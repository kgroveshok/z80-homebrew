# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 51 18			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
011c			 
011c			 
011c			;        nop  
011c			;        nop 
011c			;;	org 05h		; null out bdos call 
011c			; 
011c			;        nop  
011c			;        nop  
011c			;        nop 
011c			;;	org 08h 
011c			;;; 
011c			;;	jp cin		; rst 8 - char in 
011c			;;; 
011c			; 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;	org 010h 
011c			;; 
011c			;	jp cout		; rest 010h  - char out 
011c			;; 
011c			;	org 01bh   
011c			; 
011c			;	;jp  		; rst 01bh   - write string to display 
011c			;	jp str_at_display 
011c			; 
011c			; 
011c			;	org 020h 
011c			; 
011c			;	; jp		 ; rst 020h - read char at screen location 
011c			; 
011c			;	org 028h 
011c			 
011c				; jp		 ; rst 028h  - storage i/o 
011c			 
011c			; 	org 030h 
011c			;	jp break_point_state 
011c			  
011c			; $30  
011c			; org 038h 
011c			; $38 
011c			 
011c			; TODO any more important entry points to add to jump table for easier coding use? 
011c			 
011c			 
011c			include "firmware.asm" 
011c			  
011c			; main constants (used here and in firmware)  
011c			  
011c			; TODO have page 0 of storage as bios  
011c			  
011c			Device_A: equ 0h  
011c			Device_B: equ 040h          ; Sound  
011c			  
011c			if BASE_KEV  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_SC114  
011c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			; TODO fixup for CPM  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			Device_D: equ 0c0h             ; Keyboard and LCD  
011c			  
011c			; Odd specific debug points for testing hardware dev  
011c			  
011c			DEBUG_SOUND: equ 1  
011c			DEBUG_STK_FAULT: equ 0  
011c			DEBUG_INPUT: equ 0     ; Debug input entry code  
011c			DEBUG_KEYCINWAIT: equ 0  
011c			DEBUG_KEYCIN: equ 0  
011c			DEBUG_KEY: equ 0  
011c			DEBUG_KEY_MATRIX: equ 0  
011c			DEBUG_STORECF: equ 0  
011c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011c			DEBUG_SPI: equ 0    ; low level spi tests  
011c			  
011c			; Enable many break points  
011c			  
011c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011c			DEBUG_FORTH_JP: equ 0    ; 4  
011c			DEBUG_FORTH_MALLOC: equ 0  
011c			DEBUG_FORTH_MALLOC_INT: equ 0  
011c			DEBUG_FORTH_DOT: equ 0  
011c			DEBUG_FORTH_DOT_WAIT: equ 0  
011c			DEBUG_FORTH_MATHS: equ 0  
011c			DEBUG_FORTH_TOK: equ 0    ; 4  
011c			DEBUG_FORTH_PARSE: equ 0    ; 3  
011c			DEBUG_FORTH: equ 0  ;2  
011c			DEBUG_FORTH_WORDS: equ 1   ; 1  
011c			DEBUG_FORTH_PUSH: equ 1   ; 1  
011c			DEBUG_FORTH_UWORD: equ 1   ; 1  
011c			  
011c			; Enable key point breakpoints  
011c			  
011c			DEBUG_FORTH_DOT_KEY: equ 0  
011c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011c			  
011c			; Debug stack imbalances  
011c			  
011c			ON: equ 1  
011c			OFF: equ 0  
011c			  
011c			DEBUG_STACK_IMB: equ 0  
011c			STACK_IMB_STORE: equ 20  
011c			  
011c			; House keeping and protections  
011c			  
011c			DEBUG_FORTH_STACK_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011c			FORTH_ENABLE_FREE: equ 0  
011c			FORTH_ENABLE_MALLOCFREE: equ 1  
011c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011c			FORTH_ENABLE_FLOATMATH: equ 0  
011c			  
011c			  
011c			CALLMONITOR: macro  
011c				call break_point_state  
011c				endm  
011c			  
011c			MALLOC_1: equ 1        ; from dk88   
011c			MALLOC_2: equ 0           ; broke  
011c			MALLOC_3: equ 0           ; really broke  
011c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011c			  
011c			if BASE_KEV   
011c			stacksize: equ 256  
011c			  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 512  
011c			endif  
011c			if BASE_SC114  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			;if STORAGE_SE == 0  
011c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011c			;endif  
011c			  
011c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011c			  
011c			STORE_0_AUTORUN: equ $20  
011c			  
011c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011c			  
011c			STORE_0_AUTOFILE: equ $21  
011c			STORE_0_BANKRUN: equ $23  
011c			STORE_0_FILERUN: equ $24  
011c			  
011c			; Block 0 offsets for settings  
011c			  
011c			; if set then skip prompt for start up and accept all  
011c			  
011c			STORE_0_QUICKSTART: equ $25  
011c			  
011c			; Blocks where directory table is held  
011c			  
011c			; Reducing the number of entries increases the max file size  
011c			  
011c			;STORE_DIR_START: equ 1  
011c			;STORE_DIR_END: equ 33  
011c			  
011c			; Blocks from where file data is stored  
011c			  
011c			;STORE_DATA_START: equ STORE_DIR_END + 1  
011c			  
011c			; Block indicators (<32 are data files)  
011c			  
011c			;STORE_BLOCK_CFG: equ $8f       ; config block  
011c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011c			;STORE_BLOCK_FREE: equ $85       ; data block free  
011c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011c			  
011c			  
011c			  
011c			; Directory entry flags  
011c			  
011c			;STORE_DIR_FREE: equ 0  
011c			;STORE_DIR_FILE:  equ 1  
011c			  
011c			; Structure offsets to directory entries  
011c			;STORE_DE_FLAG: equ 0  
011c			;STORE_DE_MAXEXT: equ 1  
011c			;STORE_DE_FILENAME: equ 2  
011c			  
011c			; Structure offsets to block 0  
011c			  
011c			;STORE_BK0_ISFOR: equ 1  
011c			;STORE_BK0_LABEL: equ 3  
011c			  
011c			; memory allocation   
011c			  
011c			chk_stund: equ tos+2           ; underflow check word  
011c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011c			  
011c			; keyscan table needs rows x cols buffer  
011c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011c			  
011c			keyscan_table_row1: equ chk_stovr -key_cols-1  
011c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011c			keyscan_scancol: equ keyscan_table-key_cols  
011c			;keyscan_table_len: equ key_rows*key_cols  
011c			;keybufptr: equ keyscan_table - 2  
011c			;keysymbol: equ keybufptr - 1  
011c			key_held: equ keyscan_scancol-1	; currently held  
011c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011c			key_fa: equ key_repeat_ct -1 ;  
011c			key_fb: equ key_fa -1 ;  
011c			key_fc: equ key_fb -1 ;  
011c			key_fd: equ key_fc -1 ;  
011c			key_face_held: equ key_fd - 1   
011c			  
011c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011c			  
011c			hardware_config: equ key_face_held - 10  
011c			  
011c			; hardware config switches  
011c			; TODO add bitmasks on includes for hardware  
011c			; high byte for expansion ids  
011c			;     0000 0000  no card inserted  
011c			;     0000 0001  storage card inserted  
011c			;     0000 0010  spi sd card active  
011c			  
011c			;       
011c			; low byte:  
011c			;     0000 0001   4x4 keypad  
011c			;     0000 0010   full keyboard  
011c			;     0000 0011   spi/ext keyboard  
011c			;     0000 0100   20x4 lcd  
011c			;     0000 1000   40x4 lcd  
011c			;     0000 1100   spi/ext display  
011c			;     0001 0000   ide interface available  
011c			  
011c			hardware_word: equ hardware_config - 2  
011c			  
011c			; debug marker - optional display of debug point on the debug screens  
011c			  
011c			debug_mark: equ hardware_word - 4  
011c			  
011c			; input_str vars  
011c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011c			input_size: equ input_start -1  ; number of chars  
011c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011c			input_len: equ input_cur_onoff - 5 ; length of current input  
011c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011c			  
011c			CUR_BLINK_RATE: equ 15  
011c			  
011c			key_actual_pressed: equ input_cursor - 1   
011c			key_symbol: equ key_actual_pressed - 1   
011c			key_shift: equ key_symbol - 1   
011c			  
011c			; Display allocation  
011c			  
011c			;display_rows: equ 4     ; move out to mini and mega files  
011c			;display_cols: equ 20  
011c			  
011c			display_fb_len: equ display_rows*display_cols  
011c			  
011c			; primary frame buffer     
011c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011c			; working frame buffers  
011c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011c			display_fb3: equ  display_fb1-display_fb_len - 1  
011c			display_fb2: equ  display_fb3-display_fb_len - 1  
011c			;  
011c			; pointer to active frame buffer  
011c			display_fb_active: equ display_fb2 - 2  
011c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011c			display_write_tmp: equ display_lcde1e2 - 2  
011c			  
011c			  
011c			;  
011c			  
011c			;; can load into de directory  
011c			cursor_col: equ display_write_tmp-1  
011c			cursor_row: equ cursor_col-1  
011c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011c			  
011c			; maths vars  
011c			  
011c			LFSRSeed: equ cursor_shape -20   
011c			randData: equ LFSRSeed - 2  
011c			xrandc: equ randData - 2  
011c			stackstore: equ xrandc - 2  
011c			seed1: equ  stackstore -2   
011c			seed2: equ seed1 - 2  
011c			  
011c			; cf storage vars  
011c			  
011c			iErrorNum:  equ seed2-1         ;Error number  
011c			iErrorReg:  equ iErrorNum -1              ;Error register  
011c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011c			  
011c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011c			  
011c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011c			  
011c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011c			store_tmpid: equ store_tmp3 - 1		; page temp id  
011c			store_tmpext: equ store_tmpid - 1		; file extent temp  
011c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011c			;  
011c			; spi vars  
011c			  
011c			  
011c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011c			spi_device_id: equ spi_device - 1    ; human readable bank number  
011c			  
011c			;;;;; forth cli params  
011c			  
011c			; TODO use a different frame buffer for forth???  
011c			  
011c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011c			  
011c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011c			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
011c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011c			  
011c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011c			  
011c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011c			  
011c			; os/forth token vars  
011c			  
011c			os_last_cmd: equ os_var_array-255  
011c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011c			os_current_i: equ os_cli_cmd-2  
011c			os_cur_ptr: equ os_current_i-2  
011c			os_word_scratch: equ os_cur_ptr-30  
011c			os_tok_len: equ os_word_scratch - 2  
011c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011c			os_tok_malloc: equ os_tok_ptr - 2  
011c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011c			execscratch: equ os_input-255        ; exec cmd eval buffer  
011c			scratch: equ execscratch-255  
011c			  
011c			  
011c			; temp locations for new word processing to save on adding more   
011c			  
011c			os_new_malloc: equ scratch-2  
011c			os_new_parse_len: equ os_new_malloc - 2  
011c			os_new_word_len: equ os_new_parse_len - 2  
011c			os_new_work_ptr: equ os_new_word_len - 2  
011c			os_new_src_ptr: equ os_new_work_ptr - 2  
011c			os_new_exec: equ os_new_src_ptr - 2  
011c			os_new_exec_ptr: equ os_new_exec - 2  
011c			  
011c			; resume memory alloocations....  
011c			  
011c			os_view_disable: equ os_new_exec_ptr - 1  
011c			os_view_af: equ os_view_disable - 2  
011c			os_view_hl: equ os_view_af -2  
011c			os_view_de: equ os_view_hl - 2  
011c			os_view_bc: equ os_view_de - 2  
011c			  
011c			; stack checksum word  
011c			if DEBUG_STACK_IMB  
011c				curframe: equ  os_view_de - 5  
011c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			else  
011c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			endif  
011c			  
011c			; with data stack could see memory filled with junk. need some memory management   
011c			; malloc and free entry points added  
011c			  
011c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			;heap_end: equ free_list-1  ; Starting address of heap  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			heap_end: equ chk_word-1  ; Starting address of heap  
011c			  
011c			  
011c			;if BASE_KEV   
011c			;heap_start: equ 0800eh  ; Starting address of heap  
011c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;heap_start: equ baseram+15  ; Starting address of heap  
011c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;endif  
011c			  
011c			  
011c			;;;;  
011c			  
011c			  
011c			; change below to point to last memory alloc above  
011c			topusermem:  equ   heap_start  
011c			  
011c			;if BASE_KEV   
011c			;baseusermem: equ 08000h  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;;aseusermem:     equ    12  
011c			;baseusermem:     equ    prompt  
011c			;;baseusermem:     equ    endofcode  
011c			;endif  
011c			  
011c			  
011c			; **********************************************************************  
011c			; **  Constants  
011c			; **********************************************************************  
011c			  
011c			; Constants used by this code module  
011c			kDataReg:   EQU Device_D           ;PIO port A data register  
011c			kContReg:   EQU Device_D+2           ;PIO port A control register  
011c			  
011c			  
011c			portbdata:  equ Device_D+1    ; port b data  
011c			portbctl:   equ Device_D+3    ; port b control  
011c			  
011c			  
011c			;KEY_SHIFT:   equ 5  
011c			;KEY_SYMBOLSHIFT:  equ 6  
011c			  
011c			KEY_SHIFTLOCK: equ 4  
011c			  
011c			  
011c			KEY_UP: equ 5  
011c			KEY_NEXTWORD: equ 6  
011c			KEY_PREVWORD: equ 7  
011c			KEY_BS: equ 8  
011c			KEY_TAB:  equ 9  
011c			KEY_DOWN: equ 10  
011c			KEY_LEFT: equ 11  
011c			KEY_RIGHT: equ 12  
011c			KEY_CR:   equ 13  
011c			KEY_HOME: equ 14  
011c			KEY_END: equ 15  
011c			  
011c			KEY_F1: equ 16  
011c			KEY_F2: equ 17  
011c			KEY_F3: equ 18  
011c			KEY_F4: equ 19  
011c			  
011c			KEY_F5: equ 20  
011c			KEY_F6: equ 21  
011c			KEY_F7: equ 22  
011c			KEY_F8: equ 23  
011c			  
011c			KEY_F9: equ 24  
011c			KEY_F10: equ 25  
011c			KEY_F11: equ 26  
011c			KEY_F12: equ 27  
011c			  
011c			;if DEBUG_KEY  
011c			;	KEY_MATRIX_NO_PRESS: equ '.'  
011c			;	KEY_SHIFT:   equ '.'  
011c			;	KEY_SYMBOLSHIFT:  equ '.'  
011c			;else  
011c				KEY_SHIFT:   equ '~'  
011c				KEY_SYMBOLSHIFT:  equ '~'  
011c				KEY_MATRIX_NO_PRESS: equ '~'  
011c			;endi  
011c			  
011c			  
011c			  
011c			  
011c			; Macro to make adding debug marks easier  
011c			  
011c			DMARK: macro str  
011c				push af  
011c				ld a, (.dmark)  
011c				ld (debug_mark),a  
011c				ld a, (.dmark+1)  
011c				ld (debug_mark+1),a  
011c				ld a, (.dmark+2)  
011c				ld (debug_mark+2),a  
011c				jr .pastdmark  
011c			.dmark: db str  
011c			.pastdmark: pop af  
011c			  
011c			endm  
011c			  
011c			  
011c			; macro to detect for stack imbalances  
011c			  
011c			include "stackimbal.asm"  
011c			; Macro and code to detect stock imbalances 
011c			 
011c			SPPUSH: equ 0 
011c			 
011c			; Add a stack frame which can be checked before return 
011c			 
011c			STACKFRAME: macro onoff frame1 frame2 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c						exx 
011c			 
011c						ld de, frame1 
011c						ld a, d 
011c						ld hl, curframe 
011c						call hexout 
011c						ld a, e 
011c						ld hl, curframe+2 
011c						call hexout 
011c			  
011c						ld hl, frame1 
011c						push hl 
011c						ld hl, frame2 
011c						push hl 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			endm 
011c			 
011c			STACKFRAMECHK: macro onoff frame1 frame2 
011c			 
011c					 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						exx 
011c						; check stack frame SP 
011c			 
011c						ld hl, frame2 
011c						pop de   ; frame2 
011c			 
011c						call cmp16 
011c						jr nz, .spnosame 
011c						 
011c			 
011c						ld hl, frame1 
011c						pop de   ; frame1 
011c			 
011c						call cmp16 
011c						jr z, .spfrsame 
011c			 
011c						.spnosame: call showsperror 
011c			 
011c						.spfrsame: nop 
011c			 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			 
011c			 
011c			endm 
011c			 
011c			 
011c			; for a sub routine, wrap SP collection and comparisons 
011c			 
011c			; Usage: 
011c			; 
011c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011c			 
011c			SAVESP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c			 
011c						ld (store_sp+(storeword*4)), sp 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			CHECKSP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c			 
011c						; save SP after last save 
011c				 
011c						ld (store_sp+(storeword*4)+2), sp 
011c			 
011c						push hl 
011c						ld hl, store_sp+(storeword*4) 
011c						call check_stack_sp  
011c						pop hl 
011c			 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			if DEBUG_STACK_IMB 
011c			 
011c			check_stack_sp: 
011c					push de 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					push de 
011c			 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					pop hl 
011c			 
011c			 
011c					; check to see if the same 
011c			 
011c					call cmp16 
011c					jr z, .spsame 
011c			 
011c					; not same 
011c			 
011c					call showsperror 
011c			.spsame: 
011c			 
011c					pop de 
011c			 
011c					ret 
011c			 
011c			.sperr:  db "Stack imbalance",0 
011c			 
011c			 
011c			showsperror: 
011c			 
011c			 
011c				push hl 
011c				push af 
011c				push de 
011c				call clear_display 
011c				ld de, .sperr 
011c				ld a,0 
011c			;	ld de,os_word_scratch 
011c				call str_at_display 
011c				ld a, display_row_1+17 
011c				ld de, debug_mark 
011c				call str_at_display 
011c				ld a, 0 
011c				ld (curframe+4),a 
011c				ld hl, curframe 
011c				ld de, os_word_scratch 
011c				ld a, display_row_4 
011c				call str_at_display 
011c				call update_display 
011c				;call break_point_state 
011c				call cin_wait 
011c			 
011c				ld a, ' ' 
011c				ld (os_view_disable), a 
011c				pop de	 
011c				pop af 
011c				pop hl 
011c				CALLMONITOR 
011c				ret 
011c			 
011c			endif 
011c			 
011c			 
011c			 
011c			; eof 
# End of file stackimbal.asm
011c			  
011c			;TODO macro to calc col and row offset into screen  
011c			  
011c			  
011c			  
011c			hardware_init:  
011c			  
011c				  
011c			  
011c					;ld a, 0  
011c					;ld (hardware_diag), a  
011c			  
011c					; clear all the buffers  
011c			  
011c 21 16 ed				ld hl, display_fb1  
011f 22 d2 eb				ld (display_fb_active), hl  
0122			  
0122 cd 80 0b				call clear_display  
0125			  
0125 21 d4 eb				ld hl, display_fb2  
0128 22 d2 eb				ld (display_fb_active), hl  
012b			  
012b cd 80 0b				call clear_display  
012e			  
012e					; init primary frame buffer area  
012e 21 b7 ed				ld hl, display_fb0  
0131 22 d2 eb				ld (display_fb_active), hl  
0134			  
0134 cd 80 0b				call clear_display  
0137			  
0137			  
0137 cd 03 5e				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013a			  
013a cd f1 5e			call key_init  
013d cd 9f 01			call storage_init  
0140			  
0140				; setup malloc functions  
0140			  
0140				if MALLOC_1  
0140 cd 50 12				call  heap_init  
0143				endif  
0143				if MALLOC_4  
0143					call  heap_init  
0143				endif  
0143			  
0143				; init sound hardware if present  
0143			  
0143				if SOUND_ENABLE  
0143					call sound_init  
0143				endif  
0143			  
0143				; lcd test sequence  
0143					  
0143 cd a3 0b			call update_display  
0146 cd f2 0a			call delay1s  
0149 3e 2b			ld a,'+'  
014b cd 85 0b			call fill_display  
014e cd a3 0b			call update_display  
0151 cd f2 0a			call delay1s  
0154 3e 2a			ld a,'*'  
0156 cd 85 0b			call fill_display  
0159 cd a3 0b			call update_display  
015c cd f2 0a			call delay1s  
015f 3e 2d			ld a,'-'  
0161 cd 85 0b			call fill_display  
0164 cd a3 0b			call update_display  
0167 cd f2 0a			call delay1s  
016a			  
016a			; boot splash screen  
016a			if display_cols == 20	  
016a			        ld a, display_row_1    
016a			else  
016a 3e 0a		        ld a, display_row_1 +10   
016c			endif  
016c 11 84 17			ld de, prom_bootmsg  
016f cd 93 0b			call str_at_display  
0172 cd a3 0b			call update_display  
0175			  
0175			  
0175 cd f2 0a			call delay1s  
0178 cd f2 0a			call delay1s  
017b			if display_cols == 20	  
017b			            LD   A, display_row_3+2  
017b			else  
017b 3e 5c		            LD   A, display_row_3+12  
017d			endif  
017d 11 99 17			ld de, prom_bootmsg1  
0180 cd 93 0b			call str_at_display  
0183 cd a3 0b			call update_display  
0186 cd f2 0a			call delay1s  
0189 cd f2 0a			call delay1s  
018c			  
018c			;	ld a, display_row_4+3  
018c			;	ld de, bootmsg2  
018c			;	call str_at_display  
018c			;	call update_display  
018c			;	call delay1s  
018c			;	call delay1s  
018c			  
018c			; debug mark setup  
018c			  
018c 3e 5f		ld a, '_'  
018e 32 71 ee		ld (debug_mark),a  
0191 32 72 ee		ld (debug_mark+1),a  
0194 32 73 ee		ld (debug_mark+2),a  
0197 3e 00		ld a,0  
0199 32 74 ee		ld (debug_mark+3),a  
019c			  
019c c9					ret  
019d			  
019d			  
019d			;bootmsg2:	db "Firmware v0.1",0  
019d			  
019d			; a 4x20 lcd  
019d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019d			  
019d			;if display_cols == 20  
019d			;	include "firmware_lcd_4x20.asm"  
019d			;endif  
019d			  
019d			;if display_cols == 40  
019d			;	include "firmware_lcd_4x40.asm"  
019d			;endif  
019d			  
019d			;  
019d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019d			; TODO abstract the bit bang video out interface for dual display  
019d			; TODO wire video out to tx pin on rc2014 bus  
019d			  
019d			; must supply cin, and cin_wait for low level hardware abstraction   
019d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019d			; test scancode  
019d			  
019d			;;;;;  
019d			;;;  
019d			; Moved out to mini and maxi versions  
019d			;  
019d			; include "firmware_key_4x4.asm"  
019d			; using existing 4 wire x 4 resistor array for input  
019d			;include "firmware_key_4x10.asm"  
019d			; need to mod the board for 5 rows due to resistor array  
019d			;include "firmware_key_5x10.asm"  
019d			  
019d			; storage hardware interface  
019d			  
019d			; use microchip serial eeprom for storage  
019d			  
019d			  
019d			if STORAGE_SE  
019d				include "firmware_spi.asm"  
019d				include "firmware_seeprom.asm"  
019d			else  
019d			   ; create some stubs for the labels  
019d c9			se_readbyte: ret  
019e c9			se_writebyte: ret  
019f c9			storage_init: ret  
01a0			  
01a0			endif  
01a0			  
01a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01a0			;include "firmware_cf.asm"  
01a0			  
01a0			; load up high level storage hardward abstractions  
01a0			include "firmware_storage.asm"  
01a0			 
01a0			; persisent storage hardware abstraction layer  
01a0			 
01a0			 
01a0			 
01a0			; Block 0 on storage is a config state 
01a0			 
01a0			 
01a0			 
01a0			; TODO add read phy block and write phy block functions 
01a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01a0			 
01a0			; Abstraction layer  
01a0			 
01a0			; Logocial block size is same size as physical size - using tape concept 
01a0			 
01a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01a0			 
01a0			 
01a0			 
01a0			; Filesystem layout (Logical layout) 
01a0			; 
01a0			; Block 0 - Bank config  
01a0			; 
01a0			;      Byte - 0 file id counter 
01a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01a0			;      Byte - 3-20 zero terminated bank label 
01a0			; 
01a0			; Block 1 > File storage 
01a0			; 
01a0			;      Byte 0 file id    - block 0 file details 
01a0			;      Byte 1 block id - block 0 is file  
01a0			;            Byte 2-15 - File name 
01a0			; 
01a0			;       - to end of block data 
01a0			; 
01a0			 
01a0			; Get ID for the file named in pointer held HL 
01a0			; Returns ID in HL = 255 if no file found 
01a0			 
01a0			storage_getid: 
01a0			 
01a0 22 7d ea			ld (store_tmp1), hl 
01a3			 
01a3				if DEBUG_STORESE 
01a3					DMARK "SGI" 
01a3 f5				push af  
01a4 3a b8 01			ld a, (.dmark)  
01a7 32 71 ee			ld (debug_mark),a  
01aa 3a b9 01			ld a, (.dmark+1)  
01ad 32 72 ee			ld (debug_mark+1),a  
01b0 3a ba 01			ld a, (.dmark+2)  
01b3 32 73 ee			ld (debug_mark+2),a  
01b6 18 03			jr .pastdmark  
01b8 ..			.dmark: db "SGI"  
01bb f1			.pastdmark: pop af  
01bc			endm  
# End of macro DMARK
01bc					CALLMONITOR 
01bc cd ae 15			call break_point_state  
01bf				endm  
# End of macro CALLMONITOR
01bf				endif 
01bf				; get block 0 and set counter for number of files to scan 
01bf			 
01bf cd 2a 03			call storage_get_block_0 
01c2			 
01c2 3a 84 ea			ld a, (store_page) 
01c5 47				ld b, a 
01c6			 
01c6				; get extent 0 of each file id 
01c6			 
01c6				if DEBUG_STORESE 
01c6					DMARK "SGc" 
01c6 f5				push af  
01c7 3a db 01			ld a, (.dmark)  
01ca 32 71 ee			ld (debug_mark),a  
01cd 3a dc 01			ld a, (.dmark+1)  
01d0 32 72 ee			ld (debug_mark+1),a  
01d3 3a dd 01			ld a, (.dmark+2)  
01d6 32 73 ee			ld (debug_mark+2),a  
01d9 18 03			jr .pastdmark  
01db ..			.dmark: db "SGc"  
01de f1			.pastdmark: pop af  
01df			endm  
# End of macro DMARK
01df					CALLMONITOR 
01df cd ae 15			call break_point_state  
01e2				endm  
# End of macro CALLMONITOR
01e2				endif 
01e2 60			.getloop:	ld h, b 
01e3 2e 00				ld l, 0 
01e5 c5					push bc 
01e6			 
01e6 11 84 ea				ld de, store_page 
01e9				if DEBUG_STORESE 
01e9					DMARK "SGr" 
01e9 f5				push af  
01ea 3a fe 01			ld a, (.dmark)  
01ed 32 71 ee			ld (debug_mark),a  
01f0 3a ff 01			ld a, (.dmark+1)  
01f3 32 72 ee			ld (debug_mark+1),a  
01f6 3a 00 02			ld a, (.dmark+2)  
01f9 32 73 ee			ld (debug_mark+2),a  
01fc 18 03			jr .pastdmark  
01fe ..			.dmark: db "SGr"  
0201 f1			.pastdmark: pop af  
0202			endm  
# End of macro DMARK
0202					CALLMONITOR 
0202 cd ae 15			call break_point_state  
0205				endm  
# End of macro CALLMONITOR
0205				endif 
0205 cd d2 07				call storage_read 
0208 cd d6 0d				call ishlzero 
020b 28 2d				jr z, .gap 
020d					 
020d					; have a file name read. Is it one we want. 
020d			 
020d 2a 7d ea				ld hl, (store_tmp1) 
0210 11 87 ea				ld de, store_page+3   ; file name 
0213			 
0213				if DEBUG_STORESE 
0213					DMARK "SGc" 
0213 f5				push af  
0214 3a 28 02			ld a, (.dmark)  
0217 32 71 ee			ld (debug_mark),a  
021a 3a 29 02			ld a, (.dmark+1)  
021d 32 72 ee			ld (debug_mark+1),a  
0220 3a 2a 02			ld a, (.dmark+2)  
0223 32 73 ee			ld (debug_mark+2),a  
0226 18 03			jr .pastdmark  
0228 ..			.dmark: db "SGc"  
022b f1			.pastdmark: pop af  
022c			endm  
# End of macro DMARK
022c					CALLMONITOR 
022c cd ae 15			call break_point_state  
022f				endm  
# End of macro CALLMONITOR
022f				endif 
022f cd 43 12				call strcmp 
0232 20 06				jr nz, .gap   ; not this one 
0234			 
0234 c1				        pop bc 
0235			 
0235 26 00				ld h, 0 
0237 68					ld l, b 
0238 18 22				jr .getdone 
023a						 
023a			 
023a			 
023a			 
023a			.gap: 
023a				if DEBUG_STORESE 
023a					DMARK "SGg" 
023a f5				push af  
023b 3a 4f 02			ld a, (.dmark)  
023e 32 71 ee			ld (debug_mark),a  
0241 3a 50 02			ld a, (.dmark+1)  
0244 32 72 ee			ld (debug_mark+1),a  
0247 3a 51 02			ld a, (.dmark+2)  
024a 32 73 ee			ld (debug_mark+2),a  
024d 18 03			jr .pastdmark  
024f ..			.dmark: db "SGg"  
0252 f1			.pastdmark: pop af  
0253			endm  
# End of macro DMARK
0253					CALLMONITOR 
0253 cd ae 15			call break_point_state  
0256				endm  
# End of macro CALLMONITOR
0256				endif 
0256			 
0256 c1					pop bc 
0257 10 89				djnz .getloop 
0259 21 ff 00				ld hl, 255 
025c			.getdone: 
025c			 
025c				if DEBUG_STORESE 
025c					DMARK "SGe" 
025c f5				push af  
025d 3a 71 02			ld a, (.dmark)  
0260 32 71 ee			ld (debug_mark),a  
0263 3a 72 02			ld a, (.dmark+1)  
0266 32 72 ee			ld (debug_mark+1),a  
0269 3a 73 02			ld a, (.dmark+2)  
026c 32 73 ee			ld (debug_mark+2),a  
026f 18 03			jr .pastdmark  
0271 ..			.dmark: db "SGe"  
0274 f1			.pastdmark: pop af  
0275			endm  
# End of macro DMARK
0275					CALLMONITOR 
0275 cd ae 15			call break_point_state  
0278				endm  
# End of macro CALLMONITOR
0278				endif 
0278			 
0278 c9				ret 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			; Read Block 
0279			; ---------- 
0279			; 
0279			; With current bank 
0279			;  
0279			; Get block number to read 
0279			; Load physical blocks starting at start block into buffer 
0279			 
0279			; de points to buffer to use 
0279			; hl holds logical block number  
0279			 
0279			storage_read_block: 
0279			 
0279				; TODO bank selection 
0279			 
0279				; for each of the physical blocks read it into the buffer 
0279 06 40			ld b, STORE_BLOCK_PHY 
027b			 
027b				if DEBUG_STORESE 
027b d5					push de 
027c				endif 
027c				 
027c			.rl1:    
027c			 
027c				; read physical block at hl into de 
027c			        ; increment hl and de to next read position on exit 
027c			 
027c e5				push hl 
027d d5				push de	 
027e c5				push bc 
027f			;	if DEBUG_STORESE 
027f			;		push af 
027f			;		ld a, 'R' 
027f			;		ld (debug_mark),a 
027f			;		pop af 
027f			;		CALLMONITOR 
027f			;	endif 
027f cd 9d 01			call se_readbyte 
0282			;	if DEBUG_STORESE 
0282			;		ld a,(spi_portbyte) 
0282			;		ld l, a 
0282			;		push af 
0282			;		ld a, '1' 
0282			;		ld (debug_mark),a 
0282			;		pop af 
0282			;		CALLMONITOR 
0282			;	endif 
0282 c1				pop bc 
0283 d1				pop de 
0284 e1				pop hl 
0285 12				ld (de),a 
0286 23				inc hl 
0287 13				inc de 
0288			 
0288			;	if DEBUG_STORESE 
0288			;		push af 
0288			;		ld a, 'r' 
0288			;		ld (debug_mark),a 
0288			;		pop af 
0288			;		CALLMONITOR 
0288			;	endif 
0288			 
0288 10 f2			djnz .rl1 
028a			 
028a				if DEBUG_STORESE 
028a					DMARK "SRB" 
028a f5				push af  
028b 3a 9f 02			ld a, (.dmark)  
028e 32 71 ee			ld (debug_mark),a  
0291 3a a0 02			ld a, (.dmark+1)  
0294 32 72 ee			ld (debug_mark+1),a  
0297 3a a1 02			ld a, (.dmark+2)  
029a 32 73 ee			ld (debug_mark+2),a  
029d 18 03			jr .pastdmark  
029f ..			.dmark: db "SRB"  
02a2 f1			.pastdmark: pop af  
02a3			endm  
# End of macro DMARK
02a3 d1					pop de 
02a4			; 
02a4			;		push af 
02a4			;		ld a, 'R' 
02a4			;		ld (debug_mark),a 
02a4			;		pop af 
02a4					CALLMONITOR 
02a4 cd ae 15			call break_point_state  
02a7				endm  
# End of macro CALLMONITOR
02a7				endif 
02a7 c9				ret	 
02a8				 
02a8			 
02a8			; File Size 
02a8			; --------- 
02a8			; 
02a8			;   hl file id 
02a8			; 
02a8			;  returns in hl the number of blocks 
02a8			 
02a8			storage_file_size: 
02a8 5d				ld e, l 
02a9 16 00			ld d, 0 
02ab 21 40 00			ld hl, STORE_BLOCK_PHY 
02ae					if DEBUG_FORTH_WORDS 
02ae						DMARK "SIZ" 
02ae f5				push af  
02af 3a c3 02			ld a, (.dmark)  
02b2 32 71 ee			ld (debug_mark),a  
02b5 3a c4 02			ld a, (.dmark+1)  
02b8 32 72 ee			ld (debug_mark+1),a  
02bb 3a c5 02			ld a, (.dmark+2)  
02be 32 73 ee			ld (debug_mark+2),a  
02c1 18 03			jr .pastdmark  
02c3 ..			.dmark: db "SIZ"  
02c6 f1			.pastdmark: pop af  
02c7			endm  
# End of macro DMARK
02c7						CALLMONITOR 
02c7 cd ae 15			call break_point_state  
02ca				endm  
# End of macro CALLMONITOR
02ca					endif 
02ca cd ac 05			call storage_findnextid 
02cd			 
02cd cd d6 0d			call ishlzero 
02d0			;	ld a, l 
02d0			;	add h 
02d0			;	cp 0 
02d0 c8				ret z			; block not found so EOF 
02d1			 
02d1 11 84 ea			ld de, store_page 
02d4 cd 79 02			call storage_read_block 
02d7			 
02d7 3a 86 ea			ld a, (store_page+2)	 ; get extent count 
02da 6f				ld l, a 
02db 26 00			ld h, 0 
02dd c9			 	ret 
02de			 
02de			 
02de			; Write Block 
02de			; ----------- 
02de			; 
02de			; With current bank 
02de			;  
02de			; Get block number to write 
02de			; Write physical blocks starting at start block from buffer 
02de			  
02de			storage_write_block: 
02de				; TODO bank selection 
02de			 
02de				; for each of the physical blocks read it into the buffer 
02de 06 40			ld b, STORE_BLOCK_PHY 
02e0			 
02e0				if DEBUG_STORESE 
02e0					DMARK "SWB" 
02e0 f5				push af  
02e1 3a f5 02			ld a, (.dmark)  
02e4 32 71 ee			ld (debug_mark),a  
02e7 3a f6 02			ld a, (.dmark+1)  
02ea 32 72 ee			ld (debug_mark+1),a  
02ed 3a f7 02			ld a, (.dmark+2)  
02f0 32 73 ee			ld (debug_mark+2),a  
02f3 18 03			jr .pastdmark  
02f5 ..			.dmark: db "SWB"  
02f8 f1			.pastdmark: pop af  
02f9			endm  
# End of macro DMARK
02f9			 
02f9					;push af 
02f9					;ld a, 'W' 
02f9					;ld (debug_mark),a 
02f9					;pop af 
02f9					CALLMONITOR 
02f9 cd ae 15			call break_point_state  
02fc				endm  
# End of macro CALLMONITOR
02fc				endif 
02fc			 
02fc			; might not be working 
02fc			;	call se_writepage 
02fc			 
02fc			;	ret 
02fc			; 
02fc			 
02fc			 
02fc			 
02fc			.wl1:    
02fc			 
02fc				; read physical block at hl into de 
02fc			        ; increment hl and de to next read position on exit 
02fc			 
02fc e5				push hl 
02fd d5				push de	 
02fe c5				push bc 
02ff 1a				ld a,(de) 
0300				;if DEBUG_STORESE 
0300			;		push af 
0300			;		ld a, 'W' 
0300			;		ld (debug_mark),a 
0300			;		pop af 
0300			;		CALLMONITOR 
0300			;	endif 
0300 cd 9e 01			call se_writebyte 
0303			;	call delay250ms 
0303 00				nop 
0304 00				nop 
0305 00				nop 
0306			;	if DEBUG_STORESE 
0306			;		push af 
0306			;		ld a, 'w' 
0306			;		ld (debug_mark),a 
0306			;		pop af 
0306			;		CALLMONITOR 
0306			;	endif 
0306 c1				pop bc 
0307 d1				pop de 
0308 e1				pop hl 
0309 23				inc hl 
030a 13				inc de 
030b			 
030b			 
030b 10 ef			djnz .wl1 
030d			 
030d				if DEBUG_STORESE 
030d					DMARK "SW2" 
030d f5				push af  
030e 3a 22 03			ld a, (.dmark)  
0311 32 71 ee			ld (debug_mark),a  
0314 3a 23 03			ld a, (.dmark+1)  
0317 32 72 ee			ld (debug_mark+1),a  
031a 3a 24 03			ld a, (.dmark+2)  
031d 32 73 ee			ld (debug_mark+2),a  
0320 18 03			jr .pastdmark  
0322 ..			.dmark: db "SW2"  
0325 f1			.pastdmark: pop af  
0326			endm  
# End of macro DMARK
0326			 
0326					;push af 
0326					;ld a, 'W' 
0326					;ld (debug_mark),a 
0326					;pop af 
0326					CALLMONITOR 
0326 cd ae 15			call break_point_state  
0329				endm  
# End of macro CALLMONITOR
0329				endif 
0329 c9				ret	 
032a			 
032a			; Init bank 
032a			; --------- 
032a			; 
032a			; With current bank 
032a			; 
032a			; Setup block 0 config 
032a			;     Set 0 file id counter 
032a			;     Set formatted byte pattern 
032a			;     Zero out bank label 
032a			;      
032a			; For every logical block write 0-1 byte as null 
032a			 
032a			storage_get_block_0: 
032a			 
032a				; TODO check presence 
032a			 
032a				; get block 0 config 
032a			 
032a 21 00 00			ld hl, 0 
032d 11 84 ea			ld de, store_page 
0330 cd 79 02			call storage_read_block 
0333			 
0333				if DEBUG_STORESE 
0333					DMARK "SB0" 
0333 f5				push af  
0334 3a 48 03			ld a, (.dmark)  
0337 32 71 ee			ld (debug_mark),a  
033a 3a 49 03			ld a, (.dmark+1)  
033d 32 72 ee			ld (debug_mark+1),a  
0340 3a 4a 03			ld a, (.dmark+2)  
0343 32 73 ee			ld (debug_mark+2),a  
0346 18 03			jr .pastdmark  
0348 ..			.dmark: db "SB0"  
034b f1			.pastdmark: pop af  
034c			endm  
# End of macro DMARK
034c 11 84 ea				ld de, store_page 
034f			;		push af 
034f			;		ld a, 'i' 
034f			;		ld (debug_mark),a 
034f			;		pop af 
034f					CALLMONITOR 
034f cd ae 15			call break_point_state  
0352				endm  
# End of macro CALLMONITOR
0352				endif 
0352			 
0352				; is this area formatted? 
0352			 
0352			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0352 2a 85 ea			ld hl, (store_page+1) 
0355 3e 80			ld a,0x80 
0357 bd				cp l 
0358 20 22			jr nz, .ininotformatted 
035a				; do a double check 
035a 3e 27			ld a, 0x27 
035c bc				cp h 
035d 20 1d			jr nz, .ininotformatted 
035f			 
035f				; formatted then 
035f			 
035f				if DEBUG_STORESE 
035f					DMARK "SB1" 
035f f5				push af  
0360 3a 74 03			ld a, (.dmark)  
0363 32 71 ee			ld (debug_mark),a  
0366 3a 75 03			ld a, (.dmark+1)  
0369 32 72 ee			ld (debug_mark+1),a  
036c 3a 76 03			ld a, (.dmark+2)  
036f 32 73 ee			ld (debug_mark+2),a  
0372 18 03			jr .pastdmark  
0374 ..			.dmark: db "SB1"  
0377 f1			.pastdmark: pop af  
0378			endm  
# End of macro DMARK
0378					;push af 
0378					;ld a, 'I' 
0378					;ld (debug_mark),a 
0378					;pop af 
0378					CALLMONITOR 
0378 cd ae 15			call break_point_state  
037b				endm  
# End of macro CALLMONITOR
037b				endif 
037b c9				ret 
037c			 
037c			.ininotformatted: 
037c				; bank not formatted so poke various bits to make sure 
037c			 
037c				if DEBUG_STORESE 
037c					DMARK "SB2" 
037c f5				push af  
037d 3a 91 03			ld a, (.dmark)  
0380 32 71 ee			ld (debug_mark),a  
0383 3a 92 03			ld a, (.dmark+1)  
0386 32 72 ee			ld (debug_mark+1),a  
0389 3a 93 03			ld a, (.dmark+2)  
038c 32 73 ee			ld (debug_mark+2),a  
038f 18 03			jr .pastdmark  
0391 ..			.dmark: db "SB2"  
0394 f1			.pastdmark: pop af  
0395			endm  
# End of macro DMARK
0395					;push af 
0395					;ld a, 'f' 
0395					;ld (debug_mark),a 
0395					;pop af 
0395					CALLMONITOR 
0395 cd ae 15			call break_point_state  
0398				endm  
# End of macro CALLMONITOR
0398				endif 
0398			 
0398 cd b5 0a			call storage_clear_page 
039b			 
039b 21 84 ea			ld hl, store_page 
039e 3e 00			ld a, 0 
03a0				 
03a0 77				ld (hl),a   ; reset file counter 
03a1			 
03a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a4 22 85 ea		 	ld (store_page+1), hl	 
03a7			 
03a7				; set default label 
03a7			 
03a7 21 43 04			ld hl, .defaultbanklabl 
03aa 11 87 ea		 	ld de, store_page+3 
03ad 01 0f 00			ld bc, 15 
03b0 ed b0			ldir 
03b2			 
03b2				; Append the current bank id 
03b2 21 90 ea			ld hl, store_page+3+9 
03b5 3a 69 ea			ld a, (spi_device_id) 
03b8 77				ld (hl), a 
03b9			 
03b9				; save default page 0 
03b9			 
03b9 21 00 00			ld hl, 0 
03bc 11 84 ea			ld de, store_page 
03bf				if DEBUG_STORESE 
03bf					DMARK "SB3" 
03bf f5				push af  
03c0 3a d4 03			ld a, (.dmark)  
03c3 32 71 ee			ld (debug_mark),a  
03c6 3a d5 03			ld a, (.dmark+1)  
03c9 32 72 ee			ld (debug_mark+1),a  
03cc 3a d6 03			ld a, (.dmark+2)  
03cf 32 73 ee			ld (debug_mark+2),a  
03d2 18 03			jr .pastdmark  
03d4 ..			.dmark: db "SB3"  
03d7 f1			.pastdmark: pop af  
03d8			endm  
# End of macro DMARK
03d8			;		push af 
03d8			;		ld a, 'F' 
03d8			;		ld (debug_mark),a 
03d8			;		pop af 
03d8					CALLMONITOR 
03d8 cd ae 15			call break_point_state  
03db				endm  
# End of macro CALLMONITOR
03db				endif 
03db cd de 02			call storage_write_block 
03de				if DEBUG_STORESE 
03de					DMARK "SB4" 
03de f5				push af  
03df 3a f3 03			ld a, (.dmark)  
03e2 32 71 ee			ld (debug_mark),a  
03e5 3a f4 03			ld a, (.dmark+1)  
03e8 32 72 ee			ld (debug_mark+1),a  
03eb 3a f5 03			ld a, (.dmark+2)  
03ee 32 73 ee			ld (debug_mark+2),a  
03f1 18 03			jr .pastdmark  
03f3 ..			.dmark: db "SB4"  
03f6 f1			.pastdmark: pop af  
03f7			endm  
# End of macro DMARK
03f7			;		push af 
03f7			;		ld a, '>' 
03f7			;		ld (debug_mark),a 
03f7			;		pop af 
03f7					CALLMONITOR 
03f7 cd ae 15			call break_point_state  
03fa				endm  
# End of macro CALLMONITOR
03fa				endif 
03fa			 
03fa 00				nop 
03fb 00				nop 
03fc 00				nop 
03fd			 
03fd				; now set 0 in every page to mark as a free block 
03fd			 
03fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03ff 21 40 00			ld hl, STORE_BLOCK_PHY 
0402			 
0402 3e 00		.setmark1:   	ld a,0 
0404 e5					push hl 
0405 c5					push bc 
0406 cd 9e 01				call se_writebyte 
0409 3e 0a			ld a, 10 
040b cd d7 0a			call aDelayInMS 
040e 23				inc hl 
040f cd 9e 01				call se_writebyte 
0412 3e 0a			ld a, 10 
0414 cd d7 0a			call aDelayInMS 
0417 2b				dec hl 
0418 c1					pop bc 
0419 e1					pop hl 
041a 3e 40				ld a, STORE_BLOCK_PHY 
041c cd ad 0d				call addatohl 
041f 10 e1				djnz .setmark1 
0421			 
0421 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0423 3e 00		.setmark2:   	ld a,0 
0425 e5					push hl 
0426 c5					push bc 
0427 cd 9e 01				call se_writebyte 
042a 3e 0a			ld a, 10 
042c cd d7 0a			call aDelayInMS 
042f 23				inc hl 
0430 cd 9e 01				call se_writebyte 
0433 3e 0a			ld a, 10 
0435 cd d7 0a			call aDelayInMS 
0438 2b				dec hl 
0439 c1					pop bc 
043a e1					pop hl 
043b 3e 40				ld a, STORE_BLOCK_PHY 
043d cd ad 0d				call addatohl 
0440 10 e1				djnz .setmark2 
0442			 
0442					 
0442			 
0442			 
0442 c9				ret 
0443			 
0443			 
0443			 
0443			 
0443 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044e			 
044e			 
044e			 
044e			; Label Bank 
044e			; ---------- 
044e			; 
044e			; With current bank 
044e			; Read block 0 
044e			; Set label 
044e			; Write block 0 
044e			 
044e			; label str pointer in hl 
044e			 
044e			storage_label:     
044e			 
044e				if DEBUG_STORESE 
044e					DMARK "LBL" 
044e f5				push af  
044f 3a 63 04			ld a, (.dmark)  
0452 32 71 ee			ld (debug_mark),a  
0455 3a 64 04			ld a, (.dmark+1)  
0458 32 72 ee			ld (debug_mark+1),a  
045b 3a 65 04			ld a, (.dmark+2)  
045e 32 73 ee			ld (debug_mark+2),a  
0461 18 03			jr .pastdmark  
0463 ..			.dmark: db "LBL"  
0466 f1			.pastdmark: pop af  
0467			endm  
# End of macro DMARK
0467					CALLMONITOR 
0467 cd ae 15			call break_point_state  
046a				endm  
# End of macro CALLMONITOR
046a				endif 
046a			 
046a e5				push hl 
046b			 
046b cd 2a 03			call storage_get_block_0 
046e			 
046e				; set default label 
046e			 
046e e1				pop hl 
046f			 
046f 11 87 ea		 	ld de, store_page+3 
0472 01 0f 00			ld bc, 15 
0475				if DEBUG_STORESE 
0475					DMARK "LB3" 
0475 f5				push af  
0476 3a 8a 04			ld a, (.dmark)  
0479 32 71 ee			ld (debug_mark),a  
047c 3a 8b 04			ld a, (.dmark+1)  
047f 32 72 ee			ld (debug_mark+1),a  
0482 3a 8c 04			ld a, (.dmark+2)  
0485 32 73 ee			ld (debug_mark+2),a  
0488 18 03			jr .pastdmark  
048a ..			.dmark: db "LB3"  
048d f1			.pastdmark: pop af  
048e			endm  
# End of macro DMARK
048e					CALLMONITOR 
048e cd ae 15			call break_point_state  
0491				endm  
# End of macro CALLMONITOR
0491				endif 
0491 ed b0			ldir 
0493				; save default page 0 
0493			 
0493 21 00 00			ld hl, 0 
0496 11 84 ea			ld de, store_page 
0499				if DEBUG_STORESE 
0499					DMARK "LBW" 
0499 f5				push af  
049a 3a ae 04			ld a, (.dmark)  
049d 32 71 ee			ld (debug_mark),a  
04a0 3a af 04			ld a, (.dmark+1)  
04a3 32 72 ee			ld (debug_mark+1),a  
04a6 3a b0 04			ld a, (.dmark+2)  
04a9 32 73 ee			ld (debug_mark+2),a  
04ac 18 03			jr .pastdmark  
04ae ..			.dmark: db "LBW"  
04b1 f1			.pastdmark: pop af  
04b2			endm  
# End of macro DMARK
04b2					CALLMONITOR 
04b2 cd ae 15			call break_point_state  
04b5				endm  
# End of macro CALLMONITOR
04b5				endif 
04b5 cd de 02			call storage_write_block 
04b8			 
04b8 c9				ret 
04b9			 
04b9			 
04b9			 
04b9			; Read Block 0 - Config 
04b9			; --------------------- 
04b9			; 
04b9			; With current bank 
04b9			; Call presence test 
04b9			;    If not present format/init bank  
04b9			; Read block 0  
04b9			;  
04b9			 
04b9			 
04b9			; Dir 
04b9			; --- 
04b9			; 
04b9			; With current bank 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block read byte 2 
04b9			;      if first block of file 
04b9			;         Display file name 
04b9			;         Display type flags for file 
04b9			;        
04b9			 
04b9			; moving to words as this requires stack control 
04b9			 
04b9			 
04b9			; Delete File 
04b9			; ----------- 
04b9			; 
04b9			; With current bank 
04b9			; 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block file id 
04b9			;      If first block of file and dont have file id 
04b9			;         if file to delete 
04b9			;         Save file id 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			;      If file id is one saved 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			 
04b9			 
04b9			.se_done: 
04b9 e1				pop hl 
04ba c9				ret 
04bb			 
04bb			storage_erase: 
04bb			 
04bb				; hl contains the file id 
04bb			 
04bb 5d				ld e, l 
04bc 16 00			ld d, 0 
04be 21 40 00			ld hl, STORE_BLOCK_PHY 
04c1					if DEBUG_FORTH_WORDS 
04c1						DMARK "ERA" 
04c1 f5				push af  
04c2 3a d6 04			ld a, (.dmark)  
04c5 32 71 ee			ld (debug_mark),a  
04c8 3a d7 04			ld a, (.dmark+1)  
04cb 32 72 ee			ld (debug_mark+1),a  
04ce 3a d8 04			ld a, (.dmark+2)  
04d1 32 73 ee			ld (debug_mark+2),a  
04d4 18 03			jr .pastdmark  
04d6 ..			.dmark: db "ERA"  
04d9 f1			.pastdmark: pop af  
04da			endm  
# End of macro DMARK
04da						CALLMONITOR 
04da cd ae 15			call break_point_state  
04dd				endm  
# End of macro CALLMONITOR
04dd					endif 
04dd cd ac 05			call storage_findnextid 
04e0 cd d6 0d			call ishlzero 
04e3 c8				ret z 
04e4			 
04e4 e5				push hl 
04e5			 
04e5				; TODO check file not found 
04e5			 
04e5 11 84 ea			ld de, store_page 
04e8 cd 79 02			call storage_read_block 
04eb			 
04eb cd d6 0d			call ishlzero 
04ee ca b9 04			jp z,.se_done 
04f1			 
04f1					if DEBUG_FORTH_WORDS 
04f1						DMARK "ER1" 
04f1 f5				push af  
04f2 3a 06 05			ld a, (.dmark)  
04f5 32 71 ee			ld (debug_mark),a  
04f8 3a 07 05			ld a, (.dmark+1)  
04fb 32 72 ee			ld (debug_mark+1),a  
04fe 3a 08 05			ld a, (.dmark+2)  
0501 32 73 ee			ld (debug_mark+2),a  
0504 18 03			jr .pastdmark  
0506 ..			.dmark: db "ER1"  
0509 f1			.pastdmark: pop af  
050a			endm  
# End of macro DMARK
050a						CALLMONITOR 
050a cd ae 15			call break_point_state  
050d				endm  
# End of macro CALLMONITOR
050d					endif 
050d 3a 84 ea			ld a, (store_page)	; get file id 
0510 32 78 ea			ld (store_tmpid), a 
0513			 
0513 3a 86 ea			ld a, (store_page+2)    ; get count of extends 
0516 32 77 ea			ld (store_tmpext), a 
0519			 
0519				; wipe file header 
0519			 
0519 e1				pop hl 
051a 3e 00			ld a, 0 
051c 32 84 ea			ld (store_page), a 
051f 32 85 ea			ld (store_page+1),a 
0522 11 84 ea			ld de, store_page 
0525					if DEBUG_FORTH_WORDS 
0525						DMARK "ER2" 
0525 f5				push af  
0526 3a 3a 05			ld a, (.dmark)  
0529 32 71 ee			ld (debug_mark),a  
052c 3a 3b 05			ld a, (.dmark+1)  
052f 32 72 ee			ld (debug_mark+1),a  
0532 3a 3c 05			ld a, (.dmark+2)  
0535 32 73 ee			ld (debug_mark+2),a  
0538 18 03			jr .pastdmark  
053a ..			.dmark: db "ER2"  
053d f1			.pastdmark: pop af  
053e			endm  
# End of macro DMARK
053e						CALLMONITOR 
053e cd ae 15			call break_point_state  
0541				endm  
# End of macro CALLMONITOR
0541					endif 
0541 cd de 02			call storage_write_block 
0544			 
0544			 
0544				; wipe file extents 
0544			 
0544 3a 77 ea			ld a, (store_tmpext) 
0547 47				ld b, a 
0548			 
0548			.eraext:	  
0548 c5				push bc 
0549			 
0549 21 40 00			ld hl, STORE_BLOCK_PHY 
054c 3a 78 ea			ld a,(store_tmpid) 
054f 5f				ld e, a 
0550 50				ld d, b	 
0551					if DEBUG_FORTH_WORDS 
0551						DMARK "ER3" 
0551 f5				push af  
0552 3a 66 05			ld a, (.dmark)  
0555 32 71 ee			ld (debug_mark),a  
0558 3a 67 05			ld a, (.dmark+1)  
055b 32 72 ee			ld (debug_mark+1),a  
055e 3a 68 05			ld a, (.dmark+2)  
0561 32 73 ee			ld (debug_mark+2),a  
0564 18 03			jr .pastdmark  
0566 ..			.dmark: db "ER3"  
0569 f1			.pastdmark: pop af  
056a			endm  
# End of macro DMARK
056a						CALLMONITOR 
056a cd ae 15			call break_point_state  
056d				endm  
# End of macro CALLMONITOR
056d					endif 
056d cd ac 05			call storage_findnextid 
0570 cd d6 0d			call ishlzero 
0573 ca b9 04			jp z,.se_done 
0576			 
0576 e5				push hl 
0577 11 84 ea			ld de, store_page 
057a cd 79 02			call storage_read_block 
057d			 
057d				; free block	 
057d			 
057d 3e 00			ld a, 0 
057f 32 84 ea			ld (store_page), a 
0582 32 85 ea			ld (store_page+1),a 
0585 11 84 ea			ld de, store_page 
0588 e1				pop hl 
0589					if DEBUG_FORTH_WORDS 
0589						DMARK "ER4" 
0589 f5				push af  
058a 3a 9e 05			ld a, (.dmark)  
058d 32 71 ee			ld (debug_mark),a  
0590 3a 9f 05			ld a, (.dmark+1)  
0593 32 72 ee			ld (debug_mark+1),a  
0596 3a a0 05			ld a, (.dmark+2)  
0599 32 73 ee			ld (debug_mark+2),a  
059c 18 03			jr .pastdmark  
059e ..			.dmark: db "ER4"  
05a1 f1			.pastdmark: pop af  
05a2			endm  
# End of macro DMARK
05a2						CALLMONITOR 
05a2 cd ae 15			call break_point_state  
05a5				endm  
# End of macro CALLMONITOR
05a5					endif 
05a5 cd de 02			call storage_write_block 
05a8			 
05a8 c1				pop bc 
05a9 10 9d			djnz .eraext 
05ab			 
05ab c9				ret 
05ac			 
05ac			 
05ac			; Find Free Block 
05ac			; --------------- 
05ac			; 
05ac			; With current bank 
05ac			;  
05ac			; From given starting logical block 
05ac			;    Read block  
05ac			;    If no file id 
05ac			;         Return block id 
05ac			 
05ac			 
05ac			; hl starting page number 
05ac			; hl contains free page number or zero if no pages free 
05ac			; e contains the file id to locate 
05ac			; d contains the block number 
05ac			 
05ac			; TODO change to find file id and use zero for free block 
05ac			 
05ac			storage_findnextid: 
05ac			 
05ac				; now locate first 0 page to mark as a free block 
05ac			 
05ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ae			;	ld hl, STORE_BLOCK_PHY 
05ae			 
05ae					if DEBUG_FORTH_WORDS 
05ae					DMARK "FNI" 
05ae f5				push af  
05af 3a c3 05			ld a, (.dmark)  
05b2 32 71 ee			ld (debug_mark),a  
05b5 3a c4 05			ld a, (.dmark+1)  
05b8 32 72 ee			ld (debug_mark+1),a  
05bb 3a c5 05			ld a, (.dmark+2)  
05be 32 73 ee			ld (debug_mark+2),a  
05c1 18 03			jr .pastdmark  
05c3 ..			.dmark: db "FNI"  
05c6 f1			.pastdmark: pop af  
05c7			endm  
# End of macro DMARK
05c7						CALLMONITOR 
05c7 cd ae 15			call break_point_state  
05ca				endm  
# End of macro CALLMONITOR
05ca					endif 
05ca			.ff1:   	 
05ca e5					push hl 
05cb c5					push bc 
05cc d5					push de 
05cd cd 9d 01				call se_readbyte 
05d0 5f					ld e,a 
05d1 23					inc hl 
05d2 cd 9d 01				call se_readbyte 
05d5 57					ld d, a 
05d6 e1					pop hl 
05d7 e5					push hl 
05d8 cd cb 0d				call cmp16 
05db 28 49				jr z, .fffound 
05dd			 
05dd d1					pop de 
05de c1					pop bc 
05df e1					pop hl 
05e0			 
05e0					; is found? 
05e0					;cp e 
05e0					;ret z 
05e0			 
05e0 3e 40				ld a, STORE_BLOCK_PHY 
05e2 cd ad 0d				call addatohl 
05e5 10 e3				djnz .ff1 
05e7			 
05e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e9			.ff2:   	 
05e9			 
05e9 e5					push hl 
05ea c5					push bc 
05eb d5					push de 
05ec cd 9d 01				call se_readbyte 
05ef 5f					ld e,a 
05f0 23					inc hl 
05f1 cd 9d 01				call se_readbyte 
05f4 57					ld d, a 
05f5			 
05f5 e1					pop hl 
05f6 e5					push hl 
05f7 cd cb 0d				call cmp16 
05fa 28 2a				jr z, .fffound 
05fc			 
05fc d1					pop de 
05fd c1					pop bc 
05fe e1					pop hl 
05ff					; is found? 
05ff					;cp e 
05ff					;ret z 
05ff			 
05ff 3e 40				ld a, STORE_BLOCK_PHY 
0601 cd ad 0d				call addatohl 
0604 10 e3				djnz .ff2 
0606			 
0606			 
0606					if DEBUG_FORTH_WORDS 
0606					DMARK "FN-" 
0606 f5				push af  
0607 3a 1b 06			ld a, (.dmark)  
060a 32 71 ee			ld (debug_mark),a  
060d 3a 1c 06			ld a, (.dmark+1)  
0610 32 72 ee			ld (debug_mark+1),a  
0613 3a 1d 06			ld a, (.dmark+2)  
0616 32 73 ee			ld (debug_mark+2),a  
0619 18 03			jr .pastdmark  
061b ..			.dmark: db "FN-"  
061e f1			.pastdmark: pop af  
061f			endm  
# End of macro DMARK
061f					;	push af 
061f					;	ld a, 'n' 
061f					;	ld (debug_mark),a 
061f					;	pop af 
061f						CALLMONITOR 
061f cd ae 15			call break_point_state  
0622				endm  
# End of macro CALLMONITOR
0622					endif 
0622				; no free marks! 
0622 21 00 00				ld hl, 0 
0625 c9				ret 
0626			.fffound: 
0626				 
0626			 
0626 d1					pop de 
0627 c1					pop bc 
0628 e1					pop hl 
0629					if DEBUG_FORTH_WORDS 
0629					DMARK "FNF" 
0629 f5				push af  
062a 3a 3e 06			ld a, (.dmark)  
062d 32 71 ee			ld (debug_mark),a  
0630 3a 3f 06			ld a, (.dmark+1)  
0633 32 72 ee			ld (debug_mark+1),a  
0636 3a 40 06			ld a, (.dmark+2)  
0639 32 73 ee			ld (debug_mark+2),a  
063c 18 03			jr .pastdmark  
063e ..			.dmark: db "FNF"  
0641 f1			.pastdmark: pop af  
0642			endm  
# End of macro DMARK
0642					;	push af 
0642					;	ld a, 'n' 
0642					;	ld (debug_mark),a 
0642					;	pop af 
0642						CALLMONITOR 
0642 cd ae 15			call break_point_state  
0645				endm  
# End of macro CALLMONITOR
0645					endif 
0645 c9				ret 
0646			 
0646			 
0646			 
0646			; Free Space 
0646			; ---------- 
0646			; 
0646			; With current bank 
0646			; 
0646			; Set block count to zero 
0646			; Starting with first logical block 
0646			;      Find free block  
0646			;      If block id given, increment block count 
0646			; 
0646			;  
0646			 
0646			 
0646			; hl contains count of free blocks 
0646			 
0646			storage_freeblocks: 
0646			 
0646				; now locate first 0 page to mark as a free block 
0646			 
0646 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0648 21 40 00			ld hl, STORE_BLOCK_PHY 
064b 11 00 00			ld de, 0 
064e			 
064e			.fb1:   	 
064e e5					push hl 
064f c5					push bc 
0650 d5					push de 
0651 cd 9d 01				call se_readbyte 
0654 d1					pop de 
0655 c1					pop bc 
0656 e1					pop hl 
0657			 
0657					; is free? 
0657 fe 00				cp 0 
0659 20 01				jr nz, .ff1cont 
065b 13					inc de 
065c			 
065c			.ff1cont: 
065c			 
065c			 
065c 3e 40				ld a, STORE_BLOCK_PHY 
065e cd ad 0d				call addatohl 
0661 10 eb				djnz .fb1 
0663			 
0663 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0665			.fb2:   	 
0665 e5					push hl 
0666 c5					push bc 
0667 d5					push de 
0668 cd 9d 01				call se_readbyte 
066b d1					pop de 
066c c1					pop bc 
066d e1					pop hl 
066e			 
066e					; is free? 
066e fe 00				cp 0 
0670 20 01				jr nz, .ff2cont 
0672 13					inc de 
0673			 
0673			.ff2cont: 
0673			 
0673 3e 40				ld a, STORE_BLOCK_PHY 
0675 cd ad 0d				call addatohl 
0678 10 eb				djnz .fb2 
067a			 
067a eb				ex de, hl 
067b c9				ret 
067c			 
067c			; Get File ID 
067c			; ----------- 
067c			; 
067c			; With current bank 
067c			;  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; For each logical block 
067c			;    Read block file id 
067c			;      If first block of file and dont have file id 
067c			;         if file get id and exit 
067c			 
067c			 
067c			 
067c			 
067c			; Create File 
067c			; ----------- 
067c			; 
067c			; With current bank  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; Increment file id number 
067c			; Save Config 
067c			; Find free block 
067c			; Set buffer with file name and file id 
067c			; Write buffer to free block  
067c			 
067c			 
067c			; hl point to file name 
067c			; hl returns file id 
067c			 
067c			; file format: 
067c			; byte 0 - file id 
067c			; byte 1 - extent number 
067c			; byte 2-> data 
067c			 
067c			; format for extent number 0: 
067c			; 
067c			; byte 0 - file id 
067c			; byte 1 - extent 0 
067c			; byte 2 - extent count 
067c			; byte 3 -> file name and meta data 
067c			 
067c			 
067c			storage_create: 
067c				if DEBUG_STORESE 
067c					DMARK "SCR" 
067c f5				push af  
067d 3a 91 06			ld a, (.dmark)  
0680 32 71 ee			ld (debug_mark),a  
0683 3a 92 06			ld a, (.dmark+1)  
0686 32 72 ee			ld (debug_mark+1),a  
0689 3a 93 06			ld a, (.dmark+2)  
068c 32 73 ee			ld (debug_mark+2),a  
068f 18 03			jr .pastdmark  
0691 ..			.dmark: db "SCR"  
0694 f1			.pastdmark: pop af  
0695			endm  
# End of macro DMARK
0695					CALLMONITOR 
0695 cd ae 15			call break_point_state  
0698				endm  
# End of macro CALLMONITOR
0698				endif 
0698			 
0698 e5				push hl		; save file name pointer 
0699			 
0699 cd 2a 03			call storage_get_block_0 
069c			 
069c 3a 84 ea			ld a,(store_page)	; get current file id 
069f 3c				inc a 
06a0 32 84 ea			ld (store_page),a 
06a3				 
06a3 32 78 ea			ld (store_tmpid),a			; save id 
06a6			 
06a6 21 00 00			ld hl, 0 
06a9 11 84 ea			ld de, store_page 
06ac				if DEBUG_STORESE 
06ac					DMARK "SCw" 
06ac f5				push af  
06ad 3a c1 06			ld a, (.dmark)  
06b0 32 71 ee			ld (debug_mark),a  
06b3 3a c2 06			ld a, (.dmark+1)  
06b6 32 72 ee			ld (debug_mark+1),a  
06b9 3a c3 06			ld a, (.dmark+2)  
06bc 32 73 ee			ld (debug_mark+2),a  
06bf 18 03			jr .pastdmark  
06c1 ..			.dmark: db "SCw"  
06c4 f1			.pastdmark: pop af  
06c5			endm  
# End of macro DMARK
06c5					CALLMONITOR 
06c5 cd ae 15			call break_point_state  
06c8				endm  
# End of macro CALLMONITOR
06c8				endif 
06c8 cd de 02			call storage_write_block	 ; save update 
06cb			 
06cb				if DEBUG_STORESE 
06cb 11 84 ea				ld de, store_page 
06ce					DMARK "SCC" 
06ce f5				push af  
06cf 3a e3 06			ld a, (.dmark)  
06d2 32 71 ee			ld (debug_mark),a  
06d5 3a e4 06			ld a, (.dmark+1)  
06d8 32 72 ee			ld (debug_mark+1),a  
06db 3a e5 06			ld a, (.dmark+2)  
06de 32 73 ee			ld (debug_mark+2),a  
06e1 18 03			jr .pastdmark  
06e3 ..			.dmark: db "SCC"  
06e6 f1			.pastdmark: pop af  
06e7			endm  
# End of macro DMARK
06e7					CALLMONITOR 
06e7 cd ae 15			call break_point_state  
06ea				endm  
# End of macro CALLMONITOR
06ea				endif 
06ea				;  
06ea				 
06ea 21 40 00			ld hl, STORE_BLOCK_PHY 
06ed 11 00 00			ld de, 0 
06f0 cd ac 05			call storage_findnextid 
06f3			 
06f3 22 6f ea			ld (store_tmppageid), hl    ; save page to use  
06f6			 
06f6				; TODO detect 0 = no spare blocks 
06f6			 
06f6				; hl now contains the free page to use for the file header page 
06f6			 
06f6				if DEBUG_STORESE 
06f6				DMARK "SCF" 
06f6 f5				push af  
06f7 3a 0b 07			ld a, (.dmark)  
06fa 32 71 ee			ld (debug_mark),a  
06fd 3a 0c 07			ld a, (.dmark+1)  
0700 32 72 ee			ld (debug_mark+1),a  
0703 3a 0d 07			ld a, (.dmark+2)  
0706 32 73 ee			ld (debug_mark+2),a  
0709 18 03			jr .pastdmark  
070b ..			.dmark: db "SCF"  
070e f1			.pastdmark: pop af  
070f			endm  
# End of macro DMARK
070f					CALLMONITOR 
070f cd ae 15			call break_point_state  
0712				endm  
# End of macro CALLMONITOR
0712				endif 
0712			 
0712 22 6f ea			ld (store_tmppageid), hl 
0715				 
0715 3a 78 ea			ld a,(store_tmpid)    ; get file id 
0718			;	ld a, (store_filecache)			; save to cache 
0718			 
0718 32 84 ea			ld (store_page),a    ; set page id 
071b 3e 00			ld a, 0			 ; extent 0 is file header 
071d 32 85 ea			ld (store_page+1), a   ; set file extent 
0720			 
0720 32 86 ea			ld (store_page+2), a   ; extent count for the file 
0723			 
0723			;	inc hl 		; init block 0 of file 
0723			;	inc hl   		; skip file and extent id 
0723			 ;       ld a, 0 
0723			;	ld (hl),a 
0723			;	ld a, (store_filecache+1)  	; save to cache 
0723			 
0723			;	inc hl    ; file name 
0723				 
0723				 
0723 11 87 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0726				if DEBUG_STORESE 
0726					DMARK "SCc" 
0726 f5				push af  
0727 3a 3b 07			ld a, (.dmark)  
072a 32 71 ee			ld (debug_mark),a  
072d 3a 3c 07			ld a, (.dmark+1)  
0730 32 72 ee			ld (debug_mark+1),a  
0733 3a 3d 07			ld a, (.dmark+2)  
0736 32 73 ee			ld (debug_mark+2),a  
0739 18 03			jr .pastdmark  
073b ..			.dmark: db "SCc"  
073e f1			.pastdmark: pop af  
073f			endm  
# End of macro DMARK
073f					CALLMONITOR 
073f cd ae 15			call break_point_state  
0742				endm  
# End of macro CALLMONITOR
0742				endif 
0742 e1				pop hl    ; get zero term string 
0743 e5				push hl 
0744 3e 00			ld a, 0 
0746 cd 16 12			call strlent 
0749 23				inc hl   ; cover zero term 
074a 06 00			ld b,0 
074c 4d				ld c,l 
074d e1				pop hl 
074e				;ex de, hl 
074e				if DEBUG_STORESE 
074e					DMARK "SCa" 
074e f5				push af  
074f 3a 63 07			ld a, (.dmark)  
0752 32 71 ee			ld (debug_mark),a  
0755 3a 64 07			ld a, (.dmark+1)  
0758 32 72 ee			ld (debug_mark+1),a  
075b 3a 65 07			ld a, (.dmark+2)  
075e 32 73 ee			ld (debug_mark+2),a  
0761 18 03			jr .pastdmark  
0763 ..			.dmark: db "SCa"  
0766 f1			.pastdmark: pop af  
0767			endm  
# End of macro DMARK
0767					;push af 
0767					;ld a, 'a' 
0767					;ld (debug_mark),a 
0767					;pop af 
0767					CALLMONITOR 
0767 cd ae 15			call break_point_state  
076a				endm  
# End of macro CALLMONITOR
076a				endif 
076a ed b0			ldir    ; copy zero term string 
076c				if DEBUG_STORESE 
076c					DMARK "SCA" 
076c f5				push af  
076d 3a 81 07			ld a, (.dmark)  
0770 32 71 ee			ld (debug_mark),a  
0773 3a 82 07			ld a, (.dmark+1)  
0776 32 72 ee			ld (debug_mark+1),a  
0779 3a 83 07			ld a, (.dmark+2)  
077c 32 73 ee			ld (debug_mark+2),a  
077f 18 03			jr .pastdmark  
0781 ..			.dmark: db "SCA"  
0784 f1			.pastdmark: pop af  
0785			endm  
# End of macro DMARK
0785					CALLMONITOR 
0785 cd ae 15			call break_point_state  
0788				endm  
# End of macro CALLMONITOR
0788				endif 
0788			 
0788				; write file header page 
0788			 
0788 2a 6f ea			ld hl,(store_tmppageid) 
078b 11 84 ea			ld de, store_page 
078e				if DEBUG_STORESE 
078e					DMARK "SCb" 
078e f5				push af  
078f 3a a3 07			ld a, (.dmark)  
0792 32 71 ee			ld (debug_mark),a  
0795 3a a4 07			ld a, (.dmark+1)  
0798 32 72 ee			ld (debug_mark+1),a  
079b 3a a5 07			ld a, (.dmark+2)  
079e 32 73 ee			ld (debug_mark+2),a  
07a1 18 03			jr .pastdmark  
07a3 ..			.dmark: db "SCb"  
07a6 f1			.pastdmark: pop af  
07a7			endm  
# End of macro DMARK
07a7					;push af 
07a7					;ld a, 'b' 
07a7					;ld (debug_mark),a 
07a7					;pop af 
07a7					CALLMONITOR 
07a7 cd ae 15			call break_point_state  
07aa				endm  
# End of macro CALLMONITOR
07aa				endif 
07aa cd de 02			call storage_write_block 
07ad			 
07ad 3a 78 ea			ld a, (store_tmpid) 
07b0 6f				ld l, a 
07b1 26 00			ld h,0 
07b3				if DEBUG_STORESE 
07b3					DMARK "SCz" 
07b3 f5				push af  
07b4 3a c8 07			ld a, (.dmark)  
07b7 32 71 ee			ld (debug_mark),a  
07ba 3a c9 07			ld a, (.dmark+1)  
07bd 32 72 ee			ld (debug_mark+1),a  
07c0 3a ca 07			ld a, (.dmark+2)  
07c3 32 73 ee			ld (debug_mark+2),a  
07c6 18 03			jr .pastdmark  
07c8 ..			.dmark: db "SCz"  
07cb f1			.pastdmark: pop af  
07cc			endm  
# End of macro DMARK
07cc					CALLMONITOR 
07cc cd ae 15			call break_point_state  
07cf				endm  
# End of macro CALLMONITOR
07cf				endif 
07cf c9				ret 
07d0				 
07d0			 
07d0			 
07d0			; 
07d0			; Read File 
07d0			; 
07d0			; h - file id to locate 
07d0			; l - extent to locate 
07d0			; de - pointer to string to read into 
07d0			; 
07d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07d0			 
07d0			.sr_fail: 
07d0 d1				pop de 
07d1 c9				ret 
07d2			 
07d2			storage_read: 
07d2			 
07d2			 
07d2 d5				push de 
07d3			 
07d3			; TODO BUG the above push is it popped before the RET Z? 
07d3			 
07d3			; TODO how to handle multiple part blocks 
07d3			 
07d3				; locate file extent to read 
07d3			 
07d3 5c				ld e, h 
07d4 55				ld d, l 
07d5			 
07d5			.srext: 
07d5 22 82 ea			ld (store_readptr), hl     ; save the current extent to load 
07d8 ed 53 80 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07dc			 
07dc 21 40 00			ld hl, STORE_BLOCK_PHY 
07df				if DEBUG_STORESE 
07df					DMARK "sre" 
07df f5				push af  
07e0 3a f4 07			ld a, (.dmark)  
07e3 32 71 ee			ld (debug_mark),a  
07e6 3a f5 07			ld a, (.dmark+1)  
07e9 32 72 ee			ld (debug_mark+1),a  
07ec 3a f6 07			ld a, (.dmark+2)  
07ef 32 73 ee			ld (debug_mark+2),a  
07f2 18 03			jr .pastdmark  
07f4 ..			.dmark: db "sre"  
07f7 f1			.pastdmark: pop af  
07f8			endm  
# End of macro DMARK
07f8					CALLMONITOR 
07f8 cd ae 15			call break_point_state  
07fb				endm  
# End of macro CALLMONITOR
07fb				endif 
07fb cd ac 05			call storage_findnextid 
07fe			 
07fe				if DEBUG_STORESE 
07fe					DMARK "srf" 
07fe f5				push af  
07ff 3a 13 08			ld a, (.dmark)  
0802 32 71 ee			ld (debug_mark),a  
0805 3a 14 08			ld a, (.dmark+1)  
0808 32 72 ee			ld (debug_mark+1),a  
080b 3a 15 08			ld a, (.dmark+2)  
080e 32 73 ee			ld (debug_mark+2),a  
0811 18 03			jr .pastdmark  
0813 ..			.dmark: db "srf"  
0816 f1			.pastdmark: pop af  
0817			endm  
# End of macro DMARK
0817					CALLMONITOR 
0817 cd ae 15			call break_point_state  
081a				endm  
# End of macro CALLMONITOR
081a				endif 
081a cd d6 0d			call ishlzero 
081d			;	ld a, l 
081d			;	add h 
081d			;	cp 0 
081d 28 b1			jr z,.sr_fail			; block not found so EOF 
081f			 
081f				; save current address for use by higher level words etc 
081f			 
081f 22 75 ea			ld (store_openaddr),hl 
0822			 
0822			 
0822				; hl contains page number to load 
0822 d1				pop de   ; get storage 
0823 ed 53 80 ea		ld (store_readbuf), de     ; current buffer to load in to 
0827 d5				push de 
0828				if DEBUG_STORESE 
0828					DMARK "srg" 
0828 f5				push af  
0829 3a 3d 08			ld a, (.dmark)  
082c 32 71 ee			ld (debug_mark),a  
082f 3a 3e 08			ld a, (.dmark+1)  
0832 32 72 ee			ld (debug_mark+1),a  
0835 3a 3f 08			ld a, (.dmark+2)  
0838 32 73 ee			ld (debug_mark+2),a  
083b 18 03			jr .pastdmark  
083d ..			.dmark: db "srg"  
0840 f1			.pastdmark: pop af  
0841			endm  
# End of macro DMARK
0841					CALLMONITOR 
0841 cd ae 15			call break_point_state  
0844				endm  
# End of macro CALLMONITOR
0844				endif 
0844 cd 79 02			call storage_read_block 
0847			 
0847				; if this a continuation read??? 
0847			 
0847 2a 80 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
084a			 
084a 3e 3f			ld a, STORE_BLOCK_PHY-1 
084c cd ad 0d			call addatohl 
084f 7e				ld a,(hl) 
0850 fe 00			cp 0 
0852 28 02			jr z, .markiscont 
0854 3e ff			ld a, 255 
0856			 
0856			.markiscont: 
0856 32 77 ea			ld (store_readcont), a 
0859			 
0859				if DEBUG_STORESE 
0859					DMARK "srC" 
0859 f5				push af  
085a 3a 6e 08			ld a, (.dmark)  
085d 32 71 ee			ld (debug_mark),a  
0860 3a 6f 08			ld a, (.dmark+1)  
0863 32 72 ee			ld (debug_mark+1),a  
0866 3a 70 08			ld a, (.dmark+2)  
0869 32 73 ee			ld (debug_mark+2),a  
086c 18 03			jr .pastdmark  
086e ..			.dmark: db "srC"  
0871 f1			.pastdmark: pop af  
0872			endm  
# End of macro DMARK
0872					CALLMONITOR 
0872 cd ae 15			call break_point_state  
0875				endm  
# End of macro CALLMONITOR
0875				endif 
0875				; only short reads enabled 
0875			 
0875 3a 7f ea			ld a, (store_longread) 
0878 fe 00			cp 0 
087a ca 47 09			jp z, .readdone 
087d			 
087d			; TODO if block has no zeros then need to read next block  
087d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
087d			; check last byte of physical block. 
087d			; if not zero then the next block needs to be loaded 
087d			 
087d			 
087d 2a 80 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0880			 
0880 3e 3f			ld a, STORE_BLOCK_PHY-1 
0882 cd ad 0d			call addatohl 
0885				;dec hl 
0885 7e				ld a,(hl) 
0886				if DEBUG_STORESE 
0886					DMARK "sr?" 
0886 f5				push af  
0887 3a 9b 08			ld a, (.dmark)  
088a 32 71 ee			ld (debug_mark),a  
088d 3a 9c 08			ld a, (.dmark+1)  
0890 32 72 ee			ld (debug_mark+1),a  
0893 3a 9d 08			ld a, (.dmark+2)  
0896 32 73 ee			ld (debug_mark+2),a  
0899 18 03			jr .pastdmark  
089b ..			.dmark: db "sr?"  
089e f1			.pastdmark: pop af  
089f			endm  
# End of macro DMARK
089f					CALLMONITOR 
089f cd ae 15			call break_point_state  
08a2				endm  
# End of macro CALLMONITOR
08a2				endif 
08a2 fe 00			cp 0 
08a4 ca 47 09			jp z, .readdone 
08a7			 
08a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a7			 
08a7 23				inc hl 
08a8			 
08a8 22 80 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08ab			 
08ab ed 5b 82 ea		ld de, (store_readptr)     ; save the current extent to load 
08af			 
08af eb				ex de, hl 
08b0			 
08b0				; next ext 
08b0			 
08b0 23				inc hl 
08b1 22 82 ea			ld  (store_readptr), hl     ; save the current extent to load 
08b4			 
08b4				if DEBUG_STORESE 
08b4					DMARK "sF2" 
08b4 f5				push af  
08b5 3a c9 08			ld a, (.dmark)  
08b8 32 71 ee			ld (debug_mark),a  
08bb 3a ca 08			ld a, (.dmark+1)  
08be 32 72 ee			ld (debug_mark+1),a  
08c1 3a cb 08			ld a, (.dmark+2)  
08c4 32 73 ee			ld (debug_mark+2),a  
08c7 18 03			jr .pastdmark  
08c9 ..			.dmark: db "sF2"  
08cc f1			.pastdmark: pop af  
08cd			endm  
# End of macro DMARK
08cd					CALLMONITOR 
08cd cd ae 15			call break_point_state  
08d0				endm  
# End of macro CALLMONITOR
08d0				endif 
08d0			 
08d0				; get and load block 
08d0			 
08d0 cd ac 05			call storage_findnextid 
08d3			 
08d3				if DEBUG_STORESE 
08d3					DMARK "sf2" 
08d3 f5				push af  
08d4 3a e8 08			ld a, (.dmark)  
08d7 32 71 ee			ld (debug_mark),a  
08da 3a e9 08			ld a, (.dmark+1)  
08dd 32 72 ee			ld (debug_mark+1),a  
08e0 3a ea 08			ld a, (.dmark+2)  
08e3 32 73 ee			ld (debug_mark+2),a  
08e6 18 03			jr .pastdmark  
08e8 ..			.dmark: db "sf2"  
08eb f1			.pastdmark: pop af  
08ec			endm  
# End of macro DMARK
08ec					CALLMONITOR 
08ec cd ae 15			call break_point_state  
08ef				endm  
# End of macro CALLMONITOR
08ef				endif 
08ef cd d6 0d			call ishlzero 
08f2			;	ld a, l 
08f2			;	add h 
08f2			;	cp 0 
08f2 ca d0 07			jp z,.sr_fail			; block not found so EOF 
08f5				 
08f5				; save current address for use by higher level words etc 
08f5			 
08f5 22 75 ea			ld (store_openaddr),hl 
08f8			 
08f8 cd 79 02			call storage_read_block 
08fb			 
08fb				; on a continuation block, we now have the file id and ext in the middle of the block 
08fb				; we need to pull everything back  
08fb			 
08fb ed 5b 80 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08ff 2a 80 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0902 23				inc hl 
0903 23				inc hl     ; skip id and ext 
0904 01 40 00			ld bc, STORE_BLOCK_PHY 
0907				if DEBUG_STORESE 
0907					DMARK "SR<" 
0907 f5				push af  
0908 3a 1c 09			ld a, (.dmark)  
090b 32 71 ee			ld (debug_mark),a  
090e 3a 1d 09			ld a, (.dmark+1)  
0911 32 72 ee			ld (debug_mark+1),a  
0914 3a 1e 09			ld a, (.dmark+2)  
0917 32 73 ee			ld (debug_mark+2),a  
091a 18 03			jr .pastdmark  
091c ..			.dmark: db "SR<"  
091f f1			.pastdmark: pop af  
0920			endm  
# End of macro DMARK
0920					CALLMONITOR 
0920 cd ae 15			call break_point_state  
0923				endm  
# End of macro CALLMONITOR
0923				endif 
0923 ed b0			ldir     ; copy data 
0925			 
0925				; move the pointer back and pretend we have a full buffer for next recheck 
0925			 
0925 1b				dec de 
0926 1b				dec de 
0927			 
0927			; TODO do pop below now short circuit loop????? 
0927 c1				pop bc     ; get rid of spare de on stack 
0928				if DEBUG_STORESE 
0928					DMARK "SR>" 
0928 f5				push af  
0929 3a 3d 09			ld a, (.dmark)  
092c 32 71 ee			ld (debug_mark),a  
092f 3a 3e 09			ld a, (.dmark+1)  
0932 32 72 ee			ld (debug_mark+1),a  
0935 3a 3f 09			ld a, (.dmark+2)  
0938 32 73 ee			ld (debug_mark+2),a  
093b 18 03			jr .pastdmark  
093d ..			.dmark: db "SR>"  
0940 f1			.pastdmark: pop af  
0941			endm  
# End of macro DMARK
0941					CALLMONITOR 
0941 cd ae 15			call break_point_state  
0944				endm  
# End of macro CALLMONITOR
0944				endif 
0944 c3 d5 07			jp .srext 
0947			 
0947			 
0947			 
0947			 
0947			 
0947			.readdone:		 
0947 e1				pop hl 		 ; return start of data to show as not EOF 
0948 23				inc hl   ; past file id 
0949 23				inc hl   ; past ext 
094a				if DEBUG_STORESE 
094a					DMARK "SRe" 
094a f5				push af  
094b 3a 5f 09			ld a, (.dmark)  
094e 32 71 ee			ld (debug_mark),a  
0951 3a 60 09			ld a, (.dmark+1)  
0954 32 72 ee			ld (debug_mark+1),a  
0957 3a 61 09			ld a, (.dmark+2)  
095a 32 73 ee			ld (debug_mark+2),a  
095d 18 03			jr .pastdmark  
095f ..			.dmark: db "SRe"  
0962 f1			.pastdmark: pop af  
0963			endm  
# End of macro DMARK
0963					CALLMONITOR 
0963 cd ae 15			call break_point_state  
0966				endm  
# End of macro CALLMONITOR
0966				endif 
0966 c9					ret 
0967			 
0967			 
0967			 
0967			; 
0967			; Append File 
0967			; 
0967			; hl - file id to locate 
0967			; de - pointer to (multi block) string to write 
0967			 
0967			.sa_notfound: 
0967 d1				pop de 
0968 c9				ret 
0969			 
0969			 
0969			storage_append: 
0969				; hl -  file id to append to 
0969				; de - string to append 
0969			 
0969 d5				push de 
096a				 
096a				if DEBUG_STORESE 
096a					DMARK "AP1" 
096a f5				push af  
096b 3a 7f 09			ld a, (.dmark)  
096e 32 71 ee			ld (debug_mark),a  
0971 3a 80 09			ld a, (.dmark+1)  
0974 32 72 ee			ld (debug_mark+1),a  
0977 3a 81 09			ld a, (.dmark+2)  
097a 32 73 ee			ld (debug_mark+2),a  
097d 18 03			jr .pastdmark  
097f ..			.dmark: db "AP1"  
0982 f1			.pastdmark: pop af  
0983			endm  
# End of macro DMARK
0983					CALLMONITOR 
0983 cd ae 15			call break_point_state  
0986				endm  
# End of macro CALLMONITOR
0986				endif 
0986			 
0986 7d				ld a, l 
0987 32 78 ea			ld (store_tmpid), a 
098a			 
098a				; get file header  
098a			 
098a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098c 3a 78 ea			ld a, (store_tmpid) 
098f 5f				ld e, a 
0990			 
0990 21 40 00				ld hl, STORE_BLOCK_PHY 
0993 cd ac 05				call storage_findnextid 
0996			 
0996 cd d6 0d			call ishlzero 
0999 28 cc			jr z, .sa_notfound 
099b			 
099b 22 6f ea			ld (store_tmppageid), hl 
099e			 
099e				; TODO handle file id not found 
099e			 
099e				if DEBUG_STORESE 
099e					DMARK "AP2" 
099e f5				push af  
099f 3a b3 09			ld a, (.dmark)  
09a2 32 71 ee			ld (debug_mark),a  
09a5 3a b4 09			ld a, (.dmark+1)  
09a8 32 72 ee			ld (debug_mark+1),a  
09ab 3a b5 09			ld a, (.dmark+2)  
09ae 32 73 ee			ld (debug_mark+2),a  
09b1 18 03			jr .pastdmark  
09b3 ..			.dmark: db "AP2"  
09b6 f1			.pastdmark: pop af  
09b7			endm  
# End of macro DMARK
09b7					CALLMONITOR 
09b7 cd ae 15			call break_point_state  
09ba				endm  
# End of macro CALLMONITOR
09ba				endif 
09ba			 
09ba				; update file extent count 
09ba			 
09ba 11 84 ea			ld de, store_page 
09bd			 
09bd cd 79 02			call storage_read_block 
09c0			 
09c0				if DEBUG_STORESE 
09c0					DMARK "AP3" 
09c0 f5				push af  
09c1 3a d5 09			ld a, (.dmark)  
09c4 32 71 ee			ld (debug_mark),a  
09c7 3a d6 09			ld a, (.dmark+1)  
09ca 32 72 ee			ld (debug_mark+1),a  
09cd 3a d7 09			ld a, (.dmark+2)  
09d0 32 73 ee			ld (debug_mark+2),a  
09d3 18 03			jr .pastdmark  
09d5 ..			.dmark: db "AP3"  
09d8 f1			.pastdmark: pop af  
09d9			endm  
# End of macro DMARK
09d9					CALLMONITOR 
09d9 cd ae 15			call break_point_state  
09dc				endm  
# End of macro CALLMONITOR
09dc				endif 
09dc			;	ld (store_tmppageid), hl 
09dc			 
09dc 3a 86 ea			ld a, (store_page+2) 
09df 3c				inc a 
09e0 32 86 ea			ld (store_page+2), a 
09e3 32 77 ea			ld (store_tmpext), a 
09e6				 
09e6				if DEBUG_STORESE 
09e6					DMARK "AP3" 
09e6 f5				push af  
09e7 3a fb 09			ld a, (.dmark)  
09ea 32 71 ee			ld (debug_mark),a  
09ed 3a fc 09			ld a, (.dmark+1)  
09f0 32 72 ee			ld (debug_mark+1),a  
09f3 3a fd 09			ld a, (.dmark+2)  
09f6 32 73 ee			ld (debug_mark+2),a  
09f9 18 03			jr .pastdmark  
09fb ..			.dmark: db "AP3"  
09fe f1			.pastdmark: pop af  
09ff			endm  
# End of macro DMARK
09ff					CALLMONITOR 
09ff cd ae 15			call break_point_state  
0a02				endm  
# End of macro CALLMONITOR
0a02				endif 
0a02 2a 6f ea			ld hl, (store_tmppageid) 
0a05 11 84 ea			ld de, store_page 
0a08 cd de 02			call storage_write_block 
0a0b			 
0a0b				; find free block 
0a0b			 
0a0b 11 00 00			ld de, 0			 ; file extent to locate 
0a0e			 
0a0e 21 40 00				ld hl, STORE_BLOCK_PHY 
0a11 cd ac 05				call storage_findnextid 
0a14 cd d6 0d			call ishlzero 
0a17 ca 67 09			jp z, .sa_notfound 
0a1a			 
0a1a					; TODO handle no space left 
0a1a					 
0a1a 22 6f ea				ld (store_tmppageid), hl 
0a1d			 
0a1d				if DEBUG_STORESE 
0a1d					DMARK "AP4" 
0a1d f5				push af  
0a1e 3a 32 0a			ld a, (.dmark)  
0a21 32 71 ee			ld (debug_mark),a  
0a24 3a 33 0a			ld a, (.dmark+1)  
0a27 32 72 ee			ld (debug_mark+1),a  
0a2a 3a 34 0a			ld a, (.dmark+2)  
0a2d 32 73 ee			ld (debug_mark+2),a  
0a30 18 03			jr .pastdmark  
0a32 ..			.dmark: db "AP4"  
0a35 f1			.pastdmark: pop af  
0a36			endm  
# End of macro DMARK
0a36					CALLMONITOR 
0a36 cd ae 15			call break_point_state  
0a39				endm  
# End of macro CALLMONITOR
0a39				endif 
0a39					; init the buffer with zeros so we can id if the buffer is full or not 
0a39			 
0a39 e5					push hl 
0a3a c5					push bc 
0a3b			 
0a3b 21 84 ea				ld hl, store_page 
0a3e 06 40				ld b, STORE_BLOCK_PHY 
0a40 3e 00				ld a, 0 
0a42 77			.zeroblock:	ld (hl), a 
0a43 23					inc hl 
0a44 10 fc				djnz .zeroblock 
0a46			 
0a46 c1					pop bc 
0a47 e1					pop hl 
0a48			 
0a48					; construct block 
0a48			 
0a48 3a 78 ea				ld a, (store_tmpid) 
0a4b 32 84 ea				ld (store_page), a   ; file id 
0a4e 3a 77 ea				ld a, (store_tmpext)   ; extent for this block 
0a51 32 85 ea				ld (store_page+1), a 
0a54			 
0a54 e1					pop hl    ; get string to write 
0a55 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a57 11 86 ea				ld de, store_page+2 
0a5a			 
0a5a				if DEBUG_STORESE 
0a5a					DMARK "AP5" 
0a5a f5				push af  
0a5b 3a 6f 0a			ld a, (.dmark)  
0a5e 32 71 ee			ld (debug_mark),a  
0a61 3a 70 0a			ld a, (.dmark+1)  
0a64 32 72 ee			ld (debug_mark+1),a  
0a67 3a 71 0a			ld a, (.dmark+2)  
0a6a 32 73 ee			ld (debug_mark+2),a  
0a6d 18 03			jr .pastdmark  
0a6f ..			.dmark: db "AP5"  
0a72 f1			.pastdmark: pop af  
0a73			endm  
# End of macro DMARK
0a73					CALLMONITOR 
0a73 cd ae 15			call break_point_state  
0a76				endm  
# End of macro CALLMONITOR
0a76				endif 
0a76			 
0a76			 
0a76			 
0a76					; fill buffer with data until end of string or full block 
0a76			 
0a76 7e			.appd:		ld a, (hl) 
0a77 12					ld (de), a 
0a78 fe 00				cp 0 
0a7a 28 04				jr z, .appdone 
0a7c 23					inc hl 
0a7d 13					inc de 
0a7e 10 f6				djnz .appd 
0a80			 
0a80 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a81 f5					push af   		; save last byte dumped 
0a82			 
0a82			 
0a82 2a 6f ea			ld hl, (store_tmppageid) 
0a85 11 84 ea			ld de, store_page 
0a88				if DEBUG_STORESE 
0a88					DMARK "AP6" 
0a88 f5				push af  
0a89 3a 9d 0a			ld a, (.dmark)  
0a8c 32 71 ee			ld (debug_mark),a  
0a8f 3a 9e 0a			ld a, (.dmark+1)  
0a92 32 72 ee			ld (debug_mark+1),a  
0a95 3a 9f 0a			ld a, (.dmark+2)  
0a98 32 73 ee			ld (debug_mark+2),a  
0a9b 18 03			jr .pastdmark  
0a9d ..			.dmark: db "AP6"  
0aa0 f1			.pastdmark: pop af  
0aa1			endm  
# End of macro DMARK
0aa1					CALLMONITOR 
0aa1 cd ae 15			call break_point_state  
0aa4				endm  
# End of macro CALLMONITOR
0aa4				endif 
0aa4 cd de 02				call storage_write_block 
0aa7			 
0aa7			 
0aa7				; was that a full block of data written? 
0aa7				; any more to write out? 
0aa7			 
0aa7				; if yes then set vars and jump to start of function again 
0aa7			 
0aa7 f1					pop af 
0aa8 d1					pop de 
0aa9			 
0aa9 fe 00				cp 0		 ; no, string was fully written 
0aab c8					ret z 
0aac			 
0aac					; setup vars for next cycle 
0aac			 
0aac 3a 78 ea				ld a, (store_tmpid) 
0aaf 6f					ld l, a 
0ab0 26 00				ld h, 0 
0ab2			 
0ab2 c3 69 09			 	jp storage_append	 ; yes, need to write out some more 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			if DEBUG_STORECF 
0ab5			storageput:	 
0ab5					ret 
0ab5			storageread: 
0ab5					ld hl, store_page 
0ab5					ld b, 200 
0ab5					ld a,0 
0ab5			.src:		ld (hl),a 
0ab5					inc hl 
0ab5					djnz .src 
0ab5					 
0ab5			 
0ab5					ld de, 0 
0ab5					ld bc, 1 
0ab5					ld hl, store_page 
0ab5					call cfRead 
0ab5			 
0ab5				call cfGetError 
0ab5				ld hl,scratch 
0ab5				call hexout 
0ab5				ld hl, scratch+2 
0ab5				ld a, 0 
0ab5				ld (hl),a 
0ab5				ld de, scratch 
0ab5				ld a,display_row_1 
0ab5				call str_at_display 
0ab5				call update_display 
0ab5			 
0ab5					ld hl, store_page 
0ab5					ld (os_cur_ptr),hl 
0ab5			 
0ab5					ret 
0ab5			endif 
0ab5			 
0ab5			 
0ab5			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab5			 
0ab5			storage_clear_page: 
0ab5 e5				push hl 
0ab6 d5				push de 
0ab7 c5				push bc 
0ab8 21 84 ea			ld hl, store_page 
0abb 3e 00			ld a, 0 
0abd 77				ld (hl), a 
0abe			 
0abe 11 85 ea			ld de, store_page+1 
0ac1 01 18 01			ld bc, STORE_BLOCK_LOG 
0ac4			 
0ac4 ed b0			ldir 
0ac6				 
0ac6 c1				pop bc 
0ac7 d1				pop de 
0ac8 e1				pop hl 
0ac9 c9				ret 
0aca			 
0aca			; eof 
# End of file firmware_storage.asm
0aca			  
0aca			; support routines for above hardware abstraction layer  
0aca			  
0aca			include "firmware_general.asm"        ; general support functions  
0aca			 
0aca			; word look up 
0aca			 
0aca			; in 
0aca			; a is the index 
0aca			; hl is pointer start of array 
0aca			; 
0aca			; returns 
0aca			; hl to the word 
0aca			; 
0aca			 
0aca			table_lookup:  
0aca d5					push de 
0acb eb					ex de, hl 
0acc			 
0acc 6f					ld l, a 
0acd 26 00				ld h, 0 
0acf 29					add hl, hl 
0ad0 19					add hl, de 
0ad1 7e					ld a, (hl) 
0ad2 23					inc hl 
0ad3 66					ld h,(hl) 
0ad4 6f					ld l, a 
0ad5			 
0ad5 d1					pop de 
0ad6 c9					ret 
0ad7			 
0ad7			; Delay loops 
0ad7			 
0ad7			 
0ad7			 
0ad7			aDelayInMS: 
0ad7 c5				push bc 
0ad8 47				ld b,a 
0ad9			msdelay: 
0ad9 c5				push bc 
0ada				 
0ada			 
0ada 01 41 00			ld bc,041h 
0add cd f5 0a			call delayloop 
0ae0 c1				pop bc 
0ae1 05				dec b 
0ae2 20 f5			jr nz,msdelay 
0ae4			 
0ae4			;if CPU_CLOCK_8MHZ 
0ae4			;msdelay8: 
0ae4			;	push bc 
0ae4			;	 
0ae4			; 
0ae4			;	ld bc,041h 
0ae4			;	call delayloop 
0ae4			;	pop bc 
0ae4			;	dec b 
0ae4			;	jr nz,msdelay8 
0ae4			;endif 
0ae4			 
0ae4			 
0ae4 c1				pop bc 
0ae5 c9				ret 
0ae6			 
0ae6			 
0ae6			delay250ms: 
0ae6				;push de 
0ae6 01 00 40			ld bc, 04000h 
0ae9 c3 f5 0a			jp delayloop 
0aec			delay500ms: 
0aec				;push de 
0aec 01 00 80			ld bc, 08000h 
0aef c3 f5 0a			jp delayloop 
0af2			delay1s: 
0af2				;push bc 
0af2			   ; Clobbers A, d and e 
0af2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af5			delayloop: 
0af5 c5			    push bc 
0af6			 
0af6			if BASE_CPM 
0af6 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af9			.cpmloop: 
0af9 c5				push bc 
0afa			 
0afa			endif 
0afa			 
0afa			 
0afa			 
0afa			delayloopi: 
0afa			;	push bc 
0afa			;.dl: 
0afa cb 47		    bit     0,a    	; 8 
0afc cb 47		    bit     0,a    	; 8 
0afe cb 47		    bit     0,a    	; 8 
0b00 e6 ff		    and     255  	; 7 
0b02 0b			    dec     bc      	; 6 
0b03 79			    ld      a,c     	; 4 
0b04 b0			    or      b     	; 4 
0b05 c2 fa 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b08			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b08				;pop de 
0b08			;pop bc 
0b08			 
0b08			if BASE_CPM 
0b08 c1				pop bc 
0b09				 
0b09 0b			    dec     bc      	; 6 
0b0a 79			    ld      a,c     	; 4 
0b0b b0			    or      b     	; 4 
0b0c c2 f9 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0f				 
0b0f			 
0b0f			endif 
0b0f			;if CPU_CLOCK_8MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f			 
0b0f			;if CPU_CLOCK_10MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f c1			    pop bc 
0b10			 
0b10 c9				ret 
0b11			 
0b11			 
0b11			 
0b11			; eof 
# End of file firmware_general.asm
0b11			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b11			; display routines that use the physical hardware abstraction layer 
0b11			 
0b11			 
0b11			; information window 
0b11			 
0b11			; pass hl with 1st string to display 
0b11			; pass de with 2nd string to display 
0b11			 
0b11			info_panel: 
0b11 e5				push hl 
0b12			 
0b12 2a d2 eb			ld hl, (display_fb_active) 
0b15 e5				push hl    ; future de destination 
0b16 21 b7 ed				ld hl, display_fb0 
0b19 22 d2 eb				ld (display_fb_active), hl 
0b1c			 
0b1c			;	call clear_display 
0b1c			 
0b1c				if BASE_CPM 
0b1c 3e 2e			ld a, '.' 
0b1e				else 
0b1e				ld a, 165 
0b1e				endif 
0b1e cd 85 0b			call fill_display 
0b21			 
0b21			 
0b21 3e 55			ld a, display_row_3 + 5 
0b23 cd 93 0b			call str_at_display 
0b26			 
0b26 e1				pop hl 
0b27 d1				pop de 
0b28			 
0b28 e5				push hl 
0b29			 
0b29			 
0b29 3e 2d			ld a, display_row_2 + 5 
0b2b cd 93 0b			call str_at_display 
0b2e			 
0b2e			 
0b2e cd a3 0b			call update_display 
0b31 cd 97 1b			call next_page_prompt 
0b34 cd 80 0b			call clear_display 
0b37			 
0b37				 
0b37 21 16 ed				ld hl, display_fb1 
0b3a 22 d2 eb				ld (display_fb_active), hl 
0b3d cd a3 0b			call update_display 
0b40			 
0b40 e1				pop hl 
0b41			 
0b41 c9				ret 
0b42			 
0b42			 
0b42			 
0b42			 
0b42			; TODO windowing? 
0b42			 
0b42			; TODO scroll line up 
0b42			 
0b42			scroll_up: 
0b42			 
0b42 e5				push hl 
0b43 d5				push de 
0b44 c5				push bc 
0b45			 
0b45				; get frame buffer  
0b45			 
0b45 2a d2 eb			ld hl, (display_fb_active) 
0b48 e5				push hl    ; future de destination 
0b49			 
0b49 11 28 00			ld  de, display_cols 
0b4c 19				add hl, de 
0b4d			 
0b4d d1				pop de 
0b4e			 
0b4e				;ex de, hl 
0b4e 01 9f 00			ld bc, display_fb_len -1  
0b51			;if DEBUG_FORTH_WORDS 
0b51			;	DMARK "SCL" 
0b51			;	CALLMONITOR 
0b51			;endif	 
0b51 ed b0			ldir 
0b53			 
0b53				; wipe bottom row 
0b53			 
0b53			 
0b53 2a d2 eb			ld hl, (display_fb_active) 
0b56 11 a0 00			ld de, display_cols*display_rows 
0b59 19				add hl, de 
0b5a 06 28			ld b, display_cols 
0b5c 3e 20			ld a, ' ' 
0b5e			.scwipe: 
0b5e 77				ld (hl), a 
0b5f 2b				dec hl 
0b60 10 fc			djnz .scwipe 
0b62			 
0b62				;pop hl 
0b62			 
0b62 c1				pop bc 
0b63 d1				pop de 
0b64 e1				pop hl 
0b65			 
0b65 c9				ret 
0b66			 
0b66			 
0b66			;scroll_upo: 
0b66			;	ld de, display_row_1 
0b66			 ;	ld hl, display_row_2 
0b66			;	ld bc, display_cols 
0b66			;	ldir 
0b66			;	ld de, display_row_2 
0b66			 ;	ld hl, display_row_3 
0b66			;	ld bc, display_cols 
0b66			;	ldir 
0b66			;	ld de, display_row_3 
0b66			 ;	ld hl, display_row_4 
0b66			;	ld bc, display_cols 
0b66			;	ldir 
0b66			 
0b66			; TODO clear row 4 
0b66			 
0b66			;	ret 
0b66			 
0b66				 
0b66			scroll_down: 
0b66			 
0b66 e5				push hl 
0b67 d5				push de 
0b68 c5				push bc 
0b69			 
0b69				; get frame buffer  
0b69			 
0b69 2a d2 eb			ld hl, (display_fb_active) 
0b6c			 
0b6c 11 9f 00			ld de, display_fb_len - 1 
0b6f 19				add hl, de 
0b70			 
0b70 e5			push hl    ; future de destination 
0b71			 
0b71 11 28 00			ld  de, display_cols 
0b74 ed 52			sbc hl, de 
0b76			 
0b76			 
0b76 d1				pop de 
0b77			 
0b77			;	ex de, hl 
0b77 01 9f 00			ld bc, display_fb_len -1  
0b7a			 
0b7a			 
0b7a				 
0b7a			 
0b7a ed b0			ldir 
0b7c			 
0b7c				; wipe bottom row 
0b7c			 
0b7c			 
0b7c			;	ld hl, (display_fb_active) 
0b7c			;;	ld de, display_cols*display_rows 
0b7c			;;	add hl, de 
0b7c			;	ld b, display_cols 
0b7c			;	ld a, ' ' 
0b7c			;.scwiped: 
0b7c			;	ld (hl), a 
0b7c			;	dec hl 
0b7c			;	djnz .scwiped 
0b7c			 
0b7c				;pop hl 
0b7c			 
0b7c c1				pop bc 
0b7d d1				pop de 
0b7e e1				pop hl 
0b7f			 
0b7f c9				ret 
0b80			;scroll_down: 
0b80			;	ld de, display_row_4 
0b80			;	ld hl, display_row_3 
0b80			;	ld bc, display_cols 
0b80			;	ldir 
0b80			;	ld de, display_row_3 
0b80			; 	ld hl, display_row_2 
0b80			;	ld bc, display_cols 
0b80			;	ldir 
0b80			;	ld de, display_row_2 
0b80			;	ld hl, display_row_1 
0b80			;	ld bc, display_cols 
0b80			;	ldir 
0b80			;;; TODO clear row 1 
0b80			;	ret 
0b80			 
0b80			 
0b80			 
0b80			 
0b80			 
0b80			; clear active frame buffer 
0b80			 
0b80			clear_display: 
0b80 3e 20			ld a, ' ' 
0b82 c3 85 0b			jp fill_display 
0b85			 
0b85			; fill active frame buffer with a char in A 
0b85			 
0b85			fill_display: 
0b85 06 a0			ld b,display_fb_len 
0b87 2a d2 eb			ld hl, (display_fb_active) 
0b8a 77			.fd1:	ld (hl),a 
0b8b 23				inc hl 
0b8c 10 fc			djnz .fd1 
0b8e 23				inc hl 
0b8f 3e 00			ld a,0 
0b91 77				ld (hl),a 
0b92			 
0b92			 
0b92 c9				ret 
0b93			; Write string (DE) at pos (A) to active frame buffer 
0b93			 
0b93 2a d2 eb		str_at_display:    ld hl,(display_fb_active) 
0b96 06 00					ld b,0 
0b98 4f					ld c,a 
0b99 09					add hl,bc 
0b9a 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0b9b b7			            OR   A              ;Null terminator? 
0b9c c8			            RET  Z              ;Yes, so finished 
0b9d 77					ld (hl),a 
0b9e 23				inc hl 
0b9f 13			            INC  DE             ;Point to next character 
0ba0 18 f8		            JR   .sad1     ;Repeat 
0ba2 c9					ret 
0ba3			 
0ba3			; using current frame buffer write to physical display 
0ba3			 
0ba3			update_display: 
0ba3 e5				push hl 
0ba4 2a d2 eb			ld hl, (display_fb_active) 
0ba7 cd 40 5e			call write_display 
0baa e1				pop hl 
0bab c9				ret 
0bac			 
0bac			; TODO scrolling 
0bac			 
0bac			 
0bac			; move cursor right one char 
0bac			cursor_right: 
0bac			 
0bac				; TODO shift right 
0bac				; TODO if beyond max col 
0bac				; TODO       cursor_next_line 
0bac			 
0bac c9				ret 
0bad			 
0bad			 
0bad			cursor_next_line: 
0bad				; TODO first char 
0bad				; TODO line down 
0bad				; TODO if past last row 
0bad				; TODO    scroll up 
0bad			 
0bad c9				ret 
0bae			 
0bae			cursor_left: 
0bae				; TODO shift left 
0bae				; TODO if beyond left  
0bae				; TODO     cursor prev line 
0bae				 
0bae c9				ret 
0baf			 
0baf			cursor_prev_line: 
0baf				; TODO last char 
0baf				; TODO line up 
0baf				; TODO if past first row 
0baf				; TODO   scroll down 
0baf			 
0baf c9				ret 
0bb0			 
0bb0			 
0bb0			cout: 
0bb0				; A - char 
0bb0 c9				ret 
0bb1			 
0bb1			 
0bb1			; Display a menu and allow item selection (optional toggle items) 
0bb1			; 
0bb1			; format: 
0bb1			; hl pointer to word array with zero term for items 
0bb1			; e.g.    db item1 
0bb1			;         db .... 
0bb1			;         db 0 
0bb1			; 
0bb1			; a = starting menu item  
0bb1			; 
0bb1			; de = pointer item toggle array   (todo) 
0bb1			; 
0bb1			; returns item selected in a 1-... 
0bb1			; returns 0 if back button pressed 
0bb1			; 
0bb1			; NOTE: Uses system frame buffer to display 
0bb1			; 
0bb1			; LEFT, Q = go back 
0bb1			; RIGHT, SPACE, CR = select 
0bb1			; UP, A - Up 
0bb1			; DOWN, Z - Down 
0bb1			 
0bb1			 
0bb1			 
0bb1			 
0bb1			 
0bb1			menu: 
0bb1			 
0bb1					; keep array pointer 
0bb1			 
0bb1 22 7d ea				ld (store_tmp1), hl 
0bb4 32 7b ea				ld (store_tmp2), a 
0bb7			 
0bb7					; check for key bounce 
0bb7			 
0bb7			if BASE_KEV 
0bb7			 
0bb7			.mbounce:	call cin 
0bb7					cp 0 
0bb7					jr nz, .mbounce 
0bb7			endif 
0bb7					; for ease use ex 
0bb7			 
0bb7					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bb7 21 b7 ed				ld hl, display_fb0 
0bba 22 d2 eb				ld (display_fb_active), hl 
0bbd			 
0bbd cd 80 0b		.mloop:		call clear_display 
0bc0 cd a3 0b				call update_display 
0bc3			 
0bc3					; draw selection id '>' at 1 
0bc3			 
0bc3					; init start of list display 
0bc3			 
0bc3 3e 05				ld a, 5 
0bc5 32 79 ea				ld (store_tmp3), a   ; display row count 
0bc8 3a 7b ea				ld a,( store_tmp2) 
0bcb 32 7c ea				ld (store_tmp2+1), a   ; display item count 
0bce			 
0bce					 
0bce			.mitem:	 
0bce			 
0bce			 
0bce 3a 7c ea				ld a,(store_tmp2+1) 
0bd1 6f					ld l, a 
0bd2 26 00				ld h, 0 
0bd4 29					add hl, hl 
0bd5 ed 5b 7d ea			ld de, (store_tmp1) 
0bd9 19					add hl, de 
0bda 7e					ld a, (hl) 
0bdb 23					inc hl 
0bdc 66					ld h,(hl) 
0bdd 6f					ld l, a 
0bde			 
0bde cd d6 0d				call ishlzero 
0be1 28 1a				jr z, .mdone 
0be3			 
0be3 eb					ex de, hl 
0be4 3a 79 ea				ld a, (store_tmp3) 
0be7 cd 93 0b				call str_at_display 
0bea					 
0bea			 
0bea					; next item 
0bea 3a 7c ea				ld a, (store_tmp2+1) 
0bed 3c					inc a 
0bee 32 7c ea				ld (store_tmp2+1), a   ; display item count 
0bf1			 
0bf1			 		; next row 
0bf1			 
0bf1 3a 79 ea				ld a, (store_tmp3) 
0bf4 c6 28				add display_cols 
0bf6 32 79 ea				ld (store_tmp3), a 
0bf9			 
0bf9					; at end of screen? 
0bf9			 
0bf9 fe 10				cp display_rows*4 
0bfb 20 d1				jr nz, .mitem 
0bfd			 
0bfd			 
0bfd			.mdone: 
0bfd cd d6 0d				call ishlzero 
0c00 28 08				jr z, .nodn 
0c02			 
0c02 3e 78				ld a, display_row_4 
0c04 11 83 0c				ld de, .mdown 
0c07 cd 93 0b				call str_at_display 
0c0a			 
0c0a					; draw options to fill the screens with active item on line 1 
0c0a					; if current option is 2 or more then display ^ in top 
0c0a			 
0c0a 3a 7b ea		.nodn:		ld a, (store_tmp2) 
0c0d fe 00				cp 0 
0c0f 28 08				jr z, .noup 
0c11			 
0c11 3e 00				ld a, 0 
0c13 11 81 0c				ld de, .mup 
0c16 cd 93 0b				call str_at_display 
0c19			 
0c19 3e 02		.noup:		ld a, 2 
0c1b 11 7f 0c				ld de, .msel 
0c1e cd 93 0b				call str_at_display 
0c21			 
0c21					; if current option + 1 is not null then display V in bottom 
0c21					; get key 
0c21 cd a3 0b				call update_display 
0c24			 
0c24			 
0c24					; handle key 
0c24			 
0c24 cd f2 5e				call cin_wait 
0c27			 
0c27 fe 05				cp KEY_UP 
0c29 28 2b				jr z, .mgoup 
0c2b fe 61				cp 'a' 
0c2d 28 27				jr z, .mgoup 
0c2f fe 0a				cp KEY_DOWN 
0c31 28 32				jr z, .mgod 
0c33 fe 7a				cp 'z' 
0c35 28 2e				jr z, .mgod 
0c37 fe 20				cp ' ' 
0c39 28 34				jr z, .goend 
0c3b fe 0c				cp KEY_RIGHT 
0c3d 28 30				jr z, .goend 
0c3f fe 0d				cp KEY_CR 
0c41 28 2c				jr z, .goend 
0c43 fe 71				cp 'q' 
0c45 28 0b				jr z, .goback 
0c47			 
0c47 fe 0b				cp KEY_LEFT 
0c49 28 07				jr z, .goback 
0c4b fe 08				cp KEY_BS 
0c4d 28 03				jr z, .goback 
0c4f c3 bd 0b				jp .mloop 
0c52			 
0c52			.goback: 
0c52 3e 00			ld a, 0 
0c54 18 1d			jr .goend2 
0c56			 
0c56				; move up one 
0c56			.mgoup: 
0c56 3a 7b ea				ld a, (store_tmp2) 
0c59 fe 00				cp 0 
0c5b ca bd 0b				jp z, .mloop 
0c5e 3d					dec a 
0c5f 32 7b ea				ld (store_tmp2), a 
0c62 c3 bd 0b				jp .mloop 
0c65			 
0c65				; move down one 
0c65			.mgod: 
0c65 3a 7b ea				ld a, (store_tmp2) 
0c68 3c					inc a 
0c69 32 7b ea				ld (store_tmp2), a 
0c6c c3 bd 0b				jp .mloop 
0c6f			 
0c6f			 
0c6f			.goend: 
0c6f					; get selected item number 
0c6f			 
0c6f 3a 7b ea				ld a, (store_tmp2) 
0c72 3c					inc a 
0c73			 
0c73			.goend2: 
0c73 f5					push af 
0c74			 
0c74					; restore active fb 
0c74					; TODO BUG assumes fb1 
0c74			 
0c74 21 16 ed				ld hl, display_fb1 
0c77 22 d2 eb				ld (display_fb_active), hl 
0c7a			 
0c7a					; restore main regs 
0c7a			 
0c7a			 
0c7a cd a3 0b				call update_display 
0c7d			 
0c7d f1					pop af 
0c7e			 
0c7e c9				ret 
0c7f			 
0c7f .. 00		.msel:   db ">",0 
0c81 .. 00		.mup:   db "^",0 
0c83 .. 00		.mdown:   db "v",0 
0c85			 
0c85			 
0c85			; eof 
0c85			 
# End of file firmware_display.asm
0c85			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0c85			; random number generators 
0c85			 
0c85			 
0c85			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0c85			 
0c85			 
0c85			;-----> Generate a random number 
0c85			; output a=answer 0<=a<=255 
0c85			; all registers are preserved except: af 
0c85			random: 
0c85 e5			        push    hl 
0c86 d5			        push    de 
0c87 2a b4 eb		        ld      hl,(randData) 
0c8a ed 5f		        ld      a,r 
0c8c 57			        ld      d,a 
0c8d 5e			        ld      e,(hl) 
0c8e 19			        add     hl,de 
0c8f 85			        add     a,l 
0c90 ac			        xor     h 
0c91 22 b4 eb		        ld      (randData),hl 
0c94 d1			        pop     de 
0c95 e1			        pop     hl 
0c96 c9			        ret 
0c97			 
0c97			 
0c97			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0c97			 
0c97			 
0c97			 
0c97			;------LFSR------ 
0c97			;James Montelongo 
0c97			;optimized by Spencer Putt 
0c97			;out: 
0c97			; a = 8 bit random number 
0c97			RandLFSR: 
0c97 21 ba eb		        ld hl,LFSRSeed+4 
0c9a 5e			        ld e,(hl) 
0c9b 23			        inc hl 
0c9c 56			        ld d,(hl) 
0c9d 23			        inc hl 
0c9e 4e			        ld c,(hl) 
0c9f 23			        inc hl 
0ca0 7e			        ld a,(hl) 
0ca1 47			        ld b,a 
0ca2 cb 13		        rl e  
0ca4 cb 12			rl d 
0ca6 cb 11		        rl c  
0ca8 17				rla 
0ca9 cb 13		        rl e  
0cab cb 12			rl d 
0cad cb 11		        rl c  
0caf 17				rla 
0cb0 cb 13		        rl e  
0cb2 cb 12			rl d 
0cb4 cb 11		        rl c  
0cb6 17				rla 
0cb7 67			        ld h,a 
0cb8 cb 13		        rl e  
0cba cb 12			rl d 
0cbc cb 11		        rl c  
0cbe 17				rla 
0cbf a8			        xor b 
0cc0 cb 13		        rl e  
0cc2 cb 12			rl d 
0cc4 ac			        xor h 
0cc5 a9			        xor c 
0cc6 aa			        xor d 
0cc7 21 bc eb		        ld hl,LFSRSeed+6 
0cca 11 bd eb		        ld de,LFSRSeed+7 
0ccd 01 07 00		        ld bc,7 
0cd0 ed b8		        lddr 
0cd2 12			        ld (de),a 
0cd3 c9			        ret 
0cd4			 
0cd4			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0cd4			 
0cd4			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0cd4			 
0cd4			 
0cd4			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0cd4			 
0cd4			prng16: 
0cd4			;Inputs: 
0cd4			;   (seed1) contains a 16-bit seed value 
0cd4			;   (seed2) contains a NON-ZERO 16-bit seed value 
0cd4			;Outputs: 
0cd4			;   HL is the result 
0cd4			;   BC is the result of the LCG, so not that great of quality 
0cd4			;   DE is preserved 
0cd4			;Destroys: 
0cd4			;   AF 
0cd4			;cycle: 4,294,901,760 (almost 4.3 billion) 
0cd4			;160cc 
0cd4			;26 bytes 
0cd4 2a ae eb		    ld hl,(seed1) 
0cd7 44			    ld b,h 
0cd8 4d			    ld c,l 
0cd9 29			    add hl,hl 
0cda 29			    add hl,hl 
0cdb 2c			    inc l 
0cdc 09			    add hl,bc 
0cdd 22 ae eb		    ld (seed1),hl 
0ce0 2a ac eb		    ld hl,(seed2) 
0ce3 29			    add hl,hl 
0ce4 9f			    sbc a,a 
0ce5 e6 2d		    and %00101101 
0ce7 ad			    xor l 
0ce8 6f			    ld l,a 
0ce9 22 ac eb		    ld (seed2),hl 
0cec 09			    add hl,bc 
0ced c9			    ret 
0cee			 
0cee			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0cee			 
0cee			rand32: 
0cee			;Inputs: 
0cee			;   (seed1_0) holds the lower 16 bits of the first seed 
0cee			;   (seed1_1) holds the upper 16 bits of the first seed 
0cee			;   (seed2_0) holds the lower 16 bits of the second seed 
0cee			;   (seed2_1) holds the upper 16 bits of the second seed 
0cee			;   **NOTE: seed2 must be non-zero 
0cee			;Outputs: 
0cee			;   HL is the result 
0cee			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0cee			;Destroys: 
0cee			;   AF 
0cee			;Tested and passes all CAcert tests 
0cee			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0cee			;it has a period of 18,446,744,069,414,584,320 
0cee			;roughly 18.4 quintillion. 
0cee			;LFSR taps: 0,2,6,7  = 11000101 
0cee			;291cc 
0cee			;seed1_0=$+1 
0cee			;    ld hl,12345 
0cee			;seed1_1=$+1 
0cee			;    ld de,6789 
0cee			;    ld b,h 
0cee			;    ld c,l 
0cee			;    add hl,hl \ rl e \ rl d 
0cee			;    add hl,hl \ rl e \ rl d 
0cee			;    inc l 
0cee			;    add hl,bc 
0cee			;    ld (seed1_0),hl 
0cee			;    ld hl,(seed1_1) 
0cee			;    adc hl,de 
0cee			;    ld (seed1_1),hl 
0cee			;    ex de,hl 
0cee			;seed2_0=$+1 
0cee			;    ld hl,9876 
0cee			;seed2_1=$+1 
0cee			;    ld bc,54321 
0cee			;    add hl,hl \ rl c \ rl b 
0cee			;    ld (seed2_1),bc 
0cee			;    sbc a,a 
0cee			;    and %11000101 
0cee			;    xor l 
0cee			;    ld l,a 
0cee			;    ld (seed2_0),hl 
0cee			;    ex de,hl 
0cee			;    add hl,bc 
0cee			;    ret 
0cee			; 
0cee			 
0cee			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0cee			; 20 bytes, 86 cycles (excluding ret) 
0cee			 
0cee			; returns   hl = pseudorandom number 
0cee			; corrupts   a 
0cee			 
0cee			; generates 16-bit pseudorandom numbers with a period of 65535 
0cee			; using the xorshift method: 
0cee			 
0cee			; hl ^= hl << 7 
0cee			; hl ^= hl >> 9 
0cee			; hl ^= hl << 8 
0cee			 
0cee			; some alternative shift triplets which also perform well are: 
0cee			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0cee			 
0cee			;  org 32768 
0cee			 
0cee			xrnd: 
0cee 2a b2 eb		  ld hl,(xrandc)       ; seed must not be 0 
0cf1 3e 00		  ld a,0 
0cf3 bd			  cp l 
0cf4 20 02		  jr nz, .xrnd1 
0cf6 2e 01		  ld l, 1 
0cf8			.xrnd1: 
0cf8			 
0cf8 7c			  ld a,h 
0cf9 1f			  rra 
0cfa 7d			  ld a,l 
0cfb 1f			  rra 
0cfc ac			  xor h 
0cfd 67			  ld h,a 
0cfe 7d			  ld a,l 
0cff 1f			  rra 
0d00 7c			  ld a,h 
0d01 1f			  rra 
0d02 ad			  xor l 
0d03 6f			  ld l,a 
0d04 ac			  xor h 
0d05 67			  ld h,a 
0d06			 
0d06 22 b2 eb		  ld (xrandc),hl 
0d09			 
0d09 c9			  ret 
0d0a			;  
0d0a			 
0d0a			 
0d0a			;;;; int maths 
0d0a			 
0d0a			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d0a			; Divide 16-bit values (with 16-bit result) 
0d0a			; In: Divide BC by divider DE 
0d0a			; Out: BC = result, HL = rest 
0d0a			; 
0d0a			Div16: 
0d0a 21 00 00		    ld hl,0 
0d0d 78			    ld a,b 
0d0e 06 08		    ld b,8 
0d10			Div16_Loop1: 
0d10 17			    rla 
0d11 ed 6a		    adc hl,hl 
0d13 ed 52		    sbc hl,de 
0d15 30 01		    jr nc,Div16_NoAdd1 
0d17 19			    add hl,de 
0d18			Div16_NoAdd1: 
0d18 10 f6		    djnz Div16_Loop1 
0d1a 17			    rla 
0d1b 2f			    cpl 
0d1c 47			    ld b,a 
0d1d 79			    ld a,c 
0d1e 48			    ld c,b 
0d1f 06 08		    ld b,8 
0d21			Div16_Loop2: 
0d21 17			    rla 
0d22 ed 6a		    adc hl,hl 
0d24 ed 52		    sbc hl,de 
0d26 30 01		    jr nc,Div16_NoAdd2 
0d28 19			    add hl,de 
0d29			Div16_NoAdd2: 
0d29 10 f6		    djnz Div16_Loop2 
0d2b 17			    rla 
0d2c 2f			    cpl 
0d2d 41			    ld b,c 
0d2e 4f			    ld c,a 
0d2f c9			ret 
0d30			 
0d30			 
0d30			;http://z80-heaven.wikidot.com/math 
0d30			; 
0d30			;Inputs: 
0d30			;     DE and A are factors 
0d30			;Outputs: 
0d30			;     A is not changed 
0d30			;     B is 0 
0d30			;     C is not changed 
0d30			;     DE is not changed 
0d30			;     HL is the product 
0d30			;Time: 
0d30			;     342+6x 
0d30			; 
0d30			Mult16: 
0d30			 
0d30 06 08		     ld b,8          ;7           7 
0d32 21 00 00		     ld hl,0         ;10         10 
0d35 29			       add hl,hl     ;11*8       88 
0d36 07			       rlca          ;4*8        32 
0d37 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d39 19			         add hl,de   ;--         -- 
0d3a 10 f9		       djnz $-5      ;13*7+8     99 
0d3c c9			ret 
0d3d			 
0d3d			; 
0d3d			; Square root of 16-bit value 
0d3d			; In:  HL = value 
0d3d			; Out:  D = result (rounded down) 
0d3d			; 
0d3d			;Sqr16: 
0d3d			;    ld de,#0040 
0d3d			;    ld a,l 
0d3d			;    ld l,h 
0d3d			;    ld h,d 
0d3d			;    or a 
0d3d			;    ld b,8 
0d3d			;Sqr16_Loop: 
0d3d			;    sbc hl,de 
0d3d			;    jr nc,Sqr16_Skip 
0d3d			;    add hl,de 
0d3d			;Sqr16_Skip: 
0d3d			;    ccf 
0d3d			;    rl d 
0d3d			;    add a,a 
0d3d			;    adc hl,hl 
0d3d			;    add a,a 
0d3d			;    adc hl,hl 
0d3d			;    djnz Sqr16_Loop 
0d3d			;    ret 
0d3d			; 
0d3d			; 
0d3d			; Divide 8-bit values 
0d3d			; In: Divide E by divider C 
0d3d			; Out: A = result, B = rest 
0d3d			; 
0d3d			Div8: 
0d3d af			    xor a 
0d3e 06 08		    ld b,8 
0d40			Div8_Loop: 
0d40 cb 13		    rl e 
0d42 17			    rla 
0d43 91			    sub c 
0d44 30 01		    jr nc,Div8_NoAdd 
0d46 81			    add a,c 
0d47			Div8_NoAdd: 
0d47 10 f7		    djnz Div8_Loop 
0d49 47			    ld b,a 
0d4a 7b			    ld a,e 
0d4b 17			    rla 
0d4c 2f			    cpl 
0d4d c9			    ret 
0d4e			 
0d4e			; 
0d4e			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d4e			; In: Multiply A with DE 
0d4e			; Out: HL = result 
0d4e			; 
0d4e			Mult12U: 
0d4e 2e 00		    ld l,0 
0d50 87			    add a,a 
0d51 30 01		    jr nc,Mult12U_NoAdd0 
0d53 19			    add hl,de 
0d54			Mult12U_NoAdd0: 
0d54 29			    add hl,hl 
0d55 87			    add a,a 
0d56 30 01		    jr nc,Mult12U_NoAdd1 
0d58 19			    add hl,de 
0d59			Mult12U_NoAdd1: 
0d59 29			    add hl,hl 
0d5a 87			    add a,a 
0d5b 30 01		    jr nc,Mult12U_NoAdd2 
0d5d 19			    add hl,de 
0d5e			Mult12U_NoAdd2: 
0d5e 29			    add hl,hl 
0d5f 87			    add a,a 
0d60 30 01		    jr nc,Mult12U_NoAdd3 
0d62 19			    add hl,de 
0d63			Mult12U_NoAdd3: 
0d63 29			    add hl,hl 
0d64 87			    add a,a 
0d65 30 01		    jr nc,Mult12U_NoAdd4 
0d67 19			    add hl,de 
0d68			Mult12U_NoAdd4: 
0d68 29			    add hl,hl 
0d69 87			    add a,a 
0d6a 30 01		    jr nc,Mult12U_NoAdd5 
0d6c 19			    add hl,de 
0d6d			Mult12U_NoAdd5: 
0d6d 29			    add hl,hl 
0d6e 87			    add a,a 
0d6f 30 01		    jr nc,Mult12U_NoAdd6 
0d71 19			    add hl,de 
0d72			Mult12U_NoAdd6: 
0d72 29			    add hl,hl 
0d73 87			    add a,a 
0d74 d0			    ret nc 
0d75 19			    add hl,de 
0d76 c9			    ret 
0d77			 
0d77			; 
0d77			; Multiply 8-bit value with a 16-bit value (right rotating) 
0d77			; In: Multiply A with DE 
0d77			;      Put lowest value in A for most efficient calculation 
0d77			; Out: HL = result 
0d77			; 
0d77			Mult12R: 
0d77 21 00 00		    ld hl,0 
0d7a			Mult12R_Loop: 
0d7a cb 3f		    srl a 
0d7c 30 01		    jr nc,Mult12R_NoAdd 
0d7e 19			    add hl,de 
0d7f			Mult12R_NoAdd: 
0d7f cb 23		    sla e 
0d81 cb 12		    rl d 
0d83 b7			    or a 
0d84 c2 7a 0d		    jp nz,Mult12R_Loop 
0d87 c9			    ret 
0d88			 
0d88			; 
0d88			; Multiply 16-bit values (with 32-bit result) 
0d88			; In: Multiply BC with DE 
0d88			; Out: BCHL = result 
0d88			; 
0d88			Mult32: 
0d88 79			    ld a,c 
0d89 48			    ld c,b 
0d8a 21 00 00		    ld hl,0 
0d8d 06 10		    ld b,16 
0d8f			Mult32_Loop: 
0d8f 29			    add hl,hl 
0d90 17			    rla 
0d91 cb 11		    rl c 
0d93 30 07		    jr nc,Mult32_NoAdd 
0d95 19			    add hl,de 
0d96 ce 00		    adc a,0 
0d98 d2 9c 0d		    jp nc,Mult32_NoAdd 
0d9b 0c			    inc c 
0d9c			Mult32_NoAdd: 
0d9c 10 f1		    djnz Mult32_Loop 
0d9e 41			    ld b,c 
0d9f 4f			    ld c,a 
0da0 c9			    ret 
0da1			 
0da1			 
0da1			 
0da1			; 
0da1			; Multiply 8-bit values 
0da1			; In:  Multiply H with E 
0da1			; Out: HL = result 
0da1			; 
0da1			Mult8: 
0da1 16 00		    ld d,0 
0da3 6a			    ld l,d 
0da4 06 08		    ld b,8 
0da6			Mult8_Loop: 
0da6 29			    add hl,hl 
0da7 30 01		    jr nc,Mult8_NoAdd 
0da9 19			    add hl,de 
0daa			Mult8_NoAdd: 
0daa 10 fa		    djnz Mult8_Loop 
0dac c9			    ret 
0dad			 
0dad			 
0dad			 
0dad			 
0dad			 
0dad			 
0dad			 
0dad			 
0dad			;;http://z80-heaven.wikidot.com/math 
0dad			;;This divides DE by BC, storing the result in DE, remainder in HL 
0dad			; 
0dad			;DE_Div_BC:          ;1281-2x, x is at most 16 
0dad			;     ld a,16        ;7 
0dad			;     ld hl,0        ;10 
0dad			;     jp $+5         ;10 
0dad			;.DivLoop: 
0dad			;       add hl,bc    ;-- 
0dad			;       dec a        ;64 
0dad			;       jr z,.DivLoopEnd        ;86 
0dad			; 
0dad			;       sla e        ;128 
0dad			;       rl d         ;128 
0dad			;       adc hl,hl    ;240 
0dad			;       sbc hl,bc    ;240 
0dad			;       jr nc,.DivLoop ;23|21 
0dad			;       inc e        ;-- 
0dad			;       jp .DivLoop+1 
0dad			; 
0dad			;.DivLoopEnd: 
0dad			 
0dad			;HL_Div_C: 
0dad			;Inputs: 
0dad			;     HL is the numerator 
0dad			;     C is the denominator 
0dad			;Outputs: 
0dad			;     A is the remainder 
0dad			;     B is 0 
0dad			;     C is not changed 
0dad			;     DE is not changed 
0dad			;     HL is the quotient 
0dad			; 
0dad			;       ld b,16 
0dad			;       xor a 
0dad			;         add hl,hl 
0dad			;         rla 
0dad			;         cp c 
0dad			;         jr c,$+4 
0dad			;           inc l 
0dad			;           sub c 
0dad			;         djnz $-7 
0dad			 
0dad			; https://plutiedev.com/z80-add-8bit-to-16bit 
0dad			 
0dad			addatohl: 
0dad 85			    add   a, l    ; A = A+L 
0dae 6f			    ld    l, a    ; L = A+L 
0daf 8c			    adc   a, h    ; A = A+L+H+carry 
0db0 95			    sub   l       ; A = H+carry 
0db1 67			    ld    h, a    ; H = H+carry 
0db2 c9			ret 
0db3			 
0db3			addatode: 
0db3 83			    add   a, e    ; A = A+L 
0db4 5f			    ld    e, a    ; L = A+L 
0db5 8a			    adc   a, d    ; A = A+L+H+carry 
0db6 93			    sub   e       ; A = H+carry 
0db7 57			    ld    d, a    ; H = H+carry 
0db8 c9			ret 
0db9			 
0db9			 
0db9			addatobc: 
0db9 81			    add   a, c    ; A = A+L 
0dba 4f			    ld    c, a    ; L = A+L 
0dbb 88			    adc   a, b    ; A = A+L+H+carry 
0dbc 91			    sub   c       ; A = H+carry 
0dbd 47			    ld    b, a    ; H = H+carry 
0dbe c9			ret 
0dbf			 
0dbf			subafromhl: 
0dbf			   ; If A=0 do nothing 
0dbf			    ; Otherwise flip A's sign. Since 
0dbf			    ; the upper byte becomes -1, also 
0dbf			    ; substract 1 from H. 
0dbf ed 44		    neg 
0dc1 ca ca 0d		    jp    z, Skip 
0dc4 25			    dec   h 
0dc5			     
0dc5			    ; Now add the low byte as usual 
0dc5			    ; Two's complement takes care of 
0dc5			    ; ensuring the result is correct 
0dc5 85			    add   a, l 
0dc6 6f			    ld    l, a 
0dc7 8c			    adc   a, h 
0dc8 95			    sub   l 
0dc9 67			    ld    h, a 
0dca			Skip: 
0dca c9				ret 
0dcb			 
0dcb			 
0dcb			; compare hl and de 
0dcb			; returns:  
0dcb			; if hl = de, z=1, s=0, c0=0 
0dcb			; if hl > de, z=0, s=0, c=0 
0dcb			; if hl < de, z=0, s=1, c=1 
0dcb			cmp16:	 
0dcb b7				or a 
0dcc ed 52			sbc hl,de 
0dce e0				ret po 
0dcf 7c				ld a,h 
0dd0 1f				rra 
0dd1 ee 40			xor 01000000B 
0dd3 37				scf 
0dd4 8f				adc a,a 
0dd5 c9				ret 
0dd6			 
0dd6			 
0dd6			; test if hl contains zero   - A is destroyed 
0dd6			 
0dd6			ishlzero:    
0dd6 b7				or a     ; reset flags 
0dd7 7c				ld a, h 
0dd8 b5				or l        	 
0dd9			 
0dd9 c9				ret 
0dda			 
0dda			 
0dda			 
0dda			 
0dda			if FORTH_ENABLE_FLOATMATH 
0dda			;include "float/bbcmath.z80" 
0dda			include "float/lpfpcalc.asm" 
0dda			endif 
0dda			 
0dda			 
0dda			; eof 
0dda			 
# End of file firmware_maths.asm
0dda			include "firmware_strings.asm"   ; string handling  
0dda			 
0dda			 
0dda			; TODO string len 
0dda			; input text string, end on cr with zero term 
0dda			; a offset into frame buffer to start prompt 
0dda			; d is max length 
0dda			; e is display size TODO 
0dda			; c is current cursor position 
0dda			; hl is ptr to where string will be stored 
0dda			 
0dda			 
0dda			; TODO check limit of buffer for new inserts 
0dda			; TODO check insert does not push beyond buffer 
0dda			; TODO scroll in a limited display area 
0dda			; TODO scroll whole screen on page wrap 
0dda			 
0dda			 
0dda			; TODO handle KEY_PREVWORD 
0dda			; TODO handle KEY_NEXTWORD 
0dda			; TODO handle KEY_HOME 
0dda			; TODO handle KEY_END 
0dda			; TODO use LCD cursor? 
0dda			 
0dda 32 6a ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0ddd 81					add c 
0dde 32 68 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0de1 22 6d ee				ld (input_start), hl     ; save ptr to buffer 
0de4 79					ld a, c 
0de5 cd ad 0d				call addatohl 
0de8 22 6f ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0deb 7a					ld a,d 
0dec 32 6c ee			        ld (input_size), a       ; save length of input area 
0def 79					ld a, c 
0df0 32 5b ee				ld (input_cursor),a      ; init cursor start position  
0df3 7b					ld a,e 
0df4 32 6b ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0df7					 
0df7					 
0df7			 
0df7			;		ld a,(input_ptr) 
0df7			;		ld (input_under_cursor),a 	; save what is under the cursor 
0df7			 
0df7			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0df7					; init cursor shape if not set by the cin routines 
0df7 21 ca eb				ld hl, cursor_shape 
0dfa 3e ff				ld a, 255 
0dfc 77					ld (hl), a 
0dfd 23					inc hl 
0dfe 3e 00				ld a, 0 
0e00 77					ld (hl), a 
0e01			 
0e01 3e 0f				ld a, CUR_BLINK_RATE 
0e03 32 66 ee				ld (input_cur_flash), a 
0e06 3e 01				ld a, 1 
0e08 32 65 ee				ld (input_cur_onoff),a 
0e0b			 
0e0b			;	if DEBUG_INPUT 
0e0b			;		push af 
0e0b			;		ld a, 'I' 
0e0b			;		ld (debug_mark),a 
0e0b			;		pop af 
0e0b			;		CALLMONITOR 
0e0b			;	endif 
0e0b			.is1:		; main entry loop 
0e0b			 
0e0b			 
0e0b			 
0e0b					; pause 1ms 
0e0b			 
0e0b 3e 01				ld a, 1 
0e0d cd d7 0a				call aDelayInMS 
0e10			 
0e10					; dec flash counter 
0e10 3a 66 ee				ld a, (input_cur_flash) 
0e13 3d					dec a 
0e14 32 66 ee				ld (input_cur_flash), a 
0e17 fe 00				cp 0 
0e19 20 0d				jr nz, .nochgstate 
0e1b			 
0e1b			 
0e1b					; change state 
0e1b 3a 65 ee				ld a,(input_cur_onoff) 
0e1e ed 44				neg 
0e20 32 65 ee				ld (input_cur_onoff),a 
0e23			 
0e23			 
0e23					; reset on change of state 
0e23 3e 0f				ld a, CUR_BLINK_RATE 
0e25 32 66 ee				ld (input_cur_flash), a 
0e28			 
0e28			.nochgstate: 
0e28					 
0e28					 
0e28			 
0e28					; display cursor  
0e28			 
0e28			;		ld hl, (input_start) 
0e28			;		ld a, (input_cursor) 
0e28			;		call addatohl 
0e28			 
0e28					; get char under cursor and replace with cursor 
0e28 2a 6f ee		ld hl, (input_ptr) 
0e2b			;		ld a, (hl) 
0e2b			;		ld (input_under_cursor),a 
0e2b			;		ld a, '_' 
0e2b			;		ld (hl), a 
0e2b			 
0e2b					; display string 
0e2b			 
0e2b ed 5b 6d ee			ld de, (input_start) 
0e2f 3a 6a ee				ld a, (input_at_pos) 
0e32 cd 93 0b				call str_at_display 
0e35			;	        call update_display 
0e35			 
0e35					; find place to put the cursor 
0e35			;		add h 
0e35			;		ld l, display_row_1 
0e35			;		sub l 
0e35			; (input_at_pos) 
0e35					;ld c, a 
0e35			;		ld a, (input_cursor) 
0e35			;		ld l, (input_at_pos) 
0e35			;		;ld b, h 
0e35			;		add l 
0e35			;		ld (input_at_cursor),a 
0e35					;ld l,h 
0e35			 
0e35			;		ld h, 0 
0e35			;		ld l,(input_at_pos) 
0e35			;		ld a, (input_cursor) 
0e35			;		call addatohl 
0e35			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0e35			;		call subafromhl 
0e35			;		ld a,l 
0e35			;		ld (input_at_cursor), a 
0e35			 
0e35				if DEBUG_INPUT 
0e35					ld a, (hardware_diag) 
0e35					cp 0 
0e35					jr z, .skip_input_diag 
0e35			 
0e35					ld a,(input_at_pos) 
0e35					ld hl, LFSRSeed 
0e35					call hexout 
0e35					ld a, (input_cursor) 
0e35					ld hl, LFSRSeed+2 
0e35					call hexout 
0e35					ld a,(input_at_cursor) 
0e35					ld hl, LFSRSeed+4 
0e35					call hexout 
0e35			 
0e35					ld a,(input_cur_onoff) 
0e35					ld hl, LFSRSeed+6 
0e35					call hexout 
0e35			 
0e35					ld a,(input_cur_flash) 
0e35					ld hl, LFSRSeed+8 
0e35					call hexout 
0e35			 
0e35					ld a,(input_len) 
0e35					ld hl, LFSRSeed+10 
0e35					call hexout 
0e35					ld hl, LFSRSeed+12 
0e35					ld a, 0 
0e35					ld (hl),a 
0e35					ld a, display_row_4 
0e35					ld de, LFSRSeed 
0e35					call str_at_display 
0e35					.skip_input_diag: 
0e35				endif 
0e35			 
0e35					; decide on if we are showing the cursor this time round 
0e35			 
0e35 3a 65 ee				ld a, (input_cur_onoff) 
0e38 fe ff				cp 255 
0e3a 28 13				jr z, .skipcur 
0e3c			 
0e3c			 
0e3c 3a 68 ee				ld a,(input_at_cursor) 
0e3f 11 ca eb				ld de, cursor_shape 
0e42 cd 93 0b				call str_at_display 
0e45			 
0e45					; save length of current input string 
0e45 2a 6d ee				ld hl, (input_start) 
0e48 cd 0b 12				call strlenz 
0e4b 7d					ld a,l 
0e4c 32 60 ee				ld (input_len),a 
0e4f			 
0e4f			.skipcur: 
0e4f			 
0e4f cd a3 0b			        call update_display 
0e52					 
0e52			 
0e52			 
0e52					; wait 
0e52				 
0e52					; TODO loop without wait to flash the cursor and char under cursor	 
0e52 cd fa 5e				call cin    ; _wait 
0e55			 
0e55 fe 00				cp 0 
0e57 ca 0b 0e				jp z, .is1 
0e5a			 
0e5a					; get ptr to char to input into 
0e5a			 
0e5a 4f					ld c,a 
0e5b 2a 6d ee				ld hl, (input_start) 
0e5e 3a 5b ee				ld a, (input_cursor) 
0e61 cd ad 0d				call addatohl 
0e64 22 6f ee				ld (input_ptr), hl 
0e67 79					ld a,c 
0e68			 
0e68					; replace char under cursor 
0e68			 
0e68			;		ld hl, (input_ptr) 
0e68			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0e68			;		ld (hl), a 
0e68			 
0e68			;	if DEBUG_INPUT 
0e68			;		push af 
0e68			;		ld a, 'i' 
0e68			;		ld (debug_mark),a 
0e68			;		pop af 
0e68			;		CALLMONITOR 
0e68			;	endif 
0e68 fe 0e				cp KEY_HOME 
0e6a 20 0e				jr nz, .iske 
0e6c			 
0e6c 3a 6a ee				ld a, (input_at_pos) 
0e6f 32 68 ee				ld (input_at_cursor),a 
0e72 3e 00				ld a, 0 
0e74 32 5b ee				ld (input_cursor), a 
0e77 c3 0b 0e				jp .is1 
0e7a					 
0e7a fe 0f		.iske:		cp KEY_END 
0e7c 20 03				jr nz, .isknw 
0e7e c3 0b 0e				jp .is1 
0e81			 
0e81 fe 06		.isknw:		cp KEY_NEXTWORD 
0e83 20 1b				jr nz, .iskpw 
0e85			 
0e85 2a 6f ee		.isknwm:	ld hl, (input_ptr) 
0e88 7e					ld a,(hl)	 
0e89 fe 00				cp 0 
0e8b ca 0b 0e				jp z, .is1    ; end of string 
0e8e fe 20				cp ' ' 
0e90 ca 0b 0e				jp z, .is1    ; end of word 
0e93 23					inc hl 
0e94 22 6f ee				ld (input_ptr), hl 
0e97 3a 68 ee				ld a, (input_at_cursor) 
0e9a 3c					inc a 
0e9b 32 68 ee				ld (input_at_cursor), a 
0e9e 18 e5				jr .isknwm 
0ea0			 
0ea0 fe 07		.iskpw:		cp KEY_PREVWORD 
0ea2 20 1b				jr nz, .iskl 
0ea4			.iskpwm:	 
0ea4 2a 6f ee				ld hl, (input_ptr) 
0ea7 7e					ld a,(hl)	 
0ea8 fe 00				cp 0  
0eaa ca 0b 0e				jp z, .is1    ; end of string 
0ead fe 20				cp ' ' 
0eaf ca 0b 0e				jp z, .is1    ; end of word 
0eb2 2b					dec hl 
0eb3 22 6f ee				ld (input_ptr), hl 
0eb6 3a 68 ee				ld a, (input_at_cursor) 
0eb9 3d					dec a 
0eba 32 68 ee				ld (input_at_cursor), a 
0ebd 18 e5				jr .iskpwm 
0ebf			 
0ebf			 
0ebf fe 0b		.iskl:		cp KEY_LEFT 
0ec1 20 27				jr nz, .isk1 
0ec3			 
0ec3 3a 5b ee				ld a, (input_cursor) 
0ec6			 
0ec6 fe 00				cp 0 
0ec8 ca 0b 0e				jp z, .is1 		; at start of line to ignore  
0ecb			 
0ecb 3d					dec  a 		; TODO check underflow 
0ecc 32 5b ee				ld (input_cursor), a 
0ecf			 
0ecf 2a 6f ee				ld hl, (input_ptr) 
0ed2 2b					dec hl 
0ed3 22 6f ee				ld (input_ptr), hl 
0ed6					 
0ed6 3a 68 ee				ld a, (input_at_cursor) 
0ed9 3d					dec a 
0eda 32 68 ee				ld (input_at_cursor), a 
0edd			 
0edd 3e 01				ld a, 1		; show cursor moving 
0edf 32 65 ee				ld (input_cur_onoff),a 
0ee2 3e 0f				ld a, CUR_BLINK_RATE 
0ee4 32 66 ee				ld (input_cur_flash), a 
0ee7			 
0ee7 c3 0b 0e				jp .is1 
0eea			 
0eea fe 0c		.isk1:		cp KEY_RIGHT 
0eec 20 2a				jr nz, .isk2 
0eee			 
0eee 3a 60 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0ef1 5f					ld e,a 
0ef2 3a 5b ee				ld a, (input_cursor) 
0ef5 bb					cp e 
0ef6 ca 0b 0e				jp z, .is1		; at the end of string so dont go right 
0ef9			 
0ef9 3c					inc  a 		; TODO check overflow 
0efa 32 5b ee				ld (input_cursor), a 
0efd			 
0efd 3a 68 ee				ld a, (input_at_cursor) 
0f00 3c					inc a 
0f01 32 68 ee				ld (input_at_cursor), a 
0f04			 
0f04 2a 6f ee				ld hl, (input_ptr) 
0f07 23					inc hl 
0f08 22 6f ee				ld (input_ptr), hl 
0f0b			 
0f0b 3e 01				ld a, 1		; show cursor moving 
0f0d 32 65 ee				ld (input_cur_onoff),a 
0f10 3e 0f				ld a, CUR_BLINK_RATE 
0f12 32 66 ee				ld (input_cur_flash), a 
0f15			 
0f15 c3 0b 0e				jp .is1 
0f18			 
0f18 fe 05		.isk2:		cp KEY_UP 
0f1a			 
0f1a 20 26				jr nz, .isk3 
0f1c			 
0f1c					; swap last command with the current on 
0f1c			 
0f1c					; move cursor to start of string 
0f1c 2a 6d ee				ld hl, (input_start) 
0f1f 22 6f ee				ld (input_ptr), hl 
0f22			 
0f22 3a 6a ee				ld a, (input_at_pos) 
0f25 32 68 ee				ld (input_at_cursor), a 
0f28			 
0f28 3e 00				ld a, 0 
0f2a 32 5b ee				ld (input_cursor), a 
0f2d					 
0f2d					; swap input and last command buffers 
0f2d			 
0f2d 21 26 e6				ld hl, os_cli_cmd 
0f30 11 25 e7				ld de, os_last_cmd 
0f33 06 ff				ld b, 255 
0f35 7e			.swap1:		ld a, (hl) 
0f36 4f					ld c,a 
0f37 1a					ld a, (de) 
0f38 77					ld (hl), a 
0f39 79					ld a,c 
0f3a 12					ld (de),a 
0f3b 23					inc hl 
0f3c 13					inc de 
0f3d 10 f6				djnz .swap1 
0f3f			 
0f3f			 
0f3f			 
0f3f			 
0f3f			 
0f3f c3 0b 0e				jp .is1 
0f42			 
0f42 fe 08		.isk3:		cp KEY_BS 
0f44 20 3c				jr nz, .isk4 
0f46			 
0f46 3a 5b ee				ld a, (input_cursor) 
0f49			 
0f49 fe 00				cp 0 
0f4b ca 0b 0e				jp z, .is1 		; at start of line to ignore  
0f4e			 
0f4e 3d					dec  a 		; TODO check underflow 
0f4f 32 5b ee				ld (input_cursor), a 
0f52			 
0f52					; hl is source 
0f52					; de needs to be source - 1 
0f52			 
0f52			;		ld a, 0 
0f52			;		dec hl 
0f52			;		ld (hl), a 
0f52			 
0f52 2a 6f ee				ld hl, (input_ptr) 
0f55 2b					dec hl 
0f56 22 6f ee				ld (input_ptr), hl 
0f59			 
0f59					; shift all data 
0f59			 
0f59 e5					push hl 
0f5a 23					inc hl 
0f5b d1					pop de 
0f5c 3a 60 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0f5f 4f					ld c,a 
0f60 06 00				ld b,0 
0f62 ed b0				ldir  
0f64			 
0f64			 
0f64			 
0f64			 
0f64 3a 68 ee				ld a, (input_at_cursor) 
0f67 3d					dec a 
0f68 32 68 ee				ld (input_at_cursor), a 
0f6b			 
0f6b			 
0f6b 3e 01				ld a, 1		; show cursor moving 
0f6d 32 65 ee				ld (input_cur_onoff),a 
0f70 3e 0f				ld a, CUR_BLINK_RATE 
0f72 32 66 ee				ld (input_cur_flash), a 
0f75			 
0f75					; remove char 
0f75 3a 68 ee				ld a, (input_at_cursor) 
0f78 3c					inc a 
0f79 11 03 10				ld de,.iblank 
0f7c cd 93 0b				call str_at_display 
0f7f			 
0f7f c3 0b 0e				jp .is1 
0f82			 
0f82 fe 0d		.isk4:		cp KEY_CR 
0f84 28 6c				jr z, .endinput 
0f86			 
0f86					; else add the key press to the end 
0f86			 
0f86 4f					ld c, a			; save key pressed 
0f87			 
0f87 7e					ld a,(hl)		; get what is currently under char 
0f88			 
0f88 fe 00				cp 0			; we are at the end of the string 
0f8a 20 2f				jr nz, .onchar 
0f8c					 
0f8c					; add a char to the end of the string 
0f8c				 
0f8c 71					ld (hl),c 
0f8d 23					inc hl 
0f8e			;		ld a,' ' 
0f8e			;		ld (hl),a 
0f8e			;		inc hl 
0f8e 3e 00				ld a,0 
0f90 77					ld (hl),a 
0f91 2b					dec hl 
0f92			 
0f92 3a 5b ee				ld a, (input_cursor) 
0f95 3c					inc a				; TODO check max string length and scroll  
0f96 32 5b ee				ld (input_cursor), a		; inc cursor pos 
0f99							 
0f99 3a 68 ee				ld a, (input_at_cursor) 
0f9c 3c					inc a 
0f9d 32 68 ee				ld (input_at_cursor), a 
0fa0			 
0fa0 2a 6f ee				ld hl, (input_ptr) 
0fa3 23					inc hl 
0fa4 22 6f ee				ld (input_ptr), hl 
0fa7			 
0fa7 2a 6f ee				ld hl, (input_ptr) 
0faa 23					inc hl 
0fab 22 6f ee				ld (input_ptr), hl 
0fae			;	if DEBUG_INPUT 
0fae			;		push af 
0fae			;		ld a, '+' 
0fae			;		ld (debug_mark),a 
0fae			;		pop af 
0fae			;		CALLMONITOR 
0fae			;	endif 
0fae 3e 01				ld a, 1		; show cursor moving 
0fb0 32 65 ee				ld (input_cur_onoff),a 
0fb3 3e 0f				ld a, CUR_BLINK_RATE 
0fb5 32 66 ee				ld (input_cur_flash), a 
0fb8 c3 0b 0e				jp .is1 
0fbb					 
0fbb			 
0fbb			 
0fbb					; if on a char then insert 
0fbb			.onchar: 
0fbb			 
0fbb					; TODO over flow check: make sure insert does not blow out buffer 
0fbb			 
0fbb					; need to do some maths to use lddr 
0fbb			 
0fbb e5					push hl   ; save char pos 
0fbc c5					push bc 
0fbd			 
0fbd 2a 6d ee				ld hl, (input_start) 
0fc0 3a 60 ee				ld a, (input_len) 
0fc3 cd ad 0d				call addatohl  		; end of string 
0fc6 23					inc hl 
0fc7 23					inc hl		; past zero term 
0fc8 e5					push hl 
0fc9 23					inc hl 
0fca e5					push hl  
0fcb			 
0fcb								; start and end of lddr set, now how much to move? 
0fcb			 
0fcb							 
0fcb 3a 5b ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0fce 47					ld b,a 
0fcf 3a 60 ee				ld a,(input_len) 
0fd2 5f					ld e,a 
0fd3 90					sub b 
0fd4 3c					inc a		;?? 
0fd5 3c					inc a		;?? 
0fd6 3c					inc a		;?? 
0fd7			 
0fd7 06 00				ld b,0 
0fd9 4f					ld c,a 
0fda			 
0fda				if DEBUG_INPUT 
0fda					push af 
0fda					ld a, 'i' 
0fda					ld (debug_mark),a 
0fda					pop af 
0fda			;		CALLMONITOR 
0fda				endif 
0fda d1					pop de 
0fdb e1					pop hl 
0fdc				if DEBUG_INPUT 
0fdc					push af 
0fdc					ld a, 'I' 
0fdc					ld (debug_mark),a 
0fdc					pop af 
0fdc			;		CALLMONITOR 
0fdc				endif 
0fdc ed b8				lddr 
0fde				 
0fde			 
0fde			 
0fde					; TODO have a key for insert/overwrite mode???? 
0fde c1					pop bc 
0fdf e1					pop hl 
0fe0 71					ld (hl), c		; otherwise overwrite current char 
0fe1					 
0fe1			 
0fe1			 
0fe1			 
0fe1 3a 5b ee				ld a, (input_cursor) 
0fe4 3c					inc  a 		; TODO check overflow 
0fe5 32 5b ee				ld (input_cursor), a 
0fe8			 
0fe8 3a 68 ee				ld a, (input_at_cursor) 
0feb 3c					inc a 
0fec 32 68 ee				ld (input_at_cursor), a 
0fef			 
0fef c3 0b 0e				jp .is1 
0ff2			 
0ff2			.endinput:	; TODO look for end of string 
0ff2			 
0ff2					; add trailing space for end of token 
0ff2			 
0ff2 2a 6d ee				ld hl, (input_start) 
0ff5 3a 60 ee				ld a,(input_len) 
0ff8 cd ad 0d				call addatohl 
0ffb 3e 20				ld a, ' ' 
0ffd 77					ld (hl),a 
0ffe					; TODO eof of parse marker 
0ffe			 
0ffe 23					inc hl 
0fff 3e 00				ld a, 0 
1001 77					ld (hl),a 
1002			 
1002			 
1002 c9					ret 
1003			 
1003 .. 00		.iblank: db " ",0 
1005			 
1005			 
1005 32 6a ee		input_str_prev:	ld (input_at_pos), a 
1008 22 6d ee				ld (input_start), hl 
100b 3e 01				ld a,1			; add cursor 
100d 77					ld (hl),a 
100e 23					inc hl 
100f 3e 00				ld a,0 
1011 77					ld (hl),a 
1012 22 6f ee				ld (input_ptr), hl 
1015 7a					ld a,d 
1016 32 6c ee				ld (input_size), a 
1019 3e 00				ld a,0 
101b 32 5b ee				ld (input_cursor),a 
101e			.instr1:	 
101e			 
101e					; TODO do block cursor 
101e					; TODO switch cursor depending on the modifer key 
101e			 
101e					; update cursor shape change on key hold 
101e			 
101e 2a 6f ee				ld hl, (input_ptr) 
1021 2b					dec hl 
1022 3a ca eb				ld a,(cursor_shape) 
1025 77					ld (hl), a 
1026			 
1026					; display entered text 
1026 3a 6a ee				ld a,(input_at_pos) 
1029 cd 0f 5e		            	CALL fLCD_Pos       ;Position cursor to location in A 
102c ed 5b 6d ee	            	LD   de, (input_start) 
1030 cd 04 5e		            	CALL fLCD_Str       ;Display string pointed to by DE 
1033			 
1033 cd fa 5e				call cin 
1036 fe 00				cp 0 
1038 28 e4				jr z, .instr1 
103a			 
103a					; proecess keyboard controls first 
103a			 
103a 2a 6f ee				ld hl,(input_ptr) 
103d			 
103d fe 0d				cp KEY_CR	 ; pressing enter ends input 
103f 28 5a				jr z, .instrcr 
1041			 
1041 fe 08				cp KEY_BS 	; back space 
1043 20 0f				jr nz, .instr2 
1045					; process back space 
1045			 
1045					; TODO stop back space if at start of string 
1045 2b					dec hl 
1046 2b					dec hl ; to over write cursor 
1047 3a ca eb				ld a,(cursor_shape) 
104a					;ld a,0 
104a 77					ld (hl),a 
104b 23					inc hl 
104c 3e 20				ld a," " 
104e 77					ld (hl),a 
104f 22 6f ee				ld (input_ptr),hl 
1052					 
1052			 
1052 18 ca				jr .instr1 
1054			 
1054 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1056 20 06				jr nz, .instr3 
1058 2b					dec hl 
1059 22 6f ee				ld (input_ptr),hl 
105c 18 c0				jr .instr1 
105e				 
105e fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
1060 20 06				jr nz, .instr4 
1062 23					inc hl 
1063 22 6f ee				ld (input_ptr),hl 
1066 18 b6				jr .instr1 
1068			 
1068 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
106a 20 06				jr nz, .instr5 
106c 2b					dec hl 
106d 22 6f ee				ld (input_ptr),hl 
1070 18 ac				jr .instr1 
1072			 
1072 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1074 20 06				jr nz, .instr6 
1076 2b					dec hl 
1077 22 6f ee				ld (input_ptr),hl 
107a 18 a2				jr .instr1 
107c fe 05		.instr6:        cp KEY_UP      ; recall last command 
107e 20 0b				jr nz, .instrnew 
1080			 
1080 21 ff e2			ld hl, scratch 
1083 11 25 e7			ld de, os_last_cmd 
1086 cd a4 10			call strcpy 
1089 18 93				jr .instr1 
108b			 
108b			 
108b			.instrnew:	; no special key pressed to see if we have room to store it 
108b			 
108b					; TODO do string size test 
108b			 
108b 2b					dec hl ; to over write cursor 
108c 77					ld (hl),a 
108d 23					inc hl 
108e 3a ca eb				ld a,(cursor_shape) 
1091 77					ld (hl),a 
1092 23					inc hl 
1093 3e 00				ld a,0 
1095 77					ld (hl),a 
1096			 
1096 22 6f ee				ld (input_ptr),hl 
1099					 
1099 18 83				jr .instr1 
109b 2b			.instrcr:	dec hl		; remove cursor 
109c 3e 20				ld a,' '	; TODO add a trailing space for safety 
109e 77					ld (hl),a 
109f 23					inc hl 
10a0 3e 00				ld a,0 
10a2 77					ld (hl),a 
10a3			 
10a3			 
10a3					; if at end of line scroll up    
10a3					; TODO detecting only end of line 4 for scroll up  
10a3			 
10a3					;ld   
10a3			 
10a3 c9					ret 
10a4			 
10a4			 
10a4			; strcpy hl = dest, de source 
10a4			 
10a4 1a			strcpy:   LD   A, (DE)        ;Get character from string 
10a5 b7			            OR   A              ;Null terminator? 
10a6 c8			            RET  Z              ;Yes, so finished 
10a7 1a					ld a,(de) 
10a8 77					ld (hl),a 
10a9 13			            INC  DE             ;Point to next character 
10aa 23					inc hl 
10ab 18 f7		            JR   strcpy       ;Repeat 
10ad c9					ret 
10ae			 
10ae			 
10ae			; TODO string_at  
10ae			; pass string which starts with lcd offset address and then null term string 
10ae			 
10ae			; TODO string to dec 
10ae			; TODO string to hex 
10ae			; TODO byte to string hex 
10ae			; TODO byte to string dec 
10ae			 
10ae			 
10ae			 
10ae			; from z80uartmonitor 
10ae			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10ae			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
10ae			; pass hl for where to put the text 
10ae			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10ae c5			hexout:	PUSH BC 
10af f5					PUSH AF 
10b0 47					LD B, A 
10b1					; Upper nybble 
10b1 cb 3f				SRL A 
10b3 cb 3f				SRL A 
10b5 cb 3f				SRL A 
10b7 cb 3f				SRL A 
10b9 cd c9 10				CALL tohex 
10bc 77					ld (hl),a 
10bd 23					inc hl	 
10be					 
10be					; Lower nybble 
10be 78					LD A, B 
10bf e6 0f				AND 0FH 
10c1 cd c9 10				CALL tohex 
10c4 77					ld (hl),a 
10c5 23					inc hl	 
10c6					 
10c6 f1					POP AF 
10c7 c1					POP BC 
10c8 c9					RET 
10c9					 
10c9			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10c9			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
10c9			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10c9			tohex: 
10c9 e5					PUSH HL 
10ca d5					PUSH DE 
10cb 16 00				LD D, 0 
10cd 5f					LD E, A 
10ce 21 d6 10				LD HL, .DATA 
10d1 19					ADD HL, DE 
10d2 7e					LD A, (HL) 
10d3 d1					POP DE 
10d4 e1					POP HL 
10d5 c9					RET 
10d6			 
10d6			.DATA: 
10d6 30					DEFB	30h	; 0 
10d7 31					DEFB	31h	; 1 
10d8 32					DEFB	32h	; 2 
10d9 33					DEFB	33h	; 3 
10da 34					DEFB	34h	; 4 
10db 35					DEFB	35h	; 5 
10dc 36					DEFB	36h	; 6 
10dd 37					DEFB	37h	; 7 
10de 38					DEFB	38h	; 8 
10df 39					DEFB	39h	; 9 
10e0 41					DEFB	41h	; A 
10e1 42					DEFB	42h	; B 
10e2 43					DEFB	43h	; C 
10e3 44					DEFB	44h	; D 
10e4 45					DEFB	45h	; E 
10e5 46					DEFB	46h	; F 
10e6			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
10e6			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
10e6			;;    subtract $30, if result > 9 then subtract $7 more 
10e6			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
10e6			atohex: 
10e6 d6 30				SUB $30 
10e8 fe 0a				CP 10 
10ea f8					RET M		; If result negative it was 0-9 so we're done 
10eb d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
10ed c9					RET		 
10ee			 
10ee			 
10ee			 
10ee			 
10ee			; Get 2 ASCII characters as hex byte from pointer in hl 
10ee			 
10ee			BYTERD: 
10ee 16 00			LD	D,00h		;Set up 
10f0 cd f8 10			CALL	HEXCON		;Get byte and convert to hex 
10f3 87				ADD	A,A		;First nibble so 
10f4 87				ADD	A,A		;multiply by 16 
10f5 87				ADD	A,A		; 
10f6 87				ADD	A,A		; 
10f7 57				LD	D,A		;Save hi nibble in D 
10f8			HEXCON: 
10f8 7e				ld a, (hl)		;Get next chr 
10f9 23				inc hl 
10fa d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
10fc fe 0a			CP	00Ah		;Is it 0-9 ? 
10fe 38 02			JR	C,NALPHA	;If so miss next bit 
1100 d6 07			SUB	007h		;Else convert alpha 
1102			NALPHA: 
1102 b2				OR	D		;Add hi nibble back 
1103 c9				RET			; 
1104			 
1104			 
1104			; 
1104			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1104			; Since the routines get_byte and therefore get_nibble are called, only valid 
1104			; characters (0-9a-f) are accepted. 
1104			; 
1104			;get_word        push    af 
1104			;                call    get_byte        ; Get the upper byte 
1104			;                ld      h, a 
1104			;                call    get_byte        ; Get the lower byte 
1104			;                ld      l, a 
1104			;                pop     af 
1104			;                ret 
1104			; 
1104			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1104			; the routine get_nibble is used only valid characters are accepted - the  
1104			; input routine only accepts characters 0-9a-f. 
1104			; 
1104 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1105 7e					ld a,(hl) 
1106 23					inc hl 
1107 cd 2c 11		                call    nibble2val      ; Get upper nibble 
110a cb 07		                rlc     a 
110c cb 07		                rlc     a 
110e cb 07		                rlc     a 
1110 cb 07		                rlc     a 
1112 47			                ld      b, a            ; Save upper four bits 
1113 7e					ld a,(hl) 
1114 cd 2c 11		                call    nibble2val      ; Get lower nibble 
1117 b0			                or      b               ; Combine both nibbles 
1118 c1			                pop     bc              ; Restore B (and C) 
1119 c9			                ret 
111a			; 
111a			; Get a hexadecimal digit from the serial line. This routine blocks until 
111a			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
111a			; to the serial line interface. The lower 4 bits of A contain the value of  
111a			; that particular digit. 
111a			; 
111a			;get_nibble      ld a,(hl)           ; Read a character 
111a			;                call    to_upper        ; Convert to upper case 
111a			;                call    is_hex          ; Was it a hex digit? 
111a			;                jr      nc, get_nibble  ; No, get another character 
111a			 ;               call    nibble2val      ; Convert nibble to value 
111a			 ;               call    print_nibble 
111a			 ;               ret 
111a			; 
111a			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
111a			; A valid hexadecimal digit is denoted by a set C flag. 
111a			; 
111a			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
111a			;                ret     nc              ; Yes 
111a			;                cp      '0'             ; Less than '0'? 
111a			;                jr      nc, is_hex_1    ; No, continue 
111a			;                ccf                     ; Complement carry (i.e. clear it) 
111a			;                ret 
111a			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
111a			;                ret     c               ; Yes 
111a			;                cp      'A'             ; Less than 'A'? 
111a			;                jr      nc, is_hex_2    ; No, continue 
111a			;                ccf                     ; Yes - clear carry and return 
111a			;                ret 
111a			;is_hex_2        scf                     ; Set carry 
111a			;                ret 
111a			; 
111a			; Convert a single character contained in A to upper case: 
111a			; 
111a fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
111c d8			                ret     c 
111d fe 7b		                cp      'z' + 1         ; > 'z'? 
111f d0			                ret     nc              ; Nothing to do, either 
1120 e6 5f		                and     $5f             ; Convert to upper case 
1122 c9			                ret 
1123			 
1123			 
1123			to_lower: 
1123			 
1123			   ; if char is in [A-Z] make it lower case 
1123			 
1123			   ; enter : a = char 
1123			   ; exit  : a = lower case char 
1123			   ; uses  : af 
1123			 
1123 fe 41		   cp 'A' 
1125 d8			   ret c 
1126			    
1126 fe 5b		   cp 'Z'+1 
1128 d0			   ret nc 
1129			    
1129 f6 20		   or $20 
112b c9			   ret 
112c			 
112c			; 
112c			; Expects a hexadecimal digit (upper case!) in A and returns the 
112c			; corresponding value in A. 
112c			; 
112c fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
112e 38 02		                jr      c, nibble2val_1 ; Yes 
1130 d6 07		                sub     7               ; Adjust for A-F 
1132 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1134 e6 0f		                and     $f              ; Only return lower 4 bits 
1136 c9			                ret 
1137			; 
1137			; Print_nibble prints a single hex nibble which is contained in the lower  
1137			; four bits of A: 
1137			; 
1137			;print_nibble    push    af              ; We won't destroy the contents of A 
1137			;                and     $f              ; Just in case... 
1137			;                add     a, '0'             ; If we have a digit we are done here. 
1137			;                cp      '9' + 1         ; Is the result > 9? 
1137			;                jr      c, print_nibble_1 
1137			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1137			;print_nibble_1  call    putc            ; Print the nibble and 
1137			;                pop     af              ; restore the original value of A 
1137			;                ret 
1137			;; 
1137			;; Send a CR/LF pair: 
1137			; 
1137			;crlf            push    af 
1137			;                ld      a, cr 
1137			;                call    putc 
1137			;                ld      a, lf 
1137			;                call    putc 
1137			;                pop     af 
1137			;                ret 
1137			; 
1137			; Print_word prints the four hex digits of a word to the serial line. The  
1137			; word is expected to be in HL. 
1137			; 
1137			;print_word      push    hl 
1137			;                push    af 
1137			;                ld      a, h 
1137			;                call    print_byte 
1137			;                ld      a, l 
1137			;                call    print_byte 
1137			;                pop     af 
1137			;                pop     hl 
1137			;                ret 
1137			; 
1137			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1137			; The byte to be printed is expected to be in A. 
1137			; 
1137			;print_byte      push    af              ; Save the contents of the registers 
1137			;                push    bc 
1137			;                ld      b, a 
1137			;                rrca 
1137			;                rrca 
1137			;                rrca 
1137			;                rrca 
1137			;                call    print_nibble    ; Print high nibble 
1137			;                ld      a, b 
1137			;                call    print_nibble    ; Print low nibble 
1137			;                pop     bc              ; Restore original register contents 
1137			;                pop     af 
1137			;                ret 
1137			 
1137			 
1137			 
1137			 
1137			 
1137			fourehexhl:  
1137 7e				ld a,(hl) 
1138 cd e6 10			call atohex 
113b cb 3f				SRL A 
113d cb 3f				SRL A 
113f cb 3f				SRL A 
1141 cb 3f				SRL A 
1143 47				ld b, a 
1144 23				inc hl 
1145 7e				ld a,(hl) 
1146 23				inc hl 
1147 cd e6 10			call atohex 
114a 80				add b 
114b 57				ld d,a 
114c 7e				ld a,(hl) 
114d cd e6 10			call atohex 
1150 cb 3f				SRL A 
1152 cb 3f				SRL A 
1154 cb 3f				SRL A 
1156 cb 3f				SRL A 
1158 47				ld b, a 
1159 23				inc hl 
115a 7e				ld a,(hl) 
115b 23				inc hl 
115c cd e6 10			call atohex 
115f 80				add b 
1160 5f				ld e, a 
1161 d5				push de 
1162 e1				pop hl 
1163 c9				ret 
1164			 
1164			; pass hl. returns z set if the byte at hl is a digit 
1164			;isdigithl:  
1164			;	push bc 
1164			;	ld a,(hl) 
1164			;	cp ':' 
1164			;	jr nc, .isdf 		; > 
1164			;	cp '0' 
1164			;	jr c, .isdf		; < 
1164			; 
1164			;	; TODO find a better way to set z 
1164			; 
1164			;	ld b,a 
1164			;	cp b 
1164			;	pop bc 
1164			;	ret 
1164			; 
1164			;.isdf:	; not digit so clear z 
1164			; 
1164			;	; TODO find a better way to unset z 
1164			; 
1164			;	ld b,a 
1164			;	inc b 
1164			;	cp b 
1164			; 
1164			;	pop bc 
1164			;	ret 
1164				 
1164				 
1164			 
1164			 
1164			; pass hl as the four byte address to load 
1164			 
1164			get_word_hl:  
1164 e5				push hl 
1165 cd 04 11			call get_byte 
1168				 
1168 47				ld b, a 
1169			 
1169 e1				pop hl 
116a 23				inc hl 
116b 23				inc hl 
116c			 
116c			; TODO not able to handle a-f  
116c 7e				ld a,(hl) 
116d			;	;cp ':' 
116d			;	cp 'g' 
116d			;	jr nc, .single_byte_hl 		; > 
116d			;	cp 'G' 
116d			;	jr nc, .single_byte_hl 		; > 
116d			;	cp '0' 
116d			;	jr c, .single_byte_hl		; < 
116d			 
116d				;call isdigithl 
116d fe 00			cp 0 
116f 28 06			jr z, .single_byte_hl 
1171			 
1171			.getwhln:   ; hex word so get next byte 
1171			 
1171 cd 04 11			call get_byte 
1174 6f				ld l, a 
1175 60				ld h,b 
1176 c9				ret 
1177 68			.single_byte_hl:   ld l,b 
1178 26 00				ld h,0 
117a c9					ret 
117b			 
117b			 
117b			 
117b			 
117b 21 36 19			ld hl,asc+1 
117e			;	ld a, (hl) 
117e			;	call nibble2val 
117e cd 04 11			call get_byte 
1181			 
1181			;	call fourehexhl 
1181 32 33 e3			ld (scratch+52),a 
1184				 
1184 21 31 e3			ld hl,scratch+50 
1187 22 22 e6			ld (os_cur_ptr),hl 
118a			 
118a c9				ret 
118b			 
118b			 
118b			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
118b			 
118b			; Decimal Unsigned Version 
118b			 
118b			;Number in a to decimal ASCII 
118b			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
118b			;Example: display a=56 as "056" 
118b			;input: a = number 
118b			;Output: a=0,value of a in the screen 
118b			;destroys af,bc (don't know about hl and de) 
118b			DispAToASCII: 
118b 0e 9c			ld	c,-100 
118d cd 97 11			call	.Na1 
1190 0e f6			ld	c,-10 
1192 cd 97 11			call	.Na1 
1195 0e ff			ld	c,-1 
1197 06 2f		.Na1:	ld	b,'0'-1 
1199 04			.Na2:	inc	b 
119a 81				add	a,c 
119b 38 fc			jr	c,.Na2 
119d 91				sub	c		;works as add 100/10/1 
119e f5				push af		;safer than ld c,a 
119f 78				ld	a,b		;char is in b 
11a0			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
11a0 f1				pop af		;safer than ld a,c 
11a1 c9				ret 
11a2			 
11a2			; Decimal Signed Version 
11a2			 
11a2			; DispA 
11a2			; -------------------------------------------------------------- 
11a2			; Converts a signed integer value to a zero-terminated ASCII 
11a2			; string representative of that value (using radix 10). 
11a2			; -------------------------------------------------------------- 
11a2			; INPUTS: 
11a2			;     HL     Value to convert (two's complement integer). 
11a2			;     DE     Base address of string destination. (pointer). 
11a2			; -------------------------------------------------------------- 
11a2			; OUTPUTS: 
11a2			;     None 
11a2			; -------------------------------------------------------------- 
11a2			; REGISTERS/MEMORY DESTROYED 
11a2			; AF HL 
11a2			; -------------------------------------------------------------- 
11a2			 
11a2			;DispHLToASCII: 
11a2			;   push    de 
11a2			;   push    bc 
11a2			; 
11a2			;; Detect sign of HL. 
11a2			;    bit    7, h 
11a2			;    jr     z, ._DoConvert 
11a2			; 
11a2			;; HL is negative. Output '-' to string and negate HL. 
11a2			;    ld     a, '-' 
11a2			;    ld     (de), a 
11a2			;    inc    de 
11a2			; 
11a2			;; Negate HL (using two's complement) 
11a2			;    xor    a 
11a2			;    sub    l 
11a2			;    ld     l, a 
11a2			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
11a2			;    sbc    a, h 
11a2			;    ld     h, a 
11a2			; 
11a2			;; Convert HL to digit characters 
11a2			;._DoConvert: 
11a2			;    ld     b, 0     ; B will count character length of number 
11a2			;-   ld     a, 10 
11a2			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
11a2			;    push   af 
11a2			;    inc    b 
11a2			;    ld     a, h 
11a2			;    or     l 
11a2			;    jr     nz, - 
11a2			; 
11a2			;; Retrieve digits from stack 
11a2			;-   pop    af 
11a2			;    or     $30 
11a2			;    ld     (de), a 
11a2			;    inc    de 
11a2			;    djnz   - 
11a2			; 
11a2			;; Terminate string with NULL 
11a2			;    xor    a 
11a2			;    ld     (de), a 
11a2			; 
11a2			;    pop    bc 
11a2			;    pop    de 
11a2			;    ret 
11a2			 
11a2			;Comments 
11a2			; 
11a2			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
11a2			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
11a2			;    Note that the output string will not be fixed-width. 
11a2			; 
11a2			;Example Usage 
11a2			; 
11a2			;    ld    hl, -1004 
11a2			;    ld    de, OP1 
11a2			;    call  DispA 
11a2			;    ld    hl, OP1 
11a2			;    syscall  PutS 
11a2			 
11a2			 
11a2			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11a2			 
11a2			 
11a2			;Converts an ASCII string to an unsigned 16-bit integer 
11a2			;Quits when it reaches a non-decimal digit 
11a2			 
11a2			string_to_uint16: 
11a2			atoui_16: 
11a2			;Input: 
11a2			;     DE points to the string 
11a2			;Outputs: 
11a2			;     HL is the result 
11a2			;     A is the 8-bit value of the number 
11a2			;     DE points to the byte after the number 
11a2			;Destroys: 
11a2			;     BC 
11a2			;       if the string is non-empty, BC is HL/10 
11a2			;Size:  24 bytes 
11a2			;Speed: 42+d(104+{0,9}) 
11a2			;       d is the number of digits in the number 
11a2			;       max is 640 cycles for a 5 digit number 
11a2			;Assuming no leading zeros: 
11a2			;1 digit:  146cc 
11a2			;2 digit:  250cc 
11a2			;3 digit:  354cc or 363cc (avg: 354.126cc) 
11a2			;4 digit:  458cc or 467cc (avg: 458.27cc) 
11a2			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
11a2			;avg: 544.81158447265625cc (544+13297/16384) 
11a2			;=============================================================== 
11a2 21 00 00		  ld hl,0 
11a5			.u16a: 
11a5 1a			  ld a,(de) 
11a6 d6 30		  sub 30h 
11a8 fe 0a		  cp 10 
11aa d0			  ret nc 
11ab 13			  inc de 
11ac 44			  ld b,h 
11ad 4d			  ld c,l 
11ae 29			  add hl,hl 
11af 29			  add hl,hl 
11b0 09			  add hl,bc 
11b1 29			  add hl,hl 
11b2 85			  add a,l 
11b3 6f			  ld l,a 
11b4 30 ef		  jr nc,.u16a 
11b6 24			  inc h 
11b7 c3 a5 11		  jp .u16a 
11ba			 
11ba			 
11ba			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11ba			 
11ba			;written by Zeda 
11ba			;Converts a 16-bit unsigned integer to an ASCII string. 
11ba			 
11ba			uitoa_16: 
11ba			;Input: 
11ba			;   DE is the number to convert 
11ba			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
11ba			;Output: 
11ba			;   HL points to the null-terminated ASCII string 
11ba			;      NOTE: This isn't necessarily the same as the input HL. 
11ba d5			  push de 
11bb c5			  push bc 
11bc f5			  push af 
11bd eb			  ex de,hl 
11be			 
11be 01 f0 d8		  ld bc,-10000 
11c1 3e 2f		  ld a,'0'-1 
11c3 3c			  inc a 
11c4 09			  add hl,bc  
11c5 38 fc		   jr c,$-2 
11c7 12			  ld (de),a 
11c8 13			  inc de 
11c9			 
11c9 01 e8 03		  ld bc,1000 
11cc 3e 3a		  ld a,'9'+1 
11ce 3d			  dec a  
11cf 09			  add hl,bc  
11d0 30 fc		   jr nc,$-2 
11d2 12			  ld (de),a 
11d3 13			  inc de 
11d4			 
11d4 01 9c ff		  ld bc,-100 
11d7 3e 2f		  ld a,'0'-1 
11d9 3c			  inc a  
11da 09			  add hl,bc  
11db 38 fc		   jr c,$-2 
11dd 12			  ld (de),a 
11de 13			  inc de 
11df			 
11df 7d			  ld a,l 
11e0 26 3a		  ld h,'9'+1 
11e2 25			  dec h  
11e3 c6 0a		  add a,10  
11e5 30 fb		   jr nc,$-3 
11e7 c6 30		  add a,'0' 
11e9 eb			  ex de,hl 
11ea 72			  ld (hl),d 
11eb 23			  inc hl 
11ec 77			  ld (hl),a 
11ed 23			  inc hl 
11ee 36 00		  ld (hl),0 
11f0			 
11f0			;Now strip the leading zeros 
11f0 0e fa		  ld c,-6 
11f2 09			  add hl,bc 
11f3 3e 30		  ld a,'0' 
11f5 23			  inc hl  
11f6 be			  cp (hl)  
11f7 28 fc		  jr z,$-2 
11f9			 
11f9			;Make sure that the string is non-empty! 
11f9 7e			  ld a,(hl) 
11fa b7			  or a 
11fb 20 01		  jr nz,.atoub 
11fd 2b			  dec hl 
11fe			.atoub: 
11fe			 
11fe f1			  pop af 
11ff c1			  pop bc 
1200 d1			  pop de 
1201 c9			  ret 
1202			 
1202			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1202			 
1202			toUpper: 
1202			;A is the char. 
1202			;If A is a lowercase letter, this sets it to the matching uppercase 
1202			;18cc or 30cc or 41cc 
1202			;avg: 26.75cc 
1202 fe 61		  cp 'a' 
1204 d8			  ret c 
1205 fe 7b		  cp 'z'+1 
1207 d0			  ret nc 
1208 d6 20		  sub 'a'-'A' 
120a c9			  ret 
120b			 
120b			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
120b			 
120b			; String Length 
120b			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
120b			 
120b			; Get the length of the null-terminated string starting at $8000 hl 
120b			;    LD     HL, $8000 
120b			 
120b			strlenz: 
120b			 
120b af			    XOR    A               ; Zero is the value we are looking for. 
120c 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
120d 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
120e			                           ; 65, 536 bytes (the entire addressable memory space). 
120e ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1210			 
1210			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1210 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1211 6f			    LD     L, A             ; number of bytes 
1212 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1214 2b			    DEC    HL              ; Compensate for null. 
1215 c9				ret 
1216			 
1216			; Get the length of the A terminated string starting at $8000 hl 
1216			;    LD     HL, $8000 
1216			 
1216			strlent: 
1216			 
1216			                  ; A is the value we are looking for. 
1216 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1218 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
121a			                           ; 65, 536 bytes (the entire addressable memory space). 
121a ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
121c			 
121c			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
121c 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
121e 2e 00		    LD     L, 0             ; number of bytes 
1220 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1222 2b			    DEC    HL              ; Compensate for null. 
1223 c9				ret 
1224			 
1224			 
1224			;Comparing Strings 
1224			 
1224			;IN    HL     Address of string1. 
1224			;      DE     Address of string2. 
1224			 
1224			; doc given but wrong??? 
1224			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1224			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1224			; tested 
1224			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1224			 
1224			strcmp_old: 
1224 e5			    PUSH   HL 
1225 d5			    PUSH   DE 
1226			 
1226 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1227 be			    CP     (HL)            ; (want to minimize work). 
1228 38 01		    JR     C, Str1IsBigger 
122a 7e			    LD     A, (HL) 
122b			 
122b			Str1IsBigger: 
122b 4f			    LD     C, A             ; Put length in BC 
122c 06 00		    LD     B, 0 
122e 13			    INC    DE              ; Increment pointers to meat of string. 
122f 23			    INC    HL 
1230			 
1230			CmpLoop: 
1230 1a			    LD     A, (DE)          ; Compare bytes. 
1231 ed a1		    CPI 
1233 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1235 13			    INC    DE              ; Update pointer. 
1236 ea 30 12		    JP     PE, CmpLoop 
1239			 
1239 d1			    POP    DE 
123a e1			    POP    HL 
123b 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
123c be			    CP     (HL) 
123d c9			    RET 
123e			 
123e			NoMatch: 
123e 2b			    DEC    HL 
123f be			    CP     (HL)            ; Compare again to affect carry. 
1240 d1			    POP    DE 
1241 e1			    POP    HL 
1242 c9			    RET 
1243			 
1243			;; test strmp 
1243			; 
1243			;ld de, .str1 
1243			;ld hl, .str2 
1243			;call strcmp 
1243			;jr z, .z1 
1243			;;this 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "NZ1" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			;.z1: 
1243			; 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "ZZ1" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			; 
1243			;ld de, .str1 
1243			;ld hl, .str1 
1243			;call strcmp 
1243			;jr z, .z2 
1243			;;this 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "NZ2" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			;.z2: 
1243			; 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "ZZ2" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			; 
1243			;ld de, .str1 
1243			;ld hl, .str2 
1243			;call strcmp 
1243			;jr c, .c1 
1243			; 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "Nc1" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			;.c1: 
1243			;;this 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "cc1" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			; 
1243			;ld de, .str1 
1243			;ld hl, .str1 
1243			;call strcmp 
1243			;jr c, .c2 
1243			;;this 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "Nc2" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			;.c2: 
1243			; 
1243			;	if DEBUG_FORTH_WORDS 
1243			;		DMARK "cc2" 
1243			;		CALLMONITOR 
1243			;	endif 
1243			;	NEXTW 
1243			;.str1:   db "string1",0 
1243			;.str2:   db "string2",0 
1243			 
1243			; only care about direct match or not 
1243			; hl and de strings 
1243			; zero set if the same 
1243			 
1243			strcmp: 
1243 1a				ld a, (de) 
1244 be				cp (hl) 
1245 28 02			jr z, .ssame 
1247 b7				or a 
1248 c9				ret 
1249			 
1249			.ssame:  
1249 fe 00			cp 0 
124b c8				ret z 
124c			 
124c 23				inc hl 
124d 13				inc de 
124e 18 f3			jr strcmp 
1250				 
1250				 
1250			 
1250			 
1250			 
1250			 
1250			; eof 
1250			 
1250			 
1250			 
1250			 
1250			 
1250			 
# End of file firmware_strings.asm
1250			include "firmware_memory.asm"   ; malloc and free  
1250			 
1250			if DEBUG_FORTH_MALLOC_HIGH 
1250			.mallocsize: db "Wants malloc >256",0 
1250			.mallocasize: db "MALLOC gives >256",0 
1250			.malloczero: db "MALLOC gives zero",0 
1250			 
1250			malloc_guard_zerolen: 
1250				push hl 
1250				push de 
1250				push af 
1250			 
1250				ld de, 0 
1250			        call cmp16 
1250				jr nz, .lowalloz 
1250			 
1250				push hl 
1250				push de 
1250					ld hl, display_fb0 
1250					ld (display_fb_active), hl 
1250				call clear_display 
1250				ld a, 0 
1250				ld de, .malloczero 
1250				call str_at_display 
1250				call update_display 
1250				call delay1s 
1250				call delay1s 
1250				ld a, 0 
1250				ld (os_view_disable), a 
1250			 
1250				pop de 
1250				pop hl 
1250			 
1250				 
1250			 
1250				CALLMONITOR 
1250			.lowalloz: 
1250			 
1250			 
1250				pop af 
1250				pop de 
1250				pop hl 
1250			ret 
1250			 
1250			malloc_guard_entry: 
1250				push hl 
1250				push de 
1250				push af 
1250			 
1250			 	or a      ;clear carry flag 
1250				push hl 
1250				ld de, 255 
1250				sbc hl, de 
1250				jr c, .lowalloc 
1250			 
1250				push de 
1250					ld hl, display_fb0 
1250					ld (display_fb_active), hl 
1250				call clear_display 
1250				ld a, 0 
1250				ld de, .mallocsize 
1250				call str_at_display 
1250				call update_display 
1250				call delay1s 
1250				call delay1s 
1250				ld a, 0 
1250				ld (os_view_disable), a 
1250			 
1250				pop de 
1250				pop hl 
1250			 
1250				 
1250			 
1250				CALLMONITOR 
1250				jr .lowdone 
1250			.lowalloc: 
1250			 
1250			 
1250				pop hl 
1250			.lowdone:	pop af 
1250				pop de 
1250				pop hl 
1250			ret 
1250			 
1250			malloc_guard_exit: 
1250				push hl 
1250				push de 
1250				push af 
1250			 
1250			 	or a      ;clear carry flag 
1250				push hl 
1250				ld de, 255 
1250				sbc hl, de 
1250				jr c, .lowallocx 
1250			 
1250				push de 
1250					ld hl, display_fb0 
1250					ld (display_fb_active), hl 
1250				call clear_display 
1250				ld a, 0 
1250				ld de, .mallocasize 
1250				call str_at_display 
1250				call update_display 
1250				call delay1s 
1250				call delay1s 
1250				ld a, 0 
1250				ld (os_view_disable), a 
1250				pop de 
1250				pop hl 
1250			 
1250				CALLMONITOR 
1250				jr .lowdonex 
1250			.lowallocx: 
1250			 
1250				pop hl 
1250			.lowdonex:	pop af 
1250				pop de 
1250				pop hl 
1250			ret 
1250			endif 
1250			 
1250			if MALLOC_2 
1250			; Z80 Malloc and Free Functions 
1250			 
1250			; Malloc Function: 
1250			; Input: 
1250			;   HL: Size of block to allocate 
1250			; Output: 
1250			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1250			 
1250			malloc: 
1250				 
1250			if DEBUG_FORTH_MALLOC_HIGH 
1250			call malloc_guard_entry 
1250			endif 
1250			 
1250			 
1250			 
1250			 
1250					if DEBUG_FORTH_MALLOC 
1250						DMARK "mal" 
1250						CALLMONITOR 
1250					endif 
1250			    push af            ; Save AF register 
1250			    ld a, l            ; Load low byte of size into A 
1250			    or h               ; Check if size is zero 
1250			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1250			 
1250			    ; Allocate memory 
1250			    ld hl, (heap_start) ; Load start of heap into HL 
1250					if DEBUG_FORTH_MALLOC 
1250						DMARK "ma1" 
1250						CALLMONITOR 
1250					endif 
1250			    call malloc_internal ; Call internal malloc function 
1250			    pop af             ; Restore AF register 
1250			if DEBUG_FORTH_MALLOC_HIGH 
1250			call malloc_guard_exit 
1250			call malloc_guard_zerolen 
1250			endif 
1250			    ret                ; Return 
1250			 
1250			; Free Function: 
1250			; Input: 
1250			;   HL: Pointer to memory block to free 
1250			; Output: 
1250			;   None 
1250			 
1250			free: 
1250			    push af            ; Save AF register 
1250			    ld a, l            ; Load low byte of pointer into A 
1250			    or h               ; Check if pointer is NULL 
1250			    jp z, free_exit    ; If pointer is NULL, exit 
1250			 
1250			    ; Free memory 
1250			    ld hl, (heap_start) ; Load start of heap into HL 
1250			    call free_internal  ; Call internal free function 
1250			    pop af             ; Restore AF register 
1250			    ret                ; Return 
1250			 
1250			; Internal Malloc Function: 
1250			; Input: 
1250			;   HL: Size of block to allocate 
1250			; Output: 
1250			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1250			 
1250			malloc_internal: 
1250			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1250			    add hl, bc         ; Add management overhead to requested size 
1250			    ex de, hl          ; Save total size in DE, and keep it in HL 
1250					if DEBUG_FORTH_MALLOC 
1250						DMARK "ma2" 
1250						CALLMONITOR 
1250					endif 
1250			 
1250			    ; Search for free memory block 
1250			    ld de, (heap_end)  ; Load end of heap into DE 
1250			    ld bc, 0           ; Initialize counter 
1250			 
1250					if DEBUG_FORTH_MALLOC 
1250						DMARK "ma2" 
1250						CALLMONITOR 
1250					endif 
1250			malloc_search_loop: 
1250			    ; Check if current block is free 
1250			    ld a, (hl)         ; Load current block's status (free or used) 
1250			    cp 0               ; Compare with zero (free) 
1250			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1250			 
1250			    ; Check if current block is large enough 
1250			    ld a, (hl+1)       ; Load high byte of block size 
1250			    cp l               ; Compare with low byte of requested size 
1250			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1250			 
1250			    ld a, (hl+2)       ; Load low byte of block size 
1250			    cp h               ; Compare with high byte of requested size 
1250			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1250			 
1250			    ; Mark block as used 
1250			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1250			 
1250			    ; Calculate remaining space in block 
1250			    ld bc, 0           ; Clear BC 
1250			    add hl, bc         ; Increment HL to point to start of data block 
1250			    add hl, de         ; HL = HL + DE (total size) 
1250			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1250			    add hl, bc         ; Add management overhead to start of data block 
1250			 
1250			    ; Save pointer to allocated block in HL 
1250			if DEBUG_FORTH_MALLOC_HIGH 
1250						DMARK "ma5" 
1250			call malloc_guard_exit 
1250			call malloc_guard_zerolen 
1250			endif 
1250			    ret 
1250			 
1250			malloc_skip_block_check: 
1250			    ; Move to the next block 
1250			    ld bc, 3           ; Size of management overhead 
1250			    add hl, bc         ; Move to the next block 
1250			    inc de             ; Increment counter 
1250			 
1250			    ; Check if we have reached the end of heap 
1250			    ld a, e            ; Load low byte of heap end address 
1250			    cp (hl)            ; Compare with low byte of current address 
1250			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1250			    ld a, d            ; Load high byte of heap end address 
1250			    cp 0               ; Check if it's zero (end of memory) 
1250			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1250			 
1250			    ; If we reached here, allocation failed 
1250			    xor a              ; Set result to NULL 
1250			if DEBUG_FORTH_MALLOC_HIGH 
1250						DMARK "ma6" 
1250			call malloc_guard_exit 
1250			call malloc_guard_zerolen 
1250			endif 
1250			    ret 
1250			malloc_exit: 
1250			if DEBUG_FORTH_MALLOC_HIGH 
1250						DMARK "ma7" 
1250			call malloc_guard_exit 
1250			call malloc_guard_zerolen 
1250			endif 
1250			    ret 
1250			 
1250			; Internal Free Function: 
1250			; Input: 
1250			;   HL: Pointer to memory block to free 
1250			; Output: 
1250			;   None 
1250			 
1250			free_internal: 
1250			    ld de, (heap_start) ; Load start of heap into DE 
1250			    ld bc, 0            ; Initialize counter 
1250			 
1250			free_search_loop: 
1250			    ; Check if current block contains the pointer 
1250			    ld a, l             ; Load low byte of pointer 
1250			    cp (hl+1)           ; Compare with high byte of current block's address 
1250			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1250			    ld a, h             ; Load high byte of pointer 
1250			    cp (hl+2)           ; Compare with low byte of current block's address 
1250			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1250			 
1250			    ; Mark block as free 
1250			    ld (hl), 0          ; Set status byte to indicate free block 
1250			    ret                 ; Return 
1250			 
1250			free_skip_block_check: 
1250			    ; Move to the next block 
1250			    ld bc, 3            ; Size of management overhead 
1250			    add hl, bc          ; Move to the next block 
1250			    inc de              ; Increment counter 
1250			 
1250			    ; Check if we have reached the end of heap 
1250			    ld a, e             ; Load low byte of heap end address 
1250			    cp (hl)             ; Compare with low byte of current address 
1250			    jr nz, free_search_loop  ; If not equal, continue searching 
1250			    ld a, d             ; Load high byte of heap end address 
1250			    cp 0                ; Check if it's zero (end of memory) 
1250			    jr nz, free_search_loop  ; If not zero, continue searching 
1250			 
1250			    ; If we reached here, pointer is not found in heap 
1250			    ret 
1250			 
1250			free_exit: 
1250			    ret                 ; Return 
1250			 
1250			; Define heap start and end addresses 
1250			;heap_start:    .dw 0xC000   ; Start of heap 
1250			;heap_end:      .dw 0xE000   ; End of heap 
1250			 
1250			endif 
1250			 
1250			 
1250			if MALLOC_1 
1250			 
1250			 
1250			 
1250			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1250			 
1250			;moved to firmware.asm 
1250			;heap_start        .equ  0x9000      ; Starting address of heap 
1250			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1250			 
1250			;      .org 0 
1250			;      jp    main 
1250			 
1250			 
1250			;      .org  0x100 
1250			;main: 
1250			;      ld    HL, 0x8100 
1250			;      ld    SP, HL 
1250			; 
1250			;      call  heap_init 
1250			; 
1250			;      ; Make some allocations 
1250			;      ld    HL, 12 
1250			;      call  malloc            ; Allocates 0x9004 
1250			; 
1250			;      ld    HL, 12 
1250			;      call  malloc            ; Allocates 0x9014 
1250			; 
1250			;      ld    HL, 12 
1250			;      call  malloc            ; Allocates 0x9024 
1250			; 
1250			;      ; Free some allocations 
1250			;      ld    HL, 0x9014 
1250			;      call  free 
1250			; 
1250			;      ld    HL, 0x9004 
1250			;      call  free 
1250			; 
1250			;      ld    HL, 0x9024 
1250			;      call  free 
1250			; 
1250			; 
1250			;      halt 
1250			 
1250			 
1250			;------------------------------------------------------------------------------ 
1250			;     heap_init                                                               : 
1250			;                                                                             : 
1250			; Description                                                                 : 
1250			;     Initialise the heap and make it ready for malloc and free operations.   : 
1250			;                                                                             : 
1250			;     The heap is maintained as a linked list, starting with an initial       : 
1250			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1250			;     the first free block in the heap. Each block then points to the next    : 
1250			;     free block within the heap, and the free list ends at the first block   : 
1250			;     with a null pointer to the next free block.                             : 
1250			;                                                                             : 
1250			; Parameters                                                                  : 
1250			;     Inputs are compile-time only. Two defines which specify the starting    : 
1250			;     address of the heap and its size are required, along with a memory      : 
1250			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1250			;     principally stores a pointer to the first free block in the heap.       : 
1250			;                                                                             : 
1250			; Returns                                                                     : 
1250			;     Nothing                                                                 : 
1250			;------------------------------------------------------------------------------ 
1250			heap_init: 
1250 e5			      push  HL 
1251			 
1251			      ; Initialise free list struct 
1251 21 22 5f		      ld    HL, heap_start 
1254 22 1d 5f		      ld    (free_list), HL 
1257 21 00 00		      ld    HL, 0 
125a 22 1f 5f		      ld    (free_list+2), HL 
125d			 
125d			      ; Insert first free block at bottom of heap, consumes entire heap 
125d 21 e1 e2		      ld    HL, heap_start+heap_size-4 
1260 22 22 5f		      ld    (heap_start), HL        ; Next block (end of free list) 
1263 21 bf 83		      ld    HL, heap_size-4 
1266 22 24 5f		      ld    (heap_start+2), HL      ; Block size 
1269			 
1269			      ; Insert end of free list block at top of heap - two null words will 
1269			      ; terminate the free list 
1269 21 00 00		      ld    HL, 0 
126c 22 e3 e2		      ld    (heap_start+heap_size-2), HL 
126f 22 e1 e2		      ld    (heap_start+heap_size-4), HL 
1272			 
1272 e1			      pop   HL 
1273			 
1273 c9			      ret 
1274			 
1274			 
1274			;------------------------------------------------------------------------------ 
1274			;     malloc                                                                  : 
1274			;                                                                             : 
1274			; Description                                                                 : 
1274			;     Allocates the wanted space from the heap and returns the address of the : 
1274			;     first useable byte of the allocation.                                   : 
1274			;                                                                             : 
1274			;     Allocations can happen in one of two ways:                              : 
1274			;                                                                             : 
1274			;     1. A free block may be found which is the exact size wanted. In this    : 
1274			;        case the block is removed from the free list and retuedn to the      : 
1274			;        caller.                                                              : 
1274			;     2. A free block may be found which is larger than the size wanted. In   : 
1274			;        this case, the larger block is split into two. The first portion of  : 
1274			;        this block will become the requested space by the malloc call and    : 
1274			;        is returned to the caller. The second portion becomes a new free     : 
1274			;        block, and the free list is adjusted to maintain continuity via this : 
1274			;        newly created block.                                                 : 
1274			;                                                                             : 
1274			;     malloc does not set any initial value in the allocated space, the       : 
1274			;     caller is required to do this as required.                              : 
1274			;                                                                             : 
1274			;     This implementation of malloc uses the stack exclusively, and is        : 
1274			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1274			;     advisable to disable interrupts before calling malloc, and recommended  : 
1274			;     to avoid the use of malloc inside ISRs in general.                      : 
1274			;                                                                             : 
1274			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1274			;                                                                             : 
1274			; Parameters                                                                  : 
1274			;     HL  Number of bytes wanted                                              : 
1274			;                                                                             : 
1274			; Returns                                                                     : 
1274			;     HL  Address of the first useable byte of the allocation                 : 
1274			;                                                                             : 
1274			; Flags                                                                       : 
1274			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1274			;                                                                             : 
1274			; Stack frame                                                                 : 
1274			;       |             |                                                       : 
1274			;       +-------------+                                                       : 
1274			;       |     BC      |                                                       : 
1274			;       +-------------+                                                       : 
1274			;       |     DE      |                                                       : 
1274			;       +-------------+                                                       : 
1274			;       |     IX      |                                                       : 
1274			;       +-------------+                                                       : 
1274			;       |  prev_free  |                                                       : 
1274			;   +4  +-------------+                                                       : 
1274			;       |  this_free  |                                                       : 
1274			;   +2  +-------------+                                                       : 
1274			;       |  next_free  |                                                       : 
1274			;   +0  +-------------+                                                       : 
1274			;       |             |                                                       : 
1274			;                                                                             : 
1274			;------------------------------------------------------------------------------ 
1274			 
1274			 
1274			;malloc: 
1274			; 
1274			;	SAVESP ON 1 
1274			; 
1274			;	call malloc_code 
1274			; 
1274			;	CHECKSP ON 1 
1274			;	ret 
1274			 
1274			 
1274			malloc: 
1274 c5			      push  BC 
1275 d5			      push  DE 
1276 dd e5		      push  IX 
1278			if DEBUG_FORTH_MALLOC_HIGH 
1278			call malloc_guard_entry 
1278			endif 
1278			 
1278					if DEBUG_FORTH_MALLOC 
1278						DMARK "mal" 
1278						CALLMONITOR 
1278					endif 
1278 7c			      ld    A, H                    ; Exit if no space requested 
1279 b5			      or    L 
127a ca 39 13		      jp    Z, malloc_early_exit 
127d			 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			; 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			;inc hl 
127d			 
127d			 
127d			 
127d			 
127d					if DEBUG_FORTH_MALLOC 
127d						DMARK "maA" 
127d						CALLMONITOR 
127d					endif 
127d			      ; Set up stack frame 
127d eb			      ex    DE, HL 
127e 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1281 39			      add   HL, SP 
1282 f9			      ld    SP, HL 
1283 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1287 dd 39		      add   IX, SP 
1289			 
1289			      ; Setup initial state 
1289 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
128c 19			      add   HL, DE 
128d			 
128d 44			      ld    B, H                    ; Move want to BC 
128e 4d			      ld    C, L 
128f			 
128f 21 1d 5f		      ld    HL, free_list           ; Store prev_free ptr to stack 
1292 dd 75 04		      ld    (IX+4), L 
1295 dd 74 05		      ld    (IX+5), H 
1298			 
1298 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1299 23			      inc   HL 
129a 56			      ld    D, (HL) 
129b dd 73 02		      ld    (IX+2), E 
129e dd 72 03		      ld    (IX+3), D 
12a1 eb			      ex    DE, HL                  ; this_free ptr into HL 
12a2			 
12a2					if DEBUG_FORTH_MALLOC 
12a2						DMARK "maB" 
12a2						CALLMONITOR 
12a2					endif 
12a2			      ; Loop through free block list to find some space 
12a2			malloc_find_space: 
12a2 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
12a3 23			      inc   HL 
12a4 56			      ld    D, (HL) 
12a5			 
12a5 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
12a6 b3			      or    E 
12a7 ca 33 13		      jp    Z, malloc_no_space 
12aa			 
12aa dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
12ad dd 72 01		      ld    (IX+1), D 
12b0			 
12b0			      ; Does this block have enough space to make the allocation? 
12b0 23			      inc   HL                      ; Load free block size into DE 
12b1 5e			      ld    E, (HL) 
12b2 23			      inc   HL 
12b3 56			      ld    D, (HL) 
12b4			 
12b4 eb			      ex    DE, HL                  ; Check size of block against want 
12b5 b7			      or    A                       ; Ensure carry flag clear 
12b6 ed 42		      sbc   HL, BC 
12b8 e5			      push  HL                      ; Store the result for later (new block size) 
12b9			 
12b9 ca 08 13		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
12bc 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
12be			 
12be			      ; this_free block is not big enough, setup ptrs to test next free block 
12be e1			      pop   HL                      ; Discard previous result 
12bf			 
12bf dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
12c2 dd 66 03		      ld    H, (IX+3) 
12c5 dd 75 04		      ld    (IX+4), L 
12c8 dd 74 05		      ld    (IX+5), H 
12cb			 
12cb dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
12ce dd 66 01		      ld    H, (IX+1) 
12d1 dd 75 02		      ld    (IX+2), L 
12d4 dd 74 03		      ld    (IX+3), H 
12d7			 
12d7					if DEBUG_FORTH_MALLOC 
12d7						DMARK "MA>" 
12d7						CALLMONITOR 
12d7					endif 
12d7 18 c9		      jr    malloc_find_space 
12d9			 
12d9			      ; split a bigger block into two - requested size and remaining size 
12d9			malloc_alloc_split: 
12d9					if DEBUG_FORTH_MALLOC 
12d9						DMARK "MAs" 
12d9						CALLMONITOR 
12d9					endif 
12d9 eb			      ex    DE, HL                  ; Calculate address of new free block 
12da 2b			      dec   HL 
12db 2b			      dec   HL 
12dc 2b			      dec   HL 
12dd 09			      add   HL, BC 
12de			 
12de			      ; Create a new block and point it at next_free 
12de dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
12e1 dd 56 01		      ld    D, (IX+1) 
12e4			 
12e4 73			      ld    (HL), E                 ; Store next_free ptr into new block 
12e5 23			      inc   HL 
12e6 72			      ld    (HL), D 
12e7			 
12e7 d1			      pop   DE                      ; Store size of new block into new block 
12e8 23			      inc   HL 
12e9 73			      ld    (HL), E 
12ea 23			      inc   HL 
12eb 72			      ld    (HL), D 
12ec			 
12ec			      ; Update this_free ptr to point to new block 
12ec 2b			      dec   HL 
12ed 2b			      dec   HL 
12ee 2b			      dec   HL 
12ef			 
12ef dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
12f2 dd 56 03		      ld    D, (IX+3) 
12f5			 
12f5 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
12f8 dd 74 03		      ld    (IX+3), H 
12fb			 
12fb			      ; Modify this_free block to be allocation 
12fb eb			      ex    DE, HL 
12fc af			      xor   A                       ; Null the next block ptr of allocated block 
12fd 77			      ld    (HL), A 
12fe 23			      inc   HL 
12ff 77			      ld    (HL), A 
1300			 
1300 23			      inc   HL                      ; Store want size into allocated block 
1301 71			      ld    (HL), C 
1302 23			      inc   HL 
1303 70			      ld    (HL), B 
1304 23			      inc   HL 
1305 e5			      push  HL                      ; Address of allocation to return 
1306			 
1306 18 19		      jr    malloc_update_links 
1308			 
1308			malloc_alloc_fit: 
1308 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1309			 
1309					if DEBUG_FORTH_MALLOC 
1309						DMARK "MAf" 
1309						CALLMONITOR 
1309					endif 
1309			      ; Modify this_free block to be allocation 
1309 eb			      ex    DE, HL 
130a 2b			      dec   HL 
130b 2b			      dec   HL 
130c 2b			      dec   HL 
130d			 
130d af			      xor   A                       ; Null the next block ptr of allocated block 
130e 77			      ld    (HL), A 
130f 23			      inc   HL 
1310 77			      ld    (HL), A 
1311			 
1311 23			      inc   HL                      ; Store address of allocation to return 
1312 23			      inc   HL 
1313 23			      inc   HL 
1314 e5			      push  HL 
1315			 
1315			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1315 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1318 dd 66 01		      ld    H, (IX+1) 
131b			 
131b dd 75 02		      ld    (IX+2), L               ; HL to this_free 
131e dd 74 03		      ld    (IX+3), H 
1321			 
1321			 
1321			malloc_update_links: 
1321			      ; Update prev_free ptr to point to this_free 
1321 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1324 dd 66 05		      ld    H, (IX+5) 
1327			 
1327 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
132a dd 56 03		      ld    D, (IX+3) 
132d			 
132d 73			      ld    (HL), E                 ; this_free ptr into prev_free 
132e 23			      inc   HL 
132f 72			      ld    (HL), D 
1330			 
1330					if DEBUG_FORTH_MALLOC 
1330						DMARK "Mul" 
1330						CALLMONITOR 
1330					endif 
1330			      ; Clear the Z flag to indicate successful allocation 
1330 7a			      ld    A, D 
1331 b3			      or    E 
1332			 
1332 d1			      pop   DE                      ; Address of allocation 
1333					if DEBUG_FORTH_MALLOC 
1333						DMARK "MAu" 
1333						CALLMONITOR 
1333					endif 
1333			 
1333			malloc_no_space: 
1333 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1336 39			      add   HL, SP 
1337 f9			      ld    SP, HL 
1338			 
1338 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1339					if DEBUG_FORTH_MALLOC 
1339						DMARK "MAN" 
1339						CALLMONITOR 
1339					endif 
1339			 
1339			malloc_early_exit: 
1339					if DEBUG_FORTH_MALLOC 
1339						DMARK "MAx" 
1339						CALLMONITOR 
1339					endif 
1339 dd e1		      pop   IX 
133b d1			      pop   DE 
133c c1			      pop   BC 
133d			 
133d			if DEBUG_FORTH_MALLOC_HIGH 
133d			call malloc_guard_exit 
133d			call malloc_guard_zerolen 
133d			endif 
133d c9			      ret 
133e			 
133e			 
133e			;------------------------------------------------------------------------------ 
133e			;     free                                                                    : 
133e			;                                                                             : 
133e			; Description                                                                 : 
133e			;     Return the space pointed to by HL to the heap. HL must be an address as : 
133e			;     returned by malloc, otherwise the behaviour is undefined.               : 
133e			;                                                                             : 
133e			;     Where possible, directly adjacent free blocks will be merged together   : 
133e			;     into larger blocks to help ensure that the heap does not become         : 
133e			;     excessively fragmented.                                                 : 
133e			;                                                                             : 
133e			;     free does not clear or set any other value into the freed space, and    : 
133e			;     therefore its contents may be visible through subsequent malloc's. The  : 
133e			;     caller should clear the freed space as required.                        : 
133e			;                                                                             : 
133e			;     This implementation of free uses the stack exclusively, and is          : 
133e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
133e			;     advisable to disable interrupts before calling free, and recommended    : 
133e			;     to avoid the use of free inside ISRs in general.                        : 
133e			;                                                                             : 
133e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
133e			;                                                                             : 
133e			; Parameters                                                                  : 
133e			;     HL  Pointer to address of first byte of allocation to be freed          : 
133e			;                                                                             : 
133e			; Returns                                                                     : 
133e			;     Nothing                                                                 : 
133e			;                                                                             : 
133e			; Stack frame                                                                 : 
133e			;       |             |                                                       : 
133e			;       +-------------+                                                       : 
133e			;       |     BC      |                                                       : 
133e			;       +-------------+                                                       : 
133e			;       |     DE      |                                                       : 
133e			;       +-------------+                                                       : 
133e			;       |     IX      |                                                       : 
133e			;       +-------------+                                                       : 
133e			;       |  prev_free  |                                                       : 
133e			;   +2  +-------------+                                                       : 
133e			;       |  next_free  |                                                       : 
133e			;   +0  +-------------+                                                       : 
133e			;       |             |                                                       : 
133e			;                                                                             : 
133e			;------------------------------------------------------------------------------ 
133e			free: 
133e c5			      push  BC 
133f d5			      push  DE 
1340 dd e5		      push  IX 
1342			 
1342 7c			      ld    A, H                    ; Exit if ptr is null 
1343 b5			      or    L 
1344 ca 08 14		      jp    Z, free_early_exit 
1347			 
1347			      ; Set up stack frame 
1347 eb			      ex    DE, HL 
1348 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
134b 39			      add   HL, SP 
134c f9			      ld    SP, HL 
134d dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1351 dd 39		      add   IX, SP 
1353			 
1353			      ; The address in HL points to the start of the useable allocated space, 
1353			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1353			      ; address of the block itself. 
1353 eb			      ex    DE, HL 
1354 11 fc ff		      ld    DE, -4 
1357 19			      add   HL, DE 
1358			 
1358			      ; An allocated block must have a null next block pointer in it 
1358 7e			      ld    A, (HL) 
1359 23			      inc   HL 
135a b6			      or    (HL) 
135b c2 03 14		      jp    NZ, free_done 
135e			 
135e 2b			      dec   HL 
135f			 
135f 44			      ld    B, H                    ; Copy HL to BC 
1360 4d			      ld    C, L 
1361			 
1361			      ; Loop through the free list to find the first block with an address 
1361			      ; higher than the block being freed 
1361 21 1d 5f		      ld    HL, free_list 
1364			 
1364			free_find_higher_block: 
1364 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1365 23			      inc   HL 
1366 56			      ld    D, (HL) 
1367 2b			      dec   HL 
1368			 
1368 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
136b dd 72 01		      ld    (IX+1), D 
136e dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1371 dd 74 03		      ld    (IX+3), H 
1374			 
1374 78			      ld    A, B                    ; Check if DE is greater than BC 
1375 ba			      cp    D                       ; Compare MSB first 
1376 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1378 30 04		      jr    NC, free_find_higher_block_skip 
137a 79			      ld    A, C 
137b bb			      cp    E                       ; Then compare LSB 
137c 38 08		      jr    C, free_found_higher_block 
137e			 
137e			free_find_higher_block_skip: 
137e 7a			      ld    A, D                    ; Reached the end of the free list? 
137f b3			      or    E 
1380 ca 03 14		      jp    Z, free_done 
1383			 
1383 eb			      ex    DE, HL 
1384			 
1384 18 de		      jr    free_find_higher_block 
1386			 
1386			free_found_higher_block: 
1386			      ; Insert freed block between prev and next free blocks 
1386 71			      ld    (HL), C                 ; Point prev free block to freed block 
1387 23			      inc   HL 
1388 70			      ld    (HL), B 
1389			 
1389 60			      ld    H, B                    ; Point freed block at next free block 
138a 69			      ld    L, C 
138b 73			      ld    (HL), E 
138c 23			      inc   HL 
138d 72			      ld    (HL), D 
138e			 
138e			      ; Check if the freed block is adjacent to the next free block 
138e 23			      inc   HL                      ; Load size of freed block into HL 
138f 5e			      ld    E, (HL) 
1390 23			      inc   HL 
1391 56			      ld    D, (HL) 
1392 eb			      ex    DE, HL 
1393			 
1393 09			      add   HL, BC                  ; Add addr of freed block and its size 
1394			 
1394 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1397 dd 56 01		      ld    D, (IX+1) 
139a			 
139a b7			      or    A                       ; Clear the carry flag 
139b ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
139d 20 22		      jr    NZ, free_check_adjacent_to_prev 
139f			 
139f			      ; Freed block is adjacent to next, merge into one bigger block 
139f eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
13a0 5e			      ld    E, (HL) 
13a1 23			      inc   HL 
13a2 56			      ld    D, (HL) 
13a3 e5			      push  HL                      ; Save ptr to next block for later 
13a4			 
13a4 60			      ld    H, B                    ; Store ptr from next block into freed block 
13a5 69			      ld    L, C 
13a6 73			      ld    (HL), E 
13a7 23			      inc   HL 
13a8 72			      ld    (HL), D 
13a9			 
13a9 e1			      pop   HL                      ; Restore ptr to next block 
13aa 23			      inc   HL                      ; Load size of next block into DE 
13ab 5e			      ld    E, (HL) 
13ac 23			      inc   HL 
13ad 56			      ld    D, (HL) 
13ae d5			      push  DE                      ; Save next block size for later 
13af			 
13af 60			      ld    H, B                    ; Load size of freed block into HL 
13b0 69			      ld    L, C 
13b1 23			      inc   HL 
13b2 23			      inc   HL 
13b3 5e			      ld    E, (HL) 
13b4 23			      inc   HL 
13b5 56			      ld    D, (HL) 
13b6 eb			      ex    DE, HL 
13b7			 
13b7 d1			      pop   DE                      ; Restore size of next block 
13b8 19			      add   HL, DE                  ; Add sizes of both blocks 
13b9 eb			      ex    DE, HL 
13ba			 
13ba 60			      ld    H, B                    ; Store new bigger size into freed block 
13bb 69			      ld    L, C 
13bc 23			      inc   HL 
13bd 23			      inc   HL 
13be 73			      ld    (HL), E 
13bf 23			      inc   HL 
13c0 72			      ld    (HL), D 
13c1			 
13c1			free_check_adjacent_to_prev: 
13c1			      ; Check if the freed block is adjacent to the prev free block 
13c1 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
13c4 dd 66 03		      ld    H, (IX+3) 
13c7			 
13c7 23			      inc   HL                      ; Size of prev free block into DE 
13c8 23			      inc   HL 
13c9 5e			      ld    E, (HL) 
13ca 23			      inc   HL 
13cb 56			      ld    D, (HL) 
13cc 2b			      dec   HL 
13cd 2b			      dec   HL 
13ce 2b			      dec   HL 
13cf			 
13cf 19			      add   HL, DE                  ; Add prev block addr and size 
13d0			 
13d0 b7			      or    A                       ; Clear the carry flag 
13d1 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
13d3 20 2e		      jr    NZ, free_done 
13d5			 
13d5			      ; Freed block is adjacent to prev, merge into one bigger block 
13d5 60			      ld    H, B                    ; Load next ptr from freed block into DE 
13d6 69			      ld    L, C 
13d7 5e			      ld    E, (HL) 
13d8 23			      inc   HL 
13d9 56			      ld    D, (HL) 
13da e5			      push  HL                      ; Save freed block ptr for later 
13db			 
13db dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
13de dd 66 03		      ld    H, (IX+3) 
13e1 73			      ld    (HL), E 
13e2 23			      inc   HL 
13e3 72			      ld    (HL), D 
13e4			 
13e4 e1			      pop   HL                      ; Restore freed block ptr 
13e5 23			      inc   HL                      ; Load size of freed block into DE 
13e6 5e			      ld    E, (HL) 
13e7 23			      inc   HL 
13e8 56			      ld    D, (HL) 
13e9 d5			      push  DE                      ; Save freed block size for later 
13ea			 
13ea dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
13ed dd 66 03		      ld    H, (IX+3) 
13f0 23			      inc   HL 
13f1 23			      inc   HL 
13f2 5e			      ld    E, (HL) 
13f3 23			      inc   HL 
13f4 56			      ld    D, (HL) 
13f5			 
13f5 e1			      pop   HL                      ; Add sizes of both blocks 
13f6 19			      add   HL, DE 
13f7 eb			      ex    DE, HL 
13f8			 
13f8 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
13fb dd 66 03		      ld    H, (IX+3) 
13fe 23			      inc   HL 
13ff 23			      inc   HL 
1400 73			      ld    (HL), E 
1401 23			      inc   HL 
1402 72			      ld    (HL), D 
1403			 
1403			free_done: 
1403 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1406 39			      add   HL, SP 
1407 f9			      ld    SP, HL 
1408			 
1408			free_early_exit: 
1408 dd e1		      pop   IX 
140a d1			      pop   DE 
140b c1			      pop   BC 
140c			 
140c c9			      ret 
140d			 
140d			; moved to firmware.asm 
140d			; 
140d			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
140d			;                  .dw   0 
140d			 
140d			 
140d			endif 
140d			 
140d			 
140d			if MALLOC_3 
140d			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
140d			;heap_start        .equ  0x9000      ; Starting address of heap 
140d			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
140d			; 
140d			 ;     .org 0 
140d			  ;    jp    main 
140d			; 
140d			; 
140d			 ;     .org  0x100 
140d			;main: 
140d			 ;     ld    HL, 0x8100 
140d			  ;    ld    SP, HL 
140d			; 
140d			;      call  heap_init 
140d			 
140d			      ; Make some allocations 
140d			;      ld    HL, 12 
140d			;      call  malloc            ; Allocates 0x9004 
140d			; 
140d			 ;     ld    HL, 12 
140d			;      call  malloc            ; Allocates 0x9014 
140d			 
140d			;      ld    HL, 12 
140d			;      call  malloc            ; Allocates 0x9024 
140d			 
140d			      ; Free some allocations 
140d			;      ld    HL, 0x9014 
140d			;      call  free 
140d			 
140d			;      ld    HL, 0x9004 
140d			;      call  free 
140d			; 
140d			;      ld    HL, 0x9024 
140d			;      call  free 
140d			 
140d			 
140d			 ;     halt 
140d			 
140d			 
140d			;------------------------------------------------------------------------------ 
140d			;     heap_init                                                               : 
140d			;                                                                             : 
140d			; Description                                                                 : 
140d			;     Initialise the heap and make it ready for malloc and free operations.   : 
140d			;                                                                             : 
140d			;     The heap is maintained as a linked list, starting with an initial       : 
140d			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
140d			;     the first free block in the heap. Each block then points to the next    : 
140d			;     free block within the heap, and the free list ends at the first block   : 
140d			;     with a null pointer to the next free block.                             : 
140d			;                                                                             : 
140d			; Parameters                                                                  : 
140d			;     Inputs are compile-time only. Two defines which specify the starting    : 
140d			;     address of the heap and its size are required, along with a memory      : 
140d			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
140d			;     principally stores a pointer to the first free block in the heap.       : 
140d			;                                                                             : 
140d			; Returns                                                                     : 
140d			;     Nothing                                                                 : 
140d			;------------------------------------------------------------------------------ 
140d			heap_init: 
140d			      push  HL 
140d			 
140d			      ; Initialise free list struct 
140d			      ld    HL, heap_start 
140d			      ld    (free_list), HL 
140d			      ld    HL, 0 
140d			      ld    (free_list+2), HL 
140d			 
140d			      ; Insert first free block at bottom of heap, consumes entire heap 
140d			      ld    HL, heap_start+heap_size-4 
140d			      ld    (heap_start), HL        ; Next block (end of free list) 
140d			      ld    HL, heap_size-4 
140d			      ld    (heap_start+2), HL      ; Block size 
140d			 
140d			      ; Insert end of free list block at top of heap - two null words will 
140d			      ; terminate the free list 
140d			      ld    HL, 0 
140d			      ld    (heap_start+heap_size-2), HL 
140d			      ld    (heap_start+heap_size-4), HL 
140d			 
140d			      pop   HL 
140d			 
140d			      ret 
140d			 
140d			 
140d			;------------------------------------------------------------------------------ 
140d			;     malloc                                                                  : 
140d			;                                                                             : 
140d			; Description                                                                 : 
140d			;     Allocates the wanted space from the heap and returns the address of the : 
140d			;     first useable byte of the allocation.                                   : 
140d			;                                                                             : 
140d			;     Allocations can happen in one of two ways:                              : 
140d			;                                                                             : 
140d			;     1. A free block may be found which is the exact size wanted. In this    : 
140d			;        case the block is removed from the free list and retuedn to the      : 
140d			;        caller.                                                              : 
140d			;     2. A free block may be found which is larger than the size wanted. In   : 
140d			;        this case, the larger block is split into two. The first portion of  : 
140d			;        this block will become the requested space by the malloc call and    : 
140d			;        is returned to the caller. The second portion becomes a new free     : 
140d			;        block, and the free list is adjusted to maintain continuity via this : 
140d			;        newly created block.                                                 : 
140d			;                                                                             : 
140d			;     malloc does not set any initial value in the allocated space, the       : 
140d			;     caller is required to do this as required.                              : 
140d			;                                                                             : 
140d			;     This implementation of malloc uses the stack exclusively, and is        : 
140d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
140d			;     advisable to disable interrupts before calling malloc, and recommended  : 
140d			;     to avoid the use of malloc inside ISRs in general.                      : 
140d			;                                                                             : 
140d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
140d			;                                                                             : 
140d			; Parameters                                                                  : 
140d			;     HL  Number of bytes wanted                                              : 
140d			;                                                                             : 
140d			; Returns                                                                     : 
140d			;     HL  Address of the first useable byte of the allocation                 : 
140d			;                                                                             : 
140d			; Flags                                                                       : 
140d			;     Z   Set if the allocation did not succeed, clear otherwise              : 
140d			;                                                                             : 
140d			; Stack frame                                                                 : 
140d			;       |             |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |     BC      |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |     DE      |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |     IX      |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |  prev_free  |                                                       : 
140d			;   +4  +-------------+                                                       : 
140d			;       |  this_free  |                                                       : 
140d			;   +2  +-------------+                                                       : 
140d			;       |  next_free  |                                                       : 
140d			;   +0  +-------------+                                                       : 
140d			;       |             |                                                       : 
140d			;                                                                             : 
140d			;------------------------------------------------------------------------------ 
140d			malloc: 
140d			      push  BC 
140d			      push  DE 
140d			      push  IX 
140d			 
140d			      ld    A, H                    ; Exit if no space requested 
140d			      or    L 
140d			      jp    Z, malloc_early_exit 
140d			 
140d			      ; Set up stack frame 
140d			      ex    DE, HL 
140d			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
140d			      add   HL, SP 
140d			      ld    SP, HL 
140d			      ld    IX, 0                   ; Use IX as a frame pointer 
140d			      add   IX, SP 
140d			 
140d			      ; Setup initial state 
140d			      ld    HL, 4                   ; want must also include space used by block struct 
140d			      add   HL, DE 
140d			 
140d			      ld    B, H                    ; Move want to BC 
140d			      ld    C, L 
140d			 
140d			      ld    HL, free_list           ; Store prev_free ptr to stack 
140d			      ld    (IX+4), L 
140d			      ld    (IX+5), H 
140d			 
140d			      ld    E, (HL)                 ; Store this_free ptr to stack 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      ld    (IX+2), E 
140d			      ld    (IX+3), D 
140d			      ex    DE, HL                  ; this_free ptr into HL 
140d			 
140d			      ; Loop through free block list to find some space 
140d			malloc_find_space: 
140d			      ld    E, (HL)                 ; Load next_free ptr into DE 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			 
140d			      ld    A, D                    ; Check for null next_free ptr - end of free list 
140d			      or    E 
140d			      jp    Z, malloc_no_space 
140d			 
140d			      ld    (IX+0), E               ; Store next_free ptr to stack 
140d			      ld    (IX+1), D 
140d			 
140d			      ; Does this block have enough space to make the allocation? 
140d			      inc   HL                      ; Load free block size into DE 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			 
140d			      ex    DE, HL                  ; Check size of block against want 
140d			      or    A                       ; Ensure carry flag clear 
140d			      sbc   HL, BC 
140d			      push  HL                      ; Store the result for later (new block size) 
140d			 
140d			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
140d			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
140d			 
140d			      ; this_free block is not big enough, setup ptrs to test next free block 
140d			      pop   HL                      ; Discard previous result 
140d			 
140d			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
140d			      ld    H, (IX+3) 
140d			      ld    (IX+4), L 
140d			      ld    (IX+5), H 
140d			 
140d			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
140d			      ld    H, (IX+1) 
140d			      ld    (IX+2), L 
140d			      ld    (IX+3), H 
140d			 
140d			      jr    malloc_find_space 
140d			 
140d			      ; split a bigger block into two - requested size and remaining size 
140d			malloc_alloc_split: 
140d			      ex    DE, HL                  ; Calculate address of new free block 
140d			      dec   HL 
140d			      dec   HL 
140d			      dec   HL 
140d			      add   HL, BC 
140d			 
140d			      ; Create a new block and point it at next_free 
140d			      ld    E, (IX+0)               ; Load next_free ptr into DE 
140d			      ld    D, (IX+1) 
140d			 
140d			      ld    (HL), E                 ; Store next_free ptr into new block 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			      pop   DE                      ; Store size of new block into new block 
140d			      inc   HL 
140d			      ld    (HL), E 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			      ; Update this_free ptr to point to new block 
140d			      dec   HL 
140d			      dec   HL 
140d			      dec   HL 
140d			 
140d			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
140d			      ld    D, (IX+3) 
140d			 
140d			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
140d			      ld    (IX+3), H 
140d			 
140d			      ; Modify this_free block to be allocation 
140d			      ex    DE, HL 
140d			      xor   A                       ; Null the next block ptr of allocated block 
140d			      ld    (HL), A 
140d			      inc   HL 
140d			      ld    (HL), A 
140d			 
140d			      inc   HL                      ; Store want size into allocated block 
140d			      ld    (HL), C 
140d			      inc   HL 
140d			      ld    (HL), B 
140d			      inc   HL 
140d			      push  HL                      ; Address of allocation to return 
140d			 
140d			      jr    malloc_update_links 
140d			 
140d			malloc_alloc_fit: 
140d			      pop   HL                      ; Dont need new block size, want is exact fit 
140d			 
140d			      ; Modify this_free block to be allocation 
140d			      ex    DE, HL 
140d			      dec   HL 
140d			      dec   HL 
140d			      dec   HL 
140d			 
140d			      xor   A                       ; Null the next block ptr of allocated block 
140d			      ld    (HL), A 
140d			      inc   HL 
140d			      ld    (HL), A 
140d			 
140d			      inc   HL                      ; Store address of allocation to return 
140d			      inc   HL 
140d			      inc   HL 
140d			      push  HL 
140d			 
140d			      ; Copy next_free ptr to this_free, remove allocated block from free list 
140d			      ld    L, (IX+0)               ; next_free to HL 
140d			      ld    H, (IX+1) 
140d			 
140d			      ld    (IX+2), L               ; HL to this_free 
140d			      ld    (IX+3), H 
140d			 
140d			 
140d			malloc_update_links: 
140d			      ; Update prev_free ptr to point to this_free 
140d			      ld    L, (IX+4)               ; prev_free ptr to HL 
140d			      ld    H, (IX+5) 
140d			 
140d			      ld    E, (IX+2)               ; this_free ptr to DE 
140d			      ld    D, (IX+3) 
140d			 
140d			      ld    (HL), E                 ; this_free ptr into prev_free 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			      ; Clear the Z flag to indicate successful allocation 
140d			      ld    A, D 
140d			      or    E 
140d			 
140d			      pop   DE                      ; Address of allocation 
140d			 
140d			malloc_no_space: 
140d			      ld    HL, 6                   ; Clean up stack frame 
140d			      add   HL, SP 
140d			      ld    SP, HL 
140d			 
140d			      ex    DE, HL                  ; Alloc addr into HL for return 
140d			 
140d			malloc_early_exit: 
140d			      pop   IX 
140d			      pop   DE 
140d			      pop   BC 
140d			 
140d			      ret 
140d			 
140d			 
140d			;------------------------------------------------------------------------------ 
140d			;     free                                                                    : 
140d			;                                                                             : 
140d			; Description                                                                 : 
140d			;     Return the space pointed to by HL to the heap. HL must be an address as : 
140d			;     returned by malloc, otherwise the behaviour is undefined.               : 
140d			;                                                                             : 
140d			;     Where possible, directly adjacent free blocks will be merged together   : 
140d			;     into larger blocks to help ensure that the heap does not become         : 
140d			;     excessively fragmented.                                                 : 
140d			;                                                                             : 
140d			;     free does not clear or set any other value into the freed space, and    : 
140d			;     therefore its contents may be visible through subsequent malloc's. The  : 
140d			;     caller should clear the freed space as required.                        : 
140d			;                                                                             : 
140d			;     This implementation of free uses the stack exclusively, and is          : 
140d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
140d			;     advisable to disable interrupts before calling free, and recommended    : 
140d			;     to avoid the use of free inside ISRs in general.                        : 
140d			;                                                                             : 
140d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
140d			;                                                                             : 
140d			; Parameters                                                                  : 
140d			;     HL  Pointer to address of first byte of allocation to be freed          : 
140d			;                                                                             : 
140d			; Returns                                                                     : 
140d			;     Nothing                                                                 : 
140d			;                                                                             : 
140d			; Stack frame                                                                 : 
140d			;       |             |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |     BC      |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |     DE      |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |     IX      |                                                       : 
140d			;       +-------------+                                                       : 
140d			;       |  prev_free  |                                                       : 
140d			;   +2  +-------------+                                                       : 
140d			;       |  next_free  |                                                       : 
140d			;   +0  +-------------+                                                       : 
140d			;       |             |                                                       : 
140d			;                                                                             : 
140d			;------------------------------------------------------------------------------ 
140d			free: 
140d			      push  BC 
140d			      push  DE 
140d			      push  IX 
140d			 
140d			      ld    A, H                    ; Exit if ptr is null 
140d			      or    L 
140d			      jp    Z, free_early_exit 
140d			 
140d			      ; Set up stack frame 
140d			      ex    DE, HL 
140d			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
140d			      add   HL, SP 
140d			      ld    SP, HL 
140d			      ld    IX, 0                   ; Use IX as a frame pointer 
140d			      add   IX, SP 
140d			 
140d			      ; The address in HL points to the start of the useable allocated space, 
140d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
140d			      ; address of the block itself. 
140d			      ex    DE, HL 
140d			      ld    DE, -4 
140d			      add   HL, DE 
140d			 
140d			      ; An allocated block must have a null next block pointer in it 
140d			      ld    A, (HL) 
140d			      inc   HL 
140d			      or    (HL) 
140d			      jp    NZ, free_done 
140d			 
140d			      dec   HL 
140d			 
140d			      ld    B, H                    ; Copy HL to BC 
140d			      ld    C, L 
140d			 
140d			      ; Loop through the free list to find the first block with an address 
140d			      ; higher than the block being freed 
140d			      ld    HL, free_list 
140d			 
140d			free_find_higher_block: 
140d			      ld    E, (HL)                 ; Load next ptr from free block 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      dec   HL 
140d			 
140d			      ld    (IX+0), E               ; Save ptr to next free block 
140d			      ld    (IX+1), D 
140d			      ld    (IX+2), L               ; Save ptr to prev free block 
140d			      ld    (IX+3), H 
140d			 
140d			      ld    A, B                    ; Check if DE is greater than BC 
140d			      cp    D                       ; Compare MSB first 
140d			      jr    Z, $+4                  ; MSB the same, compare LSB 
140d			      jr    NC, free_find_higher_block_skip 
140d			      ld    A, C 
140d			      cp    E                       ; Then compare LSB 
140d			      jr    C, free_found_higher_block 
140d			 
140d			free_find_higher_block_skip: 
140d			      ld    A, D                    ; Reached the end of the free list? 
140d			      or    E 
140d			      jp    Z, free_done 
140d			 
140d			      ex    DE, HL 
140d			 
140d			      jr    free_find_higher_block 
140d			 
140d			free_found_higher_block: 
140d			      ; Insert freed block between prev and next free blocks 
140d			      ld    (HL), C                 ; Point prev free block to freed block 
140d			      inc   HL 
140d			      ld    (HL), B 
140d			 
140d			      ld    H, B                    ; Point freed block at next free block 
140d			      ld    L, C 
140d			      ld    (HL), E 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			      ; Check if the freed block is adjacent to the next free block 
140d			      inc   HL                      ; Load size of freed block into HL 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      ex    DE, HL 
140d			 
140d			      add   HL, BC                  ; Add addr of freed block and its size 
140d			 
140d			      ld    E, (IX+0)               ; Load addr of next free block into DE 
140d			      ld    D, (IX+1) 
140d			 
140d			      or    A                       ; Clear the carry flag 
140d			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
140d			      jr    NZ, free_check_adjacent_to_prev 
140d			 
140d			      ; Freed block is adjacent to next, merge into one bigger block 
140d			      ex    DE, HL                  ; Load next ptr from next block into DE 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      push  HL                      ; Save ptr to next block for later 
140d			 
140d			      ld    H, B                    ; Store ptr from next block into freed block 
140d			      ld    L, C 
140d			      ld    (HL), E 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			      pop   HL                      ; Restore ptr to next block 
140d			      inc   HL                      ; Load size of next block into DE 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      push  DE                      ; Save next block size for later 
140d			 
140d			      ld    H, B                    ; Load size of freed block into HL 
140d			      ld    L, C 
140d			      inc   HL 
140d			      inc   HL 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      ex    DE, HL 
140d			 
140d			      pop   DE                      ; Restore size of next block 
140d			      add   HL, DE                  ; Add sizes of both blocks 
140d			      ex    DE, HL 
140d			 
140d			      ld    H, B                    ; Store new bigger size into freed block 
140d			      ld    L, C 
140d			      inc   HL 
140d			      inc   HL 
140d			      ld    (HL), E 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			free_check_adjacent_to_prev: 
140d			      ; Check if the freed block is adjacent to the prev free block 
140d			      ld    L, (IX+2)               ; Prev free block ptr into HL 
140d			      ld    H, (IX+3) 
140d			 
140d			      inc   HL                      ; Size of prev free block into DE 
140d			      inc   HL 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      dec   HL 
140d			      dec   HL 
140d			      dec   HL 
140d			 
140d			      add   HL, DE                  ; Add prev block addr and size 
140d			 
140d			      or    A                       ; Clear the carry flag 
140d			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
140d			      jr    NZ, free_done 
140d			 
140d			      ; Freed block is adjacent to prev, merge into one bigger block 
140d			      ld    H, B                    ; Load next ptr from freed block into DE 
140d			      ld    L, C 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      push  HL                      ; Save freed block ptr for later 
140d			 
140d			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
140d			      ld    H, (IX+3) 
140d			      ld    (HL), E 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			      pop   HL                      ; Restore freed block ptr 
140d			      inc   HL                      ; Load size of freed block into DE 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			      push  DE                      ; Save freed block size for later 
140d			 
140d			      ld    L, (IX+2)               ; Load size of prev block into DE 
140d			      ld    H, (IX+3) 
140d			      inc   HL 
140d			      inc   HL 
140d			      ld    E, (HL) 
140d			      inc   HL 
140d			      ld    D, (HL) 
140d			 
140d			      pop   HL                      ; Add sizes of both blocks 
140d			      add   HL, DE 
140d			      ex    DE, HL 
140d			 
140d			      ld    L, (IX+2)               ; Store new bigger size into prev block 
140d			      ld    H, (IX+3) 
140d			      inc   HL 
140d			      inc   HL 
140d			      ld    (HL), E 
140d			      inc   HL 
140d			      ld    (HL), D 
140d			 
140d			free_done: 
140d			      ld    HL, 4                   ; Clean up stack frame 
140d			      add   HL, SP 
140d			      ld    SP, HL 
140d			 
140d			free_early_exit: 
140d			      pop   IX 
140d			      pop   DE 
140d			      pop   BC 
140d			 
140d			      ret 
140d			 
140d			 
140d			;      .org 0x8000 
140d			; 
140d			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
140d			 ;                 .dw   0 
140d			 
140d			endif 
140d			 
140d			 
140d			if MALLOC_4 
140d			 
140d			; My memory allocation code. Very very simple.... 
140d			; allocate space under 250 chars 
140d			 
140d			heap_init: 
140d				; init start of heap as zero 
140d				;  
140d			 
140d				ld hl, heap_start 
140d				ld a, 0 
140d				ld (hl), a      ; empty block 
140d				inc hl 
140d				ld a, 0 
140d				ld (hl), a      ; length of block 
140d				; write end of list 
140d				inc hl 
140d				ld a,(hl) 
140d				inc hl 
140d				ld a,(hl) 
140d				 
140d			 
140d				; init some malloc vars 
140d			 
140d				ld hl, 0 
140d				ld (free_list), hl       ; store last malloc location 
140d			 
140d				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
140d				ld a, 0 
140d				ld (hl), a 
140d			 
140d			 
140d				ld hl, heap_start 
140d				;  
140d				  
140d				ret 
140d			 
140d			 
140d			;    free block marker 
140d			;    requested size  
140d			;    pointer to next block 
140d			;    .... 
140d			;    next block marker 
140d			 
140d			 
140d			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
140d			; 
140d			 
140d			 
140d			malloc:  
140d				push de 
140d				push bc 
140d				push af 
140d			 
140d				; hl space required 
140d				 
140d				ld c, l    ; hold space   (TODO only a max of 255) 
140d			 
140d			;	inc c     ; TODO BUG need to fix memory leak on push str 
140d			;	inc c 
140d			;	inc c 
140d			;	inc c 
140d			;	inc c 
140d			;	inc c 
140d			;	inc c 
140d			 
140d			 
140d			 
140d				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
140d			 
140d				ld a, (free_list+3) 
140d				cp 0 
140d				jr z, .contheap 
140d			 
140d				ld hl, (free_list)     ; get last alloc 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "mrs" 
140d						CALLMONITOR 
140d					endif 
140d				jr .startalloc 
140d			 
140d			.contheap: 
140d				ld hl, heap_start 
140d			 
140d			.startalloc: 
140d			 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "mym" 
140d						CALLMONITOR 
140d					endif 
140d			.findblock: 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "mmf" 
140d						CALLMONITOR 
140d					endif 
140d			 
140d				ld a,(hl)  
140d				; if byte is zero then clear to use 
140d			 
140d				cp 0 
140d				jr z, .foundemptyblock 
140d			 
140d				; if byte is not clear 
140d				;     then byte is offset to next block 
140d			 
140d				inc hl 
140d				ld a, (hl) ; get size 
140d			.nextblock:	inc hl 
140d					ld e, (hl) 
140d					inc hl 
140d					ld d, (hl) 
140d					ex de, hl 
140d			;	inc hl  ; move past the store space 
140d			;	inc hl  ; move past zero index  
140d			 
140d				; TODO detect no more space 
140d			 
140d				push hl 
140d				ld de, heap_end 
140d				call cmp16 
140d				pop hl 
140d				jr nc, .nospace 
140d			 
140d				jr .findblock 
140d			 
140d			.nospace: ld hl, 0 
140d				jp .exit 
140d			 
140d			 
140d			.foundemptyblock:	 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "mme" 
140d						CALLMONITOR 
140d					endif 
140d			 
140d			; TODO has block enough space if reusing??? 
140d			 
140d				;  
140d			 
140d			; see if this block has been previously used 
140d				inc hl 
140d				ld a, (hl) 
140d				dec hl 
140d				cp 0 
140d				jr z, .newblock 
140d			 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "meR" 
140d						CALLMONITOR 
140d					endif 
140d			 
140d			; no reusing previously allocated block 
140d			 
140d			; is it smaller than previously used? 
140d				 
140d				inc hl    ; move to size 
140d				ld a, c 
140d				sub (hl)        ; we want c < (hl) 
140d				dec hl    ; move back to marker 
140d			        jr z, .findblock 
140d			 
140d				; update with the new size which should be lower 
140d			 
140d			        ;inc  hl   ; negate next move. move back to size  
140d			 
140d			.newblock: 
140d				; need to be at marker here 
140d			 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "meN" 
140d						CALLMONITOR 
140d					endif 
140d			 
140d			 
140d				ld a, c 
140d			 
140d				ld (free_list+3), a	 ; flag resume from last malloc  
140d				ld (free_list), hl    ; save out last location 
140d			 
140d			 
140d				;inc a     ; space for length byte 
140d				ld (hl), a     ; save block in use marker 
140d			 
140d				inc hl   ; move to space marker 
140d				ld (hl), a    ; save new space 
140d			 
140d				inc hl   ; move to start of allocated area 
140d				 
140d			;	push hl     ; save where we are - 1  
140d			 
140d			;	inc hl  ; move past zero index  
140d				; skip space to set down new marker 
140d			 
140d				; provide some extra space for now 
140d			 
140d				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
140d				inc a 
140d				inc a 
140d			 
140d				push hl   ; save where we are in the node block 
140d			 
140d				call addatohl 
140d			 
140d				; write linked list point 
140d			 
140d				pop de     ; get our node position 
140d				ex de, hl 
140d			 
140d				ld (hl), e 
140d				inc hl 
140d				ld (hl), d 
140d			 
140d				inc hl 
140d			 
140d				; now at start of allocated data so save pointer 
140d			 
140d				push hl 
140d			 
140d				; jump to position of next node and setup empty header in DE 
140d			 
140d				ex de, hl 
140d			 
140d			;	inc hl ; move past end of block 
140d			 
140d				ld a, 0 
140d				ld (hl), a   ; empty marker 
140d				inc hl 
140d				ld (hl), a   ; size 
140d				inc hl  
140d				ld (hl), a   ; ptr 
140d				inc hl 
140d				ld (hl), a   ; ptr 
140d			 
140d			 
140d				pop hl 
140d			 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "mmr" 
140d						CALLMONITOR 
140d					endif 
140d			 
140d			.exit: 
140d				pop af 
140d				pop bc 
140d				pop de  
140d				ret 
140d			 
140d			 
140d			 
140d			 
140d			free:  
140d				push hl 
140d				push af 
140d				; get address in hl 
140d			 
140d					if DEBUG_FORTH_MALLOC_INT 
140d						DMARK "fre" 
140d						CALLMONITOR 
140d					endif 
140d				; data is at hl - move to block count 
140d				dec hl 
140d				dec hl    ; get past pointer 
140d				dec hl 
140d			 
140d				ld a, (hl)    ; need this for a validation check 
140d			 
140d				dec hl    ; move to block marker 
140d			 
140d				; now check that the block count and block marker are the same  
140d			        ; this checks that we are on a malloc node and not random memory 
140d			        ; OK a faint chance this could be a problem but rare - famous last words! 
140d			 
140d				ld c, a 
140d				ld a, (hl)    
140d			 
140d				cp c 
140d				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
140d			 
140d				; yes good chance we are on a malloc node 
140d			 
140d				ld a, 0      
140d				ld (hl), a   ; mark as free 
140d			 
140d				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
140d			 
140d			.freeignore:  
140d			 
140d				pop af 
140d				pop hl 
140d			 
140d				ret 
140d			 
140d			 
140d			 
140d			endif 
140d			 
140d			; eof 
# End of file firmware_memory.asm
140d			  
140d			; device C  
140d			if SOUND_ENABLE  
140d				include "firmware_sound.asm"  
140d			endif  
140d			  
140d			include "firmware_diags.asm"  
140d			; Hardware diags menu 
140d			 
140d			 
140d			config: 
140d			 
140d 3e 00			ld a, 0 
140f 21 3d 14			ld hl, .configmn 
1412 cd b1 0b			call menu 
1415			 
1415 fe 00			cp 0 
1417 c8				ret z 
1418			 
1418 fe 01			cp 1 
141a cc 6b 14			call z, .savetostore 
141d			 
141d fe 02			cp 2 
141f cc 57 14			call z, .selautoload 
1422 fe 03			cp 3 
1424 cc 4d 14			call z, .disautoload 
1427 fe 04			cp 4 
1429 cc 61 14			call z, .selbank 
142c fe 05			cp 5 
142e cc 75 14			call z, .debug_tog 
1431 fe 06			cp 6 
1433 cc b8 15			call z, .bpsgo 
1436 fe 07			cp 7 
1438 cc 9b 14			call z, hardware_diags 
143b			 
143b 18 d0			jr config 
143d			 
143d			.configmn: 
143d a9 17			dw prom_c3 
143f c0 17			dw prom_c2 
1441 d5 17			dw prom_c2a 
1443 eb 17			dw prom_c2b 
1445			;	dw prom_c4 
1445 08 18			dw prom_m4 
1447 23 18			dw prom_m4b 
1449 2b 18			dw prom_c1 
144b 00 00			dw 0 
144d				 
144d			 
144d			 
144d			 
144d			.disautoload: 
144d				if STORAGE_SE 
144d				ld a, $fe      ; bit 0 clear 
144d				ld (spi_device), a 
144d			 
144d				call storage_get_block_0 
144d			 
144d				ld a, 0 
144d				ld (store_page+STORE_0_AUTOFILE), a 
144d			 
144d					ld hl, 0 
144d					ld de, store_page 
144d				call storage_write_block	 ; save update 
144d				else 
144d			 
144d 21 3a 18			ld hl, prom_notav 
1450 11 50 18			ld de, prom_empty 
1453 cd 11 0b			call info_panel 
1456				endif 
1456			 
1456			 
1456 c9				ret 
1457			 
1457			 
1457			 
1457			; Select auto start 
1457			 
1457			.selautoload: 
1457			 
1457				 
1457				if STORAGE_SE 
1457			 
1457					call config_dir 
1457				        ld hl, scratch 
1457					ld a, 0 
1457					call menu 
1457			 
1457					cp 0 
1457					ret z 
1457			 
1457					dec a 
1457			 
1457			 
1457					; locate menu option 
1457			 
1457					ld hl, scratch 
1457					call table_lookup 
1457			 
1457					if DEBUG_FORTH_WORDS 
1457						DMARK "ALl" 
1457						CALLMONITOR 
1457					endif 
1457					; with the pointer to the menu it, the byte following the zero term is the file id 
1457			 
1457					ld a, 0 
1457					ld bc, 50   ; max of bytes to look at 
1457					cpir  
1457			 
1457					if DEBUG_FORTH_WORDS 
1457						DMARK "ALb" 
1457						CALLMONITOR 
1457					endif 
1457					;inc hl 
1457			 
1457					ld a, (hl)   ; file id 
1457					 
1457				        ; save bank and file ids 
1457			 
1457					push af 
1457			 
1457			; TODO need to save to block 0 on bank 1	 
1457			 
1457					call storage_get_block_0 
1457			 
1457					if DEBUG_FORTH_WORDS 
1457						DMARK "AL0" 
1457						CALLMONITOR 
1457					endif 
1457					pop af 
1457			 
1457					ld (store_page+STORE_0_FILERUN),a 
1457					 
1457					; save bank id 
1457			 
1457					ld a,(spi_device) 
1457					ld (store_page+STORE_0_BANKRUN),a 
1457			 
1457					; enable auto run of store file 
1457			 
1457					ld a, 1 
1457					ld (store_page+STORE_0_AUTOFILE),a 
1457			 
1457					; save buffer 
1457			 
1457					ld hl, 0 
1457					ld de, store_page 
1457					if DEBUG_FORTH_WORDS 
1457						DMARK "ALw" 
1457						CALLMONITOR 
1457					endif 
1457				call storage_write_block	 ; save update 
1457			  
1457			 
1457			 
1457			 
1457					ld hl, scratch 
1457					call config_fdir 
1457			 
1457				else 
1457			 
1457 21 3a 18			ld hl, prom_notav 
145a 11 50 18			ld de, prom_empty 
145d cd 11 0b			call info_panel 
1460			 
1460				endif 
1460 c9				ret 
1461			 
1461			 
1461			 
1461			; Select storage bank 
1461			 
1461			.selbank: 
1461			 
1461				if STORAGE_SE 
1461				else 
1461			 
1461 21 3a 18			ld hl, prom_notav 
1464 11 50 18			ld de, prom_empty 
1467 cd 11 0b			call info_panel 
146a				endif 
146a				 
146a c9				ret 
146b			 
146b			if STORAGE_SE 
146b			 
146b			.config_ldir:   
146b				; Load storage bank labels into menu array 
146b			 
146b				 
146b			 
146b			 
146b				ret 
146b			 
146b			 
146b			endif 
146b			 
146b			 
146b			; Save user words to storage 
146b			 
146b			.savetostore: 
146b			 
146b				if STORAGE_SE 
146b			 
146b					call config_dir 
146b				        ld hl, scratch 
146b					ld a, 0 
146b					call menu 
146b					 
146b					ld hl, scratch 
146b					call config_fdir 
146b			 
146b				else 
146b			 
146b 21 3a 18			ld hl, prom_notav 
146e 11 50 18			ld de, prom_empty 
1471 cd 11 0b			call info_panel 
1474			 
1474				endif 
1474			 
1474 c9				ret 
1475			 
1475			 
1475			 
1475			if STORAGE_SE 
1475			 
1475			config_fdir: 
1475				; using the scratch dir go through and release the memory allocated for each string 
1475				 
1475				ld hl, scratch 
1475			.cfdir:	ld e,(hl) 
1475				inc hl 
1475				ld d,(hl) 
1475				inc hl 
1475			 
1475				ex de, hl 
1475				call ishlzero 
1475				ret z     ; return on null pointer 
1475				call free 
1475				ex de, hl 
1475				jr .cfdir 
1475			 
1475			 
1475				ret 
1475			 
1475			 
1475			config_dir: 
1475			 
1475				; for the config menus that need to build a directory of storage call this routine 
1475				; it will construct a menu in scratch to pass to menu 
1475			 
1475				; open storage device 
1475			 
1475				; execute DIR to build a list of files and their ids into scratch in menu format 
1475				; once the menu has finished then will need to call config_fdir to release the strings 
1475				 
1475				; c = number items 
1475			 
1475				 
1475				call storage_get_block_0 
1475			 
1475				ld hl, store_page     ; get current id count 
1475				ld b, (hl) 
1475				ld c, 0    ; count of files   
1475			 
1475			 
1475				ld hl, scratch 
1475				ld (store_tmp2), hl    ; location to poke strings 
1475			 
1475				; check for empty drive 
1475			 
1475				ld a, 0 
1475				cp b 
1475				jp z, .dirdone 
1475			 
1475				 
1475					if DEBUG_FORTH_WORDS 
1475						DMARK "Cdc" 
1475						CALLMONITOR 
1475					endif 
1475			 
1475			 
1475			.diritem:	 
1475				push bc 
1475				; for each of the current ids do a search for them and if found push to stack 
1475			 
1475					ld hl, STORE_BLOCK_PHY 
1475					ld d, 0		 ; look for extent 0 of block id as this contains file name 
1475					ld e,b 
1475			 
1475					call storage_findnextid 
1475			 
1475			 
1475					; if found hl will be non zero 
1475			 
1475					call ishlzero 
1475					jr z, .dirnotfound 
1475			 
1475					; increase count 
1475			 
1475					pop bc	 
1475					inc c 
1475					push bc 
1475					 
1475			 
1475					; get file header and push the file name 
1475			 
1475					ld de, store_page 
1475					call storage_read_block 
1475			 
1475					; push file id to stack 
1475				 
1475					ld a, (store_page) 
1475					ld h, 0 
1475					ld l, a 
1475			 
1475					;call forth_push_numhl 
1475					; TODO store id 
1475			 
1475					push hl 
1475			 
1475					; push extent count to stack  
1475				 
1475					ld hl, store_page+3 
1475			 
1475					; get file name length 
1475			 
1475					call strlenz   
1475			 
1475					inc hl   ; cover zero term 
1475					inc hl  ; stick the id at the end of the area 
1475			 
1475					push hl 
1475					pop bc    ; move length to bc 
1475			 
1475					call malloc 
1475			 
1475					; TODO save malloc area to scratch 
1475			 
1475					ex de, hl 
1475					ld hl, (store_tmp2) 
1475					ld (hl), e 
1475					inc hl 
1475					ld (hl), d 
1475					inc hl 
1475					ld (store_tmp2), hl 
1475			 
1475					 
1475			 
1475					;pop hl   ; get source 
1475			;		ex de, hl    ; swap aronund	 
1475			 
1475					ld hl, store_page+3 
1475					if DEBUG_FORTH_WORDS 
1475						DMARK "CFd" 
1475						CALLMONITOR 
1475					endif 
1475					ldir 
1475			 
1475					; de is past string, move back one and store id 
1475					 
1475					dec de 
1475			 
1475					; store file id 
1475			 
1475					pop hl 
1475					ex de,hl 
1475					ld (hl), e 
1475			 
1475					if DEBUG_FORTH_WORDS 
1475						DMARK "Cdi" 
1475						CALLMONITOR 
1475					endif 
1475					 
1475			.dirnotfound: 
1475					pop bc     
1475					djnz .diritem 
1475				 
1475			.dirdone:	 
1475			 
1475					ld a, 0 
1475					ld hl, (store_tmp2) 
1475					ld (hl), a 
1475					inc hl 
1475					ld (hl), a 
1475					inc hl 
1475					; push a count of the dir items found 
1475			 
1475			;		ld h, 0 
1475			;		ld l, c 
1475			 
1475				ret 
1475			 
1475			endif 
1475			 
1475			 
1475			; Settings 
1475			; Run  
1475			 
1475			 
1475			 
1475			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1475			;;hd_menu2:   db "        2: Editor",0   
1475			;hd_menu2:   db "        2: Editor       6: Menu",0   
1475			;hd_menu3:   db "        3: Storage",0 
1475			;hd_menu4:   db "0=quit  4: Debug",0 
1475			;hd_don:     db "ON",0 
1475			;hd_doff:     db "OFF",0 
1475			; 
1475			; 
1475			; 
1475			;hardware_diags_old:       
1475			; 
1475			;.diagmenu: 
1475			;	call clear_display 
1475			;	ld a, display_row_1 
1475			;	ld de, hd_menu1 
1475			;	call str_at_display 
1475			; 
1475			;	ld a, display_row_2 
1475			;	ld de, hd_menu2 
1475			;	call str_at_display 
1475			; 
1475			;	ld a, display_row_3 
1475			;	ld de, hd_menu3 
1475			;	call str_at_display 
1475			; 
1475			;	ld a,  display_row_4 
1475			;	ld de, hd_menu4 
1475			;	call str_at_display 
1475			; 
1475			;	; display debug state 
1475			; 
1475			;	ld de, hd_don 
1475			;	ld a, (os_view_disable) 
1475			;	cp 0 
1475			;	jr z, .distog 
1475			;	ld de, hd_doff 
1475			;.distog: ld a, display_row_4+17 
1475			;	call str_at_display 
1475			; 
1475			;	call update_display 
1475			; 
1475			;	call cin_wait 
1475			; 
1475			; 
1475			; 
1475			;	cp '4' 
1475			;	jr nz, .diagn1 
1475			; 
1475			;	; debug toggle 
1475			; 
1475			;	ld a, (os_view_disable) 
1475			;	ld b, '*' 
1475			;	cp 0 
1475			;	jr z, .debtog 
1475			;	ld b, 0 
1475			;.debtog:	 
1475			;	ld a,b 
1475			;	ld (os_view_disable),a 
1475			; 
1475			;.diagn1: cp '0' 
1475			;	 ret z 
1475			; 
1475			;;	cp '1' 
1475			;;       jp z, matrix	 
1475			;;   TODO keyboard matrix test 
1475			; 
1475			;	cp '2' 
1475			;	jp z, .diagedit 
1475			; 
1475			;;	cp '6' 
1475			;;	jp z, .menutest 
1475			;;if ENABLE_BASIC 
1475			;;	cp '6' 
1475			;;	jp z, basic 
1475			;;endif 
1475			 ; 
1475			;	jp .diagmenu 
1475			; 
1475			; 
1475			;	ret 
1475			 
1475			 
1475			.debug_tog: 
1475 21 bc 14			ld hl, .menudebug 
1478				 
1478 3a f0 e2			ld a, (os_view_disable) 
147b fe 2a			cp '*' 
147d 20 04			jr nz,.tdon  
147f 3e 01			ld a, 1 
1481 18 02			jr .tog1 
1483 3e 00		.tdon: ld a, 0 
1485			 
1485			.tog1: 
1485 cd b1 0b			call menu 
1488 fe 00			cp 0 
148a c8				ret z 
148b fe 01			cp 1    ; disable debug 
148d 28 04			jr z, .dtog0 
148f 3e 2a			ld a, '*' 
1491 18 02			jr .dtogset 
1493 3e 00		.dtog0: ld a, 0 
1495 32 f0 e2		.dtogset:  ld (os_view_disable), a 
1498 c3 75 14			jp .debug_tog 
149b			 
149b			 
149b			hardware_diags:       
149b			 
149b			.diagm: 
149b 21 ae 14			ld hl, .menuitems 
149e 3e 00			ld a, 0 
14a0 cd b1 0b			call menu 
14a3			 
14a3 fe 00		         cp 0 
14a5 c8				 ret z 
14a6			 
14a6 fe 02			cp 2 
14a8 ca 07 15			jp z, .diagedit 
14ab			 
14ab			;	cp '6' 
14ab			;	jp z, .menutest 
14ab			;if ENABLE_BASIC 
14ab			;	cp '6' 
14ab			;	jp z, basic 
14ab			;endif 
14ab			  
14ab c3 9b 14			jp .diagm 
14ae			 
14ae				 
14ae c2 14		.menuitems:   	dw .m1 
14b0 cd 14				dw .m2 
14b2 d4 14				dw .m3 
14b4 dc 14				dw .m5 
14b6 e2 14				dw .m5a 
14b8 eb 14				dw .m5b 
14ba 00 00				dw 0 
14bc			 
14bc			.menudebug: 
14bc f4 14				dw .m6 
14be fd 14				dw .m7 
14c0 00 00				dw 0 
14c2			 
14c2 .. 00		.m1:   db "Key Matrix",0 
14cd .. 00		.m2:   db "Editor",0 
14d4 .. 00		.m3:   db "Storage",0 
14dc .. 00		.m5:   db "Sound",0 
14e2 .. 00		.m5a:  db "RAM Test",0 
14eb .. 00		.m5b:  db "LCD Test",0 
14f4			 
14f4 .. 00		.m6:   db "Debug ON",0 
14fd .. 00		.m7:   db "Debug OFF",0 
1507			 
1507			; debug editor 
1507			 
1507			.diagedit: 
1507			 
1507 21 ff e2			ld hl, scratch 
150a			;	ld bc, 250 
150a			;	ldir 
150a				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
150a 3e 00			ld a, 0 
150c 77				ld (hl), a 
150d 23				inc hl 
150e 77				ld (hl), a 
150f 23				inc hl 
1510 77				ld (hl), a 
1511			 
1511 cd 80 0b		        call clear_display 
1514 cd a3 0b			call update_display 
1517				;ld a, 1 
1517				;ld (hardware_diag), a 
1517			.diloop: 
1517 3e 00			ld a, display_row_1 
1519 0e 00			ld c, 0 
151b 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
151d 1e 28			ld e, 40 
151f			 
151f 21 ff e2			ld hl, scratch	 
1522 cd da 0d			call input_str 
1525			 
1525 3e 28			ld a, display_row_2 
1527 11 ff e2			ld de, scratch 
152a cd 93 0b			call str_at_display 
152d cd a3 0b			call update_display 
1530			 
1530 c3 17 15			jp .diloop 
1533			 
1533			 
1533			; pass word in hl 
1533			; a has display location 
1533			display_word_at: 
1533 f5				push af 
1534 e5				push hl 
1535 7c				ld a,h 
1536 21 04 e6			ld hl, os_word_scratch 
1539 cd ae 10			call hexout 
153c e1				pop hl 
153d 7d				ld a,l 
153e 21 06 e6			ld hl, os_word_scratch+2 
1541 cd ae 10			call hexout 
1544 21 08 e6			ld hl, os_word_scratch+4 
1547 3e 00			ld a,0 
1549 77				ld (hl),a 
154a 11 04 e6			ld de,os_word_scratch 
154d f1				pop af 
154e cd 93 0b				call str_at_display 
1551 c9				ret 
1552			 
1552			display_ptr_state: 
1552			 
1552				; to restore afterwards 
1552			 
1552 d5				push de 
1553 c5				push bc 
1554 e5				push hl 
1555 f5				push af 
1556			 
1556				; for use in here 
1556			 
1556			;	push bc 
1556			;	push de 
1556			;	push hl 
1556			;	push af 
1556			 
1556 cd 80 0b			call clear_display 
1559			 
1559 11 2c 17			ld de, .ptrstate 
155c 3e 00			ld a, display_row_1 
155e cd 93 0b			call str_at_display 
1561			 
1561				; display debug step 
1561			 
1561			 
1561 11 71 ee			ld de, debug_mark 
1564 3e 26			ld a, display_row_1+display_cols-2 
1566 cd 93 0b			call str_at_display 
1569			 
1569				; display a 
1569 11 36 17			ld de, .ptrcliptr 
156c 3e 28			ld a, display_row_2 
156e cd 93 0b			call str_at_display 
1571			 
1571 f1				pop af 
1572 2a 4a ea			ld hl,(cli_ptr) 
1575 3e 30			ld a, display_row_2+8 
1577 cd 33 15			call display_word_at 
157a			 
157a			 
157a				; display hl 
157a			 
157a			 
157a 11 3e 17			ld de, .ptrclioptr 
157d 3e 32			ld a, display_row_2+10 
157f cd 93 0b			call str_at_display 
1582			; 
1582			;	pop hl 
1582 3e 35			ld a, display_row_2+13 
1584 2a 48 ea			ld hl,(cli_origptr) 
1587 cd 33 15			call display_word_at 
158a			; 
158a			;	 
158a			;	; display de 
158a			 
158a			;	ld de, .regstatede 
158a			;	ld a, display_row_3 
158a			;	call str_at_display 
158a			 
158a			;	pop de 
158a			;	ld h,d 
158a			;	ld l, e 
158a			;	ld a, display_row_3+3 
158a			;	call display_word_at 
158a			 
158a			 
158a				; display bc 
158a			 
158a			;	ld de, .regstatebc 
158a			;	ld a, display_row_3+10 
158a			;	call str_at_display 
158a			 
158a			;	pop bc 
158a			;	ld h,b 
158a			;	ld l, c 
158a			;	ld a, display_row_3+13 
158a			;	call display_word_at 
158a			 
158a			 
158a				; display dsp 
158a			 
158a			;	ld de, .regstatedsp 
158a			;	ld a, display_row_4 
158a			;	call str_at_display 
158a			 
158a				 
158a			;	ld hl,(cli_data_sp) 
158a			;	ld a, display_row_4+4 
158a			;	call display_word_at 
158a			 
158a				; display rsp 
158a			 
158a 11 6d 17			ld de, .regstatersp 
158d 3e 82			ld a, display_row_4+10 
158f cd 93 0b			call str_at_display 
1592			 
1592				 
1592 2a 30 ea			ld hl,(cli_ret_sp) 
1595 3e 86			ld a, display_row_4+14 
1597 cd 33 15			call display_word_at 
159a			 
159a cd a3 0b			call update_display 
159d			 
159d cd f2 0a			call delay1s 
15a0 cd f2 0a			call delay1s 
15a3 cd f2 0a			call delay1s 
15a6			 
15a6			 
15a6 cd 97 1b			call next_page_prompt 
15a9			 
15a9				; restore  
15a9			 
15a9 f1				pop af 
15aa e1				pop hl 
15ab c1				pop bc 
15ac d1				pop de 
15ad c9				ret 
15ae			 
15ae			break_point_state: 
15ae f5				push af 
15af			 
15af				; see if disabled 
15af			 
15af 3a f0 e2			ld a, (os_view_disable) 
15b2 fe 2a			cp '*' 
15b4 20 02			jr nz, .bpsgo 
15b6 f1				pop af 
15b7 c9				ret 
15b8			 
15b8			.bpsgo: 
15b8 f1				pop af 
15b9 f5				push af 
15ba 22 ec e2			ld (os_view_hl), hl 
15bd ed 53 ea e2		ld (os_view_de), de 
15c1 ed 43 e8 e2		ld (os_view_bc), bc 
15c5 e5				push hl 
15c6 6f				ld l, a 
15c7 26 00			ld h, 0 
15c9 22 ee e2			ld (os_view_af),hl 
15cc			 
15cc 21 b7 ed				ld hl, display_fb0 
15cf 22 d2 eb				ld (display_fb_active), hl 
15d2 e1				pop hl	 
15d3			 
15d3 3e 31			ld a, '1' 
15d5 fe 2a		.bps1:  cp '*' 
15d7 20 03			jr nz, .bps1b 
15d9 32 f0 e2			ld (os_view_disable),a 
15dc fe 31		.bps1b:  cp '1' 
15de 20 14			jr nz, .bps2 
15e0			 
15e0				; display reg 
15e0			 
15e0				 
15e0			 
15e0 3a ee e2			ld a, (os_view_af) 
15e3 2a ec e2			ld hl, (os_view_hl) 
15e6 ed 5b ea e2		ld de, (os_view_de) 
15ea ed 4b e8 e2		ld bc, (os_view_bc) 
15ee cd 88 16			call display_reg_state 
15f1 c3 74 16			jp .bpschk 
15f4			 
15f4 fe 32		.bps2:  cp '2' 
15f6 20 08			jr nz, .bps3 
15f8				 
15f8				; display hl 
15f8 2a ec e2			ld hl, (os_view_hl) 
15fb cd 72 17			call display_dump_at_hl 
15fe			 
15fe 18 74			jr .bpschk 
1600			 
1600 fe 33		.bps3:  cp '3' 
1602 20 08			jr nz, .bps4 
1604			 
1604			        ; display de 
1604 2a ea e2			ld hl, (os_view_de) 
1607 cd 72 17			call display_dump_at_hl 
160a			 
160a 18 68			jr .bpschk 
160c fe 34		.bps4:  cp '4' 
160e 20 08			jr nz, .bps5 
1610			 
1610			        ; display bc 
1610 2a e8 e2			ld hl, (os_view_bc) 
1613 cd 72 17			call display_dump_at_hl 
1616			 
1616 18 5c			jr .bpschk 
1618 fe 35		.bps5:  cp '5' 
161a 20 08		        jr nz, .bps7 
161c			 
161c				; display cur ptr 
161c 2a 4a ea			ld hl, (cli_ptr) 
161f cd 72 17			call display_dump_at_hl 
1622			 
1622 18 50			jr .bpschk 
1624 fe 36		.bps7:  cp '6' 
1626 20 08			jr nz, .bps8b 
1628				 
1628				; display cur orig ptr 
1628 2a 48 ea			ld hl, (cli_origptr) 
162b cd 72 17			call display_dump_at_hl 
162e 18 44			jr .bpschk 
1630 fe 37		.bps8b:  cp '7' 
1632 20 08			jr nz, .bps9 
1634				 
1634				; display dsp 
1634 2a 2c ea			ld hl, (cli_data_sp) 
1637 cd 72 17			call display_dump_at_hl 
163a			 
163a 18 38			jr .bpschk 
163c fe 39		.bps9:  cp '9' 
163e 20 05			jr nz, .bps8c 
1640				 
1640				; display SP 
1640			;	ld hl, sp 
1640 cd 72 17			call display_dump_at_hl 
1643			 
1643 18 2f			jr .bpschk 
1645 fe 38		.bps8c:  cp '8' 
1647 20 08			jr nz, .bps8d 
1649				 
1649				; display rsp 
1649 2a 30 ea			ld hl, (cli_ret_sp) 
164c cd 72 17			call display_dump_at_hl 
164f			 
164f 18 23			jr .bpschk 
1651 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1653 20 05			jr nz, .bps8 
1655 cd 8d 19			call monitor 
1658			 
1658 18 1a			jr .bpschk 
165a fe 30		.bps8:  cp '0' 
165c 20 16			jr nz, .bpschk 
165e			 
165e 21 16 ed				ld hl, display_fb1 
1661 22 d2 eb				ld (display_fb_active), hl 
1664 cd a3 0b				call update_display 
1667			 
1667				;ld a, (os_view_af) 
1667 2a ec e2			ld hl, (os_view_hl) 
166a ed 5b ea e2		ld de, (os_view_de) 
166e ed 4b e8 e2		ld bc, (os_view_bc) 
1672 f1				pop af 
1673 c9				ret 
1674			 
1674			.bpschk:   
1674 cd f2 0a			call delay1s 
1677 3e 9f		ld a,display_row_4 + display_cols - 1 
1679 11 95 1b		        ld de, endprg 
167c cd 93 0b			call str_at_display 
167f cd a3 0b			call update_display 
1682 cd f2 5e			call cin_wait 
1685			 
1685 c3 d5 15			jp .bps1 
1688			 
1688			 
1688			display_reg_state: 
1688			 
1688				; to restore afterwards 
1688			 
1688 d5				push de 
1689 c5				push bc 
168a e5				push hl 
168b f5				push af 
168c			 
168c				; for use in here 
168c			 
168c c5				push bc 
168d d5				push de 
168e e5				push hl 
168f f5				push af 
1690			 
1690 cd 80 0b			call clear_display 
1693			 
1693 11 48 17			ld de, .regstate 
1696 3e 00			ld a, display_row_1 
1698 cd 93 0b			call str_at_display 
169b			 
169b				; display debug step 
169b			 
169b			 
169b 11 71 ee			ld de, debug_mark 
169e 3e 25			ld a, display_row_1+display_cols-3 
16a0 cd 93 0b			call str_at_display 
16a3			 
16a3				; display a 
16a3 11 64 17			ld de, .regstatea 
16a6 3e 28			ld a, display_row_2 
16a8 cd 93 0b			call str_at_display 
16ab			 
16ab e1				pop hl 
16ac			;	ld h,0 
16ac			;	ld l, a 
16ac 3e 2b			ld a, display_row_2+3 
16ae cd 33 15			call display_word_at 
16b1			 
16b1			 
16b1				; display hl 
16b1			 
16b1			 
16b1 11 58 17			ld de, .regstatehl 
16b4 3e 32			ld a, display_row_2+10 
16b6 cd 93 0b			call str_at_display 
16b9			 
16b9 e1				pop hl 
16ba 3e 35			ld a, display_row_2+13 
16bc cd 33 15			call display_word_at 
16bf			 
16bf				 
16bf				; display de 
16bf			 
16bf 11 5c 17			ld de, .regstatede 
16c2 3e 50			ld a, display_row_3 
16c4 cd 93 0b			call str_at_display 
16c7			 
16c7 e1				pop hl 
16c8			;	ld h,d 
16c8			;	ld l, e 
16c8 3e 53			ld a, display_row_3+3 
16ca cd 33 15			call display_word_at 
16cd			 
16cd			 
16cd				; display bc 
16cd			 
16cd 11 60 17			ld de, .regstatebc 
16d0 3e 5a			ld a, display_row_3+10 
16d2 cd 93 0b			call str_at_display 
16d5			 
16d5 e1				pop hl 
16d6			;	ld h,b 
16d6			;	ld l, c 
16d6 3e 5d			ld a, display_row_3+13 
16d8 cd 33 15			call display_word_at 
16db			 
16db			 
16db				; display dsp 
16db			 
16db 11 68 17			ld de, .regstatedsp 
16de 3e 78			ld a, display_row_4 
16e0 cd 93 0b			call str_at_display 
16e3			 
16e3				 
16e3 2a 2c ea			ld hl,(cli_data_sp) 
16e6 3e 7c			ld a, display_row_4+4 
16e8 cd 33 15			call display_word_at 
16eb			 
16eb				; display rsp 
16eb			 
16eb 11 6d 17			ld de, .regstatersp 
16ee 3e 82			ld a, display_row_4+10 
16f0 cd 93 0b			call str_at_display 
16f3			 
16f3				 
16f3 2a 30 ea			ld hl,(cli_ret_sp) 
16f6 3e 86			ld a, display_row_4+14 
16f8 cd 33 15			call display_word_at 
16fb			 
16fb cd a3 0b			call update_display 
16fe			 
16fe			;	call delay1s 
16fe			;	call delay1s 
16fe			;	call delay1s 
16fe			 
16fe			 
16fe			;	call next_page_prompt 
16fe			 
16fe				; restore  
16fe			 
16fe f1				pop af 
16ff e1				pop hl 
1700 c1				pop bc 
1701 d1				pop de 
1702 c9				ret 
1703			 
1703 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1717 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
172c .. 00		.ptrstate:	db "Ptr State",0 
1736 .. 00		.ptrcliptr:     db "cli_ptr",0 
173e .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1748 .. 00		.regstate:	db "Reg State (1/0)",0 
1758 .. 00		.regstatehl:	db "HL:",0 
175c .. 00		.regstatede:	db "DE:",0 
1760 .. 00		.regstatebc:	db "BC:",0 
1764 .. 00		.regstatea:	db "A :",0 
1768 .. 00		.regstatedsp:	db "DSP:",0 
176d .. 00		.regstatersp:	db "RSP:",0 
1772			 
1772			display_dump_at_hl: 
1772 e5				push hl 
1773 d5				push de 
1774 c5				push bc 
1775 f5				push af 
1776			 
1776 22 22 e6			ld (os_cur_ptr),hl	 
1779 cd 80 0b			call clear_display 
177c cd 9f 1a			call dumpcont 
177f			;	call delay1s 
177f			;	call next_page_prompt 
177f			 
177f			 
177f f1				pop af 
1780 c1				pop bc 
1781 d1				pop de 
1782 e1				pop hl 
1783 c9				ret 
1784			 
1784			;if ENABLE_BASIC 
1784			;	include "nascombasic.asm" 
1784			;	basic: 
1784			;	include "forth/FORTH.ASM" 
1784			;endif 
1784			 
1784			; eof 
1784			 
1784			 
# End of file firmware_diags.asm
1784			  
1784			include "firmware_prompts.asm"  
1784			; Prompts  
1784			 
1784			; boot messages 
1784			 
1784 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1799 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
17a9			 
17a9			 
17a9			; config menus 
17a9			 
17a9 .. 00		prom_c3: db "Add Dictionary To File",0 
17c0 .. 00		prom_c2: db "Select Autoload File",0 
17d5 .. 00		prom_c2a: db "Disable Autoload File", 0 
17eb .. 00		prom_c2b: db "Select Storage Bank",0 
17ff .. 00		prom_c4: db "Settings",0 
1808 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1823 .. 00		prom_m4b:   db "Monitor",0 
182b .. 00		prom_c1: db "Hardware Diags",0 
183a			 
183a			 
183a .. 00		prom_notav:    db "Feature not available",0 
1850 .. 00		prom_empty:    db "",0 
1851			 
1851			; eof 
1851			 
# End of file firmware_prompts.asm
1851			  
1851			  
1851			; eof  
1851			  
# End of file firmware.asm
1851			 
1851			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1851			;if BASE_KEV  
1851			;baseram: equ 08000h 
1851			;endif 
1851			 
1851			;if BASE_SC114 
1851			;baseram:     equ    endofcode 
1851			;endif 
1851			 
1851			 
1851			; start system 
1851			 
1851			coldstart: 
1851				; set sp 
1851				; di/ei 
1851			 
1851 f3				di 
1852 31 00 f0			ld sp, tos 
1855			;	ei 
1855			 
1855			 
1855				; disable breakpoint by default 
1855			 
1855 3e 2a			ld a,'*' 
1857 32 f0 e2			ld (os_view_disable),a 
185a			 
185a				; init hardware 
185a			 
185a				; init keyboard and screen hardware 
185a			 
185a cd 1c 01			call hardware_init 
185d			 
185d			 
185d cd f2 0a			call delay1s 
1860 3e 58			ld a, display_row_3+8 
1862 11 03 01			ld de, buildtime 
1865 cd 93 0b			call str_at_display 
1868 cd a3 0b			call update_display 
186b			 
186b cd f2 0a			call delay1s 
186e cd f2 0a			call delay1s 
1871 cd f2 0a			call delay1s 
1874			 
1874				; detect if any keys are held down to enable breakpoints at start up 
1874			 
1874 cd fa 5e			call cin  
1877 fe 00			cp 0 
1879 28 03			jr z, .nokeys 
187b			 
187b				;call hardware_diags 
187b cd 0d 14			call config 
187e			 
187e			;	ld de, .bpen 
187e			;	ld a, display_row_4 
187e			;	call str_at_display 
187e			;	call update_display 
187e			; 
187e			;	ld a,0 
187e			;	ld (os_view_disable),a 
187e			; 
187e			;.bpwait: 
187e			;	call cin 
187e			;	cp 0 
187e			;	jr z, .bpwait 
187e			;	jr .nokeys 
187e			; 
187e			; 
187e			;.bpen:  db "Break points enabled!",0 
187e			 
187e			 
187e			 
187e			 
187e			 
187e			 
187e			.nokeys: 
187e			 
187e			 
187e				 
187e			 
187e			;jp  testkey 
187e			 
187e			;call storage_get_block_0 
187e			; 
187e			;ld hl, 0 
187e			;ld de, store_page 
187e			;call storage_read_block 
187e			 
187e				 
187e			;ld hl, 10 
187e			;ld de, store_page 
187e			;call storage_read_block 
187e			 
187e			 
187e			 
187e			 
187e			 
187e			;stop:	nop 
187e			;	jp stop 
187e			 
187e			 
187e			 
187e			main: 
187e cd 80 0b			call clear_display 
1881 cd a3 0b			call update_display 
1884			 
1884			 
1884			 
1884			;	call testlcd 
1884			 
1884			 
1884			 
1884 cd 5d 1f			call forth_init 
1887			 
1887			 
1887			warmstart: 
1887 cd 33 1f			call forth_warmstart 
188a			 
188a				; run startup word load 
188a			        ; TODO prevent this running at warmstart after crash  
188a			 
188a				if STARTUP_ENABLE 
188a					if STORAGE_SE 
188a						call forth_autoload 
188a					endif 
188a cd 40 5b				call forth_startup 
188d			 
188d			 
188d				endif 
188d			 
188d				; show free memory after boot 
188d 11 27 19			ld de, freeram 
1890 3e 00			ld a, display_row_1 
1892 cd 93 0b			call str_at_display 
1895			 
1895			; Or use heap_size word???? 
1895 21 e5 e2			ld hl, heap_end 
1898 11 22 5f			ld de, heap_start 
189b ed 52			sbc hl, de 
189d e5				push hl 
189e 7c				ld a,h	         	 
189f 21 04 e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
18a2 cd ae 10			call hexout 
18a5 e1			   	pop hl 
18a6			 
18a6 7d				ld a,l 
18a7 21 06 e6			ld hl, os_word_scratch+2 
18aa cd ae 10			call hexout 
18ad 21 08 e6			ld hl, os_word_scratch+4 
18b0 3e 00			ld a, 0 
18b2 77				ld (hl),a 
18b3 11 04 e6			ld de, os_word_scratch 
18b6 3e 0d			ld a, display_row_1 + 13 
18b8 cd 93 0b			call str_at_display 
18bb cd a3 0b			call update_display 
18be			 
18be			 
18be				;call demo 
18be			 
18be			 
18be				; init scratch input area for cli commands 
18be			 
18be 21 26 e6			ld hl, os_cli_cmd 
18c1 3e 00			ld a,0 
18c3 77				ld (hl),a 
18c4 23				inc hl 
18c5 77				ld (hl),a 
18c6			 
18c6 3e 00			ld a,0 
18c8 32 25 e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
18cb			 
18cb 32 22 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
18ce 32 23 e6			ld (os_cur_ptr+1),a	 
18d1			 
18d1 32 04 e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
18d4 32 05 e6			ld (os_word_scratch+1),a	 
18d7				 
18d7			 
18d7				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18d7 21 26 e6			ld hl, os_cli_cmd 
18da			 
18da 3e 00			ld a, 0		 ; init cli input 
18dc 77				ld (hl), a 
18dd 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18df			cli: 
18df				; show cli prompt 
18df				;push af 
18df				;ld a, 0 
18df				;ld de, prompt 
18df				;call str_at_display 
18df			 
18df				;call update_display 
18df				;pop af 
18df				;inc a 
18df				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18df 0e 00			ld c, 0 
18e1 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18e3 1e 28			ld e, 40 
18e5			 
18e5 21 26 e6			ld hl, os_cli_cmd 
18e8			 
18e8				STACKFRAME OFF $fefe $9f9f 
18e8				if DEBUG_STACK_IMB 
18e8					if OFF 
18e8						exx 
18e8						ld de, $fefe 
18e8						ld a, d 
18e8						ld hl, curframe 
18e8						call hexout 
18e8						ld a, e 
18e8						ld hl, curframe+2 
18e8						call hexout 
18e8						ld hl, $fefe 
18e8						push hl 
18e8						ld hl, $9f9f 
18e8						push hl 
18e8						exx 
18e8					endif 
18e8				endif 
18e8			endm 
# End of macro STACKFRAME
18e8			 
18e8 cd da 0d			call input_str 
18eb			 
18eb				STACKFRAMECHK OFF $fefe $9f9f 
18eb				if DEBUG_STACK_IMB 
18eb					if OFF 
18eb						exx 
18eb						ld hl, $9f9f 
18eb						pop de   ; $9f9f 
18eb						call cmp16 
18eb						jr nz, .spnosame 
18eb						ld hl, $fefe 
18eb						pop de   ; $fefe 
18eb						call cmp16 
18eb						jr z, .spfrsame 
18eb						.spnosame: call showsperror 
18eb						.spfrsame: nop 
18eb						exx 
18eb					endif 
18eb				endif 
18eb			endm 
# End of macro STACKFRAMECHK
18eb			 
18eb				; copy input to last command 
18eb			 
18eb 21 26 e6			ld hl, os_cli_cmd 
18ee 11 25 e7			ld de, os_last_cmd 
18f1 01 ff 00			ld bc, 255 
18f4 ed b0			ldir 
18f6			 
18f6				; wipe current buffer 
18f6			 
18f6			;	ld a, 0 
18f6			;	ld hl, os_cli_cmd 
18f6			;	ld de, os_cli_cmd+1 
18f6			;	ld bc, 254 
18f6			;	ldir 
18f6				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18f6			;	call strcpy 
18f6			;	ld a, 0 
18f6			;	ld (hl), a 
18f6			;	inc hl 
18f6			;	ld (hl), a 
18f6			;	inc hl 
18f6			;	ld (hl), a 
18f6			 
18f6				; switch frame buffer to program  
18f6			 
18f6 21 16 ed				ld hl, display_fb1 
18f9 22 d2 eb				ld (display_fb_active), hl 
18fc			 
18fc			;	nop 
18fc				STACKFRAME ON $fbfe $8f9f 
18fc				if DEBUG_STACK_IMB 
18fc					if ON 
18fc						exx 
18fc						ld de, $fbfe 
18fc						ld a, d 
18fc						ld hl, curframe 
18fc						call hexout 
18fc						ld a, e 
18fc						ld hl, curframe+2 
18fc						call hexout 
18fc						ld hl, $fbfe 
18fc						push hl 
18fc						ld hl, $8f9f 
18fc						push hl 
18fc						exx 
18fc					endif 
18fc				endif 
18fc			endm 
# End of macro STACKFRAME
18fc				; first time into the parser so pass over the current scratch pad 
18fc 21 26 e6			ld hl,os_cli_cmd 
18ff				; tokenise the entered statement(s) in HL 
18ff cd db 1f			call forthparse 
1902			        ; exec forth statements in top of return stack 
1902 cd 1b 20			call forthexec 
1905				;call forthexec_cleanup 
1905			;	call parsenext 
1905			 
1905				STACKFRAMECHK ON $fbfe $8f9f 
1905				if DEBUG_STACK_IMB 
1905					if ON 
1905						exx 
1905						ld hl, $8f9f 
1905						pop de   ; $8f9f 
1905						call cmp16 
1905						jr nz, .spnosame 
1905						ld hl, $fbfe 
1905						pop de   ; $fbfe 
1905						call cmp16 
1905						jr z, .spfrsame 
1905						.spnosame: call showsperror 
1905						.spfrsame: nop 
1905						exx 
1905					endif 
1905				endif 
1905			endm 
# End of macro STACKFRAMECHK
1905				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1905			 
1905 3e 78			ld a, display_row_4 
1907 11 39 19			ld de, endprog 
190a			 
190a cd a3 0b			call update_display		 
190d			 
190d cd 97 1b			call next_page_prompt 
1910			 
1910				; switch frame buffer to cli 
1910			 
1910 21 b7 ed				ld hl, display_fb0 
1913 22 d2 eb				ld (display_fb_active), hl 
1916			 
1916			 
1916 cd 80 0b		        call clear_display 
1919 cd a3 0b			call update_display		 
191c			 
191c 21 26 e6			ld hl, os_cli_cmd 
191f			 
191f 3e 00			ld a, 0		 ; init cli input 
1921 77				ld (hl), a 
1922			 
1922				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1922			 
1922				; now on last line 
1922			 
1922				; TODO scroll screen up 
1922			 
1922				; TODO instead just clear screen and place at top of screen 
1922			 
1922			;	ld a, 0 
1922			;	ld (f_cursor_ptr),a 
1922			 
1922				;call clear_display 
1922				;call update_display 
1922			 
1922				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1922 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1924 c3 df 18			jp cli 
1927			 
1927 .. 00		freeram: db "Free bytes: $",0 
1935 ..			asc: db "1A2F" 
1939 .. 00		endprog: db "End prog...",0 
1945			 
1945			testenter2:   
1945 21 31 e3			ld hl,scratch+50 
1948 22 22 e6			ld (os_cur_ptr),hl 
194b c3 df 18			jp cli 
194e			 
194e			testenter:  
194e			 
194e 21 35 19			ld hl,asc 
1951			;	ld a,(hl) 
1951			;	call nibble2val 
1951 cd 04 11			call get_byte 
1954			 
1954			 
1954			;	ld a,(hl) 
1954			;	call atohex 
1954			 
1954			;	call fourehexhl 
1954 32 31 e3			ld (scratch+50),a 
1957			 
1957			 
1957			 
1957 21 37 19			ld hl,asc+2 
195a			;	ld a, (hl) 
195a			;	call nibble2val 
195a cd 04 11			call get_byte 
195d			 
195d			;	call fourehexhl 
195d 32 33 e3			ld (scratch+52),a 
1960				 
1960 21 31 e3			ld hl,scratch+50 
1963 22 22 e6			ld (os_cur_ptr),hl 
1966 c3 df 18			jp cli 
1969			 
1969			enter:	 
1969 3a 03 e3			ld a,(scratch+4) 
196c fe 00			cp 0 
196e 28 0c			jr z, .entercont 
1970				; no, not a null term line so has an address to work out.... 
1970			 
1970 21 01 e3			ld hl,scratch+2 
1973 cd 64 11			call get_word_hl 
1976			 
1976 22 22 e6			ld (os_cur_ptr),hl	 
1979 c3 df 18			jp cli 
197c			 
197c			 
197c			.entercont:  
197c			 
197c 21 01 e3			ld hl, scratch+2 
197f cd 04 11			call get_byte 
1982			 
1982 2a 22 e6		   	ld hl,(os_cur_ptr) 
1985 77					ld (hl),a 
1986 23					inc hl 
1987 22 22 e6				ld (os_cur_ptr),hl 
198a				 
198a			; get byte  
198a			 
198a			 
198a c3 df 18			jp cli 
198d			 
198d			 
198d			; basic monitor support 
198d			 
198d			monitor: 
198d				;  
198d cd 80 0b			call clear_display 
1990 3e 00			ld a, 0 
1992 11 da 19			ld de, .monprompt 
1995 cd 93 0b			call str_at_display 
1998 cd a3 0b			call update_display 
199b			 
199b				; get a monitor command 
199b			 
199b 0e 00			ld c, 0     ; entry at top left 
199d 16 64			ld d, 100   ; max buffer size 
199f 1e 0f			ld e, 15    ; input scroll area 
19a1 3e 00			ld a, 0     ; init string 
19a3 21 fd e4			ld hl, os_input 
19a6 77				ld (hl), a 
19a7 23				inc hl 
19a8 77				ld (hl), a 
19a9 21 fd e4			ld hl, os_input 
19ac 3e 01			ld a, 1     ; init string 
19ae cd da 0d			call input_str 
19b1			 
19b1 cd 80 0b		        call clear_display 
19b4 cd a3 0b			call update_display		 
19b7			 
19b7 3a fd e4			ld a, (os_input) 
19ba cd 02 12			call toUpper 
19bd fe 48		        cp 'H' 
19bf 28 6f		        jr z, .monhelp 
19c1 fe 44			cp 'D'		; dump 
19c3 ca 51 1a			jp z, .mondump	 
19c6 fe 43			cp 'C'		; dump 
19c8 ca 6b 1a			jp z, .moncdump	 
19cb fe 4d			cp 'M'		; dump 
19cd ca dc 19			jp z, .moneditstart 
19d0 fe 55			cp 'U'		; dump 
19d2 28 14			jr z, .monedit	 
19d4 fe 51			cp 'Q'		; dump 
19d6 c8				ret z	 
19d7			 
19d7			 
19d7				; TODO "S" to access symbol by name and not need the address 
19d7				; TODO "F" to find a string in memory 
19d7			 
19d7 c3 8d 19			jp monitor 
19da			 
19da .. 00		.monprompt: db ">", 0 
19dc			 
19dc			.moneditstart: 
19dc				; get starting address 
19dc			 
19dc 21 ff e4			ld hl,os_input+2 
19df cd 64 11			call get_word_hl 
19e2			 
19e2 22 22 e6			ld (os_cur_ptr),hl	 
19e5			 
19e5 c3 8d 19			jp monitor 
19e8			 
19e8			.monedit: 
19e8				; get byte to load 
19e8			 
19e8 21 ff e4			ld hl,os_input+2 
19eb cd 04 11			call get_byte 
19ee			 
19ee				; get address to update 
19ee 2a 22 e6			ld hl, (os_cur_ptr) 
19f1			 
19f1				; update byte 
19f1			 
19f1 77				ld (hl), a 
19f2			 
19f2				; move to next address and save it 
19f2			 
19f2 23				inc hl 
19f3 22 22 e6			ld (os_cur_ptr),hl	 
19f6			 
19f6 c3 8d 19			jp monitor 
19f9			 
19f9			 
19f9 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1a0d .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1a29 .. 00		.monhelptext3:  db "Q-Quit",0 
1a30			        
1a30			.monhelp: 
1a30 3e 00			ld a, display_row_1 
1a32 11 f9 19		        ld de, .monhelptext1 
1a35			 
1a35 cd 93 0b			call str_at_display 
1a38 3e 28			ld a, display_row_2 
1a3a 11 0d 1a		        ld de, .monhelptext2 
1a3d					 
1a3d cd 93 0b			call str_at_display 
1a40 3e 50			ld a, display_row_3 
1a42 11 29 1a		        ld de, .monhelptext3 
1a45					 
1a45 cd 93 0b			call str_at_display 
1a48 cd a3 0b			call update_display		 
1a4b			 
1a4b cd 97 1b			call next_page_prompt 
1a4e c3 8d 19			jp monitor 
1a51			 
1a51			.mondump:    
1a51 21 ff e4			ld hl,os_input+2 
1a54 cd 64 11			call get_word_hl 
1a57			 
1a57 22 22 e6			ld (os_cur_ptr),hl	 
1a5a cd 9f 1a			call dumpcont 
1a5d 3e 78			ld a, display_row_4 
1a5f 11 39 19			ld de, endprog 
1a62			 
1a62 cd a3 0b			call update_display		 
1a65			 
1a65 cd 97 1b			call next_page_prompt 
1a68 c3 8d 19			jp monitor 
1a6b			.moncdump: 
1a6b cd 9f 1a			call dumpcont 
1a6e 3e 78			ld a, display_row_4 
1a70 11 39 19			ld de, endprog 
1a73			 
1a73 cd a3 0b			call update_display		 
1a76			 
1a76 cd 97 1b			call next_page_prompt 
1a79 c3 8d 19			jp monitor 
1a7c			 
1a7c			 
1a7c			; TODO symbol access  
1a7c			 
1a7c			.symbols:     ;; A list of symbols that can be called up  
1a7c b7 ed			dw display_fb0 
1a7e .. 00			db "fb0",0  
1a82 84 ea		     	dw store_page 
1a84 .. 00			db "store_page",0 
1a8f			 
1a8f			 
1a8f			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1a8f			 
1a8f 3a 00 e3			ld a,(scratch+1) 
1a92 fe 00			cp 0 
1a94 28 09			jr z, dumpcont 
1a96			 
1a96				; no, not a null term line so has an address to work out.... 
1a96			 
1a96 21 01 e3			ld hl,scratch+2 
1a99 cd 64 11			call get_word_hl 
1a9c			 
1a9c 22 22 e6			ld (os_cur_ptr),hl	 
1a9f			 
1a9f			 
1a9f			 
1a9f			dumpcont: 
1a9f			 
1a9f				; dump bytes at ptr 
1a9f			 
1a9f			 
1a9f 3e 00			ld a, display_row_1 
1aa1 2a d2 eb			ld hl, (display_fb_active) 
1aa4 cd ad 0d			call addatohl 
1aa7 cd cf 1a			call .dumpbyterow 
1aaa			 
1aaa 3e 28			ld a, display_row_2 
1aac 2a d2 eb			ld hl, (display_fb_active) 
1aaf cd ad 0d			call addatohl 
1ab2 cd cf 1a			call .dumpbyterow 
1ab5			 
1ab5			 
1ab5 3e 50			ld a, display_row_3 
1ab7 2a d2 eb			ld hl, (display_fb_active) 
1aba cd ad 0d			call addatohl 
1abd cd cf 1a			call .dumpbyterow 
1ac0			 
1ac0 3e 78			ld a, display_row_4 
1ac2 2a d2 eb			ld hl, (display_fb_active) 
1ac5 cd ad 0d			call addatohl 
1ac8 cd cf 1a			call .dumpbyterow 
1acb			 
1acb cd a3 0b			call update_display 
1ace			;		jp cli 
1ace c9				ret 
1acf			 
1acf			.dumpbyterow: 
1acf			 
1acf				;push af 
1acf			 
1acf e5				push hl 
1ad0			 
1ad0				; calc where to poke the ascii 
1ad0			if display_cols == 20 
1ad0				ld a, 16 
1ad0			else 
1ad0 3e 1f			ld a, 31 
1ad2			endif 
1ad2			 
1ad2 cd ad 0d			call addatohl 
1ad5 22 04 e6			ld (os_word_scratch),hl  		; save pos for later 
1ad8			 
1ad8			 
1ad8			; display decoding address 
1ad8 2a 22 e6		   	ld hl,(os_cur_ptr) 
1adb			 
1adb 7c				ld a,h 
1adc e1				pop hl 
1add e5				push hl 
1ade			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1ade cd ae 10			call hexout 
1ae1 2a 22 e6		   	ld hl,(os_cur_ptr) 
1ae4			 
1ae4 7d				ld a,l 
1ae5 e1				pop hl 
1ae6 23				inc hl 
1ae7 23				inc hl 
1ae8 e5				push hl 
1ae9			;	ld hl, os_word_scratch+2 
1ae9 cd ae 10			call hexout 
1aec e1				pop hl 
1aed 23				inc hl 
1aee 23				inc hl 
1aef				;ld hl, os_word_scratch+4 
1aef 3e 3a			ld a, ':' 
1af1 77				ld (hl),a 
1af2 23				inc hl 
1af3				;ld a, 0 
1af3				;ld (hl),a 
1af3				;ld de, os_word_scratch 
1af3				;pop af 
1af3				;push af 
1af3			;		ld a, display_row_2 
1af3			;		call str_at_display 
1af3			;		call update_display 
1af3			 
1af3			 
1af3			;pop af 
1af3			;	add 5 
1af3			 
1af3			if display_cols == 20 
1af3				ld b, 4 
1af3			else 
1af3 06 08			ld b, 8 
1af5			endif	 
1af5			 
1af5			.dumpbyte: 
1af5 c5				push bc 
1af6 e5				push hl 
1af7			 
1af7			 
1af7 2a 22 e6		   	ld hl,(os_cur_ptr) 
1afa 7e					ld a,(hl) 
1afb			 
1afb					; poke the ascii to display 
1afb 2a 04 e6				ld hl,(os_word_scratch) 
1afe 77					ld (hl),a 
1aff 23					inc hl 
1b00 22 04 e6				ld (os_word_scratch),hl 
1b03			 
1b03					 
1b03			 
1b03			 
1b03 e1					pop hl 
1b04 e5					push hl 
1b05			 
1b05 cd ae 10				call hexout 
1b08			 
1b08					 
1b08 2a 22 e6		   	ld hl,(os_cur_ptr) 
1b0b 23				inc hl 
1b0c 22 22 e6		   	ld (os_cur_ptr),hl 
1b0f			 
1b0f e1					pop hl 
1b10 23					inc hl 
1b11 23					inc hl 
1b12 23					inc hl 
1b13			 
1b13			 
1b13			 
1b13					;ld a,0 
1b13					;ld (os_word_scratch+2),a 
1b13					;pop af 
1b13					;push af 
1b13			 
1b13					;ld de, os_word_scratch 
1b13					;call str_at_display 
1b13			;		call update_display 
1b13			;		pop af 
1b13 c1					pop bc 
1b14 c6 03				add 3 
1b16 10 dd			djnz .dumpbyte 
1b18			 
1b18				 
1b18			 
1b18 c9				ret 
1b19			 
1b19			jump:	 
1b19			 
1b19 21 01 e3			ld hl,scratch+2 
1b1c cd 64 11			call get_word_hl 
1b1f				;ld hl,(scratch+2) 
1b1f				;call fourehexhl 
1b1f			 
1b1f 22 22 e6			ld (os_cur_ptr),hl	 
1b22			 
1b22 e9				jp (hl) 
1b23			 
1b23			 
1b23			 
1b23			; TODO implement a basic monitor mode to start with 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			 
1b23			; testing and demo code during development 
1b23			 
1b23			 
1b23 .. 00		str1: db "Enter some text...",0 
1b36 .. 00		clear: db "                    ",0 
1b4b			 
1b4b			demo: 
1b4b			 
1b4b			 
1b4b			 
1b4b			;	call update_display 
1b4b			 
1b4b				; init scratch input area for testing 
1b4b 21 ff e2			ld hl, scratch	 
1b4e 3e 00			ld a,0 
1b50 77				ld (hl),a 
1b51			 
1b51			 
1b51 3e 28		            LD   A, display_row_2 
1b53			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b53 11 23 1b		            LD   DE, str1 
1b56 cd 93 0b			call str_at_display 
1b59			 
1b59			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b59			cloop:	 
1b59 3e 50		            LD   A, display_row_3 
1b5b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b5b 11 36 1b		            LD   DE, clear 
1b5e			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1b5e cd 93 0b				call str_at_display 
1b61 3e 78			ld a, display_row_4 
1b63 11 93 1b			ld de, prompt 
1b66			 
1b66 cd 93 0b				call str_at_display 
1b69 cd a3 0b			call update_display 
1b6c			 
1b6c 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1b6e 16 0a			ld d, 10 
1b70 21 ff e2			ld hl, scratch	 
1b73 cd da 0d			call input_str 
1b76			 
1b76			;	call clear_display 
1b76			;'	call update_display 
1b76			 
1b76 3e 00		            LD   A, display_row_1 
1b78			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b78 11 36 1b		            LD   DE, clear 
1b7b cd 93 0b				call str_at_display 
1b7e			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b7e 3e 00		            LD   A, display_row_1 
1b80			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b80 11 ff e2		            LD   DE, scratch 
1b83			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b83 cd 93 0b				call str_at_display 
1b86 cd a3 0b			call update_display 
1b89			 
1b89 3e 00				ld a,0 
1b8b 21 ff e2			ld hl, scratch 
1b8e 77				ld (hl),a 
1b8f			 
1b8f 00				nop 
1b90 c3 59 1b			jp cloop 
1b93			 
1b93			 
1b93			 
1b93			; OS Prompt 
1b93			 
1b93 .. 00		prompt: db ">",0 
1b95 .. 00		endprg: db "?",0 
1b97			 
1b97			 
1b97			; handy next page prompt 
1b97			next_page_prompt: 
1b97 e5				push hl 
1b98 d5				push de 
1b99 f5				push af 
1b9a c5				push bc 
1b9b			 
1b9b 3e 9f			ld a,display_row_4 + display_cols - 1 
1b9d 11 95 1b		        ld de, endprg 
1ba0 cd 93 0b			call str_at_display 
1ba3 cd a3 0b			call update_display 
1ba6 cd f2 5e			call cin_wait 
1ba9 c1				pop bc 
1baa f1				pop af 
1bab d1				pop de 
1bac e1				pop hl 
1bad			 
1bad			 
1bad c9				ret 
1bae			 
1bae			 
1bae			; forth parser 
1bae			 
1bae			; My forth kernel 
1bae			include "forth_kernel.asm" 
1bae			; 
1bae			; kernel to the forth OS 
1bae			 
1bae			DS_TYPE_STR: equ 1     ; string type 
1bae			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1bae			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1bae			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1bae			 
1bae			FORTH_PARSEV1: equ 0 
1bae			FORTH_PARSEV2: equ 0 
1bae			FORTH_PARSEV3: equ 0 
1bae			FORTH_PARSEV4: equ 0 
1bae			FORTH_PARSEV5: equ 1 
1bae			 
1bae			;if FORTH_PARSEV5 
1bae			;	FORTH_END_BUFFER: equ 0 
1bae			;else 
1bae			FORTH_END_BUFFER: equ 127 
1bae			;endif 
1bae			 
1bae			FORTH_TRUE: equ 1 
1bae			FORTH_FALSE: equ 0 
1bae			 
1bae			if FORTH_PARSEV4 
1bae			include "forth_stackops.asm" 
1bae			endif 
1bae			 
1bae			if FORTH_PARSEV5 
1bae			include "forth_stackopsv5.asm" 
1bae			 
1bae			; Stack operations for v5 parser on wards 
1bae			; * DATA stack 
1bae			; * LOOP stack 
1bae			; * RETURN stack 
1bae			 
1bae			 
1bae			 
1bae			FORTH_CHK_DSP_UNDER: macro 
1bae				push hl 
1bae				push de 
1bae				ld hl,(cli_data_sp) 
1bae				ld de, cli_data_stack 
1bae				call cmp16 
1bae				jp c, fault_dsp_under 
1bae				pop de 
1bae				pop hl 
1bae				endm 
1bae			 
1bae			 
1bae			FORTH_CHK_RSP_UNDER: macro 
1bae				push hl 
1bae				push de 
1bae				ld hl,(cli_ret_sp) 
1bae				ld de, cli_ret_stack 
1bae				call cmp16 
1bae				jp c, fault_rsp_under 
1bae				pop de 
1bae				pop hl 
1bae				endm 
1bae			 
1bae			FORTH_CHK_LOOP_UNDER: macro 
1bae				push hl 
1bae				push de 
1bae				ld hl,(cli_loop_sp) 
1bae				ld de, cli_loop_stack 
1bae				call cmp16 
1bae				jp c, fault_loop_under 
1bae				pop de 
1bae				pop hl 
1bae				endm 
1bae			 
1bae			FORTH_ERR_TOS_NOTSTR: macro 
1bae				; TOSO might need more for checks when used 
1bae				push af 
1bae				ld a,(hl) 
1bae				cp DS_TYPE_STR 
1bae				jp nz, type_faultn   
1bae				pop af 
1bae				endm 
1bae			 
1bae			FORTH_ERR_TOS_NOTNUM: macro 
1bae				push af 
1bae				ld a,(hl) 
1bae				cp DS_TYPE_INUM 
1bae				jp nz, type_faultn   
1bae				pop af 
1bae				endm 
1bae			 
1bae			 
1bae			; increase data stack pointer and save hl to it 
1bae				 
1bae			FORTH_DSP_NEXT: macro 
1bae				call macro_forth_dsp_next 
1bae				endm 
1bae			 
1bae			 
1bae			macro_forth_dsp_next: 
1bae				if DEBUG_FORTH_STACK_GUARD 
1bae cd 0a 5c				call check_stacks 
1bb1				endif 
1bb1 e5				push hl 
1bb2 d5				push de 
1bb3 eb				ex de,hl 
1bb4 2a 2c ea			ld hl,(cli_data_sp) 
1bb7 23				inc hl 
1bb8 23				inc hl 
1bb9			 
1bb9			; PARSEV5 
1bb9 23				inc hl 
1bba 22 2c ea			ld (cli_data_sp),hl 
1bbd 73				ld (hl), e 
1bbe 23				inc hl 
1bbf 72				ld (hl), d 
1bc0 d1				pop de 
1bc1 e1				pop hl 
1bc2				if DEBUG_FORTH_STACK_GUARD 
1bc2 cd 0a 5c				call check_stacks 
1bc5				endif 
1bc5 c9				ret 
1bc6			 
1bc6			 
1bc6			; increase ret stack pointer and save hl to it 
1bc6				 
1bc6			FORTH_RSP_NEXT: macro 
1bc6				call macro_forth_rsp_next 
1bc6				endm 
1bc6			 
1bc6			macro_forth_rsp_next: 
1bc6				if DEBUG_FORTH_STACK_GUARD 
1bc6 cd 0a 5c				call check_stacks 
1bc9				endif 
1bc9 e5				push hl 
1bca d5				push de 
1bcb eb				ex de,hl 
1bcc 2a 30 ea			ld hl,(cli_ret_sp) 
1bcf 23				inc hl 
1bd0 23				inc hl 
1bd1 22 30 ea			ld (cli_ret_sp),hl 
1bd4 73				ld (hl), e 
1bd5 23				inc hl 
1bd6 72				ld (hl), d 
1bd7 d1				pop de 
1bd8 e1				pop hl 
1bd9				if DEBUG_FORTH_STACK_GUARD 
1bd9 cd 0a 5c				call check_stacks 
1bdc				endif 
1bdc c9				ret 
1bdd			 
1bdd			; get current ret stack pointer and save to hl  
1bdd				 
1bdd			FORTH_RSP_TOS: macro 
1bdd				call macro_forth_rsp_tos 
1bdd				endm 
1bdd			 
1bdd			macro_forth_rsp_tos: 
1bdd				;push de 
1bdd 2a 30 ea			ld hl,(cli_ret_sp) 
1be0 cd 18 1c			call loadhlptrtohl 
1be3				;ld e, (hl) 
1be3				;inc hl 
1be3				;ld d, (hl) 
1be3				;ex de, hl 
1be3					if DEBUG_FORTH_WORDS 
1be3			;			DMARK "RST" 
1be3						CALLMONITOR 
1be3 cd ae 15			call break_point_state  
1be6				endm  
# End of macro CALLMONITOR
1be6					endif 
1be6				;pop de 
1be6 c9				ret 
1be7			 
1be7			; pop ret stack pointer 
1be7				 
1be7			FORTH_RSP_POP: macro 
1be7				call macro_forth_rsp_pop 
1be7				endm 
1be7			 
1be7			 
1be7			macro_forth_rsp_pop: 
1be7				if DEBUG_FORTH_STACK_GUARD 
1be7			;		DMARK "RPP" 
1be7 cd 0a 5c				call check_stacks 
1bea					FORTH_CHK_RSP_UNDER 
1bea e5				push hl 
1beb d5				push de 
1bec 2a 30 ea			ld hl,(cli_ret_sp) 
1bef 11 ea e9			ld de, cli_ret_stack 
1bf2 cd cb 0d			call cmp16 
1bf5 da 1e 5d			jp c, fault_rsp_under 
1bf8 d1				pop de 
1bf9 e1				pop hl 
1bfa				endm 
# End of macro FORTH_CHK_RSP_UNDER
1bfa				endif 
1bfa e5				push hl 
1bfb 2a 30 ea			ld hl,(cli_ret_sp) 
1bfe			 
1bfe			 
1bfe				if FORTH_ENABLE_FREE 
1bfe			 
1bfe					; get pointer 
1bfe			 
1bfe					push de 
1bfe					push hl 
1bfe			 
1bfe					ld e, (hl) 
1bfe					inc hl 
1bfe					ld d, (hl) 
1bfe			 
1bfe					ex de, hl 
1bfe					call free 
1bfe			 
1bfe					pop hl 
1bfe					pop de 
1bfe			 
1bfe			 
1bfe				endif 
1bfe			 
1bfe			 
1bfe 2b				dec hl 
1bff 2b				dec hl 
1c00 22 30 ea			ld (cli_ret_sp), hl 
1c03				; do stack underflow checks 
1c03 e1				pop hl 
1c04				if DEBUG_FORTH_STACK_GUARD 
1c04 cd 0a 5c				call check_stacks 
1c07					FORTH_CHK_RSP_UNDER 
1c07 e5				push hl 
1c08 d5				push de 
1c09 2a 30 ea			ld hl,(cli_ret_sp) 
1c0c 11 ea e9			ld de, cli_ret_stack 
1c0f cd cb 0d			call cmp16 
1c12 da 1e 5d			jp c, fault_rsp_under 
1c15 d1				pop de 
1c16 e1				pop hl 
1c17				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c17				endif 
1c17 c9				ret 
1c18			 
1c18			 
1c18			 
1c18			; routine to load word pointed to by hl into hl 
1c18			 
1c18			loadhlptrtohl: 
1c18			 
1c18 d5				push de 
1c19 5e				ld e, (hl) 
1c1a 23				inc hl 
1c1b 56				ld d, (hl) 
1c1c eb				ex de, hl 
1c1d d1				pop de 
1c1e			 
1c1e c9				ret 
1c1f			 
1c1f			 
1c1f			 
1c1f			 
1c1f			 
1c1f			; push a number held in HL onto the data stack 
1c1f			; entry point for pushing a value when already in hl used in function above 
1c1f			 
1c1f			forth_push_numhl: 
1c1f			 
1c1f e5				push hl    ; save value to push 
1c20			 
1c20			if DEBUG_FORTH_PUSH 
1c20				; see if disabled 
1c20			 
1c20			 
1c20 f5				push af 
1c21 3a f0 e2			ld a, (os_view_disable) 
1c24 fe 2a			cp '*' 
1c26 28 34			jr z, .pskip2 
1c28 e5				push hl 
1c29 e5			push hl 
1c2a cd 80 0b			call clear_display 
1c2d e1			pop hl 
1c2e 7c				ld a,h 
1c2f 21 04 e6			ld hl, os_word_scratch 
1c32 cd ae 10			call hexout 
1c35 e1				pop hl 
1c36 7d				ld a,l 
1c37 21 06 e6			ld hl, os_word_scratch+2 
1c3a cd ae 10			call hexout 
1c3d			 
1c3d 21 08 e6			ld hl, os_word_scratch+4 
1c40 3e 00			ld a,0 
1c42 77				ld (hl),a 
1c43 11 04 e6			ld de,os_word_scratch 
1c46 3e 28				ld a, display_row_2 
1c48 cd 93 0b				call str_at_display 
1c4b 11 d7 47			ld de, .push_num 
1c4e 3e 00			ld a, display_row_1 
1c50			 
1c50 cd 93 0b				call str_at_display 
1c53			 
1c53			 
1c53 cd a3 0b			call update_display 
1c56 cd f2 0a			call delay1s 
1c59 cd f2 0a			call delay1s 
1c5c			.pskip2:  
1c5c			 
1c5c f1				pop af 
1c5d			endif	 
1c5d			 
1c5d			 
1c5d				FORTH_DSP_NEXT 
1c5d cd ae 1b			call macro_forth_dsp_next 
1c60				endm 
# End of macro FORTH_DSP_NEXT
1c60			 
1c60 2a 2c ea			ld hl, (cli_data_sp) 
1c63			 
1c63				; save item type 
1c63 3e 02			ld a,  DS_TYPE_INUM 
1c65 77				ld (hl), a 
1c66 23				inc hl 
1c67			 
1c67				; get word off stack 
1c67 d1				pop de 
1c68 7b				ld a,e 
1c69 77				ld (hl), a 
1c6a 23				inc hl 
1c6b 7a				ld a,d 
1c6c 77				ld (hl), a 
1c6d			 
1c6d			if DEBUG_FORTH_PUSH 
1c6d 2b				dec hl 
1c6e 2b				dec hl 
1c6f 2b				dec hl 
1c70						DMARK "PH5" 
1c70 f5				push af  
1c71 3a 85 1c			ld a, (.dmark)  
1c74 32 71 ee			ld (debug_mark),a  
1c77 3a 86 1c			ld a, (.dmark+1)  
1c7a 32 72 ee			ld (debug_mark+1),a  
1c7d 3a 87 1c			ld a, (.dmark+2)  
1c80 32 73 ee			ld (debug_mark+2),a  
1c83 18 03			jr .pastdmark  
1c85 ..			.dmark: db "PH5"  
1c88 f1			.pastdmark: pop af  
1c89			endm  
# End of macro DMARK
1c89				CALLMONITOR 
1c89 cd ae 15			call break_point_state  
1c8c				endm  
# End of macro CALLMONITOR
1c8c			endif	 
1c8c			 
1c8c c9				ret 
1c8d			 
1c8d			 
1c8d			; Push a string to stack pointed to by hl 
1c8d			 
1c8d			forth_push_str: 
1c8d			 
1c8d			if DEBUG_FORTH_PUSH 
1c8d						DMARK "PSQ" 
1c8d f5				push af  
1c8e 3a a2 1c			ld a, (.dmark)  
1c91 32 71 ee			ld (debug_mark),a  
1c94 3a a3 1c			ld a, (.dmark+1)  
1c97 32 72 ee			ld (debug_mark+1),a  
1c9a 3a a4 1c			ld a, (.dmark+2)  
1c9d 32 73 ee			ld (debug_mark+2),a  
1ca0 18 03			jr .pastdmark  
1ca2 ..			.dmark: db "PSQ"  
1ca5 f1			.pastdmark: pop af  
1ca6			endm  
# End of macro DMARK
1ca6				CALLMONITOR 
1ca6 cd ae 15			call break_point_state  
1ca9				endm  
# End of macro CALLMONITOR
1ca9			endif	 
1ca9			    
1ca9 e5				push hl 
1caa e5				push hl 
1cab			 
1cab			;	ld a, 0   ; find end of string 
1cab cd 0b 12			call strlenz 
1cae			if DEBUG_FORTH_PUSH 
1cae						DMARK "PQ2" 
1cae f5				push af  
1caf 3a c3 1c			ld a, (.dmark)  
1cb2 32 71 ee			ld (debug_mark),a  
1cb5 3a c4 1c			ld a, (.dmark+1)  
1cb8 32 72 ee			ld (debug_mark+1),a  
1cbb 3a c5 1c			ld a, (.dmark+2)  
1cbe 32 73 ee			ld (debug_mark+2),a  
1cc1 18 03			jr .pastdmark  
1cc3 ..			.dmark: db "PQ2"  
1cc6 f1			.pastdmark: pop af  
1cc7			endm  
# End of macro DMARK
1cc7				CALLMONITOR 
1cc7 cd ae 15			call break_point_state  
1cca				endm  
# End of macro CALLMONITOR
1cca			endif	 
1cca eb				ex de, hl 
1ccb e1				pop hl   ; get ptr to start of string 
1ccc			if DEBUG_FORTH_PUSH 
1ccc						DMARK "PQ3" 
1ccc f5				push af  
1ccd 3a e1 1c			ld a, (.dmark)  
1cd0 32 71 ee			ld (debug_mark),a  
1cd3 3a e2 1c			ld a, (.dmark+1)  
1cd6 32 72 ee			ld (debug_mark+1),a  
1cd9 3a e3 1c			ld a, (.dmark+2)  
1cdc 32 73 ee			ld (debug_mark+2),a  
1cdf 18 03			jr .pastdmark  
1ce1 ..			.dmark: db "PQ3"  
1ce4 f1			.pastdmark: pop af  
1ce5			endm  
# End of macro DMARK
1ce5				CALLMONITOR 
1ce5 cd ae 15			call break_point_state  
1ce8				endm  
# End of macro CALLMONITOR
1ce8			endif	 
1ce8 19				add hl,de 
1ce9			if DEBUG_FORTH_PUSH 
1ce9						DMARK "PQE" 
1ce9 f5				push af  
1cea 3a fe 1c			ld a, (.dmark)  
1ced 32 71 ee			ld (debug_mark),a  
1cf0 3a ff 1c			ld a, (.dmark+1)  
1cf3 32 72 ee			ld (debug_mark+1),a  
1cf6 3a 00 1d			ld a, (.dmark+2)  
1cf9 32 73 ee			ld (debug_mark+2),a  
1cfc 18 03			jr .pastdmark  
1cfe ..			.dmark: db "PQE"  
1d01 f1			.pastdmark: pop af  
1d02			endm  
# End of macro DMARK
1d02				CALLMONITOR 
1d02 cd ae 15			call break_point_state  
1d05				endm  
# End of macro CALLMONITOR
1d05			endif	 
1d05			 
1d05 2b				dec hl    ; see if there is an optional trailing double quote 
1d06 7e				ld a,(hl) 
1d07 fe 22			cp '"' 
1d09 20 03			jr nz, .strnoq 
1d0b 3e 00			ld a, 0      ; get rid of double quote 
1d0d 77				ld (hl), a 
1d0e 23			.strnoq: inc hl 
1d0f			 
1d0f 3e 00			ld a, 0 
1d11 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1d12			 
1d12 13				inc de ; add one for the type string 
1d13 13				inc de ; add one for null term??? 
1d14			 
1d14				; tos is get string pointer again 
1d14				; de contains space to allocate 
1d14				 
1d14 d5				push de 
1d15			 
1d15 eb				ex de, hl 
1d16			 
1d16				;push af 
1d16			 
1d16			if DEBUG_FORTH_PUSH 
1d16						DMARK "PHm" 
1d16 f5				push af  
1d17 3a 2b 1d			ld a, (.dmark)  
1d1a 32 71 ee			ld (debug_mark),a  
1d1d 3a 2c 1d			ld a, (.dmark+1)  
1d20 32 72 ee			ld (debug_mark+1),a  
1d23 3a 2d 1d			ld a, (.dmark+2)  
1d26 32 73 ee			ld (debug_mark+2),a  
1d29 18 03			jr .pastdmark  
1d2b ..			.dmark: db "PHm"  
1d2e f1			.pastdmark: pop af  
1d2f			endm  
# End of macro DMARK
1d2f				CALLMONITOR 
1d2f cd ae 15			call break_point_state  
1d32				endm  
# End of macro CALLMONITOR
1d32			endif	 
1d32 cd 74 12			call malloc	; on ret hl now contains allocated memory 
1d35				if DEBUG_FORTH_MALLOC_GUARD 
1d35 cc 2f 48				call z,malloc_error 
1d38				endif 
1d38			 
1d38				 
1d38 c1				pop bc    ; get length 
1d39 d1				pop de   ;  get string start    
1d3a			 
1d3a				; hl has destination from malloc 
1d3a			 
1d3a eb				ex de, hl    ; prep for ldir 
1d3b			 
1d3b d5				push de   ; save malloc area for DSP later 
1d3c				;push hl   ; save malloc area for DSP later 
1d3c			 
1d3c			if DEBUG_FORTH_PUSH 
1d3c						DMARK "PHc" 
1d3c f5				push af  
1d3d 3a 51 1d			ld a, (.dmark)  
1d40 32 71 ee			ld (debug_mark),a  
1d43 3a 52 1d			ld a, (.dmark+1)  
1d46 32 72 ee			ld (debug_mark+1),a  
1d49 3a 53 1d			ld a, (.dmark+2)  
1d4c 32 73 ee			ld (debug_mark+2),a  
1d4f 18 03			jr .pastdmark  
1d51 ..			.dmark: db "PHc"  
1d54 f1			.pastdmark: pop af  
1d55			endm  
# End of macro DMARK
1d55				CALLMONITOR 
1d55 cd ae 15			call break_point_state  
1d58				endm  
# End of macro CALLMONITOR
1d58			endif	 
1d58			 
1d58			 
1d58 ed b0			ldir 
1d5a			 
1d5a			 
1d5a				; push malloc to data stack     macro?????  
1d5a			 
1d5a				FORTH_DSP_NEXT 
1d5a cd ae 1b			call macro_forth_dsp_next 
1d5d				endm 
# End of macro FORTH_DSP_NEXT
1d5d			 
1d5d				; save value and type 
1d5d			 
1d5d 2a 2c ea			ld hl, (cli_data_sp) 
1d60			 
1d60				; save item type 
1d60 3e 01			ld a,  DS_TYPE_STR 
1d62 77				ld (hl), a 
1d63 23				inc hl 
1d64			 
1d64				; get malloc word off stack 
1d64 d1				pop de 
1d65 73				ld (hl), e 
1d66 23				inc hl 
1d67 72				ld (hl), d 
1d68			 
1d68			 
1d68			 
1d68			if DEBUG_FORTH_PUSH 
1d68 2a 2c ea			ld hl, (cli_data_sp) 
1d6b						DMARK "PHS" 
1d6b f5				push af  
1d6c 3a 80 1d			ld a, (.dmark)  
1d6f 32 71 ee			ld (debug_mark),a  
1d72 3a 81 1d			ld a, (.dmark+1)  
1d75 32 72 ee			ld (debug_mark+1),a  
1d78 3a 82 1d			ld a, (.dmark+2)  
1d7b 32 73 ee			ld (debug_mark+2),a  
1d7e 18 03			jr .pastdmark  
1d80 ..			.dmark: db "PHS"  
1d83 f1			.pastdmark: pop af  
1d84			endm  
# End of macro DMARK
1d84				CALLMONITOR 
1d84 cd ae 15			call break_point_state  
1d87				endm  
# End of macro CALLMONITOR
1d87			;	ex de,hl 
1d87			endif	 
1d87				; in case of spaces, skip the ptr past the copied string 
1d87				;pop af 
1d87				;ld (cli_origptr),hl 
1d87			 
1d87 c9				ret 
1d88			 
1d88			 
1d88			 
1d88			; TODO ascii push input onto stack given hl to start of input 
1d88			 
1d88			; identify type 
1d88			; if starts with a " then a string 
1d88			; otherwise it is a number 
1d88			;  
1d88			; if a string 
1d88			;     scan for ending " to get length of string to malloc for + 1 
1d88			;     malloc 
1d88			;     put pointer to string on stack first byte flags as string 
1d88			; 
1d88			; else a number 
1d88			;    look for number format identifier 
1d88			;    $xx hex 
1d88			;    %xxxxx bin 
1d88			;    xxxxx decimal 
1d88			;    convert number to 16bit word.  
1d88			;    malloc word + 1 with flag to identiy as num 
1d88			;    put pointer to number on stack 
1d88			;   
1d88			;  
1d88			  
1d88			forth_apush: 
1d88				; kernel push 
1d88			 
1d88			if DEBUG_FORTH_PUSH 
1d88						DMARK "PSH" 
1d88 f5				push af  
1d89 3a 9d 1d			ld a, (.dmark)  
1d8c 32 71 ee			ld (debug_mark),a  
1d8f 3a 9e 1d			ld a, (.dmark+1)  
1d92 32 72 ee			ld (debug_mark+1),a  
1d95 3a 9f 1d			ld a, (.dmark+2)  
1d98 32 73 ee			ld (debug_mark+2),a  
1d9b 18 03			jr .pastdmark  
1d9d ..			.dmark: db "PSH"  
1da0 f1			.pastdmark: pop af  
1da1			endm  
# End of macro DMARK
1da1				CALLMONITOR 
1da1 cd ae 15			call break_point_state  
1da4				endm  
# End of macro CALLMONITOR
1da4			endif	 
1da4				; identify input type 
1da4			 
1da4 7e				ld a,(hl) 
1da5 fe 22			cp '"' 
1da7 28 0a			jr z, .fapstr 
1da9 fe 24			cp '$' 
1dab ca d3 1d			jp z, .faphex 
1dae fe 25			cp '%' 
1db0 ca bb 1d			jp z, .fapbin 
1db3			;	cp 'b' 
1db3			;	jp z, .fabin 
1db3				; else decimal 
1db3			 
1db3				; TODO do decimal conversion 
1db3				; decimal is stored as a 16bit word 
1db3			 
1db3				; by default everything is a string if type is not detected 
1db3			.fapstr: ; 
1db3 fe 22			cp '"' 
1db5 20 01			jr nz, .strnoqu 
1db7 23				inc hl 
1db8			.strnoqu: 
1db8 c3 8d 1c			jp forth_push_str 
1dbb			 
1dbb			 
1dbb			 
1dbb			.fapbin:    ; push a binary string.  
1dbb 11 00 00			ld de, 0   ; hold a 16bit value 
1dbe			 
1dbe 23			.fapbinshift:	inc hl  
1dbf 7e				ld a,(hl) 
1dc0 fe 00			cp 0     ; done scanning  
1dc2 28 0b			jr z, .fapbdone  	; got it in HL so push  
1dc4			 
1dc4				; left shift de 
1dc4 eb				ex de, hl	 
1dc5 29				add hl, hl 
1dc6			 
1dc6				; is 1 
1dc6 fe 31			cp '1' 
1dc8 20 02			jr nz, .binzero 
1dca cb 4d			bit 1, l 
1dcc			.binzero: 
1dcc eb				ex de, hl	 ; save current de 
1dcd 18 ef			jr .fapbinshift 
1dcf			 
1dcf			.fapbdone: 
1dcf eb				ex de, hl 
1dd0 c3 1f 1c			jp forth_push_numhl 
1dd3			 
1dd3			 
1dd3			.faphex:   ; hex is always stored as a 16bit word 
1dd3				; skip number prefix 
1dd3 23				inc hl 
1dd4				; turn ascii into number 
1dd4 cd 64 11			call get_word_hl	; ret 16bit word in hl 
1dd7			 
1dd7 c3 1f 1c			jp forth_push_numhl 
1dda			 
1dda 00				 nop 
1ddb			 
1ddb			.fabin:   ; TODO bin conversion 
1ddb			 
1ddb			 
1ddb c9				ret 
1ddc			 
1ddc			 
1ddc			; get either a string ptr or a 16bit word from the data stack 
1ddc			 
1ddc			FORTH_DSP: macro 
1ddc				call macro_forth_dsp 
1ddc				endm 
1ddc			 
1ddc			macro_forth_dsp: 
1ddc				; data stack pointer points to current word on tos 
1ddc			 
1ddc 2a 2c ea			ld hl,(cli_data_sp) 
1ddf			 
1ddf				if DEBUG_FORTH_PUSH 
1ddf						DMARK "DSP" 
1ddf f5				push af  
1de0 3a f4 1d			ld a, (.dmark)  
1de3 32 71 ee			ld (debug_mark),a  
1de6 3a f5 1d			ld a, (.dmark+1)  
1de9 32 72 ee			ld (debug_mark+1),a  
1dec 3a f6 1d			ld a, (.dmark+2)  
1def 32 73 ee			ld (debug_mark+2),a  
1df2 18 03			jr .pastdmark  
1df4 ..			.dmark: db "DSP"  
1df7 f1			.pastdmark: pop af  
1df8			endm  
# End of macro DMARK
1df8			 
1df8 cd 64 48				call display_data_sp 
1dfb				;call break_point_state 
1dfb				;rst 030h 
1dfb				CALLMONITOR 
1dfb cd ae 15			call break_point_state  
1dfe				endm  
# End of macro CALLMONITOR
1dfe				endif 
1dfe			 
1dfe c9				ret 
1dff			 
1dff			; return hl to start of value on stack 
1dff			 
1dff			FORTH_DSP_VALUE: macro 
1dff				call macro_forth_dsp_value 
1dff				endm 
1dff			 
1dff			macro_forth_dsp_value: 
1dff			 
1dff				FORTH_DSP 
1dff cd dc 1d			call macro_forth_dsp 
1e02				endm 
# End of macro FORTH_DSP
1e02			 
1e02 d5				push de 
1e03			 
1e03 23				inc hl ; skip type 
1e04			 
1e04 5e				ld e, (hl) 
1e05 23				inc hl 
1e06 56				ld d, (hl) 
1e07 eb				ex de,hl  
1e08			 
1e08 d1				pop de 
1e09			 
1e09 c9				ret 
1e0a			 
1e0a			; return hl to start of value to second item on stack 
1e0a			 
1e0a			FORTH_DSP_VALUEM1: macro 
1e0a				call macro_forth_dsp_value_m1 
1e0a				endm 
1e0a			 
1e0a			macro_forth_dsp_value_m1: 
1e0a			 
1e0a				FORTH_DSP 
1e0a cd dc 1d			call macro_forth_dsp 
1e0d				endm 
# End of macro FORTH_DSP
1e0d			 
1e0d 2b				dec hl 
1e0e 2b				dec hl 
1e0f			;	dec hl 
1e0f			 
1e0f d5				push de 
1e10			 
1e10 5e				ld e, (hl) 
1e11 23				inc hl 
1e12 56				ld d, (hl) 
1e13 eb				ex de,hl  
1e14			 
1e14 d1				pop de 
1e15			 
1e15 c9				ret 
1e16			 
1e16				 
1e16			 
1e16			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1e16			 
1e16			FORTH_DSP_POP: macro 
1e16				call macro_forth_dsp_pop 
1e16				endm 
1e16			 
1e16			 
1e16			; get the tos data type 
1e16			 
1e16			FORTH_DSP_TYPE:   macro 
1e16			 
1e16				;FORTH_DSP_VALUE 
1e16				FORTH_DSP 
1e16				 
1e16				; hl points to value 
1e16				; check type 
1e16			 
1e16				ld a,(hl) 
1e16			 
1e16				endm 
1e16			 
1e16			; load the tos value into hl 
1e16			 
1e16			 
1e16			FORTH_DSP_VALUEHL:  macro 
1e16				call macro_dsp_valuehl 
1e16				endm 
1e16			 
1e16			 
1e16			 
1e16			macro_dsp_valuehl: 
1e16				FORTH_DSP_VALUE 
1e16 cd ff 1d			call macro_forth_dsp_value 
1e19				endm 
# End of macro FORTH_DSP_VALUE
1e19			 
1e19				;FORTH_ERR_TOS_NOTNUM 
1e19			 
1e19				;inc hl   ; skip type id 
1e19			 
1e19			;	push de 
1e19			; 
1e19			;	ld e, (hl) 
1e19			;	inc hl 
1e19			;	ld d, (hl) 
1e19			;	ex de,hl  
1e19			 
1e19			;	pop de 
1e19			 
1e19				if DEBUG_FORTH_PUSH 
1e19						DMARK "DVL" 
1e19 f5				push af  
1e1a 3a 2e 1e			ld a, (.dmark)  
1e1d 32 71 ee			ld (debug_mark),a  
1e20 3a 2f 1e			ld a, (.dmark+1)  
1e23 32 72 ee			ld (debug_mark+1),a  
1e26 3a 30 1e			ld a, (.dmark+2)  
1e29 32 73 ee			ld (debug_mark+2),a  
1e2c 18 03			jr .pastdmark  
1e2e ..			.dmark: db "DVL"  
1e31 f1			.pastdmark: pop af  
1e32			endm  
# End of macro DMARK
1e32				CALLMONITOR 
1e32 cd ae 15			call break_point_state  
1e35				endm  
# End of macro CALLMONITOR
1e35				endif 
1e35 c9				ret 
1e36			 
1e36			forth_apushstrhl:      
1e36				; push of string requires use of cli_origptr 
1e36				; bodge use 
1e36			 
1e36				; get current cli_origptr, save, update with temp pointer  
1e36 ed 5b 48 ea		ld de, (cli_origptr) 
1e3a 22 48 ea			ld (cli_origptr), hl 
1e3d d5				push de 
1e3e cd 88 1d			call forth_apush 
1e41 d1				pop de 
1e42 ed 53 48 ea		ld (cli_origptr), de 
1e46 c9			        ret	 
1e47			 
1e47			 
1e47			; increase loop stack pointer and save hl to it 
1e47				 
1e47			FORTH_LOOP_NEXT: macro 
1e47				call macro_forth_loop_next 
1e47				;nop 
1e47				endm 
1e47			 
1e47			macro_forth_loop_next: 
1e47				if DEBUG_FORTH_STACK_GUARD 
1e47 cd 0a 5c				call check_stacks 
1e4a				endif 
1e4a e5				push hl 
1e4b d5				push de 
1e4c eb				ex de,hl 
1e4d 2a 2e ea			ld hl,(cli_loop_sp) 
1e50 23				inc hl 
1e51 23				inc hl 
1e52					if DEBUG_FORTH_WORDS 
1e52						DMARK "LNX" 
1e52 f5				push af  
1e53 3a 67 1e			ld a, (.dmark)  
1e56 32 71 ee			ld (debug_mark),a  
1e59 3a 68 1e			ld a, (.dmark+1)  
1e5c 32 72 ee			ld (debug_mark+1),a  
1e5f 3a 69 1e			ld a, (.dmark+2)  
1e62 32 73 ee			ld (debug_mark+2),a  
1e65 18 03			jr .pastdmark  
1e67 ..			.dmark: db "LNX"  
1e6a f1			.pastdmark: pop af  
1e6b			endm  
# End of macro DMARK
1e6b						CALLMONITOR 
1e6b cd ae 15			call break_point_state  
1e6e				endm  
# End of macro CALLMONITOR
1e6e					endif 
1e6e 22 2e ea			ld (cli_loop_sp),hl 
1e71 73				ld (hl), e 
1e72 23				inc hl 
1e73 72				ld (hl), d 
1e74 d1				pop de    ; been reversed so save a swap on restore 
1e75 e1				pop hl 
1e76				if DEBUG_FORTH_STACK_GUARD 
1e76 cd 0a 5c				call check_stacks 
1e79				endif 
1e79 c9				ret 
1e7a			 
1e7a			; get current ret stack pointer and save to hl  
1e7a				 
1e7a			FORTH_LOOP_TOS: macro 
1e7a				call macro_forth_loop_tos 
1e7a				endm 
1e7a			 
1e7a			macro_forth_loop_tos: 
1e7a d5				push de 
1e7b 2a 2e ea			ld hl,(cli_loop_sp) 
1e7e 5e				ld e, (hl) 
1e7f 23				inc hl 
1e80 56				ld d, (hl) 
1e81 eb				ex de, hl 
1e82 d1				pop de 
1e83 c9				ret 
1e84			 
1e84			; pop loop stack pointer 
1e84				 
1e84			FORTH_LOOP_POP: macro 
1e84				call macro_forth_loop_pop 
1e84				endm 
1e84			 
1e84			 
1e84			macro_forth_loop_pop: 
1e84				if DEBUG_FORTH_STACK_GUARD 
1e84					DMARK "LPP" 
1e84 f5				push af  
1e85 3a 99 1e			ld a, (.dmark)  
1e88 32 71 ee			ld (debug_mark),a  
1e8b 3a 9a 1e			ld a, (.dmark+1)  
1e8e 32 72 ee			ld (debug_mark+1),a  
1e91 3a 9b 1e			ld a, (.dmark+2)  
1e94 32 73 ee			ld (debug_mark+2),a  
1e97 18 03			jr .pastdmark  
1e99 ..			.dmark: db "LPP"  
1e9c f1			.pastdmark: pop af  
1e9d			endm  
# End of macro DMARK
1e9d cd 0a 5c				call check_stacks 
1ea0					FORTH_CHK_LOOP_UNDER 
1ea0 e5				push hl 
1ea1 d5				push de 
1ea2 2a 2e ea			ld hl,(cli_loop_sp) 
1ea5 11 68 e9			ld de, cli_loop_stack 
1ea8 cd cb 0d			call cmp16 
1eab da 24 5d			jp c, fault_loop_under 
1eae d1				pop de 
1eaf e1				pop hl 
1eb0				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1eb0				endif 
1eb0 e5				push hl 
1eb1 2a 2e ea			ld hl,(cli_loop_sp) 
1eb4 2b				dec hl 
1eb5 2b				dec hl 
1eb6 22 2e ea			ld (cli_loop_sp), hl 
1eb9				; TODO do stack underflow checks 
1eb9 e1				pop hl 
1eba				if DEBUG_FORTH_STACK_GUARD 
1eba cd 0a 5c				call check_stacks 
1ebd					FORTH_CHK_LOOP_UNDER 
1ebd e5				push hl 
1ebe d5				push de 
1ebf 2a 2e ea			ld hl,(cli_loop_sp) 
1ec2 11 68 e9			ld de, cli_loop_stack 
1ec5 cd cb 0d			call cmp16 
1ec8 da 24 5d			jp c, fault_loop_under 
1ecb d1				pop de 
1ecc e1				pop hl 
1ecd				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ecd				endif 
1ecd c9				ret 
1ece			 
1ece			macro_forth_dsp_pop: 
1ece			 
1ece e5				push hl 
1ecf			 
1ecf				; release malloc data 
1ecf			 
1ecf				if DEBUG_FORTH_STACK_GUARD 
1ecf cd 0a 5c				call check_stacks 
1ed2					FORTH_CHK_DSP_UNDER 
1ed2 e5				push hl 
1ed3 d5				push de 
1ed4 2a 2c ea			ld hl,(cli_data_sp) 
1ed7 11 66 e8			ld de, cli_data_stack 
1eda cd cb 0d			call cmp16 
1edd da 18 5d			jp c, fault_dsp_under 
1ee0 d1				pop de 
1ee1 e1				pop hl 
1ee2				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ee2				endif 
1ee2				;ld hl,(cli_data_sp) 
1ee2			if DEBUG_FORTH_DOT 
1ee2				DMARK "DPP" 
1ee2				CALLMONITOR 
1ee2			endif	 
1ee2			 
1ee2			 
1ee2			if FORTH_ENABLE_DSPPOPFREE 
1ee2			 
1ee2				FORTH_DSP 
1ee2 cd dc 1d			call macro_forth_dsp 
1ee5				endm 
# End of macro FORTH_DSP
1ee5			 
1ee5 7e				ld a, (hl) 
1ee6 fe 01			cp DS_TYPE_STR 
1ee8 20 07			jr nz, .skippopfree 
1eea			 
1eea				FORTH_DSP_VALUEHL 
1eea cd 16 1e			call macro_dsp_valuehl 
1eed				endm 
# End of macro FORTH_DSP_VALUEHL
1eed 00				nop 
1eee			if DEBUG_FORTH_DOT 
1eee				DMARK "DPf" 
1eee				CALLMONITOR 
1eee			endif	 
1eee cd 3e 13			call free 
1ef1			.skippopfree: 
1ef1				 
1ef1			 
1ef1			endif 
1ef1			 
1ef1			if DEBUG_FORTH_DOT_KEY 
1ef1				DMARK "DP2" 
1ef1				CALLMONITOR 
1ef1			endif	 
1ef1			 
1ef1				; move pointer down 
1ef1			 
1ef1 2a 2c ea			ld hl,(cli_data_sp) 
1ef4 2b				dec hl 
1ef5 2b				dec hl 
1ef6			; PARSEV5 
1ef6 2b				dec hl 
1ef7 22 2c ea			ld (cli_data_sp), hl 
1efa			 
1efa				if DEBUG_FORTH_STACK_GUARD 
1efa cd 0a 5c				call check_stacks 
1efd					FORTH_CHK_DSP_UNDER 
1efd e5				push hl 
1efe d5				push de 
1eff 2a 2c ea			ld hl,(cli_data_sp) 
1f02 11 66 e8			ld de, cli_data_stack 
1f05 cd cb 0d			call cmp16 
1f08 da 18 5d			jp c, fault_dsp_under 
1f0b d1				pop de 
1f0c e1				pop hl 
1f0d				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f0d				endif 
1f0d			 
1f0d e1				pop hl 
1f0e			 
1f0e c9				ret 
1f0f			 
1f0f			getwordathl: 
1f0f				; hl points to an address 
1f0f				; load hl with the word at that address 
1f0f			 
1f0f d5				push de 
1f10			 
1f10 5e				ld e, (hl) 
1f11 23				inc hl 
1f12 56				ld d, (hl) 
1f13 eb				ex de, hl 
1f14			 
1f14 d1				pop de 
1f15 c9				ret 
1f16			 
1f16			 
1f16			 
1f16			 
1f16			 
1f16			; eof 
1f16			 
# End of file forth_stackopsv5.asm
1f16			endif 
1f16			 
1f16			user_word_eol:  
1f16				; hl contains the pointer to where to create a linked list item from the end 
1f16				; of the user dict to continue on at the system word dict 
1f16				 
1f16				; poke the stub of the word list linked list to repoint to rom words 
1f16			 
1f16				; stub format 
1f16				; db   word id 
1f16				; dw    link to next word 
1f16			        ; db char length of token 
1f16				; db string + 0 term 
1f16				; db exec code....  
1f16			 
1f16 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1f18 77				ld (hl), a		; word id 
1f19 23				inc hl 
1f1a			 
1f1a 11 e5 20			ld de, sysdict 
1f1d 73				ld (hl), e		; next word link ie system dict 
1f1e 23				inc hl 
1f1f 72				ld (hl), d		; next word link ie system dict 
1f20 23				inc hl	 
1f21			 
1f21			;	ld (hl), sysdict		; next word link ie system dict 
1f21			;	inc hl 
1f21			;	inc hl 
1f21			 
1f21			;	inc hl 
1f21			;	inc hl 
1f21			 
1f21 3e 02			ld a, 2			; word length is 0 
1f23 77				ld (hl), a	 
1f24 23				inc hl 
1f25			 
1f25 3e 7e			ld a, '~'			; word length is 0 
1f27 77				ld (hl), a	 
1f28 23				inc hl 
1f29 3e 00			ld a, 0			; save empty word 
1f2b 77				ld (hl), a 
1f2c			 
1f2c c9				ret 
1f2d			 
1f2d				 
1f2d			 
1f2d			forthexec_cleanup: 
1f2d				FORTH_RSP_POP 
1f2d cd e7 1b			call macro_forth_rsp_pop 
1f30				endm 
# End of macro FORTH_RSP_POP
1f30 c9				ret 
1f31			 
1f31			forth_call_hl: 
1f31				; taking hl 
1f31 e5				push hl 
1f32 c9				ret 
1f33			 
1f33			; this is called to reset Forth system but keep existing uwords etc 
1f33			 
1f33			forth_warmstart: 
1f33				; setup stack over/under flow checks 
1f33				if DEBUG_FORTH_STACK_GUARD 
1f33 cd f0 5b				call chk_stk_init 
1f36				endif 
1f36			 
1f36				; init stack pointers  - * these stacks go upwards *  
1f36 21 ea e9			ld hl, cli_ret_stack 
1f39 22 30 ea			ld (cli_ret_sp), hl	 
1f3c				; set bottom of stack 
1f3c 3e 00			ld a,0 
1f3e 77				ld (hl),a 
1f3f 23				inc hl 
1f40 77				ld (hl),a 
1f41			 
1f41 21 66 e8			ld hl, cli_data_stack 
1f44 22 2c ea			ld (cli_data_sp), hl	 
1f47				; set bottom of stack 
1f47 3e 00			ld a,0 
1f49 77				ld (hl),a 
1f4a 23				inc hl 
1f4b 77				ld (hl),a 
1f4c			 
1f4c 21 68 e9			ld hl, cli_loop_stack 
1f4f 22 2e ea			ld (cli_loop_sp), hl	 
1f52				; set bottom of stack 
1f52 3e 00			ld a,0 
1f54 77				ld (hl),a 
1f55 23				inc hl 
1f56 77				ld (hl),a 
1f57			 
1f57				; init extent of current open file 
1f57			 
1f57 3e 00			ld a, 0 
1f59 32 74 ea			ld (store_openext), a 
1f5c			 
1f5c c9				ret 
1f5d			 
1f5d			 
1f5d			; Cold Start - this is called to setup the whole Forth system 
1f5d			 
1f5d			forth_init: 
1f5d			 
1f5d				; setup stack over/under flow checks 
1f5d			 
1f5d			;	if DEBUG_FORTH_STACK_GUARD 
1f5d			;		call chk_stk_init 
1f5d			;	endif 
1f5d			 
1f5d				; enable auto display updates (slow.....) 
1f5d			 
1f5d 3e 01			ld a, 1 
1f5f 32 46 ea			ld (cli_autodisplay), a 
1f62			 
1f62				; if storage is in use disable long reads for now 
1f62 3e 00			ld a, 0 
1f64 32 7f ea			ld (store_longread), a 
1f67			 
1f67			 
1f67				; show start up screen 
1f67			 
1f67 cd 80 0b			call clear_display 
1f6a			 
1f6a 3e 00			ld a,0 
1f6c 32 68 ea			ld (f_cursor_ptr), a 
1f6f			 
1f6f				; set start of word list in start of ram - for use when creating user words 
1f6f			 
1f6f 21 13 5f			ld hl, baseram 
1f72 22 fc e5			ld (os_last_new_uword), hl 
1f75 cd 16 1f			call user_word_eol 
1f78				 
1f78			;		call display_data_sp 
1f78			;		call next_page_prompt 
1f78			 
1f78			 
1f78			 
1f78			 
1f78 c9				ret 
1f79			 
1f79 .. 00		.bootforth: db " Forth Kernel Init ",0 
1f8d			 
1f8d			; TODO push to stack 
1f8d			 
1f8d			;  
1f8d			 
1f8d			if FORTH_PARSEV2 
1f8d			 
1f8d			 
1f8d				include "forth_parserv2.asm" 
1f8d			 
1f8d			endif 
1f8d			 
1f8d			 
1f8d			; parse cli version 1 
1f8d			 
1f8d			if FORTH_PARSEV1 
1f8d			 
1f8d			 
1f8d			 
1f8d			      include "forth_parserv1.asm" 
1f8d			endif 
1f8d				 
1f8d			if FORTH_PARSEV3 
1f8d			 
1f8d			 
1f8d			 
1f8d			      include "forth_parserv3.asm" 
1f8d				include "forth_wordsv3.asm" 
1f8d			endif 
1f8d			 
1f8d			if FORTH_PARSEV4 
1f8d			 
1f8d			 
1f8d			 
1f8d			      include "forth_parserv4.asm" 
1f8d				include "forth_wordsv4.asm" 
1f8d			endif 
1f8d			 
1f8d			if FORTH_PARSEV5 
1f8d			 
1f8d			 
1f8d			 
1f8d			      include "forth_parserv5.asm" 
1f8d			 
1f8d			 
1f8d			; A better parser without using malloc and string copies all over the place.  
1f8d			; Exec in situ should be faster 
1f8d			 
1f8d			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1f8d			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1f8d			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1f8d			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1f8d			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1f8d			WORD_SYS_END: equ 0   ; Opcode for all user words 
1f8d			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1f8d			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1f8d			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1f8d			 
1f8d			; Core word preamble macro 
1f8d			 
1f8d			CWHEAD:   macro nxtword opcode lit len opflags 
1f8d				db WORD_SYS_CORE+opcode             
1f8d				; internal op code number 
1f8d				dw nxtword            
1f8d				; link to next dict word block 
1f8d				db len + 1 
1f8d				; literal length of dict word inc zero term 
1f8d				db lit,0              
1f8d				; literal dict word 
1f8d			        ; TODO db opflags        
1f8d				endm 
1f8d			 
1f8d			 
1f8d			NEXTW: macro  
1f8d				jp macro_next 
1f8d				endm 
1f8d			 
1f8d			macro_next: 
1f8d			if DEBUG_FORTH_PARSE_KEY 
1f8d				DMARK "NXT" 
1f8d				CALLMONITOR 
1f8d			endif	 
1f8d			;	inc hl  ; skip token null term  
1f8d ed 4b 4a ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f91 ed 5b 48 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f95 2a 00 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f98			if DEBUG_FORTH_PARSE_KEY 
1f98				DMARK "}AA" 
1f98				CALLMONITOR 
1f98			endif	 
1f98 c3 9b 20			jp execnext 
1f9b				;jp exec1 
1f9b			       
1f9b			 
1f9b			 
1f9b			; Another go at the parser to compile  
1f9b			 
1f9b			 
1f9b			; TODO rework parser to change all of the string words to byte tokens 
1f9b			; TODO do a search for  
1f9b			 
1f9b			; TODO first run normal parser to zero term sections 
1f9b			; TODO for each word do a token look up to get the op code 
1f9b			; TODO need some means to flag to the exec that this is a byte code form    
1f9b			 
1f9b			 
1f9b			forthcompile: 
1f9b			 
1f9b			; 
1f9b			; line parse: 
1f9b			;       parse raw input buffer 
1f9b			;       tokenise the words 
1f9b			;       malloc new copy (for looping etc) 
1f9b			;       copy to malloc + current pc in line to start of string and add line term 
1f9b			;       save on new rsp 
1f9b			; 
1f9b			 
1f9b			; hl to point to the line to tokenise 
1f9b			 
1f9b			;	push hl 
1f9b 22 00 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1f9e			 
1f9e			;	ld a,0		; string term on input 
1f9e			;	call strlent 
1f9e			 
1f9e			;	ld (os_tok_len), hl	 ; save string length 
1f9e			 
1f9e			;if DEBUG_FORTH_TOK 
1f9e			;	ex de,hl		 
1f9e			;endif 
1f9e			 
1f9e			;	pop hl 		; get back string pointer 
1f9e			 
1f9e			if DEBUG_FORTH_TOK 
1f9e						DMARK "TOc" 
1f9e				CALLMONITOR 
1f9e			endif 
1f9e 7e			.cptoken2:    ld a,(hl) 
1f9f 23				inc hl 
1fa0 fe 7f			cp FORTH_END_BUFFER 
1fa2 28 29			jr z, .cptokendone2 
1fa4 fe 00			cp 0 
1fa6 28 25			jr z, .cptokendone2 
1fa8 fe 22			cp '"' 
1faa 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1fac fe 20			cp ' ' 
1fae 20 ee			jr nz,  .cptoken2 
1fb0			 
1fb0			; TODO consume comments held between ( and ) 
1fb0			 
1fb0				; we have a space so change to zero term for dict match later 
1fb0 2b				dec hl 
1fb1 3e 00			ld a,0 
1fb3 77				ld (hl), a 
1fb4 23				inc hl 
1fb5 18 e7			jr .cptoken2 
1fb7				 
1fb7			 
1fb7			.cptokenstr2: 
1fb7				; skip all white space until either eol (because forgot to term) or end double quote 
1fb7			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1fb7				;inc hl ; skip current double quote 
1fb7 7e				ld a,(hl) 
1fb8 23				inc hl 
1fb9 fe 22			cp '"' 
1fbb 28 e1			jr z, .cptoken2 
1fbd fe 7f			cp FORTH_END_BUFFER 
1fbf 28 0c			jr z, .cptokendone2 
1fc1 fe 00			cp 0 
1fc3 28 08			jr z, .cptokendone2 
1fc5 fe 20			cp ' ' 
1fc7 28 02			jr z, .cptmp2 
1fc9 18 ec			jr .cptokenstr2 
1fcb			 
1fcb			.cptmp2:	; we have a space so change to zero term for dict match later 
1fcb				;dec hl 
1fcb				;ld a,"-"	; TODO remove this when working 
1fcb				;ld (hl), a 
1fcb				;inc hl 
1fcb 18 ea			jr .cptokenstr2 
1fcd			 
1fcd			.cptokendone2: 
1fcd				;inc hl 
1fcd 3e 7f			ld a, FORTH_END_BUFFER 
1fcf 77				ld (hl),a 
1fd0 23				inc hl 
1fd1 3e 21			ld a, '!' 
1fd3 77				ld (hl),a 
1fd4			 
1fd4 2a 00 e6			ld hl,(os_tok_ptr) 
1fd7			         
1fd7			if DEBUG_FORTH_TOK 
1fd7						DMARK "Tc1" 
1fd7				CALLMONITOR 
1fd7			endif 
1fd7			 
1fd7				; push exec string to top of return stack 
1fd7				FORTH_RSP_NEXT 
1fd7 cd c6 1b			call macro_forth_rsp_next 
1fda				endm 
# End of macro FORTH_RSP_NEXT
1fda c9				ret 
1fdb			 
1fdb			; Another go at the parser need to simplify the process 
1fdb			 
1fdb			forthparse: 
1fdb			 
1fdb			; 
1fdb			; line parse: 
1fdb			;       parse raw input buffer 
1fdb			;       tokenise the words 
1fdb			;       malloc new copy (for looping etc) 
1fdb			;       copy to malloc + current pc in line to start of string and add line term 
1fdb			;       save on new rsp 
1fdb			; 
1fdb			 
1fdb			; hl to point to the line to tokenise 
1fdb			 
1fdb			;	push hl 
1fdb 22 00 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1fde			 
1fde			;	ld a,0		; string term on input 
1fde			;	call strlent 
1fde			 
1fde			;	ld (os_tok_len), hl	 ; save string length 
1fde			 
1fde			;if DEBUG_FORTH_TOK 
1fde			;	ex de,hl		 
1fde			;endif 
1fde			 
1fde			;	pop hl 		; get back string pointer 
1fde			 
1fde			if DEBUG_FORTH_TOK 
1fde						DMARK "TOK" 
1fde				CALLMONITOR 
1fde			endif 
1fde 7e			.ptoken2:    ld a,(hl) 
1fdf 23				inc hl 
1fe0 fe 7f			cp FORTH_END_BUFFER 
1fe2 28 29			jr z, .ptokendone2 
1fe4 fe 00			cp 0 
1fe6 28 25			jr z, .ptokendone2 
1fe8 fe 22			cp '"' 
1fea 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1fec fe 20			cp ' ' 
1fee 20 ee			jr nz,  .ptoken2 
1ff0			 
1ff0			; TODO consume comments held between ( and ) 
1ff0			 
1ff0				; we have a space so change to zero term for dict match later 
1ff0 2b				dec hl 
1ff1 3e 00			ld a,0 
1ff3 77				ld (hl), a 
1ff4 23				inc hl 
1ff5 18 e7			jr .ptoken2 
1ff7				 
1ff7			 
1ff7			.ptokenstr2: 
1ff7				; skip all white space until either eol (because forgot to term) or end double quote 
1ff7			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1ff7				;inc hl ; skip current double quote 
1ff7 7e				ld a,(hl) 
1ff8 23				inc hl 
1ff9 fe 22			cp '"' 
1ffb 28 e1			jr z, .ptoken2 
1ffd fe 7f			cp FORTH_END_BUFFER 
1fff 28 0c			jr z, .ptokendone2 
2001 fe 00			cp 0 
2003 28 08			jr z, .ptokendone2 
2005 fe 20			cp ' ' 
2007 28 02			jr z, .ptmp2 
2009 18 ec			jr .ptokenstr2 
200b			 
200b			.ptmp2:	; we have a space so change to zero term for dict match later 
200b				;dec hl 
200b				;ld a,"-"	; TODO remove this when working 
200b				;ld (hl), a 
200b				;inc hl 
200b 18 ea			jr .ptokenstr2 
200d			 
200d			.ptokendone2: 
200d				;inc hl 
200d 3e 7f			ld a, FORTH_END_BUFFER 
200f 77				ld (hl),a 
2010 23				inc hl 
2011 3e 21			ld a, '!' 
2013 77				ld (hl),a 
2014			 
2014 2a 00 e6			ld hl,(os_tok_ptr) 
2017			         
2017			if DEBUG_FORTH_TOK 
2017						DMARK "TK1" 
2017				CALLMONITOR 
2017			endif 
2017			 
2017				; push exec string to top of return stack 
2017				FORTH_RSP_NEXT 
2017 cd c6 1b			call macro_forth_rsp_next 
201a				endm 
# End of macro FORTH_RSP_NEXT
201a c9				ret 
201b			 
201b			; 
201b			;	; malloc size + buffer pointer + if is loop flag 
201b			;	ld hl,(os_tok_len) 		 ; get string length 
201b			; 
201b			;	ld a,l 
201b			; 
201b			;	cp 0			; we dont want to use a null string 
201b			;	ret z 
201b			; 
201b			;;	add 3    ; prefix malloc with buffer for current word ptr 
201b			; 
201b			;	add 5     ; TODO when certain not over writing memory remove 
201b			; 
201b			;		 
201b			; 
201b			;if DEBUG_FORTH_TOK 
201b			;			DMARK "TKE" 
201b			;	CALLMONITOR 
201b			;endif 
201b			; 
201b			;	ld l,a 
201b			;	ld h,0 
201b			;;	push hl   ; save required space for the copy later 
201b			;	call malloc 
201b			;if DEBUG_FORTH_TOK 
201b			;			DMARK "TKM" 
201b			;	CALLMONITOR 
201b			;endif 
201b			;	if DEBUG_FORTH_MALLOC_GUARD 
201b			;		push af 
201b			;		call ishlzero 
201b			;;		ld a, l 
201b			;;		add h 
201b			;;		cp 0 
201b			;		pop af 
201b			;		 
201b			;		call z,malloc_error 
201b			;	endif 
201b			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
201b			; 
201b			; 
201b			;if DEBUG_FORTH_TOK 
201b			;			DMARK "TKR" 
201b			;	CALLMONITOR 
201b			;endif 
201b			; 
201b			;	FORTH_RSP_NEXT 
201b			; 
201b			;	;inc hl	 ; go past current buffer pointer 
201b			;	;inc hl 
201b			;	;inc hl   ; and past if loop flag 
201b			;		; TODO Need to set flag  
201b			; 
201b			;	 
201b			;	 
201b			;	ex de,hl	; malloc is dest 
201b			;	ld hl, (os_tok_len) 
201b			;;	pop bc 
201b			;	ld c, l                
201b			;	ld b,0 
201b			;	ld hl, (os_tok_ptr) 
201b			; 
201b			;if DEBUG_FORTH_TOK 
201b			;			DMARK "TKT" 
201b			;	CALLMONITOR 
201b			;endif 
201b			; 
201b			;	; do str cpy 
201b			; 
201b			;	ldir      ; copy byte in hl to de 
201b			; 
201b			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
201b			; 
201b			;if DEBUG_FORTH_TOK 
201b			; 
201b			;			DMARK "TKY" 
201b			;	CALLMONITOR 
201b			;endif 
201b			;	;ld a,0 
201b			;	;ld a,FORTH_END_BUFFER 
201b			;	ex de, hl 
201b			;	;dec hl			 ; go back over the space delim at the end of word 
201b			;	;ld (hl),a 
201b			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
201b			;	ld a,FORTH_END_BUFFER 
201b			;	ld (hl),a 
201b			;	inc hl 
201b			;	ld a,FORTH_END_BUFFER 
201b			;	ld (hl),a 
201b			; 
201b			;	; init the malloc area data 
201b			;	; set pc for in current area 
201b			;	;ld hl, (os_tok_malloc) 
201b			;	;inc hl 
201b			;	;inc hl 
201b			;	;inc hl 
201b			;	;ex de,hl 
201b			;	;ld hl, (os_tok_malloc) 
201b			;	;ld (hl),e 
201b			;	;inc hl 
201b			;	;ld (hl),d 
201b			; 
201b			; 
201b			;	ld hl,(os_tok_malloc) 
201b			;if DEBUG_FORTH_PARSE_KEY 
201b			;			DMARK "TKU" 
201b			;	CALLMONITOR 
201b			;endif 
201b			; 
201b			;	ret 
201b			 
201b			forthexec: 
201b			 
201b			; line exec: 
201b			; forth parser 
201b			 
201b			; 
201b			;       get current exec line on rsp 
201b			 
201b				FORTH_RSP_TOS 
201b cd dd 1b			call macro_forth_rsp_tos 
201e				endm 
# End of macro FORTH_RSP_TOS
201e			 
201e			;       restore current pc - hl points to malloc of data 
201e			 
201e				;ld e, (hl) 
201e				;inc hl 
201e				;ld d, (hl) 
201e				;ex de,hl 
201e			 
201e			 
201e			exec1: 
201e 22 00 e6			ld (os_tok_ptr), hl 
2021			 
2021				; copy our PC to working vars  
2021 22 4a ea			ld (cli_ptr), hl 
2024 22 48 ea			ld (cli_origptr), hl 
2027			 
2027 7e				ld a,(hl) 
2028 fe 7f			cp FORTH_END_BUFFER 
202a c8				ret z 
202b			 
202b				; skip any nulls 
202b			 
202b fe 00			cp 0 
202d 20 03			jr nz, .execword 
202f 23				inc hl 
2030 18 ec			jr exec1 
2032			 
2032			 
2032			.execword: 
2032			 
2032			 
2032			 
2032			if DEBUG_FORTH_PARSE_KEY 
2032						DMARK "KYQ" 
2032				CALLMONITOR 
2032			endif 
2032			;       while at start of word: 
2032			; get start of dict (in user area first) 
2032			 
2032 21 13 5f		ld hl, baseram 
2035			;ld hl, sysdict 
2035 22 4c ea		ld (cli_nextword),hl 
2038			;           match word at pc 
2038			;           exec word 
2038			;           or push to dsp 
2038			;           forward to next token 
2038			;           if line term pop rsp and exit 
2038			;        
2038			 
2038			if DEBUG_FORTH_PARSE_KEY 
2038						DMARK "KYq" 
2038				CALLMONITOR 
2038			endif 
2038			 
2038			; 
2038			; word comp 
2038			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2038			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2038			;    move to start of word  
2038			;    compare word to cli_token 
2038			 
2038			.execpnword:	; HL at start of a word in the dictionary to check 
2038			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2038			;	ld (cli_ptr), hl 
2038			 
2038 2a 4c ea			ld hl,(cli_nextword) 
203b			 
203b cd de 20			call forth_tok_next 
203e			; tok next start here 
203e			;	; TODO skip compiled symbol for now 
203e			;	inc hl 
203e			; 
203e			;	; save pointer to next word 
203e			; 
203e			;	; hl now points to the address of the next word pointer  
203e			;	ld e, (hl) 
203e			;	inc hl 
203e			;	ld d, (hl) 
203e			;	inc l 
203e			; 
203e			;	ex de,hl 
203e			;if DEBUG_FORTH_PARSE_NEXTWORD 
203e			;	push bc 
203e			;	ld bc, (cli_nextword) 
203e			;			DMARK "NXW" 
203e			;	CALLMONITOR 
203e			;	pop bc 
203e			;endif 
203e			; tok next end here 
203e 22 4c ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
2041 eb				ex de, hl 
2042			 
2042			 
2042				; save the pointer of the current token - 1 to check against 
2042				 
2042 22 50 ea			ld (cli_token), hl   
2045				; TODO maybe remove below save if no debug 
2045				; save token string ptr for any debug later 
2045 23				inc hl  
2046 22 52 ea			ld (cli_origtoken), hl 
2049 2b				dec hl 
204a				; save pointer to the start of the next dictionay word 
204a 7e				ld a,(hl)   ; get string length 
204b 47				ld b,a 
204c			.execpnwordinc:  
204c 23				inc hl 
204d 10 fd			djnz .execpnwordinc 
204f 22 4e ea			ld (cli_execword), hl      ; save start of this words code 
2052			 
2052				; now check the word token against the string being parsed 
2052			 
2052 2a 50 ea			ld hl,(cli_token) 
2055 23				inc hl     ; skip string length (use zero term instead to end) 
2056 22 50 ea			ld (cli_token), hl 
2059			 
2059			if DEBUG_FORTH_PARSE_KEY 
2059						DMARK "KY2" 
2059			endif 
2059			if DEBUG_FORTH_PARSE_EXEC 
2059				; see if disabled 
2059			 
2059				ld a, (os_view_disable) 
2059				cp '*' 
2059				jr z, .skip 
2059			 
2059				push hl 
2059				push hl 
2059				call clear_display 
2059				ld de, .compword 
2059				ld a, display_row_1 
2059				call str_at_display 
2059				pop de 
2059				ld a, display_row_2 
2059				call str_at_display 
2059				ld hl,(cli_ptr) 
2059				ld a,(hl) 
2059			        ld hl, os_word_scratch 
2059				ld (hl),a 
2059				ld a,0 
2059				inc hl 
2059				ld (hl),a 	 
2059				ld de, os_word_scratch 
2059				ld a, display_row_2+10 
2059				call str_at_display 
2059				call update_display 
2059				ld a, 100 
2059				call aDelayInMS 
2059				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2059				call delay250ms 
2059				endif 
2059				pop hl 
2059			.skip:  
2059			endif	 
2059			.execpnchar:    ; compare char between token and string to parse 
2059			 
2059			if DEBUG_FORTH_PARSE_KEY 
2059						DMARK "Ky3" 
2059			endif 
2059			if DEBUG_FORTH_PARSE_EXEC 
2059				; see if disabled 
2059			 
2059				ld a, (os_view_disable) 
2059				cp '*' 
2059				jr z, .skip2 
2059			 
2059			;	call clear_display 
2059			ld hl,(cli_token) 
2059			ld a,(hl) 
2059			ld (os_word_scratch),a 
2059				ld hl,(cli_ptr) 
2059			ld a,(hl) 
2059				ld (os_word_scratch+1),a 
2059				ld a,0 
2059				ld (os_word_scratch+2),a 
2059				ld de,os_word_scratch 
2059				ld a,display_row_4 
2059				call str_at_display 
2059				call update_display 
2059			.skip2:  
2059			endif 
2059 2a 50 ea			ld hl,(cli_token) 
205c 7e				ld a, (hl)	 ; char in word token 
205d 23				inc hl 		; move to next char 
205e 22 50 ea			ld (cli_token), hl ; and save it 
2061 47				ld b,a 
2062			 
2062 2a 4a ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
2065 7e				ld a,(hl) 
2066 23				inc hl 
2067 22 4a ea			ld (cli_ptr), hl		; move to next char 
206a cd 02 12			call toUpper 		; make sure the input string matches case 
206d			 
206d			if DEBUG_FORTH_PARSE 
206d			endif 
206d			 
206d				; input stream end of token is a space so get rid of it 
206d			 
206d			;	cp ' ' 
206d			;	jr nz, .pnskipspace 
206d			; 
206d			;	ld a, 0		; make same term as word token term 
206d			; 
206d			;.pnskipspace: 
206d			 
206d			if DEBUG_FORTH_PARSE_KEY 
206d						DMARK "KY7" 
206d			endif 
206d b8				cp b 
206e c2 84 20			jp nz, .execpnskipword	 ; no match so move to next word 
2071				 
2071			;    if same 
2071			;       scan for string terms 0 for token and 32 for input 
2071			 
2071				 
2071			if DEBUG_FORTH_PARSE_KEY 
2071						DMARK "KY8" 
2071			endif 
2071			 
2071 80				add b			 
2072 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2074							; TODO need to make sure last word in zero term string is accounted for 
2074 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2076			 
2076			 
2076				; at end of both strings so both are exact match 
2076			 
2076			;       skip ptr for next word 
2076			 
2076 2a 4a ea			ld hl,(cli_ptr) 	; at input string term 
2079 23				inc hl			 ; at next char 
207a 22 4a ea			ld (cli_ptr), hl     ; save for next round of the parser 
207d 22 48 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2080				 
2080				 
2080			if DEBUG_FORTH_PARSE_KEY 
2080						DMARK "KY3" 
2080			endif 
2080			 
2080			 
2080			 
2080			;       exec code block 
2080			if DEBUG_FORTH_JP 
2080				call clear_display 
2080				call update_display 
2080				call delay1s 
2080				ld hl, (cli_execword)     ; save for next check if no match on this word 
2080				ld a,h 
2080				ld hl, os_word_scratch 
2080				call hexout 
2080				ld hl, (cli_execword)     ; save for next check if no match on this word 
2080				ld a,l 
2080				ld hl, os_word_scratch+2 
2080				call hexout 
2080				ld hl, os_word_scratch+4 
2080				ld a,0 
2080				ld (hl),a 
2080				ld de,os_word_scratch 
2080				call str_at_display 
2080					ld a, display_row_2 
2080					call str_at_display 
2080				ld de, (cli_origtoken) 
2080				ld a, display_row_1+10 
2080					call str_at_display 
2080			 
2080				ld a,display_row_1 
2080				ld de, .foundword 
2080				ld a, display_row_3 
2080				call str_at_display 
2080				call update_display 
2080				call delay1s 
2080				call delay1s 
2080				call delay1s 
2080			endif 
2080			 
2080			if DEBUG_FORTH_PARSE_KEY 
2080						DMARK "KYj" 
2080			endif 
2080				; TODO save the word pointer in this exec 
2080			 
2080 2a 4e ea			ld hl,(cli_execword) 
2083 e9				jp (hl) 
2084			 
2084			 
2084			;    if not same 
2084			;	scan for zero term 
2084			;	get ptr for next word 
2084			;	goto word comp 
2084			 
2084			.execpnskipword:	; get pointer to next word 
2084 2a 4c ea			ld hl,(cli_nextword) 
2087			 
2087 7e				ld a,(hl) 
2088 fe 00			cp WORD_SYS_END 
208a			;	cp 0 
208a 28 09			jr z, .execendofdict			 ; at end of words 
208c			 
208c			if DEBUG_FORTH_PARSE_KEY 
208c						DMARK "KY4" 
208c			endif 
208c			if DEBUG_FORTH_PARSE_EXEC 
208c			 
208c				; see if disabled 
208c			 
208c				ld a, (os_view_disable) 
208c				cp '*' 
208c				jr z, .noskip 
208c			 
208c			 
208c				ld de, .nowordfound 
208c				ld a, display_row_3 
208c				call str_at_display 
208c				call update_display 
208c				ld a, 100 
208c				call aDelayInMS 
208c				 
208c				if DEBUG_FORTH_PARSE_EXEC_SLOW 
208c					call delay250ms 
208c				endif 
208c			.noskip:  
208c			 
208c			endif	 
208c			 
208c 2a 48 ea			ld hl,(cli_origptr) 
208f 22 4a ea			ld (cli_ptr),hl 
2092			 
2092			if DEBUG_FORTH_PARSE_KEY 
2092						DMARK "KY5" 
2092			endif 
2092 c3 38 20			jp .execpnword			; else go to next word 
2095			 
2095			.execendofdict:  
2095			 
2095			if DEBUG_FORTH_PARSE_KEY 
2095						DMARK "KYe" 
2095			endif 
2095			if DEBUG_FORTH_PARSE_EXEC 
2095				; see if disabled 
2095			 
2095				ld a, (os_view_disable) 
2095				cp '*' 
2095				jr z, .ispskip 
2095			 
2095				call clear_display 
2095				call update_display 
2095				call delay1s 
2095				ld de, (cli_origptr) 
2095				ld a, display_row_1 
2095				call str_at_display 
2095				 
2095				ld de, .enddict 
2095				ld a, display_row_3 
2095				call str_at_display 
2095				call update_display 
2095				ld a, 100 
2095				call aDelayInMS 
2095				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2095				call delay1s 
2095				call delay1s 
2095				call delay1s 
2095				endif 
2095			.ispskip:  
2095				 
2095			endif	 
2095			 
2095			 
2095			 
2095				; if the word is not a keyword then must be a literal so push it to stack 
2095			 
2095			; push token to stack to end of word 
2095			 
2095				STACKFRAME ON $1efe $2f9f 
2095				if DEBUG_STACK_IMB 
2095					if ON 
2095						exx 
2095						ld de, $1efe 
2095						ld a, d 
2095						ld hl, curframe 
2095						call hexout 
2095						ld a, e 
2095						ld hl, curframe+2 
2095						call hexout 
2095						ld hl, $1efe 
2095						push hl 
2095						ld hl, $2f9f 
2095						push hl 
2095						exx 
2095					endif 
2095				endif 
2095			endm 
# End of macro STACKFRAME
2095			 
2095 2a 00 e6		ld hl,(os_tok_ptr) 
2098 cd 88 1d		call forth_apush 
209b			 
209b				STACKFRAMECHK ON $1efe $2f9f 
209b				if DEBUG_STACK_IMB 
209b					if ON 
209b						exx 
209b						ld hl, $2f9f 
209b						pop de   ; $2f9f 
209b						call cmp16 
209b						jr nz, .spnosame 
209b						ld hl, $1efe 
209b						pop de   ; $1efe 
209b						call cmp16 
209b						jr z, .spfrsame 
209b						.spnosame: call showsperror 
209b						.spfrsame: nop 
209b						exx 
209b					endif 
209b				endif 
209b			endm 
# End of macro STACKFRAMECHK
209b			 
209b			execnext: 
209b			 
209b			if DEBUG_FORTH_PARSE_KEY 
209b						DMARK "KY>" 
209b			endif 
209b			; move past token to next word 
209b			 
209b 2a 00 e6		ld hl, (os_tok_ptr) 
209e 3e 00		ld a, 0 
20a0 01 ff 00		ld bc, 255     ; input buffer size 
20a3 ed b1		cpir 
20a5			 
20a5			if DEBUG_FORTH_PARSE_KEY 
20a5						DMARK "KY!" 
20a5				CALLMONITOR 
20a5			endif	 
20a5			; TODO this might place hl on the null, so will need to forward on??? 
20a5			;inc hl   ; see if this gets onto the next item 
20a5			 
20a5			 
20a5			; TODO pass a pointer to the buffer to push 
20a5			; TODO call function to push 
20a5			 
20a5			; look for end of input 
20a5			 
20a5			;inc hl 
20a5			;ld a,(hl) 
20a5			;cp FORTH_END_BUFFER 
20a5			;ret z 
20a5			 
20a5			 
20a5 c3 1e 20		jp exec1 
20a8			 
20a8			 
20a8			 
20a8			 
20a8			 
20a8			 
20a8			 
20a8			 
20a8			 
20a8			findnexttok: 
20a8			 
20a8				; hl is pointer to move 
20a8				; de is the token to locate 
20a8			 
20a8					if DEBUG_FORTH 
20a8						DMARK "NTK" 
20a8						CALLMONITOR 
20a8					endif 
20a8 d5				push de 
20a9			 
20a9			.fnt1:	 
20a9				; find first char of token to locate 
20a9			 
20a9 1a				ld a, (de) 
20aa 4f				ld c,a 
20ab 7e				ld a,(hl) 
20ac cd 02 12			call toUpper 
20af					if DEBUG_FORTH 
20af						DMARK "NT1" 
20af						CALLMONITOR 
20af					endif 
20af b9				cp c 
20b0			 
20b0 28 03			jr z, .fnt2cmpmorefirst	 
20b2			 
20b2				; first char not found move to next char 
20b2			 
20b2 23				inc hl 
20b3 18 f4			jr .fnt1 
20b5			 
20b5			.fnt2cmpmorefirst:	 
20b5				; first char of token found.  
20b5			 
20b5 e5				push hl     ; save start of token just in case it is the right one 
20b6 d9				exx 
20b7 e1				pop hl        ; save it to hl' 
20b8 d9				exx 
20b9			 
20b9			 
20b9			.fnt2cmpmore:	 
20b9				; compare the rest 
20b9				 
20b9 23				inc hl 
20ba 13				inc de 
20bb				 
20bb 1a				ld a, (de) 
20bc 4f				ld c,a 
20bd 7e				ld a,(hl) 
20be cd 02 12			call toUpper 
20c1			 
20c1					if DEBUG_FORTH 
20c1						DMARK "NT2" 
20c1						CALLMONITOR 
20c1					endif 
20c1				; c has the token to find char 
20c1				; a has the mem to scan char 
20c1			 
20c1 b9				cp c 
20c2 28 04			jr z,.fntmatch1 
20c4			 
20c4				; they are not the same 
20c4			 
20c4					if DEBUG_FORTH 
20c4						DMARK "NT3" 
20c4						CALLMONITOR 
20c4					endif 
20c4 d1				pop de	; reset de token to look for 
20c5 d5				push de 
20c6 18 e1			jr .fnt1 
20c8				 
20c8			.fntmatch1: 
20c8			 
20c8				; is the same char a null which means we might have a full hit? 
20c8					if DEBUG_FORTH 
20c8						DMARK "NT4" 
20c8						CALLMONITOR 
20c8					endif 
20c8			 
20c8 fe 00			cp 0 
20ca 28 0b			jr z, .fntmatchyes 
20cc			 
20cc				; are we at the end of the token to find? 
20cc			 
20cc					if DEBUG_FORTH 
20cc						DMARK "NT5" 
20cc						CALLMONITOR 
20cc					endif 
20cc 3e 00			ld a, 0 
20ce b9				cp c 
20cf			 
20cf c2 b9 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
20d2			 
20d2					if DEBUG_FORTH 
20d2						DMARK "NT6" 
20d2						CALLMONITOR 
20d2					endif 
20d2				; token to find is exhusted but no match to stream 
20d2			 
20d2				; restore tok pointer and continue on 
20d2 d1				pop de 
20d3 d5				push de 
20d4 c3 a9 20			jp .fnt1 
20d7			 
20d7			 
20d7			.fntmatchyes: 
20d7			 
20d7				; hl now contains the end of the found token 
20d7			 
20d7				; get rid of saved token pointer to find 
20d7			 
20d7 d1				pop de 
20d8			 
20d8					if DEBUG_FORTH 
20d8						DMARK "NT9" 
20d8						CALLMONITOR 
20d8					endif 
20d8			 
20d8				; hl will be on the null term so forward on 
20d8			 
20d8				; get back the saved start of the token 
20d8			 
20d8 d9				exx 
20d9 e5				push hl     ; save start of token just in case it is the right one 
20da d9				exx 
20db e1				pop hl        ; save it to hl 
20dc			 
20dc c9				ret 
20dd			 
20dd			 
20dd			; LIST needs to find a specific token   
20dd			; FORGET needs to find a spefici token 
20dd			 
20dd			; SAVE needs to find all tokens by flag 
20dd			; WORDS just needs to scan through all  by flag 
20dd			; UWORDS needs to scan through all by flag 
20dd			 
20dd			 
20dd			; given hl as pointer to start of dict look up string 
20dd			; return hl as pointer to start of word block 
20dd			; or 0 if not found 
20dd			 
20dd			forth_find_tok: 
20dd c9				ret 
20de			 
20de			; given hl as pointer to dict structure 
20de			; move to the next dict block structure 
20de			 
20de			forth_tok_next: 
20de				; hl now points to the address of the next word pointer  
20de				; TODO skip compiled symbol for now 
20de			;	push de 
20de 23				inc hl 
20df 5e				ld e, (hl) 
20e0 23				inc hl 
20e1 56				ld d, (hl) 
20e2 23				inc hl 
20e3			 
20e3 eb				ex de,hl 
20e4			if DEBUG_FORTH_PARSE_NEXTWORD 
20e4				push bc 
20e4				ld bc, (cli_nextword) 
20e4						DMARK "NXW" 
20e4				CALLMONITOR 
20e4				pop bc 
20e4			endif 
20e4			;	pop de	 
20e4 c9				ret 
20e5			 
20e5			 
20e5			 
20e5			; eof 
# End of file forth_parserv5.asm
20e5				include "forth_wordsv4.asm" 
20e5			 
20e5			; the core word dictionary v4 
20e5			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
20e5			 
20e5			; this is a linked list for each of the system words used 
20e5			; user defined words will follow the same format but will be in ram 
20e5			 
20e5			 
20e5			; 
20e5			; 
20e5			; define linked list: 
20e5			; 
20e5			; 1. compiled byte op code 
20e5			; 2. len of text word 
20e5			; 3. text word 
20e5			; 4. ptr to next dictionary word 
20e5			; 5. asm, calls etc for the word 
20e5			; 
20e5			;  if 1 == 0 then last word in dict  
20e5			;   
20e5			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
20e5			;  
20e5			;  
20e5			; create basic standard set of words 
20e5			; 
20e5			;  
20e5			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
20e5			; 2DUP 2DROP 2SWAP  
20e5			; @ C@ - get byte  
20e5			; ! C! - store byte 
20e5			; 0< true if less than zero 
20e5			; 0= true if zero 
20e5			; < >  
20e5			; = true if same 
20e5			; variables 
20e5			 
20e5			 
20e5			; Hardware specific words I may need 
20e5			; 
20e5			; IN OUT  
20e5			; calls to key util functions 
20e5			; calls to hardward abstraction stuff 
20e5			; easy control of frame buffers and lcd i/o 
20e5			; keyboard  
20e5			 
20e5			 
20e5			;DICT: macro 
20e5			; op_code, len, word, next 
20e5			;    word: 
20e5			;    db op_code 
20e5			;    ds word zero term 
20e5			;    dw next 
20e5			;    endm 
20e5			 
20e5			 
20e5			 
20e5			 
20e5			; op code 1 is a flag for user define words which are to be handled differently 
20e5			 
20e5			 
20e5			; 
20e5			; 
20e5			;    TODO on entry to a word this should be the expected environment 
20e5			;    hl - tos value if number then held, if string this is the ptr 
20e5			;    de -  
20e5			 
20e5			 
20e5			; opcode ranges 
20e5			; 0 - end of word dict 
20e5			; 255 - user define words 
20e5			 
20e5			sysdict: 
20e5			include "forth_opcodes.asm" 
20e5			; op codes for forth keywords 
20e5			; free to use code 0  
20e5				OPCODE_HEAP: equ  1 
20e5				OPCODE_EXEC: equ 2 
20e5				OPCODE_DUP: equ 3 
20e5				OPCODE_SWAP: equ 4 
20e5				OPCODE_COLN: equ 5 
20e5				OPCODE_SCOLN: equ 6 
20e5				OPCODE_DROP: equ 7 
20e5				OPCODE_DUP2: equ 8 
20e5				OPCODE_DROP2: equ 9 
20e5				OPCODE_SWAP2: equ 10 
20e5				OPCODE_AT: equ 11 
20e5				OPCODE_CAT: equ 12 
20e5				OPCODE_BANG: equ 13 
20e5				OPCODE_CBANG: equ 14 
20e5				OPCODE_SCALL: equ 15 
20e5				OPCODE_DEPTH: equ 16 
20e5				OPCODE_OVER: equ 17 
20e5				OPCODE_PAUSE: equ 18 
20e5				OPCODE_PAUSES: equ 19 
20e5				OPCODE_ROT: equ 20 
20e5			;free to reuse	OPCODE_WORDS: equ 21 
20e5			        OPCODE_NOT: equ 21 
20e5				OPCODE_UWORDS: equ 22 
20e5				OPCODE_BP: equ 23 
20e5				OPCODE_MONITOR: equ 24  
20e5				OPCODE_MALLOC: equ 25 
20e5				OPCODE_FREE: equ 26 
20e5				OPCODE_LIST: equ 27 
20e5				OPCODE_FORGET: equ 28 
20e5				OPCODE_NOP: equ 29 
20e5				OPCODE_COMO: equ 30 
20e5				OPCODE_COMC: equ 31 
20e5			;free to reuse	OPCODE_ENDCORE: equ 32 
20e5				OPCODE_AFTERSOUND: equ 33 
20e5				OPCODE_GP2: equ 34 
20e5				OPCODE_GP3: equ 35 
20e5				OPCODE_GP4: equ 36 
20e5				OPCODE_SIN: equ 37 
20e5				OPCODE_SOUT: equ 38 
20e5				OPCODE_SPIO: equ 39 
20e5				OPCODE_SPICEH: equ 40 
20e5				OPCODE_SPIOb: equ 41 
20e5				OPCODE_SPII: equ 42 
20e5				OPCODE_SESEL: equ 43 
20e5				OPCODE_CARTDEV: equ 44 
20e5			; free to reuse	OPCODE_ENDDEVICE: equ 45 
20e5				OPCODE_FB: equ 46 
20e5				OPCODE_EMIT: equ 47 
20e5				OPCODE_DOTH: equ 48 
20e5				OPCODE_DOTF: equ 49 
20e5				OPCODE_DOT: equ 50 
20e5				OPCODE_CLS: equ 51 
20e5				OPCODE_DRAW: equ 52 
20e5				OPCODE_DUMP: equ 53 
20e5				OPCODE_CDUMP: equ 54 
20e5				OPCODE_DAT: equ 55 
20e5				OPCODE_HOME: equ 56 
20e5				OPCODE_SPACE: equ 57 
20e5				OPCODE_SPACES: equ 58 
20e5				OPCODE_SCROLL: equ 59 
20e5				OPCODE_ATQ: equ 60 
20e5				OPCODE_AUTODSP: equ 61 
20e5				OPCODE_MENU: equ 62 
20e5			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
20e5				OPCODE_THEN: equ 64 
20e5				OPCODE_ELSE: equ 65 
20e5				OPCODE_DO: equ 66 
20e5				OPCODE_LOOP: equ 67 
20e5				OPCODE_I: equ 68 
20e5				OPCODE_DLOOP: equ 69  
20e5				OPCODE_REPEAT: equ 70  
20e5				OPCODE_UNTIL: equ 71 
20e5				OPCODE_ENDFLOW: equ 72 
20e5				OPCODE_WAITK: equ 73 
20e5				OPCODE_ACCEPT: equ 74 
20e5				OPCODE_EDIT: equ 75 
20e5			;free to reuse	OPCODE_ENDKEY: equ 76 
20e5				OPCODE_LZERO: equ 77 
20e5				OPCODE_TZERO: equ 78 
20e5				OPCODE_LESS: equ 79 
20e5				OPCODE_GT: equ 80 
20e5				OPCODE_EQUAL: equ 81  
20e5			;free to reuse	OPCODE_ENDLOGIC: equ 82 
20e5				OPCODE_NEG: equ 83 
20e5				OPCODE_DIV: equ 84 
20e5				OPCODE_MUL: equ 85 
20e5				OPCODE_MIN: equ 86 
20e5				OPCODE_MAX: equ 87 
20e5				OPCODE_RND16: equ 88 
20e5				OPCODE_RND8: equ 89 
20e5				OPCODE_RND: equ 90 
20e5			;free to reuse	OPCODE_ENDMATHS: equ 91  
20e5				OPCODE_BYNAME: equ 92 
20e5				OPCODE_DIR: equ 93 
20e5				OPCODE_SAVE: equ 94 
20e5				OPCODE_LOAD: equ 95 
20e5				OPCODE_BSAVE: equ 96 
20e5				OPCODE_BLOAD: equ 97 
20e5				OPCODE_SEO: equ 98  
20e5				OPCODE_SEI: equ 99 
20e5				OPCODE_SFREE: equ 100 
20e5				OPCODE_SIZE: equ 101 
20e5				OPCODE_CREATE: equ 102 
20e5				OPCODE_APPEND: equ 103 
20e5				OPCODE_SDEL: equ 104 
20e5				OPCODE_OPEN: equ 105 
20e5				OPCODE_READ: equ 106 
20e5				OPCODE_EOF: equ 106 
20e5				OPCODE_FORMAT: equ 107 
20e5				OPCODE_LABEL: equ 108 
20e5				OPCODE_LABELS: equ 109 
20e5			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
20e5				OPCODE_UPPER: equ 111 
20e5				OPCODE_LOWER: equ 112 
20e5				OPCODE_SUBSTR: equ 113 
20e5				OPCODE_LEFT: equ 114 
20e5				OPCODE_RIGHT: equ 115 
20e5				OPCODE_STR2NUM: equ 116 
20e5				OPCODE_NUM2STR: equ 117 
20e5				OPCODE_CONCAT: equ 118 
20e5				OPCODE_FIND: equ 119 
20e5				OPCODE_LEN: equ 120 
20e5				OPCODE_CHAR: equ 121 
20e5			; free to reuse	OPCODE_STRLEN: equ 122 
20e5			; free to reuse	OPCODE_ENDSTR: equ 123 
20e5				OPCODE_V0S: equ 124 
20e5				OPCODE_V0Q: equ 125 
20e5				OPCODE_V1S: equ 126 
20e5				OPCODE_V1Q: equ 127 
20e5				OPCODE_V2S: equ 128 
20e5				OPCODE_V2Q: equ 129 
20e5				OPCODE_V3S: equ 130 
20e5				OPCODE_V3Q: equ 131 
20e5			;free to reuse	OPCODE_END: equ 132 
20e5				OPCODE_ZDUP: equ 133 
20e5			 
20e5			; eof 
# End of file forth_opcodes.asm
20e5			 
20e5			include "forth_words_core.asm" 
20e5			 
20e5			; | ## Core Words 
20e5			 
20e5			;if MALLOC_4 
20e5			 
20e5			.HEAP: 
20e5				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
20e5 15				db WORD_SYS_CORE+OPCODE_HEAP             
20e6 24 21			dw .EXEC            
20e8 05				db 4 + 1 
20e9 .. 00			db "HEAP",0              
20ee				endm 
# End of macro CWHEAD
20ee			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
20ee			; | | u1 - Current number of bytes in the heap 
20ee			; | | u2 - Remaining bytes left on the heap 
20ee			; | |  
20ee			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
20ee			 
20ee			 
20ee					if DEBUG_FORTH_WORDS_KEY 
20ee						DMARK "HEP" 
20ee f5				push af  
20ef 3a 03 21			ld a, (.dmark)  
20f2 32 71 ee			ld (debug_mark),a  
20f5 3a 04 21			ld a, (.dmark+1)  
20f8 32 72 ee			ld (debug_mark+1),a  
20fb 3a 05 21			ld a, (.dmark+2)  
20fe 32 73 ee			ld (debug_mark+2),a  
2101 18 03			jr .pastdmark  
2103 ..			.dmark: db "HEP"  
2106 f1			.pastdmark: pop af  
2107			endm  
# End of macro DMARK
2107						CALLMONITOR 
2107 cd ae 15			call break_point_state  
210a				endm  
# End of macro CALLMONITOR
210a					endif 
210a 2a 1d 5f				ld hl, (free_list )      
210d 11 22 5f				ld de, heap_start 
2110			 
2110 ed 52				sbc hl, de  
2112			 
2112 cd 1f 1c				call forth_push_numhl 
2115			 
2115			 
2115 ed 5b 1d 5f			ld de, (free_list )      
2119 21 e5 e2				ld hl, heap_end 
211c			 
211c ed 52				sbc hl, de 
211e			 
211e cd 1f 1c				call forth_push_numhl 
2121					 
2121			 
2121					 
2121			 
2121			 
2121			 
2121					NEXTW 
2121 c3 8d 1f			jp macro_next 
2124				endm 
# End of macro NEXTW
2124			;endif 
2124			 
2124			.EXEC: 
2124			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2124			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2124			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2124			;; > > 
2124			;; > >   
2124			;	STACKFRAME OFF $5efe $5f9f 
2124			; 
2124			;		if DEBUG_FORTH_WORDS_KEY 
2124			;			DMARK "EXE" 
2124			;			CALLMONITOR 
2124			;		endif 
2124			; 
2124			;	FORTH_DSP_VALUEHL 
2124			; 
2124			;	FORTH_DSP_POP 
2124			; 
2124			;		if DEBUG_FORTH_WORDS 
2124			;			DMARK "EX1" 
2124			;			CALLMONITOR 
2124			;		endif 
2124			;;	ld e,(hl) 
2124			;;	inc hl 
2124			;;	ld d,(hl) 
2124			;;	ex de,hl 
2124			; 
2124			;;		if DEBUG_FORTH_WORDS 
2124			;;			DMARK "EX2" 
2124			;;			CALLMONITOR 
2124			;;		endif 
2124			;	push hl 
2124			; 
2124			;	;ld a, 0 
2124			;	;ld a, FORTH_END_BUFFER 
2124			;	call strlenz 
2124			;	inc hl   ; include zero term to copy 
2124			;	inc hl   ; include term 
2124			;	inc hl   ; include term 
2124			;	ld b,0 
2124			;	ld c,l 
2124			;	pop hl 
2124			;	ld de, execscratch 
2124			;		if DEBUG_FORTH_WORDS 
2124			;			DMARK "EX3" 
2124			;			CALLMONITOR 
2124			;		endif 
2124			;	ldir 
2124			; 
2124			; 
2124			;	ld hl, execscratch 
2124			; 
2124			;		if DEBUG_FORTH_WORDS 
2124			;			DMARK "EXe" 
2124			;			CALLMONITOR 
2124			;		endif 
2124			; 
2124			;	call forthparse 
2124			;	call forthexec 
2124			;;	call forthexec_cleanup 
2124			;;	call forthparse 
2124			;;	call forthexec 
2124			; 
2124			;	STACKFRAMECHK OFF $5efe $5f9f 
2124			; 
2124			;	; an immediate word so no need to process any more words 
2124			;	ret 
2124			;	NEXTW 
2124			 
2124			; dead code - old version  
2124			;	FORTH_RSP_NEXT 
2124			 
2124			;  
2124			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2124			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2124			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2124			;	push hl 
2124			;	push de 
2124			;	push bc 
2124			; 
2124			; 
2124			;		if DEBUG_FORTH_WORDS_KEY 
2124			;			DMARK "EXR" 
2124			;			CALLMONITOR 
2124			;		endif 
2124			; 
2124			; 
2124			; 
2124			;	;v5 FORTH_DSP_VALUE 
2124			;	FORTH_DSP_VALUEHL 
2124			; 
2124			;	; TODO do string type checks 
2124			; 
2124			;;v5	inc hl   ; skip type 
2124			; 
2124			;	push hl  ; source code  
2124			;		if DEBUG_FORTH_WORDS 
2124			;			DMARK "EX1" 
2124			;			CALLMONITOR 
2124			;		endif 
2124			;	ld a, 0 
2124			;	call strlent 
2124			; 
2124			;	inc hl 
2124			;	inc hl 
2124			;	inc hl 
2124			;	inc hl 
2124			; 
2124			;	push hl    ; size 
2124			; 
2124			;		if DEBUG_FORTH_WORDS 
2124			;			DMARK "EX2" 
2124			;			CALLMONITOR 
2124			;		endif 
2124			;	call malloc 
2124			; 
2124			;	ex de, hl    ; de now contains malloc area 
2124			;	pop bc   	; get byte count 
2124			;	pop hl      ; get string to copy 
2124			; 
2124			;	push de     ; save malloc for free later 
2124			; 
2124			;		if DEBUG_FORTH_WORDS 
2124			;			DMARK "EX3" 
2124			;			CALLMONITOR 
2124			;		endif 
2124			;	ldir       ; duplicate string 
2124			; 
2124			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2124			;	 
2124			;	; TODO fix the parse would be better than this...  
2124			;	ex de, hl 
2124			;	dec hl 
2124			;	ld a, 0 
2124			;	ld (hl), a 
2124			;	dec hl 
2124			;	ld a, ' ' 
2124			;	ld (hl), a 
2124			;	dec hl 
2124			;	ld (hl), a 
2124			; 
2124			;	dec hl 
2124			;	ld (hl), a 
2124			; 
2124			; 
2124			;	FORTH_DSP_POP  
2124			; 
2124			;	pop hl     
2124			;	push hl    ; save malloc area 
2124			; 
2124			;		if DEBUG_FORTH_WORDS 
2124			;			DMARK "EX4" 
2124			;			CALLMONITOR 
2124			;		endif 
2124			; 
2124			;	call forthparse 
2124			;	call forthexec 
2124			;	 
2124			;	pop hl 
2124			;	if DEBUG_FORTH_WORDS 
2124			;		DMARK "EX5" 
2124			;		CALLMONITOR 
2124			;	endif 
2124			; 
2124			;	if FORTH_ENABLE_FREE 
2124			;	call free 
2124			;	endif 
2124			; 
2124			;	if DEBUG_FORTH_WORDS 
2124			;		DMARK "EX6" 
2124			;		CALLMONITOR 
2124			;	endif 
2124			; 
2124			;	pop bc 
2124			;	pop de 
2124			;	pop hl 
2124			;;	FORTH_RSP_POP	  
2124			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2124			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2124			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2124			; 
2124			;	if DEBUG_FORTH_WORDS 
2124			;		DMARK "EX7" 
2124			;		CALLMONITOR 
2124			;	endif 
2124			;	NEXTW 
2124			 
2124			;.STKEXEC: 
2124			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2124			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2124			; 
2124			; 
2124			;		if DEBUG_FORTH_WORDS_KEY 
2124			;			DMARK "STX" 
2124			;			CALLMONITOR 
2124			;		endif 
2124			; 
2124			;	FORTH_DSP_VALUEHL 
2124			; 
2124			;	ld (store_tmp1), hl    ; count 
2124			; 
2124			;	FORTH_DSP_POP 
2124			;.stkexec1: 
2124			;	ld hl, (store_tmp1)   ; count 
2124			;	ld a, 0 
2124			;	cp l 
2124			;	ret z 
2124			; 
2124			;	dec hl 
2124			;	ld (store_tmp1), hl    ; count 
2124			;	 
2124			;	FORTH_DSP_VALUEHL 
2124			;	push hl 
2124			;	 
2124			;		if DEBUG_FORTH_WORDS 
2124			;			DMARK "EXp" 
2124			;			CALLMONITOR 
2124			;		endif 
2124			;	FORTH_DSP_POP 
2124			; 
2124			;	call strlenz 
2124			;	inc hl   ; include zero term to copy 
2124			;	inc hl   ; include zero term to copy 
2124			;	inc hl   ; include zero term to copy 
2124			;	ld b,0 
2124			;	ld c,l 
2124			;	pop hl 
2124			;	ld de, execscratch 
2124			;		if DEBUG_FORTH_WORDS 
2124			;			DMARK "EX3" 
2124			;			CALLMONITOR 
2124			;		endif 
2124			;	ldir 
2124			; 
2124			; 
2124			;	ld hl, execscratch 
2124			; 
2124			;		if DEBUG_FORTH_WORDS 
2124			;			DMARK "EXP" 
2124			;			CALLMONITOR 
2124			;		endif 
2124			; 
2124			;	call forthparse 
2124			;	ld hl, execscratch 
2124			;		if DEBUG_FORTH_WORDS 
2124			;			DMARK "EXx" 
2124			;			CALLMONITOR 
2124			;		endif 
2124			;	call forthexec 
2124			; 
2124			;	jp .stkexec1 
2124			; 
2124			;	ret 
2124			 
2124			 
2124			.DUP: 
2124				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2124 17				db WORD_SYS_CORE+OPCODE_DUP             
2125 9a 21			dw .ZDUP            
2127 04				db 3 + 1 
2128 .. 00			db "DUP",0              
212c				endm 
# End of macro CWHEAD
212c			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
212c			 
212c					if DEBUG_FORTH_WORDS_KEY 
212c						DMARK "DUP" 
212c f5				push af  
212d 3a 41 21			ld a, (.dmark)  
2130 32 71 ee			ld (debug_mark),a  
2133 3a 42 21			ld a, (.dmark+1)  
2136 32 72 ee			ld (debug_mark+1),a  
2139 3a 43 21			ld a, (.dmark+2)  
213c 32 73 ee			ld (debug_mark+2),a  
213f 18 03			jr .pastdmark  
2141 ..			.dmark: db "DUP"  
2144 f1			.pastdmark: pop af  
2145			endm  
# End of macro DMARK
2145						CALLMONITOR 
2145 cd ae 15			call break_point_state  
2148				endm  
# End of macro CALLMONITOR
2148					endif 
2148			 
2148					FORTH_DSP 
2148 cd dc 1d			call macro_forth_dsp 
214b				endm 
# End of macro FORTH_DSP
214b			 
214b 7e					ld a, (HL) 
214c fe 01				cp DS_TYPE_STR 
214e 20 25				jr nz, .dupinum 
2150			 
2150					; push another string 
2150			 
2150					FORTH_DSP_VALUEHL     		 
2150 cd 16 1e			call macro_dsp_valuehl 
2153				endm 
# End of macro FORTH_DSP_VALUEHL
2153			 
2153				if DEBUG_FORTH_WORDS 
2153					DMARK "DUs" 
2153 f5				push af  
2154 3a 68 21			ld a, (.dmark)  
2157 32 71 ee			ld (debug_mark),a  
215a 3a 69 21			ld a, (.dmark+1)  
215d 32 72 ee			ld (debug_mark+1),a  
2160 3a 6a 21			ld a, (.dmark+2)  
2163 32 73 ee			ld (debug_mark+2),a  
2166 18 03			jr .pastdmark  
2168 ..			.dmark: db "DUs"  
216b f1			.pastdmark: pop af  
216c			endm  
# End of macro DMARK
216c					CALLMONITOR 
216c cd ae 15			call break_point_state  
216f				endm  
# End of macro CALLMONITOR
216f				endif 
216f cd 8d 1c				call forth_push_str 
2172			 
2172					NEXTW 
2172 c3 8d 1f			jp macro_next 
2175				endm 
# End of macro NEXTW
2175			 
2175			 
2175			.dupinum: 
2175					 
2175			 
2175			 
2175					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2175 cd 16 1e			call macro_dsp_valuehl 
2178				endm 
# End of macro FORTH_DSP_VALUEHL
2178			 
2178				; TODO add floating point number detection 
2178			 
2178				if DEBUG_FORTH_WORDS 
2178					DMARK "DUi" 
2178 f5				push af  
2179 3a 8d 21			ld a, (.dmark)  
217c 32 71 ee			ld (debug_mark),a  
217f 3a 8e 21			ld a, (.dmark+1)  
2182 32 72 ee			ld (debug_mark+1),a  
2185 3a 8f 21			ld a, (.dmark+2)  
2188 32 73 ee			ld (debug_mark+2),a  
218b 18 03			jr .pastdmark  
218d ..			.dmark: db "DUi"  
2190 f1			.pastdmark: pop af  
2191			endm  
# End of macro DMARK
2191					CALLMONITOR 
2191 cd ae 15			call break_point_state  
2194				endm  
# End of macro CALLMONITOR
2194				endif 
2194			 
2194 cd 1f 1c				call forth_push_numhl 
2197					NEXTW 
2197 c3 8d 1f			jp macro_next 
219a				endm 
# End of macro NEXTW
219a			.ZDUP: 
219a				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
219a 99				db WORD_SYS_CORE+OPCODE_ZDUP             
219b d2 21			dw .SWAP            
219d 05				db 4 + 1 
219e .. 00			db "?DUP",0              
21a3				endm 
# End of macro CWHEAD
21a3			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
21a3			 
21a3					if DEBUG_FORTH_WORDS_KEY 
21a3						DMARK "qDU" 
21a3 f5				push af  
21a4 3a b8 21			ld a, (.dmark)  
21a7 32 71 ee			ld (debug_mark),a  
21aa 3a b9 21			ld a, (.dmark+1)  
21ad 32 72 ee			ld (debug_mark+1),a  
21b0 3a ba 21			ld a, (.dmark+2)  
21b3 32 73 ee			ld (debug_mark+2),a  
21b6 18 03			jr .pastdmark  
21b8 ..			.dmark: db "qDU"  
21bb f1			.pastdmark: pop af  
21bc			endm  
# End of macro DMARK
21bc						CALLMONITOR 
21bc cd ae 15			call break_point_state  
21bf				endm  
# End of macro CALLMONITOR
21bf					endif 
21bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21bf cd 16 1e			call macro_dsp_valuehl 
21c2				endm 
# End of macro FORTH_DSP_VALUEHL
21c2			 
21c2 e5					push hl 
21c3			 
21c3					; is it a zero? 
21c3			 
21c3 3e 00				ld a, 0 
21c5 84					add h 
21c6 85					add l 
21c7			 
21c7 e1					pop hl 
21c8			 
21c8 fe 00				cp 0 
21ca 28 03				jr z, .dup2orig 
21cc			 
21cc			 
21cc cd 1f 1c				call forth_push_numhl 
21cf			 
21cf			 
21cf				; TODO add floating point number detection 
21cf			 
21cf			.dup2orig: 
21cf			 
21cf					NEXTW 
21cf c3 8d 1f			jp macro_next 
21d2				endm 
# End of macro NEXTW
21d2			.SWAP: 
21d2				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
21d2 18				db WORD_SYS_CORE+OPCODE_SWAP             
21d3 11 22			dw .COLN            
21d5 05				db 4 + 1 
21d6 .. 00			db "SWAP",0              
21db				endm 
# End of macro CWHEAD
21db			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
21db					if DEBUG_FORTH_WORDS_KEY 
21db						DMARK "SWP" 
21db f5				push af  
21dc 3a f0 21			ld a, (.dmark)  
21df 32 71 ee			ld (debug_mark),a  
21e2 3a f1 21			ld a, (.dmark+1)  
21e5 32 72 ee			ld (debug_mark+1),a  
21e8 3a f2 21			ld a, (.dmark+2)  
21eb 32 73 ee			ld (debug_mark+2),a  
21ee 18 03			jr .pastdmark  
21f0 ..			.dmark: db "SWP"  
21f3 f1			.pastdmark: pop af  
21f4			endm  
# End of macro DMARK
21f4						CALLMONITOR 
21f4 cd ae 15			call break_point_state  
21f7				endm  
# End of macro CALLMONITOR
21f7					endif 
21f7			 
21f7					FORTH_DSP_VALUEHL 
21f7 cd 16 1e			call macro_dsp_valuehl 
21fa				endm 
# End of macro FORTH_DSP_VALUEHL
21fa e5					push hl     ; w2 
21fb			 
21fb					FORTH_DSP_POP 
21fb cd ce 1e			call macro_forth_dsp_pop 
21fe				endm 
# End of macro FORTH_DSP_POP
21fe			 
21fe					FORTH_DSP_VALUEHL 
21fe cd 16 1e			call macro_dsp_valuehl 
2201				endm 
# End of macro FORTH_DSP_VALUEHL
2201			 
2201					FORTH_DSP_POP 
2201 cd ce 1e			call macro_forth_dsp_pop 
2204				endm 
# End of macro FORTH_DSP_POP
2204			 
2204 d1					pop de     ; w2	, hl = w1 
2205			 
2205 eb					ex de, hl 
2206 d5					push de 
2207			 
2207 cd 1f 1c				call forth_push_numhl 
220a			 
220a e1					pop hl 
220b			 
220b cd 1f 1c				call forth_push_numhl 
220e					 
220e			 
220e					NEXTW 
220e c3 8d 1f			jp macro_next 
2211				endm 
# End of macro NEXTW
2211			.COLN: 
2211				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2211 19				db WORD_SYS_CORE+OPCODE_COLN             
2212 9d 23			dw .SCOLN            
2214 02				db 1 + 1 
2215 .. 00			db ":",0              
2217				endm 
# End of macro CWHEAD
2217			; | : ( -- )         Create new word | DONE 
2217			 
2217					if DEBUG_FORTH_WORDS_KEY 
2217						DMARK "CLN" 
2217 f5				push af  
2218 3a 2c 22			ld a, (.dmark)  
221b 32 71 ee			ld (debug_mark),a  
221e 3a 2d 22			ld a, (.dmark+1)  
2221 32 72 ee			ld (debug_mark+1),a  
2224 3a 2e 22			ld a, (.dmark+2)  
2227 32 73 ee			ld (debug_mark+2),a  
222a 18 03			jr .pastdmark  
222c ..			.dmark: db "CLN"  
222f f1			.pastdmark: pop af  
2230			endm  
# End of macro DMARK
2230						CALLMONITOR 
2230 cd ae 15			call break_point_state  
2233				endm  
# End of macro CALLMONITOR
2233					endif 
2233				STACKFRAME OFF $8efe $989f 
2233				if DEBUG_STACK_IMB 
2233					if OFF 
2233						exx 
2233						ld de, $8efe 
2233						ld a, d 
2233						ld hl, curframe 
2233						call hexout 
2233						ld a, e 
2233						ld hl, curframe+2 
2233						call hexout 
2233						ld hl, $8efe 
2233						push hl 
2233						ld hl, $989f 
2233						push hl 
2233						exx 
2233					endif 
2233				endif 
2233			endm 
# End of macro STACKFRAME
2233				; get parser buffer length  of new word 
2233			 
2233				 
2233			 
2233					; move tok past this to start of name defintition 
2233					; TODO get word to define 
2233					; TODO Move past word token 
2233					; TODO get length of string up to the ';' 
2233			 
2233 2a 00 e6			ld hl, (os_tok_ptr) 
2236 23				inc hl 
2237 23				inc hl 
2238			 
2238 3e 3b			ld a, ';' 
223a cd 16 12			call strlent 
223d			 
223d 7d				ld a,l 
223e 32 fb e2			ld (os_new_parse_len), a 
2241			 
2241			 
2241			if DEBUG_FORTH_UWORD 
2241 ed 5b 00 e6		ld de, (os_tok_ptr) 
2245						DMARK ":01" 
2245 f5				push af  
2246 3a 5a 22			ld a, (.dmark)  
2249 32 71 ee			ld (debug_mark),a  
224c 3a 5b 22			ld a, (.dmark+1)  
224f 32 72 ee			ld (debug_mark+1),a  
2252 3a 5c 22			ld a, (.dmark+2)  
2255 32 73 ee			ld (debug_mark+2),a  
2258 18 03			jr .pastdmark  
225a ..			.dmark: db ":01"  
225d f1			.pastdmark: pop af  
225e			endm  
# End of macro DMARK
225e				CALLMONITOR 
225e cd ae 15			call break_point_state  
2261				endm  
# End of macro CALLMONITOR
2261			endif 
2261			 
2261			; 
2261			;  new word memory layout: 
2261			;  
2261			;    : adg 6666 ;  
2261			; 
2261			;    db   1     ; user defined word  
2261 23				inc hl    
2262			;    dw   sysdict 
2262 23				inc hl 
2263 23				inc hl 
2264			;    db <word len>+1 (for null) 
2264 23				inc hl 
2265			;    db .... <word> 
2265			; 
2265			 
2265 23				inc hl    ; some extras for the word preamble before the above 
2266 23				inc hl 
2267 23				inc hl 
2268 23				inc hl 
2269 23				inc hl 
226a 23				inc hl 
226b 23				inc hl  
226c 23				inc hl 
226d 23				inc hl 
226e 23				inc hl 
226f 23				inc hl 
2270 23				inc hl 
2271 23				inc hl 
2272 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2273			;       exec word buffer 
2273			;	<ptr word>   
2273 23				inc hl 
2274 23				inc hl 
2275			;       <word list><null term> 7F final term 
2275			 
2275			 
2275			if DEBUG_FORTH_UWORD 
2275						DMARK ":02" 
2275 f5				push af  
2276 3a 8a 22			ld a, (.dmark)  
2279 32 71 ee			ld (debug_mark),a  
227c 3a 8b 22			ld a, (.dmark+1)  
227f 32 72 ee			ld (debug_mark+1),a  
2282 3a 8c 22			ld a, (.dmark+2)  
2285 32 73 ee			ld (debug_mark+2),a  
2288 18 03			jr .pastdmark  
228a ..			.dmark: db ":02"  
228d f1			.pastdmark: pop af  
228e			endm  
# End of macro DMARK
228e				CALLMONITOR 
228e cd ae 15			call break_point_state  
2291				endm  
# End of macro CALLMONITOR
2291			endif 
2291			 
2291				 
2291					; malloc the size 
2291			 
2291 cd 74 12				call malloc 
2294 22 fd e2				ld (os_new_malloc), hl     ; save malloc start 
2297			 
2297			;    db   1     ; user defined word  
2297 3e 01				ld a, WORD_SYS_UWORD  
2299 77					ld (hl), a 
229a				 
229a 23				inc hl    
229b			;    dw   sysdict 
229b 11 e5 20			ld de, sysdict       ; continue on with the scan to the system dict 
229e 73				ld (hl), e 
229f 23				inc hl 
22a0 72				ld (hl), d 
22a1 23				inc hl 
22a2			 
22a2			 
22a2			;    Setup dict word 
22a2			 
22a2 23				inc hl 
22a3 22 f7 e2			ld (os_new_work_ptr), hl     ; save start of dict word  
22a6			 
22a6				; 1. get length of dict word 
22a6			 
22a6			 
22a6 2a 00 e6			ld hl, (os_tok_ptr) 
22a9 23				inc hl 
22aa 23				inc hl    ; position to start of dict word 
22ab 3e 00			ld a, 0 
22ad cd 16 12			call strlent 
22b0			 
22b0			 
22b0 23				inc hl    ; to include null??? 
22b1			 
22b1				; write length of dict word 
22b1			 
22b1 ed 5b f7 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
22b5 1b				dec de 
22b6 eb				ex de, hl 
22b7 73				ld (hl), e 
22b8 eb				ex de, hl 
22b9			 
22b9				 
22b9			 
22b9				; copy  
22b9 4d				ld c, l 
22ba 06 00			ld b, 0 
22bc ed 5b f7 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
22c0 2a 00 e6			ld hl, (os_tok_ptr) 
22c3 23				inc hl 
22c4 23				inc hl    ; position to start of dict word 
22c5				 
22c5			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
22c5				 
22c5				; TODO need to convert word to upper case 
22c5			 
22c5			ucasetok:	 
22c5 7e				ld a,(hl) 
22c6 cd 02 12			call toUpper 
22c9 77				ld (hl),a 
22ca ed a0			ldi 
22cc f2 c5 22		 	jp p, ucasetok 
22cf			 
22cf			 
22cf			 
22cf				; de now points to start of where the word body code should be placed 
22cf ed 53 f7 e2		ld (os_new_work_ptr), de 
22d3				; hl now points to the words to throw at forthexec which needs to be copied 
22d3 22 f5 e2			ld (os_new_src_ptr), hl 
22d6			 
22d6				; TODO add 'call to forthexec' 
22d6			 
22d6			if DEBUG_FORTH_UWORD 
22d6 c5				push bc 
22d7 ed 4b fd e2		ld bc, (os_new_malloc) 
22db						DMARK ":0x" 
22db f5				push af  
22dc 3a f0 22			ld a, (.dmark)  
22df 32 71 ee			ld (debug_mark),a  
22e2 3a f1 22			ld a, (.dmark+1)  
22e5 32 72 ee			ld (debug_mark+1),a  
22e8 3a f2 22			ld a, (.dmark+2)  
22eb 32 73 ee			ld (debug_mark+2),a  
22ee 18 03			jr .pastdmark  
22f0 ..			.dmark: db ":0x"  
22f3 f1			.pastdmark: pop af  
22f4			endm  
# End of macro DMARK
22f4				CALLMONITOR 
22f4 cd ae 15			call break_point_state  
22f7				endm  
# End of macro CALLMONITOR
22f7 c1				pop bc 
22f8			endif 
22f8			 
22f8			 
22f8				; create word preamble which should be: 
22f8			 
22f8			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
22f8			 
22f8				;    ld hl, <word code> 
22f8				;    jp user_exec 
22f8			        ;    <word code bytes> 
22f8			 
22f8			 
22f8			;	inc de     ; TODO ??? or are we already past the word's null 
22f8 eb				ex de, hl 
22f9			 
22f9 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
22fb			 
22fb 23				inc hl 
22fc 22 f1 e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
22ff 23				inc hl 
2300			 
2300 23				inc hl 
2301 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2303			 
2303 01 5d 47			ld bc, user_exec 
2306 23				inc hl 
2307 71				ld (hl), c     ; poke address of user_exec 
2308 23				inc hl 
2309 70				ld (hl), b     
230a			 ; 
230a			;	inc hl 
230a			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
230a			; 
230a			; 
230a			;	ld bc, macro_forth_rsp_next 
230a			;	inc hl 
230a			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
230a			;	inc hl 
230a			;	ld (hl), b     
230a			 ; 
230a			;	inc hl 
230a			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
230a			; 
230a			; 
230a			;	inc hl 
230a			;	ld bc, forthexec 
230a			;	ld (hl), c     ; poke address of forthexec 
230a			;	inc hl 
230a			;	ld (hl), b      
230a			; 
230a			;	inc hl 
230a			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
230a			; 
230a			;	ld bc, user_dict_next 
230a			;	inc hl 
230a			;	ld (hl), c     ; poke address of forthexec 
230a			;	inc hl 
230a			;	ld (hl), b      
230a			 
230a				; hl is now where we need to copy the word byte data to save this 
230a			 
230a 23				inc hl 
230b 22 f3 e2			ld (os_new_exec), hl 
230e				 
230e				; copy definition 
230e			 
230e eb				ex de, hl 
230f			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
230f			;	inc de    ; skip the PC for this parse 
230f 3a fb e2			ld a, (os_new_parse_len) 
2312 4f				ld c, a 
2313 06 00			ld b, 0 
2315 ed b0			ldir		 ; copy defintion 
2317			 
2317			 
2317				; poke the address of where the new word bytes live for forthexec 
2317			 
2317 2a f1 e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
231a			 
231a ed 5b f3 e2		ld de, (os_new_exec)      
231e				 
231e 73				ld (hl), e 
231f 23				inc hl 
2320 72				ld (hl), d 
2321			 
2321					; TODO copy last user dict word next link to this word 
2321					; TODO update last user dict word to point to this word 
2321			; 
2321			; hl f923 de 812a ; bc 811a 
2321			 
2321			if DEBUG_FORTH_UWORD 
2321 c5				push bc 
2322 ed 4b fd e2		ld bc, (os_new_malloc) 
2326						DMARK ":0A" 
2326 f5				push af  
2327 3a 3b 23			ld a, (.dmark)  
232a 32 71 ee			ld (debug_mark),a  
232d 3a 3c 23			ld a, (.dmark+1)  
2330 32 72 ee			ld (debug_mark+1),a  
2333 3a 3d 23			ld a, (.dmark+2)  
2336 32 73 ee			ld (debug_mark+2),a  
2339 18 03			jr .pastdmark  
233b ..			.dmark: db ":0A"  
233e f1			.pastdmark: pop af  
233f			endm  
# End of macro DMARK
233f				CALLMONITOR 
233f cd ae 15			call break_point_state  
2342				endm  
# End of macro CALLMONITOR
2342 c1				pop bc 
2343			endif 
2343			if DEBUG_FORTH_UWORD 
2343 c5				push bc 
2344 ed 4b fd e2		ld bc, (os_new_malloc) 
2348 03				inc bc 
2349 03				inc bc 
234a 03				inc bc 
234b 03				inc bc 
234c 03				inc bc 
234d 03				inc bc 
234e 03				inc bc 
234f 03				inc bc 
2350			 
2350						DMARK ":0B" 
2350 f5				push af  
2351 3a 65 23			ld a, (.dmark)  
2354 32 71 ee			ld (debug_mark),a  
2357 3a 66 23			ld a, (.dmark+1)  
235a 32 72 ee			ld (debug_mark+1),a  
235d 3a 67 23			ld a, (.dmark+2)  
2360 32 73 ee			ld (debug_mark+2),a  
2363 18 03			jr .pastdmark  
2365 ..			.dmark: db ":0B"  
2368 f1			.pastdmark: pop af  
2369			endm  
# End of macro DMARK
2369				CALLMONITOR 
2369 cd ae 15			call break_point_state  
236c				endm  
# End of macro CALLMONITOR
236c c1				pop bc 
236d			endif 
236d			 
236d			; update word dict linked list for new word 
236d			 
236d			 
236d 2a fc e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2370 23			inc hl     ; move to next work linked list ptr 
2371			 
2371 ed 5b fd e2	ld de, (os_new_malloc)		 ; new next word 
2375 73			ld (hl), e 
2376 23			inc hl 
2377 72			ld (hl), d 
2378			 
2378			if DEBUG_FORTH_UWORD 
2378 ed 4b fc e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
237c			endif 
237c			 
237c ed 53 fc e5	ld (os_last_new_uword), de      ; update last new uword ptr 
2380			 
2380			 
2380			if DEBUG_FORTH_UWORD 
2380						DMARK ":0+" 
2380 f5				push af  
2381 3a 95 23			ld a, (.dmark)  
2384 32 71 ee			ld (debug_mark),a  
2387 3a 96 23			ld a, (.dmark+1)  
238a 32 72 ee			ld (debug_mark+1),a  
238d 3a 97 23			ld a, (.dmark+2)  
2390 32 73 ee			ld (debug_mark+2),a  
2393 18 03			jr .pastdmark  
2395 ..			.dmark: db ":0+"  
2398 f1			.pastdmark: pop af  
2399			endm  
# End of macro DMARK
2399				CALLMONITOR 
2399 cd ae 15			call break_point_state  
239c				endm  
# End of macro CALLMONITOR
239c			endif 
239c			 
239c				STACKFRAMECHK OFF $8efe $989f 
239c				if DEBUG_STACK_IMB 
239c					if OFF 
239c						exx 
239c						ld hl, $989f 
239c						pop de   ; $989f 
239c						call cmp16 
239c						jr nz, .spnosame 
239c						ld hl, $8efe 
239c						pop de   ; $8efe 
239c						call cmp16 
239c						jr z, .spfrsame 
239c						.spnosame: call showsperror 
239c						.spfrsame: nop 
239c						exx 
239c					endif 
239c				endif 
239c			endm 
# End of macro STACKFRAMECHK
239c			 
239c c9			ret    ; dont process any remaining parser tokens as they form new word 
239d			 
239d			 
239d			 
239d			 
239d			;		NEXT 
239d			.SCOLN: 
239d			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
239d 06				db OPCODE_SCOLN 
239e e9 23			dw .DROP 
23a0 02				db 2 
23a1 .. 00			db ";",0           
23a3			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
23a3					if DEBUG_FORTH_WORDS_KEY 
23a3						DMARK "SCN" 
23a3 f5				push af  
23a4 3a b8 23			ld a, (.dmark)  
23a7 32 71 ee			ld (debug_mark),a  
23aa 3a b9 23			ld a, (.dmark+1)  
23ad 32 72 ee			ld (debug_mark+1),a  
23b0 3a ba 23			ld a, (.dmark+2)  
23b3 32 73 ee			ld (debug_mark+2),a  
23b6 18 03			jr .pastdmark  
23b8 ..			.dmark: db "SCN"  
23bb f1			.pastdmark: pop af  
23bc			endm  
# End of macro DMARK
23bc						CALLMONITOR 
23bc cd ae 15			call break_point_state  
23bf				endm  
# End of macro CALLMONITOR
23bf					endif 
23bf					FORTH_RSP_TOS 
23bf cd dd 1b			call macro_forth_rsp_tos 
23c2				endm 
# End of macro FORTH_RSP_TOS
23c2 e5					push hl 
23c3					FORTH_RSP_POP 
23c3 cd e7 1b			call macro_forth_rsp_pop 
23c6				endm 
# End of macro FORTH_RSP_POP
23c6 e1					pop hl 
23c7			;		ex de,hl 
23c7 22 00 e6				ld (os_tok_ptr),hl 
23ca			 
23ca			if DEBUG_FORTH_UWORD 
23ca						DMARK "SCL" 
23ca f5				push af  
23cb 3a df 23			ld a, (.dmark)  
23ce 32 71 ee			ld (debug_mark),a  
23d1 3a e0 23			ld a, (.dmark+1)  
23d4 32 72 ee			ld (debug_mark+1),a  
23d7 3a e1 23			ld a, (.dmark+2)  
23da 32 73 ee			ld (debug_mark+2),a  
23dd 18 03			jr .pastdmark  
23df ..			.dmark: db "SCL"  
23e2 f1			.pastdmark: pop af  
23e3			endm  
# End of macro DMARK
23e3				CALLMONITOR 
23e3 cd ae 15			call break_point_state  
23e6				endm  
# End of macro CALLMONITOR
23e6			endif 
23e6					NEXTW 
23e6 c3 8d 1f			jp macro_next 
23e9				endm 
# End of macro NEXTW
23e9			 
23e9			.DROP: 
23e9				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
23e9 1b				db WORD_SYS_CORE+OPCODE_DROP             
23ea 14 24			dw .DUP2            
23ec 05				db 4 + 1 
23ed .. 00			db "DROP",0              
23f2				endm 
# End of macro CWHEAD
23f2			; | DROP ( w -- )   drop the TOS item   | DONE 
23f2					if DEBUG_FORTH_WORDS_KEY 
23f2						DMARK "DRP" 
23f2 f5				push af  
23f3 3a 07 24			ld a, (.dmark)  
23f6 32 71 ee			ld (debug_mark),a  
23f9 3a 08 24			ld a, (.dmark+1)  
23fc 32 72 ee			ld (debug_mark+1),a  
23ff 3a 09 24			ld a, (.dmark+2)  
2402 32 73 ee			ld (debug_mark+2),a  
2405 18 03			jr .pastdmark  
2407 ..			.dmark: db "DRP"  
240a f1			.pastdmark: pop af  
240b			endm  
# End of macro DMARK
240b						CALLMONITOR 
240b cd ae 15			call break_point_state  
240e				endm  
# End of macro CALLMONITOR
240e					endif 
240e					FORTH_DSP_POP 
240e cd ce 1e			call macro_forth_dsp_pop 
2411				endm 
# End of macro FORTH_DSP_POP
2411					NEXTW 
2411 c3 8d 1f			jp macro_next 
2414				endm 
# End of macro NEXTW
2414			.DUP2: 
2414				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2414 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2415 59 24			dw .DROP2            
2417 05				db 4 + 1 
2418 .. 00			db "2DUP",0              
241d				endm 
# End of macro CWHEAD
241d			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
241d					if DEBUG_FORTH_WORDS_KEY 
241d						DMARK "2DU" 
241d f5				push af  
241e 3a 32 24			ld a, (.dmark)  
2421 32 71 ee			ld (debug_mark),a  
2424 3a 33 24			ld a, (.dmark+1)  
2427 32 72 ee			ld (debug_mark+1),a  
242a 3a 34 24			ld a, (.dmark+2)  
242d 32 73 ee			ld (debug_mark+2),a  
2430 18 03			jr .pastdmark  
2432 ..			.dmark: db "2DU"  
2435 f1			.pastdmark: pop af  
2436			endm  
# End of macro DMARK
2436						CALLMONITOR 
2436 cd ae 15			call break_point_state  
2439				endm  
# End of macro CALLMONITOR
2439					endif 
2439					FORTH_DSP_VALUEHL 
2439 cd 16 1e			call macro_dsp_valuehl 
243c				endm 
# End of macro FORTH_DSP_VALUEHL
243c e5					push hl      ; 2 
243d			 
243d					FORTH_DSP_POP 
243d cd ce 1e			call macro_forth_dsp_pop 
2440				endm 
# End of macro FORTH_DSP_POP
2440					 
2440					FORTH_DSP_VALUEHL 
2440 cd 16 1e			call macro_dsp_valuehl 
2443				endm 
# End of macro FORTH_DSP_VALUEHL
2443			;		push hl      ; 1 
2443			 
2443					FORTH_DSP_POP 
2443 cd ce 1e			call macro_forth_dsp_pop 
2446				endm 
# End of macro FORTH_DSP_POP
2446			 
2446			;		pop hl       ; 1 
2446 d1					pop de       ; 2 
2447			 
2447 cd 1f 1c				call forth_push_numhl 
244a eb					ex de, hl 
244b cd 1f 1c				call forth_push_numhl 
244e			 
244e					 
244e eb					ex de, hl 
244f			 
244f cd 1f 1c				call forth_push_numhl 
2452 eb					ex de, hl 
2453 cd 1f 1c				call forth_push_numhl 
2456			 
2456			 
2456					NEXTW 
2456 c3 8d 1f			jp macro_next 
2459				endm 
# End of macro NEXTW
2459			.DROP2: 
2459				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2459 1d				db WORD_SYS_CORE+OPCODE_DROP2             
245a 88 24			dw .SWAP2            
245c 06				db 5 + 1 
245d .. 00			db "2DROP",0              
2463				endm 
# End of macro CWHEAD
2463			; | 2DROP ( w w -- )    Double drop | DONE 
2463					if DEBUG_FORTH_WORDS_KEY 
2463						DMARK "2DR" 
2463 f5				push af  
2464 3a 78 24			ld a, (.dmark)  
2467 32 71 ee			ld (debug_mark),a  
246a 3a 79 24			ld a, (.dmark+1)  
246d 32 72 ee			ld (debug_mark+1),a  
2470 3a 7a 24			ld a, (.dmark+2)  
2473 32 73 ee			ld (debug_mark+2),a  
2476 18 03			jr .pastdmark  
2478 ..			.dmark: db "2DR"  
247b f1			.pastdmark: pop af  
247c			endm  
# End of macro DMARK
247c						CALLMONITOR 
247c cd ae 15			call break_point_state  
247f				endm  
# End of macro CALLMONITOR
247f					endif 
247f					FORTH_DSP_POP 
247f cd ce 1e			call macro_forth_dsp_pop 
2482				endm 
# End of macro FORTH_DSP_POP
2482					FORTH_DSP_POP 
2482 cd ce 1e			call macro_forth_dsp_pop 
2485				endm 
# End of macro FORTH_DSP_POP
2485					NEXTW 
2485 c3 8d 1f			jp macro_next 
2488				endm 
# End of macro NEXTW
2488			.SWAP2: 
2488				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2488 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2489 b1 24			dw .AT            
248b 06				db 5 + 1 
248c .. 00			db "2SWAP",0              
2492				endm 
# End of macro CWHEAD
2492			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2492					if DEBUG_FORTH_WORDS_KEY 
2492						DMARK "2SW" 
2492 f5				push af  
2493 3a a7 24			ld a, (.dmark)  
2496 32 71 ee			ld (debug_mark),a  
2499 3a a8 24			ld a, (.dmark+1)  
249c 32 72 ee			ld (debug_mark+1),a  
249f 3a a9 24			ld a, (.dmark+2)  
24a2 32 73 ee			ld (debug_mark+2),a  
24a5 18 03			jr .pastdmark  
24a7 ..			.dmark: db "2SW"  
24aa f1			.pastdmark: pop af  
24ab			endm  
# End of macro DMARK
24ab						CALLMONITOR 
24ab cd ae 15			call break_point_state  
24ae				endm  
# End of macro CALLMONITOR
24ae					endif 
24ae					NEXTW 
24ae c3 8d 1f			jp macro_next 
24b1				endm 
# End of macro NEXTW
24b1			.AT: 
24b1				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
24b1 1f				db WORD_SYS_CORE+OPCODE_AT             
24b2 e3 24			dw .CAT            
24b4 02				db 1 + 1 
24b5 .. 00			db "@",0              
24b7				endm 
# End of macro CWHEAD
24b7			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
24b7			 
24b7					if DEBUG_FORTH_WORDS_KEY 
24b7						DMARK "AT." 
24b7 f5				push af  
24b8 3a cc 24			ld a, (.dmark)  
24bb 32 71 ee			ld (debug_mark),a  
24be 3a cd 24			ld a, (.dmark+1)  
24c1 32 72 ee			ld (debug_mark+1),a  
24c4 3a ce 24			ld a, (.dmark+2)  
24c7 32 73 ee			ld (debug_mark+2),a  
24ca 18 03			jr .pastdmark  
24cc ..			.dmark: db "AT."  
24cf f1			.pastdmark: pop af  
24d0			endm  
# End of macro DMARK
24d0						CALLMONITOR 
24d0 cd ae 15			call break_point_state  
24d3				endm  
# End of macro CALLMONITOR
24d3					endif 
24d3			.getbyteat:	 
24d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24d3 cd 16 1e			call macro_dsp_valuehl 
24d6				endm 
# End of macro FORTH_DSP_VALUEHL
24d6					 
24d6			;		push hl 
24d6				 
24d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24d6 cd ce 1e			call macro_forth_dsp_pop 
24d9				endm 
# End of macro FORTH_DSP_POP
24d9			 
24d9			;		pop hl 
24d9			 
24d9 7e					ld a, (hl) 
24da			 
24da 6f					ld l, a 
24db 26 00				ld h, 0 
24dd cd 1f 1c				call forth_push_numhl 
24e0			 
24e0					NEXTW 
24e0 c3 8d 1f			jp macro_next 
24e3				endm 
# End of macro NEXTW
24e3			.CAT: 
24e3				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
24e3 20				db WORD_SYS_CORE+OPCODE_CAT             
24e4 0c 25			dw .BANG            
24e6 03				db 2 + 1 
24e7 .. 00			db "C@",0              
24ea				endm 
# End of macro CWHEAD
24ea			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
24ea					if DEBUG_FORTH_WORDS_KEY 
24ea						DMARK "CAA" 
24ea f5				push af  
24eb 3a ff 24			ld a, (.dmark)  
24ee 32 71 ee			ld (debug_mark),a  
24f1 3a 00 25			ld a, (.dmark+1)  
24f4 32 72 ee			ld (debug_mark+1),a  
24f7 3a 01 25			ld a, (.dmark+2)  
24fa 32 73 ee			ld (debug_mark+2),a  
24fd 18 03			jr .pastdmark  
24ff ..			.dmark: db "CAA"  
2502 f1			.pastdmark: pop af  
2503			endm  
# End of macro DMARK
2503						CALLMONITOR 
2503 cd ae 15			call break_point_state  
2506				endm  
# End of macro CALLMONITOR
2506					endif 
2506 c3 d3 24				jp .getbyteat 
2509					NEXTW 
2509 c3 8d 1f			jp macro_next 
250c				endm 
# End of macro NEXTW
250c			.BANG: 
250c				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
250c 21				db WORD_SYS_CORE+OPCODE_BANG             
250d 42 25			dw .CBANG            
250f 02				db 1 + 1 
2510 .. 00			db "!",0              
2512				endm 
# End of macro CWHEAD
2512			; | ! ( x w -- ) Store x at address w      | DONE 
2512					if DEBUG_FORTH_WORDS_KEY 
2512						DMARK "BNG" 
2512 f5				push af  
2513 3a 27 25			ld a, (.dmark)  
2516 32 71 ee			ld (debug_mark),a  
2519 3a 28 25			ld a, (.dmark+1)  
251c 32 72 ee			ld (debug_mark+1),a  
251f 3a 29 25			ld a, (.dmark+2)  
2522 32 73 ee			ld (debug_mark+2),a  
2525 18 03			jr .pastdmark  
2527 ..			.dmark: db "BNG"  
252a f1			.pastdmark: pop af  
252b			endm  
# End of macro DMARK
252b						CALLMONITOR 
252b cd ae 15			call break_point_state  
252e				endm  
# End of macro CALLMONITOR
252e					endif 
252e			 
252e			.storebyteat:		 
252e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
252e cd 16 1e			call macro_dsp_valuehl 
2531				endm 
# End of macro FORTH_DSP_VALUEHL
2531					 
2531 e5					push hl 
2532				 
2532					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2532 cd ce 1e			call macro_forth_dsp_pop 
2535				endm 
# End of macro FORTH_DSP_POP
2535			 
2535					; get byte to poke 
2535			 
2535					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2535 cd 16 1e			call macro_dsp_valuehl 
2538				endm 
# End of macro FORTH_DSP_VALUEHL
2538 e5					push hl 
2539			 
2539			 
2539					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2539 cd ce 1e			call macro_forth_dsp_pop 
253c				endm 
# End of macro FORTH_DSP_POP
253c			 
253c			 
253c d1					pop de 
253d e1					pop hl 
253e			 
253e 73					ld (hl),e 
253f			 
253f			 
253f					NEXTW 
253f c3 8d 1f			jp macro_next 
2542				endm 
# End of macro NEXTW
2542			.CBANG: 
2542				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2542 22				db WORD_SYS_CORE+OPCODE_CBANG             
2543 6b 25			dw .SCALL            
2545 03				db 2 + 1 
2546 .. 00			db "C!",0              
2549				endm 
# End of macro CWHEAD
2549			; | C!  ( x w -- ) Store x at address w  | DONE 
2549					if DEBUG_FORTH_WORDS_KEY 
2549						DMARK "CBA" 
2549 f5				push af  
254a 3a 5e 25			ld a, (.dmark)  
254d 32 71 ee			ld (debug_mark),a  
2550 3a 5f 25			ld a, (.dmark+1)  
2553 32 72 ee			ld (debug_mark+1),a  
2556 3a 60 25			ld a, (.dmark+2)  
2559 32 73 ee			ld (debug_mark+2),a  
255c 18 03			jr .pastdmark  
255e ..			.dmark: db "CBA"  
2561 f1			.pastdmark: pop af  
2562			endm  
# End of macro DMARK
2562						CALLMONITOR 
2562 cd ae 15			call break_point_state  
2565				endm  
# End of macro CALLMONITOR
2565					endif 
2565 c3 2e 25				jp .storebyteat 
2568					NEXTW 
2568 c3 8d 1f			jp macro_next 
256b				endm 
# End of macro NEXTW
256b			.SCALL: 
256b				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
256b 23				db WORD_SYS_CORE+OPCODE_SCALL             
256c 9f 25			dw .DEPTH            
256e 05				db 4 + 1 
256f .. 00			db "CALL",0              
2574				endm 
# End of macro CWHEAD
2574			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2574					if DEBUG_FORTH_WORDS_KEY 
2574						DMARK "CLL" 
2574 f5				push af  
2575 3a 89 25			ld a, (.dmark)  
2578 32 71 ee			ld (debug_mark),a  
257b 3a 8a 25			ld a, (.dmark+1)  
257e 32 72 ee			ld (debug_mark+1),a  
2581 3a 8b 25			ld a, (.dmark+2)  
2584 32 73 ee			ld (debug_mark+2),a  
2587 18 03			jr .pastdmark  
2589 ..			.dmark: db "CLL"  
258c f1			.pastdmark: pop af  
258d			endm  
# End of macro DMARK
258d						CALLMONITOR 
258d cd ae 15			call break_point_state  
2590				endm  
# End of macro CALLMONITOR
2590					endif 
2590			 
2590					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2590 cd 16 1e			call macro_dsp_valuehl 
2593				endm 
# End of macro FORTH_DSP_VALUEHL
2593			 
2593			;		push hl 
2593			 
2593					; destroy value TOS 
2593			 
2593					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2593 cd ce 1e			call macro_forth_dsp_pop 
2596				endm 
# End of macro FORTH_DSP_POP
2596			 
2596						 
2596			;		pop hl 
2596			 
2596					; how to do a call with hl???? save SP? 
2596 cd 31 1f				call forth_call_hl 
2599			 
2599			 
2599					; TODO push value back onto stack for another op etc 
2599			 
2599 cd 1f 1c				call forth_push_numhl 
259c					NEXTW 
259c c3 8d 1f			jp macro_next 
259f				endm 
# End of macro NEXTW
259f			.DEPTH: 
259f				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
259f 24				db WORD_SYS_CORE+OPCODE_DEPTH             
25a0 dc 25			dw .OVER            
25a2 06				db 5 + 1 
25a3 .. 00			db "DEPTH",0              
25a9				endm 
# End of macro CWHEAD
25a9			; | DEPTH ( -- u ) Push count of stack | DONE 
25a9					; take current TOS and remove from base value div by two to get count 
25a9					if DEBUG_FORTH_WORDS_KEY 
25a9						DMARK "DEP" 
25a9 f5				push af  
25aa 3a be 25			ld a, (.dmark)  
25ad 32 71 ee			ld (debug_mark),a  
25b0 3a bf 25			ld a, (.dmark+1)  
25b3 32 72 ee			ld (debug_mark+1),a  
25b6 3a c0 25			ld a, (.dmark+2)  
25b9 32 73 ee			ld (debug_mark+2),a  
25bc 18 03			jr .pastdmark  
25be ..			.dmark: db "DEP"  
25c1 f1			.pastdmark: pop af  
25c2			endm  
# End of macro DMARK
25c2						CALLMONITOR 
25c2 cd ae 15			call break_point_state  
25c5				endm  
# End of macro CALLMONITOR
25c5					endif 
25c5			 
25c5			 
25c5 2a 2c ea			ld hl, (cli_data_sp) 
25c8 11 66 e8			ld de, cli_data_stack 
25cb ed 52			sbc hl,de 
25cd				 
25cd				; div by size of stack item 
25cd			 
25cd 5d				ld e,l 
25ce 0e 03			ld c, 3 
25d0 cd 3d 0d			call Div8 
25d3			 
25d3 6f				ld l,a 
25d4 26 00			ld h,0 
25d6			 
25d6				;srl h 
25d6				;rr l 
25d6			 
25d6 cd 1f 1c				call forth_push_numhl 
25d9					NEXTW 
25d9 c3 8d 1f			jp macro_next 
25dc				endm 
# End of macro NEXTW
25dc			.OVER: 
25dc				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
25dc 42				db WORD_SYS_CORE+46             
25dd 23 26			dw .PAUSE            
25df 05				db 4 + 1 
25e0 .. 00			db "OVER",0              
25e5				endm 
# End of macro CWHEAD
25e5			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
25e5					if DEBUG_FORTH_WORDS_KEY 
25e5						DMARK "OVR" 
25e5 f5				push af  
25e6 3a fa 25			ld a, (.dmark)  
25e9 32 71 ee			ld (debug_mark),a  
25ec 3a fb 25			ld a, (.dmark+1)  
25ef 32 72 ee			ld (debug_mark+1),a  
25f2 3a fc 25			ld a, (.dmark+2)  
25f5 32 73 ee			ld (debug_mark+2),a  
25f8 18 03			jr .pastdmark  
25fa ..			.dmark: db "OVR"  
25fd f1			.pastdmark: pop af  
25fe			endm  
# End of macro DMARK
25fe						CALLMONITOR 
25fe cd ae 15			call break_point_state  
2601				endm  
# End of macro CALLMONITOR
2601					endif 
2601			 
2601					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2601 cd 16 1e			call macro_dsp_valuehl 
2604				endm 
# End of macro FORTH_DSP_VALUEHL
2604 e5					push hl    ; n2 
2605					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2605 cd ce 1e			call macro_forth_dsp_pop 
2608				endm 
# End of macro FORTH_DSP_POP
2608			 
2608					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2608 cd 16 1e			call macro_dsp_valuehl 
260b				endm 
# End of macro FORTH_DSP_VALUEHL
260b e5					push hl    ; n1 
260c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
260c cd ce 1e			call macro_forth_dsp_pop 
260f				endm 
# End of macro FORTH_DSP_POP
260f			 
260f d1					pop de     ; n1 
2610 e1					pop hl     ; n2 
2611			 
2611 d5					push de 
2612 e5					push hl 
2613 d5					push de 
2614			 
2614					; push back  
2614			 
2614 e1					pop hl 
2615 cd 1f 1c				call forth_push_numhl 
2618 e1					pop hl 
2619 cd 1f 1c				call forth_push_numhl 
261c e1					pop hl 
261d cd 1f 1c				call forth_push_numhl 
2620					NEXTW 
2620 c3 8d 1f			jp macro_next 
2623				endm 
# End of macro NEXTW
2623			 
2623			.PAUSE: 
2623				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2623 43				db WORD_SYS_CORE+47             
2624 58 26			dw .PAUSES            
2626 08				db 7 + 1 
2627 .. 00			db "PAUSEMS",0              
262f				endm 
# End of macro CWHEAD
262f			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
262f					if DEBUG_FORTH_WORDS_KEY 
262f						DMARK "PMS" 
262f f5				push af  
2630 3a 44 26			ld a, (.dmark)  
2633 32 71 ee			ld (debug_mark),a  
2636 3a 45 26			ld a, (.dmark+1)  
2639 32 72 ee			ld (debug_mark+1),a  
263c 3a 46 26			ld a, (.dmark+2)  
263f 32 73 ee			ld (debug_mark+2),a  
2642 18 03			jr .pastdmark  
2644 ..			.dmark: db "PMS"  
2647 f1			.pastdmark: pop af  
2648			endm  
# End of macro DMARK
2648						CALLMONITOR 
2648 cd ae 15			call break_point_state  
264b				endm  
# End of macro CALLMONITOR
264b					endif 
264b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
264b cd 16 1e			call macro_dsp_valuehl 
264e				endm 
# End of macro FORTH_DSP_VALUEHL
264e			;		push hl    ; n2 
264e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
264e cd ce 1e			call macro_forth_dsp_pop 
2651				endm 
# End of macro FORTH_DSP_POP
2651			;		pop hl 
2651			 
2651 7d					ld a, l 
2652 cd d7 0a				call aDelayInMS 
2655				       NEXTW 
2655 c3 8d 1f			jp macro_next 
2658				endm 
# End of macro NEXTW
2658			.PAUSES:  
2658				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2658 44				db WORD_SYS_CORE+48             
2659 c7 26			dw .ROT            
265b 06				db 5 + 1 
265c .. 00			db "PAUSE",0              
2662				endm 
# End of macro CWHEAD
2662			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2662					if DEBUG_FORTH_WORDS_KEY 
2662						DMARK "PAU" 
2662 f5				push af  
2663 3a 77 26			ld a, (.dmark)  
2666 32 71 ee			ld (debug_mark),a  
2669 3a 78 26			ld a, (.dmark+1)  
266c 32 72 ee			ld (debug_mark+1),a  
266f 3a 79 26			ld a, (.dmark+2)  
2672 32 73 ee			ld (debug_mark+2),a  
2675 18 03			jr .pastdmark  
2677 ..			.dmark: db "PAU"  
267a f1			.pastdmark: pop af  
267b			endm  
# End of macro DMARK
267b						CALLMONITOR 
267b cd ae 15			call break_point_state  
267e				endm  
# End of macro CALLMONITOR
267e					endif 
267e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
267e cd 16 1e			call macro_dsp_valuehl 
2681				endm 
# End of macro FORTH_DSP_VALUEHL
2681			;		push hl    ; n2 
2681					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2681 cd ce 1e			call macro_forth_dsp_pop 
2684				endm 
# End of macro FORTH_DSP_POP
2684			;		pop hl 
2684 45					ld b, l 
2685					if DEBUG_FORTH_WORDS 
2685						DMARK "PAU" 
2685 f5				push af  
2686 3a 9a 26			ld a, (.dmark)  
2689 32 71 ee			ld (debug_mark),a  
268c 3a 9b 26			ld a, (.dmark+1)  
268f 32 72 ee			ld (debug_mark+1),a  
2692 3a 9c 26			ld a, (.dmark+2)  
2695 32 73 ee			ld (debug_mark+2),a  
2698 18 03			jr .pastdmark  
269a ..			.dmark: db "PAU"  
269d f1			.pastdmark: pop af  
269e			endm  
# End of macro DMARK
269e						CALLMONITOR 
269e cd ae 15			call break_point_state  
26a1				endm  
# End of macro CALLMONITOR
26a1					endif 
26a1 c5			.pauses1:	push bc 
26a2 cd f2 0a				call delay1s 
26a5 c1					pop bc 
26a6					if DEBUG_FORTH_WORDS 
26a6						DMARK "PA1" 
26a6 f5				push af  
26a7 3a bb 26			ld a, (.dmark)  
26aa 32 71 ee			ld (debug_mark),a  
26ad 3a bc 26			ld a, (.dmark+1)  
26b0 32 72 ee			ld (debug_mark+1),a  
26b3 3a bd 26			ld a, (.dmark+2)  
26b6 32 73 ee			ld (debug_mark+2),a  
26b9 18 03			jr .pastdmark  
26bb ..			.dmark: db "PA1"  
26be f1			.pastdmark: pop af  
26bf			endm  
# End of macro DMARK
26bf						CALLMONITOR 
26bf cd ae 15			call break_point_state  
26c2				endm  
# End of macro CALLMONITOR
26c2					endif 
26c2 10 dd				djnz .pauses1 
26c4			 
26c4				       NEXTW 
26c4 c3 8d 1f			jp macro_next 
26c7				endm 
# End of macro NEXTW
26c7			.ROT: 
26c7				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
26c7 45				db WORD_SYS_CORE+49             
26c8 15 27			dw .UWORDS            
26ca 04				db 3 + 1 
26cb .. 00			db "ROT",0              
26cf				endm 
# End of macro CWHEAD
26cf			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
26cf					if DEBUG_FORTH_WORDS_KEY 
26cf						DMARK "ROT" 
26cf f5				push af  
26d0 3a e4 26			ld a, (.dmark)  
26d3 32 71 ee			ld (debug_mark),a  
26d6 3a e5 26			ld a, (.dmark+1)  
26d9 32 72 ee			ld (debug_mark+1),a  
26dc 3a e6 26			ld a, (.dmark+2)  
26df 32 73 ee			ld (debug_mark+2),a  
26e2 18 03			jr .pastdmark  
26e4 ..			.dmark: db "ROT"  
26e7 f1			.pastdmark: pop af  
26e8			endm  
# End of macro DMARK
26e8						CALLMONITOR 
26e8 cd ae 15			call break_point_state  
26eb				endm  
# End of macro CALLMONITOR
26eb					endif 
26eb			 
26eb					FORTH_DSP_VALUEHL 
26eb cd 16 1e			call macro_dsp_valuehl 
26ee				endm 
# End of macro FORTH_DSP_VALUEHL
26ee e5					push hl    ; u3  
26ef			 
26ef					FORTH_DSP_POP 
26ef cd ce 1e			call macro_forth_dsp_pop 
26f2				endm 
# End of macro FORTH_DSP_POP
26f2			   
26f2					FORTH_DSP_VALUEHL 
26f2 cd 16 1e			call macro_dsp_valuehl 
26f5				endm 
# End of macro FORTH_DSP_VALUEHL
26f5 e5					push hl     ; u2 
26f6			 
26f6					FORTH_DSP_POP 
26f6 cd ce 1e			call macro_forth_dsp_pop 
26f9				endm 
# End of macro FORTH_DSP_POP
26f9			 
26f9					FORTH_DSP_VALUEHL 
26f9 cd 16 1e			call macro_dsp_valuehl 
26fc				endm 
# End of macro FORTH_DSP_VALUEHL
26fc e5					push hl     ; u1 
26fd			 
26fd					FORTH_DSP_POP 
26fd cd ce 1e			call macro_forth_dsp_pop 
2700				endm 
# End of macro FORTH_DSP_POP
2700			 
2700 c1					pop bc      ; u1 
2701 e1					pop hl      ; u2 
2702 d1					pop de      ; u3 
2703			 
2703			 
2703 c5					push bc 
2704 d5					push de 
2705 e5					push hl 
2706			 
2706			 
2706 e1					pop hl 
2707 cd 1f 1c				call forth_push_numhl 
270a			 
270a e1					pop hl 
270b cd 1f 1c				call forth_push_numhl 
270e			 
270e e1					pop hl 
270f cd 1f 1c				call forth_push_numhl 
2712					 
2712			 
2712			 
2712			 
2712			 
2712			 
2712				       NEXTW 
2712 c3 8d 1f			jp macro_next 
2715				endm 
# End of macro NEXTW
2715			 
2715			.UWORDS: 
2715				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2715 50				db WORD_SYS_CORE+60             
2716 d7 27			dw .BP            
2718 07				db 6 + 1 
2719 .. 00			db "UWORDS",0              
2720				endm 
# End of macro CWHEAD
2720			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2720			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2720			; | | Following the count are the individual words. 
2720			; | | 
2720			; | | e.g. UWORDS 
2720			; | | BOX DIRLIST 2 
2720			; | |  
2720			; | | Can be used to save the words to storage via: 
2720			; | | UWORDS $01 DO $01 APPEND LOOP 
2720				if DEBUG_FORTH_WORDS_KEY 
2720					DMARK "UWR" 
2720 f5				push af  
2721 3a 35 27			ld a, (.dmark)  
2724 32 71 ee			ld (debug_mark),a  
2727 3a 36 27			ld a, (.dmark+1)  
272a 32 72 ee			ld (debug_mark+1),a  
272d 3a 37 27			ld a, (.dmark+2)  
2730 32 73 ee			ld (debug_mark+2),a  
2733 18 03			jr .pastdmark  
2735 ..			.dmark: db "UWR"  
2738 f1			.pastdmark: pop af  
2739			endm  
# End of macro DMARK
2739					CALLMONITOR 
2739 cd ae 15			call break_point_state  
273c				endm  
# End of macro CALLMONITOR
273c				endif 
273c 21 13 5f				ld hl, baseram 
273f					;ld hl, baseusermem 
273f 01 00 00				ld bc, 0    ; start a counter 
2742			 
2742				; skip dict stub 
2742			 
2742 cd de 20				call forth_tok_next 
2745			 
2745			 
2745			; while we have words to look for 
2745			 
2745 7e			.douscan:	ld a, (hl)      
2746				if DEBUG_FORTH_WORDS 
2746					DMARK "UWs" 
2746 f5				push af  
2747 3a 5b 27			ld a, (.dmark)  
274a 32 71 ee			ld (debug_mark),a  
274d 3a 5c 27			ld a, (.dmark+1)  
2750 32 72 ee			ld (debug_mark+1),a  
2753 3a 5d 27			ld a, (.dmark+2)  
2756 32 73 ee			ld (debug_mark+2),a  
2759 18 03			jr .pastdmark  
275b ..			.dmark: db "UWs"  
275e f1			.pastdmark: pop af  
275f			endm  
# End of macro DMARK
275f					CALLMONITOR 
275f cd ae 15			call break_point_state  
2762				endm  
# End of macro CALLMONITOR
2762				endif 
2762 fe 00				cp WORD_SYS_END 
2764 28 4d				jr z, .udone 
2766 fe 01				cp WORD_SYS_UWORD 
2768 20 44				jr nz, .nuword 
276a			 
276a				if DEBUG_FORTH_WORDS 
276a					DMARK "UWu" 
276a f5				push af  
276b 3a 7f 27			ld a, (.dmark)  
276e 32 71 ee			ld (debug_mark),a  
2771 3a 80 27			ld a, (.dmark+1)  
2774 32 72 ee			ld (debug_mark+1),a  
2777 3a 81 27			ld a, (.dmark+2)  
277a 32 73 ee			ld (debug_mark+2),a  
277d 18 03			jr .pastdmark  
277f ..			.dmark: db "UWu"  
2782 f1			.pastdmark: pop af  
2783			endm  
# End of macro DMARK
2783					CALLMONITOR 
2783 cd ae 15			call break_point_state  
2786				endm  
# End of macro CALLMONITOR
2786				endif 
2786					; we have a uword so push its name to the stack 
2786			 
2786 e5				   	push hl  ; save so we can move to next dict block 
2787			 
2787					; skip opcode 
2787 23					inc hl  
2788					; skip next ptr 
2788 23					inc hl  
2789 23					inc hl 
278a					; skip len 
278a 23					inc hl 
278b				if DEBUG_FORTH_WORDS 
278b					DMARK "UWt" 
278b f5				push af  
278c 3a a0 27			ld a, (.dmark)  
278f 32 71 ee			ld (debug_mark),a  
2792 3a a1 27			ld a, (.dmark+1)  
2795 32 72 ee			ld (debug_mark+1),a  
2798 3a a2 27			ld a, (.dmark+2)  
279b 32 73 ee			ld (debug_mark+2),a  
279e 18 03			jr .pastdmark  
27a0 ..			.dmark: db "UWt"  
27a3 f1			.pastdmark: pop af  
27a4			endm  
# End of macro DMARK
27a4					CALLMONITOR 
27a4 cd ae 15			call break_point_state  
27a7				endm  
# End of macro CALLMONITOR
27a7				endif 
27a7 03					inc bc 
27a8			 
27a8 c5					push bc 
27a9 cd 8d 1c				call forth_push_str 
27ac c1					pop bc 
27ad			 
27ad e1					pop hl 	 
27ae			 
27ae cd de 20		.nuword:	call forth_tok_next 
27b1 18 92				jr .douscan  
27b3			 
27b3			.udone:		 ; push count of uwords found 
27b3 c5					push bc 
27b4 e1					pop hl 
27b5			 
27b5				if DEBUG_FORTH_WORDS 
27b5					DMARK "UWc" 
27b5 f5				push af  
27b6 3a ca 27			ld a, (.dmark)  
27b9 32 71 ee			ld (debug_mark),a  
27bc 3a cb 27			ld a, (.dmark+1)  
27bf 32 72 ee			ld (debug_mark+1),a  
27c2 3a cc 27			ld a, (.dmark+2)  
27c5 32 73 ee			ld (debug_mark+2),a  
27c8 18 03			jr .pastdmark  
27ca ..			.dmark: db "UWc"  
27cd f1			.pastdmark: pop af  
27ce			endm  
# End of macro DMARK
27ce					CALLMONITOR 
27ce cd ae 15			call break_point_state  
27d1				endm  
# End of macro CALLMONITOR
27d1				endif 
27d1 cd 1f 1c				call forth_push_numhl 
27d4			 
27d4			 
27d4				       NEXTW 
27d4 c3 8d 1f			jp macro_next 
27d7				endm 
# End of macro NEXTW
27d7			 
27d7			.BP: 
27d7				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
27d7 54				db WORD_SYS_CORE+64             
27d8 0d 28			dw .MONITOR            
27da 03				db 2 + 1 
27db .. 00			db "BP",0              
27de				endm 
# End of macro CWHEAD
27de			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
27de			; | | $00 Will enable the break points within specific code paths 
27de			; | | $01 Will disable break points 
27de			; | |  
27de			; | | By default break points are off. Either the above can be used to enable them 
27de			; | | or if a key is held down during start up the spashscreen will appear to freeze 
27de			; | | and on release of the pressed key a message will be disaplayed to notify 
27de			; | | that break points are enabled. Pressing any key will then continue boot process. 
27de					; get byte count 
27de					if DEBUG_FORTH_WORDS_KEY 
27de						DMARK "BP." 
27de f5				push af  
27df 3a f3 27			ld a, (.dmark)  
27e2 32 71 ee			ld (debug_mark),a  
27e5 3a f4 27			ld a, (.dmark+1)  
27e8 32 72 ee			ld (debug_mark+1),a  
27eb 3a f5 27			ld a, (.dmark+2)  
27ee 32 73 ee			ld (debug_mark+2),a  
27f1 18 03			jr .pastdmark  
27f3 ..			.dmark: db "BP."  
27f6 f1			.pastdmark: pop af  
27f7			endm  
# End of macro DMARK
27f7						CALLMONITOR 
27f7 cd ae 15			call break_point_state  
27fa				endm  
# End of macro CALLMONITOR
27fa					endif 
27fa			 
27fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27fa cd 16 1e			call macro_dsp_valuehl 
27fd				endm 
# End of macro FORTH_DSP_VALUEHL
27fd			 
27fd			;		push hl 
27fd			 
27fd					; destroy value TOS 
27fd			 
27fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27fd cd ce 1e			call macro_forth_dsp_pop 
2800				endm 
# End of macro FORTH_DSP_POP
2800			 
2800			;		pop hl 
2800			 
2800 3e 00				ld a,0 
2802 bd					cp l 
2803 28 02				jr z, .bpset 
2805 3e 2a				ld a, '*' 
2807			 
2807 32 f0 e2		.bpset:		ld (os_view_disable), a 
280a			 
280a			 
280a					NEXTW 
280a c3 8d 1f			jp macro_next 
280d				endm 
# End of macro NEXTW
280d			 
280d			 
280d			.MONITOR: 
280d				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
280d 55				db WORD_SYS_CORE+65             
280e 40 28			dw .MALLOC            
2810 08				db 7 + 1 
2811 .. 00			db "MONITOR",0              
2819				endm 
# End of macro CWHEAD
2819			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2819			; | | At start the current various registers will be displayed with contents. 
2819			; | | Top right corner will show the most recent debug marker seen. 
2819			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2819			; | | and the return stack pointer (RSP). 
2819			; | | Pressing: 
2819			; | |    1 - Initial screen 
2819			; | |    2 - Display a data dump of HL 
2819			; | |    3 - Display a data dump of DE 
2819			; | |    4 - Display a data dump of BC 
2819			; | |    5 - Display a data dump of HL 
2819			; | |    6 - Display a data dump of DSP 
2819			; | |    7 - Display a data dump of RSP 
2819			; | |    8 - Display a data dump of what is at DSP 
2819			; | |    9 - Display a data dump of what is at RSP 
2819			; | |    0 - Exit monitor and continue running. This will also enable break points 
2819			; | |    * - Disable break points 
2819			; | |    # - Enter traditional monitor mode 
2819			; | | 
2819			; | | Monitor Mode 
2819			; | | ------------ 
2819			; | | A prompt of '>' will be shown for various commands: 
2819			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2819			; | |    C - Continue display a data dump from the last set address 
2819			; | |    M xxxx - Set start of memory edit at address xx 
2819			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2819			; | |    Q - Return to previous 
2819					if DEBUG_FORTH_WORDS_KEY 
2819						DMARK "MON" 
2819 f5				push af  
281a 3a 2e 28			ld a, (.dmark)  
281d 32 71 ee			ld (debug_mark),a  
2820 3a 2f 28			ld a, (.dmark+1)  
2823 32 72 ee			ld (debug_mark+1),a  
2826 3a 30 28			ld a, (.dmark+2)  
2829 32 73 ee			ld (debug_mark+2),a  
282c 18 03			jr .pastdmark  
282e ..			.dmark: db "MON"  
2831 f1			.pastdmark: pop af  
2832			endm  
# End of macro DMARK
2832						CALLMONITOR 
2832 cd ae 15			call break_point_state  
2835				endm  
# End of macro CALLMONITOR
2835					endif 
2835 3e 00				ld a, 0 
2837 32 f0 e2				ld (os_view_disable), a 
283a			 
283a					CALLMONITOR 
283a cd ae 15			call break_point_state  
283d				endm  
# End of macro CALLMONITOR
283d			 
283d			;	call monitor 
283d			 
283d					NEXTW 
283d c3 8d 1f			jp macro_next 
2840				endm 
# End of macro NEXTW
2840			 
2840			 
2840			.MALLOC: 
2840				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2840 56				db WORD_SYS_CORE+66             
2841 69 28			dw .MALLOC2            
2843 06				db 5 + 1 
2844 .. 00			db "ALLOT",0              
284a				endm 
# End of macro CWHEAD
284a			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
284a					if DEBUG_FORTH_WORDS_KEY 
284a						DMARK "ALL" 
284a f5				push af  
284b 3a 5f 28			ld a, (.dmark)  
284e 32 71 ee			ld (debug_mark),a  
2851 3a 60 28			ld a, (.dmark+1)  
2854 32 72 ee			ld (debug_mark+1),a  
2857 3a 61 28			ld a, (.dmark+2)  
285a 32 73 ee			ld (debug_mark+2),a  
285d 18 03			jr .pastdmark  
285f ..			.dmark: db "ALL"  
2862 f1			.pastdmark: pop af  
2863			endm  
# End of macro DMARK
2863						CALLMONITOR 
2863 cd ae 15			call break_point_state  
2866				endm  
# End of macro CALLMONITOR
2866					endif 
2866 c3 90 28				jp .mallocc 
2869			.MALLOC2: 
2869				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2869 56				db WORD_SYS_CORE+66             
286a a7 28			dw .FREE            
286c 07				db 6 + 1 
286d .. 00			db "MALLOC",0              
2874				endm 
# End of macro CWHEAD
2874			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2874					; get byte count 
2874					if DEBUG_FORTH_WORDS_KEY 
2874						DMARK "MAL" 
2874 f5				push af  
2875 3a 89 28			ld a, (.dmark)  
2878 32 71 ee			ld (debug_mark),a  
287b 3a 8a 28			ld a, (.dmark+1)  
287e 32 72 ee			ld (debug_mark+1),a  
2881 3a 8b 28			ld a, (.dmark+2)  
2884 32 73 ee			ld (debug_mark+2),a  
2887 18 03			jr .pastdmark  
2889 ..			.dmark: db "MAL"  
288c f1			.pastdmark: pop af  
288d			endm  
# End of macro DMARK
288d						CALLMONITOR 
288d cd ae 15			call break_point_state  
2890				endm  
# End of macro CALLMONITOR
2890					endif 
2890			.mallocc: 
2890					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2890 cd 16 1e			call macro_dsp_valuehl 
2893				endm 
# End of macro FORTH_DSP_VALUEHL
2893			 
2893			;		push hl 
2893			 
2893					; destroy value TOS 
2893			 
2893					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2893 cd ce 1e			call macro_forth_dsp_pop 
2896				endm 
# End of macro FORTH_DSP_POP
2896			 
2896			;		pop hl 
2896 cd 74 12				call malloc 
2899				if DEBUG_FORTH_MALLOC_GUARD 
2899 f5					push af 
289a cd d6 0d				call ishlzero 
289d			;		ld a, l 
289d			;		add h 
289d			;		cp 0 
289d f1					pop af 
289e					 
289e cc 2f 48				call z,malloc_error 
28a1				endif 
28a1			 
28a1 cd 1f 1c				call forth_push_numhl 
28a4					NEXTW 
28a4 c3 8d 1f			jp macro_next 
28a7				endm 
# End of macro NEXTW
28a7			 
28a7			.FREE: 
28a7				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
28a7 57				db WORD_SYS_CORE+67             
28a8 d8 28			dw .LIST            
28aa 05				db 4 + 1 
28ab .. 00			db "FREE",0              
28b0				endm 
# End of macro CWHEAD
28b0			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
28b0					if DEBUG_FORTH_WORDS_KEY 
28b0						DMARK "FRE" 
28b0 f5				push af  
28b1 3a c5 28			ld a, (.dmark)  
28b4 32 71 ee			ld (debug_mark),a  
28b7 3a c6 28			ld a, (.dmark+1)  
28ba 32 72 ee			ld (debug_mark+1),a  
28bd 3a c7 28			ld a, (.dmark+2)  
28c0 32 73 ee			ld (debug_mark+2),a  
28c3 18 03			jr .pastdmark  
28c5 ..			.dmark: db "FRE"  
28c8 f1			.pastdmark: pop af  
28c9			endm  
# End of macro DMARK
28c9						CALLMONITOR 
28c9 cd ae 15			call break_point_state  
28cc				endm  
# End of macro CALLMONITOR
28cc					endif 
28cc					; get address 
28cc			 
28cc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28cc cd 16 1e			call macro_dsp_valuehl 
28cf				endm 
# End of macro FORTH_DSP_VALUEHL
28cf			 
28cf			;		push hl 
28cf			 
28cf					; destroy value TOS 
28cf			 
28cf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28cf cd ce 1e			call macro_forth_dsp_pop 
28d2				endm 
# End of macro FORTH_DSP_POP
28d2			 
28d2			;		pop hl 
28d2			if FORTH_ENABLE_MALLOCFREE 
28d2 cd 3e 13				call free 
28d5			endif 
28d5					NEXTW 
28d5 c3 8d 1f			jp macro_next 
28d8				endm 
# End of macro NEXTW
28d8			.LIST: 
28d8				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
28d8 5c				db WORD_SYS_CORE+72             
28d9 c6 2a			dw .FORGET            
28db 05				db 4 + 1 
28dc .. 00			db "LIST",0              
28e1				endm 
# End of macro CWHEAD
28e1			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
28e1			; | | The quoted word must be in upper case. 
28e1				if DEBUG_FORTH_WORDS_KEY 
28e1					DMARK "LST" 
28e1 f5				push af  
28e2 3a f6 28			ld a, (.dmark)  
28e5 32 71 ee			ld (debug_mark),a  
28e8 3a f7 28			ld a, (.dmark+1)  
28eb 32 72 ee			ld (debug_mark+1),a  
28ee 3a f8 28			ld a, (.dmark+2)  
28f1 32 73 ee			ld (debug_mark+2),a  
28f4 18 03			jr .pastdmark  
28f6 ..			.dmark: db "LST"  
28f9 f1			.pastdmark: pop af  
28fa			endm  
# End of macro DMARK
28fa					CALLMONITOR 
28fa cd ae 15			call break_point_state  
28fd				endm  
# End of macro CALLMONITOR
28fd				endif 
28fd			 
28fd					FORTH_DSP_VALUEHL 
28fd cd 16 1e			call macro_dsp_valuehl 
2900				endm 
# End of macro FORTH_DSP_VALUEHL
2900			 
2900 e5					push hl 
2901					FORTH_DSP_POP 
2901 cd ce 1e			call macro_forth_dsp_pop 
2904				endm 
# End of macro FORTH_DSP_POP
2904 c1					pop bc 
2905			 
2905			; Start format of scratch string 
2905			 
2905 21 ff e2				ld hl, scratch 
2908			 
2908 3e 3a				ld a, ':' 
290a 77					ld (hl),a 
290b 23					inc hl 
290c 3e 20				ld a, ' ' 
290e 77					ld (hl), a 
290f			 
290f					; Get ptr to the word we need to look up 
290f			 
290f			;		FORTH_DSP_VALUEHL 
290f					;v5 FORTH_DSP_VALUE 
290f				; TODO type check 
290f			;		inc hl    ; Skip type check  
290f			;		push hl 
290f			;		ex de, hl    ; put into DE 
290f			 
290f			 
290f 21 13 5f				ld hl, baseram 
2912					;ld hl, baseusermem 
2912			 
2912 e5			push hl   ; sacreifical push 
2913			 
2913			.ldouscanm: 
2913 e1				pop hl 
2914			.ldouscan: 
2914				if DEBUG_FORTH_WORDS 
2914					DMARK "LSs" 
2914 f5				push af  
2915 3a 29 29			ld a, (.dmark)  
2918 32 71 ee			ld (debug_mark),a  
291b 3a 2a 29			ld a, (.dmark+1)  
291e 32 72 ee			ld (debug_mark+1),a  
2921 3a 2b 29			ld a, (.dmark+2)  
2924 32 73 ee			ld (debug_mark+2),a  
2927 18 03			jr .pastdmark  
2929 ..			.dmark: db "LSs"  
292c f1			.pastdmark: pop af  
292d			endm  
# End of macro DMARK
292d					CALLMONITOR 
292d cd ae 15			call break_point_state  
2930				endm  
# End of macro CALLMONITOR
2930				endif 
2930				; skip dict stub 
2930 cd de 20				call forth_tok_next 
2933			 
2933			 
2933			; while we have words to look for 
2933			 
2933 7e				ld a, (hl)      
2934				if DEBUG_FORTH_WORDS 
2934					DMARK "LSk" 
2934 f5				push af  
2935 3a 49 29			ld a, (.dmark)  
2938 32 71 ee			ld (debug_mark),a  
293b 3a 4a 29			ld a, (.dmark+1)  
293e 32 72 ee			ld (debug_mark+1),a  
2941 3a 4b 29			ld a, (.dmark+2)  
2944 32 73 ee			ld (debug_mark+2),a  
2947 18 03			jr .pastdmark  
2949 ..			.dmark: db "LSk"  
294c f1			.pastdmark: pop af  
294d			endm  
# End of macro DMARK
294d					CALLMONITOR 
294d cd ae 15			call break_point_state  
2950				endm  
# End of macro CALLMONITOR
2950				endif 
2950					;cp WORD_SYS_END 
2950					;jp z, .lunotfound 
2950			 
2950					; if we hit non uwords then gone too far 
2950 fe 01				cp WORD_SYS_UWORD 
2952 c2 82 2a				jp nz, .lunotfound 
2955			 
2955				if DEBUG_FORTH_WORDS 
2955					DMARK "LSu" 
2955 f5				push af  
2956 3a 6a 29			ld a, (.dmark)  
2959 32 71 ee			ld (debug_mark),a  
295c 3a 6b 29			ld a, (.dmark+1)  
295f 32 72 ee			ld (debug_mark+1),a  
2962 3a 6c 29			ld a, (.dmark+2)  
2965 32 73 ee			ld (debug_mark+2),a  
2968 18 03			jr .pastdmark  
296a ..			.dmark: db "LSu"  
296d f1			.pastdmark: pop af  
296e			endm  
# End of macro DMARK
296e					CALLMONITOR 
296e cd ae 15			call break_point_state  
2971				endm  
# End of macro CALLMONITOR
2971				endif 
2971			 
2971					; found a uword but is it the one we want... 
2971			 
2971 c5					push bc     ; uword to find is on bc 
2972 d1					pop de 
2973			 
2973 e5					push hl  ; to save the ptr 
2974			 
2974					; skip opcode 
2974 23					inc hl  
2975					; skip next ptr 
2975 23					inc hl  
2976 23					inc hl 
2977					; skip len 
2977 23					inc hl 
2978			 
2978				if DEBUG_FORTH_WORDS 
2978					DMARK "LSc" 
2978 f5				push af  
2979 3a 8d 29			ld a, (.dmark)  
297c 32 71 ee			ld (debug_mark),a  
297f 3a 8e 29			ld a, (.dmark+1)  
2982 32 72 ee			ld (debug_mark+1),a  
2985 3a 8f 29			ld a, (.dmark+2)  
2988 32 73 ee			ld (debug_mark+2),a  
298b 18 03			jr .pastdmark  
298d ..			.dmark: db "LSc"  
2990 f1			.pastdmark: pop af  
2991			endm  
# End of macro DMARK
2991					CALLMONITOR 
2991 cd ae 15			call break_point_state  
2994				endm  
# End of macro CALLMONITOR
2994				endif 
2994 cd 43 12				call strcmp 
2997 c2 13 29				jp nz, .ldouscanm 
299a				 
299a			 
299a			 
299a					; we have a uword so push its name to the stack 
299a			 
299a			;	   	push hl  ; save so we can move to next dict block 
299a e1			pop hl 
299b			 
299b				if DEBUG_FORTH_WORDS 
299b					DMARK "LSm" 
299b f5				push af  
299c 3a b0 29			ld a, (.dmark)  
299f 32 71 ee			ld (debug_mark),a  
29a2 3a b1 29			ld a, (.dmark+1)  
29a5 32 72 ee			ld (debug_mark+1),a  
29a8 3a b2 29			ld a, (.dmark+2)  
29ab 32 73 ee			ld (debug_mark+2),a  
29ae 18 03			jr .pastdmark  
29b0 ..			.dmark: db "LSm"  
29b3 f1			.pastdmark: pop af  
29b4			endm  
# End of macro DMARK
29b4					CALLMONITOR 
29b4 cd ae 15			call break_point_state  
29b7				endm  
# End of macro CALLMONITOR
29b7				endif 
29b7			 
29b7					; skip opcode 
29b7 23					inc hl  
29b8					; skip next ptr 
29b8 23					inc hl  
29b9 23					inc hl 
29ba					; skip len 
29ba 7e					ld a, (hl)   ; save length to add 
29bb				if DEBUG_FORTH_WORDS 
29bb					DMARK "LS2" 
29bb f5				push af  
29bc 3a d0 29			ld a, (.dmark)  
29bf 32 71 ee			ld (debug_mark),a  
29c2 3a d1 29			ld a, (.dmark+1)  
29c5 32 72 ee			ld (debug_mark+1),a  
29c8 3a d2 29			ld a, (.dmark+2)  
29cb 32 73 ee			ld (debug_mark+2),a  
29ce 18 03			jr .pastdmark  
29d0 ..			.dmark: db "LS2"  
29d3 f1			.pastdmark: pop af  
29d4			endm  
# End of macro DMARK
29d4					CALLMONITOR 
29d4 cd ae 15			call break_point_state  
29d7				endm  
# End of macro CALLMONITOR
29d7				endif 
29d7			 
29d7					; save this location 
29d7				 
29d7 e5					push hl 
29d8			 
29d8 23					inc hl 
29d9 11 01 e3				ld de, scratch+2 
29dc 4f					ld c, a 
29dd 06 00				ld b, 0 
29df			 
29df				if DEBUG_FORTH_WORDS 
29df					DMARK "LSn" 
29df f5				push af  
29e0 3a f4 29			ld a, (.dmark)  
29e3 32 71 ee			ld (debug_mark),a  
29e6 3a f5 29			ld a, (.dmark+1)  
29e9 32 72 ee			ld (debug_mark+1),a  
29ec 3a f6 29			ld a, (.dmark+2)  
29ef 32 73 ee			ld (debug_mark+2),a  
29f2 18 03			jr .pastdmark  
29f4 ..			.dmark: db "LSn"  
29f7 f1			.pastdmark: pop af  
29f8			endm  
# End of macro DMARK
29f8					CALLMONITOR 
29f8 cd ae 15			call break_point_state  
29fb				endm  
# End of macro CALLMONITOR
29fb				endif 
29fb			 
29fb					; copy uword name to scratch 
29fb			 
29fb ed b0				ldir 
29fd			 
29fd 1b					dec de 
29fe 3e 20				ld a, ' '    ; change null to space 
2a00 12					ld (de), a 
2a01			 
2a01 13					inc de 
2a02			 
2a02 d5					push de 
2a03 c1					pop bc     ; move scratch pointer to end of word name and save it 
2a04			 
2a04 e1					pop hl 
2a05 7e					ld a, (hl) 
2a06					;inc hl 
2a06					; skip word string 
2a06 cd ad 0d				call addatohl 
2a09			 
2a09 23					inc hl 
2a0a			 
2a0a				if DEBUG_FORTH_WORDS 
2a0a					DMARK "LS3" 
2a0a f5				push af  
2a0b 3a 1f 2a			ld a, (.dmark)  
2a0e 32 71 ee			ld (debug_mark),a  
2a11 3a 20 2a			ld a, (.dmark+1)  
2a14 32 72 ee			ld (debug_mark+1),a  
2a17 3a 21 2a			ld a, (.dmark+2)  
2a1a 32 73 ee			ld (debug_mark+2),a  
2a1d 18 03			jr .pastdmark  
2a1f ..			.dmark: db "LS3"  
2a22 f1			.pastdmark: pop af  
2a23			endm  
# End of macro DMARK
2a23					CALLMONITOR 
2a23 cd ae 15			call break_point_state  
2a26				endm  
# End of macro CALLMONITOR
2a26				endif 
2a26					; should now be at the start of the machine code to setup the eval of the uword 
2a26					; now locate the ptr to the string defintion 
2a26			 
2a26					; skip ld hl, 
2a26					; then load the ptr 
2a26			; TODO use get from hl ptr 
2a26 23					inc hl 
2a27 5e					ld e, (hl) 
2a28 23					inc hl 
2a29 56					ld d, (hl) 
2a2a eb					ex de, hl 
2a2b			 
2a2b			 
2a2b				if DEBUG_FORTH_WORDS 
2a2b					DMARK "LSt" 
2a2b f5				push af  
2a2c 3a 40 2a			ld a, (.dmark)  
2a2f 32 71 ee			ld (debug_mark),a  
2a32 3a 41 2a			ld a, (.dmark+1)  
2a35 32 72 ee			ld (debug_mark+1),a  
2a38 3a 42 2a			ld a, (.dmark+2)  
2a3b 32 73 ee			ld (debug_mark+2),a  
2a3e 18 03			jr .pastdmark  
2a40 ..			.dmark: db "LSt"  
2a43 f1			.pastdmark: pop af  
2a44			endm  
# End of macro DMARK
2a44					CALLMONITOR 
2a44 cd ae 15			call break_point_state  
2a47				endm  
# End of macro CALLMONITOR
2a47				endif 
2a47			 
2a47			; cant push right now due to tokenised strings  
2a47			 
2a47			; get the destination of where to copy this definition to. 
2a47			 
2a47 c5					push bc 
2a48 d1					pop de 
2a49			 
2a49 7e			.listl:         ld a,(hl) 
2a4a fe 00				cp 0 
2a4c 28 09				jr z, .lreplsp     ; replace zero with space 
2a4e					;cp FORTH_END_BUFFER 
2a4e fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2a50 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2a52				 
2a52					; just copy this char as is then 
2a52			 
2a52 12					ld (de), a 
2a53			 
2a53 23			.listnxt:	inc hl 
2a54 13					inc de 
2a55 18 f2				jr .listl 
2a57			 
2a57 3e 20		.lreplsp:	ld a,' ' 
2a59 12					ld (de), a 
2a5a 18 f7				jr .listnxt 
2a5c			 
2a5c			; close up uword def 
2a5c			 
2a5c			.listdone: 
2a5c 12					ld (de), a 
2a5d 13					inc de 
2a5e 3e 00				ld a, 0 
2a60 12					ld (de), a 
2a61			 
2a61			; now have def so clean up and push to stack 
2a61			 
2a61 21 ff e2				ld hl, scratch 
2a64				if DEBUG_FORTH_WORDS 
2a64					DMARK "Ltp" 
2a64 f5				push af  
2a65 3a 79 2a			ld a, (.dmark)  
2a68 32 71 ee			ld (debug_mark),a  
2a6b 3a 7a 2a			ld a, (.dmark+1)  
2a6e 32 72 ee			ld (debug_mark+1),a  
2a71 3a 7b 2a			ld a, (.dmark+2)  
2a74 32 73 ee			ld (debug_mark+2),a  
2a77 18 03			jr .pastdmark  
2a79 ..			.dmark: db "Ltp"  
2a7c f1			.pastdmark: pop af  
2a7d			endm  
# End of macro DMARK
2a7d					CALLMONITOR 
2a7d cd ae 15			call break_point_state  
2a80				endm  
# End of macro CALLMONITOR
2a80				endif 
2a80			 
2a80 18 1f			jr .listpush 
2a82			 
2a82			;.lnuword:	pop hl 
2a82			;		call forth_tok_next 
2a82			;		jp .ldouscan  
2a82			 
2a82			.lunotfound:		  
2a82			 
2a82				if DEBUG_FORTH_WORDS 
2a82					DMARK "LSn" 
2a82 f5				push af  
2a83 3a 97 2a			ld a, (.dmark)  
2a86 32 71 ee			ld (debug_mark),a  
2a89 3a 98 2a			ld a, (.dmark+1)  
2a8c 32 72 ee			ld (debug_mark+1),a  
2a8f 3a 99 2a			ld a, (.dmark+2)  
2a92 32 73 ee			ld (debug_mark+2),a  
2a95 18 03			jr .pastdmark  
2a97 ..			.dmark: db "LSn"  
2a9a f1			.pastdmark: pop af  
2a9b			endm  
# End of macro DMARK
2a9b					CALLMONITOR 
2a9b cd ae 15			call break_point_state  
2a9e				endm  
# End of macro CALLMONITOR
2a9e				endif 
2a9e			 
2a9e					 
2a9e			;		FORTH_DSP_POP 
2a9e			;		ld hl, .luno 
2a9e			 
2a9e					NEXTW			 
2a9e c3 8d 1f			jp macro_next 
2aa1				endm 
# End of macro NEXTW
2aa1			 
2aa1			.listpush: 
2aa1				if DEBUG_FORTH_WORDS 
2aa1					DMARK "LS>" 
2aa1 f5				push af  
2aa2 3a b6 2a			ld a, (.dmark)  
2aa5 32 71 ee			ld (debug_mark),a  
2aa8 3a b7 2a			ld a, (.dmark+1)  
2aab 32 72 ee			ld (debug_mark+1),a  
2aae 3a b8 2a			ld a, (.dmark+2)  
2ab1 32 73 ee			ld (debug_mark+2),a  
2ab4 18 03			jr .pastdmark  
2ab6 ..			.dmark: db "LS>"  
2ab9 f1			.pastdmark: pop af  
2aba			endm  
# End of macro DMARK
2aba					CALLMONITOR 
2aba cd ae 15			call break_point_state  
2abd				endm  
# End of macro CALLMONITOR
2abd				endif 
2abd cd 8d 1c				call forth_push_str 
2ac0			 
2ac0			 
2ac0			 
2ac0					NEXTW 
2ac0 c3 8d 1f			jp macro_next 
2ac3				endm 
# End of macro NEXTW
2ac3			 
2ac3			;.luno:    db "Word not found",0 
2ac3			 
2ac3			 
2ac3			 
2ac3			 
2ac3			 
2ac3			;		push hl   ; save pointer to start of uword def string 
2ac3			; 
2ac3			;; look for FORTH_EOL_LINE 
2ac3			;		ld a, FORTH_END_BUFFER 
2ac3			;		call strlent 
2ac3			; 
2ac3			;		inc hl		 ; space for coln def 
2ac3			;		inc hl 
2ac3			;		inc hl          ; space for terms 
2ac3			;		inc hl 
2ac3			; 
2ac3			;		ld a, 20   ; TODO get actual length 
2ac3			;		call addatohl    ; include a random amount of room for the uword name 
2ac3			; 
2ac3			;		 
2ac3			;	if DEBUG_FORTH_WORDS 
2ac3			;		DMARK "Lt1" 
2ac3			;		CALLMONITOR 
2ac3			;	endif 
2ac3			;		 
2ac3			; 
2ac3			;; malloc space for the string because we cant change it 
2ac3			; 
2ac3			;		call malloc 
2ac3			;	if DEBUG_FORTH_MALLOC_GUARD 
2ac3			;		push af 
2ac3			;		call ishlzero 
2ac3			;		pop af 
2ac3			;		 
2ac3			;		call z,malloc_error 
2ac3			;	endif 
2ac3			; 
2ac3			;	if DEBUG_FORTH_WORDS 
2ac3			;		DMARK "Lt2" 
2ac3			;		CALLMONITOR 
2ac3			;	endif 
2ac3			;		pop de 
2ac3			;		push hl    ; push the malloc to release later 
2ac3			;		push hl   ;  push back a copy for the later stack push 
2ac3			;		 
2ac3			;; copy the string swapping out the zero terms for spaces 
2ac3			; 
2ac3			;		; de has our source 
2ac3			;		; hl has our dest 
2ac3			; 
2ac3			;; add the coln def 
2ac3			; 
2ac3			;		ld a, ':' 
2ac3			;		ld (hl), a 
2ac3			;		inc hl 
2ac3			;		ld a, ' ' 
2ac3			;		ld (hl), a 
2ac3			;		inc hl 
2ac3			; 
2ac3			;; add the uname word 
2ac3			;		push de   ; save our string for now 
2ac3			;		ex de, hl 
2ac3			; 
2ac3			;		FORTH_DSP_VALUE 
2ac3			;		;v5 FORTH_DSP_VALUE 
2ac3			; 
2ac3			;		inc hl   ; skip type but we know by now this is OK 
2ac3			; 
2ac3			;.luword:	ld a,(hl) 
2ac3			;		cp 0 
2ac3			;		jr z, .luword2 
2ac3			;		ld (de), a 
2ac3			;		inc de 
2ac3			;		inc hl 
2ac3			;		jr .luword 
2ac3			; 
2ac3			;.luword2:	ld a, ' ' 
2ac3			;		ld (de), a 
2ac3			;;		inc hl 
2ac3			;;		inc de 
2ac3			;;		ld (de), a 
2ac3			;;		inc hl 
2ac3			;		inc de 
2ac3			; 
2ac3			;		ex de, hl 
2ac3			;		pop de 
2ac3			;		 
2ac3			;		 
2ac3			; 
2ac3			;; detoken that string and copy it 
2ac3			; 
2ac3			;	if DEBUG_FORTH_WORDS 
2ac3			;		DMARK "Lt2" 
2ac3			;		CALLMONITOR 
2ac3			;	endif 
2ac3			;.ldetok:	ld a, (de) 
2ac3			;		cp FORTH_END_BUFFER 
2ac3			;		jr z, .ldetokend 
2ac3			;		; swap out any zero term for space 
2ac3			;		cp 0 
2ac3			;		jr nz, .ldetoknext 
2ac3			;		ld a, ' ' 
2ac3			; 
2ac3			;	if DEBUG_FORTH_WORDS 
2ac3			;		DMARK "LtS" 
2ac3			;		CALLMONITOR 
2ac3			;	endif 
2ac3			;.ldetoknext:	ld (hl), a 
2ac3			;		inc de 
2ac3			;		inc hl 
2ac3			;		jr .ldetok 
2ac3			; 
2ac3			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2ac3			;		ld (hl), a  
2ac3			; 
2ac3			;; free that temp malloc 
2ac3			; 
2ac3			;		pop hl    
2ac3			; 
2ac3			;	if DEBUG_FORTH_WORDS 
2ac3			;		DMARK "Lt4" 
2ac3			;		CALLMONITOR 
2ac3			;	endif 
2ac3			;		call forth_apushstrhl 
2ac3			; 
2ac3			;		; get rid of temp malloc area 
2ac3			; 
2ac3			;		pop hl 
2ac3			;		call free 
2ac3			; 
2ac3			;		jr .ludone 
2ac3			; 
2ac3			;.lnuword:	pop hl 
2ac3			;		call forth_tok_next 
2ac3			;		jp .ldouscan  
2ac3			; 
2ac3			;.ludone:		 pop hl 
2ac3			; 
2ac3					NEXTW 
2ac3 c3 8d 1f			jp macro_next 
2ac6				endm 
# End of macro NEXTW
2ac6			 
2ac6			.FORGET: 
2ac6				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2ac6 5d				db WORD_SYS_CORE+73             
2ac7 3f 2b			dw .NOP            
2ac9 07				db 6 + 1 
2aca .. 00			db "FORGET",0              
2ad1				endm 
# End of macro CWHEAD
2ad1			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2ad1			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2ad1			; | |  
2ad1			; | | e.g. "MORE" forget 
2ad1					if DEBUG_FORTH_WORDS_KEY 
2ad1						DMARK "FRG" 
2ad1 f5				push af  
2ad2 3a e6 2a			ld a, (.dmark)  
2ad5 32 71 ee			ld (debug_mark),a  
2ad8 3a e7 2a			ld a, (.dmark+1)  
2adb 32 72 ee			ld (debug_mark+1),a  
2ade 3a e8 2a			ld a, (.dmark+2)  
2ae1 32 73 ee			ld (debug_mark+2),a  
2ae4 18 03			jr .pastdmark  
2ae6 ..			.dmark: db "FRG"  
2ae9 f1			.pastdmark: pop af  
2aea			endm  
# End of macro DMARK
2aea						CALLMONITOR 
2aea cd ae 15			call break_point_state  
2aed				endm  
# End of macro CALLMONITOR
2aed					endif 
2aed			 
2aed				; find uword 
2aed			        ; update start of word with "_" 
2aed				; replace uword with deleted flag 
2aed			 
2aed			 
2aed			;	if DEBUG_FORTH_WORDS 
2aed			;		DMARK "FOG" 
2aed			;		CALLMONITOR 
2aed			;	endif 
2aed			 
2aed			 
2aed					; Get ptr to the word we need to look up 
2aed			 
2aed					FORTH_DSP_VALUEHL 
2aed cd 16 1e			call macro_dsp_valuehl 
2af0				endm 
# End of macro FORTH_DSP_VALUEHL
2af0					;v5 FORTH_DSP_VALUE 
2af0				; TODO type check 
2af0			;		inc hl    ; Skip type check  
2af0 e5					push hl 
2af1 c1					pop bc 
2af2			;		ex de, hl    ; put into DE 
2af2			 
2af2			 
2af2 21 13 5f				ld hl, baseram 
2af5					;ld hl, baseusermem 
2af5			 
2af5				; skip dict stub 
2af5			;	call forth_tok_next 
2af5 e5			push hl   ; sacreifical push 
2af6			 
2af6			.fldouscanm: 
2af6 e1				pop hl 
2af7			.fldouscan: 
2af7			;	if DEBUG_FORTH_WORDS 
2af7			;		DMARK "LSs" 
2af7			;		CALLMONITOR 
2af7			;	endif 
2af7				; skip dict stub 
2af7 cd de 20				call forth_tok_next 
2afa			 
2afa			 
2afa			; while we have words to look for 
2afa			 
2afa 7e				ld a, (hl)      
2afb			;	if DEBUG_FORTH_WORDS 
2afb			;		DMARK "LSk" 
2afb			;		CALLMONITOR 
2afb			;	endif 
2afb fe 00				cp WORD_SYS_END 
2afd ca 39 2b				jp z, .flunotfound 
2b00 fe 01				cp WORD_SYS_UWORD 
2b02 c2 f7 2a				jp nz, .fldouscan 
2b05			 
2b05			;	if DEBUG_FORTH_WORDS 
2b05			;		DMARK "LSu" 
2b05			;		CALLMONITOR 
2b05			;	endif 
2b05			 
2b05					; found a uword but is it the one we want... 
2b05			 
2b05 c5					push bc     ; uword to find is on bc 
2b06 d1					pop de 
2b07			 
2b07 e5					push hl  ; to save the ptr 
2b08			 
2b08					; skip opcode 
2b08 23					inc hl  
2b09					; skip next ptr 
2b09 23					inc hl  
2b0a 23					inc hl 
2b0b					; skip len 
2b0b 23					inc hl 
2b0c			 
2b0c			;	if DEBUG_FORTH_WORDS 
2b0c			;		DMARK "LSc" 
2b0c			;		CALLMONITOR 
2b0c			;	endif 
2b0c cd 43 12				call strcmp 
2b0f c2 f6 2a				jp nz, .fldouscanm 
2b12			; 
2b12			; 
2b12			;; while we have words to look for 
2b12			; 
2b12			;.fdouscan:	ld a, (hl)      
2b12			;	if DEBUG_FORTH_WORDS 
2b12			;		DMARK "LSs" 
2b12			;		CALLMONITOR 
2b12			;	endif 
2b12			;		cp WORD_SYS_END 
2b12			;		jp z, .fudone 
2b12			;		cp WORD_SYS_UWORD 
2b12			;		jp nz, .fnuword 
2b12			; 
2b12			;	if DEBUG_FORTH_WORDS 
2b12			;		DMARK "FGu" 
2b12			;		CALLMONITOR 
2b12			;	endif 
2b12			; 
2b12			;		; found a uword but is it the one we want... 
2b12			; 
2b12			; 
2b12			;	        pop de   ; get back the dsp name 
2b12			;		push de 
2b12			; 
2b12			;		push hl  ; to save the ptr 
2b12			; 
2b12			;		; skip opcode 
2b12			;		inc hl  
2b12			;		; skip next ptr 
2b12			;		inc hl  
2b12			;		inc hl 
2b12			;		; skip len 
2b12			;		inc hl 
2b12			; 
2b12			;	if DEBUG_FORTH_WORDS 
2b12			;		DMARK "FGc" 
2b12			;		CALLMONITOR 
2b12			;	endif 
2b12			;		call strcmp 
2b12			;		jp nz, .fnuword 
2b12			 
2b12			 
2b12 e1			pop hl 
2b13			 
2b13				 
2b13				if DEBUG_FORTH_WORDS 
2b13					DMARK "FGm" 
2b13 f5				push af  
2b14 3a 28 2b			ld a, (.dmark)  
2b17 32 71 ee			ld (debug_mark),a  
2b1a 3a 29 2b			ld a, (.dmark+1)  
2b1d 32 72 ee			ld (debug_mark+1),a  
2b20 3a 2a 2b			ld a, (.dmark+2)  
2b23 32 73 ee			ld (debug_mark+2),a  
2b26 18 03			jr .pastdmark  
2b28 ..			.dmark: db "FGm"  
2b2b f1			.pastdmark: pop af  
2b2c			endm  
# End of macro DMARK
2b2c					CALLMONITOR 
2b2c cd ae 15			call break_point_state  
2b2f				endm  
# End of macro CALLMONITOR
2b2f				endif 
2b2f			 
2b2f			 
2b2f			 
2b2f					; we have a uword so push its name to the stack 
2b2f			 
2b2f			;	   	push hl  ; save so we can move to next dict block 
2b2f			;pop hl 
2b2f			 
2b2f					; update opcode to deleted 
2b2f 3e 03				ld a, WORD_SYS_DELETED 
2b31 77					ld (hl), a 
2b32			 
2b32 23					inc hl  
2b33					; skip next ptr 
2b33 23					inc hl  
2b34 23					inc hl 
2b35					; skip len 
2b35 23					inc hl 
2b36			 
2b36					; TODO change parser to skip deleted words but for now mark it out 
2b36 3e 5f				ld a, "_" 
2b38 77					ld  (hl),a 
2b39			 
2b39			;		jr .fudone 
2b39			; 
2b39			;.fnuword:	pop hl 
2b39			;		call forth_tok_next 
2b39			;		jp .fdouscan  
2b39			 
2b39			.flunotfound:		  
2b39			 
2b39			 
2b39					 
2b39					FORTH_DSP_POP 
2b39 cd ce 1e			call macro_forth_dsp_pop 
2b3c				endm 
# End of macro FORTH_DSP_POP
2b3c			;		ld hl, .luno 
2b3c			;.fudone:		 pop hl 
2b3c					NEXTW 
2b3c c3 8d 1f			jp macro_next 
2b3f				endm 
# End of macro NEXTW
2b3f			.NOP: 
2b3f				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2b3f 61				db WORD_SYS_CORE+77             
2b40 66 2b			dw .COMO            
2b42 04				db 3 + 1 
2b43 .. 00			db "NOP",0              
2b47				endm 
# End of macro CWHEAD
2b47			; | NOP (  --  ) Do nothing | DONE 
2b47					if DEBUG_FORTH_WORDS_KEY 
2b47						DMARK "NOP" 
2b47 f5				push af  
2b48 3a 5c 2b			ld a, (.dmark)  
2b4b 32 71 ee			ld (debug_mark),a  
2b4e 3a 5d 2b			ld a, (.dmark+1)  
2b51 32 72 ee			ld (debug_mark+1),a  
2b54 3a 5e 2b			ld a, (.dmark+2)  
2b57 32 73 ee			ld (debug_mark+2),a  
2b5a 18 03			jr .pastdmark  
2b5c ..			.dmark: db "NOP"  
2b5f f1			.pastdmark: pop af  
2b60			endm  
# End of macro DMARK
2b60						CALLMONITOR 
2b60 cd ae 15			call break_point_state  
2b63				endm  
# End of macro CALLMONITOR
2b63					endif 
2b63				       NEXTW 
2b63 c3 8d 1f			jp macro_next 
2b66				endm 
# End of macro NEXTW
2b66			.COMO: 
2b66				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2b66 6e				db WORD_SYS_CORE+90             
2b67 b8 2b			dw .COMC            
2b69 02				db 1 + 1 
2b6a .. 00			db "(",0              
2b6c				endm 
# End of macro CWHEAD
2b6c			; | ( ( -- )  Start of comment | DONE 
2b6c			 
2b6c			 
2b6c 2a 00 e6				ld hl, ( os_tok_ptr) 
2b6f 11 b3 2b			ld de, .closepar 
2b72					 
2b72					if DEBUG_FORTH_WORDS 
2b72						DMARK ").." 
2b72 f5				push af  
2b73 3a 87 2b			ld a, (.dmark)  
2b76 32 71 ee			ld (debug_mark),a  
2b79 3a 88 2b			ld a, (.dmark+1)  
2b7c 32 72 ee			ld (debug_mark+1),a  
2b7f 3a 89 2b			ld a, (.dmark+2)  
2b82 32 73 ee			ld (debug_mark+2),a  
2b85 18 03			jr .pastdmark  
2b87 ..			.dmark: db ").."  
2b8a f1			.pastdmark: pop af  
2b8b			endm  
# End of macro DMARK
2b8b						CALLMONITOR 
2b8b cd ae 15			call break_point_state  
2b8e				endm  
# End of macro CALLMONITOR
2b8e					endif 
2b8e cd a8 20			call findnexttok  
2b91			 
2b91					if DEBUG_FORTH_WORDS 
2b91						DMARK "IF5" 
2b91 f5				push af  
2b92 3a a6 2b			ld a, (.dmark)  
2b95 32 71 ee			ld (debug_mark),a  
2b98 3a a7 2b			ld a, (.dmark+1)  
2b9b 32 72 ee			ld (debug_mark+1),a  
2b9e 3a a8 2b			ld a, (.dmark+2)  
2ba1 32 73 ee			ld (debug_mark+2),a  
2ba4 18 03			jr .pastdmark  
2ba6 ..			.dmark: db "IF5"  
2ba9 f1			.pastdmark: pop af  
2baa			endm  
# End of macro DMARK
2baa						CALLMONITOR 
2baa cd ae 15			call break_point_state  
2bad				endm  
# End of macro CALLMONITOR
2bad					endif 
2bad				; replace below with ) exec using tok_ptr 
2bad 22 00 e6			ld (os_tok_ptr), hl 
2bb0 c3 1e 20			jp exec1 
2bb3			 
2bb3 .. 00			.closepar:   db ")",0 
2bb5			 
2bb5				       NEXTW 
2bb5 c3 8d 1f			jp macro_next 
2bb8				endm 
# End of macro NEXTW
2bb8			.COMC: 
2bb8				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2bb8 6f				db WORD_SYS_CORE+91             
2bb9 c1 2b			dw .SCRATCH            
2bbb 02				db 1 + 1 
2bbc .. 00			db ")",0              
2bbe				endm 
# End of macro CWHEAD
2bbe			; | ) ( -- )  End of comment |  DONE  
2bbe				       NEXTW 
2bbe c3 8d 1f			jp macro_next 
2bc1				endm 
# End of macro NEXTW
2bc1			 
2bc1			.SCRATCH: 
2bc1				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2bc1 6f				db WORD_SYS_CORE+91             
2bc2 fc 2b			dw .INC            
2bc4 08				db 7 + 1 
2bc5 .. 00			db "SCRATCH",0              
2bcd				endm 
# End of macro CWHEAD
2bcd			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2bcd			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2bcd			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2bcd			; | |  
2bcd			; | | e.g.    : score $00 scratch ; 
2bcd			; | |  
2bcd			; | | $00 score ! 
2bcd			; | | $01 score +! 
2bcd			; | |  
2bcd			; | | e.g.   : varword $0a scratch ;  
2bcd			; | | 
2bcd			; | | $8000 varword ! 
2bcd					if DEBUG_FORTH_WORDS_KEY 
2bcd						DMARK "SCR" 
2bcd f5				push af  
2bce 3a e2 2b			ld a, (.dmark)  
2bd1 32 71 ee			ld (debug_mark),a  
2bd4 3a e3 2b			ld a, (.dmark+1)  
2bd7 32 72 ee			ld (debug_mark+1),a  
2bda 3a e4 2b			ld a, (.dmark+2)  
2bdd 32 73 ee			ld (debug_mark+2),a  
2be0 18 03			jr .pastdmark  
2be2 ..			.dmark: db "SCR"  
2be5 f1			.pastdmark: pop af  
2be6			endm  
# End of macro DMARK
2be6						CALLMONITOR 
2be6 cd ae 15			call break_point_state  
2be9				endm  
# End of macro CALLMONITOR
2be9					endif 
2be9			 
2be9					FORTH_DSP_VALUEHL 
2be9 cd 16 1e			call macro_dsp_valuehl 
2bec				endm 
# End of macro FORTH_DSP_VALUEHL
2bec				 
2bec					FORTH_DSP_POP 
2bec cd ce 1e			call macro_forth_dsp_pop 
2bef				endm 
# End of macro FORTH_DSP_POP
2bef			 
2bef 7d					ld a, l 
2bf0 21 24 e8				ld hl, os_var_array 
2bf3 cd ad 0d				call addatohl 
2bf6			 
2bf6 cd 1f 1c				call forth_push_numhl 
2bf9			 
2bf9				       NEXTW 
2bf9 c3 8d 1f			jp macro_next 
2bfc				endm 
# End of macro NEXTW
2bfc			 
2bfc			.INC: 
2bfc				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2bfc 6f				db WORD_SYS_CORE+91             
2bfd 50 2c			dw .DEC            
2bff 03				db 2 + 1 
2c00 .. 00			db "+!",0              
2c03				endm 
# End of macro CWHEAD
2c03			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2c03					if DEBUG_FORTH_WORDS_KEY 
2c03						DMARK "+s_" 
2c03 f5				push af  
2c04 3a 18 2c			ld a, (.dmark)  
2c07 32 71 ee			ld (debug_mark),a  
2c0a 3a 19 2c			ld a, (.dmark+1)  
2c0d 32 72 ee			ld (debug_mark+1),a  
2c10 3a 1a 2c			ld a, (.dmark+2)  
2c13 32 73 ee			ld (debug_mark+2),a  
2c16 18 03			jr .pastdmark  
2c18 ..			.dmark: db "+s_"  
2c1b f1			.pastdmark: pop af  
2c1c			endm  
# End of macro DMARK
2c1c						CALLMONITOR 
2c1c cd ae 15			call break_point_state  
2c1f				endm  
# End of macro CALLMONITOR
2c1f					endif 
2c1f			 
2c1f					FORTH_DSP_VALUEHL 
2c1f cd 16 1e			call macro_dsp_valuehl 
2c22				endm 
# End of macro FORTH_DSP_VALUEHL
2c22			 
2c22 e5					push hl   ; save address 
2c23			 
2c23					FORTH_DSP_POP 
2c23 cd ce 1e			call macro_forth_dsp_pop 
2c26				endm 
# End of macro FORTH_DSP_POP
2c26			 
2c26					FORTH_DSP_VALUEHL 
2c26 cd 16 1e			call macro_dsp_valuehl 
2c29				endm 
# End of macro FORTH_DSP_VALUEHL
2c29			 
2c29					FORTH_DSP_POP 
2c29 cd ce 1e			call macro_forth_dsp_pop 
2c2c				endm 
# End of macro FORTH_DSP_POP
2c2c			 
2c2c					; hl contains value to add to byte at a 
2c2c				 
2c2c eb					ex de, hl 
2c2d			 
2c2d e1					pop hl 
2c2e			 
2c2e					if DEBUG_FORTH_WORDS 
2c2e						DMARK "INC" 
2c2e f5				push af  
2c2f 3a 43 2c			ld a, (.dmark)  
2c32 32 71 ee			ld (debug_mark),a  
2c35 3a 44 2c			ld a, (.dmark+1)  
2c38 32 72 ee			ld (debug_mark+1),a  
2c3b 3a 45 2c			ld a, (.dmark+2)  
2c3e 32 73 ee			ld (debug_mark+2),a  
2c41 18 03			jr .pastdmark  
2c43 ..			.dmark: db "INC"  
2c46 f1			.pastdmark: pop af  
2c47			endm  
# End of macro DMARK
2c47						CALLMONITOR 
2c47 cd ae 15			call break_point_state  
2c4a				endm  
# End of macro CALLMONITOR
2c4a					endif 
2c4a			 
2c4a 7e					ld a,(hl) 
2c4b 83					add e 
2c4c 77					ld (hl),a 
2c4d			 
2c4d			 
2c4d			 
2c4d				       NEXTW 
2c4d c3 8d 1f			jp macro_next 
2c50				endm 
# End of macro NEXTW
2c50			 
2c50			.DEC: 
2c50				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2c50 6f				db WORD_SYS_CORE+91             
2c51 a1 2c			dw .INC2            
2c53 03				db 2 + 1 
2c54 .. 00			db "-!",0              
2c57				endm 
# End of macro CWHEAD
2c57			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2c57					if DEBUG_FORTH_WORDS_KEY 
2c57						DMARK "-s_" 
2c57 f5				push af  
2c58 3a 6c 2c			ld a, (.dmark)  
2c5b 32 71 ee			ld (debug_mark),a  
2c5e 3a 6d 2c			ld a, (.dmark+1)  
2c61 32 72 ee			ld (debug_mark+1),a  
2c64 3a 6e 2c			ld a, (.dmark+2)  
2c67 32 73 ee			ld (debug_mark+2),a  
2c6a 18 03			jr .pastdmark  
2c6c ..			.dmark: db "-s_"  
2c6f f1			.pastdmark: pop af  
2c70			endm  
# End of macro DMARK
2c70						CALLMONITOR 
2c70 cd ae 15			call break_point_state  
2c73				endm  
# End of macro CALLMONITOR
2c73					endif 
2c73			 
2c73					FORTH_DSP_VALUEHL 
2c73 cd 16 1e			call macro_dsp_valuehl 
2c76				endm 
# End of macro FORTH_DSP_VALUEHL
2c76			 
2c76 e5					push hl   ; save address 
2c77			 
2c77					FORTH_DSP_POP 
2c77 cd ce 1e			call macro_forth_dsp_pop 
2c7a				endm 
# End of macro FORTH_DSP_POP
2c7a			 
2c7a					FORTH_DSP_VALUEHL 
2c7a cd 16 1e			call macro_dsp_valuehl 
2c7d				endm 
# End of macro FORTH_DSP_VALUEHL
2c7d			 
2c7d					; hl contains value to add to byte at a 
2c7d				 
2c7d eb					ex de, hl 
2c7e			 
2c7e e1					pop hl 
2c7f			 
2c7f					if DEBUG_FORTH_WORDS 
2c7f						DMARK "DEC" 
2c7f f5				push af  
2c80 3a 94 2c			ld a, (.dmark)  
2c83 32 71 ee			ld (debug_mark),a  
2c86 3a 95 2c			ld a, (.dmark+1)  
2c89 32 72 ee			ld (debug_mark+1),a  
2c8c 3a 96 2c			ld a, (.dmark+2)  
2c8f 32 73 ee			ld (debug_mark+2),a  
2c92 18 03			jr .pastdmark  
2c94 ..			.dmark: db "DEC"  
2c97 f1			.pastdmark: pop af  
2c98			endm  
# End of macro DMARK
2c98						CALLMONITOR 
2c98 cd ae 15			call break_point_state  
2c9b				endm  
# End of macro CALLMONITOR
2c9b					endif 
2c9b			 
2c9b 7e					ld a,(hl) 
2c9c 93					sub e 
2c9d 77					ld (hl),a 
2c9e			 
2c9e			 
2c9e			 
2c9e				       NEXTW 
2c9e c3 8d 1f			jp macro_next 
2ca1				endm 
# End of macro NEXTW
2ca1			 
2ca1			.INC2: 
2ca1				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2ca1 6f				db WORD_SYS_CORE+91             
2ca2 4b 2d			dw .DEC2            
2ca4 04				db 3 + 1 
2ca5 .. 00			db "+2!",0              
2ca9				endm 
# End of macro CWHEAD
2ca9			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2ca9			 
2ca9					if DEBUG_FORTH_WORDS_KEY 
2ca9						DMARK "+2s" 
2ca9 f5				push af  
2caa 3a be 2c			ld a, (.dmark)  
2cad 32 71 ee			ld (debug_mark),a  
2cb0 3a bf 2c			ld a, (.dmark+1)  
2cb3 32 72 ee			ld (debug_mark+1),a  
2cb6 3a c0 2c			ld a, (.dmark+2)  
2cb9 32 73 ee			ld (debug_mark+2),a  
2cbc 18 03			jr .pastdmark  
2cbe ..			.dmark: db "+2s"  
2cc1 f1			.pastdmark: pop af  
2cc2			endm  
# End of macro DMARK
2cc2						CALLMONITOR 
2cc2 cd ae 15			call break_point_state  
2cc5				endm  
# End of macro CALLMONITOR
2cc5					endif 
2cc5			 
2cc5					; Address 
2cc5			 
2cc5					FORTH_DSP_VALUEHL 
2cc5 cd 16 1e			call macro_dsp_valuehl 
2cc8				endm 
# End of macro FORTH_DSP_VALUEHL
2cc8			 
2cc8 e5					push hl    ; save address 
2cc9			 
2cc9					; load content into de 
2cc9			 
2cc9 5e					ld e,(hl) 
2cca 23					inc hl 
2ccb 56					ld d, (hl) 
2ccc			 
2ccc					if DEBUG_FORTH_WORDS 
2ccc						DMARK "+2a" 
2ccc f5				push af  
2ccd 3a e1 2c			ld a, (.dmark)  
2cd0 32 71 ee			ld (debug_mark),a  
2cd3 3a e2 2c			ld a, (.dmark+1)  
2cd6 32 72 ee			ld (debug_mark+1),a  
2cd9 3a e3 2c			ld a, (.dmark+2)  
2cdc 32 73 ee			ld (debug_mark+2),a  
2cdf 18 03			jr .pastdmark  
2ce1 ..			.dmark: db "+2a"  
2ce4 f1			.pastdmark: pop af  
2ce5			endm  
# End of macro DMARK
2ce5						CALLMONITOR 
2ce5 cd ae 15			call break_point_state  
2ce8				endm  
# End of macro CALLMONITOR
2ce8					endif 
2ce8			 
2ce8					FORTH_DSP_POP 
2ce8 cd ce 1e			call macro_forth_dsp_pop 
2ceb				endm 
# End of macro FORTH_DSP_POP
2ceb			 
2ceb					; Get value to add 
2ceb			 
2ceb					FORTH_DSP_VALUE 
2ceb cd ff 1d			call macro_forth_dsp_value 
2cee				endm 
# End of macro FORTH_DSP_VALUE
2cee			 
2cee					if DEBUG_FORTH_WORDS 
2cee						DMARK "+2v" 
2cee f5				push af  
2cef 3a 03 2d			ld a, (.dmark)  
2cf2 32 71 ee			ld (debug_mark),a  
2cf5 3a 04 2d			ld a, (.dmark+1)  
2cf8 32 72 ee			ld (debug_mark+1),a  
2cfb 3a 05 2d			ld a, (.dmark+2)  
2cfe 32 73 ee			ld (debug_mark+2),a  
2d01 18 03			jr .pastdmark  
2d03 ..			.dmark: db "+2v"  
2d06 f1			.pastdmark: pop af  
2d07			endm  
# End of macro DMARK
2d07						CALLMONITOR 
2d07 cd ae 15			call break_point_state  
2d0a				endm  
# End of macro CALLMONITOR
2d0a					endif 
2d0a			 
2d0a 19					add hl, de 
2d0b			 
2d0b					if DEBUG_FORTH_WORDS 
2d0b						DMARK "+2+" 
2d0b f5				push af  
2d0c 3a 20 2d			ld a, (.dmark)  
2d0f 32 71 ee			ld (debug_mark),a  
2d12 3a 21 2d			ld a, (.dmark+1)  
2d15 32 72 ee			ld (debug_mark+1),a  
2d18 3a 22 2d			ld a, (.dmark+2)  
2d1b 32 73 ee			ld (debug_mark+2),a  
2d1e 18 03			jr .pastdmark  
2d20 ..			.dmark: db "+2+"  
2d23 f1			.pastdmark: pop af  
2d24			endm  
# End of macro DMARK
2d24						CALLMONITOR 
2d24 cd ae 15			call break_point_state  
2d27				endm  
# End of macro CALLMONITOR
2d27					endif 
2d27			 
2d27					; move result to de 
2d27			 
2d27 eb					ex de, hl 
2d28			 
2d28					; Address 
2d28			 
2d28 e1					pop hl 
2d29			 
2d29					; save it back 
2d29			 
2d29 73					ld (hl), e 
2d2a 23					inc hl 
2d2b 72					ld (hl), d 
2d2c			 
2d2c					if DEBUG_FORTH_WORDS 
2d2c						DMARK "+2e" 
2d2c f5				push af  
2d2d 3a 41 2d			ld a, (.dmark)  
2d30 32 71 ee			ld (debug_mark),a  
2d33 3a 42 2d			ld a, (.dmark+1)  
2d36 32 72 ee			ld (debug_mark+1),a  
2d39 3a 43 2d			ld a, (.dmark+2)  
2d3c 32 73 ee			ld (debug_mark+2),a  
2d3f 18 03			jr .pastdmark  
2d41 ..			.dmark: db "+2e"  
2d44 f1			.pastdmark: pop af  
2d45			endm  
# End of macro DMARK
2d45						CALLMONITOR 
2d45 cd ae 15			call break_point_state  
2d48				endm  
# End of macro CALLMONITOR
2d48					endif 
2d48			 
2d48			 
2d48			 
2d48			 
2d48			 
2d48				       NEXTW 
2d48 c3 8d 1f			jp macro_next 
2d4b				endm 
# End of macro NEXTW
2d4b			 
2d4b			.DEC2: 
2d4b				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2d4b 6f				db WORD_SYS_CORE+91             
2d4c f7 2d			dw .GET2            
2d4e 04				db 3 + 1 
2d4f .. 00			db "-2!",0              
2d53				endm 
# End of macro CWHEAD
2d53			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2d53			 
2d53			 
2d53					if DEBUG_FORTH_WORDS_KEY 
2d53						DMARK "-2s" 
2d53 f5				push af  
2d54 3a 68 2d			ld a, (.dmark)  
2d57 32 71 ee			ld (debug_mark),a  
2d5a 3a 69 2d			ld a, (.dmark+1)  
2d5d 32 72 ee			ld (debug_mark+1),a  
2d60 3a 6a 2d			ld a, (.dmark+2)  
2d63 32 73 ee			ld (debug_mark+2),a  
2d66 18 03			jr .pastdmark  
2d68 ..			.dmark: db "-2s"  
2d6b f1			.pastdmark: pop af  
2d6c			endm  
# End of macro DMARK
2d6c						CALLMONITOR 
2d6c cd ae 15			call break_point_state  
2d6f				endm  
# End of macro CALLMONITOR
2d6f					endif 
2d6f			 
2d6f					; Address 
2d6f			 
2d6f					FORTH_DSP_VALUEHL 
2d6f cd 16 1e			call macro_dsp_valuehl 
2d72				endm 
# End of macro FORTH_DSP_VALUEHL
2d72			 
2d72 e5					push hl    ; save address 
2d73			 
2d73					; load content into de 
2d73			 
2d73 5e					ld e,(hl) 
2d74 23					inc hl 
2d75 56					ld d, (hl) 
2d76			 
2d76					if DEBUG_FORTH_WORDS 
2d76						DMARK "-2a" 
2d76 f5				push af  
2d77 3a 8b 2d			ld a, (.dmark)  
2d7a 32 71 ee			ld (debug_mark),a  
2d7d 3a 8c 2d			ld a, (.dmark+1)  
2d80 32 72 ee			ld (debug_mark+1),a  
2d83 3a 8d 2d			ld a, (.dmark+2)  
2d86 32 73 ee			ld (debug_mark+2),a  
2d89 18 03			jr .pastdmark  
2d8b ..			.dmark: db "-2a"  
2d8e f1			.pastdmark: pop af  
2d8f			endm  
# End of macro DMARK
2d8f						CALLMONITOR 
2d8f cd ae 15			call break_point_state  
2d92				endm  
# End of macro CALLMONITOR
2d92					endif 
2d92			 
2d92					FORTH_DSP_POP 
2d92 cd ce 1e			call macro_forth_dsp_pop 
2d95				endm 
# End of macro FORTH_DSP_POP
2d95			 
2d95					; Get value to remove 
2d95			 
2d95					FORTH_DSP_VALUE 
2d95 cd ff 1d			call macro_forth_dsp_value 
2d98				endm 
# End of macro FORTH_DSP_VALUE
2d98			 
2d98					if DEBUG_FORTH_WORDS 
2d98						DMARK "-2v" 
2d98 f5				push af  
2d99 3a ad 2d			ld a, (.dmark)  
2d9c 32 71 ee			ld (debug_mark),a  
2d9f 3a ae 2d			ld a, (.dmark+1)  
2da2 32 72 ee			ld (debug_mark+1),a  
2da5 3a af 2d			ld a, (.dmark+2)  
2da8 32 73 ee			ld (debug_mark+2),a  
2dab 18 03			jr .pastdmark  
2dad ..			.dmark: db "-2v"  
2db0 f1			.pastdmark: pop af  
2db1			endm  
# End of macro DMARK
2db1						CALLMONITOR 
2db1 cd ae 15			call break_point_state  
2db4				endm  
# End of macro CALLMONITOR
2db4					endif 
2db4			 
2db4 eb					ex de, hl 
2db5 ed 52				sbc hl, de 
2db7			 
2db7					if DEBUG_FORTH_WORDS 
2db7						DMARK "-2d" 
2db7 f5				push af  
2db8 3a cc 2d			ld a, (.dmark)  
2dbb 32 71 ee			ld (debug_mark),a  
2dbe 3a cd 2d			ld a, (.dmark+1)  
2dc1 32 72 ee			ld (debug_mark+1),a  
2dc4 3a ce 2d			ld a, (.dmark+2)  
2dc7 32 73 ee			ld (debug_mark+2),a  
2dca 18 03			jr .pastdmark  
2dcc ..			.dmark: db "-2d"  
2dcf f1			.pastdmark: pop af  
2dd0			endm  
# End of macro DMARK
2dd0						CALLMONITOR 
2dd0 cd ae 15			call break_point_state  
2dd3				endm  
# End of macro CALLMONITOR
2dd3					endif 
2dd3			 
2dd3					; move result to de 
2dd3			 
2dd3 eb					ex de, hl 
2dd4			 
2dd4					; Address 
2dd4			 
2dd4 e1					pop hl 
2dd5			 
2dd5					; save it back 
2dd5			 
2dd5 73					ld (hl), e 
2dd6 23					inc hl 
2dd7 72					ld (hl), d 
2dd8			 
2dd8					if DEBUG_FORTH_WORDS 
2dd8						DMARK "-2e" 
2dd8 f5				push af  
2dd9 3a ed 2d			ld a, (.dmark)  
2ddc 32 71 ee			ld (debug_mark),a  
2ddf 3a ee 2d			ld a, (.dmark+1)  
2de2 32 72 ee			ld (debug_mark+1),a  
2de5 3a ef 2d			ld a, (.dmark+2)  
2de8 32 73 ee			ld (debug_mark+2),a  
2deb 18 03			jr .pastdmark  
2ded ..			.dmark: db "-2e"  
2df0 f1			.pastdmark: pop af  
2df1			endm  
# End of macro DMARK
2df1						CALLMONITOR 
2df1 cd ae 15			call break_point_state  
2df4				endm  
# End of macro CALLMONITOR
2df4					endif 
2df4			 
2df4			 
2df4			 
2df4			 
2df4			 
2df4				       NEXTW 
2df4 c3 8d 1f			jp macro_next 
2df7				endm 
# End of macro NEXTW
2df7			.GET2: 
2df7				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2df7 6f				db WORD_SYS_CORE+91             
2df8 27 2e			dw .BANG2            
2dfa 03				db 2 + 1 
2dfb .. 00			db "2@",0              
2dfe				endm 
# End of macro CWHEAD
2dfe			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2dfe					if DEBUG_FORTH_WORDS_KEY 
2dfe						DMARK "2A_" 
2dfe f5				push af  
2dff 3a 13 2e			ld a, (.dmark)  
2e02 32 71 ee			ld (debug_mark),a  
2e05 3a 14 2e			ld a, (.dmark+1)  
2e08 32 72 ee			ld (debug_mark+1),a  
2e0b 3a 15 2e			ld a, (.dmark+2)  
2e0e 32 73 ee			ld (debug_mark+2),a  
2e11 18 03			jr .pastdmark  
2e13 ..			.dmark: db "2A_"  
2e16 f1			.pastdmark: pop af  
2e17			endm  
# End of macro DMARK
2e17						CALLMONITOR 
2e17 cd ae 15			call break_point_state  
2e1a				endm  
# End of macro CALLMONITOR
2e1a					endif 
2e1a			 
2e1a					FORTH_DSP_VALUEHL 
2e1a cd 16 1e			call macro_dsp_valuehl 
2e1d				endm 
# End of macro FORTH_DSP_VALUEHL
2e1d			 
2e1d 5e					ld e, (hl) 
2e1e 23					inc hl 
2e1f 56					ld d, (hl) 
2e20			 
2e20 eb					ex de, hl 
2e21			 
2e21 cd 1f 1c				call forth_push_numhl 
2e24			 
2e24				       NEXTW 
2e24 c3 8d 1f			jp macro_next 
2e27				endm 
# End of macro NEXTW
2e27			.BANG2: 
2e27				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2e27 6f				db WORD_SYS_CORE+91             
2e28 5f 2e			dw .CONFIG            
2e2a 03				db 2 + 1 
2e2b .. 00			db "2!",0              
2e2e				endm 
# End of macro CWHEAD
2e2e			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2e2e					if DEBUG_FORTH_WORDS_KEY 
2e2e						DMARK "2S_" 
2e2e f5				push af  
2e2f 3a 43 2e			ld a, (.dmark)  
2e32 32 71 ee			ld (debug_mark),a  
2e35 3a 44 2e			ld a, (.dmark+1)  
2e38 32 72 ee			ld (debug_mark+1),a  
2e3b 3a 45 2e			ld a, (.dmark+2)  
2e3e 32 73 ee			ld (debug_mark+2),a  
2e41 18 03			jr .pastdmark  
2e43 ..			.dmark: db "2S_"  
2e46 f1			.pastdmark: pop af  
2e47			endm  
# End of macro DMARK
2e47						CALLMONITOR 
2e47 cd ae 15			call break_point_state  
2e4a				endm  
# End of macro CALLMONITOR
2e4a					endif 
2e4a			 
2e4a					FORTH_DSP_VALUEHL 
2e4a cd 16 1e			call macro_dsp_valuehl 
2e4d				endm 
# End of macro FORTH_DSP_VALUEHL
2e4d			 
2e4d e5					push hl   ; save address 
2e4e			 
2e4e			 
2e4e					FORTH_DSP_POP 
2e4e cd ce 1e			call macro_forth_dsp_pop 
2e51				endm 
# End of macro FORTH_DSP_POP
2e51			 
2e51					 
2e51					FORTH_DSP_VALUEHL 
2e51 cd 16 1e			call macro_dsp_valuehl 
2e54				endm 
# End of macro FORTH_DSP_VALUEHL
2e54			 
2e54					FORTH_DSP_POP 
2e54 cd ce 1e			call macro_forth_dsp_pop 
2e57				endm 
# End of macro FORTH_DSP_POP
2e57			 
2e57 eb					ex de, hl    ; value now in de 
2e58			 
2e58 e1					pop hl 
2e59			 
2e59 73					ld (hl), e 
2e5a			 
2e5a 23					inc hl 
2e5b			 
2e5b 72					ld (hl), d 
2e5c			 
2e5c			 
2e5c				       NEXTW 
2e5c c3 8d 1f			jp macro_next 
2e5f				endm 
# End of macro NEXTW
2e5f			.CONFIG: 
2e5f				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2e5f 6f				db WORD_SYS_CORE+91             
2e60 70 2e			dw .ENDCORE            
2e62 07				db 6 + 1 
2e63 .. 00			db "CONFIG",0              
2e6a				endm 
# End of macro CWHEAD
2e6a			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2e6a			 
2e6a cd 0d 14				call config 
2e6d					NEXTW 
2e6d c3 8d 1f			jp macro_next 
2e70				endm 
# End of macro NEXTW
2e70			.ENDCORE: 
2e70			 
2e70			; eof 
2e70			 
2e70			 
# End of file forth_words_core.asm
2e70			include "forth_words_flow.asm" 
2e70			 
2e70			; | ## Program Flow Words 
2e70			 
2e70			.IF: 
2e70				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2e70 1e				db WORD_SYS_CORE+10             
2e71 65 2f			dw .THEN            
2e73 03				db 2 + 1 
2e74 .. 00			db "IF",0              
2e77				endm 
# End of macro CWHEAD
2e77			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2e77			; 
2e77					if DEBUG_FORTH_WORDS_KEY 
2e77						DMARK "IF." 
2e77 f5				push af  
2e78 3a 8c 2e			ld a, (.dmark)  
2e7b 32 71 ee			ld (debug_mark),a  
2e7e 3a 8d 2e			ld a, (.dmark+1)  
2e81 32 72 ee			ld (debug_mark+1),a  
2e84 3a 8e 2e			ld a, (.dmark+2)  
2e87 32 73 ee			ld (debug_mark+2),a  
2e8a 18 03			jr .pastdmark  
2e8c ..			.dmark: db "IF."  
2e8f f1			.pastdmark: pop af  
2e90			endm  
# End of macro DMARK
2e90						CALLMONITOR 
2e90 cd ae 15			call break_point_state  
2e93				endm  
# End of macro CALLMONITOR
2e93					endif 
2e93			; eval TOS 
2e93			 
2e93				FORTH_DSP_VALUEHL 
2e93 cd 16 1e			call macro_dsp_valuehl 
2e96				endm 
# End of macro FORTH_DSP_VALUEHL
2e96			 
2e96			;	push hl 
2e96				FORTH_DSP_POP 
2e96 cd ce 1e			call macro_forth_dsp_pop 
2e99				endm 
# End of macro FORTH_DSP_POP
2e99			;	pop hl 
2e99			 
2e99					if DEBUG_FORTH_WORDS 
2e99						DMARK "IF1" 
2e99 f5				push af  
2e9a 3a ae 2e			ld a, (.dmark)  
2e9d 32 71 ee			ld (debug_mark),a  
2ea0 3a af 2e			ld a, (.dmark+1)  
2ea3 32 72 ee			ld (debug_mark+1),a  
2ea6 3a b0 2e			ld a, (.dmark+2)  
2ea9 32 73 ee			ld (debug_mark+2),a  
2eac 18 03			jr .pastdmark  
2eae ..			.dmark: db "IF1"  
2eb1 f1			.pastdmark: pop af  
2eb2			endm  
# End of macro DMARK
2eb2						CALLMONITOR 
2eb2 cd ae 15			call break_point_state  
2eb5				endm  
# End of macro CALLMONITOR
2eb5					endif 
2eb5 b7				or a        ; clear carry flag 
2eb6 11 00 00			ld de, 0 
2eb9 eb				ex de,hl 
2eba ed 52			sbc hl, de 
2ebc c2 46 2f			jp nz, .iftrue 
2ebf			 
2ebf					if DEBUG_FORTH_WORDS 
2ebf						DMARK "IF2" 
2ebf f5				push af  
2ec0 3a d4 2e			ld a, (.dmark)  
2ec3 32 71 ee			ld (debug_mark),a  
2ec6 3a d5 2e			ld a, (.dmark+1)  
2ec9 32 72 ee			ld (debug_mark+1),a  
2ecc 3a d6 2e			ld a, (.dmark+2)  
2ecf 32 73 ee			ld (debug_mark+2),a  
2ed2 18 03			jr .pastdmark  
2ed4 ..			.dmark: db "IF2"  
2ed7 f1			.pastdmark: pop af  
2ed8			endm  
# End of macro DMARK
2ed8						CALLMONITOR 
2ed8 cd ae 15			call break_point_state  
2edb				endm  
# End of macro CALLMONITOR
2edb					endif 
2edb			 
2edb			; if not true then skip to THEN 
2edb			 
2edb				; TODO get tok_ptr 
2edb				; TODO consume toks until we get to THEN 
2edb			 
2edb 2a 00 e6			ld hl, (os_tok_ptr) 
2ede					if DEBUG_FORTH_WORDS 
2ede						DMARK "IF3" 
2ede f5				push af  
2edf 3a f3 2e			ld a, (.dmark)  
2ee2 32 71 ee			ld (debug_mark),a  
2ee5 3a f4 2e			ld a, (.dmark+1)  
2ee8 32 72 ee			ld (debug_mark+1),a  
2eeb 3a f5 2e			ld a, (.dmark+2)  
2eee 32 73 ee			ld (debug_mark+2),a  
2ef1 18 03			jr .pastdmark  
2ef3 ..			.dmark: db "IF3"  
2ef6 f1			.pastdmark: pop af  
2ef7			endm  
# End of macro DMARK
2ef7						CALLMONITOR 
2ef7 cd ae 15			call break_point_state  
2efa				endm  
# End of macro CALLMONITOR
2efa						 
2efa					endif 
2efa 11 41 2f			ld de, .ifthen 
2efd					if DEBUG_FORTH_WORDS 
2efd						DMARK "IF4" 
2efd f5				push af  
2efe 3a 12 2f			ld a, (.dmark)  
2f01 32 71 ee			ld (debug_mark),a  
2f04 3a 13 2f			ld a, (.dmark+1)  
2f07 32 72 ee			ld (debug_mark+1),a  
2f0a 3a 14 2f			ld a, (.dmark+2)  
2f0d 32 73 ee			ld (debug_mark+2),a  
2f10 18 03			jr .pastdmark  
2f12 ..			.dmark: db "IF4"  
2f15 f1			.pastdmark: pop af  
2f16			endm  
# End of macro DMARK
2f16						CALLMONITOR 
2f16 cd ae 15			call break_point_state  
2f19				endm  
# End of macro CALLMONITOR
2f19					endif 
2f19 cd a8 20			call findnexttok  
2f1c			 
2f1c					if DEBUG_FORTH_WORDS 
2f1c						DMARK "IF5" 
2f1c f5				push af  
2f1d 3a 31 2f			ld a, (.dmark)  
2f20 32 71 ee			ld (debug_mark),a  
2f23 3a 32 2f			ld a, (.dmark+1)  
2f26 32 72 ee			ld (debug_mark+1),a  
2f29 3a 33 2f			ld a, (.dmark+2)  
2f2c 32 73 ee			ld (debug_mark+2),a  
2f2f 18 03			jr .pastdmark  
2f31 ..			.dmark: db "IF5"  
2f34 f1			.pastdmark: pop af  
2f35			endm  
# End of macro DMARK
2f35						CALLMONITOR 
2f35 cd ae 15			call break_point_state  
2f38				endm  
# End of macro CALLMONITOR
2f38					endif 
2f38				; TODO replace below with ; exec using tok_ptr 
2f38 22 00 e6			ld (os_tok_ptr), hl 
2f3b c3 1e 20			jp exec1 
2f3e				NEXTW 
2f3e c3 8d 1f			jp macro_next 
2f41				endm 
# End of macro NEXTW
2f41			 
2f41 .. 00		.ifthen:  db "THEN",0 
2f46			 
2f46			.iftrue:		 
2f46				; Exec next words normally 
2f46			 
2f46				; if true then exec following IF as normal 
2f46					if DEBUG_FORTH_WORDS 
2f46						DMARK "IFT" 
2f46 f5				push af  
2f47 3a 5b 2f			ld a, (.dmark)  
2f4a 32 71 ee			ld (debug_mark),a  
2f4d 3a 5c 2f			ld a, (.dmark+1)  
2f50 32 72 ee			ld (debug_mark+1),a  
2f53 3a 5d 2f			ld a, (.dmark+2)  
2f56 32 73 ee			ld (debug_mark+2),a  
2f59 18 03			jr .pastdmark  
2f5b ..			.dmark: db "IFT"  
2f5e f1			.pastdmark: pop af  
2f5f			endm  
# End of macro DMARK
2f5f						CALLMONITOR 
2f5f cd ae 15			call break_point_state  
2f62				endm  
# End of macro CALLMONITOR
2f62					endif 
2f62			 
2f62					NEXTW 
2f62 c3 8d 1f			jp macro_next 
2f65				endm 
# End of macro NEXTW
2f65			.THEN: 
2f65				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2f65 1f				db WORD_SYS_CORE+11             
2f66 8d 2f			dw .ELSE            
2f68 05				db 4 + 1 
2f69 .. 00			db "THEN",0              
2f6e				endm 
# End of macro CWHEAD
2f6e			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2f6e					if DEBUG_FORTH_WORDS_KEY 
2f6e						DMARK "THN" 
2f6e f5				push af  
2f6f 3a 83 2f			ld a, (.dmark)  
2f72 32 71 ee			ld (debug_mark),a  
2f75 3a 84 2f			ld a, (.dmark+1)  
2f78 32 72 ee			ld (debug_mark+1),a  
2f7b 3a 85 2f			ld a, (.dmark+2)  
2f7e 32 73 ee			ld (debug_mark+2),a  
2f81 18 03			jr .pastdmark  
2f83 ..			.dmark: db "THN"  
2f86 f1			.pastdmark: pop af  
2f87			endm  
# End of macro DMARK
2f87						CALLMONITOR 
2f87 cd ae 15			call break_point_state  
2f8a				endm  
# End of macro CALLMONITOR
2f8a					endif 
2f8a					NEXTW 
2f8a c3 8d 1f			jp macro_next 
2f8d				endm 
# End of macro NEXTW
2f8d			.ELSE: 
2f8d				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2f8d 20				db WORD_SYS_CORE+12             
2f8e b5 2f			dw .DO            
2f90 03				db 2 + 1 
2f91 .. 00			db "ELSE",0              
2f96				endm 
# End of macro CWHEAD
2f96			; | ELSE ( -- ) Not supported - does nothing | TODO 
2f96			 
2f96					if DEBUG_FORTH_WORDS_KEY 
2f96						DMARK "ELS" 
2f96 f5				push af  
2f97 3a ab 2f			ld a, (.dmark)  
2f9a 32 71 ee			ld (debug_mark),a  
2f9d 3a ac 2f			ld a, (.dmark+1)  
2fa0 32 72 ee			ld (debug_mark+1),a  
2fa3 3a ad 2f			ld a, (.dmark+2)  
2fa6 32 73 ee			ld (debug_mark+2),a  
2fa9 18 03			jr .pastdmark  
2fab ..			.dmark: db "ELS"  
2fae f1			.pastdmark: pop af  
2faf			endm  
# End of macro DMARK
2faf						CALLMONITOR 
2faf cd ae 15			call break_point_state  
2fb2				endm  
# End of macro CALLMONITOR
2fb2					endif 
2fb2			 
2fb2			 
2fb2					NEXTW 
2fb2 c3 8d 1f			jp macro_next 
2fb5				endm 
# End of macro NEXTW
2fb5			.DO: 
2fb5				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2fb5 21				db WORD_SYS_CORE+13             
2fb6 dc 30			dw .LOOP            
2fb8 03				db 2 + 1 
2fb9 .. 00			db "DO",0              
2fbc				endm 
# End of macro CWHEAD
2fbc			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2fbc			 
2fbc					if DEBUG_FORTH_WORDS_KEY 
2fbc						DMARK "DO." 
2fbc f5				push af  
2fbd 3a d1 2f			ld a, (.dmark)  
2fc0 32 71 ee			ld (debug_mark),a  
2fc3 3a d2 2f			ld a, (.dmark+1)  
2fc6 32 72 ee			ld (debug_mark+1),a  
2fc9 3a d3 2f			ld a, (.dmark+2)  
2fcc 32 73 ee			ld (debug_mark+2),a  
2fcf 18 03			jr .pastdmark  
2fd1 ..			.dmark: db "DO."  
2fd4 f1			.pastdmark: pop af  
2fd5			endm  
# End of macro DMARK
2fd5						CALLMONITOR 
2fd5 cd ae 15			call break_point_state  
2fd8				endm  
# End of macro CALLMONITOR
2fd8					endif 
2fd8			;  push pc to rsp stack past the DO 
2fd8			 
2fd8 2a 00 e6				ld hl, (os_tok_ptr) 
2fdb 23					inc hl   ; D 
2fdc 23					inc hl  ; O 
2fdd 23					inc hl   ; null 
2fde					if DEBUG_FORTH_WORDS 
2fde						DMARK "DO2" 
2fde f5				push af  
2fdf 3a f3 2f			ld a, (.dmark)  
2fe2 32 71 ee			ld (debug_mark),a  
2fe5 3a f4 2f			ld a, (.dmark+1)  
2fe8 32 72 ee			ld (debug_mark+1),a  
2feb 3a f5 2f			ld a, (.dmark+2)  
2fee 32 73 ee			ld (debug_mark+2),a  
2ff1 18 03			jr .pastdmark  
2ff3 ..			.dmark: db "DO2"  
2ff6 f1			.pastdmark: pop af  
2ff7			endm  
# End of macro DMARK
2ff7						CALLMONITOR 
2ff7 cd ae 15			call break_point_state  
2ffa				endm  
# End of macro CALLMONITOR
2ffa					endif 
2ffa					FORTH_RSP_NEXT 
2ffa cd c6 1b			call macro_forth_rsp_next 
2ffd				endm 
# End of macro FORTH_RSP_NEXT
2ffd					if DEBUG_FORTH_WORDS 
2ffd						DMARK "DO3" 
2ffd f5				push af  
2ffe 3a 12 30			ld a, (.dmark)  
3001 32 71 ee			ld (debug_mark),a  
3004 3a 13 30			ld a, (.dmark+1)  
3007 32 72 ee			ld (debug_mark+1),a  
300a 3a 14 30			ld a, (.dmark+2)  
300d 32 73 ee			ld (debug_mark+2),a  
3010 18 03			jr .pastdmark  
3012 ..			.dmark: db "DO3"  
3015 f1			.pastdmark: pop af  
3016			endm  
# End of macro DMARK
3016						CALLMONITOR 
3016 cd ae 15			call break_point_state  
3019				endm  
# End of macro CALLMONITOR
3019					endif 
3019			 
3019					;if DEBUG_FORTH_WORDS 
3019				;		push hl 
3019			;		endif  
3019			 
3019			; get counters from data stack 
3019			 
3019			 
3019					FORTH_DSP_VALUEHL 
3019 cd 16 1e			call macro_dsp_valuehl 
301c				endm 
# End of macro FORTH_DSP_VALUEHL
301c e5					push hl		 ; hl now has starting counter which needs to be tos 
301d			 
301d					if DEBUG_FORTH_WORDS 
301d						DMARK "DO4" 
301d f5				push af  
301e 3a 32 30			ld a, (.dmark)  
3021 32 71 ee			ld (debug_mark),a  
3024 3a 33 30			ld a, (.dmark+1)  
3027 32 72 ee			ld (debug_mark+1),a  
302a 3a 34 30			ld a, (.dmark+2)  
302d 32 73 ee			ld (debug_mark+2),a  
3030 18 03			jr .pastdmark  
3032 ..			.dmark: db "DO4"  
3035 f1			.pastdmark: pop af  
3036			endm  
# End of macro DMARK
3036						CALLMONITOR 
3036 cd ae 15			call break_point_state  
3039				endm  
# End of macro CALLMONITOR
3039					endif 
3039					FORTH_DSP_POP 
3039 cd ce 1e			call macro_forth_dsp_pop 
303c				endm 
# End of macro FORTH_DSP_POP
303c			 
303c					if DEBUG_FORTH_WORDS 
303c						DMARK "DO5" 
303c f5				push af  
303d 3a 51 30			ld a, (.dmark)  
3040 32 71 ee			ld (debug_mark),a  
3043 3a 52 30			ld a, (.dmark+1)  
3046 32 72 ee			ld (debug_mark+1),a  
3049 3a 53 30			ld a, (.dmark+2)  
304c 32 73 ee			ld (debug_mark+2),a  
304f 18 03			jr .pastdmark  
3051 ..			.dmark: db "DO5"  
3054 f1			.pastdmark: pop af  
3055			endm  
# End of macro DMARK
3055						CALLMONITOR 
3055 cd ae 15			call break_point_state  
3058				endm  
# End of macro CALLMONITOR
3058					endif 
3058			 
3058					FORTH_DSP_VALUEHL 
3058 cd 16 1e			call macro_dsp_valuehl 
305b				endm 
# End of macro FORTH_DSP_VALUEHL
305b			;		push hl		 ; hl now has starting limit counter 
305b			 
305b					if DEBUG_FORTH_WORDS 
305b						DMARK "DO6" 
305b f5				push af  
305c 3a 70 30			ld a, (.dmark)  
305f 32 71 ee			ld (debug_mark),a  
3062 3a 71 30			ld a, (.dmark+1)  
3065 32 72 ee			ld (debug_mark+1),a  
3068 3a 72 30			ld a, (.dmark+2)  
306b 32 73 ee			ld (debug_mark+2),a  
306e 18 03			jr .pastdmark  
3070 ..			.dmark: db "DO6"  
3073 f1			.pastdmark: pop af  
3074			endm  
# End of macro DMARK
3074						CALLMONITOR 
3074 cd ae 15			call break_point_state  
3077				endm  
# End of macro CALLMONITOR
3077					endif 
3077					FORTH_DSP_POP 
3077 cd ce 1e			call macro_forth_dsp_pop 
307a				endm 
# End of macro FORTH_DSP_POP
307a			 
307a			; put counters on the loop stack 
307a			 
307a			;		pop hl			 ; limit counter 
307a d1					pop de			; start counter 
307b			 
307b					; push limit counter 
307b			 
307b					if DEBUG_FORTH_WORDS 
307b						DMARK "DO7" 
307b f5				push af  
307c 3a 90 30			ld a, (.dmark)  
307f 32 71 ee			ld (debug_mark),a  
3082 3a 91 30			ld a, (.dmark+1)  
3085 32 72 ee			ld (debug_mark+1),a  
3088 3a 92 30			ld a, (.dmark+2)  
308b 32 73 ee			ld (debug_mark+2),a  
308e 18 03			jr .pastdmark  
3090 ..			.dmark: db "DO7"  
3093 f1			.pastdmark: pop af  
3094			endm  
# End of macro DMARK
3094						CALLMONITOR 
3094 cd ae 15			call break_point_state  
3097				endm  
# End of macro CALLMONITOR
3097					endif 
3097					FORTH_LOOP_NEXT 
3097 cd 47 1e			call macro_forth_loop_next 
309a				endm 
# End of macro FORTH_LOOP_NEXT
309a			 
309a					; push start counter 
309a			 
309a eb					ex de, hl 
309b					if DEBUG_FORTH_WORDS 
309b						DMARK "DO7" 
309b f5				push af  
309c 3a b0 30			ld a, (.dmark)  
309f 32 71 ee			ld (debug_mark),a  
30a2 3a b1 30			ld a, (.dmark+1)  
30a5 32 72 ee			ld (debug_mark+1),a  
30a8 3a b2 30			ld a, (.dmark+2)  
30ab 32 73 ee			ld (debug_mark+2),a  
30ae 18 03			jr .pastdmark  
30b0 ..			.dmark: db "DO7"  
30b3 f1			.pastdmark: pop af  
30b4			endm  
# End of macro DMARK
30b4						CALLMONITOR 
30b4 cd ae 15			call break_point_state  
30b7				endm  
# End of macro CALLMONITOR
30b7					endif 
30b7					FORTH_LOOP_NEXT 
30b7 cd 47 1e			call macro_forth_loop_next 
30ba				endm 
# End of macro FORTH_LOOP_NEXT
30ba			 
30ba			 
30ba					; init first round of I counter 
30ba			 
30ba 22 24 e6				ld (os_current_i), hl 
30bd			 
30bd					if DEBUG_FORTH_WORDS 
30bd						DMARK "DO8" 
30bd f5				push af  
30be 3a d2 30			ld a, (.dmark)  
30c1 32 71 ee			ld (debug_mark),a  
30c4 3a d3 30			ld a, (.dmark+1)  
30c7 32 72 ee			ld (debug_mark+1),a  
30ca 3a d4 30			ld a, (.dmark+2)  
30cd 32 73 ee			ld (debug_mark+2),a  
30d0 18 03			jr .pastdmark  
30d2 ..			.dmark: db "DO8"  
30d5 f1			.pastdmark: pop af  
30d6			endm  
# End of macro DMARK
30d6						CALLMONITOR 
30d6 cd ae 15			call break_point_state  
30d9				endm  
# End of macro CALLMONITOR
30d9					endif 
30d9			 
30d9					NEXTW 
30d9 c3 8d 1f			jp macro_next 
30dc				endm 
# End of macro NEXTW
30dc			.LOOP: 
30dc				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
30dc 22				db WORD_SYS_CORE+14             
30dd f4 31			dw .I            
30df 05				db 4 + 1 
30e0 .. 00			db "LOOP",0              
30e5				endm 
# End of macro CWHEAD
30e5			; | LOOP ( -- ) Increment and test loop counter  | DONE 
30e5			 
30e5				; pop tos as current loop count to hl 
30e5			 
30e5				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
30e5			 
30e5				FORTH_LOOP_TOS 
30e5 cd 7a 1e			call macro_forth_loop_tos 
30e8				endm 
# End of macro FORTH_LOOP_TOS
30e8 e5				push hl 
30e9			 
30e9					if DEBUG_FORTH_WORDS_KEY 
30e9						DMARK "LOP" 
30e9 f5				push af  
30ea 3a fe 30			ld a, (.dmark)  
30ed 32 71 ee			ld (debug_mark),a  
30f0 3a ff 30			ld a, (.dmark+1)  
30f3 32 72 ee			ld (debug_mark+1),a  
30f6 3a 00 31			ld a, (.dmark+2)  
30f9 32 73 ee			ld (debug_mark+2),a  
30fc 18 03			jr .pastdmark  
30fe ..			.dmark: db "LOP"  
3101 f1			.pastdmark: pop af  
3102			endm  
# End of macro DMARK
3102						CALLMONITOR 
3102 cd ae 15			call break_point_state  
3105				endm  
# End of macro CALLMONITOR
3105					endif 
3105				; next item on the stack is the limit. get it 
3105			 
3105			 
3105				FORTH_LOOP_POP 
3105 cd 84 1e			call macro_forth_loop_pop 
3108				endm 
# End of macro FORTH_LOOP_POP
3108			 
3108				FORTH_LOOP_TOS 
3108 cd 7a 1e			call macro_forth_loop_tos 
310b				endm 
# End of macro FORTH_LOOP_TOS
310b			 
310b d1				pop de		 ; de = i, hl = limit 
310c			 
310c					if DEBUG_FORTH_WORDS 
310c						DMARK "LP1" 
310c f5				push af  
310d 3a 21 31			ld a, (.dmark)  
3110 32 71 ee			ld (debug_mark),a  
3113 3a 22 31			ld a, (.dmark+1)  
3116 32 72 ee			ld (debug_mark+1),a  
3119 3a 23 31			ld a, (.dmark+2)  
311c 32 73 ee			ld (debug_mark+2),a  
311f 18 03			jr .pastdmark  
3121 ..			.dmark: db "LP1"  
3124 f1			.pastdmark: pop af  
3125			endm  
# End of macro DMARK
3125						CALLMONITOR 
3125 cd ae 15			call break_point_state  
3128				endm  
# End of macro CALLMONITOR
3128					endif 
3128			 
3128				; go back to previous word 
3128			 
3128 d5				push de    ; save I for inc later 
3129			 
3129			 
3129				; get limit 
3129				;  is I at limit? 
3129			 
3129			 
3129					if DEBUG_FORTH_WORDS 
3129						DMARK "LP1" 
3129 f5				push af  
312a 3a 3e 31			ld a, (.dmark)  
312d 32 71 ee			ld (debug_mark),a  
3130 3a 3f 31			ld a, (.dmark+1)  
3133 32 72 ee			ld (debug_mark+1),a  
3136 3a 40 31			ld a, (.dmark+2)  
3139 32 73 ee			ld (debug_mark+2),a  
313c 18 03			jr .pastdmark  
313e ..			.dmark: db "LP1"  
3141 f1			.pastdmark: pop af  
3142			endm  
# End of macro DMARK
3142						CALLMONITOR 
3142 cd ae 15			call break_point_state  
3145				endm  
# End of macro CALLMONITOR
3145					endif 
3145			 
3145 ed 52			sbc hl, de 
3147			 
3147			 
3147				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3147			 
3147 20 26				jr nz, .loopnotdone 
3149			 
3149 e1				pop hl   ; get rid of saved I 
314a				FORTH_LOOP_POP     ; get rid of limit 
314a cd 84 1e			call macro_forth_loop_pop 
314d				endm 
# End of macro FORTH_LOOP_POP
314d			 
314d				FORTH_RSP_POP     ; get rid of DO ptr 
314d cd e7 1b			call macro_forth_rsp_pop 
3150				endm 
# End of macro FORTH_RSP_POP
3150			 
3150			if DEBUG_FORTH_WORDS 
3150						DMARK "LP>" 
3150 f5				push af  
3151 3a 65 31			ld a, (.dmark)  
3154 32 71 ee			ld (debug_mark),a  
3157 3a 66 31			ld a, (.dmark+1)  
315a 32 72 ee			ld (debug_mark+1),a  
315d 3a 67 31			ld a, (.dmark+2)  
3160 32 73 ee			ld (debug_mark+2),a  
3163 18 03			jr .pastdmark  
3165 ..			.dmark: db "LP>"  
3168 f1			.pastdmark: pop af  
3169			endm  
# End of macro DMARK
3169				CALLMONITOR 
3169 cd ae 15			call break_point_state  
316c				endm  
# End of macro CALLMONITOR
316c			endif 
316c			 
316c					NEXTW 
316c c3 8d 1f			jp macro_next 
316f				endm 
# End of macro NEXTW
316f				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
316f			 
316f			.loopnotdone: 
316f			 
316f e1				pop hl    ; get I 
3170 23				inc hl 
3171			 
3171			   	; save new I 
3171			 
3171			 
3171					; set I counter 
3171			 
3171 22 24 e6				ld (os_current_i), hl 
3174			 
3174					if DEBUG_FORTH_WORDS 
3174						DMARK "LPN" 
3174 f5				push af  
3175 3a 89 31			ld a, (.dmark)  
3178 32 71 ee			ld (debug_mark),a  
317b 3a 8a 31			ld a, (.dmark+1)  
317e 32 72 ee			ld (debug_mark+1),a  
3181 3a 8b 31			ld a, (.dmark+2)  
3184 32 73 ee			ld (debug_mark+2),a  
3187 18 03			jr .pastdmark  
3189 ..			.dmark: db "LPN"  
318c f1			.pastdmark: pop af  
318d			endm  
# End of macro DMARK
318d					CALLMONITOR 
318d cd ae 15			call break_point_state  
3190				endm  
# End of macro CALLMONITOR
3190					endif 
3190					 
3190				FORTH_LOOP_NEXT 
3190 cd 47 1e			call macro_forth_loop_next 
3193				endm 
# End of macro FORTH_LOOP_NEXT
3193			 
3193			 
3193					if DEBUG_FORTH_WORDS 
3193 eb						ex de,hl 
3194					endif 
3194			 
3194			;	; get DO ptr 
3194			; 
3194					if DEBUG_FORTH_WORDS 
3194						DMARK "LP7" 
3194 f5				push af  
3195 3a a9 31			ld a, (.dmark)  
3198 32 71 ee			ld (debug_mark),a  
319b 3a aa 31			ld a, (.dmark+1)  
319e 32 72 ee			ld (debug_mark+1),a  
31a1 3a ab 31			ld a, (.dmark+2)  
31a4 32 73 ee			ld (debug_mark+2),a  
31a7 18 03			jr .pastdmark  
31a9 ..			.dmark: db "LP7"  
31ac f1			.pastdmark: pop af  
31ad			endm  
# End of macro DMARK
31ad					CALLMONITOR 
31ad cd ae 15			call break_point_state  
31b0				endm  
# End of macro CALLMONITOR
31b0					endif 
31b0				FORTH_RSP_TOS 
31b0 cd dd 1b			call macro_forth_rsp_tos 
31b3				endm 
# End of macro FORTH_RSP_TOS
31b3			 
31b3					if DEBUG_FORTH_WORDS 
31b3						DMARK "LP8" 
31b3 f5				push af  
31b4 3a c8 31			ld a, (.dmark)  
31b7 32 71 ee			ld (debug_mark),a  
31ba 3a c9 31			ld a, (.dmark+1)  
31bd 32 72 ee			ld (debug_mark+1),a  
31c0 3a ca 31			ld a, (.dmark+2)  
31c3 32 73 ee			ld (debug_mark+2),a  
31c6 18 03			jr .pastdmark  
31c8 ..			.dmark: db "LP8"  
31cb f1			.pastdmark: pop af  
31cc			endm  
# End of macro DMARK
31cc					CALLMONITOR 
31cc cd ae 15			call break_point_state  
31cf				endm  
# End of macro CALLMONITOR
31cf					endif 
31cf				;push hl 
31cf			 
31cf				; not going to DO any more 
31cf				; get rid of the RSP pointer as DO will add it back in 
31cf				;FORTH_RSP_POP 
31cf				;pop hl 
31cf			 
31cf				;ld hl,(cli_ret_sp) 
31cf				;ld e, (hl) 
31cf				;inc hl 
31cf				;ld d, (hl) 
31cf				;ex de,hl 
31cf 22 00 e6			ld (os_tok_ptr), hl 
31d2					if DEBUG_FORTH_WORDS 
31d2						DMARK "LP<" 
31d2 f5				push af  
31d3 3a e7 31			ld a, (.dmark)  
31d6 32 71 ee			ld (debug_mark),a  
31d9 3a e8 31			ld a, (.dmark+1)  
31dc 32 72 ee			ld (debug_mark+1),a  
31df 3a e9 31			ld a, (.dmark+2)  
31e2 32 73 ee			ld (debug_mark+2),a  
31e5 18 03			jr .pastdmark  
31e7 ..			.dmark: db "LP<"  
31ea f1			.pastdmark: pop af  
31eb			endm  
# End of macro DMARK
31eb					CALLMONITOR 
31eb cd ae 15			call break_point_state  
31ee				endm  
# End of macro CALLMONITOR
31ee				endif 
31ee c3 1e 20			jp exec1 
31f1			 
31f1					 
31f1			 
31f1			 
31f1					NEXTW 
31f1 c3 8d 1f			jp macro_next 
31f4				endm 
# End of macro NEXTW
31f4			.I:  
31f4			 
31f4				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
31f4 5e				db WORD_SYS_CORE+74             
31f5 1f 32			dw .DLOOP            
31f7 02				db 1 + 1 
31f8 .. 00			db "I",0              
31fa				endm 
# End of macro CWHEAD
31fa			; | I ( -- ) Current loop counter | DONE 
31fa					if DEBUG_FORTH_WORDS_KEY 
31fa						DMARK "I.." 
31fa f5				push af  
31fb 3a 0f 32			ld a, (.dmark)  
31fe 32 71 ee			ld (debug_mark),a  
3201 3a 10 32			ld a, (.dmark+1)  
3204 32 72 ee			ld (debug_mark+1),a  
3207 3a 11 32			ld a, (.dmark+2)  
320a 32 73 ee			ld (debug_mark+2),a  
320d 18 03			jr .pastdmark  
320f ..			.dmark: db "I.."  
3212 f1			.pastdmark: pop af  
3213			endm  
# End of macro DMARK
3213						CALLMONITOR 
3213 cd ae 15			call break_point_state  
3216				endm  
# End of macro CALLMONITOR
3216					endif 
3216			 
3216 2a 24 e6				ld hl,(os_current_i) 
3219 cd 1f 1c				call forth_push_numhl 
321c			 
321c					NEXTW 
321c c3 8d 1f			jp macro_next 
321f				endm 
# End of macro NEXTW
321f			.DLOOP: 
321f				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
321f 5f				db WORD_SYS_CORE+75             
3220 00 33			dw .REPEAT            
3222 06				db 5 + 1 
3223 .. 00			db "-LOOP",0              
3229				endm 
# End of macro CWHEAD
3229			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3229				; pop tos as current loop count to hl 
3229					if DEBUG_FORTH_WORDS_KEY 
3229						DMARK "-LP" 
3229 f5				push af  
322a 3a 3e 32			ld a, (.dmark)  
322d 32 71 ee			ld (debug_mark),a  
3230 3a 3f 32			ld a, (.dmark+1)  
3233 32 72 ee			ld (debug_mark+1),a  
3236 3a 40 32			ld a, (.dmark+2)  
3239 32 73 ee			ld (debug_mark+2),a  
323c 18 03			jr .pastdmark  
323e ..			.dmark: db "-LP"  
3241 f1			.pastdmark: pop af  
3242			endm  
# End of macro DMARK
3242						CALLMONITOR 
3242 cd ae 15			call break_point_state  
3245				endm  
# End of macro CALLMONITOR
3245					endif 
3245			 
3245				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3245			 
3245				FORTH_LOOP_TOS 
3245 cd 7a 1e			call macro_forth_loop_tos 
3248				endm 
# End of macro FORTH_LOOP_TOS
3248 e5				push hl 
3249			 
3249					if DEBUG_FORTH_WORDS 
3249						DMARK "-LP" 
3249 f5				push af  
324a 3a 5e 32			ld a, (.dmark)  
324d 32 71 ee			ld (debug_mark),a  
3250 3a 5f 32			ld a, (.dmark+1)  
3253 32 72 ee			ld (debug_mark+1),a  
3256 3a 60 32			ld a, (.dmark+2)  
3259 32 73 ee			ld (debug_mark+2),a  
325c 18 03			jr .pastdmark  
325e ..			.dmark: db "-LP"  
3261 f1			.pastdmark: pop af  
3262			endm  
# End of macro DMARK
3262						CALLMONITOR 
3262 cd ae 15			call break_point_state  
3265				endm  
# End of macro CALLMONITOR
3265					endif 
3265				; next item on the stack is the limit. get it 
3265			 
3265			 
3265				FORTH_LOOP_POP 
3265 cd 84 1e			call macro_forth_loop_pop 
3268				endm 
# End of macro FORTH_LOOP_POP
3268			 
3268				FORTH_LOOP_TOS 
3268 cd 7a 1e			call macro_forth_loop_tos 
326b				endm 
# End of macro FORTH_LOOP_TOS
326b			 
326b d1				pop de		 ; de = i, hl = limit 
326c			 
326c					if DEBUG_FORTH_WORDS 
326c						DMARK "-L1" 
326c f5				push af  
326d 3a 81 32			ld a, (.dmark)  
3270 32 71 ee			ld (debug_mark),a  
3273 3a 82 32			ld a, (.dmark+1)  
3276 32 72 ee			ld (debug_mark+1),a  
3279 3a 83 32			ld a, (.dmark+2)  
327c 32 73 ee			ld (debug_mark+2),a  
327f 18 03			jr .pastdmark  
3281 ..			.dmark: db "-L1"  
3284 f1			.pastdmark: pop af  
3285			endm  
# End of macro DMARK
3285						CALLMONITOR 
3285 cd ae 15			call break_point_state  
3288				endm  
# End of macro CALLMONITOR
3288					endif 
3288			 
3288				; go back to previous word 
3288			 
3288 d5				push de    ; save I for inc later 
3289			 
3289			 
3289				; get limit 
3289				;  is I at limit? 
3289			 
3289			 
3289					if DEBUG_FORTH_WORDS 
3289						DMARK "-L1" 
3289 f5				push af  
328a 3a 9e 32			ld a, (.dmark)  
328d 32 71 ee			ld (debug_mark),a  
3290 3a 9f 32			ld a, (.dmark+1)  
3293 32 72 ee			ld (debug_mark+1),a  
3296 3a a0 32			ld a, (.dmark+2)  
3299 32 73 ee			ld (debug_mark+2),a  
329c 18 03			jr .pastdmark  
329e ..			.dmark: db "-L1"  
32a1 f1			.pastdmark: pop af  
32a2			endm  
# End of macro DMARK
32a2						CALLMONITOR 
32a2 cd ae 15			call break_point_state  
32a5				endm  
# End of macro CALLMONITOR
32a5					endif 
32a5			 
32a5 ed 52			sbc hl, de 
32a7			 
32a7			 
32a7				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
32a7			 
32a7 20 26				jr nz, .mloopnotdone 
32a9			 
32a9 e1				pop hl   ; get rid of saved I 
32aa				FORTH_LOOP_POP     ; get rid of limit 
32aa cd 84 1e			call macro_forth_loop_pop 
32ad				endm 
# End of macro FORTH_LOOP_POP
32ad			 
32ad				FORTH_RSP_POP     ; get rid of DO ptr 
32ad cd e7 1b			call macro_forth_rsp_pop 
32b0				endm 
# End of macro FORTH_RSP_POP
32b0			 
32b0			if DEBUG_FORTH_WORDS 
32b0						DMARK "-L>" 
32b0 f5				push af  
32b1 3a c5 32			ld a, (.dmark)  
32b4 32 71 ee			ld (debug_mark),a  
32b7 3a c6 32			ld a, (.dmark+1)  
32ba 32 72 ee			ld (debug_mark+1),a  
32bd 3a c7 32			ld a, (.dmark+2)  
32c0 32 73 ee			ld (debug_mark+2),a  
32c3 18 03			jr .pastdmark  
32c5 ..			.dmark: db "-L>"  
32c8 f1			.pastdmark: pop af  
32c9			endm  
# End of macro DMARK
32c9				CALLMONITOR 
32c9 cd ae 15			call break_point_state  
32cc				endm  
# End of macro CALLMONITOR
32cc			endif 
32cc			 
32cc					NEXTW 
32cc c3 8d 1f			jp macro_next 
32cf				endm 
# End of macro NEXTW
32cf				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
32cf			 
32cf			.mloopnotdone: 
32cf			 
32cf e1				pop hl    ; get I 
32d0 2b				dec hl 
32d1			 
32d1			   	; save new I 
32d1			 
32d1			 
32d1					; set I counter 
32d1			 
32d1 22 24 e6				ld (os_current_i), hl 
32d4			 
32d4					 
32d4				FORTH_LOOP_NEXT 
32d4 cd 47 1e			call macro_forth_loop_next 
32d7				endm 
# End of macro FORTH_LOOP_NEXT
32d7			 
32d7			 
32d7					if DEBUG_FORTH_WORDS 
32d7 eb						ex de,hl 
32d8					endif 
32d8			 
32d8			;	; get DO ptr 
32d8			; 
32d8				FORTH_RSP_TOS 
32d8 cd dd 1b			call macro_forth_rsp_tos 
32db				endm 
# End of macro FORTH_RSP_TOS
32db			 
32db				;push hl 
32db			 
32db				; not going to DO any more 
32db				; get rid of the RSP pointer as DO will add it back in 
32db				;FORTH_RSP_POP 
32db				;pop hl 
32db			 
32db			 
32db 22 00 e6			ld (os_tok_ptr), hl 
32de					if DEBUG_FORTH_WORDS 
32de						DMARK "-L<" 
32de f5				push af  
32df 3a f3 32			ld a, (.dmark)  
32e2 32 71 ee			ld (debug_mark),a  
32e5 3a f4 32			ld a, (.dmark+1)  
32e8 32 72 ee			ld (debug_mark+1),a  
32eb 3a f5 32			ld a, (.dmark+2)  
32ee 32 73 ee			ld (debug_mark+2),a  
32f1 18 03			jr .pastdmark  
32f3 ..			.dmark: db "-L<"  
32f6 f1			.pastdmark: pop af  
32f7			endm  
# End of macro DMARK
32f7					CALLMONITOR 
32f7 cd ae 15			call break_point_state  
32fa				endm  
# End of macro CALLMONITOR
32fa				endif 
32fa c3 1e 20			jp exec1 
32fd			 
32fd					 
32fd			 
32fd			 
32fd			 
32fd				NEXTW 
32fd c3 8d 1f			jp macro_next 
3300				endm 
# End of macro NEXTW
3300			 
3300			 
3300			 
3300			 
3300			.REPEAT: 
3300				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3300 71				db WORD_SYS_CORE+93             
3301 53 33			dw .UNTIL            
3303 06				db 5 + 1 
3304 .. 00			db "REPEAT",0              
330b				endm 
# End of macro CWHEAD
330b			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
330b			;  push pc to rsp stack past the REPEAT 
330b					if DEBUG_FORTH_WORDS_KEY 
330b						DMARK "REP" 
330b f5				push af  
330c 3a 20 33			ld a, (.dmark)  
330f 32 71 ee			ld (debug_mark),a  
3312 3a 21 33			ld a, (.dmark+1)  
3315 32 72 ee			ld (debug_mark+1),a  
3318 3a 22 33			ld a, (.dmark+2)  
331b 32 73 ee			ld (debug_mark+2),a  
331e 18 03			jr .pastdmark  
3320 ..			.dmark: db "REP"  
3323 f1			.pastdmark: pop af  
3324			endm  
# End of macro DMARK
3324						CALLMONITOR 
3324 cd ae 15			call break_point_state  
3327				endm  
# End of macro CALLMONITOR
3327					endif 
3327			 
3327 2a 00 e6				ld hl, (os_tok_ptr) 
332a 23					inc hl   ; R 
332b 23					inc hl  ; E 
332c 23					inc hl   ; P 
332d 23					inc hl   ; E 
332e 23					inc hl   ; A 
332f 23					inc hl   ; T 
3330 23					inc hl   ; zero 
3331					FORTH_RSP_NEXT 
3331 cd c6 1b			call macro_forth_rsp_next 
3334				endm 
# End of macro FORTH_RSP_NEXT
3334			 
3334			 
3334					if DEBUG_FORTH_WORDS 
3334						DMARK "REP" 
3334 f5				push af  
3335 3a 49 33			ld a, (.dmark)  
3338 32 71 ee			ld (debug_mark),a  
333b 3a 4a 33			ld a, (.dmark+1)  
333e 32 72 ee			ld (debug_mark+1),a  
3341 3a 4b 33			ld a, (.dmark+2)  
3344 32 73 ee			ld (debug_mark+2),a  
3347 18 03			jr .pastdmark  
3349 ..			.dmark: db "REP"  
334c f1			.pastdmark: pop af  
334d			endm  
# End of macro DMARK
334d						;pop bc    ; TODO BUG ?????? what is this for???? 
334d						CALLMONITOR 
334d cd ae 15			call break_point_state  
3350				endm  
# End of macro CALLMONITOR
3350					endif 
3350			 
3350					NEXTW 
3350 c3 8d 1f			jp macro_next 
3353				endm 
# End of macro NEXTW
3353			;	       NEXTW 
3353			 
3353			.UNTIL: 
3353				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3353 72				db WORD_SYS_CORE+94             
3354 ea 33			dw .ENDFLOW            
3356 06				db 5 + 1 
3357 .. 00			db "UNTIL",0              
335d				endm 
# End of macro CWHEAD
335d			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
335d			 
335d				; pop tos as check 
335d			 
335d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
335d			 
335d				FORTH_DSP_VALUEHL 
335d cd 16 1e			call macro_dsp_valuehl 
3360				endm 
# End of macro FORTH_DSP_VALUEHL
3360			 
3360					if DEBUG_FORTH_WORDS_KEY 
3360						DMARK "UNT" 
3360 f5				push af  
3361 3a 75 33			ld a, (.dmark)  
3364 32 71 ee			ld (debug_mark),a  
3367 3a 76 33			ld a, (.dmark+1)  
336a 32 72 ee			ld (debug_mark+1),a  
336d 3a 77 33			ld a, (.dmark+2)  
3370 32 73 ee			ld (debug_mark+2),a  
3373 18 03			jr .pastdmark  
3375 ..			.dmark: db "UNT"  
3378 f1			.pastdmark: pop af  
3379			endm  
# End of macro DMARK
3379						CALLMONITOR 
3379 cd ae 15			call break_point_state  
337c				endm  
# End of macro CALLMONITOR
337c					endif 
337c			 
337c			;	push hl 
337c				FORTH_DSP_POP 
337c cd ce 1e			call macro_forth_dsp_pop 
337f				endm 
# End of macro FORTH_DSP_POP
337f			 
337f			;	pop hl 
337f			 
337f				; test if true 
337f			 
337f cd d6 0d			call ishlzero 
3382			;	ld a,l 
3382			;	add h 
3382			; 
3382			;	cp 0 
3382			 
3382 20 3e			jr nz, .untilnotdone 
3384			 
3384					if DEBUG_FORTH_WORDS 
3384						DMARK "UNf" 
3384 f5				push af  
3385 3a 99 33			ld a, (.dmark)  
3388 32 71 ee			ld (debug_mark),a  
338b 3a 9a 33			ld a, (.dmark+1)  
338e 32 72 ee			ld (debug_mark+1),a  
3391 3a 9b 33			ld a, (.dmark+2)  
3394 32 73 ee			ld (debug_mark+2),a  
3397 18 03			jr .pastdmark  
3399 ..			.dmark: db "UNf"  
339c f1			.pastdmark: pop af  
339d			endm  
# End of macro DMARK
339d						CALLMONITOR 
339d cd ae 15			call break_point_state  
33a0				endm  
# End of macro CALLMONITOR
33a0					endif 
33a0			 
33a0			 
33a0			 
33a0				FORTH_RSP_POP     ; get rid of DO ptr 
33a0 cd e7 1b			call macro_forth_rsp_pop 
33a3				endm 
# End of macro FORTH_RSP_POP
33a3			 
33a3			if DEBUG_FORTH_WORDS 
33a3						DMARK "UN>" 
33a3 f5				push af  
33a4 3a b8 33			ld a, (.dmark)  
33a7 32 71 ee			ld (debug_mark),a  
33aa 3a b9 33			ld a, (.dmark+1)  
33ad 32 72 ee			ld (debug_mark+1),a  
33b0 3a ba 33			ld a, (.dmark+2)  
33b3 32 73 ee			ld (debug_mark+2),a  
33b6 18 03			jr .pastdmark  
33b8 ..			.dmark: db "UN>"  
33bb f1			.pastdmark: pop af  
33bc			endm  
# End of macro DMARK
33bc				CALLMONITOR 
33bc cd ae 15			call break_point_state  
33bf				endm  
# End of macro CALLMONITOR
33bf			endif 
33bf			 
33bf					NEXTW 
33bf c3 8d 1f			jp macro_next 
33c2				endm 
# End of macro NEXTW
33c2				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
33c2			 
33c2			.untilnotdone: 
33c2			 
33c2			 
33c2			;	; get DO ptr 
33c2			; 
33c2				FORTH_RSP_TOS 
33c2 cd dd 1b			call macro_forth_rsp_tos 
33c5				endm 
# End of macro FORTH_RSP_TOS
33c5			 
33c5				;push hl 
33c5			 
33c5				; not going to DO any more 
33c5				; get rid of the RSP pointer as DO will add it back in 
33c5				;FORTH_RSP_POP 
33c5				;pop hl 
33c5			 
33c5			 
33c5 22 00 e6			ld (os_tok_ptr), hl 
33c8					if DEBUG_FORTH_WORDS 
33c8						DMARK "UN<" 
33c8 f5				push af  
33c9 3a dd 33			ld a, (.dmark)  
33cc 32 71 ee			ld (debug_mark),a  
33cf 3a de 33			ld a, (.dmark+1)  
33d2 32 72 ee			ld (debug_mark+1),a  
33d5 3a df 33			ld a, (.dmark+2)  
33d8 32 73 ee			ld (debug_mark+2),a  
33db 18 03			jr .pastdmark  
33dd ..			.dmark: db "UN<"  
33e0 f1			.pastdmark: pop af  
33e1			endm  
# End of macro DMARK
33e1					CALLMONITOR 
33e1 cd ae 15			call break_point_state  
33e4				endm  
# End of macro CALLMONITOR
33e4				endif 
33e4 c3 1e 20			jp exec1 
33e7			 
33e7					 
33e7			 
33e7			 
33e7					NEXTW 
33e7 c3 8d 1f			jp macro_next 
33ea				endm 
# End of macro NEXTW
33ea			 
33ea			 
33ea			.ENDFLOW: 
33ea			 
33ea			; eof 
33ea			 
# End of file forth_words_flow.asm
33ea			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
33ea			include "forth_words_logic.asm" 
33ea			 
33ea			; | ## Logic Words 
33ea			 
33ea			.NOT: 
33ea				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
33ea 2d				db WORD_SYS_CORE+25             
33eb 32 34			dw .IS            
33ed 04				db 3 + 1 
33ee .. 00			db "NOT",0              
33f2				endm 
# End of macro CWHEAD
33f2			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
33f2					if DEBUG_FORTH_WORDS_KEY 
33f2						DMARK "NOT" 
33f2 f5				push af  
33f3 3a 07 34			ld a, (.dmark)  
33f6 32 71 ee			ld (debug_mark),a  
33f9 3a 08 34			ld a, (.dmark+1)  
33fc 32 72 ee			ld (debug_mark+1),a  
33ff 3a 09 34			ld a, (.dmark+2)  
3402 32 73 ee			ld (debug_mark+2),a  
3405 18 03			jr .pastdmark  
3407 ..			.dmark: db "NOT"  
340a f1			.pastdmark: pop af  
340b			endm  
# End of macro DMARK
340b						CALLMONITOR 
340b cd ae 15			call break_point_state  
340e				endm  
# End of macro CALLMONITOR
340e					endif 
340e					FORTH_DSP 
340e cd dc 1d			call macro_forth_dsp 
3411				endm 
# End of macro FORTH_DSP
3411 7e					ld a,(hl)	; get type of value on TOS 
3412 fe 02				cp DS_TYPE_INUM  
3414 28 03				jr z, .noti 
3416					NEXTW 
3416 c3 8d 1f			jp macro_next 
3419				endm 
# End of macro NEXTW
3419			.noti:          FORTH_DSP_VALUEHL 
3419 cd 16 1e			call macro_dsp_valuehl 
341c				endm 
# End of macro FORTH_DSP_VALUEHL
341c			;		push hl 
341c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
341c cd ce 1e			call macro_forth_dsp_pop 
341f				endm 
# End of macro FORTH_DSP_POP
341f			;		pop hl 
341f 3e 00				ld a,0 
3421 bd					cp l 
3422 28 04				jr z, .not2t 
3424 2e 00				ld l, 0 
3426 18 02				jr .notip 
3428			 
3428 2e ff		.not2t:		ld l, 255 
342a			 
342a 26 00		.notip:		ld h, 0	 
342c			 
342c cd 1f 1c				call forth_push_numhl 
342f					NEXTW 
342f c3 8d 1f			jp macro_next 
3432				endm 
# End of macro NEXTW
3432			 
3432			.IS: 
3432				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3432 2d				db WORD_SYS_CORE+25             
3433 58 34			dw .LZERO            
3435 03				db 2 + 1 
3436 .. 00			db "IS",0              
3439				endm 
# End of macro CWHEAD
3439			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3439					if DEBUG_FORTH_WORDS_KEY 
3439						DMARK "IS." 
3439 f5				push af  
343a 3a 4e 34			ld a, (.dmark)  
343d 32 71 ee			ld (debug_mark),a  
3440 3a 4f 34			ld a, (.dmark+1)  
3443 32 72 ee			ld (debug_mark+1),a  
3446 3a 50 34			ld a, (.dmark+2)  
3449 32 73 ee			ld (debug_mark+2),a  
344c 18 03			jr .pastdmark  
344e ..			.dmark: db "IS."  
3451 f1			.pastdmark: pop af  
3452			endm  
# End of macro DMARK
3452						CALLMONITOR 
3452 cd ae 15			call break_point_state  
3455				endm  
# End of macro CALLMONITOR
3455					endif 
3455					NEXTW 
3455 c3 8d 1f			jp macro_next 
3458				endm 
# End of macro NEXTW
3458			.LZERO: 
3458				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3458 2d				db WORD_SYS_CORE+25             
3459 62 34			dw .TZERO            
345b 03				db 2 + 1 
345c .. 00			db "0<",0              
345f				endm 
# End of macro CWHEAD
345f			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
345f					NEXTW 
345f c3 8d 1f			jp macro_next 
3462				endm 
# End of macro NEXTW
3462			.TZERO: 
3462				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3462 2e				db WORD_SYS_CORE+26             
3463 a9 34			dw .LESS            
3465 03				db 2 + 1 
3466 .. 00			db "0=",0              
3469				endm 
# End of macro CWHEAD
3469			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3469				; TODO add floating point number detection 
3469					;v5 FORTH_DSP_VALUE 
3469					if DEBUG_FORTH_WORDS_KEY 
3469						DMARK "0=." 
3469 f5				push af  
346a 3a 7e 34			ld a, (.dmark)  
346d 32 71 ee			ld (debug_mark),a  
3470 3a 7f 34			ld a, (.dmark+1)  
3473 32 72 ee			ld (debug_mark+1),a  
3476 3a 80 34			ld a, (.dmark+2)  
3479 32 73 ee			ld (debug_mark+2),a  
347c 18 03			jr .pastdmark  
347e ..			.dmark: db "0=."  
3481 f1			.pastdmark: pop af  
3482			endm  
# End of macro DMARK
3482						CALLMONITOR 
3482 cd ae 15			call break_point_state  
3485				endm  
# End of macro CALLMONITOR
3485					endif 
3485					FORTH_DSP 
3485 cd dc 1d			call macro_forth_dsp 
3488				endm 
# End of macro FORTH_DSP
3488 7e					ld a,(hl)	; get type of value on TOS 
3489 fe 02				cp DS_TYPE_INUM  
348b 28 00				jr z, .tz_inum 
348d			 
348d				if FORTH_ENABLE_FLOATMATH 
348d					jr .tz_done 
348d			 
348d				endif 
348d					 
348d			 
348d			.tz_inum: 
348d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
348d cd 16 1e			call macro_dsp_valuehl 
3490				endm 
# End of macro FORTH_DSP_VALUEHL
3490			 
3490			;		push hl 
3490			 
3490					; destroy value TOS 
3490			 
3490					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3490 cd ce 1e			call macro_forth_dsp_pop 
3493				endm 
# End of macro FORTH_DSP_POP
3493			 
3493			;		pop hl 
3493			 
3493 3e 00				ld a,0 
3495			 
3495 bd					cp l 
3496 20 08				jr nz, .tz_notzero 
3498			 
3498 bc					cp h 
3499			 
3499 20 05				jr nz, .tz_notzero 
349b			 
349b			 
349b 21 01 00				ld hl, FORTH_TRUE 
349e 18 03				jr .tz_done 
34a0			 
34a0 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
34a3			 
34a3					; push value back onto stack for another op etc 
34a3			 
34a3			.tz_done: 
34a3 cd 1f 1c				call forth_push_numhl 
34a6			 
34a6					NEXTW 
34a6 c3 8d 1f			jp macro_next 
34a9				endm 
# End of macro NEXTW
34a9			.LESS: 
34a9				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
34a9 2f				db WORD_SYS_CORE+27             
34aa 12 35			dw .GT            
34ac 02				db 1 + 1 
34ad .. 00			db "<",0              
34af				endm 
# End of macro CWHEAD
34af			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
34af				; TODO add floating point number detection 
34af					if DEBUG_FORTH_WORDS_KEY 
34af						DMARK "LES" 
34af f5				push af  
34b0 3a c4 34			ld a, (.dmark)  
34b3 32 71 ee			ld (debug_mark),a  
34b6 3a c5 34			ld a, (.dmark+1)  
34b9 32 72 ee			ld (debug_mark+1),a  
34bc 3a c6 34			ld a, (.dmark+2)  
34bf 32 73 ee			ld (debug_mark+2),a  
34c2 18 03			jr .pastdmark  
34c4 ..			.dmark: db "LES"  
34c7 f1			.pastdmark: pop af  
34c8			endm  
# End of macro DMARK
34c8						CALLMONITOR 
34c8 cd ae 15			call break_point_state  
34cb				endm  
# End of macro CALLMONITOR
34cb					endif 
34cb					FORTH_DSP 
34cb cd dc 1d			call macro_forth_dsp 
34ce				endm 
# End of macro FORTH_DSP
34ce					;v5 FORTH_DSP_VALUE 
34ce 7e					ld a,(hl)	; get type of value on TOS 
34cf fe 02				cp DS_TYPE_INUM  
34d1 28 00				jr z, .less_inum 
34d3			 
34d3				if FORTH_ENABLE_FLOATMATH 
34d3					jr .less_done 
34d3			 
34d3				endif 
34d3					 
34d3			 
34d3			.less_inum: 
34d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34d3 cd 16 1e			call macro_dsp_valuehl 
34d6				endm 
# End of macro FORTH_DSP_VALUEHL
34d6			 
34d6 e5					push hl  ; u2 
34d7			 
34d7					; destroy value TOS 
34d7			 
34d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34d7 cd ce 1e			call macro_forth_dsp_pop 
34da				endm 
# End of macro FORTH_DSP_POP
34da			 
34da			 
34da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34da cd 16 1e			call macro_dsp_valuehl 
34dd				endm 
# End of macro FORTH_DSP_VALUEHL
34dd			 
34dd e5					push hl    ; u1 
34de			 
34de					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34de cd ce 1e			call macro_forth_dsp_pop 
34e1				endm 
# End of macro FORTH_DSP_POP
34e1			 
34e1			 
34e1 b7			 or a      ;clear carry flag 
34e2 01 00 00		 ld bc, FORTH_FALSE 
34e5 e1			  pop hl    ; u1 
34e6 d1			  pop de    ; u2 
34e7 ed 52		  sbc hl,de 
34e9 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
34eb			 
34eb 01 01 00		 ld bc, FORTH_TRUE 
34ee			.lscont:  
34ee c5					push bc 
34ef e1					pop hl 
34f0			 
34f0					if DEBUG_FORTH_WORDS 
34f0						DMARK "LT1" 
34f0 f5				push af  
34f1 3a 05 35			ld a, (.dmark)  
34f4 32 71 ee			ld (debug_mark),a  
34f7 3a 06 35			ld a, (.dmark+1)  
34fa 32 72 ee			ld (debug_mark+1),a  
34fd 3a 07 35			ld a, (.dmark+2)  
3500 32 73 ee			ld (debug_mark+2),a  
3503 18 03			jr .pastdmark  
3505 ..			.dmark: db "LT1"  
3508 f1			.pastdmark: pop af  
3509			endm  
# End of macro DMARK
3509						CALLMONITOR 
3509 cd ae 15			call break_point_state  
350c				endm  
# End of macro CALLMONITOR
350c					endif 
350c cd 1f 1c				call forth_push_numhl 
350f			 
350f					NEXTW 
350f c3 8d 1f			jp macro_next 
3512				endm 
# End of macro NEXTW
3512			.GT: 
3512				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3512 30				db WORD_SYS_CORE+28             
3513 7b 35			dw .EQUAL            
3515 02				db 1 + 1 
3516 .. 00			db ">",0              
3518				endm 
# End of macro CWHEAD
3518			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3518				; TODO add floating point number detection 
3518					if DEBUG_FORTH_WORDS_KEY 
3518						DMARK "GRT" 
3518 f5				push af  
3519 3a 2d 35			ld a, (.dmark)  
351c 32 71 ee			ld (debug_mark),a  
351f 3a 2e 35			ld a, (.dmark+1)  
3522 32 72 ee			ld (debug_mark+1),a  
3525 3a 2f 35			ld a, (.dmark+2)  
3528 32 73 ee			ld (debug_mark+2),a  
352b 18 03			jr .pastdmark  
352d ..			.dmark: db "GRT"  
3530 f1			.pastdmark: pop af  
3531			endm  
# End of macro DMARK
3531						CALLMONITOR 
3531 cd ae 15			call break_point_state  
3534				endm  
# End of macro CALLMONITOR
3534					endif 
3534					FORTH_DSP 
3534 cd dc 1d			call macro_forth_dsp 
3537				endm 
# End of macro FORTH_DSP
3537					;FORTH_DSP_VALUE 
3537 7e					ld a,(hl)	; get type of value on TOS 
3538 fe 02				cp DS_TYPE_INUM  
353a 28 00				jr z, .gt_inum 
353c			 
353c				if FORTH_ENABLE_FLOATMATH 
353c					jr .gt_done 
353c			 
353c				endif 
353c					 
353c			 
353c			.gt_inum: 
353c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
353c cd 16 1e			call macro_dsp_valuehl 
353f				endm 
# End of macro FORTH_DSP_VALUEHL
353f			 
353f e5					push hl  ; u2 
3540			 
3540					; destroy value TOS 
3540			 
3540					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3540 cd ce 1e			call macro_forth_dsp_pop 
3543				endm 
# End of macro FORTH_DSP_POP
3543			 
3543			 
3543					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3543 cd 16 1e			call macro_dsp_valuehl 
3546				endm 
# End of macro FORTH_DSP_VALUEHL
3546			 
3546 e5					push hl    ; u1 
3547			 
3547					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3547 cd ce 1e			call macro_forth_dsp_pop 
354a				endm 
# End of macro FORTH_DSP_POP
354a			 
354a			 
354a b7			 or a      ;clear carry flag 
354b 01 00 00		 ld bc, FORTH_FALSE 
354e e1			  pop hl    ; u1 
354f d1			  pop de    ; u2 
3550 ed 52		  sbc hl,de 
3552 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3554			 
3554 01 01 00		 ld bc, FORTH_TRUE 
3557			.gtcont:  
3557 c5					push bc 
3558 e1					pop hl 
3559			 
3559					if DEBUG_FORTH_WORDS 
3559						DMARK "GT1" 
3559 f5				push af  
355a 3a 6e 35			ld a, (.dmark)  
355d 32 71 ee			ld (debug_mark),a  
3560 3a 6f 35			ld a, (.dmark+1)  
3563 32 72 ee			ld (debug_mark+1),a  
3566 3a 70 35			ld a, (.dmark+2)  
3569 32 73 ee			ld (debug_mark+2),a  
356c 18 03			jr .pastdmark  
356e ..			.dmark: db "GT1"  
3571 f1			.pastdmark: pop af  
3572			endm  
# End of macro DMARK
3572						CALLMONITOR 
3572 cd ae 15			call break_point_state  
3575				endm  
# End of macro CALLMONITOR
3575					endif 
3575 cd 1f 1c				call forth_push_numhl 
3578			 
3578					NEXTW 
3578 c3 8d 1f			jp macro_next 
357b				endm 
# End of macro NEXTW
357b			.EQUAL: 
357b				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
357b 31				db WORD_SYS_CORE+29             
357c e6 35			dw .ENDLOGIC            
357e 02				db 1 + 1 
357f .. 00			db "=",0              
3581				endm 
# End of macro CWHEAD
3581			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3581				; TODO add floating point number detection 
3581					if DEBUG_FORTH_WORDS_KEY 
3581						DMARK "EQ." 
3581 f5				push af  
3582 3a 96 35			ld a, (.dmark)  
3585 32 71 ee			ld (debug_mark),a  
3588 3a 97 35			ld a, (.dmark+1)  
358b 32 72 ee			ld (debug_mark+1),a  
358e 3a 98 35			ld a, (.dmark+2)  
3591 32 73 ee			ld (debug_mark+2),a  
3594 18 03			jr .pastdmark  
3596 ..			.dmark: db "EQ."  
3599 f1			.pastdmark: pop af  
359a			endm  
# End of macro DMARK
359a						CALLMONITOR 
359a cd ae 15			call break_point_state  
359d				endm  
# End of macro CALLMONITOR
359d					endif 
359d					FORTH_DSP 
359d cd dc 1d			call macro_forth_dsp 
35a0				endm 
# End of macro FORTH_DSP
35a0					;v5 FORTH_DSP_VALUE 
35a0 7e					ld a,(hl)	; get type of value on TOS 
35a1 fe 02				cp DS_TYPE_INUM  
35a3 28 00				jr z, .eq_inum 
35a5			 
35a5				if FORTH_ENABLE_FLOATMATH 
35a5					jr .eq_done 
35a5			 
35a5				endif 
35a5					 
35a5			 
35a5			.eq_inum: 
35a5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35a5 cd 16 1e			call macro_dsp_valuehl 
35a8				endm 
# End of macro FORTH_DSP_VALUEHL
35a8			 
35a8 e5					push hl 
35a9			 
35a9					; destroy value TOS 
35a9			 
35a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35a9 cd ce 1e			call macro_forth_dsp_pop 
35ac				endm 
# End of macro FORTH_DSP_POP
35ac			 
35ac			 
35ac					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35ac cd 16 1e			call macro_dsp_valuehl 
35af				endm 
# End of macro FORTH_DSP_VALUEHL
35af			 
35af					; one value on hl get other one back 
35af			 
35af e5					push hl 
35b0			 
35b0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35b0 cd ce 1e			call macro_forth_dsp_pop 
35b3				endm 
# End of macro FORTH_DSP_POP
35b3			 
35b3 0e 00				ld c, FORTH_FALSE 
35b5			 
35b5 e1					pop hl 
35b6 d1					pop de 
35b7			 
35b7 7b					ld a, e 
35b8 bd					cp l 
35b9			 
35b9 20 06				jr nz, .eq_done 
35bb			 
35bb 7a					ld a, d 
35bc bc					cp h 
35bd			 
35bd 20 02				jr nz, .eq_done 
35bf			 
35bf 0e 01				ld c, FORTH_TRUE 
35c1					 
35c1			 
35c1			 
35c1			.eq_done: 
35c1			 
35c1					; TODO push value back onto stack for another op etc 
35c1			 
35c1 26 00				ld h, 0 
35c3 69					ld l, c 
35c4					if DEBUG_FORTH_WORDS 
35c4						DMARK "EQ1" 
35c4 f5				push af  
35c5 3a d9 35			ld a, (.dmark)  
35c8 32 71 ee			ld (debug_mark),a  
35cb 3a da 35			ld a, (.dmark+1)  
35ce 32 72 ee			ld (debug_mark+1),a  
35d1 3a db 35			ld a, (.dmark+2)  
35d4 32 73 ee			ld (debug_mark+2),a  
35d7 18 03			jr .pastdmark  
35d9 ..			.dmark: db "EQ1"  
35dc f1			.pastdmark: pop af  
35dd			endm  
# End of macro DMARK
35dd						CALLMONITOR 
35dd cd ae 15			call break_point_state  
35e0				endm  
# End of macro CALLMONITOR
35e0					endif 
35e0 cd 1f 1c				call forth_push_numhl 
35e3			 
35e3					NEXTW 
35e3 c3 8d 1f			jp macro_next 
35e6				endm 
# End of macro NEXTW
35e6			 
35e6			 
35e6			.ENDLOGIC: 
35e6			; eof 
35e6			 
35e6			 
# End of file forth_words_logic.asm
35e6			include "forth_words_maths.asm" 
35e6			 
35e6			; | ## Maths Words 
35e6			 
35e6			.PLUS:	 
35e6				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
35e6 15				db WORD_SYS_CORE+1             
35e7 28 36			dw .NEG            
35e9 02				db 1 + 1 
35ea .. 00			db "+",0              
35ec				endm 
# End of macro CWHEAD
35ec			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
35ec					if DEBUG_FORTH_WORDS_KEY 
35ec						DMARK "PLU" 
35ec f5				push af  
35ed 3a 01 36			ld a, (.dmark)  
35f0 32 71 ee			ld (debug_mark),a  
35f3 3a 02 36			ld a, (.dmark+1)  
35f6 32 72 ee			ld (debug_mark+1),a  
35f9 3a 03 36			ld a, (.dmark+2)  
35fc 32 73 ee			ld (debug_mark+2),a  
35ff 18 03			jr .pastdmark  
3601 ..			.dmark: db "PLU"  
3604 f1			.pastdmark: pop af  
3605			endm  
# End of macro DMARK
3605						CALLMONITOR 
3605 cd ae 15			call break_point_state  
3608				endm  
# End of macro CALLMONITOR
3608					endif 
3608					; add top two values and push back result 
3608			 
3608					;for v5 FORTH_DSP_VALUE 
3608					FORTH_DSP 
3608 cd dc 1d			call macro_forth_dsp 
360b				endm 
# End of macro FORTH_DSP
360b 7e					ld a,(hl)	; get type of value on TOS 
360c fe 02				cp DS_TYPE_INUM  
360e 28 03				jr z, .dot_inum 
3610			 
3610					NEXTW 
3610 c3 8d 1f			jp macro_next 
3613				endm 
# End of macro NEXTW
3613			 
3613			; float maths 
3613			 
3613				if FORTH_ENABLE_FLOATMATH 
3613						inc hl      ; now at start of numeric as string 
3613			 
3613					if DEBUG_FORTH_MATHS 
3613						DMARK "ADD" 
3613				CALLMONITOR 
3613					endif 
3613			 
3613					;ld ix, hl 
3613					call CON 
3613			 
3613			 
3613					push hl 
3613					 
3613					 
3613			 
3613						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3613			 
3613					; get next number 
3613			 
3613						FORTH_DSP_VALUE 
3613			 
3613						inc hl      ; now at start of numeric as string 
3613			 
3613					;ld ix, hl 
3613					call CON 
3613			 
3613					push hl 
3613			 
3613			 
3613						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3613			 
3613						; TODO do add 
3613			 
3613						call IADD 
3613			 
3613						; TODO get result back as ascii 
3613			 
3613						; TODO push result  
3613			 
3613			 
3613			 
3613						jr .dot_done 
3613				endif 
3613			 
3613			.dot_inum: 
3613			 
3613			 
3613					if DEBUG_FORTH_DOT 
3613						DMARK "+IT" 
3613				CALLMONITOR 
3613					endif 
3613			 
3613					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3613 cd 16 1e			call macro_dsp_valuehl 
3616				endm 
# End of macro FORTH_DSP_VALUEHL
3616			 
3616				; TODO add floating point number detection 
3616			 
3616 e5					push hl 
3617			 
3617					; destroy value TOS 
3617			 
3617					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3617 cd ce 1e			call macro_forth_dsp_pop 
361a				endm 
# End of macro FORTH_DSP_POP
361a			 
361a			 
361a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
361a cd 16 1e			call macro_dsp_valuehl 
361d				endm 
# End of macro FORTH_DSP_VALUEHL
361d			 
361d					; one value on hl get other one back 
361d			 
361d d1					pop de 
361e			 
361e					; do the add 
361e			 
361e 19					add hl,de 
361f			 
361f					; save it 
361f			 
361f			;		push hl	 
361f			 
361f					; 
361f			 
361f					; destroy value TOS 
361f			 
361f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
361f cd ce 1e			call macro_forth_dsp_pop 
3622				endm 
# End of macro FORTH_DSP_POP
3622			 
3622					; TODO push value back onto stack for another op etc 
3622			 
3622			;		pop hl 
3622			 
3622			.dot_done: 
3622 cd 1f 1c				call forth_push_numhl 
3625			 
3625					NEXTW 
3625 c3 8d 1f			jp macro_next 
3628				endm 
# End of macro NEXTW
3628			.NEG: 
3628			 
3628				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3628 17				db WORD_SYS_CORE+3             
3629 6b 36			dw .DIV            
362b 02				db 1 + 1 
362c .. 00			db "-",0              
362e				endm 
# End of macro CWHEAD
362e			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
362e					if DEBUG_FORTH_WORDS_KEY 
362e						DMARK "SUB" 
362e f5				push af  
362f 3a 43 36			ld a, (.dmark)  
3632 32 71 ee			ld (debug_mark),a  
3635 3a 44 36			ld a, (.dmark+1)  
3638 32 72 ee			ld (debug_mark+1),a  
363b 3a 45 36			ld a, (.dmark+2)  
363e 32 73 ee			ld (debug_mark+2),a  
3641 18 03			jr .pastdmark  
3643 ..			.dmark: db "SUB"  
3646 f1			.pastdmark: pop af  
3647			endm  
# End of macro DMARK
3647						CALLMONITOR 
3647 cd ae 15			call break_point_state  
364a				endm  
# End of macro CALLMONITOR
364a					endif 
364a			 
364a			 
364a				; TODO add floating point number detection 
364a					; v5 FORTH_DSP_VALUE 
364a					FORTH_DSP 
364a cd dc 1d			call macro_forth_dsp 
364d				endm 
# End of macro FORTH_DSP
364d 7e					ld a,(hl)	; get type of value on TOS 
364e fe 02				cp DS_TYPE_INUM  
3650 28 03				jr z, .neg_inum 
3652			 
3652					NEXTW 
3652 c3 8d 1f			jp macro_next 
3655				endm 
# End of macro NEXTW
3655			 
3655			; float maths 
3655			 
3655				if FORTH_ENABLE_FLOATMATH 
3655					jr .neg_done 
3655			 
3655				endif 
3655					 
3655			 
3655			.neg_inum: 
3655					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3655 cd 16 1e			call macro_dsp_valuehl 
3658				endm 
# End of macro FORTH_DSP_VALUEHL
3658			 
3658 e5					push hl 
3659			 
3659					; destroy value TOS 
3659			 
3659					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3659 cd ce 1e			call macro_forth_dsp_pop 
365c				endm 
# End of macro FORTH_DSP_POP
365c			 
365c			 
365c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
365c cd 16 1e			call macro_dsp_valuehl 
365f				endm 
# End of macro FORTH_DSP_VALUEHL
365f			 
365f					; one value on hl get other one back 
365f			 
365f d1					pop de 
3660			 
3660					; do the sub 
3660			;		ex de, hl 
3660			 
3660 ed 52				sbc hl,de 
3662			 
3662					; save it 
3662			 
3662			;		push hl	 
3662			 
3662					; 
3662			 
3662					; destroy value TOS 
3662			 
3662					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3662 cd ce 1e			call macro_forth_dsp_pop 
3665				endm 
# End of macro FORTH_DSP_POP
3665			 
3665					; TODO push value back onto stack for another op etc 
3665			 
3665			;		pop hl 
3665			 
3665 cd 1f 1c				call forth_push_numhl 
3668			.neg_done: 
3668			 
3668					NEXTW 
3668 c3 8d 1f			jp macro_next 
366b				endm 
# End of macro NEXTW
366b			.DIV: 
366b				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
366b 18				db WORD_SYS_CORE+4             
366c b8 36			dw .MUL            
366e 02				db 1 + 1 
366f .. 00			db "/",0              
3671				endm 
# End of macro CWHEAD
3671			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3671					if DEBUG_FORTH_WORDS_KEY 
3671						DMARK "DIV" 
3671 f5				push af  
3672 3a 86 36			ld a, (.dmark)  
3675 32 71 ee			ld (debug_mark),a  
3678 3a 87 36			ld a, (.dmark+1)  
367b 32 72 ee			ld (debug_mark+1),a  
367e 3a 88 36			ld a, (.dmark+2)  
3681 32 73 ee			ld (debug_mark+2),a  
3684 18 03			jr .pastdmark  
3686 ..			.dmark: db "DIV"  
3689 f1			.pastdmark: pop af  
368a			endm  
# End of macro DMARK
368a						CALLMONITOR 
368a cd ae 15			call break_point_state  
368d				endm  
# End of macro CALLMONITOR
368d					endif 
368d				; TODO add floating point number detection 
368d					; v5 FORTH_DSP_VALUE 
368d					FORTH_DSP 
368d cd dc 1d			call macro_forth_dsp 
3690				endm 
# End of macro FORTH_DSP
3690 7e					ld a,(hl)	; get type of value on TOS 
3691 fe 02				cp DS_TYPE_INUM  
3693 28 03				jr z, .div_inum 
3695			 
3695				if FORTH_ENABLE_FLOATMATH 
3695					jr .div_done 
3695			 
3695				endif 
3695					NEXTW 
3695 c3 8d 1f			jp macro_next 
3698				endm 
# End of macro NEXTW
3698			.div_inum: 
3698			 
3698					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3698 cd 16 1e			call macro_dsp_valuehl 
369b				endm 
# End of macro FORTH_DSP_VALUEHL
369b			 
369b e5					push hl    ; to go to bc 
369c			 
369c					; destroy value TOS 
369c			 
369c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
369c cd ce 1e			call macro_forth_dsp_pop 
369f				endm 
# End of macro FORTH_DSP_POP
369f			 
369f			 
369f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
369f cd 16 1e			call macro_dsp_valuehl 
36a2				endm 
# End of macro FORTH_DSP_VALUEHL
36a2			 
36a2					; hl to go to de 
36a2			 
36a2 e5					push hl 
36a3			 
36a3 c1					pop bc 
36a4 d1					pop de		 
36a5			 
36a5			 
36a5					if DEBUG_FORTH_MATHS 
36a5						DMARK "DIV" 
36a5				CALLMONITOR 
36a5					endif 
36a5					; one value on hl but move to a get other one back 
36a5			 
36a5			        
36a5 cd 0a 0d			call Div16 
36a8			 
36a8			;	push af	 
36a8 e5				push hl 
36a9 c5				push bc 
36aa			 
36aa					if DEBUG_FORTH_MATHS 
36aa						DMARK "DI1" 
36aa				CALLMONITOR 
36aa					endif 
36aa			 
36aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36aa cd ce 1e			call macro_forth_dsp_pop 
36ad				endm 
# End of macro FORTH_DSP_POP
36ad			 
36ad			 
36ad			 
36ad e1					pop hl    ; result 
36ae			 
36ae cd 1f 1c				call forth_push_numhl 
36b1			 
36b1 e1					pop hl    ; reminder 
36b2			;		ld h,0 
36b2			;		ld l,d 
36b2			 
36b2 cd 1f 1c				call forth_push_numhl 
36b5			.div_done: 
36b5					NEXTW 
36b5 c3 8d 1f			jp macro_next 
36b8				endm 
# End of macro NEXTW
36b8			.MUL: 
36b8				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
36b8 19				db WORD_SYS_CORE+5             
36b9 fd 36			dw .MIN            
36bb 02				db 1 + 1 
36bc .. 00			db "*",0              
36be				endm 
# End of macro CWHEAD
36be			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
36be				; TODO add floating point number detection 
36be					if DEBUG_FORTH_WORDS_KEY 
36be						DMARK "MUL" 
36be f5				push af  
36bf 3a d3 36			ld a, (.dmark)  
36c2 32 71 ee			ld (debug_mark),a  
36c5 3a d4 36			ld a, (.dmark+1)  
36c8 32 72 ee			ld (debug_mark+1),a  
36cb 3a d5 36			ld a, (.dmark+2)  
36ce 32 73 ee			ld (debug_mark+2),a  
36d1 18 03			jr .pastdmark  
36d3 ..			.dmark: db "MUL"  
36d6 f1			.pastdmark: pop af  
36d7			endm  
# End of macro DMARK
36d7						CALLMONITOR 
36d7 cd ae 15			call break_point_state  
36da				endm  
# End of macro CALLMONITOR
36da					endif 
36da					FORTH_DSP 
36da cd dc 1d			call macro_forth_dsp 
36dd				endm 
# End of macro FORTH_DSP
36dd					; v5 FORTH_DSP_VALUE 
36dd 7e					ld a,(hl)	; get type of value on TOS 
36de fe 02				cp DS_TYPE_INUM  
36e0 28 03				jr z, .mul_inum 
36e2			 
36e2				if FORTH_ENABLE_FLOATMATH 
36e2					jr .mul_done 
36e2			 
36e2				endif 
36e2			 
36e2					NEXTW 
36e2 c3 8d 1f			jp macro_next 
36e5				endm 
# End of macro NEXTW
36e5			.mul_inum:	 
36e5			 
36e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36e5 cd 16 1e			call macro_dsp_valuehl 
36e8				endm 
# End of macro FORTH_DSP_VALUEHL
36e8			 
36e8 e5					push hl 
36e9			 
36e9					; destroy value TOS 
36e9			 
36e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36e9 cd ce 1e			call macro_forth_dsp_pop 
36ec				endm 
# End of macro FORTH_DSP_POP
36ec			 
36ec			 
36ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36ec cd 16 1e			call macro_dsp_valuehl 
36ef				endm 
# End of macro FORTH_DSP_VALUEHL
36ef			 
36ef					; one value on hl but move to a get other one back 
36ef			 
36ef 7d					ld a, l 
36f0			 
36f0 d1					pop de 
36f1			 
36f1					; do the mull 
36f1			;		ex de, hl 
36f1			 
36f1 cd 30 0d				call Mult16 
36f4					; save it 
36f4			 
36f4			;		push hl	 
36f4			 
36f4					; 
36f4			 
36f4					; destroy value TOS 
36f4			 
36f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36f4 cd ce 1e			call macro_forth_dsp_pop 
36f7				endm 
# End of macro FORTH_DSP_POP
36f7			 
36f7					; TODO push value back onto stack for another op etc 
36f7			 
36f7			;		pop hl 
36f7			 
36f7 cd 1f 1c				call forth_push_numhl 
36fa			 
36fa			.mul_done: 
36fa					NEXTW 
36fa c3 8d 1f			jp macro_next 
36fd				endm 
# End of macro NEXTW
36fd			 
36fd			 
36fd			 
36fd			 
36fd			.MIN: 
36fd				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
36fd 49				db WORD_SYS_CORE+53             
36fe 7e 37			dw .MAX            
3700 04				db 3 + 1 
3701 .. 00			db "MIN",0              
3705				endm 
# End of macro CWHEAD
3705			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3705					if DEBUG_FORTH_WORDS_KEY 
3705						DMARK "MIN" 
3705 f5				push af  
3706 3a 1a 37			ld a, (.dmark)  
3709 32 71 ee			ld (debug_mark),a  
370c 3a 1b 37			ld a, (.dmark+1)  
370f 32 72 ee			ld (debug_mark+1),a  
3712 3a 1c 37			ld a, (.dmark+2)  
3715 32 73 ee			ld (debug_mark+2),a  
3718 18 03			jr .pastdmark  
371a ..			.dmark: db "MIN"  
371d f1			.pastdmark: pop af  
371e			endm  
# End of macro DMARK
371e						CALLMONITOR 
371e cd ae 15			call break_point_state  
3721				endm  
# End of macro CALLMONITOR
3721					endif 
3721					; get u2 
3721			 
3721					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3721 cd 16 1e			call macro_dsp_valuehl 
3724				endm 
# End of macro FORTH_DSP_VALUEHL
3724			 
3724 e5					push hl   ; u2 
3725			 
3725					; destroy value TOS 
3725			 
3725					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3725 cd ce 1e			call macro_forth_dsp_pop 
3728				endm 
# End of macro FORTH_DSP_POP
3728			 
3728					; get u1 
3728			 
3728					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3728 cd 16 1e			call macro_dsp_valuehl 
372b				endm 
# End of macro FORTH_DSP_VALUEHL
372b			 
372b e5					push hl  ; u1 
372c			 
372c					; destroy value TOS 
372c			 
372c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
372c cd ce 1e			call macro_forth_dsp_pop 
372f				endm 
# End of macro FORTH_DSP_POP
372f			 
372f b7			 or a      ;clear carry flag 
3730 e1			  pop hl    ; u1 
3731 d1			  pop de    ; u2 
3732 e5				push hl   ; saved in case hl is lowest 
3733 ed 52		  sbc hl,de 
3735 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3737			 
3737 e1				pop hl 
3738					if DEBUG_FORTH_WORDS 
3738						DMARK "MIN" 
3738 f5				push af  
3739 3a 4d 37			ld a, (.dmark)  
373c 32 71 ee			ld (debug_mark),a  
373f 3a 4e 37			ld a, (.dmark+1)  
3742 32 72 ee			ld (debug_mark+1),a  
3745 3a 4f 37			ld a, (.dmark+2)  
3748 32 73 ee			ld (debug_mark+2),a  
374b 18 03			jr .pastdmark  
374d ..			.dmark: db "MIN"  
3750 f1			.pastdmark: pop af  
3751			endm  
# End of macro DMARK
3751						CALLMONITOR 
3751 cd ae 15			call break_point_state  
3754				endm  
# End of macro CALLMONITOR
3754					endif 
3754 cd 1f 1c				call forth_push_numhl 
3757			 
3757				       NEXTW 
3757 c3 8d 1f			jp macro_next 
375a				endm 
# End of macro NEXTW
375a			 
375a			.mincont:  
375a c1				pop bc   ; tidy up 
375b eb				ex de , hl  
375c					if DEBUG_FORTH_WORDS 
375c						DMARK "MI1" 
375c f5				push af  
375d 3a 71 37			ld a, (.dmark)  
3760 32 71 ee			ld (debug_mark),a  
3763 3a 72 37			ld a, (.dmark+1)  
3766 32 72 ee			ld (debug_mark+1),a  
3769 3a 73 37			ld a, (.dmark+2)  
376c 32 73 ee			ld (debug_mark+2),a  
376f 18 03			jr .pastdmark  
3771 ..			.dmark: db "MI1"  
3774 f1			.pastdmark: pop af  
3775			endm  
# End of macro DMARK
3775						CALLMONITOR 
3775 cd ae 15			call break_point_state  
3778				endm  
# End of macro CALLMONITOR
3778					endif 
3778 cd 1f 1c				call forth_push_numhl 
377b			 
377b				       NEXTW 
377b c3 8d 1f			jp macro_next 
377e				endm 
# End of macro NEXTW
377e			.MAX: 
377e				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
377e 4a				db WORD_SYS_CORE+54             
377f ff 37			dw .RND16            
3781 04				db 3 + 1 
3782 .. 00			db "MAX",0              
3786				endm 
# End of macro CWHEAD
3786			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3786					if DEBUG_FORTH_WORDS_KEY 
3786						DMARK "MAX" 
3786 f5				push af  
3787 3a 9b 37			ld a, (.dmark)  
378a 32 71 ee			ld (debug_mark),a  
378d 3a 9c 37			ld a, (.dmark+1)  
3790 32 72 ee			ld (debug_mark+1),a  
3793 3a 9d 37			ld a, (.dmark+2)  
3796 32 73 ee			ld (debug_mark+2),a  
3799 18 03			jr .pastdmark  
379b ..			.dmark: db "MAX"  
379e f1			.pastdmark: pop af  
379f			endm  
# End of macro DMARK
379f						CALLMONITOR 
379f cd ae 15			call break_point_state  
37a2				endm  
# End of macro CALLMONITOR
37a2					endif 
37a2					; get u2 
37a2			 
37a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37a2 cd 16 1e			call macro_dsp_valuehl 
37a5				endm 
# End of macro FORTH_DSP_VALUEHL
37a5			 
37a5 e5					push hl   ; u2 
37a6			 
37a6					; destroy value TOS 
37a6			 
37a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37a6 cd ce 1e			call macro_forth_dsp_pop 
37a9				endm 
# End of macro FORTH_DSP_POP
37a9			 
37a9					; get u1 
37a9			 
37a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37a9 cd 16 1e			call macro_dsp_valuehl 
37ac				endm 
# End of macro FORTH_DSP_VALUEHL
37ac			 
37ac e5					push hl  ; u1 
37ad			 
37ad					; destroy value TOS 
37ad			 
37ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37ad cd ce 1e			call macro_forth_dsp_pop 
37b0				endm 
# End of macro FORTH_DSP_POP
37b0			 
37b0 b7			 or a      ;clear carry flag 
37b1 e1			  pop hl    ; u1 
37b2 d1			  pop de    ; u2 
37b3 e5				push hl   ; saved in case hl is lowest 
37b4 ed 52		  sbc hl,de 
37b6 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
37b8			 
37b8 e1				pop hl 
37b9					if DEBUG_FORTH_WORDS 
37b9						DMARK "MAX" 
37b9 f5				push af  
37ba 3a ce 37			ld a, (.dmark)  
37bd 32 71 ee			ld (debug_mark),a  
37c0 3a cf 37			ld a, (.dmark+1)  
37c3 32 72 ee			ld (debug_mark+1),a  
37c6 3a d0 37			ld a, (.dmark+2)  
37c9 32 73 ee			ld (debug_mark+2),a  
37cc 18 03			jr .pastdmark  
37ce ..			.dmark: db "MAX"  
37d1 f1			.pastdmark: pop af  
37d2			endm  
# End of macro DMARK
37d2						CALLMONITOR 
37d2 cd ae 15			call break_point_state  
37d5				endm  
# End of macro CALLMONITOR
37d5					endif 
37d5 cd 1f 1c				call forth_push_numhl 
37d8			 
37d8				       NEXTW 
37d8 c3 8d 1f			jp macro_next 
37db				endm 
# End of macro NEXTW
37db			 
37db			.maxcont:  
37db c1				pop bc   ; tidy up 
37dc eb				ex de , hl  
37dd					if DEBUG_FORTH_WORDS 
37dd						DMARK "MA1" 
37dd f5				push af  
37de 3a f2 37			ld a, (.dmark)  
37e1 32 71 ee			ld (debug_mark),a  
37e4 3a f3 37			ld a, (.dmark+1)  
37e7 32 72 ee			ld (debug_mark+1),a  
37ea 3a f4 37			ld a, (.dmark+2)  
37ed 32 73 ee			ld (debug_mark+2),a  
37f0 18 03			jr .pastdmark  
37f2 ..			.dmark: db "MA1"  
37f5 f1			.pastdmark: pop af  
37f6			endm  
# End of macro DMARK
37f6						CALLMONITOR 
37f6 cd ae 15			call break_point_state  
37f9				endm  
# End of macro CALLMONITOR
37f9					endif 
37f9 cd 1f 1c				call forth_push_numhl 
37fc				       NEXTW 
37fc c3 8d 1f			jp macro_next 
37ff				endm 
# End of macro NEXTW
37ff			 
37ff			.RND16: 
37ff				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
37ff 4e				db WORD_SYS_CORE+58             
3800 2e 38			dw .RND8            
3802 06				db 5 + 1 
3803 .. 00			db "RND16",0              
3809				endm 
# End of macro CWHEAD
3809			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3809					if DEBUG_FORTH_WORDS_KEY 
3809						DMARK "R16" 
3809 f5				push af  
380a 3a 1e 38			ld a, (.dmark)  
380d 32 71 ee			ld (debug_mark),a  
3810 3a 1f 38			ld a, (.dmark+1)  
3813 32 72 ee			ld (debug_mark+1),a  
3816 3a 20 38			ld a, (.dmark+2)  
3819 32 73 ee			ld (debug_mark+2),a  
381c 18 03			jr .pastdmark  
381e ..			.dmark: db "R16"  
3821 f1			.pastdmark: pop af  
3822			endm  
# End of macro DMARK
3822						CALLMONITOR 
3822 cd ae 15			call break_point_state  
3825				endm  
# End of macro CALLMONITOR
3825					endif 
3825 cd d4 0c				call prng16  
3828 cd 1f 1c				call forth_push_numhl 
382b				       NEXTW 
382b c3 8d 1f			jp macro_next 
382e				endm 
# End of macro NEXTW
382e			.RND8: 
382e				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
382e 60				db WORD_SYS_CORE+76             
382f 63 38			dw .RND            
3831 05				db 4 + 1 
3832 .. 00			db "RND8",0              
3837				endm 
# End of macro CWHEAD
3837			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3837					if DEBUG_FORTH_WORDS_KEY 
3837						DMARK "RN8" 
3837 f5				push af  
3838 3a 4c 38			ld a, (.dmark)  
383b 32 71 ee			ld (debug_mark),a  
383e 3a 4d 38			ld a, (.dmark+1)  
3841 32 72 ee			ld (debug_mark+1),a  
3844 3a 4e 38			ld a, (.dmark+2)  
3847 32 73 ee			ld (debug_mark+2),a  
384a 18 03			jr .pastdmark  
384c ..			.dmark: db "RN8"  
384f f1			.pastdmark: pop af  
3850			endm  
# End of macro DMARK
3850						CALLMONITOR 
3850 cd ae 15			call break_point_state  
3853				endm  
# End of macro CALLMONITOR
3853					endif 
3853 2a b2 eb				ld hl,(xrandc) 
3856 23					inc hl 
3857 cd ee 0c				call xrnd 
385a 6f					ld l,a	 
385b 26 00				ld h,0 
385d cd 1f 1c				call forth_push_numhl 
3860				       NEXTW 
3860 c3 8d 1f			jp macro_next 
3863				endm 
# End of macro NEXTW
3863			.RND: 
3863				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3863 60				db WORD_SYS_CORE+76             
3864 69 39			dw .ENDMATHS            
3866 04				db 3 + 1 
3867 .. 00			db "RND",0              
386b				endm 
# End of macro CWHEAD
386b			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
386b			 
386b					if DEBUG_FORTH_WORDS_KEY 
386b						DMARK "RND" 
386b f5				push af  
386c 3a 80 38			ld a, (.dmark)  
386f 32 71 ee			ld (debug_mark),a  
3872 3a 81 38			ld a, (.dmark+1)  
3875 32 72 ee			ld (debug_mark+1),a  
3878 3a 82 38			ld a, (.dmark+2)  
387b 32 73 ee			ld (debug_mark+2),a  
387e 18 03			jr .pastdmark  
3880 ..			.dmark: db "RND"  
3883 f1			.pastdmark: pop af  
3884			endm  
# End of macro DMARK
3884						CALLMONITOR 
3884 cd ae 15			call break_point_state  
3887				endm  
# End of macro CALLMONITOR
3887					endif 
3887					 
3887					FORTH_DSP_VALUEHL    ; upper range 
3887 cd 16 1e			call macro_dsp_valuehl 
388a				endm 
# End of macro FORTH_DSP_VALUEHL
388a			 
388a 22 b6 eb				ld (LFSRSeed), hl	 
388d			 
388d					if DEBUG_FORTH_WORDS 
388d						DMARK "RN1" 
388d f5				push af  
388e 3a a2 38			ld a, (.dmark)  
3891 32 71 ee			ld (debug_mark),a  
3894 3a a3 38			ld a, (.dmark+1)  
3897 32 72 ee			ld (debug_mark+1),a  
389a 3a a4 38			ld a, (.dmark+2)  
389d 32 73 ee			ld (debug_mark+2),a  
38a0 18 03			jr .pastdmark  
38a2 ..			.dmark: db "RN1"  
38a5 f1			.pastdmark: pop af  
38a6			endm  
# End of macro DMARK
38a6						CALLMONITOR 
38a6 cd ae 15			call break_point_state  
38a9				endm  
# End of macro CALLMONITOR
38a9					endif 
38a9					FORTH_DSP_POP 
38a9 cd ce 1e			call macro_forth_dsp_pop 
38ac				endm 
# End of macro FORTH_DSP_POP
38ac			 
38ac					FORTH_DSP_VALUEHL    ; low range 
38ac cd 16 1e			call macro_dsp_valuehl 
38af				endm 
# End of macro FORTH_DSP_VALUEHL
38af			 
38af					if DEBUG_FORTH_WORDS 
38af						DMARK "RN2" 
38af f5				push af  
38b0 3a c4 38			ld a, (.dmark)  
38b3 32 71 ee			ld (debug_mark),a  
38b6 3a c5 38			ld a, (.dmark+1)  
38b9 32 72 ee			ld (debug_mark+1),a  
38bc 3a c6 38			ld a, (.dmark+2)  
38bf 32 73 ee			ld (debug_mark+2),a  
38c2 18 03			jr .pastdmark  
38c4 ..			.dmark: db "RN2"  
38c7 f1			.pastdmark: pop af  
38c8			endm  
# End of macro DMARK
38c8						CALLMONITOR 
38c8 cd ae 15			call break_point_state  
38cb				endm  
# End of macro CALLMONITOR
38cb					endif 
38cb 22 b8 eb				ld (LFSRSeed+2), hl 
38ce			 
38ce					FORTH_DSP_POP 
38ce cd ce 1e			call macro_forth_dsp_pop 
38d1				endm 
# End of macro FORTH_DSP_POP
38d1			 
38d1 e5					push hl 
38d2			 
38d2 e1			.inrange:	pop hl 
38d3 cd d4 0c				call prng16  
38d6					if DEBUG_FORTH_WORDS 
38d6						DMARK "RN3" 
38d6 f5				push af  
38d7 3a eb 38			ld a, (.dmark)  
38da 32 71 ee			ld (debug_mark),a  
38dd 3a ec 38			ld a, (.dmark+1)  
38e0 32 72 ee			ld (debug_mark+1),a  
38e3 3a ed 38			ld a, (.dmark+2)  
38e6 32 73 ee			ld (debug_mark+2),a  
38e9 18 03			jr .pastdmark  
38eb ..			.dmark: db "RN3"  
38ee f1			.pastdmark: pop af  
38ef			endm  
# End of macro DMARK
38ef						CALLMONITOR 
38ef cd ae 15			call break_point_state  
38f2				endm  
# End of macro CALLMONITOR
38f2					endif 
38f2					 
38f2					; if the range is 8bit knock out the high byte 
38f2			 
38f2 ed 5b b6 eb			ld de, (LFSRSeed)     ; check high level 
38f6			 
38f6 3e 00				ld a, 0 
38f8 ba					cp d  
38f9 20 1e				jr nz, .hirange 
38fb 26 00				ld h, 0   ; knock it down to 8bit 
38fd			 
38fd					if DEBUG_FORTH_WORDS 
38fd						DMARK "RNk" 
38fd f5				push af  
38fe 3a 12 39			ld a, (.dmark)  
3901 32 71 ee			ld (debug_mark),a  
3904 3a 13 39			ld a, (.dmark+1)  
3907 32 72 ee			ld (debug_mark+1),a  
390a 3a 14 39			ld a, (.dmark+2)  
390d 32 73 ee			ld (debug_mark+2),a  
3910 18 03			jr .pastdmark  
3912 ..			.dmark: db "RNk"  
3915 f1			.pastdmark: pop af  
3916			endm  
# End of macro DMARK
3916						CALLMONITOR 
3916 cd ae 15			call break_point_state  
3919				endm  
# End of macro CALLMONITOR
3919					endif 
3919			.hirange:   
3919 e5					push hl  
391a b7					or a  
391b ed 52		                sbc hl, de 
391d			 
391d					;call cmp16 
391d			 
391d 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
391f e1					pop hl 
3920 e5					push hl 
3921			 
3921					if DEBUG_FORTH_WORDS 
3921						DMARK "RN4" 
3921 f5				push af  
3922 3a 36 39			ld a, (.dmark)  
3925 32 71 ee			ld (debug_mark),a  
3928 3a 37 39			ld a, (.dmark+1)  
392b 32 72 ee			ld (debug_mark+1),a  
392e 3a 38 39			ld a, (.dmark+2)  
3931 32 73 ee			ld (debug_mark+2),a  
3934 18 03			jr .pastdmark  
3936 ..			.dmark: db "RN4"  
3939 f1			.pastdmark: pop af  
393a			endm  
# End of macro DMARK
393a						CALLMONITOR 
393a cd ae 15			call break_point_state  
393d				endm  
# End of macro CALLMONITOR
393d					endif 
393d ed 5b b8 eb			ld de, (LFSRSeed+2)   ; check low range 
3941					;call cmp16 
3941				 
3941 b7					or a  
3942 ed 52		                sbc hl, de 
3944 38 8c				jr c, .inrange 
3946			 
3946 e1					pop hl 
3947					 
3947					if DEBUG_FORTH_WORDS 
3947						DMARK "RNd" 
3947 f5				push af  
3948 3a 5c 39			ld a, (.dmark)  
394b 32 71 ee			ld (debug_mark),a  
394e 3a 5d 39			ld a, (.dmark+1)  
3951 32 72 ee			ld (debug_mark+1),a  
3954 3a 5e 39			ld a, (.dmark+2)  
3957 32 73 ee			ld (debug_mark+2),a  
395a 18 03			jr .pastdmark  
395c ..			.dmark: db "RNd"  
395f f1			.pastdmark: pop af  
3960			endm  
# End of macro DMARK
3960						CALLMONITOR 
3960 cd ae 15			call break_point_state  
3963				endm  
# End of macro CALLMONITOR
3963					endif 
3963			 
3963			 
3963 cd 1f 1c				call forth_push_numhl 
3966				       NEXTW 
3966 c3 8d 1f			jp macro_next 
3969				endm 
# End of macro NEXTW
3969			 
3969			.ENDMATHS: 
3969			 
3969			; eof 
3969			 
# End of file forth_words_maths.asm
3969			include "forth_words_display.asm" 
3969			 
3969			; | ## Display Words 
3969			 
3969			.INFO: 
3969			 
3969				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3969 62				db WORD_SYS_CORE+78             
396a 86 39			dw .ATP            
396c 05				db 4 + 1 
396d .. 00			db "INFO",0              
3972				endm 
# End of macro CWHEAD
3972			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3972					FORTH_DSP_VALUEHL 
3972 cd 16 1e			call macro_dsp_valuehl 
3975				endm 
# End of macro FORTH_DSP_VALUEHL
3975			 
3975					FORTH_DSP_POP 
3975 cd ce 1e			call macro_forth_dsp_pop 
3978				endm 
# End of macro FORTH_DSP_POP
3978			 
3978 e5					push hl 
3979			 
3979					FORTH_DSP_VALUEHL 
3979 cd 16 1e			call macro_dsp_valuehl 
397c				endm 
# End of macro FORTH_DSP_VALUEHL
397c			 
397c					FORTH_DSP_POP 
397c cd ce 1e			call macro_forth_dsp_pop 
397f				endm 
# End of macro FORTH_DSP_POP
397f			 
397f d1					pop de 
3980			 
3980 cd 11 0b				call info_panel 
3983			 
3983			 
3983					NEXTW 
3983 c3 8d 1f			jp macro_next 
3986				endm 
# End of macro NEXTW
3986			.ATP: 
3986				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3986 62				db WORD_SYS_CORE+78             
3987 fd 39			dw .FB            
3989 04				db 3 + 1 
398a .. 00			db "AT?",0              
398e				endm 
# End of macro CWHEAD
398e			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
398e					if DEBUG_FORTH_WORDS_KEY 
398e						DMARK "AT?" 
398e f5				push af  
398f 3a a3 39			ld a, (.dmark)  
3992 32 71 ee			ld (debug_mark),a  
3995 3a a4 39			ld a, (.dmark+1)  
3998 32 72 ee			ld (debug_mark+1),a  
399b 3a a5 39			ld a, (.dmark+2)  
399e 32 73 ee			ld (debug_mark+2),a  
39a1 18 03			jr .pastdmark  
39a3 ..			.dmark: db "AT?"  
39a6 f1			.pastdmark: pop af  
39a7			endm  
# End of macro DMARK
39a7						CALLMONITOR 
39a7 cd ae 15			call break_point_state  
39aa				endm  
# End of macro CALLMONITOR
39aa					endif 
39aa 3a 68 ea				ld a, (f_cursor_ptr) 
39ad			 
39ad			if DEBUG_FORTH_WORDS 
39ad				DMARK "AT?" 
39ad f5				push af  
39ae 3a c2 39			ld a, (.dmark)  
39b1 32 71 ee			ld (debug_mark),a  
39b4 3a c3 39			ld a, (.dmark+1)  
39b7 32 72 ee			ld (debug_mark+1),a  
39ba 3a c4 39			ld a, (.dmark+2)  
39bd 32 73 ee			ld (debug_mark+2),a  
39c0 18 03			jr .pastdmark  
39c2 ..			.dmark: db "AT?"  
39c5 f1			.pastdmark: pop af  
39c6			endm  
# End of macro DMARK
39c6				CALLMONITOR 
39c6 cd ae 15			call break_point_state  
39c9				endm  
# End of macro CALLMONITOR
39c9			endif	 
39c9					; count the number of rows 
39c9			 
39c9 06 00				ld b, 0 
39cb 4f			.atpr:		ld c, a    ; save in case we go below zero 
39cc d6 28				sub display_cols 
39ce f2 d4 39				jp p, .atprunder 
39d1 04					inc b 
39d2 18 f7				jr .atpr 
39d4			.atprunder:	 
39d4			if DEBUG_FORTH_WORDS 
39d4				DMARK "A?2" 
39d4 f5				push af  
39d5 3a e9 39			ld a, (.dmark)  
39d8 32 71 ee			ld (debug_mark),a  
39db 3a ea 39			ld a, (.dmark+1)  
39de 32 72 ee			ld (debug_mark+1),a  
39e1 3a eb 39			ld a, (.dmark+2)  
39e4 32 73 ee			ld (debug_mark+2),a  
39e7 18 03			jr .pastdmark  
39e9 ..			.dmark: db "A?2"  
39ec f1			.pastdmark: pop af  
39ed			endm  
# End of macro DMARK
39ed				CALLMONITOR 
39ed cd ae 15			call break_point_state  
39f0				endm  
# End of macro CALLMONITOR
39f0			endif	 
39f0 26 00				ld h, 0 
39f2 69					ld l, c 
39f3 cd 1f 1c				call forth_push_numhl 
39f6 68					ld l, b  
39f7 cd 1f 1c				call forth_push_numhl 
39fa			 
39fa			 
39fa				NEXTW 
39fa c3 8d 1f			jp macro_next 
39fd				endm 
# End of macro NEXTW
39fd			 
39fd			.FB: 
39fd				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
39fd 1b				db WORD_SYS_CORE+7             
39fe 4b 3a			dw .EMIT            
3a00 03				db 2 + 1 
3a01 .. 00			db "FB",0              
3a04				endm 
# End of macro CWHEAD
3a04			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3a04			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3a04			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3a04			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3a04					if DEBUG_FORTH_WORDS_KEY 
3a04						DMARK "FB." 
3a04 f5				push af  
3a05 3a 19 3a			ld a, (.dmark)  
3a08 32 71 ee			ld (debug_mark),a  
3a0b 3a 1a 3a			ld a, (.dmark+1)  
3a0e 32 72 ee			ld (debug_mark+1),a  
3a11 3a 1b 3a			ld a, (.dmark+2)  
3a14 32 73 ee			ld (debug_mark+2),a  
3a17 18 03			jr .pastdmark  
3a19 ..			.dmark: db "FB."  
3a1c f1			.pastdmark: pop af  
3a1d			endm  
# End of macro DMARK
3a1d						CALLMONITOR 
3a1d cd ae 15			call break_point_state  
3a20				endm  
# End of macro CALLMONITOR
3a20					endif 
3a20			 
3a20					FORTH_DSP_VALUEHL 
3a20 cd 16 1e			call macro_dsp_valuehl 
3a23				endm 
# End of macro FORTH_DSP_VALUEHL
3a23			 
3a23 7d					ld a, l 
3a24 fe 01				cp 1 
3a26 20 05				jr nz, .fbn1 
3a28 21 16 ed				ld hl, display_fb1 
3a2b 18 15				jr .fbset 
3a2d fe 02		.fbn1:		cp 2 
3a2f 20 05				jr nz, .fbn2 
3a31 21 d4 eb				ld hl, display_fb2 
3a34 18 0c				jr .fbset 
3a36 fe 03		.fbn2:		cp 3 
3a38 20 05				jr nz, .fbn3 
3a3a 21 75 ec				ld hl, display_fb3 
3a3d 18 03				jr .fbset 
3a3f			.fbn3:		 ; if invalid number select first 
3a3f 21 16 ed				ld hl, display_fb1 
3a42 22 d2 eb		.fbset:		ld (display_fb_active), hl 
3a45			 
3a45					FORTH_DSP_POP 
3a45 cd ce 1e			call macro_forth_dsp_pop 
3a48				endm 
# End of macro FORTH_DSP_POP
3a48			 
3a48					NEXTW 
3a48 c3 8d 1f			jp macro_next 
3a4b				endm 
# End of macro NEXTW
3a4b			 
3a4b			 
3a4b			.EMIT: 
3a4b				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3a4b 1b				db WORD_SYS_CORE+7             
3a4c 9c 3a			dw .DOTH            
3a4e 05				db 4 + 1 
3a4f .. 00			db "EMIT",0              
3a54				endm 
# End of macro CWHEAD
3a54			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3a54					; get value off TOS and display it 
3a54			 
3a54					if DEBUG_FORTH_WORDS_KEY 
3a54						DMARK "EMT" 
3a54 f5				push af  
3a55 3a 69 3a			ld a, (.dmark)  
3a58 32 71 ee			ld (debug_mark),a  
3a5b 3a 6a 3a			ld a, (.dmark+1)  
3a5e 32 72 ee			ld (debug_mark+1),a  
3a61 3a 6b 3a			ld a, (.dmark+2)  
3a64 32 73 ee			ld (debug_mark+2),a  
3a67 18 03			jr .pastdmark  
3a69 ..			.dmark: db "EMT"  
3a6c f1			.pastdmark: pop af  
3a6d			endm  
# End of macro DMARK
3a6d						CALLMONITOR 
3a6d cd ae 15			call break_point_state  
3a70				endm  
# End of macro CALLMONITOR
3a70					endif 
3a70			 
3a70					FORTH_DSP_VALUEHL 
3a70 cd 16 1e			call macro_dsp_valuehl 
3a73				endm 
# End of macro FORTH_DSP_VALUEHL
3a73			 
3a73 7d					ld a,l 
3a74			 
3a74					; TODO write to display 
3a74			 
3a74 32 fd e4				ld (os_input), a 
3a77 3e 00				ld a, 0 
3a79 32 fe e4				ld (os_input+1), a 
3a7c					 
3a7c 3a 68 ea				ld a, (f_cursor_ptr) 
3a7f 11 fd e4				ld de, os_input 
3a82 cd 93 0b				call str_at_display 
3a85			 
3a85			 
3a85 3a 46 ea				ld a,(cli_autodisplay) 
3a88 fe 00				cp 0 
3a8a 28 03				jr z, .enoupdate 
3a8c cd a3 0b						call update_display 
3a8f					.enoupdate: 
3a8f			 
3a8f 3a 68 ea				ld a, (f_cursor_ptr) 
3a92 3c					inc a 
3a93 32 68 ea				ld (f_cursor_ptr), a   ; save new pos 
3a96			 
3a96			 
3a96					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a96 cd ce 1e			call macro_forth_dsp_pop 
3a99				endm 
# End of macro FORTH_DSP_POP
3a99			  
3a99			 
3a99					NEXTW 
3a99 c3 8d 1f			jp macro_next 
3a9c				endm 
# End of macro NEXTW
3a9c			.DOTH: 
3a9c				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3a9c 1c				db WORD_SYS_CORE+8             
3a9d cc 3a			dw .DOTF            
3a9f 03				db 2 + 1 
3aa0 .. 00			db ".-",0              
3aa3				endm 
# End of macro CWHEAD
3aa3			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3aa3					; get value off TOS and display it 
3aa3					if DEBUG_FORTH_WORDS_KEY 
3aa3						DMARK "DTD" 
3aa3 f5				push af  
3aa4 3a b8 3a			ld a, (.dmark)  
3aa7 32 71 ee			ld (debug_mark),a  
3aaa 3a b9 3a			ld a, (.dmark+1)  
3aad 32 72 ee			ld (debug_mark+1),a  
3ab0 3a ba 3a			ld a, (.dmark+2)  
3ab3 32 73 ee			ld (debug_mark+2),a  
3ab6 18 03			jr .pastdmark  
3ab8 ..			.dmark: db "DTD"  
3abb f1			.pastdmark: pop af  
3abc			endm  
# End of macro DMARK
3abc						CALLMONITOR 
3abc cd ae 15			call break_point_state  
3abf				endm  
# End of macro CALLMONITOR
3abf					endif 
3abf 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3ac1 3e 00			ld a, 0 
3ac3 32 47 ea			ld (cli_mvdot), a 
3ac6 c3 23 3b			jp .dotgo 
3ac9				NEXTW 
3ac9 c3 8d 1f			jp macro_next 
3acc				endm 
# End of macro NEXTW
3acc			.DOTF: 
3acc				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3acc 1c				db WORD_SYS_CORE+8             
3acd fa 3a			dw .DOT            
3acf 03				db 2 + 1 
3ad0 .. 00			db ".>",0              
3ad3				endm 
# End of macro CWHEAD
3ad3			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3ad3					; get value off TOS and display it 
3ad3			        ; TODO BUG adds extra spaces 
3ad3			        ; TODO BUG handle numerics? 
3ad3					if DEBUG_FORTH_WORDS_KEY 
3ad3						DMARK "DTC" 
3ad3 f5				push af  
3ad4 3a e8 3a			ld a, (.dmark)  
3ad7 32 71 ee			ld (debug_mark),a  
3ada 3a e9 3a			ld a, (.dmark+1)  
3add 32 72 ee			ld (debug_mark+1),a  
3ae0 3a ea 3a			ld a, (.dmark+2)  
3ae3 32 73 ee			ld (debug_mark+2),a  
3ae6 18 03			jr .pastdmark  
3ae8 ..			.dmark: db "DTC"  
3aeb f1			.pastdmark: pop af  
3aec			endm  
# End of macro DMARK
3aec						CALLMONITOR 
3aec cd ae 15			call break_point_state  
3aef				endm  
# End of macro CALLMONITOR
3aef					endif 
3aef 3e 01			ld a, 1 
3af1 32 47 ea			ld (cli_mvdot), a 
3af4 c3 23 3b			jp .dotgo 
3af7				NEXTW 
3af7 c3 8d 1f			jp macro_next 
3afa				endm 
# End of macro NEXTW
3afa			 
3afa			.DOT: 
3afa				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3afa 1c				db WORD_SYS_CORE+8             
3afb 86 3b			dw .CLS            
3afd 02				db 1 + 1 
3afe .. 00			db ".",0              
3b00				endm 
# End of macro CWHEAD
3b00			        ; | . ( u -- ) Display TOS | DONE 
3b00					; get value off TOS and display it 
3b00			 
3b00					if DEBUG_FORTH_WORDS_KEY 
3b00						DMARK "DOT" 
3b00 f5				push af  
3b01 3a 15 3b			ld a, (.dmark)  
3b04 32 71 ee			ld (debug_mark),a  
3b07 3a 16 3b			ld a, (.dmark+1)  
3b0a 32 72 ee			ld (debug_mark+1),a  
3b0d 3a 17 3b			ld a, (.dmark+2)  
3b10 32 73 ee			ld (debug_mark+2),a  
3b13 18 03			jr .pastdmark  
3b15 ..			.dmark: db "DOT"  
3b18 f1			.pastdmark: pop af  
3b19			endm  
# End of macro DMARK
3b19						CALLMONITOR 
3b19 cd ae 15			call break_point_state  
3b1c				endm  
# End of macro CALLMONITOR
3b1c					endif 
3b1c 3e 00			ld a, 0 
3b1e 32 47 ea			ld (cli_mvdot), a 
3b21 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3b23				 
3b23			 
3b23			.dotgo: 
3b23			 
3b23			; move up type to on stack for parserv5 
3b23					FORTH_DSP 
3b23 cd dc 1d			call macro_forth_dsp 
3b26				endm 
# End of macro FORTH_DSP
3b26				;FORTH_DSP_VALUE  
3b26			 
3b26			if DEBUG_FORTH_DOT 
3b26				DMARK "DOT" 
3b26				CALLMONITOR 
3b26			endif	 
3b26			;		.print: 
3b26			 
3b26 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3b27 23				inc hl   ; position to the actual value 
3b28 fe 01			cp DS_TYPE_STR 
3b2a 20 06			jr nz, .dotnum1  
3b2c			 
3b2c			; display string 
3b2c				FORTH_DSP_VALUE  
3b2c cd ff 1d			call macro_forth_dsp_value 
3b2f				endm 
# End of macro FORTH_DSP_VALUE
3b2f eb				ex de,hl 
3b30 18 11			jr .dotwrite 
3b32			 
3b32			.dotnum1: 
3b32 fe 02			cp DS_TYPE_INUM 
3b34 20 0c			jr nz, .dotflot 
3b36			 
3b36			 
3b36			; display number 
3b36			 
3b36			;	push hl 
3b36			;	call clear_display 
3b36			;	pop hl 
3b36			 
3b36 5e				ld e, (hl) 
3b37 23				inc hl 
3b38 56				ld d, (hl) 
3b39 21 ff e2			ld hl, scratch 
3b3c			if DEBUG_FORTH_DOT 
3b3c				DMARK "DT1" 
3b3c				CALLMONITOR 
3b3c			endif	 
3b3c			 
3b3c cd ba 11			call uitoa_16 
3b3f eb				ex de,hl 
3b40			 
3b40			if DEBUG_FORTH_DOT 
3b40				DMARK "DT2" 
3b40				CALLMONITOR 
3b40			endif	 
3b40			 
3b40			;	ld de, os_word_scratch 
3b40 18 01			jr .dotwrite 
3b42			 
3b42 00			.dotflot:   nop 
3b43			; TODO print floating point number 
3b43			 
3b43			.dotwrite:		 
3b43			 
3b43					; if c is set then set all '-' to spaces 
3b43					; need to also take into account .>  
3b43			 
3b43 3e 01				ld a, 1 
3b45 b9					cp c 
3b46 20 13				jr nz, .nodashswap 
3b48			 
3b48					; DE has the string to write, working with HL 
3b48			 
3b48 06 ff				ld b, 255 
3b4a d5					push de 
3b4b e1					pop hl 
3b4c			 
3b4c			if DEBUG_FORTH_DOT 
3b4c				DMARK "DT-" 
3b4c				CALLMONITOR 
3b4c			endif	 
3b4c 7e			.dashscan:	ld a, (hl) 
3b4d fe 00				cp 0 
3b4f 28 0a				jr z, .nodashswap 
3b51 fe 2d				cp '-' 
3b53 20 03				jr nz, .dashskip 
3b55 3e 20				ld a, ' ' 
3b57 77					ld (hl), a 
3b58 23			.dashskip:	inc hl 
3b59			if DEBUG_FORTH_DOT 
3b59				DMARK "D-2" 
3b59				CALLMONITOR 
3b59			endif	 
3b59 10 f1				djnz .dashscan 
3b5b			 
3b5b			if DEBUG_FORTH_DOT 
3b5b				DMARK "D-1" 
3b5b				CALLMONITOR 
3b5b			endif	 
3b5b			 
3b5b			.nodashswap: 
3b5b			 
3b5b e5					push hl   ; save string start in case we need to advance print 
3b5c			 
3b5c 3a 68 ea				ld a, (f_cursor_ptr) 
3b5f cd 93 0b				call str_at_display 
3b62 3a 46 ea				ld a,(cli_autodisplay) 
3b65 fe 00				cp 0 
3b67 28 03				jr z, .noupdate 
3b69 cd a3 0b						call update_display 
3b6c					.noupdate: 
3b6c			 
3b6c			 
3b6c					; see if we need to advance the print position 
3b6c			 
3b6c e1					pop hl   ; get back string 
3b6d			 
3b6d 3a 47 ea				ld a, (cli_mvdot) 
3b70			if DEBUG_FORTH_DOT 
3b70					ld e,a 
3b70				DMARK "D>1" 
3b70				CALLMONITOR 
3b70			endif	 
3b70 fe 00				cp 0 
3b72 28 0c				jr z, .noadv 
3b74					; yes, lets advance the print position 
3b74 3e 00				ld a, 0 
3b76 cd 16 12				call strlent 
3b79 3a 68 ea				ld a, (f_cursor_ptr) 
3b7c 85					add a,l 
3b7d					;call addatohl 
3b7d					;ld a, l 
3b7d 32 68 ea				ld (f_cursor_ptr), a   ; save new pos 
3b80			 
3b80			if DEBUG_FORTH_DOT 
3b80				DMARK "D->" 
3b80				CALLMONITOR 
3b80			endif	 
3b80			 
3b80			.noadv:	 
3b80			 
3b80					if DEBUG_FORTH_DOT_WAIT 
3b80							call next_page_prompt 
3b80					endif	 
3b80			; TODO this pop off the stack causes a crash. i dont know why 
3b80			 
3b80			 
3b80			if DEBUG_FORTH_DOT 
3b80				DMARK "DTh" 
3b80				CALLMONITOR 
3b80			endif	 
3b80			 
3b80					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b80 cd ce 1e			call macro_forth_dsp_pop 
3b83				endm 
# End of macro FORTH_DSP_POP
3b83			 
3b83			if DEBUG_FORTH_DOT 
3b83				DMARK "DTi" 
3b83				CALLMONITOR 
3b83			endif	 
3b83			 
3b83			 
3b83					NEXTW 
3b83 c3 8d 1f			jp macro_next 
3b86				endm 
# End of macro NEXTW
3b86			 
3b86			.CLS: 
3b86				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3b86 35				db WORD_SYS_CORE+33             
3b87 b3 3b			dw .DRAW            
3b89 04				db 3 + 1 
3b8a .. 00			db "CLS",0              
3b8e				endm 
# End of macro CWHEAD
3b8e			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3b8e					if DEBUG_FORTH_WORDS_KEY 
3b8e						DMARK "CLS" 
3b8e f5				push af  
3b8f 3a a3 3b			ld a, (.dmark)  
3b92 32 71 ee			ld (debug_mark),a  
3b95 3a a4 3b			ld a, (.dmark+1)  
3b98 32 72 ee			ld (debug_mark+1),a  
3b9b 3a a5 3b			ld a, (.dmark+2)  
3b9e 32 73 ee			ld (debug_mark+2),a  
3ba1 18 03			jr .pastdmark  
3ba3 ..			.dmark: db "CLS"  
3ba6 f1			.pastdmark: pop af  
3ba7			endm  
# End of macro DMARK
3ba7						CALLMONITOR 
3ba7 cd ae 15			call break_point_state  
3baa				endm  
# End of macro CALLMONITOR
3baa					endif 
3baa cd 80 0b				call clear_display 
3bad c3 c1 3c				jp .home		; and home cursor 
3bb0					NEXTW 
3bb0 c3 8d 1f			jp macro_next 
3bb3				endm 
# End of macro NEXTW
3bb3			 
3bb3			.DRAW: 
3bb3				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3bb3 36				db WORD_SYS_CORE+34             
3bb4 de 3b			dw .DUMP            
3bb6 05				db 4 + 1 
3bb7 .. 00			db "DRAW",0              
3bbc				endm 
# End of macro CWHEAD
3bbc			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3bbc					if DEBUG_FORTH_WORDS_KEY 
3bbc						DMARK "DRW" 
3bbc f5				push af  
3bbd 3a d1 3b			ld a, (.dmark)  
3bc0 32 71 ee			ld (debug_mark),a  
3bc3 3a d2 3b			ld a, (.dmark+1)  
3bc6 32 72 ee			ld (debug_mark+1),a  
3bc9 3a d3 3b			ld a, (.dmark+2)  
3bcc 32 73 ee			ld (debug_mark+2),a  
3bcf 18 03			jr .pastdmark  
3bd1 ..			.dmark: db "DRW"  
3bd4 f1			.pastdmark: pop af  
3bd5			endm  
# End of macro DMARK
3bd5						CALLMONITOR 
3bd5 cd ae 15			call break_point_state  
3bd8				endm  
# End of macro CALLMONITOR
3bd8					endif 
3bd8 cd a3 0b				call update_display 
3bdb					NEXTW 
3bdb c3 8d 1f			jp macro_next 
3bde				endm 
# End of macro NEXTW
3bde			 
3bde			.DUMP: 
3bde				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3bde 37				db WORD_SYS_CORE+35             
3bdf 16 3c			dw .CDUMP            
3be1 05				db 4 + 1 
3be2 .. 00			db "DUMP",0              
3be7				endm 
# End of macro CWHEAD
3be7			; | DUMP ( x -- ) With address x display dump   | DONE 
3be7			; TODO pop address to use off of the stack 
3be7					if DEBUG_FORTH_WORDS_KEY 
3be7						DMARK "DUM" 
3be7 f5				push af  
3be8 3a fc 3b			ld a, (.dmark)  
3beb 32 71 ee			ld (debug_mark),a  
3bee 3a fd 3b			ld a, (.dmark+1)  
3bf1 32 72 ee			ld (debug_mark+1),a  
3bf4 3a fe 3b			ld a, (.dmark+2)  
3bf7 32 73 ee			ld (debug_mark+2),a  
3bfa 18 03			jr .pastdmark  
3bfc ..			.dmark: db "DUM"  
3bff f1			.pastdmark: pop af  
3c00			endm  
# End of macro DMARK
3c00						CALLMONITOR 
3c00 cd ae 15			call break_point_state  
3c03				endm  
# End of macro CALLMONITOR
3c03					endif 
3c03 cd 80 0b				call clear_display 
3c06			 
3c06					; get address 
3c06			 
3c06					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c06 cd 16 1e			call macro_dsp_valuehl 
3c09				endm 
# End of macro FORTH_DSP_VALUEHL
3c09				 
3c09					; save it for cdump 
3c09			 
3c09 22 22 e6				ld (os_cur_ptr),hl 
3c0c			 
3c0c					; destroy value TOS 
3c0c			 
3c0c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c0c cd ce 1e			call macro_forth_dsp_pop 
3c0f				endm 
# End of macro FORTH_DSP_POP
3c0f			 
3c0f cd 9f 1a				call dumpcont	; skip old style of param parsing	 
3c12 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3c13					NEXTW 
3c13 c3 8d 1f			jp macro_next 
3c16				endm 
# End of macro NEXTW
3c16			.CDUMP: 
3c16				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3c16 38				db WORD_SYS_CORE+36             
3c17 46 3c			dw .DAT            
3c19 06				db 5 + 1 
3c1a .. 00			db "CDUMP",0              
3c20				endm 
# End of macro CWHEAD
3c20			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3c20					if DEBUG_FORTH_WORDS_KEY 
3c20						DMARK "CDP" 
3c20 f5				push af  
3c21 3a 35 3c			ld a, (.dmark)  
3c24 32 71 ee			ld (debug_mark),a  
3c27 3a 36 3c			ld a, (.dmark+1)  
3c2a 32 72 ee			ld (debug_mark+1),a  
3c2d 3a 37 3c			ld a, (.dmark+2)  
3c30 32 73 ee			ld (debug_mark+2),a  
3c33 18 03			jr .pastdmark  
3c35 ..			.dmark: db "CDP"  
3c38 f1			.pastdmark: pop af  
3c39			endm  
# End of macro DMARK
3c39						CALLMONITOR 
3c39 cd ae 15			call break_point_state  
3c3c				endm  
# End of macro CALLMONITOR
3c3c					endif 
3c3c cd 80 0b				call clear_display 
3c3f cd 9f 1a				call dumpcont	 
3c42 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3c43					NEXTW 
3c43 c3 8d 1f			jp macro_next 
3c46				endm 
# End of macro NEXTW
3c46			 
3c46			 
3c46			 
3c46			 
3c46			.DAT: 
3c46				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3c46 3d				db WORD_SYS_CORE+41             
3c47 9c 3c			dw .HOME            
3c49 03				db 2 + 1 
3c4a .. 00			db "AT",0              
3c4d				endm 
# End of macro CWHEAD
3c4d			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3c4d					if DEBUG_FORTH_WORDS_KEY 
3c4d						DMARK "AT." 
3c4d f5				push af  
3c4e 3a 62 3c			ld a, (.dmark)  
3c51 32 71 ee			ld (debug_mark),a  
3c54 3a 63 3c			ld a, (.dmark+1)  
3c57 32 72 ee			ld (debug_mark+1),a  
3c5a 3a 64 3c			ld a, (.dmark+2)  
3c5d 32 73 ee			ld (debug_mark+2),a  
3c60 18 03			jr .pastdmark  
3c62 ..			.dmark: db "AT."  
3c65 f1			.pastdmark: pop af  
3c66			endm  
# End of macro DMARK
3c66						CALLMONITOR 
3c66 cd ae 15			call break_point_state  
3c69				endm  
# End of macro CALLMONITOR
3c69					endif 
3c69					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c69 cd 16 1e			call macro_dsp_valuehl 
3c6c				endm 
# End of macro FORTH_DSP_VALUEHL
3c6c			 
3c6c			 
3c6c					; TODO save cursor row 
3c6c 7d					ld a,l 
3c6d fe 02				cp 2 
3c6f 20 04				jr nz, .crow3 
3c71 3e 28				ld a, display_row_2 
3c73 18 12				jr .ccol1 
3c75 fe 03		.crow3:		cp 3 
3c77 20 04				jr nz, .crow4 
3c79 3e 50				ld a, display_row_3 
3c7b 18 0a				jr .ccol1 
3c7d fe 04		.crow4:		cp 4 
3c7f 20 04				jr nz, .crow1 
3c81 3e 78				ld a, display_row_4 
3c83 18 02				jr .ccol1 
3c85 3e 00		.crow1:		ld a,display_row_1 
3c87 f5			.ccol1:		push af			; got row offset 
3c88 6f					ld l,a 
3c89 26 00				ld h,0 
3c8b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c8b cd ce 1e			call macro_forth_dsp_pop 
3c8e				endm 
# End of macro FORTH_DSP_POP
3c8e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c8e cd 16 1e			call macro_dsp_valuehl 
3c91				endm 
# End of macro FORTH_DSP_VALUEHL
3c91					; TODO save cursor col 
3c91 f1					pop af 
3c92 85					add l		; add col offset 
3c93 32 68 ea				ld (f_cursor_ptr), a 
3c96					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c96 cd ce 1e			call macro_forth_dsp_pop 
3c99				endm 
# End of macro FORTH_DSP_POP
3c99			 
3c99					; calculate  
3c99			 
3c99					NEXTW 
3c99 c3 8d 1f			jp macro_next 
3c9c				endm 
# End of macro NEXTW
3c9c			 
3c9c			 
3c9c			.HOME: 
3c9c				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3c9c 41				db WORD_SYS_CORE+45             
3c9d c9 3c			dw .SPACE            
3c9f 05				db 4 + 1 
3ca0 .. 00			db "HOME",0              
3ca5				endm 
# End of macro CWHEAD
3ca5			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3ca5					if DEBUG_FORTH_WORDS_KEY 
3ca5						DMARK "HOM" 
3ca5 f5				push af  
3ca6 3a ba 3c			ld a, (.dmark)  
3ca9 32 71 ee			ld (debug_mark),a  
3cac 3a bb 3c			ld a, (.dmark+1)  
3caf 32 72 ee			ld (debug_mark+1),a  
3cb2 3a bc 3c			ld a, (.dmark+2)  
3cb5 32 73 ee			ld (debug_mark+2),a  
3cb8 18 03			jr .pastdmark  
3cba ..			.dmark: db "HOM"  
3cbd f1			.pastdmark: pop af  
3cbe			endm  
# End of macro DMARK
3cbe						CALLMONITOR 
3cbe cd ae 15			call break_point_state  
3cc1				endm  
# End of macro CALLMONITOR
3cc1					endif 
3cc1 3e 00		.home:		ld a, 0		; and home cursor 
3cc3 32 68 ea				ld (f_cursor_ptr), a 
3cc6					NEXTW 
3cc6 c3 8d 1f			jp macro_next 
3cc9				endm 
# End of macro NEXTW
3cc9			 
3cc9			 
3cc9			.SPACE: 
3cc9				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3cc9 46				db WORD_SYS_CORE+50             
3cca f7 3c			dw .SPACES            
3ccc 03				db 2 + 1 
3ccd .. 00			db "BL",0              
3cd0				endm 
# End of macro CWHEAD
3cd0			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3cd0					if DEBUG_FORTH_WORDS_KEY 
3cd0						DMARK "BL." 
3cd0 f5				push af  
3cd1 3a e5 3c			ld a, (.dmark)  
3cd4 32 71 ee			ld (debug_mark),a  
3cd7 3a e6 3c			ld a, (.dmark+1)  
3cda 32 72 ee			ld (debug_mark+1),a  
3cdd 3a e7 3c			ld a, (.dmark+2)  
3ce0 32 73 ee			ld (debug_mark+2),a  
3ce3 18 03			jr .pastdmark  
3ce5 ..			.dmark: db "BL."  
3ce8 f1			.pastdmark: pop af  
3ce9			endm  
# End of macro DMARK
3ce9						CALLMONITOR 
3ce9 cd ae 15			call break_point_state  
3cec				endm  
# End of macro CALLMONITOR
3cec					endif 
3cec 21 f5 3c				ld hl, .blstr 
3cef cd 8d 1c				call forth_push_str 
3cf2					 
3cf2				       NEXTW 
3cf2 c3 8d 1f			jp macro_next 
3cf5				endm 
# End of macro NEXTW
3cf5			 
3cf5 .. 00		.blstr: db " ", 0 
3cf7			 
3cf7			.SPACES: 
3cf7				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3cf7 47				db WORD_SYS_CORE+51             
3cf8 92 3d			dw .SCROLL            
3cfa 07				db 6 + 1 
3cfb .. 00			db "SPACES",0              
3d02				endm 
# End of macro CWHEAD
3d02			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3d02					if DEBUG_FORTH_WORDS_KEY 
3d02						DMARK "SPS" 
3d02 f5				push af  
3d03 3a 17 3d			ld a, (.dmark)  
3d06 32 71 ee			ld (debug_mark),a  
3d09 3a 18 3d			ld a, (.dmark+1)  
3d0c 32 72 ee			ld (debug_mark+1),a  
3d0f 3a 19 3d			ld a, (.dmark+2)  
3d12 32 73 ee			ld (debug_mark+2),a  
3d15 18 03			jr .pastdmark  
3d17 ..			.dmark: db "SPS"  
3d1a f1			.pastdmark: pop af  
3d1b			endm  
# End of macro DMARK
3d1b						CALLMONITOR 
3d1b cd ae 15			call break_point_state  
3d1e				endm  
# End of macro CALLMONITOR
3d1e					endif 
3d1e			 
3d1e			 
3d1e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d1e cd 16 1e			call macro_dsp_valuehl 
3d21				endm 
# End of macro FORTH_DSP_VALUEHL
3d21			 
3d21			;		push hl    ; u 
3d21					if DEBUG_FORTH_WORDS 
3d21						DMARK "SPA" 
3d21 f5				push af  
3d22 3a 36 3d			ld a, (.dmark)  
3d25 32 71 ee			ld (debug_mark),a  
3d28 3a 37 3d			ld a, (.dmark+1)  
3d2b 32 72 ee			ld (debug_mark+1),a  
3d2e 3a 38 3d			ld a, (.dmark+2)  
3d31 32 73 ee			ld (debug_mark+2),a  
3d34 18 03			jr .pastdmark  
3d36 ..			.dmark: db "SPA"  
3d39 f1			.pastdmark: pop af  
3d3a			endm  
# End of macro DMARK
3d3a						CALLMONITOR 
3d3a cd ae 15			call break_point_state  
3d3d				endm  
# End of macro CALLMONITOR
3d3d					endif 
3d3d			 
3d3d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d3d cd ce 1e			call macro_forth_dsp_pop 
3d40				endm 
# End of macro FORTH_DSP_POP
3d40			;		pop hl 
3d40 4d					ld c, l 
3d41 06 00				ld b, 0 
3d43 21 ff e2				ld hl, scratch  
3d46			 
3d46					if DEBUG_FORTH_WORDS 
3d46						DMARK "SP2" 
3d46 f5				push af  
3d47 3a 5b 3d			ld a, (.dmark)  
3d4a 32 71 ee			ld (debug_mark),a  
3d4d 3a 5c 3d			ld a, (.dmark+1)  
3d50 32 72 ee			ld (debug_mark+1),a  
3d53 3a 5d 3d			ld a, (.dmark+2)  
3d56 32 73 ee			ld (debug_mark+2),a  
3d59 18 03			jr .pastdmark  
3d5b ..			.dmark: db "SP2"  
3d5e f1			.pastdmark: pop af  
3d5f			endm  
# End of macro DMARK
3d5f						CALLMONITOR 
3d5f cd ae 15			call break_point_state  
3d62				endm  
# End of macro CALLMONITOR
3d62					endif 
3d62 3e 20				ld a, ' ' 
3d64 c5			.spaces1:	push bc 
3d65 77					ld (hl),a 
3d66 23					inc hl 
3d67 c1					pop bc 
3d68 10 fa				djnz .spaces1 
3d6a 3e 00				ld a,0 
3d6c 77					ld (hl),a 
3d6d 21 ff e2				ld hl, scratch 
3d70					if DEBUG_FORTH_WORDS 
3d70						DMARK "SP3" 
3d70 f5				push af  
3d71 3a 85 3d			ld a, (.dmark)  
3d74 32 71 ee			ld (debug_mark),a  
3d77 3a 86 3d			ld a, (.dmark+1)  
3d7a 32 72 ee			ld (debug_mark+1),a  
3d7d 3a 87 3d			ld a, (.dmark+2)  
3d80 32 73 ee			ld (debug_mark+2),a  
3d83 18 03			jr .pastdmark  
3d85 ..			.dmark: db "SP3"  
3d88 f1			.pastdmark: pop af  
3d89			endm  
# End of macro DMARK
3d89						CALLMONITOR 
3d89 cd ae 15			call break_point_state  
3d8c				endm  
# End of macro CALLMONITOR
3d8c					endif 
3d8c cd 88 1d				call forth_apush 
3d8f			 
3d8f				       NEXTW 
3d8f c3 8d 1f			jp macro_next 
3d92				endm 
# End of macro NEXTW
3d92			 
3d92			 
3d92			 
3d92			.SCROLL: 
3d92				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3d92 53				db WORD_SYS_CORE+63             
3d93 bf 3d			dw .SCROLLD            
3d95 07				db 6 + 1 
3d96 .. 00			db "SCROLL",0              
3d9d				endm 
# End of macro CWHEAD
3d9d			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3d9d					if DEBUG_FORTH_WORDS_KEY 
3d9d						DMARK "SCR" 
3d9d f5				push af  
3d9e 3a b2 3d			ld a, (.dmark)  
3da1 32 71 ee			ld (debug_mark),a  
3da4 3a b3 3d			ld a, (.dmark+1)  
3da7 32 72 ee			ld (debug_mark+1),a  
3daa 3a b4 3d			ld a, (.dmark+2)  
3dad 32 73 ee			ld (debug_mark+2),a  
3db0 18 03			jr .pastdmark  
3db2 ..			.dmark: db "SCR"  
3db5 f1			.pastdmark: pop af  
3db6			endm  
# End of macro DMARK
3db6						CALLMONITOR 
3db6 cd ae 15			call break_point_state  
3db9				endm  
# End of macro CALLMONITOR
3db9					endif 
3db9			 
3db9 cd 42 0b			call scroll_up 
3dbc			;	call update_display 
3dbc			 
3dbc					NEXTW 
3dbc c3 8d 1f			jp macro_next 
3dbf				endm 
# End of macro NEXTW
3dbf			 
3dbf			 
3dbf			 
3dbf			;		; get dir 
3dbf			; 
3dbf			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dbf			; 
3dbf			;		push hl 
3dbf			; 
3dbf			;		; destroy value TOS 
3dbf			; 
3dbf			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3dbf			; 
3dbf			;		; get count 
3dbf			; 
3dbf			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dbf			; 
3dbf			;		push hl 
3dbf			; 
3dbf			;		; destroy value TOS 
3dbf			; 
3dbf			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3dbf			; 
3dbf			;		; one value on hl get other one back 
3dbf			; 
3dbf			;		pop bc    ; count 
3dbf			; 
3dbf			;		pop de   ; dir 
3dbf			; 
3dbf			; 
3dbf			;		ld b, c 
3dbf			; 
3dbf			;.scrolldir:     push bc 
3dbf			;		push de 
3dbf			; 
3dbf			;		ld a, 0 
3dbf			;		cp e 
3dbf			;		jr z, .scrollup  
3dbf			;		call scroll_down 
3dbf			;		jr .scrollnext 
3dbf			;.scrollup:	call scroll_up 
3dbf			; 
3dbf			;		 
3dbf			;.scrollnext: 
3dbf			;		pop de 
3dbf			;		pop bc 
3dbf			;		djnz .scrolldir 
3dbf			; 
3dbf			; 
3dbf			; 
3dbf			; 
3dbf			; 
3dbf			;		NEXTW 
3dbf			 
3dbf			.SCROLLD: 
3dbf				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3dbf 53				db WORD_SYS_CORE+63             
3dc0 ed 3d			dw .ATQ            
3dc2 08				db 7 + 1 
3dc3 .. 00			db "SCROLLD",0              
3dcb				endm 
# End of macro CWHEAD
3dcb			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3dcb					if DEBUG_FORTH_WORDS_KEY 
3dcb						DMARK "SCD" 
3dcb f5				push af  
3dcc 3a e0 3d			ld a, (.dmark)  
3dcf 32 71 ee			ld (debug_mark),a  
3dd2 3a e1 3d			ld a, (.dmark+1)  
3dd5 32 72 ee			ld (debug_mark+1),a  
3dd8 3a e2 3d			ld a, (.dmark+2)  
3ddb 32 73 ee			ld (debug_mark+2),a  
3dde 18 03			jr .pastdmark  
3de0 ..			.dmark: db "SCD"  
3de3 f1			.pastdmark: pop af  
3de4			endm  
# End of macro DMARK
3de4						CALLMONITOR 
3de4 cd ae 15			call break_point_state  
3de7				endm  
# End of macro CALLMONITOR
3de7					endif 
3de7			 
3de7 cd 66 0b			call scroll_down 
3dea			;	call update_display 
3dea			 
3dea					NEXTW 
3dea c3 8d 1f			jp macro_next 
3ded				endm 
# End of macro NEXTW
3ded			 
3ded			 
3ded			.ATQ: 
3ded				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3ded 62				db WORD_SYS_CORE+78             
3dee 4b 3e			dw .AUTODSP            
3df0 04				db 3 + 1 
3df1 .. 00			db "AT@",0              
3df5				endm 
# End of macro CWHEAD
3df5			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3df5					if DEBUG_FORTH_WORDS_KEY 
3df5						DMARK "ATA" 
3df5 f5				push af  
3df6 3a 0a 3e			ld a, (.dmark)  
3df9 32 71 ee			ld (debug_mark),a  
3dfc 3a 0b 3e			ld a, (.dmark+1)  
3dff 32 72 ee			ld (debug_mark+1),a  
3e02 3a 0c 3e			ld a, (.dmark+2)  
3e05 32 73 ee			ld (debug_mark+2),a  
3e08 18 03			jr .pastdmark  
3e0a ..			.dmark: db "ATA"  
3e0d f1			.pastdmark: pop af  
3e0e			endm  
# End of macro DMARK
3e0e						CALLMONITOR 
3e0e cd ae 15			call break_point_state  
3e11				endm  
# End of macro CALLMONITOR
3e11					endif 
3e11			 
3e11			 
3e11					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e11 cd 16 1e			call macro_dsp_valuehl 
3e14				endm 
# End of macro FORTH_DSP_VALUEHL
3e14			 
3e14					; TODO save cursor row 
3e14 7d					ld a,l 
3e15 fe 02				cp 2 
3e17 20 04				jr nz, .crow3aq 
3e19 3e 28				ld a, display_row_2 
3e1b 18 12				jr .ccol1aq 
3e1d fe 03		.crow3aq:		cp 3 
3e1f 20 04				jr nz, .crow4aq 
3e21 3e 50				ld a, display_row_3 
3e23 18 0a				jr .ccol1aq 
3e25 fe 04		.crow4aq:		cp 4 
3e27 20 04				jr nz, .crow1aq 
3e29 3e 78				ld a, display_row_4 
3e2b 18 02				jr .ccol1aq 
3e2d 3e 00		.crow1aq:		ld a,display_row_1 
3e2f f5			.ccol1aq:		push af			; got row offset 
3e30 6f					ld l,a 
3e31 26 00				ld h,0 
3e33					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e33 cd ce 1e			call macro_forth_dsp_pop 
3e36				endm 
# End of macro FORTH_DSP_POP
3e36					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e36 cd 16 1e			call macro_dsp_valuehl 
3e39				endm 
# End of macro FORTH_DSP_VALUEHL
3e39					; TODO save cursor col 
3e39 f1					pop af 
3e3a 85					add l		; add col offset 
3e3b			 
3e3b					; add current frame buffer address 
3e3b 2a d2 eb				ld hl, (display_fb_active) 
3e3e cd ad 0d				call addatohl 
3e41			 
3e41			 
3e41			 
3e41			 
3e41					; get char frame buffer location offset in hl 
3e41			 
3e41 7e					ld a,(hl) 
3e42 26 00				ld h, 0 
3e44 6f					ld l, a 
3e45			 
3e45 cd 1f 1c				call forth_push_numhl 
3e48			 
3e48			 
3e48					NEXTW 
3e48 c3 8d 1f			jp macro_next 
3e4b				endm 
# End of macro NEXTW
3e4b			 
3e4b			.AUTODSP: 
3e4b				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3e4b 63				db WORD_SYS_CORE+79             
3e4c 61 3e			dw .MENU            
3e4e 05				db 4 + 1 
3e4f .. 00			db "ADSP",0              
3e54				endm 
# End of macro CWHEAD
3e54			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3e54			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3e54			 
3e54					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e54 cd 16 1e			call macro_dsp_valuehl 
3e57				endm 
# End of macro FORTH_DSP_VALUEHL
3e57			 
3e57			;		push hl 
3e57			 
3e57					; destroy value TOS 
3e57			 
3e57					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e57 cd ce 1e			call macro_forth_dsp_pop 
3e5a				endm 
# End of macro FORTH_DSP_POP
3e5a			 
3e5a			;		pop hl 
3e5a			 
3e5a 7d					ld a,l 
3e5b 32 46 ea				ld (cli_autodisplay), a 
3e5e				       NEXTW 
3e5e c3 8d 1f			jp macro_next 
3e61				endm 
# End of macro NEXTW
3e61			 
3e61			.MENU: 
3e61				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3e61 70				db WORD_SYS_CORE+92             
3e62 0a 3f			dw .ENDDISPLAY            
3e64 05				db 4 + 1 
3e65 .. 00			db "MENU",0              
3e6a				endm 
# End of macro CWHEAD
3e6a			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3e6a			 
3e6a			;		; get number of items on the stack 
3e6a			; 
3e6a				 
3e6a					FORTH_DSP_VALUEHL 
3e6a cd 16 1e			call macro_dsp_valuehl 
3e6d				endm 
# End of macro FORTH_DSP_VALUEHL
3e6d				 
3e6d					if DEBUG_FORTH_WORDS_KEY 
3e6d						DMARK "MNU" 
3e6d f5				push af  
3e6e 3a 82 3e			ld a, (.dmark)  
3e71 32 71 ee			ld (debug_mark),a  
3e74 3a 83 3e			ld a, (.dmark+1)  
3e77 32 72 ee			ld (debug_mark+1),a  
3e7a 3a 84 3e			ld a, (.dmark+2)  
3e7d 32 73 ee			ld (debug_mark+2),a  
3e80 18 03			jr .pastdmark  
3e82 ..			.dmark: db "MNU"  
3e85 f1			.pastdmark: pop af  
3e86			endm  
# End of macro DMARK
3e86						CALLMONITOR 
3e86 cd ae 15			call break_point_state  
3e89				endm  
# End of macro CALLMONITOR
3e89					endif 
3e89			 
3e89 45					ld b, l	 
3e8a 05					dec b 
3e8b			 
3e8b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e8b cd ce 1e			call macro_forth_dsp_pop 
3e8e				endm 
# End of macro FORTH_DSP_POP
3e8e			 
3e8e			 
3e8e					; go directly through the stack to pluck out the string pointers and build an array 
3e8e			 
3e8e			;		FORTH_DSP 
3e8e			 
3e8e					; hl contains top most stack item 
3e8e				 
3e8e 11 ff e2				ld de, scratch 
3e91			 
3e91			.mbuild: 
3e91			 
3e91					FORTH_DSP_VALUEHL 
3e91 cd 16 1e			call macro_dsp_valuehl 
3e94				endm 
# End of macro FORTH_DSP_VALUEHL
3e94			 
3e94					if DEBUG_FORTH_WORDS 
3e94						DMARK "MN3" 
3e94 f5				push af  
3e95 3a a9 3e			ld a, (.dmark)  
3e98 32 71 ee			ld (debug_mark),a  
3e9b 3a aa 3e			ld a, (.dmark+1)  
3e9e 32 72 ee			ld (debug_mark+1),a  
3ea1 3a ab 3e			ld a, (.dmark+2)  
3ea4 32 73 ee			ld (debug_mark+2),a  
3ea7 18 03			jr .pastdmark  
3ea9 ..			.dmark: db "MN3"  
3eac f1			.pastdmark: pop af  
3ead			endm  
# End of macro DMARK
3ead						CALLMONITOR 
3ead cd ae 15			call break_point_state  
3eb0				endm  
# End of macro CALLMONITOR
3eb0					endif 
3eb0 eb					ex de, hl 
3eb1 73					ld (hl), e 
3eb2 23					inc hl 
3eb3 72					ld (hl), d 
3eb4 23					inc hl 
3eb5 eb					ex de, hl 
3eb6			 
3eb6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3eb6 cd ce 1e			call macro_forth_dsp_pop 
3eb9				endm 
# End of macro FORTH_DSP_POP
3eb9			 
3eb9 10 d6				djnz .mbuild 
3ebb			 
3ebb					; done add term 
3ebb			 
3ebb eb					ex de, hl 
3ebc 36 00				ld (hl), 0 
3ebe 23					inc hl 
3ebf 36 00				ld (hl), 0 
3ec1			 
3ec1				 
3ec1					 
3ec1 21 ff e2				ld hl, scratch 
3ec4			 
3ec4					if DEBUG_FORTH_WORDS 
3ec4						DMARK "MNx" 
3ec4 f5				push af  
3ec5 3a d9 3e			ld a, (.dmark)  
3ec8 32 71 ee			ld (debug_mark),a  
3ecb 3a da 3e			ld a, (.dmark+1)  
3ece 32 72 ee			ld (debug_mark+1),a  
3ed1 3a db 3e			ld a, (.dmark+2)  
3ed4 32 73 ee			ld (debug_mark+2),a  
3ed7 18 03			jr .pastdmark  
3ed9 ..			.dmark: db "MNx"  
3edc f1			.pastdmark: pop af  
3edd			endm  
# End of macro DMARK
3edd						CALLMONITOR 
3edd cd ae 15			call break_point_state  
3ee0				endm  
# End of macro CALLMONITOR
3ee0					endif 
3ee0			 
3ee0			 
3ee0			 
3ee0 3e 00				ld a, 0 
3ee2 cd b1 0b				call menu 
3ee5			 
3ee5			 
3ee5 6f					ld l, a 
3ee6 26 00				ld h, 0 
3ee8			 
3ee8					if DEBUG_FORTH_WORDS 
3ee8						DMARK "MNr" 
3ee8 f5				push af  
3ee9 3a fd 3e			ld a, (.dmark)  
3eec 32 71 ee			ld (debug_mark),a  
3eef 3a fe 3e			ld a, (.dmark+1)  
3ef2 32 72 ee			ld (debug_mark+1),a  
3ef5 3a ff 3e			ld a, (.dmark+2)  
3ef8 32 73 ee			ld (debug_mark+2),a  
3efb 18 03			jr .pastdmark  
3efd ..			.dmark: db "MNr"  
3f00 f1			.pastdmark: pop af  
3f01			endm  
# End of macro DMARK
3f01						CALLMONITOR 
3f01 cd ae 15			call break_point_state  
3f04				endm  
# End of macro CALLMONITOR
3f04					endif 
3f04			 
3f04 cd 1f 1c				call forth_push_numhl 
3f07			 
3f07			 
3f07			 
3f07			 
3f07				       NEXTW 
3f07 c3 8d 1f			jp macro_next 
3f0a				endm 
# End of macro NEXTW
3f0a			 
3f0a			 
3f0a			.ENDDISPLAY: 
3f0a			 
3f0a			; eof 
# End of file forth_words_display.asm
3f0a			include "forth_words_str.asm" 
3f0a			 
3f0a			; | ## String Words 
3f0a			 
3f0a			.PTR:   
3f0a			 
3f0a				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3f0a 48				db WORD_SYS_CORE+52             
3f0b 37 3f			dw .STYPE            
3f0d 04				db 3 + 1 
3f0e .. 00			db "PTR",0              
3f12				endm 
# End of macro CWHEAD
3f12			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3f12			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3f12			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3f12			 
3f12					if DEBUG_FORTH_WORDS_KEY 
3f12						DMARK "PTR" 
3f12 f5				push af  
3f13 3a 27 3f			ld a, (.dmark)  
3f16 32 71 ee			ld (debug_mark),a  
3f19 3a 28 3f			ld a, (.dmark+1)  
3f1c 32 72 ee			ld (debug_mark+1),a  
3f1f 3a 29 3f			ld a, (.dmark+2)  
3f22 32 73 ee			ld (debug_mark+2),a  
3f25 18 03			jr .pastdmark  
3f27 ..			.dmark: db "PTR"  
3f2a f1			.pastdmark: pop af  
3f2b			endm  
# End of macro DMARK
3f2b						CALLMONITOR 
3f2b cd ae 15			call break_point_state  
3f2e				endm  
# End of macro CALLMONITOR
3f2e					endif 
3f2e					FORTH_DSP_VALUEHL 
3f2e cd 16 1e			call macro_dsp_valuehl 
3f31				endm 
# End of macro FORTH_DSP_VALUEHL
3f31 cd 1f 1c				call forth_push_numhl 
3f34			 
3f34			 
3f34					NEXTW 
3f34 c3 8d 1f			jp macro_next 
3f37				endm 
# End of macro NEXTW
3f37			.STYPE: 
3f37				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3f37 48				db WORD_SYS_CORE+52             
3f38 86 3f			dw .UPPER            
3f3a 06				db 5 + 1 
3f3b .. 00			db "STYPE",0              
3f41				endm 
# End of macro CWHEAD
3f41			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3f41					if DEBUG_FORTH_WORDS_KEY 
3f41						DMARK "STY" 
3f41 f5				push af  
3f42 3a 56 3f			ld a, (.dmark)  
3f45 32 71 ee			ld (debug_mark),a  
3f48 3a 57 3f			ld a, (.dmark+1)  
3f4b 32 72 ee			ld (debug_mark+1),a  
3f4e 3a 58 3f			ld a, (.dmark+2)  
3f51 32 73 ee			ld (debug_mark+2),a  
3f54 18 03			jr .pastdmark  
3f56 ..			.dmark: db "STY"  
3f59 f1			.pastdmark: pop af  
3f5a			endm  
# End of macro DMARK
3f5a						CALLMONITOR 
3f5a cd ae 15			call break_point_state  
3f5d				endm  
# End of macro CALLMONITOR
3f5d					endif 
3f5d					FORTH_DSP 
3f5d cd dc 1d			call macro_forth_dsp 
3f60				endm 
# End of macro FORTH_DSP
3f60					;v5 FORTH_DSP_VALUE 
3f60			 
3f60 7e					ld a, (hl) 
3f61			 
3f61 f5					push af 
3f62			 
3f62			; Dont destroy TOS		FORTH_DSP_POP 
3f62			 
3f62 f1					pop af 
3f63			 
3f63 fe 01				cp DS_TYPE_STR 
3f65 28 09				jr z, .typestr 
3f67			 
3f67 fe 02				cp DS_TYPE_INUM 
3f69 28 0a				jr z, .typeinum 
3f6b			 
3f6b 21 84 3f				ld hl, .tna 
3f6e 18 0a				jr .tpush 
3f70			 
3f70 21 80 3f		.typestr:	ld hl, .tstr 
3f73 18 05				jr .tpush 
3f75 21 82 3f		.typeinum:	ld hl, .tinum 
3f78 18 00				jr .tpush 
3f7a			 
3f7a			.tpush: 
3f7a			 
3f7a cd 8d 1c				call forth_push_str 
3f7d			 
3f7d					NEXTW 
3f7d c3 8d 1f			jp macro_next 
3f80				endm 
# End of macro NEXTW
3f80 .. 00		.tstr:	db "s",0 
3f82 .. 00		.tinum:  db "i",0 
3f84 .. 00		.tna:   db "?", 0 
3f86			 
3f86			 
3f86			.UPPER: 
3f86				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3f86 48				db WORD_SYS_CORE+52             
3f87 c1 3f			dw .LOWER            
3f89 06				db 5 + 1 
3f8a .. 00			db "UPPER",0              
3f90				endm 
# End of macro CWHEAD
3f90			; | UPPER ( s -- s ) Upper case string s  | DONE 
3f90					if DEBUG_FORTH_WORDS_KEY 
3f90						DMARK "UPR" 
3f90 f5				push af  
3f91 3a a5 3f			ld a, (.dmark)  
3f94 32 71 ee			ld (debug_mark),a  
3f97 3a a6 3f			ld a, (.dmark+1)  
3f9a 32 72 ee			ld (debug_mark+1),a  
3f9d 3a a7 3f			ld a, (.dmark+2)  
3fa0 32 73 ee			ld (debug_mark+2),a  
3fa3 18 03			jr .pastdmark  
3fa5 ..			.dmark: db "UPR"  
3fa8 f1			.pastdmark: pop af  
3fa9			endm  
# End of macro DMARK
3fa9						CALLMONITOR 
3fa9 cd ae 15			call break_point_state  
3fac				endm  
# End of macro CALLMONITOR
3fac					endif 
3fac			 
3fac					FORTH_DSP 
3fac cd dc 1d			call macro_forth_dsp 
3faf				endm 
# End of macro FORTH_DSP
3faf					 
3faf			; TODO check is string type 
3faf			 
3faf					FORTH_DSP_VALUEHL 
3faf cd 16 1e			call macro_dsp_valuehl 
3fb2				endm 
# End of macro FORTH_DSP_VALUEHL
3fb2			; get pointer to string in hl 
3fb2			 
3fb2 7e			.toup:		ld a, (hl) 
3fb3 fe 00				cp 0 
3fb5 28 07				jr z, .toupdone 
3fb7			 
3fb7 cd 1a 11				call to_upper 
3fba			 
3fba 77					ld (hl), a 
3fbb 23					inc hl 
3fbc 18 f4				jr .toup 
3fbe			 
3fbe					 
3fbe			 
3fbe			 
3fbe			; for each char convert to upper 
3fbe					 
3fbe			.toupdone: 
3fbe			 
3fbe			 
3fbe					NEXTW 
3fbe c3 8d 1f			jp macro_next 
3fc1				endm 
# End of macro NEXTW
3fc1			.LOWER: 
3fc1				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3fc1 48				db WORD_SYS_CORE+52             
3fc2 fc 3f			dw .TCASE            
3fc4 06				db 5 + 1 
3fc5 .. 00			db "LOWER",0              
3fcb				endm 
# End of macro CWHEAD
3fcb			; | LOWER ( s -- s ) Lower case string s  | DONE 
3fcb					if DEBUG_FORTH_WORDS_KEY 
3fcb						DMARK "LWR" 
3fcb f5				push af  
3fcc 3a e0 3f			ld a, (.dmark)  
3fcf 32 71 ee			ld (debug_mark),a  
3fd2 3a e1 3f			ld a, (.dmark+1)  
3fd5 32 72 ee			ld (debug_mark+1),a  
3fd8 3a e2 3f			ld a, (.dmark+2)  
3fdb 32 73 ee			ld (debug_mark+2),a  
3fde 18 03			jr .pastdmark  
3fe0 ..			.dmark: db "LWR"  
3fe3 f1			.pastdmark: pop af  
3fe4			endm  
# End of macro DMARK
3fe4						CALLMONITOR 
3fe4 cd ae 15			call break_point_state  
3fe7				endm  
# End of macro CALLMONITOR
3fe7					endif 
3fe7			 
3fe7					FORTH_DSP 
3fe7 cd dc 1d			call macro_forth_dsp 
3fea				endm 
# End of macro FORTH_DSP
3fea					 
3fea			; TODO check is string type 
3fea			 
3fea					FORTH_DSP_VALUEHL 
3fea cd 16 1e			call macro_dsp_valuehl 
3fed				endm 
# End of macro FORTH_DSP_VALUEHL
3fed			; get pointer to string in hl 
3fed			 
3fed 7e			.tolow:		ld a, (hl) 
3fee fe 00				cp 0 
3ff0 28 07				jr z, .tolowdone 
3ff2			 
3ff2 cd 23 11				call to_lower 
3ff5			 
3ff5 77					ld (hl), a 
3ff6 23					inc hl 
3ff7 18 f4				jr .tolow 
3ff9			 
3ff9					 
3ff9			 
3ff9			 
3ff9			; for each char convert to low 
3ff9					 
3ff9			.tolowdone: 
3ff9					NEXTW 
3ff9 c3 8d 1f			jp macro_next 
3ffc				endm 
# End of macro NEXTW
3ffc			.TCASE: 
3ffc				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3ffc 48				db WORD_SYS_CORE+52             
3ffd 32 41			dw .SUBSTR            
3fff 06				db 5 + 1 
4000 .. 00			db "TCASE",0              
4006				endm 
# End of macro CWHEAD
4006			; | TCASE ( s -- s ) Title case string s  | DONE 
4006					if DEBUG_FORTH_WORDS_KEY 
4006						DMARK "TCS" 
4006 f5				push af  
4007 3a 1b 40			ld a, (.dmark)  
400a 32 71 ee			ld (debug_mark),a  
400d 3a 1c 40			ld a, (.dmark+1)  
4010 32 72 ee			ld (debug_mark+1),a  
4013 3a 1d 40			ld a, (.dmark+2)  
4016 32 73 ee			ld (debug_mark+2),a  
4019 18 03			jr .pastdmark  
401b ..			.dmark: db "TCS"  
401e f1			.pastdmark: pop af  
401f			endm  
# End of macro DMARK
401f						CALLMONITOR 
401f cd ae 15			call break_point_state  
4022				endm  
# End of macro CALLMONITOR
4022					endif 
4022			 
4022					FORTH_DSP 
4022 cd dc 1d			call macro_forth_dsp 
4025				endm 
# End of macro FORTH_DSP
4025					 
4025			; TODO check is string type 
4025			 
4025					FORTH_DSP_VALUEHL 
4025 cd 16 1e			call macro_dsp_valuehl 
4028				endm 
# End of macro FORTH_DSP_VALUEHL
4028			; get pointer to string in hl 
4028			 
4028					if DEBUG_FORTH_WORDS 
4028						DMARK "TC1" 
4028 f5				push af  
4029 3a 3d 40			ld a, (.dmark)  
402c 32 71 ee			ld (debug_mark),a  
402f 3a 3e 40			ld a, (.dmark+1)  
4032 32 72 ee			ld (debug_mark+1),a  
4035 3a 3f 40			ld a, (.dmark+2)  
4038 32 73 ee			ld (debug_mark+2),a  
403b 18 03			jr .pastdmark  
403d ..			.dmark: db "TC1"  
4040 f1			.pastdmark: pop af  
4041			endm  
# End of macro DMARK
4041						CALLMONITOR 
4041 cd ae 15			call break_point_state  
4044				endm  
# End of macro CALLMONITOR
4044					endif 
4044			 
4044					; first time in turn to upper case first char 
4044			 
4044 7e					ld a, (hl) 
4045 c3 cf 40				jp .totsiptou 
4048			 
4048			 
4048 7e			.tot:		ld a, (hl) 
4049 fe 00				cp 0 
404b ca 13 41				jp z, .totdone 
404e			 
404e					if DEBUG_FORTH_WORDS 
404e						DMARK "TC2" 
404e f5				push af  
404f 3a 63 40			ld a, (.dmark)  
4052 32 71 ee			ld (debug_mark),a  
4055 3a 64 40			ld a, (.dmark+1)  
4058 32 72 ee			ld (debug_mark+1),a  
405b 3a 65 40			ld a, (.dmark+2)  
405e 32 73 ee			ld (debug_mark+2),a  
4061 18 03			jr .pastdmark  
4063 ..			.dmark: db "TC2"  
4066 f1			.pastdmark: pop af  
4067			endm  
# End of macro DMARK
4067						CALLMONITOR 
4067 cd ae 15			call break_point_state  
406a				endm  
# End of macro CALLMONITOR
406a					endif 
406a					; check to see if current char is a space 
406a			 
406a fe 20				cp ' ' 
406c 28 21				jr z, .totsp 
406e cd 23 11				call to_lower 
4071					if DEBUG_FORTH_WORDS 
4071						DMARK "TC3" 
4071 f5				push af  
4072 3a 86 40			ld a, (.dmark)  
4075 32 71 ee			ld (debug_mark),a  
4078 3a 87 40			ld a, (.dmark+1)  
407b 32 72 ee			ld (debug_mark+1),a  
407e 3a 88 40			ld a, (.dmark+2)  
4081 32 73 ee			ld (debug_mark+2),a  
4084 18 03			jr .pastdmark  
4086 ..			.dmark: db "TC3"  
4089 f1			.pastdmark: pop af  
408a			endm  
# End of macro DMARK
408a						CALLMONITOR 
408a cd ae 15			call break_point_state  
408d				endm  
# End of macro CALLMONITOR
408d					endif 
408d 18 63				jr .totnxt 
408f			 
408f			.totsp:         ; on a space, find next char which should be upper 
408f			 
408f					if DEBUG_FORTH_WORDS 
408f						DMARK "TC4" 
408f f5				push af  
4090 3a a4 40			ld a, (.dmark)  
4093 32 71 ee			ld (debug_mark),a  
4096 3a a5 40			ld a, (.dmark+1)  
4099 32 72 ee			ld (debug_mark+1),a  
409c 3a a6 40			ld a, (.dmark+2)  
409f 32 73 ee			ld (debug_mark+2),a  
40a2 18 03			jr .pastdmark  
40a4 ..			.dmark: db "TC4"  
40a7 f1			.pastdmark: pop af  
40a8			endm  
# End of macro DMARK
40a8						CALLMONITOR 
40a8 cd ae 15			call break_point_state  
40ab				endm  
# End of macro CALLMONITOR
40ab					endif 
40ab					;; 
40ab			 
40ab fe 20				cp ' ' 
40ad 20 20				jr nz, .totsiptou 
40af 23					inc hl 
40b0 7e					ld a, (hl) 
40b1					if DEBUG_FORTH_WORDS 
40b1						DMARK "TC5" 
40b1 f5				push af  
40b2 3a c6 40			ld a, (.dmark)  
40b5 32 71 ee			ld (debug_mark),a  
40b8 3a c7 40			ld a, (.dmark+1)  
40bb 32 72 ee			ld (debug_mark+1),a  
40be 3a c8 40			ld a, (.dmark+2)  
40c1 32 73 ee			ld (debug_mark+2),a  
40c4 18 03			jr .pastdmark  
40c6 ..			.dmark: db "TC5"  
40c9 f1			.pastdmark: pop af  
40ca			endm  
# End of macro DMARK
40ca						CALLMONITOR 
40ca cd ae 15			call break_point_state  
40cd				endm  
# End of macro CALLMONITOR
40cd					endif 
40cd 18 c0				jr .totsp 
40cf fe 00		.totsiptou:    cp 0 
40d1 28 40				jr z, .totdone 
40d3					; not space and not zero term so upper case it 
40d3 cd 1a 11				call to_upper 
40d6			 
40d6					if DEBUG_FORTH_WORDS 
40d6						DMARK "TC6" 
40d6 f5				push af  
40d7 3a eb 40			ld a, (.dmark)  
40da 32 71 ee			ld (debug_mark),a  
40dd 3a ec 40			ld a, (.dmark+1)  
40e0 32 72 ee			ld (debug_mark+1),a  
40e3 3a ed 40			ld a, (.dmark+2)  
40e6 32 73 ee			ld (debug_mark+2),a  
40e9 18 03			jr .pastdmark  
40eb ..			.dmark: db "TC6"  
40ee f1			.pastdmark: pop af  
40ef			endm  
# End of macro DMARK
40ef						CALLMONITOR 
40ef cd ae 15			call break_point_state  
40f2				endm  
# End of macro CALLMONITOR
40f2					endif 
40f2			 
40f2			 
40f2			.totnxt: 
40f2			 
40f2 77					ld (hl), a 
40f3 23					inc hl 
40f4					if DEBUG_FORTH_WORDS 
40f4						DMARK "TC7" 
40f4 f5				push af  
40f5 3a 09 41			ld a, (.dmark)  
40f8 32 71 ee			ld (debug_mark),a  
40fb 3a 0a 41			ld a, (.dmark+1)  
40fe 32 72 ee			ld (debug_mark+1),a  
4101 3a 0b 41			ld a, (.dmark+2)  
4104 32 73 ee			ld (debug_mark+2),a  
4107 18 03			jr .pastdmark  
4109 ..			.dmark: db "TC7"  
410c f1			.pastdmark: pop af  
410d			endm  
# End of macro DMARK
410d						CALLMONITOR 
410d cd ae 15			call break_point_state  
4110				endm  
# End of macro CALLMONITOR
4110					endif 
4110 c3 48 40				jp .tot 
4113			 
4113					 
4113			 
4113			 
4113			; for each char convert to low 
4113					 
4113			.totdone: 
4113					if DEBUG_FORTH_WORDS 
4113						DMARK "TCd" 
4113 f5				push af  
4114 3a 28 41			ld a, (.dmark)  
4117 32 71 ee			ld (debug_mark),a  
411a 3a 29 41			ld a, (.dmark+1)  
411d 32 72 ee			ld (debug_mark+1),a  
4120 3a 2a 41			ld a, (.dmark+2)  
4123 32 73 ee			ld (debug_mark+2),a  
4126 18 03			jr .pastdmark  
4128 ..			.dmark: db "TCd"  
412b f1			.pastdmark: pop af  
412c			endm  
# End of macro DMARK
412c						CALLMONITOR 
412c cd ae 15			call break_point_state  
412f				endm  
# End of macro CALLMONITOR
412f					endif 
412f					NEXTW 
412f c3 8d 1f			jp macro_next 
4132				endm 
# End of macro NEXTW
4132			 
4132			.SUBSTR: 
4132				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4132 48				db WORD_SYS_CORE+52             
4133 90 41			dw .LEFT            
4135 07				db 6 + 1 
4136 .. 00			db "SUBSTR",0              
413d				endm 
# End of macro CWHEAD
413d			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
413d			 
413d					if DEBUG_FORTH_WORDS_KEY 
413d						DMARK "SST" 
413d f5				push af  
413e 3a 52 41			ld a, (.dmark)  
4141 32 71 ee			ld (debug_mark),a  
4144 3a 53 41			ld a, (.dmark+1)  
4147 32 72 ee			ld (debug_mark+1),a  
414a 3a 54 41			ld a, (.dmark+2)  
414d 32 73 ee			ld (debug_mark+2),a  
4150 18 03			jr .pastdmark  
4152 ..			.dmark: db "SST"  
4155 f1			.pastdmark: pop af  
4156			endm  
# End of macro DMARK
4156						CALLMONITOR 
4156 cd ae 15			call break_point_state  
4159				endm  
# End of macro CALLMONITOR
4159					endif 
4159			; TODO check string type 
4159					FORTH_DSP_VALUEHL 
4159 cd 16 1e			call macro_dsp_valuehl 
415c				endm 
# End of macro FORTH_DSP_VALUEHL
415c			 
415c e5					push hl      ; string length 
415d			 
415d					FORTH_DSP_POP 
415d cd ce 1e			call macro_forth_dsp_pop 
4160				endm 
# End of macro FORTH_DSP_POP
4160			 
4160					FORTH_DSP_VALUEHL 
4160 cd 16 1e			call macro_dsp_valuehl 
4163				endm 
# End of macro FORTH_DSP_VALUEHL
4163			 
4163 e5					push hl     ; start char 
4164			 
4164					FORTH_DSP_POP 
4164 cd ce 1e			call macro_forth_dsp_pop 
4167				endm 
# End of macro FORTH_DSP_POP
4167			 
4167			 
4167					FORTH_DSP_VALUE 
4167 cd ff 1d			call macro_forth_dsp_value 
416a				endm 
# End of macro FORTH_DSP_VALUE
416a			 
416a d1					pop de    ; get start post offset 
416b			 
416b 19					add hl, de    ; starting offset 
416c			 
416c c1					pop bc 
416d c5					push bc      ; grab size of string 
416e			 
416e e5					push hl    ; save string start  
416f			 
416f 26 00				ld h, 0 
4171 69					ld l, c 
4172 23					inc hl 
4173 23					inc hl 
4174			 
4174 cd 74 12				call malloc 
4177				if DEBUG_FORTH_MALLOC_GUARD 
4177 cc 2f 48				call z,malloc_error 
417a				endif 
417a			 
417a eb					ex de, hl      ; save malloc area for string copy 
417b e1					pop hl    ; get back source 
417c c1					pop bc    ; get length of string back 
417d			 
417d d5					push de    ; save malloc area for after we push 
417e ed b0				ldir     ; copy substr 
4180			 
4180			 
4180 eb					ex de, hl 
4181 3e 00				ld a, 0 
4183 77					ld (hl), a   ; term substr 
4184			 
4184					 
4184 e1					pop hl    ; get malloc so we can push it 
4185 e5					push hl   ; save so we can free it afterwards 
4186			 
4186 cd 8d 1c				call forth_push_str 
4189			 
4189 e1					pop hl 
418a cd 3e 13				call free 
418d			 
418d					 
418d					 
418d			 
418d			 
418d					NEXTW 
418d c3 8d 1f			jp macro_next 
4190				endm 
# End of macro NEXTW
4190			 
4190			.LEFT: 
4190				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4190 48				db WORD_SYS_CORE+52             
4191 b8 41			dw .RIGHT            
4193 05				db 4 + 1 
4194 .. 00			db "LEFT",0              
4199				endm 
# End of macro CWHEAD
4199			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4199					if DEBUG_FORTH_WORDS_KEY 
4199						DMARK "LEF" 
4199 f5				push af  
419a 3a ae 41			ld a, (.dmark)  
419d 32 71 ee			ld (debug_mark),a  
41a0 3a af 41			ld a, (.dmark+1)  
41a3 32 72 ee			ld (debug_mark+1),a  
41a6 3a b0 41			ld a, (.dmark+2)  
41a9 32 73 ee			ld (debug_mark+2),a  
41ac 18 03			jr .pastdmark  
41ae ..			.dmark: db "LEF"  
41b1 f1			.pastdmark: pop af  
41b2			endm  
# End of macro DMARK
41b2						CALLMONITOR 
41b2 cd ae 15			call break_point_state  
41b5				endm  
# End of macro CALLMONITOR
41b5					endif 
41b5			 
41b5					NEXTW 
41b5 c3 8d 1f			jp macro_next 
41b8				endm 
# End of macro NEXTW
41b8			.RIGHT: 
41b8				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
41b8 48				db WORD_SYS_CORE+52             
41b9 e1 41			dw .STR2NUM            
41bb 06				db 5 + 1 
41bc .. 00			db "RIGHT",0              
41c2				endm 
# End of macro CWHEAD
41c2			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
41c2					if DEBUG_FORTH_WORDS_KEY 
41c2						DMARK "RIG" 
41c2 f5				push af  
41c3 3a d7 41			ld a, (.dmark)  
41c6 32 71 ee			ld (debug_mark),a  
41c9 3a d8 41			ld a, (.dmark+1)  
41cc 32 72 ee			ld (debug_mark+1),a  
41cf 3a d9 41			ld a, (.dmark+2)  
41d2 32 73 ee			ld (debug_mark+2),a  
41d5 18 03			jr .pastdmark  
41d7 ..			.dmark: db "RIG"  
41da f1			.pastdmark: pop af  
41db			endm  
# End of macro DMARK
41db						CALLMONITOR 
41db cd ae 15			call break_point_state  
41de				endm  
# End of macro CALLMONITOR
41de					endif 
41de			 
41de					NEXTW 
41de c3 8d 1f			jp macro_next 
41e1				endm 
# End of macro NEXTW
41e1			 
41e1			 
41e1			.STR2NUM: 
41e1				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
41e1 48				db WORD_SYS_CORE+52             
41e2 6d 42			dw .NUM2STR            
41e4 08				db 7 + 1 
41e5 .. 00			db "STR2NUM",0              
41ed				endm 
# End of macro CWHEAD
41ed			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
41ed			 
41ed			 
41ed			; TODO STR type check to do 
41ed					if DEBUG_FORTH_WORDS_KEY 
41ed						DMARK "S2N" 
41ed f5				push af  
41ee 3a 02 42			ld a, (.dmark)  
41f1 32 71 ee			ld (debug_mark),a  
41f4 3a 03 42			ld a, (.dmark+1)  
41f7 32 72 ee			ld (debug_mark+1),a  
41fa 3a 04 42			ld a, (.dmark+2)  
41fd 32 73 ee			ld (debug_mark+2),a  
4200 18 03			jr .pastdmark  
4202 ..			.dmark: db "S2N"  
4205 f1			.pastdmark: pop af  
4206			endm  
# End of macro DMARK
4206						CALLMONITOR 
4206 cd ae 15			call break_point_state  
4209				endm  
# End of macro CALLMONITOR
4209					endif 
4209			 
4209					;FORTH_DSP 
4209					FORTH_DSP_VALUE 
4209 cd ff 1d			call macro_forth_dsp_value 
420c				endm 
# End of macro FORTH_DSP_VALUE
420c					;inc hl 
420c			 
420c eb					ex de, hl 
420d					if DEBUG_FORTH_WORDS 
420d						DMARK "S2a" 
420d f5				push af  
420e 3a 22 42			ld a, (.dmark)  
4211 32 71 ee			ld (debug_mark),a  
4214 3a 23 42			ld a, (.dmark+1)  
4217 32 72 ee			ld (debug_mark+1),a  
421a 3a 24 42			ld a, (.dmark+2)  
421d 32 73 ee			ld (debug_mark+2),a  
4220 18 03			jr .pastdmark  
4222 ..			.dmark: db "S2a"  
4225 f1			.pastdmark: pop af  
4226			endm  
# End of macro DMARK
4226						CALLMONITOR 
4226 cd ae 15			call break_point_state  
4229				endm  
# End of macro CALLMONITOR
4229					endif 
4229 cd a2 11				call string_to_uint16 
422c			 
422c					if DEBUG_FORTH_WORDS 
422c						DMARK "S2b" 
422c f5				push af  
422d 3a 41 42			ld a, (.dmark)  
4230 32 71 ee			ld (debug_mark),a  
4233 3a 42 42			ld a, (.dmark+1)  
4236 32 72 ee			ld (debug_mark+1),a  
4239 3a 43 42			ld a, (.dmark+2)  
423c 32 73 ee			ld (debug_mark+2),a  
423f 18 03			jr .pastdmark  
4241 ..			.dmark: db "S2b"  
4244 f1			.pastdmark: pop af  
4245			endm  
# End of macro DMARK
4245						CALLMONITOR 
4245 cd ae 15			call break_point_state  
4248				endm  
# End of macro CALLMONITOR
4248					endif 
4248			;		push hl 
4248					FORTH_DSP_POP 
4248 cd ce 1e			call macro_forth_dsp_pop 
424b				endm 
# End of macro FORTH_DSP_POP
424b			;		pop hl 
424b					 
424b					if DEBUG_FORTH_WORDS 
424b						DMARK "S2b" 
424b f5				push af  
424c 3a 60 42			ld a, (.dmark)  
424f 32 71 ee			ld (debug_mark),a  
4252 3a 61 42			ld a, (.dmark+1)  
4255 32 72 ee			ld (debug_mark+1),a  
4258 3a 62 42			ld a, (.dmark+2)  
425b 32 73 ee			ld (debug_mark+2),a  
425e 18 03			jr .pastdmark  
4260 ..			.dmark: db "S2b"  
4263 f1			.pastdmark: pop af  
4264			endm  
# End of macro DMARK
4264						CALLMONITOR 
4264 cd ae 15			call break_point_state  
4267				endm  
# End of macro CALLMONITOR
4267					endif 
4267 cd 1f 1c				call forth_push_numhl	 
426a			 
426a				 
426a				       NEXTW 
426a c3 8d 1f			jp macro_next 
426d				endm 
# End of macro NEXTW
426d			.NUM2STR: 
426d				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
426d 48				db WORD_SYS_CORE+52             
426e 7c 42			dw .CONCAT            
4270 08				db 7 + 1 
4271 .. 00			db "NUM2STR",0              
4279				endm 
# End of macro CWHEAD
4279			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4279			 
4279			;		; malloc a string to target 
4279			;		ld hl, 10     ; TODO max string size should be fine 
4279			;		call malloc 
4279			;		push hl    ; save malloc location 
4279			; 
4279			; 
4279			;; TODO check int type 
4279			;		FORTH_DSP_VALUEHL 
4279			;		ld a, l 
4279			;		call DispAToASCII   
4279			;;TODO need to chage above call to dump into string 
4279			; 
4279			; 
4279			 
4279				       NEXTW 
4279 c3 8d 1f			jp macro_next 
427c				endm 
# End of macro NEXTW
427c			 
427c			.CONCAT: 
427c				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
427c 48				db WORD_SYS_CORE+52             
427d 2f 43			dw .FIND            
427f 07				db 6 + 1 
4280 .. 00			db "CONCAT",0              
4287				endm 
# End of macro CWHEAD
4287			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4287			 
4287			; TODO check string type 
4287			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4287			 
4287					if DEBUG_FORTH_WORDS_KEY 
4287						DMARK "CON" 
4287 f5				push af  
4288 3a 9c 42			ld a, (.dmark)  
428b 32 71 ee			ld (debug_mark),a  
428e 3a 9d 42			ld a, (.dmark+1)  
4291 32 72 ee			ld (debug_mark+1),a  
4294 3a 9e 42			ld a, (.dmark+2)  
4297 32 73 ee			ld (debug_mark+2),a  
429a 18 03			jr .pastdmark  
429c ..			.dmark: db "CON"  
429f f1			.pastdmark: pop af  
42a0			endm  
# End of macro DMARK
42a0						CALLMONITOR 
42a0 cd ae 15			call break_point_state  
42a3				endm  
# End of macro CALLMONITOR
42a3					endif 
42a3			 
42a3			 
42a3					FORTH_DSP_VALUE 
42a3 cd ff 1d			call macro_forth_dsp_value 
42a6				endm 
# End of macro FORTH_DSP_VALUE
42a6 e5					push hl   ; s2 
42a7			 
42a7					FORTH_DSP_POP 
42a7 cd ce 1e			call macro_forth_dsp_pop 
42aa				endm 
# End of macro FORTH_DSP_POP
42aa			 
42aa					FORTH_DSP_VALUE 
42aa cd ff 1d			call macro_forth_dsp_value 
42ad				endm 
# End of macro FORTH_DSP_VALUE
42ad			 
42ad e5					push hl   ; s1 
42ae			 
42ae					FORTH_DSP_POP 
42ae cd ce 1e			call macro_forth_dsp_pop 
42b1				endm 
# End of macro FORTH_DSP_POP
42b1					 
42b1			 
42b1					; copy s1 
42b1			 
42b1				 
42b1					; save ptr 
42b1 e1					pop hl  
42b2 e5					push hl 
42b3 3e 00				ld a, 0 
42b5 cd 16 12				call strlent 
42b8					;inc hl    ; zer0 
42b8 06 00				ld b, 0 
42ba 4d					ld c, l 
42bb e1					pop hl		 
42bc 11 ff e2				ld de, scratch	 
42bf					if DEBUG_FORTH_WORDS 
42bf						DMARK "CO1" 
42bf f5				push af  
42c0 3a d4 42			ld a, (.dmark)  
42c3 32 71 ee			ld (debug_mark),a  
42c6 3a d5 42			ld a, (.dmark+1)  
42c9 32 72 ee			ld (debug_mark+1),a  
42cc 3a d6 42			ld a, (.dmark+2)  
42cf 32 73 ee			ld (debug_mark+2),a  
42d2 18 03			jr .pastdmark  
42d4 ..			.dmark: db "CO1"  
42d7 f1			.pastdmark: pop af  
42d8			endm  
# End of macro DMARK
42d8						CALLMONITOR 
42d8 cd ae 15			call break_point_state  
42db				endm  
# End of macro CALLMONITOR
42db					endif 
42db ed b0				ldir 
42dd			 
42dd e1					pop hl 
42de e5					push hl 
42df d5					push de 
42e0			 
42e0			 
42e0 3e 00				ld a, 0 
42e2 cd 16 12				call strlent 
42e5 23					inc hl    ; zer0 
42e6 23					inc hl 
42e7 06 00				ld b, 0 
42e9 4d					ld c, l 
42ea d1					pop de 
42eb e1					pop hl		 
42ec					if DEBUG_FORTH_WORDS 
42ec						DMARK "CO2" 
42ec f5				push af  
42ed 3a 01 43			ld a, (.dmark)  
42f0 32 71 ee			ld (debug_mark),a  
42f3 3a 02 43			ld a, (.dmark+1)  
42f6 32 72 ee			ld (debug_mark+1),a  
42f9 3a 03 43			ld a, (.dmark+2)  
42fc 32 73 ee			ld (debug_mark+2),a  
42ff 18 03			jr .pastdmark  
4301 ..			.dmark: db "CO2"  
4304 f1			.pastdmark: pop af  
4305			endm  
# End of macro DMARK
4305						CALLMONITOR 
4305 cd ae 15			call break_point_state  
4308				endm  
# End of macro CALLMONITOR
4308					endif 
4308 ed b0				ldir 
430a			 
430a			 
430a			 
430a 21 ff e2				ld hl, scratch 
430d					if DEBUG_FORTH_WORDS 
430d						DMARK "CO5" 
430d f5				push af  
430e 3a 22 43			ld a, (.dmark)  
4311 32 71 ee			ld (debug_mark),a  
4314 3a 23 43			ld a, (.dmark+1)  
4317 32 72 ee			ld (debug_mark+1),a  
431a 3a 24 43			ld a, (.dmark+2)  
431d 32 73 ee			ld (debug_mark+2),a  
4320 18 03			jr .pastdmark  
4322 ..			.dmark: db "CO5"  
4325 f1			.pastdmark: pop af  
4326			endm  
# End of macro DMARK
4326						CALLMONITOR 
4326 cd ae 15			call break_point_state  
4329				endm  
# End of macro CALLMONITOR
4329					endif 
4329			 
4329 cd 8d 1c				call forth_push_str 
432c			 
432c			 
432c			 
432c			 
432c				       NEXTW 
432c c3 8d 1f			jp macro_next 
432f				endm 
# End of macro NEXTW
432f			 
432f			 
432f			.FIND: 
432f				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
432f 4b				db WORD_SYS_CORE+55             
4330 ed 43			dw .LEN            
4332 05				db 4 + 1 
4333 .. 00			db "FIND",0              
4338				endm 
# End of macro CWHEAD
4338			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4338			 
4338					if DEBUG_FORTH_WORDS_KEY 
4338						DMARK "FND" 
4338 f5				push af  
4339 3a 4d 43			ld a, (.dmark)  
433c 32 71 ee			ld (debug_mark),a  
433f 3a 4e 43			ld a, (.dmark+1)  
4342 32 72 ee			ld (debug_mark+1),a  
4345 3a 4f 43			ld a, (.dmark+2)  
4348 32 73 ee			ld (debug_mark+2),a  
434b 18 03			jr .pastdmark  
434d ..			.dmark: db "FND"  
4350 f1			.pastdmark: pop af  
4351			endm  
# End of macro DMARK
4351						CALLMONITOR 
4351 cd ae 15			call break_point_state  
4354				endm  
# End of macro CALLMONITOR
4354					endif 
4354			 
4354			; TODO check string type 
4354					FORTH_DSP_VALUE 
4354 cd ff 1d			call macro_forth_dsp_value 
4357				endm 
# End of macro FORTH_DSP_VALUE
4357			 
4357 e5					push hl    
4358 7e					ld a,(hl)    ; char to find   
4359			; TODO change char to substr 
4359			 
4359 f5					push af 
435a					 
435a			 
435a			 
435a					if DEBUG_FORTH_WORDS 
435a						DMARK "FN1" 
435a f5				push af  
435b 3a 6f 43			ld a, (.dmark)  
435e 32 71 ee			ld (debug_mark),a  
4361 3a 70 43			ld a, (.dmark+1)  
4364 32 72 ee			ld (debug_mark+1),a  
4367 3a 71 43			ld a, (.dmark+2)  
436a 32 73 ee			ld (debug_mark+2),a  
436d 18 03			jr .pastdmark  
436f ..			.dmark: db "FN1"  
4372 f1			.pastdmark: pop af  
4373			endm  
# End of macro DMARK
4373						CALLMONITOR 
4373 cd ae 15			call break_point_state  
4376				endm  
# End of macro CALLMONITOR
4376					endif 
4376			 
4376					FORTH_DSP_POP 
4376 cd ce 1e			call macro_forth_dsp_pop 
4379				endm 
# End of macro FORTH_DSP_POP
4379			 
4379					; string to search 
4379			 
4379					FORTH_DSP_VALUE 
4379 cd ff 1d			call macro_forth_dsp_value 
437c				endm 
# End of macro FORTH_DSP_VALUE
437c			 
437c d1					pop de  ; d is char to find  
437d			 
437d					if DEBUG_FORTH_WORDS 
437d						DMARK "FN2" 
437d f5				push af  
437e 3a 92 43			ld a, (.dmark)  
4381 32 71 ee			ld (debug_mark),a  
4384 3a 93 43			ld a, (.dmark+1)  
4387 32 72 ee			ld (debug_mark+1),a  
438a 3a 94 43			ld a, (.dmark+2)  
438d 32 73 ee			ld (debug_mark+2),a  
4390 18 03			jr .pastdmark  
4392 ..			.dmark: db "FN2"  
4395 f1			.pastdmark: pop af  
4396			endm  
# End of macro DMARK
4396						CALLMONITOR 
4396 cd ae 15			call break_point_state  
4399				endm  
# End of macro CALLMONITOR
4399					endif 
4399					 
4399 01 00 00				ld bc, 0 
439c 7e			.findchar:      ld a,(hl) 
439d fe 00				cp 0   		 
439f 28 27				jr z, .finddone     
43a1 ba					cp d 
43a2 28 20				jr z, .foundchar 
43a4 03					inc bc 
43a5 23					inc hl 
43a6					if DEBUG_FORTH_WORDS 
43a6						DMARK "FN3" 
43a6 f5				push af  
43a7 3a bb 43			ld a, (.dmark)  
43aa 32 71 ee			ld (debug_mark),a  
43ad 3a bc 43			ld a, (.dmark+1)  
43b0 32 72 ee			ld (debug_mark+1),a  
43b3 3a bd 43			ld a, (.dmark+2)  
43b6 32 73 ee			ld (debug_mark+2),a  
43b9 18 03			jr .pastdmark  
43bb ..			.dmark: db "FN3"  
43be f1			.pastdmark: pop af  
43bf			endm  
# End of macro DMARK
43bf						CALLMONITOR 
43bf cd ae 15			call break_point_state  
43c2				endm  
# End of macro CALLMONITOR
43c2					endif 
43c2 18 d8				jr .findchar 
43c4			 
43c4			 
43c4 c5			.foundchar:	push bc 
43c5 e1					pop hl 
43c6 18 03				jr .findexit 
43c8			 
43c8			 
43c8							 
43c8			 
43c8			.finddone:     ; got to end of string with no find 
43c8 21 00 00				ld hl, 0 
43cb			.findexit: 
43cb			 
43cb					if DEBUG_FORTH_WORDS 
43cb						DMARK "FNd" 
43cb f5				push af  
43cc 3a e0 43			ld a, (.dmark)  
43cf 32 71 ee			ld (debug_mark),a  
43d2 3a e1 43			ld a, (.dmark+1)  
43d5 32 72 ee			ld (debug_mark+1),a  
43d8 3a e2 43			ld a, (.dmark+2)  
43db 32 73 ee			ld (debug_mark+2),a  
43de 18 03			jr .pastdmark  
43e0 ..			.dmark: db "FNd"  
43e3 f1			.pastdmark: pop af  
43e4			endm  
# End of macro DMARK
43e4						CALLMONITOR 
43e4 cd ae 15			call break_point_state  
43e7				endm  
# End of macro CALLMONITOR
43e7					endif 
43e7 cd 1f 1c			call forth_push_numhl 
43ea			 
43ea				       NEXTW 
43ea c3 8d 1f			jp macro_next 
43ed				endm 
# End of macro NEXTW
43ed			 
43ed			.LEN: 
43ed				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
43ed 4c				db WORD_SYS_CORE+56             
43ee 57 44			dw .ASC            
43f0 06				db 5 + 1 
43f1 .. 00			db "COUNT",0              
43f7				endm 
# End of macro CWHEAD
43f7			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
43f7			 
43f7					if DEBUG_FORTH_WORDS_KEY 
43f7						DMARK "CNT" 
43f7 f5				push af  
43f8 3a 0c 44			ld a, (.dmark)  
43fb 32 71 ee			ld (debug_mark),a  
43fe 3a 0d 44			ld a, (.dmark+1)  
4401 32 72 ee			ld (debug_mark+1),a  
4404 3a 0e 44			ld a, (.dmark+2)  
4407 32 73 ee			ld (debug_mark+2),a  
440a 18 03			jr .pastdmark  
440c ..			.dmark: db "CNT"  
440f f1			.pastdmark: pop af  
4410			endm  
# End of macro DMARK
4410						CALLMONITOR 
4410 cd ae 15			call break_point_state  
4413				endm  
# End of macro CALLMONITOR
4413					endif 
4413			; TODO check string type 
4413					FORTH_DSP_VALUE 
4413 cd ff 1d			call macro_forth_dsp_value 
4416				endm 
# End of macro FORTH_DSP_VALUE
4416			 
4416			 
4416					if DEBUG_FORTH_WORDS 
4416						DMARK "CN?" 
4416 f5				push af  
4417 3a 2b 44			ld a, (.dmark)  
441a 32 71 ee			ld (debug_mark),a  
441d 3a 2c 44			ld a, (.dmark+1)  
4420 32 72 ee			ld (debug_mark+1),a  
4423 3a 2d 44			ld a, (.dmark+2)  
4426 32 73 ee			ld (debug_mark+2),a  
4429 18 03			jr .pastdmark  
442b ..			.dmark: db "CN?"  
442e f1			.pastdmark: pop af  
442f			endm  
# End of macro DMARK
442f						CALLMONITOR 
442f cd ae 15			call break_point_state  
4432				endm  
# End of macro CALLMONITOR
4432					endif 
4432 cd 0b 12				call strlenz 
4435					if DEBUG_FORTH_WORDS 
4435						DMARK "CNl" 
4435 f5				push af  
4436 3a 4a 44			ld a, (.dmark)  
4439 32 71 ee			ld (debug_mark),a  
443c 3a 4b 44			ld a, (.dmark+1)  
443f 32 72 ee			ld (debug_mark+1),a  
4442 3a 4c 44			ld a, (.dmark+2)  
4445 32 73 ee			ld (debug_mark+2),a  
4448 18 03			jr .pastdmark  
444a ..			.dmark: db "CNl"  
444d f1			.pastdmark: pop af  
444e			endm  
# End of macro DMARK
444e						CALLMONITOR 
444e cd ae 15			call break_point_state  
4451				endm  
# End of macro CALLMONITOR
4451					endif 
4451			 
4451 cd 1f 1c				call forth_push_numhl 
4454			 
4454			 
4454			 
4454				       NEXTW 
4454 c3 8d 1f			jp macro_next 
4457				endm 
# End of macro NEXTW
4457			.ASC: 
4457				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4457 4d				db WORD_SYS_CORE+57             
4458 8c 44			dw .CHR            
445a 04				db 3 + 1 
445b .. 00			db "ASC",0              
445f				endm 
# End of macro CWHEAD
445f			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
445f					if DEBUG_FORTH_WORDS_KEY 
445f						DMARK "ASC" 
445f f5				push af  
4460 3a 74 44			ld a, (.dmark)  
4463 32 71 ee			ld (debug_mark),a  
4466 3a 75 44			ld a, (.dmark+1)  
4469 32 72 ee			ld (debug_mark+1),a  
446c 3a 76 44			ld a, (.dmark+2)  
446f 32 73 ee			ld (debug_mark+2),a  
4472 18 03			jr .pastdmark  
4474 ..			.dmark: db "ASC"  
4477 f1			.pastdmark: pop af  
4478			endm  
# End of macro DMARK
4478						CALLMONITOR 
4478 cd ae 15			call break_point_state  
447b				endm  
# End of macro CALLMONITOR
447b					endif 
447b					FORTH_DSP 
447b cd dc 1d			call macro_forth_dsp 
447e				endm 
# End of macro FORTH_DSP
447e					;v5 FORTH_DSP_VALUE 
447e 23					inc hl      ; now at start of numeric as string 
447f			 
447f			;		push hl 
447f			 
447f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
447f cd ce 1e			call macro_forth_dsp_pop 
4482				endm 
# End of macro FORTH_DSP_POP
4482			 
4482			;		pop hl 
4482			 
4482					; push the content of a onto the stack as a value 
4482			 
4482 7e					ld a,(hl)   ; get char 
4483 26 00				ld h,0 
4485 6f					ld l,a 
4486 cd 1f 1c				call forth_push_numhl 
4489			 
4489				       NEXTW 
4489 c3 8d 1f			jp macro_next 
448c				endm 
# End of macro NEXTW
448c			 
448c			.CHR: 
448c				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
448c 4d				db WORD_SYS_CORE+57             
448d c8 44			dw .ENDSTR            
448f 04				db 3 + 1 
4490 .. 00			db "CHR",0              
4494				endm 
# End of macro CWHEAD
4494			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4494					if DEBUG_FORTH_WORDS_KEY 
4494						DMARK "CHR" 
4494 f5				push af  
4495 3a a9 44			ld a, (.dmark)  
4498 32 71 ee			ld (debug_mark),a  
449b 3a aa 44			ld a, (.dmark+1)  
449e 32 72 ee			ld (debug_mark+1),a  
44a1 3a ab 44			ld a, (.dmark+2)  
44a4 32 73 ee			ld (debug_mark+2),a  
44a7 18 03			jr .pastdmark  
44a9 ..			.dmark: db "CHR"  
44ac f1			.pastdmark: pop af  
44ad			endm  
# End of macro DMARK
44ad						CALLMONITOR 
44ad cd ae 15			call break_point_state  
44b0				endm  
# End of macro CALLMONITOR
44b0					endif 
44b0					FORTH_DSP_VALUEHL 
44b0 cd 16 1e			call macro_dsp_valuehl 
44b3				endm 
# End of macro FORTH_DSP_VALUEHL
44b3			 
44b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44b3 cd ce 1e			call macro_forth_dsp_pop 
44b6				endm 
# End of macro FORTH_DSP_POP
44b6			 
44b6					; save asci byte as a zero term string and push string 
44b6			 
44b6 7d					ld a,l 
44b7 32 ff e2				ld (scratch), a 
44ba			 
44ba 3e 00				ld a, 0 
44bc 32 00 e3				ld (scratch+1), a 
44bf			 
44bf 21 ff e2				ld hl, scratch 
44c2 cd 8d 1c				call forth_push_str 
44c5			 
44c5			 
44c5				       NEXTW 
44c5 c3 8d 1f			jp macro_next 
44c8				endm 
# End of macro NEXTW
44c8			 
44c8			 
44c8			 
44c8			 
44c8			.ENDSTR: 
44c8			; eof 
44c8			 
# End of file forth_words_str.asm
44c8			include "forth_words_key.asm" 
44c8			 
44c8			; | ## Keyboard Words 
44c8			 
44c8			.KEY: 
44c8				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
44c8 3e				db WORD_SYS_CORE+42             
44c9 f8 44			dw .WAITK            
44cb 04				db 3 + 1 
44cc .. 00			db "KEY",0              
44d0				endm 
# End of macro CWHEAD
44d0			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
44d0			 
44d0					if DEBUG_FORTH_WORDS_KEY 
44d0						DMARK "KEY" 
44d0 f5				push af  
44d1 3a e5 44			ld a, (.dmark)  
44d4 32 71 ee			ld (debug_mark),a  
44d7 3a e6 44			ld a, (.dmark+1)  
44da 32 72 ee			ld (debug_mark+1),a  
44dd 3a e7 44			ld a, (.dmark+2)  
44e0 32 73 ee			ld (debug_mark+2),a  
44e3 18 03			jr .pastdmark  
44e5 ..			.dmark: db "KEY"  
44e8 f1			.pastdmark: pop af  
44e9			endm  
# End of macro DMARK
44e9						CALLMONITOR 
44e9 cd ae 15			call break_point_state  
44ec				endm  
# End of macro CALLMONITOR
44ec					endif 
44ec			; TODO currently waits 
44ec cd fa 5e				call cin 
44ef					;call cin_wait 
44ef 6f					ld l, a 
44f0 26 00				ld h, 0 
44f2 cd 1f 1c				call forth_push_numhl 
44f5					NEXTW 
44f5 c3 8d 1f			jp macro_next 
44f8				endm 
# End of macro NEXTW
44f8			.WAITK: 
44f8				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
44f8 3f				db WORD_SYS_CORE+43             
44f9 2a 45			dw .ACCEPT            
44fb 06				db 5 + 1 
44fc .. 00			db "WAITK",0              
4502				endm 
# End of macro CWHEAD
4502			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4502					if DEBUG_FORTH_WORDS_KEY 
4502						DMARK "WAI" 
4502 f5				push af  
4503 3a 17 45			ld a, (.dmark)  
4506 32 71 ee			ld (debug_mark),a  
4509 3a 18 45			ld a, (.dmark+1)  
450c 32 72 ee			ld (debug_mark+1),a  
450f 3a 19 45			ld a, (.dmark+2)  
4512 32 73 ee			ld (debug_mark+2),a  
4515 18 03			jr .pastdmark  
4517 ..			.dmark: db "WAI"  
451a f1			.pastdmark: pop af  
451b			endm  
# End of macro DMARK
451b						CALLMONITOR 
451b cd ae 15			call break_point_state  
451e				endm  
# End of macro CALLMONITOR
451e					endif 
451e cd f2 5e				call cin_wait 
4521 6f					ld l, a 
4522 26 00				ld h, 0 
4524 cd 1f 1c				call forth_push_numhl 
4527					NEXTW 
4527 c3 8d 1f			jp macro_next 
452a				endm 
# End of macro NEXTW
452a			.ACCEPT: 
452a				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
452a 40				db WORD_SYS_CORE+44             
452b 88 45			dw .EDIT            
452d 07				db 6 + 1 
452e .. 00			db "ACCEPT",0              
4535				endm 
# End of macro CWHEAD
4535			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4535					; TODO crashes on push 
4535					if DEBUG_FORTH_WORDS_KEY 
4535						DMARK "ACC" 
4535 f5				push af  
4536 3a 4a 45			ld a, (.dmark)  
4539 32 71 ee			ld (debug_mark),a  
453c 3a 4b 45			ld a, (.dmark+1)  
453f 32 72 ee			ld (debug_mark+1),a  
4542 3a 4c 45			ld a, (.dmark+2)  
4545 32 73 ee			ld (debug_mark+2),a  
4548 18 03			jr .pastdmark  
454a ..			.dmark: db "ACC"  
454d f1			.pastdmark: pop af  
454e			endm  
# End of macro DMARK
454e						CALLMONITOR 
454e cd ae 15			call break_point_state  
4551				endm  
# End of macro CALLMONITOR
4551					endif 
4551 21 fd e4				ld hl, os_input 
4554 3e 00				ld a, 0 
4556 77					ld (hl),a 
4557 3a 68 ea				ld a,(f_cursor_ptr) 
455a 16 64				ld d, 100 
455c 0e 00				ld c, 0 
455e 1e 28				ld e, 40 
4560 cd da 0d				call input_str 
4563					; TODO perhaps do a type check and wrap in quotes if not a number 
4563 21 fd e4				ld hl, os_input 
4566					if DEBUG_FORTH_WORDS 
4566						DMARK "AC1" 
4566 f5				push af  
4567 3a 7b 45			ld a, (.dmark)  
456a 32 71 ee			ld (debug_mark),a  
456d 3a 7c 45			ld a, (.dmark+1)  
4570 32 72 ee			ld (debug_mark+1),a  
4573 3a 7d 45			ld a, (.dmark+2)  
4576 32 73 ee			ld (debug_mark+2),a  
4579 18 03			jr .pastdmark  
457b ..			.dmark: db "AC1"  
457e f1			.pastdmark: pop af  
457f			endm  
# End of macro DMARK
457f						CALLMONITOR 
457f cd ae 15			call break_point_state  
4582				endm  
# End of macro CALLMONITOR
4582					endif 
4582 cd 8d 1c				call forth_push_str 
4585					NEXTW 
4585 c3 8d 1f			jp macro_next 
4588				endm 
# End of macro NEXTW
4588			 
4588			.EDIT: 
4588				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4588 40				db WORD_SYS_CORE+44             
4589 2a 46			dw .ENDKEY            
458b 05				db 4 + 1 
458c .. 00			db "EDIT",0              
4591				endm 
# End of macro CWHEAD
4591			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4591			 
4591					; TODO does not copy from stack 
4591					if DEBUG_FORTH_WORDS_KEY 
4591						DMARK "EDT" 
4591 f5				push af  
4592 3a a6 45			ld a, (.dmark)  
4595 32 71 ee			ld (debug_mark),a  
4598 3a a7 45			ld a, (.dmark+1)  
459b 32 72 ee			ld (debug_mark+1),a  
459e 3a a8 45			ld a, (.dmark+2)  
45a1 32 73 ee			ld (debug_mark+2),a  
45a4 18 03			jr .pastdmark  
45a6 ..			.dmark: db "EDT"  
45a9 f1			.pastdmark: pop af  
45aa			endm  
# End of macro DMARK
45aa						CALLMONITOR 
45aa cd ae 15			call break_point_state  
45ad				endm  
# End of macro CALLMONITOR
45ad					endif 
45ad			 
45ad					;FORTH_DSP 
45ad					FORTH_DSP_VALUEHL 
45ad cd 16 1e			call macro_dsp_valuehl 
45b0				endm 
# End of macro FORTH_DSP_VALUEHL
45b0			;		inc hl    ; TODO do type check 
45b0			 
45b0			;		call get_word_hl 
45b0 e5					push hl 
45b1					if DEBUG_FORTH_WORDS 
45b1						DMARK "EDp" 
45b1 f5				push af  
45b2 3a c6 45			ld a, (.dmark)  
45b5 32 71 ee			ld (debug_mark),a  
45b8 3a c7 45			ld a, (.dmark+1)  
45bb 32 72 ee			ld (debug_mark+1),a  
45be 3a c8 45			ld a, (.dmark+2)  
45c1 32 73 ee			ld (debug_mark+2),a  
45c4 18 03			jr .pastdmark  
45c6 ..			.dmark: db "EDp"  
45c9 f1			.pastdmark: pop af  
45ca			endm  
# End of macro DMARK
45ca						CALLMONITOR 
45ca cd ae 15			call break_point_state  
45cd				endm  
# End of macro CALLMONITOR
45cd					endif 
45cd				;	ld a, 0 
45cd cd 0b 12				call strlenz 
45d0 23					inc hl 
45d1			 
45d1 06 00				ld b, 0 
45d3 4d					ld c, l 
45d4			 
45d4 e1					pop hl 
45d5 11 fd e4				ld de, os_input 
45d8					if DEBUG_FORTH_WORDS_KEY 
45d8						DMARK "EDc" 
45d8 f5				push af  
45d9 3a ed 45			ld a, (.dmark)  
45dc 32 71 ee			ld (debug_mark),a  
45df 3a ee 45			ld a, (.dmark+1)  
45e2 32 72 ee			ld (debug_mark+1),a  
45e5 3a ef 45			ld a, (.dmark+2)  
45e8 32 73 ee			ld (debug_mark+2),a  
45eb 18 03			jr .pastdmark  
45ed ..			.dmark: db "EDc"  
45f0 f1			.pastdmark: pop af  
45f1			endm  
# End of macro DMARK
45f1						CALLMONITOR 
45f1 cd ae 15			call break_point_state  
45f4				endm  
# End of macro CALLMONITOR
45f4					endif 
45f4 ed b0				ldir 
45f6			 
45f6			 
45f6 21 fd e4				ld hl, os_input 
45f9					;ld a, 0 
45f9					;ld (hl),a 
45f9 3a 68 ea				ld a,(f_cursor_ptr) 
45fc 16 64				ld d, 100 
45fe 0e 00				ld c, 0 
4600 1e 28				ld e, 40 
4602 cd da 0d				call input_str 
4605					; TODO perhaps do a type check and wrap in quotes if not a number 
4605 21 fd e4				ld hl, os_input 
4608					if DEBUG_FORTH_WORDS 
4608						DMARK "ED1" 
4608 f5				push af  
4609 3a 1d 46			ld a, (.dmark)  
460c 32 71 ee			ld (debug_mark),a  
460f 3a 1e 46			ld a, (.dmark+1)  
4612 32 72 ee			ld (debug_mark+1),a  
4615 3a 1f 46			ld a, (.dmark+2)  
4618 32 73 ee			ld (debug_mark+2),a  
461b 18 03			jr .pastdmark  
461d ..			.dmark: db "ED1"  
4620 f1			.pastdmark: pop af  
4621			endm  
# End of macro DMARK
4621						CALLMONITOR 
4621 cd ae 15			call break_point_state  
4624				endm  
# End of macro CALLMONITOR
4624					endif 
4624 cd 8d 1c				call forth_push_str 
4627					NEXTW 
4627 c3 8d 1f			jp macro_next 
462a				endm 
# End of macro NEXTW
462a			 
462a			 
462a			 
462a			.ENDKEY: 
462a			; eof 
462a			 
# End of file forth_words_key.asm
462a			 
462a			if STORAGE_SE 
462a			   	include "forth_words_storage.asm" 
462a			endif 
462a				include "forth_words_device.asm" 
462a			; Device related words 
462a			 
462a			; | ## Device Words 
462a			 
462a			if SOUND_ENABLE 
462a			.NOTE: 
462a				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
462a			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
462a					if DEBUG_FORTH_WORDS_KEY 
462a						DMARK "NTE" 
462a						CALLMONITOR 
462a					endif 
462a			 
462a				 
462a			 
462a					NEXTW 
462a			.AFTERSOUND: 
462a			endif 
462a			 
462a			 
462a			USE_GPIO: equ 0 
462a			 
462a			if USE_GPIO 
462a			.GP1: 
462a				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
462a			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
462a					NEXTW 
462a			.GP2: 
462a				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
462a			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
462a			 
462a					NEXTW 
462a			 
462a			.GP3: 
462a				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
462a			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
462a			 
462a					NEXTW 
462a			 
462a			.GP4: 
462a				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
462a			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
462a			 
462a					NEXTW 
462a			.SIN: 
462a			 
462a			 
462a			endif 
462a			 
462a			 
462a				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
462a 33				db WORD_SYS_CORE+31             
462b 5f 46			dw .SOUT            
462d 03				db 2 + 1 
462e .. 00			db "IN",0              
4631				endm 
# End of macro CWHEAD
4631			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4631					if DEBUG_FORTH_WORDS_KEY 
4631						DMARK "IN." 
4631 f5				push af  
4632 3a 46 46			ld a, (.dmark)  
4635 32 71 ee			ld (debug_mark),a  
4638 3a 47 46			ld a, (.dmark+1)  
463b 32 72 ee			ld (debug_mark+1),a  
463e 3a 48 46			ld a, (.dmark+2)  
4641 32 73 ee			ld (debug_mark+2),a  
4644 18 03			jr .pastdmark  
4646 ..			.dmark: db "IN."  
4649 f1			.pastdmark: pop af  
464a			endm  
# End of macro DMARK
464a						CALLMONITOR 
464a cd ae 15			call break_point_state  
464d				endm  
# End of macro CALLMONITOR
464d					endif 
464d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
464d cd 16 1e			call macro_dsp_valuehl 
4650				endm 
# End of macro FORTH_DSP_VALUEHL
4650			 
4650 e5					push hl 
4651			 
4651					; destroy value TOS 
4651			 
4651					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4651 cd ce 1e			call macro_forth_dsp_pop 
4654				endm 
# End of macro FORTH_DSP_POP
4654			 
4654					; one value on hl get other one back 
4654			 
4654 c1					pop bc 
4655			 
4655					; do the sub 
4655			;		ex de, hl 
4655			 
4655 ed 68				in l,(c) 
4657			 
4657					; save it 
4657			 
4657 26 00				ld h,0 
4659			 
4659					; TODO push value back onto stack for another op etc 
4659			 
4659 cd 1f 1c				call forth_push_numhl 
465c					NEXTW 
465c c3 8d 1f			jp macro_next 
465f				endm 
# End of macro NEXTW
465f			.SOUT: 
465f				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
465f 34				db WORD_SYS_CORE+32             
4660 b2 46			dw .SPIO            
4662 04				db 3 + 1 
4663 .. 00			db "OUT",0              
4667				endm 
# End of macro CWHEAD
4667			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4667					if DEBUG_FORTH_WORDS_KEY 
4667						DMARK "OUT" 
4667 f5				push af  
4668 3a 7c 46			ld a, (.dmark)  
466b 32 71 ee			ld (debug_mark),a  
466e 3a 7d 46			ld a, (.dmark+1)  
4671 32 72 ee			ld (debug_mark+1),a  
4674 3a 7e 46			ld a, (.dmark+2)  
4677 32 73 ee			ld (debug_mark+2),a  
467a 18 03			jr .pastdmark  
467c ..			.dmark: db "OUT"  
467f f1			.pastdmark: pop af  
4680			endm  
# End of macro DMARK
4680						CALLMONITOR 
4680 cd ae 15			call break_point_state  
4683				endm  
# End of macro CALLMONITOR
4683					endif 
4683			 
4683					; get port 
4683			 
4683					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4683 cd 16 1e			call macro_dsp_valuehl 
4686				endm 
# End of macro FORTH_DSP_VALUEHL
4686			 
4686 e5					push hl 
4687			 
4687					; destroy value TOS 
4687			 
4687					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4687 cd ce 1e			call macro_forth_dsp_pop 
468a				endm 
# End of macro FORTH_DSP_POP
468a			 
468a					; get byte to send 
468a			 
468a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
468a cd 16 1e			call macro_dsp_valuehl 
468d				endm 
# End of macro FORTH_DSP_VALUEHL
468d			 
468d			;		push hl 
468d			 
468d					; destroy value TOS 
468d			 
468d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
468d cd ce 1e			call macro_forth_dsp_pop 
4690				endm 
# End of macro FORTH_DSP_POP
4690			 
4690					; one value on hl get other one back 
4690			 
4690			;		pop hl 
4690			 
4690 c1					pop bc 
4691			 
4691					if DEBUG_FORTH_WORDS 
4691						DMARK "OUT" 
4691 f5				push af  
4692 3a a6 46			ld a, (.dmark)  
4695 32 71 ee			ld (debug_mark),a  
4698 3a a7 46			ld a, (.dmark+1)  
469b 32 72 ee			ld (debug_mark+1),a  
469e 3a a8 46			ld a, (.dmark+2)  
46a1 32 73 ee			ld (debug_mark+2),a  
46a4 18 03			jr .pastdmark  
46a6 ..			.dmark: db "OUT"  
46a9 f1			.pastdmark: pop af  
46aa			endm  
# End of macro DMARK
46aa						CALLMONITOR 
46aa cd ae 15			call break_point_state  
46ad				endm  
# End of macro CALLMONITOR
46ad					endif 
46ad			 
46ad ed 69				out (c), l 
46af			 
46af					NEXTW 
46af c3 8d 1f			jp macro_next 
46b2				endm 
# End of macro NEXTW
46b2			 
46b2			 
46b2			.SPIO: 
46b2			 
46b2			if STORAGE_SE 
46b2				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
46b2			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
46b2			 
46b2					call spi_ce_low 
46b2			    NEXTW 
46b2			 
46b2			.SPICEH: 
46b2				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
46b2			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
46b2			 
46b2					call spi_ce_high 
46b2			    NEXTW 
46b2			 
46b2			 
46b2			.SPIOb: 
46b2			 
46b2				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
46b2			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
46b2			 
46b2					if DEBUG_FORTH_WORDS_KEY 
46b2						DMARK "SPo" 
46b2						CALLMONITOR 
46b2					endif 
46b2					; get port 
46b2			 
46b2			 
46b2					; get byte to send 
46b2			 
46b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
46b2			 
46b2			;		push hl    ; u1  
46b2			 
46b2					; destroy value TOS 
46b2			 
46b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46b2			 
46b2					; one value on hl get other one back 
46b2			 
46b2			;		pop hl   ; u2 - addr 
46b2			 
46b2					; TODO Send SPI byte 
46b2			 
46b2			;		push hl 
46b2			;		call spi_ce_low 
46b2			;		pop hl 
46b2					ld a, l 
46b2					call spi_send_byte 
46b2			;		call spi_ce_high 
46b2			 
46b2					NEXTW 
46b2			 
46b2			.SPII: 
46b2				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
46b2			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
46b2					if DEBUG_FORTH_WORDS_KEY 
46b2						DMARK "SPi" 
46b2						CALLMONITOR 
46b2					endif 
46b2			 
46b2					; TODO Get SPI byte 
46b2			 
46b2					call spi_read_byte 
46b2			 
46b2					if DEBUG_FORTH_WORDS 
46b2						DMARK "Si2" 
46b2						CALLMONITOR 
46b2					endif 
46b2					ld h, 0 
46b2					ld l, a 
46b2					if DEBUG_FORTH_WORDS 
46b2						DMARK "Si3" 
46b2						CALLMONITOR 
46b2					endif 
46b2					call forth_push_numhl 
46b2			 
46b2					NEXTW 
46b2			 
46b2			 
46b2			 
46b2			.SESEL: 
46b2				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
46b2			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
46b2					if DEBUG_FORTH_WORDS_KEY 
46b2						DMARK "BNK" 
46b2						CALLMONITOR 
46b2					endif 
46b2			 
46b2					ld a, 255 
46b2					ld (spi_cartdev), a 
46b2			 
46b2					; get bank 
46b2			 
46b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
46b2			 
46b2			;		push hl 
46b2			 
46b2					; destroy value TOS 
46b2			 
46b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46b2			 
46b2					; one value on hl get other one back 
46b2			 
46b2			;		pop hl 
46b2			 
46b2			 
46b2					ld c, SPI_CE_HIGH 
46b2					ld b, '0'    ; human readable bank number 
46b2			 
46b2					ld a, l 
46b2			 
46b2					if DEBUG_FORTH_WORDS 
46b2						DMARK "BNK" 
46b2						CALLMONITOR 
46b2					endif 
46b2			 
46b2					; active low 
46b2			 
46b2					cp 0 
46b2					jr z, .bset 
46b2					cp 1 
46b2					jr nz, .b2 
46b2					res 0, c 
46b2					ld b, '1'    ; human readable bank number 
46b2			.b2:		cp 2 
46b2					jr nz, .b3 
46b2					res 1, c 
46b2					ld b, '2'    ; human readable bank number 
46b2			.b3:		cp 3 
46b2					jr nz, .b4 
46b2					res 2, c 
46b2					ld b, '3'    ; human readable bank number 
46b2			.b4:		cp 4 
46b2					jr nz, .b5 
46b2					res 3, c 
46b2					ld b, '4'    ; human readable bank number 
46b2			.b5:		cp 5 
46b2					jr nz, .bset 
46b2					res 4, c 
46b2					ld b, '5'    ; human readable bank number 
46b2			 
46b2			.bset: 
46b2					ld a, c 
46b2					ld (spi_device),a 
46b2					ld a, b 
46b2					ld (spi_device_id),a 
46b2					if DEBUG_FORTH_WORDS 
46b2						DMARK "BN2" 
46b2						CALLMONITOR 
46b2					endif 
46b2			 
46b2					; set default SPI clk pulse time as disabled for BANK use 
46b2			 
46b2					ld a, 0 
46b2					ld (spi_clktime), a 
46b2			 
46b2					NEXTW 
46b2			 
46b2			.CARTDEV: 
46b2				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
46b2			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
46b2					if DEBUG_FORTH_WORDS_KEY 
46b2						DMARK "CDV" 
46b2						CALLMONITOR 
46b2					endif 
46b2			 
46b2					; disable se storage bank selection 
46b2			 
46b2					ld a, SPI_CE_HIGH		; ce high 
46b2					ld (spi_device), a 
46b2			 
46b2					; get bank 
46b2			 
46b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
46b2			 
46b2			;		push hl 
46b2			 
46b2					; destroy value TOS 
46b2			 
46b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46b2			 
46b2					; one value on hl get other one back 
46b2			 
46b2			;		pop hl 
46b2			 
46b2					; active low 
46b2			 
46b2					ld c, 255 
46b2			 
46b2					ld a, l 
46b2					if DEBUG_FORTH_WORDS 
46b2						DMARK "CDV" 
46b2						CALLMONITOR 
46b2					endif 
46b2					cp 0 
46b2					jr z, .cset 
46b2					cp 1 
46b2					jr nz, .c2 
46b2					res 0, c 
46b2			.c2:		cp 2 
46b2					jr nz, .c3 
46b2					res 1, c 
46b2			.c3:		cp 3 
46b2					jr nz, .c4 
46b2					res 2, c 
46b2			.c4:		cp 4 
46b2					jr nz, .c5 
46b2					res 3, c 
46b2			.c5:		cp 5 
46b2					jr nz, .c6 
46b2					res 4, c 
46b2			.c6:		cp 6 
46b2					jr nz, .c7 
46b2					res 5, c 
46b2			.c7:		cp 7 
46b2					jr nz, .c8 
46b2					res 6, c 
46b2			.c8:		cp 8 
46b2					jr nz, .cset 
46b2					res 7, c 
46b2			.cset:		ld a, c 
46b2					ld (spi_cartdev),a 
46b2			 
46b2					if DEBUG_FORTH_WORDS 
46b2						DMARK "CD2" 
46b2						CALLMONITOR 
46b2					endif 
46b2			 
46b2					; set default SPI clk pulse time as 10ms for CARTDEV use 
46b2			 
46b2					ld a, $0a 
46b2					ld (spi_clktime), a 
46b2					NEXTW 
46b2			endif 
46b2			 
46b2			.ENDDEVICE: 
46b2			; eof 
46b2			 
# End of file forth_words_device.asm
46b2			 
46b2			; var handler 
46b2			 
46b2			 
46b2			.VARS: 
46b2				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
46b2 78				db WORD_SYS_CORE+100             
46b3 ca 46			dw .V0Q            
46b5 04				db 3 + 1 
46b6 .. 00			db "V0!",0              
46ba				endm 
# End of macro CWHEAD
46ba			;| V0! ( u1 -- )  Store value to v0  | DONE 
46ba			 
46ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
46ba cd 16 1e			call macro_dsp_valuehl 
46bd				endm 
# End of macro FORTH_DSP_VALUEHL
46bd			 
46bd 11 32 ea				ld de, cli_var_array 
46c0			 
46c0 eb					ex de, hl 
46c1 73					ld (hl), e 
46c2 23					inc hl 
46c3 72					ld (hl), d 
46c4			 
46c4					; destroy value TOS 
46c4			 
46c4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46c4 cd ce 1e			call macro_forth_dsp_pop 
46c7				endm 
# End of macro FORTH_DSP_POP
46c7			 
46c7				       NEXTW 
46c7 c3 8d 1f			jp macro_next 
46ca				endm 
# End of macro NEXTW
46ca			.V0Q: 
46ca				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
46ca 79				db WORD_SYS_CORE+101             
46cb db 46			dw .V1S            
46cd 04				db 3 + 1 
46ce .. 00			db "V0@",0              
46d2				endm 
# End of macro CWHEAD
46d2			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
46d2 2a 32 ea				ld hl, (cli_var_array) 
46d5 cd 1f 1c				call forth_push_numhl 
46d8			 
46d8				       NEXTW 
46d8 c3 8d 1f			jp macro_next 
46db				endm 
# End of macro NEXTW
46db			.V1S: 
46db				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
46db 7a				db WORD_SYS_CORE+102             
46dc f3 46			dw .V1Q            
46de 04				db 3 + 1 
46df .. 00			db "V1!",0              
46e3				endm 
# End of macro CWHEAD
46e3			;| V1! ( u1 -- )  Store value to v1 | DONE 
46e3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
46e3 cd 16 1e			call macro_dsp_valuehl 
46e6				endm 
# End of macro FORTH_DSP_VALUEHL
46e6			 
46e6 11 34 ea				ld de, cli_var_array+2 
46e9				 
46e9 eb					ex de, hl 
46ea 73					ld (hl), e 
46eb 23					inc hl 
46ec 72					ld (hl), d 
46ed			 
46ed					; destroy value TOS 
46ed			 
46ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46ed cd ce 1e			call macro_forth_dsp_pop 
46f0				endm 
# End of macro FORTH_DSP_POP
46f0				       NEXTW 
46f0 c3 8d 1f			jp macro_next 
46f3				endm 
# End of macro NEXTW
46f3			.V1Q: 
46f3				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
46f3 7b				db WORD_SYS_CORE+103             
46f4 04 47			dw .V2S            
46f6 04				db 3 + 1 
46f7 .. 00			db "V1@",0              
46fb				endm 
# End of macro CWHEAD
46fb			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
46fb 2a 34 ea				ld hl, (cli_var_array+2) 
46fe cd 1f 1c				call forth_push_numhl 
4701				       NEXTW 
4701 c3 8d 1f			jp macro_next 
4704				endm 
# End of macro NEXTW
4704			.V2S: 
4704				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4704 7c				db WORD_SYS_CORE+104             
4705 1c 47			dw .V2Q            
4707 04				db 3 + 1 
4708 .. 00			db "V2!",0              
470c				endm 
# End of macro CWHEAD
470c			;| V2! ( u1 -- )  Store value to v2 | DONE 
470c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
470c cd 16 1e			call macro_dsp_valuehl 
470f				endm 
# End of macro FORTH_DSP_VALUEHL
470f			 
470f 11 36 ea				ld de, cli_var_array+4 
4712				 
4712 eb					ex de, hl 
4713 73					ld (hl), e 
4714 23					inc hl 
4715 72					ld (hl), d 
4716			 
4716					; destroy value TOS 
4716			 
4716					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4716 cd ce 1e			call macro_forth_dsp_pop 
4719				endm 
# End of macro FORTH_DSP_POP
4719				       NEXTW 
4719 c3 8d 1f			jp macro_next 
471c				endm 
# End of macro NEXTW
471c			.V2Q: 
471c				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
471c 7d				db WORD_SYS_CORE+105             
471d 2d 47			dw .V3S            
471f 04				db 3 + 1 
4720 .. 00			db "V2@",0              
4724				endm 
# End of macro CWHEAD
4724			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4724 2a 36 ea				ld hl, (cli_var_array+4) 
4727 cd 1f 1c				call forth_push_numhl 
472a				       NEXTW 
472a c3 8d 1f			jp macro_next 
472d				endm 
# End of macro NEXTW
472d			.V3S: 
472d				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
472d 7c				db WORD_SYS_CORE+104             
472e 45 47			dw .V3Q            
4730 04				db 3 + 1 
4731 .. 00			db "V3!",0              
4735				endm 
# End of macro CWHEAD
4735			;| V3! ( u1 -- )  Store value to v3 | DONE 
4735					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4735 cd 16 1e			call macro_dsp_valuehl 
4738				endm 
# End of macro FORTH_DSP_VALUEHL
4738			 
4738 11 38 ea				ld de, cli_var_array+6 
473b				 
473b eb					ex de, hl 
473c 73					ld (hl), e 
473d 23					inc hl 
473e 72					ld (hl), d 
473f			 
473f					; destroy value TOS 
473f			 
473f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
473f cd ce 1e			call macro_forth_dsp_pop 
4742				endm 
# End of macro FORTH_DSP_POP
4742				       NEXTW 
4742 c3 8d 1f			jp macro_next 
4745				endm 
# End of macro NEXTW
4745			.V3Q: 
4745				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4745 7d				db WORD_SYS_CORE+105             
4746 56 47			dw .END            
4748 04				db 3 + 1 
4749 .. 00			db "V3@",0              
474d				endm 
# End of macro CWHEAD
474d			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
474d 2a 38 ea				ld hl, (cli_var_array+6) 
4750 cd 1f 1c				call forth_push_numhl 
4753				       NEXTW 
4753 c3 8d 1f			jp macro_next 
4756				endm 
# End of macro NEXTW
4756			 
4756			 
4756			 
4756			 
4756			 
4756			; end of dict marker 
4756			 
4756 00			.END:    db WORD_SYS_END 
4757 00 00			dw 0 
4759 00				db 0 
475a			 
475a			; use to jp here for user dict words to save on macro expansion  
475a			 
475a			user_dict_next: 
475a				NEXTW 
475a c3 8d 1f			jp macro_next 
475d				endm 
# End of macro NEXTW
475d			 
475d			 
475d			user_exec: 
475d				;    ld hl, <word code> 
475d				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
475d				;    call forthexec 
475d				;    jp user_dict_next   (NEXT) 
475d			        ;    <word code bytes> 
475d eb				ex de, hl 
475e 2a 00 e6			ld hl,(os_tok_ptr) 
4761				 
4761				FORTH_RSP_NEXT 
4761 cd c6 1b			call macro_forth_rsp_next 
4764				endm 
# End of macro FORTH_RSP_NEXT
4764			 
4764			if DEBUG_FORTH_UWORD 
4764						DMARK "UEX" 
4764 f5				push af  
4765 3a 79 47			ld a, (.dmark)  
4768 32 71 ee			ld (debug_mark),a  
476b 3a 7a 47			ld a, (.dmark+1)  
476e 32 72 ee			ld (debug_mark+1),a  
4771 3a 7b 47			ld a, (.dmark+2)  
4774 32 73 ee			ld (debug_mark+2),a  
4777 18 03			jr .pastdmark  
4779 ..			.dmark: db "UEX"  
477c f1			.pastdmark: pop af  
477d			endm  
# End of macro DMARK
477d				CALLMONITOR 
477d cd ae 15			call break_point_state  
4780				endm  
# End of macro CALLMONITOR
4780			endif 
4780			 
4780			 
4780			 
4780 eb				ex de, hl 
4781 22 00 e6			ld (os_tok_ptr), hl 
4784				 
4784				; Don't use next - Skips the first word in uword. 
4784			 
4784 c3 1e 20			jp exec1 
4787			;	NEXT 
4787			 
4787			 
4787			; eof 
# End of file forth_wordsv4.asm
4787			endif 
4787			;;;;;;;;;;;;;; Debug code 
4787			 
4787			 
4787			;if DEBUG_FORTH_PARSE 
4787 .. 00		.nowordfound: db "No match",0 
4790 .. 00		.compword:	db "Comparing word ",0 
47a0 .. 00		.nextwordat:	db "Next word at",0 
47ad .. 00		.charmatch:	db "Char match",0 
47b8			;endif 
47b8			if DEBUG_FORTH_JP 
47b8			.foundword:	db "Word match. Exec..",0 
47b8			endif 
47b8			;if DEBUG_FORTH_PUSH 
47b8 .. 00		.enddict:	db "Dict end. Push.",0 
47c8 .. 00		.push_str:	db "Pushing string",0 
47d7 .. 00		.push_num:	db "Pushing number",0 
47e6 .. 00		.data_sp:	db "SP:",0 
47ea .. 00		.wordinhl:	db "Word in HL (2/0):",0 
47fc .. 00		.wordinde:	db "Word in DE (3/0):",0 
480e .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4820			;endif 
4820			;if DEBUG_FORTH_MALLOC 
4820 .. 00		.push_malloc:	db "Malloc address",0 
482f			;endif 
482f			 
482f			 
482f			 
482f			; display malloc address and current data stack pointer  
482f			 
482f			malloc_error: 
482f d5				push de 
4830 f5				push af 
4831 e5				push hl 
4832 cd 80 0b			call clear_display 
4835 11 57 48			ld de, .mallocerr 
4838 3e 00			ld a,0 
483a			;	ld de,os_word_scratch 
483a cd 93 0b			call str_at_display 
483d 3e 11			ld a, display_row_1+17 
483f 11 71 ee			ld de, debug_mark 
4842 cd 93 0b			call str_at_display 
4845 cd a3 0b			call update_display 
4848				;call break_point_state 
4848 cd f2 5e			call cin_wait 
484b			 
484b 3e 20			ld a, ' ' 
484d 32 f0 e2			ld (os_view_disable), a 
4850 e1				pop hl 
4851 f1				pop af 
4852 d1				pop de	 
4853				CALLMONITOR 
4853 cd ae 15			call break_point_state  
4856				endm  
# End of macro CALLMONITOR
4856 c9				ret 
4857			 
4857 .. 00		.mallocerr: 	db "Malloc Error",0 
4864			;if DEBUG_FORTH_PUSH 
4864			display_data_sp: 
4864 f5				push af 
4865			 
4865				; see if disabled 
4865			 
4865 3a f0 e2			ld a, (os_view_disable) 
4868 fe 2a			cp '*' 
486a 28 67			jr z, .skipdsp 
486c			 
486c e5				push hl 
486d e5				push hl 
486e e5			push hl 
486f cd 80 0b			call clear_display 
4872 e1			pop hl 
4873 7c				ld a,h 
4874 21 04 e6			ld hl, os_word_scratch 
4877 cd ae 10			call hexout 
487a e1				pop hl 
487b 7d				ld a,l 
487c 21 06 e6			ld hl, os_word_scratch+2 
487f cd ae 10			call hexout 
4882 21 08 e6			ld hl, os_word_scratch+4 
4885 3e 00			ld a,0 
4887 77				ld (hl),a 
4888 11 04 e6			ld de,os_word_scratch 
488b 3e 28				ld a, display_row_2 
488d cd 93 0b				call str_at_display 
4890 11 ea 47			ld de, .wordinhl 
4893 3e 00			ld a, display_row_1 
4895			 
4895 cd 93 0b				call str_at_display 
4898 11 71 ee			ld de, debug_mark 
489b 3e 11			ld a, display_row_1+17 
489d			 
489d cd 93 0b				call str_at_display 
48a0			 
48a0				; display current data stack pointer 
48a0 11 e6 47			ld de,.data_sp 
48a3 3e 30				ld a, display_row_2 + 8 
48a5 cd 93 0b				call str_at_display 
48a8			 
48a8 2a 2c ea			ld hl,(cli_data_sp) 
48ab e5				push hl 
48ac 7c				ld a,h 
48ad 21 04 e6			ld hl, os_word_scratch 
48b0 cd ae 10			call hexout 
48b3 e1				pop hl 
48b4 7d				ld a,l 
48b5 21 06 e6			ld hl, os_word_scratch+2 
48b8 cd ae 10			call hexout 
48bb 21 08 e6			ld hl, os_word_scratch+4 
48be 3e 00			ld a,0 
48c0 77				ld (hl),a 
48c1 11 04 e6			ld de,os_word_scratch 
48c4 3e 33				ld a, display_row_2 + 11 
48c6 cd 93 0b				call str_at_display 
48c9			 
48c9			 
48c9 cd a3 0b			call update_display 
48cc cd f2 0a			call delay1s 
48cf cd f2 0a			call delay1s 
48d2 e1				pop hl 
48d3			.skipdsp: 
48d3 f1				pop af 
48d4 c9				ret 
48d5			 
48d5			display_data_malloc: 
48d5			 
48d5 f5				push af 
48d6 e5				push hl 
48d7 e5				push hl 
48d8 e5			push hl 
48d9 cd 80 0b			call clear_display 
48dc e1			pop hl 
48dd 7c				ld a,h 
48de 21 04 e6			ld hl, os_word_scratch 
48e1 cd ae 10			call hexout 
48e4 e1				pop hl 
48e5 7d				ld a,l 
48e6 21 06 e6			ld hl, os_word_scratch+2 
48e9 cd ae 10			call hexout 
48ec 21 08 e6			ld hl, os_word_scratch+4 
48ef 3e 00			ld a,0 
48f1 77				ld (hl),a 
48f2 11 04 e6			ld de,os_word_scratch 
48f5 3e 28				ld a, display_row_2 
48f7 cd 93 0b				call str_at_display 
48fa 11 20 48			ld de, .push_malloc 
48fd 3e 00			ld a, display_row_1 
48ff			 
48ff cd 93 0b				call str_at_display 
4902			 
4902				; display current data stack pointer 
4902 11 e6 47			ld de,.data_sp 
4905 3e 30				ld a, display_row_2 + 8 
4907 cd 93 0b				call str_at_display 
490a			 
490a 2a 2c ea			ld hl,(cli_data_sp) 
490d e5				push hl 
490e 7c				ld a,h 
490f 21 04 e6			ld hl, os_word_scratch 
4912 cd ae 10			call hexout 
4915 e1				pop hl 
4916 7d				ld a,l 
4917 21 06 e6			ld hl, os_word_scratch+2 
491a cd ae 10			call hexout 
491d 21 08 e6			ld hl, os_word_scratch+4 
4920 3e 00			ld a,0 
4922 77				ld (hl),a 
4923 11 04 e6			ld de,os_word_scratch 
4926 3e 33				ld a, display_row_2 + 11 
4928 cd 93 0b				call str_at_display 
492b			 
492b cd a3 0b			call update_display 
492e cd f2 0a			call delay1s 
4931 cd f2 0a			call delay1s 
4934 e1				pop hl 
4935 f1				pop af 
4936 c9				ret 
4937			;endif 
4937			 
4937			include "forth_autostart.asm" 
4937			; list of commands to perform at system start up 
4937			 
4937			startcmds: 
4937			;	dw test11 
4937			;	dw test12 
4937			;	dw test13 
4937			;	dw test14 
4937			;	dw test15 
4937			;	dw test16 
4937			;	dw test17 
4937			;	dw ifthtest1 
4937			;	dw ifthtest2 
4937			;	dw ifthtest3 
4937			;	dw mmtest1 
4937			;	dw mmtest2 
4937			;	dw mmtest3 
4937			;	dw mmtest4 
4937			;	dw mmtest5 
4937			;	dw mmtest6 
4937			;	dw iftest1 
4937			;	dw iftest2 
4937			;	dw iftest3 
4937			;	dw looptest1 
4937			;	dw looptest2 
4937			;	dw test1 
4937			;	dw test2 
4937			;	dw test3 
4937			;	dw test4 
4937			;	dw game2r 
4937			;	dw game2b1 
4937			;	dw game2b2 
4937			 
4937				; start up words that are actually useful 
4937			 
4937 ab 49		    dw spi1 
4939 ff 49		    dw spi2 
493b 35 4a		    dw spi3 
493d 71 4a		    dw spi4 
493f 9c 4a		    dw spi5 
4941 c9 4a		    dw spi6 
4943 1e 4b		    dw spi7 
4945			 
4945 76 4b		    dw spi8 
4947 95 4b		    dw spi9 
4949 ed 4b		    dw spi10 
494b			 
494b 60 4c			dw longread 
494d a7 4c			dw clrstack 
494f da 4c			dw type 
4951 ca 4e			dw stest 
4953 fe 4c			dw strncpy 
4955 60 4e			dw list 
4957 5f 4d			dw start1 
4959 71 4d			dw start2 
495b			;	dw start3 
495b 84 4d			dw start3b 
495d 00 4e			dw start3c 
495f			 
495f				; (unit) testing words 
495f			 
495f 41 4f			dw mtesta 
4961 f6 4f			dw mtestb 
4963 99 50			dw mtestc 
4965 4e 51			dw mtestd 
4967 f2 51			dw mteste 
4969			 
4969				; demo/game words 
4969			 
4969 fe 58		        dw game3w 
496b 2c 59		        dw game3p 
496d 4a 59		        dw game3sc 
496f 7b 59		        dw game3vsi 
4971 a7 59		        dw game3vs 
4973				 
4973 f1 56			dw game2b 
4975 5f 57			dw game2bf 
4977 a9 57			dw game2mba 
4979 3f 58			dw game2mbas 
497b 81 58			dw game2mb 
497d			 
497d b2 53			dw game1 
497f c3 53			dw game1a 
4981 25 54			dw game1b 
4983 5a 54			dw game1c 
4985 90 54			dw game1d 
4987 c1 54			dw game1s 
4989 d5 54			dw game1t 
498b ea 54			dw game1f 
498d 1e 55			dw game1z 
498f 62 55			dw game1zz 
4991			 
4991 a8 52			dw test5 
4993 e0 52			dw test6 
4995 18 53			dw test7 
4997 2c 53			dw test8 
4999 58 53			dw test9 
499b 6e 53			dw test10 
499d				 
499d 39 56		        dw ssv5 
499f 1d 56		        dw ssv4 
49a1 01 56		        dw ssv3 
49a3 cb 55		        dw ssv2 
49a5 52 56		        dw ssv1 
49a7 9a 56		        dw ssv1cpm 
49a9			;	dw keyup 
49a9			;	dw keydown 
49a9			;	dw keyleft 
49a9			;	dw keyright 
49a9			;	dw 	keyf1 
49a9			;	dw keyf2 
49a9			;	dw keyf3 
49a9			;	dw keyf4 
49a9			;	dw keyf5 
49a9			;	dw keyf6 
49a9			;	dw keyf7 
49a9			;	dw keyf8 
49a9			;	dw keyf9 
49a9			;	dw keyf10 
49a9			;	dw keyf11 
49a9			;	dw keyf12 
49a9			;	dw keytab 
49a9			;	dw keycr 
49a9			;	dw keyhome 
49a9			;	dw keyend 
49a9			;	dw keybs 
49a9 00 00			db 0, 0	 
49ab			 
49ab			; SPI Net support words 
49ab			 
49ab			; v0! = node to send to 
49ab			; ( str count - ) 
49ab .. 00		spi1:       db ": spitype spicel $00 do dup i + @ v0@ $10 spio spio spio $01 pause loop spiceh ; ; ",0 
49ff			 
49ff			; spiputchr ( char node - ) 
49ff .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
4a35 .. 00		spi3:       db ": storestr spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
4a71			 
4a71			; spigetchr ( - n ) 
4a71 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
4a9c			 
4a9c			; getnode ( - n ) 
4a9c .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
4ac9			 
4ac9			 
4ac9			; store string ( str i - ) 
4ac9			 
4ac9 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
4b1e			 
4b1e			; get string ( addr i -  )    TO FIX 
4b1e			 
4b1e .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
4b76			 
4b76			 
4b76			; SPICHAT (TODO) 
4b76			; Program to allow two nodes to chat with eachother 
4b76			; 
4b76			; v0 - target node 
4b76			;  
4b76			; accept input at 0,0 
4b76			; if input is string send spitype to target node 
4b76			; starting at row 2,0 , while spigetchr is not zero ->  
4b76			; 
4b76			; ( node - ) 
4b76 .. 00		spi8:		db ": spichatp $00 $00 at accept ;", 0 
4b95 .. 00		spi9: 		db ": spichatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
4bed .. 00		spi10:		db ": spichat v0! repeat spichatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . spichatr true until ;", 0 
4c60			 
4c60			 
4c60			; Long read of currently open file 
4c60 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
4ca7			 
4ca7			; clear stack  
4ca7			 
4ca7 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
4cda			 
4cda			; type ( addr count - ) 
4cda .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
4cfe			 
4cfe			; some direct memory words 
4cfe			; strncpy ( len t f -- t ) 
4cfe			 
4cfe .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
4d5f			 
4d5f .. 00		start1:     	db ": bpon $0000 bp ;",0 
4d71 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
4d84 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
4e00 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
4e60			 
4e60			 
4e60			; a handy word to list items on the stack 
4e60			 
4e60 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
4eca			 
4eca			 
4eca			; test stack  
4eca			; rnd8 stest 
4eca			 
4eca .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
4f41			 
4f41			; random malloc and free cycles 
4f41			 
4f41 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4ff6			 
4ff6			; fixed malloc and free cycles 
4ff6			 
4ff6 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5099			 
5099			; fixed double string push and drop cycle  
5099			 
5099 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
514e			 
514e			; consistent fixed string push and drop cycle  
514e			 
514e .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
51f2			 
51f2 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
52a8			 
52a8			;test1:		db ": aa 1 2 3 ;", 0 
52a8			;test2:     	db "111 aa 888 999",0 
52a8			;test3:     	db ": bb 77 ;",0 
52a8			;test4:     	db "$02 $01 do i . loop bb",0 
52a8			 
52a8 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
52e0 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5318 .. 00		test7:     	db ": box hline vline ;",0 
532c .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5358 .. 00		test9:     	db ": sw $01 adsp world ;",0 
536e .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5393 .. 00		test11:     	db "hello create .",0 
53a2 .. 00		test12:     	db "hello2 create .",0 
53b2			 
53b2			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
53b2			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
53b2			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
53b2			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
53b2			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
53b2			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
53b2			 
53b2			;iftest1:     	db "$0001 IF cls .",0 
53b2			;iftest2:     	db "$0000 IF cls .",0 
53b2			;iftest3:     	db "$0002 $0003 - IF cls .",0 
53b2			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
53b2			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
53b2			 
53b2			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
53b2			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
53b2			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
53b2			 
53b2			 
53b2			 
53b2			; a small guess the number game 
53b2			 
53b2 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
53c3 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5425			 
5425 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
545a .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5490 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
54c1 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
54d5 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
54ea .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
551e .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5562			 
5562			; Using 'ga' save a high score across multiple runs using external storage 
5562			 
5562 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
55cb			 
55cb			 
55cb			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
55cb			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
55cb			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
55cb			 
55cb			; simple screen saver to test code memory reuse to destruction 
55cb			 
55cb .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5601 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
561d .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5639 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5652 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
569a .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
56f1			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
56f1			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
56f1			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
56f1			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
56f1			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
56f1			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
56f1			 
56f1			 
56f1			 
56f1			; minesweeper/battleship finding game 
56f1			; draws a game board of random ship/mine positions 
56f1			; user enters coords to see if it hits on 
56f1			; game ends when all are hit 
56f1			; when hit or miss says how many may be in the area 
56f1			 
56f1			; setup the game board and then hide it 
56f1 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
575f .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
57a9			; prompt for where to target 
57a9 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
583f .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5864			; TODO see if the entered coords hits or misses pushes char hit of miss 
5864 .. 00		game2mbht:      db ": mbckht nop ;",0 
5873 .. 00		game2mbms:      db ": mbcms nop ;",0 
5881			; TODO how many might be near by 
5881 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
58fe			 
58fe			; Game 3 
58fe			 
58fe			; Vert scroller ski game - avoid the trees! 
58fe			 
58fe			; v0 score (ie turns) 
58fe			; v1 player pos 
58fe			; v2 left wall 
58fe			; v3 right wall 
58fe			 
58fe			; Draw side walls randomly 
58fe			 
58fe .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
592c			 
592c			; Draw player 
592c .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
594a			 
594a			; TODO Get Key 
594a			 
594a			; TODO Move left right 
594a			 
594a			; scroll and move walls a bit 
594a			 
594a .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
597b			 
597b			; main game loop 
597b			 
597b .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
59a7 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
59e6			 
59e6			; key board defs 
59e6			 
59e6 .. 00		keyup:       db ": keyup $05 ;",0 
59f4 .. 00		keydown:       db ": keydown $0a ;",0 
5a04 .. 00		keyleft:       db ": keyleft $0b ;",0 
5a14 .. 00		keyright:       db ": keyright $0c ;",0 
5a25 .. 00		keyf1:       db ": keyf1 $10 ;",0 
5a33 .. 00		keyf2:       db ": keyf2 $11 ;",0 
5a41 .. 00		keyf3:       db ": keyf3 $12 ;",0 
5a4f .. 00		keyf4:       db ": keyf4 $13 ;",0 
5a5d .. 00		keyf5:       db ": keyf5 $14 ;",0 
5a6b .. 00		keyf6:       db ": keyf6 $15 ;",0 
5a79 .. 00		keyf7:       db ": keyf7 $16 ;",0 
5a87 .. 00		keyf8:       db ": keyf8 $17 ;",0 
5a95 .. 00		keyf9:       db ": keyf9 $18 ;",0 
5aa3 .. 00		keyf10:       db ": keyf10 $19 ;",0 
5ab2 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5ac1 .. 00		keyf12:       db ": keyf12 $1b ;",0 
5ad0			 
5ad0 .. 00		keytab:       db ": keytab $09 ;",0 
5adf .. 00		keycr:       db ": keycr $0d ;",0 
5aed .. 00		keyhome:       db ": keyhome $0e ;",0 
5afd .. 00		keyend:       db ": keyend $0f ;",0 
5b0c .. 00		keybs:       db ": keybs $08 ;",0 
5b1a			 
5b1a			   
5b1a			 
5b1a			 
5b1a			 
5b1a			; eof 
# End of file forth_autostart.asm
5b1a			 
5b1a .. 00		sprompt1: db "Startup load...",0 
5b2a .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5b40			 
5b40			 
5b40			 
5b40			 
5b40			forth_startup: 
5b40 21 37 49			ld hl, startcmds 
5b43 3e 00			ld a, 0 
5b45 32 25 e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
5b48			 
5b48 e5			.start1:	push hl 
5b49 cd 80 0b			call clear_display 
5b4c 11 1a 5b			ld de, sprompt1 
5b4f 3e 00		        ld a, display_row_1 
5b51 cd 93 0b			call str_at_display 
5b54 11 2a 5b			ld de, sprompt2 
5b57 3e 28		        ld a, display_row_2 
5b59 cd 93 0b			call str_at_display 
5b5c e1				pop hl 
5b5d e5				push hl 
5b5e 5e				ld e,(hl) 
5b5f 23				inc hl 
5b60 56				ld d,(hl) 
5b61 3e 50		        ld a, display_row_3 
5b63 cd 93 0b			call str_at_display 
5b66 cd a3 0b			call update_display 
5b69			 
5b69			 
5b69 3a 25 e7			ld a, (os_last_cmd) 
5b6c fe 00			cp 0 
5b6e 28 05			jr z, .startprompt 
5b70 cd e6 0a			call delay250ms 
5b73 18 24			jr .startdo 
5b75				 
5b75				 
5b75			 
5b75			.startprompt: 
5b75			 
5b75 3e 9f			ld a,display_row_4 + display_cols - 1 
5b77 11 95 1b		        ld de, endprg 
5b7a cd 93 0b			call str_at_display 
5b7d cd a3 0b			call update_display 
5b80 cd f2 0a			call delay1s 
5b83 cd f2 5e			call cin_wait 
5b86						 
5b86 fe 2a			cp '*' 
5b88 28 5e			jr z, .startupend1 
5b8a fe 23			cp '#' 
5b8c 20 07			jr nz, .startno 
5b8e 3e 01			ld a, 1 
5b90 32 25 e7			ld (os_last_cmd),a 
5b93 18 04			jr .startdo 
5b95 fe 31		.startno:	cp '1' 
5b97 28 3a			jr z,.startnxt  
5b99			 
5b99				; exec startup line 
5b99			.startdo:	 
5b99 e1				pop hl 
5b9a e5				push hl 
5b9b				 
5b9b 5e				ld e,(hl) 
5b9c 23				inc hl 
5b9d 56				ld d,(hl) 
5b9e eb				ex de,hl 
5b9f			 
5b9f e5				push hl 
5ba0			 
5ba0 3e 00			ld a, 0 
5ba2				;ld a, FORTH_END_BUFFER 
5ba2 cd 16 12			call strlent 
5ba5 23				inc hl   ; include zero term to copy 
5ba6 06 00			ld b,0 
5ba8 4d				ld c,l 
5ba9 e1				pop hl 
5baa 11 ff e2			ld de, scratch 
5bad ed b0			ldir 
5baf			 
5baf			 
5baf 21 ff e2			ld hl, scratch 
5bb2 cd db 1f			call forthparse 
5bb5 cd 1b 20			call forthexec 
5bb8 cd 2d 1f			call forthexec_cleanup 
5bbb			 
5bbb 3e 78			ld a, display_row_4 
5bbd 11 39 19			ld de, endprog 
5bc0			 
5bc0 cd a3 0b			call update_display		 
5bc3			 
5bc3 3a 25 e7			ld a, (os_last_cmd) 
5bc6 fe 00			cp 0 
5bc8 20 09			jr nz, .startnxt 
5bca cd 97 1b			call next_page_prompt 
5bcd cd 80 0b		        call clear_display 
5bd0 cd a3 0b			call update_display		 
5bd3			 
5bd3				; move onto next startup line? 
5bd3			.startnxt: 
5bd3			 
5bd3 cd e6 0a			call delay250ms 
5bd6 e1				pop hl 
5bd7			 
5bd7 23				inc hl 
5bd8 23				inc hl 
5bd9			 
5bd9 e5				push hl 
5bda 5e				ld e, (hl) 
5bdb 23				inc hl 
5bdc 56				ld d, (hl) 
5bdd e1				pop hl 
5bde				; TODO replace 0 test 
5bde			 
5bde eb				ex de, hl 
5bdf cd d6 0d			call ishlzero 
5be2			;	ld a,e 
5be2			;	add d 
5be2			;	cp 0    ; any left to do? 
5be2 eb				ex de, hl 
5be3 c2 48 5b			jp nz, .start1 
5be6 18 01			jr .startupend 
5be8			 
5be8 e1			.startupend1: pop hl 
5be9			.startupend: 
5be9			 
5be9 cd 80 0b			call clear_display 
5bec cd a3 0b			call update_display 
5bef c9				ret 
5bf0			 
5bf0			 
5bf0			; stack over and underflow checks 
5bf0			 
5bf0			; init the words to detect the under/overflow 
5bf0			 
5bf0			chk_stk_init: 
5bf0				; a vague random number to check so we dont get any "lucky" hits 
5bf0 3e 2d			ld a, 45 
5bf2 6f				ld l, a 
5bf3 00				nop 
5bf4 3e 17			ld a, 23 
5bf6 67				ld h, a 
5bf7			 
5bf7 22 e6 e2			ld (chk_word), hl     ; the word we need to check against 
5bfa			 
5bfa			;	ld (chk_stund), hl	; stack points.... 
5bfa 22 00 ef			ld (chk_stovr), hl 
5bfd 22 2a ea			ld (chk_ret_und), hl 
5c00 22 e8 e9			ld (chk_ret_ovr), hl 
5c03 22 66 e9			ld (chk_loop_ovr), hl 
5c06 22 64 e8			ld (chk_data_ovr), hl 
5c09 c9				ret 
5c0a				 
5c0a			check_stacks: 
5c0a				; check all stack words 
5c0a			 
5c0a e5				push hl 
5c0b d5				push de 
5c0c			 
5c0c			;	ld de,(chk_word) 
5c0c			;	ld hl, (chk_stund)	; stack points.... 
5c0c			;	if DEBUG_STK_FAULT 
5c0c			;		DMARK "FAa" 
5c0c			;		CALLMONITOR 
5c0c			;	endif 
5c0c			;	call cmp16 
5c0c			;	jp z, .chk_faulta 
5c0c			; 
5c0c			;	ld de, sfaultsu 
5c0c			;	jp .chk_fault 
5c0c			 
5c0c 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
5c0f ed 5b e6 e2		ld de,(chk_word) 
5c13				if DEBUG_STK_FAULT 
5c13					DMARK "FAb" 
5c13					CALLMONITOR 
5c13				endif 
5c13 cd cb 0d			call cmp16 
5c16 28 06			jr z, .chk_fault1 
5c18 11 b9 5c			ld de, sfaultso 
5c1b c3 6d 5c			jp .chk_fault 
5c1e			.chk_fault1:  
5c1e 2a 2a ea			ld hl, (chk_ret_und) 
5c21 ed 5b e6 e2		ld de,(chk_word) 
5c25				if DEBUG_STK_FAULT 
5c25					DMARK "FAU" 
5c25					CALLMONITOR 
5c25				endif 
5c25 cd cb 0d			call cmp16 
5c28 ca 31 5c			jp z, .chk_fault2 
5c2b 11 c9 5c			ld de, sfaultru 
5c2e c3 6d 5c			jp .chk_fault 
5c31			.chk_fault2:  
5c31 2a e8 e9			ld hl, (chk_ret_ovr) 
5c34 ed 5b e6 e2		ld de,(chk_word) 
5c38				if DEBUG_STK_FAULT 
5c38					DMARK "FA1" 
5c38					CALLMONITOR 
5c38				endif 
5c38 cd cb 0d			call cmp16 
5c3b ca 44 5c			jp z, .chk_fault3 
5c3e 11 d7 5c			ld de, sfaultro 
5c41 c3 6d 5c			jp .chk_fault 
5c44			.chk_fault3:  
5c44 2a 66 e9			ld hl, (chk_loop_ovr) 
5c47 ed 5b e6 e2		ld de,(chk_word) 
5c4b				if DEBUG_STK_FAULT 
5c4b					DMARK "FA2" 
5c4b					CALLMONITOR 
5c4b				endif 
5c4b cd cb 0d			call cmp16 
5c4e ca 57 5c			jp z, .chk_fault4 
5c51 11 f1 5c			ld de, sfaultlo 
5c54 c3 6d 5c			jp .chk_fault 
5c57			.chk_fault4:  
5c57 2a 64 e8			ld hl, (chk_data_ovr) 
5c5a ed 5b e6 e2		ld de,(chk_word) 
5c5e				if DEBUG_STK_FAULT 
5c5e					DMARK "FA3" 
5c5e					CALLMONITOR 
5c5e				endif 
5c5e cd cb 0d			call cmp16 
5c61 ca 6a 5c			jp z, .chk_fault5 
5c64 11 0b 5d			ld de, sfaultdo 
5c67 c3 6d 5c			jp .chk_fault 
5c6a			 
5c6a			 
5c6a			.chk_fault5:  
5c6a d1				pop de 
5c6b e1				pop hl 
5c6c			 
5c6c c9				ret 
5c6d			 
5c6d cd 80 0b		.chk_fault: 	call clear_display 
5c70 3e 28				ld a, display_row_2 
5c72 cd 93 0b				call str_at_display 
5c75 11 9b 5c				   ld de, .stackfault 
5c78 3e 00				ld a, display_row_1 
5c7a cd 93 0b				call str_at_display 
5c7d 11 71 ee				    ld de, debug_mark 
5c80 3e 11				ld a, display_row_1+17 
5c82 cd 93 0b				call str_at_display 
5c85 cd a3 0b				call update_display 
5c88			 
5c88				; prompt before entering montior for investigating issue 
5c88			 
5c88 3e 78			ld a, display_row_4 
5c8a 11 39 19			ld de, endprog 
5c8d			 
5c8d cd a3 0b			call update_display		 
5c90			 
5c90 cd 97 1b			call next_page_prompt 
5c93			 
5c93 d1				pop de 
5c94 e1				pop hl 
5c95 cd 8d 19				call monitor 
5c98 c3 87 18				jp warmstart 
5c9b					;jp 0 
5c9b					;halt 
5c9b			 
5c9b			 
5c9b			 
5c9b .. 00		.stackfault: 	db "Stack fault:",0 
5ca8			 
5ca8 .. 00		sfaultsu: 	db	"Stack under flow",0 
5cb9 .. 00		sfaultso: 	db	"Stack over flow",0 
5cc9 .. 00		sfaultru:	db "RTS underflow",0 
5cd7 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
5cf1 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
5d0b .. 00		sfaultdo:	db "DTS overflow", 0 
5d18			 
5d18			 
5d18			fault_dsp_under: 
5d18 11 2a 5d			ld de, .dsp_under 
5d1b c3 da 5d			jp .show_fault 
5d1e			 
5d1e			fault_rsp_under: 
5d1e 11 38 5d			ld de, .rsp_under 
5d21 c3 da 5d			jp .show_fault 
5d24			fault_loop_under: 
5d24 11 46 5d			ld de, .loop_under 
5d27 c3 da 5d			jp .show_fault 
5d2a			 
5d2a .. 00		.dsp_under: db "DSP Underflow",0 
5d38 .. 00		.rsp_under: db "RSP Underflow",0 
5d46 .. 00		.loop_under: db "LOOP Underflow",0 
5d55			 
5d55			 
5d55 d5			type_faultn: 	push de 
5d56 e5					push hl 
5d57 cd 80 0b				call clear_display 
5d5a 11 81 5d				   ld de, .typefaultn 
5d5d 3e 00				ld a, display_row_1 
5d5f cd 93 0b				call str_at_display 
5d62 11 71 ee				    ld de, debug_mark 
5d65 3e 11				ld a, display_row_1+17 
5d67 cd 93 0b				call str_at_display 
5d6a cd a3 0b				call update_display 
5d6d			 
5d6d				; prompt before entering montior for investigating issue 
5d6d			 
5d6d 3e 78			ld a, display_row_4 
5d6f 11 39 19			ld de, endprog 
5d72			 
5d72 cd a3 0b			call update_display		 
5d75			 
5d75 cd 97 1b			call next_page_prompt 
5d78			 
5d78 e5					push hl 
5d79 d5					push de 
5d7a cd 8d 19				call monitor 
5d7d c3 87 18				jp warmstart 
5d80 76					halt 
5d81			 
5d81			 
5d81 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
5d98			 
5d98 d5			type_faults: 	push de 
5d99 e5					push hl 
5d9a cd 80 0b				call clear_display 
5d9d 11 c3 5d				   ld de, .typefaults 
5da0 3e 00				ld a, display_row_1 
5da2 cd 93 0b				call str_at_display 
5da5 11 71 ee				    ld de, debug_mark 
5da8 3e 11				ld a, display_row_1+17 
5daa cd 93 0b				call str_at_display 
5dad cd a3 0b				call update_display 
5db0			 
5db0				; prompt before entering montior for investigating issue 
5db0			 
5db0 3e 78			ld a, display_row_4 
5db2 11 39 19			ld de, endprog 
5db5			 
5db5 cd a3 0b			call update_display		 
5db8			 
5db8 cd 97 1b			call next_page_prompt 
5dbb			 
5dbb e1					pop hl 
5dbc d1					pop de 
5dbd cd 8d 19				call monitor 
5dc0 c3 87 18				jp warmstart 
5dc3			 
5dc3			 
5dc3 .. 00		.typefaults: db "STR Type Expected TOS!",0 
5dda			 
5dda			.show_fault: 	 
5dda d5					push de 
5ddb cd 80 0b				call clear_display 
5dde d1					pop de 
5ddf 3e 00				ld a, display_row_1 
5de1 cd 93 0b				call str_at_display 
5de4 11 71 ee				    ld de, debug_mark 
5de7 3e 11				ld a, display_row_1+17 
5de9 cd 93 0b				call str_at_display 
5dec cd a3 0b				call update_display 
5def			 
5def				; prompt before entering montior for investigating issue 
5def			 
5def 3e 78			ld a, display_row_4 
5df1 11 39 19			ld de, endprog 
5df4			 
5df4 cd a3 0b			call update_display		 
5df7			 
5df7 cd 97 1b			call next_page_prompt 
5dfa			 
5dfa e1					pop hl 
5dfb d1					pop de 
5dfc cd 8d 19				call monitor 
5dff			; do a dump to cli and not warmstart so we preserve all of the uwords.  
5dff			; TODO Make optional fault restart to cli or warm boot? 
5dff					;jp warmstart 
5dff c3 df 18				jp cli 
5e02 76					halt 
5e03			 
5e03			; handle the auto run of code from files in storage 
5e03			 
5e03			 
5e03			if STORAGE_SE 
5e03			 
5e03			sprompt3: db "Loading from start-up file?:",0 
5e03			sprompt4: db "(Y=Any key/N=No)",0 
5e03			 
5e03			 
5e03			forth_autoload: 
5e03			 
5e03				; load block 0 of store 1 
5e03				 
5e03				ld a, $fe      ; bit 0 clear 
5e03				ld (spi_device), a 
5e03			 
5e03				call storage_get_block_0 
5e03			 
5e03				ld a, (store_page+STORE_0_AUTOFILE) 
5e03			 
5e03				cp 0 
5e03				ret z     ; auto start not enabled 
5e03			 
5e03				call clear_display 
5e03			 
5e03				; set bank 
5e03			 
5e03					ld a, (store_page+STORE_0_BANKRUN) 
5e03					ld (spi_device), a 
5e03			 
5e03				; get file id to load from and get the file name to display 
5e03			 
5e03					ld a, (store_page+STORE_0_FILERUN) 
5e03			 
5e03					ld l, 0 
5e03					ld h, a 
5e03					ld de, store_page 
5e03			 
5e03					if DEBUG_FORTH_WORDS 
5e03						DMARK "ASp" 
5e03						CALLMONITOR 
5e03					endif 
5e03					call storage_read 
5e03			 
5e03					if DEBUG_FORTH_WORDS 
5e03						DMARK "ASr" 
5e03						CALLMONITOR 
5e03					endif 
5e03			 
5e03					call ishlzero 
5e03					ret z             ; file not found 
5e03			 
5e03					ld a, display_row_2 + 10 
5e03					ld de, store_page+3 
5e03					call str_at_display 
5e03				 
5e03			; 
5e03			 
5e03				ld a, display_row_1+5 
5e03				ld de, sprompt3 
5e03				call str_at_display 
5e03				ld a, display_row_3+15 
5e03				ld de, sprompt4 
5e03				call str_at_display 
5e03			 
5e03				call update_display 
5e03			 
5e03				call cin_wait 
5e03				cp 'n' 
5e03				ret z 
5e03				cp 'N' 
5e03				ret z 
5e03			 
5e03				call delay1s 
5e03			 
5e03				ld a, (store_page+2) 
5e03				ld (store_openmaxext), a    ; save count of ext 
5e03				ld a, 1  
5e03				ld (store_openext), a    ; save count of ext 
5e03			 
5e03			.autof:  
5e03				ld l , a 
5e03				 
5e03				ld a, (store_page) 
5e03				ld h, a	 
5e03				ld de, store_page 
5e03					if DEBUG_FORTH_WORDS 
5e03						DMARK "ASl" 
5e03						CALLMONITOR 
5e03					endif 
5e03					call storage_read 
5e03				call ishlzero 
5e03				ret z 
5e03			;	jr z, .autoend 
5e03			 
5e03					if DEBUG_FORTH_WORDS 
5e03						DMARK "ASc" 
5e03						CALLMONITOR 
5e03					endif 
5e03				ld de, store_page+2 
5e03				ld a, display_row_4 
5e03				call str_at_display 
5e03			 
5e03				call update_display 
5e03				call delay250ms 
5e03			 
5e03			 
5e03			 
5e03				ld hl, store_page+2 
5e03				call forthparse 
5e03				call forthexec 
5e03				call forthexec_cleanup 
5e03			 
5e03				 
5e03				ld a, (store_openext) 
5e03				inc a 
5e03				ld (store_openext), a    ; save count of ext 
5e03			 
5e03				jr .autof 
5e03			;.autofdone: 
5e03			; 
5e03			;		if DEBUG_FORTH_WORDS 
5e03			;			DMARK "ASx" 
5e03			;			CALLMONITOR 
5e03			;		endif 
5e03			;;	call clear_display 
5e03			;	ret 
5e03			 
5e03			 
5e03			 
5e03			endif 
5e03			 
5e03			 
5e03			; eof 
# End of file forth_kernel.asm
5e03			;include "nascombasic.asm" 
5e03			 
5e03			 
5e03			; find out where the code ends if loaded into RAM (for SC114) 
5e03			;endofcode:  
5e03			;	nop 
5e03			 
5e03			 
5e03			; eof 
5e03			 
# End of file main.asm
5e03			;include "firmware_lcd_4x40.asm" 
5e03			;;include "firmware_lcd_4x20.asm" 
5e03			include "firmware_cpm_display.asm" 
5e03			 
5e03			; Serial display interface for SC114 
5e03			 
5e03			 
5e03			display_row_1: equ 0 
5e03			display_row_2: equ display_row_1+display_cols 
5e03			display_row_3: equ display_row_2 + display_cols 
5e03			display_row_4: equ display_row_3 + display_cols 
5e03			 
5e03			kLCDWidth:  EQU display_cols             ;Width in characters 
5e03			kLCD_Line1: EQU 0x00  
5e03			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
5e03			; E1 
5e03			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
5e03			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
5e03			 
5e03			lcd_init: 
5e03				; no init as handled by the SCM bios 
5e03 c9				ret 
5e04			 
5e04			 
5e04			; low level functions for direct screen writes 
5e04			 
5e04			; output char at pos? 
5e04			fLCD_Str: 
5e04			        ;out (SC114_SIO_1_OUT),a 
5e04 c5				push bc 
5e05 d5				push de 
5e06 5f				ld e, a 
5e07			; TODO Replace with CP/M BIOS call 
5e07 0e 02			ld c, $02 
5e09 cd 05 00			call 5 
5e0c d1				pop de 
5e0d c1				pop bc 
5e0e c9				ret 
5e0f			 
5e0f			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
5e0f			fLCD_Pos: 
5e0f				; use ASCII escape to position 
5e0f			        ;out (SC114_SIO_1_OUT),a 
5e0f c5				push bc 
5e10 d5				push de 
5e11 5f				ld e, a 
5e12 0e 02			ld c, $02 
5e14			; TODO Replace with CP/M BIOS call 
5e14 cd 05 00			call 5 
5e17 d1				pop de 
5e18 c1				pop bc 
5e19			 
5e19 c9				ret 
5e1a			 
5e1a			; output char at pos 
5e1a			fLCD_Data: 
5e1a			      ;  out (SC114_SIO_1_OUT),a 
5e1a c5				push bc 
5e1b d5				push de 
5e1c 0e 02			ld c, $02 
5e1e 5f				ld e, a 
5e1f			; TODO Replace with CP/M BIOS call 
5e1f cd 05 00			call 5 
5e22 d1				pop de 
5e23 c1				pop bc 
5e24			 
5e24 c9				ret 
5e25			 
5e25			; ascii cls  
5e25			 
5e25 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
5e29			 
5e29 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
5e40			;.clscpm: db 3, $3c,"$" 
5e40			 
5e40			; write the frame buffer given in hl to hardware  
5e40			write_display: 
5e40			 
5e40			API: equ 0 
5e40			 
5e40			if API 
5e40				push bc 
5e40				ld b, 4 
5e40			 
5e40			        ld (display_write_tmp), hl 	  
5e40			 
5e40				; clear and home cursor 
5e40			 
5e40				ld c, 9 
5e40				ld de, .cls 
5e40			; TODO Replace with CP/M BIOS call 
5e40				call 5 
5e40			 
5e40			 
5e40			.writeln: 
5e40			 
5e40				ld de, (display_write_tmp) 
5e40				ld c, 6 
5e40			; TODO Replace with CP/M BIOS call 
5e40				rst $30 
5e40				ld c, 7 
5e40				rst $30 
5e40			 
5e40				ld hl, (display_write_tmp) 
5e40				ld de, display_cols 
5e40				add hl,de 
5e40				ld (display_write_tmp),hl 
5e40			 
5e40				djnz  .writeln 
5e40			 
5e40				pop bc 
5e40			 
5e40			 
5e40				ret 
5e40			endif 
5e40 e5				push hl 
5e41 c5				push bc 
5e42 d5				push de 
5e43			 
5e43			;	ld c, 2 
5e43			;	;ld de, .cls 
5e43			;	ld a, 27 
5e43			;	rst $30 
5e43			;	ld c, 2 
5e43			;	;ld de, .cls 
5e43			;	ld a, '[' 
5e43			;	rst $30 
5e43			; 
5e43			;	ld c, 2 
5e43			;	;ld de, .cls 
5e43			;	ld a, 'H' 
5e43			;	rst $30 
5e43			; 
5e43			 
5e43			 
5e43			; lots of CR/LF 
5e43			;	ld c, 9 
5e43			;	ld de, .clscpm 
5e43			;	call 5 
5e43			 
5e43			; xterm cls 
5e43 0e 02			ld c, 2 
5e45 1e 1b			ld e, 27 
5e47 cd 05 00			call 5 
5e4a			; cls causes too much flicker 
5e4a			;	ld c, 2 
5e4a			;	ld e, 'c' 
5e4a			;	call 5 
5e4a			 
5e4a			; use xterm home instead 
5e4a 0e 02			ld c, 2 
5e4c 1e 5b			ld e, '[' 
5e4e cd 05 00			call 5 
5e51 0e 02			ld c, 2 
5e53 1e 48			ld e, 'H' 
5e55 cd 05 00			call 5 
5e58			LLL: equ 0 
5e58			 
5e58			if LLL 
5e58			 
5e58				ld c, 2 
5e58				;ld de, .cls 
5e58				ld e, 27 
5e58			; TODO Replace with CP/M BIOS call 
5e58				call 5 
5e58			 
5e58			 
5e58				ld c, 2 
5e58				;ld de, .cls 
5e58				ld e, '[' 
5e58			; TODO Replace with CP/M BIOS call 
5e58				call 5 
5e58				ld c, 2 
5e58				;ld de, .cls 
5e58				ld e, '2' 
5e58			; TODO Replace with CP/M BIOS call 
5e58				call 5 
5e58				ld c, 2 
5e58				;ld de, .cls 
5e58				ld e, 'J' 
5e58			; TODO Replace with CP/M BIOS call 
5e58				call 5 
5e58			 
5e58			endif 
5e58			 
5e58 d1				pop de 
5e59 c1				pop bc 
5e5a e1				pop hl 
5e5b			 
5e5b			 
5e5b 22 cf eb		        ld (display_write_tmp), hl 	  
5e5e 3e 00			ld a, kLCD_Line1 
5e60			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5e60 06 28			ld b, display_cols 
5e62 ed 5b cf eb		ld de, (display_write_tmp) 
5e66 cd e9 5e			call write_len_string 
5e69				 
5e69			 
5e69 e5			push hl 
5e6a d5			push de 
5e6b c5			push bc 
5e6c 0e 02			ld c, 2 
5e6e 1e 0a			ld e, 10 
5e70 cd 05 00			call 5 
5e73 0e 02			ld c, 2 
5e75 1e 0d			ld e, 13 
5e77 cd 05 00			call 5 
5e7a			; TODO Replace with CP/M BIOS call 
5e7a				;rst $30 
5e7a c1			pop bc 
5e7b d1			pop de 
5e7c e1			pop hl 
5e7d			 
5e7d				 
5e7d 2a cf eb			ld hl, (display_write_tmp) 
5e80 11 28 00			ld de, display_cols 
5e83 19				add hl,de 
5e84 22 cf eb			ld (display_write_tmp),hl 
5e87			 
5e87				 
5e87 3e 28			ld a, kLCD_Line2 
5e89			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5e89 06 28			ld b, display_cols 
5e8b ed 5b cf eb		ld de, (display_write_tmp) 
5e8f cd e9 5e			call write_len_string 
5e92				 
5e92 2a cf eb			ld hl, (display_write_tmp) 
5e95 11 28 00			ld de, display_cols 
5e98 19				add hl,de 
5e99 22 cf eb			ld (display_write_tmp),hl 
5e9c			 
5e9c e5			push hl 
5e9d d5			push de 
5e9e c5			push bc 
5e9f 0e 07			ld c, 7 
5ea1			; TODO Replace with CP/M BIOS call 
5ea1				;rst $30 
5ea1 0e 02			ld c, 2 
5ea3 1e 0a			ld e, 10 
5ea5 cd 05 00			call 5 
5ea8 0e 02			ld c, 2 
5eaa 1e 0d			ld e, 13 
5eac cd 05 00			call 5 
5eaf c1			pop bc 
5eb0 d1			pop de 
5eb1 e1			pop hl 
5eb2			 
5eb2				 
5eb2 3e 50			ld a, kLCD_Line3 
5eb4			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
5eb4 06 28			ld b, display_cols 
5eb6 ed 5b cf eb		ld de, (display_write_tmp) 
5eba cd e9 5e			call write_len_string 
5ebd				 
5ebd 2a cf eb			ld hl, (display_write_tmp) 
5ec0 11 28 00			ld de, display_cols 
5ec3 19				add hl,de 
5ec4 22 cf eb			ld (display_write_tmp),hl 
5ec7			 
5ec7 e5			push hl 
5ec8 d5			push de 
5ec9 c5			push bc 
5eca 0e 07			ld c, 7 
5ecc			; TODO Replace with CP/M BIOS call 
5ecc				;rst $30 
5ecc 0e 02			ld c, 2 
5ece 1e 0a			ld e, 10 
5ed0 cd 05 00			call 5 
5ed3 0e 02			ld c, 2 
5ed5 1e 0d			ld e, 13 
5ed7 cd 05 00			call 5 
5eda c1			pop bc 
5edb d1			pop de 
5edc e1			pop hl 
5edd			 
5edd				 
5edd 3e 78			ld a, kLCD_Line4 
5edf			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
5edf 06 28			ld b, display_cols 
5ee1 ed 5b cf eb		ld de, (display_write_tmp) 
5ee5 cd e9 5e			call write_len_string 
5ee8 c9					ret 
5ee9			 
5ee9			 
5ee9				; write out a fixed length string given in b from de 
5ee9			 
5ee9 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
5eea cd 1a 5e		            CALL fLCD_Data      ;Write character to display 
5eed 13				inc de 
5eee 10 f9			djnz write_len_string 
5ef0 c9				ret 
5ef1			 
5ef1			 
5ef1			; eof 
# End of file firmware_cpm_display.asm
5ef1			;include "firmware_key_5x10.asm" 
5ef1			;;include "firmware_key_4x10.asm" 
5ef1			include "firmware_key_cpm.asm" 
5ef1			; Serial keyboard interface for SC114 
5ef1			 
5ef1			 
5ef1			key_init: 
5ef1				; no init as handled by the SCM bios 
5ef1 c9				ret 
5ef2			 
5ef2			 
5ef2			cin_wait: 
5ef2			;	ld a, 0 
5ef2			;	ret 
5ef2			 
5ef2				;in a,(SC114_SIO_1_IN) 
5ef2			        ; Use SCM API to get from whatever console device we are using 
5ef2			 
5ef2			; TODO Replace with CP/M BIOS call 
5ef2 c5				push bc 
5ef3 0e 01			ld c, $01 
5ef5 cd 05 00			call 5 
5ef8 c1				pop bc 
5ef9 c9				ret 
5efa			 
5efa			cin: 
5efa			 
5efa			 
5efa c5				push bc 
5efb			 
5efb				; any key waiting to process? 
5efb			; TODO Replace with CP/M BIOS call 
5efb 0e 06			ld c, $06 
5efd cd 05 00			call 5 
5f00 28 0d			jr z, .cin_skip 
5f02			 
5f02				; yep, get it 
5f02			 
5f02 0e 01			ld c, $01 
5f04			; TODO Replace with CP/M BIOS call 
5f04 cd 05 00			call 5 
5f07			 
5f07 fe 7f			cp $7f     ; back space 
5f09 20 02			jr nz, .skipbs 
5f0b 3e 08			ld a, KEY_BS 
5f0d			.skipbs: 
5f0d			 
5f0d c1				pop bc 
5f0e c9				ret 
5f0f			.cin_skip: 
5f0f 3e 00			ld a, 0 
5f11 c1				pop bc 
5f12 c9				ret 
5f13			 
5f13			 
5f13			 
5f13			 
# End of file firmware_key_cpm.asm
5f13			endofcode:  
5f13			baseram:  
5f13 00				nop 
5f14			 
5f14			heap_start: equ baseram+15  ; Starting address of heap 
5f14			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
5f14			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
5f14			;VDU:  EQU     endofcode           ; BASIC Work space 
5f14			; eof 
5f14			 
# End of file os_mega_cpm.asm
5f14
