# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 5a 18			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
011c			 
011c			 
011c			 
011c			;        nop  
011c			;        nop 
011c			;;	org 05h		; null out bdos call 
011c			; 
011c			;        nop  
011c			;        nop  
011c			;        nop 
011c			;;	org 08h 
011c			;;; 
011c			;;	jp cin		; rst 8 - char in 
011c			;;; 
011c			; 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;        nop 
011c			;	org 010h 
011c			;; 
011c			;	jp cout		; rest 010h  - char out 
011c			;; 
011c			;	org 01bh   
011c			; 
011c			;	;jp  		; rst 01bh   - write string to display 
011c			;	jp str_at_display 
011c			; 
011c			; 
011c			;	org 020h 
011c			; 
011c			;	; jp		 ; rst 020h - read char at screen location 
011c			; 
011c			;	org 028h 
011c			 
011c				; jp		 ; rst 028h  - storage i/o 
011c			 
011c			; 	org 030h 
011c			;	jp break_point_state 
011c			  
011c			; $30  
011c			; org 038h 
011c			; $38 
011c			 
011c			; TODO any more important entry points to add to jump table for easier coding use? 
011c			 
011c			if BASE_KEV = 1  
011c			 
011c				; need to be at $66 for nmi support 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255,0,255,0,255 
011c				db 0,255 
011c				jp nmi 
011c			endif 
011c			 
011c			include "firmware.asm" 
011c			  
011c			; main constants (used here and in firmware)  
011c			  
011c			; TODO have page 0 of storage as bios  
011c			  
011c			Device_A: equ 0h  
011c			Device_B: equ 040h          ; Sound  
011c			  
011c			if BASE_KEV  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_SC114  
011c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			; TODO fixup for CPM  
011c			Device_C: equ 080h          ; Storage and ext cart devices  
011c			endif  
011c			  
011c			Device_D: equ 0c0h             ; Keyboard and LCD  
011c			  
011c			; Odd specific debug points for testing hardware dev  
011c			  
011c			DEBUG_SOUND: equ 0       
011c			DEBUG_STK_FAULT: equ 0  
011c			DEBUG_INPUT: equ 0     ; Debug input entry code  
011c			DEBUG_KEYCINWAIT: equ 0  
011c			DEBUG_KEYCIN: equ 0  
011c			DEBUG_KEY: equ 0  
011c			DEBUG_KEY_MATRIX: equ 0  
011c			DEBUG_STORECF: equ 0  
011c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011c			DEBUG_SPI: equ 0    ; low level spi tests  
011c			  
011c			; Enable many break points  
011c			  
011c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011c			DEBUG_FORTH_JP: equ 0    ; 4  
011c			DEBUG_FORTH_MALLOC: equ 0  
011c			DEBUG_FORTH_MALLOC_INT: equ 0  
011c			DEBUG_FORTH_DOT: equ 1  
011c			DEBUG_FORTH_DOT_WAIT: equ 0  
011c			DEBUG_FORTH_MATHS: equ 0  
011c			DEBUG_FORTH_TOK: equ 0    ; 4  
011c			DEBUG_FORTH_PARSE: equ 0    ; 3  
011c			DEBUG_FORTH: equ 0  ;2  
011c			DEBUG_FORTH_WORDS: equ 1   ; 1  
011c			DEBUG_FORTH_PUSH: equ 1   ; 1  
011c			DEBUG_FORTH_UWORD: equ 1   ; 1  
011c			  
011c			; Enable key point breakpoints  
011c			  
011c			DEBUG_FORTH_DOT_KEY: equ 0  
011c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011c			  
011c			; Debug stack imbalances  
011c			  
011c			ON: equ 1  
011c			OFF: equ 0  
011c			  
011c			DEBUG_STACK_IMB: equ 0  
011c			STACK_IMB_STORE: equ 20  
011c			  
011c			; House keeping and protections  
011c			  
011c			DEBUG_FORTH_STACK_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011c			FORTH_ENABLE_FREE: equ 0  
011c			FORTH_ENABLE_MALLOCFREE: equ 1  
011c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011c			FORTH_ENABLE_FLOATMATH: equ 0  
011c			  
011c			  
011c			CALLMONITOR: macro  
011c			;	call break_point_state  
011c			; now use the break point debug vector  
011c				call debug_vector  
011c				endm  
011c			  
011c			MALLOC_1: equ 1        ; from dk88   
011c			MALLOC_2: equ 0           ; broke  
011c			MALLOC_3: equ 0           ; really broke  
011c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011c			  
011c			if BASE_KEV   
011c			stacksize: equ 256  
011c			  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 512  
011c			endif  
011c			if BASE_SC114  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			if BASE_CPM  
011c			;tos:	equ 0f000h  
011c			stacksize: equ 256  
011c			STACK_RET_SIZE: equ 64  
011c			STACK_LOOP_SIZE: equ 128  
011c			STACK_DATA_SIZE: equ 256  
011c			endif  
011c			  
011c			;if STORAGE_SE == 0  
011c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011c			;endif  
011c			  
011c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011c			  
011c			STORE_0_AUTORUN: equ $20  
011c			  
011c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011c			  
011c			STORE_0_AUTOFILE: equ $21  
011c			STORE_0_BANKRUN: equ $23  
011c			STORE_0_FILERUN: equ $24  
011c			  
011c			; Block 0 offsets for settings  
011c			  
011c			; if set then skip prompt for start up and accept all  
011c			  
011c			STORE_0_QUICKSTART: equ $25  
011c			  
011c			; Blocks where directory table is held  
011c			  
011c			; Reducing the number of entries increases the max file size  
011c			  
011c			;STORE_DIR_START: equ 1  
011c			;STORE_DIR_END: equ 33  
011c			  
011c			; Blocks from where file data is stored  
011c			  
011c			;STORE_DATA_START: equ STORE_DIR_END + 1  
011c			  
011c			; Block indicators (<32 are data files)  
011c			  
011c			;STORE_BLOCK_CFG: equ $8f       ; config block  
011c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011c			;STORE_BLOCK_FREE: equ $85       ; data block free  
011c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011c			  
011c			  
011c			  
011c			; Directory entry flags  
011c			  
011c			;STORE_DIR_FREE: equ 0  
011c			;STORE_DIR_FILE:  equ 1  
011c			  
011c			; Structure offsets to directory entries  
011c			;STORE_DE_FLAG: equ 0  
011c			;STORE_DE_MAXEXT: equ 1  
011c			;STORE_DE_FILENAME: equ 2  
011c			  
011c			; Structure offsets to block 0  
011c			  
011c			;STORE_BK0_ISFOR: equ 1  
011c			;STORE_BK0_LABEL: equ 3  
011c			  
011c			; memory allocation   
011c			  
011c			chk_stund: equ tos+2           ; underflow check word  
011c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011c			  
011c			; keyscan table needs rows x cols buffer  
011c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011c			  
011c			keyscan_table_row1: equ chk_stovr -key_cols-1  
011c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011c			keyscan_scancol: equ keyscan_table-key_cols  
011c			;keyscan_table_len: equ key_rows*key_cols  
011c			;keybufptr: equ keyscan_table - 2  
011c			;keysymbol: equ keybufptr - 1  
011c			key_held: equ keyscan_scancol-1	; currently held  
011c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011c			key_fa: equ key_repeat_ct -1 ;  
011c			key_fb: equ key_fa -1 ;  
011c			key_fc: equ key_fb -1 ;  
011c			key_fd: equ key_fc -1 ;  
011c			key_face_held: equ key_fd - 1   
011c			  
011c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011c			  
011c			hardware_config: equ key_face_held - 10  
011c			  
011c			; hardware config switches  
011c			; TODO add bitmasks on includes for hardware  
011c			; high byte for expansion ids  
011c			;     0000 0000  no card inserted  
011c			;     0000 0001  storage card inserted  
011c			;     0000 0010  spi sd card active  
011c			  
011c			;       
011c			; low byte:  
011c			;     0000 0001   4x4 keypad  
011c			;     0000 0010   full keyboard  
011c			;     0000 0011   spi/ext keyboard  
011c			;     0000 0100   20x4 lcd  
011c			;     0000 1000   40x4 lcd  
011c			;     0000 1100   spi/ext display  
011c			;     0001 0000   ide interface available  
011c			  
011c			hardware_word: equ hardware_config - 2  
011c			  
011c			; debug marker - optional display of debug point on the debug screens  
011c			  
011c			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011c			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011c			  
011c			debug_mark: equ debug_vector - 4  
011c			  
011c			; input_str vars  
011c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011c			input_size: equ input_start -1  ; number of chars  
011c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011c			input_len: equ input_cur_onoff - 5 ; length of current input  
011c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011c			  
011c			CUR_BLINK_RATE: equ 15  
011c			  
011c			key_actual_pressed: equ input_cursor - 1   
011c			key_symbol: equ key_actual_pressed - 1   
011c			key_shift: equ key_symbol - 1   
011c			  
011c			; Display allocation  
011c			  
011c			;display_rows: equ 4     ; move out to mini and mega files  
011c			;display_cols: equ 20  
011c			  
011c			display_fb_len: equ display_rows*display_cols  
011c			  
011c			; primary frame buffer     
011c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011c			; working frame buffers  
011c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011c			display_fb3: equ  display_fb1-display_fb_len - 1  
011c			display_fb2: equ  display_fb3-display_fb_len - 1  
011c			;  
011c			; pointer to active frame buffer  
011c			display_fb_active: equ display_fb2 - 2  
011c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011c			display_write_tmp: equ display_lcde1e2 - 2  
011c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011c			  
011c			;  
011c			  
011c			;; can load into de directory  
011c			cursor_col: equ display_active-1  
011c			cursor_row: equ cursor_col-1  
011c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011c			  
011c			; maths vars  
011c			  
011c			LFSRSeed: equ cursor_shape -20   
011c			randData: equ LFSRSeed - 2  
011c			xrandc: equ randData - 2  
011c			stackstore: equ xrandc - 2  
011c			seed1: equ  stackstore -2   
011c			seed2: equ seed1 - 2  
011c			  
011c			; cf storage vars  
011c			  
011c			iErrorNum:  equ seed2-1         ;Error number  
011c			iErrorReg:  equ iErrorNum -1              ;Error register  
011c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011c			  
011c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011c			  
011c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011c			  
011c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011c			store_tmpid: equ store_tmp3 - 1		; page temp id  
011c			store_tmpext: equ store_tmpid - 1		; file extent temp  
011c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011c			;  
011c			; spi vars  
011c			  
011c			  
011c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011c			spi_device_id: equ spi_device - 1    ; human readable bank number  
011c			  
011c			;;;;; forth cli params  
011c			  
011c			; TODO use a different frame buffer for forth???  
011c			  
011c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011c			  
011c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011c			  
011c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011c			  
011c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011c			  
011c			; os/forth token vars  
011c			  
011c			os_last_cmd: equ os_var_array-255  
011c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011c			os_current_i: equ os_cli_cmd-2  
011c			os_cur_ptr: equ os_current_i-2  
011c			os_word_scratch: equ os_cur_ptr-30  
011c			os_tok_len: equ os_word_scratch - 2  
011c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011c			os_tok_malloc: equ os_tok_ptr - 2  
011c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011c			execscratch: equ os_input-255        ; exec cmd eval buffer  
011c			scratch: equ execscratch-255  
011c			  
011c			  
011c			; temp locations for new word processing to save on adding more   
011c			  
011c			os_new_malloc: equ scratch-2  
011c			os_new_parse_len: equ os_new_malloc - 2  
011c			os_new_word_len: equ os_new_parse_len - 2  
011c			os_new_work_ptr: equ os_new_word_len - 2  
011c			os_new_src_ptr: equ os_new_work_ptr - 2  
011c			os_new_exec: equ os_new_src_ptr - 2  
011c			os_new_exec_ptr: equ os_new_exec - 2  
011c			  
011c			; resume memory alloocations....  
011c			  
011c			;os_view_disable: equ os_new_exec_ptr - 1  
011c			os_view_af: equ os_new_exec_ptr - 2  
011c			os_view_hl: equ os_view_af -2  
011c			os_view_de: equ os_view_hl - 2  
011c			os_view_bc: equ os_view_de - 2  
011c			  
011c			; stack checksum word  
011c			if DEBUG_STACK_IMB  
011c				curframe: equ  os_view_de - 5  
011c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			else  
011c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011c			endif  
011c			  
011c			; with data stack could see memory filled with junk. need some memory management   
011c			; malloc and free entry points added  
011c			  
011c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			;heap_end: equ free_list-1  ; Starting address of heap  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			  
011c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011c			heap_end: equ chk_word-1  ; Starting address of heap  
011c			  
011c			  
011c			;if BASE_KEV   
011c			;heap_start: equ 0800eh  ; Starting address of heap  
011c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;heap_start: equ baseram+15  ; Starting address of heap  
011c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011c			;endif  
011c			  
011c			  
011c			;;;;  
011c			  
011c			  
011c			; change below to point to last memory alloc above  
011c			topusermem:  equ   heap_start  
011c			  
011c			;if BASE_KEV   
011c			;baseusermem: equ 08000h  
011c			;endif  
011c			  
011c			;if BASE_SC114  
011c			;;aseusermem:     equ    12  
011c			;baseusermem:     equ    prompt  
011c			;;baseusermem:     equ    endofcode  
011c			;endif  
011c			  
011c			  
011c			; **********************************************************************  
011c			; **  Constants  
011c			; **********************************************************************  
011c			  
011c			; Constants used by this code module  
011c			kDataReg:   EQU Device_D           ;PIO port A data register  
011c			kContReg:   EQU Device_D+2           ;PIO port A control register  
011c			  
011c			  
011c			portbdata:  equ Device_D+1    ; port b data  
011c			portbctl:   equ Device_D+3    ; port b control  
011c			  
011c			  
011c			;KEY_SHIFT:   equ 5  
011c			;KEY_SYMBOLSHIFT:  equ 6  
011c			  
011c			KEY_SHIFTLOCK: equ 4  
011c			  
011c			  
011c			KEY_UP: equ 5  
011c			KEY_NEXTWORD: equ 6  
011c			KEY_PREVWORD: equ 7  
011c			KEY_BS: equ 8  
011c			KEY_TAB:  equ 9  
011c			KEY_DOWN: equ 10  
011c			KEY_LEFT: equ 11  
011c			KEY_RIGHT: equ 12  
011c			KEY_CR:   equ 13  
011c			KEY_HOME: equ 14  
011c			KEY_END: equ 15  
011c			  
011c			KEY_F1: equ 16  
011c			KEY_F2: equ 17  
011c			KEY_F3: equ 18  
011c			KEY_F4: equ 19  
011c			  
011c			KEY_F5: equ 20  
011c			KEY_F6: equ 21  
011c			KEY_F7: equ 22  
011c			KEY_F8: equ 23  
011c			  
011c			KEY_F9: equ 24  
011c			KEY_F10: equ 25  
011c			KEY_F11: equ 26  
011c			KEY_F12: equ 27  
011c			  
011c			;if DEBUG_KEY  
011c			;	KEY_MATRIX_NO_PRESS: equ '.'  
011c			;	KEY_SHIFT:   equ '.'  
011c			;	KEY_SYMBOLSHIFT:  equ '.'  
011c			;else  
011c				KEY_SHIFT:   equ '~'  
011c				KEY_SYMBOLSHIFT:  equ '~'  
011c				KEY_MATRIX_NO_PRESS: equ '~'  
011c			;endi  
011c			  
011c			  
011c			  
011c			  
011c			; Macro to make adding debug marks easier  
011c			  
011c			DMARK: macro str  
011c				push af  
011c				ld a, (.dmark)  
011c				ld (debug_mark),a  
011c				ld a, (.dmark+1)  
011c				ld (debug_mark+1),a  
011c				ld a, (.dmark+2)  
011c				ld (debug_mark+2),a  
011c				jr .pastdmark  
011c			.dmark: db str  
011c			.pastdmark: pop af  
011c			  
011c			endm  
011c			  
011c			  
011c			; macro to detect for stack imbalances  
011c			  
011c			include "stackimbal.asm"  
011c			; Macro and code to detect stock imbalances 
011c			 
011c			SPPUSH: equ 0 
011c			 
011c			; Add a stack frame which can be checked before return 
011c			 
011c			STACKFRAME: macro onoff frame1 frame2 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c						exx 
011c			 
011c						ld de, frame1 
011c						ld a, d 
011c						ld hl, curframe 
011c						call hexout 
011c						ld a, e 
011c						ld hl, curframe+2 
011c						call hexout 
011c			  
011c						ld hl, frame1 
011c						push hl 
011c						ld hl, frame2 
011c						push hl 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			endm 
011c			 
011c			STACKFRAMECHK: macro onoff frame1 frame2 
011c			 
011c					 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						exx 
011c						; check stack frame SP 
011c			 
011c						ld hl, frame2 
011c						pop de   ; frame2 
011c			 
011c						call cmp16 
011c						jr nz, .spnosame 
011c						 
011c			 
011c						ld hl, frame1 
011c						pop de   ; frame1 
011c			 
011c						call cmp16 
011c						jr z, .spfrsame 
011c			 
011c						.spnosame: call showsperror 
011c			 
011c						.spfrsame: nop 
011c			 
011c						exx 
011c					endif 
011c					 
011c				endif 
011c			 
011c			 
011c			endm 
011c			 
011c			 
011c			; for a sub routine, wrap SP collection and comparisons 
011c			 
011c			; Usage: 
011c			; 
011c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011c			 
011c			SAVESP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c						; save current SP 
011c			 
011c						ld (store_sp+(storeword*4)), sp 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			CHECKSP: macro onoff storeword 
011c			 
011c				if DEBUG_STACK_IMB 
011c					if onoff 
011c			 
011c						; save SP after last save 
011c				 
011c						ld (store_sp+(storeword*4)+2), sp 
011c			 
011c						push hl 
011c						ld hl, store_sp+(storeword*4) 
011c						call check_stack_sp  
011c						pop hl 
011c			 
011c			 
011c					endif 
011c					 
011c				endif 
011c			 
011c			endm 
011c			 
011c			if DEBUG_STACK_IMB 
011c			 
011c			check_stack_sp: 
011c					push de 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					push de 
011c			 
011c			 
011c					ld e, (hl) 
011c					inc hl 
011c					ld d, (hl) 
011c					inc hl 
011c			 
011c					pop hl 
011c			 
011c			 
011c					; check to see if the same 
011c			 
011c					call cmp16 
011c					jr z, .spsame 
011c			 
011c					; not same 
011c			 
011c					call showsperror 
011c			.spsame: 
011c			 
011c					pop de 
011c			 
011c					ret 
011c			 
011c			.sperr:  db "Stack imbalance",0 
011c			 
011c			 
011c			showsperror: 
011c			 
011c			 
011c				push hl 
011c				push af 
011c				push de 
011c				call clear_display 
011c				ld de, .sperr 
011c				ld a,0 
011c			;	ld de,os_word_scratch 
011c				call str_at_display 
011c				ld a, display_row_1+17 
011c				ld de, debug_mark 
011c				call str_at_display 
011c				ld a, 0 
011c				ld (curframe+4),a 
011c				ld hl, curframe 
011c				ld de, os_word_scratch 
011c				ld a, display_row_4 
011c				call str_at_display 
011c				call update_display 
011c				;call break_point_state 
011c				call cin_wait 
011c			 
011c			;	ld a, ' ' 
011c			;	ld (os_view_disable), a 
011c				call bp_on 
011c				pop de	 
011c				pop af 
011c				pop hl 
011c				CALLMONITOR 
011c				ret 
011c			 
011c			endif 
011c			 
011c			 
011c			 
011c			; eof 
# End of file stackimbal.asm
011c			  
011c			;TODO macro to calc col and row offset into screen  
011c			  
011c			  
011c			  
011c			hardware_init:  
011c			  
011c				  
011c			  
011c					;ld a, 0  
011c					;ld (hardware_diag), a  
011c			  
011c					; clear all the buffers  
011c			  
011c 21 10 ed				ld hl, display_fb1  
011f 22 cc eb				ld (display_fb_active), hl  
0122			  
0122 cd ba 0b				call clear_display  
0125			  
0125 21 ce eb				ld hl, display_fb2  
0128 22 cc eb				ld (display_fb_active), hl  
012b			  
012b cd ba 0b				call clear_display  
012e			  
012e					; init primary frame buffer area  
012e 21 b1 ed				ld hl, display_fb0  
0131 22 cc eb				ld (display_fb_active), hl  
0134			  
0134 cd ba 0b				call clear_display  
0137			  
0137			  
0137 cd 90 64				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013a			  
013a cd 7e 65			call key_init  
013d cd 9f 01			call storage_init  
0140			  
0140				; setup malloc functions  
0140			  
0140				if MALLOC_1  
0140 cd 8a 12				call  heap_init  
0143				endif  
0143				if MALLOC_4  
0143					call  heap_init  
0143				endif  
0143			  
0143				; init sound hardware if present  
0143			  
0143				if SOUND_ENABLE  
0143					call sound_init  
0143				endif  
0143			  
0143				; lcd test sequence  
0143					  
0143 cd dd 0b			call update_display  
0146 cd f2 0a			call delay1s  
0149 3e 2b			ld a,'+'  
014b cd bf 0b			call fill_display  
014e cd dd 0b			call update_display  
0151 cd f2 0a			call delay1s  
0154 3e 2a			ld a,'*'  
0156 cd bf 0b			call fill_display  
0159 cd dd 0b			call update_display  
015c cd f2 0a			call delay1s  
015f 3e 2d			ld a,'-'  
0161 cd bf 0b			call fill_display  
0164 cd dd 0b			call update_display  
0167 cd f2 0a			call delay1s  
016a			  
016a			; boot splash screen  
016a			if display_cols == 20	  
016a			        ld a, display_row_1    
016a			else  
016a 3e 0a		        ld a, display_row_1 +10   
016c			endif  
016c 11 b8 17			ld de, prom_bootmsg  
016f cd cd 0b			call str_at_display  
0172 cd dd 0b			call update_display  
0175			  
0175			  
0175 cd f2 0a			call delay1s  
0178 cd f2 0a			call delay1s  
017b			if display_cols == 20	  
017b			            LD   A, display_row_3+2  
017b			else  
017b 3e 5c		            LD   A, display_row_3+12  
017d			endif  
017d 11 cd 17			ld de, prom_bootmsg1  
0180 cd cd 0b			call str_at_display  
0183 cd dd 0b			call update_display  
0186 cd f2 0a			call delay1s  
0189 cd f2 0a			call delay1s  
018c			  
018c			;	ld a, display_row_4+3  
018c			;	ld de, bootmsg2  
018c			;	call str_at_display  
018c			;	call update_display  
018c			;	call delay1s  
018c			;	call delay1s  
018c			  
018c			; debug mark setup  
018c			  
018c 3e 5f		ld a, '_'  
018e 32 6b ee		ld (debug_mark),a  
0191 32 6c ee		ld (debug_mark+1),a  
0194 32 6d ee		ld (debug_mark+2),a  
0197 3e 00		ld a,0  
0199 32 6e ee		ld (debug_mark+3),a  
019c			  
019c c9					ret  
019d			  
019d			  
019d			;bootmsg2:	db "Firmware v0.1",0  
019d			  
019d			; a 4x20 lcd  
019d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019d			  
019d			;if display_cols == 20  
019d			;	include "firmware_lcd_4x20.asm"  
019d			;endif  
019d			  
019d			;if display_cols == 40  
019d			;	include "firmware_lcd_4x40.asm"  
019d			;endif  
019d			  
019d			;  
019d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019d			; TODO abstract the bit bang video out interface for dual display  
019d			; TODO wire video out to tx pin on rc2014 bus  
019d			  
019d			; must supply cin, and cin_wait for low level hardware abstraction   
019d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019d			; test scancode  
019d			  
019d			;;;;;  
019d			;;;  
019d			; Moved out to mini and maxi versions  
019d			;  
019d			; include "firmware_key_4x4.asm"  
019d			; using existing 4 wire x 4 resistor array for input  
019d			;include "firmware_key_4x10.asm"  
019d			; need to mod the board for 5 rows due to resistor array  
019d			;include "firmware_key_5x10.asm"  
019d			  
019d			; storage hardware interface  
019d			  
019d			; use microchip serial eeprom for storage  
019d			  
019d			  
019d			if STORAGE_SE  
019d				include "firmware_spi.asm"  
019d				include "firmware_seeprom.asm"  
019d			else  
019d			   ; create some stubs for the labels  
019d c9			se_readbyte: ret  
019e c9			se_writebyte: ret  
019f c9			storage_init: ret  
01a0			  
01a0			endif  
01a0			  
01a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01a0			;include "firmware_cf.asm"  
01a0			  
01a0			; load up high level storage hardward abstractions  
01a0			include "firmware_storage.asm"  
01a0			 
01a0			; persisent storage hardware abstraction layer  
01a0			 
01a0			 
01a0			 
01a0			; Block 0 on storage is a config state 
01a0			 
01a0			 
01a0			 
01a0			; TODO add read phy block and write phy block functions 
01a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01a0			 
01a0			; Abstraction layer  
01a0			 
01a0			; Logocial block size is same size as physical size - using tape concept 
01a0			 
01a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01a0			 
01a0			 
01a0			 
01a0			; Filesystem layout (Logical layout) 
01a0			; 
01a0			; Block 0 - Bank config  
01a0			; 
01a0			;      Byte - 0 file id counter 
01a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01a0			;      Byte - 3-20 zero terminated bank label 
01a0			; 
01a0			; Block 1 > File storage 
01a0			; 
01a0			;      Byte 0 file id    - block 0 file details 
01a0			;      Byte 1 block id - block 0 is file  
01a0			;            Byte 2-15 - File name 
01a0			; 
01a0			;       - to end of block data 
01a0			; 
01a0			 
01a0			; Get ID for the file named in pointer held HL 
01a0			; Returns ID in HL = 255 if no file found 
01a0			 
01a0			storage_getid: 
01a0			 
01a0 22 73 ea			ld (store_tmp1), hl 
01a3			 
01a3				if DEBUG_STORESE 
01a3					DMARK "SGI" 
01a3 f5				push af  
01a4 3a b8 01			ld a, (.dmark)  
01a7 32 6b ee			ld (debug_mark),a  
01aa 3a b9 01			ld a, (.dmark+1)  
01ad 32 6c ee			ld (debug_mark+1),a  
01b0 3a ba 01			ld a, (.dmark+2)  
01b3 32 6d ee			ld (debug_mark+2),a  
01b6 18 03			jr .pastdmark  
01b8 ..			.dmark: db "SGI"  
01bb f1			.pastdmark: pop af  
01bc			endm  
# End of macro DMARK
01bc					CALLMONITOR 
01bc cd 6f ee			call debug_vector  
01bf				endm  
# End of macro CALLMONITOR
01bf				endif 
01bf				; get block 0 and set counter for number of files to scan 
01bf			 
01bf cd 2a 03			call storage_get_block_0 
01c2			 
01c2 3a 7a ea			ld a, (store_page) 
01c5 47				ld b, a 
01c6			 
01c6				; get extent 0 of each file id 
01c6			 
01c6				if DEBUG_STORESE 
01c6					DMARK "SGc" 
01c6 f5				push af  
01c7 3a db 01			ld a, (.dmark)  
01ca 32 6b ee			ld (debug_mark),a  
01cd 3a dc 01			ld a, (.dmark+1)  
01d0 32 6c ee			ld (debug_mark+1),a  
01d3 3a dd 01			ld a, (.dmark+2)  
01d6 32 6d ee			ld (debug_mark+2),a  
01d9 18 03			jr .pastdmark  
01db ..			.dmark: db "SGc"  
01de f1			.pastdmark: pop af  
01df			endm  
# End of macro DMARK
01df					CALLMONITOR 
01df cd 6f ee			call debug_vector  
01e2				endm  
# End of macro CALLMONITOR
01e2				endif 
01e2 60			.getloop:	ld h, b 
01e3 2e 00				ld l, 0 
01e5 c5					push bc 
01e6			 
01e6 11 7a ea				ld de, store_page 
01e9				if DEBUG_STORESE 
01e9					DMARK "SGr" 
01e9 f5				push af  
01ea 3a fe 01			ld a, (.dmark)  
01ed 32 6b ee			ld (debug_mark),a  
01f0 3a ff 01			ld a, (.dmark+1)  
01f3 32 6c ee			ld (debug_mark+1),a  
01f6 3a 00 02			ld a, (.dmark+2)  
01f9 32 6d ee			ld (debug_mark+2),a  
01fc 18 03			jr .pastdmark  
01fe ..			.dmark: db "SGr"  
0201 f1			.pastdmark: pop af  
0202			endm  
# End of macro DMARK
0202					CALLMONITOR 
0202 cd 6f ee			call debug_vector  
0205				endm  
# End of macro CALLMONITOR
0205				endif 
0205 cd d2 07				call storage_read 
0208 cd 10 0e				call ishlzero 
020b 28 2d				jr z, .gap 
020d					 
020d					; have a file name read. Is it one we want. 
020d			 
020d 2a 73 ea				ld hl, (store_tmp1) 
0210 11 7d ea				ld de, store_page+3   ; file name 
0213			 
0213				if DEBUG_STORESE 
0213					DMARK "SGc" 
0213 f5				push af  
0214 3a 28 02			ld a, (.dmark)  
0217 32 6b ee			ld (debug_mark),a  
021a 3a 29 02			ld a, (.dmark+1)  
021d 32 6c ee			ld (debug_mark+1),a  
0220 3a 2a 02			ld a, (.dmark+2)  
0223 32 6d ee			ld (debug_mark+2),a  
0226 18 03			jr .pastdmark  
0228 ..			.dmark: db "SGc"  
022b f1			.pastdmark: pop af  
022c			endm  
# End of macro DMARK
022c					CALLMONITOR 
022c cd 6f ee			call debug_vector  
022f				endm  
# End of macro CALLMONITOR
022f				endif 
022f cd 7d 12				call strcmp 
0232 20 06				jr nz, .gap   ; not this one 
0234			 
0234 c1				        pop bc 
0235			 
0235 26 00				ld h, 0 
0237 68					ld l, b 
0238 18 22				jr .getdone 
023a						 
023a			 
023a			 
023a			 
023a			.gap: 
023a				if DEBUG_STORESE 
023a					DMARK "SGg" 
023a f5				push af  
023b 3a 4f 02			ld a, (.dmark)  
023e 32 6b ee			ld (debug_mark),a  
0241 3a 50 02			ld a, (.dmark+1)  
0244 32 6c ee			ld (debug_mark+1),a  
0247 3a 51 02			ld a, (.dmark+2)  
024a 32 6d ee			ld (debug_mark+2),a  
024d 18 03			jr .pastdmark  
024f ..			.dmark: db "SGg"  
0252 f1			.pastdmark: pop af  
0253			endm  
# End of macro DMARK
0253					CALLMONITOR 
0253 cd 6f ee			call debug_vector  
0256				endm  
# End of macro CALLMONITOR
0256				endif 
0256			 
0256 c1					pop bc 
0257 10 89				djnz .getloop 
0259 21 ff 00				ld hl, 255 
025c			.getdone: 
025c			 
025c				if DEBUG_STORESE 
025c					DMARK "SGe" 
025c f5				push af  
025d 3a 71 02			ld a, (.dmark)  
0260 32 6b ee			ld (debug_mark),a  
0263 3a 72 02			ld a, (.dmark+1)  
0266 32 6c ee			ld (debug_mark+1),a  
0269 3a 73 02			ld a, (.dmark+2)  
026c 32 6d ee			ld (debug_mark+2),a  
026f 18 03			jr .pastdmark  
0271 ..			.dmark: db "SGe"  
0274 f1			.pastdmark: pop af  
0275			endm  
# End of macro DMARK
0275					CALLMONITOR 
0275 cd 6f ee			call debug_vector  
0278				endm  
# End of macro CALLMONITOR
0278				endif 
0278			 
0278 c9				ret 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			 
0279			; Read Block 
0279			; ---------- 
0279			; 
0279			; With current bank 
0279			;  
0279			; Get block number to read 
0279			; Load physical blocks starting at start block into buffer 
0279			 
0279			; de points to buffer to use 
0279			; hl holds logical block number  
0279			 
0279			storage_read_block: 
0279			 
0279				; TODO bank selection 
0279			 
0279				; for each of the physical blocks read it into the buffer 
0279 06 40			ld b, STORE_BLOCK_PHY 
027b			 
027b				if DEBUG_STORESE 
027b d5					push de 
027c				endif 
027c				 
027c			.rl1:    
027c			 
027c				; read physical block at hl into de 
027c			        ; increment hl and de to next read position on exit 
027c			 
027c e5				push hl 
027d d5				push de	 
027e c5				push bc 
027f			;	if DEBUG_STORESE 
027f			;		push af 
027f			;		ld a, 'R' 
027f			;		ld (debug_mark),a 
027f			;		pop af 
027f			;		CALLMONITOR 
027f			;	endif 
027f cd 9d 01			call se_readbyte 
0282			;	if DEBUG_STORESE 
0282			;		ld a,(spi_portbyte) 
0282			;		ld l, a 
0282			;		push af 
0282			;		ld a, '1' 
0282			;		ld (debug_mark),a 
0282			;		pop af 
0282			;		CALLMONITOR 
0282			;	endif 
0282 c1				pop bc 
0283 d1				pop de 
0284 e1				pop hl 
0285 12				ld (de),a 
0286 23				inc hl 
0287 13				inc de 
0288			 
0288			;	if DEBUG_STORESE 
0288			;		push af 
0288			;		ld a, 'r' 
0288			;		ld (debug_mark),a 
0288			;		pop af 
0288			;		CALLMONITOR 
0288			;	endif 
0288			 
0288 10 f2			djnz .rl1 
028a			 
028a				if DEBUG_STORESE 
028a					DMARK "SRB" 
028a f5				push af  
028b 3a 9f 02			ld a, (.dmark)  
028e 32 6b ee			ld (debug_mark),a  
0291 3a a0 02			ld a, (.dmark+1)  
0294 32 6c ee			ld (debug_mark+1),a  
0297 3a a1 02			ld a, (.dmark+2)  
029a 32 6d ee			ld (debug_mark+2),a  
029d 18 03			jr .pastdmark  
029f ..			.dmark: db "SRB"  
02a2 f1			.pastdmark: pop af  
02a3			endm  
# End of macro DMARK
02a3 d1					pop de 
02a4			; 
02a4			;		push af 
02a4			;		ld a, 'R' 
02a4			;		ld (debug_mark),a 
02a4			;		pop af 
02a4					CALLMONITOR 
02a4 cd 6f ee			call debug_vector  
02a7				endm  
# End of macro CALLMONITOR
02a7				endif 
02a7 c9				ret	 
02a8				 
02a8			 
02a8			; File Size 
02a8			; --------- 
02a8			; 
02a8			;   hl file id 
02a8			; 
02a8			;  returns in hl the number of blocks 
02a8			 
02a8			storage_file_size: 
02a8 5d				ld e, l 
02a9 16 00			ld d, 0 
02ab 21 40 00			ld hl, STORE_BLOCK_PHY 
02ae					if DEBUG_FORTH_WORDS 
02ae						DMARK "SIZ" 
02ae f5				push af  
02af 3a c3 02			ld a, (.dmark)  
02b2 32 6b ee			ld (debug_mark),a  
02b5 3a c4 02			ld a, (.dmark+1)  
02b8 32 6c ee			ld (debug_mark+1),a  
02bb 3a c5 02			ld a, (.dmark+2)  
02be 32 6d ee			ld (debug_mark+2),a  
02c1 18 03			jr .pastdmark  
02c3 ..			.dmark: db "SIZ"  
02c6 f1			.pastdmark: pop af  
02c7			endm  
# End of macro DMARK
02c7						CALLMONITOR 
02c7 cd 6f ee			call debug_vector  
02ca				endm  
# End of macro CALLMONITOR
02ca					endif 
02ca cd ac 05			call storage_findnextid 
02cd			 
02cd cd 10 0e			call ishlzero 
02d0			;	ld a, l 
02d0			;	add h 
02d0			;	cp 0 
02d0 c8				ret z			; block not found so EOF 
02d1			 
02d1 11 7a ea			ld de, store_page 
02d4 cd 79 02			call storage_read_block 
02d7			 
02d7 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
02da 6f				ld l, a 
02db 26 00			ld h, 0 
02dd c9			 	ret 
02de			 
02de			 
02de			; Write Block 
02de			; ----------- 
02de			; 
02de			; With current bank 
02de			;  
02de			; Get block number to write 
02de			; Write physical blocks starting at start block from buffer 
02de			  
02de			storage_write_block: 
02de				; TODO bank selection 
02de			 
02de				; for each of the physical blocks read it into the buffer 
02de 06 40			ld b, STORE_BLOCK_PHY 
02e0			 
02e0				if DEBUG_STORESE 
02e0					DMARK "SWB" 
02e0 f5				push af  
02e1 3a f5 02			ld a, (.dmark)  
02e4 32 6b ee			ld (debug_mark),a  
02e7 3a f6 02			ld a, (.dmark+1)  
02ea 32 6c ee			ld (debug_mark+1),a  
02ed 3a f7 02			ld a, (.dmark+2)  
02f0 32 6d ee			ld (debug_mark+2),a  
02f3 18 03			jr .pastdmark  
02f5 ..			.dmark: db "SWB"  
02f8 f1			.pastdmark: pop af  
02f9			endm  
# End of macro DMARK
02f9			 
02f9					;push af 
02f9					;ld a, 'W' 
02f9					;ld (debug_mark),a 
02f9					;pop af 
02f9					CALLMONITOR 
02f9 cd 6f ee			call debug_vector  
02fc				endm  
# End of macro CALLMONITOR
02fc				endif 
02fc			 
02fc			; might not be working 
02fc			;	call se_writepage 
02fc			 
02fc			;	ret 
02fc			; 
02fc			 
02fc			 
02fc			 
02fc			.wl1:    
02fc			 
02fc				; read physical block at hl into de 
02fc			        ; increment hl and de to next read position on exit 
02fc			 
02fc e5				push hl 
02fd d5				push de	 
02fe c5				push bc 
02ff 1a				ld a,(de) 
0300				;if DEBUG_STORESE 
0300			;		push af 
0300			;		ld a, 'W' 
0300			;		ld (debug_mark),a 
0300			;		pop af 
0300			;		CALLMONITOR 
0300			;	endif 
0300 cd 9e 01			call se_writebyte 
0303			;	call delay250ms 
0303 00				nop 
0304 00				nop 
0305 00				nop 
0306			;	if DEBUG_STORESE 
0306			;		push af 
0306			;		ld a, 'w' 
0306			;		ld (debug_mark),a 
0306			;		pop af 
0306			;		CALLMONITOR 
0306			;	endif 
0306 c1				pop bc 
0307 d1				pop de 
0308 e1				pop hl 
0309 23				inc hl 
030a 13				inc de 
030b			 
030b			 
030b 10 ef			djnz .wl1 
030d			 
030d				if DEBUG_STORESE 
030d					DMARK "SW2" 
030d f5				push af  
030e 3a 22 03			ld a, (.dmark)  
0311 32 6b ee			ld (debug_mark),a  
0314 3a 23 03			ld a, (.dmark+1)  
0317 32 6c ee			ld (debug_mark+1),a  
031a 3a 24 03			ld a, (.dmark+2)  
031d 32 6d ee			ld (debug_mark+2),a  
0320 18 03			jr .pastdmark  
0322 ..			.dmark: db "SW2"  
0325 f1			.pastdmark: pop af  
0326			endm  
# End of macro DMARK
0326			 
0326					;push af 
0326					;ld a, 'W' 
0326					;ld (debug_mark),a 
0326					;pop af 
0326					CALLMONITOR 
0326 cd 6f ee			call debug_vector  
0329				endm  
# End of macro CALLMONITOR
0329				endif 
0329 c9				ret	 
032a			 
032a			; Init bank 
032a			; --------- 
032a			; 
032a			; With current bank 
032a			; 
032a			; Setup block 0 config 
032a			;     Set 0 file id counter 
032a			;     Set formatted byte pattern 
032a			;     Zero out bank label 
032a			;      
032a			; For every logical block write 0-1 byte as null 
032a			 
032a			storage_get_block_0: 
032a			 
032a				; TODO check presence 
032a			 
032a				; get block 0 config 
032a			 
032a 21 00 00			ld hl, 0 
032d 11 7a ea			ld de, store_page 
0330 cd 79 02			call storage_read_block 
0333			 
0333				if DEBUG_STORESE 
0333					DMARK "SB0" 
0333 f5				push af  
0334 3a 48 03			ld a, (.dmark)  
0337 32 6b ee			ld (debug_mark),a  
033a 3a 49 03			ld a, (.dmark+1)  
033d 32 6c ee			ld (debug_mark+1),a  
0340 3a 4a 03			ld a, (.dmark+2)  
0343 32 6d ee			ld (debug_mark+2),a  
0346 18 03			jr .pastdmark  
0348 ..			.dmark: db "SB0"  
034b f1			.pastdmark: pop af  
034c			endm  
# End of macro DMARK
034c 11 7a ea				ld de, store_page 
034f			;		push af 
034f			;		ld a, 'i' 
034f			;		ld (debug_mark),a 
034f			;		pop af 
034f					CALLMONITOR 
034f cd 6f ee			call debug_vector  
0352				endm  
# End of macro CALLMONITOR
0352				endif 
0352			 
0352				; is this area formatted? 
0352			 
0352			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0352 2a 7b ea			ld hl, (store_page+1) 
0355 3e 80			ld a,0x80 
0357 bd				cp l 
0358 20 22			jr nz, .ininotformatted 
035a				; do a double check 
035a 3e 27			ld a, 0x27 
035c bc				cp h 
035d 20 1d			jr nz, .ininotformatted 
035f			 
035f				; formatted then 
035f			 
035f				if DEBUG_STORESE 
035f					DMARK "SB1" 
035f f5				push af  
0360 3a 74 03			ld a, (.dmark)  
0363 32 6b ee			ld (debug_mark),a  
0366 3a 75 03			ld a, (.dmark+1)  
0369 32 6c ee			ld (debug_mark+1),a  
036c 3a 76 03			ld a, (.dmark+2)  
036f 32 6d ee			ld (debug_mark+2),a  
0372 18 03			jr .pastdmark  
0374 ..			.dmark: db "SB1"  
0377 f1			.pastdmark: pop af  
0378			endm  
# End of macro DMARK
0378					;push af 
0378					;ld a, 'I' 
0378					;ld (debug_mark),a 
0378					;pop af 
0378					CALLMONITOR 
0378 cd 6f ee			call debug_vector  
037b				endm  
# End of macro CALLMONITOR
037b				endif 
037b c9				ret 
037c			 
037c			.ininotformatted: 
037c				; bank not formatted so poke various bits to make sure 
037c			 
037c				if DEBUG_STORESE 
037c					DMARK "SB2" 
037c f5				push af  
037d 3a 91 03			ld a, (.dmark)  
0380 32 6b ee			ld (debug_mark),a  
0383 3a 92 03			ld a, (.dmark+1)  
0386 32 6c ee			ld (debug_mark+1),a  
0389 3a 93 03			ld a, (.dmark+2)  
038c 32 6d ee			ld (debug_mark+2),a  
038f 18 03			jr .pastdmark  
0391 ..			.dmark: db "SB2"  
0394 f1			.pastdmark: pop af  
0395			endm  
# End of macro DMARK
0395					;push af 
0395					;ld a, 'f' 
0395					;ld (debug_mark),a 
0395					;pop af 
0395					CALLMONITOR 
0395 cd 6f ee			call debug_vector  
0398				endm  
# End of macro CALLMONITOR
0398				endif 
0398			 
0398 cd b5 0a			call storage_clear_page 
039b			 
039b 21 7a ea			ld hl, store_page 
039e 3e 00			ld a, 0 
03a0				 
03a0 77				ld (hl),a   ; reset file counter 
03a1			 
03a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a4 22 7b ea		 	ld (store_page+1), hl	 
03a7			 
03a7				; set default label 
03a7			 
03a7 21 43 04			ld hl, .defaultbanklabl 
03aa 11 7d ea		 	ld de, store_page+3 
03ad 01 0f 00			ld bc, 15 
03b0 ed b0			ldir 
03b2			 
03b2				; Append the current bank id 
03b2 21 86 ea			ld hl, store_page+3+9 
03b5 3a 5f ea			ld a, (spi_device_id) 
03b8 77				ld (hl), a 
03b9			 
03b9				; save default page 0 
03b9			 
03b9 21 00 00			ld hl, 0 
03bc 11 7a ea			ld de, store_page 
03bf				if DEBUG_STORESE 
03bf					DMARK "SB3" 
03bf f5				push af  
03c0 3a d4 03			ld a, (.dmark)  
03c3 32 6b ee			ld (debug_mark),a  
03c6 3a d5 03			ld a, (.dmark+1)  
03c9 32 6c ee			ld (debug_mark+1),a  
03cc 3a d6 03			ld a, (.dmark+2)  
03cf 32 6d ee			ld (debug_mark+2),a  
03d2 18 03			jr .pastdmark  
03d4 ..			.dmark: db "SB3"  
03d7 f1			.pastdmark: pop af  
03d8			endm  
# End of macro DMARK
03d8			;		push af 
03d8			;		ld a, 'F' 
03d8			;		ld (debug_mark),a 
03d8			;		pop af 
03d8					CALLMONITOR 
03d8 cd 6f ee			call debug_vector  
03db				endm  
# End of macro CALLMONITOR
03db				endif 
03db cd de 02			call storage_write_block 
03de				if DEBUG_STORESE 
03de					DMARK "SB4" 
03de f5				push af  
03df 3a f3 03			ld a, (.dmark)  
03e2 32 6b ee			ld (debug_mark),a  
03e5 3a f4 03			ld a, (.dmark+1)  
03e8 32 6c ee			ld (debug_mark+1),a  
03eb 3a f5 03			ld a, (.dmark+2)  
03ee 32 6d ee			ld (debug_mark+2),a  
03f1 18 03			jr .pastdmark  
03f3 ..			.dmark: db "SB4"  
03f6 f1			.pastdmark: pop af  
03f7			endm  
# End of macro DMARK
03f7			;		push af 
03f7			;		ld a, '>' 
03f7			;		ld (debug_mark),a 
03f7			;		pop af 
03f7					CALLMONITOR 
03f7 cd 6f ee			call debug_vector  
03fa				endm  
# End of macro CALLMONITOR
03fa				endif 
03fa			 
03fa 00				nop 
03fb 00				nop 
03fc 00				nop 
03fd			 
03fd				; now set 0 in every page to mark as a free block 
03fd			 
03fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03ff 21 40 00			ld hl, STORE_BLOCK_PHY 
0402			 
0402 3e 00		.setmark1:   	ld a,0 
0404 e5					push hl 
0405 c5					push bc 
0406 cd 9e 01				call se_writebyte 
0409 3e 0a			ld a, 10 
040b cd d7 0a			call aDelayInMS 
040e 23				inc hl 
040f cd 9e 01				call se_writebyte 
0412 3e 0a			ld a, 10 
0414 cd d7 0a			call aDelayInMS 
0417 2b				dec hl 
0418 c1					pop bc 
0419 e1					pop hl 
041a 3e 40				ld a, STORE_BLOCK_PHY 
041c cd e7 0d				call addatohl 
041f 10 e1				djnz .setmark1 
0421			 
0421 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0423 3e 00		.setmark2:   	ld a,0 
0425 e5					push hl 
0426 c5					push bc 
0427 cd 9e 01				call se_writebyte 
042a 3e 0a			ld a, 10 
042c cd d7 0a			call aDelayInMS 
042f 23				inc hl 
0430 cd 9e 01				call se_writebyte 
0433 3e 0a			ld a, 10 
0435 cd d7 0a			call aDelayInMS 
0438 2b				dec hl 
0439 c1					pop bc 
043a e1					pop hl 
043b 3e 40				ld a, STORE_BLOCK_PHY 
043d cd e7 0d				call addatohl 
0440 10 e1				djnz .setmark2 
0442			 
0442					 
0442			 
0442			 
0442 c9				ret 
0443			 
0443			 
0443			 
0443			 
0443 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044e			 
044e			 
044e			 
044e			; Label Bank 
044e			; ---------- 
044e			; 
044e			; With current bank 
044e			; Read block 0 
044e			; Set label 
044e			; Write block 0 
044e			 
044e			; label str pointer in hl 
044e			 
044e			storage_label:     
044e			 
044e				if DEBUG_STORESE 
044e					DMARK "LBL" 
044e f5				push af  
044f 3a 63 04			ld a, (.dmark)  
0452 32 6b ee			ld (debug_mark),a  
0455 3a 64 04			ld a, (.dmark+1)  
0458 32 6c ee			ld (debug_mark+1),a  
045b 3a 65 04			ld a, (.dmark+2)  
045e 32 6d ee			ld (debug_mark+2),a  
0461 18 03			jr .pastdmark  
0463 ..			.dmark: db "LBL"  
0466 f1			.pastdmark: pop af  
0467			endm  
# End of macro DMARK
0467					CALLMONITOR 
0467 cd 6f ee			call debug_vector  
046a				endm  
# End of macro CALLMONITOR
046a				endif 
046a			 
046a e5				push hl 
046b			 
046b cd 2a 03			call storage_get_block_0 
046e			 
046e				; set default label 
046e			 
046e e1				pop hl 
046f			 
046f 11 7d ea		 	ld de, store_page+3 
0472 01 0f 00			ld bc, 15 
0475				if DEBUG_STORESE 
0475					DMARK "LB3" 
0475 f5				push af  
0476 3a 8a 04			ld a, (.dmark)  
0479 32 6b ee			ld (debug_mark),a  
047c 3a 8b 04			ld a, (.dmark+1)  
047f 32 6c ee			ld (debug_mark+1),a  
0482 3a 8c 04			ld a, (.dmark+2)  
0485 32 6d ee			ld (debug_mark+2),a  
0488 18 03			jr .pastdmark  
048a ..			.dmark: db "LB3"  
048d f1			.pastdmark: pop af  
048e			endm  
# End of macro DMARK
048e					CALLMONITOR 
048e cd 6f ee			call debug_vector  
0491				endm  
# End of macro CALLMONITOR
0491				endif 
0491 ed b0			ldir 
0493				; save default page 0 
0493			 
0493 21 00 00			ld hl, 0 
0496 11 7a ea			ld de, store_page 
0499				if DEBUG_STORESE 
0499					DMARK "LBW" 
0499 f5				push af  
049a 3a ae 04			ld a, (.dmark)  
049d 32 6b ee			ld (debug_mark),a  
04a0 3a af 04			ld a, (.dmark+1)  
04a3 32 6c ee			ld (debug_mark+1),a  
04a6 3a b0 04			ld a, (.dmark+2)  
04a9 32 6d ee			ld (debug_mark+2),a  
04ac 18 03			jr .pastdmark  
04ae ..			.dmark: db "LBW"  
04b1 f1			.pastdmark: pop af  
04b2			endm  
# End of macro DMARK
04b2					CALLMONITOR 
04b2 cd 6f ee			call debug_vector  
04b5				endm  
# End of macro CALLMONITOR
04b5				endif 
04b5 cd de 02			call storage_write_block 
04b8			 
04b8 c9				ret 
04b9			 
04b9			 
04b9			 
04b9			; Read Block 0 - Config 
04b9			; --------------------- 
04b9			; 
04b9			; With current bank 
04b9			; Call presence test 
04b9			;    If not present format/init bank  
04b9			; Read block 0  
04b9			;  
04b9			 
04b9			 
04b9			; Dir 
04b9			; --- 
04b9			; 
04b9			; With current bank 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block read byte 2 
04b9			;      if first block of file 
04b9			;         Display file name 
04b9			;         Display type flags for file 
04b9			;        
04b9			 
04b9			; moving to words as this requires stack control 
04b9			 
04b9			 
04b9			; Delete File 
04b9			; ----------- 
04b9			; 
04b9			; With current bank 
04b9			; 
04b9			; Load Block 0 Config 
04b9			; Get max file id number 
04b9			; For each logical block 
04b9			;    Read block file id 
04b9			;      If first block of file and dont have file id 
04b9			;         if file to delete 
04b9			;         Save file id 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			;      If file id is one saved 
04b9			;         Null file id 
04b9			;         Write this block back 
04b9			 
04b9			 
04b9			.se_done: 
04b9 e1				pop hl 
04ba c9				ret 
04bb			 
04bb			storage_erase: 
04bb			 
04bb				; hl contains the file id 
04bb			 
04bb 5d				ld e, l 
04bc 16 00			ld d, 0 
04be 21 40 00			ld hl, STORE_BLOCK_PHY 
04c1					if DEBUG_FORTH_WORDS 
04c1						DMARK "ERA" 
04c1 f5				push af  
04c2 3a d6 04			ld a, (.dmark)  
04c5 32 6b ee			ld (debug_mark),a  
04c8 3a d7 04			ld a, (.dmark+1)  
04cb 32 6c ee			ld (debug_mark+1),a  
04ce 3a d8 04			ld a, (.dmark+2)  
04d1 32 6d ee			ld (debug_mark+2),a  
04d4 18 03			jr .pastdmark  
04d6 ..			.dmark: db "ERA"  
04d9 f1			.pastdmark: pop af  
04da			endm  
# End of macro DMARK
04da						CALLMONITOR 
04da cd 6f ee			call debug_vector  
04dd				endm  
# End of macro CALLMONITOR
04dd					endif 
04dd cd ac 05			call storage_findnextid 
04e0 cd 10 0e			call ishlzero 
04e3 c8				ret z 
04e4			 
04e4 e5				push hl 
04e5			 
04e5				; TODO check file not found 
04e5			 
04e5 11 7a ea			ld de, store_page 
04e8 cd 79 02			call storage_read_block 
04eb			 
04eb cd 10 0e			call ishlzero 
04ee ca b9 04			jp z,.se_done 
04f1			 
04f1					if DEBUG_FORTH_WORDS 
04f1						DMARK "ER1" 
04f1 f5				push af  
04f2 3a 06 05			ld a, (.dmark)  
04f5 32 6b ee			ld (debug_mark),a  
04f8 3a 07 05			ld a, (.dmark+1)  
04fb 32 6c ee			ld (debug_mark+1),a  
04fe 3a 08 05			ld a, (.dmark+2)  
0501 32 6d ee			ld (debug_mark+2),a  
0504 18 03			jr .pastdmark  
0506 ..			.dmark: db "ER1"  
0509 f1			.pastdmark: pop af  
050a			endm  
# End of macro DMARK
050a						CALLMONITOR 
050a cd 6f ee			call debug_vector  
050d				endm  
# End of macro CALLMONITOR
050d					endif 
050d 3a 7a ea			ld a, (store_page)	; get file id 
0510 32 6e ea			ld (store_tmpid), a 
0513			 
0513 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
0516 32 6d ea			ld (store_tmpext), a 
0519			 
0519				; wipe file header 
0519			 
0519 e1				pop hl 
051a 3e 00			ld a, 0 
051c 32 7a ea			ld (store_page), a 
051f 32 7b ea			ld (store_page+1),a 
0522 11 7a ea			ld de, store_page 
0525					if DEBUG_FORTH_WORDS 
0525						DMARK "ER2" 
0525 f5				push af  
0526 3a 3a 05			ld a, (.dmark)  
0529 32 6b ee			ld (debug_mark),a  
052c 3a 3b 05			ld a, (.dmark+1)  
052f 32 6c ee			ld (debug_mark+1),a  
0532 3a 3c 05			ld a, (.dmark+2)  
0535 32 6d ee			ld (debug_mark+2),a  
0538 18 03			jr .pastdmark  
053a ..			.dmark: db "ER2"  
053d f1			.pastdmark: pop af  
053e			endm  
# End of macro DMARK
053e						CALLMONITOR 
053e cd 6f ee			call debug_vector  
0541				endm  
# End of macro CALLMONITOR
0541					endif 
0541 cd de 02			call storage_write_block 
0544			 
0544			 
0544				; wipe file extents 
0544			 
0544 3a 6d ea			ld a, (store_tmpext) 
0547 47				ld b, a 
0548			 
0548			.eraext:	  
0548 c5				push bc 
0549			 
0549 21 40 00			ld hl, STORE_BLOCK_PHY 
054c 3a 6e ea			ld a,(store_tmpid) 
054f 5f				ld e, a 
0550 50				ld d, b	 
0551					if DEBUG_FORTH_WORDS 
0551						DMARK "ER3" 
0551 f5				push af  
0552 3a 66 05			ld a, (.dmark)  
0555 32 6b ee			ld (debug_mark),a  
0558 3a 67 05			ld a, (.dmark+1)  
055b 32 6c ee			ld (debug_mark+1),a  
055e 3a 68 05			ld a, (.dmark+2)  
0561 32 6d ee			ld (debug_mark+2),a  
0564 18 03			jr .pastdmark  
0566 ..			.dmark: db "ER3"  
0569 f1			.pastdmark: pop af  
056a			endm  
# End of macro DMARK
056a						CALLMONITOR 
056a cd 6f ee			call debug_vector  
056d				endm  
# End of macro CALLMONITOR
056d					endif 
056d cd ac 05			call storage_findnextid 
0570 cd 10 0e			call ishlzero 
0573 ca b9 04			jp z,.se_done 
0576			 
0576 e5				push hl 
0577 11 7a ea			ld de, store_page 
057a cd 79 02			call storage_read_block 
057d			 
057d				; free block	 
057d			 
057d 3e 00			ld a, 0 
057f 32 7a ea			ld (store_page), a 
0582 32 7b ea			ld (store_page+1),a 
0585 11 7a ea			ld de, store_page 
0588 e1				pop hl 
0589					if DEBUG_FORTH_WORDS 
0589						DMARK "ER4" 
0589 f5				push af  
058a 3a 9e 05			ld a, (.dmark)  
058d 32 6b ee			ld (debug_mark),a  
0590 3a 9f 05			ld a, (.dmark+1)  
0593 32 6c ee			ld (debug_mark+1),a  
0596 3a a0 05			ld a, (.dmark+2)  
0599 32 6d ee			ld (debug_mark+2),a  
059c 18 03			jr .pastdmark  
059e ..			.dmark: db "ER4"  
05a1 f1			.pastdmark: pop af  
05a2			endm  
# End of macro DMARK
05a2						CALLMONITOR 
05a2 cd 6f ee			call debug_vector  
05a5				endm  
# End of macro CALLMONITOR
05a5					endif 
05a5 cd de 02			call storage_write_block 
05a8			 
05a8 c1				pop bc 
05a9 10 9d			djnz .eraext 
05ab			 
05ab c9				ret 
05ac			 
05ac			 
05ac			; Find Free Block 
05ac			; --------------- 
05ac			; 
05ac			; With current bank 
05ac			;  
05ac			; From given starting logical block 
05ac			;    Read block  
05ac			;    If no file id 
05ac			;         Return block id 
05ac			 
05ac			 
05ac			; hl starting page number 
05ac			; hl contains free page number or zero if no pages free 
05ac			; e contains the file id to locate 
05ac			; d contains the block number 
05ac			 
05ac			; TODO change to find file id and use zero for free block 
05ac			 
05ac			storage_findnextid: 
05ac			 
05ac				; now locate first 0 page to mark as a free block 
05ac			 
05ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ae			;	ld hl, STORE_BLOCK_PHY 
05ae			 
05ae					if DEBUG_FORTH_WORDS 
05ae					DMARK "FNI" 
05ae f5				push af  
05af 3a c3 05			ld a, (.dmark)  
05b2 32 6b ee			ld (debug_mark),a  
05b5 3a c4 05			ld a, (.dmark+1)  
05b8 32 6c ee			ld (debug_mark+1),a  
05bb 3a c5 05			ld a, (.dmark+2)  
05be 32 6d ee			ld (debug_mark+2),a  
05c1 18 03			jr .pastdmark  
05c3 ..			.dmark: db "FNI"  
05c6 f1			.pastdmark: pop af  
05c7			endm  
# End of macro DMARK
05c7						CALLMONITOR 
05c7 cd 6f ee			call debug_vector  
05ca				endm  
# End of macro CALLMONITOR
05ca					endif 
05ca			.ff1:   	 
05ca e5					push hl 
05cb c5					push bc 
05cc d5					push de 
05cd cd 9d 01				call se_readbyte 
05d0 5f					ld e,a 
05d1 23					inc hl 
05d2 cd 9d 01				call se_readbyte 
05d5 57					ld d, a 
05d6 e1					pop hl 
05d7 e5					push hl 
05d8 cd 05 0e				call cmp16 
05db 28 49				jr z, .fffound 
05dd			 
05dd d1					pop de 
05de c1					pop bc 
05df e1					pop hl 
05e0			 
05e0					; is found? 
05e0					;cp e 
05e0					;ret z 
05e0			 
05e0 3e 40				ld a, STORE_BLOCK_PHY 
05e2 cd e7 0d				call addatohl 
05e5 10 e3				djnz .ff1 
05e7			 
05e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e9			.ff2:   	 
05e9			 
05e9 e5					push hl 
05ea c5					push bc 
05eb d5					push de 
05ec cd 9d 01				call se_readbyte 
05ef 5f					ld e,a 
05f0 23					inc hl 
05f1 cd 9d 01				call se_readbyte 
05f4 57					ld d, a 
05f5			 
05f5 e1					pop hl 
05f6 e5					push hl 
05f7 cd 05 0e				call cmp16 
05fa 28 2a				jr z, .fffound 
05fc			 
05fc d1					pop de 
05fd c1					pop bc 
05fe e1					pop hl 
05ff					; is found? 
05ff					;cp e 
05ff					;ret z 
05ff			 
05ff 3e 40				ld a, STORE_BLOCK_PHY 
0601 cd e7 0d				call addatohl 
0604 10 e3				djnz .ff2 
0606			 
0606			 
0606					if DEBUG_FORTH_WORDS 
0606					DMARK "FN-" 
0606 f5				push af  
0607 3a 1b 06			ld a, (.dmark)  
060a 32 6b ee			ld (debug_mark),a  
060d 3a 1c 06			ld a, (.dmark+1)  
0610 32 6c ee			ld (debug_mark+1),a  
0613 3a 1d 06			ld a, (.dmark+2)  
0616 32 6d ee			ld (debug_mark+2),a  
0619 18 03			jr .pastdmark  
061b ..			.dmark: db "FN-"  
061e f1			.pastdmark: pop af  
061f			endm  
# End of macro DMARK
061f					;	push af 
061f					;	ld a, 'n' 
061f					;	ld (debug_mark),a 
061f					;	pop af 
061f						CALLMONITOR 
061f cd 6f ee			call debug_vector  
0622				endm  
# End of macro CALLMONITOR
0622					endif 
0622				; no free marks! 
0622 21 00 00				ld hl, 0 
0625 c9				ret 
0626			.fffound: 
0626				 
0626			 
0626 d1					pop de 
0627 c1					pop bc 
0628 e1					pop hl 
0629					if DEBUG_FORTH_WORDS 
0629					DMARK "FNF" 
0629 f5				push af  
062a 3a 3e 06			ld a, (.dmark)  
062d 32 6b ee			ld (debug_mark),a  
0630 3a 3f 06			ld a, (.dmark+1)  
0633 32 6c ee			ld (debug_mark+1),a  
0636 3a 40 06			ld a, (.dmark+2)  
0639 32 6d ee			ld (debug_mark+2),a  
063c 18 03			jr .pastdmark  
063e ..			.dmark: db "FNF"  
0641 f1			.pastdmark: pop af  
0642			endm  
# End of macro DMARK
0642					;	push af 
0642					;	ld a, 'n' 
0642					;	ld (debug_mark),a 
0642					;	pop af 
0642						CALLMONITOR 
0642 cd 6f ee			call debug_vector  
0645				endm  
# End of macro CALLMONITOR
0645					endif 
0645 c9				ret 
0646			 
0646			 
0646			 
0646			; Free Space 
0646			; ---------- 
0646			; 
0646			; With current bank 
0646			; 
0646			; Set block count to zero 
0646			; Starting with first logical block 
0646			;      Find free block  
0646			;      If block id given, increment block count 
0646			; 
0646			;  
0646			 
0646			 
0646			; hl contains count of free blocks 
0646			 
0646			storage_freeblocks: 
0646			 
0646				; now locate first 0 page to mark as a free block 
0646			 
0646 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0648 21 40 00			ld hl, STORE_BLOCK_PHY 
064b 11 00 00			ld de, 0 
064e			 
064e			.fb1:   	 
064e e5					push hl 
064f c5					push bc 
0650 d5					push de 
0651 cd 9d 01				call se_readbyte 
0654 d1					pop de 
0655 c1					pop bc 
0656 e1					pop hl 
0657			 
0657					; is free? 
0657 fe 00				cp 0 
0659 20 01				jr nz, .ff1cont 
065b 13					inc de 
065c			 
065c			.ff1cont: 
065c			 
065c			 
065c 3e 40				ld a, STORE_BLOCK_PHY 
065e cd e7 0d				call addatohl 
0661 10 eb				djnz .fb1 
0663			 
0663 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0665			.fb2:   	 
0665 e5					push hl 
0666 c5					push bc 
0667 d5					push de 
0668 cd 9d 01				call se_readbyte 
066b d1					pop de 
066c c1					pop bc 
066d e1					pop hl 
066e			 
066e					; is free? 
066e fe 00				cp 0 
0670 20 01				jr nz, .ff2cont 
0672 13					inc de 
0673			 
0673			.ff2cont: 
0673			 
0673 3e 40				ld a, STORE_BLOCK_PHY 
0675 cd e7 0d				call addatohl 
0678 10 eb				djnz .fb2 
067a			 
067a eb				ex de, hl 
067b c9				ret 
067c			 
067c			; Get File ID 
067c			; ----------- 
067c			; 
067c			; With current bank 
067c			;  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; For each logical block 
067c			;    Read block file id 
067c			;      If first block of file and dont have file id 
067c			;         if file get id and exit 
067c			 
067c			 
067c			 
067c			 
067c			; Create File 
067c			; ----------- 
067c			; 
067c			; With current bank  
067c			; Load Block 0 Config 
067c			; Get max file id number 
067c			; Increment file id number 
067c			; Save Config 
067c			; Find free block 
067c			; Set buffer with file name and file id 
067c			; Write buffer to free block  
067c			 
067c			 
067c			; hl point to file name 
067c			; hl returns file id 
067c			 
067c			; file format: 
067c			; byte 0 - file id 
067c			; byte 1 - extent number 
067c			; byte 2-> data 
067c			 
067c			; format for extent number 0: 
067c			; 
067c			; byte 0 - file id 
067c			; byte 1 - extent 0 
067c			; byte 2 - extent count 
067c			; byte 3 -> file name and meta data 
067c			 
067c			 
067c			storage_create: 
067c				if DEBUG_STORESE 
067c					DMARK "SCR" 
067c f5				push af  
067d 3a 91 06			ld a, (.dmark)  
0680 32 6b ee			ld (debug_mark),a  
0683 3a 92 06			ld a, (.dmark+1)  
0686 32 6c ee			ld (debug_mark+1),a  
0689 3a 93 06			ld a, (.dmark+2)  
068c 32 6d ee			ld (debug_mark+2),a  
068f 18 03			jr .pastdmark  
0691 ..			.dmark: db "SCR"  
0694 f1			.pastdmark: pop af  
0695			endm  
# End of macro DMARK
0695					CALLMONITOR 
0695 cd 6f ee			call debug_vector  
0698				endm  
# End of macro CALLMONITOR
0698				endif 
0698			 
0698 e5				push hl		; save file name pointer 
0699			 
0699 cd 2a 03			call storage_get_block_0 
069c			 
069c 3a 7a ea			ld a,(store_page)	; get current file id 
069f 3c				inc a 
06a0 32 7a ea			ld (store_page),a 
06a3				 
06a3 32 6e ea			ld (store_tmpid),a			; save id 
06a6			 
06a6 21 00 00			ld hl, 0 
06a9 11 7a ea			ld de, store_page 
06ac				if DEBUG_STORESE 
06ac					DMARK "SCw" 
06ac f5				push af  
06ad 3a c1 06			ld a, (.dmark)  
06b0 32 6b ee			ld (debug_mark),a  
06b3 3a c2 06			ld a, (.dmark+1)  
06b6 32 6c ee			ld (debug_mark+1),a  
06b9 3a c3 06			ld a, (.dmark+2)  
06bc 32 6d ee			ld (debug_mark+2),a  
06bf 18 03			jr .pastdmark  
06c1 ..			.dmark: db "SCw"  
06c4 f1			.pastdmark: pop af  
06c5			endm  
# End of macro DMARK
06c5					CALLMONITOR 
06c5 cd 6f ee			call debug_vector  
06c8				endm  
# End of macro CALLMONITOR
06c8				endif 
06c8 cd de 02			call storage_write_block	 ; save update 
06cb			 
06cb				if DEBUG_STORESE 
06cb 11 7a ea				ld de, store_page 
06ce					DMARK "SCC" 
06ce f5				push af  
06cf 3a e3 06			ld a, (.dmark)  
06d2 32 6b ee			ld (debug_mark),a  
06d5 3a e4 06			ld a, (.dmark+1)  
06d8 32 6c ee			ld (debug_mark+1),a  
06db 3a e5 06			ld a, (.dmark+2)  
06de 32 6d ee			ld (debug_mark+2),a  
06e1 18 03			jr .pastdmark  
06e3 ..			.dmark: db "SCC"  
06e6 f1			.pastdmark: pop af  
06e7			endm  
# End of macro DMARK
06e7					CALLMONITOR 
06e7 cd 6f ee			call debug_vector  
06ea				endm  
# End of macro CALLMONITOR
06ea				endif 
06ea				;  
06ea				 
06ea 21 40 00			ld hl, STORE_BLOCK_PHY 
06ed 11 00 00			ld de, 0 
06f0 cd ac 05			call storage_findnextid 
06f3			 
06f3 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
06f6			 
06f6				; TODO detect 0 = no spare blocks 
06f6			 
06f6				; hl now contains the free page to use for the file header page 
06f6			 
06f6				if DEBUG_STORESE 
06f6				DMARK "SCF" 
06f6 f5				push af  
06f7 3a 0b 07			ld a, (.dmark)  
06fa 32 6b ee			ld (debug_mark),a  
06fd 3a 0c 07			ld a, (.dmark+1)  
0700 32 6c ee			ld (debug_mark+1),a  
0703 3a 0d 07			ld a, (.dmark+2)  
0706 32 6d ee			ld (debug_mark+2),a  
0709 18 03			jr .pastdmark  
070b ..			.dmark: db "SCF"  
070e f1			.pastdmark: pop af  
070f			endm  
# End of macro DMARK
070f					CALLMONITOR 
070f cd 6f ee			call debug_vector  
0712				endm  
# End of macro CALLMONITOR
0712				endif 
0712			 
0712 22 65 ea			ld (store_tmppageid), hl 
0715				 
0715 3a 6e ea			ld a,(store_tmpid)    ; get file id 
0718			;	ld a, (store_filecache)			; save to cache 
0718			 
0718 32 7a ea			ld (store_page),a    ; set page id 
071b 3e 00			ld a, 0			 ; extent 0 is file header 
071d 32 7b ea			ld (store_page+1), a   ; set file extent 
0720			 
0720 32 7c ea			ld (store_page+2), a   ; extent count for the file 
0723			 
0723			;	inc hl 		; init block 0 of file 
0723			;	inc hl   		; skip file and extent id 
0723			 ;       ld a, 0 
0723			;	ld (hl),a 
0723			;	ld a, (store_filecache+1)  	; save to cache 
0723			 
0723			;	inc hl    ; file name 
0723				 
0723				 
0723 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0726				if DEBUG_STORESE 
0726					DMARK "SCc" 
0726 f5				push af  
0727 3a 3b 07			ld a, (.dmark)  
072a 32 6b ee			ld (debug_mark),a  
072d 3a 3c 07			ld a, (.dmark+1)  
0730 32 6c ee			ld (debug_mark+1),a  
0733 3a 3d 07			ld a, (.dmark+2)  
0736 32 6d ee			ld (debug_mark+2),a  
0739 18 03			jr .pastdmark  
073b ..			.dmark: db "SCc"  
073e f1			.pastdmark: pop af  
073f			endm  
# End of macro DMARK
073f					CALLMONITOR 
073f cd 6f ee			call debug_vector  
0742				endm  
# End of macro CALLMONITOR
0742				endif 
0742 e1				pop hl    ; get zero term string 
0743 e5				push hl 
0744 3e 00			ld a, 0 
0746 cd 50 12			call strlent 
0749 23				inc hl   ; cover zero term 
074a 06 00			ld b,0 
074c 4d				ld c,l 
074d e1				pop hl 
074e				;ex de, hl 
074e				if DEBUG_STORESE 
074e					DMARK "SCa" 
074e f5				push af  
074f 3a 63 07			ld a, (.dmark)  
0752 32 6b ee			ld (debug_mark),a  
0755 3a 64 07			ld a, (.dmark+1)  
0758 32 6c ee			ld (debug_mark+1),a  
075b 3a 65 07			ld a, (.dmark+2)  
075e 32 6d ee			ld (debug_mark+2),a  
0761 18 03			jr .pastdmark  
0763 ..			.dmark: db "SCa"  
0766 f1			.pastdmark: pop af  
0767			endm  
# End of macro DMARK
0767					;push af 
0767					;ld a, 'a' 
0767					;ld (debug_mark),a 
0767					;pop af 
0767					CALLMONITOR 
0767 cd 6f ee			call debug_vector  
076a				endm  
# End of macro CALLMONITOR
076a				endif 
076a ed b0			ldir    ; copy zero term string 
076c				if DEBUG_STORESE 
076c					DMARK "SCA" 
076c f5				push af  
076d 3a 81 07			ld a, (.dmark)  
0770 32 6b ee			ld (debug_mark),a  
0773 3a 82 07			ld a, (.dmark+1)  
0776 32 6c ee			ld (debug_mark+1),a  
0779 3a 83 07			ld a, (.dmark+2)  
077c 32 6d ee			ld (debug_mark+2),a  
077f 18 03			jr .pastdmark  
0781 ..			.dmark: db "SCA"  
0784 f1			.pastdmark: pop af  
0785			endm  
# End of macro DMARK
0785					CALLMONITOR 
0785 cd 6f ee			call debug_vector  
0788				endm  
# End of macro CALLMONITOR
0788				endif 
0788			 
0788				; write file header page 
0788			 
0788 2a 65 ea			ld hl,(store_tmppageid) 
078b 11 7a ea			ld de, store_page 
078e				if DEBUG_STORESE 
078e					DMARK "SCb" 
078e f5				push af  
078f 3a a3 07			ld a, (.dmark)  
0792 32 6b ee			ld (debug_mark),a  
0795 3a a4 07			ld a, (.dmark+1)  
0798 32 6c ee			ld (debug_mark+1),a  
079b 3a a5 07			ld a, (.dmark+2)  
079e 32 6d ee			ld (debug_mark+2),a  
07a1 18 03			jr .pastdmark  
07a3 ..			.dmark: db "SCb"  
07a6 f1			.pastdmark: pop af  
07a7			endm  
# End of macro DMARK
07a7					;push af 
07a7					;ld a, 'b' 
07a7					;ld (debug_mark),a 
07a7					;pop af 
07a7					CALLMONITOR 
07a7 cd 6f ee			call debug_vector  
07aa				endm  
# End of macro CALLMONITOR
07aa				endif 
07aa cd de 02			call storage_write_block 
07ad			 
07ad 3a 6e ea			ld a, (store_tmpid) 
07b0 6f				ld l, a 
07b1 26 00			ld h,0 
07b3				if DEBUG_STORESE 
07b3					DMARK "SCz" 
07b3 f5				push af  
07b4 3a c8 07			ld a, (.dmark)  
07b7 32 6b ee			ld (debug_mark),a  
07ba 3a c9 07			ld a, (.dmark+1)  
07bd 32 6c ee			ld (debug_mark+1),a  
07c0 3a ca 07			ld a, (.dmark+2)  
07c3 32 6d ee			ld (debug_mark+2),a  
07c6 18 03			jr .pastdmark  
07c8 ..			.dmark: db "SCz"  
07cb f1			.pastdmark: pop af  
07cc			endm  
# End of macro DMARK
07cc					CALLMONITOR 
07cc cd 6f ee			call debug_vector  
07cf				endm  
# End of macro CALLMONITOR
07cf				endif 
07cf c9				ret 
07d0				 
07d0			 
07d0			 
07d0			; 
07d0			; Read File 
07d0			; 
07d0			; h - file id to locate 
07d0			; l - extent to locate 
07d0			; de - pointer to string to read into 
07d0			; 
07d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07d0			 
07d0			.sr_fail: 
07d0 d1				pop de 
07d1 c9				ret 
07d2			 
07d2			storage_read: 
07d2			 
07d2			 
07d2 d5				push de 
07d3			 
07d3			; TODO BUG the above push is it popped before the RET Z? 
07d3			 
07d3			; TODO how to handle multiple part blocks 
07d3			 
07d3				; locate file extent to read 
07d3			 
07d3 5c				ld e, h 
07d4 55				ld d, l 
07d5			 
07d5			.srext: 
07d5 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
07d8 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07dc			 
07dc 21 40 00			ld hl, STORE_BLOCK_PHY 
07df				if DEBUG_STORESE 
07df					DMARK "sre" 
07df f5				push af  
07e0 3a f4 07			ld a, (.dmark)  
07e3 32 6b ee			ld (debug_mark),a  
07e6 3a f5 07			ld a, (.dmark+1)  
07e9 32 6c ee			ld (debug_mark+1),a  
07ec 3a f6 07			ld a, (.dmark+2)  
07ef 32 6d ee			ld (debug_mark+2),a  
07f2 18 03			jr .pastdmark  
07f4 ..			.dmark: db "sre"  
07f7 f1			.pastdmark: pop af  
07f8			endm  
# End of macro DMARK
07f8					CALLMONITOR 
07f8 cd 6f ee			call debug_vector  
07fb				endm  
# End of macro CALLMONITOR
07fb				endif 
07fb cd ac 05			call storage_findnextid 
07fe			 
07fe				if DEBUG_STORESE 
07fe					DMARK "srf" 
07fe f5				push af  
07ff 3a 13 08			ld a, (.dmark)  
0802 32 6b ee			ld (debug_mark),a  
0805 3a 14 08			ld a, (.dmark+1)  
0808 32 6c ee			ld (debug_mark+1),a  
080b 3a 15 08			ld a, (.dmark+2)  
080e 32 6d ee			ld (debug_mark+2),a  
0811 18 03			jr .pastdmark  
0813 ..			.dmark: db "srf"  
0816 f1			.pastdmark: pop af  
0817			endm  
# End of macro DMARK
0817					CALLMONITOR 
0817 cd 6f ee			call debug_vector  
081a				endm  
# End of macro CALLMONITOR
081a				endif 
081a cd 10 0e			call ishlzero 
081d			;	ld a, l 
081d			;	add h 
081d			;	cp 0 
081d 28 b1			jr z,.sr_fail			; block not found so EOF 
081f			 
081f				; save current address for use by higher level words etc 
081f			 
081f 22 6b ea			ld (store_openaddr),hl 
0822			 
0822			 
0822				; hl contains page number to load 
0822 d1				pop de   ; get storage 
0823 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
0827 d5				push de 
0828				if DEBUG_STORESE 
0828					DMARK "srg" 
0828 f5				push af  
0829 3a 3d 08			ld a, (.dmark)  
082c 32 6b ee			ld (debug_mark),a  
082f 3a 3e 08			ld a, (.dmark+1)  
0832 32 6c ee			ld (debug_mark+1),a  
0835 3a 3f 08			ld a, (.dmark+2)  
0838 32 6d ee			ld (debug_mark+2),a  
083b 18 03			jr .pastdmark  
083d ..			.dmark: db "srg"  
0840 f1			.pastdmark: pop af  
0841			endm  
# End of macro DMARK
0841					CALLMONITOR 
0841 cd 6f ee			call debug_vector  
0844				endm  
# End of macro CALLMONITOR
0844				endif 
0844 cd 79 02			call storage_read_block 
0847			 
0847				; if this a continuation read??? 
0847			 
0847 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
084a			 
084a 3e 3f			ld a, STORE_BLOCK_PHY-1 
084c cd e7 0d			call addatohl 
084f 7e				ld a,(hl) 
0850 fe 00			cp 0 
0852 28 02			jr z, .markiscont 
0854 3e ff			ld a, 255 
0856			 
0856			.markiscont: 
0856 32 6d ea			ld (store_readcont), a 
0859			 
0859				if DEBUG_STORESE 
0859					DMARK "srC" 
0859 f5				push af  
085a 3a 6e 08			ld a, (.dmark)  
085d 32 6b ee			ld (debug_mark),a  
0860 3a 6f 08			ld a, (.dmark+1)  
0863 32 6c ee			ld (debug_mark+1),a  
0866 3a 70 08			ld a, (.dmark+2)  
0869 32 6d ee			ld (debug_mark+2),a  
086c 18 03			jr .pastdmark  
086e ..			.dmark: db "srC"  
0871 f1			.pastdmark: pop af  
0872			endm  
# End of macro DMARK
0872					CALLMONITOR 
0872 cd 6f ee			call debug_vector  
0875				endm  
# End of macro CALLMONITOR
0875				endif 
0875				; only short reads enabled 
0875			 
0875 3a 75 ea			ld a, (store_longread) 
0878 fe 00			cp 0 
087a ca 47 09			jp z, .readdone 
087d			 
087d			; TODO if block has no zeros then need to read next block  
087d			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
087d			; check last byte of physical block. 
087d			; if not zero then the next block needs to be loaded 
087d			 
087d			 
087d 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0880			 
0880 3e 3f			ld a, STORE_BLOCK_PHY-1 
0882 cd e7 0d			call addatohl 
0885				;dec hl 
0885 7e				ld a,(hl) 
0886				if DEBUG_STORESE 
0886					DMARK "sr?" 
0886 f5				push af  
0887 3a 9b 08			ld a, (.dmark)  
088a 32 6b ee			ld (debug_mark),a  
088d 3a 9c 08			ld a, (.dmark+1)  
0890 32 6c ee			ld (debug_mark+1),a  
0893 3a 9d 08			ld a, (.dmark+2)  
0896 32 6d ee			ld (debug_mark+2),a  
0899 18 03			jr .pastdmark  
089b ..			.dmark: db "sr?"  
089e f1			.pastdmark: pop af  
089f			endm  
# End of macro DMARK
089f					CALLMONITOR 
089f cd 6f ee			call debug_vector  
08a2				endm  
# End of macro CALLMONITOR
08a2				endif 
08a2 fe 00			cp 0 
08a4 ca 47 09			jp z, .readdone 
08a7			 
08a7				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a7			 
08a7 23				inc hl 
08a8			 
08a8 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08ab			 
08ab ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
08af			 
08af eb				ex de, hl 
08b0			 
08b0				; next ext 
08b0			 
08b0 23				inc hl 
08b1 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
08b4			 
08b4				if DEBUG_STORESE 
08b4					DMARK "sF2" 
08b4 f5				push af  
08b5 3a c9 08			ld a, (.dmark)  
08b8 32 6b ee			ld (debug_mark),a  
08bb 3a ca 08			ld a, (.dmark+1)  
08be 32 6c ee			ld (debug_mark+1),a  
08c1 3a cb 08			ld a, (.dmark+2)  
08c4 32 6d ee			ld (debug_mark+2),a  
08c7 18 03			jr .pastdmark  
08c9 ..			.dmark: db "sF2"  
08cc f1			.pastdmark: pop af  
08cd			endm  
# End of macro DMARK
08cd					CALLMONITOR 
08cd cd 6f ee			call debug_vector  
08d0				endm  
# End of macro CALLMONITOR
08d0				endif 
08d0			 
08d0				; get and load block 
08d0			 
08d0 cd ac 05			call storage_findnextid 
08d3			 
08d3				if DEBUG_STORESE 
08d3					DMARK "sf2" 
08d3 f5				push af  
08d4 3a e8 08			ld a, (.dmark)  
08d7 32 6b ee			ld (debug_mark),a  
08da 3a e9 08			ld a, (.dmark+1)  
08dd 32 6c ee			ld (debug_mark+1),a  
08e0 3a ea 08			ld a, (.dmark+2)  
08e3 32 6d ee			ld (debug_mark+2),a  
08e6 18 03			jr .pastdmark  
08e8 ..			.dmark: db "sf2"  
08eb f1			.pastdmark: pop af  
08ec			endm  
# End of macro DMARK
08ec					CALLMONITOR 
08ec cd 6f ee			call debug_vector  
08ef				endm  
# End of macro CALLMONITOR
08ef				endif 
08ef cd 10 0e			call ishlzero 
08f2			;	ld a, l 
08f2			;	add h 
08f2			;	cp 0 
08f2 ca d0 07			jp z,.sr_fail			; block not found so EOF 
08f5				 
08f5				; save current address for use by higher level words etc 
08f5			 
08f5 22 6b ea			ld (store_openaddr),hl 
08f8			 
08f8 cd 79 02			call storage_read_block 
08fb			 
08fb				; on a continuation block, we now have the file id and ext in the middle of the block 
08fb				; we need to pull everything back  
08fb			 
08fb ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08ff 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0902 23				inc hl 
0903 23				inc hl     ; skip id and ext 
0904 01 40 00			ld bc, STORE_BLOCK_PHY 
0907				if DEBUG_STORESE 
0907					DMARK "SR<" 
0907 f5				push af  
0908 3a 1c 09			ld a, (.dmark)  
090b 32 6b ee			ld (debug_mark),a  
090e 3a 1d 09			ld a, (.dmark+1)  
0911 32 6c ee			ld (debug_mark+1),a  
0914 3a 1e 09			ld a, (.dmark+2)  
0917 32 6d ee			ld (debug_mark+2),a  
091a 18 03			jr .pastdmark  
091c ..			.dmark: db "SR<"  
091f f1			.pastdmark: pop af  
0920			endm  
# End of macro DMARK
0920					CALLMONITOR 
0920 cd 6f ee			call debug_vector  
0923				endm  
# End of macro CALLMONITOR
0923				endif 
0923 ed b0			ldir     ; copy data 
0925			 
0925				; move the pointer back and pretend we have a full buffer for next recheck 
0925			 
0925 1b				dec de 
0926 1b				dec de 
0927			 
0927			; TODO do pop below now short circuit loop????? 
0927 c1				pop bc     ; get rid of spare de on stack 
0928				if DEBUG_STORESE 
0928					DMARK "SR>" 
0928 f5				push af  
0929 3a 3d 09			ld a, (.dmark)  
092c 32 6b ee			ld (debug_mark),a  
092f 3a 3e 09			ld a, (.dmark+1)  
0932 32 6c ee			ld (debug_mark+1),a  
0935 3a 3f 09			ld a, (.dmark+2)  
0938 32 6d ee			ld (debug_mark+2),a  
093b 18 03			jr .pastdmark  
093d ..			.dmark: db "SR>"  
0940 f1			.pastdmark: pop af  
0941			endm  
# End of macro DMARK
0941					CALLMONITOR 
0941 cd 6f ee			call debug_vector  
0944				endm  
# End of macro CALLMONITOR
0944				endif 
0944 c3 d5 07			jp .srext 
0947			 
0947			 
0947			 
0947			 
0947			 
0947			.readdone:		 
0947 e1				pop hl 		 ; return start of data to show as not EOF 
0948 23				inc hl   ; past file id 
0949 23				inc hl   ; past ext 
094a				if DEBUG_STORESE 
094a					DMARK "SRe" 
094a f5				push af  
094b 3a 5f 09			ld a, (.dmark)  
094e 32 6b ee			ld (debug_mark),a  
0951 3a 60 09			ld a, (.dmark+1)  
0954 32 6c ee			ld (debug_mark+1),a  
0957 3a 61 09			ld a, (.dmark+2)  
095a 32 6d ee			ld (debug_mark+2),a  
095d 18 03			jr .pastdmark  
095f ..			.dmark: db "SRe"  
0962 f1			.pastdmark: pop af  
0963			endm  
# End of macro DMARK
0963					CALLMONITOR 
0963 cd 6f ee			call debug_vector  
0966				endm  
# End of macro CALLMONITOR
0966				endif 
0966 c9					ret 
0967			 
0967			 
0967			 
0967			; 
0967			; Append File 
0967			; 
0967			; hl - file id to locate 
0967			; de - pointer to (multi block) string to write 
0967			 
0967			.sa_notfound: 
0967 d1				pop de 
0968 c9				ret 
0969			 
0969			 
0969			storage_append: 
0969				; hl -  file id to append to 
0969				; de - string to append 
0969			 
0969 d5				push de 
096a				 
096a				if DEBUG_STORESE 
096a					DMARK "AP1" 
096a f5				push af  
096b 3a 7f 09			ld a, (.dmark)  
096e 32 6b ee			ld (debug_mark),a  
0971 3a 80 09			ld a, (.dmark+1)  
0974 32 6c ee			ld (debug_mark+1),a  
0977 3a 81 09			ld a, (.dmark+2)  
097a 32 6d ee			ld (debug_mark+2),a  
097d 18 03			jr .pastdmark  
097f ..			.dmark: db "AP1"  
0982 f1			.pastdmark: pop af  
0983			endm  
# End of macro DMARK
0983					CALLMONITOR 
0983 cd 6f ee			call debug_vector  
0986				endm  
# End of macro CALLMONITOR
0986				endif 
0986			 
0986 7d				ld a, l 
0987 32 6e ea			ld (store_tmpid), a 
098a			 
098a				; get file header  
098a			 
098a 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098c 3a 6e ea			ld a, (store_tmpid) 
098f 5f				ld e, a 
0990			 
0990 21 40 00				ld hl, STORE_BLOCK_PHY 
0993 cd ac 05				call storage_findnextid 
0996			 
0996 cd 10 0e			call ishlzero 
0999 28 cc			jr z, .sa_notfound 
099b			 
099b 22 65 ea			ld (store_tmppageid), hl 
099e			 
099e				; TODO handle file id not found 
099e			 
099e				if DEBUG_STORESE 
099e					DMARK "AP2" 
099e f5				push af  
099f 3a b3 09			ld a, (.dmark)  
09a2 32 6b ee			ld (debug_mark),a  
09a5 3a b4 09			ld a, (.dmark+1)  
09a8 32 6c ee			ld (debug_mark+1),a  
09ab 3a b5 09			ld a, (.dmark+2)  
09ae 32 6d ee			ld (debug_mark+2),a  
09b1 18 03			jr .pastdmark  
09b3 ..			.dmark: db "AP2"  
09b6 f1			.pastdmark: pop af  
09b7			endm  
# End of macro DMARK
09b7					CALLMONITOR 
09b7 cd 6f ee			call debug_vector  
09ba				endm  
# End of macro CALLMONITOR
09ba				endif 
09ba			 
09ba				; update file extent count 
09ba			 
09ba 11 7a ea			ld de, store_page 
09bd			 
09bd cd 79 02			call storage_read_block 
09c0			 
09c0				if DEBUG_STORESE 
09c0					DMARK "AP3" 
09c0 f5				push af  
09c1 3a d5 09			ld a, (.dmark)  
09c4 32 6b ee			ld (debug_mark),a  
09c7 3a d6 09			ld a, (.dmark+1)  
09ca 32 6c ee			ld (debug_mark+1),a  
09cd 3a d7 09			ld a, (.dmark+2)  
09d0 32 6d ee			ld (debug_mark+2),a  
09d3 18 03			jr .pastdmark  
09d5 ..			.dmark: db "AP3"  
09d8 f1			.pastdmark: pop af  
09d9			endm  
# End of macro DMARK
09d9					CALLMONITOR 
09d9 cd 6f ee			call debug_vector  
09dc				endm  
# End of macro CALLMONITOR
09dc				endif 
09dc			;	ld (store_tmppageid), hl 
09dc			 
09dc 3a 7c ea			ld a, (store_page+2) 
09df 3c				inc a 
09e0 32 7c ea			ld (store_page+2), a 
09e3 32 6d ea			ld (store_tmpext), a 
09e6				 
09e6				if DEBUG_STORESE 
09e6					DMARK "AP3" 
09e6 f5				push af  
09e7 3a fb 09			ld a, (.dmark)  
09ea 32 6b ee			ld (debug_mark),a  
09ed 3a fc 09			ld a, (.dmark+1)  
09f0 32 6c ee			ld (debug_mark+1),a  
09f3 3a fd 09			ld a, (.dmark+2)  
09f6 32 6d ee			ld (debug_mark+2),a  
09f9 18 03			jr .pastdmark  
09fb ..			.dmark: db "AP3"  
09fe f1			.pastdmark: pop af  
09ff			endm  
# End of macro DMARK
09ff					CALLMONITOR 
09ff cd 6f ee			call debug_vector  
0a02				endm  
# End of macro CALLMONITOR
0a02				endif 
0a02 2a 65 ea			ld hl, (store_tmppageid) 
0a05 11 7a ea			ld de, store_page 
0a08 cd de 02			call storage_write_block 
0a0b			 
0a0b				; find free block 
0a0b			 
0a0b 11 00 00			ld de, 0			 ; file extent to locate 
0a0e			 
0a0e 21 40 00				ld hl, STORE_BLOCK_PHY 
0a11 cd ac 05				call storage_findnextid 
0a14 cd 10 0e			call ishlzero 
0a17 ca 67 09			jp z, .sa_notfound 
0a1a			 
0a1a					; TODO handle no space left 
0a1a					 
0a1a 22 65 ea				ld (store_tmppageid), hl 
0a1d			 
0a1d				if DEBUG_STORESE 
0a1d					DMARK "AP4" 
0a1d f5				push af  
0a1e 3a 32 0a			ld a, (.dmark)  
0a21 32 6b ee			ld (debug_mark),a  
0a24 3a 33 0a			ld a, (.dmark+1)  
0a27 32 6c ee			ld (debug_mark+1),a  
0a2a 3a 34 0a			ld a, (.dmark+2)  
0a2d 32 6d ee			ld (debug_mark+2),a  
0a30 18 03			jr .pastdmark  
0a32 ..			.dmark: db "AP4"  
0a35 f1			.pastdmark: pop af  
0a36			endm  
# End of macro DMARK
0a36					CALLMONITOR 
0a36 cd 6f ee			call debug_vector  
0a39				endm  
# End of macro CALLMONITOR
0a39				endif 
0a39					; init the buffer with zeros so we can id if the buffer is full or not 
0a39			 
0a39 e5					push hl 
0a3a c5					push bc 
0a3b			 
0a3b 21 7a ea				ld hl, store_page 
0a3e 06 40				ld b, STORE_BLOCK_PHY 
0a40 3e 00				ld a, 0 
0a42 77			.zeroblock:	ld (hl), a 
0a43 23					inc hl 
0a44 10 fc				djnz .zeroblock 
0a46			 
0a46 c1					pop bc 
0a47 e1					pop hl 
0a48			 
0a48					; construct block 
0a48			 
0a48 3a 6e ea				ld a, (store_tmpid) 
0a4b 32 7a ea				ld (store_page), a   ; file id 
0a4e 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
0a51 32 7b ea				ld (store_page+1), a 
0a54			 
0a54 e1					pop hl    ; get string to write 
0a55 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a57 11 7c ea				ld de, store_page+2 
0a5a			 
0a5a				if DEBUG_STORESE 
0a5a					DMARK "AP5" 
0a5a f5				push af  
0a5b 3a 6f 0a			ld a, (.dmark)  
0a5e 32 6b ee			ld (debug_mark),a  
0a61 3a 70 0a			ld a, (.dmark+1)  
0a64 32 6c ee			ld (debug_mark+1),a  
0a67 3a 71 0a			ld a, (.dmark+2)  
0a6a 32 6d ee			ld (debug_mark+2),a  
0a6d 18 03			jr .pastdmark  
0a6f ..			.dmark: db "AP5"  
0a72 f1			.pastdmark: pop af  
0a73			endm  
# End of macro DMARK
0a73					CALLMONITOR 
0a73 cd 6f ee			call debug_vector  
0a76				endm  
# End of macro CALLMONITOR
0a76				endif 
0a76			 
0a76			 
0a76			 
0a76					; fill buffer with data until end of string or full block 
0a76			 
0a76 7e			.appd:		ld a, (hl) 
0a77 12					ld (de), a 
0a78 fe 00				cp 0 
0a7a 28 04				jr z, .appdone 
0a7c 23					inc hl 
0a7d 13					inc de 
0a7e 10 f6				djnz .appd 
0a80			 
0a80 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a81 f5					push af   		; save last byte dumped 
0a82			 
0a82			 
0a82 2a 65 ea			ld hl, (store_tmppageid) 
0a85 11 7a ea			ld de, store_page 
0a88				if DEBUG_STORESE 
0a88					DMARK "AP6" 
0a88 f5				push af  
0a89 3a 9d 0a			ld a, (.dmark)  
0a8c 32 6b ee			ld (debug_mark),a  
0a8f 3a 9e 0a			ld a, (.dmark+1)  
0a92 32 6c ee			ld (debug_mark+1),a  
0a95 3a 9f 0a			ld a, (.dmark+2)  
0a98 32 6d ee			ld (debug_mark+2),a  
0a9b 18 03			jr .pastdmark  
0a9d ..			.dmark: db "AP6"  
0aa0 f1			.pastdmark: pop af  
0aa1			endm  
# End of macro DMARK
0aa1					CALLMONITOR 
0aa1 cd 6f ee			call debug_vector  
0aa4				endm  
# End of macro CALLMONITOR
0aa4				endif 
0aa4 cd de 02				call storage_write_block 
0aa7			 
0aa7			 
0aa7				; was that a full block of data written? 
0aa7				; any more to write out? 
0aa7			 
0aa7				; if yes then set vars and jump to start of function again 
0aa7			 
0aa7 f1					pop af 
0aa8 d1					pop de 
0aa9			 
0aa9 fe 00				cp 0		 ; no, string was fully written 
0aab c8					ret z 
0aac			 
0aac					; setup vars for next cycle 
0aac			 
0aac 3a 6e ea				ld a, (store_tmpid) 
0aaf 6f					ld l, a 
0ab0 26 00				ld h, 0 
0ab2			 
0ab2 c3 69 09			 	jp storage_append	 ; yes, need to write out some more 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			 
0ab5			if DEBUG_STORECF 
0ab5			storageput:	 
0ab5					ret 
0ab5			storageread: 
0ab5					ld hl, store_page 
0ab5					ld b, 200 
0ab5					ld a,0 
0ab5			.src:		ld (hl),a 
0ab5					inc hl 
0ab5					djnz .src 
0ab5					 
0ab5			 
0ab5					ld de, 0 
0ab5					ld bc, 1 
0ab5					ld hl, store_page 
0ab5					call cfRead 
0ab5			 
0ab5				call cfGetError 
0ab5				ld hl,scratch 
0ab5				call hexout 
0ab5				ld hl, scratch+2 
0ab5				ld a, 0 
0ab5				ld (hl),a 
0ab5				ld de, scratch 
0ab5				ld a,display_row_1 
0ab5				call str_at_display 
0ab5				call update_display 
0ab5			 
0ab5					ld hl, store_page 
0ab5					ld (os_cur_ptr),hl 
0ab5			 
0ab5					ret 
0ab5			endif 
0ab5			 
0ab5			 
0ab5			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab5			 
0ab5			storage_clear_page: 
0ab5 e5				push hl 
0ab6 d5				push de 
0ab7 c5				push bc 
0ab8 21 7a ea			ld hl, store_page 
0abb 3e 00			ld a, 0 
0abd 77				ld (hl), a 
0abe			 
0abe 11 7b ea			ld de, store_page+1 
0ac1 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ac4			 
0ac4 ed b0			ldir 
0ac6				 
0ac6 c1				pop bc 
0ac7 d1				pop de 
0ac8 e1				pop hl 
0ac9 c9				ret 
0aca			 
0aca			; eof 
# End of file firmware_storage.asm
0aca			  
0aca			; support routines for above hardware abstraction layer  
0aca			  
0aca			include "firmware_general.asm"        ; general support functions  
0aca			 
0aca			; word look up 
0aca			 
0aca			; in 
0aca			; a is the index 
0aca			; hl is pointer start of array 
0aca			; 
0aca			; returns 
0aca			; hl to the word 
0aca			; 
0aca			 
0aca			table_lookup:  
0aca d5					push de 
0acb eb					ex de, hl 
0acc			 
0acc 6f					ld l, a 
0acd 26 00				ld h, 0 
0acf 29					add hl, hl 
0ad0 19					add hl, de 
0ad1 7e					ld a, (hl) 
0ad2 23					inc hl 
0ad3 66					ld h,(hl) 
0ad4 6f					ld l, a 
0ad5			 
0ad5 d1					pop de 
0ad6 c9					ret 
0ad7			 
0ad7			; Delay loops 
0ad7			 
0ad7			 
0ad7			 
0ad7			aDelayInMS: 
0ad7 c5				push bc 
0ad8 47				ld b,a 
0ad9			msdelay: 
0ad9 c5				push bc 
0ada				 
0ada			 
0ada 01 41 00			ld bc,041h 
0add cd f5 0a			call delayloop 
0ae0 c1				pop bc 
0ae1 05				dec b 
0ae2 20 f5			jr nz,msdelay 
0ae4			 
0ae4			;if CPU_CLOCK_8MHZ 
0ae4			;msdelay8: 
0ae4			;	push bc 
0ae4			;	 
0ae4			; 
0ae4			;	ld bc,041h 
0ae4			;	call delayloop 
0ae4			;	pop bc 
0ae4			;	dec b 
0ae4			;	jr nz,msdelay8 
0ae4			;endif 
0ae4			 
0ae4			 
0ae4 c1				pop bc 
0ae5 c9				ret 
0ae6			 
0ae6			 
0ae6			delay250ms: 
0ae6				;push de 
0ae6 01 00 40			ld bc, 04000h 
0ae9 c3 f5 0a			jp delayloop 
0aec			delay500ms: 
0aec				;push de 
0aec 01 00 80			ld bc, 08000h 
0aef c3 f5 0a			jp delayloop 
0af2			delay1s: 
0af2				;push bc 
0af2			   ; Clobbers A, d and e 
0af2 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af5			delayloop: 
0af5 c5			    push bc 
0af6			 
0af6			if BASE_CPM 
0af6 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af9			.cpmloop: 
0af9 c5				push bc 
0afa			 
0afa			endif 
0afa			 
0afa			 
0afa			 
0afa			delayloopi: 
0afa			;	push bc 
0afa			;.dl: 
0afa cb 47		    bit     0,a    	; 8 
0afc cb 47		    bit     0,a    	; 8 
0afe cb 47		    bit     0,a    	; 8 
0b00 e6 ff		    and     255  	; 7 
0b02 0b			    dec     bc      	; 6 
0b03 79			    ld      a,c     	; 4 
0b04 b0			    or      b     	; 4 
0b05 c2 fa 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b08			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b08				;pop de 
0b08			;pop bc 
0b08			 
0b08			if BASE_CPM 
0b08 c1				pop bc 
0b09				 
0b09 0b			    dec     bc      	; 6 
0b0a 79			    ld      a,c     	; 4 
0b0b b0			    or      b     	; 4 
0b0c c2 f9 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0f				 
0b0f			 
0b0f			endif 
0b0f			;if CPU_CLOCK_8MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f			 
0b0f			;if CPU_CLOCK_10MHZ 
0b0f			;    pop bc 
0b0f			;    push bc 
0b0f			;.dl8: 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    bit     0,a    	; 8 
0b0f			;    and     255  	; 7 
0b0f			;    dec     bc      	; 6 
0b0f			;    ld      a,c     	; 4 
0b0f			;    or      b     	; 4 
0b0f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0f			;endif 
0b0f c1			    pop bc 
0b10			 
0b10 c9				ret 
0b11			 
0b11			 
0b11			 
0b11			; eof 
# End of file firmware_general.asm
0b11			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b11			; display routines that use the physical hardware abstraction layer 
0b11			 
0b11			 
0b11			; Display an activity indicator 
0b11			; Each call returns the new char pointed to in hl 
0b11			 
0b11			active: 
0b11 3a c6 eb			ld a, (display_active) 
0b14 fe 06			cp 6 
0b16			 
0b16 20 02			jr nz, .sne 
0b18				; gone past the last one reset sequence 
0b18 3e ff			ld a, 255 
0b1a			 
0b1a			.sne:   
0b1a				; get the next char in seq 
0b1a 3c				inc a 
0b1b 32 c6 eb			ld (display_active), a 
0b1e			 
0b1e				; look up the string in the table 
0b1e 21 35 0b			ld hl, actseq 
0b21 cb 27			sla a 
0b23 cd e7 0d			call addatohl 
0b26 cd 85 1f			call loadwordinhl 
0b29			 
0b29				; forth will write the to string when pushing so move from rom to ram 
0b29			 
0b29 11 c7 eb			ld de, display_active+1 
0b2c 01 02 00			ld bc, 2 
0b2f ed b0			ldir 
0b31			 
0b31 21 c7 eb			ld hl, display_active+1 
0b34 c9				ret 
0b35				 
0b35				 
0b35			 
0b35			 
0b35			;db "|/-\|-\" 
0b35			 
0b35			actseq: 
0b35			 
0b35 43 0b		dw spin0 
0b37 45 0b		dw spin1 
0b39 47 0b		dw spin2 
0b3b 49 0b		dw spin3 
0b3d 47 0b		dw spin2 
0b3f 45 0b		dw spin1 
0b41 43 0b		dw spin0 
0b43			 
0b43 .. 00		spin0: db " ", 0 
0b45 .. 00		spin1: db "-", 0 
0b47 .. 00		spin2: db "+", 0 
0b49 .. 00		spin3: db "#", 0 
0b4b			 
0b4b			 
0b4b			; information window 
0b4b			 
0b4b			; pass hl with 1st string to display 
0b4b			; pass de with 2nd string to display 
0b4b			 
0b4b			info_panel: 
0b4b e5				push hl 
0b4c			 
0b4c 2a cc eb			ld hl, (display_fb_active) 
0b4f e5				push hl    ; future de destination 
0b50 21 b1 ed				ld hl, display_fb0 
0b53 22 cc eb				ld (display_fb_active), hl 
0b56			 
0b56			;	call clear_display 
0b56			 
0b56				if BASE_CPM 
0b56 3e 2e			ld a, '.' 
0b58				else 
0b58				ld a, 165 
0b58				endif 
0b58 cd bf 0b			call fill_display 
0b5b			 
0b5b			 
0b5b 3e 55			ld a, display_row_3 + 5 
0b5d cd cd 0b			call str_at_display 
0b60			 
0b60 e1				pop hl 
0b61 d1				pop de 
0b62			 
0b62 e5				push hl 
0b63			 
0b63			 
0b63 3e 2d			ld a, display_row_2 + 5 
0b65 cd cd 0b			call str_at_display 
0b68			 
0b68			 
0b68 cd dd 0b			call update_display 
0b6b cd ce 1b			call next_page_prompt 
0b6e cd ba 0b			call clear_display 
0b71			 
0b71				 
0b71 21 10 ed				ld hl, display_fb1 
0b74 22 cc eb				ld (display_fb_active), hl 
0b77 cd dd 0b			call update_display 
0b7a			 
0b7a e1				pop hl 
0b7b			 
0b7b c9				ret 
0b7c			 
0b7c			 
0b7c			 
0b7c			 
0b7c			; TODO windowing? 
0b7c			 
0b7c			; TODO scroll line up 
0b7c			 
0b7c			scroll_up: 
0b7c			 
0b7c e5				push hl 
0b7d d5				push de 
0b7e c5				push bc 
0b7f			 
0b7f				; get frame buffer  
0b7f			 
0b7f 2a cc eb			ld hl, (display_fb_active) 
0b82 e5				push hl    ; future de destination 
0b83			 
0b83 11 28 00			ld  de, display_cols 
0b86 19				add hl, de 
0b87			 
0b87 d1				pop de 
0b88			 
0b88				;ex de, hl 
0b88 01 9f 00			ld bc, display_fb_len -1  
0b8b			;if DEBUG_FORTH_WORDS 
0b8b			;	DMARK "SCL" 
0b8b			;	CALLMONITOR 
0b8b			;endif	 
0b8b ed b0			ldir 
0b8d			 
0b8d				; wipe bottom row 
0b8d			 
0b8d			 
0b8d 2a cc eb			ld hl, (display_fb_active) 
0b90 11 a0 00			ld de, display_cols*display_rows 
0b93 19				add hl, de 
0b94 06 28			ld b, display_cols 
0b96 3e 20			ld a, ' ' 
0b98			.scwipe: 
0b98 77				ld (hl), a 
0b99 2b				dec hl 
0b9a 10 fc			djnz .scwipe 
0b9c			 
0b9c				;pop hl 
0b9c			 
0b9c c1				pop bc 
0b9d d1				pop de 
0b9e e1				pop hl 
0b9f			 
0b9f c9				ret 
0ba0			 
0ba0			 
0ba0			;scroll_upo: 
0ba0			;	ld de, display_row_1 
0ba0			 ;	ld hl, display_row_2 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			;	ld de, display_row_2 
0ba0			 ;	ld hl, display_row_3 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			;	ld de, display_row_3 
0ba0			 ;	ld hl, display_row_4 
0ba0			;	ld bc, display_cols 
0ba0			;	ldir 
0ba0			 
0ba0			; TODO clear row 4 
0ba0			 
0ba0			;	ret 
0ba0			 
0ba0				 
0ba0			scroll_down: 
0ba0			 
0ba0 e5				push hl 
0ba1 d5				push de 
0ba2 c5				push bc 
0ba3			 
0ba3				; get frame buffer  
0ba3			 
0ba3 2a cc eb			ld hl, (display_fb_active) 
0ba6			 
0ba6 11 9f 00			ld de, display_fb_len - 1 
0ba9 19				add hl, de 
0baa			 
0baa e5			push hl    ; future de destination 
0bab			 
0bab 11 28 00			ld  de, display_cols 
0bae ed 52			sbc hl, de 
0bb0			 
0bb0			 
0bb0 d1				pop de 
0bb1			 
0bb1			;	ex de, hl 
0bb1 01 9f 00			ld bc, display_fb_len -1  
0bb4			 
0bb4			 
0bb4				 
0bb4			 
0bb4 ed b0			ldir 
0bb6			 
0bb6				; wipe bottom row 
0bb6			 
0bb6			 
0bb6			;	ld hl, (display_fb_active) 
0bb6			;;	ld de, display_cols*display_rows 
0bb6			;;	add hl, de 
0bb6			;	ld b, display_cols 
0bb6			;	ld a, ' ' 
0bb6			;.scwiped: 
0bb6			;	ld (hl), a 
0bb6			;	dec hl 
0bb6			;	djnz .scwiped 
0bb6			 
0bb6				;pop hl 
0bb6			 
0bb6 c1				pop bc 
0bb7 d1				pop de 
0bb8 e1				pop hl 
0bb9			 
0bb9 c9				ret 
0bba			;scroll_down: 
0bba			;	ld de, display_row_4 
0bba			;	ld hl, display_row_3 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;	ld de, display_row_3 
0bba			; 	ld hl, display_row_2 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;	ld de, display_row_2 
0bba			;	ld hl, display_row_1 
0bba			;	ld bc, display_cols 
0bba			;	ldir 
0bba			;;; TODO clear row 1 
0bba			;	ret 
0bba			 
0bba			 
0bba			 
0bba			 
0bba			 
0bba			; clear active frame buffer 
0bba			 
0bba			clear_display: 
0bba 3e 20			ld a, ' ' 
0bbc c3 bf 0b			jp fill_display 
0bbf			 
0bbf			; fill active frame buffer with a char in A 
0bbf			 
0bbf			fill_display: 
0bbf 06 a0			ld b,display_fb_len 
0bc1 2a cc eb			ld hl, (display_fb_active) 
0bc4 77			.fd1:	ld (hl),a 
0bc5 23				inc hl 
0bc6 10 fc			djnz .fd1 
0bc8 23				inc hl 
0bc9 3e 00			ld a,0 
0bcb 77				ld (hl),a 
0bcc			 
0bcc			 
0bcc c9				ret 
0bcd			; Write string (DE) at pos (A) to active frame buffer 
0bcd			 
0bcd 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
0bd0 06 00					ld b,0 
0bd2 4f					ld c,a 
0bd3 09					add hl,bc 
0bd4 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bd5 b7			            OR   A              ;Null terminator? 
0bd6 c8			            RET  Z              ;Yes, so finished 
0bd7 77					ld (hl),a 
0bd8 23				inc hl 
0bd9 13			            INC  DE             ;Point to next character 
0bda 18 f8		            JR   .sad1     ;Repeat 
0bdc c9					ret 
0bdd			 
0bdd			; using current frame buffer write to physical display 
0bdd			 
0bdd			update_display: 
0bdd e5				push hl 
0bde 2a cc eb			ld hl, (display_fb_active) 
0be1 cd cd 64			call write_display 
0be4 e1				pop hl 
0be5 c9				ret 
0be6			 
0be6			; TODO scrolling 
0be6			 
0be6			 
0be6			; move cursor right one char 
0be6			cursor_right: 
0be6			 
0be6				; TODO shift right 
0be6				; TODO if beyond max col 
0be6				; TODO       cursor_next_line 
0be6			 
0be6 c9				ret 
0be7			 
0be7			 
0be7			cursor_next_line: 
0be7				; TODO first char 
0be7				; TODO line down 
0be7				; TODO if past last row 
0be7				; TODO    scroll up 
0be7			 
0be7 c9				ret 
0be8			 
0be8			cursor_left: 
0be8				; TODO shift left 
0be8				; TODO if beyond left  
0be8				; TODO     cursor prev line 
0be8				 
0be8 c9				ret 
0be9			 
0be9			cursor_prev_line: 
0be9				; TODO last char 
0be9				; TODO line up 
0be9				; TODO if past first row 
0be9				; TODO   scroll down 
0be9			 
0be9 c9				ret 
0bea			 
0bea			 
0bea			cout: 
0bea				; A - char 
0bea c9				ret 
0beb			 
0beb			 
0beb			; Display a menu and allow item selection (optional toggle items) 
0beb			; 
0beb			; format: 
0beb			; hl pointer to word array with zero term for items 
0beb			; e.g.    db item1 
0beb			;         db .... 
0beb			;         db 0 
0beb			; 
0beb			; a = starting menu item  
0beb			; 
0beb			; de = pointer item toggle array   (todo) 
0beb			; 
0beb			; returns item selected in a 1-... 
0beb			; returns 0 if back button pressed 
0beb			; 
0beb			; NOTE: Uses system frame buffer to display 
0beb			; 
0beb			; LEFT, Q = go back 
0beb			; RIGHT, SPACE, CR = select 
0beb			; UP, A - Up 
0beb			; DOWN, Z - Down 
0beb			 
0beb			 
0beb			 
0beb			 
0beb			 
0beb			menu: 
0beb			 
0beb					; keep array pointer 
0beb			 
0beb 22 73 ea				ld (store_tmp1), hl 
0bee 32 71 ea				ld (store_tmp2), a 
0bf1			 
0bf1					; check for key bounce 
0bf1			 
0bf1			if BASE_KEV 
0bf1			 
0bf1			.mbounce:	call cin 
0bf1					cp 0 
0bf1					jr nz, .mbounce 
0bf1			endif 
0bf1					; for ease use ex 
0bf1			 
0bf1					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bf1 21 b1 ed				ld hl, display_fb0 
0bf4 22 cc eb				ld (display_fb_active), hl 
0bf7			 
0bf7 cd ba 0b		.mloop:		call clear_display 
0bfa cd dd 0b				call update_display 
0bfd			 
0bfd					; draw selection id '>' at 1 
0bfd			 
0bfd					; init start of list display 
0bfd			 
0bfd 3e 05				ld a, 5 
0bff 32 6f ea				ld (store_tmp3), a   ; display row count 
0c02 3a 71 ea				ld a,( store_tmp2) 
0c05 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c08			 
0c08					 
0c08			.mitem:	 
0c08			 
0c08			 
0c08 3a 72 ea				ld a,(store_tmp2+1) 
0c0b 6f					ld l, a 
0c0c 26 00				ld h, 0 
0c0e 29					add hl, hl 
0c0f ed 5b 73 ea			ld de, (store_tmp1) 
0c13 19					add hl, de 
0c14 7e					ld a, (hl) 
0c15 23					inc hl 
0c16 66					ld h,(hl) 
0c17 6f					ld l, a 
0c18			 
0c18 cd 10 0e				call ishlzero 
0c1b 28 1a				jr z, .mdone 
0c1d			 
0c1d eb					ex de, hl 
0c1e 3a 6f ea				ld a, (store_tmp3) 
0c21 cd cd 0b				call str_at_display 
0c24					 
0c24			 
0c24					; next item 
0c24 3a 72 ea				ld a, (store_tmp2+1) 
0c27 3c					inc a 
0c28 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c2b			 
0c2b			 		; next row 
0c2b			 
0c2b 3a 6f ea				ld a, (store_tmp3) 
0c2e c6 28				add display_cols 
0c30 32 6f ea				ld (store_tmp3), a 
0c33			 
0c33					; at end of screen? 
0c33			 
0c33 fe 10				cp display_rows*4 
0c35 20 d1				jr nz, .mitem 
0c37			 
0c37			 
0c37			.mdone: 
0c37 cd 10 0e				call ishlzero 
0c3a 28 08				jr z, .nodn 
0c3c			 
0c3c 3e 78				ld a, display_row_4 
0c3e 11 bd 0c				ld de, .mdown 
0c41 cd cd 0b				call str_at_display 
0c44			 
0c44					; draw options to fill the screens with active item on line 1 
0c44					; if current option is 2 or more then display ^ in top 
0c44			 
0c44 3a 71 ea		.nodn:		ld a, (store_tmp2) 
0c47 fe 00				cp 0 
0c49 28 08				jr z, .noup 
0c4b			 
0c4b 3e 00				ld a, 0 
0c4d 11 bb 0c				ld de, .mup 
0c50 cd cd 0b				call str_at_display 
0c53			 
0c53 3e 02		.noup:		ld a, 2 
0c55 11 b9 0c				ld de, .msel 
0c58 cd cd 0b				call str_at_display 
0c5b			 
0c5b					; if current option + 1 is not null then display V in bottom 
0c5b					; get key 
0c5b cd dd 0b				call update_display 
0c5e			 
0c5e			 
0c5e					; handle key 
0c5e			 
0c5e cd 7f 65				call cin_wait 
0c61			 
0c61 fe 05				cp KEY_UP 
0c63 28 2b				jr z, .mgoup 
0c65 fe 61				cp 'a' 
0c67 28 27				jr z, .mgoup 
0c69 fe 0a				cp KEY_DOWN 
0c6b 28 32				jr z, .mgod 
0c6d fe 7a				cp 'z' 
0c6f 28 2e				jr z, .mgod 
0c71 fe 20				cp ' ' 
0c73 28 34				jr z, .goend 
0c75 fe 0c				cp KEY_RIGHT 
0c77 28 30				jr z, .goend 
0c79 fe 0d				cp KEY_CR 
0c7b 28 2c				jr z, .goend 
0c7d fe 71				cp 'q' 
0c7f 28 0b				jr z, .goback 
0c81			 
0c81 fe 0b				cp KEY_LEFT 
0c83 28 07				jr z, .goback 
0c85 fe 08				cp KEY_BS 
0c87 28 03				jr z, .goback 
0c89 c3 f7 0b				jp .mloop 
0c8c			 
0c8c			.goback: 
0c8c 3e 00			ld a, 0 
0c8e 18 1d			jr .goend2 
0c90			 
0c90				; move up one 
0c90			.mgoup: 
0c90 3a 71 ea				ld a, (store_tmp2) 
0c93 fe 00				cp 0 
0c95 ca f7 0b				jp z, .mloop 
0c98 3d					dec a 
0c99 32 71 ea				ld (store_tmp2), a 
0c9c c3 f7 0b				jp .mloop 
0c9f			 
0c9f				; move down one 
0c9f			.mgod: 
0c9f 3a 71 ea				ld a, (store_tmp2) 
0ca2 3c					inc a 
0ca3 32 71 ea				ld (store_tmp2), a 
0ca6 c3 f7 0b				jp .mloop 
0ca9			 
0ca9			 
0ca9			.goend: 
0ca9					; get selected item number 
0ca9			 
0ca9 3a 71 ea				ld a, (store_tmp2) 
0cac 3c					inc a 
0cad			 
0cad			.goend2: 
0cad f5					push af 
0cae			 
0cae					; restore active fb 
0cae					; TODO BUG assumes fb1 
0cae			 
0cae 21 10 ed				ld hl, display_fb1 
0cb1 22 cc eb				ld (display_fb_active), hl 
0cb4			 
0cb4					; restore main regs 
0cb4			 
0cb4			 
0cb4 cd dd 0b				call update_display 
0cb7			 
0cb7 f1					pop af 
0cb8			 
0cb8 c9				ret 
0cb9			 
0cb9 .. 00		.msel:   db ">",0 
0cbb .. 00		.mup:   db "^",0 
0cbd .. 00		.mdown:   db "v",0 
0cbf			 
0cbf			 
0cbf			; eof 
0cbf			 
# End of file firmware_display.asm
0cbf			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cbf			; random number generators 
0cbf			 
0cbf			 
0cbf			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cbf			 
0cbf			 
0cbf			;-----> Generate a random number 
0cbf			; output a=answer 0<=a<=255 
0cbf			; all registers are preserved except: af 
0cbf			random: 
0cbf e5			        push    hl 
0cc0 d5			        push    de 
0cc1 2a ab eb		        ld      hl,(randData) 
0cc4 ed 5f		        ld      a,r 
0cc6 57			        ld      d,a 
0cc7 5e			        ld      e,(hl) 
0cc8 19			        add     hl,de 
0cc9 85			        add     a,l 
0cca ac			        xor     h 
0ccb 22 ab eb		        ld      (randData),hl 
0cce d1			        pop     de 
0ccf e1			        pop     hl 
0cd0 c9			        ret 
0cd1			 
0cd1			 
0cd1			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cd1			 
0cd1			 
0cd1			 
0cd1			;------LFSR------ 
0cd1			;James Montelongo 
0cd1			;optimized by Spencer Putt 
0cd1			;out: 
0cd1			; a = 8 bit random number 
0cd1			RandLFSR: 
0cd1 21 b1 eb		        ld hl,LFSRSeed+4 
0cd4 5e			        ld e,(hl) 
0cd5 23			        inc hl 
0cd6 56			        ld d,(hl) 
0cd7 23			        inc hl 
0cd8 4e			        ld c,(hl) 
0cd9 23			        inc hl 
0cda 7e			        ld a,(hl) 
0cdb 47			        ld b,a 
0cdc cb 13		        rl e  
0cde cb 12			rl d 
0ce0 cb 11		        rl c  
0ce2 17				rla 
0ce3 cb 13		        rl e  
0ce5 cb 12			rl d 
0ce7 cb 11		        rl c  
0ce9 17				rla 
0cea cb 13		        rl e  
0cec cb 12			rl d 
0cee cb 11		        rl c  
0cf0 17				rla 
0cf1 67			        ld h,a 
0cf2 cb 13		        rl e  
0cf4 cb 12			rl d 
0cf6 cb 11		        rl c  
0cf8 17				rla 
0cf9 a8			        xor b 
0cfa cb 13		        rl e  
0cfc cb 12			rl d 
0cfe ac			        xor h 
0cff a9			        xor c 
0d00 aa			        xor d 
0d01 21 b3 eb		        ld hl,LFSRSeed+6 
0d04 11 b4 eb		        ld de,LFSRSeed+7 
0d07 01 07 00		        ld bc,7 
0d0a ed b8		        lddr 
0d0c 12			        ld (de),a 
0d0d c9			        ret 
0d0e			 
0d0e			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d0e			 
0d0e			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d0e			 
0d0e			 
0d0e			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d0e			 
0d0e			prng16: 
0d0e			;Inputs: 
0d0e			;   (seed1) contains a 16-bit seed value 
0d0e			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d0e			;Outputs: 
0d0e			;   HL is the result 
0d0e			;   BC is the result of the LCG, so not that great of quality 
0d0e			;   DE is preserved 
0d0e			;Destroys: 
0d0e			;   AF 
0d0e			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d0e			;160cc 
0d0e			;26 bytes 
0d0e 2a a5 eb		    ld hl,(seed1) 
0d11 44			    ld b,h 
0d12 4d			    ld c,l 
0d13 29			    add hl,hl 
0d14 29			    add hl,hl 
0d15 2c			    inc l 
0d16 09			    add hl,bc 
0d17 22 a5 eb		    ld (seed1),hl 
0d1a 2a a3 eb		    ld hl,(seed2) 
0d1d 29			    add hl,hl 
0d1e 9f			    sbc a,a 
0d1f e6 2d		    and %00101101 
0d21 ad			    xor l 
0d22 6f			    ld l,a 
0d23 22 a3 eb		    ld (seed2),hl 
0d26 09			    add hl,bc 
0d27 c9			    ret 
0d28			 
0d28			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d28			 
0d28			rand32: 
0d28			;Inputs: 
0d28			;   (seed1_0) holds the lower 16 bits of the first seed 
0d28			;   (seed1_1) holds the upper 16 bits of the first seed 
0d28			;   (seed2_0) holds the lower 16 bits of the second seed 
0d28			;   (seed2_1) holds the upper 16 bits of the second seed 
0d28			;   **NOTE: seed2 must be non-zero 
0d28			;Outputs: 
0d28			;   HL is the result 
0d28			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d28			;Destroys: 
0d28			;   AF 
0d28			;Tested and passes all CAcert tests 
0d28			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d28			;it has a period of 18,446,744,069,414,584,320 
0d28			;roughly 18.4 quintillion. 
0d28			;LFSR taps: 0,2,6,7  = 11000101 
0d28			;291cc 
0d28			;seed1_0=$+1 
0d28			;    ld hl,12345 
0d28			;seed1_1=$+1 
0d28			;    ld de,6789 
0d28			;    ld b,h 
0d28			;    ld c,l 
0d28			;    add hl,hl \ rl e \ rl d 
0d28			;    add hl,hl \ rl e \ rl d 
0d28			;    inc l 
0d28			;    add hl,bc 
0d28			;    ld (seed1_0),hl 
0d28			;    ld hl,(seed1_1) 
0d28			;    adc hl,de 
0d28			;    ld (seed1_1),hl 
0d28			;    ex de,hl 
0d28			;seed2_0=$+1 
0d28			;    ld hl,9876 
0d28			;seed2_1=$+1 
0d28			;    ld bc,54321 
0d28			;    add hl,hl \ rl c \ rl b 
0d28			;    ld (seed2_1),bc 
0d28			;    sbc a,a 
0d28			;    and %11000101 
0d28			;    xor l 
0d28			;    ld l,a 
0d28			;    ld (seed2_0),hl 
0d28			;    ex de,hl 
0d28			;    add hl,bc 
0d28			;    ret 
0d28			; 
0d28			 
0d28			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d28			; 20 bytes, 86 cycles (excluding ret) 
0d28			 
0d28			; returns   hl = pseudorandom number 
0d28			; corrupts   a 
0d28			 
0d28			; generates 16-bit pseudorandom numbers with a period of 65535 
0d28			; using the xorshift method: 
0d28			 
0d28			; hl ^= hl << 7 
0d28			; hl ^= hl >> 9 
0d28			; hl ^= hl << 8 
0d28			 
0d28			; some alternative shift triplets which also perform well are: 
0d28			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d28			 
0d28			;  org 32768 
0d28			 
0d28			xrnd: 
0d28 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d2b 3e 00		  ld a,0 
0d2d bd			  cp l 
0d2e 20 02		  jr nz, .xrnd1 
0d30 2e 01		  ld l, 1 
0d32			.xrnd1: 
0d32			 
0d32 7c			  ld a,h 
0d33 1f			  rra 
0d34 7d			  ld a,l 
0d35 1f			  rra 
0d36 ac			  xor h 
0d37 67			  ld h,a 
0d38 7d			  ld a,l 
0d39 1f			  rra 
0d3a 7c			  ld a,h 
0d3b 1f			  rra 
0d3c ad			  xor l 
0d3d 6f			  ld l,a 
0d3e ac			  xor h 
0d3f 67			  ld h,a 
0d40			 
0d40 22 a9 eb		  ld (xrandc),hl 
0d43			 
0d43 c9			  ret 
0d44			;  
0d44			 
0d44			 
0d44			;;;; int maths 
0d44			 
0d44			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d44			; Divide 16-bit values (with 16-bit result) 
0d44			; In: Divide BC by divider DE 
0d44			; Out: BC = result, HL = rest 
0d44			; 
0d44			Div16: 
0d44 21 00 00		    ld hl,0 
0d47 78			    ld a,b 
0d48 06 08		    ld b,8 
0d4a			Div16_Loop1: 
0d4a 17			    rla 
0d4b ed 6a		    adc hl,hl 
0d4d ed 52		    sbc hl,de 
0d4f 30 01		    jr nc,Div16_NoAdd1 
0d51 19			    add hl,de 
0d52			Div16_NoAdd1: 
0d52 10 f6		    djnz Div16_Loop1 
0d54 17			    rla 
0d55 2f			    cpl 
0d56 47			    ld b,a 
0d57 79			    ld a,c 
0d58 48			    ld c,b 
0d59 06 08		    ld b,8 
0d5b			Div16_Loop2: 
0d5b 17			    rla 
0d5c ed 6a		    adc hl,hl 
0d5e ed 52		    sbc hl,de 
0d60 30 01		    jr nc,Div16_NoAdd2 
0d62 19			    add hl,de 
0d63			Div16_NoAdd2: 
0d63 10 f6		    djnz Div16_Loop2 
0d65 17			    rla 
0d66 2f			    cpl 
0d67 41			    ld b,c 
0d68 4f			    ld c,a 
0d69 c9			ret 
0d6a			 
0d6a			 
0d6a			;http://z80-heaven.wikidot.com/math 
0d6a			; 
0d6a			;Inputs: 
0d6a			;     DE and A are factors 
0d6a			;Outputs: 
0d6a			;     A is not changed 
0d6a			;     B is 0 
0d6a			;     C is not changed 
0d6a			;     DE is not changed 
0d6a			;     HL is the product 
0d6a			;Time: 
0d6a			;     342+6x 
0d6a			; 
0d6a			Mult16: 
0d6a			 
0d6a 06 08		     ld b,8          ;7           7 
0d6c 21 00 00		     ld hl,0         ;10         10 
0d6f 29			       add hl,hl     ;11*8       88 
0d70 07			       rlca          ;4*8        32 
0d71 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d73 19			         add hl,de   ;--         -- 
0d74 10 f9		       djnz $-5      ;13*7+8     99 
0d76 c9			ret 
0d77			 
0d77			; 
0d77			; Square root of 16-bit value 
0d77			; In:  HL = value 
0d77			; Out:  D = result (rounded down) 
0d77			; 
0d77			;Sqr16: 
0d77			;    ld de,#0040 
0d77			;    ld a,l 
0d77			;    ld l,h 
0d77			;    ld h,d 
0d77			;    or a 
0d77			;    ld b,8 
0d77			;Sqr16_Loop: 
0d77			;    sbc hl,de 
0d77			;    jr nc,Sqr16_Skip 
0d77			;    add hl,de 
0d77			;Sqr16_Skip: 
0d77			;    ccf 
0d77			;    rl d 
0d77			;    add a,a 
0d77			;    adc hl,hl 
0d77			;    add a,a 
0d77			;    adc hl,hl 
0d77			;    djnz Sqr16_Loop 
0d77			;    ret 
0d77			; 
0d77			; 
0d77			; Divide 8-bit values 
0d77			; In: Divide E by divider C 
0d77			; Out: A = result, B = rest 
0d77			; 
0d77			Div8: 
0d77 af			    xor a 
0d78 06 08		    ld b,8 
0d7a			Div8_Loop: 
0d7a cb 13		    rl e 
0d7c 17			    rla 
0d7d 91			    sub c 
0d7e 30 01		    jr nc,Div8_NoAdd 
0d80 81			    add a,c 
0d81			Div8_NoAdd: 
0d81 10 f7		    djnz Div8_Loop 
0d83 47			    ld b,a 
0d84 7b			    ld a,e 
0d85 17			    rla 
0d86 2f			    cpl 
0d87 c9			    ret 
0d88			 
0d88			; 
0d88			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d88			; In: Multiply A with DE 
0d88			; Out: HL = result 
0d88			; 
0d88			Mult12U: 
0d88 2e 00		    ld l,0 
0d8a 87			    add a,a 
0d8b 30 01		    jr nc,Mult12U_NoAdd0 
0d8d 19			    add hl,de 
0d8e			Mult12U_NoAdd0: 
0d8e 29			    add hl,hl 
0d8f 87			    add a,a 
0d90 30 01		    jr nc,Mult12U_NoAdd1 
0d92 19			    add hl,de 
0d93			Mult12U_NoAdd1: 
0d93 29			    add hl,hl 
0d94 87			    add a,a 
0d95 30 01		    jr nc,Mult12U_NoAdd2 
0d97 19			    add hl,de 
0d98			Mult12U_NoAdd2: 
0d98 29			    add hl,hl 
0d99 87			    add a,a 
0d9a 30 01		    jr nc,Mult12U_NoAdd3 
0d9c 19			    add hl,de 
0d9d			Mult12U_NoAdd3: 
0d9d 29			    add hl,hl 
0d9e 87			    add a,a 
0d9f 30 01		    jr nc,Mult12U_NoAdd4 
0da1 19			    add hl,de 
0da2			Mult12U_NoAdd4: 
0da2 29			    add hl,hl 
0da3 87			    add a,a 
0da4 30 01		    jr nc,Mult12U_NoAdd5 
0da6 19			    add hl,de 
0da7			Mult12U_NoAdd5: 
0da7 29			    add hl,hl 
0da8 87			    add a,a 
0da9 30 01		    jr nc,Mult12U_NoAdd6 
0dab 19			    add hl,de 
0dac			Mult12U_NoAdd6: 
0dac 29			    add hl,hl 
0dad 87			    add a,a 
0dae d0			    ret nc 
0daf 19			    add hl,de 
0db0 c9			    ret 
0db1			 
0db1			; 
0db1			; Multiply 8-bit value with a 16-bit value (right rotating) 
0db1			; In: Multiply A with DE 
0db1			;      Put lowest value in A for most efficient calculation 
0db1			; Out: HL = result 
0db1			; 
0db1			Mult12R: 
0db1 21 00 00		    ld hl,0 
0db4			Mult12R_Loop: 
0db4 cb 3f		    srl a 
0db6 30 01		    jr nc,Mult12R_NoAdd 
0db8 19			    add hl,de 
0db9			Mult12R_NoAdd: 
0db9 cb 23		    sla e 
0dbb cb 12		    rl d 
0dbd b7			    or a 
0dbe c2 b4 0d		    jp nz,Mult12R_Loop 
0dc1 c9			    ret 
0dc2			 
0dc2			; 
0dc2			; Multiply 16-bit values (with 32-bit result) 
0dc2			; In: Multiply BC with DE 
0dc2			; Out: BCHL = result 
0dc2			; 
0dc2			Mult32: 
0dc2 79			    ld a,c 
0dc3 48			    ld c,b 
0dc4 21 00 00		    ld hl,0 
0dc7 06 10		    ld b,16 
0dc9			Mult32_Loop: 
0dc9 29			    add hl,hl 
0dca 17			    rla 
0dcb cb 11		    rl c 
0dcd 30 07		    jr nc,Mult32_NoAdd 
0dcf 19			    add hl,de 
0dd0 ce 00		    adc a,0 
0dd2 d2 d6 0d		    jp nc,Mult32_NoAdd 
0dd5 0c			    inc c 
0dd6			Mult32_NoAdd: 
0dd6 10 f1		    djnz Mult32_Loop 
0dd8 41			    ld b,c 
0dd9 4f			    ld c,a 
0dda c9			    ret 
0ddb			 
0ddb			 
0ddb			 
0ddb			; 
0ddb			; Multiply 8-bit values 
0ddb			; In:  Multiply H with E 
0ddb			; Out: HL = result 
0ddb			; 
0ddb			Mult8: 
0ddb 16 00		    ld d,0 
0ddd 6a			    ld l,d 
0dde 06 08		    ld b,8 
0de0			Mult8_Loop: 
0de0 29			    add hl,hl 
0de1 30 01		    jr nc,Mult8_NoAdd 
0de3 19			    add hl,de 
0de4			Mult8_NoAdd: 
0de4 10 fa		    djnz Mult8_Loop 
0de6 c9			    ret 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			 
0de7			;;http://z80-heaven.wikidot.com/math 
0de7			;;This divides DE by BC, storing the result in DE, remainder in HL 
0de7			; 
0de7			;DE_Div_BC:          ;1281-2x, x is at most 16 
0de7			;     ld a,16        ;7 
0de7			;     ld hl,0        ;10 
0de7			;     jp $+5         ;10 
0de7			;.DivLoop: 
0de7			;       add hl,bc    ;-- 
0de7			;       dec a        ;64 
0de7			;       jr z,.DivLoopEnd        ;86 
0de7			; 
0de7			;       sla e        ;128 
0de7			;       rl d         ;128 
0de7			;       adc hl,hl    ;240 
0de7			;       sbc hl,bc    ;240 
0de7			;       jr nc,.DivLoop ;23|21 
0de7			;       inc e        ;-- 
0de7			;       jp .DivLoop+1 
0de7			; 
0de7			;.DivLoopEnd: 
0de7			 
0de7			;HL_Div_C: 
0de7			;Inputs: 
0de7			;     HL is the numerator 
0de7			;     C is the denominator 
0de7			;Outputs: 
0de7			;     A is the remainder 
0de7			;     B is 0 
0de7			;     C is not changed 
0de7			;     DE is not changed 
0de7			;     HL is the quotient 
0de7			; 
0de7			;       ld b,16 
0de7			;       xor a 
0de7			;         add hl,hl 
0de7			;         rla 
0de7			;         cp c 
0de7			;         jr c,$+4 
0de7			;           inc l 
0de7			;           sub c 
0de7			;         djnz $-7 
0de7			 
0de7			; https://plutiedev.com/z80-add-8bit-to-16bit 
0de7			 
0de7			addatohl: 
0de7 85			    add   a, l    ; A = A+L 
0de8 6f			    ld    l, a    ; L = A+L 
0de9 8c			    adc   a, h    ; A = A+L+H+carry 
0dea 95			    sub   l       ; A = H+carry 
0deb 67			    ld    h, a    ; H = H+carry 
0dec c9			ret 
0ded			 
0ded			addatode: 
0ded 83			    add   a, e    ; A = A+L 
0dee 5f			    ld    e, a    ; L = A+L 
0def 8a			    adc   a, d    ; A = A+L+H+carry 
0df0 93			    sub   e       ; A = H+carry 
0df1 57			    ld    d, a    ; H = H+carry 
0df2 c9			ret 
0df3			 
0df3			 
0df3			addatobc: 
0df3 81			    add   a, c    ; A = A+L 
0df4 4f			    ld    c, a    ; L = A+L 
0df5 88			    adc   a, b    ; A = A+L+H+carry 
0df6 91			    sub   c       ; A = H+carry 
0df7 47			    ld    b, a    ; H = H+carry 
0df8 c9			ret 
0df9			 
0df9			subafromhl: 
0df9			   ; If A=0 do nothing 
0df9			    ; Otherwise flip A's sign. Since 
0df9			    ; the upper byte becomes -1, also 
0df9			    ; substract 1 from H. 
0df9 ed 44		    neg 
0dfb ca 04 0e		    jp    z, Skip 
0dfe 25			    dec   h 
0dff			     
0dff			    ; Now add the low byte as usual 
0dff			    ; Two's complement takes care of 
0dff			    ; ensuring the result is correct 
0dff 85			    add   a, l 
0e00 6f			    ld    l, a 
0e01 8c			    adc   a, h 
0e02 95			    sub   l 
0e03 67			    ld    h, a 
0e04			Skip: 
0e04 c9				ret 
0e05			 
0e05			 
0e05			; compare hl and de 
0e05			; returns:  
0e05			; if hl = de, z=1, s=0, c0=0 
0e05			; if hl > de, z=0, s=0, c=0 
0e05			; if hl < de, z=0, s=1, c=1 
0e05			cmp16:	 
0e05 b7				or a 
0e06 ed 52			sbc hl,de 
0e08 e0				ret po 
0e09 7c				ld a,h 
0e0a 1f				rra 
0e0b ee 40			xor 01000000B 
0e0d 37				scf 
0e0e 8f				adc a,a 
0e0f c9				ret 
0e10			 
0e10			 
0e10			; test if hl contains zero   - A is destroyed 
0e10			 
0e10			ishlzero:    
0e10 b7				or a     ; reset flags 
0e11 7c				ld a, h 
0e12 b5				or l        	 
0e13			 
0e13 c9				ret 
0e14			 
0e14			 
0e14			 
0e14			 
0e14			if FORTH_ENABLE_FLOATMATH 
0e14			;include "float/bbcmath.z80" 
0e14			include "float/lpfpcalc.asm" 
0e14			endif 
0e14			 
0e14			 
0e14			; eof 
0e14			 
# End of file firmware_maths.asm
0e14			include "firmware_strings.asm"   ; string handling  
0e14			 
0e14			 
0e14			; TODO string len 
0e14			; input text string, end on cr with zero term 
0e14			; a offset into frame buffer to start prompt 
0e14			; d is max length 
0e14			; e is display size TODO 
0e14			; c is current cursor position 
0e14			; hl is ptr to where string will be stored 
0e14			 
0e14			 
0e14			; TODO check limit of buffer for new inserts 
0e14			; TODO check insert does not push beyond buffer 
0e14			; TODO scroll in a limited display area 
0e14			; TODO scroll whole screen on page wrap 
0e14			 
0e14			 
0e14			; TODO handle KEY_PREVWORD 
0e14			; TODO handle KEY_NEXTWORD 
0e14			; TODO handle KEY_HOME 
0e14			; TODO handle KEY_END 
0e14			; TODO use LCD cursor? 
0e14			 
0e14 32 64 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0e17 81					add c 
0e18 32 62 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0e1b 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
0e1e 79					ld a, c 
0e1f cd e7 0d				call addatohl 
0e22 22 69 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0e25 7a					ld a,d 
0e26 32 66 ee			        ld (input_size), a       ; save length of input area 
0e29 79					ld a, c 
0e2a 32 55 ee				ld (input_cursor),a      ; init cursor start position  
0e2d 7b					ld a,e 
0e2e 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e31					 
0e31					 
0e31			 
0e31			;		ld a,(input_ptr) 
0e31			;		ld (input_under_cursor),a 	; save what is under the cursor 
0e31			 
0e31			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e31					; init cursor shape if not set by the cin routines 
0e31 21 c1 eb				ld hl, cursor_shape 
0e34 3e ff				ld a, 255 
0e36 77					ld (hl), a 
0e37 23					inc hl 
0e38 3e 00				ld a, 0 
0e3a 77					ld (hl), a 
0e3b			 
0e3b 3e 0f				ld a, CUR_BLINK_RATE 
0e3d 32 60 ee				ld (input_cur_flash), a 
0e40 3e 01				ld a, 1 
0e42 32 5f ee				ld (input_cur_onoff),a 
0e45			 
0e45			;	if DEBUG_INPUT 
0e45			;		push af 
0e45			;		ld a, 'I' 
0e45			;		ld (debug_mark),a 
0e45			;		pop af 
0e45			;		CALLMONITOR 
0e45			;	endif 
0e45			.is1:		; main entry loop 
0e45			 
0e45			 
0e45			 
0e45					; pause 1ms 
0e45			 
0e45 3e 01				ld a, 1 
0e47 cd d7 0a				call aDelayInMS 
0e4a			 
0e4a					; dec flash counter 
0e4a 3a 60 ee				ld a, (input_cur_flash) 
0e4d 3d					dec a 
0e4e 32 60 ee				ld (input_cur_flash), a 
0e51 fe 00				cp 0 
0e53 20 0d				jr nz, .nochgstate 
0e55			 
0e55			 
0e55					; change state 
0e55 3a 5f ee				ld a,(input_cur_onoff) 
0e58 ed 44				neg 
0e5a 32 5f ee				ld (input_cur_onoff),a 
0e5d			 
0e5d			 
0e5d					; reset on change of state 
0e5d 3e 0f				ld a, CUR_BLINK_RATE 
0e5f 32 60 ee				ld (input_cur_flash), a 
0e62			 
0e62			.nochgstate: 
0e62					 
0e62					 
0e62			 
0e62					; display cursor  
0e62			 
0e62			;		ld hl, (input_start) 
0e62			;		ld a, (input_cursor) 
0e62			;		call addatohl 
0e62			 
0e62					; get char under cursor and replace with cursor 
0e62 2a 69 ee		ld hl, (input_ptr) 
0e65			;		ld a, (hl) 
0e65			;		ld (input_under_cursor),a 
0e65			;		ld a, '_' 
0e65			;		ld (hl), a 
0e65			 
0e65					; display string 
0e65			 
0e65 ed 5b 67 ee			ld de, (input_start) 
0e69 3a 64 ee				ld a, (input_at_pos) 
0e6c cd cd 0b				call str_at_display 
0e6f			;	        call update_display 
0e6f			 
0e6f					; find place to put the cursor 
0e6f			;		add h 
0e6f			;		ld l, display_row_1 
0e6f			;		sub l 
0e6f			; (input_at_pos) 
0e6f					;ld c, a 
0e6f			;		ld a, (input_cursor) 
0e6f			;		ld l, (input_at_pos) 
0e6f			;		;ld b, h 
0e6f			;		add l 
0e6f			;		ld (input_at_cursor),a 
0e6f					;ld l,h 
0e6f			 
0e6f			;		ld h, 0 
0e6f			;		ld l,(input_at_pos) 
0e6f			;		ld a, (input_cursor) 
0e6f			;		call addatohl 
0e6f			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0e6f			;		call subafromhl 
0e6f			;		ld a,l 
0e6f			;		ld (input_at_cursor), a 
0e6f			 
0e6f				if DEBUG_INPUT 
0e6f					ld a, (hardware_diag) 
0e6f					cp 0 
0e6f					jr z, .skip_input_diag 
0e6f			 
0e6f					ld a,(input_at_pos) 
0e6f					ld hl, LFSRSeed 
0e6f					call hexout 
0e6f					ld a, (input_cursor) 
0e6f					ld hl, LFSRSeed+2 
0e6f					call hexout 
0e6f					ld a,(input_at_cursor) 
0e6f					ld hl, LFSRSeed+4 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_cur_onoff) 
0e6f					ld hl, LFSRSeed+6 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_cur_flash) 
0e6f					ld hl, LFSRSeed+8 
0e6f					call hexout 
0e6f			 
0e6f					ld a,(input_len) 
0e6f					ld hl, LFSRSeed+10 
0e6f					call hexout 
0e6f					ld hl, LFSRSeed+12 
0e6f					ld a, 0 
0e6f					ld (hl),a 
0e6f					ld a, display_row_4 
0e6f					ld de, LFSRSeed 
0e6f					call str_at_display 
0e6f					.skip_input_diag: 
0e6f				endif 
0e6f			 
0e6f					; decide on if we are showing the cursor this time round 
0e6f			 
0e6f 3a 5f ee				ld a, (input_cur_onoff) 
0e72 fe ff				cp 255 
0e74 28 13				jr z, .skipcur 
0e76			 
0e76			 
0e76 3a 62 ee				ld a,(input_at_cursor) 
0e79 11 c1 eb				ld de, cursor_shape 
0e7c cd cd 0b				call str_at_display 
0e7f			 
0e7f					; save length of current input string 
0e7f 2a 67 ee				ld hl, (input_start) 
0e82 cd 45 12				call strlenz 
0e85 7d					ld a,l 
0e86 32 5a ee				ld (input_len),a 
0e89			 
0e89			.skipcur: 
0e89			 
0e89 cd dd 0b			        call update_display 
0e8c					 
0e8c			 
0e8c			 
0e8c					; wait 
0e8c				 
0e8c					; TODO loop without wait to flash the cursor and char under cursor	 
0e8c cd 87 65				call cin    ; _wait 
0e8f			 
0e8f fe 00				cp 0 
0e91 ca 45 0e				jp z, .is1 
0e94			 
0e94					; get ptr to char to input into 
0e94			 
0e94 4f					ld c,a 
0e95 2a 67 ee				ld hl, (input_start) 
0e98 3a 55 ee				ld a, (input_cursor) 
0e9b cd e7 0d				call addatohl 
0e9e 22 69 ee				ld (input_ptr), hl 
0ea1 79					ld a,c 
0ea2			 
0ea2					; replace char under cursor 
0ea2			 
0ea2			;		ld hl, (input_ptr) 
0ea2			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ea2			;		ld (hl), a 
0ea2			 
0ea2			;	if DEBUG_INPUT 
0ea2			;		push af 
0ea2			;		ld a, 'i' 
0ea2			;		ld (debug_mark),a 
0ea2			;		pop af 
0ea2			;		CALLMONITOR 
0ea2			;	endif 
0ea2 fe 0e				cp KEY_HOME 
0ea4 20 0e				jr nz, .iske 
0ea6			 
0ea6 3a 64 ee				ld a, (input_at_pos) 
0ea9 32 62 ee				ld (input_at_cursor),a 
0eac 3e 00				ld a, 0 
0eae 32 55 ee				ld (input_cursor), a 
0eb1 c3 45 0e				jp .is1 
0eb4					 
0eb4 fe 0f		.iske:		cp KEY_END 
0eb6 20 03				jr nz, .isknw 
0eb8 c3 45 0e				jp .is1 
0ebb			 
0ebb fe 06		.isknw:		cp KEY_NEXTWORD 
0ebd 20 1b				jr nz, .iskpw 
0ebf			 
0ebf 2a 69 ee		.isknwm:	ld hl, (input_ptr) 
0ec2 7e					ld a,(hl)	 
0ec3 fe 00				cp 0 
0ec5 ca 45 0e				jp z, .is1    ; end of string 
0ec8 fe 20				cp ' ' 
0eca ca 45 0e				jp z, .is1    ; end of word 
0ecd 23					inc hl 
0ece 22 69 ee				ld (input_ptr), hl 
0ed1 3a 62 ee				ld a, (input_at_cursor) 
0ed4 3c					inc a 
0ed5 32 62 ee				ld (input_at_cursor), a 
0ed8 18 e5				jr .isknwm 
0eda			 
0eda fe 07		.iskpw:		cp KEY_PREVWORD 
0edc 20 1b				jr nz, .iskl 
0ede			.iskpwm:	 
0ede 2a 69 ee				ld hl, (input_ptr) 
0ee1 7e					ld a,(hl)	 
0ee2 fe 00				cp 0  
0ee4 ca 45 0e				jp z, .is1    ; end of string 
0ee7 fe 20				cp ' ' 
0ee9 ca 45 0e				jp z, .is1    ; end of word 
0eec 2b					dec hl 
0eed 22 69 ee				ld (input_ptr), hl 
0ef0 3a 62 ee				ld a, (input_at_cursor) 
0ef3 3d					dec a 
0ef4 32 62 ee				ld (input_at_cursor), a 
0ef7 18 e5				jr .iskpwm 
0ef9			 
0ef9			 
0ef9 fe 0b		.iskl:		cp KEY_LEFT 
0efb 20 27				jr nz, .isk1 
0efd			 
0efd 3a 55 ee				ld a, (input_cursor) 
0f00			 
0f00 fe 00				cp 0 
0f02 ca 45 0e				jp z, .is1 		; at start of line to ignore  
0f05			 
0f05 3d					dec  a 		; TODO check underflow 
0f06 32 55 ee				ld (input_cursor), a 
0f09			 
0f09 2a 69 ee				ld hl, (input_ptr) 
0f0c 2b					dec hl 
0f0d 22 69 ee				ld (input_ptr), hl 
0f10					 
0f10 3a 62 ee				ld a, (input_at_cursor) 
0f13 3d					dec a 
0f14 32 62 ee				ld (input_at_cursor), a 
0f17			 
0f17 3e 01				ld a, 1		; show cursor moving 
0f19 32 5f ee				ld (input_cur_onoff),a 
0f1c 3e 0f				ld a, CUR_BLINK_RATE 
0f1e 32 60 ee				ld (input_cur_flash), a 
0f21			 
0f21 c3 45 0e				jp .is1 
0f24			 
0f24 fe 0c		.isk1:		cp KEY_RIGHT 
0f26 20 2a				jr nz, .isk2 
0f28			 
0f28 3a 5a ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0f2b 5f					ld e,a 
0f2c 3a 55 ee				ld a, (input_cursor) 
0f2f bb					cp e 
0f30 ca 45 0e				jp z, .is1		; at the end of string so dont go right 
0f33			 
0f33 3c					inc  a 		; TODO check overflow 
0f34 32 55 ee				ld (input_cursor), a 
0f37			 
0f37 3a 62 ee				ld a, (input_at_cursor) 
0f3a 3c					inc a 
0f3b 32 62 ee				ld (input_at_cursor), a 
0f3e			 
0f3e 2a 69 ee				ld hl, (input_ptr) 
0f41 23					inc hl 
0f42 22 69 ee				ld (input_ptr), hl 
0f45			 
0f45 3e 01				ld a, 1		; show cursor moving 
0f47 32 5f ee				ld (input_cur_onoff),a 
0f4a 3e 0f				ld a, CUR_BLINK_RATE 
0f4c 32 60 ee				ld (input_cur_flash), a 
0f4f			 
0f4f c3 45 0e				jp .is1 
0f52			 
0f52 fe 05		.isk2:		cp KEY_UP 
0f54			 
0f54 20 26				jr nz, .isk3 
0f56			 
0f56					; swap last command with the current on 
0f56			 
0f56					; move cursor to start of string 
0f56 2a 67 ee				ld hl, (input_start) 
0f59 22 69 ee				ld (input_ptr), hl 
0f5c			 
0f5c 3a 64 ee				ld a, (input_at_pos) 
0f5f 32 62 ee				ld (input_at_cursor), a 
0f62			 
0f62 3e 00				ld a, 0 
0f64 32 55 ee				ld (input_cursor), a 
0f67					 
0f67					; swap input and last command buffers 
0f67			 
0f67 21 e8 e5				ld hl, os_cli_cmd 
0f6a 11 e7 e6				ld de, os_last_cmd 
0f6d 06 ff				ld b, 255 
0f6f 7e			.swap1:		ld a, (hl) 
0f70 4f					ld c,a 
0f71 1a					ld a, (de) 
0f72 77					ld (hl), a 
0f73 79					ld a,c 
0f74 12					ld (de),a 
0f75 23					inc hl 
0f76 13					inc de 
0f77 10 f6				djnz .swap1 
0f79			 
0f79			 
0f79			 
0f79			 
0f79			 
0f79 c3 45 0e				jp .is1 
0f7c			 
0f7c fe 08		.isk3:		cp KEY_BS 
0f7e 20 3c				jr nz, .isk4 
0f80			 
0f80 3a 55 ee				ld a, (input_cursor) 
0f83			 
0f83 fe 00				cp 0 
0f85 ca 45 0e				jp z, .is1 		; at start of line to ignore  
0f88			 
0f88 3d					dec  a 		; TODO check underflow 
0f89 32 55 ee				ld (input_cursor), a 
0f8c			 
0f8c					; hl is source 
0f8c					; de needs to be source - 1 
0f8c			 
0f8c			;		ld a, 0 
0f8c			;		dec hl 
0f8c			;		ld (hl), a 
0f8c			 
0f8c 2a 69 ee				ld hl, (input_ptr) 
0f8f 2b					dec hl 
0f90 22 69 ee				ld (input_ptr), hl 
0f93			 
0f93					; shift all data 
0f93			 
0f93 e5					push hl 
0f94 23					inc hl 
0f95 d1					pop de 
0f96 3a 5a ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0f99 4f					ld c,a 
0f9a 06 00				ld b,0 
0f9c ed b0				ldir  
0f9e			 
0f9e			 
0f9e			 
0f9e			 
0f9e 3a 62 ee				ld a, (input_at_cursor) 
0fa1 3d					dec a 
0fa2 32 62 ee				ld (input_at_cursor), a 
0fa5			 
0fa5			 
0fa5 3e 01				ld a, 1		; show cursor moving 
0fa7 32 5f ee				ld (input_cur_onoff),a 
0faa 3e 0f				ld a, CUR_BLINK_RATE 
0fac 32 60 ee				ld (input_cur_flash), a 
0faf			 
0faf					; remove char 
0faf 3a 62 ee				ld a, (input_at_cursor) 
0fb2 3c					inc a 
0fb3 11 3d 10				ld de,.iblank 
0fb6 cd cd 0b				call str_at_display 
0fb9			 
0fb9 c3 45 0e				jp .is1 
0fbc			 
0fbc fe 0d		.isk4:		cp KEY_CR 
0fbe 28 6c				jr z, .endinput 
0fc0			 
0fc0					; else add the key press to the end 
0fc0			 
0fc0 4f					ld c, a			; save key pressed 
0fc1			 
0fc1 7e					ld a,(hl)		; get what is currently under char 
0fc2			 
0fc2 fe 00				cp 0			; we are at the end of the string 
0fc4 20 2f				jr nz, .onchar 
0fc6					 
0fc6					; add a char to the end of the string 
0fc6				 
0fc6 71					ld (hl),c 
0fc7 23					inc hl 
0fc8			;		ld a,' ' 
0fc8			;		ld (hl),a 
0fc8			;		inc hl 
0fc8 3e 00				ld a,0 
0fca 77					ld (hl),a 
0fcb 2b					dec hl 
0fcc			 
0fcc 3a 55 ee				ld a, (input_cursor) 
0fcf 3c					inc a				; TODO check max string length and scroll  
0fd0 32 55 ee				ld (input_cursor), a		; inc cursor pos 
0fd3							 
0fd3 3a 62 ee				ld a, (input_at_cursor) 
0fd6 3c					inc a 
0fd7 32 62 ee				ld (input_at_cursor), a 
0fda			 
0fda 2a 69 ee				ld hl, (input_ptr) 
0fdd 23					inc hl 
0fde 22 69 ee				ld (input_ptr), hl 
0fe1			 
0fe1 2a 69 ee				ld hl, (input_ptr) 
0fe4 23					inc hl 
0fe5 22 69 ee				ld (input_ptr), hl 
0fe8			;	if DEBUG_INPUT 
0fe8			;		push af 
0fe8			;		ld a, '+' 
0fe8			;		ld (debug_mark),a 
0fe8			;		pop af 
0fe8			;		CALLMONITOR 
0fe8			;	endif 
0fe8 3e 01				ld a, 1		; show cursor moving 
0fea 32 5f ee				ld (input_cur_onoff),a 
0fed 3e 0f				ld a, CUR_BLINK_RATE 
0fef 32 60 ee				ld (input_cur_flash), a 
0ff2 c3 45 0e				jp .is1 
0ff5					 
0ff5			 
0ff5			 
0ff5					; if on a char then insert 
0ff5			.onchar: 
0ff5			 
0ff5					; TODO over flow check: make sure insert does not blow out buffer 
0ff5			 
0ff5					; need to do some maths to use lddr 
0ff5			 
0ff5 e5					push hl   ; save char pos 
0ff6 c5					push bc 
0ff7			 
0ff7 2a 67 ee				ld hl, (input_start) 
0ffa 3a 5a ee				ld a, (input_len) 
0ffd cd e7 0d				call addatohl  		; end of string 
1000 23					inc hl 
1001 23					inc hl		; past zero term 
1002 e5					push hl 
1003 23					inc hl 
1004 e5					push hl  
1005			 
1005								; start and end of lddr set, now how much to move? 
1005			 
1005							 
1005 3a 55 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
1008 47					ld b,a 
1009 3a 5a ee				ld a,(input_len) 
100c 5f					ld e,a 
100d 90					sub b 
100e 3c					inc a		;?? 
100f 3c					inc a		;?? 
1010 3c					inc a		;?? 
1011			 
1011 06 00				ld b,0 
1013 4f					ld c,a 
1014			 
1014				if DEBUG_INPUT 
1014					push af 
1014					ld a, 'i' 
1014					ld (debug_mark),a 
1014					pop af 
1014			;		CALLMONITOR 
1014				endif 
1014 d1					pop de 
1015 e1					pop hl 
1016				if DEBUG_INPUT 
1016					push af 
1016					ld a, 'I' 
1016					ld (debug_mark),a 
1016					pop af 
1016			;		CALLMONITOR 
1016				endif 
1016 ed b8				lddr 
1018				 
1018			 
1018			 
1018					; TODO have a key for insert/overwrite mode???? 
1018 c1					pop bc 
1019 e1					pop hl 
101a 71					ld (hl), c		; otherwise overwrite current char 
101b					 
101b			 
101b			 
101b			 
101b 3a 55 ee				ld a, (input_cursor) 
101e 3c					inc  a 		; TODO check overflow 
101f 32 55 ee				ld (input_cursor), a 
1022			 
1022 3a 62 ee				ld a, (input_at_cursor) 
1025 3c					inc a 
1026 32 62 ee				ld (input_at_cursor), a 
1029			 
1029 c3 45 0e				jp .is1 
102c			 
102c			.endinput:	; TODO look for end of string 
102c			 
102c					; add trailing space for end of token 
102c			 
102c 2a 67 ee				ld hl, (input_start) 
102f 3a 5a ee				ld a,(input_len) 
1032 cd e7 0d				call addatohl 
1035 3e 20				ld a, ' ' 
1037 77					ld (hl),a 
1038					; TODO eof of parse marker 
1038			 
1038 23					inc hl 
1039 3e 00				ld a, 0 
103b 77					ld (hl),a 
103c			 
103c			 
103c c9					ret 
103d			 
103d .. 00		.iblank: db " ",0 
103f			 
103f			 
103f 32 64 ee		input_str_prev:	ld (input_at_pos), a 
1042 22 67 ee				ld (input_start), hl 
1045 3e 01				ld a,1			; add cursor 
1047 77					ld (hl),a 
1048 23					inc hl 
1049 3e 00				ld a,0 
104b 77					ld (hl),a 
104c 22 69 ee				ld (input_ptr), hl 
104f 7a					ld a,d 
1050 32 66 ee				ld (input_size), a 
1053 3e 00				ld a,0 
1055 32 55 ee				ld (input_cursor),a 
1058			.instr1:	 
1058			 
1058					; TODO do block cursor 
1058					; TODO switch cursor depending on the modifer key 
1058			 
1058					; update cursor shape change on key hold 
1058			 
1058 2a 69 ee				ld hl, (input_ptr) 
105b 2b					dec hl 
105c 3a c1 eb				ld a,(cursor_shape) 
105f 77					ld (hl), a 
1060			 
1060					; display entered text 
1060 3a 64 ee				ld a,(input_at_pos) 
1063 cd 9c 64		            	CALL fLCD_Pos       ;Position cursor to location in A 
1066 ed 5b 67 ee	            	LD   de, (input_start) 
106a cd 91 64		            	CALL fLCD_Str       ;Display string pointed to by DE 
106d			 
106d cd 87 65				call cin 
1070 fe 00				cp 0 
1072 28 e4				jr z, .instr1 
1074			 
1074					; proecess keyboard controls first 
1074			 
1074 2a 69 ee				ld hl,(input_ptr) 
1077			 
1077 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1079 28 5a				jr z, .instrcr 
107b			 
107b fe 08				cp KEY_BS 	; back space 
107d 20 0f				jr nz, .instr2 
107f					; process back space 
107f			 
107f					; TODO stop back space if at start of string 
107f 2b					dec hl 
1080 2b					dec hl ; to over write cursor 
1081 3a c1 eb				ld a,(cursor_shape) 
1084					;ld a,0 
1084 77					ld (hl),a 
1085 23					inc hl 
1086 3e 20				ld a," " 
1088 77					ld (hl),a 
1089 22 69 ee				ld (input_ptr),hl 
108c					 
108c			 
108c 18 ca				jr .instr1 
108e			 
108e fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1090 20 06				jr nz, .instr3 
1092 2b					dec hl 
1093 22 69 ee				ld (input_ptr),hl 
1096 18 c0				jr .instr1 
1098				 
1098 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
109a 20 06				jr nz, .instr4 
109c 23					inc hl 
109d 22 69 ee				ld (input_ptr),hl 
10a0 18 b6				jr .instr1 
10a2			 
10a2 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
10a4 20 06				jr nz, .instr5 
10a6 2b					dec hl 
10a7 22 69 ee				ld (input_ptr),hl 
10aa 18 ac				jr .instr1 
10ac			 
10ac fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
10ae 20 06				jr nz, .instr6 
10b0 2b					dec hl 
10b1 22 69 ee				ld (input_ptr),hl 
10b4 18 a2				jr .instr1 
10b6 fe 05		.instr6:        cp KEY_UP      ; recall last command 
10b8 20 0b				jr nz, .instrnew 
10ba			 
10ba 21 c1 e2			ld hl, scratch 
10bd 11 e7 e6			ld de, os_last_cmd 
10c0 cd de 10			call strcpy 
10c3 18 93				jr .instr1 
10c5			 
10c5			 
10c5			.instrnew:	; no special key pressed to see if we have room to store it 
10c5			 
10c5					; TODO do string size test 
10c5			 
10c5 2b					dec hl ; to over write cursor 
10c6 77					ld (hl),a 
10c7 23					inc hl 
10c8 3a c1 eb				ld a,(cursor_shape) 
10cb 77					ld (hl),a 
10cc 23					inc hl 
10cd 3e 00				ld a,0 
10cf 77					ld (hl),a 
10d0			 
10d0 22 69 ee				ld (input_ptr),hl 
10d3					 
10d3 18 83				jr .instr1 
10d5 2b			.instrcr:	dec hl		; remove cursor 
10d6 3e 20				ld a,' '	; TODO add a trailing space for safety 
10d8 77					ld (hl),a 
10d9 23					inc hl 
10da 3e 00				ld a,0 
10dc 77					ld (hl),a 
10dd			 
10dd			 
10dd					; if at end of line scroll up    
10dd					; TODO detecting only end of line 4 for scroll up  
10dd			 
10dd					;ld   
10dd			 
10dd c9					ret 
10de			 
10de			 
10de			; strcpy hl = dest, de source 
10de			 
10de 1a			strcpy:   LD   A, (DE)        ;Get character from string 
10df b7			            OR   A              ;Null terminator? 
10e0 c8			            RET  Z              ;Yes, so finished 
10e1 1a					ld a,(de) 
10e2 77					ld (hl),a 
10e3 13			            INC  DE             ;Point to next character 
10e4 23					inc hl 
10e5 18 f7		            JR   strcpy       ;Repeat 
10e7 c9					ret 
10e8			 
10e8			 
10e8			; TODO string_at  
10e8			; pass string which starts with lcd offset address and then null term string 
10e8			 
10e8			; TODO string to dec 
10e8			; TODO string to hex 
10e8			; TODO byte to string hex 
10e8			; TODO byte to string dec 
10e8			 
10e8			 
10e8			 
10e8			; from z80uartmonitor 
10e8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10e8			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
10e8			; pass hl for where to put the text 
10e8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10e8 c5			hexout:	PUSH BC 
10e9 f5					PUSH AF 
10ea 47					LD B, A 
10eb					; Upper nybble 
10eb cb 3f				SRL A 
10ed cb 3f				SRL A 
10ef cb 3f				SRL A 
10f1 cb 3f				SRL A 
10f3 cd 03 11				CALL tohex 
10f6 77					ld (hl),a 
10f7 23					inc hl	 
10f8					 
10f8					; Lower nybble 
10f8 78					LD A, B 
10f9 e6 0f				AND 0FH 
10fb cd 03 11				CALL tohex 
10fe 77					ld (hl),a 
10ff 23					inc hl	 
1100					 
1100 f1					POP AF 
1101 c1					POP BC 
1102 c9					RET 
1103					 
1103			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1103			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1103			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1103			tohex: 
1103 e5					PUSH HL 
1104 d5					PUSH DE 
1105 16 00				LD D, 0 
1107 5f					LD E, A 
1108 21 10 11				LD HL, .DATA 
110b 19					ADD HL, DE 
110c 7e					LD A, (HL) 
110d d1					POP DE 
110e e1					POP HL 
110f c9					RET 
1110			 
1110			.DATA: 
1110 30					DEFB	30h	; 0 
1111 31					DEFB	31h	; 1 
1112 32					DEFB	32h	; 2 
1113 33					DEFB	33h	; 3 
1114 34					DEFB	34h	; 4 
1115 35					DEFB	35h	; 5 
1116 36					DEFB	36h	; 6 
1117 37					DEFB	37h	; 7 
1118 38					DEFB	38h	; 8 
1119 39					DEFB	39h	; 9 
111a 41					DEFB	41h	; A 
111b 42					DEFB	42h	; B 
111c 43					DEFB	43h	; C 
111d 44					DEFB	44h	; D 
111e 45					DEFB	45h	; E 
111f 46					DEFB	46h	; F 
1120			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1120			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1120			;;    subtract $30, if result > 9 then subtract $7 more 
1120			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1120			atohex: 
1120 d6 30				SUB $30 
1122 fe 0a				CP 10 
1124 f8					RET M		; If result negative it was 0-9 so we're done 
1125 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1127 c9					RET		 
1128			 
1128			 
1128			 
1128			 
1128			; Get 2 ASCII characters as hex byte from pointer in hl 
1128			 
1128			BYTERD: 
1128 16 00			LD	D,00h		;Set up 
112a cd 32 11			CALL	HEXCON		;Get byte and convert to hex 
112d 87				ADD	A,A		;First nibble so 
112e 87				ADD	A,A		;multiply by 16 
112f 87				ADD	A,A		; 
1130 87				ADD	A,A		; 
1131 57				LD	D,A		;Save hi nibble in D 
1132			HEXCON: 
1132 7e				ld a, (hl)		;Get next chr 
1133 23				inc hl 
1134 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1136 fe 0a			CP	00Ah		;Is it 0-9 ? 
1138 38 02			JR	C,NALPHA	;If so miss next bit 
113a d6 07			SUB	007h		;Else convert alpha 
113c			NALPHA: 
113c b2				OR	D		;Add hi nibble back 
113d c9				RET			; 
113e			 
113e			 
113e			; 
113e			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
113e			; Since the routines get_byte and therefore get_nibble are called, only valid 
113e			; characters (0-9a-f) are accepted. 
113e			; 
113e			;get_word        push    af 
113e			;                call    get_byte        ; Get the upper byte 
113e			;                ld      h, a 
113e			;                call    get_byte        ; Get the lower byte 
113e			;                ld      l, a 
113e			;                pop     af 
113e			;                ret 
113e			; 
113e			; Get a byte in hexadecimal notation. The result is returned in A. Since 
113e			; the routine get_nibble is used only valid characters are accepted - the  
113e			; input routine only accepts characters 0-9a-f. 
113e			; 
113e c5			get_byte:        push    bc              ; Save contents of B (and C) 
113f 7e					ld a,(hl) 
1140 23					inc hl 
1141 cd 66 11		                call    nibble2val      ; Get upper nibble 
1144 cb 07		                rlc     a 
1146 cb 07		                rlc     a 
1148 cb 07		                rlc     a 
114a cb 07		                rlc     a 
114c 47			                ld      b, a            ; Save upper four bits 
114d 7e					ld a,(hl) 
114e cd 66 11		                call    nibble2val      ; Get lower nibble 
1151 b0			                or      b               ; Combine both nibbles 
1152 c1			                pop     bc              ; Restore B (and C) 
1153 c9			                ret 
1154			; 
1154			; Get a hexadecimal digit from the serial line. This routine blocks until 
1154			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1154			; to the serial line interface. The lower 4 bits of A contain the value of  
1154			; that particular digit. 
1154			; 
1154			;get_nibble      ld a,(hl)           ; Read a character 
1154			;                call    to_upper        ; Convert to upper case 
1154			;                call    is_hex          ; Was it a hex digit? 
1154			;                jr      nc, get_nibble  ; No, get another character 
1154			 ;               call    nibble2val      ; Convert nibble to value 
1154			 ;               call    print_nibble 
1154			 ;               ret 
1154			; 
1154			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1154			; A valid hexadecimal digit is denoted by a set C flag. 
1154			; 
1154			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1154			;                ret     nc              ; Yes 
1154			;                cp      '0'             ; Less than '0'? 
1154			;                jr      nc, is_hex_1    ; No, continue 
1154			;                ccf                     ; Complement carry (i.e. clear it) 
1154			;                ret 
1154			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1154			;                ret     c               ; Yes 
1154			;                cp      'A'             ; Less than 'A'? 
1154			;                jr      nc, is_hex_2    ; No, continue 
1154			;                ccf                     ; Yes - clear carry and return 
1154			;                ret 
1154			;is_hex_2        scf                     ; Set carry 
1154			;                ret 
1154			; 
1154			; Convert a single character contained in A to upper case: 
1154			; 
1154 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1156 d8			                ret     c 
1157 fe 7b		                cp      'z' + 1         ; > 'z'? 
1159 d0			                ret     nc              ; Nothing to do, either 
115a e6 5f		                and     $5f             ; Convert to upper case 
115c c9			                ret 
115d			 
115d			 
115d			to_lower: 
115d			 
115d			   ; if char is in [A-Z] make it lower case 
115d			 
115d			   ; enter : a = char 
115d			   ; exit  : a = lower case char 
115d			   ; uses  : af 
115d			 
115d fe 41		   cp 'A' 
115f d8			   ret c 
1160			    
1160 fe 5b		   cp 'Z'+1 
1162 d0			   ret nc 
1163			    
1163 f6 20		   or $20 
1165 c9			   ret 
1166			 
1166			; 
1166			; Expects a hexadecimal digit (upper case!) in A and returns the 
1166			; corresponding value in A. 
1166			; 
1166 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1168 38 02		                jr      c, nibble2val_1 ; Yes 
116a d6 07		                sub     7               ; Adjust for A-F 
116c d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
116e e6 0f		                and     $f              ; Only return lower 4 bits 
1170 c9			                ret 
1171			; 
1171			; Print_nibble prints a single hex nibble which is contained in the lower  
1171			; four bits of A: 
1171			; 
1171			;print_nibble    push    af              ; We won't destroy the contents of A 
1171			;                and     $f              ; Just in case... 
1171			;                add     a, '0'             ; If we have a digit we are done here. 
1171			;                cp      '9' + 1         ; Is the result > 9? 
1171			;                jr      c, print_nibble_1 
1171			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1171			;print_nibble_1  call    putc            ; Print the nibble and 
1171			;                pop     af              ; restore the original value of A 
1171			;                ret 
1171			;; 
1171			;; Send a CR/LF pair: 
1171			; 
1171			;crlf            push    af 
1171			;                ld      a, cr 
1171			;                call    putc 
1171			;                ld      a, lf 
1171			;                call    putc 
1171			;                pop     af 
1171			;                ret 
1171			; 
1171			; Print_word prints the four hex digits of a word to the serial line. The  
1171			; word is expected to be in HL. 
1171			; 
1171			;print_word      push    hl 
1171			;                push    af 
1171			;                ld      a, h 
1171			;                call    print_byte 
1171			;                ld      a, l 
1171			;                call    print_byte 
1171			;                pop     af 
1171			;                pop     hl 
1171			;                ret 
1171			; 
1171			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1171			; The byte to be printed is expected to be in A. 
1171			; 
1171			;print_byte      push    af              ; Save the contents of the registers 
1171			;                push    bc 
1171			;                ld      b, a 
1171			;                rrca 
1171			;                rrca 
1171			;                rrca 
1171			;                rrca 
1171			;                call    print_nibble    ; Print high nibble 
1171			;                ld      a, b 
1171			;                call    print_nibble    ; Print low nibble 
1171			;                pop     bc              ; Restore original register contents 
1171			;                pop     af 
1171			;                ret 
1171			 
1171			 
1171			 
1171			 
1171			 
1171			fourehexhl:  
1171 7e				ld a,(hl) 
1172 cd 20 11			call atohex 
1175 cb 3f				SRL A 
1177 cb 3f				SRL A 
1179 cb 3f				SRL A 
117b cb 3f				SRL A 
117d 47				ld b, a 
117e 23				inc hl 
117f 7e				ld a,(hl) 
1180 23				inc hl 
1181 cd 20 11			call atohex 
1184 80				add b 
1185 57				ld d,a 
1186 7e				ld a,(hl) 
1187 cd 20 11			call atohex 
118a cb 3f				SRL A 
118c cb 3f				SRL A 
118e cb 3f				SRL A 
1190 cb 3f				SRL A 
1192 47				ld b, a 
1193 23				inc hl 
1194 7e				ld a,(hl) 
1195 23				inc hl 
1196 cd 20 11			call atohex 
1199 80				add b 
119a 5f				ld e, a 
119b d5				push de 
119c e1				pop hl 
119d c9				ret 
119e			 
119e			; pass hl. returns z set if the byte at hl is a digit 
119e			;isdigithl:  
119e			;	push bc 
119e			;	ld a,(hl) 
119e			;	cp ':' 
119e			;	jr nc, .isdf 		; > 
119e			;	cp '0' 
119e			;	jr c, .isdf		; < 
119e			; 
119e			;	; TODO find a better way to set z 
119e			; 
119e			;	ld b,a 
119e			;	cp b 
119e			;	pop bc 
119e			;	ret 
119e			; 
119e			;.isdf:	; not digit so clear z 
119e			; 
119e			;	; TODO find a better way to unset z 
119e			; 
119e			;	ld b,a 
119e			;	inc b 
119e			;	cp b 
119e			; 
119e			;	pop bc 
119e			;	ret 
119e				 
119e				 
119e			 
119e			 
119e			; pass hl as the four byte address to load 
119e			 
119e			get_word_hl:  
119e e5				push hl 
119f cd 3e 11			call get_byte 
11a2				 
11a2 47				ld b, a 
11a3			 
11a3 e1				pop hl 
11a4 23				inc hl 
11a5 23				inc hl 
11a6			 
11a6			; TODO not able to handle a-f  
11a6 7e				ld a,(hl) 
11a7			;	;cp ':' 
11a7			;	cp 'g' 
11a7			;	jr nc, .single_byte_hl 		; > 
11a7			;	cp 'G' 
11a7			;	jr nc, .single_byte_hl 		; > 
11a7			;	cp '0' 
11a7			;	jr c, .single_byte_hl		; < 
11a7			 
11a7				;call isdigithl 
11a7 fe 00			cp 0 
11a9 28 06			jr z, .single_byte_hl 
11ab			 
11ab			.getwhln:   ; hex word so get next byte 
11ab			 
11ab cd 3e 11			call get_byte 
11ae 6f				ld l, a 
11af 60				ld h,b 
11b0 c9				ret 
11b1 68			.single_byte_hl:   ld l,b 
11b2 26 00				ld h,0 
11b4 c9					ret 
11b5			 
11b5			 
11b5			 
11b5			 
11b5 21 45 19			ld hl,asc+1 
11b8			;	ld a, (hl) 
11b8			;	call nibble2val 
11b8 cd 3e 11			call get_byte 
11bb			 
11bb			;	call fourehexhl 
11bb 32 f5 e2			ld (scratch+52),a 
11be				 
11be 21 f3 e2			ld hl,scratch+50 
11c1 22 e4 e5			ld (os_cur_ptr),hl 
11c4			 
11c4 c9				ret 
11c5			 
11c5			 
11c5			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
11c5			 
11c5			; Decimal Unsigned Version 
11c5			 
11c5			;Number in a to decimal ASCII 
11c5			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
11c5			;Example: display a=56 as "056" 
11c5			;input: a = number 
11c5			;Output: a=0,value of a in the screen 
11c5			;destroys af,bc (don't know about hl and de) 
11c5			DispAToASCII: 
11c5 0e 9c			ld	c,-100 
11c7 cd d1 11			call	.Na1 
11ca 0e f6			ld	c,-10 
11cc cd d1 11			call	.Na1 
11cf 0e ff			ld	c,-1 
11d1 06 2f		.Na1:	ld	b,'0'-1 
11d3 04			.Na2:	inc	b 
11d4 81				add	a,c 
11d5 38 fc			jr	c,.Na2 
11d7 91				sub	c		;works as add 100/10/1 
11d8 f5				push af		;safer than ld c,a 
11d9 78				ld	a,b		;char is in b 
11da			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
11da f1				pop af		;safer than ld a,c 
11db c9				ret 
11dc			 
11dc			; Decimal Signed Version 
11dc			 
11dc			; DispA 
11dc			; -------------------------------------------------------------- 
11dc			; Converts a signed integer value to a zero-terminated ASCII 
11dc			; string representative of that value (using radix 10). 
11dc			; -------------------------------------------------------------- 
11dc			; INPUTS: 
11dc			;     HL     Value to convert (two's complement integer). 
11dc			;     DE     Base address of string destination. (pointer). 
11dc			; -------------------------------------------------------------- 
11dc			; OUTPUTS: 
11dc			;     None 
11dc			; -------------------------------------------------------------- 
11dc			; REGISTERS/MEMORY DESTROYED 
11dc			; AF HL 
11dc			; -------------------------------------------------------------- 
11dc			 
11dc			;DispHLToASCII: 
11dc			;   push    de 
11dc			;   push    bc 
11dc			; 
11dc			;; Detect sign of HL. 
11dc			;    bit    7, h 
11dc			;    jr     z, ._DoConvert 
11dc			; 
11dc			;; HL is negative. Output '-' to string and negate HL. 
11dc			;    ld     a, '-' 
11dc			;    ld     (de), a 
11dc			;    inc    de 
11dc			; 
11dc			;; Negate HL (using two's complement) 
11dc			;    xor    a 
11dc			;    sub    l 
11dc			;    ld     l, a 
11dc			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
11dc			;    sbc    a, h 
11dc			;    ld     h, a 
11dc			; 
11dc			;; Convert HL to digit characters 
11dc			;._DoConvert: 
11dc			;    ld     b, 0     ; B will count character length of number 
11dc			;-   ld     a, 10 
11dc			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
11dc			;    push   af 
11dc			;    inc    b 
11dc			;    ld     a, h 
11dc			;    or     l 
11dc			;    jr     nz, - 
11dc			; 
11dc			;; Retrieve digits from stack 
11dc			;-   pop    af 
11dc			;    or     $30 
11dc			;    ld     (de), a 
11dc			;    inc    de 
11dc			;    djnz   - 
11dc			; 
11dc			;; Terminate string with NULL 
11dc			;    xor    a 
11dc			;    ld     (de), a 
11dc			; 
11dc			;    pop    bc 
11dc			;    pop    de 
11dc			;    ret 
11dc			 
11dc			;Comments 
11dc			; 
11dc			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
11dc			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
11dc			;    Note that the output string will not be fixed-width. 
11dc			; 
11dc			;Example Usage 
11dc			; 
11dc			;    ld    hl, -1004 
11dc			;    ld    de, OP1 
11dc			;    call  DispA 
11dc			;    ld    hl, OP1 
11dc			;    syscall  PutS 
11dc			 
11dc			 
11dc			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11dc			 
11dc			 
11dc			;Converts an ASCII string to an unsigned 16-bit integer 
11dc			;Quits when it reaches a non-decimal digit 
11dc			 
11dc			string_to_uint16: 
11dc			atoui_16: 
11dc			;Input: 
11dc			;     DE points to the string 
11dc			;Outputs: 
11dc			;     HL is the result 
11dc			;     A is the 8-bit value of the number 
11dc			;     DE points to the byte after the number 
11dc			;Destroys: 
11dc			;     BC 
11dc			;       if the string is non-empty, BC is HL/10 
11dc			;Size:  24 bytes 
11dc			;Speed: 42+d(104+{0,9}) 
11dc			;       d is the number of digits in the number 
11dc			;       max is 640 cycles for a 5 digit number 
11dc			;Assuming no leading zeros: 
11dc			;1 digit:  146cc 
11dc			;2 digit:  250cc 
11dc			;3 digit:  354cc or 363cc (avg: 354.126cc) 
11dc			;4 digit:  458cc or 467cc (avg: 458.27cc) 
11dc			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
11dc			;avg: 544.81158447265625cc (544+13297/16384) 
11dc			;=============================================================== 
11dc 21 00 00		  ld hl,0 
11df			.u16a: 
11df 1a			  ld a,(de) 
11e0 d6 30		  sub 30h 
11e2 fe 0a		  cp 10 
11e4 d0			  ret nc 
11e5 13			  inc de 
11e6 44			  ld b,h 
11e7 4d			  ld c,l 
11e8 29			  add hl,hl 
11e9 29			  add hl,hl 
11ea 09			  add hl,bc 
11eb 29			  add hl,hl 
11ec 85			  add a,l 
11ed 6f			  ld l,a 
11ee 30 ef		  jr nc,.u16a 
11f0 24			  inc h 
11f1 c3 df 11		  jp .u16a 
11f4			 
11f4			 
11f4			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11f4			 
11f4			;written by Zeda 
11f4			;Converts a 16-bit unsigned integer to an ASCII string. 
11f4			 
11f4			uitoa_16: 
11f4			;Input: 
11f4			;   DE is the number to convert 
11f4			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
11f4			;Output: 
11f4			;   HL points to the null-terminated ASCII string 
11f4			;      NOTE: This isn't necessarily the same as the input HL. 
11f4 d5			  push de 
11f5 c5			  push bc 
11f6 f5			  push af 
11f7 eb			  ex de,hl 
11f8			 
11f8 01 f0 d8		  ld bc,-10000 
11fb 3e 2f		  ld a,'0'-1 
11fd 3c			  inc a 
11fe 09			  add hl,bc  
11ff 38 fc		   jr c,$-2 
1201 12			  ld (de),a 
1202 13			  inc de 
1203			 
1203 01 e8 03		  ld bc,1000 
1206 3e 3a		  ld a,'9'+1 
1208 3d			  dec a  
1209 09			  add hl,bc  
120a 30 fc		   jr nc,$-2 
120c 12			  ld (de),a 
120d 13			  inc de 
120e			 
120e 01 9c ff		  ld bc,-100 
1211 3e 2f		  ld a,'0'-1 
1213 3c			  inc a  
1214 09			  add hl,bc  
1215 38 fc		   jr c,$-2 
1217 12			  ld (de),a 
1218 13			  inc de 
1219			 
1219 7d			  ld a,l 
121a 26 3a		  ld h,'9'+1 
121c 25			  dec h  
121d c6 0a		  add a,10  
121f 30 fb		   jr nc,$-3 
1221 c6 30		  add a,'0' 
1223 eb			  ex de,hl 
1224 72			  ld (hl),d 
1225 23			  inc hl 
1226 77			  ld (hl),a 
1227 23			  inc hl 
1228 36 00		  ld (hl),0 
122a			 
122a			;Now strip the leading zeros 
122a 0e fa		  ld c,-6 
122c 09			  add hl,bc 
122d 3e 30		  ld a,'0' 
122f 23			  inc hl  
1230 be			  cp (hl)  
1231 28 fc		  jr z,$-2 
1233			 
1233			;Make sure that the string is non-empty! 
1233 7e			  ld a,(hl) 
1234 b7			  or a 
1235 20 01		  jr nz,.atoub 
1237 2b			  dec hl 
1238			.atoub: 
1238			 
1238 f1			  pop af 
1239 c1			  pop bc 
123a d1			  pop de 
123b c9			  ret 
123c			 
123c			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
123c			 
123c			toUpper: 
123c			;A is the char. 
123c			;If A is a lowercase letter, this sets it to the matching uppercase 
123c			;18cc or 30cc or 41cc 
123c			;avg: 26.75cc 
123c fe 61		  cp 'a' 
123e d8			  ret c 
123f fe 7b		  cp 'z'+1 
1241 d0			  ret nc 
1242 d6 20		  sub 'a'-'A' 
1244 c9			  ret 
1245			 
1245			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1245			 
1245			; String Length 
1245			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1245			 
1245			; Get the length of the null-terminated string starting at $8000 hl 
1245			;    LD     HL, $8000 
1245			 
1245			strlenz: 
1245			 
1245 af			    XOR    A               ; Zero is the value we are looking for. 
1246 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1247 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1248			                           ; 65, 536 bytes (the entire addressable memory space). 
1248 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
124a			 
124a			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
124a 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
124b 6f			    LD     L, A             ; number of bytes 
124c ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
124e 2b			    DEC    HL              ; Compensate for null. 
124f c9				ret 
1250			 
1250			; Get the length of the A terminated string starting at $8000 hl 
1250			;    LD     HL, $8000 
1250			 
1250			strlent: 
1250			 
1250			                  ; A is the value we are looking for. 
1250 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1252 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1254			                           ; 65, 536 bytes (the entire addressable memory space). 
1254 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1256			 
1256			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1256 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1258 2e 00		    LD     L, 0             ; number of bytes 
125a ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
125c 2b			    DEC    HL              ; Compensate for null. 
125d c9				ret 
125e			 
125e			 
125e			;Comparing Strings 
125e			 
125e			;IN    HL     Address of string1. 
125e			;      DE     Address of string2. 
125e			 
125e			; doc given but wrong??? 
125e			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
125e			;      carry  Set if string1 > string2, reset if string1 <= string2. 
125e			; tested 
125e			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
125e			 
125e			strcmp_old: 
125e e5			    PUSH   HL 
125f d5			    PUSH   DE 
1260			 
1260 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1261 be			    CP     (HL)            ; (want to minimize work). 
1262 38 01		    JR     C, Str1IsBigger 
1264 7e			    LD     A, (HL) 
1265			 
1265			Str1IsBigger: 
1265 4f			    LD     C, A             ; Put length in BC 
1266 06 00		    LD     B, 0 
1268 13			    INC    DE              ; Increment pointers to meat of string. 
1269 23			    INC    HL 
126a			 
126a			CmpLoop: 
126a 1a			    LD     A, (DE)          ; Compare bytes. 
126b ed a1		    CPI 
126d 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
126f 13			    INC    DE              ; Update pointer. 
1270 ea 6a 12		    JP     PE, CmpLoop 
1273			 
1273 d1			    POP    DE 
1274 e1			    POP    HL 
1275 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1276 be			    CP     (HL) 
1277 c9			    RET 
1278			 
1278			NoMatch: 
1278 2b			    DEC    HL 
1279 be			    CP     (HL)            ; Compare again to affect carry. 
127a d1			    POP    DE 
127b e1			    POP    HL 
127c c9			    RET 
127d			 
127d			;; test strmp 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str2 
127d			;call strcmp 
127d			;jr z, .z1 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "NZ1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.z1: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "ZZ1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str1 
127d			;call strcmp 
127d			;jr z, .z2 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "NZ2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.z2: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "ZZ2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str2 
127d			;call strcmp 
127d			;jr c, .c1 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "Nc1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.c1: 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "cc1" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			; 
127d			;ld de, .str1 
127d			;ld hl, .str1 
127d			;call strcmp 
127d			;jr c, .c2 
127d			;;this 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "Nc2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;.c2: 
127d			; 
127d			;	if DEBUG_FORTH_WORDS 
127d			;		DMARK "cc2" 
127d			;		CALLMONITOR 
127d			;	endif 
127d			;	NEXTW 
127d			;.str1:   db "string1",0 
127d			;.str2:   db "string2",0 
127d			 
127d			; only care about direct match or not 
127d			; hl and de strings 
127d			; zero set if the same 
127d			 
127d			strcmp: 
127d 1a				ld a, (de) 
127e be				cp (hl) 
127f 28 02			jr z, .ssame 
1281 b7				or a 
1282 c9				ret 
1283			 
1283			.ssame:  
1283 fe 00			cp 0 
1285 c8				ret z 
1286			 
1286 23				inc hl 
1287 13				inc de 
1288 18 f3			jr strcmp 
128a				 
128a				 
128a			 
128a			 
128a			 
128a			 
128a			; eof 
128a			 
128a			 
128a			 
128a			 
128a			 
128a			 
# End of file firmware_strings.asm
128a			include "firmware_memory.asm"   ; malloc and free  
128a			 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			.mallocsize: db "Wants malloc >256",0 
128a			.mallocasize: db "MALLOC gives >256",0 
128a			.malloczero: db "MALLOC gives zero",0 
128a			 
128a			malloc_guard_zerolen: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a				ld de, 0 
128a			        call cmp16 
128a				jr nz, .lowalloz 
128a			 
128a				push hl 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .malloczero 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a				call bp_on 
128a			;	ld a, 0 
128a			;	ld (os_view_disable), a 
128a			 
128a				pop de 
128a				pop hl 
128a			 
128a				 
128a			 
128a				CALLMONITOR 
128a			.lowalloz: 
128a			 
128a			 
128a				pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			 
128a			malloc_guard_entry: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a			 	or a      ;clear carry flag 
128a				push hl 
128a				ld de, 255 
128a				sbc hl, de 
128a				jr c, .lowalloc 
128a			 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .mallocsize 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a			;	ld a, 0 
128a			;	ld (os_view_disable), a 
128a				call bp_on 
128a			 
128a				pop de 
128a				pop hl 
128a			 
128a				 
128a			 
128a				CALLMONITOR 
128a				jr .lowdone 
128a			.lowalloc: 
128a			 
128a			 
128a				pop hl 
128a			.lowdone:	pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			 
128a			malloc_guard_exit: 
128a				push hl 
128a				push de 
128a				push af 
128a			 
128a			 	or a      ;clear carry flag 
128a				push hl 
128a				ld de, 255 
128a				sbc hl, de 
128a				jr c, .lowallocx 
128a			 
128a				push de 
128a					ld hl, display_fb0 
128a					ld (display_fb_active), hl 
128a				call clear_display 
128a				ld a, 0 
128a				ld de, .mallocasize 
128a				call str_at_display 
128a				call update_display 
128a				call delay1s 
128a				call delay1s 
128a			;	ld a, 0 
128a			;	ld (os_view_disable), a 
128a				call bp_on 
128a				pop de 
128a				pop hl 
128a			 
128a				CALLMONITOR 
128a				jr .lowdonex 
128a			.lowallocx: 
128a			 
128a				pop hl 
128a			.lowdonex:	pop af 
128a				pop de 
128a				pop hl 
128a			ret 
128a			endif 
128a			 
128a			if MALLOC_2 
128a			; Z80 Malloc and Free Functions 
128a			 
128a			; Malloc Function: 
128a			; Input: 
128a			;   HL: Size of block to allocate 
128a			; Output: 
128a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
128a			 
128a			malloc: 
128a				 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			call malloc_guard_entry 
128a			endif 
128a			 
128a			 
128a			 
128a			 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "mal" 
128a						CALLMONITOR 
128a					endif 
128a			    push af            ; Save AF register 
128a			    ld a, l            ; Load low byte of size into A 
128a			    or h               ; Check if size is zero 
128a			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
128a			 
128a			    ; Allocate memory 
128a			    ld hl, (heap_start) ; Load start of heap into HL 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma1" 
128a						CALLMONITOR 
128a					endif 
128a			    call malloc_internal ; Call internal malloc function 
128a			    pop af             ; Restore AF register 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret                ; Return 
128a			 
128a			; Free Function: 
128a			; Input: 
128a			;   HL: Pointer to memory block to free 
128a			; Output: 
128a			;   None 
128a			 
128a			free: 
128a			    push af            ; Save AF register 
128a			    ld a, l            ; Load low byte of pointer into A 
128a			    or h               ; Check if pointer is NULL 
128a			    jp z, free_exit    ; If pointer is NULL, exit 
128a			 
128a			    ; Free memory 
128a			    ld hl, (heap_start) ; Load start of heap into HL 
128a			    call free_internal  ; Call internal free function 
128a			    pop af             ; Restore AF register 
128a			    ret                ; Return 
128a			 
128a			; Internal Malloc Function: 
128a			; Input: 
128a			;   HL: Size of block to allocate 
128a			; Output: 
128a			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
128a			 
128a			malloc_internal: 
128a			    ld bc, 2           ; Number of bytes to allocate for management overhead 
128a			    add hl, bc         ; Add management overhead to requested size 
128a			    ex de, hl          ; Save total size in DE, and keep it in HL 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma2" 
128a						CALLMONITOR 
128a					endif 
128a			 
128a			    ; Search for free memory block 
128a			    ld de, (heap_end)  ; Load end of heap into DE 
128a			    ld bc, 0           ; Initialize counter 
128a			 
128a					if DEBUG_FORTH_MALLOC 
128a						DMARK "ma2" 
128a						CALLMONITOR 
128a					endif 
128a			malloc_search_loop: 
128a			    ; Check if current block is free 
128a			    ld a, (hl)         ; Load current block's status (free or used) 
128a			    cp 0               ; Compare with zero (free) 
128a			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
128a			 
128a			    ; Check if current block is large enough 
128a			    ld a, (hl+1)       ; Load high byte of block size 
128a			    cp l               ; Compare with low byte of requested size 
128a			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
128a			 
128a			    ld a, (hl+2)       ; Load low byte of block size 
128a			    cp h               ; Compare with high byte of requested size 
128a			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
128a			 
128a			    ; Mark block as used 
128a			    ld (hl), 0xFF      ; Set status byte to indicate used block 
128a			 
128a			    ; Calculate remaining space in block 
128a			    ld bc, 0           ; Clear BC 
128a			    add hl, bc         ; Increment HL to point to start of data block 
128a			    add hl, de         ; HL = HL + DE (total size) 
128a			    ld bc, 1           ; Number of bytes to allocate for management overhead 
128a			    add hl, bc         ; Add management overhead to start of data block 
128a			 
128a			    ; Save pointer to allocated block in HL 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma5" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			 
128a			malloc_skip_block_check: 
128a			    ; Move to the next block 
128a			    ld bc, 3           ; Size of management overhead 
128a			    add hl, bc         ; Move to the next block 
128a			    inc de             ; Increment counter 
128a			 
128a			    ; Check if we have reached the end of heap 
128a			    ld a, e            ; Load low byte of heap end address 
128a			    cp (hl)            ; Compare with low byte of current address 
128a			    jr nz, malloc_search_loop  ; If not equal, continue searching 
128a			    ld a, d            ; Load high byte of heap end address 
128a			    cp 0               ; Check if it's zero (end of memory) 
128a			    jr nz, malloc_search_loop  ; If not zero, continue searching 
128a			 
128a			    ; If we reached here, allocation failed 
128a			    xor a              ; Set result to NULL 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma6" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			malloc_exit: 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a						DMARK "ma7" 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a			    ret 
128a			 
128a			; Internal Free Function: 
128a			; Input: 
128a			;   HL: Pointer to memory block to free 
128a			; Output: 
128a			;   None 
128a			 
128a			free_internal: 
128a			    ld de, (heap_start) ; Load start of heap into DE 
128a			    ld bc, 0            ; Initialize counter 
128a			 
128a			free_search_loop: 
128a			    ; Check if current block contains the pointer 
128a			    ld a, l             ; Load low byte of pointer 
128a			    cp (hl+1)           ; Compare with high byte of current block's address 
128a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
128a			    ld a, h             ; Load high byte of pointer 
128a			    cp (hl+2)           ; Compare with low byte of current block's address 
128a			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
128a			 
128a			    ; Mark block as free 
128a			    ld (hl), 0          ; Set status byte to indicate free block 
128a			    ret                 ; Return 
128a			 
128a			free_skip_block_check: 
128a			    ; Move to the next block 
128a			    ld bc, 3            ; Size of management overhead 
128a			    add hl, bc          ; Move to the next block 
128a			    inc de              ; Increment counter 
128a			 
128a			    ; Check if we have reached the end of heap 
128a			    ld a, e             ; Load low byte of heap end address 
128a			    cp (hl)             ; Compare with low byte of current address 
128a			    jr nz, free_search_loop  ; If not equal, continue searching 
128a			    ld a, d             ; Load high byte of heap end address 
128a			    cp 0                ; Check if it's zero (end of memory) 
128a			    jr nz, free_search_loop  ; If not zero, continue searching 
128a			 
128a			    ; If we reached here, pointer is not found in heap 
128a			    ret 
128a			 
128a			free_exit: 
128a			    ret                 ; Return 
128a			 
128a			; Define heap start and end addresses 
128a			;heap_start:    .dw 0xC000   ; Start of heap 
128a			;heap_end:      .dw 0xE000   ; End of heap 
128a			 
128a			endif 
128a			 
128a			 
128a			if MALLOC_1 
128a			 
128a			 
128a			 
128a			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
128a			 
128a			;moved to firmware.asm 
128a			;heap_start        .equ  0x9000      ; Starting address of heap 
128a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
128a			 
128a			;      .org 0 
128a			;      jp    main 
128a			 
128a			 
128a			;      .org  0x100 
128a			;main: 
128a			;      ld    HL, 0x8100 
128a			;      ld    SP, HL 
128a			; 
128a			;      call  heap_init 
128a			; 
128a			;      ; Make some allocations 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9004 
128a			; 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9014 
128a			; 
128a			;      ld    HL, 12 
128a			;      call  malloc            ; Allocates 0x9024 
128a			; 
128a			;      ; Free some allocations 
128a			;      ld    HL, 0x9014 
128a			;      call  free 
128a			; 
128a			;      ld    HL, 0x9004 
128a			;      call  free 
128a			; 
128a			;      ld    HL, 0x9024 
128a			;      call  free 
128a			; 
128a			; 
128a			;      halt 
128a			 
128a			 
128a			;------------------------------------------------------------------------------ 
128a			;     heap_init                                                               : 
128a			;                                                                             : 
128a			; Description                                                                 : 
128a			;     Initialise the heap and make it ready for malloc and free operations.   : 
128a			;                                                                             : 
128a			;     The heap is maintained as a linked list, starting with an initial       : 
128a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
128a			;     the first free block in the heap. Each block then points to the next    : 
128a			;     free block within the heap, and the free list ends at the first block   : 
128a			;     with a null pointer to the next free block.                             : 
128a			;                                                                             : 
128a			; Parameters                                                                  : 
128a			;     Inputs are compile-time only. Two defines which specify the starting    : 
128a			;     address of the heap and its size are required, along with a memory      : 
128a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
128a			;     principally stores a pointer to the first free block in the heap.       : 
128a			;                                                                             : 
128a			; Returns                                                                     : 
128a			;     Nothing                                                                 : 
128a			;------------------------------------------------------------------------------ 
128a			heap_init: 
128a e5			      push  HL 
128b			 
128b			      ; Initialise free list struct 
128b 21 af 65		      ld    HL, heap_start 
128e 22 aa 65		      ld    (free_list), HL 
1291 21 00 00		      ld    HL, 0 
1294 22 ac 65		      ld    (free_list+2), HL 
1297			 
1297			      ; Insert first free block at bottom of heap, consumes entire heap 
1297 21 a4 e2		      ld    HL, heap_start+heap_size-4 
129a 22 af 65		      ld    (heap_start), HL        ; Next block (end of free list) 
129d 21 f5 7c		      ld    HL, heap_size-4 
12a0 22 b1 65		      ld    (heap_start+2), HL      ; Block size 
12a3			 
12a3			      ; Insert end of free list block at top of heap - two null words will 
12a3			      ; terminate the free list 
12a3 21 00 00		      ld    HL, 0 
12a6 22 a6 e2		      ld    (heap_start+heap_size-2), HL 
12a9 22 a4 e2		      ld    (heap_start+heap_size-4), HL 
12ac			 
12ac e1			      pop   HL 
12ad			 
12ad c9			      ret 
12ae			 
12ae			 
12ae			;------------------------------------------------------------------------------ 
12ae			;     malloc                                                                  : 
12ae			;                                                                             : 
12ae			; Description                                                                 : 
12ae			;     Allocates the wanted space from the heap and returns the address of the : 
12ae			;     first useable byte of the allocation.                                   : 
12ae			;                                                                             : 
12ae			;     Allocations can happen in one of two ways:                              : 
12ae			;                                                                             : 
12ae			;     1. A free block may be found which is the exact size wanted. In this    : 
12ae			;        case the block is removed from the free list and retuedn to the      : 
12ae			;        caller.                                                              : 
12ae			;     2. A free block may be found which is larger than the size wanted. In   : 
12ae			;        this case, the larger block is split into two. The first portion of  : 
12ae			;        this block will become the requested space by the malloc call and    : 
12ae			;        is returned to the caller. The second portion becomes a new free     : 
12ae			;        block, and the free list is adjusted to maintain continuity via this : 
12ae			;        newly created block.                                                 : 
12ae			;                                                                             : 
12ae			;     malloc does not set any initial value in the allocated space, the       : 
12ae			;     caller is required to do this as required.                              : 
12ae			;                                                                             : 
12ae			;     This implementation of malloc uses the stack exclusively, and is        : 
12ae			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12ae			;     advisable to disable interrupts before calling malloc, and recommended  : 
12ae			;     to avoid the use of malloc inside ISRs in general.                      : 
12ae			;                                                                             : 
12ae			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12ae			;                                                                             : 
12ae			; Parameters                                                                  : 
12ae			;     HL  Number of bytes wanted                                              : 
12ae			;                                                                             : 
12ae			; Returns                                                                     : 
12ae			;     HL  Address of the first useable byte of the allocation                 : 
12ae			;                                                                             : 
12ae			; Flags                                                                       : 
12ae			;     Z   Set if the allocation did not succeed, clear otherwise              : 
12ae			;                                                                             : 
12ae			; Stack frame                                                                 : 
12ae			;       |             |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     BC      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     DE      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |     IX      |                                                       : 
12ae			;       +-------------+                                                       : 
12ae			;       |  prev_free  |                                                       : 
12ae			;   +4  +-------------+                                                       : 
12ae			;       |  this_free  |                                                       : 
12ae			;   +2  +-------------+                                                       : 
12ae			;       |  next_free  |                                                       : 
12ae			;   +0  +-------------+                                                       : 
12ae			;       |             |                                                       : 
12ae			;                                                                             : 
12ae			;------------------------------------------------------------------------------ 
12ae			 
12ae			 
12ae			;malloc: 
12ae			; 
12ae			;	SAVESP ON 1 
12ae			; 
12ae			;	call malloc_code 
12ae			; 
12ae			;	CHECKSP ON 1 
12ae			;	ret 
12ae			 
12ae			 
12ae			malloc: 
12ae c5			      push  BC 
12af d5			      push  DE 
12b0 dd e5		      push  IX 
12b2			if DEBUG_FORTH_MALLOC_HIGH 
12b2			call malloc_guard_entry 
12b2			endif 
12b2			 
12b2					if DEBUG_FORTH_MALLOC 
12b2						DMARK "mal" 
12b2						CALLMONITOR 
12b2					endif 
12b2 7c			      ld    A, H                    ; Exit if no space requested 
12b3 b5			      or    L 
12b4 ca 73 13		      jp    Z, malloc_early_exit 
12b7			 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			; 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			;inc hl 
12b7			 
12b7			 
12b7			 
12b7			 
12b7					if DEBUG_FORTH_MALLOC 
12b7						DMARK "maA" 
12b7						CALLMONITOR 
12b7					endif 
12b7			      ; Set up stack frame 
12b7 eb			      ex    DE, HL 
12b8 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
12bb 39			      add   HL, SP 
12bc f9			      ld    SP, HL 
12bd dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12c1 dd 39		      add   IX, SP 
12c3			 
12c3			      ; Setup initial state 
12c3 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
12c6 19			      add   HL, DE 
12c7			 
12c7 44			      ld    B, H                    ; Move want to BC 
12c8 4d			      ld    C, L 
12c9			 
12c9 21 aa 65		      ld    HL, free_list           ; Store prev_free ptr to stack 
12cc dd 75 04		      ld    (IX+4), L 
12cf dd 74 05		      ld    (IX+5), H 
12d2			 
12d2 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
12d3 23			      inc   HL 
12d4 56			      ld    D, (HL) 
12d5 dd 73 02		      ld    (IX+2), E 
12d8 dd 72 03		      ld    (IX+3), D 
12db eb			      ex    DE, HL                  ; this_free ptr into HL 
12dc			 
12dc					if DEBUG_FORTH_MALLOC 
12dc						DMARK "maB" 
12dc						CALLMONITOR 
12dc					endif 
12dc			      ; Loop through free block list to find some space 
12dc			malloc_find_space: 
12dc 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
12dd 23			      inc   HL 
12de 56			      ld    D, (HL) 
12df			 
12df 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
12e0 b3			      or    E 
12e1 ca 6d 13		      jp    Z, malloc_no_space 
12e4			 
12e4 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
12e7 dd 72 01		      ld    (IX+1), D 
12ea			 
12ea			      ; Does this block have enough space to make the allocation? 
12ea 23			      inc   HL                      ; Load free block size into DE 
12eb 5e			      ld    E, (HL) 
12ec 23			      inc   HL 
12ed 56			      ld    D, (HL) 
12ee			 
12ee eb			      ex    DE, HL                  ; Check size of block against want 
12ef b7			      or    A                       ; Ensure carry flag clear 
12f0 ed 42		      sbc   HL, BC 
12f2 e5			      push  HL                      ; Store the result for later (new block size) 
12f3			 
12f3 ca 42 13		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
12f6 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
12f8			 
12f8			      ; this_free block is not big enough, setup ptrs to test next free block 
12f8 e1			      pop   HL                      ; Discard previous result 
12f9			 
12f9 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
12fc dd 66 03		      ld    H, (IX+3) 
12ff dd 75 04		      ld    (IX+4), L 
1302 dd 74 05		      ld    (IX+5), H 
1305			 
1305 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1308 dd 66 01		      ld    H, (IX+1) 
130b dd 75 02		      ld    (IX+2), L 
130e dd 74 03		      ld    (IX+3), H 
1311			 
1311					if DEBUG_FORTH_MALLOC 
1311						DMARK "MA>" 
1311						CALLMONITOR 
1311					endif 
1311 18 c9		      jr    malloc_find_space 
1313			 
1313			      ; split a bigger block into two - requested size and remaining size 
1313			malloc_alloc_split: 
1313					if DEBUG_FORTH_MALLOC 
1313						DMARK "MAs" 
1313						CALLMONITOR 
1313					endif 
1313 eb			      ex    DE, HL                  ; Calculate address of new free block 
1314 2b			      dec   HL 
1315 2b			      dec   HL 
1316 2b			      dec   HL 
1317 09			      add   HL, BC 
1318			 
1318			      ; Create a new block and point it at next_free 
1318 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
131b dd 56 01		      ld    D, (IX+1) 
131e			 
131e 73			      ld    (HL), E                 ; Store next_free ptr into new block 
131f 23			      inc   HL 
1320 72			      ld    (HL), D 
1321			 
1321 d1			      pop   DE                      ; Store size of new block into new block 
1322 23			      inc   HL 
1323 73			      ld    (HL), E 
1324 23			      inc   HL 
1325 72			      ld    (HL), D 
1326			 
1326			      ; Update this_free ptr to point to new block 
1326 2b			      dec   HL 
1327 2b			      dec   HL 
1328 2b			      dec   HL 
1329			 
1329 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
132c dd 56 03		      ld    D, (IX+3) 
132f			 
132f dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1332 dd 74 03		      ld    (IX+3), H 
1335			 
1335			      ; Modify this_free block to be allocation 
1335 eb			      ex    DE, HL 
1336 af			      xor   A                       ; Null the next block ptr of allocated block 
1337 77			      ld    (HL), A 
1338 23			      inc   HL 
1339 77			      ld    (HL), A 
133a			 
133a 23			      inc   HL                      ; Store want size into allocated block 
133b 71			      ld    (HL), C 
133c 23			      inc   HL 
133d 70			      ld    (HL), B 
133e 23			      inc   HL 
133f e5			      push  HL                      ; Address of allocation to return 
1340			 
1340 18 19		      jr    malloc_update_links 
1342			 
1342			malloc_alloc_fit: 
1342 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1343			 
1343					if DEBUG_FORTH_MALLOC 
1343						DMARK "MAf" 
1343						CALLMONITOR 
1343					endif 
1343			      ; Modify this_free block to be allocation 
1343 eb			      ex    DE, HL 
1344 2b			      dec   HL 
1345 2b			      dec   HL 
1346 2b			      dec   HL 
1347			 
1347 af			      xor   A                       ; Null the next block ptr of allocated block 
1348 77			      ld    (HL), A 
1349 23			      inc   HL 
134a 77			      ld    (HL), A 
134b			 
134b 23			      inc   HL                      ; Store address of allocation to return 
134c 23			      inc   HL 
134d 23			      inc   HL 
134e e5			      push  HL 
134f			 
134f			      ; Copy next_free ptr to this_free, remove allocated block from free list 
134f dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1352 dd 66 01		      ld    H, (IX+1) 
1355			 
1355 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1358 dd 74 03		      ld    (IX+3), H 
135b			 
135b			 
135b			malloc_update_links: 
135b			      ; Update prev_free ptr to point to this_free 
135b dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
135e dd 66 05		      ld    H, (IX+5) 
1361			 
1361 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1364 dd 56 03		      ld    D, (IX+3) 
1367			 
1367 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1368 23			      inc   HL 
1369 72			      ld    (HL), D 
136a			 
136a					if DEBUG_FORTH_MALLOC 
136a						DMARK "Mul" 
136a						CALLMONITOR 
136a					endif 
136a			      ; Clear the Z flag to indicate successful allocation 
136a 7a			      ld    A, D 
136b b3			      or    E 
136c			 
136c d1			      pop   DE                      ; Address of allocation 
136d					if DEBUG_FORTH_MALLOC 
136d						DMARK "MAu" 
136d						CALLMONITOR 
136d					endif 
136d			 
136d			malloc_no_space: 
136d 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1370 39			      add   HL, SP 
1371 f9			      ld    SP, HL 
1372			 
1372 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1373					if DEBUG_FORTH_MALLOC 
1373						DMARK "MAN" 
1373						CALLMONITOR 
1373					endif 
1373			 
1373			malloc_early_exit: 
1373					if DEBUG_FORTH_MALLOC 
1373						DMARK "MAx" 
1373						CALLMONITOR 
1373					endif 
1373 dd e1		      pop   IX 
1375 d1			      pop   DE 
1376 c1			      pop   BC 
1377			 
1377			if DEBUG_FORTH_MALLOC_HIGH 
1377			call malloc_guard_exit 
1377			call malloc_guard_zerolen 
1377			endif 
1377 c9			      ret 
1378			 
1378			 
1378			;------------------------------------------------------------------------------ 
1378			;     free                                                                    : 
1378			;                                                                             : 
1378			; Description                                                                 : 
1378			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1378			;     returned by malloc, otherwise the behaviour is undefined.               : 
1378			;                                                                             : 
1378			;     Where possible, directly adjacent free blocks will be merged together   : 
1378			;     into larger blocks to help ensure that the heap does not become         : 
1378			;     excessively fragmented.                                                 : 
1378			;                                                                             : 
1378			;     free does not clear or set any other value into the freed space, and    : 
1378			;     therefore its contents may be visible through subsequent malloc's. The  : 
1378			;     caller should clear the freed space as required.                        : 
1378			;                                                                             : 
1378			;     This implementation of free uses the stack exclusively, and is          : 
1378			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1378			;     advisable to disable interrupts before calling free, and recommended    : 
1378			;     to avoid the use of free inside ISRs in general.                        : 
1378			;                                                                             : 
1378			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1378			;                                                                             : 
1378			; Parameters                                                                  : 
1378			;     HL  Pointer to address of first byte of allocation to be freed          : 
1378			;                                                                             : 
1378			; Returns                                                                     : 
1378			;     Nothing                                                                 : 
1378			;                                                                             : 
1378			; Stack frame                                                                 : 
1378			;       |             |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     BC      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     DE      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     IX      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |  prev_free  |                                                       : 
1378			;   +2  +-------------+                                                       : 
1378			;       |  next_free  |                                                       : 
1378			;   +0  +-------------+                                                       : 
1378			;       |             |                                                       : 
1378			;                                                                             : 
1378			;------------------------------------------------------------------------------ 
1378			free: 
1378 c5			      push  BC 
1379 d5			      push  DE 
137a dd e5		      push  IX 
137c			 
137c 7c			      ld    A, H                    ; Exit if ptr is null 
137d b5			      or    L 
137e ca 42 14		      jp    Z, free_early_exit 
1381			 
1381			      ; Set up stack frame 
1381 eb			      ex    DE, HL 
1382 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1385 39			      add   HL, SP 
1386 f9			      ld    SP, HL 
1387 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
138b dd 39		      add   IX, SP 
138d			 
138d			      ; The address in HL points to the start of the useable allocated space, 
138d			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
138d			      ; address of the block itself. 
138d eb			      ex    DE, HL 
138e 11 fc ff		      ld    DE, -4 
1391 19			      add   HL, DE 
1392			 
1392			      ; An allocated block must have a null next block pointer in it 
1392 7e			      ld    A, (HL) 
1393 23			      inc   HL 
1394 b6			      or    (HL) 
1395 c2 3d 14		      jp    NZ, free_done 
1398			 
1398 2b			      dec   HL 
1399			 
1399 44			      ld    B, H                    ; Copy HL to BC 
139a 4d			      ld    C, L 
139b			 
139b			      ; Loop through the free list to find the first block with an address 
139b			      ; higher than the block being freed 
139b 21 aa 65		      ld    HL, free_list 
139e			 
139e			free_find_higher_block: 
139e 5e			      ld    E, (HL)                 ; Load next ptr from free block 
139f 23			      inc   HL 
13a0 56			      ld    D, (HL) 
13a1 2b			      dec   HL 
13a2			 
13a2 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
13a5 dd 72 01		      ld    (IX+1), D 
13a8 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
13ab dd 74 03		      ld    (IX+3), H 
13ae			 
13ae 78			      ld    A, B                    ; Check if DE is greater than BC 
13af ba			      cp    D                       ; Compare MSB first 
13b0 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
13b2 30 04		      jr    NC, free_find_higher_block_skip 
13b4 79			      ld    A, C 
13b5 bb			      cp    E                       ; Then compare LSB 
13b6 38 08		      jr    C, free_found_higher_block 
13b8			 
13b8			free_find_higher_block_skip: 
13b8 7a			      ld    A, D                    ; Reached the end of the free list? 
13b9 b3			      or    E 
13ba ca 3d 14		      jp    Z, free_done 
13bd			 
13bd eb			      ex    DE, HL 
13be			 
13be 18 de		      jr    free_find_higher_block 
13c0			 
13c0			free_found_higher_block: 
13c0			      ; Insert freed block between prev and next free blocks 
13c0 71			      ld    (HL), C                 ; Point prev free block to freed block 
13c1 23			      inc   HL 
13c2 70			      ld    (HL), B 
13c3			 
13c3 60			      ld    H, B                    ; Point freed block at next free block 
13c4 69			      ld    L, C 
13c5 73			      ld    (HL), E 
13c6 23			      inc   HL 
13c7 72			      ld    (HL), D 
13c8			 
13c8			      ; Check if the freed block is adjacent to the next free block 
13c8 23			      inc   HL                      ; Load size of freed block into HL 
13c9 5e			      ld    E, (HL) 
13ca 23			      inc   HL 
13cb 56			      ld    D, (HL) 
13cc eb			      ex    DE, HL 
13cd			 
13cd 09			      add   HL, BC                  ; Add addr of freed block and its size 
13ce			 
13ce dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
13d1 dd 56 01		      ld    D, (IX+1) 
13d4			 
13d4 b7			      or    A                       ; Clear the carry flag 
13d5 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
13d7 20 22		      jr    NZ, free_check_adjacent_to_prev 
13d9			 
13d9			      ; Freed block is adjacent to next, merge into one bigger block 
13d9 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
13da 5e			      ld    E, (HL) 
13db 23			      inc   HL 
13dc 56			      ld    D, (HL) 
13dd e5			      push  HL                      ; Save ptr to next block for later 
13de			 
13de 60			      ld    H, B                    ; Store ptr from next block into freed block 
13df 69			      ld    L, C 
13e0 73			      ld    (HL), E 
13e1 23			      inc   HL 
13e2 72			      ld    (HL), D 
13e3			 
13e3 e1			      pop   HL                      ; Restore ptr to next block 
13e4 23			      inc   HL                      ; Load size of next block into DE 
13e5 5e			      ld    E, (HL) 
13e6 23			      inc   HL 
13e7 56			      ld    D, (HL) 
13e8 d5			      push  DE                      ; Save next block size for later 
13e9			 
13e9 60			      ld    H, B                    ; Load size of freed block into HL 
13ea 69			      ld    L, C 
13eb 23			      inc   HL 
13ec 23			      inc   HL 
13ed 5e			      ld    E, (HL) 
13ee 23			      inc   HL 
13ef 56			      ld    D, (HL) 
13f0 eb			      ex    DE, HL 
13f1			 
13f1 d1			      pop   DE                      ; Restore size of next block 
13f2 19			      add   HL, DE                  ; Add sizes of both blocks 
13f3 eb			      ex    DE, HL 
13f4			 
13f4 60			      ld    H, B                    ; Store new bigger size into freed block 
13f5 69			      ld    L, C 
13f6 23			      inc   HL 
13f7 23			      inc   HL 
13f8 73			      ld    (HL), E 
13f9 23			      inc   HL 
13fa 72			      ld    (HL), D 
13fb			 
13fb			free_check_adjacent_to_prev: 
13fb			      ; Check if the freed block is adjacent to the prev free block 
13fb dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
13fe dd 66 03		      ld    H, (IX+3) 
1401			 
1401 23			      inc   HL                      ; Size of prev free block into DE 
1402 23			      inc   HL 
1403 5e			      ld    E, (HL) 
1404 23			      inc   HL 
1405 56			      ld    D, (HL) 
1406 2b			      dec   HL 
1407 2b			      dec   HL 
1408 2b			      dec   HL 
1409			 
1409 19			      add   HL, DE                  ; Add prev block addr and size 
140a			 
140a b7			      or    A                       ; Clear the carry flag 
140b ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
140d 20 2e		      jr    NZ, free_done 
140f			 
140f			      ; Freed block is adjacent to prev, merge into one bigger block 
140f 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1410 69			      ld    L, C 
1411 5e			      ld    E, (HL) 
1412 23			      inc   HL 
1413 56			      ld    D, (HL) 
1414 e5			      push  HL                      ; Save freed block ptr for later 
1415			 
1415 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1418 dd 66 03		      ld    H, (IX+3) 
141b 73			      ld    (HL), E 
141c 23			      inc   HL 
141d 72			      ld    (HL), D 
141e			 
141e e1			      pop   HL                      ; Restore freed block ptr 
141f 23			      inc   HL                      ; Load size of freed block into DE 
1420 5e			      ld    E, (HL) 
1421 23			      inc   HL 
1422 56			      ld    D, (HL) 
1423 d5			      push  DE                      ; Save freed block size for later 
1424			 
1424 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1427 dd 66 03		      ld    H, (IX+3) 
142a 23			      inc   HL 
142b 23			      inc   HL 
142c 5e			      ld    E, (HL) 
142d 23			      inc   HL 
142e 56			      ld    D, (HL) 
142f			 
142f e1			      pop   HL                      ; Add sizes of both blocks 
1430 19			      add   HL, DE 
1431 eb			      ex    DE, HL 
1432			 
1432 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1435 dd 66 03		      ld    H, (IX+3) 
1438 23			      inc   HL 
1439 23			      inc   HL 
143a 73			      ld    (HL), E 
143b 23			      inc   HL 
143c 72			      ld    (HL), D 
143d			 
143d			free_done: 
143d 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1440 39			      add   HL, SP 
1441 f9			      ld    SP, HL 
1442			 
1442			free_early_exit: 
1442 dd e1		      pop   IX 
1444 d1			      pop   DE 
1445 c1			      pop   BC 
1446			 
1446 c9			      ret 
1447			 
1447			; moved to firmware.asm 
1447			; 
1447			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1447			;                  .dw   0 
1447			 
1447			 
1447			endif 
1447			 
1447			 
1447			if MALLOC_3 
1447			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1447			;heap_start        .equ  0x9000      ; Starting address of heap 
1447			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1447			; 
1447			 ;     .org 0 
1447			  ;    jp    main 
1447			; 
1447			; 
1447			 ;     .org  0x100 
1447			;main: 
1447			 ;     ld    HL, 0x8100 
1447			  ;    ld    SP, HL 
1447			; 
1447			;      call  heap_init 
1447			 
1447			      ; Make some allocations 
1447			;      ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9004 
1447			; 
1447			 ;     ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9014 
1447			 
1447			;      ld    HL, 12 
1447			;      call  malloc            ; Allocates 0x9024 
1447			 
1447			      ; Free some allocations 
1447			;      ld    HL, 0x9014 
1447			;      call  free 
1447			 
1447			;      ld    HL, 0x9004 
1447			;      call  free 
1447			; 
1447			;      ld    HL, 0x9024 
1447			;      call  free 
1447			 
1447			 
1447			 ;     halt 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     heap_init                                                               : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Initialise the heap and make it ready for malloc and free operations.   : 
1447			;                                                                             : 
1447			;     The heap is maintained as a linked list, starting with an initial       : 
1447			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1447			;     the first free block in the heap. Each block then points to the next    : 
1447			;     free block within the heap, and the free list ends at the first block   : 
1447			;     with a null pointer to the next free block.                             : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     Inputs are compile-time only. Two defines which specify the starting    : 
1447			;     address of the heap and its size are required, along with a memory      : 
1447			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1447			;     principally stores a pointer to the first free block in the heap.       : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     Nothing                                                                 : 
1447			;------------------------------------------------------------------------------ 
1447			heap_init: 
1447			      push  HL 
1447			 
1447			      ; Initialise free list struct 
1447			      ld    HL, heap_start 
1447			      ld    (free_list), HL 
1447			      ld    HL, 0 
1447			      ld    (free_list+2), HL 
1447			 
1447			      ; Insert first free block at bottom of heap, consumes entire heap 
1447			      ld    HL, heap_start+heap_size-4 
1447			      ld    (heap_start), HL        ; Next block (end of free list) 
1447			      ld    HL, heap_size-4 
1447			      ld    (heap_start+2), HL      ; Block size 
1447			 
1447			      ; Insert end of free list block at top of heap - two null words will 
1447			      ; terminate the free list 
1447			      ld    HL, 0 
1447			      ld    (heap_start+heap_size-2), HL 
1447			      ld    (heap_start+heap_size-4), HL 
1447			 
1447			      pop   HL 
1447			 
1447			      ret 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     malloc                                                                  : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Allocates the wanted space from the heap and returns the address of the : 
1447			;     first useable byte of the allocation.                                   : 
1447			;                                                                             : 
1447			;     Allocations can happen in one of two ways:                              : 
1447			;                                                                             : 
1447			;     1. A free block may be found which is the exact size wanted. In this    : 
1447			;        case the block is removed from the free list and retuedn to the      : 
1447			;        caller.                                                              : 
1447			;     2. A free block may be found which is larger than the size wanted. In   : 
1447			;        this case, the larger block is split into two. The first portion of  : 
1447			;        this block will become the requested space by the malloc call and    : 
1447			;        is returned to the caller. The second portion becomes a new free     : 
1447			;        block, and the free list is adjusted to maintain continuity via this : 
1447			;        newly created block.                                                 : 
1447			;                                                                             : 
1447			;     malloc does not set any initial value in the allocated space, the       : 
1447			;     caller is required to do this as required.                              : 
1447			;                                                                             : 
1447			;     This implementation of malloc uses the stack exclusively, and is        : 
1447			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1447			;     advisable to disable interrupts before calling malloc, and recommended  : 
1447			;     to avoid the use of malloc inside ISRs in general.                      : 
1447			;                                                                             : 
1447			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     HL  Number of bytes wanted                                              : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     HL  Address of the first useable byte of the allocation                 : 
1447			;                                                                             : 
1447			; Flags                                                                       : 
1447			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1447			;                                                                             : 
1447			; Stack frame                                                                 : 
1447			;       |             |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     BC      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     DE      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     IX      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |  prev_free  |                                                       : 
1447			;   +4  +-------------+                                                       : 
1447			;       |  this_free  |                                                       : 
1447			;   +2  +-------------+                                                       : 
1447			;       |  next_free  |                                                       : 
1447			;   +0  +-------------+                                                       : 
1447			;       |             |                                                       : 
1447			;                                                                             : 
1447			;------------------------------------------------------------------------------ 
1447			malloc: 
1447			      push  BC 
1447			      push  DE 
1447			      push  IX 
1447			 
1447			      ld    A, H                    ; Exit if no space requested 
1447			      or    L 
1447			      jp    Z, malloc_early_exit 
1447			 
1447			      ; Set up stack frame 
1447			      ex    DE, HL 
1447			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			      ld    IX, 0                   ; Use IX as a frame pointer 
1447			      add   IX, SP 
1447			 
1447			      ; Setup initial state 
1447			      ld    HL, 4                   ; want must also include space used by block struct 
1447			      add   HL, DE 
1447			 
1447			      ld    B, H                    ; Move want to BC 
1447			      ld    C, L 
1447			 
1447			      ld    HL, free_list           ; Store prev_free ptr to stack 
1447			      ld    (IX+4), L 
1447			      ld    (IX+5), H 
1447			 
1447			      ld    E, (HL)                 ; Store this_free ptr to stack 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ld    (IX+2), E 
1447			      ld    (IX+3), D 
1447			      ex    DE, HL                  ; this_free ptr into HL 
1447			 
1447			      ; Loop through free block list to find some space 
1447			malloc_find_space: 
1447			      ld    E, (HL)                 ; Load next_free ptr into DE 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1447			      or    E 
1447			      jp    Z, malloc_no_space 
1447			 
1447			      ld    (IX+0), E               ; Store next_free ptr to stack 
1447			      ld    (IX+1), D 
1447			 
1447			      ; Does this block have enough space to make the allocation? 
1447			      inc   HL                      ; Load free block size into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      ex    DE, HL                  ; Check size of block against want 
1447			      or    A                       ; Ensure carry flag clear 
1447			      sbc   HL, BC 
1447			      push  HL                      ; Store the result for later (new block size) 
1447			 
1447			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1447			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1447			 
1447			      ; this_free block is not big enough, setup ptrs to test next free block 
1447			      pop   HL                      ; Discard previous result 
1447			 
1447			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1447			      ld    H, (IX+3) 
1447			      ld    (IX+4), L 
1447			      ld    (IX+5), H 
1447			 
1447			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1447			      ld    H, (IX+1) 
1447			      ld    (IX+2), L 
1447			      ld    (IX+3), H 
1447			 
1447			      jr    malloc_find_space 
1447			 
1447			      ; split a bigger block into two - requested size and remaining size 
1447			malloc_alloc_split: 
1447			      ex    DE, HL                  ; Calculate address of new free block 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			      add   HL, BC 
1447			 
1447			      ; Create a new block and point it at next_free 
1447			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1447			      ld    D, (IX+1) 
1447			 
1447			      ld    (HL), E                 ; Store next_free ptr into new block 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   DE                      ; Store size of new block into new block 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Update this_free ptr to point to new block 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1447			      ld    D, (IX+3) 
1447			 
1447			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1447			      ld    (IX+3), H 
1447			 
1447			      ; Modify this_free block to be allocation 
1447			      ex    DE, HL 
1447			      xor   A                       ; Null the next block ptr of allocated block 
1447			      ld    (HL), A 
1447			      inc   HL 
1447			      ld    (HL), A 
1447			 
1447			      inc   HL                      ; Store want size into allocated block 
1447			      ld    (HL), C 
1447			      inc   HL 
1447			      ld    (HL), B 
1447			      inc   HL 
1447			      push  HL                      ; Address of allocation to return 
1447			 
1447			      jr    malloc_update_links 
1447			 
1447			malloc_alloc_fit: 
1447			      pop   HL                      ; Dont need new block size, want is exact fit 
1447			 
1447			      ; Modify this_free block to be allocation 
1447			      ex    DE, HL 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      xor   A                       ; Null the next block ptr of allocated block 
1447			      ld    (HL), A 
1447			      inc   HL 
1447			      ld    (HL), A 
1447			 
1447			      inc   HL                      ; Store address of allocation to return 
1447			      inc   HL 
1447			      inc   HL 
1447			      push  HL 
1447			 
1447			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1447			      ld    L, (IX+0)               ; next_free to HL 
1447			      ld    H, (IX+1) 
1447			 
1447			      ld    (IX+2), L               ; HL to this_free 
1447			      ld    (IX+3), H 
1447			 
1447			 
1447			malloc_update_links: 
1447			      ; Update prev_free ptr to point to this_free 
1447			      ld    L, (IX+4)               ; prev_free ptr to HL 
1447			      ld    H, (IX+5) 
1447			 
1447			      ld    E, (IX+2)               ; this_free ptr to DE 
1447			      ld    D, (IX+3) 
1447			 
1447			      ld    (HL), E                 ; this_free ptr into prev_free 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Clear the Z flag to indicate successful allocation 
1447			      ld    A, D 
1447			      or    E 
1447			 
1447			      pop   DE                      ; Address of allocation 
1447			 
1447			malloc_no_space: 
1447			      ld    HL, 6                   ; Clean up stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			 
1447			      ex    DE, HL                  ; Alloc addr into HL for return 
1447			 
1447			malloc_early_exit: 
1447			      pop   IX 
1447			      pop   DE 
1447			      pop   BC 
1447			 
1447			      ret 
1447			 
1447			 
1447			;------------------------------------------------------------------------------ 
1447			;     free                                                                    : 
1447			;                                                                             : 
1447			; Description                                                                 : 
1447			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1447			;     returned by malloc, otherwise the behaviour is undefined.               : 
1447			;                                                                             : 
1447			;     Where possible, directly adjacent free blocks will be merged together   : 
1447			;     into larger blocks to help ensure that the heap does not become         : 
1447			;     excessively fragmented.                                                 : 
1447			;                                                                             : 
1447			;     free does not clear or set any other value into the freed space, and    : 
1447			;     therefore its contents may be visible through subsequent malloc's. The  : 
1447			;     caller should clear the freed space as required.                        : 
1447			;                                                                             : 
1447			;     This implementation of free uses the stack exclusively, and is          : 
1447			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1447			;     advisable to disable interrupts before calling free, and recommended    : 
1447			;     to avoid the use of free inside ISRs in general.                        : 
1447			;                                                                             : 
1447			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1447			;                                                                             : 
1447			; Parameters                                                                  : 
1447			;     HL  Pointer to address of first byte of allocation to be freed          : 
1447			;                                                                             : 
1447			; Returns                                                                     : 
1447			;     Nothing                                                                 : 
1447			;                                                                             : 
1447			; Stack frame                                                                 : 
1447			;       |             |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     BC      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     DE      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |     IX      |                                                       : 
1447			;       +-------------+                                                       : 
1447			;       |  prev_free  |                                                       : 
1447			;   +2  +-------------+                                                       : 
1447			;       |  next_free  |                                                       : 
1447			;   +0  +-------------+                                                       : 
1447			;       |             |                                                       : 
1447			;                                                                             : 
1447			;------------------------------------------------------------------------------ 
1447			free: 
1447			      push  BC 
1447			      push  DE 
1447			      push  IX 
1447			 
1447			      ld    A, H                    ; Exit if ptr is null 
1447			      or    L 
1447			      jp    Z, free_early_exit 
1447			 
1447			      ; Set up stack frame 
1447			      ex    DE, HL 
1447			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			      ld    IX, 0                   ; Use IX as a frame pointer 
1447			      add   IX, SP 
1447			 
1447			      ; The address in HL points to the start of the useable allocated space, 
1447			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1447			      ; address of the block itself. 
1447			      ex    DE, HL 
1447			      ld    DE, -4 
1447			      add   HL, DE 
1447			 
1447			      ; An allocated block must have a null next block pointer in it 
1447			      ld    A, (HL) 
1447			      inc   HL 
1447			      or    (HL) 
1447			      jp    NZ, free_done 
1447			 
1447			      dec   HL 
1447			 
1447			      ld    B, H                    ; Copy HL to BC 
1447			      ld    C, L 
1447			 
1447			      ; Loop through the free list to find the first block with an address 
1447			      ; higher than the block being freed 
1447			      ld    HL, free_list 
1447			 
1447			free_find_higher_block: 
1447			      ld    E, (HL)                 ; Load next ptr from free block 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      dec   HL 
1447			 
1447			      ld    (IX+0), E               ; Save ptr to next free block 
1447			      ld    (IX+1), D 
1447			      ld    (IX+2), L               ; Save ptr to prev free block 
1447			      ld    (IX+3), H 
1447			 
1447			      ld    A, B                    ; Check if DE is greater than BC 
1447			      cp    D                       ; Compare MSB first 
1447			      jr    Z, $+4                  ; MSB the same, compare LSB 
1447			      jr    NC, free_find_higher_block_skip 
1447			      ld    A, C 
1447			      cp    E                       ; Then compare LSB 
1447			      jr    C, free_found_higher_block 
1447			 
1447			free_find_higher_block_skip: 
1447			      ld    A, D                    ; Reached the end of the free list? 
1447			      or    E 
1447			      jp    Z, free_done 
1447			 
1447			      ex    DE, HL 
1447			 
1447			      jr    free_find_higher_block 
1447			 
1447			free_found_higher_block: 
1447			      ; Insert freed block between prev and next free blocks 
1447			      ld    (HL), C                 ; Point prev free block to freed block 
1447			      inc   HL 
1447			      ld    (HL), B 
1447			 
1447			      ld    H, B                    ; Point freed block at next free block 
1447			      ld    L, C 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      ; Check if the freed block is adjacent to the next free block 
1447			      inc   HL                      ; Load size of freed block into HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ex    DE, HL 
1447			 
1447			      add   HL, BC                  ; Add addr of freed block and its size 
1447			 
1447			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1447			      ld    D, (IX+1) 
1447			 
1447			      or    A                       ; Clear the carry flag 
1447			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1447			      jr    NZ, free_check_adjacent_to_prev 
1447			 
1447			      ; Freed block is adjacent to next, merge into one bigger block 
1447			      ex    DE, HL                  ; Load next ptr from next block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  HL                      ; Save ptr to next block for later 
1447			 
1447			      ld    H, B                    ; Store ptr from next block into freed block 
1447			      ld    L, C 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   HL                      ; Restore ptr to next block 
1447			      inc   HL                      ; Load size of next block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  DE                      ; Save next block size for later 
1447			 
1447			      ld    H, B                    ; Load size of freed block into HL 
1447			      ld    L, C 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      ex    DE, HL 
1447			 
1447			      pop   DE                      ; Restore size of next block 
1447			      add   HL, DE                  ; Add sizes of both blocks 
1447			      ex    DE, HL 
1447			 
1447			      ld    H, B                    ; Store new bigger size into freed block 
1447			      ld    L, C 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			free_check_adjacent_to_prev: 
1447			      ; Check if the freed block is adjacent to the prev free block 
1447			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1447			      ld    H, (IX+3) 
1447			 
1447			      inc   HL                      ; Size of prev free block into DE 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      dec   HL 
1447			      dec   HL 
1447			      dec   HL 
1447			 
1447			      add   HL, DE                  ; Add prev block addr and size 
1447			 
1447			      or    A                       ; Clear the carry flag 
1447			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1447			      jr    NZ, free_done 
1447			 
1447			      ; Freed block is adjacent to prev, merge into one bigger block 
1447			      ld    H, B                    ; Load next ptr from freed block into DE 
1447			      ld    L, C 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  HL                      ; Save freed block ptr for later 
1447			 
1447			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1447			      ld    H, (IX+3) 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			      pop   HL                      ; Restore freed block ptr 
1447			      inc   HL                      ; Load size of freed block into DE 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			      push  DE                      ; Save freed block size for later 
1447			 
1447			      ld    L, (IX+2)               ; Load size of prev block into DE 
1447			      ld    H, (IX+3) 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    E, (HL) 
1447			      inc   HL 
1447			      ld    D, (HL) 
1447			 
1447			      pop   HL                      ; Add sizes of both blocks 
1447			      add   HL, DE 
1447			      ex    DE, HL 
1447			 
1447			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1447			      ld    H, (IX+3) 
1447			      inc   HL 
1447			      inc   HL 
1447			      ld    (HL), E 
1447			      inc   HL 
1447			      ld    (HL), D 
1447			 
1447			free_done: 
1447			      ld    HL, 4                   ; Clean up stack frame 
1447			      add   HL, SP 
1447			      ld    SP, HL 
1447			 
1447			free_early_exit: 
1447			      pop   IX 
1447			      pop   DE 
1447			      pop   BC 
1447			 
1447			      ret 
1447			 
1447			 
1447			;      .org 0x8000 
1447			; 
1447			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1447			 ;                 .dw   0 
1447			 
1447			endif 
1447			 
1447			 
1447			if MALLOC_4 
1447			 
1447			; My memory allocation code. Very very simple.... 
1447			; allocate space under 250 chars 
1447			 
1447			heap_init: 
1447				; init start of heap as zero 
1447				;  
1447			 
1447				ld hl, heap_start 
1447				ld a, 0 
1447				ld (hl), a      ; empty block 
1447				inc hl 
1447				ld a, 0 
1447				ld (hl), a      ; length of block 
1447				; write end of list 
1447				inc hl 
1447				ld a,(hl) 
1447				inc hl 
1447				ld a,(hl) 
1447				 
1447			 
1447				; init some malloc vars 
1447			 
1447				ld hl, 0 
1447				ld (free_list), hl       ; store last malloc location 
1447			 
1447				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1447				ld a, 0 
1447				ld (hl), a 
1447			 
1447			 
1447				ld hl, heap_start 
1447				;  
1447				  
1447				ret 
1447			 
1447			 
1447			;    free block marker 
1447			;    requested size  
1447			;    pointer to next block 
1447			;    .... 
1447			;    next block marker 
1447			 
1447			 
1447			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1447			; 
1447			 
1447			 
1447			malloc:  
1447				push de 
1447				push bc 
1447				push af 
1447			 
1447				; hl space required 
1447				 
1447				ld c, l    ; hold space   (TODO only a max of 255) 
1447			 
1447			;	inc c     ; TODO BUG need to fix memory leak on push str 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			;	inc c 
1447			 
1447			 
1447			 
1447				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1447			 
1447				ld a, (free_list+3) 
1447				cp 0 
1447				jr z, .contheap 
1447			 
1447				ld hl, (free_list)     ; get last alloc 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mrs" 
1447						CALLMONITOR 
1447					endif 
1447				jr .startalloc 
1447			 
1447			.contheap: 
1447				ld hl, heap_start 
1447			 
1447			.startalloc: 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mym" 
1447						CALLMONITOR 
1447					endif 
1447			.findblock: 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mmf" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447				ld a,(hl)  
1447				; if byte is zero then clear to use 
1447			 
1447				cp 0 
1447				jr z, .foundemptyblock 
1447			 
1447				; if byte is not clear 
1447				;     then byte is offset to next block 
1447			 
1447				inc hl 
1447				ld a, (hl) ; get size 
1447			.nextblock:	inc hl 
1447					ld e, (hl) 
1447					inc hl 
1447					ld d, (hl) 
1447					ex de, hl 
1447			;	inc hl  ; move past the store space 
1447			;	inc hl  ; move past zero index  
1447			 
1447				; TODO detect no more space 
1447			 
1447				push hl 
1447				ld de, heap_end 
1447				call cmp16 
1447				pop hl 
1447				jr nc, .nospace 
1447			 
1447				jr .findblock 
1447			 
1447			.nospace: ld hl, 0 
1447				jp .exit 
1447			 
1447			 
1447			.foundemptyblock:	 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mme" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			; TODO has block enough space if reusing??? 
1447			 
1447				;  
1447			 
1447			; see if this block has been previously used 
1447				inc hl 
1447				ld a, (hl) 
1447				dec hl 
1447				cp 0 
1447				jr z, .newblock 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "meR" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			; no reusing previously allocated block 
1447			 
1447			; is it smaller than previously used? 
1447				 
1447				inc hl    ; move to size 
1447				ld a, c 
1447				sub (hl)        ; we want c < (hl) 
1447				dec hl    ; move back to marker 
1447			        jr z, .findblock 
1447			 
1447				; update with the new size which should be lower 
1447			 
1447			        ;inc  hl   ; negate next move. move back to size  
1447			 
1447			.newblock: 
1447				; need to be at marker here 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "meN" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			 
1447				ld a, c 
1447			 
1447				ld (free_list+3), a	 ; flag resume from last malloc  
1447				ld (free_list), hl    ; save out last location 
1447			 
1447			 
1447				;inc a     ; space for length byte 
1447				ld (hl), a     ; save block in use marker 
1447			 
1447				inc hl   ; move to space marker 
1447				ld (hl), a    ; save new space 
1447			 
1447				inc hl   ; move to start of allocated area 
1447				 
1447			;	push hl     ; save where we are - 1  
1447			 
1447			;	inc hl  ; move past zero index  
1447				; skip space to set down new marker 
1447			 
1447				; provide some extra space for now 
1447			 
1447				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1447				inc a 
1447				inc a 
1447			 
1447				push hl   ; save where we are in the node block 
1447			 
1447				call addatohl 
1447			 
1447				; write linked list point 
1447			 
1447				pop de     ; get our node position 
1447				ex de, hl 
1447			 
1447				ld (hl), e 
1447				inc hl 
1447				ld (hl), d 
1447			 
1447				inc hl 
1447			 
1447				; now at start of allocated data so save pointer 
1447			 
1447				push hl 
1447			 
1447				; jump to position of next node and setup empty header in DE 
1447			 
1447				ex de, hl 
1447			 
1447			;	inc hl ; move past end of block 
1447			 
1447				ld a, 0 
1447				ld (hl), a   ; empty marker 
1447				inc hl 
1447				ld (hl), a   ; size 
1447				inc hl  
1447				ld (hl), a   ; ptr 
1447				inc hl 
1447				ld (hl), a   ; ptr 
1447			 
1447			 
1447				pop hl 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "mmr" 
1447						CALLMONITOR 
1447					endif 
1447			 
1447			.exit: 
1447				pop af 
1447				pop bc 
1447				pop de  
1447				ret 
1447			 
1447			 
1447			 
1447			 
1447			free:  
1447				push hl 
1447				push af 
1447				; get address in hl 
1447			 
1447					if DEBUG_FORTH_MALLOC_INT 
1447						DMARK "fre" 
1447						CALLMONITOR 
1447					endif 
1447				; data is at hl - move to block count 
1447				dec hl 
1447				dec hl    ; get past pointer 
1447				dec hl 
1447			 
1447				ld a, (hl)    ; need this for a validation check 
1447			 
1447				dec hl    ; move to block marker 
1447			 
1447				; now check that the block count and block marker are the same  
1447			        ; this checks that we are on a malloc node and not random memory 
1447			        ; OK a faint chance this could be a problem but rare - famous last words! 
1447			 
1447				ld c, a 
1447				ld a, (hl)    
1447			 
1447				cp c 
1447				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1447			 
1447				; yes good chance we are on a malloc node 
1447			 
1447				ld a, 0      
1447				ld (hl), a   ; mark as free 
1447			 
1447				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1447			 
1447			.freeignore:  
1447			 
1447				pop af 
1447				pop hl 
1447			 
1447				ret 
1447			 
1447			 
1447			 
1447			endif 
1447			 
1447			; eof 
# End of file firmware_memory.asm
1447			  
1447			; device C  
1447			; Now handled by SPI  
1447			;if SOUND_ENABLE  
1447			;	include "firmware_sound.asm"  
1447			;endif  
1447			  
1447			include "firmware_diags.asm"  
1447			; Hardware diags menu 
1447			 
1447			 
1447			config: 
1447			 
1447 3e 00			ld a, 0 
1449 21 6d 14			ld hl, .configmn 
144c cd eb 0b			call menu 
144f			 
144f fe 00			cp 0 
1451 c8				ret z 
1452			 
1452			;	cp 1 
1452			;	call z, .savetostore 
1452			 
1452 fe 01			cp 1 
1454			if STARTUP_V1 
1454 cc 83 14			call z, .selautoload 
1457			endif 
1457			 
1457			if STARTUP_V2 
1457				call z, .enautoload 
1457			endif 
1457 fe 02			cp 2 
1459 cc 79 14			call z, .disautoload 
145c			;	cp 3 
145c			;	call z, .selbank 
145c fe 03			cp 3 
145e cc a1 14			call z, .debug_tog 
1461 fe 04			cp 4 
1463 cc ef 15			call z, .bpsgo 
1466 fe 05			cp 5 
1468 cc ca 14			call z, hardware_diags 
146b			if STARTUP_V2 
146b				cp 6 
146b				call z, create_startup 
146b			endif 
146b 18 da			jr config 
146d			 
146d			.configmn: 
146d			;	dw prom_c3 
146d dd 17			dw prom_c2 
146f f2 17			dw prom_c2a 
1471			;	dw prom_c2b 
1471			;	dw prom_c4 
1471 11 18			dw prom_m4 
1473 2c 18			dw prom_m4b 
1475 34 18			dw prom_c1 
1477			if STARTUP_V2 
1477				dw prom_c9 
1477			endif 
1477 00 00			dw 0 
1479				 
1479			 
1479			if STARTUP_V2 
1479			.enautoload: 
1479				if STORAGE_SE 
1479				ld a, $fe      ; bit 0 clear 
1479				ld (spi_device), a 
1479			 
1479				call storage_get_block_0 
1479			 
1479				ld a, 1 
1479				ld (store_page+STORE_0_AUTOFILE), a 
1479			 
1479					ld hl, 0 
1479					ld de, store_page 
1479				call storage_write_block	 ; save update 
1479				else 
1479			 
1479				ld hl, prom_notav 
1479				ld de, prom_empty 
1479				call info_panel 
1479				endif 
1479			 
1479			 
1479				ret 
1479			endif 
1479			 
1479			.disautoload: 
1479				if STORAGE_SE 
1479				ld a, $fe      ; bit 0 clear 
1479				ld (spi_device), a 
1479			 
1479				call storage_get_block_0 
1479			 
1479				ld a, 0 
1479				ld (store_page+STORE_0_AUTOFILE), a 
1479			 
1479					ld hl, 0 
1479					ld de, store_page 
1479				call storage_write_block	 ; save update 
1479				else 
1479			 
1479 21 43 18			ld hl, prom_notav 
147c 11 59 18			ld de, prom_empty 
147f cd 4b 0b			call info_panel 
1482				endif 
1482			 
1482			 
1482 c9				ret 
1483			 
1483			if STARTUP_V1 
1483			 
1483			; Select auto start 
1483			 
1483			.selautoload: 
1483			 
1483				 
1483				if STORAGE_SE 
1483			 
1483					call config_dir 
1483				        ld hl, scratch 
1483					ld a, 0 
1483					call menu 
1483			 
1483					cp 0 
1483					ret z 
1483			 
1483					dec a 
1483			 
1483			 
1483					; locate menu option 
1483			 
1483					ld hl, scratch 
1483					call table_lookup 
1483			 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "ALl" 
1483						CALLMONITOR 
1483					endif 
1483					; with the pointer to the menu it, the byte following the zero term is the file id 
1483			 
1483					ld a, 0 
1483					ld bc, 50   ; max of bytes to look at 
1483					cpir  
1483			 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "ALb" 
1483						CALLMONITOR 
1483					endif 
1483					;inc hl 
1483			 
1483					ld a, (hl)   ; file id 
1483					 
1483				        ; save bank and file ids 
1483			 
1483					push af 
1483			 
1483			; TODO need to save to block 0 on bank 1	 
1483			 
1483					call storage_get_block_0 
1483			 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "AL0" 
1483						CALLMONITOR 
1483					endif 
1483					pop af 
1483			 
1483					ld (store_page+STORE_0_FILERUN),a 
1483					 
1483					; save bank id 
1483			 
1483					ld a,(spi_device) 
1483					ld (store_page+STORE_0_BANKRUN),a 
1483			 
1483					; enable auto run of store file 
1483			 
1483					ld a, 1 
1483					ld (store_page+STORE_0_AUTOFILE),a 
1483			 
1483					; save buffer 
1483			 
1483					ld hl, 0 
1483					ld de, store_page 
1483					if DEBUG_FORTH_WORDS 
1483						DMARK "ALw" 
1483						CALLMONITOR 
1483					endif 
1483				call storage_write_block	 ; save update 
1483			  
1483			 
1483			 
1483			 
1483					ld hl, scratch 
1483					call config_fdir 
1483			 
1483				else 
1483			 
1483 21 43 18			ld hl, prom_notav 
1486 11 59 18			ld de, prom_empty 
1489 cd 4b 0b			call info_panel 
148c			 
148c				endif 
148c c9				ret 
148d			endif 
148d			 
148d			 
148d			; Select storage bank 
148d			 
148d			.selbank: 
148d			 
148d			;	if STORAGE_SE 
148d			;	else 
148d			 
148d 21 43 18			ld hl, prom_notav 
1490 11 59 18			ld de, prom_empty 
1493 cd 4b 0b			call info_panel 
1496			;	endif 
1496				 
1496 c9				ret 
1497			 
1497			if STORAGE_SE 
1497			 
1497			.config_ldir:   
1497				; Load storage bank labels into menu array 
1497			 
1497				 
1497			 
1497			 
1497				ret 
1497			 
1497			 
1497			endif 
1497			 
1497			 
1497			; Save user words to storage 
1497			 
1497			.savetostore: 
1497			 
1497			;	if STORAGE_SE 
1497			; 
1497			;		call config_dir 
1497			;	        ld hl, scratch 
1497			;		ld a, 0 
1497			;		call menu 
1497			;		 
1497			;		ld hl, scratch 
1497			;		call config_fdir 
1497			; 
1497			;	else 
1497			 
1497 21 43 18			ld hl, prom_notav 
149a 11 59 18			ld de, prom_empty 
149d cd 4b 0b			call info_panel 
14a0			 
14a0			;	endif 
14a0			 
14a0 c9				ret 
14a1			 
14a1			if STARTUP_V2 
14a1			 
14a1			create_startup: 
14a1			 
14a1				ld a, 0 
14a1				ld hl, .crstart 
14a1				call menu 
14a1			 
14a1				cp 0 
14a1				ret z 
14a1			 
14a1				cp 1 
14a1				call z, .genlsword 
14a1				cp 2 
14a1				call z, .genedword 
14a1			 
14a1				cp 3 
14a1				call z, .gendemword 
14a1			 
14a1				cp 4 
14a1				call z, .genutlword 
14a1				cp 5 
14a1				call z, .genspiword 
14a1				cp 6 
14a1				call z, .genkeyword 
14a1				cp 7 
14a1				call z, .gensoundword 
14a1				jr create_startup 
14a1			 
14a1			.gensoundword: 
14a1				ld hl, crs_sound 
14a1				ld de, .soundworddef 
14a1				call .genfile 
14a1				ret 
14a1			.genlsword: 
14a1				ld hl, crs_s1 
14a1				ld de, .lsworddef 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			.genedword: 
14a1				ld de, .edworddef 
14a1				ld hl, crs_s2 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			.gendemword: 
14a1				ld de, .demoworddef 
14a1				ld hl, crs_s3 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			.genutlword: 
14a1				ld hl, crs_s4 
14a1				ld de, .utilwordef 
14a1				call .genfile 
14a1				ret 
14a1			.genspiword: 
14a1				ld hl, crs_s5 
14a1				ld de, .spiworddef 
14a1				call .genfile 
14a1				ret 
14a1			.genkeyword: 
14a1				ld hl, crs_s6 
14a1				ld de, .keyworddef 
14a1				call .genfile 
14a1				ret 
14a1			 
14a1			; hl - points to file name 
14a1			; de - points to strings to add to file 
14a1			 
14a1			.genfile: 
14a1				push hl 
14a1				push de 
14a1			 
14a1				call clear_display 
14a1				ld a, display_row_1 
14a1				ld de, .genfiletxt 
14a1				call str_at_display 
14a1				call update_display 
14a1			 
14a1				pop de 
14a1				pop hl 
14a1			 
14a1			 
14a1				push de 
14a1				call storage_create 
14a1				; id in hl 
14a1				pop de   ; table of strings to add 
14a1			 
14a1			.genloop: 
14a1			 
14a1				push hl ; save id for next time around 
14a1				push de ; save de for next time around 
14a1			 
14a1				ex de, hl 
14a1				call loadwordinhl 
14a1				ex de, hl 
14a1			 
14a1				; need hl to be the id 
14a1				; need de to be the string ptr 
14a1				 
14a1				call storage_append 
14a1			 
14a1				pop de 
14a1				pop hl 
14a1			 
14a1				inc de 
14a1				inc de 
14a1			 
14a1				ld a,(de) 
14a1				cp 0 
14a1				jr nz, .genloop 
14a1				inc de 
14a1				ld a, (de) 
14a1				dec de 
14a1				cp 0 
14a1				jr nz, .genloop	 
14a1			 
14a1				ret 
14a1			 
14a1			.genfiletxt:  db "Creating file...",0 
14a1			 
14a1			.soundworddef: 
14a1				dw sound1 
14a1				dw sound2 
14a1				dw sound3 
14a1				dw sound4 
14a1				dw sound5 
14a1				dw sound6 
14a1				dw sound7 
14a1				dw sound8 
14a1				dw sound9 
14a1				dw 0 
14a1			 
14a1			.utilwordef: 
14a1				dw strncpy 
14a1				dw type 
14a1				dw clrstack 
14a1				dw longread 
14a1				dw start1 
14a1				dw start2 
14a1				dw start3b 
14a1				dw start3c 
14a1				dw list 
14a1				dw 0 
14a1			 
14a1			.lsworddef: 
14a1				dw start3b 
14a1				dw 0 
14a1			 
14a1			.edworddef: 
14a1				dw edit1 
14a1				dw edit2 
14a1				dw edit3 
14a1				dw 0 
14a1			 
14a1			.demoworddef: 
14a1				dw test5 
14a1				dw test6 
14a1				dw test7 
14a1				dw test8 
14a1				dw test9 
14a1				dw test10 
14a1				dw game1 
14a1				dw game1a 
14a1				dw game1b 
14a1				dw game1c 
14a1				dw game1d 
14a1				dw game1s 
14a1				dw game1t 
14a1				dw game1f 
14a1				dw game1z 
14a1				dw game1zz 
14a1				dw ssv2 
14a1				dw ssv3 
14a1				dw ssv4 
14a1				dw ssv5 
14a1				dw ssv1 
14a1				dw ssv1cpm	 
14a1				dw game2b 
14a1				dw game2bf 
14a1				dw game2mba 
14a1				dw game2mbas	 
14a1				dw game2mbht 
14a1				dw game2mbms 
14a1				dw game2mb 
14a1				dw game3w 
14a1				dw game3p 
14a1				dw game3sc 
14a1				dw game3vsi 
14a1				dw game3vs 
14a1				dw 0 
14a1			 
14a1			 
14a1			.spiworddef: 
14a1			 
14a1			    dw spi1 
14a1			    dw spi2 
14a1			    dw spi3 
14a1			    dw spi4 
14a1			    dw spi5 
14a1			    dw spi6 
14a1			    dw spi7 
14a1			 
14a1			    dw spi8 
14a1			    dw spi9 
14a1			    dw spi10 
14a1			    dw 0 
14a1			 
14a1			.keyworddef: 
14a1			 
14a1				dw keyup 
14a1				dw keydown 
14a1				dw keyleft 
14a1				dw keyright 
14a1				dw 	keyf1 
14a1				dw keyf2 
14a1				dw keyf3 
14a1				dw keyf4 
14a1				dw keyf5 
14a1				dw keyf6 
14a1				dw keyf7 
14a1				dw keyf8 
14a1				dw keyf9 
14a1				dw keyf10 
14a1				dw keyf11 
14a1				dw keyf12 
14a1				dw keytab 
14a1				dw keycr 
14a1				dw keyhome 
14a1				dw keyend 
14a1				dw keybs 
14a1				dw 0 
14a1			 
14a1			.crstart: 
14a1				dw crs_s1 
14a1				dw crs_s2 
14a1				dw crs_s3 
14a1				dw crs_s4 
14a1				dw crs_s5 
14a1				dw crs_s6 
14a1				dw crs_sound 
14a1				dw 0 
14a1			 
14a1			endif 
14a1			 
14a1			 
14a1			if STORAGE_SE 
14a1			 
14a1			config_fdir: 
14a1				; using the scratch dir go through and release the memory allocated for each string 
14a1				 
14a1				ld hl, scratch 
14a1			.cfdir:	ld e,(hl) 
14a1				inc hl 
14a1				ld d,(hl) 
14a1				inc hl 
14a1			 
14a1				ex de, hl 
14a1				call ishlzero 
14a1				ret z     ; return on null pointer 
14a1				call free 
14a1				ex de, hl 
14a1				jr .cfdir 
14a1			 
14a1			 
14a1				ret 
14a1			 
14a1			 
14a1			config_dir: 
14a1			 
14a1				; for the config menus that need to build a directory of storage call this routine 
14a1				; it will construct a menu in scratch to pass to menu 
14a1			 
14a1				; open storage device 
14a1			 
14a1				; execute DIR to build a list of files and their ids into scratch in menu format 
14a1				; once the menu has finished then will need to call config_fdir to release the strings 
14a1				 
14a1				; c = number items 
14a1			 
14a1				 
14a1				call storage_get_block_0 
14a1			 
14a1				ld hl, store_page     ; get current id count 
14a1				ld b, (hl) 
14a1				ld c, 0    ; count of files   
14a1			 
14a1			 
14a1				ld hl, scratch 
14a1				ld (store_tmp2), hl    ; location to poke strings 
14a1			 
14a1				; check for empty drive 
14a1			 
14a1				ld a, 0 
14a1				cp b 
14a1				jp z, .dirdone 
14a1			 
14a1				 
14a1					if DEBUG_FORTH_WORDS 
14a1						DMARK "Cdc" 
14a1						CALLMONITOR 
14a1					endif 
14a1			 
14a1			 
14a1			.diritem:	 
14a1				push bc 
14a1				; for each of the current ids do a search for them and if found push to stack 
14a1			 
14a1					ld hl, STORE_BLOCK_PHY 
14a1					ld d, 0		 ; look for extent 0 of block id as this contains file name 
14a1					ld e,b 
14a1			 
14a1					call storage_findnextid 
14a1			 
14a1			 
14a1					; if found hl will be non zero 
14a1			 
14a1					call ishlzero 
14a1					jr z, .dirnotfound 
14a1			 
14a1					; increase count 
14a1			 
14a1					pop bc	 
14a1					inc c 
14a1					push bc 
14a1					 
14a1			 
14a1					; get file header and push the file name 
14a1			 
14a1					ld de, store_page 
14a1					call storage_read_block 
14a1			 
14a1					; push file id to stack 
14a1				 
14a1					ld a, (store_page) 
14a1					ld h, 0 
14a1					ld l, a 
14a1			 
14a1					;call forth_push_numhl 
14a1					; TODO store id 
14a1			 
14a1					push hl 
14a1			 
14a1					; push extent count to stack  
14a1				 
14a1					ld hl, store_page+3 
14a1			 
14a1					; get file name length 
14a1			 
14a1					call strlenz   
14a1			 
14a1					inc hl   ; cover zero term 
14a1					inc hl  ; stick the id at the end of the area 
14a1			 
14a1					push hl 
14a1					pop bc    ; move length to bc 
14a1			 
14a1					call malloc 
14a1			 
14a1					; TODO save malloc area to scratch 
14a1			 
14a1					ex de, hl 
14a1					ld hl, (store_tmp2) 
14a1					ld (hl), e 
14a1					inc hl 
14a1					ld (hl), d 
14a1					inc hl 
14a1					ld (store_tmp2), hl 
14a1			 
14a1					 
14a1			 
14a1					;pop hl   ; get source 
14a1			;		ex de, hl    ; swap aronund	 
14a1			 
14a1					ld hl, store_page+3 
14a1					if DEBUG_FORTH_WORDS 
14a1						DMARK "CFd" 
14a1						CALLMONITOR 
14a1					endif 
14a1					ldir 
14a1			 
14a1					; de is past string, move back one and store id 
14a1					 
14a1					dec de 
14a1			 
14a1					; store file id 
14a1			 
14a1					pop hl 
14a1					ex de,hl 
14a1					ld (hl), e 
14a1			 
14a1					if DEBUG_FORTH_WORDS 
14a1						DMARK "Cdi" 
14a1						CALLMONITOR 
14a1					endif 
14a1					 
14a1			.dirnotfound: 
14a1					pop bc     
14a1					djnz .diritem 
14a1				 
14a1			.dirdone:	 
14a1			 
14a1					ld a, 0 
14a1					ld hl, (store_tmp2) 
14a1					ld (hl), a 
14a1					inc hl 
14a1					ld (hl), a 
14a1					inc hl 
14a1					; push a count of the dir items found 
14a1			 
14a1			;		ld h, 0 
14a1			;		ld l, c 
14a1			 
14a1				ret 
14a1			 
14a1			endif 
14a1			 
14a1			 
14a1			; Settings 
14a1			; Run  
14a1			 
14a1			 
14a1			 
14a1			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
14a1			;;hd_menu2:   db "        2: Editor",0   
14a1			;hd_menu2:   db "        2: Editor       6: Menu",0   
14a1			;hd_menu3:   db "        3: Storage",0 
14a1			;hd_menu4:   db "0=quit  4: Debug",0 
14a1			;hd_don:     db "ON",0 
14a1			;hd_doff:     db "OFF",0 
14a1			; 
14a1			; 
14a1			; 
14a1			;hardware_diags_old:       
14a1			; 
14a1			;.diagmenu: 
14a1			;	call clear_display 
14a1			;	ld a, display_row_1 
14a1			;	ld de, hd_menu1 
14a1			;	call str_at_display 
14a1			; 
14a1			;	ld a, display_row_2 
14a1			;	ld de, hd_menu2 
14a1			;	call str_at_display 
14a1			; 
14a1			;	ld a, display_row_3 
14a1			;	ld de, hd_menu3 
14a1			;	call str_at_display 
14a1			; 
14a1			;	ld a,  display_row_4 
14a1			;	ld de, hd_menu4 
14a1			;	call str_at_display 
14a1			; 
14a1			;	; display debug state 
14a1			; 
14a1			;	ld de, hd_don 
14a1			;	ld a, (os_view_disable) 
14a1			;	cp 0 
14a1			;	jr z, .distog 
14a1			;	ld de, hd_doff 
14a1			;.distog: ld a, display_row_4+17 
14a1			;	call str_at_display 
14a1			; 
14a1			;	call update_display 
14a1			; 
14a1			;	call cin_wait 
14a1			; 
14a1			; 
14a1			; 
14a1			;	cp '4' 
14a1			;	jr nz, .diagn1 
14a1			; 
14a1			;	; debug toggle 
14a1			; 
14a1			;	ld a, (os_view_disable) 
14a1			;	ld b, '*' 
14a1			;	cp 0 
14a1			;	jr z, .debtog 
14a1			;	ld b, 0 
14a1			;.debtog:	 
14a1			;	ld a,b 
14a1			;	ld (os_view_disable),a 
14a1			; 
14a1			;.diagn1: cp '0' 
14a1			;	 ret z 
14a1			; 
14a1			;;	cp '1' 
14a1			;;       jp z, matrix	 
14a1			;;   TODO keyboard matrix test 
14a1			; 
14a1			;	cp '2' 
14a1			;	jp z, .diagedit 
14a1			; 
14a1			;;	cp '6' 
14a1			;;	jp z, .menutest 
14a1			;;if ENABLE_BASIC 
14a1			;;	cp '6' 
14a1			;;	jp z, basic 
14a1			;;endif 
14a1			 ; 
14a1			;	jp .diagmenu 
14a1			; 
14a1			; 
14a1			;	ret 
14a1			 
14a1			 
14a1			.debug_tog: 
14a1 21 eb 14			ld hl, .menudebug 
14a4				 
14a4			;	ld a, (os_view_disable) 
14a4			;	cp '*' 
14a4 3a 6f ee			ld a,(debug_vector) 
14a7 fe c9			cp $C9   ; RET 
14a9 20 04			jr nz,.tdon  
14ab 3e 01			ld a, 1 
14ad 18 02			jr .tog1 
14af 3e 00		.tdon: ld a, 0 
14b1			 
14b1			.tog1: 
14b1 cd eb 0b			call menu 
14b4 fe 00			cp 0 
14b6 c8				ret z 
14b7 fe 01			cp 1    ; disable debug 
14b9 28 04			jr z, .dtog0 
14bb 3e 2a			ld a, '*' 
14bd 18 05			jr .dtogset 
14bf			.dtog0:  
14bf				;ld a, 0 
14bf cd dd 15			call bp_on 
14c2 18 dd			jr .debug_tog 
14c4			.dtogset:  
14c4				; ld (os_view_disable), a 
14c4 cd e9 15			call bp_off 
14c7 c3 a1 14			jp .debug_tog 
14ca			 
14ca			 
14ca			hardware_diags:       
14ca			 
14ca			.diagm: 
14ca 21 dd 14			ld hl, .menuitems 
14cd 3e 00			ld a, 0 
14cf cd eb 0b			call menu 
14d2			 
14d2 fe 00		         cp 0 
14d4 c8				 ret z 
14d5			 
14d5 fe 02			cp 2 
14d7 ca 36 15			jp z, .diagedit 
14da			 
14da			;	cp '6' 
14da			;	jp z, .menutest 
14da			;if ENABLE_BASIC 
14da			;	cp '6' 
14da			;	jp z, basic 
14da			;endif 
14da			  
14da c3 ca 14			jp .diagm 
14dd			 
14dd				 
14dd f1 14		.menuitems:   	dw .m1 
14df fc 14				dw .m2 
14e1 03 15				dw .m3 
14e3 0b 15				dw .m5 
14e5 11 15				dw .m5a 
14e7 1a 15				dw .m5b 
14e9 00 00				dw 0 
14eb			 
14eb			.menudebug: 
14eb 23 15				dw .m6 
14ed 2c 15				dw .m7 
14ef 00 00				dw 0 
14f1			 
14f1 .. 00		.m1:   db "Key Matrix",0 
14fc .. 00		.m2:   db "Editor",0 
1503 .. 00		.m3:   db "Storage",0 
150b .. 00		.m5:   db "Sound",0 
1511 .. 00		.m5a:  db "RAM Test",0 
151a .. 00		.m5b:  db "LCD Test",0 
1523			 
1523 .. 00		.m6:   db "Debug ON",0 
152c .. 00		.m7:   db "Debug OFF",0 
1536			 
1536			; debug editor 
1536			 
1536			.diagedit: 
1536			 
1536 21 c1 e2			ld hl, scratch 
1539			;	ld bc, 250 
1539			;	ldir 
1539				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1539 3e 00			ld a, 0 
153b 77				ld (hl), a 
153c 23				inc hl 
153d 77				ld (hl), a 
153e 23				inc hl 
153f 77				ld (hl), a 
1540			 
1540 cd ba 0b		        call clear_display 
1543 cd dd 0b			call update_display 
1546				;ld a, 1 
1546				;ld (hardware_diag), a 
1546			.diloop: 
1546 3e 00			ld a, display_row_1 
1548 0e 00			ld c, 0 
154a 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
154c 1e 28			ld e, 40 
154e			 
154e 21 c1 e2			ld hl, scratch	 
1551 cd 14 0e			call input_str 
1554			 
1554 3e 28			ld a, display_row_2 
1556 11 c1 e2			ld de, scratch 
1559 cd cd 0b			call str_at_display 
155c cd dd 0b			call update_display 
155f			 
155f c3 46 15			jp .diloop 
1562			 
1562			 
1562			; pass word in hl 
1562			; a has display location 
1562			display_word_at: 
1562 f5				push af 
1563 e5				push hl 
1564 7c				ld a,h 
1565 21 c6 e5			ld hl, os_word_scratch 
1568 cd e8 10			call hexout 
156b e1				pop hl 
156c 7d				ld a,l 
156d 21 c8 e5			ld hl, os_word_scratch+2 
1570 cd e8 10			call hexout 
1573 21 ca e5			ld hl, os_word_scratch+4 
1576 3e 00			ld a,0 
1578 77				ld (hl),a 
1579 11 c6 e5			ld de,os_word_scratch 
157c f1				pop af 
157d cd cd 0b				call str_at_display 
1580 c9				ret 
1581			 
1581			display_ptr_state: 
1581			 
1581				; to restore afterwards 
1581			 
1581 d5				push de 
1582 c5				push bc 
1583 e5				push hl 
1584 f5				push af 
1585			 
1585				; for use in here 
1585			 
1585			;	push bc 
1585			;	push de 
1585			;	push hl 
1585			;	push af 
1585			 
1585 cd ba 0b			call clear_display 
1588			 
1588 11 60 17			ld de, .ptrstate 
158b 3e 00			ld a, display_row_1 
158d cd cd 0b			call str_at_display 
1590			 
1590				; display debug step 
1590			 
1590			 
1590 11 6b ee			ld de, debug_mark 
1593 3e 26			ld a, display_row_1+display_cols-2 
1595 cd cd 0b			call str_at_display 
1598			 
1598				; display a 
1598 11 6a 17			ld de, .ptrcliptr 
159b 3e 28			ld a, display_row_2 
159d cd cd 0b			call str_at_display 
15a0			 
15a0 f1				pop af 
15a1 2a 40 ea			ld hl,(cli_ptr) 
15a4 3e 30			ld a, display_row_2+8 
15a6 cd 62 15			call display_word_at 
15a9			 
15a9			 
15a9				; display hl 
15a9			 
15a9			 
15a9 11 72 17			ld de, .ptrclioptr 
15ac 3e 32			ld a, display_row_2+10 
15ae cd cd 0b			call str_at_display 
15b1			; 
15b1			;	pop hl 
15b1 3e 35			ld a, display_row_2+13 
15b3 2a 3e ea			ld hl,(cli_origptr) 
15b6 cd 62 15			call display_word_at 
15b9			; 
15b9			;	 
15b9			;	; display de 
15b9			 
15b9			;	ld de, .regstatede 
15b9			;	ld a, display_row_3 
15b9			;	call str_at_display 
15b9			 
15b9			;	pop de 
15b9			;	ld h,d 
15b9			;	ld l, e 
15b9			;	ld a, display_row_3+3 
15b9			;	call display_word_at 
15b9			 
15b9			 
15b9				; display bc 
15b9			 
15b9			;	ld de, .regstatebc 
15b9			;	ld a, display_row_3+10 
15b9			;	call str_at_display 
15b9			 
15b9			;	pop bc 
15b9			;	ld h,b 
15b9			;	ld l, c 
15b9			;	ld a, display_row_3+13 
15b9			;	call display_word_at 
15b9			 
15b9			 
15b9				; display dsp 
15b9			 
15b9			;	ld de, .regstatedsp 
15b9			;	ld a, display_row_4 
15b9			;	call str_at_display 
15b9			 
15b9				 
15b9			;	ld hl,(cli_data_sp) 
15b9			;	ld a, display_row_4+4 
15b9			;	call display_word_at 
15b9			 
15b9				; display rsp 
15b9			 
15b9 11 a1 17			ld de, .regstatersp 
15bc 3e 82			ld a, display_row_4+10 
15be cd cd 0b			call str_at_display 
15c1			 
15c1				 
15c1 2a f2 e9			ld hl,(cli_ret_sp) 
15c4 3e 86			ld a, display_row_4+14 
15c6 cd 62 15			call display_word_at 
15c9			 
15c9 cd dd 0b			call update_display 
15cc			 
15cc cd f2 0a			call delay1s 
15cf cd f2 0a			call delay1s 
15d2 cd f2 0a			call delay1s 
15d5			 
15d5			 
15d5 cd ce 1b			call next_page_prompt 
15d8			 
15d8				; restore  
15d8			 
15d8 f1				pop af 
15d9 e1				pop hl 
15da c1				pop bc 
15db d1				pop de 
15dc c9				ret 
15dd			 
15dd			; Update the break point vector so that the user can hook a new routine 
15dd			 
15dd			bp_on: 
15dd 3e c3			ld a, $c3    ; JP 
15df 32 6f ee			ld (debug_vector), a 
15e2 21 ef 15			ld hl, break_point_state 
15e5 22 70 ee			ld (debug_vector+1), hl 
15e8 c9				ret 
15e9			 
15e9			bp_off: 
15e9 3e c9			ld a, $c9    ; RET 
15eb 32 6f ee			ld (debug_vector), a 
15ee c9				ret 
15ef			 
15ef			 
15ef			break_point_state: 
15ef			;	push af 
15ef			; 
15ef			;	; see if disabled 
15ef			; 
15ef			;	ld a, (os_view_disable) 
15ef			;	cp '*' 
15ef			;	jr nz, .bpsgo 
15ef			;	pop af 
15ef			;	ret 
15ef			 
15ef			.bpsgo: 
15ef			;	pop af 
15ef f5				push af 
15f0 22 af e2			ld (os_view_hl), hl 
15f3 ed 53 ad e2		ld (os_view_de), de 
15f7 ed 43 ab e2		ld (os_view_bc), bc 
15fb e5				push hl 
15fc 6f				ld l, a 
15fd 26 00			ld h, 0 
15ff 22 b1 e2			ld (os_view_af),hl 
1602			 
1602 21 b1 ed				ld hl, display_fb0 
1605 22 cc eb				ld (display_fb_active), hl 
1608 e1				pop hl	 
1609			 
1609 3e 31			ld a, '1' 
160b fe 2a		.bps1:  cp '*' 
160d cc e9 15			call z, bp_off 
1610			;	jr nz, .bps1b 
1610			;	ld (os_view_disable),a 
1610 fe 31		.bps1b:  cp '1' 
1612 20 14			jr nz, .bps2 
1614			 
1614				; display reg 
1614			 
1614				 
1614			 
1614 3a b1 e2			ld a, (os_view_af) 
1617 2a af e2			ld hl, (os_view_hl) 
161a ed 5b ad e2		ld de, (os_view_de) 
161e ed 4b ab e2		ld bc, (os_view_bc) 
1622 cd bc 16			call display_reg_state 
1625 c3 a8 16			jp .bpschk 
1628			 
1628 fe 32		.bps2:  cp '2' 
162a 20 08			jr nz, .bps3 
162c				 
162c				; display hl 
162c 2a af e2			ld hl, (os_view_hl) 
162f cd a6 17			call display_dump_at_hl 
1632			 
1632 18 74			jr .bpschk 
1634			 
1634 fe 33		.bps3:  cp '3' 
1636 20 08			jr nz, .bps4 
1638			 
1638			        ; display de 
1638 2a ad e2			ld hl, (os_view_de) 
163b cd a6 17			call display_dump_at_hl 
163e			 
163e 18 68			jr .bpschk 
1640 fe 34		.bps4:  cp '4' 
1642 20 08			jr nz, .bps5 
1644			 
1644			        ; display bc 
1644 2a ab e2			ld hl, (os_view_bc) 
1647 cd a6 17			call display_dump_at_hl 
164a			 
164a 18 5c			jr .bpschk 
164c fe 35		.bps5:  cp '5' 
164e 20 08		        jr nz, .bps7 
1650			 
1650				; display cur ptr 
1650 2a 40 ea			ld hl, (cli_ptr) 
1653 cd a6 17			call display_dump_at_hl 
1656			 
1656 18 50			jr .bpschk 
1658 fe 36		.bps7:  cp '6' 
165a 20 08			jr nz, .bps8b 
165c				 
165c				; display cur orig ptr 
165c 2a 3e ea			ld hl, (cli_origptr) 
165f cd a6 17			call display_dump_at_hl 
1662 18 44			jr .bpschk 
1664 fe 37		.bps8b:  cp '7' 
1666 20 08			jr nz, .bps9 
1668				 
1668				; display dsp 
1668 2a ee e9			ld hl, (cli_data_sp) 
166b cd a6 17			call display_dump_at_hl 
166e			 
166e 18 38			jr .bpschk 
1670 fe 39		.bps9:  cp '9' 
1672 20 05			jr nz, .bps8c 
1674				 
1674				; display SP 
1674			;	ld hl, sp 
1674 cd a6 17			call display_dump_at_hl 
1677			 
1677 18 2f			jr .bpschk 
1679 fe 38		.bps8c:  cp '8' 
167b 20 08			jr nz, .bps8d 
167d				 
167d				; display rsp 
167d 2a f2 e9			ld hl, (cli_ret_sp) 
1680 cd a6 17			call display_dump_at_hl 
1683			 
1683 18 23			jr .bpschk 
1685 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1687 20 05			jr nz, .bps8 
1689 cd 9c 19			call monitor 
168c			 
168c 18 1a			jr .bpschk 
168e fe 30		.bps8:  cp '0' 
1690 20 16			jr nz, .bpschk 
1692			 
1692 21 10 ed				ld hl, display_fb1 
1695 22 cc eb				ld (display_fb_active), hl 
1698 cd dd 0b				call update_display 
169b			 
169b				;ld a, (os_view_af) 
169b 2a af e2			ld hl, (os_view_hl) 
169e ed 5b ad e2		ld de, (os_view_de) 
16a2 ed 4b ab e2		ld bc, (os_view_bc) 
16a6 f1				pop af 
16a7 c9				ret 
16a8			 
16a8			.bpschk:   
16a8 cd f2 0a			call delay1s 
16ab 3e 9f		ld a,display_row_4 + display_cols - 1 
16ad 11 cc 1b		        ld de, endprg 
16b0 cd cd 0b			call str_at_display 
16b3 cd dd 0b			call update_display 
16b6 cd 7f 65			call cin_wait 
16b9			 
16b9 c3 0b 16			jp .bps1 
16bc			 
16bc			 
16bc			display_reg_state: 
16bc			 
16bc				; to restore afterwards 
16bc			 
16bc d5				push de 
16bd c5				push bc 
16be e5				push hl 
16bf f5				push af 
16c0			 
16c0				; for use in here 
16c0			 
16c0 c5				push bc 
16c1 d5				push de 
16c2 e5				push hl 
16c3 f5				push af 
16c4			 
16c4 cd ba 0b			call clear_display 
16c7			 
16c7 11 7c 17			ld de, .regstate 
16ca 3e 00			ld a, display_row_1 
16cc cd cd 0b			call str_at_display 
16cf			 
16cf				; display debug step 
16cf			 
16cf			 
16cf 11 6b ee			ld de, debug_mark 
16d2 3e 25			ld a, display_row_1+display_cols-3 
16d4 cd cd 0b			call str_at_display 
16d7			 
16d7				; display a 
16d7 11 98 17			ld de, .regstatea 
16da 3e 28			ld a, display_row_2 
16dc cd cd 0b			call str_at_display 
16df			 
16df e1				pop hl 
16e0			;	ld h,0 
16e0			;	ld l, a 
16e0 3e 2b			ld a, display_row_2+3 
16e2 cd 62 15			call display_word_at 
16e5			 
16e5			 
16e5				; display hl 
16e5			 
16e5			 
16e5 11 8c 17			ld de, .regstatehl 
16e8 3e 32			ld a, display_row_2+10 
16ea cd cd 0b			call str_at_display 
16ed			 
16ed e1				pop hl 
16ee 3e 35			ld a, display_row_2+13 
16f0 cd 62 15			call display_word_at 
16f3			 
16f3				 
16f3				; display de 
16f3			 
16f3 11 90 17			ld de, .regstatede 
16f6 3e 50			ld a, display_row_3 
16f8 cd cd 0b			call str_at_display 
16fb			 
16fb e1				pop hl 
16fc			;	ld h,d 
16fc			;	ld l, e 
16fc 3e 53			ld a, display_row_3+3 
16fe cd 62 15			call display_word_at 
1701			 
1701			 
1701				; display bc 
1701			 
1701 11 94 17			ld de, .regstatebc 
1704 3e 5a			ld a, display_row_3+10 
1706 cd cd 0b			call str_at_display 
1709			 
1709 e1				pop hl 
170a			;	ld h,b 
170a			;	ld l, c 
170a 3e 5d			ld a, display_row_3+13 
170c cd 62 15			call display_word_at 
170f			 
170f			 
170f				; display dsp 
170f			 
170f 11 9c 17			ld de, .regstatedsp 
1712 3e 78			ld a, display_row_4 
1714 cd cd 0b			call str_at_display 
1717			 
1717				 
1717 2a ee e9			ld hl,(cli_data_sp) 
171a 3e 7c			ld a, display_row_4+4 
171c cd 62 15			call display_word_at 
171f			 
171f				; display rsp 
171f			 
171f 11 a1 17			ld de, .regstatersp 
1722 3e 82			ld a, display_row_4+10 
1724 cd cd 0b			call str_at_display 
1727			 
1727				 
1727 2a f2 e9			ld hl,(cli_ret_sp) 
172a 3e 86			ld a, display_row_4+14 
172c cd 62 15			call display_word_at 
172f			 
172f cd dd 0b			call update_display 
1732			 
1732			;	call delay1s 
1732			;	call delay1s 
1732			;	call delay1s 
1732			 
1732			 
1732			;	call next_page_prompt 
1732			 
1732				; restore  
1732			 
1732 f1				pop af 
1733 e1				pop hl 
1734 c1				pop bc 
1735 d1				pop de 
1736 c9				ret 
1737			 
1737 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
174b .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1760 .. 00		.ptrstate:	db "Ptr State",0 
176a .. 00		.ptrcliptr:     db "cli_ptr",0 
1772 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
177c .. 00		.regstate:	db "Reg State (1/0)",0 
178c .. 00		.regstatehl:	db "HL:",0 
1790 .. 00		.regstatede:	db "DE:",0 
1794 .. 00		.regstatebc:	db "BC:",0 
1798 .. 00		.regstatea:	db "A :",0 
179c .. 00		.regstatedsp:	db "DSP:",0 
17a1 .. 00		.regstatersp:	db "RSP:",0 
17a6			 
17a6			display_dump_at_hl: 
17a6 e5				push hl 
17a7 d5				push de 
17a8 c5				push bc 
17a9 f5				push af 
17aa			 
17aa 22 e4 e5			ld (os_cur_ptr),hl	 
17ad cd ba 0b			call clear_display 
17b0 cd d6 1a			call dumpcont 
17b3			;	call delay1s 
17b3			;	call next_page_prompt 
17b3			 
17b3			 
17b3 f1				pop af 
17b4 c1				pop bc 
17b5 d1				pop de 
17b6 e1				pop hl 
17b7 c9				ret 
17b8			 
17b8			;if ENABLE_BASIC 
17b8			;	include "nascombasic.asm" 
17b8			;	basic: 
17b8			;	include "forth/FORTH.ASM" 
17b8			;endif 
17b8			 
17b8			; eof 
17b8			 
17b8			 
# End of file firmware_diags.asm
17b8			  
17b8			include "firmware_prompts.asm"  
17b8			; Prompts  
17b8			 
17b8			; boot messages 
17b8			 
17b8 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
17cd .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
17dd			 
17dd			 
17dd			; config menus 
17dd			 
17dd			;prom_c3: db "Add Dictionary To File",0 
17dd			 
17dd			if STARTUP_V1 
17dd .. 00		prom_c2: db "Select Autoload File",0 
17f2 .. 00		prom_c2a: db "Disable Autoload File", 0 
1808			endif 
1808			 
1808			if STARTUP_V2 
1808			prom_c2: db "Enable Autoload Files",0 
1808			prom_c2a: db "Disable Autoload Files", 0 
1808			 
1808			crs_s1: db "*ls-word", 0 
1808			crs_s2: db "*ed-word", 0 
1808			crs_s3: db "*Demo-Programs", 0 
1808			crs_s4: db "*Utils", 0 
1808			crs_s5: db "*SPI-Addons", 0 
1808			crs_s6: db "*Key-constants", 0 
1808			crs_sound: db "*Sound-Util", 0 
1808			 
1808			 
1808			 
1808			endif 
1808			;prom_c2b: db "Select Storage Bank",0 
1808 .. 00		prom_c4: db "Settings",0 
1811 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
182c .. 00		prom_m4b:   db "Monitor",0 
1834 .. 00		prom_c1: db "Hardware Diags",0 
1843			 
1843			 
1843			if STARTUP_V2 
1843			prom_c9: db "Create Startup Files",0 
1843			endif 
1843			 
1843 .. 00		prom_notav:    db "Feature not available",0 
1859 .. 00		prom_empty:    db "",0 
185a			 
185a			; eof 
185a			 
# End of file firmware_prompts.asm
185a			  
185a			  
185a			; eof  
185a			  
# End of file firmware.asm
185a			 
185a			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
185a			;if BASE_KEV  
185a			;baseram: equ 08000h 
185a			;endif 
185a			 
185a			;if BASE_SC114 
185a			;baseram:     equ    endofcode 
185a			;endif 
185a			 
185a			 
185a			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
185a			 
185a			; start system 
185a			 
185a			coldstart: 
185a				; set sp 
185a				; di/ei 
185a			 
185a f3				di 
185b 31 00 f0			ld sp, tos 
185e cd 7d 64			call init_nmi 
1861			;	ei 
1861			 
1861				; init spinner 
1861 3e 00			ld a,0 
1863 32 c6 eb			ld (display_active), a 
1866			 
1866				; disable breakpoint by default 
1866			 
1866				;ld a,'*' 
1866			;	ld a,' ' 
1866			;	ld (os_view_disable),a 
1866			 
1866				; set break point vector as new break point on or off 
1866 cd e9 15			call bp_off 
1869			 
1869				; init hardware 
1869			 
1869				; init keyboard and screen hardware 
1869			 
1869 cd 1c 01			call hardware_init 
186c			 
186c			 
186c cd f2 0a			call delay1s 
186f 3e 58			ld a, display_row_3+8 
1871 11 03 01			ld de, buildtime 
1874 cd cd 0b			call str_at_display 
1877 cd dd 0b			call update_display 
187a			 
187a cd f2 0a			call delay1s 
187d cd f2 0a			call delay1s 
1880 cd f2 0a			call delay1s 
1883			 
1883				; detect if any keys are held down to enable breakpoints at start up 
1883			 
1883 cd 87 65			call cin  
1886 fe 00			cp 0 
1888 28 03			jr z, .nokeys 
188a			 
188a				;call hardware_diags 
188a cd 47 14			call config 
188d			 
188d			;	ld de, .bpen 
188d			;	ld a, display_row_4 
188d			;	call str_at_display 
188d			;	call update_display 
188d			; 
188d			;	ld a,0 
188d			;	ld (os_view_disable),a 
188d			; 
188d			;.bpwait: 
188d			;	call cin 
188d			;	cp 0 
188d			;	jr z, .bpwait 
188d			;	jr .nokeys 
188d			; 
188d			; 
188d			;.bpen:  db "Break points enabled!",0 
188d			 
188d			 
188d			 
188d			 
188d			 
188d			 
188d			.nokeys: 
188d			 
188d			 
188d				 
188d			 
188d			;jp  testkey 
188d			 
188d			;call storage_get_block_0 
188d			; 
188d			;ld hl, 0 
188d			;ld de, store_page 
188d			;call storage_read_block 
188d			 
188d				 
188d			;ld hl, 10 
188d			;ld de, store_page 
188d			;call storage_read_block 
188d			 
188d			 
188d			 
188d			 
188d			 
188d			;stop:	nop 
188d			;	jp stop 
188d			 
188d			 
188d			 
188d			main: 
188d cd ba 0b			call clear_display 
1890 cd dd 0b			call update_display 
1893			 
1893			 
1893			 
1893			;	call testlcd 
1893			 
1893			 
1893			 
1893 cd d3 1f			call forth_init 
1896			 
1896			 
1896			warmstart: 
1896 cd a9 1f			call forth_warmstart 
1899			 
1899				; run startup word load 
1899			        ; TODO prevent this running at warmstart after crash  
1899			 
1899				if STARTUP_ENABLE 
1899			 
1899					if STARTUP_V1 
1899			 
1899						if STORAGE_SE 
1899							call forth_autoload 
1899						endif 
1899 cd cd 63					call forth_startup 
189c					endif 
189c			 
189c					if STARTUP_V2 
189c			 
189c						if STORAGE_SE 
189c							call forth_autoload 
189c						else 
189c							call forth_startup 
189c						endif 
189c			 
189c			 
189c					endif 
189c			 
189c				endif 
189c			 
189c				; show free memory after boot 
189c 11 36 19			ld de, freeram 
189f 3e 00			ld a, display_row_1 
18a1 cd cd 0b			call str_at_display 
18a4			 
18a4			; Or use heap_size word???? 
18a4 21 a8 e2			ld hl, heap_end 
18a7 11 af 65			ld de, heap_start 
18aa ed 52			sbc hl, de 
18ac e5				push hl 
18ad 7c				ld a,h	         	 
18ae 21 c6 e5			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
18b1 cd e8 10			call hexout 
18b4 e1			   	pop hl 
18b5			 
18b5 7d				ld a,l 
18b6 21 c8 e5			ld hl, os_word_scratch+2 
18b9 cd e8 10			call hexout 
18bc 21 ca e5			ld hl, os_word_scratch+4 
18bf 3e 00			ld a, 0 
18c1 77				ld (hl),a 
18c2 11 c6 e5			ld de, os_word_scratch 
18c5 3e 0d			ld a, display_row_1 + 13 
18c7 cd cd 0b			call str_at_display 
18ca cd dd 0b			call update_display 
18cd			 
18cd			 
18cd				;call demo 
18cd			 
18cd			 
18cd				; init scratch input area for cli commands 
18cd			 
18cd 21 e8 e5			ld hl, os_cli_cmd 
18d0 3e 00			ld a,0 
18d2 77				ld (hl),a 
18d3 23				inc hl 
18d4 77				ld (hl),a 
18d5			 
18d5 3e 00			ld a,0 
18d7 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
18da			 
18da 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
18dd 32 e5 e5			ld (os_cur_ptr+1),a	 
18e0			 
18e0 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
18e3 32 c7 e5			ld (os_word_scratch+1),a	 
18e6				 
18e6			 
18e6				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18e6 21 e8 e5			ld hl, os_cli_cmd 
18e9			 
18e9 3e 00			ld a, 0		 ; init cli input 
18eb 77				ld (hl), a 
18ec 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18ee			cli: 
18ee				; show cli prompt 
18ee				;push af 
18ee				;ld a, 0 
18ee				;ld de, prompt 
18ee				;call str_at_display 
18ee			 
18ee				;call update_display 
18ee				;pop af 
18ee				;inc a 
18ee				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18ee 0e 00			ld c, 0 
18f0 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18f2 1e 28			ld e, 40 
18f4			 
18f4 21 e8 e5			ld hl, os_cli_cmd 
18f7			 
18f7				STACKFRAME OFF $fefe $9f9f 
18f7				if DEBUG_STACK_IMB 
18f7					if OFF 
18f7						exx 
18f7						ld de, $fefe 
18f7						ld a, d 
18f7						ld hl, curframe 
18f7						call hexout 
18f7						ld a, e 
18f7						ld hl, curframe+2 
18f7						call hexout 
18f7						ld hl, $fefe 
18f7						push hl 
18f7						ld hl, $9f9f 
18f7						push hl 
18f7						exx 
18f7					endif 
18f7				endif 
18f7			endm 
# End of macro STACKFRAME
18f7			 
18f7 cd 14 0e			call input_str 
18fa			 
18fa				STACKFRAMECHK OFF $fefe $9f9f 
18fa				if DEBUG_STACK_IMB 
18fa					if OFF 
18fa						exx 
18fa						ld hl, $9f9f 
18fa						pop de   ; $9f9f 
18fa						call cmp16 
18fa						jr nz, .spnosame 
18fa						ld hl, $fefe 
18fa						pop de   ; $fefe 
18fa						call cmp16 
18fa						jr z, .spfrsame 
18fa						.spnosame: call showsperror 
18fa						.spfrsame: nop 
18fa						exx 
18fa					endif 
18fa				endif 
18fa			endm 
# End of macro STACKFRAMECHK
18fa			 
18fa				; copy input to last command 
18fa			 
18fa 21 e8 e5			ld hl, os_cli_cmd 
18fd 11 e7 e6			ld de, os_last_cmd 
1900 01 ff 00			ld bc, 255 
1903 ed b0			ldir 
1905			 
1905				; wipe current buffer 
1905			 
1905			;	ld a, 0 
1905			;	ld hl, os_cli_cmd 
1905			;	ld de, os_cli_cmd+1 
1905			;	ld bc, 254 
1905			;	ldir 
1905				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1905			;	call strcpy 
1905			;	ld a, 0 
1905			;	ld (hl), a 
1905			;	inc hl 
1905			;	ld (hl), a 
1905			;	inc hl 
1905			;	ld (hl), a 
1905			 
1905				; switch frame buffer to program  
1905			 
1905 21 10 ed				ld hl, display_fb1 
1908 22 cc eb				ld (display_fb_active), hl 
190b			 
190b			;	nop 
190b				STACKFRAME ON $fbfe $8f9f 
190b				if DEBUG_STACK_IMB 
190b					if ON 
190b						exx 
190b						ld de, $fbfe 
190b						ld a, d 
190b						ld hl, curframe 
190b						call hexout 
190b						ld a, e 
190b						ld hl, curframe+2 
190b						call hexout 
190b						ld hl, $fbfe 
190b						push hl 
190b						ld hl, $8f9f 
190b						push hl 
190b						exx 
190b					endif 
190b				endif 
190b			endm 
# End of macro STACKFRAME
190b				; first time into the parser so pass over the current scratch pad 
190b 21 e8 e5			ld hl,os_cli_cmd 
190e				; tokenise the entered statement(s) in HL 
190e cd 51 20			call forthparse 
1911			        ; exec forth statements in top of return stack 
1911 cd 91 20			call forthexec 
1914				;call forthexec_cleanup 
1914			;	call parsenext 
1914			 
1914				STACKFRAMECHK ON $fbfe $8f9f 
1914				if DEBUG_STACK_IMB 
1914					if ON 
1914						exx 
1914						ld hl, $8f9f 
1914						pop de   ; $8f9f 
1914						call cmp16 
1914						jr nz, .spnosame 
1914						ld hl, $fbfe 
1914						pop de   ; $fbfe 
1914						call cmp16 
1914						jr z, .spfrsame 
1914						.spnosame: call showsperror 
1914						.spfrsame: nop 
1914						exx 
1914					endif 
1914				endif 
1914			endm 
# End of macro STACKFRAMECHK
1914				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1914			 
1914 3e 78			ld a, display_row_4 
1916 11 48 19			ld de, endprog 
1919			 
1919 cd dd 0b			call update_display		 
191c			 
191c cd ce 1b			call next_page_prompt 
191f			 
191f				; switch frame buffer to cli 
191f			 
191f 21 b1 ed				ld hl, display_fb0 
1922 22 cc eb				ld (display_fb_active), hl 
1925			 
1925			 
1925 cd ba 0b		        call clear_display 
1928 cd dd 0b			call update_display		 
192b			 
192b 21 e8 e5			ld hl, os_cli_cmd 
192e			 
192e 3e 00			ld a, 0		 ; init cli input 
1930 77				ld (hl), a 
1931			 
1931				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1931			 
1931				; now on last line 
1931			 
1931				; TODO scroll screen up 
1931			 
1931				; TODO instead just clear screen and place at top of screen 
1931			 
1931			;	ld a, 0 
1931			;	ld (f_cursor_ptr),a 
1931			 
1931				;call clear_display 
1931				;call update_display 
1931			 
1931				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1931 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1933 c3 ee 18			jp cli 
1936			 
1936 .. 00		freeram: db "Free bytes: $",0 
1944 ..			asc: db "1A2F" 
1948 .. 00		endprog: db "End prog...",0 
1954			 
1954			testenter2:   
1954 21 f3 e2			ld hl,scratch+50 
1957 22 e4 e5			ld (os_cur_ptr),hl 
195a c3 ee 18			jp cli 
195d			 
195d			testenter:  
195d			 
195d 21 44 19			ld hl,asc 
1960			;	ld a,(hl) 
1960			;	call nibble2val 
1960 cd 3e 11			call get_byte 
1963			 
1963			 
1963			;	ld a,(hl) 
1963			;	call atohex 
1963			 
1963			;	call fourehexhl 
1963 32 f3 e2			ld (scratch+50),a 
1966			 
1966			 
1966			 
1966 21 46 19			ld hl,asc+2 
1969			;	ld a, (hl) 
1969			;	call nibble2val 
1969 cd 3e 11			call get_byte 
196c			 
196c			;	call fourehexhl 
196c 32 f5 e2			ld (scratch+52),a 
196f				 
196f 21 f3 e2			ld hl,scratch+50 
1972 22 e4 e5			ld (os_cur_ptr),hl 
1975 c3 ee 18			jp cli 
1978			 
1978			enter:	 
1978 3a c5 e2			ld a,(scratch+4) 
197b fe 00			cp 0 
197d 28 0c			jr z, .entercont 
197f				; no, not a null term line so has an address to work out.... 
197f			 
197f 21 c3 e2			ld hl,scratch+2 
1982 cd 9e 11			call get_word_hl 
1985			 
1985 22 e4 e5			ld (os_cur_ptr),hl	 
1988 c3 ee 18			jp cli 
198b			 
198b			 
198b			.entercont:  
198b			 
198b 21 c3 e2			ld hl, scratch+2 
198e cd 3e 11			call get_byte 
1991			 
1991 2a e4 e5		   	ld hl,(os_cur_ptr) 
1994 77					ld (hl),a 
1995 23					inc hl 
1996 22 e4 e5				ld (os_cur_ptr),hl 
1999				 
1999			; get byte  
1999			 
1999			 
1999 c3 ee 18			jp cli 
199c			 
199c			 
199c			; basic monitor support 
199c			 
199c			monitor: 
199c				;  
199c cd ba 0b			call clear_display 
199f 3e 00			ld a, 0 
19a1 11 f0 19			ld de, .monprompt 
19a4 cd cd 0b			call str_at_display 
19a7 cd dd 0b			call update_display 
19aa			 
19aa				; get a monitor command 
19aa			 
19aa 0e 00			ld c, 0     ; entry at top left 
19ac 16 64			ld d, 100   ; max buffer size 
19ae 1e 0f			ld e, 15    ; input scroll area 
19b0 3e 00			ld a, 0     ; init string 
19b2 21 bf e4			ld hl, os_input 
19b5 77				ld (hl), a 
19b6 23				inc hl 
19b7 77				ld (hl), a 
19b8 21 bf e4			ld hl, os_input 
19bb 3e 01			ld a, 1     ; init string 
19bd cd 14 0e			call input_str 
19c0			 
19c0 cd ba 0b		        call clear_display 
19c3 cd dd 0b			call update_display		 
19c6			 
19c6 3a bf e4			ld a, (os_input) 
19c9 cd 3c 12			call toUpper 
19cc fe 48		        cp 'H' 
19ce ca 55 1a		        jp z, .monhelp 
19d1 fe 44			cp 'D'		; dump 
19d3 ca 88 1a			jp z, .mondump	 
19d6 fe 43			cp 'C'		; dump 
19d8 ca a2 1a			jp z, .moncdump	 
19db fe 4d			cp 'M'		; dump 
19dd ca f2 19			jp z, .moneditstart 
19e0 fe 55			cp 'U'		; dump 
19e2 ca fe 19			jp z, .monedit	 
19e5 fe 47			cp 'G'		; dump 
19e7 ca 7e 1a			jp z, .monjump 
19ea fe 51			cp 'Q'		; dump 
19ec c8				ret z	 
19ed			 
19ed			 
19ed				; TODO "S" to access symbol by name and not need the address 
19ed				; TODO "F" to find a string in memory 
19ed			 
19ed c3 9c 19			jp monitor 
19f0			 
19f0 .. 00		.monprompt: db ">", 0 
19f2			 
19f2			.moneditstart: 
19f2				; get starting address 
19f2			 
19f2 21 c1 e4			ld hl,os_input+2 
19f5 cd 9e 11			call get_word_hl 
19f8			 
19f8 22 e4 e5			ld (os_cur_ptr),hl	 
19fb			 
19fb c3 9c 19			jp monitor 
19fe			 
19fe			.monedit: 
19fe				; get byte to load 
19fe			 
19fe 21 c1 e4			ld hl,os_input+2 
1a01 cd 3e 11			call get_byte 
1a04			 
1a04				; get address to update 
1a04 2a e4 e5			ld hl, (os_cur_ptr) 
1a07			 
1a07				; update byte 
1a07			 
1a07 77				ld (hl), a 
1a08			 
1a08				; move to next address and save it 
1a08			 
1a08 23				inc hl 
1a09 22 e4 e5			ld (os_cur_ptr),hl	 
1a0c			 
1a0c c3 9c 19			jp monitor 
1a0f			 
1a0f			 
1a0f .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1a23 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1a3f .. 00		.monhelptext3:  db "G-Call address",0 
1a4e .. 00		.monhelptext4:  db "Q-Quit",0 
1a55			        
1a55			.monhelp: 
1a55 3e 00			ld a, display_row_1 
1a57 11 0f 1a		        ld de, .monhelptext1 
1a5a			 
1a5a cd cd 0b			call str_at_display 
1a5d 3e 28			ld a, display_row_2 
1a5f 11 23 1a		        ld de, .monhelptext2 
1a62					 
1a62 cd cd 0b			call str_at_display 
1a65 3e 50			ld a, display_row_3 
1a67 11 3f 1a		        ld de, .monhelptext3 
1a6a					 
1a6a cd cd 0b			call str_at_display 
1a6d 3e 78			ld a, display_row_4 
1a6f 11 4e 1a		        ld de, .monhelptext4 
1a72 cd cd 0b			call str_at_display 
1a75			 
1a75 cd dd 0b			call update_display		 
1a78			 
1a78 cd ce 1b			call next_page_prompt 
1a7b c3 9c 19			jp monitor 
1a7e			 
1a7e			.monjump:    
1a7e 21 c1 e4			ld hl,os_input+2 
1a81 cd 9e 11			call get_word_hl 
1a84			 
1a84 e9				jp (hl) 
1a85 c3 9c 19			jp monitor 
1a88			 
1a88			.mondump:    
1a88 21 c1 e4			ld hl,os_input+2 
1a8b cd 9e 11			call get_word_hl 
1a8e			 
1a8e 22 e4 e5			ld (os_cur_ptr),hl	 
1a91 cd d6 1a			call dumpcont 
1a94 3e 78			ld a, display_row_4 
1a96 11 48 19			ld de, endprog 
1a99			 
1a99 cd dd 0b			call update_display		 
1a9c			 
1a9c cd ce 1b			call next_page_prompt 
1a9f c3 9c 19			jp monitor 
1aa2			.moncdump: 
1aa2 cd d6 1a			call dumpcont 
1aa5 3e 78			ld a, display_row_4 
1aa7 11 48 19			ld de, endprog 
1aaa			 
1aaa cd dd 0b			call update_display		 
1aad			 
1aad cd ce 1b			call next_page_prompt 
1ab0 c3 9c 19			jp monitor 
1ab3			 
1ab3			 
1ab3			; TODO symbol access  
1ab3			 
1ab3			.symbols:     ;; A list of symbols that can be called up  
1ab3 b1 ed			dw display_fb0 
1ab5 .. 00			db "fb0",0  
1ab9 7a ea		     	dw store_page 
1abb .. 00			db "store_page",0 
1ac6			 
1ac6			 
1ac6			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1ac6			 
1ac6 3a c2 e2			ld a,(scratch+1) 
1ac9 fe 00			cp 0 
1acb 28 09			jr z, dumpcont 
1acd			 
1acd				; no, not a null term line so has an address to work out.... 
1acd			 
1acd 21 c3 e2			ld hl,scratch+2 
1ad0 cd 9e 11			call get_word_hl 
1ad3			 
1ad3 22 e4 e5			ld (os_cur_ptr),hl	 
1ad6			 
1ad6			 
1ad6			 
1ad6			dumpcont: 
1ad6			 
1ad6				; dump bytes at ptr 
1ad6			 
1ad6			 
1ad6 3e 00			ld a, display_row_1 
1ad8 2a cc eb			ld hl, (display_fb_active) 
1adb cd e7 0d			call addatohl 
1ade cd 06 1b			call .dumpbyterow 
1ae1			 
1ae1 3e 28			ld a, display_row_2 
1ae3 2a cc eb			ld hl, (display_fb_active) 
1ae6 cd e7 0d			call addatohl 
1ae9 cd 06 1b			call .dumpbyterow 
1aec			 
1aec			 
1aec 3e 50			ld a, display_row_3 
1aee 2a cc eb			ld hl, (display_fb_active) 
1af1 cd e7 0d			call addatohl 
1af4 cd 06 1b			call .dumpbyterow 
1af7			 
1af7 3e 78			ld a, display_row_4 
1af9 2a cc eb			ld hl, (display_fb_active) 
1afc cd e7 0d			call addatohl 
1aff cd 06 1b			call .dumpbyterow 
1b02			 
1b02 cd dd 0b			call update_display 
1b05			;		jp cli 
1b05 c9				ret 
1b06			 
1b06			.dumpbyterow: 
1b06			 
1b06				;push af 
1b06			 
1b06 e5				push hl 
1b07			 
1b07				; calc where to poke the ascii 
1b07			if display_cols == 20 
1b07				ld a, 16 
1b07			else 
1b07 3e 1f			ld a, 31 
1b09			endif 
1b09			 
1b09 cd e7 0d			call addatohl 
1b0c 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
1b0f			 
1b0f			 
1b0f			; display decoding address 
1b0f 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b12			 
1b12 7c				ld a,h 
1b13 e1				pop hl 
1b14 e5				push hl 
1b15			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b15 cd e8 10			call hexout 
1b18 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b1b			 
1b1b 7d				ld a,l 
1b1c e1				pop hl 
1b1d 23				inc hl 
1b1e 23				inc hl 
1b1f e5				push hl 
1b20			;	ld hl, os_word_scratch+2 
1b20 cd e8 10			call hexout 
1b23 e1				pop hl 
1b24 23				inc hl 
1b25 23				inc hl 
1b26				;ld hl, os_word_scratch+4 
1b26 3e 3a			ld a, ':' 
1b28 77				ld (hl),a 
1b29 23				inc hl 
1b2a				;ld a, 0 
1b2a				;ld (hl),a 
1b2a				;ld de, os_word_scratch 
1b2a				;pop af 
1b2a				;push af 
1b2a			;		ld a, display_row_2 
1b2a			;		call str_at_display 
1b2a			;		call update_display 
1b2a			 
1b2a			 
1b2a			;pop af 
1b2a			;	add 5 
1b2a			 
1b2a			if display_cols == 20 
1b2a				ld b, 4 
1b2a			else 
1b2a 06 08			ld b, 8 
1b2c			endif	 
1b2c			 
1b2c			.dumpbyte: 
1b2c c5				push bc 
1b2d e5				push hl 
1b2e			 
1b2e			 
1b2e 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b31 7e					ld a,(hl) 
1b32			 
1b32					; poke the ascii to display 
1b32 2a c6 e5				ld hl,(os_word_scratch) 
1b35 77					ld (hl),a 
1b36 23					inc hl 
1b37 22 c6 e5				ld (os_word_scratch),hl 
1b3a			 
1b3a					 
1b3a			 
1b3a			 
1b3a e1					pop hl 
1b3b e5					push hl 
1b3c			 
1b3c cd e8 10				call hexout 
1b3f			 
1b3f					 
1b3f 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b42 23				inc hl 
1b43 22 e4 e5		   	ld (os_cur_ptr),hl 
1b46			 
1b46 e1					pop hl 
1b47 23					inc hl 
1b48 23					inc hl 
1b49 23					inc hl 
1b4a			 
1b4a			 
1b4a			 
1b4a					;ld a,0 
1b4a					;ld (os_word_scratch+2),a 
1b4a					;pop af 
1b4a					;push af 
1b4a			 
1b4a					;ld de, os_word_scratch 
1b4a					;call str_at_display 
1b4a			;		call update_display 
1b4a			;		pop af 
1b4a c1					pop bc 
1b4b c6 03				add 3 
1b4d 10 dd			djnz .dumpbyte 
1b4f			 
1b4f				 
1b4f			 
1b4f c9				ret 
1b50			 
1b50			jump:	 
1b50			 
1b50 21 c3 e2			ld hl,scratch+2 
1b53 cd 9e 11			call get_word_hl 
1b56				;ld hl,(scratch+2) 
1b56				;call fourehexhl 
1b56			 
1b56 22 e4 e5			ld (os_cur_ptr),hl	 
1b59			 
1b59 e9				jp (hl) 
1b5a			 
1b5a			 
1b5a			 
1b5a			; TODO implement a basic monitor mode to start with 
1b5a			 
1b5a			 
1b5a			 
1b5a			 
1b5a			 
1b5a			 
1b5a			 
1b5a			 
1b5a			 
1b5a			; testing and demo code during development 
1b5a			 
1b5a			 
1b5a .. 00		str1: db "Enter some text...",0 
1b6d .. 00		clear: db "                    ",0 
1b82			 
1b82			demo: 
1b82			 
1b82			 
1b82			 
1b82			;	call update_display 
1b82			 
1b82				; init scratch input area for testing 
1b82 21 c1 e2			ld hl, scratch	 
1b85 3e 00			ld a,0 
1b87 77				ld (hl),a 
1b88			 
1b88			 
1b88 3e 28		            LD   A, display_row_2 
1b8a			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b8a 11 5a 1b		            LD   DE, str1 
1b8d cd cd 0b			call str_at_display 
1b90			 
1b90			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b90			cloop:	 
1b90 3e 50		            LD   A, display_row_3 
1b92			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b92 11 6d 1b		            LD   DE, clear 
1b95			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1b95 cd cd 0b				call str_at_display 
1b98 3e 78			ld a, display_row_4 
1b9a 11 ca 1b			ld de, prompt 
1b9d			 
1b9d cd cd 0b				call str_at_display 
1ba0 cd dd 0b			call update_display 
1ba3			 
1ba3 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1ba5 16 0a			ld d, 10 
1ba7 21 c1 e2			ld hl, scratch	 
1baa cd 14 0e			call input_str 
1bad			 
1bad			;	call clear_display 
1bad			;'	call update_display 
1bad			 
1bad 3e 00		            LD   A, display_row_1 
1baf			;            CALL fLCD_Pos       ;Position cursor to location in A 
1baf 11 6d 1b		            LD   DE, clear 
1bb2 cd cd 0b				call str_at_display 
1bb5			;            CALL fLCD_Str       ;Display string pointed to by DE 
1bb5 3e 00		            LD   A, display_row_1 
1bb7			;            CALL fLCD_Pos       ;Position cursor to location in A 
1bb7 11 c1 e2		            LD   DE, scratch 
1bba			;            CALL fLCD_Str       ;Display string pointed to by DE 
1bba cd cd 0b				call str_at_display 
1bbd cd dd 0b			call update_display 
1bc0			 
1bc0 3e 00				ld a,0 
1bc2 21 c1 e2			ld hl, scratch 
1bc5 77				ld (hl),a 
1bc6			 
1bc6 00				nop 
1bc7 c3 90 1b			jp cloop 
1bca			 
1bca			 
1bca			 
1bca			; OS Prompt 
1bca			 
1bca .. 00		prompt: db ">",0 
1bcc .. 00		endprg: db "?",0 
1bce			 
1bce			 
1bce			; handy next page prompt 
1bce			next_page_prompt: 
1bce e5				push hl 
1bcf d5				push de 
1bd0 f5				push af 
1bd1 c5				push bc 
1bd2			 
1bd2 3e 9f			ld a,display_row_4 + display_cols - 1 
1bd4 11 cc 1b		        ld de, endprg 
1bd7 cd cd 0b			call str_at_display 
1bda cd dd 0b			call update_display 
1bdd cd 7f 65			call cin_wait 
1be0 c1				pop bc 
1be1 f1				pop af 
1be2 d1				pop de 
1be3 e1				pop hl 
1be4			 
1be4			 
1be4 c9				ret 
1be5			 
1be5			 
1be5			; forth parser 
1be5			 
1be5			; My forth kernel 
1be5			include "forth_kernel.asm" 
1be5			; 
1be5			; kernel to the forth OS 
1be5			 
1be5			DS_TYPE_STR: equ 1     ; string type 
1be5			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1be5			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1be5			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1be5			 
1be5			FORTH_PARSEV1: equ 0 
1be5			FORTH_PARSEV2: equ 0 
1be5			FORTH_PARSEV3: equ 0 
1be5			FORTH_PARSEV4: equ 0 
1be5			FORTH_PARSEV5: equ 1 
1be5			 
1be5			;if FORTH_PARSEV5 
1be5			;	FORTH_END_BUFFER: equ 0 
1be5			;else 
1be5			FORTH_END_BUFFER: equ 127 
1be5			;endif 
1be5			 
1be5			FORTH_TRUE: equ 1 
1be5			FORTH_FALSE: equ 0 
1be5			 
1be5			if FORTH_PARSEV4 
1be5			include "forth_stackops.asm" 
1be5			endif 
1be5			 
1be5			if FORTH_PARSEV5 
1be5			include "forth_stackopsv5.asm" 
1be5			 
1be5			; Stack operations for v5 parser on wards 
1be5			; * DATA stack 
1be5			; * LOOP stack 
1be5			; * RETURN stack 
1be5			 
1be5			 
1be5			 
1be5			FORTH_CHK_DSP_UNDER: macro 
1be5				push hl 
1be5				push de 
1be5				ld hl,(cli_data_sp) 
1be5				ld de, cli_data_stack 
1be5				call cmp16 
1be5				jp c, fault_dsp_under 
1be5				pop de 
1be5				pop hl 
1be5				endm 
1be5			 
1be5			 
1be5			FORTH_CHK_RSP_UNDER: macro 
1be5				push hl 
1be5				push de 
1be5				ld hl,(cli_ret_sp) 
1be5				ld de, cli_ret_stack 
1be5				call cmp16 
1be5				jp c, fault_rsp_under 
1be5				pop de 
1be5				pop hl 
1be5				endm 
1be5			 
1be5			FORTH_CHK_LOOP_UNDER: macro 
1be5				push hl 
1be5				push de 
1be5				ld hl,(cli_loop_sp) 
1be5				ld de, cli_loop_stack 
1be5				call cmp16 
1be5				jp c, fault_loop_under 
1be5				pop de 
1be5				pop hl 
1be5				endm 
1be5			 
1be5			FORTH_ERR_TOS_NOTSTR: macro 
1be5				; TOSO might need more for checks when used 
1be5				push af 
1be5				ld a,(hl) 
1be5				cp DS_TYPE_STR 
1be5				jp nz, type_faultn   
1be5				pop af 
1be5				endm 
1be5			 
1be5			FORTH_ERR_TOS_NOTNUM: macro 
1be5				push af 
1be5				ld a,(hl) 
1be5				cp DS_TYPE_INUM 
1be5				jp nz, type_faultn   
1be5				pop af 
1be5				endm 
1be5			 
1be5			 
1be5			; increase data stack pointer and save hl to it 
1be5				 
1be5			FORTH_DSP_NEXT: macro 
1be5				call macro_forth_dsp_next 
1be5				endm 
1be5			 
1be5			 
1be5			macro_forth_dsp_next: 
1be5				if DEBUG_FORTH_STACK_GUARD 
1be5 cd ae 61				call check_stacks 
1be8				endif 
1be8 e5				push hl 
1be9 d5				push de 
1bea eb				ex de,hl 
1beb 2a ee e9			ld hl,(cli_data_sp) 
1bee 23				inc hl 
1bef 23				inc hl 
1bf0			 
1bf0			; PARSEV5 
1bf0 23				inc hl 
1bf1 22 ee e9			ld (cli_data_sp),hl 
1bf4 73				ld (hl), e 
1bf5 23				inc hl 
1bf6 72				ld (hl), d 
1bf7 d1				pop de 
1bf8 e1				pop hl 
1bf9				if DEBUG_FORTH_STACK_GUARD 
1bf9 cd ae 61				call check_stacks 
1bfc				endif 
1bfc c9				ret 
1bfd			 
1bfd			 
1bfd			; increase ret stack pointer and save hl to it 
1bfd				 
1bfd			FORTH_RSP_NEXT: macro 
1bfd				call macro_forth_rsp_next 
1bfd				endm 
1bfd			 
1bfd			macro_forth_rsp_next: 
1bfd				if DEBUG_FORTH_STACK_GUARD 
1bfd cd ae 61				call check_stacks 
1c00				endif 
1c00 e5				push hl 
1c01 d5				push de 
1c02 eb				ex de,hl 
1c03 2a f2 e9			ld hl,(cli_ret_sp) 
1c06 23				inc hl 
1c07 23				inc hl 
1c08 22 f2 e9			ld (cli_ret_sp),hl 
1c0b 73				ld (hl), e 
1c0c 23				inc hl 
1c0d 72				ld (hl), d 
1c0e d1				pop de 
1c0f e1				pop hl 
1c10				if DEBUG_FORTH_STACK_GUARD 
1c10 cd ae 61				call check_stacks 
1c13				endif 
1c13 c9				ret 
1c14			 
1c14			; get current ret stack pointer and save to hl  
1c14				 
1c14			FORTH_RSP_TOS: macro 
1c14				call macro_forth_rsp_tos 
1c14				endm 
1c14			 
1c14			macro_forth_rsp_tos: 
1c14				;push de 
1c14 2a f2 e9			ld hl,(cli_ret_sp) 
1c17 cd 4f 1c			call loadhlptrtohl 
1c1a				;ld e, (hl) 
1c1a				;inc hl 
1c1a				;ld d, (hl) 
1c1a				;ex de, hl 
1c1a					if DEBUG_FORTH_WORDS 
1c1a			;			DMARK "RST" 
1c1a						CALLMONITOR 
1c1a cd 6f ee			call debug_vector  
1c1d				endm  
# End of macro CALLMONITOR
1c1d					endif 
1c1d				;pop de 
1c1d c9				ret 
1c1e			 
1c1e			; pop ret stack pointer 
1c1e				 
1c1e			FORTH_RSP_POP: macro 
1c1e				call macro_forth_rsp_pop 
1c1e				endm 
1c1e			 
1c1e			 
1c1e			macro_forth_rsp_pop: 
1c1e				if DEBUG_FORTH_STACK_GUARD 
1c1e			;		DMARK "RPP" 
1c1e cd ae 61				call check_stacks 
1c21					FORTH_CHK_RSP_UNDER 
1c21 e5				push hl 
1c22 d5				push de 
1c23 2a f2 e9			ld hl,(cli_ret_sp) 
1c26 11 ac e9			ld de, cli_ret_stack 
1c29 cd 05 0e			call cmp16 
1c2c da c2 62			jp c, fault_rsp_under 
1c2f d1				pop de 
1c30 e1				pop hl 
1c31				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c31				endif 
1c31 e5				push hl 
1c32 2a f2 e9			ld hl,(cli_ret_sp) 
1c35			 
1c35			 
1c35				if FORTH_ENABLE_FREE 
1c35			 
1c35					; get pointer 
1c35			 
1c35					push de 
1c35					push hl 
1c35			 
1c35					ld e, (hl) 
1c35					inc hl 
1c35					ld d, (hl) 
1c35			 
1c35					ex de, hl 
1c35					call free 
1c35			 
1c35					pop hl 
1c35					pop de 
1c35			 
1c35			 
1c35				endif 
1c35			 
1c35			 
1c35 2b				dec hl 
1c36 2b				dec hl 
1c37 22 f2 e9			ld (cli_ret_sp), hl 
1c3a				; do stack underflow checks 
1c3a e1				pop hl 
1c3b				if DEBUG_FORTH_STACK_GUARD 
1c3b cd ae 61				call check_stacks 
1c3e					FORTH_CHK_RSP_UNDER 
1c3e e5				push hl 
1c3f d5				push de 
1c40 2a f2 e9			ld hl,(cli_ret_sp) 
1c43 11 ac e9			ld de, cli_ret_stack 
1c46 cd 05 0e			call cmp16 
1c49 da c2 62			jp c, fault_rsp_under 
1c4c d1				pop de 
1c4d e1				pop hl 
1c4e				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c4e				endif 
1c4e c9				ret 
1c4f			 
1c4f			 
1c4f			 
1c4f			; routine to load word pointed to by hl into hl 
1c4f			 
1c4f			loadhlptrtohl: 
1c4f			 
1c4f d5				push de 
1c50 5e				ld e, (hl) 
1c51 23				inc hl 
1c52 56				ld d, (hl) 
1c53 eb				ex de, hl 
1c54 d1				pop de 
1c55			 
1c55 c9				ret 
1c56			 
1c56			 
1c56			 
1c56			 
1c56			 
1c56			; push a number held in HL onto the data stack 
1c56			; entry point for pushing a value when already in hl used in function above 
1c56			 
1c56			forth_push_numhl: 
1c56			 
1c56 e5				push hl    ; save value to push 
1c57			 
1c57			if DEBUG_FORTH_PUSH 
1c57				; see if disabled 
1c57			 
1c57			 
1c57 f5				push af 
1c58 3a 6f ee			ld a,(debug_vector) 
1c5b fe c9			cp $c9   ; ret 
1c5d			;	ld a, (os_view_disable) 
1c5d			;	cp '*' 
1c5d 28 34			jr z, .pskip2 
1c5f e5				push hl 
1c60 e5			push hl 
1c61 cd ba 0b			call clear_display 
1c64 e1			pop hl 
1c65 7c				ld a,h 
1c66 21 c6 e5			ld hl, os_word_scratch 
1c69 cd e8 10			call hexout 
1c6c e1				pop hl 
1c6d 7d				ld a,l 
1c6e 21 c8 e5			ld hl, os_word_scratch+2 
1c71 cd e8 10			call hexout 
1c74			 
1c74 21 ca e5			ld hl, os_word_scratch+4 
1c77 3e 00			ld a,0 
1c79 77				ld (hl),a 
1c7a 11 c6 e5			ld de,os_word_scratch 
1c7d 3e 28				ld a, display_row_2 
1c7f cd cd 0b				call str_at_display 
1c82 11 ea 4c			ld de, .push_num 
1c85 3e 00			ld a, display_row_1 
1c87			 
1c87 cd cd 0b				call str_at_display 
1c8a			 
1c8a			 
1c8a cd dd 0b			call update_display 
1c8d cd f2 0a			call delay1s 
1c90 cd f2 0a			call delay1s 
1c93			.pskip2:  
1c93			 
1c93 f1				pop af 
1c94			endif	 
1c94			 
1c94			 
1c94				FORTH_DSP_NEXT 
1c94 cd e5 1b			call macro_forth_dsp_next 
1c97				endm 
# End of macro FORTH_DSP_NEXT
1c97			 
1c97 2a ee e9			ld hl, (cli_data_sp) 
1c9a			 
1c9a				; save item type 
1c9a 3e 02			ld a,  DS_TYPE_INUM 
1c9c 77				ld (hl), a 
1c9d 23				inc hl 
1c9e			 
1c9e				; get word off stack 
1c9e d1				pop de 
1c9f 7b				ld a,e 
1ca0 77				ld (hl), a 
1ca1 23				inc hl 
1ca2 7a				ld a,d 
1ca3 77				ld (hl), a 
1ca4			 
1ca4			if DEBUG_FORTH_PUSH 
1ca4 2b				dec hl 
1ca5 2b				dec hl 
1ca6 2b				dec hl 
1ca7						DMARK "PH5" 
1ca7 f5				push af  
1ca8 3a bc 1c			ld a, (.dmark)  
1cab 32 6b ee			ld (debug_mark),a  
1cae 3a bd 1c			ld a, (.dmark+1)  
1cb1 32 6c ee			ld (debug_mark+1),a  
1cb4 3a be 1c			ld a, (.dmark+2)  
1cb7 32 6d ee			ld (debug_mark+2),a  
1cba 18 03			jr .pastdmark  
1cbc ..			.dmark: db "PH5"  
1cbf f1			.pastdmark: pop af  
1cc0			endm  
# End of macro DMARK
1cc0				CALLMONITOR 
1cc0 cd 6f ee			call debug_vector  
1cc3				endm  
# End of macro CALLMONITOR
1cc3			endif	 
1cc3			 
1cc3 c9				ret 
1cc4			 
1cc4			 
1cc4			; Push a string to stack pointed to by hl 
1cc4			 
1cc4			forth_push_str: 
1cc4			 
1cc4			if DEBUG_FORTH_PUSH 
1cc4						DMARK "PSQ" 
1cc4 f5				push af  
1cc5 3a d9 1c			ld a, (.dmark)  
1cc8 32 6b ee			ld (debug_mark),a  
1ccb 3a da 1c			ld a, (.dmark+1)  
1cce 32 6c ee			ld (debug_mark+1),a  
1cd1 3a db 1c			ld a, (.dmark+2)  
1cd4 32 6d ee			ld (debug_mark+2),a  
1cd7 18 03			jr .pastdmark  
1cd9 ..			.dmark: db "PSQ"  
1cdc f1			.pastdmark: pop af  
1cdd			endm  
# End of macro DMARK
1cdd				CALLMONITOR 
1cdd cd 6f ee			call debug_vector  
1ce0				endm  
# End of macro CALLMONITOR
1ce0			endif	 
1ce0			    
1ce0 e5				push hl 
1ce1 e5				push hl 
1ce2			 
1ce2			;	ld a, 0   ; find end of string 
1ce2 cd 45 12			call strlenz 
1ce5			if DEBUG_FORTH_PUSH 
1ce5						DMARK "PQ2" 
1ce5 f5				push af  
1ce6 3a fa 1c			ld a, (.dmark)  
1ce9 32 6b ee			ld (debug_mark),a  
1cec 3a fb 1c			ld a, (.dmark+1)  
1cef 32 6c ee			ld (debug_mark+1),a  
1cf2 3a fc 1c			ld a, (.dmark+2)  
1cf5 32 6d ee			ld (debug_mark+2),a  
1cf8 18 03			jr .pastdmark  
1cfa ..			.dmark: db "PQ2"  
1cfd f1			.pastdmark: pop af  
1cfe			endm  
# End of macro DMARK
1cfe				CALLMONITOR 
1cfe cd 6f ee			call debug_vector  
1d01				endm  
# End of macro CALLMONITOR
1d01			endif	 
1d01 eb				ex de, hl 
1d02 e1				pop hl   ; get ptr to start of string 
1d03			if DEBUG_FORTH_PUSH 
1d03						DMARK "PQ3" 
1d03 f5				push af  
1d04 3a 18 1d			ld a, (.dmark)  
1d07 32 6b ee			ld (debug_mark),a  
1d0a 3a 19 1d			ld a, (.dmark+1)  
1d0d 32 6c ee			ld (debug_mark+1),a  
1d10 3a 1a 1d			ld a, (.dmark+2)  
1d13 32 6d ee			ld (debug_mark+2),a  
1d16 18 03			jr .pastdmark  
1d18 ..			.dmark: db "PQ3"  
1d1b f1			.pastdmark: pop af  
1d1c			endm  
# End of macro DMARK
1d1c				CALLMONITOR 
1d1c cd 6f ee			call debug_vector  
1d1f				endm  
# End of macro CALLMONITOR
1d1f			endif	 
1d1f 19				add hl,de 
1d20			if DEBUG_FORTH_PUSH 
1d20						DMARK "PQE" 
1d20 f5				push af  
1d21 3a 35 1d			ld a, (.dmark)  
1d24 32 6b ee			ld (debug_mark),a  
1d27 3a 36 1d			ld a, (.dmark+1)  
1d2a 32 6c ee			ld (debug_mark+1),a  
1d2d 3a 37 1d			ld a, (.dmark+2)  
1d30 32 6d ee			ld (debug_mark+2),a  
1d33 18 03			jr .pastdmark  
1d35 ..			.dmark: db "PQE"  
1d38 f1			.pastdmark: pop af  
1d39			endm  
# End of macro DMARK
1d39				CALLMONITOR 
1d39 cd 6f ee			call debug_vector  
1d3c				endm  
# End of macro CALLMONITOR
1d3c			endif	 
1d3c			 
1d3c 2b				dec hl    ; see if there is an optional trailing double quote 
1d3d 7e				ld a,(hl) 
1d3e fe 22			cp '"' 
1d40 20 03			jr nz, .strnoq 
1d42 3e 00			ld a, 0      ; get rid of double quote 
1d44 77				ld (hl), a 
1d45 23			.strnoq: inc hl 
1d46			 
1d46 3e 00			ld a, 0 
1d48 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1d49			 
1d49 13				inc de ; add one for the type string 
1d4a 13				inc de ; add one for null term??? 
1d4b			 
1d4b				; tos is get string pointer again 
1d4b				; de contains space to allocate 
1d4b				 
1d4b d5				push de 
1d4c			 
1d4c eb				ex de, hl 
1d4d			 
1d4d				;push af 
1d4d			 
1d4d			if DEBUG_FORTH_PUSH 
1d4d						DMARK "PHm" 
1d4d f5				push af  
1d4e 3a 62 1d			ld a, (.dmark)  
1d51 32 6b ee			ld (debug_mark),a  
1d54 3a 63 1d			ld a, (.dmark+1)  
1d57 32 6c ee			ld (debug_mark+1),a  
1d5a 3a 64 1d			ld a, (.dmark+2)  
1d5d 32 6d ee			ld (debug_mark+2),a  
1d60 18 03			jr .pastdmark  
1d62 ..			.dmark: db "PHm"  
1d65 f1			.pastdmark: pop af  
1d66			endm  
# End of macro DMARK
1d66				CALLMONITOR 
1d66 cd 6f ee			call debug_vector  
1d69				endm  
# End of macro CALLMONITOR
1d69			endif	 
1d69 cd ae 12			call malloc	; on ret hl now contains allocated memory 
1d6c				if DEBUG_FORTH_MALLOC_GUARD 
1d6c cc 42 4d				call z,malloc_error 
1d6f				endif 
1d6f			 
1d6f				 
1d6f c1				pop bc    ; get length 
1d70 d1				pop de   ;  get string start    
1d71			 
1d71				; hl has destination from malloc 
1d71			 
1d71 eb				ex de, hl    ; prep for ldir 
1d72			 
1d72 d5				push de   ; save malloc area for DSP later 
1d73				;push hl   ; save malloc area for DSP later 
1d73			 
1d73			if DEBUG_FORTH_PUSH 
1d73						DMARK "PHc" 
1d73 f5				push af  
1d74 3a 88 1d			ld a, (.dmark)  
1d77 32 6b ee			ld (debug_mark),a  
1d7a 3a 89 1d			ld a, (.dmark+1)  
1d7d 32 6c ee			ld (debug_mark+1),a  
1d80 3a 8a 1d			ld a, (.dmark+2)  
1d83 32 6d ee			ld (debug_mark+2),a  
1d86 18 03			jr .pastdmark  
1d88 ..			.dmark: db "PHc"  
1d8b f1			.pastdmark: pop af  
1d8c			endm  
# End of macro DMARK
1d8c				CALLMONITOR 
1d8c cd 6f ee			call debug_vector  
1d8f				endm  
# End of macro CALLMONITOR
1d8f			endif	 
1d8f			 
1d8f			 
1d8f ed b0			ldir 
1d91			 
1d91			 
1d91				; push malloc to data stack     macro?????  
1d91			 
1d91				FORTH_DSP_NEXT 
1d91 cd e5 1b			call macro_forth_dsp_next 
1d94				endm 
# End of macro FORTH_DSP_NEXT
1d94			 
1d94				; save value and type 
1d94			 
1d94 2a ee e9			ld hl, (cli_data_sp) 
1d97			 
1d97				; save item type 
1d97 3e 01			ld a,  DS_TYPE_STR 
1d99 77				ld (hl), a 
1d9a 23				inc hl 
1d9b			 
1d9b				; get malloc word off stack 
1d9b d1				pop de 
1d9c 73				ld (hl), e 
1d9d 23				inc hl 
1d9e 72				ld (hl), d 
1d9f			 
1d9f			 
1d9f			 
1d9f			if DEBUG_FORTH_PUSH 
1d9f 2a ee e9			ld hl, (cli_data_sp) 
1da2						DMARK "PHS" 
1da2 f5				push af  
1da3 3a b7 1d			ld a, (.dmark)  
1da6 32 6b ee			ld (debug_mark),a  
1da9 3a b8 1d			ld a, (.dmark+1)  
1dac 32 6c ee			ld (debug_mark+1),a  
1daf 3a b9 1d			ld a, (.dmark+2)  
1db2 32 6d ee			ld (debug_mark+2),a  
1db5 18 03			jr .pastdmark  
1db7 ..			.dmark: db "PHS"  
1dba f1			.pastdmark: pop af  
1dbb			endm  
# End of macro DMARK
1dbb				CALLMONITOR 
1dbb cd 6f ee			call debug_vector  
1dbe				endm  
# End of macro CALLMONITOR
1dbe			;	ex de,hl 
1dbe			endif	 
1dbe				; in case of spaces, skip the ptr past the copied string 
1dbe				;pop af 
1dbe				;ld (cli_origptr),hl 
1dbe			 
1dbe c9				ret 
1dbf			 
1dbf			 
1dbf			 
1dbf			; TODO ascii push input onto stack given hl to start of input 
1dbf			 
1dbf			; identify type 
1dbf			; if starts with a " then a string 
1dbf			; otherwise it is a number 
1dbf			;  
1dbf			; if a string 
1dbf			;     scan for ending " to get length of string to malloc for + 1 
1dbf			;     malloc 
1dbf			;     put pointer to string on stack first byte flags as string 
1dbf			; 
1dbf			; else a number 
1dbf			;    look for number format identifier 
1dbf			;    $xx hex 
1dbf			;    %xxxxx bin 
1dbf			;    xxxxx decimal 
1dbf			;    convert number to 16bit word.  
1dbf			;    malloc word + 1 with flag to identiy as num 
1dbf			;    put pointer to number on stack 
1dbf			;   
1dbf			;  
1dbf			  
1dbf			forth_apush: 
1dbf				; kernel push 
1dbf			 
1dbf			if DEBUG_FORTH_PUSH 
1dbf						DMARK "PSH" 
1dbf f5				push af  
1dc0 3a d4 1d			ld a, (.dmark)  
1dc3 32 6b ee			ld (debug_mark),a  
1dc6 3a d5 1d			ld a, (.dmark+1)  
1dc9 32 6c ee			ld (debug_mark+1),a  
1dcc 3a d6 1d			ld a, (.dmark+2)  
1dcf 32 6d ee			ld (debug_mark+2),a  
1dd2 18 03			jr .pastdmark  
1dd4 ..			.dmark: db "PSH"  
1dd7 f1			.pastdmark: pop af  
1dd8			endm  
# End of macro DMARK
1dd8				CALLMONITOR 
1dd8 cd 6f ee			call debug_vector  
1ddb				endm  
# End of macro CALLMONITOR
1ddb			endif	 
1ddb				; identify input type 
1ddb			 
1ddb 7e				ld a,(hl) 
1ddc fe 22			cp '"' 
1dde 28 0a			jr z, .fapstr 
1de0 fe 24			cp '$' 
1de2 ca 0a 1e			jp z, .faphex 
1de5 fe 25			cp '%' 
1de7 ca f2 1d			jp z, .fapbin 
1dea			;	cp 'b' 
1dea			;	jp z, .fabin 
1dea				; else decimal 
1dea			 
1dea				; TODO do decimal conversion 
1dea				; decimal is stored as a 16bit word 
1dea			 
1dea				; by default everything is a string if type is not detected 
1dea			.fapstr: ; 
1dea fe 22			cp '"' 
1dec 20 01			jr nz, .strnoqu 
1dee 23				inc hl 
1def			.strnoqu: 
1def c3 c4 1c			jp forth_push_str 
1df2			 
1df2			 
1df2			 
1df2			.fapbin:    ; push a binary string.  
1df2 11 00 00			ld de, 0   ; hold a 16bit value 
1df5			 
1df5 23			.fapbinshift:	inc hl  
1df6 7e				ld a,(hl) 
1df7 fe 00			cp 0     ; done scanning  
1df9 28 0b			jr z, .fapbdone  	; got it in HL so push  
1dfb			 
1dfb				; left shift de 
1dfb eb				ex de, hl	 
1dfc 29				add hl, hl 
1dfd			 
1dfd				; is 1 
1dfd fe 31			cp '1' 
1dff 20 02			jr nz, .binzero 
1e01 cb 4d			bit 1, l 
1e03			.binzero: 
1e03 eb				ex de, hl	 ; save current de 
1e04 18 ef			jr .fapbinshift 
1e06			 
1e06			.fapbdone: 
1e06 eb				ex de, hl 
1e07 c3 56 1c			jp forth_push_numhl 
1e0a			 
1e0a			 
1e0a			.faphex:   ; hex is always stored as a 16bit word 
1e0a				; skip number prefix 
1e0a 23				inc hl 
1e0b				; turn ascii into number 
1e0b cd 9e 11			call get_word_hl	; ret 16bit word in hl 
1e0e			 
1e0e c3 56 1c			jp forth_push_numhl 
1e11			 
1e11 00				 nop 
1e12			 
1e12			.fabin:   ; TODO bin conversion 
1e12			 
1e12			 
1e12 c9				ret 
1e13			 
1e13			 
1e13			; get either a string ptr or a 16bit word from the data stack 
1e13			 
1e13			FORTH_DSP: macro 
1e13				call macro_forth_dsp 
1e13				endm 
1e13			 
1e13			macro_forth_dsp: 
1e13				; data stack pointer points to current word on tos 
1e13			 
1e13 2a ee e9			ld hl,(cli_data_sp) 
1e16			 
1e16				if DEBUG_FORTH_PUSH 
1e16						DMARK "DSP" 
1e16 f5				push af  
1e17 3a 2b 1e			ld a, (.dmark)  
1e1a 32 6b ee			ld (debug_mark),a  
1e1d 3a 2c 1e			ld a, (.dmark+1)  
1e20 32 6c ee			ld (debug_mark+1),a  
1e23 3a 2d 1e			ld a, (.dmark+2)  
1e26 32 6d ee			ld (debug_mark+2),a  
1e29 18 03			jr .pastdmark  
1e2b ..			.dmark: db "DSP"  
1e2e f1			.pastdmark: pop af  
1e2f			endm  
# End of macro DMARK
1e2f			 
1e2f cd 75 4d				call display_data_sp 
1e32				;call break_point_state 
1e32				;rst 030h 
1e32				CALLMONITOR 
1e32 cd 6f ee			call debug_vector  
1e35				endm  
# End of macro CALLMONITOR
1e35				endif 
1e35			 
1e35 c9				ret 
1e36			 
1e36			; return hl to start of value on stack 
1e36			 
1e36			FORTH_DSP_VALUE: macro 
1e36				call macro_forth_dsp_value 
1e36				endm 
1e36			 
1e36			macro_forth_dsp_value: 
1e36			 
1e36				FORTH_DSP 
1e36 cd 13 1e			call macro_forth_dsp 
1e39				endm 
# End of macro FORTH_DSP
1e39			 
1e39 d5				push de 
1e3a			 
1e3a 23				inc hl ; skip type 
1e3b			 
1e3b 5e				ld e, (hl) 
1e3c 23				inc hl 
1e3d 56				ld d, (hl) 
1e3e eb				ex de,hl  
1e3f			 
1e3f d1				pop de 
1e40			 
1e40 c9				ret 
1e41			 
1e41			; return hl to start of value to second item on stack 
1e41			 
1e41			FORTH_DSP_VALUEM1: macro 
1e41				call macro_forth_dsp_value_m1 
1e41				endm 
1e41			 
1e41			macro_forth_dsp_value_m1: 
1e41			 
1e41				FORTH_DSP 
1e41 cd 13 1e			call macro_forth_dsp 
1e44				endm 
# End of macro FORTH_DSP
1e44			 
1e44 2b				dec hl 
1e45 2b				dec hl 
1e46			;	dec hl 
1e46			 
1e46 d5				push de 
1e47			 
1e47 5e				ld e, (hl) 
1e48 23				inc hl 
1e49 56				ld d, (hl) 
1e4a eb				ex de,hl  
1e4b			 
1e4b d1				pop de 
1e4c			 
1e4c c9				ret 
1e4d			 
1e4d				 
1e4d			 
1e4d			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1e4d			 
1e4d			FORTH_DSP_POP: macro 
1e4d				call macro_forth_dsp_pop 
1e4d				endm 
1e4d			 
1e4d			 
1e4d			; get the tos data type 
1e4d			 
1e4d			FORTH_DSP_TYPE:   macro 
1e4d			 
1e4d				;FORTH_DSP_VALUE 
1e4d				FORTH_DSP 
1e4d				 
1e4d				; hl points to value 
1e4d				; check type 
1e4d			 
1e4d				ld a,(hl) 
1e4d			 
1e4d				endm 
1e4d			 
1e4d			; load the tos value into hl 
1e4d			 
1e4d			 
1e4d			FORTH_DSP_VALUEHL:  macro 
1e4d				call macro_dsp_valuehl 
1e4d				endm 
1e4d			 
1e4d			 
1e4d			 
1e4d			macro_dsp_valuehl: 
1e4d				FORTH_DSP_VALUE 
1e4d cd 36 1e			call macro_forth_dsp_value 
1e50				endm 
# End of macro FORTH_DSP_VALUE
1e50			 
1e50				;FORTH_ERR_TOS_NOTNUM 
1e50			 
1e50				;inc hl   ; skip type id 
1e50			 
1e50			;	push de 
1e50			; 
1e50			;	ld e, (hl) 
1e50			;	inc hl 
1e50			;	ld d, (hl) 
1e50			;	ex de,hl  
1e50			 
1e50			;	pop de 
1e50			 
1e50				if DEBUG_FORTH_PUSH 
1e50						DMARK "DVL" 
1e50 f5				push af  
1e51 3a 65 1e			ld a, (.dmark)  
1e54 32 6b ee			ld (debug_mark),a  
1e57 3a 66 1e			ld a, (.dmark+1)  
1e5a 32 6c ee			ld (debug_mark+1),a  
1e5d 3a 67 1e			ld a, (.dmark+2)  
1e60 32 6d ee			ld (debug_mark+2),a  
1e63 18 03			jr .pastdmark  
1e65 ..			.dmark: db "DVL"  
1e68 f1			.pastdmark: pop af  
1e69			endm  
# End of macro DMARK
1e69				CALLMONITOR 
1e69 cd 6f ee			call debug_vector  
1e6c				endm  
# End of macro CALLMONITOR
1e6c				endif 
1e6c c9				ret 
1e6d			 
1e6d			forth_apushstrhl:      
1e6d				; push of string requires use of cli_origptr 
1e6d				; bodge use 
1e6d			 
1e6d				; get current cli_origptr, save, update with temp pointer  
1e6d ed 5b 3e ea		ld de, (cli_origptr) 
1e71 22 3e ea			ld (cli_origptr), hl 
1e74 d5				push de 
1e75 cd bf 1d			call forth_apush 
1e78 d1				pop de 
1e79 ed 53 3e ea		ld (cli_origptr), de 
1e7d c9			        ret	 
1e7e			 
1e7e			 
1e7e			; increase loop stack pointer and save hl to it 
1e7e				 
1e7e			FORTH_LOOP_NEXT: macro 
1e7e				call macro_forth_loop_next 
1e7e				;nop 
1e7e				endm 
1e7e			 
1e7e			macro_forth_loop_next: 
1e7e				if DEBUG_FORTH_STACK_GUARD 
1e7e cd ae 61				call check_stacks 
1e81				endif 
1e81 e5				push hl 
1e82 d5				push de 
1e83 eb				ex de,hl 
1e84 2a f0 e9			ld hl,(cli_loop_sp) 
1e87 23				inc hl 
1e88 23				inc hl 
1e89					if DEBUG_FORTH_WORDS 
1e89						DMARK "LNX" 
1e89 f5				push af  
1e8a 3a 9e 1e			ld a, (.dmark)  
1e8d 32 6b ee			ld (debug_mark),a  
1e90 3a 9f 1e			ld a, (.dmark+1)  
1e93 32 6c ee			ld (debug_mark+1),a  
1e96 3a a0 1e			ld a, (.dmark+2)  
1e99 32 6d ee			ld (debug_mark+2),a  
1e9c 18 03			jr .pastdmark  
1e9e ..			.dmark: db "LNX"  
1ea1 f1			.pastdmark: pop af  
1ea2			endm  
# End of macro DMARK
1ea2						CALLMONITOR 
1ea2 cd 6f ee			call debug_vector  
1ea5				endm  
# End of macro CALLMONITOR
1ea5					endif 
1ea5 22 f0 e9			ld (cli_loop_sp),hl 
1ea8 73				ld (hl), e 
1ea9 23				inc hl 
1eaa 72				ld (hl), d 
1eab d1				pop de    ; been reversed so save a swap on restore 
1eac e1				pop hl 
1ead				if DEBUG_FORTH_STACK_GUARD 
1ead cd ae 61				call check_stacks 
1eb0				endif 
1eb0 c9				ret 
1eb1			 
1eb1			; get current ret stack pointer and save to hl  
1eb1				 
1eb1			FORTH_LOOP_TOS: macro 
1eb1				call macro_forth_loop_tos 
1eb1				endm 
1eb1			 
1eb1			macro_forth_loop_tos: 
1eb1 d5				push de 
1eb2 2a f0 e9			ld hl,(cli_loop_sp) 
1eb5 5e				ld e, (hl) 
1eb6 23				inc hl 
1eb7 56				ld d, (hl) 
1eb8 eb				ex de, hl 
1eb9 d1				pop de 
1eba c9				ret 
1ebb			 
1ebb			; pop loop stack pointer 
1ebb				 
1ebb			FORTH_LOOP_POP: macro 
1ebb				call macro_forth_loop_pop 
1ebb				endm 
1ebb			 
1ebb			 
1ebb			macro_forth_loop_pop: 
1ebb				if DEBUG_FORTH_STACK_GUARD 
1ebb					DMARK "LPP" 
1ebb f5				push af  
1ebc 3a d0 1e			ld a, (.dmark)  
1ebf 32 6b ee			ld (debug_mark),a  
1ec2 3a d1 1e			ld a, (.dmark+1)  
1ec5 32 6c ee			ld (debug_mark+1),a  
1ec8 3a d2 1e			ld a, (.dmark+2)  
1ecb 32 6d ee			ld (debug_mark+2),a  
1ece 18 03			jr .pastdmark  
1ed0 ..			.dmark: db "LPP"  
1ed3 f1			.pastdmark: pop af  
1ed4			endm  
# End of macro DMARK
1ed4 cd ae 61				call check_stacks 
1ed7					FORTH_CHK_LOOP_UNDER 
1ed7 e5				push hl 
1ed8 d5				push de 
1ed9 2a f0 e9			ld hl,(cli_loop_sp) 
1edc 11 2a e9			ld de, cli_loop_stack 
1edf cd 05 0e			call cmp16 
1ee2 da c8 62			jp c, fault_loop_under 
1ee5 d1				pop de 
1ee6 e1				pop hl 
1ee7				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ee7				endif 
1ee7 e5				push hl 
1ee8 2a f0 e9			ld hl,(cli_loop_sp) 
1eeb 2b				dec hl 
1eec 2b				dec hl 
1eed 22 f0 e9			ld (cli_loop_sp), hl 
1ef0				; TODO do stack underflow checks 
1ef0 e1				pop hl 
1ef1				if DEBUG_FORTH_STACK_GUARD 
1ef1 cd ae 61				call check_stacks 
1ef4					FORTH_CHK_LOOP_UNDER 
1ef4 e5				push hl 
1ef5 d5				push de 
1ef6 2a f0 e9			ld hl,(cli_loop_sp) 
1ef9 11 2a e9			ld de, cli_loop_stack 
1efc cd 05 0e			call cmp16 
1eff da c8 62			jp c, fault_loop_under 
1f02 d1				pop de 
1f03 e1				pop hl 
1f04				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1f04				endif 
1f04 c9				ret 
1f05			 
1f05			macro_forth_dsp_pop: 
1f05			 
1f05 e5				push hl 
1f06			 
1f06				; release malloc data 
1f06			 
1f06				if DEBUG_FORTH_STACK_GUARD 
1f06 cd ae 61				call check_stacks 
1f09					FORTH_CHK_DSP_UNDER 
1f09 e5				push hl 
1f0a d5				push de 
1f0b 2a ee e9			ld hl,(cli_data_sp) 
1f0e 11 28 e8			ld de, cli_data_stack 
1f11 cd 05 0e			call cmp16 
1f14 da bc 62			jp c, fault_dsp_under 
1f17 d1				pop de 
1f18 e1				pop hl 
1f19				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f19				endif 
1f19				;ld hl,(cli_data_sp) 
1f19			if DEBUG_FORTH_DOT 
1f19				DMARK "DPP" 
1f19 f5				push af  
1f1a 3a 2e 1f			ld a, (.dmark)  
1f1d 32 6b ee			ld (debug_mark),a  
1f20 3a 2f 1f			ld a, (.dmark+1)  
1f23 32 6c ee			ld (debug_mark+1),a  
1f26 3a 30 1f			ld a, (.dmark+2)  
1f29 32 6d ee			ld (debug_mark+2),a  
1f2c 18 03			jr .pastdmark  
1f2e ..			.dmark: db "DPP"  
1f31 f1			.pastdmark: pop af  
1f32			endm  
# End of macro DMARK
1f32				CALLMONITOR 
1f32 cd 6f ee			call debug_vector  
1f35				endm  
# End of macro CALLMONITOR
1f35			endif	 
1f35			 
1f35			 
1f35			if FORTH_ENABLE_DSPPOPFREE 
1f35			 
1f35				FORTH_DSP 
1f35 cd 13 1e			call macro_forth_dsp 
1f38				endm 
# End of macro FORTH_DSP
1f38			 
1f38 7e				ld a, (hl) 
1f39 fe 01			cp DS_TYPE_STR 
1f3b 20 23			jr nz, .skippopfree 
1f3d			 
1f3d				FORTH_DSP_VALUEHL 
1f3d cd 4d 1e			call macro_dsp_valuehl 
1f40				endm 
# End of macro FORTH_DSP_VALUEHL
1f40 00				nop 
1f41			if DEBUG_FORTH_DOT 
1f41				DMARK "DPf" 
1f41 f5				push af  
1f42 3a 56 1f			ld a, (.dmark)  
1f45 32 6b ee			ld (debug_mark),a  
1f48 3a 57 1f			ld a, (.dmark+1)  
1f4b 32 6c ee			ld (debug_mark+1),a  
1f4e 3a 58 1f			ld a, (.dmark+2)  
1f51 32 6d ee			ld (debug_mark+2),a  
1f54 18 03			jr .pastdmark  
1f56 ..			.dmark: db "DPf"  
1f59 f1			.pastdmark: pop af  
1f5a			endm  
# End of macro DMARK
1f5a				CALLMONITOR 
1f5a cd 6f ee			call debug_vector  
1f5d				endm  
# End of macro CALLMONITOR
1f5d			endif	 
1f5d cd 78 13			call free 
1f60			.skippopfree: 
1f60				 
1f60			 
1f60			endif 
1f60			 
1f60			if DEBUG_FORTH_DOT_KEY 
1f60				DMARK "DP2" 
1f60				CALLMONITOR 
1f60			endif	 
1f60			 
1f60				; move pointer down 
1f60			 
1f60 2a ee e9			ld hl,(cli_data_sp) 
1f63 2b				dec hl 
1f64 2b				dec hl 
1f65			; PARSEV5 
1f65 2b				dec hl 
1f66 22 ee e9			ld (cli_data_sp), hl 
1f69			 
1f69				if DEBUG_FORTH_STACK_GUARD 
1f69 cd ae 61				call check_stacks 
1f6c					FORTH_CHK_DSP_UNDER 
1f6c e5				push hl 
1f6d d5				push de 
1f6e 2a ee e9			ld hl,(cli_data_sp) 
1f71 11 28 e8			ld de, cli_data_stack 
1f74 cd 05 0e			call cmp16 
1f77 da bc 62			jp c, fault_dsp_under 
1f7a d1				pop de 
1f7b e1				pop hl 
1f7c				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f7c				endif 
1f7c			 
1f7c e1				pop hl 
1f7d			 
1f7d c9				ret 
1f7e			 
1f7e			getwordathl: 
1f7e				; hl points to an address 
1f7e				; load hl with the word at that address 
1f7e			 
1f7e d5				push de 
1f7f			 
1f7f 5e				ld e, (hl) 
1f80 23				inc hl 
1f81 56				ld d, (hl) 
1f82 eb				ex de, hl 
1f83			 
1f83 d1				pop de 
1f84 c9				ret 
1f85			 
1f85			 
1f85			 
1f85			 
1f85			 
1f85			; eof 
1f85			 
# End of file forth_stackopsv5.asm
1f85			endif 
1f85			 
1f85			loadwordinhl:	 
1f85			 
1f85 d5				push de 
1f86			 
1f86 5e				ld e, (hl) 
1f87 23				inc hl 
1f88 56				ld d, (hl) 
1f89 eb				ex de,hl  
1f8a			 
1f8a d1				pop de 
1f8b			 
1f8b c9				ret 
1f8c			 
1f8c			user_word_eol:  
1f8c				; hl contains the pointer to where to create a linked list item from the end 
1f8c				; of the user dict to continue on at the system word dict 
1f8c				 
1f8c				; poke the stub of the word list linked list to repoint to rom words 
1f8c			 
1f8c				; stub format 
1f8c				; db   word id 
1f8c				; dw    link to next word 
1f8c			        ; db char length of token 
1f8c				; db string + 0 term 
1f8c				; db exec code....  
1f8c			 
1f8c 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1f8e 77				ld (hl), a		; word id 
1f8f 23				inc hl 
1f90			 
1f90 11 5b 21			ld de, sysdict 
1f93 73				ld (hl), e		; next word link ie system dict 
1f94 23				inc hl 
1f95 72				ld (hl), d		; next word link ie system dict 
1f96 23				inc hl	 
1f97			 
1f97			;	ld (hl), sysdict		; next word link ie system dict 
1f97			;	inc hl 
1f97			;	inc hl 
1f97			 
1f97			;	inc hl 
1f97			;	inc hl 
1f97			 
1f97 3e 02			ld a, 2			; word length is 0 
1f99 77				ld (hl), a	 
1f9a 23				inc hl 
1f9b			 
1f9b 3e 7e			ld a, '~'			; word length is 0 
1f9d 77				ld (hl), a	 
1f9e 23				inc hl 
1f9f 3e 00			ld a, 0			; save empty word 
1fa1 77				ld (hl), a 
1fa2			 
1fa2 c9				ret 
1fa3			 
1fa3				 
1fa3			 
1fa3			forthexec_cleanup: 
1fa3				FORTH_RSP_POP 
1fa3 cd 1e 1c			call macro_forth_rsp_pop 
1fa6				endm 
# End of macro FORTH_RSP_POP
1fa6 c9				ret 
1fa7			 
1fa7			forth_call_hl: 
1fa7				; taking hl 
1fa7 e5				push hl 
1fa8 c9				ret 
1fa9			 
1fa9			; this is called to reset Forth system but keep existing uwords etc 
1fa9			 
1fa9			forth_warmstart: 
1fa9				; setup stack over/under flow checks 
1fa9				if DEBUG_FORTH_STACK_GUARD 
1fa9 cd 94 61				call chk_stk_init 
1fac				endif 
1fac			 
1fac				; init stack pointers  - * these stacks go upwards *  
1fac 21 ac e9			ld hl, cli_ret_stack 
1faf 22 f2 e9			ld (cli_ret_sp), hl	 
1fb2				; set bottom of stack 
1fb2 3e 00			ld a,0 
1fb4 77				ld (hl),a 
1fb5 23				inc hl 
1fb6 77				ld (hl),a 
1fb7			 
1fb7 21 28 e8			ld hl, cli_data_stack 
1fba 22 ee e9			ld (cli_data_sp), hl	 
1fbd				; set bottom of stack 
1fbd 3e 00			ld a,0 
1fbf 77				ld (hl),a 
1fc0 23				inc hl 
1fc1 77				ld (hl),a 
1fc2			 
1fc2 21 2a e9			ld hl, cli_loop_stack 
1fc5 22 f0 e9			ld (cli_loop_sp), hl	 
1fc8				; set bottom of stack 
1fc8 3e 00			ld a,0 
1fca 77				ld (hl),a 
1fcb 23				inc hl 
1fcc 77				ld (hl),a 
1fcd			 
1fcd				; init extent of current open file 
1fcd			 
1fcd 3e 00			ld a, 0 
1fcf 32 6a ea			ld (store_openext), a 
1fd2			 
1fd2 c9				ret 
1fd3			 
1fd3			 
1fd3			 
1fd3			; Cold Start - this is called to setup the whole Forth system 
1fd3			 
1fd3			forth_init: 
1fd3			 
1fd3				; setup stack over/under flow checks 
1fd3			 
1fd3			;	if DEBUG_FORTH_STACK_GUARD 
1fd3			;		call chk_stk_init 
1fd3			;	endif 
1fd3			 
1fd3				; enable auto display updates (slow.....) 
1fd3			 
1fd3 3e 01			ld a, 1 
1fd5 32 3c ea			ld (cli_autodisplay), a 
1fd8			 
1fd8				; if storage is in use disable long reads for now 
1fd8 3e 00			ld a, 0 
1fda 32 75 ea			ld (store_longread), a 
1fdd			 
1fdd			 
1fdd				; show start up screen 
1fdd			 
1fdd cd ba 0b			call clear_display 
1fe0			 
1fe0 3e 00			ld a,0 
1fe2 32 5e ea			ld (f_cursor_ptr), a 
1fe5			 
1fe5				; set start of word list in start of ram - for use when creating user words 
1fe5			 
1fe5 21 a0 65			ld hl, baseram 
1fe8 22 be e5			ld (os_last_new_uword), hl 
1feb cd 8c 1f			call user_word_eol 
1fee				 
1fee			;		call display_data_sp 
1fee			;		call next_page_prompt 
1fee			 
1fee			 
1fee			 
1fee			 
1fee c9				ret 
1fef			 
1fef .. 00		.bootforth: db " Forth Kernel Init ",0 
2003			 
2003			; TODO push to stack 
2003			 
2003			;  
2003			 
2003			if FORTH_PARSEV2 
2003			 
2003			 
2003				include "forth_parserv2.asm" 
2003			 
2003			endif 
2003			 
2003			 
2003			; parse cli version 1 
2003			 
2003			if FORTH_PARSEV1 
2003			 
2003			 
2003			 
2003			      include "forth_parserv1.asm" 
2003			endif 
2003				 
2003			if FORTH_PARSEV3 
2003			 
2003			 
2003			 
2003			      include "forth_parserv3.asm" 
2003				include "forth_wordsv3.asm" 
2003			endif 
2003			 
2003			if FORTH_PARSEV4 
2003			 
2003			 
2003			 
2003			      include "forth_parserv4.asm" 
2003				include "forth_wordsv4.asm" 
2003			endif 
2003			 
2003			if FORTH_PARSEV5 
2003			 
2003			 
2003			 
2003			      include "forth_parserv5.asm" 
2003			 
2003			 
2003			; A better parser without using malloc and string copies all over the place.  
2003			; Exec in situ should be faster 
2003			 
2003			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2003			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2003			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2003			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2003			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2003			WORD_SYS_END: equ 0   ; Opcode for all user words 
2003			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2003			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2003			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2003			 
2003			; Core word preamble macro 
2003			 
2003			CWHEAD:   macro nxtword opcode lit len opflags 
2003				db WORD_SYS_CORE+opcode             
2003				; internal op code number 
2003				dw nxtword            
2003				; link to next dict word block 
2003				db len + 1 
2003				; literal length of dict word inc zero term 
2003				db lit,0              
2003				; literal dict word 
2003			        ; TODO db opflags        
2003				endm 
2003			 
2003			 
2003			NEXTW: macro  
2003				jp macro_next 
2003				endm 
2003			 
2003			macro_next: 
2003			if DEBUG_FORTH_PARSE_KEY 
2003				DMARK "NXT" 
2003				CALLMONITOR 
2003			endif	 
2003			;	inc hl  ; skip token null term  
2003 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2007 ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
200b 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
200e			if DEBUG_FORTH_PARSE_KEY 
200e				DMARK "}AA" 
200e				CALLMONITOR 
200e			endif	 
200e c3 11 21			jp execnext 
2011				;jp exec1 
2011			       
2011			 
2011			 
2011			; Another go at the parser to compile  
2011			 
2011			 
2011			; TODO rework parser to change all of the string words to byte tokens 
2011			; TODO do a search for  
2011			 
2011			; TODO first run normal parser to zero term sections 
2011			; TODO for each word do a token look up to get the op code 
2011			; TODO need some means to flag to the exec that this is a byte code form    
2011			 
2011			 
2011			forthcompile: 
2011			 
2011			; 
2011			; line parse: 
2011			;       parse raw input buffer 
2011			;       tokenise the words 
2011			;       malloc new copy (for looping etc) 
2011			;       copy to malloc + current pc in line to start of string and add line term 
2011			;       save on new rsp 
2011			; 
2011			 
2011			; hl to point to the line to tokenise 
2011			 
2011			;	push hl 
2011 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
2014			 
2014			;	ld a,0		; string term on input 
2014			;	call strlent 
2014			 
2014			;	ld (os_tok_len), hl	 ; save string length 
2014			 
2014			;if DEBUG_FORTH_TOK 
2014			;	ex de,hl		 
2014			;endif 
2014			 
2014			;	pop hl 		; get back string pointer 
2014			 
2014			if DEBUG_FORTH_TOK 
2014						DMARK "TOc" 
2014				CALLMONITOR 
2014			endif 
2014 7e			.cptoken2:    ld a,(hl) 
2015 23				inc hl 
2016 fe 7f			cp FORTH_END_BUFFER 
2018 28 29			jr z, .cptokendone2 
201a fe 00			cp 0 
201c 28 25			jr z, .cptokendone2 
201e fe 22			cp '"' 
2020 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2022 fe 20			cp ' ' 
2024 20 ee			jr nz,  .cptoken2 
2026			 
2026			; TODO consume comments held between ( and ) 
2026			 
2026				; we have a space so change to zero term for dict match later 
2026 2b				dec hl 
2027 3e 00			ld a,0 
2029 77				ld (hl), a 
202a 23				inc hl 
202b 18 e7			jr .cptoken2 
202d				 
202d			 
202d			.cptokenstr2: 
202d				; skip all white space until either eol (because forgot to term) or end double quote 
202d			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
202d				;inc hl ; skip current double quote 
202d 7e				ld a,(hl) 
202e 23				inc hl 
202f fe 22			cp '"' 
2031 28 e1			jr z, .cptoken2 
2033 fe 7f			cp FORTH_END_BUFFER 
2035 28 0c			jr z, .cptokendone2 
2037 fe 00			cp 0 
2039 28 08			jr z, .cptokendone2 
203b fe 20			cp ' ' 
203d 28 02			jr z, .cptmp2 
203f 18 ec			jr .cptokenstr2 
2041			 
2041			.cptmp2:	; we have a space so change to zero term for dict match later 
2041				;dec hl 
2041				;ld a,"-"	; TODO remove this when working 
2041				;ld (hl), a 
2041				;inc hl 
2041 18 ea			jr .cptokenstr2 
2043			 
2043			.cptokendone2: 
2043				;inc hl 
2043 3e 7f			ld a, FORTH_END_BUFFER 
2045 77				ld (hl),a 
2046 23				inc hl 
2047 3e 21			ld a, '!' 
2049 77				ld (hl),a 
204a			 
204a 2a c2 e5			ld hl,(os_tok_ptr) 
204d			         
204d			if DEBUG_FORTH_TOK 
204d						DMARK "Tc1" 
204d				CALLMONITOR 
204d			endif 
204d			 
204d				; push exec string to top of return stack 
204d				FORTH_RSP_NEXT 
204d cd fd 1b			call macro_forth_rsp_next 
2050				endm 
# End of macro FORTH_RSP_NEXT
2050 c9				ret 
2051			 
2051			; Another go at the parser need to simplify the process 
2051			 
2051			forthparse: 
2051			 
2051			; 
2051			; line parse: 
2051			;       parse raw input buffer 
2051			;       tokenise the words 
2051			;       malloc new copy (for looping etc) 
2051			;       copy to malloc + current pc in line to start of string and add line term 
2051			;       save on new rsp 
2051			; 
2051			 
2051			; hl to point to the line to tokenise 
2051			 
2051			;	push hl 
2051 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
2054			 
2054			;	ld a,0		; string term on input 
2054			;	call strlent 
2054			 
2054			;	ld (os_tok_len), hl	 ; save string length 
2054			 
2054			;if DEBUG_FORTH_TOK 
2054			;	ex de,hl		 
2054			;endif 
2054			 
2054			;	pop hl 		; get back string pointer 
2054			 
2054			if DEBUG_FORTH_TOK 
2054						DMARK "TOK" 
2054				CALLMONITOR 
2054			endif 
2054 7e			.ptoken2:    ld a,(hl) 
2055 23				inc hl 
2056 fe 7f			cp FORTH_END_BUFFER 
2058 28 29			jr z, .ptokendone2 
205a fe 00			cp 0 
205c 28 25			jr z, .ptokendone2 
205e fe 22			cp '"' 
2060 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2062 fe 20			cp ' ' 
2064 20 ee			jr nz,  .ptoken2 
2066			 
2066			; TODO consume comments held between ( and ) 
2066			 
2066				; we have a space so change to zero term for dict match later 
2066 2b				dec hl 
2067 3e 00			ld a,0 
2069 77				ld (hl), a 
206a 23				inc hl 
206b 18 e7			jr .ptoken2 
206d				 
206d			 
206d			.ptokenstr2: 
206d				; skip all white space until either eol (because forgot to term) or end double quote 
206d			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
206d				;inc hl ; skip current double quote 
206d 7e				ld a,(hl) 
206e 23				inc hl 
206f fe 22			cp '"' 
2071 28 e1			jr z, .ptoken2 
2073 fe 7f			cp FORTH_END_BUFFER 
2075 28 0c			jr z, .ptokendone2 
2077 fe 00			cp 0 
2079 28 08			jr z, .ptokendone2 
207b fe 20			cp ' ' 
207d 28 02			jr z, .ptmp2 
207f 18 ec			jr .ptokenstr2 
2081			 
2081			.ptmp2:	; we have a space so change to zero term for dict match later 
2081				;dec hl 
2081				;ld a,"-"	; TODO remove this when working 
2081				;ld (hl), a 
2081				;inc hl 
2081 18 ea			jr .ptokenstr2 
2083			 
2083			.ptokendone2: 
2083				;inc hl 
2083 3e 7f			ld a, FORTH_END_BUFFER 
2085 77				ld (hl),a 
2086 23				inc hl 
2087 3e 21			ld a, '!' 
2089 77				ld (hl),a 
208a			 
208a 2a c2 e5			ld hl,(os_tok_ptr) 
208d			         
208d			if DEBUG_FORTH_TOK 
208d						DMARK "TK1" 
208d				CALLMONITOR 
208d			endif 
208d			 
208d				; push exec string to top of return stack 
208d				FORTH_RSP_NEXT 
208d cd fd 1b			call macro_forth_rsp_next 
2090				endm 
# End of macro FORTH_RSP_NEXT
2090 c9				ret 
2091			 
2091			; 
2091			;	; malloc size + buffer pointer + if is loop flag 
2091			;	ld hl,(os_tok_len) 		 ; get string length 
2091			; 
2091			;	ld a,l 
2091			; 
2091			;	cp 0			; we dont want to use a null string 
2091			;	ret z 
2091			; 
2091			;;	add 3    ; prefix malloc with buffer for current word ptr 
2091			; 
2091			;	add 5     ; TODO when certain not over writing memory remove 
2091			; 
2091			;		 
2091			; 
2091			;if DEBUG_FORTH_TOK 
2091			;			DMARK "TKE" 
2091			;	CALLMONITOR 
2091			;endif 
2091			; 
2091			;	ld l,a 
2091			;	ld h,0 
2091			;;	push hl   ; save required space for the copy later 
2091			;	call malloc 
2091			;if DEBUG_FORTH_TOK 
2091			;			DMARK "TKM" 
2091			;	CALLMONITOR 
2091			;endif 
2091			;	if DEBUG_FORTH_MALLOC_GUARD 
2091			;		push af 
2091			;		call ishlzero 
2091			;;		ld a, l 
2091			;;		add h 
2091			;;		cp 0 
2091			;		pop af 
2091			;		 
2091			;		call z,malloc_error 
2091			;	endif 
2091			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2091			; 
2091			; 
2091			;if DEBUG_FORTH_TOK 
2091			;			DMARK "TKR" 
2091			;	CALLMONITOR 
2091			;endif 
2091			; 
2091			;	FORTH_RSP_NEXT 
2091			; 
2091			;	;inc hl	 ; go past current buffer pointer 
2091			;	;inc hl 
2091			;	;inc hl   ; and past if loop flag 
2091			;		; TODO Need to set flag  
2091			; 
2091			;	 
2091			;	 
2091			;	ex de,hl	; malloc is dest 
2091			;	ld hl, (os_tok_len) 
2091			;;	pop bc 
2091			;	ld c, l                
2091			;	ld b,0 
2091			;	ld hl, (os_tok_ptr) 
2091			; 
2091			;if DEBUG_FORTH_TOK 
2091			;			DMARK "TKT" 
2091			;	CALLMONITOR 
2091			;endif 
2091			; 
2091			;	; do str cpy 
2091			; 
2091			;	ldir      ; copy byte in hl to de 
2091			; 
2091			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2091			; 
2091			;if DEBUG_FORTH_TOK 
2091			; 
2091			;			DMARK "TKY" 
2091			;	CALLMONITOR 
2091			;endif 
2091			;	;ld a,0 
2091			;	;ld a,FORTH_END_BUFFER 
2091			;	ex de, hl 
2091			;	;dec hl			 ; go back over the space delim at the end of word 
2091			;	;ld (hl),a 
2091			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2091			;	ld a,FORTH_END_BUFFER 
2091			;	ld (hl),a 
2091			;	inc hl 
2091			;	ld a,FORTH_END_BUFFER 
2091			;	ld (hl),a 
2091			; 
2091			;	; init the malloc area data 
2091			;	; set pc for in current area 
2091			;	;ld hl, (os_tok_malloc) 
2091			;	;inc hl 
2091			;	;inc hl 
2091			;	;inc hl 
2091			;	;ex de,hl 
2091			;	;ld hl, (os_tok_malloc) 
2091			;	;ld (hl),e 
2091			;	;inc hl 
2091			;	;ld (hl),d 
2091			; 
2091			; 
2091			;	ld hl,(os_tok_malloc) 
2091			;if DEBUG_FORTH_PARSE_KEY 
2091			;			DMARK "TKU" 
2091			;	CALLMONITOR 
2091			;endif 
2091			; 
2091			;	ret 
2091			 
2091			forthexec: 
2091			 
2091			; line exec: 
2091			; forth parser 
2091			 
2091			; 
2091			;       get current exec line on rsp 
2091			 
2091				FORTH_RSP_TOS 
2091 cd 14 1c			call macro_forth_rsp_tos 
2094				endm 
# End of macro FORTH_RSP_TOS
2094			 
2094			;       restore current pc - hl points to malloc of data 
2094			 
2094				;ld e, (hl) 
2094				;inc hl 
2094				;ld d, (hl) 
2094				;ex de,hl 
2094			 
2094			 
2094			exec1: 
2094 22 c2 e5			ld (os_tok_ptr), hl 
2097			 
2097				; copy our PC to working vars  
2097 22 40 ea			ld (cli_ptr), hl 
209a 22 3e ea			ld (cli_origptr), hl 
209d			 
209d 7e				ld a,(hl) 
209e fe 7f			cp FORTH_END_BUFFER 
20a0 c8				ret z 
20a1			 
20a1				; skip any nulls 
20a1			 
20a1 fe 00			cp 0 
20a3 20 03			jr nz, .execword 
20a5 23				inc hl 
20a6 18 ec			jr exec1 
20a8			 
20a8			 
20a8			.execword: 
20a8			 
20a8			 
20a8			 
20a8			if DEBUG_FORTH_PARSE_KEY 
20a8						DMARK "KYQ" 
20a8				CALLMONITOR 
20a8			endif 
20a8			;       while at start of word: 
20a8			; get start of dict (in user area first) 
20a8			 
20a8 21 a0 65		ld hl, baseram 
20ab			;ld hl, sysdict 
20ab 22 42 ea		ld (cli_nextword),hl 
20ae			;           match word at pc 
20ae			;           exec word 
20ae			;           or push to dsp 
20ae			;           forward to next token 
20ae			;           if line term pop rsp and exit 
20ae			;        
20ae			 
20ae			if DEBUG_FORTH_PARSE_KEY 
20ae						DMARK "KYq" 
20ae				CALLMONITOR 
20ae			endif 
20ae			 
20ae			; 
20ae			; word comp 
20ae			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
20ae			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
20ae			;    move to start of word  
20ae			;    compare word to cli_token 
20ae			 
20ae			.execpnword:	; HL at start of a word in the dictionary to check 
20ae			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
20ae			;	ld (cli_ptr), hl 
20ae			 
20ae 2a 42 ea			ld hl,(cli_nextword) 
20b1			 
20b1 cd 54 21			call forth_tok_next 
20b4			; tok next start here 
20b4			;	; TODO skip compiled symbol for now 
20b4			;	inc hl 
20b4			; 
20b4			;	; save pointer to next word 
20b4			; 
20b4			;	; hl now points to the address of the next word pointer  
20b4			;	ld e, (hl) 
20b4			;	inc hl 
20b4			;	ld d, (hl) 
20b4			;	inc l 
20b4			; 
20b4			;	ex de,hl 
20b4			;if DEBUG_FORTH_PARSE_NEXTWORD 
20b4			;	push bc 
20b4			;	ld bc, (cli_nextword) 
20b4			;			DMARK "NXW" 
20b4			;	CALLMONITOR 
20b4			;	pop bc 
20b4			;endif 
20b4			; tok next end here 
20b4 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
20b7 eb				ex de, hl 
20b8			 
20b8			 
20b8				; save the pointer of the current token - 1 to check against 
20b8				 
20b8 22 46 ea			ld (cli_token), hl   
20bb				; TODO maybe remove below save if no debug 
20bb				; save token string ptr for any debug later 
20bb 23				inc hl  
20bc 22 48 ea			ld (cli_origtoken), hl 
20bf 2b				dec hl 
20c0				; save pointer to the start of the next dictionay word 
20c0 7e				ld a,(hl)   ; get string length 
20c1 47				ld b,a 
20c2			.execpnwordinc:  
20c2 23				inc hl 
20c3 10 fd			djnz .execpnwordinc 
20c5 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
20c8			 
20c8				; now check the word token against the string being parsed 
20c8			 
20c8 2a 46 ea			ld hl,(cli_token) 
20cb 23				inc hl     ; skip string length (use zero term instead to end) 
20cc 22 46 ea			ld (cli_token), hl 
20cf			 
20cf			if DEBUG_FORTH_PARSE_KEY 
20cf						DMARK "KY2" 
20cf			endif 
20cf			if DEBUG_FORTH_PARSE_EXEC 
20cf				; see if disabled 
20cf			 
20cf			;	ld a, (os_view_disable) 
20cf			;	cp '*' 
20cf				ld a, (debug_vector) 
20cf				cp $c9   ; RET  
20cf				jr z, .skip 
20cf			 
20cf				push hl 
20cf				push hl 
20cf				call clear_display 
20cf				ld de, .compword 
20cf				ld a, display_row_1 
20cf				call str_at_display 
20cf				pop de 
20cf				ld a, display_row_2 
20cf				call str_at_display 
20cf				ld hl,(cli_ptr) 
20cf				ld a,(hl) 
20cf			        ld hl, os_word_scratch 
20cf				ld (hl),a 
20cf				ld a,0 
20cf				inc hl 
20cf				ld (hl),a 	 
20cf				ld de, os_word_scratch 
20cf				ld a, display_row_2+10 
20cf				call str_at_display 
20cf				call update_display 
20cf				ld a, 100 
20cf				call aDelayInMS 
20cf				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20cf				call delay250ms 
20cf				endif 
20cf				pop hl 
20cf			.skip:  
20cf			endif	 
20cf			.execpnchar:    ; compare char between token and string to parse 
20cf			 
20cf			if DEBUG_FORTH_PARSE_KEY 
20cf						DMARK "Ky3" 
20cf			endif 
20cf			if DEBUG_FORTH_PARSE_EXEC 
20cf				; see if disabled 
20cf			 
20cf			;	ld a, (os_view_disable) 
20cf			;	cp '*' 
20cf				ld a, (debug_vector) 
20cf				cp $C9  ; RET 
20cf				jr z, .skip2 
20cf			 
20cf			;	call clear_display 
20cf			ld hl,(cli_token) 
20cf			ld a,(hl) 
20cf			ld (os_word_scratch),a 
20cf				ld hl,(cli_ptr) 
20cf			ld a,(hl) 
20cf				ld (os_word_scratch+1),a 
20cf				ld a,0 
20cf				ld (os_word_scratch+2),a 
20cf				ld de,os_word_scratch 
20cf				ld a,display_row_4 
20cf				call str_at_display 
20cf				call update_display 
20cf			.skip2:  
20cf			endif 
20cf 2a 46 ea			ld hl,(cli_token) 
20d2 7e				ld a, (hl)	 ; char in word token 
20d3 23				inc hl 		; move to next char 
20d4 22 46 ea			ld (cli_token), hl ; and save it 
20d7 47				ld b,a 
20d8			 
20d8 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
20db 7e				ld a,(hl) 
20dc 23				inc hl 
20dd 22 40 ea			ld (cli_ptr), hl		; move to next char 
20e0 cd 3c 12			call toUpper 		; make sure the input string matches case 
20e3			 
20e3			if DEBUG_FORTH_PARSE 
20e3			endif 
20e3			 
20e3				; input stream end of token is a space so get rid of it 
20e3			 
20e3			;	cp ' ' 
20e3			;	jr nz, .pnskipspace 
20e3			; 
20e3			;	ld a, 0		; make same term as word token term 
20e3			; 
20e3			;.pnskipspace: 
20e3			 
20e3			if DEBUG_FORTH_PARSE_KEY 
20e3						DMARK "KY7" 
20e3			endif 
20e3 b8				cp b 
20e4 c2 fa 20			jp nz, .execpnskipword	 ; no match so move to next word 
20e7				 
20e7			;    if same 
20e7			;       scan for string terms 0 for token and 32 for input 
20e7			 
20e7				 
20e7			if DEBUG_FORTH_PARSE_KEY 
20e7						DMARK "KY8" 
20e7			endif 
20e7			 
20e7 80				add b			 
20e8 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
20ea							; TODO need to make sure last word in zero term string is accounted for 
20ea 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
20ec			 
20ec			 
20ec				; at end of both strings so both are exact match 
20ec			 
20ec			;       skip ptr for next word 
20ec			 
20ec 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
20ef 23				inc hl			 ; at next char 
20f0 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
20f3 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
20f6				 
20f6				 
20f6			if DEBUG_FORTH_PARSE_KEY 
20f6						DMARK "KY3" 
20f6			endif 
20f6			 
20f6			 
20f6			 
20f6			;       exec code block 
20f6			if DEBUG_FORTH_JP 
20f6				call clear_display 
20f6				call update_display 
20f6				call delay1s 
20f6				ld hl, (cli_execword)     ; save for next check if no match on this word 
20f6				ld a,h 
20f6				ld hl, os_word_scratch 
20f6				call hexout 
20f6				ld hl, (cli_execword)     ; save for next check if no match on this word 
20f6				ld a,l 
20f6				ld hl, os_word_scratch+2 
20f6				call hexout 
20f6				ld hl, os_word_scratch+4 
20f6				ld a,0 
20f6				ld (hl),a 
20f6				ld de,os_word_scratch 
20f6				call str_at_display 
20f6					ld a, display_row_2 
20f6					call str_at_display 
20f6				ld de, (cli_origtoken) 
20f6				ld a, display_row_1+10 
20f6					call str_at_display 
20f6			 
20f6				ld a,display_row_1 
20f6				ld de, .foundword 
20f6				ld a, display_row_3 
20f6				call str_at_display 
20f6				call update_display 
20f6				call delay1s 
20f6				call delay1s 
20f6				call delay1s 
20f6			endif 
20f6			 
20f6			if DEBUG_FORTH_PARSE_KEY 
20f6						DMARK "KYj" 
20f6			endif 
20f6				; TODO save the word pointer in this exec 
20f6			 
20f6 2a 44 ea			ld hl,(cli_execword) 
20f9 e9				jp (hl) 
20fa			 
20fa			 
20fa			;    if not same 
20fa			;	scan for zero term 
20fa			;	get ptr for next word 
20fa			;	goto word comp 
20fa			 
20fa			.execpnskipword:	; get pointer to next word 
20fa 2a 42 ea			ld hl,(cli_nextword) 
20fd			 
20fd 7e				ld a,(hl) 
20fe fe 00			cp WORD_SYS_END 
2100			;	cp 0 
2100 28 09			jr z, .execendofdict			 ; at end of words 
2102			 
2102			if DEBUG_FORTH_PARSE_KEY 
2102						DMARK "KY4" 
2102			endif 
2102			if DEBUG_FORTH_PARSE_EXEC 
2102			 
2102				; see if disabled 
2102			 
2102			;	ld a, (os_view_disable) 
2102			;	cp '*' 
2102				ld a,(debug_vector) 
2102				cp $c9   ; RET 
2102				jr z, .noskip 
2102			 
2102			 
2102				ld de, .nowordfound 
2102				ld a, display_row_3 
2102				call str_at_display 
2102				call update_display 
2102				ld a, 100 
2102				call aDelayInMS 
2102				 
2102				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2102					call delay250ms 
2102				endif 
2102			.noskip:  
2102			 
2102			endif	 
2102			 
2102 2a 3e ea			ld hl,(cli_origptr) 
2105 22 40 ea			ld (cli_ptr),hl 
2108			 
2108			if DEBUG_FORTH_PARSE_KEY 
2108						DMARK "KY5" 
2108			endif 
2108 c3 ae 20			jp .execpnword			; else go to next word 
210b			 
210b			.execendofdict:  
210b			 
210b			if DEBUG_FORTH_PARSE_KEY 
210b						DMARK "KYe" 
210b			endif 
210b			if DEBUG_FORTH_PARSE_EXEC 
210b				; see if disabled 
210b			 
210b			;	ld a, (os_view_disable) 
210b			;	cp '*' 
210b				ld a,(debug_vector) 
210b				cp $c9   ; ret 
210b				jr z, .ispskip 
210b			 
210b				call clear_display 
210b				call update_display 
210b				call delay1s 
210b				ld de, (cli_origptr) 
210b				ld a, display_row_1 
210b				call str_at_display 
210b				 
210b				ld de, .enddict 
210b				ld a, display_row_3 
210b				call str_at_display 
210b				call update_display 
210b				ld a, 100 
210b				call aDelayInMS 
210b				if DEBUG_FORTH_PARSE_EXEC_SLOW 
210b				call delay1s 
210b				call delay1s 
210b				call delay1s 
210b				endif 
210b			.ispskip:  
210b				 
210b			endif	 
210b			 
210b			 
210b			 
210b				; if the word is not a keyword then must be a literal so push it to stack 
210b			 
210b			; push token to stack to end of word 
210b			 
210b				STACKFRAME ON $1efe $2f9f 
210b				if DEBUG_STACK_IMB 
210b					if ON 
210b						exx 
210b						ld de, $1efe 
210b						ld a, d 
210b						ld hl, curframe 
210b						call hexout 
210b						ld a, e 
210b						ld hl, curframe+2 
210b						call hexout 
210b						ld hl, $1efe 
210b						push hl 
210b						ld hl, $2f9f 
210b						push hl 
210b						exx 
210b					endif 
210b				endif 
210b			endm 
# End of macro STACKFRAME
210b			 
210b 2a c2 e5		ld hl,(os_tok_ptr) 
210e cd bf 1d		call forth_apush 
2111			 
2111				STACKFRAMECHK ON $1efe $2f9f 
2111				if DEBUG_STACK_IMB 
2111					if ON 
2111						exx 
2111						ld hl, $2f9f 
2111						pop de   ; $2f9f 
2111						call cmp16 
2111						jr nz, .spnosame 
2111						ld hl, $1efe 
2111						pop de   ; $1efe 
2111						call cmp16 
2111						jr z, .spfrsame 
2111						.spnosame: call showsperror 
2111						.spfrsame: nop 
2111						exx 
2111					endif 
2111				endif 
2111			endm 
# End of macro STACKFRAMECHK
2111			 
2111			execnext: 
2111			 
2111			if DEBUG_FORTH_PARSE_KEY 
2111						DMARK "KY>" 
2111			endif 
2111			; move past token to next word 
2111			 
2111 2a c2 e5		ld hl, (os_tok_ptr) 
2114 3e 00		ld a, 0 
2116 01 ff 00		ld bc, 255     ; input buffer size 
2119 ed b1		cpir 
211b			 
211b			if DEBUG_FORTH_PARSE_KEY 
211b						DMARK "KY!" 
211b				CALLMONITOR 
211b			endif	 
211b			; TODO this might place hl on the null, so will need to forward on??? 
211b			;inc hl   ; see if this gets onto the next item 
211b			 
211b			 
211b			; TODO pass a pointer to the buffer to push 
211b			; TODO call function to push 
211b			 
211b			; look for end of input 
211b			 
211b			;inc hl 
211b			;ld a,(hl) 
211b			;cp FORTH_END_BUFFER 
211b			;ret z 
211b			 
211b			 
211b c3 94 20		jp exec1 
211e			 
211e			 
211e			 
211e			 
211e			 
211e			 
211e			 
211e			 
211e			 
211e			findnexttok: 
211e			 
211e				; hl is pointer to move 
211e				; de is the token to locate 
211e			 
211e					if DEBUG_FORTH 
211e						DMARK "NTK" 
211e						CALLMONITOR 
211e					endif 
211e d5				push de 
211f			 
211f			.fnt1:	 
211f				; find first char of token to locate 
211f			 
211f 1a				ld a, (de) 
2120 4f				ld c,a 
2121 7e				ld a,(hl) 
2122 cd 3c 12			call toUpper 
2125					if DEBUG_FORTH 
2125						DMARK "NT1" 
2125						CALLMONITOR 
2125					endif 
2125 b9				cp c 
2126			 
2126 28 03			jr z, .fnt2cmpmorefirst	 
2128			 
2128				; first char not found move to next char 
2128			 
2128 23				inc hl 
2129 18 f4			jr .fnt1 
212b			 
212b			.fnt2cmpmorefirst:	 
212b				; first char of token found.  
212b			 
212b e5				push hl     ; save start of token just in case it is the right one 
212c d9				exx 
212d e1				pop hl        ; save it to hl' 
212e d9				exx 
212f			 
212f			 
212f			.fnt2cmpmore:	 
212f				; compare the rest 
212f				 
212f 23				inc hl 
2130 13				inc de 
2131				 
2131 1a				ld a, (de) 
2132 4f				ld c,a 
2133 7e				ld a,(hl) 
2134 cd 3c 12			call toUpper 
2137			 
2137					if DEBUG_FORTH 
2137						DMARK "NT2" 
2137						CALLMONITOR 
2137					endif 
2137				; c has the token to find char 
2137				; a has the mem to scan char 
2137			 
2137 b9				cp c 
2138 28 04			jr z,.fntmatch1 
213a			 
213a				; they are not the same 
213a			 
213a					if DEBUG_FORTH 
213a						DMARK "NT3" 
213a						CALLMONITOR 
213a					endif 
213a d1				pop de	; reset de token to look for 
213b d5				push de 
213c 18 e1			jr .fnt1 
213e				 
213e			.fntmatch1: 
213e			 
213e				; is the same char a null which means we might have a full hit? 
213e					if DEBUG_FORTH 
213e						DMARK "NT4" 
213e						CALLMONITOR 
213e					endif 
213e			 
213e fe 00			cp 0 
2140 28 0b			jr z, .fntmatchyes 
2142			 
2142				; are we at the end of the token to find? 
2142			 
2142					if DEBUG_FORTH 
2142						DMARK "NT5" 
2142						CALLMONITOR 
2142					endif 
2142 3e 00			ld a, 0 
2144 b9				cp c 
2145			 
2145 c2 2f 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2148			 
2148					if DEBUG_FORTH 
2148						DMARK "NT6" 
2148						CALLMONITOR 
2148					endif 
2148				; token to find is exhusted but no match to stream 
2148			 
2148				; restore tok pointer and continue on 
2148 d1				pop de 
2149 d5				push de 
214a c3 1f 21			jp .fnt1 
214d			 
214d			 
214d			.fntmatchyes: 
214d			 
214d				; hl now contains the end of the found token 
214d			 
214d				; get rid of saved token pointer to find 
214d			 
214d d1				pop de 
214e			 
214e					if DEBUG_FORTH 
214e						DMARK "NT9" 
214e						CALLMONITOR 
214e					endif 
214e			 
214e				; hl will be on the null term so forward on 
214e			 
214e				; get back the saved start of the token 
214e			 
214e d9				exx 
214f e5				push hl     ; save start of token just in case it is the right one 
2150 d9				exx 
2151 e1				pop hl        ; save it to hl 
2152			 
2152 c9				ret 
2153			 
2153			 
2153			; LIST needs to find a specific token   
2153			; FORGET needs to find a spefici token 
2153			 
2153			; SAVE needs to find all tokens by flag 
2153			; WORDS just needs to scan through all  by flag 
2153			; UWORDS needs to scan through all by flag 
2153			 
2153			 
2153			; given hl as pointer to start of dict look up string 
2153			; return hl as pointer to start of word block 
2153			; or 0 if not found 
2153			 
2153			forth_find_tok: 
2153 c9				ret 
2154			 
2154			; given hl as pointer to dict structure 
2154			; move to the next dict block structure 
2154			 
2154			forth_tok_next: 
2154				; hl now points to the address of the next word pointer  
2154				; TODO skip compiled symbol for now 
2154			;	push de 
2154 23				inc hl 
2155 5e				ld e, (hl) 
2156 23				inc hl 
2157 56				ld d, (hl) 
2158 23				inc hl 
2159			 
2159 eb				ex de,hl 
215a			if DEBUG_FORTH_PARSE_NEXTWORD 
215a				push bc 
215a				ld bc, (cli_nextword) 
215a						DMARK "NXW" 
215a				CALLMONITOR 
215a				pop bc 
215a			endif 
215a			;	pop de	 
215a c9				ret 
215b			 
215b			 
215b			 
215b			; eof 
# End of file forth_parserv5.asm
215b				include "forth_wordsv4.asm" 
215b			 
215b			; the core word dictionary v4 
215b			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
215b			 
215b			; this is a linked list for each of the system words used 
215b			; user defined words will follow the same format but will be in ram 
215b			 
215b			 
215b			; 
215b			; 
215b			; define linked list: 
215b			; 
215b			; 1. compiled byte op code 
215b			; 2. len of text word 
215b			; 3. text word 
215b			; 4. ptr to next dictionary word 
215b			; 5. asm, calls etc for the word 
215b			; 
215b			;  if 1 == 0 then last word in dict  
215b			;   
215b			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
215b			;  
215b			;  
215b			; create basic standard set of words 
215b			; 
215b			;  
215b			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
215b			; 2DUP 2DROP 2SWAP  
215b			; @ C@ - get byte  
215b			; ! C! - store byte 
215b			; 0< true if less than zero 
215b			; 0= true if zero 
215b			; < >  
215b			; = true if same 
215b			; variables 
215b			 
215b			 
215b			; Hardware specific words I may need 
215b			; 
215b			; IN OUT  
215b			; calls to key util functions 
215b			; calls to hardward abstraction stuff 
215b			; easy control of frame buffers and lcd i/o 
215b			; keyboard  
215b			 
215b			 
215b			;DICT: macro 
215b			; op_code, len, word, next 
215b			;    word: 
215b			;    db op_code 
215b			;    ds word zero term 
215b			;    dw next 
215b			;    endm 
215b			 
215b			 
215b			 
215b			 
215b			; op code 1 is a flag for user define words which are to be handled differently 
215b			 
215b			 
215b			; 
215b			; 
215b			;    TODO on entry to a word this should be the expected environment 
215b			;    hl - tos value if number then held, if string this is the ptr 
215b			;    de -  
215b			 
215b			 
215b			; opcode ranges 
215b			; 0 - end of word dict 
215b			; 255 - user define words 
215b			 
215b			sysdict: 
215b			include "forth_opcodes.asm" 
215b			; op codes for forth keywords 
215b			; free to use code 0  
215b				OPCODE_HEAP: equ  1 
215b				OPCODE_EXEC: equ 2 
215b				OPCODE_DUP: equ 3 
215b				OPCODE_SWAP: equ 4 
215b				OPCODE_COLN: equ 5 
215b				OPCODE_SCOLN: equ 6 
215b				OPCODE_DROP: equ 7 
215b				OPCODE_DUP2: equ 8 
215b				OPCODE_DROP2: equ 9 
215b				OPCODE_SWAP2: equ 10 
215b				OPCODE_AT: equ 11 
215b				OPCODE_CAT: equ 12 
215b				OPCODE_BANG: equ 13 
215b				OPCODE_CBANG: equ 14 
215b				OPCODE_SCALL: equ 15 
215b				OPCODE_DEPTH: equ 16 
215b				OPCODE_OVER: equ 17 
215b				OPCODE_PAUSE: equ 18 
215b				OPCODE_PAUSES: equ 19 
215b				OPCODE_ROT: equ 20 
215b			;free to reuse	OPCODE_WORDS: equ 21 
215b			        OPCODE_NOT: equ 21 
215b				OPCODE_UWORDS: equ 22 
215b				OPCODE_BP: equ 23 
215b				OPCODE_MONITOR: equ 24  
215b				OPCODE_MALLOC: equ 25 
215b				OPCODE_FREE: equ 26 
215b				OPCODE_LIST: equ 27 
215b				OPCODE_FORGET: equ 28 
215b				OPCODE_NOP: equ 29 
215b				OPCODE_COMO: equ 30 
215b				OPCODE_COMC: equ 31 
215b			;free to reuse	OPCODE_ENDCORE: equ 32 
215b				OPCODE_AFTERSOUND: equ 33 
215b				OPCODE_GP2: equ 34 
215b				OPCODE_GP3: equ 35 
215b				OPCODE_GP4: equ 36 
215b				OPCODE_SIN: equ 37 
215b				OPCODE_SOUT: equ 38 
215b				OPCODE_SPIO: equ 39 
215b				OPCODE_SPICEH: equ 40 
215b				OPCODE_SPIOb: equ 41 
215b				OPCODE_SPII: equ 42 
215b				OPCODE_SESEL: equ 43 
215b				OPCODE_CARTDEV: equ 44 
215b			; free to reuse	OPCODE_ENDDEVICE: equ 45 
215b				OPCODE_FB: equ 46 
215b				OPCODE_EMIT: equ 47 
215b				OPCODE_DOTH: equ 48 
215b				OPCODE_DOTF: equ 49 
215b				OPCODE_DOT: equ 50 
215b				OPCODE_CLS: equ 51 
215b				OPCODE_DRAW: equ 52 
215b				OPCODE_DUMP: equ 53 
215b				OPCODE_CDUMP: equ 54 
215b				OPCODE_DAT: equ 55 
215b				OPCODE_HOME: equ 56 
215b				OPCODE_SPACE: equ 57 
215b				OPCODE_SPACES: equ 58 
215b				OPCODE_SCROLL: equ 59 
215b				OPCODE_ATQ: equ 60 
215b				OPCODE_AUTODSP: equ 61 
215b				OPCODE_MENU: equ 62 
215b			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
215b				OPCODE_THEN: equ 64 
215b				OPCODE_ELSE: equ 65 
215b				OPCODE_DO: equ 66 
215b				OPCODE_LOOP: equ 67 
215b				OPCODE_I: equ 68 
215b				OPCODE_DLOOP: equ 69  
215b				OPCODE_REPEAT: equ 70  
215b				OPCODE_UNTIL: equ 71 
215b				OPCODE_ENDFLOW: equ 72 
215b				OPCODE_WAITK: equ 73 
215b				OPCODE_ACCEPT: equ 74 
215b				OPCODE_EDIT: equ 75 
215b			;free to reuse	OPCODE_ENDKEY: equ 76 
215b				OPCODE_LZERO: equ 77 
215b				OPCODE_TZERO: equ 78 
215b				OPCODE_LESS: equ 79 
215b				OPCODE_GT: equ 80 
215b				OPCODE_EQUAL: equ 81  
215b			;free to reuse	OPCODE_ENDLOGIC: equ 82 
215b				OPCODE_NEG: equ 83 
215b				OPCODE_DIV: equ 84 
215b				OPCODE_MUL: equ 85 
215b				OPCODE_MIN: equ 86 
215b				OPCODE_MAX: equ 87 
215b				OPCODE_RND16: equ 88 
215b				OPCODE_RND8: equ 89 
215b				OPCODE_RND: equ 90 
215b			;free to reuse	OPCODE_ENDMATHS: equ 91  
215b				OPCODE_BYNAME: equ 92 
215b				OPCODE_DIR: equ 93 
215b				OPCODE_SAVE: equ 94 
215b				OPCODE_LOAD: equ 95 
215b				OPCODE_BSAVE: equ 96 
215b				OPCODE_BLOAD: equ 97 
215b				OPCODE_SEO: equ 98  
215b				OPCODE_SEI: equ 99 
215b				OPCODE_SFREE: equ 100 
215b				OPCODE_SIZE: equ 101 
215b				OPCODE_CREATE: equ 102 
215b				OPCODE_APPEND: equ 103 
215b				OPCODE_SDEL: equ 104 
215b				OPCODE_OPEN: equ 105 
215b				OPCODE_READ: equ 106 
215b				OPCODE_EOF: equ 106 
215b				OPCODE_FORMAT: equ 107 
215b				OPCODE_LABEL: equ 108 
215b				OPCODE_LABELS: equ 109 
215b			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
215b				OPCODE_UPPER: equ 111 
215b				OPCODE_LOWER: equ 112 
215b				OPCODE_SUBSTR: equ 113 
215b				OPCODE_LEFT: equ 114 
215b				OPCODE_RIGHT: equ 115 
215b				OPCODE_STR2NUM: equ 116 
215b				OPCODE_NUM2STR: equ 117 
215b				OPCODE_CONCAT: equ 118 
215b				OPCODE_FIND: equ 119 
215b				OPCODE_LEN: equ 120 
215b				OPCODE_CHAR: equ 121 
215b			; free to reuse	OPCODE_STRLEN: equ 122 
215b			; free to reuse	OPCODE_ENDSTR: equ 123 
215b				OPCODE_V0S: equ 124 
215b				OPCODE_V0Q: equ 125 
215b				OPCODE_V1S: equ 126 
215b				OPCODE_V1Q: equ 127 
215b				OPCODE_V2S: equ 128 
215b				OPCODE_V2Q: equ 129 
215b				OPCODE_V3S: equ 130 
215b				OPCODE_V3Q: equ 131 
215b			;free to reuse	OPCODE_END: equ 132 
215b				OPCODE_ZDUP: equ 133 
215b			 
215b			; eof 
# End of file forth_opcodes.asm
215b			 
215b			include "forth_words_core.asm" 
215b			 
215b			; | ## Core Words 
215b			 
215b			;if MALLOC_4 
215b			 
215b			.HEAP: 
215b				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
215b 15				db WORD_SYS_CORE+OPCODE_HEAP             
215c 9a 21			dw .EXEC            
215e 05				db 4 + 1 
215f .. 00			db "HEAP",0              
2164				endm 
# End of macro CWHEAD
2164			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2164			; | | u1 - Current number of bytes in the heap 
2164			; | | u2 - Remaining bytes left on the heap 
2164			; | |  
2164			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2164			 
2164			 
2164					if DEBUG_FORTH_WORDS_KEY 
2164						DMARK "HEP" 
2164 f5				push af  
2165 3a 79 21			ld a, (.dmark)  
2168 32 6b ee			ld (debug_mark),a  
216b 3a 7a 21			ld a, (.dmark+1)  
216e 32 6c ee			ld (debug_mark+1),a  
2171 3a 7b 21			ld a, (.dmark+2)  
2174 32 6d ee			ld (debug_mark+2),a  
2177 18 03			jr .pastdmark  
2179 ..			.dmark: db "HEP"  
217c f1			.pastdmark: pop af  
217d			endm  
# End of macro DMARK
217d						CALLMONITOR 
217d cd 6f ee			call debug_vector  
2180				endm  
# End of macro CALLMONITOR
2180					endif 
2180 2a aa 65				ld hl, (free_list )      
2183 11 af 65				ld de, heap_start 
2186			 
2186 ed 52				sbc hl, de  
2188			 
2188 cd 56 1c				call forth_push_numhl 
218b			 
218b			 
218b ed 5b aa 65			ld de, (free_list )      
218f 21 a8 e2				ld hl, heap_end 
2192			 
2192 ed 52				sbc hl, de 
2194			 
2194 cd 56 1c				call forth_push_numhl 
2197					 
2197			 
2197					 
2197			 
2197			 
2197			 
2197					NEXTW 
2197 c3 03 20			jp macro_next 
219a				endm 
# End of macro NEXTW
219a			;endif 
219a			 
219a			.EXEC: 
219a			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
219a			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
219a			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
219a			;; > > 
219a			;; > >   
219a			;	STACKFRAME OFF $5efe $5f9f 
219a			; 
219a			;		if DEBUG_FORTH_WORDS_KEY 
219a			;			DMARK "EXE" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			; 
219a			;	FORTH_DSP_VALUEHL 
219a			; 
219a			;	FORTH_DSP_POP 
219a			; 
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EX1" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			;;	ld e,(hl) 
219a			;;	inc hl 
219a			;;	ld d,(hl) 
219a			;;	ex de,hl 
219a			; 
219a			;;		if DEBUG_FORTH_WORDS 
219a			;;			DMARK "EX2" 
219a			;;			CALLMONITOR 
219a			;;		endif 
219a			;	push hl 
219a			; 
219a			;	;ld a, 0 
219a			;	;ld a, FORTH_END_BUFFER 
219a			;	call strlenz 
219a			;	inc hl   ; include zero term to copy 
219a			;	inc hl   ; include term 
219a			;	inc hl   ; include term 
219a			;	ld b,0 
219a			;	ld c,l 
219a			;	pop hl 
219a			;	ld de, execscratch 
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EX3" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			;	ldir 
219a			; 
219a			; 
219a			;	ld hl, execscratch 
219a			; 
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EXe" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			; 
219a			;	call forthparse 
219a			;	call forthexec 
219a			;;	call forthexec_cleanup 
219a			;;	call forthparse 
219a			;;	call forthexec 
219a			; 
219a			;	STACKFRAMECHK OFF $5efe $5f9f 
219a			; 
219a			;	; an immediate word so no need to process any more words 
219a			;	ret 
219a			;	NEXTW 
219a			 
219a			; dead code - old version  
219a			;	FORTH_RSP_NEXT 
219a			 
219a			;  
219a			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
219a			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
219a			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
219a			;	push hl 
219a			;	push de 
219a			;	push bc 
219a			; 
219a			; 
219a			;		if DEBUG_FORTH_WORDS_KEY 
219a			;			DMARK "EXR" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			; 
219a			; 
219a			; 
219a			;	;v5 FORTH_DSP_VALUE 
219a			;	FORTH_DSP_VALUEHL 
219a			; 
219a			;	; TODO do string type checks 
219a			; 
219a			;;v5	inc hl   ; skip type 
219a			; 
219a			;	push hl  ; source code  
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EX1" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			;	ld a, 0 
219a			;	call strlent 
219a			; 
219a			;	inc hl 
219a			;	inc hl 
219a			;	inc hl 
219a			;	inc hl 
219a			; 
219a			;	push hl    ; size 
219a			; 
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EX2" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			;	call malloc 
219a			; 
219a			;	ex de, hl    ; de now contains malloc area 
219a			;	pop bc   	; get byte count 
219a			;	pop hl      ; get string to copy 
219a			; 
219a			;	push de     ; save malloc for free later 
219a			; 
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EX3" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			;	ldir       ; duplicate string 
219a			; 
219a			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
219a			;	 
219a			;	; TODO fix the parse would be better than this...  
219a			;	ex de, hl 
219a			;	dec hl 
219a			;	ld a, 0 
219a			;	ld (hl), a 
219a			;	dec hl 
219a			;	ld a, ' ' 
219a			;	ld (hl), a 
219a			;	dec hl 
219a			;	ld (hl), a 
219a			; 
219a			;	dec hl 
219a			;	ld (hl), a 
219a			; 
219a			; 
219a			;	FORTH_DSP_POP  
219a			; 
219a			;	pop hl     
219a			;	push hl    ; save malloc area 
219a			; 
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EX4" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			; 
219a			;	call forthparse 
219a			;	call forthexec 
219a			;	 
219a			;	pop hl 
219a			;	if DEBUG_FORTH_WORDS 
219a			;		DMARK "EX5" 
219a			;		CALLMONITOR 
219a			;	endif 
219a			; 
219a			;	if FORTH_ENABLE_FREE 
219a			;	call free 
219a			;	endif 
219a			; 
219a			;	if DEBUG_FORTH_WORDS 
219a			;		DMARK "EX6" 
219a			;		CALLMONITOR 
219a			;	endif 
219a			; 
219a			;	pop bc 
219a			;	pop de 
219a			;	pop hl 
219a			;;	FORTH_RSP_POP	  
219a			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
219a			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
219a			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
219a			; 
219a			;	if DEBUG_FORTH_WORDS 
219a			;		DMARK "EX7" 
219a			;		CALLMONITOR 
219a			;	endif 
219a			;	NEXTW 
219a			 
219a			;.STKEXEC: 
219a			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
219a			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
219a			; 
219a			; 
219a			;		if DEBUG_FORTH_WORDS_KEY 
219a			;			DMARK "STX" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			; 
219a			;	FORTH_DSP_VALUEHL 
219a			; 
219a			;	ld (store_tmp1), hl    ; count 
219a			; 
219a			;	FORTH_DSP_POP 
219a			;.stkexec1: 
219a			;	ld hl, (store_tmp1)   ; count 
219a			;	ld a, 0 
219a			;	cp l 
219a			;	ret z 
219a			; 
219a			;	dec hl 
219a			;	ld (store_tmp1), hl    ; count 
219a			;	 
219a			;	FORTH_DSP_VALUEHL 
219a			;	push hl 
219a			;	 
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EXp" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			;	FORTH_DSP_POP 
219a			; 
219a			;	call strlenz 
219a			;	inc hl   ; include zero term to copy 
219a			;	inc hl   ; include zero term to copy 
219a			;	inc hl   ; include zero term to copy 
219a			;	ld b,0 
219a			;	ld c,l 
219a			;	pop hl 
219a			;	ld de, execscratch 
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EX3" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			;	ldir 
219a			; 
219a			; 
219a			;	ld hl, execscratch 
219a			; 
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EXP" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			; 
219a			;	call forthparse 
219a			;	ld hl, execscratch 
219a			;		if DEBUG_FORTH_WORDS 
219a			;			DMARK "EXx" 
219a			;			CALLMONITOR 
219a			;		endif 
219a			;	call forthexec 
219a			; 
219a			;	jp .stkexec1 
219a			; 
219a			;	ret 
219a			 
219a			 
219a			.DUP: 
219a				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
219a 17				db WORD_SYS_CORE+OPCODE_DUP             
219b 10 22			dw .ZDUP            
219d 04				db 3 + 1 
219e .. 00			db "DUP",0              
21a2				endm 
# End of macro CWHEAD
21a2			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
21a2			 
21a2					if DEBUG_FORTH_WORDS_KEY 
21a2						DMARK "DUP" 
21a2 f5				push af  
21a3 3a b7 21			ld a, (.dmark)  
21a6 32 6b ee			ld (debug_mark),a  
21a9 3a b8 21			ld a, (.dmark+1)  
21ac 32 6c ee			ld (debug_mark+1),a  
21af 3a b9 21			ld a, (.dmark+2)  
21b2 32 6d ee			ld (debug_mark+2),a  
21b5 18 03			jr .pastdmark  
21b7 ..			.dmark: db "DUP"  
21ba f1			.pastdmark: pop af  
21bb			endm  
# End of macro DMARK
21bb						CALLMONITOR 
21bb cd 6f ee			call debug_vector  
21be				endm  
# End of macro CALLMONITOR
21be					endif 
21be			 
21be					FORTH_DSP 
21be cd 13 1e			call macro_forth_dsp 
21c1				endm 
# End of macro FORTH_DSP
21c1			 
21c1 7e					ld a, (HL) 
21c2 fe 01				cp DS_TYPE_STR 
21c4 20 25				jr nz, .dupinum 
21c6			 
21c6					; push another string 
21c6			 
21c6					FORTH_DSP_VALUEHL     		 
21c6 cd 4d 1e			call macro_dsp_valuehl 
21c9				endm 
# End of macro FORTH_DSP_VALUEHL
21c9			 
21c9				if DEBUG_FORTH_WORDS 
21c9					DMARK "DUs" 
21c9 f5				push af  
21ca 3a de 21			ld a, (.dmark)  
21cd 32 6b ee			ld (debug_mark),a  
21d0 3a df 21			ld a, (.dmark+1)  
21d3 32 6c ee			ld (debug_mark+1),a  
21d6 3a e0 21			ld a, (.dmark+2)  
21d9 32 6d ee			ld (debug_mark+2),a  
21dc 18 03			jr .pastdmark  
21de ..			.dmark: db "DUs"  
21e1 f1			.pastdmark: pop af  
21e2			endm  
# End of macro DMARK
21e2					CALLMONITOR 
21e2 cd 6f ee			call debug_vector  
21e5				endm  
# End of macro CALLMONITOR
21e5				endif 
21e5 cd c4 1c				call forth_push_str 
21e8			 
21e8					NEXTW 
21e8 c3 03 20			jp macro_next 
21eb				endm 
# End of macro NEXTW
21eb			 
21eb			 
21eb			.dupinum: 
21eb					 
21eb			 
21eb			 
21eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21eb cd 4d 1e			call macro_dsp_valuehl 
21ee				endm 
# End of macro FORTH_DSP_VALUEHL
21ee			 
21ee				; TODO add floating point number detection 
21ee			 
21ee				if DEBUG_FORTH_WORDS 
21ee					DMARK "DUi" 
21ee f5				push af  
21ef 3a 03 22			ld a, (.dmark)  
21f2 32 6b ee			ld (debug_mark),a  
21f5 3a 04 22			ld a, (.dmark+1)  
21f8 32 6c ee			ld (debug_mark+1),a  
21fb 3a 05 22			ld a, (.dmark+2)  
21fe 32 6d ee			ld (debug_mark+2),a  
2201 18 03			jr .pastdmark  
2203 ..			.dmark: db "DUi"  
2206 f1			.pastdmark: pop af  
2207			endm  
# End of macro DMARK
2207					CALLMONITOR 
2207 cd 6f ee			call debug_vector  
220a				endm  
# End of macro CALLMONITOR
220a				endif 
220a			 
220a cd 56 1c				call forth_push_numhl 
220d					NEXTW 
220d c3 03 20			jp macro_next 
2210				endm 
# End of macro NEXTW
2210			.ZDUP: 
2210				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2210 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2211 48 22			dw .SWAP            
2213 05				db 4 + 1 
2214 .. 00			db "?DUP",0              
2219				endm 
# End of macro CWHEAD
2219			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2219			 
2219					if DEBUG_FORTH_WORDS_KEY 
2219						DMARK "qDU" 
2219 f5				push af  
221a 3a 2e 22			ld a, (.dmark)  
221d 32 6b ee			ld (debug_mark),a  
2220 3a 2f 22			ld a, (.dmark+1)  
2223 32 6c ee			ld (debug_mark+1),a  
2226 3a 30 22			ld a, (.dmark+2)  
2229 32 6d ee			ld (debug_mark+2),a  
222c 18 03			jr .pastdmark  
222e ..			.dmark: db "qDU"  
2231 f1			.pastdmark: pop af  
2232			endm  
# End of macro DMARK
2232						CALLMONITOR 
2232 cd 6f ee			call debug_vector  
2235				endm  
# End of macro CALLMONITOR
2235					endif 
2235					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2235 cd 4d 1e			call macro_dsp_valuehl 
2238				endm 
# End of macro FORTH_DSP_VALUEHL
2238			 
2238 e5					push hl 
2239			 
2239					; is it a zero? 
2239			 
2239 3e 00				ld a, 0 
223b 84					add h 
223c 85					add l 
223d			 
223d e1					pop hl 
223e			 
223e fe 00				cp 0 
2240 28 03				jr z, .dup2orig 
2242			 
2242			 
2242 cd 56 1c				call forth_push_numhl 
2245			 
2245			 
2245				; TODO add floating point number detection 
2245			 
2245			.dup2orig: 
2245			 
2245					NEXTW 
2245 c3 03 20			jp macro_next 
2248				endm 
# End of macro NEXTW
2248			.SWAP: 
2248				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2248 18				db WORD_SYS_CORE+OPCODE_SWAP             
2249 87 22			dw .COLN            
224b 05				db 4 + 1 
224c .. 00			db "SWAP",0              
2251				endm 
# End of macro CWHEAD
2251			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2251					if DEBUG_FORTH_WORDS_KEY 
2251						DMARK "SWP" 
2251 f5				push af  
2252 3a 66 22			ld a, (.dmark)  
2255 32 6b ee			ld (debug_mark),a  
2258 3a 67 22			ld a, (.dmark+1)  
225b 32 6c ee			ld (debug_mark+1),a  
225e 3a 68 22			ld a, (.dmark+2)  
2261 32 6d ee			ld (debug_mark+2),a  
2264 18 03			jr .pastdmark  
2266 ..			.dmark: db "SWP"  
2269 f1			.pastdmark: pop af  
226a			endm  
# End of macro DMARK
226a						CALLMONITOR 
226a cd 6f ee			call debug_vector  
226d				endm  
# End of macro CALLMONITOR
226d					endif 
226d			 
226d					FORTH_DSP_VALUEHL 
226d cd 4d 1e			call macro_dsp_valuehl 
2270				endm 
# End of macro FORTH_DSP_VALUEHL
2270 e5					push hl     ; w2 
2271			 
2271					FORTH_DSP_POP 
2271 cd 05 1f			call macro_forth_dsp_pop 
2274				endm 
# End of macro FORTH_DSP_POP
2274			 
2274					FORTH_DSP_VALUEHL 
2274 cd 4d 1e			call macro_dsp_valuehl 
2277				endm 
# End of macro FORTH_DSP_VALUEHL
2277			 
2277					FORTH_DSP_POP 
2277 cd 05 1f			call macro_forth_dsp_pop 
227a				endm 
# End of macro FORTH_DSP_POP
227a			 
227a d1					pop de     ; w2	, hl = w1 
227b			 
227b eb					ex de, hl 
227c d5					push de 
227d			 
227d cd 56 1c				call forth_push_numhl 
2280			 
2280 e1					pop hl 
2281			 
2281 cd 56 1c				call forth_push_numhl 
2284					 
2284			 
2284					NEXTW 
2284 c3 03 20			jp macro_next 
2287				endm 
# End of macro NEXTW
2287			.COLN: 
2287				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2287 19				db WORD_SYS_CORE+OPCODE_COLN             
2288 13 24			dw .SCOLN            
228a 02				db 1 + 1 
228b .. 00			db ":",0              
228d				endm 
# End of macro CWHEAD
228d			; | : ( -- )         Create new word | DONE 
228d			 
228d					if DEBUG_FORTH_WORDS_KEY 
228d						DMARK "CLN" 
228d f5				push af  
228e 3a a2 22			ld a, (.dmark)  
2291 32 6b ee			ld (debug_mark),a  
2294 3a a3 22			ld a, (.dmark+1)  
2297 32 6c ee			ld (debug_mark+1),a  
229a 3a a4 22			ld a, (.dmark+2)  
229d 32 6d ee			ld (debug_mark+2),a  
22a0 18 03			jr .pastdmark  
22a2 ..			.dmark: db "CLN"  
22a5 f1			.pastdmark: pop af  
22a6			endm  
# End of macro DMARK
22a6						CALLMONITOR 
22a6 cd 6f ee			call debug_vector  
22a9				endm  
# End of macro CALLMONITOR
22a9					endif 
22a9				STACKFRAME OFF $8efe $989f 
22a9				if DEBUG_STACK_IMB 
22a9					if OFF 
22a9						exx 
22a9						ld de, $8efe 
22a9						ld a, d 
22a9						ld hl, curframe 
22a9						call hexout 
22a9						ld a, e 
22a9						ld hl, curframe+2 
22a9						call hexout 
22a9						ld hl, $8efe 
22a9						push hl 
22a9						ld hl, $989f 
22a9						push hl 
22a9						exx 
22a9					endif 
22a9				endif 
22a9			endm 
# End of macro STACKFRAME
22a9				; get parser buffer length  of new word 
22a9			 
22a9				 
22a9			 
22a9					; move tok past this to start of name defintition 
22a9					; TODO get word to define 
22a9					; TODO Move past word token 
22a9					; TODO get length of string up to the ';' 
22a9			 
22a9 2a c2 e5			ld hl, (os_tok_ptr) 
22ac 23				inc hl 
22ad 23				inc hl 
22ae			 
22ae 3e 3b			ld a, ';' 
22b0 cd 50 12			call strlent 
22b3			 
22b3 7d				ld a,l 
22b4 32 bd e2			ld (os_new_parse_len), a 
22b7			 
22b7			 
22b7			if DEBUG_FORTH_UWORD 
22b7 ed 5b c2 e5		ld de, (os_tok_ptr) 
22bb						DMARK ":01" 
22bb f5				push af  
22bc 3a d0 22			ld a, (.dmark)  
22bf 32 6b ee			ld (debug_mark),a  
22c2 3a d1 22			ld a, (.dmark+1)  
22c5 32 6c ee			ld (debug_mark+1),a  
22c8 3a d2 22			ld a, (.dmark+2)  
22cb 32 6d ee			ld (debug_mark+2),a  
22ce 18 03			jr .pastdmark  
22d0 ..			.dmark: db ":01"  
22d3 f1			.pastdmark: pop af  
22d4			endm  
# End of macro DMARK
22d4				CALLMONITOR 
22d4 cd 6f ee			call debug_vector  
22d7				endm  
# End of macro CALLMONITOR
22d7			endif 
22d7			 
22d7			; 
22d7			;  new word memory layout: 
22d7			;  
22d7			;    : adg 6666 ;  
22d7			; 
22d7			;    db   1     ; user defined word  
22d7 23				inc hl    
22d8			;    dw   sysdict 
22d8 23				inc hl 
22d9 23				inc hl 
22da			;    db <word len>+1 (for null) 
22da 23				inc hl 
22db			;    db .... <word> 
22db			; 
22db			 
22db 23				inc hl    ; some extras for the word preamble before the above 
22dc 23				inc hl 
22dd 23				inc hl 
22de 23				inc hl 
22df 23				inc hl 
22e0 23				inc hl 
22e1 23				inc hl  
22e2 23				inc hl 
22e3 23				inc hl 
22e4 23				inc hl 
22e5 23				inc hl 
22e6 23				inc hl 
22e7 23				inc hl 
22e8 23				inc hl     ; TODO how many do we really need?     maybe only 6 
22e9			;       exec word buffer 
22e9			;	<ptr word>   
22e9 23				inc hl 
22ea 23				inc hl 
22eb			;       <word list><null term> 7F final term 
22eb			 
22eb			 
22eb			if DEBUG_FORTH_UWORD 
22eb						DMARK ":02" 
22eb f5				push af  
22ec 3a 00 23			ld a, (.dmark)  
22ef 32 6b ee			ld (debug_mark),a  
22f2 3a 01 23			ld a, (.dmark+1)  
22f5 32 6c ee			ld (debug_mark+1),a  
22f8 3a 02 23			ld a, (.dmark+2)  
22fb 32 6d ee			ld (debug_mark+2),a  
22fe 18 03			jr .pastdmark  
2300 ..			.dmark: db ":02"  
2303 f1			.pastdmark: pop af  
2304			endm  
# End of macro DMARK
2304				CALLMONITOR 
2304 cd 6f ee			call debug_vector  
2307				endm  
# End of macro CALLMONITOR
2307			endif 
2307			 
2307				 
2307					; malloc the size 
2307			 
2307 cd ae 12				call malloc 
230a 22 bf e2				ld (os_new_malloc), hl     ; save malloc start 
230d			 
230d			;    db   1     ; user defined word  
230d 3e 01				ld a, WORD_SYS_UWORD  
230f 77					ld (hl), a 
2310				 
2310 23				inc hl    
2311			;    dw   sysdict 
2311 11 5b 21			ld de, sysdict       ; continue on with the scan to the system dict 
2314 73				ld (hl), e 
2315 23				inc hl 
2316 72				ld (hl), d 
2317 23				inc hl 
2318			 
2318			 
2318			;    Setup dict word 
2318			 
2318 23				inc hl 
2319 22 b9 e2			ld (os_new_work_ptr), hl     ; save start of dict word  
231c			 
231c				; 1. get length of dict word 
231c			 
231c			 
231c 2a c2 e5			ld hl, (os_tok_ptr) 
231f 23				inc hl 
2320 23				inc hl    ; position to start of dict word 
2321 3e 00			ld a, 0 
2323 cd 50 12			call strlent 
2326			 
2326			 
2326 23				inc hl    ; to include null??? 
2327			 
2327				; write length of dict word 
2327			 
2327 ed 5b b9 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
232b 1b				dec de 
232c eb				ex de, hl 
232d 73				ld (hl), e 
232e eb				ex de, hl 
232f			 
232f				 
232f			 
232f				; copy  
232f 4d				ld c, l 
2330 06 00			ld b, 0 
2332 ed 5b b9 e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2336 2a c2 e5			ld hl, (os_tok_ptr) 
2339 23				inc hl 
233a 23				inc hl    ; position to start of dict word 
233b				 
233b			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
233b				 
233b				; TODO need to convert word to upper case 
233b			 
233b			ucasetok:	 
233b 7e				ld a,(hl) 
233c cd 3c 12			call toUpper 
233f 77				ld (hl),a 
2340 ed a0			ldi 
2342 f2 3b 23		 	jp p, ucasetok 
2345			 
2345			 
2345			 
2345				; de now points to start of where the word body code should be placed 
2345 ed 53 b9 e2		ld (os_new_work_ptr), de 
2349				; hl now points to the words to throw at forthexec which needs to be copied 
2349 22 b7 e2			ld (os_new_src_ptr), hl 
234c			 
234c				; TODO add 'call to forthexec' 
234c			 
234c			if DEBUG_FORTH_UWORD 
234c c5				push bc 
234d ed 4b bf e2		ld bc, (os_new_malloc) 
2351						DMARK ":0x" 
2351 f5				push af  
2352 3a 66 23			ld a, (.dmark)  
2355 32 6b ee			ld (debug_mark),a  
2358 3a 67 23			ld a, (.dmark+1)  
235b 32 6c ee			ld (debug_mark+1),a  
235e 3a 68 23			ld a, (.dmark+2)  
2361 32 6d ee			ld (debug_mark+2),a  
2364 18 03			jr .pastdmark  
2366 ..			.dmark: db ":0x"  
2369 f1			.pastdmark: pop af  
236a			endm  
# End of macro DMARK
236a				CALLMONITOR 
236a cd 6f ee			call debug_vector  
236d				endm  
# End of macro CALLMONITOR
236d c1				pop bc 
236e			endif 
236e			 
236e			 
236e				; create word preamble which should be: 
236e			 
236e			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
236e			 
236e				;    ld hl, <word code> 
236e				;    jp user_exec 
236e			        ;    <word code bytes> 
236e			 
236e			 
236e			;	inc de     ; TODO ??? or are we already past the word's null 
236e eb				ex de, hl 
236f			 
236f 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2371			 
2371 23				inc hl 
2372 22 b3 e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2375 23				inc hl 
2376			 
2376 23				inc hl 
2377 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2379			 
2379 01 70 4c			ld bc, user_exec 
237c 23				inc hl 
237d 71				ld (hl), c     ; poke address of user_exec 
237e 23				inc hl 
237f 70				ld (hl), b     
2380			 ; 
2380			;	inc hl 
2380			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2380			; 
2380			; 
2380			;	ld bc, macro_forth_rsp_next 
2380			;	inc hl 
2380			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2380			;	inc hl 
2380			;	ld (hl), b     
2380			 ; 
2380			;	inc hl 
2380			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2380			; 
2380			; 
2380			;	inc hl 
2380			;	ld bc, forthexec 
2380			;	ld (hl), c     ; poke address of forthexec 
2380			;	inc hl 
2380			;	ld (hl), b      
2380			; 
2380			;	inc hl 
2380			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2380			; 
2380			;	ld bc, user_dict_next 
2380			;	inc hl 
2380			;	ld (hl), c     ; poke address of forthexec 
2380			;	inc hl 
2380			;	ld (hl), b      
2380			 
2380				; hl is now where we need to copy the word byte data to save this 
2380			 
2380 23				inc hl 
2381 22 b5 e2			ld (os_new_exec), hl 
2384				 
2384				; copy definition 
2384			 
2384 eb				ex de, hl 
2385			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2385			;	inc de    ; skip the PC for this parse 
2385 3a bd e2			ld a, (os_new_parse_len) 
2388 4f				ld c, a 
2389 06 00			ld b, 0 
238b ed b0			ldir		 ; copy defintion 
238d			 
238d			 
238d				; poke the address of where the new word bytes live for forthexec 
238d			 
238d 2a b3 e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2390			 
2390 ed 5b b5 e2		ld de, (os_new_exec)      
2394				 
2394 73				ld (hl), e 
2395 23				inc hl 
2396 72				ld (hl), d 
2397			 
2397					; TODO copy last user dict word next link to this word 
2397					; TODO update last user dict word to point to this word 
2397			; 
2397			; hl f923 de 812a ; bc 811a 
2397			 
2397			if DEBUG_FORTH_UWORD 
2397 c5				push bc 
2398 ed 4b bf e2		ld bc, (os_new_malloc) 
239c						DMARK ":0A" 
239c f5				push af  
239d 3a b1 23			ld a, (.dmark)  
23a0 32 6b ee			ld (debug_mark),a  
23a3 3a b2 23			ld a, (.dmark+1)  
23a6 32 6c ee			ld (debug_mark+1),a  
23a9 3a b3 23			ld a, (.dmark+2)  
23ac 32 6d ee			ld (debug_mark+2),a  
23af 18 03			jr .pastdmark  
23b1 ..			.dmark: db ":0A"  
23b4 f1			.pastdmark: pop af  
23b5			endm  
# End of macro DMARK
23b5				CALLMONITOR 
23b5 cd 6f ee			call debug_vector  
23b8				endm  
# End of macro CALLMONITOR
23b8 c1				pop bc 
23b9			endif 
23b9			if DEBUG_FORTH_UWORD 
23b9 c5				push bc 
23ba ed 4b bf e2		ld bc, (os_new_malloc) 
23be 03				inc bc 
23bf 03				inc bc 
23c0 03				inc bc 
23c1 03				inc bc 
23c2 03				inc bc 
23c3 03				inc bc 
23c4 03				inc bc 
23c5 03				inc bc 
23c6			 
23c6						DMARK ":0B" 
23c6 f5				push af  
23c7 3a db 23			ld a, (.dmark)  
23ca 32 6b ee			ld (debug_mark),a  
23cd 3a dc 23			ld a, (.dmark+1)  
23d0 32 6c ee			ld (debug_mark+1),a  
23d3 3a dd 23			ld a, (.dmark+2)  
23d6 32 6d ee			ld (debug_mark+2),a  
23d9 18 03			jr .pastdmark  
23db ..			.dmark: db ":0B"  
23de f1			.pastdmark: pop af  
23df			endm  
# End of macro DMARK
23df				CALLMONITOR 
23df cd 6f ee			call debug_vector  
23e2				endm  
# End of macro CALLMONITOR
23e2 c1				pop bc 
23e3			endif 
23e3			 
23e3			; update word dict linked list for new word 
23e3			 
23e3			 
23e3 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
23e6 23			inc hl     ; move to next work linked list ptr 
23e7			 
23e7 ed 5b bf e2	ld de, (os_new_malloc)		 ; new next word 
23eb 73			ld (hl), e 
23ec 23			inc hl 
23ed 72			ld (hl), d 
23ee			 
23ee			if DEBUG_FORTH_UWORD 
23ee ed 4b be e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
23f2			endif 
23f2			 
23f2 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
23f6			 
23f6			 
23f6			if DEBUG_FORTH_UWORD 
23f6						DMARK ":0+" 
23f6 f5				push af  
23f7 3a 0b 24			ld a, (.dmark)  
23fa 32 6b ee			ld (debug_mark),a  
23fd 3a 0c 24			ld a, (.dmark+1)  
2400 32 6c ee			ld (debug_mark+1),a  
2403 3a 0d 24			ld a, (.dmark+2)  
2406 32 6d ee			ld (debug_mark+2),a  
2409 18 03			jr .pastdmark  
240b ..			.dmark: db ":0+"  
240e f1			.pastdmark: pop af  
240f			endm  
# End of macro DMARK
240f				CALLMONITOR 
240f cd 6f ee			call debug_vector  
2412				endm  
# End of macro CALLMONITOR
2412			endif 
2412			 
2412				STACKFRAMECHK OFF $8efe $989f 
2412				if DEBUG_STACK_IMB 
2412					if OFF 
2412						exx 
2412						ld hl, $989f 
2412						pop de   ; $989f 
2412						call cmp16 
2412						jr nz, .spnosame 
2412						ld hl, $8efe 
2412						pop de   ; $8efe 
2412						call cmp16 
2412						jr z, .spfrsame 
2412						.spnosame: call showsperror 
2412						.spfrsame: nop 
2412						exx 
2412					endif 
2412				endif 
2412			endm 
# End of macro STACKFRAMECHK
2412			 
2412 c9			ret    ; dont process any remaining parser tokens as they form new word 
2413			 
2413			 
2413			 
2413			 
2413			;		NEXT 
2413			.SCOLN: 
2413			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2413 06				db OPCODE_SCOLN 
2414 5f 24			dw .DROP 
2416 02				db 2 
2417 .. 00			db ";",0           
2419			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2419					if DEBUG_FORTH_WORDS_KEY 
2419						DMARK "SCN" 
2419 f5				push af  
241a 3a 2e 24			ld a, (.dmark)  
241d 32 6b ee			ld (debug_mark),a  
2420 3a 2f 24			ld a, (.dmark+1)  
2423 32 6c ee			ld (debug_mark+1),a  
2426 3a 30 24			ld a, (.dmark+2)  
2429 32 6d ee			ld (debug_mark+2),a  
242c 18 03			jr .pastdmark  
242e ..			.dmark: db "SCN"  
2431 f1			.pastdmark: pop af  
2432			endm  
# End of macro DMARK
2432						CALLMONITOR 
2432 cd 6f ee			call debug_vector  
2435				endm  
# End of macro CALLMONITOR
2435					endif 
2435					FORTH_RSP_TOS 
2435 cd 14 1c			call macro_forth_rsp_tos 
2438				endm 
# End of macro FORTH_RSP_TOS
2438 e5					push hl 
2439					FORTH_RSP_POP 
2439 cd 1e 1c			call macro_forth_rsp_pop 
243c				endm 
# End of macro FORTH_RSP_POP
243c e1					pop hl 
243d			;		ex de,hl 
243d 22 c2 e5				ld (os_tok_ptr),hl 
2440			 
2440			if DEBUG_FORTH_UWORD 
2440						DMARK "SCL" 
2440 f5				push af  
2441 3a 55 24			ld a, (.dmark)  
2444 32 6b ee			ld (debug_mark),a  
2447 3a 56 24			ld a, (.dmark+1)  
244a 32 6c ee			ld (debug_mark+1),a  
244d 3a 57 24			ld a, (.dmark+2)  
2450 32 6d ee			ld (debug_mark+2),a  
2453 18 03			jr .pastdmark  
2455 ..			.dmark: db "SCL"  
2458 f1			.pastdmark: pop af  
2459			endm  
# End of macro DMARK
2459				CALLMONITOR 
2459 cd 6f ee			call debug_vector  
245c				endm  
# End of macro CALLMONITOR
245c			endif 
245c					NEXTW 
245c c3 03 20			jp macro_next 
245f				endm 
# End of macro NEXTW
245f			 
245f			.DROP: 
245f				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
245f 1b				db WORD_SYS_CORE+OPCODE_DROP             
2460 8a 24			dw .DUP2            
2462 05				db 4 + 1 
2463 .. 00			db "DROP",0              
2468				endm 
# End of macro CWHEAD
2468			; | DROP ( w -- )   drop the TOS item   | DONE 
2468					if DEBUG_FORTH_WORDS_KEY 
2468						DMARK "DRP" 
2468 f5				push af  
2469 3a 7d 24			ld a, (.dmark)  
246c 32 6b ee			ld (debug_mark),a  
246f 3a 7e 24			ld a, (.dmark+1)  
2472 32 6c ee			ld (debug_mark+1),a  
2475 3a 7f 24			ld a, (.dmark+2)  
2478 32 6d ee			ld (debug_mark+2),a  
247b 18 03			jr .pastdmark  
247d ..			.dmark: db "DRP"  
2480 f1			.pastdmark: pop af  
2481			endm  
# End of macro DMARK
2481						CALLMONITOR 
2481 cd 6f ee			call debug_vector  
2484				endm  
# End of macro CALLMONITOR
2484					endif 
2484					FORTH_DSP_POP 
2484 cd 05 1f			call macro_forth_dsp_pop 
2487				endm 
# End of macro FORTH_DSP_POP
2487					NEXTW 
2487 c3 03 20			jp macro_next 
248a				endm 
# End of macro NEXTW
248a			.DUP2: 
248a				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
248a 1c				db WORD_SYS_CORE+OPCODE_DUP2             
248b cf 24			dw .DROP2            
248d 05				db 4 + 1 
248e .. 00			db "2DUP",0              
2493				endm 
# End of macro CWHEAD
2493			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2493					if DEBUG_FORTH_WORDS_KEY 
2493						DMARK "2DU" 
2493 f5				push af  
2494 3a a8 24			ld a, (.dmark)  
2497 32 6b ee			ld (debug_mark),a  
249a 3a a9 24			ld a, (.dmark+1)  
249d 32 6c ee			ld (debug_mark+1),a  
24a0 3a aa 24			ld a, (.dmark+2)  
24a3 32 6d ee			ld (debug_mark+2),a  
24a6 18 03			jr .pastdmark  
24a8 ..			.dmark: db "2DU"  
24ab f1			.pastdmark: pop af  
24ac			endm  
# End of macro DMARK
24ac						CALLMONITOR 
24ac cd 6f ee			call debug_vector  
24af				endm  
# End of macro CALLMONITOR
24af					endif 
24af					FORTH_DSP_VALUEHL 
24af cd 4d 1e			call macro_dsp_valuehl 
24b2				endm 
# End of macro FORTH_DSP_VALUEHL
24b2 e5					push hl      ; 2 
24b3			 
24b3					FORTH_DSP_POP 
24b3 cd 05 1f			call macro_forth_dsp_pop 
24b6				endm 
# End of macro FORTH_DSP_POP
24b6					 
24b6					FORTH_DSP_VALUEHL 
24b6 cd 4d 1e			call macro_dsp_valuehl 
24b9				endm 
# End of macro FORTH_DSP_VALUEHL
24b9			;		push hl      ; 1 
24b9			 
24b9					FORTH_DSP_POP 
24b9 cd 05 1f			call macro_forth_dsp_pop 
24bc				endm 
# End of macro FORTH_DSP_POP
24bc			 
24bc			;		pop hl       ; 1 
24bc d1					pop de       ; 2 
24bd			 
24bd cd 56 1c				call forth_push_numhl 
24c0 eb					ex de, hl 
24c1 cd 56 1c				call forth_push_numhl 
24c4			 
24c4					 
24c4 eb					ex de, hl 
24c5			 
24c5 cd 56 1c				call forth_push_numhl 
24c8 eb					ex de, hl 
24c9 cd 56 1c				call forth_push_numhl 
24cc			 
24cc			 
24cc					NEXTW 
24cc c3 03 20			jp macro_next 
24cf				endm 
# End of macro NEXTW
24cf			.DROP2: 
24cf				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
24cf 1d				db WORD_SYS_CORE+OPCODE_DROP2             
24d0 fe 24			dw .SWAP2            
24d2 06				db 5 + 1 
24d3 .. 00			db "2DROP",0              
24d9				endm 
# End of macro CWHEAD
24d9			; | 2DROP ( w w -- )    Double drop | DONE 
24d9					if DEBUG_FORTH_WORDS_KEY 
24d9						DMARK "2DR" 
24d9 f5				push af  
24da 3a ee 24			ld a, (.dmark)  
24dd 32 6b ee			ld (debug_mark),a  
24e0 3a ef 24			ld a, (.dmark+1)  
24e3 32 6c ee			ld (debug_mark+1),a  
24e6 3a f0 24			ld a, (.dmark+2)  
24e9 32 6d ee			ld (debug_mark+2),a  
24ec 18 03			jr .pastdmark  
24ee ..			.dmark: db "2DR"  
24f1 f1			.pastdmark: pop af  
24f2			endm  
# End of macro DMARK
24f2						CALLMONITOR 
24f2 cd 6f ee			call debug_vector  
24f5				endm  
# End of macro CALLMONITOR
24f5					endif 
24f5					FORTH_DSP_POP 
24f5 cd 05 1f			call macro_forth_dsp_pop 
24f8				endm 
# End of macro FORTH_DSP_POP
24f8					FORTH_DSP_POP 
24f8 cd 05 1f			call macro_forth_dsp_pop 
24fb				endm 
# End of macro FORTH_DSP_POP
24fb					NEXTW 
24fb c3 03 20			jp macro_next 
24fe				endm 
# End of macro NEXTW
24fe			.SWAP2: 
24fe				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
24fe 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
24ff 27 25			dw .AT            
2501 06				db 5 + 1 
2502 .. 00			db "2SWAP",0              
2508				endm 
# End of macro CWHEAD
2508			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2508					if DEBUG_FORTH_WORDS_KEY 
2508						DMARK "2SW" 
2508 f5				push af  
2509 3a 1d 25			ld a, (.dmark)  
250c 32 6b ee			ld (debug_mark),a  
250f 3a 1e 25			ld a, (.dmark+1)  
2512 32 6c ee			ld (debug_mark+1),a  
2515 3a 1f 25			ld a, (.dmark+2)  
2518 32 6d ee			ld (debug_mark+2),a  
251b 18 03			jr .pastdmark  
251d ..			.dmark: db "2SW"  
2520 f1			.pastdmark: pop af  
2521			endm  
# End of macro DMARK
2521						CALLMONITOR 
2521 cd 6f ee			call debug_vector  
2524				endm  
# End of macro CALLMONITOR
2524					endif 
2524					NEXTW 
2524 c3 03 20			jp macro_next 
2527				endm 
# End of macro NEXTW
2527			.AT: 
2527				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2527 1f				db WORD_SYS_CORE+OPCODE_AT             
2528 59 25			dw .CAT            
252a 02				db 1 + 1 
252b .. 00			db "@",0              
252d				endm 
# End of macro CWHEAD
252d			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
252d			 
252d					if DEBUG_FORTH_WORDS_KEY 
252d						DMARK "AT." 
252d f5				push af  
252e 3a 42 25			ld a, (.dmark)  
2531 32 6b ee			ld (debug_mark),a  
2534 3a 43 25			ld a, (.dmark+1)  
2537 32 6c ee			ld (debug_mark+1),a  
253a 3a 44 25			ld a, (.dmark+2)  
253d 32 6d ee			ld (debug_mark+2),a  
2540 18 03			jr .pastdmark  
2542 ..			.dmark: db "AT."  
2545 f1			.pastdmark: pop af  
2546			endm  
# End of macro DMARK
2546						CALLMONITOR 
2546 cd 6f ee			call debug_vector  
2549				endm  
# End of macro CALLMONITOR
2549					endif 
2549			.getbyteat:	 
2549					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2549 cd 4d 1e			call macro_dsp_valuehl 
254c				endm 
# End of macro FORTH_DSP_VALUEHL
254c					 
254c			;		push hl 
254c				 
254c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
254c cd 05 1f			call macro_forth_dsp_pop 
254f				endm 
# End of macro FORTH_DSP_POP
254f			 
254f			;		pop hl 
254f			 
254f 7e					ld a, (hl) 
2550			 
2550 6f					ld l, a 
2551 26 00				ld h, 0 
2553 cd 56 1c				call forth_push_numhl 
2556			 
2556					NEXTW 
2556 c3 03 20			jp macro_next 
2559				endm 
# End of macro NEXTW
2559			.CAT: 
2559				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2559 20				db WORD_SYS_CORE+OPCODE_CAT             
255a 82 25			dw .BANG            
255c 03				db 2 + 1 
255d .. 00			db "C@",0              
2560				endm 
# End of macro CWHEAD
2560			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2560					if DEBUG_FORTH_WORDS_KEY 
2560						DMARK "CAA" 
2560 f5				push af  
2561 3a 75 25			ld a, (.dmark)  
2564 32 6b ee			ld (debug_mark),a  
2567 3a 76 25			ld a, (.dmark+1)  
256a 32 6c ee			ld (debug_mark+1),a  
256d 3a 77 25			ld a, (.dmark+2)  
2570 32 6d ee			ld (debug_mark+2),a  
2573 18 03			jr .pastdmark  
2575 ..			.dmark: db "CAA"  
2578 f1			.pastdmark: pop af  
2579			endm  
# End of macro DMARK
2579						CALLMONITOR 
2579 cd 6f ee			call debug_vector  
257c				endm  
# End of macro CALLMONITOR
257c					endif 
257c c3 49 25				jp .getbyteat 
257f					NEXTW 
257f c3 03 20			jp macro_next 
2582				endm 
# End of macro NEXTW
2582			.BANG: 
2582				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2582 21				db WORD_SYS_CORE+OPCODE_BANG             
2583 b8 25			dw .CBANG            
2585 02				db 1 + 1 
2586 .. 00			db "!",0              
2588				endm 
# End of macro CWHEAD
2588			; | ! ( x w -- ) Store x at address w      | DONE 
2588					if DEBUG_FORTH_WORDS_KEY 
2588						DMARK "BNG" 
2588 f5				push af  
2589 3a 9d 25			ld a, (.dmark)  
258c 32 6b ee			ld (debug_mark),a  
258f 3a 9e 25			ld a, (.dmark+1)  
2592 32 6c ee			ld (debug_mark+1),a  
2595 3a 9f 25			ld a, (.dmark+2)  
2598 32 6d ee			ld (debug_mark+2),a  
259b 18 03			jr .pastdmark  
259d ..			.dmark: db "BNG"  
25a0 f1			.pastdmark: pop af  
25a1			endm  
# End of macro DMARK
25a1						CALLMONITOR 
25a1 cd 6f ee			call debug_vector  
25a4				endm  
# End of macro CALLMONITOR
25a4					endif 
25a4			 
25a4			.storebyteat:		 
25a4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25a4 cd 4d 1e			call macro_dsp_valuehl 
25a7				endm 
# End of macro FORTH_DSP_VALUEHL
25a7					 
25a7 e5					push hl 
25a8				 
25a8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25a8 cd 05 1f			call macro_forth_dsp_pop 
25ab				endm 
# End of macro FORTH_DSP_POP
25ab			 
25ab					; get byte to poke 
25ab			 
25ab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25ab cd 4d 1e			call macro_dsp_valuehl 
25ae				endm 
# End of macro FORTH_DSP_VALUEHL
25ae e5					push hl 
25af			 
25af			 
25af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25af cd 05 1f			call macro_forth_dsp_pop 
25b2				endm 
# End of macro FORTH_DSP_POP
25b2			 
25b2			 
25b2 d1					pop de 
25b3 e1					pop hl 
25b4			 
25b4 73					ld (hl),e 
25b5			 
25b5			 
25b5					NEXTW 
25b5 c3 03 20			jp macro_next 
25b8				endm 
# End of macro NEXTW
25b8			.CBANG: 
25b8				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
25b8 22				db WORD_SYS_CORE+OPCODE_CBANG             
25b9 e1 25			dw .SCALL            
25bb 03				db 2 + 1 
25bc .. 00			db "C!",0              
25bf				endm 
# End of macro CWHEAD
25bf			; | C!  ( x w -- ) Store x at address w  | DONE 
25bf					if DEBUG_FORTH_WORDS_KEY 
25bf						DMARK "CBA" 
25bf f5				push af  
25c0 3a d4 25			ld a, (.dmark)  
25c3 32 6b ee			ld (debug_mark),a  
25c6 3a d5 25			ld a, (.dmark+1)  
25c9 32 6c ee			ld (debug_mark+1),a  
25cc 3a d6 25			ld a, (.dmark+2)  
25cf 32 6d ee			ld (debug_mark+2),a  
25d2 18 03			jr .pastdmark  
25d4 ..			.dmark: db "CBA"  
25d7 f1			.pastdmark: pop af  
25d8			endm  
# End of macro DMARK
25d8						CALLMONITOR 
25d8 cd 6f ee			call debug_vector  
25db				endm  
# End of macro CALLMONITOR
25db					endif 
25db c3 a4 25				jp .storebyteat 
25de					NEXTW 
25de c3 03 20			jp macro_next 
25e1				endm 
# End of macro NEXTW
25e1			.SCALL: 
25e1				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
25e1 23				db WORD_SYS_CORE+OPCODE_SCALL             
25e2 15 26			dw .DEPTH            
25e4 05				db 4 + 1 
25e5 .. 00			db "CALL",0              
25ea				endm 
# End of macro CWHEAD
25ea			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
25ea					if DEBUG_FORTH_WORDS_KEY 
25ea						DMARK "CLL" 
25ea f5				push af  
25eb 3a ff 25			ld a, (.dmark)  
25ee 32 6b ee			ld (debug_mark),a  
25f1 3a 00 26			ld a, (.dmark+1)  
25f4 32 6c ee			ld (debug_mark+1),a  
25f7 3a 01 26			ld a, (.dmark+2)  
25fa 32 6d ee			ld (debug_mark+2),a  
25fd 18 03			jr .pastdmark  
25ff ..			.dmark: db "CLL"  
2602 f1			.pastdmark: pop af  
2603			endm  
# End of macro DMARK
2603						CALLMONITOR 
2603 cd 6f ee			call debug_vector  
2606				endm  
# End of macro CALLMONITOR
2606					endif 
2606			 
2606					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2606 cd 4d 1e			call macro_dsp_valuehl 
2609				endm 
# End of macro FORTH_DSP_VALUEHL
2609			 
2609			;		push hl 
2609			 
2609					; destroy value TOS 
2609			 
2609					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2609 cd 05 1f			call macro_forth_dsp_pop 
260c				endm 
# End of macro FORTH_DSP_POP
260c			 
260c						 
260c			;		pop hl 
260c			 
260c					; how to do a call with hl???? save SP? 
260c cd a7 1f				call forth_call_hl 
260f			 
260f			 
260f					; TODO push value back onto stack for another op etc 
260f			 
260f cd 56 1c				call forth_push_numhl 
2612					NEXTW 
2612 c3 03 20			jp macro_next 
2615				endm 
# End of macro NEXTW
2615			.DEPTH: 
2615				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2615 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2616 52 26			dw .OVER            
2618 06				db 5 + 1 
2619 .. 00			db "DEPTH",0              
261f				endm 
# End of macro CWHEAD
261f			; | DEPTH ( -- u ) Push count of stack | DONE 
261f					; take current TOS and remove from base value div by two to get count 
261f					if DEBUG_FORTH_WORDS_KEY 
261f						DMARK "DEP" 
261f f5				push af  
2620 3a 34 26			ld a, (.dmark)  
2623 32 6b ee			ld (debug_mark),a  
2626 3a 35 26			ld a, (.dmark+1)  
2629 32 6c ee			ld (debug_mark+1),a  
262c 3a 36 26			ld a, (.dmark+2)  
262f 32 6d ee			ld (debug_mark+2),a  
2632 18 03			jr .pastdmark  
2634 ..			.dmark: db "DEP"  
2637 f1			.pastdmark: pop af  
2638			endm  
# End of macro DMARK
2638						CALLMONITOR 
2638 cd 6f ee			call debug_vector  
263b				endm  
# End of macro CALLMONITOR
263b					endif 
263b			 
263b			 
263b 2a ee e9			ld hl, (cli_data_sp) 
263e 11 28 e8			ld de, cli_data_stack 
2641 ed 52			sbc hl,de 
2643				 
2643				; div by size of stack item 
2643			 
2643 5d				ld e,l 
2644 0e 03			ld c, 3 
2646 cd 77 0d			call Div8 
2649			 
2649 6f				ld l,a 
264a 26 00			ld h,0 
264c			 
264c				;srl h 
264c				;rr l 
264c			 
264c cd 56 1c				call forth_push_numhl 
264f					NEXTW 
264f c3 03 20			jp macro_next 
2652				endm 
# End of macro NEXTW
2652			.OVER: 
2652				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2652 42				db WORD_SYS_CORE+46             
2653 99 26			dw .PAUSE            
2655 05				db 4 + 1 
2656 .. 00			db "OVER",0              
265b				endm 
# End of macro CWHEAD
265b			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
265b					if DEBUG_FORTH_WORDS_KEY 
265b						DMARK "OVR" 
265b f5				push af  
265c 3a 70 26			ld a, (.dmark)  
265f 32 6b ee			ld (debug_mark),a  
2662 3a 71 26			ld a, (.dmark+1)  
2665 32 6c ee			ld (debug_mark+1),a  
2668 3a 72 26			ld a, (.dmark+2)  
266b 32 6d ee			ld (debug_mark+2),a  
266e 18 03			jr .pastdmark  
2670 ..			.dmark: db "OVR"  
2673 f1			.pastdmark: pop af  
2674			endm  
# End of macro DMARK
2674						CALLMONITOR 
2674 cd 6f ee			call debug_vector  
2677				endm  
# End of macro CALLMONITOR
2677					endif 
2677			 
2677					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2677 cd 4d 1e			call macro_dsp_valuehl 
267a				endm 
# End of macro FORTH_DSP_VALUEHL
267a e5					push hl    ; n2 
267b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
267b cd 05 1f			call macro_forth_dsp_pop 
267e				endm 
# End of macro FORTH_DSP_POP
267e			 
267e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
267e cd 4d 1e			call macro_dsp_valuehl 
2681				endm 
# End of macro FORTH_DSP_VALUEHL
2681 e5					push hl    ; n1 
2682					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2682 cd 05 1f			call macro_forth_dsp_pop 
2685				endm 
# End of macro FORTH_DSP_POP
2685			 
2685 d1					pop de     ; n1 
2686 e1					pop hl     ; n2 
2687			 
2687 d5					push de 
2688 e5					push hl 
2689 d5					push de 
268a			 
268a					; push back  
268a			 
268a e1					pop hl 
268b cd 56 1c				call forth_push_numhl 
268e e1					pop hl 
268f cd 56 1c				call forth_push_numhl 
2692 e1					pop hl 
2693 cd 56 1c				call forth_push_numhl 
2696					NEXTW 
2696 c3 03 20			jp macro_next 
2699				endm 
# End of macro NEXTW
2699			 
2699			.PAUSE: 
2699				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2699 43				db WORD_SYS_CORE+47             
269a ce 26			dw .PAUSES            
269c 08				db 7 + 1 
269d .. 00			db "PAUSEMS",0              
26a5				endm 
# End of macro CWHEAD
26a5			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
26a5					if DEBUG_FORTH_WORDS_KEY 
26a5						DMARK "PMS" 
26a5 f5				push af  
26a6 3a ba 26			ld a, (.dmark)  
26a9 32 6b ee			ld (debug_mark),a  
26ac 3a bb 26			ld a, (.dmark+1)  
26af 32 6c ee			ld (debug_mark+1),a  
26b2 3a bc 26			ld a, (.dmark+2)  
26b5 32 6d ee			ld (debug_mark+2),a  
26b8 18 03			jr .pastdmark  
26ba ..			.dmark: db "PMS"  
26bd f1			.pastdmark: pop af  
26be			endm  
# End of macro DMARK
26be						CALLMONITOR 
26be cd 6f ee			call debug_vector  
26c1				endm  
# End of macro CALLMONITOR
26c1					endif 
26c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26c1 cd 4d 1e			call macro_dsp_valuehl 
26c4				endm 
# End of macro FORTH_DSP_VALUEHL
26c4			;		push hl    ; n2 
26c4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26c4 cd 05 1f			call macro_forth_dsp_pop 
26c7				endm 
# End of macro FORTH_DSP_POP
26c7			;		pop hl 
26c7			 
26c7 7d					ld a, l 
26c8 cd d7 0a				call aDelayInMS 
26cb				       NEXTW 
26cb c3 03 20			jp macro_next 
26ce				endm 
# End of macro NEXTW
26ce			.PAUSES:  
26ce				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
26ce 44				db WORD_SYS_CORE+48             
26cf 3d 27			dw .ROT            
26d1 06				db 5 + 1 
26d2 .. 00			db "PAUSE",0              
26d8				endm 
# End of macro CWHEAD
26d8			; | PAUSE ( n -- )  Pause for n seconds | DONE 
26d8					if DEBUG_FORTH_WORDS_KEY 
26d8						DMARK "PAU" 
26d8 f5				push af  
26d9 3a ed 26			ld a, (.dmark)  
26dc 32 6b ee			ld (debug_mark),a  
26df 3a ee 26			ld a, (.dmark+1)  
26e2 32 6c ee			ld (debug_mark+1),a  
26e5 3a ef 26			ld a, (.dmark+2)  
26e8 32 6d ee			ld (debug_mark+2),a  
26eb 18 03			jr .pastdmark  
26ed ..			.dmark: db "PAU"  
26f0 f1			.pastdmark: pop af  
26f1			endm  
# End of macro DMARK
26f1						CALLMONITOR 
26f1 cd 6f ee			call debug_vector  
26f4				endm  
# End of macro CALLMONITOR
26f4					endif 
26f4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26f4 cd 4d 1e			call macro_dsp_valuehl 
26f7				endm 
# End of macro FORTH_DSP_VALUEHL
26f7			;		push hl    ; n2 
26f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26f7 cd 05 1f			call macro_forth_dsp_pop 
26fa				endm 
# End of macro FORTH_DSP_POP
26fa			;		pop hl 
26fa 45					ld b, l 
26fb					if DEBUG_FORTH_WORDS 
26fb						DMARK "PAU" 
26fb f5				push af  
26fc 3a 10 27			ld a, (.dmark)  
26ff 32 6b ee			ld (debug_mark),a  
2702 3a 11 27			ld a, (.dmark+1)  
2705 32 6c ee			ld (debug_mark+1),a  
2708 3a 12 27			ld a, (.dmark+2)  
270b 32 6d ee			ld (debug_mark+2),a  
270e 18 03			jr .pastdmark  
2710 ..			.dmark: db "PAU"  
2713 f1			.pastdmark: pop af  
2714			endm  
# End of macro DMARK
2714						CALLMONITOR 
2714 cd 6f ee			call debug_vector  
2717				endm  
# End of macro CALLMONITOR
2717					endif 
2717 c5			.pauses1:	push bc 
2718 cd f2 0a				call delay1s 
271b c1					pop bc 
271c					if DEBUG_FORTH_WORDS 
271c						DMARK "PA1" 
271c f5				push af  
271d 3a 31 27			ld a, (.dmark)  
2720 32 6b ee			ld (debug_mark),a  
2723 3a 32 27			ld a, (.dmark+1)  
2726 32 6c ee			ld (debug_mark+1),a  
2729 3a 33 27			ld a, (.dmark+2)  
272c 32 6d ee			ld (debug_mark+2),a  
272f 18 03			jr .pastdmark  
2731 ..			.dmark: db "PA1"  
2734 f1			.pastdmark: pop af  
2735			endm  
# End of macro DMARK
2735						CALLMONITOR 
2735 cd 6f ee			call debug_vector  
2738				endm  
# End of macro CALLMONITOR
2738					endif 
2738 10 dd				djnz .pauses1 
273a			 
273a				       NEXTW 
273a c3 03 20			jp macro_next 
273d				endm 
# End of macro NEXTW
273d			.ROT: 
273d				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
273d 45				db WORD_SYS_CORE+49             
273e 8b 27			dw .UWORDS            
2740 04				db 3 + 1 
2741 .. 00			db "ROT",0              
2745				endm 
# End of macro CWHEAD
2745			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2745					if DEBUG_FORTH_WORDS_KEY 
2745						DMARK "ROT" 
2745 f5				push af  
2746 3a 5a 27			ld a, (.dmark)  
2749 32 6b ee			ld (debug_mark),a  
274c 3a 5b 27			ld a, (.dmark+1)  
274f 32 6c ee			ld (debug_mark+1),a  
2752 3a 5c 27			ld a, (.dmark+2)  
2755 32 6d ee			ld (debug_mark+2),a  
2758 18 03			jr .pastdmark  
275a ..			.dmark: db "ROT"  
275d f1			.pastdmark: pop af  
275e			endm  
# End of macro DMARK
275e						CALLMONITOR 
275e cd 6f ee			call debug_vector  
2761				endm  
# End of macro CALLMONITOR
2761					endif 
2761			 
2761					FORTH_DSP_VALUEHL 
2761 cd 4d 1e			call macro_dsp_valuehl 
2764				endm 
# End of macro FORTH_DSP_VALUEHL
2764 e5					push hl    ; u3  
2765			 
2765					FORTH_DSP_POP 
2765 cd 05 1f			call macro_forth_dsp_pop 
2768				endm 
# End of macro FORTH_DSP_POP
2768			   
2768					FORTH_DSP_VALUEHL 
2768 cd 4d 1e			call macro_dsp_valuehl 
276b				endm 
# End of macro FORTH_DSP_VALUEHL
276b e5					push hl     ; u2 
276c			 
276c					FORTH_DSP_POP 
276c cd 05 1f			call macro_forth_dsp_pop 
276f				endm 
# End of macro FORTH_DSP_POP
276f			 
276f					FORTH_DSP_VALUEHL 
276f cd 4d 1e			call macro_dsp_valuehl 
2772				endm 
# End of macro FORTH_DSP_VALUEHL
2772 e5					push hl     ; u1 
2773			 
2773					FORTH_DSP_POP 
2773 cd 05 1f			call macro_forth_dsp_pop 
2776				endm 
# End of macro FORTH_DSP_POP
2776			 
2776 c1					pop bc      ; u1 
2777 e1					pop hl      ; u2 
2778 d1					pop de      ; u3 
2779			 
2779			 
2779 c5					push bc 
277a d5					push de 
277b e5					push hl 
277c			 
277c			 
277c e1					pop hl 
277d cd 56 1c				call forth_push_numhl 
2780			 
2780 e1					pop hl 
2781 cd 56 1c				call forth_push_numhl 
2784			 
2784 e1					pop hl 
2785 cd 56 1c				call forth_push_numhl 
2788					 
2788			 
2788			 
2788			 
2788			 
2788			 
2788				       NEXTW 
2788 c3 03 20			jp macro_next 
278b				endm 
# End of macro NEXTW
278b			 
278b			.UWORDS: 
278b				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
278b 50				db WORD_SYS_CORE+60             
278c 4d 28			dw .BP            
278e 07				db 6 + 1 
278f .. 00			db "UWORDS",0              
2796				endm 
# End of macro CWHEAD
2796			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2796			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2796			; | | Following the count are the individual words. 
2796			; | | 
2796			; | | e.g. UWORDS 
2796			; | | BOX DIRLIST 2 
2796			; | |  
2796			; | | Can be used to save the words to storage via: 
2796			; | | UWORDS $01 DO $01 APPEND LOOP 
2796				if DEBUG_FORTH_WORDS_KEY 
2796					DMARK "UWR" 
2796 f5				push af  
2797 3a ab 27			ld a, (.dmark)  
279a 32 6b ee			ld (debug_mark),a  
279d 3a ac 27			ld a, (.dmark+1)  
27a0 32 6c ee			ld (debug_mark+1),a  
27a3 3a ad 27			ld a, (.dmark+2)  
27a6 32 6d ee			ld (debug_mark+2),a  
27a9 18 03			jr .pastdmark  
27ab ..			.dmark: db "UWR"  
27ae f1			.pastdmark: pop af  
27af			endm  
# End of macro DMARK
27af					CALLMONITOR 
27af cd 6f ee			call debug_vector  
27b2				endm  
# End of macro CALLMONITOR
27b2				endif 
27b2 21 a0 65				ld hl, baseram 
27b5					;ld hl, baseusermem 
27b5 01 00 00				ld bc, 0    ; start a counter 
27b8			 
27b8				; skip dict stub 
27b8			 
27b8 cd 54 21				call forth_tok_next 
27bb			 
27bb			 
27bb			; while we have words to look for 
27bb			 
27bb 7e			.douscan:	ld a, (hl)      
27bc				if DEBUG_FORTH_WORDS 
27bc					DMARK "UWs" 
27bc f5				push af  
27bd 3a d1 27			ld a, (.dmark)  
27c0 32 6b ee			ld (debug_mark),a  
27c3 3a d2 27			ld a, (.dmark+1)  
27c6 32 6c ee			ld (debug_mark+1),a  
27c9 3a d3 27			ld a, (.dmark+2)  
27cc 32 6d ee			ld (debug_mark+2),a  
27cf 18 03			jr .pastdmark  
27d1 ..			.dmark: db "UWs"  
27d4 f1			.pastdmark: pop af  
27d5			endm  
# End of macro DMARK
27d5					CALLMONITOR 
27d5 cd 6f ee			call debug_vector  
27d8				endm  
# End of macro CALLMONITOR
27d8				endif 
27d8 fe 00				cp WORD_SYS_END 
27da 28 4d				jr z, .udone 
27dc fe 01				cp WORD_SYS_UWORD 
27de 20 44				jr nz, .nuword 
27e0			 
27e0				if DEBUG_FORTH_WORDS 
27e0					DMARK "UWu" 
27e0 f5				push af  
27e1 3a f5 27			ld a, (.dmark)  
27e4 32 6b ee			ld (debug_mark),a  
27e7 3a f6 27			ld a, (.dmark+1)  
27ea 32 6c ee			ld (debug_mark+1),a  
27ed 3a f7 27			ld a, (.dmark+2)  
27f0 32 6d ee			ld (debug_mark+2),a  
27f3 18 03			jr .pastdmark  
27f5 ..			.dmark: db "UWu"  
27f8 f1			.pastdmark: pop af  
27f9			endm  
# End of macro DMARK
27f9					CALLMONITOR 
27f9 cd 6f ee			call debug_vector  
27fc				endm  
# End of macro CALLMONITOR
27fc				endif 
27fc					; we have a uword so push its name to the stack 
27fc			 
27fc e5				   	push hl  ; save so we can move to next dict block 
27fd			 
27fd					; skip opcode 
27fd 23					inc hl  
27fe					; skip next ptr 
27fe 23					inc hl  
27ff 23					inc hl 
2800					; skip len 
2800 23					inc hl 
2801				if DEBUG_FORTH_WORDS 
2801					DMARK "UWt" 
2801 f5				push af  
2802 3a 16 28			ld a, (.dmark)  
2805 32 6b ee			ld (debug_mark),a  
2808 3a 17 28			ld a, (.dmark+1)  
280b 32 6c ee			ld (debug_mark+1),a  
280e 3a 18 28			ld a, (.dmark+2)  
2811 32 6d ee			ld (debug_mark+2),a  
2814 18 03			jr .pastdmark  
2816 ..			.dmark: db "UWt"  
2819 f1			.pastdmark: pop af  
281a			endm  
# End of macro DMARK
281a					CALLMONITOR 
281a cd 6f ee			call debug_vector  
281d				endm  
# End of macro CALLMONITOR
281d				endif 
281d 03					inc bc 
281e			 
281e c5					push bc 
281f cd c4 1c				call forth_push_str 
2822 c1					pop bc 
2823			 
2823 e1					pop hl 	 
2824			 
2824 cd 54 21		.nuword:	call forth_tok_next 
2827 18 92				jr .douscan  
2829			 
2829			.udone:		 ; push count of uwords found 
2829 c5					push bc 
282a e1					pop hl 
282b			 
282b				if DEBUG_FORTH_WORDS 
282b					DMARK "UWc" 
282b f5				push af  
282c 3a 40 28			ld a, (.dmark)  
282f 32 6b ee			ld (debug_mark),a  
2832 3a 41 28			ld a, (.dmark+1)  
2835 32 6c ee			ld (debug_mark+1),a  
2838 3a 42 28			ld a, (.dmark+2)  
283b 32 6d ee			ld (debug_mark+2),a  
283e 18 03			jr .pastdmark  
2840 ..			.dmark: db "UWc"  
2843 f1			.pastdmark: pop af  
2844			endm  
# End of macro DMARK
2844					CALLMONITOR 
2844 cd 6f ee			call debug_vector  
2847				endm  
# End of macro CALLMONITOR
2847				endif 
2847 cd 56 1c				call forth_push_numhl 
284a			 
284a			 
284a				       NEXTW 
284a c3 03 20			jp macro_next 
284d				endm 
# End of macro NEXTW
284d			 
284d			.BP: 
284d				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
284d 54				db WORD_SYS_CORE+64             
284e 87 28			dw .MONITOR            
2850 03				db 2 + 1 
2851 .. 00			db "BP",0              
2854				endm 
# End of macro CWHEAD
2854			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2854			; | | $00 Will enable the break points within specific code paths 
2854			; | | $01 Will disable break points 
2854			; | |  
2854			; | | By default break points are off. Either the above can be used to enable them 
2854			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2854			; | | and on release of the pressed key a message will be disaplayed to notify 
2854			; | | that break points are enabled. Pressing any key will then continue boot process. 
2854					; get byte count 
2854					if DEBUG_FORTH_WORDS_KEY 
2854						DMARK "BP." 
2854 f5				push af  
2855 3a 69 28			ld a, (.dmark)  
2858 32 6b ee			ld (debug_mark),a  
285b 3a 6a 28			ld a, (.dmark+1)  
285e 32 6c ee			ld (debug_mark+1),a  
2861 3a 6b 28			ld a, (.dmark+2)  
2864 32 6d ee			ld (debug_mark+2),a  
2867 18 03			jr .pastdmark  
2869 ..			.dmark: db "BP."  
286c f1			.pastdmark: pop af  
286d			endm  
# End of macro DMARK
286d						CALLMONITOR 
286d cd 6f ee			call debug_vector  
2870				endm  
# End of macro CALLMONITOR
2870					endif 
2870			 
2870					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2870 cd 4d 1e			call macro_dsp_valuehl 
2873				endm 
# End of macro FORTH_DSP_VALUEHL
2873			 
2873			;		push hl 
2873			 
2873					; destroy value TOS 
2873			 
2873					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2873 cd 05 1f			call macro_forth_dsp_pop 
2876				endm 
# End of macro FORTH_DSP_POP
2876			 
2876			;		pop hl 
2876			 
2876 3e 00				ld a,0 
2878 bd					cp l 
2879 28 06				jr z, .bpset 
287b			;		ld a, '*' 
287b cd e9 15				call bp_off 
287e					NEXTW 
287e c3 03 20			jp macro_next 
2881				endm 
# End of macro NEXTW
2881			 
2881			.bpset:	 
2881					;	ld (os_view_disable), a 
2881 cd dd 15				call bp_on 
2884			 
2884			 
2884					NEXTW 
2884 c3 03 20			jp macro_next 
2887				endm 
# End of macro NEXTW
2887			 
2887			 
2887			.MONITOR: 
2887				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2887 55				db WORD_SYS_CORE+65             
2888 b8 28			dw .MALLOC            
288a 08				db 7 + 1 
288b .. 00			db "MONITOR",0              
2893				endm 
# End of macro CWHEAD
2893			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2893			; | | At start the current various registers will be displayed with contents. 
2893			; | | Top right corner will show the most recent debug marker seen. 
2893			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2893			; | | and the return stack pointer (RSP). 
2893			; | | Pressing: 
2893			; | |    1 - Initial screen 
2893			; | |    2 - Display a data dump of HL 
2893			; | |    3 - Display a data dump of DE 
2893			; | |    4 - Display a data dump of BC 
2893			; | |    5 - Display a data dump of HL 
2893			; | |    6 - Display a data dump of DSP 
2893			; | |    7 - Display a data dump of RSP 
2893			; | |    8 - Display a data dump of what is at DSP 
2893			; | |    9 - Display a data dump of what is at RSP 
2893			; | |    0 - Exit monitor and continue running. This will also enable break points 
2893			; | |    * - Disable break points 
2893			; | |    # - Enter traditional monitor mode 
2893			; | | 
2893			; | | Monitor Mode 
2893			; | | ------------ 
2893			; | | A prompt of '>' will be shown for various commands: 
2893			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2893			; | |    C - Continue display a data dump from the last set address 
2893			; | |    M xxxx - Set start of memory edit at address xx 
2893			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2893			; | |    Q - Return to previous 
2893					if DEBUG_FORTH_WORDS_KEY 
2893						DMARK "MON" 
2893 f5				push af  
2894 3a a8 28			ld a, (.dmark)  
2897 32 6b ee			ld (debug_mark),a  
289a 3a a9 28			ld a, (.dmark+1)  
289d 32 6c ee			ld (debug_mark+1),a  
28a0 3a aa 28			ld a, (.dmark+2)  
28a3 32 6d ee			ld (debug_mark+2),a  
28a6 18 03			jr .pastdmark  
28a8 ..			.dmark: db "MON"  
28ab f1			.pastdmark: pop af  
28ac			endm  
# End of macro DMARK
28ac						CALLMONITOR 
28ac cd 6f ee			call debug_vector  
28af				endm  
# End of macro CALLMONITOR
28af					endif 
28af			;		ld a, 0 
28af			;		ld (os_view_disable), a 
28af cd dd 15				call bp_on 
28b2			 
28b2					CALLMONITOR 
28b2 cd 6f ee			call debug_vector  
28b5				endm  
# End of macro CALLMONITOR
28b5			 
28b5			;	call monitor 
28b5			 
28b5					NEXTW 
28b5 c3 03 20			jp macro_next 
28b8				endm 
# End of macro NEXTW
28b8			 
28b8			 
28b8			.MALLOC: 
28b8				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
28b8 56				db WORD_SYS_CORE+66             
28b9 e1 28			dw .MALLOC2            
28bb 06				db 5 + 1 
28bc .. 00			db "ALLOT",0              
28c2				endm 
# End of macro CWHEAD
28c2			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28c2					if DEBUG_FORTH_WORDS_KEY 
28c2						DMARK "ALL" 
28c2 f5				push af  
28c3 3a d7 28			ld a, (.dmark)  
28c6 32 6b ee			ld (debug_mark),a  
28c9 3a d8 28			ld a, (.dmark+1)  
28cc 32 6c ee			ld (debug_mark+1),a  
28cf 3a d9 28			ld a, (.dmark+2)  
28d2 32 6d ee			ld (debug_mark+2),a  
28d5 18 03			jr .pastdmark  
28d7 ..			.dmark: db "ALL"  
28da f1			.pastdmark: pop af  
28db			endm  
# End of macro DMARK
28db						CALLMONITOR 
28db cd 6f ee			call debug_vector  
28de				endm  
# End of macro CALLMONITOR
28de					endif 
28de c3 08 29				jp .mallocc 
28e1			.MALLOC2: 
28e1				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
28e1 56				db WORD_SYS_CORE+66             
28e2 1f 29			dw .FREE            
28e4 07				db 6 + 1 
28e5 .. 00			db "MALLOC",0              
28ec				endm 
# End of macro CWHEAD
28ec			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28ec					; get byte count 
28ec					if DEBUG_FORTH_WORDS_KEY 
28ec						DMARK "MAL" 
28ec f5				push af  
28ed 3a 01 29			ld a, (.dmark)  
28f0 32 6b ee			ld (debug_mark),a  
28f3 3a 02 29			ld a, (.dmark+1)  
28f6 32 6c ee			ld (debug_mark+1),a  
28f9 3a 03 29			ld a, (.dmark+2)  
28fc 32 6d ee			ld (debug_mark+2),a  
28ff 18 03			jr .pastdmark  
2901 ..			.dmark: db "MAL"  
2904 f1			.pastdmark: pop af  
2905			endm  
# End of macro DMARK
2905						CALLMONITOR 
2905 cd 6f ee			call debug_vector  
2908				endm  
# End of macro CALLMONITOR
2908					endif 
2908			.mallocc: 
2908					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2908 cd 4d 1e			call macro_dsp_valuehl 
290b				endm 
# End of macro FORTH_DSP_VALUEHL
290b			 
290b			;		push hl 
290b			 
290b					; destroy value TOS 
290b			 
290b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
290b cd 05 1f			call macro_forth_dsp_pop 
290e				endm 
# End of macro FORTH_DSP_POP
290e			 
290e			;		pop hl 
290e cd ae 12				call malloc 
2911				if DEBUG_FORTH_MALLOC_GUARD 
2911 f5					push af 
2912 cd 10 0e				call ishlzero 
2915			;		ld a, l 
2915			;		add h 
2915			;		cp 0 
2915 f1					pop af 
2916					 
2916 cc 42 4d				call z,malloc_error 
2919				endif 
2919			 
2919 cd 56 1c				call forth_push_numhl 
291c					NEXTW 
291c c3 03 20			jp macro_next 
291f				endm 
# End of macro NEXTW
291f			 
291f			.FREE: 
291f				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
291f 57				db WORD_SYS_CORE+67             
2920 50 29			dw .LIST            
2922 05				db 4 + 1 
2923 .. 00			db "FREE",0              
2928				endm 
# End of macro CWHEAD
2928			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2928					if DEBUG_FORTH_WORDS_KEY 
2928						DMARK "FRE" 
2928 f5				push af  
2929 3a 3d 29			ld a, (.dmark)  
292c 32 6b ee			ld (debug_mark),a  
292f 3a 3e 29			ld a, (.dmark+1)  
2932 32 6c ee			ld (debug_mark+1),a  
2935 3a 3f 29			ld a, (.dmark+2)  
2938 32 6d ee			ld (debug_mark+2),a  
293b 18 03			jr .pastdmark  
293d ..			.dmark: db "FRE"  
2940 f1			.pastdmark: pop af  
2941			endm  
# End of macro DMARK
2941						CALLMONITOR 
2941 cd 6f ee			call debug_vector  
2944				endm  
# End of macro CALLMONITOR
2944					endif 
2944					; get address 
2944			 
2944					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2944 cd 4d 1e			call macro_dsp_valuehl 
2947				endm 
# End of macro FORTH_DSP_VALUEHL
2947			 
2947			;		push hl 
2947			 
2947					; destroy value TOS 
2947			 
2947					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2947 cd 05 1f			call macro_forth_dsp_pop 
294a				endm 
# End of macro FORTH_DSP_POP
294a			 
294a			;		pop hl 
294a			if FORTH_ENABLE_MALLOCFREE 
294a cd 78 13				call free 
294d			endif 
294d					NEXTW 
294d c3 03 20			jp macro_next 
2950				endm 
# End of macro NEXTW
2950			.LIST: 
2950				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2950 5c				db WORD_SYS_CORE+72             
2951 3e 2b			dw .FORGET            
2953 05				db 4 + 1 
2954 .. 00			db "LIST",0              
2959				endm 
# End of macro CWHEAD
2959			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2959			; | | The quoted word must be in upper case. 
2959				if DEBUG_FORTH_WORDS_KEY 
2959					DMARK "LST" 
2959 f5				push af  
295a 3a 6e 29			ld a, (.dmark)  
295d 32 6b ee			ld (debug_mark),a  
2960 3a 6f 29			ld a, (.dmark+1)  
2963 32 6c ee			ld (debug_mark+1),a  
2966 3a 70 29			ld a, (.dmark+2)  
2969 32 6d ee			ld (debug_mark+2),a  
296c 18 03			jr .pastdmark  
296e ..			.dmark: db "LST"  
2971 f1			.pastdmark: pop af  
2972			endm  
# End of macro DMARK
2972					CALLMONITOR 
2972 cd 6f ee			call debug_vector  
2975				endm  
# End of macro CALLMONITOR
2975				endif 
2975			 
2975					FORTH_DSP_VALUEHL 
2975 cd 4d 1e			call macro_dsp_valuehl 
2978				endm 
# End of macro FORTH_DSP_VALUEHL
2978			 
2978 e5					push hl 
2979					FORTH_DSP_POP 
2979 cd 05 1f			call macro_forth_dsp_pop 
297c				endm 
# End of macro FORTH_DSP_POP
297c c1					pop bc 
297d			 
297d			; Start format of scratch string 
297d			 
297d 21 c1 e2				ld hl, scratch 
2980			 
2980 3e 3a				ld a, ':' 
2982 77					ld (hl),a 
2983 23					inc hl 
2984 3e 20				ld a, ' ' 
2986 77					ld (hl), a 
2987			 
2987					; Get ptr to the word we need to look up 
2987			 
2987			;		FORTH_DSP_VALUEHL 
2987					;v5 FORTH_DSP_VALUE 
2987				; TODO type check 
2987			;		inc hl    ; Skip type check  
2987			;		push hl 
2987			;		ex de, hl    ; put into DE 
2987			 
2987			 
2987 21 a0 65				ld hl, baseram 
298a					;ld hl, baseusermem 
298a			 
298a e5			push hl   ; sacreifical push 
298b			 
298b			.ldouscanm: 
298b e1				pop hl 
298c			.ldouscan: 
298c				if DEBUG_FORTH_WORDS 
298c					DMARK "LSs" 
298c f5				push af  
298d 3a a1 29			ld a, (.dmark)  
2990 32 6b ee			ld (debug_mark),a  
2993 3a a2 29			ld a, (.dmark+1)  
2996 32 6c ee			ld (debug_mark+1),a  
2999 3a a3 29			ld a, (.dmark+2)  
299c 32 6d ee			ld (debug_mark+2),a  
299f 18 03			jr .pastdmark  
29a1 ..			.dmark: db "LSs"  
29a4 f1			.pastdmark: pop af  
29a5			endm  
# End of macro DMARK
29a5					CALLMONITOR 
29a5 cd 6f ee			call debug_vector  
29a8				endm  
# End of macro CALLMONITOR
29a8				endif 
29a8				; skip dict stub 
29a8 cd 54 21				call forth_tok_next 
29ab			 
29ab			 
29ab			; while we have words to look for 
29ab			 
29ab 7e				ld a, (hl)      
29ac				if DEBUG_FORTH_WORDS 
29ac					DMARK "LSk" 
29ac f5				push af  
29ad 3a c1 29			ld a, (.dmark)  
29b0 32 6b ee			ld (debug_mark),a  
29b3 3a c2 29			ld a, (.dmark+1)  
29b6 32 6c ee			ld (debug_mark+1),a  
29b9 3a c3 29			ld a, (.dmark+2)  
29bc 32 6d ee			ld (debug_mark+2),a  
29bf 18 03			jr .pastdmark  
29c1 ..			.dmark: db "LSk"  
29c4 f1			.pastdmark: pop af  
29c5			endm  
# End of macro DMARK
29c5					CALLMONITOR 
29c5 cd 6f ee			call debug_vector  
29c8				endm  
# End of macro CALLMONITOR
29c8				endif 
29c8					;cp WORD_SYS_END 
29c8					;jp z, .lunotfound 
29c8			 
29c8					; if we hit non uwords then gone too far 
29c8 fe 01				cp WORD_SYS_UWORD 
29ca c2 fa 2a				jp nz, .lunotfound 
29cd			 
29cd				if DEBUG_FORTH_WORDS 
29cd					DMARK "LSu" 
29cd f5				push af  
29ce 3a e2 29			ld a, (.dmark)  
29d1 32 6b ee			ld (debug_mark),a  
29d4 3a e3 29			ld a, (.dmark+1)  
29d7 32 6c ee			ld (debug_mark+1),a  
29da 3a e4 29			ld a, (.dmark+2)  
29dd 32 6d ee			ld (debug_mark+2),a  
29e0 18 03			jr .pastdmark  
29e2 ..			.dmark: db "LSu"  
29e5 f1			.pastdmark: pop af  
29e6			endm  
# End of macro DMARK
29e6					CALLMONITOR 
29e6 cd 6f ee			call debug_vector  
29e9				endm  
# End of macro CALLMONITOR
29e9				endif 
29e9			 
29e9					; found a uword but is it the one we want... 
29e9			 
29e9 c5					push bc     ; uword to find is on bc 
29ea d1					pop de 
29eb			 
29eb e5					push hl  ; to save the ptr 
29ec			 
29ec					; skip opcode 
29ec 23					inc hl  
29ed					; skip next ptr 
29ed 23					inc hl  
29ee 23					inc hl 
29ef					; skip len 
29ef 23					inc hl 
29f0			 
29f0				if DEBUG_FORTH_WORDS 
29f0					DMARK "LSc" 
29f0 f5				push af  
29f1 3a 05 2a			ld a, (.dmark)  
29f4 32 6b ee			ld (debug_mark),a  
29f7 3a 06 2a			ld a, (.dmark+1)  
29fa 32 6c ee			ld (debug_mark+1),a  
29fd 3a 07 2a			ld a, (.dmark+2)  
2a00 32 6d ee			ld (debug_mark+2),a  
2a03 18 03			jr .pastdmark  
2a05 ..			.dmark: db "LSc"  
2a08 f1			.pastdmark: pop af  
2a09			endm  
# End of macro DMARK
2a09					CALLMONITOR 
2a09 cd 6f ee			call debug_vector  
2a0c				endm  
# End of macro CALLMONITOR
2a0c				endif 
2a0c cd 7d 12				call strcmp 
2a0f c2 8b 29				jp nz, .ldouscanm 
2a12				 
2a12			 
2a12			 
2a12					; we have a uword so push its name to the stack 
2a12			 
2a12			;	   	push hl  ; save so we can move to next dict block 
2a12 e1			pop hl 
2a13			 
2a13				if DEBUG_FORTH_WORDS 
2a13					DMARK "LSm" 
2a13 f5				push af  
2a14 3a 28 2a			ld a, (.dmark)  
2a17 32 6b ee			ld (debug_mark),a  
2a1a 3a 29 2a			ld a, (.dmark+1)  
2a1d 32 6c ee			ld (debug_mark+1),a  
2a20 3a 2a 2a			ld a, (.dmark+2)  
2a23 32 6d ee			ld (debug_mark+2),a  
2a26 18 03			jr .pastdmark  
2a28 ..			.dmark: db "LSm"  
2a2b f1			.pastdmark: pop af  
2a2c			endm  
# End of macro DMARK
2a2c					CALLMONITOR 
2a2c cd 6f ee			call debug_vector  
2a2f				endm  
# End of macro CALLMONITOR
2a2f				endif 
2a2f			 
2a2f					; skip opcode 
2a2f 23					inc hl  
2a30					; skip next ptr 
2a30 23					inc hl  
2a31 23					inc hl 
2a32					; skip len 
2a32 7e					ld a, (hl)   ; save length to add 
2a33				if DEBUG_FORTH_WORDS 
2a33					DMARK "LS2" 
2a33 f5				push af  
2a34 3a 48 2a			ld a, (.dmark)  
2a37 32 6b ee			ld (debug_mark),a  
2a3a 3a 49 2a			ld a, (.dmark+1)  
2a3d 32 6c ee			ld (debug_mark+1),a  
2a40 3a 4a 2a			ld a, (.dmark+2)  
2a43 32 6d ee			ld (debug_mark+2),a  
2a46 18 03			jr .pastdmark  
2a48 ..			.dmark: db "LS2"  
2a4b f1			.pastdmark: pop af  
2a4c			endm  
# End of macro DMARK
2a4c					CALLMONITOR 
2a4c cd 6f ee			call debug_vector  
2a4f				endm  
# End of macro CALLMONITOR
2a4f				endif 
2a4f			 
2a4f					; save this location 
2a4f				 
2a4f e5					push hl 
2a50			 
2a50 23					inc hl 
2a51 11 c3 e2				ld de, scratch+2 
2a54 4f					ld c, a 
2a55 06 00				ld b, 0 
2a57			 
2a57				if DEBUG_FORTH_WORDS 
2a57					DMARK "LSn" 
2a57 f5				push af  
2a58 3a 6c 2a			ld a, (.dmark)  
2a5b 32 6b ee			ld (debug_mark),a  
2a5e 3a 6d 2a			ld a, (.dmark+1)  
2a61 32 6c ee			ld (debug_mark+1),a  
2a64 3a 6e 2a			ld a, (.dmark+2)  
2a67 32 6d ee			ld (debug_mark+2),a  
2a6a 18 03			jr .pastdmark  
2a6c ..			.dmark: db "LSn"  
2a6f f1			.pastdmark: pop af  
2a70			endm  
# End of macro DMARK
2a70					CALLMONITOR 
2a70 cd 6f ee			call debug_vector  
2a73				endm  
# End of macro CALLMONITOR
2a73				endif 
2a73			 
2a73					; copy uword name to scratch 
2a73			 
2a73 ed b0				ldir 
2a75			 
2a75 1b					dec de 
2a76 3e 20				ld a, ' '    ; change null to space 
2a78 12					ld (de), a 
2a79			 
2a79 13					inc de 
2a7a			 
2a7a d5					push de 
2a7b c1					pop bc     ; move scratch pointer to end of word name and save it 
2a7c			 
2a7c e1					pop hl 
2a7d 7e					ld a, (hl) 
2a7e					;inc hl 
2a7e					; skip word string 
2a7e cd e7 0d				call addatohl 
2a81			 
2a81 23					inc hl 
2a82			 
2a82				if DEBUG_FORTH_WORDS 
2a82					DMARK "LS3" 
2a82 f5				push af  
2a83 3a 97 2a			ld a, (.dmark)  
2a86 32 6b ee			ld (debug_mark),a  
2a89 3a 98 2a			ld a, (.dmark+1)  
2a8c 32 6c ee			ld (debug_mark+1),a  
2a8f 3a 99 2a			ld a, (.dmark+2)  
2a92 32 6d ee			ld (debug_mark+2),a  
2a95 18 03			jr .pastdmark  
2a97 ..			.dmark: db "LS3"  
2a9a f1			.pastdmark: pop af  
2a9b			endm  
# End of macro DMARK
2a9b					CALLMONITOR 
2a9b cd 6f ee			call debug_vector  
2a9e				endm  
# End of macro CALLMONITOR
2a9e				endif 
2a9e					; should now be at the start of the machine code to setup the eval of the uword 
2a9e					; now locate the ptr to the string defintion 
2a9e			 
2a9e					; skip ld hl, 
2a9e					; then load the ptr 
2a9e			; TODO use get from hl ptr 
2a9e 23					inc hl 
2a9f 5e					ld e, (hl) 
2aa0 23					inc hl 
2aa1 56					ld d, (hl) 
2aa2 eb					ex de, hl 
2aa3			 
2aa3			 
2aa3				if DEBUG_FORTH_WORDS 
2aa3					DMARK "LSt" 
2aa3 f5				push af  
2aa4 3a b8 2a			ld a, (.dmark)  
2aa7 32 6b ee			ld (debug_mark),a  
2aaa 3a b9 2a			ld a, (.dmark+1)  
2aad 32 6c ee			ld (debug_mark+1),a  
2ab0 3a ba 2a			ld a, (.dmark+2)  
2ab3 32 6d ee			ld (debug_mark+2),a  
2ab6 18 03			jr .pastdmark  
2ab8 ..			.dmark: db "LSt"  
2abb f1			.pastdmark: pop af  
2abc			endm  
# End of macro DMARK
2abc					CALLMONITOR 
2abc cd 6f ee			call debug_vector  
2abf				endm  
# End of macro CALLMONITOR
2abf				endif 
2abf			 
2abf			; cant push right now due to tokenised strings  
2abf			 
2abf			; get the destination of where to copy this definition to. 
2abf			 
2abf c5					push bc 
2ac0 d1					pop de 
2ac1			 
2ac1 7e			.listl:         ld a,(hl) 
2ac2 fe 00				cp 0 
2ac4 28 09				jr z, .lreplsp     ; replace zero with space 
2ac6					;cp FORTH_END_BUFFER 
2ac6 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2ac8 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2aca				 
2aca					; just copy this char as is then 
2aca			 
2aca 12					ld (de), a 
2acb			 
2acb 23			.listnxt:	inc hl 
2acc 13					inc de 
2acd 18 f2				jr .listl 
2acf			 
2acf 3e 20		.lreplsp:	ld a,' ' 
2ad1 12					ld (de), a 
2ad2 18 f7				jr .listnxt 
2ad4			 
2ad4			; close up uword def 
2ad4			 
2ad4			.listdone: 
2ad4 12					ld (de), a 
2ad5 13					inc de 
2ad6 3e 00				ld a, 0 
2ad8 12					ld (de), a 
2ad9			 
2ad9			; now have def so clean up and push to stack 
2ad9			 
2ad9 21 c1 e2				ld hl, scratch 
2adc				if DEBUG_FORTH_WORDS 
2adc					DMARK "Ltp" 
2adc f5				push af  
2add 3a f1 2a			ld a, (.dmark)  
2ae0 32 6b ee			ld (debug_mark),a  
2ae3 3a f2 2a			ld a, (.dmark+1)  
2ae6 32 6c ee			ld (debug_mark+1),a  
2ae9 3a f3 2a			ld a, (.dmark+2)  
2aec 32 6d ee			ld (debug_mark+2),a  
2aef 18 03			jr .pastdmark  
2af1 ..			.dmark: db "Ltp"  
2af4 f1			.pastdmark: pop af  
2af5			endm  
# End of macro DMARK
2af5					CALLMONITOR 
2af5 cd 6f ee			call debug_vector  
2af8				endm  
# End of macro CALLMONITOR
2af8				endif 
2af8			 
2af8 18 1f			jr .listpush 
2afa			 
2afa			;.lnuword:	pop hl 
2afa			;		call forth_tok_next 
2afa			;		jp .ldouscan  
2afa			 
2afa			.lunotfound:		  
2afa			 
2afa				if DEBUG_FORTH_WORDS 
2afa					DMARK "LSn" 
2afa f5				push af  
2afb 3a 0f 2b			ld a, (.dmark)  
2afe 32 6b ee			ld (debug_mark),a  
2b01 3a 10 2b			ld a, (.dmark+1)  
2b04 32 6c ee			ld (debug_mark+1),a  
2b07 3a 11 2b			ld a, (.dmark+2)  
2b0a 32 6d ee			ld (debug_mark+2),a  
2b0d 18 03			jr .pastdmark  
2b0f ..			.dmark: db "LSn"  
2b12 f1			.pastdmark: pop af  
2b13			endm  
# End of macro DMARK
2b13					CALLMONITOR 
2b13 cd 6f ee			call debug_vector  
2b16				endm  
# End of macro CALLMONITOR
2b16				endif 
2b16			 
2b16					 
2b16			;		FORTH_DSP_POP 
2b16			;		ld hl, .luno 
2b16			 
2b16					NEXTW			 
2b16 c3 03 20			jp macro_next 
2b19				endm 
# End of macro NEXTW
2b19			 
2b19			.listpush: 
2b19				if DEBUG_FORTH_WORDS 
2b19					DMARK "LS>" 
2b19 f5				push af  
2b1a 3a 2e 2b			ld a, (.dmark)  
2b1d 32 6b ee			ld (debug_mark),a  
2b20 3a 2f 2b			ld a, (.dmark+1)  
2b23 32 6c ee			ld (debug_mark+1),a  
2b26 3a 30 2b			ld a, (.dmark+2)  
2b29 32 6d ee			ld (debug_mark+2),a  
2b2c 18 03			jr .pastdmark  
2b2e ..			.dmark: db "LS>"  
2b31 f1			.pastdmark: pop af  
2b32			endm  
# End of macro DMARK
2b32					CALLMONITOR 
2b32 cd 6f ee			call debug_vector  
2b35				endm  
# End of macro CALLMONITOR
2b35				endif 
2b35 cd c4 1c				call forth_push_str 
2b38			 
2b38			 
2b38			 
2b38					NEXTW 
2b38 c3 03 20			jp macro_next 
2b3b				endm 
# End of macro NEXTW
2b3b			 
2b3b			;.luno:    db "Word not found",0 
2b3b			 
2b3b			 
2b3b			 
2b3b			 
2b3b			 
2b3b			;		push hl   ; save pointer to start of uword def string 
2b3b			; 
2b3b			;; look for FORTH_EOL_LINE 
2b3b			;		ld a, FORTH_END_BUFFER 
2b3b			;		call strlent 
2b3b			; 
2b3b			;		inc hl		 ; space for coln def 
2b3b			;		inc hl 
2b3b			;		inc hl          ; space for terms 
2b3b			;		inc hl 
2b3b			; 
2b3b			;		ld a, 20   ; TODO get actual length 
2b3b			;		call addatohl    ; include a random amount of room for the uword name 
2b3b			; 
2b3b			;		 
2b3b			;	if DEBUG_FORTH_WORDS 
2b3b			;		DMARK "Lt1" 
2b3b			;		CALLMONITOR 
2b3b			;	endif 
2b3b			;		 
2b3b			; 
2b3b			;; malloc space for the string because we cant change it 
2b3b			; 
2b3b			;		call malloc 
2b3b			;	if DEBUG_FORTH_MALLOC_GUARD 
2b3b			;		push af 
2b3b			;		call ishlzero 
2b3b			;		pop af 
2b3b			;		 
2b3b			;		call z,malloc_error 
2b3b			;	endif 
2b3b			; 
2b3b			;	if DEBUG_FORTH_WORDS 
2b3b			;		DMARK "Lt2" 
2b3b			;		CALLMONITOR 
2b3b			;	endif 
2b3b			;		pop de 
2b3b			;		push hl    ; push the malloc to release later 
2b3b			;		push hl   ;  push back a copy for the later stack push 
2b3b			;		 
2b3b			;; copy the string swapping out the zero terms for spaces 
2b3b			; 
2b3b			;		; de has our source 
2b3b			;		; hl has our dest 
2b3b			; 
2b3b			;; add the coln def 
2b3b			; 
2b3b			;		ld a, ':' 
2b3b			;		ld (hl), a 
2b3b			;		inc hl 
2b3b			;		ld a, ' ' 
2b3b			;		ld (hl), a 
2b3b			;		inc hl 
2b3b			; 
2b3b			;; add the uname word 
2b3b			;		push de   ; save our string for now 
2b3b			;		ex de, hl 
2b3b			; 
2b3b			;		FORTH_DSP_VALUE 
2b3b			;		;v5 FORTH_DSP_VALUE 
2b3b			; 
2b3b			;		inc hl   ; skip type but we know by now this is OK 
2b3b			; 
2b3b			;.luword:	ld a,(hl) 
2b3b			;		cp 0 
2b3b			;		jr z, .luword2 
2b3b			;		ld (de), a 
2b3b			;		inc de 
2b3b			;		inc hl 
2b3b			;		jr .luword 
2b3b			; 
2b3b			;.luword2:	ld a, ' ' 
2b3b			;		ld (de), a 
2b3b			;;		inc hl 
2b3b			;;		inc de 
2b3b			;;		ld (de), a 
2b3b			;;		inc hl 
2b3b			;		inc de 
2b3b			; 
2b3b			;		ex de, hl 
2b3b			;		pop de 
2b3b			;		 
2b3b			;		 
2b3b			; 
2b3b			;; detoken that string and copy it 
2b3b			; 
2b3b			;	if DEBUG_FORTH_WORDS 
2b3b			;		DMARK "Lt2" 
2b3b			;		CALLMONITOR 
2b3b			;	endif 
2b3b			;.ldetok:	ld a, (de) 
2b3b			;		cp FORTH_END_BUFFER 
2b3b			;		jr z, .ldetokend 
2b3b			;		; swap out any zero term for space 
2b3b			;		cp 0 
2b3b			;		jr nz, .ldetoknext 
2b3b			;		ld a, ' ' 
2b3b			; 
2b3b			;	if DEBUG_FORTH_WORDS 
2b3b			;		DMARK "LtS" 
2b3b			;		CALLMONITOR 
2b3b			;	endif 
2b3b			;.ldetoknext:	ld (hl), a 
2b3b			;		inc de 
2b3b			;		inc hl 
2b3b			;		jr .ldetok 
2b3b			; 
2b3b			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b3b			;		ld (hl), a  
2b3b			; 
2b3b			;; free that temp malloc 
2b3b			; 
2b3b			;		pop hl    
2b3b			; 
2b3b			;	if DEBUG_FORTH_WORDS 
2b3b			;		DMARK "Lt4" 
2b3b			;		CALLMONITOR 
2b3b			;	endif 
2b3b			;		call forth_apushstrhl 
2b3b			; 
2b3b			;		; get rid of temp malloc area 
2b3b			; 
2b3b			;		pop hl 
2b3b			;		call free 
2b3b			; 
2b3b			;		jr .ludone 
2b3b			; 
2b3b			;.lnuword:	pop hl 
2b3b			;		call forth_tok_next 
2b3b			;		jp .ldouscan  
2b3b			; 
2b3b			;.ludone:		 pop hl 
2b3b			; 
2b3b					NEXTW 
2b3b c3 03 20			jp macro_next 
2b3e				endm 
# End of macro NEXTW
2b3e			 
2b3e			.FORGET: 
2b3e				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b3e 5d				db WORD_SYS_CORE+73             
2b3f b7 2b			dw .NOP            
2b41 07				db 6 + 1 
2b42 .. 00			db "FORGET",0              
2b49				endm 
# End of macro CWHEAD
2b49			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b49			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b49			; | |  
2b49			; | | e.g. "MORE" forget 
2b49					if DEBUG_FORTH_WORDS_KEY 
2b49						DMARK "FRG" 
2b49 f5				push af  
2b4a 3a 5e 2b			ld a, (.dmark)  
2b4d 32 6b ee			ld (debug_mark),a  
2b50 3a 5f 2b			ld a, (.dmark+1)  
2b53 32 6c ee			ld (debug_mark+1),a  
2b56 3a 60 2b			ld a, (.dmark+2)  
2b59 32 6d ee			ld (debug_mark+2),a  
2b5c 18 03			jr .pastdmark  
2b5e ..			.dmark: db "FRG"  
2b61 f1			.pastdmark: pop af  
2b62			endm  
# End of macro DMARK
2b62						CALLMONITOR 
2b62 cd 6f ee			call debug_vector  
2b65				endm  
# End of macro CALLMONITOR
2b65					endif 
2b65			 
2b65				; find uword 
2b65			        ; update start of word with "_" 
2b65				; replace uword with deleted flag 
2b65			 
2b65			 
2b65			;	if DEBUG_FORTH_WORDS 
2b65			;		DMARK "FOG" 
2b65			;		CALLMONITOR 
2b65			;	endif 
2b65			 
2b65			 
2b65					; Get ptr to the word we need to look up 
2b65			 
2b65					FORTH_DSP_VALUEHL 
2b65 cd 4d 1e			call macro_dsp_valuehl 
2b68				endm 
# End of macro FORTH_DSP_VALUEHL
2b68					;v5 FORTH_DSP_VALUE 
2b68				; TODO type check 
2b68			;		inc hl    ; Skip type check  
2b68 e5					push hl 
2b69 c1					pop bc 
2b6a			;		ex de, hl    ; put into DE 
2b6a			 
2b6a			 
2b6a 21 a0 65				ld hl, baseram 
2b6d					;ld hl, baseusermem 
2b6d			 
2b6d				; skip dict stub 
2b6d			;	call forth_tok_next 
2b6d e5			push hl   ; sacreifical push 
2b6e			 
2b6e			.fldouscanm: 
2b6e e1				pop hl 
2b6f			.fldouscan: 
2b6f			;	if DEBUG_FORTH_WORDS 
2b6f			;		DMARK "LSs" 
2b6f			;		CALLMONITOR 
2b6f			;	endif 
2b6f				; skip dict stub 
2b6f cd 54 21				call forth_tok_next 
2b72			 
2b72			 
2b72			; while we have words to look for 
2b72			 
2b72 7e				ld a, (hl)      
2b73			;	if DEBUG_FORTH_WORDS 
2b73			;		DMARK "LSk" 
2b73			;		CALLMONITOR 
2b73			;	endif 
2b73 fe 00				cp WORD_SYS_END 
2b75 ca b1 2b				jp z, .flunotfound 
2b78 fe 01				cp WORD_SYS_UWORD 
2b7a c2 6f 2b				jp nz, .fldouscan 
2b7d			 
2b7d			;	if DEBUG_FORTH_WORDS 
2b7d			;		DMARK "LSu" 
2b7d			;		CALLMONITOR 
2b7d			;	endif 
2b7d			 
2b7d					; found a uword but is it the one we want... 
2b7d			 
2b7d c5					push bc     ; uword to find is on bc 
2b7e d1					pop de 
2b7f			 
2b7f e5					push hl  ; to save the ptr 
2b80			 
2b80					; skip opcode 
2b80 23					inc hl  
2b81					; skip next ptr 
2b81 23					inc hl  
2b82 23					inc hl 
2b83					; skip len 
2b83 23					inc hl 
2b84			 
2b84			;	if DEBUG_FORTH_WORDS 
2b84			;		DMARK "LSc" 
2b84			;		CALLMONITOR 
2b84			;	endif 
2b84 cd 7d 12				call strcmp 
2b87 c2 6e 2b				jp nz, .fldouscanm 
2b8a			; 
2b8a			; 
2b8a			;; while we have words to look for 
2b8a			; 
2b8a			;.fdouscan:	ld a, (hl)      
2b8a			;	if DEBUG_FORTH_WORDS 
2b8a			;		DMARK "LSs" 
2b8a			;		CALLMONITOR 
2b8a			;	endif 
2b8a			;		cp WORD_SYS_END 
2b8a			;		jp z, .fudone 
2b8a			;		cp WORD_SYS_UWORD 
2b8a			;		jp nz, .fnuword 
2b8a			; 
2b8a			;	if DEBUG_FORTH_WORDS 
2b8a			;		DMARK "FGu" 
2b8a			;		CALLMONITOR 
2b8a			;	endif 
2b8a			; 
2b8a			;		; found a uword but is it the one we want... 
2b8a			; 
2b8a			; 
2b8a			;	        pop de   ; get back the dsp name 
2b8a			;		push de 
2b8a			; 
2b8a			;		push hl  ; to save the ptr 
2b8a			; 
2b8a			;		; skip opcode 
2b8a			;		inc hl  
2b8a			;		; skip next ptr 
2b8a			;		inc hl  
2b8a			;		inc hl 
2b8a			;		; skip len 
2b8a			;		inc hl 
2b8a			; 
2b8a			;	if DEBUG_FORTH_WORDS 
2b8a			;		DMARK "FGc" 
2b8a			;		CALLMONITOR 
2b8a			;	endif 
2b8a			;		call strcmp 
2b8a			;		jp nz, .fnuword 
2b8a			 
2b8a			 
2b8a e1			pop hl 
2b8b			 
2b8b				 
2b8b				if DEBUG_FORTH_WORDS 
2b8b					DMARK "FGm" 
2b8b f5				push af  
2b8c 3a a0 2b			ld a, (.dmark)  
2b8f 32 6b ee			ld (debug_mark),a  
2b92 3a a1 2b			ld a, (.dmark+1)  
2b95 32 6c ee			ld (debug_mark+1),a  
2b98 3a a2 2b			ld a, (.dmark+2)  
2b9b 32 6d ee			ld (debug_mark+2),a  
2b9e 18 03			jr .pastdmark  
2ba0 ..			.dmark: db "FGm"  
2ba3 f1			.pastdmark: pop af  
2ba4			endm  
# End of macro DMARK
2ba4					CALLMONITOR 
2ba4 cd 6f ee			call debug_vector  
2ba7				endm  
# End of macro CALLMONITOR
2ba7				endif 
2ba7			 
2ba7			 
2ba7			 
2ba7					; we have a uword so push its name to the stack 
2ba7			 
2ba7			;	   	push hl  ; save so we can move to next dict block 
2ba7			;pop hl 
2ba7			 
2ba7					; update opcode to deleted 
2ba7 3e 03				ld a, WORD_SYS_DELETED 
2ba9 77					ld (hl), a 
2baa			 
2baa 23					inc hl  
2bab					; skip next ptr 
2bab 23					inc hl  
2bac 23					inc hl 
2bad					; skip len 
2bad 23					inc hl 
2bae			 
2bae					; TODO change parser to skip deleted words but for now mark it out 
2bae 3e 5f				ld a, "_" 
2bb0 77					ld  (hl),a 
2bb1			 
2bb1			;		jr .fudone 
2bb1			; 
2bb1			;.fnuword:	pop hl 
2bb1			;		call forth_tok_next 
2bb1			;		jp .fdouscan  
2bb1			 
2bb1			.flunotfound:		  
2bb1			 
2bb1			 
2bb1					 
2bb1					FORTH_DSP_POP 
2bb1 cd 05 1f			call macro_forth_dsp_pop 
2bb4				endm 
# End of macro FORTH_DSP_POP
2bb4			;		ld hl, .luno 
2bb4			;.fudone:		 pop hl 
2bb4					NEXTW 
2bb4 c3 03 20			jp macro_next 
2bb7				endm 
# End of macro NEXTW
2bb7			.NOP: 
2bb7				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2bb7 61				db WORD_SYS_CORE+77             
2bb8 de 2b			dw .COMO            
2bba 04				db 3 + 1 
2bbb .. 00			db "NOP",0              
2bbf				endm 
# End of macro CWHEAD
2bbf			; | NOP (  --  ) Do nothing | DONE 
2bbf					if DEBUG_FORTH_WORDS_KEY 
2bbf						DMARK "NOP" 
2bbf f5				push af  
2bc0 3a d4 2b			ld a, (.dmark)  
2bc3 32 6b ee			ld (debug_mark),a  
2bc6 3a d5 2b			ld a, (.dmark+1)  
2bc9 32 6c ee			ld (debug_mark+1),a  
2bcc 3a d6 2b			ld a, (.dmark+2)  
2bcf 32 6d ee			ld (debug_mark+2),a  
2bd2 18 03			jr .pastdmark  
2bd4 ..			.dmark: db "NOP"  
2bd7 f1			.pastdmark: pop af  
2bd8			endm  
# End of macro DMARK
2bd8						CALLMONITOR 
2bd8 cd 6f ee			call debug_vector  
2bdb				endm  
# End of macro CALLMONITOR
2bdb					endif 
2bdb				       NEXTW 
2bdb c3 03 20			jp macro_next 
2bde				endm 
# End of macro NEXTW
2bde			.COMO: 
2bde				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2bde 6e				db WORD_SYS_CORE+90             
2bdf 30 2c			dw .COMC            
2be1 02				db 1 + 1 
2be2 .. 00			db "(",0              
2be4				endm 
# End of macro CWHEAD
2be4			; | ( ( -- )  Start of comment | DONE 
2be4			 
2be4			 
2be4 2a c2 e5				ld hl, ( os_tok_ptr) 
2be7 11 2b 2c			ld de, .closepar 
2bea					 
2bea					if DEBUG_FORTH_WORDS 
2bea						DMARK ").." 
2bea f5				push af  
2beb 3a ff 2b			ld a, (.dmark)  
2bee 32 6b ee			ld (debug_mark),a  
2bf1 3a 00 2c			ld a, (.dmark+1)  
2bf4 32 6c ee			ld (debug_mark+1),a  
2bf7 3a 01 2c			ld a, (.dmark+2)  
2bfa 32 6d ee			ld (debug_mark+2),a  
2bfd 18 03			jr .pastdmark  
2bff ..			.dmark: db ").."  
2c02 f1			.pastdmark: pop af  
2c03			endm  
# End of macro DMARK
2c03						CALLMONITOR 
2c03 cd 6f ee			call debug_vector  
2c06				endm  
# End of macro CALLMONITOR
2c06					endif 
2c06 cd 1e 21			call findnexttok  
2c09			 
2c09					if DEBUG_FORTH_WORDS 
2c09						DMARK "IF5" 
2c09 f5				push af  
2c0a 3a 1e 2c			ld a, (.dmark)  
2c0d 32 6b ee			ld (debug_mark),a  
2c10 3a 1f 2c			ld a, (.dmark+1)  
2c13 32 6c ee			ld (debug_mark+1),a  
2c16 3a 20 2c			ld a, (.dmark+2)  
2c19 32 6d ee			ld (debug_mark+2),a  
2c1c 18 03			jr .pastdmark  
2c1e ..			.dmark: db "IF5"  
2c21 f1			.pastdmark: pop af  
2c22			endm  
# End of macro DMARK
2c22						CALLMONITOR 
2c22 cd 6f ee			call debug_vector  
2c25				endm  
# End of macro CALLMONITOR
2c25					endif 
2c25				; replace below with ) exec using tok_ptr 
2c25 22 c2 e5			ld (os_tok_ptr), hl 
2c28 c3 94 20			jp exec1 
2c2b			 
2c2b .. 00			.closepar:   db ")",0 
2c2d			 
2c2d				       NEXTW 
2c2d c3 03 20			jp macro_next 
2c30				endm 
# End of macro NEXTW
2c30			.COMC: 
2c30				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c30 6f				db WORD_SYS_CORE+91             
2c31 39 2c			dw .SCRATCH            
2c33 02				db 1 + 1 
2c34 .. 00			db ")",0              
2c36				endm 
# End of macro CWHEAD
2c36			; | ) ( -- )  End of comment |  DONE  
2c36				       NEXTW 
2c36 c3 03 20			jp macro_next 
2c39				endm 
# End of macro NEXTW
2c39			 
2c39			.SCRATCH: 
2c39				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c39 6f				db WORD_SYS_CORE+91             
2c3a 74 2c			dw .INC            
2c3c 08				db 7 + 1 
2c3d .. 00			db "SCRATCH",0              
2c45				endm 
# End of macro CWHEAD
2c45			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c45			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c45			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c45			; | |  
2c45			; | | e.g.    : score $00 scratch ; 
2c45			; | |  
2c45			; | | $00 score ! 
2c45			; | | $01 score +! 
2c45			; | |  
2c45			; | | e.g.   : varword $0a scratch ;  
2c45			; | | 
2c45			; | | $8000 varword ! 
2c45					if DEBUG_FORTH_WORDS_KEY 
2c45						DMARK "SCR" 
2c45 f5				push af  
2c46 3a 5a 2c			ld a, (.dmark)  
2c49 32 6b ee			ld (debug_mark),a  
2c4c 3a 5b 2c			ld a, (.dmark+1)  
2c4f 32 6c ee			ld (debug_mark+1),a  
2c52 3a 5c 2c			ld a, (.dmark+2)  
2c55 32 6d ee			ld (debug_mark+2),a  
2c58 18 03			jr .pastdmark  
2c5a ..			.dmark: db "SCR"  
2c5d f1			.pastdmark: pop af  
2c5e			endm  
# End of macro DMARK
2c5e						CALLMONITOR 
2c5e cd 6f ee			call debug_vector  
2c61				endm  
# End of macro CALLMONITOR
2c61					endif 
2c61			 
2c61					FORTH_DSP_VALUEHL 
2c61 cd 4d 1e			call macro_dsp_valuehl 
2c64				endm 
# End of macro FORTH_DSP_VALUEHL
2c64				 
2c64					FORTH_DSP_POP 
2c64 cd 05 1f			call macro_forth_dsp_pop 
2c67				endm 
# End of macro FORTH_DSP_POP
2c67			 
2c67 7d					ld a, l 
2c68 21 e6 e7				ld hl, os_var_array 
2c6b cd e7 0d				call addatohl 
2c6e			 
2c6e cd 56 1c				call forth_push_numhl 
2c71			 
2c71				       NEXTW 
2c71 c3 03 20			jp macro_next 
2c74				endm 
# End of macro NEXTW
2c74			 
2c74			.INC: 
2c74				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2c74 6f				db WORD_SYS_CORE+91             
2c75 c8 2c			dw .DEC            
2c77 03				db 2 + 1 
2c78 .. 00			db "+!",0              
2c7b				endm 
# End of macro CWHEAD
2c7b			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2c7b					if DEBUG_FORTH_WORDS_KEY 
2c7b						DMARK "+s_" 
2c7b f5				push af  
2c7c 3a 90 2c			ld a, (.dmark)  
2c7f 32 6b ee			ld (debug_mark),a  
2c82 3a 91 2c			ld a, (.dmark+1)  
2c85 32 6c ee			ld (debug_mark+1),a  
2c88 3a 92 2c			ld a, (.dmark+2)  
2c8b 32 6d ee			ld (debug_mark+2),a  
2c8e 18 03			jr .pastdmark  
2c90 ..			.dmark: db "+s_"  
2c93 f1			.pastdmark: pop af  
2c94			endm  
# End of macro DMARK
2c94						CALLMONITOR 
2c94 cd 6f ee			call debug_vector  
2c97				endm  
# End of macro CALLMONITOR
2c97					endif 
2c97			 
2c97					FORTH_DSP_VALUEHL 
2c97 cd 4d 1e			call macro_dsp_valuehl 
2c9a				endm 
# End of macro FORTH_DSP_VALUEHL
2c9a			 
2c9a e5					push hl   ; save address 
2c9b			 
2c9b					FORTH_DSP_POP 
2c9b cd 05 1f			call macro_forth_dsp_pop 
2c9e				endm 
# End of macro FORTH_DSP_POP
2c9e			 
2c9e					FORTH_DSP_VALUEHL 
2c9e cd 4d 1e			call macro_dsp_valuehl 
2ca1				endm 
# End of macro FORTH_DSP_VALUEHL
2ca1			 
2ca1					FORTH_DSP_POP 
2ca1 cd 05 1f			call macro_forth_dsp_pop 
2ca4				endm 
# End of macro FORTH_DSP_POP
2ca4			 
2ca4					; hl contains value to add to byte at a 
2ca4				 
2ca4 eb					ex de, hl 
2ca5			 
2ca5 e1					pop hl 
2ca6			 
2ca6					if DEBUG_FORTH_WORDS 
2ca6						DMARK "INC" 
2ca6 f5				push af  
2ca7 3a bb 2c			ld a, (.dmark)  
2caa 32 6b ee			ld (debug_mark),a  
2cad 3a bc 2c			ld a, (.dmark+1)  
2cb0 32 6c ee			ld (debug_mark+1),a  
2cb3 3a bd 2c			ld a, (.dmark+2)  
2cb6 32 6d ee			ld (debug_mark+2),a  
2cb9 18 03			jr .pastdmark  
2cbb ..			.dmark: db "INC"  
2cbe f1			.pastdmark: pop af  
2cbf			endm  
# End of macro DMARK
2cbf						CALLMONITOR 
2cbf cd 6f ee			call debug_vector  
2cc2				endm  
# End of macro CALLMONITOR
2cc2					endif 
2cc2			 
2cc2 7e					ld a,(hl) 
2cc3 83					add e 
2cc4 77					ld (hl),a 
2cc5			 
2cc5			 
2cc5			 
2cc5				       NEXTW 
2cc5 c3 03 20			jp macro_next 
2cc8				endm 
# End of macro NEXTW
2cc8			 
2cc8			.DEC: 
2cc8				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2cc8 6f				db WORD_SYS_CORE+91             
2cc9 19 2d			dw .INC2            
2ccb 03				db 2 + 1 
2ccc .. 00			db "-!",0              
2ccf				endm 
# End of macro CWHEAD
2ccf			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2ccf					if DEBUG_FORTH_WORDS_KEY 
2ccf						DMARK "-s_" 
2ccf f5				push af  
2cd0 3a e4 2c			ld a, (.dmark)  
2cd3 32 6b ee			ld (debug_mark),a  
2cd6 3a e5 2c			ld a, (.dmark+1)  
2cd9 32 6c ee			ld (debug_mark+1),a  
2cdc 3a e6 2c			ld a, (.dmark+2)  
2cdf 32 6d ee			ld (debug_mark+2),a  
2ce2 18 03			jr .pastdmark  
2ce4 ..			.dmark: db "-s_"  
2ce7 f1			.pastdmark: pop af  
2ce8			endm  
# End of macro DMARK
2ce8						CALLMONITOR 
2ce8 cd 6f ee			call debug_vector  
2ceb				endm  
# End of macro CALLMONITOR
2ceb					endif 
2ceb			 
2ceb					FORTH_DSP_VALUEHL 
2ceb cd 4d 1e			call macro_dsp_valuehl 
2cee				endm 
# End of macro FORTH_DSP_VALUEHL
2cee			 
2cee e5					push hl   ; save address 
2cef			 
2cef					FORTH_DSP_POP 
2cef cd 05 1f			call macro_forth_dsp_pop 
2cf2				endm 
# End of macro FORTH_DSP_POP
2cf2			 
2cf2					FORTH_DSP_VALUEHL 
2cf2 cd 4d 1e			call macro_dsp_valuehl 
2cf5				endm 
# End of macro FORTH_DSP_VALUEHL
2cf5			 
2cf5					; hl contains value to add to byte at a 
2cf5				 
2cf5 eb					ex de, hl 
2cf6			 
2cf6 e1					pop hl 
2cf7			 
2cf7					if DEBUG_FORTH_WORDS 
2cf7						DMARK "DEC" 
2cf7 f5				push af  
2cf8 3a 0c 2d			ld a, (.dmark)  
2cfb 32 6b ee			ld (debug_mark),a  
2cfe 3a 0d 2d			ld a, (.dmark+1)  
2d01 32 6c ee			ld (debug_mark+1),a  
2d04 3a 0e 2d			ld a, (.dmark+2)  
2d07 32 6d ee			ld (debug_mark+2),a  
2d0a 18 03			jr .pastdmark  
2d0c ..			.dmark: db "DEC"  
2d0f f1			.pastdmark: pop af  
2d10			endm  
# End of macro DMARK
2d10						CALLMONITOR 
2d10 cd 6f ee			call debug_vector  
2d13				endm  
# End of macro CALLMONITOR
2d13					endif 
2d13			 
2d13 7e					ld a,(hl) 
2d14 93					sub e 
2d15 77					ld (hl),a 
2d16			 
2d16			 
2d16			 
2d16				       NEXTW 
2d16 c3 03 20			jp macro_next 
2d19				endm 
# End of macro NEXTW
2d19			 
2d19			.INC2: 
2d19				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d19 6f				db WORD_SYS_CORE+91             
2d1a c3 2d			dw .DEC2            
2d1c 04				db 3 + 1 
2d1d .. 00			db "+2!",0              
2d21				endm 
# End of macro CWHEAD
2d21			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d21			 
2d21					if DEBUG_FORTH_WORDS_KEY 
2d21						DMARK "+2s" 
2d21 f5				push af  
2d22 3a 36 2d			ld a, (.dmark)  
2d25 32 6b ee			ld (debug_mark),a  
2d28 3a 37 2d			ld a, (.dmark+1)  
2d2b 32 6c ee			ld (debug_mark+1),a  
2d2e 3a 38 2d			ld a, (.dmark+2)  
2d31 32 6d ee			ld (debug_mark+2),a  
2d34 18 03			jr .pastdmark  
2d36 ..			.dmark: db "+2s"  
2d39 f1			.pastdmark: pop af  
2d3a			endm  
# End of macro DMARK
2d3a						CALLMONITOR 
2d3a cd 6f ee			call debug_vector  
2d3d				endm  
# End of macro CALLMONITOR
2d3d					endif 
2d3d			 
2d3d					; Address 
2d3d			 
2d3d					FORTH_DSP_VALUEHL 
2d3d cd 4d 1e			call macro_dsp_valuehl 
2d40				endm 
# End of macro FORTH_DSP_VALUEHL
2d40			 
2d40 e5					push hl    ; save address 
2d41			 
2d41					; load content into de 
2d41			 
2d41 5e					ld e,(hl) 
2d42 23					inc hl 
2d43 56					ld d, (hl) 
2d44			 
2d44					if DEBUG_FORTH_WORDS 
2d44						DMARK "+2a" 
2d44 f5				push af  
2d45 3a 59 2d			ld a, (.dmark)  
2d48 32 6b ee			ld (debug_mark),a  
2d4b 3a 5a 2d			ld a, (.dmark+1)  
2d4e 32 6c ee			ld (debug_mark+1),a  
2d51 3a 5b 2d			ld a, (.dmark+2)  
2d54 32 6d ee			ld (debug_mark+2),a  
2d57 18 03			jr .pastdmark  
2d59 ..			.dmark: db "+2a"  
2d5c f1			.pastdmark: pop af  
2d5d			endm  
# End of macro DMARK
2d5d						CALLMONITOR 
2d5d cd 6f ee			call debug_vector  
2d60				endm  
# End of macro CALLMONITOR
2d60					endif 
2d60			 
2d60					FORTH_DSP_POP 
2d60 cd 05 1f			call macro_forth_dsp_pop 
2d63				endm 
# End of macro FORTH_DSP_POP
2d63			 
2d63					; Get value to add 
2d63			 
2d63					FORTH_DSP_VALUE 
2d63 cd 36 1e			call macro_forth_dsp_value 
2d66				endm 
# End of macro FORTH_DSP_VALUE
2d66			 
2d66					if DEBUG_FORTH_WORDS 
2d66						DMARK "+2v" 
2d66 f5				push af  
2d67 3a 7b 2d			ld a, (.dmark)  
2d6a 32 6b ee			ld (debug_mark),a  
2d6d 3a 7c 2d			ld a, (.dmark+1)  
2d70 32 6c ee			ld (debug_mark+1),a  
2d73 3a 7d 2d			ld a, (.dmark+2)  
2d76 32 6d ee			ld (debug_mark+2),a  
2d79 18 03			jr .pastdmark  
2d7b ..			.dmark: db "+2v"  
2d7e f1			.pastdmark: pop af  
2d7f			endm  
# End of macro DMARK
2d7f						CALLMONITOR 
2d7f cd 6f ee			call debug_vector  
2d82				endm  
# End of macro CALLMONITOR
2d82					endif 
2d82			 
2d82 19					add hl, de 
2d83			 
2d83					if DEBUG_FORTH_WORDS 
2d83						DMARK "+2+" 
2d83 f5				push af  
2d84 3a 98 2d			ld a, (.dmark)  
2d87 32 6b ee			ld (debug_mark),a  
2d8a 3a 99 2d			ld a, (.dmark+1)  
2d8d 32 6c ee			ld (debug_mark+1),a  
2d90 3a 9a 2d			ld a, (.dmark+2)  
2d93 32 6d ee			ld (debug_mark+2),a  
2d96 18 03			jr .pastdmark  
2d98 ..			.dmark: db "+2+"  
2d9b f1			.pastdmark: pop af  
2d9c			endm  
# End of macro DMARK
2d9c						CALLMONITOR 
2d9c cd 6f ee			call debug_vector  
2d9f				endm  
# End of macro CALLMONITOR
2d9f					endif 
2d9f			 
2d9f					; move result to de 
2d9f			 
2d9f eb					ex de, hl 
2da0			 
2da0					; Address 
2da0			 
2da0 e1					pop hl 
2da1			 
2da1					; save it back 
2da1			 
2da1 73					ld (hl), e 
2da2 23					inc hl 
2da3 72					ld (hl), d 
2da4			 
2da4					if DEBUG_FORTH_WORDS 
2da4						DMARK "+2e" 
2da4 f5				push af  
2da5 3a b9 2d			ld a, (.dmark)  
2da8 32 6b ee			ld (debug_mark),a  
2dab 3a ba 2d			ld a, (.dmark+1)  
2dae 32 6c ee			ld (debug_mark+1),a  
2db1 3a bb 2d			ld a, (.dmark+2)  
2db4 32 6d ee			ld (debug_mark+2),a  
2db7 18 03			jr .pastdmark  
2db9 ..			.dmark: db "+2e"  
2dbc f1			.pastdmark: pop af  
2dbd			endm  
# End of macro DMARK
2dbd						CALLMONITOR 
2dbd cd 6f ee			call debug_vector  
2dc0				endm  
# End of macro CALLMONITOR
2dc0					endif 
2dc0			 
2dc0			 
2dc0			 
2dc0			 
2dc0			 
2dc0				       NEXTW 
2dc0 c3 03 20			jp macro_next 
2dc3				endm 
# End of macro NEXTW
2dc3			 
2dc3			.DEC2: 
2dc3				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2dc3 6f				db WORD_SYS_CORE+91             
2dc4 6f 2e			dw .GET2            
2dc6 04				db 3 + 1 
2dc7 .. 00			db "-2!",0              
2dcb				endm 
# End of macro CWHEAD
2dcb			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2dcb			 
2dcb			 
2dcb					if DEBUG_FORTH_WORDS_KEY 
2dcb						DMARK "-2s" 
2dcb f5				push af  
2dcc 3a e0 2d			ld a, (.dmark)  
2dcf 32 6b ee			ld (debug_mark),a  
2dd2 3a e1 2d			ld a, (.dmark+1)  
2dd5 32 6c ee			ld (debug_mark+1),a  
2dd8 3a e2 2d			ld a, (.dmark+2)  
2ddb 32 6d ee			ld (debug_mark+2),a  
2dde 18 03			jr .pastdmark  
2de0 ..			.dmark: db "-2s"  
2de3 f1			.pastdmark: pop af  
2de4			endm  
# End of macro DMARK
2de4						CALLMONITOR 
2de4 cd 6f ee			call debug_vector  
2de7				endm  
# End of macro CALLMONITOR
2de7					endif 
2de7			 
2de7					; Address 
2de7			 
2de7					FORTH_DSP_VALUEHL 
2de7 cd 4d 1e			call macro_dsp_valuehl 
2dea				endm 
# End of macro FORTH_DSP_VALUEHL
2dea			 
2dea e5					push hl    ; save address 
2deb			 
2deb					; load content into de 
2deb			 
2deb 5e					ld e,(hl) 
2dec 23					inc hl 
2ded 56					ld d, (hl) 
2dee			 
2dee					if DEBUG_FORTH_WORDS 
2dee						DMARK "-2a" 
2dee f5				push af  
2def 3a 03 2e			ld a, (.dmark)  
2df2 32 6b ee			ld (debug_mark),a  
2df5 3a 04 2e			ld a, (.dmark+1)  
2df8 32 6c ee			ld (debug_mark+1),a  
2dfb 3a 05 2e			ld a, (.dmark+2)  
2dfe 32 6d ee			ld (debug_mark+2),a  
2e01 18 03			jr .pastdmark  
2e03 ..			.dmark: db "-2a"  
2e06 f1			.pastdmark: pop af  
2e07			endm  
# End of macro DMARK
2e07						CALLMONITOR 
2e07 cd 6f ee			call debug_vector  
2e0a				endm  
# End of macro CALLMONITOR
2e0a					endif 
2e0a			 
2e0a					FORTH_DSP_POP 
2e0a cd 05 1f			call macro_forth_dsp_pop 
2e0d				endm 
# End of macro FORTH_DSP_POP
2e0d			 
2e0d					; Get value to remove 
2e0d			 
2e0d					FORTH_DSP_VALUE 
2e0d cd 36 1e			call macro_forth_dsp_value 
2e10				endm 
# End of macro FORTH_DSP_VALUE
2e10			 
2e10					if DEBUG_FORTH_WORDS 
2e10						DMARK "-2v" 
2e10 f5				push af  
2e11 3a 25 2e			ld a, (.dmark)  
2e14 32 6b ee			ld (debug_mark),a  
2e17 3a 26 2e			ld a, (.dmark+1)  
2e1a 32 6c ee			ld (debug_mark+1),a  
2e1d 3a 27 2e			ld a, (.dmark+2)  
2e20 32 6d ee			ld (debug_mark+2),a  
2e23 18 03			jr .pastdmark  
2e25 ..			.dmark: db "-2v"  
2e28 f1			.pastdmark: pop af  
2e29			endm  
# End of macro DMARK
2e29						CALLMONITOR 
2e29 cd 6f ee			call debug_vector  
2e2c				endm  
# End of macro CALLMONITOR
2e2c					endif 
2e2c			 
2e2c eb					ex de, hl 
2e2d ed 52				sbc hl, de 
2e2f			 
2e2f					if DEBUG_FORTH_WORDS 
2e2f						DMARK "-2d" 
2e2f f5				push af  
2e30 3a 44 2e			ld a, (.dmark)  
2e33 32 6b ee			ld (debug_mark),a  
2e36 3a 45 2e			ld a, (.dmark+1)  
2e39 32 6c ee			ld (debug_mark+1),a  
2e3c 3a 46 2e			ld a, (.dmark+2)  
2e3f 32 6d ee			ld (debug_mark+2),a  
2e42 18 03			jr .pastdmark  
2e44 ..			.dmark: db "-2d"  
2e47 f1			.pastdmark: pop af  
2e48			endm  
# End of macro DMARK
2e48						CALLMONITOR 
2e48 cd 6f ee			call debug_vector  
2e4b				endm  
# End of macro CALLMONITOR
2e4b					endif 
2e4b			 
2e4b					; move result to de 
2e4b			 
2e4b eb					ex de, hl 
2e4c			 
2e4c					; Address 
2e4c			 
2e4c e1					pop hl 
2e4d			 
2e4d					; save it back 
2e4d			 
2e4d 73					ld (hl), e 
2e4e 23					inc hl 
2e4f 72					ld (hl), d 
2e50			 
2e50					if DEBUG_FORTH_WORDS 
2e50						DMARK "-2e" 
2e50 f5				push af  
2e51 3a 65 2e			ld a, (.dmark)  
2e54 32 6b ee			ld (debug_mark),a  
2e57 3a 66 2e			ld a, (.dmark+1)  
2e5a 32 6c ee			ld (debug_mark+1),a  
2e5d 3a 67 2e			ld a, (.dmark+2)  
2e60 32 6d ee			ld (debug_mark+2),a  
2e63 18 03			jr .pastdmark  
2e65 ..			.dmark: db "-2e"  
2e68 f1			.pastdmark: pop af  
2e69			endm  
# End of macro DMARK
2e69						CALLMONITOR 
2e69 cd 6f ee			call debug_vector  
2e6c				endm  
# End of macro CALLMONITOR
2e6c					endif 
2e6c			 
2e6c			 
2e6c			 
2e6c			 
2e6c			 
2e6c				       NEXTW 
2e6c c3 03 20			jp macro_next 
2e6f				endm 
# End of macro NEXTW
2e6f			.GET2: 
2e6f				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2e6f 6f				db WORD_SYS_CORE+91             
2e70 9f 2e			dw .BANG2            
2e72 03				db 2 + 1 
2e73 .. 00			db "2@",0              
2e76				endm 
# End of macro CWHEAD
2e76			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2e76					if DEBUG_FORTH_WORDS_KEY 
2e76						DMARK "2A_" 
2e76 f5				push af  
2e77 3a 8b 2e			ld a, (.dmark)  
2e7a 32 6b ee			ld (debug_mark),a  
2e7d 3a 8c 2e			ld a, (.dmark+1)  
2e80 32 6c ee			ld (debug_mark+1),a  
2e83 3a 8d 2e			ld a, (.dmark+2)  
2e86 32 6d ee			ld (debug_mark+2),a  
2e89 18 03			jr .pastdmark  
2e8b ..			.dmark: db "2A_"  
2e8e f1			.pastdmark: pop af  
2e8f			endm  
# End of macro DMARK
2e8f						CALLMONITOR 
2e8f cd 6f ee			call debug_vector  
2e92				endm  
# End of macro CALLMONITOR
2e92					endif 
2e92			 
2e92					FORTH_DSP_VALUEHL 
2e92 cd 4d 1e			call macro_dsp_valuehl 
2e95				endm 
# End of macro FORTH_DSP_VALUEHL
2e95			 
2e95 5e					ld e, (hl) 
2e96 23					inc hl 
2e97 56					ld d, (hl) 
2e98			 
2e98 eb					ex de, hl 
2e99			 
2e99 cd 56 1c				call forth_push_numhl 
2e9c			 
2e9c				       NEXTW 
2e9c c3 03 20			jp macro_next 
2e9f				endm 
# End of macro NEXTW
2e9f			.BANG2: 
2e9f				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2e9f 6f				db WORD_SYS_CORE+91             
2ea0 d7 2e			dw .CONFIG            
2ea2 03				db 2 + 1 
2ea3 .. 00			db "2!",0              
2ea6				endm 
# End of macro CWHEAD
2ea6			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2ea6					if DEBUG_FORTH_WORDS_KEY 
2ea6						DMARK "2S_" 
2ea6 f5				push af  
2ea7 3a bb 2e			ld a, (.dmark)  
2eaa 32 6b ee			ld (debug_mark),a  
2ead 3a bc 2e			ld a, (.dmark+1)  
2eb0 32 6c ee			ld (debug_mark+1),a  
2eb3 3a bd 2e			ld a, (.dmark+2)  
2eb6 32 6d ee			ld (debug_mark+2),a  
2eb9 18 03			jr .pastdmark  
2ebb ..			.dmark: db "2S_"  
2ebe f1			.pastdmark: pop af  
2ebf			endm  
# End of macro DMARK
2ebf						CALLMONITOR 
2ebf cd 6f ee			call debug_vector  
2ec2				endm  
# End of macro CALLMONITOR
2ec2					endif 
2ec2			 
2ec2					FORTH_DSP_VALUEHL 
2ec2 cd 4d 1e			call macro_dsp_valuehl 
2ec5				endm 
# End of macro FORTH_DSP_VALUEHL
2ec5			 
2ec5 e5					push hl   ; save address 
2ec6			 
2ec6			 
2ec6					FORTH_DSP_POP 
2ec6 cd 05 1f			call macro_forth_dsp_pop 
2ec9				endm 
# End of macro FORTH_DSP_POP
2ec9			 
2ec9					 
2ec9					FORTH_DSP_VALUEHL 
2ec9 cd 4d 1e			call macro_dsp_valuehl 
2ecc				endm 
# End of macro FORTH_DSP_VALUEHL
2ecc			 
2ecc					FORTH_DSP_POP 
2ecc cd 05 1f			call macro_forth_dsp_pop 
2ecf				endm 
# End of macro FORTH_DSP_POP
2ecf			 
2ecf eb					ex de, hl    ; value now in de 
2ed0			 
2ed0 e1					pop hl 
2ed1			 
2ed1 73					ld (hl), e 
2ed2			 
2ed2 23					inc hl 
2ed3			 
2ed3 72					ld (hl), d 
2ed4			 
2ed4			 
2ed4				       NEXTW 
2ed4 c3 03 20			jp macro_next 
2ed7				endm 
# End of macro NEXTW
2ed7			.CONFIG: 
2ed7				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
2ed7 6f				db WORD_SYS_CORE+91             
2ed8 e8 2e			dw .ADTOS            
2eda 07				db 6 + 1 
2edb .. 00			db "CONFIG",0              
2ee2				endm 
# End of macro CWHEAD
2ee2			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2ee2			 
2ee2 cd 47 14				call config 
2ee5					NEXTW 
2ee5 c3 03 20			jp macro_next 
2ee8				endm 
# End of macro NEXTW
2ee8			 
2ee8			.ADTOS: 
2ee8				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
2ee8 6f				db WORD_SYS_CORE+91             
2ee9 fe 2e			dw .SBTOS            
2eeb 03				db 2 + 1 
2eec .. 00			db "1+",0              
2eef				endm 
# End of macro CWHEAD
2eef			; | 1+ ( u -- u )  Increment value on TOS | DONE 
2eef			 
2eef					FORTH_DSP_VALUEHL 
2eef cd 4d 1e			call macro_dsp_valuehl 
2ef2				endm 
# End of macro FORTH_DSP_VALUEHL
2ef2 e5					push hl 
2ef3			 
2ef3					FORTH_DSP_POP 
2ef3 cd 05 1f			call macro_forth_dsp_pop 
2ef6				endm 
# End of macro FORTH_DSP_POP
2ef6 e1					pop hl 
2ef7			 
2ef7 23					inc hl 
2ef8 cd 56 1c				call forth_push_numhl 
2efb					 
2efb					NEXTW 
2efb c3 03 20			jp macro_next 
2efe				endm 
# End of macro NEXTW
2efe			.SBTOS: 
2efe				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
2efe 6f				db WORD_SYS_CORE+91             
2eff 14 2f			dw .ADSTORE            
2f01 03				db 2 + 1 
2f02 .. 00			db "1-",0              
2f05				endm 
# End of macro CWHEAD
2f05			; | 1- ( u -- u )  Decrement value on TOS | DONE 
2f05			 
2f05					FORTH_DSP_VALUEHL 
2f05 cd 4d 1e			call macro_dsp_valuehl 
2f08				endm 
# End of macro FORTH_DSP_VALUEHL
2f08 e5					push hl 
2f09			 
2f09					FORTH_DSP_POP 
2f09 cd 05 1f			call macro_forth_dsp_pop 
2f0c				endm 
# End of macro FORTH_DSP_POP
2f0c e1					pop hl 
2f0d			 
2f0d 2b					dec hl 
2f0e cd 56 1c				call forth_push_numhl 
2f11					 
2f11					NEXTW 
2f11 c3 03 20			jp macro_next 
2f14				endm 
# End of macro NEXTW
2f14			.ADSTORE: 
2f14				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
2f14 6f				db WORD_SYS_CORE+91             
2f15 2a 2f			dw .ADWSTORE            
2f17 04				db 3 + 1 
2f18 .. 00			db "1+!",0              
2f1c				endm 
# End of macro CWHEAD
2f1c			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
2f1c			 
2f1c					FORTH_DSP_VALUEHL 
2f1c cd 4d 1e			call macro_dsp_valuehl 
2f1f				endm 
# End of macro FORTH_DSP_VALUEHL
2f1f e5					push hl 
2f20			 
2f20					FORTH_DSP_POP 
2f20 cd 05 1f			call macro_forth_dsp_pop 
2f23				endm 
# End of macro FORTH_DSP_POP
2f23 e1					pop hl 
2f24			 
2f24 7e					ld a, (hl) 
2f25 3c					inc a 
2f26 77					ld (hl), a 
2f27					 
2f27					NEXTW 
2f27 c3 03 20			jp macro_next 
2f2a				endm 
# End of macro NEXTW
2f2a			.ADWSTORE: 
2f2a				CWHEAD .ENDCORE 91 "1+2!" 4 WORD_FLAG_CODE 
2f2a 6f				db WORD_SYS_CORE+91             
2f2b 48 2f			dw .ENDCORE            
2f2d 05				db 4 + 1 
2f2e .. 00			db "1+2!",0              
2f33				endm 
# End of macro CWHEAD
2f33			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
2f33			 
2f33					FORTH_DSP_VALUEHL 
2f33 cd 4d 1e			call macro_dsp_valuehl 
2f36				endm 
# End of macro FORTH_DSP_VALUEHL
2f36 e5					push hl 
2f37			 
2f37					FORTH_DSP_POP 
2f37 cd 05 1f			call macro_forth_dsp_pop 
2f3a				endm 
# End of macro FORTH_DSP_POP
2f3a e1					pop hl 
2f3b			 
2f3b e5					push hl 
2f3c			 
2f3c cd 85 1f				call loadwordinhl 
2f3f 23					inc hl 
2f40			 
2f40 d1					pop de 
2f41 eb					ex de, hl 
2f42 73					ld (hl), e 
2f43 23					inc hl 
2f44 72					ld (hl), d 
2f45					 
2f45					NEXTW 
2f45 c3 03 20			jp macro_next 
2f48				endm 
# End of macro NEXTW
2f48			.ENDCORE: 
2f48			 
2f48			; eof 
2f48			 
2f48			 
# End of file forth_words_core.asm
2f48			include "forth_words_flow.asm" 
2f48			 
2f48			; | ## Program Flow Words 
2f48			 
2f48			.IF: 
2f48				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f48 1e				db WORD_SYS_CORE+10             
2f49 3d 30			dw .THEN            
2f4b 03				db 2 + 1 
2f4c .. 00			db "IF",0              
2f4f				endm 
# End of macro CWHEAD
2f4f			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f4f			; 
2f4f					if DEBUG_FORTH_WORDS_KEY 
2f4f						DMARK "IF." 
2f4f f5				push af  
2f50 3a 64 2f			ld a, (.dmark)  
2f53 32 6b ee			ld (debug_mark),a  
2f56 3a 65 2f			ld a, (.dmark+1)  
2f59 32 6c ee			ld (debug_mark+1),a  
2f5c 3a 66 2f			ld a, (.dmark+2)  
2f5f 32 6d ee			ld (debug_mark+2),a  
2f62 18 03			jr .pastdmark  
2f64 ..			.dmark: db "IF."  
2f67 f1			.pastdmark: pop af  
2f68			endm  
# End of macro DMARK
2f68						CALLMONITOR 
2f68 cd 6f ee			call debug_vector  
2f6b				endm  
# End of macro CALLMONITOR
2f6b					endif 
2f6b			; eval TOS 
2f6b			 
2f6b				FORTH_DSP_VALUEHL 
2f6b cd 4d 1e			call macro_dsp_valuehl 
2f6e				endm 
# End of macro FORTH_DSP_VALUEHL
2f6e			 
2f6e			;	push hl 
2f6e				FORTH_DSP_POP 
2f6e cd 05 1f			call macro_forth_dsp_pop 
2f71				endm 
# End of macro FORTH_DSP_POP
2f71			;	pop hl 
2f71			 
2f71					if DEBUG_FORTH_WORDS 
2f71						DMARK "IF1" 
2f71 f5				push af  
2f72 3a 86 2f			ld a, (.dmark)  
2f75 32 6b ee			ld (debug_mark),a  
2f78 3a 87 2f			ld a, (.dmark+1)  
2f7b 32 6c ee			ld (debug_mark+1),a  
2f7e 3a 88 2f			ld a, (.dmark+2)  
2f81 32 6d ee			ld (debug_mark+2),a  
2f84 18 03			jr .pastdmark  
2f86 ..			.dmark: db "IF1"  
2f89 f1			.pastdmark: pop af  
2f8a			endm  
# End of macro DMARK
2f8a						CALLMONITOR 
2f8a cd 6f ee			call debug_vector  
2f8d				endm  
# End of macro CALLMONITOR
2f8d					endif 
2f8d b7				or a        ; clear carry flag 
2f8e 11 00 00			ld de, 0 
2f91 eb				ex de,hl 
2f92 ed 52			sbc hl, de 
2f94 c2 1e 30			jp nz, .iftrue 
2f97			 
2f97					if DEBUG_FORTH_WORDS 
2f97						DMARK "IF2" 
2f97 f5				push af  
2f98 3a ac 2f			ld a, (.dmark)  
2f9b 32 6b ee			ld (debug_mark),a  
2f9e 3a ad 2f			ld a, (.dmark+1)  
2fa1 32 6c ee			ld (debug_mark+1),a  
2fa4 3a ae 2f			ld a, (.dmark+2)  
2fa7 32 6d ee			ld (debug_mark+2),a  
2faa 18 03			jr .pastdmark  
2fac ..			.dmark: db "IF2"  
2faf f1			.pastdmark: pop af  
2fb0			endm  
# End of macro DMARK
2fb0						CALLMONITOR 
2fb0 cd 6f ee			call debug_vector  
2fb3				endm  
# End of macro CALLMONITOR
2fb3					endif 
2fb3			 
2fb3			; if not true then skip to THEN 
2fb3			 
2fb3				; TODO get tok_ptr 
2fb3				; TODO consume toks until we get to THEN 
2fb3			 
2fb3 2a c2 e5			ld hl, (os_tok_ptr) 
2fb6					if DEBUG_FORTH_WORDS 
2fb6						DMARK "IF3" 
2fb6 f5				push af  
2fb7 3a cb 2f			ld a, (.dmark)  
2fba 32 6b ee			ld (debug_mark),a  
2fbd 3a cc 2f			ld a, (.dmark+1)  
2fc0 32 6c ee			ld (debug_mark+1),a  
2fc3 3a cd 2f			ld a, (.dmark+2)  
2fc6 32 6d ee			ld (debug_mark+2),a  
2fc9 18 03			jr .pastdmark  
2fcb ..			.dmark: db "IF3"  
2fce f1			.pastdmark: pop af  
2fcf			endm  
# End of macro DMARK
2fcf						CALLMONITOR 
2fcf cd 6f ee			call debug_vector  
2fd2				endm  
# End of macro CALLMONITOR
2fd2						 
2fd2					endif 
2fd2 11 19 30			ld de, .ifthen 
2fd5					if DEBUG_FORTH_WORDS 
2fd5						DMARK "IF4" 
2fd5 f5				push af  
2fd6 3a ea 2f			ld a, (.dmark)  
2fd9 32 6b ee			ld (debug_mark),a  
2fdc 3a eb 2f			ld a, (.dmark+1)  
2fdf 32 6c ee			ld (debug_mark+1),a  
2fe2 3a ec 2f			ld a, (.dmark+2)  
2fe5 32 6d ee			ld (debug_mark+2),a  
2fe8 18 03			jr .pastdmark  
2fea ..			.dmark: db "IF4"  
2fed f1			.pastdmark: pop af  
2fee			endm  
# End of macro DMARK
2fee						CALLMONITOR 
2fee cd 6f ee			call debug_vector  
2ff1				endm  
# End of macro CALLMONITOR
2ff1					endif 
2ff1 cd 1e 21			call findnexttok  
2ff4			 
2ff4					if DEBUG_FORTH_WORDS 
2ff4						DMARK "IF5" 
2ff4 f5				push af  
2ff5 3a 09 30			ld a, (.dmark)  
2ff8 32 6b ee			ld (debug_mark),a  
2ffb 3a 0a 30			ld a, (.dmark+1)  
2ffe 32 6c ee			ld (debug_mark+1),a  
3001 3a 0b 30			ld a, (.dmark+2)  
3004 32 6d ee			ld (debug_mark+2),a  
3007 18 03			jr .pastdmark  
3009 ..			.dmark: db "IF5"  
300c f1			.pastdmark: pop af  
300d			endm  
# End of macro DMARK
300d						CALLMONITOR 
300d cd 6f ee			call debug_vector  
3010				endm  
# End of macro CALLMONITOR
3010					endif 
3010				; TODO replace below with ; exec using tok_ptr 
3010 22 c2 e5			ld (os_tok_ptr), hl 
3013 c3 94 20			jp exec1 
3016				NEXTW 
3016 c3 03 20			jp macro_next 
3019				endm 
# End of macro NEXTW
3019			 
3019 .. 00		.ifthen:  db "THEN",0 
301e			 
301e			.iftrue:		 
301e				; Exec next words normally 
301e			 
301e				; if true then exec following IF as normal 
301e					if DEBUG_FORTH_WORDS 
301e						DMARK "IFT" 
301e f5				push af  
301f 3a 33 30			ld a, (.dmark)  
3022 32 6b ee			ld (debug_mark),a  
3025 3a 34 30			ld a, (.dmark+1)  
3028 32 6c ee			ld (debug_mark+1),a  
302b 3a 35 30			ld a, (.dmark+2)  
302e 32 6d ee			ld (debug_mark+2),a  
3031 18 03			jr .pastdmark  
3033 ..			.dmark: db "IFT"  
3036 f1			.pastdmark: pop af  
3037			endm  
# End of macro DMARK
3037						CALLMONITOR 
3037 cd 6f ee			call debug_vector  
303a				endm  
# End of macro CALLMONITOR
303a					endif 
303a			 
303a					NEXTW 
303a c3 03 20			jp macro_next 
303d				endm 
# End of macro NEXTW
303d			.THEN: 
303d				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
303d 1f				db WORD_SYS_CORE+11             
303e 65 30			dw .ELSE            
3040 05				db 4 + 1 
3041 .. 00			db "THEN",0              
3046				endm 
# End of macro CWHEAD
3046			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3046					if DEBUG_FORTH_WORDS_KEY 
3046						DMARK "THN" 
3046 f5				push af  
3047 3a 5b 30			ld a, (.dmark)  
304a 32 6b ee			ld (debug_mark),a  
304d 3a 5c 30			ld a, (.dmark+1)  
3050 32 6c ee			ld (debug_mark+1),a  
3053 3a 5d 30			ld a, (.dmark+2)  
3056 32 6d ee			ld (debug_mark+2),a  
3059 18 03			jr .pastdmark  
305b ..			.dmark: db "THN"  
305e f1			.pastdmark: pop af  
305f			endm  
# End of macro DMARK
305f						CALLMONITOR 
305f cd 6f ee			call debug_vector  
3062				endm  
# End of macro CALLMONITOR
3062					endif 
3062					NEXTW 
3062 c3 03 20			jp macro_next 
3065				endm 
# End of macro NEXTW
3065			.ELSE: 
3065				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3065 20				db WORD_SYS_CORE+12             
3066 8d 30			dw .DO            
3068 03				db 2 + 1 
3069 .. 00			db "ELSE",0              
306e				endm 
# End of macro CWHEAD
306e			; | ELSE ( -- ) Not supported - does nothing | TODO 
306e			 
306e					if DEBUG_FORTH_WORDS_KEY 
306e						DMARK "ELS" 
306e f5				push af  
306f 3a 83 30			ld a, (.dmark)  
3072 32 6b ee			ld (debug_mark),a  
3075 3a 84 30			ld a, (.dmark+1)  
3078 32 6c ee			ld (debug_mark+1),a  
307b 3a 85 30			ld a, (.dmark+2)  
307e 32 6d ee			ld (debug_mark+2),a  
3081 18 03			jr .pastdmark  
3083 ..			.dmark: db "ELS"  
3086 f1			.pastdmark: pop af  
3087			endm  
# End of macro DMARK
3087						CALLMONITOR 
3087 cd 6f ee			call debug_vector  
308a				endm  
# End of macro CALLMONITOR
308a					endif 
308a			 
308a			 
308a					NEXTW 
308a c3 03 20			jp macro_next 
308d				endm 
# End of macro NEXTW
308d			.DO: 
308d				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
308d 21				db WORD_SYS_CORE+13             
308e b4 31			dw .LOOP            
3090 03				db 2 + 1 
3091 .. 00			db "DO",0              
3094				endm 
# End of macro CWHEAD
3094			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3094			 
3094					if DEBUG_FORTH_WORDS_KEY 
3094						DMARK "DO." 
3094 f5				push af  
3095 3a a9 30			ld a, (.dmark)  
3098 32 6b ee			ld (debug_mark),a  
309b 3a aa 30			ld a, (.dmark+1)  
309e 32 6c ee			ld (debug_mark+1),a  
30a1 3a ab 30			ld a, (.dmark+2)  
30a4 32 6d ee			ld (debug_mark+2),a  
30a7 18 03			jr .pastdmark  
30a9 ..			.dmark: db "DO."  
30ac f1			.pastdmark: pop af  
30ad			endm  
# End of macro DMARK
30ad						CALLMONITOR 
30ad cd 6f ee			call debug_vector  
30b0				endm  
# End of macro CALLMONITOR
30b0					endif 
30b0			;  push pc to rsp stack past the DO 
30b0			 
30b0 2a c2 e5				ld hl, (os_tok_ptr) 
30b3 23					inc hl   ; D 
30b4 23					inc hl  ; O 
30b5 23					inc hl   ; null 
30b6					if DEBUG_FORTH_WORDS 
30b6						DMARK "DO2" 
30b6 f5				push af  
30b7 3a cb 30			ld a, (.dmark)  
30ba 32 6b ee			ld (debug_mark),a  
30bd 3a cc 30			ld a, (.dmark+1)  
30c0 32 6c ee			ld (debug_mark+1),a  
30c3 3a cd 30			ld a, (.dmark+2)  
30c6 32 6d ee			ld (debug_mark+2),a  
30c9 18 03			jr .pastdmark  
30cb ..			.dmark: db "DO2"  
30ce f1			.pastdmark: pop af  
30cf			endm  
# End of macro DMARK
30cf						CALLMONITOR 
30cf cd 6f ee			call debug_vector  
30d2				endm  
# End of macro CALLMONITOR
30d2					endif 
30d2					FORTH_RSP_NEXT 
30d2 cd fd 1b			call macro_forth_rsp_next 
30d5				endm 
# End of macro FORTH_RSP_NEXT
30d5					if DEBUG_FORTH_WORDS 
30d5						DMARK "DO3" 
30d5 f5				push af  
30d6 3a ea 30			ld a, (.dmark)  
30d9 32 6b ee			ld (debug_mark),a  
30dc 3a eb 30			ld a, (.dmark+1)  
30df 32 6c ee			ld (debug_mark+1),a  
30e2 3a ec 30			ld a, (.dmark+2)  
30e5 32 6d ee			ld (debug_mark+2),a  
30e8 18 03			jr .pastdmark  
30ea ..			.dmark: db "DO3"  
30ed f1			.pastdmark: pop af  
30ee			endm  
# End of macro DMARK
30ee						CALLMONITOR 
30ee cd 6f ee			call debug_vector  
30f1				endm  
# End of macro CALLMONITOR
30f1					endif 
30f1			 
30f1					;if DEBUG_FORTH_WORDS 
30f1				;		push hl 
30f1			;		endif  
30f1			 
30f1			; get counters from data stack 
30f1			 
30f1			 
30f1					FORTH_DSP_VALUEHL 
30f1 cd 4d 1e			call macro_dsp_valuehl 
30f4				endm 
# End of macro FORTH_DSP_VALUEHL
30f4 e5					push hl		 ; hl now has starting counter which needs to be tos 
30f5			 
30f5					if DEBUG_FORTH_WORDS 
30f5						DMARK "DO4" 
30f5 f5				push af  
30f6 3a 0a 31			ld a, (.dmark)  
30f9 32 6b ee			ld (debug_mark),a  
30fc 3a 0b 31			ld a, (.dmark+1)  
30ff 32 6c ee			ld (debug_mark+1),a  
3102 3a 0c 31			ld a, (.dmark+2)  
3105 32 6d ee			ld (debug_mark+2),a  
3108 18 03			jr .pastdmark  
310a ..			.dmark: db "DO4"  
310d f1			.pastdmark: pop af  
310e			endm  
# End of macro DMARK
310e						CALLMONITOR 
310e cd 6f ee			call debug_vector  
3111				endm  
# End of macro CALLMONITOR
3111					endif 
3111					FORTH_DSP_POP 
3111 cd 05 1f			call macro_forth_dsp_pop 
3114				endm 
# End of macro FORTH_DSP_POP
3114			 
3114					if DEBUG_FORTH_WORDS 
3114						DMARK "DO5" 
3114 f5				push af  
3115 3a 29 31			ld a, (.dmark)  
3118 32 6b ee			ld (debug_mark),a  
311b 3a 2a 31			ld a, (.dmark+1)  
311e 32 6c ee			ld (debug_mark+1),a  
3121 3a 2b 31			ld a, (.dmark+2)  
3124 32 6d ee			ld (debug_mark+2),a  
3127 18 03			jr .pastdmark  
3129 ..			.dmark: db "DO5"  
312c f1			.pastdmark: pop af  
312d			endm  
# End of macro DMARK
312d						CALLMONITOR 
312d cd 6f ee			call debug_vector  
3130				endm  
# End of macro CALLMONITOR
3130					endif 
3130			 
3130					FORTH_DSP_VALUEHL 
3130 cd 4d 1e			call macro_dsp_valuehl 
3133				endm 
# End of macro FORTH_DSP_VALUEHL
3133			;		push hl		 ; hl now has starting limit counter 
3133			 
3133					if DEBUG_FORTH_WORDS 
3133						DMARK "DO6" 
3133 f5				push af  
3134 3a 48 31			ld a, (.dmark)  
3137 32 6b ee			ld (debug_mark),a  
313a 3a 49 31			ld a, (.dmark+1)  
313d 32 6c ee			ld (debug_mark+1),a  
3140 3a 4a 31			ld a, (.dmark+2)  
3143 32 6d ee			ld (debug_mark+2),a  
3146 18 03			jr .pastdmark  
3148 ..			.dmark: db "DO6"  
314b f1			.pastdmark: pop af  
314c			endm  
# End of macro DMARK
314c						CALLMONITOR 
314c cd 6f ee			call debug_vector  
314f				endm  
# End of macro CALLMONITOR
314f					endif 
314f					FORTH_DSP_POP 
314f cd 05 1f			call macro_forth_dsp_pop 
3152				endm 
# End of macro FORTH_DSP_POP
3152			 
3152			; put counters on the loop stack 
3152			 
3152			;		pop hl			 ; limit counter 
3152 d1					pop de			; start counter 
3153			 
3153					; push limit counter 
3153			 
3153					if DEBUG_FORTH_WORDS 
3153						DMARK "DO7" 
3153 f5				push af  
3154 3a 68 31			ld a, (.dmark)  
3157 32 6b ee			ld (debug_mark),a  
315a 3a 69 31			ld a, (.dmark+1)  
315d 32 6c ee			ld (debug_mark+1),a  
3160 3a 6a 31			ld a, (.dmark+2)  
3163 32 6d ee			ld (debug_mark+2),a  
3166 18 03			jr .pastdmark  
3168 ..			.dmark: db "DO7"  
316b f1			.pastdmark: pop af  
316c			endm  
# End of macro DMARK
316c						CALLMONITOR 
316c cd 6f ee			call debug_vector  
316f				endm  
# End of macro CALLMONITOR
316f					endif 
316f					FORTH_LOOP_NEXT 
316f cd 7e 1e			call macro_forth_loop_next 
3172				endm 
# End of macro FORTH_LOOP_NEXT
3172			 
3172					; push start counter 
3172			 
3172 eb					ex de, hl 
3173					if DEBUG_FORTH_WORDS 
3173						DMARK "DO7" 
3173 f5				push af  
3174 3a 88 31			ld a, (.dmark)  
3177 32 6b ee			ld (debug_mark),a  
317a 3a 89 31			ld a, (.dmark+1)  
317d 32 6c ee			ld (debug_mark+1),a  
3180 3a 8a 31			ld a, (.dmark+2)  
3183 32 6d ee			ld (debug_mark+2),a  
3186 18 03			jr .pastdmark  
3188 ..			.dmark: db "DO7"  
318b f1			.pastdmark: pop af  
318c			endm  
# End of macro DMARK
318c						CALLMONITOR 
318c cd 6f ee			call debug_vector  
318f				endm  
# End of macro CALLMONITOR
318f					endif 
318f					FORTH_LOOP_NEXT 
318f cd 7e 1e			call macro_forth_loop_next 
3192				endm 
# End of macro FORTH_LOOP_NEXT
3192			 
3192			 
3192					; init first round of I counter 
3192			 
3192 22 e6 e5				ld (os_current_i), hl 
3195			 
3195					if DEBUG_FORTH_WORDS 
3195						DMARK "DO8" 
3195 f5				push af  
3196 3a aa 31			ld a, (.dmark)  
3199 32 6b ee			ld (debug_mark),a  
319c 3a ab 31			ld a, (.dmark+1)  
319f 32 6c ee			ld (debug_mark+1),a  
31a2 3a ac 31			ld a, (.dmark+2)  
31a5 32 6d ee			ld (debug_mark+2),a  
31a8 18 03			jr .pastdmark  
31aa ..			.dmark: db "DO8"  
31ad f1			.pastdmark: pop af  
31ae			endm  
# End of macro DMARK
31ae						CALLMONITOR 
31ae cd 6f ee			call debug_vector  
31b1				endm  
# End of macro CALLMONITOR
31b1					endif 
31b1			 
31b1					NEXTW 
31b1 c3 03 20			jp macro_next 
31b4				endm 
# End of macro NEXTW
31b4			.LOOP: 
31b4				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
31b4 22				db WORD_SYS_CORE+14             
31b5 cc 32			dw .I            
31b7 05				db 4 + 1 
31b8 .. 00			db "LOOP",0              
31bd				endm 
# End of macro CWHEAD
31bd			; | LOOP ( -- ) Increment and test loop counter  | DONE 
31bd			 
31bd				; pop tos as current loop count to hl 
31bd			 
31bd				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
31bd			 
31bd				FORTH_LOOP_TOS 
31bd cd b1 1e			call macro_forth_loop_tos 
31c0				endm 
# End of macro FORTH_LOOP_TOS
31c0 e5				push hl 
31c1			 
31c1					if DEBUG_FORTH_WORDS_KEY 
31c1						DMARK "LOP" 
31c1 f5				push af  
31c2 3a d6 31			ld a, (.dmark)  
31c5 32 6b ee			ld (debug_mark),a  
31c8 3a d7 31			ld a, (.dmark+1)  
31cb 32 6c ee			ld (debug_mark+1),a  
31ce 3a d8 31			ld a, (.dmark+2)  
31d1 32 6d ee			ld (debug_mark+2),a  
31d4 18 03			jr .pastdmark  
31d6 ..			.dmark: db "LOP"  
31d9 f1			.pastdmark: pop af  
31da			endm  
# End of macro DMARK
31da						CALLMONITOR 
31da cd 6f ee			call debug_vector  
31dd				endm  
# End of macro CALLMONITOR
31dd					endif 
31dd				; next item on the stack is the limit. get it 
31dd			 
31dd			 
31dd				FORTH_LOOP_POP 
31dd cd bb 1e			call macro_forth_loop_pop 
31e0				endm 
# End of macro FORTH_LOOP_POP
31e0			 
31e0				FORTH_LOOP_TOS 
31e0 cd b1 1e			call macro_forth_loop_tos 
31e3				endm 
# End of macro FORTH_LOOP_TOS
31e3			 
31e3 d1				pop de		 ; de = i, hl = limit 
31e4			 
31e4					if DEBUG_FORTH_WORDS 
31e4						DMARK "LP1" 
31e4 f5				push af  
31e5 3a f9 31			ld a, (.dmark)  
31e8 32 6b ee			ld (debug_mark),a  
31eb 3a fa 31			ld a, (.dmark+1)  
31ee 32 6c ee			ld (debug_mark+1),a  
31f1 3a fb 31			ld a, (.dmark+2)  
31f4 32 6d ee			ld (debug_mark+2),a  
31f7 18 03			jr .pastdmark  
31f9 ..			.dmark: db "LP1"  
31fc f1			.pastdmark: pop af  
31fd			endm  
# End of macro DMARK
31fd						CALLMONITOR 
31fd cd 6f ee			call debug_vector  
3200				endm  
# End of macro CALLMONITOR
3200					endif 
3200			 
3200				; go back to previous word 
3200			 
3200 d5				push de    ; save I for inc later 
3201			 
3201			 
3201				; get limit 
3201				;  is I at limit? 
3201			 
3201			 
3201					if DEBUG_FORTH_WORDS 
3201						DMARK "LP1" 
3201 f5				push af  
3202 3a 16 32			ld a, (.dmark)  
3205 32 6b ee			ld (debug_mark),a  
3208 3a 17 32			ld a, (.dmark+1)  
320b 32 6c ee			ld (debug_mark+1),a  
320e 3a 18 32			ld a, (.dmark+2)  
3211 32 6d ee			ld (debug_mark+2),a  
3214 18 03			jr .pastdmark  
3216 ..			.dmark: db "LP1"  
3219 f1			.pastdmark: pop af  
321a			endm  
# End of macro DMARK
321a						CALLMONITOR 
321a cd 6f ee			call debug_vector  
321d				endm  
# End of macro CALLMONITOR
321d					endif 
321d			 
321d ed 52			sbc hl, de 
321f			 
321f			 
321f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
321f			 
321f 20 26				jr nz, .loopnotdone 
3221			 
3221 e1				pop hl   ; get rid of saved I 
3222				FORTH_LOOP_POP     ; get rid of limit 
3222 cd bb 1e			call macro_forth_loop_pop 
3225				endm 
# End of macro FORTH_LOOP_POP
3225			 
3225				FORTH_RSP_POP     ; get rid of DO ptr 
3225 cd 1e 1c			call macro_forth_rsp_pop 
3228				endm 
# End of macro FORTH_RSP_POP
3228			 
3228			if DEBUG_FORTH_WORDS 
3228						DMARK "LP>" 
3228 f5				push af  
3229 3a 3d 32			ld a, (.dmark)  
322c 32 6b ee			ld (debug_mark),a  
322f 3a 3e 32			ld a, (.dmark+1)  
3232 32 6c ee			ld (debug_mark+1),a  
3235 3a 3f 32			ld a, (.dmark+2)  
3238 32 6d ee			ld (debug_mark+2),a  
323b 18 03			jr .pastdmark  
323d ..			.dmark: db "LP>"  
3240 f1			.pastdmark: pop af  
3241			endm  
# End of macro DMARK
3241				CALLMONITOR 
3241 cd 6f ee			call debug_vector  
3244				endm  
# End of macro CALLMONITOR
3244			endif 
3244			 
3244					NEXTW 
3244 c3 03 20			jp macro_next 
3247				endm 
# End of macro NEXTW
3247				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3247			 
3247			.loopnotdone: 
3247			 
3247 e1				pop hl    ; get I 
3248 23				inc hl 
3249			 
3249			   	; save new I 
3249			 
3249			 
3249					; set I counter 
3249			 
3249 22 e6 e5				ld (os_current_i), hl 
324c			 
324c					if DEBUG_FORTH_WORDS 
324c						DMARK "LPN" 
324c f5				push af  
324d 3a 61 32			ld a, (.dmark)  
3250 32 6b ee			ld (debug_mark),a  
3253 3a 62 32			ld a, (.dmark+1)  
3256 32 6c ee			ld (debug_mark+1),a  
3259 3a 63 32			ld a, (.dmark+2)  
325c 32 6d ee			ld (debug_mark+2),a  
325f 18 03			jr .pastdmark  
3261 ..			.dmark: db "LPN"  
3264 f1			.pastdmark: pop af  
3265			endm  
# End of macro DMARK
3265					CALLMONITOR 
3265 cd 6f ee			call debug_vector  
3268				endm  
# End of macro CALLMONITOR
3268					endif 
3268					 
3268				FORTH_LOOP_NEXT 
3268 cd 7e 1e			call macro_forth_loop_next 
326b				endm 
# End of macro FORTH_LOOP_NEXT
326b			 
326b			 
326b					if DEBUG_FORTH_WORDS 
326b eb						ex de,hl 
326c					endif 
326c			 
326c			;	; get DO ptr 
326c			; 
326c					if DEBUG_FORTH_WORDS 
326c						DMARK "LP7" 
326c f5				push af  
326d 3a 81 32			ld a, (.dmark)  
3270 32 6b ee			ld (debug_mark),a  
3273 3a 82 32			ld a, (.dmark+1)  
3276 32 6c ee			ld (debug_mark+1),a  
3279 3a 83 32			ld a, (.dmark+2)  
327c 32 6d ee			ld (debug_mark+2),a  
327f 18 03			jr .pastdmark  
3281 ..			.dmark: db "LP7"  
3284 f1			.pastdmark: pop af  
3285			endm  
# End of macro DMARK
3285					CALLMONITOR 
3285 cd 6f ee			call debug_vector  
3288				endm  
# End of macro CALLMONITOR
3288					endif 
3288				FORTH_RSP_TOS 
3288 cd 14 1c			call macro_forth_rsp_tos 
328b				endm 
# End of macro FORTH_RSP_TOS
328b			 
328b					if DEBUG_FORTH_WORDS 
328b						DMARK "LP8" 
328b f5				push af  
328c 3a a0 32			ld a, (.dmark)  
328f 32 6b ee			ld (debug_mark),a  
3292 3a a1 32			ld a, (.dmark+1)  
3295 32 6c ee			ld (debug_mark+1),a  
3298 3a a2 32			ld a, (.dmark+2)  
329b 32 6d ee			ld (debug_mark+2),a  
329e 18 03			jr .pastdmark  
32a0 ..			.dmark: db "LP8"  
32a3 f1			.pastdmark: pop af  
32a4			endm  
# End of macro DMARK
32a4					CALLMONITOR 
32a4 cd 6f ee			call debug_vector  
32a7				endm  
# End of macro CALLMONITOR
32a7					endif 
32a7				;push hl 
32a7			 
32a7				; not going to DO any more 
32a7				; get rid of the RSP pointer as DO will add it back in 
32a7				;FORTH_RSP_POP 
32a7				;pop hl 
32a7			 
32a7				;ld hl,(cli_ret_sp) 
32a7				;ld e, (hl) 
32a7				;inc hl 
32a7				;ld d, (hl) 
32a7				;ex de,hl 
32a7 22 c2 e5			ld (os_tok_ptr), hl 
32aa					if DEBUG_FORTH_WORDS 
32aa						DMARK "LP<" 
32aa f5				push af  
32ab 3a bf 32			ld a, (.dmark)  
32ae 32 6b ee			ld (debug_mark),a  
32b1 3a c0 32			ld a, (.dmark+1)  
32b4 32 6c ee			ld (debug_mark+1),a  
32b7 3a c1 32			ld a, (.dmark+2)  
32ba 32 6d ee			ld (debug_mark+2),a  
32bd 18 03			jr .pastdmark  
32bf ..			.dmark: db "LP<"  
32c2 f1			.pastdmark: pop af  
32c3			endm  
# End of macro DMARK
32c3					CALLMONITOR 
32c3 cd 6f ee			call debug_vector  
32c6				endm  
# End of macro CALLMONITOR
32c6				endif 
32c6 c3 94 20			jp exec1 
32c9			 
32c9					 
32c9			 
32c9			 
32c9					NEXTW 
32c9 c3 03 20			jp macro_next 
32cc				endm 
# End of macro NEXTW
32cc			.I:  
32cc			 
32cc				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
32cc 5e				db WORD_SYS_CORE+74             
32cd f7 32			dw .DLOOP            
32cf 02				db 1 + 1 
32d0 .. 00			db "I",0              
32d2				endm 
# End of macro CWHEAD
32d2			; | I ( -- ) Current loop counter | DONE 
32d2					if DEBUG_FORTH_WORDS_KEY 
32d2						DMARK "I.." 
32d2 f5				push af  
32d3 3a e7 32			ld a, (.dmark)  
32d6 32 6b ee			ld (debug_mark),a  
32d9 3a e8 32			ld a, (.dmark+1)  
32dc 32 6c ee			ld (debug_mark+1),a  
32df 3a e9 32			ld a, (.dmark+2)  
32e2 32 6d ee			ld (debug_mark+2),a  
32e5 18 03			jr .pastdmark  
32e7 ..			.dmark: db "I.."  
32ea f1			.pastdmark: pop af  
32eb			endm  
# End of macro DMARK
32eb						CALLMONITOR 
32eb cd 6f ee			call debug_vector  
32ee				endm  
# End of macro CALLMONITOR
32ee					endif 
32ee			 
32ee 2a e6 e5				ld hl,(os_current_i) 
32f1 cd 56 1c				call forth_push_numhl 
32f4			 
32f4					NEXTW 
32f4 c3 03 20			jp macro_next 
32f7				endm 
# End of macro NEXTW
32f7			.DLOOP: 
32f7				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
32f7 5f				db WORD_SYS_CORE+75             
32f8 d8 33			dw .REPEAT            
32fa 06				db 5 + 1 
32fb .. 00			db "-LOOP",0              
3301				endm 
# End of macro CWHEAD
3301			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3301				; pop tos as current loop count to hl 
3301					if DEBUG_FORTH_WORDS_KEY 
3301						DMARK "-LP" 
3301 f5				push af  
3302 3a 16 33			ld a, (.dmark)  
3305 32 6b ee			ld (debug_mark),a  
3308 3a 17 33			ld a, (.dmark+1)  
330b 32 6c ee			ld (debug_mark+1),a  
330e 3a 18 33			ld a, (.dmark+2)  
3311 32 6d ee			ld (debug_mark+2),a  
3314 18 03			jr .pastdmark  
3316 ..			.dmark: db "-LP"  
3319 f1			.pastdmark: pop af  
331a			endm  
# End of macro DMARK
331a						CALLMONITOR 
331a cd 6f ee			call debug_vector  
331d				endm  
# End of macro CALLMONITOR
331d					endif 
331d			 
331d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
331d			 
331d				FORTH_LOOP_TOS 
331d cd b1 1e			call macro_forth_loop_tos 
3320				endm 
# End of macro FORTH_LOOP_TOS
3320 e5				push hl 
3321			 
3321					if DEBUG_FORTH_WORDS 
3321						DMARK "-LP" 
3321 f5				push af  
3322 3a 36 33			ld a, (.dmark)  
3325 32 6b ee			ld (debug_mark),a  
3328 3a 37 33			ld a, (.dmark+1)  
332b 32 6c ee			ld (debug_mark+1),a  
332e 3a 38 33			ld a, (.dmark+2)  
3331 32 6d ee			ld (debug_mark+2),a  
3334 18 03			jr .pastdmark  
3336 ..			.dmark: db "-LP"  
3339 f1			.pastdmark: pop af  
333a			endm  
# End of macro DMARK
333a						CALLMONITOR 
333a cd 6f ee			call debug_vector  
333d				endm  
# End of macro CALLMONITOR
333d					endif 
333d				; next item on the stack is the limit. get it 
333d			 
333d			 
333d				FORTH_LOOP_POP 
333d cd bb 1e			call macro_forth_loop_pop 
3340				endm 
# End of macro FORTH_LOOP_POP
3340			 
3340				FORTH_LOOP_TOS 
3340 cd b1 1e			call macro_forth_loop_tos 
3343				endm 
# End of macro FORTH_LOOP_TOS
3343			 
3343 d1				pop de		 ; de = i, hl = limit 
3344			 
3344					if DEBUG_FORTH_WORDS 
3344						DMARK "-L1" 
3344 f5				push af  
3345 3a 59 33			ld a, (.dmark)  
3348 32 6b ee			ld (debug_mark),a  
334b 3a 5a 33			ld a, (.dmark+1)  
334e 32 6c ee			ld (debug_mark+1),a  
3351 3a 5b 33			ld a, (.dmark+2)  
3354 32 6d ee			ld (debug_mark+2),a  
3357 18 03			jr .pastdmark  
3359 ..			.dmark: db "-L1"  
335c f1			.pastdmark: pop af  
335d			endm  
# End of macro DMARK
335d						CALLMONITOR 
335d cd 6f ee			call debug_vector  
3360				endm  
# End of macro CALLMONITOR
3360					endif 
3360			 
3360				; go back to previous word 
3360			 
3360 d5				push de    ; save I for inc later 
3361			 
3361			 
3361				; get limit 
3361				;  is I at limit? 
3361			 
3361			 
3361					if DEBUG_FORTH_WORDS 
3361						DMARK "-L1" 
3361 f5				push af  
3362 3a 76 33			ld a, (.dmark)  
3365 32 6b ee			ld (debug_mark),a  
3368 3a 77 33			ld a, (.dmark+1)  
336b 32 6c ee			ld (debug_mark+1),a  
336e 3a 78 33			ld a, (.dmark+2)  
3371 32 6d ee			ld (debug_mark+2),a  
3374 18 03			jr .pastdmark  
3376 ..			.dmark: db "-L1"  
3379 f1			.pastdmark: pop af  
337a			endm  
# End of macro DMARK
337a						CALLMONITOR 
337a cd 6f ee			call debug_vector  
337d				endm  
# End of macro CALLMONITOR
337d					endif 
337d			 
337d ed 52			sbc hl, de 
337f			 
337f			 
337f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
337f			 
337f 20 26				jr nz, .mloopnotdone 
3381			 
3381 e1				pop hl   ; get rid of saved I 
3382				FORTH_LOOP_POP     ; get rid of limit 
3382 cd bb 1e			call macro_forth_loop_pop 
3385				endm 
# End of macro FORTH_LOOP_POP
3385			 
3385				FORTH_RSP_POP     ; get rid of DO ptr 
3385 cd 1e 1c			call macro_forth_rsp_pop 
3388				endm 
# End of macro FORTH_RSP_POP
3388			 
3388			if DEBUG_FORTH_WORDS 
3388						DMARK "-L>" 
3388 f5				push af  
3389 3a 9d 33			ld a, (.dmark)  
338c 32 6b ee			ld (debug_mark),a  
338f 3a 9e 33			ld a, (.dmark+1)  
3392 32 6c ee			ld (debug_mark+1),a  
3395 3a 9f 33			ld a, (.dmark+2)  
3398 32 6d ee			ld (debug_mark+2),a  
339b 18 03			jr .pastdmark  
339d ..			.dmark: db "-L>"  
33a0 f1			.pastdmark: pop af  
33a1			endm  
# End of macro DMARK
33a1				CALLMONITOR 
33a1 cd 6f ee			call debug_vector  
33a4				endm  
# End of macro CALLMONITOR
33a4			endif 
33a4			 
33a4					NEXTW 
33a4 c3 03 20			jp macro_next 
33a7				endm 
# End of macro NEXTW
33a7				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
33a7			 
33a7			.mloopnotdone: 
33a7			 
33a7 e1				pop hl    ; get I 
33a8 2b				dec hl 
33a9			 
33a9			   	; save new I 
33a9			 
33a9			 
33a9					; set I counter 
33a9			 
33a9 22 e6 e5				ld (os_current_i), hl 
33ac			 
33ac					 
33ac				FORTH_LOOP_NEXT 
33ac cd 7e 1e			call macro_forth_loop_next 
33af				endm 
# End of macro FORTH_LOOP_NEXT
33af			 
33af			 
33af					if DEBUG_FORTH_WORDS 
33af eb						ex de,hl 
33b0					endif 
33b0			 
33b0			;	; get DO ptr 
33b0			; 
33b0				FORTH_RSP_TOS 
33b0 cd 14 1c			call macro_forth_rsp_tos 
33b3				endm 
# End of macro FORTH_RSP_TOS
33b3			 
33b3				;push hl 
33b3			 
33b3				; not going to DO any more 
33b3				; get rid of the RSP pointer as DO will add it back in 
33b3				;FORTH_RSP_POP 
33b3				;pop hl 
33b3			 
33b3			 
33b3 22 c2 e5			ld (os_tok_ptr), hl 
33b6					if DEBUG_FORTH_WORDS 
33b6						DMARK "-L<" 
33b6 f5				push af  
33b7 3a cb 33			ld a, (.dmark)  
33ba 32 6b ee			ld (debug_mark),a  
33bd 3a cc 33			ld a, (.dmark+1)  
33c0 32 6c ee			ld (debug_mark+1),a  
33c3 3a cd 33			ld a, (.dmark+2)  
33c6 32 6d ee			ld (debug_mark+2),a  
33c9 18 03			jr .pastdmark  
33cb ..			.dmark: db "-L<"  
33ce f1			.pastdmark: pop af  
33cf			endm  
# End of macro DMARK
33cf					CALLMONITOR 
33cf cd 6f ee			call debug_vector  
33d2				endm  
# End of macro CALLMONITOR
33d2				endif 
33d2 c3 94 20			jp exec1 
33d5			 
33d5					 
33d5			 
33d5			 
33d5			 
33d5				NEXTW 
33d5 c3 03 20			jp macro_next 
33d8				endm 
# End of macro NEXTW
33d8			 
33d8			 
33d8			 
33d8			 
33d8			.REPEAT: 
33d8				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
33d8 71				db WORD_SYS_CORE+93             
33d9 2b 34			dw .UNTIL            
33db 06				db 5 + 1 
33dc .. 00			db "REPEAT",0              
33e3				endm 
# End of macro CWHEAD
33e3			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
33e3			;  push pc to rsp stack past the REPEAT 
33e3					if DEBUG_FORTH_WORDS_KEY 
33e3						DMARK "REP" 
33e3 f5				push af  
33e4 3a f8 33			ld a, (.dmark)  
33e7 32 6b ee			ld (debug_mark),a  
33ea 3a f9 33			ld a, (.dmark+1)  
33ed 32 6c ee			ld (debug_mark+1),a  
33f0 3a fa 33			ld a, (.dmark+2)  
33f3 32 6d ee			ld (debug_mark+2),a  
33f6 18 03			jr .pastdmark  
33f8 ..			.dmark: db "REP"  
33fb f1			.pastdmark: pop af  
33fc			endm  
# End of macro DMARK
33fc						CALLMONITOR 
33fc cd 6f ee			call debug_vector  
33ff				endm  
# End of macro CALLMONITOR
33ff					endif 
33ff			 
33ff 2a c2 e5				ld hl, (os_tok_ptr) 
3402 23					inc hl   ; R 
3403 23					inc hl  ; E 
3404 23					inc hl   ; P 
3405 23					inc hl   ; E 
3406 23					inc hl   ; A 
3407 23					inc hl   ; T 
3408 23					inc hl   ; zero 
3409					FORTH_RSP_NEXT 
3409 cd fd 1b			call macro_forth_rsp_next 
340c				endm 
# End of macro FORTH_RSP_NEXT
340c			 
340c			 
340c					if DEBUG_FORTH_WORDS 
340c						DMARK "REP" 
340c f5				push af  
340d 3a 21 34			ld a, (.dmark)  
3410 32 6b ee			ld (debug_mark),a  
3413 3a 22 34			ld a, (.dmark+1)  
3416 32 6c ee			ld (debug_mark+1),a  
3419 3a 23 34			ld a, (.dmark+2)  
341c 32 6d ee			ld (debug_mark+2),a  
341f 18 03			jr .pastdmark  
3421 ..			.dmark: db "REP"  
3424 f1			.pastdmark: pop af  
3425			endm  
# End of macro DMARK
3425						;pop bc    ; TODO BUG ?????? what is this for???? 
3425						CALLMONITOR 
3425 cd 6f ee			call debug_vector  
3428				endm  
# End of macro CALLMONITOR
3428					endif 
3428			 
3428					NEXTW 
3428 c3 03 20			jp macro_next 
342b				endm 
# End of macro NEXTW
342b			;	       NEXTW 
342b			 
342b			.UNTIL: 
342b				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
342b 72				db WORD_SYS_CORE+94             
342c c2 34			dw .ENDFLOW            
342e 06				db 5 + 1 
342f .. 00			db "UNTIL",0              
3435				endm 
# End of macro CWHEAD
3435			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3435			 
3435				; pop tos as check 
3435			 
3435				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3435			 
3435				FORTH_DSP_VALUEHL 
3435 cd 4d 1e			call macro_dsp_valuehl 
3438				endm 
# End of macro FORTH_DSP_VALUEHL
3438			 
3438					if DEBUG_FORTH_WORDS_KEY 
3438						DMARK "UNT" 
3438 f5				push af  
3439 3a 4d 34			ld a, (.dmark)  
343c 32 6b ee			ld (debug_mark),a  
343f 3a 4e 34			ld a, (.dmark+1)  
3442 32 6c ee			ld (debug_mark+1),a  
3445 3a 4f 34			ld a, (.dmark+2)  
3448 32 6d ee			ld (debug_mark+2),a  
344b 18 03			jr .pastdmark  
344d ..			.dmark: db "UNT"  
3450 f1			.pastdmark: pop af  
3451			endm  
# End of macro DMARK
3451						CALLMONITOR 
3451 cd 6f ee			call debug_vector  
3454				endm  
# End of macro CALLMONITOR
3454					endif 
3454			 
3454			;	push hl 
3454				FORTH_DSP_POP 
3454 cd 05 1f			call macro_forth_dsp_pop 
3457				endm 
# End of macro FORTH_DSP_POP
3457			 
3457			;	pop hl 
3457			 
3457				; test if true 
3457			 
3457 cd 10 0e			call ishlzero 
345a			;	ld a,l 
345a			;	add h 
345a			; 
345a			;	cp 0 
345a			 
345a 20 3e			jr nz, .untilnotdone 
345c			 
345c					if DEBUG_FORTH_WORDS 
345c						DMARK "UNf" 
345c f5				push af  
345d 3a 71 34			ld a, (.dmark)  
3460 32 6b ee			ld (debug_mark),a  
3463 3a 72 34			ld a, (.dmark+1)  
3466 32 6c ee			ld (debug_mark+1),a  
3469 3a 73 34			ld a, (.dmark+2)  
346c 32 6d ee			ld (debug_mark+2),a  
346f 18 03			jr .pastdmark  
3471 ..			.dmark: db "UNf"  
3474 f1			.pastdmark: pop af  
3475			endm  
# End of macro DMARK
3475						CALLMONITOR 
3475 cd 6f ee			call debug_vector  
3478				endm  
# End of macro CALLMONITOR
3478					endif 
3478			 
3478			 
3478			 
3478				FORTH_RSP_POP     ; get rid of DO ptr 
3478 cd 1e 1c			call macro_forth_rsp_pop 
347b				endm 
# End of macro FORTH_RSP_POP
347b			 
347b			if DEBUG_FORTH_WORDS 
347b						DMARK "UN>" 
347b f5				push af  
347c 3a 90 34			ld a, (.dmark)  
347f 32 6b ee			ld (debug_mark),a  
3482 3a 91 34			ld a, (.dmark+1)  
3485 32 6c ee			ld (debug_mark+1),a  
3488 3a 92 34			ld a, (.dmark+2)  
348b 32 6d ee			ld (debug_mark+2),a  
348e 18 03			jr .pastdmark  
3490 ..			.dmark: db "UN>"  
3493 f1			.pastdmark: pop af  
3494			endm  
# End of macro DMARK
3494				CALLMONITOR 
3494 cd 6f ee			call debug_vector  
3497				endm  
# End of macro CALLMONITOR
3497			endif 
3497			 
3497					NEXTW 
3497 c3 03 20			jp macro_next 
349a				endm 
# End of macro NEXTW
349a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
349a			 
349a			.untilnotdone: 
349a			 
349a			 
349a			;	; get DO ptr 
349a			; 
349a				FORTH_RSP_TOS 
349a cd 14 1c			call macro_forth_rsp_tos 
349d				endm 
# End of macro FORTH_RSP_TOS
349d			 
349d				;push hl 
349d			 
349d				; not going to DO any more 
349d				; get rid of the RSP pointer as DO will add it back in 
349d				;FORTH_RSP_POP 
349d				;pop hl 
349d			 
349d			 
349d 22 c2 e5			ld (os_tok_ptr), hl 
34a0					if DEBUG_FORTH_WORDS 
34a0						DMARK "UN<" 
34a0 f5				push af  
34a1 3a b5 34			ld a, (.dmark)  
34a4 32 6b ee			ld (debug_mark),a  
34a7 3a b6 34			ld a, (.dmark+1)  
34aa 32 6c ee			ld (debug_mark+1),a  
34ad 3a b7 34			ld a, (.dmark+2)  
34b0 32 6d ee			ld (debug_mark+2),a  
34b3 18 03			jr .pastdmark  
34b5 ..			.dmark: db "UN<"  
34b8 f1			.pastdmark: pop af  
34b9			endm  
# End of macro DMARK
34b9					CALLMONITOR 
34b9 cd 6f ee			call debug_vector  
34bc				endm  
# End of macro CALLMONITOR
34bc				endif 
34bc c3 94 20			jp exec1 
34bf			 
34bf					 
34bf			 
34bf			 
34bf					NEXTW 
34bf c3 03 20			jp macro_next 
34c2				endm 
# End of macro NEXTW
34c2			 
34c2			 
34c2			.ENDFLOW: 
34c2			 
34c2			; eof 
34c2			 
# End of file forth_words_flow.asm
34c2			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
34c2			include "forth_words_logic.asm" 
34c2			 
34c2			; | ## Logic Words 
34c2			 
34c2			.NOT: 
34c2				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
34c2 2d				db WORD_SYS_CORE+25             
34c3 0a 35			dw .IS            
34c5 04				db 3 + 1 
34c6 .. 00			db "NOT",0              
34ca				endm 
# End of macro CWHEAD
34ca			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
34ca					if DEBUG_FORTH_WORDS_KEY 
34ca						DMARK "NOT" 
34ca f5				push af  
34cb 3a df 34			ld a, (.dmark)  
34ce 32 6b ee			ld (debug_mark),a  
34d1 3a e0 34			ld a, (.dmark+1)  
34d4 32 6c ee			ld (debug_mark+1),a  
34d7 3a e1 34			ld a, (.dmark+2)  
34da 32 6d ee			ld (debug_mark+2),a  
34dd 18 03			jr .pastdmark  
34df ..			.dmark: db "NOT"  
34e2 f1			.pastdmark: pop af  
34e3			endm  
# End of macro DMARK
34e3						CALLMONITOR 
34e3 cd 6f ee			call debug_vector  
34e6				endm  
# End of macro CALLMONITOR
34e6					endif 
34e6					FORTH_DSP 
34e6 cd 13 1e			call macro_forth_dsp 
34e9				endm 
# End of macro FORTH_DSP
34e9 7e					ld a,(hl)	; get type of value on TOS 
34ea fe 02				cp DS_TYPE_INUM  
34ec 28 03				jr z, .noti 
34ee					NEXTW 
34ee c3 03 20			jp macro_next 
34f1				endm 
# End of macro NEXTW
34f1			.noti:          FORTH_DSP_VALUEHL 
34f1 cd 4d 1e			call macro_dsp_valuehl 
34f4				endm 
# End of macro FORTH_DSP_VALUEHL
34f4			;		push hl 
34f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34f4 cd 05 1f			call macro_forth_dsp_pop 
34f7				endm 
# End of macro FORTH_DSP_POP
34f7			;		pop hl 
34f7 3e 00				ld a,0 
34f9 bd					cp l 
34fa 28 04				jr z, .not2t 
34fc 2e 00				ld l, 0 
34fe 18 02				jr .notip 
3500			 
3500 2e ff		.not2t:		ld l, 255 
3502			 
3502 26 00		.notip:		ld h, 0	 
3504			 
3504 cd 56 1c				call forth_push_numhl 
3507					NEXTW 
3507 c3 03 20			jp macro_next 
350a				endm 
# End of macro NEXTW
350a			 
350a			.IS: 
350a				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
350a 2d				db WORD_SYS_CORE+25             
350b 30 35			dw .LZERO            
350d 03				db 2 + 1 
350e .. 00			db "IS",0              
3511				endm 
# End of macro CWHEAD
3511			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3511					if DEBUG_FORTH_WORDS_KEY 
3511						DMARK "IS." 
3511 f5				push af  
3512 3a 26 35			ld a, (.dmark)  
3515 32 6b ee			ld (debug_mark),a  
3518 3a 27 35			ld a, (.dmark+1)  
351b 32 6c ee			ld (debug_mark+1),a  
351e 3a 28 35			ld a, (.dmark+2)  
3521 32 6d ee			ld (debug_mark+2),a  
3524 18 03			jr .pastdmark  
3526 ..			.dmark: db "IS."  
3529 f1			.pastdmark: pop af  
352a			endm  
# End of macro DMARK
352a						CALLMONITOR 
352a cd 6f ee			call debug_vector  
352d				endm  
# End of macro CALLMONITOR
352d					endif 
352d					NEXTW 
352d c3 03 20			jp macro_next 
3530				endm 
# End of macro NEXTW
3530			.LZERO: 
3530				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3530 2d				db WORD_SYS_CORE+25             
3531 3a 35			dw .TZERO            
3533 03				db 2 + 1 
3534 .. 00			db "0<",0              
3537				endm 
# End of macro CWHEAD
3537			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3537					NEXTW 
3537 c3 03 20			jp macro_next 
353a				endm 
# End of macro NEXTW
353a			.TZERO: 
353a				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
353a 2e				db WORD_SYS_CORE+26             
353b 81 35			dw .LESS            
353d 03				db 2 + 1 
353e .. 00			db "0=",0              
3541				endm 
# End of macro CWHEAD
3541			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3541				; TODO add floating point number detection 
3541					;v5 FORTH_DSP_VALUE 
3541					if DEBUG_FORTH_WORDS_KEY 
3541						DMARK "0=." 
3541 f5				push af  
3542 3a 56 35			ld a, (.dmark)  
3545 32 6b ee			ld (debug_mark),a  
3548 3a 57 35			ld a, (.dmark+1)  
354b 32 6c ee			ld (debug_mark+1),a  
354e 3a 58 35			ld a, (.dmark+2)  
3551 32 6d ee			ld (debug_mark+2),a  
3554 18 03			jr .pastdmark  
3556 ..			.dmark: db "0=."  
3559 f1			.pastdmark: pop af  
355a			endm  
# End of macro DMARK
355a						CALLMONITOR 
355a cd 6f ee			call debug_vector  
355d				endm  
# End of macro CALLMONITOR
355d					endif 
355d					FORTH_DSP 
355d cd 13 1e			call macro_forth_dsp 
3560				endm 
# End of macro FORTH_DSP
3560 7e					ld a,(hl)	; get type of value on TOS 
3561 fe 02				cp DS_TYPE_INUM  
3563 28 00				jr z, .tz_inum 
3565			 
3565				if FORTH_ENABLE_FLOATMATH 
3565					jr .tz_done 
3565			 
3565				endif 
3565					 
3565			 
3565			.tz_inum: 
3565					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3565 cd 4d 1e			call macro_dsp_valuehl 
3568				endm 
# End of macro FORTH_DSP_VALUEHL
3568			 
3568			;		push hl 
3568			 
3568					; destroy value TOS 
3568			 
3568					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3568 cd 05 1f			call macro_forth_dsp_pop 
356b				endm 
# End of macro FORTH_DSP_POP
356b			 
356b			;		pop hl 
356b			 
356b 3e 00				ld a,0 
356d			 
356d bd					cp l 
356e 20 08				jr nz, .tz_notzero 
3570			 
3570 bc					cp h 
3571			 
3571 20 05				jr nz, .tz_notzero 
3573			 
3573			 
3573 21 01 00				ld hl, FORTH_TRUE 
3576 18 03				jr .tz_done 
3578			 
3578 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
357b			 
357b					; push value back onto stack for another op etc 
357b			 
357b			.tz_done: 
357b cd 56 1c				call forth_push_numhl 
357e			 
357e					NEXTW 
357e c3 03 20			jp macro_next 
3581				endm 
# End of macro NEXTW
3581			.LESS: 
3581				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3581 2f				db WORD_SYS_CORE+27             
3582 ea 35			dw .GT            
3584 02				db 1 + 1 
3585 .. 00			db "<",0              
3587				endm 
# End of macro CWHEAD
3587			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3587				; TODO add floating point number detection 
3587					if DEBUG_FORTH_WORDS_KEY 
3587						DMARK "LES" 
3587 f5				push af  
3588 3a 9c 35			ld a, (.dmark)  
358b 32 6b ee			ld (debug_mark),a  
358e 3a 9d 35			ld a, (.dmark+1)  
3591 32 6c ee			ld (debug_mark+1),a  
3594 3a 9e 35			ld a, (.dmark+2)  
3597 32 6d ee			ld (debug_mark+2),a  
359a 18 03			jr .pastdmark  
359c ..			.dmark: db "LES"  
359f f1			.pastdmark: pop af  
35a0			endm  
# End of macro DMARK
35a0						CALLMONITOR 
35a0 cd 6f ee			call debug_vector  
35a3				endm  
# End of macro CALLMONITOR
35a3					endif 
35a3					FORTH_DSP 
35a3 cd 13 1e			call macro_forth_dsp 
35a6				endm 
# End of macro FORTH_DSP
35a6					;v5 FORTH_DSP_VALUE 
35a6 7e					ld a,(hl)	; get type of value on TOS 
35a7 fe 02				cp DS_TYPE_INUM  
35a9 28 00				jr z, .less_inum 
35ab			 
35ab				if FORTH_ENABLE_FLOATMATH 
35ab					jr .less_done 
35ab			 
35ab				endif 
35ab					 
35ab			 
35ab			.less_inum: 
35ab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35ab cd 4d 1e			call macro_dsp_valuehl 
35ae				endm 
# End of macro FORTH_DSP_VALUEHL
35ae			 
35ae e5					push hl  ; u2 
35af			 
35af					; destroy value TOS 
35af			 
35af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35af cd 05 1f			call macro_forth_dsp_pop 
35b2				endm 
# End of macro FORTH_DSP_POP
35b2			 
35b2			 
35b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35b2 cd 4d 1e			call macro_dsp_valuehl 
35b5				endm 
# End of macro FORTH_DSP_VALUEHL
35b5			 
35b5 e5					push hl    ; u1 
35b6			 
35b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35b6 cd 05 1f			call macro_forth_dsp_pop 
35b9				endm 
# End of macro FORTH_DSP_POP
35b9			 
35b9			 
35b9 b7			 or a      ;clear carry flag 
35ba 01 00 00		 ld bc, FORTH_FALSE 
35bd e1			  pop hl    ; u1 
35be d1			  pop de    ; u2 
35bf ed 52		  sbc hl,de 
35c1 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
35c3			 
35c3 01 01 00		 ld bc, FORTH_TRUE 
35c6			.lscont:  
35c6 c5					push bc 
35c7 e1					pop hl 
35c8			 
35c8					if DEBUG_FORTH_WORDS 
35c8						DMARK "LT1" 
35c8 f5				push af  
35c9 3a dd 35			ld a, (.dmark)  
35cc 32 6b ee			ld (debug_mark),a  
35cf 3a de 35			ld a, (.dmark+1)  
35d2 32 6c ee			ld (debug_mark+1),a  
35d5 3a df 35			ld a, (.dmark+2)  
35d8 32 6d ee			ld (debug_mark+2),a  
35db 18 03			jr .pastdmark  
35dd ..			.dmark: db "LT1"  
35e0 f1			.pastdmark: pop af  
35e1			endm  
# End of macro DMARK
35e1						CALLMONITOR 
35e1 cd 6f ee			call debug_vector  
35e4				endm  
# End of macro CALLMONITOR
35e4					endif 
35e4 cd 56 1c				call forth_push_numhl 
35e7			 
35e7					NEXTW 
35e7 c3 03 20			jp macro_next 
35ea				endm 
# End of macro NEXTW
35ea			.GT: 
35ea				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
35ea 30				db WORD_SYS_CORE+28             
35eb 53 36			dw .EQUAL            
35ed 02				db 1 + 1 
35ee .. 00			db ">",0              
35f0				endm 
# End of macro CWHEAD
35f0			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
35f0				; TODO add floating point number detection 
35f0					if DEBUG_FORTH_WORDS_KEY 
35f0						DMARK "GRT" 
35f0 f5				push af  
35f1 3a 05 36			ld a, (.dmark)  
35f4 32 6b ee			ld (debug_mark),a  
35f7 3a 06 36			ld a, (.dmark+1)  
35fa 32 6c ee			ld (debug_mark+1),a  
35fd 3a 07 36			ld a, (.dmark+2)  
3600 32 6d ee			ld (debug_mark+2),a  
3603 18 03			jr .pastdmark  
3605 ..			.dmark: db "GRT"  
3608 f1			.pastdmark: pop af  
3609			endm  
# End of macro DMARK
3609						CALLMONITOR 
3609 cd 6f ee			call debug_vector  
360c				endm  
# End of macro CALLMONITOR
360c					endif 
360c					FORTH_DSP 
360c cd 13 1e			call macro_forth_dsp 
360f				endm 
# End of macro FORTH_DSP
360f					;FORTH_DSP_VALUE 
360f 7e					ld a,(hl)	; get type of value on TOS 
3610 fe 02				cp DS_TYPE_INUM  
3612 28 00				jr z, .gt_inum 
3614			 
3614				if FORTH_ENABLE_FLOATMATH 
3614					jr .gt_done 
3614			 
3614				endif 
3614					 
3614			 
3614			.gt_inum: 
3614					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3614 cd 4d 1e			call macro_dsp_valuehl 
3617				endm 
# End of macro FORTH_DSP_VALUEHL
3617			 
3617 e5					push hl  ; u2 
3618			 
3618					; destroy value TOS 
3618			 
3618					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3618 cd 05 1f			call macro_forth_dsp_pop 
361b				endm 
# End of macro FORTH_DSP_POP
361b			 
361b			 
361b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
361b cd 4d 1e			call macro_dsp_valuehl 
361e				endm 
# End of macro FORTH_DSP_VALUEHL
361e			 
361e e5					push hl    ; u1 
361f			 
361f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
361f cd 05 1f			call macro_forth_dsp_pop 
3622				endm 
# End of macro FORTH_DSP_POP
3622			 
3622			 
3622 b7			 or a      ;clear carry flag 
3623 01 00 00		 ld bc, FORTH_FALSE 
3626 e1			  pop hl    ; u1 
3627 d1			  pop de    ; u2 
3628 ed 52		  sbc hl,de 
362a 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
362c			 
362c 01 01 00		 ld bc, FORTH_TRUE 
362f			.gtcont:  
362f c5					push bc 
3630 e1					pop hl 
3631			 
3631					if DEBUG_FORTH_WORDS 
3631						DMARK "GT1" 
3631 f5				push af  
3632 3a 46 36			ld a, (.dmark)  
3635 32 6b ee			ld (debug_mark),a  
3638 3a 47 36			ld a, (.dmark+1)  
363b 32 6c ee			ld (debug_mark+1),a  
363e 3a 48 36			ld a, (.dmark+2)  
3641 32 6d ee			ld (debug_mark+2),a  
3644 18 03			jr .pastdmark  
3646 ..			.dmark: db "GT1"  
3649 f1			.pastdmark: pop af  
364a			endm  
# End of macro DMARK
364a						CALLMONITOR 
364a cd 6f ee			call debug_vector  
364d				endm  
# End of macro CALLMONITOR
364d					endif 
364d cd 56 1c				call forth_push_numhl 
3650			 
3650					NEXTW 
3650 c3 03 20			jp macro_next 
3653				endm 
# End of macro NEXTW
3653			.EQUAL: 
3653				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3653 31				db WORD_SYS_CORE+29             
3654 be 36			dw .ENDLOGIC            
3656 02				db 1 + 1 
3657 .. 00			db "=",0              
3659				endm 
# End of macro CWHEAD
3659			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3659				; TODO add floating point number detection 
3659					if DEBUG_FORTH_WORDS_KEY 
3659						DMARK "EQ." 
3659 f5				push af  
365a 3a 6e 36			ld a, (.dmark)  
365d 32 6b ee			ld (debug_mark),a  
3660 3a 6f 36			ld a, (.dmark+1)  
3663 32 6c ee			ld (debug_mark+1),a  
3666 3a 70 36			ld a, (.dmark+2)  
3669 32 6d ee			ld (debug_mark+2),a  
366c 18 03			jr .pastdmark  
366e ..			.dmark: db "EQ."  
3671 f1			.pastdmark: pop af  
3672			endm  
# End of macro DMARK
3672						CALLMONITOR 
3672 cd 6f ee			call debug_vector  
3675				endm  
# End of macro CALLMONITOR
3675					endif 
3675					FORTH_DSP 
3675 cd 13 1e			call macro_forth_dsp 
3678				endm 
# End of macro FORTH_DSP
3678					;v5 FORTH_DSP_VALUE 
3678 7e					ld a,(hl)	; get type of value on TOS 
3679 fe 02				cp DS_TYPE_INUM  
367b 28 00				jr z, .eq_inum 
367d			 
367d				if FORTH_ENABLE_FLOATMATH 
367d					jr .eq_done 
367d			 
367d				endif 
367d					 
367d			 
367d			.eq_inum: 
367d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
367d cd 4d 1e			call macro_dsp_valuehl 
3680				endm 
# End of macro FORTH_DSP_VALUEHL
3680			 
3680 e5					push hl 
3681			 
3681					; destroy value TOS 
3681			 
3681					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3681 cd 05 1f			call macro_forth_dsp_pop 
3684				endm 
# End of macro FORTH_DSP_POP
3684			 
3684			 
3684					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3684 cd 4d 1e			call macro_dsp_valuehl 
3687				endm 
# End of macro FORTH_DSP_VALUEHL
3687			 
3687					; one value on hl get other one back 
3687			 
3687 e5					push hl 
3688			 
3688					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3688 cd 05 1f			call macro_forth_dsp_pop 
368b				endm 
# End of macro FORTH_DSP_POP
368b			 
368b 0e 00				ld c, FORTH_FALSE 
368d			 
368d e1					pop hl 
368e d1					pop de 
368f			 
368f 7b					ld a, e 
3690 bd					cp l 
3691			 
3691 20 06				jr nz, .eq_done 
3693			 
3693 7a					ld a, d 
3694 bc					cp h 
3695			 
3695 20 02				jr nz, .eq_done 
3697			 
3697 0e 01				ld c, FORTH_TRUE 
3699					 
3699			 
3699			 
3699			.eq_done: 
3699			 
3699					; TODO push value back onto stack for another op etc 
3699			 
3699 26 00				ld h, 0 
369b 69					ld l, c 
369c					if DEBUG_FORTH_WORDS 
369c						DMARK "EQ1" 
369c f5				push af  
369d 3a b1 36			ld a, (.dmark)  
36a0 32 6b ee			ld (debug_mark),a  
36a3 3a b2 36			ld a, (.dmark+1)  
36a6 32 6c ee			ld (debug_mark+1),a  
36a9 3a b3 36			ld a, (.dmark+2)  
36ac 32 6d ee			ld (debug_mark+2),a  
36af 18 03			jr .pastdmark  
36b1 ..			.dmark: db "EQ1"  
36b4 f1			.pastdmark: pop af  
36b5			endm  
# End of macro DMARK
36b5						CALLMONITOR 
36b5 cd 6f ee			call debug_vector  
36b8				endm  
# End of macro CALLMONITOR
36b8					endif 
36b8 cd 56 1c				call forth_push_numhl 
36bb			 
36bb					NEXTW 
36bb c3 03 20			jp macro_next 
36be				endm 
# End of macro NEXTW
36be			 
36be			 
36be			.ENDLOGIC: 
36be			; eof 
36be			 
36be			 
# End of file forth_words_logic.asm
36be			include "forth_words_maths.asm" 
36be			 
36be			; | ## Maths Words 
36be			 
36be			.PLUS:	 
36be				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
36be 15				db WORD_SYS_CORE+1             
36bf 1c 37			dw .NEG            
36c1 02				db 1 + 1 
36c2 .. 00			db "+",0              
36c4				endm 
# End of macro CWHEAD
36c4			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
36c4					if DEBUG_FORTH_WORDS_KEY 
36c4						DMARK "PLU" 
36c4 f5				push af  
36c5 3a d9 36			ld a, (.dmark)  
36c8 32 6b ee			ld (debug_mark),a  
36cb 3a da 36			ld a, (.dmark+1)  
36ce 32 6c ee			ld (debug_mark+1),a  
36d1 3a db 36			ld a, (.dmark+2)  
36d4 32 6d ee			ld (debug_mark+2),a  
36d7 18 03			jr .pastdmark  
36d9 ..			.dmark: db "PLU"  
36dc f1			.pastdmark: pop af  
36dd			endm  
# End of macro DMARK
36dd						CALLMONITOR 
36dd cd 6f ee			call debug_vector  
36e0				endm  
# End of macro CALLMONITOR
36e0					endif 
36e0					; add top two values and push back result 
36e0			 
36e0					;for v5 FORTH_DSP_VALUE 
36e0					FORTH_DSP 
36e0 cd 13 1e			call macro_forth_dsp 
36e3				endm 
# End of macro FORTH_DSP
36e3 7e					ld a,(hl)	; get type of value on TOS 
36e4 fe 02				cp DS_TYPE_INUM  
36e6 28 03				jr z, .dot_inum 
36e8			 
36e8					NEXTW 
36e8 c3 03 20			jp macro_next 
36eb				endm 
# End of macro NEXTW
36eb			 
36eb			; float maths 
36eb			 
36eb				if FORTH_ENABLE_FLOATMATH 
36eb						inc hl      ; now at start of numeric as string 
36eb			 
36eb					if DEBUG_FORTH_MATHS 
36eb						DMARK "ADD" 
36eb				CALLMONITOR 
36eb					endif 
36eb			 
36eb					;ld ix, hl 
36eb					call CON 
36eb			 
36eb			 
36eb					push hl 
36eb					 
36eb					 
36eb			 
36eb						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
36eb			 
36eb					; get next number 
36eb			 
36eb						FORTH_DSP_VALUE 
36eb			 
36eb						inc hl      ; now at start of numeric as string 
36eb			 
36eb					;ld ix, hl 
36eb					call CON 
36eb			 
36eb					push hl 
36eb			 
36eb			 
36eb						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36eb			 
36eb						; TODO do add 
36eb			 
36eb						call IADD 
36eb			 
36eb						; TODO get result back as ascii 
36eb			 
36eb						; TODO push result  
36eb			 
36eb			 
36eb			 
36eb						jr .dot_done 
36eb				endif 
36eb			 
36eb			.dot_inum: 
36eb			 
36eb			 
36eb					if DEBUG_FORTH_DOT 
36eb						DMARK "+IT" 
36eb f5				push af  
36ec 3a 00 37			ld a, (.dmark)  
36ef 32 6b ee			ld (debug_mark),a  
36f2 3a 01 37			ld a, (.dmark+1)  
36f5 32 6c ee			ld (debug_mark+1),a  
36f8 3a 02 37			ld a, (.dmark+2)  
36fb 32 6d ee			ld (debug_mark+2),a  
36fe 18 03			jr .pastdmark  
3700 ..			.dmark: db "+IT"  
3703 f1			.pastdmark: pop af  
3704			endm  
# End of macro DMARK
3704				CALLMONITOR 
3704 cd 6f ee			call debug_vector  
3707				endm  
# End of macro CALLMONITOR
3707					endif 
3707			 
3707					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3707 cd 4d 1e			call macro_dsp_valuehl 
370a				endm 
# End of macro FORTH_DSP_VALUEHL
370a			 
370a				; TODO add floating point number detection 
370a			 
370a e5					push hl 
370b			 
370b					; destroy value TOS 
370b			 
370b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
370b cd 05 1f			call macro_forth_dsp_pop 
370e				endm 
# End of macro FORTH_DSP_POP
370e			 
370e			 
370e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
370e cd 4d 1e			call macro_dsp_valuehl 
3711				endm 
# End of macro FORTH_DSP_VALUEHL
3711			 
3711					; one value on hl get other one back 
3711			 
3711 d1					pop de 
3712			 
3712					; do the add 
3712			 
3712 19					add hl,de 
3713			 
3713					; save it 
3713			 
3713			;		push hl	 
3713			 
3713					; 
3713			 
3713					; destroy value TOS 
3713			 
3713					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3713 cd 05 1f			call macro_forth_dsp_pop 
3716				endm 
# End of macro FORTH_DSP_POP
3716			 
3716					; TODO push value back onto stack for another op etc 
3716			 
3716			;		pop hl 
3716			 
3716			.dot_done: 
3716 cd 56 1c				call forth_push_numhl 
3719			 
3719					NEXTW 
3719 c3 03 20			jp macro_next 
371c				endm 
# End of macro NEXTW
371c			.NEG: 
371c			 
371c				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
371c 17				db WORD_SYS_CORE+3             
371d 5f 37			dw .DIV            
371f 02				db 1 + 1 
3720 .. 00			db "-",0              
3722				endm 
# End of macro CWHEAD
3722			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3722					if DEBUG_FORTH_WORDS_KEY 
3722						DMARK "SUB" 
3722 f5				push af  
3723 3a 37 37			ld a, (.dmark)  
3726 32 6b ee			ld (debug_mark),a  
3729 3a 38 37			ld a, (.dmark+1)  
372c 32 6c ee			ld (debug_mark+1),a  
372f 3a 39 37			ld a, (.dmark+2)  
3732 32 6d ee			ld (debug_mark+2),a  
3735 18 03			jr .pastdmark  
3737 ..			.dmark: db "SUB"  
373a f1			.pastdmark: pop af  
373b			endm  
# End of macro DMARK
373b						CALLMONITOR 
373b cd 6f ee			call debug_vector  
373e				endm  
# End of macro CALLMONITOR
373e					endif 
373e			 
373e			 
373e				; TODO add floating point number detection 
373e					; v5 FORTH_DSP_VALUE 
373e					FORTH_DSP 
373e cd 13 1e			call macro_forth_dsp 
3741				endm 
# End of macro FORTH_DSP
3741 7e					ld a,(hl)	; get type of value on TOS 
3742 fe 02				cp DS_TYPE_INUM  
3744 28 03				jr z, .neg_inum 
3746			 
3746					NEXTW 
3746 c3 03 20			jp macro_next 
3749				endm 
# End of macro NEXTW
3749			 
3749			; float maths 
3749			 
3749				if FORTH_ENABLE_FLOATMATH 
3749					jr .neg_done 
3749			 
3749				endif 
3749					 
3749			 
3749			.neg_inum: 
3749					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3749 cd 4d 1e			call macro_dsp_valuehl 
374c				endm 
# End of macro FORTH_DSP_VALUEHL
374c			 
374c e5					push hl 
374d			 
374d					; destroy value TOS 
374d			 
374d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
374d cd 05 1f			call macro_forth_dsp_pop 
3750				endm 
# End of macro FORTH_DSP_POP
3750			 
3750			 
3750					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3750 cd 4d 1e			call macro_dsp_valuehl 
3753				endm 
# End of macro FORTH_DSP_VALUEHL
3753			 
3753					; one value on hl get other one back 
3753			 
3753 d1					pop de 
3754			 
3754					; do the sub 
3754			;		ex de, hl 
3754			 
3754 ed 52				sbc hl,de 
3756			 
3756					; save it 
3756			 
3756			;		push hl	 
3756			 
3756					; 
3756			 
3756					; destroy value TOS 
3756			 
3756					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3756 cd 05 1f			call macro_forth_dsp_pop 
3759				endm 
# End of macro FORTH_DSP_POP
3759			 
3759					; TODO push value back onto stack for another op etc 
3759			 
3759			;		pop hl 
3759			 
3759 cd 56 1c				call forth_push_numhl 
375c			.neg_done: 
375c			 
375c					NEXTW 
375c c3 03 20			jp macro_next 
375f				endm 
# End of macro NEXTW
375f			.DIV: 
375f				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
375f 18				db WORD_SYS_CORE+4             
3760 ac 37			dw .MUL            
3762 02				db 1 + 1 
3763 .. 00			db "/",0              
3765				endm 
# End of macro CWHEAD
3765			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3765					if DEBUG_FORTH_WORDS_KEY 
3765						DMARK "DIV" 
3765 f5				push af  
3766 3a 7a 37			ld a, (.dmark)  
3769 32 6b ee			ld (debug_mark),a  
376c 3a 7b 37			ld a, (.dmark+1)  
376f 32 6c ee			ld (debug_mark+1),a  
3772 3a 7c 37			ld a, (.dmark+2)  
3775 32 6d ee			ld (debug_mark+2),a  
3778 18 03			jr .pastdmark  
377a ..			.dmark: db "DIV"  
377d f1			.pastdmark: pop af  
377e			endm  
# End of macro DMARK
377e						CALLMONITOR 
377e cd 6f ee			call debug_vector  
3781				endm  
# End of macro CALLMONITOR
3781					endif 
3781				; TODO add floating point number detection 
3781					; v5 FORTH_DSP_VALUE 
3781					FORTH_DSP 
3781 cd 13 1e			call macro_forth_dsp 
3784				endm 
# End of macro FORTH_DSP
3784 7e					ld a,(hl)	; get type of value on TOS 
3785 fe 02				cp DS_TYPE_INUM  
3787 28 03				jr z, .div_inum 
3789			 
3789				if FORTH_ENABLE_FLOATMATH 
3789					jr .div_done 
3789			 
3789				endif 
3789					NEXTW 
3789 c3 03 20			jp macro_next 
378c				endm 
# End of macro NEXTW
378c			.div_inum: 
378c			 
378c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
378c cd 4d 1e			call macro_dsp_valuehl 
378f				endm 
# End of macro FORTH_DSP_VALUEHL
378f			 
378f e5					push hl    ; to go to bc 
3790			 
3790					; destroy value TOS 
3790			 
3790					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3790 cd 05 1f			call macro_forth_dsp_pop 
3793				endm 
# End of macro FORTH_DSP_POP
3793			 
3793			 
3793					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3793 cd 4d 1e			call macro_dsp_valuehl 
3796				endm 
# End of macro FORTH_DSP_VALUEHL
3796			 
3796					; hl to go to de 
3796			 
3796 e5					push hl 
3797			 
3797 c1					pop bc 
3798 d1					pop de		 
3799			 
3799			 
3799					if DEBUG_FORTH_MATHS 
3799						DMARK "DIV" 
3799				CALLMONITOR 
3799					endif 
3799					; one value on hl but move to a get other one back 
3799			 
3799			        
3799 cd 44 0d			call Div16 
379c			 
379c			;	push af	 
379c e5				push hl 
379d c5				push bc 
379e			 
379e					if DEBUG_FORTH_MATHS 
379e						DMARK "DI1" 
379e				CALLMONITOR 
379e					endif 
379e			 
379e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
379e cd 05 1f			call macro_forth_dsp_pop 
37a1				endm 
# End of macro FORTH_DSP_POP
37a1			 
37a1			 
37a1			 
37a1 e1					pop hl    ; result 
37a2			 
37a2 cd 56 1c				call forth_push_numhl 
37a5			 
37a5 e1					pop hl    ; reminder 
37a6			;		ld h,0 
37a6			;		ld l,d 
37a6			 
37a6 cd 56 1c				call forth_push_numhl 
37a9			.div_done: 
37a9					NEXTW 
37a9 c3 03 20			jp macro_next 
37ac				endm 
# End of macro NEXTW
37ac			.MUL: 
37ac				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
37ac 19				db WORD_SYS_CORE+5             
37ad f1 37			dw .MIN            
37af 02				db 1 + 1 
37b0 .. 00			db "*",0              
37b2				endm 
# End of macro CWHEAD
37b2			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
37b2				; TODO add floating point number detection 
37b2					if DEBUG_FORTH_WORDS_KEY 
37b2						DMARK "MUL" 
37b2 f5				push af  
37b3 3a c7 37			ld a, (.dmark)  
37b6 32 6b ee			ld (debug_mark),a  
37b9 3a c8 37			ld a, (.dmark+1)  
37bc 32 6c ee			ld (debug_mark+1),a  
37bf 3a c9 37			ld a, (.dmark+2)  
37c2 32 6d ee			ld (debug_mark+2),a  
37c5 18 03			jr .pastdmark  
37c7 ..			.dmark: db "MUL"  
37ca f1			.pastdmark: pop af  
37cb			endm  
# End of macro DMARK
37cb						CALLMONITOR 
37cb cd 6f ee			call debug_vector  
37ce				endm  
# End of macro CALLMONITOR
37ce					endif 
37ce					FORTH_DSP 
37ce cd 13 1e			call macro_forth_dsp 
37d1				endm 
# End of macro FORTH_DSP
37d1					; v5 FORTH_DSP_VALUE 
37d1 7e					ld a,(hl)	; get type of value on TOS 
37d2 fe 02				cp DS_TYPE_INUM  
37d4 28 03				jr z, .mul_inum 
37d6			 
37d6				if FORTH_ENABLE_FLOATMATH 
37d6					jr .mul_done 
37d6			 
37d6				endif 
37d6			 
37d6					NEXTW 
37d6 c3 03 20			jp macro_next 
37d9				endm 
# End of macro NEXTW
37d9			.mul_inum:	 
37d9			 
37d9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37d9 cd 4d 1e			call macro_dsp_valuehl 
37dc				endm 
# End of macro FORTH_DSP_VALUEHL
37dc			 
37dc e5					push hl 
37dd			 
37dd					; destroy value TOS 
37dd			 
37dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37dd cd 05 1f			call macro_forth_dsp_pop 
37e0				endm 
# End of macro FORTH_DSP_POP
37e0			 
37e0			 
37e0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37e0 cd 4d 1e			call macro_dsp_valuehl 
37e3				endm 
# End of macro FORTH_DSP_VALUEHL
37e3			 
37e3					; one value on hl but move to a get other one back 
37e3			 
37e3 7d					ld a, l 
37e4			 
37e4 d1					pop de 
37e5			 
37e5					; do the mull 
37e5			;		ex de, hl 
37e5			 
37e5 cd 6a 0d				call Mult16 
37e8					; save it 
37e8			 
37e8			;		push hl	 
37e8			 
37e8					; 
37e8			 
37e8					; destroy value TOS 
37e8			 
37e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37e8 cd 05 1f			call macro_forth_dsp_pop 
37eb				endm 
# End of macro FORTH_DSP_POP
37eb			 
37eb					; TODO push value back onto stack for another op etc 
37eb			 
37eb			;		pop hl 
37eb			 
37eb cd 56 1c				call forth_push_numhl 
37ee			 
37ee			.mul_done: 
37ee					NEXTW 
37ee c3 03 20			jp macro_next 
37f1				endm 
# End of macro NEXTW
37f1			 
37f1			 
37f1			 
37f1			 
37f1			.MIN: 
37f1				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
37f1 49				db WORD_SYS_CORE+53             
37f2 72 38			dw .MAX            
37f4 04				db 3 + 1 
37f5 .. 00			db "MIN",0              
37f9				endm 
# End of macro CWHEAD
37f9			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
37f9					if DEBUG_FORTH_WORDS_KEY 
37f9						DMARK "MIN" 
37f9 f5				push af  
37fa 3a 0e 38			ld a, (.dmark)  
37fd 32 6b ee			ld (debug_mark),a  
3800 3a 0f 38			ld a, (.dmark+1)  
3803 32 6c ee			ld (debug_mark+1),a  
3806 3a 10 38			ld a, (.dmark+2)  
3809 32 6d ee			ld (debug_mark+2),a  
380c 18 03			jr .pastdmark  
380e ..			.dmark: db "MIN"  
3811 f1			.pastdmark: pop af  
3812			endm  
# End of macro DMARK
3812						CALLMONITOR 
3812 cd 6f ee			call debug_vector  
3815				endm  
# End of macro CALLMONITOR
3815					endif 
3815					; get u2 
3815			 
3815					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3815 cd 4d 1e			call macro_dsp_valuehl 
3818				endm 
# End of macro FORTH_DSP_VALUEHL
3818			 
3818 e5					push hl   ; u2 
3819			 
3819					; destroy value TOS 
3819			 
3819					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3819 cd 05 1f			call macro_forth_dsp_pop 
381c				endm 
# End of macro FORTH_DSP_POP
381c			 
381c					; get u1 
381c			 
381c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
381c cd 4d 1e			call macro_dsp_valuehl 
381f				endm 
# End of macro FORTH_DSP_VALUEHL
381f			 
381f e5					push hl  ; u1 
3820			 
3820					; destroy value TOS 
3820			 
3820					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3820 cd 05 1f			call macro_forth_dsp_pop 
3823				endm 
# End of macro FORTH_DSP_POP
3823			 
3823 b7			 or a      ;clear carry flag 
3824 e1			  pop hl    ; u1 
3825 d1			  pop de    ; u2 
3826 e5				push hl   ; saved in case hl is lowest 
3827 ed 52		  sbc hl,de 
3829 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
382b			 
382b e1				pop hl 
382c					if DEBUG_FORTH_WORDS 
382c						DMARK "MIN" 
382c f5				push af  
382d 3a 41 38			ld a, (.dmark)  
3830 32 6b ee			ld (debug_mark),a  
3833 3a 42 38			ld a, (.dmark+1)  
3836 32 6c ee			ld (debug_mark+1),a  
3839 3a 43 38			ld a, (.dmark+2)  
383c 32 6d ee			ld (debug_mark+2),a  
383f 18 03			jr .pastdmark  
3841 ..			.dmark: db "MIN"  
3844 f1			.pastdmark: pop af  
3845			endm  
# End of macro DMARK
3845						CALLMONITOR 
3845 cd 6f ee			call debug_vector  
3848				endm  
# End of macro CALLMONITOR
3848					endif 
3848 cd 56 1c				call forth_push_numhl 
384b			 
384b				       NEXTW 
384b c3 03 20			jp macro_next 
384e				endm 
# End of macro NEXTW
384e			 
384e			.mincont:  
384e c1				pop bc   ; tidy up 
384f eb				ex de , hl  
3850					if DEBUG_FORTH_WORDS 
3850						DMARK "MI1" 
3850 f5				push af  
3851 3a 65 38			ld a, (.dmark)  
3854 32 6b ee			ld (debug_mark),a  
3857 3a 66 38			ld a, (.dmark+1)  
385a 32 6c ee			ld (debug_mark+1),a  
385d 3a 67 38			ld a, (.dmark+2)  
3860 32 6d ee			ld (debug_mark+2),a  
3863 18 03			jr .pastdmark  
3865 ..			.dmark: db "MI1"  
3868 f1			.pastdmark: pop af  
3869			endm  
# End of macro DMARK
3869						CALLMONITOR 
3869 cd 6f ee			call debug_vector  
386c				endm  
# End of macro CALLMONITOR
386c					endif 
386c cd 56 1c				call forth_push_numhl 
386f			 
386f				       NEXTW 
386f c3 03 20			jp macro_next 
3872				endm 
# End of macro NEXTW
3872			.MAX: 
3872				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3872 4a				db WORD_SYS_CORE+54             
3873 f3 38			dw .RND16            
3875 04				db 3 + 1 
3876 .. 00			db "MAX",0              
387a				endm 
# End of macro CWHEAD
387a			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
387a					if DEBUG_FORTH_WORDS_KEY 
387a						DMARK "MAX" 
387a f5				push af  
387b 3a 8f 38			ld a, (.dmark)  
387e 32 6b ee			ld (debug_mark),a  
3881 3a 90 38			ld a, (.dmark+1)  
3884 32 6c ee			ld (debug_mark+1),a  
3887 3a 91 38			ld a, (.dmark+2)  
388a 32 6d ee			ld (debug_mark+2),a  
388d 18 03			jr .pastdmark  
388f ..			.dmark: db "MAX"  
3892 f1			.pastdmark: pop af  
3893			endm  
# End of macro DMARK
3893						CALLMONITOR 
3893 cd 6f ee			call debug_vector  
3896				endm  
# End of macro CALLMONITOR
3896					endif 
3896					; get u2 
3896			 
3896					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3896 cd 4d 1e			call macro_dsp_valuehl 
3899				endm 
# End of macro FORTH_DSP_VALUEHL
3899			 
3899 e5					push hl   ; u2 
389a			 
389a					; destroy value TOS 
389a			 
389a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
389a cd 05 1f			call macro_forth_dsp_pop 
389d				endm 
# End of macro FORTH_DSP_POP
389d			 
389d					; get u1 
389d			 
389d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
389d cd 4d 1e			call macro_dsp_valuehl 
38a0				endm 
# End of macro FORTH_DSP_VALUEHL
38a0			 
38a0 e5					push hl  ; u1 
38a1			 
38a1					; destroy value TOS 
38a1			 
38a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38a1 cd 05 1f			call macro_forth_dsp_pop 
38a4				endm 
# End of macro FORTH_DSP_POP
38a4			 
38a4 b7			 or a      ;clear carry flag 
38a5 e1			  pop hl    ; u1 
38a6 d1			  pop de    ; u2 
38a7 e5				push hl   ; saved in case hl is lowest 
38a8 ed 52		  sbc hl,de 
38aa 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
38ac			 
38ac e1				pop hl 
38ad					if DEBUG_FORTH_WORDS 
38ad						DMARK "MAX" 
38ad f5				push af  
38ae 3a c2 38			ld a, (.dmark)  
38b1 32 6b ee			ld (debug_mark),a  
38b4 3a c3 38			ld a, (.dmark+1)  
38b7 32 6c ee			ld (debug_mark+1),a  
38ba 3a c4 38			ld a, (.dmark+2)  
38bd 32 6d ee			ld (debug_mark+2),a  
38c0 18 03			jr .pastdmark  
38c2 ..			.dmark: db "MAX"  
38c5 f1			.pastdmark: pop af  
38c6			endm  
# End of macro DMARK
38c6						CALLMONITOR 
38c6 cd 6f ee			call debug_vector  
38c9				endm  
# End of macro CALLMONITOR
38c9					endif 
38c9 cd 56 1c				call forth_push_numhl 
38cc			 
38cc				       NEXTW 
38cc c3 03 20			jp macro_next 
38cf				endm 
# End of macro NEXTW
38cf			 
38cf			.maxcont:  
38cf c1				pop bc   ; tidy up 
38d0 eb				ex de , hl  
38d1					if DEBUG_FORTH_WORDS 
38d1						DMARK "MA1" 
38d1 f5				push af  
38d2 3a e6 38			ld a, (.dmark)  
38d5 32 6b ee			ld (debug_mark),a  
38d8 3a e7 38			ld a, (.dmark+1)  
38db 32 6c ee			ld (debug_mark+1),a  
38de 3a e8 38			ld a, (.dmark+2)  
38e1 32 6d ee			ld (debug_mark+2),a  
38e4 18 03			jr .pastdmark  
38e6 ..			.dmark: db "MA1"  
38e9 f1			.pastdmark: pop af  
38ea			endm  
# End of macro DMARK
38ea						CALLMONITOR 
38ea cd 6f ee			call debug_vector  
38ed				endm  
# End of macro CALLMONITOR
38ed					endif 
38ed cd 56 1c				call forth_push_numhl 
38f0				       NEXTW 
38f0 c3 03 20			jp macro_next 
38f3				endm 
# End of macro NEXTW
38f3			 
38f3			.RND16: 
38f3				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
38f3 4e				db WORD_SYS_CORE+58             
38f4 22 39			dw .RND8            
38f6 06				db 5 + 1 
38f7 .. 00			db "RND16",0              
38fd				endm 
# End of macro CWHEAD
38fd			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
38fd					if DEBUG_FORTH_WORDS_KEY 
38fd						DMARK "R16" 
38fd f5				push af  
38fe 3a 12 39			ld a, (.dmark)  
3901 32 6b ee			ld (debug_mark),a  
3904 3a 13 39			ld a, (.dmark+1)  
3907 32 6c ee			ld (debug_mark+1),a  
390a 3a 14 39			ld a, (.dmark+2)  
390d 32 6d ee			ld (debug_mark+2),a  
3910 18 03			jr .pastdmark  
3912 ..			.dmark: db "R16"  
3915 f1			.pastdmark: pop af  
3916			endm  
# End of macro DMARK
3916						CALLMONITOR 
3916 cd 6f ee			call debug_vector  
3919				endm  
# End of macro CALLMONITOR
3919					endif 
3919 cd 0e 0d				call prng16  
391c cd 56 1c				call forth_push_numhl 
391f				       NEXTW 
391f c3 03 20			jp macro_next 
3922				endm 
# End of macro NEXTW
3922			.RND8: 
3922				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3922 60				db WORD_SYS_CORE+76             
3923 57 39			dw .RND            
3925 05				db 4 + 1 
3926 .. 00			db "RND8",0              
392b				endm 
# End of macro CWHEAD
392b			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
392b					if DEBUG_FORTH_WORDS_KEY 
392b						DMARK "RN8" 
392b f5				push af  
392c 3a 40 39			ld a, (.dmark)  
392f 32 6b ee			ld (debug_mark),a  
3932 3a 41 39			ld a, (.dmark+1)  
3935 32 6c ee			ld (debug_mark+1),a  
3938 3a 42 39			ld a, (.dmark+2)  
393b 32 6d ee			ld (debug_mark+2),a  
393e 18 03			jr .pastdmark  
3940 ..			.dmark: db "RN8"  
3943 f1			.pastdmark: pop af  
3944			endm  
# End of macro DMARK
3944						CALLMONITOR 
3944 cd 6f ee			call debug_vector  
3947				endm  
# End of macro CALLMONITOR
3947					endif 
3947 2a a9 eb				ld hl,(xrandc) 
394a 23					inc hl 
394b cd 28 0d				call xrnd 
394e 6f					ld l,a	 
394f 26 00				ld h,0 
3951 cd 56 1c				call forth_push_numhl 
3954				       NEXTW 
3954 c3 03 20			jp macro_next 
3957				endm 
# End of macro NEXTW
3957			.RND: 
3957				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3957 60				db WORD_SYS_CORE+76             
3958 5d 3a			dw .ENDMATHS            
395a 04				db 3 + 1 
395b .. 00			db "RND",0              
395f				endm 
# End of macro CWHEAD
395f			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
395f			 
395f					if DEBUG_FORTH_WORDS_KEY 
395f						DMARK "RND" 
395f f5				push af  
3960 3a 74 39			ld a, (.dmark)  
3963 32 6b ee			ld (debug_mark),a  
3966 3a 75 39			ld a, (.dmark+1)  
3969 32 6c ee			ld (debug_mark+1),a  
396c 3a 76 39			ld a, (.dmark+2)  
396f 32 6d ee			ld (debug_mark+2),a  
3972 18 03			jr .pastdmark  
3974 ..			.dmark: db "RND"  
3977 f1			.pastdmark: pop af  
3978			endm  
# End of macro DMARK
3978						CALLMONITOR 
3978 cd 6f ee			call debug_vector  
397b				endm  
# End of macro CALLMONITOR
397b					endif 
397b					 
397b					FORTH_DSP_VALUEHL    ; upper range 
397b cd 4d 1e			call macro_dsp_valuehl 
397e				endm 
# End of macro FORTH_DSP_VALUEHL
397e			 
397e 22 ad eb				ld (LFSRSeed), hl	 
3981			 
3981					if DEBUG_FORTH_WORDS 
3981						DMARK "RN1" 
3981 f5				push af  
3982 3a 96 39			ld a, (.dmark)  
3985 32 6b ee			ld (debug_mark),a  
3988 3a 97 39			ld a, (.dmark+1)  
398b 32 6c ee			ld (debug_mark+1),a  
398e 3a 98 39			ld a, (.dmark+2)  
3991 32 6d ee			ld (debug_mark+2),a  
3994 18 03			jr .pastdmark  
3996 ..			.dmark: db "RN1"  
3999 f1			.pastdmark: pop af  
399a			endm  
# End of macro DMARK
399a						CALLMONITOR 
399a cd 6f ee			call debug_vector  
399d				endm  
# End of macro CALLMONITOR
399d					endif 
399d					FORTH_DSP_POP 
399d cd 05 1f			call macro_forth_dsp_pop 
39a0				endm 
# End of macro FORTH_DSP_POP
39a0			 
39a0					FORTH_DSP_VALUEHL    ; low range 
39a0 cd 4d 1e			call macro_dsp_valuehl 
39a3				endm 
# End of macro FORTH_DSP_VALUEHL
39a3			 
39a3					if DEBUG_FORTH_WORDS 
39a3						DMARK "RN2" 
39a3 f5				push af  
39a4 3a b8 39			ld a, (.dmark)  
39a7 32 6b ee			ld (debug_mark),a  
39aa 3a b9 39			ld a, (.dmark+1)  
39ad 32 6c ee			ld (debug_mark+1),a  
39b0 3a ba 39			ld a, (.dmark+2)  
39b3 32 6d ee			ld (debug_mark+2),a  
39b6 18 03			jr .pastdmark  
39b8 ..			.dmark: db "RN2"  
39bb f1			.pastdmark: pop af  
39bc			endm  
# End of macro DMARK
39bc						CALLMONITOR 
39bc cd 6f ee			call debug_vector  
39bf				endm  
# End of macro CALLMONITOR
39bf					endif 
39bf 22 af eb				ld (LFSRSeed+2), hl 
39c2			 
39c2					FORTH_DSP_POP 
39c2 cd 05 1f			call macro_forth_dsp_pop 
39c5				endm 
# End of macro FORTH_DSP_POP
39c5			 
39c5 e5					push hl 
39c6			 
39c6 e1			.inrange:	pop hl 
39c7 cd 0e 0d				call prng16  
39ca					if DEBUG_FORTH_WORDS 
39ca						DMARK "RN3" 
39ca f5				push af  
39cb 3a df 39			ld a, (.dmark)  
39ce 32 6b ee			ld (debug_mark),a  
39d1 3a e0 39			ld a, (.dmark+1)  
39d4 32 6c ee			ld (debug_mark+1),a  
39d7 3a e1 39			ld a, (.dmark+2)  
39da 32 6d ee			ld (debug_mark+2),a  
39dd 18 03			jr .pastdmark  
39df ..			.dmark: db "RN3"  
39e2 f1			.pastdmark: pop af  
39e3			endm  
# End of macro DMARK
39e3						CALLMONITOR 
39e3 cd 6f ee			call debug_vector  
39e6				endm  
# End of macro CALLMONITOR
39e6					endif 
39e6					 
39e6					; if the range is 8bit knock out the high byte 
39e6			 
39e6 ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
39ea			 
39ea 3e 00				ld a, 0 
39ec ba					cp d  
39ed 20 1e				jr nz, .hirange 
39ef 26 00				ld h, 0   ; knock it down to 8bit 
39f1			 
39f1					if DEBUG_FORTH_WORDS 
39f1						DMARK "RNk" 
39f1 f5				push af  
39f2 3a 06 3a			ld a, (.dmark)  
39f5 32 6b ee			ld (debug_mark),a  
39f8 3a 07 3a			ld a, (.dmark+1)  
39fb 32 6c ee			ld (debug_mark+1),a  
39fe 3a 08 3a			ld a, (.dmark+2)  
3a01 32 6d ee			ld (debug_mark+2),a  
3a04 18 03			jr .pastdmark  
3a06 ..			.dmark: db "RNk"  
3a09 f1			.pastdmark: pop af  
3a0a			endm  
# End of macro DMARK
3a0a						CALLMONITOR 
3a0a cd 6f ee			call debug_vector  
3a0d				endm  
# End of macro CALLMONITOR
3a0d					endif 
3a0d			.hirange:   
3a0d e5					push hl  
3a0e b7					or a  
3a0f ed 52		                sbc hl, de 
3a11			 
3a11					;call cmp16 
3a11			 
3a11 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3a13 e1					pop hl 
3a14 e5					push hl 
3a15			 
3a15					if DEBUG_FORTH_WORDS 
3a15						DMARK "RN4" 
3a15 f5				push af  
3a16 3a 2a 3a			ld a, (.dmark)  
3a19 32 6b ee			ld (debug_mark),a  
3a1c 3a 2b 3a			ld a, (.dmark+1)  
3a1f 32 6c ee			ld (debug_mark+1),a  
3a22 3a 2c 3a			ld a, (.dmark+2)  
3a25 32 6d ee			ld (debug_mark+2),a  
3a28 18 03			jr .pastdmark  
3a2a ..			.dmark: db "RN4"  
3a2d f1			.pastdmark: pop af  
3a2e			endm  
# End of macro DMARK
3a2e						CALLMONITOR 
3a2e cd 6f ee			call debug_vector  
3a31				endm  
# End of macro CALLMONITOR
3a31					endif 
3a31 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
3a35					;call cmp16 
3a35				 
3a35 b7					or a  
3a36 ed 52		                sbc hl, de 
3a38 38 8c				jr c, .inrange 
3a3a			 
3a3a e1					pop hl 
3a3b					 
3a3b					if DEBUG_FORTH_WORDS 
3a3b						DMARK "RNd" 
3a3b f5				push af  
3a3c 3a 50 3a			ld a, (.dmark)  
3a3f 32 6b ee			ld (debug_mark),a  
3a42 3a 51 3a			ld a, (.dmark+1)  
3a45 32 6c ee			ld (debug_mark+1),a  
3a48 3a 52 3a			ld a, (.dmark+2)  
3a4b 32 6d ee			ld (debug_mark+2),a  
3a4e 18 03			jr .pastdmark  
3a50 ..			.dmark: db "RNd"  
3a53 f1			.pastdmark: pop af  
3a54			endm  
# End of macro DMARK
3a54						CALLMONITOR 
3a54 cd 6f ee			call debug_vector  
3a57				endm  
# End of macro CALLMONITOR
3a57					endif 
3a57			 
3a57			 
3a57 cd 56 1c				call forth_push_numhl 
3a5a				       NEXTW 
3a5a c3 03 20			jp macro_next 
3a5d				endm 
# End of macro NEXTW
3a5d			 
3a5d			.ENDMATHS: 
3a5d			 
3a5d			; eof 
3a5d			 
# End of file forth_words_maths.asm
3a5d			include "forth_words_display.asm" 
3a5d			 
3a5d			; | ## Display Words 
3a5d			 
3a5d			.ACT: 
3a5d			 
3a5d				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3a5d 62				db WORD_SYS_CORE+78             
3a5e a9 3a			dw .INFO            
3a60 07				db 6 + 1 
3a61 .. 00			db "ACTIVE",0              
3a68				endm 
# End of macro CWHEAD
3a68			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3a68			;  
3a68			; | | e.g. $ff $00 do active . $01 pause loop 
3a68			 
3a68					if DEBUG_FORTH_WORDS_KEY 
3a68						DMARK "ACT" 
3a68 f5				push af  
3a69 3a 7d 3a			ld a, (.dmark)  
3a6c 32 6b ee			ld (debug_mark),a  
3a6f 3a 7e 3a			ld a, (.dmark+1)  
3a72 32 6c ee			ld (debug_mark+1),a  
3a75 3a 7f 3a			ld a, (.dmark+2)  
3a78 32 6d ee			ld (debug_mark+2),a  
3a7b 18 03			jr .pastdmark  
3a7d ..			.dmark: db "ACT"  
3a80 f1			.pastdmark: pop af  
3a81			endm  
# End of macro DMARK
3a81						CALLMONITOR 
3a81 cd 6f ee			call debug_vector  
3a84				endm  
# End of macro CALLMONITOR
3a84					endif 
3a84 cd 11 0b				call active 
3a87					if DEBUG_FORTH_WORDS 
3a87						DMARK "ACp" 
3a87 f5				push af  
3a88 3a 9c 3a			ld a, (.dmark)  
3a8b 32 6b ee			ld (debug_mark),a  
3a8e 3a 9d 3a			ld a, (.dmark+1)  
3a91 32 6c ee			ld (debug_mark+1),a  
3a94 3a 9e 3a			ld a, (.dmark+2)  
3a97 32 6d ee			ld (debug_mark+2),a  
3a9a 18 03			jr .pastdmark  
3a9c ..			.dmark: db "ACp"  
3a9f f1			.pastdmark: pop af  
3aa0			endm  
# End of macro DMARK
3aa0						CALLMONITOR 
3aa0 cd 6f ee			call debug_vector  
3aa3				endm  
# End of macro CALLMONITOR
3aa3					endif 
3aa3 cd c4 1c				call forth_push_str 
3aa6			 
3aa6					NEXTW 
3aa6 c3 03 20			jp macro_next 
3aa9				endm 
# End of macro NEXTW
3aa9			.INFO: 
3aa9			 
3aa9				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3aa9 62				db WORD_SYS_CORE+78             
3aaa c6 3a			dw .ATP            
3aac 05				db 4 + 1 
3aad .. 00			db "INFO",0              
3ab2				endm 
# End of macro CWHEAD
3ab2			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3ab2					FORTH_DSP_VALUEHL 
3ab2 cd 4d 1e			call macro_dsp_valuehl 
3ab5				endm 
# End of macro FORTH_DSP_VALUEHL
3ab5			 
3ab5					FORTH_DSP_POP 
3ab5 cd 05 1f			call macro_forth_dsp_pop 
3ab8				endm 
# End of macro FORTH_DSP_POP
3ab8			 
3ab8 e5					push hl 
3ab9			 
3ab9					FORTH_DSP_VALUEHL 
3ab9 cd 4d 1e			call macro_dsp_valuehl 
3abc				endm 
# End of macro FORTH_DSP_VALUEHL
3abc			 
3abc					FORTH_DSP_POP 
3abc cd 05 1f			call macro_forth_dsp_pop 
3abf				endm 
# End of macro FORTH_DSP_POP
3abf			 
3abf d1					pop de 
3ac0			 
3ac0 cd 4b 0b				call info_panel 
3ac3			 
3ac3			 
3ac3					NEXTW 
3ac3 c3 03 20			jp macro_next 
3ac6				endm 
# End of macro NEXTW
3ac6			.ATP: 
3ac6				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3ac6 62				db WORD_SYS_CORE+78             
3ac7 3d 3b			dw .FB            
3ac9 04				db 3 + 1 
3aca .. 00			db "AT?",0              
3ace				endm 
# End of macro CWHEAD
3ace			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3ace					if DEBUG_FORTH_WORDS_KEY 
3ace						DMARK "AT?" 
3ace f5				push af  
3acf 3a e3 3a			ld a, (.dmark)  
3ad2 32 6b ee			ld (debug_mark),a  
3ad5 3a e4 3a			ld a, (.dmark+1)  
3ad8 32 6c ee			ld (debug_mark+1),a  
3adb 3a e5 3a			ld a, (.dmark+2)  
3ade 32 6d ee			ld (debug_mark+2),a  
3ae1 18 03			jr .pastdmark  
3ae3 ..			.dmark: db "AT?"  
3ae6 f1			.pastdmark: pop af  
3ae7			endm  
# End of macro DMARK
3ae7						CALLMONITOR 
3ae7 cd 6f ee			call debug_vector  
3aea				endm  
# End of macro CALLMONITOR
3aea					endif 
3aea 3a 5e ea				ld a, (f_cursor_ptr) 
3aed			 
3aed			if DEBUG_FORTH_WORDS 
3aed				DMARK "AT?" 
3aed f5				push af  
3aee 3a 02 3b			ld a, (.dmark)  
3af1 32 6b ee			ld (debug_mark),a  
3af4 3a 03 3b			ld a, (.dmark+1)  
3af7 32 6c ee			ld (debug_mark+1),a  
3afa 3a 04 3b			ld a, (.dmark+2)  
3afd 32 6d ee			ld (debug_mark+2),a  
3b00 18 03			jr .pastdmark  
3b02 ..			.dmark: db "AT?"  
3b05 f1			.pastdmark: pop af  
3b06			endm  
# End of macro DMARK
3b06				CALLMONITOR 
3b06 cd 6f ee			call debug_vector  
3b09				endm  
# End of macro CALLMONITOR
3b09			endif	 
3b09					; count the number of rows 
3b09			 
3b09 06 00				ld b, 0 
3b0b 4f			.atpr:		ld c, a    ; save in case we go below zero 
3b0c d6 28				sub display_cols 
3b0e f2 14 3b				jp p, .atprunder 
3b11 04					inc b 
3b12 18 f7				jr .atpr 
3b14			.atprunder:	 
3b14			if DEBUG_FORTH_WORDS 
3b14				DMARK "A?2" 
3b14 f5				push af  
3b15 3a 29 3b			ld a, (.dmark)  
3b18 32 6b ee			ld (debug_mark),a  
3b1b 3a 2a 3b			ld a, (.dmark+1)  
3b1e 32 6c ee			ld (debug_mark+1),a  
3b21 3a 2b 3b			ld a, (.dmark+2)  
3b24 32 6d ee			ld (debug_mark+2),a  
3b27 18 03			jr .pastdmark  
3b29 ..			.dmark: db "A?2"  
3b2c f1			.pastdmark: pop af  
3b2d			endm  
# End of macro DMARK
3b2d				CALLMONITOR 
3b2d cd 6f ee			call debug_vector  
3b30				endm  
# End of macro CALLMONITOR
3b30			endif	 
3b30 26 00				ld h, 0 
3b32 69					ld l, c 
3b33 cd 56 1c				call forth_push_numhl 
3b36 68					ld l, b  
3b37 cd 56 1c				call forth_push_numhl 
3b3a			 
3b3a			 
3b3a				NEXTW 
3b3a c3 03 20			jp macro_next 
3b3d				endm 
# End of macro NEXTW
3b3d			 
3b3d			.FB: 
3b3d				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3b3d 1b				db WORD_SYS_CORE+7             
3b3e 8b 3b			dw .EMIT            
3b40 03				db 2 + 1 
3b41 .. 00			db "FB",0              
3b44				endm 
# End of macro CWHEAD
3b44			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3b44			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3b44			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3b44			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3b44					if DEBUG_FORTH_WORDS_KEY 
3b44						DMARK "FB." 
3b44 f5				push af  
3b45 3a 59 3b			ld a, (.dmark)  
3b48 32 6b ee			ld (debug_mark),a  
3b4b 3a 5a 3b			ld a, (.dmark+1)  
3b4e 32 6c ee			ld (debug_mark+1),a  
3b51 3a 5b 3b			ld a, (.dmark+2)  
3b54 32 6d ee			ld (debug_mark+2),a  
3b57 18 03			jr .pastdmark  
3b59 ..			.dmark: db "FB."  
3b5c f1			.pastdmark: pop af  
3b5d			endm  
# End of macro DMARK
3b5d						CALLMONITOR 
3b5d cd 6f ee			call debug_vector  
3b60				endm  
# End of macro CALLMONITOR
3b60					endif 
3b60			 
3b60					FORTH_DSP_VALUEHL 
3b60 cd 4d 1e			call macro_dsp_valuehl 
3b63				endm 
# End of macro FORTH_DSP_VALUEHL
3b63			 
3b63 7d					ld a, l 
3b64 fe 01				cp 1 
3b66 20 05				jr nz, .fbn1 
3b68 21 10 ed				ld hl, display_fb1 
3b6b 18 15				jr .fbset 
3b6d fe 02		.fbn1:		cp 2 
3b6f 20 05				jr nz, .fbn2 
3b71 21 ce eb				ld hl, display_fb2 
3b74 18 0c				jr .fbset 
3b76 fe 03		.fbn2:		cp 3 
3b78 20 05				jr nz, .fbn3 
3b7a 21 6f ec				ld hl, display_fb3 
3b7d 18 03				jr .fbset 
3b7f			.fbn3:		 ; if invalid number select first 
3b7f 21 10 ed				ld hl, display_fb1 
3b82 22 cc eb		.fbset:		ld (display_fb_active), hl 
3b85			 
3b85					FORTH_DSP_POP 
3b85 cd 05 1f			call macro_forth_dsp_pop 
3b88				endm 
# End of macro FORTH_DSP_POP
3b88			 
3b88					NEXTW 
3b88 c3 03 20			jp macro_next 
3b8b				endm 
# End of macro NEXTW
3b8b			 
3b8b			 
3b8b			.EMIT: 
3b8b				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b8b 1b				db WORD_SYS_CORE+7             
3b8c dc 3b			dw .DOTH            
3b8e 05				db 4 + 1 
3b8f .. 00			db "EMIT",0              
3b94				endm 
# End of macro CWHEAD
3b94			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b94					; get value off TOS and display it 
3b94			 
3b94					if DEBUG_FORTH_WORDS_KEY 
3b94						DMARK "EMT" 
3b94 f5				push af  
3b95 3a a9 3b			ld a, (.dmark)  
3b98 32 6b ee			ld (debug_mark),a  
3b9b 3a aa 3b			ld a, (.dmark+1)  
3b9e 32 6c ee			ld (debug_mark+1),a  
3ba1 3a ab 3b			ld a, (.dmark+2)  
3ba4 32 6d ee			ld (debug_mark+2),a  
3ba7 18 03			jr .pastdmark  
3ba9 ..			.dmark: db "EMT"  
3bac f1			.pastdmark: pop af  
3bad			endm  
# End of macro DMARK
3bad						CALLMONITOR 
3bad cd 6f ee			call debug_vector  
3bb0				endm  
# End of macro CALLMONITOR
3bb0					endif 
3bb0			 
3bb0					FORTH_DSP_VALUEHL 
3bb0 cd 4d 1e			call macro_dsp_valuehl 
3bb3				endm 
# End of macro FORTH_DSP_VALUEHL
3bb3			 
3bb3 7d					ld a,l 
3bb4			 
3bb4					; TODO write to display 
3bb4			 
3bb4 32 bf e4				ld (os_input), a 
3bb7 3e 00				ld a, 0 
3bb9 32 c0 e4				ld (os_input+1), a 
3bbc					 
3bbc 3a 5e ea				ld a, (f_cursor_ptr) 
3bbf 11 bf e4				ld de, os_input 
3bc2 cd cd 0b				call str_at_display 
3bc5			 
3bc5			 
3bc5 3a 3c ea				ld a,(cli_autodisplay) 
3bc8 fe 00				cp 0 
3bca 28 03				jr z, .enoupdate 
3bcc cd dd 0b						call update_display 
3bcf					.enoupdate: 
3bcf			 
3bcf 3a 5e ea				ld a, (f_cursor_ptr) 
3bd2 3c					inc a 
3bd3 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3bd6			 
3bd6			 
3bd6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bd6 cd 05 1f			call macro_forth_dsp_pop 
3bd9				endm 
# End of macro FORTH_DSP_POP
3bd9			  
3bd9			 
3bd9					NEXTW 
3bd9 c3 03 20			jp macro_next 
3bdc				endm 
# End of macro NEXTW
3bdc			.DOTH: 
3bdc				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3bdc 1c				db WORD_SYS_CORE+8             
3bdd 0c 3c			dw .DOTF            
3bdf 03				db 2 + 1 
3be0 .. 00			db ".-",0              
3be3				endm 
# End of macro CWHEAD
3be3			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3be3					; get value off TOS and display it 
3be3					if DEBUG_FORTH_WORDS_KEY 
3be3						DMARK "DTD" 
3be3 f5				push af  
3be4 3a f8 3b			ld a, (.dmark)  
3be7 32 6b ee			ld (debug_mark),a  
3bea 3a f9 3b			ld a, (.dmark+1)  
3bed 32 6c ee			ld (debug_mark+1),a  
3bf0 3a fa 3b			ld a, (.dmark+2)  
3bf3 32 6d ee			ld (debug_mark+2),a  
3bf6 18 03			jr .pastdmark  
3bf8 ..			.dmark: db "DTD"  
3bfb f1			.pastdmark: pop af  
3bfc			endm  
# End of macro DMARK
3bfc						CALLMONITOR 
3bfc cd 6f ee			call debug_vector  
3bff				endm  
# End of macro CALLMONITOR
3bff					endif 
3bff 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3c01 3e 00			ld a, 0 
3c03 32 3d ea			ld (cli_mvdot), a 
3c06 c3 63 3c			jp .dotgo 
3c09				NEXTW 
3c09 c3 03 20			jp macro_next 
3c0c				endm 
# End of macro NEXTW
3c0c			.DOTF: 
3c0c				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3c0c 1c				db WORD_SYS_CORE+8             
3c0d 3a 3c			dw .DOT            
3c0f 03				db 2 + 1 
3c10 .. 00			db ".>",0              
3c13				endm 
# End of macro CWHEAD
3c13			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3c13					; get value off TOS and display it 
3c13			        ; TODO BUG adds extra spaces 
3c13			        ; TODO BUG handle numerics? 
3c13					if DEBUG_FORTH_WORDS_KEY 
3c13						DMARK "DTC" 
3c13 f5				push af  
3c14 3a 28 3c			ld a, (.dmark)  
3c17 32 6b ee			ld (debug_mark),a  
3c1a 3a 29 3c			ld a, (.dmark+1)  
3c1d 32 6c ee			ld (debug_mark+1),a  
3c20 3a 2a 3c			ld a, (.dmark+2)  
3c23 32 6d ee			ld (debug_mark+2),a  
3c26 18 03			jr .pastdmark  
3c28 ..			.dmark: db "DTC"  
3c2b f1			.pastdmark: pop af  
3c2c			endm  
# End of macro DMARK
3c2c						CALLMONITOR 
3c2c cd 6f ee			call debug_vector  
3c2f				endm  
# End of macro CALLMONITOR
3c2f					endif 
3c2f 3e 01			ld a, 1 
3c31 32 3d ea			ld (cli_mvdot), a 
3c34 c3 63 3c			jp .dotgo 
3c37				NEXTW 
3c37 c3 03 20			jp macro_next 
3c3a				endm 
# End of macro NEXTW
3c3a			 
3c3a			.DOT: 
3c3a				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3c3a 1c				db WORD_SYS_CORE+8             
3c3b 16 3e			dw .CLS            
3c3d 02				db 1 + 1 
3c3e .. 00			db ".",0              
3c40				endm 
# End of macro CWHEAD
3c40			        ; | . ( u -- ) Display TOS | DONE 
3c40					; get value off TOS and display it 
3c40			 
3c40					if DEBUG_FORTH_WORDS_KEY 
3c40						DMARK "DOT" 
3c40 f5				push af  
3c41 3a 55 3c			ld a, (.dmark)  
3c44 32 6b ee			ld (debug_mark),a  
3c47 3a 56 3c			ld a, (.dmark+1)  
3c4a 32 6c ee			ld (debug_mark+1),a  
3c4d 3a 57 3c			ld a, (.dmark+2)  
3c50 32 6d ee			ld (debug_mark+2),a  
3c53 18 03			jr .pastdmark  
3c55 ..			.dmark: db "DOT"  
3c58 f1			.pastdmark: pop af  
3c59			endm  
# End of macro DMARK
3c59						CALLMONITOR 
3c59 cd 6f ee			call debug_vector  
3c5c				endm  
# End of macro CALLMONITOR
3c5c					endif 
3c5c 3e 00			ld a, 0 
3c5e 32 3d ea			ld (cli_mvdot), a 
3c61 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3c63				 
3c63			 
3c63			.dotgo: 
3c63			 
3c63			; move up type to on stack for parserv5 
3c63					FORTH_DSP 
3c63 cd 13 1e			call macro_forth_dsp 
3c66				endm 
# End of macro FORTH_DSP
3c66				;FORTH_DSP_VALUE  
3c66			 
3c66			if DEBUG_FORTH_DOT 
3c66				DMARK "DOT" 
3c66 f5				push af  
3c67 3a 7b 3c			ld a, (.dmark)  
3c6a 32 6b ee			ld (debug_mark),a  
3c6d 3a 7c 3c			ld a, (.dmark+1)  
3c70 32 6c ee			ld (debug_mark+1),a  
3c73 3a 7d 3c			ld a, (.dmark+2)  
3c76 32 6d ee			ld (debug_mark+2),a  
3c79 18 03			jr .pastdmark  
3c7b ..			.dmark: db "DOT"  
3c7e f1			.pastdmark: pop af  
3c7f			endm  
# End of macro DMARK
3c7f				CALLMONITOR 
3c7f cd 6f ee			call debug_vector  
3c82				endm  
# End of macro CALLMONITOR
3c82			endif	 
3c82			;		.print: 
3c82			 
3c82 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3c83 23				inc hl   ; position to the actual value 
3c84 fe 01			cp DS_TYPE_STR 
3c86 20 06			jr nz, .dotnum1  
3c88			 
3c88			; display string 
3c88				FORTH_DSP_VALUE  
3c88 cd 36 1e			call macro_forth_dsp_value 
3c8b				endm 
# End of macro FORTH_DSP_VALUE
3c8b eb				ex de,hl 
3c8c 18 49			jr .dotwrite 
3c8e			 
3c8e			.dotnum1: 
3c8e fe 02			cp DS_TYPE_INUM 
3c90 20 44			jr nz, .dotflot 
3c92			 
3c92			 
3c92			; display number 
3c92			 
3c92			;	push hl 
3c92			;	call clear_display 
3c92			;	pop hl 
3c92			 
3c92 5e				ld e, (hl) 
3c93 23				inc hl 
3c94 56				ld d, (hl) 
3c95 21 c1 e2			ld hl, scratch 
3c98			if DEBUG_FORTH_DOT 
3c98				DMARK "DT1" 
3c98 f5				push af  
3c99 3a ad 3c			ld a, (.dmark)  
3c9c 32 6b ee			ld (debug_mark),a  
3c9f 3a ae 3c			ld a, (.dmark+1)  
3ca2 32 6c ee			ld (debug_mark+1),a  
3ca5 3a af 3c			ld a, (.dmark+2)  
3ca8 32 6d ee			ld (debug_mark+2),a  
3cab 18 03			jr .pastdmark  
3cad ..			.dmark: db "DT1"  
3cb0 f1			.pastdmark: pop af  
3cb1			endm  
# End of macro DMARK
3cb1				CALLMONITOR 
3cb1 cd 6f ee			call debug_vector  
3cb4				endm  
# End of macro CALLMONITOR
3cb4			endif	 
3cb4			 
3cb4 cd f4 11			call uitoa_16 
3cb7 eb				ex de,hl 
3cb8			 
3cb8			if DEBUG_FORTH_DOT 
3cb8				DMARK "DT2" 
3cb8 f5				push af  
3cb9 3a cd 3c			ld a, (.dmark)  
3cbc 32 6b ee			ld (debug_mark),a  
3cbf 3a ce 3c			ld a, (.dmark+1)  
3cc2 32 6c ee			ld (debug_mark+1),a  
3cc5 3a cf 3c			ld a, (.dmark+2)  
3cc8 32 6d ee			ld (debug_mark+2),a  
3ccb 18 03			jr .pastdmark  
3ccd ..			.dmark: db "DT2"  
3cd0 f1			.pastdmark: pop af  
3cd1			endm  
# End of macro DMARK
3cd1				CALLMONITOR 
3cd1 cd 6f ee			call debug_vector  
3cd4				endm  
# End of macro CALLMONITOR
3cd4			endif	 
3cd4			 
3cd4			;	ld de, os_word_scratch 
3cd4 18 01			jr .dotwrite 
3cd6			 
3cd6 00			.dotflot:   nop 
3cd7			; TODO print floating point number 
3cd7			 
3cd7			.dotwrite:		 
3cd7			 
3cd7					; if c is set then set all '-' to spaces 
3cd7					; need to also take into account .>  
3cd7			 
3cd7 3e 01				ld a, 1 
3cd9 b9					cp c 
3cda 20 67				jr nz, .nodashswap 
3cdc			 
3cdc					; DE has the string to write, working with HL 
3cdc			 
3cdc 06 ff				ld b, 255 
3cde d5					push de 
3cdf e1					pop hl 
3ce0			 
3ce0			if DEBUG_FORTH_DOT 
3ce0				DMARK "DT-" 
3ce0 f5				push af  
3ce1 3a f5 3c			ld a, (.dmark)  
3ce4 32 6b ee			ld (debug_mark),a  
3ce7 3a f6 3c			ld a, (.dmark+1)  
3cea 32 6c ee			ld (debug_mark+1),a  
3ced 3a f7 3c			ld a, (.dmark+2)  
3cf0 32 6d ee			ld (debug_mark+2),a  
3cf3 18 03			jr .pastdmark  
3cf5 ..			.dmark: db "DT-"  
3cf8 f1			.pastdmark: pop af  
3cf9			endm  
# End of macro DMARK
3cf9				CALLMONITOR 
3cf9 cd 6f ee			call debug_vector  
3cfc				endm  
# End of macro CALLMONITOR
3cfc			endif	 
3cfc 7e			.dashscan:	ld a, (hl) 
3cfd fe 00				cp 0 
3cff 28 42				jr z, .nodashswap 
3d01 fe 2d				cp '-' 
3d03 20 03				jr nz, .dashskip 
3d05 3e 20				ld a, ' ' 
3d07 77					ld (hl), a 
3d08 23			.dashskip:	inc hl 
3d09			if DEBUG_FORTH_DOT 
3d09				DMARK "D-2" 
3d09 f5				push af  
3d0a 3a 1e 3d			ld a, (.dmark)  
3d0d 32 6b ee			ld (debug_mark),a  
3d10 3a 1f 3d			ld a, (.dmark+1)  
3d13 32 6c ee			ld (debug_mark+1),a  
3d16 3a 20 3d			ld a, (.dmark+2)  
3d19 32 6d ee			ld (debug_mark+2),a  
3d1c 18 03			jr .pastdmark  
3d1e ..			.dmark: db "D-2"  
3d21 f1			.pastdmark: pop af  
3d22			endm  
# End of macro DMARK
3d22				CALLMONITOR 
3d22 cd 6f ee			call debug_vector  
3d25				endm  
# End of macro CALLMONITOR
3d25			endif	 
3d25 10 d5				djnz .dashscan 
3d27			 
3d27			if DEBUG_FORTH_DOT 
3d27				DMARK "D-1" 
3d27 f5				push af  
3d28 3a 3c 3d			ld a, (.dmark)  
3d2b 32 6b ee			ld (debug_mark),a  
3d2e 3a 3d 3d			ld a, (.dmark+1)  
3d31 32 6c ee			ld (debug_mark+1),a  
3d34 3a 3e 3d			ld a, (.dmark+2)  
3d37 32 6d ee			ld (debug_mark+2),a  
3d3a 18 03			jr .pastdmark  
3d3c ..			.dmark: db "D-1"  
3d3f f1			.pastdmark: pop af  
3d40			endm  
# End of macro DMARK
3d40				CALLMONITOR 
3d40 cd 6f ee			call debug_vector  
3d43				endm  
# End of macro CALLMONITOR
3d43			endif	 
3d43			 
3d43			.nodashswap: 
3d43			 
3d43			if DEBUG_FORTH_DOT 
3d43				DMARK "D-o" 
3d43 f5				push af  
3d44 3a 58 3d			ld a, (.dmark)  
3d47 32 6b ee			ld (debug_mark),a  
3d4a 3a 59 3d			ld a, (.dmark+1)  
3d4d 32 6c ee			ld (debug_mark+1),a  
3d50 3a 5a 3d			ld a, (.dmark+2)  
3d53 32 6d ee			ld (debug_mark+2),a  
3d56 18 03			jr .pastdmark  
3d58 ..			.dmark: db "D-o"  
3d5b f1			.pastdmark: pop af  
3d5c			endm  
# End of macro DMARK
3d5c				CALLMONITOR 
3d5c cd 6f ee			call debug_vector  
3d5f				endm  
# End of macro CALLMONITOR
3d5f			endif	 
3d5f			 
3d5f d5					push de   ; save string start in case we need to advance print 
3d60			 
3d60 3a 5e ea				ld a, (f_cursor_ptr) 
3d63 cd cd 0b				call str_at_display 
3d66 3a 3c ea				ld a,(cli_autodisplay) 
3d69 fe 00				cp 0 
3d6b 28 03				jr z, .noupdate 
3d6d cd dd 0b						call update_display 
3d70					.noupdate: 
3d70			 
3d70			 
3d70					; see if we need to advance the print position 
3d70			 
3d70 e1					pop hl   ; get back string 
3d71			;		ex de,hl 
3d71			 
3d71 3a 3d ea				ld a, (cli_mvdot) 
3d74			if DEBUG_FORTH_DOT 
3d74			;		ld e,a 
3d74				DMARK "D>1" 
3d74 f5				push af  
3d75 3a 89 3d			ld a, (.dmark)  
3d78 32 6b ee			ld (debug_mark),a  
3d7b 3a 8a 3d			ld a, (.dmark+1)  
3d7e 32 6c ee			ld (debug_mark+1),a  
3d81 3a 8b 3d			ld a, (.dmark+2)  
3d84 32 6d ee			ld (debug_mark+2),a  
3d87 18 03			jr .pastdmark  
3d89 ..			.dmark: db "D>1"  
3d8c f1			.pastdmark: pop af  
3d8d			endm  
# End of macro DMARK
3d8d				CALLMONITOR 
3d8d cd 6f ee			call debug_vector  
3d90				endm  
# End of macro CALLMONITOR
3d90			endif	 
3d90 fe 00				cp 0 
3d92 28 44				jr z, .noadv 
3d94					; yes, lets advance the print position 
3d94 3e 00				ld a, 0 
3d96 cd 50 12				call strlent 
3d99			if DEBUG_FORTH_DOT 
3d99				DMARK "D-?" 
3d99 f5				push af  
3d9a 3a ae 3d			ld a, (.dmark)  
3d9d 32 6b ee			ld (debug_mark),a  
3da0 3a af 3d			ld a, (.dmark+1)  
3da3 32 6c ee			ld (debug_mark+1),a  
3da6 3a b0 3d			ld a, (.dmark+2)  
3da9 32 6d ee			ld (debug_mark+2),a  
3dac 18 03			jr .pastdmark  
3dae ..			.dmark: db "D-?"  
3db1 f1			.pastdmark: pop af  
3db2			endm  
# End of macro DMARK
3db2				CALLMONITOR 
3db2 cd 6f ee			call debug_vector  
3db5				endm  
# End of macro CALLMONITOR
3db5			endif	 
3db5 3a 5e ea				ld a, (f_cursor_ptr) 
3db8 85					add a,l 
3db9					;call addatohl 
3db9					;ld a, l 
3db9 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3dbc			 
3dbc			if DEBUG_FORTH_DOT 
3dbc				DMARK "D->" 
3dbc f5				push af  
3dbd 3a d1 3d			ld a, (.dmark)  
3dc0 32 6b ee			ld (debug_mark),a  
3dc3 3a d2 3d			ld a, (.dmark+1)  
3dc6 32 6c ee			ld (debug_mark+1),a  
3dc9 3a d3 3d			ld a, (.dmark+2)  
3dcc 32 6d ee			ld (debug_mark+2),a  
3dcf 18 03			jr .pastdmark  
3dd1 ..			.dmark: db "D->"  
3dd4 f1			.pastdmark: pop af  
3dd5			endm  
# End of macro DMARK
3dd5				CALLMONITOR 
3dd5 cd 6f ee			call debug_vector  
3dd8				endm  
# End of macro CALLMONITOR
3dd8			endif	 
3dd8			 
3dd8			.noadv:	 
3dd8			 
3dd8					if DEBUG_FORTH_DOT_WAIT 
3dd8							call next_page_prompt 
3dd8					endif	 
3dd8			; TODO this pop off the stack causes a crash. i dont know why 
3dd8			 
3dd8			 
3dd8			if DEBUG_FORTH_DOT 
3dd8				DMARK "DTh" 
3dd8 f5				push af  
3dd9 3a ed 3d			ld a, (.dmark)  
3ddc 32 6b ee			ld (debug_mark),a  
3ddf 3a ee 3d			ld a, (.dmark+1)  
3de2 32 6c ee			ld (debug_mark+1),a  
3de5 3a ef 3d			ld a, (.dmark+2)  
3de8 32 6d ee			ld (debug_mark+2),a  
3deb 18 03			jr .pastdmark  
3ded ..			.dmark: db "DTh"  
3df0 f1			.pastdmark: pop af  
3df1			endm  
# End of macro DMARK
3df1				CALLMONITOR 
3df1 cd 6f ee			call debug_vector  
3df4				endm  
# End of macro CALLMONITOR
3df4			endif	 
3df4			 
3df4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3df4 cd 05 1f			call macro_forth_dsp_pop 
3df7				endm 
# End of macro FORTH_DSP_POP
3df7			 
3df7			if DEBUG_FORTH_DOT 
3df7				DMARK "DTi" 
3df7 f5				push af  
3df8 3a 0c 3e			ld a, (.dmark)  
3dfb 32 6b ee			ld (debug_mark),a  
3dfe 3a 0d 3e			ld a, (.dmark+1)  
3e01 32 6c ee			ld (debug_mark+1),a  
3e04 3a 0e 3e			ld a, (.dmark+2)  
3e07 32 6d ee			ld (debug_mark+2),a  
3e0a 18 03			jr .pastdmark  
3e0c ..			.dmark: db "DTi"  
3e0f f1			.pastdmark: pop af  
3e10			endm  
# End of macro DMARK
3e10				CALLMONITOR 
3e10 cd 6f ee			call debug_vector  
3e13				endm  
# End of macro CALLMONITOR
3e13			endif	 
3e13			 
3e13			 
3e13					NEXTW 
3e13 c3 03 20			jp macro_next 
3e16				endm 
# End of macro NEXTW
3e16			 
3e16			.CLS: 
3e16				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3e16 35				db WORD_SYS_CORE+33             
3e17 43 3e			dw .DRAW            
3e19 04				db 3 + 1 
3e1a .. 00			db "CLS",0              
3e1e				endm 
# End of macro CWHEAD
3e1e			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3e1e					if DEBUG_FORTH_WORDS_KEY 
3e1e						DMARK "CLS" 
3e1e f5				push af  
3e1f 3a 33 3e			ld a, (.dmark)  
3e22 32 6b ee			ld (debug_mark),a  
3e25 3a 34 3e			ld a, (.dmark+1)  
3e28 32 6c ee			ld (debug_mark+1),a  
3e2b 3a 35 3e			ld a, (.dmark+2)  
3e2e 32 6d ee			ld (debug_mark+2),a  
3e31 18 03			jr .pastdmark  
3e33 ..			.dmark: db "CLS"  
3e36 f1			.pastdmark: pop af  
3e37			endm  
# End of macro DMARK
3e37						CALLMONITOR 
3e37 cd 6f ee			call debug_vector  
3e3a				endm  
# End of macro CALLMONITOR
3e3a					endif 
3e3a cd ba 0b				call clear_display 
3e3d c3 51 3f				jp .home		; and home cursor 
3e40					NEXTW 
3e40 c3 03 20			jp macro_next 
3e43				endm 
# End of macro NEXTW
3e43			 
3e43			.DRAW: 
3e43				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3e43 36				db WORD_SYS_CORE+34             
3e44 6e 3e			dw .DUMP            
3e46 05				db 4 + 1 
3e47 .. 00			db "DRAW",0              
3e4c				endm 
# End of macro CWHEAD
3e4c			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3e4c					if DEBUG_FORTH_WORDS_KEY 
3e4c						DMARK "DRW" 
3e4c f5				push af  
3e4d 3a 61 3e			ld a, (.dmark)  
3e50 32 6b ee			ld (debug_mark),a  
3e53 3a 62 3e			ld a, (.dmark+1)  
3e56 32 6c ee			ld (debug_mark+1),a  
3e59 3a 63 3e			ld a, (.dmark+2)  
3e5c 32 6d ee			ld (debug_mark+2),a  
3e5f 18 03			jr .pastdmark  
3e61 ..			.dmark: db "DRW"  
3e64 f1			.pastdmark: pop af  
3e65			endm  
# End of macro DMARK
3e65						CALLMONITOR 
3e65 cd 6f ee			call debug_vector  
3e68				endm  
# End of macro CALLMONITOR
3e68					endif 
3e68 cd dd 0b				call update_display 
3e6b					NEXTW 
3e6b c3 03 20			jp macro_next 
3e6e				endm 
# End of macro NEXTW
3e6e			 
3e6e			.DUMP: 
3e6e				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3e6e 37				db WORD_SYS_CORE+35             
3e6f a6 3e			dw .CDUMP            
3e71 05				db 4 + 1 
3e72 .. 00			db "DUMP",0              
3e77				endm 
# End of macro CWHEAD
3e77			; | DUMP ( x -- ) With address x display dump   | DONE 
3e77			; TODO pop address to use off of the stack 
3e77					if DEBUG_FORTH_WORDS_KEY 
3e77						DMARK "DUM" 
3e77 f5				push af  
3e78 3a 8c 3e			ld a, (.dmark)  
3e7b 32 6b ee			ld (debug_mark),a  
3e7e 3a 8d 3e			ld a, (.dmark+1)  
3e81 32 6c ee			ld (debug_mark+1),a  
3e84 3a 8e 3e			ld a, (.dmark+2)  
3e87 32 6d ee			ld (debug_mark+2),a  
3e8a 18 03			jr .pastdmark  
3e8c ..			.dmark: db "DUM"  
3e8f f1			.pastdmark: pop af  
3e90			endm  
# End of macro DMARK
3e90						CALLMONITOR 
3e90 cd 6f ee			call debug_vector  
3e93				endm  
# End of macro CALLMONITOR
3e93					endif 
3e93 cd ba 0b				call clear_display 
3e96			 
3e96					; get address 
3e96			 
3e96					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e96 cd 4d 1e			call macro_dsp_valuehl 
3e99				endm 
# End of macro FORTH_DSP_VALUEHL
3e99				 
3e99					; save it for cdump 
3e99			 
3e99 22 e4 e5				ld (os_cur_ptr),hl 
3e9c			 
3e9c					; destroy value TOS 
3e9c			 
3e9c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e9c cd 05 1f			call macro_forth_dsp_pop 
3e9f				endm 
# End of macro FORTH_DSP_POP
3e9f			 
3e9f cd d6 1a				call dumpcont	; skip old style of param parsing	 
3ea2 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3ea3					NEXTW 
3ea3 c3 03 20			jp macro_next 
3ea6				endm 
# End of macro NEXTW
3ea6			.CDUMP: 
3ea6				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3ea6 38				db WORD_SYS_CORE+36             
3ea7 d6 3e			dw .DAT            
3ea9 06				db 5 + 1 
3eaa .. 00			db "CDUMP",0              
3eb0				endm 
# End of macro CWHEAD
3eb0			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3eb0					if DEBUG_FORTH_WORDS_KEY 
3eb0						DMARK "CDP" 
3eb0 f5				push af  
3eb1 3a c5 3e			ld a, (.dmark)  
3eb4 32 6b ee			ld (debug_mark),a  
3eb7 3a c6 3e			ld a, (.dmark+1)  
3eba 32 6c ee			ld (debug_mark+1),a  
3ebd 3a c7 3e			ld a, (.dmark+2)  
3ec0 32 6d ee			ld (debug_mark+2),a  
3ec3 18 03			jr .pastdmark  
3ec5 ..			.dmark: db "CDP"  
3ec8 f1			.pastdmark: pop af  
3ec9			endm  
# End of macro DMARK
3ec9						CALLMONITOR 
3ec9 cd 6f ee			call debug_vector  
3ecc				endm  
# End of macro CALLMONITOR
3ecc					endif 
3ecc cd ba 0b				call clear_display 
3ecf cd d6 1a				call dumpcont	 
3ed2 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3ed3					NEXTW 
3ed3 c3 03 20			jp macro_next 
3ed6				endm 
# End of macro NEXTW
3ed6			 
3ed6			 
3ed6			 
3ed6			 
3ed6			.DAT: 
3ed6				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3ed6 3d				db WORD_SYS_CORE+41             
3ed7 2c 3f			dw .HOME            
3ed9 03				db 2 + 1 
3eda .. 00			db "AT",0              
3edd				endm 
# End of macro CWHEAD
3edd			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3edd					if DEBUG_FORTH_WORDS_KEY 
3edd						DMARK "AT." 
3edd f5				push af  
3ede 3a f2 3e			ld a, (.dmark)  
3ee1 32 6b ee			ld (debug_mark),a  
3ee4 3a f3 3e			ld a, (.dmark+1)  
3ee7 32 6c ee			ld (debug_mark+1),a  
3eea 3a f4 3e			ld a, (.dmark+2)  
3eed 32 6d ee			ld (debug_mark+2),a  
3ef0 18 03			jr .pastdmark  
3ef2 ..			.dmark: db "AT."  
3ef5 f1			.pastdmark: pop af  
3ef6			endm  
# End of macro DMARK
3ef6						CALLMONITOR 
3ef6 cd 6f ee			call debug_vector  
3ef9				endm  
# End of macro CALLMONITOR
3ef9					endif 
3ef9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ef9 cd 4d 1e			call macro_dsp_valuehl 
3efc				endm 
# End of macro FORTH_DSP_VALUEHL
3efc			 
3efc			 
3efc					; TODO save cursor row 
3efc 7d					ld a,l 
3efd fe 02				cp 2 
3eff 20 04				jr nz, .crow3 
3f01 3e 28				ld a, display_row_2 
3f03 18 12				jr .ccol1 
3f05 fe 03		.crow3:		cp 3 
3f07 20 04				jr nz, .crow4 
3f09 3e 50				ld a, display_row_3 
3f0b 18 0a				jr .ccol1 
3f0d fe 04		.crow4:		cp 4 
3f0f 20 04				jr nz, .crow1 
3f11 3e 78				ld a, display_row_4 
3f13 18 02				jr .ccol1 
3f15 3e 00		.crow1:		ld a,display_row_1 
3f17 f5			.ccol1:		push af			; got row offset 
3f18 6f					ld l,a 
3f19 26 00				ld h,0 
3f1b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f1b cd 05 1f			call macro_forth_dsp_pop 
3f1e				endm 
# End of macro FORTH_DSP_POP
3f1e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f1e cd 4d 1e			call macro_dsp_valuehl 
3f21				endm 
# End of macro FORTH_DSP_VALUEHL
3f21					; TODO save cursor col 
3f21 f1					pop af 
3f22 85					add l		; add col offset 
3f23 32 5e ea				ld (f_cursor_ptr), a 
3f26					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f26 cd 05 1f			call macro_forth_dsp_pop 
3f29				endm 
# End of macro FORTH_DSP_POP
3f29			 
3f29					; calculate  
3f29			 
3f29					NEXTW 
3f29 c3 03 20			jp macro_next 
3f2c				endm 
# End of macro NEXTW
3f2c			 
3f2c			 
3f2c			.HOME: 
3f2c				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3f2c 41				db WORD_SYS_CORE+45             
3f2d 59 3f			dw .SPACE            
3f2f 05				db 4 + 1 
3f30 .. 00			db "HOME",0              
3f35				endm 
# End of macro CWHEAD
3f35			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3f35					if DEBUG_FORTH_WORDS_KEY 
3f35						DMARK "HOM" 
3f35 f5				push af  
3f36 3a 4a 3f			ld a, (.dmark)  
3f39 32 6b ee			ld (debug_mark),a  
3f3c 3a 4b 3f			ld a, (.dmark+1)  
3f3f 32 6c ee			ld (debug_mark+1),a  
3f42 3a 4c 3f			ld a, (.dmark+2)  
3f45 32 6d ee			ld (debug_mark+2),a  
3f48 18 03			jr .pastdmark  
3f4a ..			.dmark: db "HOM"  
3f4d f1			.pastdmark: pop af  
3f4e			endm  
# End of macro DMARK
3f4e						CALLMONITOR 
3f4e cd 6f ee			call debug_vector  
3f51				endm  
# End of macro CALLMONITOR
3f51					endif 
3f51 3e 00		.home:		ld a, 0		; and home cursor 
3f53 32 5e ea				ld (f_cursor_ptr), a 
3f56					NEXTW 
3f56 c3 03 20			jp macro_next 
3f59				endm 
# End of macro NEXTW
3f59			 
3f59			 
3f59			.SPACE: 
3f59				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3f59 46				db WORD_SYS_CORE+50             
3f5a 8f 3f			dw .SPACES            
3f5c 03				db 2 + 1 
3f5d .. 00			db "BL",0              
3f60				endm 
# End of macro CWHEAD
3f60			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3f60					if DEBUG_FORTH_WORDS_KEY 
3f60						DMARK "BL." 
3f60 f5				push af  
3f61 3a 75 3f			ld a, (.dmark)  
3f64 32 6b ee			ld (debug_mark),a  
3f67 3a 76 3f			ld a, (.dmark+1)  
3f6a 32 6c ee			ld (debug_mark+1),a  
3f6d 3a 77 3f			ld a, (.dmark+2)  
3f70 32 6d ee			ld (debug_mark+2),a  
3f73 18 03			jr .pastdmark  
3f75 ..			.dmark: db "BL."  
3f78 f1			.pastdmark: pop af  
3f79			endm  
# End of macro DMARK
3f79						CALLMONITOR 
3f79 cd 6f ee			call debug_vector  
3f7c				endm  
# End of macro CALLMONITOR
3f7c					endif 
3f7c 3e 20				ld a, " " 
3f7e 32 c1 e2				ld (scratch),a 
3f81 3e 00				ld a, 0 
3f83 32 c2 e2				ld (scratch+1),a 
3f86 21 c1 e2				ld hl, scratch 
3f89 cd c4 1c				call forth_push_str 
3f8c					 
3f8c				       NEXTW 
3f8c c3 03 20			jp macro_next 
3f8f				endm 
# End of macro NEXTW
3f8f			 
3f8f			;.blstr: db " ", 0 
3f8f			 
3f8f			.SPACES: 
3f8f				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3f8f 47				db WORD_SYS_CORE+51             
3f90 2a 40			dw .SCROLL            
3f92 07				db 6 + 1 
3f93 .. 00			db "SPACES",0              
3f9a				endm 
# End of macro CWHEAD
3f9a			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
3f9a					if DEBUG_FORTH_WORDS_KEY 
3f9a						DMARK "SPS" 
3f9a f5				push af  
3f9b 3a af 3f			ld a, (.dmark)  
3f9e 32 6b ee			ld (debug_mark),a  
3fa1 3a b0 3f			ld a, (.dmark+1)  
3fa4 32 6c ee			ld (debug_mark+1),a  
3fa7 3a b1 3f			ld a, (.dmark+2)  
3faa 32 6d ee			ld (debug_mark+2),a  
3fad 18 03			jr .pastdmark  
3faf ..			.dmark: db "SPS"  
3fb2 f1			.pastdmark: pop af  
3fb3			endm  
# End of macro DMARK
3fb3						CALLMONITOR 
3fb3 cd 6f ee			call debug_vector  
3fb6				endm  
# End of macro CALLMONITOR
3fb6					endif 
3fb6			 
3fb6			 
3fb6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fb6 cd 4d 1e			call macro_dsp_valuehl 
3fb9				endm 
# End of macro FORTH_DSP_VALUEHL
3fb9			 
3fb9 e5					push hl    ; u 
3fba					if DEBUG_FORTH_WORDS 
3fba						DMARK "SPA" 
3fba f5				push af  
3fbb 3a cf 3f			ld a, (.dmark)  
3fbe 32 6b ee			ld (debug_mark),a  
3fc1 3a d0 3f			ld a, (.dmark+1)  
3fc4 32 6c ee			ld (debug_mark+1),a  
3fc7 3a d1 3f			ld a, (.dmark+2)  
3fca 32 6d ee			ld (debug_mark+2),a  
3fcd 18 03			jr .pastdmark  
3fcf ..			.dmark: db "SPA"  
3fd2 f1			.pastdmark: pop af  
3fd3			endm  
# End of macro DMARK
3fd3						CALLMONITOR 
3fd3 cd 6f ee			call debug_vector  
3fd6				endm  
# End of macro CALLMONITOR
3fd6					endif 
3fd6			 
3fd6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fd6 cd 05 1f			call macro_forth_dsp_pop 
3fd9				endm 
# End of macro FORTH_DSP_POP
3fd9 e1					pop hl 
3fda 0e 00				ld c, 0 
3fdc 45					ld b, l 
3fdd 21 c1 e2				ld hl, scratch  
3fe0			 
3fe0					if DEBUG_FORTH_WORDS 
3fe0						DMARK "SP2" 
3fe0 f5				push af  
3fe1 3a f5 3f			ld a, (.dmark)  
3fe4 32 6b ee			ld (debug_mark),a  
3fe7 3a f6 3f			ld a, (.dmark+1)  
3fea 32 6c ee			ld (debug_mark+1),a  
3fed 3a f7 3f			ld a, (.dmark+2)  
3ff0 32 6d ee			ld (debug_mark+2),a  
3ff3 18 03			jr .pastdmark  
3ff5 ..			.dmark: db "SP2"  
3ff8 f1			.pastdmark: pop af  
3ff9			endm  
# End of macro DMARK
3ff9						CALLMONITOR 
3ff9 cd 6f ee			call debug_vector  
3ffc				endm  
# End of macro CALLMONITOR
3ffc					endif 
3ffc 3e 20				ld a, ' ' 
3ffe			.spaces1:	 
3ffe 77					ld (hl),a 
3fff 23					inc hl 
4000					 
4000 10 fc				djnz .spaces1 
4002 3e 00				ld a,0 
4004 77					ld (hl),a 
4005 21 c1 e2				ld hl, scratch 
4008					if DEBUG_FORTH_WORDS 
4008						DMARK "SP3" 
4008 f5				push af  
4009 3a 1d 40			ld a, (.dmark)  
400c 32 6b ee			ld (debug_mark),a  
400f 3a 1e 40			ld a, (.dmark+1)  
4012 32 6c ee			ld (debug_mark+1),a  
4015 3a 1f 40			ld a, (.dmark+2)  
4018 32 6d ee			ld (debug_mark+2),a  
401b 18 03			jr .pastdmark  
401d ..			.dmark: db "SP3"  
4020 f1			.pastdmark: pop af  
4021			endm  
# End of macro DMARK
4021						CALLMONITOR 
4021 cd 6f ee			call debug_vector  
4024				endm  
# End of macro CALLMONITOR
4024					endif 
4024 cd c4 1c				call forth_push_str 
4027			 
4027				       NEXTW 
4027 c3 03 20			jp macro_next 
402a				endm 
# End of macro NEXTW
402a			 
402a			 
402a			 
402a			.SCROLL: 
402a				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
402a 53				db WORD_SYS_CORE+63             
402b 57 40			dw .SCROLLD            
402d 07				db 6 + 1 
402e .. 00			db "SCROLL",0              
4035				endm 
# End of macro CWHEAD
4035			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4035					if DEBUG_FORTH_WORDS_KEY 
4035						DMARK "SCR" 
4035 f5				push af  
4036 3a 4a 40			ld a, (.dmark)  
4039 32 6b ee			ld (debug_mark),a  
403c 3a 4b 40			ld a, (.dmark+1)  
403f 32 6c ee			ld (debug_mark+1),a  
4042 3a 4c 40			ld a, (.dmark+2)  
4045 32 6d ee			ld (debug_mark+2),a  
4048 18 03			jr .pastdmark  
404a ..			.dmark: db "SCR"  
404d f1			.pastdmark: pop af  
404e			endm  
# End of macro DMARK
404e						CALLMONITOR 
404e cd 6f ee			call debug_vector  
4051				endm  
# End of macro CALLMONITOR
4051					endif 
4051			 
4051 cd 7c 0b			call scroll_up 
4054			;	call update_display 
4054			 
4054					NEXTW 
4054 c3 03 20			jp macro_next 
4057				endm 
# End of macro NEXTW
4057			 
4057			 
4057			 
4057			;		; get dir 
4057			; 
4057			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4057			; 
4057			;		push hl 
4057			; 
4057			;		; destroy value TOS 
4057			; 
4057			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4057			; 
4057			;		; get count 
4057			; 
4057			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4057			; 
4057			;		push hl 
4057			; 
4057			;		; destroy value TOS 
4057			; 
4057			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4057			; 
4057			;		; one value on hl get other one back 
4057			; 
4057			;		pop bc    ; count 
4057			; 
4057			;		pop de   ; dir 
4057			; 
4057			; 
4057			;		ld b, c 
4057			; 
4057			;.scrolldir:     push bc 
4057			;		push de 
4057			; 
4057			;		ld a, 0 
4057			;		cp e 
4057			;		jr z, .scrollup  
4057			;		call scroll_down 
4057			;		jr .scrollnext 
4057			;.scrollup:	call scroll_up 
4057			; 
4057			;		 
4057			;.scrollnext: 
4057			;		pop de 
4057			;		pop bc 
4057			;		djnz .scrolldir 
4057			; 
4057			; 
4057			; 
4057			; 
4057			; 
4057			;		NEXTW 
4057			 
4057			.SCROLLD: 
4057				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4057 53				db WORD_SYS_CORE+63             
4058 85 40			dw .ATQ            
405a 08				db 7 + 1 
405b .. 00			db "SCROLLD",0              
4063				endm 
# End of macro CWHEAD
4063			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4063					if DEBUG_FORTH_WORDS_KEY 
4063						DMARK "SCD" 
4063 f5				push af  
4064 3a 78 40			ld a, (.dmark)  
4067 32 6b ee			ld (debug_mark),a  
406a 3a 79 40			ld a, (.dmark+1)  
406d 32 6c ee			ld (debug_mark+1),a  
4070 3a 7a 40			ld a, (.dmark+2)  
4073 32 6d ee			ld (debug_mark+2),a  
4076 18 03			jr .pastdmark  
4078 ..			.dmark: db "SCD"  
407b f1			.pastdmark: pop af  
407c			endm  
# End of macro DMARK
407c						CALLMONITOR 
407c cd 6f ee			call debug_vector  
407f				endm  
# End of macro CALLMONITOR
407f					endif 
407f			 
407f cd a0 0b			call scroll_down 
4082			;	call update_display 
4082			 
4082					NEXTW 
4082 c3 03 20			jp macro_next 
4085				endm 
# End of macro NEXTW
4085			 
4085			 
4085			.ATQ: 
4085				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4085 62				db WORD_SYS_CORE+78             
4086 e3 40			dw .AUTODSP            
4088 04				db 3 + 1 
4089 .. 00			db "AT@",0              
408d				endm 
# End of macro CWHEAD
408d			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
408d					if DEBUG_FORTH_WORDS_KEY 
408d						DMARK "ATA" 
408d f5				push af  
408e 3a a2 40			ld a, (.dmark)  
4091 32 6b ee			ld (debug_mark),a  
4094 3a a3 40			ld a, (.dmark+1)  
4097 32 6c ee			ld (debug_mark+1),a  
409a 3a a4 40			ld a, (.dmark+2)  
409d 32 6d ee			ld (debug_mark+2),a  
40a0 18 03			jr .pastdmark  
40a2 ..			.dmark: db "ATA"  
40a5 f1			.pastdmark: pop af  
40a6			endm  
# End of macro DMARK
40a6						CALLMONITOR 
40a6 cd 6f ee			call debug_vector  
40a9				endm  
# End of macro CALLMONITOR
40a9					endif 
40a9			 
40a9			 
40a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40a9 cd 4d 1e			call macro_dsp_valuehl 
40ac				endm 
# End of macro FORTH_DSP_VALUEHL
40ac			 
40ac					; TODO save cursor row 
40ac 7d					ld a,l 
40ad fe 02				cp 2 
40af 20 04				jr nz, .crow3aq 
40b1 3e 28				ld a, display_row_2 
40b3 18 12				jr .ccol1aq 
40b5 fe 03		.crow3aq:		cp 3 
40b7 20 04				jr nz, .crow4aq 
40b9 3e 50				ld a, display_row_3 
40bb 18 0a				jr .ccol1aq 
40bd fe 04		.crow4aq:		cp 4 
40bf 20 04				jr nz, .crow1aq 
40c1 3e 78				ld a, display_row_4 
40c3 18 02				jr .ccol1aq 
40c5 3e 00		.crow1aq:		ld a,display_row_1 
40c7 f5			.ccol1aq:		push af			; got row offset 
40c8 6f					ld l,a 
40c9 26 00				ld h,0 
40cb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40cb cd 05 1f			call macro_forth_dsp_pop 
40ce				endm 
# End of macro FORTH_DSP_POP
40ce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40ce cd 4d 1e			call macro_dsp_valuehl 
40d1				endm 
# End of macro FORTH_DSP_VALUEHL
40d1					; TODO save cursor col 
40d1 f1					pop af 
40d2 85					add l		; add col offset 
40d3			 
40d3					; add current frame buffer address 
40d3 2a cc eb				ld hl, (display_fb_active) 
40d6 cd e7 0d				call addatohl 
40d9			 
40d9			 
40d9			 
40d9			 
40d9					; get char frame buffer location offset in hl 
40d9			 
40d9 7e					ld a,(hl) 
40da 26 00				ld h, 0 
40dc 6f					ld l, a 
40dd			 
40dd cd 56 1c				call forth_push_numhl 
40e0			 
40e0			 
40e0					NEXTW 
40e0 c3 03 20			jp macro_next 
40e3				endm 
# End of macro NEXTW
40e3			 
40e3			.AUTODSP: 
40e3				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
40e3 63				db WORD_SYS_CORE+79             
40e4 f9 40			dw .MENU            
40e6 05				db 4 + 1 
40e7 .. 00			db "ADSP",0              
40ec				endm 
# End of macro CWHEAD
40ec			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
40ec			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
40ec			 
40ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40ec cd 4d 1e			call macro_dsp_valuehl 
40ef				endm 
# End of macro FORTH_DSP_VALUEHL
40ef			 
40ef			;		push hl 
40ef			 
40ef					; destroy value TOS 
40ef			 
40ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40ef cd 05 1f			call macro_forth_dsp_pop 
40f2				endm 
# End of macro FORTH_DSP_POP
40f2			 
40f2			;		pop hl 
40f2			 
40f2 7d					ld a,l 
40f3 32 3c ea				ld (cli_autodisplay), a 
40f6				       NEXTW 
40f6 c3 03 20			jp macro_next 
40f9				endm 
# End of macro NEXTW
40f9			 
40f9			.MENU: 
40f9				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
40f9 70				db WORD_SYS_CORE+92             
40fa a2 41			dw .ENDDISPLAY            
40fc 05				db 4 + 1 
40fd .. 00			db "MENU",0              
4102				endm 
# End of macro CWHEAD
4102			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
4102			 
4102			;		; get number of items on the stack 
4102			; 
4102				 
4102					FORTH_DSP_VALUEHL 
4102 cd 4d 1e			call macro_dsp_valuehl 
4105				endm 
# End of macro FORTH_DSP_VALUEHL
4105				 
4105					if DEBUG_FORTH_WORDS_KEY 
4105						DMARK "MNU" 
4105 f5				push af  
4106 3a 1a 41			ld a, (.dmark)  
4109 32 6b ee			ld (debug_mark),a  
410c 3a 1b 41			ld a, (.dmark+1)  
410f 32 6c ee			ld (debug_mark+1),a  
4112 3a 1c 41			ld a, (.dmark+2)  
4115 32 6d ee			ld (debug_mark+2),a  
4118 18 03			jr .pastdmark  
411a ..			.dmark: db "MNU"  
411d f1			.pastdmark: pop af  
411e			endm  
# End of macro DMARK
411e						CALLMONITOR 
411e cd 6f ee			call debug_vector  
4121				endm  
# End of macro CALLMONITOR
4121					endif 
4121			 
4121 45					ld b, l	 
4122 05					dec b 
4123			 
4123					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4123 cd 05 1f			call macro_forth_dsp_pop 
4126				endm 
# End of macro FORTH_DSP_POP
4126			 
4126			 
4126					; go directly through the stack to pluck out the string pointers and build an array 
4126			 
4126			;		FORTH_DSP 
4126			 
4126					; hl contains top most stack item 
4126				 
4126 11 c1 e2				ld de, scratch 
4129			 
4129			.mbuild: 
4129			 
4129					FORTH_DSP_VALUEHL 
4129 cd 4d 1e			call macro_dsp_valuehl 
412c				endm 
# End of macro FORTH_DSP_VALUEHL
412c			 
412c					if DEBUG_FORTH_WORDS 
412c						DMARK "MN3" 
412c f5				push af  
412d 3a 41 41			ld a, (.dmark)  
4130 32 6b ee			ld (debug_mark),a  
4133 3a 42 41			ld a, (.dmark+1)  
4136 32 6c ee			ld (debug_mark+1),a  
4139 3a 43 41			ld a, (.dmark+2)  
413c 32 6d ee			ld (debug_mark+2),a  
413f 18 03			jr .pastdmark  
4141 ..			.dmark: db "MN3"  
4144 f1			.pastdmark: pop af  
4145			endm  
# End of macro DMARK
4145						CALLMONITOR 
4145 cd 6f ee			call debug_vector  
4148				endm  
# End of macro CALLMONITOR
4148					endif 
4148 eb					ex de, hl 
4149 73					ld (hl), e 
414a 23					inc hl 
414b 72					ld (hl), d 
414c 23					inc hl 
414d eb					ex de, hl 
414e			 
414e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
414e cd 05 1f			call macro_forth_dsp_pop 
4151				endm 
# End of macro FORTH_DSP_POP
4151			 
4151 10 d6				djnz .mbuild 
4153			 
4153					; done add term 
4153			 
4153 eb					ex de, hl 
4154 36 00				ld (hl), 0 
4156 23					inc hl 
4157 36 00				ld (hl), 0 
4159			 
4159				 
4159					 
4159 21 c1 e2				ld hl, scratch 
415c			 
415c					if DEBUG_FORTH_WORDS 
415c						DMARK "MNx" 
415c f5				push af  
415d 3a 71 41			ld a, (.dmark)  
4160 32 6b ee			ld (debug_mark),a  
4163 3a 72 41			ld a, (.dmark+1)  
4166 32 6c ee			ld (debug_mark+1),a  
4169 3a 73 41			ld a, (.dmark+2)  
416c 32 6d ee			ld (debug_mark+2),a  
416f 18 03			jr .pastdmark  
4171 ..			.dmark: db "MNx"  
4174 f1			.pastdmark: pop af  
4175			endm  
# End of macro DMARK
4175						CALLMONITOR 
4175 cd 6f ee			call debug_vector  
4178				endm  
# End of macro CALLMONITOR
4178					endif 
4178			 
4178			 
4178			 
4178 3e 00				ld a, 0 
417a cd eb 0b				call menu 
417d			 
417d			 
417d 6f					ld l, a 
417e 26 00				ld h, 0 
4180			 
4180					if DEBUG_FORTH_WORDS 
4180						DMARK "MNr" 
4180 f5				push af  
4181 3a 95 41			ld a, (.dmark)  
4184 32 6b ee			ld (debug_mark),a  
4187 3a 96 41			ld a, (.dmark+1)  
418a 32 6c ee			ld (debug_mark+1),a  
418d 3a 97 41			ld a, (.dmark+2)  
4190 32 6d ee			ld (debug_mark+2),a  
4193 18 03			jr .pastdmark  
4195 ..			.dmark: db "MNr"  
4198 f1			.pastdmark: pop af  
4199			endm  
# End of macro DMARK
4199						CALLMONITOR 
4199 cd 6f ee			call debug_vector  
419c				endm  
# End of macro CALLMONITOR
419c					endif 
419c			 
419c cd 56 1c				call forth_push_numhl 
419f			 
419f			 
419f			 
419f			 
419f				       NEXTW 
419f c3 03 20			jp macro_next 
41a2				endm 
# End of macro NEXTW
41a2			 
41a2			 
41a2			.ENDDISPLAY: 
41a2			 
41a2			; eof 
# End of file forth_words_display.asm
41a2			include "forth_words_str.asm" 
41a2			 
41a2			; | ## String Words 
41a2			 
41a2			.PTR:   
41a2			 
41a2				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
41a2 48				db WORD_SYS_CORE+52             
41a3 cf 41			dw .STYPE            
41a5 04				db 3 + 1 
41a6 .. 00			db "PTR",0              
41aa				endm 
# End of macro CWHEAD
41aa			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
41aa			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
41aa			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
41aa			 
41aa					if DEBUG_FORTH_WORDS_KEY 
41aa						DMARK "PTR" 
41aa f5				push af  
41ab 3a bf 41			ld a, (.dmark)  
41ae 32 6b ee			ld (debug_mark),a  
41b1 3a c0 41			ld a, (.dmark+1)  
41b4 32 6c ee			ld (debug_mark+1),a  
41b7 3a c1 41			ld a, (.dmark+2)  
41ba 32 6d ee			ld (debug_mark+2),a  
41bd 18 03			jr .pastdmark  
41bf ..			.dmark: db "PTR"  
41c2 f1			.pastdmark: pop af  
41c3			endm  
# End of macro DMARK
41c3						CALLMONITOR 
41c3 cd 6f ee			call debug_vector  
41c6				endm  
# End of macro CALLMONITOR
41c6					endif 
41c6					FORTH_DSP_VALUEHL 
41c6 cd 4d 1e			call macro_dsp_valuehl 
41c9				endm 
# End of macro FORTH_DSP_VALUEHL
41c9 cd 56 1c				call forth_push_numhl 
41cc			 
41cc			 
41cc					NEXTW 
41cc c3 03 20			jp macro_next 
41cf				endm 
# End of macro NEXTW
41cf			.STYPE: 
41cf				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
41cf 48				db WORD_SYS_CORE+52             
41d0 1e 42			dw .UPPER            
41d2 06				db 5 + 1 
41d3 .. 00			db "STYPE",0              
41d9				endm 
# End of macro CWHEAD
41d9			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
41d9					if DEBUG_FORTH_WORDS_KEY 
41d9						DMARK "STY" 
41d9 f5				push af  
41da 3a ee 41			ld a, (.dmark)  
41dd 32 6b ee			ld (debug_mark),a  
41e0 3a ef 41			ld a, (.dmark+1)  
41e3 32 6c ee			ld (debug_mark+1),a  
41e6 3a f0 41			ld a, (.dmark+2)  
41e9 32 6d ee			ld (debug_mark+2),a  
41ec 18 03			jr .pastdmark  
41ee ..			.dmark: db "STY"  
41f1 f1			.pastdmark: pop af  
41f2			endm  
# End of macro DMARK
41f2						CALLMONITOR 
41f2 cd 6f ee			call debug_vector  
41f5				endm  
# End of macro CALLMONITOR
41f5					endif 
41f5					FORTH_DSP 
41f5 cd 13 1e			call macro_forth_dsp 
41f8				endm 
# End of macro FORTH_DSP
41f8					;v5 FORTH_DSP_VALUE 
41f8			 
41f8 7e					ld a, (hl) 
41f9			 
41f9 f5					push af 
41fa			 
41fa			; Dont destroy TOS		FORTH_DSP_POP 
41fa			 
41fa f1					pop af 
41fb			 
41fb fe 01				cp DS_TYPE_STR 
41fd 28 09				jr z, .typestr 
41ff			 
41ff fe 02				cp DS_TYPE_INUM 
4201 28 0a				jr z, .typeinum 
4203			 
4203 21 1c 42				ld hl, .tna 
4206 18 0a				jr .tpush 
4208			 
4208 21 18 42		.typestr:	ld hl, .tstr 
420b 18 05				jr .tpush 
420d 21 1a 42		.typeinum:	ld hl, .tinum 
4210 18 00				jr .tpush 
4212			 
4212			.tpush: 
4212			 
4212 cd c4 1c				call forth_push_str 
4215			 
4215					NEXTW 
4215 c3 03 20			jp macro_next 
4218				endm 
# End of macro NEXTW
4218 .. 00		.tstr:	db "s",0 
421a .. 00		.tinum:  db "i",0 
421c .. 00		.tna:   db "?", 0 
421e			 
421e			 
421e			.UPPER: 
421e				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
421e 48				db WORD_SYS_CORE+52             
421f 59 42			dw .LOWER            
4221 06				db 5 + 1 
4222 .. 00			db "UPPER",0              
4228				endm 
# End of macro CWHEAD
4228			; | UPPER ( s -- s ) Upper case string s  | DONE 
4228					if DEBUG_FORTH_WORDS_KEY 
4228						DMARK "UPR" 
4228 f5				push af  
4229 3a 3d 42			ld a, (.dmark)  
422c 32 6b ee			ld (debug_mark),a  
422f 3a 3e 42			ld a, (.dmark+1)  
4232 32 6c ee			ld (debug_mark+1),a  
4235 3a 3f 42			ld a, (.dmark+2)  
4238 32 6d ee			ld (debug_mark+2),a  
423b 18 03			jr .pastdmark  
423d ..			.dmark: db "UPR"  
4240 f1			.pastdmark: pop af  
4241			endm  
# End of macro DMARK
4241						CALLMONITOR 
4241 cd 6f ee			call debug_vector  
4244				endm  
# End of macro CALLMONITOR
4244					endif 
4244			 
4244					FORTH_DSP 
4244 cd 13 1e			call macro_forth_dsp 
4247				endm 
# End of macro FORTH_DSP
4247					 
4247			; TODO check is string type 
4247			 
4247					FORTH_DSP_VALUEHL 
4247 cd 4d 1e			call macro_dsp_valuehl 
424a				endm 
# End of macro FORTH_DSP_VALUEHL
424a			; get pointer to string in hl 
424a			 
424a 7e			.toup:		ld a, (hl) 
424b fe 00				cp 0 
424d 28 07				jr z, .toupdone 
424f			 
424f cd 54 11				call to_upper 
4252			 
4252 77					ld (hl), a 
4253 23					inc hl 
4254 18 f4				jr .toup 
4256			 
4256					 
4256			 
4256			 
4256			; for each char convert to upper 
4256					 
4256			.toupdone: 
4256			 
4256			 
4256					NEXTW 
4256 c3 03 20			jp macro_next 
4259				endm 
# End of macro NEXTW
4259			.LOWER: 
4259				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4259 48				db WORD_SYS_CORE+52             
425a 94 42			dw .TCASE            
425c 06				db 5 + 1 
425d .. 00			db "LOWER",0              
4263				endm 
# End of macro CWHEAD
4263			; | LOWER ( s -- s ) Lower case string s  | DONE 
4263					if DEBUG_FORTH_WORDS_KEY 
4263						DMARK "LWR" 
4263 f5				push af  
4264 3a 78 42			ld a, (.dmark)  
4267 32 6b ee			ld (debug_mark),a  
426a 3a 79 42			ld a, (.dmark+1)  
426d 32 6c ee			ld (debug_mark+1),a  
4270 3a 7a 42			ld a, (.dmark+2)  
4273 32 6d ee			ld (debug_mark+2),a  
4276 18 03			jr .pastdmark  
4278 ..			.dmark: db "LWR"  
427b f1			.pastdmark: pop af  
427c			endm  
# End of macro DMARK
427c						CALLMONITOR 
427c cd 6f ee			call debug_vector  
427f				endm  
# End of macro CALLMONITOR
427f					endif 
427f			 
427f					FORTH_DSP 
427f cd 13 1e			call macro_forth_dsp 
4282				endm 
# End of macro FORTH_DSP
4282					 
4282			; TODO check is string type 
4282			 
4282					FORTH_DSP_VALUEHL 
4282 cd 4d 1e			call macro_dsp_valuehl 
4285				endm 
# End of macro FORTH_DSP_VALUEHL
4285			; get pointer to string in hl 
4285			 
4285 7e			.tolow:		ld a, (hl) 
4286 fe 00				cp 0 
4288 28 07				jr z, .tolowdone 
428a			 
428a cd 5d 11				call to_lower 
428d			 
428d 77					ld (hl), a 
428e 23					inc hl 
428f 18 f4				jr .tolow 
4291			 
4291					 
4291			 
4291			 
4291			; for each char convert to low 
4291					 
4291			.tolowdone: 
4291					NEXTW 
4291 c3 03 20			jp macro_next 
4294				endm 
# End of macro NEXTW
4294			.TCASE: 
4294				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4294 48				db WORD_SYS_CORE+52             
4295 ca 43			dw .SUBSTR            
4297 06				db 5 + 1 
4298 .. 00			db "TCASE",0              
429e				endm 
# End of macro CWHEAD
429e			; | TCASE ( s -- s ) Title case string s  | DONE 
429e					if DEBUG_FORTH_WORDS_KEY 
429e						DMARK "TCS" 
429e f5				push af  
429f 3a b3 42			ld a, (.dmark)  
42a2 32 6b ee			ld (debug_mark),a  
42a5 3a b4 42			ld a, (.dmark+1)  
42a8 32 6c ee			ld (debug_mark+1),a  
42ab 3a b5 42			ld a, (.dmark+2)  
42ae 32 6d ee			ld (debug_mark+2),a  
42b1 18 03			jr .pastdmark  
42b3 ..			.dmark: db "TCS"  
42b6 f1			.pastdmark: pop af  
42b7			endm  
# End of macro DMARK
42b7						CALLMONITOR 
42b7 cd 6f ee			call debug_vector  
42ba				endm  
# End of macro CALLMONITOR
42ba					endif 
42ba			 
42ba					FORTH_DSP 
42ba cd 13 1e			call macro_forth_dsp 
42bd				endm 
# End of macro FORTH_DSP
42bd					 
42bd			; TODO check is string type 
42bd			 
42bd					FORTH_DSP_VALUEHL 
42bd cd 4d 1e			call macro_dsp_valuehl 
42c0				endm 
# End of macro FORTH_DSP_VALUEHL
42c0			; get pointer to string in hl 
42c0			 
42c0					if DEBUG_FORTH_WORDS 
42c0						DMARK "TC1" 
42c0 f5				push af  
42c1 3a d5 42			ld a, (.dmark)  
42c4 32 6b ee			ld (debug_mark),a  
42c7 3a d6 42			ld a, (.dmark+1)  
42ca 32 6c ee			ld (debug_mark+1),a  
42cd 3a d7 42			ld a, (.dmark+2)  
42d0 32 6d ee			ld (debug_mark+2),a  
42d3 18 03			jr .pastdmark  
42d5 ..			.dmark: db "TC1"  
42d8 f1			.pastdmark: pop af  
42d9			endm  
# End of macro DMARK
42d9						CALLMONITOR 
42d9 cd 6f ee			call debug_vector  
42dc				endm  
# End of macro CALLMONITOR
42dc					endif 
42dc			 
42dc					; first time in turn to upper case first char 
42dc			 
42dc 7e					ld a, (hl) 
42dd c3 67 43				jp .totsiptou 
42e0			 
42e0			 
42e0 7e			.tot:		ld a, (hl) 
42e1 fe 00				cp 0 
42e3 ca ab 43				jp z, .totdone 
42e6			 
42e6					if DEBUG_FORTH_WORDS 
42e6						DMARK "TC2" 
42e6 f5				push af  
42e7 3a fb 42			ld a, (.dmark)  
42ea 32 6b ee			ld (debug_mark),a  
42ed 3a fc 42			ld a, (.dmark+1)  
42f0 32 6c ee			ld (debug_mark+1),a  
42f3 3a fd 42			ld a, (.dmark+2)  
42f6 32 6d ee			ld (debug_mark+2),a  
42f9 18 03			jr .pastdmark  
42fb ..			.dmark: db "TC2"  
42fe f1			.pastdmark: pop af  
42ff			endm  
# End of macro DMARK
42ff						CALLMONITOR 
42ff cd 6f ee			call debug_vector  
4302				endm  
# End of macro CALLMONITOR
4302					endif 
4302					; check to see if current char is a space 
4302			 
4302 fe 20				cp ' ' 
4304 28 21				jr z, .totsp 
4306 cd 5d 11				call to_lower 
4309					if DEBUG_FORTH_WORDS 
4309						DMARK "TC3" 
4309 f5				push af  
430a 3a 1e 43			ld a, (.dmark)  
430d 32 6b ee			ld (debug_mark),a  
4310 3a 1f 43			ld a, (.dmark+1)  
4313 32 6c ee			ld (debug_mark+1),a  
4316 3a 20 43			ld a, (.dmark+2)  
4319 32 6d ee			ld (debug_mark+2),a  
431c 18 03			jr .pastdmark  
431e ..			.dmark: db "TC3"  
4321 f1			.pastdmark: pop af  
4322			endm  
# End of macro DMARK
4322						CALLMONITOR 
4322 cd 6f ee			call debug_vector  
4325				endm  
# End of macro CALLMONITOR
4325					endif 
4325 18 63				jr .totnxt 
4327			 
4327			.totsp:         ; on a space, find next char which should be upper 
4327			 
4327					if DEBUG_FORTH_WORDS 
4327						DMARK "TC4" 
4327 f5				push af  
4328 3a 3c 43			ld a, (.dmark)  
432b 32 6b ee			ld (debug_mark),a  
432e 3a 3d 43			ld a, (.dmark+1)  
4331 32 6c ee			ld (debug_mark+1),a  
4334 3a 3e 43			ld a, (.dmark+2)  
4337 32 6d ee			ld (debug_mark+2),a  
433a 18 03			jr .pastdmark  
433c ..			.dmark: db "TC4"  
433f f1			.pastdmark: pop af  
4340			endm  
# End of macro DMARK
4340						CALLMONITOR 
4340 cd 6f ee			call debug_vector  
4343				endm  
# End of macro CALLMONITOR
4343					endif 
4343					;; 
4343			 
4343 fe 20				cp ' ' 
4345 20 20				jr nz, .totsiptou 
4347 23					inc hl 
4348 7e					ld a, (hl) 
4349					if DEBUG_FORTH_WORDS 
4349						DMARK "TC5" 
4349 f5				push af  
434a 3a 5e 43			ld a, (.dmark)  
434d 32 6b ee			ld (debug_mark),a  
4350 3a 5f 43			ld a, (.dmark+1)  
4353 32 6c ee			ld (debug_mark+1),a  
4356 3a 60 43			ld a, (.dmark+2)  
4359 32 6d ee			ld (debug_mark+2),a  
435c 18 03			jr .pastdmark  
435e ..			.dmark: db "TC5"  
4361 f1			.pastdmark: pop af  
4362			endm  
# End of macro DMARK
4362						CALLMONITOR 
4362 cd 6f ee			call debug_vector  
4365				endm  
# End of macro CALLMONITOR
4365					endif 
4365 18 c0				jr .totsp 
4367 fe 00		.totsiptou:    cp 0 
4369 28 40				jr z, .totdone 
436b					; not space and not zero term so upper case it 
436b cd 54 11				call to_upper 
436e			 
436e					if DEBUG_FORTH_WORDS 
436e						DMARK "TC6" 
436e f5				push af  
436f 3a 83 43			ld a, (.dmark)  
4372 32 6b ee			ld (debug_mark),a  
4375 3a 84 43			ld a, (.dmark+1)  
4378 32 6c ee			ld (debug_mark+1),a  
437b 3a 85 43			ld a, (.dmark+2)  
437e 32 6d ee			ld (debug_mark+2),a  
4381 18 03			jr .pastdmark  
4383 ..			.dmark: db "TC6"  
4386 f1			.pastdmark: pop af  
4387			endm  
# End of macro DMARK
4387						CALLMONITOR 
4387 cd 6f ee			call debug_vector  
438a				endm  
# End of macro CALLMONITOR
438a					endif 
438a			 
438a			 
438a			.totnxt: 
438a			 
438a 77					ld (hl), a 
438b 23					inc hl 
438c					if DEBUG_FORTH_WORDS 
438c						DMARK "TC7" 
438c f5				push af  
438d 3a a1 43			ld a, (.dmark)  
4390 32 6b ee			ld (debug_mark),a  
4393 3a a2 43			ld a, (.dmark+1)  
4396 32 6c ee			ld (debug_mark+1),a  
4399 3a a3 43			ld a, (.dmark+2)  
439c 32 6d ee			ld (debug_mark+2),a  
439f 18 03			jr .pastdmark  
43a1 ..			.dmark: db "TC7"  
43a4 f1			.pastdmark: pop af  
43a5			endm  
# End of macro DMARK
43a5						CALLMONITOR 
43a5 cd 6f ee			call debug_vector  
43a8				endm  
# End of macro CALLMONITOR
43a8					endif 
43a8 c3 e0 42				jp .tot 
43ab			 
43ab					 
43ab			 
43ab			 
43ab			; for each char convert to low 
43ab					 
43ab			.totdone: 
43ab					if DEBUG_FORTH_WORDS 
43ab						DMARK "TCd" 
43ab f5				push af  
43ac 3a c0 43			ld a, (.dmark)  
43af 32 6b ee			ld (debug_mark),a  
43b2 3a c1 43			ld a, (.dmark+1)  
43b5 32 6c ee			ld (debug_mark+1),a  
43b8 3a c2 43			ld a, (.dmark+2)  
43bb 32 6d ee			ld (debug_mark+2),a  
43be 18 03			jr .pastdmark  
43c0 ..			.dmark: db "TCd"  
43c3 f1			.pastdmark: pop af  
43c4			endm  
# End of macro DMARK
43c4						CALLMONITOR 
43c4 cd 6f ee			call debug_vector  
43c7				endm  
# End of macro CALLMONITOR
43c7					endif 
43c7					NEXTW 
43c7 c3 03 20			jp macro_next 
43ca				endm 
# End of macro NEXTW
43ca			 
43ca			.SUBSTR: 
43ca				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
43ca 48				db WORD_SYS_CORE+52             
43cb 28 44			dw .LEFT            
43cd 07				db 6 + 1 
43ce .. 00			db "SUBSTR",0              
43d5				endm 
# End of macro CWHEAD
43d5			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
43d5			 
43d5					if DEBUG_FORTH_WORDS_KEY 
43d5						DMARK "SST" 
43d5 f5				push af  
43d6 3a ea 43			ld a, (.dmark)  
43d9 32 6b ee			ld (debug_mark),a  
43dc 3a eb 43			ld a, (.dmark+1)  
43df 32 6c ee			ld (debug_mark+1),a  
43e2 3a ec 43			ld a, (.dmark+2)  
43e5 32 6d ee			ld (debug_mark+2),a  
43e8 18 03			jr .pastdmark  
43ea ..			.dmark: db "SST"  
43ed f1			.pastdmark: pop af  
43ee			endm  
# End of macro DMARK
43ee						CALLMONITOR 
43ee cd 6f ee			call debug_vector  
43f1				endm  
# End of macro CALLMONITOR
43f1					endif 
43f1			; TODO check string type 
43f1					FORTH_DSP_VALUEHL 
43f1 cd 4d 1e			call macro_dsp_valuehl 
43f4				endm 
# End of macro FORTH_DSP_VALUEHL
43f4			 
43f4 e5					push hl      ; string length 
43f5			 
43f5					FORTH_DSP_POP 
43f5 cd 05 1f			call macro_forth_dsp_pop 
43f8				endm 
# End of macro FORTH_DSP_POP
43f8			 
43f8					FORTH_DSP_VALUEHL 
43f8 cd 4d 1e			call macro_dsp_valuehl 
43fb				endm 
# End of macro FORTH_DSP_VALUEHL
43fb			 
43fb e5					push hl     ; start char 
43fc			 
43fc					FORTH_DSP_POP 
43fc cd 05 1f			call macro_forth_dsp_pop 
43ff				endm 
# End of macro FORTH_DSP_POP
43ff			 
43ff			 
43ff					FORTH_DSP_VALUE 
43ff cd 36 1e			call macro_forth_dsp_value 
4402				endm 
# End of macro FORTH_DSP_VALUE
4402			 
4402 d1					pop de    ; get start post offset 
4403			 
4403 19					add hl, de    ; starting offset 
4404			 
4404 c1					pop bc 
4405 c5					push bc      ; grab size of string 
4406			 
4406 e5					push hl    ; save string start  
4407			 
4407 26 00				ld h, 0 
4409 69					ld l, c 
440a 23					inc hl 
440b 23					inc hl 
440c			 
440c cd ae 12				call malloc 
440f				if DEBUG_FORTH_MALLOC_GUARD 
440f cc 42 4d				call z,malloc_error 
4412				endif 
4412			 
4412 eb					ex de, hl      ; save malloc area for string copy 
4413 e1					pop hl    ; get back source 
4414 c1					pop bc    ; get length of string back 
4415			 
4415 d5					push de    ; save malloc area for after we push 
4416 ed b0				ldir     ; copy substr 
4418			 
4418			 
4418 eb					ex de, hl 
4419 3e 00				ld a, 0 
441b 77					ld (hl), a   ; term substr 
441c			 
441c					 
441c e1					pop hl    ; get malloc so we can push it 
441d e5					push hl   ; save so we can free it afterwards 
441e			 
441e cd c4 1c				call forth_push_str 
4421			 
4421 e1					pop hl 
4422 cd 78 13				call free 
4425			 
4425					 
4425					 
4425			 
4425			 
4425					NEXTW 
4425 c3 03 20			jp macro_next 
4428				endm 
# End of macro NEXTW
4428			 
4428			.LEFT: 
4428				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4428 48				db WORD_SYS_CORE+52             
4429 50 44			dw .RIGHT            
442b 05				db 4 + 1 
442c .. 00			db "LEFT",0              
4431				endm 
# End of macro CWHEAD
4431			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4431					if DEBUG_FORTH_WORDS_KEY 
4431						DMARK "LEF" 
4431 f5				push af  
4432 3a 46 44			ld a, (.dmark)  
4435 32 6b ee			ld (debug_mark),a  
4438 3a 47 44			ld a, (.dmark+1)  
443b 32 6c ee			ld (debug_mark+1),a  
443e 3a 48 44			ld a, (.dmark+2)  
4441 32 6d ee			ld (debug_mark+2),a  
4444 18 03			jr .pastdmark  
4446 ..			.dmark: db "LEF"  
4449 f1			.pastdmark: pop af  
444a			endm  
# End of macro DMARK
444a						CALLMONITOR 
444a cd 6f ee			call debug_vector  
444d				endm  
# End of macro CALLMONITOR
444d					endif 
444d			 
444d					NEXTW 
444d c3 03 20			jp macro_next 
4450				endm 
# End of macro NEXTW
4450			.RIGHT: 
4450				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4450 48				db WORD_SYS_CORE+52             
4451 79 44			dw .STR2NUM            
4453 06				db 5 + 1 
4454 .. 00			db "RIGHT",0              
445a				endm 
# End of macro CWHEAD
445a			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
445a					if DEBUG_FORTH_WORDS_KEY 
445a						DMARK "RIG" 
445a f5				push af  
445b 3a 6f 44			ld a, (.dmark)  
445e 32 6b ee			ld (debug_mark),a  
4461 3a 70 44			ld a, (.dmark+1)  
4464 32 6c ee			ld (debug_mark+1),a  
4467 3a 71 44			ld a, (.dmark+2)  
446a 32 6d ee			ld (debug_mark+2),a  
446d 18 03			jr .pastdmark  
446f ..			.dmark: db "RIG"  
4472 f1			.pastdmark: pop af  
4473			endm  
# End of macro DMARK
4473						CALLMONITOR 
4473 cd 6f ee			call debug_vector  
4476				endm  
# End of macro CALLMONITOR
4476					endif 
4476			 
4476					NEXTW 
4476 c3 03 20			jp macro_next 
4479				endm 
# End of macro NEXTW
4479			 
4479			 
4479			.STR2NUM: 
4479				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4479 48				db WORD_SYS_CORE+52             
447a 05 45			dw .NUM2STR            
447c 08				db 7 + 1 
447d .. 00			db "STR2NUM",0              
4485				endm 
# End of macro CWHEAD
4485			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4485			 
4485			 
4485			; TODO STR type check to do 
4485					if DEBUG_FORTH_WORDS_KEY 
4485						DMARK "S2N" 
4485 f5				push af  
4486 3a 9a 44			ld a, (.dmark)  
4489 32 6b ee			ld (debug_mark),a  
448c 3a 9b 44			ld a, (.dmark+1)  
448f 32 6c ee			ld (debug_mark+1),a  
4492 3a 9c 44			ld a, (.dmark+2)  
4495 32 6d ee			ld (debug_mark+2),a  
4498 18 03			jr .pastdmark  
449a ..			.dmark: db "S2N"  
449d f1			.pastdmark: pop af  
449e			endm  
# End of macro DMARK
449e						CALLMONITOR 
449e cd 6f ee			call debug_vector  
44a1				endm  
# End of macro CALLMONITOR
44a1					endif 
44a1			 
44a1					;FORTH_DSP 
44a1					FORTH_DSP_VALUE 
44a1 cd 36 1e			call macro_forth_dsp_value 
44a4				endm 
# End of macro FORTH_DSP_VALUE
44a4					;inc hl 
44a4			 
44a4 eb					ex de, hl 
44a5					if DEBUG_FORTH_WORDS 
44a5						DMARK "S2a" 
44a5 f5				push af  
44a6 3a ba 44			ld a, (.dmark)  
44a9 32 6b ee			ld (debug_mark),a  
44ac 3a bb 44			ld a, (.dmark+1)  
44af 32 6c ee			ld (debug_mark+1),a  
44b2 3a bc 44			ld a, (.dmark+2)  
44b5 32 6d ee			ld (debug_mark+2),a  
44b8 18 03			jr .pastdmark  
44ba ..			.dmark: db "S2a"  
44bd f1			.pastdmark: pop af  
44be			endm  
# End of macro DMARK
44be						CALLMONITOR 
44be cd 6f ee			call debug_vector  
44c1				endm  
# End of macro CALLMONITOR
44c1					endif 
44c1 cd dc 11				call string_to_uint16 
44c4			 
44c4					if DEBUG_FORTH_WORDS 
44c4						DMARK "S2b" 
44c4 f5				push af  
44c5 3a d9 44			ld a, (.dmark)  
44c8 32 6b ee			ld (debug_mark),a  
44cb 3a da 44			ld a, (.dmark+1)  
44ce 32 6c ee			ld (debug_mark+1),a  
44d1 3a db 44			ld a, (.dmark+2)  
44d4 32 6d ee			ld (debug_mark+2),a  
44d7 18 03			jr .pastdmark  
44d9 ..			.dmark: db "S2b"  
44dc f1			.pastdmark: pop af  
44dd			endm  
# End of macro DMARK
44dd						CALLMONITOR 
44dd cd 6f ee			call debug_vector  
44e0				endm  
# End of macro CALLMONITOR
44e0					endif 
44e0			;		push hl 
44e0					FORTH_DSP_POP 
44e0 cd 05 1f			call macro_forth_dsp_pop 
44e3				endm 
# End of macro FORTH_DSP_POP
44e3			;		pop hl 
44e3					 
44e3					if DEBUG_FORTH_WORDS 
44e3						DMARK "S2b" 
44e3 f5				push af  
44e4 3a f8 44			ld a, (.dmark)  
44e7 32 6b ee			ld (debug_mark),a  
44ea 3a f9 44			ld a, (.dmark+1)  
44ed 32 6c ee			ld (debug_mark+1),a  
44f0 3a fa 44			ld a, (.dmark+2)  
44f3 32 6d ee			ld (debug_mark+2),a  
44f6 18 03			jr .pastdmark  
44f8 ..			.dmark: db "S2b"  
44fb f1			.pastdmark: pop af  
44fc			endm  
# End of macro DMARK
44fc						CALLMONITOR 
44fc cd 6f ee			call debug_vector  
44ff				endm  
# End of macro CALLMONITOR
44ff					endif 
44ff cd 56 1c				call forth_push_numhl	 
4502			 
4502				 
4502				       NEXTW 
4502 c3 03 20			jp macro_next 
4505				endm 
# End of macro NEXTW
4505			.NUM2STR: 
4505				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4505 48				db WORD_SYS_CORE+52             
4506 14 45			dw .CONCAT            
4508 08				db 7 + 1 
4509 .. 00			db "NUM2STR",0              
4511				endm 
# End of macro CWHEAD
4511			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4511			 
4511			;		; malloc a string to target 
4511			;		ld hl, 10     ; TODO max string size should be fine 
4511			;		call malloc 
4511			;		push hl    ; save malloc location 
4511			; 
4511			; 
4511			;; TODO check int type 
4511			;		FORTH_DSP_VALUEHL 
4511			;		ld a, l 
4511			;		call DispAToASCII   
4511			;;TODO need to chage above call to dump into string 
4511			; 
4511			; 
4511			 
4511				       NEXTW 
4511 c3 03 20			jp macro_next 
4514				endm 
# End of macro NEXTW
4514			 
4514			.CONCAT: 
4514				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4514 48				db WORD_SYS_CORE+52             
4515 c7 45			dw .FIND            
4517 07				db 6 + 1 
4518 .. 00			db "CONCAT",0              
451f				endm 
# End of macro CWHEAD
451f			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
451f			 
451f			; TODO check string type 
451f			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
451f			 
451f					if DEBUG_FORTH_WORDS_KEY 
451f						DMARK "CON" 
451f f5				push af  
4520 3a 34 45			ld a, (.dmark)  
4523 32 6b ee			ld (debug_mark),a  
4526 3a 35 45			ld a, (.dmark+1)  
4529 32 6c ee			ld (debug_mark+1),a  
452c 3a 36 45			ld a, (.dmark+2)  
452f 32 6d ee			ld (debug_mark+2),a  
4532 18 03			jr .pastdmark  
4534 ..			.dmark: db "CON"  
4537 f1			.pastdmark: pop af  
4538			endm  
# End of macro DMARK
4538						CALLMONITOR 
4538 cd 6f ee			call debug_vector  
453b				endm  
# End of macro CALLMONITOR
453b					endif 
453b			 
453b			 
453b					FORTH_DSP_VALUE 
453b cd 36 1e			call macro_forth_dsp_value 
453e				endm 
# End of macro FORTH_DSP_VALUE
453e e5					push hl   ; s2 
453f			 
453f					FORTH_DSP_POP 
453f cd 05 1f			call macro_forth_dsp_pop 
4542				endm 
# End of macro FORTH_DSP_POP
4542			 
4542					FORTH_DSP_VALUE 
4542 cd 36 1e			call macro_forth_dsp_value 
4545				endm 
# End of macro FORTH_DSP_VALUE
4545			 
4545 e5					push hl   ; s1 
4546			 
4546					FORTH_DSP_POP 
4546 cd 05 1f			call macro_forth_dsp_pop 
4549				endm 
# End of macro FORTH_DSP_POP
4549					 
4549			 
4549					; copy s1 
4549			 
4549				 
4549					; save ptr 
4549 e1					pop hl  
454a e5					push hl 
454b 3e 00				ld a, 0 
454d cd 50 12				call strlent 
4550					;inc hl    ; zer0 
4550 06 00				ld b, 0 
4552 4d					ld c, l 
4553 e1					pop hl		 
4554 11 c1 e2				ld de, scratch	 
4557					if DEBUG_FORTH_WORDS 
4557						DMARK "CO1" 
4557 f5				push af  
4558 3a 6c 45			ld a, (.dmark)  
455b 32 6b ee			ld (debug_mark),a  
455e 3a 6d 45			ld a, (.dmark+1)  
4561 32 6c ee			ld (debug_mark+1),a  
4564 3a 6e 45			ld a, (.dmark+2)  
4567 32 6d ee			ld (debug_mark+2),a  
456a 18 03			jr .pastdmark  
456c ..			.dmark: db "CO1"  
456f f1			.pastdmark: pop af  
4570			endm  
# End of macro DMARK
4570						CALLMONITOR 
4570 cd 6f ee			call debug_vector  
4573				endm  
# End of macro CALLMONITOR
4573					endif 
4573 ed b0				ldir 
4575			 
4575 e1					pop hl 
4576 e5					push hl 
4577 d5					push de 
4578			 
4578			 
4578 3e 00				ld a, 0 
457a cd 50 12				call strlent 
457d 23					inc hl    ; zer0 
457e 23					inc hl 
457f 06 00				ld b, 0 
4581 4d					ld c, l 
4582 d1					pop de 
4583 e1					pop hl		 
4584					if DEBUG_FORTH_WORDS 
4584						DMARK "CO2" 
4584 f5				push af  
4585 3a 99 45			ld a, (.dmark)  
4588 32 6b ee			ld (debug_mark),a  
458b 3a 9a 45			ld a, (.dmark+1)  
458e 32 6c ee			ld (debug_mark+1),a  
4591 3a 9b 45			ld a, (.dmark+2)  
4594 32 6d ee			ld (debug_mark+2),a  
4597 18 03			jr .pastdmark  
4599 ..			.dmark: db "CO2"  
459c f1			.pastdmark: pop af  
459d			endm  
# End of macro DMARK
459d						CALLMONITOR 
459d cd 6f ee			call debug_vector  
45a0				endm  
# End of macro CALLMONITOR
45a0					endif 
45a0 ed b0				ldir 
45a2			 
45a2			 
45a2			 
45a2 21 c1 e2				ld hl, scratch 
45a5					if DEBUG_FORTH_WORDS 
45a5						DMARK "CO5" 
45a5 f5				push af  
45a6 3a ba 45			ld a, (.dmark)  
45a9 32 6b ee			ld (debug_mark),a  
45ac 3a bb 45			ld a, (.dmark+1)  
45af 32 6c ee			ld (debug_mark+1),a  
45b2 3a bc 45			ld a, (.dmark+2)  
45b5 32 6d ee			ld (debug_mark+2),a  
45b8 18 03			jr .pastdmark  
45ba ..			.dmark: db "CO5"  
45bd f1			.pastdmark: pop af  
45be			endm  
# End of macro DMARK
45be						CALLMONITOR 
45be cd 6f ee			call debug_vector  
45c1				endm  
# End of macro CALLMONITOR
45c1					endif 
45c1			 
45c1 cd c4 1c				call forth_push_str 
45c4			 
45c4			 
45c4			 
45c4			 
45c4				       NEXTW 
45c4 c3 03 20			jp macro_next 
45c7				endm 
# End of macro NEXTW
45c7			 
45c7			 
45c7			.FIND: 
45c7				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
45c7 4b				db WORD_SYS_CORE+55             
45c8 85 46			dw .LEN            
45ca 05				db 4 + 1 
45cb .. 00			db "FIND",0              
45d0				endm 
# End of macro CWHEAD
45d0			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
45d0			 
45d0					if DEBUG_FORTH_WORDS_KEY 
45d0						DMARK "FND" 
45d0 f5				push af  
45d1 3a e5 45			ld a, (.dmark)  
45d4 32 6b ee			ld (debug_mark),a  
45d7 3a e6 45			ld a, (.dmark+1)  
45da 32 6c ee			ld (debug_mark+1),a  
45dd 3a e7 45			ld a, (.dmark+2)  
45e0 32 6d ee			ld (debug_mark+2),a  
45e3 18 03			jr .pastdmark  
45e5 ..			.dmark: db "FND"  
45e8 f1			.pastdmark: pop af  
45e9			endm  
# End of macro DMARK
45e9						CALLMONITOR 
45e9 cd 6f ee			call debug_vector  
45ec				endm  
# End of macro CALLMONITOR
45ec					endif 
45ec			 
45ec			; TODO check string type 
45ec					FORTH_DSP_VALUE 
45ec cd 36 1e			call macro_forth_dsp_value 
45ef				endm 
# End of macro FORTH_DSP_VALUE
45ef			 
45ef e5					push hl    
45f0 7e					ld a,(hl)    ; char to find   
45f1			; TODO change char to substr 
45f1			 
45f1 f5					push af 
45f2					 
45f2			 
45f2			 
45f2					if DEBUG_FORTH_WORDS 
45f2						DMARK "FN1" 
45f2 f5				push af  
45f3 3a 07 46			ld a, (.dmark)  
45f6 32 6b ee			ld (debug_mark),a  
45f9 3a 08 46			ld a, (.dmark+1)  
45fc 32 6c ee			ld (debug_mark+1),a  
45ff 3a 09 46			ld a, (.dmark+2)  
4602 32 6d ee			ld (debug_mark+2),a  
4605 18 03			jr .pastdmark  
4607 ..			.dmark: db "FN1"  
460a f1			.pastdmark: pop af  
460b			endm  
# End of macro DMARK
460b						CALLMONITOR 
460b cd 6f ee			call debug_vector  
460e				endm  
# End of macro CALLMONITOR
460e					endif 
460e			 
460e					FORTH_DSP_POP 
460e cd 05 1f			call macro_forth_dsp_pop 
4611				endm 
# End of macro FORTH_DSP_POP
4611			 
4611					; string to search 
4611			 
4611					FORTH_DSP_VALUE 
4611 cd 36 1e			call macro_forth_dsp_value 
4614				endm 
# End of macro FORTH_DSP_VALUE
4614			 
4614 d1					pop de  ; d is char to find  
4615			 
4615					if DEBUG_FORTH_WORDS 
4615						DMARK "FN2" 
4615 f5				push af  
4616 3a 2a 46			ld a, (.dmark)  
4619 32 6b ee			ld (debug_mark),a  
461c 3a 2b 46			ld a, (.dmark+1)  
461f 32 6c ee			ld (debug_mark+1),a  
4622 3a 2c 46			ld a, (.dmark+2)  
4625 32 6d ee			ld (debug_mark+2),a  
4628 18 03			jr .pastdmark  
462a ..			.dmark: db "FN2"  
462d f1			.pastdmark: pop af  
462e			endm  
# End of macro DMARK
462e						CALLMONITOR 
462e cd 6f ee			call debug_vector  
4631				endm  
# End of macro CALLMONITOR
4631					endif 
4631					 
4631 01 00 00				ld bc, 0 
4634 7e			.findchar:      ld a,(hl) 
4635 fe 00				cp 0   		 
4637 28 27				jr z, .finddone     
4639 ba					cp d 
463a 28 20				jr z, .foundchar 
463c 03					inc bc 
463d 23					inc hl 
463e					if DEBUG_FORTH_WORDS 
463e						DMARK "FN3" 
463e f5				push af  
463f 3a 53 46			ld a, (.dmark)  
4642 32 6b ee			ld (debug_mark),a  
4645 3a 54 46			ld a, (.dmark+1)  
4648 32 6c ee			ld (debug_mark+1),a  
464b 3a 55 46			ld a, (.dmark+2)  
464e 32 6d ee			ld (debug_mark+2),a  
4651 18 03			jr .pastdmark  
4653 ..			.dmark: db "FN3"  
4656 f1			.pastdmark: pop af  
4657			endm  
# End of macro DMARK
4657						CALLMONITOR 
4657 cd 6f ee			call debug_vector  
465a				endm  
# End of macro CALLMONITOR
465a					endif 
465a 18 d8				jr .findchar 
465c			 
465c			 
465c c5			.foundchar:	push bc 
465d e1					pop hl 
465e 18 03				jr .findexit 
4660			 
4660			 
4660							 
4660			 
4660			.finddone:     ; got to end of string with no find 
4660 21 00 00				ld hl, 0 
4663			.findexit: 
4663			 
4663					if DEBUG_FORTH_WORDS 
4663						DMARK "FNd" 
4663 f5				push af  
4664 3a 78 46			ld a, (.dmark)  
4667 32 6b ee			ld (debug_mark),a  
466a 3a 79 46			ld a, (.dmark+1)  
466d 32 6c ee			ld (debug_mark+1),a  
4670 3a 7a 46			ld a, (.dmark+2)  
4673 32 6d ee			ld (debug_mark+2),a  
4676 18 03			jr .pastdmark  
4678 ..			.dmark: db "FNd"  
467b f1			.pastdmark: pop af  
467c			endm  
# End of macro DMARK
467c						CALLMONITOR 
467c cd 6f ee			call debug_vector  
467f				endm  
# End of macro CALLMONITOR
467f					endif 
467f cd 56 1c			call forth_push_numhl 
4682			 
4682				       NEXTW 
4682 c3 03 20			jp macro_next 
4685				endm 
# End of macro NEXTW
4685			 
4685			.LEN: 
4685				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4685 4c				db WORD_SYS_CORE+56             
4686 ef 46			dw .ASC            
4688 06				db 5 + 1 
4689 .. 00			db "COUNT",0              
468f				endm 
# End of macro CWHEAD
468f			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
468f			 
468f					if DEBUG_FORTH_WORDS_KEY 
468f						DMARK "CNT" 
468f f5				push af  
4690 3a a4 46			ld a, (.dmark)  
4693 32 6b ee			ld (debug_mark),a  
4696 3a a5 46			ld a, (.dmark+1)  
4699 32 6c ee			ld (debug_mark+1),a  
469c 3a a6 46			ld a, (.dmark+2)  
469f 32 6d ee			ld (debug_mark+2),a  
46a2 18 03			jr .pastdmark  
46a4 ..			.dmark: db "CNT"  
46a7 f1			.pastdmark: pop af  
46a8			endm  
# End of macro DMARK
46a8						CALLMONITOR 
46a8 cd 6f ee			call debug_vector  
46ab				endm  
# End of macro CALLMONITOR
46ab					endif 
46ab			; TODO check string type 
46ab					FORTH_DSP_VALUE 
46ab cd 36 1e			call macro_forth_dsp_value 
46ae				endm 
# End of macro FORTH_DSP_VALUE
46ae			 
46ae			 
46ae					if DEBUG_FORTH_WORDS 
46ae						DMARK "CN?" 
46ae f5				push af  
46af 3a c3 46			ld a, (.dmark)  
46b2 32 6b ee			ld (debug_mark),a  
46b5 3a c4 46			ld a, (.dmark+1)  
46b8 32 6c ee			ld (debug_mark+1),a  
46bb 3a c5 46			ld a, (.dmark+2)  
46be 32 6d ee			ld (debug_mark+2),a  
46c1 18 03			jr .pastdmark  
46c3 ..			.dmark: db "CN?"  
46c6 f1			.pastdmark: pop af  
46c7			endm  
# End of macro DMARK
46c7						CALLMONITOR 
46c7 cd 6f ee			call debug_vector  
46ca				endm  
# End of macro CALLMONITOR
46ca					endif 
46ca cd 45 12				call strlenz 
46cd					if DEBUG_FORTH_WORDS 
46cd						DMARK "CNl" 
46cd f5				push af  
46ce 3a e2 46			ld a, (.dmark)  
46d1 32 6b ee			ld (debug_mark),a  
46d4 3a e3 46			ld a, (.dmark+1)  
46d7 32 6c ee			ld (debug_mark+1),a  
46da 3a e4 46			ld a, (.dmark+2)  
46dd 32 6d ee			ld (debug_mark+2),a  
46e0 18 03			jr .pastdmark  
46e2 ..			.dmark: db "CNl"  
46e5 f1			.pastdmark: pop af  
46e6			endm  
# End of macro DMARK
46e6						CALLMONITOR 
46e6 cd 6f ee			call debug_vector  
46e9				endm  
# End of macro CALLMONITOR
46e9					endif 
46e9			 
46e9 cd 56 1c				call forth_push_numhl 
46ec			 
46ec			 
46ec			 
46ec				       NEXTW 
46ec c3 03 20			jp macro_next 
46ef				endm 
# End of macro NEXTW
46ef			.ASC: 
46ef				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
46ef 4d				db WORD_SYS_CORE+57             
46f0 5d 47			dw .CHR            
46f2 04				db 3 + 1 
46f3 .. 00			db "ASC",0              
46f7				endm 
# End of macro CWHEAD
46f7			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
46f7					if DEBUG_FORTH_WORDS_KEY 
46f7						DMARK "ASC" 
46f7 f5				push af  
46f8 3a 0c 47			ld a, (.dmark)  
46fb 32 6b ee			ld (debug_mark),a  
46fe 3a 0d 47			ld a, (.dmark+1)  
4701 32 6c ee			ld (debug_mark+1),a  
4704 3a 0e 47			ld a, (.dmark+2)  
4707 32 6d ee			ld (debug_mark+2),a  
470a 18 03			jr .pastdmark  
470c ..			.dmark: db "ASC"  
470f f1			.pastdmark: pop af  
4710			endm  
# End of macro DMARK
4710						CALLMONITOR 
4710 cd 6f ee			call debug_vector  
4713				endm  
# End of macro CALLMONITOR
4713					endif 
4713					FORTH_DSP_VALUE 
4713 cd 36 1e			call macro_forth_dsp_value 
4716				endm 
# End of macro FORTH_DSP_VALUE
4716					;v5 FORTH_DSP_VALUE 
4716			;		inc hl      ; now at start of numeric as string 
4716			 
4716 e5					push hl 
4717			 
4717					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4717 cd 05 1f			call macro_forth_dsp_pop 
471a				endm 
# End of macro FORTH_DSP_POP
471a			 
471a e1					pop hl 
471b			 
471b					if DEBUG_FORTH_WORDS 
471b						DMARK "AS1" 
471b f5				push af  
471c 3a 30 47			ld a, (.dmark)  
471f 32 6b ee			ld (debug_mark),a  
4722 3a 31 47			ld a, (.dmark+1)  
4725 32 6c ee			ld (debug_mark+1),a  
4728 3a 32 47			ld a, (.dmark+2)  
472b 32 6d ee			ld (debug_mark+2),a  
472e 18 03			jr .pastdmark  
4730 ..			.dmark: db "AS1"  
4733 f1			.pastdmark: pop af  
4734			endm  
# End of macro DMARK
4734						CALLMONITOR 
4734 cd 6f ee			call debug_vector  
4737				endm  
# End of macro CALLMONITOR
4737					endif 
4737					; push the content of a onto the stack as a value 
4737			 
4737 7e					ld a,(hl)   ; get char 
4738 26 00				ld h,0 
473a 6f					ld l,a 
473b					if DEBUG_FORTH_WORDS 
473b						DMARK "AS2" 
473b f5				push af  
473c 3a 50 47			ld a, (.dmark)  
473f 32 6b ee			ld (debug_mark),a  
4742 3a 51 47			ld a, (.dmark+1)  
4745 32 6c ee			ld (debug_mark+1),a  
4748 3a 52 47			ld a, (.dmark+2)  
474b 32 6d ee			ld (debug_mark+2),a  
474e 18 03			jr .pastdmark  
4750 ..			.dmark: db "AS2"  
4753 f1			.pastdmark: pop af  
4754			endm  
# End of macro DMARK
4754						CALLMONITOR 
4754 cd 6f ee			call debug_vector  
4757				endm  
# End of macro CALLMONITOR
4757					endif 
4757 cd 56 1c				call forth_push_numhl 
475a			 
475a				       NEXTW 
475a c3 03 20			jp macro_next 
475d				endm 
# End of macro NEXTW
475d			 
475d			.CHR: 
475d				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
475d 4d				db WORD_SYS_CORE+57             
475e 99 47			dw .ENDSTR            
4760 04				db 3 + 1 
4761 .. 00			db "CHR",0              
4765				endm 
# End of macro CWHEAD
4765			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4765					if DEBUG_FORTH_WORDS_KEY 
4765						DMARK "CHR" 
4765 f5				push af  
4766 3a 7a 47			ld a, (.dmark)  
4769 32 6b ee			ld (debug_mark),a  
476c 3a 7b 47			ld a, (.dmark+1)  
476f 32 6c ee			ld (debug_mark+1),a  
4772 3a 7c 47			ld a, (.dmark+2)  
4775 32 6d ee			ld (debug_mark+2),a  
4778 18 03			jr .pastdmark  
477a ..			.dmark: db "CHR"  
477d f1			.pastdmark: pop af  
477e			endm  
# End of macro DMARK
477e						CALLMONITOR 
477e cd 6f ee			call debug_vector  
4781				endm  
# End of macro CALLMONITOR
4781					endif 
4781					FORTH_DSP_VALUEHL 
4781 cd 4d 1e			call macro_dsp_valuehl 
4784				endm 
# End of macro FORTH_DSP_VALUEHL
4784			 
4784					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4784 cd 05 1f			call macro_forth_dsp_pop 
4787				endm 
# End of macro FORTH_DSP_POP
4787			 
4787					; save asci byte as a zero term string and push string 
4787			 
4787 7d					ld a,l 
4788 32 c1 e2				ld (scratch), a 
478b			 
478b 3e 00				ld a, 0 
478d 32 c2 e2				ld (scratch+1), a 
4790			 
4790 21 c1 e2				ld hl, scratch 
4793 cd c4 1c				call forth_push_str 
4796			 
4796			 
4796				       NEXTW 
4796 c3 03 20			jp macro_next 
4799				endm 
# End of macro NEXTW
4799			 
4799			 
4799			 
4799			 
4799			.ENDSTR: 
4799			; eof 
4799			 
# End of file forth_words_str.asm
4799			include "forth_words_key.asm" 
4799			 
4799			; | ## Keyboard Words 
4799			 
4799			.KEY: 
4799				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4799 3e				db WORD_SYS_CORE+42             
479a c9 47			dw .WAITK            
479c 04				db 3 + 1 
479d .. 00			db "KEY",0              
47a1				endm 
# End of macro CWHEAD
47a1			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
47a1			 
47a1					if DEBUG_FORTH_WORDS_KEY 
47a1						DMARK "KEY" 
47a1 f5				push af  
47a2 3a b6 47			ld a, (.dmark)  
47a5 32 6b ee			ld (debug_mark),a  
47a8 3a b7 47			ld a, (.dmark+1)  
47ab 32 6c ee			ld (debug_mark+1),a  
47ae 3a b8 47			ld a, (.dmark+2)  
47b1 32 6d ee			ld (debug_mark+2),a  
47b4 18 03			jr .pastdmark  
47b6 ..			.dmark: db "KEY"  
47b9 f1			.pastdmark: pop af  
47ba			endm  
# End of macro DMARK
47ba						CALLMONITOR 
47ba cd 6f ee			call debug_vector  
47bd				endm  
# End of macro CALLMONITOR
47bd					endif 
47bd			; TODO currently waits 
47bd cd 87 65				call cin 
47c0					;call cin_wait 
47c0 6f					ld l, a 
47c1 26 00				ld h, 0 
47c3 cd 56 1c				call forth_push_numhl 
47c6					NEXTW 
47c6 c3 03 20			jp macro_next 
47c9				endm 
# End of macro NEXTW
47c9			.WAITK: 
47c9				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
47c9 3f				db WORD_SYS_CORE+43             
47ca fb 47			dw .ACCEPT            
47cc 06				db 5 + 1 
47cd .. 00			db "WAITK",0              
47d3				endm 
# End of macro CWHEAD
47d3			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
47d3					if DEBUG_FORTH_WORDS_KEY 
47d3						DMARK "WAI" 
47d3 f5				push af  
47d4 3a e8 47			ld a, (.dmark)  
47d7 32 6b ee			ld (debug_mark),a  
47da 3a e9 47			ld a, (.dmark+1)  
47dd 32 6c ee			ld (debug_mark+1),a  
47e0 3a ea 47			ld a, (.dmark+2)  
47e3 32 6d ee			ld (debug_mark+2),a  
47e6 18 03			jr .pastdmark  
47e8 ..			.dmark: db "WAI"  
47eb f1			.pastdmark: pop af  
47ec			endm  
# End of macro DMARK
47ec						CALLMONITOR 
47ec cd 6f ee			call debug_vector  
47ef				endm  
# End of macro CALLMONITOR
47ef					endif 
47ef cd 7f 65				call cin_wait 
47f2 6f					ld l, a 
47f3 26 00				ld h, 0 
47f5 cd 56 1c				call forth_push_numhl 
47f8					NEXTW 
47f8 c3 03 20			jp macro_next 
47fb				endm 
# End of macro NEXTW
47fb			.ACCEPT: 
47fb				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
47fb 40				db WORD_SYS_CORE+44             
47fc 59 48			dw .EDIT            
47fe 07				db 6 + 1 
47ff .. 00			db "ACCEPT",0              
4806				endm 
# End of macro CWHEAD
4806			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4806					; TODO crashes on push 
4806					if DEBUG_FORTH_WORDS_KEY 
4806						DMARK "ACC" 
4806 f5				push af  
4807 3a 1b 48			ld a, (.dmark)  
480a 32 6b ee			ld (debug_mark),a  
480d 3a 1c 48			ld a, (.dmark+1)  
4810 32 6c ee			ld (debug_mark+1),a  
4813 3a 1d 48			ld a, (.dmark+2)  
4816 32 6d ee			ld (debug_mark+2),a  
4819 18 03			jr .pastdmark  
481b ..			.dmark: db "ACC"  
481e f1			.pastdmark: pop af  
481f			endm  
# End of macro DMARK
481f						CALLMONITOR 
481f cd 6f ee			call debug_vector  
4822				endm  
# End of macro CALLMONITOR
4822					endif 
4822 21 bf e4				ld hl, os_input 
4825 3e 00				ld a, 0 
4827 77					ld (hl),a 
4828 3a 5e ea				ld a,(f_cursor_ptr) 
482b 16 64				ld d, 100 
482d 0e 00				ld c, 0 
482f 1e 28				ld e, 40 
4831 cd 14 0e				call input_str 
4834					; TODO perhaps do a type check and wrap in quotes if not a number 
4834 21 bf e4				ld hl, os_input 
4837					if DEBUG_FORTH_WORDS 
4837						DMARK "AC1" 
4837 f5				push af  
4838 3a 4c 48			ld a, (.dmark)  
483b 32 6b ee			ld (debug_mark),a  
483e 3a 4d 48			ld a, (.dmark+1)  
4841 32 6c ee			ld (debug_mark+1),a  
4844 3a 4e 48			ld a, (.dmark+2)  
4847 32 6d ee			ld (debug_mark+2),a  
484a 18 03			jr .pastdmark  
484c ..			.dmark: db "AC1"  
484f f1			.pastdmark: pop af  
4850			endm  
# End of macro DMARK
4850						CALLMONITOR 
4850 cd 6f ee			call debug_vector  
4853				endm  
# End of macro CALLMONITOR
4853					endif 
4853 cd c4 1c				call forth_push_str 
4856					NEXTW 
4856 c3 03 20			jp macro_next 
4859				endm 
# End of macro NEXTW
4859			 
4859			.EDIT: 
4859				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4859 40				db WORD_SYS_CORE+44             
485a fb 48			dw .DEDIT            
485c 05				db 4 + 1 
485d .. 00			db "EDIT",0              
4862				endm 
# End of macro CWHEAD
4862			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4862			 
4862					; TODO does not copy from stack 
4862					if DEBUG_FORTH_WORDS_KEY 
4862						DMARK "EDT" 
4862 f5				push af  
4863 3a 77 48			ld a, (.dmark)  
4866 32 6b ee			ld (debug_mark),a  
4869 3a 78 48			ld a, (.dmark+1)  
486c 32 6c ee			ld (debug_mark+1),a  
486f 3a 79 48			ld a, (.dmark+2)  
4872 32 6d ee			ld (debug_mark+2),a  
4875 18 03			jr .pastdmark  
4877 ..			.dmark: db "EDT"  
487a f1			.pastdmark: pop af  
487b			endm  
# End of macro DMARK
487b						CALLMONITOR 
487b cd 6f ee			call debug_vector  
487e				endm  
# End of macro CALLMONITOR
487e					endif 
487e			 
487e					;FORTH_DSP 
487e					FORTH_DSP_VALUEHL 
487e cd 4d 1e			call macro_dsp_valuehl 
4881				endm 
# End of macro FORTH_DSP_VALUEHL
4881			;		inc hl    ; TODO do type check 
4881			 
4881			;		call get_word_hl 
4881 e5					push hl 
4882					if DEBUG_FORTH_WORDS 
4882						DMARK "EDp" 
4882 f5				push af  
4883 3a 97 48			ld a, (.dmark)  
4886 32 6b ee			ld (debug_mark),a  
4889 3a 98 48			ld a, (.dmark+1)  
488c 32 6c ee			ld (debug_mark+1),a  
488f 3a 99 48			ld a, (.dmark+2)  
4892 32 6d ee			ld (debug_mark+2),a  
4895 18 03			jr .pastdmark  
4897 ..			.dmark: db "EDp"  
489a f1			.pastdmark: pop af  
489b			endm  
# End of macro DMARK
489b						CALLMONITOR 
489b cd 6f ee			call debug_vector  
489e				endm  
# End of macro CALLMONITOR
489e					endif 
489e				;	ld a, 0 
489e cd 45 12				call strlenz 
48a1 23					inc hl 
48a2			 
48a2 06 00				ld b, 0 
48a4 4d					ld c, l 
48a5			 
48a5 e1					pop hl 
48a6 11 bf e4				ld de, os_input 
48a9					if DEBUG_FORTH_WORDS_KEY 
48a9						DMARK "EDc" 
48a9 f5				push af  
48aa 3a be 48			ld a, (.dmark)  
48ad 32 6b ee			ld (debug_mark),a  
48b0 3a bf 48			ld a, (.dmark+1)  
48b3 32 6c ee			ld (debug_mark+1),a  
48b6 3a c0 48			ld a, (.dmark+2)  
48b9 32 6d ee			ld (debug_mark+2),a  
48bc 18 03			jr .pastdmark  
48be ..			.dmark: db "EDc"  
48c1 f1			.pastdmark: pop af  
48c2			endm  
# End of macro DMARK
48c2						CALLMONITOR 
48c2 cd 6f ee			call debug_vector  
48c5				endm  
# End of macro CALLMONITOR
48c5					endif 
48c5 ed b0				ldir 
48c7			 
48c7			 
48c7 21 bf e4				ld hl, os_input 
48ca					;ld a, 0 
48ca					;ld (hl),a 
48ca 3a 5e ea				ld a,(f_cursor_ptr) 
48cd 16 64				ld d, 100 
48cf 0e 00				ld c, 0 
48d1 1e 28				ld e, 40 
48d3 cd 14 0e				call input_str 
48d6					; TODO perhaps do a type check and wrap in quotes if not a number 
48d6 21 bf e4				ld hl, os_input 
48d9					if DEBUG_FORTH_WORDS 
48d9						DMARK "ED1" 
48d9 f5				push af  
48da 3a ee 48			ld a, (.dmark)  
48dd 32 6b ee			ld (debug_mark),a  
48e0 3a ef 48			ld a, (.dmark+1)  
48e3 32 6c ee			ld (debug_mark+1),a  
48e6 3a f0 48			ld a, (.dmark+2)  
48e9 32 6d ee			ld (debug_mark+2),a  
48ec 18 03			jr .pastdmark  
48ee ..			.dmark: db "ED1"  
48f1 f1			.pastdmark: pop af  
48f2			endm  
# End of macro DMARK
48f2						CALLMONITOR 
48f2 cd 6f ee			call debug_vector  
48f5				endm  
# End of macro CALLMONITOR
48f5					endif 
48f5 cd c4 1c				call forth_push_str 
48f8					NEXTW 
48f8 c3 03 20			jp macro_next 
48fb				endm 
# End of macro NEXTW
48fb			 
48fb			.DEDIT: 
48fb				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
48fb 40				db WORD_SYS_CORE+44             
48fc 5d 49			dw .ENDKEY            
48fe 06				db 5 + 1 
48ff .. 00			db "DEDIT",0              
4905				endm 
# End of macro CWHEAD
4905			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4905			 
4905					; TODO does not copy from stack 
4905					if DEBUG_FORTH_WORDS_KEY 
4905						DMARK "DED" 
4905 f5				push af  
4906 3a 1a 49			ld a, (.dmark)  
4909 32 6b ee			ld (debug_mark),a  
490c 3a 1b 49			ld a, (.dmark+1)  
490f 32 6c ee			ld (debug_mark+1),a  
4912 3a 1c 49			ld a, (.dmark+2)  
4915 32 6d ee			ld (debug_mark+2),a  
4918 18 03			jr .pastdmark  
491a ..			.dmark: db "DED"  
491d f1			.pastdmark: pop af  
491e			endm  
# End of macro DMARK
491e						CALLMONITOR 
491e cd 6f ee			call debug_vector  
4921				endm  
# End of macro CALLMONITOR
4921					endif 
4921			 
4921					;FORTH_DSP 
4921					FORTH_DSP_VALUEHL 
4921 cd 4d 1e			call macro_dsp_valuehl 
4924				endm 
# End of macro FORTH_DSP_VALUEHL
4924			;		inc hl    ; TODO do type check 
4924			 
4924			;		call get_word_hl 
4924 e5					push hl 
4925 e5					push hl 
4926					FORTH_DSP_POP 
4926 cd 05 1f			call macro_forth_dsp_pop 
4929				endm 
# End of macro FORTH_DSP_POP
4929 e1					pop hl 
492a					if DEBUG_FORTH_WORDS 
492a						DMARK "EDp" 
492a f5				push af  
492b 3a 3f 49			ld a, (.dmark)  
492e 32 6b ee			ld (debug_mark),a  
4931 3a 40 49			ld a, (.dmark+1)  
4934 32 6c ee			ld (debug_mark+1),a  
4937 3a 41 49			ld a, (.dmark+2)  
493a 32 6d ee			ld (debug_mark+2),a  
493d 18 03			jr .pastdmark  
493f ..			.dmark: db "EDp"  
4942 f1			.pastdmark: pop af  
4943			endm  
# End of macro DMARK
4943						CALLMONITOR 
4943 cd 6f ee			call debug_vector  
4946				endm  
# End of macro CALLMONITOR
4946					endif 
4946				;	ld a, 0 
4946 cd 45 12				call strlenz 
4949 23					inc hl 
494a			 
494a 06 00				ld b, 0 
494c 4d					ld c, l 
494d			 
494d e1					pop hl 
494e			 
494e					;ld a, 0 
494e					;ld (hl),a 
494e 3a 5e ea				ld a,(f_cursor_ptr) 
4951 16 64				ld d, 100 
4953 0e 00				ld c, 0 
4955 1e 28				ld e, 40 
4957 cd 14 0e				call input_str 
495a					; TODO perhaps do a type check and wrap in quotes if not a number 
495a					NEXTW 
495a c3 03 20			jp macro_next 
495d				endm 
# End of macro NEXTW
495d			 
495d			 
495d			.ENDKEY: 
495d			; eof 
495d			 
# End of file forth_words_key.asm
495d			include "forth_words_const.asm" 
495d			 
495d			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
495d			 
495d			 
495d			.SPITIME: 
495d				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
495d 77				db WORD_SYS_CORE+99             
495e 72 49			dw .VA            
4960 08				db 7 + 1 
4961 .. 00			db "SPITIME",0              
4969				endm 
# End of macro CWHEAD
4969			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
4969			; 
4969			; | If using BANK devices then leave as is. 
4969			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
4969			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
4969			 
4969 21 64 ea				ld hl, spi_clktime  
496c cd 56 1c				call forth_push_numhl 
496f			 
496f					NEXTW 
496f c3 03 20			jp macro_next 
4972				endm 
# End of macro NEXTW
4972			 
4972			 
4972			.VA: 
4972				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4972 77				db WORD_SYS_CORE+99             
4973 82 49			dw .SYMBOL            
4975 03				db 2 + 1 
4976 .. 00			db "VA",0              
4979				endm 
# End of macro CWHEAD
4979			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
4979 21 28 ea				ld hl, cli_var_array 
497c cd 56 1c				call forth_push_numhl 
497f			 
497f					NEXTW 
497f c3 03 20			jp macro_next 
4982				endm 
# End of macro NEXTW
4982			 
4982			.SYMBOL: 
4982				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4982 77				db WORD_SYS_CORE+99             
4983 8c 4a			dw .ENDCONST            
4985 07				db 6 + 1 
4986 .. 00			db "SYMBOL",0              
498d				endm 
# End of macro CWHEAD
498d			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
498d			; | 
498d			; | The value is the number reference and the final address is pushed to stack 
498d			 
498d			; | dw sym_table 
498d			; | dw nmi_vector 
498d			; | dw cli_autodisplay 
498d			; | dw cli_data_sp 
498d			; | dw cli_data_stack 
498d			; | dw cli_loop_sp 
498d			; | dw cli_loop_stack 
498d			; | dw cli_var_array 
498d			; | dw cursor_col 
498d			; | dw cursor_ptr 
498d			; | ; 10 
498d			; | dw cursor_row 
498d			; | dw debug_mark 
498d			; | dw display_fb0 
498d			; | dw display_fb1 
498d			; | dw display_fb2 
498d			; | dw display_fb3 
498d			; | dw display_fb_active 
498d			; | dw execscratch 
498d			; | dw f_cursor_ptr 
498d			; | dw hardware_word 
498d			; | ;20 
498d			; | dw input_at_cursor 
498d			; | dw input_at_pos 
498d			; | dw input_cur_flash 
498d			; | dw input_cur_onoff 
498d			; | dw input_cursor 
498d			; | dw input_display_size 
498d			; | dw input_len 
498d			; | dw input_ptr 
498d			; | dw input_size 
498d			; | dw input_start 
498d			; | ; 30 
498d			; | dw input_str 
498d			; | dw input_under_cursor 
498d			; | dw os_cli_cmd 
498d			; | dw os_cur_ptr 
498d			; | dw os_current_i 
498d			; | dw os_input 
498d			; | dw os_last_cmd 
498d			; | dw os_last_new_uword 
498d			; | dw debug_vector 
498d			; | dw os_view_hl 
498d			; | ;40 
498d			; | dw os_word_scratch 
498d			; | dw portbctl 
498d			; | dw portbdata 
498d			; | dw spi_cartdev 
498d			; | dw spi_cartdev2 
498d			; | dw spi_clktime 
498d			; | dw spi_device 
498d			; | dw spi_device_id 
498d			; | dw spi_portbyte 
498d			; | dw stackstore 
498d			; | ; 50 
498d			; | if STORAGE_SE 
498d			; | dw storage_actl 
498d			; | dw storage_adata 
498d			; | else 
498d			; | dw 0 
498d			; | dw 0 
498d			; | endif 
498d			; | dw storage_append 
498d			; | if STORAGE_SE 
498d			; | dw storage_bctl 
498d			; | else 
498d			; | dw 0 
498d			; | endif 
498d			; | dw store_bank_active 
498d			; | dw store_filecache 
498d			; | dw store_longread 
498d			; | dw store_openaddr 
498d			; | dw store_openext 
498d			; | dw store_openmaxext 
498d			; | ; 60 
498d			; | dw store_page 
498d			; | dw store_readbuf 
498d			; | dw store_readcont 
498d			; | dw store_readptr 
498d			; | dw store_tmpext 
498d			; | dw store_tmpid 
498d			; | dw store_tmppageid 
498d			; | dw malloc 
498d			; | dw free 
498d			; | dw cin 
498d			; | ; 70 
498d			; | dw cin_wait 
498d			; | dw forth_push_numhl 
498d			; | dw forth_push_str 
498d			 
498d					if DEBUG_FORTH_WORDS_KEY 
498d						DMARK "SYM" 
498d f5				push af  
498e 3a a2 49			ld a, (.dmark)  
4991 32 6b ee			ld (debug_mark),a  
4994 3a a3 49			ld a, (.dmark+1)  
4997 32 6c ee			ld (debug_mark+1),a  
499a 3a a4 49			ld a, (.dmark+2)  
499d 32 6d ee			ld (debug_mark+2),a  
49a0 18 03			jr .pastdmark  
49a2 ..			.dmark: db "SYM"  
49a5 f1			.pastdmark: pop af  
49a6			endm  
# End of macro DMARK
49a6						CALLMONITOR 
49a6 cd 6f ee			call debug_vector  
49a9				endm  
# End of macro CALLMONITOR
49a9					endif 
49a9			 
49a9					FORTH_DSP_VALUEHL 
49a9 cd 4d 1e			call macro_dsp_valuehl 
49ac				endm 
# End of macro FORTH_DSP_VALUEHL
49ac			 
49ac 7d					ld a, l     
49ad			 
49ad			 
49ad					if DEBUG_FORTH_WORDS 
49ad						DMARK "SY1" 
49ad f5				push af  
49ae 3a c2 49			ld a, (.dmark)  
49b1 32 6b ee			ld (debug_mark),a  
49b4 3a c3 49			ld a, (.dmark+1)  
49b7 32 6c ee			ld (debug_mark+1),a  
49ba 3a c4 49			ld a, (.dmark+2)  
49bd 32 6d ee			ld (debug_mark+2),a  
49c0 18 03			jr .pastdmark  
49c2 ..			.dmark: db "SY1"  
49c5 f1			.pastdmark: pop af  
49c6			endm  
# End of macro DMARK
49c6						CALLMONITOR 
49c6 cd 6f ee			call debug_vector  
49c9				endm  
# End of macro CALLMONITOR
49c9					endif 
49c9					 
49c9 f5					push af	 
49ca					FORTH_DSP_POP 
49ca cd 05 1f			call macro_forth_dsp_pop 
49cd				endm 
# End of macro FORTH_DSP_POP
49cd f1					pop af 
49ce			 
49ce cb 27				sla a  
49d0				 
49d0					 
49d0					if DEBUG_FORTH_WORDS 
49d0						DMARK "SY" 
49d0 f5				push af  
49d1 3a e5 49			ld a, (.dmark)  
49d4 32 6b ee			ld (debug_mark),a  
49d7 3a e6 49			ld a, (.dmark+1)  
49da 32 6c ee			ld (debug_mark+1),a  
49dd 3a e7 49			ld a, (.dmark+2)  
49e0 32 6d ee			ld (debug_mark+2),a  
49e3 18 02			jr .pastdmark  
49e5 ..			.dmark: db "SY"  
49e7 f1			.pastdmark: pop af  
49e8			endm  
# End of macro DMARK
49e8						CALLMONITOR 
49e8 cd 6f ee			call debug_vector  
49eb				endm  
# End of macro CALLMONITOR
49eb					endif 
49eb			 
49eb 21 fa 49				ld hl, sym_table 
49ee cd e7 0d				call addatohl 
49f1 cd 85 1f				call loadwordinhl 
49f4 cd 56 1c				call forth_push_numhl 
49f7			 
49f7			 
49f7				       NEXTW 
49f7 c3 03 20			jp macro_next 
49fa				endm 
# End of macro NEXTW
49fa			 
49fa			sym_table: 
49fa			 
49fa			; 0 
49fa fa 49		dw sym_table 
49fc 72 ee		dw nmi_vector 
49fe 3c ea		dw cli_autodisplay 
4a00 ee e9		dw cli_data_sp 
4a02 28 e8		dw cli_data_stack 
4a04 f0 e9		dw cli_loop_sp 
4a06 2a e9		dw cli_loop_stack 
4a08 28 ea		dw cli_var_array 
4a0a c5 eb		dw cursor_col 
4a0c c3 eb		dw cursor_ptr 
4a0e			; 10 
4a0e c4 eb		dw cursor_row 
4a10 6b ee		dw debug_mark 
4a12 b1 ed		dw display_fb0 
4a14 10 ed		dw display_fb1 
4a16 ce eb		dw display_fb2 
4a18 6f ec		dw display_fb3 
4a1a cc eb		dw display_fb_active 
4a1c c0 e3		dw execscratch 
4a1e 5e ea		dw f_cursor_ptr 
4a20 75 ee		dw hardware_word 
4a22			;20 
4a22 62 ee		dw input_at_cursor 
4a24 64 ee		dw input_at_pos 
4a26 60 ee		dw input_cur_flash 
4a28 5f ee		dw input_cur_onoff 
4a2a 55 ee		dw input_cursor 
4a2c 65 ee		dw input_display_size 
4a2e 5a ee		dw input_len 
4a30 69 ee		dw input_ptr 
4a32 66 ee		dw input_size 
4a34 67 ee		dw input_start 
4a36			; 30 
4a36 14 0e		dw input_str 
4a38 63 ee		dw input_under_cursor 
4a3a e8 e5		dw os_cli_cmd 
4a3c e4 e5		dw os_cur_ptr 
4a3e e6 e5		dw os_current_i 
4a40 bf e4		dw os_input 
4a42 e7 e6		dw os_last_cmd 
4a44 be e5		dw os_last_new_uword 
4a46 6f ee		dw debug_vector 
4a48 af e2		dw os_view_hl 
4a4a			;40 
4a4a c6 e5		dw os_word_scratch 
4a4c c3 00		dw portbctl 
4a4e c1 00		dw portbdata 
4a50 63 ea		dw spi_cartdev 
4a52 62 ea		dw spi_cartdev2 
4a54 64 ea		dw spi_clktime 
4a56 60 ea		dw spi_device 
4a58 5f ea		dw spi_device_id 
4a5a 61 ea		dw spi_portbyte 
4a5c a7 eb		dw stackstore 
4a5e			; 50 
4a5e			if STORAGE_SE 
4a5e			dw storage_actl 
4a5e			dw storage_adata 
4a5e			else 
4a5e 00 00		dw 0 
4a60 00 00		dw 0 
4a62			endif 
4a62 69 09		dw storage_append 
4a64			if STORAGE_SE 
4a64			dw storage_bctl 
4a64			else 
4a64 00 00		dw 0 
4a66			endif 
4a66 93 eb		dw store_bank_active 
4a68 67 ea		dw store_filecache 
4a6a 75 ea		dw store_longread 
4a6c 6b ea		dw store_openaddr 
4a6e 6a ea		dw store_openext 
4a70 69 ea		dw store_openmaxext 
4a72			; 60 
4a72 7a ea		dw store_page 
4a74 76 ea		dw store_readbuf 
4a76 6d ea		dw store_readcont 
4a78 78 ea		dw store_readptr 
4a7a 6d ea		dw store_tmpext 
4a7c 6e ea		dw store_tmpid 
4a7e 65 ea		dw store_tmppageid 
4a80 ae 12		dw malloc 
4a82 78 13		dw free 
4a84 87 65		dw cin 
4a86			; 70 
4a86 7f 65		dw cin_wait 
4a88 56 1c		dw forth_push_numhl 
4a8a c4 1c		dw forth_push_str 
4a8c			 
4a8c			 
4a8c			.ENDCONST: 
4a8c			 
4a8c			; eof 
4a8c			 
4a8c			 
# End of file forth_words_const.asm
4a8c			 
4a8c			if STORAGE_SE 
4a8c			   	include "forth_words_storage.asm" 
4a8c			endif 
4a8c				include "forth_words_device.asm" 
4a8c			; Device related words 
4a8c			 
4a8c			; | ## Device Words 
4a8c			 
4a8c			;if SOUND_ENABLE 
4a8c			;.NOTE: 
4a8c			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4a8c			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4a8c			;		if DEBUG_FORTH_WORDS_KEY 
4a8c			;			DMARK "NTE" 
4a8c			;			CALLMONITOR 
4a8c			;		endif 
4a8c			; 
4a8c			;	 
4a8c			; 
4a8c			;		NEXTW 
4a8c			;.AFTERSOUND: 
4a8c			;endif 
4a8c			 
4a8c			 
4a8c			USE_GPIO: equ 0 
4a8c			 
4a8c			if USE_GPIO 
4a8c			.GP1: 
4a8c				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4a8c			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4a8c					NEXTW 
4a8c			.GP2: 
4a8c				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4a8c			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4a8c			 
4a8c					NEXTW 
4a8c			 
4a8c			.GP3: 
4a8c				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4a8c			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4a8c			 
4a8c					NEXTW 
4a8c			 
4a8c			.GP4: 
4a8c				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4a8c			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4a8c			 
4a8c					NEXTW 
4a8c			.SIN: 
4a8c			 
4a8c			 
4a8c			endif 
4a8c			 
4a8c			 
4a8c				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4a8c 33				db WORD_SYS_CORE+31             
4a8d c1 4a			dw .SOUT            
4a8f 03				db 2 + 1 
4a90 .. 00			db "IN",0              
4a93				endm 
# End of macro CWHEAD
4a93			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4a93					if DEBUG_FORTH_WORDS_KEY 
4a93						DMARK "IN." 
4a93 f5				push af  
4a94 3a a8 4a			ld a, (.dmark)  
4a97 32 6b ee			ld (debug_mark),a  
4a9a 3a a9 4a			ld a, (.dmark+1)  
4a9d 32 6c ee			ld (debug_mark+1),a  
4aa0 3a aa 4a			ld a, (.dmark+2)  
4aa3 32 6d ee			ld (debug_mark+2),a  
4aa6 18 03			jr .pastdmark  
4aa8 ..			.dmark: db "IN."  
4aab f1			.pastdmark: pop af  
4aac			endm  
# End of macro DMARK
4aac						CALLMONITOR 
4aac cd 6f ee			call debug_vector  
4aaf				endm  
# End of macro CALLMONITOR
4aaf					endif 
4aaf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aaf cd 4d 1e			call macro_dsp_valuehl 
4ab2				endm 
# End of macro FORTH_DSP_VALUEHL
4ab2			 
4ab2 e5					push hl 
4ab3			 
4ab3					; destroy value TOS 
4ab3			 
4ab3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ab3 cd 05 1f			call macro_forth_dsp_pop 
4ab6				endm 
# End of macro FORTH_DSP_POP
4ab6			 
4ab6					; one value on hl get other one back 
4ab6			 
4ab6 c1					pop bc 
4ab7			 
4ab7					; do the sub 
4ab7			;		ex de, hl 
4ab7			 
4ab7 ed 68				in l,(c) 
4ab9			 
4ab9					; save it 
4ab9			 
4ab9 26 00				ld h,0 
4abb			 
4abb					; TODO push value back onto stack for another op etc 
4abb			 
4abb cd 56 1c				call forth_push_numhl 
4abe					NEXTW 
4abe c3 03 20			jp macro_next 
4ac1				endm 
# End of macro NEXTW
4ac1			.SOUT: 
4ac1				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4ac1 34				db WORD_SYS_CORE+32             
4ac2 14 4b			dw .SPIO            
4ac4 04				db 3 + 1 
4ac5 .. 00			db "OUT",0              
4ac9				endm 
# End of macro CWHEAD
4ac9			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4ac9					if DEBUG_FORTH_WORDS_KEY 
4ac9						DMARK "OUT" 
4ac9 f5				push af  
4aca 3a de 4a			ld a, (.dmark)  
4acd 32 6b ee			ld (debug_mark),a  
4ad0 3a df 4a			ld a, (.dmark+1)  
4ad3 32 6c ee			ld (debug_mark+1),a  
4ad6 3a e0 4a			ld a, (.dmark+2)  
4ad9 32 6d ee			ld (debug_mark+2),a  
4adc 18 03			jr .pastdmark  
4ade ..			.dmark: db "OUT"  
4ae1 f1			.pastdmark: pop af  
4ae2			endm  
# End of macro DMARK
4ae2						CALLMONITOR 
4ae2 cd 6f ee			call debug_vector  
4ae5				endm  
# End of macro CALLMONITOR
4ae5					endif 
4ae5			 
4ae5					; get port 
4ae5			 
4ae5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ae5 cd 4d 1e			call macro_dsp_valuehl 
4ae8				endm 
# End of macro FORTH_DSP_VALUEHL
4ae8			 
4ae8 e5					push hl 
4ae9			 
4ae9					; destroy value TOS 
4ae9			 
4ae9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ae9 cd 05 1f			call macro_forth_dsp_pop 
4aec				endm 
# End of macro FORTH_DSP_POP
4aec			 
4aec					; get byte to send 
4aec			 
4aec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aec cd 4d 1e			call macro_dsp_valuehl 
4aef				endm 
# End of macro FORTH_DSP_VALUEHL
4aef			 
4aef			;		push hl 
4aef			 
4aef					; destroy value TOS 
4aef			 
4aef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aef cd 05 1f			call macro_forth_dsp_pop 
4af2				endm 
# End of macro FORTH_DSP_POP
4af2			 
4af2					; one value on hl get other one back 
4af2			 
4af2			;		pop hl 
4af2			 
4af2 c1					pop bc 
4af3			 
4af3					if DEBUG_FORTH_WORDS 
4af3						DMARK "OUT" 
4af3 f5				push af  
4af4 3a 08 4b			ld a, (.dmark)  
4af7 32 6b ee			ld (debug_mark),a  
4afa 3a 09 4b			ld a, (.dmark+1)  
4afd 32 6c ee			ld (debug_mark+1),a  
4b00 3a 0a 4b			ld a, (.dmark+2)  
4b03 32 6d ee			ld (debug_mark+2),a  
4b06 18 03			jr .pastdmark  
4b08 ..			.dmark: db "OUT"  
4b0b f1			.pastdmark: pop af  
4b0c			endm  
# End of macro DMARK
4b0c						CALLMONITOR 
4b0c cd 6f ee			call debug_vector  
4b0f				endm  
# End of macro CALLMONITOR
4b0f					endif 
4b0f			 
4b0f ed 69				out (c), l 
4b11			 
4b11					NEXTW 
4b11 c3 03 20			jp macro_next 
4b14				endm 
# End of macro NEXTW
4b14			 
4b14			 
4b14			.SPIO: 
4b14			 
4b14			if STORAGE_SE 
4b14				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4b14			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4b14			 
4b14					call spi_ce_low 
4b14			    NEXTW 
4b14			 
4b14			.SPICEH: 
4b14				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4b14			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4b14			 
4b14					call spi_ce_high 
4b14			    NEXTW 
4b14			 
4b14			 
4b14			.SPIOb: 
4b14			 
4b14				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4b14			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4b14			 
4b14					if DEBUG_FORTH_WORDS_KEY 
4b14						DMARK "SPo" 
4b14						CALLMONITOR 
4b14					endif 
4b14					; get port 
4b14			 
4b14			 
4b14					; get byte to send 
4b14			 
4b14					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b14			 
4b14			;		push hl    ; u1  
4b14			 
4b14					; destroy value TOS 
4b14			 
4b14					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b14			 
4b14					; one value on hl get other one back 
4b14			 
4b14			;		pop hl   ; u2 - addr 
4b14			 
4b14					; TODO Send SPI byte 
4b14			 
4b14			;		push hl 
4b14			;		call spi_ce_low 
4b14			;		pop hl 
4b14					ld a, l 
4b14					call spi_send_byte 
4b14			;		call spi_ce_high 
4b14			 
4b14					NEXTW 
4b14			 
4b14			.SPII: 
4b14				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4b14			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4b14					if DEBUG_FORTH_WORDS_KEY 
4b14						DMARK "SPi" 
4b14						CALLMONITOR 
4b14					endif 
4b14			 
4b14					; TODO Get SPI byte 
4b14			 
4b14					call spi_read_byte 
4b14			 
4b14					if DEBUG_FORTH_WORDS 
4b14						DMARK "Si2" 
4b14						CALLMONITOR 
4b14					endif 
4b14					ld h, 0 
4b14					ld l, a 
4b14					if DEBUG_FORTH_WORDS 
4b14						DMARK "Si3" 
4b14						CALLMONITOR 
4b14					endif 
4b14					call forth_push_numhl 
4b14			 
4b14					NEXTW 
4b14			 
4b14			 
4b14			 
4b14			.SESEL: 
4b14				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4b14			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4b14					if DEBUG_FORTH_WORDS_KEY 
4b14						DMARK "BNK" 
4b14						CALLMONITOR 
4b14					endif 
4b14			 
4b14					ld a, 255 
4b14					ld (spi_cartdev), a 
4b14			 
4b14					; get bank 
4b14			 
4b14					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b14			 
4b14			;		push hl 
4b14			 
4b14					; destroy value TOS 
4b14			 
4b14					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b14			 
4b14					; one value on hl get other one back 
4b14			 
4b14			;		pop hl 
4b14			 
4b14			 
4b14					ld c, SPI_CE_HIGH 
4b14					ld b, '0'    ; human readable bank number 
4b14			 
4b14					ld a, l 
4b14			 
4b14					if DEBUG_FORTH_WORDS 
4b14						DMARK "BNK" 
4b14						CALLMONITOR 
4b14					endif 
4b14			 
4b14					; active low 
4b14			 
4b14					cp 0 
4b14					jr z, .bset 
4b14					cp 1 
4b14					jr nz, .b2 
4b14					res 0, c 
4b14					ld b, '1'    ; human readable bank number 
4b14			.b2:		cp 2 
4b14					jr nz, .b3 
4b14					res 1, c 
4b14					ld b, '2'    ; human readable bank number 
4b14			.b3:		cp 3 
4b14					jr nz, .b4 
4b14					res 2, c 
4b14					ld b, '3'    ; human readable bank number 
4b14			.b4:		cp 4 
4b14					jr nz, .b5 
4b14					res 3, c 
4b14					ld b, '4'    ; human readable bank number 
4b14			.b5:		cp 5 
4b14					jr nz, .bset 
4b14					res 4, c 
4b14					ld b, '5'    ; human readable bank number 
4b14			 
4b14			.bset: 
4b14					ld a, c 
4b14					ld (spi_device),a 
4b14					ld a, b 
4b14					ld (spi_device_id),a 
4b14					if DEBUG_FORTH_WORDS 
4b14						DMARK "BN2" 
4b14						CALLMONITOR 
4b14					endif 
4b14			 
4b14					; set default SPI clk pulse time as disabled for BANK use 
4b14			 
4b14					ld a, 0 
4b14					ld (spi_clktime), a 
4b14			 
4b14					NEXTW 
4b14			 
4b14			.CARTDEV: 
4b14				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4b14			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4b14					if DEBUG_FORTH_WORDS_KEY 
4b14						DMARK "CDV" 
4b14						CALLMONITOR 
4b14					endif 
4b14			 
4b14					; disable se storage bank selection 
4b14			 
4b14					ld a, SPI_CE_HIGH		; ce high 
4b14					ld (spi_device), a 
4b14			 
4b14					; get bank 
4b14			 
4b14					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b14			 
4b14			;		push hl 
4b14			 
4b14					; destroy value TOS 
4b14			 
4b14					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b14			 
4b14					; one value on hl get other one back 
4b14			 
4b14			;		pop hl 
4b14			 
4b14					; active low 
4b14			 
4b14					ld c, 255 
4b14			 
4b14					ld a, l 
4b14					if DEBUG_FORTH_WORDS 
4b14						DMARK "CDV" 
4b14						CALLMONITOR 
4b14					endif 
4b14					cp 0 
4b14					jr z, .cset 
4b14					cp 1 
4b14					jr nz, .c2 
4b14					res 0, c 
4b14			.c2:		cp 2 
4b14					jr nz, .c3 
4b14					res 1, c 
4b14			.c3:		cp 3 
4b14					jr nz, .c4 
4b14					res 2, c 
4b14			.c4:		cp 4 
4b14					jr nz, .c5 
4b14					res 3, c 
4b14			.c5:		cp 5 
4b14					jr nz, .c6 
4b14					res 4, c 
4b14			.c6:		cp 6 
4b14					jr nz, .c7 
4b14					res 5, c 
4b14			.c7:		cp 7 
4b14					jr nz, .c8 
4b14					res 6, c 
4b14			.c8:		cp 8 
4b14					jr nz, .cset 
4b14					res 7, c 
4b14			.cset:		ld a, c 
4b14					ld (spi_cartdev),a 
4b14			 
4b14					if DEBUG_FORTH_WORDS 
4b14						DMARK "CD2" 
4b14						CALLMONITOR 
4b14					endif 
4b14			 
4b14					; set default SPI clk pulse time as 10ms for CARTDEV use 
4b14			 
4b14					ld a, $0a 
4b14					ld (spi_clktime), a 
4b14					NEXTW 
4b14			endif 
4b14			 
4b14			.ENDDEVICE: 
4b14			; eof 
4b14			 
# End of file forth_words_device.asm
4b14			 
4b14			; var handler 
4b14			 
4b14			 
4b14			.VARS: 
4b14				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4b14 77				db WORD_SYS_CORE+99             
4b15 c5 4b			dw .V0            
4b17 04				db 3 + 1 
4b18 .. 00			db "VAR",0              
4b1c				endm 
# End of macro CWHEAD
4b1c			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4b1c			;| 
4b1c			;| The variable name should consist of a single letter. e.g. "a" 
4b1c			;! If a full string is passed then only the first char is looked at 
4b1c			;| Any other char could exceed bounds checks!  
4b1c			 
4b1c					if DEBUG_FORTH_WORDS_KEY 
4b1c						DMARK "VAR" 
4b1c f5				push af  
4b1d 3a 31 4b			ld a, (.dmark)  
4b20 32 6b ee			ld (debug_mark),a  
4b23 3a 32 4b			ld a, (.dmark+1)  
4b26 32 6c ee			ld (debug_mark+1),a  
4b29 3a 33 4b			ld a, (.dmark+2)  
4b2c 32 6d ee			ld (debug_mark+2),a  
4b2f 18 03			jr .pastdmark  
4b31 ..			.dmark: db "VAR"  
4b34 f1			.pastdmark: pop af  
4b35			endm  
# End of macro DMARK
4b35						CALLMONITOR 
4b35 cd 6f ee			call debug_vector  
4b38				endm  
# End of macro CALLMONITOR
4b38					endif 
4b38			 
4b38					FORTH_DSP_VALUEHL 
4b38 cd 4d 1e			call macro_dsp_valuehl 
4b3b				endm 
# End of macro FORTH_DSP_VALUEHL
4b3b			 
4b3b 7e					ld a, (hl)    ; get first char on of the string 
4b3c			 
4b3c			 
4b3c					if DEBUG_FORTH_WORDS 
4b3c						DMARK "VR1" 
4b3c f5				push af  
4b3d 3a 51 4b			ld a, (.dmark)  
4b40 32 6b ee			ld (debug_mark),a  
4b43 3a 52 4b			ld a, (.dmark+1)  
4b46 32 6c ee			ld (debug_mark+1),a  
4b49 3a 53 4b			ld a, (.dmark+2)  
4b4c 32 6d ee			ld (debug_mark+2),a  
4b4f 18 03			jr .pastdmark  
4b51 ..			.dmark: db "VR1"  
4b54 f1			.pastdmark: pop af  
4b55			endm  
# End of macro DMARK
4b55						CALLMONITOR 
4b55 cd 6f ee			call debug_vector  
4b58				endm  
# End of macro CALLMONITOR
4b58					endif 
4b58					 
4b58 f5					push af	 
4b59					FORTH_DSP_POP 
4b59 cd 05 1f			call macro_forth_dsp_pop 
4b5c				endm 
# End of macro FORTH_DSP_POP
4b5c f1					pop af 
4b5d			 
4b5d					; convert to upper 
4b5d			 
4b5d cd 54 11				call to_upper 
4b60					if DEBUG_FORTH_WORDS 
4b60						DMARK "Vaa" 
4b60 f5				push af  
4b61 3a 75 4b			ld a, (.dmark)  
4b64 32 6b ee			ld (debug_mark),a  
4b67 3a 76 4b			ld a, (.dmark+1)  
4b6a 32 6c ee			ld (debug_mark+1),a  
4b6d 3a 77 4b			ld a, (.dmark+2)  
4b70 32 6d ee			ld (debug_mark+2),a  
4b73 18 03			jr .pastdmark  
4b75 ..			.dmark: db "Vaa"  
4b78 f1			.pastdmark: pop af  
4b79			endm  
# End of macro DMARK
4b79						CALLMONITOR 
4b79 cd 6f ee			call debug_vector  
4b7c				endm  
# End of macro CALLMONITOR
4b7c					endif 
4b7c 06 41				ld b, 'A' 
4b7e 90					sub b			; set offset 
4b7f					if DEBUG_FORTH_WORDS 
4b7f						DMARK "Vbb" 
4b7f f5				push af  
4b80 3a 94 4b			ld a, (.dmark)  
4b83 32 6b ee			ld (debug_mark),a  
4b86 3a 95 4b			ld a, (.dmark+1)  
4b89 32 6c ee			ld (debug_mark+1),a  
4b8c 3a 96 4b			ld a, (.dmark+2)  
4b8f 32 6d ee			ld (debug_mark+2),a  
4b92 18 03			jr .pastdmark  
4b94 ..			.dmark: db "Vbb"  
4b97 f1			.pastdmark: pop af  
4b98			endm  
# End of macro DMARK
4b98						CALLMONITOR 
4b98 cd 6f ee			call debug_vector  
4b9b				endm  
# End of macro CALLMONITOR
4b9b					endif 
4b9b cb 27				sla a  
4b9d				 
4b9d					 
4b9d					if DEBUG_FORTH_WORDS 
4b9d						DMARK "VR2" 
4b9d f5				push af  
4b9e 3a b2 4b			ld a, (.dmark)  
4ba1 32 6b ee			ld (debug_mark),a  
4ba4 3a b3 4b			ld a, (.dmark+1)  
4ba7 32 6c ee			ld (debug_mark+1),a  
4baa 3a b4 4b			ld a, (.dmark+2)  
4bad 32 6d ee			ld (debug_mark+2),a  
4bb0 18 03			jr .pastdmark  
4bb2 ..			.dmark: db "VR2"  
4bb5 f1			.pastdmark: pop af  
4bb6			endm  
# End of macro DMARK
4bb6						CALLMONITOR 
4bb6 cd 6f ee			call debug_vector  
4bb9				endm  
# End of macro CALLMONITOR
4bb9					endif 
4bb9			 
4bb9 21 f4 e9				ld hl, cli_var_array2 
4bbc cd e7 0d				call addatohl 
4bbf cd 56 1c				call forth_push_numhl 
4bc2			 
4bc2			 
4bc2				       NEXTW 
4bc2 c3 03 20			jp macro_next 
4bc5				endm 
# End of macro NEXTW
4bc5			.V0: 
4bc5				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4bc5 78				db WORD_SYS_CORE+100             
4bc6 dd 4b			dw .V0Q            
4bc8 04				db 3 + 1 
4bc9 .. 00			db "V0!",0              
4bcd				endm 
# End of macro CWHEAD
4bcd			;| V0! ( u1 -- )  Store value to v0  | DONE 
4bcd			 
4bcd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bcd cd 4d 1e			call macro_dsp_valuehl 
4bd0				endm 
# End of macro FORTH_DSP_VALUEHL
4bd0			 
4bd0 11 28 ea				ld de, cli_var_array 
4bd3			 
4bd3 eb					ex de, hl 
4bd4 73					ld (hl), e 
4bd5 23					inc hl 
4bd6 72					ld (hl), d 
4bd7			 
4bd7					; destroy value TOS 
4bd7			 
4bd7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bd7 cd 05 1f			call macro_forth_dsp_pop 
4bda				endm 
# End of macro FORTH_DSP_POP
4bda			 
4bda				       NEXTW 
4bda c3 03 20			jp macro_next 
4bdd				endm 
# End of macro NEXTW
4bdd			.V0Q: 
4bdd				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4bdd 79				db WORD_SYS_CORE+101             
4bde ee 4b			dw .V1S            
4be0 04				db 3 + 1 
4be1 .. 00			db "V0@",0              
4be5				endm 
# End of macro CWHEAD
4be5			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4be5 2a 28 ea				ld hl, (cli_var_array) 
4be8 cd 56 1c				call forth_push_numhl 
4beb			 
4beb				       NEXTW 
4beb c3 03 20			jp macro_next 
4bee				endm 
# End of macro NEXTW
4bee			.V1S: 
4bee				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4bee 7a				db WORD_SYS_CORE+102             
4bef 06 4c			dw .V1Q            
4bf1 04				db 3 + 1 
4bf2 .. 00			db "V1!",0              
4bf6				endm 
# End of macro CWHEAD
4bf6			;| V1! ( u1 -- )  Store value to v1 | DONE 
4bf6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bf6 cd 4d 1e			call macro_dsp_valuehl 
4bf9				endm 
# End of macro FORTH_DSP_VALUEHL
4bf9			 
4bf9 11 2a ea				ld de, cli_var_array+2 
4bfc				 
4bfc eb					ex de, hl 
4bfd 73					ld (hl), e 
4bfe 23					inc hl 
4bff 72					ld (hl), d 
4c00			 
4c00					; destroy value TOS 
4c00			 
4c00					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c00 cd 05 1f			call macro_forth_dsp_pop 
4c03				endm 
# End of macro FORTH_DSP_POP
4c03				       NEXTW 
4c03 c3 03 20			jp macro_next 
4c06				endm 
# End of macro NEXTW
4c06			.V1Q: 
4c06				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4c06 7b				db WORD_SYS_CORE+103             
4c07 17 4c			dw .V2S            
4c09 04				db 3 + 1 
4c0a .. 00			db "V1@",0              
4c0e				endm 
# End of macro CWHEAD
4c0e			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4c0e 2a 2a ea				ld hl, (cli_var_array+2) 
4c11 cd 56 1c				call forth_push_numhl 
4c14				       NEXTW 
4c14 c3 03 20			jp macro_next 
4c17				endm 
# End of macro NEXTW
4c17			.V2S: 
4c17				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4c17 7c				db WORD_SYS_CORE+104             
4c18 2f 4c			dw .V2Q            
4c1a 04				db 3 + 1 
4c1b .. 00			db "V2!",0              
4c1f				endm 
# End of macro CWHEAD
4c1f			;| V2! ( u1 -- )  Store value to v2 | DONE 
4c1f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c1f cd 4d 1e			call macro_dsp_valuehl 
4c22				endm 
# End of macro FORTH_DSP_VALUEHL
4c22			 
4c22 11 2c ea				ld de, cli_var_array+4 
4c25				 
4c25 eb					ex de, hl 
4c26 73					ld (hl), e 
4c27 23					inc hl 
4c28 72					ld (hl), d 
4c29			 
4c29					; destroy value TOS 
4c29			 
4c29					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c29 cd 05 1f			call macro_forth_dsp_pop 
4c2c				endm 
# End of macro FORTH_DSP_POP
4c2c				       NEXTW 
4c2c c3 03 20			jp macro_next 
4c2f				endm 
# End of macro NEXTW
4c2f			.V2Q: 
4c2f				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4c2f 7d				db WORD_SYS_CORE+105             
4c30 40 4c			dw .V3S            
4c32 04				db 3 + 1 
4c33 .. 00			db "V2@",0              
4c37				endm 
# End of macro CWHEAD
4c37			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4c37 2a 2c ea				ld hl, (cli_var_array+4) 
4c3a cd 56 1c				call forth_push_numhl 
4c3d				       NEXTW 
4c3d c3 03 20			jp macro_next 
4c40				endm 
# End of macro NEXTW
4c40			.V3S: 
4c40				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4c40 7c				db WORD_SYS_CORE+104             
4c41 58 4c			dw .V3Q            
4c43 04				db 3 + 1 
4c44 .. 00			db "V3!",0              
4c48				endm 
# End of macro CWHEAD
4c48			;| V3! ( u1 -- )  Store value to v3 | DONE 
4c48					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c48 cd 4d 1e			call macro_dsp_valuehl 
4c4b				endm 
# End of macro FORTH_DSP_VALUEHL
4c4b			 
4c4b 11 2e ea				ld de, cli_var_array+6 
4c4e				 
4c4e eb					ex de, hl 
4c4f 73					ld (hl), e 
4c50 23					inc hl 
4c51 72					ld (hl), d 
4c52			 
4c52					; destroy value TOS 
4c52			 
4c52					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c52 cd 05 1f			call macro_forth_dsp_pop 
4c55				endm 
# End of macro FORTH_DSP_POP
4c55				       NEXTW 
4c55 c3 03 20			jp macro_next 
4c58				endm 
# End of macro NEXTW
4c58			.V3Q: 
4c58				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4c58 7d				db WORD_SYS_CORE+105             
4c59 69 4c			dw .END            
4c5b 04				db 3 + 1 
4c5c .. 00			db "V3@",0              
4c60				endm 
# End of macro CWHEAD
4c60			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4c60 2a 2e ea				ld hl, (cli_var_array+6) 
4c63 cd 56 1c				call forth_push_numhl 
4c66				       NEXTW 
4c66 c3 03 20			jp macro_next 
4c69				endm 
# End of macro NEXTW
4c69			 
4c69			 
4c69			 
4c69			 
4c69			 
4c69			; end of dict marker 
4c69			 
4c69 00			.END:    db WORD_SYS_END 
4c6a 00 00			dw 0 
4c6c 00				db 0 
4c6d			 
4c6d			; use to jp here for user dict words to save on macro expansion  
4c6d			 
4c6d			user_dict_next: 
4c6d				NEXTW 
4c6d c3 03 20			jp macro_next 
4c70				endm 
# End of macro NEXTW
4c70			 
4c70			 
4c70			user_exec: 
4c70				;    ld hl, <word code> 
4c70				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4c70				;    call forthexec 
4c70				;    jp user_dict_next   (NEXT) 
4c70			        ;    <word code bytes> 
4c70 eb				ex de, hl 
4c71 2a c2 e5			ld hl,(os_tok_ptr) 
4c74				 
4c74				FORTH_RSP_NEXT 
4c74 cd fd 1b			call macro_forth_rsp_next 
4c77				endm 
# End of macro FORTH_RSP_NEXT
4c77			 
4c77			if DEBUG_FORTH_UWORD 
4c77						DMARK "UEX" 
4c77 f5				push af  
4c78 3a 8c 4c			ld a, (.dmark)  
4c7b 32 6b ee			ld (debug_mark),a  
4c7e 3a 8d 4c			ld a, (.dmark+1)  
4c81 32 6c ee			ld (debug_mark+1),a  
4c84 3a 8e 4c			ld a, (.dmark+2)  
4c87 32 6d ee			ld (debug_mark+2),a  
4c8a 18 03			jr .pastdmark  
4c8c ..			.dmark: db "UEX"  
4c8f f1			.pastdmark: pop af  
4c90			endm  
# End of macro DMARK
4c90				CALLMONITOR 
4c90 cd 6f ee			call debug_vector  
4c93				endm  
# End of macro CALLMONITOR
4c93			endif 
4c93			 
4c93			 
4c93			 
4c93 eb				ex de, hl 
4c94 22 c2 e5			ld (os_tok_ptr), hl 
4c97				 
4c97				; Don't use next - Skips the first word in uword. 
4c97			 
4c97 c3 94 20			jp exec1 
4c9a			;	NEXT 
4c9a			 
4c9a			 
4c9a			; eof 
# End of file forth_wordsv4.asm
4c9a			endif 
4c9a			;;;;;;;;;;;;;; Debug code 
4c9a			 
4c9a			 
4c9a			;if DEBUG_FORTH_PARSE 
4c9a .. 00		.nowordfound: db "No match",0 
4ca3 .. 00		.compword:	db "Comparing word ",0 
4cb3 .. 00		.nextwordat:	db "Next word at",0 
4cc0 .. 00		.charmatch:	db "Char match",0 
4ccb			;endif 
4ccb			if DEBUG_FORTH_JP 
4ccb			.foundword:	db "Word match. Exec..",0 
4ccb			endif 
4ccb			;if DEBUG_FORTH_PUSH 
4ccb .. 00		.enddict:	db "Dict end. Push.",0 
4cdb .. 00		.push_str:	db "Pushing string",0 
4cea .. 00		.push_num:	db "Pushing number",0 
4cf9 .. 00		.data_sp:	db "SP:",0 
4cfd .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4d0f .. 00		.wordinde:	db "Word in DE (3/0):",0 
4d21 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4d33			;endif 
4d33			;if DEBUG_FORTH_MALLOC 
4d33 .. 00		.push_malloc:	db "Malloc address",0 
4d42			;endif 
4d42			 
4d42			 
4d42			 
4d42			; display malloc address and current data stack pointer  
4d42			 
4d42			malloc_error: 
4d42 d5				push de 
4d43 f5				push af 
4d44 e5				push hl 
4d45 cd ba 0b			call clear_display 
4d48 11 68 4d			ld de, .mallocerr 
4d4b 3e 00			ld a,0 
4d4d			;	ld de,os_word_scratch 
4d4d cd cd 0b			call str_at_display 
4d50 3e 11			ld a, display_row_1+17 
4d52 11 6b ee			ld de, debug_mark 
4d55 cd cd 0b			call str_at_display 
4d58 cd dd 0b			call update_display 
4d5b				;call break_point_state 
4d5b cd 7f 65			call cin_wait 
4d5e			 
4d5e			;	ld a, ' ' 
4d5e			;	ld (os_view_disable), a 
4d5e cd dd 15			call bp_on 
4d61 e1				pop hl 
4d62 f1				pop af 
4d63 d1				pop de	 
4d64				CALLMONITOR 
4d64 cd 6f ee			call debug_vector  
4d67				endm  
# End of macro CALLMONITOR
4d67 c9				ret 
4d68			 
4d68 .. 00		.mallocerr: 	db "Malloc Error",0 
4d75			;if DEBUG_FORTH_PUSH 
4d75			display_data_sp: 
4d75 f5				push af 
4d76			 
4d76				; see if disabled 
4d76			 
4d76			 
4d76 3a 6f ee			ld a, (debug_vector) 
4d79 fe c9			cp $C9  ; RET 
4d7b				;ld a, (os_view_disable) 
4d7b				;cp '*' 
4d7b 28 67			jr z, .skipdsp 
4d7d			 
4d7d e5				push hl 
4d7e e5				push hl 
4d7f e5			push hl 
4d80 cd ba 0b			call clear_display 
4d83 e1			pop hl 
4d84 7c				ld a,h 
4d85 21 c6 e5			ld hl, os_word_scratch 
4d88 cd e8 10			call hexout 
4d8b e1				pop hl 
4d8c 7d				ld a,l 
4d8d 21 c8 e5			ld hl, os_word_scratch+2 
4d90 cd e8 10			call hexout 
4d93 21 ca e5			ld hl, os_word_scratch+4 
4d96 3e 00			ld a,0 
4d98 77				ld (hl),a 
4d99 11 c6 e5			ld de,os_word_scratch 
4d9c 3e 28				ld a, display_row_2 
4d9e cd cd 0b				call str_at_display 
4da1 11 fd 4c			ld de, .wordinhl 
4da4 3e 00			ld a, display_row_1 
4da6			 
4da6 cd cd 0b				call str_at_display 
4da9 11 6b ee			ld de, debug_mark 
4dac 3e 11			ld a, display_row_1+17 
4dae			 
4dae cd cd 0b				call str_at_display 
4db1			 
4db1				; display current data stack pointer 
4db1 11 f9 4c			ld de,.data_sp 
4db4 3e 30				ld a, display_row_2 + 8 
4db6 cd cd 0b				call str_at_display 
4db9			 
4db9 2a ee e9			ld hl,(cli_data_sp) 
4dbc e5				push hl 
4dbd 7c				ld a,h 
4dbe 21 c6 e5			ld hl, os_word_scratch 
4dc1 cd e8 10			call hexout 
4dc4 e1				pop hl 
4dc5 7d				ld a,l 
4dc6 21 c8 e5			ld hl, os_word_scratch+2 
4dc9 cd e8 10			call hexout 
4dcc 21 ca e5			ld hl, os_word_scratch+4 
4dcf 3e 00			ld a,0 
4dd1 77				ld (hl),a 
4dd2 11 c6 e5			ld de,os_word_scratch 
4dd5 3e 33				ld a, display_row_2 + 11 
4dd7 cd cd 0b				call str_at_display 
4dda			 
4dda			 
4dda cd dd 0b			call update_display 
4ddd cd f2 0a			call delay1s 
4de0 cd f2 0a			call delay1s 
4de3 e1				pop hl 
4de4			.skipdsp: 
4de4 f1				pop af 
4de5 c9				ret 
4de6			 
4de6			display_data_malloc: 
4de6			 
4de6 f5				push af 
4de7 e5				push hl 
4de8 e5				push hl 
4de9 e5			push hl 
4dea cd ba 0b			call clear_display 
4ded e1			pop hl 
4dee 7c				ld a,h 
4def 21 c6 e5			ld hl, os_word_scratch 
4df2 cd e8 10			call hexout 
4df5 e1				pop hl 
4df6 7d				ld a,l 
4df7 21 c8 e5			ld hl, os_word_scratch+2 
4dfa cd e8 10			call hexout 
4dfd 21 ca e5			ld hl, os_word_scratch+4 
4e00 3e 00			ld a,0 
4e02 77				ld (hl),a 
4e03 11 c6 e5			ld de,os_word_scratch 
4e06 3e 28				ld a, display_row_2 
4e08 cd cd 0b				call str_at_display 
4e0b 11 33 4d			ld de, .push_malloc 
4e0e 3e 00			ld a, display_row_1 
4e10			 
4e10 cd cd 0b				call str_at_display 
4e13			 
4e13				; display current data stack pointer 
4e13 11 f9 4c			ld de,.data_sp 
4e16 3e 30				ld a, display_row_2 + 8 
4e18 cd cd 0b				call str_at_display 
4e1b			 
4e1b 2a ee e9			ld hl,(cli_data_sp) 
4e1e e5				push hl 
4e1f 7c				ld a,h 
4e20 21 c6 e5			ld hl, os_word_scratch 
4e23 cd e8 10			call hexout 
4e26 e1				pop hl 
4e27 7d				ld a,l 
4e28 21 c8 e5			ld hl, os_word_scratch+2 
4e2b cd e8 10			call hexout 
4e2e 21 ca e5			ld hl, os_word_scratch+4 
4e31 3e 00			ld a,0 
4e33 77				ld (hl),a 
4e34 11 c6 e5			ld de,os_word_scratch 
4e37 3e 33				ld a, display_row_2 + 11 
4e39 cd cd 0b				call str_at_display 
4e3c			 
4e3c cd dd 0b			call update_display 
4e3f cd f2 0a			call delay1s 
4e42 cd f2 0a			call delay1s 
4e45 e1				pop hl 
4e46 f1				pop af 
4e47 c9				ret 
4e48			;endif 
4e48			 
4e48			include "forth_autostart.asm" 
4e48			; list of commands to perform at system start up 
4e48			 
4e48			startcmds: 
4e48			;	dw test11 
4e48			;	dw test12 
4e48			;	dw test13 
4e48			;	dw test14 
4e48			;	dw test15 
4e48			;	dw test16 
4e48			;	dw test17 
4e48			;	dw ifthtest1 
4e48			;	dw ifthtest2 
4e48			;	dw ifthtest3 
4e48			;	dw mmtest1 
4e48			;	dw mmtest2 
4e48			;	dw mmtest3 
4e48			;	dw mmtest4 
4e48			;	dw mmtest5 
4e48			;	dw mmtest6 
4e48			;	dw iftest1 
4e48			;	dw iftest2 
4e48			;	dw iftest3 
4e48			;	dw looptest1 
4e48			;	dw looptest2 
4e48			;	dw test1 
4e48			;	dw test2 
4e48			;	dw test3 
4e48			;	dw test4 
4e48			;	dw game2r 
4e48			;	dw game2b1 
4e48			;	dw game2b2 
4e48			 
4e48				; start up words that are actually useful 
4e48			 
4e48			;    dw spi1 
4e48			;    dw spi2 
4e48			;    dw spi3 
4e48			;    dw spi4 
4e48			;    dw spi5 
4e48			;    dw spi6 
4e48			;    dw spi7 
4e48			; 
4e48			;    dw spi8 
4e48			;    dw spi9 
4e48			;    dw spi10 
4e48			 
4e48			; file editor 
4e48			;	dw edit1 
4e48			;	dw edit2 
4e48			;	dw edit3 
4e48			 
4e48			;	dw longread 
4e48 48 52			dw clrstack 
4e4a 7c 52			dw type 
4e4c			;	dw stest 
4e4c a1 52			dw strncpy 
4e4e			;	dw list 
4e4e 02 53			dw start1 
4e50 12 53			dw start2 
4e52			;	dw start3 
4e52			;	dw start3b 
4e52			;	dw start3c 
4e52			 
4e52				; (unit) testing words 
4e52			 
4e52			;	dw mtesta 
4e52			;	dw mtestb 
4e52			;	dw mtestc 
4e52			;	dw mtestd 
4e52			;	dw mteste 
4e52			 
4e52				; demo/game words 
4e52			 
4e52			;        dw game3w 
4e52			;        dw game3p 
4e52			;        dw game3sc 
4e52			;        dw game3vsi 
4e52			;        dw game3vs 
4e52				 
4e52 6b 5d			dw game2b 
4e54 d9 5d			dw game2bf 
4e56 23 5e			dw game2mba 
4e58 b9 5e			dw game2mbas 
4e5a fb 5e			dw game2mb 
4e5c			 
4e5c 2c 5a			dw game1 
4e5e 3d 5a			dw game1a 
4e60 9f 5a			dw game1b 
4e62 d4 5a			dw game1c 
4e64 0a 5b			dw game1d 
4e66 3b 5b			dw game1s 
4e68 4f 5b			dw game1t 
4e6a 64 5b			dw game1f 
4e6c 98 5b			dw game1z 
4e6e dc 5b			dw game1zz 
4e70			 
4e70 46 58			dw test5 
4e72 7e 58			dw test6 
4e74 b6 58			dw test7 
4e76 ca 58			dw test8 
4e78 f6 58			dw test9 
4e7a 0c 59			dw test10 
4e7c				 
4e7c b3 5c		        dw ssv5 
4e7e 97 5c		        dw ssv4 
4e80 7b 5c		        dw ssv3 
4e82 45 5c		        dw ssv2 
4e84 cc 5c		        dw ssv1 
4e86 14 5d		        dw ssv1cpm 
4e88			;	dw keyup 
4e88			;	dw keydown 
4e88			;	dw keyleft 
4e88			;	dw keyright 
4e88			;	dw 	keyf1 
4e88			;	dw keyf2 
4e88			;	dw keyf3 
4e88			;	dw keyf4 
4e88			;	dw keyf5 
4e88			;	dw keyf6 
4e88			;	dw keyf7 
4e88			;	dw keyf8 
4e88			;	dw keyf9 
4e88			;	dw keyf10 
4e88			;	dw keyf11 
4e88			;	dw keyf12 
4e88			;	dw keytab 
4e88			;	dw keycr 
4e88			;	dw keyhome 
4e88			;	dw keyend 
4e88			;	dw keybs 
4e88 00 00			db 0, 0	 
4e8a			 
4e8a			 
4e8a			; File Editor 
4e8a			 
4e8a			; ( id - ) use 'e' to edit the displayed line 
4e8a .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
4eab .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4ee0			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4ee0 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
4f18			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
4f18			 
4f18			; SPI Net support words 
4f18			 
4f18			; v0! = node to send to 
4f18			; ( str count - ) 
4f18 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
4f71			 
4f71			; spiputchr ( char node - ) 
4f71 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
4fa7			 
4fa7			; spigetchr ( - n ) 
4fa7 .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
4fd2			 
4fd2			; getnode ( - n ) 
4fd2 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
4fff			 
4fff			; ( str node - )  
4fff .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5065			; store string ( str i - ) 
5065			 
5065			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5065 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
50ba			 
50ba			; get string ( addr i -  )    TO FIX 
50ba			 
50ba .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
5112			 
5112			 
5112			; NETCHAT (TODO) 
5112			; Program to allow two nodes to chat with eachother 
5112			; 
5112			; v0 - target node 
5112			;  
5112			; accept input at 0,0 
5112			; if input is string send spitype to target node 
5112			; starting at row 2,0 , while spigetchr is not zero ->  
5112			; 
5112			; 
5112			; TODO add paging of get request 
5112			 
5112			; ( node - ) 
5112 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
5131 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
5189 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
5201			 
5201			 
5201			; Long read of currently open file 
5201 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
5248			 
5248			; clear stack  
5248			 
5248 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
527c			 
527c			; type ( addr count - ) 
527c .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
52a1			 
52a1			; some direct memory words 
52a1			; strncpy ( len t f -- t ) 
52a1			 
52a1 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5302			 
5302 .. 00		start1:     	db ": bpon $00 bp ;",0 
5312 .. 00		start2:     	db ": bpoff $01 bp ;",0 
5323 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
539e .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
53fe			 
53fe			 
53fe			; a handy word to list items on the stack 
53fe			 
53fe .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5468			 
5468			 
5468			; test stack  
5468			; rnd8 stest 
5468			 
5468 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
54df			 
54df			; random malloc and free cycles 
54df			 
54df .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5594			 
5594			; fixed malloc and free cycles 
5594			 
5594 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5637			 
5637			; fixed double string push and drop cycle  
5637			 
5637 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
56ec			 
56ec			; consistent fixed string push and drop cycle  
56ec			 
56ec .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5790			 
5790 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5846			 
5846			;test1:		db ": aa 1 2 3 ;", 0 
5846			;test2:     	db "111 aa 888 999",0 
5846			;test3:     	db ": bb 77 ;",0 
5846			;test4:     	db "$02 $01 do i . loop bb",0 
5846			 
5846 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
587e .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
58b6 .. 00		test7:     	db ": box hline vline ;",0 
58ca .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
58f6 .. 00		test9:     	db ": sw $01 adsp world ;",0 
590c .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5931 .. 00		test11:     	db "hello create .",0 
5940 .. 00		test12:     	db "hello2 create .",0 
5950			 
5950			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5950			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5950			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5950			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5950			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5950			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5950			 
5950			;iftest1:     	db "$0001 IF cls .",0 
5950			;iftest2:     	db "$0000 IF cls .",0 
5950			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5950			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5950			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5950			 
5950			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5950			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5950			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5950			 
5950			 
5950 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
5974 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
59a4 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
59c9 .. 00		sound4: db ": cha $00 ; ",0 
59d6 .. 00		sound5: db ": chb $20 ; ",0 
59e3 .. 00		sound6: db ": chc $40 ; ",0 
59f0 .. 00		sound7: db ": chd $60 ; ",0 
59fd .. 00		sound8: db ": cnote $80 + + note ; ", 0 
5a15 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
5a2c			 
5a2c			 
5a2c			 
5a2c			 
5a2c			; a small guess the number game 
5a2c			 
5a2c .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5a3d .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5a9f			 
5a9f .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5ad4 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5b0a .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5b3b .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5b4f .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5b64 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5b98 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5bdc			 
5bdc			; Using 'ga' save a high score across multiple runs using external storage 
5bdc			 
5bdc .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5c45			 
5c45			 
5c45			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5c45			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c45			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c45			 
5c45			; simple screen saver to test code memory reuse to destruction 
5c45			 
5c45 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5c7b .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5c97 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5cb3 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5ccc .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d14 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5d6b			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d6b			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5d6b			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5d6b			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5d6b			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5d6b			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5d6b			 
5d6b			 
5d6b			 
5d6b			; minesweeper/battleship finding game 
5d6b			; draws a game board of random ship/mine positions 
5d6b			; user enters coords to see if it hits on 
5d6b			; game ends when all are hit 
5d6b			; when hit or miss says how many may be in the area 
5d6b			 
5d6b			; setup the game board and then hide it 
5d6b .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5dd9 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5e23			; prompt for where to target 
5e23 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5eb9 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5ede			; TODO see if the entered coords hits or misses pushes char hit of miss 
5ede .. 00		game2mbht:      db ": mbckht nop ;",0 
5eed .. 00		game2mbms:      db ": mbcms nop ;",0 
5efb			; TODO how many might be near by 
5efb .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5f78			 
5f78			; Game 3 
5f78			 
5f78			; Vert scroller ski game - avoid the trees! 
5f78			 
5f78			; v0 score (ie turns) 
5f78			; v1 player pos 
5f78			; v2 left wall 
5f78			; v3 right wall 
5f78			 
5f78			; Draw side walls randomly 
5f78			 
5f78 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5fa6			 
5fa6			; Draw player 
5fa6 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5fc4			 
5fc4			; TODO Get Key 
5fc4			 
5fc4			; TODO Move left right 
5fc4			 
5fc4			; scroll and move walls a bit 
5fc4			 
5fc4 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5ff5			 
5ff5			; main game loop 
5ff5			 
5ff5 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6021 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6060			 
6060			; key board defs 
6060			 
6060 .. 00		keyup:       db ": keyup $05 ;",0 
606e .. 00		keydown:       db ": keydown $0a ;",0 
607e .. 00		keyleft:       db ": keyleft $0b ;",0 
608e .. 00		keyright:       db ": keyright $0c ;",0 
609f .. 00		keyf1:       db ": keyf1 $10 ;",0 
60ad .. 00		keyf2:       db ": keyf2 $11 ;",0 
60bb .. 00		keyf3:       db ": keyf3 $12 ;",0 
60c9 .. 00		keyf4:       db ": keyf4 $13 ;",0 
60d7 .. 00		keyf5:       db ": keyf5 $14 ;",0 
60e5 .. 00		keyf6:       db ": keyf6 $15 ;",0 
60f3 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6101 .. 00		keyf8:       db ": keyf8 $17 ;",0 
610f .. 00		keyf9:       db ": keyf9 $18 ;",0 
611d .. 00		keyf10:       db ": keyf10 $19 ;",0 
612c .. 00		keyf11:       db ": keyf11 $1a ;",0 
613b .. 00		keyf12:       db ": keyf12 $1b ;",0 
614a			 
614a .. 00		keytab:       db ": keytab $09 ;",0 
6159 .. 00		keycr:       db ": keycr $0d ;",0 
6167 .. 00		keyhome:       db ": keyhome $0e ;",0 
6177 .. 00		keyend:       db ": keyend $0f ;",0 
6186 .. 00		keybs:       db ": keybs $08 ;",0 
6194			 
6194			   
6194			 
6194			 
6194			 
6194			; eof 
# End of file forth_autostart.asm
6194			 
6194			 
6194			 
6194			; stack over and underflow checks 
6194			 
6194			; init the words to detect the under/overflow 
6194			 
6194			chk_stk_init: 
6194				; a vague random number to check so we dont get any "lucky" hits 
6194 3e 2d			ld a, 45 
6196 6f				ld l, a 
6197 00				nop 
6198 3e 17			ld a, 23 
619a 67				ld h, a 
619b			 
619b 22 a9 e2			ld (chk_word), hl     ; the word we need to check against 
619e			 
619e			;	ld (chk_stund), hl	; stack points.... 
619e 22 00 ef			ld (chk_stovr), hl 
61a1 22 ec e9			ld (chk_ret_und), hl 
61a4 22 aa e9			ld (chk_ret_ovr), hl 
61a7 22 28 e9			ld (chk_loop_ovr), hl 
61aa 22 26 e8			ld (chk_data_ovr), hl 
61ad c9				ret 
61ae				 
61ae			check_stacks: 
61ae				; check all stack words 
61ae			 
61ae e5				push hl 
61af d5				push de 
61b0			 
61b0			;	ld de,(chk_word) 
61b0			;	ld hl, (chk_stund)	; stack points.... 
61b0			;	if DEBUG_STK_FAULT 
61b0			;		DMARK "FAa" 
61b0			;		CALLMONITOR 
61b0			;	endif 
61b0			;	call cmp16 
61b0			;	jp z, .chk_faulta 
61b0			; 
61b0			;	ld de, sfaultsu 
61b0			;	jp .chk_fault 
61b0			 
61b0 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
61b3 ed 5b a9 e2		ld de,(chk_word) 
61b7				if DEBUG_STK_FAULT 
61b7					DMARK "FAb" 
61b7					CALLMONITOR 
61b7				endif 
61b7 cd 05 0e			call cmp16 
61ba 28 06			jr z, .chk_fault1 
61bc 11 5d 62			ld de, sfaultso 
61bf c3 11 62			jp .chk_fault 
61c2			.chk_fault1:  
61c2 2a ec e9			ld hl, (chk_ret_und) 
61c5 ed 5b a9 e2		ld de,(chk_word) 
61c9				if DEBUG_STK_FAULT 
61c9					DMARK "FAU" 
61c9					CALLMONITOR 
61c9				endif 
61c9 cd 05 0e			call cmp16 
61cc ca d5 61			jp z, .chk_fault2 
61cf 11 6d 62			ld de, sfaultru 
61d2 c3 11 62			jp .chk_fault 
61d5			.chk_fault2:  
61d5 2a aa e9			ld hl, (chk_ret_ovr) 
61d8 ed 5b a9 e2		ld de,(chk_word) 
61dc				if DEBUG_STK_FAULT 
61dc					DMARK "FA1" 
61dc					CALLMONITOR 
61dc				endif 
61dc cd 05 0e			call cmp16 
61df ca e8 61			jp z, .chk_fault3 
61e2 11 7b 62			ld de, sfaultro 
61e5 c3 11 62			jp .chk_fault 
61e8			.chk_fault3:  
61e8 2a 28 e9			ld hl, (chk_loop_ovr) 
61eb ed 5b a9 e2		ld de,(chk_word) 
61ef				if DEBUG_STK_FAULT 
61ef					DMARK "FA2" 
61ef					CALLMONITOR 
61ef				endif 
61ef cd 05 0e			call cmp16 
61f2 ca fb 61			jp z, .chk_fault4 
61f5 11 95 62			ld de, sfaultlo 
61f8 c3 11 62			jp .chk_fault 
61fb			.chk_fault4:  
61fb 2a 26 e8			ld hl, (chk_data_ovr) 
61fe ed 5b a9 e2		ld de,(chk_word) 
6202				if DEBUG_STK_FAULT 
6202					DMARK "FA3" 
6202					CALLMONITOR 
6202				endif 
6202 cd 05 0e			call cmp16 
6205 ca 0e 62			jp z, .chk_fault5 
6208 11 af 62			ld de, sfaultdo 
620b c3 11 62			jp .chk_fault 
620e			 
620e			 
620e			.chk_fault5:  
620e d1				pop de 
620f e1				pop hl 
6210			 
6210 c9				ret 
6211			 
6211 cd ba 0b		.chk_fault: 	call clear_display 
6214 3e 28				ld a, display_row_2 
6216 cd cd 0b				call str_at_display 
6219 11 3f 62				   ld de, .stackfault 
621c 3e 00				ld a, display_row_1 
621e cd cd 0b				call str_at_display 
6221 11 6b ee				    ld de, debug_mark 
6224 3e 11				ld a, display_row_1+17 
6226 cd cd 0b				call str_at_display 
6229 cd dd 0b				call update_display 
622c			 
622c				; prompt before entering montior for investigating issue 
622c			 
622c 3e 78			ld a, display_row_4 
622e 11 48 19			ld de, endprog 
6231			 
6231 cd dd 0b			call update_display		 
6234			 
6234 cd ce 1b			call next_page_prompt 
6237			 
6237 d1				pop de 
6238 e1				pop hl 
6239 cd 9c 19				call monitor 
623c c3 96 18				jp warmstart 
623f					;jp 0 
623f					;halt 
623f			 
623f			 
623f			 
623f .. 00		.stackfault: 	db "Stack fault:",0 
624c			 
624c .. 00		sfaultsu: 	db	"Stack under flow",0 
625d .. 00		sfaultso: 	db	"Stack over flow",0 
626d .. 00		sfaultru:	db "RTS underflow",0 
627b .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6295 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
62af .. 00		sfaultdo:	db "DTS overflow", 0 
62bc			 
62bc			 
62bc			fault_dsp_under: 
62bc 11 ce 62			ld de, .dsp_under 
62bf c3 7e 63			jp .show_fault 
62c2			 
62c2			fault_rsp_under: 
62c2 11 dc 62			ld de, .rsp_under 
62c5 c3 7e 63			jp .show_fault 
62c8			fault_loop_under: 
62c8 11 ea 62			ld de, .loop_under 
62cb c3 7e 63			jp .show_fault 
62ce			 
62ce .. 00		.dsp_under: db "DSP Underflow",0 
62dc .. 00		.rsp_under: db "RSP Underflow",0 
62ea .. 00		.loop_under: db "LOOP Underflow",0 
62f9			 
62f9			 
62f9 d5			type_faultn: 	push de 
62fa e5					push hl 
62fb cd ba 0b				call clear_display 
62fe 11 25 63				   ld de, .typefaultn 
6301 3e 00				ld a, display_row_1 
6303 cd cd 0b				call str_at_display 
6306 11 6b ee				    ld de, debug_mark 
6309 3e 11				ld a, display_row_1+17 
630b cd cd 0b				call str_at_display 
630e cd dd 0b				call update_display 
6311			 
6311				; prompt before entering montior for investigating issue 
6311			 
6311 3e 78			ld a, display_row_4 
6313 11 48 19			ld de, endprog 
6316			 
6316 cd dd 0b			call update_display		 
6319			 
6319 cd ce 1b			call next_page_prompt 
631c			 
631c e5					push hl 
631d d5					push de 
631e cd 9c 19				call monitor 
6321 c3 96 18				jp warmstart 
6324 76					halt 
6325			 
6325			 
6325 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
633c			 
633c d5			type_faults: 	push de 
633d e5					push hl 
633e cd ba 0b				call clear_display 
6341 11 67 63				   ld de, .typefaults 
6344 3e 00				ld a, display_row_1 
6346 cd cd 0b				call str_at_display 
6349 11 6b ee				    ld de, debug_mark 
634c 3e 11				ld a, display_row_1+17 
634e cd cd 0b				call str_at_display 
6351 cd dd 0b				call update_display 
6354			 
6354				; prompt before entering montior for investigating issue 
6354			 
6354 3e 78			ld a, display_row_4 
6356 11 48 19			ld de, endprog 
6359			 
6359 cd dd 0b			call update_display		 
635c			 
635c cd ce 1b			call next_page_prompt 
635f			 
635f e1					pop hl 
6360 d1					pop de 
6361 cd 9c 19				call monitor 
6364 c3 96 18				jp warmstart 
6367			 
6367			 
6367 .. 00		.typefaults: db "STR Type Expected TOS!",0 
637e			 
637e			.show_fault: 	 
637e d5					push de 
637f cd ba 0b				call clear_display 
6382 d1					pop de 
6383 3e 00				ld a, display_row_1 
6385 cd cd 0b				call str_at_display 
6388 11 6b ee				    ld de, debug_mark 
638b 3e 11				ld a, display_row_1+17 
638d cd cd 0b				call str_at_display 
6390 cd dd 0b				call update_display 
6393			 
6393				; prompt before entering montior for investigating issue 
6393			 
6393 3e 78			ld a, display_row_4 
6395 11 48 19			ld de, endprog 
6398			 
6398 cd dd 0b			call update_display		 
639b			 
639b cd ce 1b			call next_page_prompt 
639e			 
639e e1					pop hl 
639f d1					pop de 
63a0 cd 9c 19				call monitor 
63a3			; do a dump to cli and not warmstart so we preserve all of the uwords.  
63a3			; TODO Make optional fault restart to cli or warm boot? 
63a3					;jp warmstart 
63a3 c3 ee 18				jp cli 
63a6 76					halt 
63a7			 
63a7			; handle the auto run of code from files in storage 
63a7			 
63a7			 
63a7			include "forth_startup.asm" 
63a7			; Which startup method to use? 
63a7			; 
63a7			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
63a7			; followed by loading of a list of scripts in eeprom 
63a7			 
63a7			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
63a7			; from eeprom 
63a7			 
63a7			; Select with define in main stubs 
63a7			 
63a7			if STARTUP_V1 
63a7				include "forth_startupv1.asm" 
63a7			; Startup script loading version 1 
63a7			 
63a7			; If SE storage is available first stage is to use the selected file 
63a7			; then go through the eeprom list 
63a7			 
63a7 .. 00		sprompt1: db "Startup load...",0 
63b7 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
63cd			 
63cd			 
63cd			 
63cd			 
63cd			forth_startup: 
63cd 21 48 4e			ld hl, startcmds 
63d0 3e 00			ld a, 0 
63d2 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
63d5			 
63d5 e5			.start1:	push hl 
63d6 cd ba 0b			call clear_display 
63d9 11 a7 63			ld de, sprompt1 
63dc 3e 00		        ld a, display_row_1 
63de cd cd 0b			call str_at_display 
63e1 11 b7 63			ld de, sprompt2 
63e4 3e 28		        ld a, display_row_2 
63e6 cd cd 0b			call str_at_display 
63e9 e1				pop hl 
63ea e5				push hl 
63eb 5e				ld e,(hl) 
63ec 23				inc hl 
63ed 56				ld d,(hl) 
63ee 3e 50		        ld a, display_row_3 
63f0 cd cd 0b			call str_at_display 
63f3 cd dd 0b			call update_display 
63f6			 
63f6			 
63f6 3a e7 e6			ld a, (os_last_cmd) 
63f9 fe 00			cp 0 
63fb 28 05			jr z, .startprompt 
63fd cd e6 0a			call delay250ms 
6400 18 24			jr .startdo 
6402				 
6402				 
6402			 
6402			.startprompt: 
6402			 
6402 3e 9f			ld a,display_row_4 + display_cols - 1 
6404 11 cc 1b		        ld de, endprg 
6407 cd cd 0b			call str_at_display 
640a cd dd 0b			call update_display 
640d cd f2 0a			call delay1s 
6410 cd 7f 65			call cin_wait 
6413						 
6413 fe 2a			cp '*' 
6415 28 5e			jr z, .startupend1 
6417 fe 23			cp '#' 
6419 20 07			jr nz, .startno 
641b 3e 01			ld a, 1 
641d 32 e7 e6			ld (os_last_cmd),a 
6420 18 04			jr .startdo 
6422 fe 31		.startno:	cp '1' 
6424 28 3a			jr z,.startnxt  
6426			 
6426				; exec startup line 
6426			.startdo:	 
6426 e1				pop hl 
6427 e5				push hl 
6428				 
6428 5e				ld e,(hl) 
6429 23				inc hl 
642a 56				ld d,(hl) 
642b eb				ex de,hl 
642c			 
642c e5				push hl 
642d			 
642d 3e 00			ld a, 0 
642f				;ld a, FORTH_END_BUFFER 
642f cd 50 12			call strlent 
6432 23				inc hl   ; include zero term to copy 
6433 06 00			ld b,0 
6435 4d				ld c,l 
6436 e1				pop hl 
6437 11 c1 e2			ld de, scratch 
643a ed b0			ldir 
643c			 
643c			 
643c 21 c1 e2			ld hl, scratch 
643f cd 51 20			call forthparse 
6442 cd 91 20			call forthexec 
6445 cd a3 1f			call forthexec_cleanup 
6448			 
6448 3e 78			ld a, display_row_4 
644a 11 48 19			ld de, endprog 
644d			 
644d cd dd 0b			call update_display		 
6450			 
6450 3a e7 e6			ld a, (os_last_cmd) 
6453 fe 00			cp 0 
6455 20 09			jr nz, .startnxt 
6457 cd ce 1b			call next_page_prompt 
645a cd ba 0b		        call clear_display 
645d cd dd 0b			call update_display		 
6460			 
6460				; move onto next startup line? 
6460			.startnxt: 
6460			 
6460 cd e6 0a			call delay250ms 
6463 e1				pop hl 
6464			 
6464 23				inc hl 
6465 23				inc hl 
6466			 
6466 e5				push hl 
6467 5e				ld e, (hl) 
6468 23				inc hl 
6469 56				ld d, (hl) 
646a e1				pop hl 
646b				; TODO replace 0 test 
646b			 
646b eb				ex de, hl 
646c cd 10 0e			call ishlzero 
646f			;	ld a,e 
646f			;	add d 
646f			;	cp 0    ; any left to do? 
646f eb				ex de, hl 
6470 c2 d5 63			jp nz, .start1 
6473 18 01			jr .startupend 
6475			 
6475 e1			.startupend1: pop hl 
6476			.startupend: 
6476			 
6476 cd ba 0b			call clear_display 
6479 cd dd 0b			call update_display 
647c c9				ret 
647d			if STORAGE_SE 
647d			 
647d			sprompt3: db "Loading from start-up file?:",0 
647d			sprompt4: db "(Y=Any key/N=No)",0 
647d			 
647d			 
647d			forth_autoload: 
647d			 
647d				; load block 0 of store 1 
647d				 
647d				ld a, $fe      ; bit 0 clear 
647d				ld (spi_device), a 
647d			 
647d				call storage_get_block_0 
647d			 
647d				ld a, (store_page+STORE_0_AUTOFILE) 
647d			 
647d				cp 0 
647d				ret z     ; auto start not enabled 
647d			 
647d				call clear_display 
647d			 
647d				; set bank 
647d			 
647d					ld a, (store_page+STORE_0_BANKRUN) 
647d					ld (spi_device), a 
647d			 
647d				; get file id to load from and get the file name to display 
647d			 
647d					ld a, (store_page+STORE_0_FILERUN) 
647d			 
647d					ld l, 0 
647d					ld h, a 
647d					ld de, store_page 
647d			 
647d					if DEBUG_FORTH_WORDS 
647d						DMARK "ASp" 
647d						CALLMONITOR 
647d					endif 
647d					call storage_read 
647d			 
647d					if DEBUG_FORTH_WORDS 
647d						DMARK "ASr" 
647d						CALLMONITOR 
647d					endif 
647d			 
647d					call ishlzero 
647d					ret z             ; file not found 
647d			 
647d					ld a, display_row_2 + 10 
647d					ld de, store_page+3 
647d					call str_at_display 
647d				 
647d			; 
647d			 
647d				ld a, display_row_1+5 
647d				ld de, sprompt3 
647d				call str_at_display 
647d				ld a, display_row_3+15 
647d				ld de, sprompt4 
647d				call str_at_display 
647d			 
647d				call update_display 
647d			 
647d				call cin_wait 
647d				cp 'n' 
647d				ret z 
647d				cp 'N' 
647d				ret z 
647d			 
647d				call delay1s 
647d			 
647d				ld a, (store_page+2) 
647d				ld (store_openmaxext), a    ; save count of ext 
647d				ld a, 1  
647d				ld (store_openext), a    ; save count of ext 
647d			 
647d			.autof:  
647d				ld l , a 
647d				 
647d				ld a, (store_page) 
647d				ld h, a	 
647d				ld de, store_page 
647d					if DEBUG_FORTH_WORDS 
647d						DMARK "ASl" 
647d						CALLMONITOR 
647d					endif 
647d					call storage_read 
647d				call ishlzero 
647d				ret z 
647d			;	jr z, .autoend 
647d			 
647d					if DEBUG_FORTH_WORDS 
647d						DMARK "ASc" 
647d						CALLMONITOR 
647d					endif 
647d				ld de, store_page+2 
647d				ld a, display_row_4 
647d				call str_at_display 
647d			 
647d				call update_display 
647d				call delay250ms 
647d			 
647d			 
647d			 
647d				ld hl, store_page+2 
647d				call forthparse 
647d				call forthexec 
647d				call forthexec_cleanup 
647d			 
647d				 
647d				ld a, (store_openext) 
647d				inc a 
647d				ld (store_openext), a    ; save count of ext 
647d			 
647d				jr .autof 
647d			;.autofdone: 
647d			; 
647d			;		if DEBUG_FORTH_WORDS 
647d			;			DMARK "ASx" 
647d			;			CALLMONITOR 
647d			;		endif 
647d			;;	call clear_display 
647d			;	ret 
647d			 
647d			 
647d			 
647d			endif 
# End of file forth_startupv1.asm
647d			endif 
647d			if STARTUP_V2 
647d				include "forth_startupv2.asm" 
647d			endif 
647d			 
# End of file forth_startup.asm
647d			 
647d			; eof 
# End of file forth_kernel.asm
647d			;include "nascombasic.asm" 
647d			 
647d			 
647d			; find out where the code ends if loaded into RAM (for SC114) 
647d			;endofcode:  
647d			;	nop 
647d			 
647d			 
647d			; jump to nmi vector 
647d			 
647d			init_nmi: 
647d 3e c9			ld a, $c9   ; RET 
647f 32 72 ee			ld (nmi_vector), a 
6482 c9				ret 
6483			nmi: 
6483 e5				push hl 
6484 d5				push de 
6485 c5				push bc 
6486 f5				push af 
6487 cd 72 ee			call nmi_vector 
648a f5				push af 
648b c5				push bc 
648c d5				push de 
648d e5				push hl 
648e ed 4d			reti 
6490			 
6490			 
6490			; eof 
6490			 
# End of file main.asm
6490			;include "firmware_lcd_4x40.asm" 
6490			;;include "firmware_lcd_4x20.asm" 
6490			include "firmware_cpm_display.asm" 
6490			 
6490			; Serial display interface for SC114 
6490			 
6490			 
6490			display_row_1: equ 0 
6490			display_row_2: equ display_row_1+display_cols 
6490			display_row_3: equ display_row_2 + display_cols 
6490			display_row_4: equ display_row_3 + display_cols 
6490			 
6490			kLCDWidth:  EQU display_cols             ;Width in characters 
6490			kLCD_Line1: EQU 0x00  
6490			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
6490			; E1 
6490			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
6490			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
6490			 
6490			lcd_init: 
6490				; no init as handled by the SCM bios 
6490 c9				ret 
6491			 
6491			 
6491			; low level functions for direct screen writes 
6491			 
6491			; output char at pos? 
6491			fLCD_Str: 
6491			        ;out (SC114_SIO_1_OUT),a 
6491 c5				push bc 
6492 d5				push de 
6493 5f				ld e, a 
6494			; TODO Replace with CP/M BIOS call 
6494 0e 02			ld c, $02 
6496 cd 05 00			call 5 
6499 d1				pop de 
649a c1				pop bc 
649b c9				ret 
649c			 
649c			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
649c			fLCD_Pos: 
649c				; use ASCII escape to position 
649c			        ;out (SC114_SIO_1_OUT),a 
649c c5				push bc 
649d d5				push de 
649e 5f				ld e, a 
649f 0e 02			ld c, $02 
64a1			; TODO Replace with CP/M BIOS call 
64a1 cd 05 00			call 5 
64a4 d1				pop de 
64a5 c1				pop bc 
64a6			 
64a6 c9				ret 
64a7			 
64a7			; output char at pos 
64a7			fLCD_Data: 
64a7			      ;  out (SC114_SIO_1_OUT),a 
64a7 c5				push bc 
64a8 d5				push de 
64a9 0e 02			ld c, $02 
64ab 5f				ld e, a 
64ac			; TODO Replace with CP/M BIOS call 
64ac cd 05 00			call 5 
64af d1				pop de 
64b0 c1				pop bc 
64b1			 
64b1 c9				ret 
64b2			 
64b2			; ascii cls  
64b2			 
64b2 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
64b6			 
64b6 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
64cd			;.clscpm: db 3, $3c,"$" 
64cd			 
64cd			; write the frame buffer given in hl to hardware  
64cd			write_display: 
64cd			 
64cd			API: equ 0 
64cd			 
64cd			if API 
64cd				push bc 
64cd				ld b, 4 
64cd			 
64cd			        ld (display_write_tmp), hl 	  
64cd			 
64cd				; clear and home cursor 
64cd			 
64cd				ld c, 9 
64cd				ld de, .cls 
64cd			; TODO Replace with CP/M BIOS call 
64cd				call 5 
64cd			 
64cd			 
64cd			.writeln: 
64cd			 
64cd				ld de, (display_write_tmp) 
64cd				ld c, 6 
64cd			; TODO Replace with CP/M BIOS call 
64cd				rst $30 
64cd				ld c, 7 
64cd				rst $30 
64cd			 
64cd				ld hl, (display_write_tmp) 
64cd				ld de, display_cols 
64cd				add hl,de 
64cd				ld (display_write_tmp),hl 
64cd			 
64cd				djnz  .writeln 
64cd			 
64cd				pop bc 
64cd			 
64cd			 
64cd				ret 
64cd			endif 
64cd e5				push hl 
64ce c5				push bc 
64cf d5				push de 
64d0			 
64d0			;	ld c, 2 
64d0			;	;ld de, .cls 
64d0			;	ld a, 27 
64d0			;	rst $30 
64d0			;	ld c, 2 
64d0			;	;ld de, .cls 
64d0			;	ld a, '[' 
64d0			;	rst $30 
64d0			; 
64d0			;	ld c, 2 
64d0			;	;ld de, .cls 
64d0			;	ld a, 'H' 
64d0			;	rst $30 
64d0			; 
64d0			 
64d0			 
64d0			; lots of CR/LF 
64d0			;	ld c, 9 
64d0			;	ld de, .clscpm 
64d0			;	call 5 
64d0			 
64d0			; xterm cls 
64d0 0e 02			ld c, 2 
64d2 1e 1b			ld e, 27 
64d4 cd 05 00			call 5 
64d7			; cls causes too much flicker 
64d7			;	ld c, 2 
64d7			;	ld e, 'c' 
64d7			;	call 5 
64d7			 
64d7			; use xterm home instead 
64d7 0e 02			ld c, 2 
64d9 1e 5b			ld e, '[' 
64db cd 05 00			call 5 
64de 0e 02			ld c, 2 
64e0 1e 48			ld e, 'H' 
64e2 cd 05 00			call 5 
64e5			LLL: equ 0 
64e5			 
64e5			if LLL 
64e5			 
64e5				ld c, 2 
64e5				;ld de, .cls 
64e5				ld e, 27 
64e5			; TODO Replace with CP/M BIOS call 
64e5				call 5 
64e5			 
64e5			 
64e5				ld c, 2 
64e5				;ld de, .cls 
64e5				ld e, '[' 
64e5			; TODO Replace with CP/M BIOS call 
64e5				call 5 
64e5				ld c, 2 
64e5				;ld de, .cls 
64e5				ld e, '2' 
64e5			; TODO Replace with CP/M BIOS call 
64e5				call 5 
64e5				ld c, 2 
64e5				;ld de, .cls 
64e5				ld e, 'J' 
64e5			; TODO Replace with CP/M BIOS call 
64e5				call 5 
64e5			 
64e5			endif 
64e5			 
64e5 d1				pop de 
64e6 c1				pop bc 
64e7 e1				pop hl 
64e8			 
64e8			 
64e8 22 c9 eb		        ld (display_write_tmp), hl 	  
64eb 3e 00			ld a, kLCD_Line1 
64ed			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
64ed 06 28			ld b, display_cols 
64ef ed 5b c9 eb		ld de, (display_write_tmp) 
64f3 cd 76 65			call write_len_string 
64f6				 
64f6			 
64f6 e5			push hl 
64f7 d5			push de 
64f8 c5			push bc 
64f9 0e 02			ld c, 2 
64fb 1e 0a			ld e, 10 
64fd cd 05 00			call 5 
6500 0e 02			ld c, 2 
6502 1e 0d			ld e, 13 
6504 cd 05 00			call 5 
6507			; TODO Replace with CP/M BIOS call 
6507				;rst $30 
6507 c1			pop bc 
6508 d1			pop de 
6509 e1			pop hl 
650a			 
650a				 
650a 2a c9 eb			ld hl, (display_write_tmp) 
650d 11 28 00			ld de, display_cols 
6510 19				add hl,de 
6511 22 c9 eb			ld (display_write_tmp),hl 
6514			 
6514				 
6514 3e 28			ld a, kLCD_Line2 
6516			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
6516 06 28			ld b, display_cols 
6518 ed 5b c9 eb		ld de, (display_write_tmp) 
651c cd 76 65			call write_len_string 
651f				 
651f 2a c9 eb			ld hl, (display_write_tmp) 
6522 11 28 00			ld de, display_cols 
6525 19				add hl,de 
6526 22 c9 eb			ld (display_write_tmp),hl 
6529			 
6529 e5			push hl 
652a d5			push de 
652b c5			push bc 
652c 0e 07			ld c, 7 
652e			; TODO Replace with CP/M BIOS call 
652e				;rst $30 
652e 0e 02			ld c, 2 
6530 1e 0a			ld e, 10 
6532 cd 05 00			call 5 
6535 0e 02			ld c, 2 
6537 1e 0d			ld e, 13 
6539 cd 05 00			call 5 
653c c1			pop bc 
653d d1			pop de 
653e e1			pop hl 
653f			 
653f				 
653f 3e 50			ld a, kLCD_Line3 
6541			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
6541 06 28			ld b, display_cols 
6543 ed 5b c9 eb		ld de, (display_write_tmp) 
6547 cd 76 65			call write_len_string 
654a				 
654a 2a c9 eb			ld hl, (display_write_tmp) 
654d 11 28 00			ld de, display_cols 
6550 19				add hl,de 
6551 22 c9 eb			ld (display_write_tmp),hl 
6554			 
6554 e5			push hl 
6555 d5			push de 
6556 c5			push bc 
6557 0e 07			ld c, 7 
6559			; TODO Replace with CP/M BIOS call 
6559				;rst $30 
6559 0e 02			ld c, 2 
655b 1e 0a			ld e, 10 
655d cd 05 00			call 5 
6560 0e 02			ld c, 2 
6562 1e 0d			ld e, 13 
6564 cd 05 00			call 5 
6567 c1			pop bc 
6568 d1			pop de 
6569 e1			pop hl 
656a			 
656a				 
656a 3e 78			ld a, kLCD_Line4 
656c			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
656c 06 28			ld b, display_cols 
656e ed 5b c9 eb		ld de, (display_write_tmp) 
6572 cd 76 65			call write_len_string 
6575 c9					ret 
6576			 
6576			 
6576				; write out a fixed length string given in b from de 
6576			 
6576 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
6577 cd a7 64		            CALL fLCD_Data      ;Write character to display 
657a 13				inc de 
657b 10 f9			djnz write_len_string 
657d c9				ret 
657e			 
657e			 
657e			; eof 
# End of file firmware_cpm_display.asm
657e			;include "firmware_key_5x10.asm" 
657e			;;include "firmware_key_4x10.asm" 
657e			include "firmware_key_cpm.asm" 
657e			; Serial keyboard interface for SC114 
657e			 
657e			 
657e			key_init: 
657e				; no init as handled by the SCM bios 
657e c9				ret 
657f			 
657f			 
657f			cin_wait: 
657f			;	ld a, 0 
657f			;	ret 
657f			 
657f				;in a,(SC114_SIO_1_IN) 
657f			        ; Use SCM API to get from whatever console device we are using 
657f			 
657f			; TODO Replace with CP/M BIOS call 
657f c5				push bc 
6580 0e 01			ld c, $01 
6582 cd 05 00			call 5 
6585 c1				pop bc 
6586 c9				ret 
6587			 
6587			cin: 
6587			 
6587			 
6587 c5				push bc 
6588			 
6588				; any key waiting to process? 
6588			; TODO Replace with CP/M BIOS call 
6588 0e 06			ld c, $06 
658a cd 05 00			call 5 
658d 28 0d			jr z, .cin_skip 
658f			 
658f				; yep, get it 
658f			 
658f 0e 01			ld c, $01 
6591			; TODO Replace with CP/M BIOS call 
6591 cd 05 00			call 5 
6594			 
6594 fe 7f			cp $7f     ; back space 
6596 20 02			jr nz, .skipbs 
6598 3e 08			ld a, KEY_BS 
659a			.skipbs: 
659a			 
659a c1				pop bc 
659b c9				ret 
659c			.cin_skip: 
659c 3e 00			ld a, 0 
659e c1				pop bc 
659f c9				ret 
65a0			 
65a0			 
65a0			 
65a0			 
# End of file firmware_key_cpm.asm
65a0			endofcode:  
65a0			baseram:  
65a0 00				nop 
65a1			 
65a1			heap_start: equ baseram+15  ; Starting address of heap 
65a1			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
65a1			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
65a1			;VDU:  EQU     endofcode           ; BASIC Work space 
65a1			; eof 
65a1			 
# End of file os_mega_cpm.asm
65a1
