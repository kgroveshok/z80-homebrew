# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 c4 19			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 ..			buildtime: db   "Build: " 
010a					include "romtimestamp.asm" 
010a ..			db '2025-08-08 22:30' 
# End of file romtimestamp.asm
011a 00				   db 0 
011b			 
011b			 
011b			 
011b			;        nop  
011b			;        nop 
011b			;;	org 05h		; null out bdos call 
011b			; 
011b			;        nop  
011b			;        nop  
011b			;        nop 
011b			;;	org 08h 
011b			;;; 
011b			;;	jp cin		; rst 8 - char in 
011b			;;; 
011b			; 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;	org 010h 
011b			;; 
011b			;	jp cout		; rest 010h  - char out 
011b			;; 
011b			;	org 01bh   
011b			; 
011b			;	;jp  		; rst 01bh   - write string to display 
011b			;	jp str_at_display 
011b			; 
011b			; 
011b			;	org 020h 
011b			; 
011b			;	; jp		 ; rst 020h - read char at screen location 
011b			; 
011b			;	org 028h 
011b			 
011b				; jp		 ; rst 028h  - storage i/o 
011b			 
011b			; 	org 030h 
011b			;	jp break_point_state 
011b			  
011b			; $30  
011b			; org 038h 
011b			; $38 
011b			 
011b			; TODO any more important entry points to add to jump table for easier coding use? 
011b			 
011b			if BASE_KEV = 1  
011b			 
011b				; need to be at $66 for nmi support 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255 
011b				jp nmi 
011b			endif 
011b			 
011b			include "firmware.asm" 
011b			  
011b			; main constants (used here and in firmware)  
011b			  
011b			; TODO have page 0 of storage as bios  
011b			  
011b			Device_A: equ 0h  
011b			Device_B: equ 040h          ; Sound  
011b			  
011b			if BASE_KEV  
011b			Device_C: equ 080h          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			if BASE_SC114  
011b			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			if BASE_CPM  
011b			; TODO fixup for CPM  
011b			Device_C: equ 080h          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			Device_D: equ 0c0h             ; Keyboard and LCD  
011b			  
011b			; Odd specific debug points for testing hardware dev  
011b			  
011b			DEBUG_SOUND: equ 0       
011b			DEBUG_STK_FAULT: equ 0  
011b			DEBUG_INPUT: equ 0     ; Debug input entry code  
011b			DEBUG_INPUTV2: equ 1     ; Debug input entry code  
011b			DEBUG_KEYCINWAIT: equ 0  
011b			DEBUG_KEYCIN: equ 0  
011b			DEBUG_KEY: equ 0  
011b			DEBUG_KEY_MATRIX: equ 0  
011b			DEBUG_STORECF: equ 0  
011b			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011b			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011b			DEBUG_SPI: equ 0    ; low level spi tests  
011b			  
011b			; Enable many break points  
011b			  
011b			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011b			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011b			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011b			DEBUG_FORTH_JP: equ 0    ; 4  
011b			DEBUG_FORTH_MALLOC: equ 0  
011b			DEBUG_FORTH_MALLOC_INT: equ 0  
011b			DEBUG_FORTH_DOT: equ 1  
011b			DEBUG_FORTH_DOT_WAIT: equ 0  
011b			DEBUG_FORTH_MATHS: equ 0  
011b			DEBUG_FORTH_TOK: equ 0    ; 4  
011b			DEBUG_FORTH_PARSE: equ 0    ; 3  
011b			DEBUG_FORTH: equ 0  ;2  
011b			DEBUG_FORTH_WORDS: equ 1   ; 1  
011b			DEBUG_FORTH_PUSH: equ 1   ; 1  
011b			DEBUG_FORTH_UWORD: equ 1   ; 1  
011b			  
011b			; Enable key point breakpoints  
011b			  
011b			DEBUG_FORTH_DOT_KEY: equ 0  
011b			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011b			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011b			  
011b			; Debug stack imbalances  
011b			  
011b			ON: equ 1  
011b			OFF: equ 0  
011b			  
011b			DEBUG_STACK_IMB: equ 0  
011b			STACK_IMB_STORE: equ 20  
011b			  
011b			; House keeping and protections  
011b			  
011b			DEBUG_FORTH_STACK_GUARD: equ 1  
011b			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011b			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011b			FORTH_ENABLE_FREE: equ 0  
011b			FORTH_ENABLE_MALLOCFREE: equ 1  
011b			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011b			FORTH_ENABLE_FLOATMATH: equ 0  
011b			  
011b			  
011b			CALLMONITOR: macro  
011b			;	call break_point_state  
011b			; now use the break point debug vector  
011b				call debug_vector  
011b				endm  
011b			  
011b			MALLOC_1: equ 1        ; from dk88   
011b			MALLOC_2: equ 0           ; broke  
011b			MALLOC_3: equ 0           ; really broke  
011b			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011b			  
011b			if BASE_KEV   
011b			;stacksize: equ 256  
011b			; each stack entry is three bytes (type + word)  
011b			stacksize: equ 3*150  
011b			  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 512  
011b			endif  
011b			if BASE_SC114  
011b			;tos:	equ 0f000h  
011b			stacksize: equ 256  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 256  
011b			endif  
011b			  
011b			if BASE_CPM  
011b			;tos:	equ 0f000h  
011b			stacksize: equ 256  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 256  
011b			endif  
011b			  
011b			;if STORAGE_SE == 0  
011b			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011b			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011b			;endif  
011b			  
011b			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011b			  
011b			STORE_0_AUTORUN: equ $20  
011b			  
011b			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011b			  
011b			STORE_0_AUTOFILE: equ $21  
011b			STORE_0_BANKRUN: equ $23  
011b			STORE_0_FILERUN: equ $24  
011b			  
011b			; Block 0 offsets for settings  
011b			  
011b			; if set then skip prompt for start up and accept all  
011b			  
011b			STORE_0_QUICKSTART: equ $25  
011b			  
011b			; Blocks where directory table is held  
011b			  
011b			; Reducing the number of entries increases the max file size  
011b			  
011b			;STORE_DIR_START: equ 1  
011b			;STORE_DIR_END: equ 33  
011b			  
011b			; Blocks from where file data is stored  
011b			  
011b			;STORE_DATA_START: equ STORE_DIR_END + 1  
011b			  
011b			; Block indicators (<32 are data files)  
011b			  
011b			;STORE_BLOCK_CFG: equ $8f       ; config block  
011b			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011b			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011b			;STORE_BLOCK_FREE: equ $85       ; data block free  
011b			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011b			  
011b			  
011b			  
011b			; Directory entry flags  
011b			  
011b			;STORE_DIR_FREE: equ 0  
011b			;STORE_DIR_FILE:  equ 1  
011b			  
011b			; Structure offsets to directory entries  
011b			;STORE_DE_FLAG: equ 0  
011b			;STORE_DE_MAXEXT: equ 1  
011b			;STORE_DE_FILENAME: equ 2  
011b			  
011b			; Structure offsets to block 0  
011b			  
011b			;STORE_BK0_ISFOR: equ 1  
011b			;STORE_BK0_LABEL: equ 3  
011b			  
011b			; memory allocation   
011b			  
011b			chk_stund: equ tos+2           ; underflow check word  
011b			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011b			  
011b			; keyscan table needs rows x cols buffer  
011b			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011b			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011b			  
011b			keyscan_table_row1: equ chk_stovr -key_cols-1  
011b			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011b			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011b			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011b			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011b			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011b			keyscan_scancol: equ keyscan_table-key_cols  
011b			;keyscan_table_len: equ key_rows*key_cols  
011b			;keybufptr: equ keyscan_table - 2  
011b			;keysymbol: equ keybufptr - 1  
011b			key_held: equ keyscan_scancol-1	; currently held  
011b			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011b			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011b			key_fa: equ key_repeat_ct -1 ;  
011b			key_fb: equ key_fa -1 ;  
011b			key_fc: equ key_fb -1 ;  
011b			key_fd: equ key_fc -1 ;  
011b			key_face_held: equ key_fd - 1   
011b			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011b			  
011b			hardware_config: equ key_face_held - 10  
011b			  
011b			; hardware config switches  
011b			; TODO add bitmasks on includes for hardware  
011b			; high byte for expansion ids  
011b			;     0000 0000  no card inserted  
011b			;     0000 0001  storage card inserted  
011b			;     0000 0010  spi sd card active  
011b			  
011b			;       
011b			; low byte:  
011b			;     0000 0001   4x4 keypad  
011b			;     0000 0010   full keyboard  
011b			;     0000 0011   spi/ext keyboard  
011b			;     0000 0100   20x4 lcd  
011b			;     0000 1000   40x4 lcd  
011b			;     0000 1100   spi/ext display  
011b			;     0001 0000   ide interface available  
011b			  
011b			hardware_word: equ hardware_config - 2  
011b			  
011b			; debug marker - optional display of debug point on the debug screens  
011b			  
011b			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011b			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011b			  
011b			debug_mark: equ debug_vector - 4  
011b			  
011b			; input_str vars  
011b			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011b			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011b			input_size: equ input_start -1  ; number of chars  
011b			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011b			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011b			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011b			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011b			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011b			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011b			input_len: equ input_cur_onoff - 5 ; length of current input  
011b			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011b			  
011b			; cursor blink rate  
011b			CUR_BLINK_RATE: equ $09  
011b			;CUR_BLINK_RATE: equ 15  
011b			  
011b			key_actual_pressed: equ input_cursor - 1   
011b			key_symbol: equ key_actual_pressed - 1   
011b			key_shift: equ key_symbol - 1   
011b			  
011b			; Display allocation  
011b			  
011b			;display_rows: equ 4     ; move out to mini and mega files  
011b			;display_cols: equ 20  
011b			  
011b			display_fb_len: equ display_rows*display_cols  
011b			  
011b			; primary frame buffer     
011b			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011b			; working frame buffers  
011b			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011b			display_fb3: equ  display_fb1-display_fb_len - 1  
011b			display_fb2: equ  display_fb3-display_fb_len - 1  
011b			;  
011b			; pointer to active frame buffer  
011b			display_fb_active: equ display_fb2 - 2  
011b			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011b			display_write_tmp: equ display_lcde1e2 - 2  
011b			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011b			  
011b			;  
011b			  
011b			;; can load into de directory  
011b			cursor_col: equ display_active-1  
011b			cursor_row: equ cursor_col-1  
011b			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011b			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011b			  
011b			; maths vars  
011b			  
011b			LFSRSeed: equ cursor_shape -20   
011b			randData: equ LFSRSeed - 2  
011b			xrandc: equ randData - 2  
011b			stackstore: equ xrandc - 2  
011b			seed1: equ  stackstore -2   
011b			seed2: equ seed1 - 2  
011b			  
011b			; cf storage vars  
011b			  
011b			iErrorNum:  equ seed2-1         ;Error number  
011b			iErrorReg:  equ iErrorNum -1              ;Error register  
011b			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011b			  
011b			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011b			  
011b			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011b			  
011b			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011b			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011b			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011b			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011b			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011b			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011b			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011b			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011b			store_tmpid: equ store_tmp3 - 1		; page temp id  
011b			store_tmpext: equ store_tmpid - 1		; file extent temp  
011b			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011b			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011b			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011b			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011b			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011b			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011b			;  
011b			; spi vars  
011b			  
011b			  
011b			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011b			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011b			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011b			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011b			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011b			spi_device_id: equ spi_device - 1    ; human readable bank number  
011b			  
011b			;;;;; forth cli params  
011b			  
011b			; TODO use a different frame buffer for forth???  
011b			  
011b			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011b			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011b			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011b			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011b			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011b			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011b			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011b			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011b			  
011b			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011b			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011b			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011b			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011b			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011b			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011b			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011b			  
011b			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011b			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011b			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011b			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011b			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011b			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011b			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011b			  
011b			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011b			  
011b			; os/forth token vars  
011b			  
011b			os_last_cmd: equ os_var_array-255  
011b			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011b			os_current_i: equ os_cli_cmd-2  
011b			os_cur_ptr: equ os_current_i-2  
011b			os_word_scratch: equ os_cur_ptr-30  
011b			os_tok_len: equ os_word_scratch - 2  
011b			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011b			os_tok_malloc: equ os_tok_ptr - 2  
011b			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011b			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011b			execscratch: equ os_input-255        ; exec cmd eval buffer  
011b			scratch: equ execscratch-255  
011b			  
011b			os_stack_1: equ scratch - 3       ; stack holding area 1  
011b			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
011b			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
011b			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
011b			  
011b			  
011b			; temp locations for new word processing to save on adding more   
011b			  
011b			os_new_malloc: equ os_stack_4-2  
011b			os_new_parse_len: equ os_new_malloc - 2  
011b			os_new_word_len: equ os_new_parse_len - 2  
011b			os_new_work_ptr: equ os_new_word_len - 2  
011b			os_new_src_ptr: equ os_new_work_ptr - 2  
011b			os_new_exec: equ os_new_src_ptr - 2  
011b			os_new_exec_ptr: equ os_new_exec - 2  
011b			  
011b			; resume memory alloocations....  
011b			  
011b			;os_view_disable: equ os_new_exec_ptr - 1  
011b			os_view_af: equ os_new_exec_ptr - 2  
011b			os_view_hl: equ os_view_af -2  
011b			os_view_de: equ os_view_hl - 2  
011b			os_view_bc: equ os_view_de - 2  
011b			  
011b			; stack checksum word  
011b			if DEBUG_STACK_IMB  
011b				curframe: equ  os_view_de - 5  
011b				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011b				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011b			else  
011b				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011b			endif  
011b			  
011b			; with data stack could see memory filled with junk. need some memory management   
011b			; malloc and free entry points added  
011b			  
011b			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011b			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011b			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			;heap_end: equ free_list-1  ; Starting address of heap  
011b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			  
011b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			heap_end: equ chk_word-1  ; Starting address of heap  
011b			  
011b			  
011b			;if BASE_KEV   
011b			;heap_start: equ 0800eh  ; Starting address of heap  
011b			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011b			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011b			;endif  
011b			  
011b			;if BASE_SC114  
011b			;heap_start: equ baseram+15  ; Starting address of heap  
011b			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011b			;endif  
011b			  
011b			  
011b			;;;;  
011b			  
011b			  
011b			; change below to point to last memory alloc above  
011b			topusermem:  equ   heap_start  
011b			  
011b			;if BASE_KEV   
011b			;baseusermem: equ 08000h  
011b			;endif  
011b			  
011b			;if BASE_SC114  
011b			;;aseusermem:     equ    12  
011b			;baseusermem:     equ    prompt  
011b			;;baseusermem:     equ    endofcode  
011b			;endif  
011b			  
011b			  
011b			; **********************************************************************  
011b			; **  Constants  
011b			; **********************************************************************  
011b			  
011b			; Constants used by this code module  
011b			kDataReg:   EQU Device_D           ;PIO port A data register  
011b			kContReg:   EQU Device_D+2           ;PIO port A control register  
011b			  
011b			  
011b			portbdata:  equ Device_D+1    ; port b data  
011b			portbctl:   equ Device_D+3    ; port b control  
011b			  
011b			  
011b			;KEY_SHIFT:   equ 5  
011b			;KEY_SYMBOLSHIFT:  equ 6  
011b			  
011b			KEY_SHIFTLOCK: equ 4  
011b			  
011b			  
011b			KEY_UP: equ 5  
011b			KEY_NEXTWORD: equ 6  
011b			KEY_PREVWORD: equ 7  
011b			KEY_BS: equ 8  
011b			KEY_TAB:  equ 9  
011b			KEY_DOWN: equ 10  
011b			KEY_LEFT: equ 11  
011b			KEY_RIGHT: equ 12  
011b			KEY_CR:   equ 13  
011b			KEY_HOME: equ 14  
011b			KEY_END: equ 15  
011b			  
011b			KEY_F1: equ 16  
011b			KEY_F2: equ 17  
011b			KEY_F3: equ 18  
011b			KEY_F4: equ 19  
011b			  
011b			KEY_F5: equ 20  
011b			KEY_F6: equ 21  
011b			KEY_F7: equ 22  
011b			KEY_F8: equ 23  
011b			  
011b			KEY_F9: equ 24  
011b			KEY_F10: equ 25  
011b			KEY_F11: equ 26  
011b			KEY_F12: equ 27  
011b			  
011b			;if DEBUG_KEY  
011b			;	KEY_MATRIX_NO_PRESS: equ '.'  
011b			;	KEY_SHIFT:   equ '.'  
011b			;	KEY_SYMBOLSHIFT:  equ '.'  
011b			;else  
011b				KEY_SHIFT:   equ '~'  
011b				KEY_SYMBOLSHIFT:  equ '~'  
011b				KEY_MATRIX_NO_PRESS: equ '~'  
011b			;endi  
011b			  
011b			  
011b			  
011b			  
011b			; Macro to make adding debug marks easier  
011b			  
011b			DMARK: macro str  
011b				push af  
011b				ld a, (.dmark)  
011b				ld (debug_mark),a  
011b				ld a, (.dmark+1)  
011b				ld (debug_mark+1),a  
011b				ld a, (.dmark+2)  
011b				ld (debug_mark+2),a  
011b				jr .pastdmark  
011b			.dmark: db str  
011b			.pastdmark: pop af  
011b			  
011b			endm  
011b			  
011b			  
011b			; macro to detect for stack imbalances  
011b			  
011b			include "stackimbal.asm"  
011b			; Macro and code to detect stock imbalances 
011b			 
011b			SPPUSH: equ 0 
011b			 
011b			; Add a stack frame which can be checked before return 
011b			 
011b			STACKFRAME: macro onoff frame1 frame2 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						; save current SP 
011b						exx 
011b			 
011b						ld de, frame1 
011b						ld a, d 
011b						ld hl, curframe 
011b						call hexout 
011b						ld a, e 
011b						ld hl, curframe+2 
011b						call hexout 
011b			  
011b						ld hl, frame1 
011b						push hl 
011b						ld hl, frame2 
011b						push hl 
011b						exx 
011b					endif 
011b					 
011b				endif 
011b			endm 
011b			 
011b			STACKFRAMECHK: macro onoff frame1 frame2 
011b			 
011b					 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						exx 
011b						; check stack frame SP 
011b			 
011b						ld hl, frame2 
011b						pop de   ; frame2 
011b			 
011b						call cmp16 
011b						jr nz, .spnosame 
011b						 
011b			 
011b						ld hl, frame1 
011b						pop de   ; frame1 
011b			 
011b						call cmp16 
011b						jr z, .spfrsame 
011b			 
011b						.spnosame: call showsperror 
011b			 
011b						.spfrsame: nop 
011b			 
011b						exx 
011b					endif 
011b					 
011b				endif 
011b			 
011b			 
011b			endm 
011b			 
011b			 
011b			; for a sub routine, wrap SP collection and comparisons 
011b			 
011b			; Usage: 
011b			; 
011b			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011b			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011b			 
011b			SAVESP: macro onoff storeword 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						; save current SP 
011b			 
011b						ld (store_sp+(storeword*4)), sp 
011b			 
011b					endif 
011b					 
011b				endif 
011b			 
011b			endm 
011b			 
011b			CHECKSP: macro onoff storeword 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b			 
011b						; save SP after last save 
011b				 
011b						ld (store_sp+(storeword*4)+2), sp 
011b			 
011b						push hl 
011b						ld hl, store_sp+(storeword*4) 
011b						call check_stack_sp  
011b						pop hl 
011b			 
011b			 
011b					endif 
011b					 
011b				endif 
011b			 
011b			endm 
011b			 
011b			if DEBUG_STACK_IMB 
011b			 
011b			check_stack_sp: 
011b					push de 
011b			 
011b					ld e, (hl) 
011b					inc hl 
011b					ld d, (hl) 
011b					inc hl 
011b			 
011b					push de 
011b			 
011b			 
011b					ld e, (hl) 
011b					inc hl 
011b					ld d, (hl) 
011b					inc hl 
011b			 
011b					pop hl 
011b			 
011b			 
011b					; check to see if the same 
011b			 
011b					call cmp16 
011b					jr z, .spsame 
011b			 
011b					; not same 
011b			 
011b					call showsperror 
011b			.spsame: 
011b			 
011b					pop de 
011b			 
011b					ret 
011b			 
011b			.sperr:  db "Stack imbalance",0 
011b			 
011b			 
011b			showsperror: 
011b			 
011b			 
011b				push hl 
011b				push af 
011b				push de 
011b				call clear_display 
011b				ld de, .sperr 
011b				ld a,0 
011b			;	ld de,os_word_scratch 
011b				call str_at_display 
011b				ld a, display_row_1+17 
011b				ld de, debug_mark 
011b				call str_at_display 
011b				ld a, 0 
011b				ld (curframe+4),a 
011b				ld hl, curframe 
011b				ld de, os_word_scratch 
011b				ld a, display_row_4 
011b				call str_at_display 
011b				call update_display 
011b				;call break_point_state 
011b				call cin_wait 
011b			 
011b			;	ld a, ' ' 
011b			;	ld (os_view_disable), a 
011b				call bp_on 
011b				pop de	 
011b				pop af 
011b				pop hl 
011b				CALLMONITOR 
011b				ret 
011b			 
011b			endif 
011b			 
011b			 
011b			 
011b			; eof 
# End of file stackimbal.asm
011b			  
011b			;TODO macro to calc col and row offset into screen  
011b			  
011b			  
011b			  
011b			hardware_init:  
011b			  
011b				  
011b			  
011b					;ld a, 0  
011b					;ld (hardware_diag), a  
011b			  
011b					; clear all the buffers  
011b			  
011b 21 10 ed				ld hl, display_fb1  
011e 22 cc eb				ld (display_fb_active), hl  
0121			  
0121 cd b9 0b				call clear_display  
0124			  
0124 21 ce eb				ld hl, display_fb2  
0127 22 cc eb				ld (display_fb_active), hl  
012a			  
012a cd b9 0b				call clear_display  
012d			  
012d					; init primary frame buffer area  
012d 21 b1 ed				ld hl, display_fb0  
0130 22 cc eb				ld (display_fb_active), hl  
0133			  
0133 cd b9 0b				call clear_display  
0136			  
0136			  
0136 cd 96 66				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0139			  
0139 cd 84 67			call key_init  
013c cd 9e 01			call storage_init  
013f			  
013f				; setup malloc functions  
013f			  
013f				if MALLOC_1  
013f cd f4 13				call  heap_init  
0142				endif  
0142				if MALLOC_4  
0142					call  heap_init  
0142				endif  
0142			  
0142				; init sound hardware if present  
0142			  
0142				if SOUND_ENABLE  
0142					call sound_init  
0142				endif  
0142			  
0142				; lcd test sequence  
0142					  
0142 cd dc 0b			call update_display  
0145 cd f1 0a			call delay1s  
0148 3e 2b			ld a,'+'  
014a cd be 0b			call fill_display  
014d cd dc 0b			call update_display  
0150 cd f1 0a			call delay1s  
0153 3e 2a			ld a,'*'  
0155 cd be 0b			call fill_display  
0158 cd dc 0b			call update_display  
015b cd f1 0a			call delay1s  
015e 3e 2d			ld a,'-'  
0160 cd be 0b			call fill_display  
0163 cd dc 0b			call update_display  
0166 cd f1 0a			call delay1s  
0169			  
0169			; boot splash screen  
0169			if display_cols == 20	  
0169			        ld a, display_row_1    
0169			else  
0169 3e 0a		        ld a, display_row_1 +10   
016b			endif  
016b 11 22 19			ld de, prom_bootmsg  
016e cd cc 0b			call str_at_display  
0171 cd dc 0b			call update_display  
0174			  
0174			  
0174 cd f1 0a			call delay1s  
0177 cd f1 0a			call delay1s  
017a			if display_cols == 20	  
017a			            LD   A, display_row_3+2  
017a			else  
017a 3e 5c		            LD   A, display_row_3+12  
017c			endif  
017c 11 37 19			ld de, prom_bootmsg1  
017f cd cc 0b			call str_at_display  
0182 cd dc 0b			call update_display  
0185 cd f1 0a			call delay1s  
0188 cd f1 0a			call delay1s  
018b			  
018b			;	ld a, display_row_4+3  
018b			;	ld de, bootmsg2  
018b			;	call str_at_display  
018b			;	call update_display  
018b			;	call delay1s  
018b			;	call delay1s  
018b			  
018b			; debug mark setup  
018b			  
018b 3e 5f		ld a, '_'  
018d 32 6b ee		ld (debug_mark),a  
0190 32 6c ee		ld (debug_mark+1),a  
0193 32 6d ee		ld (debug_mark+2),a  
0196 3e 00		ld a,0  
0198 32 6e ee		ld (debug_mark+3),a  
019b			  
019b c9					ret  
019c			  
019c			  
019c			;bootmsg2:	db "Firmware v0.1",0  
019c			  
019c			; a 4x20 lcd  
019c			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019c			  
019c			;if display_cols == 20  
019c			;	include "firmware_lcd_4x20.asm"  
019c			;endif  
019c			  
019c			;if display_cols == 40  
019c			;	include "firmware_lcd_4x40.asm"  
019c			;endif  
019c			  
019c			;  
019c			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019c			; TODO abstract the bit bang video out interface for dual display  
019c			; TODO wire video out to tx pin on rc2014 bus  
019c			  
019c			; must supply cin, and cin_wait for low level hardware abstraction   
019c			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019c			; test scancode  
019c			  
019c			;;;;;  
019c			;;;  
019c			; Moved out to mini and maxi versions  
019c			;  
019c			; include "firmware_key_4x4.asm"  
019c			; using existing 4 wire x 4 resistor array for input  
019c			;include "firmware_key_4x10.asm"  
019c			; need to mod the board for 5 rows due to resistor array  
019c			;include "firmware_key_5x10.asm"  
019c			  
019c			; storage hardware interface  
019c			  
019c			; use microchip serial eeprom for storage  
019c			  
019c			  
019c			if STORAGE_SE  
019c				include "firmware_spi.asm"  
019c				include "firmware_seeprom.asm"  
019c			else  
019c			   ; create some stubs for the labels  
019c c9			se_readbyte: ret  
019d c9			se_writebyte: ret  
019e c9			storage_init: ret  
019f			  
019f			endif  
019f			  
019f			; use cf card for storage - throwing timeout errors. Hardware or software?????  
019f			;include "firmware_cf.asm"  
019f			  
019f			; load up high level storage hardward abstractions  
019f			include "firmware_storage.asm"  
019f			 
019f			; persisent storage hardware abstraction layer  
019f			 
019f			 
019f			 
019f			; Block 0 on storage is a config state 
019f			 
019f			 
019f			 
019f			; TODO add read phy block and write phy block functions 
019f			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
019f			 
019f			; Abstraction layer  
019f			 
019f			; Logocial block size is same size as physical size - using tape concept 
019f			 
019f			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
019f			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
019f			 
019f			 
019f			 
019f			; Filesystem layout (Logical layout) 
019f			; 
019f			; Block 0 - Bank config  
019f			; 
019f			;      Byte - 0 file id counter 
019f			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
019f			;      Byte - 3-20 zero terminated bank label 
019f			; 
019f			; Block 1 > File storage 
019f			; 
019f			;      Byte 0 file id    - block 0 file details 
019f			;      Byte 1 block id - block 0 is file  
019f			;            Byte 2-15 - File name 
019f			; 
019f			;       - to end of block data 
019f			; 
019f			 
019f			; Get ID for the file named in pointer held HL 
019f			; Returns ID in HL = 255 if no file found 
019f			 
019f			storage_getid: 
019f			 
019f 22 73 ea			ld (store_tmp1), hl 
01a2			 
01a2				if DEBUG_STORESE 
01a2					DMARK "SGI" 
01a2 f5				push af  
01a3 3a b7 01			ld a, (.dmark)  
01a6 32 6b ee			ld (debug_mark),a  
01a9 3a b8 01			ld a, (.dmark+1)  
01ac 32 6c ee			ld (debug_mark+1),a  
01af 3a b9 01			ld a, (.dmark+2)  
01b2 32 6d ee			ld (debug_mark+2),a  
01b5 18 03			jr .pastdmark  
01b7 ..			.dmark: db "SGI"  
01ba f1			.pastdmark: pop af  
01bb			endm  
# End of macro DMARK
01bb					CALLMONITOR 
01bb cd 6f ee			call debug_vector  
01be				endm  
# End of macro CALLMONITOR
01be				endif 
01be				; get block 0 and set counter for number of files to scan 
01be			 
01be cd 29 03			call storage_get_block_0 
01c1			 
01c1 3a 7a ea			ld a, (store_page) 
01c4 47				ld b, a 
01c5			 
01c5				; get extent 0 of each file id 
01c5			 
01c5				if DEBUG_STORESE 
01c5					DMARK "SGc" 
01c5 f5				push af  
01c6 3a da 01			ld a, (.dmark)  
01c9 32 6b ee			ld (debug_mark),a  
01cc 3a db 01			ld a, (.dmark+1)  
01cf 32 6c ee			ld (debug_mark+1),a  
01d2 3a dc 01			ld a, (.dmark+2)  
01d5 32 6d ee			ld (debug_mark+2),a  
01d8 18 03			jr .pastdmark  
01da ..			.dmark: db "SGc"  
01dd f1			.pastdmark: pop af  
01de			endm  
# End of macro DMARK
01de					CALLMONITOR 
01de cd 6f ee			call debug_vector  
01e1				endm  
# End of macro CALLMONITOR
01e1				endif 
01e1 60			.getloop:	ld h, b 
01e2 2e 00				ld l, 0 
01e4 c5					push bc 
01e5			 
01e5 11 7a ea				ld de, store_page 
01e8				if DEBUG_STORESE 
01e8					DMARK "SGr" 
01e8 f5				push af  
01e9 3a fd 01			ld a, (.dmark)  
01ec 32 6b ee			ld (debug_mark),a  
01ef 3a fe 01			ld a, (.dmark+1)  
01f2 32 6c ee			ld (debug_mark+1),a  
01f5 3a ff 01			ld a, (.dmark+2)  
01f8 32 6d ee			ld (debug_mark+2),a  
01fb 18 03			jr .pastdmark  
01fd ..			.dmark: db "SGr"  
0200 f1			.pastdmark: pop af  
0201			endm  
# End of macro DMARK
0201					CALLMONITOR 
0201 cd 6f ee			call debug_vector  
0204				endm  
# End of macro CALLMONITOR
0204				endif 
0204 cd d1 07				call storage_read 
0207 cd 0f 0e				call ishlzero 
020a 28 2d				jr z, .gap 
020c					 
020c					; have a file name read. Is it one we want. 
020c			 
020c 2a 73 ea				ld hl, (store_tmp1) 
020f 11 7d ea				ld de, store_page+3   ; file name 
0212			 
0212				if DEBUG_STORESE 
0212					DMARK "SGc" 
0212 f5				push af  
0213 3a 27 02			ld a, (.dmark)  
0216 32 6b ee			ld (debug_mark),a  
0219 3a 28 02			ld a, (.dmark+1)  
021c 32 6c ee			ld (debug_mark+1),a  
021f 3a 29 02			ld a, (.dmark+2)  
0222 32 6d ee			ld (debug_mark+2),a  
0225 18 03			jr .pastdmark  
0227 ..			.dmark: db "SGc"  
022a f1			.pastdmark: pop af  
022b			endm  
# End of macro DMARK
022b					CALLMONITOR 
022b cd 6f ee			call debug_vector  
022e				endm  
# End of macro CALLMONITOR
022e				endif 
022e cd db 13				call strcmp 
0231 20 06				jr nz, .gap   ; not this one 
0233			 
0233 c1				        pop bc 
0234			 
0234 26 00				ld h, 0 
0236 68					ld l, b 
0237 18 22				jr .getdone 
0239						 
0239			 
0239			 
0239			 
0239			.gap: 
0239				if DEBUG_STORESE 
0239					DMARK "SGg" 
0239 f5				push af  
023a 3a 4e 02			ld a, (.dmark)  
023d 32 6b ee			ld (debug_mark),a  
0240 3a 4f 02			ld a, (.dmark+1)  
0243 32 6c ee			ld (debug_mark+1),a  
0246 3a 50 02			ld a, (.dmark+2)  
0249 32 6d ee			ld (debug_mark+2),a  
024c 18 03			jr .pastdmark  
024e ..			.dmark: db "SGg"  
0251 f1			.pastdmark: pop af  
0252			endm  
# End of macro DMARK
0252					CALLMONITOR 
0252 cd 6f ee			call debug_vector  
0255				endm  
# End of macro CALLMONITOR
0255				endif 
0255			 
0255 c1					pop bc 
0256 10 89				djnz .getloop 
0258 21 ff 00				ld hl, 255 
025b			.getdone: 
025b			 
025b				if DEBUG_STORESE 
025b					DMARK "SGe" 
025b f5				push af  
025c 3a 70 02			ld a, (.dmark)  
025f 32 6b ee			ld (debug_mark),a  
0262 3a 71 02			ld a, (.dmark+1)  
0265 32 6c ee			ld (debug_mark+1),a  
0268 3a 72 02			ld a, (.dmark+2)  
026b 32 6d ee			ld (debug_mark+2),a  
026e 18 03			jr .pastdmark  
0270 ..			.dmark: db "SGe"  
0273 f1			.pastdmark: pop af  
0274			endm  
# End of macro DMARK
0274					CALLMONITOR 
0274 cd 6f ee			call debug_vector  
0277				endm  
# End of macro CALLMONITOR
0277				endif 
0277			 
0277 c9				ret 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			; Read Block 
0278			; ---------- 
0278			; 
0278			; With current bank 
0278			;  
0278			; Get block number to read 
0278			; Load physical blocks starting at start block into buffer 
0278			 
0278			; de points to buffer to use 
0278			; hl holds logical block number  
0278			 
0278			storage_read_block: 
0278			 
0278				; TODO bank selection 
0278			 
0278				; for each of the physical blocks read it into the buffer 
0278 06 40			ld b, STORE_BLOCK_PHY 
027a			 
027a				if DEBUG_STORESE 
027a d5					push de 
027b				endif 
027b				 
027b			.rl1:    
027b			 
027b				; read physical block at hl into de 
027b			        ; increment hl and de to next read position on exit 
027b			 
027b e5				push hl 
027c d5				push de	 
027d c5				push bc 
027e			;	if DEBUG_STORESE 
027e			;		push af 
027e			;		ld a, 'R' 
027e			;		ld (debug_mark),a 
027e			;		pop af 
027e			;		CALLMONITOR 
027e			;	endif 
027e cd 9c 01			call se_readbyte 
0281			;	if DEBUG_STORESE 
0281			;		ld a,(spi_portbyte) 
0281			;		ld l, a 
0281			;		push af 
0281			;		ld a, '1' 
0281			;		ld (debug_mark),a 
0281			;		pop af 
0281			;		CALLMONITOR 
0281			;	endif 
0281 c1				pop bc 
0282 d1				pop de 
0283 e1				pop hl 
0284 12				ld (de),a 
0285 23				inc hl 
0286 13				inc de 
0287			 
0287			;	if DEBUG_STORESE 
0287			;		push af 
0287			;		ld a, 'r' 
0287			;		ld (debug_mark),a 
0287			;		pop af 
0287			;		CALLMONITOR 
0287			;	endif 
0287			 
0287 10 f2			djnz .rl1 
0289			 
0289				if DEBUG_STORESE 
0289					DMARK "SRB" 
0289 f5				push af  
028a 3a 9e 02			ld a, (.dmark)  
028d 32 6b ee			ld (debug_mark),a  
0290 3a 9f 02			ld a, (.dmark+1)  
0293 32 6c ee			ld (debug_mark+1),a  
0296 3a a0 02			ld a, (.dmark+2)  
0299 32 6d ee			ld (debug_mark+2),a  
029c 18 03			jr .pastdmark  
029e ..			.dmark: db "SRB"  
02a1 f1			.pastdmark: pop af  
02a2			endm  
# End of macro DMARK
02a2 d1					pop de 
02a3			; 
02a3			;		push af 
02a3			;		ld a, 'R' 
02a3			;		ld (debug_mark),a 
02a3			;		pop af 
02a3					CALLMONITOR 
02a3 cd 6f ee			call debug_vector  
02a6				endm  
# End of macro CALLMONITOR
02a6				endif 
02a6 c9				ret	 
02a7				 
02a7			 
02a7			; File Size 
02a7			; --------- 
02a7			; 
02a7			;   hl file id 
02a7			; 
02a7			;  returns in hl the number of blocks 
02a7			 
02a7			storage_file_size: 
02a7 5d				ld e, l 
02a8 16 00			ld d, 0 
02aa 21 40 00			ld hl, STORE_BLOCK_PHY 
02ad					if DEBUG_FORTH_WORDS 
02ad						DMARK "SIZ" 
02ad f5				push af  
02ae 3a c2 02			ld a, (.dmark)  
02b1 32 6b ee			ld (debug_mark),a  
02b4 3a c3 02			ld a, (.dmark+1)  
02b7 32 6c ee			ld (debug_mark+1),a  
02ba 3a c4 02			ld a, (.dmark+2)  
02bd 32 6d ee			ld (debug_mark+2),a  
02c0 18 03			jr .pastdmark  
02c2 ..			.dmark: db "SIZ"  
02c5 f1			.pastdmark: pop af  
02c6			endm  
# End of macro DMARK
02c6						CALLMONITOR 
02c6 cd 6f ee			call debug_vector  
02c9				endm  
# End of macro CALLMONITOR
02c9					endif 
02c9 cd ab 05			call storage_findnextid 
02cc			 
02cc cd 0f 0e			call ishlzero 
02cf			;	ld a, l 
02cf			;	add h 
02cf			;	cp 0 
02cf c8				ret z			; block not found so EOF 
02d0			 
02d0 11 7a ea			ld de, store_page 
02d3 cd 78 02			call storage_read_block 
02d6			 
02d6 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
02d9 6f				ld l, a 
02da 26 00			ld h, 0 
02dc c9			 	ret 
02dd			 
02dd			 
02dd			; Write Block 
02dd			; ----------- 
02dd			; 
02dd			; With current bank 
02dd			;  
02dd			; Get block number to write 
02dd			; Write physical blocks starting at start block from buffer 
02dd			  
02dd			storage_write_block: 
02dd				; TODO bank selection 
02dd			 
02dd				; for each of the physical blocks read it into the buffer 
02dd 06 40			ld b, STORE_BLOCK_PHY 
02df			 
02df				if DEBUG_STORESE 
02df					DMARK "SWB" 
02df f5				push af  
02e0 3a f4 02			ld a, (.dmark)  
02e3 32 6b ee			ld (debug_mark),a  
02e6 3a f5 02			ld a, (.dmark+1)  
02e9 32 6c ee			ld (debug_mark+1),a  
02ec 3a f6 02			ld a, (.dmark+2)  
02ef 32 6d ee			ld (debug_mark+2),a  
02f2 18 03			jr .pastdmark  
02f4 ..			.dmark: db "SWB"  
02f7 f1			.pastdmark: pop af  
02f8			endm  
# End of macro DMARK
02f8			 
02f8					;push af 
02f8					;ld a, 'W' 
02f8					;ld (debug_mark),a 
02f8					;pop af 
02f8					CALLMONITOR 
02f8 cd 6f ee			call debug_vector  
02fb				endm  
# End of macro CALLMONITOR
02fb				endif 
02fb			 
02fb			; might not be working 
02fb			;	call se_writepage 
02fb			 
02fb			;	ret 
02fb			; 
02fb			 
02fb			 
02fb			 
02fb			.wl1:    
02fb			 
02fb				; read physical block at hl into de 
02fb			        ; increment hl and de to next read position on exit 
02fb			 
02fb e5				push hl 
02fc d5				push de	 
02fd c5				push bc 
02fe 1a				ld a,(de) 
02ff				;if DEBUG_STORESE 
02ff			;		push af 
02ff			;		ld a, 'W' 
02ff			;		ld (debug_mark),a 
02ff			;		pop af 
02ff			;		CALLMONITOR 
02ff			;	endif 
02ff cd 9d 01			call se_writebyte 
0302			;	call delay250ms 
0302 00				nop 
0303 00				nop 
0304 00				nop 
0305			;	if DEBUG_STORESE 
0305			;		push af 
0305			;		ld a, 'w' 
0305			;		ld (debug_mark),a 
0305			;		pop af 
0305			;		CALLMONITOR 
0305			;	endif 
0305 c1				pop bc 
0306 d1				pop de 
0307 e1				pop hl 
0308 23				inc hl 
0309 13				inc de 
030a			 
030a			 
030a 10 ef			djnz .wl1 
030c			 
030c				if DEBUG_STORESE 
030c					DMARK "SW2" 
030c f5				push af  
030d 3a 21 03			ld a, (.dmark)  
0310 32 6b ee			ld (debug_mark),a  
0313 3a 22 03			ld a, (.dmark+1)  
0316 32 6c ee			ld (debug_mark+1),a  
0319 3a 23 03			ld a, (.dmark+2)  
031c 32 6d ee			ld (debug_mark+2),a  
031f 18 03			jr .pastdmark  
0321 ..			.dmark: db "SW2"  
0324 f1			.pastdmark: pop af  
0325			endm  
# End of macro DMARK
0325			 
0325					;push af 
0325					;ld a, 'W' 
0325					;ld (debug_mark),a 
0325					;pop af 
0325					CALLMONITOR 
0325 cd 6f ee			call debug_vector  
0328				endm  
# End of macro CALLMONITOR
0328				endif 
0328 c9				ret	 
0329			 
0329			; Init bank 
0329			; --------- 
0329			; 
0329			; With current bank 
0329			; 
0329			; Setup block 0 config 
0329			;     Set 0 file id counter 
0329			;     Set formatted byte pattern 
0329			;     Zero out bank label 
0329			;      
0329			; For every logical block write 0-1 byte as null 
0329			 
0329			storage_get_block_0: 
0329			 
0329				; TODO check presence 
0329			 
0329				; get block 0 config 
0329			 
0329 21 00 00			ld hl, 0 
032c 11 7a ea			ld de, store_page 
032f cd 78 02			call storage_read_block 
0332			 
0332				if DEBUG_STORESE 
0332					DMARK "SB0" 
0332 f5				push af  
0333 3a 47 03			ld a, (.dmark)  
0336 32 6b ee			ld (debug_mark),a  
0339 3a 48 03			ld a, (.dmark+1)  
033c 32 6c ee			ld (debug_mark+1),a  
033f 3a 49 03			ld a, (.dmark+2)  
0342 32 6d ee			ld (debug_mark+2),a  
0345 18 03			jr .pastdmark  
0347 ..			.dmark: db "SB0"  
034a f1			.pastdmark: pop af  
034b			endm  
# End of macro DMARK
034b 11 7a ea				ld de, store_page 
034e			;		push af 
034e			;		ld a, 'i' 
034e			;		ld (debug_mark),a 
034e			;		pop af 
034e					CALLMONITOR 
034e cd 6f ee			call debug_vector  
0351				endm  
# End of macro CALLMONITOR
0351				endif 
0351			 
0351				; is this area formatted? 
0351			 
0351			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0351 2a 7b ea			ld hl, (store_page+1) 
0354 3e 80			ld a,0x80 
0356 bd				cp l 
0357 20 22			jr nz, .ininotformatted 
0359				; do a double check 
0359 3e 27			ld a, 0x27 
035b bc				cp h 
035c 20 1d			jr nz, .ininotformatted 
035e			 
035e				; formatted then 
035e			 
035e				if DEBUG_STORESE 
035e					DMARK "SB1" 
035e f5				push af  
035f 3a 73 03			ld a, (.dmark)  
0362 32 6b ee			ld (debug_mark),a  
0365 3a 74 03			ld a, (.dmark+1)  
0368 32 6c ee			ld (debug_mark+1),a  
036b 3a 75 03			ld a, (.dmark+2)  
036e 32 6d ee			ld (debug_mark+2),a  
0371 18 03			jr .pastdmark  
0373 ..			.dmark: db "SB1"  
0376 f1			.pastdmark: pop af  
0377			endm  
# End of macro DMARK
0377					;push af 
0377					;ld a, 'I' 
0377					;ld (debug_mark),a 
0377					;pop af 
0377					CALLMONITOR 
0377 cd 6f ee			call debug_vector  
037a				endm  
# End of macro CALLMONITOR
037a				endif 
037a c9				ret 
037b			 
037b			.ininotformatted: 
037b				; bank not formatted so poke various bits to make sure 
037b			 
037b				if DEBUG_STORESE 
037b					DMARK "SB2" 
037b f5				push af  
037c 3a 90 03			ld a, (.dmark)  
037f 32 6b ee			ld (debug_mark),a  
0382 3a 91 03			ld a, (.dmark+1)  
0385 32 6c ee			ld (debug_mark+1),a  
0388 3a 92 03			ld a, (.dmark+2)  
038b 32 6d ee			ld (debug_mark+2),a  
038e 18 03			jr .pastdmark  
0390 ..			.dmark: db "SB2"  
0393 f1			.pastdmark: pop af  
0394			endm  
# End of macro DMARK
0394					;push af 
0394					;ld a, 'f' 
0394					;ld (debug_mark),a 
0394					;pop af 
0394					CALLMONITOR 
0394 cd 6f ee			call debug_vector  
0397				endm  
# End of macro CALLMONITOR
0397				endif 
0397			 
0397 cd b4 0a			call storage_clear_page 
039a			 
039a 21 7a ea			ld hl, store_page 
039d 3e 00			ld a, 0 
039f				 
039f 77				ld (hl),a   ; reset file counter 
03a0			 
03a0 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a3 22 7b ea		 	ld (store_page+1), hl	 
03a6			 
03a6				; set default label 
03a6			 
03a6 21 42 04			ld hl, .defaultbanklabl 
03a9 11 7d ea		 	ld de, store_page+3 
03ac 01 0f 00			ld bc, 15 
03af ed b0			ldir 
03b1			 
03b1				; Append the current bank id 
03b1 21 86 ea			ld hl, store_page+3+9 
03b4 3a 5f ea			ld a, (spi_device_id) 
03b7 77				ld (hl), a 
03b8			 
03b8				; save default page 0 
03b8			 
03b8 21 00 00			ld hl, 0 
03bb 11 7a ea			ld de, store_page 
03be				if DEBUG_STORESE 
03be					DMARK "SB3" 
03be f5				push af  
03bf 3a d3 03			ld a, (.dmark)  
03c2 32 6b ee			ld (debug_mark),a  
03c5 3a d4 03			ld a, (.dmark+1)  
03c8 32 6c ee			ld (debug_mark+1),a  
03cb 3a d5 03			ld a, (.dmark+2)  
03ce 32 6d ee			ld (debug_mark+2),a  
03d1 18 03			jr .pastdmark  
03d3 ..			.dmark: db "SB3"  
03d6 f1			.pastdmark: pop af  
03d7			endm  
# End of macro DMARK
03d7			;		push af 
03d7			;		ld a, 'F' 
03d7			;		ld (debug_mark),a 
03d7			;		pop af 
03d7					CALLMONITOR 
03d7 cd 6f ee			call debug_vector  
03da				endm  
# End of macro CALLMONITOR
03da				endif 
03da cd dd 02			call storage_write_block 
03dd				if DEBUG_STORESE 
03dd					DMARK "SB4" 
03dd f5				push af  
03de 3a f2 03			ld a, (.dmark)  
03e1 32 6b ee			ld (debug_mark),a  
03e4 3a f3 03			ld a, (.dmark+1)  
03e7 32 6c ee			ld (debug_mark+1),a  
03ea 3a f4 03			ld a, (.dmark+2)  
03ed 32 6d ee			ld (debug_mark+2),a  
03f0 18 03			jr .pastdmark  
03f2 ..			.dmark: db "SB4"  
03f5 f1			.pastdmark: pop af  
03f6			endm  
# End of macro DMARK
03f6			;		push af 
03f6			;		ld a, '>' 
03f6			;		ld (debug_mark),a 
03f6			;		pop af 
03f6					CALLMONITOR 
03f6 cd 6f ee			call debug_vector  
03f9				endm  
# End of macro CALLMONITOR
03f9				endif 
03f9			 
03f9 00				nop 
03fa 00				nop 
03fb 00				nop 
03fc			 
03fc				; now set 0 in every page to mark as a free block 
03fc			 
03fc 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03fe 21 40 00			ld hl, STORE_BLOCK_PHY 
0401			 
0401 3e 00		.setmark1:   	ld a,0 
0403 e5					push hl 
0404 c5					push bc 
0405 cd 9d 01				call se_writebyte 
0408 3e 0a			ld a, 10 
040a cd d6 0a			call aDelayInMS 
040d 23				inc hl 
040e cd 9d 01				call se_writebyte 
0411 3e 0a			ld a, 10 
0413 cd d6 0a			call aDelayInMS 
0416 2b				dec hl 
0417 c1					pop bc 
0418 e1					pop hl 
0419 3e 40				ld a, STORE_BLOCK_PHY 
041b cd e6 0d				call addatohl 
041e 10 e1				djnz .setmark1 
0420			 
0420 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0422 3e 00		.setmark2:   	ld a,0 
0424 e5					push hl 
0425 c5					push bc 
0426 cd 9d 01				call se_writebyte 
0429 3e 0a			ld a, 10 
042b cd d6 0a			call aDelayInMS 
042e 23				inc hl 
042f cd 9d 01				call se_writebyte 
0432 3e 0a			ld a, 10 
0434 cd d6 0a			call aDelayInMS 
0437 2b				dec hl 
0438 c1					pop bc 
0439 e1					pop hl 
043a 3e 40				ld a, STORE_BLOCK_PHY 
043c cd e6 0d				call addatohl 
043f 10 e1				djnz .setmark2 
0441			 
0441					 
0441			 
0441			 
0441 c9				ret 
0442			 
0442			 
0442			 
0442			 
0442 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044d			 
044d			 
044d			 
044d			; Label Bank 
044d			; ---------- 
044d			; 
044d			; With current bank 
044d			; Read block 0 
044d			; Set label 
044d			; Write block 0 
044d			 
044d			; label str pointer in hl 
044d			 
044d			storage_label:     
044d			 
044d				if DEBUG_STORESE 
044d					DMARK "LBL" 
044d f5				push af  
044e 3a 62 04			ld a, (.dmark)  
0451 32 6b ee			ld (debug_mark),a  
0454 3a 63 04			ld a, (.dmark+1)  
0457 32 6c ee			ld (debug_mark+1),a  
045a 3a 64 04			ld a, (.dmark+2)  
045d 32 6d ee			ld (debug_mark+2),a  
0460 18 03			jr .pastdmark  
0462 ..			.dmark: db "LBL"  
0465 f1			.pastdmark: pop af  
0466			endm  
# End of macro DMARK
0466					CALLMONITOR 
0466 cd 6f ee			call debug_vector  
0469				endm  
# End of macro CALLMONITOR
0469				endif 
0469			 
0469 e5				push hl 
046a			 
046a cd 29 03			call storage_get_block_0 
046d			 
046d				; set default label 
046d			 
046d e1				pop hl 
046e			 
046e 11 7d ea		 	ld de, store_page+3 
0471 01 0f 00			ld bc, 15 
0474				if DEBUG_STORESE 
0474					DMARK "LB3" 
0474 f5				push af  
0475 3a 89 04			ld a, (.dmark)  
0478 32 6b ee			ld (debug_mark),a  
047b 3a 8a 04			ld a, (.dmark+1)  
047e 32 6c ee			ld (debug_mark+1),a  
0481 3a 8b 04			ld a, (.dmark+2)  
0484 32 6d ee			ld (debug_mark+2),a  
0487 18 03			jr .pastdmark  
0489 ..			.dmark: db "LB3"  
048c f1			.pastdmark: pop af  
048d			endm  
# End of macro DMARK
048d					CALLMONITOR 
048d cd 6f ee			call debug_vector  
0490				endm  
# End of macro CALLMONITOR
0490				endif 
0490 ed b0			ldir 
0492				; save default page 0 
0492			 
0492 21 00 00			ld hl, 0 
0495 11 7a ea			ld de, store_page 
0498				if DEBUG_STORESE 
0498					DMARK "LBW" 
0498 f5				push af  
0499 3a ad 04			ld a, (.dmark)  
049c 32 6b ee			ld (debug_mark),a  
049f 3a ae 04			ld a, (.dmark+1)  
04a2 32 6c ee			ld (debug_mark+1),a  
04a5 3a af 04			ld a, (.dmark+2)  
04a8 32 6d ee			ld (debug_mark+2),a  
04ab 18 03			jr .pastdmark  
04ad ..			.dmark: db "LBW"  
04b0 f1			.pastdmark: pop af  
04b1			endm  
# End of macro DMARK
04b1					CALLMONITOR 
04b1 cd 6f ee			call debug_vector  
04b4				endm  
# End of macro CALLMONITOR
04b4				endif 
04b4 cd dd 02			call storage_write_block 
04b7			 
04b7 c9				ret 
04b8			 
04b8			 
04b8			 
04b8			; Read Block 0 - Config 
04b8			; --------------------- 
04b8			; 
04b8			; With current bank 
04b8			; Call presence test 
04b8			;    If not present format/init bank  
04b8			; Read block 0  
04b8			;  
04b8			 
04b8			 
04b8			; Dir 
04b8			; --- 
04b8			; 
04b8			; With current bank 
04b8			; Load Block 0 Config 
04b8			; Get max file id number 
04b8			; For each logical block 
04b8			;    Read block read byte 2 
04b8			;      if first block of file 
04b8			;         Display file name 
04b8			;         Display type flags for file 
04b8			;        
04b8			 
04b8			; moving to words as this requires stack control 
04b8			 
04b8			 
04b8			; Delete File 
04b8			; ----------- 
04b8			; 
04b8			; With current bank 
04b8			; 
04b8			; Load Block 0 Config 
04b8			; Get max file id number 
04b8			; For each logical block 
04b8			;    Read block file id 
04b8			;      If first block of file and dont have file id 
04b8			;         if file to delete 
04b8			;         Save file id 
04b8			;         Null file id 
04b8			;         Write this block back 
04b8			;      If file id is one saved 
04b8			;         Null file id 
04b8			;         Write this block back 
04b8			 
04b8			 
04b8			.se_done: 
04b8 e1				pop hl 
04b9 c9				ret 
04ba			 
04ba			storage_erase: 
04ba			 
04ba				; hl contains the file id 
04ba			 
04ba 5d				ld e, l 
04bb 16 00			ld d, 0 
04bd 21 40 00			ld hl, STORE_BLOCK_PHY 
04c0					if DEBUG_FORTH_WORDS 
04c0						DMARK "ERA" 
04c0 f5				push af  
04c1 3a d5 04			ld a, (.dmark)  
04c4 32 6b ee			ld (debug_mark),a  
04c7 3a d6 04			ld a, (.dmark+1)  
04ca 32 6c ee			ld (debug_mark+1),a  
04cd 3a d7 04			ld a, (.dmark+2)  
04d0 32 6d ee			ld (debug_mark+2),a  
04d3 18 03			jr .pastdmark  
04d5 ..			.dmark: db "ERA"  
04d8 f1			.pastdmark: pop af  
04d9			endm  
# End of macro DMARK
04d9						CALLMONITOR 
04d9 cd 6f ee			call debug_vector  
04dc				endm  
# End of macro CALLMONITOR
04dc					endif 
04dc cd ab 05			call storage_findnextid 
04df cd 0f 0e			call ishlzero 
04e2 c8				ret z 
04e3			 
04e3 e5				push hl 
04e4			 
04e4				; TODO check file not found 
04e4			 
04e4 11 7a ea			ld de, store_page 
04e7 cd 78 02			call storage_read_block 
04ea			 
04ea cd 0f 0e			call ishlzero 
04ed ca b8 04			jp z,.se_done 
04f0			 
04f0					if DEBUG_FORTH_WORDS 
04f0						DMARK "ER1" 
04f0 f5				push af  
04f1 3a 05 05			ld a, (.dmark)  
04f4 32 6b ee			ld (debug_mark),a  
04f7 3a 06 05			ld a, (.dmark+1)  
04fa 32 6c ee			ld (debug_mark+1),a  
04fd 3a 07 05			ld a, (.dmark+2)  
0500 32 6d ee			ld (debug_mark+2),a  
0503 18 03			jr .pastdmark  
0505 ..			.dmark: db "ER1"  
0508 f1			.pastdmark: pop af  
0509			endm  
# End of macro DMARK
0509						CALLMONITOR 
0509 cd 6f ee			call debug_vector  
050c				endm  
# End of macro CALLMONITOR
050c					endif 
050c 3a 7a ea			ld a, (store_page)	; get file id 
050f 32 6e ea			ld (store_tmpid), a 
0512			 
0512 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
0515 32 6d ea			ld (store_tmpext), a 
0518			 
0518				; wipe file header 
0518			 
0518 e1				pop hl 
0519 3e 00			ld a, 0 
051b 32 7a ea			ld (store_page), a 
051e 32 7b ea			ld (store_page+1),a 
0521 11 7a ea			ld de, store_page 
0524					if DEBUG_FORTH_WORDS 
0524						DMARK "ER2" 
0524 f5				push af  
0525 3a 39 05			ld a, (.dmark)  
0528 32 6b ee			ld (debug_mark),a  
052b 3a 3a 05			ld a, (.dmark+1)  
052e 32 6c ee			ld (debug_mark+1),a  
0531 3a 3b 05			ld a, (.dmark+2)  
0534 32 6d ee			ld (debug_mark+2),a  
0537 18 03			jr .pastdmark  
0539 ..			.dmark: db "ER2"  
053c f1			.pastdmark: pop af  
053d			endm  
# End of macro DMARK
053d						CALLMONITOR 
053d cd 6f ee			call debug_vector  
0540				endm  
# End of macro CALLMONITOR
0540					endif 
0540 cd dd 02			call storage_write_block 
0543			 
0543			 
0543				; wipe file extents 
0543			 
0543 3a 6d ea			ld a, (store_tmpext) 
0546 47				ld b, a 
0547			 
0547			.eraext:	  
0547 c5				push bc 
0548			 
0548 21 40 00			ld hl, STORE_BLOCK_PHY 
054b 3a 6e ea			ld a,(store_tmpid) 
054e 5f				ld e, a 
054f 50				ld d, b	 
0550					if DEBUG_FORTH_WORDS 
0550						DMARK "ER3" 
0550 f5				push af  
0551 3a 65 05			ld a, (.dmark)  
0554 32 6b ee			ld (debug_mark),a  
0557 3a 66 05			ld a, (.dmark+1)  
055a 32 6c ee			ld (debug_mark+1),a  
055d 3a 67 05			ld a, (.dmark+2)  
0560 32 6d ee			ld (debug_mark+2),a  
0563 18 03			jr .pastdmark  
0565 ..			.dmark: db "ER3"  
0568 f1			.pastdmark: pop af  
0569			endm  
# End of macro DMARK
0569						CALLMONITOR 
0569 cd 6f ee			call debug_vector  
056c				endm  
# End of macro CALLMONITOR
056c					endif 
056c cd ab 05			call storage_findnextid 
056f cd 0f 0e			call ishlzero 
0572 ca b8 04			jp z,.se_done 
0575			 
0575 e5				push hl 
0576 11 7a ea			ld de, store_page 
0579 cd 78 02			call storage_read_block 
057c			 
057c				; free block	 
057c			 
057c 3e 00			ld a, 0 
057e 32 7a ea			ld (store_page), a 
0581 32 7b ea			ld (store_page+1),a 
0584 11 7a ea			ld de, store_page 
0587 e1				pop hl 
0588					if DEBUG_FORTH_WORDS 
0588						DMARK "ER4" 
0588 f5				push af  
0589 3a 9d 05			ld a, (.dmark)  
058c 32 6b ee			ld (debug_mark),a  
058f 3a 9e 05			ld a, (.dmark+1)  
0592 32 6c ee			ld (debug_mark+1),a  
0595 3a 9f 05			ld a, (.dmark+2)  
0598 32 6d ee			ld (debug_mark+2),a  
059b 18 03			jr .pastdmark  
059d ..			.dmark: db "ER4"  
05a0 f1			.pastdmark: pop af  
05a1			endm  
# End of macro DMARK
05a1						CALLMONITOR 
05a1 cd 6f ee			call debug_vector  
05a4				endm  
# End of macro CALLMONITOR
05a4					endif 
05a4 cd dd 02			call storage_write_block 
05a7			 
05a7 c1				pop bc 
05a8 10 9d			djnz .eraext 
05aa			 
05aa c9				ret 
05ab			 
05ab			 
05ab			; Find Free Block 
05ab			; --------------- 
05ab			; 
05ab			; With current bank 
05ab			;  
05ab			; From given starting logical block 
05ab			;    Read block  
05ab			;    If no file id 
05ab			;         Return block id 
05ab			 
05ab			 
05ab			; hl starting page number 
05ab			; hl contains free page number or zero if no pages free 
05ab			; e contains the file id to locate 
05ab			; d contains the block number 
05ab			 
05ab			; TODO change to find file id and use zero for free block 
05ab			 
05ab			storage_findnextid: 
05ab			 
05ab				; now locate first 0 page to mark as a free block 
05ab			 
05ab 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ad			;	ld hl, STORE_BLOCK_PHY 
05ad			 
05ad					if DEBUG_FORTH_WORDS 
05ad					DMARK "FNI" 
05ad f5				push af  
05ae 3a c2 05			ld a, (.dmark)  
05b1 32 6b ee			ld (debug_mark),a  
05b4 3a c3 05			ld a, (.dmark+1)  
05b7 32 6c ee			ld (debug_mark+1),a  
05ba 3a c4 05			ld a, (.dmark+2)  
05bd 32 6d ee			ld (debug_mark+2),a  
05c0 18 03			jr .pastdmark  
05c2 ..			.dmark: db "FNI"  
05c5 f1			.pastdmark: pop af  
05c6			endm  
# End of macro DMARK
05c6						CALLMONITOR 
05c6 cd 6f ee			call debug_vector  
05c9				endm  
# End of macro CALLMONITOR
05c9					endif 
05c9			.ff1:   	 
05c9 e5					push hl 
05ca c5					push bc 
05cb d5					push de 
05cc cd 9c 01				call se_readbyte 
05cf 5f					ld e,a 
05d0 23					inc hl 
05d1 cd 9c 01				call se_readbyte 
05d4 57					ld d, a 
05d5 e1					pop hl 
05d6 e5					push hl 
05d7 cd 04 0e				call cmp16 
05da 28 49				jr z, .fffound 
05dc			 
05dc d1					pop de 
05dd c1					pop bc 
05de e1					pop hl 
05df			 
05df					; is found? 
05df					;cp e 
05df					;ret z 
05df			 
05df 3e 40				ld a, STORE_BLOCK_PHY 
05e1 cd e6 0d				call addatohl 
05e4 10 e3				djnz .ff1 
05e6			 
05e6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e8			.ff2:   	 
05e8			 
05e8 e5					push hl 
05e9 c5					push bc 
05ea d5					push de 
05eb cd 9c 01				call se_readbyte 
05ee 5f					ld e,a 
05ef 23					inc hl 
05f0 cd 9c 01				call se_readbyte 
05f3 57					ld d, a 
05f4			 
05f4 e1					pop hl 
05f5 e5					push hl 
05f6 cd 04 0e				call cmp16 
05f9 28 2a				jr z, .fffound 
05fb			 
05fb d1					pop de 
05fc c1					pop bc 
05fd e1					pop hl 
05fe					; is found? 
05fe					;cp e 
05fe					;ret z 
05fe			 
05fe 3e 40				ld a, STORE_BLOCK_PHY 
0600 cd e6 0d				call addatohl 
0603 10 e3				djnz .ff2 
0605			 
0605			 
0605					if DEBUG_FORTH_WORDS 
0605					DMARK "FN-" 
0605 f5				push af  
0606 3a 1a 06			ld a, (.dmark)  
0609 32 6b ee			ld (debug_mark),a  
060c 3a 1b 06			ld a, (.dmark+1)  
060f 32 6c ee			ld (debug_mark+1),a  
0612 3a 1c 06			ld a, (.dmark+2)  
0615 32 6d ee			ld (debug_mark+2),a  
0618 18 03			jr .pastdmark  
061a ..			.dmark: db "FN-"  
061d f1			.pastdmark: pop af  
061e			endm  
# End of macro DMARK
061e					;	push af 
061e					;	ld a, 'n' 
061e					;	ld (debug_mark),a 
061e					;	pop af 
061e						CALLMONITOR 
061e cd 6f ee			call debug_vector  
0621				endm  
# End of macro CALLMONITOR
0621					endif 
0621				; no free marks! 
0621 21 00 00				ld hl, 0 
0624 c9				ret 
0625			.fffound: 
0625				 
0625			 
0625 d1					pop de 
0626 c1					pop bc 
0627 e1					pop hl 
0628					if DEBUG_FORTH_WORDS 
0628					DMARK "FNF" 
0628 f5				push af  
0629 3a 3d 06			ld a, (.dmark)  
062c 32 6b ee			ld (debug_mark),a  
062f 3a 3e 06			ld a, (.dmark+1)  
0632 32 6c ee			ld (debug_mark+1),a  
0635 3a 3f 06			ld a, (.dmark+2)  
0638 32 6d ee			ld (debug_mark+2),a  
063b 18 03			jr .pastdmark  
063d ..			.dmark: db "FNF"  
0640 f1			.pastdmark: pop af  
0641			endm  
# End of macro DMARK
0641					;	push af 
0641					;	ld a, 'n' 
0641					;	ld (debug_mark),a 
0641					;	pop af 
0641						CALLMONITOR 
0641 cd 6f ee			call debug_vector  
0644				endm  
# End of macro CALLMONITOR
0644					endif 
0644 c9				ret 
0645			 
0645			 
0645			 
0645			; Free Space 
0645			; ---------- 
0645			; 
0645			; With current bank 
0645			; 
0645			; Set block count to zero 
0645			; Starting with first logical block 
0645			;      Find free block  
0645			;      If block id given, increment block count 
0645			; 
0645			;  
0645			 
0645			 
0645			; hl contains count of free blocks 
0645			 
0645			storage_freeblocks: 
0645			 
0645				; now locate first 0 page to mark as a free block 
0645			 
0645 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0647 21 40 00			ld hl, STORE_BLOCK_PHY 
064a 11 00 00			ld de, 0 
064d			 
064d			.fb1:   	 
064d e5					push hl 
064e c5					push bc 
064f d5					push de 
0650 cd 9c 01				call se_readbyte 
0653 d1					pop de 
0654 c1					pop bc 
0655 e1					pop hl 
0656			 
0656					; is free? 
0656 fe 00				cp 0 
0658 20 01				jr nz, .ff1cont 
065a 13					inc de 
065b			 
065b			.ff1cont: 
065b			 
065b			 
065b 3e 40				ld a, STORE_BLOCK_PHY 
065d cd e6 0d				call addatohl 
0660 10 eb				djnz .fb1 
0662			 
0662 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0664			.fb2:   	 
0664 e5					push hl 
0665 c5					push bc 
0666 d5					push de 
0667 cd 9c 01				call se_readbyte 
066a d1					pop de 
066b c1					pop bc 
066c e1					pop hl 
066d			 
066d					; is free? 
066d fe 00				cp 0 
066f 20 01				jr nz, .ff2cont 
0671 13					inc de 
0672			 
0672			.ff2cont: 
0672			 
0672 3e 40				ld a, STORE_BLOCK_PHY 
0674 cd e6 0d				call addatohl 
0677 10 eb				djnz .fb2 
0679			 
0679 eb				ex de, hl 
067a c9				ret 
067b			 
067b			; Get File ID 
067b			; ----------- 
067b			; 
067b			; With current bank 
067b			;  
067b			; Load Block 0 Config 
067b			; Get max file id number 
067b			; For each logical block 
067b			;    Read block file id 
067b			;      If first block of file and dont have file id 
067b			;         if file get id and exit 
067b			 
067b			 
067b			 
067b			 
067b			; Create File 
067b			; ----------- 
067b			; 
067b			; With current bank  
067b			; Load Block 0 Config 
067b			; Get max file id number 
067b			; Increment file id number 
067b			; Save Config 
067b			; Find free block 
067b			; Set buffer with file name and file id 
067b			; Write buffer to free block  
067b			 
067b			 
067b			; hl point to file name 
067b			; hl returns file id 
067b			 
067b			; file format: 
067b			; byte 0 - file id 
067b			; byte 1 - extent number 
067b			; byte 2-> data 
067b			 
067b			; format for extent number 0: 
067b			; 
067b			; byte 0 - file id 
067b			; byte 1 - extent 0 
067b			; byte 2 - extent count 
067b			; byte 3 -> file name and meta data 
067b			 
067b			 
067b			storage_create: 
067b				if DEBUG_STORESE 
067b					DMARK "SCR" 
067b f5				push af  
067c 3a 90 06			ld a, (.dmark)  
067f 32 6b ee			ld (debug_mark),a  
0682 3a 91 06			ld a, (.dmark+1)  
0685 32 6c ee			ld (debug_mark+1),a  
0688 3a 92 06			ld a, (.dmark+2)  
068b 32 6d ee			ld (debug_mark+2),a  
068e 18 03			jr .pastdmark  
0690 ..			.dmark: db "SCR"  
0693 f1			.pastdmark: pop af  
0694			endm  
# End of macro DMARK
0694					CALLMONITOR 
0694 cd 6f ee			call debug_vector  
0697				endm  
# End of macro CALLMONITOR
0697				endif 
0697			 
0697 e5				push hl		; save file name pointer 
0698			 
0698 cd 29 03			call storage_get_block_0 
069b			 
069b 3a 7a ea			ld a,(store_page)	; get current file id 
069e 3c				inc a 
069f 32 7a ea			ld (store_page),a 
06a2				 
06a2 32 6e ea			ld (store_tmpid),a			; save id 
06a5			 
06a5 21 00 00			ld hl, 0 
06a8 11 7a ea			ld de, store_page 
06ab				if DEBUG_STORESE 
06ab					DMARK "SCw" 
06ab f5				push af  
06ac 3a c0 06			ld a, (.dmark)  
06af 32 6b ee			ld (debug_mark),a  
06b2 3a c1 06			ld a, (.dmark+1)  
06b5 32 6c ee			ld (debug_mark+1),a  
06b8 3a c2 06			ld a, (.dmark+2)  
06bb 32 6d ee			ld (debug_mark+2),a  
06be 18 03			jr .pastdmark  
06c0 ..			.dmark: db "SCw"  
06c3 f1			.pastdmark: pop af  
06c4			endm  
# End of macro DMARK
06c4					CALLMONITOR 
06c4 cd 6f ee			call debug_vector  
06c7				endm  
# End of macro CALLMONITOR
06c7				endif 
06c7 cd dd 02			call storage_write_block	 ; save update 
06ca			 
06ca				if DEBUG_STORESE 
06ca 11 7a ea				ld de, store_page 
06cd					DMARK "SCC" 
06cd f5				push af  
06ce 3a e2 06			ld a, (.dmark)  
06d1 32 6b ee			ld (debug_mark),a  
06d4 3a e3 06			ld a, (.dmark+1)  
06d7 32 6c ee			ld (debug_mark+1),a  
06da 3a e4 06			ld a, (.dmark+2)  
06dd 32 6d ee			ld (debug_mark+2),a  
06e0 18 03			jr .pastdmark  
06e2 ..			.dmark: db "SCC"  
06e5 f1			.pastdmark: pop af  
06e6			endm  
# End of macro DMARK
06e6					CALLMONITOR 
06e6 cd 6f ee			call debug_vector  
06e9				endm  
# End of macro CALLMONITOR
06e9				endif 
06e9				;  
06e9				 
06e9 21 40 00			ld hl, STORE_BLOCK_PHY 
06ec 11 00 00			ld de, 0 
06ef cd ab 05			call storage_findnextid 
06f2			 
06f2 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
06f5			 
06f5				; TODO detect 0 = no spare blocks 
06f5			 
06f5				; hl now contains the free page to use for the file header page 
06f5			 
06f5				if DEBUG_STORESE 
06f5				DMARK "SCF" 
06f5 f5				push af  
06f6 3a 0a 07			ld a, (.dmark)  
06f9 32 6b ee			ld (debug_mark),a  
06fc 3a 0b 07			ld a, (.dmark+1)  
06ff 32 6c ee			ld (debug_mark+1),a  
0702 3a 0c 07			ld a, (.dmark+2)  
0705 32 6d ee			ld (debug_mark+2),a  
0708 18 03			jr .pastdmark  
070a ..			.dmark: db "SCF"  
070d f1			.pastdmark: pop af  
070e			endm  
# End of macro DMARK
070e					CALLMONITOR 
070e cd 6f ee			call debug_vector  
0711				endm  
# End of macro CALLMONITOR
0711				endif 
0711			 
0711 22 65 ea			ld (store_tmppageid), hl 
0714				 
0714 3a 6e ea			ld a,(store_tmpid)    ; get file id 
0717			;	ld a, (store_filecache)			; save to cache 
0717			 
0717 32 7a ea			ld (store_page),a    ; set page id 
071a 3e 00			ld a, 0			 ; extent 0 is file header 
071c 32 7b ea			ld (store_page+1), a   ; set file extent 
071f			 
071f 32 7c ea			ld (store_page+2), a   ; extent count for the file 
0722			 
0722			;	inc hl 		; init block 0 of file 
0722			;	inc hl   		; skip file and extent id 
0722			 ;       ld a, 0 
0722			;	ld (hl),a 
0722			;	ld a, (store_filecache+1)  	; save to cache 
0722			 
0722			;	inc hl    ; file name 
0722				 
0722				 
0722 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0725				if DEBUG_STORESE 
0725					DMARK "SCc" 
0725 f5				push af  
0726 3a 3a 07			ld a, (.dmark)  
0729 32 6b ee			ld (debug_mark),a  
072c 3a 3b 07			ld a, (.dmark+1)  
072f 32 6c ee			ld (debug_mark+1),a  
0732 3a 3c 07			ld a, (.dmark+2)  
0735 32 6d ee			ld (debug_mark+2),a  
0738 18 03			jr .pastdmark  
073a ..			.dmark: db "SCc"  
073d f1			.pastdmark: pop af  
073e			endm  
# End of macro DMARK
073e					CALLMONITOR 
073e cd 6f ee			call debug_vector  
0741				endm  
# End of macro CALLMONITOR
0741				endif 
0741 e1				pop hl    ; get zero term string 
0742 e5				push hl 
0743 3e 00			ld a, 0 
0745 cd ae 13			call strlent 
0748 23				inc hl   ; cover zero term 
0749 06 00			ld b,0 
074b 4d				ld c,l 
074c e1				pop hl 
074d				;ex de, hl 
074d				if DEBUG_STORESE 
074d					DMARK "SCa" 
074d f5				push af  
074e 3a 62 07			ld a, (.dmark)  
0751 32 6b ee			ld (debug_mark),a  
0754 3a 63 07			ld a, (.dmark+1)  
0757 32 6c ee			ld (debug_mark+1),a  
075a 3a 64 07			ld a, (.dmark+2)  
075d 32 6d ee			ld (debug_mark+2),a  
0760 18 03			jr .pastdmark  
0762 ..			.dmark: db "SCa"  
0765 f1			.pastdmark: pop af  
0766			endm  
# End of macro DMARK
0766					;push af 
0766					;ld a, 'a' 
0766					;ld (debug_mark),a 
0766					;pop af 
0766					CALLMONITOR 
0766 cd 6f ee			call debug_vector  
0769				endm  
# End of macro CALLMONITOR
0769				endif 
0769 ed b0			ldir    ; copy zero term string 
076b				if DEBUG_STORESE 
076b					DMARK "SCA" 
076b f5				push af  
076c 3a 80 07			ld a, (.dmark)  
076f 32 6b ee			ld (debug_mark),a  
0772 3a 81 07			ld a, (.dmark+1)  
0775 32 6c ee			ld (debug_mark+1),a  
0778 3a 82 07			ld a, (.dmark+2)  
077b 32 6d ee			ld (debug_mark+2),a  
077e 18 03			jr .pastdmark  
0780 ..			.dmark: db "SCA"  
0783 f1			.pastdmark: pop af  
0784			endm  
# End of macro DMARK
0784					CALLMONITOR 
0784 cd 6f ee			call debug_vector  
0787				endm  
# End of macro CALLMONITOR
0787				endif 
0787			 
0787				; write file header page 
0787			 
0787 2a 65 ea			ld hl,(store_tmppageid) 
078a 11 7a ea			ld de, store_page 
078d				if DEBUG_STORESE 
078d					DMARK "SCb" 
078d f5				push af  
078e 3a a2 07			ld a, (.dmark)  
0791 32 6b ee			ld (debug_mark),a  
0794 3a a3 07			ld a, (.dmark+1)  
0797 32 6c ee			ld (debug_mark+1),a  
079a 3a a4 07			ld a, (.dmark+2)  
079d 32 6d ee			ld (debug_mark+2),a  
07a0 18 03			jr .pastdmark  
07a2 ..			.dmark: db "SCb"  
07a5 f1			.pastdmark: pop af  
07a6			endm  
# End of macro DMARK
07a6					;push af 
07a6					;ld a, 'b' 
07a6					;ld (debug_mark),a 
07a6					;pop af 
07a6					CALLMONITOR 
07a6 cd 6f ee			call debug_vector  
07a9				endm  
# End of macro CALLMONITOR
07a9				endif 
07a9 cd dd 02			call storage_write_block 
07ac			 
07ac 3a 6e ea			ld a, (store_tmpid) 
07af 6f				ld l, a 
07b0 26 00			ld h,0 
07b2				if DEBUG_STORESE 
07b2					DMARK "SCz" 
07b2 f5				push af  
07b3 3a c7 07			ld a, (.dmark)  
07b6 32 6b ee			ld (debug_mark),a  
07b9 3a c8 07			ld a, (.dmark+1)  
07bc 32 6c ee			ld (debug_mark+1),a  
07bf 3a c9 07			ld a, (.dmark+2)  
07c2 32 6d ee			ld (debug_mark+2),a  
07c5 18 03			jr .pastdmark  
07c7 ..			.dmark: db "SCz"  
07ca f1			.pastdmark: pop af  
07cb			endm  
# End of macro DMARK
07cb					CALLMONITOR 
07cb cd 6f ee			call debug_vector  
07ce				endm  
# End of macro CALLMONITOR
07ce				endif 
07ce c9				ret 
07cf				 
07cf			 
07cf			 
07cf			; 
07cf			; Read File 
07cf			; 
07cf			; h - file id to locate 
07cf			; l - extent to locate 
07cf			; de - pointer to string to read into 
07cf			; 
07cf			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07cf			 
07cf			.sr_fail: 
07cf d1				pop de 
07d0 c9				ret 
07d1			 
07d1			storage_read: 
07d1			 
07d1			 
07d1 d5				push de 
07d2			 
07d2			; TODO BUG the above push is it popped before the RET Z? 
07d2			 
07d2			; TODO how to handle multiple part blocks 
07d2			 
07d2				; locate file extent to read 
07d2			 
07d2 5c				ld e, h 
07d3 55				ld d, l 
07d4			 
07d4			.srext: 
07d4 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
07d7 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07db			 
07db 21 40 00			ld hl, STORE_BLOCK_PHY 
07de				if DEBUG_STORESE 
07de					DMARK "sre" 
07de f5				push af  
07df 3a f3 07			ld a, (.dmark)  
07e2 32 6b ee			ld (debug_mark),a  
07e5 3a f4 07			ld a, (.dmark+1)  
07e8 32 6c ee			ld (debug_mark+1),a  
07eb 3a f5 07			ld a, (.dmark+2)  
07ee 32 6d ee			ld (debug_mark+2),a  
07f1 18 03			jr .pastdmark  
07f3 ..			.dmark: db "sre"  
07f6 f1			.pastdmark: pop af  
07f7			endm  
# End of macro DMARK
07f7					CALLMONITOR 
07f7 cd 6f ee			call debug_vector  
07fa				endm  
# End of macro CALLMONITOR
07fa				endif 
07fa cd ab 05			call storage_findnextid 
07fd			 
07fd				if DEBUG_STORESE 
07fd					DMARK "srf" 
07fd f5				push af  
07fe 3a 12 08			ld a, (.dmark)  
0801 32 6b ee			ld (debug_mark),a  
0804 3a 13 08			ld a, (.dmark+1)  
0807 32 6c ee			ld (debug_mark+1),a  
080a 3a 14 08			ld a, (.dmark+2)  
080d 32 6d ee			ld (debug_mark+2),a  
0810 18 03			jr .pastdmark  
0812 ..			.dmark: db "srf"  
0815 f1			.pastdmark: pop af  
0816			endm  
# End of macro DMARK
0816					CALLMONITOR 
0816 cd 6f ee			call debug_vector  
0819				endm  
# End of macro CALLMONITOR
0819				endif 
0819 cd 0f 0e			call ishlzero 
081c			;	ld a, l 
081c			;	add h 
081c			;	cp 0 
081c 28 b1			jr z,.sr_fail			; block not found so EOF 
081e			 
081e				; save current address for use by higher level words etc 
081e			 
081e 22 6b ea			ld (store_openaddr),hl 
0821			 
0821			 
0821				; hl contains page number to load 
0821 d1				pop de   ; get storage 
0822 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
0826 d5				push de 
0827				if DEBUG_STORESE 
0827					DMARK "srg" 
0827 f5				push af  
0828 3a 3c 08			ld a, (.dmark)  
082b 32 6b ee			ld (debug_mark),a  
082e 3a 3d 08			ld a, (.dmark+1)  
0831 32 6c ee			ld (debug_mark+1),a  
0834 3a 3e 08			ld a, (.dmark+2)  
0837 32 6d ee			ld (debug_mark+2),a  
083a 18 03			jr .pastdmark  
083c ..			.dmark: db "srg"  
083f f1			.pastdmark: pop af  
0840			endm  
# End of macro DMARK
0840					CALLMONITOR 
0840 cd 6f ee			call debug_vector  
0843				endm  
# End of macro CALLMONITOR
0843				endif 
0843 cd 78 02			call storage_read_block 
0846			 
0846				; if this a continuation read??? 
0846			 
0846 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0849			 
0849 3e 3f			ld a, STORE_BLOCK_PHY-1 
084b cd e6 0d			call addatohl 
084e 7e				ld a,(hl) 
084f fe 00			cp 0 
0851 28 02			jr z, .markiscont 
0853 3e ff			ld a, 255 
0855			 
0855			.markiscont: 
0855 32 6d ea			ld (store_readcont), a 
0858			 
0858				if DEBUG_STORESE 
0858					DMARK "srC" 
0858 f5				push af  
0859 3a 6d 08			ld a, (.dmark)  
085c 32 6b ee			ld (debug_mark),a  
085f 3a 6e 08			ld a, (.dmark+1)  
0862 32 6c ee			ld (debug_mark+1),a  
0865 3a 6f 08			ld a, (.dmark+2)  
0868 32 6d ee			ld (debug_mark+2),a  
086b 18 03			jr .pastdmark  
086d ..			.dmark: db "srC"  
0870 f1			.pastdmark: pop af  
0871			endm  
# End of macro DMARK
0871					CALLMONITOR 
0871 cd 6f ee			call debug_vector  
0874				endm  
# End of macro CALLMONITOR
0874				endif 
0874				; only short reads enabled 
0874			 
0874 3a 75 ea			ld a, (store_longread) 
0877 fe 00			cp 0 
0879 ca 46 09			jp z, .readdone 
087c			 
087c			; TODO if block has no zeros then need to read next block  
087c			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
087c			; check last byte of physical block. 
087c			; if not zero then the next block needs to be loaded 
087c			 
087c			 
087c 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
087f			 
087f 3e 3f			ld a, STORE_BLOCK_PHY-1 
0881 cd e6 0d			call addatohl 
0884				;dec hl 
0884 7e				ld a,(hl) 
0885				if DEBUG_STORESE 
0885					DMARK "sr?" 
0885 f5				push af  
0886 3a 9a 08			ld a, (.dmark)  
0889 32 6b ee			ld (debug_mark),a  
088c 3a 9b 08			ld a, (.dmark+1)  
088f 32 6c ee			ld (debug_mark+1),a  
0892 3a 9c 08			ld a, (.dmark+2)  
0895 32 6d ee			ld (debug_mark+2),a  
0898 18 03			jr .pastdmark  
089a ..			.dmark: db "sr?"  
089d f1			.pastdmark: pop af  
089e			endm  
# End of macro DMARK
089e					CALLMONITOR 
089e cd 6f ee			call debug_vector  
08a1				endm  
# End of macro CALLMONITOR
08a1				endif 
08a1 fe 00			cp 0 
08a3 ca 46 09			jp z, .readdone 
08a6			 
08a6				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a6			 
08a6 23				inc hl 
08a7			 
08a7 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08aa			 
08aa ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
08ae			 
08ae eb				ex de, hl 
08af			 
08af				; next ext 
08af			 
08af 23				inc hl 
08b0 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
08b3			 
08b3				if DEBUG_STORESE 
08b3					DMARK "sF2" 
08b3 f5				push af  
08b4 3a c8 08			ld a, (.dmark)  
08b7 32 6b ee			ld (debug_mark),a  
08ba 3a c9 08			ld a, (.dmark+1)  
08bd 32 6c ee			ld (debug_mark+1),a  
08c0 3a ca 08			ld a, (.dmark+2)  
08c3 32 6d ee			ld (debug_mark+2),a  
08c6 18 03			jr .pastdmark  
08c8 ..			.dmark: db "sF2"  
08cb f1			.pastdmark: pop af  
08cc			endm  
# End of macro DMARK
08cc					CALLMONITOR 
08cc cd 6f ee			call debug_vector  
08cf				endm  
# End of macro CALLMONITOR
08cf				endif 
08cf			 
08cf				; get and load block 
08cf			 
08cf cd ab 05			call storage_findnextid 
08d2			 
08d2				if DEBUG_STORESE 
08d2					DMARK "sf2" 
08d2 f5				push af  
08d3 3a e7 08			ld a, (.dmark)  
08d6 32 6b ee			ld (debug_mark),a  
08d9 3a e8 08			ld a, (.dmark+1)  
08dc 32 6c ee			ld (debug_mark+1),a  
08df 3a e9 08			ld a, (.dmark+2)  
08e2 32 6d ee			ld (debug_mark+2),a  
08e5 18 03			jr .pastdmark  
08e7 ..			.dmark: db "sf2"  
08ea f1			.pastdmark: pop af  
08eb			endm  
# End of macro DMARK
08eb					CALLMONITOR 
08eb cd 6f ee			call debug_vector  
08ee				endm  
# End of macro CALLMONITOR
08ee				endif 
08ee cd 0f 0e			call ishlzero 
08f1			;	ld a, l 
08f1			;	add h 
08f1			;	cp 0 
08f1 ca cf 07			jp z,.sr_fail			; block not found so EOF 
08f4				 
08f4				; save current address for use by higher level words etc 
08f4			 
08f4 22 6b ea			ld (store_openaddr),hl 
08f7			 
08f7 cd 78 02			call storage_read_block 
08fa			 
08fa				; on a continuation block, we now have the file id and ext in the middle of the block 
08fa				; we need to pull everything back  
08fa			 
08fa ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08fe 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0901 23				inc hl 
0902 23				inc hl     ; skip id and ext 
0903 01 40 00			ld bc, STORE_BLOCK_PHY 
0906				if DEBUG_STORESE 
0906					DMARK "SR<" 
0906 f5				push af  
0907 3a 1b 09			ld a, (.dmark)  
090a 32 6b ee			ld (debug_mark),a  
090d 3a 1c 09			ld a, (.dmark+1)  
0910 32 6c ee			ld (debug_mark+1),a  
0913 3a 1d 09			ld a, (.dmark+2)  
0916 32 6d ee			ld (debug_mark+2),a  
0919 18 03			jr .pastdmark  
091b ..			.dmark: db "SR<"  
091e f1			.pastdmark: pop af  
091f			endm  
# End of macro DMARK
091f					CALLMONITOR 
091f cd 6f ee			call debug_vector  
0922				endm  
# End of macro CALLMONITOR
0922				endif 
0922 ed b0			ldir     ; copy data 
0924			 
0924				; move the pointer back and pretend we have a full buffer for next recheck 
0924			 
0924 1b				dec de 
0925 1b				dec de 
0926			 
0926			; TODO do pop below now short circuit loop????? 
0926 c1				pop bc     ; get rid of spare de on stack 
0927				if DEBUG_STORESE 
0927					DMARK "SR>" 
0927 f5				push af  
0928 3a 3c 09			ld a, (.dmark)  
092b 32 6b ee			ld (debug_mark),a  
092e 3a 3d 09			ld a, (.dmark+1)  
0931 32 6c ee			ld (debug_mark+1),a  
0934 3a 3e 09			ld a, (.dmark+2)  
0937 32 6d ee			ld (debug_mark+2),a  
093a 18 03			jr .pastdmark  
093c ..			.dmark: db "SR>"  
093f f1			.pastdmark: pop af  
0940			endm  
# End of macro DMARK
0940					CALLMONITOR 
0940 cd 6f ee			call debug_vector  
0943				endm  
# End of macro CALLMONITOR
0943				endif 
0943 c3 d4 07			jp .srext 
0946			 
0946			 
0946			 
0946			 
0946			 
0946			.readdone:		 
0946 e1				pop hl 		 ; return start of data to show as not EOF 
0947 23				inc hl   ; past file id 
0948 23				inc hl   ; past ext 
0949				if DEBUG_STORESE 
0949					DMARK "SRe" 
0949 f5				push af  
094a 3a 5e 09			ld a, (.dmark)  
094d 32 6b ee			ld (debug_mark),a  
0950 3a 5f 09			ld a, (.dmark+1)  
0953 32 6c ee			ld (debug_mark+1),a  
0956 3a 60 09			ld a, (.dmark+2)  
0959 32 6d ee			ld (debug_mark+2),a  
095c 18 03			jr .pastdmark  
095e ..			.dmark: db "SRe"  
0961 f1			.pastdmark: pop af  
0962			endm  
# End of macro DMARK
0962					CALLMONITOR 
0962 cd 6f ee			call debug_vector  
0965				endm  
# End of macro CALLMONITOR
0965				endif 
0965 c9					ret 
0966			 
0966			 
0966			 
0966			; 
0966			; Append File 
0966			; 
0966			; hl - file id to locate 
0966			; de - pointer to (multi block) string to write 
0966			 
0966			.sa_notfound: 
0966 d1				pop de 
0967 c9				ret 
0968			 
0968			 
0968			storage_append: 
0968				; hl -  file id to append to 
0968				; de - string to append 
0968			 
0968 d5				push de 
0969				 
0969				if DEBUG_STORESE 
0969					DMARK "AP1" 
0969 f5				push af  
096a 3a 7e 09			ld a, (.dmark)  
096d 32 6b ee			ld (debug_mark),a  
0970 3a 7f 09			ld a, (.dmark+1)  
0973 32 6c ee			ld (debug_mark+1),a  
0976 3a 80 09			ld a, (.dmark+2)  
0979 32 6d ee			ld (debug_mark+2),a  
097c 18 03			jr .pastdmark  
097e ..			.dmark: db "AP1"  
0981 f1			.pastdmark: pop af  
0982			endm  
# End of macro DMARK
0982					CALLMONITOR 
0982 cd 6f ee			call debug_vector  
0985				endm  
# End of macro CALLMONITOR
0985				endif 
0985			 
0985 7d				ld a, l 
0986 32 6e ea			ld (store_tmpid), a 
0989			 
0989				; get file header  
0989			 
0989 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098b 3a 6e ea			ld a, (store_tmpid) 
098e 5f				ld e, a 
098f			 
098f 21 40 00				ld hl, STORE_BLOCK_PHY 
0992 cd ab 05				call storage_findnextid 
0995			 
0995 cd 0f 0e			call ishlzero 
0998 28 cc			jr z, .sa_notfound 
099a			 
099a 22 65 ea			ld (store_tmppageid), hl 
099d			 
099d				; TODO handle file id not found 
099d			 
099d				if DEBUG_STORESE 
099d					DMARK "AP2" 
099d f5				push af  
099e 3a b2 09			ld a, (.dmark)  
09a1 32 6b ee			ld (debug_mark),a  
09a4 3a b3 09			ld a, (.dmark+1)  
09a7 32 6c ee			ld (debug_mark+1),a  
09aa 3a b4 09			ld a, (.dmark+2)  
09ad 32 6d ee			ld (debug_mark+2),a  
09b0 18 03			jr .pastdmark  
09b2 ..			.dmark: db "AP2"  
09b5 f1			.pastdmark: pop af  
09b6			endm  
# End of macro DMARK
09b6					CALLMONITOR 
09b6 cd 6f ee			call debug_vector  
09b9				endm  
# End of macro CALLMONITOR
09b9				endif 
09b9			 
09b9				; update file extent count 
09b9			 
09b9 11 7a ea			ld de, store_page 
09bc			 
09bc cd 78 02			call storage_read_block 
09bf			 
09bf				if DEBUG_STORESE 
09bf					DMARK "AP3" 
09bf f5				push af  
09c0 3a d4 09			ld a, (.dmark)  
09c3 32 6b ee			ld (debug_mark),a  
09c6 3a d5 09			ld a, (.dmark+1)  
09c9 32 6c ee			ld (debug_mark+1),a  
09cc 3a d6 09			ld a, (.dmark+2)  
09cf 32 6d ee			ld (debug_mark+2),a  
09d2 18 03			jr .pastdmark  
09d4 ..			.dmark: db "AP3"  
09d7 f1			.pastdmark: pop af  
09d8			endm  
# End of macro DMARK
09d8					CALLMONITOR 
09d8 cd 6f ee			call debug_vector  
09db				endm  
# End of macro CALLMONITOR
09db				endif 
09db			;	ld (store_tmppageid), hl 
09db			 
09db 3a 7c ea			ld a, (store_page+2) 
09de 3c				inc a 
09df 32 7c ea			ld (store_page+2), a 
09e2 32 6d ea			ld (store_tmpext), a 
09e5				 
09e5				if DEBUG_STORESE 
09e5					DMARK "AP3" 
09e5 f5				push af  
09e6 3a fa 09			ld a, (.dmark)  
09e9 32 6b ee			ld (debug_mark),a  
09ec 3a fb 09			ld a, (.dmark+1)  
09ef 32 6c ee			ld (debug_mark+1),a  
09f2 3a fc 09			ld a, (.dmark+2)  
09f5 32 6d ee			ld (debug_mark+2),a  
09f8 18 03			jr .pastdmark  
09fa ..			.dmark: db "AP3"  
09fd f1			.pastdmark: pop af  
09fe			endm  
# End of macro DMARK
09fe					CALLMONITOR 
09fe cd 6f ee			call debug_vector  
0a01				endm  
# End of macro CALLMONITOR
0a01				endif 
0a01 2a 65 ea			ld hl, (store_tmppageid) 
0a04 11 7a ea			ld de, store_page 
0a07 cd dd 02			call storage_write_block 
0a0a			 
0a0a				; find free block 
0a0a			 
0a0a 11 00 00			ld de, 0			 ; file extent to locate 
0a0d			 
0a0d 21 40 00				ld hl, STORE_BLOCK_PHY 
0a10 cd ab 05				call storage_findnextid 
0a13 cd 0f 0e			call ishlzero 
0a16 ca 66 09			jp z, .sa_notfound 
0a19			 
0a19					; TODO handle no space left 
0a19					 
0a19 22 65 ea				ld (store_tmppageid), hl 
0a1c			 
0a1c				if DEBUG_STORESE 
0a1c					DMARK "AP4" 
0a1c f5				push af  
0a1d 3a 31 0a			ld a, (.dmark)  
0a20 32 6b ee			ld (debug_mark),a  
0a23 3a 32 0a			ld a, (.dmark+1)  
0a26 32 6c ee			ld (debug_mark+1),a  
0a29 3a 33 0a			ld a, (.dmark+2)  
0a2c 32 6d ee			ld (debug_mark+2),a  
0a2f 18 03			jr .pastdmark  
0a31 ..			.dmark: db "AP4"  
0a34 f1			.pastdmark: pop af  
0a35			endm  
# End of macro DMARK
0a35					CALLMONITOR 
0a35 cd 6f ee			call debug_vector  
0a38				endm  
# End of macro CALLMONITOR
0a38				endif 
0a38					; init the buffer with zeros so we can id if the buffer is full or not 
0a38			 
0a38 e5					push hl 
0a39 c5					push bc 
0a3a			 
0a3a 21 7a ea				ld hl, store_page 
0a3d 06 40				ld b, STORE_BLOCK_PHY 
0a3f 3e 00				ld a, 0 
0a41 77			.zeroblock:	ld (hl), a 
0a42 23					inc hl 
0a43 10 fc				djnz .zeroblock 
0a45			 
0a45 c1					pop bc 
0a46 e1					pop hl 
0a47			 
0a47					; construct block 
0a47			 
0a47 3a 6e ea				ld a, (store_tmpid) 
0a4a 32 7a ea				ld (store_page), a   ; file id 
0a4d 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
0a50 32 7b ea				ld (store_page+1), a 
0a53			 
0a53 e1					pop hl    ; get string to write 
0a54 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a56 11 7c ea				ld de, store_page+2 
0a59			 
0a59				if DEBUG_STORESE 
0a59					DMARK "AP5" 
0a59 f5				push af  
0a5a 3a 6e 0a			ld a, (.dmark)  
0a5d 32 6b ee			ld (debug_mark),a  
0a60 3a 6f 0a			ld a, (.dmark+1)  
0a63 32 6c ee			ld (debug_mark+1),a  
0a66 3a 70 0a			ld a, (.dmark+2)  
0a69 32 6d ee			ld (debug_mark+2),a  
0a6c 18 03			jr .pastdmark  
0a6e ..			.dmark: db "AP5"  
0a71 f1			.pastdmark: pop af  
0a72			endm  
# End of macro DMARK
0a72					CALLMONITOR 
0a72 cd 6f ee			call debug_vector  
0a75				endm  
# End of macro CALLMONITOR
0a75				endif 
0a75			 
0a75			 
0a75			 
0a75					; fill buffer with data until end of string or full block 
0a75			 
0a75 7e			.appd:		ld a, (hl) 
0a76 12					ld (de), a 
0a77 fe 00				cp 0 
0a79 28 04				jr z, .appdone 
0a7b 23					inc hl 
0a7c 13					inc de 
0a7d 10 f6				djnz .appd 
0a7f			 
0a7f e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a80 f5					push af   		; save last byte dumped 
0a81			 
0a81			 
0a81 2a 65 ea			ld hl, (store_tmppageid) 
0a84 11 7a ea			ld de, store_page 
0a87				if DEBUG_STORESE 
0a87					DMARK "AP6" 
0a87 f5				push af  
0a88 3a 9c 0a			ld a, (.dmark)  
0a8b 32 6b ee			ld (debug_mark),a  
0a8e 3a 9d 0a			ld a, (.dmark+1)  
0a91 32 6c ee			ld (debug_mark+1),a  
0a94 3a 9e 0a			ld a, (.dmark+2)  
0a97 32 6d ee			ld (debug_mark+2),a  
0a9a 18 03			jr .pastdmark  
0a9c ..			.dmark: db "AP6"  
0a9f f1			.pastdmark: pop af  
0aa0			endm  
# End of macro DMARK
0aa0					CALLMONITOR 
0aa0 cd 6f ee			call debug_vector  
0aa3				endm  
# End of macro CALLMONITOR
0aa3				endif 
0aa3 cd dd 02				call storage_write_block 
0aa6			 
0aa6			 
0aa6				; was that a full block of data written? 
0aa6				; any more to write out? 
0aa6			 
0aa6				; if yes then set vars and jump to start of function again 
0aa6			 
0aa6 f1					pop af 
0aa7 d1					pop de 
0aa8			 
0aa8 fe 00				cp 0		 ; no, string was fully written 
0aaa c8					ret z 
0aab			 
0aab					; setup vars for next cycle 
0aab			 
0aab 3a 6e ea				ld a, (store_tmpid) 
0aae 6f					ld l, a 
0aaf 26 00				ld h, 0 
0ab1			 
0ab1 c3 68 09			 	jp storage_append	 ; yes, need to write out some more 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			if DEBUG_STORECF 
0ab4			storageput:	 
0ab4					ret 
0ab4			storageread: 
0ab4					ld hl, store_page 
0ab4					ld b, 200 
0ab4					ld a,0 
0ab4			.src:		ld (hl),a 
0ab4					inc hl 
0ab4					djnz .src 
0ab4					 
0ab4			 
0ab4					ld de, 0 
0ab4					ld bc, 1 
0ab4					ld hl, store_page 
0ab4					call cfRead 
0ab4			 
0ab4				call cfGetError 
0ab4				ld hl,scratch 
0ab4				call hexout 
0ab4				ld hl, scratch+2 
0ab4				ld a, 0 
0ab4				ld (hl),a 
0ab4				ld de, scratch 
0ab4				ld a,display_row_1 
0ab4				call str_at_display 
0ab4				call update_display 
0ab4			 
0ab4					ld hl, store_page 
0ab4					ld (os_cur_ptr),hl 
0ab4			 
0ab4					ret 
0ab4			endif 
0ab4			 
0ab4			 
0ab4			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab4			 
0ab4			storage_clear_page: 
0ab4 e5				push hl 
0ab5 d5				push de 
0ab6 c5				push bc 
0ab7 21 7a ea			ld hl, store_page 
0aba 3e 00			ld a, 0 
0abc 77				ld (hl), a 
0abd			 
0abd 11 7b ea			ld de, store_page+1 
0ac0 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ac3			 
0ac3 ed b0			ldir 
0ac5				 
0ac5 c1				pop bc 
0ac6 d1				pop de 
0ac7 e1				pop hl 
0ac8 c9				ret 
0ac9			 
0ac9			; eof 
# End of file firmware_storage.asm
0ac9			  
0ac9			; support routines for above hardware abstraction layer  
0ac9			  
0ac9			include "firmware_general.asm"        ; general support functions  
0ac9			 
0ac9			; word look up 
0ac9			 
0ac9			; in 
0ac9			; a is the index 
0ac9			; hl is pointer start of array 
0ac9			; 
0ac9			; returns 
0ac9			; hl to the word 
0ac9			; 
0ac9			 
0ac9			table_lookup:  
0ac9 d5					push de 
0aca eb					ex de, hl 
0acb			 
0acb 6f					ld l, a 
0acc 26 00				ld h, 0 
0ace 29					add hl, hl 
0acf 19					add hl, de 
0ad0 7e					ld a, (hl) 
0ad1 23					inc hl 
0ad2 66					ld h,(hl) 
0ad3 6f					ld l, a 
0ad4			 
0ad4 d1					pop de 
0ad5 c9					ret 
0ad6			 
0ad6			; Delay loops 
0ad6			 
0ad6			 
0ad6			 
0ad6			aDelayInMS: 
0ad6 c5				push bc 
0ad7 47				ld b,a 
0ad8			msdelay: 
0ad8 c5				push bc 
0ad9				 
0ad9			 
0ad9 01 41 00			ld bc,041h 
0adc cd f4 0a			call delayloop 
0adf c1				pop bc 
0ae0 05				dec b 
0ae1 20 f5			jr nz,msdelay 
0ae3			 
0ae3			;if CPU_CLOCK_8MHZ 
0ae3			;msdelay8: 
0ae3			;	push bc 
0ae3			;	 
0ae3			; 
0ae3			;	ld bc,041h 
0ae3			;	call delayloop 
0ae3			;	pop bc 
0ae3			;	dec b 
0ae3			;	jr nz,msdelay8 
0ae3			;endif 
0ae3			 
0ae3			 
0ae3 c1				pop bc 
0ae4 c9				ret 
0ae5			 
0ae5			 
0ae5			delay250ms: 
0ae5				;push de 
0ae5 01 00 40			ld bc, 04000h 
0ae8 c3 f4 0a			jp delayloop 
0aeb			delay500ms: 
0aeb				;push de 
0aeb 01 00 80			ld bc, 08000h 
0aee c3 f4 0a			jp delayloop 
0af1			delay1s: 
0af1				;push bc 
0af1			   ; Clobbers A, d and e 
0af1 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af4			delayloop: 
0af4 c5			    push bc 
0af5			 
0af5			if BASE_CPM 
0af5 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af8			.cpmloop: 
0af8 c5				push bc 
0af9			 
0af9			endif 
0af9			 
0af9			 
0af9			 
0af9			delayloopi: 
0af9			;	push bc 
0af9			;.dl: 
0af9 cb 47		    bit     0,a    	; 8 
0afb cb 47		    bit     0,a    	; 8 
0afd cb 47		    bit     0,a    	; 8 
0aff e6 ff		    and     255  	; 7 
0b01 0b			    dec     bc      	; 6 
0b02 79			    ld      a,c     	; 4 
0b03 b0			    or      b     	; 4 
0b04 c2 f9 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b07			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b07				;pop de 
0b07			;pop bc 
0b07			 
0b07			if BASE_CPM 
0b07 c1				pop bc 
0b08				 
0b08 0b			    dec     bc      	; 6 
0b09 79			    ld      a,c     	; 4 
0b0a b0			    or      b     	; 4 
0b0b c2 f8 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0e				 
0b0e			 
0b0e			endif 
0b0e			;if CPU_CLOCK_8MHZ 
0b0e			;    pop bc 
0b0e			;    push bc 
0b0e			;.dl8: 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    and     255  	; 7 
0b0e			;    dec     bc      	; 6 
0b0e			;    ld      a,c     	; 4 
0b0e			;    or      b     	; 4 
0b0e			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0e			;endif 
0b0e			 
0b0e			;if CPU_CLOCK_10MHZ 
0b0e			;    pop bc 
0b0e			;    push bc 
0b0e			;.dl8: 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    and     255  	; 7 
0b0e			;    dec     bc      	; 6 
0b0e			;    ld      a,c     	; 4 
0b0e			;    or      b     	; 4 
0b0e			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0e			;endif 
0b0e c1			    pop bc 
0b0f			 
0b0f c9				ret 
0b10			 
0b10			 
0b10			 
0b10			; eof 
# End of file firmware_general.asm
0b10			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b10			; display routines that use the physical hardware abstraction layer 
0b10			 
0b10			 
0b10			; Display an activity indicator 
0b10			; Each call returns the new char pointed to in hl 
0b10			 
0b10			active: 
0b10 3a c6 eb			ld a, (display_active) 
0b13 fe 06			cp 6 
0b15			 
0b15 20 02			jr nz, .sne 
0b17				; gone past the last one reset sequence 
0b17 3e ff			ld a, 255 
0b19			 
0b19			.sne:   
0b19				; get the next char in seq 
0b19 3c				inc a 
0b1a 32 c6 eb			ld (display_active), a 
0b1d			 
0b1d				; look up the string in the table 
0b1d 21 34 0b			ld hl, actseq 
0b20 cb 27			sla a 
0b22 cd e6 0d			call addatohl 
0b25 cd e0 20			call loadwordinhl 
0b28			 
0b28				; forth will write the to string when pushing so move from rom to ram 
0b28			 
0b28 11 c7 eb			ld de, display_active+1 
0b2b 01 02 00			ld bc, 2 
0b2e ed b0			ldir 
0b30			 
0b30 21 c7 eb			ld hl, display_active+1 
0b33 c9				ret 
0b34				 
0b34				 
0b34			 
0b34			 
0b34			;db "|/-\|-\" 
0b34			 
0b34			actseq: 
0b34			 
0b34 42 0b		dw spin0 
0b36 44 0b		dw spin1 
0b38 46 0b		dw spin2 
0b3a 48 0b		dw spin3 
0b3c 46 0b		dw spin2 
0b3e 44 0b		dw spin1 
0b40 42 0b		dw spin0 
0b42			 
0b42 .. 00		spin0: db " ", 0 
0b44 .. 00		spin1: db "-", 0 
0b46 .. 00		spin2: db "+", 0 
0b48 .. 00		spin3: db "#", 0 
0b4a			 
0b4a			 
0b4a			; information window 
0b4a			 
0b4a			; pass hl with 1st string to display 
0b4a			; pass de with 2nd string to display 
0b4a			 
0b4a			info_panel: 
0b4a e5				push hl 
0b4b			 
0b4b 2a cc eb			ld hl, (display_fb_active) 
0b4e e5				push hl    ; future de destination 
0b4f 21 b1 ed				ld hl, display_fb0 
0b52 22 cc eb				ld (display_fb_active), hl 
0b55			 
0b55			;	call clear_display 
0b55			 
0b55				if BASE_CPM 
0b55 3e 2e			ld a, '.' 
0b57				else 
0b57				ld a, 165 
0b57				endif 
0b57 cd be 0b			call fill_display 
0b5a			 
0b5a			 
0b5a 3e 55			ld a, display_row_3 + 5 
0b5c cd cc 0b			call str_at_display 
0b5f			 
0b5f e1				pop hl 
0b60 d1				pop de 
0b61			 
0b61 e5				push hl 
0b62			 
0b62			 
0b62 3e 2d			ld a, display_row_2 + 5 
0b64 cd cc 0b			call str_at_display 
0b67			 
0b67			 
0b67 cd dc 0b			call update_display 
0b6a cd 29 1d			call next_page_prompt 
0b6d cd b9 0b			call clear_display 
0b70			 
0b70				 
0b70 21 10 ed				ld hl, display_fb1 
0b73 22 cc eb				ld (display_fb_active), hl 
0b76 cd dc 0b			call update_display 
0b79			 
0b79 e1				pop hl 
0b7a			 
0b7a c9				ret 
0b7b			 
0b7b			 
0b7b			 
0b7b			 
0b7b			; TODO windowing? 
0b7b			 
0b7b			; TODO scroll line up 
0b7b			 
0b7b			scroll_up: 
0b7b			 
0b7b e5				push hl 
0b7c d5				push de 
0b7d c5				push bc 
0b7e			 
0b7e				; get frame buffer  
0b7e			 
0b7e 2a cc eb			ld hl, (display_fb_active) 
0b81 e5				push hl    ; future de destination 
0b82			 
0b82 11 28 00			ld  de, display_cols 
0b85 19				add hl, de 
0b86			 
0b86 d1				pop de 
0b87			 
0b87				;ex de, hl 
0b87 01 9f 00			ld bc, display_fb_len -1  
0b8a			;if DEBUG_FORTH_WORDS 
0b8a			;	DMARK "SCL" 
0b8a			;	CALLMONITOR 
0b8a			;endif	 
0b8a ed b0			ldir 
0b8c			 
0b8c				; wipe bottom row 
0b8c			 
0b8c			 
0b8c 2a cc eb			ld hl, (display_fb_active) 
0b8f 11 a0 00			ld de, display_cols*display_rows 
0b92 19				add hl, de 
0b93 06 28			ld b, display_cols 
0b95 3e 20			ld a, ' ' 
0b97			.scwipe: 
0b97 77				ld (hl), a 
0b98 2b				dec hl 
0b99 10 fc			djnz .scwipe 
0b9b			 
0b9b				;pop hl 
0b9b			 
0b9b c1				pop bc 
0b9c d1				pop de 
0b9d e1				pop hl 
0b9e			 
0b9e c9				ret 
0b9f			 
0b9f			 
0b9f			;scroll_upo: 
0b9f			;	ld de, display_row_1 
0b9f			 ;	ld hl, display_row_2 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			;	ld de, display_row_2 
0b9f			 ;	ld hl, display_row_3 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			;	ld de, display_row_3 
0b9f			 ;	ld hl, display_row_4 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			 
0b9f			; TODO clear row 4 
0b9f			 
0b9f			;	ret 
0b9f			 
0b9f				 
0b9f			scroll_down: 
0b9f			 
0b9f e5				push hl 
0ba0 d5				push de 
0ba1 c5				push bc 
0ba2			 
0ba2				; get frame buffer  
0ba2			 
0ba2 2a cc eb			ld hl, (display_fb_active) 
0ba5			 
0ba5 11 9f 00			ld de, display_fb_len - 1 
0ba8 19				add hl, de 
0ba9			 
0ba9 e5			push hl    ; future de destination 
0baa			 
0baa 11 28 00			ld  de, display_cols 
0bad ed 52			sbc hl, de 
0baf			 
0baf			 
0baf d1				pop de 
0bb0			 
0bb0			;	ex de, hl 
0bb0 01 9f 00			ld bc, display_fb_len -1  
0bb3			 
0bb3			 
0bb3				 
0bb3			 
0bb3 ed b0			ldir 
0bb5			 
0bb5				; wipe bottom row 
0bb5			 
0bb5			 
0bb5			;	ld hl, (display_fb_active) 
0bb5			;;	ld de, display_cols*display_rows 
0bb5			;;	add hl, de 
0bb5			;	ld b, display_cols 
0bb5			;	ld a, ' ' 
0bb5			;.scwiped: 
0bb5			;	ld (hl), a 
0bb5			;	dec hl 
0bb5			;	djnz .scwiped 
0bb5			 
0bb5				;pop hl 
0bb5			 
0bb5 c1				pop bc 
0bb6 d1				pop de 
0bb7 e1				pop hl 
0bb8			 
0bb8 c9				ret 
0bb9			;scroll_down: 
0bb9			;	ld de, display_row_4 
0bb9			;	ld hl, display_row_3 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;	ld de, display_row_3 
0bb9			; 	ld hl, display_row_2 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;	ld de, display_row_2 
0bb9			;	ld hl, display_row_1 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;;; TODO clear row 1 
0bb9			;	ret 
0bb9			 
0bb9			 
0bb9			 
0bb9			 
0bb9			 
0bb9			; clear active frame buffer 
0bb9			 
0bb9			clear_display: 
0bb9 3e 20			ld a, ' ' 
0bbb c3 be 0b			jp fill_display 
0bbe			 
0bbe			; fill active frame buffer with a char in A 
0bbe			 
0bbe			fill_display: 
0bbe 06 a0			ld b,display_fb_len 
0bc0 2a cc eb			ld hl, (display_fb_active) 
0bc3 77			.fd1:	ld (hl),a 
0bc4 23				inc hl 
0bc5 10 fc			djnz .fd1 
0bc7 23				inc hl 
0bc8 3e 00			ld a,0 
0bca 77				ld (hl),a 
0bcb			 
0bcb			 
0bcb c9				ret 
0bcc			; Write string (DE) at pos (A) to active frame buffer 
0bcc			 
0bcc 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
0bcf 06 00					ld b,0 
0bd1 4f					ld c,a 
0bd2 09					add hl,bc 
0bd3 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bd4 b7			            OR   A              ;Null terminator? 
0bd5 c8			            RET  Z              ;Yes, so finished 
0bd6 77					ld (hl),a 
0bd7 23				inc hl 
0bd8 13			            INC  DE             ;Point to next character 
0bd9 18 f8		            JR   .sad1     ;Repeat 
0bdb c9					ret 
0bdc			 
0bdc			; using current frame buffer write to physical display 
0bdc			 
0bdc			update_display: 
0bdc e5				push hl 
0bdd 2a cc eb			ld hl, (display_fb_active) 
0be0 cd d3 66			call write_display 
0be3 e1				pop hl 
0be4 c9				ret 
0be5			 
0be5			; TODO scrolling 
0be5			 
0be5			 
0be5			; move cursor right one char 
0be5			cursor_right: 
0be5			 
0be5				; TODO shift right 
0be5				; TODO if beyond max col 
0be5				; TODO       cursor_next_line 
0be5			 
0be5 c9				ret 
0be6			 
0be6			 
0be6			cursor_next_line: 
0be6				; TODO first char 
0be6				; TODO line down 
0be6				; TODO if past last row 
0be6				; TODO    scroll up 
0be6			 
0be6 c9				ret 
0be7			 
0be7			cursor_left: 
0be7				; TODO shift left 
0be7				; TODO if beyond left  
0be7				; TODO     cursor prev line 
0be7				 
0be7 c9				ret 
0be8			 
0be8			cursor_prev_line: 
0be8				; TODO last char 
0be8				; TODO line up 
0be8				; TODO if past first row 
0be8				; TODO   scroll down 
0be8			 
0be8 c9				ret 
0be9			 
0be9			 
0be9			cout: 
0be9				; A - char 
0be9 c9				ret 
0bea			 
0bea			 
0bea			; Display a menu and allow item selection (optional toggle items) 
0bea			; 
0bea			; format: 
0bea			; hl pointer to word array with zero term for items 
0bea			; e.g.    db item1 
0bea			;         db .... 
0bea			;         db 0 
0bea			; 
0bea			; a = starting menu item  
0bea			; 
0bea			; de = pointer item toggle array   (todo) 
0bea			; 
0bea			; returns item selected in a 1-... 
0bea			; returns 0 if back button pressed 
0bea			; 
0bea			; NOTE: Uses system frame buffer to display 
0bea			; 
0bea			; LEFT, Q = go back 
0bea			; RIGHT, SPACE, CR = select 
0bea			; UP, A - Up 
0bea			; DOWN, Z - Down 
0bea			 
0bea			 
0bea			 
0bea			 
0bea			 
0bea			menu: 
0bea			 
0bea					; keep array pointer 
0bea			 
0bea 22 73 ea				ld (store_tmp1), hl 
0bed 32 71 ea				ld (store_tmp2), a 
0bf0			 
0bf0					; check for key bounce 
0bf0			 
0bf0			if BASE_KEV 
0bf0			 
0bf0			.mbounce:	call cin 
0bf0					cp 0 
0bf0					jr nz, .mbounce 
0bf0			endif 
0bf0					; for ease use ex 
0bf0			 
0bf0					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bf0 21 b1 ed				ld hl, display_fb0 
0bf3 22 cc eb				ld (display_fb_active), hl 
0bf6			 
0bf6 cd b9 0b		.mloop:		call clear_display 
0bf9 cd dc 0b				call update_display 
0bfc			 
0bfc					; draw selection id '>' at 1 
0bfc			 
0bfc					; init start of list display 
0bfc			 
0bfc 3e 05				ld a, 5 
0bfe 32 6f ea				ld (store_tmp3), a   ; display row count 
0c01 3a 71 ea				ld a,( store_tmp2) 
0c04 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c07			 
0c07					 
0c07			.mitem:	 
0c07			 
0c07			 
0c07 3a 72 ea				ld a,(store_tmp2+1) 
0c0a 6f					ld l, a 
0c0b 26 00				ld h, 0 
0c0d 29					add hl, hl 
0c0e ed 5b 73 ea			ld de, (store_tmp1) 
0c12 19					add hl, de 
0c13 7e					ld a, (hl) 
0c14 23					inc hl 
0c15 66					ld h,(hl) 
0c16 6f					ld l, a 
0c17			 
0c17 cd 0f 0e				call ishlzero 
0c1a 28 1a				jr z, .mdone 
0c1c			 
0c1c eb					ex de, hl 
0c1d 3a 6f ea				ld a, (store_tmp3) 
0c20 cd cc 0b				call str_at_display 
0c23					 
0c23			 
0c23					; next item 
0c23 3a 72 ea				ld a, (store_tmp2+1) 
0c26 3c					inc a 
0c27 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c2a			 
0c2a			 		; next row 
0c2a			 
0c2a 3a 6f ea				ld a, (store_tmp3) 
0c2d c6 28				add display_cols 
0c2f 32 6f ea				ld (store_tmp3), a 
0c32			 
0c32					; at end of screen? 
0c32			 
0c32 fe 10				cp display_rows*4 
0c34 20 d1				jr nz, .mitem 
0c36			 
0c36			 
0c36			.mdone: 
0c36 cd 0f 0e				call ishlzero 
0c39 28 08				jr z, .nodn 
0c3b			 
0c3b 3e 78				ld a, display_row_4 
0c3d 11 bc 0c				ld de, .mdown 
0c40 cd cc 0b				call str_at_display 
0c43			 
0c43					; draw options to fill the screens with active item on line 1 
0c43					; if current option is 2 or more then display ^ in top 
0c43			 
0c43 3a 71 ea		.nodn:		ld a, (store_tmp2) 
0c46 fe 00				cp 0 
0c48 28 08				jr z, .noup 
0c4a			 
0c4a 3e 00				ld a, 0 
0c4c 11 ba 0c				ld de, .mup 
0c4f cd cc 0b				call str_at_display 
0c52			 
0c52 3e 02		.noup:		ld a, 2 
0c54 11 b8 0c				ld de, .msel 
0c57 cd cc 0b				call str_at_display 
0c5a			 
0c5a					; if current option + 1 is not null then display V in bottom 
0c5a					; get key 
0c5a cd dc 0b				call update_display 
0c5d			 
0c5d			 
0c5d					; handle key 
0c5d			 
0c5d cd 85 67				call cin_wait 
0c60			 
0c60 fe 05				cp KEY_UP 
0c62 28 2b				jr z, .mgoup 
0c64 fe 61				cp 'a' 
0c66 28 27				jr z, .mgoup 
0c68 fe 0a				cp KEY_DOWN 
0c6a 28 32				jr z, .mgod 
0c6c fe 7a				cp 'z' 
0c6e 28 2e				jr z, .mgod 
0c70 fe 20				cp ' ' 
0c72 28 34				jr z, .goend 
0c74 fe 0c				cp KEY_RIGHT 
0c76 28 30				jr z, .goend 
0c78 fe 0d				cp KEY_CR 
0c7a 28 2c				jr z, .goend 
0c7c fe 71				cp 'q' 
0c7e 28 0b				jr z, .goback 
0c80			 
0c80 fe 0b				cp KEY_LEFT 
0c82 28 07				jr z, .goback 
0c84 fe 08				cp KEY_BS 
0c86 28 03				jr z, .goback 
0c88 c3 f6 0b				jp .mloop 
0c8b			 
0c8b			.goback: 
0c8b 3e 00			ld a, 0 
0c8d 18 1d			jr .goend2 
0c8f			 
0c8f				; move up one 
0c8f			.mgoup: 
0c8f 3a 71 ea				ld a, (store_tmp2) 
0c92 fe 00				cp 0 
0c94 ca f6 0b				jp z, .mloop 
0c97 3d					dec a 
0c98 32 71 ea				ld (store_tmp2), a 
0c9b c3 f6 0b				jp .mloop 
0c9e			 
0c9e				; move down one 
0c9e			.mgod: 
0c9e 3a 71 ea				ld a, (store_tmp2) 
0ca1 3c					inc a 
0ca2 32 71 ea				ld (store_tmp2), a 
0ca5 c3 f6 0b				jp .mloop 
0ca8			 
0ca8			 
0ca8			.goend: 
0ca8					; get selected item number 
0ca8			 
0ca8 3a 71 ea				ld a, (store_tmp2) 
0cab 3c					inc a 
0cac			 
0cac			.goend2: 
0cac f5					push af 
0cad			 
0cad					; restore active fb 
0cad					; TODO BUG assumes fb1 
0cad			 
0cad 21 10 ed				ld hl, display_fb1 
0cb0 22 cc eb				ld (display_fb_active), hl 
0cb3			 
0cb3					; restore main regs 
0cb3			 
0cb3			 
0cb3 cd dc 0b				call update_display 
0cb6			 
0cb6 f1					pop af 
0cb7			 
0cb7 c9				ret 
0cb8			 
0cb8 .. 00		.msel:   db ">",0 
0cba .. 00		.mup:   db "^",0 
0cbc .. 00		.mdown:   db "v",0 
0cbe			 
0cbe			 
0cbe			; eof 
0cbe			 
# End of file firmware_display.asm
0cbe			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cbe			; random number generators 
0cbe			 
0cbe			 
0cbe			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cbe			 
0cbe			 
0cbe			;-----> Generate a random number 
0cbe			; output a=answer 0<=a<=255 
0cbe			; all registers are preserved except: af 
0cbe			random: 
0cbe e5			        push    hl 
0cbf d5			        push    de 
0cc0 2a ab eb		        ld      hl,(randData) 
0cc3 ed 5f		        ld      a,r 
0cc5 57			        ld      d,a 
0cc6 5e			        ld      e,(hl) 
0cc7 19			        add     hl,de 
0cc8 85			        add     a,l 
0cc9 ac			        xor     h 
0cca 22 ab eb		        ld      (randData),hl 
0ccd d1			        pop     de 
0cce e1			        pop     hl 
0ccf c9			        ret 
0cd0			 
0cd0			 
0cd0			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cd0			 
0cd0			 
0cd0			 
0cd0			;------LFSR------ 
0cd0			;James Montelongo 
0cd0			;optimized by Spencer Putt 
0cd0			;out: 
0cd0			; a = 8 bit random number 
0cd0			RandLFSR: 
0cd0 21 b1 eb		        ld hl,LFSRSeed+4 
0cd3 5e			        ld e,(hl) 
0cd4 23			        inc hl 
0cd5 56			        ld d,(hl) 
0cd6 23			        inc hl 
0cd7 4e			        ld c,(hl) 
0cd8 23			        inc hl 
0cd9 7e			        ld a,(hl) 
0cda 47			        ld b,a 
0cdb cb 13		        rl e  
0cdd cb 12			rl d 
0cdf cb 11		        rl c  
0ce1 17				rla 
0ce2 cb 13		        rl e  
0ce4 cb 12			rl d 
0ce6 cb 11		        rl c  
0ce8 17				rla 
0ce9 cb 13		        rl e  
0ceb cb 12			rl d 
0ced cb 11		        rl c  
0cef 17				rla 
0cf0 67			        ld h,a 
0cf1 cb 13		        rl e  
0cf3 cb 12			rl d 
0cf5 cb 11		        rl c  
0cf7 17				rla 
0cf8 a8			        xor b 
0cf9 cb 13		        rl e  
0cfb cb 12			rl d 
0cfd ac			        xor h 
0cfe a9			        xor c 
0cff aa			        xor d 
0d00 21 b3 eb		        ld hl,LFSRSeed+6 
0d03 11 b4 eb		        ld de,LFSRSeed+7 
0d06 01 07 00		        ld bc,7 
0d09 ed b8		        lddr 
0d0b 12			        ld (de),a 
0d0c c9			        ret 
0d0d			 
0d0d			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d0d			 
0d0d			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d0d			 
0d0d			 
0d0d			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d0d			 
0d0d			prng16: 
0d0d			;Inputs: 
0d0d			;   (seed1) contains a 16-bit seed value 
0d0d			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d0d			;Outputs: 
0d0d			;   HL is the result 
0d0d			;   BC is the result of the LCG, so not that great of quality 
0d0d			;   DE is preserved 
0d0d			;Destroys: 
0d0d			;   AF 
0d0d			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d0d			;160cc 
0d0d			;26 bytes 
0d0d 2a a5 eb		    ld hl,(seed1) 
0d10 44			    ld b,h 
0d11 4d			    ld c,l 
0d12 29			    add hl,hl 
0d13 29			    add hl,hl 
0d14 2c			    inc l 
0d15 09			    add hl,bc 
0d16 22 a5 eb		    ld (seed1),hl 
0d19 2a a3 eb		    ld hl,(seed2) 
0d1c 29			    add hl,hl 
0d1d 9f			    sbc a,a 
0d1e e6 2d		    and %00101101 
0d20 ad			    xor l 
0d21 6f			    ld l,a 
0d22 22 a3 eb		    ld (seed2),hl 
0d25 09			    add hl,bc 
0d26 c9			    ret 
0d27			 
0d27			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d27			 
0d27			rand32: 
0d27			;Inputs: 
0d27			;   (seed1_0) holds the lower 16 bits of the first seed 
0d27			;   (seed1_1) holds the upper 16 bits of the first seed 
0d27			;   (seed2_0) holds the lower 16 bits of the second seed 
0d27			;   (seed2_1) holds the upper 16 bits of the second seed 
0d27			;   **NOTE: seed2 must be non-zero 
0d27			;Outputs: 
0d27			;   HL is the result 
0d27			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d27			;Destroys: 
0d27			;   AF 
0d27			;Tested and passes all CAcert tests 
0d27			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d27			;it has a period of 18,446,744,069,414,584,320 
0d27			;roughly 18.4 quintillion. 
0d27			;LFSR taps: 0,2,6,7  = 11000101 
0d27			;291cc 
0d27			;seed1_0=$+1 
0d27			;    ld hl,12345 
0d27			;seed1_1=$+1 
0d27			;    ld de,6789 
0d27			;    ld b,h 
0d27			;    ld c,l 
0d27			;    add hl,hl \ rl e \ rl d 
0d27			;    add hl,hl \ rl e \ rl d 
0d27			;    inc l 
0d27			;    add hl,bc 
0d27			;    ld (seed1_0),hl 
0d27			;    ld hl,(seed1_1) 
0d27			;    adc hl,de 
0d27			;    ld (seed1_1),hl 
0d27			;    ex de,hl 
0d27			;seed2_0=$+1 
0d27			;    ld hl,9876 
0d27			;seed2_1=$+1 
0d27			;    ld bc,54321 
0d27			;    add hl,hl \ rl c \ rl b 
0d27			;    ld (seed2_1),bc 
0d27			;    sbc a,a 
0d27			;    and %11000101 
0d27			;    xor l 
0d27			;    ld l,a 
0d27			;    ld (seed2_0),hl 
0d27			;    ex de,hl 
0d27			;    add hl,bc 
0d27			;    ret 
0d27			; 
0d27			 
0d27			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d27			; 20 bytes, 86 cycles (excluding ret) 
0d27			 
0d27			; returns   hl = pseudorandom number 
0d27			; corrupts   a 
0d27			 
0d27			; generates 16-bit pseudorandom numbers with a period of 65535 
0d27			; using the xorshift method: 
0d27			 
0d27			; hl ^= hl << 7 
0d27			; hl ^= hl >> 9 
0d27			; hl ^= hl << 8 
0d27			 
0d27			; some alternative shift triplets which also perform well are: 
0d27			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d27			 
0d27			;  org 32768 
0d27			 
0d27			xrnd: 
0d27 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d2a 3e 00		  ld a,0 
0d2c bd			  cp l 
0d2d 20 02		  jr nz, .xrnd1 
0d2f 2e 01		  ld l, 1 
0d31			.xrnd1: 
0d31			 
0d31 7c			  ld a,h 
0d32 1f			  rra 
0d33 7d			  ld a,l 
0d34 1f			  rra 
0d35 ac			  xor h 
0d36 67			  ld h,a 
0d37 7d			  ld a,l 
0d38 1f			  rra 
0d39 7c			  ld a,h 
0d3a 1f			  rra 
0d3b ad			  xor l 
0d3c 6f			  ld l,a 
0d3d ac			  xor h 
0d3e 67			  ld h,a 
0d3f			 
0d3f 22 a9 eb		  ld (xrandc),hl 
0d42			 
0d42 c9			  ret 
0d43			;  
0d43			 
0d43			 
0d43			;;;; int maths 
0d43			 
0d43			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d43			; Divide 16-bit values (with 16-bit result) 
0d43			; In: Divide BC by divider DE 
0d43			; Out: BC = result, HL = rest 
0d43			; 
0d43			Div16: 
0d43 21 00 00		    ld hl,0 
0d46 78			    ld a,b 
0d47 06 08		    ld b,8 
0d49			Div16_Loop1: 
0d49 17			    rla 
0d4a ed 6a		    adc hl,hl 
0d4c ed 52		    sbc hl,de 
0d4e 30 01		    jr nc,Div16_NoAdd1 
0d50 19			    add hl,de 
0d51			Div16_NoAdd1: 
0d51 10 f6		    djnz Div16_Loop1 
0d53 17			    rla 
0d54 2f			    cpl 
0d55 47			    ld b,a 
0d56 79			    ld a,c 
0d57 48			    ld c,b 
0d58 06 08		    ld b,8 
0d5a			Div16_Loop2: 
0d5a 17			    rla 
0d5b ed 6a		    adc hl,hl 
0d5d ed 52		    sbc hl,de 
0d5f 30 01		    jr nc,Div16_NoAdd2 
0d61 19			    add hl,de 
0d62			Div16_NoAdd2: 
0d62 10 f6		    djnz Div16_Loop2 
0d64 17			    rla 
0d65 2f			    cpl 
0d66 41			    ld b,c 
0d67 4f			    ld c,a 
0d68 c9			ret 
0d69			 
0d69			 
0d69			;http://z80-heaven.wikidot.com/math 
0d69			; 
0d69			;Inputs: 
0d69			;     DE and A are factors 
0d69			;Outputs: 
0d69			;     A is not changed 
0d69			;     B is 0 
0d69			;     C is not changed 
0d69			;     DE is not changed 
0d69			;     HL is the product 
0d69			;Time: 
0d69			;     342+6x 
0d69			; 
0d69			Mult16: 
0d69			 
0d69 06 08		     ld b,8          ;7           7 
0d6b 21 00 00		     ld hl,0         ;10         10 
0d6e 29			       add hl,hl     ;11*8       88 
0d6f 07			       rlca          ;4*8        32 
0d70 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d72 19			         add hl,de   ;--         -- 
0d73 10 f9		       djnz $-5      ;13*7+8     99 
0d75 c9			ret 
0d76			 
0d76			; 
0d76			; Square root of 16-bit value 
0d76			; In:  HL = value 
0d76			; Out:  D = result (rounded down) 
0d76			; 
0d76			;Sqr16: 
0d76			;    ld de,#0040 
0d76			;    ld a,l 
0d76			;    ld l,h 
0d76			;    ld h,d 
0d76			;    or a 
0d76			;    ld b,8 
0d76			;Sqr16_Loop: 
0d76			;    sbc hl,de 
0d76			;    jr nc,Sqr16_Skip 
0d76			;    add hl,de 
0d76			;Sqr16_Skip: 
0d76			;    ccf 
0d76			;    rl d 
0d76			;    add a,a 
0d76			;    adc hl,hl 
0d76			;    add a,a 
0d76			;    adc hl,hl 
0d76			;    djnz Sqr16_Loop 
0d76			;    ret 
0d76			; 
0d76			; 
0d76			; Divide 8-bit values 
0d76			; In: Divide E by divider C 
0d76			; Out: A = result, B = rest 
0d76			; 
0d76			Div8: 
0d76 af			    xor a 
0d77 06 08		    ld b,8 
0d79			Div8_Loop: 
0d79 cb 13		    rl e 
0d7b 17			    rla 
0d7c 91			    sub c 
0d7d 30 01		    jr nc,Div8_NoAdd 
0d7f 81			    add a,c 
0d80			Div8_NoAdd: 
0d80 10 f7		    djnz Div8_Loop 
0d82 47			    ld b,a 
0d83 7b			    ld a,e 
0d84 17			    rla 
0d85 2f			    cpl 
0d86 c9			    ret 
0d87			 
0d87			; 
0d87			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d87			; In: Multiply A with DE 
0d87			; Out: HL = result 
0d87			; 
0d87			Mult12U: 
0d87 2e 00		    ld l,0 
0d89 87			    add a,a 
0d8a 30 01		    jr nc,Mult12U_NoAdd0 
0d8c 19			    add hl,de 
0d8d			Mult12U_NoAdd0: 
0d8d 29			    add hl,hl 
0d8e 87			    add a,a 
0d8f 30 01		    jr nc,Mult12U_NoAdd1 
0d91 19			    add hl,de 
0d92			Mult12U_NoAdd1: 
0d92 29			    add hl,hl 
0d93 87			    add a,a 
0d94 30 01		    jr nc,Mult12U_NoAdd2 
0d96 19			    add hl,de 
0d97			Mult12U_NoAdd2: 
0d97 29			    add hl,hl 
0d98 87			    add a,a 
0d99 30 01		    jr nc,Mult12U_NoAdd3 
0d9b 19			    add hl,de 
0d9c			Mult12U_NoAdd3: 
0d9c 29			    add hl,hl 
0d9d 87			    add a,a 
0d9e 30 01		    jr nc,Mult12U_NoAdd4 
0da0 19			    add hl,de 
0da1			Mult12U_NoAdd4: 
0da1 29			    add hl,hl 
0da2 87			    add a,a 
0da3 30 01		    jr nc,Mult12U_NoAdd5 
0da5 19			    add hl,de 
0da6			Mult12U_NoAdd5: 
0da6 29			    add hl,hl 
0da7 87			    add a,a 
0da8 30 01		    jr nc,Mult12U_NoAdd6 
0daa 19			    add hl,de 
0dab			Mult12U_NoAdd6: 
0dab 29			    add hl,hl 
0dac 87			    add a,a 
0dad d0			    ret nc 
0dae 19			    add hl,de 
0daf c9			    ret 
0db0			 
0db0			; 
0db0			; Multiply 8-bit value with a 16-bit value (right rotating) 
0db0			; In: Multiply A with DE 
0db0			;      Put lowest value in A for most efficient calculation 
0db0			; Out: HL = result 
0db0			; 
0db0			Mult12R: 
0db0 21 00 00		    ld hl,0 
0db3			Mult12R_Loop: 
0db3 cb 3f		    srl a 
0db5 30 01		    jr nc,Mult12R_NoAdd 
0db7 19			    add hl,de 
0db8			Mult12R_NoAdd: 
0db8 cb 23		    sla e 
0dba cb 12		    rl d 
0dbc b7			    or a 
0dbd c2 b3 0d		    jp nz,Mult12R_Loop 
0dc0 c9			    ret 
0dc1			 
0dc1			; 
0dc1			; Multiply 16-bit values (with 32-bit result) 
0dc1			; In: Multiply BC with DE 
0dc1			; Out: BCHL = result 
0dc1			; 
0dc1			Mult32: 
0dc1 79			    ld a,c 
0dc2 48			    ld c,b 
0dc3 21 00 00		    ld hl,0 
0dc6 06 10		    ld b,16 
0dc8			Mult32_Loop: 
0dc8 29			    add hl,hl 
0dc9 17			    rla 
0dca cb 11		    rl c 
0dcc 30 07		    jr nc,Mult32_NoAdd 
0dce 19			    add hl,de 
0dcf ce 00		    adc a,0 
0dd1 d2 d5 0d		    jp nc,Mult32_NoAdd 
0dd4 0c			    inc c 
0dd5			Mult32_NoAdd: 
0dd5 10 f1		    djnz Mult32_Loop 
0dd7 41			    ld b,c 
0dd8 4f			    ld c,a 
0dd9 c9			    ret 
0dda			 
0dda			 
0dda			 
0dda			; 
0dda			; Multiply 8-bit values 
0dda			; In:  Multiply H with E 
0dda			; Out: HL = result 
0dda			; 
0dda			Mult8: 
0dda 16 00		    ld d,0 
0ddc 6a			    ld l,d 
0ddd 06 08		    ld b,8 
0ddf			Mult8_Loop: 
0ddf 29			    add hl,hl 
0de0 30 01		    jr nc,Mult8_NoAdd 
0de2 19			    add hl,de 
0de3			Mult8_NoAdd: 
0de3 10 fa		    djnz Mult8_Loop 
0de5 c9			    ret 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			;;http://z80-heaven.wikidot.com/math 
0de6			;;This divides DE by BC, storing the result in DE, remainder in HL 
0de6			; 
0de6			;DE_Div_BC:          ;1281-2x, x is at most 16 
0de6			;     ld a,16        ;7 
0de6			;     ld hl,0        ;10 
0de6			;     jp $+5         ;10 
0de6			;.DivLoop: 
0de6			;       add hl,bc    ;-- 
0de6			;       dec a        ;64 
0de6			;       jr z,.DivLoopEnd        ;86 
0de6			; 
0de6			;       sla e        ;128 
0de6			;       rl d         ;128 
0de6			;       adc hl,hl    ;240 
0de6			;       sbc hl,bc    ;240 
0de6			;       jr nc,.DivLoop ;23|21 
0de6			;       inc e        ;-- 
0de6			;       jp .DivLoop+1 
0de6			; 
0de6			;.DivLoopEnd: 
0de6			 
0de6			;HL_Div_C: 
0de6			;Inputs: 
0de6			;     HL is the numerator 
0de6			;     C is the denominator 
0de6			;Outputs: 
0de6			;     A is the remainder 
0de6			;     B is 0 
0de6			;     C is not changed 
0de6			;     DE is not changed 
0de6			;     HL is the quotient 
0de6			; 
0de6			;       ld b,16 
0de6			;       xor a 
0de6			;         add hl,hl 
0de6			;         rla 
0de6			;         cp c 
0de6			;         jr c,$+4 
0de6			;           inc l 
0de6			;           sub c 
0de6			;         djnz $-7 
0de6			 
0de6			; https://plutiedev.com/z80-add-8bit-to-16bit 
0de6			 
0de6			addatohl: 
0de6 85			    add   a, l    ; A = A+L 
0de7 6f			    ld    l, a    ; L = A+L 
0de8 8c			    adc   a, h    ; A = A+L+H+carry 
0de9 95			    sub   l       ; A = H+carry 
0dea 67			    ld    h, a    ; H = H+carry 
0deb c9			ret 
0dec			 
0dec			addatode: 
0dec 83			    add   a, e    ; A = A+L 
0ded 5f			    ld    e, a    ; L = A+L 
0dee 8a			    adc   a, d    ; A = A+L+H+carry 
0def 93			    sub   e       ; A = H+carry 
0df0 57			    ld    d, a    ; H = H+carry 
0df1 c9			ret 
0df2			 
0df2			 
0df2			addatobc: 
0df2 81			    add   a, c    ; A = A+L 
0df3 4f			    ld    c, a    ; L = A+L 
0df4 88			    adc   a, b    ; A = A+L+H+carry 
0df5 91			    sub   c       ; A = H+carry 
0df6 47			    ld    b, a    ; H = H+carry 
0df7 c9			ret 
0df8			 
0df8			subafromhl: 
0df8			   ; If A=0 do nothing 
0df8			    ; Otherwise flip A's sign. Since 
0df8			    ; the upper byte becomes -1, also 
0df8			    ; substract 1 from H. 
0df8 ed 44		    neg 
0dfa ca 03 0e		    jp    z, Skip 
0dfd 25			    dec   h 
0dfe			     
0dfe			    ; Now add the low byte as usual 
0dfe			    ; Two's complement takes care of 
0dfe			    ; ensuring the result is correct 
0dfe 85			    add   a, l 
0dff 6f			    ld    l, a 
0e00 8c			    adc   a, h 
0e01 95			    sub   l 
0e02 67			    ld    h, a 
0e03			Skip: 
0e03 c9				ret 
0e04			 
0e04			 
0e04			; compare hl and de 
0e04			; returns:  
0e04			; if hl = de, z=1, s=0, c0=0 
0e04			; if hl > de, z=0, s=0, c=0 
0e04			; if hl < de, z=0, s=1, c=1 
0e04			cmp16:	 
0e04 b7				or a 
0e05 ed 52			sbc hl,de 
0e07 e0				ret po 
0e08 7c				ld a,h 
0e09 1f				rra 
0e0a ee 40			xor 01000000B 
0e0c 37				scf 
0e0d 8f				adc a,a 
0e0e c9				ret 
0e0f			 
0e0f			 
0e0f			; test if hl contains zero   - A is destroyed 
0e0f			 
0e0f			ishlzero:    
0e0f b7				or a     ; reset flags 
0e10 7c				ld a, h 
0e11 b5				or l        	 
0e12			 
0e12 c9				ret 
0e13			 
0e13			 
0e13			 
0e13			 
0e13			if FORTH_ENABLE_FLOATMATH 
0e13			;include "float/bbcmath.z80" 
0e13			include "float/lpfpcalc.asm" 
0e13			endif 
0e13			 
0e13			 
0e13			; eof 
0e13			 
# End of file firmware_maths.asm
0e13			include "firmware_strings.asm"   ; string handling  
0e13			 
0e13			 
0e13			; TODO string len 
0e13			; input text string, end on cr with zero term 
0e13			; a offset into frame buffer to start prompt 
0e13			; d is max length 
0e13			; e is display size TODO 
0e13			; c is current cursor position 
0e13			; hl is ptr to where string will be stored and edited directly 
0e13			 
0e13			 
0e13			; TODO check limit of buffer for new inserts 
0e13			; TODO check insert does not push beyond buffer 
0e13			; TODO scroll in a limited display area 
0e13			; TODO scroll whole screen on page wrap 
0e13			 
0e13			 
0e13			; TODO handle KEY_PREVWORD 
0e13			; TODO handle KEY_NEXTWORD 
0e13			; TODO handle KEY_HOME 
0e13			; TODO handle KEY_END 
0e13			; TODO use LCD cursor? 
0e13			 
0e13			EDIT_V1: equ 0 
0e13			EDIT_V2: equ 1 
0e13			 
0e13			 
0e13			 
0e13			if EDIT_V2 
0e13			input_str: 
0e13			else 
0e13			input_str_new: 
0e13			endif 
0e13			 
0e13 32 64 ee			    	ld (input_at_pos),a      ; save display position to start 
0e16			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0e16 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
0e19			;		ld a, c 
0e19			;		call addatohl 
0e19			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
0e19 7a					ld a,d 
0e1a 32 66 ee			        ld (input_size), a       ; save length of input area 
0e1d 79					ld a, c 
0e1e 32 55 ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
0e21 7b					ld a,e 
0e22 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e25			 
0e25			 
0e25					; add a trailing space to make screen refresh nicer 
0e25			 
0e25					;ld hl, (input_start) 
0e25					;push hl 
0e25					;ld a, 0 
0e25					;call strlent 
0e25					;ld a, l 
0e25					;pop hl 
0e25					;call addatohl 
0e25					;dec hl 
0e25					;ld a, ' ' 
0e25					;ld (hl), a 
0e25					;inc hl 
0e25					;ld (hl), a 
0e25					;inc hl 
0e25					;ld a, 0 
0e25					;ld (hl), a 
0e25			 
0e25			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e25					; init cursor shape if not set by the cin routines 
0e25 21 c1 eb				ld hl, cursor_shape 
0e28			if BASE_KEV 
0e28					ld a, 255 
0e28			else 
0e28 3e 23				ld a, '#' 
0e2a			endif 
0e2a 77					ld (hl), a 
0e2b 23					inc hl 
0e2c 3e 00				ld a, 0 
0e2e 77					ld (hl), a 
0e2f			 
0e2f 3e 09				ld a, CUR_BLINK_RATE 
0e31 32 60 ee				ld (input_cur_flash), a 
0e34 3e 01				ld a, 1 
0e36 32 5f ee				ld (input_cur_onoff),a 
0e39			.inmain:	 
0e39			 
0e39 2a 67 ee				ld hl, (input_start) 
0e3c 3e 00				ld a, 0 
0e3e cd ae 13				call strlent 
0e41 7d					ld a, l 
0e42 32 5a ee				ld (input_len),a 
0e45 cd f2 0e				call input_disp_ref 
0e48					;call input_disp_oncur 
0e48			 
0e48					; TODO display current state of input buffer 
0e48			 
0e48			 
0e48					; pause 1ms 
0e48			 
0e48 3e 01				ld a, 1 
0e4a cd d6 0a				call aDelayInMS 
0e4d			 
0e4d			; display cursor if visible on this cycle 
0e4d			 
0e4d					; dec flash counter 
0e4d 3a 60 ee				ld a, (input_cur_flash) 
0e50 3d					dec a 
0e51 32 60 ee				ld (input_cur_flash), a 
0e54 fe 00				cp 0 
0e56 20 0d				jr nz, .inochgstate 
0e58			 
0e58			 
0e58					; reset on change of state 
0e58 3e 09				ld a, CUR_BLINK_RATE 
0e5a 32 60 ee				ld (input_cur_flash), a 
0e5d			 
0e5d					; change state 
0e5d 3a 5f ee				ld a,(input_cur_onoff) 
0e60 ed 44				neg 
0e62 32 5f ee				ld (input_cur_onoff),a 
0e65			 
0e65			 
0e65			 
0e65			 
0e65					; TODO is cursor visible? 
0e65					; TODO if so then over write the char at curspos pos with the cursor shape 
0e65			 
0e65								 
0e65			 
0e65			.inochgstate: 
0e65 3a 5f ee				ld a,(input_cur_onoff) 
0e68 fe ff				cp 255 
0e6a 28 0e				jr z, .skipcursor 
0e6c 3a 64 ee				ld a, (input_at_pos) 
0e6f 47					ld b, a 
0e70 3a 55 ee				ld a, (input_cursor) 
0e73 80					add b 
0e74 11 c1 eb				ld de, cursor_shape 
0e77					 
0e77 cd cc 0b				call str_at_display 
0e7a			 
0e7a			.skipcursor: 
0e7a				if DEBUG_INPUTV2 
0e7a			 
0e7a 3a 64 ee				ld a,(input_at_pos) 
0e7d 21 ad eb				ld hl, LFSRSeed 
0e80 cd 46 12				call hexout 
0e83 3a 55 ee				ld a, (input_cursor) 
0e86 21 af eb				ld hl, LFSRSeed+2 
0e89 cd 46 12				call hexout 
0e8c 3a 66 ee				ld a,(input_size) 
0e8f 21 b1 eb				ld hl, LFSRSeed+4 
0e92 cd 46 12				call hexout 
0e95			 
0e95 3a 5f ee				ld a,(input_cur_onoff) 
0e98 21 b3 eb				ld hl, LFSRSeed+6 
0e9b cd 46 12				call hexout 
0e9e			 
0e9e 3a 60 ee				ld a,(input_cur_flash) 
0ea1 21 b5 eb				ld hl, LFSRSeed+8 
0ea4 cd 46 12				call hexout 
0ea7			 
0ea7 3a 5a ee				ld a,(input_len) 
0eaa 21 b7 eb				ld hl, LFSRSeed+10 
0ead cd 46 12				call hexout 
0eb0 21 b9 eb				ld hl, LFSRSeed+12 
0eb3 3e 00				ld a, 0 
0eb5 77					ld (hl),a 
0eb6 3e 78				ld a, display_row_4 
0eb8 11 ad eb				ld de, LFSRSeed 
0ebb cd cc 0b				call str_at_display 
0ebe				endif 
0ebe cd dc 0b				call update_display 
0ec1			 
0ec1					; TODO keyboard processing 
0ec1			 
0ec1			if BASE_CPM 
0ec1 cd 85 67				call cin_wait 
0ec4			else 
0ec4					call cin    ; _wait 
0ec4			endif 
0ec4 fe 00				cp 0 
0ec6 ca 39 0e				jp z, .inmain 
0ec9			 
0ec9 fe 0b				cp KEY_LEFT    ; cursor left 
0ecb ca de 0e				jp z, input_left 
0ece				 
0ece fe 0c				cp KEY_RIGHT      ; cursor right 
0ed0 ca e8 0e				jp z, input_right 
0ed3			 
0ed3 fe 0d				cp KEY_CR 
0ed5 c8					ret z 
0ed6			 
0ed6 fe 08				cp KEY_BS 
0ed8 ca 55 0f				jp z, input_delchar 
0edb			 
0edb			;		cp KEY_HOME    ; jump to start of line 
0edb			;		jr nz, .instr5 
0edb			;		dec hl 
0edb			;		ld (input_ptr),hl 
0edb			;		jr .instr1 
0edb			 
0edb			;		cp KEY_END     ; jump to end of line 
0edb			;		jr nz, .instr6 
0edb			;		dec hl 
0edb			;		ld (input_ptr),hl 
0edb			;		jr .instr1 
0edb			;	        cp KEY_UP      ; recall last command 
0edb			;		jr nz, .instrnew 
0edb			; 
0edb			;	ld hl, scratch 
0edb			;	ld de, os_last_cmd 
0edb			;	call strcpy 
0edb			;		jr .instr1 
0edb			 
0edb			 
0edb					; if no special key then insert as a char 
0edb			 
0edb c3 21 0f				jp input_inschr 
0ede			 
0ede				 
0ede			 
0ede			 
0ede			 
0ede			input_left: 
0ede				; move cursor left 
0ede 3a 55 ee			ld a, (input_cursor) 
0ee1			;	cp 0 
0ee1			;	jp z, .inmain    ; ignore left as at the start of the string 
0ee1 3d				dec a 
0ee2 32 55 ee			ld (input_cursor), a 
0ee5 c3 39 0e			jp .inmain 
0ee8			 
0ee8			input_right: 
0ee8				; move cursor right 
0ee8				 
0ee8				;ld a, (input_size) 
0ee8				;ld b, a 
0ee8 3a 55 ee			ld a, (input_cursor) 
0eeb				;dec b 
0eeb				;cp 0 
0eeb				;jp z, .inmain   ; ignore as at end of the string buffer 
0eeb				;ld a, b 
0eeb 3c				inc a 
0eec 32 55 ee			ld (input_cursor), a 
0eef c3 39 0e			jp .inmain 
0ef2			 
0ef2			 
0ef2			 
0ef2			input_disp_ref: 
0ef2				; display the text from start of buffer (ie full refresh) 
0ef2 3a 64 ee			ld a, (input_at_pos) 
0ef5 2a 67 ee			ld hl,(input_start) 
0ef8 eb				ex de, hl 
0ef9 cd cc 0b			call str_at_display  
0efc c9				ret 
0efd			input_disp_oncur: 
0efd				; display the text from cursor position to end of buffer 
0efd				; TODO position start of string at cursor position on screen 
0efd				; TODO draw from that point on 
0efd 3a 55 ee			ld a, (input_cursor) 
0f00 47				ld b, a 
0f01 3a 64 ee			ld a, (input_at_pos) 
0f04 80				add b 
0f05 48				ld c, b     ; save a 
0f06 78				ld a, b     ; inc string start for cursor 
0f07 2a 67 ee			ld hl,(input_start) 
0f0a cd e6 0d			call addatohl 
0f0d eb				ex de, hl 
0f0e 79				ld a, c 
0f0f cd cc 0b			call str_at_display  
0f12 c9				ret 
0f13			 
0f13			input_nxtw: 
0f13				; Find next word 
0f13 c9				ret 
0f14			 
0f14			input_prvw: 
0f14				; Find previous word 
0f14 c9				ret 
0f15			 
0f15			input_lenrem:   
0f15				; Calculate the length of string remaining from current cursor 
0f15				; position to end of buffer (exc null term) 
0f15				 
0f15 3a 55 ee			ld a, (input_cursor) 
0f18 4f				ld c, a 
0f19 3a 66 ee			ld a, (input_size) 
0f1c 91				sub c 
0f1d 06 00			ld b, 0 
0f1f 0d				dec c 
0f20 c9				ret	 
0f21				 
0f21			 
0f21			input_inschr: 
0f21				; Insert char at cursor position 
0f21 f5				push af   ; save char 
0f22				;call input_lenrem    ; get bc length of remaining string 
0f22			 
0f22				 
0f22			 
0f22 2a 67 ee			ld hl, (input_start) 
0f25 3a 55 ee			ld a, (input_cursor) 
0f28 cd e6 0d			call addatohl 
0f2b				;push hl   ; save to come back to 
0f2b			 
0f2b				; shift everything up one to end of buffer 
0f2b			 
0f2b				;push hl 
0f2b				;dec de 
0f2b				;inc de 
0f2b			;	ldir 
0f2b				 
0f2b				;pop hl 
0f2b			 
0f2b				; are we adding to the end of line? 
0f2b			 
0f2b 3a 55 ee			ld a, (input_cursor) 
0f2e 47				ld b, a 
0f2f 3a 5a ee			ld a, (input_len) 
0f32 b8				cp b 
0f33 20 09			jr nz, .insmid   ; no, insert in middle of text 
0f35			 
0f35				; tack on the end of the line 
0f35 f1				pop af 
0f36 77				ld (hl), a   ; save new char 
0f37 23				inc hl 
0f38 3e 00			ld a, 0 
0f3a 77				ld (hl), a 
0f3b c3 e8 0e			jp input_right 
0f3e				 
0f3e			.insmid: 
0f3e				; hl has insertion point so move everything up one to allow for insertion 
0f3e				;call input_shiftright 
0f3e f1				pop af 
0f3f			 
0f3f			.shufinsmid: 
0f3f 47				ld b, a     ; b contains new char, c prev char at this position  
0f40 7e				ld a, (hl) 
0f41			 
0f41 fe 00			cp 0    ; at end of string need to then dump new char and add term 
0f43 28 07			jr z, .endinsmid 
0f45 4f				ld c, a 
0f46 78				ld a, b 
0f47 77				ld (hl), a 
0f48 23				inc hl 
0f49 79				ld a, c 
0f4a 18 f3			jr .shufinsmid 
0f4c				 
0f4c			 
0f4c			 
0f4c			 
0f4c			.endinsmid: 
0f4c 78				ld a, b 
0f4d 77				ld (hl), a 
0f4e 23				inc hl 
0f4f 3e 00			ld a, 0 
0f51 77				ld (hl), a 
0f52			 
0f52			 
0f52			;	ld (hl), a   ; save new char 
0f52			 
0f52 c3 e8 0e			jp input_right 
0f55			 
0f55			;input_shiftright: 
0f55			;	; shift text right at cursor, hl has shift start 
0f55			;	push hl 
0f55			;	push de 
0f55			;	push bc 
0f55			; 
0f55			; 
0f55			;	; move to end of string past zero term 
0f55			;	ld hl,(input_start) 
0f55			;	ld a, (input_len) 
0f55			;	call addatohl 
0f55			;	inc hl 
0f55			;;	inc hl 
0f55			;;	inc hl 
0f55			;	ld a, 0 
0f55			;	ld (hl), a 
0f55			;;	dec hl 
0f55			;	 
0f55			;;	ld (hl), a 
0f55			;;	dec hl 
0f55			; 
0f55			;	push hl 
0f55			;	pop de 
0f55			;	inc de 
0f55			;	 
0f55			; 
0f55			;;	ld hl,(input_start) 
0f55			;;	ld a, (input_cursor) 
0f55			;;	call addatohl 
0f55			; 
0f55			; 
0f55			;	; calc how many bytes from cursor pos to end of string we need to shift 
0f55			;	call input_lenrem    ; get bc length of remaining string 
0f55			;	;ld a, (input_cursor) 
0f55			;	;ld c, a 
0f55			;	ld a, (input_len) 
0f55			;	cp 2 
0f55			;	jr z, .iskipzero	 
0f55			;	;sub c 
0f55			;	;inc a 
0f55			;	;ld c, a 
0f55			;	;ld b, 0 
0f55			;	inc c 
0f55			;	inc c 
0f55			;	; move data 
0f55			;	lddr 
0f55			;.iskipzero: 
0f55			; 
0f55			;	pop bc 
0f55			;	pop de 
0f55			;	pop hl 
0f55			;	ret	 
0f55			 
0f55			input_delchar: 
0f55				; Delete char at cursor position 
0f55 cd 15 0f			call input_lenrem    ; get bc length of remaining string 
0f58 2a 67 ee			ld hl, (input_start) 
0f5b 3a 55 ee			ld a, (input_cursor) 
0f5e cd e6 0d			call addatohl 
0f61			 
0f61 e5				push hl 
0f62 d1				pop de 
0f63 1b				dec de 
0f64			 
0f64			.dl:	 
0f64 ed a0			ldi  
0f66 7e				ld a, (hl) 
0f67 fe 00			cp 0 
0f69 28 02			jr z, .dldone 
0f6b 18 f7			jr .dl 
0f6d			.dldone: 
0f6d ed a0			ldi 
0f6f			 
0f6f c3 de 0e			jp input_left 
0f72			 
0f72			 
0f72			 
0f72			 
0f72			 
0f72			if EDIT_V1 
0f72			input_str: 
0f72			else 
0f72			input_str_old: 
0f72			endif 
0f72			 
0f72 32 64 ee			    	ld (input_at_pos),a      ; save display position to start 
0f75 81					add c 
0f76 32 62 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0f79 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
0f7c 79					ld a, c 
0f7d cd e6 0d				call addatohl 
0f80 22 69 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0f83 7a					ld a,d 
0f84 32 66 ee			        ld (input_size), a       ; save length of input area 
0f87 79					ld a, c 
0f88 32 55 ee				ld (input_cursor),a      ; init cursor start position  
0f8b 7b					ld a,e 
0f8c 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0f8f					 
0f8f					 
0f8f			 
0f8f			;		ld a,(input_ptr) 
0f8f			;		ld (input_under_cursor),a 	; save what is under the cursor 
0f8f			 
0f8f			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0f8f					; init cursor shape if not set by the cin routines 
0f8f 21 c1 eb				ld hl, cursor_shape 
0f92			if BASE_KEV 
0f92					ld a, 255 
0f92			else 
0f92 3e 23				ld a, '#' 
0f94			endif 
0f94 77					ld (hl), a 
0f95 23					inc hl 
0f96 3e 00				ld a, 0 
0f98 77					ld (hl), a 
0f99			 
0f99 3e 09				ld a, CUR_BLINK_RATE 
0f9b 32 60 ee				ld (input_cur_flash), a 
0f9e 3e 01				ld a, 1 
0fa0 32 5f ee				ld (input_cur_onoff),a 
0fa3			 
0fa3			;	if DEBUG_INPUT 
0fa3			;		push af 
0fa3			;		ld a, 'I' 
0fa3			;		ld (debug_mark),a 
0fa3			;		pop af 
0fa3			;		CALLMONITOR 
0fa3			;	endif 
0fa3			.is1:		; main entry loop 
0fa3			 
0fa3			 
0fa3			 
0fa3					; pause 1ms 
0fa3			 
0fa3 3e 01				ld a, 1 
0fa5 cd d6 0a				call aDelayInMS 
0fa8			 
0fa8					; dec flash counter 
0fa8 3a 60 ee				ld a, (input_cur_flash) 
0fab 3d					dec a 
0fac 32 60 ee				ld (input_cur_flash), a 
0faf fe 00				cp 0 
0fb1 20 0d				jr nz, .nochgstate 
0fb3			 
0fb3			 
0fb3					; change state 
0fb3 3a 5f ee				ld a,(input_cur_onoff) 
0fb6 ed 44				neg 
0fb8 32 5f ee				ld (input_cur_onoff),a 
0fbb			 
0fbb			 
0fbb					; reset on change of state 
0fbb 3e 09				ld a, CUR_BLINK_RATE 
0fbd 32 60 ee				ld (input_cur_flash), a 
0fc0			 
0fc0			.nochgstate: 
0fc0					 
0fc0					 
0fc0			 
0fc0					; display cursor  
0fc0			 
0fc0			;		ld hl, (input_start) 
0fc0			;		ld a, (input_cursor) 
0fc0			;		call addatohl 
0fc0			 
0fc0					; get char under cursor and replace with cursor 
0fc0 2a 69 ee		ld hl, (input_ptr) 
0fc3			;		ld a, (hl) 
0fc3			;		ld (input_under_cursor),a 
0fc3			;		ld a, '_' 
0fc3			;		ld (hl), a 
0fc3			 
0fc3					; display string 
0fc3			 
0fc3 ed 5b 67 ee			ld de, (input_start) 
0fc7 3a 64 ee				ld a, (input_at_pos) 
0fca cd cc 0b				call str_at_display 
0fcd			;	        call update_display 
0fcd			 
0fcd					; find place to put the cursor 
0fcd			;		add h 
0fcd			;		ld l, display_row_1 
0fcd			;		sub l 
0fcd			; (input_at_pos) 
0fcd					;ld c, a 
0fcd			;		ld a, (input_cursor) 
0fcd			;		ld l, (input_at_pos) 
0fcd			;		;ld b, h 
0fcd			;		add l 
0fcd			;		ld (input_at_cursor),a 
0fcd					;ld l,h 
0fcd			 
0fcd			;		ld h, 0 
0fcd			;		ld l,(input_at_pos) 
0fcd			;		ld a, (input_cursor) 
0fcd			;		call addatohl 
0fcd			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0fcd			;		call subafromhl 
0fcd			;		ld a,l 
0fcd			;		ld (input_at_cursor), a 
0fcd			 
0fcd				if DEBUG_INPUT 
0fcd					ld a, (hardware_diag) 
0fcd					cp 0 
0fcd					jr z, .skip_input_diag 
0fcd			 
0fcd					ld a,(input_at_pos) 
0fcd					ld hl, LFSRSeed 
0fcd					call hexout 
0fcd					ld a, (input_cursor) 
0fcd					ld hl, LFSRSeed+2 
0fcd					call hexout 
0fcd					ld a,(input_at_cursor) 
0fcd					ld hl, LFSRSeed+4 
0fcd					call hexout 
0fcd			 
0fcd					ld a,(input_cur_onoff) 
0fcd					ld hl, LFSRSeed+6 
0fcd					call hexout 
0fcd			 
0fcd					ld a,(input_cur_flash) 
0fcd					ld hl, LFSRSeed+8 
0fcd					call hexout 
0fcd			 
0fcd					ld a,(input_len) 
0fcd					ld hl, LFSRSeed+10 
0fcd					call hexout 
0fcd					ld hl, LFSRSeed+12 
0fcd					ld a, 0 
0fcd					ld (hl),a 
0fcd					ld a, display_row_4 
0fcd					ld de, LFSRSeed 
0fcd					call str_at_display 
0fcd					.skip_input_diag: 
0fcd				endif 
0fcd			 
0fcd					; decide on if we are showing the cursor this time round 
0fcd			 
0fcd 3a 5f ee				ld a, (input_cur_onoff) 
0fd0 fe ff				cp 255 
0fd2 28 13				jr z, .skipcur 
0fd4			 
0fd4			 
0fd4 3a 62 ee				ld a,(input_at_cursor) 
0fd7 11 c1 eb				ld de, cursor_shape 
0fda cd cc 0b				call str_at_display 
0fdd			 
0fdd					; save length of current input string 
0fdd 2a 67 ee				ld hl, (input_start) 
0fe0 cd a3 13				call strlenz 
0fe3 7d					ld a,l 
0fe4 32 5a ee				ld (input_len),a 
0fe7			 
0fe7			.skipcur: 
0fe7			 
0fe7 cd dc 0b			        call update_display 
0fea					 
0fea			 
0fea			 
0fea					; wait 
0fea				 
0fea					; TODO loop without wait to flash the cursor and char under cursor	 
0fea cd 8d 67				call cin    ; _wait 
0fed			 
0fed fe 00				cp 0 
0fef ca a3 0f				jp z, .is1 
0ff2			 
0ff2					; get ptr to char to input into 
0ff2			 
0ff2 4f					ld c,a 
0ff3 2a 67 ee				ld hl, (input_start) 
0ff6 3a 55 ee				ld a, (input_cursor) 
0ff9 cd e6 0d				call addatohl 
0ffc 22 69 ee				ld (input_ptr), hl 
0fff 79					ld a,c 
1000			 
1000					; replace char under cursor 
1000			 
1000			;		ld hl, (input_ptr) 
1000			;		ld a, (input_under_cursor) 	; get what is under the cursor 
1000			;		ld (hl), a 
1000			 
1000			;	if DEBUG_INPUT 
1000			;		push af 
1000			;		ld a, 'i' 
1000			;		ld (debug_mark),a 
1000			;		pop af 
1000			;		CALLMONITOR 
1000			;	endif 
1000 fe 0e				cp KEY_HOME 
1002 20 0e				jr nz, .iske 
1004			 
1004 3a 64 ee				ld a, (input_at_pos) 
1007 32 62 ee				ld (input_at_cursor),a 
100a 3e 00				ld a, 0 
100c 32 55 ee				ld (input_cursor), a 
100f c3 a3 0f				jp .is1 
1012					 
1012 fe 0f		.iske:		cp KEY_END 
1014 20 03				jr nz, .isknw 
1016 c3 a3 0f				jp .is1 
1019			 
1019 fe 06		.isknw:		cp KEY_NEXTWORD 
101b 20 1b				jr nz, .iskpw 
101d			 
101d 2a 69 ee		.isknwm:	ld hl, (input_ptr) 
1020 7e					ld a,(hl)	 
1021 fe 00				cp 0 
1023 ca a3 0f				jp z, .is1    ; end of string 
1026 fe 20				cp ' ' 
1028 ca a3 0f				jp z, .is1    ; end of word 
102b 23					inc hl 
102c 22 69 ee				ld (input_ptr), hl 
102f 3a 62 ee				ld a, (input_at_cursor) 
1032 3c					inc a 
1033 32 62 ee				ld (input_at_cursor), a 
1036 18 e5				jr .isknwm 
1038			 
1038 fe 07		.iskpw:		cp KEY_PREVWORD 
103a 20 1b				jr nz, .iskl 
103c			.iskpwm:	 
103c 2a 69 ee				ld hl, (input_ptr) 
103f 7e					ld a,(hl)	 
1040 fe 00				cp 0  
1042 ca a3 0f				jp z, .is1    ; end of string 
1045 fe 20				cp ' ' 
1047 ca a3 0f				jp z, .is1    ; end of word 
104a 2b					dec hl 
104b 22 69 ee				ld (input_ptr), hl 
104e 3a 62 ee				ld a, (input_at_cursor) 
1051 3d					dec a 
1052 32 62 ee				ld (input_at_cursor), a 
1055 18 e5				jr .iskpwm 
1057			 
1057			 
1057 fe 0b		.iskl:		cp KEY_LEFT 
1059 20 27				jr nz, .isk1 
105b			 
105b 3a 55 ee				ld a, (input_cursor) 
105e			 
105e fe 00				cp 0 
1060 ca a3 0f				jp z, .is1 		; at start of line to ignore  
1063			 
1063 3d					dec  a 		; TODO check underflow 
1064 32 55 ee				ld (input_cursor), a 
1067			 
1067 2a 69 ee				ld hl, (input_ptr) 
106a 2b					dec hl 
106b 22 69 ee				ld (input_ptr), hl 
106e					 
106e 3a 62 ee				ld a, (input_at_cursor) 
1071 3d					dec a 
1072 32 62 ee				ld (input_at_cursor), a 
1075			 
1075 3e 01				ld a, 1		; show cursor moving 
1077 32 5f ee				ld (input_cur_onoff),a 
107a 3e 09				ld a, CUR_BLINK_RATE 
107c 32 60 ee				ld (input_cur_flash), a 
107f			 
107f c3 a3 0f				jp .is1 
1082			 
1082 fe 0c		.isk1:		cp KEY_RIGHT 
1084 20 2a				jr nz, .isk2 
1086			 
1086 3a 5a ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
1089 5f					ld e,a 
108a 3a 55 ee				ld a, (input_cursor) 
108d bb					cp e 
108e ca a3 0f				jp z, .is1		; at the end of string so dont go right 
1091			 
1091 3c					inc  a 		; TODO check overflow 
1092 32 55 ee				ld (input_cursor), a 
1095			 
1095 3a 62 ee				ld a, (input_at_cursor) 
1098 3c					inc a 
1099 32 62 ee				ld (input_at_cursor), a 
109c			 
109c 2a 69 ee				ld hl, (input_ptr) 
109f 23					inc hl 
10a0 22 69 ee				ld (input_ptr), hl 
10a3			 
10a3 3e 01				ld a, 1		; show cursor moving 
10a5 32 5f ee				ld (input_cur_onoff),a 
10a8 3e 09				ld a, CUR_BLINK_RATE 
10aa 32 60 ee				ld (input_cur_flash), a 
10ad			 
10ad c3 a3 0f				jp .is1 
10b0			 
10b0 fe 05		.isk2:		cp KEY_UP 
10b2			 
10b2 20 26				jr nz, .isk3 
10b4			 
10b4					; swap last command with the current on 
10b4			 
10b4					; move cursor to start of string 
10b4 2a 67 ee				ld hl, (input_start) 
10b7 22 69 ee				ld (input_ptr), hl 
10ba			 
10ba 3a 64 ee				ld a, (input_at_pos) 
10bd 32 62 ee				ld (input_at_cursor), a 
10c0			 
10c0 3e 00				ld a, 0 
10c2 32 55 ee				ld (input_cursor), a 
10c5					 
10c5					; swap input and last command buffers 
10c5			 
10c5 21 e8 e5				ld hl, os_cli_cmd 
10c8 11 e7 e6				ld de, os_last_cmd 
10cb 06 ff				ld b, 255 
10cd 7e			.swap1:		ld a, (hl) 
10ce 4f					ld c,a 
10cf 1a					ld a, (de) 
10d0 77					ld (hl), a 
10d1 79					ld a,c 
10d2 12					ld (de),a 
10d3 23					inc hl 
10d4 13					inc de 
10d5 10 f6				djnz .swap1 
10d7			 
10d7			 
10d7			 
10d7			 
10d7			 
10d7 c3 a3 0f				jp .is1 
10da			 
10da fe 08		.isk3:		cp KEY_BS 
10dc 20 3c				jr nz, .isk4 
10de			 
10de 3a 55 ee				ld a, (input_cursor) 
10e1			 
10e1 fe 00				cp 0 
10e3 ca a3 0f				jp z, .is1 		; at start of line to ignore  
10e6			 
10e6 3d					dec  a 		; TODO check underflow 
10e7 32 55 ee				ld (input_cursor), a 
10ea			 
10ea					; hl is source 
10ea					; de needs to be source - 1 
10ea			 
10ea			;		ld a, 0 
10ea			;		dec hl 
10ea			;		ld (hl), a 
10ea			 
10ea 2a 69 ee				ld hl, (input_ptr) 
10ed 2b					dec hl 
10ee 22 69 ee				ld (input_ptr), hl 
10f1			 
10f1					; shift all data 
10f1			 
10f1 e5					push hl 
10f2 23					inc hl 
10f3 d1					pop de 
10f4 3a 5a ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
10f7 4f					ld c,a 
10f8 06 00				ld b,0 
10fa ed b0				ldir  
10fc			 
10fc			 
10fc			 
10fc			 
10fc 3a 62 ee				ld a, (input_at_cursor) 
10ff 3d					dec a 
1100 32 62 ee				ld (input_at_cursor), a 
1103			 
1103			 
1103 3e 01				ld a, 1		; show cursor moving 
1105 32 5f ee				ld (input_cur_onoff),a 
1108 3e 09				ld a, CUR_BLINK_RATE 
110a 32 60 ee				ld (input_cur_flash), a 
110d			 
110d					; remove char 
110d 3a 62 ee				ld a, (input_at_cursor) 
1110 3c					inc a 
1111 11 9b 11				ld de,.iblank 
1114 cd cc 0b				call str_at_display 
1117			 
1117 c3 a3 0f				jp .is1 
111a			 
111a fe 0d		.isk4:		cp KEY_CR 
111c 28 6c				jr z, .endinput 
111e			 
111e					; else add the key press to the end 
111e			 
111e 4f					ld c, a			; save key pressed 
111f			 
111f 7e					ld a,(hl)		; get what is currently under char 
1120			 
1120 fe 00				cp 0			; we are at the end of the string 
1122 20 2f				jr nz, .onchar 
1124					 
1124					; add a char to the end of the string 
1124				 
1124 71					ld (hl),c 
1125 23					inc hl 
1126			;		ld a,' ' 
1126			;		ld (hl),a 
1126			;		inc hl 
1126 3e 00				ld a,0 
1128 77					ld (hl),a 
1129 2b					dec hl 
112a			 
112a 3a 55 ee				ld a, (input_cursor) 
112d 3c					inc a				; TODO check max string length and scroll  
112e 32 55 ee				ld (input_cursor), a		; inc cursor pos 
1131							 
1131 3a 62 ee				ld a, (input_at_cursor) 
1134 3c					inc a 
1135 32 62 ee				ld (input_at_cursor), a 
1138			 
1138 2a 69 ee				ld hl, (input_ptr) 
113b 23					inc hl 
113c 22 69 ee				ld (input_ptr), hl 
113f			 
113f 2a 69 ee				ld hl, (input_ptr) 
1142 23					inc hl 
1143 22 69 ee				ld (input_ptr), hl 
1146			;	if DEBUG_INPUT 
1146			;		push af 
1146			;		ld a, '+' 
1146			;		ld (debug_mark),a 
1146			;		pop af 
1146			;		CALLMONITOR 
1146			;	endif 
1146 3e 01				ld a, 1		; show cursor moving 
1148 32 5f ee				ld (input_cur_onoff),a 
114b 3e 09				ld a, CUR_BLINK_RATE 
114d 32 60 ee				ld (input_cur_flash), a 
1150 c3 a3 0f				jp .is1 
1153					 
1153			 
1153			 
1153					; if on a char then insert 
1153			.onchar: 
1153			 
1153					; TODO over flow check: make sure insert does not blow out buffer 
1153			 
1153					; need to do some maths to use lddr 
1153			 
1153 e5					push hl   ; save char pos 
1154 c5					push bc 
1155			 
1155 2a 67 ee				ld hl, (input_start) 
1158 3a 5a ee				ld a, (input_len) 
115b cd e6 0d				call addatohl  		; end of string 
115e 23					inc hl 
115f 23					inc hl		; past zero term 
1160 e5					push hl 
1161 23					inc hl 
1162 e5					push hl  
1163			 
1163								; start and end of lddr set, now how much to move? 
1163			 
1163							 
1163 3a 55 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
1166 47					ld b,a 
1167 3a 5a ee				ld a,(input_len) 
116a 5f					ld e,a 
116b 90					sub b 
116c 3c					inc a		;?? 
116d 3c					inc a		;?? 
116e 3c					inc a		;?? 
116f			 
116f 06 00				ld b,0 
1171 4f					ld c,a 
1172			 
1172				if DEBUG_INPUT 
1172					push af 
1172					ld a, 'i' 
1172					ld (debug_mark),a 
1172					pop af 
1172			;		CALLMONITOR 
1172				endif 
1172 d1					pop de 
1173 e1					pop hl 
1174				if DEBUG_INPUT 
1174					push af 
1174					ld a, 'I' 
1174					ld (debug_mark),a 
1174					pop af 
1174			;		CALLMONITOR 
1174				endif 
1174 ed b8				lddr 
1176				 
1176			 
1176			 
1176					; TODO have a key for insert/overwrite mode???? 
1176 c1					pop bc 
1177 e1					pop hl 
1178 71					ld (hl), c		; otherwise overwrite current char 
1179					 
1179			 
1179			 
1179			 
1179 3a 55 ee				ld a, (input_cursor) 
117c 3c					inc  a 		; TODO check overflow 
117d 32 55 ee				ld (input_cursor), a 
1180			 
1180 3a 62 ee				ld a, (input_at_cursor) 
1183 3c					inc a 
1184 32 62 ee				ld (input_at_cursor), a 
1187			 
1187 c3 a3 0f				jp .is1 
118a			 
118a			.endinput:	; TODO look for end of string 
118a			 
118a					; add trailing space for end of token 
118a			 
118a 2a 67 ee				ld hl, (input_start) 
118d 3a 5a ee				ld a,(input_len) 
1190 cd e6 0d				call addatohl 
1193 3e 20				ld a, ' ' 
1195 77					ld (hl),a 
1196					; TODO eof of parse marker 
1196			 
1196 23					inc hl 
1197 3e 00				ld a, 0 
1199 77					ld (hl),a 
119a			 
119a			 
119a c9					ret 
119b			 
119b .. 00		.iblank: db " ",0 
119d			 
119d			 
119d 32 64 ee		input_str_prev:	ld (input_at_pos), a 
11a0 22 67 ee				ld (input_start), hl 
11a3 3e 01				ld a,1			; add cursor 
11a5 77					ld (hl),a 
11a6 23					inc hl 
11a7 3e 00				ld a,0 
11a9 77					ld (hl),a 
11aa 22 69 ee				ld (input_ptr), hl 
11ad 7a					ld a,d 
11ae 32 66 ee				ld (input_size), a 
11b1 3e 00				ld a,0 
11b3 32 55 ee				ld (input_cursor),a 
11b6			.instr1:	 
11b6			 
11b6					; TODO do block cursor 
11b6					; TODO switch cursor depending on the modifer key 
11b6			 
11b6					; update cursor shape change on key hold 
11b6			 
11b6 2a 69 ee				ld hl, (input_ptr) 
11b9 2b					dec hl 
11ba 3a c1 eb				ld a,(cursor_shape) 
11bd 77					ld (hl), a 
11be			 
11be					; display entered text 
11be 3a 64 ee				ld a,(input_at_pos) 
11c1 cd a2 66		            	CALL fLCD_Pos       ;Position cursor to location in A 
11c4 ed 5b 67 ee	            	LD   de, (input_start) 
11c8 cd 97 66		            	CALL fLCD_Str       ;Display string pointed to by DE 
11cb			 
11cb cd 8d 67				call cin 
11ce fe 00				cp 0 
11d0 28 e4				jr z, .instr1 
11d2			 
11d2					; proecess keyboard controls first 
11d2			 
11d2 2a 69 ee				ld hl,(input_ptr) 
11d5			 
11d5 fe 0d				cp KEY_CR	 ; pressing enter ends input 
11d7 28 5a				jr z, .instrcr 
11d9			 
11d9 fe 08				cp KEY_BS 	; back space 
11db 20 0f				jr nz, .instr2 
11dd					; process back space 
11dd			 
11dd					; TODO stop back space if at start of string 
11dd 2b					dec hl 
11de 2b					dec hl ; to over write cursor 
11df 3a c1 eb				ld a,(cursor_shape) 
11e2					;ld a,0 
11e2 77					ld (hl),a 
11e3 23					inc hl 
11e4 3e 20				ld a," " 
11e6 77					ld (hl),a 
11e7 22 69 ee				ld (input_ptr),hl 
11ea					 
11ea			 
11ea 18 ca				jr .instr1 
11ec			 
11ec fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
11ee 20 06				jr nz, .instr3 
11f0 2b					dec hl 
11f1 22 69 ee				ld (input_ptr),hl 
11f4 18 c0				jr .instr1 
11f6				 
11f6 fe 0c		.instr3:	cp KEY_RIGHT      ; cursor right 
11f8 20 06				jr nz, .instr4 
11fa 23					inc hl 
11fb 22 69 ee				ld (input_ptr),hl 
11fe 18 b6				jr .instr1 
1200			 
1200 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
1202 20 06				jr nz, .instr5 
1204 2b					dec hl 
1205 22 69 ee				ld (input_ptr),hl 
1208 18 ac				jr .instr1 
120a			 
120a fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
120c 20 06				jr nz, .instr6 
120e 2b					dec hl 
120f 22 69 ee				ld (input_ptr),hl 
1212 18 a2				jr .instr1 
1214 fe 05		.instr6:        cp KEY_UP      ; recall last command 
1216 20 0b				jr nz, .instrnew 
1218			 
1218 21 c1 e2			ld hl, scratch 
121b 11 e7 e6			ld de, os_last_cmd 
121e cd 3c 12			call strcpy 
1221 18 93				jr .instr1 
1223			 
1223			 
1223			.instrnew:	; no special key pressed to see if we have room to store it 
1223			 
1223					; TODO do string size test 
1223			 
1223 2b					dec hl ; to over write cursor 
1224 77					ld (hl),a 
1225 23					inc hl 
1226 3a c1 eb				ld a,(cursor_shape) 
1229 77					ld (hl),a 
122a 23					inc hl 
122b 3e 00				ld a,0 
122d 77					ld (hl),a 
122e			 
122e 22 69 ee				ld (input_ptr),hl 
1231					 
1231 18 83				jr .instr1 
1233 2b			.instrcr:	dec hl		; remove cursor 
1234 3e 20				ld a,' '	; TODO add a trailing space for safety 
1236 77					ld (hl),a 
1237 23					inc hl 
1238 3e 00				ld a,0 
123a 77					ld (hl),a 
123b			 
123b			 
123b					; if at end of line scroll up    
123b					; TODO detecting only end of line 4 for scroll up  
123b			 
123b					;ld   
123b			 
123b c9					ret 
123c			 
123c			 
123c			; strcpy hl = dest, de source 
123c			 
123c 1a			strcpy:   LD   A, (DE)        ;Get character from string 
123d b7			            OR   A              ;Null terminator? 
123e c8			            RET  Z              ;Yes, so finished 
123f 1a					ld a,(de) 
1240 77					ld (hl),a 
1241 13			            INC  DE             ;Point to next character 
1242 23					inc hl 
1243 18 f7		            JR   strcpy       ;Repeat 
1245 c9					ret 
1246			 
1246			 
1246			; TODO string_at  
1246			; pass string which starts with lcd offset address and then null term string 
1246			 
1246			; TODO string to dec 
1246			; TODO string to hex 
1246			; TODO byte to string hex 
1246			; TODO byte to string dec 
1246			 
1246			 
1246			 
1246			; from z80uartmonitor 
1246			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1246			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
1246			; pass hl for where to put the text 
1246			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1246 c5			hexout:	PUSH BC 
1247 f5					PUSH AF 
1248 47					LD B, A 
1249					; Upper nybble 
1249 cb 3f				SRL A 
124b cb 3f				SRL A 
124d cb 3f				SRL A 
124f cb 3f				SRL A 
1251 cd 61 12				CALL tohex 
1254 77					ld (hl),a 
1255 23					inc hl	 
1256					 
1256					; Lower nybble 
1256 78					LD A, B 
1257 e6 0f				AND 0FH 
1259 cd 61 12				CALL tohex 
125c 77					ld (hl),a 
125d 23					inc hl	 
125e					 
125e f1					POP AF 
125f c1					POP BC 
1260 c9					RET 
1261					 
1261			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1261			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1261			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1261			tohex: 
1261 e5					PUSH HL 
1262 d5					PUSH DE 
1263 16 00				LD D, 0 
1265 5f					LD E, A 
1266 21 6e 12				LD HL, .DATA 
1269 19					ADD HL, DE 
126a 7e					LD A, (HL) 
126b d1					POP DE 
126c e1					POP HL 
126d c9					RET 
126e			 
126e			.DATA: 
126e 30					DEFB	30h	; 0 
126f 31					DEFB	31h	; 1 
1270 32					DEFB	32h	; 2 
1271 33					DEFB	33h	; 3 
1272 34					DEFB	34h	; 4 
1273 35					DEFB	35h	; 5 
1274 36					DEFB	36h	; 6 
1275 37					DEFB	37h	; 7 
1276 38					DEFB	38h	; 8 
1277 39					DEFB	39h	; 9 
1278 41					DEFB	41h	; A 
1279 42					DEFB	42h	; B 
127a 43					DEFB	43h	; C 
127b 44					DEFB	44h	; D 
127c 45					DEFB	45h	; E 
127d 46					DEFB	46h	; F 
127e			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
127e			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
127e			;;    subtract $30, if result > 9 then subtract $7 more 
127e			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
127e			atohex: 
127e d6 30				SUB $30 
1280 fe 0a				CP 10 
1282 f8					RET M		; If result negative it was 0-9 so we're done 
1283 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1285 c9					RET		 
1286			 
1286			 
1286			 
1286			 
1286			; Get 2 ASCII characters as hex byte from pointer in hl 
1286			 
1286			BYTERD: 
1286 16 00			LD	D,00h		;Set up 
1288 cd 90 12			CALL	HEXCON		;Get byte and convert to hex 
128b 87				ADD	A,A		;First nibble so 
128c 87				ADD	A,A		;multiply by 16 
128d 87				ADD	A,A		; 
128e 87				ADD	A,A		; 
128f 57				LD	D,A		;Save hi nibble in D 
1290			HEXCON: 
1290 7e				ld a, (hl)		;Get next chr 
1291 23				inc hl 
1292 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1294 fe 0a			CP	00Ah		;Is it 0-9 ? 
1296 38 02			JR	C,NALPHA	;If so miss next bit 
1298 d6 07			SUB	007h		;Else convert alpha 
129a			NALPHA: 
129a b2				OR	D		;Add hi nibble back 
129b c9				RET			; 
129c			 
129c			 
129c			; 
129c			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
129c			; Since the routines get_byte and therefore get_nibble are called, only valid 
129c			; characters (0-9a-f) are accepted. 
129c			; 
129c			;get_word        push    af 
129c			;                call    get_byte        ; Get the upper byte 
129c			;                ld      h, a 
129c			;                call    get_byte        ; Get the lower byte 
129c			;                ld      l, a 
129c			;                pop     af 
129c			;                ret 
129c			; 
129c			; Get a byte in hexadecimal notation. The result is returned in A. Since 
129c			; the routine get_nibble is used only valid characters are accepted - the  
129c			; input routine only accepts characters 0-9a-f. 
129c			; 
129c c5			get_byte:        push    bc              ; Save contents of B (and C) 
129d 7e					ld a,(hl) 
129e 23					inc hl 
129f cd c4 12		                call    nibble2val      ; Get upper nibble 
12a2 cb 07		                rlc     a 
12a4 cb 07		                rlc     a 
12a6 cb 07		                rlc     a 
12a8 cb 07		                rlc     a 
12aa 47			                ld      b, a            ; Save upper four bits 
12ab 7e					ld a,(hl) 
12ac cd c4 12		                call    nibble2val      ; Get lower nibble 
12af b0			                or      b               ; Combine both nibbles 
12b0 c1			                pop     bc              ; Restore B (and C) 
12b1 c9			                ret 
12b2			; 
12b2			; Get a hexadecimal digit from the serial line. This routine blocks until 
12b2			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
12b2			; to the serial line interface. The lower 4 bits of A contain the value of  
12b2			; that particular digit. 
12b2			; 
12b2			;get_nibble      ld a,(hl)           ; Read a character 
12b2			;                call    to_upper        ; Convert to upper case 
12b2			;                call    is_hex          ; Was it a hex digit? 
12b2			;                jr      nc, get_nibble  ; No, get another character 
12b2			 ;               call    nibble2val      ; Convert nibble to value 
12b2			 ;               call    print_nibble 
12b2			 ;               ret 
12b2			; 
12b2			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
12b2			; A valid hexadecimal digit is denoted by a set C flag. 
12b2			; 
12b2			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
12b2			;                ret     nc              ; Yes 
12b2			;                cp      '0'             ; Less than '0'? 
12b2			;                jr      nc, is_hex_1    ; No, continue 
12b2			;                ccf                     ; Complement carry (i.e. clear it) 
12b2			;                ret 
12b2			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
12b2			;                ret     c               ; Yes 
12b2			;                cp      'A'             ; Less than 'A'? 
12b2			;                jr      nc, is_hex_2    ; No, continue 
12b2			;                ccf                     ; Yes - clear carry and return 
12b2			;                ret 
12b2			;is_hex_2        scf                     ; Set carry 
12b2			;                ret 
12b2			; 
12b2			; Convert a single character contained in A to upper case: 
12b2			; 
12b2 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
12b4 d8			                ret     c 
12b5 fe 7b		                cp      'z' + 1         ; > 'z'? 
12b7 d0			                ret     nc              ; Nothing to do, either 
12b8 e6 5f		                and     $5f             ; Convert to upper case 
12ba c9			                ret 
12bb			 
12bb			 
12bb			to_lower: 
12bb			 
12bb			   ; if char is in [A-Z] make it lower case 
12bb			 
12bb			   ; enter : a = char 
12bb			   ; exit  : a = lower case char 
12bb			   ; uses  : af 
12bb			 
12bb fe 41		   cp 'A' 
12bd d8			   ret c 
12be			    
12be fe 5b		   cp 'Z'+1 
12c0 d0			   ret nc 
12c1			    
12c1 f6 20		   or $20 
12c3 c9			   ret 
12c4			 
12c4			; 
12c4			; Expects a hexadecimal digit (upper case!) in A and returns the 
12c4			; corresponding value in A. 
12c4			; 
12c4 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
12c6 38 02		                jr      c, nibble2val_1 ; Yes 
12c8 d6 07		                sub     7               ; Adjust for A-F 
12ca d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
12cc e6 0f		                and     $f              ; Only return lower 4 bits 
12ce c9			                ret 
12cf			; 
12cf			; Print_nibble prints a single hex nibble which is contained in the lower  
12cf			; four bits of A: 
12cf			; 
12cf			;print_nibble    push    af              ; We won't destroy the contents of A 
12cf			;                and     $f              ; Just in case... 
12cf			;                add     a, '0'             ; If we have a digit we are done here. 
12cf			;                cp      '9' + 1         ; Is the result > 9? 
12cf			;                jr      c, print_nibble_1 
12cf			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
12cf			;print_nibble_1  call    putc            ; Print the nibble and 
12cf			;                pop     af              ; restore the original value of A 
12cf			;                ret 
12cf			;; 
12cf			;; Send a CR/LF pair: 
12cf			; 
12cf			;crlf            push    af 
12cf			;                ld      a, cr 
12cf			;                call    putc 
12cf			;                ld      a, lf 
12cf			;                call    putc 
12cf			;                pop     af 
12cf			;                ret 
12cf			; 
12cf			; Print_word prints the four hex digits of a word to the serial line. The  
12cf			; word is expected to be in HL. 
12cf			; 
12cf			;print_word      push    hl 
12cf			;                push    af 
12cf			;                ld      a, h 
12cf			;                call    print_byte 
12cf			;                ld      a, l 
12cf			;                call    print_byte 
12cf			;                pop     af 
12cf			;                pop     hl 
12cf			;                ret 
12cf			; 
12cf			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
12cf			; The byte to be printed is expected to be in A. 
12cf			; 
12cf			;print_byte      push    af              ; Save the contents of the registers 
12cf			;                push    bc 
12cf			;                ld      b, a 
12cf			;                rrca 
12cf			;                rrca 
12cf			;                rrca 
12cf			;                rrca 
12cf			;                call    print_nibble    ; Print high nibble 
12cf			;                ld      a, b 
12cf			;                call    print_nibble    ; Print low nibble 
12cf			;                pop     bc              ; Restore original register contents 
12cf			;                pop     af 
12cf			;                ret 
12cf			 
12cf			 
12cf			 
12cf			 
12cf			 
12cf			fourehexhl:  
12cf 7e				ld a,(hl) 
12d0 cd 7e 12			call atohex 
12d3 cb 3f				SRL A 
12d5 cb 3f				SRL A 
12d7 cb 3f				SRL A 
12d9 cb 3f				SRL A 
12db 47				ld b, a 
12dc 23				inc hl 
12dd 7e				ld a,(hl) 
12de 23				inc hl 
12df cd 7e 12			call atohex 
12e2 80				add b 
12e3 57				ld d,a 
12e4 7e				ld a,(hl) 
12e5 cd 7e 12			call atohex 
12e8 cb 3f				SRL A 
12ea cb 3f				SRL A 
12ec cb 3f				SRL A 
12ee cb 3f				SRL A 
12f0 47				ld b, a 
12f1 23				inc hl 
12f2 7e				ld a,(hl) 
12f3 23				inc hl 
12f4 cd 7e 12			call atohex 
12f7 80				add b 
12f8 5f				ld e, a 
12f9 d5				push de 
12fa e1				pop hl 
12fb c9				ret 
12fc			 
12fc			; pass hl. returns z set if the byte at hl is a digit 
12fc			;isdigithl:  
12fc			;	push bc 
12fc			;	ld a,(hl) 
12fc			;	cp ':' 
12fc			;	jr nc, .isdf 		; > 
12fc			;	cp '0' 
12fc			;	jr c, .isdf		; < 
12fc			; 
12fc			;	; TODO find a better way to set z 
12fc			; 
12fc			;	ld b,a 
12fc			;	cp b 
12fc			;	pop bc 
12fc			;	ret 
12fc			; 
12fc			;.isdf:	; not digit so clear z 
12fc			; 
12fc			;	; TODO find a better way to unset z 
12fc			; 
12fc			;	ld b,a 
12fc			;	inc b 
12fc			;	cp b 
12fc			; 
12fc			;	pop bc 
12fc			;	ret 
12fc				 
12fc				 
12fc			 
12fc			 
12fc			; pass hl as the four byte address to load 
12fc			 
12fc			get_word_hl:  
12fc e5				push hl 
12fd cd 9c 12			call get_byte 
1300				 
1300 47				ld b, a 
1301			 
1301 e1				pop hl 
1302 23				inc hl 
1303 23				inc hl 
1304			 
1304			; TODO not able to handle a-f  
1304 7e				ld a,(hl) 
1305			;	;cp ':' 
1305			;	cp 'g' 
1305			;	jr nc, .single_byte_hl 		; > 
1305			;	cp 'G' 
1305			;	jr nc, .single_byte_hl 		; > 
1305			;	cp '0' 
1305			;	jr c, .single_byte_hl		; < 
1305			 
1305				;call isdigithl 
1305 fe 00			cp 0 
1307 28 06			jr z, .single_byte_hl 
1309			 
1309			.getwhln:   ; hex word so get next byte 
1309			 
1309 cd 9c 12			call get_byte 
130c 6f				ld l, a 
130d 60				ld h,b 
130e c9				ret 
130f 68			.single_byte_hl:   ld l,b 
1310 26 00				ld h,0 
1312 c9					ret 
1313			 
1313			 
1313			 
1313			 
1313 21 a0 1a			ld hl,asc+1 
1316			;	ld a, (hl) 
1316			;	call nibble2val 
1316 cd 9c 12			call get_byte 
1319			 
1319			;	call fourehexhl 
1319 32 f5 e2			ld (scratch+52),a 
131c				 
131c 21 f3 e2			ld hl,scratch+50 
131f 22 e4 e5			ld (os_cur_ptr),hl 
1322			 
1322 c9				ret 
1323			 
1323			 
1323			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
1323			 
1323			; Decimal Unsigned Version 
1323			 
1323			;Number in a to decimal ASCII 
1323			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
1323			;Example: display a=56 as "056" 
1323			;input: a = number 
1323			;Output: a=0,value of a in the screen 
1323			;destroys af,bc (don't know about hl and de) 
1323			DispAToASCII: 
1323 0e 9c			ld	c,-100 
1325 cd 2f 13			call	.Na1 
1328 0e f6			ld	c,-10 
132a cd 2f 13			call	.Na1 
132d 0e ff			ld	c,-1 
132f 06 2f		.Na1:	ld	b,'0'-1 
1331 04			.Na2:	inc	b 
1332 81				add	a,c 
1333 38 fc			jr	c,.Na2 
1335 91				sub	c		;works as add 100/10/1 
1336 f5				push af		;safer than ld c,a 
1337 78				ld	a,b		;char is in b 
1338			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
1338 f1				pop af		;safer than ld a,c 
1339 c9				ret 
133a			 
133a			; Decimal Signed Version 
133a			 
133a			; DispA 
133a			; -------------------------------------------------------------- 
133a			; Converts a signed integer value to a zero-terminated ASCII 
133a			; string representative of that value (using radix 10). 
133a			; -------------------------------------------------------------- 
133a			; INPUTS: 
133a			;     HL     Value to convert (two's complement integer). 
133a			;     DE     Base address of string destination. (pointer). 
133a			; -------------------------------------------------------------- 
133a			; OUTPUTS: 
133a			;     None 
133a			; -------------------------------------------------------------- 
133a			; REGISTERS/MEMORY DESTROYED 
133a			; AF HL 
133a			; -------------------------------------------------------------- 
133a			 
133a			;DispHLToASCII: 
133a			;   push    de 
133a			;   push    bc 
133a			; 
133a			;; Detect sign of HL. 
133a			;    bit    7, h 
133a			;    jr     z, ._DoConvert 
133a			; 
133a			;; HL is negative. Output '-' to string and negate HL. 
133a			;    ld     a, '-' 
133a			;    ld     (de), a 
133a			;    inc    de 
133a			; 
133a			;; Negate HL (using two's complement) 
133a			;    xor    a 
133a			;    sub    l 
133a			;    ld     l, a 
133a			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
133a			;    sbc    a, h 
133a			;    ld     h, a 
133a			; 
133a			;; Convert HL to digit characters 
133a			;._DoConvert: 
133a			;    ld     b, 0     ; B will count character length of number 
133a			;-   ld     a, 10 
133a			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
133a			;    push   af 
133a			;    inc    b 
133a			;    ld     a, h 
133a			;    or     l 
133a			;    jr     nz, - 
133a			; 
133a			;; Retrieve digits from stack 
133a			;-   pop    af 
133a			;    or     $30 
133a			;    ld     (de), a 
133a			;    inc    de 
133a			;    djnz   - 
133a			; 
133a			;; Terminate string with NULL 
133a			;    xor    a 
133a			;    ld     (de), a 
133a			; 
133a			;    pop    bc 
133a			;    pop    de 
133a			;    ret 
133a			 
133a			;Comments 
133a			; 
133a			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
133a			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
133a			;    Note that the output string will not be fixed-width. 
133a			; 
133a			;Example Usage 
133a			; 
133a			;    ld    hl, -1004 
133a			;    ld    de, OP1 
133a			;    call  DispA 
133a			;    ld    hl, OP1 
133a			;    syscall  PutS 
133a			 
133a			 
133a			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
133a			 
133a			 
133a			;Converts an ASCII string to an unsigned 16-bit integer 
133a			;Quits when it reaches a non-decimal digit 
133a			 
133a			string_to_uint16: 
133a			atoui_16: 
133a			;Input: 
133a			;     DE points to the string 
133a			;Outputs: 
133a			;     HL is the result 
133a			;     A is the 8-bit value of the number 
133a			;     DE points to the byte after the number 
133a			;Destroys: 
133a			;     BC 
133a			;       if the string is non-empty, BC is HL/10 
133a			;Size:  24 bytes 
133a			;Speed: 42+d(104+{0,9}) 
133a			;       d is the number of digits in the number 
133a			;       max is 640 cycles for a 5 digit number 
133a			;Assuming no leading zeros: 
133a			;1 digit:  146cc 
133a			;2 digit:  250cc 
133a			;3 digit:  354cc or 363cc (avg: 354.126cc) 
133a			;4 digit:  458cc or 467cc (avg: 458.27cc) 
133a			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
133a			;avg: 544.81158447265625cc (544+13297/16384) 
133a			;=============================================================== 
133a 21 00 00		  ld hl,0 
133d			.u16a: 
133d 1a			  ld a,(de) 
133e d6 30		  sub 30h 
1340 fe 0a		  cp 10 
1342 d0			  ret nc 
1343 13			  inc de 
1344 44			  ld b,h 
1345 4d			  ld c,l 
1346 29			  add hl,hl 
1347 29			  add hl,hl 
1348 09			  add hl,bc 
1349 29			  add hl,hl 
134a 85			  add a,l 
134b 6f			  ld l,a 
134c 30 ef		  jr nc,.u16a 
134e 24			  inc h 
134f c3 3d 13		  jp .u16a 
1352			 
1352			 
1352			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1352			 
1352			;written by Zeda 
1352			;Converts a 16-bit unsigned integer to an ASCII string. 
1352			 
1352			uitoa_16: 
1352			;Input: 
1352			;   DE is the number to convert 
1352			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1352			;Output: 
1352			;   HL points to the null-terminated ASCII string 
1352			;      NOTE: This isn't necessarily the same as the input HL. 
1352 d5			  push de 
1353 c5			  push bc 
1354 f5			  push af 
1355 eb			  ex de,hl 
1356			 
1356 01 f0 d8		  ld bc,-10000 
1359 3e 2f		  ld a,'0'-1 
135b 3c			  inc a 
135c 09			  add hl,bc  
135d 38 fc		   jr c,$-2 
135f 12			  ld (de),a 
1360 13			  inc de 
1361			 
1361 01 e8 03		  ld bc,1000 
1364 3e 3a		  ld a,'9'+1 
1366 3d			  dec a  
1367 09			  add hl,bc  
1368 30 fc		   jr nc,$-2 
136a 12			  ld (de),a 
136b 13			  inc de 
136c			 
136c 01 9c ff		  ld bc,-100 
136f 3e 2f		  ld a,'0'-1 
1371 3c			  inc a  
1372 09			  add hl,bc  
1373 38 fc		   jr c,$-2 
1375 12			  ld (de),a 
1376 13			  inc de 
1377			 
1377 7d			  ld a,l 
1378 26 3a		  ld h,'9'+1 
137a 25			  dec h  
137b c6 0a		  add a,10  
137d 30 fb		   jr nc,$-3 
137f c6 30		  add a,'0' 
1381 eb			  ex de,hl 
1382 72			  ld (hl),d 
1383 23			  inc hl 
1384 77			  ld (hl),a 
1385 23			  inc hl 
1386 36 00		  ld (hl),0 
1388			 
1388			;Now strip the leading zeros 
1388 0e fa		  ld c,-6 
138a 09			  add hl,bc 
138b 3e 30		  ld a,'0' 
138d 23			  inc hl  
138e be			  cp (hl)  
138f 28 fc		  jr z,$-2 
1391			 
1391			;Make sure that the string is non-empty! 
1391 7e			  ld a,(hl) 
1392 b7			  or a 
1393 20 01		  jr nz,.atoub 
1395 2b			  dec hl 
1396			.atoub: 
1396			 
1396 f1			  pop af 
1397 c1			  pop bc 
1398 d1			  pop de 
1399 c9			  ret 
139a			 
139a			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
139a			 
139a			toUpper: 
139a			;A is the char. 
139a			;If A is a lowercase letter, this sets it to the matching uppercase 
139a			;18cc or 30cc or 41cc 
139a			;avg: 26.75cc 
139a fe 61		  cp 'a' 
139c d8			  ret c 
139d fe 7b		  cp 'z'+1 
139f d0			  ret nc 
13a0 d6 20		  sub 'a'-'A' 
13a2 c9			  ret 
13a3			 
13a3			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
13a3			 
13a3			; String Length 
13a3			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
13a3			 
13a3			; Get the length of the null-terminated string starting at $8000 hl 
13a3			;    LD     HL, $8000 
13a3			 
13a3			strlenz: 
13a3			 
13a3 af			    XOR    A               ; Zero is the value we are looking for. 
13a4 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
13a5 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
13a6			                           ; 65, 536 bytes (the entire addressable memory space). 
13a6 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13a8			 
13a8			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13a8 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
13a9 6f			    LD     L, A             ; number of bytes 
13aa ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13ac 2b			    DEC    HL              ; Compensate for null. 
13ad c9				ret 
13ae			 
13ae			; Get the length of the A terminated string starting at $8000 hl 
13ae			;    LD     HL, $8000 
13ae			 
13ae			strlent: 
13ae			 
13ae			                  ; A is the value we are looking for. 
13ae 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
13b0 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
13b2			                           ; 65, 536 bytes (the entire addressable memory space). 
13b2 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
13b4			 
13b4			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
13b4 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
13b6 2e 00		    LD     L, 0             ; number of bytes 
13b8 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
13ba 2b			    DEC    HL              ; Compensate for null. 
13bb c9				ret 
13bc			 
13bc			 
13bc			;Comparing Strings 
13bc			 
13bc			;IN    HL     Address of string1. 
13bc			;      DE     Address of string2. 
13bc			 
13bc			; doc given but wrong??? 
13bc			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
13bc			;      carry  Set if string1 > string2, reset if string1 <= string2. 
13bc			; tested 
13bc			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
13bc			 
13bc			strcmp_old: 
13bc e5			    PUSH   HL 
13bd d5			    PUSH   DE 
13be			 
13be 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
13bf be			    CP     (HL)            ; (want to minimize work). 
13c0 38 01		    JR     C, Str1IsBigger 
13c2 7e			    LD     A, (HL) 
13c3			 
13c3			Str1IsBigger: 
13c3 4f			    LD     C, A             ; Put length in BC 
13c4 06 00		    LD     B, 0 
13c6 13			    INC    DE              ; Increment pointers to meat of string. 
13c7 23			    INC    HL 
13c8			 
13c8			CmpLoop: 
13c8 1a			    LD     A, (DE)          ; Compare bytes. 
13c9 ed a1		    CPI 
13cb 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
13cd 13			    INC    DE              ; Update pointer. 
13ce ea c8 13		    JP     PE, CmpLoop 
13d1			 
13d1 d1			    POP    DE 
13d2 e1			    POP    HL 
13d3 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
13d4 be			    CP     (HL) 
13d5 c9			    RET 
13d6			 
13d6			NoMatch: 
13d6 2b			    DEC    HL 
13d7 be			    CP     (HL)            ; Compare again to affect carry. 
13d8 d1			    POP    DE 
13d9 e1			    POP    HL 
13da c9			    RET 
13db			 
13db			;; test strmp 
13db			; 
13db			;ld de, .str1 
13db			;ld hl, .str2 
13db			;call strcmp 
13db			;jr z, .z1 
13db			;;this 
13db			;	if DEBUG_FORTH_WORDS 
13db			;		DMARK "NZ1" 
13db			;		CALLMONITOR 
13db			;	endif 
13db			;.z1: 
13db			; 
13db			;	if DEBUG_FORTH_WORDS 
13db			;		DMARK "ZZ1" 
13db			;		CALLMONITOR 
13db			;	endif 
13db			; 
13db			;ld de, .str1 
13db			;ld hl, .str1 
13db			;call strcmp 
13db			;jr z, .z2 
13db			;;this 
13db			;	if DEBUG_FORTH_WORDS 
13db			;		DMARK "NZ2" 
13db			;		CALLMONITOR 
13db			;	endif 
13db			;.z2: 
13db			; 
13db			;	if DEBUG_FORTH_WORDS 
13db			;		DMARK "ZZ2" 
13db			;		CALLMONITOR 
13db			;	endif 
13db			; 
13db			;ld de, .str1 
13db			;ld hl, .str2 
13db			;call strcmp 
13db			;jr c, .c1 
13db			; 
13db			;	if DEBUG_FORTH_WORDS 
13db			;		DMARK "Nc1" 
13db			;		CALLMONITOR 
13db			;	endif 
13db			;.c1: 
13db			;;this 
13db			;	if DEBUG_FORTH_WORDS 
13db			;		DMARK "cc1" 
13db			;		CALLMONITOR 
13db			;	endif 
13db			; 
13db			;ld de, .str1 
13db			;ld hl, .str1 
13db			;call strcmp 
13db			;jr c, .c2 
13db			;;this 
13db			;	if DEBUG_FORTH_WORDS 
13db			;		DMARK "Nc2" 
13db			;		CALLMONITOR 
13db			;	endif 
13db			;.c2: 
13db			; 
13db			;	if DEBUG_FORTH_WORDS 
13db			;		DMARK "cc2" 
13db			;		CALLMONITOR 
13db			;	endif 
13db			;	NEXTW 
13db			;.str1:   db "string1",0 
13db			;.str2:   db "string2",0 
13db			 
13db			; only care about direct match or not 
13db			; hl and de strings 
13db			; zero set if the same 
13db			 
13db			strcmp: 
13db 1a				ld a, (de) 
13dc be				cp (hl) 
13dd 28 02			jr z, .ssame 
13df b7				or a 
13e0 c9				ret 
13e1			 
13e1			.ssame:  
13e1 fe 00			cp 0 
13e3 c8				ret z 
13e4			 
13e4 23				inc hl 
13e5 13				inc de 
13e6 18 f3			jr strcmp 
13e8				 
13e8				 
13e8			 
13e8			;Copyright (c) 2014, Luke Maurits 
13e8			;All rights reserved. 
13e8			; 
13e8			;Redistribution and use in source and binary forms, with or without 
13e8			;modification, are permitted provided that the following conditions are met: 
13e8			; 
13e8			;* Redistributions of source code must retain the above copyright notice, this 
13e8			;  list of conditions and the following disclaimer. 
13e8			; 
13e8			;* Redistributions in binary form must reproduce the above copyright notice, 
13e8			;  this list of conditions and the following disclaimer in the documentation 
13e8			;  and/or other materials provided with the distribution. 
13e8			; 
13e8			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
13e8			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
13e8			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
13e8			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
13e8			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
13e8			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
13e8			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
13e8			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
13e8			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
13e8			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
13e8			 
13e8			; https://github.com/lmaurits/lm512/blob/master/string.z80 
13e8			 
13e8			StrictStrCmp: 
13e8				; Load next chars of each string 
13e8 1a				ld a, (de) 
13e9 47				ld b, a 
13ea 7e				ld a, (hl) 
13eb				; Compare 
13eb b8				cp b 
13ec				; Return non-zero if chars don't match 
13ec c0				ret nz 
13ed				; Check for end of both strings 
13ed fe 00			cp "\0" 
13ef				; Return if strings have ended 
13ef c8				ret z 
13f0				; Otherwise, advance to next chars 
13f0 23				inc hl 
13f1 13				inc de 
13f2 18 f4			jr StrictStrCmp 
13f4			 
13f4			;end 
13f4			; eof 
13f4			 
13f4			 
13f4			 
13f4			 
13f4			 
13f4			 
# End of file firmware_strings.asm
13f4			include "firmware_memory.asm"   ; malloc and free  
13f4			 
13f4			if DEBUG_FORTH_MALLOC_HIGH 
13f4			.mallocsize: db "Wants malloc >256",0 
13f4			.mallocasize: db "MALLOC gives >256",0 
13f4			.malloczero: db "MALLOC gives zero",0 
13f4			 
13f4			malloc_guard_zerolen: 
13f4				push hl 
13f4				push de 
13f4				push af 
13f4			 
13f4				ld de, 0 
13f4			        call cmp16 
13f4				jr nz, .lowalloz 
13f4			 
13f4				push hl 
13f4				push de 
13f4					ld hl, display_fb0 
13f4					ld (display_fb_active), hl 
13f4				call clear_display 
13f4				ld a, 0 
13f4				ld de, .malloczero 
13f4				call str_at_display 
13f4				call update_display 
13f4				call delay1s 
13f4				call delay1s 
13f4				call bp_on 
13f4			;	ld a, 0 
13f4			;	ld (os_view_disable), a 
13f4			 
13f4				pop de 
13f4				pop hl 
13f4			 
13f4				 
13f4			 
13f4				CALLMONITOR 
13f4			.lowalloz: 
13f4			 
13f4			 
13f4				pop af 
13f4				pop de 
13f4				pop hl 
13f4			ret 
13f4			 
13f4			malloc_guard_entry: 
13f4				push hl 
13f4				push de 
13f4				push af 
13f4			 
13f4			 	or a      ;clear carry flag 
13f4				push hl 
13f4				ld de, 255 
13f4				sbc hl, de 
13f4				jr c, .lowalloc 
13f4			 
13f4				push de 
13f4					ld hl, display_fb0 
13f4					ld (display_fb_active), hl 
13f4				call clear_display 
13f4				ld a, 0 
13f4				ld de, .mallocsize 
13f4				call str_at_display 
13f4				call update_display 
13f4				call delay1s 
13f4				call delay1s 
13f4			;	ld a, 0 
13f4			;	ld (os_view_disable), a 
13f4				call bp_on 
13f4			 
13f4				pop de 
13f4				pop hl 
13f4			 
13f4				 
13f4			 
13f4				CALLMONITOR 
13f4				jr .lowdone 
13f4			.lowalloc: 
13f4			 
13f4			 
13f4				pop hl 
13f4			.lowdone:	pop af 
13f4				pop de 
13f4				pop hl 
13f4			ret 
13f4			 
13f4			malloc_guard_exit: 
13f4				push hl 
13f4				push de 
13f4				push af 
13f4			 
13f4			 	or a      ;clear carry flag 
13f4				push hl 
13f4				ld de, 255 
13f4				sbc hl, de 
13f4				jr c, .lowallocx 
13f4			 
13f4				push de 
13f4					ld hl, display_fb0 
13f4					ld (display_fb_active), hl 
13f4				call clear_display 
13f4				ld a, 0 
13f4				ld de, .mallocasize 
13f4				call str_at_display 
13f4				call update_display 
13f4				call delay1s 
13f4				call delay1s 
13f4			;	ld a, 0 
13f4			;	ld (os_view_disable), a 
13f4				call bp_on 
13f4				pop de 
13f4				pop hl 
13f4			 
13f4				CALLMONITOR 
13f4				jr .lowdonex 
13f4			.lowallocx: 
13f4			 
13f4				pop hl 
13f4			.lowdonex:	pop af 
13f4				pop de 
13f4				pop hl 
13f4			ret 
13f4			endif 
13f4			 
13f4			if MALLOC_2 
13f4			; Z80 Malloc and Free Functions 
13f4			 
13f4			; Malloc Function: 
13f4			; Input: 
13f4			;   HL: Size of block to allocate 
13f4			; Output: 
13f4			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13f4			 
13f4			malloc: 
13f4				 
13f4			if DEBUG_FORTH_MALLOC_HIGH 
13f4			call malloc_guard_entry 
13f4			endif 
13f4			 
13f4			 
13f4			 
13f4			 
13f4					if DEBUG_FORTH_MALLOC 
13f4						DMARK "mal" 
13f4						CALLMONITOR 
13f4					endif 
13f4			    push af            ; Save AF register 
13f4			    ld a, l            ; Load low byte of size into A 
13f4			    or h               ; Check if size is zero 
13f4			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
13f4			 
13f4			    ; Allocate memory 
13f4			    ld hl, (heap_start) ; Load start of heap into HL 
13f4					if DEBUG_FORTH_MALLOC 
13f4						DMARK "ma1" 
13f4						CALLMONITOR 
13f4					endif 
13f4			    call malloc_internal ; Call internal malloc function 
13f4			    pop af             ; Restore AF register 
13f4			if DEBUG_FORTH_MALLOC_HIGH 
13f4			call malloc_guard_exit 
13f4			call malloc_guard_zerolen 
13f4			endif 
13f4			    ret                ; Return 
13f4			 
13f4			; Free Function: 
13f4			; Input: 
13f4			;   HL: Pointer to memory block to free 
13f4			; Output: 
13f4			;   None 
13f4			 
13f4			free: 
13f4			    push af            ; Save AF register 
13f4			    ld a, l            ; Load low byte of pointer into A 
13f4			    or h               ; Check if pointer is NULL 
13f4			    jp z, free_exit    ; If pointer is NULL, exit 
13f4			 
13f4			    ; Free memory 
13f4			    ld hl, (heap_start) ; Load start of heap into HL 
13f4			    call free_internal  ; Call internal free function 
13f4			    pop af             ; Restore AF register 
13f4			    ret                ; Return 
13f4			 
13f4			; Internal Malloc Function: 
13f4			; Input: 
13f4			;   HL: Size of block to allocate 
13f4			; Output: 
13f4			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13f4			 
13f4			malloc_internal: 
13f4			    ld bc, 2           ; Number of bytes to allocate for management overhead 
13f4			    add hl, bc         ; Add management overhead to requested size 
13f4			    ex de, hl          ; Save total size in DE, and keep it in HL 
13f4					if DEBUG_FORTH_MALLOC 
13f4						DMARK "ma2" 
13f4						CALLMONITOR 
13f4					endif 
13f4			 
13f4			    ; Search for free memory block 
13f4			    ld de, (heap_end)  ; Load end of heap into DE 
13f4			    ld bc, 0           ; Initialize counter 
13f4			 
13f4					if DEBUG_FORTH_MALLOC 
13f4						DMARK "ma2" 
13f4						CALLMONITOR 
13f4					endif 
13f4			malloc_search_loop: 
13f4			    ; Check if current block is free 
13f4			    ld a, (hl)         ; Load current block's status (free or used) 
13f4			    cp 0               ; Compare with zero (free) 
13f4			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
13f4			 
13f4			    ; Check if current block is large enough 
13f4			    ld a, (hl+1)       ; Load high byte of block size 
13f4			    cp l               ; Compare with low byte of requested size 
13f4			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
13f4			 
13f4			    ld a, (hl+2)       ; Load low byte of block size 
13f4			    cp h               ; Compare with high byte of requested size 
13f4			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
13f4			 
13f4			    ; Mark block as used 
13f4			    ld (hl), 0xFF      ; Set status byte to indicate used block 
13f4			 
13f4			    ; Calculate remaining space in block 
13f4			    ld bc, 0           ; Clear BC 
13f4			    add hl, bc         ; Increment HL to point to start of data block 
13f4			    add hl, de         ; HL = HL + DE (total size) 
13f4			    ld bc, 1           ; Number of bytes to allocate for management overhead 
13f4			    add hl, bc         ; Add management overhead to start of data block 
13f4			 
13f4			    ; Save pointer to allocated block in HL 
13f4			if DEBUG_FORTH_MALLOC_HIGH 
13f4						DMARK "ma5" 
13f4			call malloc_guard_exit 
13f4			call malloc_guard_zerolen 
13f4			endif 
13f4			    ret 
13f4			 
13f4			malloc_skip_block_check: 
13f4			    ; Move to the next block 
13f4			    ld bc, 3           ; Size of management overhead 
13f4			    add hl, bc         ; Move to the next block 
13f4			    inc de             ; Increment counter 
13f4			 
13f4			    ; Check if we have reached the end of heap 
13f4			    ld a, e            ; Load low byte of heap end address 
13f4			    cp (hl)            ; Compare with low byte of current address 
13f4			    jr nz, malloc_search_loop  ; If not equal, continue searching 
13f4			    ld a, d            ; Load high byte of heap end address 
13f4			    cp 0               ; Check if it's zero (end of memory) 
13f4			    jr nz, malloc_search_loop  ; If not zero, continue searching 
13f4			 
13f4			    ; If we reached here, allocation failed 
13f4			    xor a              ; Set result to NULL 
13f4			if DEBUG_FORTH_MALLOC_HIGH 
13f4						DMARK "ma6" 
13f4			call malloc_guard_exit 
13f4			call malloc_guard_zerolen 
13f4			endif 
13f4			    ret 
13f4			malloc_exit: 
13f4			if DEBUG_FORTH_MALLOC_HIGH 
13f4						DMARK "ma7" 
13f4			call malloc_guard_exit 
13f4			call malloc_guard_zerolen 
13f4			endif 
13f4			    ret 
13f4			 
13f4			; Internal Free Function: 
13f4			; Input: 
13f4			;   HL: Pointer to memory block to free 
13f4			; Output: 
13f4			;   None 
13f4			 
13f4			free_internal: 
13f4			    ld de, (heap_start) ; Load start of heap into DE 
13f4			    ld bc, 0            ; Initialize counter 
13f4			 
13f4			free_search_loop: 
13f4			    ; Check if current block contains the pointer 
13f4			    ld a, l             ; Load low byte of pointer 
13f4			    cp (hl+1)           ; Compare with high byte of current block's address 
13f4			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13f4			    ld a, h             ; Load high byte of pointer 
13f4			    cp (hl+2)           ; Compare with low byte of current block's address 
13f4			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13f4			 
13f4			    ; Mark block as free 
13f4			    ld (hl), 0          ; Set status byte to indicate free block 
13f4			    ret                 ; Return 
13f4			 
13f4			free_skip_block_check: 
13f4			    ; Move to the next block 
13f4			    ld bc, 3            ; Size of management overhead 
13f4			    add hl, bc          ; Move to the next block 
13f4			    inc de              ; Increment counter 
13f4			 
13f4			    ; Check if we have reached the end of heap 
13f4			    ld a, e             ; Load low byte of heap end address 
13f4			    cp (hl)             ; Compare with low byte of current address 
13f4			    jr nz, free_search_loop  ; If not equal, continue searching 
13f4			    ld a, d             ; Load high byte of heap end address 
13f4			    cp 0                ; Check if it's zero (end of memory) 
13f4			    jr nz, free_search_loop  ; If not zero, continue searching 
13f4			 
13f4			    ; If we reached here, pointer is not found in heap 
13f4			    ret 
13f4			 
13f4			free_exit: 
13f4			    ret                 ; Return 
13f4			 
13f4			; Define heap start and end addresses 
13f4			;heap_start:    .dw 0xC000   ; Start of heap 
13f4			;heap_end:      .dw 0xE000   ; End of heap 
13f4			 
13f4			endif 
13f4			 
13f4			 
13f4			if MALLOC_1 
13f4			 
13f4			 
13f4			 
13f4			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
13f4			 
13f4			;moved to firmware.asm 
13f4			;heap_start        .equ  0x9000      ; Starting address of heap 
13f4			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
13f4			 
13f4			;      .org 0 
13f4			;      jp    main 
13f4			 
13f4			 
13f4			;      .org  0x100 
13f4			;main: 
13f4			;      ld    HL, 0x8100 
13f4			;      ld    SP, HL 
13f4			; 
13f4			;      call  heap_init 
13f4			; 
13f4			;      ; Make some allocations 
13f4			;      ld    HL, 12 
13f4			;      call  malloc            ; Allocates 0x9004 
13f4			; 
13f4			;      ld    HL, 12 
13f4			;      call  malloc            ; Allocates 0x9014 
13f4			; 
13f4			;      ld    HL, 12 
13f4			;      call  malloc            ; Allocates 0x9024 
13f4			; 
13f4			;      ; Free some allocations 
13f4			;      ld    HL, 0x9014 
13f4			;      call  free 
13f4			; 
13f4			;      ld    HL, 0x9004 
13f4			;      call  free 
13f4			; 
13f4			;      ld    HL, 0x9024 
13f4			;      call  free 
13f4			; 
13f4			; 
13f4			;      halt 
13f4			 
13f4			 
13f4			;------------------------------------------------------------------------------ 
13f4			;     heap_init                                                               : 
13f4			;                                                                             : 
13f4			; Description                                                                 : 
13f4			;     Initialise the heap and make it ready for malloc and free operations.   : 
13f4			;                                                                             : 
13f4			;     The heap is maintained as a linked list, starting with an initial       : 
13f4			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
13f4			;     the first free block in the heap. Each block then points to the next    : 
13f4			;     free block within the heap, and the free list ends at the first block   : 
13f4			;     with a null pointer to the next free block.                             : 
13f4			;                                                                             : 
13f4			; Parameters                                                                  : 
13f4			;     Inputs are compile-time only. Two defines which specify the starting    : 
13f4			;     address of the heap and its size are required, along with a memory      : 
13f4			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
13f4			;     principally stores a pointer to the first free block in the heap.       : 
13f4			;                                                                             : 
13f4			; Returns                                                                     : 
13f4			;     Nothing                                                                 : 
13f4			;------------------------------------------------------------------------------ 
13f4			heap_init: 
13f4 e5			      push  HL 
13f5			 
13f5			      ; Initialise free list struct 
13f5 21 b5 67		      ld    HL, heap_start 
13f8 22 b0 67		      ld    (free_list), HL 
13fb 21 00 00		      ld    HL, 0 
13fe 22 b2 67		      ld    (free_list+2), HL 
1401			 
1401			      ; Insert first free block at bottom of heap, consumes entire heap 
1401 21 98 e2		      ld    HL, heap_start+heap_size-4 
1404 22 b5 67		      ld    (heap_start), HL        ; Next block (end of free list) 
1407 21 e3 7a		      ld    HL, heap_size-4 
140a 22 b7 67		      ld    (heap_start+2), HL      ; Block size 
140d			 
140d			      ; Insert end of free list block at top of heap - two null words will 
140d			      ; terminate the free list 
140d 21 00 00		      ld    HL, 0 
1410 22 9a e2		      ld    (heap_start+heap_size-2), HL 
1413 22 98 e2		      ld    (heap_start+heap_size-4), HL 
1416			 
1416 e1			      pop   HL 
1417			 
1417 c9			      ret 
1418			 
1418			 
1418			;------------------------------------------------------------------------------ 
1418			;     malloc                                                                  : 
1418			;                                                                             : 
1418			; Description                                                                 : 
1418			;     Allocates the wanted space from the heap and returns the address of the : 
1418			;     first useable byte of the allocation.                                   : 
1418			;                                                                             : 
1418			;     Allocations can happen in one of two ways:                              : 
1418			;                                                                             : 
1418			;     1. A free block may be found which is the exact size wanted. In this    : 
1418			;        case the block is removed from the free list and retuedn to the      : 
1418			;        caller.                                                              : 
1418			;     2. A free block may be found which is larger than the size wanted. In   : 
1418			;        this case, the larger block is split into two. The first portion of  : 
1418			;        this block will become the requested space by the malloc call and    : 
1418			;        is returned to the caller. The second portion becomes a new free     : 
1418			;        block, and the free list is adjusted to maintain continuity via this : 
1418			;        newly created block.                                                 : 
1418			;                                                                             : 
1418			;     malloc does not set any initial value in the allocated space, the       : 
1418			;     caller is required to do this as required.                              : 
1418			;                                                                             : 
1418			;     This implementation of malloc uses the stack exclusively, and is        : 
1418			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1418			;     advisable to disable interrupts before calling malloc, and recommended  : 
1418			;     to avoid the use of malloc inside ISRs in general.                      : 
1418			;                                                                             : 
1418			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1418			;                                                                             : 
1418			; Parameters                                                                  : 
1418			;     HL  Number of bytes wanted                                              : 
1418			;                                                                             : 
1418			; Returns                                                                     : 
1418			;     HL  Address of the first useable byte of the allocation                 : 
1418			;                                                                             : 
1418			; Flags                                                                       : 
1418			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1418			;                                                                             : 
1418			; Stack frame                                                                 : 
1418			;       |             |                                                       : 
1418			;       +-------------+                                                       : 
1418			;       |     BC      |                                                       : 
1418			;       +-------------+                                                       : 
1418			;       |     DE      |                                                       : 
1418			;       +-------------+                                                       : 
1418			;       |     IX      |                                                       : 
1418			;       +-------------+                                                       : 
1418			;       |  prev_free  |                                                       : 
1418			;   +4  +-------------+                                                       : 
1418			;       |  this_free  |                                                       : 
1418			;   +2  +-------------+                                                       : 
1418			;       |  next_free  |                                                       : 
1418			;   +0  +-------------+                                                       : 
1418			;       |             |                                                       : 
1418			;                                                                             : 
1418			;------------------------------------------------------------------------------ 
1418			 
1418			 
1418			;malloc: 
1418			; 
1418			;	SAVESP ON 1 
1418			; 
1418			;	call malloc_code 
1418			; 
1418			;	CHECKSP ON 1 
1418			;	ret 
1418			 
1418			 
1418			malloc: 
1418 c5			      push  BC 
1419 d5			      push  DE 
141a dd e5		      push  IX 
141c			if DEBUG_FORTH_MALLOC_HIGH 
141c			call malloc_guard_entry 
141c			endif 
141c			 
141c					if DEBUG_FORTH_MALLOC 
141c						DMARK "mal" 
141c						CALLMONITOR 
141c					endif 
141c 7c			      ld    A, H                    ; Exit if no space requested 
141d b5			      or    L 
141e ca dd 14		      jp    Z, malloc_early_exit 
1421			 
1421			;inc hl 
1421			;inc hl 
1421			;inc hl 
1421			; 
1421			;inc hl 
1421			;inc hl 
1421			;inc hl 
1421			;inc hl 
1421			;inc hl 
1421			;inc hl 
1421			;inc hl 
1421			;inc hl 
1421			;inc hl 
1421			 
1421			 
1421			 
1421			 
1421					if DEBUG_FORTH_MALLOC 
1421						DMARK "maA" 
1421						CALLMONITOR 
1421					endif 
1421			      ; Set up stack frame 
1421 eb			      ex    DE, HL 
1422 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1425 39			      add   HL, SP 
1426 f9			      ld    SP, HL 
1427 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
142b dd 39		      add   IX, SP 
142d			 
142d			      ; Setup initial state 
142d 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1430 19			      add   HL, DE 
1431			 
1431 44			      ld    B, H                    ; Move want to BC 
1432 4d			      ld    C, L 
1433			 
1433 21 b0 67		      ld    HL, free_list           ; Store prev_free ptr to stack 
1436 dd 75 04		      ld    (IX+4), L 
1439 dd 74 05		      ld    (IX+5), H 
143c			 
143c 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
143d 23			      inc   HL 
143e 56			      ld    D, (HL) 
143f dd 73 02		      ld    (IX+2), E 
1442 dd 72 03		      ld    (IX+3), D 
1445 eb			      ex    DE, HL                  ; this_free ptr into HL 
1446			 
1446					if DEBUG_FORTH_MALLOC 
1446						DMARK "maB" 
1446						CALLMONITOR 
1446					endif 
1446			      ; Loop through free block list to find some space 
1446			malloc_find_space: 
1446 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1447 23			      inc   HL 
1448 56			      ld    D, (HL) 
1449			 
1449 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
144a b3			      or    E 
144b ca d7 14		      jp    Z, malloc_no_space 
144e			 
144e dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1451 dd 72 01		      ld    (IX+1), D 
1454			 
1454			      ; Does this block have enough space to make the allocation? 
1454 23			      inc   HL                      ; Load free block size into DE 
1455 5e			      ld    E, (HL) 
1456 23			      inc   HL 
1457 56			      ld    D, (HL) 
1458			 
1458 eb			      ex    DE, HL                  ; Check size of block against want 
1459 b7			      or    A                       ; Ensure carry flag clear 
145a ed 42		      sbc   HL, BC 
145c e5			      push  HL                      ; Store the result for later (new block size) 
145d			 
145d ca ac 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1460 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1462			 
1462			      ; this_free block is not big enough, setup ptrs to test next free block 
1462 e1			      pop   HL                      ; Discard previous result 
1463			 
1463 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1466 dd 66 03		      ld    H, (IX+3) 
1469 dd 75 04		      ld    (IX+4), L 
146c dd 74 05		      ld    (IX+5), H 
146f			 
146f dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1472 dd 66 01		      ld    H, (IX+1) 
1475 dd 75 02		      ld    (IX+2), L 
1478 dd 74 03		      ld    (IX+3), H 
147b			 
147b					if DEBUG_FORTH_MALLOC 
147b						DMARK "MA>" 
147b						CALLMONITOR 
147b					endif 
147b 18 c9		      jr    malloc_find_space 
147d			 
147d			      ; split a bigger block into two - requested size and remaining size 
147d			malloc_alloc_split: 
147d					if DEBUG_FORTH_MALLOC 
147d						DMARK "MAs" 
147d						CALLMONITOR 
147d					endif 
147d eb			      ex    DE, HL                  ; Calculate address of new free block 
147e 2b			      dec   HL 
147f 2b			      dec   HL 
1480 2b			      dec   HL 
1481 09			      add   HL, BC 
1482			 
1482			      ; Create a new block and point it at next_free 
1482 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1485 dd 56 01		      ld    D, (IX+1) 
1488			 
1488 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1489 23			      inc   HL 
148a 72			      ld    (HL), D 
148b			 
148b d1			      pop   DE                      ; Store size of new block into new block 
148c 23			      inc   HL 
148d 73			      ld    (HL), E 
148e 23			      inc   HL 
148f 72			      ld    (HL), D 
1490			 
1490			      ; Update this_free ptr to point to new block 
1490 2b			      dec   HL 
1491 2b			      dec   HL 
1492 2b			      dec   HL 
1493			 
1493 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1496 dd 56 03		      ld    D, (IX+3) 
1499			 
1499 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
149c dd 74 03		      ld    (IX+3), H 
149f			 
149f			      ; Modify this_free block to be allocation 
149f eb			      ex    DE, HL 
14a0 af			      xor   A                       ; Null the next block ptr of allocated block 
14a1 77			      ld    (HL), A 
14a2 23			      inc   HL 
14a3 77			      ld    (HL), A 
14a4			 
14a4 23			      inc   HL                      ; Store want size into allocated block 
14a5 71			      ld    (HL), C 
14a6 23			      inc   HL 
14a7 70			      ld    (HL), B 
14a8 23			      inc   HL 
14a9 e5			      push  HL                      ; Address of allocation to return 
14aa			 
14aa 18 19		      jr    malloc_update_links 
14ac			 
14ac			malloc_alloc_fit: 
14ac e1			      pop   HL                      ; Dont need new block size, want is exact fit 
14ad			 
14ad					if DEBUG_FORTH_MALLOC 
14ad						DMARK "MAf" 
14ad						CALLMONITOR 
14ad					endif 
14ad			      ; Modify this_free block to be allocation 
14ad eb			      ex    DE, HL 
14ae 2b			      dec   HL 
14af 2b			      dec   HL 
14b0 2b			      dec   HL 
14b1			 
14b1 af			      xor   A                       ; Null the next block ptr of allocated block 
14b2 77			      ld    (HL), A 
14b3 23			      inc   HL 
14b4 77			      ld    (HL), A 
14b5			 
14b5 23			      inc   HL                      ; Store address of allocation to return 
14b6 23			      inc   HL 
14b7 23			      inc   HL 
14b8 e5			      push  HL 
14b9			 
14b9			      ; Copy next_free ptr to this_free, remove allocated block from free list 
14b9 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
14bc dd 66 01		      ld    H, (IX+1) 
14bf			 
14bf dd 75 02		      ld    (IX+2), L               ; HL to this_free 
14c2 dd 74 03		      ld    (IX+3), H 
14c5			 
14c5			 
14c5			malloc_update_links: 
14c5			      ; Update prev_free ptr to point to this_free 
14c5 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
14c8 dd 66 05		      ld    H, (IX+5) 
14cb			 
14cb dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
14ce dd 56 03		      ld    D, (IX+3) 
14d1			 
14d1 73			      ld    (HL), E                 ; this_free ptr into prev_free 
14d2 23			      inc   HL 
14d3 72			      ld    (HL), D 
14d4			 
14d4					if DEBUG_FORTH_MALLOC 
14d4						DMARK "Mul" 
14d4						CALLMONITOR 
14d4					endif 
14d4			      ; Clear the Z flag to indicate successful allocation 
14d4 7a			      ld    A, D 
14d5 b3			      or    E 
14d6			 
14d6 d1			      pop   DE                      ; Address of allocation 
14d7					if DEBUG_FORTH_MALLOC 
14d7						DMARK "MAu" 
14d7						CALLMONITOR 
14d7					endif 
14d7			 
14d7			malloc_no_space: 
14d7 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
14da 39			      add   HL, SP 
14db f9			      ld    SP, HL 
14dc			 
14dc eb			      ex    DE, HL                  ; Alloc addr into HL for return 
14dd					if DEBUG_FORTH_MALLOC 
14dd						DMARK "MAN" 
14dd						CALLMONITOR 
14dd					endif 
14dd			 
14dd			malloc_early_exit: 
14dd					if DEBUG_FORTH_MALLOC 
14dd						DMARK "MAx" 
14dd						CALLMONITOR 
14dd					endif 
14dd dd e1		      pop   IX 
14df d1			      pop   DE 
14e0 c1			      pop   BC 
14e1			 
14e1			if DEBUG_FORTH_MALLOC_HIGH 
14e1			call malloc_guard_exit 
14e1			call malloc_guard_zerolen 
14e1			endif 
14e1 c9			      ret 
14e2			 
14e2			 
14e2			;------------------------------------------------------------------------------ 
14e2			;     free                                                                    : 
14e2			;                                                                             : 
14e2			; Description                                                                 : 
14e2			;     Return the space pointed to by HL to the heap. HL must be an address as : 
14e2			;     returned by malloc, otherwise the behaviour is undefined.               : 
14e2			;                                                                             : 
14e2			;     Where possible, directly adjacent free blocks will be merged together   : 
14e2			;     into larger blocks to help ensure that the heap does not become         : 
14e2			;     excessively fragmented.                                                 : 
14e2			;                                                                             : 
14e2			;     free does not clear or set any other value into the freed space, and    : 
14e2			;     therefore its contents may be visible through subsequent malloc's. The  : 
14e2			;     caller should clear the freed space as required.                        : 
14e2			;                                                                             : 
14e2			;     This implementation of free uses the stack exclusively, and is          : 
14e2			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
14e2			;     advisable to disable interrupts before calling free, and recommended    : 
14e2			;     to avoid the use of free inside ISRs in general.                        : 
14e2			;                                                                             : 
14e2			;     NOTE: heap_init must be called before malloc and free can be used.      : 
14e2			;                                                                             : 
14e2			; Parameters                                                                  : 
14e2			;     HL  Pointer to address of first byte of allocation to be freed          : 
14e2			;                                                                             : 
14e2			; Returns                                                                     : 
14e2			;     Nothing                                                                 : 
14e2			;                                                                             : 
14e2			; Stack frame                                                                 : 
14e2			;       |             |                                                       : 
14e2			;       +-------------+                                                       : 
14e2			;       |     BC      |                                                       : 
14e2			;       +-------------+                                                       : 
14e2			;       |     DE      |                                                       : 
14e2			;       +-------------+                                                       : 
14e2			;       |     IX      |                                                       : 
14e2			;       +-------------+                                                       : 
14e2			;       |  prev_free  |                                                       : 
14e2			;   +2  +-------------+                                                       : 
14e2			;       |  next_free  |                                                       : 
14e2			;   +0  +-------------+                                                       : 
14e2			;       |             |                                                       : 
14e2			;                                                                             : 
14e2			;------------------------------------------------------------------------------ 
14e2			free: 
14e2 c5			      push  BC 
14e3 d5			      push  DE 
14e4 dd e5		      push  IX 
14e6			 
14e6 7c			      ld    A, H                    ; Exit if ptr is null 
14e7 b5			      or    L 
14e8 ca ac 15		      jp    Z, free_early_exit 
14eb			 
14eb			      ; Set up stack frame 
14eb eb			      ex    DE, HL 
14ec 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
14ef 39			      add   HL, SP 
14f0 f9			      ld    SP, HL 
14f1 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14f5 dd 39		      add   IX, SP 
14f7			 
14f7			      ; The address in HL points to the start of the useable allocated space, 
14f7			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
14f7			      ; address of the block itself. 
14f7 eb			      ex    DE, HL 
14f8 11 fc ff		      ld    DE, -4 
14fb 19			      add   HL, DE 
14fc			 
14fc			      ; An allocated block must have a null next block pointer in it 
14fc 7e			      ld    A, (HL) 
14fd 23			      inc   HL 
14fe b6			      or    (HL) 
14ff c2 a7 15		      jp    NZ, free_done 
1502			 
1502 2b			      dec   HL 
1503			 
1503 44			      ld    B, H                    ; Copy HL to BC 
1504 4d			      ld    C, L 
1505			 
1505			      ; Loop through the free list to find the first block with an address 
1505			      ; higher than the block being freed 
1505 21 b0 67		      ld    HL, free_list 
1508			 
1508			free_find_higher_block: 
1508 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1509 23			      inc   HL 
150a 56			      ld    D, (HL) 
150b 2b			      dec   HL 
150c			 
150c dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
150f dd 72 01		      ld    (IX+1), D 
1512 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1515 dd 74 03		      ld    (IX+3), H 
1518			 
1518 78			      ld    A, B                    ; Check if DE is greater than BC 
1519 ba			      cp    D                       ; Compare MSB first 
151a 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
151c 30 04		      jr    NC, free_find_higher_block_skip 
151e 79			      ld    A, C 
151f bb			      cp    E                       ; Then compare LSB 
1520 38 08		      jr    C, free_found_higher_block 
1522			 
1522			free_find_higher_block_skip: 
1522 7a			      ld    A, D                    ; Reached the end of the free list? 
1523 b3			      or    E 
1524 ca a7 15		      jp    Z, free_done 
1527			 
1527 eb			      ex    DE, HL 
1528			 
1528 18 de		      jr    free_find_higher_block 
152a			 
152a			free_found_higher_block: 
152a			      ; Insert freed block between prev and next free blocks 
152a 71			      ld    (HL), C                 ; Point prev free block to freed block 
152b 23			      inc   HL 
152c 70			      ld    (HL), B 
152d			 
152d 60			      ld    H, B                    ; Point freed block at next free block 
152e 69			      ld    L, C 
152f 73			      ld    (HL), E 
1530 23			      inc   HL 
1531 72			      ld    (HL), D 
1532			 
1532			      ; Check if the freed block is adjacent to the next free block 
1532 23			      inc   HL                      ; Load size of freed block into HL 
1533 5e			      ld    E, (HL) 
1534 23			      inc   HL 
1535 56			      ld    D, (HL) 
1536 eb			      ex    DE, HL 
1537			 
1537 09			      add   HL, BC                  ; Add addr of freed block and its size 
1538			 
1538 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
153b dd 56 01		      ld    D, (IX+1) 
153e			 
153e b7			      or    A                       ; Clear the carry flag 
153f ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1541 20 22		      jr    NZ, free_check_adjacent_to_prev 
1543			 
1543			      ; Freed block is adjacent to next, merge into one bigger block 
1543 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
1544 5e			      ld    E, (HL) 
1545 23			      inc   HL 
1546 56			      ld    D, (HL) 
1547 e5			      push  HL                      ; Save ptr to next block for later 
1548			 
1548 60			      ld    H, B                    ; Store ptr from next block into freed block 
1549 69			      ld    L, C 
154a 73			      ld    (HL), E 
154b 23			      inc   HL 
154c 72			      ld    (HL), D 
154d			 
154d e1			      pop   HL                      ; Restore ptr to next block 
154e 23			      inc   HL                      ; Load size of next block into DE 
154f 5e			      ld    E, (HL) 
1550 23			      inc   HL 
1551 56			      ld    D, (HL) 
1552 d5			      push  DE                      ; Save next block size for later 
1553			 
1553 60			      ld    H, B                    ; Load size of freed block into HL 
1554 69			      ld    L, C 
1555 23			      inc   HL 
1556 23			      inc   HL 
1557 5e			      ld    E, (HL) 
1558 23			      inc   HL 
1559 56			      ld    D, (HL) 
155a eb			      ex    DE, HL 
155b			 
155b d1			      pop   DE                      ; Restore size of next block 
155c 19			      add   HL, DE                  ; Add sizes of both blocks 
155d eb			      ex    DE, HL 
155e			 
155e 60			      ld    H, B                    ; Store new bigger size into freed block 
155f 69			      ld    L, C 
1560 23			      inc   HL 
1561 23			      inc   HL 
1562 73			      ld    (HL), E 
1563 23			      inc   HL 
1564 72			      ld    (HL), D 
1565			 
1565			free_check_adjacent_to_prev: 
1565			      ; Check if the freed block is adjacent to the prev free block 
1565 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1568 dd 66 03		      ld    H, (IX+3) 
156b			 
156b 23			      inc   HL                      ; Size of prev free block into DE 
156c 23			      inc   HL 
156d 5e			      ld    E, (HL) 
156e 23			      inc   HL 
156f 56			      ld    D, (HL) 
1570 2b			      dec   HL 
1571 2b			      dec   HL 
1572 2b			      dec   HL 
1573			 
1573 19			      add   HL, DE                  ; Add prev block addr and size 
1574			 
1574 b7			      or    A                       ; Clear the carry flag 
1575 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1577 20 2e		      jr    NZ, free_done 
1579			 
1579			      ; Freed block is adjacent to prev, merge into one bigger block 
1579 60			      ld    H, B                    ; Load next ptr from freed block into DE 
157a 69			      ld    L, C 
157b 5e			      ld    E, (HL) 
157c 23			      inc   HL 
157d 56			      ld    D, (HL) 
157e e5			      push  HL                      ; Save freed block ptr for later 
157f			 
157f dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1582 dd 66 03		      ld    H, (IX+3) 
1585 73			      ld    (HL), E 
1586 23			      inc   HL 
1587 72			      ld    (HL), D 
1588			 
1588 e1			      pop   HL                      ; Restore freed block ptr 
1589 23			      inc   HL                      ; Load size of freed block into DE 
158a 5e			      ld    E, (HL) 
158b 23			      inc   HL 
158c 56			      ld    D, (HL) 
158d d5			      push  DE                      ; Save freed block size for later 
158e			 
158e dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1591 dd 66 03		      ld    H, (IX+3) 
1594 23			      inc   HL 
1595 23			      inc   HL 
1596 5e			      ld    E, (HL) 
1597 23			      inc   HL 
1598 56			      ld    D, (HL) 
1599			 
1599 e1			      pop   HL                      ; Add sizes of both blocks 
159a 19			      add   HL, DE 
159b eb			      ex    DE, HL 
159c			 
159c dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
159f dd 66 03		      ld    H, (IX+3) 
15a2 23			      inc   HL 
15a3 23			      inc   HL 
15a4 73			      ld    (HL), E 
15a5 23			      inc   HL 
15a6 72			      ld    (HL), D 
15a7			 
15a7			free_done: 
15a7 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
15aa 39			      add   HL, SP 
15ab f9			      ld    SP, HL 
15ac			 
15ac			free_early_exit: 
15ac dd e1		      pop   IX 
15ae d1			      pop   DE 
15af c1			      pop   BC 
15b0			 
15b0 c9			      ret 
15b1			 
15b1			; moved to firmware.asm 
15b1			; 
15b1			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15b1			;                  .dw   0 
15b1			 
15b1			 
15b1			endif 
15b1			 
15b1			 
15b1			if MALLOC_3 
15b1			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
15b1			;heap_start        .equ  0x9000      ; Starting address of heap 
15b1			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
15b1			; 
15b1			 ;     .org 0 
15b1			  ;    jp    main 
15b1			; 
15b1			; 
15b1			 ;     .org  0x100 
15b1			;main: 
15b1			 ;     ld    HL, 0x8100 
15b1			  ;    ld    SP, HL 
15b1			; 
15b1			;      call  heap_init 
15b1			 
15b1			      ; Make some allocations 
15b1			;      ld    HL, 12 
15b1			;      call  malloc            ; Allocates 0x9004 
15b1			; 
15b1			 ;     ld    HL, 12 
15b1			;      call  malloc            ; Allocates 0x9014 
15b1			 
15b1			;      ld    HL, 12 
15b1			;      call  malloc            ; Allocates 0x9024 
15b1			 
15b1			      ; Free some allocations 
15b1			;      ld    HL, 0x9014 
15b1			;      call  free 
15b1			 
15b1			;      ld    HL, 0x9004 
15b1			;      call  free 
15b1			; 
15b1			;      ld    HL, 0x9024 
15b1			;      call  free 
15b1			 
15b1			 
15b1			 ;     halt 
15b1			 
15b1			 
15b1			;------------------------------------------------------------------------------ 
15b1			;     heap_init                                                               : 
15b1			;                                                                             : 
15b1			; Description                                                                 : 
15b1			;     Initialise the heap and make it ready for malloc and free operations.   : 
15b1			;                                                                             : 
15b1			;     The heap is maintained as a linked list, starting with an initial       : 
15b1			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
15b1			;     the first free block in the heap. Each block then points to the next    : 
15b1			;     free block within the heap, and the free list ends at the first block   : 
15b1			;     with a null pointer to the next free block.                             : 
15b1			;                                                                             : 
15b1			; Parameters                                                                  : 
15b1			;     Inputs are compile-time only. Two defines which specify the starting    : 
15b1			;     address of the heap and its size are required, along with a memory      : 
15b1			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
15b1			;     principally stores a pointer to the first free block in the heap.       : 
15b1			;                                                                             : 
15b1			; Returns                                                                     : 
15b1			;     Nothing                                                                 : 
15b1			;------------------------------------------------------------------------------ 
15b1			heap_init: 
15b1			      push  HL 
15b1			 
15b1			      ; Initialise free list struct 
15b1			      ld    HL, heap_start 
15b1			      ld    (free_list), HL 
15b1			      ld    HL, 0 
15b1			      ld    (free_list+2), HL 
15b1			 
15b1			      ; Insert first free block at bottom of heap, consumes entire heap 
15b1			      ld    HL, heap_start+heap_size-4 
15b1			      ld    (heap_start), HL        ; Next block (end of free list) 
15b1			      ld    HL, heap_size-4 
15b1			      ld    (heap_start+2), HL      ; Block size 
15b1			 
15b1			      ; Insert end of free list block at top of heap - two null words will 
15b1			      ; terminate the free list 
15b1			      ld    HL, 0 
15b1			      ld    (heap_start+heap_size-2), HL 
15b1			      ld    (heap_start+heap_size-4), HL 
15b1			 
15b1			      pop   HL 
15b1			 
15b1			      ret 
15b1			 
15b1			 
15b1			;------------------------------------------------------------------------------ 
15b1			;     malloc                                                                  : 
15b1			;                                                                             : 
15b1			; Description                                                                 : 
15b1			;     Allocates the wanted space from the heap and returns the address of the : 
15b1			;     first useable byte of the allocation.                                   : 
15b1			;                                                                             : 
15b1			;     Allocations can happen in one of two ways:                              : 
15b1			;                                                                             : 
15b1			;     1. A free block may be found which is the exact size wanted. In this    : 
15b1			;        case the block is removed from the free list and retuedn to the      : 
15b1			;        caller.                                                              : 
15b1			;     2. A free block may be found which is larger than the size wanted. In   : 
15b1			;        this case, the larger block is split into two. The first portion of  : 
15b1			;        this block will become the requested space by the malloc call and    : 
15b1			;        is returned to the caller. The second portion becomes a new free     : 
15b1			;        block, and the free list is adjusted to maintain continuity via this : 
15b1			;        newly created block.                                                 : 
15b1			;                                                                             : 
15b1			;     malloc does not set any initial value in the allocated space, the       : 
15b1			;     caller is required to do this as required.                              : 
15b1			;                                                                             : 
15b1			;     This implementation of malloc uses the stack exclusively, and is        : 
15b1			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15b1			;     advisable to disable interrupts before calling malloc, and recommended  : 
15b1			;     to avoid the use of malloc inside ISRs in general.                      : 
15b1			;                                                                             : 
15b1			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15b1			;                                                                             : 
15b1			; Parameters                                                                  : 
15b1			;     HL  Number of bytes wanted                                              : 
15b1			;                                                                             : 
15b1			; Returns                                                                     : 
15b1			;     HL  Address of the first useable byte of the allocation                 : 
15b1			;                                                                             : 
15b1			; Flags                                                                       : 
15b1			;     Z   Set if the allocation did not succeed, clear otherwise              : 
15b1			;                                                                             : 
15b1			; Stack frame                                                                 : 
15b1			;       |             |                                                       : 
15b1			;       +-------------+                                                       : 
15b1			;       |     BC      |                                                       : 
15b1			;       +-------------+                                                       : 
15b1			;       |     DE      |                                                       : 
15b1			;       +-------------+                                                       : 
15b1			;       |     IX      |                                                       : 
15b1			;       +-------------+                                                       : 
15b1			;       |  prev_free  |                                                       : 
15b1			;   +4  +-------------+                                                       : 
15b1			;       |  this_free  |                                                       : 
15b1			;   +2  +-------------+                                                       : 
15b1			;       |  next_free  |                                                       : 
15b1			;   +0  +-------------+                                                       : 
15b1			;       |             |                                                       : 
15b1			;                                                                             : 
15b1			;------------------------------------------------------------------------------ 
15b1			malloc: 
15b1			      push  BC 
15b1			      push  DE 
15b1			      push  IX 
15b1			 
15b1			      ld    A, H                    ; Exit if no space requested 
15b1			      or    L 
15b1			      jp    Z, malloc_early_exit 
15b1			 
15b1			      ; Set up stack frame 
15b1			      ex    DE, HL 
15b1			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
15b1			      add   HL, SP 
15b1			      ld    SP, HL 
15b1			      ld    IX, 0                   ; Use IX as a frame pointer 
15b1			      add   IX, SP 
15b1			 
15b1			      ; Setup initial state 
15b1			      ld    HL, 4                   ; want must also include space used by block struct 
15b1			      add   HL, DE 
15b1			 
15b1			      ld    B, H                    ; Move want to BC 
15b1			      ld    C, L 
15b1			 
15b1			      ld    HL, free_list           ; Store prev_free ptr to stack 
15b1			      ld    (IX+4), L 
15b1			      ld    (IX+5), H 
15b1			 
15b1			      ld    E, (HL)                 ; Store this_free ptr to stack 
15b1			      inc   HL 
15b1			      ld    D, (HL) 
15b1			      ld    (IX+2), E 
15b1			      ld    (IX+3), D 
15b1			      ex    DE, HL                  ; this_free ptr into HL 
15b1			 
15b1			      ; Loop through free block list to find some space 
15b1			malloc_find_space: 
15b1			      ld    E, (HL)                 ; Load next_free ptr into DE 
15b1			      inc   HL 
15b1			      ld    D, (HL) 
15b1			 
15b1			      ld    A, D                    ; Check for null next_free ptr - end of free list 
15b1			      or    E 
15b1			      jp    Z, malloc_no_space 
15b1			 
15b1			      ld    (IX+0), E               ; Store next_free ptr to stack 
15b1			      ld    (IX+1), D 
15b1			 
15b1			      ; Does this block have enough space to make the allocation? 
15b1			      inc   HL                      ; Load free block size into DE 
15b1			      ld    E, (HL) 
15b1			      inc   HL 
15b1			      ld    D, (HL) 
15b1			 
15b1			      ex    DE, HL                  ; Check size of block against want 
15b1			      or    A                       ; Ensure carry flag clear 
15b1			      sbc   HL, BC 
15b1			      push  HL                      ; Store the result for later (new block size) 
15b1			 
15b1			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
15b1			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
15b1			 
15b1			      ; this_free block is not big enough, setup ptrs to test next free block 
15b1			      pop   HL                      ; Discard previous result 
15b1			 
15b1			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
15b1			      ld    H, (IX+3) 
15b1			      ld    (IX+4), L 
15b1			      ld    (IX+5), H 
15b1			 
15b1			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
15b1			      ld    H, (IX+1) 
15b1			      ld    (IX+2), L 
15b1			      ld    (IX+3), H 
15b1			 
15b1			      jr    malloc_find_space 
15b1			 
15b1			      ; split a bigger block into two - requested size and remaining size 
15b1			malloc_alloc_split: 
15b1			      ex    DE, HL                  ; Calculate address of new free block 
15b1			      dec   HL 
15b1			      dec   HL 
15b1			      dec   HL 
15b1			      add   HL, BC 
15b1			 
15b1			      ; Create a new block and point it at next_free 
15b1			      ld    E, (IX+0)               ; Load next_free ptr into DE 
15b1			      ld    D, (IX+1) 
15b1			 
15b1			      ld    (HL), E                 ; Store next_free ptr into new block 
15b1			      inc   HL 
15b1			      ld    (HL), D 
15b1			 
15b1			      pop   DE                      ; Store size of new block into new block 
15b1			      inc   HL 
15b1			      ld    (HL), E 
15b1			      inc   HL 
15b1			      ld    (HL), D 
15b1			 
15b1			      ; Update this_free ptr to point to new block 
15b1			      dec   HL 
15b1			      dec   HL 
15b1			      dec   HL 
15b1			 
15b1			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
15b1			      ld    D, (IX+3) 
15b1			 
15b1			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
15b1			      ld    (IX+3), H 
15b1			 
15b1			      ; Modify this_free block to be allocation 
15b1			      ex    DE, HL 
15b1			      xor   A                       ; Null the next block ptr of allocated block 
15b1			      ld    (HL), A 
15b1			      inc   HL 
15b1			      ld    (HL), A 
15b1			 
15b1			      inc   HL                      ; Store want size into allocated block 
15b1			      ld    (HL), C 
15b1			      inc   HL 
15b1			      ld    (HL), B 
15b1			      inc   HL 
15b1			      push  HL                      ; Address of allocation to return 
15b1			 
15b1			      jr    malloc_update_links 
15b1			 
15b1			malloc_alloc_fit: 
15b1			      pop   HL                      ; Dont need new block size, want is exact fit 
15b1			 
15b1			      ; Modify this_free block to be allocation 
15b1			      ex    DE, HL 
15b1			      dec   HL 
15b1			      dec   HL 
15b1			      dec   HL 
15b1			 
15b1			      xor   A                       ; Null the next block ptr of allocated block 
15b1			      ld    (HL), A 
15b1			      inc   HL 
15b1			      ld    (HL), A 
15b1			 
15b1			      inc   HL                      ; Store address of allocation to return 
15b1			      inc   HL 
15b1			      inc   HL 
15b1			      push  HL 
15b1			 
15b1			      ; Copy next_free ptr to this_free, remove allocated block from free list 
15b1			      ld    L, (IX+0)               ; next_free to HL 
15b1			      ld    H, (IX+1) 
15b1			 
15b1			      ld    (IX+2), L               ; HL to this_free 
15b1			      ld    (IX+3), H 
15b1			 
15b1			 
15b1			malloc_update_links: 
15b1			      ; Update prev_free ptr to point to this_free 
15b1			      ld    L, (IX+4)               ; prev_free ptr to HL 
15b1			      ld    H, (IX+5) 
15b1			 
15b1			      ld    E, (IX+2)               ; this_free ptr to DE 
15b1			      ld    D, (IX+3) 
15b1			 
15b1			      ld    (HL), E                 ; this_free ptr into prev_free 
15b1			      inc   HL 
15b1			      ld    (HL), D 
15b1			 
15b1			      ; Clear the Z flag to indicate successful allocation 
15b1			      ld    A, D 
15b1			      or    E 
15b1			 
15b1			      pop   DE                      ; Address of allocation 
15b1			 
15b1			malloc_no_space: 
15b1			      ld    HL, 6                   ; Clean up stack frame 
15b1			      add   HL, SP 
15b1			      ld    SP, HL 
15b1			 
15b1			      ex    DE, HL                  ; Alloc addr into HL for return 
15b1			 
15b1			malloc_early_exit: 
15b1			      pop   IX 
15b1			      pop   DE 
15b1			      pop   BC 
15b1			 
15b1			      ret 
15b1			 
15b1			 
15b1			;------------------------------------------------------------------------------ 
15b1			;     free                                                                    : 
15b1			;                                                                             : 
15b1			; Description                                                                 : 
15b1			;     Return the space pointed to by HL to the heap. HL must be an address as : 
15b1			;     returned by malloc, otherwise the behaviour is undefined.               : 
15b1			;                                                                             : 
15b1			;     Where possible, directly adjacent free blocks will be merged together   : 
15b1			;     into larger blocks to help ensure that the heap does not become         : 
15b1			;     excessively fragmented.                                                 : 
15b1			;                                                                             : 
15b1			;     free does not clear or set any other value into the freed space, and    : 
15b1			;     therefore its contents may be visible through subsequent malloc's. The  : 
15b1			;     caller should clear the freed space as required.                        : 
15b1			;                                                                             : 
15b1			;     This implementation of free uses the stack exclusively, and is          : 
15b1			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
15b1			;     advisable to disable interrupts before calling free, and recommended    : 
15b1			;     to avoid the use of free inside ISRs in general.                        : 
15b1			;                                                                             : 
15b1			;     NOTE: heap_init must be called before malloc and free can be used.      : 
15b1			;                                                                             : 
15b1			; Parameters                                                                  : 
15b1			;     HL  Pointer to address of first byte of allocation to be freed          : 
15b1			;                                                                             : 
15b1			; Returns                                                                     : 
15b1			;     Nothing                                                                 : 
15b1			;                                                                             : 
15b1			; Stack frame                                                                 : 
15b1			;       |             |                                                       : 
15b1			;       +-------------+                                                       : 
15b1			;       |     BC      |                                                       : 
15b1			;       +-------------+                                                       : 
15b1			;       |     DE      |                                                       : 
15b1			;       +-------------+                                                       : 
15b1			;       |     IX      |                                                       : 
15b1			;       +-------------+                                                       : 
15b1			;       |  prev_free  |                                                       : 
15b1			;   +2  +-------------+                                                       : 
15b1			;       |  next_free  |                                                       : 
15b1			;   +0  +-------------+                                                       : 
15b1			;       |             |                                                       : 
15b1			;                                                                             : 
15b1			;------------------------------------------------------------------------------ 
15b1			free: 
15b1			      push  BC 
15b1			      push  DE 
15b1			      push  IX 
15b1			 
15b1			      ld    A, H                    ; Exit if ptr is null 
15b1			      or    L 
15b1			      jp    Z, free_early_exit 
15b1			 
15b1			      ; Set up stack frame 
15b1			      ex    DE, HL 
15b1			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
15b1			      add   HL, SP 
15b1			      ld    SP, HL 
15b1			      ld    IX, 0                   ; Use IX as a frame pointer 
15b1			      add   IX, SP 
15b1			 
15b1			      ; The address in HL points to the start of the useable allocated space, 
15b1			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
15b1			      ; address of the block itself. 
15b1			      ex    DE, HL 
15b1			      ld    DE, -4 
15b1			      add   HL, DE 
15b1			 
15b1			      ; An allocated block must have a null next block pointer in it 
15b1			      ld    A, (HL) 
15b1			      inc   HL 
15b1			      or    (HL) 
15b1			      jp    NZ, free_done 
15b1			 
15b1			      dec   HL 
15b1			 
15b1			      ld    B, H                    ; Copy HL to BC 
15b1			      ld    C, L 
15b1			 
15b1			      ; Loop through the free list to find the first block with an address 
15b1			      ; higher than the block being freed 
15b1			      ld    HL, free_list 
15b1			 
15b1			free_find_higher_block: 
15b1			      ld    E, (HL)                 ; Load next ptr from free block 
15b1			      inc   HL 
15b1			      ld    D, (HL) 
15b1			      dec   HL 
15b1			 
15b1			      ld    (IX+0), E               ; Save ptr to next free block 
15b1			      ld    (IX+1), D 
15b1			      ld    (IX+2), L               ; Save ptr to prev free block 
15b1			      ld    (IX+3), H 
15b1			 
15b1			      ld    A, B                    ; Check if DE is greater than BC 
15b1			      cp    D                       ; Compare MSB first 
15b1			      jr    Z, $+4                  ; MSB the same, compare LSB 
15b1			      jr    NC, free_find_higher_block_skip 
15b1			      ld    A, C 
15b1			      cp    E                       ; Then compare LSB 
15b1			      jr    C, free_found_higher_block 
15b1			 
15b1			free_find_higher_block_skip: 
15b1			      ld    A, D                    ; Reached the end of the free list? 
15b1			      or    E 
15b1			      jp    Z, free_done 
15b1			 
15b1			      ex    DE, HL 
15b1			 
15b1			      jr    free_find_higher_block 
15b1			 
15b1			free_found_higher_block: 
15b1			      ; Insert freed block between prev and next free blocks 
15b1			      ld    (HL), C                 ; Point prev free block to freed block 
15b1			      inc   HL 
15b1			      ld    (HL), B 
15b1			 
15b1			      ld    H, B                    ; Point freed block at next free block 
15b1			      ld    L, C 
15b1			      ld    (HL), E 
15b1			      inc   HL 
15b1			      ld    (HL), D 
15b1			 
15b1			      ; Check if the freed block is adjacent to the next free block 
15b1			      inc   HL                      ; Load size of freed block into HL 
15b1			      ld    E, (HL) 
15b1			      inc   HL 
15b1			      ld    D, (HL) 
15b1			      ex    DE, HL 
15b1			 
15b1			      add   HL, BC                  ; Add addr of freed block and its size 
15b1			 
15b1			      ld    E, (IX+0)               ; Load addr of next free block into DE 
15b1			      ld    D, (IX+1) 
15b1			 
15b1			      or    A                       ; Clear the carry flag 
15b1			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
15b1			      jr    NZ, free_check_adjacent_to_prev 
15b1			 
15b1			      ; Freed block is adjacent to next, merge into one bigger block 
15b1			      ex    DE, HL                  ; Load next ptr from next block into DE 
15b1			      ld    E, (HL) 
15b1			      inc   HL 
15b1			      ld    D, (HL) 
15b1			      push  HL                      ; Save ptr to next block for later 
15b1			 
15b1			      ld    H, B                    ; Store ptr from next block into freed block 
15b1			      ld    L, C 
15b1			      ld    (HL), E 
15b1			      inc   HL 
15b1			      ld    (HL), D 
15b1			 
15b1			      pop   HL                      ; Restore ptr to next block 
15b1			      inc   HL                      ; Load size of next block into DE 
15b1			      ld    E, (HL) 
15b1			      inc   HL 
15b1			      ld    D, (HL) 
15b1			      push  DE                      ; Save next block size for later 
15b1			 
15b1			      ld    H, B                    ; Load size of freed block into HL 
15b1			      ld    L, C 
15b1			      inc   HL 
15b1			      inc   HL 
15b1			      ld    E, (HL) 
15b1			      inc   HL 
15b1			      ld    D, (HL) 
15b1			      ex    DE, HL 
15b1			 
15b1			      pop   DE                      ; Restore size of next block 
15b1			      add   HL, DE                  ; Add sizes of both blocks 
15b1			      ex    DE, HL 
15b1			 
15b1			      ld    H, B                    ; Store new bigger size into freed block 
15b1			      ld    L, C 
15b1			      inc   HL 
15b1			      inc   HL 
15b1			      ld    (HL), E 
15b1			      inc   HL 
15b1			      ld    (HL), D 
15b1			 
15b1			free_check_adjacent_to_prev: 
15b1			      ; Check if the freed block is adjacent to the prev free block 
15b1			      ld    L, (IX+2)               ; Prev free block ptr into HL 
15b1			      ld    H, (IX+3) 
15b1			 
15b1			      inc   HL                      ; Size of prev free block into DE 
15b1			      inc   HL 
15b1			      ld    E, (HL) 
15b1			      inc   HL 
15b1			      ld    D, (HL) 
15b1			      dec   HL 
15b1			      dec   HL 
15b1			      dec   HL 
15b1			 
15b1			      add   HL, DE                  ; Add prev block addr and size 
15b1			 
15b1			      or    A                       ; Clear the carry flag 
15b1			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
15b1			      jr    NZ, free_done 
15b1			 
15b1			      ; Freed block is adjacent to prev, merge into one bigger block 
15b1			      ld    H, B                    ; Load next ptr from freed block into DE 
15b1			      ld    L, C 
15b1			      ld    E, (HL) 
15b1			      inc   HL 
15b1			      ld    D, (HL) 
15b1			      push  HL                      ; Save freed block ptr for later 
15b1			 
15b1			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
15b1			      ld    H, (IX+3) 
15b1			      ld    (HL), E 
15b1			      inc   HL 
15b1			      ld    (HL), D 
15b1			 
15b1			      pop   HL                      ; Restore freed block ptr 
15b1			      inc   HL                      ; Load size of freed block into DE 
15b1			      ld    E, (HL) 
15b1			      inc   HL 
15b1			      ld    D, (HL) 
15b1			      push  DE                      ; Save freed block size for later 
15b1			 
15b1			      ld    L, (IX+2)               ; Load size of prev block into DE 
15b1			      ld    H, (IX+3) 
15b1			      inc   HL 
15b1			      inc   HL 
15b1			      ld    E, (HL) 
15b1			      inc   HL 
15b1			      ld    D, (HL) 
15b1			 
15b1			      pop   HL                      ; Add sizes of both blocks 
15b1			      add   HL, DE 
15b1			      ex    DE, HL 
15b1			 
15b1			      ld    L, (IX+2)               ; Store new bigger size into prev block 
15b1			      ld    H, (IX+3) 
15b1			      inc   HL 
15b1			      inc   HL 
15b1			      ld    (HL), E 
15b1			      inc   HL 
15b1			      ld    (HL), D 
15b1			 
15b1			free_done: 
15b1			      ld    HL, 4                   ; Clean up stack frame 
15b1			      add   HL, SP 
15b1			      ld    SP, HL 
15b1			 
15b1			free_early_exit: 
15b1			      pop   IX 
15b1			      pop   DE 
15b1			      pop   BC 
15b1			 
15b1			      ret 
15b1			 
15b1			 
15b1			;      .org 0x8000 
15b1			; 
15b1			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
15b1			 ;                 .dw   0 
15b1			 
15b1			endif 
15b1			 
15b1			 
15b1			if MALLOC_4 
15b1			 
15b1			; My memory allocation code. Very very simple.... 
15b1			; allocate space under 250 chars 
15b1			 
15b1			heap_init: 
15b1				; init start of heap as zero 
15b1				;  
15b1			 
15b1				ld hl, heap_start 
15b1				ld a, 0 
15b1				ld (hl), a      ; empty block 
15b1				inc hl 
15b1				ld a, 0 
15b1				ld (hl), a      ; length of block 
15b1				; write end of list 
15b1				inc hl 
15b1				ld a,(hl) 
15b1				inc hl 
15b1				ld a,(hl) 
15b1				 
15b1			 
15b1				; init some malloc vars 
15b1			 
15b1				ld hl, 0 
15b1				ld (free_list), hl       ; store last malloc location 
15b1			 
15b1				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
15b1				ld a, 0 
15b1				ld (hl), a 
15b1			 
15b1			 
15b1				ld hl, heap_start 
15b1				;  
15b1				  
15b1				ret 
15b1			 
15b1			 
15b1			;    free block marker 
15b1			;    requested size  
15b1			;    pointer to next block 
15b1			;    .... 
15b1			;    next block marker 
15b1			 
15b1			 
15b1			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
15b1			; 
15b1			 
15b1			 
15b1			malloc:  
15b1				push de 
15b1				push bc 
15b1				push af 
15b1			 
15b1				; hl space required 
15b1				 
15b1				ld c, l    ; hold space   (TODO only a max of 255) 
15b1			 
15b1			;	inc c     ; TODO BUG need to fix memory leak on push str 
15b1			;	inc c 
15b1			;	inc c 
15b1			;	inc c 
15b1			;	inc c 
15b1			;	inc c 
15b1			;	inc c 
15b1			 
15b1			 
15b1			 
15b1				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
15b1			 
15b1				ld a, (free_list+3) 
15b1				cp 0 
15b1				jr z, .contheap 
15b1			 
15b1				ld hl, (free_list)     ; get last alloc 
15b1					if DEBUG_FORTH_MALLOC_INT 
15b1						DMARK "mrs" 
15b1						CALLMONITOR 
15b1					endif 
15b1				jr .startalloc 
15b1			 
15b1			.contheap: 
15b1				ld hl, heap_start 
15b1			 
15b1			.startalloc: 
15b1			 
15b1					if DEBUG_FORTH_MALLOC_INT 
15b1						DMARK "mym" 
15b1						CALLMONITOR 
15b1					endif 
15b1			.findblock: 
15b1					if DEBUG_FORTH_MALLOC_INT 
15b1						DMARK "mmf" 
15b1						CALLMONITOR 
15b1					endif 
15b1			 
15b1				ld a,(hl)  
15b1				; if byte is zero then clear to use 
15b1			 
15b1				cp 0 
15b1				jr z, .foundemptyblock 
15b1			 
15b1				; if byte is not clear 
15b1				;     then byte is offset to next block 
15b1			 
15b1				inc hl 
15b1				ld a, (hl) ; get size 
15b1			.nextblock:	inc hl 
15b1					ld e, (hl) 
15b1					inc hl 
15b1					ld d, (hl) 
15b1					ex de, hl 
15b1			;	inc hl  ; move past the store space 
15b1			;	inc hl  ; move past zero index  
15b1			 
15b1				; TODO detect no more space 
15b1			 
15b1				push hl 
15b1				ld de, heap_end 
15b1				call cmp16 
15b1				pop hl 
15b1				jr nc, .nospace 
15b1			 
15b1				jr .findblock 
15b1			 
15b1			.nospace: ld hl, 0 
15b1				jp .exit 
15b1			 
15b1			 
15b1			.foundemptyblock:	 
15b1					if DEBUG_FORTH_MALLOC_INT 
15b1						DMARK "mme" 
15b1						CALLMONITOR 
15b1					endif 
15b1			 
15b1			; TODO has block enough space if reusing??? 
15b1			 
15b1				;  
15b1			 
15b1			; see if this block has been previously used 
15b1				inc hl 
15b1				ld a, (hl) 
15b1				dec hl 
15b1				cp 0 
15b1				jr z, .newblock 
15b1			 
15b1					if DEBUG_FORTH_MALLOC_INT 
15b1						DMARK "meR" 
15b1						CALLMONITOR 
15b1					endif 
15b1			 
15b1			; no reusing previously allocated block 
15b1			 
15b1			; is it smaller than previously used? 
15b1				 
15b1				inc hl    ; move to size 
15b1				ld a, c 
15b1				sub (hl)        ; we want c < (hl) 
15b1				dec hl    ; move back to marker 
15b1			        jr z, .findblock 
15b1			 
15b1				; update with the new size which should be lower 
15b1			 
15b1			        ;inc  hl   ; negate next move. move back to size  
15b1			 
15b1			.newblock: 
15b1				; need to be at marker here 
15b1			 
15b1					if DEBUG_FORTH_MALLOC_INT 
15b1						DMARK "meN" 
15b1						CALLMONITOR 
15b1					endif 
15b1			 
15b1			 
15b1				ld a, c 
15b1			 
15b1				ld (free_list+3), a	 ; flag resume from last malloc  
15b1				ld (free_list), hl    ; save out last location 
15b1			 
15b1			 
15b1				;inc a     ; space for length byte 
15b1				ld (hl), a     ; save block in use marker 
15b1			 
15b1				inc hl   ; move to space marker 
15b1				ld (hl), a    ; save new space 
15b1			 
15b1				inc hl   ; move to start of allocated area 
15b1				 
15b1			;	push hl     ; save where we are - 1  
15b1			 
15b1			;	inc hl  ; move past zero index  
15b1				; skip space to set down new marker 
15b1			 
15b1				; provide some extra space for now 
15b1			 
15b1				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
15b1				inc a 
15b1				inc a 
15b1			 
15b1				push hl   ; save where we are in the node block 
15b1			 
15b1				call addatohl 
15b1			 
15b1				; write linked list point 
15b1			 
15b1				pop de     ; get our node position 
15b1				ex de, hl 
15b1			 
15b1				ld (hl), e 
15b1				inc hl 
15b1				ld (hl), d 
15b1			 
15b1				inc hl 
15b1			 
15b1				; now at start of allocated data so save pointer 
15b1			 
15b1				push hl 
15b1			 
15b1				; jump to position of next node and setup empty header in DE 
15b1			 
15b1				ex de, hl 
15b1			 
15b1			;	inc hl ; move past end of block 
15b1			 
15b1				ld a, 0 
15b1				ld (hl), a   ; empty marker 
15b1				inc hl 
15b1				ld (hl), a   ; size 
15b1				inc hl  
15b1				ld (hl), a   ; ptr 
15b1				inc hl 
15b1				ld (hl), a   ; ptr 
15b1			 
15b1			 
15b1				pop hl 
15b1			 
15b1					if DEBUG_FORTH_MALLOC_INT 
15b1						DMARK "mmr" 
15b1						CALLMONITOR 
15b1					endif 
15b1			 
15b1			.exit: 
15b1				pop af 
15b1				pop bc 
15b1				pop de  
15b1				ret 
15b1			 
15b1			 
15b1			 
15b1			 
15b1			free:  
15b1				push hl 
15b1				push af 
15b1				; get address in hl 
15b1			 
15b1					if DEBUG_FORTH_MALLOC_INT 
15b1						DMARK "fre" 
15b1						CALLMONITOR 
15b1					endif 
15b1				; data is at hl - move to block count 
15b1				dec hl 
15b1				dec hl    ; get past pointer 
15b1				dec hl 
15b1			 
15b1				ld a, (hl)    ; need this for a validation check 
15b1			 
15b1				dec hl    ; move to block marker 
15b1			 
15b1				; now check that the block count and block marker are the same  
15b1			        ; this checks that we are on a malloc node and not random memory 
15b1			        ; OK a faint chance this could be a problem but rare - famous last words! 
15b1			 
15b1				ld c, a 
15b1				ld a, (hl)    
15b1			 
15b1				cp c 
15b1				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
15b1			 
15b1				; yes good chance we are on a malloc node 
15b1			 
15b1				ld a, 0      
15b1				ld (hl), a   ; mark as free 
15b1			 
15b1				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
15b1			 
15b1			.freeignore:  
15b1			 
15b1				pop af 
15b1				pop hl 
15b1			 
15b1				ret 
15b1			 
15b1			 
15b1			 
15b1			endif 
15b1			 
15b1			; eof 
# End of file firmware_memory.asm
15b1			  
15b1			; device C  
15b1			; Now handled by SPI  
15b1			;if SOUND_ENABLE  
15b1			;	include "firmware_sound.asm"  
15b1			;endif  
15b1			  
15b1			include "firmware_diags.asm"  
15b1			; Hardware diags menu 
15b1			 
15b1			 
15b1			config: 
15b1			 
15b1 3e 00			ld a, 0 
15b3 21 d7 15			ld hl, .configmn 
15b6 cd ea 0b			call menu 
15b9			 
15b9 fe 00			cp 0 
15bb c8				ret z 
15bc			 
15bc			;	cp 1 
15bc			;	call z, .savetostore 
15bc			 
15bc fe 01			cp 1 
15be			if STARTUP_V1 
15be cc ed 15			call z, .selautoload 
15c1			endif 
15c1			 
15c1			if STARTUP_V2 
15c1				call z, .enautoload 
15c1			endif 
15c1 fe 02			cp 2 
15c3 cc e3 15			call z, .disautoload 
15c6			;	cp 3 
15c6			;	call z, .selbank 
15c6 fe 03			cp 3 
15c8 cc 0b 16			call z, .debug_tog 
15cb fe 04			cp 4 
15cd cc 59 17			call z, .bpsgo 
15d0 fe 05			cp 5 
15d2 cc 34 16			call z, hardware_diags 
15d5			if STARTUP_V2 
15d5				cp 6 
15d5				call z, create_startup 
15d5			endif 
15d5 18 da			jr config 
15d7			 
15d7			.configmn: 
15d7			;	dw prom_c3 
15d7 47 19			dw prom_c2 
15d9 5c 19			dw prom_c2a 
15db			;	dw prom_c2b 
15db			;	dw prom_c4 
15db 7b 19			dw prom_m4 
15dd 96 19			dw prom_m4b 
15df 9e 19			dw prom_c1 
15e1			if STARTUP_V2 
15e1				dw prom_c9 
15e1			endif 
15e1 00 00			dw 0 
15e3				 
15e3			 
15e3			if STARTUP_V2 
15e3			.enautoload: 
15e3				if STORAGE_SE 
15e3				ld a, $fe      ; bit 0 clear 
15e3				ld (spi_device), a 
15e3			 
15e3				call storage_get_block_0 
15e3			 
15e3				ld a, 1 
15e3				ld (store_page+STORE_0_AUTOFILE), a 
15e3			 
15e3					ld hl, 0 
15e3					ld de, store_page 
15e3				call storage_write_block	 ; save update 
15e3				else 
15e3			 
15e3				ld hl, prom_notav 
15e3				ld de, prom_empty 
15e3				call info_panel 
15e3				endif 
15e3			 
15e3			 
15e3				ret 
15e3			endif 
15e3			 
15e3			.disautoload: 
15e3				if STORAGE_SE 
15e3				ld a, $fe      ; bit 0 clear 
15e3				ld (spi_device), a 
15e3			 
15e3				call storage_get_block_0 
15e3			 
15e3				ld a, 0 
15e3				ld (store_page+STORE_0_AUTOFILE), a 
15e3			 
15e3					ld hl, 0 
15e3					ld de, store_page 
15e3				call storage_write_block	 ; save update 
15e3				else 
15e3			 
15e3 21 ad 19			ld hl, prom_notav 
15e6 11 c3 19			ld de, prom_empty 
15e9 cd 4a 0b			call info_panel 
15ec				endif 
15ec			 
15ec			 
15ec c9				ret 
15ed			 
15ed			if STARTUP_V1 
15ed			 
15ed			; Select auto start 
15ed			 
15ed			.selautoload: 
15ed			 
15ed				 
15ed				if STORAGE_SE 
15ed			 
15ed					call config_dir 
15ed				        ld hl, scratch 
15ed					ld a, 0 
15ed					call menu 
15ed			 
15ed					cp 0 
15ed					ret z 
15ed			 
15ed					dec a 
15ed			 
15ed			 
15ed					; locate menu option 
15ed			 
15ed					ld hl, scratch 
15ed					call table_lookup 
15ed			 
15ed					if DEBUG_FORTH_WORDS 
15ed						DMARK "ALl" 
15ed						CALLMONITOR 
15ed					endif 
15ed					; with the pointer to the menu it, the byte following the zero term is the file id 
15ed			 
15ed					ld a, 0 
15ed					ld bc, 50   ; max of bytes to look at 
15ed					cpir  
15ed			 
15ed					if DEBUG_FORTH_WORDS 
15ed						DMARK "ALb" 
15ed						CALLMONITOR 
15ed					endif 
15ed					;inc hl 
15ed			 
15ed					ld a, (hl)   ; file id 
15ed					 
15ed				        ; save bank and file ids 
15ed			 
15ed					push af 
15ed			 
15ed			; TODO need to save to block 0 on bank 1	 
15ed			 
15ed					call storage_get_block_0 
15ed			 
15ed					if DEBUG_FORTH_WORDS 
15ed						DMARK "AL0" 
15ed						CALLMONITOR 
15ed					endif 
15ed					pop af 
15ed			 
15ed					ld (store_page+STORE_0_FILERUN),a 
15ed					 
15ed					; save bank id 
15ed			 
15ed					ld a,(spi_device) 
15ed					ld (store_page+STORE_0_BANKRUN),a 
15ed			 
15ed					; enable auto run of store file 
15ed			 
15ed					ld a, 1 
15ed					ld (store_page+STORE_0_AUTOFILE),a 
15ed			 
15ed					; save buffer 
15ed			 
15ed					ld hl, 0 
15ed					ld de, store_page 
15ed					if DEBUG_FORTH_WORDS 
15ed						DMARK "ALw" 
15ed						CALLMONITOR 
15ed					endif 
15ed				call storage_write_block	 ; save update 
15ed			  
15ed			 
15ed			 
15ed			 
15ed					ld hl, scratch 
15ed					call config_fdir 
15ed			 
15ed				else 
15ed			 
15ed 21 ad 19			ld hl, prom_notav 
15f0 11 c3 19			ld de, prom_empty 
15f3 cd 4a 0b			call info_panel 
15f6			 
15f6				endif 
15f6 c9				ret 
15f7			endif 
15f7			 
15f7			 
15f7			; Select storage bank 
15f7			 
15f7			.selbank: 
15f7			 
15f7			;	if STORAGE_SE 
15f7			;	else 
15f7			 
15f7 21 ad 19			ld hl, prom_notav 
15fa 11 c3 19			ld de, prom_empty 
15fd cd 4a 0b			call info_panel 
1600			;	endif 
1600				 
1600 c9				ret 
1601			 
1601			if STORAGE_SE 
1601			 
1601			.config_ldir:   
1601				; Load storage bank labels into menu array 
1601			 
1601				 
1601			 
1601			 
1601				ret 
1601			 
1601			 
1601			endif 
1601			 
1601			 
1601			; Save user words to storage 
1601			 
1601			.savetostore: 
1601			 
1601			;	if STORAGE_SE 
1601			; 
1601			;		call config_dir 
1601			;	        ld hl, scratch 
1601			;		ld a, 0 
1601			;		call menu 
1601			;		 
1601			;		ld hl, scratch 
1601			;		call config_fdir 
1601			; 
1601			;	else 
1601			 
1601 21 ad 19			ld hl, prom_notav 
1604 11 c3 19			ld de, prom_empty 
1607 cd 4a 0b			call info_panel 
160a			 
160a			;	endif 
160a			 
160a c9				ret 
160b			 
160b			if STARTUP_V2 
160b			 
160b			create_startup: 
160b			 
160b				ld a, 0 
160b				ld hl, .crstart 
160b				call menu 
160b			 
160b				cp 0 
160b				ret z 
160b			 
160b				cp 1 
160b				call z, .genlsword 
160b				cp 2 
160b				call z, .genedword 
160b			 
160b				cp 3 
160b				call z, .gendemword 
160b			 
160b				cp 4 
160b				call z, .genutlword 
160b				cp 5 
160b				call z, .genspiword 
160b				cp 6 
160b				call z, .genkeyword 
160b				cp 7 
160b				call z, .gensoundword 
160b				jr create_startup 
160b			 
160b			.gensoundword: 
160b				ld hl, crs_sound 
160b				ld de, .soundworddef 
160b				call .genfile 
160b				ret 
160b			.genlsword: 
160b				ld hl, crs_s1 
160b				ld de, .lsworddef 
160b				call .genfile 
160b				ret 
160b			 
160b			.genedword: 
160b				ld de, .edworddef 
160b				ld hl, crs_s2 
160b				call .genfile 
160b				ret 
160b			 
160b			.gendemword: 
160b				ld de, .demoworddef 
160b				ld hl, crs_s3 
160b				call .genfile 
160b				ret 
160b			 
160b			.genutlword: 
160b				ld hl, crs_s4 
160b				ld de, .utilwordef 
160b				call .genfile 
160b				ret 
160b			.genspiword: 
160b				ld hl, crs_s5 
160b				ld de, .spiworddef 
160b				call .genfile 
160b				ret 
160b			.genkeyword: 
160b				ld hl, crs_s6 
160b				ld de, .keyworddef 
160b				call .genfile 
160b				ret 
160b			 
160b			; hl - points to file name 
160b			; de - points to strings to add to file 
160b			 
160b			.genfile: 
160b				push hl 
160b				push de 
160b			 
160b				call clear_display 
160b				ld a, display_row_1 
160b				ld de, .genfiletxt 
160b				call str_at_display 
160b				call update_display 
160b			 
160b				pop de 
160b				pop hl 
160b			 
160b			 
160b				push de 
160b				call storage_create 
160b				; id in hl 
160b				pop de   ; table of strings to add 
160b			 
160b			.genloop: 
160b			 
160b				push hl ; save id for next time around 
160b				push de ; save de for next time around 
160b			 
160b				ex de, hl 
160b				call loadwordinhl 
160b				ex de, hl 
160b			 
160b				; need hl to be the id 
160b				; need de to be the string ptr 
160b				 
160b				call storage_append 
160b			 
160b				pop de 
160b				pop hl 
160b			 
160b				inc de 
160b				inc de 
160b			 
160b				ld a,(de) 
160b				cp 0 
160b				jr nz, .genloop 
160b				inc de 
160b				ld a, (de) 
160b				dec de 
160b				cp 0 
160b				jr nz, .genloop	 
160b			 
160b				ret 
160b			 
160b			.genfiletxt:  db "Creating file...",0 
160b			 
160b			.soundworddef: 
160b				dw sound1 
160b				dw sound2 
160b				dw sound3 
160b				dw sound4 
160b				dw sound5 
160b				dw sound6 
160b				dw sound7 
160b				dw sound8 
160b				dw sound9 
160b				dw 0 
160b			 
160b			.utilwordef: 
160b				dw strncpy 
160b				dw type 
160b				dw clrstack 
160b				dw longread 
160b				dw start1 
160b				dw start2 
160b			; duplicated 
160b			;	dw start3b 
160b			;	dw start3c 
160b				dw list 
160b				dw 0 
160b			 
160b			.lsworddef: 
160b				dw start3b 
160b				dw 0 
160b			 
160b			.edworddef: 
160b				dw edit1 
160b				dw edit2 
160b				dw edit3 
160b				dw 0 
160b			 
160b			.demoworddef: 
160b				dw test5 
160b				dw test6 
160b				dw test7 
160b				dw test8 
160b				dw test9 
160b				dw test10 
160b				dw game1 
160b				dw game1a 
160b				dw game1b 
160b				dw game1c 
160b				dw game1d 
160b				dw game1s 
160b				dw game1t 
160b				dw game1f 
160b				dw game1z 
160b				dw game1zz 
160b				dw ssv2 
160b				dw ssv3 
160b				dw ssv4 
160b				dw ssv5 
160b				dw ssv1 
160b				dw ssv1cpm	 
160b				dw game2b 
160b				dw game2bf 
160b				dw game2mba 
160b				dw game2mbas	 
160b				dw game2mbht 
160b				dw game2mbms 
160b				dw game2mb 
160b				dw game3w 
160b				dw game3p 
160b				dw game3sc 
160b				dw game3vsi 
160b				dw game3vs 
160b				dw 0 
160b			 
160b			 
160b			.spiworddef: 
160b			 
160b			    dw spi1 
160b			    dw spi2 
160b			    dw spi2b 
160b			    dw spi3 
160b			    dw spi4 
160b			    dw spi5 
160b			;    dw spi6 
160b			;    dw spi7 
160b			 
160b			;    dw spi8 
160b			;    dw spi9 
160b			;    dw spi10 
160b			    dw 0 
160b			 
160b			.keyworddef: 
160b			 
160b				dw keyup 
160b				dw keydown 
160b				dw keyleft 
160b				dw keyright 
160b				dw 	keyf1 
160b				dw keyf2 
160b				dw keyf3 
160b				dw keyf4 
160b				dw keyf5 
160b				dw keyf6 
160b				dw keyf7 
160b				dw keyf8 
160b				dw keyf9 
160b				dw keyf10 
160b				dw keyf11 
160b				dw keyf12 
160b				dw keytab 
160b				dw keycr 
160b				dw keyhome 
160b				dw keyend 
160b				dw keybs 
160b				dw 0 
160b			 
160b			.crstart: 
160b				dw crs_s1 
160b				dw crs_s2 
160b				dw crs_s3 
160b				dw crs_s4 
160b				dw crs_s5 
160b				dw crs_s6 
160b				dw crs_sound 
160b				dw 0 
160b			 
160b			endif 
160b			 
160b			 
160b			if STORAGE_SE 
160b			 
160b			config_fdir: 
160b				; using the scratch dir go through and release the memory allocated for each string 
160b				 
160b				ld hl, scratch 
160b			.cfdir:	ld e,(hl) 
160b				inc hl 
160b				ld d,(hl) 
160b				inc hl 
160b			 
160b				ex de, hl 
160b				call ishlzero 
160b				ret z     ; return on null pointer 
160b				call free 
160b				ex de, hl 
160b				jr .cfdir 
160b			 
160b			 
160b				ret 
160b			 
160b			 
160b			config_dir: 
160b			 
160b				; for the config menus that need to build a directory of storage call this routine 
160b				; it will construct a menu in scratch to pass to menu 
160b			 
160b				; open storage device 
160b			 
160b				; execute DIR to build a list of files and their ids into scratch in menu format 
160b				; once the menu has finished then will need to call config_fdir to release the strings 
160b				 
160b				; c = number items 
160b			 
160b				 
160b				call storage_get_block_0 
160b			 
160b				ld hl, store_page     ; get current id count 
160b				ld b, (hl) 
160b				ld c, 0    ; count of files   
160b			 
160b			 
160b				ld hl, scratch 
160b				ld (store_tmp2), hl    ; location to poke strings 
160b			 
160b				; check for empty drive 
160b			 
160b				ld a, 0 
160b				cp b 
160b				jp z, .dirdone 
160b			 
160b				 
160b					if DEBUG_FORTH_WORDS 
160b						DMARK "Cdc" 
160b						CALLMONITOR 
160b					endif 
160b			 
160b			 
160b			.diritem:	 
160b				push bc 
160b				; for each of the current ids do a search for them and if found push to stack 
160b			 
160b					ld hl, STORE_BLOCK_PHY 
160b					ld d, 0		 ; look for extent 0 of block id as this contains file name 
160b					ld e,b 
160b			 
160b					call storage_findnextid 
160b			 
160b			 
160b					; if found hl will be non zero 
160b			 
160b					call ishlzero 
160b					jr z, .dirnotfound 
160b			 
160b					; increase count 
160b			 
160b					pop bc	 
160b					inc c 
160b					push bc 
160b					 
160b			 
160b					; get file header and push the file name 
160b			 
160b					ld de, store_page 
160b					call storage_read_block 
160b			 
160b					; push file id to stack 
160b				 
160b					ld a, (store_page) 
160b					ld h, 0 
160b					ld l, a 
160b			 
160b					;call forth_push_numhl 
160b					; TODO store id 
160b			 
160b					push hl 
160b			 
160b					; push extent count to stack  
160b				 
160b					ld hl, store_page+3 
160b			 
160b					; get file name length 
160b			 
160b					call strlenz   
160b			 
160b					inc hl   ; cover zero term 
160b					inc hl  ; stick the id at the end of the area 
160b			 
160b					push hl 
160b					pop bc    ; move length to bc 
160b			 
160b					call malloc 
160b			 
160b					; TODO save malloc area to scratch 
160b			 
160b					ex de, hl 
160b					ld hl, (store_tmp2) 
160b					ld (hl), e 
160b					inc hl 
160b					ld (hl), d 
160b					inc hl 
160b					ld (store_tmp2), hl 
160b			 
160b					 
160b			 
160b					;pop hl   ; get source 
160b			;		ex de, hl    ; swap aronund	 
160b			 
160b					ld hl, store_page+3 
160b					if DEBUG_FORTH_WORDS 
160b						DMARK "CFd" 
160b						CALLMONITOR 
160b					endif 
160b					ldir 
160b			 
160b					; de is past string, move back one and store id 
160b					 
160b					dec de 
160b			 
160b					; store file id 
160b			 
160b					pop hl 
160b					ex de,hl 
160b					ld (hl), e 
160b			 
160b					if DEBUG_FORTH_WORDS 
160b						DMARK "Cdi" 
160b						CALLMONITOR 
160b					endif 
160b					 
160b			.dirnotfound: 
160b					pop bc     
160b					djnz .diritem 
160b				 
160b			.dirdone:	 
160b			 
160b					ld a, 0 
160b					ld hl, (store_tmp2) 
160b					ld (hl), a 
160b					inc hl 
160b					ld (hl), a 
160b					inc hl 
160b					; push a count of the dir items found 
160b			 
160b			;		ld h, 0 
160b			;		ld l, c 
160b			 
160b				ret 
160b			 
160b			endif 
160b			 
160b			 
160b			; Settings 
160b			; Run  
160b			 
160b			 
160b			 
160b			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
160b			;;hd_menu2:   db "        2: Editor",0   
160b			;hd_menu2:   db "        2: Editor       6: Menu",0   
160b			;hd_menu3:   db "        3: Storage",0 
160b			;hd_menu4:   db "0=quit  4: Debug",0 
160b			;hd_don:     db "ON",0 
160b			;hd_doff:     db "OFF",0 
160b			; 
160b			; 
160b			; 
160b			;hardware_diags_old:       
160b			; 
160b			;.diagmenu: 
160b			;	call clear_display 
160b			;	ld a, display_row_1 
160b			;	ld de, hd_menu1 
160b			;	call str_at_display 
160b			; 
160b			;	ld a, display_row_2 
160b			;	ld de, hd_menu2 
160b			;	call str_at_display 
160b			; 
160b			;	ld a, display_row_3 
160b			;	ld de, hd_menu3 
160b			;	call str_at_display 
160b			; 
160b			;	ld a,  display_row_4 
160b			;	ld de, hd_menu4 
160b			;	call str_at_display 
160b			; 
160b			;	; display debug state 
160b			; 
160b			;	ld de, hd_don 
160b			;	ld a, (os_view_disable) 
160b			;	cp 0 
160b			;	jr z, .distog 
160b			;	ld de, hd_doff 
160b			;.distog: ld a, display_row_4+17 
160b			;	call str_at_display 
160b			; 
160b			;	call update_display 
160b			; 
160b			;	call cin_wait 
160b			; 
160b			; 
160b			; 
160b			;	cp '4' 
160b			;	jr nz, .diagn1 
160b			; 
160b			;	; debug toggle 
160b			; 
160b			;	ld a, (os_view_disable) 
160b			;	ld b, '*' 
160b			;	cp 0 
160b			;	jr z, .debtog 
160b			;	ld b, 0 
160b			;.debtog:	 
160b			;	ld a,b 
160b			;	ld (os_view_disable),a 
160b			; 
160b			;.diagn1: cp '0' 
160b			;	 ret z 
160b			; 
160b			;;	cp '1' 
160b			;;       jp z, matrix	 
160b			;;   TODO keyboard matrix test 
160b			; 
160b			;	cp '2' 
160b			;	jp z, .diagedit 
160b			; 
160b			;;	cp '6' 
160b			;;	jp z, .menutest 
160b			;;if ENABLE_BASIC 
160b			;;	cp '6' 
160b			;;	jp z, basic 
160b			;;endif 
160b			 ; 
160b			;	jp .diagmenu 
160b			; 
160b			; 
160b			;	ret 
160b			 
160b			 
160b			.debug_tog: 
160b 21 55 16			ld hl, .menudebug 
160e				 
160e			;	ld a, (os_view_disable) 
160e			;	cp '*' 
160e 3a 6f ee			ld a,(debug_vector) 
1611 fe c9			cp $C9   ; RET 
1613 20 04			jr nz,.tdon  
1615 3e 01			ld a, 1 
1617 18 02			jr .tog1 
1619 3e 00		.tdon: ld a, 0 
161b			 
161b			.tog1: 
161b cd ea 0b			call menu 
161e fe 00			cp 0 
1620 c8				ret z 
1621 fe 01			cp 1    ; disable debug 
1623 28 04			jr z, .dtog0 
1625 3e 2a			ld a, '*' 
1627 18 05			jr .dtogset 
1629			.dtog0:  
1629				;ld a, 0 
1629 cd 47 17			call bp_on 
162c 18 dd			jr .debug_tog 
162e			.dtogset:  
162e				; ld (os_view_disable), a 
162e cd 53 17			call bp_off 
1631 c3 0b 16			jp .debug_tog 
1634			 
1634			 
1634			hardware_diags:       
1634			 
1634			.diagm: 
1634 21 47 16			ld hl, .menuitems 
1637 3e 00			ld a, 0 
1639 cd ea 0b			call menu 
163c			 
163c fe 00		         cp 0 
163e c8				 ret z 
163f			 
163f fe 02			cp 2 
1641 ca a0 16			jp z, .diagedit 
1644			 
1644			;	cp '6' 
1644			;	jp z, .menutest 
1644			;if ENABLE_BASIC 
1644			;	cp '6' 
1644			;	jp z, basic 
1644			;endif 
1644			  
1644 c3 34 16			jp .diagm 
1647			 
1647				 
1647 5b 16		.menuitems:   	dw .m1 
1649 66 16				dw .m2 
164b 6d 16				dw .m3 
164d 75 16				dw .m5 
164f 7b 16				dw .m5a 
1651 84 16				dw .m5b 
1653 00 00				dw 0 
1655			 
1655			.menudebug: 
1655 8d 16				dw .m6 
1657 96 16				dw .m7 
1659 00 00				dw 0 
165b			 
165b .. 00		.m1:   db "Key Matrix",0 
1666 .. 00		.m2:   db "Editor",0 
166d .. 00		.m3:   db "Storage",0 
1675 .. 00		.m5:   db "Sound",0 
167b .. 00		.m5a:  db "RAM Test",0 
1684 .. 00		.m5b:  db "LCD Test",0 
168d			 
168d .. 00		.m6:   db "Debug ON",0 
1696 .. 00		.m7:   db "Debug OFF",0 
16a0			 
16a0			; debug editor 
16a0			 
16a0			.diagedit: 
16a0			 
16a0 21 c1 e2			ld hl, scratch 
16a3			;	ld bc, 250 
16a3			;	ldir 
16a3				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
16a3 3e 00			ld a, 0 
16a5 77				ld (hl), a 
16a6 23				inc hl 
16a7 77				ld (hl), a 
16a8 23				inc hl 
16a9 77				ld (hl), a 
16aa			 
16aa cd b9 0b		        call clear_display 
16ad cd dc 0b			call update_display 
16b0				;ld a, 1 
16b0				;ld (hardware_diag), a 
16b0			.diloop: 
16b0 3e 00			ld a, display_row_1 
16b2 0e 00			ld c, 0 
16b4 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
16b6 1e 28			ld e, 40 
16b8			 
16b8 21 c1 e2			ld hl, scratch	 
16bb cd 13 0e			call input_str 
16be			 
16be 3e 28			ld a, display_row_2 
16c0 11 c1 e2			ld de, scratch 
16c3 cd cc 0b			call str_at_display 
16c6 cd dc 0b			call update_display 
16c9			 
16c9 c3 b0 16			jp .diloop 
16cc			 
16cc			 
16cc			; pass word in hl 
16cc			; a has display location 
16cc			display_word_at: 
16cc f5				push af 
16cd e5				push hl 
16ce 7c				ld a,h 
16cf 21 c6 e5			ld hl, os_word_scratch 
16d2 cd 46 12			call hexout 
16d5 e1				pop hl 
16d6 7d				ld a,l 
16d7 21 c8 e5			ld hl, os_word_scratch+2 
16da cd 46 12			call hexout 
16dd 21 ca e5			ld hl, os_word_scratch+4 
16e0 3e 00			ld a,0 
16e2 77				ld (hl),a 
16e3 11 c6 e5			ld de,os_word_scratch 
16e6 f1				pop af 
16e7 cd cc 0b				call str_at_display 
16ea c9				ret 
16eb			 
16eb			display_ptr_state: 
16eb			 
16eb				; to restore afterwards 
16eb			 
16eb d5				push de 
16ec c5				push bc 
16ed e5				push hl 
16ee f5				push af 
16ef			 
16ef				; for use in here 
16ef			 
16ef			;	push bc 
16ef			;	push de 
16ef			;	push hl 
16ef			;	push af 
16ef			 
16ef cd b9 0b			call clear_display 
16f2			 
16f2 11 ca 18			ld de, .ptrstate 
16f5 3e 00			ld a, display_row_1 
16f7 cd cc 0b			call str_at_display 
16fa			 
16fa				; display debug step 
16fa			 
16fa			 
16fa 11 6b ee			ld de, debug_mark 
16fd 3e 26			ld a, display_row_1+display_cols-2 
16ff cd cc 0b			call str_at_display 
1702			 
1702				; display a 
1702 11 d4 18			ld de, .ptrcliptr 
1705 3e 28			ld a, display_row_2 
1707 cd cc 0b			call str_at_display 
170a			 
170a f1				pop af 
170b 2a 40 ea			ld hl,(cli_ptr) 
170e 3e 30			ld a, display_row_2+8 
1710 cd cc 16			call display_word_at 
1713			 
1713			 
1713				; display hl 
1713			 
1713			 
1713 11 dc 18			ld de, .ptrclioptr 
1716 3e 32			ld a, display_row_2+10 
1718 cd cc 0b			call str_at_display 
171b			; 
171b			;	pop hl 
171b 3e 35			ld a, display_row_2+13 
171d 2a 3e ea			ld hl,(cli_origptr) 
1720 cd cc 16			call display_word_at 
1723			; 
1723			;	 
1723			;	; display de 
1723			 
1723			;	ld de, .regstatede 
1723			;	ld a, display_row_3 
1723			;	call str_at_display 
1723			 
1723			;	pop de 
1723			;	ld h,d 
1723			;	ld l, e 
1723			;	ld a, display_row_3+3 
1723			;	call display_word_at 
1723			 
1723			 
1723				; display bc 
1723			 
1723			;	ld de, .regstatebc 
1723			;	ld a, display_row_3+10 
1723			;	call str_at_display 
1723			 
1723			;	pop bc 
1723			;	ld h,b 
1723			;	ld l, c 
1723			;	ld a, display_row_3+13 
1723			;	call display_word_at 
1723			 
1723			 
1723				; display dsp 
1723			 
1723			;	ld de, .regstatedsp 
1723			;	ld a, display_row_4 
1723			;	call str_at_display 
1723			 
1723				 
1723			;	ld hl,(cli_data_sp) 
1723			;	ld a, display_row_4+4 
1723			;	call display_word_at 
1723			 
1723				; display rsp 
1723			 
1723 11 0b 19			ld de, .regstatersp 
1726 3e 82			ld a, display_row_4+10 
1728 cd cc 0b			call str_at_display 
172b			 
172b				 
172b 2a f2 e9			ld hl,(cli_ret_sp) 
172e 3e 86			ld a, display_row_4+14 
1730 cd cc 16			call display_word_at 
1733			 
1733 cd dc 0b			call update_display 
1736			 
1736 cd f1 0a			call delay1s 
1739 cd f1 0a			call delay1s 
173c cd f1 0a			call delay1s 
173f			 
173f			 
173f cd 29 1d			call next_page_prompt 
1742			 
1742				; restore  
1742			 
1742 f1				pop af 
1743 e1				pop hl 
1744 c1				pop bc 
1745 d1				pop de 
1746 c9				ret 
1747			 
1747			; Update the break point vector so that the user can hook a new routine 
1747			 
1747			bp_on: 
1747 3e c3			ld a, $c3    ; JP 
1749 32 6f ee			ld (debug_vector), a 
174c 21 59 17			ld hl, break_point_state 
174f 22 70 ee			ld (debug_vector+1), hl 
1752 c9				ret 
1753			 
1753			bp_off: 
1753 3e c9			ld a, $c9    ; RET 
1755 32 6f ee			ld (debug_vector), a 
1758 c9				ret 
1759			 
1759			 
1759			break_point_state: 
1759			;	push af 
1759			; 
1759			;	; see if disabled 
1759			; 
1759			;	ld a, (os_view_disable) 
1759			;	cp '*' 
1759			;	jr nz, .bpsgo 
1759			;	pop af 
1759			;	ret 
1759			 
1759			.bpsgo: 
1759			;	pop af 
1759 f5				push af 
175a 22 a3 e2			ld (os_view_hl), hl 
175d ed 53 a1 e2		ld (os_view_de), de 
1761 ed 43 9f e2		ld (os_view_bc), bc 
1765 e5				push hl 
1766 6f				ld l, a 
1767 26 00			ld h, 0 
1769 22 a5 e2			ld (os_view_af),hl 
176c			 
176c 21 b1 ed				ld hl, display_fb0 
176f 22 cc eb				ld (display_fb_active), hl 
1772 e1				pop hl	 
1773			 
1773 3e 31			ld a, '1' 
1775 fe 2a		.bps1:  cp '*' 
1777 cc 53 17			call z, bp_off 
177a			;	jr nz, .bps1b 
177a			;	ld (os_view_disable),a 
177a fe 31		.bps1b:  cp '1' 
177c 20 14			jr nz, .bps2 
177e			 
177e				; display reg 
177e			 
177e				 
177e			 
177e 3a a5 e2			ld a, (os_view_af) 
1781 2a a3 e2			ld hl, (os_view_hl) 
1784 ed 5b a1 e2		ld de, (os_view_de) 
1788 ed 4b 9f e2		ld bc, (os_view_bc) 
178c cd 26 18			call display_reg_state 
178f c3 12 18			jp .bpschk 
1792			 
1792 fe 32		.bps2:  cp '2' 
1794 20 08			jr nz, .bps3 
1796				 
1796				; display hl 
1796 2a a3 e2			ld hl, (os_view_hl) 
1799 cd 10 19			call display_dump_at_hl 
179c			 
179c 18 74			jr .bpschk 
179e			 
179e fe 33		.bps3:  cp '3' 
17a0 20 08			jr nz, .bps4 
17a2			 
17a2			        ; display de 
17a2 2a a1 e2			ld hl, (os_view_de) 
17a5 cd 10 19			call display_dump_at_hl 
17a8			 
17a8 18 68			jr .bpschk 
17aa fe 34		.bps4:  cp '4' 
17ac 20 08			jr nz, .bps5 
17ae			 
17ae			        ; display bc 
17ae 2a 9f e2			ld hl, (os_view_bc) 
17b1 cd 10 19			call display_dump_at_hl 
17b4			 
17b4 18 5c			jr .bpschk 
17b6 fe 35		.bps5:  cp '5' 
17b8 20 08		        jr nz, .bps7 
17ba			 
17ba				; display cur ptr 
17ba 2a 40 ea			ld hl, (cli_ptr) 
17bd cd 10 19			call display_dump_at_hl 
17c0			 
17c0 18 50			jr .bpschk 
17c2 fe 36		.bps7:  cp '6' 
17c4 20 08			jr nz, .bps8b 
17c6				 
17c6				; display cur orig ptr 
17c6 2a 3e ea			ld hl, (cli_origptr) 
17c9 cd 10 19			call display_dump_at_hl 
17cc 18 44			jr .bpschk 
17ce fe 37		.bps8b:  cp '7' 
17d0 20 08			jr nz, .bps9 
17d2				 
17d2				; display dsp 
17d2 2a ee e9			ld hl, (cli_data_sp) 
17d5 cd 10 19			call display_dump_at_hl 
17d8			 
17d8 18 38			jr .bpschk 
17da fe 39		.bps9:  cp '9' 
17dc 20 05			jr nz, .bps8c 
17de				 
17de				; display SP 
17de			;	ld hl, sp 
17de cd 10 19			call display_dump_at_hl 
17e1			 
17e1 18 2f			jr .bpschk 
17e3 fe 38		.bps8c:  cp '8' 
17e5 20 08			jr nz, .bps8d 
17e7				 
17e7				; display rsp 
17e7 2a f2 e9			ld hl, (cli_ret_sp) 
17ea cd 10 19			call display_dump_at_hl 
17ed			 
17ed 18 23			jr .bpschk 
17ef fe 23		.bps8d:  cp '#'     ; access monitor sub system 
17f1 20 05			jr nz, .bps8 
17f3 cd f7 1a			call monitor 
17f6			 
17f6 18 1a			jr .bpschk 
17f8 fe 30		.bps8:  cp '0' 
17fa 20 16			jr nz, .bpschk 
17fc			 
17fc 21 10 ed				ld hl, display_fb1 
17ff 22 cc eb				ld (display_fb_active), hl 
1802 cd dc 0b				call update_display 
1805			 
1805				;ld a, (os_view_af) 
1805 2a a3 e2			ld hl, (os_view_hl) 
1808 ed 5b a1 e2		ld de, (os_view_de) 
180c ed 4b 9f e2		ld bc, (os_view_bc) 
1810 f1				pop af 
1811 c9				ret 
1812			 
1812			.bpschk:   
1812 cd f1 0a			call delay1s 
1815 3e 9f		ld a,display_row_4 + display_cols - 1 
1817 11 27 1d		        ld de, endprg 
181a cd cc 0b			call str_at_display 
181d cd dc 0b			call update_display 
1820 cd 85 67			call cin_wait 
1823			 
1823 c3 75 17			jp .bps1 
1826			 
1826			 
1826			display_reg_state: 
1826			 
1826				; to restore afterwards 
1826			 
1826 d5				push de 
1827 c5				push bc 
1828 e5				push hl 
1829 f5				push af 
182a			 
182a				; for use in here 
182a			 
182a c5				push bc 
182b d5				push de 
182c e5				push hl 
182d f5				push af 
182e			 
182e cd b9 0b			call clear_display 
1831			 
1831 11 e6 18			ld de, .regstate 
1834 3e 00			ld a, display_row_1 
1836 cd cc 0b			call str_at_display 
1839			 
1839				; display debug step 
1839			 
1839			 
1839 11 6b ee			ld de, debug_mark 
183c 3e 25			ld a, display_row_1+display_cols-3 
183e cd cc 0b			call str_at_display 
1841			 
1841				; display a 
1841 11 02 19			ld de, .regstatea 
1844 3e 28			ld a, display_row_2 
1846 cd cc 0b			call str_at_display 
1849			 
1849 e1				pop hl 
184a			;	ld h,0 
184a			;	ld l, a 
184a 3e 2b			ld a, display_row_2+3 
184c cd cc 16			call display_word_at 
184f			 
184f			 
184f				; display hl 
184f			 
184f			 
184f 11 f6 18			ld de, .regstatehl 
1852 3e 32			ld a, display_row_2+10 
1854 cd cc 0b			call str_at_display 
1857			 
1857 e1				pop hl 
1858 3e 35			ld a, display_row_2+13 
185a cd cc 16			call display_word_at 
185d			 
185d				 
185d				; display de 
185d			 
185d 11 fa 18			ld de, .regstatede 
1860 3e 50			ld a, display_row_3 
1862 cd cc 0b			call str_at_display 
1865			 
1865 e1				pop hl 
1866			;	ld h,d 
1866			;	ld l, e 
1866 3e 53			ld a, display_row_3+3 
1868 cd cc 16			call display_word_at 
186b			 
186b			 
186b				; display bc 
186b			 
186b 11 fe 18			ld de, .regstatebc 
186e 3e 5a			ld a, display_row_3+10 
1870 cd cc 0b			call str_at_display 
1873			 
1873 e1				pop hl 
1874			;	ld h,b 
1874			;	ld l, c 
1874 3e 5d			ld a, display_row_3+13 
1876 cd cc 16			call display_word_at 
1879			 
1879			 
1879				; display dsp 
1879			 
1879 11 06 19			ld de, .regstatedsp 
187c 3e 78			ld a, display_row_4 
187e cd cc 0b			call str_at_display 
1881			 
1881				 
1881 2a ee e9			ld hl,(cli_data_sp) 
1884 3e 7c			ld a, display_row_4+4 
1886 cd cc 16			call display_word_at 
1889			 
1889				; display rsp 
1889			 
1889 11 0b 19			ld de, .regstatersp 
188c 3e 82			ld a, display_row_4+10 
188e cd cc 0b			call str_at_display 
1891			 
1891				 
1891 2a f2 e9			ld hl,(cli_ret_sp) 
1894 3e 86			ld a, display_row_4+14 
1896 cd cc 16			call display_word_at 
1899			 
1899 cd dc 0b			call update_display 
189c			 
189c			;	call delay1s 
189c			;	call delay1s 
189c			;	call delay1s 
189c			 
189c			 
189c			;	call next_page_prompt 
189c			 
189c				; restore  
189c			 
189c f1				pop af 
189d e1				pop hl 
189e c1				pop bc 
189f d1				pop de 
18a0 c9				ret 
18a1			 
18a1 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
18b5 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
18ca .. 00		.ptrstate:	db "Ptr State",0 
18d4 .. 00		.ptrcliptr:     db "cli_ptr",0 
18dc .. 00		.ptrclioptr:     db "cli_o_ptr",0 
18e6 .. 00		.regstate:	db "Reg State (1/0)",0 
18f6 .. 00		.regstatehl:	db "HL:",0 
18fa .. 00		.regstatede:	db "DE:",0 
18fe .. 00		.regstatebc:	db "BC:",0 
1902 .. 00		.regstatea:	db "A :",0 
1906 .. 00		.regstatedsp:	db "DSP:",0 
190b .. 00		.regstatersp:	db "RSP:",0 
1910			 
1910			display_dump_at_hl: 
1910 e5				push hl 
1911 d5				push de 
1912 c5				push bc 
1913 f5				push af 
1914			 
1914 22 e4 e5			ld (os_cur_ptr),hl	 
1917 cd b9 0b			call clear_display 
191a cd 31 1c			call dumpcont 
191d			;	call delay1s 
191d			;	call next_page_prompt 
191d			 
191d			 
191d f1				pop af 
191e c1				pop bc 
191f d1				pop de 
1920 e1				pop hl 
1921 c9				ret 
1922			 
1922			;if ENABLE_BASIC 
1922			;	include "nascombasic.asm" 
1922			;	basic: 
1922			;	include "forth/FORTH.ASM" 
1922			;endif 
1922			 
1922			; eof 
1922			 
1922			 
# End of file firmware_diags.asm
1922			  
1922			include "firmware_prompts.asm"  
1922			; Prompts  
1922			 
1922			; boot messages 
1922			 
1922 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1937 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1947			 
1947			 
1947			; config menus 
1947			 
1947			;prom_c3: db "Add Dictionary To File",0 
1947			 
1947			if STARTUP_V1 
1947 .. 00		prom_c2: db "Select Autoload File",0 
195c .. 00		prom_c2a: db "Disable Autoload File", 0 
1972			endif 
1972			 
1972			if STARTUP_V2 
1972			prom_c2: db "Enable Autoload Files",0 
1972			prom_c2a: db "Disable Autoload Files", 0 
1972			 
1972			crs_s1: db "*ls-word", 0 
1972			crs_s2: db "*ed-word", 0 
1972			crs_s3: db "*Demo-Programs", 0 
1972			crs_s4: db "*Utils", 0 
1972			crs_s5: db "*SPI-Util", 0 
1972			crs_s6: db "*Key-constants", 0 
1972			crs_sound: db "*Sound-Util", 0 
1972			 
1972			 
1972			 
1972			endif 
1972			;prom_c2b: db "Select Storage Bank",0 
1972 .. 00		prom_c4: db "Settings",0 
197b .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1996 .. 00		prom_m4b:   db "Monitor",0 
199e .. 00		prom_c1: db "Hardware Diags",0 
19ad			 
19ad			 
19ad			if STARTUP_V2 
19ad			prom_c9: db "Create Startup Files",0 
19ad			endif 
19ad			 
19ad .. 00		prom_notav:    db "Feature not available",0 
19c3 .. 00		prom_empty:    db "",0 
19c4			 
19c4			; eof 
19c4			 
# End of file firmware_prompts.asm
19c4			  
19c4			  
19c4			; eof  
19c4			  
# End of file firmware.asm
19c4			 
19c4			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
19c4			;if BASE_KEV  
19c4			;baseram: equ 08000h 
19c4			;endif 
19c4			 
19c4			;if BASE_SC114 
19c4			;baseram:     equ    endofcode 
19c4			;endif 
19c4			 
19c4			 
19c4			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
19c4			 
19c4			; start system 
19c4			 
19c4			coldstart: 
19c4				; set sp 
19c4				; di/ei 
19c4			 
19c4 f3				di 
19c5 31 00 f0			ld sp, tos 
19c8 cd 83 66			call init_nmi 
19cb			;	ei 
19cb			 
19cb				; init spinner 
19cb 3e 00			ld a,0 
19cd 32 c6 eb			ld (display_active), a 
19d0			 
19d0				; disable breakpoint by default 
19d0			 
19d0				;ld a,'*' 
19d0			;	ld a,' ' 
19d0			;	ld (os_view_disable),a 
19d0			 
19d0				; set break point vector as new break point on or off 
19d0 cd 53 17			call bp_off 
19d3			 
19d3				; init hardware 
19d3			 
19d3				; init keyboard and screen hardware 
19d3			 
19d3 cd 1b 01			call hardware_init 
19d6			 
19d6			 
19d6 cd f1 0a			call delay1s 
19d9 3e 58			ld a, display_row_3+8 
19db 11 03 01			ld de, buildtime 
19de cd cc 0b			call str_at_display 
19e1 cd dc 0b			call update_display 
19e4			 
19e4 cd f1 0a			call delay1s 
19e7 cd f1 0a			call delay1s 
19ea cd f1 0a			call delay1s 
19ed			 
19ed				; detect if any keys are held down to enable breakpoints at start up 
19ed			 
19ed cd 8d 67			call cin  
19f0 fe 00			cp 0 
19f2 28 03			jr z, .nokeys 
19f4			 
19f4				;call hardware_diags 
19f4 cd b1 15			call config 
19f7			 
19f7			;	ld de, .bpen 
19f7			;	ld a, display_row_4 
19f7			;	call str_at_display 
19f7			;	call update_display 
19f7			; 
19f7			;	ld a,0 
19f7			;	ld (os_view_disable),a 
19f7			; 
19f7			;.bpwait: 
19f7			;	call cin 
19f7			;	cp 0 
19f7			;	jr z, .bpwait 
19f7			;	jr .nokeys 
19f7			; 
19f7			; 
19f7			;.bpen:  db "Break points enabled!",0 
19f7			 
19f7			 
19f7			 
19f7			 
19f7			 
19f7			 
19f7			.nokeys: 
19f7			 
19f7			 
19f7				 
19f7			 
19f7			;jp  testkey 
19f7			 
19f7			;call storage_get_block_0 
19f7			; 
19f7			;ld hl, 0 
19f7			;ld de, store_page 
19f7			;call storage_read_block 
19f7			 
19f7				 
19f7			;ld hl, 10 
19f7			;ld de, store_page 
19f7			;call storage_read_block 
19f7			 
19f7			 
19f7			 
19f7			 
19f7			 
19f7			;stop:	nop 
19f7			;	jp stop 
19f7			 
19f7			 
19f7			 
19f7			main: 
19f7 cd b9 0b			call clear_display 
19fa cd dc 0b			call update_display 
19fd			 
19fd			 
19fd			 
19fd			;	call testlcd 
19fd			 
19fd			 
19fd			 
19fd cd 2e 21			call forth_init 
1a00			 
1a00			 
1a00			warmstart: 
1a00 cd 04 21			call forth_warmstart 
1a03			 
1a03				; run startup word load 
1a03			        ; TODO prevent this running at warmstart after crash  
1a03			 
1a03				if STARTUP_ENABLE 
1a03			 
1a03					if STARTUP_V1 
1a03			 
1a03						if STORAGE_SE 
1a03							call forth_autoload 
1a03						endif 
1a03 cd d3 65					call forth_startup 
1a06					endif 
1a06			 
1a06					if STARTUP_V2 
1a06			 
1a06						if STORAGE_SE 
1a06							call forth_autoload 
1a06						else 
1a06							call forth_startup 
1a06						endif 
1a06			 
1a06			 
1a06					endif 
1a06			 
1a06				endif 
1a06			 
1a06				; show free memory after boot 
1a06 11 92 1a			ld de, freeram 
1a09 3e 00			ld a, display_row_1 
1a0b cd cc 0b			call str_at_display 
1a0e			 
1a0e				; get current heap start after loading any uwords 
1a0e			 
1a0e				;ld de, (os_last_new_uword) 
1a0e				;ex de, hl 
1a0e			 
1a0e			; Or use heap_size word???? 
1a0e				;ld hl, heap_end 
1a0e				;ld hl, heap_size 
1a0e				;ld de, topusermem 
1a0e				;ld de, heap_start 
1a0e ed 5b b0 67			ld de, (free_list )      
1a12 21 9c e2				ld hl, heap_end 
1a15 ed 52			sbc hl, de 
1a17				;push hl 
1a17				;ld a,h	         	 
1a17				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1a17				;call hexout 
1a17			   	;pop hl 
1a17			; 
1a17			;	ld a,l 
1a17			;	ld hl, os_word_scratch+2 
1a17			;	call hexout 
1a17			;	ld hl, os_word_scratch+4 
1a17			;	ld a, 0 
1a17			;	ld (hl),a 
1a17 eb				ex de, hl 
1a18 21 c6 e5			ld hl, os_word_scratch 
1a1b cd 52 13			call uitoa_16 
1a1e			 
1a1e			 
1a1e 11 c6 e5			ld de, os_word_scratch 
1a21 3e 0d			ld a, display_row_1 + 13 
1a23 cd cc 0b			call str_at_display 
1a26 cd dc 0b			call update_display 
1a29			 
1a29			 
1a29				;call demo 
1a29			 
1a29			 
1a29				; init scratch input area for cli commands 
1a29			 
1a29 21 e8 e5			ld hl, os_cli_cmd 
1a2c 3e 00			ld a,0 
1a2e 77				ld (hl),a 
1a2f 23				inc hl 
1a30 77				ld (hl),a 
1a31			 
1a31 3e 00			ld a,0 
1a33 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1a36			 
1a36 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1a39 32 e5 e5			ld (os_cur_ptr+1),a	 
1a3c			 
1a3c 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1a3f 32 c7 e5			ld (os_word_scratch+1),a	 
1a42				 
1a42			 
1a42				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1a42 21 e8 e5			ld hl, os_cli_cmd 
1a45			 
1a45 3e 00			ld a, 0		 ; init cli input 
1a47 77				ld (hl), a 
1a48 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1a4a			cli: 
1a4a				; show cli prompt 
1a4a				;push af 
1a4a				;ld a, 0 
1a4a				;ld de, prompt 
1a4a				;call str_at_display 
1a4a			 
1a4a				;call update_display 
1a4a				;pop af 
1a4a				;inc a 
1a4a				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1a4a 0e 00			ld c, 0 
1a4c 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1a4e 1e 28			ld e, 40 
1a50			 
1a50 21 e8 e5			ld hl, os_cli_cmd 
1a53			 
1a53				STACKFRAME OFF $fefe $9f9f 
1a53				if DEBUG_STACK_IMB 
1a53					if OFF 
1a53						exx 
1a53						ld de, $fefe 
1a53						ld a, d 
1a53						ld hl, curframe 
1a53						call hexout 
1a53						ld a, e 
1a53						ld hl, curframe+2 
1a53						call hexout 
1a53						ld hl, $fefe 
1a53						push hl 
1a53						ld hl, $9f9f 
1a53						push hl 
1a53						exx 
1a53					endif 
1a53				endif 
1a53			endm 
# End of macro STACKFRAME
1a53			 
1a53 cd 13 0e			call input_str 
1a56			 
1a56				STACKFRAMECHK OFF $fefe $9f9f 
1a56				if DEBUG_STACK_IMB 
1a56					if OFF 
1a56						exx 
1a56						ld hl, $9f9f 
1a56						pop de   ; $9f9f 
1a56						call cmp16 
1a56						jr nz, .spnosame 
1a56						ld hl, $fefe 
1a56						pop de   ; $fefe 
1a56						call cmp16 
1a56						jr z, .spfrsame 
1a56						.spnosame: call showsperror 
1a56						.spfrsame: nop 
1a56						exx 
1a56					endif 
1a56				endif 
1a56			endm 
# End of macro STACKFRAMECHK
1a56			 
1a56				; copy input to last command 
1a56			 
1a56 21 e8 e5			ld hl, os_cli_cmd 
1a59 11 e7 e6			ld de, os_last_cmd 
1a5c 01 ff 00			ld bc, 255 
1a5f ed b0			ldir 
1a61			 
1a61				; wipe current buffer 
1a61			 
1a61			;	ld a, 0 
1a61			;	ld hl, os_cli_cmd 
1a61			;	ld de, os_cli_cmd+1 
1a61			;	ld bc, 254 
1a61			;	ldir 
1a61				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1a61			;	call strcpy 
1a61			;	ld a, 0 
1a61			;	ld (hl), a 
1a61			;	inc hl 
1a61			;	ld (hl), a 
1a61			;	inc hl 
1a61			;	ld (hl), a 
1a61			 
1a61				; switch frame buffer to program  
1a61			 
1a61 21 10 ed				ld hl, display_fb1 
1a64 22 cc eb				ld (display_fb_active), hl 
1a67			 
1a67			;	nop 
1a67				STACKFRAME ON $fbfe $8f9f 
1a67				if DEBUG_STACK_IMB 
1a67					if ON 
1a67						exx 
1a67						ld de, $fbfe 
1a67						ld a, d 
1a67						ld hl, curframe 
1a67						call hexout 
1a67						ld a, e 
1a67						ld hl, curframe+2 
1a67						call hexout 
1a67						ld hl, $fbfe 
1a67						push hl 
1a67						ld hl, $8f9f 
1a67						push hl 
1a67						exx 
1a67					endif 
1a67				endif 
1a67			endm 
# End of macro STACKFRAME
1a67				; first time into the parser so pass over the current scratch pad 
1a67 21 e8 e5			ld hl,os_cli_cmd 
1a6a				; tokenise the entered statement(s) in HL 
1a6a cd ac 21			call forthparse 
1a6d			        ; exec forth statements in top of return stack 
1a6d cd ec 21			call forthexec 
1a70				;call forthexec_cleanup 
1a70			;	call parsenext 
1a70			 
1a70				STACKFRAMECHK ON $fbfe $8f9f 
1a70				if DEBUG_STACK_IMB 
1a70					if ON 
1a70						exx 
1a70						ld hl, $8f9f 
1a70						pop de   ; $8f9f 
1a70						call cmp16 
1a70						jr nz, .spnosame 
1a70						ld hl, $fbfe 
1a70						pop de   ; $fbfe 
1a70						call cmp16 
1a70						jr z, .spfrsame 
1a70						.spnosame: call showsperror 
1a70						.spfrsame: nop 
1a70						exx 
1a70					endif 
1a70				endif 
1a70			endm 
# End of macro STACKFRAMECHK
1a70				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1a70			 
1a70 3e 78			ld a, display_row_4 
1a72 11 a3 1a			ld de, endprog 
1a75			 
1a75 cd dc 0b			call update_display		 
1a78			 
1a78 cd 29 1d			call next_page_prompt 
1a7b			 
1a7b				; switch frame buffer to cli 
1a7b			 
1a7b 21 b1 ed				ld hl, display_fb0 
1a7e 22 cc eb				ld (display_fb_active), hl 
1a81			 
1a81			 
1a81 cd b9 0b		        call clear_display 
1a84 cd dc 0b			call update_display		 
1a87			 
1a87 21 e8 e5			ld hl, os_cli_cmd 
1a8a			 
1a8a 3e 00			ld a, 0		 ; init cli input 
1a8c 77				ld (hl), a 
1a8d			 
1a8d				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1a8d			 
1a8d				; now on last line 
1a8d			 
1a8d				; TODO scroll screen up 
1a8d			 
1a8d				; TODO instead just clear screen and place at top of screen 
1a8d			 
1a8d			;	ld a, 0 
1a8d			;	ld (f_cursor_ptr),a 
1a8d			 
1a8d				;call clear_display 
1a8d				;call update_display 
1a8d			 
1a8d				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1a8d 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1a8f c3 4a 1a			jp cli 
1a92			 
1a92 .. 00		freeram: db "Free bytes: ",0 
1a9f ..			asc: db "1A2F" 
1aa3 .. 00		endprog: db "End prog...",0 
1aaf			 
1aaf			testenter2:   
1aaf 21 f3 e2			ld hl,scratch+50 
1ab2 22 e4 e5			ld (os_cur_ptr),hl 
1ab5 c3 4a 1a			jp cli 
1ab8			 
1ab8			testenter:  
1ab8			 
1ab8 21 9f 1a			ld hl,asc 
1abb			;	ld a,(hl) 
1abb			;	call nibble2val 
1abb cd 9c 12			call get_byte 
1abe			 
1abe			 
1abe			;	ld a,(hl) 
1abe			;	call atohex 
1abe			 
1abe			;	call fourehexhl 
1abe 32 f3 e2			ld (scratch+50),a 
1ac1			 
1ac1			 
1ac1			 
1ac1 21 a1 1a			ld hl,asc+2 
1ac4			;	ld a, (hl) 
1ac4			;	call nibble2val 
1ac4 cd 9c 12			call get_byte 
1ac7			 
1ac7			;	call fourehexhl 
1ac7 32 f5 e2			ld (scratch+52),a 
1aca				 
1aca 21 f3 e2			ld hl,scratch+50 
1acd 22 e4 e5			ld (os_cur_ptr),hl 
1ad0 c3 4a 1a			jp cli 
1ad3			 
1ad3			enter:	 
1ad3 3a c5 e2			ld a,(scratch+4) 
1ad6 fe 00			cp 0 
1ad8 28 0c			jr z, .entercont 
1ada				; no, not a null term line so has an address to work out.... 
1ada			 
1ada 21 c3 e2			ld hl,scratch+2 
1add cd fc 12			call get_word_hl 
1ae0			 
1ae0 22 e4 e5			ld (os_cur_ptr),hl	 
1ae3 c3 4a 1a			jp cli 
1ae6			 
1ae6			 
1ae6			.entercont:  
1ae6			 
1ae6 21 c3 e2			ld hl, scratch+2 
1ae9 cd 9c 12			call get_byte 
1aec			 
1aec 2a e4 e5		   	ld hl,(os_cur_ptr) 
1aef 77					ld (hl),a 
1af0 23					inc hl 
1af1 22 e4 e5				ld (os_cur_ptr),hl 
1af4				 
1af4			; get byte  
1af4			 
1af4			 
1af4 c3 4a 1a			jp cli 
1af7			 
1af7			 
1af7			; basic monitor support 
1af7			 
1af7			monitor: 
1af7				;  
1af7 cd b9 0b			call clear_display 
1afa 3e 00			ld a, 0 
1afc 11 4b 1b			ld de, .monprompt 
1aff cd cc 0b			call str_at_display 
1b02 cd dc 0b			call update_display 
1b05			 
1b05				; get a monitor command 
1b05			 
1b05 0e 00			ld c, 0     ; entry at top left 
1b07 16 64			ld d, 100   ; max buffer size 
1b09 1e 0f			ld e, 15    ; input scroll area 
1b0b 3e 00			ld a, 0     ; init string 
1b0d 21 bf e4			ld hl, os_input 
1b10 77				ld (hl), a 
1b11 23				inc hl 
1b12 77				ld (hl), a 
1b13 21 bf e4			ld hl, os_input 
1b16 3e 01			ld a, 1     ; init string 
1b18 cd 13 0e			call input_str 
1b1b			 
1b1b cd b9 0b		        call clear_display 
1b1e cd dc 0b			call update_display		 
1b21			 
1b21 3a bf e4			ld a, (os_input) 
1b24 cd 9a 13			call toUpper 
1b27 fe 48		        cp 'H' 
1b29 ca b0 1b		        jp z, .monhelp 
1b2c fe 44			cp 'D'		; dump 
1b2e ca e3 1b			jp z, .mondump	 
1b31 fe 43			cp 'C'		; dump 
1b33 ca fd 1b			jp z, .moncdump	 
1b36 fe 4d			cp 'M'		; dump 
1b38 ca 4d 1b			jp z, .moneditstart 
1b3b fe 55			cp 'U'		; dump 
1b3d ca 59 1b			jp z, .monedit	 
1b40 fe 47			cp 'G'		; dump 
1b42 ca d9 1b			jp z, .monjump 
1b45 fe 51			cp 'Q'		; dump 
1b47 c8				ret z	 
1b48			 
1b48			 
1b48				; TODO "S" to access symbol by name and not need the address 
1b48				; TODO "F" to find a string in memory 
1b48			 
1b48 c3 f7 1a			jp monitor 
1b4b			 
1b4b .. 00		.monprompt: db ">", 0 
1b4d			 
1b4d			.moneditstart: 
1b4d				; get starting address 
1b4d			 
1b4d 21 c1 e4			ld hl,os_input+2 
1b50 cd fc 12			call get_word_hl 
1b53			 
1b53 22 e4 e5			ld (os_cur_ptr),hl	 
1b56			 
1b56 c3 f7 1a			jp monitor 
1b59			 
1b59			.monedit: 
1b59				; get byte to load 
1b59			 
1b59 21 c1 e4			ld hl,os_input+2 
1b5c cd 9c 12			call get_byte 
1b5f			 
1b5f				; get address to update 
1b5f 2a e4 e5			ld hl, (os_cur_ptr) 
1b62			 
1b62				; update byte 
1b62			 
1b62 77				ld (hl), a 
1b63			 
1b63				; move to next address and save it 
1b63			 
1b63 23				inc hl 
1b64 22 e4 e5			ld (os_cur_ptr),hl	 
1b67			 
1b67 c3 f7 1a			jp monitor 
1b6a			 
1b6a			 
1b6a .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1b7e .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1b9a .. 00		.monhelptext3:  db "G-Call address",0 
1ba9 .. 00		.monhelptext4:  db "Q-Quit",0 
1bb0			        
1bb0			.monhelp: 
1bb0 3e 00			ld a, display_row_1 
1bb2 11 6a 1b		        ld de, .monhelptext1 
1bb5			 
1bb5 cd cc 0b			call str_at_display 
1bb8 3e 28			ld a, display_row_2 
1bba 11 7e 1b		        ld de, .monhelptext2 
1bbd					 
1bbd cd cc 0b			call str_at_display 
1bc0 3e 50			ld a, display_row_3 
1bc2 11 9a 1b		        ld de, .monhelptext3 
1bc5					 
1bc5 cd cc 0b			call str_at_display 
1bc8 3e 78			ld a, display_row_4 
1bca 11 a9 1b		        ld de, .monhelptext4 
1bcd cd cc 0b			call str_at_display 
1bd0			 
1bd0 cd dc 0b			call update_display		 
1bd3			 
1bd3 cd 29 1d			call next_page_prompt 
1bd6 c3 f7 1a			jp monitor 
1bd9			 
1bd9			.monjump:    
1bd9 21 c1 e4			ld hl,os_input+2 
1bdc cd fc 12			call get_word_hl 
1bdf			 
1bdf e9				jp (hl) 
1be0 c3 f7 1a			jp monitor 
1be3			 
1be3			.mondump:    
1be3 21 c1 e4			ld hl,os_input+2 
1be6 cd fc 12			call get_word_hl 
1be9			 
1be9 22 e4 e5			ld (os_cur_ptr),hl	 
1bec cd 31 1c			call dumpcont 
1bef 3e 78			ld a, display_row_4 
1bf1 11 a3 1a			ld de, endprog 
1bf4			 
1bf4 cd dc 0b			call update_display		 
1bf7			 
1bf7 cd 29 1d			call next_page_prompt 
1bfa c3 f7 1a			jp monitor 
1bfd			.moncdump: 
1bfd cd 31 1c			call dumpcont 
1c00 3e 78			ld a, display_row_4 
1c02 11 a3 1a			ld de, endprog 
1c05			 
1c05 cd dc 0b			call update_display		 
1c08			 
1c08 cd 29 1d			call next_page_prompt 
1c0b c3 f7 1a			jp monitor 
1c0e			 
1c0e			 
1c0e			; TODO symbol access  
1c0e			 
1c0e			.symbols:     ;; A list of symbols that can be called up  
1c0e b1 ed			dw display_fb0 
1c10 .. 00			db "fb0",0  
1c14 7a ea		     	dw store_page 
1c16 .. 00			db "store_page",0 
1c21			 
1c21			 
1c21			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1c21			 
1c21 3a c2 e2			ld a,(scratch+1) 
1c24 fe 00			cp 0 
1c26 28 09			jr z, dumpcont 
1c28			 
1c28				; no, not a null term line so has an address to work out.... 
1c28			 
1c28 21 c3 e2			ld hl,scratch+2 
1c2b cd fc 12			call get_word_hl 
1c2e			 
1c2e 22 e4 e5			ld (os_cur_ptr),hl	 
1c31			 
1c31			 
1c31			 
1c31			dumpcont: 
1c31			 
1c31				; dump bytes at ptr 
1c31			 
1c31			 
1c31 3e 00			ld a, display_row_1 
1c33 2a cc eb			ld hl, (display_fb_active) 
1c36 cd e6 0d			call addatohl 
1c39 cd 61 1c			call .dumpbyterow 
1c3c			 
1c3c 3e 28			ld a, display_row_2 
1c3e 2a cc eb			ld hl, (display_fb_active) 
1c41 cd e6 0d			call addatohl 
1c44 cd 61 1c			call .dumpbyterow 
1c47			 
1c47			 
1c47 3e 50			ld a, display_row_3 
1c49 2a cc eb			ld hl, (display_fb_active) 
1c4c cd e6 0d			call addatohl 
1c4f cd 61 1c			call .dumpbyterow 
1c52			 
1c52 3e 78			ld a, display_row_4 
1c54 2a cc eb			ld hl, (display_fb_active) 
1c57 cd e6 0d			call addatohl 
1c5a cd 61 1c			call .dumpbyterow 
1c5d			 
1c5d cd dc 0b			call update_display 
1c60			;		jp cli 
1c60 c9				ret 
1c61			 
1c61			.dumpbyterow: 
1c61			 
1c61				;push af 
1c61			 
1c61 e5				push hl 
1c62			 
1c62				; calc where to poke the ascii 
1c62			if display_cols == 20 
1c62				ld a, 16 
1c62			else 
1c62 3e 1f			ld a, 31 
1c64			endif 
1c64			 
1c64 cd e6 0d			call addatohl 
1c67 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
1c6a			 
1c6a			 
1c6a			; display decoding address 
1c6a 2a e4 e5		   	ld hl,(os_cur_ptr) 
1c6d			 
1c6d 7c				ld a,h 
1c6e e1				pop hl 
1c6f e5				push hl 
1c70			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1c70 cd 46 12			call hexout 
1c73 2a e4 e5		   	ld hl,(os_cur_ptr) 
1c76			 
1c76 7d				ld a,l 
1c77 e1				pop hl 
1c78 23				inc hl 
1c79 23				inc hl 
1c7a e5				push hl 
1c7b			;	ld hl, os_word_scratch+2 
1c7b cd 46 12			call hexout 
1c7e e1				pop hl 
1c7f 23				inc hl 
1c80 23				inc hl 
1c81				;ld hl, os_word_scratch+4 
1c81 3e 3a			ld a, ':' 
1c83 77				ld (hl),a 
1c84 23				inc hl 
1c85				;ld a, 0 
1c85				;ld (hl),a 
1c85				;ld de, os_word_scratch 
1c85				;pop af 
1c85				;push af 
1c85			;		ld a, display_row_2 
1c85			;		call str_at_display 
1c85			;		call update_display 
1c85			 
1c85			 
1c85			;pop af 
1c85			;	add 5 
1c85			 
1c85			if display_cols == 20 
1c85				ld b, 4 
1c85			else 
1c85 06 08			ld b, 8 
1c87			endif	 
1c87			 
1c87			.dumpbyte: 
1c87 c5				push bc 
1c88 e5				push hl 
1c89			 
1c89			 
1c89 2a e4 e5		   	ld hl,(os_cur_ptr) 
1c8c 7e					ld a,(hl) 
1c8d			 
1c8d					; poke the ascii to display 
1c8d 2a c6 e5				ld hl,(os_word_scratch) 
1c90 77					ld (hl),a 
1c91 23					inc hl 
1c92 22 c6 e5				ld (os_word_scratch),hl 
1c95			 
1c95					 
1c95			 
1c95			 
1c95 e1					pop hl 
1c96 e5					push hl 
1c97			 
1c97 cd 46 12				call hexout 
1c9a			 
1c9a					 
1c9a 2a e4 e5		   	ld hl,(os_cur_ptr) 
1c9d 23				inc hl 
1c9e 22 e4 e5		   	ld (os_cur_ptr),hl 
1ca1			 
1ca1 e1					pop hl 
1ca2 23					inc hl 
1ca3 23					inc hl 
1ca4 23					inc hl 
1ca5			 
1ca5			 
1ca5			 
1ca5					;ld a,0 
1ca5					;ld (os_word_scratch+2),a 
1ca5					;pop af 
1ca5					;push af 
1ca5			 
1ca5					;ld de, os_word_scratch 
1ca5					;call str_at_display 
1ca5			;		call update_display 
1ca5			;		pop af 
1ca5 c1					pop bc 
1ca6 c6 03				add 3 
1ca8 10 dd			djnz .dumpbyte 
1caa			 
1caa				 
1caa			 
1caa c9				ret 
1cab			 
1cab			jump:	 
1cab			 
1cab 21 c3 e2			ld hl,scratch+2 
1cae cd fc 12			call get_word_hl 
1cb1				;ld hl,(scratch+2) 
1cb1				;call fourehexhl 
1cb1			 
1cb1 22 e4 e5			ld (os_cur_ptr),hl	 
1cb4			 
1cb4 e9				jp (hl) 
1cb5			 
1cb5			 
1cb5			 
1cb5			; TODO implement a basic monitor mode to start with 
1cb5			 
1cb5			 
1cb5			 
1cb5			 
1cb5			 
1cb5			 
1cb5			 
1cb5			 
1cb5			 
1cb5			; testing and demo code during development 
1cb5			 
1cb5			 
1cb5 .. 00		str1: db "Enter some text...",0 
1cc8 .. 00		clear: db "                    ",0 
1cdd			 
1cdd			demo: 
1cdd			 
1cdd			 
1cdd			 
1cdd			;	call update_display 
1cdd			 
1cdd				; init scratch input area for testing 
1cdd 21 c1 e2			ld hl, scratch	 
1ce0 3e 00			ld a,0 
1ce2 77				ld (hl),a 
1ce3			 
1ce3			 
1ce3 3e 28		            LD   A, display_row_2 
1ce5			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ce5 11 b5 1c		            LD   DE, str1 
1ce8 cd cc 0b			call str_at_display 
1ceb			 
1ceb			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ceb			cloop:	 
1ceb 3e 50		            LD   A, display_row_3 
1ced			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ced 11 c8 1c		            LD   DE, clear 
1cf0			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1cf0 cd cc 0b				call str_at_display 
1cf3 3e 78			ld a, display_row_4 
1cf5 11 25 1d			ld de, prompt 
1cf8			 
1cf8 cd cc 0b				call str_at_display 
1cfb cd dc 0b			call update_display 
1cfe			 
1cfe 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1d00 16 0a			ld d, 10 
1d02 21 c1 e2			ld hl, scratch	 
1d05 cd 13 0e			call input_str 
1d08			 
1d08			;	call clear_display 
1d08			;'	call update_display 
1d08			 
1d08 3e 00		            LD   A, display_row_1 
1d0a			;            CALL fLCD_Pos       ;Position cursor to location in A 
1d0a 11 c8 1c		            LD   DE, clear 
1d0d cd cc 0b				call str_at_display 
1d10			;            CALL fLCD_Str       ;Display string pointed to by DE 
1d10 3e 00		            LD   A, display_row_1 
1d12			;            CALL fLCD_Pos       ;Position cursor to location in A 
1d12 11 c1 e2		            LD   DE, scratch 
1d15			;            CALL fLCD_Str       ;Display string pointed to by DE 
1d15 cd cc 0b				call str_at_display 
1d18 cd dc 0b			call update_display 
1d1b			 
1d1b 3e 00				ld a,0 
1d1d 21 c1 e2			ld hl, scratch 
1d20 77				ld (hl),a 
1d21			 
1d21 00				nop 
1d22 c3 eb 1c			jp cloop 
1d25			 
1d25			 
1d25			 
1d25			; OS Prompt 
1d25			 
1d25 .. 00		prompt: db ">",0 
1d27 .. 00		endprg: db "?",0 
1d29			 
1d29			 
1d29			; handy next page prompt 
1d29			next_page_prompt: 
1d29 e5				push hl 
1d2a d5				push de 
1d2b f5				push af 
1d2c c5				push bc 
1d2d			 
1d2d 3e 9f			ld a,display_row_4 + display_cols - 1 
1d2f 11 27 1d		        ld de, endprg 
1d32 cd cc 0b			call str_at_display 
1d35 cd dc 0b			call update_display 
1d38 cd 85 67			call cin_wait 
1d3b c1				pop bc 
1d3c f1				pop af 
1d3d d1				pop de 
1d3e e1				pop hl 
1d3f			 
1d3f			 
1d3f c9				ret 
1d40			 
1d40			 
1d40			; forth parser 
1d40			 
1d40			; My forth kernel 
1d40			include "forth_kernel.asm" 
1d40			; 
1d40			; kernel to the forth OS 
1d40			 
1d40			DS_TYPE_STR: equ 1     ; string type 
1d40			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1d40			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1d40			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1d40			 
1d40			FORTH_PARSEV1: equ 0 
1d40			FORTH_PARSEV2: equ 0 
1d40			FORTH_PARSEV3: equ 0 
1d40			FORTH_PARSEV4: equ 0 
1d40			FORTH_PARSEV5: equ 1 
1d40			 
1d40			;if FORTH_PARSEV5 
1d40			;	FORTH_END_BUFFER: equ 0 
1d40			;else 
1d40			FORTH_END_BUFFER: equ 127 
1d40			;endif 
1d40			 
1d40			FORTH_TRUE: equ 1 
1d40			FORTH_FALSE: equ 0 
1d40			 
1d40			if FORTH_PARSEV4 
1d40			include "forth_stackops.asm" 
1d40			endif 
1d40			 
1d40			if FORTH_PARSEV5 
1d40			include "forth_stackopsv5.asm" 
1d40			 
1d40			; Stack operations for v5 parser on wards 
1d40			; * DATA stack 
1d40			; * LOOP stack 
1d40			; * RETURN stack 
1d40			 
1d40			 
1d40			 
1d40			FORTH_CHK_DSP_UNDER: macro 
1d40				push hl 
1d40				push de 
1d40				ld hl,(cli_data_sp) 
1d40				ld de, cli_data_stack 
1d40				call cmp16 
1d40				jp c, fault_dsp_under 
1d40				pop de 
1d40				pop hl 
1d40				endm 
1d40			 
1d40			 
1d40			FORTH_CHK_RSP_UNDER: macro 
1d40				push hl 
1d40				push de 
1d40				ld hl,(cli_ret_sp) 
1d40				ld de, cli_ret_stack 
1d40				call cmp16 
1d40				jp c, fault_rsp_under 
1d40				pop de 
1d40				pop hl 
1d40				endm 
1d40			 
1d40			FORTH_CHK_LOOP_UNDER: macro 
1d40				push hl 
1d40				push de 
1d40				ld hl,(cli_loop_sp) 
1d40				ld de, cli_loop_stack 
1d40				call cmp16 
1d40				jp c, fault_loop_under 
1d40				pop de 
1d40				pop hl 
1d40				endm 
1d40			 
1d40			FORTH_ERR_TOS_NOTSTR: macro 
1d40				; TOSO might need more for checks when used 
1d40				push af 
1d40				ld a,(hl) 
1d40				cp DS_TYPE_STR 
1d40				jp nz, type_faultn   
1d40				pop af 
1d40				endm 
1d40			 
1d40			FORTH_ERR_TOS_NOTNUM: macro 
1d40				push af 
1d40				ld a,(hl) 
1d40				cp DS_TYPE_INUM 
1d40				jp nz, type_faultn   
1d40				pop af 
1d40				endm 
1d40			 
1d40			 
1d40			; increase data stack pointer and save hl to it 
1d40				 
1d40			FORTH_DSP_NEXT: macro 
1d40				call macro_forth_dsp_next 
1d40				endm 
1d40			 
1d40			 
1d40			macro_forth_dsp_next: 
1d40				if DEBUG_FORTH_STACK_GUARD 
1d40 cd b4 63				call check_stacks 
1d43				endif 
1d43 e5				push hl 
1d44 d5				push de 
1d45 eb				ex de,hl 
1d46 2a ee e9			ld hl,(cli_data_sp) 
1d49 23				inc hl 
1d4a 23				inc hl 
1d4b			 
1d4b			; PARSEV5 
1d4b 23				inc hl 
1d4c 22 ee e9			ld (cli_data_sp),hl 
1d4f 73				ld (hl), e 
1d50 23				inc hl 
1d51 72				ld (hl), d 
1d52 d1				pop de 
1d53 e1				pop hl 
1d54				if DEBUG_FORTH_STACK_GUARD 
1d54 cd b4 63				call check_stacks 
1d57				endif 
1d57 c9				ret 
1d58			 
1d58			 
1d58			; increase ret stack pointer and save hl to it 
1d58				 
1d58			FORTH_RSP_NEXT: macro 
1d58				call macro_forth_rsp_next 
1d58				endm 
1d58			 
1d58			macro_forth_rsp_next: 
1d58				if DEBUG_FORTH_STACK_GUARD 
1d58 cd b4 63				call check_stacks 
1d5b				endif 
1d5b e5				push hl 
1d5c d5				push de 
1d5d eb				ex de,hl 
1d5e 2a f2 e9			ld hl,(cli_ret_sp) 
1d61 23				inc hl 
1d62 23				inc hl 
1d63 22 f2 e9			ld (cli_ret_sp),hl 
1d66 73				ld (hl), e 
1d67 23				inc hl 
1d68 72				ld (hl), d 
1d69 d1				pop de 
1d6a e1				pop hl 
1d6b				if DEBUG_FORTH_STACK_GUARD 
1d6b cd b4 63				call check_stacks 
1d6e				endif 
1d6e c9				ret 
1d6f			 
1d6f			; get current ret stack pointer and save to hl  
1d6f				 
1d6f			FORTH_RSP_TOS: macro 
1d6f				call macro_forth_rsp_tos 
1d6f				endm 
1d6f			 
1d6f			macro_forth_rsp_tos: 
1d6f				;push de 
1d6f 2a f2 e9			ld hl,(cli_ret_sp) 
1d72 cd aa 1d			call loadhlptrtohl 
1d75				;ld e, (hl) 
1d75				;inc hl 
1d75				;ld d, (hl) 
1d75				;ex de, hl 
1d75					if DEBUG_FORTH_WORDS 
1d75			;			DMARK "RST" 
1d75						CALLMONITOR 
1d75 cd 6f ee			call debug_vector  
1d78				endm  
# End of macro CALLMONITOR
1d78					endif 
1d78				;pop de 
1d78 c9				ret 
1d79			 
1d79			; pop ret stack pointer 
1d79				 
1d79			FORTH_RSP_POP: macro 
1d79				call macro_forth_rsp_pop 
1d79				endm 
1d79			 
1d79			 
1d79			macro_forth_rsp_pop: 
1d79				if DEBUG_FORTH_STACK_GUARD 
1d79			;		DMARK "RPP" 
1d79 cd b4 63				call check_stacks 
1d7c					FORTH_CHK_RSP_UNDER 
1d7c e5				push hl 
1d7d d5				push de 
1d7e 2a f2 e9			ld hl,(cli_ret_sp) 
1d81 11 ac e9			ld de, cli_ret_stack 
1d84 cd 04 0e			call cmp16 
1d87 da c8 64			jp c, fault_rsp_under 
1d8a d1				pop de 
1d8b e1				pop hl 
1d8c				endm 
# End of macro FORTH_CHK_RSP_UNDER
1d8c				endif 
1d8c e5				push hl 
1d8d 2a f2 e9			ld hl,(cli_ret_sp) 
1d90			 
1d90			 
1d90				if FORTH_ENABLE_FREE 
1d90			 
1d90					; get pointer 
1d90			 
1d90					push de 
1d90					push hl 
1d90			 
1d90					ld e, (hl) 
1d90					inc hl 
1d90					ld d, (hl) 
1d90			 
1d90					ex de, hl 
1d90					call free 
1d90			 
1d90					pop hl 
1d90					pop de 
1d90			 
1d90			 
1d90				endif 
1d90			 
1d90			 
1d90 2b				dec hl 
1d91 2b				dec hl 
1d92 22 f2 e9			ld (cli_ret_sp), hl 
1d95				; do stack underflow checks 
1d95 e1				pop hl 
1d96				if DEBUG_FORTH_STACK_GUARD 
1d96 cd b4 63				call check_stacks 
1d99					FORTH_CHK_RSP_UNDER 
1d99 e5				push hl 
1d9a d5				push de 
1d9b 2a f2 e9			ld hl,(cli_ret_sp) 
1d9e 11 ac e9			ld de, cli_ret_stack 
1da1 cd 04 0e			call cmp16 
1da4 da c8 64			jp c, fault_rsp_under 
1da7 d1				pop de 
1da8 e1				pop hl 
1da9				endm 
# End of macro FORTH_CHK_RSP_UNDER
1da9				endif 
1da9 c9				ret 
1daa			 
1daa			 
1daa			 
1daa			; routine to load word pointed to by hl into hl 
1daa			 
1daa			loadhlptrtohl: 
1daa			 
1daa d5				push de 
1dab 5e				ld e, (hl) 
1dac 23				inc hl 
1dad 56				ld d, (hl) 
1dae eb				ex de, hl 
1daf d1				pop de 
1db0			 
1db0 c9				ret 
1db1			 
1db1			 
1db1			 
1db1			 
1db1			 
1db1			; push a number held in HL onto the data stack 
1db1			; entry point for pushing a value when already in hl used in function above 
1db1			 
1db1			forth_push_numhl: 
1db1			 
1db1 e5				push hl    ; save value to push 
1db2			 
1db2			if DEBUG_FORTH_PUSH 
1db2				; see if disabled 
1db2			 
1db2			 
1db2 f5				push af 
1db3 3a 6f ee			ld a,(debug_vector) 
1db6 fe c9			cp $c9   ; ret 
1db8			;	ld a, (os_view_disable) 
1db8			;	cp '*' 
1db8 28 34			jr z, .pskip2 
1dba e5				push hl 
1dbb e5			push hl 
1dbc cd b9 0b			call clear_display 
1dbf e1			pop hl 
1dc0 7c				ld a,h 
1dc1 21 c6 e5			ld hl, os_word_scratch 
1dc4 cd 46 12			call hexout 
1dc7 e1				pop hl 
1dc8 7d				ld a,l 
1dc9 21 c8 e5			ld hl, os_word_scratch+2 
1dcc cd 46 12			call hexout 
1dcf			 
1dcf 21 ca e5			ld hl, os_word_scratch+4 
1dd2 3e 00			ld a,0 
1dd4 77				ld (hl),a 
1dd5 11 c6 e5			ld de,os_word_scratch 
1dd8 3e 28				ld a, display_row_2 
1dda cd cc 0b				call str_at_display 
1ddd 11 c6 4e			ld de, .push_num 
1de0 3e 00			ld a, display_row_1 
1de2			 
1de2 cd cc 0b				call str_at_display 
1de5			 
1de5			 
1de5 cd dc 0b			call update_display 
1de8 cd f1 0a			call delay1s 
1deb cd f1 0a			call delay1s 
1dee			.pskip2:  
1dee			 
1dee f1				pop af 
1def			endif	 
1def			 
1def			 
1def				FORTH_DSP_NEXT 
1def cd 40 1d			call macro_forth_dsp_next 
1df2				endm 
# End of macro FORTH_DSP_NEXT
1df2			 
1df2 2a ee e9			ld hl, (cli_data_sp) 
1df5			 
1df5				; save item type 
1df5 3e 02			ld a,  DS_TYPE_INUM 
1df7 77				ld (hl), a 
1df8 23				inc hl 
1df9			 
1df9				; get word off stack 
1df9 d1				pop de 
1dfa 7b				ld a,e 
1dfb 77				ld (hl), a 
1dfc 23				inc hl 
1dfd 7a				ld a,d 
1dfe 77				ld (hl), a 
1dff			 
1dff			if DEBUG_FORTH_PUSH 
1dff 2b				dec hl 
1e00 2b				dec hl 
1e01 2b				dec hl 
1e02						DMARK "PH5" 
1e02 f5				push af  
1e03 3a 17 1e			ld a, (.dmark)  
1e06 32 6b ee			ld (debug_mark),a  
1e09 3a 18 1e			ld a, (.dmark+1)  
1e0c 32 6c ee			ld (debug_mark+1),a  
1e0f 3a 19 1e			ld a, (.dmark+2)  
1e12 32 6d ee			ld (debug_mark+2),a  
1e15 18 03			jr .pastdmark  
1e17 ..			.dmark: db "PH5"  
1e1a f1			.pastdmark: pop af  
1e1b			endm  
# End of macro DMARK
1e1b				CALLMONITOR 
1e1b cd 6f ee			call debug_vector  
1e1e				endm  
# End of macro CALLMONITOR
1e1e			endif	 
1e1e			 
1e1e c9				ret 
1e1f			 
1e1f			 
1e1f			; Push a string to stack pointed to by hl 
1e1f			 
1e1f			forth_push_str: 
1e1f			 
1e1f			if DEBUG_FORTH_PUSH 
1e1f						DMARK "PSQ" 
1e1f f5				push af  
1e20 3a 34 1e			ld a, (.dmark)  
1e23 32 6b ee			ld (debug_mark),a  
1e26 3a 35 1e			ld a, (.dmark+1)  
1e29 32 6c ee			ld (debug_mark+1),a  
1e2c 3a 36 1e			ld a, (.dmark+2)  
1e2f 32 6d ee			ld (debug_mark+2),a  
1e32 18 03			jr .pastdmark  
1e34 ..			.dmark: db "PSQ"  
1e37 f1			.pastdmark: pop af  
1e38			endm  
# End of macro DMARK
1e38				CALLMONITOR 
1e38 cd 6f ee			call debug_vector  
1e3b				endm  
# End of macro CALLMONITOR
1e3b			endif	 
1e3b			    
1e3b e5				push hl 
1e3c e5				push hl 
1e3d			 
1e3d			;	ld a, 0   ; find end of string 
1e3d cd a3 13			call strlenz 
1e40			if DEBUG_FORTH_PUSH 
1e40						DMARK "PQ2" 
1e40 f5				push af  
1e41 3a 55 1e			ld a, (.dmark)  
1e44 32 6b ee			ld (debug_mark),a  
1e47 3a 56 1e			ld a, (.dmark+1)  
1e4a 32 6c ee			ld (debug_mark+1),a  
1e4d 3a 57 1e			ld a, (.dmark+2)  
1e50 32 6d ee			ld (debug_mark+2),a  
1e53 18 03			jr .pastdmark  
1e55 ..			.dmark: db "PQ2"  
1e58 f1			.pastdmark: pop af  
1e59			endm  
# End of macro DMARK
1e59				CALLMONITOR 
1e59 cd 6f ee			call debug_vector  
1e5c				endm  
# End of macro CALLMONITOR
1e5c			endif	 
1e5c eb				ex de, hl 
1e5d e1				pop hl   ; get ptr to start of string 
1e5e			if DEBUG_FORTH_PUSH 
1e5e						DMARK "PQ3" 
1e5e f5				push af  
1e5f 3a 73 1e			ld a, (.dmark)  
1e62 32 6b ee			ld (debug_mark),a  
1e65 3a 74 1e			ld a, (.dmark+1)  
1e68 32 6c ee			ld (debug_mark+1),a  
1e6b 3a 75 1e			ld a, (.dmark+2)  
1e6e 32 6d ee			ld (debug_mark+2),a  
1e71 18 03			jr .pastdmark  
1e73 ..			.dmark: db "PQ3"  
1e76 f1			.pastdmark: pop af  
1e77			endm  
# End of macro DMARK
1e77				CALLMONITOR 
1e77 cd 6f ee			call debug_vector  
1e7a				endm  
# End of macro CALLMONITOR
1e7a			endif	 
1e7a 19				add hl,de 
1e7b			if DEBUG_FORTH_PUSH 
1e7b						DMARK "PQE" 
1e7b f5				push af  
1e7c 3a 90 1e			ld a, (.dmark)  
1e7f 32 6b ee			ld (debug_mark),a  
1e82 3a 91 1e			ld a, (.dmark+1)  
1e85 32 6c ee			ld (debug_mark+1),a  
1e88 3a 92 1e			ld a, (.dmark+2)  
1e8b 32 6d ee			ld (debug_mark+2),a  
1e8e 18 03			jr .pastdmark  
1e90 ..			.dmark: db "PQE"  
1e93 f1			.pastdmark: pop af  
1e94			endm  
# End of macro DMARK
1e94				CALLMONITOR 
1e94 cd 6f ee			call debug_vector  
1e97				endm  
# End of macro CALLMONITOR
1e97			endif	 
1e97			 
1e97 2b				dec hl    ; see if there is an optional trailing double quote 
1e98 7e				ld a,(hl) 
1e99 fe 22			cp '"' 
1e9b 20 03			jr nz, .strnoq 
1e9d 3e 00			ld a, 0      ; get rid of double quote 
1e9f 77				ld (hl), a 
1ea0 23			.strnoq: inc hl 
1ea1			 
1ea1 3e 00			ld a, 0 
1ea3 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1ea4			 
1ea4 13				inc de ; add one for the type string 
1ea5 13				inc de ; add one for null term??? 
1ea6			 
1ea6				; tos is get string pointer again 
1ea6				; de contains space to allocate 
1ea6				 
1ea6 d5				push de 
1ea7			 
1ea7 eb				ex de, hl 
1ea8			 
1ea8				;push af 
1ea8			 
1ea8			if DEBUG_FORTH_PUSH 
1ea8						DMARK "PHm" 
1ea8 f5				push af  
1ea9 3a bd 1e			ld a, (.dmark)  
1eac 32 6b ee			ld (debug_mark),a  
1eaf 3a be 1e			ld a, (.dmark+1)  
1eb2 32 6c ee			ld (debug_mark+1),a  
1eb5 3a bf 1e			ld a, (.dmark+2)  
1eb8 32 6d ee			ld (debug_mark+2),a  
1ebb 18 03			jr .pastdmark  
1ebd ..			.dmark: db "PHm"  
1ec0 f1			.pastdmark: pop af  
1ec1			endm  
# End of macro DMARK
1ec1				CALLMONITOR 
1ec1 cd 6f ee			call debug_vector  
1ec4				endm  
# End of macro CALLMONITOR
1ec4			endif	 
1ec4 cd 18 14			call malloc	; on ret hl now contains allocated memory 
1ec7				if DEBUG_FORTH_MALLOC_GUARD 
1ec7 cc 1e 4f				call z,malloc_error 
1eca				endif 
1eca			 
1eca				 
1eca c1				pop bc    ; get length 
1ecb d1				pop de   ;  get string start    
1ecc			 
1ecc				; hl has destination from malloc 
1ecc			 
1ecc eb				ex de, hl    ; prep for ldir 
1ecd			 
1ecd d5				push de   ; save malloc area for DSP later 
1ece				;push hl   ; save malloc area for DSP later 
1ece			 
1ece			if DEBUG_FORTH_PUSH 
1ece						DMARK "PHc" 
1ece f5				push af  
1ecf 3a e3 1e			ld a, (.dmark)  
1ed2 32 6b ee			ld (debug_mark),a  
1ed5 3a e4 1e			ld a, (.dmark+1)  
1ed8 32 6c ee			ld (debug_mark+1),a  
1edb 3a e5 1e			ld a, (.dmark+2)  
1ede 32 6d ee			ld (debug_mark+2),a  
1ee1 18 03			jr .pastdmark  
1ee3 ..			.dmark: db "PHc"  
1ee6 f1			.pastdmark: pop af  
1ee7			endm  
# End of macro DMARK
1ee7				CALLMONITOR 
1ee7 cd 6f ee			call debug_vector  
1eea				endm  
# End of macro CALLMONITOR
1eea			endif	 
1eea			 
1eea			 
1eea ed b0			ldir 
1eec			 
1eec			 
1eec				; push malloc to data stack     macro?????  
1eec			 
1eec				FORTH_DSP_NEXT 
1eec cd 40 1d			call macro_forth_dsp_next 
1eef				endm 
# End of macro FORTH_DSP_NEXT
1eef			 
1eef				; save value and type 
1eef			 
1eef 2a ee e9			ld hl, (cli_data_sp) 
1ef2			 
1ef2				; save item type 
1ef2 3e 01			ld a,  DS_TYPE_STR 
1ef4 77				ld (hl), a 
1ef5 23				inc hl 
1ef6			 
1ef6				; get malloc word off stack 
1ef6 d1				pop de 
1ef7 73				ld (hl), e 
1ef8 23				inc hl 
1ef9 72				ld (hl), d 
1efa			 
1efa			 
1efa			 
1efa			if DEBUG_FORTH_PUSH 
1efa 2a ee e9			ld hl, (cli_data_sp) 
1efd						DMARK "PHS" 
1efd f5				push af  
1efe 3a 12 1f			ld a, (.dmark)  
1f01 32 6b ee			ld (debug_mark),a  
1f04 3a 13 1f			ld a, (.dmark+1)  
1f07 32 6c ee			ld (debug_mark+1),a  
1f0a 3a 14 1f			ld a, (.dmark+2)  
1f0d 32 6d ee			ld (debug_mark+2),a  
1f10 18 03			jr .pastdmark  
1f12 ..			.dmark: db "PHS"  
1f15 f1			.pastdmark: pop af  
1f16			endm  
# End of macro DMARK
1f16				CALLMONITOR 
1f16 cd 6f ee			call debug_vector  
1f19				endm  
# End of macro CALLMONITOR
1f19			;	ex de,hl 
1f19			endif	 
1f19				; in case of spaces, skip the ptr past the copied string 
1f19				;pop af 
1f19				;ld (cli_origptr),hl 
1f19			 
1f19 c9				ret 
1f1a			 
1f1a			 
1f1a			 
1f1a			; TODO ascii push input onto stack given hl to start of input 
1f1a			 
1f1a			; identify type 
1f1a			; if starts with a " then a string 
1f1a			; otherwise it is a number 
1f1a			;  
1f1a			; if a string 
1f1a			;     scan for ending " to get length of string to malloc for + 1 
1f1a			;     malloc 
1f1a			;     put pointer to string on stack first byte flags as string 
1f1a			; 
1f1a			; else a number 
1f1a			;    look for number format identifier 
1f1a			;    $xx hex 
1f1a			;    %xxxxx bin 
1f1a			;    xxxxx decimal 
1f1a			;    convert number to 16bit word.  
1f1a			;    malloc word + 1 with flag to identiy as num 
1f1a			;    put pointer to number on stack 
1f1a			;   
1f1a			;  
1f1a			  
1f1a			forth_apush: 
1f1a				; kernel push 
1f1a			 
1f1a			if DEBUG_FORTH_PUSH 
1f1a						DMARK "PSH" 
1f1a f5				push af  
1f1b 3a 2f 1f			ld a, (.dmark)  
1f1e 32 6b ee			ld (debug_mark),a  
1f21 3a 30 1f			ld a, (.dmark+1)  
1f24 32 6c ee			ld (debug_mark+1),a  
1f27 3a 31 1f			ld a, (.dmark+2)  
1f2a 32 6d ee			ld (debug_mark+2),a  
1f2d 18 03			jr .pastdmark  
1f2f ..			.dmark: db "PSH"  
1f32 f1			.pastdmark: pop af  
1f33			endm  
# End of macro DMARK
1f33				CALLMONITOR 
1f33 cd 6f ee			call debug_vector  
1f36				endm  
# End of macro CALLMONITOR
1f36			endif	 
1f36				; identify input type 
1f36			 
1f36 7e				ld a,(hl) 
1f37 fe 22			cp '"' 
1f39 28 0a			jr z, .fapstr 
1f3b fe 24			cp '$' 
1f3d ca 65 1f			jp z, .faphex 
1f40 fe 25			cp '%' 
1f42 ca 4d 1f			jp z, .fapbin 
1f45			;	cp 'b' 
1f45			;	jp z, .fabin 
1f45				; else decimal 
1f45			 
1f45				; TODO do decimal conversion 
1f45				; decimal is stored as a 16bit word 
1f45			 
1f45				; by default everything is a string if type is not detected 
1f45			.fapstr: ; 
1f45 fe 22			cp '"' 
1f47 20 01			jr nz, .strnoqu 
1f49 23				inc hl 
1f4a			.strnoqu: 
1f4a c3 1f 1e			jp forth_push_str 
1f4d			 
1f4d			 
1f4d			 
1f4d			.fapbin:    ; push a binary string.  
1f4d 11 00 00			ld de, 0   ; hold a 16bit value 
1f50			 
1f50 23			.fapbinshift:	inc hl  
1f51 7e				ld a,(hl) 
1f52 fe 00			cp 0     ; done scanning  
1f54 28 0b			jr z, .fapbdone  	; got it in HL so push  
1f56			 
1f56				; left shift de 
1f56 eb				ex de, hl	 
1f57 29				add hl, hl 
1f58			 
1f58				; is 1 
1f58 fe 31			cp '1' 
1f5a 20 02			jr nz, .binzero 
1f5c cb 4d			bit 1, l 
1f5e			.binzero: 
1f5e eb				ex de, hl	 ; save current de 
1f5f 18 ef			jr .fapbinshift 
1f61			 
1f61			.fapbdone: 
1f61 eb				ex de, hl 
1f62 c3 b1 1d			jp forth_push_numhl 
1f65			 
1f65			 
1f65			.faphex:   ; hex is always stored as a 16bit word 
1f65				; skip number prefix 
1f65 23				inc hl 
1f66				; turn ascii into number 
1f66 cd fc 12			call get_word_hl	; ret 16bit word in hl 
1f69			 
1f69 c3 b1 1d			jp forth_push_numhl 
1f6c			 
1f6c 00				 nop 
1f6d			 
1f6d			.fabin:   ; TODO bin conversion 
1f6d			 
1f6d			 
1f6d c9				ret 
1f6e			 
1f6e			 
1f6e			; get either a string ptr or a 16bit word from the data stack 
1f6e			 
1f6e			FORTH_DSP: macro 
1f6e				call macro_forth_dsp 
1f6e				endm 
1f6e			 
1f6e			macro_forth_dsp: 
1f6e				; data stack pointer points to current word on tos 
1f6e			 
1f6e 2a ee e9			ld hl,(cli_data_sp) 
1f71			 
1f71				if DEBUG_FORTH_PUSH 
1f71						DMARK "DSP" 
1f71 f5				push af  
1f72 3a 86 1f			ld a, (.dmark)  
1f75 32 6b ee			ld (debug_mark),a  
1f78 3a 87 1f			ld a, (.dmark+1)  
1f7b 32 6c ee			ld (debug_mark+1),a  
1f7e 3a 88 1f			ld a, (.dmark+2)  
1f81 32 6d ee			ld (debug_mark+2),a  
1f84 18 03			jr .pastdmark  
1f86 ..			.dmark: db "DSP"  
1f89 f1			.pastdmark: pop af  
1f8a			endm  
# End of macro DMARK
1f8a			 
1f8a cd 51 4f				call display_data_sp 
1f8d				;call break_point_state 
1f8d				;rst 030h 
1f8d				CALLMONITOR 
1f8d cd 6f ee			call debug_vector  
1f90				endm  
# End of macro CALLMONITOR
1f90				endif 
1f90			 
1f90 c9				ret 
1f91			 
1f91			; return hl to start of value on stack 
1f91			 
1f91			FORTH_DSP_VALUE: macro 
1f91				call macro_forth_dsp_value 
1f91				endm 
1f91			 
1f91			macro_forth_dsp_value: 
1f91			 
1f91				FORTH_DSP 
1f91 cd 6e 1f			call macro_forth_dsp 
1f94				endm 
# End of macro FORTH_DSP
1f94			 
1f94 d5				push de 
1f95			 
1f95 23				inc hl ; skip type 
1f96			 
1f96 5e				ld e, (hl) 
1f97 23				inc hl 
1f98 56				ld d, (hl) 
1f99 eb				ex de,hl  
1f9a			 
1f9a d1				pop de 
1f9b			 
1f9b c9				ret 
1f9c			 
1f9c			; return hl to start of value to second item on stack 
1f9c			 
1f9c			FORTH_DSP_VALUEM1: macro 
1f9c				call macro_forth_dsp_value_m1 
1f9c				endm 
1f9c			 
1f9c			macro_forth_dsp_value_m1: 
1f9c			 
1f9c				FORTH_DSP 
1f9c cd 6e 1f			call macro_forth_dsp 
1f9f				endm 
# End of macro FORTH_DSP
1f9f			 
1f9f 2b				dec hl 
1fa0 2b				dec hl 
1fa1			;	dec hl 
1fa1			 
1fa1 d5				push de 
1fa2			 
1fa2 5e				ld e, (hl) 
1fa3 23				inc hl 
1fa4 56				ld d, (hl) 
1fa5 eb				ex de,hl  
1fa6			 
1fa6 d1				pop de 
1fa7			 
1fa7 c9				ret 
1fa8			 
1fa8				 
1fa8			 
1fa8			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1fa8			 
1fa8			FORTH_DSP_POP: macro 
1fa8				call macro_forth_dsp_pop 
1fa8				endm 
1fa8			 
1fa8			 
1fa8			; get the tos data type 
1fa8			 
1fa8			FORTH_DSP_TYPE:   macro 
1fa8			 
1fa8				;FORTH_DSP_VALUE 
1fa8				FORTH_DSP 
1fa8				 
1fa8				; hl points to value 
1fa8				; check type 
1fa8			 
1fa8				ld a,(hl) 
1fa8			 
1fa8				endm 
1fa8			 
1fa8			; load the tos value into hl 
1fa8			 
1fa8			 
1fa8			FORTH_DSP_VALUEHL:  macro 
1fa8				call macro_dsp_valuehl 
1fa8				endm 
1fa8			 
1fa8			 
1fa8			 
1fa8			macro_dsp_valuehl: 
1fa8				FORTH_DSP_VALUE 
1fa8 cd 91 1f			call macro_forth_dsp_value 
1fab				endm 
# End of macro FORTH_DSP_VALUE
1fab			 
1fab				;FORTH_ERR_TOS_NOTNUM 
1fab			 
1fab				;inc hl   ; skip type id 
1fab			 
1fab			;	push de 
1fab			; 
1fab			;	ld e, (hl) 
1fab			;	inc hl 
1fab			;	ld d, (hl) 
1fab			;	ex de,hl  
1fab			 
1fab			;	pop de 
1fab			 
1fab				if DEBUG_FORTH_PUSH 
1fab						DMARK "DVL" 
1fab f5				push af  
1fac 3a c0 1f			ld a, (.dmark)  
1faf 32 6b ee			ld (debug_mark),a  
1fb2 3a c1 1f			ld a, (.dmark+1)  
1fb5 32 6c ee			ld (debug_mark+1),a  
1fb8 3a c2 1f			ld a, (.dmark+2)  
1fbb 32 6d ee			ld (debug_mark+2),a  
1fbe 18 03			jr .pastdmark  
1fc0 ..			.dmark: db "DVL"  
1fc3 f1			.pastdmark: pop af  
1fc4			endm  
# End of macro DMARK
1fc4				CALLMONITOR 
1fc4 cd 6f ee			call debug_vector  
1fc7				endm  
# End of macro CALLMONITOR
1fc7				endif 
1fc7 c9				ret 
1fc8			 
1fc8			forth_apushstrhl:      
1fc8				; push of string requires use of cli_origptr 
1fc8				; bodge use 
1fc8			 
1fc8				; get current cli_origptr, save, update with temp pointer  
1fc8 ed 5b 3e ea		ld de, (cli_origptr) 
1fcc 22 3e ea			ld (cli_origptr), hl 
1fcf d5				push de 
1fd0 cd 1a 1f			call forth_apush 
1fd3 d1				pop de 
1fd4 ed 53 3e ea		ld (cli_origptr), de 
1fd8 c9			        ret	 
1fd9			 
1fd9			 
1fd9			; increase loop stack pointer and save hl to it 
1fd9				 
1fd9			FORTH_LOOP_NEXT: macro 
1fd9				call macro_forth_loop_next 
1fd9				;nop 
1fd9				endm 
1fd9			 
1fd9			macro_forth_loop_next: 
1fd9				if DEBUG_FORTH_STACK_GUARD 
1fd9 cd b4 63				call check_stacks 
1fdc				endif 
1fdc e5				push hl 
1fdd d5				push de 
1fde eb				ex de,hl 
1fdf 2a f0 e9			ld hl,(cli_loop_sp) 
1fe2 23				inc hl 
1fe3 23				inc hl 
1fe4					if DEBUG_FORTH_WORDS 
1fe4						DMARK "LNX" 
1fe4 f5				push af  
1fe5 3a f9 1f			ld a, (.dmark)  
1fe8 32 6b ee			ld (debug_mark),a  
1feb 3a fa 1f			ld a, (.dmark+1)  
1fee 32 6c ee			ld (debug_mark+1),a  
1ff1 3a fb 1f			ld a, (.dmark+2)  
1ff4 32 6d ee			ld (debug_mark+2),a  
1ff7 18 03			jr .pastdmark  
1ff9 ..			.dmark: db "LNX"  
1ffc f1			.pastdmark: pop af  
1ffd			endm  
# End of macro DMARK
1ffd						CALLMONITOR 
1ffd cd 6f ee			call debug_vector  
2000				endm  
# End of macro CALLMONITOR
2000					endif 
2000 22 f0 e9			ld (cli_loop_sp),hl 
2003 73				ld (hl), e 
2004 23				inc hl 
2005 72				ld (hl), d 
2006 d1				pop de    ; been reversed so save a swap on restore 
2007 e1				pop hl 
2008				if DEBUG_FORTH_STACK_GUARD 
2008 cd b4 63				call check_stacks 
200b				endif 
200b c9				ret 
200c			 
200c			; get current ret stack pointer and save to hl  
200c				 
200c			FORTH_LOOP_TOS: macro 
200c				call macro_forth_loop_tos 
200c				endm 
200c			 
200c			macro_forth_loop_tos: 
200c d5				push de 
200d 2a f0 e9			ld hl,(cli_loop_sp) 
2010 5e				ld e, (hl) 
2011 23				inc hl 
2012 56				ld d, (hl) 
2013 eb				ex de, hl 
2014 d1				pop de 
2015 c9				ret 
2016			 
2016			; pop loop stack pointer 
2016				 
2016			FORTH_LOOP_POP: macro 
2016				call macro_forth_loop_pop 
2016				endm 
2016			 
2016			 
2016			macro_forth_loop_pop: 
2016				if DEBUG_FORTH_STACK_GUARD 
2016					DMARK "LPP" 
2016 f5				push af  
2017 3a 2b 20			ld a, (.dmark)  
201a 32 6b ee			ld (debug_mark),a  
201d 3a 2c 20			ld a, (.dmark+1)  
2020 32 6c ee			ld (debug_mark+1),a  
2023 3a 2d 20			ld a, (.dmark+2)  
2026 32 6d ee			ld (debug_mark+2),a  
2029 18 03			jr .pastdmark  
202b ..			.dmark: db "LPP"  
202e f1			.pastdmark: pop af  
202f			endm  
# End of macro DMARK
202f cd b4 63				call check_stacks 
2032					FORTH_CHK_LOOP_UNDER 
2032 e5				push hl 
2033 d5				push de 
2034 2a f0 e9			ld hl,(cli_loop_sp) 
2037 11 2a e9			ld de, cli_loop_stack 
203a cd 04 0e			call cmp16 
203d da ce 64			jp c, fault_loop_under 
2040 d1				pop de 
2041 e1				pop hl 
2042				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2042				endif 
2042 e5				push hl 
2043 2a f0 e9			ld hl,(cli_loop_sp) 
2046 2b				dec hl 
2047 2b				dec hl 
2048 22 f0 e9			ld (cli_loop_sp), hl 
204b				; TODO do stack underflow checks 
204b e1				pop hl 
204c				if DEBUG_FORTH_STACK_GUARD 
204c cd b4 63				call check_stacks 
204f					FORTH_CHK_LOOP_UNDER 
204f e5				push hl 
2050 d5				push de 
2051 2a f0 e9			ld hl,(cli_loop_sp) 
2054 11 2a e9			ld de, cli_loop_stack 
2057 cd 04 0e			call cmp16 
205a da ce 64			jp c, fault_loop_under 
205d d1				pop de 
205e e1				pop hl 
205f				endm 
# End of macro FORTH_CHK_LOOP_UNDER
205f				endif 
205f c9				ret 
2060			 
2060			macro_forth_dsp_pop: 
2060			 
2060 e5				push hl 
2061			 
2061				; release malloc data 
2061			 
2061				if DEBUG_FORTH_STACK_GUARD 
2061 cd b4 63				call check_stacks 
2064					FORTH_CHK_DSP_UNDER 
2064 e5				push hl 
2065 d5				push de 
2066 2a ee e9			ld hl,(cli_data_sp) 
2069 11 28 e8			ld de, cli_data_stack 
206c cd 04 0e			call cmp16 
206f da c2 64			jp c, fault_dsp_under 
2072 d1				pop de 
2073 e1				pop hl 
2074				endm 
# End of macro FORTH_CHK_DSP_UNDER
2074				endif 
2074				;ld hl,(cli_data_sp) 
2074			if DEBUG_FORTH_DOT 
2074				DMARK "DPP" 
2074 f5				push af  
2075 3a 89 20			ld a, (.dmark)  
2078 32 6b ee			ld (debug_mark),a  
207b 3a 8a 20			ld a, (.dmark+1)  
207e 32 6c ee			ld (debug_mark+1),a  
2081 3a 8b 20			ld a, (.dmark+2)  
2084 32 6d ee			ld (debug_mark+2),a  
2087 18 03			jr .pastdmark  
2089 ..			.dmark: db "DPP"  
208c f1			.pastdmark: pop af  
208d			endm  
# End of macro DMARK
208d				CALLMONITOR 
208d cd 6f ee			call debug_vector  
2090				endm  
# End of macro CALLMONITOR
2090			endif	 
2090			 
2090			 
2090			if FORTH_ENABLE_DSPPOPFREE 
2090			 
2090				FORTH_DSP 
2090 cd 6e 1f			call macro_forth_dsp 
2093				endm 
# End of macro FORTH_DSP
2093			 
2093 7e				ld a, (hl) 
2094 fe 01			cp DS_TYPE_STR 
2096 20 23			jr nz, .skippopfree 
2098			 
2098				FORTH_DSP_VALUEHL 
2098 cd a8 1f			call macro_dsp_valuehl 
209b				endm 
# End of macro FORTH_DSP_VALUEHL
209b 00				nop 
209c			if DEBUG_FORTH_DOT 
209c				DMARK "DPf" 
209c f5				push af  
209d 3a b1 20			ld a, (.dmark)  
20a0 32 6b ee			ld (debug_mark),a  
20a3 3a b2 20			ld a, (.dmark+1)  
20a6 32 6c ee			ld (debug_mark+1),a  
20a9 3a b3 20			ld a, (.dmark+2)  
20ac 32 6d ee			ld (debug_mark+2),a  
20af 18 03			jr .pastdmark  
20b1 ..			.dmark: db "DPf"  
20b4 f1			.pastdmark: pop af  
20b5			endm  
# End of macro DMARK
20b5				CALLMONITOR 
20b5 cd 6f ee			call debug_vector  
20b8				endm  
# End of macro CALLMONITOR
20b8			endif	 
20b8 cd e2 14			call free 
20bb			.skippopfree: 
20bb				 
20bb			 
20bb			endif 
20bb			 
20bb			if DEBUG_FORTH_DOT_KEY 
20bb				DMARK "DP2" 
20bb				CALLMONITOR 
20bb			endif	 
20bb			 
20bb				; move pointer down 
20bb			 
20bb 2a ee e9			ld hl,(cli_data_sp) 
20be 2b				dec hl 
20bf 2b				dec hl 
20c0			; PARSEV5 
20c0 2b				dec hl 
20c1 22 ee e9			ld (cli_data_sp), hl 
20c4			 
20c4				if DEBUG_FORTH_STACK_GUARD 
20c4 cd b4 63				call check_stacks 
20c7					FORTH_CHK_DSP_UNDER 
20c7 e5				push hl 
20c8 d5				push de 
20c9 2a ee e9			ld hl,(cli_data_sp) 
20cc 11 28 e8			ld de, cli_data_stack 
20cf cd 04 0e			call cmp16 
20d2 da c2 64			jp c, fault_dsp_under 
20d5 d1				pop de 
20d6 e1				pop hl 
20d7				endm 
# End of macro FORTH_CHK_DSP_UNDER
20d7				endif 
20d7			 
20d7 e1				pop hl 
20d8			 
20d8 c9				ret 
20d9			 
20d9			getwordathl: 
20d9				; hl points to an address 
20d9				; load hl with the word at that address 
20d9			 
20d9 d5				push de 
20da			 
20da 5e				ld e, (hl) 
20db 23				inc hl 
20dc 56				ld d, (hl) 
20dd eb				ex de, hl 
20de			 
20de d1				pop de 
20df c9				ret 
20e0			 
20e0			 
20e0			 
20e0			 
20e0			 
20e0			; eof 
20e0			 
# End of file forth_stackopsv5.asm
20e0			endif 
20e0			 
20e0			loadwordinhl:	 
20e0			 
20e0 d5				push de 
20e1			 
20e1 5e				ld e, (hl) 
20e2 23				inc hl 
20e3 56				ld d, (hl) 
20e4 eb				ex de,hl  
20e5			 
20e5 d1				pop de 
20e6			 
20e6 c9				ret 
20e7			 
20e7			user_word_eol:  
20e7				; hl contains the pointer to where to create a linked list item from the end 
20e7				; of the user dict to continue on at the system word dict 
20e7				 
20e7				; poke the stub of the word list linked list to repoint to rom words 
20e7			 
20e7				; stub format 
20e7				; db   word id 
20e7				; dw    link to next word 
20e7			        ; db char length of token 
20e7				; db string + 0 term 
20e7				; db exec code....  
20e7			 
20e7 3e 00			ld a, WORD_SYS_ROOT     ; root word 
20e9 77				ld (hl), a		; word id 
20ea 23				inc hl 
20eb			 
20eb 11 b6 22			ld de, sysdict 
20ee 73				ld (hl), e		; next word link ie system dict 
20ef 23				inc hl 
20f0 72				ld (hl), d		; next word link ie system dict 
20f1 23				inc hl	 
20f2			 
20f2			;	ld (hl), sysdict		; next word link ie system dict 
20f2			;	inc hl 
20f2			;	inc hl 
20f2			 
20f2			;	inc hl 
20f2			;	inc hl 
20f2			 
20f2 3e 02			ld a, 2			; word length is 0 
20f4 77				ld (hl), a	 
20f5 23				inc hl 
20f6			 
20f6 3e 7e			ld a, '~'			; word length is 0 
20f8 77				ld (hl), a	 
20f9 23				inc hl 
20fa 3e 00			ld a, 0			; save empty word 
20fc 77				ld (hl), a 
20fd			 
20fd c9				ret 
20fe			 
20fe				 
20fe			 
20fe			forthexec_cleanup: 
20fe				FORTH_RSP_POP 
20fe cd 79 1d			call macro_forth_rsp_pop 
2101				endm 
# End of macro FORTH_RSP_POP
2101 c9				ret 
2102			 
2102			forth_call_hl: 
2102				; taking hl 
2102 e5				push hl 
2103 c9				ret 
2104			 
2104			; this is called to reset Forth system but keep existing uwords etc 
2104			 
2104			forth_warmstart: 
2104				; setup stack over/under flow checks 
2104				if DEBUG_FORTH_STACK_GUARD 
2104 cd 9a 63				call chk_stk_init 
2107				endif 
2107			 
2107				; init stack pointers  - * these stacks go upwards *  
2107 21 ac e9			ld hl, cli_ret_stack 
210a 22 f2 e9			ld (cli_ret_sp), hl	 
210d				; set bottom of stack 
210d 3e 00			ld a,0 
210f 77				ld (hl),a 
2110 23				inc hl 
2111 77				ld (hl),a 
2112			 
2112 21 28 e8			ld hl, cli_data_stack 
2115 22 ee e9			ld (cli_data_sp), hl	 
2118				; set bottom of stack 
2118 3e 00			ld a,0 
211a 77				ld (hl),a 
211b 23				inc hl 
211c 77				ld (hl),a 
211d			 
211d 21 2a e9			ld hl, cli_loop_stack 
2120 22 f0 e9			ld (cli_loop_sp), hl	 
2123				; set bottom of stack 
2123 3e 00			ld a,0 
2125 77				ld (hl),a 
2126 23				inc hl 
2127 77				ld (hl),a 
2128			 
2128				; init extent of current open file 
2128			 
2128 3e 00			ld a, 0 
212a 32 6a ea			ld (store_openext), a 
212d			 
212d c9				ret 
212e			 
212e			 
212e			 
212e			; Cold Start - this is called to setup the whole Forth system 
212e			 
212e			forth_init: 
212e			 
212e				; setup stack over/under flow checks 
212e			 
212e			;	if DEBUG_FORTH_STACK_GUARD 
212e			;		call chk_stk_init 
212e			;	endif 
212e			 
212e				; enable auto display updates (slow.....) 
212e			 
212e 3e 01			ld a, 1 
2130 32 3c ea			ld (cli_autodisplay), a 
2133			 
2133				; if storage is in use disable long reads for now 
2133 3e 00			ld a, 0 
2135 32 75 ea			ld (store_longread), a 
2138			 
2138			 
2138				; show start up screen 
2138			 
2138 cd b9 0b			call clear_display 
213b			 
213b 3e 00			ld a,0 
213d 32 5e ea			ld (f_cursor_ptr), a 
2140			 
2140				; set start of word list in start of ram - for use when creating user words 
2140			 
2140 21 a6 67			ld hl, baseram 
2143 22 be e5			ld (os_last_new_uword), hl 
2146 cd e7 20			call user_word_eol 
2149				 
2149			;		call display_data_sp 
2149			;		call next_page_prompt 
2149			 
2149			 
2149			 
2149			 
2149 c9				ret 
214a			 
214a .. 00		.bootforth: db " Forth Kernel Init ",0 
215e			 
215e			; TODO push to stack 
215e			 
215e			;  
215e			 
215e			if FORTH_PARSEV2 
215e			 
215e			 
215e				include "forth_parserv2.asm" 
215e			 
215e			endif 
215e			 
215e			 
215e			; parse cli version 1 
215e			 
215e			if FORTH_PARSEV1 
215e			 
215e			 
215e			 
215e			      include "forth_parserv1.asm" 
215e			endif 
215e				 
215e			if FORTH_PARSEV3 
215e			 
215e			 
215e			 
215e			      include "forth_parserv3.asm" 
215e				include "forth_wordsv3.asm" 
215e			endif 
215e			 
215e			if FORTH_PARSEV4 
215e			 
215e			 
215e			 
215e			      include "forth_parserv4.asm" 
215e				include "forth_wordsv4.asm" 
215e			endif 
215e			 
215e			if FORTH_PARSEV5 
215e			 
215e			 
215e			 
215e			      include "forth_parserv5.asm" 
215e			 
215e			 
215e			; A better parser without using malloc and string copies all over the place.  
215e			; Exec in situ should be faster 
215e			 
215e			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
215e			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
215e			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
215e			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
215e			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
215e			WORD_SYS_END: equ 0   ; Opcode for all user words 
215e			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
215e			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
215e			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
215e			 
215e			; Core word preamble macro 
215e			 
215e			CWHEAD:   macro nxtword opcode lit len opflags 
215e				db WORD_SYS_CORE+opcode             
215e				; internal op code number 
215e				dw nxtword            
215e				; link to next dict word block 
215e				db len + 1 
215e				; literal length of dict word inc zero term 
215e				db lit,0              
215e				; literal dict word 
215e			        ; TODO db opflags        
215e				endm 
215e			 
215e			 
215e			NEXTW: macro  
215e				jp macro_next 
215e				endm 
215e			 
215e			macro_next: 
215e			if DEBUG_FORTH_PARSE_KEY 
215e				DMARK "NXT" 
215e				CALLMONITOR 
215e			endif	 
215e			;	inc hl  ; skip token null term  
215e ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2162 ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2166 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2169			if DEBUG_FORTH_PARSE_KEY 
2169				DMARK "}AA" 
2169				CALLMONITOR 
2169			endif	 
2169 c3 6c 22			jp execnext 
216c				;jp exec1 
216c			       
216c			 
216c			 
216c			; Another go at the parser to compile  
216c			 
216c			 
216c			; TODO rework parser to change all of the string words to byte tokens 
216c			; TODO do a search for  
216c			 
216c			; TODO first run normal parser to zero term sections 
216c			; TODO for each word do a token look up to get the op code 
216c			; TODO need some means to flag to the exec that this is a byte code form    
216c			 
216c			 
216c			forthcompile: 
216c			 
216c			; 
216c			; line parse: 
216c			;       parse raw input buffer 
216c			;       tokenise the words 
216c			;       malloc new copy (for looping etc) 
216c			;       copy to malloc + current pc in line to start of string and add line term 
216c			;       save on new rsp 
216c			; 
216c			 
216c			; hl to point to the line to tokenise 
216c			 
216c			;	push hl 
216c 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
216f			 
216f			;	ld a,0		; string term on input 
216f			;	call strlent 
216f			 
216f			;	ld (os_tok_len), hl	 ; save string length 
216f			 
216f			;if DEBUG_FORTH_TOK 
216f			;	ex de,hl		 
216f			;endif 
216f			 
216f			;	pop hl 		; get back string pointer 
216f			 
216f			if DEBUG_FORTH_TOK 
216f						DMARK "TOc" 
216f				CALLMONITOR 
216f			endif 
216f 7e			.cptoken2:    ld a,(hl) 
2170 23				inc hl 
2171 fe 7f			cp FORTH_END_BUFFER 
2173 28 29			jr z, .cptokendone2 
2175 fe 00			cp 0 
2177 28 25			jr z, .cptokendone2 
2179 fe 22			cp '"' 
217b 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
217d fe 20			cp ' ' 
217f 20 ee			jr nz,  .cptoken2 
2181			 
2181			; TODO consume comments held between ( and ) 
2181			 
2181				; we have a space so change to zero term for dict match later 
2181 2b				dec hl 
2182 3e 00			ld a,0 
2184 77				ld (hl), a 
2185 23				inc hl 
2186 18 e7			jr .cptoken2 
2188				 
2188			 
2188			.cptokenstr2: 
2188				; skip all white space until either eol (because forgot to term) or end double quote 
2188			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2188				;inc hl ; skip current double quote 
2188 7e				ld a,(hl) 
2189 23				inc hl 
218a fe 22			cp '"' 
218c 28 e1			jr z, .cptoken2 
218e fe 7f			cp FORTH_END_BUFFER 
2190 28 0c			jr z, .cptokendone2 
2192 fe 00			cp 0 
2194 28 08			jr z, .cptokendone2 
2196 fe 20			cp ' ' 
2198 28 02			jr z, .cptmp2 
219a 18 ec			jr .cptokenstr2 
219c			 
219c			.cptmp2:	; we have a space so change to zero term for dict match later 
219c				;dec hl 
219c				;ld a,"-"	; TODO remove this when working 
219c				;ld (hl), a 
219c				;inc hl 
219c 18 ea			jr .cptokenstr2 
219e			 
219e			.cptokendone2: 
219e				;inc hl 
219e 3e 7f			ld a, FORTH_END_BUFFER 
21a0 77				ld (hl),a 
21a1 23				inc hl 
21a2 3e 21			ld a, '!' 
21a4 77				ld (hl),a 
21a5			 
21a5 2a c2 e5			ld hl,(os_tok_ptr) 
21a8			         
21a8			if DEBUG_FORTH_TOK 
21a8						DMARK "Tc1" 
21a8				CALLMONITOR 
21a8			endif 
21a8			 
21a8				; push exec string to top of return stack 
21a8				FORTH_RSP_NEXT 
21a8 cd 58 1d			call macro_forth_rsp_next 
21ab				endm 
# End of macro FORTH_RSP_NEXT
21ab c9				ret 
21ac			 
21ac			; Another go at the parser need to simplify the process 
21ac			 
21ac			forthparse: 
21ac			 
21ac			; 
21ac			; line parse: 
21ac			;       parse raw input buffer 
21ac			;       tokenise the words 
21ac			;       malloc new copy (for looping etc) 
21ac			;       copy to malloc + current pc in line to start of string and add line term 
21ac			;       save on new rsp 
21ac			; 
21ac			 
21ac			; hl to point to the line to tokenise 
21ac			 
21ac			;	push hl 
21ac 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
21af			 
21af			;	ld a,0		; string term on input 
21af			;	call strlent 
21af			 
21af			;	ld (os_tok_len), hl	 ; save string length 
21af			 
21af			;if DEBUG_FORTH_TOK 
21af			;	ex de,hl		 
21af			;endif 
21af			 
21af			;	pop hl 		; get back string pointer 
21af			 
21af			if DEBUG_FORTH_TOK 
21af						DMARK "TOK" 
21af				CALLMONITOR 
21af			endif 
21af 7e			.ptoken2:    ld a,(hl) 
21b0 23				inc hl 
21b1 fe 7f			cp FORTH_END_BUFFER 
21b3 28 29			jr z, .ptokendone2 
21b5 fe 00			cp 0 
21b7 28 25			jr z, .ptokendone2 
21b9 fe 22			cp '"' 
21bb 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
21bd fe 20			cp ' ' 
21bf 20 ee			jr nz,  .ptoken2 
21c1			 
21c1			; TODO consume comments held between ( and ) 
21c1			 
21c1				; we have a space so change to zero term for dict match later 
21c1 2b				dec hl 
21c2 3e 00			ld a,0 
21c4 77				ld (hl), a 
21c5 23				inc hl 
21c6 18 e7			jr .ptoken2 
21c8				 
21c8			 
21c8			.ptokenstr2: 
21c8				; skip all white space until either eol (because forgot to term) or end double quote 
21c8			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
21c8				;inc hl ; skip current double quote 
21c8 7e				ld a,(hl) 
21c9 23				inc hl 
21ca fe 22			cp '"' 
21cc 28 e1			jr z, .ptoken2 
21ce fe 7f			cp FORTH_END_BUFFER 
21d0 28 0c			jr z, .ptokendone2 
21d2 fe 00			cp 0 
21d4 28 08			jr z, .ptokendone2 
21d6 fe 20			cp ' ' 
21d8 28 02			jr z, .ptmp2 
21da 18 ec			jr .ptokenstr2 
21dc			 
21dc			.ptmp2:	; we have a space so change to zero term for dict match later 
21dc				;dec hl 
21dc				;ld a,"-"	; TODO remove this when working 
21dc				;ld (hl), a 
21dc				;inc hl 
21dc 18 ea			jr .ptokenstr2 
21de			 
21de			.ptokendone2: 
21de				;inc hl 
21de 3e 7f			ld a, FORTH_END_BUFFER 
21e0 77				ld (hl),a 
21e1 23				inc hl 
21e2 3e 21			ld a, '!' 
21e4 77				ld (hl),a 
21e5			 
21e5 2a c2 e5			ld hl,(os_tok_ptr) 
21e8			         
21e8			if DEBUG_FORTH_TOK 
21e8						DMARK "TK1" 
21e8				CALLMONITOR 
21e8			endif 
21e8			 
21e8				; push exec string to top of return stack 
21e8				FORTH_RSP_NEXT 
21e8 cd 58 1d			call macro_forth_rsp_next 
21eb				endm 
# End of macro FORTH_RSP_NEXT
21eb c9				ret 
21ec			 
21ec			; 
21ec			;	; malloc size + buffer pointer + if is loop flag 
21ec			;	ld hl,(os_tok_len) 		 ; get string length 
21ec			; 
21ec			;	ld a,l 
21ec			; 
21ec			;	cp 0			; we dont want to use a null string 
21ec			;	ret z 
21ec			; 
21ec			;;	add 3    ; prefix malloc with buffer for current word ptr 
21ec			; 
21ec			;	add 5     ; TODO when certain not over writing memory remove 
21ec			; 
21ec			;		 
21ec			; 
21ec			;if DEBUG_FORTH_TOK 
21ec			;			DMARK "TKE" 
21ec			;	CALLMONITOR 
21ec			;endif 
21ec			; 
21ec			;	ld l,a 
21ec			;	ld h,0 
21ec			;;	push hl   ; save required space for the copy later 
21ec			;	call malloc 
21ec			;if DEBUG_FORTH_TOK 
21ec			;			DMARK "TKM" 
21ec			;	CALLMONITOR 
21ec			;endif 
21ec			;	if DEBUG_FORTH_MALLOC_GUARD 
21ec			;		push af 
21ec			;		call ishlzero 
21ec			;;		ld a, l 
21ec			;;		add h 
21ec			;;		cp 0 
21ec			;		pop af 
21ec			;		 
21ec			;		call z,malloc_error 
21ec			;	endif 
21ec			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
21ec			; 
21ec			; 
21ec			;if DEBUG_FORTH_TOK 
21ec			;			DMARK "TKR" 
21ec			;	CALLMONITOR 
21ec			;endif 
21ec			; 
21ec			;	FORTH_RSP_NEXT 
21ec			; 
21ec			;	;inc hl	 ; go past current buffer pointer 
21ec			;	;inc hl 
21ec			;	;inc hl   ; and past if loop flag 
21ec			;		; TODO Need to set flag  
21ec			; 
21ec			;	 
21ec			;	 
21ec			;	ex de,hl	; malloc is dest 
21ec			;	ld hl, (os_tok_len) 
21ec			;;	pop bc 
21ec			;	ld c, l                
21ec			;	ld b,0 
21ec			;	ld hl, (os_tok_ptr) 
21ec			; 
21ec			;if DEBUG_FORTH_TOK 
21ec			;			DMARK "TKT" 
21ec			;	CALLMONITOR 
21ec			;endif 
21ec			; 
21ec			;	; do str cpy 
21ec			; 
21ec			;	ldir      ; copy byte in hl to de 
21ec			; 
21ec			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
21ec			; 
21ec			;if DEBUG_FORTH_TOK 
21ec			; 
21ec			;			DMARK "TKY" 
21ec			;	CALLMONITOR 
21ec			;endif 
21ec			;	;ld a,0 
21ec			;	;ld a,FORTH_END_BUFFER 
21ec			;	ex de, hl 
21ec			;	;dec hl			 ; go back over the space delim at the end of word 
21ec			;	;ld (hl),a 
21ec			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
21ec			;	ld a,FORTH_END_BUFFER 
21ec			;	ld (hl),a 
21ec			;	inc hl 
21ec			;	ld a,FORTH_END_BUFFER 
21ec			;	ld (hl),a 
21ec			; 
21ec			;	; init the malloc area data 
21ec			;	; set pc for in current area 
21ec			;	;ld hl, (os_tok_malloc) 
21ec			;	;inc hl 
21ec			;	;inc hl 
21ec			;	;inc hl 
21ec			;	;ex de,hl 
21ec			;	;ld hl, (os_tok_malloc) 
21ec			;	;ld (hl),e 
21ec			;	;inc hl 
21ec			;	;ld (hl),d 
21ec			; 
21ec			; 
21ec			;	ld hl,(os_tok_malloc) 
21ec			;if DEBUG_FORTH_PARSE_KEY 
21ec			;			DMARK "TKU" 
21ec			;	CALLMONITOR 
21ec			;endif 
21ec			; 
21ec			;	ret 
21ec			 
21ec			forthexec: 
21ec			 
21ec			; line exec: 
21ec			; forth parser 
21ec			 
21ec			; 
21ec			;       get current exec line on rsp 
21ec			 
21ec				FORTH_RSP_TOS 
21ec cd 6f 1d			call macro_forth_rsp_tos 
21ef				endm 
# End of macro FORTH_RSP_TOS
21ef			 
21ef			;       restore current pc - hl points to malloc of data 
21ef			 
21ef				;ld e, (hl) 
21ef				;inc hl 
21ef				;ld d, (hl) 
21ef				;ex de,hl 
21ef			 
21ef			 
21ef			exec1: 
21ef 22 c2 e5			ld (os_tok_ptr), hl 
21f2			 
21f2				; copy our PC to working vars  
21f2 22 40 ea			ld (cli_ptr), hl 
21f5 22 3e ea			ld (cli_origptr), hl 
21f8			 
21f8 7e				ld a,(hl) 
21f9 fe 7f			cp FORTH_END_BUFFER 
21fb c8				ret z 
21fc			 
21fc				; skip any nulls 
21fc			 
21fc fe 00			cp 0 
21fe 20 03			jr nz, .execword 
2200 23				inc hl 
2201 18 ec			jr exec1 
2203			 
2203			 
2203			.execword: 
2203			 
2203			 
2203			 
2203			if DEBUG_FORTH_PARSE_KEY 
2203						DMARK "KYQ" 
2203				CALLMONITOR 
2203			endif 
2203			;       while at start of word: 
2203			; get start of dict (in user area first) 
2203			 
2203 21 a6 67		ld hl, baseram 
2206			;ld hl, sysdict 
2206 22 42 ea		ld (cli_nextword),hl 
2209			;           match word at pc 
2209			;           exec word 
2209			;           or push to dsp 
2209			;           forward to next token 
2209			;           if line term pop rsp and exit 
2209			;        
2209			 
2209			if DEBUG_FORTH_PARSE_KEY 
2209						DMARK "KYq" 
2209				CALLMONITOR 
2209			endif 
2209			 
2209			; 
2209			; word comp 
2209			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2209			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2209			;    move to start of word  
2209			;    compare word to cli_token 
2209			 
2209			.execpnword:	; HL at start of a word in the dictionary to check 
2209			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2209			;	ld (cli_ptr), hl 
2209			 
2209 2a 42 ea			ld hl,(cli_nextword) 
220c			 
220c cd af 22			call forth_tok_next 
220f			; tok next start here 
220f			;	; TODO skip compiled symbol for now 
220f			;	inc hl 
220f			; 
220f			;	; save pointer to next word 
220f			; 
220f			;	; hl now points to the address of the next word pointer  
220f			;	ld e, (hl) 
220f			;	inc hl 
220f			;	ld d, (hl) 
220f			;	inc l 
220f			; 
220f			;	ex de,hl 
220f			;if DEBUG_FORTH_PARSE_NEXTWORD 
220f			;	push bc 
220f			;	ld bc, (cli_nextword) 
220f			;			DMARK "NXW" 
220f			;	CALLMONITOR 
220f			;	pop bc 
220f			;endif 
220f			; tok next end here 
220f 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
2212 eb				ex de, hl 
2213			 
2213			 
2213				; save the pointer of the current token - 1 to check against 
2213				 
2213 22 46 ea			ld (cli_token), hl   
2216				; TODO maybe remove below save if no debug 
2216				; save token string ptr for any debug later 
2216 23				inc hl  
2217 22 48 ea			ld (cli_origtoken), hl 
221a 2b				dec hl 
221b				; save pointer to the start of the next dictionay word 
221b 7e				ld a,(hl)   ; get string length 
221c 47				ld b,a 
221d			.execpnwordinc:  
221d 23				inc hl 
221e 10 fd			djnz .execpnwordinc 
2220 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
2223			 
2223				; now check the word token against the string being parsed 
2223			 
2223 2a 46 ea			ld hl,(cli_token) 
2226 23				inc hl     ; skip string length (use zero term instead to end) 
2227 22 46 ea			ld (cli_token), hl 
222a			 
222a			if DEBUG_FORTH_PARSE_KEY 
222a						DMARK "KY2" 
222a			endif 
222a			if DEBUG_FORTH_PARSE_EXEC 
222a				; see if disabled 
222a			 
222a			;	ld a, (os_view_disable) 
222a			;	cp '*' 
222a				ld a, (debug_vector) 
222a				cp $c9   ; RET  
222a				jr z, .skip 
222a			 
222a				push hl 
222a				push hl 
222a				call clear_display 
222a				ld de, .compword 
222a				ld a, display_row_1 
222a				call str_at_display 
222a				pop de 
222a				ld a, display_row_2 
222a				call str_at_display 
222a				ld hl,(cli_ptr) 
222a				ld a,(hl) 
222a			        ld hl, os_word_scratch 
222a				ld (hl),a 
222a				ld a,0 
222a				inc hl 
222a				ld (hl),a 	 
222a				ld de, os_word_scratch 
222a				ld a, display_row_2+10 
222a				call str_at_display 
222a				call update_display 
222a				ld a, 100 
222a				call aDelayInMS 
222a				if DEBUG_FORTH_PARSE_EXEC_SLOW 
222a				call delay250ms 
222a				endif 
222a				pop hl 
222a			.skip:  
222a			endif	 
222a			.execpnchar:    ; compare char between token and string to parse 
222a			 
222a			if DEBUG_FORTH_PARSE_KEY 
222a						DMARK "Ky3" 
222a			endif 
222a			if DEBUG_FORTH_PARSE_EXEC 
222a				; see if disabled 
222a			 
222a			;	ld a, (os_view_disable) 
222a			;	cp '*' 
222a				ld a, (debug_vector) 
222a				cp $C9  ; RET 
222a				jr z, .skip2 
222a			 
222a			;	call clear_display 
222a			ld hl,(cli_token) 
222a			ld a,(hl) 
222a			ld (os_word_scratch),a 
222a				ld hl,(cli_ptr) 
222a			ld a,(hl) 
222a				ld (os_word_scratch+1),a 
222a				ld a,0 
222a				ld (os_word_scratch+2),a 
222a				ld de,os_word_scratch 
222a				ld a,display_row_4 
222a				call str_at_display 
222a				call update_display 
222a			.skip2:  
222a			endif 
222a 2a 46 ea			ld hl,(cli_token) 
222d 7e				ld a, (hl)	 ; char in word token 
222e 23				inc hl 		; move to next char 
222f 22 46 ea			ld (cli_token), hl ; and save it 
2232 47				ld b,a 
2233			 
2233 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
2236 7e				ld a,(hl) 
2237 23				inc hl 
2238 22 40 ea			ld (cli_ptr), hl		; move to next char 
223b cd 9a 13			call toUpper 		; make sure the input string matches case 
223e			 
223e			if DEBUG_FORTH_PARSE 
223e			endif 
223e			 
223e				; input stream end of token is a space so get rid of it 
223e			 
223e			;	cp ' ' 
223e			;	jr nz, .pnskipspace 
223e			; 
223e			;	ld a, 0		; make same term as word token term 
223e			; 
223e			;.pnskipspace: 
223e			 
223e			if DEBUG_FORTH_PARSE_KEY 
223e						DMARK "KY7" 
223e			endif 
223e b8				cp b 
223f c2 55 22			jp nz, .execpnskipword	 ; no match so move to next word 
2242				 
2242			;    if same 
2242			;       scan for string terms 0 for token and 32 for input 
2242			 
2242				 
2242			if DEBUG_FORTH_PARSE_KEY 
2242						DMARK "KY8" 
2242			endif 
2242			 
2242 80				add b			 
2243 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2245							; TODO need to make sure last word in zero term string is accounted for 
2245 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2247			 
2247			 
2247				; at end of both strings so both are exact match 
2247			 
2247			;       skip ptr for next word 
2247			 
2247 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
224a 23				inc hl			 ; at next char 
224b 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
224e 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2251				 
2251				 
2251			if DEBUG_FORTH_PARSE_KEY 
2251						DMARK "KY3" 
2251			endif 
2251			 
2251			 
2251			 
2251			;       exec code block 
2251			if DEBUG_FORTH_JP 
2251				call clear_display 
2251				call update_display 
2251				call delay1s 
2251				ld hl, (cli_execword)     ; save for next check if no match on this word 
2251				ld a,h 
2251				ld hl, os_word_scratch 
2251				call hexout 
2251				ld hl, (cli_execword)     ; save for next check if no match on this word 
2251				ld a,l 
2251				ld hl, os_word_scratch+2 
2251				call hexout 
2251				ld hl, os_word_scratch+4 
2251				ld a,0 
2251				ld (hl),a 
2251				ld de,os_word_scratch 
2251				call str_at_display 
2251					ld a, display_row_2 
2251					call str_at_display 
2251				ld de, (cli_origtoken) 
2251				ld a, display_row_1+10 
2251					call str_at_display 
2251			 
2251				ld a,display_row_1 
2251				ld de, .foundword 
2251				ld a, display_row_3 
2251				call str_at_display 
2251				call update_display 
2251				call delay1s 
2251				call delay1s 
2251				call delay1s 
2251			endif 
2251			 
2251			if DEBUG_FORTH_PARSE_KEY 
2251						DMARK "KYj" 
2251			endif 
2251				; TODO save the word pointer in this exec 
2251			 
2251 2a 44 ea			ld hl,(cli_execword) 
2254 e9				jp (hl) 
2255			 
2255			 
2255			;    if not same 
2255			;	scan for zero term 
2255			;	get ptr for next word 
2255			;	goto word comp 
2255			 
2255			.execpnskipword:	; get pointer to next word 
2255 2a 42 ea			ld hl,(cli_nextword) 
2258			 
2258 7e				ld a,(hl) 
2259 fe 00			cp WORD_SYS_END 
225b			;	cp 0 
225b 28 09			jr z, .execendofdict			 ; at end of words 
225d			 
225d			if DEBUG_FORTH_PARSE_KEY 
225d						DMARK "KY4" 
225d			endif 
225d			if DEBUG_FORTH_PARSE_EXEC 
225d			 
225d				; see if disabled 
225d			 
225d			;	ld a, (os_view_disable) 
225d			;	cp '*' 
225d				ld a,(debug_vector) 
225d				cp $c9   ; RET 
225d				jr z, .noskip 
225d			 
225d			 
225d				ld de, .nowordfound 
225d				ld a, display_row_3 
225d				call str_at_display 
225d				call update_display 
225d				ld a, 100 
225d				call aDelayInMS 
225d				 
225d				if DEBUG_FORTH_PARSE_EXEC_SLOW 
225d					call delay250ms 
225d				endif 
225d			.noskip:  
225d			 
225d			endif	 
225d			 
225d 2a 3e ea			ld hl,(cli_origptr) 
2260 22 40 ea			ld (cli_ptr),hl 
2263			 
2263			if DEBUG_FORTH_PARSE_KEY 
2263						DMARK "KY5" 
2263			endif 
2263 c3 09 22			jp .execpnword			; else go to next word 
2266			 
2266			.execendofdict:  
2266			 
2266			if DEBUG_FORTH_PARSE_KEY 
2266						DMARK "KYe" 
2266			endif 
2266			if DEBUG_FORTH_PARSE_EXEC 
2266				; see if disabled 
2266			 
2266			;	ld a, (os_view_disable) 
2266			;	cp '*' 
2266				ld a,(debug_vector) 
2266				cp $c9   ; ret 
2266				jr z, .ispskip 
2266			 
2266				call clear_display 
2266				call update_display 
2266				call delay1s 
2266				ld de, (cli_origptr) 
2266				ld a, display_row_1 
2266				call str_at_display 
2266				 
2266				ld de, .enddict 
2266				ld a, display_row_3 
2266				call str_at_display 
2266				call update_display 
2266				ld a, 100 
2266				call aDelayInMS 
2266				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2266				call delay1s 
2266				call delay1s 
2266				call delay1s 
2266				endif 
2266			.ispskip:  
2266				 
2266			endif	 
2266			 
2266			 
2266			 
2266				; if the word is not a keyword then must be a literal so push it to stack 
2266			 
2266			; push token to stack to end of word 
2266			 
2266				STACKFRAME ON $1efe $2f9f 
2266				if DEBUG_STACK_IMB 
2266					if ON 
2266						exx 
2266						ld de, $1efe 
2266						ld a, d 
2266						ld hl, curframe 
2266						call hexout 
2266						ld a, e 
2266						ld hl, curframe+2 
2266						call hexout 
2266						ld hl, $1efe 
2266						push hl 
2266						ld hl, $2f9f 
2266						push hl 
2266						exx 
2266					endif 
2266				endif 
2266			endm 
# End of macro STACKFRAME
2266			 
2266 2a c2 e5		ld hl,(os_tok_ptr) 
2269 cd 1a 1f		call forth_apush 
226c			 
226c				STACKFRAMECHK ON $1efe $2f9f 
226c				if DEBUG_STACK_IMB 
226c					if ON 
226c						exx 
226c						ld hl, $2f9f 
226c						pop de   ; $2f9f 
226c						call cmp16 
226c						jr nz, .spnosame 
226c						ld hl, $1efe 
226c						pop de   ; $1efe 
226c						call cmp16 
226c						jr z, .spfrsame 
226c						.spnosame: call showsperror 
226c						.spfrsame: nop 
226c						exx 
226c					endif 
226c				endif 
226c			endm 
# End of macro STACKFRAMECHK
226c			 
226c			execnext: 
226c			 
226c			if DEBUG_FORTH_PARSE_KEY 
226c						DMARK "KY>" 
226c			endif 
226c			; move past token to next word 
226c			 
226c 2a c2 e5		ld hl, (os_tok_ptr) 
226f 3e 00		ld a, 0 
2271 01 ff 00		ld bc, 255     ; input buffer size 
2274 ed b1		cpir 
2276			 
2276			if DEBUG_FORTH_PARSE_KEY 
2276						DMARK "KY!" 
2276				CALLMONITOR 
2276			endif	 
2276			; TODO this might place hl on the null, so will need to forward on??? 
2276			;inc hl   ; see if this gets onto the next item 
2276			 
2276			 
2276			; TODO pass a pointer to the buffer to push 
2276			; TODO call function to push 
2276			 
2276			; look for end of input 
2276			 
2276			;inc hl 
2276			;ld a,(hl) 
2276			;cp FORTH_END_BUFFER 
2276			;ret z 
2276			 
2276			 
2276 c3 ef 21		jp exec1 
2279			 
2279			 
2279			 
2279			 
2279			 
2279			 
2279			 
2279			 
2279			 
2279			findnexttok: 
2279			 
2279				; hl is pointer to move 
2279				; de is the token to locate 
2279			 
2279					if DEBUG_FORTH 
2279						DMARK "NTK" 
2279						CALLMONITOR 
2279					endif 
2279 d5				push de 
227a			 
227a			.fnt1:	 
227a				; find first char of token to locate 
227a			 
227a 1a				ld a, (de) 
227b 4f				ld c,a 
227c 7e				ld a,(hl) 
227d cd 9a 13			call toUpper 
2280					if DEBUG_FORTH 
2280						DMARK "NT1" 
2280						CALLMONITOR 
2280					endif 
2280 b9				cp c 
2281			 
2281 28 03			jr z, .fnt2cmpmorefirst	 
2283			 
2283				; first char not found move to next char 
2283			 
2283 23				inc hl 
2284 18 f4			jr .fnt1 
2286			 
2286			.fnt2cmpmorefirst:	 
2286				; first char of token found.  
2286			 
2286 e5				push hl     ; save start of token just in case it is the right one 
2287 d9				exx 
2288 e1				pop hl        ; save it to hl' 
2289 d9				exx 
228a			 
228a			 
228a			.fnt2cmpmore:	 
228a				; compare the rest 
228a				 
228a 23				inc hl 
228b 13				inc de 
228c				 
228c 1a				ld a, (de) 
228d 4f				ld c,a 
228e 7e				ld a,(hl) 
228f cd 9a 13			call toUpper 
2292			 
2292					if DEBUG_FORTH 
2292						DMARK "NT2" 
2292						CALLMONITOR 
2292					endif 
2292				; c has the token to find char 
2292				; a has the mem to scan char 
2292			 
2292 b9				cp c 
2293 28 04			jr z,.fntmatch1 
2295			 
2295				; they are not the same 
2295			 
2295					if DEBUG_FORTH 
2295						DMARK "NT3" 
2295						CALLMONITOR 
2295					endif 
2295 d1				pop de	; reset de token to look for 
2296 d5				push de 
2297 18 e1			jr .fnt1 
2299				 
2299			.fntmatch1: 
2299			 
2299				; is the same char a null which means we might have a full hit? 
2299					if DEBUG_FORTH 
2299						DMARK "NT4" 
2299						CALLMONITOR 
2299					endif 
2299			 
2299 fe 00			cp 0 
229b 28 0b			jr z, .fntmatchyes 
229d			 
229d				; are we at the end of the token to find? 
229d			 
229d					if DEBUG_FORTH 
229d						DMARK "NT5" 
229d						CALLMONITOR 
229d					endif 
229d 3e 00			ld a, 0 
229f b9				cp c 
22a0			 
22a0 c2 8a 22			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
22a3			 
22a3					if DEBUG_FORTH 
22a3						DMARK "NT6" 
22a3						CALLMONITOR 
22a3					endif 
22a3				; token to find is exhusted but no match to stream 
22a3			 
22a3				; restore tok pointer and continue on 
22a3 d1				pop de 
22a4 d5				push de 
22a5 c3 7a 22			jp .fnt1 
22a8			 
22a8			 
22a8			.fntmatchyes: 
22a8			 
22a8				; hl now contains the end of the found token 
22a8			 
22a8				; get rid of saved token pointer to find 
22a8			 
22a8 d1				pop de 
22a9			 
22a9					if DEBUG_FORTH 
22a9						DMARK "NT9" 
22a9						CALLMONITOR 
22a9					endif 
22a9			 
22a9				; hl will be on the null term so forward on 
22a9			 
22a9				; get back the saved start of the token 
22a9			 
22a9 d9				exx 
22aa e5				push hl     ; save start of token just in case it is the right one 
22ab d9				exx 
22ac e1				pop hl        ; save it to hl 
22ad			 
22ad c9				ret 
22ae			 
22ae			 
22ae			; LIST needs to find a specific token   
22ae			; FORGET needs to find a spefici token 
22ae			 
22ae			; SAVE needs to find all tokens by flag 
22ae			; WORDS just needs to scan through all  by flag 
22ae			; UWORDS needs to scan through all by flag 
22ae			 
22ae			 
22ae			; given hl as pointer to start of dict look up string 
22ae			; return hl as pointer to start of word block 
22ae			; or 0 if not found 
22ae			 
22ae			forth_find_tok: 
22ae c9				ret 
22af			 
22af			; given hl as pointer to dict structure 
22af			; move to the next dict block structure 
22af			 
22af			forth_tok_next: 
22af				; hl now points to the address of the next word pointer  
22af				; TODO skip compiled symbol for now 
22af			;	push de 
22af 23				inc hl 
22b0 5e				ld e, (hl) 
22b1 23				inc hl 
22b2 56				ld d, (hl) 
22b3 23				inc hl 
22b4			 
22b4 eb				ex de,hl 
22b5			if DEBUG_FORTH_PARSE_NEXTWORD 
22b5				push bc 
22b5				ld bc, (cli_nextword) 
22b5						DMARK "NXW" 
22b5				CALLMONITOR 
22b5				pop bc 
22b5			endif 
22b5			;	pop de	 
22b5 c9				ret 
22b6			 
22b6			 
22b6			 
22b6			; eof 
# End of file forth_parserv5.asm
22b6				include "forth_wordsv4.asm" 
22b6			 
22b6			; the core word dictionary v4 
22b6			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
22b6			 
22b6			; this is a linked list for each of the system words used 
22b6			; user defined words will follow the same format but will be in ram 
22b6			 
22b6			 
22b6			; 
22b6			; 
22b6			; define linked list: 
22b6			; 
22b6			; 1. compiled byte op code 
22b6			; 2. len of text word 
22b6			; 3. text word 
22b6			; 4. ptr to next dictionary word 
22b6			; 5. asm, calls etc for the word 
22b6			; 
22b6			;  if 1 == 0 then last word in dict  
22b6			;   
22b6			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
22b6			;  
22b6			;  
22b6			; create basic standard set of words 
22b6			; 
22b6			;  
22b6			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
22b6			; 2DUP 2DROP 2SWAP  
22b6			; @ C@ - get byte  
22b6			; ! C! - store byte 
22b6			; 0< true if less than zero 
22b6			; 0= true if zero 
22b6			; < >  
22b6			; = true if same 
22b6			; variables 
22b6			 
22b6			 
22b6			; Hardware specific words I may need 
22b6			; 
22b6			; IN OUT  
22b6			; calls to key util functions 
22b6			; calls to hardward abstraction stuff 
22b6			; easy control of frame buffers and lcd i/o 
22b6			; keyboard  
22b6			 
22b6			 
22b6			;DICT: macro 
22b6			; op_code, len, word, next 
22b6			;    word: 
22b6			;    db op_code 
22b6			;    ds word zero term 
22b6			;    dw next 
22b6			;    endm 
22b6			 
22b6			 
22b6			 
22b6			 
22b6			; op code 1 is a flag for user define words which are to be handled differently 
22b6			 
22b6			 
22b6			; 
22b6			; 
22b6			;    TODO on entry to a word this should be the expected environment 
22b6			;    hl - tos value if number then held, if string this is the ptr 
22b6			;    de -  
22b6			 
22b6			 
22b6			; opcode ranges 
22b6			; 0 - end of word dict 
22b6			; 255 - user define words 
22b6			 
22b6			sysdict: 
22b6			include "forth_opcodes.asm" 
22b6			; op codes for forth keywords 
22b6			; free to use code 0  
22b6				OPCODE_HEAP: equ  1 
22b6				OPCODE_EXEC: equ 2 
22b6				OPCODE_DUP: equ 3 
22b6				OPCODE_SWAP: equ 4 
22b6				OPCODE_COLN: equ 5 
22b6				OPCODE_SCOLN: equ 6 
22b6				OPCODE_DROP: equ 7 
22b6				OPCODE_DUP2: equ 8 
22b6				OPCODE_DROP2: equ 9 
22b6				OPCODE_SWAP2: equ 10 
22b6				OPCODE_AT: equ 11 
22b6				OPCODE_CAT: equ 12 
22b6				OPCODE_BANG: equ 13 
22b6				OPCODE_CBANG: equ 14 
22b6				OPCODE_SCALL: equ 15 
22b6				OPCODE_DEPTH: equ 16 
22b6				OPCODE_OVER: equ 17 
22b6				OPCODE_PAUSE: equ 18 
22b6				OPCODE_PAUSES: equ 19 
22b6				OPCODE_ROT: equ 20 
22b6			;free to reuse	OPCODE_WORDS: equ 21 
22b6			        OPCODE_NOT: equ 21 
22b6				OPCODE_UWORDS: equ 22 
22b6				OPCODE_BP: equ 23 
22b6				OPCODE_MONITOR: equ 24  
22b6				OPCODE_MALLOC: equ 25 
22b6				OPCODE_FREE: equ 26 
22b6				OPCODE_LIST: equ 27 
22b6				OPCODE_FORGET: equ 28 
22b6				OPCODE_NOP: equ 29 
22b6				OPCODE_COMO: equ 30 
22b6				OPCODE_COMC: equ 31 
22b6			;free to reuse	OPCODE_ENDCORE: equ 32 
22b6				OPCODE_AFTERSOUND: equ 33 
22b6				OPCODE_GP2: equ 34 
22b6				OPCODE_GP3: equ 35 
22b6				OPCODE_GP4: equ 36 
22b6				OPCODE_SIN: equ 37 
22b6				OPCODE_SOUT: equ 38 
22b6				OPCODE_SPIO: equ 39 
22b6				OPCODE_SPICEH: equ 40 
22b6				OPCODE_SPIOb: equ 41 
22b6				OPCODE_SPII: equ 42 
22b6				OPCODE_SESEL: equ 43 
22b6				OPCODE_CARTDEV: equ 44 
22b6			; free to reuse	OPCODE_ENDDEVICE: equ 45 
22b6				OPCODE_FB: equ 46 
22b6				OPCODE_EMIT: equ 47 
22b6				OPCODE_DOTH: equ 48 
22b6				OPCODE_DOTF: equ 49 
22b6				OPCODE_DOT: equ 50 
22b6				OPCODE_CLS: equ 51 
22b6				OPCODE_DRAW: equ 52 
22b6				OPCODE_DUMP: equ 53 
22b6				OPCODE_CDUMP: equ 54 
22b6				OPCODE_DAT: equ 55 
22b6				OPCODE_HOME: equ 56 
22b6				OPCODE_SPACE: equ 57 
22b6				OPCODE_SPACES: equ 58 
22b6				OPCODE_SCROLL: equ 59 
22b6				OPCODE_ATQ: equ 60 
22b6				OPCODE_AUTODSP: equ 61 
22b6				OPCODE_MENU: equ 62 
22b6			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
22b6				OPCODE_THEN: equ 64 
22b6				OPCODE_ELSE: equ 65 
22b6				OPCODE_DO: equ 66 
22b6				OPCODE_LOOP: equ 67 
22b6				OPCODE_I: equ 68 
22b6				OPCODE_DLOOP: equ 69  
22b6				OPCODE_REPEAT: equ 70  
22b6				OPCODE_UNTIL: equ 71 
22b6				OPCODE_ENDFLOW: equ 72 
22b6				OPCODE_WAITK: equ 73 
22b6				OPCODE_ACCEPT: equ 74 
22b6				OPCODE_EDIT: equ 75 
22b6			;free to reuse	OPCODE_ENDKEY: equ 76 
22b6				OPCODE_LZERO: equ 77 
22b6				OPCODE_TZERO: equ 78 
22b6				OPCODE_LESS: equ 79 
22b6				OPCODE_GT: equ 80 
22b6				OPCODE_EQUAL: equ 81  
22b6			;free to reuse	OPCODE_ENDLOGIC: equ 82 
22b6				OPCODE_NEG: equ 83 
22b6				OPCODE_DIV: equ 84 
22b6				OPCODE_MUL: equ 85 
22b6				OPCODE_MIN: equ 86 
22b6				OPCODE_MAX: equ 87 
22b6				OPCODE_RND16: equ 88 
22b6				OPCODE_RND8: equ 89 
22b6				OPCODE_RND: equ 90 
22b6			;free to reuse	OPCODE_ENDMATHS: equ 91  
22b6				OPCODE_BYNAME: equ 92 
22b6				OPCODE_DIR: equ 93 
22b6				OPCODE_SAVE: equ 94 
22b6				OPCODE_LOAD: equ 95 
22b6				OPCODE_BSAVE: equ 96 
22b6				OPCODE_BLOAD: equ 97 
22b6				OPCODE_SEO: equ 98  
22b6				OPCODE_SEI: equ 99 
22b6				OPCODE_SFREE: equ 100 
22b6				OPCODE_SIZE: equ 101 
22b6				OPCODE_CREATE: equ 102 
22b6				OPCODE_APPEND: equ 103 
22b6				OPCODE_SDEL: equ 104 
22b6				OPCODE_OPEN: equ 105 
22b6				OPCODE_READ: equ 106 
22b6				OPCODE_EOF: equ 106 
22b6				OPCODE_FORMAT: equ 107 
22b6				OPCODE_LABEL: equ 108 
22b6				OPCODE_LABELS: equ 109 
22b6			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
22b6				OPCODE_UPPER: equ 111 
22b6				OPCODE_LOWER: equ 112 
22b6				OPCODE_SUBSTR: equ 113 
22b6				OPCODE_LEFT: equ 114 
22b6				OPCODE_RIGHT: equ 115 
22b6				OPCODE_STR2NUM: equ 116 
22b6				OPCODE_NUM2STR: equ 117 
22b6				OPCODE_CONCAT: equ 118 
22b6				OPCODE_FIND: equ 119 
22b6				OPCODE_LEN: equ 120 
22b6				OPCODE_CHAR: equ 121 
22b6			; free to reuse	OPCODE_STRLEN: equ 122 
22b6			; free to reuse	OPCODE_ENDSTR: equ 123 
22b6				OPCODE_V0S: equ 124 
22b6				OPCODE_V0Q: equ 125 
22b6				OPCODE_V1S: equ 126 
22b6				OPCODE_V1Q: equ 127 
22b6				OPCODE_V2S: equ 128 
22b6				OPCODE_V2Q: equ 129 
22b6				OPCODE_V3S: equ 130 
22b6				OPCODE_V3Q: equ 131 
22b6			;free to reuse	OPCODE_END: equ 132 
22b6				OPCODE_ZDUP: equ 133 
22b6			 
22b6			; eof 
# End of file forth_opcodes.asm
22b6			 
22b6			include "forth_words_core.asm" 
22b6			 
22b6			; | ## Core Words 
22b6			 
22b6			;if MALLOC_4 
22b6			 
22b6			.HEAP: 
22b6			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
22b6 15				db WORD_SYS_CORE+OPCODE_HEAP             
22b7 f5 22			dw .EXEC            
22b9 05				db 4 + 1 
22ba .. 00			db "HEAP",0              
22bf				endm 
# End of macro CWHEAD
22bf			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
22bf			; | | u1 - Current number of bytes in the heap 
22bf			; | | u2 - Remaining bytes left on the heap 
22bf			; | |  
22bf			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
22bf			 
22bf			 
22bf				if DEBUG_FORTH_WORDS_KEY 
22bf					DMARK "HEP" 
22bf f5				push af  
22c0 3a d4 22			ld a, (.dmark)  
22c3 32 6b ee			ld (debug_mark),a  
22c6 3a d5 22			ld a, (.dmark+1)  
22c9 32 6c ee			ld (debug_mark+1),a  
22cc 3a d6 22			ld a, (.dmark+2)  
22cf 32 6d ee			ld (debug_mark+2),a  
22d2 18 03			jr .pastdmark  
22d4 ..			.dmark: db "HEP"  
22d7 f1			.pastdmark: pop af  
22d8			endm  
# End of macro DMARK
22d8					CALLMONITOR 
22d8 cd 6f ee			call debug_vector  
22db				endm  
# End of macro CALLMONITOR
22db				endif 
22db 2a b0 67			ld hl, (free_list )      
22de 11 b5 67			ld de, heap_start 
22e1			 
22e1 ed 52			sbc hl, de  
22e3			 
22e3 cd b1 1d			call forth_push_numhl 
22e6			 
22e6			 
22e6 ed 5b b0 67		ld de, (free_list )      
22ea 21 9c e2			ld hl, heap_end 
22ed			 
22ed ed 52			sbc hl, de 
22ef			 
22ef cd b1 1d			call forth_push_numhl 
22f2				 
22f2			 
22f2				 
22f2			 
22f2			 
22f2			 
22f2				NEXTW 
22f2 c3 5e 21			jp macro_next 
22f5				endm 
# End of macro NEXTW
22f5			;endif 
22f5			 
22f5			.EXEC: 
22f5			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
22f5			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
22f5			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
22f5			;; > > 
22f5			;; > >   
22f5			;	STACKFRAME OFF $5efe $5f9f 
22f5			; 
22f5			;		if DEBUG_FORTH_WORDS_KEY 
22f5			;			DMARK "EXE" 
22f5			;			CALLMONITOR 
22f5			;		endif 
22f5			; 
22f5			;	FORTH_DSP_VALUEHL 
22f5			; 
22f5			;	FORTH_DSP_POP 
22f5			; 
22f5			;		if DEBUG_FORTH_WORDS 
22f5			;			DMARK "EX1" 
22f5			;			CALLMONITOR 
22f5			;		endif 
22f5			;;	ld e,(hl) 
22f5			;;	inc hl 
22f5			;;	ld d,(hl) 
22f5			;;	ex de,hl 
22f5			; 
22f5			;;		if DEBUG_FORTH_WORDS 
22f5			;;			DMARK "EX2" 
22f5			;;			CALLMONITOR 
22f5			;;		endif 
22f5			;	push hl 
22f5			; 
22f5			;	;ld a, 0 
22f5			;	;ld a, FORTH_END_BUFFER 
22f5			;	call strlenz 
22f5			;	inc hl   ; include zero term to copy 
22f5			;	inc hl   ; include term 
22f5			;	inc hl   ; include term 
22f5			;	ld b,0 
22f5			;	ld c,l 
22f5			;	pop hl 
22f5			;	ld de, execscratch 
22f5			;		if DEBUG_FORTH_WORDS 
22f5			;			DMARK "EX3" 
22f5			;			CALLMONITOR 
22f5			;		endif 
22f5			;	ldir 
22f5			; 
22f5			; 
22f5			;	ld hl, execscratch 
22f5			; 
22f5			;		if DEBUG_FORTH_WORDS 
22f5			;			DMARK "EXe" 
22f5			;			CALLMONITOR 
22f5			;		endif 
22f5			; 
22f5			;	call forthparse 
22f5			;	call forthexec 
22f5			;;	call forthexec_cleanup 
22f5			;;	call forthparse 
22f5			;;	call forthexec 
22f5			; 
22f5			;	STACKFRAMECHK OFF $5efe $5f9f 
22f5			; 
22f5			;	; an immediate word so no need to process any more words 
22f5			;	ret 
22f5			;	NEXTW 
22f5			 
22f5			; dead code - old version  
22f5			;	FORTH_RSP_NEXT 
22f5			 
22f5			;  
22f5			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
22f5			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
22f5			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
22f5			;	push hl 
22f5			;	push de 
22f5			;	push bc 
22f5			; 
22f5			; 
22f5			;		if DEBUG_FORTH_WORDS_KEY 
22f5			;			DMARK "EXR" 
22f5			;			CALLMONITOR 
22f5			;		endif 
22f5			; 
22f5			; 
22f5			; 
22f5			;	;v5 FORTH_DSP_VALUE 
22f5			;	FORTH_DSP_VALUEHL 
22f5			; 
22f5			;	; TODO do string type checks 
22f5			; 
22f5			;;v5	inc hl   ; skip type 
22f5			; 
22f5			;	push hl  ; source code  
22f5			;		if DEBUG_FORTH_WORDS 
22f5			;			DMARK "EX1" 
22f5			;			CALLMONITOR 
22f5			;		endif 
22f5			;	ld a, 0 
22f5			;	call strlent 
22f5			; 
22f5			;	inc hl 
22f5			;	inc hl 
22f5			;	inc hl 
22f5			;	inc hl 
22f5			; 
22f5			;	push hl    ; size 
22f5			; 
22f5			;		if DEBUG_FORTH_WORDS 
22f5			;			DMARK "EX2" 
22f5			;			CALLMONITOR 
22f5			;		endif 
22f5			;	call malloc 
22f5			; 
22f5			;	ex de, hl    ; de now contains malloc area 
22f5			;	pop bc   	; get byte count 
22f5			;	pop hl      ; get string to copy 
22f5			; 
22f5			;	push de     ; save malloc for free later 
22f5			; 
22f5			;		if DEBUG_FORTH_WORDS 
22f5			;			DMARK "EX3" 
22f5			;			CALLMONITOR 
22f5			;		endif 
22f5			;	ldir       ; duplicate string 
22f5			; 
22f5			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
22f5			;	 
22f5			;	; TODO fix the parse would be better than this...  
22f5			;	ex de, hl 
22f5			;	dec hl 
22f5			;	ld a, 0 
22f5			;	ld (hl), a 
22f5			;	dec hl 
22f5			;	ld a, ' ' 
22f5			;	ld (hl), a 
22f5			;	dec hl 
22f5			;	ld (hl), a 
22f5			; 
22f5			;	dec hl 
22f5			;	ld (hl), a 
22f5			; 
22f5			; 
22f5			;	FORTH_DSP_POP  
22f5			; 
22f5			;	pop hl     
22f5			;	push hl    ; save malloc area 
22f5			; 
22f5			;		if DEBUG_FORTH_WORDS 
22f5			;			DMARK "EX4" 
22f5			;			CALLMONITOR 
22f5			;		endif 
22f5			; 
22f5			;	call forthparse 
22f5			;	call forthexec 
22f5			;	 
22f5			;	pop hl 
22f5			;	if DEBUG_FORTH_WORDS 
22f5			;		DMARK "EX5" 
22f5			;		CALLMONITOR 
22f5			;	endif 
22f5			; 
22f5			;	if FORTH_ENABLE_FREE 
22f5			;	call free 
22f5			;	endif 
22f5			; 
22f5			;	if DEBUG_FORTH_WORDS 
22f5			;		DMARK "EX6" 
22f5			;		CALLMONITOR 
22f5			;	endif 
22f5			; 
22f5			;	pop bc 
22f5			;	pop de 
22f5			;	pop hl 
22f5			;;	FORTH_RSP_POP	  
22f5			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
22f5			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
22f5			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
22f5			; 
22f5			;	if DEBUG_FORTH_WORDS 
22f5			;		DMARK "EX7" 
22f5			;		CALLMONITOR 
22f5			;	endif 
22f5			;	NEXTW 
22f5			 
22f5			;.STKEXEC: 
22f5			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
22f5			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
22f5			; 
22f5			; 
22f5			;		if DEBUG_FORTH_WORDS_KEY 
22f5			;			DMARK "STX" 
22f5			;			CALLMONITOR 
22f5			;		endif 
22f5			; 
22f5			;	FORTH_DSP_VALUEHL 
22f5			; 
22f5			;	ld (store_tmp1), hl    ; count 
22f5			; 
22f5			;	FORTH_DSP_POP 
22f5			;.stkexec1: 
22f5			;	ld hl, (store_tmp1)   ; count 
22f5			;	ld a, 0 
22f5			;	cp l 
22f5			;	ret z 
22f5			; 
22f5			;	dec hl 
22f5			;	ld (store_tmp1), hl    ; count 
22f5			;	 
22f5			;	FORTH_DSP_VALUEHL 
22f5			;	push hl 
22f5			;	 
22f5			;		if DEBUG_FORTH_WORDS 
22f5			;			DMARK "EXp" 
22f5			;			CALLMONITOR 
22f5			;		endif 
22f5			;	FORTH_DSP_POP 
22f5			; 
22f5			;	call strlenz 
22f5			;	inc hl   ; include zero term to copy 
22f5			;	inc hl   ; include zero term to copy 
22f5			;	inc hl   ; include zero term to copy 
22f5			;	ld b,0 
22f5			;	ld c,l 
22f5			;	pop hl 
22f5			;	ld de, execscratch 
22f5			;		if DEBUG_FORTH_WORDS 
22f5			;			DMARK "EX3" 
22f5			;			CALLMONITOR 
22f5			;		endif 
22f5			;	ldir 
22f5			; 
22f5			; 
22f5			;	ld hl, execscratch 
22f5			; 
22f5			;		if DEBUG_FORTH_WORDS 
22f5			;			DMARK "EXP" 
22f5			;			CALLMONITOR 
22f5			;		endif 
22f5			; 
22f5			;	call forthparse 
22f5			;	ld hl, execscratch 
22f5			;		if DEBUG_FORTH_WORDS 
22f5			;			DMARK "EXx" 
22f5			;			CALLMONITOR 
22f5			;		endif 
22f5			;	call forthexec 
22f5			; 
22f5			;	jp .stkexec1 
22f5			; 
22f5			;	ret 
22f5			 
22f5			 
22f5			.DUP: 
22f5			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
22f5 17				db WORD_SYS_CORE+OPCODE_DUP             
22f6 6b 23			dw .ZDUP            
22f8 04				db 3 + 1 
22f9 .. 00			db "DUP",0              
22fd				endm 
# End of macro CWHEAD
22fd			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
22fd			 
22fd				if DEBUG_FORTH_WORDS_KEY 
22fd					DMARK "DUP" 
22fd f5				push af  
22fe 3a 12 23			ld a, (.dmark)  
2301 32 6b ee			ld (debug_mark),a  
2304 3a 13 23			ld a, (.dmark+1)  
2307 32 6c ee			ld (debug_mark+1),a  
230a 3a 14 23			ld a, (.dmark+2)  
230d 32 6d ee			ld (debug_mark+2),a  
2310 18 03			jr .pastdmark  
2312 ..			.dmark: db "DUP"  
2315 f1			.pastdmark: pop af  
2316			endm  
# End of macro DMARK
2316					CALLMONITOR 
2316 cd 6f ee			call debug_vector  
2319				endm  
# End of macro CALLMONITOR
2319				endif 
2319			 
2319				FORTH_DSP 
2319 cd 6e 1f			call macro_forth_dsp 
231c				endm 
# End of macro FORTH_DSP
231c			 
231c 7e				ld a, (HL) 
231d fe 01			cp DS_TYPE_STR 
231f 20 25			jr nz, .dupinum 
2321			 
2321				; push another string 
2321			 
2321				FORTH_DSP_VALUEHL     		 
2321 cd a8 1f			call macro_dsp_valuehl 
2324				endm 
# End of macro FORTH_DSP_VALUEHL
2324			 
2324			if DEBUG_FORTH_WORDS 
2324				DMARK "DUs" 
2324 f5				push af  
2325 3a 39 23			ld a, (.dmark)  
2328 32 6b ee			ld (debug_mark),a  
232b 3a 3a 23			ld a, (.dmark+1)  
232e 32 6c ee			ld (debug_mark+1),a  
2331 3a 3b 23			ld a, (.dmark+2)  
2334 32 6d ee			ld (debug_mark+2),a  
2337 18 03			jr .pastdmark  
2339 ..			.dmark: db "DUs"  
233c f1			.pastdmark: pop af  
233d			endm  
# End of macro DMARK
233d				CALLMONITOR 
233d cd 6f ee			call debug_vector  
2340				endm  
# End of macro CALLMONITOR
2340			endif 
2340 cd 1f 1e			call forth_push_str 
2343			 
2343				NEXTW 
2343 c3 5e 21			jp macro_next 
2346				endm 
# End of macro NEXTW
2346			 
2346			 
2346			.dupinum: 
2346				 
2346			 
2346			 
2346				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2346 cd a8 1f			call macro_dsp_valuehl 
2349				endm 
# End of macro FORTH_DSP_VALUEHL
2349			 
2349			; TODO add floating point number detection 
2349			 
2349			if DEBUG_FORTH_WORDS 
2349				DMARK "DUi" 
2349 f5				push af  
234a 3a 5e 23			ld a, (.dmark)  
234d 32 6b ee			ld (debug_mark),a  
2350 3a 5f 23			ld a, (.dmark+1)  
2353 32 6c ee			ld (debug_mark+1),a  
2356 3a 60 23			ld a, (.dmark+2)  
2359 32 6d ee			ld (debug_mark+2),a  
235c 18 03			jr .pastdmark  
235e ..			.dmark: db "DUi"  
2361 f1			.pastdmark: pop af  
2362			endm  
# End of macro DMARK
2362				CALLMONITOR 
2362 cd 6f ee			call debug_vector  
2365				endm  
# End of macro CALLMONITOR
2365			endif 
2365			 
2365 cd b1 1d			call forth_push_numhl 
2368				NEXTW 
2368 c3 5e 21			jp macro_next 
236b				endm 
# End of macro NEXTW
236b			.ZDUP: 
236b			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
236b 99				db WORD_SYS_CORE+OPCODE_ZDUP             
236c a3 23			dw .SWAP            
236e 05				db 4 + 1 
236f .. 00			db "?DUP",0              
2374				endm 
# End of macro CWHEAD
2374			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2374			 
2374				if DEBUG_FORTH_WORDS_KEY 
2374					DMARK "qDU" 
2374 f5				push af  
2375 3a 89 23			ld a, (.dmark)  
2378 32 6b ee			ld (debug_mark),a  
237b 3a 8a 23			ld a, (.dmark+1)  
237e 32 6c ee			ld (debug_mark+1),a  
2381 3a 8b 23			ld a, (.dmark+2)  
2384 32 6d ee			ld (debug_mark+2),a  
2387 18 03			jr .pastdmark  
2389 ..			.dmark: db "qDU"  
238c f1			.pastdmark: pop af  
238d			endm  
# End of macro DMARK
238d					CALLMONITOR 
238d cd 6f ee			call debug_vector  
2390				endm  
# End of macro CALLMONITOR
2390				endif 
2390				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2390 cd a8 1f			call macro_dsp_valuehl 
2393				endm 
# End of macro FORTH_DSP_VALUEHL
2393			 
2393 e5				push hl 
2394			 
2394				; is it a zero? 
2394			 
2394 3e 00			ld a, 0 
2396 84				add h 
2397 85				add l 
2398			 
2398 e1				pop hl 
2399			 
2399 fe 00			cp 0 
239b 28 03			jr z, .dup2orig 
239d			 
239d			 
239d cd b1 1d			call forth_push_numhl 
23a0			 
23a0			 
23a0			; TODO add floating point number detection 
23a0			 
23a0			.dup2orig: 
23a0			 
23a0				NEXTW 
23a0 c3 5e 21			jp macro_next 
23a3				endm 
# End of macro NEXTW
23a3			.SWAP: 
23a3			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
23a3 18				db WORD_SYS_CORE+OPCODE_SWAP             
23a4 e2 23			dw .COLN            
23a6 05				db 4 + 1 
23a7 .. 00			db "SWAP",0              
23ac				endm 
# End of macro CWHEAD
23ac			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
23ac				if DEBUG_FORTH_WORDS_KEY 
23ac					DMARK "SWP" 
23ac f5				push af  
23ad 3a c1 23			ld a, (.dmark)  
23b0 32 6b ee			ld (debug_mark),a  
23b3 3a c2 23			ld a, (.dmark+1)  
23b6 32 6c ee			ld (debug_mark+1),a  
23b9 3a c3 23			ld a, (.dmark+2)  
23bc 32 6d ee			ld (debug_mark+2),a  
23bf 18 03			jr .pastdmark  
23c1 ..			.dmark: db "SWP"  
23c4 f1			.pastdmark: pop af  
23c5			endm  
# End of macro DMARK
23c5					CALLMONITOR 
23c5 cd 6f ee			call debug_vector  
23c8				endm  
# End of macro CALLMONITOR
23c8				endif 
23c8			 
23c8			; TODO Use os stack swap memory 
23c8				FORTH_DSP_VALUEHL 
23c8 cd a8 1f			call macro_dsp_valuehl 
23cb				endm 
# End of macro FORTH_DSP_VALUEHL
23cb e5				push hl     ; w2 
23cc			 
23cc				FORTH_DSP_POP 
23cc cd 60 20			call macro_forth_dsp_pop 
23cf				endm 
# End of macro FORTH_DSP_POP
23cf			 
23cf				FORTH_DSP_VALUEHL 
23cf cd a8 1f			call macro_dsp_valuehl 
23d2				endm 
# End of macro FORTH_DSP_VALUEHL
23d2			 
23d2				FORTH_DSP_POP 
23d2 cd 60 20			call macro_forth_dsp_pop 
23d5				endm 
# End of macro FORTH_DSP_POP
23d5			 
23d5 d1				pop de     ; w2	, hl = w1 
23d6			 
23d6 eb				ex de, hl 
23d7 d5				push de 
23d8			 
23d8 cd b1 1d			call forth_push_numhl 
23db			 
23db e1				pop hl 
23dc			 
23dc cd b1 1d			call forth_push_numhl 
23df				 
23df			 
23df				NEXTW 
23df c3 5e 21			jp macro_next 
23e2				endm 
# End of macro NEXTW
23e2			.COLN: 
23e2			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
23e2 19				db WORD_SYS_CORE+OPCODE_COLN             
23e3 6e 25			dw .SCOLN            
23e5 02				db 1 + 1 
23e6 .. 00			db ":",0              
23e8				endm 
# End of macro CWHEAD
23e8			; | : ( -- )         Create new word | DONE 
23e8			 
23e8				if DEBUG_FORTH_WORDS_KEY 
23e8					DMARK "CLN" 
23e8 f5				push af  
23e9 3a fd 23			ld a, (.dmark)  
23ec 32 6b ee			ld (debug_mark),a  
23ef 3a fe 23			ld a, (.dmark+1)  
23f2 32 6c ee			ld (debug_mark+1),a  
23f5 3a ff 23			ld a, (.dmark+2)  
23f8 32 6d ee			ld (debug_mark+2),a  
23fb 18 03			jr .pastdmark  
23fd ..			.dmark: db "CLN"  
2400 f1			.pastdmark: pop af  
2401			endm  
# End of macro DMARK
2401					CALLMONITOR 
2401 cd 6f ee			call debug_vector  
2404				endm  
# End of macro CALLMONITOR
2404				endif 
2404			STACKFRAME OFF $8efe $989f 
2404				if DEBUG_STACK_IMB 
2404					if OFF 
2404						exx 
2404						ld de, $8efe 
2404						ld a, d 
2404						ld hl, curframe 
2404						call hexout 
2404						ld a, e 
2404						ld hl, curframe+2 
2404						call hexout 
2404						ld hl, $8efe 
2404						push hl 
2404						ld hl, $989f 
2404						push hl 
2404						exx 
2404					endif 
2404				endif 
2404			endm 
# End of macro STACKFRAME
2404			; get parser buffer length  of new word 
2404			 
2404			 
2404			 
2404				; move tok past this to start of name defintition 
2404				; TODO get word to define 
2404				; TODO Move past word token 
2404				; TODO get length of string up to the ';' 
2404			 
2404 2a c2 e5		ld hl, (os_tok_ptr) 
2407 23			inc hl 
2408 23			inc hl 
2409			 
2409 3e 3b		ld a, ';' 
240b cd ae 13		call strlent 
240e			 
240e 7d			ld a,l 
240f 32 b1 e2		ld (os_new_parse_len), a 
2412			 
2412			 
2412			if DEBUG_FORTH_UWORD 
2412 ed 5b c2 e5	ld de, (os_tok_ptr) 
2416					DMARK ":01" 
2416 f5				push af  
2417 3a 2b 24			ld a, (.dmark)  
241a 32 6b ee			ld (debug_mark),a  
241d 3a 2c 24			ld a, (.dmark+1)  
2420 32 6c ee			ld (debug_mark+1),a  
2423 3a 2d 24			ld a, (.dmark+2)  
2426 32 6d ee			ld (debug_mark+2),a  
2429 18 03			jr .pastdmark  
242b ..			.dmark: db ":01"  
242e f1			.pastdmark: pop af  
242f			endm  
# End of macro DMARK
242f			CALLMONITOR 
242f cd 6f ee			call debug_vector  
2432				endm  
# End of macro CALLMONITOR
2432			endif 
2432			 
2432			; 
2432			;  new word memory layout: 
2432			;  
2432			;    : adg 6666 ;  
2432			; 
2432			;    db   1     ; user defined word  
2432 23			inc hl    
2433			;    dw   sysdict 
2433 23			inc hl 
2434 23			inc hl 
2435			;    db <word len>+1 (for null) 
2435 23			inc hl 
2436			;    db .... <word> 
2436			; 
2436			 
2436 23			inc hl    ; some extras for the word preamble before the above 
2437 23			inc hl 
2438 23			inc hl 
2439 23			inc hl 
243a 23			inc hl 
243b 23			inc hl 
243c 23			inc hl  
243d 23			inc hl 
243e 23			inc hl 
243f 23			inc hl 
2440 23			inc hl 
2441 23			inc hl 
2442 23			inc hl 
2443 23			inc hl     ; TODO how many do we really need?     maybe only 6 
2444			;       exec word buffer 
2444			;	<ptr word>   
2444 23			inc hl 
2445 23			inc hl 
2446			;       <word list><null term> 7F final term 
2446			 
2446			 
2446			if DEBUG_FORTH_UWORD 
2446					DMARK ":02" 
2446 f5				push af  
2447 3a 5b 24			ld a, (.dmark)  
244a 32 6b ee			ld (debug_mark),a  
244d 3a 5c 24			ld a, (.dmark+1)  
2450 32 6c ee			ld (debug_mark+1),a  
2453 3a 5d 24			ld a, (.dmark+2)  
2456 32 6d ee			ld (debug_mark+2),a  
2459 18 03			jr .pastdmark  
245b ..			.dmark: db ":02"  
245e f1			.pastdmark: pop af  
245f			endm  
# End of macro DMARK
245f			CALLMONITOR 
245f cd 6f ee			call debug_vector  
2462				endm  
# End of macro CALLMONITOR
2462			endif 
2462			 
2462			 
2462				; malloc the size 
2462			 
2462 cd 18 14			call malloc 
2465 22 b3 e2			ld (os_new_malloc), hl     ; save malloc start 
2468			 
2468			;    db   1     ; user defined word  
2468 3e 01			ld a, WORD_SYS_UWORD  
246a 77				ld (hl), a 
246b			 
246b 23			inc hl    
246c			;    dw   sysdict 
246c 11 b6 22		ld de, sysdict       ; continue on with the scan to the system dict 
246f 73			ld (hl), e 
2470 23			inc hl 
2471 72			ld (hl), d 
2472 23			inc hl 
2473			 
2473			 
2473			;    Setup dict word 
2473			 
2473 23			inc hl 
2474 22 ad e2		ld (os_new_work_ptr), hl     ; save start of dict word  
2477			 
2477			; 1. get length of dict word 
2477			 
2477			 
2477 2a c2 e5		ld hl, (os_tok_ptr) 
247a 23			inc hl 
247b 23			inc hl    ; position to start of dict word 
247c 3e 00		ld a, 0 
247e cd ae 13		call strlent 
2481			 
2481			 
2481 23			inc hl    ; to include null??? 
2482			 
2482			; write length of dict word 
2482			 
2482 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2486 1b			dec de 
2487 eb			ex de, hl 
2488 73			ld (hl), e 
2489 eb			ex de, hl 
248a			 
248a			 
248a			 
248a			; copy  
248a 4d			ld c, l 
248b 06 00		ld b, 0 
248d ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2491 2a c2 e5		ld hl, (os_tok_ptr) 
2494 23			inc hl 
2495 23			inc hl    ; position to start of dict word 
2496			 
2496			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2496			 
2496			; TODO need to convert word to upper case 
2496			 
2496			ucasetok:	 
2496 7e			ld a,(hl) 
2497 cd 9a 13		call toUpper 
249a 77			ld (hl),a 
249b ed a0		ldi 
249d f2 96 24		jp p, ucasetok 
24a0			 
24a0			 
24a0			 
24a0			; de now points to start of where the word body code should be placed 
24a0 ed 53 ad e2	ld (os_new_work_ptr), de 
24a4			; hl now points to the words to throw at forthexec which needs to be copied 
24a4 22 ab e2		ld (os_new_src_ptr), hl 
24a7			 
24a7			; TODO add 'call to forthexec' 
24a7			 
24a7			if DEBUG_FORTH_UWORD 
24a7 c5			push bc 
24a8 ed 4b b3 e2	ld bc, (os_new_malloc) 
24ac					DMARK ":0x" 
24ac f5				push af  
24ad 3a c1 24			ld a, (.dmark)  
24b0 32 6b ee			ld (debug_mark),a  
24b3 3a c2 24			ld a, (.dmark+1)  
24b6 32 6c ee			ld (debug_mark+1),a  
24b9 3a c3 24			ld a, (.dmark+2)  
24bc 32 6d ee			ld (debug_mark+2),a  
24bf 18 03			jr .pastdmark  
24c1 ..			.dmark: db ":0x"  
24c4 f1			.pastdmark: pop af  
24c5			endm  
# End of macro DMARK
24c5			CALLMONITOR 
24c5 cd 6f ee			call debug_vector  
24c8				endm  
# End of macro CALLMONITOR
24c8 c1			pop bc 
24c9			endif 
24c9			 
24c9			 
24c9			; create word preamble which should be: 
24c9			 
24c9			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
24c9			 
24c9			;    ld hl, <word code> 
24c9			;    jp user_exec 
24c9			;    <word code bytes> 
24c9			 
24c9			 
24c9			;	inc de     ; TODO ??? or are we already past the word's null 
24c9 eb			ex de, hl 
24ca			 
24ca 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
24cc			 
24cc 23			inc hl 
24cd 22 a7 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
24d0 23			inc hl 
24d1			 
24d1 23			inc hl 
24d2 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
24d4			 
24d4 01 4c 4e		ld bc, user_exec 
24d7 23			inc hl 
24d8 71			ld (hl), c     ; poke address of user_exec 
24d9 23			inc hl 
24da 70			ld (hl), b     
24db			; 
24db			;	inc hl 
24db			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
24db			; 
24db			; 
24db			;	ld bc, macro_forth_rsp_next 
24db			;	inc hl 
24db			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
24db			;	inc hl 
24db			;	ld (hl), b     
24db			; 
24db			;	inc hl 
24db			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
24db			; 
24db			; 
24db			;	inc hl 
24db			;	ld bc, forthexec 
24db			;	ld (hl), c     ; poke address of forthexec 
24db			;	inc hl 
24db			;	ld (hl), b      
24db			; 
24db			;	inc hl 
24db			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
24db			; 
24db			;	ld bc, user_dict_next 
24db			;	inc hl 
24db			;	ld (hl), c     ; poke address of forthexec 
24db			;	inc hl 
24db			;	ld (hl), b      
24db			 
24db			; hl is now where we need to copy the word byte data to save this 
24db			 
24db 23			inc hl 
24dc 22 a9 e2		ld (os_new_exec), hl 
24df			 
24df			; copy definition 
24df			 
24df eb			ex de, hl 
24e0			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
24e0			;	inc de    ; skip the PC for this parse 
24e0 3a b1 e2		ld a, (os_new_parse_len) 
24e3 4f			ld c, a 
24e4 06 00		ld b, 0 
24e6 ed b0		ldir		 ; copy defintion 
24e8			 
24e8			 
24e8			; poke the address of where the new word bytes live for forthexec 
24e8			 
24e8 2a a7 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
24eb			 
24eb ed 5b a9 e2	ld de, (os_new_exec)      
24ef			 
24ef 73			ld (hl), e 
24f0 23			inc hl 
24f1 72			ld (hl), d 
24f2			 
24f2				; TODO copy last user dict word next link to this word 
24f2				; TODO update last user dict word to point to this word 
24f2			; 
24f2			; hl f923 de 812a ; bc 811a 
24f2			 
24f2			if DEBUG_FORTH_UWORD 
24f2 c5			push bc 
24f3 ed 4b b3 e2	ld bc, (os_new_malloc) 
24f7					DMARK ":0A" 
24f7 f5				push af  
24f8 3a 0c 25			ld a, (.dmark)  
24fb 32 6b ee			ld (debug_mark),a  
24fe 3a 0d 25			ld a, (.dmark+1)  
2501 32 6c ee			ld (debug_mark+1),a  
2504 3a 0e 25			ld a, (.dmark+2)  
2507 32 6d ee			ld (debug_mark+2),a  
250a 18 03			jr .pastdmark  
250c ..			.dmark: db ":0A"  
250f f1			.pastdmark: pop af  
2510			endm  
# End of macro DMARK
2510			CALLMONITOR 
2510 cd 6f ee			call debug_vector  
2513				endm  
# End of macro CALLMONITOR
2513 c1			pop bc 
2514			endif 
2514			if DEBUG_FORTH_UWORD 
2514 c5			push bc 
2515 ed 4b b3 e2	ld bc, (os_new_malloc) 
2519 03			inc bc 
251a 03			inc bc 
251b 03			inc bc 
251c 03			inc bc 
251d 03			inc bc 
251e 03			inc bc 
251f 03			inc bc 
2520 03			inc bc 
2521			 
2521					DMARK ":0B" 
2521 f5				push af  
2522 3a 36 25			ld a, (.dmark)  
2525 32 6b ee			ld (debug_mark),a  
2528 3a 37 25			ld a, (.dmark+1)  
252b 32 6c ee			ld (debug_mark+1),a  
252e 3a 38 25			ld a, (.dmark+2)  
2531 32 6d ee			ld (debug_mark+2),a  
2534 18 03			jr .pastdmark  
2536 ..			.dmark: db ":0B"  
2539 f1			.pastdmark: pop af  
253a			endm  
# End of macro DMARK
253a			CALLMONITOR 
253a cd 6f ee			call debug_vector  
253d				endm  
# End of macro CALLMONITOR
253d c1			pop bc 
253e			endif 
253e			 
253e			; update word dict linked list for new word 
253e			 
253e			 
253e 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2541 23			inc hl     ; move to next work linked list ptr 
2542			 
2542 ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
2546 73			ld (hl), e 
2547 23			inc hl 
2548 72			ld (hl), d 
2549			 
2549			if DEBUG_FORTH_UWORD 
2549 ed 4b be e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
254d			endif 
254d			 
254d ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
2551			 
2551			 
2551			if DEBUG_FORTH_UWORD 
2551					DMARK ":0+" 
2551 f5				push af  
2552 3a 66 25			ld a, (.dmark)  
2555 32 6b ee			ld (debug_mark),a  
2558 3a 67 25			ld a, (.dmark+1)  
255b 32 6c ee			ld (debug_mark+1),a  
255e 3a 68 25			ld a, (.dmark+2)  
2561 32 6d ee			ld (debug_mark+2),a  
2564 18 03			jr .pastdmark  
2566 ..			.dmark: db ":0+"  
2569 f1			.pastdmark: pop af  
256a			endm  
# End of macro DMARK
256a			CALLMONITOR 
256a cd 6f ee			call debug_vector  
256d				endm  
# End of macro CALLMONITOR
256d			endif 
256d			 
256d			STACKFRAMECHK OFF $8efe $989f 
256d				if DEBUG_STACK_IMB 
256d					if OFF 
256d						exx 
256d						ld hl, $989f 
256d						pop de   ; $989f 
256d						call cmp16 
256d						jr nz, .spnosame 
256d						ld hl, $8efe 
256d						pop de   ; $8efe 
256d						call cmp16 
256d						jr z, .spfrsame 
256d						.spnosame: call showsperror 
256d						.spfrsame: nop 
256d						exx 
256d					endif 
256d				endif 
256d			endm 
# End of macro STACKFRAMECHK
256d			 
256d c9			ret    ; dont process any remaining parser tokens as they form new word 
256e			 
256e			 
256e			 
256e			 
256e			;		NEXT 
256e			.SCOLN: 
256e			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
256e 06			db OPCODE_SCOLN 
256f ba 25		dw .DROP 
2571 02			db 2 
2572 .. 00		db ";",0           
2574			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2574				if DEBUG_FORTH_WORDS_KEY 
2574					DMARK "SCN" 
2574 f5				push af  
2575 3a 89 25			ld a, (.dmark)  
2578 32 6b ee			ld (debug_mark),a  
257b 3a 8a 25			ld a, (.dmark+1)  
257e 32 6c ee			ld (debug_mark+1),a  
2581 3a 8b 25			ld a, (.dmark+2)  
2584 32 6d ee			ld (debug_mark+2),a  
2587 18 03			jr .pastdmark  
2589 ..			.dmark: db "SCN"  
258c f1			.pastdmark: pop af  
258d			endm  
# End of macro DMARK
258d					CALLMONITOR 
258d cd 6f ee			call debug_vector  
2590				endm  
# End of macro CALLMONITOR
2590				endif 
2590				FORTH_RSP_TOS 
2590 cd 6f 1d			call macro_forth_rsp_tos 
2593				endm 
# End of macro FORTH_RSP_TOS
2593 e5				push hl 
2594				FORTH_RSP_POP 
2594 cd 79 1d			call macro_forth_rsp_pop 
2597				endm 
# End of macro FORTH_RSP_POP
2597 e1				pop hl 
2598			;		ex de,hl 
2598 22 c2 e5			ld (os_tok_ptr),hl 
259b			 
259b			if DEBUG_FORTH_UWORD 
259b					DMARK "SCL" 
259b f5				push af  
259c 3a b0 25			ld a, (.dmark)  
259f 32 6b ee			ld (debug_mark),a  
25a2 3a b1 25			ld a, (.dmark+1)  
25a5 32 6c ee			ld (debug_mark+1),a  
25a8 3a b2 25			ld a, (.dmark+2)  
25ab 32 6d ee			ld (debug_mark+2),a  
25ae 18 03			jr .pastdmark  
25b0 ..			.dmark: db "SCL"  
25b3 f1			.pastdmark: pop af  
25b4			endm  
# End of macro DMARK
25b4			CALLMONITOR 
25b4 cd 6f ee			call debug_vector  
25b7				endm  
# End of macro CALLMONITOR
25b7			endif 
25b7				NEXTW 
25b7 c3 5e 21			jp macro_next 
25ba				endm 
# End of macro NEXTW
25ba			 
25ba			.DROP: 
25ba			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
25ba 1b				db WORD_SYS_CORE+OPCODE_DROP             
25bb e5 25			dw .DUP2            
25bd 05				db 4 + 1 
25be .. 00			db "DROP",0              
25c3				endm 
# End of macro CWHEAD
25c3			; | DROP ( w -- )   drop the TOS item   | DONE 
25c3				if DEBUG_FORTH_WORDS_KEY 
25c3					DMARK "DRP" 
25c3 f5				push af  
25c4 3a d8 25			ld a, (.dmark)  
25c7 32 6b ee			ld (debug_mark),a  
25ca 3a d9 25			ld a, (.dmark+1)  
25cd 32 6c ee			ld (debug_mark+1),a  
25d0 3a da 25			ld a, (.dmark+2)  
25d3 32 6d ee			ld (debug_mark+2),a  
25d6 18 03			jr .pastdmark  
25d8 ..			.dmark: db "DRP"  
25db f1			.pastdmark: pop af  
25dc			endm  
# End of macro DMARK
25dc					CALLMONITOR 
25dc cd 6f ee			call debug_vector  
25df				endm  
# End of macro CALLMONITOR
25df				endif 
25df				FORTH_DSP_POP 
25df cd 60 20			call macro_forth_dsp_pop 
25e2				endm 
# End of macro FORTH_DSP_POP
25e2				NEXTW 
25e2 c3 5e 21			jp macro_next 
25e5				endm 
# End of macro NEXTW
25e5			.DUP2: 
25e5			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
25e5 1c				db WORD_SYS_CORE+OPCODE_DUP2             
25e6 2a 26			dw .DROP2            
25e8 05				db 4 + 1 
25e9 .. 00			db "2DUP",0              
25ee				endm 
# End of macro CWHEAD
25ee			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
25ee				if DEBUG_FORTH_WORDS_KEY 
25ee					DMARK "2DU" 
25ee f5				push af  
25ef 3a 03 26			ld a, (.dmark)  
25f2 32 6b ee			ld (debug_mark),a  
25f5 3a 04 26			ld a, (.dmark+1)  
25f8 32 6c ee			ld (debug_mark+1),a  
25fb 3a 05 26			ld a, (.dmark+2)  
25fe 32 6d ee			ld (debug_mark+2),a  
2601 18 03			jr .pastdmark  
2603 ..			.dmark: db "2DU"  
2606 f1			.pastdmark: pop af  
2607			endm  
# End of macro DMARK
2607					CALLMONITOR 
2607 cd 6f ee			call debug_vector  
260a				endm  
# End of macro CALLMONITOR
260a				endif 
260a				FORTH_DSP_VALUEHL 
260a cd a8 1f			call macro_dsp_valuehl 
260d				endm 
# End of macro FORTH_DSP_VALUEHL
260d e5				push hl      ; 2 
260e			 
260e				FORTH_DSP_POP 
260e cd 60 20			call macro_forth_dsp_pop 
2611				endm 
# End of macro FORTH_DSP_POP
2611				 
2611				FORTH_DSP_VALUEHL 
2611 cd a8 1f			call macro_dsp_valuehl 
2614				endm 
# End of macro FORTH_DSP_VALUEHL
2614			;		push hl      ; 1 
2614			 
2614				FORTH_DSP_POP 
2614 cd 60 20			call macro_forth_dsp_pop 
2617				endm 
# End of macro FORTH_DSP_POP
2617			 
2617			;		pop hl       ; 1 
2617 d1				pop de       ; 2 
2618			 
2618 cd b1 1d			call forth_push_numhl 
261b eb				ex de, hl 
261c cd b1 1d			call forth_push_numhl 
261f			 
261f				 
261f eb				ex de, hl 
2620			 
2620 cd b1 1d			call forth_push_numhl 
2623 eb				ex de, hl 
2624 cd b1 1d			call forth_push_numhl 
2627			 
2627			 
2627				NEXTW 
2627 c3 5e 21			jp macro_next 
262a				endm 
# End of macro NEXTW
262a			.DROP2: 
262a			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
262a 1d				db WORD_SYS_CORE+OPCODE_DROP2             
262b 59 26			dw .SWAP2            
262d 06				db 5 + 1 
262e .. 00			db "2DROP",0              
2634				endm 
# End of macro CWHEAD
2634			; | 2DROP ( w w -- )    Double drop | DONE 
2634				if DEBUG_FORTH_WORDS_KEY 
2634					DMARK "2DR" 
2634 f5				push af  
2635 3a 49 26			ld a, (.dmark)  
2638 32 6b ee			ld (debug_mark),a  
263b 3a 4a 26			ld a, (.dmark+1)  
263e 32 6c ee			ld (debug_mark+1),a  
2641 3a 4b 26			ld a, (.dmark+2)  
2644 32 6d ee			ld (debug_mark+2),a  
2647 18 03			jr .pastdmark  
2649 ..			.dmark: db "2DR"  
264c f1			.pastdmark: pop af  
264d			endm  
# End of macro DMARK
264d					CALLMONITOR 
264d cd 6f ee			call debug_vector  
2650				endm  
# End of macro CALLMONITOR
2650				endif 
2650				FORTH_DSP_POP 
2650 cd 60 20			call macro_forth_dsp_pop 
2653				endm 
# End of macro FORTH_DSP_POP
2653				FORTH_DSP_POP 
2653 cd 60 20			call macro_forth_dsp_pop 
2656				endm 
# End of macro FORTH_DSP_POP
2656				NEXTW 
2656 c3 5e 21			jp macro_next 
2659				endm 
# End of macro NEXTW
2659			.SWAP2: 
2659			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2659 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
265a 82 26			dw .AT            
265c 06				db 5 + 1 
265d .. 00			db "2SWAP",0              
2663				endm 
# End of macro CWHEAD
2663			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2663				if DEBUG_FORTH_WORDS_KEY 
2663					DMARK "2SW" 
2663 f5				push af  
2664 3a 78 26			ld a, (.dmark)  
2667 32 6b ee			ld (debug_mark),a  
266a 3a 79 26			ld a, (.dmark+1)  
266d 32 6c ee			ld (debug_mark+1),a  
2670 3a 7a 26			ld a, (.dmark+2)  
2673 32 6d ee			ld (debug_mark+2),a  
2676 18 03			jr .pastdmark  
2678 ..			.dmark: db "2SW"  
267b f1			.pastdmark: pop af  
267c			endm  
# End of macro DMARK
267c					CALLMONITOR 
267c cd 6f ee			call debug_vector  
267f				endm  
# End of macro CALLMONITOR
267f				endif 
267f			; TODO Use os stack swap memory 
267f				NEXTW 
267f c3 5e 21			jp macro_next 
2682				endm 
# End of macro NEXTW
2682			.AT: 
2682			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2682 1f				db WORD_SYS_CORE+OPCODE_AT             
2683 b4 26			dw .CAT            
2685 02				db 1 + 1 
2686 .. 00			db "@",0              
2688				endm 
# End of macro CWHEAD
2688			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2688			 
2688				if DEBUG_FORTH_WORDS_KEY 
2688					DMARK "AT." 
2688 f5				push af  
2689 3a 9d 26			ld a, (.dmark)  
268c 32 6b ee			ld (debug_mark),a  
268f 3a 9e 26			ld a, (.dmark+1)  
2692 32 6c ee			ld (debug_mark+1),a  
2695 3a 9f 26			ld a, (.dmark+2)  
2698 32 6d ee			ld (debug_mark+2),a  
269b 18 03			jr .pastdmark  
269d ..			.dmark: db "AT."  
26a0 f1			.pastdmark: pop af  
26a1			endm  
# End of macro DMARK
26a1					CALLMONITOR 
26a1 cd 6f ee			call debug_vector  
26a4				endm  
# End of macro CALLMONITOR
26a4				endif 
26a4			.getbyteat:	 
26a4				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26a4 cd a8 1f			call macro_dsp_valuehl 
26a7				endm 
# End of macro FORTH_DSP_VALUEHL
26a7				 
26a7			;		push hl 
26a7			 
26a7				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26a7 cd 60 20			call macro_forth_dsp_pop 
26aa				endm 
# End of macro FORTH_DSP_POP
26aa			 
26aa			;		pop hl 
26aa			 
26aa 7e				ld a, (hl) 
26ab			 
26ab 6f				ld l, a 
26ac 26 00			ld h, 0 
26ae cd b1 1d			call forth_push_numhl 
26b1			 
26b1				NEXTW 
26b1 c3 5e 21			jp macro_next 
26b4				endm 
# End of macro NEXTW
26b4			.CAT: 
26b4			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
26b4 20				db WORD_SYS_CORE+OPCODE_CAT             
26b5 dd 26			dw .BANG            
26b7 03				db 2 + 1 
26b8 .. 00			db "C@",0              
26bb				endm 
# End of macro CWHEAD
26bb			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
26bb				if DEBUG_FORTH_WORDS_KEY 
26bb					DMARK "CAA" 
26bb f5				push af  
26bc 3a d0 26			ld a, (.dmark)  
26bf 32 6b ee			ld (debug_mark),a  
26c2 3a d1 26			ld a, (.dmark+1)  
26c5 32 6c ee			ld (debug_mark+1),a  
26c8 3a d2 26			ld a, (.dmark+2)  
26cb 32 6d ee			ld (debug_mark+2),a  
26ce 18 03			jr .pastdmark  
26d0 ..			.dmark: db "CAA"  
26d3 f1			.pastdmark: pop af  
26d4			endm  
# End of macro DMARK
26d4					CALLMONITOR 
26d4 cd 6f ee			call debug_vector  
26d7				endm  
# End of macro CALLMONITOR
26d7				endif 
26d7 c3 a4 26			jp .getbyteat 
26da				NEXTW 
26da c3 5e 21			jp macro_next 
26dd				endm 
# End of macro NEXTW
26dd			.BANG: 
26dd			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
26dd 21				db WORD_SYS_CORE+OPCODE_BANG             
26de 13 27			dw .CBANG            
26e0 02				db 1 + 1 
26e1 .. 00			db "!",0              
26e3				endm 
# End of macro CWHEAD
26e3			; | ! ( x w -- ) Store x at address w      | DONE 
26e3				if DEBUG_FORTH_WORDS_KEY 
26e3					DMARK "BNG" 
26e3 f5				push af  
26e4 3a f8 26			ld a, (.dmark)  
26e7 32 6b ee			ld (debug_mark),a  
26ea 3a f9 26			ld a, (.dmark+1)  
26ed 32 6c ee			ld (debug_mark+1),a  
26f0 3a fa 26			ld a, (.dmark+2)  
26f3 32 6d ee			ld (debug_mark+2),a  
26f6 18 03			jr .pastdmark  
26f8 ..			.dmark: db "BNG"  
26fb f1			.pastdmark: pop af  
26fc			endm  
# End of macro DMARK
26fc					CALLMONITOR 
26fc cd 6f ee			call debug_vector  
26ff				endm  
# End of macro CALLMONITOR
26ff				endif 
26ff			 
26ff			.storebyteat:		 
26ff				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26ff cd a8 1f			call macro_dsp_valuehl 
2702				endm 
# End of macro FORTH_DSP_VALUEHL
2702				 
2702 e5				push hl 
2703			 
2703				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2703 cd 60 20			call macro_forth_dsp_pop 
2706				endm 
# End of macro FORTH_DSP_POP
2706			 
2706				; get byte to poke 
2706			 
2706				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2706 cd a8 1f			call macro_dsp_valuehl 
2709				endm 
# End of macro FORTH_DSP_VALUEHL
2709 e5				push hl 
270a			 
270a			 
270a				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
270a cd 60 20			call macro_forth_dsp_pop 
270d				endm 
# End of macro FORTH_DSP_POP
270d			 
270d			 
270d d1				pop de 
270e e1				pop hl 
270f			 
270f 73				ld (hl),e 
2710			 
2710			 
2710				NEXTW 
2710 c3 5e 21			jp macro_next 
2713				endm 
# End of macro NEXTW
2713			.CBANG: 
2713			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2713 22				db WORD_SYS_CORE+OPCODE_CBANG             
2714 3c 27			dw .SCALL            
2716 03				db 2 + 1 
2717 .. 00			db "C!",0              
271a				endm 
# End of macro CWHEAD
271a			; | C!  ( x w -- ) Store x at address w  | DONE 
271a				if DEBUG_FORTH_WORDS_KEY 
271a					DMARK "CBA" 
271a f5				push af  
271b 3a 2f 27			ld a, (.dmark)  
271e 32 6b ee			ld (debug_mark),a  
2721 3a 30 27			ld a, (.dmark+1)  
2724 32 6c ee			ld (debug_mark+1),a  
2727 3a 31 27			ld a, (.dmark+2)  
272a 32 6d ee			ld (debug_mark+2),a  
272d 18 03			jr .pastdmark  
272f ..			.dmark: db "CBA"  
2732 f1			.pastdmark: pop af  
2733			endm  
# End of macro DMARK
2733					CALLMONITOR 
2733 cd 6f ee			call debug_vector  
2736				endm  
# End of macro CALLMONITOR
2736				endif 
2736 c3 ff 26			jp .storebyteat 
2739				NEXTW 
2739 c3 5e 21			jp macro_next 
273c				endm 
# End of macro NEXTW
273c			.SCALL: 
273c			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
273c 23				db WORD_SYS_CORE+OPCODE_SCALL             
273d 70 27			dw .DEPTH            
273f 05				db 4 + 1 
2740 .. 00			db "CALL",0              
2745				endm 
# End of macro CWHEAD
2745			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2745				if DEBUG_FORTH_WORDS_KEY 
2745					DMARK "CLL" 
2745 f5				push af  
2746 3a 5a 27			ld a, (.dmark)  
2749 32 6b ee			ld (debug_mark),a  
274c 3a 5b 27			ld a, (.dmark+1)  
274f 32 6c ee			ld (debug_mark+1),a  
2752 3a 5c 27			ld a, (.dmark+2)  
2755 32 6d ee			ld (debug_mark+2),a  
2758 18 03			jr .pastdmark  
275a ..			.dmark: db "CLL"  
275d f1			.pastdmark: pop af  
275e			endm  
# End of macro DMARK
275e					CALLMONITOR 
275e cd 6f ee			call debug_vector  
2761				endm  
# End of macro CALLMONITOR
2761				endif 
2761			 
2761				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2761 cd a8 1f			call macro_dsp_valuehl 
2764				endm 
# End of macro FORTH_DSP_VALUEHL
2764			 
2764			;		push hl 
2764			 
2764				; destroy value TOS 
2764			 
2764				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2764 cd 60 20			call macro_forth_dsp_pop 
2767				endm 
# End of macro FORTH_DSP_POP
2767			 
2767					 
2767			;		pop hl 
2767			 
2767				; how to do a call with hl???? save SP? 
2767 cd 02 21			call forth_call_hl 
276a			 
276a			 
276a				; TODO push value back onto stack for another op etc 
276a			 
276a cd b1 1d			call forth_push_numhl 
276d				NEXTW 
276d c3 5e 21			jp macro_next 
2770				endm 
# End of macro NEXTW
2770			.DEPTH: 
2770			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2770 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2771 ad 27			dw .OVER            
2773 06				db 5 + 1 
2774 .. 00			db "DEPTH",0              
277a				endm 
# End of macro CWHEAD
277a			; | DEPTH ( -- u ) Push count of stack | DONE 
277a				; take current TOS and remove from base value div by two to get count 
277a				if DEBUG_FORTH_WORDS_KEY 
277a					DMARK "DEP" 
277a f5				push af  
277b 3a 8f 27			ld a, (.dmark)  
277e 32 6b ee			ld (debug_mark),a  
2781 3a 90 27			ld a, (.dmark+1)  
2784 32 6c ee			ld (debug_mark+1),a  
2787 3a 91 27			ld a, (.dmark+2)  
278a 32 6d ee			ld (debug_mark+2),a  
278d 18 03			jr .pastdmark  
278f ..			.dmark: db "DEP"  
2792 f1			.pastdmark: pop af  
2793			endm  
# End of macro DMARK
2793					CALLMONITOR 
2793 cd 6f ee			call debug_vector  
2796				endm  
# End of macro CALLMONITOR
2796				endif 
2796			 
2796			 
2796 2a ee e9		ld hl, (cli_data_sp) 
2799 11 28 e8		ld de, cli_data_stack 
279c ed 52		sbc hl,de 
279e			 
279e			; div by size of stack item 
279e			 
279e 5d			ld e,l 
279f 0e 03		ld c, 3 
27a1 cd 76 0d		call Div8 
27a4			 
27a4 6f			ld l,a 
27a5 26 00		ld h,0 
27a7			 
27a7			;srl h 
27a7			;rr l 
27a7			 
27a7 cd b1 1d			call forth_push_numhl 
27aa				NEXTW 
27aa c3 5e 21			jp macro_next 
27ad				endm 
# End of macro NEXTW
27ad			.OVER: 
27ad			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
27ad 42				db WORD_SYS_CORE+46             
27ae f4 27			dw .PAUSE            
27b0 05				db 4 + 1 
27b1 .. 00			db "OVER",0              
27b6				endm 
# End of macro CWHEAD
27b6			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
27b6				if DEBUG_FORTH_WORDS_KEY 
27b6					DMARK "OVR" 
27b6 f5				push af  
27b7 3a cb 27			ld a, (.dmark)  
27ba 32 6b ee			ld (debug_mark),a  
27bd 3a cc 27			ld a, (.dmark+1)  
27c0 32 6c ee			ld (debug_mark+1),a  
27c3 3a cd 27			ld a, (.dmark+2)  
27c6 32 6d ee			ld (debug_mark+2),a  
27c9 18 03			jr .pastdmark  
27cb ..			.dmark: db "OVR"  
27ce f1			.pastdmark: pop af  
27cf			endm  
# End of macro DMARK
27cf					CALLMONITOR 
27cf cd 6f ee			call debug_vector  
27d2				endm  
# End of macro CALLMONITOR
27d2				endif 
27d2			 
27d2			; TODO Use os stack swap memory 
27d2				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27d2 cd a8 1f			call macro_dsp_valuehl 
27d5				endm 
# End of macro FORTH_DSP_VALUEHL
27d5 e5				push hl    ; n2 
27d6				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27d6 cd 60 20			call macro_forth_dsp_pop 
27d9				endm 
# End of macro FORTH_DSP_POP
27d9			 
27d9				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27d9 cd a8 1f			call macro_dsp_valuehl 
27dc				endm 
# End of macro FORTH_DSP_VALUEHL
27dc e5				push hl    ; n1 
27dd				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27dd cd 60 20			call macro_forth_dsp_pop 
27e0				endm 
# End of macro FORTH_DSP_POP
27e0			 
27e0 d1				pop de     ; n1 
27e1 e1				pop hl     ; n2 
27e2			 
27e2 d5				push de 
27e3 e5				push hl 
27e4 d5				push de 
27e5			 
27e5				; push back  
27e5			 
27e5 e1				pop hl 
27e6 cd b1 1d			call forth_push_numhl 
27e9 e1				pop hl 
27ea cd b1 1d			call forth_push_numhl 
27ed e1				pop hl 
27ee cd b1 1d			call forth_push_numhl 
27f1				NEXTW 
27f1 c3 5e 21			jp macro_next 
27f4				endm 
# End of macro NEXTW
27f4			 
27f4			.PAUSE: 
27f4			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
27f4 43				db WORD_SYS_CORE+47             
27f5 29 28			dw .PAUSES            
27f7 08				db 7 + 1 
27f8 .. 00			db "PAUSEMS",0              
2800				endm 
# End of macro CWHEAD
2800			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2800				if DEBUG_FORTH_WORDS_KEY 
2800					DMARK "PMS" 
2800 f5				push af  
2801 3a 15 28			ld a, (.dmark)  
2804 32 6b ee			ld (debug_mark),a  
2807 3a 16 28			ld a, (.dmark+1)  
280a 32 6c ee			ld (debug_mark+1),a  
280d 3a 17 28			ld a, (.dmark+2)  
2810 32 6d ee			ld (debug_mark+2),a  
2813 18 03			jr .pastdmark  
2815 ..			.dmark: db "PMS"  
2818 f1			.pastdmark: pop af  
2819			endm  
# End of macro DMARK
2819					CALLMONITOR 
2819 cd 6f ee			call debug_vector  
281c				endm  
# End of macro CALLMONITOR
281c				endif 
281c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
281c cd a8 1f			call macro_dsp_valuehl 
281f				endm 
# End of macro FORTH_DSP_VALUEHL
281f			;		push hl    ; n2 
281f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
281f cd 60 20			call macro_forth_dsp_pop 
2822				endm 
# End of macro FORTH_DSP_POP
2822			;		pop hl 
2822			 
2822 7d				ld a, l 
2823 cd d6 0a			call aDelayInMS 
2826			       NEXTW 
2826 c3 5e 21			jp macro_next 
2829				endm 
# End of macro NEXTW
2829			.PAUSES:  
2829			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2829 44				db WORD_SYS_CORE+48             
282a 98 28			dw .ROT            
282c 06				db 5 + 1 
282d .. 00			db "PAUSE",0              
2833				endm 
# End of macro CWHEAD
2833			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2833				if DEBUG_FORTH_WORDS_KEY 
2833					DMARK "PAU" 
2833 f5				push af  
2834 3a 48 28			ld a, (.dmark)  
2837 32 6b ee			ld (debug_mark),a  
283a 3a 49 28			ld a, (.dmark+1)  
283d 32 6c ee			ld (debug_mark+1),a  
2840 3a 4a 28			ld a, (.dmark+2)  
2843 32 6d ee			ld (debug_mark+2),a  
2846 18 03			jr .pastdmark  
2848 ..			.dmark: db "PAU"  
284b f1			.pastdmark: pop af  
284c			endm  
# End of macro DMARK
284c					CALLMONITOR 
284c cd 6f ee			call debug_vector  
284f				endm  
# End of macro CALLMONITOR
284f				endif 
284f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
284f cd a8 1f			call macro_dsp_valuehl 
2852				endm 
# End of macro FORTH_DSP_VALUEHL
2852			;		push hl    ; n2 
2852				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2852 cd 60 20			call macro_forth_dsp_pop 
2855				endm 
# End of macro FORTH_DSP_POP
2855			;		pop hl 
2855 45				ld b, l 
2856				if DEBUG_FORTH_WORDS 
2856					DMARK "PAU" 
2856 f5				push af  
2857 3a 6b 28			ld a, (.dmark)  
285a 32 6b ee			ld (debug_mark),a  
285d 3a 6c 28			ld a, (.dmark+1)  
2860 32 6c ee			ld (debug_mark+1),a  
2863 3a 6d 28			ld a, (.dmark+2)  
2866 32 6d ee			ld (debug_mark+2),a  
2869 18 03			jr .pastdmark  
286b ..			.dmark: db "PAU"  
286e f1			.pastdmark: pop af  
286f			endm  
# End of macro DMARK
286f					CALLMONITOR 
286f cd 6f ee			call debug_vector  
2872				endm  
# End of macro CALLMONITOR
2872				endif 
2872 c5			.pauses1:	push bc 
2873 cd f1 0a			call delay1s 
2876 c1				pop bc 
2877				if DEBUG_FORTH_WORDS 
2877					DMARK "PA1" 
2877 f5				push af  
2878 3a 8c 28			ld a, (.dmark)  
287b 32 6b ee			ld (debug_mark),a  
287e 3a 8d 28			ld a, (.dmark+1)  
2881 32 6c ee			ld (debug_mark+1),a  
2884 3a 8e 28			ld a, (.dmark+2)  
2887 32 6d ee			ld (debug_mark+2),a  
288a 18 03			jr .pastdmark  
288c ..			.dmark: db "PA1"  
288f f1			.pastdmark: pop af  
2890			endm  
# End of macro DMARK
2890					CALLMONITOR 
2890 cd 6f ee			call debug_vector  
2893				endm  
# End of macro CALLMONITOR
2893				endif 
2893 10 dd			djnz .pauses1 
2895			 
2895			       NEXTW 
2895 c3 5e 21			jp macro_next 
2898				endm 
# End of macro NEXTW
2898			.ROT: 
2898			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2898 45				db WORD_SYS_CORE+49             
2899 e6 28			dw .UWORDS            
289b 04				db 3 + 1 
289c .. 00			db "ROT",0              
28a0				endm 
# End of macro CWHEAD
28a0			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
28a0				if DEBUG_FORTH_WORDS_KEY 
28a0					DMARK "ROT" 
28a0 f5				push af  
28a1 3a b5 28			ld a, (.dmark)  
28a4 32 6b ee			ld (debug_mark),a  
28a7 3a b6 28			ld a, (.dmark+1)  
28aa 32 6c ee			ld (debug_mark+1),a  
28ad 3a b7 28			ld a, (.dmark+2)  
28b0 32 6d ee			ld (debug_mark+2),a  
28b3 18 03			jr .pastdmark  
28b5 ..			.dmark: db "ROT"  
28b8 f1			.pastdmark: pop af  
28b9			endm  
# End of macro DMARK
28b9					CALLMONITOR 
28b9 cd 6f ee			call debug_vector  
28bc				endm  
# End of macro CALLMONITOR
28bc				endif 
28bc			 
28bc			; TODO Use os stack swap memory 
28bc				FORTH_DSP_VALUEHL 
28bc cd a8 1f			call macro_dsp_valuehl 
28bf				endm 
# End of macro FORTH_DSP_VALUEHL
28bf e5				push hl    ; u3  
28c0			 
28c0				FORTH_DSP_POP 
28c0 cd 60 20			call macro_forth_dsp_pop 
28c3				endm 
# End of macro FORTH_DSP_POP
28c3			 
28c3				FORTH_DSP_VALUEHL 
28c3 cd a8 1f			call macro_dsp_valuehl 
28c6				endm 
# End of macro FORTH_DSP_VALUEHL
28c6 e5				push hl     ; u2 
28c7			 
28c7				FORTH_DSP_POP 
28c7 cd 60 20			call macro_forth_dsp_pop 
28ca				endm 
# End of macro FORTH_DSP_POP
28ca			 
28ca				FORTH_DSP_VALUEHL 
28ca cd a8 1f			call macro_dsp_valuehl 
28cd				endm 
# End of macro FORTH_DSP_VALUEHL
28cd e5				push hl     ; u1 
28ce			 
28ce				FORTH_DSP_POP 
28ce cd 60 20			call macro_forth_dsp_pop 
28d1				endm 
# End of macro FORTH_DSP_POP
28d1			 
28d1 c1				pop bc      ; u1 
28d2 e1				pop hl      ; u2 
28d3 d1				pop de      ; u3 
28d4			 
28d4			 
28d4 c5				push bc 
28d5 d5				push de 
28d6 e5				push hl 
28d7			 
28d7			 
28d7 e1				pop hl 
28d8 cd b1 1d			call forth_push_numhl 
28db			 
28db e1				pop hl 
28dc cd b1 1d			call forth_push_numhl 
28df			 
28df e1				pop hl 
28e0 cd b1 1d			call forth_push_numhl 
28e3				 
28e3			 
28e3			 
28e3			 
28e3			 
28e3			 
28e3			       NEXTW 
28e3 c3 5e 21			jp macro_next 
28e6				endm 
# End of macro NEXTW
28e6			 
28e6			.UWORDS: 
28e6			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
28e6 50				db WORD_SYS_CORE+60             
28e7 a8 29			dw .BP            
28e9 07				db 6 + 1 
28ea .. 00			db "UWORDS",0              
28f1				endm 
# End of macro CWHEAD
28f1			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
28f1			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
28f1			; | | Following the count are the individual words. 
28f1			; | | 
28f1			; | | e.g. UWORDS 
28f1			; | | BOX DIRLIST 2 
28f1			; | |  
28f1			; | | Can be used to save the words to storage via: 
28f1			; | | UWORDS $01 DO $01 APPEND LOOP 
28f1			if DEBUG_FORTH_WORDS_KEY 
28f1				DMARK "UWR" 
28f1 f5				push af  
28f2 3a 06 29			ld a, (.dmark)  
28f5 32 6b ee			ld (debug_mark),a  
28f8 3a 07 29			ld a, (.dmark+1)  
28fb 32 6c ee			ld (debug_mark+1),a  
28fe 3a 08 29			ld a, (.dmark+2)  
2901 32 6d ee			ld (debug_mark+2),a  
2904 18 03			jr .pastdmark  
2906 ..			.dmark: db "UWR"  
2909 f1			.pastdmark: pop af  
290a			endm  
# End of macro DMARK
290a				CALLMONITOR 
290a cd 6f ee			call debug_vector  
290d				endm  
# End of macro CALLMONITOR
290d			endif 
290d 21 a6 67			ld hl, baseram 
2910				;ld hl, baseusermem 
2910 01 00 00			ld bc, 0    ; start a counter 
2913			 
2913			; skip dict stub 
2913			 
2913 cd af 22			call forth_tok_next 
2916			 
2916			 
2916			; while we have words to look for 
2916			 
2916 7e			.douscan:	ld a, (hl)      
2917			if DEBUG_FORTH_WORDS 
2917				DMARK "UWs" 
2917 f5				push af  
2918 3a 2c 29			ld a, (.dmark)  
291b 32 6b ee			ld (debug_mark),a  
291e 3a 2d 29			ld a, (.dmark+1)  
2921 32 6c ee			ld (debug_mark+1),a  
2924 3a 2e 29			ld a, (.dmark+2)  
2927 32 6d ee			ld (debug_mark+2),a  
292a 18 03			jr .pastdmark  
292c ..			.dmark: db "UWs"  
292f f1			.pastdmark: pop af  
2930			endm  
# End of macro DMARK
2930				CALLMONITOR 
2930 cd 6f ee			call debug_vector  
2933				endm  
# End of macro CALLMONITOR
2933			endif 
2933 fe 00			cp WORD_SYS_END 
2935 28 4d			jr z, .udone 
2937 fe 01			cp WORD_SYS_UWORD 
2939 20 44			jr nz, .nuword 
293b			 
293b			if DEBUG_FORTH_WORDS 
293b				DMARK "UWu" 
293b f5				push af  
293c 3a 50 29			ld a, (.dmark)  
293f 32 6b ee			ld (debug_mark),a  
2942 3a 51 29			ld a, (.dmark+1)  
2945 32 6c ee			ld (debug_mark+1),a  
2948 3a 52 29			ld a, (.dmark+2)  
294b 32 6d ee			ld (debug_mark+2),a  
294e 18 03			jr .pastdmark  
2950 ..			.dmark: db "UWu"  
2953 f1			.pastdmark: pop af  
2954			endm  
# End of macro DMARK
2954				CALLMONITOR 
2954 cd 6f ee			call debug_vector  
2957				endm  
# End of macro CALLMONITOR
2957			endif 
2957				; we have a uword so push its name to the stack 
2957			 
2957 e5				push hl  ; save so we can move to next dict block 
2958			 
2958				; skip opcode 
2958 23				inc hl  
2959				; skip next ptr 
2959 23				inc hl  
295a 23				inc hl 
295b				; skip len 
295b 23				inc hl 
295c			if DEBUG_FORTH_WORDS 
295c				DMARK "UWt" 
295c f5				push af  
295d 3a 71 29			ld a, (.dmark)  
2960 32 6b ee			ld (debug_mark),a  
2963 3a 72 29			ld a, (.dmark+1)  
2966 32 6c ee			ld (debug_mark+1),a  
2969 3a 73 29			ld a, (.dmark+2)  
296c 32 6d ee			ld (debug_mark+2),a  
296f 18 03			jr .pastdmark  
2971 ..			.dmark: db "UWt"  
2974 f1			.pastdmark: pop af  
2975			endm  
# End of macro DMARK
2975				CALLMONITOR 
2975 cd 6f ee			call debug_vector  
2978				endm  
# End of macro CALLMONITOR
2978			endif 
2978 03				inc bc 
2979			 
2979 c5				push bc 
297a cd 1f 1e			call forth_push_str 
297d c1				pop bc 
297e			 
297e e1				pop hl 	 
297f			 
297f cd af 22		.nuword:	call forth_tok_next 
2982 18 92			jr .douscan  
2984			 
2984			.udone:		 ; push count of uwords found 
2984 c5				push bc 
2985 e1				pop hl 
2986			 
2986			if DEBUG_FORTH_WORDS 
2986				DMARK "UWc" 
2986 f5				push af  
2987 3a 9b 29			ld a, (.dmark)  
298a 32 6b ee			ld (debug_mark),a  
298d 3a 9c 29			ld a, (.dmark+1)  
2990 32 6c ee			ld (debug_mark+1),a  
2993 3a 9d 29			ld a, (.dmark+2)  
2996 32 6d ee			ld (debug_mark+2),a  
2999 18 03			jr .pastdmark  
299b ..			.dmark: db "UWc"  
299e f1			.pastdmark: pop af  
299f			endm  
# End of macro DMARK
299f				CALLMONITOR 
299f cd 6f ee			call debug_vector  
29a2				endm  
# End of macro CALLMONITOR
29a2			endif 
29a2 cd b1 1d			call forth_push_numhl 
29a5			 
29a5			 
29a5			       NEXTW 
29a5 c3 5e 21			jp macro_next 
29a8				endm 
# End of macro NEXTW
29a8			 
29a8			.BP: 
29a8			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
29a8 54				db WORD_SYS_CORE+64             
29a9 e2 29			dw .MONITOR            
29ab 03				db 2 + 1 
29ac .. 00			db "BP",0              
29af				endm 
# End of macro CWHEAD
29af			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
29af			; | | $00 Will enable the break points within specific code paths 
29af			; | | $01 Will disable break points 
29af			; | |  
29af			; | | By default break points are off. Either the above can be used to enable them 
29af			; | | or if a key is held down during start up the spashscreen will appear to freeze 
29af			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
29af			; | | can disable break points. Exiting will then continue boot process. 
29af				; get byte count 
29af				if DEBUG_FORTH_WORDS_KEY 
29af					DMARK "BP." 
29af f5				push af  
29b0 3a c4 29			ld a, (.dmark)  
29b3 32 6b ee			ld (debug_mark),a  
29b6 3a c5 29			ld a, (.dmark+1)  
29b9 32 6c ee			ld (debug_mark+1),a  
29bc 3a c6 29			ld a, (.dmark+2)  
29bf 32 6d ee			ld (debug_mark+2),a  
29c2 18 03			jr .pastdmark  
29c4 ..			.dmark: db "BP."  
29c7 f1			.pastdmark: pop af  
29c8			endm  
# End of macro DMARK
29c8					CALLMONITOR 
29c8 cd 6f ee			call debug_vector  
29cb				endm  
# End of macro CALLMONITOR
29cb				endif 
29cb			 
29cb				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29cb cd a8 1f			call macro_dsp_valuehl 
29ce				endm 
# End of macro FORTH_DSP_VALUEHL
29ce			 
29ce			;		push hl 
29ce			 
29ce				; destroy value TOS 
29ce			 
29ce				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29ce cd 60 20			call macro_forth_dsp_pop 
29d1				endm 
# End of macro FORTH_DSP_POP
29d1			 
29d1			;		pop hl 
29d1			 
29d1 3e 00			ld a,0 
29d3 bd				cp l 
29d4 28 06			jr z, .bpset 
29d6			;		ld a, '*' 
29d6 cd 53 17			call bp_off 
29d9				NEXTW 
29d9 c3 5e 21			jp macro_next 
29dc				endm 
# End of macro NEXTW
29dc			 
29dc			.bpset:	 
29dc				;	ld (os_view_disable), a 
29dc cd 47 17			call bp_on 
29df			 
29df			 
29df				NEXTW 
29df c3 5e 21			jp macro_next 
29e2				endm 
# End of macro NEXTW
29e2			 
29e2			 
29e2			.MONITOR: 
29e2			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
29e2 55				db WORD_SYS_CORE+65             
29e3 13 2a			dw .MALLOC            
29e5 08				db 7 + 1 
29e6 .. 00			db "MONITOR",0              
29ee				endm 
# End of macro CWHEAD
29ee			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
29ee			; | | At start the current various registers will be displayed with contents. 
29ee			; | | Top right corner will show the most recent debug marker seen. 
29ee			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
29ee			; | | and the return stack pointer (RSP). 
29ee			; | | Pressing: 
29ee			; | |    1 - Initial screen 
29ee			; | |    2 - Display a data dump of HL 
29ee			; | |    3 - Display a data dump of DE 
29ee			; | |    4 - Display a data dump of BC 
29ee			; | |    5 - Display a data dump of HL 
29ee			; | |    6 - Display a data dump of DSP 
29ee			; | |    7 - Display a data dump of RSP 
29ee			; | |    8 - Display a data dump of what is at DSP 
29ee			; | |    9 - Display a data dump of what is at RSP 
29ee			; | |    0 - Exit monitor and continue running. This will also enable break points 
29ee			; | |    * - Disable break points 
29ee			; | |    # - Enter traditional monitor mode 
29ee			; | | 
29ee			; | | Monitor Mode 
29ee			; | | ------------ 
29ee			; | | A prompt of '>' will be shown for various commands: 
29ee			; | |    D xxxx - Display a data dump starting from hex address xxxx 
29ee			; | |    C - Continue display a data dump from the last set address 
29ee			; | |    M xxxx - Set start of memory edit at address xx 
29ee			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
29ee			; | |    G xxxx - Exec code at specific address 
29ee			; | |    Q - Return to previous 
29ee				if DEBUG_FORTH_WORDS_KEY 
29ee					DMARK "MON" 
29ee f5				push af  
29ef 3a 03 2a			ld a, (.dmark)  
29f2 32 6b ee			ld (debug_mark),a  
29f5 3a 04 2a			ld a, (.dmark+1)  
29f8 32 6c ee			ld (debug_mark+1),a  
29fb 3a 05 2a			ld a, (.dmark+2)  
29fe 32 6d ee			ld (debug_mark+2),a  
2a01 18 03			jr .pastdmark  
2a03 ..			.dmark: db "MON"  
2a06 f1			.pastdmark: pop af  
2a07			endm  
# End of macro DMARK
2a07					CALLMONITOR 
2a07 cd 6f ee			call debug_vector  
2a0a				endm  
# End of macro CALLMONITOR
2a0a				endif 
2a0a			;		ld a, 0 
2a0a			;		ld (os_view_disable), a 
2a0a cd 47 17			call bp_on 
2a0d			 
2a0d				CALLMONITOR 
2a0d cd 6f ee			call debug_vector  
2a10				endm  
# End of macro CALLMONITOR
2a10			 
2a10			;	call monitor 
2a10			 
2a10				NEXTW 
2a10 c3 5e 21			jp macro_next 
2a13				endm 
# End of macro NEXTW
2a13			 
2a13			 
2a13			.MALLOC: 
2a13			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2a13 56				db WORD_SYS_CORE+66             
2a14 3c 2a			dw .MALLOC2            
2a16 06				db 5 + 1 
2a17 .. 00			db "ALLOT",0              
2a1d				endm 
# End of macro CWHEAD
2a1d			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2a1d				if DEBUG_FORTH_WORDS_KEY 
2a1d					DMARK "ALL" 
2a1d f5				push af  
2a1e 3a 32 2a			ld a, (.dmark)  
2a21 32 6b ee			ld (debug_mark),a  
2a24 3a 33 2a			ld a, (.dmark+1)  
2a27 32 6c ee			ld (debug_mark+1),a  
2a2a 3a 34 2a			ld a, (.dmark+2)  
2a2d 32 6d ee			ld (debug_mark+2),a  
2a30 18 03			jr .pastdmark  
2a32 ..			.dmark: db "ALL"  
2a35 f1			.pastdmark: pop af  
2a36			endm  
# End of macro DMARK
2a36					CALLMONITOR 
2a36 cd 6f ee			call debug_vector  
2a39				endm  
# End of macro CALLMONITOR
2a39				endif 
2a39 c3 63 2a			jp .mallocc 
2a3c			.MALLOC2: 
2a3c			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2a3c 56				db WORD_SYS_CORE+66             
2a3d 7a 2a			dw .FREE            
2a3f 07				db 6 + 1 
2a40 .. 00			db "MALLOC",0              
2a47				endm 
# End of macro CWHEAD
2a47			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2a47				; get byte count 
2a47				if DEBUG_FORTH_WORDS_KEY 
2a47					DMARK "MAL" 
2a47 f5				push af  
2a48 3a 5c 2a			ld a, (.dmark)  
2a4b 32 6b ee			ld (debug_mark),a  
2a4e 3a 5d 2a			ld a, (.dmark+1)  
2a51 32 6c ee			ld (debug_mark+1),a  
2a54 3a 5e 2a			ld a, (.dmark+2)  
2a57 32 6d ee			ld (debug_mark+2),a  
2a5a 18 03			jr .pastdmark  
2a5c ..			.dmark: db "MAL"  
2a5f f1			.pastdmark: pop af  
2a60			endm  
# End of macro DMARK
2a60					CALLMONITOR 
2a60 cd 6f ee			call debug_vector  
2a63				endm  
# End of macro CALLMONITOR
2a63				endif 
2a63			.mallocc: 
2a63				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a63 cd a8 1f			call macro_dsp_valuehl 
2a66				endm 
# End of macro FORTH_DSP_VALUEHL
2a66			 
2a66			;		push hl 
2a66			 
2a66				; destroy value TOS 
2a66			 
2a66				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a66 cd 60 20			call macro_forth_dsp_pop 
2a69				endm 
# End of macro FORTH_DSP_POP
2a69			 
2a69			;		pop hl 
2a69 cd 18 14			call malloc 
2a6c			if DEBUG_FORTH_MALLOC_GUARD 
2a6c f5				push af 
2a6d cd 0f 0e			call ishlzero 
2a70			;		ld a, l 
2a70			;		add h 
2a70			;		cp 0 
2a70 f1				pop af 
2a71				 
2a71 cc 1e 4f			call z,malloc_error 
2a74			endif 
2a74			 
2a74 cd b1 1d			call forth_push_numhl 
2a77				NEXTW 
2a77 c3 5e 21			jp macro_next 
2a7a				endm 
# End of macro NEXTW
2a7a			 
2a7a			.FREE: 
2a7a			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2a7a 57				db WORD_SYS_CORE+67             
2a7b ab 2a			dw .LIST            
2a7d 05				db 4 + 1 
2a7e .. 00			db "FREE",0              
2a83				endm 
# End of macro CWHEAD
2a83			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2a83				if DEBUG_FORTH_WORDS_KEY 
2a83					DMARK "FRE" 
2a83 f5				push af  
2a84 3a 98 2a			ld a, (.dmark)  
2a87 32 6b ee			ld (debug_mark),a  
2a8a 3a 99 2a			ld a, (.dmark+1)  
2a8d 32 6c ee			ld (debug_mark+1),a  
2a90 3a 9a 2a			ld a, (.dmark+2)  
2a93 32 6d ee			ld (debug_mark+2),a  
2a96 18 03			jr .pastdmark  
2a98 ..			.dmark: db "FRE"  
2a9b f1			.pastdmark: pop af  
2a9c			endm  
# End of macro DMARK
2a9c					CALLMONITOR 
2a9c cd 6f ee			call debug_vector  
2a9f				endm  
# End of macro CALLMONITOR
2a9f				endif 
2a9f				; get address 
2a9f			 
2a9f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a9f cd a8 1f			call macro_dsp_valuehl 
2aa2				endm 
# End of macro FORTH_DSP_VALUEHL
2aa2			 
2aa2			;		push hl 
2aa2			 
2aa2				; destroy value TOS 
2aa2			 
2aa2				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2aa2 cd 60 20			call macro_forth_dsp_pop 
2aa5				endm 
# End of macro FORTH_DSP_POP
2aa5			 
2aa5			;		pop hl 
2aa5			if FORTH_ENABLE_MALLOCFREE 
2aa5 cd e2 14			call free 
2aa8			endif 
2aa8				NEXTW 
2aa8 c3 5e 21			jp macro_next 
2aab				endm 
# End of macro NEXTW
2aab			.LIST: 
2aab			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2aab 5c				db WORD_SYS_CORE+72             
2aac 9b 2c			dw .FORGET            
2aae 05				db 4 + 1 
2aaf .. 00			db "LIST",0              
2ab4				endm 
# End of macro CWHEAD
2ab4			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2ab4			; | | The quoted word must be in upper case. 
2ab4			if DEBUG_FORTH_WORDS_KEY 
2ab4				DMARK "LST" 
2ab4 f5				push af  
2ab5 3a c9 2a			ld a, (.dmark)  
2ab8 32 6b ee			ld (debug_mark),a  
2abb 3a ca 2a			ld a, (.dmark+1)  
2abe 32 6c ee			ld (debug_mark+1),a  
2ac1 3a cb 2a			ld a, (.dmark+2)  
2ac4 32 6d ee			ld (debug_mark+2),a  
2ac7 18 03			jr .pastdmark  
2ac9 ..			.dmark: db "LST"  
2acc f1			.pastdmark: pop af  
2acd			endm  
# End of macro DMARK
2acd				CALLMONITOR 
2acd cd 6f ee			call debug_vector  
2ad0				endm  
# End of macro CALLMONITOR
2ad0			endif 
2ad0			 
2ad0				FORTH_DSP_VALUEHL 
2ad0 cd a8 1f			call macro_dsp_valuehl 
2ad3				endm 
# End of macro FORTH_DSP_VALUEHL
2ad3			 
2ad3 e5				push hl 
2ad4				FORTH_DSP_POP 
2ad4 cd 60 20			call macro_forth_dsp_pop 
2ad7				endm 
# End of macro FORTH_DSP_POP
2ad7 c1				pop bc 
2ad8			 
2ad8			; Start format of scratch string 
2ad8			 
2ad8 21 c1 e2			ld hl, scratch 
2adb			 
2adb 3e 3a			ld a, ':' 
2add 77				ld (hl),a 
2ade 23				inc hl 
2adf 3e 20			ld a, ' ' 
2ae1 77				ld (hl), a 
2ae2			 
2ae2				; Get ptr to the word we need to look up 
2ae2			 
2ae2			;		FORTH_DSP_VALUEHL 
2ae2				;v5 FORTH_DSP_VALUE 
2ae2			; TODO type check 
2ae2			;		inc hl    ; Skip type check  
2ae2			;		push hl 
2ae2			;		ex de, hl    ; put into DE 
2ae2			 
2ae2			 
2ae2 21 a6 67			ld hl, baseram 
2ae5				;ld hl, baseusermem 
2ae5			 
2ae5 e5			push hl   ; sacreifical push 
2ae6			 
2ae6			.ldouscanm: 
2ae6 e1			pop hl 
2ae7			.ldouscan: 
2ae7			if DEBUG_FORTH_WORDS 
2ae7				DMARK "LSs" 
2ae7 f5				push af  
2ae8 3a fc 2a			ld a, (.dmark)  
2aeb 32 6b ee			ld (debug_mark),a  
2aee 3a fd 2a			ld a, (.dmark+1)  
2af1 32 6c ee			ld (debug_mark+1),a  
2af4 3a fe 2a			ld a, (.dmark+2)  
2af7 32 6d ee			ld (debug_mark+2),a  
2afa 18 03			jr .pastdmark  
2afc ..			.dmark: db "LSs"  
2aff f1			.pastdmark: pop af  
2b00			endm  
# End of macro DMARK
2b00				CALLMONITOR 
2b00 cd 6f ee			call debug_vector  
2b03				endm  
# End of macro CALLMONITOR
2b03			endif 
2b03			; skip dict stub 
2b03 cd af 22			call forth_tok_next 
2b06			 
2b06			 
2b06			; while we have words to look for 
2b06			 
2b06 7e			ld a, (hl)      
2b07			if DEBUG_FORTH_WORDS 
2b07				DMARK "LSk" 
2b07 f5				push af  
2b08 3a 1c 2b			ld a, (.dmark)  
2b0b 32 6b ee			ld (debug_mark),a  
2b0e 3a 1d 2b			ld a, (.dmark+1)  
2b11 32 6c ee			ld (debug_mark+1),a  
2b14 3a 1e 2b			ld a, (.dmark+2)  
2b17 32 6d ee			ld (debug_mark+2),a  
2b1a 18 03			jr .pastdmark  
2b1c ..			.dmark: db "LSk"  
2b1f f1			.pastdmark: pop af  
2b20			endm  
# End of macro DMARK
2b20				CALLMONITOR 
2b20 cd 6f ee			call debug_vector  
2b23				endm  
# End of macro CALLMONITOR
2b23			endif 
2b23				;cp WORD_SYS_END 
2b23				;jp z, .lunotfound 
2b23			 
2b23					; if we hit non uwords then gone too far 
2b23 fe 01				cp WORD_SYS_UWORD 
2b25 c2 57 2c				jp nz, .lunotfound 
2b28			 
2b28				if DEBUG_FORTH_WORDS 
2b28					DMARK "LSu" 
2b28 f5				push af  
2b29 3a 3d 2b			ld a, (.dmark)  
2b2c 32 6b ee			ld (debug_mark),a  
2b2f 3a 3e 2b			ld a, (.dmark+1)  
2b32 32 6c ee			ld (debug_mark+1),a  
2b35 3a 3f 2b			ld a, (.dmark+2)  
2b38 32 6d ee			ld (debug_mark+2),a  
2b3b 18 03			jr .pastdmark  
2b3d ..			.dmark: db "LSu"  
2b40 f1			.pastdmark: pop af  
2b41			endm  
# End of macro DMARK
2b41					CALLMONITOR 
2b41 cd 6f ee			call debug_vector  
2b44				endm  
# End of macro CALLMONITOR
2b44				endif 
2b44			 
2b44					; found a uword but is it the one we want... 
2b44			 
2b44 c5					push bc     ; uword to find is on bc 
2b45 d1					pop de 
2b46			 
2b46 e5					push hl  ; to save the ptr 
2b47			 
2b47					; skip opcode 
2b47 23					inc hl  
2b48					; skip next ptr 
2b48 23					inc hl  
2b49 23					inc hl 
2b4a					; skip len 
2b4a 23					inc hl 
2b4b			 
2b4b				if DEBUG_FORTH_WORDS 
2b4b					DMARK "LSc" 
2b4b f5				push af  
2b4c 3a 60 2b			ld a, (.dmark)  
2b4f 32 6b ee			ld (debug_mark),a  
2b52 3a 61 2b			ld a, (.dmark+1)  
2b55 32 6c ee			ld (debug_mark+1),a  
2b58 3a 62 2b			ld a, (.dmark+2)  
2b5b 32 6d ee			ld (debug_mark+2),a  
2b5e 18 03			jr .pastdmark  
2b60 ..			.dmark: db "LSc"  
2b63 f1			.pastdmark: pop af  
2b64			endm  
# End of macro DMARK
2b64					CALLMONITOR 
2b64 cd 6f ee			call debug_vector  
2b67				endm  
# End of macro CALLMONITOR
2b67				endif 
2b67			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2b67			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2b67			; Nope that has gone the other way. It needs to be exact not on first zero 
2b67			;		call strcmp 
2b67 c5					push bc 
2b68 cd e8 13				call StrictStrCmp 
2b6b c1					pop bc 
2b6c c2 e6 2a				jp nz, .ldouscanm 
2b6f				 
2b6f			 
2b6f			 
2b6f					; we have a uword so push its name to the stack 
2b6f			 
2b6f			;	   	push hl  ; save so we can move to next dict block 
2b6f e1			pop hl 
2b70			 
2b70				if DEBUG_FORTH_WORDS 
2b70					DMARK "LSm" 
2b70 f5				push af  
2b71 3a 85 2b			ld a, (.dmark)  
2b74 32 6b ee			ld (debug_mark),a  
2b77 3a 86 2b			ld a, (.dmark+1)  
2b7a 32 6c ee			ld (debug_mark+1),a  
2b7d 3a 87 2b			ld a, (.dmark+2)  
2b80 32 6d ee			ld (debug_mark+2),a  
2b83 18 03			jr .pastdmark  
2b85 ..			.dmark: db "LSm"  
2b88 f1			.pastdmark: pop af  
2b89			endm  
# End of macro DMARK
2b89					CALLMONITOR 
2b89 cd 6f ee			call debug_vector  
2b8c				endm  
# End of macro CALLMONITOR
2b8c				endif 
2b8c			 
2b8c					; skip opcode 
2b8c 23					inc hl  
2b8d					; skip next ptr 
2b8d 23					inc hl  
2b8e 23					inc hl 
2b8f					; skip len 
2b8f 7e					ld a, (hl)   ; save length to add 
2b90				if DEBUG_FORTH_WORDS 
2b90					DMARK "LS2" 
2b90 f5				push af  
2b91 3a a5 2b			ld a, (.dmark)  
2b94 32 6b ee			ld (debug_mark),a  
2b97 3a a6 2b			ld a, (.dmark+1)  
2b9a 32 6c ee			ld (debug_mark+1),a  
2b9d 3a a7 2b			ld a, (.dmark+2)  
2ba0 32 6d ee			ld (debug_mark+2),a  
2ba3 18 03			jr .pastdmark  
2ba5 ..			.dmark: db "LS2"  
2ba8 f1			.pastdmark: pop af  
2ba9			endm  
# End of macro DMARK
2ba9					CALLMONITOR 
2ba9 cd 6f ee			call debug_vector  
2bac				endm  
# End of macro CALLMONITOR
2bac				endif 
2bac			 
2bac					; save this location 
2bac				 
2bac e5					push hl 
2bad			 
2bad 23					inc hl 
2bae 11 c3 e2				ld de, scratch+2 
2bb1 4f					ld c, a 
2bb2 06 00				ld b, 0 
2bb4			 
2bb4				if DEBUG_FORTH_WORDS 
2bb4					DMARK "LSn" 
2bb4 f5				push af  
2bb5 3a c9 2b			ld a, (.dmark)  
2bb8 32 6b ee			ld (debug_mark),a  
2bbb 3a ca 2b			ld a, (.dmark+1)  
2bbe 32 6c ee			ld (debug_mark+1),a  
2bc1 3a cb 2b			ld a, (.dmark+2)  
2bc4 32 6d ee			ld (debug_mark+2),a  
2bc7 18 03			jr .pastdmark  
2bc9 ..			.dmark: db "LSn"  
2bcc f1			.pastdmark: pop af  
2bcd			endm  
# End of macro DMARK
2bcd					CALLMONITOR 
2bcd cd 6f ee			call debug_vector  
2bd0				endm  
# End of macro CALLMONITOR
2bd0				endif 
2bd0			 
2bd0					; copy uword name to scratch 
2bd0			 
2bd0 ed b0				ldir 
2bd2			 
2bd2 1b					dec de 
2bd3 3e 20				ld a, ' '    ; change null to space 
2bd5 12					ld (de), a 
2bd6			 
2bd6 13					inc de 
2bd7			 
2bd7 d5					push de 
2bd8 c1					pop bc     ; move scratch pointer to end of word name and save it 
2bd9			 
2bd9 e1					pop hl 
2bda 7e					ld a, (hl) 
2bdb					;inc hl 
2bdb					; skip word string 
2bdb cd e6 0d				call addatohl 
2bde			 
2bde 23					inc hl 
2bdf			 
2bdf				if DEBUG_FORTH_WORDS 
2bdf					DMARK "LS3" 
2bdf f5				push af  
2be0 3a f4 2b			ld a, (.dmark)  
2be3 32 6b ee			ld (debug_mark),a  
2be6 3a f5 2b			ld a, (.dmark+1)  
2be9 32 6c ee			ld (debug_mark+1),a  
2bec 3a f6 2b			ld a, (.dmark+2)  
2bef 32 6d ee			ld (debug_mark+2),a  
2bf2 18 03			jr .pastdmark  
2bf4 ..			.dmark: db "LS3"  
2bf7 f1			.pastdmark: pop af  
2bf8			endm  
# End of macro DMARK
2bf8					CALLMONITOR 
2bf8 cd 6f ee			call debug_vector  
2bfb				endm  
# End of macro CALLMONITOR
2bfb				endif 
2bfb					; should now be at the start of the machine code to setup the eval of the uword 
2bfb					; now locate the ptr to the string defintion 
2bfb			 
2bfb					; skip ld hl, 
2bfb					; then load the ptr 
2bfb			; TODO use get from hl ptr 
2bfb 23					inc hl 
2bfc 5e					ld e, (hl) 
2bfd 23					inc hl 
2bfe 56					ld d, (hl) 
2bff eb					ex de, hl 
2c00			 
2c00			 
2c00				if DEBUG_FORTH_WORDS 
2c00					DMARK "LSt" 
2c00 f5				push af  
2c01 3a 15 2c			ld a, (.dmark)  
2c04 32 6b ee			ld (debug_mark),a  
2c07 3a 16 2c			ld a, (.dmark+1)  
2c0a 32 6c ee			ld (debug_mark+1),a  
2c0d 3a 17 2c			ld a, (.dmark+2)  
2c10 32 6d ee			ld (debug_mark+2),a  
2c13 18 03			jr .pastdmark  
2c15 ..			.dmark: db "LSt"  
2c18 f1			.pastdmark: pop af  
2c19			endm  
# End of macro DMARK
2c19					CALLMONITOR 
2c19 cd 6f ee			call debug_vector  
2c1c				endm  
# End of macro CALLMONITOR
2c1c				endif 
2c1c			 
2c1c			; cant push right now due to tokenised strings  
2c1c			 
2c1c			; get the destination of where to copy this definition to. 
2c1c			 
2c1c c5					push bc 
2c1d d1					pop de 
2c1e			 
2c1e 7e			.listl:         ld a,(hl) 
2c1f fe 00				cp 0 
2c21 28 09				jr z, .lreplsp     ; replace zero with space 
2c23					;cp FORTH_END_BUFFER 
2c23 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2c25 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2c27				 
2c27					; just copy this char as is then 
2c27			 
2c27 12					ld (de), a 
2c28			 
2c28 23			.listnxt:	inc hl 
2c29 13					inc de 
2c2a 18 f2				jr .listl 
2c2c			 
2c2c 3e 20		.lreplsp:	ld a,' ' 
2c2e 12					ld (de), a 
2c2f 18 f7				jr .listnxt 
2c31			 
2c31			; close up uword def 
2c31			 
2c31			.listdone: 
2c31 12					ld (de), a 
2c32 13					inc de 
2c33 3e 00				ld a, 0 
2c35 12					ld (de), a 
2c36			 
2c36			; now have def so clean up and push to stack 
2c36			 
2c36 21 c1 e2				ld hl, scratch 
2c39				if DEBUG_FORTH_WORDS 
2c39					DMARK "Ltp" 
2c39 f5				push af  
2c3a 3a 4e 2c			ld a, (.dmark)  
2c3d 32 6b ee			ld (debug_mark),a  
2c40 3a 4f 2c			ld a, (.dmark+1)  
2c43 32 6c ee			ld (debug_mark+1),a  
2c46 3a 50 2c			ld a, (.dmark+2)  
2c49 32 6d ee			ld (debug_mark+2),a  
2c4c 18 03			jr .pastdmark  
2c4e ..			.dmark: db "Ltp"  
2c51 f1			.pastdmark: pop af  
2c52			endm  
# End of macro DMARK
2c52					CALLMONITOR 
2c52 cd 6f ee			call debug_vector  
2c55				endm  
# End of macro CALLMONITOR
2c55				endif 
2c55			 
2c55 18 1f			jr .listpush 
2c57			 
2c57			;.lnuword:	pop hl 
2c57			;		call forth_tok_next 
2c57			;		jp .ldouscan  
2c57			 
2c57			.lunotfound:		  
2c57			 
2c57				if DEBUG_FORTH_WORDS 
2c57					DMARK "LSn" 
2c57 f5				push af  
2c58 3a 6c 2c			ld a, (.dmark)  
2c5b 32 6b ee			ld (debug_mark),a  
2c5e 3a 6d 2c			ld a, (.dmark+1)  
2c61 32 6c ee			ld (debug_mark+1),a  
2c64 3a 6e 2c			ld a, (.dmark+2)  
2c67 32 6d ee			ld (debug_mark+2),a  
2c6a 18 03			jr .pastdmark  
2c6c ..			.dmark: db "LSn"  
2c6f f1			.pastdmark: pop af  
2c70			endm  
# End of macro DMARK
2c70					CALLMONITOR 
2c70 cd 6f ee			call debug_vector  
2c73				endm  
# End of macro CALLMONITOR
2c73				endif 
2c73			 
2c73					 
2c73			;		FORTH_DSP_POP 
2c73			;		ld hl, .luno 
2c73			 
2c73					NEXTW			 
2c73 c3 5e 21			jp macro_next 
2c76				endm 
# End of macro NEXTW
2c76			 
2c76			.listpush: 
2c76				if DEBUG_FORTH_WORDS 
2c76					DMARK "LS>" 
2c76 f5				push af  
2c77 3a 8b 2c			ld a, (.dmark)  
2c7a 32 6b ee			ld (debug_mark),a  
2c7d 3a 8c 2c			ld a, (.dmark+1)  
2c80 32 6c ee			ld (debug_mark+1),a  
2c83 3a 8d 2c			ld a, (.dmark+2)  
2c86 32 6d ee			ld (debug_mark+2),a  
2c89 18 03			jr .pastdmark  
2c8b ..			.dmark: db "LS>"  
2c8e f1			.pastdmark: pop af  
2c8f			endm  
# End of macro DMARK
2c8f					CALLMONITOR 
2c8f cd 6f ee			call debug_vector  
2c92				endm  
# End of macro CALLMONITOR
2c92				endif 
2c92 cd 1f 1e				call forth_push_str 
2c95			 
2c95			 
2c95			 
2c95					NEXTW 
2c95 c3 5e 21			jp macro_next 
2c98				endm 
# End of macro NEXTW
2c98			 
2c98			;.luno:    db "Word not found",0 
2c98			 
2c98			 
2c98			 
2c98			 
2c98			 
2c98			;		push hl   ; save pointer to start of uword def string 
2c98			; 
2c98			;; look for FORTH_EOL_LINE 
2c98			;		ld a, FORTH_END_BUFFER 
2c98			;		call strlent 
2c98			; 
2c98			;		inc hl		 ; space for coln def 
2c98			;		inc hl 
2c98			;		inc hl          ; space for terms 
2c98			;		inc hl 
2c98			; 
2c98			;		ld a, 20   ; TODO get actual length 
2c98			;		call addatohl    ; include a random amount of room for the uword name 
2c98			; 
2c98			;		 
2c98			;	if DEBUG_FORTH_WORDS 
2c98			;		DMARK "Lt1" 
2c98			;		CALLMONITOR 
2c98			;	endif 
2c98			;		 
2c98			; 
2c98			;; malloc space for the string because we cant change it 
2c98			; 
2c98			;		call malloc 
2c98			;	if DEBUG_FORTH_MALLOC_GUARD 
2c98			;		push af 
2c98			;		call ishlzero 
2c98			;		pop af 
2c98			;		 
2c98			;		call z,malloc_error 
2c98			;	endif 
2c98			; 
2c98			;	if DEBUG_FORTH_WORDS 
2c98			;		DMARK "Lt2" 
2c98			;		CALLMONITOR 
2c98			;	endif 
2c98			;		pop de 
2c98			;		push hl    ; push the malloc to release later 
2c98			;		push hl   ;  push back a copy for the later stack push 
2c98			;		 
2c98			;; copy the string swapping out the zero terms for spaces 
2c98			; 
2c98			;		; de has our source 
2c98			;		; hl has our dest 
2c98			; 
2c98			;; add the coln def 
2c98			; 
2c98			;		ld a, ':' 
2c98			;		ld (hl), a 
2c98			;		inc hl 
2c98			;		ld a, ' ' 
2c98			;		ld (hl), a 
2c98			;		inc hl 
2c98			; 
2c98			;; add the uname word 
2c98			;		push de   ; save our string for now 
2c98			;		ex de, hl 
2c98			; 
2c98			;		FORTH_DSP_VALUE 
2c98			;		;v5 FORTH_DSP_VALUE 
2c98			; 
2c98			;		inc hl   ; skip type but we know by now this is OK 
2c98			; 
2c98			;.luword:	ld a,(hl) 
2c98			;		cp 0 
2c98			;		jr z, .luword2 
2c98			;		ld (de), a 
2c98			;		inc de 
2c98			;		inc hl 
2c98			;		jr .luword 
2c98			; 
2c98			;.luword2:	ld a, ' ' 
2c98			;		ld (de), a 
2c98			;;		inc hl 
2c98			;;		inc de 
2c98			;;		ld (de), a 
2c98			;;		inc hl 
2c98			;		inc de 
2c98			; 
2c98			;		ex de, hl 
2c98			;		pop de 
2c98			;		 
2c98			;		 
2c98			; 
2c98			;; detoken that string and copy it 
2c98			; 
2c98			;	if DEBUG_FORTH_WORDS 
2c98			;		DMARK "Lt2" 
2c98			;		CALLMONITOR 
2c98			;	endif 
2c98			;.ldetok:	ld a, (de) 
2c98			;		cp FORTH_END_BUFFER 
2c98			;		jr z, .ldetokend 
2c98			;		; swap out any zero term for space 
2c98			;		cp 0 
2c98			;		jr nz, .ldetoknext 
2c98			;		ld a, ' ' 
2c98			; 
2c98			;	if DEBUG_FORTH_WORDS 
2c98			;		DMARK "LtS" 
2c98			;		CALLMONITOR 
2c98			;	endif 
2c98			;.ldetoknext:	ld (hl), a 
2c98			;		inc de 
2c98			;		inc hl 
2c98			;		jr .ldetok 
2c98			; 
2c98			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2c98			;		ld (hl), a  
2c98			; 
2c98			;; free that temp malloc 
2c98			; 
2c98			;		pop hl    
2c98			; 
2c98			;	if DEBUG_FORTH_WORDS 
2c98			;		DMARK "Lt4" 
2c98			;		CALLMONITOR 
2c98			;	endif 
2c98			;		call forth_apushstrhl 
2c98			; 
2c98			;		; get rid of temp malloc area 
2c98			; 
2c98			;		pop hl 
2c98			;		call free 
2c98			; 
2c98			;		jr .ludone 
2c98			; 
2c98			;.lnuword:	pop hl 
2c98			;		call forth_tok_next 
2c98			;		jp .ldouscan  
2c98			; 
2c98			;.ludone:		 pop hl 
2c98			; 
2c98					NEXTW 
2c98 c3 5e 21			jp macro_next 
2c9b				endm 
# End of macro NEXTW
2c9b			 
2c9b			.FORGET: 
2c9b				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2c9b 5d				db WORD_SYS_CORE+73             
2c9c 14 2d			dw .NOP            
2c9e 07				db 6 + 1 
2c9f .. 00			db "FORGET",0              
2ca6				endm 
# End of macro CWHEAD
2ca6			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2ca6			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2ca6			; | |  
2ca6			; | | e.g. "MORE" forget 
2ca6					if DEBUG_FORTH_WORDS_KEY 
2ca6						DMARK "FRG" 
2ca6 f5				push af  
2ca7 3a bb 2c			ld a, (.dmark)  
2caa 32 6b ee			ld (debug_mark),a  
2cad 3a bc 2c			ld a, (.dmark+1)  
2cb0 32 6c ee			ld (debug_mark+1),a  
2cb3 3a bd 2c			ld a, (.dmark+2)  
2cb6 32 6d ee			ld (debug_mark+2),a  
2cb9 18 03			jr .pastdmark  
2cbb ..			.dmark: db "FRG"  
2cbe f1			.pastdmark: pop af  
2cbf			endm  
# End of macro DMARK
2cbf						CALLMONITOR 
2cbf cd 6f ee			call debug_vector  
2cc2				endm  
# End of macro CALLMONITOR
2cc2					endif 
2cc2			 
2cc2				; find uword 
2cc2			        ; update start of word with "_" 
2cc2				; replace uword with deleted flag 
2cc2			 
2cc2			 
2cc2			;	if DEBUG_FORTH_WORDS 
2cc2			;		DMARK "FOG" 
2cc2			;		CALLMONITOR 
2cc2			;	endif 
2cc2			 
2cc2			 
2cc2					; Get ptr to the word we need to look up 
2cc2			 
2cc2					FORTH_DSP_VALUEHL 
2cc2 cd a8 1f			call macro_dsp_valuehl 
2cc5				endm 
# End of macro FORTH_DSP_VALUEHL
2cc5					;v5 FORTH_DSP_VALUE 
2cc5				; TODO type check 
2cc5			;		inc hl    ; Skip type check  
2cc5 e5					push hl 
2cc6 c1					pop bc 
2cc7			;		ex de, hl    ; put into DE 
2cc7			 
2cc7			 
2cc7 21 a6 67				ld hl, baseram 
2cca					;ld hl, baseusermem 
2cca			 
2cca				; skip dict stub 
2cca			;	call forth_tok_next 
2cca e5			push hl   ; sacreifical push 
2ccb			 
2ccb			.fldouscanm: 
2ccb e1				pop hl 
2ccc			.fldouscan: 
2ccc			;	if DEBUG_FORTH_WORDS 
2ccc			;		DMARK "LSs" 
2ccc			;		CALLMONITOR 
2ccc			;	endif 
2ccc				; skip dict stub 
2ccc cd af 22				call forth_tok_next 
2ccf			 
2ccf			 
2ccf			; while we have words to look for 
2ccf			 
2ccf 7e				ld a, (hl)      
2cd0			;	if DEBUG_FORTH_WORDS 
2cd0			;		DMARK "LSk" 
2cd0			;		CALLMONITOR 
2cd0			;	endif 
2cd0 fe 00				cp WORD_SYS_END 
2cd2 ca 0e 2d				jp z, .flunotfound 
2cd5 fe 01				cp WORD_SYS_UWORD 
2cd7 c2 cc 2c				jp nz, .fldouscan 
2cda			 
2cda			;	if DEBUG_FORTH_WORDS 
2cda			;		DMARK "LSu" 
2cda			;		CALLMONITOR 
2cda			;	endif 
2cda			 
2cda					; found a uword but is it the one we want... 
2cda			 
2cda c5					push bc     ; uword to find is on bc 
2cdb d1					pop de 
2cdc			 
2cdc e5					push hl  ; to save the ptr 
2cdd			 
2cdd					; skip opcode 
2cdd 23					inc hl  
2cde					; skip next ptr 
2cde 23					inc hl  
2cdf 23					inc hl 
2ce0					; skip len 
2ce0 23					inc hl 
2ce1			 
2ce1			;	if DEBUG_FORTH_WORDS 
2ce1			;		DMARK "LSc" 
2ce1			;		CALLMONITOR 
2ce1			;	endif 
2ce1 cd db 13				call strcmp 
2ce4 c2 cb 2c				jp nz, .fldouscanm 
2ce7			; 
2ce7			; 
2ce7			;; while we have words to look for 
2ce7			; 
2ce7			;.fdouscan:	ld a, (hl)      
2ce7			;	if DEBUG_FORTH_WORDS 
2ce7			;		DMARK "LSs" 
2ce7			;		CALLMONITOR 
2ce7			;	endif 
2ce7			;		cp WORD_SYS_END 
2ce7			;		jp z, .fudone 
2ce7			;		cp WORD_SYS_UWORD 
2ce7			;		jp nz, .fnuword 
2ce7			; 
2ce7			;	if DEBUG_FORTH_WORDS 
2ce7			;		DMARK "FGu" 
2ce7			;		CALLMONITOR 
2ce7			;	endif 
2ce7			; 
2ce7			;		; found a uword but is it the one we want... 
2ce7			; 
2ce7			; 
2ce7			;	        pop de   ; get back the dsp name 
2ce7			;		push de 
2ce7			; 
2ce7			;		push hl  ; to save the ptr 
2ce7			; 
2ce7			;		; skip opcode 
2ce7			;		inc hl  
2ce7			;		; skip next ptr 
2ce7			;		inc hl  
2ce7			;		inc hl 
2ce7			;		; skip len 
2ce7			;		inc hl 
2ce7			; 
2ce7			;	if DEBUG_FORTH_WORDS 
2ce7			;		DMARK "FGc" 
2ce7			;		CALLMONITOR 
2ce7			;	endif 
2ce7			;		call strcmp 
2ce7			;		jp nz, .fnuword 
2ce7			 
2ce7			 
2ce7 e1			pop hl 
2ce8			 
2ce8				 
2ce8				if DEBUG_FORTH_WORDS 
2ce8					DMARK "FGm" 
2ce8 f5				push af  
2ce9 3a fd 2c			ld a, (.dmark)  
2cec 32 6b ee			ld (debug_mark),a  
2cef 3a fe 2c			ld a, (.dmark+1)  
2cf2 32 6c ee			ld (debug_mark+1),a  
2cf5 3a ff 2c			ld a, (.dmark+2)  
2cf8 32 6d ee			ld (debug_mark+2),a  
2cfb 18 03			jr .pastdmark  
2cfd ..			.dmark: db "FGm"  
2d00 f1			.pastdmark: pop af  
2d01			endm  
# End of macro DMARK
2d01					CALLMONITOR 
2d01 cd 6f ee			call debug_vector  
2d04				endm  
# End of macro CALLMONITOR
2d04				endif 
2d04			 
2d04			 
2d04			 
2d04					; we have a uword so push its name to the stack 
2d04			 
2d04			;	   	push hl  ; save so we can move to next dict block 
2d04			;pop hl 
2d04			 
2d04					; update opcode to deleted 
2d04 3e 03				ld a, WORD_SYS_DELETED 
2d06 77					ld (hl), a 
2d07			 
2d07 23					inc hl  
2d08					; skip next ptr 
2d08 23					inc hl  
2d09 23					inc hl 
2d0a					; skip len 
2d0a 23					inc hl 
2d0b			 
2d0b					; TODO change parser to skip deleted words but for now mark it out 
2d0b 3e 5f				ld a, "_" 
2d0d 77					ld  (hl),a 
2d0e			 
2d0e			;		jr .fudone 
2d0e			; 
2d0e			;.fnuword:	pop hl 
2d0e			;		call forth_tok_next 
2d0e			;		jp .fdouscan  
2d0e			 
2d0e			.flunotfound:		  
2d0e			 
2d0e			 
2d0e					 
2d0e					FORTH_DSP_POP 
2d0e cd 60 20			call macro_forth_dsp_pop 
2d11				endm 
# End of macro FORTH_DSP_POP
2d11			;		ld hl, .luno 
2d11			;.fudone:		 pop hl 
2d11					NEXTW 
2d11 c3 5e 21			jp macro_next 
2d14				endm 
# End of macro NEXTW
2d14			.NOP: 
2d14				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2d14 61				db WORD_SYS_CORE+77             
2d15 3b 2d			dw .COMO            
2d17 04				db 3 + 1 
2d18 .. 00			db "NOP",0              
2d1c				endm 
# End of macro CWHEAD
2d1c			; | NOP (  --  ) Do nothing | DONE 
2d1c					if DEBUG_FORTH_WORDS_KEY 
2d1c						DMARK "NOP" 
2d1c f5				push af  
2d1d 3a 31 2d			ld a, (.dmark)  
2d20 32 6b ee			ld (debug_mark),a  
2d23 3a 32 2d			ld a, (.dmark+1)  
2d26 32 6c ee			ld (debug_mark+1),a  
2d29 3a 33 2d			ld a, (.dmark+2)  
2d2c 32 6d ee			ld (debug_mark+2),a  
2d2f 18 03			jr .pastdmark  
2d31 ..			.dmark: db "NOP"  
2d34 f1			.pastdmark: pop af  
2d35			endm  
# End of macro DMARK
2d35						CALLMONITOR 
2d35 cd 6f ee			call debug_vector  
2d38				endm  
# End of macro CALLMONITOR
2d38					endif 
2d38				       NEXTW 
2d38 c3 5e 21			jp macro_next 
2d3b				endm 
# End of macro NEXTW
2d3b			.COMO: 
2d3b				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2d3b 6e				db WORD_SYS_CORE+90             
2d3c 8d 2d			dw .COMC            
2d3e 02				db 1 + 1 
2d3f .. 00			db "(",0              
2d41				endm 
# End of macro CWHEAD
2d41			; | ( ( -- )  Start of comment | DONE 
2d41			 
2d41			 
2d41 2a c2 e5				ld hl, ( os_tok_ptr) 
2d44 11 88 2d			ld de, .closepar 
2d47					 
2d47					if DEBUG_FORTH_WORDS 
2d47						DMARK ").." 
2d47 f5				push af  
2d48 3a 5c 2d			ld a, (.dmark)  
2d4b 32 6b ee			ld (debug_mark),a  
2d4e 3a 5d 2d			ld a, (.dmark+1)  
2d51 32 6c ee			ld (debug_mark+1),a  
2d54 3a 5e 2d			ld a, (.dmark+2)  
2d57 32 6d ee			ld (debug_mark+2),a  
2d5a 18 03			jr .pastdmark  
2d5c ..			.dmark: db ").."  
2d5f f1			.pastdmark: pop af  
2d60			endm  
# End of macro DMARK
2d60						CALLMONITOR 
2d60 cd 6f ee			call debug_vector  
2d63				endm  
# End of macro CALLMONITOR
2d63					endif 
2d63 cd 79 22			call findnexttok  
2d66			 
2d66					if DEBUG_FORTH_WORDS 
2d66						DMARK "IF5" 
2d66 f5				push af  
2d67 3a 7b 2d			ld a, (.dmark)  
2d6a 32 6b ee			ld (debug_mark),a  
2d6d 3a 7c 2d			ld a, (.dmark+1)  
2d70 32 6c ee			ld (debug_mark+1),a  
2d73 3a 7d 2d			ld a, (.dmark+2)  
2d76 32 6d ee			ld (debug_mark+2),a  
2d79 18 03			jr .pastdmark  
2d7b ..			.dmark: db "IF5"  
2d7e f1			.pastdmark: pop af  
2d7f			endm  
# End of macro DMARK
2d7f						CALLMONITOR 
2d7f cd 6f ee			call debug_vector  
2d82				endm  
# End of macro CALLMONITOR
2d82					endif 
2d82				; replace below with ) exec using tok_ptr 
2d82 22 c2 e5			ld (os_tok_ptr), hl 
2d85 c3 ef 21			jp exec1 
2d88			 
2d88 .. 00			.closepar:   db ")",0 
2d8a			 
2d8a				       NEXTW 
2d8a c3 5e 21			jp macro_next 
2d8d				endm 
# End of macro NEXTW
2d8d			.COMC: 
2d8d				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2d8d 6f				db WORD_SYS_CORE+91             
2d8e 96 2d			dw .SCRATCH            
2d90 02				db 1 + 1 
2d91 .. 00			db ")",0              
2d93				endm 
# End of macro CWHEAD
2d93			; | ) ( -- )  End of comment |  DONE  
2d93				       NEXTW 
2d93 c3 5e 21			jp macro_next 
2d96				endm 
# End of macro NEXTW
2d96			 
2d96			.SCRATCH: 
2d96				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2d96 6f				db WORD_SYS_CORE+91             
2d97 d1 2d			dw .INC            
2d99 08				db 7 + 1 
2d9a .. 00			db "SCRATCH",0              
2da2				endm 
# End of macro CWHEAD
2da2			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2da2			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2da2			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2da2			; | |  
2da2			; | | e.g.    : score $00 scratch ; 
2da2			; | |  
2da2			; | | $00 score ! 
2da2			; | | $01 score +! 
2da2			; | |  
2da2			; | | e.g.   : varword $0a scratch ;  
2da2			; | | 
2da2			; | | $8000 varword ! 
2da2					if DEBUG_FORTH_WORDS_KEY 
2da2						DMARK "SCR" 
2da2 f5				push af  
2da3 3a b7 2d			ld a, (.dmark)  
2da6 32 6b ee			ld (debug_mark),a  
2da9 3a b8 2d			ld a, (.dmark+1)  
2dac 32 6c ee			ld (debug_mark+1),a  
2daf 3a b9 2d			ld a, (.dmark+2)  
2db2 32 6d ee			ld (debug_mark+2),a  
2db5 18 03			jr .pastdmark  
2db7 ..			.dmark: db "SCR"  
2dba f1			.pastdmark: pop af  
2dbb			endm  
# End of macro DMARK
2dbb						CALLMONITOR 
2dbb cd 6f ee			call debug_vector  
2dbe				endm  
# End of macro CALLMONITOR
2dbe					endif 
2dbe			 
2dbe					FORTH_DSP_VALUEHL 
2dbe cd a8 1f			call macro_dsp_valuehl 
2dc1				endm 
# End of macro FORTH_DSP_VALUEHL
2dc1				 
2dc1					FORTH_DSP_POP 
2dc1 cd 60 20			call macro_forth_dsp_pop 
2dc4				endm 
# End of macro FORTH_DSP_POP
2dc4			 
2dc4 7d					ld a, l 
2dc5 21 e6 e7				ld hl, os_var_array 
2dc8 cd e6 0d				call addatohl 
2dcb			 
2dcb cd b1 1d				call forth_push_numhl 
2dce			 
2dce				       NEXTW 
2dce c3 5e 21			jp macro_next 
2dd1				endm 
# End of macro NEXTW
2dd1			 
2dd1			.INC: 
2dd1				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2dd1 6f				db WORD_SYS_CORE+91             
2dd2 27 2e			dw .DEC            
2dd4 03				db 2 + 1 
2dd5 .. 00			db "+!",0              
2dd8				endm 
# End of macro CWHEAD
2dd8			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2dd8					if DEBUG_FORTH_WORDS_KEY 
2dd8						DMARK "+s_" 
2dd8 f5				push af  
2dd9 3a ed 2d			ld a, (.dmark)  
2ddc 32 6b ee			ld (debug_mark),a  
2ddf 3a ee 2d			ld a, (.dmark+1)  
2de2 32 6c ee			ld (debug_mark+1),a  
2de5 3a ef 2d			ld a, (.dmark+2)  
2de8 32 6d ee			ld (debug_mark+2),a  
2deb 18 03			jr .pastdmark  
2ded ..			.dmark: db "+s_"  
2df0 f1			.pastdmark: pop af  
2df1			endm  
# End of macro DMARK
2df1						CALLMONITOR 
2df1 cd 6f ee			call debug_vector  
2df4				endm  
# End of macro CALLMONITOR
2df4					endif 
2df4			 
2df4					FORTH_DSP_VALUEHL 
2df4 cd a8 1f			call macro_dsp_valuehl 
2df7				endm 
# End of macro FORTH_DSP_VALUEHL
2df7			 
2df7 e5					push hl   ; save address 
2df8			 
2df8					FORTH_DSP_POP 
2df8 cd 60 20			call macro_forth_dsp_pop 
2dfb				endm 
# End of macro FORTH_DSP_POP
2dfb			 
2dfb					FORTH_DSP_VALUEHL 
2dfb cd a8 1f			call macro_dsp_valuehl 
2dfe				endm 
# End of macro FORTH_DSP_VALUEHL
2dfe			 
2dfe e5					push hl 
2dff					FORTH_DSP_POP 
2dff cd 60 20			call macro_forth_dsp_pop 
2e02				endm 
# End of macro FORTH_DSP_POP
2e02 e1					pop hl 
2e03			 
2e03					; hl contains value to add to byte at a 
2e03				 
2e03 eb					ex de, hl 
2e04			 
2e04 e1					pop hl 
2e05			 
2e05					if DEBUG_FORTH_WORDS 
2e05						DMARK "INC" 
2e05 f5				push af  
2e06 3a 1a 2e			ld a, (.dmark)  
2e09 32 6b ee			ld (debug_mark),a  
2e0c 3a 1b 2e			ld a, (.dmark+1)  
2e0f 32 6c ee			ld (debug_mark+1),a  
2e12 3a 1c 2e			ld a, (.dmark+2)  
2e15 32 6d ee			ld (debug_mark+2),a  
2e18 18 03			jr .pastdmark  
2e1a ..			.dmark: db "INC"  
2e1d f1			.pastdmark: pop af  
2e1e			endm  
# End of macro DMARK
2e1e						CALLMONITOR 
2e1e cd 6f ee			call debug_vector  
2e21				endm  
# End of macro CALLMONITOR
2e21					endif 
2e21			 
2e21 7e					ld a,(hl) 
2e22 83					add e 
2e23 77					ld (hl),a 
2e24			 
2e24			 
2e24			 
2e24				       NEXTW 
2e24 c3 5e 21			jp macro_next 
2e27				endm 
# End of macro NEXTW
2e27			 
2e27			.DEC: 
2e27				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2e27 6f				db WORD_SYS_CORE+91             
2e28 7b 2e			dw .INC2            
2e2a 03				db 2 + 1 
2e2b .. 00			db "-!",0              
2e2e				endm 
# End of macro CWHEAD
2e2e			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2e2e					if DEBUG_FORTH_WORDS_KEY 
2e2e						DMARK "-s_" 
2e2e f5				push af  
2e2f 3a 43 2e			ld a, (.dmark)  
2e32 32 6b ee			ld (debug_mark),a  
2e35 3a 44 2e			ld a, (.dmark+1)  
2e38 32 6c ee			ld (debug_mark+1),a  
2e3b 3a 45 2e			ld a, (.dmark+2)  
2e3e 32 6d ee			ld (debug_mark+2),a  
2e41 18 03			jr .pastdmark  
2e43 ..			.dmark: db "-s_"  
2e46 f1			.pastdmark: pop af  
2e47			endm  
# End of macro DMARK
2e47						CALLMONITOR 
2e47 cd 6f ee			call debug_vector  
2e4a				endm  
# End of macro CALLMONITOR
2e4a					endif 
2e4a			 
2e4a					FORTH_DSP_VALUEHL 
2e4a cd a8 1f			call macro_dsp_valuehl 
2e4d				endm 
# End of macro FORTH_DSP_VALUEHL
2e4d			 
2e4d e5					push hl   ; save address 
2e4e			 
2e4e					FORTH_DSP_POP 
2e4e cd 60 20			call macro_forth_dsp_pop 
2e51				endm 
# End of macro FORTH_DSP_POP
2e51			 
2e51					FORTH_DSP_VALUEHL 
2e51 cd a8 1f			call macro_dsp_valuehl 
2e54				endm 
# End of macro FORTH_DSP_VALUEHL
2e54			 
2e54					; hl contains value to add to byte at a 
2e54				 
2e54 eb					ex de, hl 
2e55			 
2e55 e1					pop hl 
2e56			 
2e56					if DEBUG_FORTH_WORDS 
2e56						DMARK "DEC" 
2e56 f5				push af  
2e57 3a 6b 2e			ld a, (.dmark)  
2e5a 32 6b ee			ld (debug_mark),a  
2e5d 3a 6c 2e			ld a, (.dmark+1)  
2e60 32 6c ee			ld (debug_mark+1),a  
2e63 3a 6d 2e			ld a, (.dmark+2)  
2e66 32 6d ee			ld (debug_mark+2),a  
2e69 18 03			jr .pastdmark  
2e6b ..			.dmark: db "DEC"  
2e6e f1			.pastdmark: pop af  
2e6f			endm  
# End of macro DMARK
2e6f						CALLMONITOR 
2e6f cd 6f ee			call debug_vector  
2e72				endm  
# End of macro CALLMONITOR
2e72					endif 
2e72			 
2e72 7e					ld a,(hl) 
2e73 93					sub e 
2e74 77					ld (hl),a 
2e75			 
2e75			 
2e75					FORTH_DSP_POP 
2e75 cd 60 20			call macro_forth_dsp_pop 
2e78				endm 
# End of macro FORTH_DSP_POP
2e78			 
2e78				       NEXTW 
2e78 c3 5e 21			jp macro_next 
2e7b				endm 
# End of macro NEXTW
2e7b			 
2e7b			.INC2: 
2e7b				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2e7b 6f				db WORD_SYS_CORE+91             
2e7c 28 2f			dw .DEC2            
2e7e 04				db 3 + 1 
2e7f .. 00			db "+2!",0              
2e83				endm 
# End of macro CWHEAD
2e83			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2e83			 
2e83					if DEBUG_FORTH_WORDS_KEY 
2e83						DMARK "+2s" 
2e83 f5				push af  
2e84 3a 98 2e			ld a, (.dmark)  
2e87 32 6b ee			ld (debug_mark),a  
2e8a 3a 99 2e			ld a, (.dmark+1)  
2e8d 32 6c ee			ld (debug_mark+1),a  
2e90 3a 9a 2e			ld a, (.dmark+2)  
2e93 32 6d ee			ld (debug_mark+2),a  
2e96 18 03			jr .pastdmark  
2e98 ..			.dmark: db "+2s"  
2e9b f1			.pastdmark: pop af  
2e9c			endm  
# End of macro DMARK
2e9c						CALLMONITOR 
2e9c cd 6f ee			call debug_vector  
2e9f				endm  
# End of macro CALLMONITOR
2e9f					endif 
2e9f			 
2e9f					; Address 
2e9f			 
2e9f					FORTH_DSP_VALUEHL 
2e9f cd a8 1f			call macro_dsp_valuehl 
2ea2				endm 
# End of macro FORTH_DSP_VALUEHL
2ea2			 
2ea2 e5					push hl    ; save address 
2ea3			 
2ea3					; load content into de 
2ea3			 
2ea3 5e					ld e,(hl) 
2ea4 23					inc hl 
2ea5 56					ld d, (hl) 
2ea6			 
2ea6					if DEBUG_FORTH_WORDS 
2ea6						DMARK "+2a" 
2ea6 f5				push af  
2ea7 3a bb 2e			ld a, (.dmark)  
2eaa 32 6b ee			ld (debug_mark),a  
2ead 3a bc 2e			ld a, (.dmark+1)  
2eb0 32 6c ee			ld (debug_mark+1),a  
2eb3 3a bd 2e			ld a, (.dmark+2)  
2eb6 32 6d ee			ld (debug_mark+2),a  
2eb9 18 03			jr .pastdmark  
2ebb ..			.dmark: db "+2a"  
2ebe f1			.pastdmark: pop af  
2ebf			endm  
# End of macro DMARK
2ebf						CALLMONITOR 
2ebf cd 6f ee			call debug_vector  
2ec2				endm  
# End of macro CALLMONITOR
2ec2					endif 
2ec2			 
2ec2					FORTH_DSP_POP 
2ec2 cd 60 20			call macro_forth_dsp_pop 
2ec5				endm 
# End of macro FORTH_DSP_POP
2ec5			 
2ec5					; Get value to add 
2ec5			 
2ec5					FORTH_DSP_VALUE 
2ec5 cd 91 1f			call macro_forth_dsp_value 
2ec8				endm 
# End of macro FORTH_DSP_VALUE
2ec8			 
2ec8					if DEBUG_FORTH_WORDS 
2ec8						DMARK "+2v" 
2ec8 f5				push af  
2ec9 3a dd 2e			ld a, (.dmark)  
2ecc 32 6b ee			ld (debug_mark),a  
2ecf 3a de 2e			ld a, (.dmark+1)  
2ed2 32 6c ee			ld (debug_mark+1),a  
2ed5 3a df 2e			ld a, (.dmark+2)  
2ed8 32 6d ee			ld (debug_mark+2),a  
2edb 18 03			jr .pastdmark  
2edd ..			.dmark: db "+2v"  
2ee0 f1			.pastdmark: pop af  
2ee1			endm  
# End of macro DMARK
2ee1						CALLMONITOR 
2ee1 cd 6f ee			call debug_vector  
2ee4				endm  
# End of macro CALLMONITOR
2ee4					endif 
2ee4			 
2ee4 19					add hl, de 
2ee5			 
2ee5					if DEBUG_FORTH_WORDS 
2ee5						DMARK "+2+" 
2ee5 f5				push af  
2ee6 3a fa 2e			ld a, (.dmark)  
2ee9 32 6b ee			ld (debug_mark),a  
2eec 3a fb 2e			ld a, (.dmark+1)  
2eef 32 6c ee			ld (debug_mark+1),a  
2ef2 3a fc 2e			ld a, (.dmark+2)  
2ef5 32 6d ee			ld (debug_mark+2),a  
2ef8 18 03			jr .pastdmark  
2efa ..			.dmark: db "+2+"  
2efd f1			.pastdmark: pop af  
2efe			endm  
# End of macro DMARK
2efe						CALLMONITOR 
2efe cd 6f ee			call debug_vector  
2f01				endm  
# End of macro CALLMONITOR
2f01					endif 
2f01			 
2f01					; move result to de 
2f01			 
2f01 eb					ex de, hl 
2f02			 
2f02					; Address 
2f02			 
2f02 e1					pop hl 
2f03			 
2f03					; save it back 
2f03			 
2f03 73					ld (hl), e 
2f04 23					inc hl 
2f05 72					ld (hl), d 
2f06			 
2f06					if DEBUG_FORTH_WORDS 
2f06						DMARK "+2e" 
2f06 f5				push af  
2f07 3a 1b 2f			ld a, (.dmark)  
2f0a 32 6b ee			ld (debug_mark),a  
2f0d 3a 1c 2f			ld a, (.dmark+1)  
2f10 32 6c ee			ld (debug_mark+1),a  
2f13 3a 1d 2f			ld a, (.dmark+2)  
2f16 32 6d ee			ld (debug_mark+2),a  
2f19 18 03			jr .pastdmark  
2f1b ..			.dmark: db "+2e"  
2f1e f1			.pastdmark: pop af  
2f1f			endm  
# End of macro DMARK
2f1f						CALLMONITOR 
2f1f cd 6f ee			call debug_vector  
2f22				endm  
# End of macro CALLMONITOR
2f22					endif 
2f22			 
2f22			 
2f22			 
2f22					FORTH_DSP_POP 
2f22 cd 60 20			call macro_forth_dsp_pop 
2f25				endm 
# End of macro FORTH_DSP_POP
2f25			 
2f25			 
2f25				       NEXTW 
2f25 c3 5e 21			jp macro_next 
2f28				endm 
# End of macro NEXTW
2f28			 
2f28			.DEC2: 
2f28				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2f28 6f				db WORD_SYS_CORE+91             
2f29 d7 2f			dw .GET2            
2f2b 04				db 3 + 1 
2f2c .. 00			db "-2!",0              
2f30				endm 
# End of macro CWHEAD
2f30			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2f30			 
2f30			 
2f30					if DEBUG_FORTH_WORDS_KEY 
2f30						DMARK "-2s" 
2f30 f5				push af  
2f31 3a 45 2f			ld a, (.dmark)  
2f34 32 6b ee			ld (debug_mark),a  
2f37 3a 46 2f			ld a, (.dmark+1)  
2f3a 32 6c ee			ld (debug_mark+1),a  
2f3d 3a 47 2f			ld a, (.dmark+2)  
2f40 32 6d ee			ld (debug_mark+2),a  
2f43 18 03			jr .pastdmark  
2f45 ..			.dmark: db "-2s"  
2f48 f1			.pastdmark: pop af  
2f49			endm  
# End of macro DMARK
2f49						CALLMONITOR 
2f49 cd 6f ee			call debug_vector  
2f4c				endm  
# End of macro CALLMONITOR
2f4c					endif 
2f4c			 
2f4c					; Address 
2f4c			 
2f4c					FORTH_DSP_VALUEHL 
2f4c cd a8 1f			call macro_dsp_valuehl 
2f4f				endm 
# End of macro FORTH_DSP_VALUEHL
2f4f			 
2f4f e5					push hl    ; save address 
2f50			 
2f50					; load content into de 
2f50			 
2f50 5e					ld e,(hl) 
2f51 23					inc hl 
2f52 56					ld d, (hl) 
2f53			 
2f53					if DEBUG_FORTH_WORDS 
2f53						DMARK "-2a" 
2f53 f5				push af  
2f54 3a 68 2f			ld a, (.dmark)  
2f57 32 6b ee			ld (debug_mark),a  
2f5a 3a 69 2f			ld a, (.dmark+1)  
2f5d 32 6c ee			ld (debug_mark+1),a  
2f60 3a 6a 2f			ld a, (.dmark+2)  
2f63 32 6d ee			ld (debug_mark+2),a  
2f66 18 03			jr .pastdmark  
2f68 ..			.dmark: db "-2a"  
2f6b f1			.pastdmark: pop af  
2f6c			endm  
# End of macro DMARK
2f6c						CALLMONITOR 
2f6c cd 6f ee			call debug_vector  
2f6f				endm  
# End of macro CALLMONITOR
2f6f					endif 
2f6f			 
2f6f					FORTH_DSP_POP 
2f6f cd 60 20			call macro_forth_dsp_pop 
2f72				endm 
# End of macro FORTH_DSP_POP
2f72			 
2f72					; Get value to remove 
2f72			 
2f72					FORTH_DSP_VALUE 
2f72 cd 91 1f			call macro_forth_dsp_value 
2f75				endm 
# End of macro FORTH_DSP_VALUE
2f75			 
2f75					if DEBUG_FORTH_WORDS 
2f75						DMARK "-2v" 
2f75 f5				push af  
2f76 3a 8a 2f			ld a, (.dmark)  
2f79 32 6b ee			ld (debug_mark),a  
2f7c 3a 8b 2f			ld a, (.dmark+1)  
2f7f 32 6c ee			ld (debug_mark+1),a  
2f82 3a 8c 2f			ld a, (.dmark+2)  
2f85 32 6d ee			ld (debug_mark+2),a  
2f88 18 03			jr .pastdmark  
2f8a ..			.dmark: db "-2v"  
2f8d f1			.pastdmark: pop af  
2f8e			endm  
# End of macro DMARK
2f8e						CALLMONITOR 
2f8e cd 6f ee			call debug_vector  
2f91				endm  
# End of macro CALLMONITOR
2f91					endif 
2f91			 
2f91 eb					ex de, hl 
2f92 ed 52				sbc hl, de 
2f94			 
2f94					if DEBUG_FORTH_WORDS 
2f94						DMARK "-2d" 
2f94 f5				push af  
2f95 3a a9 2f			ld a, (.dmark)  
2f98 32 6b ee			ld (debug_mark),a  
2f9b 3a aa 2f			ld a, (.dmark+1)  
2f9e 32 6c ee			ld (debug_mark+1),a  
2fa1 3a ab 2f			ld a, (.dmark+2)  
2fa4 32 6d ee			ld (debug_mark+2),a  
2fa7 18 03			jr .pastdmark  
2fa9 ..			.dmark: db "-2d"  
2fac f1			.pastdmark: pop af  
2fad			endm  
# End of macro DMARK
2fad						CALLMONITOR 
2fad cd 6f ee			call debug_vector  
2fb0				endm  
# End of macro CALLMONITOR
2fb0					endif 
2fb0			 
2fb0					; move result to de 
2fb0			 
2fb0 eb					ex de, hl 
2fb1			 
2fb1					; Address 
2fb1			 
2fb1 e1					pop hl 
2fb2			 
2fb2					; save it back 
2fb2			 
2fb2 73					ld (hl), e 
2fb3 23					inc hl 
2fb4 72					ld (hl), d 
2fb5			 
2fb5					if DEBUG_FORTH_WORDS 
2fb5						DMARK "-2e" 
2fb5 f5				push af  
2fb6 3a ca 2f			ld a, (.dmark)  
2fb9 32 6b ee			ld (debug_mark),a  
2fbc 3a cb 2f			ld a, (.dmark+1)  
2fbf 32 6c ee			ld (debug_mark+1),a  
2fc2 3a cc 2f			ld a, (.dmark+2)  
2fc5 32 6d ee			ld (debug_mark+2),a  
2fc8 18 03			jr .pastdmark  
2fca ..			.dmark: db "-2e"  
2fcd f1			.pastdmark: pop af  
2fce			endm  
# End of macro DMARK
2fce						CALLMONITOR 
2fce cd 6f ee			call debug_vector  
2fd1				endm  
# End of macro CALLMONITOR
2fd1					endif 
2fd1			 
2fd1			 
2fd1					FORTH_DSP_POP 
2fd1 cd 60 20			call macro_forth_dsp_pop 
2fd4				endm 
# End of macro FORTH_DSP_POP
2fd4			 
2fd4			 
2fd4			 
2fd4				       NEXTW 
2fd4 c3 5e 21			jp macro_next 
2fd7				endm 
# End of macro NEXTW
2fd7			.GET2: 
2fd7				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2fd7 6f				db WORD_SYS_CORE+91             
2fd8 0c 30			dw .BANG2            
2fda 03				db 2 + 1 
2fdb .. 00			db "2@",0              
2fde				endm 
# End of macro CWHEAD
2fde			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2fde					if DEBUG_FORTH_WORDS_KEY 
2fde						DMARK "2A_" 
2fde f5				push af  
2fdf 3a f3 2f			ld a, (.dmark)  
2fe2 32 6b ee			ld (debug_mark),a  
2fe5 3a f4 2f			ld a, (.dmark+1)  
2fe8 32 6c ee			ld (debug_mark+1),a  
2feb 3a f5 2f			ld a, (.dmark+2)  
2fee 32 6d ee			ld (debug_mark+2),a  
2ff1 18 03			jr .pastdmark  
2ff3 ..			.dmark: db "2A_"  
2ff6 f1			.pastdmark: pop af  
2ff7			endm  
# End of macro DMARK
2ff7						CALLMONITOR 
2ff7 cd 6f ee			call debug_vector  
2ffa				endm  
# End of macro CALLMONITOR
2ffa					endif 
2ffa			 
2ffa					FORTH_DSP_VALUEHL 
2ffa cd a8 1f			call macro_dsp_valuehl 
2ffd				endm 
# End of macro FORTH_DSP_VALUEHL
2ffd			 
2ffd e5					push hl   ; save address 
2ffe			 
2ffe					FORTH_DSP_POP 
2ffe cd 60 20			call macro_forth_dsp_pop 
3001				endm 
# End of macro FORTH_DSP_POP
3001			 
3001 e1					pop hl 
3002			 
3002 5e					ld e, (hl) 
3003 23					inc hl 
3004 56					ld d, (hl) 
3005			 
3005 eb					ex de, hl 
3006			 
3006 cd b1 1d				call forth_push_numhl 
3009			 
3009				       NEXTW 
3009 c3 5e 21			jp macro_next 
300c				endm 
# End of macro NEXTW
300c			.BANG2: 
300c				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
300c 6f				db WORD_SYS_CORE+91             
300d 44 30			dw .CONFIG            
300f 03				db 2 + 1 
3010 .. 00			db "2!",0              
3013				endm 
# End of macro CWHEAD
3013			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3013					if DEBUG_FORTH_WORDS_KEY 
3013						DMARK "2S_" 
3013 f5				push af  
3014 3a 28 30			ld a, (.dmark)  
3017 32 6b ee			ld (debug_mark),a  
301a 3a 29 30			ld a, (.dmark+1)  
301d 32 6c ee			ld (debug_mark+1),a  
3020 3a 2a 30			ld a, (.dmark+2)  
3023 32 6d ee			ld (debug_mark+2),a  
3026 18 03			jr .pastdmark  
3028 ..			.dmark: db "2S_"  
302b f1			.pastdmark: pop af  
302c			endm  
# End of macro DMARK
302c						CALLMONITOR 
302c cd 6f ee			call debug_vector  
302f				endm  
# End of macro CALLMONITOR
302f					endif 
302f			 
302f					FORTH_DSP_VALUEHL 
302f cd a8 1f			call macro_dsp_valuehl 
3032				endm 
# End of macro FORTH_DSP_VALUEHL
3032			 
3032 e5					push hl   ; save address 
3033			 
3033			 
3033					FORTH_DSP_POP 
3033 cd 60 20			call macro_forth_dsp_pop 
3036				endm 
# End of macro FORTH_DSP_POP
3036			 
3036					 
3036					FORTH_DSP_VALUEHL 
3036 cd a8 1f			call macro_dsp_valuehl 
3039				endm 
# End of macro FORTH_DSP_VALUEHL
3039			 
3039					FORTH_DSP_POP 
3039 cd 60 20			call macro_forth_dsp_pop 
303c				endm 
# End of macro FORTH_DSP_POP
303c			 
303c eb					ex de, hl    ; value now in de 
303d			 
303d e1					pop hl 
303e			 
303e 73					ld (hl), e 
303f			 
303f 23					inc hl 
3040			 
3040 72					ld (hl), d 
3041			 
3041			 
3041				       NEXTW 
3041 c3 5e 21			jp macro_next 
3044				endm 
# End of macro NEXTW
3044			.CONFIG: 
3044				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
3044 6f				db WORD_SYS_CORE+91             
3045 55 30			dw .ADTOS            
3047 07				db 6 + 1 
3048 .. 00			db "CONFIG",0              
304f				endm 
# End of macro CWHEAD
304f			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
304f			 
304f cd b1 15				call config 
3052					NEXTW 
3052 c3 5e 21			jp macro_next 
3055				endm 
# End of macro NEXTW
3055			 
3055			.ADTOS: 
3055				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
3055 6f				db WORD_SYS_CORE+91             
3056 6b 30			dw .SBTOS            
3058 03				db 2 + 1 
3059 .. 00			db "1+",0              
305c				endm 
# End of macro CWHEAD
305c			; | 1+ ( u -- u )  Increment value on TOS | DONE 
305c			 
305c					FORTH_DSP_VALUEHL 
305c cd a8 1f			call macro_dsp_valuehl 
305f				endm 
# End of macro FORTH_DSP_VALUEHL
305f e5					push hl 
3060			 
3060					FORTH_DSP_POP 
3060 cd 60 20			call macro_forth_dsp_pop 
3063				endm 
# End of macro FORTH_DSP_POP
3063 e1					pop hl 
3064			 
3064 23					inc hl 
3065 cd b1 1d				call forth_push_numhl 
3068					 
3068					NEXTW 
3068 c3 5e 21			jp macro_next 
306b				endm 
# End of macro NEXTW
306b			.SBTOS: 
306b				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
306b 6f				db WORD_SYS_CORE+91             
306c 81 30			dw .ADSTORE            
306e 03				db 2 + 1 
306f .. 00			db "1-",0              
3072				endm 
# End of macro CWHEAD
3072			; | 1- ( u -- u )  Decrement value on TOS | DONE 
3072			 
3072					FORTH_DSP_VALUEHL 
3072 cd a8 1f			call macro_dsp_valuehl 
3075				endm 
# End of macro FORTH_DSP_VALUEHL
3075 e5					push hl 
3076			 
3076					FORTH_DSP_POP 
3076 cd 60 20			call macro_forth_dsp_pop 
3079				endm 
# End of macro FORTH_DSP_POP
3079 e1					pop hl 
307a			 
307a 2b					dec hl 
307b cd b1 1d				call forth_push_numhl 
307e					 
307e					NEXTW 
307e c3 5e 21			jp macro_next 
3081				endm 
# End of macro NEXTW
3081			.ADSTORE: 
3081				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
3081 6f				db WORD_SYS_CORE+91             
3082 97 30			dw .ADWSTORE            
3084 04				db 3 + 1 
3085 .. 00			db "1+!",0              
3089				endm 
# End of macro CWHEAD
3089			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
3089			 
3089					FORTH_DSP_VALUEHL 
3089 cd a8 1f			call macro_dsp_valuehl 
308c				endm 
# End of macro FORTH_DSP_VALUEHL
308c e5					push hl 
308d			 
308d					FORTH_DSP_POP 
308d cd 60 20			call macro_forth_dsp_pop 
3090				endm 
# End of macro FORTH_DSP_POP
3090 e1					pop hl 
3091			 
3091 7e					ld a, (hl) 
3092 3c					inc a 
3093 77					ld (hl), a 
3094					 
3094					NEXTW 
3094 c3 5e 21			jp macro_next 
3097				endm 
# End of macro NEXTW
3097			.ADWSTORE: 
3097				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
3097 6f				db WORD_SYS_CORE+91             
3098 b5 30			dw .SBSTORE            
309a 05				db 4 + 1 
309b .. 00			db "1+2!",0              
30a0				endm 
# End of macro CWHEAD
30a0			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
30a0			 
30a0					FORTH_DSP_VALUEHL 
30a0 cd a8 1f			call macro_dsp_valuehl 
30a3				endm 
# End of macro FORTH_DSP_VALUEHL
30a3 e5					push hl 
30a4			 
30a4					FORTH_DSP_POP 
30a4 cd 60 20			call macro_forth_dsp_pop 
30a7				endm 
# End of macro FORTH_DSP_POP
30a7 e1					pop hl 
30a8			 
30a8 e5					push hl 
30a9			 
30a9 cd e0 20				call loadwordinhl 
30ac 23					inc hl 
30ad			 
30ad d1					pop de 
30ae eb					ex de, hl 
30af 73					ld (hl), e 
30b0 23					inc hl 
30b1 72					ld (hl), d 
30b2					 
30b2					NEXTW 
30b2 c3 5e 21			jp macro_next 
30b5				endm 
# End of macro NEXTW
30b5			.SBSTORE: 
30b5				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
30b5 6f				db WORD_SYS_CORE+91             
30b6 cb 30			dw .SBWSTORE            
30b8 04				db 3 + 1 
30b9 .. 00			db "1-!",0              
30bd				endm 
# End of macro CWHEAD
30bd			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
30bd			 
30bd					FORTH_DSP_VALUEHL 
30bd cd a8 1f			call macro_dsp_valuehl 
30c0				endm 
# End of macro FORTH_DSP_VALUEHL
30c0 e5					push hl 
30c1			 
30c1					FORTH_DSP_POP 
30c1 cd 60 20			call macro_forth_dsp_pop 
30c4				endm 
# End of macro FORTH_DSP_POP
30c4 e1					pop hl 
30c5			 
30c5 7e					ld a, (hl) 
30c6 3d					dec a 
30c7 77					ld (hl), a 
30c8					 
30c8					NEXTW 
30c8 c3 5e 21			jp macro_next 
30cb				endm 
# End of macro NEXTW
30cb			.SBWSTORE: 
30cb				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
30cb 6f				db WORD_SYS_CORE+91             
30cc e9 30			dw .ENDCORE            
30ce 05				db 4 + 1 
30cf .. 00			db "1-2!",0              
30d4				endm 
# End of macro CWHEAD
30d4			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
30d4			 
30d4					FORTH_DSP_VALUEHL 
30d4 cd a8 1f			call macro_dsp_valuehl 
30d7				endm 
# End of macro FORTH_DSP_VALUEHL
30d7 e5					push hl 
30d8			 
30d8					FORTH_DSP_POP 
30d8 cd 60 20			call macro_forth_dsp_pop 
30db				endm 
# End of macro FORTH_DSP_POP
30db e1					pop hl 
30dc			 
30dc e5					push hl 
30dd			 
30dd cd e0 20				call loadwordinhl 
30e0 2b					dec hl 
30e1			 
30e1 d1					pop de 
30e2 eb					ex de, hl 
30e3 73					ld (hl), e 
30e4 23					inc hl 
30e5 72					ld (hl), d 
30e6					 
30e6					NEXTW 
30e6 c3 5e 21			jp macro_next 
30e9				endm 
# End of macro NEXTW
30e9			.ENDCORE: 
30e9			 
30e9			; eof 
30e9			 
30e9			 
# End of file forth_words_core.asm
30e9			include "forth_words_flow.asm" 
30e9			 
30e9			; | ## Program Flow Words 
30e9			 
30e9			.IF: 
30e9				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
30e9 1e				db WORD_SYS_CORE+10             
30ea de 31			dw .THEN            
30ec 03				db 2 + 1 
30ed .. 00			db "IF",0              
30f0				endm 
# End of macro CWHEAD
30f0			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
30f0			; 
30f0					if DEBUG_FORTH_WORDS_KEY 
30f0						DMARK "IF." 
30f0 f5				push af  
30f1 3a 05 31			ld a, (.dmark)  
30f4 32 6b ee			ld (debug_mark),a  
30f7 3a 06 31			ld a, (.dmark+1)  
30fa 32 6c ee			ld (debug_mark+1),a  
30fd 3a 07 31			ld a, (.dmark+2)  
3100 32 6d ee			ld (debug_mark+2),a  
3103 18 03			jr .pastdmark  
3105 ..			.dmark: db "IF."  
3108 f1			.pastdmark: pop af  
3109			endm  
# End of macro DMARK
3109						CALLMONITOR 
3109 cd 6f ee			call debug_vector  
310c				endm  
# End of macro CALLMONITOR
310c					endif 
310c			; eval TOS 
310c			 
310c				FORTH_DSP_VALUEHL 
310c cd a8 1f			call macro_dsp_valuehl 
310f				endm 
# End of macro FORTH_DSP_VALUEHL
310f			 
310f			;	push hl 
310f				FORTH_DSP_POP 
310f cd 60 20			call macro_forth_dsp_pop 
3112				endm 
# End of macro FORTH_DSP_POP
3112			;	pop hl 
3112			 
3112					if DEBUG_FORTH_WORDS 
3112						DMARK "IF1" 
3112 f5				push af  
3113 3a 27 31			ld a, (.dmark)  
3116 32 6b ee			ld (debug_mark),a  
3119 3a 28 31			ld a, (.dmark+1)  
311c 32 6c ee			ld (debug_mark+1),a  
311f 3a 29 31			ld a, (.dmark+2)  
3122 32 6d ee			ld (debug_mark+2),a  
3125 18 03			jr .pastdmark  
3127 ..			.dmark: db "IF1"  
312a f1			.pastdmark: pop af  
312b			endm  
# End of macro DMARK
312b						CALLMONITOR 
312b cd 6f ee			call debug_vector  
312e				endm  
# End of macro CALLMONITOR
312e					endif 
312e b7				or a        ; clear carry flag 
312f 11 00 00			ld de, 0 
3132 eb				ex de,hl 
3133 ed 52			sbc hl, de 
3135 c2 bf 31			jp nz, .iftrue 
3138			 
3138					if DEBUG_FORTH_WORDS 
3138						DMARK "IF2" 
3138 f5				push af  
3139 3a 4d 31			ld a, (.dmark)  
313c 32 6b ee			ld (debug_mark),a  
313f 3a 4e 31			ld a, (.dmark+1)  
3142 32 6c ee			ld (debug_mark+1),a  
3145 3a 4f 31			ld a, (.dmark+2)  
3148 32 6d ee			ld (debug_mark+2),a  
314b 18 03			jr .pastdmark  
314d ..			.dmark: db "IF2"  
3150 f1			.pastdmark: pop af  
3151			endm  
# End of macro DMARK
3151						CALLMONITOR 
3151 cd 6f ee			call debug_vector  
3154				endm  
# End of macro CALLMONITOR
3154					endif 
3154			 
3154			; if not true then skip to THEN 
3154			 
3154				; TODO get tok_ptr 
3154				; TODO consume toks until we get to THEN 
3154			 
3154 2a c2 e5			ld hl, (os_tok_ptr) 
3157					if DEBUG_FORTH_WORDS 
3157						DMARK "IF3" 
3157 f5				push af  
3158 3a 6c 31			ld a, (.dmark)  
315b 32 6b ee			ld (debug_mark),a  
315e 3a 6d 31			ld a, (.dmark+1)  
3161 32 6c ee			ld (debug_mark+1),a  
3164 3a 6e 31			ld a, (.dmark+2)  
3167 32 6d ee			ld (debug_mark+2),a  
316a 18 03			jr .pastdmark  
316c ..			.dmark: db "IF3"  
316f f1			.pastdmark: pop af  
3170			endm  
# End of macro DMARK
3170						CALLMONITOR 
3170 cd 6f ee			call debug_vector  
3173				endm  
# End of macro CALLMONITOR
3173						 
3173					endif 
3173 11 ba 31			ld de, .ifthen 
3176					if DEBUG_FORTH_WORDS 
3176						DMARK "IF4" 
3176 f5				push af  
3177 3a 8b 31			ld a, (.dmark)  
317a 32 6b ee			ld (debug_mark),a  
317d 3a 8c 31			ld a, (.dmark+1)  
3180 32 6c ee			ld (debug_mark+1),a  
3183 3a 8d 31			ld a, (.dmark+2)  
3186 32 6d ee			ld (debug_mark+2),a  
3189 18 03			jr .pastdmark  
318b ..			.dmark: db "IF4"  
318e f1			.pastdmark: pop af  
318f			endm  
# End of macro DMARK
318f						CALLMONITOR 
318f cd 6f ee			call debug_vector  
3192				endm  
# End of macro CALLMONITOR
3192					endif 
3192 cd 79 22			call findnexttok  
3195			 
3195					if DEBUG_FORTH_WORDS 
3195						DMARK "IF5" 
3195 f5				push af  
3196 3a aa 31			ld a, (.dmark)  
3199 32 6b ee			ld (debug_mark),a  
319c 3a ab 31			ld a, (.dmark+1)  
319f 32 6c ee			ld (debug_mark+1),a  
31a2 3a ac 31			ld a, (.dmark+2)  
31a5 32 6d ee			ld (debug_mark+2),a  
31a8 18 03			jr .pastdmark  
31aa ..			.dmark: db "IF5"  
31ad f1			.pastdmark: pop af  
31ae			endm  
# End of macro DMARK
31ae						CALLMONITOR 
31ae cd 6f ee			call debug_vector  
31b1				endm  
# End of macro CALLMONITOR
31b1					endif 
31b1				; TODO replace below with ; exec using tok_ptr 
31b1 22 c2 e5			ld (os_tok_ptr), hl 
31b4 c3 ef 21			jp exec1 
31b7				NEXTW 
31b7 c3 5e 21			jp macro_next 
31ba				endm 
# End of macro NEXTW
31ba			 
31ba .. 00		.ifthen:  db "THEN",0 
31bf			 
31bf			.iftrue:		 
31bf				; Exec next words normally 
31bf			 
31bf				; if true then exec following IF as normal 
31bf					if DEBUG_FORTH_WORDS 
31bf						DMARK "IFT" 
31bf f5				push af  
31c0 3a d4 31			ld a, (.dmark)  
31c3 32 6b ee			ld (debug_mark),a  
31c6 3a d5 31			ld a, (.dmark+1)  
31c9 32 6c ee			ld (debug_mark+1),a  
31cc 3a d6 31			ld a, (.dmark+2)  
31cf 32 6d ee			ld (debug_mark+2),a  
31d2 18 03			jr .pastdmark  
31d4 ..			.dmark: db "IFT"  
31d7 f1			.pastdmark: pop af  
31d8			endm  
# End of macro DMARK
31d8						CALLMONITOR 
31d8 cd 6f ee			call debug_vector  
31db				endm  
# End of macro CALLMONITOR
31db					endif 
31db			 
31db					NEXTW 
31db c3 5e 21			jp macro_next 
31de				endm 
# End of macro NEXTW
31de			.THEN: 
31de				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
31de 1f				db WORD_SYS_CORE+11             
31df 06 32			dw .ELSE            
31e1 05				db 4 + 1 
31e2 .. 00			db "THEN",0              
31e7				endm 
# End of macro CWHEAD
31e7			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
31e7					if DEBUG_FORTH_WORDS_KEY 
31e7						DMARK "THN" 
31e7 f5				push af  
31e8 3a fc 31			ld a, (.dmark)  
31eb 32 6b ee			ld (debug_mark),a  
31ee 3a fd 31			ld a, (.dmark+1)  
31f1 32 6c ee			ld (debug_mark+1),a  
31f4 3a fe 31			ld a, (.dmark+2)  
31f7 32 6d ee			ld (debug_mark+2),a  
31fa 18 03			jr .pastdmark  
31fc ..			.dmark: db "THN"  
31ff f1			.pastdmark: pop af  
3200			endm  
# End of macro DMARK
3200						CALLMONITOR 
3200 cd 6f ee			call debug_vector  
3203				endm  
# End of macro CALLMONITOR
3203					endif 
3203					NEXTW 
3203 c3 5e 21			jp macro_next 
3206				endm 
# End of macro NEXTW
3206			.ELSE: 
3206				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3206 20				db WORD_SYS_CORE+12             
3207 2e 32			dw .DO            
3209 03				db 2 + 1 
320a .. 00			db "ELSE",0              
320f				endm 
# End of macro CWHEAD
320f			; | ELSE ( -- ) Not supported - does nothing | TODO 
320f			 
320f					if DEBUG_FORTH_WORDS_KEY 
320f						DMARK "ELS" 
320f f5				push af  
3210 3a 24 32			ld a, (.dmark)  
3213 32 6b ee			ld (debug_mark),a  
3216 3a 25 32			ld a, (.dmark+1)  
3219 32 6c ee			ld (debug_mark+1),a  
321c 3a 26 32			ld a, (.dmark+2)  
321f 32 6d ee			ld (debug_mark+2),a  
3222 18 03			jr .pastdmark  
3224 ..			.dmark: db "ELS"  
3227 f1			.pastdmark: pop af  
3228			endm  
# End of macro DMARK
3228						CALLMONITOR 
3228 cd 6f ee			call debug_vector  
322b				endm  
# End of macro CALLMONITOR
322b					endif 
322b			 
322b			 
322b					NEXTW 
322b c3 5e 21			jp macro_next 
322e				endm 
# End of macro NEXTW
322e			.DO: 
322e				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
322e 21				db WORD_SYS_CORE+13             
322f 55 33			dw .LOOP            
3231 03				db 2 + 1 
3232 .. 00			db "DO",0              
3235				endm 
# End of macro CWHEAD
3235			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3235			 
3235					if DEBUG_FORTH_WORDS_KEY 
3235						DMARK "DO." 
3235 f5				push af  
3236 3a 4a 32			ld a, (.dmark)  
3239 32 6b ee			ld (debug_mark),a  
323c 3a 4b 32			ld a, (.dmark+1)  
323f 32 6c ee			ld (debug_mark+1),a  
3242 3a 4c 32			ld a, (.dmark+2)  
3245 32 6d ee			ld (debug_mark+2),a  
3248 18 03			jr .pastdmark  
324a ..			.dmark: db "DO."  
324d f1			.pastdmark: pop af  
324e			endm  
# End of macro DMARK
324e						CALLMONITOR 
324e cd 6f ee			call debug_vector  
3251				endm  
# End of macro CALLMONITOR
3251					endif 
3251			;  push pc to rsp stack past the DO 
3251			 
3251 2a c2 e5				ld hl, (os_tok_ptr) 
3254 23					inc hl   ; D 
3255 23					inc hl  ; O 
3256 23					inc hl   ; null 
3257					if DEBUG_FORTH_WORDS 
3257						DMARK "DO2" 
3257 f5				push af  
3258 3a 6c 32			ld a, (.dmark)  
325b 32 6b ee			ld (debug_mark),a  
325e 3a 6d 32			ld a, (.dmark+1)  
3261 32 6c ee			ld (debug_mark+1),a  
3264 3a 6e 32			ld a, (.dmark+2)  
3267 32 6d ee			ld (debug_mark+2),a  
326a 18 03			jr .pastdmark  
326c ..			.dmark: db "DO2"  
326f f1			.pastdmark: pop af  
3270			endm  
# End of macro DMARK
3270						CALLMONITOR 
3270 cd 6f ee			call debug_vector  
3273				endm  
# End of macro CALLMONITOR
3273					endif 
3273					FORTH_RSP_NEXT 
3273 cd 58 1d			call macro_forth_rsp_next 
3276				endm 
# End of macro FORTH_RSP_NEXT
3276					if DEBUG_FORTH_WORDS 
3276						DMARK "DO3" 
3276 f5				push af  
3277 3a 8b 32			ld a, (.dmark)  
327a 32 6b ee			ld (debug_mark),a  
327d 3a 8c 32			ld a, (.dmark+1)  
3280 32 6c ee			ld (debug_mark+1),a  
3283 3a 8d 32			ld a, (.dmark+2)  
3286 32 6d ee			ld (debug_mark+2),a  
3289 18 03			jr .pastdmark  
328b ..			.dmark: db "DO3"  
328e f1			.pastdmark: pop af  
328f			endm  
# End of macro DMARK
328f						CALLMONITOR 
328f cd 6f ee			call debug_vector  
3292				endm  
# End of macro CALLMONITOR
3292					endif 
3292			 
3292					;if DEBUG_FORTH_WORDS 
3292				;		push hl 
3292			;		endif  
3292			 
3292			; get counters from data stack 
3292			 
3292			 
3292					FORTH_DSP_VALUEHL 
3292 cd a8 1f			call macro_dsp_valuehl 
3295				endm 
# End of macro FORTH_DSP_VALUEHL
3295 e5					push hl		 ; hl now has starting counter which needs to be tos 
3296			 
3296					if DEBUG_FORTH_WORDS 
3296						DMARK "DO4" 
3296 f5				push af  
3297 3a ab 32			ld a, (.dmark)  
329a 32 6b ee			ld (debug_mark),a  
329d 3a ac 32			ld a, (.dmark+1)  
32a0 32 6c ee			ld (debug_mark+1),a  
32a3 3a ad 32			ld a, (.dmark+2)  
32a6 32 6d ee			ld (debug_mark+2),a  
32a9 18 03			jr .pastdmark  
32ab ..			.dmark: db "DO4"  
32ae f1			.pastdmark: pop af  
32af			endm  
# End of macro DMARK
32af						CALLMONITOR 
32af cd 6f ee			call debug_vector  
32b2				endm  
# End of macro CALLMONITOR
32b2					endif 
32b2					FORTH_DSP_POP 
32b2 cd 60 20			call macro_forth_dsp_pop 
32b5				endm 
# End of macro FORTH_DSP_POP
32b5			 
32b5					if DEBUG_FORTH_WORDS 
32b5						DMARK "DO5" 
32b5 f5				push af  
32b6 3a ca 32			ld a, (.dmark)  
32b9 32 6b ee			ld (debug_mark),a  
32bc 3a cb 32			ld a, (.dmark+1)  
32bf 32 6c ee			ld (debug_mark+1),a  
32c2 3a cc 32			ld a, (.dmark+2)  
32c5 32 6d ee			ld (debug_mark+2),a  
32c8 18 03			jr .pastdmark  
32ca ..			.dmark: db "DO5"  
32cd f1			.pastdmark: pop af  
32ce			endm  
# End of macro DMARK
32ce						CALLMONITOR 
32ce cd 6f ee			call debug_vector  
32d1				endm  
# End of macro CALLMONITOR
32d1					endif 
32d1			 
32d1					FORTH_DSP_VALUEHL 
32d1 cd a8 1f			call macro_dsp_valuehl 
32d4				endm 
# End of macro FORTH_DSP_VALUEHL
32d4			;		push hl		 ; hl now has starting limit counter 
32d4			 
32d4					if DEBUG_FORTH_WORDS 
32d4						DMARK "DO6" 
32d4 f5				push af  
32d5 3a e9 32			ld a, (.dmark)  
32d8 32 6b ee			ld (debug_mark),a  
32db 3a ea 32			ld a, (.dmark+1)  
32de 32 6c ee			ld (debug_mark+1),a  
32e1 3a eb 32			ld a, (.dmark+2)  
32e4 32 6d ee			ld (debug_mark+2),a  
32e7 18 03			jr .pastdmark  
32e9 ..			.dmark: db "DO6"  
32ec f1			.pastdmark: pop af  
32ed			endm  
# End of macro DMARK
32ed						CALLMONITOR 
32ed cd 6f ee			call debug_vector  
32f0				endm  
# End of macro CALLMONITOR
32f0					endif 
32f0					FORTH_DSP_POP 
32f0 cd 60 20			call macro_forth_dsp_pop 
32f3				endm 
# End of macro FORTH_DSP_POP
32f3			 
32f3			; put counters on the loop stack 
32f3			 
32f3			;		pop hl			 ; limit counter 
32f3 d1					pop de			; start counter 
32f4			 
32f4					; push limit counter 
32f4			 
32f4					if DEBUG_FORTH_WORDS 
32f4						DMARK "DO7" 
32f4 f5				push af  
32f5 3a 09 33			ld a, (.dmark)  
32f8 32 6b ee			ld (debug_mark),a  
32fb 3a 0a 33			ld a, (.dmark+1)  
32fe 32 6c ee			ld (debug_mark+1),a  
3301 3a 0b 33			ld a, (.dmark+2)  
3304 32 6d ee			ld (debug_mark+2),a  
3307 18 03			jr .pastdmark  
3309 ..			.dmark: db "DO7"  
330c f1			.pastdmark: pop af  
330d			endm  
# End of macro DMARK
330d						CALLMONITOR 
330d cd 6f ee			call debug_vector  
3310				endm  
# End of macro CALLMONITOR
3310					endif 
3310					FORTH_LOOP_NEXT 
3310 cd d9 1f			call macro_forth_loop_next 
3313				endm 
# End of macro FORTH_LOOP_NEXT
3313			 
3313					; push start counter 
3313			 
3313 eb					ex de, hl 
3314					if DEBUG_FORTH_WORDS 
3314						DMARK "DO7" 
3314 f5				push af  
3315 3a 29 33			ld a, (.dmark)  
3318 32 6b ee			ld (debug_mark),a  
331b 3a 2a 33			ld a, (.dmark+1)  
331e 32 6c ee			ld (debug_mark+1),a  
3321 3a 2b 33			ld a, (.dmark+2)  
3324 32 6d ee			ld (debug_mark+2),a  
3327 18 03			jr .pastdmark  
3329 ..			.dmark: db "DO7"  
332c f1			.pastdmark: pop af  
332d			endm  
# End of macro DMARK
332d						CALLMONITOR 
332d cd 6f ee			call debug_vector  
3330				endm  
# End of macro CALLMONITOR
3330					endif 
3330					FORTH_LOOP_NEXT 
3330 cd d9 1f			call macro_forth_loop_next 
3333				endm 
# End of macro FORTH_LOOP_NEXT
3333			 
3333			 
3333					; init first round of I counter 
3333			 
3333 22 e6 e5				ld (os_current_i), hl 
3336			 
3336					if DEBUG_FORTH_WORDS 
3336						DMARK "DO8" 
3336 f5				push af  
3337 3a 4b 33			ld a, (.dmark)  
333a 32 6b ee			ld (debug_mark),a  
333d 3a 4c 33			ld a, (.dmark+1)  
3340 32 6c ee			ld (debug_mark+1),a  
3343 3a 4d 33			ld a, (.dmark+2)  
3346 32 6d ee			ld (debug_mark+2),a  
3349 18 03			jr .pastdmark  
334b ..			.dmark: db "DO8"  
334e f1			.pastdmark: pop af  
334f			endm  
# End of macro DMARK
334f						CALLMONITOR 
334f cd 6f ee			call debug_vector  
3352				endm  
# End of macro CALLMONITOR
3352					endif 
3352			 
3352					NEXTW 
3352 c3 5e 21			jp macro_next 
3355				endm 
# End of macro NEXTW
3355			.LOOP: 
3355				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3355 22				db WORD_SYS_CORE+14             
3356 6d 34			dw .I            
3358 05				db 4 + 1 
3359 .. 00			db "LOOP",0              
335e				endm 
# End of macro CWHEAD
335e			; | LOOP ( -- ) Increment and test loop counter  | DONE 
335e			 
335e				; pop tos as current loop count to hl 
335e			 
335e				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
335e			 
335e				FORTH_LOOP_TOS 
335e cd 0c 20			call macro_forth_loop_tos 
3361				endm 
# End of macro FORTH_LOOP_TOS
3361 e5				push hl 
3362			 
3362					if DEBUG_FORTH_WORDS_KEY 
3362						DMARK "LOP" 
3362 f5				push af  
3363 3a 77 33			ld a, (.dmark)  
3366 32 6b ee			ld (debug_mark),a  
3369 3a 78 33			ld a, (.dmark+1)  
336c 32 6c ee			ld (debug_mark+1),a  
336f 3a 79 33			ld a, (.dmark+2)  
3372 32 6d ee			ld (debug_mark+2),a  
3375 18 03			jr .pastdmark  
3377 ..			.dmark: db "LOP"  
337a f1			.pastdmark: pop af  
337b			endm  
# End of macro DMARK
337b						CALLMONITOR 
337b cd 6f ee			call debug_vector  
337e				endm  
# End of macro CALLMONITOR
337e					endif 
337e				; next item on the stack is the limit. get it 
337e			 
337e			 
337e				FORTH_LOOP_POP 
337e cd 16 20			call macro_forth_loop_pop 
3381				endm 
# End of macro FORTH_LOOP_POP
3381			 
3381				FORTH_LOOP_TOS 
3381 cd 0c 20			call macro_forth_loop_tos 
3384				endm 
# End of macro FORTH_LOOP_TOS
3384			 
3384 d1				pop de		 ; de = i, hl = limit 
3385			 
3385					if DEBUG_FORTH_WORDS 
3385						DMARK "LP1" 
3385 f5				push af  
3386 3a 9a 33			ld a, (.dmark)  
3389 32 6b ee			ld (debug_mark),a  
338c 3a 9b 33			ld a, (.dmark+1)  
338f 32 6c ee			ld (debug_mark+1),a  
3392 3a 9c 33			ld a, (.dmark+2)  
3395 32 6d ee			ld (debug_mark+2),a  
3398 18 03			jr .pastdmark  
339a ..			.dmark: db "LP1"  
339d f1			.pastdmark: pop af  
339e			endm  
# End of macro DMARK
339e						CALLMONITOR 
339e cd 6f ee			call debug_vector  
33a1				endm  
# End of macro CALLMONITOR
33a1					endif 
33a1			 
33a1				; go back to previous word 
33a1			 
33a1 d5				push de    ; save I for inc later 
33a2			 
33a2			 
33a2				; get limit 
33a2				;  is I at limit? 
33a2			 
33a2			 
33a2					if DEBUG_FORTH_WORDS 
33a2						DMARK "LP1" 
33a2 f5				push af  
33a3 3a b7 33			ld a, (.dmark)  
33a6 32 6b ee			ld (debug_mark),a  
33a9 3a b8 33			ld a, (.dmark+1)  
33ac 32 6c ee			ld (debug_mark+1),a  
33af 3a b9 33			ld a, (.dmark+2)  
33b2 32 6d ee			ld (debug_mark+2),a  
33b5 18 03			jr .pastdmark  
33b7 ..			.dmark: db "LP1"  
33ba f1			.pastdmark: pop af  
33bb			endm  
# End of macro DMARK
33bb						CALLMONITOR 
33bb cd 6f ee			call debug_vector  
33be				endm  
# End of macro CALLMONITOR
33be					endif 
33be			 
33be ed 52			sbc hl, de 
33c0			 
33c0			 
33c0				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
33c0			 
33c0 20 26				jr nz, .loopnotdone 
33c2			 
33c2 e1				pop hl   ; get rid of saved I 
33c3				FORTH_LOOP_POP     ; get rid of limit 
33c3 cd 16 20			call macro_forth_loop_pop 
33c6				endm 
# End of macro FORTH_LOOP_POP
33c6			 
33c6				FORTH_RSP_POP     ; get rid of DO ptr 
33c6 cd 79 1d			call macro_forth_rsp_pop 
33c9				endm 
# End of macro FORTH_RSP_POP
33c9			 
33c9			if DEBUG_FORTH_WORDS 
33c9						DMARK "LP>" 
33c9 f5				push af  
33ca 3a de 33			ld a, (.dmark)  
33cd 32 6b ee			ld (debug_mark),a  
33d0 3a df 33			ld a, (.dmark+1)  
33d3 32 6c ee			ld (debug_mark+1),a  
33d6 3a e0 33			ld a, (.dmark+2)  
33d9 32 6d ee			ld (debug_mark+2),a  
33dc 18 03			jr .pastdmark  
33de ..			.dmark: db "LP>"  
33e1 f1			.pastdmark: pop af  
33e2			endm  
# End of macro DMARK
33e2				CALLMONITOR 
33e2 cd 6f ee			call debug_vector  
33e5				endm  
# End of macro CALLMONITOR
33e5			endif 
33e5			 
33e5					NEXTW 
33e5 c3 5e 21			jp macro_next 
33e8				endm 
# End of macro NEXTW
33e8				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
33e8			 
33e8			.loopnotdone: 
33e8			 
33e8 e1				pop hl    ; get I 
33e9 23				inc hl 
33ea			 
33ea			   	; save new I 
33ea			 
33ea			 
33ea					; set I counter 
33ea			 
33ea 22 e6 e5				ld (os_current_i), hl 
33ed			 
33ed					if DEBUG_FORTH_WORDS 
33ed						DMARK "LPN" 
33ed f5				push af  
33ee 3a 02 34			ld a, (.dmark)  
33f1 32 6b ee			ld (debug_mark),a  
33f4 3a 03 34			ld a, (.dmark+1)  
33f7 32 6c ee			ld (debug_mark+1),a  
33fa 3a 04 34			ld a, (.dmark+2)  
33fd 32 6d ee			ld (debug_mark+2),a  
3400 18 03			jr .pastdmark  
3402 ..			.dmark: db "LPN"  
3405 f1			.pastdmark: pop af  
3406			endm  
# End of macro DMARK
3406					CALLMONITOR 
3406 cd 6f ee			call debug_vector  
3409				endm  
# End of macro CALLMONITOR
3409					endif 
3409					 
3409				FORTH_LOOP_NEXT 
3409 cd d9 1f			call macro_forth_loop_next 
340c				endm 
# End of macro FORTH_LOOP_NEXT
340c			 
340c			 
340c					if DEBUG_FORTH_WORDS 
340c eb						ex de,hl 
340d					endif 
340d			 
340d			;	; get DO ptr 
340d			; 
340d					if DEBUG_FORTH_WORDS 
340d						DMARK "LP7" 
340d f5				push af  
340e 3a 22 34			ld a, (.dmark)  
3411 32 6b ee			ld (debug_mark),a  
3414 3a 23 34			ld a, (.dmark+1)  
3417 32 6c ee			ld (debug_mark+1),a  
341a 3a 24 34			ld a, (.dmark+2)  
341d 32 6d ee			ld (debug_mark+2),a  
3420 18 03			jr .pastdmark  
3422 ..			.dmark: db "LP7"  
3425 f1			.pastdmark: pop af  
3426			endm  
# End of macro DMARK
3426					CALLMONITOR 
3426 cd 6f ee			call debug_vector  
3429				endm  
# End of macro CALLMONITOR
3429					endif 
3429				FORTH_RSP_TOS 
3429 cd 6f 1d			call macro_forth_rsp_tos 
342c				endm 
# End of macro FORTH_RSP_TOS
342c			 
342c					if DEBUG_FORTH_WORDS 
342c						DMARK "LP8" 
342c f5				push af  
342d 3a 41 34			ld a, (.dmark)  
3430 32 6b ee			ld (debug_mark),a  
3433 3a 42 34			ld a, (.dmark+1)  
3436 32 6c ee			ld (debug_mark+1),a  
3439 3a 43 34			ld a, (.dmark+2)  
343c 32 6d ee			ld (debug_mark+2),a  
343f 18 03			jr .pastdmark  
3441 ..			.dmark: db "LP8"  
3444 f1			.pastdmark: pop af  
3445			endm  
# End of macro DMARK
3445					CALLMONITOR 
3445 cd 6f ee			call debug_vector  
3448				endm  
# End of macro CALLMONITOR
3448					endif 
3448				;push hl 
3448			 
3448				; not going to DO any more 
3448				; get rid of the RSP pointer as DO will add it back in 
3448				;FORTH_RSP_POP 
3448				;pop hl 
3448			 
3448				;ld hl,(cli_ret_sp) 
3448				;ld e, (hl) 
3448				;inc hl 
3448				;ld d, (hl) 
3448				;ex de,hl 
3448 22 c2 e5			ld (os_tok_ptr), hl 
344b					if DEBUG_FORTH_WORDS 
344b						DMARK "LP<" 
344b f5				push af  
344c 3a 60 34			ld a, (.dmark)  
344f 32 6b ee			ld (debug_mark),a  
3452 3a 61 34			ld a, (.dmark+1)  
3455 32 6c ee			ld (debug_mark+1),a  
3458 3a 62 34			ld a, (.dmark+2)  
345b 32 6d ee			ld (debug_mark+2),a  
345e 18 03			jr .pastdmark  
3460 ..			.dmark: db "LP<"  
3463 f1			.pastdmark: pop af  
3464			endm  
# End of macro DMARK
3464					CALLMONITOR 
3464 cd 6f ee			call debug_vector  
3467				endm  
# End of macro CALLMONITOR
3467				endif 
3467 c3 ef 21			jp exec1 
346a			 
346a					 
346a			 
346a			 
346a					NEXTW 
346a c3 5e 21			jp macro_next 
346d				endm 
# End of macro NEXTW
346d			.I:  
346d			 
346d				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
346d 5e				db WORD_SYS_CORE+74             
346e 98 34			dw .DLOOP            
3470 02				db 1 + 1 
3471 .. 00			db "I",0              
3473				endm 
# End of macro CWHEAD
3473			; | I ( -- ) Current loop counter | DONE 
3473					if DEBUG_FORTH_WORDS_KEY 
3473						DMARK "I.." 
3473 f5				push af  
3474 3a 88 34			ld a, (.dmark)  
3477 32 6b ee			ld (debug_mark),a  
347a 3a 89 34			ld a, (.dmark+1)  
347d 32 6c ee			ld (debug_mark+1),a  
3480 3a 8a 34			ld a, (.dmark+2)  
3483 32 6d ee			ld (debug_mark+2),a  
3486 18 03			jr .pastdmark  
3488 ..			.dmark: db "I.."  
348b f1			.pastdmark: pop af  
348c			endm  
# End of macro DMARK
348c						CALLMONITOR 
348c cd 6f ee			call debug_vector  
348f				endm  
# End of macro CALLMONITOR
348f					endif 
348f			 
348f 2a e6 e5				ld hl,(os_current_i) 
3492 cd b1 1d				call forth_push_numhl 
3495			 
3495					NEXTW 
3495 c3 5e 21			jp macro_next 
3498				endm 
# End of macro NEXTW
3498			.DLOOP: 
3498				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3498 5f				db WORD_SYS_CORE+75             
3499 79 35			dw .REPEAT            
349b 06				db 5 + 1 
349c .. 00			db "-LOOP",0              
34a2				endm 
# End of macro CWHEAD
34a2			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
34a2				; pop tos as current loop count to hl 
34a2					if DEBUG_FORTH_WORDS_KEY 
34a2						DMARK "-LP" 
34a2 f5				push af  
34a3 3a b7 34			ld a, (.dmark)  
34a6 32 6b ee			ld (debug_mark),a  
34a9 3a b8 34			ld a, (.dmark+1)  
34ac 32 6c ee			ld (debug_mark+1),a  
34af 3a b9 34			ld a, (.dmark+2)  
34b2 32 6d ee			ld (debug_mark+2),a  
34b5 18 03			jr .pastdmark  
34b7 ..			.dmark: db "-LP"  
34ba f1			.pastdmark: pop af  
34bb			endm  
# End of macro DMARK
34bb						CALLMONITOR 
34bb cd 6f ee			call debug_vector  
34be				endm  
# End of macro CALLMONITOR
34be					endif 
34be			 
34be				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
34be			 
34be				FORTH_LOOP_TOS 
34be cd 0c 20			call macro_forth_loop_tos 
34c1				endm 
# End of macro FORTH_LOOP_TOS
34c1 e5				push hl 
34c2			 
34c2					if DEBUG_FORTH_WORDS 
34c2						DMARK "-LP" 
34c2 f5				push af  
34c3 3a d7 34			ld a, (.dmark)  
34c6 32 6b ee			ld (debug_mark),a  
34c9 3a d8 34			ld a, (.dmark+1)  
34cc 32 6c ee			ld (debug_mark+1),a  
34cf 3a d9 34			ld a, (.dmark+2)  
34d2 32 6d ee			ld (debug_mark+2),a  
34d5 18 03			jr .pastdmark  
34d7 ..			.dmark: db "-LP"  
34da f1			.pastdmark: pop af  
34db			endm  
# End of macro DMARK
34db						CALLMONITOR 
34db cd 6f ee			call debug_vector  
34de				endm  
# End of macro CALLMONITOR
34de					endif 
34de				; next item on the stack is the limit. get it 
34de			 
34de			 
34de				FORTH_LOOP_POP 
34de cd 16 20			call macro_forth_loop_pop 
34e1				endm 
# End of macro FORTH_LOOP_POP
34e1			 
34e1				FORTH_LOOP_TOS 
34e1 cd 0c 20			call macro_forth_loop_tos 
34e4				endm 
# End of macro FORTH_LOOP_TOS
34e4			 
34e4 d1				pop de		 ; de = i, hl = limit 
34e5			 
34e5					if DEBUG_FORTH_WORDS 
34e5						DMARK "-L1" 
34e5 f5				push af  
34e6 3a fa 34			ld a, (.dmark)  
34e9 32 6b ee			ld (debug_mark),a  
34ec 3a fb 34			ld a, (.dmark+1)  
34ef 32 6c ee			ld (debug_mark+1),a  
34f2 3a fc 34			ld a, (.dmark+2)  
34f5 32 6d ee			ld (debug_mark+2),a  
34f8 18 03			jr .pastdmark  
34fa ..			.dmark: db "-L1"  
34fd f1			.pastdmark: pop af  
34fe			endm  
# End of macro DMARK
34fe						CALLMONITOR 
34fe cd 6f ee			call debug_vector  
3501				endm  
# End of macro CALLMONITOR
3501					endif 
3501			 
3501				; go back to previous word 
3501			 
3501 d5				push de    ; save I for inc later 
3502			 
3502			 
3502				; get limit 
3502				;  is I at limit? 
3502			 
3502			 
3502					if DEBUG_FORTH_WORDS 
3502						DMARK "-L1" 
3502 f5				push af  
3503 3a 17 35			ld a, (.dmark)  
3506 32 6b ee			ld (debug_mark),a  
3509 3a 18 35			ld a, (.dmark+1)  
350c 32 6c ee			ld (debug_mark+1),a  
350f 3a 19 35			ld a, (.dmark+2)  
3512 32 6d ee			ld (debug_mark+2),a  
3515 18 03			jr .pastdmark  
3517 ..			.dmark: db "-L1"  
351a f1			.pastdmark: pop af  
351b			endm  
# End of macro DMARK
351b						CALLMONITOR 
351b cd 6f ee			call debug_vector  
351e				endm  
# End of macro CALLMONITOR
351e					endif 
351e			 
351e ed 52			sbc hl, de 
3520			 
3520			 
3520				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3520			 
3520 20 26				jr nz, .mloopnotdone 
3522			 
3522 e1				pop hl   ; get rid of saved I 
3523				FORTH_LOOP_POP     ; get rid of limit 
3523 cd 16 20			call macro_forth_loop_pop 
3526				endm 
# End of macro FORTH_LOOP_POP
3526			 
3526				FORTH_RSP_POP     ; get rid of DO ptr 
3526 cd 79 1d			call macro_forth_rsp_pop 
3529				endm 
# End of macro FORTH_RSP_POP
3529			 
3529			if DEBUG_FORTH_WORDS 
3529						DMARK "-L>" 
3529 f5				push af  
352a 3a 3e 35			ld a, (.dmark)  
352d 32 6b ee			ld (debug_mark),a  
3530 3a 3f 35			ld a, (.dmark+1)  
3533 32 6c ee			ld (debug_mark+1),a  
3536 3a 40 35			ld a, (.dmark+2)  
3539 32 6d ee			ld (debug_mark+2),a  
353c 18 03			jr .pastdmark  
353e ..			.dmark: db "-L>"  
3541 f1			.pastdmark: pop af  
3542			endm  
# End of macro DMARK
3542				CALLMONITOR 
3542 cd 6f ee			call debug_vector  
3545				endm  
# End of macro CALLMONITOR
3545			endif 
3545			 
3545					NEXTW 
3545 c3 5e 21			jp macro_next 
3548				endm 
# End of macro NEXTW
3548				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3548			 
3548			.mloopnotdone: 
3548			 
3548 e1				pop hl    ; get I 
3549 2b				dec hl 
354a			 
354a			   	; save new I 
354a			 
354a			 
354a					; set I counter 
354a			 
354a 22 e6 e5				ld (os_current_i), hl 
354d			 
354d					 
354d				FORTH_LOOP_NEXT 
354d cd d9 1f			call macro_forth_loop_next 
3550				endm 
# End of macro FORTH_LOOP_NEXT
3550			 
3550			 
3550					if DEBUG_FORTH_WORDS 
3550 eb						ex de,hl 
3551					endif 
3551			 
3551			;	; get DO ptr 
3551			; 
3551				FORTH_RSP_TOS 
3551 cd 6f 1d			call macro_forth_rsp_tos 
3554				endm 
# End of macro FORTH_RSP_TOS
3554			 
3554				;push hl 
3554			 
3554				; not going to DO any more 
3554				; get rid of the RSP pointer as DO will add it back in 
3554				;FORTH_RSP_POP 
3554				;pop hl 
3554			 
3554			 
3554 22 c2 e5			ld (os_tok_ptr), hl 
3557					if DEBUG_FORTH_WORDS 
3557						DMARK "-L<" 
3557 f5				push af  
3558 3a 6c 35			ld a, (.dmark)  
355b 32 6b ee			ld (debug_mark),a  
355e 3a 6d 35			ld a, (.dmark+1)  
3561 32 6c ee			ld (debug_mark+1),a  
3564 3a 6e 35			ld a, (.dmark+2)  
3567 32 6d ee			ld (debug_mark+2),a  
356a 18 03			jr .pastdmark  
356c ..			.dmark: db "-L<"  
356f f1			.pastdmark: pop af  
3570			endm  
# End of macro DMARK
3570					CALLMONITOR 
3570 cd 6f ee			call debug_vector  
3573				endm  
# End of macro CALLMONITOR
3573				endif 
3573 c3 ef 21			jp exec1 
3576			 
3576					 
3576			 
3576			 
3576			 
3576				NEXTW 
3576 c3 5e 21			jp macro_next 
3579				endm 
# End of macro NEXTW
3579			 
3579			 
3579			 
3579			 
3579			.REPEAT: 
3579				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3579 71				db WORD_SYS_CORE+93             
357a cc 35			dw .UNTIL            
357c 06				db 5 + 1 
357d .. 00			db "REPEAT",0              
3584				endm 
# End of macro CWHEAD
3584			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3584			;  push pc to rsp stack past the REPEAT 
3584					if DEBUG_FORTH_WORDS_KEY 
3584						DMARK "REP" 
3584 f5				push af  
3585 3a 99 35			ld a, (.dmark)  
3588 32 6b ee			ld (debug_mark),a  
358b 3a 9a 35			ld a, (.dmark+1)  
358e 32 6c ee			ld (debug_mark+1),a  
3591 3a 9b 35			ld a, (.dmark+2)  
3594 32 6d ee			ld (debug_mark+2),a  
3597 18 03			jr .pastdmark  
3599 ..			.dmark: db "REP"  
359c f1			.pastdmark: pop af  
359d			endm  
# End of macro DMARK
359d						CALLMONITOR 
359d cd 6f ee			call debug_vector  
35a0				endm  
# End of macro CALLMONITOR
35a0					endif 
35a0			 
35a0 2a c2 e5				ld hl, (os_tok_ptr) 
35a3 23					inc hl   ; R 
35a4 23					inc hl  ; E 
35a5 23					inc hl   ; P 
35a6 23					inc hl   ; E 
35a7 23					inc hl   ; A 
35a8 23					inc hl   ; T 
35a9 23					inc hl   ; zero 
35aa					FORTH_RSP_NEXT 
35aa cd 58 1d			call macro_forth_rsp_next 
35ad				endm 
# End of macro FORTH_RSP_NEXT
35ad			 
35ad			 
35ad					if DEBUG_FORTH_WORDS 
35ad						DMARK "REP" 
35ad f5				push af  
35ae 3a c2 35			ld a, (.dmark)  
35b1 32 6b ee			ld (debug_mark),a  
35b4 3a c3 35			ld a, (.dmark+1)  
35b7 32 6c ee			ld (debug_mark+1),a  
35ba 3a c4 35			ld a, (.dmark+2)  
35bd 32 6d ee			ld (debug_mark+2),a  
35c0 18 03			jr .pastdmark  
35c2 ..			.dmark: db "REP"  
35c5 f1			.pastdmark: pop af  
35c6			endm  
# End of macro DMARK
35c6						;pop bc    ; TODO BUG ?????? what is this for???? 
35c6						CALLMONITOR 
35c6 cd 6f ee			call debug_vector  
35c9				endm  
# End of macro CALLMONITOR
35c9					endif 
35c9			 
35c9					NEXTW 
35c9 c3 5e 21			jp macro_next 
35cc				endm 
# End of macro NEXTW
35cc			;	       NEXTW 
35cc			 
35cc			.UNTIL: 
35cc				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
35cc 72				db WORD_SYS_CORE+94             
35cd 63 36			dw .ENDFLOW            
35cf 06				db 5 + 1 
35d0 .. 00			db "UNTIL",0              
35d6				endm 
# End of macro CWHEAD
35d6			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
35d6			 
35d6				; pop tos as check 
35d6			 
35d6				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
35d6			 
35d6				FORTH_DSP_VALUEHL 
35d6 cd a8 1f			call macro_dsp_valuehl 
35d9				endm 
# End of macro FORTH_DSP_VALUEHL
35d9			 
35d9					if DEBUG_FORTH_WORDS_KEY 
35d9						DMARK "UNT" 
35d9 f5				push af  
35da 3a ee 35			ld a, (.dmark)  
35dd 32 6b ee			ld (debug_mark),a  
35e0 3a ef 35			ld a, (.dmark+1)  
35e3 32 6c ee			ld (debug_mark+1),a  
35e6 3a f0 35			ld a, (.dmark+2)  
35e9 32 6d ee			ld (debug_mark+2),a  
35ec 18 03			jr .pastdmark  
35ee ..			.dmark: db "UNT"  
35f1 f1			.pastdmark: pop af  
35f2			endm  
# End of macro DMARK
35f2						CALLMONITOR 
35f2 cd 6f ee			call debug_vector  
35f5				endm  
# End of macro CALLMONITOR
35f5					endif 
35f5			 
35f5			;	push hl 
35f5				FORTH_DSP_POP 
35f5 cd 60 20			call macro_forth_dsp_pop 
35f8				endm 
# End of macro FORTH_DSP_POP
35f8			 
35f8			;	pop hl 
35f8			 
35f8				; test if true 
35f8			 
35f8 cd 0f 0e			call ishlzero 
35fb			;	ld a,l 
35fb			;	add h 
35fb			; 
35fb			;	cp 0 
35fb			 
35fb 20 3e			jr nz, .untilnotdone 
35fd			 
35fd					if DEBUG_FORTH_WORDS 
35fd						DMARK "UNf" 
35fd f5				push af  
35fe 3a 12 36			ld a, (.dmark)  
3601 32 6b ee			ld (debug_mark),a  
3604 3a 13 36			ld a, (.dmark+1)  
3607 32 6c ee			ld (debug_mark+1),a  
360a 3a 14 36			ld a, (.dmark+2)  
360d 32 6d ee			ld (debug_mark+2),a  
3610 18 03			jr .pastdmark  
3612 ..			.dmark: db "UNf"  
3615 f1			.pastdmark: pop af  
3616			endm  
# End of macro DMARK
3616						CALLMONITOR 
3616 cd 6f ee			call debug_vector  
3619				endm  
# End of macro CALLMONITOR
3619					endif 
3619			 
3619			 
3619			 
3619				FORTH_RSP_POP     ; get rid of DO ptr 
3619 cd 79 1d			call macro_forth_rsp_pop 
361c				endm 
# End of macro FORTH_RSP_POP
361c			 
361c			if DEBUG_FORTH_WORDS 
361c						DMARK "UN>" 
361c f5				push af  
361d 3a 31 36			ld a, (.dmark)  
3620 32 6b ee			ld (debug_mark),a  
3623 3a 32 36			ld a, (.dmark+1)  
3626 32 6c ee			ld (debug_mark+1),a  
3629 3a 33 36			ld a, (.dmark+2)  
362c 32 6d ee			ld (debug_mark+2),a  
362f 18 03			jr .pastdmark  
3631 ..			.dmark: db "UN>"  
3634 f1			.pastdmark: pop af  
3635			endm  
# End of macro DMARK
3635				CALLMONITOR 
3635 cd 6f ee			call debug_vector  
3638				endm  
# End of macro CALLMONITOR
3638			endif 
3638			 
3638					NEXTW 
3638 c3 5e 21			jp macro_next 
363b				endm 
# End of macro NEXTW
363b				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
363b			 
363b			.untilnotdone: 
363b			 
363b			 
363b			;	; get DO ptr 
363b			; 
363b				FORTH_RSP_TOS 
363b cd 6f 1d			call macro_forth_rsp_tos 
363e				endm 
# End of macro FORTH_RSP_TOS
363e			 
363e				;push hl 
363e			 
363e				; not going to DO any more 
363e				; get rid of the RSP pointer as DO will add it back in 
363e				;FORTH_RSP_POP 
363e				;pop hl 
363e			 
363e			 
363e 22 c2 e5			ld (os_tok_ptr), hl 
3641					if DEBUG_FORTH_WORDS 
3641						DMARK "UN<" 
3641 f5				push af  
3642 3a 56 36			ld a, (.dmark)  
3645 32 6b ee			ld (debug_mark),a  
3648 3a 57 36			ld a, (.dmark+1)  
364b 32 6c ee			ld (debug_mark+1),a  
364e 3a 58 36			ld a, (.dmark+2)  
3651 32 6d ee			ld (debug_mark+2),a  
3654 18 03			jr .pastdmark  
3656 ..			.dmark: db "UN<"  
3659 f1			.pastdmark: pop af  
365a			endm  
# End of macro DMARK
365a					CALLMONITOR 
365a cd 6f ee			call debug_vector  
365d				endm  
# End of macro CALLMONITOR
365d				endif 
365d c3 ef 21			jp exec1 
3660			 
3660					 
3660			 
3660			 
3660					NEXTW 
3660 c3 5e 21			jp macro_next 
3663				endm 
# End of macro NEXTW
3663			 
3663			 
3663			.ENDFLOW: 
3663			 
3663			; eof 
3663			 
# End of file forth_words_flow.asm
3663			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3663			include "forth_words_logic.asm" 
3663			 
3663			; | ## Logic Words 
3663			 
3663			.NOT: 
3663				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3663 2d				db WORD_SYS_CORE+25             
3664 ab 36			dw .IS            
3666 04				db 3 + 1 
3667 .. 00			db "NOT",0              
366b				endm 
# End of macro CWHEAD
366b			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
366b					if DEBUG_FORTH_WORDS_KEY 
366b						DMARK "NOT" 
366b f5				push af  
366c 3a 80 36			ld a, (.dmark)  
366f 32 6b ee			ld (debug_mark),a  
3672 3a 81 36			ld a, (.dmark+1)  
3675 32 6c ee			ld (debug_mark+1),a  
3678 3a 82 36			ld a, (.dmark+2)  
367b 32 6d ee			ld (debug_mark+2),a  
367e 18 03			jr .pastdmark  
3680 ..			.dmark: db "NOT"  
3683 f1			.pastdmark: pop af  
3684			endm  
# End of macro DMARK
3684						CALLMONITOR 
3684 cd 6f ee			call debug_vector  
3687				endm  
# End of macro CALLMONITOR
3687					endif 
3687					FORTH_DSP 
3687 cd 6e 1f			call macro_forth_dsp 
368a				endm 
# End of macro FORTH_DSP
368a 7e					ld a,(hl)	; get type of value on TOS 
368b fe 02				cp DS_TYPE_INUM  
368d 28 03				jr z, .noti 
368f					NEXTW 
368f c3 5e 21			jp macro_next 
3692				endm 
# End of macro NEXTW
3692			.noti:          FORTH_DSP_VALUEHL 
3692 cd a8 1f			call macro_dsp_valuehl 
3695				endm 
# End of macro FORTH_DSP_VALUEHL
3695			;		push hl 
3695					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3695 cd 60 20			call macro_forth_dsp_pop 
3698				endm 
# End of macro FORTH_DSP_POP
3698			;		pop hl 
3698 3e 00				ld a,0 
369a bd					cp l 
369b 28 04				jr z, .not2t 
369d 2e 00				ld l, 0 
369f 18 02				jr .notip 
36a1			 
36a1 2e ff		.not2t:		ld l, 255 
36a3			 
36a3 26 00		.notip:		ld h, 0	 
36a5			 
36a5 cd b1 1d				call forth_push_numhl 
36a8					NEXTW 
36a8 c3 5e 21			jp macro_next 
36ab				endm 
# End of macro NEXTW
36ab			 
36ab			.IS: 
36ab				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
36ab 2d				db WORD_SYS_CORE+25             
36ac d1 36			dw .LZERO            
36ae 03				db 2 + 1 
36af .. 00			db "IS",0              
36b2				endm 
# End of macro CWHEAD
36b2			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
36b2					if DEBUG_FORTH_WORDS_KEY 
36b2						DMARK "IS." 
36b2 f5				push af  
36b3 3a c7 36			ld a, (.dmark)  
36b6 32 6b ee			ld (debug_mark),a  
36b9 3a c8 36			ld a, (.dmark+1)  
36bc 32 6c ee			ld (debug_mark+1),a  
36bf 3a c9 36			ld a, (.dmark+2)  
36c2 32 6d ee			ld (debug_mark+2),a  
36c5 18 03			jr .pastdmark  
36c7 ..			.dmark: db "IS."  
36ca f1			.pastdmark: pop af  
36cb			endm  
# End of macro DMARK
36cb						CALLMONITOR 
36cb cd 6f ee			call debug_vector  
36ce				endm  
# End of macro CALLMONITOR
36ce					endif 
36ce					NEXTW 
36ce c3 5e 21			jp macro_next 
36d1				endm 
# End of macro NEXTW
36d1			.LZERO: 
36d1				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
36d1 2d				db WORD_SYS_CORE+25             
36d2 db 36			dw .TZERO            
36d4 03				db 2 + 1 
36d5 .. 00			db "0<",0              
36d8				endm 
# End of macro CWHEAD
36d8			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
36d8					NEXTW 
36d8 c3 5e 21			jp macro_next 
36db				endm 
# End of macro NEXTW
36db			.TZERO: 
36db				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
36db 2e				db WORD_SYS_CORE+26             
36dc 22 37			dw .LESS            
36de 03				db 2 + 1 
36df .. 00			db "0=",0              
36e2				endm 
# End of macro CWHEAD
36e2			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
36e2				; TODO add floating point number detection 
36e2					;v5 FORTH_DSP_VALUE 
36e2					if DEBUG_FORTH_WORDS_KEY 
36e2						DMARK "0=." 
36e2 f5				push af  
36e3 3a f7 36			ld a, (.dmark)  
36e6 32 6b ee			ld (debug_mark),a  
36e9 3a f8 36			ld a, (.dmark+1)  
36ec 32 6c ee			ld (debug_mark+1),a  
36ef 3a f9 36			ld a, (.dmark+2)  
36f2 32 6d ee			ld (debug_mark+2),a  
36f5 18 03			jr .pastdmark  
36f7 ..			.dmark: db "0=."  
36fa f1			.pastdmark: pop af  
36fb			endm  
# End of macro DMARK
36fb						CALLMONITOR 
36fb cd 6f ee			call debug_vector  
36fe				endm  
# End of macro CALLMONITOR
36fe					endif 
36fe					FORTH_DSP 
36fe cd 6e 1f			call macro_forth_dsp 
3701				endm 
# End of macro FORTH_DSP
3701 7e					ld a,(hl)	; get type of value on TOS 
3702 fe 02				cp DS_TYPE_INUM  
3704 28 00				jr z, .tz_inum 
3706			 
3706				if FORTH_ENABLE_FLOATMATH 
3706					jr .tz_done 
3706			 
3706				endif 
3706					 
3706			 
3706			.tz_inum: 
3706					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3706 cd a8 1f			call macro_dsp_valuehl 
3709				endm 
# End of macro FORTH_DSP_VALUEHL
3709			 
3709			;		push hl 
3709			 
3709					; destroy value TOS 
3709			 
3709					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3709 cd 60 20			call macro_forth_dsp_pop 
370c				endm 
# End of macro FORTH_DSP_POP
370c			 
370c			;		pop hl 
370c			 
370c 3e 00				ld a,0 
370e			 
370e bd					cp l 
370f 20 08				jr nz, .tz_notzero 
3711			 
3711 bc					cp h 
3712			 
3712 20 05				jr nz, .tz_notzero 
3714			 
3714			 
3714 21 01 00				ld hl, FORTH_TRUE 
3717 18 03				jr .tz_done 
3719			 
3719 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
371c			 
371c					; push value back onto stack for another op etc 
371c			 
371c			.tz_done: 
371c cd b1 1d				call forth_push_numhl 
371f			 
371f					NEXTW 
371f c3 5e 21			jp macro_next 
3722				endm 
# End of macro NEXTW
3722			.LESS: 
3722				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3722 2f				db WORD_SYS_CORE+27             
3723 8b 37			dw .GT            
3725 02				db 1 + 1 
3726 .. 00			db "<",0              
3728				endm 
# End of macro CWHEAD
3728			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3728				; TODO add floating point number detection 
3728					if DEBUG_FORTH_WORDS_KEY 
3728						DMARK "LES" 
3728 f5				push af  
3729 3a 3d 37			ld a, (.dmark)  
372c 32 6b ee			ld (debug_mark),a  
372f 3a 3e 37			ld a, (.dmark+1)  
3732 32 6c ee			ld (debug_mark+1),a  
3735 3a 3f 37			ld a, (.dmark+2)  
3738 32 6d ee			ld (debug_mark+2),a  
373b 18 03			jr .pastdmark  
373d ..			.dmark: db "LES"  
3740 f1			.pastdmark: pop af  
3741			endm  
# End of macro DMARK
3741						CALLMONITOR 
3741 cd 6f ee			call debug_vector  
3744				endm  
# End of macro CALLMONITOR
3744					endif 
3744					FORTH_DSP 
3744 cd 6e 1f			call macro_forth_dsp 
3747				endm 
# End of macro FORTH_DSP
3747					;v5 FORTH_DSP_VALUE 
3747 7e					ld a,(hl)	; get type of value on TOS 
3748 fe 02				cp DS_TYPE_INUM  
374a 28 00				jr z, .less_inum 
374c			 
374c				if FORTH_ENABLE_FLOATMATH 
374c					jr .less_done 
374c			 
374c				endif 
374c					 
374c			 
374c			.less_inum: 
374c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
374c cd a8 1f			call macro_dsp_valuehl 
374f				endm 
# End of macro FORTH_DSP_VALUEHL
374f			 
374f e5					push hl  ; u2 
3750			 
3750					; destroy value TOS 
3750			 
3750					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3750 cd 60 20			call macro_forth_dsp_pop 
3753				endm 
# End of macro FORTH_DSP_POP
3753			 
3753			 
3753					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3753 cd a8 1f			call macro_dsp_valuehl 
3756				endm 
# End of macro FORTH_DSP_VALUEHL
3756			 
3756 e5					push hl    ; u1 
3757			 
3757					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3757 cd 60 20			call macro_forth_dsp_pop 
375a				endm 
# End of macro FORTH_DSP_POP
375a			 
375a			 
375a b7			 or a      ;clear carry flag 
375b 01 00 00		 ld bc, FORTH_FALSE 
375e e1			  pop hl    ; u1 
375f d1			  pop de    ; u2 
3760 ed 52		  sbc hl,de 
3762 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3764			 
3764 01 01 00		 ld bc, FORTH_TRUE 
3767			.lscont:  
3767 c5					push bc 
3768 e1					pop hl 
3769			 
3769					if DEBUG_FORTH_WORDS 
3769						DMARK "LT1" 
3769 f5				push af  
376a 3a 7e 37			ld a, (.dmark)  
376d 32 6b ee			ld (debug_mark),a  
3770 3a 7f 37			ld a, (.dmark+1)  
3773 32 6c ee			ld (debug_mark+1),a  
3776 3a 80 37			ld a, (.dmark+2)  
3779 32 6d ee			ld (debug_mark+2),a  
377c 18 03			jr .pastdmark  
377e ..			.dmark: db "LT1"  
3781 f1			.pastdmark: pop af  
3782			endm  
# End of macro DMARK
3782						CALLMONITOR 
3782 cd 6f ee			call debug_vector  
3785				endm  
# End of macro CALLMONITOR
3785					endif 
3785 cd b1 1d				call forth_push_numhl 
3788			 
3788					NEXTW 
3788 c3 5e 21			jp macro_next 
378b				endm 
# End of macro NEXTW
378b			.GT: 
378b				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
378b 30				db WORD_SYS_CORE+28             
378c f4 37			dw .EQUAL            
378e 02				db 1 + 1 
378f .. 00			db ">",0              
3791				endm 
# End of macro CWHEAD
3791			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3791				; TODO add floating point number detection 
3791					if DEBUG_FORTH_WORDS_KEY 
3791						DMARK "GRT" 
3791 f5				push af  
3792 3a a6 37			ld a, (.dmark)  
3795 32 6b ee			ld (debug_mark),a  
3798 3a a7 37			ld a, (.dmark+1)  
379b 32 6c ee			ld (debug_mark+1),a  
379e 3a a8 37			ld a, (.dmark+2)  
37a1 32 6d ee			ld (debug_mark+2),a  
37a4 18 03			jr .pastdmark  
37a6 ..			.dmark: db "GRT"  
37a9 f1			.pastdmark: pop af  
37aa			endm  
# End of macro DMARK
37aa						CALLMONITOR 
37aa cd 6f ee			call debug_vector  
37ad				endm  
# End of macro CALLMONITOR
37ad					endif 
37ad					FORTH_DSP 
37ad cd 6e 1f			call macro_forth_dsp 
37b0				endm 
# End of macro FORTH_DSP
37b0					;FORTH_DSP_VALUE 
37b0 7e					ld a,(hl)	; get type of value on TOS 
37b1 fe 02				cp DS_TYPE_INUM  
37b3 28 00				jr z, .gt_inum 
37b5			 
37b5				if FORTH_ENABLE_FLOATMATH 
37b5					jr .gt_done 
37b5			 
37b5				endif 
37b5					 
37b5			 
37b5			.gt_inum: 
37b5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37b5 cd a8 1f			call macro_dsp_valuehl 
37b8				endm 
# End of macro FORTH_DSP_VALUEHL
37b8			 
37b8 e5					push hl  ; u2 
37b9			 
37b9					; destroy value TOS 
37b9			 
37b9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37b9 cd 60 20			call macro_forth_dsp_pop 
37bc				endm 
# End of macro FORTH_DSP_POP
37bc			 
37bc			 
37bc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37bc cd a8 1f			call macro_dsp_valuehl 
37bf				endm 
# End of macro FORTH_DSP_VALUEHL
37bf			 
37bf e5					push hl    ; u1 
37c0			 
37c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37c0 cd 60 20			call macro_forth_dsp_pop 
37c3				endm 
# End of macro FORTH_DSP_POP
37c3			 
37c3			 
37c3 b7			 or a      ;clear carry flag 
37c4 01 00 00		 ld bc, FORTH_FALSE 
37c7 e1			  pop hl    ; u1 
37c8 d1			  pop de    ; u2 
37c9 ed 52		  sbc hl,de 
37cb 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
37cd			 
37cd 01 01 00		 ld bc, FORTH_TRUE 
37d0			.gtcont:  
37d0 c5					push bc 
37d1 e1					pop hl 
37d2			 
37d2					if DEBUG_FORTH_WORDS 
37d2						DMARK "GT1" 
37d2 f5				push af  
37d3 3a e7 37			ld a, (.dmark)  
37d6 32 6b ee			ld (debug_mark),a  
37d9 3a e8 37			ld a, (.dmark+1)  
37dc 32 6c ee			ld (debug_mark+1),a  
37df 3a e9 37			ld a, (.dmark+2)  
37e2 32 6d ee			ld (debug_mark+2),a  
37e5 18 03			jr .pastdmark  
37e7 ..			.dmark: db "GT1"  
37ea f1			.pastdmark: pop af  
37eb			endm  
# End of macro DMARK
37eb						CALLMONITOR 
37eb cd 6f ee			call debug_vector  
37ee				endm  
# End of macro CALLMONITOR
37ee					endif 
37ee cd b1 1d				call forth_push_numhl 
37f1			 
37f1					NEXTW 
37f1 c3 5e 21			jp macro_next 
37f4				endm 
# End of macro NEXTW
37f4			.EQUAL: 
37f4				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
37f4 31				db WORD_SYS_CORE+29             
37f5 5f 38			dw .ENDLOGIC            
37f7 02				db 1 + 1 
37f8 .. 00			db "=",0              
37fa				endm 
# End of macro CWHEAD
37fa			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
37fa				; TODO add floating point number detection 
37fa					if DEBUG_FORTH_WORDS_KEY 
37fa						DMARK "EQ." 
37fa f5				push af  
37fb 3a 0f 38			ld a, (.dmark)  
37fe 32 6b ee			ld (debug_mark),a  
3801 3a 10 38			ld a, (.dmark+1)  
3804 32 6c ee			ld (debug_mark+1),a  
3807 3a 11 38			ld a, (.dmark+2)  
380a 32 6d ee			ld (debug_mark+2),a  
380d 18 03			jr .pastdmark  
380f ..			.dmark: db "EQ."  
3812 f1			.pastdmark: pop af  
3813			endm  
# End of macro DMARK
3813						CALLMONITOR 
3813 cd 6f ee			call debug_vector  
3816				endm  
# End of macro CALLMONITOR
3816					endif 
3816					FORTH_DSP 
3816 cd 6e 1f			call macro_forth_dsp 
3819				endm 
# End of macro FORTH_DSP
3819					;v5 FORTH_DSP_VALUE 
3819 7e					ld a,(hl)	; get type of value on TOS 
381a fe 02				cp DS_TYPE_INUM  
381c 28 00				jr z, .eq_inum 
381e			 
381e				if FORTH_ENABLE_FLOATMATH 
381e					jr .eq_done 
381e			 
381e				endif 
381e					 
381e			 
381e			.eq_inum: 
381e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
381e cd a8 1f			call macro_dsp_valuehl 
3821				endm 
# End of macro FORTH_DSP_VALUEHL
3821			 
3821 e5					push hl 
3822			 
3822					; destroy value TOS 
3822			 
3822					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3822 cd 60 20			call macro_forth_dsp_pop 
3825				endm 
# End of macro FORTH_DSP_POP
3825			 
3825			 
3825					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3825 cd a8 1f			call macro_dsp_valuehl 
3828				endm 
# End of macro FORTH_DSP_VALUEHL
3828			 
3828					; one value on hl get other one back 
3828			 
3828 e5					push hl 
3829			 
3829					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3829 cd 60 20			call macro_forth_dsp_pop 
382c				endm 
# End of macro FORTH_DSP_POP
382c			 
382c 0e 00				ld c, FORTH_FALSE 
382e			 
382e e1					pop hl 
382f d1					pop de 
3830			 
3830 7b					ld a, e 
3831 bd					cp l 
3832			 
3832 20 06				jr nz, .eq_done 
3834			 
3834 7a					ld a, d 
3835 bc					cp h 
3836			 
3836 20 02				jr nz, .eq_done 
3838			 
3838 0e 01				ld c, FORTH_TRUE 
383a					 
383a			 
383a			 
383a			.eq_done: 
383a			 
383a					; TODO push value back onto stack for another op etc 
383a			 
383a 26 00				ld h, 0 
383c 69					ld l, c 
383d					if DEBUG_FORTH_WORDS 
383d						DMARK "EQ1" 
383d f5				push af  
383e 3a 52 38			ld a, (.dmark)  
3841 32 6b ee			ld (debug_mark),a  
3844 3a 53 38			ld a, (.dmark+1)  
3847 32 6c ee			ld (debug_mark+1),a  
384a 3a 54 38			ld a, (.dmark+2)  
384d 32 6d ee			ld (debug_mark+2),a  
3850 18 03			jr .pastdmark  
3852 ..			.dmark: db "EQ1"  
3855 f1			.pastdmark: pop af  
3856			endm  
# End of macro DMARK
3856						CALLMONITOR 
3856 cd 6f ee			call debug_vector  
3859				endm  
# End of macro CALLMONITOR
3859					endif 
3859 cd b1 1d				call forth_push_numhl 
385c			 
385c					NEXTW 
385c c3 5e 21			jp macro_next 
385f				endm 
# End of macro NEXTW
385f			 
385f			 
385f			.ENDLOGIC: 
385f			; eof 
385f			 
385f			 
# End of file forth_words_logic.asm
385f			include "forth_words_maths.asm" 
385f			 
385f			; | ## Maths Words 
385f			 
385f			.PLUS:	 
385f				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
385f 15				db WORD_SYS_CORE+1             
3860 bd 38			dw .NEG            
3862 02				db 1 + 1 
3863 .. 00			db "+",0              
3865				endm 
# End of macro CWHEAD
3865			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3865					if DEBUG_FORTH_WORDS_KEY 
3865						DMARK "PLU" 
3865 f5				push af  
3866 3a 7a 38			ld a, (.dmark)  
3869 32 6b ee			ld (debug_mark),a  
386c 3a 7b 38			ld a, (.dmark+1)  
386f 32 6c ee			ld (debug_mark+1),a  
3872 3a 7c 38			ld a, (.dmark+2)  
3875 32 6d ee			ld (debug_mark+2),a  
3878 18 03			jr .pastdmark  
387a ..			.dmark: db "PLU"  
387d f1			.pastdmark: pop af  
387e			endm  
# End of macro DMARK
387e						CALLMONITOR 
387e cd 6f ee			call debug_vector  
3881				endm  
# End of macro CALLMONITOR
3881					endif 
3881					; add top two values and push back result 
3881			 
3881					;for v5 FORTH_DSP_VALUE 
3881					FORTH_DSP 
3881 cd 6e 1f			call macro_forth_dsp 
3884				endm 
# End of macro FORTH_DSP
3884 7e					ld a,(hl)	; get type of value on TOS 
3885 fe 02				cp DS_TYPE_INUM  
3887 28 03				jr z, .dot_inum 
3889			 
3889					NEXTW 
3889 c3 5e 21			jp macro_next 
388c				endm 
# End of macro NEXTW
388c			 
388c			; float maths 
388c			 
388c				if FORTH_ENABLE_FLOATMATH 
388c						inc hl      ; now at start of numeric as string 
388c			 
388c					if DEBUG_FORTH_MATHS 
388c						DMARK "ADD" 
388c				CALLMONITOR 
388c					endif 
388c			 
388c					;ld ix, hl 
388c					call CON 
388c			 
388c			 
388c					push hl 
388c					 
388c					 
388c			 
388c						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
388c			 
388c					; get next number 
388c			 
388c						FORTH_DSP_VALUE 
388c			 
388c						inc hl      ; now at start of numeric as string 
388c			 
388c					;ld ix, hl 
388c					call CON 
388c			 
388c					push hl 
388c			 
388c			 
388c						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
388c			 
388c						; TODO do add 
388c			 
388c						call IADD 
388c			 
388c						; TODO get result back as ascii 
388c			 
388c						; TODO push result  
388c			 
388c			 
388c			 
388c						jr .dot_done 
388c				endif 
388c			 
388c			.dot_inum: 
388c			 
388c			 
388c					if DEBUG_FORTH_DOT 
388c						DMARK "+IT" 
388c f5				push af  
388d 3a a1 38			ld a, (.dmark)  
3890 32 6b ee			ld (debug_mark),a  
3893 3a a2 38			ld a, (.dmark+1)  
3896 32 6c ee			ld (debug_mark+1),a  
3899 3a a3 38			ld a, (.dmark+2)  
389c 32 6d ee			ld (debug_mark+2),a  
389f 18 03			jr .pastdmark  
38a1 ..			.dmark: db "+IT"  
38a4 f1			.pastdmark: pop af  
38a5			endm  
# End of macro DMARK
38a5				CALLMONITOR 
38a5 cd 6f ee			call debug_vector  
38a8				endm  
# End of macro CALLMONITOR
38a8					endif 
38a8			 
38a8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38a8 cd a8 1f			call macro_dsp_valuehl 
38ab				endm 
# End of macro FORTH_DSP_VALUEHL
38ab			 
38ab				; TODO add floating point number detection 
38ab			 
38ab e5					push hl 
38ac			 
38ac					; destroy value TOS 
38ac			 
38ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38ac cd 60 20			call macro_forth_dsp_pop 
38af				endm 
# End of macro FORTH_DSP_POP
38af			 
38af			 
38af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38af cd a8 1f			call macro_dsp_valuehl 
38b2				endm 
# End of macro FORTH_DSP_VALUEHL
38b2			 
38b2					; one value on hl get other one back 
38b2			 
38b2 d1					pop de 
38b3			 
38b3					; do the add 
38b3			 
38b3 19					add hl,de 
38b4			 
38b4					; save it 
38b4			 
38b4			;		push hl	 
38b4			 
38b4					; 
38b4			 
38b4					; destroy value TOS 
38b4			 
38b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38b4 cd 60 20			call macro_forth_dsp_pop 
38b7				endm 
# End of macro FORTH_DSP_POP
38b7			 
38b7					; TODO push value back onto stack for another op etc 
38b7			 
38b7			;		pop hl 
38b7			 
38b7			.dot_done: 
38b7 cd b1 1d				call forth_push_numhl 
38ba			 
38ba					NEXTW 
38ba c3 5e 21			jp macro_next 
38bd				endm 
# End of macro NEXTW
38bd			.NEG: 
38bd			 
38bd				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
38bd 17				db WORD_SYS_CORE+3             
38be 00 39			dw .DIV            
38c0 02				db 1 + 1 
38c1 .. 00			db "-",0              
38c3				endm 
# End of macro CWHEAD
38c3			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
38c3					if DEBUG_FORTH_WORDS_KEY 
38c3						DMARK "SUB" 
38c3 f5				push af  
38c4 3a d8 38			ld a, (.dmark)  
38c7 32 6b ee			ld (debug_mark),a  
38ca 3a d9 38			ld a, (.dmark+1)  
38cd 32 6c ee			ld (debug_mark+1),a  
38d0 3a da 38			ld a, (.dmark+2)  
38d3 32 6d ee			ld (debug_mark+2),a  
38d6 18 03			jr .pastdmark  
38d8 ..			.dmark: db "SUB"  
38db f1			.pastdmark: pop af  
38dc			endm  
# End of macro DMARK
38dc						CALLMONITOR 
38dc cd 6f ee			call debug_vector  
38df				endm  
# End of macro CALLMONITOR
38df					endif 
38df			 
38df			 
38df				; TODO add floating point number detection 
38df					; v5 FORTH_DSP_VALUE 
38df					FORTH_DSP 
38df cd 6e 1f			call macro_forth_dsp 
38e2				endm 
# End of macro FORTH_DSP
38e2 7e					ld a,(hl)	; get type of value on TOS 
38e3 fe 02				cp DS_TYPE_INUM  
38e5 28 03				jr z, .neg_inum 
38e7			 
38e7					NEXTW 
38e7 c3 5e 21			jp macro_next 
38ea				endm 
# End of macro NEXTW
38ea			 
38ea			; float maths 
38ea			 
38ea				if FORTH_ENABLE_FLOATMATH 
38ea					jr .neg_done 
38ea			 
38ea				endif 
38ea					 
38ea			 
38ea			.neg_inum: 
38ea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38ea cd a8 1f			call macro_dsp_valuehl 
38ed				endm 
# End of macro FORTH_DSP_VALUEHL
38ed			 
38ed e5					push hl 
38ee			 
38ee					; destroy value TOS 
38ee			 
38ee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38ee cd 60 20			call macro_forth_dsp_pop 
38f1				endm 
# End of macro FORTH_DSP_POP
38f1			 
38f1			 
38f1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38f1 cd a8 1f			call macro_dsp_valuehl 
38f4				endm 
# End of macro FORTH_DSP_VALUEHL
38f4			 
38f4					; one value on hl get other one back 
38f4			 
38f4 d1					pop de 
38f5			 
38f5					; do the sub 
38f5			;		ex de, hl 
38f5			 
38f5 ed 52				sbc hl,de 
38f7			 
38f7					; save it 
38f7			 
38f7			;		push hl	 
38f7			 
38f7					; 
38f7			 
38f7					; destroy value TOS 
38f7			 
38f7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38f7 cd 60 20			call macro_forth_dsp_pop 
38fa				endm 
# End of macro FORTH_DSP_POP
38fa			 
38fa					; TODO push value back onto stack for another op etc 
38fa			 
38fa			;		pop hl 
38fa			 
38fa cd b1 1d				call forth_push_numhl 
38fd			.neg_done: 
38fd			 
38fd					NEXTW 
38fd c3 5e 21			jp macro_next 
3900				endm 
# End of macro NEXTW
3900			.DIV: 
3900				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3900 18				db WORD_SYS_CORE+4             
3901 4d 39			dw .MUL            
3903 02				db 1 + 1 
3904 .. 00			db "/",0              
3906				endm 
# End of macro CWHEAD
3906			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3906					if DEBUG_FORTH_WORDS_KEY 
3906						DMARK "DIV" 
3906 f5				push af  
3907 3a 1b 39			ld a, (.dmark)  
390a 32 6b ee			ld (debug_mark),a  
390d 3a 1c 39			ld a, (.dmark+1)  
3910 32 6c ee			ld (debug_mark+1),a  
3913 3a 1d 39			ld a, (.dmark+2)  
3916 32 6d ee			ld (debug_mark+2),a  
3919 18 03			jr .pastdmark  
391b ..			.dmark: db "DIV"  
391e f1			.pastdmark: pop af  
391f			endm  
# End of macro DMARK
391f						CALLMONITOR 
391f cd 6f ee			call debug_vector  
3922				endm  
# End of macro CALLMONITOR
3922					endif 
3922				; TODO add floating point number detection 
3922					; v5 FORTH_DSP_VALUE 
3922					FORTH_DSP 
3922 cd 6e 1f			call macro_forth_dsp 
3925				endm 
# End of macro FORTH_DSP
3925 7e					ld a,(hl)	; get type of value on TOS 
3926 fe 02				cp DS_TYPE_INUM  
3928 28 03				jr z, .div_inum 
392a			 
392a				if FORTH_ENABLE_FLOATMATH 
392a					jr .div_done 
392a			 
392a				endif 
392a					NEXTW 
392a c3 5e 21			jp macro_next 
392d				endm 
# End of macro NEXTW
392d			.div_inum: 
392d			 
392d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
392d cd a8 1f			call macro_dsp_valuehl 
3930				endm 
# End of macro FORTH_DSP_VALUEHL
3930			 
3930 e5					push hl    ; to go to bc 
3931			 
3931					; destroy value TOS 
3931			 
3931					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3931 cd 60 20			call macro_forth_dsp_pop 
3934				endm 
# End of macro FORTH_DSP_POP
3934			 
3934			 
3934					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3934 cd a8 1f			call macro_dsp_valuehl 
3937				endm 
# End of macro FORTH_DSP_VALUEHL
3937			 
3937					; hl to go to de 
3937			 
3937 e5					push hl 
3938			 
3938 c1					pop bc 
3939 d1					pop de		 
393a			 
393a			 
393a					if DEBUG_FORTH_MATHS 
393a						DMARK "DIV" 
393a				CALLMONITOR 
393a					endif 
393a					; one value on hl but move to a get other one back 
393a			 
393a			        
393a cd 43 0d			call Div16 
393d			 
393d			;	push af	 
393d e5				push hl 
393e c5				push bc 
393f			 
393f					if DEBUG_FORTH_MATHS 
393f						DMARK "DI1" 
393f				CALLMONITOR 
393f					endif 
393f			 
393f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
393f cd 60 20			call macro_forth_dsp_pop 
3942				endm 
# End of macro FORTH_DSP_POP
3942			 
3942			 
3942			 
3942 e1					pop hl    ; result 
3943			 
3943 cd b1 1d				call forth_push_numhl 
3946			 
3946 e1					pop hl    ; reminder 
3947			;		ld h,0 
3947			;		ld l,d 
3947			 
3947 cd b1 1d				call forth_push_numhl 
394a			.div_done: 
394a					NEXTW 
394a c3 5e 21			jp macro_next 
394d				endm 
# End of macro NEXTW
394d			.MUL: 
394d				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
394d 19				db WORD_SYS_CORE+5             
394e 92 39			dw .MIN            
3950 02				db 1 + 1 
3951 .. 00			db "*",0              
3953				endm 
# End of macro CWHEAD
3953			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3953				; TODO add floating point number detection 
3953					if DEBUG_FORTH_WORDS_KEY 
3953						DMARK "MUL" 
3953 f5				push af  
3954 3a 68 39			ld a, (.dmark)  
3957 32 6b ee			ld (debug_mark),a  
395a 3a 69 39			ld a, (.dmark+1)  
395d 32 6c ee			ld (debug_mark+1),a  
3960 3a 6a 39			ld a, (.dmark+2)  
3963 32 6d ee			ld (debug_mark+2),a  
3966 18 03			jr .pastdmark  
3968 ..			.dmark: db "MUL"  
396b f1			.pastdmark: pop af  
396c			endm  
# End of macro DMARK
396c						CALLMONITOR 
396c cd 6f ee			call debug_vector  
396f				endm  
# End of macro CALLMONITOR
396f					endif 
396f					FORTH_DSP 
396f cd 6e 1f			call macro_forth_dsp 
3972				endm 
# End of macro FORTH_DSP
3972					; v5 FORTH_DSP_VALUE 
3972 7e					ld a,(hl)	; get type of value on TOS 
3973 fe 02				cp DS_TYPE_INUM  
3975 28 03				jr z, .mul_inum 
3977			 
3977				if FORTH_ENABLE_FLOATMATH 
3977					jr .mul_done 
3977			 
3977				endif 
3977			 
3977					NEXTW 
3977 c3 5e 21			jp macro_next 
397a				endm 
# End of macro NEXTW
397a			.mul_inum:	 
397a			 
397a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
397a cd a8 1f			call macro_dsp_valuehl 
397d				endm 
# End of macro FORTH_DSP_VALUEHL
397d			 
397d e5					push hl 
397e			 
397e					; destroy value TOS 
397e			 
397e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
397e cd 60 20			call macro_forth_dsp_pop 
3981				endm 
# End of macro FORTH_DSP_POP
3981			 
3981			 
3981					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3981 cd a8 1f			call macro_dsp_valuehl 
3984				endm 
# End of macro FORTH_DSP_VALUEHL
3984			 
3984					; one value on hl but move to a get other one back 
3984			 
3984 7d					ld a, l 
3985			 
3985 d1					pop de 
3986			 
3986					; do the mull 
3986			;		ex de, hl 
3986			 
3986 cd 69 0d				call Mult16 
3989					; save it 
3989			 
3989			;		push hl	 
3989			 
3989					; 
3989			 
3989					; destroy value TOS 
3989			 
3989					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3989 cd 60 20			call macro_forth_dsp_pop 
398c				endm 
# End of macro FORTH_DSP_POP
398c			 
398c					; TODO push value back onto stack for another op etc 
398c			 
398c			;		pop hl 
398c			 
398c cd b1 1d				call forth_push_numhl 
398f			 
398f			.mul_done: 
398f					NEXTW 
398f c3 5e 21			jp macro_next 
3992				endm 
# End of macro NEXTW
3992			 
3992			 
3992			 
3992			 
3992			.MIN: 
3992				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3992 49				db WORD_SYS_CORE+53             
3993 13 3a			dw .MAX            
3995 04				db 3 + 1 
3996 .. 00			db "MIN",0              
399a				endm 
# End of macro CWHEAD
399a			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
399a					if DEBUG_FORTH_WORDS_KEY 
399a						DMARK "MIN" 
399a f5				push af  
399b 3a af 39			ld a, (.dmark)  
399e 32 6b ee			ld (debug_mark),a  
39a1 3a b0 39			ld a, (.dmark+1)  
39a4 32 6c ee			ld (debug_mark+1),a  
39a7 3a b1 39			ld a, (.dmark+2)  
39aa 32 6d ee			ld (debug_mark+2),a  
39ad 18 03			jr .pastdmark  
39af ..			.dmark: db "MIN"  
39b2 f1			.pastdmark: pop af  
39b3			endm  
# End of macro DMARK
39b3						CALLMONITOR 
39b3 cd 6f ee			call debug_vector  
39b6				endm  
# End of macro CALLMONITOR
39b6					endif 
39b6					; get u2 
39b6			 
39b6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39b6 cd a8 1f			call macro_dsp_valuehl 
39b9				endm 
# End of macro FORTH_DSP_VALUEHL
39b9			 
39b9 e5					push hl   ; u2 
39ba			 
39ba					; destroy value TOS 
39ba			 
39ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39ba cd 60 20			call macro_forth_dsp_pop 
39bd				endm 
# End of macro FORTH_DSP_POP
39bd			 
39bd					; get u1 
39bd			 
39bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39bd cd a8 1f			call macro_dsp_valuehl 
39c0				endm 
# End of macro FORTH_DSP_VALUEHL
39c0			 
39c0 e5					push hl  ; u1 
39c1			 
39c1					; destroy value TOS 
39c1			 
39c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39c1 cd 60 20			call macro_forth_dsp_pop 
39c4				endm 
# End of macro FORTH_DSP_POP
39c4			 
39c4 b7			 or a      ;clear carry flag 
39c5 e1			  pop hl    ; u1 
39c6 d1			  pop de    ; u2 
39c7 e5				push hl   ; saved in case hl is lowest 
39c8 ed 52		  sbc hl,de 
39ca 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
39cc			 
39cc e1				pop hl 
39cd					if DEBUG_FORTH_WORDS 
39cd						DMARK "MIN" 
39cd f5				push af  
39ce 3a e2 39			ld a, (.dmark)  
39d1 32 6b ee			ld (debug_mark),a  
39d4 3a e3 39			ld a, (.dmark+1)  
39d7 32 6c ee			ld (debug_mark+1),a  
39da 3a e4 39			ld a, (.dmark+2)  
39dd 32 6d ee			ld (debug_mark+2),a  
39e0 18 03			jr .pastdmark  
39e2 ..			.dmark: db "MIN"  
39e5 f1			.pastdmark: pop af  
39e6			endm  
# End of macro DMARK
39e6						CALLMONITOR 
39e6 cd 6f ee			call debug_vector  
39e9				endm  
# End of macro CALLMONITOR
39e9					endif 
39e9 cd b1 1d				call forth_push_numhl 
39ec			 
39ec				       NEXTW 
39ec c3 5e 21			jp macro_next 
39ef				endm 
# End of macro NEXTW
39ef			 
39ef			.mincont:  
39ef c1				pop bc   ; tidy up 
39f0 eb				ex de , hl  
39f1					if DEBUG_FORTH_WORDS 
39f1						DMARK "MI1" 
39f1 f5				push af  
39f2 3a 06 3a			ld a, (.dmark)  
39f5 32 6b ee			ld (debug_mark),a  
39f8 3a 07 3a			ld a, (.dmark+1)  
39fb 32 6c ee			ld (debug_mark+1),a  
39fe 3a 08 3a			ld a, (.dmark+2)  
3a01 32 6d ee			ld (debug_mark+2),a  
3a04 18 03			jr .pastdmark  
3a06 ..			.dmark: db "MI1"  
3a09 f1			.pastdmark: pop af  
3a0a			endm  
# End of macro DMARK
3a0a						CALLMONITOR 
3a0a cd 6f ee			call debug_vector  
3a0d				endm  
# End of macro CALLMONITOR
3a0d					endif 
3a0d cd b1 1d				call forth_push_numhl 
3a10			 
3a10				       NEXTW 
3a10 c3 5e 21			jp macro_next 
3a13				endm 
# End of macro NEXTW
3a13			.MAX: 
3a13				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3a13 4a				db WORD_SYS_CORE+54             
3a14 94 3a			dw .RND16            
3a16 04				db 3 + 1 
3a17 .. 00			db "MAX",0              
3a1b				endm 
# End of macro CWHEAD
3a1b			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3a1b					if DEBUG_FORTH_WORDS_KEY 
3a1b						DMARK "MAX" 
3a1b f5				push af  
3a1c 3a 30 3a			ld a, (.dmark)  
3a1f 32 6b ee			ld (debug_mark),a  
3a22 3a 31 3a			ld a, (.dmark+1)  
3a25 32 6c ee			ld (debug_mark+1),a  
3a28 3a 32 3a			ld a, (.dmark+2)  
3a2b 32 6d ee			ld (debug_mark+2),a  
3a2e 18 03			jr .pastdmark  
3a30 ..			.dmark: db "MAX"  
3a33 f1			.pastdmark: pop af  
3a34			endm  
# End of macro DMARK
3a34						CALLMONITOR 
3a34 cd 6f ee			call debug_vector  
3a37				endm  
# End of macro CALLMONITOR
3a37					endif 
3a37					; get u2 
3a37			 
3a37					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a37 cd a8 1f			call macro_dsp_valuehl 
3a3a				endm 
# End of macro FORTH_DSP_VALUEHL
3a3a			 
3a3a e5					push hl   ; u2 
3a3b			 
3a3b					; destroy value TOS 
3a3b			 
3a3b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a3b cd 60 20			call macro_forth_dsp_pop 
3a3e				endm 
# End of macro FORTH_DSP_POP
3a3e			 
3a3e					; get u1 
3a3e			 
3a3e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a3e cd a8 1f			call macro_dsp_valuehl 
3a41				endm 
# End of macro FORTH_DSP_VALUEHL
3a41			 
3a41 e5					push hl  ; u1 
3a42			 
3a42					; destroy value TOS 
3a42			 
3a42					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a42 cd 60 20			call macro_forth_dsp_pop 
3a45				endm 
# End of macro FORTH_DSP_POP
3a45			 
3a45 b7			 or a      ;clear carry flag 
3a46 e1			  pop hl    ; u1 
3a47 d1			  pop de    ; u2 
3a48 e5				push hl   ; saved in case hl is lowest 
3a49 ed 52		  sbc hl,de 
3a4b 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3a4d			 
3a4d e1				pop hl 
3a4e					if DEBUG_FORTH_WORDS 
3a4e						DMARK "MAX" 
3a4e f5				push af  
3a4f 3a 63 3a			ld a, (.dmark)  
3a52 32 6b ee			ld (debug_mark),a  
3a55 3a 64 3a			ld a, (.dmark+1)  
3a58 32 6c ee			ld (debug_mark+1),a  
3a5b 3a 65 3a			ld a, (.dmark+2)  
3a5e 32 6d ee			ld (debug_mark+2),a  
3a61 18 03			jr .pastdmark  
3a63 ..			.dmark: db "MAX"  
3a66 f1			.pastdmark: pop af  
3a67			endm  
# End of macro DMARK
3a67						CALLMONITOR 
3a67 cd 6f ee			call debug_vector  
3a6a				endm  
# End of macro CALLMONITOR
3a6a					endif 
3a6a cd b1 1d				call forth_push_numhl 
3a6d			 
3a6d				       NEXTW 
3a6d c3 5e 21			jp macro_next 
3a70				endm 
# End of macro NEXTW
3a70			 
3a70			.maxcont:  
3a70 c1				pop bc   ; tidy up 
3a71 eb				ex de , hl  
3a72					if DEBUG_FORTH_WORDS 
3a72						DMARK "MA1" 
3a72 f5				push af  
3a73 3a 87 3a			ld a, (.dmark)  
3a76 32 6b ee			ld (debug_mark),a  
3a79 3a 88 3a			ld a, (.dmark+1)  
3a7c 32 6c ee			ld (debug_mark+1),a  
3a7f 3a 89 3a			ld a, (.dmark+2)  
3a82 32 6d ee			ld (debug_mark+2),a  
3a85 18 03			jr .pastdmark  
3a87 ..			.dmark: db "MA1"  
3a8a f1			.pastdmark: pop af  
3a8b			endm  
# End of macro DMARK
3a8b						CALLMONITOR 
3a8b cd 6f ee			call debug_vector  
3a8e				endm  
# End of macro CALLMONITOR
3a8e					endif 
3a8e cd b1 1d				call forth_push_numhl 
3a91				       NEXTW 
3a91 c3 5e 21			jp macro_next 
3a94				endm 
# End of macro NEXTW
3a94			 
3a94			.RND16: 
3a94				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3a94 4e				db WORD_SYS_CORE+58             
3a95 c3 3a			dw .RND8            
3a97 06				db 5 + 1 
3a98 .. 00			db "RND16",0              
3a9e				endm 
# End of macro CWHEAD
3a9e			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3a9e					if DEBUG_FORTH_WORDS_KEY 
3a9e						DMARK "R16" 
3a9e f5				push af  
3a9f 3a b3 3a			ld a, (.dmark)  
3aa2 32 6b ee			ld (debug_mark),a  
3aa5 3a b4 3a			ld a, (.dmark+1)  
3aa8 32 6c ee			ld (debug_mark+1),a  
3aab 3a b5 3a			ld a, (.dmark+2)  
3aae 32 6d ee			ld (debug_mark+2),a  
3ab1 18 03			jr .pastdmark  
3ab3 ..			.dmark: db "R16"  
3ab6 f1			.pastdmark: pop af  
3ab7			endm  
# End of macro DMARK
3ab7						CALLMONITOR 
3ab7 cd 6f ee			call debug_vector  
3aba				endm  
# End of macro CALLMONITOR
3aba					endif 
3aba cd 0d 0d				call prng16  
3abd cd b1 1d				call forth_push_numhl 
3ac0				       NEXTW 
3ac0 c3 5e 21			jp macro_next 
3ac3				endm 
# End of macro NEXTW
3ac3			.RND8: 
3ac3				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3ac3 60				db WORD_SYS_CORE+76             
3ac4 f8 3a			dw .RND            
3ac6 05				db 4 + 1 
3ac7 .. 00			db "RND8",0              
3acc				endm 
# End of macro CWHEAD
3acc			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3acc					if DEBUG_FORTH_WORDS_KEY 
3acc						DMARK "RN8" 
3acc f5				push af  
3acd 3a e1 3a			ld a, (.dmark)  
3ad0 32 6b ee			ld (debug_mark),a  
3ad3 3a e2 3a			ld a, (.dmark+1)  
3ad6 32 6c ee			ld (debug_mark+1),a  
3ad9 3a e3 3a			ld a, (.dmark+2)  
3adc 32 6d ee			ld (debug_mark+2),a  
3adf 18 03			jr .pastdmark  
3ae1 ..			.dmark: db "RN8"  
3ae4 f1			.pastdmark: pop af  
3ae5			endm  
# End of macro DMARK
3ae5						CALLMONITOR 
3ae5 cd 6f ee			call debug_vector  
3ae8				endm  
# End of macro CALLMONITOR
3ae8					endif 
3ae8 2a a9 eb				ld hl,(xrandc) 
3aeb 23					inc hl 
3aec cd 27 0d				call xrnd 
3aef 6f					ld l,a	 
3af0 26 00				ld h,0 
3af2 cd b1 1d				call forth_push_numhl 
3af5				       NEXTW 
3af5 c3 5e 21			jp macro_next 
3af8				endm 
# End of macro NEXTW
3af8			.RND: 
3af8				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3af8 60				db WORD_SYS_CORE+76             
3af9 fe 3b			dw .ENDMATHS            
3afb 04				db 3 + 1 
3afc .. 00			db "RND",0              
3b00				endm 
# End of macro CWHEAD
3b00			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3b00			 
3b00					if DEBUG_FORTH_WORDS_KEY 
3b00						DMARK "RND" 
3b00 f5				push af  
3b01 3a 15 3b			ld a, (.dmark)  
3b04 32 6b ee			ld (debug_mark),a  
3b07 3a 16 3b			ld a, (.dmark+1)  
3b0a 32 6c ee			ld (debug_mark+1),a  
3b0d 3a 17 3b			ld a, (.dmark+2)  
3b10 32 6d ee			ld (debug_mark+2),a  
3b13 18 03			jr .pastdmark  
3b15 ..			.dmark: db "RND"  
3b18 f1			.pastdmark: pop af  
3b19			endm  
# End of macro DMARK
3b19						CALLMONITOR 
3b19 cd 6f ee			call debug_vector  
3b1c				endm  
# End of macro CALLMONITOR
3b1c					endif 
3b1c					 
3b1c					FORTH_DSP_VALUEHL    ; upper range 
3b1c cd a8 1f			call macro_dsp_valuehl 
3b1f				endm 
# End of macro FORTH_DSP_VALUEHL
3b1f			 
3b1f 22 ad eb				ld (LFSRSeed), hl	 
3b22			 
3b22					if DEBUG_FORTH_WORDS 
3b22						DMARK "RN1" 
3b22 f5				push af  
3b23 3a 37 3b			ld a, (.dmark)  
3b26 32 6b ee			ld (debug_mark),a  
3b29 3a 38 3b			ld a, (.dmark+1)  
3b2c 32 6c ee			ld (debug_mark+1),a  
3b2f 3a 39 3b			ld a, (.dmark+2)  
3b32 32 6d ee			ld (debug_mark+2),a  
3b35 18 03			jr .pastdmark  
3b37 ..			.dmark: db "RN1"  
3b3a f1			.pastdmark: pop af  
3b3b			endm  
# End of macro DMARK
3b3b						CALLMONITOR 
3b3b cd 6f ee			call debug_vector  
3b3e				endm  
# End of macro CALLMONITOR
3b3e					endif 
3b3e					FORTH_DSP_POP 
3b3e cd 60 20			call macro_forth_dsp_pop 
3b41				endm 
# End of macro FORTH_DSP_POP
3b41			 
3b41					FORTH_DSP_VALUEHL    ; low range 
3b41 cd a8 1f			call macro_dsp_valuehl 
3b44				endm 
# End of macro FORTH_DSP_VALUEHL
3b44			 
3b44					if DEBUG_FORTH_WORDS 
3b44						DMARK "RN2" 
3b44 f5				push af  
3b45 3a 59 3b			ld a, (.dmark)  
3b48 32 6b ee			ld (debug_mark),a  
3b4b 3a 5a 3b			ld a, (.dmark+1)  
3b4e 32 6c ee			ld (debug_mark+1),a  
3b51 3a 5b 3b			ld a, (.dmark+2)  
3b54 32 6d ee			ld (debug_mark+2),a  
3b57 18 03			jr .pastdmark  
3b59 ..			.dmark: db "RN2"  
3b5c f1			.pastdmark: pop af  
3b5d			endm  
# End of macro DMARK
3b5d						CALLMONITOR 
3b5d cd 6f ee			call debug_vector  
3b60				endm  
# End of macro CALLMONITOR
3b60					endif 
3b60 22 af eb				ld (LFSRSeed+2), hl 
3b63			 
3b63					FORTH_DSP_POP 
3b63 cd 60 20			call macro_forth_dsp_pop 
3b66				endm 
# End of macro FORTH_DSP_POP
3b66			 
3b66 e5					push hl 
3b67			 
3b67 e1			.inrange:	pop hl 
3b68 cd 0d 0d				call prng16  
3b6b					if DEBUG_FORTH_WORDS 
3b6b						DMARK "RN3" 
3b6b f5				push af  
3b6c 3a 80 3b			ld a, (.dmark)  
3b6f 32 6b ee			ld (debug_mark),a  
3b72 3a 81 3b			ld a, (.dmark+1)  
3b75 32 6c ee			ld (debug_mark+1),a  
3b78 3a 82 3b			ld a, (.dmark+2)  
3b7b 32 6d ee			ld (debug_mark+2),a  
3b7e 18 03			jr .pastdmark  
3b80 ..			.dmark: db "RN3"  
3b83 f1			.pastdmark: pop af  
3b84			endm  
# End of macro DMARK
3b84						CALLMONITOR 
3b84 cd 6f ee			call debug_vector  
3b87				endm  
# End of macro CALLMONITOR
3b87					endif 
3b87					 
3b87					; if the range is 8bit knock out the high byte 
3b87			 
3b87 ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
3b8b			 
3b8b 3e 00				ld a, 0 
3b8d ba					cp d  
3b8e 20 1e				jr nz, .hirange 
3b90 26 00				ld h, 0   ; knock it down to 8bit 
3b92			 
3b92					if DEBUG_FORTH_WORDS 
3b92						DMARK "RNk" 
3b92 f5				push af  
3b93 3a a7 3b			ld a, (.dmark)  
3b96 32 6b ee			ld (debug_mark),a  
3b99 3a a8 3b			ld a, (.dmark+1)  
3b9c 32 6c ee			ld (debug_mark+1),a  
3b9f 3a a9 3b			ld a, (.dmark+2)  
3ba2 32 6d ee			ld (debug_mark+2),a  
3ba5 18 03			jr .pastdmark  
3ba7 ..			.dmark: db "RNk"  
3baa f1			.pastdmark: pop af  
3bab			endm  
# End of macro DMARK
3bab						CALLMONITOR 
3bab cd 6f ee			call debug_vector  
3bae				endm  
# End of macro CALLMONITOR
3bae					endif 
3bae			.hirange:   
3bae e5					push hl  
3baf b7					or a  
3bb0 ed 52		                sbc hl, de 
3bb2			 
3bb2					;call cmp16 
3bb2			 
3bb2 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3bb4 e1					pop hl 
3bb5 e5					push hl 
3bb6			 
3bb6					if DEBUG_FORTH_WORDS 
3bb6						DMARK "RN4" 
3bb6 f5				push af  
3bb7 3a cb 3b			ld a, (.dmark)  
3bba 32 6b ee			ld (debug_mark),a  
3bbd 3a cc 3b			ld a, (.dmark+1)  
3bc0 32 6c ee			ld (debug_mark+1),a  
3bc3 3a cd 3b			ld a, (.dmark+2)  
3bc6 32 6d ee			ld (debug_mark+2),a  
3bc9 18 03			jr .pastdmark  
3bcb ..			.dmark: db "RN4"  
3bce f1			.pastdmark: pop af  
3bcf			endm  
# End of macro DMARK
3bcf						CALLMONITOR 
3bcf cd 6f ee			call debug_vector  
3bd2				endm  
# End of macro CALLMONITOR
3bd2					endif 
3bd2 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
3bd6					;call cmp16 
3bd6				 
3bd6 b7					or a  
3bd7 ed 52		                sbc hl, de 
3bd9 38 8c				jr c, .inrange 
3bdb			 
3bdb e1					pop hl 
3bdc					 
3bdc					if DEBUG_FORTH_WORDS 
3bdc						DMARK "RNd" 
3bdc f5				push af  
3bdd 3a f1 3b			ld a, (.dmark)  
3be0 32 6b ee			ld (debug_mark),a  
3be3 3a f2 3b			ld a, (.dmark+1)  
3be6 32 6c ee			ld (debug_mark+1),a  
3be9 3a f3 3b			ld a, (.dmark+2)  
3bec 32 6d ee			ld (debug_mark+2),a  
3bef 18 03			jr .pastdmark  
3bf1 ..			.dmark: db "RNd"  
3bf4 f1			.pastdmark: pop af  
3bf5			endm  
# End of macro DMARK
3bf5						CALLMONITOR 
3bf5 cd 6f ee			call debug_vector  
3bf8				endm  
# End of macro CALLMONITOR
3bf8					endif 
3bf8			 
3bf8			 
3bf8 cd b1 1d				call forth_push_numhl 
3bfb				       NEXTW 
3bfb c3 5e 21			jp macro_next 
3bfe				endm 
# End of macro NEXTW
3bfe			 
3bfe			.ENDMATHS: 
3bfe			 
3bfe			; eof 
3bfe			 
# End of file forth_words_maths.asm
3bfe			include "forth_words_display.asm" 
3bfe			 
3bfe			; | ## Display Words 
3bfe			 
3bfe			.ACT: 
3bfe			 
3bfe				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3bfe 62				db WORD_SYS_CORE+78             
3bff 4a 3c			dw .INFO            
3c01 07				db 6 + 1 
3c02 .. 00			db "ACTIVE",0              
3c09				endm 
# End of macro CWHEAD
3c09			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3c09			;  
3c09			; | | To display a pulsing activity indicator in a processing loop do this... 
3c09			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
3c09			 
3c09					if DEBUG_FORTH_WORDS_KEY 
3c09						DMARK "ACT" 
3c09 f5				push af  
3c0a 3a 1e 3c			ld a, (.dmark)  
3c0d 32 6b ee			ld (debug_mark),a  
3c10 3a 1f 3c			ld a, (.dmark+1)  
3c13 32 6c ee			ld (debug_mark+1),a  
3c16 3a 20 3c			ld a, (.dmark+2)  
3c19 32 6d ee			ld (debug_mark+2),a  
3c1c 18 03			jr .pastdmark  
3c1e ..			.dmark: db "ACT"  
3c21 f1			.pastdmark: pop af  
3c22			endm  
# End of macro DMARK
3c22						CALLMONITOR 
3c22 cd 6f ee			call debug_vector  
3c25				endm  
# End of macro CALLMONITOR
3c25					endif 
3c25 cd 10 0b				call active 
3c28					if DEBUG_FORTH_WORDS 
3c28						DMARK "ACp" 
3c28 f5				push af  
3c29 3a 3d 3c			ld a, (.dmark)  
3c2c 32 6b ee			ld (debug_mark),a  
3c2f 3a 3e 3c			ld a, (.dmark+1)  
3c32 32 6c ee			ld (debug_mark+1),a  
3c35 3a 3f 3c			ld a, (.dmark+2)  
3c38 32 6d ee			ld (debug_mark+2),a  
3c3b 18 03			jr .pastdmark  
3c3d ..			.dmark: db "ACp"  
3c40 f1			.pastdmark: pop af  
3c41			endm  
# End of macro DMARK
3c41						CALLMONITOR 
3c41 cd 6f ee			call debug_vector  
3c44				endm  
# End of macro CALLMONITOR
3c44					endif 
3c44 cd 1f 1e				call forth_push_str 
3c47			 
3c47					NEXTW 
3c47 c3 5e 21			jp macro_next 
3c4a				endm 
# End of macro NEXTW
3c4a			.INFO: 
3c4a			 
3c4a				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3c4a 62				db WORD_SYS_CORE+78             
3c4b 67 3c			dw .ATP            
3c4d 05				db 4 + 1 
3c4e .. 00			db "INFO",0              
3c53				endm 
# End of macro CWHEAD
3c53			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3c53					FORTH_DSP_VALUEHL 
3c53 cd a8 1f			call macro_dsp_valuehl 
3c56				endm 
# End of macro FORTH_DSP_VALUEHL
3c56			 
3c56					FORTH_DSP_POP 
3c56 cd 60 20			call macro_forth_dsp_pop 
3c59				endm 
# End of macro FORTH_DSP_POP
3c59			 
3c59 e5					push hl 
3c5a			 
3c5a					FORTH_DSP_VALUEHL 
3c5a cd a8 1f			call macro_dsp_valuehl 
3c5d				endm 
# End of macro FORTH_DSP_VALUEHL
3c5d			 
3c5d					FORTH_DSP_POP 
3c5d cd 60 20			call macro_forth_dsp_pop 
3c60				endm 
# End of macro FORTH_DSP_POP
3c60			 
3c60 d1					pop de 
3c61			 
3c61 cd 4a 0b				call info_panel 
3c64			 
3c64			 
3c64					NEXTW 
3c64 c3 5e 21			jp macro_next 
3c67				endm 
# End of macro NEXTW
3c67			.ATP: 
3c67				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3c67 62				db WORD_SYS_CORE+78             
3c68 de 3c			dw .FB            
3c6a 04				db 3 + 1 
3c6b .. 00			db "AT?",0              
3c6f				endm 
# End of macro CWHEAD
3c6f			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3c6f					if DEBUG_FORTH_WORDS_KEY 
3c6f						DMARK "AT?" 
3c6f f5				push af  
3c70 3a 84 3c			ld a, (.dmark)  
3c73 32 6b ee			ld (debug_mark),a  
3c76 3a 85 3c			ld a, (.dmark+1)  
3c79 32 6c ee			ld (debug_mark+1),a  
3c7c 3a 86 3c			ld a, (.dmark+2)  
3c7f 32 6d ee			ld (debug_mark+2),a  
3c82 18 03			jr .pastdmark  
3c84 ..			.dmark: db "AT?"  
3c87 f1			.pastdmark: pop af  
3c88			endm  
# End of macro DMARK
3c88						CALLMONITOR 
3c88 cd 6f ee			call debug_vector  
3c8b				endm  
# End of macro CALLMONITOR
3c8b					endif 
3c8b 3a 5e ea				ld a, (f_cursor_ptr) 
3c8e			 
3c8e			if DEBUG_FORTH_WORDS 
3c8e				DMARK "AT?" 
3c8e f5				push af  
3c8f 3a a3 3c			ld a, (.dmark)  
3c92 32 6b ee			ld (debug_mark),a  
3c95 3a a4 3c			ld a, (.dmark+1)  
3c98 32 6c ee			ld (debug_mark+1),a  
3c9b 3a a5 3c			ld a, (.dmark+2)  
3c9e 32 6d ee			ld (debug_mark+2),a  
3ca1 18 03			jr .pastdmark  
3ca3 ..			.dmark: db "AT?"  
3ca6 f1			.pastdmark: pop af  
3ca7			endm  
# End of macro DMARK
3ca7				CALLMONITOR 
3ca7 cd 6f ee			call debug_vector  
3caa				endm  
# End of macro CALLMONITOR
3caa			endif	 
3caa					; count the number of rows 
3caa			 
3caa 06 00				ld b, 0 
3cac 4f			.atpr:		ld c, a    ; save in case we go below zero 
3cad d6 28				sub display_cols 
3caf f2 b5 3c				jp p, .atprunder 
3cb2 04					inc b 
3cb3 18 f7				jr .atpr 
3cb5			.atprunder:	 
3cb5			if DEBUG_FORTH_WORDS 
3cb5				DMARK "A?2" 
3cb5 f5				push af  
3cb6 3a ca 3c			ld a, (.dmark)  
3cb9 32 6b ee			ld (debug_mark),a  
3cbc 3a cb 3c			ld a, (.dmark+1)  
3cbf 32 6c ee			ld (debug_mark+1),a  
3cc2 3a cc 3c			ld a, (.dmark+2)  
3cc5 32 6d ee			ld (debug_mark+2),a  
3cc8 18 03			jr .pastdmark  
3cca ..			.dmark: db "A?2"  
3ccd f1			.pastdmark: pop af  
3cce			endm  
# End of macro DMARK
3cce				CALLMONITOR 
3cce cd 6f ee			call debug_vector  
3cd1				endm  
# End of macro CALLMONITOR
3cd1			endif	 
3cd1 26 00				ld h, 0 
3cd3 69					ld l, c 
3cd4 cd b1 1d				call forth_push_numhl 
3cd7 68					ld l, b  
3cd8 cd b1 1d				call forth_push_numhl 
3cdb			 
3cdb			 
3cdb				NEXTW 
3cdb c3 5e 21			jp macro_next 
3cde				endm 
# End of macro NEXTW
3cde			 
3cde			.FB: 
3cde				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3cde 1b				db WORD_SYS_CORE+7             
3cdf 2c 3d			dw .EMIT            
3ce1 03				db 2 + 1 
3ce2 .. 00			db "FB",0              
3ce5				endm 
# End of macro CWHEAD
3ce5			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3ce5			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3ce5			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3ce5			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3ce5					if DEBUG_FORTH_WORDS_KEY 
3ce5						DMARK "FB." 
3ce5 f5				push af  
3ce6 3a fa 3c			ld a, (.dmark)  
3ce9 32 6b ee			ld (debug_mark),a  
3cec 3a fb 3c			ld a, (.dmark+1)  
3cef 32 6c ee			ld (debug_mark+1),a  
3cf2 3a fc 3c			ld a, (.dmark+2)  
3cf5 32 6d ee			ld (debug_mark+2),a  
3cf8 18 03			jr .pastdmark  
3cfa ..			.dmark: db "FB."  
3cfd f1			.pastdmark: pop af  
3cfe			endm  
# End of macro DMARK
3cfe						CALLMONITOR 
3cfe cd 6f ee			call debug_vector  
3d01				endm  
# End of macro CALLMONITOR
3d01					endif 
3d01			 
3d01					FORTH_DSP_VALUEHL 
3d01 cd a8 1f			call macro_dsp_valuehl 
3d04				endm 
# End of macro FORTH_DSP_VALUEHL
3d04			 
3d04 7d					ld a, l 
3d05 fe 01				cp 1 
3d07 20 05				jr nz, .fbn1 
3d09 21 10 ed				ld hl, display_fb1 
3d0c 18 15				jr .fbset 
3d0e fe 02		.fbn1:		cp 2 
3d10 20 05				jr nz, .fbn2 
3d12 21 ce eb				ld hl, display_fb2 
3d15 18 0c				jr .fbset 
3d17 fe 03		.fbn2:		cp 3 
3d19 20 05				jr nz, .fbn3 
3d1b 21 6f ec				ld hl, display_fb3 
3d1e 18 03				jr .fbset 
3d20			.fbn3:		 ; if invalid number select first 
3d20 21 10 ed				ld hl, display_fb1 
3d23 22 cc eb		.fbset:		ld (display_fb_active), hl 
3d26			 
3d26					FORTH_DSP_POP 
3d26 cd 60 20			call macro_forth_dsp_pop 
3d29				endm 
# End of macro FORTH_DSP_POP
3d29			 
3d29					NEXTW 
3d29 c3 5e 21			jp macro_next 
3d2c				endm 
# End of macro NEXTW
3d2c			 
3d2c			 
3d2c			.EMIT: 
3d2c				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3d2c 1b				db WORD_SYS_CORE+7             
3d2d 7d 3d			dw .DOTH            
3d2f 05				db 4 + 1 
3d30 .. 00			db "EMIT",0              
3d35				endm 
# End of macro CWHEAD
3d35			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3d35					; get value off TOS and display it 
3d35			 
3d35					if DEBUG_FORTH_WORDS_KEY 
3d35						DMARK "EMT" 
3d35 f5				push af  
3d36 3a 4a 3d			ld a, (.dmark)  
3d39 32 6b ee			ld (debug_mark),a  
3d3c 3a 4b 3d			ld a, (.dmark+1)  
3d3f 32 6c ee			ld (debug_mark+1),a  
3d42 3a 4c 3d			ld a, (.dmark+2)  
3d45 32 6d ee			ld (debug_mark+2),a  
3d48 18 03			jr .pastdmark  
3d4a ..			.dmark: db "EMT"  
3d4d f1			.pastdmark: pop af  
3d4e			endm  
# End of macro DMARK
3d4e						CALLMONITOR 
3d4e cd 6f ee			call debug_vector  
3d51				endm  
# End of macro CALLMONITOR
3d51					endif 
3d51			 
3d51					FORTH_DSP_VALUEHL 
3d51 cd a8 1f			call macro_dsp_valuehl 
3d54				endm 
# End of macro FORTH_DSP_VALUEHL
3d54			 
3d54 7d					ld a,l 
3d55			 
3d55					; TODO write to display 
3d55			 
3d55 32 bf e4				ld (os_input), a 
3d58 3e 00				ld a, 0 
3d5a 32 c0 e4				ld (os_input+1), a 
3d5d					 
3d5d 3a 5e ea				ld a, (f_cursor_ptr) 
3d60 11 bf e4				ld de, os_input 
3d63 cd cc 0b				call str_at_display 
3d66			 
3d66			 
3d66 3a 3c ea				ld a,(cli_autodisplay) 
3d69 fe 00				cp 0 
3d6b 28 03				jr z, .enoupdate 
3d6d cd dc 0b						call update_display 
3d70					.enoupdate: 
3d70			 
3d70 3a 5e ea				ld a, (f_cursor_ptr) 
3d73 3c					inc a 
3d74 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3d77			 
3d77			 
3d77					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d77 cd 60 20			call macro_forth_dsp_pop 
3d7a				endm 
# End of macro FORTH_DSP_POP
3d7a			  
3d7a			 
3d7a					NEXTW 
3d7a c3 5e 21			jp macro_next 
3d7d				endm 
# End of macro NEXTW
3d7d			.DOTH: 
3d7d				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3d7d 1c				db WORD_SYS_CORE+8             
3d7e ad 3d			dw .DOTF            
3d80 03				db 2 + 1 
3d81 .. 00			db ".-",0              
3d84				endm 
# End of macro CWHEAD
3d84			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3d84					; get value off TOS and display it 
3d84					if DEBUG_FORTH_WORDS_KEY 
3d84						DMARK "DTD" 
3d84 f5				push af  
3d85 3a 99 3d			ld a, (.dmark)  
3d88 32 6b ee			ld (debug_mark),a  
3d8b 3a 9a 3d			ld a, (.dmark+1)  
3d8e 32 6c ee			ld (debug_mark+1),a  
3d91 3a 9b 3d			ld a, (.dmark+2)  
3d94 32 6d ee			ld (debug_mark+2),a  
3d97 18 03			jr .pastdmark  
3d99 ..			.dmark: db "DTD"  
3d9c f1			.pastdmark: pop af  
3d9d			endm  
# End of macro DMARK
3d9d						CALLMONITOR 
3d9d cd 6f ee			call debug_vector  
3da0				endm  
# End of macro CALLMONITOR
3da0					endif 
3da0 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3da2 3e 00			ld a, 0 
3da4 32 3d ea			ld (cli_mvdot), a 
3da7 c3 04 3e			jp .dotgo 
3daa				NEXTW 
3daa c3 5e 21			jp macro_next 
3dad				endm 
# End of macro NEXTW
3dad			.DOTF: 
3dad				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3dad 1c				db WORD_SYS_CORE+8             
3dae db 3d			dw .DOT            
3db0 03				db 2 + 1 
3db1 .. 00			db ".>",0              
3db4				endm 
# End of macro CWHEAD
3db4			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
3db4					; get value off TOS and display it 
3db4			        ; TODO BUG adds extra spaces 
3db4			        ; TODO BUG handle numerics? 
3db4					if DEBUG_FORTH_WORDS_KEY 
3db4						DMARK "DTC" 
3db4 f5				push af  
3db5 3a c9 3d			ld a, (.dmark)  
3db8 32 6b ee			ld (debug_mark),a  
3dbb 3a ca 3d			ld a, (.dmark+1)  
3dbe 32 6c ee			ld (debug_mark+1),a  
3dc1 3a cb 3d			ld a, (.dmark+2)  
3dc4 32 6d ee			ld (debug_mark+2),a  
3dc7 18 03			jr .pastdmark  
3dc9 ..			.dmark: db "DTC"  
3dcc f1			.pastdmark: pop af  
3dcd			endm  
# End of macro DMARK
3dcd						CALLMONITOR 
3dcd cd 6f ee			call debug_vector  
3dd0				endm  
# End of macro CALLMONITOR
3dd0					endif 
3dd0 3e 01			ld a, 1 
3dd2 32 3d ea			ld (cli_mvdot), a 
3dd5 c3 04 3e			jp .dotgo 
3dd8				NEXTW 
3dd8 c3 5e 21			jp macro_next 
3ddb				endm 
# End of macro NEXTW
3ddb			 
3ddb			.DOT: 
3ddb				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3ddb 1c				db WORD_SYS_CORE+8             
3ddc b7 3f			dw .CLS            
3dde 02				db 1 + 1 
3ddf .. 00			db ".",0              
3de1				endm 
# End of macro CWHEAD
3de1			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
3de1					; get value off TOS and display it 
3de1			 
3de1					if DEBUG_FORTH_WORDS_KEY 
3de1						DMARK "DOT" 
3de1 f5				push af  
3de2 3a f6 3d			ld a, (.dmark)  
3de5 32 6b ee			ld (debug_mark),a  
3de8 3a f7 3d			ld a, (.dmark+1)  
3deb 32 6c ee			ld (debug_mark+1),a  
3dee 3a f8 3d			ld a, (.dmark+2)  
3df1 32 6d ee			ld (debug_mark+2),a  
3df4 18 03			jr .pastdmark  
3df6 ..			.dmark: db "DOT"  
3df9 f1			.pastdmark: pop af  
3dfa			endm  
# End of macro DMARK
3dfa						CALLMONITOR 
3dfa cd 6f ee			call debug_vector  
3dfd				endm  
# End of macro CALLMONITOR
3dfd					endif 
3dfd 3e 00			ld a, 0 
3dff 32 3d ea			ld (cli_mvdot), a 
3e02 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3e04				 
3e04			 
3e04			.dotgo: 
3e04			 
3e04			; move up type to on stack for parserv5 
3e04					FORTH_DSP 
3e04 cd 6e 1f			call macro_forth_dsp 
3e07				endm 
# End of macro FORTH_DSP
3e07				;FORTH_DSP_VALUE  
3e07			 
3e07			if DEBUG_FORTH_DOT 
3e07				DMARK "DOT" 
3e07 f5				push af  
3e08 3a 1c 3e			ld a, (.dmark)  
3e0b 32 6b ee			ld (debug_mark),a  
3e0e 3a 1d 3e			ld a, (.dmark+1)  
3e11 32 6c ee			ld (debug_mark+1),a  
3e14 3a 1e 3e			ld a, (.dmark+2)  
3e17 32 6d ee			ld (debug_mark+2),a  
3e1a 18 03			jr .pastdmark  
3e1c ..			.dmark: db "DOT"  
3e1f f1			.pastdmark: pop af  
3e20			endm  
# End of macro DMARK
3e20				CALLMONITOR 
3e20 cd 6f ee			call debug_vector  
3e23				endm  
# End of macro CALLMONITOR
3e23			endif	 
3e23			;		.print: 
3e23			 
3e23 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3e24 23				inc hl   ; position to the actual value 
3e25 fe 01			cp DS_TYPE_STR 
3e27 20 06			jr nz, .dotnum1  
3e29			 
3e29			; display string 
3e29				FORTH_DSP_VALUE  
3e29 cd 91 1f			call macro_forth_dsp_value 
3e2c				endm 
# End of macro FORTH_DSP_VALUE
3e2c eb				ex de,hl 
3e2d 18 49			jr .dotwrite 
3e2f			 
3e2f			.dotnum1: 
3e2f fe 02			cp DS_TYPE_INUM 
3e31 20 44			jr nz, .dotflot 
3e33			 
3e33			 
3e33			; display number 
3e33			 
3e33			;	push hl 
3e33			;	call clear_display 
3e33			;	pop hl 
3e33			 
3e33 5e				ld e, (hl) 
3e34 23				inc hl 
3e35 56				ld d, (hl) 
3e36 21 c1 e2			ld hl, scratch 
3e39			if DEBUG_FORTH_DOT 
3e39				DMARK "DT1" 
3e39 f5				push af  
3e3a 3a 4e 3e			ld a, (.dmark)  
3e3d 32 6b ee			ld (debug_mark),a  
3e40 3a 4f 3e			ld a, (.dmark+1)  
3e43 32 6c ee			ld (debug_mark+1),a  
3e46 3a 50 3e			ld a, (.dmark+2)  
3e49 32 6d ee			ld (debug_mark+2),a  
3e4c 18 03			jr .pastdmark  
3e4e ..			.dmark: db "DT1"  
3e51 f1			.pastdmark: pop af  
3e52			endm  
# End of macro DMARK
3e52				CALLMONITOR 
3e52 cd 6f ee			call debug_vector  
3e55				endm  
# End of macro CALLMONITOR
3e55			endif	 
3e55			 
3e55 cd 52 13			call uitoa_16 
3e58 eb				ex de,hl 
3e59			 
3e59			if DEBUG_FORTH_DOT 
3e59				DMARK "DT2" 
3e59 f5				push af  
3e5a 3a 6e 3e			ld a, (.dmark)  
3e5d 32 6b ee			ld (debug_mark),a  
3e60 3a 6f 3e			ld a, (.dmark+1)  
3e63 32 6c ee			ld (debug_mark+1),a  
3e66 3a 70 3e			ld a, (.dmark+2)  
3e69 32 6d ee			ld (debug_mark+2),a  
3e6c 18 03			jr .pastdmark  
3e6e ..			.dmark: db "DT2"  
3e71 f1			.pastdmark: pop af  
3e72			endm  
# End of macro DMARK
3e72				CALLMONITOR 
3e72 cd 6f ee			call debug_vector  
3e75				endm  
# End of macro CALLMONITOR
3e75			endif	 
3e75			 
3e75			;	ld de, os_word_scratch 
3e75 18 01			jr .dotwrite 
3e77			 
3e77 00			.dotflot:   nop 
3e78			; TODO print floating point number 
3e78			 
3e78			.dotwrite:		 
3e78			 
3e78					; if c is set then set all '-' to spaces 
3e78					; need to also take into account .>  
3e78			 
3e78 3e 01				ld a, 1 
3e7a b9					cp c 
3e7b 20 67				jr nz, .nodashswap 
3e7d			 
3e7d					; DE has the string to write, working with HL 
3e7d			 
3e7d 06 ff				ld b, 255 
3e7f d5					push de 
3e80 e1					pop hl 
3e81			 
3e81			if DEBUG_FORTH_DOT 
3e81				DMARK "DT-" 
3e81 f5				push af  
3e82 3a 96 3e			ld a, (.dmark)  
3e85 32 6b ee			ld (debug_mark),a  
3e88 3a 97 3e			ld a, (.dmark+1)  
3e8b 32 6c ee			ld (debug_mark+1),a  
3e8e 3a 98 3e			ld a, (.dmark+2)  
3e91 32 6d ee			ld (debug_mark+2),a  
3e94 18 03			jr .pastdmark  
3e96 ..			.dmark: db "DT-"  
3e99 f1			.pastdmark: pop af  
3e9a			endm  
# End of macro DMARK
3e9a				CALLMONITOR 
3e9a cd 6f ee			call debug_vector  
3e9d				endm  
# End of macro CALLMONITOR
3e9d			endif	 
3e9d 7e			.dashscan:	ld a, (hl) 
3e9e fe 00				cp 0 
3ea0 28 42				jr z, .nodashswap 
3ea2 fe 2d				cp '-' 
3ea4 20 03				jr nz, .dashskip 
3ea6 3e 20				ld a, ' ' 
3ea8 77					ld (hl), a 
3ea9 23			.dashskip:	inc hl 
3eaa			if DEBUG_FORTH_DOT 
3eaa				DMARK "D-2" 
3eaa f5				push af  
3eab 3a bf 3e			ld a, (.dmark)  
3eae 32 6b ee			ld (debug_mark),a  
3eb1 3a c0 3e			ld a, (.dmark+1)  
3eb4 32 6c ee			ld (debug_mark+1),a  
3eb7 3a c1 3e			ld a, (.dmark+2)  
3eba 32 6d ee			ld (debug_mark+2),a  
3ebd 18 03			jr .pastdmark  
3ebf ..			.dmark: db "D-2"  
3ec2 f1			.pastdmark: pop af  
3ec3			endm  
# End of macro DMARK
3ec3				CALLMONITOR 
3ec3 cd 6f ee			call debug_vector  
3ec6				endm  
# End of macro CALLMONITOR
3ec6			endif	 
3ec6 10 d5				djnz .dashscan 
3ec8			 
3ec8			if DEBUG_FORTH_DOT 
3ec8				DMARK "D-1" 
3ec8 f5				push af  
3ec9 3a dd 3e			ld a, (.dmark)  
3ecc 32 6b ee			ld (debug_mark),a  
3ecf 3a de 3e			ld a, (.dmark+1)  
3ed2 32 6c ee			ld (debug_mark+1),a  
3ed5 3a df 3e			ld a, (.dmark+2)  
3ed8 32 6d ee			ld (debug_mark+2),a  
3edb 18 03			jr .pastdmark  
3edd ..			.dmark: db "D-1"  
3ee0 f1			.pastdmark: pop af  
3ee1			endm  
# End of macro DMARK
3ee1				CALLMONITOR 
3ee1 cd 6f ee			call debug_vector  
3ee4				endm  
# End of macro CALLMONITOR
3ee4			endif	 
3ee4			 
3ee4			.nodashswap: 
3ee4			 
3ee4			if DEBUG_FORTH_DOT 
3ee4				DMARK "D-o" 
3ee4 f5				push af  
3ee5 3a f9 3e			ld a, (.dmark)  
3ee8 32 6b ee			ld (debug_mark),a  
3eeb 3a fa 3e			ld a, (.dmark+1)  
3eee 32 6c ee			ld (debug_mark+1),a  
3ef1 3a fb 3e			ld a, (.dmark+2)  
3ef4 32 6d ee			ld (debug_mark+2),a  
3ef7 18 03			jr .pastdmark  
3ef9 ..			.dmark: db "D-o"  
3efc f1			.pastdmark: pop af  
3efd			endm  
# End of macro DMARK
3efd				CALLMONITOR 
3efd cd 6f ee			call debug_vector  
3f00				endm  
# End of macro CALLMONITOR
3f00			endif	 
3f00			 
3f00 d5					push de   ; save string start in case we need to advance print 
3f01			 
3f01 3a 5e ea				ld a, (f_cursor_ptr) 
3f04 cd cc 0b				call str_at_display 
3f07 3a 3c ea				ld a,(cli_autodisplay) 
3f0a fe 00				cp 0 
3f0c 28 03				jr z, .noupdate 
3f0e cd dc 0b						call update_display 
3f11					.noupdate: 
3f11			 
3f11			 
3f11					; see if we need to advance the print position 
3f11			 
3f11 e1					pop hl   ; get back string 
3f12			;		ex de,hl 
3f12			 
3f12 3a 3d ea				ld a, (cli_mvdot) 
3f15			if DEBUG_FORTH_DOT 
3f15			;		ld e,a 
3f15				DMARK "D>1" 
3f15 f5				push af  
3f16 3a 2a 3f			ld a, (.dmark)  
3f19 32 6b ee			ld (debug_mark),a  
3f1c 3a 2b 3f			ld a, (.dmark+1)  
3f1f 32 6c ee			ld (debug_mark+1),a  
3f22 3a 2c 3f			ld a, (.dmark+2)  
3f25 32 6d ee			ld (debug_mark+2),a  
3f28 18 03			jr .pastdmark  
3f2a ..			.dmark: db "D>1"  
3f2d f1			.pastdmark: pop af  
3f2e			endm  
# End of macro DMARK
3f2e				CALLMONITOR 
3f2e cd 6f ee			call debug_vector  
3f31				endm  
# End of macro CALLMONITOR
3f31			endif	 
3f31 fe 00				cp 0 
3f33 28 44				jr z, .noadv 
3f35					; yes, lets advance the print position 
3f35 3e 00				ld a, 0 
3f37 cd ae 13				call strlent 
3f3a			if DEBUG_FORTH_DOT 
3f3a				DMARK "D-?" 
3f3a f5				push af  
3f3b 3a 4f 3f			ld a, (.dmark)  
3f3e 32 6b ee			ld (debug_mark),a  
3f41 3a 50 3f			ld a, (.dmark+1)  
3f44 32 6c ee			ld (debug_mark+1),a  
3f47 3a 51 3f			ld a, (.dmark+2)  
3f4a 32 6d ee			ld (debug_mark+2),a  
3f4d 18 03			jr .pastdmark  
3f4f ..			.dmark: db "D-?"  
3f52 f1			.pastdmark: pop af  
3f53			endm  
# End of macro DMARK
3f53				CALLMONITOR 
3f53 cd 6f ee			call debug_vector  
3f56				endm  
# End of macro CALLMONITOR
3f56			endif	 
3f56 3a 5e ea				ld a, (f_cursor_ptr) 
3f59 85					add a,l 
3f5a					;call addatohl 
3f5a					;ld a, l 
3f5a 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3f5d			 
3f5d			if DEBUG_FORTH_DOT 
3f5d				DMARK "D->" 
3f5d f5				push af  
3f5e 3a 72 3f			ld a, (.dmark)  
3f61 32 6b ee			ld (debug_mark),a  
3f64 3a 73 3f			ld a, (.dmark+1)  
3f67 32 6c ee			ld (debug_mark+1),a  
3f6a 3a 74 3f			ld a, (.dmark+2)  
3f6d 32 6d ee			ld (debug_mark+2),a  
3f70 18 03			jr .pastdmark  
3f72 ..			.dmark: db "D->"  
3f75 f1			.pastdmark: pop af  
3f76			endm  
# End of macro DMARK
3f76				CALLMONITOR 
3f76 cd 6f ee			call debug_vector  
3f79				endm  
# End of macro CALLMONITOR
3f79			endif	 
3f79			 
3f79			.noadv:	 
3f79			 
3f79					if DEBUG_FORTH_DOT_WAIT 
3f79							call next_page_prompt 
3f79					endif	 
3f79			; TODO this pop off the stack causes a crash. i dont know why 
3f79			 
3f79			 
3f79			if DEBUG_FORTH_DOT 
3f79				DMARK "DTh" 
3f79 f5				push af  
3f7a 3a 8e 3f			ld a, (.dmark)  
3f7d 32 6b ee			ld (debug_mark),a  
3f80 3a 8f 3f			ld a, (.dmark+1)  
3f83 32 6c ee			ld (debug_mark+1),a  
3f86 3a 90 3f			ld a, (.dmark+2)  
3f89 32 6d ee			ld (debug_mark+2),a  
3f8c 18 03			jr .pastdmark  
3f8e ..			.dmark: db "DTh"  
3f91 f1			.pastdmark: pop af  
3f92			endm  
# End of macro DMARK
3f92				CALLMONITOR 
3f92 cd 6f ee			call debug_vector  
3f95				endm  
# End of macro CALLMONITOR
3f95			endif	 
3f95			 
3f95					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f95 cd 60 20			call macro_forth_dsp_pop 
3f98				endm 
# End of macro FORTH_DSP_POP
3f98			 
3f98			if DEBUG_FORTH_DOT 
3f98				DMARK "DTi" 
3f98 f5				push af  
3f99 3a ad 3f			ld a, (.dmark)  
3f9c 32 6b ee			ld (debug_mark),a  
3f9f 3a ae 3f			ld a, (.dmark+1)  
3fa2 32 6c ee			ld (debug_mark+1),a  
3fa5 3a af 3f			ld a, (.dmark+2)  
3fa8 32 6d ee			ld (debug_mark+2),a  
3fab 18 03			jr .pastdmark  
3fad ..			.dmark: db "DTi"  
3fb0 f1			.pastdmark: pop af  
3fb1			endm  
# End of macro DMARK
3fb1				CALLMONITOR 
3fb1 cd 6f ee			call debug_vector  
3fb4				endm  
# End of macro CALLMONITOR
3fb4			endif	 
3fb4			 
3fb4			 
3fb4					NEXTW 
3fb4 c3 5e 21			jp macro_next 
3fb7				endm 
# End of macro NEXTW
3fb7			 
3fb7			.CLS: 
3fb7				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3fb7 35				db WORD_SYS_CORE+33             
3fb8 e4 3f			dw .DRAW            
3fba 04				db 3 + 1 
3fbb .. 00			db "CLS",0              
3fbf				endm 
# End of macro CWHEAD
3fbf			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3fbf					if DEBUG_FORTH_WORDS_KEY 
3fbf						DMARK "CLS" 
3fbf f5				push af  
3fc0 3a d4 3f			ld a, (.dmark)  
3fc3 32 6b ee			ld (debug_mark),a  
3fc6 3a d5 3f			ld a, (.dmark+1)  
3fc9 32 6c ee			ld (debug_mark+1),a  
3fcc 3a d6 3f			ld a, (.dmark+2)  
3fcf 32 6d ee			ld (debug_mark+2),a  
3fd2 18 03			jr .pastdmark  
3fd4 ..			.dmark: db "CLS"  
3fd7 f1			.pastdmark: pop af  
3fd8			endm  
# End of macro DMARK
3fd8						CALLMONITOR 
3fd8 cd 6f ee			call debug_vector  
3fdb				endm  
# End of macro CALLMONITOR
3fdb					endif 
3fdb cd b9 0b				call clear_display 
3fde c3 f2 40				jp .home		; and home cursor 
3fe1					NEXTW 
3fe1 c3 5e 21			jp macro_next 
3fe4				endm 
# End of macro NEXTW
3fe4			 
3fe4			.DRAW: 
3fe4				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3fe4 36				db WORD_SYS_CORE+34             
3fe5 0f 40			dw .DUMP            
3fe7 05				db 4 + 1 
3fe8 .. 00			db "DRAW",0              
3fed				endm 
# End of macro CWHEAD
3fed			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3fed					if DEBUG_FORTH_WORDS_KEY 
3fed						DMARK "DRW" 
3fed f5				push af  
3fee 3a 02 40			ld a, (.dmark)  
3ff1 32 6b ee			ld (debug_mark),a  
3ff4 3a 03 40			ld a, (.dmark+1)  
3ff7 32 6c ee			ld (debug_mark+1),a  
3ffa 3a 04 40			ld a, (.dmark+2)  
3ffd 32 6d ee			ld (debug_mark+2),a  
4000 18 03			jr .pastdmark  
4002 ..			.dmark: db "DRW"  
4005 f1			.pastdmark: pop af  
4006			endm  
# End of macro DMARK
4006						CALLMONITOR 
4006 cd 6f ee			call debug_vector  
4009				endm  
# End of macro CALLMONITOR
4009					endif 
4009 cd dc 0b				call update_display 
400c					NEXTW 
400c c3 5e 21			jp macro_next 
400f				endm 
# End of macro NEXTW
400f			 
400f			.DUMP: 
400f				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
400f 37				db WORD_SYS_CORE+35             
4010 47 40			dw .CDUMP            
4012 05				db 4 + 1 
4013 .. 00			db "DUMP",0              
4018				endm 
# End of macro CWHEAD
4018			; | DUMP ( x -- ) With address x display dump   | DONE 
4018			; TODO pop address to use off of the stack 
4018					if DEBUG_FORTH_WORDS_KEY 
4018						DMARK "DUM" 
4018 f5				push af  
4019 3a 2d 40			ld a, (.dmark)  
401c 32 6b ee			ld (debug_mark),a  
401f 3a 2e 40			ld a, (.dmark+1)  
4022 32 6c ee			ld (debug_mark+1),a  
4025 3a 2f 40			ld a, (.dmark+2)  
4028 32 6d ee			ld (debug_mark+2),a  
402b 18 03			jr .pastdmark  
402d ..			.dmark: db "DUM"  
4030 f1			.pastdmark: pop af  
4031			endm  
# End of macro DMARK
4031						CALLMONITOR 
4031 cd 6f ee			call debug_vector  
4034				endm  
# End of macro CALLMONITOR
4034					endif 
4034 cd b9 0b				call clear_display 
4037			 
4037					; get address 
4037			 
4037					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4037 cd a8 1f			call macro_dsp_valuehl 
403a				endm 
# End of macro FORTH_DSP_VALUEHL
403a				 
403a					; save it for cdump 
403a			 
403a 22 e4 e5				ld (os_cur_ptr),hl 
403d			 
403d					; destroy value TOS 
403d			 
403d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
403d cd 60 20			call macro_forth_dsp_pop 
4040				endm 
# End of macro FORTH_DSP_POP
4040			 
4040 cd 31 1c				call dumpcont	; skip old style of param parsing	 
4043 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
4044					NEXTW 
4044 c3 5e 21			jp macro_next 
4047				endm 
# End of macro NEXTW
4047			.CDUMP: 
4047				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
4047 38				db WORD_SYS_CORE+36             
4048 77 40			dw .DAT            
404a 06				db 5 + 1 
404b .. 00			db "CDUMP",0              
4051				endm 
# End of macro CWHEAD
4051			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
4051					if DEBUG_FORTH_WORDS_KEY 
4051						DMARK "CDP" 
4051 f5				push af  
4052 3a 66 40			ld a, (.dmark)  
4055 32 6b ee			ld (debug_mark),a  
4058 3a 67 40			ld a, (.dmark+1)  
405b 32 6c ee			ld (debug_mark+1),a  
405e 3a 68 40			ld a, (.dmark+2)  
4061 32 6d ee			ld (debug_mark+2),a  
4064 18 03			jr .pastdmark  
4066 ..			.dmark: db "CDP"  
4069 f1			.pastdmark: pop af  
406a			endm  
# End of macro DMARK
406a						CALLMONITOR 
406a cd 6f ee			call debug_vector  
406d				endm  
# End of macro CALLMONITOR
406d					endif 
406d cd b9 0b				call clear_display 
4070 cd 31 1c				call dumpcont	 
4073 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
4074					NEXTW 
4074 c3 5e 21			jp macro_next 
4077				endm 
# End of macro NEXTW
4077			 
4077			 
4077			 
4077			 
4077			.DAT: 
4077				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
4077 3d				db WORD_SYS_CORE+41             
4078 cd 40			dw .HOME            
407a 03				db 2 + 1 
407b .. 00			db "AT",0              
407e				endm 
# End of macro CWHEAD
407e			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
407e					if DEBUG_FORTH_WORDS_KEY 
407e						DMARK "AT." 
407e f5				push af  
407f 3a 93 40			ld a, (.dmark)  
4082 32 6b ee			ld (debug_mark),a  
4085 3a 94 40			ld a, (.dmark+1)  
4088 32 6c ee			ld (debug_mark+1),a  
408b 3a 95 40			ld a, (.dmark+2)  
408e 32 6d ee			ld (debug_mark+2),a  
4091 18 03			jr .pastdmark  
4093 ..			.dmark: db "AT."  
4096 f1			.pastdmark: pop af  
4097			endm  
# End of macro DMARK
4097						CALLMONITOR 
4097 cd 6f ee			call debug_vector  
409a				endm  
# End of macro CALLMONITOR
409a					endif 
409a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
409a cd a8 1f			call macro_dsp_valuehl 
409d				endm 
# End of macro FORTH_DSP_VALUEHL
409d			 
409d			 
409d					; TODO save cursor row 
409d 7d					ld a,l 
409e fe 02				cp 2 
40a0 20 04				jr nz, .crow3 
40a2 3e 28				ld a, display_row_2 
40a4 18 12				jr .ccol1 
40a6 fe 03		.crow3:		cp 3 
40a8 20 04				jr nz, .crow4 
40aa 3e 50				ld a, display_row_3 
40ac 18 0a				jr .ccol1 
40ae fe 04		.crow4:		cp 4 
40b0 20 04				jr nz, .crow1 
40b2 3e 78				ld a, display_row_4 
40b4 18 02				jr .ccol1 
40b6 3e 00		.crow1:		ld a,display_row_1 
40b8 f5			.ccol1:		push af			; got row offset 
40b9 6f					ld l,a 
40ba 26 00				ld h,0 
40bc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40bc cd 60 20			call macro_forth_dsp_pop 
40bf				endm 
# End of macro FORTH_DSP_POP
40bf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40bf cd a8 1f			call macro_dsp_valuehl 
40c2				endm 
# End of macro FORTH_DSP_VALUEHL
40c2					; TODO save cursor col 
40c2 f1					pop af 
40c3 85					add l		; add col offset 
40c4 32 5e ea				ld (f_cursor_ptr), a 
40c7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40c7 cd 60 20			call macro_forth_dsp_pop 
40ca				endm 
# End of macro FORTH_DSP_POP
40ca			 
40ca					; calculate  
40ca			 
40ca					NEXTW 
40ca c3 5e 21			jp macro_next 
40cd				endm 
# End of macro NEXTW
40cd			 
40cd			 
40cd			.HOME: 
40cd				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
40cd 41				db WORD_SYS_CORE+45             
40ce fa 40			dw .CR            
40d0 05				db 4 + 1 
40d1 .. 00			db "HOME",0              
40d6				endm 
# End of macro CWHEAD
40d6			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
40d6					if DEBUG_FORTH_WORDS_KEY 
40d6						DMARK "HOM" 
40d6 f5				push af  
40d7 3a eb 40			ld a, (.dmark)  
40da 32 6b ee			ld (debug_mark),a  
40dd 3a ec 40			ld a, (.dmark+1)  
40e0 32 6c ee			ld (debug_mark+1),a  
40e3 3a ed 40			ld a, (.dmark+2)  
40e6 32 6d ee			ld (debug_mark+2),a  
40e9 18 03			jr .pastdmark  
40eb ..			.dmark: db "HOM"  
40ee f1			.pastdmark: pop af  
40ef			endm  
# End of macro DMARK
40ef						CALLMONITOR 
40ef cd 6f ee			call debug_vector  
40f2				endm  
# End of macro CALLMONITOR
40f2					endif 
40f2 3e 00		.home:		ld a, 0		; and home cursor 
40f4 32 5e ea				ld (f_cursor_ptr), a 
40f7					NEXTW 
40f7 c3 5e 21			jp macro_next 
40fa				endm 
# End of macro NEXTW
40fa			 
40fa			 
40fa			.CR: 
40fa				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
40fa 46				db WORD_SYS_CORE+50             
40fb 35 41			dw .SPACE            
40fd 03				db 2 + 1 
40fe .. 00			db "CR",0              
4101				endm 
# End of macro CWHEAD
4101			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
4101					if DEBUG_FORTH_WORDS_KEY 
4101						DMARK "CR." 
4101 f5				push af  
4102 3a 16 41			ld a, (.dmark)  
4105 32 6b ee			ld (debug_mark),a  
4108 3a 17 41			ld a, (.dmark+1)  
410b 32 6c ee			ld (debug_mark+1),a  
410e 3a 18 41			ld a, (.dmark+2)  
4111 32 6d ee			ld (debug_mark+2),a  
4114 18 03			jr .pastdmark  
4116 ..			.dmark: db "CR."  
4119 f1			.pastdmark: pop af  
411a			endm  
# End of macro DMARK
411a						CALLMONITOR 
411a cd 6f ee			call debug_vector  
411d				endm  
# End of macro CALLMONITOR
411d					endif 
411d 3e 0d				ld a, 13 
411f 32 c1 e2				ld (scratch),a 
4122 3e 0a				ld a, 10 
4124 32 c2 e2				ld (scratch+1),a 
4127 3e 00				ld a, 0 
4129 32 c3 e2				ld (scratch+2),a 
412c 21 c1 e2				ld hl, scratch 
412f cd 1f 1e				call forth_push_str 
4132					 
4132				       NEXTW 
4132 c3 5e 21			jp macro_next 
4135				endm 
# End of macro NEXTW
4135			.SPACE: 
4135				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
4135 46				db WORD_SYS_CORE+50             
4136 6b 41			dw .SPACES            
4138 03				db 2 + 1 
4139 .. 00			db "BL",0              
413c				endm 
# End of macro CWHEAD
413c			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
413c					if DEBUG_FORTH_WORDS_KEY 
413c						DMARK "BL." 
413c f5				push af  
413d 3a 51 41			ld a, (.dmark)  
4140 32 6b ee			ld (debug_mark),a  
4143 3a 52 41			ld a, (.dmark+1)  
4146 32 6c ee			ld (debug_mark+1),a  
4149 3a 53 41			ld a, (.dmark+2)  
414c 32 6d ee			ld (debug_mark+2),a  
414f 18 03			jr .pastdmark  
4151 ..			.dmark: db "BL."  
4154 f1			.pastdmark: pop af  
4155			endm  
# End of macro DMARK
4155						CALLMONITOR 
4155 cd 6f ee			call debug_vector  
4158				endm  
# End of macro CALLMONITOR
4158					endif 
4158 3e 20				ld a, " " 
415a 32 c1 e2				ld (scratch),a 
415d 3e 00				ld a, 0 
415f 32 c2 e2				ld (scratch+1),a 
4162 21 c1 e2				ld hl, scratch 
4165 cd 1f 1e				call forth_push_str 
4168					 
4168				       NEXTW 
4168 c3 5e 21			jp macro_next 
416b				endm 
# End of macro NEXTW
416b			 
416b			;.blstr: db " ", 0 
416b			 
416b			.SPACES: 
416b				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
416b 47				db WORD_SYS_CORE+51             
416c 06 42			dw .SCROLL            
416e 07				db 6 + 1 
416f .. 00			db "SPACES",0              
4176				endm 
# End of macro CWHEAD
4176			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
4176					if DEBUG_FORTH_WORDS_KEY 
4176						DMARK "SPS" 
4176 f5				push af  
4177 3a 8b 41			ld a, (.dmark)  
417a 32 6b ee			ld (debug_mark),a  
417d 3a 8c 41			ld a, (.dmark+1)  
4180 32 6c ee			ld (debug_mark+1),a  
4183 3a 8d 41			ld a, (.dmark+2)  
4186 32 6d ee			ld (debug_mark+2),a  
4189 18 03			jr .pastdmark  
418b ..			.dmark: db "SPS"  
418e f1			.pastdmark: pop af  
418f			endm  
# End of macro DMARK
418f						CALLMONITOR 
418f cd 6f ee			call debug_vector  
4192				endm  
# End of macro CALLMONITOR
4192					endif 
4192			 
4192			 
4192					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4192 cd a8 1f			call macro_dsp_valuehl 
4195				endm 
# End of macro FORTH_DSP_VALUEHL
4195			 
4195 e5					push hl    ; u 
4196					if DEBUG_FORTH_WORDS 
4196						DMARK "SPA" 
4196 f5				push af  
4197 3a ab 41			ld a, (.dmark)  
419a 32 6b ee			ld (debug_mark),a  
419d 3a ac 41			ld a, (.dmark+1)  
41a0 32 6c ee			ld (debug_mark+1),a  
41a3 3a ad 41			ld a, (.dmark+2)  
41a6 32 6d ee			ld (debug_mark+2),a  
41a9 18 03			jr .pastdmark  
41ab ..			.dmark: db "SPA"  
41ae f1			.pastdmark: pop af  
41af			endm  
# End of macro DMARK
41af						CALLMONITOR 
41af cd 6f ee			call debug_vector  
41b2				endm  
# End of macro CALLMONITOR
41b2					endif 
41b2			 
41b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
41b2 cd 60 20			call macro_forth_dsp_pop 
41b5				endm 
# End of macro FORTH_DSP_POP
41b5 e1					pop hl 
41b6 0e 00				ld c, 0 
41b8 45					ld b, l 
41b9 21 c1 e2				ld hl, scratch  
41bc			 
41bc					if DEBUG_FORTH_WORDS 
41bc						DMARK "SP2" 
41bc f5				push af  
41bd 3a d1 41			ld a, (.dmark)  
41c0 32 6b ee			ld (debug_mark),a  
41c3 3a d2 41			ld a, (.dmark+1)  
41c6 32 6c ee			ld (debug_mark+1),a  
41c9 3a d3 41			ld a, (.dmark+2)  
41cc 32 6d ee			ld (debug_mark+2),a  
41cf 18 03			jr .pastdmark  
41d1 ..			.dmark: db "SP2"  
41d4 f1			.pastdmark: pop af  
41d5			endm  
# End of macro DMARK
41d5						CALLMONITOR 
41d5 cd 6f ee			call debug_vector  
41d8				endm  
# End of macro CALLMONITOR
41d8					endif 
41d8 3e 20				ld a, ' ' 
41da			.spaces1:	 
41da 77					ld (hl),a 
41db 23					inc hl 
41dc					 
41dc 10 fc				djnz .spaces1 
41de 3e 00				ld a,0 
41e0 77					ld (hl),a 
41e1 21 c1 e2				ld hl, scratch 
41e4					if DEBUG_FORTH_WORDS 
41e4						DMARK "SP3" 
41e4 f5				push af  
41e5 3a f9 41			ld a, (.dmark)  
41e8 32 6b ee			ld (debug_mark),a  
41eb 3a fa 41			ld a, (.dmark+1)  
41ee 32 6c ee			ld (debug_mark+1),a  
41f1 3a fb 41			ld a, (.dmark+2)  
41f4 32 6d ee			ld (debug_mark+2),a  
41f7 18 03			jr .pastdmark  
41f9 ..			.dmark: db "SP3"  
41fc f1			.pastdmark: pop af  
41fd			endm  
# End of macro DMARK
41fd						CALLMONITOR 
41fd cd 6f ee			call debug_vector  
4200				endm  
# End of macro CALLMONITOR
4200					endif 
4200 cd 1f 1e				call forth_push_str 
4203			 
4203				       NEXTW 
4203 c3 5e 21			jp macro_next 
4206				endm 
# End of macro NEXTW
4206			 
4206			 
4206			 
4206			.SCROLL: 
4206				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4206 53				db WORD_SYS_CORE+63             
4207 33 42			dw .SCROLLD            
4209 07				db 6 + 1 
420a .. 00			db "SCROLL",0              
4211				endm 
# End of macro CWHEAD
4211			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4211					if DEBUG_FORTH_WORDS_KEY 
4211						DMARK "SCR" 
4211 f5				push af  
4212 3a 26 42			ld a, (.dmark)  
4215 32 6b ee			ld (debug_mark),a  
4218 3a 27 42			ld a, (.dmark+1)  
421b 32 6c ee			ld (debug_mark+1),a  
421e 3a 28 42			ld a, (.dmark+2)  
4221 32 6d ee			ld (debug_mark+2),a  
4224 18 03			jr .pastdmark  
4226 ..			.dmark: db "SCR"  
4229 f1			.pastdmark: pop af  
422a			endm  
# End of macro DMARK
422a						CALLMONITOR 
422a cd 6f ee			call debug_vector  
422d				endm  
# End of macro CALLMONITOR
422d					endif 
422d			 
422d cd 7b 0b			call scroll_up 
4230			;	call update_display 
4230			 
4230					NEXTW 
4230 c3 5e 21			jp macro_next 
4233				endm 
# End of macro NEXTW
4233			 
4233			 
4233			 
4233			;		; get dir 
4233			; 
4233			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4233			; 
4233			;		push hl 
4233			; 
4233			;		; destroy value TOS 
4233			; 
4233			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4233			; 
4233			;		; get count 
4233			; 
4233			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4233			; 
4233			;		push hl 
4233			; 
4233			;		; destroy value TOS 
4233			; 
4233			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4233			; 
4233			;		; one value on hl get other one back 
4233			; 
4233			;		pop bc    ; count 
4233			; 
4233			;		pop de   ; dir 
4233			; 
4233			; 
4233			;		ld b, c 
4233			; 
4233			;.scrolldir:     push bc 
4233			;		push de 
4233			; 
4233			;		ld a, 0 
4233			;		cp e 
4233			;		jr z, .scrollup  
4233			;		call scroll_down 
4233			;		jr .scrollnext 
4233			;.scrollup:	call scroll_up 
4233			; 
4233			;		 
4233			;.scrollnext: 
4233			;		pop de 
4233			;		pop bc 
4233			;		djnz .scrolldir 
4233			; 
4233			; 
4233			; 
4233			; 
4233			; 
4233			;		NEXTW 
4233			 
4233			.SCROLLD: 
4233				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4233 53				db WORD_SYS_CORE+63             
4234 61 42			dw .ATQ            
4236 08				db 7 + 1 
4237 .. 00			db "SCROLLD",0              
423f				endm 
# End of macro CWHEAD
423f			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
423f					if DEBUG_FORTH_WORDS_KEY 
423f						DMARK "SCD" 
423f f5				push af  
4240 3a 54 42			ld a, (.dmark)  
4243 32 6b ee			ld (debug_mark),a  
4246 3a 55 42			ld a, (.dmark+1)  
4249 32 6c ee			ld (debug_mark+1),a  
424c 3a 56 42			ld a, (.dmark+2)  
424f 32 6d ee			ld (debug_mark+2),a  
4252 18 03			jr .pastdmark  
4254 ..			.dmark: db "SCD"  
4257 f1			.pastdmark: pop af  
4258			endm  
# End of macro DMARK
4258						CALLMONITOR 
4258 cd 6f ee			call debug_vector  
425b				endm  
# End of macro CALLMONITOR
425b					endif 
425b			 
425b cd 9f 0b			call scroll_down 
425e			;	call update_display 
425e			 
425e					NEXTW 
425e c3 5e 21			jp macro_next 
4261				endm 
# End of macro NEXTW
4261			 
4261			 
4261			.ATQ: 
4261				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
4261 62				db WORD_SYS_CORE+78             
4262 bf 42			dw .AUTODSP            
4264 04				db 3 + 1 
4265 .. 00			db "AT@",0              
4269				endm 
# End of macro CWHEAD
4269			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
4269					if DEBUG_FORTH_WORDS_KEY 
4269						DMARK "ATA" 
4269 f5				push af  
426a 3a 7e 42			ld a, (.dmark)  
426d 32 6b ee			ld (debug_mark),a  
4270 3a 7f 42			ld a, (.dmark+1)  
4273 32 6c ee			ld (debug_mark+1),a  
4276 3a 80 42			ld a, (.dmark+2)  
4279 32 6d ee			ld (debug_mark+2),a  
427c 18 03			jr .pastdmark  
427e ..			.dmark: db "ATA"  
4281 f1			.pastdmark: pop af  
4282			endm  
# End of macro DMARK
4282						CALLMONITOR 
4282 cd 6f ee			call debug_vector  
4285				endm  
# End of macro CALLMONITOR
4285					endif 
4285			 
4285			 
4285					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4285 cd a8 1f			call macro_dsp_valuehl 
4288				endm 
# End of macro FORTH_DSP_VALUEHL
4288			 
4288					; TODO save cursor row 
4288 7d					ld a,l 
4289 fe 02				cp 2 
428b 20 04				jr nz, .crow3aq 
428d 3e 28				ld a, display_row_2 
428f 18 12				jr .ccol1aq 
4291 fe 03		.crow3aq:		cp 3 
4293 20 04				jr nz, .crow4aq 
4295 3e 50				ld a, display_row_3 
4297 18 0a				jr .ccol1aq 
4299 fe 04		.crow4aq:		cp 4 
429b 20 04				jr nz, .crow1aq 
429d 3e 78				ld a, display_row_4 
429f 18 02				jr .ccol1aq 
42a1 3e 00		.crow1aq:		ld a,display_row_1 
42a3 f5			.ccol1aq:		push af			; got row offset 
42a4 6f					ld l,a 
42a5 26 00				ld h,0 
42a7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42a7 cd 60 20			call macro_forth_dsp_pop 
42aa				endm 
# End of macro FORTH_DSP_POP
42aa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42aa cd a8 1f			call macro_dsp_valuehl 
42ad				endm 
# End of macro FORTH_DSP_VALUEHL
42ad					; TODO save cursor col 
42ad f1					pop af 
42ae 85					add l		; add col offset 
42af			 
42af					; add current frame buffer address 
42af 2a cc eb				ld hl, (display_fb_active) 
42b2 cd e6 0d				call addatohl 
42b5			 
42b5			 
42b5			 
42b5			 
42b5					; get char frame buffer location offset in hl 
42b5			 
42b5 7e					ld a,(hl) 
42b6 26 00				ld h, 0 
42b8 6f					ld l, a 
42b9			 
42b9 cd b1 1d				call forth_push_numhl 
42bc			 
42bc			 
42bc					NEXTW 
42bc c3 5e 21			jp macro_next 
42bf				endm 
# End of macro NEXTW
42bf			 
42bf			.AUTODSP: 
42bf				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
42bf 63				db WORD_SYS_CORE+79             
42c0 d5 42			dw .MENU            
42c2 05				db 4 + 1 
42c3 .. 00			db "ADSP",0              
42c8				endm 
# End of macro CWHEAD
42c8			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
42c8			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
42c8			 
42c8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42c8 cd a8 1f			call macro_dsp_valuehl 
42cb				endm 
# End of macro FORTH_DSP_VALUEHL
42cb			 
42cb			;		push hl 
42cb			 
42cb					; destroy value TOS 
42cb			 
42cb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42cb cd 60 20			call macro_forth_dsp_pop 
42ce				endm 
# End of macro FORTH_DSP_POP
42ce			 
42ce			;		pop hl 
42ce			 
42ce 7d					ld a,l 
42cf 32 3c ea				ld (cli_autodisplay), a 
42d2				       NEXTW 
42d2 c3 5e 21			jp macro_next 
42d5				endm 
# End of macro NEXTW
42d5			 
42d5			.MENU: 
42d5				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
42d5 70				db WORD_SYS_CORE+92             
42d6 7e 43			dw .ENDDISPLAY            
42d8 05				db 4 + 1 
42d9 .. 00			db "MENU",0              
42de				endm 
# End of macro CWHEAD
42de			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
42de			 
42de			;		; get number of items on the stack 
42de			; 
42de				 
42de					FORTH_DSP_VALUEHL 
42de cd a8 1f			call macro_dsp_valuehl 
42e1				endm 
# End of macro FORTH_DSP_VALUEHL
42e1				 
42e1					if DEBUG_FORTH_WORDS_KEY 
42e1						DMARK "MNU" 
42e1 f5				push af  
42e2 3a f6 42			ld a, (.dmark)  
42e5 32 6b ee			ld (debug_mark),a  
42e8 3a f7 42			ld a, (.dmark+1)  
42eb 32 6c ee			ld (debug_mark+1),a  
42ee 3a f8 42			ld a, (.dmark+2)  
42f1 32 6d ee			ld (debug_mark+2),a  
42f4 18 03			jr .pastdmark  
42f6 ..			.dmark: db "MNU"  
42f9 f1			.pastdmark: pop af  
42fa			endm  
# End of macro DMARK
42fa						CALLMONITOR 
42fa cd 6f ee			call debug_vector  
42fd				endm  
# End of macro CALLMONITOR
42fd					endif 
42fd			 
42fd 45					ld b, l	 
42fe 05					dec b 
42ff			 
42ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42ff cd 60 20			call macro_forth_dsp_pop 
4302				endm 
# End of macro FORTH_DSP_POP
4302			 
4302			 
4302					; go directly through the stack to pluck out the string pointers and build an array 
4302			 
4302			;		FORTH_DSP 
4302			 
4302					; hl contains top most stack item 
4302				 
4302 11 c1 e2				ld de, scratch 
4305			 
4305			.mbuild: 
4305			 
4305					FORTH_DSP_VALUEHL 
4305 cd a8 1f			call macro_dsp_valuehl 
4308				endm 
# End of macro FORTH_DSP_VALUEHL
4308			 
4308					if DEBUG_FORTH_WORDS 
4308						DMARK "MN3" 
4308 f5				push af  
4309 3a 1d 43			ld a, (.dmark)  
430c 32 6b ee			ld (debug_mark),a  
430f 3a 1e 43			ld a, (.dmark+1)  
4312 32 6c ee			ld (debug_mark+1),a  
4315 3a 1f 43			ld a, (.dmark+2)  
4318 32 6d ee			ld (debug_mark+2),a  
431b 18 03			jr .pastdmark  
431d ..			.dmark: db "MN3"  
4320 f1			.pastdmark: pop af  
4321			endm  
# End of macro DMARK
4321						CALLMONITOR 
4321 cd 6f ee			call debug_vector  
4324				endm  
# End of macro CALLMONITOR
4324					endif 
4324 eb					ex de, hl 
4325 73					ld (hl), e 
4326 23					inc hl 
4327 72					ld (hl), d 
4328 23					inc hl 
4329 eb					ex de, hl 
432a			 
432a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
432a cd 60 20			call macro_forth_dsp_pop 
432d				endm 
# End of macro FORTH_DSP_POP
432d			 
432d 10 d6				djnz .mbuild 
432f			 
432f					; done add term 
432f			 
432f eb					ex de, hl 
4330 36 00				ld (hl), 0 
4332 23					inc hl 
4333 36 00				ld (hl), 0 
4335			 
4335				 
4335					 
4335 21 c1 e2				ld hl, scratch 
4338			 
4338					if DEBUG_FORTH_WORDS 
4338						DMARK "MNx" 
4338 f5				push af  
4339 3a 4d 43			ld a, (.dmark)  
433c 32 6b ee			ld (debug_mark),a  
433f 3a 4e 43			ld a, (.dmark+1)  
4342 32 6c ee			ld (debug_mark+1),a  
4345 3a 4f 43			ld a, (.dmark+2)  
4348 32 6d ee			ld (debug_mark+2),a  
434b 18 03			jr .pastdmark  
434d ..			.dmark: db "MNx"  
4350 f1			.pastdmark: pop af  
4351			endm  
# End of macro DMARK
4351						CALLMONITOR 
4351 cd 6f ee			call debug_vector  
4354				endm  
# End of macro CALLMONITOR
4354					endif 
4354			 
4354			 
4354			 
4354 3e 00				ld a, 0 
4356 cd ea 0b				call menu 
4359			 
4359			 
4359 6f					ld l, a 
435a 26 00				ld h, 0 
435c			 
435c					if DEBUG_FORTH_WORDS 
435c						DMARK "MNr" 
435c f5				push af  
435d 3a 71 43			ld a, (.dmark)  
4360 32 6b ee			ld (debug_mark),a  
4363 3a 72 43			ld a, (.dmark+1)  
4366 32 6c ee			ld (debug_mark+1),a  
4369 3a 73 43			ld a, (.dmark+2)  
436c 32 6d ee			ld (debug_mark+2),a  
436f 18 03			jr .pastdmark  
4371 ..			.dmark: db "MNr"  
4374 f1			.pastdmark: pop af  
4375			endm  
# End of macro DMARK
4375						CALLMONITOR 
4375 cd 6f ee			call debug_vector  
4378				endm  
# End of macro CALLMONITOR
4378					endif 
4378			 
4378 cd b1 1d				call forth_push_numhl 
437b			 
437b			 
437b			 
437b			 
437b				       NEXTW 
437b c3 5e 21			jp macro_next 
437e				endm 
# End of macro NEXTW
437e			 
437e			 
437e			.ENDDISPLAY: 
437e			 
437e			; eof 
# End of file forth_words_display.asm
437e			include "forth_words_str.asm" 
437e			 
437e			; | ## String Words 
437e			 
437e			.PTR:   
437e			 
437e				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
437e 48				db WORD_SYS_CORE+52             
437f ab 43			dw .STYPE            
4381 04				db 3 + 1 
4382 .. 00			db "PTR",0              
4386				endm 
# End of macro CWHEAD
4386			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4386			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4386			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4386			 
4386					if DEBUG_FORTH_WORDS_KEY 
4386						DMARK "PTR" 
4386 f5				push af  
4387 3a 9b 43			ld a, (.dmark)  
438a 32 6b ee			ld (debug_mark),a  
438d 3a 9c 43			ld a, (.dmark+1)  
4390 32 6c ee			ld (debug_mark+1),a  
4393 3a 9d 43			ld a, (.dmark+2)  
4396 32 6d ee			ld (debug_mark+2),a  
4399 18 03			jr .pastdmark  
439b ..			.dmark: db "PTR"  
439e f1			.pastdmark: pop af  
439f			endm  
# End of macro DMARK
439f						CALLMONITOR 
439f cd 6f ee			call debug_vector  
43a2				endm  
# End of macro CALLMONITOR
43a2					endif 
43a2					FORTH_DSP_VALUEHL 
43a2 cd a8 1f			call macro_dsp_valuehl 
43a5				endm 
# End of macro FORTH_DSP_VALUEHL
43a5 cd b1 1d				call forth_push_numhl 
43a8			 
43a8			 
43a8					NEXTW 
43a8 c3 5e 21			jp macro_next 
43ab				endm 
# End of macro NEXTW
43ab			.STYPE: 
43ab				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
43ab 48				db WORD_SYS_CORE+52             
43ac fa 43			dw .UPPER            
43ae 06				db 5 + 1 
43af .. 00			db "STYPE",0              
43b5				endm 
# End of macro CWHEAD
43b5			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
43b5					if DEBUG_FORTH_WORDS_KEY 
43b5						DMARK "STY" 
43b5 f5				push af  
43b6 3a ca 43			ld a, (.dmark)  
43b9 32 6b ee			ld (debug_mark),a  
43bc 3a cb 43			ld a, (.dmark+1)  
43bf 32 6c ee			ld (debug_mark+1),a  
43c2 3a cc 43			ld a, (.dmark+2)  
43c5 32 6d ee			ld (debug_mark+2),a  
43c8 18 03			jr .pastdmark  
43ca ..			.dmark: db "STY"  
43cd f1			.pastdmark: pop af  
43ce			endm  
# End of macro DMARK
43ce						CALLMONITOR 
43ce cd 6f ee			call debug_vector  
43d1				endm  
# End of macro CALLMONITOR
43d1					endif 
43d1					FORTH_DSP 
43d1 cd 6e 1f			call macro_forth_dsp 
43d4				endm 
# End of macro FORTH_DSP
43d4					;v5 FORTH_DSP_VALUE 
43d4			 
43d4 7e					ld a, (hl) 
43d5			 
43d5 f5					push af 
43d6			 
43d6			; Dont destroy TOS		FORTH_DSP_POP 
43d6			 
43d6 f1					pop af 
43d7			 
43d7 fe 01				cp DS_TYPE_STR 
43d9 28 09				jr z, .typestr 
43db			 
43db fe 02				cp DS_TYPE_INUM 
43dd 28 0a				jr z, .typeinum 
43df			 
43df 21 f8 43				ld hl, .tna 
43e2 18 0a				jr .tpush 
43e4			 
43e4 21 f4 43		.typestr:	ld hl, .tstr 
43e7 18 05				jr .tpush 
43e9 21 f6 43		.typeinum:	ld hl, .tinum 
43ec 18 00				jr .tpush 
43ee			 
43ee			.tpush: 
43ee			 
43ee cd 1f 1e				call forth_push_str 
43f1			 
43f1					NEXTW 
43f1 c3 5e 21			jp macro_next 
43f4				endm 
# End of macro NEXTW
43f4 .. 00		.tstr:	db "s",0 
43f6 .. 00		.tinum:  db "i",0 
43f8 .. 00		.tna:   db "?", 0 
43fa			 
43fa			 
43fa			.UPPER: 
43fa				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
43fa 48				db WORD_SYS_CORE+52             
43fb 35 44			dw .LOWER            
43fd 06				db 5 + 1 
43fe .. 00			db "UPPER",0              
4404				endm 
# End of macro CWHEAD
4404			; | UPPER ( s -- s ) Upper case string s  | DONE 
4404					if DEBUG_FORTH_WORDS_KEY 
4404						DMARK "UPR" 
4404 f5				push af  
4405 3a 19 44			ld a, (.dmark)  
4408 32 6b ee			ld (debug_mark),a  
440b 3a 1a 44			ld a, (.dmark+1)  
440e 32 6c ee			ld (debug_mark+1),a  
4411 3a 1b 44			ld a, (.dmark+2)  
4414 32 6d ee			ld (debug_mark+2),a  
4417 18 03			jr .pastdmark  
4419 ..			.dmark: db "UPR"  
441c f1			.pastdmark: pop af  
441d			endm  
# End of macro DMARK
441d						CALLMONITOR 
441d cd 6f ee			call debug_vector  
4420				endm  
# End of macro CALLMONITOR
4420					endif 
4420			 
4420					FORTH_DSP 
4420 cd 6e 1f			call macro_forth_dsp 
4423				endm 
# End of macro FORTH_DSP
4423					 
4423			; TODO check is string type 
4423			 
4423					FORTH_DSP_VALUEHL 
4423 cd a8 1f			call macro_dsp_valuehl 
4426				endm 
# End of macro FORTH_DSP_VALUEHL
4426			; get pointer to string in hl 
4426			 
4426 7e			.toup:		ld a, (hl) 
4427 fe 00				cp 0 
4429 28 07				jr z, .toupdone 
442b			 
442b cd b2 12				call to_upper 
442e			 
442e 77					ld (hl), a 
442f 23					inc hl 
4430 18 f4				jr .toup 
4432			 
4432					 
4432			 
4432			 
4432			; for each char convert to upper 
4432					 
4432			.toupdone: 
4432			 
4432			 
4432					NEXTW 
4432 c3 5e 21			jp macro_next 
4435				endm 
# End of macro NEXTW
4435			.LOWER: 
4435				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4435 48				db WORD_SYS_CORE+52             
4436 70 44			dw .TCASE            
4438 06				db 5 + 1 
4439 .. 00			db "LOWER",0              
443f				endm 
# End of macro CWHEAD
443f			; | LOWER ( s -- s ) Lower case string s  | DONE 
443f					if DEBUG_FORTH_WORDS_KEY 
443f						DMARK "LWR" 
443f f5				push af  
4440 3a 54 44			ld a, (.dmark)  
4443 32 6b ee			ld (debug_mark),a  
4446 3a 55 44			ld a, (.dmark+1)  
4449 32 6c ee			ld (debug_mark+1),a  
444c 3a 56 44			ld a, (.dmark+2)  
444f 32 6d ee			ld (debug_mark+2),a  
4452 18 03			jr .pastdmark  
4454 ..			.dmark: db "LWR"  
4457 f1			.pastdmark: pop af  
4458			endm  
# End of macro DMARK
4458						CALLMONITOR 
4458 cd 6f ee			call debug_vector  
445b				endm  
# End of macro CALLMONITOR
445b					endif 
445b			 
445b					FORTH_DSP 
445b cd 6e 1f			call macro_forth_dsp 
445e				endm 
# End of macro FORTH_DSP
445e					 
445e			; TODO check is string type 
445e			 
445e					FORTH_DSP_VALUEHL 
445e cd a8 1f			call macro_dsp_valuehl 
4461				endm 
# End of macro FORTH_DSP_VALUEHL
4461			; get pointer to string in hl 
4461			 
4461 7e			.tolow:		ld a, (hl) 
4462 fe 00				cp 0 
4464 28 07				jr z, .tolowdone 
4466			 
4466 cd bb 12				call to_lower 
4469			 
4469 77					ld (hl), a 
446a 23					inc hl 
446b 18 f4				jr .tolow 
446d			 
446d					 
446d			 
446d			 
446d			; for each char convert to low 
446d					 
446d			.tolowdone: 
446d					NEXTW 
446d c3 5e 21			jp macro_next 
4470				endm 
# End of macro NEXTW
4470			.TCASE: 
4470				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4470 48				db WORD_SYS_CORE+52             
4471 a6 45			dw .SUBSTR            
4473 06				db 5 + 1 
4474 .. 00			db "TCASE",0              
447a				endm 
# End of macro CWHEAD
447a			; | TCASE ( s -- s ) Title case string s  | DONE 
447a					if DEBUG_FORTH_WORDS_KEY 
447a						DMARK "TCS" 
447a f5				push af  
447b 3a 8f 44			ld a, (.dmark)  
447e 32 6b ee			ld (debug_mark),a  
4481 3a 90 44			ld a, (.dmark+1)  
4484 32 6c ee			ld (debug_mark+1),a  
4487 3a 91 44			ld a, (.dmark+2)  
448a 32 6d ee			ld (debug_mark+2),a  
448d 18 03			jr .pastdmark  
448f ..			.dmark: db "TCS"  
4492 f1			.pastdmark: pop af  
4493			endm  
# End of macro DMARK
4493						CALLMONITOR 
4493 cd 6f ee			call debug_vector  
4496				endm  
# End of macro CALLMONITOR
4496					endif 
4496			 
4496					FORTH_DSP 
4496 cd 6e 1f			call macro_forth_dsp 
4499				endm 
# End of macro FORTH_DSP
4499					 
4499			; TODO check is string type 
4499			 
4499					FORTH_DSP_VALUEHL 
4499 cd a8 1f			call macro_dsp_valuehl 
449c				endm 
# End of macro FORTH_DSP_VALUEHL
449c			; get pointer to string in hl 
449c			 
449c					if DEBUG_FORTH_WORDS 
449c						DMARK "TC1" 
449c f5				push af  
449d 3a b1 44			ld a, (.dmark)  
44a0 32 6b ee			ld (debug_mark),a  
44a3 3a b2 44			ld a, (.dmark+1)  
44a6 32 6c ee			ld (debug_mark+1),a  
44a9 3a b3 44			ld a, (.dmark+2)  
44ac 32 6d ee			ld (debug_mark+2),a  
44af 18 03			jr .pastdmark  
44b1 ..			.dmark: db "TC1"  
44b4 f1			.pastdmark: pop af  
44b5			endm  
# End of macro DMARK
44b5						CALLMONITOR 
44b5 cd 6f ee			call debug_vector  
44b8				endm  
# End of macro CALLMONITOR
44b8					endif 
44b8			 
44b8					; first time in turn to upper case first char 
44b8			 
44b8 7e					ld a, (hl) 
44b9 c3 43 45				jp .totsiptou 
44bc			 
44bc			 
44bc 7e			.tot:		ld a, (hl) 
44bd fe 00				cp 0 
44bf ca 87 45				jp z, .totdone 
44c2			 
44c2					if DEBUG_FORTH_WORDS 
44c2						DMARK "TC2" 
44c2 f5				push af  
44c3 3a d7 44			ld a, (.dmark)  
44c6 32 6b ee			ld (debug_mark),a  
44c9 3a d8 44			ld a, (.dmark+1)  
44cc 32 6c ee			ld (debug_mark+1),a  
44cf 3a d9 44			ld a, (.dmark+2)  
44d2 32 6d ee			ld (debug_mark+2),a  
44d5 18 03			jr .pastdmark  
44d7 ..			.dmark: db "TC2"  
44da f1			.pastdmark: pop af  
44db			endm  
# End of macro DMARK
44db						CALLMONITOR 
44db cd 6f ee			call debug_vector  
44de				endm  
# End of macro CALLMONITOR
44de					endif 
44de					; check to see if current char is a space 
44de			 
44de fe 20				cp ' ' 
44e0 28 21				jr z, .totsp 
44e2 cd bb 12				call to_lower 
44e5					if DEBUG_FORTH_WORDS 
44e5						DMARK "TC3" 
44e5 f5				push af  
44e6 3a fa 44			ld a, (.dmark)  
44e9 32 6b ee			ld (debug_mark),a  
44ec 3a fb 44			ld a, (.dmark+1)  
44ef 32 6c ee			ld (debug_mark+1),a  
44f2 3a fc 44			ld a, (.dmark+2)  
44f5 32 6d ee			ld (debug_mark+2),a  
44f8 18 03			jr .pastdmark  
44fa ..			.dmark: db "TC3"  
44fd f1			.pastdmark: pop af  
44fe			endm  
# End of macro DMARK
44fe						CALLMONITOR 
44fe cd 6f ee			call debug_vector  
4501				endm  
# End of macro CALLMONITOR
4501					endif 
4501 18 63				jr .totnxt 
4503			 
4503			.totsp:         ; on a space, find next char which should be upper 
4503			 
4503					if DEBUG_FORTH_WORDS 
4503						DMARK "TC4" 
4503 f5				push af  
4504 3a 18 45			ld a, (.dmark)  
4507 32 6b ee			ld (debug_mark),a  
450a 3a 19 45			ld a, (.dmark+1)  
450d 32 6c ee			ld (debug_mark+1),a  
4510 3a 1a 45			ld a, (.dmark+2)  
4513 32 6d ee			ld (debug_mark+2),a  
4516 18 03			jr .pastdmark  
4518 ..			.dmark: db "TC4"  
451b f1			.pastdmark: pop af  
451c			endm  
# End of macro DMARK
451c						CALLMONITOR 
451c cd 6f ee			call debug_vector  
451f				endm  
# End of macro CALLMONITOR
451f					endif 
451f					;; 
451f			 
451f fe 20				cp ' ' 
4521 20 20				jr nz, .totsiptou 
4523 23					inc hl 
4524 7e					ld a, (hl) 
4525					if DEBUG_FORTH_WORDS 
4525						DMARK "TC5" 
4525 f5				push af  
4526 3a 3a 45			ld a, (.dmark)  
4529 32 6b ee			ld (debug_mark),a  
452c 3a 3b 45			ld a, (.dmark+1)  
452f 32 6c ee			ld (debug_mark+1),a  
4532 3a 3c 45			ld a, (.dmark+2)  
4535 32 6d ee			ld (debug_mark+2),a  
4538 18 03			jr .pastdmark  
453a ..			.dmark: db "TC5"  
453d f1			.pastdmark: pop af  
453e			endm  
# End of macro DMARK
453e						CALLMONITOR 
453e cd 6f ee			call debug_vector  
4541				endm  
# End of macro CALLMONITOR
4541					endif 
4541 18 c0				jr .totsp 
4543 fe 00		.totsiptou:    cp 0 
4545 28 40				jr z, .totdone 
4547					; not space and not zero term so upper case it 
4547 cd b2 12				call to_upper 
454a			 
454a					if DEBUG_FORTH_WORDS 
454a						DMARK "TC6" 
454a f5				push af  
454b 3a 5f 45			ld a, (.dmark)  
454e 32 6b ee			ld (debug_mark),a  
4551 3a 60 45			ld a, (.dmark+1)  
4554 32 6c ee			ld (debug_mark+1),a  
4557 3a 61 45			ld a, (.dmark+2)  
455a 32 6d ee			ld (debug_mark+2),a  
455d 18 03			jr .pastdmark  
455f ..			.dmark: db "TC6"  
4562 f1			.pastdmark: pop af  
4563			endm  
# End of macro DMARK
4563						CALLMONITOR 
4563 cd 6f ee			call debug_vector  
4566				endm  
# End of macro CALLMONITOR
4566					endif 
4566			 
4566			 
4566			.totnxt: 
4566			 
4566 77					ld (hl), a 
4567 23					inc hl 
4568					if DEBUG_FORTH_WORDS 
4568						DMARK "TC7" 
4568 f5				push af  
4569 3a 7d 45			ld a, (.dmark)  
456c 32 6b ee			ld (debug_mark),a  
456f 3a 7e 45			ld a, (.dmark+1)  
4572 32 6c ee			ld (debug_mark+1),a  
4575 3a 7f 45			ld a, (.dmark+2)  
4578 32 6d ee			ld (debug_mark+2),a  
457b 18 03			jr .pastdmark  
457d ..			.dmark: db "TC7"  
4580 f1			.pastdmark: pop af  
4581			endm  
# End of macro DMARK
4581						CALLMONITOR 
4581 cd 6f ee			call debug_vector  
4584				endm  
# End of macro CALLMONITOR
4584					endif 
4584 c3 bc 44				jp .tot 
4587			 
4587					 
4587			 
4587			 
4587			; for each char convert to low 
4587					 
4587			.totdone: 
4587					if DEBUG_FORTH_WORDS 
4587						DMARK "TCd" 
4587 f5				push af  
4588 3a 9c 45			ld a, (.dmark)  
458b 32 6b ee			ld (debug_mark),a  
458e 3a 9d 45			ld a, (.dmark+1)  
4591 32 6c ee			ld (debug_mark+1),a  
4594 3a 9e 45			ld a, (.dmark+2)  
4597 32 6d ee			ld (debug_mark+2),a  
459a 18 03			jr .pastdmark  
459c ..			.dmark: db "TCd"  
459f f1			.pastdmark: pop af  
45a0			endm  
# End of macro DMARK
45a0						CALLMONITOR 
45a0 cd 6f ee			call debug_vector  
45a3				endm  
# End of macro CALLMONITOR
45a3					endif 
45a3					NEXTW 
45a3 c3 5e 21			jp macro_next 
45a6				endm 
# End of macro NEXTW
45a6			 
45a6			.SUBSTR: 
45a6				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
45a6 48				db WORD_SYS_CORE+52             
45a7 04 46			dw .LEFT            
45a9 07				db 6 + 1 
45aa .. 00			db "SUBSTR",0              
45b1				endm 
# End of macro CWHEAD
45b1			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
45b1			 
45b1					if DEBUG_FORTH_WORDS_KEY 
45b1						DMARK "SST" 
45b1 f5				push af  
45b2 3a c6 45			ld a, (.dmark)  
45b5 32 6b ee			ld (debug_mark),a  
45b8 3a c7 45			ld a, (.dmark+1)  
45bb 32 6c ee			ld (debug_mark+1),a  
45be 3a c8 45			ld a, (.dmark+2)  
45c1 32 6d ee			ld (debug_mark+2),a  
45c4 18 03			jr .pastdmark  
45c6 ..			.dmark: db "SST"  
45c9 f1			.pastdmark: pop af  
45ca			endm  
# End of macro DMARK
45ca						CALLMONITOR 
45ca cd 6f ee			call debug_vector  
45cd				endm  
# End of macro CALLMONITOR
45cd					endif 
45cd			; TODO check string type 
45cd					FORTH_DSP_VALUEHL 
45cd cd a8 1f			call macro_dsp_valuehl 
45d0				endm 
# End of macro FORTH_DSP_VALUEHL
45d0			 
45d0 e5					push hl      ; string length 
45d1			 
45d1					FORTH_DSP_POP 
45d1 cd 60 20			call macro_forth_dsp_pop 
45d4				endm 
# End of macro FORTH_DSP_POP
45d4			 
45d4					FORTH_DSP_VALUEHL 
45d4 cd a8 1f			call macro_dsp_valuehl 
45d7				endm 
# End of macro FORTH_DSP_VALUEHL
45d7			 
45d7 e5					push hl     ; start char 
45d8			 
45d8					FORTH_DSP_POP 
45d8 cd 60 20			call macro_forth_dsp_pop 
45db				endm 
# End of macro FORTH_DSP_POP
45db			 
45db			 
45db					FORTH_DSP_VALUE 
45db cd 91 1f			call macro_forth_dsp_value 
45de				endm 
# End of macro FORTH_DSP_VALUE
45de			 
45de d1					pop de    ; get start post offset 
45df			 
45df 19					add hl, de    ; starting offset 
45e0			 
45e0 c1					pop bc 
45e1 c5					push bc      ; grab size of string 
45e2			 
45e2 e5					push hl    ; save string start  
45e3			 
45e3 26 00				ld h, 0 
45e5 69					ld l, c 
45e6 23					inc hl 
45e7 23					inc hl 
45e8			 
45e8 cd 18 14				call malloc 
45eb				if DEBUG_FORTH_MALLOC_GUARD 
45eb cc 1e 4f				call z,malloc_error 
45ee				endif 
45ee			 
45ee eb					ex de, hl      ; save malloc area for string copy 
45ef e1					pop hl    ; get back source 
45f0 c1					pop bc    ; get length of string back 
45f1			 
45f1 d5					push de    ; save malloc area for after we push 
45f2 ed b0				ldir     ; copy substr 
45f4			 
45f4			 
45f4 eb					ex de, hl 
45f5 3e 00				ld a, 0 
45f7 77					ld (hl), a   ; term substr 
45f8			 
45f8					 
45f8 e1					pop hl    ; get malloc so we can push it 
45f9 e5					push hl   ; save so we can free it afterwards 
45fa			 
45fa cd 1f 1e				call forth_push_str 
45fd			 
45fd e1					pop hl 
45fe cd e2 14				call free 
4601			 
4601					 
4601					 
4601			 
4601			 
4601					NEXTW 
4601 c3 5e 21			jp macro_next 
4604				endm 
# End of macro NEXTW
4604			 
4604			.LEFT: 
4604				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4604 48				db WORD_SYS_CORE+52             
4605 2c 46			dw .RIGHT            
4607 05				db 4 + 1 
4608 .. 00			db "LEFT",0              
460d				endm 
# End of macro CWHEAD
460d			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
460d					if DEBUG_FORTH_WORDS_KEY 
460d						DMARK "LEF" 
460d f5				push af  
460e 3a 22 46			ld a, (.dmark)  
4611 32 6b ee			ld (debug_mark),a  
4614 3a 23 46			ld a, (.dmark+1)  
4617 32 6c ee			ld (debug_mark+1),a  
461a 3a 24 46			ld a, (.dmark+2)  
461d 32 6d ee			ld (debug_mark+2),a  
4620 18 03			jr .pastdmark  
4622 ..			.dmark: db "LEF"  
4625 f1			.pastdmark: pop af  
4626			endm  
# End of macro DMARK
4626						CALLMONITOR 
4626 cd 6f ee			call debug_vector  
4629				endm  
# End of macro CALLMONITOR
4629					endif 
4629			 
4629					NEXTW 
4629 c3 5e 21			jp macro_next 
462c				endm 
# End of macro NEXTW
462c			.RIGHT: 
462c				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
462c 48				db WORD_SYS_CORE+52             
462d 55 46			dw .STR2NUM            
462f 06				db 5 + 1 
4630 .. 00			db "RIGHT",0              
4636				endm 
# End of macro CWHEAD
4636			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4636					if DEBUG_FORTH_WORDS_KEY 
4636						DMARK "RIG" 
4636 f5				push af  
4637 3a 4b 46			ld a, (.dmark)  
463a 32 6b ee			ld (debug_mark),a  
463d 3a 4c 46			ld a, (.dmark+1)  
4640 32 6c ee			ld (debug_mark+1),a  
4643 3a 4d 46			ld a, (.dmark+2)  
4646 32 6d ee			ld (debug_mark+2),a  
4649 18 03			jr .pastdmark  
464b ..			.dmark: db "RIG"  
464e f1			.pastdmark: pop af  
464f			endm  
# End of macro DMARK
464f						CALLMONITOR 
464f cd 6f ee			call debug_vector  
4652				endm  
# End of macro CALLMONITOR
4652					endif 
4652			 
4652					NEXTW 
4652 c3 5e 21			jp macro_next 
4655				endm 
# End of macro NEXTW
4655			 
4655			 
4655			.STR2NUM: 
4655				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4655 48				db WORD_SYS_CORE+52             
4656 e1 46			dw .NUM2STR            
4658 08				db 7 + 1 
4659 .. 00			db "STR2NUM",0              
4661				endm 
# End of macro CWHEAD
4661			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4661			 
4661			 
4661			; TODO STR type check to do 
4661					if DEBUG_FORTH_WORDS_KEY 
4661						DMARK "S2N" 
4661 f5				push af  
4662 3a 76 46			ld a, (.dmark)  
4665 32 6b ee			ld (debug_mark),a  
4668 3a 77 46			ld a, (.dmark+1)  
466b 32 6c ee			ld (debug_mark+1),a  
466e 3a 78 46			ld a, (.dmark+2)  
4671 32 6d ee			ld (debug_mark+2),a  
4674 18 03			jr .pastdmark  
4676 ..			.dmark: db "S2N"  
4679 f1			.pastdmark: pop af  
467a			endm  
# End of macro DMARK
467a						CALLMONITOR 
467a cd 6f ee			call debug_vector  
467d				endm  
# End of macro CALLMONITOR
467d					endif 
467d			 
467d					;FORTH_DSP 
467d					FORTH_DSP_VALUE 
467d cd 91 1f			call macro_forth_dsp_value 
4680				endm 
# End of macro FORTH_DSP_VALUE
4680					;inc hl 
4680			 
4680 eb					ex de, hl 
4681					if DEBUG_FORTH_WORDS 
4681						DMARK "S2a" 
4681 f5				push af  
4682 3a 96 46			ld a, (.dmark)  
4685 32 6b ee			ld (debug_mark),a  
4688 3a 97 46			ld a, (.dmark+1)  
468b 32 6c ee			ld (debug_mark+1),a  
468e 3a 98 46			ld a, (.dmark+2)  
4691 32 6d ee			ld (debug_mark+2),a  
4694 18 03			jr .pastdmark  
4696 ..			.dmark: db "S2a"  
4699 f1			.pastdmark: pop af  
469a			endm  
# End of macro DMARK
469a						CALLMONITOR 
469a cd 6f ee			call debug_vector  
469d				endm  
# End of macro CALLMONITOR
469d					endif 
469d cd 3a 13				call string_to_uint16 
46a0			 
46a0					if DEBUG_FORTH_WORDS 
46a0						DMARK "S2b" 
46a0 f5				push af  
46a1 3a b5 46			ld a, (.dmark)  
46a4 32 6b ee			ld (debug_mark),a  
46a7 3a b6 46			ld a, (.dmark+1)  
46aa 32 6c ee			ld (debug_mark+1),a  
46ad 3a b7 46			ld a, (.dmark+2)  
46b0 32 6d ee			ld (debug_mark+2),a  
46b3 18 03			jr .pastdmark  
46b5 ..			.dmark: db "S2b"  
46b8 f1			.pastdmark: pop af  
46b9			endm  
# End of macro DMARK
46b9						CALLMONITOR 
46b9 cd 6f ee			call debug_vector  
46bc				endm  
# End of macro CALLMONITOR
46bc					endif 
46bc			;		push hl 
46bc					FORTH_DSP_POP 
46bc cd 60 20			call macro_forth_dsp_pop 
46bf				endm 
# End of macro FORTH_DSP_POP
46bf			;		pop hl 
46bf					 
46bf					if DEBUG_FORTH_WORDS 
46bf						DMARK "S2b" 
46bf f5				push af  
46c0 3a d4 46			ld a, (.dmark)  
46c3 32 6b ee			ld (debug_mark),a  
46c6 3a d5 46			ld a, (.dmark+1)  
46c9 32 6c ee			ld (debug_mark+1),a  
46cc 3a d6 46			ld a, (.dmark+2)  
46cf 32 6d ee			ld (debug_mark+2),a  
46d2 18 03			jr .pastdmark  
46d4 ..			.dmark: db "S2b"  
46d7 f1			.pastdmark: pop af  
46d8			endm  
# End of macro DMARK
46d8						CALLMONITOR 
46d8 cd 6f ee			call debug_vector  
46db				endm  
# End of macro CALLMONITOR
46db					endif 
46db cd b1 1d				call forth_push_numhl	 
46de			 
46de				 
46de				       NEXTW 
46de c3 5e 21			jp macro_next 
46e1				endm 
# End of macro NEXTW
46e1			.NUM2STR: 
46e1				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
46e1 48				db WORD_SYS_CORE+52             
46e2 f0 46			dw .CONCAT            
46e4 08				db 7 + 1 
46e5 .. 00			db "NUM2STR",0              
46ed				endm 
# End of macro CWHEAD
46ed			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
46ed			 
46ed			;		; malloc a string to target 
46ed			;		ld hl, 10     ; TODO max string size should be fine 
46ed			;		call malloc 
46ed			;		push hl    ; save malloc location 
46ed			; 
46ed			; 
46ed			;; TODO check int type 
46ed			;		FORTH_DSP_VALUEHL 
46ed			;		ld a, l 
46ed			;		call DispAToASCII   
46ed			;;TODO need to chage above call to dump into string 
46ed			; 
46ed			; 
46ed			 
46ed				       NEXTW 
46ed c3 5e 21			jp macro_next 
46f0				endm 
# End of macro NEXTW
46f0			 
46f0			.CONCAT: 
46f0				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
46f0 48				db WORD_SYS_CORE+52             
46f1 a3 47			dw .FIND            
46f3 07				db 6 + 1 
46f4 .. 00			db "CONCAT",0              
46fb				endm 
# End of macro CWHEAD
46fb			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
46fb			 
46fb			; TODO check string type 
46fb			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
46fb			 
46fb					if DEBUG_FORTH_WORDS_KEY 
46fb						DMARK "CON" 
46fb f5				push af  
46fc 3a 10 47			ld a, (.dmark)  
46ff 32 6b ee			ld (debug_mark),a  
4702 3a 11 47			ld a, (.dmark+1)  
4705 32 6c ee			ld (debug_mark+1),a  
4708 3a 12 47			ld a, (.dmark+2)  
470b 32 6d ee			ld (debug_mark+2),a  
470e 18 03			jr .pastdmark  
4710 ..			.dmark: db "CON"  
4713 f1			.pastdmark: pop af  
4714			endm  
# End of macro DMARK
4714						CALLMONITOR 
4714 cd 6f ee			call debug_vector  
4717				endm  
# End of macro CALLMONITOR
4717					endif 
4717			 
4717			 
4717					FORTH_DSP_VALUE 
4717 cd 91 1f			call macro_forth_dsp_value 
471a				endm 
# End of macro FORTH_DSP_VALUE
471a e5					push hl   ; s2 
471b			 
471b					FORTH_DSP_POP 
471b cd 60 20			call macro_forth_dsp_pop 
471e				endm 
# End of macro FORTH_DSP_POP
471e			 
471e					FORTH_DSP_VALUE 
471e cd 91 1f			call macro_forth_dsp_value 
4721				endm 
# End of macro FORTH_DSP_VALUE
4721			 
4721 e5					push hl   ; s1 
4722			 
4722					FORTH_DSP_POP 
4722 cd 60 20			call macro_forth_dsp_pop 
4725				endm 
# End of macro FORTH_DSP_POP
4725					 
4725			 
4725					; copy s1 
4725			 
4725				 
4725					; save ptr 
4725 e1					pop hl  
4726 e5					push hl 
4727 3e 00				ld a, 0 
4729 cd ae 13				call strlent 
472c					;inc hl    ; zer0 
472c 06 00				ld b, 0 
472e 4d					ld c, l 
472f e1					pop hl		 
4730 11 c1 e2				ld de, scratch	 
4733					if DEBUG_FORTH_WORDS 
4733						DMARK "CO1" 
4733 f5				push af  
4734 3a 48 47			ld a, (.dmark)  
4737 32 6b ee			ld (debug_mark),a  
473a 3a 49 47			ld a, (.dmark+1)  
473d 32 6c ee			ld (debug_mark+1),a  
4740 3a 4a 47			ld a, (.dmark+2)  
4743 32 6d ee			ld (debug_mark+2),a  
4746 18 03			jr .pastdmark  
4748 ..			.dmark: db "CO1"  
474b f1			.pastdmark: pop af  
474c			endm  
# End of macro DMARK
474c						CALLMONITOR 
474c cd 6f ee			call debug_vector  
474f				endm  
# End of macro CALLMONITOR
474f					endif 
474f ed b0				ldir 
4751			 
4751 e1					pop hl 
4752 e5					push hl 
4753 d5					push de 
4754			 
4754			 
4754 3e 00				ld a, 0 
4756 cd ae 13				call strlent 
4759 23					inc hl    ; zer0 
475a 23					inc hl 
475b 06 00				ld b, 0 
475d 4d					ld c, l 
475e d1					pop de 
475f e1					pop hl		 
4760					if DEBUG_FORTH_WORDS 
4760						DMARK "CO2" 
4760 f5				push af  
4761 3a 75 47			ld a, (.dmark)  
4764 32 6b ee			ld (debug_mark),a  
4767 3a 76 47			ld a, (.dmark+1)  
476a 32 6c ee			ld (debug_mark+1),a  
476d 3a 77 47			ld a, (.dmark+2)  
4770 32 6d ee			ld (debug_mark+2),a  
4773 18 03			jr .pastdmark  
4775 ..			.dmark: db "CO2"  
4778 f1			.pastdmark: pop af  
4779			endm  
# End of macro DMARK
4779						CALLMONITOR 
4779 cd 6f ee			call debug_vector  
477c				endm  
# End of macro CALLMONITOR
477c					endif 
477c ed b0				ldir 
477e			 
477e			 
477e			 
477e 21 c1 e2				ld hl, scratch 
4781					if DEBUG_FORTH_WORDS 
4781						DMARK "CO5" 
4781 f5				push af  
4782 3a 96 47			ld a, (.dmark)  
4785 32 6b ee			ld (debug_mark),a  
4788 3a 97 47			ld a, (.dmark+1)  
478b 32 6c ee			ld (debug_mark+1),a  
478e 3a 98 47			ld a, (.dmark+2)  
4791 32 6d ee			ld (debug_mark+2),a  
4794 18 03			jr .pastdmark  
4796 ..			.dmark: db "CO5"  
4799 f1			.pastdmark: pop af  
479a			endm  
# End of macro DMARK
479a						CALLMONITOR 
479a cd 6f ee			call debug_vector  
479d				endm  
# End of macro CALLMONITOR
479d					endif 
479d			 
479d cd 1f 1e				call forth_push_str 
47a0			 
47a0			 
47a0			 
47a0			 
47a0				       NEXTW 
47a0 c3 5e 21			jp macro_next 
47a3				endm 
# End of macro NEXTW
47a3			 
47a3			 
47a3			.FIND: 
47a3				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
47a3 4b				db WORD_SYS_CORE+55             
47a4 61 48			dw .LEN            
47a6 05				db 4 + 1 
47a7 .. 00			db "FIND",0              
47ac				endm 
# End of macro CWHEAD
47ac			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
47ac			 
47ac					if DEBUG_FORTH_WORDS_KEY 
47ac						DMARK "FND" 
47ac f5				push af  
47ad 3a c1 47			ld a, (.dmark)  
47b0 32 6b ee			ld (debug_mark),a  
47b3 3a c2 47			ld a, (.dmark+1)  
47b6 32 6c ee			ld (debug_mark+1),a  
47b9 3a c3 47			ld a, (.dmark+2)  
47bc 32 6d ee			ld (debug_mark+2),a  
47bf 18 03			jr .pastdmark  
47c1 ..			.dmark: db "FND"  
47c4 f1			.pastdmark: pop af  
47c5			endm  
# End of macro DMARK
47c5						CALLMONITOR 
47c5 cd 6f ee			call debug_vector  
47c8				endm  
# End of macro CALLMONITOR
47c8					endif 
47c8			 
47c8			; TODO check string type 
47c8					FORTH_DSP_VALUE 
47c8 cd 91 1f			call macro_forth_dsp_value 
47cb				endm 
# End of macro FORTH_DSP_VALUE
47cb			 
47cb e5					push hl    
47cc 7e					ld a,(hl)    ; char to find   
47cd			; TODO change char to substr 
47cd			 
47cd f5					push af 
47ce					 
47ce			 
47ce			 
47ce					if DEBUG_FORTH_WORDS 
47ce						DMARK "FN1" 
47ce f5				push af  
47cf 3a e3 47			ld a, (.dmark)  
47d2 32 6b ee			ld (debug_mark),a  
47d5 3a e4 47			ld a, (.dmark+1)  
47d8 32 6c ee			ld (debug_mark+1),a  
47db 3a e5 47			ld a, (.dmark+2)  
47de 32 6d ee			ld (debug_mark+2),a  
47e1 18 03			jr .pastdmark  
47e3 ..			.dmark: db "FN1"  
47e6 f1			.pastdmark: pop af  
47e7			endm  
# End of macro DMARK
47e7						CALLMONITOR 
47e7 cd 6f ee			call debug_vector  
47ea				endm  
# End of macro CALLMONITOR
47ea					endif 
47ea			 
47ea					FORTH_DSP_POP 
47ea cd 60 20			call macro_forth_dsp_pop 
47ed				endm 
# End of macro FORTH_DSP_POP
47ed			 
47ed					; string to search 
47ed			 
47ed					FORTH_DSP_VALUE 
47ed cd 91 1f			call macro_forth_dsp_value 
47f0				endm 
# End of macro FORTH_DSP_VALUE
47f0			 
47f0 d1					pop de  ; d is char to find  
47f1			 
47f1					if DEBUG_FORTH_WORDS 
47f1						DMARK "FN2" 
47f1 f5				push af  
47f2 3a 06 48			ld a, (.dmark)  
47f5 32 6b ee			ld (debug_mark),a  
47f8 3a 07 48			ld a, (.dmark+1)  
47fb 32 6c ee			ld (debug_mark+1),a  
47fe 3a 08 48			ld a, (.dmark+2)  
4801 32 6d ee			ld (debug_mark+2),a  
4804 18 03			jr .pastdmark  
4806 ..			.dmark: db "FN2"  
4809 f1			.pastdmark: pop af  
480a			endm  
# End of macro DMARK
480a						CALLMONITOR 
480a cd 6f ee			call debug_vector  
480d				endm  
# End of macro CALLMONITOR
480d					endif 
480d					 
480d 01 00 00				ld bc, 0 
4810 7e			.findchar:      ld a,(hl) 
4811 fe 00				cp 0   		 
4813 28 27				jr z, .finddone     
4815 ba					cp d 
4816 28 20				jr z, .foundchar 
4818 03					inc bc 
4819 23					inc hl 
481a					if DEBUG_FORTH_WORDS 
481a						DMARK "FN3" 
481a f5				push af  
481b 3a 2f 48			ld a, (.dmark)  
481e 32 6b ee			ld (debug_mark),a  
4821 3a 30 48			ld a, (.dmark+1)  
4824 32 6c ee			ld (debug_mark+1),a  
4827 3a 31 48			ld a, (.dmark+2)  
482a 32 6d ee			ld (debug_mark+2),a  
482d 18 03			jr .pastdmark  
482f ..			.dmark: db "FN3"  
4832 f1			.pastdmark: pop af  
4833			endm  
# End of macro DMARK
4833						CALLMONITOR 
4833 cd 6f ee			call debug_vector  
4836				endm  
# End of macro CALLMONITOR
4836					endif 
4836 18 d8				jr .findchar 
4838			 
4838			 
4838 c5			.foundchar:	push bc 
4839 e1					pop hl 
483a 18 03				jr .findexit 
483c			 
483c			 
483c							 
483c			 
483c			.finddone:     ; got to end of string with no find 
483c 21 00 00				ld hl, 0 
483f			.findexit: 
483f			 
483f					if DEBUG_FORTH_WORDS 
483f						DMARK "FNd" 
483f f5				push af  
4840 3a 54 48			ld a, (.dmark)  
4843 32 6b ee			ld (debug_mark),a  
4846 3a 55 48			ld a, (.dmark+1)  
4849 32 6c ee			ld (debug_mark+1),a  
484c 3a 56 48			ld a, (.dmark+2)  
484f 32 6d ee			ld (debug_mark+2),a  
4852 18 03			jr .pastdmark  
4854 ..			.dmark: db "FNd"  
4857 f1			.pastdmark: pop af  
4858			endm  
# End of macro DMARK
4858						CALLMONITOR 
4858 cd 6f ee			call debug_vector  
485b				endm  
# End of macro CALLMONITOR
485b					endif 
485b cd b1 1d			call forth_push_numhl 
485e			 
485e				       NEXTW 
485e c3 5e 21			jp macro_next 
4861				endm 
# End of macro NEXTW
4861			 
4861			.LEN: 
4861				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4861 4c				db WORD_SYS_CORE+56             
4862 cb 48			dw .ASC            
4864 06				db 5 + 1 
4865 .. 00			db "COUNT",0              
486b				endm 
# End of macro CWHEAD
486b			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
486b			 
486b					if DEBUG_FORTH_WORDS_KEY 
486b						DMARK "CNT" 
486b f5				push af  
486c 3a 80 48			ld a, (.dmark)  
486f 32 6b ee			ld (debug_mark),a  
4872 3a 81 48			ld a, (.dmark+1)  
4875 32 6c ee			ld (debug_mark+1),a  
4878 3a 82 48			ld a, (.dmark+2)  
487b 32 6d ee			ld (debug_mark+2),a  
487e 18 03			jr .pastdmark  
4880 ..			.dmark: db "CNT"  
4883 f1			.pastdmark: pop af  
4884			endm  
# End of macro DMARK
4884						CALLMONITOR 
4884 cd 6f ee			call debug_vector  
4887				endm  
# End of macro CALLMONITOR
4887					endif 
4887			; TODO check string type 
4887					FORTH_DSP_VALUE 
4887 cd 91 1f			call macro_forth_dsp_value 
488a				endm 
# End of macro FORTH_DSP_VALUE
488a			 
488a			 
488a					if DEBUG_FORTH_WORDS 
488a						DMARK "CN?" 
488a f5				push af  
488b 3a 9f 48			ld a, (.dmark)  
488e 32 6b ee			ld (debug_mark),a  
4891 3a a0 48			ld a, (.dmark+1)  
4894 32 6c ee			ld (debug_mark+1),a  
4897 3a a1 48			ld a, (.dmark+2)  
489a 32 6d ee			ld (debug_mark+2),a  
489d 18 03			jr .pastdmark  
489f ..			.dmark: db "CN?"  
48a2 f1			.pastdmark: pop af  
48a3			endm  
# End of macro DMARK
48a3						CALLMONITOR 
48a3 cd 6f ee			call debug_vector  
48a6				endm  
# End of macro CALLMONITOR
48a6					endif 
48a6 cd a3 13				call strlenz 
48a9					if DEBUG_FORTH_WORDS 
48a9						DMARK "CNl" 
48a9 f5				push af  
48aa 3a be 48			ld a, (.dmark)  
48ad 32 6b ee			ld (debug_mark),a  
48b0 3a bf 48			ld a, (.dmark+1)  
48b3 32 6c ee			ld (debug_mark+1),a  
48b6 3a c0 48			ld a, (.dmark+2)  
48b9 32 6d ee			ld (debug_mark+2),a  
48bc 18 03			jr .pastdmark  
48be ..			.dmark: db "CNl"  
48c1 f1			.pastdmark: pop af  
48c2			endm  
# End of macro DMARK
48c2						CALLMONITOR 
48c2 cd 6f ee			call debug_vector  
48c5				endm  
# End of macro CALLMONITOR
48c5					endif 
48c5			 
48c5 cd b1 1d				call forth_push_numhl 
48c8			 
48c8			 
48c8			 
48c8				       NEXTW 
48c8 c3 5e 21			jp macro_next 
48cb				endm 
# End of macro NEXTW
48cb			.ASC: 
48cb				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
48cb 4d				db WORD_SYS_CORE+57             
48cc 39 49			dw .CHR            
48ce 04				db 3 + 1 
48cf .. 00			db "ASC",0              
48d3				endm 
# End of macro CWHEAD
48d3			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
48d3					if DEBUG_FORTH_WORDS_KEY 
48d3						DMARK "ASC" 
48d3 f5				push af  
48d4 3a e8 48			ld a, (.dmark)  
48d7 32 6b ee			ld (debug_mark),a  
48da 3a e9 48			ld a, (.dmark+1)  
48dd 32 6c ee			ld (debug_mark+1),a  
48e0 3a ea 48			ld a, (.dmark+2)  
48e3 32 6d ee			ld (debug_mark+2),a  
48e6 18 03			jr .pastdmark  
48e8 ..			.dmark: db "ASC"  
48eb f1			.pastdmark: pop af  
48ec			endm  
# End of macro DMARK
48ec						CALLMONITOR 
48ec cd 6f ee			call debug_vector  
48ef				endm  
# End of macro CALLMONITOR
48ef					endif 
48ef					FORTH_DSP_VALUE 
48ef cd 91 1f			call macro_forth_dsp_value 
48f2				endm 
# End of macro FORTH_DSP_VALUE
48f2					;v5 FORTH_DSP_VALUE 
48f2			;		inc hl      ; now at start of numeric as string 
48f2			 
48f2 e5					push hl 
48f3			 
48f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48f3 cd 60 20			call macro_forth_dsp_pop 
48f6				endm 
# End of macro FORTH_DSP_POP
48f6			 
48f6 e1					pop hl 
48f7			 
48f7					if DEBUG_FORTH_WORDS 
48f7						DMARK "AS1" 
48f7 f5				push af  
48f8 3a 0c 49			ld a, (.dmark)  
48fb 32 6b ee			ld (debug_mark),a  
48fe 3a 0d 49			ld a, (.dmark+1)  
4901 32 6c ee			ld (debug_mark+1),a  
4904 3a 0e 49			ld a, (.dmark+2)  
4907 32 6d ee			ld (debug_mark+2),a  
490a 18 03			jr .pastdmark  
490c ..			.dmark: db "AS1"  
490f f1			.pastdmark: pop af  
4910			endm  
# End of macro DMARK
4910						CALLMONITOR 
4910 cd 6f ee			call debug_vector  
4913				endm  
# End of macro CALLMONITOR
4913					endif 
4913					; push the content of a onto the stack as a value 
4913			 
4913 7e					ld a,(hl)   ; get char 
4914 26 00				ld h,0 
4916 6f					ld l,a 
4917					if DEBUG_FORTH_WORDS 
4917						DMARK "AS2" 
4917 f5				push af  
4918 3a 2c 49			ld a, (.dmark)  
491b 32 6b ee			ld (debug_mark),a  
491e 3a 2d 49			ld a, (.dmark+1)  
4921 32 6c ee			ld (debug_mark+1),a  
4924 3a 2e 49			ld a, (.dmark+2)  
4927 32 6d ee			ld (debug_mark+2),a  
492a 18 03			jr .pastdmark  
492c ..			.dmark: db "AS2"  
492f f1			.pastdmark: pop af  
4930			endm  
# End of macro DMARK
4930						CALLMONITOR 
4930 cd 6f ee			call debug_vector  
4933				endm  
# End of macro CALLMONITOR
4933					endif 
4933 cd b1 1d				call forth_push_numhl 
4936			 
4936				       NEXTW 
4936 c3 5e 21			jp macro_next 
4939				endm 
# End of macro NEXTW
4939			 
4939			.CHR: 
4939				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4939 4d				db WORD_SYS_CORE+57             
493a 75 49			dw .ENDSTR            
493c 04				db 3 + 1 
493d .. 00			db "CHR",0              
4941				endm 
# End of macro CWHEAD
4941			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4941					if DEBUG_FORTH_WORDS_KEY 
4941						DMARK "CHR" 
4941 f5				push af  
4942 3a 56 49			ld a, (.dmark)  
4945 32 6b ee			ld (debug_mark),a  
4948 3a 57 49			ld a, (.dmark+1)  
494b 32 6c ee			ld (debug_mark+1),a  
494e 3a 58 49			ld a, (.dmark+2)  
4951 32 6d ee			ld (debug_mark+2),a  
4954 18 03			jr .pastdmark  
4956 ..			.dmark: db "CHR"  
4959 f1			.pastdmark: pop af  
495a			endm  
# End of macro DMARK
495a						CALLMONITOR 
495a cd 6f ee			call debug_vector  
495d				endm  
# End of macro CALLMONITOR
495d					endif 
495d					FORTH_DSP_VALUEHL 
495d cd a8 1f			call macro_dsp_valuehl 
4960				endm 
# End of macro FORTH_DSP_VALUEHL
4960			 
4960					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4960 cd 60 20			call macro_forth_dsp_pop 
4963				endm 
# End of macro FORTH_DSP_POP
4963			 
4963					; save asci byte as a zero term string and push string 
4963			 
4963 7d					ld a,l 
4964 32 c1 e2				ld (scratch), a 
4967			 
4967 3e 00				ld a, 0 
4969 32 c2 e2				ld (scratch+1), a 
496c			 
496c 21 c1 e2				ld hl, scratch 
496f cd 1f 1e				call forth_push_str 
4972			 
4972			 
4972				       NEXTW 
4972 c3 5e 21			jp macro_next 
4975				endm 
# End of macro NEXTW
4975			 
4975			 
4975			 
4975			 
4975			.ENDSTR: 
4975			; eof 
4975			 
# End of file forth_words_str.asm
4975			include "forth_words_key.asm" 
4975			 
4975			; | ## Keyboard Words 
4975			 
4975			.KEY: 
4975				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4975 3e				db WORD_SYS_CORE+42             
4976 a5 49			dw .WAITK            
4978 04				db 3 + 1 
4979 .. 00			db "KEY",0              
497d				endm 
# End of macro CWHEAD
497d			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
497d			 
497d					if DEBUG_FORTH_WORDS_KEY 
497d						DMARK "KEY" 
497d f5				push af  
497e 3a 92 49			ld a, (.dmark)  
4981 32 6b ee			ld (debug_mark),a  
4984 3a 93 49			ld a, (.dmark+1)  
4987 32 6c ee			ld (debug_mark+1),a  
498a 3a 94 49			ld a, (.dmark+2)  
498d 32 6d ee			ld (debug_mark+2),a  
4990 18 03			jr .pastdmark  
4992 ..			.dmark: db "KEY"  
4995 f1			.pastdmark: pop af  
4996			endm  
# End of macro DMARK
4996						CALLMONITOR 
4996 cd 6f ee			call debug_vector  
4999				endm  
# End of macro CALLMONITOR
4999					endif 
4999			; TODO currently waits 
4999 cd 8d 67				call cin 
499c					;call cin_wait 
499c 6f					ld l, a 
499d 26 00				ld h, 0 
499f cd b1 1d				call forth_push_numhl 
49a2					NEXTW 
49a2 c3 5e 21			jp macro_next 
49a5				endm 
# End of macro NEXTW
49a5			.WAITK: 
49a5				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
49a5 3f				db WORD_SYS_CORE+43             
49a6 d7 49			dw .ACCEPT            
49a8 06				db 5 + 1 
49a9 .. 00			db "WAITK",0              
49af				endm 
# End of macro CWHEAD
49af			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
49af					if DEBUG_FORTH_WORDS_KEY 
49af						DMARK "WAI" 
49af f5				push af  
49b0 3a c4 49			ld a, (.dmark)  
49b3 32 6b ee			ld (debug_mark),a  
49b6 3a c5 49			ld a, (.dmark+1)  
49b9 32 6c ee			ld (debug_mark+1),a  
49bc 3a c6 49			ld a, (.dmark+2)  
49bf 32 6d ee			ld (debug_mark+2),a  
49c2 18 03			jr .pastdmark  
49c4 ..			.dmark: db "WAI"  
49c7 f1			.pastdmark: pop af  
49c8			endm  
# End of macro DMARK
49c8						CALLMONITOR 
49c8 cd 6f ee			call debug_vector  
49cb				endm  
# End of macro CALLMONITOR
49cb					endif 
49cb cd 85 67				call cin_wait 
49ce 6f					ld l, a 
49cf 26 00				ld h, 0 
49d1 cd b1 1d				call forth_push_numhl 
49d4					NEXTW 
49d4 c3 5e 21			jp macro_next 
49d7				endm 
# End of macro NEXTW
49d7			.ACCEPT: 
49d7				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
49d7 40				db WORD_SYS_CORE+44             
49d8 35 4a			dw .EDIT            
49da 07				db 6 + 1 
49db .. 00			db "ACCEPT",0              
49e2				endm 
# End of macro CWHEAD
49e2			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
49e2					; TODO crashes on push 
49e2					if DEBUG_FORTH_WORDS_KEY 
49e2						DMARK "ACC" 
49e2 f5				push af  
49e3 3a f7 49			ld a, (.dmark)  
49e6 32 6b ee			ld (debug_mark),a  
49e9 3a f8 49			ld a, (.dmark+1)  
49ec 32 6c ee			ld (debug_mark+1),a  
49ef 3a f9 49			ld a, (.dmark+2)  
49f2 32 6d ee			ld (debug_mark+2),a  
49f5 18 03			jr .pastdmark  
49f7 ..			.dmark: db "ACC"  
49fa f1			.pastdmark: pop af  
49fb			endm  
# End of macro DMARK
49fb						CALLMONITOR 
49fb cd 6f ee			call debug_vector  
49fe				endm  
# End of macro CALLMONITOR
49fe					endif 
49fe 21 bf e4				ld hl, os_input 
4a01 3e 00				ld a, 0 
4a03 77					ld (hl),a 
4a04 3a 5e ea				ld a,(f_cursor_ptr) 
4a07 16 64				ld d, 100 
4a09 0e 00				ld c, 0 
4a0b 1e 28				ld e, 40 
4a0d cd 13 0e				call input_str 
4a10					; TODO perhaps do a type check and wrap in quotes if not a number 
4a10 21 bf e4				ld hl, os_input 
4a13					if DEBUG_FORTH_WORDS 
4a13						DMARK "AC1" 
4a13 f5				push af  
4a14 3a 28 4a			ld a, (.dmark)  
4a17 32 6b ee			ld (debug_mark),a  
4a1a 3a 29 4a			ld a, (.dmark+1)  
4a1d 32 6c ee			ld (debug_mark+1),a  
4a20 3a 2a 4a			ld a, (.dmark+2)  
4a23 32 6d ee			ld (debug_mark+2),a  
4a26 18 03			jr .pastdmark  
4a28 ..			.dmark: db "AC1"  
4a2b f1			.pastdmark: pop af  
4a2c			endm  
# End of macro DMARK
4a2c						CALLMONITOR 
4a2c cd 6f ee			call debug_vector  
4a2f				endm  
# End of macro CALLMONITOR
4a2f					endif 
4a2f cd 1f 1e				call forth_push_str 
4a32					NEXTW 
4a32 c3 5e 21			jp macro_next 
4a35				endm 
# End of macro NEXTW
4a35			 
4a35			.EDIT: 
4a35				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4a35 40				db WORD_SYS_CORE+44             
4a36 d7 4a			dw .DEDIT            
4a38 05				db 4 + 1 
4a39 .. 00			db "EDIT",0              
4a3e				endm 
# End of macro CWHEAD
4a3e			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4a3e			 
4a3e					; TODO does not copy from stack 
4a3e					if DEBUG_FORTH_WORDS_KEY 
4a3e						DMARK "EDT" 
4a3e f5				push af  
4a3f 3a 53 4a			ld a, (.dmark)  
4a42 32 6b ee			ld (debug_mark),a  
4a45 3a 54 4a			ld a, (.dmark+1)  
4a48 32 6c ee			ld (debug_mark+1),a  
4a4b 3a 55 4a			ld a, (.dmark+2)  
4a4e 32 6d ee			ld (debug_mark+2),a  
4a51 18 03			jr .pastdmark  
4a53 ..			.dmark: db "EDT"  
4a56 f1			.pastdmark: pop af  
4a57			endm  
# End of macro DMARK
4a57						CALLMONITOR 
4a57 cd 6f ee			call debug_vector  
4a5a				endm  
# End of macro CALLMONITOR
4a5a					endif 
4a5a			 
4a5a					;FORTH_DSP 
4a5a					FORTH_DSP_VALUEHL 
4a5a cd a8 1f			call macro_dsp_valuehl 
4a5d				endm 
# End of macro FORTH_DSP_VALUEHL
4a5d			;		inc hl    ; TODO do type check 
4a5d			 
4a5d			;		call get_word_hl 
4a5d e5					push hl 
4a5e					if DEBUG_FORTH_WORDS 
4a5e						DMARK "EDp" 
4a5e f5				push af  
4a5f 3a 73 4a			ld a, (.dmark)  
4a62 32 6b ee			ld (debug_mark),a  
4a65 3a 74 4a			ld a, (.dmark+1)  
4a68 32 6c ee			ld (debug_mark+1),a  
4a6b 3a 75 4a			ld a, (.dmark+2)  
4a6e 32 6d ee			ld (debug_mark+2),a  
4a71 18 03			jr .pastdmark  
4a73 ..			.dmark: db "EDp"  
4a76 f1			.pastdmark: pop af  
4a77			endm  
# End of macro DMARK
4a77						CALLMONITOR 
4a77 cd 6f ee			call debug_vector  
4a7a				endm  
# End of macro CALLMONITOR
4a7a					endif 
4a7a				;	ld a, 0 
4a7a cd a3 13				call strlenz 
4a7d 23					inc hl 
4a7e			 
4a7e 06 00				ld b, 0 
4a80 4d					ld c, l 
4a81			 
4a81 e1					pop hl 
4a82 11 bf e4				ld de, os_input 
4a85					if DEBUG_FORTH_WORDS_KEY 
4a85						DMARK "EDc" 
4a85 f5				push af  
4a86 3a 9a 4a			ld a, (.dmark)  
4a89 32 6b ee			ld (debug_mark),a  
4a8c 3a 9b 4a			ld a, (.dmark+1)  
4a8f 32 6c ee			ld (debug_mark+1),a  
4a92 3a 9c 4a			ld a, (.dmark+2)  
4a95 32 6d ee			ld (debug_mark+2),a  
4a98 18 03			jr .pastdmark  
4a9a ..			.dmark: db "EDc"  
4a9d f1			.pastdmark: pop af  
4a9e			endm  
# End of macro DMARK
4a9e						CALLMONITOR 
4a9e cd 6f ee			call debug_vector  
4aa1				endm  
# End of macro CALLMONITOR
4aa1					endif 
4aa1 ed b0				ldir 
4aa3			 
4aa3			 
4aa3 21 bf e4				ld hl, os_input 
4aa6					;ld a, 0 
4aa6					;ld (hl),a 
4aa6 3a 5e ea				ld a,(f_cursor_ptr) 
4aa9 16 64				ld d, 100 
4aab 0e 00				ld c, 0 
4aad 1e 28				ld e, 40 
4aaf cd 13 0e				call input_str 
4ab2					; TODO perhaps do a type check and wrap in quotes if not a number 
4ab2 21 bf e4				ld hl, os_input 
4ab5					if DEBUG_FORTH_WORDS 
4ab5						DMARK "ED1" 
4ab5 f5				push af  
4ab6 3a ca 4a			ld a, (.dmark)  
4ab9 32 6b ee			ld (debug_mark),a  
4abc 3a cb 4a			ld a, (.dmark+1)  
4abf 32 6c ee			ld (debug_mark+1),a  
4ac2 3a cc 4a			ld a, (.dmark+2)  
4ac5 32 6d ee			ld (debug_mark+2),a  
4ac8 18 03			jr .pastdmark  
4aca ..			.dmark: db "ED1"  
4acd f1			.pastdmark: pop af  
4ace			endm  
# End of macro DMARK
4ace						CALLMONITOR 
4ace cd 6f ee			call debug_vector  
4ad1				endm  
# End of macro CALLMONITOR
4ad1					endif 
4ad1 cd 1f 1e				call forth_push_str 
4ad4					NEXTW 
4ad4 c3 5e 21			jp macro_next 
4ad7				endm 
# End of macro NEXTW
4ad7			 
4ad7			.DEDIT: 
4ad7				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4ad7 40				db WORD_SYS_CORE+44             
4ad8 39 4b			dw .ENDKEY            
4ada 06				db 5 + 1 
4adb .. 00			db "DEDIT",0              
4ae1				endm 
# End of macro CWHEAD
4ae1			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4ae1			 
4ae1					; TODO does not copy from stack 
4ae1					if DEBUG_FORTH_WORDS_KEY 
4ae1						DMARK "DED" 
4ae1 f5				push af  
4ae2 3a f6 4a			ld a, (.dmark)  
4ae5 32 6b ee			ld (debug_mark),a  
4ae8 3a f7 4a			ld a, (.dmark+1)  
4aeb 32 6c ee			ld (debug_mark+1),a  
4aee 3a f8 4a			ld a, (.dmark+2)  
4af1 32 6d ee			ld (debug_mark+2),a  
4af4 18 03			jr .pastdmark  
4af6 ..			.dmark: db "DED"  
4af9 f1			.pastdmark: pop af  
4afa			endm  
# End of macro DMARK
4afa						CALLMONITOR 
4afa cd 6f ee			call debug_vector  
4afd				endm  
# End of macro CALLMONITOR
4afd					endif 
4afd			 
4afd					;FORTH_DSP 
4afd					FORTH_DSP_VALUEHL 
4afd cd a8 1f			call macro_dsp_valuehl 
4b00				endm 
# End of macro FORTH_DSP_VALUEHL
4b00			;		inc hl    ; TODO do type check 
4b00			 
4b00			;		call get_word_hl 
4b00 e5					push hl 
4b01 e5					push hl 
4b02					FORTH_DSP_POP 
4b02 cd 60 20			call macro_forth_dsp_pop 
4b05				endm 
# End of macro FORTH_DSP_POP
4b05 e1					pop hl 
4b06					if DEBUG_FORTH_WORDS 
4b06						DMARK "EDp" 
4b06 f5				push af  
4b07 3a 1b 4b			ld a, (.dmark)  
4b0a 32 6b ee			ld (debug_mark),a  
4b0d 3a 1c 4b			ld a, (.dmark+1)  
4b10 32 6c ee			ld (debug_mark+1),a  
4b13 3a 1d 4b			ld a, (.dmark+2)  
4b16 32 6d ee			ld (debug_mark+2),a  
4b19 18 03			jr .pastdmark  
4b1b ..			.dmark: db "EDp"  
4b1e f1			.pastdmark: pop af  
4b1f			endm  
# End of macro DMARK
4b1f						CALLMONITOR 
4b1f cd 6f ee			call debug_vector  
4b22				endm  
# End of macro CALLMONITOR
4b22					endif 
4b22				;	ld a, 0 
4b22 cd a3 13				call strlenz 
4b25 23					inc hl 
4b26			 
4b26 06 00				ld b, 0 
4b28 4d					ld c, l 
4b29			 
4b29 e1					pop hl 
4b2a			 
4b2a					;ld a, 0 
4b2a					;ld (hl),a 
4b2a 3a 5e ea				ld a,(f_cursor_ptr) 
4b2d 16 64				ld d, 100 
4b2f 0e 00				ld c, 0 
4b31 1e 28				ld e, 40 
4b33 cd 13 0e				call input_str 
4b36					; TODO perhaps do a type check and wrap in quotes if not a number 
4b36					NEXTW 
4b36 c3 5e 21			jp macro_next 
4b39				endm 
# End of macro NEXTW
4b39			 
4b39			 
4b39			.ENDKEY: 
4b39			; eof 
4b39			 
# End of file forth_words_key.asm
4b39			include "forth_words_const.asm" 
4b39			 
4b39			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4b39			 
4b39			 
4b39			.SPITIME: 
4b39				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4b39 77				db WORD_SYS_CORE+99             
4b3a 4e 4b			dw .VA            
4b3c 08				db 7 + 1 
4b3d .. 00			db "SPITIME",0              
4b45				endm 
# End of macro CWHEAD
4b45			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
4b45			; 
4b45			; | | If using BANK devices then leave as is. 
4b45			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
4b45			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
4b45			 
4b45 21 64 ea				ld hl, spi_clktime  
4b48 cd b1 1d				call forth_push_numhl 
4b4b			 
4b4b					NEXTW 
4b4b c3 5e 21			jp macro_next 
4b4e				endm 
# End of macro NEXTW
4b4e			 
4b4e			 
4b4e			.VA: 
4b4e				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4b4e 77				db WORD_SYS_CORE+99             
4b4f 5e 4b			dw .SYMBOL            
4b51 03				db 2 + 1 
4b52 .. 00			db "VA",0              
4b55				endm 
# End of macro CWHEAD
4b55			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
4b55 21 28 ea				ld hl, cli_var_array 
4b58 cd b1 1d				call forth_push_numhl 
4b5b			 
4b5b					NEXTW 
4b5b c3 5e 21			jp macro_next 
4b5e				endm 
# End of macro NEXTW
4b5e			 
4b5e			.SYMBOL: 
4b5e				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4b5e 77				db WORD_SYS_CORE+99             
4b5f 68 4c			dw .ENDCONST            
4b61 07				db 6 + 1 
4b62 .. 00			db "SYMBOL",0              
4b69				endm 
# End of macro CWHEAD
4b69			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4b69			; | 
4b69			; | | The value is the number reference and the final address is pushed to stack 
4b69			 
4b69			; | | ``` 
4b69			; | | dw sym_table 
4b69			; | | dw nmi_vector 
4b69			; | | dw cli_autodisplay 
4b69			; | | dw cli_data_sp 
4b69			; | | dw cli_data_stack 
4b69			; | | dw cli_loop_sp 
4b69			; | | dw cli_loop_stack 
4b69			; | | dw cli_var_array 
4b69			; | | dw cursor_col 
4b69			; | | dw cursor_ptr 
4b69			; | | ; 10 
4b69			; | | dw cursor_row 
4b69			; | | dw debug_mark 
4b69			; | | dw display_fb0 
4b69			; | | dw display_fb1 
4b69			; | | dw display_fb2 
4b69			; | | dw display_fb3 
4b69			; | | dw display_fb_active 
4b69			; | | dw execscratch 
4b69			; | | dw f_cursor_ptr 
4b69			; | | dw hardware_word 
4b69			; | | ;20 
4b69			; | | dw input_at_cursor 
4b69			; | | dw input_at_pos 
4b69			; | | dw input_cur_flash 
4b69			; | | dw input_cur_onoff 
4b69			; | | dw input_cursor 
4b69			; | | dw input_display_size 
4b69			; | | dw input_len 
4b69			; | | dw input_ptr 
4b69			; | | dw input_size 
4b69			; | | dw input_start 
4b69			; | | ; 30 
4b69			; | | dw input_str 
4b69			; | | dw input_under_cursor 
4b69			; | | dw os_cli_cmd 
4b69			; | | dw os_cur_ptr 
4b69			; | | dw os_current_i 
4b69			; | | dw os_input 
4b69			; | | dw os_last_cmd 
4b69			; | | dw os_last_new_uword 
4b69			; | | dw debug_vector 
4b69			; | | dw os_view_hl 
4b69			; | | ;40 
4b69			; | | dw os_word_scratch 
4b69			; | | dw portbctl 
4b69			; | | dw portbdata 
4b69			; | | dw spi_cartdev 
4b69			; | | dw spi_cartdev2 
4b69			; | | dw spi_clktime 
4b69			; | | dw spi_device 
4b69			; | | dw spi_device_id 
4b69			; | | dw spi_portbyte 
4b69			; | | dw stackstore 
4b69			; | | ; 50 
4b69			; | | if STORAGE_SE 
4b69			; | | dw storage_actl 
4b69			; | | dw storage_adata 
4b69			; | | else 
4b69			; | | dw 0 
4b69			; | | dw 0 
4b69			; | | endif 
4b69			; | | dw storage_append 
4b69			; | | if STORAGE_SE 
4b69			; | | dw storage_bctl 
4b69			; | | else 
4b69			; | | dw 0 
4b69			; | | endif 
4b69			; | | dw store_bank_active 
4b69			; | | dw store_filecache 
4b69			; | | dw store_longread 
4b69			; | | dw store_openaddr 
4b69			; | | dw store_openext 
4b69			; | | dw store_openmaxext 
4b69			; | | ; 60 
4b69			; | | dw store_page 
4b69			; | | dw store_readbuf 
4b69			; | | dw store_readcont 
4b69			; | | dw store_readptr 
4b69			; | | dw store_tmpext 
4b69			; | | dw store_tmpid 
4b69			; | | dw store_tmppageid 
4b69			; | | dw malloc 
4b69			; | | dw free 
4b69			; | | dw cin 
4b69			; | | ; 70 
4b69			; | | dw cin_wait 
4b69			; | | dw forth_push_numhl 
4b69			; | | dw forth_push_str 
4b69			; | | ``` 
4b69			 
4b69					if DEBUG_FORTH_WORDS_KEY 
4b69						DMARK "SYM" 
4b69 f5				push af  
4b6a 3a 7e 4b			ld a, (.dmark)  
4b6d 32 6b ee			ld (debug_mark),a  
4b70 3a 7f 4b			ld a, (.dmark+1)  
4b73 32 6c ee			ld (debug_mark+1),a  
4b76 3a 80 4b			ld a, (.dmark+2)  
4b79 32 6d ee			ld (debug_mark+2),a  
4b7c 18 03			jr .pastdmark  
4b7e ..			.dmark: db "SYM"  
4b81 f1			.pastdmark: pop af  
4b82			endm  
# End of macro DMARK
4b82						CALLMONITOR 
4b82 cd 6f ee			call debug_vector  
4b85				endm  
# End of macro CALLMONITOR
4b85					endif 
4b85			 
4b85					FORTH_DSP_VALUEHL 
4b85 cd a8 1f			call macro_dsp_valuehl 
4b88				endm 
# End of macro FORTH_DSP_VALUEHL
4b88			 
4b88 7d					ld a, l     
4b89			 
4b89			 
4b89					if DEBUG_FORTH_WORDS 
4b89						DMARK "SY1" 
4b89 f5				push af  
4b8a 3a 9e 4b			ld a, (.dmark)  
4b8d 32 6b ee			ld (debug_mark),a  
4b90 3a 9f 4b			ld a, (.dmark+1)  
4b93 32 6c ee			ld (debug_mark+1),a  
4b96 3a a0 4b			ld a, (.dmark+2)  
4b99 32 6d ee			ld (debug_mark+2),a  
4b9c 18 03			jr .pastdmark  
4b9e ..			.dmark: db "SY1"  
4ba1 f1			.pastdmark: pop af  
4ba2			endm  
# End of macro DMARK
4ba2						CALLMONITOR 
4ba2 cd 6f ee			call debug_vector  
4ba5				endm  
# End of macro CALLMONITOR
4ba5					endif 
4ba5					 
4ba5 f5					push af	 
4ba6					FORTH_DSP_POP 
4ba6 cd 60 20			call macro_forth_dsp_pop 
4ba9				endm 
# End of macro FORTH_DSP_POP
4ba9 f1					pop af 
4baa			 
4baa cb 27				sla a  
4bac				 
4bac					 
4bac					if DEBUG_FORTH_WORDS 
4bac						DMARK "SY" 
4bac f5				push af  
4bad 3a c1 4b			ld a, (.dmark)  
4bb0 32 6b ee			ld (debug_mark),a  
4bb3 3a c2 4b			ld a, (.dmark+1)  
4bb6 32 6c ee			ld (debug_mark+1),a  
4bb9 3a c3 4b			ld a, (.dmark+2)  
4bbc 32 6d ee			ld (debug_mark+2),a  
4bbf 18 02			jr .pastdmark  
4bc1 ..			.dmark: db "SY"  
4bc3 f1			.pastdmark: pop af  
4bc4			endm  
# End of macro DMARK
4bc4						CALLMONITOR 
4bc4 cd 6f ee			call debug_vector  
4bc7				endm  
# End of macro CALLMONITOR
4bc7					endif 
4bc7			 
4bc7 21 d6 4b				ld hl, sym_table 
4bca cd e6 0d				call addatohl 
4bcd cd e0 20				call loadwordinhl 
4bd0 cd b1 1d				call forth_push_numhl 
4bd3			 
4bd3			 
4bd3				       NEXTW 
4bd3 c3 5e 21			jp macro_next 
4bd6				endm 
# End of macro NEXTW
4bd6			 
4bd6			sym_table: 
4bd6			 
4bd6			; 0 
4bd6 d6 4b		dw sym_table 
4bd8 72 ee		dw nmi_vector 
4bda 3c ea		dw cli_autodisplay 
4bdc ee e9		dw cli_data_sp 
4bde 28 e8		dw cli_data_stack 
4be0 f0 e9		dw cli_loop_sp 
4be2 2a e9		dw cli_loop_stack 
4be4 28 ea		dw cli_var_array 
4be6 c5 eb		dw cursor_col 
4be8 c3 eb		dw cursor_ptr 
4bea			; 10 
4bea c4 eb		dw cursor_row 
4bec 6b ee		dw debug_mark 
4bee b1 ed		dw display_fb0 
4bf0 10 ed		dw display_fb1 
4bf2 ce eb		dw display_fb2 
4bf4 6f ec		dw display_fb3 
4bf6 cc eb		dw display_fb_active 
4bf8 c0 e3		dw execscratch 
4bfa 5e ea		dw f_cursor_ptr 
4bfc 75 ee		dw hardware_word 
4bfe			;20 
4bfe 62 ee		dw input_at_cursor 
4c00 64 ee		dw input_at_pos 
4c02 60 ee		dw input_cur_flash 
4c04 5f ee		dw input_cur_onoff 
4c06 55 ee		dw input_cursor 
4c08 65 ee		dw input_display_size 
4c0a 5a ee		dw input_len 
4c0c 69 ee		dw input_ptr 
4c0e 66 ee		dw input_size 
4c10 67 ee		dw input_start 
4c12			; 30 
4c12 13 0e		dw input_str 
4c14 63 ee		dw input_under_cursor 
4c16 e8 e5		dw os_cli_cmd 
4c18 e4 e5		dw os_cur_ptr 
4c1a e6 e5		dw os_current_i 
4c1c bf e4		dw os_input 
4c1e e7 e6		dw os_last_cmd 
4c20 be e5		dw os_last_new_uword 
4c22 6f ee		dw debug_vector 
4c24 a3 e2		dw os_view_hl 
4c26			;40 
4c26 c6 e5		dw os_word_scratch 
4c28 c3 00		dw portbctl 
4c2a c1 00		dw portbdata 
4c2c 63 ea		dw spi_cartdev 
4c2e 62 ea		dw spi_cartdev2 
4c30 64 ea		dw spi_clktime 
4c32 60 ea		dw spi_device 
4c34 5f ea		dw spi_device_id 
4c36 61 ea		dw spi_portbyte 
4c38 a7 eb		dw stackstore 
4c3a			; 50 
4c3a			if STORAGE_SE 
4c3a			dw storage_actl 
4c3a			dw storage_adata 
4c3a			else 
4c3a 00 00		dw 0 
4c3c 00 00		dw 0 
4c3e			endif 
4c3e 68 09		dw storage_append 
4c40			if STORAGE_SE 
4c40			dw storage_bctl 
4c40			else 
4c40 00 00		dw 0 
4c42			endif 
4c42 93 eb		dw store_bank_active 
4c44 67 ea		dw store_filecache 
4c46 75 ea		dw store_longread 
4c48 6b ea		dw store_openaddr 
4c4a 6a ea		dw store_openext 
4c4c 69 ea		dw store_openmaxext 
4c4e			; 60 
4c4e 7a ea		dw store_page 
4c50 76 ea		dw store_readbuf 
4c52 6d ea		dw store_readcont 
4c54 78 ea		dw store_readptr 
4c56 6d ea		dw store_tmpext 
4c58 6e ea		dw store_tmpid 
4c5a 65 ea		dw store_tmppageid 
4c5c 18 14		dw malloc 
4c5e e2 14		dw free 
4c60 8d 67		dw cin 
4c62			; 70 
4c62 85 67		dw cin_wait 
4c64 b1 1d		dw forth_push_numhl 
4c66 1f 1e		dw forth_push_str 
4c68			 
4c68			 
4c68			.ENDCONST: 
4c68			 
4c68			; eof 
4c68			 
4c68			 
# End of file forth_words_const.asm
4c68			 
4c68			if STORAGE_SE 
4c68			   	include "forth_words_storage.asm" 
4c68			endif 
4c68				include "forth_words_device.asm" 
4c68			; Device related words 
4c68			 
4c68			; | ## Device Words 
4c68			 
4c68			;if SOUND_ENABLE 
4c68			;.NOTE: 
4c68			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4c68			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
4c68			;		if DEBUG_FORTH_WORDS_KEY 
4c68			;			DMARK "NTE" 
4c68			;			CALLMONITOR 
4c68			;		endif 
4c68			; 
4c68			;	 
4c68			; 
4c68			;		NEXTW 
4c68			;.AFTERSOUND: 
4c68			;endif 
4c68			 
4c68			 
4c68			USE_GPIO: equ 0 
4c68			 
4c68			if USE_GPIO 
4c68			.GP1: 
4c68				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4c68			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
4c68					NEXTW 
4c68			.GP2: 
4c68				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4c68			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
4c68			 
4c68					NEXTW 
4c68			 
4c68			.GP3: 
4c68				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4c68			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
4c68			 
4c68					NEXTW 
4c68			 
4c68			.GP4: 
4c68				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4c68			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
4c68			 
4c68					NEXTW 
4c68			.SIN: 
4c68			 
4c68			 
4c68			endif 
4c68			 
4c68			 
4c68				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4c68 33				db WORD_SYS_CORE+31             
4c69 9d 4c			dw .SOUT            
4c6b 03				db 2 + 1 
4c6c .. 00			db "IN",0              
4c6f				endm 
# End of macro CWHEAD
4c6f			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4c6f					if DEBUG_FORTH_WORDS_KEY 
4c6f						DMARK "IN." 
4c6f f5				push af  
4c70 3a 84 4c			ld a, (.dmark)  
4c73 32 6b ee			ld (debug_mark),a  
4c76 3a 85 4c			ld a, (.dmark+1)  
4c79 32 6c ee			ld (debug_mark+1),a  
4c7c 3a 86 4c			ld a, (.dmark+2)  
4c7f 32 6d ee			ld (debug_mark+2),a  
4c82 18 03			jr .pastdmark  
4c84 ..			.dmark: db "IN."  
4c87 f1			.pastdmark: pop af  
4c88			endm  
# End of macro DMARK
4c88						CALLMONITOR 
4c88 cd 6f ee			call debug_vector  
4c8b				endm  
# End of macro CALLMONITOR
4c8b					endif 
4c8b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c8b cd a8 1f			call macro_dsp_valuehl 
4c8e				endm 
# End of macro FORTH_DSP_VALUEHL
4c8e			 
4c8e e5					push hl 
4c8f			 
4c8f					; destroy value TOS 
4c8f			 
4c8f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c8f cd 60 20			call macro_forth_dsp_pop 
4c92				endm 
# End of macro FORTH_DSP_POP
4c92			 
4c92					; one value on hl get other one back 
4c92			 
4c92 c1					pop bc 
4c93			 
4c93					; do the sub 
4c93			;		ex de, hl 
4c93			 
4c93 ed 68				in l,(c) 
4c95			 
4c95					; save it 
4c95			 
4c95 26 00				ld h,0 
4c97			 
4c97					; TODO push value back onto stack for another op etc 
4c97			 
4c97 cd b1 1d				call forth_push_numhl 
4c9a					NEXTW 
4c9a c3 5e 21			jp macro_next 
4c9d				endm 
# End of macro NEXTW
4c9d			.SOUT: 
4c9d				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4c9d 34				db WORD_SYS_CORE+32             
4c9e f0 4c			dw .SPIO            
4ca0 04				db 3 + 1 
4ca1 .. 00			db "OUT",0              
4ca5				endm 
# End of macro CWHEAD
4ca5			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4ca5					if DEBUG_FORTH_WORDS_KEY 
4ca5						DMARK "OUT" 
4ca5 f5				push af  
4ca6 3a ba 4c			ld a, (.dmark)  
4ca9 32 6b ee			ld (debug_mark),a  
4cac 3a bb 4c			ld a, (.dmark+1)  
4caf 32 6c ee			ld (debug_mark+1),a  
4cb2 3a bc 4c			ld a, (.dmark+2)  
4cb5 32 6d ee			ld (debug_mark+2),a  
4cb8 18 03			jr .pastdmark  
4cba ..			.dmark: db "OUT"  
4cbd f1			.pastdmark: pop af  
4cbe			endm  
# End of macro DMARK
4cbe						CALLMONITOR 
4cbe cd 6f ee			call debug_vector  
4cc1				endm  
# End of macro CALLMONITOR
4cc1					endif 
4cc1			 
4cc1					; get port 
4cc1			 
4cc1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4cc1 cd a8 1f			call macro_dsp_valuehl 
4cc4				endm 
# End of macro FORTH_DSP_VALUEHL
4cc4			 
4cc4 e5					push hl 
4cc5			 
4cc5					; destroy value TOS 
4cc5			 
4cc5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4cc5 cd 60 20			call macro_forth_dsp_pop 
4cc8				endm 
# End of macro FORTH_DSP_POP
4cc8			 
4cc8					; get byte to send 
4cc8			 
4cc8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4cc8 cd a8 1f			call macro_dsp_valuehl 
4ccb				endm 
# End of macro FORTH_DSP_VALUEHL
4ccb			 
4ccb			;		push hl 
4ccb			 
4ccb					; destroy value TOS 
4ccb			 
4ccb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ccb cd 60 20			call macro_forth_dsp_pop 
4cce				endm 
# End of macro FORTH_DSP_POP
4cce			 
4cce					; one value on hl get other one back 
4cce			 
4cce			;		pop hl 
4cce			 
4cce c1					pop bc 
4ccf			 
4ccf					if DEBUG_FORTH_WORDS 
4ccf						DMARK "OUT" 
4ccf f5				push af  
4cd0 3a e4 4c			ld a, (.dmark)  
4cd3 32 6b ee			ld (debug_mark),a  
4cd6 3a e5 4c			ld a, (.dmark+1)  
4cd9 32 6c ee			ld (debug_mark+1),a  
4cdc 3a e6 4c			ld a, (.dmark+2)  
4cdf 32 6d ee			ld (debug_mark+2),a  
4ce2 18 03			jr .pastdmark  
4ce4 ..			.dmark: db "OUT"  
4ce7 f1			.pastdmark: pop af  
4ce8			endm  
# End of macro DMARK
4ce8						CALLMONITOR 
4ce8 cd 6f ee			call debug_vector  
4ceb				endm  
# End of macro CALLMONITOR
4ceb					endif 
4ceb			 
4ceb ed 69				out (c), l 
4ced			 
4ced					NEXTW 
4ced c3 5e 21			jp macro_next 
4cf0				endm 
# End of macro NEXTW
4cf0			 
4cf0			 
4cf0			.SPIO: 
4cf0			 
4cf0			if STORAGE_SE 
4cf0				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4cf0			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4cf0			 
4cf0					call spi_ce_low 
4cf0			    NEXTW 
4cf0			 
4cf0			.SPICEH: 
4cf0				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4cf0			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4cf0			 
4cf0					call spi_ce_high 
4cf0			    NEXTW 
4cf0			 
4cf0			 
4cf0			.SPIOb: 
4cf0			 
4cf0				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4cf0			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4cf0			 
4cf0					if DEBUG_FORTH_WORDS_KEY 
4cf0						DMARK "SPo" 
4cf0						CALLMONITOR 
4cf0					endif 
4cf0					; get port 
4cf0			 
4cf0			 
4cf0					; get byte to send 
4cf0			 
4cf0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4cf0			 
4cf0			;		push hl    ; u1  
4cf0			 
4cf0					; destroy value TOS 
4cf0			 
4cf0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4cf0			 
4cf0					; one value on hl get other one back 
4cf0			 
4cf0			;		pop hl   ; u2 - addr 
4cf0			 
4cf0					; TODO Send SPI byte 
4cf0			 
4cf0			;		push hl 
4cf0			;		call spi_ce_low 
4cf0			;		pop hl 
4cf0					ld a, l 
4cf0					call spi_send_byte 
4cf0			;		call spi_ce_high 
4cf0			 
4cf0					NEXTW 
4cf0			 
4cf0			.SPII: 
4cf0				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4cf0			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4cf0					if DEBUG_FORTH_WORDS_KEY 
4cf0						DMARK "SPi" 
4cf0						CALLMONITOR 
4cf0					endif 
4cf0			 
4cf0					; TODO Get SPI byte 
4cf0			 
4cf0					call spi_read_byte 
4cf0			 
4cf0					if DEBUG_FORTH_WORDS 
4cf0						DMARK "Si2" 
4cf0						CALLMONITOR 
4cf0					endif 
4cf0					ld h, 0 
4cf0					ld l, a 
4cf0					if DEBUG_FORTH_WORDS 
4cf0						DMARK "Si3" 
4cf0						CALLMONITOR 
4cf0					endif 
4cf0					call forth_push_numhl 
4cf0			 
4cf0					NEXTW 
4cf0			 
4cf0			 
4cf0			 
4cf0			.SESEL: 
4cf0				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4cf0			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4cf0					if DEBUG_FORTH_WORDS_KEY 
4cf0						DMARK "BNK" 
4cf0						CALLMONITOR 
4cf0					endif 
4cf0			 
4cf0					ld a, 255 
4cf0					ld (spi_cartdev), a 
4cf0			 
4cf0					; get bank 
4cf0			 
4cf0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4cf0			 
4cf0			;		push hl 
4cf0			 
4cf0					; destroy value TOS 
4cf0			 
4cf0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4cf0			 
4cf0					; one value on hl get other one back 
4cf0			 
4cf0			;		pop hl 
4cf0			 
4cf0			 
4cf0					ld c, SPI_CE_HIGH 
4cf0					ld b, '0'    ; human readable bank number 
4cf0			 
4cf0					ld a, l 
4cf0			 
4cf0					if DEBUG_FORTH_WORDS 
4cf0						DMARK "BNK" 
4cf0						CALLMONITOR 
4cf0					endif 
4cf0			 
4cf0					; active low 
4cf0			 
4cf0					cp 0 
4cf0					jr z, .bset 
4cf0					cp 1 
4cf0					jr nz, .b2 
4cf0					res 0, c 
4cf0					ld b, '1'    ; human readable bank number 
4cf0			.b2:		cp 2 
4cf0					jr nz, .b3 
4cf0					res 1, c 
4cf0					ld b, '2'    ; human readable bank number 
4cf0			.b3:		cp 3 
4cf0					jr nz, .b4 
4cf0					res 2, c 
4cf0					ld b, '3'    ; human readable bank number 
4cf0			.b4:		cp 4 
4cf0					jr nz, .b5 
4cf0					res 3, c 
4cf0					ld b, '4'    ; human readable bank number 
4cf0			.b5:		cp 5 
4cf0					jr nz, .bset 
4cf0					res 4, c 
4cf0					ld b, '5'    ; human readable bank number 
4cf0			 
4cf0			.bset: 
4cf0					ld a, c 
4cf0					ld (spi_device),a 
4cf0					ld a, b 
4cf0					ld (spi_device_id),a 
4cf0					if DEBUG_FORTH_WORDS 
4cf0						DMARK "BN2" 
4cf0						CALLMONITOR 
4cf0					endif 
4cf0			 
4cf0					; set default SPI clk pulse time as disabled for BANK use 
4cf0			 
4cf0					ld a, 0 
4cf0					ld (spi_clktime), a 
4cf0			 
4cf0					NEXTW 
4cf0			 
4cf0			.CARTDEV: 
4cf0				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4cf0			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4cf0					if DEBUG_FORTH_WORDS_KEY 
4cf0						DMARK "CDV" 
4cf0						CALLMONITOR 
4cf0					endif 
4cf0			 
4cf0					; disable se storage bank selection 
4cf0			 
4cf0					ld a, SPI_CE_HIGH		; ce high 
4cf0					ld (spi_device), a 
4cf0			 
4cf0					; get bank 
4cf0			 
4cf0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4cf0			 
4cf0			;		push hl 
4cf0			 
4cf0					; destroy value TOS 
4cf0			 
4cf0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4cf0			 
4cf0					; one value on hl get other one back 
4cf0			 
4cf0			;		pop hl 
4cf0			 
4cf0					; active low 
4cf0			 
4cf0					ld c, 255 
4cf0			 
4cf0					ld a, l 
4cf0					if DEBUG_FORTH_WORDS 
4cf0						DMARK "CDV" 
4cf0						CALLMONITOR 
4cf0					endif 
4cf0					cp 0 
4cf0					jr z, .cset 
4cf0					cp 1 
4cf0					jr nz, .c2 
4cf0					res 0, c 
4cf0			.c2:		cp 2 
4cf0					jr nz, .c3 
4cf0					res 1, c 
4cf0			.c3:		cp 3 
4cf0					jr nz, .c4 
4cf0					res 2, c 
4cf0			.c4:		cp 4 
4cf0					jr nz, .c5 
4cf0					res 3, c 
4cf0			.c5:		cp 5 
4cf0					jr nz, .c6 
4cf0					res 4, c 
4cf0			.c6:		cp 6 
4cf0					jr nz, .c7 
4cf0					res 5, c 
4cf0			.c7:		cp 7 
4cf0					jr nz, .c8 
4cf0					res 6, c 
4cf0			.c8:		cp 8 
4cf0					jr nz, .cset 
4cf0					res 7, c 
4cf0			.cset:		ld a, c 
4cf0					ld (spi_cartdev),a 
4cf0			 
4cf0					if DEBUG_FORTH_WORDS 
4cf0						DMARK "CD2" 
4cf0						CALLMONITOR 
4cf0					endif 
4cf0			 
4cf0					; set default SPI clk pulse time as 10ms for CARTDEV use 
4cf0			 
4cf0					ld a, $0a 
4cf0					ld (spi_clktime), a 
4cf0					NEXTW 
4cf0			endif 
4cf0			 
4cf0			.ENDDEVICE: 
4cf0			; eof 
4cf0			 
# End of file forth_words_device.asm
4cf0			 
4cf0			; var handler 
4cf0			 
4cf0			 
4cf0			.VARS: 
4cf0				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4cf0 77				db WORD_SYS_CORE+99             
4cf1 a1 4d			dw .V0            
4cf3 04				db 3 + 1 
4cf4 .. 00			db "VAR",0              
4cf8				endm 
# End of macro CWHEAD
4cf8			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4cf8			;| 
4cf8			;| The variable name should consist of a single letter. e.g. "a" 
4cf8			;! If a full string is passed then only the first char is looked at 
4cf8			;| Any other char could exceed bounds checks!  
4cf8			 
4cf8					if DEBUG_FORTH_WORDS_KEY 
4cf8						DMARK "VAR" 
4cf8 f5				push af  
4cf9 3a 0d 4d			ld a, (.dmark)  
4cfc 32 6b ee			ld (debug_mark),a  
4cff 3a 0e 4d			ld a, (.dmark+1)  
4d02 32 6c ee			ld (debug_mark+1),a  
4d05 3a 0f 4d			ld a, (.dmark+2)  
4d08 32 6d ee			ld (debug_mark+2),a  
4d0b 18 03			jr .pastdmark  
4d0d ..			.dmark: db "VAR"  
4d10 f1			.pastdmark: pop af  
4d11			endm  
# End of macro DMARK
4d11						CALLMONITOR 
4d11 cd 6f ee			call debug_vector  
4d14				endm  
# End of macro CALLMONITOR
4d14					endif 
4d14			 
4d14					FORTH_DSP_VALUEHL 
4d14 cd a8 1f			call macro_dsp_valuehl 
4d17				endm 
# End of macro FORTH_DSP_VALUEHL
4d17			 
4d17 7e					ld a, (hl)    ; get first char on of the string 
4d18			 
4d18			 
4d18					if DEBUG_FORTH_WORDS 
4d18						DMARK "VR1" 
4d18 f5				push af  
4d19 3a 2d 4d			ld a, (.dmark)  
4d1c 32 6b ee			ld (debug_mark),a  
4d1f 3a 2e 4d			ld a, (.dmark+1)  
4d22 32 6c ee			ld (debug_mark+1),a  
4d25 3a 2f 4d			ld a, (.dmark+2)  
4d28 32 6d ee			ld (debug_mark+2),a  
4d2b 18 03			jr .pastdmark  
4d2d ..			.dmark: db "VR1"  
4d30 f1			.pastdmark: pop af  
4d31			endm  
# End of macro DMARK
4d31						CALLMONITOR 
4d31 cd 6f ee			call debug_vector  
4d34				endm  
# End of macro CALLMONITOR
4d34					endif 
4d34					 
4d34 f5					push af	 
4d35					FORTH_DSP_POP 
4d35 cd 60 20			call macro_forth_dsp_pop 
4d38				endm 
# End of macro FORTH_DSP_POP
4d38 f1					pop af 
4d39			 
4d39					; convert to upper 
4d39			 
4d39 cd b2 12				call to_upper 
4d3c					if DEBUG_FORTH_WORDS 
4d3c						DMARK "Vaa" 
4d3c f5				push af  
4d3d 3a 51 4d			ld a, (.dmark)  
4d40 32 6b ee			ld (debug_mark),a  
4d43 3a 52 4d			ld a, (.dmark+1)  
4d46 32 6c ee			ld (debug_mark+1),a  
4d49 3a 53 4d			ld a, (.dmark+2)  
4d4c 32 6d ee			ld (debug_mark+2),a  
4d4f 18 03			jr .pastdmark  
4d51 ..			.dmark: db "Vaa"  
4d54 f1			.pastdmark: pop af  
4d55			endm  
# End of macro DMARK
4d55						CALLMONITOR 
4d55 cd 6f ee			call debug_vector  
4d58				endm  
# End of macro CALLMONITOR
4d58					endif 
4d58 06 41				ld b, 'A' 
4d5a 90					sub b			; set offset 
4d5b					if DEBUG_FORTH_WORDS 
4d5b						DMARK "Vbb" 
4d5b f5				push af  
4d5c 3a 70 4d			ld a, (.dmark)  
4d5f 32 6b ee			ld (debug_mark),a  
4d62 3a 71 4d			ld a, (.dmark+1)  
4d65 32 6c ee			ld (debug_mark+1),a  
4d68 3a 72 4d			ld a, (.dmark+2)  
4d6b 32 6d ee			ld (debug_mark+2),a  
4d6e 18 03			jr .pastdmark  
4d70 ..			.dmark: db "Vbb"  
4d73 f1			.pastdmark: pop af  
4d74			endm  
# End of macro DMARK
4d74						CALLMONITOR 
4d74 cd 6f ee			call debug_vector  
4d77				endm  
# End of macro CALLMONITOR
4d77					endif 
4d77 cb 27				sla a  
4d79				 
4d79					 
4d79					if DEBUG_FORTH_WORDS 
4d79						DMARK "VR2" 
4d79 f5				push af  
4d7a 3a 8e 4d			ld a, (.dmark)  
4d7d 32 6b ee			ld (debug_mark),a  
4d80 3a 8f 4d			ld a, (.dmark+1)  
4d83 32 6c ee			ld (debug_mark+1),a  
4d86 3a 90 4d			ld a, (.dmark+2)  
4d89 32 6d ee			ld (debug_mark+2),a  
4d8c 18 03			jr .pastdmark  
4d8e ..			.dmark: db "VR2"  
4d91 f1			.pastdmark: pop af  
4d92			endm  
# End of macro DMARK
4d92						CALLMONITOR 
4d92 cd 6f ee			call debug_vector  
4d95				endm  
# End of macro CALLMONITOR
4d95					endif 
4d95			 
4d95 21 f4 e9				ld hl, cli_var_array2 
4d98 cd e6 0d				call addatohl 
4d9b cd b1 1d				call forth_push_numhl 
4d9e			 
4d9e			 
4d9e				       NEXTW 
4d9e c3 5e 21			jp macro_next 
4da1				endm 
# End of macro NEXTW
4da1			.V0: 
4da1				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4da1 78				db WORD_SYS_CORE+100             
4da2 b9 4d			dw .V0Q            
4da4 04				db 3 + 1 
4da5 .. 00			db "V0!",0              
4da9				endm 
# End of macro CWHEAD
4da9			;| V0! ( u1 -- )  Store value to v0  | DONE 
4da9			 
4da9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4da9 cd a8 1f			call macro_dsp_valuehl 
4dac				endm 
# End of macro FORTH_DSP_VALUEHL
4dac			 
4dac 11 28 ea				ld de, cli_var_array 
4daf			 
4daf eb					ex de, hl 
4db0 73					ld (hl), e 
4db1 23					inc hl 
4db2 72					ld (hl), d 
4db3			 
4db3					; destroy value TOS 
4db3			 
4db3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4db3 cd 60 20			call macro_forth_dsp_pop 
4db6				endm 
# End of macro FORTH_DSP_POP
4db6			 
4db6				       NEXTW 
4db6 c3 5e 21			jp macro_next 
4db9				endm 
# End of macro NEXTW
4db9			.V0Q: 
4db9				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4db9 79				db WORD_SYS_CORE+101             
4dba ca 4d			dw .V1S            
4dbc 04				db 3 + 1 
4dbd .. 00			db "V0@",0              
4dc1				endm 
# End of macro CWHEAD
4dc1			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4dc1 2a 28 ea				ld hl, (cli_var_array) 
4dc4 cd b1 1d				call forth_push_numhl 
4dc7			 
4dc7				       NEXTW 
4dc7 c3 5e 21			jp macro_next 
4dca				endm 
# End of macro NEXTW
4dca			.V1S: 
4dca				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4dca 7a				db WORD_SYS_CORE+102             
4dcb e2 4d			dw .V1Q            
4dcd 04				db 3 + 1 
4dce .. 00			db "V1!",0              
4dd2				endm 
# End of macro CWHEAD
4dd2			;| V1! ( u1 -- )  Store value to v1 | DONE 
4dd2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4dd2 cd a8 1f			call macro_dsp_valuehl 
4dd5				endm 
# End of macro FORTH_DSP_VALUEHL
4dd5			 
4dd5 11 2a ea				ld de, cli_var_array+2 
4dd8				 
4dd8 eb					ex de, hl 
4dd9 73					ld (hl), e 
4dda 23					inc hl 
4ddb 72					ld (hl), d 
4ddc			 
4ddc					; destroy value TOS 
4ddc			 
4ddc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ddc cd 60 20			call macro_forth_dsp_pop 
4ddf				endm 
# End of macro FORTH_DSP_POP
4ddf				       NEXTW 
4ddf c3 5e 21			jp macro_next 
4de2				endm 
# End of macro NEXTW
4de2			.V1Q: 
4de2				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4de2 7b				db WORD_SYS_CORE+103             
4de3 f3 4d			dw .V2S            
4de5 04				db 3 + 1 
4de6 .. 00			db "V1@",0              
4dea				endm 
# End of macro CWHEAD
4dea			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4dea 2a 2a ea				ld hl, (cli_var_array+2) 
4ded cd b1 1d				call forth_push_numhl 
4df0				       NEXTW 
4df0 c3 5e 21			jp macro_next 
4df3				endm 
# End of macro NEXTW
4df3			.V2S: 
4df3				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4df3 7c				db WORD_SYS_CORE+104             
4df4 0b 4e			dw .V2Q            
4df6 04				db 3 + 1 
4df7 .. 00			db "V2!",0              
4dfb				endm 
# End of macro CWHEAD
4dfb			;| V2! ( u1 -- )  Store value to v2 | DONE 
4dfb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4dfb cd a8 1f			call macro_dsp_valuehl 
4dfe				endm 
# End of macro FORTH_DSP_VALUEHL
4dfe			 
4dfe 11 2c ea				ld de, cli_var_array+4 
4e01				 
4e01 eb					ex de, hl 
4e02 73					ld (hl), e 
4e03 23					inc hl 
4e04 72					ld (hl), d 
4e05			 
4e05					; destroy value TOS 
4e05			 
4e05					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e05 cd 60 20			call macro_forth_dsp_pop 
4e08				endm 
# End of macro FORTH_DSP_POP
4e08				       NEXTW 
4e08 c3 5e 21			jp macro_next 
4e0b				endm 
# End of macro NEXTW
4e0b			.V2Q: 
4e0b				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4e0b 7d				db WORD_SYS_CORE+105             
4e0c 1c 4e			dw .V3S            
4e0e 04				db 3 + 1 
4e0f .. 00			db "V2@",0              
4e13				endm 
# End of macro CWHEAD
4e13			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4e13 2a 2c ea				ld hl, (cli_var_array+4) 
4e16 cd b1 1d				call forth_push_numhl 
4e19				       NEXTW 
4e19 c3 5e 21			jp macro_next 
4e1c				endm 
# End of macro NEXTW
4e1c			.V3S: 
4e1c				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4e1c 7c				db WORD_SYS_CORE+104             
4e1d 34 4e			dw .V3Q            
4e1f 04				db 3 + 1 
4e20 .. 00			db "V3!",0              
4e24				endm 
# End of macro CWHEAD
4e24			;| V3! ( u1 -- )  Store value to v3 | DONE 
4e24					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e24 cd a8 1f			call macro_dsp_valuehl 
4e27				endm 
# End of macro FORTH_DSP_VALUEHL
4e27			 
4e27 11 2e ea				ld de, cli_var_array+6 
4e2a				 
4e2a eb					ex de, hl 
4e2b 73					ld (hl), e 
4e2c 23					inc hl 
4e2d 72					ld (hl), d 
4e2e			 
4e2e					; destroy value TOS 
4e2e			 
4e2e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e2e cd 60 20			call macro_forth_dsp_pop 
4e31				endm 
# End of macro FORTH_DSP_POP
4e31				       NEXTW 
4e31 c3 5e 21			jp macro_next 
4e34				endm 
# End of macro NEXTW
4e34			.V3Q: 
4e34				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4e34 7d				db WORD_SYS_CORE+105             
4e35 45 4e			dw .END            
4e37 04				db 3 + 1 
4e38 .. 00			db "V3@",0              
4e3c				endm 
# End of macro CWHEAD
4e3c			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4e3c 2a 2e ea				ld hl, (cli_var_array+6) 
4e3f cd b1 1d				call forth_push_numhl 
4e42				       NEXTW 
4e42 c3 5e 21			jp macro_next 
4e45				endm 
# End of macro NEXTW
4e45			 
4e45			 
4e45			 
4e45			 
4e45			 
4e45			; end of dict marker 
4e45			 
4e45 00			.END:    db WORD_SYS_END 
4e46 00 00			dw 0 
4e48 00				db 0 
4e49			 
4e49			; use to jp here for user dict words to save on macro expansion  
4e49			 
4e49			user_dict_next: 
4e49				NEXTW 
4e49 c3 5e 21			jp macro_next 
4e4c				endm 
# End of macro NEXTW
4e4c			 
4e4c			 
4e4c			user_exec: 
4e4c				;    ld hl, <word code> 
4e4c				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4e4c				;    call forthexec 
4e4c				;    jp user_dict_next   (NEXT) 
4e4c			        ;    <word code bytes> 
4e4c eb				ex de, hl 
4e4d 2a c2 e5			ld hl,(os_tok_ptr) 
4e50				 
4e50				FORTH_RSP_NEXT 
4e50 cd 58 1d			call macro_forth_rsp_next 
4e53				endm 
# End of macro FORTH_RSP_NEXT
4e53			 
4e53			if DEBUG_FORTH_UWORD 
4e53						DMARK "UEX" 
4e53 f5				push af  
4e54 3a 68 4e			ld a, (.dmark)  
4e57 32 6b ee			ld (debug_mark),a  
4e5a 3a 69 4e			ld a, (.dmark+1)  
4e5d 32 6c ee			ld (debug_mark+1),a  
4e60 3a 6a 4e			ld a, (.dmark+2)  
4e63 32 6d ee			ld (debug_mark+2),a  
4e66 18 03			jr .pastdmark  
4e68 ..			.dmark: db "UEX"  
4e6b f1			.pastdmark: pop af  
4e6c			endm  
# End of macro DMARK
4e6c				CALLMONITOR 
4e6c cd 6f ee			call debug_vector  
4e6f				endm  
# End of macro CALLMONITOR
4e6f			endif 
4e6f			 
4e6f			 
4e6f			 
4e6f eb				ex de, hl 
4e70 22 c2 e5			ld (os_tok_ptr), hl 
4e73				 
4e73				; Don't use next - Skips the first word in uword. 
4e73			 
4e73 c3 ef 21			jp exec1 
4e76			;	NEXT 
4e76			 
4e76			 
4e76			; eof 
# End of file forth_wordsv4.asm
4e76			endif 
4e76			;;;;;;;;;;;;;; Debug code 
4e76			 
4e76			 
4e76			;if DEBUG_FORTH_PARSE 
4e76 .. 00		.nowordfound: db "No match",0 
4e7f .. 00		.compword:	db "Comparing word ",0 
4e8f .. 00		.nextwordat:	db "Next word at",0 
4e9c .. 00		.charmatch:	db "Char match",0 
4ea7			;endif 
4ea7			if DEBUG_FORTH_JP 
4ea7			.foundword:	db "Word match. Exec..",0 
4ea7			endif 
4ea7			;if DEBUG_FORTH_PUSH 
4ea7 .. 00		.enddict:	db "Dict end. Push.",0 
4eb7 .. 00		.push_str:	db "Pushing string",0 
4ec6 .. 00		.push_num:	db "Pushing number",0 
4ed5 .. 00		.data_sp:	db "SP:",0 
4ed9 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4eeb .. 00		.wordinde:	db "Word in DE (3/0):",0 
4efd .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4f0f			;endif 
4f0f			;if DEBUG_FORTH_MALLOC 
4f0f .. 00		.push_malloc:	db "Malloc address",0 
4f1e			;endif 
4f1e			 
4f1e			 
4f1e			 
4f1e			; display malloc address and current data stack pointer  
4f1e			 
4f1e			malloc_error: 
4f1e d5				push de 
4f1f f5				push af 
4f20 e5				push hl 
4f21 cd b9 0b			call clear_display 
4f24 11 44 4f			ld de, .mallocerr 
4f27 3e 00			ld a,0 
4f29			;	ld de,os_word_scratch 
4f29 cd cc 0b			call str_at_display 
4f2c 3e 11			ld a, display_row_1+17 
4f2e 11 6b ee			ld de, debug_mark 
4f31 cd cc 0b			call str_at_display 
4f34 cd dc 0b			call update_display 
4f37				;call break_point_state 
4f37 cd 85 67			call cin_wait 
4f3a			 
4f3a			;	ld a, ' ' 
4f3a			;	ld (os_view_disable), a 
4f3a cd 47 17			call bp_on 
4f3d e1				pop hl 
4f3e f1				pop af 
4f3f d1				pop de	 
4f40				CALLMONITOR 
4f40 cd 6f ee			call debug_vector  
4f43				endm  
# End of macro CALLMONITOR
4f43 c9				ret 
4f44			 
4f44 .. 00		.mallocerr: 	db "Malloc Error",0 
4f51			;if DEBUG_FORTH_PUSH 
4f51			display_data_sp: 
4f51 f5				push af 
4f52			 
4f52				; see if disabled 
4f52			 
4f52			 
4f52 3a 6f ee			ld a, (debug_vector) 
4f55 fe c9			cp $C9  ; RET 
4f57				;ld a, (os_view_disable) 
4f57				;cp '*' 
4f57 28 67			jr z, .skipdsp 
4f59			 
4f59 e5				push hl 
4f5a e5				push hl 
4f5b e5			push hl 
4f5c cd b9 0b			call clear_display 
4f5f e1			pop hl 
4f60 7c				ld a,h 
4f61 21 c6 e5			ld hl, os_word_scratch 
4f64 cd 46 12			call hexout 
4f67 e1				pop hl 
4f68 7d				ld a,l 
4f69 21 c8 e5			ld hl, os_word_scratch+2 
4f6c cd 46 12			call hexout 
4f6f 21 ca e5			ld hl, os_word_scratch+4 
4f72 3e 00			ld a,0 
4f74 77				ld (hl),a 
4f75 11 c6 e5			ld de,os_word_scratch 
4f78 3e 28				ld a, display_row_2 
4f7a cd cc 0b				call str_at_display 
4f7d 11 d9 4e			ld de, .wordinhl 
4f80 3e 00			ld a, display_row_1 
4f82			 
4f82 cd cc 0b				call str_at_display 
4f85 11 6b ee			ld de, debug_mark 
4f88 3e 11			ld a, display_row_1+17 
4f8a			 
4f8a cd cc 0b				call str_at_display 
4f8d			 
4f8d				; display current data stack pointer 
4f8d 11 d5 4e			ld de,.data_sp 
4f90 3e 30				ld a, display_row_2 + 8 
4f92 cd cc 0b				call str_at_display 
4f95			 
4f95 2a ee e9			ld hl,(cli_data_sp) 
4f98 e5				push hl 
4f99 7c				ld a,h 
4f9a 21 c6 e5			ld hl, os_word_scratch 
4f9d cd 46 12			call hexout 
4fa0 e1				pop hl 
4fa1 7d				ld a,l 
4fa2 21 c8 e5			ld hl, os_word_scratch+2 
4fa5 cd 46 12			call hexout 
4fa8 21 ca e5			ld hl, os_word_scratch+4 
4fab 3e 00			ld a,0 
4fad 77				ld (hl),a 
4fae 11 c6 e5			ld de,os_word_scratch 
4fb1 3e 33				ld a, display_row_2 + 11 
4fb3 cd cc 0b				call str_at_display 
4fb6			 
4fb6			 
4fb6 cd dc 0b			call update_display 
4fb9 cd f1 0a			call delay1s 
4fbc cd f1 0a			call delay1s 
4fbf e1				pop hl 
4fc0			.skipdsp: 
4fc0 f1				pop af 
4fc1 c9				ret 
4fc2			 
4fc2			display_data_malloc: 
4fc2			 
4fc2 f5				push af 
4fc3 e5				push hl 
4fc4 e5				push hl 
4fc5 e5			push hl 
4fc6 cd b9 0b			call clear_display 
4fc9 e1			pop hl 
4fca 7c				ld a,h 
4fcb 21 c6 e5			ld hl, os_word_scratch 
4fce cd 46 12			call hexout 
4fd1 e1				pop hl 
4fd2 7d				ld a,l 
4fd3 21 c8 e5			ld hl, os_word_scratch+2 
4fd6 cd 46 12			call hexout 
4fd9 21 ca e5			ld hl, os_word_scratch+4 
4fdc 3e 00			ld a,0 
4fde 77				ld (hl),a 
4fdf 11 c6 e5			ld de,os_word_scratch 
4fe2 3e 28				ld a, display_row_2 
4fe4 cd cc 0b				call str_at_display 
4fe7 11 0f 4f			ld de, .push_malloc 
4fea 3e 00			ld a, display_row_1 
4fec			 
4fec cd cc 0b				call str_at_display 
4fef			 
4fef				; display current data stack pointer 
4fef 11 d5 4e			ld de,.data_sp 
4ff2 3e 30				ld a, display_row_2 + 8 
4ff4 cd cc 0b				call str_at_display 
4ff7			 
4ff7 2a ee e9			ld hl,(cli_data_sp) 
4ffa e5				push hl 
4ffb 7c				ld a,h 
4ffc 21 c6 e5			ld hl, os_word_scratch 
4fff cd 46 12			call hexout 
5002 e1				pop hl 
5003 7d				ld a,l 
5004 21 c8 e5			ld hl, os_word_scratch+2 
5007 cd 46 12			call hexout 
500a 21 ca e5			ld hl, os_word_scratch+4 
500d 3e 00			ld a,0 
500f 77				ld (hl),a 
5010 11 c6 e5			ld de,os_word_scratch 
5013 3e 33				ld a, display_row_2 + 11 
5015 cd cc 0b				call str_at_display 
5018			 
5018 cd dc 0b			call update_display 
501b cd f1 0a			call delay1s 
501e cd f1 0a			call delay1s 
5021 e1				pop hl 
5022 f1				pop af 
5023 c9				ret 
5024			;endif 
5024			 
5024			include "forth_autostart.asm" 
5024			; list of commands to perform at system start up 
5024			 
5024			startcmds: 
5024			;	dw test11 
5024			;	dw test12 
5024			;	dw test13 
5024			;	dw test14 
5024			;	dw test15 
5024			;	dw test16 
5024			;	dw test17 
5024			;	dw ifthtest1 
5024			;	dw ifthtest2 
5024			;	dw ifthtest3 
5024			;	dw mmtest1 
5024			;	dw mmtest2 
5024			;	dw mmtest3 
5024			;	dw mmtest4 
5024			;	dw mmtest5 
5024			;	dw mmtest6 
5024			;	dw iftest1 
5024			;	dw iftest2 
5024			;	dw iftest3 
5024			;	dw looptest1 
5024			;	dw looptest2 
5024			;	dw test1 
5024			;	dw test2 
5024			;	dw test3 
5024			;	dw test4 
5024			;	dw game2r 
5024			;	dw game2b1 
5024			;	dw game2b2 
5024			 
5024				; start up words that are actually useful 
5024			 
5024			;    dw spi1 
5024			;    dw spi2 
5024			;    dw spi3 
5024			;    dw spi4 
5024			;    dw spi5 
5024			;    dw spi6 
5024			;    dw spi7 
5024			; 
5024			;    dw spi8 
5024			;    dw spi9 
5024			;    dw spi10 
5024			 
5024			; file editor 
5024			;	dw edit1 
5024			;	dw edit2 
5024			;	dw edit3 
5024			 
5024			;	dw longread 
5024 4e 54			dw clrstack 
5026 82 54			dw type 
5028			;	dw stest 
5028 a7 54			dw strncpy 
502a			;	dw list 
502a 08 55			dw start1 
502c 18 55			dw start2 
502e			;	dw start3 
502e			;	dw start3b 
502e			;	dw start3c 
502e			 
502e				; (unit) testing words 
502e			 
502e			;	dw mtesta 
502e			;	dw mtestb 
502e			;	dw mtestc 
502e			;	dw mtestd 
502e			;	dw mteste 
502e			 
502e				; demo/game words 
502e			 
502e			;        dw game3w 
502e			;        dw game3p 
502e			;        dw game3sc 
502e			;        dw game3vsi 
502e			;        dw game3vs 
502e				 
502e 71 5f			dw game2b 
5030 df 5f			dw game2bf 
5032 29 60			dw game2mba 
5034 bf 60			dw game2mbas 
5036 01 61			dw game2mb 
5038			 
5038 32 5c			dw game1 
503a 43 5c			dw game1a 
503c a5 5c			dw game1b 
503e da 5c			dw game1c 
5040 10 5d			dw game1d 
5042 41 5d			dw game1s 
5044 55 5d			dw game1t 
5046 6a 5d			dw game1f 
5048 9e 5d			dw game1z 
504a e2 5d			dw game1zz 
504c			 
504c 4c 5a			dw test5 
504e 84 5a			dw test6 
5050 bc 5a			dw test7 
5052 d0 5a			dw test8 
5054 fc 5a			dw test9 
5056 12 5b			dw test10 
5058				 
5058 b9 5e		        dw ssv5 
505a 9d 5e		        dw ssv4 
505c 81 5e		        dw ssv3 
505e 4b 5e		        dw ssv2 
5060 d2 5e		        dw ssv1 
5062 1a 5f		        dw ssv1cpm 
5064			;	dw keyup 
5064			;	dw keydown 
5064			;	dw keyleft 
5064			;	dw keyright 
5064			;	dw 	keyf1 
5064			;	dw keyf2 
5064			;	dw keyf3 
5064			;	dw keyf4 
5064			;	dw keyf5 
5064			;	dw keyf6 
5064			;	dw keyf7 
5064			;	dw keyf8 
5064			;	dw keyf9 
5064			;	dw keyf10 
5064			;	dw keyf11 
5064			;	dw keyf12 
5064			;	dw keytab 
5064			;	dw keycr 
5064			;	dw keyhome 
5064			;	dw keyend 
5064			;	dw keybs 
5064 00 00			db 0, 0	 
5066			 
5066			 
5066			; File Editor 
5066			 
5066			; ( id - ) use 'e' to edit the displayed line 
5066 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5087 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
50bc			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
50bc .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
50f4			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
50f4			 
50f4			; SPI Net support words 
50f4			 
50f4			; v0! = node to send to 
50f4			; ( str count - ) 
50f4 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
514d			 
514d			; spiputc ( char node - ) 
514d .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
5181			; spiputc ( u node - ) 
5181 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
51af			 
51af			; spigetc ( - n ) 
51af .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
51d8			 
51d8			; getnode ( - n ) 
51d8 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
5205			 
5205			; ( str node - )  
5205 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
526b			; store string ( str i - ) 
526b			 
526b			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
526b .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
52c0			 
52c0			; get string ( addr i -  )    TO FIX 
52c0			 
52c0 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
5318			 
5318			 
5318			; NETCHAT (TODO) 
5318			; Program to allow two nodes to chat with eachother 
5318			; 
5318			; v0 - target node 
5318			;  
5318			; accept input at 0,0 
5318			; if input is string send spitype to target node 
5318			; starting at row 2,0 , while spigetchr is not zero ->  
5318			; 
5318			; 
5318			; TODO add paging of get request 
5318			 
5318			; ( node - ) 
5318 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
5337 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
538f .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
5407			 
5407			 
5407			; Long read of currently open file 
5407 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
544e			 
544e			; clear stack  
544e			 
544e .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
5482			 
5482			; type ( addr count - ) 
5482 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
54a7			 
54a7			; some direct memory words 
54a7			; strncpy ( len t f -- t ) 
54a7			 
54a7 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5508			 
5508 .. 00		start1:     	db ": bpon $00 bp ;",0 
5518 .. 00		start2:     	db ": bpoff $01 bp ;",0 
5529 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
55a4 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5604			 
5604			 
5604			; a handy word to list items on the stack 
5604			 
5604 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
566e			 
566e			 
566e			; test stack  
566e			; rnd8 stest 
566e			 
566e .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
56e5			 
56e5			; random malloc and free cycles 
56e5			 
56e5 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
579a			 
579a			; fixed malloc and free cycles 
579a			 
579a .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
583d			 
583d			; fixed double string push and drop cycle  
583d			 
583d .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
58f2			 
58f2			; consistent fixed string push and drop cycle  
58f2			 
58f2 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5996			 
5996 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5a4c			 
5a4c			;test1:		db ": aa 1 2 3 ;", 0 
5a4c			;test2:     	db "111 aa 888 999",0 
5a4c			;test3:     	db ": bb 77 ;",0 
5a4c			;test4:     	db "$02 $01 do i . loop bb",0 
5a4c			 
5a4c .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5a84 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5abc .. 00		test7:     	db ": box hline vline ;",0 
5ad0 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5afc .. 00		test9:     	db ": sw $01 adsp world ;",0 
5b12 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5b37 .. 00		test11:     	db "hello create .",0 
5b46 .. 00		test12:     	db "hello2 create .",0 
5b56			 
5b56			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5b56			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5b56			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5b56			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5b56			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5b56			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5b56			 
5b56			;iftest1:     	db "$0001 IF cls .",0 
5b56			;iftest2:     	db "$0000 IF cls .",0 
5b56			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5b56			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5b56			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5b56			 
5b56			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5b56			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5b56			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5b56			 
5b56			 
5b56 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
5b7a .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
5baa .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
5bcf .. 00		sound4: db ": cha $00 ; ",0 
5bdc .. 00		sound5: db ": chb $20 ; ",0 
5be9 .. 00		sound6: db ": chc $40 ; ",0 
5bf6 .. 00		sound7: db ": chd $60 ; ",0 
5c03 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
5c1b .. 00		sound9: db ": cvol $90 + + note ; ", 0 
5c32			 
5c32			 
5c32			 
5c32			 
5c32			; a small guess the number game 
5c32			 
5c32 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5c43 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5ca5			 
5ca5 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5cda .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5d10 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5d41 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5d55 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5d6a .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5d9e .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5de2			 
5de2			; Using 'ga' save a high score across multiple runs using external storage 
5de2			 
5de2 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5e4b			 
5e4b			 
5e4b			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5e4b			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5e4b			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5e4b			 
5e4b			; simple screen saver to test code memory reuse to destruction 
5e4b			 
5e4b .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5e81 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5e9d .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5eb9 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5ed2 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5f1a .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5f71			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5f71			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5f71			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5f71			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5f71			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5f71			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5f71			 
5f71			 
5f71			 
5f71			; minesweeper/battleship finding game 
5f71			; draws a game board of random ship/mine positions 
5f71			; user enters coords to see if it hits on 
5f71			; game ends when all are hit 
5f71			; when hit or miss says how many may be in the area 
5f71			 
5f71			; setup the game board and then hide it 
5f71 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5fdf .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6029			; prompt for where to target 
6029 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
60bf .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
60e4			; TODO see if the entered coords hits or misses pushes char hit of miss 
60e4 .. 00		game2mbht:      db ": mbckht nop ;",0 
60f3 .. 00		game2mbms:      db ": mbcms nop ;",0 
6101			; TODO how many might be near by 
6101 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
617e			 
617e			; Game 3 
617e			 
617e			; Vert scroller ski game - avoid the trees! 
617e			 
617e			; v0 score (ie turns) 
617e			; v1 player pos 
617e			; v2 left wall 
617e			; v3 right wall 
617e			 
617e			; Draw side walls randomly 
617e			 
617e .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
61ac			 
61ac			; Draw player 
61ac .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
61ca			 
61ca			; TODO Get Key 
61ca			 
61ca			; TODO Move left right 
61ca			 
61ca			; scroll and move walls a bit 
61ca			 
61ca .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
61fb			 
61fb			; main game loop 
61fb			 
61fb .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6227 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6266			 
6266			; key board defs 
6266			 
6266 .. 00		keyup:       db ": keyup $05 ;",0 
6274 .. 00		keydown:       db ": keydown $0a ;",0 
6284 .. 00		keyleft:       db ": keyleft $0b ;",0 
6294 .. 00		keyright:       db ": keyright $0c ;",0 
62a5 .. 00		keyf1:       db ": keyf1 $10 ;",0 
62b3 .. 00		keyf2:       db ": keyf2 $11 ;",0 
62c1 .. 00		keyf3:       db ": keyf3 $12 ;",0 
62cf .. 00		keyf4:       db ": keyf4 $13 ;",0 
62dd .. 00		keyf5:       db ": keyf5 $14 ;",0 
62eb .. 00		keyf6:       db ": keyf6 $15 ;",0 
62f9 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6307 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6315 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6323 .. 00		keyf10:       db ": keyf10 $19 ;",0 
6332 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6341 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6350			 
6350 .. 00		keytab:       db ": keytab $09 ;",0 
635f .. 00		keycr:       db ": keycr $0d ;",0 
636d .. 00		keyhome:       db ": keyhome $0e ;",0 
637d .. 00		keyend:       db ": keyend $0f ;",0 
638c .. 00		keybs:       db ": keybs $08 ;",0 
639a			 
639a			   
639a			 
639a			 
639a			 
639a			; eof 
# End of file forth_autostart.asm
639a			 
639a			 
639a			 
639a			; stack over and underflow checks 
639a			 
639a			; init the words to detect the under/overflow 
639a			 
639a			chk_stk_init: 
639a				; a vague random number to check so we dont get any "lucky" hits 
639a 3e 2d			ld a, 45 
639c 6f				ld l, a 
639d 00				nop 
639e 3e 17			ld a, 23 
63a0 67				ld h, a 
63a1			 
63a1 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
63a4			 
63a4			;	ld (chk_stund), hl	; stack points.... 
63a4 22 00 ef			ld (chk_stovr), hl 
63a7 22 ec e9			ld (chk_ret_und), hl 
63aa 22 aa e9			ld (chk_ret_ovr), hl 
63ad 22 28 e9			ld (chk_loop_ovr), hl 
63b0 22 26 e8			ld (chk_data_ovr), hl 
63b3 c9				ret 
63b4				 
63b4			check_stacks: 
63b4				; check all stack words 
63b4			 
63b4 e5				push hl 
63b5 d5				push de 
63b6			 
63b6			;	ld de,(chk_word) 
63b6			;	ld hl, (chk_stund)	; stack points.... 
63b6			;	if DEBUG_STK_FAULT 
63b6			;		DMARK "FAa" 
63b6			;		CALLMONITOR 
63b6			;	endif 
63b6			;	call cmp16 
63b6			;	jp z, .chk_faulta 
63b6			; 
63b6			;	ld de, sfaultsu 
63b6			;	jp .chk_fault 
63b6			 
63b6 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
63b9 ed 5b 9d e2		ld de,(chk_word) 
63bd				if DEBUG_STK_FAULT 
63bd					DMARK "FAb" 
63bd					CALLMONITOR 
63bd				endif 
63bd cd 04 0e			call cmp16 
63c0 28 06			jr z, .chk_fault1 
63c2 11 63 64			ld de, sfaultso 
63c5 c3 17 64			jp .chk_fault 
63c8			.chk_fault1:  
63c8 2a ec e9			ld hl, (chk_ret_und) 
63cb ed 5b 9d e2		ld de,(chk_word) 
63cf				if DEBUG_STK_FAULT 
63cf					DMARK "FAU" 
63cf					CALLMONITOR 
63cf				endif 
63cf cd 04 0e			call cmp16 
63d2 ca db 63			jp z, .chk_fault2 
63d5 11 73 64			ld de, sfaultru 
63d8 c3 17 64			jp .chk_fault 
63db			.chk_fault2:  
63db 2a aa e9			ld hl, (chk_ret_ovr) 
63de ed 5b 9d e2		ld de,(chk_word) 
63e2				if DEBUG_STK_FAULT 
63e2					DMARK "FA1" 
63e2					CALLMONITOR 
63e2				endif 
63e2 cd 04 0e			call cmp16 
63e5 ca ee 63			jp z, .chk_fault3 
63e8 11 81 64			ld de, sfaultro 
63eb c3 17 64			jp .chk_fault 
63ee			.chk_fault3:  
63ee 2a 28 e9			ld hl, (chk_loop_ovr) 
63f1 ed 5b 9d e2		ld de,(chk_word) 
63f5				if DEBUG_STK_FAULT 
63f5					DMARK "FA2" 
63f5					CALLMONITOR 
63f5				endif 
63f5 cd 04 0e			call cmp16 
63f8 ca 01 64			jp z, .chk_fault4 
63fb 11 9b 64			ld de, sfaultlo 
63fe c3 17 64			jp .chk_fault 
6401			.chk_fault4:  
6401 2a 26 e8			ld hl, (chk_data_ovr) 
6404 ed 5b 9d e2		ld de,(chk_word) 
6408				if DEBUG_STK_FAULT 
6408					DMARK "FA3" 
6408					CALLMONITOR 
6408				endif 
6408 cd 04 0e			call cmp16 
640b ca 14 64			jp z, .chk_fault5 
640e 11 b5 64			ld de, sfaultdo 
6411 c3 17 64			jp .chk_fault 
6414			 
6414			 
6414			.chk_fault5:  
6414 d1				pop de 
6415 e1				pop hl 
6416			 
6416 c9				ret 
6417			 
6417 cd b9 0b		.chk_fault: 	call clear_display 
641a 3e 28				ld a, display_row_2 
641c cd cc 0b				call str_at_display 
641f 11 45 64				   ld de, .stackfault 
6422 3e 00				ld a, display_row_1 
6424 cd cc 0b				call str_at_display 
6427 11 6b ee				    ld de, debug_mark 
642a 3e 11				ld a, display_row_1+17 
642c cd cc 0b				call str_at_display 
642f cd dc 0b				call update_display 
6432			 
6432				; prompt before entering montior for investigating issue 
6432			 
6432 3e 78			ld a, display_row_4 
6434 11 a3 1a			ld de, endprog 
6437			 
6437 cd dc 0b			call update_display		 
643a			 
643a cd 29 1d			call next_page_prompt 
643d			 
643d d1				pop de 
643e e1				pop hl 
643f cd f7 1a				call monitor 
6442 c3 00 1a				jp warmstart 
6445					;jp 0 
6445					;halt 
6445			 
6445			 
6445			 
6445 .. 00		.stackfault: 	db "Stack fault:",0 
6452			 
6452 .. 00		sfaultsu: 	db	"Stack under flow",0 
6463 .. 00		sfaultso: 	db	"Stack over flow",0 
6473 .. 00		sfaultru:	db "RTS underflow",0 
6481 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
649b .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
64b5 .. 00		sfaultdo:	db "DTS overflow", 0 
64c2			 
64c2			 
64c2			fault_dsp_under: 
64c2 11 d4 64			ld de, .dsp_under 
64c5 c3 84 65			jp .show_fault 
64c8			 
64c8			fault_rsp_under: 
64c8 11 e2 64			ld de, .rsp_under 
64cb c3 84 65			jp .show_fault 
64ce			fault_loop_under: 
64ce 11 f0 64			ld de, .loop_under 
64d1 c3 84 65			jp .show_fault 
64d4			 
64d4 .. 00		.dsp_under: db "DSP Underflow",0 
64e2 .. 00		.rsp_under: db "RSP Underflow",0 
64f0 .. 00		.loop_under: db "LOOP Underflow",0 
64ff			 
64ff			 
64ff d5			type_faultn: 	push de 
6500 e5					push hl 
6501 cd b9 0b				call clear_display 
6504 11 2b 65				   ld de, .typefaultn 
6507 3e 00				ld a, display_row_1 
6509 cd cc 0b				call str_at_display 
650c 11 6b ee				    ld de, debug_mark 
650f 3e 11				ld a, display_row_1+17 
6511 cd cc 0b				call str_at_display 
6514 cd dc 0b				call update_display 
6517			 
6517				; prompt before entering montior for investigating issue 
6517			 
6517 3e 78			ld a, display_row_4 
6519 11 a3 1a			ld de, endprog 
651c			 
651c cd dc 0b			call update_display		 
651f			 
651f cd 29 1d			call next_page_prompt 
6522			 
6522 e5					push hl 
6523 d5					push de 
6524 cd f7 1a				call monitor 
6527 c3 00 1a				jp warmstart 
652a 76					halt 
652b			 
652b			 
652b .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6542			 
6542 d5			type_faults: 	push de 
6543 e5					push hl 
6544 cd b9 0b				call clear_display 
6547 11 6d 65				   ld de, .typefaults 
654a 3e 00				ld a, display_row_1 
654c cd cc 0b				call str_at_display 
654f 11 6b ee				    ld de, debug_mark 
6552 3e 11				ld a, display_row_1+17 
6554 cd cc 0b				call str_at_display 
6557 cd dc 0b				call update_display 
655a			 
655a				; prompt before entering montior for investigating issue 
655a			 
655a 3e 78			ld a, display_row_4 
655c 11 a3 1a			ld de, endprog 
655f			 
655f cd dc 0b			call update_display		 
6562			 
6562 cd 29 1d			call next_page_prompt 
6565			 
6565 e1					pop hl 
6566 d1					pop de 
6567 cd f7 1a				call monitor 
656a c3 00 1a				jp warmstart 
656d			 
656d			 
656d .. 00		.typefaults: db "STR Type Expected TOS!",0 
6584			 
6584			.show_fault: 	 
6584 d5					push de 
6585 cd b9 0b				call clear_display 
6588 d1					pop de 
6589 3e 00				ld a, display_row_1 
658b cd cc 0b				call str_at_display 
658e 11 6b ee				    ld de, debug_mark 
6591 3e 11				ld a, display_row_1+17 
6593 cd cc 0b				call str_at_display 
6596 cd dc 0b				call update_display 
6599			 
6599				; prompt before entering montior for investigating issue 
6599			 
6599 3e 78			ld a, display_row_4 
659b 11 a3 1a			ld de, endprog 
659e			 
659e cd dc 0b			call update_display		 
65a1			 
65a1 cd 29 1d			call next_page_prompt 
65a4			 
65a4 e1					pop hl 
65a5 d1					pop de 
65a6 cd f7 1a				call monitor 
65a9			; do a dump to cli and not warmstart so we preserve all of the uwords.  
65a9			; TODO Make optional fault restart to cli or warm boot? 
65a9					;jp warmstart 
65a9 c3 4a 1a				jp cli 
65ac 76					halt 
65ad			 
65ad			; handle the auto run of code from files in storage 
65ad			 
65ad			 
65ad			include "forth_startup.asm" 
65ad			; Which startup method to use? 
65ad			; 
65ad			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
65ad			; followed by loading of a list of scripts in eeprom 
65ad			 
65ad			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
65ad			; from eeprom 
65ad			 
65ad			; Select with define in main stubs 
65ad			 
65ad			if STARTUP_V1 
65ad				include "forth_startupv1.asm" 
65ad			; Startup script loading version 1 
65ad			 
65ad			; If SE storage is available first stage is to use the selected file 
65ad			; then go through the eeprom list 
65ad			 
65ad .. 00		sprompt1: db "Startup load...",0 
65bd .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
65d3			 
65d3			 
65d3			 
65d3			 
65d3			forth_startup: 
65d3 21 24 50			ld hl, startcmds 
65d6 3e 00			ld a, 0 
65d8 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
65db			 
65db e5			.start1:	push hl 
65dc cd b9 0b			call clear_display 
65df 11 ad 65			ld de, sprompt1 
65e2 3e 00		        ld a, display_row_1 
65e4 cd cc 0b			call str_at_display 
65e7 11 bd 65			ld de, sprompt2 
65ea 3e 28		        ld a, display_row_2 
65ec cd cc 0b			call str_at_display 
65ef e1				pop hl 
65f0 e5				push hl 
65f1 5e				ld e,(hl) 
65f2 23				inc hl 
65f3 56				ld d,(hl) 
65f4 3e 50		        ld a, display_row_3 
65f6 cd cc 0b			call str_at_display 
65f9 cd dc 0b			call update_display 
65fc			 
65fc			 
65fc 3a e7 e6			ld a, (os_last_cmd) 
65ff fe 00			cp 0 
6601 28 05			jr z, .startprompt 
6603 cd e5 0a			call delay250ms 
6606 18 24			jr .startdo 
6608				 
6608				 
6608			 
6608			.startprompt: 
6608			 
6608 3e 9f			ld a,display_row_4 + display_cols - 1 
660a 11 27 1d		        ld de, endprg 
660d cd cc 0b			call str_at_display 
6610 cd dc 0b			call update_display 
6613 cd f1 0a			call delay1s 
6616 cd 85 67			call cin_wait 
6619						 
6619 fe 2a			cp '*' 
661b 28 5e			jr z, .startupend1 
661d fe 23			cp '#' 
661f 20 07			jr nz, .startno 
6621 3e 01			ld a, 1 
6623 32 e7 e6			ld (os_last_cmd),a 
6626 18 04			jr .startdo 
6628 fe 31		.startno:	cp '1' 
662a 28 3a			jr z,.startnxt  
662c			 
662c				; exec startup line 
662c			.startdo:	 
662c e1				pop hl 
662d e5				push hl 
662e				 
662e 5e				ld e,(hl) 
662f 23				inc hl 
6630 56				ld d,(hl) 
6631 eb				ex de,hl 
6632			 
6632 e5				push hl 
6633			 
6633 3e 00			ld a, 0 
6635				;ld a, FORTH_END_BUFFER 
6635 cd ae 13			call strlent 
6638 23				inc hl   ; include zero term to copy 
6639 06 00			ld b,0 
663b 4d				ld c,l 
663c e1				pop hl 
663d 11 c1 e2			ld de, scratch 
6640 ed b0			ldir 
6642			 
6642			 
6642 21 c1 e2			ld hl, scratch 
6645 cd ac 21			call forthparse 
6648 cd ec 21			call forthexec 
664b cd fe 20			call forthexec_cleanup 
664e			 
664e 3e 78			ld a, display_row_4 
6650 11 a3 1a			ld de, endprog 
6653			 
6653 cd dc 0b			call update_display		 
6656			 
6656 3a e7 e6			ld a, (os_last_cmd) 
6659 fe 00			cp 0 
665b 20 09			jr nz, .startnxt 
665d cd 29 1d			call next_page_prompt 
6660 cd b9 0b		        call clear_display 
6663 cd dc 0b			call update_display		 
6666			 
6666				; move onto next startup line? 
6666			.startnxt: 
6666			 
6666 cd e5 0a			call delay250ms 
6669 e1				pop hl 
666a			 
666a 23				inc hl 
666b 23				inc hl 
666c			 
666c e5				push hl 
666d 5e				ld e, (hl) 
666e 23				inc hl 
666f 56				ld d, (hl) 
6670 e1				pop hl 
6671				; TODO replace 0 test 
6671			 
6671 eb				ex de, hl 
6672 cd 0f 0e			call ishlzero 
6675			;	ld a,e 
6675			;	add d 
6675			;	cp 0    ; any left to do? 
6675 eb				ex de, hl 
6676 c2 db 65			jp nz, .start1 
6679 18 01			jr .startupend 
667b			 
667b e1			.startupend1: pop hl 
667c			.startupend: 
667c			 
667c cd b9 0b			call clear_display 
667f cd dc 0b			call update_display 
6682 c9				ret 
6683			if STORAGE_SE 
6683			 
6683			sprompt3: db "Loading from start-up file?:",0 
6683			sprompt4: db "(Y=Any key/N=No)",0 
6683			 
6683			 
6683			forth_autoload: 
6683			 
6683				; load block 0 of store 1 
6683				 
6683				ld a, $fe      ; bit 0 clear 
6683				ld (spi_device), a 
6683			 
6683				call storage_get_block_0 
6683			 
6683				ld a, (store_page+STORE_0_AUTOFILE) 
6683			 
6683				cp 0 
6683				ret z     ; auto start not enabled 
6683			 
6683				call clear_display 
6683			 
6683				; set bank 
6683			 
6683					ld a, (store_page+STORE_0_BANKRUN) 
6683					ld (spi_device), a 
6683			 
6683				; get file id to load from and get the file name to display 
6683			 
6683					ld a, (store_page+STORE_0_FILERUN) 
6683			 
6683					ld l, 0 
6683					ld h, a 
6683					ld de, store_page 
6683			 
6683					if DEBUG_FORTH_WORDS 
6683						DMARK "ASp" 
6683						CALLMONITOR 
6683					endif 
6683					call storage_read 
6683			 
6683					if DEBUG_FORTH_WORDS 
6683						DMARK "ASr" 
6683						CALLMONITOR 
6683					endif 
6683			 
6683					call ishlzero 
6683					ret z             ; file not found 
6683			 
6683					ld a, display_row_2 + 10 
6683					ld de, store_page+3 
6683					call str_at_display 
6683				 
6683			; 
6683			 
6683				ld a, display_row_1+5 
6683				ld de, sprompt3 
6683				call str_at_display 
6683				ld a, display_row_3+15 
6683				ld de, sprompt4 
6683				call str_at_display 
6683			 
6683				call update_display 
6683			 
6683				call cin_wait 
6683				cp 'n' 
6683				ret z 
6683				cp 'N' 
6683				ret z 
6683			 
6683				call delay1s 
6683			 
6683				ld a, (store_page+2) 
6683				ld (store_openmaxext), a    ; save count of ext 
6683				ld a, 1  
6683				ld (store_openext), a    ; save count of ext 
6683			 
6683			.autof:  
6683				ld l , a 
6683				 
6683				ld a, (store_page) 
6683				ld h, a	 
6683				ld de, store_page 
6683					if DEBUG_FORTH_WORDS 
6683						DMARK "ASl" 
6683						CALLMONITOR 
6683					endif 
6683					call storage_read 
6683				call ishlzero 
6683				ret z 
6683			;	jr z, .autoend 
6683			 
6683					if DEBUG_FORTH_WORDS 
6683						DMARK "ASc" 
6683						CALLMONITOR 
6683					endif 
6683				ld de, store_page+2 
6683				ld a, display_row_4 
6683				call str_at_display 
6683			 
6683				call update_display 
6683				call delay250ms 
6683			 
6683			 
6683			 
6683				ld hl, store_page+2 
6683				call forthparse 
6683				call forthexec 
6683				call forthexec_cleanup 
6683			 
6683				 
6683				ld a, (store_openext) 
6683				inc a 
6683				ld (store_openext), a    ; save count of ext 
6683			 
6683				jr .autof 
6683			;.autofdone: 
6683			; 
6683			;		if DEBUG_FORTH_WORDS 
6683			;			DMARK "ASx" 
6683			;			CALLMONITOR 
6683			;		endif 
6683			;;	call clear_display 
6683			;	ret 
6683			 
6683			 
6683			 
6683			endif 
# End of file forth_startupv1.asm
6683			endif 
6683			if STARTUP_V2 
6683				include "forth_startupv2.asm" 
6683			endif 
6683			 
# End of file forth_startup.asm
6683			 
6683			; eof 
# End of file forth_kernel.asm
6683			;include "nascombasic.asm" 
6683			 
6683			 
6683			; find out where the code ends if loaded into RAM (for SC114) 
6683			;endofcode:  
6683			;	nop 
6683			 
6683			 
6683			; jump to nmi vector 
6683			 
6683			init_nmi: 
6683 3e c9			ld a, $c9   ; RET 
6685 32 72 ee			ld (nmi_vector), a 
6688 c9				ret 
6689			nmi: 
6689 e5				push hl 
668a d5				push de 
668b c5				push bc 
668c f5				push af 
668d cd 72 ee			call nmi_vector 
6690 f5				push af 
6691 c5				push bc 
6692 d5				push de 
6693 e5				push hl 
6694 ed 4d			reti 
6696			 
6696			 
6696			; eof 
6696			 
# End of file main.asm
6696			;include "firmware_lcd_4x40.asm" 
6696			;;include "firmware_lcd_4x20.asm" 
6696			include "firmware_cpm_display.asm" 
6696			 
6696			; Serial display interface for SC114 
6696			 
6696			 
6696			display_row_1: equ 0 
6696			display_row_2: equ display_row_1+display_cols 
6696			display_row_3: equ display_row_2 + display_cols 
6696			display_row_4: equ display_row_3 + display_cols 
6696			 
6696			kLCDWidth:  EQU display_cols             ;Width in characters 
6696			kLCD_Line1: EQU 0x00  
6696			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
6696			; E1 
6696			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
6696			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
6696			 
6696			lcd_init: 
6696				; no init as handled by the SCM bios 
6696 c9				ret 
6697			 
6697			 
6697			; low level functions for direct screen writes 
6697			 
6697			; output char at pos? 
6697			fLCD_Str: 
6697			        ;out (SC114_SIO_1_OUT),a 
6697 c5				push bc 
6698 d5				push de 
6699 5f				ld e, a 
669a			; TODO Replace with CP/M BIOS call 
669a 0e 02			ld c, $02 
669c cd 05 00			call 5 
669f d1				pop de 
66a0 c1				pop bc 
66a1 c9				ret 
66a2			 
66a2			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
66a2			fLCD_Pos: 
66a2				; use ASCII escape to position 
66a2			        ;out (SC114_SIO_1_OUT),a 
66a2 c5				push bc 
66a3 d5				push de 
66a4 5f				ld e, a 
66a5 0e 02			ld c, $02 
66a7			; TODO Replace with CP/M BIOS call 
66a7 cd 05 00			call 5 
66aa d1				pop de 
66ab c1				pop bc 
66ac			 
66ac c9				ret 
66ad			 
66ad			; output char at pos 
66ad			fLCD_Data: 
66ad			      ;  out (SC114_SIO_1_OUT),a 
66ad c5				push bc 
66ae d5				push de 
66af 0e 02			ld c, $02 
66b1 5f				ld e, a 
66b2			; TODO Replace with CP/M BIOS call 
66b2 cd 05 00			call 5 
66b5 d1				pop de 
66b6 c1				pop bc 
66b7			 
66b7 c9				ret 
66b8			 
66b8			; ascii cls  
66b8			 
66b8 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
66bc			 
66bc 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
66d3			;.clscpm: db 3, $3c,"$" 
66d3			 
66d3			; write the frame buffer given in hl to hardware  
66d3			write_display: 
66d3			 
66d3			API: equ 0 
66d3			 
66d3			if API 
66d3				push bc 
66d3				ld b, 4 
66d3			 
66d3			        ld (display_write_tmp), hl 	  
66d3			 
66d3				; clear and home cursor 
66d3			 
66d3				ld c, 9 
66d3				ld de, .cls 
66d3			; TODO Replace with CP/M BIOS call 
66d3				call 5 
66d3			 
66d3			 
66d3			.writeln: 
66d3			 
66d3				ld de, (display_write_tmp) 
66d3				ld c, 6 
66d3			; TODO Replace with CP/M BIOS call 
66d3				rst $30 
66d3				ld c, 7 
66d3				rst $30 
66d3			 
66d3				ld hl, (display_write_tmp) 
66d3				ld de, display_cols 
66d3				add hl,de 
66d3				ld (display_write_tmp),hl 
66d3			 
66d3				djnz  .writeln 
66d3			 
66d3				pop bc 
66d3			 
66d3			 
66d3				ret 
66d3			endif 
66d3 e5				push hl 
66d4 c5				push bc 
66d5 d5				push de 
66d6			 
66d6			;	ld c, 2 
66d6			;	;ld de, .cls 
66d6			;	ld a, 27 
66d6			;	rst $30 
66d6			;	ld c, 2 
66d6			;	;ld de, .cls 
66d6			;	ld a, '[' 
66d6			;	rst $30 
66d6			; 
66d6			;	ld c, 2 
66d6			;	;ld de, .cls 
66d6			;	ld a, 'H' 
66d6			;	rst $30 
66d6			; 
66d6			 
66d6			 
66d6			; lots of CR/LF 
66d6			;	ld c, 9 
66d6			;	ld de, .clscpm 
66d6			;	call 5 
66d6			 
66d6			; xterm cls 
66d6 0e 02			ld c, 2 
66d8 1e 1b			ld e, 27 
66da cd 05 00			call 5 
66dd			; cls causes too much flicker 
66dd			;	ld c, 2 
66dd			;	ld e, 'c' 
66dd			;	call 5 
66dd			 
66dd			; use xterm home instead 
66dd 0e 02			ld c, 2 
66df 1e 5b			ld e, '[' 
66e1 cd 05 00			call 5 
66e4 0e 02			ld c, 2 
66e6 1e 48			ld e, 'H' 
66e8 cd 05 00			call 5 
66eb			LLL: equ 0 
66eb			 
66eb			if LLL 
66eb			 
66eb				ld c, 2 
66eb				;ld de, .cls 
66eb				ld e, 27 
66eb			; TODO Replace with CP/M BIOS call 
66eb				call 5 
66eb			 
66eb			 
66eb				ld c, 2 
66eb				;ld de, .cls 
66eb				ld e, '[' 
66eb			; TODO Replace with CP/M BIOS call 
66eb				call 5 
66eb				ld c, 2 
66eb				;ld de, .cls 
66eb				ld e, '2' 
66eb			; TODO Replace with CP/M BIOS call 
66eb				call 5 
66eb				ld c, 2 
66eb				;ld de, .cls 
66eb				ld e, 'J' 
66eb			; TODO Replace with CP/M BIOS call 
66eb				call 5 
66eb			 
66eb			endif 
66eb			 
66eb d1				pop de 
66ec c1				pop bc 
66ed e1				pop hl 
66ee			 
66ee			 
66ee 22 c9 eb		        ld (display_write_tmp), hl 	  
66f1 3e 00			ld a, kLCD_Line1 
66f3			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
66f3 06 28			ld b, display_cols 
66f5 ed 5b c9 eb		ld de, (display_write_tmp) 
66f9 cd 7c 67			call write_len_string 
66fc				 
66fc			 
66fc e5			push hl 
66fd d5			push de 
66fe c5			push bc 
66ff 0e 02			ld c, 2 
6701 1e 0a			ld e, 10 
6703 cd 05 00			call 5 
6706 0e 02			ld c, 2 
6708 1e 0d			ld e, 13 
670a cd 05 00			call 5 
670d			; TODO Replace with CP/M BIOS call 
670d				;rst $30 
670d c1			pop bc 
670e d1			pop de 
670f e1			pop hl 
6710			 
6710				 
6710 2a c9 eb			ld hl, (display_write_tmp) 
6713 11 28 00			ld de, display_cols 
6716 19				add hl,de 
6717 22 c9 eb			ld (display_write_tmp),hl 
671a			 
671a				 
671a 3e 28			ld a, kLCD_Line2 
671c			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
671c 06 28			ld b, display_cols 
671e ed 5b c9 eb		ld de, (display_write_tmp) 
6722 cd 7c 67			call write_len_string 
6725				 
6725 2a c9 eb			ld hl, (display_write_tmp) 
6728 11 28 00			ld de, display_cols 
672b 19				add hl,de 
672c 22 c9 eb			ld (display_write_tmp),hl 
672f			 
672f e5			push hl 
6730 d5			push de 
6731 c5			push bc 
6732 0e 07			ld c, 7 
6734			; TODO Replace with CP/M BIOS call 
6734				;rst $30 
6734 0e 02			ld c, 2 
6736 1e 0a			ld e, 10 
6738 cd 05 00			call 5 
673b 0e 02			ld c, 2 
673d 1e 0d			ld e, 13 
673f cd 05 00			call 5 
6742 c1			pop bc 
6743 d1			pop de 
6744 e1			pop hl 
6745			 
6745				 
6745 3e 50			ld a, kLCD_Line3 
6747			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
6747 06 28			ld b, display_cols 
6749 ed 5b c9 eb		ld de, (display_write_tmp) 
674d cd 7c 67			call write_len_string 
6750				 
6750 2a c9 eb			ld hl, (display_write_tmp) 
6753 11 28 00			ld de, display_cols 
6756 19				add hl,de 
6757 22 c9 eb			ld (display_write_tmp),hl 
675a			 
675a e5			push hl 
675b d5			push de 
675c c5			push bc 
675d 0e 07			ld c, 7 
675f			; TODO Replace with CP/M BIOS call 
675f				;rst $30 
675f 0e 02			ld c, 2 
6761 1e 0a			ld e, 10 
6763 cd 05 00			call 5 
6766 0e 02			ld c, 2 
6768 1e 0d			ld e, 13 
676a cd 05 00			call 5 
676d c1			pop bc 
676e d1			pop de 
676f e1			pop hl 
6770			 
6770				 
6770 3e 78			ld a, kLCD_Line4 
6772			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
6772 06 28			ld b, display_cols 
6774 ed 5b c9 eb		ld de, (display_write_tmp) 
6778 cd 7c 67			call write_len_string 
677b c9					ret 
677c			 
677c			 
677c				; write out a fixed length string given in b from de 
677c			 
677c 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
677d cd ad 66		            CALL fLCD_Data      ;Write character to display 
6780 13				inc de 
6781 10 f9			djnz write_len_string 
6783 c9				ret 
6784			 
6784			 
6784			; eof 
# End of file firmware_cpm_display.asm
6784			;include "firmware_key_5x10.asm" 
6784			;;include "firmware_key_4x10.asm" 
6784			include "firmware_key_cpm.asm" 
6784			; Serial keyboard interface for SC114 
6784			 
6784			 
6784			key_init: 
6784				; no init as handled by the SCM bios 
6784 c9				ret 
6785			 
6785			 
6785			cin_wait: 
6785			;	ld a, 0 
6785			;	ret 
6785			 
6785				;in a,(SC114_SIO_1_IN) 
6785			        ; Use SCM API to get from whatever console device we are using 
6785			 
6785			; TODO Replace with CP/M BIOS call 
6785 c5				push bc 
6786 0e 01			ld c, $01 
6788 cd 05 00			call 5 
678b c1				pop bc 
678c c9				ret 
678d			 
678d			cin: 
678d			 
678d			 
678d c5				push bc 
678e			 
678e				; any key waiting to process? 
678e			; TODO Replace with CP/M BIOS call 
678e 0e 06			ld c, $06 
6790 cd 05 00			call 5 
6793 28 0d			jr z, .cin_skip 
6795			 
6795				; yep, get it 
6795			 
6795 0e 01			ld c, $01 
6797			; TODO Replace with CP/M BIOS call 
6797 cd 05 00			call 5 
679a			 
679a fe 7f			cp $7f     ; back space 
679c 20 02			jr nz, .skipbs 
679e 3e 08			ld a, KEY_BS 
67a0			.skipbs: 
67a0			 
67a0 c1				pop bc 
67a1 c9				ret 
67a2			.cin_skip: 
67a2 3e 00			ld a, 0 
67a4 c1				pop bc 
67a5 c9				ret 
67a6			 
67a6			 
67a6			 
67a6			 
# End of file firmware_key_cpm.asm
67a6			endofcode:  
67a6			baseram:  
67a6 00				nop 
67a7			 
67a7			heap_start: equ baseram+15  ; Starting address of heap 
67a7			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
67a7			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
67a7			;VDU:  EQU     endofcode           ; BASIC Work space 
67a7			; eof 
67a7			 
# End of file os_mega_cpm.asm
67a7
