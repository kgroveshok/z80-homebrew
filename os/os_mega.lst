# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 6f 1c			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 ..			buildtime: db   "Build: " 
000a					include "romtimestamp.asm" 
000a ..			db '2025-08-09 10:39' 
# End of file romtimestamp.asm
001a 00				   db 0 
001b			 
001b			 
001b			 
001b			;        nop  
001b			;        nop 
001b			;;	org 05h		; null out bdos call 
001b			; 
001b			;        nop  
001b			;        nop  
001b			;        nop 
001b			;;	org 08h 
001b			;;; 
001b			;;	jp cin		; rst 8 - char in 
001b			;;; 
001b			; 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;	org 010h 
001b			;; 
001b			;	jp cout		; rest 010h  - char out 
001b			;; 
001b			;	org 01bh   
001b			; 
001b			;	;jp  		; rst 01bh   - write string to display 
001b			;	jp str_at_display 
001b			; 
001b			; 
001b			;	org 020h 
001b			; 
001b			;	; jp		 ; rst 020h - read char at screen location 
001b			; 
001b			;	org 028h 
001b			 
001b				; jp		 ; rst 028h  - storage i/o 
001b			 
001b			; 	org 030h 
001b			;	jp break_point_state 
001b			  
001b			; $30  
001b			; org 038h 
001b			; $38 
001b			 
001b			; TODO any more important entry points to add to jump table for easier coding use? 
001b			 
001b			if BASE_KEV = 1  
001b			 
001b				; need to be at $66 for nmi support 
001b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0021 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0027 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0033 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0039 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0045 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0051 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0057 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0063 00 ff			db 0,255 
0065 c3 52 76			jp nmi 
0068			endif 
0068			 
0068			include "firmware.asm" 
0068			  
0068			; main constants (used here and in firmware)  
0068			  
0068			; TODO have page 0 of storage as bios  
0068			  
0068			Device_A: equ 0h  
0068			Device_B: equ 040h          ; Sound  
0068			  
0068			if BASE_KEV  
0068			Device_C: equ 080h          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			if BASE_SC114  
0068			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			if BASE_CPM  
0068			; TODO fixup for CPM  
0068			Device_C: equ 080h          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			Device_D: equ 0c0h             ; Keyboard and LCD  
0068			  
0068			; Odd specific debug points for testing hardware dev  
0068			  
0068			DEBUG_SOUND: equ 0       
0068			DEBUG_STK_FAULT: equ 0  
0068			DEBUG_INPUT: equ 0     ; Debug input entry code  
0068			DEBUG_INPUTV2: equ 1     ; Debug input entry code  
0068			DEBUG_KEYCINWAIT: equ 0  
0068			DEBUG_KEYCIN: equ 0  
0068			DEBUG_KEY: equ 0  
0068			DEBUG_KEY_MATRIX: equ 0  
0068			DEBUG_STORECF: equ 0  
0068			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0068			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0068			DEBUG_SPI: equ 0    ; low level spi tests  
0068			  
0068			; Enable many break points  
0068			  
0068			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0068			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0068			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0068			DEBUG_FORTH_JP: equ 0    ; 4  
0068			DEBUG_FORTH_MALLOC: equ 0  
0068			DEBUG_FORTH_MALLOC_INT: equ 0  
0068			DEBUG_FORTH_DOT: equ 1  
0068			DEBUG_FORTH_DOT_WAIT: equ 0  
0068			DEBUG_FORTH_MATHS: equ 0  
0068			DEBUG_FORTH_TOK: equ 0    ; 4  
0068			DEBUG_FORTH_PARSE: equ 0    ; 3  
0068			DEBUG_FORTH: equ 0  ;2  
0068			DEBUG_FORTH_WORDS: equ 1   ; 1  
0068			DEBUG_FORTH_PUSH: equ 1   ; 1  
0068			DEBUG_FORTH_UWORD: equ 1   ; 1  
0068			  
0068			; Enable key point breakpoints  
0068			  
0068			DEBUG_FORTH_DOT_KEY: equ 0  
0068			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0068			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0068			  
0068			; Debug stack imbalances  
0068			  
0068			ON: equ 1  
0068			OFF: equ 0  
0068			  
0068			DEBUG_STACK_IMB: equ 0  
0068			STACK_IMB_STORE: equ 20  
0068			  
0068			; House keeping and protections  
0068			  
0068			DEBUG_FORTH_STACK_GUARD: equ 1  
0068			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0068			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0068			FORTH_ENABLE_FREE: equ 0  
0068			FORTH_ENABLE_MALLOCFREE: equ 1  
0068			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0068			FORTH_ENABLE_FLOATMATH: equ 0  
0068			  
0068			  
0068			CALLMONITOR: macro  
0068			;	call break_point_state  
0068			; now use the break point debug vector  
0068				call debug_vector  
0068				endm  
0068			  
0068			MALLOC_1: equ 1        ; from dk88   
0068			MALLOC_2: equ 0           ; broke  
0068			MALLOC_3: equ 0           ; really broke  
0068			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0068			  
0068			if BASE_KEV   
0068			;stacksize: equ 256  
0068			; each stack entry is three bytes (type + word)  
0068			stacksize: equ 3*150  
0068			  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 512  
0068			endif  
0068			if BASE_SC114  
0068			;tos:	equ 0f000h  
0068			stacksize: equ 256  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 256  
0068			endif  
0068			  
0068			if BASE_CPM  
0068			;tos:	equ 0f000h  
0068			stacksize: equ 256  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 256  
0068			endif  
0068			  
0068			;if STORAGE_SE == 0  
0068			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0068			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0068			;endif  
0068			  
0068			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0068			  
0068			STORE_0_AUTORUN: equ $20  
0068			  
0068			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0068			  
0068			STORE_0_AUTOFILE: equ $21  
0068			STORE_0_BANKRUN: equ $23  
0068			STORE_0_FILERUN: equ $24  
0068			  
0068			; Block 0 offsets for settings  
0068			  
0068			; if set then skip prompt for start up and accept all  
0068			  
0068			STORE_0_QUICKSTART: equ $25  
0068			  
0068			; Blocks where directory table is held  
0068			  
0068			; Reducing the number of entries increases the max file size  
0068			  
0068			;STORE_DIR_START: equ 1  
0068			;STORE_DIR_END: equ 33  
0068			  
0068			; Blocks from where file data is stored  
0068			  
0068			;STORE_DATA_START: equ STORE_DIR_END + 1  
0068			  
0068			; Block indicators (<32 are data files)  
0068			  
0068			;STORE_BLOCK_CFG: equ $8f       ; config block  
0068			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0068			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0068			;STORE_BLOCK_FREE: equ $85       ; data block free  
0068			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0068			  
0068			  
0068			  
0068			; Directory entry flags  
0068			  
0068			;STORE_DIR_FREE: equ 0  
0068			;STORE_DIR_FILE:  equ 1  
0068			  
0068			; Structure offsets to directory entries  
0068			;STORE_DE_FLAG: equ 0  
0068			;STORE_DE_MAXEXT: equ 1  
0068			;STORE_DE_FILENAME: equ 2  
0068			  
0068			; Structure offsets to block 0  
0068			  
0068			;STORE_BK0_ISFOR: equ 1  
0068			;STORE_BK0_LABEL: equ 3  
0068			  
0068			; memory allocation   
0068			  
0068			chk_stund: equ tos+2           ; underflow check word  
0068			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0068			  
0068			; keyscan table needs rows x cols buffer  
0068			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0068			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0068			  
0068			keyscan_table_row1: equ chk_stovr -key_cols-1  
0068			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0068			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0068			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0068			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0068			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0068			keyscan_scancol: equ keyscan_table-key_cols  
0068			;keyscan_table_len: equ key_rows*key_cols  
0068			;keybufptr: equ keyscan_table - 2  
0068			;keysymbol: equ keybufptr - 1  
0068			key_held: equ keyscan_scancol-1	; currently held  
0068			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0068			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0068			key_fa: equ key_repeat_ct -1 ;  
0068			key_fb: equ key_fa -1 ;  
0068			key_fc: equ key_fb -1 ;  
0068			key_fd: equ key_fc -1 ;  
0068			key_face_held: equ key_fd - 1   
0068			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0068			  
0068			hardware_config: equ key_face_held - 10  
0068			  
0068			; hardware config switches  
0068			; TODO add bitmasks on includes for hardware  
0068			; high byte for expansion ids  
0068			;     0000 0000  no card inserted  
0068			;     0000 0001  storage card inserted  
0068			;     0000 0010  spi sd card active  
0068			  
0068			;       
0068			; low byte:  
0068			;     0000 0001   4x4 keypad  
0068			;     0000 0010   full keyboard  
0068			;     0000 0011   spi/ext keyboard  
0068			;     0000 0100   20x4 lcd  
0068			;     0000 1000   40x4 lcd  
0068			;     0000 1100   spi/ext display  
0068			;     0001 0000   ide interface available  
0068			  
0068			hardware_word: equ hardware_config - 2  
0068			  
0068			; debug marker - optional display of debug point on the debug screens  
0068			  
0068			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
0068			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
0068			  
0068			debug_mark: equ debug_vector - 4  
0068			  
0068			; input_str vars  
0068			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0068			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0068			input_size: equ input_start -1  ; number of chars  
0068			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0068			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0068			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0068			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0068			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0068			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0068			input_len: equ input_cur_onoff - 5 ; length of current input  
0068			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0068			  
0068			; cursor blink rate  
0068			CUR_BLINK_RATE: equ $09  
0068			;CUR_BLINK_RATE: equ 15  
0068			  
0068			key_actual_pressed: equ input_cursor - 1   
0068			key_symbol: equ key_actual_pressed - 1   
0068			key_shift: equ key_symbol - 1   
0068			  
0068			; Display allocation  
0068			  
0068			;display_rows: equ 4     ; move out to mini and mega files  
0068			;display_cols: equ 20  
0068			  
0068			display_fb_len: equ display_rows*display_cols  
0068			  
0068			; primary frame buffer     
0068			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0068			; working frame buffers  
0068			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0068			display_fb3: equ  display_fb1-display_fb_len - 1  
0068			display_fb2: equ  display_fb3-display_fb_len - 1  
0068			;  
0068			; pointer to active frame buffer  
0068			display_fb_active: equ display_fb2 - 2  
0068			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0068			display_write_tmp: equ display_lcde1e2 - 2  
0068			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
0068			  
0068			;  
0068			  
0068			;; can load into de directory  
0068			cursor_col: equ display_active-1  
0068			cursor_row: equ cursor_col-1  
0068			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0068			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0068			  
0068			; maths vars  
0068			  
0068			LFSRSeed: equ cursor_shape -20   
0068			randData: equ LFSRSeed - 2  
0068			xrandc: equ randData - 2  
0068			stackstore: equ xrandc - 2  
0068			seed1: equ  stackstore -2   
0068			seed2: equ seed1 - 2  
0068			  
0068			; cf storage vars  
0068			  
0068			iErrorNum:  equ seed2-1         ;Error number  
0068			iErrorReg:  equ iErrorNum -1              ;Error register  
0068			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0068			  
0068			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0068			  
0068			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
0068			  
0068			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
0068			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0068			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
0068			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
0068			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
0068			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
0068			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0068			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0068			store_tmpid: equ store_tmp3 - 1		; page temp id  
0068			store_tmpext: equ store_tmpid - 1		; file extent temp  
0068			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
0068			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
0068			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
0068			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0068			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
0068			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0068			;  
0068			; spi vars  
0068			  
0068			  
0068			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
0068			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
0068			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0068			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0068			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0068			spi_device_id: equ spi_device - 1    ; human readable bank number  
0068			  
0068			;;;;; forth cli params  
0068			  
0068			; TODO use a different frame buffer for forth???  
0068			  
0068			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0068			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0068			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0068			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0068			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0068			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0068			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0068			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0068			  
0068			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0068			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0068			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0068			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
0068			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
0068			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0068			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0068			  
0068			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0068			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0068			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0068			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0068			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0068			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0068			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0068			  
0068			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0068			  
0068			; os/forth token vars  
0068			  
0068			os_last_cmd: equ os_var_array-255  
0068			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0068			os_current_i: equ os_cli_cmd-2  
0068			os_cur_ptr: equ os_current_i-2  
0068			os_word_scratch: equ os_cur_ptr-30  
0068			os_tok_len: equ os_word_scratch - 2  
0068			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0068			os_tok_malloc: equ os_tok_ptr - 2  
0068			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0068			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0068			execscratch: equ os_input-255        ; exec cmd eval buffer  
0068			scratch: equ execscratch-255  
0068			  
0068			os_stack_1: equ scratch - 3       ; stack holding area 1  
0068			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
0068			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
0068			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
0068			  
0068			  
0068			; temp locations for new word processing to save on adding more   
0068			  
0068			os_new_malloc: equ os_stack_4-2  
0068			os_new_parse_len: equ os_new_malloc - 2  
0068			os_new_word_len: equ os_new_parse_len - 2  
0068			os_new_work_ptr: equ os_new_word_len - 2  
0068			os_new_src_ptr: equ os_new_work_ptr - 2  
0068			os_new_exec: equ os_new_src_ptr - 2  
0068			os_new_exec_ptr: equ os_new_exec - 2  
0068			  
0068			; resume memory alloocations....  
0068			  
0068			;os_view_disable: equ os_new_exec_ptr - 1  
0068			os_view_af: equ os_new_exec_ptr - 2  
0068			os_view_hl: equ os_view_af -2  
0068			os_view_de: equ os_view_hl - 2  
0068			os_view_bc: equ os_view_de - 2  
0068			  
0068			; stack checksum word  
0068			if DEBUG_STACK_IMB  
0068				curframe: equ  os_view_de - 5  
0068				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0068				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0068			else  
0068				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0068			endif  
0068			  
0068			; with data stack could see memory filled with junk. need some memory management   
0068			; malloc and free entry points added  
0068			  
0068			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0068			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0068			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			;heap_end: equ free_list-1  ; Starting address of heap  
0068			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			  
0068			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			heap_end: equ chk_word-1  ; Starting address of heap  
0068			  
0068			  
0068			;if BASE_KEV   
0068			;heap_start: equ 0800eh  ; Starting address of heap  
0068			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0068			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0068			;endif  
0068			  
0068			;if BASE_SC114  
0068			;heap_start: equ baseram+15  ; Starting address of heap  
0068			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0068			;endif  
0068			  
0068			  
0068			;;;;  
0068			  
0068			  
0068			; change below to point to last memory alloc above  
0068			topusermem:  equ   heap_start  
0068			  
0068			;if BASE_KEV   
0068			;baseusermem: equ 08000h  
0068			;endif  
0068			  
0068			;if BASE_SC114  
0068			;;aseusermem:     equ    12  
0068			;baseusermem:     equ    prompt  
0068			;;baseusermem:     equ    endofcode  
0068			;endif  
0068			  
0068			  
0068			; **********************************************************************  
0068			; **  Constants  
0068			; **********************************************************************  
0068			  
0068			; Constants used by this code module  
0068			kDataReg:   EQU Device_D           ;PIO port A data register  
0068			kContReg:   EQU Device_D+2           ;PIO port A control register  
0068			  
0068			  
0068			portbdata:  equ Device_D+1    ; port b data  
0068			portbctl:   equ Device_D+3    ; port b control  
0068			  
0068			  
0068			;KEY_SHIFT:   equ 5  
0068			;KEY_SYMBOLSHIFT:  equ 6  
0068			  
0068			KEY_SHIFTLOCK: equ 4  
0068			  
0068			  
0068			KEY_UP: equ 5  
0068			KEY_NEXTWORD: equ 6  
0068			KEY_PREVWORD: equ 7  
0068			KEY_BS: equ 8  
0068			KEY_TAB:  equ 9  
0068			KEY_DOWN: equ 10  
0068			KEY_LEFT: equ 11  
0068			KEY_RIGHT: equ 12  
0068			KEY_CR:   equ 13  
0068			KEY_HOME: equ 14  
0068			KEY_END: equ 15  
0068			  
0068			KEY_F1: equ 16  
0068			KEY_F2: equ 17  
0068			KEY_F3: equ 18  
0068			KEY_F4: equ 19  
0068			  
0068			KEY_F5: equ 20  
0068			KEY_F6: equ 21  
0068			KEY_F7: equ 22  
0068			KEY_F8: equ 23  
0068			  
0068			KEY_F9: equ 24  
0068			KEY_F10: equ 25  
0068			KEY_F11: equ 26  
0068			KEY_F12: equ 27  
0068			  
0068			;if DEBUG_KEY  
0068			;	KEY_MATRIX_NO_PRESS: equ '.'  
0068			;	KEY_SHIFT:   equ '.'  
0068			;	KEY_SYMBOLSHIFT:  equ '.'  
0068			;else  
0068				KEY_SHIFT:   equ '~'  
0068				KEY_SYMBOLSHIFT:  equ '~'  
0068				KEY_MATRIX_NO_PRESS: equ '~'  
0068			;endi  
0068			  
0068			  
0068			  
0068			  
0068			; Macro to make adding debug marks easier  
0068			  
0068			DMARK: macro str  
0068				push af  
0068				ld a, (.dmark)  
0068				ld (debug_mark),a  
0068				ld a, (.dmark+1)  
0068				ld (debug_mark+1),a  
0068				ld a, (.dmark+2)  
0068				ld (debug_mark+2),a  
0068				jr .pastdmark  
0068			.dmark: db str  
0068			.pastdmark: pop af  
0068			  
0068			endm  
0068			  
0068			  
0068			; macro to detect for stack imbalances  
0068			  
0068			include "stackimbal.asm"  
0068			; Macro and code to detect stock imbalances 
0068			 
0068			SPPUSH: equ 0 
0068			 
0068			; Add a stack frame which can be checked before return 
0068			 
0068			STACKFRAME: macro onoff frame1 frame2 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						; save current SP 
0068						exx 
0068			 
0068						ld de, frame1 
0068						ld a, d 
0068						ld hl, curframe 
0068						call hexout 
0068						ld a, e 
0068						ld hl, curframe+2 
0068						call hexout 
0068			  
0068						ld hl, frame1 
0068						push hl 
0068						ld hl, frame2 
0068						push hl 
0068						exx 
0068					endif 
0068					 
0068				endif 
0068			endm 
0068			 
0068			STACKFRAMECHK: macro onoff frame1 frame2 
0068			 
0068					 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						exx 
0068						; check stack frame SP 
0068			 
0068						ld hl, frame2 
0068						pop de   ; frame2 
0068			 
0068						call cmp16 
0068						jr nz, .spnosame 
0068						 
0068			 
0068						ld hl, frame1 
0068						pop de   ; frame1 
0068			 
0068						call cmp16 
0068						jr z, .spfrsame 
0068			 
0068						.spnosame: call showsperror 
0068			 
0068						.spfrsame: nop 
0068			 
0068						exx 
0068					endif 
0068					 
0068				endif 
0068			 
0068			 
0068			endm 
0068			 
0068			 
0068			; for a sub routine, wrap SP collection and comparisons 
0068			 
0068			; Usage: 
0068			; 
0068			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0068			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0068			 
0068			SAVESP: macro onoff storeword 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						; save current SP 
0068			 
0068						ld (store_sp+(storeword*4)), sp 
0068			 
0068					endif 
0068					 
0068				endif 
0068			 
0068			endm 
0068			 
0068			CHECKSP: macro onoff storeword 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068			 
0068						; save SP after last save 
0068				 
0068						ld (store_sp+(storeword*4)+2), sp 
0068			 
0068						push hl 
0068						ld hl, store_sp+(storeword*4) 
0068						call check_stack_sp  
0068						pop hl 
0068			 
0068			 
0068					endif 
0068					 
0068				endif 
0068			 
0068			endm 
0068			 
0068			if DEBUG_STACK_IMB 
0068			 
0068			check_stack_sp: 
0068					push de 
0068			 
0068					ld e, (hl) 
0068					inc hl 
0068					ld d, (hl) 
0068					inc hl 
0068			 
0068					push de 
0068			 
0068			 
0068					ld e, (hl) 
0068					inc hl 
0068					ld d, (hl) 
0068					inc hl 
0068			 
0068					pop hl 
0068			 
0068			 
0068					; check to see if the same 
0068			 
0068					call cmp16 
0068					jr z, .spsame 
0068			 
0068					; not same 
0068			 
0068					call showsperror 
0068			.spsame: 
0068			 
0068					pop de 
0068			 
0068					ret 
0068			 
0068			.sperr:  db "Stack imbalance",0 
0068			 
0068			 
0068			showsperror: 
0068			 
0068			 
0068				push hl 
0068				push af 
0068				push de 
0068				call clear_display 
0068				ld de, .sperr 
0068				ld a,0 
0068			;	ld de,os_word_scratch 
0068				call str_at_display 
0068				ld a, display_row_1+17 
0068				ld de, debug_mark 
0068				call str_at_display 
0068				ld a, 0 
0068				ld (curframe+4),a 
0068				ld hl, curframe 
0068				ld de, os_word_scratch 
0068				ld a, display_row_4 
0068				call str_at_display 
0068				call update_display 
0068				;call break_point_state 
0068				call cin_wait 
0068			 
0068			;	ld a, ' ' 
0068			;	ld (os_view_disable), a 
0068				call bp_on 
0068				pop de	 
0068				pop af 
0068				pop hl 
0068				CALLMONITOR 
0068				ret 
0068			 
0068			endif 
0068			 
0068			 
0068			 
0068			; eof 
# End of file stackimbal.asm
0068			  
0068			;TODO macro to calc col and row offset into screen  
0068			  
0068			  
0068			  
0068			hardware_init:  
0068			  
0068				  
0068			  
0068					;ld a, 0  
0068					;ld (hardware_diag), a  
0068			  
0068					; clear all the buffers  
0068			  
0068 21 4b fc				ld hl, display_fb1  
006b 22 07 fb				ld (display_fb_active), hl  
006e			  
006e cd 9b 0d				call clear_display  
0071			  
0071 21 09 fb				ld hl, display_fb2  
0074 22 07 fb				ld (display_fb_active), hl  
0077			  
0077 cd 9b 0d				call clear_display  
007a			  
007a					; init primary frame buffer area  
007a 21 ec fc				ld hl, display_fb0  
007d 22 07 fb				ld (display_fb_active), hl  
0080			  
0080 cd 9b 0d				call clear_display  
0083			  
0083			  
0083 cd 5f 76				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0086			  
0086 cd f6 78			call key_init  
0089 cd 47 02			call storage_init  
008c			  
008c				; setup malloc functions  
008c			  
008c				if MALLOC_1  
008c cd d7 13				call  heap_init  
008f				endif  
008f				if MALLOC_4  
008f					call  heap_init  
008f				endif  
008f			  
008f				; init sound hardware if present  
008f			  
008f				if SOUND_ENABLE  
008f					call sound_init  
008f				endif  
008f			  
008f				; lcd test sequence  
008f					  
008f cd be 0d			call update_display  
0092 cd de 0c			call delay1s  
0095 3e 2b			ld a,'+'  
0097 cd a0 0d			call fill_display  
009a cd be 0d			call update_display  
009d cd de 0c			call delay1s  
00a0 3e 2a			ld a,'*'  
00a2 cd a0 0d			call fill_display  
00a5 cd be 0d			call update_display  
00a8 cd de 0c			call delay1s  
00ab 3e 2d			ld a,'-'  
00ad cd a0 0d			call fill_display  
00b0 cd be 0d			call update_display  
00b3 cd de 0c			call delay1s  
00b6			  
00b6			; boot splash screen  
00b6			if display_cols == 20	  
00b6			        ld a, display_row_1    
00b6			else  
00b6 3e 0a		        ld a, display_row_1 +10   
00b8			endif  
00b8 11 69 1b			ld de, prom_bootmsg  
00bb cd ae 0d			call str_at_display  
00be cd be 0d			call update_display  
00c1			  
00c1			  
00c1 cd de 0c			call delay1s  
00c4 cd de 0c			call delay1s  
00c7			if display_cols == 20	  
00c7			            LD   A, display_row_3+2  
00c7			else  
00c7 3e 5c		            LD   A, display_row_3+12  
00c9			endif  
00c9 11 7e 1b			ld de, prom_bootmsg1  
00cc cd ae 0d			call str_at_display  
00cf cd be 0d			call update_display  
00d2 cd de 0c			call delay1s  
00d5 cd de 0c			call delay1s  
00d8			  
00d8			;	ld a, display_row_4+3  
00d8			;	ld de, bootmsg2  
00d8			;	call str_at_display  
00d8			;	call update_display  
00d8			;	call delay1s  
00d8			;	call delay1s  
00d8			  
00d8			; debug mark setup  
00d8			  
00d8 3e 5f		ld a, '_'  
00da 32 a6 fd		ld (debug_mark),a  
00dd 32 a7 fd		ld (debug_mark+1),a  
00e0 32 a8 fd		ld (debug_mark+2),a  
00e3 3e 00		ld a,0  
00e5 32 a9 fd		ld (debug_mark+3),a  
00e8			  
00e8 c9					ret  
00e9			  
00e9			  
00e9			;bootmsg2:	db "Firmware v0.1",0  
00e9			  
00e9			; a 4x20 lcd  
00e9			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00e9			  
00e9			;if display_cols == 20  
00e9			;	include "firmware_lcd_4x20.asm"  
00e9			;endif  
00e9			  
00e9			;if display_cols == 40  
00e9			;	include "firmware_lcd_4x40.asm"  
00e9			;endif  
00e9			  
00e9			;  
00e9			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00e9			; TODO abstract the bit bang video out interface for dual display  
00e9			; TODO wire video out to tx pin on rc2014 bus  
00e9			  
00e9			; must supply cin, and cin_wait for low level hardware abstraction   
00e9			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00e9			; test scancode  
00e9			  
00e9			;;;;;  
00e9			;;;  
00e9			; Moved out to mini and maxi versions  
00e9			;  
00e9			; include "firmware_key_4x4.asm"  
00e9			; using existing 4 wire x 4 resistor array for input  
00e9			;include "firmware_key_4x10.asm"  
00e9			; need to mod the board for 5 rows due to resistor array  
00e9			;include "firmware_key_5x10.asm"  
00e9			  
00e9			; storage hardware interface  
00e9			  
00e9			; use microchip serial eeprom for storage  
00e9			  
00e9			  
00e9			if STORAGE_SE  
00e9				include "firmware_spi.asm"  
00e9			; my spi protocol (used by storage) 
00e9			 
00e9			; SPI pins 
00e9			 
00e9			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00e9			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00e9			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00e9			 
00e9			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00e9			; chip pin 4 gnd 
00e9			 
00e9			 
00e9			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00e9			SPI_CE1: equ 1      ;    port a1 pin 14  
00e9			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00e9			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00e9			SPI_CE4: equ 4      ; port a4     pin 10 
00e9			 
00e9			; active low AND masks 
00e9			 
00e9			;SPI_CE0_MASK: equ    255-1 
00e9			;SPI_CE1_MASK: equ   255-2 
00e9			;SPI_CE2_MASK: equ   255-4 
00e9			;SPI_CE3_MASK: equ   255-8 
00e9			;SPI_CE4_MASK: equ   255-16 
00e9			SPI_CE_HIGH:  equ 255 
00e9			 
00e9			 
00e9			 
00e9			;  Perform SCLK wait pulse 
00e9			 
00e9			spi_clk: 
00e9 f5				push af 
00ea 3a 9f f9			ld a, (spi_clktime) 
00ed fe 00			cp 0 
00ef 28 03			jr z, .scskip 
00f1 cd c3 0c			call aDelayInMS 
00f4			.scskip: 
00f4 f1				pop af 
00f5 c9				ret 
00f6			 
00f6			 
00f6			 
00f6			; TODO store port id for spi device ie dev c 
00f6			; TODO store pin for SO 
00f6			; TODO store pin for SI 
00f6			; TODO store pin for SCLK 
00f6			 
00f6			; 
00f6			 
00f6			; ensure that spi bus is in a stable state with default pins  
00f6			 
00f6			se_stable_spi:   
00f6			 
00f6				 ; set DI high, CE high , SCLK low 
00f6				;ld a, SPI_DI | SPI_CE0 
00f6 3e 07			ld a, SPI_DI  
00f8 cd 02 02			call spi_ce_high 
00fb d3 80			 out (storage_adata),a 
00fd 32 9c f9			ld (spi_portbyte),a 
0100			 
0100				if DEBUG_SPI 
0100					push hl 
0100					ld l, a 
0100					DMARK "SPI" 
0100					CALLMONITOR 
0100					pop hl 
0100				endif 
0100 c9				ret 
0101			 
0101			; byte to send in a 
0101			 
0101			spi_send_byte: 
0101				; save byte to send for bit mask shift out 
0101 4f			        ld c,a 
0102 3a 9c f9			ld a,(spi_portbyte) 
0105				  
0105				; clock out	each bit of the byte msb first 
0105			 
0105 06 08			ld b, 8 
0107			.ssb1: 
0107				; clear so bit  
0107 cb bf			res SPI_DI, a 
0109 cb 11			rl c 
010b				; if bit 7 is set then carry is set 
010b 30 02			jr nc, .ssb2 
010d cb ff			set SPI_DI,a 
010f			.ssb2:  ; output bit to ensure it is stable 
010f d3 80			out (storage_adata),a 
0111 00				nop 
0112				; clock bit high 
0112 cb ef			set SPI_SCLK,a 
0114 d3 80			out (storage_adata),a 
0116 00				nop 
0117 cd e9 00			call spi_clk 
011a				; then low 
011a cb af			res SPI_SCLK,a 
011c d3 80			out (storage_adata),a 
011e 00				nop 
011f cd e9 00			call spi_clk 
0122 10 e3			djnz .ssb1 
0124			 
0124 32 9c f9			ld (spi_portbyte),a 
0127 c9				ret 
0128			 
0128			; TODO low level get byte into A on spi 
0128			 
0128			spi_read_byte:  
0128			 
0128				; save byte to send for bit mask shift out 
0128 0e 00		    ld c,0 
012a 3a 9c f9			ld a,(spi_portbyte) 
012d				  
012d				; clock out	each bit of the byte msb first 
012d			 
012d			 
012d				; clock bit high 
012d cb ef			set SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132 cd e9 00			call spi_clk 
0135			 
0135			    ; read DO  
0135			 
0135 cb f9		    set 7,c 
0137 db 80			in a,(storage_adata) 
0139 cb 77		    bit SPI_DO,a 
013b 20 02		    jr nz, .b7 
013d cb b9		    res 7,c 
013f			.b7: 
013f				; then low 
013f cb af			res SPI_SCLK,a 
0141 d3 80			out (storage_adata),a 
0143 00				nop 
0144 cd e9 00			call spi_clk 
0147			     
0147			 
0147				; clock bit high 
0147 cb ef			set SPI_SCLK,a 
0149 d3 80			out (storage_adata),a 
014b 00				nop 
014c cd e9 00			call spi_clk 
014f			 
014f			    ; read DO  
014f			 
014f cb f1		    set 6,c 
0151 db 80			in a,(storage_adata) 
0153 cb 77		    bit SPI_DO,a 
0155 20 02		    jr nz, .b6 
0157 cb b1		    res 6,c 
0159			.b6: 
0159				; then low 
0159 cb af			res SPI_SCLK,a 
015b d3 80			out (storage_adata),a 
015d 00				nop 
015e cd e9 00			call spi_clk 
0161			 
0161				; clock bit high 
0161 cb ef			set SPI_SCLK,a 
0163 d3 80			out (storage_adata),a 
0165 00				nop 
0166 cd e9 00			call spi_clk 
0169			 
0169			 
0169			    ; read DO  
0169			 
0169 cb e9		    set 5,c 
016b db 80			in a,(storage_adata) 
016d cb 77		    bit SPI_DO,a 
016f 20 02		    jr nz, .b5 
0171 cb a9		    res 5,c 
0173			.b5: 
0173				; then low 
0173 cb af			res SPI_SCLK,a 
0175 d3 80			out (storage_adata),a 
0177 00				nop 
0178 cd e9 00			call spi_clk 
017b				; clock bit high 
017b cb ef			set SPI_SCLK,a 
017d d3 80			out (storage_adata),a 
017f 00				nop 
0180 cd e9 00			call spi_clk 
0183			 
0183			    ; read DO  
0183			 
0183 cb e1		    set 4,c 
0185 db 80			in a,(storage_adata) 
0187 cb 77		    bit SPI_DO,a 
0189 20 02		    jr nz, .b4 
018b cb a1		    res 4,c 
018d			.b4: 
018d				; then low 
018d cb af			res SPI_SCLK,a 
018f d3 80			out (storage_adata),a 
0191 00				nop 
0192 cd e9 00			call spi_clk 
0195				; clock bit high 
0195 cb ef			set SPI_SCLK,a 
0197 d3 80			out (storage_adata),a 
0199 00				nop 
019a cd e9 00			call spi_clk 
019d			 
019d			    ; read DO  
019d			 
019d cb d9		    set 3,c 
019f db 80			in a,(storage_adata) 
01a1 cb 77		    bit SPI_DO,a 
01a3 20 02		    jr nz, .b3 
01a5 cb 99		    res 3,c 
01a7			.b3: 
01a7				; then low 
01a7 cb af			res SPI_SCLK,a 
01a9 d3 80			out (storage_adata),a 
01ab 00				nop 
01ac cd e9 00			call spi_clk 
01af				; clock bit high 
01af cb ef			set SPI_SCLK,a 
01b1 d3 80			out (storage_adata),a 
01b3 00				nop 
01b4 cd e9 00			call spi_clk 
01b7			 
01b7			    ; read DO  
01b7			 
01b7 cb d1		    set 2,c 
01b9 db 80			in a,(storage_adata) 
01bb cb 77		    bit SPI_DO,a 
01bd 20 02		    jr nz, .b2 
01bf cb 91		    res 2,c 
01c1			.b2: 
01c1				; then low 
01c1 cb af			res SPI_SCLK,a 
01c3 d3 80			out (storage_adata),a 
01c5 00				nop 
01c6 cd e9 00			call spi_clk 
01c9				; clock bit high 
01c9 cb ef			set SPI_SCLK,a 
01cb d3 80			out (storage_adata),a 
01cd 00				nop 
01ce cd e9 00			call spi_clk 
01d1			 
01d1			    ; read DO  
01d1			 
01d1 cb c9		    set 1,c 
01d3 db 80			in a,(storage_adata) 
01d5 cb 77		    bit SPI_DO,a 
01d7 20 02		    jr nz, .b1 
01d9 cb 89		    res 1,c 
01db			.b1: 
01db				; then low 
01db cb af			res SPI_SCLK,a 
01dd d3 80			out (storage_adata),a 
01df 00				nop 
01e0 cd e9 00			call spi_clk 
01e3				; clock bit high 
01e3 cb ef			set SPI_SCLK,a 
01e5 d3 80			out (storage_adata),a 
01e7 00				nop 
01e8 cd e9 00			call spi_clk 
01eb			 
01eb			    ; read DO  
01eb			 
01eb cb c1		    set 0,c 
01ed db 80			in a,(storage_adata) 
01ef cb 77		    bit SPI_DO,a 
01f1 20 02		    jr nz, .b0 
01f3 cb 81		    res 0,c 
01f5			.b0: 
01f5				; then low 
01f5 cb af			res SPI_SCLK,a 
01f7 d3 80			out (storage_adata),a 
01f9 00				nop 
01fa cd e9 00			call spi_clk 
01fd			 
01fd			 
01fd 32 9c f9			ld (spi_portbyte),a 
0200			 
0200			    ; return byte 
0200 79			    ld a,c 
0201			 
0201			 
0201 c9				ret 
0202			 
0202			 
0202			 
0202			spi_ce_high: 
0202			 
0202				if DEBUG_SPI_HARD_CE0 
0202			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202					ret 
0202			 
0202				endif 
0202			 
0202			 
0202 f5				push af 
0203			 
0203				; send direct ce to port b 
0203 3e ff			ld a, 255 
0205 d3 81			out (storage_bdata), a 
0207			 
0207 f1				pop af 
0208			 
0208				; for port a that shares with spi lines AND the mask 
0208			  
0208				if DEBUG_SPI 
0208					push hl 
0208					ld h, a 
0208				endif 
0208			;	ld c, SPI_CE_HIGH 
0208			;	and c 
0208 cb c7			set SPI_CE0, a 
020a cb cf			set SPI_CE1, a 
020c cb d7			set SPI_CE2, a 
020e cb df			set SPI_CE3, a 
0210 cb e7			set SPI_CE4, a 
0212			 
0212				if DEBUG_SPI 
0212					ld l, a 
0212					DMARK "CEh" 
0212					CALLMONITOR 
0212					pop hl 
0212				endif 
0212 c9				ret 
0213			 
0213			 
0213			spi_ce_low: 
0213			 
0213				if DEBUG_SPI_HARD_CE0 
0213			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0213					ret 
0213			 
0213				endif 
0213			 
0213 c5				push bc 
0214 f5				push af 
0215			 
0215				; send direct ce to port b 
0215 3a 9e f9			ld a, (spi_cartdev) 
0218 d3 81			out (storage_bdata), a 
021a			 
021a			 
021a			 
021a				; for port a that shares with spi lines AND the mask 
021a			 
021a 3a 9b f9			ld a, (spi_device)  
021d 4f				ld c, a 
021e			 
021e f1				pop af 
021f			 
021f				; detect CEx 
021f			 
021f				if DEBUG_SPI 
021f					push hl 
021f					ld h, a 
021f				endif 
021f			 
021f cb 41			bit SPI_CE0, c 
0221 20 04			jr nz, .cel1 
0223 cb 87			res SPI_CE0, a 
0225 18 1e			jr .celn 
0227			.cel1: 
0227 cb 49			bit SPI_CE1, c 
0229 20 04			jr nz, .cel2 
022b cb 8f			res SPI_CE1, a 
022d 18 16			jr .celn 
022f			.cel2: 
022f cb 51			bit SPI_CE2, c 
0231 20 04			jr nz, .cel3 
0233 cb 97			res SPI_CE2, a 
0235 18 0e			jr .celn 
0237			.cel3: 
0237 cb 59			bit SPI_CE3, c 
0239 20 04			jr nz, .cel4 
023b cb 9f			res SPI_CE3, a 
023d 18 06			jr .celn 
023f			.cel4: 
023f cb 61			bit SPI_CE4, c 
0241 20 02			jr nz, .celn 
0243 cb a7			res SPI_CE4, a 
0245			.celn: 
0245			 
0245			 
0245			 
0245			;	add c 
0245			 
0245				if DEBUG_SPI 
0245					ld l, a 
0245					DMARK "CEl" 
0245					CALLMONITOR 
0245					pop hl 
0245				endif 
0245 c1				pop bc 
0246 c9				ret 
0247			 
0247			 
0247			 
0247			; eof 
0247			 
0247			 
0247			 
0247			 
0247			 
# End of file firmware_spi.asm
0247				include "firmware_seeprom.asm"  
0247			; 
0247			; persisent storage interface via microchip serial eeprom 
0247			 
0247			; port a pio 2 
0247			; pa 7 - si 
0247			; pa 6 - sclk  
0247			; pa 5 - so 
0247			; pa 4 - cs 
0247			; pa 3 - cs 
0247			; pa 2 - cs 
0247			; pa 1 - cs 
0247			; pa 0 - cs 
0247			; 
0247			; TODO get block 
0247			; TODO save block 
0247			; TODO load file 
0247			; TODO save file 
0247			; TODO get dir  
0247			 
0247			;  
0247			storage_adata: equ Device_C    ; device c port a - onboard storage 
0247			storage_actl: equ Device_C+2     ; device c port a 
0247			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0247			storage_bctl: equ Device_C+3     ; device c port b 
0247			 
0247			 
0247			; TODO move these to hardware driver file 
0247			 
0247			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0247			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0247			; storage bank file system format 
0247			; 
0247			; first page of bank: 
0247			; 	addr 0 - status check 
0247			;       addr 1 - write protect flag 
0247			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0247			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0247			;         TODO see if scanning whole of for available next file id is fast enough 
0247			;	addr 4 > zero term string of bank label 
0247			; 
0247			;        
0247			;  
0247			; first page of any file: 
0247			;      byte 0 - file id  
0247			;      byte 1-17 - fixed file name  
0247			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0247			; 
0247			; other pages of any file: 
0247			;      byte 0 - file id 
0247			;      byte 1> - file data 
0247			; 
0247			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0247			;  
0247			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0247			 
0247			 
0247			;storage_so_bit: 5 
0247			;storage_si_bit: 7 
0247			;storage_sclk_bit: 6 
0247			  
0247			 
0247			; init storage pio 
0247			 
0247			storage_init: 
0247			 
0247			 
0247					; set default SPI clk pulse time as disabled 
0247			 
0247 3e 00				ld a, 0 
0249 32 9f f9				ld (spi_clktime), a 
024c			 
024c					; init hardware 
024c			 
024c 3e cf		            LD   A, 11001111b 
024e d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0250 3e 00		            LD   A, 00000000b 
0252 cb f7			set SPI_DO,a 
0254			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0254 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0256			 
0256 3e cf		            LD   A, 11001111b 
0258 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
025a 3e 00		            LD   A, 00000000b 
025c d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
025e			 
025e				; set all external spi devices off  
025e 3e ff			ld a, 255 
0260 32 9b f9			ld (spi_device), a 
0263 32 9e f9			ld (spi_cartdev), a 
0266			 
0266					; ensure the spi bus is in a default stable state 
0266 cd f6 00				call se_stable_spi 
0269			 
0269			; TODO scan spi bus and gather which storage banks are present 
0269			 
0269			; populate store_bank_active  
0269			; for each ce line activate and attempt to write first byte of bank and read back 
0269			; if zero is returned then bank is empty 
0269			;   
0269			; 
0269			 
0269					; init file extent cache to save on slow reads 
0269			 
0269			;	ld hl, store_filecache 
0269			;	ld de, 0 
0269			;	ld hl,(de)	 
0269			 
0269			 
0269 c9			    ret 
026a			 
026a			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
026a			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
026a			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
026a			 
026a			; INSTRUCTION SET 
026a			; READ 0000 0011 Read data from memory array beginning at selected address 
026a			; WRITE 0000 0010 Write data to memory array beginning at selected address 
026a			; WREN 0000 0110 Set the write enable latch (enable write operations) 
026a			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
026a			; RDSR 0000 0101 Read STATUS register 
026a			; WRSR 0000 0001 Write STATUS register 
026a			; PE 0100 0010 Page Erase – erase one page in memory array 
026a			; SE 1101 1000 Sector Erase – erase one sector in memory array 
026a			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
026a			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
026a			 
026a			; TODO send byte steam for page without setting the address for every single byte 
026a			; TODO read byte  
026a			 
026a			; byte in a 
026a			; address in hl  
026a			se_writebyte: 
026a			        
026a			    ;   ld c, a 
026a f5			        push af 
026b e5			        push hl 
026c			 
026c			    ; initi write mode 
026c			    ; 
026c			    ;CS low 
026c			 
026c 3a 9c f9		       ld a,(spi_portbyte) 
026f cd 13 02			call spi_ce_low 
0272			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0272 d3 80		       out (storage_adata),a 
0274 32 9c f9		       ld (spi_portbyte), a 
0277			 
0277			    ;clock out wren instruction 
0277			 
0277 3e 06		    ld a, store_wren_ins 
0279 cd 01 01		    call spi_send_byte  
027c			 
027c			    ;cs high to enable write latch 
027c			 
027c 3a 9c f9		       ld a,(spi_portbyte) 
027f cd 02 02			call spi_ce_high 
0282			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0282 d3 80		       out (storage_adata),a 
0284 32 9c f9		       ld (spi_portbyte), a 
0287			 
0287 00				nop 
0288			    ; 
0288			    ; intial write data 
0288			    ; 
0288			    ; cs low 
0288			     
0288 3a 9c f9		       ld a,(spi_portbyte) 
028b cd 13 02			call spi_ce_low 
028e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028e d3 80		       out (storage_adata),a 
0290 32 9c f9		       ld (spi_portbyte), a 
0293			 
0293			    ; clock out write instruction 
0293			     
0293 3e 02		    ld a, store_write_ins  
0295 cd 01 01		    call spi_send_byte  
0298			 
0298			    ; clock out address (depending on address size) 
0298			     
0298 e1			    pop hl 
0299 7c			    ld a,h    ; address out msb first 
029a cd 01 01		    call spi_send_byte  
029d 7d			    ld a,l 
029e cd 01 01		    call spi_send_byte  
02a1			 
02a1			    ; clock out byte(s) for page 
02a1			 
02a1 f1			    pop af 
02a2 cd 01 01		    call spi_send_byte  
02a5			 
02a5			    ; end write with ce high 
02a5 3a 9c f9		       ld a,(spi_portbyte) 
02a8			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02a8 cd 02 02			call spi_ce_high 
02ab d3 80		       out (storage_adata),a 
02ad 32 9c f9		       ld (spi_portbyte), a 
02b0			 
02b0				; pause for internal write cycle 
02b0 3e 0a			ld a, 10 
02b2 cd c3 0c			call aDelayInMS 
02b5 c9			    ret 
02b6			 
02b6			; buffer to write in de 
02b6			; address in hl  
02b6			se_writepage: 
02b6			        
02b6			    ;   ld c, a 
02b6 d5				push de 
02b7 e5			        push hl 
02b8			 
02b8			    ; initi write mode 
02b8			    ; 
02b8			    ;CS low 
02b8			 
02b8 3a 9c f9		       ld a,(spi_portbyte) 
02bb cd 13 02			call spi_ce_low 
02be			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02be d3 80		       out (storage_adata),a 
02c0 32 9c f9		       ld (spi_portbyte), a 
02c3			 
02c3			    ;clock out wren instruction 
02c3			 
02c3 3e 06		    ld a, store_wren_ins 
02c5 cd 01 01		    call spi_send_byte  
02c8			 
02c8			    ;cs high to enable write latch 
02c8			 
02c8 3a 9c f9		       ld a,(spi_portbyte) 
02cb cd 02 02			call spi_ce_high 
02ce			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02ce d3 80		       out (storage_adata),a 
02d0 32 9c f9		       ld (spi_portbyte), a 
02d3			 
02d3 00				nop 
02d4			    ; 
02d4			    ; intial write data 
02d4			    ; 
02d4			    ; cs low 
02d4			     
02d4 3a 9c f9		       ld a,(spi_portbyte) 
02d7			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02d7 cd 13 02			call spi_ce_low 
02da d3 80		       out (storage_adata),a 
02dc 32 9c f9		       ld (spi_portbyte), a 
02df			 
02df			    ; clock out write instruction 
02df			     
02df 3e 02		    ld a, store_write_ins  
02e1 cd 01 01		    call spi_send_byte  
02e4			 
02e4			    ; clock out address (depending on address size) 
02e4			     
02e4 e1			    pop hl 
02e5 7c			    ld a,h    ; address out msb first 
02e6 cd 01 01		    call spi_send_byte  
02e9 7d			    ld a,l 
02ea cd 01 01		    call spi_send_byte  
02ed			 
02ed			    ; clock out byte(s) for page 
02ed			 
02ed e1				pop hl 
02ee 06 40			ld b, STORE_BLOCK_PHY 
02f0			.bytewrite: 
02f0			 
02f0 7e				ld a,(hl) 
02f1 e5			    push hl 
02f2 c5				push bc 
02f3 cd 01 01		    call spi_send_byte  
02f6 c1				pop bc 
02f7 e1				pop hl 
02f8			 
02f8			    ; end write with ce high 
02f8 3a 9c f9		       ld a,(spi_portbyte) 
02fb cd 02 02			call spi_ce_high 
02fe			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02fe d3 80		       out (storage_adata),a 
0300 32 9c f9		       ld (spi_portbyte), a 
0303			 
0303 23				inc hl 
0304 10 ea			djnz .bytewrite 
0306			 
0306				; pause for internal write cycle 
0306 3e 64			ld a, 100 
0308 cd c3 0c			call aDelayInMS 
030b c9			    ret 
030c			; returns byte in a 
030c			; address in hl  
030c			se_readbyte: 
030c d5				push de 
030d c5				push bc 
030e			 
030e			    ;   ld c, a 
030e e5			        push hl 
030f			 
030f			    ; initi write mode 
030f			    ; 
030f			    ;CS low 
030f			 
030f 3a 9c f9		       ld a,(spi_portbyte) 
0312 cd 13 02			call spi_ce_low 
0315			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0315 d3 80		       out (storage_adata),a 
0317 32 9c f9		       ld (spi_portbyte), a 
031a			 
031a			    ;clock out wren instruction 
031a			 
031a 3e 03		    ld a, store_read_ins 
031c cd 01 01		    call spi_send_byte  
031f			 
031f			 
031f			    ; clock out address (depending on address size) 
031f			     
031f e1			    pop hl 
0320 7c			    ld a,h    ; address out msb first 
0321 cd 01 01		    call spi_send_byte  
0324 7d			    ld a,l 
0325 cd 01 01		    call spi_send_byte  
0328			 
0328			    ; clock in byte(s) for page 
0328			 
0328 cd 28 01		    call spi_read_byte  
032b f5				push af 
032c			 
032c			    ; end write with ce high 
032c 3a 9c f9		       ld a,(spi_portbyte) 
032f			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
032f cd 02 02			call spi_ce_high 
0332 d3 80		       out (storage_adata),a 
0334 32 9c f9		       ld (spi_portbyte), a 
0337			 
0337 f1				pop af 
0338			 
0338 c1				pop bc 
0339 d1				pop de 
033a			 
033a c9			    ret 
033b			 
033b			if DEBUG_STORESE 
033b			 
033b			storageput:  
033b			 
033b			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
033b			 
033b 21 fe f0			ld hl,scratch+2 
033e cd df 12			call get_word_hl 
0341			 
0341				; stuff it here for the moment as it will be overwritten later anyway 
0341			 
0341 22 1f f4			ld (os_cur_ptr),hl	 
0344			 
0344			 
0344			; get pointer to start of string 
0344			 
0344 21 03 f1			ld hl, scratch+7 
0347			 
0347			; loop writing char of string to eeprom 
0347			 
0347 7e			.writestr:	ld a,(hl) 
0348 fe 00				cp 0 
034a 28 12				jr z, .wsdone		; done writing 
034c e5					push hl 
034d 2a 1f f4				ld hl,(os_cur_ptr) 
0350 cd 6a 02				call se_writebyte 
0353			 
0353 2a 1f f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0356 23					inc hl 
0357 22 1f f4				ld (os_cur_ptr),hl 
035a			 
035a					; restore string pointer and get next char 
035a			 
035a e1					pop hl 
035b 23					inc hl 
035c 18 e9				jr .writestr 
035e			 
035e			 
035e			 
035e			.wsdone: 
035e			 
035e			 
035e			; when done load first page into a buffer  
035e			 
035e 21 00 80				ld hl,08000h		; start in ram 
0361 22 1f f4				ld (os_cur_ptr),hl 
0364 21 00 00				ld hl, 0		 ; start of page 
0367 22 24 f1				ld (scratch+40),hl	; hang on to it 
036a			 
036a 06 80				ld b, 128		; actually get more then one page 
036c c5			.wsload:	push bc 
036d 2a 24 f1				ld hl,(scratch+40) 
0370 e5					push hl 
0371 cd 0c 03				call se_readbyte 
0374			 
0374					; a now as the byte 
0374			 
0374 2a 1f f4				ld hl,(os_cur_ptr) 
0377 77					ld (hl),a 
0378					; inc next buffer area 
0378 23					inc hl 
0379 22 1f f4				ld (os_cur_ptr),hl 
037c			 
037c					; get eeprom position, inc and save for next round 
037c e1					pop hl		 
037d 23					inc hl 
037e 22 24 f1				ld (scratch+40),hl 
0381 c1					pop bc 
0382 10 e8				djnz .wsload 
0384			 
0384			; set 'd' pointer to start of buffer 
0384			 
0384 21 00 80				ld hl,08000h 
0387 22 1f f4				ld (os_cur_ptr),hl 
038a			 
038a			 
038a c9			ret 
038b			 
038b			 
038b c9			storageread: ret 
038c			 
038c			 
038c			 
038c			 
038c			 
038c			 
038c			endif 
038c			 
038c			 
038c			 
# End of file firmware_seeprom.asm
038c			else  
038c			   ; create some stubs for the labels  
038c			se_readbyte: ret  
038c			se_writebyte: ret  
038c			storage_init: ret  
038c			  
038c			endif  
038c			  
038c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
038c			;include "firmware_cf.asm"  
038c			  
038c			; load up high level storage hardward abstractions  
038c			include "firmware_storage.asm"  
038c			 
038c			; persisent storage hardware abstraction layer  
038c			 
038c			 
038c			 
038c			; Block 0 on storage is a config state 
038c			 
038c			 
038c			 
038c			; TODO add read phy block and write phy block functions 
038c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
038c			 
038c			; Abstraction layer  
038c			 
038c			; Logocial block size is same size as physical size - using tape concept 
038c			 
038c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
038c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
038c			 
038c			 
038c			 
038c			; Filesystem layout (Logical layout) 
038c			; 
038c			; Block 0 - Bank config  
038c			; 
038c			;      Byte - 0 file id counter 
038c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
038c			;      Byte - 3-20 zero terminated bank label 
038c			; 
038c			; Block 1 > File storage 
038c			; 
038c			;      Byte 0 file id    - block 0 file details 
038c			;      Byte 1 block id - block 0 is file  
038c			;            Byte 2-15 - File name 
038c			; 
038c			;       - to end of block data 
038c			; 
038c			 
038c			; Get ID for the file named in pointer held HL 
038c			; Returns ID in HL = 255 if no file found 
038c			 
038c			storage_getid: 
038c			 
038c 22 ae f9			ld (store_tmp1), hl 
038f			 
038f				if DEBUG_STORESE 
038f					DMARK "SGI" 
038f f5				push af  
0390 3a a4 03			ld a, (.dmark)  
0393 32 a6 fd			ld (debug_mark),a  
0396 3a a5 03			ld a, (.dmark+1)  
0399 32 a7 fd			ld (debug_mark+1),a  
039c 3a a6 03			ld a, (.dmark+2)  
039f 32 a8 fd			ld (debug_mark+2),a  
03a2 18 03			jr .pastdmark  
03a4 ..			.dmark: db "SGI"  
03a7 f1			.pastdmark: pop af  
03a8			endm  
# End of macro DMARK
03a8					CALLMONITOR 
03a8 cd aa fd			call debug_vector  
03ab				endm  
# End of macro CALLMONITOR
03ab				endif 
03ab				; get block 0 and set counter for number of files to scan 
03ab			 
03ab cd 16 05			call storage_get_block_0 
03ae			 
03ae 3a b5 f9			ld a, (store_page) 
03b1 47				ld b, a 
03b2			 
03b2				; get extent 0 of each file id 
03b2			 
03b2				if DEBUG_STORESE 
03b2					DMARK "SGc" 
03b2 f5				push af  
03b3 3a c7 03			ld a, (.dmark)  
03b6 32 a6 fd			ld (debug_mark),a  
03b9 3a c8 03			ld a, (.dmark+1)  
03bc 32 a7 fd			ld (debug_mark+1),a  
03bf 3a c9 03			ld a, (.dmark+2)  
03c2 32 a8 fd			ld (debug_mark+2),a  
03c5 18 03			jr .pastdmark  
03c7 ..			.dmark: db "SGc"  
03ca f1			.pastdmark: pop af  
03cb			endm  
# End of macro DMARK
03cb					CALLMONITOR 
03cb cd aa fd			call debug_vector  
03ce				endm  
# End of macro CALLMONITOR
03ce				endif 
03ce 60			.getloop:	ld h, b 
03cf 2e 00				ld l, 0 
03d1 c5					push bc 
03d2			 
03d2 11 b5 f9				ld de, store_page 
03d5				if DEBUG_STORESE 
03d5					DMARK "SGr" 
03d5 f5				push af  
03d6 3a ea 03			ld a, (.dmark)  
03d9 32 a6 fd			ld (debug_mark),a  
03dc 3a eb 03			ld a, (.dmark+1)  
03df 32 a7 fd			ld (debug_mark+1),a  
03e2 3a ec 03			ld a, (.dmark+2)  
03e5 32 a8 fd			ld (debug_mark+2),a  
03e8 18 03			jr .pastdmark  
03ea ..			.dmark: db "SGr"  
03ed f1			.pastdmark: pop af  
03ee			endm  
# End of macro DMARK
03ee					CALLMONITOR 
03ee cd aa fd			call debug_vector  
03f1				endm  
# End of macro CALLMONITOR
03f1				endif 
03f1 cd be 09				call storage_read 
03f4 cd f8 0f				call ishlzero 
03f7 28 2d				jr z, .gap 
03f9					 
03f9					; have a file name read. Is it one we want. 
03f9			 
03f9 2a ae f9				ld hl, (store_tmp1) 
03fc 11 b8 f9				ld de, store_page+3   ; file name 
03ff			 
03ff				if DEBUG_STORESE 
03ff					DMARK "SGc" 
03ff f5				push af  
0400 3a 14 04			ld a, (.dmark)  
0403 32 a6 fd			ld (debug_mark),a  
0406 3a 15 04			ld a, (.dmark+1)  
0409 32 a7 fd			ld (debug_mark+1),a  
040c 3a 16 04			ld a, (.dmark+2)  
040f 32 a8 fd			ld (debug_mark+2),a  
0412 18 03			jr .pastdmark  
0414 ..			.dmark: db "SGc"  
0417 f1			.pastdmark: pop af  
0418			endm  
# End of macro DMARK
0418					CALLMONITOR 
0418 cd aa fd			call debug_vector  
041b				endm  
# End of macro CALLMONITOR
041b				endif 
041b cd be 13				call strcmp 
041e 20 06				jr nz, .gap   ; not this one 
0420			 
0420 c1				        pop bc 
0421			 
0421 26 00				ld h, 0 
0423 68					ld l, b 
0424 18 22				jr .getdone 
0426						 
0426			 
0426			 
0426			 
0426			.gap: 
0426				if DEBUG_STORESE 
0426					DMARK "SGg" 
0426 f5				push af  
0427 3a 3b 04			ld a, (.dmark)  
042a 32 a6 fd			ld (debug_mark),a  
042d 3a 3c 04			ld a, (.dmark+1)  
0430 32 a7 fd			ld (debug_mark+1),a  
0433 3a 3d 04			ld a, (.dmark+2)  
0436 32 a8 fd			ld (debug_mark+2),a  
0439 18 03			jr .pastdmark  
043b ..			.dmark: db "SGg"  
043e f1			.pastdmark: pop af  
043f			endm  
# End of macro DMARK
043f					CALLMONITOR 
043f cd aa fd			call debug_vector  
0442				endm  
# End of macro CALLMONITOR
0442				endif 
0442			 
0442 c1					pop bc 
0443 10 89				djnz .getloop 
0445 21 ff 00				ld hl, 255 
0448			.getdone: 
0448			 
0448				if DEBUG_STORESE 
0448					DMARK "SGe" 
0448 f5				push af  
0449 3a 5d 04			ld a, (.dmark)  
044c 32 a6 fd			ld (debug_mark),a  
044f 3a 5e 04			ld a, (.dmark+1)  
0452 32 a7 fd			ld (debug_mark+1),a  
0455 3a 5f 04			ld a, (.dmark+2)  
0458 32 a8 fd			ld (debug_mark+2),a  
045b 18 03			jr .pastdmark  
045d ..			.dmark: db "SGe"  
0460 f1			.pastdmark: pop af  
0461			endm  
# End of macro DMARK
0461					CALLMONITOR 
0461 cd aa fd			call debug_vector  
0464				endm  
# End of macro CALLMONITOR
0464				endif 
0464			 
0464 c9				ret 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			; Read Block 
0465			; ---------- 
0465			; 
0465			; With current bank 
0465			;  
0465			; Get block number to read 
0465			; Load physical blocks starting at start block into buffer 
0465			 
0465			; de points to buffer to use 
0465			; hl holds logical block number  
0465			 
0465			storage_read_block: 
0465			 
0465				; TODO bank selection 
0465			 
0465				; for each of the physical blocks read it into the buffer 
0465 06 40			ld b, STORE_BLOCK_PHY 
0467			 
0467				if DEBUG_STORESE 
0467 d5					push de 
0468				endif 
0468				 
0468			.rl1:    
0468			 
0468				; read physical block at hl into de 
0468			        ; increment hl and de to next read position on exit 
0468			 
0468 e5				push hl 
0469 d5				push de	 
046a c5				push bc 
046b			;	if DEBUG_STORESE 
046b			;		push af 
046b			;		ld a, 'R' 
046b			;		ld (debug_mark),a 
046b			;		pop af 
046b			;		CALLMONITOR 
046b			;	endif 
046b cd 0c 03			call se_readbyte 
046e			;	if DEBUG_STORESE 
046e			;		ld a,(spi_portbyte) 
046e			;		ld l, a 
046e			;		push af 
046e			;		ld a, '1' 
046e			;		ld (debug_mark),a 
046e			;		pop af 
046e			;		CALLMONITOR 
046e			;	endif 
046e c1				pop bc 
046f d1				pop de 
0470 e1				pop hl 
0471 12				ld (de),a 
0472 23				inc hl 
0473 13				inc de 
0474			 
0474			;	if DEBUG_STORESE 
0474			;		push af 
0474			;		ld a, 'r' 
0474			;		ld (debug_mark),a 
0474			;		pop af 
0474			;		CALLMONITOR 
0474			;	endif 
0474			 
0474 10 f2			djnz .rl1 
0476			 
0476				if DEBUG_STORESE 
0476					DMARK "SRB" 
0476 f5				push af  
0477 3a 8b 04			ld a, (.dmark)  
047a 32 a6 fd			ld (debug_mark),a  
047d 3a 8c 04			ld a, (.dmark+1)  
0480 32 a7 fd			ld (debug_mark+1),a  
0483 3a 8d 04			ld a, (.dmark+2)  
0486 32 a8 fd			ld (debug_mark+2),a  
0489 18 03			jr .pastdmark  
048b ..			.dmark: db "SRB"  
048e f1			.pastdmark: pop af  
048f			endm  
# End of macro DMARK
048f d1					pop de 
0490			; 
0490			;		push af 
0490			;		ld a, 'R' 
0490			;		ld (debug_mark),a 
0490			;		pop af 
0490					CALLMONITOR 
0490 cd aa fd			call debug_vector  
0493				endm  
# End of macro CALLMONITOR
0493				endif 
0493 c9				ret	 
0494				 
0494			 
0494			; File Size 
0494			; --------- 
0494			; 
0494			;   hl file id 
0494			; 
0494			;  returns in hl the number of blocks 
0494			 
0494			storage_file_size: 
0494 5d				ld e, l 
0495 16 00			ld d, 0 
0497 21 40 00			ld hl, STORE_BLOCK_PHY 
049a					if DEBUG_FORTH_WORDS 
049a						DMARK "SIZ" 
049a f5				push af  
049b 3a af 04			ld a, (.dmark)  
049e 32 a6 fd			ld (debug_mark),a  
04a1 3a b0 04			ld a, (.dmark+1)  
04a4 32 a7 fd			ld (debug_mark+1),a  
04a7 3a b1 04			ld a, (.dmark+2)  
04aa 32 a8 fd			ld (debug_mark+2),a  
04ad 18 03			jr .pastdmark  
04af ..			.dmark: db "SIZ"  
04b2 f1			.pastdmark: pop af  
04b3			endm  
# End of macro DMARK
04b3						CALLMONITOR 
04b3 cd aa fd			call debug_vector  
04b6				endm  
# End of macro CALLMONITOR
04b6					endif 
04b6 cd 98 07			call storage_findnextid 
04b9			 
04b9 cd f8 0f			call ishlzero 
04bc			;	ld a, l 
04bc			;	add h 
04bc			;	cp 0 
04bc c8				ret z			; block not found so EOF 
04bd			 
04bd 11 b5 f9			ld de, store_page 
04c0 cd 65 04			call storage_read_block 
04c3			 
04c3 3a b7 f9			ld a, (store_page+2)	 ; get extent count 
04c6 6f				ld l, a 
04c7 26 00			ld h, 0 
04c9 c9			 	ret 
04ca			 
04ca			 
04ca			; Write Block 
04ca			; ----------- 
04ca			; 
04ca			; With current bank 
04ca			;  
04ca			; Get block number to write 
04ca			; Write physical blocks starting at start block from buffer 
04ca			  
04ca			storage_write_block: 
04ca				; TODO bank selection 
04ca			 
04ca				; for each of the physical blocks read it into the buffer 
04ca 06 40			ld b, STORE_BLOCK_PHY 
04cc			 
04cc				if DEBUG_STORESE 
04cc					DMARK "SWB" 
04cc f5				push af  
04cd 3a e1 04			ld a, (.dmark)  
04d0 32 a6 fd			ld (debug_mark),a  
04d3 3a e2 04			ld a, (.dmark+1)  
04d6 32 a7 fd			ld (debug_mark+1),a  
04d9 3a e3 04			ld a, (.dmark+2)  
04dc 32 a8 fd			ld (debug_mark+2),a  
04df 18 03			jr .pastdmark  
04e1 ..			.dmark: db "SWB"  
04e4 f1			.pastdmark: pop af  
04e5			endm  
# End of macro DMARK
04e5			 
04e5					;push af 
04e5					;ld a, 'W' 
04e5					;ld (debug_mark),a 
04e5					;pop af 
04e5					CALLMONITOR 
04e5 cd aa fd			call debug_vector  
04e8				endm  
# End of macro CALLMONITOR
04e8				endif 
04e8			 
04e8			; might not be working 
04e8			;	call se_writepage 
04e8			 
04e8			;	ret 
04e8			; 
04e8			 
04e8			 
04e8			 
04e8			.wl1:    
04e8			 
04e8				; read physical block at hl into de 
04e8			        ; increment hl and de to next read position on exit 
04e8			 
04e8 e5				push hl 
04e9 d5				push de	 
04ea c5				push bc 
04eb 1a				ld a,(de) 
04ec				;if DEBUG_STORESE 
04ec			;		push af 
04ec			;		ld a, 'W' 
04ec			;		ld (debug_mark),a 
04ec			;		pop af 
04ec			;		CALLMONITOR 
04ec			;	endif 
04ec cd 6a 02			call se_writebyte 
04ef			;	call delay250ms 
04ef 00				nop 
04f0 00				nop 
04f1 00				nop 
04f2			;	if DEBUG_STORESE 
04f2			;		push af 
04f2			;		ld a, 'w' 
04f2			;		ld (debug_mark),a 
04f2			;		pop af 
04f2			;		CALLMONITOR 
04f2			;	endif 
04f2 c1				pop bc 
04f3 d1				pop de 
04f4 e1				pop hl 
04f5 23				inc hl 
04f6 13				inc de 
04f7			 
04f7			 
04f7 10 ef			djnz .wl1 
04f9			 
04f9				if DEBUG_STORESE 
04f9					DMARK "SW2" 
04f9 f5				push af  
04fa 3a 0e 05			ld a, (.dmark)  
04fd 32 a6 fd			ld (debug_mark),a  
0500 3a 0f 05			ld a, (.dmark+1)  
0503 32 a7 fd			ld (debug_mark+1),a  
0506 3a 10 05			ld a, (.dmark+2)  
0509 32 a8 fd			ld (debug_mark+2),a  
050c 18 03			jr .pastdmark  
050e ..			.dmark: db "SW2"  
0511 f1			.pastdmark: pop af  
0512			endm  
# End of macro DMARK
0512			 
0512					;push af 
0512					;ld a, 'W' 
0512					;ld (debug_mark),a 
0512					;pop af 
0512					CALLMONITOR 
0512 cd aa fd			call debug_vector  
0515				endm  
# End of macro CALLMONITOR
0515				endif 
0515 c9				ret	 
0516			 
0516			; Init bank 
0516			; --------- 
0516			; 
0516			; With current bank 
0516			; 
0516			; Setup block 0 config 
0516			;     Set 0 file id counter 
0516			;     Set formatted byte pattern 
0516			;     Zero out bank label 
0516			;      
0516			; For every logical block write 0-1 byte as null 
0516			 
0516			storage_get_block_0: 
0516			 
0516				; TODO check presence 
0516			 
0516				; get block 0 config 
0516			 
0516 21 00 00			ld hl, 0 
0519 11 b5 f9			ld de, store_page 
051c cd 65 04			call storage_read_block 
051f			 
051f				if DEBUG_STORESE 
051f					DMARK "SB0" 
051f f5				push af  
0520 3a 34 05			ld a, (.dmark)  
0523 32 a6 fd			ld (debug_mark),a  
0526 3a 35 05			ld a, (.dmark+1)  
0529 32 a7 fd			ld (debug_mark+1),a  
052c 3a 36 05			ld a, (.dmark+2)  
052f 32 a8 fd			ld (debug_mark+2),a  
0532 18 03			jr .pastdmark  
0534 ..			.dmark: db "SB0"  
0537 f1			.pastdmark: pop af  
0538			endm  
# End of macro DMARK
0538 11 b5 f9				ld de, store_page 
053b			;		push af 
053b			;		ld a, 'i' 
053b			;		ld (debug_mark),a 
053b			;		pop af 
053b					CALLMONITOR 
053b cd aa fd			call debug_vector  
053e				endm  
# End of macro CALLMONITOR
053e				endif 
053e			 
053e				; is this area formatted? 
053e			 
053e			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
053e 2a b6 f9			ld hl, (store_page+1) 
0541 3e 80			ld a,0x80 
0543 bd				cp l 
0544 20 22			jr nz, .ininotformatted 
0546				; do a double check 
0546 3e 27			ld a, 0x27 
0548 bc				cp h 
0549 20 1d			jr nz, .ininotformatted 
054b			 
054b				; formatted then 
054b			 
054b				if DEBUG_STORESE 
054b					DMARK "SB1" 
054b f5				push af  
054c 3a 60 05			ld a, (.dmark)  
054f 32 a6 fd			ld (debug_mark),a  
0552 3a 61 05			ld a, (.dmark+1)  
0555 32 a7 fd			ld (debug_mark+1),a  
0558 3a 62 05			ld a, (.dmark+2)  
055b 32 a8 fd			ld (debug_mark+2),a  
055e 18 03			jr .pastdmark  
0560 ..			.dmark: db "SB1"  
0563 f1			.pastdmark: pop af  
0564			endm  
# End of macro DMARK
0564					;push af 
0564					;ld a, 'I' 
0564					;ld (debug_mark),a 
0564					;pop af 
0564					CALLMONITOR 
0564 cd aa fd			call debug_vector  
0567				endm  
# End of macro CALLMONITOR
0567				endif 
0567 c9				ret 
0568			 
0568			.ininotformatted: 
0568				; bank not formatted so poke various bits to make sure 
0568			 
0568				if DEBUG_STORESE 
0568					DMARK "SB2" 
0568 f5				push af  
0569 3a 7d 05			ld a, (.dmark)  
056c 32 a6 fd			ld (debug_mark),a  
056f 3a 7e 05			ld a, (.dmark+1)  
0572 32 a7 fd			ld (debug_mark+1),a  
0575 3a 7f 05			ld a, (.dmark+2)  
0578 32 a8 fd			ld (debug_mark+2),a  
057b 18 03			jr .pastdmark  
057d ..			.dmark: db "SB2"  
0580 f1			.pastdmark: pop af  
0581			endm  
# End of macro DMARK
0581					;push af 
0581					;ld a, 'f' 
0581					;ld (debug_mark),a 
0581					;pop af 
0581					CALLMONITOR 
0581 cd aa fd			call debug_vector  
0584				endm  
# End of macro CALLMONITOR
0584				endif 
0584			 
0584 cd a1 0c			call storage_clear_page 
0587			 
0587 21 b5 f9			ld hl, store_page 
058a 3e 00			ld a, 0 
058c				 
058c 77				ld (hl),a   ; reset file counter 
058d			 
058d 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0590 22 b6 f9		 	ld (store_page+1), hl	 
0593			 
0593				; set default label 
0593			 
0593 21 2f 06			ld hl, .defaultbanklabl 
0596 11 b8 f9		 	ld de, store_page+3 
0599 01 0f 00			ld bc, 15 
059c ed b0			ldir 
059e			 
059e				; Append the current bank id 
059e 21 c1 f9			ld hl, store_page+3+9 
05a1 3a 9a f9			ld a, (spi_device_id) 
05a4 77				ld (hl), a 
05a5			 
05a5				; save default page 0 
05a5			 
05a5 21 00 00			ld hl, 0 
05a8 11 b5 f9			ld de, store_page 
05ab				if DEBUG_STORESE 
05ab					DMARK "SB3" 
05ab f5				push af  
05ac 3a c0 05			ld a, (.dmark)  
05af 32 a6 fd			ld (debug_mark),a  
05b2 3a c1 05			ld a, (.dmark+1)  
05b5 32 a7 fd			ld (debug_mark+1),a  
05b8 3a c2 05			ld a, (.dmark+2)  
05bb 32 a8 fd			ld (debug_mark+2),a  
05be 18 03			jr .pastdmark  
05c0 ..			.dmark: db "SB3"  
05c3 f1			.pastdmark: pop af  
05c4			endm  
# End of macro DMARK
05c4			;		push af 
05c4			;		ld a, 'F' 
05c4			;		ld (debug_mark),a 
05c4			;		pop af 
05c4					CALLMONITOR 
05c4 cd aa fd			call debug_vector  
05c7				endm  
# End of macro CALLMONITOR
05c7				endif 
05c7 cd ca 04			call storage_write_block 
05ca				if DEBUG_STORESE 
05ca					DMARK "SB4" 
05ca f5				push af  
05cb 3a df 05			ld a, (.dmark)  
05ce 32 a6 fd			ld (debug_mark),a  
05d1 3a e0 05			ld a, (.dmark+1)  
05d4 32 a7 fd			ld (debug_mark+1),a  
05d7 3a e1 05			ld a, (.dmark+2)  
05da 32 a8 fd			ld (debug_mark+2),a  
05dd 18 03			jr .pastdmark  
05df ..			.dmark: db "SB4"  
05e2 f1			.pastdmark: pop af  
05e3			endm  
# End of macro DMARK
05e3			;		push af 
05e3			;		ld a, '>' 
05e3			;		ld (debug_mark),a 
05e3			;		pop af 
05e3					CALLMONITOR 
05e3 cd aa fd			call debug_vector  
05e6				endm  
# End of macro CALLMONITOR
05e6				endif 
05e6			 
05e6 00				nop 
05e7 00				nop 
05e8 00				nop 
05e9			 
05e9				; now set 0 in every page to mark as a free block 
05e9			 
05e9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05eb 21 40 00			ld hl, STORE_BLOCK_PHY 
05ee			 
05ee 3e 00		.setmark1:   	ld a,0 
05f0 e5					push hl 
05f1 c5					push bc 
05f2 cd 6a 02				call se_writebyte 
05f5 3e 0a			ld a, 10 
05f7 cd c3 0c			call aDelayInMS 
05fa 23				inc hl 
05fb cd 6a 02				call se_writebyte 
05fe 3e 0a			ld a, 10 
0600 cd c3 0c			call aDelayInMS 
0603 2b				dec hl 
0604 c1					pop bc 
0605 e1					pop hl 
0606 3e 40				ld a, STORE_BLOCK_PHY 
0608 cd cf 0f				call addatohl 
060b 10 e1				djnz .setmark1 
060d			 
060d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
060f 3e 00		.setmark2:   	ld a,0 
0611 e5					push hl 
0612 c5					push bc 
0613 cd 6a 02				call se_writebyte 
0616 3e 0a			ld a, 10 
0618 cd c3 0c			call aDelayInMS 
061b 23				inc hl 
061c cd 6a 02				call se_writebyte 
061f 3e 0a			ld a, 10 
0621 cd c3 0c			call aDelayInMS 
0624 2b				dec hl 
0625 c1					pop bc 
0626 e1					pop hl 
0627 3e 40				ld a, STORE_BLOCK_PHY 
0629 cd cf 0f				call addatohl 
062c 10 e1				djnz .setmark2 
062e			 
062e					 
062e			 
062e			 
062e c9				ret 
062f			 
062f			 
062f			 
062f			 
062f .. 00		.defaultbanklabl:   db "BankLabel_",0 
063a			 
063a			 
063a			 
063a			; Label Bank 
063a			; ---------- 
063a			; 
063a			; With current bank 
063a			; Read block 0 
063a			; Set label 
063a			; Write block 0 
063a			 
063a			; label str pointer in hl 
063a			 
063a			storage_label:     
063a			 
063a				if DEBUG_STORESE 
063a					DMARK "LBL" 
063a f5				push af  
063b 3a 4f 06			ld a, (.dmark)  
063e 32 a6 fd			ld (debug_mark),a  
0641 3a 50 06			ld a, (.dmark+1)  
0644 32 a7 fd			ld (debug_mark+1),a  
0647 3a 51 06			ld a, (.dmark+2)  
064a 32 a8 fd			ld (debug_mark+2),a  
064d 18 03			jr .pastdmark  
064f ..			.dmark: db "LBL"  
0652 f1			.pastdmark: pop af  
0653			endm  
# End of macro DMARK
0653					CALLMONITOR 
0653 cd aa fd			call debug_vector  
0656				endm  
# End of macro CALLMONITOR
0656				endif 
0656			 
0656 e5				push hl 
0657			 
0657 cd 16 05			call storage_get_block_0 
065a			 
065a				; set default label 
065a			 
065a e1				pop hl 
065b			 
065b 11 b8 f9		 	ld de, store_page+3 
065e 01 0f 00			ld bc, 15 
0661				if DEBUG_STORESE 
0661					DMARK "LB3" 
0661 f5				push af  
0662 3a 76 06			ld a, (.dmark)  
0665 32 a6 fd			ld (debug_mark),a  
0668 3a 77 06			ld a, (.dmark+1)  
066b 32 a7 fd			ld (debug_mark+1),a  
066e 3a 78 06			ld a, (.dmark+2)  
0671 32 a8 fd			ld (debug_mark+2),a  
0674 18 03			jr .pastdmark  
0676 ..			.dmark: db "LB3"  
0679 f1			.pastdmark: pop af  
067a			endm  
# End of macro DMARK
067a					CALLMONITOR 
067a cd aa fd			call debug_vector  
067d				endm  
# End of macro CALLMONITOR
067d				endif 
067d ed b0			ldir 
067f				; save default page 0 
067f			 
067f 21 00 00			ld hl, 0 
0682 11 b5 f9			ld de, store_page 
0685				if DEBUG_STORESE 
0685					DMARK "LBW" 
0685 f5				push af  
0686 3a 9a 06			ld a, (.dmark)  
0689 32 a6 fd			ld (debug_mark),a  
068c 3a 9b 06			ld a, (.dmark+1)  
068f 32 a7 fd			ld (debug_mark+1),a  
0692 3a 9c 06			ld a, (.dmark+2)  
0695 32 a8 fd			ld (debug_mark+2),a  
0698 18 03			jr .pastdmark  
069a ..			.dmark: db "LBW"  
069d f1			.pastdmark: pop af  
069e			endm  
# End of macro DMARK
069e					CALLMONITOR 
069e cd aa fd			call debug_vector  
06a1				endm  
# End of macro CALLMONITOR
06a1				endif 
06a1 cd ca 04			call storage_write_block 
06a4			 
06a4 c9				ret 
06a5			 
06a5			 
06a5			 
06a5			; Read Block 0 - Config 
06a5			; --------------------- 
06a5			; 
06a5			; With current bank 
06a5			; Call presence test 
06a5			;    If not present format/init bank  
06a5			; Read block 0  
06a5			;  
06a5			 
06a5			 
06a5			; Dir 
06a5			; --- 
06a5			; 
06a5			; With current bank 
06a5			; Load Block 0 Config 
06a5			; Get max file id number 
06a5			; For each logical block 
06a5			;    Read block read byte 2 
06a5			;      if first block of file 
06a5			;         Display file name 
06a5			;         Display type flags for file 
06a5			;        
06a5			 
06a5			; moving to words as this requires stack control 
06a5			 
06a5			 
06a5			; Delete File 
06a5			; ----------- 
06a5			; 
06a5			; With current bank 
06a5			; 
06a5			; Load Block 0 Config 
06a5			; Get max file id number 
06a5			; For each logical block 
06a5			;    Read block file id 
06a5			;      If first block of file and dont have file id 
06a5			;         if file to delete 
06a5			;         Save file id 
06a5			;         Null file id 
06a5			;         Write this block back 
06a5			;      If file id is one saved 
06a5			;         Null file id 
06a5			;         Write this block back 
06a5			 
06a5			 
06a5			.se_done: 
06a5 e1				pop hl 
06a6 c9				ret 
06a7			 
06a7			storage_erase: 
06a7			 
06a7				; hl contains the file id 
06a7			 
06a7 5d				ld e, l 
06a8 16 00			ld d, 0 
06aa 21 40 00			ld hl, STORE_BLOCK_PHY 
06ad					if DEBUG_FORTH_WORDS 
06ad						DMARK "ERA" 
06ad f5				push af  
06ae 3a c2 06			ld a, (.dmark)  
06b1 32 a6 fd			ld (debug_mark),a  
06b4 3a c3 06			ld a, (.dmark+1)  
06b7 32 a7 fd			ld (debug_mark+1),a  
06ba 3a c4 06			ld a, (.dmark+2)  
06bd 32 a8 fd			ld (debug_mark+2),a  
06c0 18 03			jr .pastdmark  
06c2 ..			.dmark: db "ERA"  
06c5 f1			.pastdmark: pop af  
06c6			endm  
# End of macro DMARK
06c6						CALLMONITOR 
06c6 cd aa fd			call debug_vector  
06c9				endm  
# End of macro CALLMONITOR
06c9					endif 
06c9 cd 98 07			call storage_findnextid 
06cc cd f8 0f			call ishlzero 
06cf c8				ret z 
06d0			 
06d0 e5				push hl 
06d1			 
06d1				; TODO check file not found 
06d1			 
06d1 11 b5 f9			ld de, store_page 
06d4 cd 65 04			call storage_read_block 
06d7			 
06d7 cd f8 0f			call ishlzero 
06da ca a5 06			jp z,.se_done 
06dd			 
06dd					if DEBUG_FORTH_WORDS 
06dd						DMARK "ER1" 
06dd f5				push af  
06de 3a f2 06			ld a, (.dmark)  
06e1 32 a6 fd			ld (debug_mark),a  
06e4 3a f3 06			ld a, (.dmark+1)  
06e7 32 a7 fd			ld (debug_mark+1),a  
06ea 3a f4 06			ld a, (.dmark+2)  
06ed 32 a8 fd			ld (debug_mark+2),a  
06f0 18 03			jr .pastdmark  
06f2 ..			.dmark: db "ER1"  
06f5 f1			.pastdmark: pop af  
06f6			endm  
# End of macro DMARK
06f6						CALLMONITOR 
06f6 cd aa fd			call debug_vector  
06f9				endm  
# End of macro CALLMONITOR
06f9					endif 
06f9 3a b5 f9			ld a, (store_page)	; get file id 
06fc 32 a9 f9			ld (store_tmpid), a 
06ff			 
06ff 3a b7 f9			ld a, (store_page+2)    ; get count of extends 
0702 32 a8 f9			ld (store_tmpext), a 
0705			 
0705				; wipe file header 
0705			 
0705 e1				pop hl 
0706 3e 00			ld a, 0 
0708 32 b5 f9			ld (store_page), a 
070b 32 b6 f9			ld (store_page+1),a 
070e 11 b5 f9			ld de, store_page 
0711					if DEBUG_FORTH_WORDS 
0711						DMARK "ER2" 
0711 f5				push af  
0712 3a 26 07			ld a, (.dmark)  
0715 32 a6 fd			ld (debug_mark),a  
0718 3a 27 07			ld a, (.dmark+1)  
071b 32 a7 fd			ld (debug_mark+1),a  
071e 3a 28 07			ld a, (.dmark+2)  
0721 32 a8 fd			ld (debug_mark+2),a  
0724 18 03			jr .pastdmark  
0726 ..			.dmark: db "ER2"  
0729 f1			.pastdmark: pop af  
072a			endm  
# End of macro DMARK
072a						CALLMONITOR 
072a cd aa fd			call debug_vector  
072d				endm  
# End of macro CALLMONITOR
072d					endif 
072d cd ca 04			call storage_write_block 
0730			 
0730			 
0730				; wipe file extents 
0730			 
0730 3a a8 f9			ld a, (store_tmpext) 
0733 47				ld b, a 
0734			 
0734			.eraext:	  
0734 c5				push bc 
0735			 
0735 21 40 00			ld hl, STORE_BLOCK_PHY 
0738 3a a9 f9			ld a,(store_tmpid) 
073b 5f				ld e, a 
073c 50				ld d, b	 
073d					if DEBUG_FORTH_WORDS 
073d						DMARK "ER3" 
073d f5				push af  
073e 3a 52 07			ld a, (.dmark)  
0741 32 a6 fd			ld (debug_mark),a  
0744 3a 53 07			ld a, (.dmark+1)  
0747 32 a7 fd			ld (debug_mark+1),a  
074a 3a 54 07			ld a, (.dmark+2)  
074d 32 a8 fd			ld (debug_mark+2),a  
0750 18 03			jr .pastdmark  
0752 ..			.dmark: db "ER3"  
0755 f1			.pastdmark: pop af  
0756			endm  
# End of macro DMARK
0756						CALLMONITOR 
0756 cd aa fd			call debug_vector  
0759				endm  
# End of macro CALLMONITOR
0759					endif 
0759 cd 98 07			call storage_findnextid 
075c cd f8 0f			call ishlzero 
075f ca a5 06			jp z,.se_done 
0762			 
0762 e5				push hl 
0763 11 b5 f9			ld de, store_page 
0766 cd 65 04			call storage_read_block 
0769			 
0769				; free block	 
0769			 
0769 3e 00			ld a, 0 
076b 32 b5 f9			ld (store_page), a 
076e 32 b6 f9			ld (store_page+1),a 
0771 11 b5 f9			ld de, store_page 
0774 e1				pop hl 
0775					if DEBUG_FORTH_WORDS 
0775						DMARK "ER4" 
0775 f5				push af  
0776 3a 8a 07			ld a, (.dmark)  
0779 32 a6 fd			ld (debug_mark),a  
077c 3a 8b 07			ld a, (.dmark+1)  
077f 32 a7 fd			ld (debug_mark+1),a  
0782 3a 8c 07			ld a, (.dmark+2)  
0785 32 a8 fd			ld (debug_mark+2),a  
0788 18 03			jr .pastdmark  
078a ..			.dmark: db "ER4"  
078d f1			.pastdmark: pop af  
078e			endm  
# End of macro DMARK
078e						CALLMONITOR 
078e cd aa fd			call debug_vector  
0791				endm  
# End of macro CALLMONITOR
0791					endif 
0791 cd ca 04			call storage_write_block 
0794			 
0794 c1				pop bc 
0795 10 9d			djnz .eraext 
0797			 
0797 c9				ret 
0798			 
0798			 
0798			; Find Free Block 
0798			; --------------- 
0798			; 
0798			; With current bank 
0798			;  
0798			; From given starting logical block 
0798			;    Read block  
0798			;    If no file id 
0798			;         Return block id 
0798			 
0798			 
0798			; hl starting page number 
0798			; hl contains free page number or zero if no pages free 
0798			; e contains the file id to locate 
0798			; d contains the block number 
0798			 
0798			; TODO change to find file id and use zero for free block 
0798			 
0798			storage_findnextid: 
0798			 
0798				; now locate first 0 page to mark as a free block 
0798			 
0798 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
079a			;	ld hl, STORE_BLOCK_PHY 
079a			 
079a					if DEBUG_FORTH_WORDS 
079a					DMARK "FNI" 
079a f5				push af  
079b 3a af 07			ld a, (.dmark)  
079e 32 a6 fd			ld (debug_mark),a  
07a1 3a b0 07			ld a, (.dmark+1)  
07a4 32 a7 fd			ld (debug_mark+1),a  
07a7 3a b1 07			ld a, (.dmark+2)  
07aa 32 a8 fd			ld (debug_mark+2),a  
07ad 18 03			jr .pastdmark  
07af ..			.dmark: db "FNI"  
07b2 f1			.pastdmark: pop af  
07b3			endm  
# End of macro DMARK
07b3						CALLMONITOR 
07b3 cd aa fd			call debug_vector  
07b6				endm  
# End of macro CALLMONITOR
07b6					endif 
07b6			.ff1:   	 
07b6 e5					push hl 
07b7 c5					push bc 
07b8 d5					push de 
07b9 cd 0c 03				call se_readbyte 
07bc 5f					ld e,a 
07bd 23					inc hl 
07be cd 0c 03				call se_readbyte 
07c1 57					ld d, a 
07c2 e1					pop hl 
07c3 e5					push hl 
07c4 cd ed 0f				call cmp16 
07c7 28 49				jr z, .fffound 
07c9			 
07c9 d1					pop de 
07ca c1					pop bc 
07cb e1					pop hl 
07cc			 
07cc					; is found? 
07cc					;cp e 
07cc					;ret z 
07cc			 
07cc 3e 40				ld a, STORE_BLOCK_PHY 
07ce cd cf 0f				call addatohl 
07d1 10 e3				djnz .ff1 
07d3			 
07d3 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07d5			.ff2:   	 
07d5			 
07d5 e5					push hl 
07d6 c5					push bc 
07d7 d5					push de 
07d8 cd 0c 03				call se_readbyte 
07db 5f					ld e,a 
07dc 23					inc hl 
07dd cd 0c 03				call se_readbyte 
07e0 57					ld d, a 
07e1			 
07e1 e1					pop hl 
07e2 e5					push hl 
07e3 cd ed 0f				call cmp16 
07e6 28 2a				jr z, .fffound 
07e8			 
07e8 d1					pop de 
07e9 c1					pop bc 
07ea e1					pop hl 
07eb					; is found? 
07eb					;cp e 
07eb					;ret z 
07eb			 
07eb 3e 40				ld a, STORE_BLOCK_PHY 
07ed cd cf 0f				call addatohl 
07f0 10 e3				djnz .ff2 
07f2			 
07f2			 
07f2					if DEBUG_FORTH_WORDS 
07f2					DMARK "FN-" 
07f2 f5				push af  
07f3 3a 07 08			ld a, (.dmark)  
07f6 32 a6 fd			ld (debug_mark),a  
07f9 3a 08 08			ld a, (.dmark+1)  
07fc 32 a7 fd			ld (debug_mark+1),a  
07ff 3a 09 08			ld a, (.dmark+2)  
0802 32 a8 fd			ld (debug_mark+2),a  
0805 18 03			jr .pastdmark  
0807 ..			.dmark: db "FN-"  
080a f1			.pastdmark: pop af  
080b			endm  
# End of macro DMARK
080b					;	push af 
080b					;	ld a, 'n' 
080b					;	ld (debug_mark),a 
080b					;	pop af 
080b						CALLMONITOR 
080b cd aa fd			call debug_vector  
080e				endm  
# End of macro CALLMONITOR
080e					endif 
080e				; no free marks! 
080e 21 00 00				ld hl, 0 
0811 c9				ret 
0812			.fffound: 
0812				 
0812			 
0812 d1					pop de 
0813 c1					pop bc 
0814 e1					pop hl 
0815					if DEBUG_FORTH_WORDS 
0815					DMARK "FNF" 
0815 f5				push af  
0816 3a 2a 08			ld a, (.dmark)  
0819 32 a6 fd			ld (debug_mark),a  
081c 3a 2b 08			ld a, (.dmark+1)  
081f 32 a7 fd			ld (debug_mark+1),a  
0822 3a 2c 08			ld a, (.dmark+2)  
0825 32 a8 fd			ld (debug_mark+2),a  
0828 18 03			jr .pastdmark  
082a ..			.dmark: db "FNF"  
082d f1			.pastdmark: pop af  
082e			endm  
# End of macro DMARK
082e					;	push af 
082e					;	ld a, 'n' 
082e					;	ld (debug_mark),a 
082e					;	pop af 
082e						CALLMONITOR 
082e cd aa fd			call debug_vector  
0831				endm  
# End of macro CALLMONITOR
0831					endif 
0831 c9				ret 
0832			 
0832			 
0832			 
0832			; Free Space 
0832			; ---------- 
0832			; 
0832			; With current bank 
0832			; 
0832			; Set block count to zero 
0832			; Starting with first logical block 
0832			;      Find free block  
0832			;      If block id given, increment block count 
0832			; 
0832			;  
0832			 
0832			 
0832			; hl contains count of free blocks 
0832			 
0832			storage_freeblocks: 
0832			 
0832				; now locate first 0 page to mark as a free block 
0832			 
0832 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0834 21 40 00			ld hl, STORE_BLOCK_PHY 
0837 11 00 00			ld de, 0 
083a			 
083a			.fb1:   	 
083a e5					push hl 
083b c5					push bc 
083c d5					push de 
083d cd 0c 03				call se_readbyte 
0840 d1					pop de 
0841 c1					pop bc 
0842 e1					pop hl 
0843			 
0843					; is free? 
0843 fe 00				cp 0 
0845 20 01				jr nz, .ff1cont 
0847 13					inc de 
0848			 
0848			.ff1cont: 
0848			 
0848			 
0848 3e 40				ld a, STORE_BLOCK_PHY 
084a cd cf 0f				call addatohl 
084d 10 eb				djnz .fb1 
084f			 
084f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0851			.fb2:   	 
0851 e5					push hl 
0852 c5					push bc 
0853 d5					push de 
0854 cd 0c 03				call se_readbyte 
0857 d1					pop de 
0858 c1					pop bc 
0859 e1					pop hl 
085a			 
085a					; is free? 
085a fe 00				cp 0 
085c 20 01				jr nz, .ff2cont 
085e 13					inc de 
085f			 
085f			.ff2cont: 
085f			 
085f 3e 40				ld a, STORE_BLOCK_PHY 
0861 cd cf 0f				call addatohl 
0864 10 eb				djnz .fb2 
0866			 
0866 eb				ex de, hl 
0867 c9				ret 
0868			 
0868			; Get File ID 
0868			; ----------- 
0868			; 
0868			; With current bank 
0868			;  
0868			; Load Block 0 Config 
0868			; Get max file id number 
0868			; For each logical block 
0868			;    Read block file id 
0868			;      If first block of file and dont have file id 
0868			;         if file get id and exit 
0868			 
0868			 
0868			 
0868			 
0868			; Create File 
0868			; ----------- 
0868			; 
0868			; With current bank  
0868			; Load Block 0 Config 
0868			; Get max file id number 
0868			; Increment file id number 
0868			; Save Config 
0868			; Find free block 
0868			; Set buffer with file name and file id 
0868			; Write buffer to free block  
0868			 
0868			 
0868			; hl point to file name 
0868			; hl returns file id 
0868			 
0868			; file format: 
0868			; byte 0 - file id 
0868			; byte 1 - extent number 
0868			; byte 2-> data 
0868			 
0868			; format for extent number 0: 
0868			; 
0868			; byte 0 - file id 
0868			; byte 1 - extent 0 
0868			; byte 2 - extent count 
0868			; byte 3 -> file name and meta data 
0868			 
0868			 
0868			storage_create: 
0868				if DEBUG_STORESE 
0868					DMARK "SCR" 
0868 f5				push af  
0869 3a 7d 08			ld a, (.dmark)  
086c 32 a6 fd			ld (debug_mark),a  
086f 3a 7e 08			ld a, (.dmark+1)  
0872 32 a7 fd			ld (debug_mark+1),a  
0875 3a 7f 08			ld a, (.dmark+2)  
0878 32 a8 fd			ld (debug_mark+2),a  
087b 18 03			jr .pastdmark  
087d ..			.dmark: db "SCR"  
0880 f1			.pastdmark: pop af  
0881			endm  
# End of macro DMARK
0881					CALLMONITOR 
0881 cd aa fd			call debug_vector  
0884				endm  
# End of macro CALLMONITOR
0884				endif 
0884			 
0884 e5				push hl		; save file name pointer 
0885			 
0885 cd 16 05			call storage_get_block_0 
0888			 
0888 3a b5 f9			ld a,(store_page)	; get current file id 
088b 3c				inc a 
088c 32 b5 f9			ld (store_page),a 
088f				 
088f 32 a9 f9			ld (store_tmpid),a			; save id 
0892			 
0892 21 00 00			ld hl, 0 
0895 11 b5 f9			ld de, store_page 
0898				if DEBUG_STORESE 
0898					DMARK "SCw" 
0898 f5				push af  
0899 3a ad 08			ld a, (.dmark)  
089c 32 a6 fd			ld (debug_mark),a  
089f 3a ae 08			ld a, (.dmark+1)  
08a2 32 a7 fd			ld (debug_mark+1),a  
08a5 3a af 08			ld a, (.dmark+2)  
08a8 32 a8 fd			ld (debug_mark+2),a  
08ab 18 03			jr .pastdmark  
08ad ..			.dmark: db "SCw"  
08b0 f1			.pastdmark: pop af  
08b1			endm  
# End of macro DMARK
08b1					CALLMONITOR 
08b1 cd aa fd			call debug_vector  
08b4				endm  
# End of macro CALLMONITOR
08b4				endif 
08b4 cd ca 04			call storage_write_block	 ; save update 
08b7			 
08b7				if DEBUG_STORESE 
08b7 11 b5 f9				ld de, store_page 
08ba					DMARK "SCC" 
08ba f5				push af  
08bb 3a cf 08			ld a, (.dmark)  
08be 32 a6 fd			ld (debug_mark),a  
08c1 3a d0 08			ld a, (.dmark+1)  
08c4 32 a7 fd			ld (debug_mark+1),a  
08c7 3a d1 08			ld a, (.dmark+2)  
08ca 32 a8 fd			ld (debug_mark+2),a  
08cd 18 03			jr .pastdmark  
08cf ..			.dmark: db "SCC"  
08d2 f1			.pastdmark: pop af  
08d3			endm  
# End of macro DMARK
08d3					CALLMONITOR 
08d3 cd aa fd			call debug_vector  
08d6				endm  
# End of macro CALLMONITOR
08d6				endif 
08d6				;  
08d6				 
08d6 21 40 00			ld hl, STORE_BLOCK_PHY 
08d9 11 00 00			ld de, 0 
08dc cd 98 07			call storage_findnextid 
08df			 
08df 22 a0 f9			ld (store_tmppageid), hl    ; save page to use  
08e2			 
08e2				; TODO detect 0 = no spare blocks 
08e2			 
08e2				; hl now contains the free page to use for the file header page 
08e2			 
08e2				if DEBUG_STORESE 
08e2				DMARK "SCF" 
08e2 f5				push af  
08e3 3a f7 08			ld a, (.dmark)  
08e6 32 a6 fd			ld (debug_mark),a  
08e9 3a f8 08			ld a, (.dmark+1)  
08ec 32 a7 fd			ld (debug_mark+1),a  
08ef 3a f9 08			ld a, (.dmark+2)  
08f2 32 a8 fd			ld (debug_mark+2),a  
08f5 18 03			jr .pastdmark  
08f7 ..			.dmark: db "SCF"  
08fa f1			.pastdmark: pop af  
08fb			endm  
# End of macro DMARK
08fb					CALLMONITOR 
08fb cd aa fd			call debug_vector  
08fe				endm  
# End of macro CALLMONITOR
08fe				endif 
08fe			 
08fe 22 a0 f9			ld (store_tmppageid), hl 
0901				 
0901 3a a9 f9			ld a,(store_tmpid)    ; get file id 
0904			;	ld a, (store_filecache)			; save to cache 
0904			 
0904 32 b5 f9			ld (store_page),a    ; set page id 
0907 3e 00			ld a, 0			 ; extent 0 is file header 
0909 32 b6 f9			ld (store_page+1), a   ; set file extent 
090c			 
090c 32 b7 f9			ld (store_page+2), a   ; extent count for the file 
090f			 
090f			;	inc hl 		; init block 0 of file 
090f			;	inc hl   		; skip file and extent id 
090f			 ;       ld a, 0 
090f			;	ld (hl),a 
090f			;	ld a, (store_filecache+1)  	; save to cache 
090f			 
090f			;	inc hl    ; file name 
090f				 
090f				 
090f 11 b8 f9			ld de, store_page+3    ; get buffer for term string to use as file name 
0912				if DEBUG_STORESE 
0912					DMARK "SCc" 
0912 f5				push af  
0913 3a 27 09			ld a, (.dmark)  
0916 32 a6 fd			ld (debug_mark),a  
0919 3a 28 09			ld a, (.dmark+1)  
091c 32 a7 fd			ld (debug_mark+1),a  
091f 3a 29 09			ld a, (.dmark+2)  
0922 32 a8 fd			ld (debug_mark+2),a  
0925 18 03			jr .pastdmark  
0927 ..			.dmark: db "SCc"  
092a f1			.pastdmark: pop af  
092b			endm  
# End of macro DMARK
092b					CALLMONITOR 
092b cd aa fd			call debug_vector  
092e				endm  
# End of macro CALLMONITOR
092e				endif 
092e e1				pop hl    ; get zero term string 
092f e5				push hl 
0930 3e 00			ld a, 0 
0932 cd 91 13			call strlent 
0935 23				inc hl   ; cover zero term 
0936 06 00			ld b,0 
0938 4d				ld c,l 
0939 e1				pop hl 
093a				;ex de, hl 
093a				if DEBUG_STORESE 
093a					DMARK "SCa" 
093a f5				push af  
093b 3a 4f 09			ld a, (.dmark)  
093e 32 a6 fd			ld (debug_mark),a  
0941 3a 50 09			ld a, (.dmark+1)  
0944 32 a7 fd			ld (debug_mark+1),a  
0947 3a 51 09			ld a, (.dmark+2)  
094a 32 a8 fd			ld (debug_mark+2),a  
094d 18 03			jr .pastdmark  
094f ..			.dmark: db "SCa"  
0952 f1			.pastdmark: pop af  
0953			endm  
# End of macro DMARK
0953					;push af 
0953					;ld a, 'a' 
0953					;ld (debug_mark),a 
0953					;pop af 
0953					CALLMONITOR 
0953 cd aa fd			call debug_vector  
0956				endm  
# End of macro CALLMONITOR
0956				endif 
0956 ed b0			ldir    ; copy zero term string 
0958				if DEBUG_STORESE 
0958					DMARK "SCA" 
0958 f5				push af  
0959 3a 6d 09			ld a, (.dmark)  
095c 32 a6 fd			ld (debug_mark),a  
095f 3a 6e 09			ld a, (.dmark+1)  
0962 32 a7 fd			ld (debug_mark+1),a  
0965 3a 6f 09			ld a, (.dmark+2)  
0968 32 a8 fd			ld (debug_mark+2),a  
096b 18 03			jr .pastdmark  
096d ..			.dmark: db "SCA"  
0970 f1			.pastdmark: pop af  
0971			endm  
# End of macro DMARK
0971					CALLMONITOR 
0971 cd aa fd			call debug_vector  
0974				endm  
# End of macro CALLMONITOR
0974				endif 
0974			 
0974				; write file header page 
0974			 
0974 2a a0 f9			ld hl,(store_tmppageid) 
0977 11 b5 f9			ld de, store_page 
097a				if DEBUG_STORESE 
097a					DMARK "SCb" 
097a f5				push af  
097b 3a 8f 09			ld a, (.dmark)  
097e 32 a6 fd			ld (debug_mark),a  
0981 3a 90 09			ld a, (.dmark+1)  
0984 32 a7 fd			ld (debug_mark+1),a  
0987 3a 91 09			ld a, (.dmark+2)  
098a 32 a8 fd			ld (debug_mark+2),a  
098d 18 03			jr .pastdmark  
098f ..			.dmark: db "SCb"  
0992 f1			.pastdmark: pop af  
0993			endm  
# End of macro DMARK
0993					;push af 
0993					;ld a, 'b' 
0993					;ld (debug_mark),a 
0993					;pop af 
0993					CALLMONITOR 
0993 cd aa fd			call debug_vector  
0996				endm  
# End of macro CALLMONITOR
0996				endif 
0996 cd ca 04			call storage_write_block 
0999			 
0999 3a a9 f9			ld a, (store_tmpid) 
099c 6f				ld l, a 
099d 26 00			ld h,0 
099f				if DEBUG_STORESE 
099f					DMARK "SCz" 
099f f5				push af  
09a0 3a b4 09			ld a, (.dmark)  
09a3 32 a6 fd			ld (debug_mark),a  
09a6 3a b5 09			ld a, (.dmark+1)  
09a9 32 a7 fd			ld (debug_mark+1),a  
09ac 3a b6 09			ld a, (.dmark+2)  
09af 32 a8 fd			ld (debug_mark+2),a  
09b2 18 03			jr .pastdmark  
09b4 ..			.dmark: db "SCz"  
09b7 f1			.pastdmark: pop af  
09b8			endm  
# End of macro DMARK
09b8					CALLMONITOR 
09b8 cd aa fd			call debug_vector  
09bb				endm  
# End of macro CALLMONITOR
09bb				endif 
09bb c9				ret 
09bc				 
09bc			 
09bc			 
09bc			; 
09bc			; Read File 
09bc			; 
09bc			; h - file id to locate 
09bc			; l - extent to locate 
09bc			; de - pointer to string to read into 
09bc			; 
09bc			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09bc			 
09bc			.sr_fail: 
09bc d1				pop de 
09bd c9				ret 
09be			 
09be			storage_read: 
09be			 
09be			 
09be d5				push de 
09bf			 
09bf			; TODO BUG the above push is it popped before the RET Z? 
09bf			 
09bf			; TODO how to handle multiple part blocks 
09bf			 
09bf				; locate file extent to read 
09bf			 
09bf 5c				ld e, h 
09c0 55				ld d, l 
09c1			 
09c1			.srext: 
09c1 22 b3 f9			ld (store_readptr), hl     ; save the current extent to load 
09c4 ed 53 b1 f9		ld (store_readbuf), de     ; save the current buffer to load in to 
09c8			 
09c8 21 40 00			ld hl, STORE_BLOCK_PHY 
09cb				if DEBUG_STORESE 
09cb					DMARK "sre" 
09cb f5				push af  
09cc 3a e0 09			ld a, (.dmark)  
09cf 32 a6 fd			ld (debug_mark),a  
09d2 3a e1 09			ld a, (.dmark+1)  
09d5 32 a7 fd			ld (debug_mark+1),a  
09d8 3a e2 09			ld a, (.dmark+2)  
09db 32 a8 fd			ld (debug_mark+2),a  
09de 18 03			jr .pastdmark  
09e0 ..			.dmark: db "sre"  
09e3 f1			.pastdmark: pop af  
09e4			endm  
# End of macro DMARK
09e4					CALLMONITOR 
09e4 cd aa fd			call debug_vector  
09e7				endm  
# End of macro CALLMONITOR
09e7				endif 
09e7 cd 98 07			call storage_findnextid 
09ea			 
09ea				if DEBUG_STORESE 
09ea					DMARK "srf" 
09ea f5				push af  
09eb 3a ff 09			ld a, (.dmark)  
09ee 32 a6 fd			ld (debug_mark),a  
09f1 3a 00 0a			ld a, (.dmark+1)  
09f4 32 a7 fd			ld (debug_mark+1),a  
09f7 3a 01 0a			ld a, (.dmark+2)  
09fa 32 a8 fd			ld (debug_mark+2),a  
09fd 18 03			jr .pastdmark  
09ff ..			.dmark: db "srf"  
0a02 f1			.pastdmark: pop af  
0a03			endm  
# End of macro DMARK
0a03					CALLMONITOR 
0a03 cd aa fd			call debug_vector  
0a06				endm  
# End of macro CALLMONITOR
0a06				endif 
0a06 cd f8 0f			call ishlzero 
0a09			;	ld a, l 
0a09			;	add h 
0a09			;	cp 0 
0a09 28 b1			jr z,.sr_fail			; block not found so EOF 
0a0b			 
0a0b				; save current address for use by higher level words etc 
0a0b			 
0a0b 22 a6 f9			ld (store_openaddr),hl 
0a0e			 
0a0e			 
0a0e				; hl contains page number to load 
0a0e d1				pop de   ; get storage 
0a0f ed 53 b1 f9		ld (store_readbuf), de     ; current buffer to load in to 
0a13 d5				push de 
0a14				if DEBUG_STORESE 
0a14					DMARK "srg" 
0a14 f5				push af  
0a15 3a 29 0a			ld a, (.dmark)  
0a18 32 a6 fd			ld (debug_mark),a  
0a1b 3a 2a 0a			ld a, (.dmark+1)  
0a1e 32 a7 fd			ld (debug_mark+1),a  
0a21 3a 2b 0a			ld a, (.dmark+2)  
0a24 32 a8 fd			ld (debug_mark+2),a  
0a27 18 03			jr .pastdmark  
0a29 ..			.dmark: db "srg"  
0a2c f1			.pastdmark: pop af  
0a2d			endm  
# End of macro DMARK
0a2d					CALLMONITOR 
0a2d cd aa fd			call debug_vector  
0a30				endm  
# End of macro CALLMONITOR
0a30				endif 
0a30 cd 65 04			call storage_read_block 
0a33			 
0a33				; if this a continuation read??? 
0a33			 
0a33 2a b1 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a36			 
0a36 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a38 cd cf 0f			call addatohl 
0a3b 7e				ld a,(hl) 
0a3c fe 00			cp 0 
0a3e 28 02			jr z, .markiscont 
0a40 3e ff			ld a, 255 
0a42			 
0a42			.markiscont: 
0a42 32 a8 f9			ld (store_readcont), a 
0a45			 
0a45				if DEBUG_STORESE 
0a45					DMARK "srC" 
0a45 f5				push af  
0a46 3a 5a 0a			ld a, (.dmark)  
0a49 32 a6 fd			ld (debug_mark),a  
0a4c 3a 5b 0a			ld a, (.dmark+1)  
0a4f 32 a7 fd			ld (debug_mark+1),a  
0a52 3a 5c 0a			ld a, (.dmark+2)  
0a55 32 a8 fd			ld (debug_mark+2),a  
0a58 18 03			jr .pastdmark  
0a5a ..			.dmark: db "srC"  
0a5d f1			.pastdmark: pop af  
0a5e			endm  
# End of macro DMARK
0a5e					CALLMONITOR 
0a5e cd aa fd			call debug_vector  
0a61				endm  
# End of macro CALLMONITOR
0a61				endif 
0a61				; only short reads enabled 
0a61			 
0a61 3a b0 f9			ld a, (store_longread) 
0a64 fe 00			cp 0 
0a66 ca 33 0b			jp z, .readdone 
0a69			 
0a69			; TODO if block has no zeros then need to read next block  
0a69			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a69			; check last byte of physical block. 
0a69			; if not zero then the next block needs to be loaded 
0a69			 
0a69			 
0a69 2a b1 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a6c			 
0a6c 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a6e cd cf 0f			call addatohl 
0a71				;dec hl 
0a71 7e				ld a,(hl) 
0a72				if DEBUG_STORESE 
0a72					DMARK "sr?" 
0a72 f5				push af  
0a73 3a 87 0a			ld a, (.dmark)  
0a76 32 a6 fd			ld (debug_mark),a  
0a79 3a 88 0a			ld a, (.dmark+1)  
0a7c 32 a7 fd			ld (debug_mark+1),a  
0a7f 3a 89 0a			ld a, (.dmark+2)  
0a82 32 a8 fd			ld (debug_mark+2),a  
0a85 18 03			jr .pastdmark  
0a87 ..			.dmark: db "sr?"  
0a8a f1			.pastdmark: pop af  
0a8b			endm  
# End of macro DMARK
0a8b					CALLMONITOR 
0a8b cd aa fd			call debug_vector  
0a8e				endm  
# End of macro CALLMONITOR
0a8e				endif 
0a8e fe 00			cp 0 
0a90 ca 33 0b			jp z, .readdone 
0a93			 
0a93				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a93			 
0a93 23				inc hl 
0a94			 
0a94 22 b1 f9			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a97			 
0a97 ed 5b b3 f9		ld de, (store_readptr)     ; save the current extent to load 
0a9b			 
0a9b eb				ex de, hl 
0a9c			 
0a9c				; next ext 
0a9c			 
0a9c 23				inc hl 
0a9d 22 b3 f9			ld  (store_readptr), hl     ; save the current extent to load 
0aa0			 
0aa0				if DEBUG_STORESE 
0aa0					DMARK "sF2" 
0aa0 f5				push af  
0aa1 3a b5 0a			ld a, (.dmark)  
0aa4 32 a6 fd			ld (debug_mark),a  
0aa7 3a b6 0a			ld a, (.dmark+1)  
0aaa 32 a7 fd			ld (debug_mark+1),a  
0aad 3a b7 0a			ld a, (.dmark+2)  
0ab0 32 a8 fd			ld (debug_mark+2),a  
0ab3 18 03			jr .pastdmark  
0ab5 ..			.dmark: db "sF2"  
0ab8 f1			.pastdmark: pop af  
0ab9			endm  
# End of macro DMARK
0ab9					CALLMONITOR 
0ab9 cd aa fd			call debug_vector  
0abc				endm  
# End of macro CALLMONITOR
0abc				endif 
0abc			 
0abc				; get and load block 
0abc			 
0abc cd 98 07			call storage_findnextid 
0abf			 
0abf				if DEBUG_STORESE 
0abf					DMARK "sf2" 
0abf f5				push af  
0ac0 3a d4 0a			ld a, (.dmark)  
0ac3 32 a6 fd			ld (debug_mark),a  
0ac6 3a d5 0a			ld a, (.dmark+1)  
0ac9 32 a7 fd			ld (debug_mark+1),a  
0acc 3a d6 0a			ld a, (.dmark+2)  
0acf 32 a8 fd			ld (debug_mark+2),a  
0ad2 18 03			jr .pastdmark  
0ad4 ..			.dmark: db "sf2"  
0ad7 f1			.pastdmark: pop af  
0ad8			endm  
# End of macro DMARK
0ad8					CALLMONITOR 
0ad8 cd aa fd			call debug_vector  
0adb				endm  
# End of macro CALLMONITOR
0adb				endif 
0adb cd f8 0f			call ishlzero 
0ade			;	ld a, l 
0ade			;	add h 
0ade			;	cp 0 
0ade ca bc 09			jp z,.sr_fail			; block not found so EOF 
0ae1				 
0ae1				; save current address for use by higher level words etc 
0ae1			 
0ae1 22 a6 f9			ld (store_openaddr),hl 
0ae4			 
0ae4 cd 65 04			call storage_read_block 
0ae7			 
0ae7				; on a continuation block, we now have the file id and ext in the middle of the block 
0ae7				; we need to pull everything back  
0ae7			 
0ae7 ed 5b b1 f9		ld de, (store_readbuf)     ; current buffer to nudge into 
0aeb 2a b1 f9			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aee 23				inc hl 
0aef 23				inc hl     ; skip id and ext 
0af0 01 40 00			ld bc, STORE_BLOCK_PHY 
0af3				if DEBUG_STORESE 
0af3					DMARK "SR<" 
0af3 f5				push af  
0af4 3a 08 0b			ld a, (.dmark)  
0af7 32 a6 fd			ld (debug_mark),a  
0afa 3a 09 0b			ld a, (.dmark+1)  
0afd 32 a7 fd			ld (debug_mark+1),a  
0b00 3a 0a 0b			ld a, (.dmark+2)  
0b03 32 a8 fd			ld (debug_mark+2),a  
0b06 18 03			jr .pastdmark  
0b08 ..			.dmark: db "SR<"  
0b0b f1			.pastdmark: pop af  
0b0c			endm  
# End of macro DMARK
0b0c					CALLMONITOR 
0b0c cd aa fd			call debug_vector  
0b0f				endm  
# End of macro CALLMONITOR
0b0f				endif 
0b0f ed b0			ldir     ; copy data 
0b11			 
0b11				; move the pointer back and pretend we have a full buffer for next recheck 
0b11			 
0b11 1b				dec de 
0b12 1b				dec de 
0b13			 
0b13			; TODO do pop below now short circuit loop????? 
0b13 c1				pop bc     ; get rid of spare de on stack 
0b14				if DEBUG_STORESE 
0b14					DMARK "SR>" 
0b14 f5				push af  
0b15 3a 29 0b			ld a, (.dmark)  
0b18 32 a6 fd			ld (debug_mark),a  
0b1b 3a 2a 0b			ld a, (.dmark+1)  
0b1e 32 a7 fd			ld (debug_mark+1),a  
0b21 3a 2b 0b			ld a, (.dmark+2)  
0b24 32 a8 fd			ld (debug_mark+2),a  
0b27 18 03			jr .pastdmark  
0b29 ..			.dmark: db "SR>"  
0b2c f1			.pastdmark: pop af  
0b2d			endm  
# End of macro DMARK
0b2d					CALLMONITOR 
0b2d cd aa fd			call debug_vector  
0b30				endm  
# End of macro CALLMONITOR
0b30				endif 
0b30 c3 c1 09			jp .srext 
0b33			 
0b33			 
0b33			 
0b33			 
0b33			 
0b33			.readdone:		 
0b33 e1				pop hl 		 ; return start of data to show as not EOF 
0b34 23				inc hl   ; past file id 
0b35 23				inc hl   ; past ext 
0b36				if DEBUG_STORESE 
0b36					DMARK "SRe" 
0b36 f5				push af  
0b37 3a 4b 0b			ld a, (.dmark)  
0b3a 32 a6 fd			ld (debug_mark),a  
0b3d 3a 4c 0b			ld a, (.dmark+1)  
0b40 32 a7 fd			ld (debug_mark+1),a  
0b43 3a 4d 0b			ld a, (.dmark+2)  
0b46 32 a8 fd			ld (debug_mark+2),a  
0b49 18 03			jr .pastdmark  
0b4b ..			.dmark: db "SRe"  
0b4e f1			.pastdmark: pop af  
0b4f			endm  
# End of macro DMARK
0b4f					CALLMONITOR 
0b4f cd aa fd			call debug_vector  
0b52				endm  
# End of macro CALLMONITOR
0b52				endif 
0b52 c9					ret 
0b53			 
0b53			 
0b53			 
0b53			; 
0b53			; Append File 
0b53			; 
0b53			; hl - file id to locate 
0b53			; de - pointer to (multi block) string to write 
0b53			 
0b53			.sa_notfound: 
0b53 d1				pop de 
0b54 c9				ret 
0b55			 
0b55			 
0b55			storage_append: 
0b55				; hl -  file id to append to 
0b55				; de - string to append 
0b55			 
0b55 d5				push de 
0b56				 
0b56				if DEBUG_STORESE 
0b56					DMARK "AP1" 
0b56 f5				push af  
0b57 3a 6b 0b			ld a, (.dmark)  
0b5a 32 a6 fd			ld (debug_mark),a  
0b5d 3a 6c 0b			ld a, (.dmark+1)  
0b60 32 a7 fd			ld (debug_mark+1),a  
0b63 3a 6d 0b			ld a, (.dmark+2)  
0b66 32 a8 fd			ld (debug_mark+2),a  
0b69 18 03			jr .pastdmark  
0b6b ..			.dmark: db "AP1"  
0b6e f1			.pastdmark: pop af  
0b6f			endm  
# End of macro DMARK
0b6f					CALLMONITOR 
0b6f cd aa fd			call debug_vector  
0b72				endm  
# End of macro CALLMONITOR
0b72				endif 
0b72			 
0b72 7d				ld a, l 
0b73 32 a9 f9			ld (store_tmpid), a 
0b76			 
0b76				; get file header  
0b76			 
0b76 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b78 3a a9 f9			ld a, (store_tmpid) 
0b7b 5f				ld e, a 
0b7c			 
0b7c 21 40 00				ld hl, STORE_BLOCK_PHY 
0b7f cd 98 07				call storage_findnextid 
0b82			 
0b82 cd f8 0f			call ishlzero 
0b85 28 cc			jr z, .sa_notfound 
0b87			 
0b87 22 a0 f9			ld (store_tmppageid), hl 
0b8a			 
0b8a				; TODO handle file id not found 
0b8a			 
0b8a				if DEBUG_STORESE 
0b8a					DMARK "AP2" 
0b8a f5				push af  
0b8b 3a 9f 0b			ld a, (.dmark)  
0b8e 32 a6 fd			ld (debug_mark),a  
0b91 3a a0 0b			ld a, (.dmark+1)  
0b94 32 a7 fd			ld (debug_mark+1),a  
0b97 3a a1 0b			ld a, (.dmark+2)  
0b9a 32 a8 fd			ld (debug_mark+2),a  
0b9d 18 03			jr .pastdmark  
0b9f ..			.dmark: db "AP2"  
0ba2 f1			.pastdmark: pop af  
0ba3			endm  
# End of macro DMARK
0ba3					CALLMONITOR 
0ba3 cd aa fd			call debug_vector  
0ba6				endm  
# End of macro CALLMONITOR
0ba6				endif 
0ba6			 
0ba6				; update file extent count 
0ba6			 
0ba6 11 b5 f9			ld de, store_page 
0ba9			 
0ba9 cd 65 04			call storage_read_block 
0bac			 
0bac				if DEBUG_STORESE 
0bac					DMARK "AP3" 
0bac f5				push af  
0bad 3a c1 0b			ld a, (.dmark)  
0bb0 32 a6 fd			ld (debug_mark),a  
0bb3 3a c2 0b			ld a, (.dmark+1)  
0bb6 32 a7 fd			ld (debug_mark+1),a  
0bb9 3a c3 0b			ld a, (.dmark+2)  
0bbc 32 a8 fd			ld (debug_mark+2),a  
0bbf 18 03			jr .pastdmark  
0bc1 ..			.dmark: db "AP3"  
0bc4 f1			.pastdmark: pop af  
0bc5			endm  
# End of macro DMARK
0bc5					CALLMONITOR 
0bc5 cd aa fd			call debug_vector  
0bc8				endm  
# End of macro CALLMONITOR
0bc8				endif 
0bc8			;	ld (store_tmppageid), hl 
0bc8			 
0bc8 3a b7 f9			ld a, (store_page+2) 
0bcb 3c				inc a 
0bcc 32 b7 f9			ld (store_page+2), a 
0bcf 32 a8 f9			ld (store_tmpext), a 
0bd2				 
0bd2				if DEBUG_STORESE 
0bd2					DMARK "AP3" 
0bd2 f5				push af  
0bd3 3a e7 0b			ld a, (.dmark)  
0bd6 32 a6 fd			ld (debug_mark),a  
0bd9 3a e8 0b			ld a, (.dmark+1)  
0bdc 32 a7 fd			ld (debug_mark+1),a  
0bdf 3a e9 0b			ld a, (.dmark+2)  
0be2 32 a8 fd			ld (debug_mark+2),a  
0be5 18 03			jr .pastdmark  
0be7 ..			.dmark: db "AP3"  
0bea f1			.pastdmark: pop af  
0beb			endm  
# End of macro DMARK
0beb					CALLMONITOR 
0beb cd aa fd			call debug_vector  
0bee				endm  
# End of macro CALLMONITOR
0bee				endif 
0bee 2a a0 f9			ld hl, (store_tmppageid) 
0bf1 11 b5 f9			ld de, store_page 
0bf4 cd ca 04			call storage_write_block 
0bf7			 
0bf7				; find free block 
0bf7			 
0bf7 11 00 00			ld de, 0			 ; file extent to locate 
0bfa			 
0bfa 21 40 00				ld hl, STORE_BLOCK_PHY 
0bfd cd 98 07				call storage_findnextid 
0c00 cd f8 0f			call ishlzero 
0c03 ca 53 0b			jp z, .sa_notfound 
0c06			 
0c06					; TODO handle no space left 
0c06					 
0c06 22 a0 f9				ld (store_tmppageid), hl 
0c09			 
0c09				if DEBUG_STORESE 
0c09					DMARK "AP4" 
0c09 f5				push af  
0c0a 3a 1e 0c			ld a, (.dmark)  
0c0d 32 a6 fd			ld (debug_mark),a  
0c10 3a 1f 0c			ld a, (.dmark+1)  
0c13 32 a7 fd			ld (debug_mark+1),a  
0c16 3a 20 0c			ld a, (.dmark+2)  
0c19 32 a8 fd			ld (debug_mark+2),a  
0c1c 18 03			jr .pastdmark  
0c1e ..			.dmark: db "AP4"  
0c21 f1			.pastdmark: pop af  
0c22			endm  
# End of macro DMARK
0c22					CALLMONITOR 
0c22 cd aa fd			call debug_vector  
0c25				endm  
# End of macro CALLMONITOR
0c25				endif 
0c25					; init the buffer with zeros so we can id if the buffer is full or not 
0c25			 
0c25 e5					push hl 
0c26 c5					push bc 
0c27			 
0c27 21 b5 f9				ld hl, store_page 
0c2a 06 40				ld b, STORE_BLOCK_PHY 
0c2c 3e 00				ld a, 0 
0c2e 77			.zeroblock:	ld (hl), a 
0c2f 23					inc hl 
0c30 10 fc				djnz .zeroblock 
0c32			 
0c32 c1					pop bc 
0c33 e1					pop hl 
0c34			 
0c34					; construct block 
0c34			 
0c34 3a a9 f9				ld a, (store_tmpid) 
0c37 32 b5 f9				ld (store_page), a   ; file id 
0c3a 3a a8 f9				ld a, (store_tmpext)   ; extent for this block 
0c3d 32 b6 f9				ld (store_page+1), a 
0c40			 
0c40 e1					pop hl    ; get string to write 
0c41 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c43 11 b7 f9				ld de, store_page+2 
0c46			 
0c46				if DEBUG_STORESE 
0c46					DMARK "AP5" 
0c46 f5				push af  
0c47 3a 5b 0c			ld a, (.dmark)  
0c4a 32 a6 fd			ld (debug_mark),a  
0c4d 3a 5c 0c			ld a, (.dmark+1)  
0c50 32 a7 fd			ld (debug_mark+1),a  
0c53 3a 5d 0c			ld a, (.dmark+2)  
0c56 32 a8 fd			ld (debug_mark+2),a  
0c59 18 03			jr .pastdmark  
0c5b ..			.dmark: db "AP5"  
0c5e f1			.pastdmark: pop af  
0c5f			endm  
# End of macro DMARK
0c5f					CALLMONITOR 
0c5f cd aa fd			call debug_vector  
0c62				endm  
# End of macro CALLMONITOR
0c62				endif 
0c62			 
0c62			 
0c62			 
0c62					; fill buffer with data until end of string or full block 
0c62			 
0c62 7e			.appd:		ld a, (hl) 
0c63 12					ld (de), a 
0c64 fe 00				cp 0 
0c66 28 04				jr z, .appdone 
0c68 23					inc hl 
0c69 13					inc de 
0c6a 10 f6				djnz .appd 
0c6c			 
0c6c e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c6d f5					push af   		; save last byte dumped 
0c6e			 
0c6e			 
0c6e 2a a0 f9			ld hl, (store_tmppageid) 
0c71 11 b5 f9			ld de, store_page 
0c74				if DEBUG_STORESE 
0c74					DMARK "AP6" 
0c74 f5				push af  
0c75 3a 89 0c			ld a, (.dmark)  
0c78 32 a6 fd			ld (debug_mark),a  
0c7b 3a 8a 0c			ld a, (.dmark+1)  
0c7e 32 a7 fd			ld (debug_mark+1),a  
0c81 3a 8b 0c			ld a, (.dmark+2)  
0c84 32 a8 fd			ld (debug_mark+2),a  
0c87 18 03			jr .pastdmark  
0c89 ..			.dmark: db "AP6"  
0c8c f1			.pastdmark: pop af  
0c8d			endm  
# End of macro DMARK
0c8d					CALLMONITOR 
0c8d cd aa fd			call debug_vector  
0c90				endm  
# End of macro CALLMONITOR
0c90				endif 
0c90 cd ca 04				call storage_write_block 
0c93			 
0c93			 
0c93				; was that a full block of data written? 
0c93				; any more to write out? 
0c93			 
0c93				; if yes then set vars and jump to start of function again 
0c93			 
0c93 f1					pop af 
0c94 d1					pop de 
0c95			 
0c95 fe 00				cp 0		 ; no, string was fully written 
0c97 c8					ret z 
0c98			 
0c98					; setup vars for next cycle 
0c98			 
0c98 3a a9 f9				ld a, (store_tmpid) 
0c9b 6f					ld l, a 
0c9c 26 00				ld h, 0 
0c9e			 
0c9e c3 55 0b			 	jp storage_append	 ; yes, need to write out some more 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			if DEBUG_STORECF 
0ca1			storageput:	 
0ca1					ret 
0ca1			storageread: 
0ca1					ld hl, store_page 
0ca1					ld b, 200 
0ca1					ld a,0 
0ca1			.src:		ld (hl),a 
0ca1					inc hl 
0ca1					djnz .src 
0ca1					 
0ca1			 
0ca1					ld de, 0 
0ca1					ld bc, 1 
0ca1					ld hl, store_page 
0ca1					call cfRead 
0ca1			 
0ca1				call cfGetError 
0ca1				ld hl,scratch 
0ca1				call hexout 
0ca1				ld hl, scratch+2 
0ca1				ld a, 0 
0ca1				ld (hl),a 
0ca1				ld de, scratch 
0ca1				ld a,display_row_1 
0ca1				call str_at_display 
0ca1				call update_display 
0ca1			 
0ca1					ld hl, store_page 
0ca1					ld (os_cur_ptr),hl 
0ca1			 
0ca1					ret 
0ca1			endif 
0ca1			 
0ca1			 
0ca1			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ca1			 
0ca1			storage_clear_page: 
0ca1 e5				push hl 
0ca2 d5				push de 
0ca3 c5				push bc 
0ca4 21 b5 f9			ld hl, store_page 
0ca7 3e 00			ld a, 0 
0ca9 77				ld (hl), a 
0caa			 
0caa 11 b6 f9			ld de, store_page+1 
0cad 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cb0			 
0cb0 ed b0			ldir 
0cb2				 
0cb2 c1				pop bc 
0cb3 d1				pop de 
0cb4 e1				pop hl 
0cb5 c9				ret 
0cb6			 
0cb6			; eof 
# End of file firmware_storage.asm
0cb6			  
0cb6			; support routines for above hardware abstraction layer  
0cb6			  
0cb6			include "firmware_general.asm"        ; general support functions  
0cb6			 
0cb6			; word look up 
0cb6			 
0cb6			; in 
0cb6			; a is the index 
0cb6			; hl is pointer start of array 
0cb6			; 
0cb6			; returns 
0cb6			; hl to the word 
0cb6			; 
0cb6			 
0cb6			table_lookup:  
0cb6 d5					push de 
0cb7 eb					ex de, hl 
0cb8			 
0cb8 6f					ld l, a 
0cb9 26 00				ld h, 0 
0cbb 29					add hl, hl 
0cbc 19					add hl, de 
0cbd 7e					ld a, (hl) 
0cbe 23					inc hl 
0cbf 66					ld h,(hl) 
0cc0 6f					ld l, a 
0cc1			 
0cc1 d1					pop de 
0cc2 c9					ret 
0cc3			 
0cc3			; Delay loops 
0cc3			 
0cc3			 
0cc3			 
0cc3			aDelayInMS: 
0cc3 c5				push bc 
0cc4 47				ld b,a 
0cc5			msdelay: 
0cc5 c5				push bc 
0cc6				 
0cc6			 
0cc6 01 41 00			ld bc,041h 
0cc9 cd e1 0c			call delayloop 
0ccc c1				pop bc 
0ccd 05				dec b 
0cce 20 f5			jr nz,msdelay 
0cd0			 
0cd0			;if CPU_CLOCK_8MHZ 
0cd0			;msdelay8: 
0cd0			;	push bc 
0cd0			;	 
0cd0			; 
0cd0			;	ld bc,041h 
0cd0			;	call delayloop 
0cd0			;	pop bc 
0cd0			;	dec b 
0cd0			;	jr nz,msdelay8 
0cd0			;endif 
0cd0			 
0cd0			 
0cd0 c1				pop bc 
0cd1 c9				ret 
0cd2			 
0cd2			 
0cd2			delay250ms: 
0cd2				;push de 
0cd2 01 00 40			ld bc, 04000h 
0cd5 c3 e1 0c			jp delayloop 
0cd8			delay500ms: 
0cd8				;push de 
0cd8 01 00 80			ld bc, 08000h 
0cdb c3 e1 0c			jp delayloop 
0cde			delay1s: 
0cde				;push bc 
0cde			   ; Clobbers A, d and e 
0cde 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0ce1			delayloop: 
0ce1 c5			    push bc 
0ce2			 
0ce2			if BASE_CPM 
0ce2				ld bc, CPM_DELAY_TUNE 
0ce2			.cpmloop: 
0ce2				push bc 
0ce2			 
0ce2			endif 
0ce2			 
0ce2			 
0ce2			 
0ce2			delayloopi: 
0ce2			;	push bc 
0ce2			;.dl: 
0ce2 cb 47		    bit     0,a    	; 8 
0ce4 cb 47		    bit     0,a    	; 8 
0ce6 cb 47		    bit     0,a    	; 8 
0ce8 e6 ff		    and     255  	; 7 
0cea 0b			    dec     bc      	; 6 
0ceb 79			    ld      a,c     	; 4 
0cec b0			    or      b     	; 4 
0ced c2 e2 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cf0			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cf0				;pop de 
0cf0			;pop bc 
0cf0			 
0cf0			if BASE_CPM 
0cf0				pop bc 
0cf0				 
0cf0			    dec     bc      	; 6 
0cf0			    ld      a,c     	; 4 
0cf0			    or      b     	; 4 
0cf0			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cf0				 
0cf0			 
0cf0			endif 
0cf0			;if CPU_CLOCK_8MHZ 
0cf0			;    pop bc 
0cf0			;    push bc 
0cf0			;.dl8: 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    and     255  	; 7 
0cf0			;    dec     bc      	; 6 
0cf0			;    ld      a,c     	; 4 
0cf0			;    or      b     	; 4 
0cf0			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf0			;endif 
0cf0			 
0cf0			;if CPU_CLOCK_10MHZ 
0cf0			;    pop bc 
0cf0			;    push bc 
0cf0			;.dl8: 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    and     255  	; 7 
0cf0			;    dec     bc      	; 6 
0cf0			;    ld      a,c     	; 4 
0cf0			;    or      b     	; 4 
0cf0			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf0			;endif 
0cf0 c1			    pop bc 
0cf1			 
0cf1 c9				ret 
0cf2			 
0cf2			 
0cf2			 
0cf2			; eof 
# End of file firmware_general.asm
0cf2			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0cf2			; display routines that use the physical hardware abstraction layer 
0cf2			 
0cf2			 
0cf2			; Display an activity indicator 
0cf2			; Each call returns the new char pointed to in hl 
0cf2			 
0cf2			active: 
0cf2 3a 01 fb			ld a, (display_active) 
0cf5 fe 06			cp 6 
0cf7			 
0cf7 20 02			jr nz, .sne 
0cf9				; gone past the last one reset sequence 
0cf9 3e ff			ld a, 255 
0cfb			 
0cfb			.sne:   
0cfb				; get the next char in seq 
0cfb 3c				inc a 
0cfc 32 01 fb			ld (display_active), a 
0cff			 
0cff				; look up the string in the table 
0cff 21 16 0d			ld hl, actseq 
0d02 cb 27			sla a 
0d04 cd cf 0f			call addatohl 
0d07 cd 8b 23			call loadwordinhl 
0d0a			 
0d0a				; forth will write the to string when pushing so move from rom to ram 
0d0a			 
0d0a 11 02 fb			ld de, display_active+1 
0d0d 01 02 00			ld bc, 2 
0d10 ed b0			ldir 
0d12			 
0d12 21 02 fb			ld hl, display_active+1 
0d15 c9				ret 
0d16				 
0d16				 
0d16			 
0d16			 
0d16			;db "|/-\|-\" 
0d16			 
0d16			actseq: 
0d16			 
0d16 24 0d		dw spin0 
0d18 26 0d		dw spin1 
0d1a 28 0d		dw spin2 
0d1c 2a 0d		dw spin3 
0d1e 28 0d		dw spin2 
0d20 26 0d		dw spin1 
0d22 24 0d		dw spin0 
0d24			 
0d24 .. 00		spin0: db " ", 0 
0d26 .. 00		spin1: db "-", 0 
0d28 .. 00		spin2: db "+", 0 
0d2a .. 00		spin3: db "#", 0 
0d2c			 
0d2c			 
0d2c			; information window 
0d2c			 
0d2c			; pass hl with 1st string to display 
0d2c			; pass de with 2nd string to display 
0d2c			 
0d2c			info_panel: 
0d2c e5				push hl 
0d2d			 
0d2d 2a 07 fb			ld hl, (display_fb_active) 
0d30 e5				push hl    ; future de destination 
0d31 21 ec fc				ld hl, display_fb0 
0d34 22 07 fb				ld (display_fb_active), hl 
0d37			 
0d37			;	call clear_display 
0d37			 
0d37				if BASE_CPM 
0d37				ld a, '.' 
0d37				else 
0d37 3e a5			ld a, 165 
0d39				endif 
0d39 cd a0 0d			call fill_display 
0d3c			 
0d3c			 
0d3c 3e 55			ld a, display_row_3 + 5 
0d3e cd ae 0d			call str_at_display 
0d41			 
0d41 e1				pop hl 
0d42 d1				pop de 
0d43			 
0d43 e5				push hl 
0d44			 
0d44			 
0d44 3e 2d			ld a, display_row_2 + 5 
0d46 cd ae 0d			call str_at_display 
0d49			 
0d49			 
0d49 cd be 0d			call update_display 
0d4c cd d4 1f			call next_page_prompt 
0d4f cd 9b 0d			call clear_display 
0d52			 
0d52				 
0d52 21 4b fc				ld hl, display_fb1 
0d55 22 07 fb				ld (display_fb_active), hl 
0d58 cd be 0d			call update_display 
0d5b			 
0d5b e1				pop hl 
0d5c			 
0d5c c9				ret 
0d5d			 
0d5d			 
0d5d			 
0d5d			 
0d5d			; TODO windowing? 
0d5d			 
0d5d			; TODO scroll line up 
0d5d			 
0d5d			scroll_up: 
0d5d			 
0d5d e5				push hl 
0d5e d5				push de 
0d5f c5				push bc 
0d60			 
0d60				; get frame buffer  
0d60			 
0d60 2a 07 fb			ld hl, (display_fb_active) 
0d63 e5				push hl    ; future de destination 
0d64			 
0d64 11 28 00			ld  de, display_cols 
0d67 19				add hl, de 
0d68			 
0d68 d1				pop de 
0d69			 
0d69				;ex de, hl 
0d69 01 9f 00			ld bc, display_fb_len -1  
0d6c			;if DEBUG_FORTH_WORDS 
0d6c			;	DMARK "SCL" 
0d6c			;	CALLMONITOR 
0d6c			;endif	 
0d6c ed b0			ldir 
0d6e			 
0d6e				; wipe bottom row 
0d6e			 
0d6e			 
0d6e 2a 07 fb			ld hl, (display_fb_active) 
0d71 11 a0 00			ld de, display_cols*display_rows 
0d74 19				add hl, de 
0d75 06 28			ld b, display_cols 
0d77 3e 20			ld a, ' ' 
0d79			.scwipe: 
0d79 77				ld (hl), a 
0d7a 2b				dec hl 
0d7b 10 fc			djnz .scwipe 
0d7d			 
0d7d				;pop hl 
0d7d			 
0d7d c1				pop bc 
0d7e d1				pop de 
0d7f e1				pop hl 
0d80			 
0d80 c9				ret 
0d81			 
0d81			 
0d81			;scroll_upo: 
0d81			;	ld de, display_row_1 
0d81			 ;	ld hl, display_row_2 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			;	ld de, display_row_2 
0d81			 ;	ld hl, display_row_3 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			;	ld de, display_row_3 
0d81			 ;	ld hl, display_row_4 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			 
0d81			; TODO clear row 4 
0d81			 
0d81			;	ret 
0d81			 
0d81				 
0d81			scroll_down: 
0d81			 
0d81 e5				push hl 
0d82 d5				push de 
0d83 c5				push bc 
0d84			 
0d84				; get frame buffer  
0d84			 
0d84 2a 07 fb			ld hl, (display_fb_active) 
0d87			 
0d87 11 9f 00			ld de, display_fb_len - 1 
0d8a 19				add hl, de 
0d8b			 
0d8b e5			push hl    ; future de destination 
0d8c			 
0d8c 11 28 00			ld  de, display_cols 
0d8f ed 52			sbc hl, de 
0d91			 
0d91			 
0d91 d1				pop de 
0d92			 
0d92			;	ex de, hl 
0d92 01 9f 00			ld bc, display_fb_len -1  
0d95			 
0d95			 
0d95				 
0d95			 
0d95 ed b0			ldir 
0d97			 
0d97				; wipe bottom row 
0d97			 
0d97			 
0d97			;	ld hl, (display_fb_active) 
0d97			;;	ld de, display_cols*display_rows 
0d97			;;	add hl, de 
0d97			;	ld b, display_cols 
0d97			;	ld a, ' ' 
0d97			;.scwiped: 
0d97			;	ld (hl), a 
0d97			;	dec hl 
0d97			;	djnz .scwiped 
0d97			 
0d97				;pop hl 
0d97			 
0d97 c1				pop bc 
0d98 d1				pop de 
0d99 e1				pop hl 
0d9a			 
0d9a c9				ret 
0d9b			;scroll_down: 
0d9b			;	ld de, display_row_4 
0d9b			;	ld hl, display_row_3 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;	ld de, display_row_3 
0d9b			; 	ld hl, display_row_2 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;	ld de, display_row_2 
0d9b			;	ld hl, display_row_1 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;;; TODO clear row 1 
0d9b			;	ret 
0d9b			 
0d9b			 
0d9b			 
0d9b			 
0d9b			 
0d9b			; clear active frame buffer 
0d9b			 
0d9b			clear_display: 
0d9b 3e 20			ld a, ' ' 
0d9d c3 a0 0d			jp fill_display 
0da0			 
0da0			; fill active frame buffer with a char in A 
0da0			 
0da0			fill_display: 
0da0 06 a0			ld b,display_fb_len 
0da2 2a 07 fb			ld hl, (display_fb_active) 
0da5 77			.fd1:	ld (hl),a 
0da6 23				inc hl 
0da7 10 fc			djnz .fd1 
0da9 23				inc hl 
0daa 3e 00			ld a,0 
0dac 77				ld (hl),a 
0dad			 
0dad			 
0dad c9				ret 
0dae			; Write string (DE) at pos (A) to active frame buffer 
0dae			 
0dae 2a 07 fb		str_at_display:    ld hl,(display_fb_active) 
0db1 06 00					ld b,0 
0db3 4f					ld c,a 
0db4 09					add hl,bc 
0db5 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0db6 b7			            OR   A              ;Null terminator? 
0db7 c8			            RET  Z              ;Yes, so finished 
0db8 77					ld (hl),a 
0db9 23				inc hl 
0dba 13			            INC  DE             ;Point to next character 
0dbb 18 f8		            JR   .sad1     ;Repeat 
0dbd c9					ret 
0dbe			 
0dbe			; using current frame buffer write to physical display 
0dbe			 
0dbe			update_display: 
0dbe e5				push hl 
0dbf 2a 07 fb			ld hl, (display_fb_active) 
0dc2 cd 8b 76			call write_display 
0dc5 e1				pop hl 
0dc6 c9				ret 
0dc7			 
0dc7			; TODO scrolling 
0dc7			 
0dc7			 
0dc7			; move cursor right one char 
0dc7			cursor_right: 
0dc7			 
0dc7				; TODO shift right 
0dc7				; TODO if beyond max col 
0dc7				; TODO       cursor_next_line 
0dc7			 
0dc7 c9				ret 
0dc8			 
0dc8			 
0dc8			cursor_next_line: 
0dc8				; TODO first char 
0dc8				; TODO line down 
0dc8				; TODO if past last row 
0dc8				; TODO    scroll up 
0dc8			 
0dc8 c9				ret 
0dc9			 
0dc9			cursor_left: 
0dc9				; TODO shift left 
0dc9				; TODO if beyond left  
0dc9				; TODO     cursor prev line 
0dc9				 
0dc9 c9				ret 
0dca			 
0dca			cursor_prev_line: 
0dca				; TODO last char 
0dca				; TODO line up 
0dca				; TODO if past first row 
0dca				; TODO   scroll down 
0dca			 
0dca c9				ret 
0dcb			 
0dcb			 
0dcb			cout: 
0dcb				; A - char 
0dcb c9				ret 
0dcc			 
0dcc			 
0dcc			; Display a menu and allow item selection (optional toggle items) 
0dcc			; 
0dcc			; format: 
0dcc			; hl pointer to word array with zero term for items 
0dcc			; e.g.    db item1 
0dcc			;         db .... 
0dcc			;         db 0 
0dcc			; 
0dcc			; a = starting menu item  
0dcc			; 
0dcc			; de = pointer item toggle array   (todo) 
0dcc			; 
0dcc			; returns item selected in a 1-... 
0dcc			; returns 0 if back button pressed 
0dcc			; 
0dcc			; NOTE: Uses system frame buffer to display 
0dcc			; 
0dcc			; LEFT, Q = go back 
0dcc			; RIGHT, SPACE, CR = select 
0dcc			; UP, A - Up 
0dcc			; DOWN, Z - Down 
0dcc			 
0dcc			 
0dcc			 
0dcc			 
0dcc			 
0dcc			menu: 
0dcc			 
0dcc					; keep array pointer 
0dcc			 
0dcc 22 ae f9				ld (store_tmp1), hl 
0dcf 32 ac f9				ld (store_tmp2), a 
0dd2			 
0dd2					; check for key bounce 
0dd2			 
0dd2			if BASE_KEV 
0dd2			 
0dd2 cd d6 79		.mbounce:	call cin 
0dd5 fe 00				cp 0 
0dd7 20 f9				jr nz, .mbounce 
0dd9			endif 
0dd9					; for ease use ex 
0dd9			 
0dd9					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0dd9 21 ec fc				ld hl, display_fb0 
0ddc 22 07 fb				ld (display_fb_active), hl 
0ddf			 
0ddf cd 9b 0d		.mloop:		call clear_display 
0de2 cd be 0d				call update_display 
0de5			 
0de5					; draw selection id '>' at 1 
0de5			 
0de5					; init start of list display 
0de5			 
0de5 3e 05				ld a, 5 
0de7 32 aa f9				ld (store_tmp3), a   ; display row count 
0dea 3a ac f9				ld a,( store_tmp2) 
0ded 32 ad f9				ld (store_tmp2+1), a   ; display item count 
0df0			 
0df0					 
0df0			.mitem:	 
0df0			 
0df0			 
0df0 3a ad f9				ld a,(store_tmp2+1) 
0df3 6f					ld l, a 
0df4 26 00				ld h, 0 
0df6 29					add hl, hl 
0df7 ed 5b ae f9			ld de, (store_tmp1) 
0dfb 19					add hl, de 
0dfc 7e					ld a, (hl) 
0dfd 23					inc hl 
0dfe 66					ld h,(hl) 
0dff 6f					ld l, a 
0e00			 
0e00 cd f8 0f				call ishlzero 
0e03 28 1a				jr z, .mdone 
0e05			 
0e05 eb					ex de, hl 
0e06 3a aa f9				ld a, (store_tmp3) 
0e09 cd ae 0d				call str_at_display 
0e0c					 
0e0c			 
0e0c					; next item 
0e0c 3a ad f9				ld a, (store_tmp2+1) 
0e0f 3c					inc a 
0e10 32 ad f9				ld (store_tmp2+1), a   ; display item count 
0e13			 
0e13			 		; next row 
0e13			 
0e13 3a aa f9				ld a, (store_tmp3) 
0e16 c6 28				add display_cols 
0e18 32 aa f9				ld (store_tmp3), a 
0e1b			 
0e1b					; at end of screen? 
0e1b			 
0e1b fe 10				cp display_rows*4 
0e1d 20 d1				jr nz, .mitem 
0e1f			 
0e1f			 
0e1f			.mdone: 
0e1f cd f8 0f				call ishlzero 
0e22 28 08				jr z, .nodn 
0e24			 
0e24 3e 78				ld a, display_row_4 
0e26 11 a5 0e				ld de, .mdown 
0e29 cd ae 0d				call str_at_display 
0e2c			 
0e2c					; draw options to fill the screens with active item on line 1 
0e2c					; if current option is 2 or more then display ^ in top 
0e2c			 
0e2c 3a ac f9		.nodn:		ld a, (store_tmp2) 
0e2f fe 00				cp 0 
0e31 28 08				jr z, .noup 
0e33			 
0e33 3e 00				ld a, 0 
0e35 11 a3 0e				ld de, .mup 
0e38 cd ae 0d				call str_at_display 
0e3b			 
0e3b 3e 02		.noup:		ld a, 2 
0e3d 11 a1 0e				ld de, .msel 
0e40 cd ae 0d				call str_at_display 
0e43			 
0e43					; if current option + 1 is not null then display V in bottom 
0e43					; get key 
0e43 cd be 0d				call update_display 
0e46			 
0e46			 
0e46					; handle key 
0e46			 
0e46 cd c5 79				call cin_wait 
0e49			 
0e49 fe 05				cp KEY_UP 
0e4b 28 2b				jr z, .mgoup 
0e4d fe 61				cp 'a' 
0e4f 28 27				jr z, .mgoup 
0e51 fe 0a				cp KEY_DOWN 
0e53 28 32				jr z, .mgod 
0e55 fe 7a				cp 'z' 
0e57 28 2e				jr z, .mgod 
0e59 fe 20				cp ' ' 
0e5b 28 34				jr z, .goend 
0e5d fe 0c				cp KEY_RIGHT 
0e5f 28 30				jr z, .goend 
0e61 fe 0d				cp KEY_CR 
0e63 28 2c				jr z, .goend 
0e65 fe 71				cp 'q' 
0e67 28 0b				jr z, .goback 
0e69			 
0e69 fe 0b				cp KEY_LEFT 
0e6b 28 07				jr z, .goback 
0e6d fe 08				cp KEY_BS 
0e6f 28 03				jr z, .goback 
0e71 c3 df 0d				jp .mloop 
0e74			 
0e74			.goback: 
0e74 3e 00			ld a, 0 
0e76 18 1d			jr .goend2 
0e78			 
0e78				; move up one 
0e78			.mgoup: 
0e78 3a ac f9				ld a, (store_tmp2) 
0e7b fe 00				cp 0 
0e7d ca df 0d				jp z, .mloop 
0e80 3d					dec a 
0e81 32 ac f9				ld (store_tmp2), a 
0e84 c3 df 0d				jp .mloop 
0e87			 
0e87				; move down one 
0e87			.mgod: 
0e87 3a ac f9				ld a, (store_tmp2) 
0e8a 3c					inc a 
0e8b 32 ac f9				ld (store_tmp2), a 
0e8e c3 df 0d				jp .mloop 
0e91			 
0e91			 
0e91			.goend: 
0e91					; get selected item number 
0e91			 
0e91 3a ac f9				ld a, (store_tmp2) 
0e94 3c					inc a 
0e95			 
0e95			.goend2: 
0e95 f5					push af 
0e96			 
0e96					; restore active fb 
0e96					; TODO BUG assumes fb1 
0e96			 
0e96 21 4b fc				ld hl, display_fb1 
0e99 22 07 fb				ld (display_fb_active), hl 
0e9c			 
0e9c					; restore main regs 
0e9c			 
0e9c			 
0e9c cd be 0d				call update_display 
0e9f			 
0e9f f1					pop af 
0ea0			 
0ea0 c9				ret 
0ea1			 
0ea1 .. 00		.msel:   db ">",0 
0ea3 .. 00		.mup:   db "^",0 
0ea5 .. 00		.mdown:   db "v",0 
0ea7			 
0ea7			 
0ea7			; eof 
0ea7			 
# End of file firmware_display.asm
0ea7			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ea7			; random number generators 
0ea7			 
0ea7			 
0ea7			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ea7			 
0ea7			 
0ea7			;-----> Generate a random number 
0ea7			; output a=answer 0<=a<=255 
0ea7			; all registers are preserved except: af 
0ea7			random: 
0ea7 e5			        push    hl 
0ea8 d5			        push    de 
0ea9 2a e6 fa		        ld      hl,(randData) 
0eac ed 5f		        ld      a,r 
0eae 57			        ld      d,a 
0eaf 5e			        ld      e,(hl) 
0eb0 19			        add     hl,de 
0eb1 85			        add     a,l 
0eb2 ac			        xor     h 
0eb3 22 e6 fa		        ld      (randData),hl 
0eb6 d1			        pop     de 
0eb7 e1			        pop     hl 
0eb8 c9			        ret 
0eb9			 
0eb9			 
0eb9			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0eb9			 
0eb9			 
0eb9			 
0eb9			;------LFSR------ 
0eb9			;James Montelongo 
0eb9			;optimized by Spencer Putt 
0eb9			;out: 
0eb9			; a = 8 bit random number 
0eb9			RandLFSR: 
0eb9 21 ec fa		        ld hl,LFSRSeed+4 
0ebc 5e			        ld e,(hl) 
0ebd 23			        inc hl 
0ebe 56			        ld d,(hl) 
0ebf 23			        inc hl 
0ec0 4e			        ld c,(hl) 
0ec1 23			        inc hl 
0ec2 7e			        ld a,(hl) 
0ec3 47			        ld b,a 
0ec4 cb 13		        rl e  
0ec6 cb 12			rl d 
0ec8 cb 11		        rl c  
0eca 17				rla 
0ecb cb 13		        rl e  
0ecd cb 12			rl d 
0ecf cb 11		        rl c  
0ed1 17				rla 
0ed2 cb 13		        rl e  
0ed4 cb 12			rl d 
0ed6 cb 11		        rl c  
0ed8 17				rla 
0ed9 67			        ld h,a 
0eda cb 13		        rl e  
0edc cb 12			rl d 
0ede cb 11		        rl c  
0ee0 17				rla 
0ee1 a8			        xor b 
0ee2 cb 13		        rl e  
0ee4 cb 12			rl d 
0ee6 ac			        xor h 
0ee7 a9			        xor c 
0ee8 aa			        xor d 
0ee9 21 ee fa		        ld hl,LFSRSeed+6 
0eec 11 ef fa		        ld de,LFSRSeed+7 
0eef 01 07 00		        ld bc,7 
0ef2 ed b8		        lddr 
0ef4 12			        ld (de),a 
0ef5 c9			        ret 
0ef6			 
0ef6			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ef6			 
0ef6			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ef6			 
0ef6			 
0ef6			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ef6			 
0ef6			prng16: 
0ef6			;Inputs: 
0ef6			;   (seed1) contains a 16-bit seed value 
0ef6			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ef6			;Outputs: 
0ef6			;   HL is the result 
0ef6			;   BC is the result of the LCG, so not that great of quality 
0ef6			;   DE is preserved 
0ef6			;Destroys: 
0ef6			;   AF 
0ef6			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ef6			;160cc 
0ef6			;26 bytes 
0ef6 2a e0 fa		    ld hl,(seed1) 
0ef9 44			    ld b,h 
0efa 4d			    ld c,l 
0efb 29			    add hl,hl 
0efc 29			    add hl,hl 
0efd 2c			    inc l 
0efe 09			    add hl,bc 
0eff 22 e0 fa		    ld (seed1),hl 
0f02 2a de fa		    ld hl,(seed2) 
0f05 29			    add hl,hl 
0f06 9f			    sbc a,a 
0f07 e6 2d		    and %00101101 
0f09 ad			    xor l 
0f0a 6f			    ld l,a 
0f0b 22 de fa		    ld (seed2),hl 
0f0e 09			    add hl,bc 
0f0f c9			    ret 
0f10			 
0f10			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f10			 
0f10			rand32: 
0f10			;Inputs: 
0f10			;   (seed1_0) holds the lower 16 bits of the first seed 
0f10			;   (seed1_1) holds the upper 16 bits of the first seed 
0f10			;   (seed2_0) holds the lower 16 bits of the second seed 
0f10			;   (seed2_1) holds the upper 16 bits of the second seed 
0f10			;   **NOTE: seed2 must be non-zero 
0f10			;Outputs: 
0f10			;   HL is the result 
0f10			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f10			;Destroys: 
0f10			;   AF 
0f10			;Tested and passes all CAcert tests 
0f10			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f10			;it has a period of 18,446,744,069,414,584,320 
0f10			;roughly 18.4 quintillion. 
0f10			;LFSR taps: 0,2,6,7  = 11000101 
0f10			;291cc 
0f10			;seed1_0=$+1 
0f10			;    ld hl,12345 
0f10			;seed1_1=$+1 
0f10			;    ld de,6789 
0f10			;    ld b,h 
0f10			;    ld c,l 
0f10			;    add hl,hl \ rl e \ rl d 
0f10			;    add hl,hl \ rl e \ rl d 
0f10			;    inc l 
0f10			;    add hl,bc 
0f10			;    ld (seed1_0),hl 
0f10			;    ld hl,(seed1_1) 
0f10			;    adc hl,de 
0f10			;    ld (seed1_1),hl 
0f10			;    ex de,hl 
0f10			;seed2_0=$+1 
0f10			;    ld hl,9876 
0f10			;seed2_1=$+1 
0f10			;    ld bc,54321 
0f10			;    add hl,hl \ rl c \ rl b 
0f10			;    ld (seed2_1),bc 
0f10			;    sbc a,a 
0f10			;    and %11000101 
0f10			;    xor l 
0f10			;    ld l,a 
0f10			;    ld (seed2_0),hl 
0f10			;    ex de,hl 
0f10			;    add hl,bc 
0f10			;    ret 
0f10			; 
0f10			 
0f10			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f10			; 20 bytes, 86 cycles (excluding ret) 
0f10			 
0f10			; returns   hl = pseudorandom number 
0f10			; corrupts   a 
0f10			 
0f10			; generates 16-bit pseudorandom numbers with a period of 65535 
0f10			; using the xorshift method: 
0f10			 
0f10			; hl ^= hl << 7 
0f10			; hl ^= hl >> 9 
0f10			; hl ^= hl << 8 
0f10			 
0f10			; some alternative shift triplets which also perform well are: 
0f10			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f10			 
0f10			;  org 32768 
0f10			 
0f10			xrnd: 
0f10 2a e4 fa		  ld hl,(xrandc)       ; seed must not be 0 
0f13 3e 00		  ld a,0 
0f15 bd			  cp l 
0f16 20 02		  jr nz, .xrnd1 
0f18 2e 01		  ld l, 1 
0f1a			.xrnd1: 
0f1a			 
0f1a 7c			  ld a,h 
0f1b 1f			  rra 
0f1c 7d			  ld a,l 
0f1d 1f			  rra 
0f1e ac			  xor h 
0f1f 67			  ld h,a 
0f20 7d			  ld a,l 
0f21 1f			  rra 
0f22 7c			  ld a,h 
0f23 1f			  rra 
0f24 ad			  xor l 
0f25 6f			  ld l,a 
0f26 ac			  xor h 
0f27 67			  ld h,a 
0f28			 
0f28 22 e4 fa		  ld (xrandc),hl 
0f2b			 
0f2b c9			  ret 
0f2c			;  
0f2c			 
0f2c			 
0f2c			;;;; int maths 
0f2c			 
0f2c			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f2c			; Divide 16-bit values (with 16-bit result) 
0f2c			; In: Divide BC by divider DE 
0f2c			; Out: BC = result, HL = rest 
0f2c			; 
0f2c			Div16: 
0f2c 21 00 00		    ld hl,0 
0f2f 78			    ld a,b 
0f30 06 08		    ld b,8 
0f32			Div16_Loop1: 
0f32 17			    rla 
0f33 ed 6a		    adc hl,hl 
0f35 ed 52		    sbc hl,de 
0f37 30 01		    jr nc,Div16_NoAdd1 
0f39 19			    add hl,de 
0f3a			Div16_NoAdd1: 
0f3a 10 f6		    djnz Div16_Loop1 
0f3c 17			    rla 
0f3d 2f			    cpl 
0f3e 47			    ld b,a 
0f3f 79			    ld a,c 
0f40 48			    ld c,b 
0f41 06 08		    ld b,8 
0f43			Div16_Loop2: 
0f43 17			    rla 
0f44 ed 6a		    adc hl,hl 
0f46 ed 52		    sbc hl,de 
0f48 30 01		    jr nc,Div16_NoAdd2 
0f4a 19			    add hl,de 
0f4b			Div16_NoAdd2: 
0f4b 10 f6		    djnz Div16_Loop2 
0f4d 17			    rla 
0f4e 2f			    cpl 
0f4f 41			    ld b,c 
0f50 4f			    ld c,a 
0f51 c9			ret 
0f52			 
0f52			 
0f52			;http://z80-heaven.wikidot.com/math 
0f52			; 
0f52			;Inputs: 
0f52			;     DE and A are factors 
0f52			;Outputs: 
0f52			;     A is not changed 
0f52			;     B is 0 
0f52			;     C is not changed 
0f52			;     DE is not changed 
0f52			;     HL is the product 
0f52			;Time: 
0f52			;     342+6x 
0f52			; 
0f52			Mult16: 
0f52			 
0f52 06 08		     ld b,8          ;7           7 
0f54 21 00 00		     ld hl,0         ;10         10 
0f57 29			       add hl,hl     ;11*8       88 
0f58 07			       rlca          ;4*8        32 
0f59 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f5b 19			         add hl,de   ;--         -- 
0f5c 10 f9		       djnz $-5      ;13*7+8     99 
0f5e c9			ret 
0f5f			 
0f5f			; 
0f5f			; Square root of 16-bit value 
0f5f			; In:  HL = value 
0f5f			; Out:  D = result (rounded down) 
0f5f			; 
0f5f			;Sqr16: 
0f5f			;    ld de,#0040 
0f5f			;    ld a,l 
0f5f			;    ld l,h 
0f5f			;    ld h,d 
0f5f			;    or a 
0f5f			;    ld b,8 
0f5f			;Sqr16_Loop: 
0f5f			;    sbc hl,de 
0f5f			;    jr nc,Sqr16_Skip 
0f5f			;    add hl,de 
0f5f			;Sqr16_Skip: 
0f5f			;    ccf 
0f5f			;    rl d 
0f5f			;    add a,a 
0f5f			;    adc hl,hl 
0f5f			;    add a,a 
0f5f			;    adc hl,hl 
0f5f			;    djnz Sqr16_Loop 
0f5f			;    ret 
0f5f			; 
0f5f			; 
0f5f			; Divide 8-bit values 
0f5f			; In: Divide E by divider C 
0f5f			; Out: A = result, B = rest 
0f5f			; 
0f5f			Div8: 
0f5f af			    xor a 
0f60 06 08		    ld b,8 
0f62			Div8_Loop: 
0f62 cb 13		    rl e 
0f64 17			    rla 
0f65 91			    sub c 
0f66 30 01		    jr nc,Div8_NoAdd 
0f68 81			    add a,c 
0f69			Div8_NoAdd: 
0f69 10 f7		    djnz Div8_Loop 
0f6b 47			    ld b,a 
0f6c 7b			    ld a,e 
0f6d 17			    rla 
0f6e 2f			    cpl 
0f6f c9			    ret 
0f70			 
0f70			; 
0f70			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f70			; In: Multiply A with DE 
0f70			; Out: HL = result 
0f70			; 
0f70			Mult12U: 
0f70 2e 00		    ld l,0 
0f72 87			    add a,a 
0f73 30 01		    jr nc,Mult12U_NoAdd0 
0f75 19			    add hl,de 
0f76			Mult12U_NoAdd0: 
0f76 29			    add hl,hl 
0f77 87			    add a,a 
0f78 30 01		    jr nc,Mult12U_NoAdd1 
0f7a 19			    add hl,de 
0f7b			Mult12U_NoAdd1: 
0f7b 29			    add hl,hl 
0f7c 87			    add a,a 
0f7d 30 01		    jr nc,Mult12U_NoAdd2 
0f7f 19			    add hl,de 
0f80			Mult12U_NoAdd2: 
0f80 29			    add hl,hl 
0f81 87			    add a,a 
0f82 30 01		    jr nc,Mult12U_NoAdd3 
0f84 19			    add hl,de 
0f85			Mult12U_NoAdd3: 
0f85 29			    add hl,hl 
0f86 87			    add a,a 
0f87 30 01		    jr nc,Mult12U_NoAdd4 
0f89 19			    add hl,de 
0f8a			Mult12U_NoAdd4: 
0f8a 29			    add hl,hl 
0f8b 87			    add a,a 
0f8c 30 01		    jr nc,Mult12U_NoAdd5 
0f8e 19			    add hl,de 
0f8f			Mult12U_NoAdd5: 
0f8f 29			    add hl,hl 
0f90 87			    add a,a 
0f91 30 01		    jr nc,Mult12U_NoAdd6 
0f93 19			    add hl,de 
0f94			Mult12U_NoAdd6: 
0f94 29			    add hl,hl 
0f95 87			    add a,a 
0f96 d0			    ret nc 
0f97 19			    add hl,de 
0f98 c9			    ret 
0f99			 
0f99			; 
0f99			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f99			; In: Multiply A with DE 
0f99			;      Put lowest value in A for most efficient calculation 
0f99			; Out: HL = result 
0f99			; 
0f99			Mult12R: 
0f99 21 00 00		    ld hl,0 
0f9c			Mult12R_Loop: 
0f9c cb 3f		    srl a 
0f9e 30 01		    jr nc,Mult12R_NoAdd 
0fa0 19			    add hl,de 
0fa1			Mult12R_NoAdd: 
0fa1 cb 23		    sla e 
0fa3 cb 12		    rl d 
0fa5 b7			    or a 
0fa6 c2 9c 0f		    jp nz,Mult12R_Loop 
0fa9 c9			    ret 
0faa			 
0faa			; 
0faa			; Multiply 16-bit values (with 32-bit result) 
0faa			; In: Multiply BC with DE 
0faa			; Out: BCHL = result 
0faa			; 
0faa			Mult32: 
0faa 79			    ld a,c 
0fab 48			    ld c,b 
0fac 21 00 00		    ld hl,0 
0faf 06 10		    ld b,16 
0fb1			Mult32_Loop: 
0fb1 29			    add hl,hl 
0fb2 17			    rla 
0fb3 cb 11		    rl c 
0fb5 30 07		    jr nc,Mult32_NoAdd 
0fb7 19			    add hl,de 
0fb8 ce 00		    adc a,0 
0fba d2 be 0f		    jp nc,Mult32_NoAdd 
0fbd 0c			    inc c 
0fbe			Mult32_NoAdd: 
0fbe 10 f1		    djnz Mult32_Loop 
0fc0 41			    ld b,c 
0fc1 4f			    ld c,a 
0fc2 c9			    ret 
0fc3			 
0fc3			 
0fc3			 
0fc3			; 
0fc3			; Multiply 8-bit values 
0fc3			; In:  Multiply H with E 
0fc3			; Out: HL = result 
0fc3			; 
0fc3			Mult8: 
0fc3 16 00		    ld d,0 
0fc5 6a			    ld l,d 
0fc6 06 08		    ld b,8 
0fc8			Mult8_Loop: 
0fc8 29			    add hl,hl 
0fc9 30 01		    jr nc,Mult8_NoAdd 
0fcb 19			    add hl,de 
0fcc			Mult8_NoAdd: 
0fcc 10 fa		    djnz Mult8_Loop 
0fce c9			    ret 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			;;http://z80-heaven.wikidot.com/math 
0fcf			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fcf			; 
0fcf			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fcf			;     ld a,16        ;7 
0fcf			;     ld hl,0        ;10 
0fcf			;     jp $+5         ;10 
0fcf			;.DivLoop: 
0fcf			;       add hl,bc    ;-- 
0fcf			;       dec a        ;64 
0fcf			;       jr z,.DivLoopEnd        ;86 
0fcf			; 
0fcf			;       sla e        ;128 
0fcf			;       rl d         ;128 
0fcf			;       adc hl,hl    ;240 
0fcf			;       sbc hl,bc    ;240 
0fcf			;       jr nc,.DivLoop ;23|21 
0fcf			;       inc e        ;-- 
0fcf			;       jp .DivLoop+1 
0fcf			; 
0fcf			;.DivLoopEnd: 
0fcf			 
0fcf			;HL_Div_C: 
0fcf			;Inputs: 
0fcf			;     HL is the numerator 
0fcf			;     C is the denominator 
0fcf			;Outputs: 
0fcf			;     A is the remainder 
0fcf			;     B is 0 
0fcf			;     C is not changed 
0fcf			;     DE is not changed 
0fcf			;     HL is the quotient 
0fcf			; 
0fcf			;       ld b,16 
0fcf			;       xor a 
0fcf			;         add hl,hl 
0fcf			;         rla 
0fcf			;         cp c 
0fcf			;         jr c,$+4 
0fcf			;           inc l 
0fcf			;           sub c 
0fcf			;         djnz $-7 
0fcf			 
0fcf			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fcf			 
0fcf			addatohl: 
0fcf 85			    add   a, l    ; A = A+L 
0fd0 6f			    ld    l, a    ; L = A+L 
0fd1 8c			    adc   a, h    ; A = A+L+H+carry 
0fd2 95			    sub   l       ; A = H+carry 
0fd3 67			    ld    h, a    ; H = H+carry 
0fd4 c9			ret 
0fd5			 
0fd5			addatode: 
0fd5 83			    add   a, e    ; A = A+L 
0fd6 5f			    ld    e, a    ; L = A+L 
0fd7 8a			    adc   a, d    ; A = A+L+H+carry 
0fd8 93			    sub   e       ; A = H+carry 
0fd9 57			    ld    d, a    ; H = H+carry 
0fda c9			ret 
0fdb			 
0fdb			 
0fdb			addatobc: 
0fdb 81			    add   a, c    ; A = A+L 
0fdc 4f			    ld    c, a    ; L = A+L 
0fdd 88			    adc   a, b    ; A = A+L+H+carry 
0fde 91			    sub   c       ; A = H+carry 
0fdf 47			    ld    b, a    ; H = H+carry 
0fe0 c9			ret 
0fe1			 
0fe1			subafromhl: 
0fe1			   ; If A=0 do nothing 
0fe1			    ; Otherwise flip A's sign. Since 
0fe1			    ; the upper byte becomes -1, also 
0fe1			    ; substract 1 from H. 
0fe1 ed 44		    neg 
0fe3 ca ec 0f		    jp    z, Skip 
0fe6 25			    dec   h 
0fe7			     
0fe7			    ; Now add the low byte as usual 
0fe7			    ; Two's complement takes care of 
0fe7			    ; ensuring the result is correct 
0fe7 85			    add   a, l 
0fe8 6f			    ld    l, a 
0fe9 8c			    adc   a, h 
0fea 95			    sub   l 
0feb 67			    ld    h, a 
0fec			Skip: 
0fec c9				ret 
0fed			 
0fed			 
0fed			; compare hl and de 
0fed			; returns:  
0fed			; if hl = de, z=1, s=0, c0=0 
0fed			; if hl > de, z=0, s=0, c=0 
0fed			; if hl < de, z=0, s=1, c=1 
0fed			cmp16:	 
0fed b7				or a 
0fee ed 52			sbc hl,de 
0ff0 e0				ret po 
0ff1 7c				ld a,h 
0ff2 1f				rra 
0ff3 ee 40			xor 01000000B 
0ff5 37				scf 
0ff6 8f				adc a,a 
0ff7 c9				ret 
0ff8			 
0ff8			 
0ff8			; test if hl contains zero   - A is destroyed 
0ff8			 
0ff8			ishlzero:    
0ff8 b7				or a     ; reset flags 
0ff9 7c				ld a, h 
0ffa b5				or l        	 
0ffb			 
0ffb c9				ret 
0ffc			 
0ffc			 
0ffc			 
0ffc			 
0ffc			if FORTH_ENABLE_FLOATMATH 
0ffc			;include "float/bbcmath.z80" 
0ffc			include "float/lpfpcalc.asm" 
0ffc			endif 
0ffc			 
0ffc			 
0ffc			; eof 
0ffc			 
# End of file firmware_maths.asm
0ffc			include "firmware_strings.asm"   ; string handling  
0ffc			 
0ffc			 
0ffc			; TODO string len 
0ffc			; input text string, end on cr with zero term 
0ffc			; a offset into frame buffer to start prompt 
0ffc			; d is max length 
0ffc			; e is display size TODO 
0ffc			; c is current cursor position 
0ffc			; hl is ptr to where string will be stored and edited directly 
0ffc			 
0ffc			 
0ffc			; TODO check limit of buffer for new inserts 
0ffc			; TODO check insert does not push beyond buffer 
0ffc			; TODO scroll in a limited display area 
0ffc			; TODO scroll whole screen on page wrap 
0ffc			 
0ffc			 
0ffc			; TODO use LCD cursor? 
0ffc			 
0ffc			EDIT_V1: equ 0 
0ffc			EDIT_V2: equ 1 
0ffc			 
0ffc			 
0ffc			 
0ffc			if EDIT_V2 
0ffc			input_str: 
0ffc			 
0ffc 32 9f fd			    	ld (input_at_pos),a      ; save display position to start 
0fff			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0fff 22 a2 fd				ld (input_start), hl     ; save ptr to buffer 
1002			;		ld a, c 
1002			;		call addatohl 
1002			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
1002 7a					ld a,d 
1003 32 a1 fd			        ld (input_size), a       ; save length of input area 
1006 79					ld a, c 
1007 32 90 fd				ld (input_cursor),a      ; init cursor start position relative to start of string 
100a 7b					ld a,e 
100b 32 a0 fd			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
100e			 
100e			 
100e					; add a trailing space to make screen refresh nicer 
100e			 
100e					;ld hl, (input_start) 
100e					;push hl 
100e					;ld a, 0 
100e					;call strlent 
100e					;ld a, l 
100e					;pop hl 
100e					;call addatohl 
100e					;dec hl 
100e					;ld a, ' ' 
100e					;ld (hl), a 
100e					;inc hl 
100e					;ld (hl), a 
100e					;inc hl 
100e					;ld a, 0 
100e					;ld (hl), a 
100e			 
100e			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
100e					; init cursor shape if not set by the cin routines 
100e 21 fc fa				ld hl, cursor_shape 
1011			if BASE_KEV 
1011 3e ff				ld a, 255 
1013			else 
1013					ld a, '#' 
1013			endif 
1013 77					ld (hl), a 
1014 23					inc hl 
1015 3e 00				ld a, 0 
1017 77					ld (hl), a 
1018			 
1018 3e 09				ld a, CUR_BLINK_RATE 
101a 32 9b fd				ld (input_cur_flash), a 
101d 3e 01				ld a, 1 
101f 32 9a fd				ld (input_cur_onoff),a 
1022			.inmain:	 
1022			 
1022 cd 9b 11				call input_disp_ref 
1025			 
1025					; save current length of string 
1025			 
1025 2a a2 fd				ld hl, (input_start) 
1028 3e 00				ld a, 0 
102a cd 91 13				call strlent 
102d 7d					ld a,l 
102e 32 95 fd				ld (input_len), a 
1031			 
1031					;call input_disp_oncur 
1031			 
1031					; display current state of input buffer 
1031			 
1031					; clean any backspace chars 
1031			 
1031 3e 20				ld a, " " 
1033 32 fc f0				ld (scratch),a 
1036 3e 00				ld a, 0 
1038 32 fd f0				ld (scratch+1),a 
103b 3a 9f fd				ld a,(input_at_pos) 
103e 85					add l 
103f 11 fc f0				ld de, scratch 
1042 cd ae 0d				call str_at_display 
1045			 
1045					; pause 1ms 
1045			 
1045 3e 01				ld a, 1 
1047 cd c3 0c				call aDelayInMS 
104a			 
104a			; display cursor if visible on this cycle 
104a			 
104a					; dec flash counter 
104a 3a 9b fd				ld a, (input_cur_flash) 
104d 3d					dec a 
104e 32 9b fd				ld (input_cur_flash), a 
1051 fe 00				cp 0 
1053 20 0d				jr nz, .inochgstate 
1055			 
1055			 
1055					; reset on change of state 
1055 3e 09				ld a, CUR_BLINK_RATE 
1057 32 9b fd				ld (input_cur_flash), a 
105a			 
105a					; change state 
105a 3a 9a fd				ld a,(input_cur_onoff) 
105d ed 44				neg 
105f 32 9a fd				ld (input_cur_onoff),a 
1062			 
1062			 
1062			 
1062			 
1062					; TODO is cursor visible? 
1062					; TODO if so then over write the char at curspos pos with the cursor shape 
1062			 
1062								 
1062			 
1062			.inochgstate: 
1062 3a 9a fd				ld a,(input_cur_onoff) 
1065 fe ff				cp 255 
1067 28 0e				jr z, .skipcursor 
1069 3a 9f fd				ld a, (input_at_pos) 
106c 47					ld b, a 
106d 3a 90 fd				ld a, (input_cursor) 
1070 80					add b 
1071 11 fc fa				ld de, cursor_shape 
1074					 
1074 cd ae 0d				call str_at_display 
1077			 
1077			.skipcursor: 
1077				if DEBUG_INPUTV2 
1077			 
1077 3a 9f fd				ld a,(input_at_pos) 
107a 21 e8 fa				ld hl, LFSRSeed 
107d cd 29 12				call hexout 
1080 3a 90 fd				ld a, (input_cursor) 
1083 21 ea fa				ld hl, LFSRSeed+2 
1086 cd 29 12				call hexout 
1089 3a a1 fd				ld a,(input_size) 
108c 21 ec fa				ld hl, LFSRSeed+4 
108f cd 29 12				call hexout 
1092			 
1092 3a 9a fd				ld a,(input_cur_onoff) 
1095 21 ee fa				ld hl, LFSRSeed+6 
1098 cd 29 12				call hexout 
109b			 
109b 3a 9b fd				ld a,(input_cur_flash) 
109e 21 f0 fa				ld hl, LFSRSeed+8 
10a1 cd 29 12				call hexout 
10a4			 
10a4 3a 95 fd				ld a,(input_len) 
10a7 21 f2 fa				ld hl, LFSRSeed+10 
10aa cd 29 12				call hexout 
10ad 21 f4 fa				ld hl, LFSRSeed+12 
10b0 3e 00				ld a, 0 
10b2 77					ld (hl),a 
10b3 3e 78				ld a, display_row_4 
10b5 11 e8 fa				ld de, LFSRSeed 
10b8 cd ae 0d				call str_at_display 
10bb				endif 
10bb cd be 0d				call update_display 
10be			 
10be					; TODO keyboard processing 
10be			 
10be			if BASE_CPM 
10be					call cin_wait 
10be			else 
10be cd d6 79				call cin    ; _wait 
10c1			endif 
10c1 fe 00				cp 0 
10c3 ca 22 10				jp z, .inmain 
10c6			 
10c6 fe 0b				cp KEY_LEFT    ; cursor left 
10c8 ca 8d 11				jp z, input_left 
10cb				 
10cb fe 0c				cp KEY_RIGHT      ; cursor right 
10cd ca 94 11				jp z, input_right 
10d0			 
10d0 fe 0d				cp KEY_CR 
10d2 c8					ret z 
10d3			 
10d3 fe 08				cp KEY_BS 
10d5 ca 02 12				jp z, input_delchar 
10d8			 
10d8 fe 06				cp KEY_NEXTWORD 
10da ca 0e 11				jp z, input_nxtword 
10dd			 
10dd fe 07				cp KEY_PREVWORD 
10df ca 35 11				jp z, input_prvword 
10e2			 
10e2 fe 0e				cp KEY_HOME    ; jump to start of line 
10e4 20 08				jr nz, .ikh 
10e6 3e 00				ld a, 0 
10e8 32 90 fd				ld (input_cursor), a 
10eb ca 22 10				jp z, .inmain 
10ee			.ikh: 
10ee			 
10ee fe 0f				cp KEY_END     ; jump to end of line 
10f0 20 09				jr nz, .ike 
10f2 3a 95 fd				ld a, (input_len) 
10f5 32 90 fd				ld (input_cursor),a 
10f8 ca 22 10				jp z, .inmain 
10fb			.ike: 
10fb fe 05			        cp KEY_UP      ; recall last command 
10fd 20 0c				jr nz, .irec 
10ff			; TODO next word 
10ff			; TODO prev word 
10ff			;  
10ff			; 
10ff 21 fc f0			ld hl, scratch 
1102 11 22 f5			ld de, os_last_cmd 
1105 cd 1f 12			call strcpy 
1108 ca 22 10				jp z, .inmain 
110b			.irec: 
110b			;		jr .instr1 
110b			 
110b			 
110b					; if no special key then insert as a char 
110b			 
110b c3 d4 11				jp input_inschr 
110e			 
110e				 
110e			input_nxtword: 
110e				; jump to start next word after the cursor 
110e			 
110e			.insknwn:	 
110e cd ca 11				call input_curptr	 
1111 7e					ld a,(hl)	 
1112 fe 00				cp 0 
1114 ca 22 10				jp z, .inmain    ; end of string 
1117			 
1117			; if we are on a word, then move off of it 
1117			 
1117 fe 20				cp ' ' 
1119 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
111b 21 90 fd				ld hl, input_cursor 
111e 34					inc (hl) 
111f 18 ed				jr .insknwn 
1121			 
1121			.inspace: 
1121			 
1121 cd ca 11				call input_curptr	 
1124 7e					ld a,(hl)	 
1125 fe 00				cp 0 
1127 ca 22 10				jp z, .inmain    ; end of string 
112a			 
112a			; if we are on a word, then move off of it 
112a			 
112a fe 20				cp ' ' 
112c c2 22 10				jp nz, .inmain     ; we are on non space so at next word 
112f 21 90 fd				ld hl, input_cursor 
1132 34					inc (hl) 
1133 18 ec				jr .inspace 
1135			 
1135			 
1135			 
1135			 
1135			input_prvword: 
1135				; jump to the start of previous word before the cursor 
1135			 
1135			; where are we to start with currently? 
1135			 
1135 cd ca 11				call input_curptr	 
1138 7e					ld a, (hl) 
1139 fe 20				cp ' ' 
113b 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
113d			 
113d			 
113d			 
113d			.inskpwn:	 
113d 3a 90 fd				ld a,(input_cursor) 
1140 fe 00				cp 0 
1142 ca 22 10				jp z, .inmain    ; start of string 
1145			 
1145			;if we are on a word, then move off of it 
1145			 
1145 cd ca 11				call input_curptr	 
1148 7e					ld a, (hl) 
1149 fe 20				cp ' ' 
114b 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
114d					;jp z, .inmain    ; start of string 
114d 21 90 fd				ld hl, input_cursor 
1150 35					dec (hl) 
1151 18 ea				jr .inskpwn 
1153			.iwstart: 
1153 21 90 fd				ld hl, input_cursor 
1156 34					inc (hl) 
1157 c3 22 10				jp .inmain 
115a					 
115a			 
115a			.inspacep: 
115a			 
115a					;jp .inmain    ; start of string 
115a			 
115a			 
115a			 
115a 3a 90 fd				ld a,(input_cursor) 
115d fe 00				cp 0 
115f ca 22 10				jp z, .inmain    ; start of string 
1162			 
1162			; if we are on a word, then move off of it 
1162			 
1162 cd ca 11				call input_curptr	 
1165 7e					ld a, (hl) 
1166 fe 20				cp ' ' 
1168 c2 71 11				jp nz, .incharp     ; we are on non space so at end of prev word 
116b 21 90 fd				ld hl, input_cursor 
116e 35					dec (hl) 
116f 18 e9				jr .inspacep 
1171			 
1171			 
1171			.incharp:	 
1171					; eat the word to get to the start 
1171 3a 90 fd				ld a,(input_cursor) 
1174 fe 00				cp 0 
1176 ca 22 10				jp z, .inmain    ; start of string 
1179			 
1179			; if we are on a word, then move off of it 
1179			 
1179 cd ca 11				call input_curptr	 
117c 7e					ld a, (hl) 
117d fe 20				cp ' ' 
117f 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
1181 21 90 fd				ld hl, input_cursor 
1184 35					dec (hl) 
1185 18 ea				jr .incharp 
1187			.ipwordst: 
1187					; at space before the prev word so reposition over it 
1187 21 90 fd				ld hl, input_cursor 
118a 34					inc (hl) 
118b 18 b0				jr .inskpwn 
118d					 
118d			 
118d			 
118d			input_left: 
118d				; move cursor left 
118d 21 90 fd			ld hl, input_cursor 
1190 35				dec (hl) 
1191			;	cp 0 
1191			;	jp z, .inmain    ; ignore left as at the start of the string 
1191 c3 22 10			jp .inmain 
1194			 
1194			input_right: 
1194				; move cursor right 
1194				 
1194				;ld a, (input_size) 
1194				;ld b, a 
1194 21 90 fd			ld hl, input_cursor 
1197 34				inc (hl) 
1198				;dec b 
1198				;cp 0 
1198				;jp z, .inmain   ; ignore as at end of the string buffer 
1198				;ld a, b 
1198				;inc a 
1198				;ld (input_cursor), a 
1198 c3 22 10			jp .inmain 
119b			 
119b			 
119b			 
119b			input_disp_ref: 
119b				; display the text from start of buffer (ie full refresh) 
119b 3a 9f fd			ld a, (input_at_pos) 
119e 2a a2 fd			ld hl,(input_start) 
11a1 eb				ex de, hl 
11a2 cd ae 0d			call str_at_display  
11a5 c9				ret 
11a6			input_disp_oncur: 
11a6				; display the text from cursor position to end of buffer 
11a6				; TODO position start of string at cursor position on screen 
11a6				; TODO draw from that point on 
11a6 3a 90 fd			ld a, (input_cursor) 
11a9 47				ld b, a 
11aa 3a 9f fd			ld a, (input_at_pos) 
11ad 80				add b 
11ae 48				ld c, b     ; save a 
11af 78				ld a, b     ; inc string start for cursor 
11b0 2a a2 fd			ld hl,(input_start) 
11b3 cd cf 0f			call addatohl 
11b6 eb				ex de, hl 
11b7 79				ld a, c 
11b8 cd ae 0d			call str_at_display  
11bb c9				ret 
11bc			 
11bc			input_nxtw: 
11bc				; Find next word 
11bc c9				ret 
11bd			 
11bd			input_prvw: 
11bd				; Find previous word 
11bd c9				ret 
11be			 
11be			input_lenrem:   
11be				; Calculate the length of string remaining from current cursor 
11be				; position to end of buffer (exc null term) 
11be				 
11be 3a 90 fd			ld a, (input_cursor) 
11c1 4f				ld c, a 
11c2 3a a1 fd			ld a, (input_size) 
11c5 91				sub c 
11c6 06 00			ld b, 0 
11c8 0d				dec c 
11c9 c9				ret	 
11ca			 
11ca			input_curptr: 
11ca				; calc address of the character under the cursor 
11ca				 
11ca 2a a2 fd			ld hl, (input_start) 
11cd 3a 90 fd			ld a, (input_cursor) 
11d0 cd cf 0f			call addatohl 
11d3 c9				ret 
11d4			 
11d4			input_inschr: 
11d4				; Insert char at cursor position 
11d4 f5				push af   ; save char 
11d5				;call input_lenrem    ; get bc length of remaining string 
11d5			 
11d5				 
11d5 cd ca 11			call input_curptr 
11d8			;	ld hl, (input_start) 
11d8			;	ld a, (input_cursor) 
11d8			;	call addatohl 
11d8				;push hl   ; save to come back to 
11d8			 
11d8				; shift everything up one to end of buffer 
11d8			 
11d8				;push hl 
11d8				;dec de 
11d8				;inc de 
11d8			;	ldir 
11d8				 
11d8				;pop hl 
11d8			 
11d8				; are we adding to the end of line? 
11d8			 
11d8 3a 90 fd			ld a, (input_cursor) 
11db 47				ld b, a 
11dc 3a 95 fd			ld a, (input_len) 
11df b8				cp b 
11e0 20 09			jr nz, .insmid   ; no, insert in middle of text 
11e2			 
11e2				; tack on the end of the line 
11e2 f1				pop af 
11e3 77				ld (hl), a   ; save new char 
11e4 23				inc hl 
11e5 3e 00			ld a, 0 
11e7 77				ld (hl), a 
11e8 c3 94 11			jp input_right 
11eb				 
11eb			.insmid: 
11eb				; hl has insertion point so move everything up one to allow for insertion 
11eb				;call input_shiftright 
11eb f1				pop af 
11ec			 
11ec			.shufinsmid: 
11ec 47				ld b, a     ; b contains new char, c prev char at this position  
11ed 7e				ld a, (hl) 
11ee			 
11ee fe 00			cp 0    ; at end of string need to then dump new char and add term 
11f0 28 07			jr z, .endinsmid 
11f2 4f				ld c, a 
11f3 78				ld a, b 
11f4 77				ld (hl), a 
11f5 23				inc hl 
11f6 79				ld a, c 
11f7 18 f3			jr .shufinsmid 
11f9				 
11f9			 
11f9			 
11f9			 
11f9			.endinsmid: 
11f9 78				ld a, b 
11fa 77				ld (hl), a 
11fb 23				inc hl 
11fc 3e 00			ld a, 0 
11fe 77				ld (hl), a 
11ff			 
11ff			 
11ff			;	ld (hl), a   ; save new char 
11ff			 
11ff c3 94 11			jp input_right 
1202			 
1202			;input_shiftright: 
1202			;	; shift text right at cursor, hl has shift start 
1202			;	push hl 
1202			;	push de 
1202			;	push bc 
1202			; 
1202			; 
1202			;	; move to end of string past zero term 
1202			;	ld hl,(input_start) 
1202			;	ld a, (input_len) 
1202			;	call addatohl 
1202			;	inc hl 
1202			;;	inc hl 
1202			;;	inc hl 
1202			;	ld a, 0 
1202			;	ld (hl), a 
1202			;;	dec hl 
1202			;	 
1202			;;	ld (hl), a 
1202			;;	dec hl 
1202			; 
1202			;	push hl 
1202			;	pop de 
1202			;	inc de 
1202			;	 
1202			; 
1202			;;	ld hl,(input_start) 
1202			;;	ld a, (input_cursor) 
1202			;;	call addatohl 
1202			; 
1202			; 
1202			;	; calc how many bytes from cursor pos to end of string we need to shift 
1202			;	call input_lenrem    ; get bc length of remaining string 
1202			;	;ld a, (input_cursor) 
1202			;	;ld c, a 
1202			;	ld a, (input_len) 
1202			;	cp 2 
1202			;	jr z, .iskipzero	 
1202			;	;sub c 
1202			;	;inc a 
1202			;	;ld c, a 
1202			;	;ld b, 0 
1202			;	inc c 
1202			;	inc c 
1202			;	; move data 
1202			;	lddr 
1202			;.iskipzero: 
1202			; 
1202			;	pop bc 
1202			;	pop de 
1202			;	pop hl 
1202			;	ret	 
1202			 
1202			input_delchar: 
1202				; Delete char at cursor position 
1202 cd be 11			call input_lenrem    ; get bc length of remaining string 
1205 2a a2 fd			ld hl, (input_start) 
1208 3a 90 fd			ld a, (input_cursor) 
120b cd cf 0f			call addatohl 
120e			 
120e e5				push hl 
120f d1				pop de 
1210 1b				dec de 
1211			 
1211			.dl:	 
1211 ed a0			ldi  
1213 7e				ld a, (hl) 
1214 fe 00			cp 0 
1216 28 02			jr z, .dldone 
1218 18 f7			jr .dl 
121a			.dldone: 
121a ed a0			ldi 
121c			 
121c c3 8d 11			jp input_left 
121f			 
121f			 
121f			endif 
121f			 
121f			 
121f			 
121f			if EDIT_V1 
121f			input_str: 
121f			 
121f				    	ld (input_at_pos),a      ; save display position to start 
121f					add c 
121f					ld (input_at_cursor),a	; save draw pos of cursor 
121f					ld (input_start), hl     ; save ptr to buffer 
121f					ld a, c 
121f					call addatohl 
121f					ld (input_ptr), hl     ; save ptr to point under the cursor 
121f					ld a,d 
121f				        ld (input_size), a       ; save length of input area 
121f					ld a, c 
121f					ld (input_cursor),a      ; init cursor start position  
121f					ld a,e 
121f				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
121f					 
121f					 
121f			 
121f			;		ld a,(input_ptr) 
121f			;		ld (input_under_cursor),a 	; save what is under the cursor 
121f			 
121f			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
121f					; init cursor shape if not set by the cin routines 
121f					ld hl, cursor_shape 
121f			if BASE_KEV 
121f					ld a, 255 
121f			else 
121f					ld a, '#' 
121f			endif 
121f					ld (hl), a 
121f					inc hl 
121f					ld a, 0 
121f					ld (hl), a 
121f			 
121f					ld a, CUR_BLINK_RATE 
121f					ld (input_cur_flash), a 
121f					ld a, 1 
121f					ld (input_cur_onoff),a 
121f			 
121f			;	if DEBUG_INPUT 
121f			;		push af 
121f			;		ld a, 'I' 
121f			;		ld (debug_mark),a 
121f			;		pop af 
121f			;		CALLMONITOR 
121f			;	endif 
121f			.is1:		; main entry loop 
121f			 
121f			 
121f			 
121f					; pause 1ms 
121f			 
121f					ld a, 1 
121f					call aDelayInMS 
121f			 
121f					; dec flash counter 
121f					ld a, (input_cur_flash) 
121f					dec a 
121f					ld (input_cur_flash), a 
121f					cp 0 
121f					jr nz, .nochgstate 
121f			 
121f			 
121f					; change state 
121f					ld a,(input_cur_onoff) 
121f					neg 
121f					ld (input_cur_onoff),a 
121f			 
121f			 
121f					; reset on change of state 
121f					ld a, CUR_BLINK_RATE 
121f					ld (input_cur_flash), a 
121f			 
121f			.nochgstate: 
121f					 
121f					 
121f			 
121f					; display cursor  
121f			 
121f			;		ld hl, (input_start) 
121f			;		ld a, (input_cursor) 
121f			;		call addatohl 
121f			 
121f					; get char under cursor and replace with cursor 
121f			ld hl, (input_ptr) 
121f			;		ld a, (hl) 
121f			;		ld (input_under_cursor),a 
121f			;		ld a, '_' 
121f			;		ld (hl), a 
121f			 
121f					; display string 
121f			 
121f					ld de, (input_start) 
121f					ld a, (input_at_pos) 
121f					call str_at_display 
121f			;	        call update_display 
121f			 
121f					; find place to put the cursor 
121f			;		add h 
121f			;		ld l, display_row_1 
121f			;		sub l 
121f			; (input_at_pos) 
121f					;ld c, a 
121f			;		ld a, (input_cursor) 
121f			;		ld l, (input_at_pos) 
121f			;		;ld b, h 
121f			;		add l 
121f			;		ld (input_at_cursor),a 
121f					;ld l,h 
121f			 
121f			;		ld h, 0 
121f			;		ld l,(input_at_pos) 
121f			;		ld a, (input_cursor) 
121f			;		call addatohl 
121f			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
121f			;		call subafromhl 
121f			;		ld a,l 
121f			;		ld (input_at_cursor), a 
121f			 
121f				if DEBUG_INPUT 
121f					ld a, (hardware_diag) 
121f					cp 0 
121f					jr z, .skip_input_diag 
121f			 
121f					ld a,(input_at_pos) 
121f					ld hl, LFSRSeed 
121f					call hexout 
121f					ld a, (input_cursor) 
121f					ld hl, LFSRSeed+2 
121f					call hexout 
121f					ld a,(input_at_cursor) 
121f					ld hl, LFSRSeed+4 
121f					call hexout 
121f			 
121f					ld a,(input_cur_onoff) 
121f					ld hl, LFSRSeed+6 
121f					call hexout 
121f			 
121f					ld a,(input_cur_flash) 
121f					ld hl, LFSRSeed+8 
121f					call hexout 
121f			 
121f					ld a,(input_len) 
121f					ld hl, LFSRSeed+10 
121f					call hexout 
121f					ld hl, LFSRSeed+12 
121f					ld a, 0 
121f					ld (hl),a 
121f					ld a, display_row_4 
121f					ld de, LFSRSeed 
121f					call str_at_display 
121f					.skip_input_diag: 
121f				endif 
121f			 
121f					; decide on if we are showing the cursor this time round 
121f			 
121f					ld a, (input_cur_onoff) 
121f					cp 255 
121f					jr z, .skipcur 
121f			 
121f			 
121f					ld a,(input_at_cursor) 
121f					ld de, cursor_shape 
121f					call str_at_display 
121f			 
121f					; save length of current input string 
121f					ld hl, (input_start) 
121f					ld a, 0 
121f					call strlent 
121f					ld a,l 
121f					ld (input_len),a 
121f			 
121f			.skipcur: 
121f			 
121f				        call update_display 
121f					 
121f			 
121f			 
121f					; wait 
121f				 
121f					; TODO loop without wait to flash the cursor and char under cursor	 
121f					call cin    ; _wait 
121f			 
121f					cp 0 
121f					jp z, .is1 
121f			 
121f					; get ptr to char to input into 
121f			 
121f					ld c,a 
121f					ld hl, (input_start) 
121f					ld a, (input_cursor) 
121f					call addatohl 
121f					ld (input_ptr), hl 
121f					ld a,c 
121f			 
121f					; replace char under cursor 
121f			 
121f			;		ld hl, (input_ptr) 
121f			;		ld a, (input_under_cursor) 	; get what is under the cursor 
121f			;		ld (hl), a 
121f			 
121f			;	if DEBUG_INPUT 
121f			;		push af 
121f			;		ld a, 'i' 
121f			;		ld (debug_mark),a 
121f			;		pop af 
121f			;		CALLMONITOR 
121f			;	endif 
121f					cp KEY_HOME 
121f					jr nz, .iske 
121f			 
121f					ld a, (input_at_pos) 
121f					ld (input_at_cursor),a 
121f					ld a, 0 
121f					ld (input_cursor), a 
121f					jp .is1 
121f					 
121f			.iske:		cp KEY_END 
121f					jr nz, .isknw 
121f					jp .is1 
121f			 
121f			.isknw:		cp KEY_NEXTWORD 
121f					jr nz, .iskpw 
121f			 
121f			.isknwm:	ld hl, (input_ptr) 
121f					ld a,(hl)	 
121f					cp 0 
121f					jp z, .is1    ; end of string 
121f					cp ' ' 
121f					jp z, .is1    ; end of word 
121f					inc hl 
121f					ld (input_ptr), hl 
121f					ld a, (input_at_cursor) 
121f					inc a 
121f					ld (input_at_cursor), a 
121f					jr .isknwm 
121f			 
121f			.iskpw:		cp KEY_PREVWORD 
121f					jr nz, .iskl 
121f			.iskpwm:	 
121f					ld hl, (input_ptr) 
121f					ld a,(hl)	 
121f					cp 0  
121f					jp z, .is1    ; end of string 
121f					cp ' ' 
121f					jp z, .is1    ; end of word 
121f					dec hl 
121f					ld (input_ptr), hl 
121f					ld a, (input_at_cursor) 
121f					dec a 
121f					ld (input_at_cursor), a 
121f					jr .iskpwm 
121f			 
121f			 
121f			.iskl:		cp KEY_LEFT 
121f					jr nz, .isk1 
121f			 
121f					ld a, (input_cursor) 
121f			 
121f					cp 0 
121f					jp z, .is1 		; at start of line to ignore  
121f			 
121f					dec  a 		; TODO check underflow 
121f					ld (input_cursor), a 
121f			 
121f					ld hl, (input_ptr) 
121f					dec hl 
121f					ld (input_ptr), hl 
121f					 
121f					ld a, (input_at_cursor) 
121f					dec a 
121f					ld (input_at_cursor), a 
121f			 
121f					ld a, 1		; show cursor moving 
121f					ld (input_cur_onoff),a 
121f					ld a, CUR_BLINK_RATE 
121f					ld (input_cur_flash), a 
121f			 
121f					jp .is1 
121f			 
121f			.isk1:		cp KEY_RIGHT 
121f					jr nz, .isk2 
121f			 
121f					ld a,(input_len)		; TODO BUG why cant i load e direct? 
121f					ld e,a 
121f					ld a, (input_cursor) 
121f					cp e 
121f					jp z, .is1		; at the end of string so dont go right 
121f			 
121f					inc  a 		; TODO check overflow 
121f					ld (input_cursor), a 
121f			 
121f					ld a, (input_at_cursor) 
121f					inc a 
121f					ld (input_at_cursor), a 
121f			 
121f					ld hl, (input_ptr) 
121f					inc hl 
121f					ld (input_ptr), hl 
121f			 
121f					ld a, 1		; show cursor moving 
121f					ld (input_cur_onoff),a 
121f					ld a, CUR_BLINK_RATE 
121f					ld (input_cur_flash), a 
121f			 
121f					jp .is1 
121f			 
121f			.isk2:		cp KEY_UP 
121f			 
121f					jr nz, .isk3 
121f			 
121f					; swap last command with the current on 
121f			 
121f					; move cursor to start of string 
121f					ld hl, (input_start) 
121f					ld (input_ptr), hl 
121f			 
121f					ld a, (input_at_pos) 
121f					ld (input_at_cursor), a 
121f			 
121f					ld a, 0 
121f					ld (input_cursor), a 
121f					 
121f					; swap input and last command buffers 
121f			 
121f					ld hl, os_cli_cmd 
121f					ld de, os_last_cmd 
121f					ld b, 255 
121f			.swap1:		ld a, (hl) 
121f					ld c,a 
121f					ld a, (de) 
121f					ld (hl), a 
121f					ld a,c 
121f					ld (de),a 
121f					inc hl 
121f					inc de 
121f					djnz .swap1 
121f			 
121f			 
121f			 
121f			 
121f			 
121f					jp .is1 
121f			 
121f			.isk3:		cp KEY_BS 
121f					jr nz, .isk4 
121f			 
121f					ld a, (input_cursor) 
121f			 
121f					cp 0 
121f					jp z, .is1 		; at start of line to ignore  
121f			 
121f					dec  a 		; TODO check underflow 
121f					ld (input_cursor), a 
121f			 
121f					; hl is source 
121f					; de needs to be source - 1 
121f			 
121f			;		ld a, 0 
121f			;		dec hl 
121f			;		ld (hl), a 
121f			 
121f					ld hl, (input_ptr) 
121f					dec hl 
121f					ld (input_ptr), hl 
121f			 
121f					; shift all data 
121f			 
121f					push hl 
121f					inc hl 
121f					pop de 
121f					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
121f					ld c,a 
121f					ld b,0 
121f					ldir  
121f			 
121f			 
121f			 
121f			 
121f					ld a, (input_at_cursor) 
121f					dec a 
121f					ld (input_at_cursor), a 
121f			 
121f			 
121f					ld a, 1		; show cursor moving 
121f					ld (input_cur_onoff),a 
121f					ld a, CUR_BLINK_RATE 
121f					ld (input_cur_flash), a 
121f			 
121f					; remove char 
121f					ld a, (input_at_cursor) 
121f					inc a 
121f					ld de,.iblank 
121f					call str_at_display 
121f			 
121f					jp .is1 
121f			 
121f			.isk4:		cp KEY_CR 
121f					jr z, .endinput 
121f			 
121f					; else add the key press to the end 
121f			 
121f					ld c, a			; save key pressed 
121f			 
121f					ld a,(hl)		; get what is currently under char 
121f			 
121f					cp 0			; we are at the end of the string 
121f					jr nz, .onchar 
121f					 
121f					; add a char to the end of the string 
121f				 
121f					ld (hl),c 
121f					inc hl 
121f			;		ld a,' ' 
121f			;		ld (hl),a 
121f			;		inc hl 
121f					ld a,0 
121f					ld (hl),a 
121f					dec hl 
121f			 
121f					ld a, (input_cursor) 
121f					inc a				; TODO check max string length and scroll  
121f					ld (input_cursor), a		; inc cursor pos 
121f							 
121f					ld a, (input_at_cursor) 
121f					inc a 
121f					ld (input_at_cursor), a 
121f			 
121f					ld hl, (input_ptr) 
121f					inc hl 
121f					ld (input_ptr), hl 
121f			 
121f					ld hl, (input_ptr) 
121f					inc hl 
121f					ld (input_ptr), hl 
121f			;	if DEBUG_INPUT 
121f			;		push af 
121f			;		ld a, '+' 
121f			;		ld (debug_mark),a 
121f			;		pop af 
121f			;		CALLMONITOR 
121f			;	endif 
121f					ld a, 1		; show cursor moving 
121f					ld (input_cur_onoff),a 
121f					ld a, CUR_BLINK_RATE 
121f					ld (input_cur_flash), a 
121f					jp .is1 
121f					 
121f			 
121f			 
121f					; if on a char then insert 
121f			.onchar: 
121f			 
121f					; TODO over flow check: make sure insert does not blow out buffer 
121f			 
121f					; need to do some maths to use lddr 
121f			 
121f					push hl   ; save char pos 
121f					push bc 
121f			 
121f					ld hl, (input_start) 
121f					ld a, (input_len) 
121f					call addatohl  		; end of string 
121f					inc hl 
121f					inc hl		; past zero term 
121f					push hl 
121f					inc hl 
121f					push hl  
121f			 
121f								; start and end of lddr set, now how much to move? 
121f			 
121f							 
121f					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
121f					ld b,a 
121f					ld a,(input_len) 
121f					ld e,a 
121f					sub b 
121f					inc a		;?? 
121f					inc a		;?? 
121f					inc a		;?? 
121f			 
121f					ld b,0 
121f					ld c,a 
121f			 
121f				if DEBUG_INPUT 
121f					push af 
121f					ld a, 'i' 
121f					ld (debug_mark),a 
121f					pop af 
121f			;		CALLMONITOR 
121f				endif 
121f					pop de 
121f					pop hl 
121f				if DEBUG_INPUT 
121f					push af 
121f					ld a, 'I' 
121f					ld (debug_mark),a 
121f					pop af 
121f			;		CALLMONITOR 
121f				endif 
121f					lddr 
121f				 
121f			 
121f			 
121f					; TODO have a key for insert/overwrite mode???? 
121f					pop bc 
121f					pop hl 
121f					ld (hl), c		; otherwise overwrite current char 
121f					 
121f			 
121f			 
121f			 
121f					ld a, (input_cursor) 
121f					inc  a 		; TODO check overflow 
121f					ld (input_cursor), a 
121f			 
121f					ld a, (input_at_cursor) 
121f					inc a 
121f					ld (input_at_cursor), a 
121f			 
121f					jp .is1 
121f			 
121f			.endinput:	; TODO look for end of string 
121f			 
121f					; add trailing space for end of token 
121f			 
121f					ld hl, (input_start) 
121f					ld a,(input_len) 
121f					call addatohl 
121f					ld a, ' ' 
121f					ld (hl),a 
121f					; TODO eof of parse marker 
121f			 
121f					inc hl 
121f					ld a, 0 
121f					ld (hl),a 
121f			 
121f			 
121f					ret 
121f			 
121f			.iblank: db " ",0 
121f			 
121f			 
121f			input_str_prev:	ld (input_at_pos), a 
121f					ld (input_start), hl 
121f					ld a,1			; add cursor 
121f					ld (hl),a 
121f					inc hl 
121f					ld a,0 
121f					ld (hl),a 
121f					ld (input_ptr), hl 
121f					ld a,d 
121f					ld (input_size), a 
121f					ld a,0 
121f					ld (input_cursor),a 
121f			.instr1:	 
121f			 
121f					; TODO do block cursor 
121f					; TODO switch cursor depending on the modifer key 
121f			 
121f					; update cursor shape change on key hold 
121f			 
121f					ld hl, (input_ptr) 
121f					dec hl 
121f					ld a,(cursor_shape) 
121f					ld (hl), a 
121f			 
121f					; display entered text 
121f					ld a,(input_at_pos) 
121f			            	CALL fLCD_Pos       ;Position cursor to location in A 
121f			            	LD   de, (input_start) 
121f			            	CALL fLCD_Str       ;Display string pointed to by DE 
121f			 
121f					call cin 
121f					cp 0 
121f					jr z, .instr1 
121f			 
121f					; proecess keyboard controls first 
121f			 
121f					ld hl,(input_ptr) 
121f			 
121f					cp KEY_CR	 ; pressing enter ends input 
121f					jr z, .instrcr 
121f			 
121f					cp KEY_BS 	; back space 
121f					jr nz, .instr2 
121f					; process back space 
121f			 
121f					; TODO stop back space if at start of string 
121f					dec hl 
121f					dec hl ; to over write cursor 
121f					ld a,(cursor_shape) 
121f					;ld a,0 
121f					ld (hl),a 
121f					inc hl 
121f					ld a," " 
121f					ld (hl),a 
121f					ld (input_ptr),hl 
121f					 
121f			 
121f					jr .instr1 
121f			 
121f			.instr2:	cp KEY_LEFT    ; cursor left 
121f					jr nz, .instr3 
121f					dec hl 
121f					ld (input_ptr),hl 
121f					jr .instr1 
121f				 
121f			.instr3:	cp KEY_RIGHT      ; cursor right 
121f					jr nz, .instr4 
121f					inc hl 
121f					ld (input_ptr),hl 
121f					jr .instr1 
121f			 
121f			.instr4:	cp KEY_HOME    ; jump to start of line 
121f					jr nz, .instr5 
121f					dec hl 
121f					ld (input_ptr),hl 
121f					jr .instr1 
121f			 
121f			.instr5:	cp KEY_END     ; jump to end of line 
121f					jr nz, .instr6 
121f					dec hl 
121f					ld (input_ptr),hl 
121f					jr .instr1 
121f			.instr6:        cp KEY_UP      ; recall last command 
121f					jr nz, .instrnew 
121f			 
121f				ld hl, scratch 
121f				ld de, os_last_cmd 
121f				call strcpy 
121f					jr .instr1 
121f			 
121f			 
121f			.instrnew:	; no special key pressed to see if we have room to store it 
121f			 
121f					; TODO do string size test 
121f			 
121f					dec hl ; to over write cursor 
121f					ld (hl),a 
121f					inc hl 
121f					ld a,(cursor_shape) 
121f					ld (hl),a 
121f					inc hl 
121f					ld a,0 
121f					ld (hl),a 
121f			 
121f					ld (input_ptr),hl 
121f					 
121f					jr .instr1 
121f			.instrcr:	dec hl		; remove cursor 
121f					ld a,' '	; TODO add a trailing space for safety 
121f					ld (hl),a 
121f					inc hl 
121f					ld a,0 
121f					ld (hl),a 
121f			 
121f			 
121f					; if at end of line scroll up    
121f					; TODO detecting only end of line 4 for scroll up  
121f			 
121f					;ld   
121f			 
121f					ret 
121f			 
121f			 
121f			endif 
121f			; strcpy hl = dest, de source 
121f			 
121f 1a			strcpy:   LD   A, (DE)        ;Get character from string 
1220 b7			            OR   A              ;Null terminator? 
1221 c8			            RET  Z              ;Yes, so finished 
1222 1a					ld a,(de) 
1223 77					ld (hl),a 
1224 13			            INC  DE             ;Point to next character 
1225 23					inc hl 
1226 18 f7		            JR   strcpy       ;Repeat 
1228 c9					ret 
1229			 
1229			 
1229			; TODO string_at  
1229			; pass string which starts with lcd offset address and then null term string 
1229			 
1229			; TODO string to dec 
1229			; TODO string to hex 
1229			; TODO byte to string hex 
1229			; TODO byte to string dec 
1229			 
1229			 
1229			 
1229			; from z80uartmonitor 
1229			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1229			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
1229			; pass hl for where to put the text 
1229			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1229 c5			hexout:	PUSH BC 
122a f5					PUSH AF 
122b 47					LD B, A 
122c					; Upper nybble 
122c cb 3f				SRL A 
122e cb 3f				SRL A 
1230 cb 3f				SRL A 
1232 cb 3f				SRL A 
1234 cd 44 12				CALL tohex 
1237 77					ld (hl),a 
1238 23					inc hl	 
1239					 
1239					; Lower nybble 
1239 78					LD A, B 
123a e6 0f				AND 0FH 
123c cd 44 12				CALL tohex 
123f 77					ld (hl),a 
1240 23					inc hl	 
1241					 
1241 f1					POP AF 
1242 c1					POP BC 
1243 c9					RET 
1244					 
1244			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1244			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1244			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1244			tohex: 
1244 e5					PUSH HL 
1245 d5					PUSH DE 
1246 16 00				LD D, 0 
1248 5f					LD E, A 
1249 21 51 12				LD HL, .DATA 
124c 19					ADD HL, DE 
124d 7e					LD A, (HL) 
124e d1					POP DE 
124f e1					POP HL 
1250 c9					RET 
1251			 
1251			.DATA: 
1251 30					DEFB	30h	; 0 
1252 31					DEFB	31h	; 1 
1253 32					DEFB	32h	; 2 
1254 33					DEFB	33h	; 3 
1255 34					DEFB	34h	; 4 
1256 35					DEFB	35h	; 5 
1257 36					DEFB	36h	; 6 
1258 37					DEFB	37h	; 7 
1259 38					DEFB	38h	; 8 
125a 39					DEFB	39h	; 9 
125b 41					DEFB	41h	; A 
125c 42					DEFB	42h	; B 
125d 43					DEFB	43h	; C 
125e 44					DEFB	44h	; D 
125f 45					DEFB	45h	; E 
1260 46					DEFB	46h	; F 
1261			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1261			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1261			;;    subtract $30, if result > 9 then subtract $7 more 
1261			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1261			atohex: 
1261 d6 30				SUB $30 
1263 fe 0a				CP 10 
1265 f8					RET M		; If result negative it was 0-9 so we're done 
1266 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1268 c9					RET		 
1269			 
1269			 
1269			 
1269			 
1269			; Get 2 ASCII characters as hex byte from pointer in hl 
1269			 
1269			BYTERD: 
1269 16 00			LD	D,00h		;Set up 
126b cd 73 12			CALL	HEXCON		;Get byte and convert to hex 
126e 87				ADD	A,A		;First nibble so 
126f 87				ADD	A,A		;multiply by 16 
1270 87				ADD	A,A		; 
1271 87				ADD	A,A		; 
1272 57				LD	D,A		;Save hi nibble in D 
1273			HEXCON: 
1273 7e				ld a, (hl)		;Get next chr 
1274 23				inc hl 
1275 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1277 fe 0a			CP	00Ah		;Is it 0-9 ? 
1279 38 02			JR	C,NALPHA	;If so miss next bit 
127b d6 07			SUB	007h		;Else convert alpha 
127d			NALPHA: 
127d b2				OR	D		;Add hi nibble back 
127e c9				RET			; 
127f			 
127f			 
127f			; 
127f			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
127f			; Since the routines get_byte and therefore get_nibble are called, only valid 
127f			; characters (0-9a-f) are accepted. 
127f			; 
127f			;get_word        push    af 
127f			;                call    get_byte        ; Get the upper byte 
127f			;                ld      h, a 
127f			;                call    get_byte        ; Get the lower byte 
127f			;                ld      l, a 
127f			;                pop     af 
127f			;                ret 
127f			; 
127f			; Get a byte in hexadecimal notation. The result is returned in A. Since 
127f			; the routine get_nibble is used only valid characters are accepted - the  
127f			; input routine only accepts characters 0-9a-f. 
127f			; 
127f c5			get_byte:        push    bc              ; Save contents of B (and C) 
1280 7e					ld a,(hl) 
1281 23					inc hl 
1282 cd a7 12		                call    nibble2val      ; Get upper nibble 
1285 cb 07		                rlc     a 
1287 cb 07		                rlc     a 
1289 cb 07		                rlc     a 
128b cb 07		                rlc     a 
128d 47			                ld      b, a            ; Save upper four bits 
128e 7e					ld a,(hl) 
128f cd a7 12		                call    nibble2val      ; Get lower nibble 
1292 b0			                or      b               ; Combine both nibbles 
1293 c1			                pop     bc              ; Restore B (and C) 
1294 c9			                ret 
1295			; 
1295			; Get a hexadecimal digit from the serial line. This routine blocks until 
1295			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1295			; to the serial line interface. The lower 4 bits of A contain the value of  
1295			; that particular digit. 
1295			; 
1295			;get_nibble      ld a,(hl)           ; Read a character 
1295			;                call    to_upper        ; Convert to upper case 
1295			;                call    is_hex          ; Was it a hex digit? 
1295			;                jr      nc, get_nibble  ; No, get another character 
1295			 ;               call    nibble2val      ; Convert nibble to value 
1295			 ;               call    print_nibble 
1295			 ;               ret 
1295			; 
1295			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1295			; A valid hexadecimal digit is denoted by a set C flag. 
1295			; 
1295			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1295			;                ret     nc              ; Yes 
1295			;                cp      '0'             ; Less than '0'? 
1295			;                jr      nc, is_hex_1    ; No, continue 
1295			;                ccf                     ; Complement carry (i.e. clear it) 
1295			;                ret 
1295			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1295			;                ret     c               ; Yes 
1295			;                cp      'A'             ; Less than 'A'? 
1295			;                jr      nc, is_hex_2    ; No, continue 
1295			;                ccf                     ; Yes - clear carry and return 
1295			;                ret 
1295			;is_hex_2        scf                     ; Set carry 
1295			;                ret 
1295			; 
1295			; Convert a single character contained in A to upper case: 
1295			; 
1295 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1297 d8			                ret     c 
1298 fe 7b		                cp      'z' + 1         ; > 'z'? 
129a d0			                ret     nc              ; Nothing to do, either 
129b e6 5f		                and     $5f             ; Convert to upper case 
129d c9			                ret 
129e			 
129e			 
129e			to_lower: 
129e			 
129e			   ; if char is in [A-Z] make it lower case 
129e			 
129e			   ; enter : a = char 
129e			   ; exit  : a = lower case char 
129e			   ; uses  : af 
129e			 
129e fe 41		   cp 'A' 
12a0 d8			   ret c 
12a1			    
12a1 fe 5b		   cp 'Z'+1 
12a3 d0			   ret nc 
12a4			    
12a4 f6 20		   or $20 
12a6 c9			   ret 
12a7			 
12a7			; 
12a7			; Expects a hexadecimal digit (upper case!) in A and returns the 
12a7			; corresponding value in A. 
12a7			; 
12a7 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
12a9 38 02		                jr      c, nibble2val_1 ; Yes 
12ab d6 07		                sub     7               ; Adjust for A-F 
12ad d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
12af e6 0f		                and     $f              ; Only return lower 4 bits 
12b1 c9			                ret 
12b2			; 
12b2			; Print_nibble prints a single hex nibble which is contained in the lower  
12b2			; four bits of A: 
12b2			; 
12b2			;print_nibble    push    af              ; We won't destroy the contents of A 
12b2			;                and     $f              ; Just in case... 
12b2			;                add     a, '0'             ; If we have a digit we are done here. 
12b2			;                cp      '9' + 1         ; Is the result > 9? 
12b2			;                jr      c, print_nibble_1 
12b2			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
12b2			;print_nibble_1  call    putc            ; Print the nibble and 
12b2			;                pop     af              ; restore the original value of A 
12b2			;                ret 
12b2			;; 
12b2			;; Send a CR/LF pair: 
12b2			; 
12b2			;crlf            push    af 
12b2			;                ld      a, cr 
12b2			;                call    putc 
12b2			;                ld      a, lf 
12b2			;                call    putc 
12b2			;                pop     af 
12b2			;                ret 
12b2			; 
12b2			; Print_word prints the four hex digits of a word to the serial line. The  
12b2			; word is expected to be in HL. 
12b2			; 
12b2			;print_word      push    hl 
12b2			;                push    af 
12b2			;                ld      a, h 
12b2			;                call    print_byte 
12b2			;                ld      a, l 
12b2			;                call    print_byte 
12b2			;                pop     af 
12b2			;                pop     hl 
12b2			;                ret 
12b2			; 
12b2			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
12b2			; The byte to be printed is expected to be in A. 
12b2			; 
12b2			;print_byte      push    af              ; Save the contents of the registers 
12b2			;                push    bc 
12b2			;                ld      b, a 
12b2			;                rrca 
12b2			;                rrca 
12b2			;                rrca 
12b2			;                rrca 
12b2			;                call    print_nibble    ; Print high nibble 
12b2			;                ld      a, b 
12b2			;                call    print_nibble    ; Print low nibble 
12b2			;                pop     bc              ; Restore original register contents 
12b2			;                pop     af 
12b2			;                ret 
12b2			 
12b2			 
12b2			 
12b2			 
12b2			 
12b2			fourehexhl:  
12b2 7e				ld a,(hl) 
12b3 cd 61 12			call atohex 
12b6 cb 3f				SRL A 
12b8 cb 3f				SRL A 
12ba cb 3f				SRL A 
12bc cb 3f				SRL A 
12be 47				ld b, a 
12bf 23				inc hl 
12c0 7e				ld a,(hl) 
12c1 23				inc hl 
12c2 cd 61 12			call atohex 
12c5 80				add b 
12c6 57				ld d,a 
12c7 7e				ld a,(hl) 
12c8 cd 61 12			call atohex 
12cb cb 3f				SRL A 
12cd cb 3f				SRL A 
12cf cb 3f				SRL A 
12d1 cb 3f				SRL A 
12d3 47				ld b, a 
12d4 23				inc hl 
12d5 7e				ld a,(hl) 
12d6 23				inc hl 
12d7 cd 61 12			call atohex 
12da 80				add b 
12db 5f				ld e, a 
12dc d5				push de 
12dd e1				pop hl 
12de c9				ret 
12df			 
12df			; pass hl. returns z set if the byte at hl is a digit 
12df			;isdigithl:  
12df			;	push bc 
12df			;	ld a,(hl) 
12df			;	cp ':' 
12df			;	jr nc, .isdf 		; > 
12df			;	cp '0' 
12df			;	jr c, .isdf		; < 
12df			; 
12df			;	; TODO find a better way to set z 
12df			; 
12df			;	ld b,a 
12df			;	cp b 
12df			;	pop bc 
12df			;	ret 
12df			; 
12df			;.isdf:	; not digit so clear z 
12df			; 
12df			;	; TODO find a better way to unset z 
12df			; 
12df			;	ld b,a 
12df			;	inc b 
12df			;	cp b 
12df			; 
12df			;	pop bc 
12df			;	ret 
12df				 
12df				 
12df			 
12df			 
12df			; pass hl as the four byte address to load 
12df			 
12df			get_word_hl:  
12df e5				push hl 
12e0 cd 7f 12			call get_byte 
12e3				 
12e3 47				ld b, a 
12e4			 
12e4 e1				pop hl 
12e5 23				inc hl 
12e6 23				inc hl 
12e7			 
12e7			; TODO not able to handle a-f  
12e7 7e				ld a,(hl) 
12e8			;	;cp ':' 
12e8			;	cp 'g' 
12e8			;	jr nc, .single_byte_hl 		; > 
12e8			;	cp 'G' 
12e8			;	jr nc, .single_byte_hl 		; > 
12e8			;	cp '0' 
12e8			;	jr c, .single_byte_hl		; < 
12e8			 
12e8				;call isdigithl 
12e8 fe 00			cp 0 
12ea 28 06			jr z, .single_byte_hl 
12ec			 
12ec			.getwhln:   ; hex word so get next byte 
12ec			 
12ec cd 7f 12			call get_byte 
12ef 6f				ld l, a 
12f0 60				ld h,b 
12f1 c9				ret 
12f2 68			.single_byte_hl:   ld l,b 
12f3 26 00				ld h,0 
12f5 c9					ret 
12f6			 
12f6			 
12f6			 
12f6			 
12f6 21 4b 1d			ld hl,asc+1 
12f9			;	ld a, (hl) 
12f9			;	call nibble2val 
12f9 cd 7f 12			call get_byte 
12fc			 
12fc			;	call fourehexhl 
12fc 32 30 f1			ld (scratch+52),a 
12ff				 
12ff 21 2e f1			ld hl,scratch+50 
1302 22 1f f4			ld (os_cur_ptr),hl 
1305			 
1305 c9				ret 
1306			 
1306			 
1306			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
1306			 
1306			; Decimal Unsigned Version 
1306			 
1306			;Number in a to decimal ASCII 
1306			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
1306			;Example: display a=56 as "056" 
1306			;input: a = number 
1306			;Output: a=0,value of a in the screen 
1306			;destroys af,bc (don't know about hl and de) 
1306			DispAToASCII: 
1306 0e 9c			ld	c,-100 
1308 cd 12 13			call	.Na1 
130b 0e f6			ld	c,-10 
130d cd 12 13			call	.Na1 
1310 0e ff			ld	c,-1 
1312 06 2f		.Na1:	ld	b,'0'-1 
1314 04			.Na2:	inc	b 
1315 81				add	a,c 
1316 38 fc			jr	c,.Na2 
1318 91				sub	c		;works as add 100/10/1 
1319 f5				push af		;safer than ld c,a 
131a 78				ld	a,b		;char is in b 
131b			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
131b f1				pop af		;safer than ld a,c 
131c c9				ret 
131d			 
131d			; Decimal Signed Version 
131d			 
131d			; DispA 
131d			; -------------------------------------------------------------- 
131d			; Converts a signed integer value to a zero-terminated ASCII 
131d			; string representative of that value (using radix 10). 
131d			; -------------------------------------------------------------- 
131d			; INPUTS: 
131d			;     HL     Value to convert (two's complement integer). 
131d			;     DE     Base address of string destination. (pointer). 
131d			; -------------------------------------------------------------- 
131d			; OUTPUTS: 
131d			;     None 
131d			; -------------------------------------------------------------- 
131d			; REGISTERS/MEMORY DESTROYED 
131d			; AF HL 
131d			; -------------------------------------------------------------- 
131d			 
131d			;DispHLToASCII: 
131d			;   push    de 
131d			;   push    bc 
131d			; 
131d			;; Detect sign of HL. 
131d			;    bit    7, h 
131d			;    jr     z, ._DoConvert 
131d			; 
131d			;; HL is negative. Output '-' to string and negate HL. 
131d			;    ld     a, '-' 
131d			;    ld     (de), a 
131d			;    inc    de 
131d			; 
131d			;; Negate HL (using two's complement) 
131d			;    xor    a 
131d			;    sub    l 
131d			;    ld     l, a 
131d			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
131d			;    sbc    a, h 
131d			;    ld     h, a 
131d			; 
131d			;; Convert HL to digit characters 
131d			;._DoConvert: 
131d			;    ld     b, 0     ; B will count character length of number 
131d			;-   ld     a, 10 
131d			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
131d			;    push   af 
131d			;    inc    b 
131d			;    ld     a, h 
131d			;    or     l 
131d			;    jr     nz, - 
131d			; 
131d			;; Retrieve digits from stack 
131d			;-   pop    af 
131d			;    or     $30 
131d			;    ld     (de), a 
131d			;    inc    de 
131d			;    djnz   - 
131d			; 
131d			;; Terminate string with NULL 
131d			;    xor    a 
131d			;    ld     (de), a 
131d			; 
131d			;    pop    bc 
131d			;    pop    de 
131d			;    ret 
131d			 
131d			;Comments 
131d			; 
131d			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
131d			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
131d			;    Note that the output string will not be fixed-width. 
131d			; 
131d			;Example Usage 
131d			; 
131d			;    ld    hl, -1004 
131d			;    ld    de, OP1 
131d			;    call  DispA 
131d			;    ld    hl, OP1 
131d			;    syscall  PutS 
131d			 
131d			 
131d			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
131d			 
131d			 
131d			;Converts an ASCII string to an unsigned 16-bit integer 
131d			;Quits when it reaches a non-decimal digit 
131d			 
131d			string_to_uint16: 
131d			atoui_16: 
131d			;Input: 
131d			;     DE points to the string 
131d			;Outputs: 
131d			;     HL is the result 
131d			;     A is the 8-bit value of the number 
131d			;     DE points to the byte after the number 
131d			;Destroys: 
131d			;     BC 
131d			;       if the string is non-empty, BC is HL/10 
131d			;Size:  24 bytes 
131d			;Speed: 42+d(104+{0,9}) 
131d			;       d is the number of digits in the number 
131d			;       max is 640 cycles for a 5 digit number 
131d			;Assuming no leading zeros: 
131d			;1 digit:  146cc 
131d			;2 digit:  250cc 
131d			;3 digit:  354cc or 363cc (avg: 354.126cc) 
131d			;4 digit:  458cc or 467cc (avg: 458.27cc) 
131d			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
131d			;avg: 544.81158447265625cc (544+13297/16384) 
131d			;=============================================================== 
131d 21 00 00		  ld hl,0 
1320			.u16a: 
1320 1a			  ld a,(de) 
1321 d6 30		  sub 30h 
1323 fe 0a		  cp 10 
1325 d0			  ret nc 
1326 13			  inc de 
1327 44			  ld b,h 
1328 4d			  ld c,l 
1329 29			  add hl,hl 
132a 29			  add hl,hl 
132b 09			  add hl,bc 
132c 29			  add hl,hl 
132d 85			  add a,l 
132e 6f			  ld l,a 
132f 30 ef		  jr nc,.u16a 
1331 24			  inc h 
1332 c3 20 13		  jp .u16a 
1335			 
1335			 
1335			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1335			 
1335			;written by Zeda 
1335			;Converts a 16-bit unsigned integer to an ASCII string. 
1335			 
1335			uitoa_16: 
1335			;Input: 
1335			;   DE is the number to convert 
1335			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1335			;Output: 
1335			;   HL points to the null-terminated ASCII string 
1335			;      NOTE: This isn't necessarily the same as the input HL. 
1335 d5			  push de 
1336 c5			  push bc 
1337 f5			  push af 
1338 eb			  ex de,hl 
1339			 
1339 01 f0 d8		  ld bc,-10000 
133c 3e 2f		  ld a,'0'-1 
133e 3c			  inc a 
133f 09			  add hl,bc  
1340 38 fc		   jr c,$-2 
1342 12			  ld (de),a 
1343 13			  inc de 
1344			 
1344 01 e8 03		  ld bc,1000 
1347 3e 3a		  ld a,'9'+1 
1349 3d			  dec a  
134a 09			  add hl,bc  
134b 30 fc		   jr nc,$-2 
134d 12			  ld (de),a 
134e 13			  inc de 
134f			 
134f 01 9c ff		  ld bc,-100 
1352 3e 2f		  ld a,'0'-1 
1354 3c			  inc a  
1355 09			  add hl,bc  
1356 38 fc		   jr c,$-2 
1358 12			  ld (de),a 
1359 13			  inc de 
135a			 
135a 7d			  ld a,l 
135b 26 3a		  ld h,'9'+1 
135d 25			  dec h  
135e c6 0a		  add a,10  
1360 30 fb		   jr nc,$-3 
1362 c6 30		  add a,'0' 
1364 eb			  ex de,hl 
1365 72			  ld (hl),d 
1366 23			  inc hl 
1367 77			  ld (hl),a 
1368 23			  inc hl 
1369 36 00		  ld (hl),0 
136b			 
136b			;Now strip the leading zeros 
136b 0e fa		  ld c,-6 
136d 09			  add hl,bc 
136e 3e 30		  ld a,'0' 
1370 23			  inc hl  
1371 be			  cp (hl)  
1372 28 fc		  jr z,$-2 
1374			 
1374			;Make sure that the string is non-empty! 
1374 7e			  ld a,(hl) 
1375 b7			  or a 
1376 20 01		  jr nz,.atoub 
1378 2b			  dec hl 
1379			.atoub: 
1379			 
1379 f1			  pop af 
137a c1			  pop bc 
137b d1			  pop de 
137c c9			  ret 
137d			 
137d			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
137d			 
137d			toUpper: 
137d			;A is the char. 
137d			;If A is a lowercase letter, this sets it to the matching uppercase 
137d			;18cc or 30cc or 41cc 
137d			;avg: 26.75cc 
137d fe 61		  cp 'a' 
137f d8			  ret c 
1380 fe 7b		  cp 'z'+1 
1382 d0			  ret nc 
1383 d6 20		  sub 'a'-'A' 
1385 c9			  ret 
1386			 
1386			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1386			 
1386			; String Length 
1386			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1386			 
1386			; Get the length of the null-terminated string starting at $8000 hl 
1386			;    LD     HL, $8000 
1386			 
1386			strlenz: 
1386			 
1386 af			    XOR    A               ; Zero is the value we are looking for. 
1387 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1388 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1389			                           ; 65, 536 bytes (the entire addressable memory space). 
1389 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
138b			 
138b			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
138b 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
138c 6f			    LD     L, A             ; number of bytes 
138d ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
138f 2b			    DEC    HL              ; Compensate for null. 
1390 c9				ret 
1391			 
1391			; Get the length of the A terminated string starting at $8000 hl 
1391			;    LD     HL, $8000 
1391			 
1391			strlent: 
1391			 
1391			                  ; A is the value we are looking for. 
1391 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1393 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1395			                           ; 65, 536 bytes (the entire addressable memory space). 
1395 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1397			 
1397			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1397 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1399 2e 00		    LD     L, 0             ; number of bytes 
139b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
139d 2b			    DEC    HL              ; Compensate for null. 
139e c9				ret 
139f			 
139f			 
139f			;Comparing Strings 
139f			 
139f			;IN    HL     Address of string1. 
139f			;      DE     Address of string2. 
139f			 
139f			; doc given but wrong??? 
139f			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
139f			;      carry  Set if string1 > string2, reset if string1 <= string2. 
139f			; tested 
139f			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
139f			 
139f			strcmp_old: 
139f e5			    PUSH   HL 
13a0 d5			    PUSH   DE 
13a1			 
13a1 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
13a2 be			    CP     (HL)            ; (want to minimize work). 
13a3 38 01		    JR     C, Str1IsBigger 
13a5 7e			    LD     A, (HL) 
13a6			 
13a6			Str1IsBigger: 
13a6 4f			    LD     C, A             ; Put length in BC 
13a7 06 00		    LD     B, 0 
13a9 13			    INC    DE              ; Increment pointers to meat of string. 
13aa 23			    INC    HL 
13ab			 
13ab			CmpLoop: 
13ab 1a			    LD     A, (DE)          ; Compare bytes. 
13ac ed a1		    CPI 
13ae 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
13b0 13			    INC    DE              ; Update pointer. 
13b1 ea ab 13		    JP     PE, CmpLoop 
13b4			 
13b4 d1			    POP    DE 
13b5 e1			    POP    HL 
13b6 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
13b7 be			    CP     (HL) 
13b8 c9			    RET 
13b9			 
13b9			NoMatch: 
13b9 2b			    DEC    HL 
13ba be			    CP     (HL)            ; Compare again to affect carry. 
13bb d1			    POP    DE 
13bc e1			    POP    HL 
13bd c9			    RET 
13be			 
13be			;; test strmp 
13be			; 
13be			;ld de, .str1 
13be			;ld hl, .str2 
13be			;call strcmp 
13be			;jr z, .z1 
13be			;;this 
13be			;	if DEBUG_FORTH_WORDS 
13be			;		DMARK "NZ1" 
13be			;		CALLMONITOR 
13be			;	endif 
13be			;.z1: 
13be			; 
13be			;	if DEBUG_FORTH_WORDS 
13be			;		DMARK "ZZ1" 
13be			;		CALLMONITOR 
13be			;	endif 
13be			; 
13be			;ld de, .str1 
13be			;ld hl, .str1 
13be			;call strcmp 
13be			;jr z, .z2 
13be			;;this 
13be			;	if DEBUG_FORTH_WORDS 
13be			;		DMARK "NZ2" 
13be			;		CALLMONITOR 
13be			;	endif 
13be			;.z2: 
13be			; 
13be			;	if DEBUG_FORTH_WORDS 
13be			;		DMARK "ZZ2" 
13be			;		CALLMONITOR 
13be			;	endif 
13be			; 
13be			;ld de, .str1 
13be			;ld hl, .str2 
13be			;call strcmp 
13be			;jr c, .c1 
13be			; 
13be			;	if DEBUG_FORTH_WORDS 
13be			;		DMARK "Nc1" 
13be			;		CALLMONITOR 
13be			;	endif 
13be			;.c1: 
13be			;;this 
13be			;	if DEBUG_FORTH_WORDS 
13be			;		DMARK "cc1" 
13be			;		CALLMONITOR 
13be			;	endif 
13be			; 
13be			;ld de, .str1 
13be			;ld hl, .str1 
13be			;call strcmp 
13be			;jr c, .c2 
13be			;;this 
13be			;	if DEBUG_FORTH_WORDS 
13be			;		DMARK "Nc2" 
13be			;		CALLMONITOR 
13be			;	endif 
13be			;.c2: 
13be			; 
13be			;	if DEBUG_FORTH_WORDS 
13be			;		DMARK "cc2" 
13be			;		CALLMONITOR 
13be			;	endif 
13be			;	NEXTW 
13be			;.str1:   db "string1",0 
13be			;.str2:   db "string2",0 
13be			 
13be			; only care about direct match or not 
13be			; hl and de strings 
13be			; zero set if the same 
13be			 
13be			strcmp: 
13be 1a				ld a, (de) 
13bf be				cp (hl) 
13c0 28 02			jr z, .ssame 
13c2 b7				or a 
13c3 c9				ret 
13c4			 
13c4			.ssame:  
13c4 fe 00			cp 0 
13c6 c8				ret z 
13c7			 
13c7 23				inc hl 
13c8 13				inc de 
13c9 18 f3			jr strcmp 
13cb				 
13cb				 
13cb			 
13cb			;Copyright (c) 2014, Luke Maurits 
13cb			;All rights reserved. 
13cb			; 
13cb			;Redistribution and use in source and binary forms, with or without 
13cb			;modification, are permitted provided that the following conditions are met: 
13cb			; 
13cb			;* Redistributions of source code must retain the above copyright notice, this 
13cb			;  list of conditions and the following disclaimer. 
13cb			; 
13cb			;* Redistributions in binary form must reproduce the above copyright notice, 
13cb			;  this list of conditions and the following disclaimer in the documentation 
13cb			;  and/or other materials provided with the distribution. 
13cb			; 
13cb			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
13cb			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
13cb			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
13cb			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
13cb			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
13cb			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
13cb			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
13cb			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
13cb			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
13cb			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
13cb			 
13cb			; https://github.com/lmaurits/lm512/blob/master/string.z80 
13cb			 
13cb			StrictStrCmp: 
13cb				; Load next chars of each string 
13cb 1a				ld a, (de) 
13cc 47				ld b, a 
13cd 7e				ld a, (hl) 
13ce				; Compare 
13ce b8				cp b 
13cf				; Return non-zero if chars don't match 
13cf c0				ret nz 
13d0				; Check for end of both strings 
13d0 fe 00			cp "\0" 
13d2				; Return if strings have ended 
13d2 c8				ret z 
13d3				; Otherwise, advance to next chars 
13d3 23				inc hl 
13d4 13				inc de 
13d5 18 f4			jr StrictStrCmp 
13d7			 
13d7			;end 
13d7			; eof 
13d7			 
13d7			 
13d7			 
13d7			 
13d7			 
13d7			 
# End of file firmware_strings.asm
13d7			include "firmware_memory.asm"   ; malloc and free  
13d7			 
13d7			if DEBUG_FORTH_MALLOC_HIGH 
13d7			.mallocsize: db "Wants malloc >256",0 
13d7			.mallocasize: db "MALLOC gives >256",0 
13d7			.malloczero: db "MALLOC gives zero",0 
13d7			 
13d7			malloc_guard_zerolen: 
13d7				push hl 
13d7				push de 
13d7				push af 
13d7			 
13d7				ld de, 0 
13d7			        call cmp16 
13d7				jr nz, .lowalloz 
13d7			 
13d7				push hl 
13d7				push de 
13d7					ld hl, display_fb0 
13d7					ld (display_fb_active), hl 
13d7				call clear_display 
13d7				ld a, 0 
13d7				ld de, .malloczero 
13d7				call str_at_display 
13d7				call update_display 
13d7				call delay1s 
13d7				call delay1s 
13d7				call bp_on 
13d7			;	ld a, 0 
13d7			;	ld (os_view_disable), a 
13d7			 
13d7				pop de 
13d7				pop hl 
13d7			 
13d7				 
13d7			 
13d7				CALLMONITOR 
13d7			.lowalloz: 
13d7			 
13d7			 
13d7				pop af 
13d7				pop de 
13d7				pop hl 
13d7			ret 
13d7			 
13d7			malloc_guard_entry: 
13d7				push hl 
13d7				push de 
13d7				push af 
13d7			 
13d7			 	or a      ;clear carry flag 
13d7				push hl 
13d7				ld de, 255 
13d7				sbc hl, de 
13d7				jr c, .lowalloc 
13d7			 
13d7				push de 
13d7					ld hl, display_fb0 
13d7					ld (display_fb_active), hl 
13d7				call clear_display 
13d7				ld a, 0 
13d7				ld de, .mallocsize 
13d7				call str_at_display 
13d7				call update_display 
13d7				call delay1s 
13d7				call delay1s 
13d7			;	ld a, 0 
13d7			;	ld (os_view_disable), a 
13d7				call bp_on 
13d7			 
13d7				pop de 
13d7				pop hl 
13d7			 
13d7				 
13d7			 
13d7				CALLMONITOR 
13d7				jr .lowdone 
13d7			.lowalloc: 
13d7			 
13d7			 
13d7				pop hl 
13d7			.lowdone:	pop af 
13d7				pop de 
13d7				pop hl 
13d7			ret 
13d7			 
13d7			malloc_guard_exit: 
13d7				push hl 
13d7				push de 
13d7				push af 
13d7			 
13d7			 	or a      ;clear carry flag 
13d7				push hl 
13d7				ld de, 255 
13d7				sbc hl, de 
13d7				jr c, .lowallocx 
13d7			 
13d7				push de 
13d7					ld hl, display_fb0 
13d7					ld (display_fb_active), hl 
13d7				call clear_display 
13d7				ld a, 0 
13d7				ld de, .mallocasize 
13d7				call str_at_display 
13d7				call update_display 
13d7				call delay1s 
13d7				call delay1s 
13d7			;	ld a, 0 
13d7			;	ld (os_view_disable), a 
13d7				call bp_on 
13d7				pop de 
13d7				pop hl 
13d7			 
13d7				CALLMONITOR 
13d7				jr .lowdonex 
13d7			.lowallocx: 
13d7			 
13d7				pop hl 
13d7			.lowdonex:	pop af 
13d7				pop de 
13d7				pop hl 
13d7			ret 
13d7			endif 
13d7			 
13d7			if MALLOC_2 
13d7			; Z80 Malloc and Free Functions 
13d7			 
13d7			; Malloc Function: 
13d7			; Input: 
13d7			;   HL: Size of block to allocate 
13d7			; Output: 
13d7			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13d7			 
13d7			malloc: 
13d7				 
13d7			if DEBUG_FORTH_MALLOC_HIGH 
13d7			call malloc_guard_entry 
13d7			endif 
13d7			 
13d7			 
13d7			 
13d7			 
13d7					if DEBUG_FORTH_MALLOC 
13d7						DMARK "mal" 
13d7						CALLMONITOR 
13d7					endif 
13d7			    push af            ; Save AF register 
13d7			    ld a, l            ; Load low byte of size into A 
13d7			    or h               ; Check if size is zero 
13d7			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
13d7			 
13d7			    ; Allocate memory 
13d7			    ld hl, (heap_start) ; Load start of heap into HL 
13d7					if DEBUG_FORTH_MALLOC 
13d7						DMARK "ma1" 
13d7						CALLMONITOR 
13d7					endif 
13d7			    call malloc_internal ; Call internal malloc function 
13d7			    pop af             ; Restore AF register 
13d7			if DEBUG_FORTH_MALLOC_HIGH 
13d7			call malloc_guard_exit 
13d7			call malloc_guard_zerolen 
13d7			endif 
13d7			    ret                ; Return 
13d7			 
13d7			; Free Function: 
13d7			; Input: 
13d7			;   HL: Pointer to memory block to free 
13d7			; Output: 
13d7			;   None 
13d7			 
13d7			free: 
13d7			    push af            ; Save AF register 
13d7			    ld a, l            ; Load low byte of pointer into A 
13d7			    or h               ; Check if pointer is NULL 
13d7			    jp z, free_exit    ; If pointer is NULL, exit 
13d7			 
13d7			    ; Free memory 
13d7			    ld hl, (heap_start) ; Load start of heap into HL 
13d7			    call free_internal  ; Call internal free function 
13d7			    pop af             ; Restore AF register 
13d7			    ret                ; Return 
13d7			 
13d7			; Internal Malloc Function: 
13d7			; Input: 
13d7			;   HL: Size of block to allocate 
13d7			; Output: 
13d7			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
13d7			 
13d7			malloc_internal: 
13d7			    ld bc, 2           ; Number of bytes to allocate for management overhead 
13d7			    add hl, bc         ; Add management overhead to requested size 
13d7			    ex de, hl          ; Save total size in DE, and keep it in HL 
13d7					if DEBUG_FORTH_MALLOC 
13d7						DMARK "ma2" 
13d7						CALLMONITOR 
13d7					endif 
13d7			 
13d7			    ; Search for free memory block 
13d7			    ld de, (heap_end)  ; Load end of heap into DE 
13d7			    ld bc, 0           ; Initialize counter 
13d7			 
13d7					if DEBUG_FORTH_MALLOC 
13d7						DMARK "ma2" 
13d7						CALLMONITOR 
13d7					endif 
13d7			malloc_search_loop: 
13d7			    ; Check if current block is free 
13d7			    ld a, (hl)         ; Load current block's status (free or used) 
13d7			    cp 0               ; Compare with zero (free) 
13d7			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
13d7			 
13d7			    ; Check if current block is large enough 
13d7			    ld a, (hl+1)       ; Load high byte of block size 
13d7			    cp l               ; Compare with low byte of requested size 
13d7			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
13d7			 
13d7			    ld a, (hl+2)       ; Load low byte of block size 
13d7			    cp h               ; Compare with high byte of requested size 
13d7			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
13d7			 
13d7			    ; Mark block as used 
13d7			    ld (hl), 0xFF      ; Set status byte to indicate used block 
13d7			 
13d7			    ; Calculate remaining space in block 
13d7			    ld bc, 0           ; Clear BC 
13d7			    add hl, bc         ; Increment HL to point to start of data block 
13d7			    add hl, de         ; HL = HL + DE (total size) 
13d7			    ld bc, 1           ; Number of bytes to allocate for management overhead 
13d7			    add hl, bc         ; Add management overhead to start of data block 
13d7			 
13d7			    ; Save pointer to allocated block in HL 
13d7			if DEBUG_FORTH_MALLOC_HIGH 
13d7						DMARK "ma5" 
13d7			call malloc_guard_exit 
13d7			call malloc_guard_zerolen 
13d7			endif 
13d7			    ret 
13d7			 
13d7			malloc_skip_block_check: 
13d7			    ; Move to the next block 
13d7			    ld bc, 3           ; Size of management overhead 
13d7			    add hl, bc         ; Move to the next block 
13d7			    inc de             ; Increment counter 
13d7			 
13d7			    ; Check if we have reached the end of heap 
13d7			    ld a, e            ; Load low byte of heap end address 
13d7			    cp (hl)            ; Compare with low byte of current address 
13d7			    jr nz, malloc_search_loop  ; If not equal, continue searching 
13d7			    ld a, d            ; Load high byte of heap end address 
13d7			    cp 0               ; Check if it's zero (end of memory) 
13d7			    jr nz, malloc_search_loop  ; If not zero, continue searching 
13d7			 
13d7			    ; If we reached here, allocation failed 
13d7			    xor a              ; Set result to NULL 
13d7			if DEBUG_FORTH_MALLOC_HIGH 
13d7						DMARK "ma6" 
13d7			call malloc_guard_exit 
13d7			call malloc_guard_zerolen 
13d7			endif 
13d7			    ret 
13d7			malloc_exit: 
13d7			if DEBUG_FORTH_MALLOC_HIGH 
13d7						DMARK "ma7" 
13d7			call malloc_guard_exit 
13d7			call malloc_guard_zerolen 
13d7			endif 
13d7			    ret 
13d7			 
13d7			; Internal Free Function: 
13d7			; Input: 
13d7			;   HL: Pointer to memory block to free 
13d7			; Output: 
13d7			;   None 
13d7			 
13d7			free_internal: 
13d7			    ld de, (heap_start) ; Load start of heap into DE 
13d7			    ld bc, 0            ; Initialize counter 
13d7			 
13d7			free_search_loop: 
13d7			    ; Check if current block contains the pointer 
13d7			    ld a, l             ; Load low byte of pointer 
13d7			    cp (hl+1)           ; Compare with high byte of current block's address 
13d7			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13d7			    ld a, h             ; Load high byte of pointer 
13d7			    cp (hl+2)           ; Compare with low byte of current block's address 
13d7			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
13d7			 
13d7			    ; Mark block as free 
13d7			    ld (hl), 0          ; Set status byte to indicate free block 
13d7			    ret                 ; Return 
13d7			 
13d7			free_skip_block_check: 
13d7			    ; Move to the next block 
13d7			    ld bc, 3            ; Size of management overhead 
13d7			    add hl, bc          ; Move to the next block 
13d7			    inc de              ; Increment counter 
13d7			 
13d7			    ; Check if we have reached the end of heap 
13d7			    ld a, e             ; Load low byte of heap end address 
13d7			    cp (hl)             ; Compare with low byte of current address 
13d7			    jr nz, free_search_loop  ; If not equal, continue searching 
13d7			    ld a, d             ; Load high byte of heap end address 
13d7			    cp 0                ; Check if it's zero (end of memory) 
13d7			    jr nz, free_search_loop  ; If not zero, continue searching 
13d7			 
13d7			    ; If we reached here, pointer is not found in heap 
13d7			    ret 
13d7			 
13d7			free_exit: 
13d7			    ret                 ; Return 
13d7			 
13d7			; Define heap start and end addresses 
13d7			;heap_start:    .dw 0xC000   ; Start of heap 
13d7			;heap_end:      .dw 0xE000   ; End of heap 
13d7			 
13d7			endif 
13d7			 
13d7			 
13d7			if MALLOC_1 
13d7			 
13d7			 
13d7			 
13d7			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
13d7			 
13d7			;moved to firmware.asm 
13d7			;heap_start        .equ  0x9000      ; Starting address of heap 
13d7			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
13d7			 
13d7			;      .org 0 
13d7			;      jp    main 
13d7			 
13d7			 
13d7			;      .org  0x100 
13d7			;main: 
13d7			;      ld    HL, 0x8100 
13d7			;      ld    SP, HL 
13d7			; 
13d7			;      call  heap_init 
13d7			; 
13d7			;      ; Make some allocations 
13d7			;      ld    HL, 12 
13d7			;      call  malloc            ; Allocates 0x9004 
13d7			; 
13d7			;      ld    HL, 12 
13d7			;      call  malloc            ; Allocates 0x9014 
13d7			; 
13d7			;      ld    HL, 12 
13d7			;      call  malloc            ; Allocates 0x9024 
13d7			; 
13d7			;      ; Free some allocations 
13d7			;      ld    HL, 0x9014 
13d7			;      call  free 
13d7			; 
13d7			;      ld    HL, 0x9004 
13d7			;      call  free 
13d7			; 
13d7			;      ld    HL, 0x9024 
13d7			;      call  free 
13d7			; 
13d7			; 
13d7			;      halt 
13d7			 
13d7			 
13d7			;------------------------------------------------------------------------------ 
13d7			;     heap_init                                                               : 
13d7			;                                                                             : 
13d7			; Description                                                                 : 
13d7			;     Initialise the heap and make it ready for malloc and free operations.   : 
13d7			;                                                                             : 
13d7			;     The heap is maintained as a linked list, starting with an initial       : 
13d7			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
13d7			;     the first free block in the heap. Each block then points to the next    : 
13d7			;     free block within the heap, and the free list ends at the first block   : 
13d7			;     with a null pointer to the next free block.                             : 
13d7			;                                                                             : 
13d7			; Parameters                                                                  : 
13d7			;     Inputs are compile-time only. Two defines which specify the starting    : 
13d7			;     address of the heap and its size are required, along with a memory      : 
13d7			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
13d7			;     principally stores a pointer to the first free block in the heap.       : 
13d7			;                                                                             : 
13d7			; Returns                                                                     : 
13d7			;     Nothing                                                                 : 
13d7			;------------------------------------------------------------------------------ 
13d7			heap_init: 
13d7 e5			      push  HL 
13d8			 
13d8			      ; Initialise free list struct 
13d8 21 0e 80		      ld    HL, heap_start 
13db 22 0a 80		      ld    (free_list), HL 
13de 21 00 00		      ld    HL, 0 
13e1 22 0c 80		      ld    (free_list+2), HL 
13e4			 
13e4			      ; Insert first free block at bottom of heap, consumes entire heap 
13e4 21 d3 f0		      ld    HL, heap_start+heap_size-4 
13e7 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
13ea 21 c5 70		      ld    HL, heap_size-4 
13ed 22 10 80		      ld    (heap_start+2), HL      ; Block size 
13f0			 
13f0			      ; Insert end of free list block at top of heap - two null words will 
13f0			      ; terminate the free list 
13f0 21 00 00		      ld    HL, 0 
13f3 22 d5 f0		      ld    (heap_start+heap_size-2), HL 
13f6 22 d3 f0		      ld    (heap_start+heap_size-4), HL 
13f9			 
13f9 e1			      pop   HL 
13fa			 
13fa c9			      ret 
13fb			 
13fb			 
13fb			;------------------------------------------------------------------------------ 
13fb			;     malloc                                                                  : 
13fb			;                                                                             : 
13fb			; Description                                                                 : 
13fb			;     Allocates the wanted space from the heap and returns the address of the : 
13fb			;     first useable byte of the allocation.                                   : 
13fb			;                                                                             : 
13fb			;     Allocations can happen in one of two ways:                              : 
13fb			;                                                                             : 
13fb			;     1. A free block may be found which is the exact size wanted. In this    : 
13fb			;        case the block is removed from the free list and retuedn to the      : 
13fb			;        caller.                                                              : 
13fb			;     2. A free block may be found which is larger than the size wanted. In   : 
13fb			;        this case, the larger block is split into two. The first portion of  : 
13fb			;        this block will become the requested space by the malloc call and    : 
13fb			;        is returned to the caller. The second portion becomes a new free     : 
13fb			;        block, and the free list is adjusted to maintain continuity via this : 
13fb			;        newly created block.                                                 : 
13fb			;                                                                             : 
13fb			;     malloc does not set any initial value in the allocated space, the       : 
13fb			;     caller is required to do this as required.                              : 
13fb			;                                                                             : 
13fb			;     This implementation of malloc uses the stack exclusively, and is        : 
13fb			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
13fb			;     advisable to disable interrupts before calling malloc, and recommended  : 
13fb			;     to avoid the use of malloc inside ISRs in general.                      : 
13fb			;                                                                             : 
13fb			;     NOTE: heap_init must be called before malloc and free can be used.      : 
13fb			;                                                                             : 
13fb			; Parameters                                                                  : 
13fb			;     HL  Number of bytes wanted                                              : 
13fb			;                                                                             : 
13fb			; Returns                                                                     : 
13fb			;     HL  Address of the first useable byte of the allocation                 : 
13fb			;                                                                             : 
13fb			; Flags                                                                       : 
13fb			;     Z   Set if the allocation did not succeed, clear otherwise              : 
13fb			;                                                                             : 
13fb			; Stack frame                                                                 : 
13fb			;       |             |                                                       : 
13fb			;       +-------------+                                                       : 
13fb			;       |     BC      |                                                       : 
13fb			;       +-------------+                                                       : 
13fb			;       |     DE      |                                                       : 
13fb			;       +-------------+                                                       : 
13fb			;       |     IX      |                                                       : 
13fb			;       +-------------+                                                       : 
13fb			;       |  prev_free  |                                                       : 
13fb			;   +4  +-------------+                                                       : 
13fb			;       |  this_free  |                                                       : 
13fb			;   +2  +-------------+                                                       : 
13fb			;       |  next_free  |                                                       : 
13fb			;   +0  +-------------+                                                       : 
13fb			;       |             |                                                       : 
13fb			;                                                                             : 
13fb			;------------------------------------------------------------------------------ 
13fb			 
13fb			 
13fb			;malloc: 
13fb			; 
13fb			;	SAVESP ON 1 
13fb			; 
13fb			;	call malloc_code 
13fb			; 
13fb			;	CHECKSP ON 1 
13fb			;	ret 
13fb			 
13fb			 
13fb			malloc: 
13fb c5			      push  BC 
13fc d5			      push  DE 
13fd dd e5		      push  IX 
13ff			if DEBUG_FORTH_MALLOC_HIGH 
13ff			call malloc_guard_entry 
13ff			endif 
13ff			 
13ff					if DEBUG_FORTH_MALLOC 
13ff						DMARK "mal" 
13ff						CALLMONITOR 
13ff					endif 
13ff 7c			      ld    A, H                    ; Exit if no space requested 
1400 b5			      or    L 
1401 ca c0 14		      jp    Z, malloc_early_exit 
1404			 
1404			;inc hl 
1404			;inc hl 
1404			;inc hl 
1404			; 
1404			;inc hl 
1404			;inc hl 
1404			;inc hl 
1404			;inc hl 
1404			;inc hl 
1404			;inc hl 
1404			;inc hl 
1404			;inc hl 
1404			;inc hl 
1404			 
1404			 
1404			 
1404			 
1404					if DEBUG_FORTH_MALLOC 
1404						DMARK "maA" 
1404						CALLMONITOR 
1404					endif 
1404			      ; Set up stack frame 
1404 eb			      ex    DE, HL 
1405 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1408 39			      add   HL, SP 
1409 f9			      ld    SP, HL 
140a dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
140e dd 39		      add   IX, SP 
1410			 
1410			      ; Setup initial state 
1410 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1413 19			      add   HL, DE 
1414			 
1414 44			      ld    B, H                    ; Move want to BC 
1415 4d			      ld    C, L 
1416			 
1416 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
1419 dd 75 04		      ld    (IX+4), L 
141c dd 74 05		      ld    (IX+5), H 
141f			 
141f 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1420 23			      inc   HL 
1421 56			      ld    D, (HL) 
1422 dd 73 02		      ld    (IX+2), E 
1425 dd 72 03		      ld    (IX+3), D 
1428 eb			      ex    DE, HL                  ; this_free ptr into HL 
1429			 
1429					if DEBUG_FORTH_MALLOC 
1429						DMARK "maB" 
1429						CALLMONITOR 
1429					endif 
1429			      ; Loop through free block list to find some space 
1429			malloc_find_space: 
1429 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
142a 23			      inc   HL 
142b 56			      ld    D, (HL) 
142c			 
142c 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
142d b3			      or    E 
142e ca ba 14		      jp    Z, malloc_no_space 
1431			 
1431 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1434 dd 72 01		      ld    (IX+1), D 
1437			 
1437			      ; Does this block have enough space to make the allocation? 
1437 23			      inc   HL                      ; Load free block size into DE 
1438 5e			      ld    E, (HL) 
1439 23			      inc   HL 
143a 56			      ld    D, (HL) 
143b			 
143b eb			      ex    DE, HL                  ; Check size of block against want 
143c b7			      or    A                       ; Ensure carry flag clear 
143d ed 42		      sbc   HL, BC 
143f e5			      push  HL                      ; Store the result for later (new block size) 
1440			 
1440 ca 8f 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1443 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1445			 
1445			      ; this_free block is not big enough, setup ptrs to test next free block 
1445 e1			      pop   HL                      ; Discard previous result 
1446			 
1446 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1449 dd 66 03		      ld    H, (IX+3) 
144c dd 75 04		      ld    (IX+4), L 
144f dd 74 05		      ld    (IX+5), H 
1452			 
1452 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1455 dd 66 01		      ld    H, (IX+1) 
1458 dd 75 02		      ld    (IX+2), L 
145b dd 74 03		      ld    (IX+3), H 
145e			 
145e					if DEBUG_FORTH_MALLOC 
145e						DMARK "MA>" 
145e						CALLMONITOR 
145e					endif 
145e 18 c9		      jr    malloc_find_space 
1460			 
1460			      ; split a bigger block into two - requested size and remaining size 
1460			malloc_alloc_split: 
1460					if DEBUG_FORTH_MALLOC 
1460						DMARK "MAs" 
1460						CALLMONITOR 
1460					endif 
1460 eb			      ex    DE, HL                  ; Calculate address of new free block 
1461 2b			      dec   HL 
1462 2b			      dec   HL 
1463 2b			      dec   HL 
1464 09			      add   HL, BC 
1465			 
1465			      ; Create a new block and point it at next_free 
1465 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1468 dd 56 01		      ld    D, (IX+1) 
146b			 
146b 73			      ld    (HL), E                 ; Store next_free ptr into new block 
146c 23			      inc   HL 
146d 72			      ld    (HL), D 
146e			 
146e d1			      pop   DE                      ; Store size of new block into new block 
146f 23			      inc   HL 
1470 73			      ld    (HL), E 
1471 23			      inc   HL 
1472 72			      ld    (HL), D 
1473			 
1473			      ; Update this_free ptr to point to new block 
1473 2b			      dec   HL 
1474 2b			      dec   HL 
1475 2b			      dec   HL 
1476			 
1476 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1479 dd 56 03		      ld    D, (IX+3) 
147c			 
147c dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
147f dd 74 03		      ld    (IX+3), H 
1482			 
1482			      ; Modify this_free block to be allocation 
1482 eb			      ex    DE, HL 
1483 af			      xor   A                       ; Null the next block ptr of allocated block 
1484 77			      ld    (HL), A 
1485 23			      inc   HL 
1486 77			      ld    (HL), A 
1487			 
1487 23			      inc   HL                      ; Store want size into allocated block 
1488 71			      ld    (HL), C 
1489 23			      inc   HL 
148a 70			      ld    (HL), B 
148b 23			      inc   HL 
148c e5			      push  HL                      ; Address of allocation to return 
148d			 
148d 18 19		      jr    malloc_update_links 
148f			 
148f			malloc_alloc_fit: 
148f e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1490			 
1490					if DEBUG_FORTH_MALLOC 
1490						DMARK "MAf" 
1490						CALLMONITOR 
1490					endif 
1490			      ; Modify this_free block to be allocation 
1490 eb			      ex    DE, HL 
1491 2b			      dec   HL 
1492 2b			      dec   HL 
1493 2b			      dec   HL 
1494			 
1494 af			      xor   A                       ; Null the next block ptr of allocated block 
1495 77			      ld    (HL), A 
1496 23			      inc   HL 
1497 77			      ld    (HL), A 
1498			 
1498 23			      inc   HL                      ; Store address of allocation to return 
1499 23			      inc   HL 
149a 23			      inc   HL 
149b e5			      push  HL 
149c			 
149c			      ; Copy next_free ptr to this_free, remove allocated block from free list 
149c dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
149f dd 66 01		      ld    H, (IX+1) 
14a2			 
14a2 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
14a5 dd 74 03		      ld    (IX+3), H 
14a8			 
14a8			 
14a8			malloc_update_links: 
14a8			      ; Update prev_free ptr to point to this_free 
14a8 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
14ab dd 66 05		      ld    H, (IX+5) 
14ae			 
14ae dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
14b1 dd 56 03		      ld    D, (IX+3) 
14b4			 
14b4 73			      ld    (HL), E                 ; this_free ptr into prev_free 
14b5 23			      inc   HL 
14b6 72			      ld    (HL), D 
14b7			 
14b7					if DEBUG_FORTH_MALLOC 
14b7						DMARK "Mul" 
14b7						CALLMONITOR 
14b7					endif 
14b7			      ; Clear the Z flag to indicate successful allocation 
14b7 7a			      ld    A, D 
14b8 b3			      or    E 
14b9			 
14b9 d1			      pop   DE                      ; Address of allocation 
14ba					if DEBUG_FORTH_MALLOC 
14ba						DMARK "MAu" 
14ba						CALLMONITOR 
14ba					endif 
14ba			 
14ba			malloc_no_space: 
14ba 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
14bd 39			      add   HL, SP 
14be f9			      ld    SP, HL 
14bf			 
14bf eb			      ex    DE, HL                  ; Alloc addr into HL for return 
14c0					if DEBUG_FORTH_MALLOC 
14c0						DMARK "MAN" 
14c0						CALLMONITOR 
14c0					endif 
14c0			 
14c0			malloc_early_exit: 
14c0					if DEBUG_FORTH_MALLOC 
14c0						DMARK "MAx" 
14c0						CALLMONITOR 
14c0					endif 
14c0 dd e1		      pop   IX 
14c2 d1			      pop   DE 
14c3 c1			      pop   BC 
14c4			 
14c4			if DEBUG_FORTH_MALLOC_HIGH 
14c4			call malloc_guard_exit 
14c4			call malloc_guard_zerolen 
14c4			endif 
14c4 c9			      ret 
14c5			 
14c5			 
14c5			;------------------------------------------------------------------------------ 
14c5			;     free                                                                    : 
14c5			;                                                                             : 
14c5			; Description                                                                 : 
14c5			;     Return the space pointed to by HL to the heap. HL must be an address as : 
14c5			;     returned by malloc, otherwise the behaviour is undefined.               : 
14c5			;                                                                             : 
14c5			;     Where possible, directly adjacent free blocks will be merged together   : 
14c5			;     into larger blocks to help ensure that the heap does not become         : 
14c5			;     excessively fragmented.                                                 : 
14c5			;                                                                             : 
14c5			;     free does not clear or set any other value into the freed space, and    : 
14c5			;     therefore its contents may be visible through subsequent malloc's. The  : 
14c5			;     caller should clear the freed space as required.                        : 
14c5			;                                                                             : 
14c5			;     This implementation of free uses the stack exclusively, and is          : 
14c5			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
14c5			;     advisable to disable interrupts before calling free, and recommended    : 
14c5			;     to avoid the use of free inside ISRs in general.                        : 
14c5			;                                                                             : 
14c5			;     NOTE: heap_init must be called before malloc and free can be used.      : 
14c5			;                                                                             : 
14c5			; Parameters                                                                  : 
14c5			;     HL  Pointer to address of first byte of allocation to be freed          : 
14c5			;                                                                             : 
14c5			; Returns                                                                     : 
14c5			;     Nothing                                                                 : 
14c5			;                                                                             : 
14c5			; Stack frame                                                                 : 
14c5			;       |             |                                                       : 
14c5			;       +-------------+                                                       : 
14c5			;       |     BC      |                                                       : 
14c5			;       +-------------+                                                       : 
14c5			;       |     DE      |                                                       : 
14c5			;       +-------------+                                                       : 
14c5			;       |     IX      |                                                       : 
14c5			;       +-------------+                                                       : 
14c5			;       |  prev_free  |                                                       : 
14c5			;   +2  +-------------+                                                       : 
14c5			;       |  next_free  |                                                       : 
14c5			;   +0  +-------------+                                                       : 
14c5			;       |             |                                                       : 
14c5			;                                                                             : 
14c5			;------------------------------------------------------------------------------ 
14c5			free: 
14c5 c5			      push  BC 
14c6 d5			      push  DE 
14c7 dd e5		      push  IX 
14c9			 
14c9 7c			      ld    A, H                    ; Exit if ptr is null 
14ca b5			      or    L 
14cb ca 8f 15		      jp    Z, free_early_exit 
14ce			 
14ce			      ; Set up stack frame 
14ce eb			      ex    DE, HL 
14cf 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
14d2 39			      add   HL, SP 
14d3 f9			      ld    SP, HL 
14d4 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
14d8 dd 39		      add   IX, SP 
14da			 
14da			      ; The address in HL points to the start of the useable allocated space, 
14da			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
14da			      ; address of the block itself. 
14da eb			      ex    DE, HL 
14db 11 fc ff		      ld    DE, -4 
14de 19			      add   HL, DE 
14df			 
14df			      ; An allocated block must have a null next block pointer in it 
14df 7e			      ld    A, (HL) 
14e0 23			      inc   HL 
14e1 b6			      or    (HL) 
14e2 c2 8a 15		      jp    NZ, free_done 
14e5			 
14e5 2b			      dec   HL 
14e6			 
14e6 44			      ld    B, H                    ; Copy HL to BC 
14e7 4d			      ld    C, L 
14e8			 
14e8			      ; Loop through the free list to find the first block with an address 
14e8			      ; higher than the block being freed 
14e8 21 0a 80		      ld    HL, free_list 
14eb			 
14eb			free_find_higher_block: 
14eb 5e			      ld    E, (HL)                 ; Load next ptr from free block 
14ec 23			      inc   HL 
14ed 56			      ld    D, (HL) 
14ee 2b			      dec   HL 
14ef			 
14ef dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
14f2 dd 72 01		      ld    (IX+1), D 
14f5 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
14f8 dd 74 03		      ld    (IX+3), H 
14fb			 
14fb 78			      ld    A, B                    ; Check if DE is greater than BC 
14fc ba			      cp    D                       ; Compare MSB first 
14fd 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
14ff 30 04		      jr    NC, free_find_higher_block_skip 
1501 79			      ld    A, C 
1502 bb			      cp    E                       ; Then compare LSB 
1503 38 08		      jr    C, free_found_higher_block 
1505			 
1505			free_find_higher_block_skip: 
1505 7a			      ld    A, D                    ; Reached the end of the free list? 
1506 b3			      or    E 
1507 ca 8a 15		      jp    Z, free_done 
150a			 
150a eb			      ex    DE, HL 
150b			 
150b 18 de		      jr    free_find_higher_block 
150d			 
150d			free_found_higher_block: 
150d			      ; Insert freed block between prev and next free blocks 
150d 71			      ld    (HL), C                 ; Point prev free block to freed block 
150e 23			      inc   HL 
150f 70			      ld    (HL), B 
1510			 
1510 60			      ld    H, B                    ; Point freed block at next free block 
1511 69			      ld    L, C 
1512 73			      ld    (HL), E 
1513 23			      inc   HL 
1514 72			      ld    (HL), D 
1515			 
1515			      ; Check if the freed block is adjacent to the next free block 
1515 23			      inc   HL                      ; Load size of freed block into HL 
1516 5e			      ld    E, (HL) 
1517 23			      inc   HL 
1518 56			      ld    D, (HL) 
1519 eb			      ex    DE, HL 
151a			 
151a 09			      add   HL, BC                  ; Add addr of freed block and its size 
151b			 
151b dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
151e dd 56 01		      ld    D, (IX+1) 
1521			 
1521 b7			      or    A                       ; Clear the carry flag 
1522 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1524 20 22		      jr    NZ, free_check_adjacent_to_prev 
1526			 
1526			      ; Freed block is adjacent to next, merge into one bigger block 
1526 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
1527 5e			      ld    E, (HL) 
1528 23			      inc   HL 
1529 56			      ld    D, (HL) 
152a e5			      push  HL                      ; Save ptr to next block for later 
152b			 
152b 60			      ld    H, B                    ; Store ptr from next block into freed block 
152c 69			      ld    L, C 
152d 73			      ld    (HL), E 
152e 23			      inc   HL 
152f 72			      ld    (HL), D 
1530			 
1530 e1			      pop   HL                      ; Restore ptr to next block 
1531 23			      inc   HL                      ; Load size of next block into DE 
1532 5e			      ld    E, (HL) 
1533 23			      inc   HL 
1534 56			      ld    D, (HL) 
1535 d5			      push  DE                      ; Save next block size for later 
1536			 
1536 60			      ld    H, B                    ; Load size of freed block into HL 
1537 69			      ld    L, C 
1538 23			      inc   HL 
1539 23			      inc   HL 
153a 5e			      ld    E, (HL) 
153b 23			      inc   HL 
153c 56			      ld    D, (HL) 
153d eb			      ex    DE, HL 
153e			 
153e d1			      pop   DE                      ; Restore size of next block 
153f 19			      add   HL, DE                  ; Add sizes of both blocks 
1540 eb			      ex    DE, HL 
1541			 
1541 60			      ld    H, B                    ; Store new bigger size into freed block 
1542 69			      ld    L, C 
1543 23			      inc   HL 
1544 23			      inc   HL 
1545 73			      ld    (HL), E 
1546 23			      inc   HL 
1547 72			      ld    (HL), D 
1548			 
1548			free_check_adjacent_to_prev: 
1548			      ; Check if the freed block is adjacent to the prev free block 
1548 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
154b dd 66 03		      ld    H, (IX+3) 
154e			 
154e 23			      inc   HL                      ; Size of prev free block into DE 
154f 23			      inc   HL 
1550 5e			      ld    E, (HL) 
1551 23			      inc   HL 
1552 56			      ld    D, (HL) 
1553 2b			      dec   HL 
1554 2b			      dec   HL 
1555 2b			      dec   HL 
1556			 
1556 19			      add   HL, DE                  ; Add prev block addr and size 
1557			 
1557 b7			      or    A                       ; Clear the carry flag 
1558 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
155a 20 2e		      jr    NZ, free_done 
155c			 
155c			      ; Freed block is adjacent to prev, merge into one bigger block 
155c 60			      ld    H, B                    ; Load next ptr from freed block into DE 
155d 69			      ld    L, C 
155e 5e			      ld    E, (HL) 
155f 23			      inc   HL 
1560 56			      ld    D, (HL) 
1561 e5			      push  HL                      ; Save freed block ptr for later 
1562			 
1562 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1565 dd 66 03		      ld    H, (IX+3) 
1568 73			      ld    (HL), E 
1569 23			      inc   HL 
156a 72			      ld    (HL), D 
156b			 
156b e1			      pop   HL                      ; Restore freed block ptr 
156c 23			      inc   HL                      ; Load size of freed block into DE 
156d 5e			      ld    E, (HL) 
156e 23			      inc   HL 
156f 56			      ld    D, (HL) 
1570 d5			      push  DE                      ; Save freed block size for later 
1571			 
1571 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1574 dd 66 03		      ld    H, (IX+3) 
1577 23			      inc   HL 
1578 23			      inc   HL 
1579 5e			      ld    E, (HL) 
157a 23			      inc   HL 
157b 56			      ld    D, (HL) 
157c			 
157c e1			      pop   HL                      ; Add sizes of both blocks 
157d 19			      add   HL, DE 
157e eb			      ex    DE, HL 
157f			 
157f dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1582 dd 66 03		      ld    H, (IX+3) 
1585 23			      inc   HL 
1586 23			      inc   HL 
1587 73			      ld    (HL), E 
1588 23			      inc   HL 
1589 72			      ld    (HL), D 
158a			 
158a			free_done: 
158a 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
158d 39			      add   HL, SP 
158e f9			      ld    SP, HL 
158f			 
158f			free_early_exit: 
158f dd e1		      pop   IX 
1591 d1			      pop   DE 
1592 c1			      pop   BC 
1593			 
1593 c9			      ret 
1594			 
1594			; moved to firmware.asm 
1594			; 
1594			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1594			;                  .dw   0 
1594			 
1594			 
1594			endif 
1594			 
1594			 
1594			if MALLOC_3 
1594			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1594			;heap_start        .equ  0x9000      ; Starting address of heap 
1594			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1594			; 
1594			 ;     .org 0 
1594			  ;    jp    main 
1594			; 
1594			; 
1594			 ;     .org  0x100 
1594			;main: 
1594			 ;     ld    HL, 0x8100 
1594			  ;    ld    SP, HL 
1594			; 
1594			;      call  heap_init 
1594			 
1594			      ; Make some allocations 
1594			;      ld    HL, 12 
1594			;      call  malloc            ; Allocates 0x9004 
1594			; 
1594			 ;     ld    HL, 12 
1594			;      call  malloc            ; Allocates 0x9014 
1594			 
1594			;      ld    HL, 12 
1594			;      call  malloc            ; Allocates 0x9024 
1594			 
1594			      ; Free some allocations 
1594			;      ld    HL, 0x9014 
1594			;      call  free 
1594			 
1594			;      ld    HL, 0x9004 
1594			;      call  free 
1594			; 
1594			;      ld    HL, 0x9024 
1594			;      call  free 
1594			 
1594			 
1594			 ;     halt 
1594			 
1594			 
1594			;------------------------------------------------------------------------------ 
1594			;     heap_init                                                               : 
1594			;                                                                             : 
1594			; Description                                                                 : 
1594			;     Initialise the heap and make it ready for malloc and free operations.   : 
1594			;                                                                             : 
1594			;     The heap is maintained as a linked list, starting with an initial       : 
1594			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1594			;     the first free block in the heap. Each block then points to the next    : 
1594			;     free block within the heap, and the free list ends at the first block   : 
1594			;     with a null pointer to the next free block.                             : 
1594			;                                                                             : 
1594			; Parameters                                                                  : 
1594			;     Inputs are compile-time only. Two defines which specify the starting    : 
1594			;     address of the heap and its size are required, along with a memory      : 
1594			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1594			;     principally stores a pointer to the first free block in the heap.       : 
1594			;                                                                             : 
1594			; Returns                                                                     : 
1594			;     Nothing                                                                 : 
1594			;------------------------------------------------------------------------------ 
1594			heap_init: 
1594			      push  HL 
1594			 
1594			      ; Initialise free list struct 
1594			      ld    HL, heap_start 
1594			      ld    (free_list), HL 
1594			      ld    HL, 0 
1594			      ld    (free_list+2), HL 
1594			 
1594			      ; Insert first free block at bottom of heap, consumes entire heap 
1594			      ld    HL, heap_start+heap_size-4 
1594			      ld    (heap_start), HL        ; Next block (end of free list) 
1594			      ld    HL, heap_size-4 
1594			      ld    (heap_start+2), HL      ; Block size 
1594			 
1594			      ; Insert end of free list block at top of heap - two null words will 
1594			      ; terminate the free list 
1594			      ld    HL, 0 
1594			      ld    (heap_start+heap_size-2), HL 
1594			      ld    (heap_start+heap_size-4), HL 
1594			 
1594			      pop   HL 
1594			 
1594			      ret 
1594			 
1594			 
1594			;------------------------------------------------------------------------------ 
1594			;     malloc                                                                  : 
1594			;                                                                             : 
1594			; Description                                                                 : 
1594			;     Allocates the wanted space from the heap and returns the address of the : 
1594			;     first useable byte of the allocation.                                   : 
1594			;                                                                             : 
1594			;     Allocations can happen in one of two ways:                              : 
1594			;                                                                             : 
1594			;     1. A free block may be found which is the exact size wanted. In this    : 
1594			;        case the block is removed from the free list and retuedn to the      : 
1594			;        caller.                                                              : 
1594			;     2. A free block may be found which is larger than the size wanted. In   : 
1594			;        this case, the larger block is split into two. The first portion of  : 
1594			;        this block will become the requested space by the malloc call and    : 
1594			;        is returned to the caller. The second portion becomes a new free     : 
1594			;        block, and the free list is adjusted to maintain continuity via this : 
1594			;        newly created block.                                                 : 
1594			;                                                                             : 
1594			;     malloc does not set any initial value in the allocated space, the       : 
1594			;     caller is required to do this as required.                              : 
1594			;                                                                             : 
1594			;     This implementation of malloc uses the stack exclusively, and is        : 
1594			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1594			;     advisable to disable interrupts before calling malloc, and recommended  : 
1594			;     to avoid the use of malloc inside ISRs in general.                      : 
1594			;                                                                             : 
1594			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1594			;                                                                             : 
1594			; Parameters                                                                  : 
1594			;     HL  Number of bytes wanted                                              : 
1594			;                                                                             : 
1594			; Returns                                                                     : 
1594			;     HL  Address of the first useable byte of the allocation                 : 
1594			;                                                                             : 
1594			; Flags                                                                       : 
1594			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1594			;                                                                             : 
1594			; Stack frame                                                                 : 
1594			;       |             |                                                       : 
1594			;       +-------------+                                                       : 
1594			;       |     BC      |                                                       : 
1594			;       +-------------+                                                       : 
1594			;       |     DE      |                                                       : 
1594			;       +-------------+                                                       : 
1594			;       |     IX      |                                                       : 
1594			;       +-------------+                                                       : 
1594			;       |  prev_free  |                                                       : 
1594			;   +4  +-------------+                                                       : 
1594			;       |  this_free  |                                                       : 
1594			;   +2  +-------------+                                                       : 
1594			;       |  next_free  |                                                       : 
1594			;   +0  +-------------+                                                       : 
1594			;       |             |                                                       : 
1594			;                                                                             : 
1594			;------------------------------------------------------------------------------ 
1594			malloc: 
1594			      push  BC 
1594			      push  DE 
1594			      push  IX 
1594			 
1594			      ld    A, H                    ; Exit if no space requested 
1594			      or    L 
1594			      jp    Z, malloc_early_exit 
1594			 
1594			      ; Set up stack frame 
1594			      ex    DE, HL 
1594			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1594			      add   HL, SP 
1594			      ld    SP, HL 
1594			      ld    IX, 0                   ; Use IX as a frame pointer 
1594			      add   IX, SP 
1594			 
1594			      ; Setup initial state 
1594			      ld    HL, 4                   ; want must also include space used by block struct 
1594			      add   HL, DE 
1594			 
1594			      ld    B, H                    ; Move want to BC 
1594			      ld    C, L 
1594			 
1594			      ld    HL, free_list           ; Store prev_free ptr to stack 
1594			      ld    (IX+4), L 
1594			      ld    (IX+5), H 
1594			 
1594			      ld    E, (HL)                 ; Store this_free ptr to stack 
1594			      inc   HL 
1594			      ld    D, (HL) 
1594			      ld    (IX+2), E 
1594			      ld    (IX+3), D 
1594			      ex    DE, HL                  ; this_free ptr into HL 
1594			 
1594			      ; Loop through free block list to find some space 
1594			malloc_find_space: 
1594			      ld    E, (HL)                 ; Load next_free ptr into DE 
1594			      inc   HL 
1594			      ld    D, (HL) 
1594			 
1594			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1594			      or    E 
1594			      jp    Z, malloc_no_space 
1594			 
1594			      ld    (IX+0), E               ; Store next_free ptr to stack 
1594			      ld    (IX+1), D 
1594			 
1594			      ; Does this block have enough space to make the allocation? 
1594			      inc   HL                      ; Load free block size into DE 
1594			      ld    E, (HL) 
1594			      inc   HL 
1594			      ld    D, (HL) 
1594			 
1594			      ex    DE, HL                  ; Check size of block against want 
1594			      or    A                       ; Ensure carry flag clear 
1594			      sbc   HL, BC 
1594			      push  HL                      ; Store the result for later (new block size) 
1594			 
1594			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1594			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1594			 
1594			      ; this_free block is not big enough, setup ptrs to test next free block 
1594			      pop   HL                      ; Discard previous result 
1594			 
1594			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1594			      ld    H, (IX+3) 
1594			      ld    (IX+4), L 
1594			      ld    (IX+5), H 
1594			 
1594			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1594			      ld    H, (IX+1) 
1594			      ld    (IX+2), L 
1594			      ld    (IX+3), H 
1594			 
1594			      jr    malloc_find_space 
1594			 
1594			      ; split a bigger block into two - requested size and remaining size 
1594			malloc_alloc_split: 
1594			      ex    DE, HL                  ; Calculate address of new free block 
1594			      dec   HL 
1594			      dec   HL 
1594			      dec   HL 
1594			      add   HL, BC 
1594			 
1594			      ; Create a new block and point it at next_free 
1594			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1594			      ld    D, (IX+1) 
1594			 
1594			      ld    (HL), E                 ; Store next_free ptr into new block 
1594			      inc   HL 
1594			      ld    (HL), D 
1594			 
1594			      pop   DE                      ; Store size of new block into new block 
1594			      inc   HL 
1594			      ld    (HL), E 
1594			      inc   HL 
1594			      ld    (HL), D 
1594			 
1594			      ; Update this_free ptr to point to new block 
1594			      dec   HL 
1594			      dec   HL 
1594			      dec   HL 
1594			 
1594			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1594			      ld    D, (IX+3) 
1594			 
1594			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1594			      ld    (IX+3), H 
1594			 
1594			      ; Modify this_free block to be allocation 
1594			      ex    DE, HL 
1594			      xor   A                       ; Null the next block ptr of allocated block 
1594			      ld    (HL), A 
1594			      inc   HL 
1594			      ld    (HL), A 
1594			 
1594			      inc   HL                      ; Store want size into allocated block 
1594			      ld    (HL), C 
1594			      inc   HL 
1594			      ld    (HL), B 
1594			      inc   HL 
1594			      push  HL                      ; Address of allocation to return 
1594			 
1594			      jr    malloc_update_links 
1594			 
1594			malloc_alloc_fit: 
1594			      pop   HL                      ; Dont need new block size, want is exact fit 
1594			 
1594			      ; Modify this_free block to be allocation 
1594			      ex    DE, HL 
1594			      dec   HL 
1594			      dec   HL 
1594			      dec   HL 
1594			 
1594			      xor   A                       ; Null the next block ptr of allocated block 
1594			      ld    (HL), A 
1594			      inc   HL 
1594			      ld    (HL), A 
1594			 
1594			      inc   HL                      ; Store address of allocation to return 
1594			      inc   HL 
1594			      inc   HL 
1594			      push  HL 
1594			 
1594			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1594			      ld    L, (IX+0)               ; next_free to HL 
1594			      ld    H, (IX+1) 
1594			 
1594			      ld    (IX+2), L               ; HL to this_free 
1594			      ld    (IX+3), H 
1594			 
1594			 
1594			malloc_update_links: 
1594			      ; Update prev_free ptr to point to this_free 
1594			      ld    L, (IX+4)               ; prev_free ptr to HL 
1594			      ld    H, (IX+5) 
1594			 
1594			      ld    E, (IX+2)               ; this_free ptr to DE 
1594			      ld    D, (IX+3) 
1594			 
1594			      ld    (HL), E                 ; this_free ptr into prev_free 
1594			      inc   HL 
1594			      ld    (HL), D 
1594			 
1594			      ; Clear the Z flag to indicate successful allocation 
1594			      ld    A, D 
1594			      or    E 
1594			 
1594			      pop   DE                      ; Address of allocation 
1594			 
1594			malloc_no_space: 
1594			      ld    HL, 6                   ; Clean up stack frame 
1594			      add   HL, SP 
1594			      ld    SP, HL 
1594			 
1594			      ex    DE, HL                  ; Alloc addr into HL for return 
1594			 
1594			malloc_early_exit: 
1594			      pop   IX 
1594			      pop   DE 
1594			      pop   BC 
1594			 
1594			      ret 
1594			 
1594			 
1594			;------------------------------------------------------------------------------ 
1594			;     free                                                                    : 
1594			;                                                                             : 
1594			; Description                                                                 : 
1594			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1594			;     returned by malloc, otherwise the behaviour is undefined.               : 
1594			;                                                                             : 
1594			;     Where possible, directly adjacent free blocks will be merged together   : 
1594			;     into larger blocks to help ensure that the heap does not become         : 
1594			;     excessively fragmented.                                                 : 
1594			;                                                                             : 
1594			;     free does not clear or set any other value into the freed space, and    : 
1594			;     therefore its contents may be visible through subsequent malloc's. The  : 
1594			;     caller should clear the freed space as required.                        : 
1594			;                                                                             : 
1594			;     This implementation of free uses the stack exclusively, and is          : 
1594			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1594			;     advisable to disable interrupts before calling free, and recommended    : 
1594			;     to avoid the use of free inside ISRs in general.                        : 
1594			;                                                                             : 
1594			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1594			;                                                                             : 
1594			; Parameters                                                                  : 
1594			;     HL  Pointer to address of first byte of allocation to be freed          : 
1594			;                                                                             : 
1594			; Returns                                                                     : 
1594			;     Nothing                                                                 : 
1594			;                                                                             : 
1594			; Stack frame                                                                 : 
1594			;       |             |                                                       : 
1594			;       +-------------+                                                       : 
1594			;       |     BC      |                                                       : 
1594			;       +-------------+                                                       : 
1594			;       |     DE      |                                                       : 
1594			;       +-------------+                                                       : 
1594			;       |     IX      |                                                       : 
1594			;       +-------------+                                                       : 
1594			;       |  prev_free  |                                                       : 
1594			;   +2  +-------------+                                                       : 
1594			;       |  next_free  |                                                       : 
1594			;   +0  +-------------+                                                       : 
1594			;       |             |                                                       : 
1594			;                                                                             : 
1594			;------------------------------------------------------------------------------ 
1594			free: 
1594			      push  BC 
1594			      push  DE 
1594			      push  IX 
1594			 
1594			      ld    A, H                    ; Exit if ptr is null 
1594			      or    L 
1594			      jp    Z, free_early_exit 
1594			 
1594			      ; Set up stack frame 
1594			      ex    DE, HL 
1594			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1594			      add   HL, SP 
1594			      ld    SP, HL 
1594			      ld    IX, 0                   ; Use IX as a frame pointer 
1594			      add   IX, SP 
1594			 
1594			      ; The address in HL points to the start of the useable allocated space, 
1594			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1594			      ; address of the block itself. 
1594			      ex    DE, HL 
1594			      ld    DE, -4 
1594			      add   HL, DE 
1594			 
1594			      ; An allocated block must have a null next block pointer in it 
1594			      ld    A, (HL) 
1594			      inc   HL 
1594			      or    (HL) 
1594			      jp    NZ, free_done 
1594			 
1594			      dec   HL 
1594			 
1594			      ld    B, H                    ; Copy HL to BC 
1594			      ld    C, L 
1594			 
1594			      ; Loop through the free list to find the first block with an address 
1594			      ; higher than the block being freed 
1594			      ld    HL, free_list 
1594			 
1594			free_find_higher_block: 
1594			      ld    E, (HL)                 ; Load next ptr from free block 
1594			      inc   HL 
1594			      ld    D, (HL) 
1594			      dec   HL 
1594			 
1594			      ld    (IX+0), E               ; Save ptr to next free block 
1594			      ld    (IX+1), D 
1594			      ld    (IX+2), L               ; Save ptr to prev free block 
1594			      ld    (IX+3), H 
1594			 
1594			      ld    A, B                    ; Check if DE is greater than BC 
1594			      cp    D                       ; Compare MSB first 
1594			      jr    Z, $+4                  ; MSB the same, compare LSB 
1594			      jr    NC, free_find_higher_block_skip 
1594			      ld    A, C 
1594			      cp    E                       ; Then compare LSB 
1594			      jr    C, free_found_higher_block 
1594			 
1594			free_find_higher_block_skip: 
1594			      ld    A, D                    ; Reached the end of the free list? 
1594			      or    E 
1594			      jp    Z, free_done 
1594			 
1594			      ex    DE, HL 
1594			 
1594			      jr    free_find_higher_block 
1594			 
1594			free_found_higher_block: 
1594			      ; Insert freed block between prev and next free blocks 
1594			      ld    (HL), C                 ; Point prev free block to freed block 
1594			      inc   HL 
1594			      ld    (HL), B 
1594			 
1594			      ld    H, B                    ; Point freed block at next free block 
1594			      ld    L, C 
1594			      ld    (HL), E 
1594			      inc   HL 
1594			      ld    (HL), D 
1594			 
1594			      ; Check if the freed block is adjacent to the next free block 
1594			      inc   HL                      ; Load size of freed block into HL 
1594			      ld    E, (HL) 
1594			      inc   HL 
1594			      ld    D, (HL) 
1594			      ex    DE, HL 
1594			 
1594			      add   HL, BC                  ; Add addr of freed block and its size 
1594			 
1594			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1594			      ld    D, (IX+1) 
1594			 
1594			      or    A                       ; Clear the carry flag 
1594			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1594			      jr    NZ, free_check_adjacent_to_prev 
1594			 
1594			      ; Freed block is adjacent to next, merge into one bigger block 
1594			      ex    DE, HL                  ; Load next ptr from next block into DE 
1594			      ld    E, (HL) 
1594			      inc   HL 
1594			      ld    D, (HL) 
1594			      push  HL                      ; Save ptr to next block for later 
1594			 
1594			      ld    H, B                    ; Store ptr from next block into freed block 
1594			      ld    L, C 
1594			      ld    (HL), E 
1594			      inc   HL 
1594			      ld    (HL), D 
1594			 
1594			      pop   HL                      ; Restore ptr to next block 
1594			      inc   HL                      ; Load size of next block into DE 
1594			      ld    E, (HL) 
1594			      inc   HL 
1594			      ld    D, (HL) 
1594			      push  DE                      ; Save next block size for later 
1594			 
1594			      ld    H, B                    ; Load size of freed block into HL 
1594			      ld    L, C 
1594			      inc   HL 
1594			      inc   HL 
1594			      ld    E, (HL) 
1594			      inc   HL 
1594			      ld    D, (HL) 
1594			      ex    DE, HL 
1594			 
1594			      pop   DE                      ; Restore size of next block 
1594			      add   HL, DE                  ; Add sizes of both blocks 
1594			      ex    DE, HL 
1594			 
1594			      ld    H, B                    ; Store new bigger size into freed block 
1594			      ld    L, C 
1594			      inc   HL 
1594			      inc   HL 
1594			      ld    (HL), E 
1594			      inc   HL 
1594			      ld    (HL), D 
1594			 
1594			free_check_adjacent_to_prev: 
1594			      ; Check if the freed block is adjacent to the prev free block 
1594			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1594			      ld    H, (IX+3) 
1594			 
1594			      inc   HL                      ; Size of prev free block into DE 
1594			      inc   HL 
1594			      ld    E, (HL) 
1594			      inc   HL 
1594			      ld    D, (HL) 
1594			      dec   HL 
1594			      dec   HL 
1594			      dec   HL 
1594			 
1594			      add   HL, DE                  ; Add prev block addr and size 
1594			 
1594			      or    A                       ; Clear the carry flag 
1594			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1594			      jr    NZ, free_done 
1594			 
1594			      ; Freed block is adjacent to prev, merge into one bigger block 
1594			      ld    H, B                    ; Load next ptr from freed block into DE 
1594			      ld    L, C 
1594			      ld    E, (HL) 
1594			      inc   HL 
1594			      ld    D, (HL) 
1594			      push  HL                      ; Save freed block ptr for later 
1594			 
1594			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1594			      ld    H, (IX+3) 
1594			      ld    (HL), E 
1594			      inc   HL 
1594			      ld    (HL), D 
1594			 
1594			      pop   HL                      ; Restore freed block ptr 
1594			      inc   HL                      ; Load size of freed block into DE 
1594			      ld    E, (HL) 
1594			      inc   HL 
1594			      ld    D, (HL) 
1594			      push  DE                      ; Save freed block size for later 
1594			 
1594			      ld    L, (IX+2)               ; Load size of prev block into DE 
1594			      ld    H, (IX+3) 
1594			      inc   HL 
1594			      inc   HL 
1594			      ld    E, (HL) 
1594			      inc   HL 
1594			      ld    D, (HL) 
1594			 
1594			      pop   HL                      ; Add sizes of both blocks 
1594			      add   HL, DE 
1594			      ex    DE, HL 
1594			 
1594			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1594			      ld    H, (IX+3) 
1594			      inc   HL 
1594			      inc   HL 
1594			      ld    (HL), E 
1594			      inc   HL 
1594			      ld    (HL), D 
1594			 
1594			free_done: 
1594			      ld    HL, 4                   ; Clean up stack frame 
1594			      add   HL, SP 
1594			      ld    SP, HL 
1594			 
1594			free_early_exit: 
1594			      pop   IX 
1594			      pop   DE 
1594			      pop   BC 
1594			 
1594			      ret 
1594			 
1594			 
1594			;      .org 0x8000 
1594			; 
1594			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1594			 ;                 .dw   0 
1594			 
1594			endif 
1594			 
1594			 
1594			if MALLOC_4 
1594			 
1594			; My memory allocation code. Very very simple.... 
1594			; allocate space under 250 chars 
1594			 
1594			heap_init: 
1594				; init start of heap as zero 
1594				;  
1594			 
1594				ld hl, heap_start 
1594				ld a, 0 
1594				ld (hl), a      ; empty block 
1594				inc hl 
1594				ld a, 0 
1594				ld (hl), a      ; length of block 
1594				; write end of list 
1594				inc hl 
1594				ld a,(hl) 
1594				inc hl 
1594				ld a,(hl) 
1594				 
1594			 
1594				; init some malloc vars 
1594			 
1594				ld hl, 0 
1594				ld (free_list), hl       ; store last malloc location 
1594			 
1594				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1594				ld a, 0 
1594				ld (hl), a 
1594			 
1594			 
1594				ld hl, heap_start 
1594				;  
1594				  
1594				ret 
1594			 
1594			 
1594			;    free block marker 
1594			;    requested size  
1594			;    pointer to next block 
1594			;    .... 
1594			;    next block marker 
1594			 
1594			 
1594			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1594			; 
1594			 
1594			 
1594			malloc:  
1594				push de 
1594				push bc 
1594				push af 
1594			 
1594				; hl space required 
1594				 
1594				ld c, l    ; hold space   (TODO only a max of 255) 
1594			 
1594			;	inc c     ; TODO BUG need to fix memory leak on push str 
1594			;	inc c 
1594			;	inc c 
1594			;	inc c 
1594			;	inc c 
1594			;	inc c 
1594			;	inc c 
1594			 
1594			 
1594			 
1594				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1594			 
1594				ld a, (free_list+3) 
1594				cp 0 
1594				jr z, .contheap 
1594			 
1594				ld hl, (free_list)     ; get last alloc 
1594					if DEBUG_FORTH_MALLOC_INT 
1594						DMARK "mrs" 
1594						CALLMONITOR 
1594					endif 
1594				jr .startalloc 
1594			 
1594			.contheap: 
1594				ld hl, heap_start 
1594			 
1594			.startalloc: 
1594			 
1594					if DEBUG_FORTH_MALLOC_INT 
1594						DMARK "mym" 
1594						CALLMONITOR 
1594					endif 
1594			.findblock: 
1594					if DEBUG_FORTH_MALLOC_INT 
1594						DMARK "mmf" 
1594						CALLMONITOR 
1594					endif 
1594			 
1594				ld a,(hl)  
1594				; if byte is zero then clear to use 
1594			 
1594				cp 0 
1594				jr z, .foundemptyblock 
1594			 
1594				; if byte is not clear 
1594				;     then byte is offset to next block 
1594			 
1594				inc hl 
1594				ld a, (hl) ; get size 
1594			.nextblock:	inc hl 
1594					ld e, (hl) 
1594					inc hl 
1594					ld d, (hl) 
1594					ex de, hl 
1594			;	inc hl  ; move past the store space 
1594			;	inc hl  ; move past zero index  
1594			 
1594				; TODO detect no more space 
1594			 
1594				push hl 
1594				ld de, heap_end 
1594				call cmp16 
1594				pop hl 
1594				jr nc, .nospace 
1594			 
1594				jr .findblock 
1594			 
1594			.nospace: ld hl, 0 
1594				jp .exit 
1594			 
1594			 
1594			.foundemptyblock:	 
1594					if DEBUG_FORTH_MALLOC_INT 
1594						DMARK "mme" 
1594						CALLMONITOR 
1594					endif 
1594			 
1594			; TODO has block enough space if reusing??? 
1594			 
1594				;  
1594			 
1594			; see if this block has been previously used 
1594				inc hl 
1594				ld a, (hl) 
1594				dec hl 
1594				cp 0 
1594				jr z, .newblock 
1594			 
1594					if DEBUG_FORTH_MALLOC_INT 
1594						DMARK "meR" 
1594						CALLMONITOR 
1594					endif 
1594			 
1594			; no reusing previously allocated block 
1594			 
1594			; is it smaller than previously used? 
1594				 
1594				inc hl    ; move to size 
1594				ld a, c 
1594				sub (hl)        ; we want c < (hl) 
1594				dec hl    ; move back to marker 
1594			        jr z, .findblock 
1594			 
1594				; update with the new size which should be lower 
1594			 
1594			        ;inc  hl   ; negate next move. move back to size  
1594			 
1594			.newblock: 
1594				; need to be at marker here 
1594			 
1594					if DEBUG_FORTH_MALLOC_INT 
1594						DMARK "meN" 
1594						CALLMONITOR 
1594					endif 
1594			 
1594			 
1594				ld a, c 
1594			 
1594				ld (free_list+3), a	 ; flag resume from last malloc  
1594				ld (free_list), hl    ; save out last location 
1594			 
1594			 
1594				;inc a     ; space for length byte 
1594				ld (hl), a     ; save block in use marker 
1594			 
1594				inc hl   ; move to space marker 
1594				ld (hl), a    ; save new space 
1594			 
1594				inc hl   ; move to start of allocated area 
1594				 
1594			;	push hl     ; save where we are - 1  
1594			 
1594			;	inc hl  ; move past zero index  
1594				; skip space to set down new marker 
1594			 
1594				; provide some extra space for now 
1594			 
1594				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1594				inc a 
1594				inc a 
1594			 
1594				push hl   ; save where we are in the node block 
1594			 
1594				call addatohl 
1594			 
1594				; write linked list point 
1594			 
1594				pop de     ; get our node position 
1594				ex de, hl 
1594			 
1594				ld (hl), e 
1594				inc hl 
1594				ld (hl), d 
1594			 
1594				inc hl 
1594			 
1594				; now at start of allocated data so save pointer 
1594			 
1594				push hl 
1594			 
1594				; jump to position of next node and setup empty header in DE 
1594			 
1594				ex de, hl 
1594			 
1594			;	inc hl ; move past end of block 
1594			 
1594				ld a, 0 
1594				ld (hl), a   ; empty marker 
1594				inc hl 
1594				ld (hl), a   ; size 
1594				inc hl  
1594				ld (hl), a   ; ptr 
1594				inc hl 
1594				ld (hl), a   ; ptr 
1594			 
1594			 
1594				pop hl 
1594			 
1594					if DEBUG_FORTH_MALLOC_INT 
1594						DMARK "mmr" 
1594						CALLMONITOR 
1594					endif 
1594			 
1594			.exit: 
1594				pop af 
1594				pop bc 
1594				pop de  
1594				ret 
1594			 
1594			 
1594			 
1594			 
1594			free:  
1594				push hl 
1594				push af 
1594				; get address in hl 
1594			 
1594					if DEBUG_FORTH_MALLOC_INT 
1594						DMARK "fre" 
1594						CALLMONITOR 
1594					endif 
1594				; data is at hl - move to block count 
1594				dec hl 
1594				dec hl    ; get past pointer 
1594				dec hl 
1594			 
1594				ld a, (hl)    ; need this for a validation check 
1594			 
1594				dec hl    ; move to block marker 
1594			 
1594				; now check that the block count and block marker are the same  
1594			        ; this checks that we are on a malloc node and not random memory 
1594			        ; OK a faint chance this could be a problem but rare - famous last words! 
1594			 
1594				ld c, a 
1594				ld a, (hl)    
1594			 
1594				cp c 
1594				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1594			 
1594				; yes good chance we are on a malloc node 
1594			 
1594				ld a, 0      
1594				ld (hl), a   ; mark as free 
1594			 
1594				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1594			 
1594			.freeignore:  
1594			 
1594				pop af 
1594				pop hl 
1594			 
1594				ret 
1594			 
1594			 
1594			 
1594			endif 
1594			 
1594			; eof 
# End of file firmware_memory.asm
1594			  
1594			; device C  
1594			; Now handled by SPI  
1594			;if SOUND_ENABLE  
1594			;	include "firmware_sound.asm"  
1594			;endif  
1594			  
1594			include "firmware_diags.asm"  
1594			; Hardware diags menu 
1594			 
1594			 
1594			config: 
1594			 
1594 3e 00			ld a, 0 
1596 21 bf 15			ld hl, .configmn 
1599 cd cc 0d			call menu 
159c			 
159c fe 00			cp 0 
159e c8				ret z 
159f			 
159f			;	cp 1 
159f			;	call z, .savetostore 
159f			 
159f fe 01			cp 1 
15a1			if STARTUP_V1 
15a1				call z, .selautoload 
15a1			endif 
15a1			 
15a1			if STARTUP_V2 
15a1 cc cd 15			call z, .enautoload 
15a4			endif 
15a4 fe 02			cp 2 
15a6 cc e4 15			call z, .disautoload 
15a9			;	cp 3 
15a9			;	call z, .selbank 
15a9 fe 03			cp 3 
15ab cc 52 18			call z, .debug_tog 
15ae fe 04			cp 4 
15b0 cc a0 19			call z, .bpsgo 
15b3 fe 05			cp 5 
15b5 cc 7b 18			call z, hardware_diags 
15b8			if STARTUP_V2 
15b8 fe 06			cp 6 
15ba cc 10 16			call z, create_startup 
15bd			endif 
15bd 18 d5			jr config 
15bf			 
15bf			.configmn: 
15bf			;	dw prom_c3 
15bf 8e 1b			dw prom_c2 
15c1 a4 1b			dw prom_c2a 
15c3			;	dw prom_c2b 
15c3			;	dw prom_c4 
15c3 11 1c			dw prom_m4 
15c5 2c 1c			dw prom_m4b 
15c7 34 1c			dw prom_c1 
15c9			if STARTUP_V2 
15c9 43 1c			dw prom_c9 
15cb			endif 
15cb 00 00			dw 0 
15cd				 
15cd			 
15cd			if STARTUP_V2 
15cd			.enautoload: 
15cd				if STORAGE_SE 
15cd 3e fe			ld a, $fe      ; bit 0 clear 
15cf 32 9b f9			ld (spi_device), a 
15d2			 
15d2 cd 16 05			call storage_get_block_0 
15d5			 
15d5 3e 01			ld a, 1 
15d7 32 d6 f9			ld (store_page+STORE_0_AUTOFILE), a 
15da			 
15da 21 00 00				ld hl, 0 
15dd 11 b5 f9				ld de, store_page 
15e0 cd ca 04			call storage_write_block	 ; save update 
15e3				else 
15e3			 
15e3				ld hl, prom_notav 
15e3				ld de, prom_empty 
15e3				call info_panel 
15e3				endif 
15e3			 
15e3			 
15e3 c9				ret 
15e4			endif 
15e4			 
15e4			.disautoload: 
15e4				if STORAGE_SE 
15e4 3e fe			ld a, $fe      ; bit 0 clear 
15e6 32 9b f9			ld (spi_device), a 
15e9			 
15e9 cd 16 05			call storage_get_block_0 
15ec			 
15ec 3e 00			ld a, 0 
15ee 32 d6 f9			ld (store_page+STORE_0_AUTOFILE), a 
15f1			 
15f1 21 00 00				ld hl, 0 
15f4 11 b5 f9				ld de, store_page 
15f7 cd ca 04			call storage_write_block	 ; save update 
15fa				else 
15fa			 
15fa				ld hl, prom_notav 
15fa				ld de, prom_empty 
15fa				call info_panel 
15fa				endif 
15fa			 
15fa			 
15fa c9				ret 
15fb			 
15fb			if STARTUP_V1 
15fb			 
15fb			; Select auto start 
15fb			 
15fb			.selautoload: 
15fb			 
15fb				 
15fb				if STORAGE_SE 
15fb			 
15fb					call config_dir 
15fb				        ld hl, scratch 
15fb					ld a, 0 
15fb					call menu 
15fb			 
15fb					cp 0 
15fb					ret z 
15fb			 
15fb					dec a 
15fb			 
15fb			 
15fb					; locate menu option 
15fb			 
15fb					ld hl, scratch 
15fb					call table_lookup 
15fb			 
15fb					if DEBUG_FORTH_WORDS 
15fb						DMARK "ALl" 
15fb						CALLMONITOR 
15fb					endif 
15fb					; with the pointer to the menu it, the byte following the zero term is the file id 
15fb			 
15fb					ld a, 0 
15fb					ld bc, 50   ; max of bytes to look at 
15fb					cpir  
15fb			 
15fb					if DEBUG_FORTH_WORDS 
15fb						DMARK "ALb" 
15fb						CALLMONITOR 
15fb					endif 
15fb					;inc hl 
15fb			 
15fb					ld a, (hl)   ; file id 
15fb					 
15fb				        ; save bank and file ids 
15fb			 
15fb					push af 
15fb			 
15fb			; TODO need to save to block 0 on bank 1	 
15fb			 
15fb					call storage_get_block_0 
15fb			 
15fb					if DEBUG_FORTH_WORDS 
15fb						DMARK "AL0" 
15fb						CALLMONITOR 
15fb					endif 
15fb					pop af 
15fb			 
15fb					ld (store_page+STORE_0_FILERUN),a 
15fb					 
15fb					; save bank id 
15fb			 
15fb					ld a,(spi_device) 
15fb					ld (store_page+STORE_0_BANKRUN),a 
15fb			 
15fb					; enable auto run of store file 
15fb			 
15fb					ld a, 1 
15fb					ld (store_page+STORE_0_AUTOFILE),a 
15fb			 
15fb					; save buffer 
15fb			 
15fb					ld hl, 0 
15fb					ld de, store_page 
15fb					if DEBUG_FORTH_WORDS 
15fb						DMARK "ALw" 
15fb						CALLMONITOR 
15fb					endif 
15fb				call storage_write_block	 ; save update 
15fb			  
15fb			 
15fb			 
15fb			 
15fb					ld hl, scratch 
15fb					call config_fdir 
15fb			 
15fb				else 
15fb			 
15fb				ld hl, prom_notav 
15fb				ld de, prom_empty 
15fb				call info_panel 
15fb			 
15fb				endif 
15fb				ret 
15fb			endif 
15fb			 
15fb			 
15fb			; Select storage bank 
15fb			 
15fb			.selbank: 
15fb			 
15fb			;	if STORAGE_SE 
15fb			;	else 
15fb			 
15fb 21 58 1c			ld hl, prom_notav 
15fe 11 6e 1c			ld de, prom_empty 
1601 cd 2c 0d			call info_panel 
1604			;	endif 
1604				 
1604 c9				ret 
1605			 
1605			if STORAGE_SE 
1605			 
1605			.config_ldir:   
1605				; Load storage bank labels into menu array 
1605			 
1605				 
1605			 
1605			 
1605 c9				ret 
1606			 
1606			 
1606			endif 
1606			 
1606			 
1606			; Save user words to storage 
1606			 
1606			.savetostore: 
1606			 
1606			;	if STORAGE_SE 
1606			; 
1606			;		call config_dir 
1606			;	        ld hl, scratch 
1606			;		ld a, 0 
1606			;		call menu 
1606			;		 
1606			;		ld hl, scratch 
1606			;		call config_fdir 
1606			; 
1606			;	else 
1606			 
1606 21 58 1c			ld hl, prom_notav 
1609 11 6e 1c			ld de, prom_empty 
160c cd 2c 0d			call info_panel 
160f			 
160f			;	endif 
160f			 
160f c9				ret 
1610			 
1610			if STARTUP_V2 
1610			 
1610			create_startup: 
1610			 
1610 3e 00			ld a, 0 
1612 21 79 17			ld hl, .crstart 
1615 cd cc 0d			call menu 
1618			 
1618 fe 00			cp 0 
161a c8				ret z 
161b			 
161b fe 01			cp 1 
161d cc 4a 16			call z, .genlsword 
1620 fe 02			cp 2 
1622 cc 54 16			call z, .genedword 
1625			 
1625 fe 03			cp 3 
1627 cc 5e 16			call z, .gendemword 
162a			 
162a fe 04			cp 4 
162c cc 68 16			call z, .genutlword 
162f fe 05			cp 5 
1631 cc 72 16			call z, .genspiword 
1634 fe 06			cp 6 
1636 cc 7c 16			call z, .genkeyword 
1639 fe 07			cp 7 
163b cc 40 16			call z, .gensoundword 
163e 18 d0			jr create_startup 
1640			 
1640			.gensoundword: 
1640 21 fc 1b			ld hl, crs_sound 
1643 11 c9 16			ld de, .soundworddef 
1646 cd 86 16			call .genfile 
1649 c9				ret 
164a			.genlsword: 
164a 21 bb 1b			ld hl, crs_s1 
164d 11 ed 16			ld de, .lsworddef 
1650 cd 86 16			call .genfile 
1653 c9				ret 
1654			 
1654			.genedword: 
1654 11 f1 16			ld de, .edworddef 
1657 21 c4 1b			ld hl, crs_s2 
165a cd 86 16			call .genfile 
165d c9				ret 
165e			 
165e			.gendemword: 
165e 11 f9 16			ld de, .demoworddef 
1661 21 cd 1b			ld hl, crs_s3 
1664 cd 86 16			call .genfile 
1667 c9				ret 
1668			 
1668			.genutlword: 
1668 21 dc 1b			ld hl, crs_s4 
166b 11 dd 16			ld de, .utilwordef 
166e cd 86 16			call .genfile 
1671 c9				ret 
1672			.genspiword: 
1672 21 e3 1b			ld hl, crs_s5 
1675 11 3f 17			ld de, .spiworddef 
1678 cd 86 16			call .genfile 
167b c9				ret 
167c			.genkeyword: 
167c 21 ed 1b			ld hl, crs_s6 
167f 11 4d 17			ld de, .keyworddef 
1682 cd 86 16			call .genfile 
1685 c9				ret 
1686			 
1686			; hl - points to file name 
1686			; de - points to strings to add to file 
1686			 
1686			.genfile: 
1686 e5				push hl 
1687 d5				push de 
1688			 
1688 cd 9b 0d			call clear_display 
168b 3e 00			ld a, display_row_1 
168d 11 b8 16			ld de, .genfiletxt 
1690 cd ae 0d			call str_at_display 
1693 cd be 0d			call update_display 
1696			 
1696 d1				pop de 
1697 e1				pop hl 
1698			 
1698			 
1698 d5				push de 
1699 cd 68 08			call storage_create 
169c				; id in hl 
169c d1				pop de   ; table of strings to add 
169d			 
169d			.genloop: 
169d			 
169d e5				push hl ; save id for next time around 
169e d5				push de ; save de for next time around 
169f			 
169f eb				ex de, hl 
16a0 cd 8b 23			call loadwordinhl 
16a3 eb				ex de, hl 
16a4			 
16a4				; need hl to be the id 
16a4				; need de to be the string ptr 
16a4				 
16a4 cd 55 0b			call storage_append 
16a7			 
16a7 d1				pop de 
16a8 e1				pop hl 
16a9			 
16a9 13				inc de 
16aa 13				inc de 
16ab			 
16ab 1a				ld a,(de) 
16ac fe 00			cp 0 
16ae 20 ed			jr nz, .genloop 
16b0 13				inc de 
16b1 1a				ld a, (de) 
16b2 1b				dec de 
16b3 fe 00			cp 0 
16b5 20 e6			jr nz, .genloop	 
16b7			 
16b7 c9				ret 
16b8			 
16b8 .. 00		.genfiletxt:  db "Creating file...",0 
16c9			 
16c9			.soundworddef: 
16c9 14 6a			dw sound1 
16cb 38 6a			dw sound2 
16cd 68 6a			dw sound3 
16cf 8d 6a			dw sound4 
16d1 9a 6a			dw sound5 
16d3 a7 6a			dw sound6 
16d5 b4 6a			dw sound7 
16d7 c1 6a			dw sound8 
16d9 d9 6a			dw sound9 
16db 00 00			dw 0 
16dd			 
16dd			.utilwordef: 
16dd 65 63			dw strncpy 
16df 40 63			dw type 
16e1 0c 63			dw clrstack 
16e3 c5 62			dw longread 
16e5 c6 63			dw start1 
16e7 d6 63			dw start2 
16e9			; duplicated 
16e9			;	dw start3b 
16e9			;	dw start3c 
16e9 c2 64			dw list 
16eb 00 00			dw 0 
16ed			 
16ed			.lsworddef: 
16ed e7 63			dw start3b 
16ef 00 00			dw 0 
16f1			 
16f1			.edworddef: 
16f1 24 5f			dw edit1 
16f3 45 5f			dw edit2 
16f5 7a 5f			dw edit3 
16f7 00 00			dw 0 
16f9			 
16f9			.demoworddef: 
16f9 0a 69			dw test5 
16fb 42 69			dw test6 
16fd 7a 69			dw test7 
16ff 8e 69			dw test8 
1701 ba 69			dw test9 
1703 d0 69			dw test10 
1705 f0 6a			dw game1 
1707 01 6b			dw game1a 
1709 63 6b			dw game1b 
170b 98 6b			dw game1c 
170d ce 6b			dw game1d 
170f ff 6b			dw game1s 
1711 13 6c			dw game1t 
1713 28 6c			dw game1f 
1715 5c 6c			dw game1z 
1717 a0 6c			dw game1zz 
1719 09 6d			dw ssv2 
171b 3f 6d			dw ssv3 
171d 5b 6d			dw ssv4 
171f 77 6d			dw ssv5 
1721 90 6d			dw ssv1 
1723 d8 6d			dw ssv1cpm	 
1725 2f 6e			dw game2b 
1727 9d 6e			dw game2bf 
1729 e7 6e			dw game2mba 
172b 7d 6f			dw game2mbas	 
172d a2 6f			dw game2mbht 
172f b1 6f			dw game2mbms 
1731 bf 6f			dw game2mb 
1733 3c 70			dw game3w 
1735 6a 70			dw game3p 
1737 88 70			dw game3sc 
1739 b9 70			dw game3vsi 
173b e5 70			dw game3vs 
173d 00 00			dw 0 
173f			 
173f			 
173f			.spiworddef: 
173f			 
173f b2 5f		    dw spi1 
1741 0b 60		    dw spi2 
1743 3f 60		    dw spi2b 
1745 c3 60		    dw spi3 
1747 6d 60		    dw spi4 
1749 96 60		    dw spi5 
174b			;    dw spi6 
174b			;    dw spi7 
174b			 
174b			;    dw spi8 
174b			;    dw spi9 
174b			;    dw spi10 
174b 00 00		    dw 0 
174d			 
174d			.keyworddef: 
174d			 
174d 24 71			dw keyup 
174f 32 71			dw keydown 
1751 42 71			dw keyleft 
1753 52 71			dw keyright 
1755 63 71			dw 	keyf1 
1757 71 71			dw keyf2 
1759 7f 71			dw keyf3 
175b 8d 71			dw keyf4 
175d 9b 71			dw keyf5 
175f a9 71			dw keyf6 
1761 b7 71			dw keyf7 
1763 c5 71			dw keyf8 
1765 d3 71			dw keyf9 
1767 e1 71			dw keyf10 
1769 f0 71			dw keyf11 
176b ff 71			dw keyf12 
176d 0e 72			dw keytab 
176f 1d 72			dw keycr 
1771 2b 72			dw keyhome 
1773 3b 72			dw keyend 
1775 4a 72			dw keybs 
1777 00 00			dw 0 
1779			 
1779			.crstart: 
1779 bb 1b			dw crs_s1 
177b c4 1b			dw crs_s2 
177d cd 1b			dw crs_s3 
177f dc 1b			dw crs_s4 
1781 e3 1b			dw crs_s5 
1783 ed 1b			dw crs_s6 
1785 fc 1b			dw crs_sound 
1787 00 00			dw 0 
1789			 
1789			endif 
1789			 
1789			 
1789			if STORAGE_SE 
1789			 
1789			config_fdir: 
1789				; using the scratch dir go through and release the memory allocated for each string 
1789				 
1789 21 fc f0			ld hl, scratch 
178c 5e			.cfdir:	ld e,(hl) 
178d 23				inc hl 
178e 56				ld d,(hl) 
178f 23				inc hl 
1790			 
1790 eb				ex de, hl 
1791 cd f8 0f			call ishlzero 
1794 c8				ret z     ; return on null pointer 
1795 cd c5 14			call free 
1798 eb				ex de, hl 
1799 18 f1			jr .cfdir 
179b			 
179b			 
179b c9				ret 
179c			 
179c			 
179c			config_dir: 
179c			 
179c				; for the config menus that need to build a directory of storage call this routine 
179c				; it will construct a menu in scratch to pass to menu 
179c			 
179c				; open storage device 
179c			 
179c				; execute DIR to build a list of files and their ids into scratch in menu format 
179c				; once the menu has finished then will need to call config_fdir to release the strings 
179c				 
179c				; c = number items 
179c			 
179c				 
179c cd 16 05			call storage_get_block_0 
179f			 
179f 21 b5 f9			ld hl, store_page     ; get current id count 
17a2 46				ld b, (hl) 
17a3 0e 00			ld c, 0    ; count of files   
17a5			 
17a5			 
17a5 21 fc f0			ld hl, scratch 
17a8 22 ac f9			ld (store_tmp2), hl    ; location to poke strings 
17ab			 
17ab				; check for empty drive 
17ab			 
17ab 3e 00			ld a, 0 
17ad b8				cp b 
17ae ca 48 18			jp z, .dirdone 
17b1			 
17b1				 
17b1					if DEBUG_FORTH_WORDS 
17b1						DMARK "Cdc" 
17b1 f5				push af  
17b2 3a c6 17			ld a, (.dmark)  
17b5 32 a6 fd			ld (debug_mark),a  
17b8 3a c7 17			ld a, (.dmark+1)  
17bb 32 a7 fd			ld (debug_mark+1),a  
17be 3a c8 17			ld a, (.dmark+2)  
17c1 32 a8 fd			ld (debug_mark+2),a  
17c4 18 03			jr .pastdmark  
17c6 ..			.dmark: db "Cdc"  
17c9 f1			.pastdmark: pop af  
17ca			endm  
# End of macro DMARK
17ca						CALLMONITOR 
17ca cd aa fd			call debug_vector  
17cd				endm  
# End of macro CALLMONITOR
17cd					endif 
17cd			 
17cd			 
17cd			.diritem:	 
17cd c5				push bc 
17ce				; for each of the current ids do a search for them and if found push to stack 
17ce			 
17ce 21 40 00				ld hl, STORE_BLOCK_PHY 
17d1 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
17d3 58					ld e,b 
17d4			 
17d4 cd 98 07				call storage_findnextid 
17d7			 
17d7			 
17d7					; if found hl will be non zero 
17d7			 
17d7 cd f8 0f				call ishlzero 
17da 28 69				jr z, .dirnotfound 
17dc			 
17dc					; increase count 
17dc			 
17dc c1					pop bc	 
17dd 0c					inc c 
17de c5					push bc 
17df					 
17df			 
17df					; get file header and push the file name 
17df			 
17df 11 b5 f9				ld de, store_page 
17e2 cd 65 04				call storage_read_block 
17e5			 
17e5					; push file id to stack 
17e5				 
17e5 3a b5 f9				ld a, (store_page) 
17e8 26 00				ld h, 0 
17ea 6f					ld l, a 
17eb			 
17eb					;call forth_push_numhl 
17eb					; TODO store id 
17eb			 
17eb e5					push hl 
17ec			 
17ec					; push extent count to stack  
17ec				 
17ec 21 b8 f9				ld hl, store_page+3 
17ef			 
17ef					; get file name length 
17ef			 
17ef cd 86 13				call strlenz   
17f2			 
17f2 23					inc hl   ; cover zero term 
17f3 23					inc hl  ; stick the id at the end of the area 
17f4			 
17f4 e5					push hl 
17f5 c1					pop bc    ; move length to bc 
17f6			 
17f6 cd fb 13				call malloc 
17f9			 
17f9					; TODO save malloc area to scratch 
17f9			 
17f9 eb					ex de, hl 
17fa 2a ac f9				ld hl, (store_tmp2) 
17fd 73					ld (hl), e 
17fe 23					inc hl 
17ff 72					ld (hl), d 
1800 23					inc hl 
1801 22 ac f9				ld (store_tmp2), hl 
1804			 
1804					 
1804			 
1804					;pop hl   ; get source 
1804			;		ex de, hl    ; swap aronund	 
1804			 
1804 21 b8 f9				ld hl, store_page+3 
1807					if DEBUG_FORTH_WORDS 
1807						DMARK "CFd" 
1807 f5				push af  
1808 3a 1c 18			ld a, (.dmark)  
180b 32 a6 fd			ld (debug_mark),a  
180e 3a 1d 18			ld a, (.dmark+1)  
1811 32 a7 fd			ld (debug_mark+1),a  
1814 3a 1e 18			ld a, (.dmark+2)  
1817 32 a8 fd			ld (debug_mark+2),a  
181a 18 03			jr .pastdmark  
181c ..			.dmark: db "CFd"  
181f f1			.pastdmark: pop af  
1820			endm  
# End of macro DMARK
1820						CALLMONITOR 
1820 cd aa fd			call debug_vector  
1823				endm  
# End of macro CALLMONITOR
1823					endif 
1823 ed b0				ldir 
1825			 
1825					; de is past string, move back one and store id 
1825					 
1825 1b					dec de 
1826			 
1826					; store file id 
1826			 
1826 e1					pop hl 
1827 eb					ex de,hl 
1828 73					ld (hl), e 
1829			 
1829					if DEBUG_FORTH_WORDS 
1829						DMARK "Cdi" 
1829 f5				push af  
182a 3a 3e 18			ld a, (.dmark)  
182d 32 a6 fd			ld (debug_mark),a  
1830 3a 3f 18			ld a, (.dmark+1)  
1833 32 a7 fd			ld (debug_mark+1),a  
1836 3a 40 18			ld a, (.dmark+2)  
1839 32 a8 fd			ld (debug_mark+2),a  
183c 18 03			jr .pastdmark  
183e ..			.dmark: db "Cdi"  
1841 f1			.pastdmark: pop af  
1842			endm  
# End of macro DMARK
1842						CALLMONITOR 
1842 cd aa fd			call debug_vector  
1845				endm  
# End of macro CALLMONITOR
1845					endif 
1845					 
1845			.dirnotfound: 
1845 c1					pop bc     
1846 10 85				djnz .diritem 
1848				 
1848			.dirdone:	 
1848			 
1848 3e 00				ld a, 0 
184a 2a ac f9				ld hl, (store_tmp2) 
184d 77					ld (hl), a 
184e 23					inc hl 
184f 77					ld (hl), a 
1850 23					inc hl 
1851					; push a count of the dir items found 
1851			 
1851			;		ld h, 0 
1851			;		ld l, c 
1851			 
1851 c9				ret 
1852			 
1852			endif 
1852			 
1852			 
1852			; Settings 
1852			; Run  
1852			 
1852			 
1852			 
1852			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1852			;;hd_menu2:   db "        2: Editor",0   
1852			;hd_menu2:   db "        2: Editor       6: Menu",0   
1852			;hd_menu3:   db "        3: Storage",0 
1852			;hd_menu4:   db "0=quit  4: Debug",0 
1852			;hd_don:     db "ON",0 
1852			;hd_doff:     db "OFF",0 
1852			; 
1852			; 
1852			; 
1852			;hardware_diags_old:       
1852			; 
1852			;.diagmenu: 
1852			;	call clear_display 
1852			;	ld a, display_row_1 
1852			;	ld de, hd_menu1 
1852			;	call str_at_display 
1852			; 
1852			;	ld a, display_row_2 
1852			;	ld de, hd_menu2 
1852			;	call str_at_display 
1852			; 
1852			;	ld a, display_row_3 
1852			;	ld de, hd_menu3 
1852			;	call str_at_display 
1852			; 
1852			;	ld a,  display_row_4 
1852			;	ld de, hd_menu4 
1852			;	call str_at_display 
1852			; 
1852			;	; display debug state 
1852			; 
1852			;	ld de, hd_don 
1852			;	ld a, (os_view_disable) 
1852			;	cp 0 
1852			;	jr z, .distog 
1852			;	ld de, hd_doff 
1852			;.distog: ld a, display_row_4+17 
1852			;	call str_at_display 
1852			; 
1852			;	call update_display 
1852			; 
1852			;	call cin_wait 
1852			; 
1852			; 
1852			; 
1852			;	cp '4' 
1852			;	jr nz, .diagn1 
1852			; 
1852			;	; debug toggle 
1852			; 
1852			;	ld a, (os_view_disable) 
1852			;	ld b, '*' 
1852			;	cp 0 
1852			;	jr z, .debtog 
1852			;	ld b, 0 
1852			;.debtog:	 
1852			;	ld a,b 
1852			;	ld (os_view_disable),a 
1852			; 
1852			;.diagn1: cp '0' 
1852			;	 ret z 
1852			; 
1852			;;	cp '1' 
1852			;;       jp z, matrix	 
1852			;;   TODO keyboard matrix test 
1852			; 
1852			;	cp '2' 
1852			;	jp z, .diagedit 
1852			; 
1852			;;	cp '6' 
1852			;;	jp z, .menutest 
1852			;;if ENABLE_BASIC 
1852			;;	cp '6' 
1852			;;	jp z, basic 
1852			;;endif 
1852			 ; 
1852			;	jp .diagmenu 
1852			; 
1852			; 
1852			;	ret 
1852			 
1852			 
1852			.debug_tog: 
1852 21 9c 18			ld hl, .menudebug 
1855				 
1855			;	ld a, (os_view_disable) 
1855			;	cp '*' 
1855 3a aa fd			ld a,(debug_vector) 
1858 fe c9			cp $C9   ; RET 
185a 20 04			jr nz,.tdon  
185c 3e 01			ld a, 1 
185e 18 02			jr .tog1 
1860 3e 00		.tdon: ld a, 0 
1862			 
1862			.tog1: 
1862 cd cc 0d			call menu 
1865 fe 00			cp 0 
1867 c8				ret z 
1868 fe 01			cp 1    ; disable debug 
186a 28 04			jr z, .dtog0 
186c 3e 2a			ld a, '*' 
186e 18 05			jr .dtogset 
1870			.dtog0:  
1870				;ld a, 0 
1870 cd 8e 19			call bp_on 
1873 18 dd			jr .debug_tog 
1875			.dtogset:  
1875				; ld (os_view_disable), a 
1875 cd 9a 19			call bp_off 
1878 c3 52 18			jp .debug_tog 
187b			 
187b			 
187b			hardware_diags:       
187b			 
187b			.diagm: 
187b 21 8e 18			ld hl, .menuitems 
187e 3e 00			ld a, 0 
1880 cd cc 0d			call menu 
1883			 
1883 fe 00		         cp 0 
1885 c8				 ret z 
1886			 
1886 fe 02			cp 2 
1888 ca e7 18			jp z, .diagedit 
188b			 
188b			;	cp '6' 
188b			;	jp z, .menutest 
188b			;if ENABLE_BASIC 
188b			;	cp '6' 
188b			;	jp z, basic 
188b			;endif 
188b			  
188b c3 7b 18			jp .diagm 
188e			 
188e				 
188e a2 18		.menuitems:   	dw .m1 
1890 ad 18				dw .m2 
1892 b4 18				dw .m3 
1894 bc 18				dw .m5 
1896 c2 18				dw .m5a 
1898 cb 18				dw .m5b 
189a 00 00				dw 0 
189c			 
189c			.menudebug: 
189c d4 18				dw .m6 
189e dd 18				dw .m7 
18a0 00 00				dw 0 
18a2			 
18a2 .. 00		.m1:   db "Key Matrix",0 
18ad .. 00		.m2:   db "Editor",0 
18b4 .. 00		.m3:   db "Storage",0 
18bc .. 00		.m5:   db "Sound",0 
18c2 .. 00		.m5a:  db "RAM Test",0 
18cb .. 00		.m5b:  db "LCD Test",0 
18d4			 
18d4 .. 00		.m6:   db "Debug ON",0 
18dd .. 00		.m7:   db "Debug OFF",0 
18e7			 
18e7			; debug editor 
18e7			 
18e7			.diagedit: 
18e7			 
18e7 21 fc f0			ld hl, scratch 
18ea			;	ld bc, 250 
18ea			;	ldir 
18ea				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18ea 3e 00			ld a, 0 
18ec 77				ld (hl), a 
18ed 23				inc hl 
18ee 77				ld (hl), a 
18ef 23				inc hl 
18f0 77				ld (hl), a 
18f1			 
18f1 cd 9b 0d		        call clear_display 
18f4 cd be 0d			call update_display 
18f7				;ld a, 1 
18f7				;ld (hardware_diag), a 
18f7			.diloop: 
18f7 3e 00			ld a, display_row_1 
18f9 0e 00			ld c, 0 
18fb 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18fd 1e 28			ld e, 40 
18ff			 
18ff 21 fc f0			ld hl, scratch	 
1902 cd fc 0f			call input_str 
1905			 
1905 3e 28			ld a, display_row_2 
1907 11 fc f0			ld de, scratch 
190a cd ae 0d			call str_at_display 
190d cd be 0d			call update_display 
1910			 
1910 c3 f7 18			jp .diloop 
1913			 
1913			 
1913			; pass word in hl 
1913			; a has display location 
1913			display_word_at: 
1913 f5				push af 
1914 e5				push hl 
1915 7c				ld a,h 
1916 21 01 f4			ld hl, os_word_scratch 
1919 cd 29 12			call hexout 
191c e1				pop hl 
191d 7d				ld a,l 
191e 21 03 f4			ld hl, os_word_scratch+2 
1921 cd 29 12			call hexout 
1924 21 05 f4			ld hl, os_word_scratch+4 
1927 3e 00			ld a,0 
1929 77				ld (hl),a 
192a 11 01 f4			ld de,os_word_scratch 
192d f1				pop af 
192e cd ae 0d				call str_at_display 
1931 c9				ret 
1932			 
1932			display_ptr_state: 
1932			 
1932				; to restore afterwards 
1932			 
1932 d5				push de 
1933 c5				push bc 
1934 e5				push hl 
1935 f5				push af 
1936			 
1936				; for use in here 
1936			 
1936			;	push bc 
1936			;	push de 
1936			;	push hl 
1936			;	push af 
1936			 
1936 cd 9b 0d			call clear_display 
1939			 
1939 11 11 1b			ld de, .ptrstate 
193c 3e 00			ld a, display_row_1 
193e cd ae 0d			call str_at_display 
1941			 
1941				; display debug step 
1941			 
1941			 
1941 11 a6 fd			ld de, debug_mark 
1944 3e 26			ld a, display_row_1+display_cols-2 
1946 cd ae 0d			call str_at_display 
1949			 
1949				; display a 
1949 11 1b 1b			ld de, .ptrcliptr 
194c 3e 28			ld a, display_row_2 
194e cd ae 0d			call str_at_display 
1951			 
1951 f1				pop af 
1952 2a 7b f9			ld hl,(cli_ptr) 
1955 3e 30			ld a, display_row_2+8 
1957 cd 13 19			call display_word_at 
195a			 
195a			 
195a				; display hl 
195a			 
195a			 
195a 11 23 1b			ld de, .ptrclioptr 
195d 3e 32			ld a, display_row_2+10 
195f cd ae 0d			call str_at_display 
1962			; 
1962			;	pop hl 
1962 3e 35			ld a, display_row_2+13 
1964 2a 79 f9			ld hl,(cli_origptr) 
1967 cd 13 19			call display_word_at 
196a			; 
196a			;	 
196a			;	; display de 
196a			 
196a			;	ld de, .regstatede 
196a			;	ld a, display_row_3 
196a			;	call str_at_display 
196a			 
196a			;	pop de 
196a			;	ld h,d 
196a			;	ld l, e 
196a			;	ld a, display_row_3+3 
196a			;	call display_word_at 
196a			 
196a			 
196a				; display bc 
196a			 
196a			;	ld de, .regstatebc 
196a			;	ld a, display_row_3+10 
196a			;	call str_at_display 
196a			 
196a			;	pop bc 
196a			;	ld h,b 
196a			;	ld l, c 
196a			;	ld a, display_row_3+13 
196a			;	call display_word_at 
196a			 
196a			 
196a				; display dsp 
196a			 
196a			;	ld de, .regstatedsp 
196a			;	ld a, display_row_4 
196a			;	call str_at_display 
196a			 
196a				 
196a			;	ld hl,(cli_data_sp) 
196a			;	ld a, display_row_4+4 
196a			;	call display_word_at 
196a			 
196a				; display rsp 
196a			 
196a 11 52 1b			ld de, .regstatersp 
196d 3e 82			ld a, display_row_4+10 
196f cd ae 0d			call str_at_display 
1972			 
1972				 
1972 2a 2d f9			ld hl,(cli_ret_sp) 
1975 3e 86			ld a, display_row_4+14 
1977 cd 13 19			call display_word_at 
197a			 
197a cd be 0d			call update_display 
197d			 
197d cd de 0c			call delay1s 
1980 cd de 0c			call delay1s 
1983 cd de 0c			call delay1s 
1986			 
1986			 
1986 cd d4 1f			call next_page_prompt 
1989			 
1989				; restore  
1989			 
1989 f1				pop af 
198a e1				pop hl 
198b c1				pop bc 
198c d1				pop de 
198d c9				ret 
198e			 
198e			; Update the break point vector so that the user can hook a new routine 
198e			 
198e			bp_on: 
198e 3e c3			ld a, $c3    ; JP 
1990 32 aa fd			ld (debug_vector), a 
1993 21 a0 19			ld hl, break_point_state 
1996 22 ab fd			ld (debug_vector+1), hl 
1999 c9				ret 
199a			 
199a			bp_off: 
199a 3e c9			ld a, $c9    ; RET 
199c 32 aa fd			ld (debug_vector), a 
199f c9				ret 
19a0			 
19a0			 
19a0			break_point_state: 
19a0			;	push af 
19a0			; 
19a0			;	; see if disabled 
19a0			; 
19a0			;	ld a, (os_view_disable) 
19a0			;	cp '*' 
19a0			;	jr nz, .bpsgo 
19a0			;	pop af 
19a0			;	ret 
19a0			 
19a0			.bpsgo: 
19a0			;	pop af 
19a0 f5				push af 
19a1 22 de f0			ld (os_view_hl), hl 
19a4 ed 53 dc f0		ld (os_view_de), de 
19a8 ed 43 da f0		ld (os_view_bc), bc 
19ac e5				push hl 
19ad 6f				ld l, a 
19ae 26 00			ld h, 0 
19b0 22 e0 f0			ld (os_view_af),hl 
19b3			 
19b3 21 ec fc				ld hl, display_fb0 
19b6 22 07 fb				ld (display_fb_active), hl 
19b9 e1				pop hl	 
19ba			 
19ba 3e 31			ld a, '1' 
19bc fe 2a		.bps1:  cp '*' 
19be cc 9a 19			call z, bp_off 
19c1			;	jr nz, .bps1b 
19c1			;	ld (os_view_disable),a 
19c1 fe 31		.bps1b:  cp '1' 
19c3 20 14			jr nz, .bps2 
19c5			 
19c5				; display reg 
19c5			 
19c5				 
19c5			 
19c5 3a e0 f0			ld a, (os_view_af) 
19c8 2a de f0			ld hl, (os_view_hl) 
19cb ed 5b dc f0		ld de, (os_view_de) 
19cf ed 4b da f0		ld bc, (os_view_bc) 
19d3 cd 6d 1a			call display_reg_state 
19d6 c3 59 1a			jp .bpschk 
19d9			 
19d9 fe 32		.bps2:  cp '2' 
19db 20 08			jr nz, .bps3 
19dd				 
19dd				; display hl 
19dd 2a de f0			ld hl, (os_view_hl) 
19e0 cd 57 1b			call display_dump_at_hl 
19e3			 
19e3 18 74			jr .bpschk 
19e5			 
19e5 fe 33		.bps3:  cp '3' 
19e7 20 08			jr nz, .bps4 
19e9			 
19e9			        ; display de 
19e9 2a dc f0			ld hl, (os_view_de) 
19ec cd 57 1b			call display_dump_at_hl 
19ef			 
19ef 18 68			jr .bpschk 
19f1 fe 34		.bps4:  cp '4' 
19f3 20 08			jr nz, .bps5 
19f5			 
19f5			        ; display bc 
19f5 2a da f0			ld hl, (os_view_bc) 
19f8 cd 57 1b			call display_dump_at_hl 
19fb			 
19fb 18 5c			jr .bpschk 
19fd fe 35		.bps5:  cp '5' 
19ff 20 08		        jr nz, .bps7 
1a01			 
1a01				; display cur ptr 
1a01 2a 7b f9			ld hl, (cli_ptr) 
1a04 cd 57 1b			call display_dump_at_hl 
1a07			 
1a07 18 50			jr .bpschk 
1a09 fe 36		.bps7:  cp '6' 
1a0b 20 08			jr nz, .bps8b 
1a0d				 
1a0d				; display cur orig ptr 
1a0d 2a 79 f9			ld hl, (cli_origptr) 
1a10 cd 57 1b			call display_dump_at_hl 
1a13 18 44			jr .bpschk 
1a15 fe 37		.bps8b:  cp '7' 
1a17 20 08			jr nz, .bps9 
1a19				 
1a19				; display dsp 
1a19 2a 29 f9			ld hl, (cli_data_sp) 
1a1c cd 57 1b			call display_dump_at_hl 
1a1f			 
1a1f 18 38			jr .bpschk 
1a21 fe 39		.bps9:  cp '9' 
1a23 20 05			jr nz, .bps8c 
1a25				 
1a25				; display SP 
1a25			;	ld hl, sp 
1a25 cd 57 1b			call display_dump_at_hl 
1a28			 
1a28 18 2f			jr .bpschk 
1a2a fe 38		.bps8c:  cp '8' 
1a2c 20 08			jr nz, .bps8d 
1a2e				 
1a2e				; display rsp 
1a2e 2a 2d f9			ld hl, (cli_ret_sp) 
1a31 cd 57 1b			call display_dump_at_hl 
1a34			 
1a34 18 23			jr .bpschk 
1a36 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1a38 20 05			jr nz, .bps8 
1a3a cd a2 1d			call monitor 
1a3d			 
1a3d 18 1a			jr .bpschk 
1a3f fe 30		.bps8:  cp '0' 
1a41 20 16			jr nz, .bpschk 
1a43			 
1a43 21 4b fc				ld hl, display_fb1 
1a46 22 07 fb				ld (display_fb_active), hl 
1a49 cd be 0d				call update_display 
1a4c			 
1a4c				;ld a, (os_view_af) 
1a4c 2a de f0			ld hl, (os_view_hl) 
1a4f ed 5b dc f0		ld de, (os_view_de) 
1a53 ed 4b da f0		ld bc, (os_view_bc) 
1a57 f1				pop af 
1a58 c9				ret 
1a59			 
1a59			.bpschk:   
1a59 cd de 0c			call delay1s 
1a5c 3e 9f		ld a,display_row_4 + display_cols - 1 
1a5e 11 d2 1f		        ld de, endprg 
1a61 cd ae 0d			call str_at_display 
1a64 cd be 0d			call update_display 
1a67 cd c5 79			call cin_wait 
1a6a			 
1a6a c3 bc 19			jp .bps1 
1a6d			 
1a6d			 
1a6d			display_reg_state: 
1a6d			 
1a6d				; to restore afterwards 
1a6d			 
1a6d d5				push de 
1a6e c5				push bc 
1a6f e5				push hl 
1a70 f5				push af 
1a71			 
1a71				; for use in here 
1a71			 
1a71 c5				push bc 
1a72 d5				push de 
1a73 e5				push hl 
1a74 f5				push af 
1a75			 
1a75 cd 9b 0d			call clear_display 
1a78			 
1a78 11 2d 1b			ld de, .regstate 
1a7b 3e 00			ld a, display_row_1 
1a7d cd ae 0d			call str_at_display 
1a80			 
1a80				; display debug step 
1a80			 
1a80			 
1a80 11 a6 fd			ld de, debug_mark 
1a83 3e 25			ld a, display_row_1+display_cols-3 
1a85 cd ae 0d			call str_at_display 
1a88			 
1a88				; display a 
1a88 11 49 1b			ld de, .regstatea 
1a8b 3e 28			ld a, display_row_2 
1a8d cd ae 0d			call str_at_display 
1a90			 
1a90 e1				pop hl 
1a91			;	ld h,0 
1a91			;	ld l, a 
1a91 3e 2b			ld a, display_row_2+3 
1a93 cd 13 19			call display_word_at 
1a96			 
1a96			 
1a96				; display hl 
1a96			 
1a96			 
1a96 11 3d 1b			ld de, .regstatehl 
1a99 3e 32			ld a, display_row_2+10 
1a9b cd ae 0d			call str_at_display 
1a9e			 
1a9e e1				pop hl 
1a9f 3e 35			ld a, display_row_2+13 
1aa1 cd 13 19			call display_word_at 
1aa4			 
1aa4				 
1aa4				; display de 
1aa4			 
1aa4 11 41 1b			ld de, .regstatede 
1aa7 3e 50			ld a, display_row_3 
1aa9 cd ae 0d			call str_at_display 
1aac			 
1aac e1				pop hl 
1aad			;	ld h,d 
1aad			;	ld l, e 
1aad 3e 53			ld a, display_row_3+3 
1aaf cd 13 19			call display_word_at 
1ab2			 
1ab2			 
1ab2				; display bc 
1ab2			 
1ab2 11 45 1b			ld de, .regstatebc 
1ab5 3e 5a			ld a, display_row_3+10 
1ab7 cd ae 0d			call str_at_display 
1aba			 
1aba e1				pop hl 
1abb			;	ld h,b 
1abb			;	ld l, c 
1abb 3e 5d			ld a, display_row_3+13 
1abd cd 13 19			call display_word_at 
1ac0			 
1ac0			 
1ac0				; display dsp 
1ac0			 
1ac0 11 4d 1b			ld de, .regstatedsp 
1ac3 3e 78			ld a, display_row_4 
1ac5 cd ae 0d			call str_at_display 
1ac8			 
1ac8				 
1ac8 2a 29 f9			ld hl,(cli_data_sp) 
1acb 3e 7c			ld a, display_row_4+4 
1acd cd 13 19			call display_word_at 
1ad0			 
1ad0				; display rsp 
1ad0			 
1ad0 11 52 1b			ld de, .regstatersp 
1ad3 3e 82			ld a, display_row_4+10 
1ad5 cd ae 0d			call str_at_display 
1ad8			 
1ad8				 
1ad8 2a 2d f9			ld hl,(cli_ret_sp) 
1adb 3e 86			ld a, display_row_4+14 
1add cd 13 19			call display_word_at 
1ae0			 
1ae0 cd be 0d			call update_display 
1ae3			 
1ae3			;	call delay1s 
1ae3			;	call delay1s 
1ae3			;	call delay1s 
1ae3			 
1ae3			 
1ae3			;	call next_page_prompt 
1ae3			 
1ae3				; restore  
1ae3			 
1ae3 f1				pop af 
1ae4 e1				pop hl 
1ae5 c1				pop bc 
1ae6 d1				pop de 
1ae7 c9				ret 
1ae8			 
1ae8 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1afc .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1b11 .. 00		.ptrstate:	db "Ptr State",0 
1b1b .. 00		.ptrcliptr:     db "cli_ptr",0 
1b23 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1b2d .. 00		.regstate:	db "Reg State (1/0)",0 
1b3d .. 00		.regstatehl:	db "HL:",0 
1b41 .. 00		.regstatede:	db "DE:",0 
1b45 .. 00		.regstatebc:	db "BC:",0 
1b49 .. 00		.regstatea:	db "A :",0 
1b4d .. 00		.regstatedsp:	db "DSP:",0 
1b52 .. 00		.regstatersp:	db "RSP:",0 
1b57			 
1b57			display_dump_at_hl: 
1b57 e5				push hl 
1b58 d5				push de 
1b59 c5				push bc 
1b5a f5				push af 
1b5b			 
1b5b 22 1f f4			ld (os_cur_ptr),hl	 
1b5e cd 9b 0d			call clear_display 
1b61 cd dc 1e			call dumpcont 
1b64			;	call delay1s 
1b64			;	call next_page_prompt 
1b64			 
1b64			 
1b64 f1				pop af 
1b65 c1				pop bc 
1b66 d1				pop de 
1b67 e1				pop hl 
1b68 c9				ret 
1b69			 
1b69			;if ENABLE_BASIC 
1b69			;	include "nascombasic.asm" 
1b69			;	basic: 
1b69			;	include "forth/FORTH.ASM" 
1b69			;endif 
1b69			 
1b69			; eof 
1b69			 
1b69			 
# End of file firmware_diags.asm
1b69			  
1b69			include "firmware_prompts.asm"  
1b69			; Prompts  
1b69			 
1b69			; boot messages 
1b69			 
1b69 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1b7e .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1b8e			 
1b8e			 
1b8e			; config menus 
1b8e			 
1b8e			;prom_c3: db "Add Dictionary To File",0 
1b8e			 
1b8e			if STARTUP_V1 
1b8e			prom_c2: db "Select Autoload File",0 
1b8e			prom_c2a: db "Disable Autoload File", 0 
1b8e			endif 
1b8e			 
1b8e			if STARTUP_V2 
1b8e .. 00		prom_c2: db "Enable Autoload Files",0 
1ba4 .. 00		prom_c2a: db "Disable Autoload Files", 0 
1bbb			 
1bbb .. 00		crs_s1: db "*ls-word", 0 
1bc4 .. 00		crs_s2: db "*ed-word", 0 
1bcd .. 00		crs_s3: db "*Demo-Programs", 0 
1bdc .. 00		crs_s4: db "*Utils", 0 
1be3 .. 00		crs_s5: db "*SPI-Util", 0 
1bed .. 00		crs_s6: db "*Key-constants", 0 
1bfc .. 00		crs_sound: db "*Sound-Util", 0 
1c08			 
1c08			 
1c08			 
1c08			endif 
1c08			;prom_c2b: db "Select Storage Bank",0 
1c08 .. 00		prom_c4: db "Settings",0 
1c11 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1c2c .. 00		prom_m4b:   db "Monitor",0 
1c34 .. 00		prom_c1: db "Hardware Diags",0 
1c43			 
1c43			 
1c43			if STARTUP_V2 
1c43 .. 00		prom_c9: db "Create Startup Files",0 
1c58			endif 
1c58			 
1c58 .. 00		prom_notav:    db "Feature not available",0 
1c6e .. 00		prom_empty:    db "",0 
1c6f			 
1c6f			; eof 
1c6f			 
# End of file firmware_prompts.asm
1c6f			  
1c6f			  
1c6f			; eof  
1c6f			  
# End of file firmware.asm
1c6f			 
1c6f			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1c6f			;if BASE_KEV  
1c6f			;baseram: equ 08000h 
1c6f			;endif 
1c6f			 
1c6f			;if BASE_SC114 
1c6f			;baseram:     equ    endofcode 
1c6f			;endif 
1c6f			 
1c6f			 
1c6f			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1c6f			 
1c6f			; start system 
1c6f			 
1c6f			coldstart: 
1c6f				; set sp 
1c6f				; di/ei 
1c6f			 
1c6f f3				di 
1c70 31 fd ff			ld sp, tos 
1c73 cd 4c 76			call init_nmi 
1c76			;	ei 
1c76			 
1c76				; init spinner 
1c76 3e 00			ld a,0 
1c78 32 01 fb			ld (display_active), a 
1c7b			 
1c7b				; disable breakpoint by default 
1c7b			 
1c7b				;ld a,'*' 
1c7b			;	ld a,' ' 
1c7b			;	ld (os_view_disable),a 
1c7b			 
1c7b				; set break point vector as new break point on or off 
1c7b cd 9a 19			call bp_off 
1c7e			 
1c7e				; init hardware 
1c7e			 
1c7e				; init keyboard and screen hardware 
1c7e			 
1c7e cd 68 00			call hardware_init 
1c81			 
1c81			 
1c81 cd de 0c			call delay1s 
1c84 3e 58			ld a, display_row_3+8 
1c86 11 03 00			ld de, buildtime 
1c89 cd ae 0d			call str_at_display 
1c8c cd be 0d			call update_display 
1c8f			 
1c8f cd de 0c			call delay1s 
1c92 cd de 0c			call delay1s 
1c95 cd de 0c			call delay1s 
1c98			 
1c98				; detect if any keys are held down to enable breakpoints at start up 
1c98			 
1c98 cd d6 79			call cin  
1c9b fe 00			cp 0 
1c9d 28 03			jr z, .nokeys 
1c9f			 
1c9f				;call hardware_diags 
1c9f cd 94 15			call config 
1ca2			 
1ca2			;	ld de, .bpen 
1ca2			;	ld a, display_row_4 
1ca2			;	call str_at_display 
1ca2			;	call update_display 
1ca2			; 
1ca2			;	ld a,0 
1ca2			;	ld (os_view_disable),a 
1ca2			; 
1ca2			;.bpwait: 
1ca2			;	call cin 
1ca2			;	cp 0 
1ca2			;	jr z, .bpwait 
1ca2			;	jr .nokeys 
1ca2			; 
1ca2			; 
1ca2			;.bpen:  db "Break points enabled!",0 
1ca2			 
1ca2			 
1ca2			 
1ca2			 
1ca2			 
1ca2			 
1ca2			.nokeys: 
1ca2			 
1ca2			 
1ca2				 
1ca2			 
1ca2			;jp  testkey 
1ca2			 
1ca2			;call storage_get_block_0 
1ca2			; 
1ca2			;ld hl, 0 
1ca2			;ld de, store_page 
1ca2			;call storage_read_block 
1ca2			 
1ca2				 
1ca2			;ld hl, 10 
1ca2			;ld de, store_page 
1ca2			;call storage_read_block 
1ca2			 
1ca2			 
1ca2			 
1ca2			 
1ca2			 
1ca2			;stop:	nop 
1ca2			;	jp stop 
1ca2			 
1ca2			 
1ca2			 
1ca2			main: 
1ca2 cd 9b 0d			call clear_display 
1ca5 cd be 0d			call update_display 
1ca8			 
1ca8			 
1ca8			 
1ca8			;	call testlcd 
1ca8			 
1ca8			 
1ca8			 
1ca8 cd d9 23			call forth_init 
1cab			 
1cab			 
1cab			warmstart: 
1cab cd af 23			call forth_warmstart 
1cae			 
1cae				; run startup word load 
1cae			        ; TODO prevent this running at warmstart after crash  
1cae			 
1cae				if STARTUP_ENABLE 
1cae			 
1cae					if STARTUP_V1 
1cae			 
1cae						if STORAGE_SE 
1cae							call forth_autoload 
1cae						endif 
1cae						call forth_startup 
1cae					endif 
1cae			 
1cae					if STARTUP_V2 
1cae			 
1cae						if STORAGE_SE 
1cae cd 7a 74						call forth_autoload 
1cb1						else 
1cb1							call forth_startup 
1cb1						endif 
1cb1			 
1cb1			 
1cb1					endif 
1cb1			 
1cb1				endif 
1cb1			 
1cb1				; show free memory after boot 
1cb1 11 3d 1d			ld de, freeram 
1cb4 3e 00			ld a, display_row_1 
1cb6 cd ae 0d			call str_at_display 
1cb9			 
1cb9				; get current heap start after loading any uwords 
1cb9			 
1cb9				;ld de, (os_last_new_uword) 
1cb9				;ex de, hl 
1cb9			 
1cb9			; Or use heap_size word???? 
1cb9				;ld hl, heap_end 
1cb9				;ld hl, heap_size 
1cb9				;ld de, topusermem 
1cb9				;ld de, heap_start 
1cb9 ed 5b 0a 80			ld de, (free_list )      
1cbd 21 d7 f0				ld hl, heap_end 
1cc0 ed 52			sbc hl, de 
1cc2				;push hl 
1cc2				;ld a,h	         	 
1cc2				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1cc2				;call hexout 
1cc2			   	;pop hl 
1cc2			; 
1cc2			;	ld a,l 
1cc2			;	ld hl, os_word_scratch+2 
1cc2			;	call hexout 
1cc2			;	ld hl, os_word_scratch+4 
1cc2			;	ld a, 0 
1cc2			;	ld (hl),a 
1cc2 eb				ex de, hl 
1cc3 21 01 f4			ld hl, os_word_scratch 
1cc6 cd 35 13			call uitoa_16 
1cc9			 
1cc9			 
1cc9 11 01 f4			ld de, os_word_scratch 
1ccc 3e 0d			ld a, display_row_1 + 13 
1cce cd ae 0d			call str_at_display 
1cd1 cd be 0d			call update_display 
1cd4			 
1cd4			 
1cd4				;call demo 
1cd4			 
1cd4			 
1cd4				; init scratch input area for cli commands 
1cd4			 
1cd4 21 23 f4			ld hl, os_cli_cmd 
1cd7 3e 00			ld a,0 
1cd9 77				ld (hl),a 
1cda 23				inc hl 
1cdb 77				ld (hl),a 
1cdc			 
1cdc 3e 00			ld a,0 
1cde 32 22 f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1ce1			 
1ce1 32 1f f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1ce4 32 20 f4			ld (os_cur_ptr+1),a	 
1ce7			 
1ce7 32 01 f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1cea 32 02 f4			ld (os_word_scratch+1),a	 
1ced				 
1ced			 
1ced				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ced 21 23 f4			ld hl, os_cli_cmd 
1cf0			 
1cf0 3e 00			ld a, 0		 ; init cli input 
1cf2 77				ld (hl), a 
1cf3 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cf5			cli: 
1cf5				; show cli prompt 
1cf5				;push af 
1cf5				;ld a, 0 
1cf5				;ld de, prompt 
1cf5				;call str_at_display 
1cf5			 
1cf5				;call update_display 
1cf5				;pop af 
1cf5				;inc a 
1cf5				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1cf5 0e 00			ld c, 0 
1cf7 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1cf9 1e 28			ld e, 40 
1cfb			 
1cfb 21 23 f4			ld hl, os_cli_cmd 
1cfe			 
1cfe				STACKFRAME OFF $fefe $9f9f 
1cfe				if DEBUG_STACK_IMB 
1cfe					if OFF 
1cfe						exx 
1cfe						ld de, $fefe 
1cfe						ld a, d 
1cfe						ld hl, curframe 
1cfe						call hexout 
1cfe						ld a, e 
1cfe						ld hl, curframe+2 
1cfe						call hexout 
1cfe						ld hl, $fefe 
1cfe						push hl 
1cfe						ld hl, $9f9f 
1cfe						push hl 
1cfe						exx 
1cfe					endif 
1cfe				endif 
1cfe			endm 
# End of macro STACKFRAME
1cfe			 
1cfe cd fc 0f			call input_str 
1d01			 
1d01				STACKFRAMECHK OFF $fefe $9f9f 
1d01				if DEBUG_STACK_IMB 
1d01					if OFF 
1d01						exx 
1d01						ld hl, $9f9f 
1d01						pop de   ; $9f9f 
1d01						call cmp16 
1d01						jr nz, .spnosame 
1d01						ld hl, $fefe 
1d01						pop de   ; $fefe 
1d01						call cmp16 
1d01						jr z, .spfrsame 
1d01						.spnosame: call showsperror 
1d01						.spfrsame: nop 
1d01						exx 
1d01					endif 
1d01				endif 
1d01			endm 
# End of macro STACKFRAMECHK
1d01			 
1d01				; copy input to last command 
1d01			 
1d01 21 23 f4			ld hl, os_cli_cmd 
1d04 11 22 f5			ld de, os_last_cmd 
1d07 01 ff 00			ld bc, 255 
1d0a ed b0			ldir 
1d0c			 
1d0c				; wipe current buffer 
1d0c			 
1d0c			;	ld a, 0 
1d0c			;	ld hl, os_cli_cmd 
1d0c			;	ld de, os_cli_cmd+1 
1d0c			;	ld bc, 254 
1d0c			;	ldir 
1d0c				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1d0c			;	call strcpy 
1d0c			;	ld a, 0 
1d0c			;	ld (hl), a 
1d0c			;	inc hl 
1d0c			;	ld (hl), a 
1d0c			;	inc hl 
1d0c			;	ld (hl), a 
1d0c			 
1d0c				; switch frame buffer to program  
1d0c			 
1d0c 21 4b fc				ld hl, display_fb1 
1d0f 22 07 fb				ld (display_fb_active), hl 
1d12			 
1d12			;	nop 
1d12				STACKFRAME ON $fbfe $8f9f 
1d12				if DEBUG_STACK_IMB 
1d12					if ON 
1d12						exx 
1d12						ld de, $fbfe 
1d12						ld a, d 
1d12						ld hl, curframe 
1d12						call hexout 
1d12						ld a, e 
1d12						ld hl, curframe+2 
1d12						call hexout 
1d12						ld hl, $fbfe 
1d12						push hl 
1d12						ld hl, $8f9f 
1d12						push hl 
1d12						exx 
1d12					endif 
1d12				endif 
1d12			endm 
# End of macro STACKFRAME
1d12				; first time into the parser so pass over the current scratch pad 
1d12 21 23 f4			ld hl,os_cli_cmd 
1d15				; tokenise the entered statement(s) in HL 
1d15 cd 57 24			call forthparse 
1d18			        ; exec forth statements in top of return stack 
1d18 cd 97 24			call forthexec 
1d1b				;call forthexec_cleanup 
1d1b			;	call parsenext 
1d1b			 
1d1b				STACKFRAMECHK ON $fbfe $8f9f 
1d1b				if DEBUG_STACK_IMB 
1d1b					if ON 
1d1b						exx 
1d1b						ld hl, $8f9f 
1d1b						pop de   ; $8f9f 
1d1b						call cmp16 
1d1b						jr nz, .spnosame 
1d1b						ld hl, $fbfe 
1d1b						pop de   ; $fbfe 
1d1b						call cmp16 
1d1b						jr z, .spfrsame 
1d1b						.spnosame: call showsperror 
1d1b						.spfrsame: nop 
1d1b						exx 
1d1b					endif 
1d1b				endif 
1d1b			endm 
# End of macro STACKFRAMECHK
1d1b				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1d1b			 
1d1b 3e 78			ld a, display_row_4 
1d1d 11 4e 1d			ld de, endprog 
1d20			 
1d20 cd be 0d			call update_display		 
1d23			 
1d23 cd d4 1f			call next_page_prompt 
1d26			 
1d26				; switch frame buffer to cli 
1d26			 
1d26 21 ec fc				ld hl, display_fb0 
1d29 22 07 fb				ld (display_fb_active), hl 
1d2c			 
1d2c			 
1d2c cd 9b 0d		        call clear_display 
1d2f cd be 0d			call update_display		 
1d32			 
1d32 21 23 f4			ld hl, os_cli_cmd 
1d35			 
1d35 3e 00			ld a, 0		 ; init cli input 
1d37 77				ld (hl), a 
1d38			 
1d38				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1d38			 
1d38				; now on last line 
1d38			 
1d38				; TODO scroll screen up 
1d38			 
1d38				; TODO instead just clear screen and place at top of screen 
1d38			 
1d38			;	ld a, 0 
1d38			;	ld (f_cursor_ptr),a 
1d38			 
1d38				;call clear_display 
1d38				;call update_display 
1d38			 
1d38				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d38 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d3a c3 f5 1c			jp cli 
1d3d			 
1d3d .. 00		freeram: db "Free bytes: ",0 
1d4a ..			asc: db "1A2F" 
1d4e .. 00		endprog: db "End prog...",0 
1d5a			 
1d5a			testenter2:   
1d5a 21 2e f1			ld hl,scratch+50 
1d5d 22 1f f4			ld (os_cur_ptr),hl 
1d60 c3 f5 1c			jp cli 
1d63			 
1d63			testenter:  
1d63			 
1d63 21 4a 1d			ld hl,asc 
1d66			;	ld a,(hl) 
1d66			;	call nibble2val 
1d66 cd 7f 12			call get_byte 
1d69			 
1d69			 
1d69			;	ld a,(hl) 
1d69			;	call atohex 
1d69			 
1d69			;	call fourehexhl 
1d69 32 2e f1			ld (scratch+50),a 
1d6c			 
1d6c			 
1d6c			 
1d6c 21 4c 1d			ld hl,asc+2 
1d6f			;	ld a, (hl) 
1d6f			;	call nibble2val 
1d6f cd 7f 12			call get_byte 
1d72			 
1d72			;	call fourehexhl 
1d72 32 30 f1			ld (scratch+52),a 
1d75				 
1d75 21 2e f1			ld hl,scratch+50 
1d78 22 1f f4			ld (os_cur_ptr),hl 
1d7b c3 f5 1c			jp cli 
1d7e			 
1d7e			enter:	 
1d7e 3a 00 f1			ld a,(scratch+4) 
1d81 fe 00			cp 0 
1d83 28 0c			jr z, .entercont 
1d85				; no, not a null term line so has an address to work out.... 
1d85			 
1d85 21 fe f0			ld hl,scratch+2 
1d88 cd df 12			call get_word_hl 
1d8b			 
1d8b 22 1f f4			ld (os_cur_ptr),hl	 
1d8e c3 f5 1c			jp cli 
1d91			 
1d91			 
1d91			.entercont:  
1d91			 
1d91 21 fe f0			ld hl, scratch+2 
1d94 cd 7f 12			call get_byte 
1d97			 
1d97 2a 1f f4		   	ld hl,(os_cur_ptr) 
1d9a 77					ld (hl),a 
1d9b 23					inc hl 
1d9c 22 1f f4				ld (os_cur_ptr),hl 
1d9f				 
1d9f			; get byte  
1d9f			 
1d9f			 
1d9f c3 f5 1c			jp cli 
1da2			 
1da2			 
1da2			; basic monitor support 
1da2			 
1da2			monitor: 
1da2				;  
1da2 cd 9b 0d			call clear_display 
1da5 3e 00			ld a, 0 
1da7 11 f6 1d			ld de, .monprompt 
1daa cd ae 0d			call str_at_display 
1dad cd be 0d			call update_display 
1db0			 
1db0				; get a monitor command 
1db0			 
1db0 0e 00			ld c, 0     ; entry at top left 
1db2 16 64			ld d, 100   ; max buffer size 
1db4 1e 0f			ld e, 15    ; input scroll area 
1db6 3e 00			ld a, 0     ; init string 
1db8 21 fa f2			ld hl, os_input 
1dbb 77				ld (hl), a 
1dbc 23				inc hl 
1dbd 77				ld (hl), a 
1dbe 21 fa f2			ld hl, os_input 
1dc1 3e 01			ld a, 1     ; init string 
1dc3 cd fc 0f			call input_str 
1dc6			 
1dc6 cd 9b 0d		        call clear_display 
1dc9 cd be 0d			call update_display		 
1dcc			 
1dcc 3a fa f2			ld a, (os_input) 
1dcf cd 7d 13			call toUpper 
1dd2 fe 48		        cp 'H' 
1dd4 ca 5b 1e		        jp z, .monhelp 
1dd7 fe 44			cp 'D'		; dump 
1dd9 ca 8e 1e			jp z, .mondump	 
1ddc fe 43			cp 'C'		; dump 
1dde ca a8 1e			jp z, .moncdump	 
1de1 fe 4d			cp 'M'		; dump 
1de3 ca f8 1d			jp z, .moneditstart 
1de6 fe 55			cp 'U'		; dump 
1de8 ca 04 1e			jp z, .monedit	 
1deb fe 47			cp 'G'		; dump 
1ded ca 84 1e			jp z, .monjump 
1df0 fe 51			cp 'Q'		; dump 
1df2 c8				ret z	 
1df3			 
1df3			 
1df3				; TODO "S" to access symbol by name and not need the address 
1df3				; TODO "F" to find a string in memory 
1df3			 
1df3 c3 a2 1d			jp monitor 
1df6			 
1df6 .. 00		.monprompt: db ">", 0 
1df8			 
1df8			.moneditstart: 
1df8				; get starting address 
1df8			 
1df8 21 fc f2			ld hl,os_input+2 
1dfb cd df 12			call get_word_hl 
1dfe			 
1dfe 22 1f f4			ld (os_cur_ptr),hl	 
1e01			 
1e01 c3 a2 1d			jp monitor 
1e04			 
1e04			.monedit: 
1e04				; get byte to load 
1e04			 
1e04 21 fc f2			ld hl,os_input+2 
1e07 cd 7f 12			call get_byte 
1e0a			 
1e0a				; get address to update 
1e0a 2a 1f f4			ld hl, (os_cur_ptr) 
1e0d			 
1e0d				; update byte 
1e0d			 
1e0d 77				ld (hl), a 
1e0e			 
1e0e				; move to next address and save it 
1e0e			 
1e0e 23				inc hl 
1e0f 22 1f f4			ld (os_cur_ptr),hl	 
1e12			 
1e12 c3 a2 1d			jp monitor 
1e15			 
1e15			 
1e15 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1e29 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1e45 .. 00		.monhelptext3:  db "G-Call address",0 
1e54 .. 00		.monhelptext4:  db "Q-Quit",0 
1e5b			        
1e5b			.monhelp: 
1e5b 3e 00			ld a, display_row_1 
1e5d 11 15 1e		        ld de, .monhelptext1 
1e60			 
1e60 cd ae 0d			call str_at_display 
1e63 3e 28			ld a, display_row_2 
1e65 11 29 1e		        ld de, .monhelptext2 
1e68					 
1e68 cd ae 0d			call str_at_display 
1e6b 3e 50			ld a, display_row_3 
1e6d 11 45 1e		        ld de, .monhelptext3 
1e70					 
1e70 cd ae 0d			call str_at_display 
1e73 3e 78			ld a, display_row_4 
1e75 11 54 1e		        ld de, .monhelptext4 
1e78 cd ae 0d			call str_at_display 
1e7b			 
1e7b cd be 0d			call update_display		 
1e7e			 
1e7e cd d4 1f			call next_page_prompt 
1e81 c3 a2 1d			jp monitor 
1e84			 
1e84			.monjump:    
1e84 21 fc f2			ld hl,os_input+2 
1e87 cd df 12			call get_word_hl 
1e8a			 
1e8a e9				jp (hl) 
1e8b c3 a2 1d			jp monitor 
1e8e			 
1e8e			.mondump:    
1e8e 21 fc f2			ld hl,os_input+2 
1e91 cd df 12			call get_word_hl 
1e94			 
1e94 22 1f f4			ld (os_cur_ptr),hl	 
1e97 cd dc 1e			call dumpcont 
1e9a 3e 78			ld a, display_row_4 
1e9c 11 4e 1d			ld de, endprog 
1e9f			 
1e9f cd be 0d			call update_display		 
1ea2			 
1ea2 cd d4 1f			call next_page_prompt 
1ea5 c3 a2 1d			jp monitor 
1ea8			.moncdump: 
1ea8 cd dc 1e			call dumpcont 
1eab 3e 78			ld a, display_row_4 
1ead 11 4e 1d			ld de, endprog 
1eb0			 
1eb0 cd be 0d			call update_display		 
1eb3			 
1eb3 cd d4 1f			call next_page_prompt 
1eb6 c3 a2 1d			jp monitor 
1eb9			 
1eb9			 
1eb9			; TODO symbol access  
1eb9			 
1eb9			.symbols:     ;; A list of symbols that can be called up  
1eb9 ec fc			dw display_fb0 
1ebb .. 00			db "fb0",0  
1ebf b5 f9		     	dw store_page 
1ec1 .. 00			db "store_page",0 
1ecc			 
1ecc			 
1ecc			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1ecc			 
1ecc 3a fd f0			ld a,(scratch+1) 
1ecf fe 00			cp 0 
1ed1 28 09			jr z, dumpcont 
1ed3			 
1ed3				; no, not a null term line so has an address to work out.... 
1ed3			 
1ed3 21 fe f0			ld hl,scratch+2 
1ed6 cd df 12			call get_word_hl 
1ed9			 
1ed9 22 1f f4			ld (os_cur_ptr),hl	 
1edc			 
1edc			 
1edc			 
1edc			dumpcont: 
1edc			 
1edc				; dump bytes at ptr 
1edc			 
1edc			 
1edc 3e 00			ld a, display_row_1 
1ede 2a 07 fb			ld hl, (display_fb_active) 
1ee1 cd cf 0f			call addatohl 
1ee4 cd 0c 1f			call .dumpbyterow 
1ee7			 
1ee7 3e 28			ld a, display_row_2 
1ee9 2a 07 fb			ld hl, (display_fb_active) 
1eec cd cf 0f			call addatohl 
1eef cd 0c 1f			call .dumpbyterow 
1ef2			 
1ef2			 
1ef2 3e 50			ld a, display_row_3 
1ef4 2a 07 fb			ld hl, (display_fb_active) 
1ef7 cd cf 0f			call addatohl 
1efa cd 0c 1f			call .dumpbyterow 
1efd			 
1efd 3e 78			ld a, display_row_4 
1eff 2a 07 fb			ld hl, (display_fb_active) 
1f02 cd cf 0f			call addatohl 
1f05 cd 0c 1f			call .dumpbyterow 
1f08			 
1f08 cd be 0d			call update_display 
1f0b			;		jp cli 
1f0b c9				ret 
1f0c			 
1f0c			.dumpbyterow: 
1f0c			 
1f0c				;push af 
1f0c			 
1f0c e5				push hl 
1f0d			 
1f0d				; calc where to poke the ascii 
1f0d			if display_cols == 20 
1f0d				ld a, 16 
1f0d			else 
1f0d 3e 1f			ld a, 31 
1f0f			endif 
1f0f			 
1f0f cd cf 0f			call addatohl 
1f12 22 01 f4			ld (os_word_scratch),hl  		; save pos for later 
1f15			 
1f15			 
1f15			; display decoding address 
1f15 2a 1f f4		   	ld hl,(os_cur_ptr) 
1f18			 
1f18 7c				ld a,h 
1f19 e1				pop hl 
1f1a e5				push hl 
1f1b			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1f1b cd 29 12			call hexout 
1f1e 2a 1f f4		   	ld hl,(os_cur_ptr) 
1f21			 
1f21 7d				ld a,l 
1f22 e1				pop hl 
1f23 23				inc hl 
1f24 23				inc hl 
1f25 e5				push hl 
1f26			;	ld hl, os_word_scratch+2 
1f26 cd 29 12			call hexout 
1f29 e1				pop hl 
1f2a 23				inc hl 
1f2b 23				inc hl 
1f2c				;ld hl, os_word_scratch+4 
1f2c 3e 3a			ld a, ':' 
1f2e 77				ld (hl),a 
1f2f 23				inc hl 
1f30				;ld a, 0 
1f30				;ld (hl),a 
1f30				;ld de, os_word_scratch 
1f30				;pop af 
1f30				;push af 
1f30			;		ld a, display_row_2 
1f30			;		call str_at_display 
1f30			;		call update_display 
1f30			 
1f30			 
1f30			;pop af 
1f30			;	add 5 
1f30			 
1f30			if display_cols == 20 
1f30				ld b, 4 
1f30			else 
1f30 06 08			ld b, 8 
1f32			endif	 
1f32			 
1f32			.dumpbyte: 
1f32 c5				push bc 
1f33 e5				push hl 
1f34			 
1f34			 
1f34 2a 1f f4		   	ld hl,(os_cur_ptr) 
1f37 7e					ld a,(hl) 
1f38			 
1f38					; poke the ascii to display 
1f38 2a 01 f4				ld hl,(os_word_scratch) 
1f3b 77					ld (hl),a 
1f3c 23					inc hl 
1f3d 22 01 f4				ld (os_word_scratch),hl 
1f40			 
1f40					 
1f40			 
1f40			 
1f40 e1					pop hl 
1f41 e5					push hl 
1f42			 
1f42 cd 29 12				call hexout 
1f45			 
1f45					 
1f45 2a 1f f4		   	ld hl,(os_cur_ptr) 
1f48 23				inc hl 
1f49 22 1f f4		   	ld (os_cur_ptr),hl 
1f4c			 
1f4c e1					pop hl 
1f4d 23					inc hl 
1f4e 23					inc hl 
1f4f 23					inc hl 
1f50			 
1f50			 
1f50			 
1f50					;ld a,0 
1f50					;ld (os_word_scratch+2),a 
1f50					;pop af 
1f50					;push af 
1f50			 
1f50					;ld de, os_word_scratch 
1f50					;call str_at_display 
1f50			;		call update_display 
1f50			;		pop af 
1f50 c1					pop bc 
1f51 c6 03				add 3 
1f53 10 dd			djnz .dumpbyte 
1f55			 
1f55				 
1f55			 
1f55 c9				ret 
1f56			 
1f56			jump:	 
1f56			 
1f56 21 fe f0			ld hl,scratch+2 
1f59 cd df 12			call get_word_hl 
1f5c				;ld hl,(scratch+2) 
1f5c				;call fourehexhl 
1f5c			 
1f5c 22 1f f4			ld (os_cur_ptr),hl	 
1f5f			 
1f5f e9				jp (hl) 
1f60			 
1f60			 
1f60			 
1f60			; TODO implement a basic monitor mode to start with 
1f60			 
1f60			 
1f60			 
1f60			 
1f60			 
1f60			 
1f60			 
1f60			 
1f60			 
1f60			; testing and demo code during development 
1f60			 
1f60			 
1f60 .. 00		str1: db "Enter some text...",0 
1f73 .. 00		clear: db "                    ",0 
1f88			 
1f88			demo: 
1f88			 
1f88			 
1f88			 
1f88			;	call update_display 
1f88			 
1f88				; init scratch input area for testing 
1f88 21 fc f0			ld hl, scratch	 
1f8b 3e 00			ld a,0 
1f8d 77				ld (hl),a 
1f8e			 
1f8e			 
1f8e 3e 28		            LD   A, display_row_2 
1f90			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f90 11 60 1f		            LD   DE, str1 
1f93 cd ae 0d			call str_at_display 
1f96			 
1f96			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f96			cloop:	 
1f96 3e 50		            LD   A, display_row_3 
1f98			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f98 11 73 1f		            LD   DE, clear 
1f9b			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1f9b cd ae 0d				call str_at_display 
1f9e 3e 78			ld a, display_row_4 
1fa0 11 d0 1f			ld de, prompt 
1fa3			 
1fa3 cd ae 0d				call str_at_display 
1fa6 cd be 0d			call update_display 
1fa9			 
1fa9 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1fab 16 0a			ld d, 10 
1fad 21 fc f0			ld hl, scratch	 
1fb0 cd fc 0f			call input_str 
1fb3			 
1fb3			;	call clear_display 
1fb3			;'	call update_display 
1fb3			 
1fb3 3e 00		            LD   A, display_row_1 
1fb5			;            CALL fLCD_Pos       ;Position cursor to location in A 
1fb5 11 73 1f		            LD   DE, clear 
1fb8 cd ae 0d				call str_at_display 
1fbb			;            CALL fLCD_Str       ;Display string pointed to by DE 
1fbb 3e 00		            LD   A, display_row_1 
1fbd			;            CALL fLCD_Pos       ;Position cursor to location in A 
1fbd 11 fc f0		            LD   DE, scratch 
1fc0			;            CALL fLCD_Str       ;Display string pointed to by DE 
1fc0 cd ae 0d				call str_at_display 
1fc3 cd be 0d			call update_display 
1fc6			 
1fc6 3e 00				ld a,0 
1fc8 21 fc f0			ld hl, scratch 
1fcb 77				ld (hl),a 
1fcc			 
1fcc 00				nop 
1fcd c3 96 1f			jp cloop 
1fd0			 
1fd0			 
1fd0			 
1fd0			; OS Prompt 
1fd0			 
1fd0 .. 00		prompt: db ">",0 
1fd2 .. 00		endprg: db "?",0 
1fd4			 
1fd4			 
1fd4			; handy next page prompt 
1fd4			next_page_prompt: 
1fd4 e5				push hl 
1fd5 d5				push de 
1fd6 f5				push af 
1fd7 c5				push bc 
1fd8			 
1fd8 3e 9f			ld a,display_row_4 + display_cols - 1 
1fda 11 d2 1f		        ld de, endprg 
1fdd cd ae 0d			call str_at_display 
1fe0 cd be 0d			call update_display 
1fe3 cd c5 79			call cin_wait 
1fe6 c1				pop bc 
1fe7 f1				pop af 
1fe8 d1				pop de 
1fe9 e1				pop hl 
1fea			 
1fea			 
1fea c9				ret 
1feb			 
1feb			 
1feb			; forth parser 
1feb			 
1feb			; My forth kernel 
1feb			include "forth_kernel.asm" 
1feb			; 
1feb			; kernel to the forth OS 
1feb			 
1feb			DS_TYPE_STR: equ 1     ; string type 
1feb			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1feb			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1feb			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1feb			 
1feb			FORTH_PARSEV1: equ 0 
1feb			FORTH_PARSEV2: equ 0 
1feb			FORTH_PARSEV3: equ 0 
1feb			FORTH_PARSEV4: equ 0 
1feb			FORTH_PARSEV5: equ 1 
1feb			 
1feb			;if FORTH_PARSEV5 
1feb			;	FORTH_END_BUFFER: equ 0 
1feb			;else 
1feb			FORTH_END_BUFFER: equ 127 
1feb			;endif 
1feb			 
1feb			FORTH_TRUE: equ 1 
1feb			FORTH_FALSE: equ 0 
1feb			 
1feb			if FORTH_PARSEV4 
1feb			include "forth_stackops.asm" 
1feb			endif 
1feb			 
1feb			if FORTH_PARSEV5 
1feb			include "forth_stackopsv5.asm" 
1feb			 
1feb			; Stack operations for v5 parser on wards 
1feb			; * DATA stack 
1feb			; * LOOP stack 
1feb			; * RETURN stack 
1feb			 
1feb			 
1feb			 
1feb			FORTH_CHK_DSP_UNDER: macro 
1feb				push hl 
1feb				push de 
1feb				ld hl,(cli_data_sp) 
1feb				ld de, cli_data_stack 
1feb				call cmp16 
1feb				jp c, fault_dsp_under 
1feb				pop de 
1feb				pop hl 
1feb				endm 
1feb			 
1feb			 
1feb			FORTH_CHK_RSP_UNDER: macro 
1feb				push hl 
1feb				push de 
1feb				ld hl,(cli_ret_sp) 
1feb				ld de, cli_ret_stack 
1feb				call cmp16 
1feb				jp c, fault_rsp_under 
1feb				pop de 
1feb				pop hl 
1feb				endm 
1feb			 
1feb			FORTH_CHK_LOOP_UNDER: macro 
1feb				push hl 
1feb				push de 
1feb				ld hl,(cli_loop_sp) 
1feb				ld de, cli_loop_stack 
1feb				call cmp16 
1feb				jp c, fault_loop_under 
1feb				pop de 
1feb				pop hl 
1feb				endm 
1feb			 
1feb			FORTH_ERR_TOS_NOTSTR: macro 
1feb				; TOSO might need more for checks when used 
1feb				push af 
1feb				ld a,(hl) 
1feb				cp DS_TYPE_STR 
1feb				jp nz, type_faultn   
1feb				pop af 
1feb				endm 
1feb			 
1feb			FORTH_ERR_TOS_NOTNUM: macro 
1feb				push af 
1feb				ld a,(hl) 
1feb				cp DS_TYPE_INUM 
1feb				jp nz, type_faultn   
1feb				pop af 
1feb				endm 
1feb			 
1feb			 
1feb			; increase data stack pointer and save hl to it 
1feb				 
1feb			FORTH_DSP_NEXT: macro 
1feb				call macro_forth_dsp_next 
1feb				endm 
1feb			 
1feb			 
1feb			macro_forth_dsp_next: 
1feb				if DEBUG_FORTH_STACK_GUARD 
1feb cd 72 72				call check_stacks 
1fee				endif 
1fee e5				push hl 
1fef d5				push de 
1ff0 eb				ex de,hl 
1ff1 2a 29 f9			ld hl,(cli_data_sp) 
1ff4 23				inc hl 
1ff5 23				inc hl 
1ff6			 
1ff6			; PARSEV5 
1ff6 23				inc hl 
1ff7 22 29 f9			ld (cli_data_sp),hl 
1ffa 73				ld (hl), e 
1ffb 23				inc hl 
1ffc 72				ld (hl), d 
1ffd d1				pop de 
1ffe e1				pop hl 
1fff				if DEBUG_FORTH_STACK_GUARD 
1fff cd 72 72				call check_stacks 
2002				endif 
2002 c9				ret 
2003			 
2003			 
2003			; increase ret stack pointer and save hl to it 
2003				 
2003			FORTH_RSP_NEXT: macro 
2003				call macro_forth_rsp_next 
2003				endm 
2003			 
2003			macro_forth_rsp_next: 
2003				if DEBUG_FORTH_STACK_GUARD 
2003 cd 72 72				call check_stacks 
2006				endif 
2006 e5				push hl 
2007 d5				push de 
2008 eb				ex de,hl 
2009 2a 2d f9			ld hl,(cli_ret_sp) 
200c 23				inc hl 
200d 23				inc hl 
200e 22 2d f9			ld (cli_ret_sp),hl 
2011 73				ld (hl), e 
2012 23				inc hl 
2013 72				ld (hl), d 
2014 d1				pop de 
2015 e1				pop hl 
2016				if DEBUG_FORTH_STACK_GUARD 
2016 cd 72 72				call check_stacks 
2019				endif 
2019 c9				ret 
201a			 
201a			; get current ret stack pointer and save to hl  
201a				 
201a			FORTH_RSP_TOS: macro 
201a				call macro_forth_rsp_tos 
201a				endm 
201a			 
201a			macro_forth_rsp_tos: 
201a				;push de 
201a 2a 2d f9			ld hl,(cli_ret_sp) 
201d cd 55 20			call loadhlptrtohl 
2020				;ld e, (hl) 
2020				;inc hl 
2020				;ld d, (hl) 
2020				;ex de, hl 
2020					if DEBUG_FORTH_WORDS 
2020			;			DMARK "RST" 
2020						CALLMONITOR 
2020 cd aa fd			call debug_vector  
2023				endm  
# End of macro CALLMONITOR
2023					endif 
2023				;pop de 
2023 c9				ret 
2024			 
2024			; pop ret stack pointer 
2024				 
2024			FORTH_RSP_POP: macro 
2024				call macro_forth_rsp_pop 
2024				endm 
2024			 
2024			 
2024			macro_forth_rsp_pop: 
2024				if DEBUG_FORTH_STACK_GUARD 
2024			;		DMARK "RPP" 
2024 cd 72 72				call check_stacks 
2027					FORTH_CHK_RSP_UNDER 
2027 e5				push hl 
2028 d5				push de 
2029 2a 2d f9			ld hl,(cli_ret_sp) 
202c 11 e7 f8			ld de, cli_ret_stack 
202f cd ed 0f			call cmp16 
2032 da 86 73			jp c, fault_rsp_under 
2035 d1				pop de 
2036 e1				pop hl 
2037				endm 
# End of macro FORTH_CHK_RSP_UNDER
2037				endif 
2037 e5				push hl 
2038 2a 2d f9			ld hl,(cli_ret_sp) 
203b			 
203b			 
203b				if FORTH_ENABLE_FREE 
203b			 
203b					; get pointer 
203b			 
203b					push de 
203b					push hl 
203b			 
203b					ld e, (hl) 
203b					inc hl 
203b					ld d, (hl) 
203b			 
203b					ex de, hl 
203b					call free 
203b			 
203b					pop hl 
203b					pop de 
203b			 
203b			 
203b				endif 
203b			 
203b			 
203b 2b				dec hl 
203c 2b				dec hl 
203d 22 2d f9			ld (cli_ret_sp), hl 
2040				; do stack underflow checks 
2040 e1				pop hl 
2041				if DEBUG_FORTH_STACK_GUARD 
2041 cd 72 72				call check_stacks 
2044					FORTH_CHK_RSP_UNDER 
2044 e5				push hl 
2045 d5				push de 
2046 2a 2d f9			ld hl,(cli_ret_sp) 
2049 11 e7 f8			ld de, cli_ret_stack 
204c cd ed 0f			call cmp16 
204f da 86 73			jp c, fault_rsp_under 
2052 d1				pop de 
2053 e1				pop hl 
2054				endm 
# End of macro FORTH_CHK_RSP_UNDER
2054				endif 
2054 c9				ret 
2055			 
2055			 
2055			 
2055			; routine to load word pointed to by hl into hl 
2055			 
2055			loadhlptrtohl: 
2055			 
2055 d5				push de 
2056 5e				ld e, (hl) 
2057 23				inc hl 
2058 56				ld d, (hl) 
2059 eb				ex de, hl 
205a d1				pop de 
205b			 
205b c9				ret 
205c			 
205c			 
205c			 
205c			 
205c			 
205c			; push a number held in HL onto the data stack 
205c			; entry point for pushing a value when already in hl used in function above 
205c			 
205c			forth_push_numhl: 
205c			 
205c e5				push hl    ; save value to push 
205d			 
205d			if DEBUG_FORTH_PUSH 
205d				; see if disabled 
205d			 
205d			 
205d f5				push af 
205e 3a aa fd			ld a,(debug_vector) 
2061 fe c9			cp $c9   ; ret 
2063			;	ld a, (os_view_disable) 
2063			;	cp '*' 
2063 28 34			jr z, .pskip2 
2065 e5				push hl 
2066 e5			push hl 
2067 cd 9b 0d			call clear_display 
206a e1			pop hl 
206b 7c				ld a,h 
206c 21 01 f4			ld hl, os_word_scratch 
206f cd 29 12			call hexout 
2072 e1				pop hl 
2073 7d				ld a,l 
2074 21 03 f4			ld hl, os_word_scratch+2 
2077 cd 29 12			call hexout 
207a			 
207a 21 05 f4			ld hl, os_word_scratch+4 
207d 3e 00			ld a,0 
207f 77				ld (hl),a 
2080 11 01 f4			ld de,os_word_scratch 
2083 3e 28				ld a, display_row_2 
2085 cd ae 0d				call str_at_display 
2088 11 84 5d			ld de, .push_num 
208b 3e 00			ld a, display_row_1 
208d			 
208d cd ae 0d				call str_at_display 
2090			 
2090			 
2090 cd be 0d			call update_display 
2093 cd de 0c			call delay1s 
2096 cd de 0c			call delay1s 
2099			.pskip2:  
2099			 
2099 f1				pop af 
209a			endif	 
209a			 
209a			 
209a				FORTH_DSP_NEXT 
209a cd eb 1f			call macro_forth_dsp_next 
209d				endm 
# End of macro FORTH_DSP_NEXT
209d			 
209d 2a 29 f9			ld hl, (cli_data_sp) 
20a0			 
20a0				; save item type 
20a0 3e 02			ld a,  DS_TYPE_INUM 
20a2 77				ld (hl), a 
20a3 23				inc hl 
20a4			 
20a4				; get word off stack 
20a4 d1				pop de 
20a5 7b				ld a,e 
20a6 77				ld (hl), a 
20a7 23				inc hl 
20a8 7a				ld a,d 
20a9 77				ld (hl), a 
20aa			 
20aa			if DEBUG_FORTH_PUSH 
20aa 2b				dec hl 
20ab 2b				dec hl 
20ac 2b				dec hl 
20ad						DMARK "PH5" 
20ad f5				push af  
20ae 3a c2 20			ld a, (.dmark)  
20b1 32 a6 fd			ld (debug_mark),a  
20b4 3a c3 20			ld a, (.dmark+1)  
20b7 32 a7 fd			ld (debug_mark+1),a  
20ba 3a c4 20			ld a, (.dmark+2)  
20bd 32 a8 fd			ld (debug_mark+2),a  
20c0 18 03			jr .pastdmark  
20c2 ..			.dmark: db "PH5"  
20c5 f1			.pastdmark: pop af  
20c6			endm  
# End of macro DMARK
20c6				CALLMONITOR 
20c6 cd aa fd			call debug_vector  
20c9				endm  
# End of macro CALLMONITOR
20c9			endif	 
20c9			 
20c9 c9				ret 
20ca			 
20ca			 
20ca			; Push a string to stack pointed to by hl 
20ca			 
20ca			forth_push_str: 
20ca			 
20ca			if DEBUG_FORTH_PUSH 
20ca						DMARK "PSQ" 
20ca f5				push af  
20cb 3a df 20			ld a, (.dmark)  
20ce 32 a6 fd			ld (debug_mark),a  
20d1 3a e0 20			ld a, (.dmark+1)  
20d4 32 a7 fd			ld (debug_mark+1),a  
20d7 3a e1 20			ld a, (.dmark+2)  
20da 32 a8 fd			ld (debug_mark+2),a  
20dd 18 03			jr .pastdmark  
20df ..			.dmark: db "PSQ"  
20e2 f1			.pastdmark: pop af  
20e3			endm  
# End of macro DMARK
20e3				CALLMONITOR 
20e3 cd aa fd			call debug_vector  
20e6				endm  
# End of macro CALLMONITOR
20e6			endif	 
20e6			    
20e6 e5				push hl 
20e7 e5				push hl 
20e8			 
20e8			;	ld a, 0   ; find end of string 
20e8 cd 86 13			call strlenz 
20eb			if DEBUG_FORTH_PUSH 
20eb						DMARK "PQ2" 
20eb f5				push af  
20ec 3a 00 21			ld a, (.dmark)  
20ef 32 a6 fd			ld (debug_mark),a  
20f2 3a 01 21			ld a, (.dmark+1)  
20f5 32 a7 fd			ld (debug_mark+1),a  
20f8 3a 02 21			ld a, (.dmark+2)  
20fb 32 a8 fd			ld (debug_mark+2),a  
20fe 18 03			jr .pastdmark  
2100 ..			.dmark: db "PQ2"  
2103 f1			.pastdmark: pop af  
2104			endm  
# End of macro DMARK
2104				CALLMONITOR 
2104 cd aa fd			call debug_vector  
2107				endm  
# End of macro CALLMONITOR
2107			endif	 
2107 eb				ex de, hl 
2108 e1				pop hl   ; get ptr to start of string 
2109			if DEBUG_FORTH_PUSH 
2109						DMARK "PQ3" 
2109 f5				push af  
210a 3a 1e 21			ld a, (.dmark)  
210d 32 a6 fd			ld (debug_mark),a  
2110 3a 1f 21			ld a, (.dmark+1)  
2113 32 a7 fd			ld (debug_mark+1),a  
2116 3a 20 21			ld a, (.dmark+2)  
2119 32 a8 fd			ld (debug_mark+2),a  
211c 18 03			jr .pastdmark  
211e ..			.dmark: db "PQ3"  
2121 f1			.pastdmark: pop af  
2122			endm  
# End of macro DMARK
2122				CALLMONITOR 
2122 cd aa fd			call debug_vector  
2125				endm  
# End of macro CALLMONITOR
2125			endif	 
2125 19				add hl,de 
2126			if DEBUG_FORTH_PUSH 
2126						DMARK "PQE" 
2126 f5				push af  
2127 3a 3b 21			ld a, (.dmark)  
212a 32 a6 fd			ld (debug_mark),a  
212d 3a 3c 21			ld a, (.dmark+1)  
2130 32 a7 fd			ld (debug_mark+1),a  
2133 3a 3d 21			ld a, (.dmark+2)  
2136 32 a8 fd			ld (debug_mark+2),a  
2139 18 03			jr .pastdmark  
213b ..			.dmark: db "PQE"  
213e f1			.pastdmark: pop af  
213f			endm  
# End of macro DMARK
213f				CALLMONITOR 
213f cd aa fd			call debug_vector  
2142				endm  
# End of macro CALLMONITOR
2142			endif	 
2142			 
2142 2b				dec hl    ; see if there is an optional trailing double quote 
2143 7e				ld a,(hl) 
2144 fe 22			cp '"' 
2146 20 03			jr nz, .strnoq 
2148 3e 00			ld a, 0      ; get rid of double quote 
214a 77				ld (hl), a 
214b 23			.strnoq: inc hl 
214c			 
214c 3e 00			ld a, 0 
214e 77				ld (hl), a     ; add null term and get rid of trailing double quote 
214f			 
214f 13				inc de ; add one for the type string 
2150 13				inc de ; add one for null term??? 
2151			 
2151				; tos is get string pointer again 
2151				; de contains space to allocate 
2151				 
2151 d5				push de 
2152			 
2152 eb				ex de, hl 
2153			 
2153				;push af 
2153			 
2153			if DEBUG_FORTH_PUSH 
2153						DMARK "PHm" 
2153 f5				push af  
2154 3a 68 21			ld a, (.dmark)  
2157 32 a6 fd			ld (debug_mark),a  
215a 3a 69 21			ld a, (.dmark+1)  
215d 32 a7 fd			ld (debug_mark+1),a  
2160 3a 6a 21			ld a, (.dmark+2)  
2163 32 a8 fd			ld (debug_mark+2),a  
2166 18 03			jr .pastdmark  
2168 ..			.dmark: db "PHm"  
216b f1			.pastdmark: pop af  
216c			endm  
# End of macro DMARK
216c				CALLMONITOR 
216c cd aa fd			call debug_vector  
216f				endm  
# End of macro CALLMONITOR
216f			endif	 
216f cd fb 13			call malloc	; on ret hl now contains allocated memory 
2172				if DEBUG_FORTH_MALLOC_GUARD 
2172 cc dc 5d				call z,malloc_error 
2175				endif 
2175			 
2175				 
2175 c1				pop bc    ; get length 
2176 d1				pop de   ;  get string start    
2177			 
2177				; hl has destination from malloc 
2177			 
2177 eb				ex de, hl    ; prep for ldir 
2178			 
2178 d5				push de   ; save malloc area for DSP later 
2179				;push hl   ; save malloc area for DSP later 
2179			 
2179			if DEBUG_FORTH_PUSH 
2179						DMARK "PHc" 
2179 f5				push af  
217a 3a 8e 21			ld a, (.dmark)  
217d 32 a6 fd			ld (debug_mark),a  
2180 3a 8f 21			ld a, (.dmark+1)  
2183 32 a7 fd			ld (debug_mark+1),a  
2186 3a 90 21			ld a, (.dmark+2)  
2189 32 a8 fd			ld (debug_mark+2),a  
218c 18 03			jr .pastdmark  
218e ..			.dmark: db "PHc"  
2191 f1			.pastdmark: pop af  
2192			endm  
# End of macro DMARK
2192				CALLMONITOR 
2192 cd aa fd			call debug_vector  
2195				endm  
# End of macro CALLMONITOR
2195			endif	 
2195			 
2195			 
2195 ed b0			ldir 
2197			 
2197			 
2197				; push malloc to data stack     macro?????  
2197			 
2197				FORTH_DSP_NEXT 
2197 cd eb 1f			call macro_forth_dsp_next 
219a				endm 
# End of macro FORTH_DSP_NEXT
219a			 
219a				; save value and type 
219a			 
219a 2a 29 f9			ld hl, (cli_data_sp) 
219d			 
219d				; save item type 
219d 3e 01			ld a,  DS_TYPE_STR 
219f 77				ld (hl), a 
21a0 23				inc hl 
21a1			 
21a1				; get malloc word off stack 
21a1 d1				pop de 
21a2 73				ld (hl), e 
21a3 23				inc hl 
21a4 72				ld (hl), d 
21a5			 
21a5			 
21a5			 
21a5			if DEBUG_FORTH_PUSH 
21a5 2a 29 f9			ld hl, (cli_data_sp) 
21a8						DMARK "PHS" 
21a8 f5				push af  
21a9 3a bd 21			ld a, (.dmark)  
21ac 32 a6 fd			ld (debug_mark),a  
21af 3a be 21			ld a, (.dmark+1)  
21b2 32 a7 fd			ld (debug_mark+1),a  
21b5 3a bf 21			ld a, (.dmark+2)  
21b8 32 a8 fd			ld (debug_mark+2),a  
21bb 18 03			jr .pastdmark  
21bd ..			.dmark: db "PHS"  
21c0 f1			.pastdmark: pop af  
21c1			endm  
# End of macro DMARK
21c1				CALLMONITOR 
21c1 cd aa fd			call debug_vector  
21c4				endm  
# End of macro CALLMONITOR
21c4			;	ex de,hl 
21c4			endif	 
21c4				; in case of spaces, skip the ptr past the copied string 
21c4				;pop af 
21c4				;ld (cli_origptr),hl 
21c4			 
21c4 c9				ret 
21c5			 
21c5			 
21c5			 
21c5			; TODO ascii push input onto stack given hl to start of input 
21c5			 
21c5			; identify type 
21c5			; if starts with a " then a string 
21c5			; otherwise it is a number 
21c5			;  
21c5			; if a string 
21c5			;     scan for ending " to get length of string to malloc for + 1 
21c5			;     malloc 
21c5			;     put pointer to string on stack first byte flags as string 
21c5			; 
21c5			; else a number 
21c5			;    look for number format identifier 
21c5			;    $xx hex 
21c5			;    %xxxxx bin 
21c5			;    xxxxx decimal 
21c5			;    convert number to 16bit word.  
21c5			;    malloc word + 1 with flag to identiy as num 
21c5			;    put pointer to number on stack 
21c5			;   
21c5			;  
21c5			  
21c5			forth_apush: 
21c5				; kernel push 
21c5			 
21c5			if DEBUG_FORTH_PUSH 
21c5						DMARK "PSH" 
21c5 f5				push af  
21c6 3a da 21			ld a, (.dmark)  
21c9 32 a6 fd			ld (debug_mark),a  
21cc 3a db 21			ld a, (.dmark+1)  
21cf 32 a7 fd			ld (debug_mark+1),a  
21d2 3a dc 21			ld a, (.dmark+2)  
21d5 32 a8 fd			ld (debug_mark+2),a  
21d8 18 03			jr .pastdmark  
21da ..			.dmark: db "PSH"  
21dd f1			.pastdmark: pop af  
21de			endm  
# End of macro DMARK
21de				CALLMONITOR 
21de cd aa fd			call debug_vector  
21e1				endm  
# End of macro CALLMONITOR
21e1			endif	 
21e1				; identify input type 
21e1			 
21e1 7e				ld a,(hl) 
21e2 fe 22			cp '"' 
21e4 28 0a			jr z, .fapstr 
21e6 fe 24			cp '$' 
21e8 ca 10 22			jp z, .faphex 
21eb fe 25			cp '%' 
21ed ca f8 21			jp z, .fapbin 
21f0			;	cp 'b' 
21f0			;	jp z, .fabin 
21f0				; else decimal 
21f0			 
21f0				; TODO do decimal conversion 
21f0				; decimal is stored as a 16bit word 
21f0			 
21f0				; by default everything is a string if type is not detected 
21f0			.fapstr: ; 
21f0 fe 22			cp '"' 
21f2 20 01			jr nz, .strnoqu 
21f4 23				inc hl 
21f5			.strnoqu: 
21f5 c3 ca 20			jp forth_push_str 
21f8			 
21f8			 
21f8			 
21f8			.fapbin:    ; push a binary string.  
21f8 11 00 00			ld de, 0   ; hold a 16bit value 
21fb			 
21fb 23			.fapbinshift:	inc hl  
21fc 7e				ld a,(hl) 
21fd fe 00			cp 0     ; done scanning  
21ff 28 0b			jr z, .fapbdone  	; got it in HL so push  
2201			 
2201				; left shift de 
2201 eb				ex de, hl	 
2202 29				add hl, hl 
2203			 
2203				; is 1 
2203 fe 31			cp '1' 
2205 20 02			jr nz, .binzero 
2207 cb 4d			bit 1, l 
2209			.binzero: 
2209 eb				ex de, hl	 ; save current de 
220a 18 ef			jr .fapbinshift 
220c			 
220c			.fapbdone: 
220c eb				ex de, hl 
220d c3 5c 20			jp forth_push_numhl 
2210			 
2210			 
2210			.faphex:   ; hex is always stored as a 16bit word 
2210				; skip number prefix 
2210 23				inc hl 
2211				; turn ascii into number 
2211 cd df 12			call get_word_hl	; ret 16bit word in hl 
2214			 
2214 c3 5c 20			jp forth_push_numhl 
2217			 
2217 00				 nop 
2218			 
2218			.fabin:   ; TODO bin conversion 
2218			 
2218			 
2218 c9				ret 
2219			 
2219			 
2219			; get either a string ptr or a 16bit word from the data stack 
2219			 
2219			FORTH_DSP: macro 
2219				call macro_forth_dsp 
2219				endm 
2219			 
2219			macro_forth_dsp: 
2219				; data stack pointer points to current word on tos 
2219			 
2219 2a 29 f9			ld hl,(cli_data_sp) 
221c			 
221c				if DEBUG_FORTH_PUSH 
221c						DMARK "DSP" 
221c f5				push af  
221d 3a 31 22			ld a, (.dmark)  
2220 32 a6 fd			ld (debug_mark),a  
2223 3a 32 22			ld a, (.dmark+1)  
2226 32 a7 fd			ld (debug_mark+1),a  
2229 3a 33 22			ld a, (.dmark+2)  
222c 32 a8 fd			ld (debug_mark+2),a  
222f 18 03			jr .pastdmark  
2231 ..			.dmark: db "DSP"  
2234 f1			.pastdmark: pop af  
2235			endm  
# End of macro DMARK
2235			 
2235 cd 0f 5e				call display_data_sp 
2238				;call break_point_state 
2238				;rst 030h 
2238				CALLMONITOR 
2238 cd aa fd			call debug_vector  
223b				endm  
# End of macro CALLMONITOR
223b				endif 
223b			 
223b c9				ret 
223c			 
223c			; return hl to start of value on stack 
223c			 
223c			FORTH_DSP_VALUE: macro 
223c				call macro_forth_dsp_value 
223c				endm 
223c			 
223c			macro_forth_dsp_value: 
223c			 
223c				FORTH_DSP 
223c cd 19 22			call macro_forth_dsp 
223f				endm 
# End of macro FORTH_DSP
223f			 
223f d5				push de 
2240			 
2240 23				inc hl ; skip type 
2241			 
2241 5e				ld e, (hl) 
2242 23				inc hl 
2243 56				ld d, (hl) 
2244 eb				ex de,hl  
2245			 
2245 d1				pop de 
2246			 
2246 c9				ret 
2247			 
2247			; return hl to start of value to second item on stack 
2247			 
2247			FORTH_DSP_VALUEM1: macro 
2247				call macro_forth_dsp_value_m1 
2247				endm 
2247			 
2247			macro_forth_dsp_value_m1: 
2247			 
2247				FORTH_DSP 
2247 cd 19 22			call macro_forth_dsp 
224a				endm 
# End of macro FORTH_DSP
224a			 
224a 2b				dec hl 
224b 2b				dec hl 
224c			;	dec hl 
224c			 
224c d5				push de 
224d			 
224d 5e				ld e, (hl) 
224e 23				inc hl 
224f 56				ld d, (hl) 
2250 eb				ex de,hl  
2251			 
2251 d1				pop de 
2252			 
2252 c9				ret 
2253			 
2253				 
2253			 
2253			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
2253			 
2253			FORTH_DSP_POP: macro 
2253				call macro_forth_dsp_pop 
2253				endm 
2253			 
2253			 
2253			; get the tos data type 
2253			 
2253			FORTH_DSP_TYPE:   macro 
2253			 
2253				;FORTH_DSP_VALUE 
2253				FORTH_DSP 
2253				 
2253				; hl points to value 
2253				; check type 
2253			 
2253				ld a,(hl) 
2253			 
2253				endm 
2253			 
2253			; load the tos value into hl 
2253			 
2253			 
2253			FORTH_DSP_VALUEHL:  macro 
2253				call macro_dsp_valuehl 
2253				endm 
2253			 
2253			 
2253			 
2253			macro_dsp_valuehl: 
2253				FORTH_DSP_VALUE 
2253 cd 3c 22			call macro_forth_dsp_value 
2256				endm 
# End of macro FORTH_DSP_VALUE
2256			 
2256				;FORTH_ERR_TOS_NOTNUM 
2256			 
2256				;inc hl   ; skip type id 
2256			 
2256			;	push de 
2256			; 
2256			;	ld e, (hl) 
2256			;	inc hl 
2256			;	ld d, (hl) 
2256			;	ex de,hl  
2256			 
2256			;	pop de 
2256			 
2256				if DEBUG_FORTH_PUSH 
2256						DMARK "DVL" 
2256 f5				push af  
2257 3a 6b 22			ld a, (.dmark)  
225a 32 a6 fd			ld (debug_mark),a  
225d 3a 6c 22			ld a, (.dmark+1)  
2260 32 a7 fd			ld (debug_mark+1),a  
2263 3a 6d 22			ld a, (.dmark+2)  
2266 32 a8 fd			ld (debug_mark+2),a  
2269 18 03			jr .pastdmark  
226b ..			.dmark: db "DVL"  
226e f1			.pastdmark: pop af  
226f			endm  
# End of macro DMARK
226f				CALLMONITOR 
226f cd aa fd			call debug_vector  
2272				endm  
# End of macro CALLMONITOR
2272				endif 
2272 c9				ret 
2273			 
2273			forth_apushstrhl:      
2273				; push of string requires use of cli_origptr 
2273				; bodge use 
2273			 
2273				; get current cli_origptr, save, update with temp pointer  
2273 ed 5b 79 f9		ld de, (cli_origptr) 
2277 22 79 f9			ld (cli_origptr), hl 
227a d5				push de 
227b cd c5 21			call forth_apush 
227e d1				pop de 
227f ed 53 79 f9		ld (cli_origptr), de 
2283 c9			        ret	 
2284			 
2284			 
2284			; increase loop stack pointer and save hl to it 
2284				 
2284			FORTH_LOOP_NEXT: macro 
2284				call macro_forth_loop_next 
2284				;nop 
2284				endm 
2284			 
2284			macro_forth_loop_next: 
2284				if DEBUG_FORTH_STACK_GUARD 
2284 cd 72 72				call check_stacks 
2287				endif 
2287 e5				push hl 
2288 d5				push de 
2289 eb				ex de,hl 
228a 2a 2b f9			ld hl,(cli_loop_sp) 
228d 23				inc hl 
228e 23				inc hl 
228f					if DEBUG_FORTH_WORDS 
228f						DMARK "LNX" 
228f f5				push af  
2290 3a a4 22			ld a, (.dmark)  
2293 32 a6 fd			ld (debug_mark),a  
2296 3a a5 22			ld a, (.dmark+1)  
2299 32 a7 fd			ld (debug_mark+1),a  
229c 3a a6 22			ld a, (.dmark+2)  
229f 32 a8 fd			ld (debug_mark+2),a  
22a2 18 03			jr .pastdmark  
22a4 ..			.dmark: db "LNX"  
22a7 f1			.pastdmark: pop af  
22a8			endm  
# End of macro DMARK
22a8						CALLMONITOR 
22a8 cd aa fd			call debug_vector  
22ab				endm  
# End of macro CALLMONITOR
22ab					endif 
22ab 22 2b f9			ld (cli_loop_sp),hl 
22ae 73				ld (hl), e 
22af 23				inc hl 
22b0 72				ld (hl), d 
22b1 d1				pop de    ; been reversed so save a swap on restore 
22b2 e1				pop hl 
22b3				if DEBUG_FORTH_STACK_GUARD 
22b3 cd 72 72				call check_stacks 
22b6				endif 
22b6 c9				ret 
22b7			 
22b7			; get current ret stack pointer and save to hl  
22b7				 
22b7			FORTH_LOOP_TOS: macro 
22b7				call macro_forth_loop_tos 
22b7				endm 
22b7			 
22b7			macro_forth_loop_tos: 
22b7 d5				push de 
22b8 2a 2b f9			ld hl,(cli_loop_sp) 
22bb 5e				ld e, (hl) 
22bc 23				inc hl 
22bd 56				ld d, (hl) 
22be eb				ex de, hl 
22bf d1				pop de 
22c0 c9				ret 
22c1			 
22c1			; pop loop stack pointer 
22c1				 
22c1			FORTH_LOOP_POP: macro 
22c1				call macro_forth_loop_pop 
22c1				endm 
22c1			 
22c1			 
22c1			macro_forth_loop_pop: 
22c1				if DEBUG_FORTH_STACK_GUARD 
22c1					DMARK "LPP" 
22c1 f5				push af  
22c2 3a d6 22			ld a, (.dmark)  
22c5 32 a6 fd			ld (debug_mark),a  
22c8 3a d7 22			ld a, (.dmark+1)  
22cb 32 a7 fd			ld (debug_mark+1),a  
22ce 3a d8 22			ld a, (.dmark+2)  
22d1 32 a8 fd			ld (debug_mark+2),a  
22d4 18 03			jr .pastdmark  
22d6 ..			.dmark: db "LPP"  
22d9 f1			.pastdmark: pop af  
22da			endm  
# End of macro DMARK
22da cd 72 72				call check_stacks 
22dd					FORTH_CHK_LOOP_UNDER 
22dd e5				push hl 
22de d5				push de 
22df 2a 2b f9			ld hl,(cli_loop_sp) 
22e2 11 65 f8			ld de, cli_loop_stack 
22e5 cd ed 0f			call cmp16 
22e8 da 8c 73			jp c, fault_loop_under 
22eb d1				pop de 
22ec e1				pop hl 
22ed				endm 
# End of macro FORTH_CHK_LOOP_UNDER
22ed				endif 
22ed e5				push hl 
22ee 2a 2b f9			ld hl,(cli_loop_sp) 
22f1 2b				dec hl 
22f2 2b				dec hl 
22f3 22 2b f9			ld (cli_loop_sp), hl 
22f6				; TODO do stack underflow checks 
22f6 e1				pop hl 
22f7				if DEBUG_FORTH_STACK_GUARD 
22f7 cd 72 72				call check_stacks 
22fa					FORTH_CHK_LOOP_UNDER 
22fa e5				push hl 
22fb d5				push de 
22fc 2a 2b f9			ld hl,(cli_loop_sp) 
22ff 11 65 f8			ld de, cli_loop_stack 
2302 cd ed 0f			call cmp16 
2305 da 8c 73			jp c, fault_loop_under 
2308 d1				pop de 
2309 e1				pop hl 
230a				endm 
# End of macro FORTH_CHK_LOOP_UNDER
230a				endif 
230a c9				ret 
230b			 
230b			macro_forth_dsp_pop: 
230b			 
230b e5				push hl 
230c			 
230c				; release malloc data 
230c			 
230c				if DEBUG_FORTH_STACK_GUARD 
230c cd 72 72				call check_stacks 
230f					FORTH_CHK_DSP_UNDER 
230f e5				push hl 
2310 d5				push de 
2311 2a 29 f9			ld hl,(cli_data_sp) 
2314 11 63 f6			ld de, cli_data_stack 
2317 cd ed 0f			call cmp16 
231a da 80 73			jp c, fault_dsp_under 
231d d1				pop de 
231e e1				pop hl 
231f				endm 
# End of macro FORTH_CHK_DSP_UNDER
231f				endif 
231f				;ld hl,(cli_data_sp) 
231f			if DEBUG_FORTH_DOT 
231f				DMARK "DPP" 
231f f5				push af  
2320 3a 34 23			ld a, (.dmark)  
2323 32 a6 fd			ld (debug_mark),a  
2326 3a 35 23			ld a, (.dmark+1)  
2329 32 a7 fd			ld (debug_mark+1),a  
232c 3a 36 23			ld a, (.dmark+2)  
232f 32 a8 fd			ld (debug_mark+2),a  
2332 18 03			jr .pastdmark  
2334 ..			.dmark: db "DPP"  
2337 f1			.pastdmark: pop af  
2338			endm  
# End of macro DMARK
2338				CALLMONITOR 
2338 cd aa fd			call debug_vector  
233b				endm  
# End of macro CALLMONITOR
233b			endif	 
233b			 
233b			 
233b			if FORTH_ENABLE_DSPPOPFREE 
233b			 
233b				FORTH_DSP 
233b cd 19 22			call macro_forth_dsp 
233e				endm 
# End of macro FORTH_DSP
233e			 
233e 7e				ld a, (hl) 
233f fe 01			cp DS_TYPE_STR 
2341 20 23			jr nz, .skippopfree 
2343			 
2343				FORTH_DSP_VALUEHL 
2343 cd 53 22			call macro_dsp_valuehl 
2346				endm 
# End of macro FORTH_DSP_VALUEHL
2346 00				nop 
2347			if DEBUG_FORTH_DOT 
2347				DMARK "DPf" 
2347 f5				push af  
2348 3a 5c 23			ld a, (.dmark)  
234b 32 a6 fd			ld (debug_mark),a  
234e 3a 5d 23			ld a, (.dmark+1)  
2351 32 a7 fd			ld (debug_mark+1),a  
2354 3a 5e 23			ld a, (.dmark+2)  
2357 32 a8 fd			ld (debug_mark+2),a  
235a 18 03			jr .pastdmark  
235c ..			.dmark: db "DPf"  
235f f1			.pastdmark: pop af  
2360			endm  
# End of macro DMARK
2360				CALLMONITOR 
2360 cd aa fd			call debug_vector  
2363				endm  
# End of macro CALLMONITOR
2363			endif	 
2363 cd c5 14			call free 
2366			.skippopfree: 
2366				 
2366			 
2366			endif 
2366			 
2366			if DEBUG_FORTH_DOT_KEY 
2366				DMARK "DP2" 
2366				CALLMONITOR 
2366			endif	 
2366			 
2366				; move pointer down 
2366			 
2366 2a 29 f9			ld hl,(cli_data_sp) 
2369 2b				dec hl 
236a 2b				dec hl 
236b			; PARSEV5 
236b 2b				dec hl 
236c 22 29 f9			ld (cli_data_sp), hl 
236f			 
236f				if DEBUG_FORTH_STACK_GUARD 
236f cd 72 72				call check_stacks 
2372					FORTH_CHK_DSP_UNDER 
2372 e5				push hl 
2373 d5				push de 
2374 2a 29 f9			ld hl,(cli_data_sp) 
2377 11 63 f6			ld de, cli_data_stack 
237a cd ed 0f			call cmp16 
237d da 80 73			jp c, fault_dsp_under 
2380 d1				pop de 
2381 e1				pop hl 
2382				endm 
# End of macro FORTH_CHK_DSP_UNDER
2382				endif 
2382			 
2382 e1				pop hl 
2383			 
2383 c9				ret 
2384			 
2384			getwordathl: 
2384				; hl points to an address 
2384				; load hl with the word at that address 
2384			 
2384 d5				push de 
2385			 
2385 5e				ld e, (hl) 
2386 23				inc hl 
2387 56				ld d, (hl) 
2388 eb				ex de, hl 
2389			 
2389 d1				pop de 
238a c9				ret 
238b			 
238b			 
238b			 
238b			 
238b			 
238b			; eof 
238b			 
# End of file forth_stackopsv5.asm
238b			endif 
238b			 
238b			loadwordinhl:	 
238b			 
238b d5				push de 
238c			 
238c 5e				ld e, (hl) 
238d 23				inc hl 
238e 56				ld d, (hl) 
238f eb				ex de,hl  
2390			 
2390 d1				pop de 
2391			 
2391 c9				ret 
2392			 
2392			user_word_eol:  
2392				; hl contains the pointer to where to create a linked list item from the end 
2392				; of the user dict to continue on at the system word dict 
2392				 
2392				; poke the stub of the word list linked list to repoint to rom words 
2392			 
2392				; stub format 
2392				; db   word id 
2392				; dw    link to next word 
2392			        ; db char length of token 
2392				; db string + 0 term 
2392				; db exec code....  
2392			 
2392 3e 00			ld a, WORD_SYS_ROOT     ; root word 
2394 77				ld (hl), a		; word id 
2395 23				inc hl 
2396			 
2396 11 61 25			ld de, sysdict 
2399 73				ld (hl), e		; next word link ie system dict 
239a 23				inc hl 
239b 72				ld (hl), d		; next word link ie system dict 
239c 23				inc hl	 
239d			 
239d			;	ld (hl), sysdict		; next word link ie system dict 
239d			;	inc hl 
239d			;	inc hl 
239d			 
239d			;	inc hl 
239d			;	inc hl 
239d			 
239d 3e 02			ld a, 2			; word length is 0 
239f 77				ld (hl), a	 
23a0 23				inc hl 
23a1			 
23a1 3e 7e			ld a, '~'			; word length is 0 
23a3 77				ld (hl), a	 
23a4 23				inc hl 
23a5 3e 00			ld a, 0			; save empty word 
23a7 77				ld (hl), a 
23a8			 
23a8 c9				ret 
23a9			 
23a9				 
23a9			 
23a9			forthexec_cleanup: 
23a9				FORTH_RSP_POP 
23a9 cd 24 20			call macro_forth_rsp_pop 
23ac				endm 
# End of macro FORTH_RSP_POP
23ac c9				ret 
23ad			 
23ad			forth_call_hl: 
23ad				; taking hl 
23ad e5				push hl 
23ae c9				ret 
23af			 
23af			; this is called to reset Forth system but keep existing uwords etc 
23af			 
23af			forth_warmstart: 
23af				; setup stack over/under flow checks 
23af				if DEBUG_FORTH_STACK_GUARD 
23af cd 58 72				call chk_stk_init 
23b2				endif 
23b2			 
23b2				; init stack pointers  - * these stacks go upwards *  
23b2 21 e7 f8			ld hl, cli_ret_stack 
23b5 22 2d f9			ld (cli_ret_sp), hl	 
23b8				; set bottom of stack 
23b8 3e 00			ld a,0 
23ba 77				ld (hl),a 
23bb 23				inc hl 
23bc 77				ld (hl),a 
23bd			 
23bd 21 63 f6			ld hl, cli_data_stack 
23c0 22 29 f9			ld (cli_data_sp), hl	 
23c3				; set bottom of stack 
23c3 3e 00			ld a,0 
23c5 77				ld (hl),a 
23c6 23				inc hl 
23c7 77				ld (hl),a 
23c8			 
23c8 21 65 f8			ld hl, cli_loop_stack 
23cb 22 2b f9			ld (cli_loop_sp), hl	 
23ce				; set bottom of stack 
23ce 3e 00			ld a,0 
23d0 77				ld (hl),a 
23d1 23				inc hl 
23d2 77				ld (hl),a 
23d3			 
23d3				; init extent of current open file 
23d3			 
23d3 3e 00			ld a, 0 
23d5 32 a5 f9			ld (store_openext), a 
23d8			 
23d8 c9				ret 
23d9			 
23d9			 
23d9			 
23d9			; Cold Start - this is called to setup the whole Forth system 
23d9			 
23d9			forth_init: 
23d9			 
23d9				; setup stack over/under flow checks 
23d9			 
23d9			;	if DEBUG_FORTH_STACK_GUARD 
23d9			;		call chk_stk_init 
23d9			;	endif 
23d9			 
23d9				; enable auto display updates (slow.....) 
23d9			 
23d9 3e 01			ld a, 1 
23db 32 77 f9			ld (cli_autodisplay), a 
23de			 
23de				; if storage is in use disable long reads for now 
23de 3e 00			ld a, 0 
23e0 32 b0 f9			ld (store_longread), a 
23e3			 
23e3			 
23e3				; show start up screen 
23e3			 
23e3 cd 9b 0d			call clear_display 
23e6			 
23e6 3e 00			ld a,0 
23e8 32 99 f9			ld (f_cursor_ptr), a 
23eb			 
23eb				; set start of word list in start of ram - for use when creating user words 
23eb			 
23eb 21 00 80			ld hl, baseram 
23ee 22 f9 f3			ld (os_last_new_uword), hl 
23f1 cd 92 23			call user_word_eol 
23f4				 
23f4			;		call display_data_sp 
23f4			;		call next_page_prompt 
23f4			 
23f4			 
23f4			 
23f4			 
23f4 c9				ret 
23f5			 
23f5 .. 00		.bootforth: db " Forth Kernel Init ",0 
2409			 
2409			; TODO push to stack 
2409			 
2409			;  
2409			 
2409			if FORTH_PARSEV2 
2409			 
2409			 
2409				include "forth_parserv2.asm" 
2409			 
2409			endif 
2409			 
2409			 
2409			; parse cli version 1 
2409			 
2409			if FORTH_PARSEV1 
2409			 
2409			 
2409			 
2409			      include "forth_parserv1.asm" 
2409			endif 
2409				 
2409			if FORTH_PARSEV3 
2409			 
2409			 
2409			 
2409			      include "forth_parserv3.asm" 
2409				include "forth_wordsv3.asm" 
2409			endif 
2409			 
2409			if FORTH_PARSEV4 
2409			 
2409			 
2409			 
2409			      include "forth_parserv4.asm" 
2409				include "forth_wordsv4.asm" 
2409			endif 
2409			 
2409			if FORTH_PARSEV5 
2409			 
2409			 
2409			 
2409			      include "forth_parserv5.asm" 
2409			 
2409			 
2409			; A better parser without using malloc and string copies all over the place.  
2409			; Exec in situ should be faster 
2409			 
2409			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2409			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2409			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2409			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2409			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2409			WORD_SYS_END: equ 0   ; Opcode for all user words 
2409			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2409			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2409			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2409			 
2409			; Core word preamble macro 
2409			 
2409			CWHEAD:   macro nxtword opcode lit len opflags 
2409				db WORD_SYS_CORE+opcode             
2409				; internal op code number 
2409				dw nxtword            
2409				; link to next dict word block 
2409				db len + 1 
2409				; literal length of dict word inc zero term 
2409				db lit,0              
2409				; literal dict word 
2409			        ; TODO db opflags        
2409				endm 
2409			 
2409			 
2409			NEXTW: macro  
2409				jp macro_next 
2409				endm 
2409			 
2409			macro_next: 
2409			if DEBUG_FORTH_PARSE_KEY 
2409				DMARK "NXT" 
2409				CALLMONITOR 
2409			endif	 
2409			;	inc hl  ; skip token null term  
2409 ed 4b 7b f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
240d ed 5b 79 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2411 2a fd f3			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2414			if DEBUG_FORTH_PARSE_KEY 
2414				DMARK "}AA" 
2414				CALLMONITOR 
2414			endif	 
2414 c3 17 25			jp execnext 
2417				;jp exec1 
2417			       
2417			 
2417			 
2417			; Another go at the parser to compile  
2417			 
2417			 
2417			; TODO rework parser to change all of the string words to byte tokens 
2417			; TODO do a search for  
2417			 
2417			; TODO first run normal parser to zero term sections 
2417			; TODO for each word do a token look up to get the op code 
2417			; TODO need some means to flag to the exec that this is a byte code form    
2417			 
2417			 
2417			forthcompile: 
2417			 
2417			; 
2417			; line parse: 
2417			;       parse raw input buffer 
2417			;       tokenise the words 
2417			;       malloc new copy (for looping etc) 
2417			;       copy to malloc + current pc in line to start of string and add line term 
2417			;       save on new rsp 
2417			; 
2417			 
2417			; hl to point to the line to tokenise 
2417			 
2417			;	push hl 
2417 22 fd f3			ld (os_tok_ptr), hl  ; save ptr to string 
241a			 
241a			;	ld a,0		; string term on input 
241a			;	call strlent 
241a			 
241a			;	ld (os_tok_len), hl	 ; save string length 
241a			 
241a			;if DEBUG_FORTH_TOK 
241a			;	ex de,hl		 
241a			;endif 
241a			 
241a			;	pop hl 		; get back string pointer 
241a			 
241a			if DEBUG_FORTH_TOK 
241a						DMARK "TOc" 
241a				CALLMONITOR 
241a			endif 
241a 7e			.cptoken2:    ld a,(hl) 
241b 23				inc hl 
241c fe 7f			cp FORTH_END_BUFFER 
241e 28 29			jr z, .cptokendone2 
2420 fe 00			cp 0 
2422 28 25			jr z, .cptokendone2 
2424 fe 22			cp '"' 
2426 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2428 fe 20			cp ' ' 
242a 20 ee			jr nz,  .cptoken2 
242c			 
242c			; TODO consume comments held between ( and ) 
242c			 
242c				; we have a space so change to zero term for dict match later 
242c 2b				dec hl 
242d 3e 00			ld a,0 
242f 77				ld (hl), a 
2430 23				inc hl 
2431 18 e7			jr .cptoken2 
2433				 
2433			 
2433			.cptokenstr2: 
2433				; skip all white space until either eol (because forgot to term) or end double quote 
2433			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2433				;inc hl ; skip current double quote 
2433 7e				ld a,(hl) 
2434 23				inc hl 
2435 fe 22			cp '"' 
2437 28 e1			jr z, .cptoken2 
2439 fe 7f			cp FORTH_END_BUFFER 
243b 28 0c			jr z, .cptokendone2 
243d fe 00			cp 0 
243f 28 08			jr z, .cptokendone2 
2441 fe 20			cp ' ' 
2443 28 02			jr z, .cptmp2 
2445 18 ec			jr .cptokenstr2 
2447			 
2447			.cptmp2:	; we have a space so change to zero term for dict match later 
2447				;dec hl 
2447				;ld a,"-"	; TODO remove this when working 
2447				;ld (hl), a 
2447				;inc hl 
2447 18 ea			jr .cptokenstr2 
2449			 
2449			.cptokendone2: 
2449				;inc hl 
2449 3e 7f			ld a, FORTH_END_BUFFER 
244b 77				ld (hl),a 
244c 23				inc hl 
244d 3e 21			ld a, '!' 
244f 77				ld (hl),a 
2450			 
2450 2a fd f3			ld hl,(os_tok_ptr) 
2453			         
2453			if DEBUG_FORTH_TOK 
2453						DMARK "Tc1" 
2453				CALLMONITOR 
2453			endif 
2453			 
2453				; push exec string to top of return stack 
2453				FORTH_RSP_NEXT 
2453 cd 03 20			call macro_forth_rsp_next 
2456				endm 
# End of macro FORTH_RSP_NEXT
2456 c9				ret 
2457			 
2457			; Another go at the parser need to simplify the process 
2457			 
2457			forthparse: 
2457			 
2457			; 
2457			; line parse: 
2457			;       parse raw input buffer 
2457			;       tokenise the words 
2457			;       malloc new copy (for looping etc) 
2457			;       copy to malloc + current pc in line to start of string and add line term 
2457			;       save on new rsp 
2457			; 
2457			 
2457			; hl to point to the line to tokenise 
2457			 
2457			;	push hl 
2457 22 fd f3			ld (os_tok_ptr), hl  ; save ptr to string 
245a			 
245a			;	ld a,0		; string term on input 
245a			;	call strlent 
245a			 
245a			;	ld (os_tok_len), hl	 ; save string length 
245a			 
245a			;if DEBUG_FORTH_TOK 
245a			;	ex de,hl		 
245a			;endif 
245a			 
245a			;	pop hl 		; get back string pointer 
245a			 
245a			if DEBUG_FORTH_TOK 
245a						DMARK "TOK" 
245a				CALLMONITOR 
245a			endif 
245a 7e			.ptoken2:    ld a,(hl) 
245b 23				inc hl 
245c fe 7f			cp FORTH_END_BUFFER 
245e 28 29			jr z, .ptokendone2 
2460 fe 00			cp 0 
2462 28 25			jr z, .ptokendone2 
2464 fe 22			cp '"' 
2466 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2468 fe 20			cp ' ' 
246a 20 ee			jr nz,  .ptoken2 
246c			 
246c			; TODO consume comments held between ( and ) 
246c			 
246c				; we have a space so change to zero term for dict match later 
246c 2b				dec hl 
246d 3e 00			ld a,0 
246f 77				ld (hl), a 
2470 23				inc hl 
2471 18 e7			jr .ptoken2 
2473				 
2473			 
2473			.ptokenstr2: 
2473				; skip all white space until either eol (because forgot to term) or end double quote 
2473			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2473				;inc hl ; skip current double quote 
2473 7e				ld a,(hl) 
2474 23				inc hl 
2475 fe 22			cp '"' 
2477 28 e1			jr z, .ptoken2 
2479 fe 7f			cp FORTH_END_BUFFER 
247b 28 0c			jr z, .ptokendone2 
247d fe 00			cp 0 
247f 28 08			jr z, .ptokendone2 
2481 fe 20			cp ' ' 
2483 28 02			jr z, .ptmp2 
2485 18 ec			jr .ptokenstr2 
2487			 
2487			.ptmp2:	; we have a space so change to zero term for dict match later 
2487				;dec hl 
2487				;ld a,"-"	; TODO remove this when working 
2487				;ld (hl), a 
2487				;inc hl 
2487 18 ea			jr .ptokenstr2 
2489			 
2489			.ptokendone2: 
2489				;inc hl 
2489 3e 7f			ld a, FORTH_END_BUFFER 
248b 77				ld (hl),a 
248c 23				inc hl 
248d 3e 21			ld a, '!' 
248f 77				ld (hl),a 
2490			 
2490 2a fd f3			ld hl,(os_tok_ptr) 
2493			         
2493			if DEBUG_FORTH_TOK 
2493						DMARK "TK1" 
2493				CALLMONITOR 
2493			endif 
2493			 
2493				; push exec string to top of return stack 
2493				FORTH_RSP_NEXT 
2493 cd 03 20			call macro_forth_rsp_next 
2496				endm 
# End of macro FORTH_RSP_NEXT
2496 c9				ret 
2497			 
2497			; 
2497			;	; malloc size + buffer pointer + if is loop flag 
2497			;	ld hl,(os_tok_len) 		 ; get string length 
2497			; 
2497			;	ld a,l 
2497			; 
2497			;	cp 0			; we dont want to use a null string 
2497			;	ret z 
2497			; 
2497			;;	add 3    ; prefix malloc with buffer for current word ptr 
2497			; 
2497			;	add 5     ; TODO when certain not over writing memory remove 
2497			; 
2497			;		 
2497			; 
2497			;if DEBUG_FORTH_TOK 
2497			;			DMARK "TKE" 
2497			;	CALLMONITOR 
2497			;endif 
2497			; 
2497			;	ld l,a 
2497			;	ld h,0 
2497			;;	push hl   ; save required space for the copy later 
2497			;	call malloc 
2497			;if DEBUG_FORTH_TOK 
2497			;			DMARK "TKM" 
2497			;	CALLMONITOR 
2497			;endif 
2497			;	if DEBUG_FORTH_MALLOC_GUARD 
2497			;		push af 
2497			;		call ishlzero 
2497			;;		ld a, l 
2497			;;		add h 
2497			;;		cp 0 
2497			;		pop af 
2497			;		 
2497			;		call z,malloc_error 
2497			;	endif 
2497			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2497			; 
2497			; 
2497			;if DEBUG_FORTH_TOK 
2497			;			DMARK "TKR" 
2497			;	CALLMONITOR 
2497			;endif 
2497			; 
2497			;	FORTH_RSP_NEXT 
2497			; 
2497			;	;inc hl	 ; go past current buffer pointer 
2497			;	;inc hl 
2497			;	;inc hl   ; and past if loop flag 
2497			;		; TODO Need to set flag  
2497			; 
2497			;	 
2497			;	 
2497			;	ex de,hl	; malloc is dest 
2497			;	ld hl, (os_tok_len) 
2497			;;	pop bc 
2497			;	ld c, l                
2497			;	ld b,0 
2497			;	ld hl, (os_tok_ptr) 
2497			; 
2497			;if DEBUG_FORTH_TOK 
2497			;			DMARK "TKT" 
2497			;	CALLMONITOR 
2497			;endif 
2497			; 
2497			;	; do str cpy 
2497			; 
2497			;	ldir      ; copy byte in hl to de 
2497			; 
2497			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2497			; 
2497			;if DEBUG_FORTH_TOK 
2497			; 
2497			;			DMARK "TKY" 
2497			;	CALLMONITOR 
2497			;endif 
2497			;	;ld a,0 
2497			;	;ld a,FORTH_END_BUFFER 
2497			;	ex de, hl 
2497			;	;dec hl			 ; go back over the space delim at the end of word 
2497			;	;ld (hl),a 
2497			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2497			;	ld a,FORTH_END_BUFFER 
2497			;	ld (hl),a 
2497			;	inc hl 
2497			;	ld a,FORTH_END_BUFFER 
2497			;	ld (hl),a 
2497			; 
2497			;	; init the malloc area data 
2497			;	; set pc for in current area 
2497			;	;ld hl, (os_tok_malloc) 
2497			;	;inc hl 
2497			;	;inc hl 
2497			;	;inc hl 
2497			;	;ex de,hl 
2497			;	;ld hl, (os_tok_malloc) 
2497			;	;ld (hl),e 
2497			;	;inc hl 
2497			;	;ld (hl),d 
2497			; 
2497			; 
2497			;	ld hl,(os_tok_malloc) 
2497			;if DEBUG_FORTH_PARSE_KEY 
2497			;			DMARK "TKU" 
2497			;	CALLMONITOR 
2497			;endif 
2497			; 
2497			;	ret 
2497			 
2497			forthexec: 
2497			 
2497			; line exec: 
2497			; forth parser 
2497			 
2497			; 
2497			;       get current exec line on rsp 
2497			 
2497				FORTH_RSP_TOS 
2497 cd 1a 20			call macro_forth_rsp_tos 
249a				endm 
# End of macro FORTH_RSP_TOS
249a			 
249a			;       restore current pc - hl points to malloc of data 
249a			 
249a				;ld e, (hl) 
249a				;inc hl 
249a				;ld d, (hl) 
249a				;ex de,hl 
249a			 
249a			 
249a			exec1: 
249a 22 fd f3			ld (os_tok_ptr), hl 
249d			 
249d				; copy our PC to working vars  
249d 22 7b f9			ld (cli_ptr), hl 
24a0 22 79 f9			ld (cli_origptr), hl 
24a3			 
24a3 7e				ld a,(hl) 
24a4 fe 7f			cp FORTH_END_BUFFER 
24a6 c8				ret z 
24a7			 
24a7				; skip any nulls 
24a7			 
24a7 fe 00			cp 0 
24a9 20 03			jr nz, .execword 
24ab 23				inc hl 
24ac 18 ec			jr exec1 
24ae			 
24ae			 
24ae			.execword: 
24ae			 
24ae			 
24ae			 
24ae			if DEBUG_FORTH_PARSE_KEY 
24ae						DMARK "KYQ" 
24ae				CALLMONITOR 
24ae			endif 
24ae			;       while at start of word: 
24ae			; get start of dict (in user area first) 
24ae			 
24ae 21 00 80		ld hl, baseram 
24b1			;ld hl, sysdict 
24b1 22 7d f9		ld (cli_nextword),hl 
24b4			;           match word at pc 
24b4			;           exec word 
24b4			;           or push to dsp 
24b4			;           forward to next token 
24b4			;           if line term pop rsp and exit 
24b4			;        
24b4			 
24b4			if DEBUG_FORTH_PARSE_KEY 
24b4						DMARK "KYq" 
24b4				CALLMONITOR 
24b4			endif 
24b4			 
24b4			; 
24b4			; word comp 
24b4			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
24b4			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
24b4			;    move to start of word  
24b4			;    compare word to cli_token 
24b4			 
24b4			.execpnword:	; HL at start of a word in the dictionary to check 
24b4			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
24b4			;	ld (cli_ptr), hl 
24b4			 
24b4 2a 7d f9			ld hl,(cli_nextword) 
24b7			 
24b7 cd 5a 25			call forth_tok_next 
24ba			; tok next start here 
24ba			;	; TODO skip compiled symbol for now 
24ba			;	inc hl 
24ba			; 
24ba			;	; save pointer to next word 
24ba			; 
24ba			;	; hl now points to the address of the next word pointer  
24ba			;	ld e, (hl) 
24ba			;	inc hl 
24ba			;	ld d, (hl) 
24ba			;	inc l 
24ba			; 
24ba			;	ex de,hl 
24ba			;if DEBUG_FORTH_PARSE_NEXTWORD 
24ba			;	push bc 
24ba			;	ld bc, (cli_nextword) 
24ba			;			DMARK "NXW" 
24ba			;	CALLMONITOR 
24ba			;	pop bc 
24ba			;endif 
24ba			; tok next end here 
24ba 22 7d f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
24bd eb				ex de, hl 
24be			 
24be			 
24be				; save the pointer of the current token - 1 to check against 
24be				 
24be 22 81 f9			ld (cli_token), hl   
24c1				; TODO maybe remove below save if no debug 
24c1				; save token string ptr for any debug later 
24c1 23				inc hl  
24c2 22 83 f9			ld (cli_origtoken), hl 
24c5 2b				dec hl 
24c6				; save pointer to the start of the next dictionay word 
24c6 7e				ld a,(hl)   ; get string length 
24c7 47				ld b,a 
24c8			.execpnwordinc:  
24c8 23				inc hl 
24c9 10 fd			djnz .execpnwordinc 
24cb 22 7f f9			ld (cli_execword), hl      ; save start of this words code 
24ce			 
24ce				; now check the word token against the string being parsed 
24ce			 
24ce 2a 81 f9			ld hl,(cli_token) 
24d1 23				inc hl     ; skip string length (use zero term instead to end) 
24d2 22 81 f9			ld (cli_token), hl 
24d5			 
24d5			if DEBUG_FORTH_PARSE_KEY 
24d5						DMARK "KY2" 
24d5			endif 
24d5			if DEBUG_FORTH_PARSE_EXEC 
24d5				; see if disabled 
24d5			 
24d5			;	ld a, (os_view_disable) 
24d5			;	cp '*' 
24d5				ld a, (debug_vector) 
24d5				cp $c9   ; RET  
24d5				jr z, .skip 
24d5			 
24d5				push hl 
24d5				push hl 
24d5				call clear_display 
24d5				ld de, .compword 
24d5				ld a, display_row_1 
24d5				call str_at_display 
24d5				pop de 
24d5				ld a, display_row_2 
24d5				call str_at_display 
24d5				ld hl,(cli_ptr) 
24d5				ld a,(hl) 
24d5			        ld hl, os_word_scratch 
24d5				ld (hl),a 
24d5				ld a,0 
24d5				inc hl 
24d5				ld (hl),a 	 
24d5				ld de, os_word_scratch 
24d5				ld a, display_row_2+10 
24d5				call str_at_display 
24d5				call update_display 
24d5				ld a, 100 
24d5				call aDelayInMS 
24d5				if DEBUG_FORTH_PARSE_EXEC_SLOW 
24d5				call delay250ms 
24d5				endif 
24d5				pop hl 
24d5			.skip:  
24d5			endif	 
24d5			.execpnchar:    ; compare char between token and string to parse 
24d5			 
24d5			if DEBUG_FORTH_PARSE_KEY 
24d5						DMARK "Ky3" 
24d5			endif 
24d5			if DEBUG_FORTH_PARSE_EXEC 
24d5				; see if disabled 
24d5			 
24d5			;	ld a, (os_view_disable) 
24d5			;	cp '*' 
24d5				ld a, (debug_vector) 
24d5				cp $C9  ; RET 
24d5				jr z, .skip2 
24d5			 
24d5			;	call clear_display 
24d5			ld hl,(cli_token) 
24d5			ld a,(hl) 
24d5			ld (os_word_scratch),a 
24d5				ld hl,(cli_ptr) 
24d5			ld a,(hl) 
24d5				ld (os_word_scratch+1),a 
24d5				ld a,0 
24d5				ld (os_word_scratch+2),a 
24d5				ld de,os_word_scratch 
24d5				ld a,display_row_4 
24d5				call str_at_display 
24d5				call update_display 
24d5			.skip2:  
24d5			endif 
24d5 2a 81 f9			ld hl,(cli_token) 
24d8 7e				ld a, (hl)	 ; char in word token 
24d9 23				inc hl 		; move to next char 
24da 22 81 f9			ld (cli_token), hl ; and save it 
24dd 47				ld b,a 
24de			 
24de 2a 7b f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
24e1 7e				ld a,(hl) 
24e2 23				inc hl 
24e3 22 7b f9			ld (cli_ptr), hl		; move to next char 
24e6 cd 7d 13			call toUpper 		; make sure the input string matches case 
24e9			 
24e9			if DEBUG_FORTH_PARSE 
24e9			endif 
24e9			 
24e9				; input stream end of token is a space so get rid of it 
24e9			 
24e9			;	cp ' ' 
24e9			;	jr nz, .pnskipspace 
24e9			; 
24e9			;	ld a, 0		; make same term as word token term 
24e9			; 
24e9			;.pnskipspace: 
24e9			 
24e9			if DEBUG_FORTH_PARSE_KEY 
24e9						DMARK "KY7" 
24e9			endif 
24e9 b8				cp b 
24ea c2 00 25			jp nz, .execpnskipword	 ; no match so move to next word 
24ed				 
24ed			;    if same 
24ed			;       scan for string terms 0 for token and 32 for input 
24ed			 
24ed				 
24ed			if DEBUG_FORTH_PARSE_KEY 
24ed						DMARK "KY8" 
24ed			endif 
24ed			 
24ed 80				add b			 
24ee fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
24f0							; TODO need to make sure last word in zero term string is accounted for 
24f0 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
24f2			 
24f2			 
24f2				; at end of both strings so both are exact match 
24f2			 
24f2			;       skip ptr for next word 
24f2			 
24f2 2a 7b f9			ld hl,(cli_ptr) 	; at input string term 
24f5 23				inc hl			 ; at next char 
24f6 22 7b f9			ld (cli_ptr), hl     ; save for next round of the parser 
24f9 22 79 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
24fc				 
24fc				 
24fc			if DEBUG_FORTH_PARSE_KEY 
24fc						DMARK "KY3" 
24fc			endif 
24fc			 
24fc			 
24fc			 
24fc			;       exec code block 
24fc			if DEBUG_FORTH_JP 
24fc				call clear_display 
24fc				call update_display 
24fc				call delay1s 
24fc				ld hl, (cli_execword)     ; save for next check if no match on this word 
24fc				ld a,h 
24fc				ld hl, os_word_scratch 
24fc				call hexout 
24fc				ld hl, (cli_execword)     ; save for next check if no match on this word 
24fc				ld a,l 
24fc				ld hl, os_word_scratch+2 
24fc				call hexout 
24fc				ld hl, os_word_scratch+4 
24fc				ld a,0 
24fc				ld (hl),a 
24fc				ld de,os_word_scratch 
24fc				call str_at_display 
24fc					ld a, display_row_2 
24fc					call str_at_display 
24fc				ld de, (cli_origtoken) 
24fc				ld a, display_row_1+10 
24fc					call str_at_display 
24fc			 
24fc				ld a,display_row_1 
24fc				ld de, .foundword 
24fc				ld a, display_row_3 
24fc				call str_at_display 
24fc				call update_display 
24fc				call delay1s 
24fc				call delay1s 
24fc				call delay1s 
24fc			endif 
24fc			 
24fc			if DEBUG_FORTH_PARSE_KEY 
24fc						DMARK "KYj" 
24fc			endif 
24fc				; TODO save the word pointer in this exec 
24fc			 
24fc 2a 7f f9			ld hl,(cli_execword) 
24ff e9				jp (hl) 
2500			 
2500			 
2500			;    if not same 
2500			;	scan for zero term 
2500			;	get ptr for next word 
2500			;	goto word comp 
2500			 
2500			.execpnskipword:	; get pointer to next word 
2500 2a 7d f9			ld hl,(cli_nextword) 
2503			 
2503 7e				ld a,(hl) 
2504 fe 00			cp WORD_SYS_END 
2506			;	cp 0 
2506 28 09			jr z, .execendofdict			 ; at end of words 
2508			 
2508			if DEBUG_FORTH_PARSE_KEY 
2508						DMARK "KY4" 
2508			endif 
2508			if DEBUG_FORTH_PARSE_EXEC 
2508			 
2508				; see if disabled 
2508			 
2508			;	ld a, (os_view_disable) 
2508			;	cp '*' 
2508				ld a,(debug_vector) 
2508				cp $c9   ; RET 
2508				jr z, .noskip 
2508			 
2508			 
2508				ld de, .nowordfound 
2508				ld a, display_row_3 
2508				call str_at_display 
2508				call update_display 
2508				ld a, 100 
2508				call aDelayInMS 
2508				 
2508				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2508					call delay250ms 
2508				endif 
2508			.noskip:  
2508			 
2508			endif	 
2508			 
2508 2a 79 f9			ld hl,(cli_origptr) 
250b 22 7b f9			ld (cli_ptr),hl 
250e			 
250e			if DEBUG_FORTH_PARSE_KEY 
250e						DMARK "KY5" 
250e			endif 
250e c3 b4 24			jp .execpnword			; else go to next word 
2511			 
2511			.execendofdict:  
2511			 
2511			if DEBUG_FORTH_PARSE_KEY 
2511						DMARK "KYe" 
2511			endif 
2511			if DEBUG_FORTH_PARSE_EXEC 
2511				; see if disabled 
2511			 
2511			;	ld a, (os_view_disable) 
2511			;	cp '*' 
2511				ld a,(debug_vector) 
2511				cp $c9   ; ret 
2511				jr z, .ispskip 
2511			 
2511				call clear_display 
2511				call update_display 
2511				call delay1s 
2511				ld de, (cli_origptr) 
2511				ld a, display_row_1 
2511				call str_at_display 
2511				 
2511				ld de, .enddict 
2511				ld a, display_row_3 
2511				call str_at_display 
2511				call update_display 
2511				ld a, 100 
2511				call aDelayInMS 
2511				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2511				call delay1s 
2511				call delay1s 
2511				call delay1s 
2511				endif 
2511			.ispskip:  
2511				 
2511			endif	 
2511			 
2511			 
2511			 
2511				; if the word is not a keyword then must be a literal so push it to stack 
2511			 
2511			; push token to stack to end of word 
2511			 
2511				STACKFRAME ON $1efe $2f9f 
2511				if DEBUG_STACK_IMB 
2511					if ON 
2511						exx 
2511						ld de, $1efe 
2511						ld a, d 
2511						ld hl, curframe 
2511						call hexout 
2511						ld a, e 
2511						ld hl, curframe+2 
2511						call hexout 
2511						ld hl, $1efe 
2511						push hl 
2511						ld hl, $2f9f 
2511						push hl 
2511						exx 
2511					endif 
2511				endif 
2511			endm 
# End of macro STACKFRAME
2511			 
2511 2a fd f3		ld hl,(os_tok_ptr) 
2514 cd c5 21		call forth_apush 
2517			 
2517				STACKFRAMECHK ON $1efe $2f9f 
2517				if DEBUG_STACK_IMB 
2517					if ON 
2517						exx 
2517						ld hl, $2f9f 
2517						pop de   ; $2f9f 
2517						call cmp16 
2517						jr nz, .spnosame 
2517						ld hl, $1efe 
2517						pop de   ; $1efe 
2517						call cmp16 
2517						jr z, .spfrsame 
2517						.spnosame: call showsperror 
2517						.spfrsame: nop 
2517						exx 
2517					endif 
2517				endif 
2517			endm 
# End of macro STACKFRAMECHK
2517			 
2517			execnext: 
2517			 
2517			if DEBUG_FORTH_PARSE_KEY 
2517						DMARK "KY>" 
2517			endif 
2517			; move past token to next word 
2517			 
2517 2a fd f3		ld hl, (os_tok_ptr) 
251a 3e 00		ld a, 0 
251c 01 ff 00		ld bc, 255     ; input buffer size 
251f ed b1		cpir 
2521			 
2521			if DEBUG_FORTH_PARSE_KEY 
2521						DMARK "KY!" 
2521				CALLMONITOR 
2521			endif	 
2521			; TODO this might place hl on the null, so will need to forward on??? 
2521			;inc hl   ; see if this gets onto the next item 
2521			 
2521			 
2521			; TODO pass a pointer to the buffer to push 
2521			; TODO call function to push 
2521			 
2521			; look for end of input 
2521			 
2521			;inc hl 
2521			;ld a,(hl) 
2521			;cp FORTH_END_BUFFER 
2521			;ret z 
2521			 
2521			 
2521 c3 9a 24		jp exec1 
2524			 
2524			 
2524			 
2524			 
2524			 
2524			 
2524			 
2524			 
2524			 
2524			findnexttok: 
2524			 
2524				; hl is pointer to move 
2524				; de is the token to locate 
2524			 
2524					if DEBUG_FORTH 
2524						DMARK "NTK" 
2524						CALLMONITOR 
2524					endif 
2524 d5				push de 
2525			 
2525			.fnt1:	 
2525				; find first char of token to locate 
2525			 
2525 1a				ld a, (de) 
2526 4f				ld c,a 
2527 7e				ld a,(hl) 
2528 cd 7d 13			call toUpper 
252b					if DEBUG_FORTH 
252b						DMARK "NT1" 
252b						CALLMONITOR 
252b					endif 
252b b9				cp c 
252c			 
252c 28 03			jr z, .fnt2cmpmorefirst	 
252e			 
252e				; first char not found move to next char 
252e			 
252e 23				inc hl 
252f 18 f4			jr .fnt1 
2531			 
2531			.fnt2cmpmorefirst:	 
2531				; first char of token found.  
2531			 
2531 e5				push hl     ; save start of token just in case it is the right one 
2532 d9				exx 
2533 e1				pop hl        ; save it to hl' 
2534 d9				exx 
2535			 
2535			 
2535			.fnt2cmpmore:	 
2535				; compare the rest 
2535				 
2535 23				inc hl 
2536 13				inc de 
2537				 
2537 1a				ld a, (de) 
2538 4f				ld c,a 
2539 7e				ld a,(hl) 
253a cd 7d 13			call toUpper 
253d			 
253d					if DEBUG_FORTH 
253d						DMARK "NT2" 
253d						CALLMONITOR 
253d					endif 
253d				; c has the token to find char 
253d				; a has the mem to scan char 
253d			 
253d b9				cp c 
253e 28 04			jr z,.fntmatch1 
2540			 
2540				; they are not the same 
2540			 
2540					if DEBUG_FORTH 
2540						DMARK "NT3" 
2540						CALLMONITOR 
2540					endif 
2540 d1				pop de	; reset de token to look for 
2541 d5				push de 
2542 18 e1			jr .fnt1 
2544				 
2544			.fntmatch1: 
2544			 
2544				; is the same char a null which means we might have a full hit? 
2544					if DEBUG_FORTH 
2544						DMARK "NT4" 
2544						CALLMONITOR 
2544					endif 
2544			 
2544 fe 00			cp 0 
2546 28 0b			jr z, .fntmatchyes 
2548			 
2548				; are we at the end of the token to find? 
2548			 
2548					if DEBUG_FORTH 
2548						DMARK "NT5" 
2548						CALLMONITOR 
2548					endif 
2548 3e 00			ld a, 0 
254a b9				cp c 
254b			 
254b c2 35 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
254e			 
254e					if DEBUG_FORTH 
254e						DMARK "NT6" 
254e						CALLMONITOR 
254e					endif 
254e				; token to find is exhusted but no match to stream 
254e			 
254e				; restore tok pointer and continue on 
254e d1				pop de 
254f d5				push de 
2550 c3 25 25			jp .fnt1 
2553			 
2553			 
2553			.fntmatchyes: 
2553			 
2553				; hl now contains the end of the found token 
2553			 
2553				; get rid of saved token pointer to find 
2553			 
2553 d1				pop de 
2554			 
2554					if DEBUG_FORTH 
2554						DMARK "NT9" 
2554						CALLMONITOR 
2554					endif 
2554			 
2554				; hl will be on the null term so forward on 
2554			 
2554				; get back the saved start of the token 
2554			 
2554 d9				exx 
2555 e5				push hl     ; save start of token just in case it is the right one 
2556 d9				exx 
2557 e1				pop hl        ; save it to hl 
2558			 
2558 c9				ret 
2559			 
2559			 
2559			; LIST needs to find a specific token   
2559			; FORGET needs to find a spefici token 
2559			 
2559			; SAVE needs to find all tokens by flag 
2559			; WORDS just needs to scan through all  by flag 
2559			; UWORDS needs to scan through all by flag 
2559			 
2559			 
2559			; given hl as pointer to start of dict look up string 
2559			; return hl as pointer to start of word block 
2559			; or 0 if not found 
2559			 
2559			forth_find_tok: 
2559 c9				ret 
255a			 
255a			; given hl as pointer to dict structure 
255a			; move to the next dict block structure 
255a			 
255a			forth_tok_next: 
255a				; hl now points to the address of the next word pointer  
255a				; TODO skip compiled symbol for now 
255a			;	push de 
255a 23				inc hl 
255b 5e				ld e, (hl) 
255c 23				inc hl 
255d 56				ld d, (hl) 
255e 23				inc hl 
255f			 
255f eb				ex de,hl 
2560			if DEBUG_FORTH_PARSE_NEXTWORD 
2560				push bc 
2560				ld bc, (cli_nextword) 
2560						DMARK "NXW" 
2560				CALLMONITOR 
2560				pop bc 
2560			endif 
2560			;	pop de	 
2560 c9				ret 
2561			 
2561			 
2561			 
2561			; eof 
# End of file forth_parserv5.asm
2561				include "forth_wordsv4.asm" 
2561			 
2561			; the core word dictionary v4 
2561			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2561			 
2561			; this is a linked list for each of the system words used 
2561			; user defined words will follow the same format but will be in ram 
2561			 
2561			 
2561			; 
2561			; 
2561			; define linked list: 
2561			; 
2561			; 1. compiled byte op code 
2561			; 2. len of text word 
2561			; 3. text word 
2561			; 4. ptr to next dictionary word 
2561			; 5. asm, calls etc for the word 
2561			; 
2561			;  if 1 == 0 then last word in dict  
2561			;   
2561			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2561			;  
2561			;  
2561			; create basic standard set of words 
2561			; 
2561			;  
2561			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2561			; 2DUP 2DROP 2SWAP  
2561			; @ C@ - get byte  
2561			; ! C! - store byte 
2561			; 0< true if less than zero 
2561			; 0= true if zero 
2561			; < >  
2561			; = true if same 
2561			; variables 
2561			 
2561			 
2561			; Hardware specific words I may need 
2561			; 
2561			; IN OUT  
2561			; calls to key util functions 
2561			; calls to hardward abstraction stuff 
2561			; easy control of frame buffers and lcd i/o 
2561			; keyboard  
2561			 
2561			 
2561			;DICT: macro 
2561			; op_code, len, word, next 
2561			;    word: 
2561			;    db op_code 
2561			;    ds word zero term 
2561			;    dw next 
2561			;    endm 
2561			 
2561			 
2561			 
2561			 
2561			; op code 1 is a flag for user define words which are to be handled differently 
2561			 
2561			 
2561			; 
2561			; 
2561			;    TODO on entry to a word this should be the expected environment 
2561			;    hl - tos value if number then held, if string this is the ptr 
2561			;    de -  
2561			 
2561			 
2561			; opcode ranges 
2561			; 0 - end of word dict 
2561			; 255 - user define words 
2561			 
2561			sysdict: 
2561			include "forth_opcodes.asm" 
2561			; op codes for forth keywords 
2561			; free to use code 0  
2561				OPCODE_HEAP: equ  1 
2561				OPCODE_EXEC: equ 2 
2561				OPCODE_DUP: equ 3 
2561				OPCODE_SWAP: equ 4 
2561				OPCODE_COLN: equ 5 
2561				OPCODE_SCOLN: equ 6 
2561				OPCODE_DROP: equ 7 
2561				OPCODE_DUP2: equ 8 
2561				OPCODE_DROP2: equ 9 
2561				OPCODE_SWAP2: equ 10 
2561				OPCODE_AT: equ 11 
2561				OPCODE_CAT: equ 12 
2561				OPCODE_BANG: equ 13 
2561				OPCODE_CBANG: equ 14 
2561				OPCODE_SCALL: equ 15 
2561				OPCODE_DEPTH: equ 16 
2561				OPCODE_OVER: equ 17 
2561				OPCODE_PAUSE: equ 18 
2561				OPCODE_PAUSES: equ 19 
2561				OPCODE_ROT: equ 20 
2561			;free to reuse	OPCODE_WORDS: equ 21 
2561			        OPCODE_NOT: equ 21 
2561				OPCODE_UWORDS: equ 22 
2561				OPCODE_BP: equ 23 
2561				OPCODE_MONITOR: equ 24  
2561				OPCODE_MALLOC: equ 25 
2561				OPCODE_FREE: equ 26 
2561				OPCODE_LIST: equ 27 
2561				OPCODE_FORGET: equ 28 
2561				OPCODE_NOP: equ 29 
2561				OPCODE_COMO: equ 30 
2561				OPCODE_COMC: equ 31 
2561			;free to reuse	OPCODE_ENDCORE: equ 32 
2561				OPCODE_AFTERSOUND: equ 33 
2561				OPCODE_GP2: equ 34 
2561				OPCODE_GP3: equ 35 
2561				OPCODE_GP4: equ 36 
2561				OPCODE_SIN: equ 37 
2561				OPCODE_SOUT: equ 38 
2561				OPCODE_SPIO: equ 39 
2561				OPCODE_SPICEH: equ 40 
2561				OPCODE_SPIOb: equ 41 
2561				OPCODE_SPII: equ 42 
2561				OPCODE_SESEL: equ 43 
2561				OPCODE_CARTDEV: equ 44 
2561			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2561				OPCODE_FB: equ 46 
2561				OPCODE_EMIT: equ 47 
2561				OPCODE_DOTH: equ 48 
2561				OPCODE_DOTF: equ 49 
2561				OPCODE_DOT: equ 50 
2561				OPCODE_CLS: equ 51 
2561				OPCODE_DRAW: equ 52 
2561				OPCODE_DUMP: equ 53 
2561				OPCODE_CDUMP: equ 54 
2561				OPCODE_DAT: equ 55 
2561				OPCODE_HOME: equ 56 
2561				OPCODE_SPACE: equ 57 
2561				OPCODE_SPACES: equ 58 
2561				OPCODE_SCROLL: equ 59 
2561				OPCODE_ATQ: equ 60 
2561				OPCODE_AUTODSP: equ 61 
2561				OPCODE_MENU: equ 62 
2561			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2561				OPCODE_THEN: equ 64 
2561				OPCODE_ELSE: equ 65 
2561				OPCODE_DO: equ 66 
2561				OPCODE_LOOP: equ 67 
2561				OPCODE_I: equ 68 
2561				OPCODE_DLOOP: equ 69  
2561				OPCODE_REPEAT: equ 70  
2561				OPCODE_UNTIL: equ 71 
2561				OPCODE_ENDFLOW: equ 72 
2561				OPCODE_WAITK: equ 73 
2561				OPCODE_ACCEPT: equ 74 
2561				OPCODE_EDIT: equ 75 
2561			;free to reuse	OPCODE_ENDKEY: equ 76 
2561				OPCODE_LZERO: equ 77 
2561				OPCODE_TZERO: equ 78 
2561				OPCODE_LESS: equ 79 
2561				OPCODE_GT: equ 80 
2561				OPCODE_EQUAL: equ 81  
2561			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2561				OPCODE_NEG: equ 83 
2561				OPCODE_DIV: equ 84 
2561				OPCODE_MUL: equ 85 
2561				OPCODE_MIN: equ 86 
2561				OPCODE_MAX: equ 87 
2561				OPCODE_RND16: equ 88 
2561				OPCODE_RND8: equ 89 
2561				OPCODE_RND: equ 90 
2561			;free to reuse	OPCODE_ENDMATHS: equ 91  
2561				OPCODE_BYNAME: equ 92 
2561				OPCODE_DIR: equ 93 
2561				OPCODE_SAVE: equ 94 
2561				OPCODE_LOAD: equ 95 
2561				OPCODE_BSAVE: equ 96 
2561				OPCODE_BLOAD: equ 97 
2561				OPCODE_SEO: equ 98  
2561				OPCODE_SEI: equ 99 
2561				OPCODE_SFREE: equ 100 
2561				OPCODE_SIZE: equ 101 
2561				OPCODE_CREATE: equ 102 
2561				OPCODE_APPEND: equ 103 
2561				OPCODE_SDEL: equ 104 
2561				OPCODE_OPEN: equ 105 
2561				OPCODE_READ: equ 106 
2561				OPCODE_EOF: equ 106 
2561				OPCODE_FORMAT: equ 107 
2561				OPCODE_LABEL: equ 108 
2561				OPCODE_LABELS: equ 109 
2561			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2561				OPCODE_UPPER: equ 111 
2561				OPCODE_LOWER: equ 112 
2561				OPCODE_SUBSTR: equ 113 
2561				OPCODE_LEFT: equ 114 
2561				OPCODE_RIGHT: equ 115 
2561				OPCODE_STR2NUM: equ 116 
2561				OPCODE_NUM2STR: equ 117 
2561				OPCODE_CONCAT: equ 118 
2561				OPCODE_FIND: equ 119 
2561				OPCODE_LEN: equ 120 
2561				OPCODE_CHAR: equ 121 
2561			; free to reuse	OPCODE_STRLEN: equ 122 
2561			; free to reuse	OPCODE_ENDSTR: equ 123 
2561				OPCODE_V0S: equ 124 
2561				OPCODE_V0Q: equ 125 
2561				OPCODE_V1S: equ 126 
2561				OPCODE_V1Q: equ 127 
2561				OPCODE_V2S: equ 128 
2561				OPCODE_V2Q: equ 129 
2561				OPCODE_V3S: equ 130 
2561				OPCODE_V3Q: equ 131 
2561			;free to reuse	OPCODE_END: equ 132 
2561				OPCODE_ZDUP: equ 133 
2561			 
2561			; eof 
# End of file forth_opcodes.asm
2561			 
2561			include "forth_words_core.asm" 
2561			 
2561			; | ## Core Words 
2561			 
2561			;if MALLOC_4 
2561			 
2561			.HEAP: 
2561			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2561 15				db WORD_SYS_CORE+OPCODE_HEAP             
2562 a0 25			dw .EXEC            
2564 05				db 4 + 1 
2565 .. 00			db "HEAP",0              
256a				endm 
# End of macro CWHEAD
256a			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
256a			; | | u1 - Current number of bytes in the heap 
256a			; | | u2 - Remaining bytes left on the heap 
256a			; | |  
256a			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
256a			 
256a			 
256a				if DEBUG_FORTH_WORDS_KEY 
256a					DMARK "HEP" 
256a f5				push af  
256b 3a 7f 25			ld a, (.dmark)  
256e 32 a6 fd			ld (debug_mark),a  
2571 3a 80 25			ld a, (.dmark+1)  
2574 32 a7 fd			ld (debug_mark+1),a  
2577 3a 81 25			ld a, (.dmark+2)  
257a 32 a8 fd			ld (debug_mark+2),a  
257d 18 03			jr .pastdmark  
257f ..			.dmark: db "HEP"  
2582 f1			.pastdmark: pop af  
2583			endm  
# End of macro DMARK
2583					CALLMONITOR 
2583 cd aa fd			call debug_vector  
2586				endm  
# End of macro CALLMONITOR
2586				endif 
2586 2a 0a 80			ld hl, (free_list )      
2589 11 0e 80			ld de, heap_start 
258c			 
258c ed 52			sbc hl, de  
258e			 
258e cd 5c 20			call forth_push_numhl 
2591			 
2591			 
2591 ed 5b 0a 80		ld de, (free_list )      
2595 21 d7 f0			ld hl, heap_end 
2598			 
2598 ed 52			sbc hl, de 
259a			 
259a cd 5c 20			call forth_push_numhl 
259d				 
259d			 
259d				 
259d			 
259d			 
259d			 
259d				NEXTW 
259d c3 09 24			jp macro_next 
25a0				endm 
# End of macro NEXTW
25a0			;endif 
25a0			 
25a0			.EXEC: 
25a0			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
25a0			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
25a0			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
25a0			;; > > 
25a0			;; > >   
25a0			;	STACKFRAME OFF $5efe $5f9f 
25a0			; 
25a0			;		if DEBUG_FORTH_WORDS_KEY 
25a0			;			DMARK "EXE" 
25a0			;			CALLMONITOR 
25a0			;		endif 
25a0			; 
25a0			;	FORTH_DSP_VALUEHL 
25a0			; 
25a0			;	FORTH_DSP_POP 
25a0			; 
25a0			;		if DEBUG_FORTH_WORDS 
25a0			;			DMARK "EX1" 
25a0			;			CALLMONITOR 
25a0			;		endif 
25a0			;;	ld e,(hl) 
25a0			;;	inc hl 
25a0			;;	ld d,(hl) 
25a0			;;	ex de,hl 
25a0			; 
25a0			;;		if DEBUG_FORTH_WORDS 
25a0			;;			DMARK "EX2" 
25a0			;;			CALLMONITOR 
25a0			;;		endif 
25a0			;	push hl 
25a0			; 
25a0			;	;ld a, 0 
25a0			;	;ld a, FORTH_END_BUFFER 
25a0			;	call strlenz 
25a0			;	inc hl   ; include zero term to copy 
25a0			;	inc hl   ; include term 
25a0			;	inc hl   ; include term 
25a0			;	ld b,0 
25a0			;	ld c,l 
25a0			;	pop hl 
25a0			;	ld de, execscratch 
25a0			;		if DEBUG_FORTH_WORDS 
25a0			;			DMARK "EX3" 
25a0			;			CALLMONITOR 
25a0			;		endif 
25a0			;	ldir 
25a0			; 
25a0			; 
25a0			;	ld hl, execscratch 
25a0			; 
25a0			;		if DEBUG_FORTH_WORDS 
25a0			;			DMARK "EXe" 
25a0			;			CALLMONITOR 
25a0			;		endif 
25a0			; 
25a0			;	call forthparse 
25a0			;	call forthexec 
25a0			;;	call forthexec_cleanup 
25a0			;;	call forthparse 
25a0			;;	call forthexec 
25a0			; 
25a0			;	STACKFRAMECHK OFF $5efe $5f9f 
25a0			; 
25a0			;	; an immediate word so no need to process any more words 
25a0			;	ret 
25a0			;	NEXTW 
25a0			 
25a0			; dead code - old version  
25a0			;	FORTH_RSP_NEXT 
25a0			 
25a0			;  
25a0			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
25a0			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
25a0			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
25a0			;	push hl 
25a0			;	push de 
25a0			;	push bc 
25a0			; 
25a0			; 
25a0			;		if DEBUG_FORTH_WORDS_KEY 
25a0			;			DMARK "EXR" 
25a0			;			CALLMONITOR 
25a0			;		endif 
25a0			; 
25a0			; 
25a0			; 
25a0			;	;v5 FORTH_DSP_VALUE 
25a0			;	FORTH_DSP_VALUEHL 
25a0			; 
25a0			;	; TODO do string type checks 
25a0			; 
25a0			;;v5	inc hl   ; skip type 
25a0			; 
25a0			;	push hl  ; source code  
25a0			;		if DEBUG_FORTH_WORDS 
25a0			;			DMARK "EX1" 
25a0			;			CALLMONITOR 
25a0			;		endif 
25a0			;	ld a, 0 
25a0			;	call strlent 
25a0			; 
25a0			;	inc hl 
25a0			;	inc hl 
25a0			;	inc hl 
25a0			;	inc hl 
25a0			; 
25a0			;	push hl    ; size 
25a0			; 
25a0			;		if DEBUG_FORTH_WORDS 
25a0			;			DMARK "EX2" 
25a0			;			CALLMONITOR 
25a0			;		endif 
25a0			;	call malloc 
25a0			; 
25a0			;	ex de, hl    ; de now contains malloc area 
25a0			;	pop bc   	; get byte count 
25a0			;	pop hl      ; get string to copy 
25a0			; 
25a0			;	push de     ; save malloc for free later 
25a0			; 
25a0			;		if DEBUG_FORTH_WORDS 
25a0			;			DMARK "EX3" 
25a0			;			CALLMONITOR 
25a0			;		endif 
25a0			;	ldir       ; duplicate string 
25a0			; 
25a0			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
25a0			;	 
25a0			;	; TODO fix the parse would be better than this...  
25a0			;	ex de, hl 
25a0			;	dec hl 
25a0			;	ld a, 0 
25a0			;	ld (hl), a 
25a0			;	dec hl 
25a0			;	ld a, ' ' 
25a0			;	ld (hl), a 
25a0			;	dec hl 
25a0			;	ld (hl), a 
25a0			; 
25a0			;	dec hl 
25a0			;	ld (hl), a 
25a0			; 
25a0			; 
25a0			;	FORTH_DSP_POP  
25a0			; 
25a0			;	pop hl     
25a0			;	push hl    ; save malloc area 
25a0			; 
25a0			;		if DEBUG_FORTH_WORDS 
25a0			;			DMARK "EX4" 
25a0			;			CALLMONITOR 
25a0			;		endif 
25a0			; 
25a0			;	call forthparse 
25a0			;	call forthexec 
25a0			;	 
25a0			;	pop hl 
25a0			;	if DEBUG_FORTH_WORDS 
25a0			;		DMARK "EX5" 
25a0			;		CALLMONITOR 
25a0			;	endif 
25a0			; 
25a0			;	if FORTH_ENABLE_FREE 
25a0			;	call free 
25a0			;	endif 
25a0			; 
25a0			;	if DEBUG_FORTH_WORDS 
25a0			;		DMARK "EX6" 
25a0			;		CALLMONITOR 
25a0			;	endif 
25a0			; 
25a0			;	pop bc 
25a0			;	pop de 
25a0			;	pop hl 
25a0			;;	FORTH_RSP_POP	  
25a0			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
25a0			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
25a0			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
25a0			; 
25a0			;	if DEBUG_FORTH_WORDS 
25a0			;		DMARK "EX7" 
25a0			;		CALLMONITOR 
25a0			;	endif 
25a0			;	NEXTW 
25a0			 
25a0			;.STKEXEC: 
25a0			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
25a0			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
25a0			; 
25a0			; 
25a0			;		if DEBUG_FORTH_WORDS_KEY 
25a0			;			DMARK "STX" 
25a0			;			CALLMONITOR 
25a0			;		endif 
25a0			; 
25a0			;	FORTH_DSP_VALUEHL 
25a0			; 
25a0			;	ld (store_tmp1), hl    ; count 
25a0			; 
25a0			;	FORTH_DSP_POP 
25a0			;.stkexec1: 
25a0			;	ld hl, (store_tmp1)   ; count 
25a0			;	ld a, 0 
25a0			;	cp l 
25a0			;	ret z 
25a0			; 
25a0			;	dec hl 
25a0			;	ld (store_tmp1), hl    ; count 
25a0			;	 
25a0			;	FORTH_DSP_VALUEHL 
25a0			;	push hl 
25a0			;	 
25a0			;		if DEBUG_FORTH_WORDS 
25a0			;			DMARK "EXp" 
25a0			;			CALLMONITOR 
25a0			;		endif 
25a0			;	FORTH_DSP_POP 
25a0			; 
25a0			;	call strlenz 
25a0			;	inc hl   ; include zero term to copy 
25a0			;	inc hl   ; include zero term to copy 
25a0			;	inc hl   ; include zero term to copy 
25a0			;	ld b,0 
25a0			;	ld c,l 
25a0			;	pop hl 
25a0			;	ld de, execscratch 
25a0			;		if DEBUG_FORTH_WORDS 
25a0			;			DMARK "EX3" 
25a0			;			CALLMONITOR 
25a0			;		endif 
25a0			;	ldir 
25a0			; 
25a0			; 
25a0			;	ld hl, execscratch 
25a0			; 
25a0			;		if DEBUG_FORTH_WORDS 
25a0			;			DMARK "EXP" 
25a0			;			CALLMONITOR 
25a0			;		endif 
25a0			; 
25a0			;	call forthparse 
25a0			;	ld hl, execscratch 
25a0			;		if DEBUG_FORTH_WORDS 
25a0			;			DMARK "EXx" 
25a0			;			CALLMONITOR 
25a0			;		endif 
25a0			;	call forthexec 
25a0			; 
25a0			;	jp .stkexec1 
25a0			; 
25a0			;	ret 
25a0			 
25a0			 
25a0			.DUP: 
25a0			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
25a0 17				db WORD_SYS_CORE+OPCODE_DUP             
25a1 16 26			dw .ZDUP            
25a3 04				db 3 + 1 
25a4 .. 00			db "DUP",0              
25a8				endm 
# End of macro CWHEAD
25a8			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
25a8			 
25a8				if DEBUG_FORTH_WORDS_KEY 
25a8					DMARK "DUP" 
25a8 f5				push af  
25a9 3a bd 25			ld a, (.dmark)  
25ac 32 a6 fd			ld (debug_mark),a  
25af 3a be 25			ld a, (.dmark+1)  
25b2 32 a7 fd			ld (debug_mark+1),a  
25b5 3a bf 25			ld a, (.dmark+2)  
25b8 32 a8 fd			ld (debug_mark+2),a  
25bb 18 03			jr .pastdmark  
25bd ..			.dmark: db "DUP"  
25c0 f1			.pastdmark: pop af  
25c1			endm  
# End of macro DMARK
25c1					CALLMONITOR 
25c1 cd aa fd			call debug_vector  
25c4				endm  
# End of macro CALLMONITOR
25c4				endif 
25c4			 
25c4				FORTH_DSP 
25c4 cd 19 22			call macro_forth_dsp 
25c7				endm 
# End of macro FORTH_DSP
25c7			 
25c7 7e				ld a, (HL) 
25c8 fe 01			cp DS_TYPE_STR 
25ca 20 25			jr nz, .dupinum 
25cc			 
25cc				; push another string 
25cc			 
25cc				FORTH_DSP_VALUEHL     		 
25cc cd 53 22			call macro_dsp_valuehl 
25cf				endm 
# End of macro FORTH_DSP_VALUEHL
25cf			 
25cf			if DEBUG_FORTH_WORDS 
25cf				DMARK "DUs" 
25cf f5				push af  
25d0 3a e4 25			ld a, (.dmark)  
25d3 32 a6 fd			ld (debug_mark),a  
25d6 3a e5 25			ld a, (.dmark+1)  
25d9 32 a7 fd			ld (debug_mark+1),a  
25dc 3a e6 25			ld a, (.dmark+2)  
25df 32 a8 fd			ld (debug_mark+2),a  
25e2 18 03			jr .pastdmark  
25e4 ..			.dmark: db "DUs"  
25e7 f1			.pastdmark: pop af  
25e8			endm  
# End of macro DMARK
25e8				CALLMONITOR 
25e8 cd aa fd			call debug_vector  
25eb				endm  
# End of macro CALLMONITOR
25eb			endif 
25eb cd ca 20			call forth_push_str 
25ee			 
25ee				NEXTW 
25ee c3 09 24			jp macro_next 
25f1				endm 
# End of macro NEXTW
25f1			 
25f1			 
25f1			.dupinum: 
25f1				 
25f1			 
25f1			 
25f1				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25f1 cd 53 22			call macro_dsp_valuehl 
25f4				endm 
# End of macro FORTH_DSP_VALUEHL
25f4			 
25f4			; TODO add floating point number detection 
25f4			 
25f4			if DEBUG_FORTH_WORDS 
25f4				DMARK "DUi" 
25f4 f5				push af  
25f5 3a 09 26			ld a, (.dmark)  
25f8 32 a6 fd			ld (debug_mark),a  
25fb 3a 0a 26			ld a, (.dmark+1)  
25fe 32 a7 fd			ld (debug_mark+1),a  
2601 3a 0b 26			ld a, (.dmark+2)  
2604 32 a8 fd			ld (debug_mark+2),a  
2607 18 03			jr .pastdmark  
2609 ..			.dmark: db "DUi"  
260c f1			.pastdmark: pop af  
260d			endm  
# End of macro DMARK
260d				CALLMONITOR 
260d cd aa fd			call debug_vector  
2610				endm  
# End of macro CALLMONITOR
2610			endif 
2610			 
2610 cd 5c 20			call forth_push_numhl 
2613				NEXTW 
2613 c3 09 24			jp macro_next 
2616				endm 
# End of macro NEXTW
2616			.ZDUP: 
2616			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2616 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2617 4e 26			dw .SWAP            
2619 05				db 4 + 1 
261a .. 00			db "?DUP",0              
261f				endm 
# End of macro CWHEAD
261f			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
261f			 
261f				if DEBUG_FORTH_WORDS_KEY 
261f					DMARK "qDU" 
261f f5				push af  
2620 3a 34 26			ld a, (.dmark)  
2623 32 a6 fd			ld (debug_mark),a  
2626 3a 35 26			ld a, (.dmark+1)  
2629 32 a7 fd			ld (debug_mark+1),a  
262c 3a 36 26			ld a, (.dmark+2)  
262f 32 a8 fd			ld (debug_mark+2),a  
2632 18 03			jr .pastdmark  
2634 ..			.dmark: db "qDU"  
2637 f1			.pastdmark: pop af  
2638			endm  
# End of macro DMARK
2638					CALLMONITOR 
2638 cd aa fd			call debug_vector  
263b				endm  
# End of macro CALLMONITOR
263b				endif 
263b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
263b cd 53 22			call macro_dsp_valuehl 
263e				endm 
# End of macro FORTH_DSP_VALUEHL
263e			 
263e e5				push hl 
263f			 
263f				; is it a zero? 
263f			 
263f 3e 00			ld a, 0 
2641 84				add h 
2642 85				add l 
2643			 
2643 e1				pop hl 
2644			 
2644 fe 00			cp 0 
2646 28 03			jr z, .dup2orig 
2648			 
2648			 
2648 cd 5c 20			call forth_push_numhl 
264b			 
264b			 
264b			; TODO add floating point number detection 
264b			 
264b			.dup2orig: 
264b			 
264b				NEXTW 
264b c3 09 24			jp macro_next 
264e				endm 
# End of macro NEXTW
264e			.SWAP: 
264e			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
264e 18				db WORD_SYS_CORE+OPCODE_SWAP             
264f 8d 26			dw .COLN            
2651 05				db 4 + 1 
2652 .. 00			db "SWAP",0              
2657				endm 
# End of macro CWHEAD
2657			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2657				if DEBUG_FORTH_WORDS_KEY 
2657					DMARK "SWP" 
2657 f5				push af  
2658 3a 6c 26			ld a, (.dmark)  
265b 32 a6 fd			ld (debug_mark),a  
265e 3a 6d 26			ld a, (.dmark+1)  
2661 32 a7 fd			ld (debug_mark+1),a  
2664 3a 6e 26			ld a, (.dmark+2)  
2667 32 a8 fd			ld (debug_mark+2),a  
266a 18 03			jr .pastdmark  
266c ..			.dmark: db "SWP"  
266f f1			.pastdmark: pop af  
2670			endm  
# End of macro DMARK
2670					CALLMONITOR 
2670 cd aa fd			call debug_vector  
2673				endm  
# End of macro CALLMONITOR
2673				endif 
2673			 
2673			; TODO Use os stack swap memory 
2673				FORTH_DSP_VALUEHL 
2673 cd 53 22			call macro_dsp_valuehl 
2676				endm 
# End of macro FORTH_DSP_VALUEHL
2676 e5				push hl     ; w2 
2677			 
2677				FORTH_DSP_POP 
2677 cd 0b 23			call macro_forth_dsp_pop 
267a				endm 
# End of macro FORTH_DSP_POP
267a			 
267a				FORTH_DSP_VALUEHL 
267a cd 53 22			call macro_dsp_valuehl 
267d				endm 
# End of macro FORTH_DSP_VALUEHL
267d			 
267d				FORTH_DSP_POP 
267d cd 0b 23			call macro_forth_dsp_pop 
2680				endm 
# End of macro FORTH_DSP_POP
2680			 
2680 d1				pop de     ; w2	, hl = w1 
2681			 
2681 eb				ex de, hl 
2682 d5				push de 
2683			 
2683 cd 5c 20			call forth_push_numhl 
2686			 
2686 e1				pop hl 
2687			 
2687 cd 5c 20			call forth_push_numhl 
268a				 
268a			 
268a				NEXTW 
268a c3 09 24			jp macro_next 
268d				endm 
# End of macro NEXTW
268d			.COLN: 
268d			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
268d 19				db WORD_SYS_CORE+OPCODE_COLN             
268e 19 28			dw .SCOLN            
2690 02				db 1 + 1 
2691 .. 00			db ":",0              
2693				endm 
# End of macro CWHEAD
2693			; | : ( -- )         Create new word | DONE 
2693			 
2693				if DEBUG_FORTH_WORDS_KEY 
2693					DMARK "CLN" 
2693 f5				push af  
2694 3a a8 26			ld a, (.dmark)  
2697 32 a6 fd			ld (debug_mark),a  
269a 3a a9 26			ld a, (.dmark+1)  
269d 32 a7 fd			ld (debug_mark+1),a  
26a0 3a aa 26			ld a, (.dmark+2)  
26a3 32 a8 fd			ld (debug_mark+2),a  
26a6 18 03			jr .pastdmark  
26a8 ..			.dmark: db "CLN"  
26ab f1			.pastdmark: pop af  
26ac			endm  
# End of macro DMARK
26ac					CALLMONITOR 
26ac cd aa fd			call debug_vector  
26af				endm  
# End of macro CALLMONITOR
26af				endif 
26af			STACKFRAME OFF $8efe $989f 
26af				if DEBUG_STACK_IMB 
26af					if OFF 
26af						exx 
26af						ld de, $8efe 
26af						ld a, d 
26af						ld hl, curframe 
26af						call hexout 
26af						ld a, e 
26af						ld hl, curframe+2 
26af						call hexout 
26af						ld hl, $8efe 
26af						push hl 
26af						ld hl, $989f 
26af						push hl 
26af						exx 
26af					endif 
26af				endif 
26af			endm 
# End of macro STACKFRAME
26af			; get parser buffer length  of new word 
26af			 
26af			 
26af			 
26af				; move tok past this to start of name defintition 
26af				; TODO get word to define 
26af				; TODO Move past word token 
26af				; TODO get length of string up to the ';' 
26af			 
26af 2a fd f3		ld hl, (os_tok_ptr) 
26b2 23			inc hl 
26b3 23			inc hl 
26b4			 
26b4 3e 3b		ld a, ';' 
26b6 cd 91 13		call strlent 
26b9			 
26b9 7d			ld a,l 
26ba 32 ec f0		ld (os_new_parse_len), a 
26bd			 
26bd			 
26bd			if DEBUG_FORTH_UWORD 
26bd ed 5b fd f3	ld de, (os_tok_ptr) 
26c1					DMARK ":01" 
26c1 f5				push af  
26c2 3a d6 26			ld a, (.dmark)  
26c5 32 a6 fd			ld (debug_mark),a  
26c8 3a d7 26			ld a, (.dmark+1)  
26cb 32 a7 fd			ld (debug_mark+1),a  
26ce 3a d8 26			ld a, (.dmark+2)  
26d1 32 a8 fd			ld (debug_mark+2),a  
26d4 18 03			jr .pastdmark  
26d6 ..			.dmark: db ":01"  
26d9 f1			.pastdmark: pop af  
26da			endm  
# End of macro DMARK
26da			CALLMONITOR 
26da cd aa fd			call debug_vector  
26dd				endm  
# End of macro CALLMONITOR
26dd			endif 
26dd			 
26dd			; 
26dd			;  new word memory layout: 
26dd			;  
26dd			;    : adg 6666 ;  
26dd			; 
26dd			;    db   1     ; user defined word  
26dd 23			inc hl    
26de			;    dw   sysdict 
26de 23			inc hl 
26df 23			inc hl 
26e0			;    db <word len>+1 (for null) 
26e0 23			inc hl 
26e1			;    db .... <word> 
26e1			; 
26e1			 
26e1 23			inc hl    ; some extras for the word preamble before the above 
26e2 23			inc hl 
26e3 23			inc hl 
26e4 23			inc hl 
26e5 23			inc hl 
26e6 23			inc hl 
26e7 23			inc hl  
26e8 23			inc hl 
26e9 23			inc hl 
26ea 23			inc hl 
26eb 23			inc hl 
26ec 23			inc hl 
26ed 23			inc hl 
26ee 23			inc hl     ; TODO how many do we really need?     maybe only 6 
26ef			;       exec word buffer 
26ef			;	<ptr word>   
26ef 23			inc hl 
26f0 23			inc hl 
26f1			;       <word list><null term> 7F final term 
26f1			 
26f1			 
26f1			if DEBUG_FORTH_UWORD 
26f1					DMARK ":02" 
26f1 f5				push af  
26f2 3a 06 27			ld a, (.dmark)  
26f5 32 a6 fd			ld (debug_mark),a  
26f8 3a 07 27			ld a, (.dmark+1)  
26fb 32 a7 fd			ld (debug_mark+1),a  
26fe 3a 08 27			ld a, (.dmark+2)  
2701 32 a8 fd			ld (debug_mark+2),a  
2704 18 03			jr .pastdmark  
2706 ..			.dmark: db ":02"  
2709 f1			.pastdmark: pop af  
270a			endm  
# End of macro DMARK
270a			CALLMONITOR 
270a cd aa fd			call debug_vector  
270d				endm  
# End of macro CALLMONITOR
270d			endif 
270d			 
270d			 
270d				; malloc the size 
270d			 
270d cd fb 13			call malloc 
2710 22 ee f0			ld (os_new_malloc), hl     ; save malloc start 
2713			 
2713			;    db   1     ; user defined word  
2713 3e 01			ld a, WORD_SYS_UWORD  
2715 77				ld (hl), a 
2716			 
2716 23			inc hl    
2717			;    dw   sysdict 
2717 11 61 25		ld de, sysdict       ; continue on with the scan to the system dict 
271a 73			ld (hl), e 
271b 23			inc hl 
271c 72			ld (hl), d 
271d 23			inc hl 
271e			 
271e			 
271e			;    Setup dict word 
271e			 
271e 23			inc hl 
271f 22 e8 f0		ld (os_new_work_ptr), hl     ; save start of dict word  
2722			 
2722			; 1. get length of dict word 
2722			 
2722			 
2722 2a fd f3		ld hl, (os_tok_ptr) 
2725 23			inc hl 
2726 23			inc hl    ; position to start of dict word 
2727 3e 00		ld a, 0 
2729 cd 91 13		call strlent 
272c			 
272c			 
272c 23			inc hl    ; to include null??? 
272d			 
272d			; write length of dict word 
272d			 
272d ed 5b e8 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2731 1b			dec de 
2732 eb			ex de, hl 
2733 73			ld (hl), e 
2734 eb			ex de, hl 
2735			 
2735			 
2735			 
2735			; copy  
2735 4d			ld c, l 
2736 06 00		ld b, 0 
2738 ed 5b e8 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
273c 2a fd f3		ld hl, (os_tok_ptr) 
273f 23			inc hl 
2740 23			inc hl    ; position to start of dict word 
2741			 
2741			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2741			 
2741			; TODO need to convert word to upper case 
2741			 
2741			ucasetok:	 
2741 7e			ld a,(hl) 
2742 cd 7d 13		call toUpper 
2745 77			ld (hl),a 
2746 ed a0		ldi 
2748 f2 41 27		jp p, ucasetok 
274b			 
274b			 
274b			 
274b			; de now points to start of where the word body code should be placed 
274b ed 53 e8 f0	ld (os_new_work_ptr), de 
274f			; hl now points to the words to throw at forthexec which needs to be copied 
274f 22 e6 f0		ld (os_new_src_ptr), hl 
2752			 
2752			; TODO add 'call to forthexec' 
2752			 
2752			if DEBUG_FORTH_UWORD 
2752 c5			push bc 
2753 ed 4b ee f0	ld bc, (os_new_malloc) 
2757					DMARK ":0x" 
2757 f5				push af  
2758 3a 6c 27			ld a, (.dmark)  
275b 32 a6 fd			ld (debug_mark),a  
275e 3a 6d 27			ld a, (.dmark+1)  
2761 32 a7 fd			ld (debug_mark+1),a  
2764 3a 6e 27			ld a, (.dmark+2)  
2767 32 a8 fd			ld (debug_mark+2),a  
276a 18 03			jr .pastdmark  
276c ..			.dmark: db ":0x"  
276f f1			.pastdmark: pop af  
2770			endm  
# End of macro DMARK
2770			CALLMONITOR 
2770 cd aa fd			call debug_vector  
2773				endm  
# End of macro CALLMONITOR
2773 c1			pop bc 
2774			endif 
2774			 
2774			 
2774			; create word preamble which should be: 
2774			 
2774			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2774			 
2774			;    ld hl, <word code> 
2774			;    jp user_exec 
2774			;    <word code bytes> 
2774			 
2774			 
2774			;	inc de     ; TODO ??? or are we already past the word's null 
2774 eb			ex de, hl 
2775			 
2775 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2777			 
2777 23			inc hl 
2778 22 e2 f0		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
277b 23			inc hl 
277c			 
277c 23			inc hl 
277d 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
277f			 
277f 01 0a 5d		ld bc, user_exec 
2782 23			inc hl 
2783 71			ld (hl), c     ; poke address of user_exec 
2784 23			inc hl 
2785 70			ld (hl), b     
2786			; 
2786			;	inc hl 
2786			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2786			; 
2786			; 
2786			;	ld bc, macro_forth_rsp_next 
2786			;	inc hl 
2786			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2786			;	inc hl 
2786			;	ld (hl), b     
2786			; 
2786			;	inc hl 
2786			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2786			; 
2786			; 
2786			;	inc hl 
2786			;	ld bc, forthexec 
2786			;	ld (hl), c     ; poke address of forthexec 
2786			;	inc hl 
2786			;	ld (hl), b      
2786			; 
2786			;	inc hl 
2786			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2786			; 
2786			;	ld bc, user_dict_next 
2786			;	inc hl 
2786			;	ld (hl), c     ; poke address of forthexec 
2786			;	inc hl 
2786			;	ld (hl), b      
2786			 
2786			; hl is now where we need to copy the word byte data to save this 
2786			 
2786 23			inc hl 
2787 22 e4 f0		ld (os_new_exec), hl 
278a			 
278a			; copy definition 
278a			 
278a eb			ex de, hl 
278b			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
278b			;	inc de    ; skip the PC for this parse 
278b 3a ec f0		ld a, (os_new_parse_len) 
278e 4f			ld c, a 
278f 06 00		ld b, 0 
2791 ed b0		ldir		 ; copy defintion 
2793			 
2793			 
2793			; poke the address of where the new word bytes live for forthexec 
2793			 
2793 2a e2 f0		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2796			 
2796 ed 5b e4 f0	ld de, (os_new_exec)      
279a			 
279a 73			ld (hl), e 
279b 23			inc hl 
279c 72			ld (hl), d 
279d			 
279d				; TODO copy last user dict word next link to this word 
279d				; TODO update last user dict word to point to this word 
279d			; 
279d			; hl f923 de 812a ; bc 811a 
279d			 
279d			if DEBUG_FORTH_UWORD 
279d c5			push bc 
279e ed 4b ee f0	ld bc, (os_new_malloc) 
27a2					DMARK ":0A" 
27a2 f5				push af  
27a3 3a b7 27			ld a, (.dmark)  
27a6 32 a6 fd			ld (debug_mark),a  
27a9 3a b8 27			ld a, (.dmark+1)  
27ac 32 a7 fd			ld (debug_mark+1),a  
27af 3a b9 27			ld a, (.dmark+2)  
27b2 32 a8 fd			ld (debug_mark+2),a  
27b5 18 03			jr .pastdmark  
27b7 ..			.dmark: db ":0A"  
27ba f1			.pastdmark: pop af  
27bb			endm  
# End of macro DMARK
27bb			CALLMONITOR 
27bb cd aa fd			call debug_vector  
27be				endm  
# End of macro CALLMONITOR
27be c1			pop bc 
27bf			endif 
27bf			if DEBUG_FORTH_UWORD 
27bf c5			push bc 
27c0 ed 4b ee f0	ld bc, (os_new_malloc) 
27c4 03			inc bc 
27c5 03			inc bc 
27c6 03			inc bc 
27c7 03			inc bc 
27c8 03			inc bc 
27c9 03			inc bc 
27ca 03			inc bc 
27cb 03			inc bc 
27cc			 
27cc					DMARK ":0B" 
27cc f5				push af  
27cd 3a e1 27			ld a, (.dmark)  
27d0 32 a6 fd			ld (debug_mark),a  
27d3 3a e2 27			ld a, (.dmark+1)  
27d6 32 a7 fd			ld (debug_mark+1),a  
27d9 3a e3 27			ld a, (.dmark+2)  
27dc 32 a8 fd			ld (debug_mark+2),a  
27df 18 03			jr .pastdmark  
27e1 ..			.dmark: db ":0B"  
27e4 f1			.pastdmark: pop af  
27e5			endm  
# End of macro DMARK
27e5			CALLMONITOR 
27e5 cd aa fd			call debug_vector  
27e8				endm  
# End of macro CALLMONITOR
27e8 c1			pop bc 
27e9			endif 
27e9			 
27e9			; update word dict linked list for new word 
27e9			 
27e9			 
27e9 2a f9 f3		ld hl, (os_last_new_uword)		; get the start of the last added uword 
27ec 23			inc hl     ; move to next work linked list ptr 
27ed			 
27ed ed 5b ee f0	ld de, (os_new_malloc)		 ; new next word 
27f1 73			ld (hl), e 
27f2 23			inc hl 
27f3 72			ld (hl), d 
27f4			 
27f4			if DEBUG_FORTH_UWORD 
27f4 ed 4b f9 f3	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
27f8			endif 
27f8			 
27f8 ed 53 f9 f3	ld (os_last_new_uword), de      ; update last new uword ptr 
27fc			 
27fc			 
27fc			if DEBUG_FORTH_UWORD 
27fc					DMARK ":0+" 
27fc f5				push af  
27fd 3a 11 28			ld a, (.dmark)  
2800 32 a6 fd			ld (debug_mark),a  
2803 3a 12 28			ld a, (.dmark+1)  
2806 32 a7 fd			ld (debug_mark+1),a  
2809 3a 13 28			ld a, (.dmark+2)  
280c 32 a8 fd			ld (debug_mark+2),a  
280f 18 03			jr .pastdmark  
2811 ..			.dmark: db ":0+"  
2814 f1			.pastdmark: pop af  
2815			endm  
# End of macro DMARK
2815			CALLMONITOR 
2815 cd aa fd			call debug_vector  
2818				endm  
# End of macro CALLMONITOR
2818			endif 
2818			 
2818			STACKFRAMECHK OFF $8efe $989f 
2818				if DEBUG_STACK_IMB 
2818					if OFF 
2818						exx 
2818						ld hl, $989f 
2818						pop de   ; $989f 
2818						call cmp16 
2818						jr nz, .spnosame 
2818						ld hl, $8efe 
2818						pop de   ; $8efe 
2818						call cmp16 
2818						jr z, .spfrsame 
2818						.spnosame: call showsperror 
2818						.spfrsame: nop 
2818						exx 
2818					endif 
2818				endif 
2818			endm 
# End of macro STACKFRAMECHK
2818			 
2818 c9			ret    ; dont process any remaining parser tokens as they form new word 
2819			 
2819			 
2819			 
2819			 
2819			;		NEXT 
2819			.SCOLN: 
2819			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2819 06			db OPCODE_SCOLN 
281a 65 28		dw .DROP 
281c 02			db 2 
281d .. 00		db ";",0           
281f			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
281f				if DEBUG_FORTH_WORDS_KEY 
281f					DMARK "SCN" 
281f f5				push af  
2820 3a 34 28			ld a, (.dmark)  
2823 32 a6 fd			ld (debug_mark),a  
2826 3a 35 28			ld a, (.dmark+1)  
2829 32 a7 fd			ld (debug_mark+1),a  
282c 3a 36 28			ld a, (.dmark+2)  
282f 32 a8 fd			ld (debug_mark+2),a  
2832 18 03			jr .pastdmark  
2834 ..			.dmark: db "SCN"  
2837 f1			.pastdmark: pop af  
2838			endm  
# End of macro DMARK
2838					CALLMONITOR 
2838 cd aa fd			call debug_vector  
283b				endm  
# End of macro CALLMONITOR
283b				endif 
283b				FORTH_RSP_TOS 
283b cd 1a 20			call macro_forth_rsp_tos 
283e				endm 
# End of macro FORTH_RSP_TOS
283e e5				push hl 
283f				FORTH_RSP_POP 
283f cd 24 20			call macro_forth_rsp_pop 
2842				endm 
# End of macro FORTH_RSP_POP
2842 e1				pop hl 
2843			;		ex de,hl 
2843 22 fd f3			ld (os_tok_ptr),hl 
2846			 
2846			if DEBUG_FORTH_UWORD 
2846					DMARK "SCL" 
2846 f5				push af  
2847 3a 5b 28			ld a, (.dmark)  
284a 32 a6 fd			ld (debug_mark),a  
284d 3a 5c 28			ld a, (.dmark+1)  
2850 32 a7 fd			ld (debug_mark+1),a  
2853 3a 5d 28			ld a, (.dmark+2)  
2856 32 a8 fd			ld (debug_mark+2),a  
2859 18 03			jr .pastdmark  
285b ..			.dmark: db "SCL"  
285e f1			.pastdmark: pop af  
285f			endm  
# End of macro DMARK
285f			CALLMONITOR 
285f cd aa fd			call debug_vector  
2862				endm  
# End of macro CALLMONITOR
2862			endif 
2862				NEXTW 
2862 c3 09 24			jp macro_next 
2865				endm 
# End of macro NEXTW
2865			 
2865			.DROP: 
2865			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2865 1b				db WORD_SYS_CORE+OPCODE_DROP             
2866 90 28			dw .DUP2            
2868 05				db 4 + 1 
2869 .. 00			db "DROP",0              
286e				endm 
# End of macro CWHEAD
286e			; | DROP ( w -- )   drop the TOS item   | DONE 
286e				if DEBUG_FORTH_WORDS_KEY 
286e					DMARK "DRP" 
286e f5				push af  
286f 3a 83 28			ld a, (.dmark)  
2872 32 a6 fd			ld (debug_mark),a  
2875 3a 84 28			ld a, (.dmark+1)  
2878 32 a7 fd			ld (debug_mark+1),a  
287b 3a 85 28			ld a, (.dmark+2)  
287e 32 a8 fd			ld (debug_mark+2),a  
2881 18 03			jr .pastdmark  
2883 ..			.dmark: db "DRP"  
2886 f1			.pastdmark: pop af  
2887			endm  
# End of macro DMARK
2887					CALLMONITOR 
2887 cd aa fd			call debug_vector  
288a				endm  
# End of macro CALLMONITOR
288a				endif 
288a				FORTH_DSP_POP 
288a cd 0b 23			call macro_forth_dsp_pop 
288d				endm 
# End of macro FORTH_DSP_POP
288d				NEXTW 
288d c3 09 24			jp macro_next 
2890				endm 
# End of macro NEXTW
2890			.DUP2: 
2890			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2890 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2891 d5 28			dw .DROP2            
2893 05				db 4 + 1 
2894 .. 00			db "2DUP",0              
2899				endm 
# End of macro CWHEAD
2899			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2899				if DEBUG_FORTH_WORDS_KEY 
2899					DMARK "2DU" 
2899 f5				push af  
289a 3a ae 28			ld a, (.dmark)  
289d 32 a6 fd			ld (debug_mark),a  
28a0 3a af 28			ld a, (.dmark+1)  
28a3 32 a7 fd			ld (debug_mark+1),a  
28a6 3a b0 28			ld a, (.dmark+2)  
28a9 32 a8 fd			ld (debug_mark+2),a  
28ac 18 03			jr .pastdmark  
28ae ..			.dmark: db "2DU"  
28b1 f1			.pastdmark: pop af  
28b2			endm  
# End of macro DMARK
28b2					CALLMONITOR 
28b2 cd aa fd			call debug_vector  
28b5				endm  
# End of macro CALLMONITOR
28b5				endif 
28b5				FORTH_DSP_VALUEHL 
28b5 cd 53 22			call macro_dsp_valuehl 
28b8				endm 
# End of macro FORTH_DSP_VALUEHL
28b8 e5				push hl      ; 2 
28b9			 
28b9				FORTH_DSP_POP 
28b9 cd 0b 23			call macro_forth_dsp_pop 
28bc				endm 
# End of macro FORTH_DSP_POP
28bc				 
28bc				FORTH_DSP_VALUEHL 
28bc cd 53 22			call macro_dsp_valuehl 
28bf				endm 
# End of macro FORTH_DSP_VALUEHL
28bf			;		push hl      ; 1 
28bf			 
28bf				FORTH_DSP_POP 
28bf cd 0b 23			call macro_forth_dsp_pop 
28c2				endm 
# End of macro FORTH_DSP_POP
28c2			 
28c2			;		pop hl       ; 1 
28c2 d1				pop de       ; 2 
28c3			 
28c3 cd 5c 20			call forth_push_numhl 
28c6 eb				ex de, hl 
28c7 cd 5c 20			call forth_push_numhl 
28ca			 
28ca				 
28ca eb				ex de, hl 
28cb			 
28cb cd 5c 20			call forth_push_numhl 
28ce eb				ex de, hl 
28cf cd 5c 20			call forth_push_numhl 
28d2			 
28d2			 
28d2				NEXTW 
28d2 c3 09 24			jp macro_next 
28d5				endm 
# End of macro NEXTW
28d5			.DROP2: 
28d5			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
28d5 1d				db WORD_SYS_CORE+OPCODE_DROP2             
28d6 04 29			dw .SWAP2            
28d8 06				db 5 + 1 
28d9 .. 00			db "2DROP",0              
28df				endm 
# End of macro CWHEAD
28df			; | 2DROP ( w w -- )    Double drop | DONE 
28df				if DEBUG_FORTH_WORDS_KEY 
28df					DMARK "2DR" 
28df f5				push af  
28e0 3a f4 28			ld a, (.dmark)  
28e3 32 a6 fd			ld (debug_mark),a  
28e6 3a f5 28			ld a, (.dmark+1)  
28e9 32 a7 fd			ld (debug_mark+1),a  
28ec 3a f6 28			ld a, (.dmark+2)  
28ef 32 a8 fd			ld (debug_mark+2),a  
28f2 18 03			jr .pastdmark  
28f4 ..			.dmark: db "2DR"  
28f7 f1			.pastdmark: pop af  
28f8			endm  
# End of macro DMARK
28f8					CALLMONITOR 
28f8 cd aa fd			call debug_vector  
28fb				endm  
# End of macro CALLMONITOR
28fb				endif 
28fb				FORTH_DSP_POP 
28fb cd 0b 23			call macro_forth_dsp_pop 
28fe				endm 
# End of macro FORTH_DSP_POP
28fe				FORTH_DSP_POP 
28fe cd 0b 23			call macro_forth_dsp_pop 
2901				endm 
# End of macro FORTH_DSP_POP
2901				NEXTW 
2901 c3 09 24			jp macro_next 
2904				endm 
# End of macro NEXTW
2904			.SWAP2: 
2904			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2904 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2905 2d 29			dw .AT            
2907 06				db 5 + 1 
2908 .. 00			db "2SWAP",0              
290e				endm 
# End of macro CWHEAD
290e			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
290e				if DEBUG_FORTH_WORDS_KEY 
290e					DMARK "2SW" 
290e f5				push af  
290f 3a 23 29			ld a, (.dmark)  
2912 32 a6 fd			ld (debug_mark),a  
2915 3a 24 29			ld a, (.dmark+1)  
2918 32 a7 fd			ld (debug_mark+1),a  
291b 3a 25 29			ld a, (.dmark+2)  
291e 32 a8 fd			ld (debug_mark+2),a  
2921 18 03			jr .pastdmark  
2923 ..			.dmark: db "2SW"  
2926 f1			.pastdmark: pop af  
2927			endm  
# End of macro DMARK
2927					CALLMONITOR 
2927 cd aa fd			call debug_vector  
292a				endm  
# End of macro CALLMONITOR
292a				endif 
292a			; TODO Use os stack swap memory 
292a				NEXTW 
292a c3 09 24			jp macro_next 
292d				endm 
# End of macro NEXTW
292d			.AT: 
292d			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
292d 1f				db WORD_SYS_CORE+OPCODE_AT             
292e 5f 29			dw .CAT            
2930 02				db 1 + 1 
2931 .. 00			db "@",0              
2933				endm 
# End of macro CWHEAD
2933			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2933			 
2933				if DEBUG_FORTH_WORDS_KEY 
2933					DMARK "AT." 
2933 f5				push af  
2934 3a 48 29			ld a, (.dmark)  
2937 32 a6 fd			ld (debug_mark),a  
293a 3a 49 29			ld a, (.dmark+1)  
293d 32 a7 fd			ld (debug_mark+1),a  
2940 3a 4a 29			ld a, (.dmark+2)  
2943 32 a8 fd			ld (debug_mark+2),a  
2946 18 03			jr .pastdmark  
2948 ..			.dmark: db "AT."  
294b f1			.pastdmark: pop af  
294c			endm  
# End of macro DMARK
294c					CALLMONITOR 
294c cd aa fd			call debug_vector  
294f				endm  
# End of macro CALLMONITOR
294f				endif 
294f			.getbyteat:	 
294f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
294f cd 53 22			call macro_dsp_valuehl 
2952				endm 
# End of macro FORTH_DSP_VALUEHL
2952				 
2952			;		push hl 
2952			 
2952				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2952 cd 0b 23			call macro_forth_dsp_pop 
2955				endm 
# End of macro FORTH_DSP_POP
2955			 
2955			;		pop hl 
2955			 
2955 7e				ld a, (hl) 
2956			 
2956 6f				ld l, a 
2957 26 00			ld h, 0 
2959 cd 5c 20			call forth_push_numhl 
295c			 
295c				NEXTW 
295c c3 09 24			jp macro_next 
295f				endm 
# End of macro NEXTW
295f			.CAT: 
295f			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
295f 20				db WORD_SYS_CORE+OPCODE_CAT             
2960 88 29			dw .BANG            
2962 03				db 2 + 1 
2963 .. 00			db "C@",0              
2966				endm 
# End of macro CWHEAD
2966			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2966				if DEBUG_FORTH_WORDS_KEY 
2966					DMARK "CAA" 
2966 f5				push af  
2967 3a 7b 29			ld a, (.dmark)  
296a 32 a6 fd			ld (debug_mark),a  
296d 3a 7c 29			ld a, (.dmark+1)  
2970 32 a7 fd			ld (debug_mark+1),a  
2973 3a 7d 29			ld a, (.dmark+2)  
2976 32 a8 fd			ld (debug_mark+2),a  
2979 18 03			jr .pastdmark  
297b ..			.dmark: db "CAA"  
297e f1			.pastdmark: pop af  
297f			endm  
# End of macro DMARK
297f					CALLMONITOR 
297f cd aa fd			call debug_vector  
2982				endm  
# End of macro CALLMONITOR
2982				endif 
2982 c3 4f 29			jp .getbyteat 
2985				NEXTW 
2985 c3 09 24			jp macro_next 
2988				endm 
# End of macro NEXTW
2988			.BANG: 
2988			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2988 21				db WORD_SYS_CORE+OPCODE_BANG             
2989 be 29			dw .CBANG            
298b 02				db 1 + 1 
298c .. 00			db "!",0              
298e				endm 
# End of macro CWHEAD
298e			; | ! ( x w -- ) Store x at address w      | DONE 
298e				if DEBUG_FORTH_WORDS_KEY 
298e					DMARK "BNG" 
298e f5				push af  
298f 3a a3 29			ld a, (.dmark)  
2992 32 a6 fd			ld (debug_mark),a  
2995 3a a4 29			ld a, (.dmark+1)  
2998 32 a7 fd			ld (debug_mark+1),a  
299b 3a a5 29			ld a, (.dmark+2)  
299e 32 a8 fd			ld (debug_mark+2),a  
29a1 18 03			jr .pastdmark  
29a3 ..			.dmark: db "BNG"  
29a6 f1			.pastdmark: pop af  
29a7			endm  
# End of macro DMARK
29a7					CALLMONITOR 
29a7 cd aa fd			call debug_vector  
29aa				endm  
# End of macro CALLMONITOR
29aa				endif 
29aa			 
29aa			.storebyteat:		 
29aa				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29aa cd 53 22			call macro_dsp_valuehl 
29ad				endm 
# End of macro FORTH_DSP_VALUEHL
29ad				 
29ad e5				push hl 
29ae			 
29ae				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29ae cd 0b 23			call macro_forth_dsp_pop 
29b1				endm 
# End of macro FORTH_DSP_POP
29b1			 
29b1				; get byte to poke 
29b1			 
29b1				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29b1 cd 53 22			call macro_dsp_valuehl 
29b4				endm 
# End of macro FORTH_DSP_VALUEHL
29b4 e5				push hl 
29b5			 
29b5			 
29b5				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29b5 cd 0b 23			call macro_forth_dsp_pop 
29b8				endm 
# End of macro FORTH_DSP_POP
29b8			 
29b8			 
29b8 d1				pop de 
29b9 e1				pop hl 
29ba			 
29ba 73				ld (hl),e 
29bb			 
29bb			 
29bb				NEXTW 
29bb c3 09 24			jp macro_next 
29be				endm 
# End of macro NEXTW
29be			.CBANG: 
29be			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
29be 22				db WORD_SYS_CORE+OPCODE_CBANG             
29bf e7 29			dw .SCALL            
29c1 03				db 2 + 1 
29c2 .. 00			db "C!",0              
29c5				endm 
# End of macro CWHEAD
29c5			; | C!  ( x w -- ) Store x at address w  | DONE 
29c5				if DEBUG_FORTH_WORDS_KEY 
29c5					DMARK "CBA" 
29c5 f5				push af  
29c6 3a da 29			ld a, (.dmark)  
29c9 32 a6 fd			ld (debug_mark),a  
29cc 3a db 29			ld a, (.dmark+1)  
29cf 32 a7 fd			ld (debug_mark+1),a  
29d2 3a dc 29			ld a, (.dmark+2)  
29d5 32 a8 fd			ld (debug_mark+2),a  
29d8 18 03			jr .pastdmark  
29da ..			.dmark: db "CBA"  
29dd f1			.pastdmark: pop af  
29de			endm  
# End of macro DMARK
29de					CALLMONITOR 
29de cd aa fd			call debug_vector  
29e1				endm  
# End of macro CALLMONITOR
29e1				endif 
29e1 c3 aa 29			jp .storebyteat 
29e4				NEXTW 
29e4 c3 09 24			jp macro_next 
29e7				endm 
# End of macro NEXTW
29e7			.SCALL: 
29e7			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
29e7 23				db WORD_SYS_CORE+OPCODE_SCALL             
29e8 1b 2a			dw .DEPTH            
29ea 05				db 4 + 1 
29eb .. 00			db "CALL",0              
29f0				endm 
# End of macro CWHEAD
29f0			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
29f0				if DEBUG_FORTH_WORDS_KEY 
29f0					DMARK "CLL" 
29f0 f5				push af  
29f1 3a 05 2a			ld a, (.dmark)  
29f4 32 a6 fd			ld (debug_mark),a  
29f7 3a 06 2a			ld a, (.dmark+1)  
29fa 32 a7 fd			ld (debug_mark+1),a  
29fd 3a 07 2a			ld a, (.dmark+2)  
2a00 32 a8 fd			ld (debug_mark+2),a  
2a03 18 03			jr .pastdmark  
2a05 ..			.dmark: db "CLL"  
2a08 f1			.pastdmark: pop af  
2a09			endm  
# End of macro DMARK
2a09					CALLMONITOR 
2a09 cd aa fd			call debug_vector  
2a0c				endm  
# End of macro CALLMONITOR
2a0c				endif 
2a0c			 
2a0c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a0c cd 53 22			call macro_dsp_valuehl 
2a0f				endm 
# End of macro FORTH_DSP_VALUEHL
2a0f			 
2a0f			;		push hl 
2a0f			 
2a0f				; destroy value TOS 
2a0f			 
2a0f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a0f cd 0b 23			call macro_forth_dsp_pop 
2a12				endm 
# End of macro FORTH_DSP_POP
2a12			 
2a12					 
2a12			;		pop hl 
2a12			 
2a12				; how to do a call with hl???? save SP? 
2a12 cd ad 23			call forth_call_hl 
2a15			 
2a15			 
2a15				; TODO push value back onto stack for another op etc 
2a15			 
2a15 cd 5c 20			call forth_push_numhl 
2a18				NEXTW 
2a18 c3 09 24			jp macro_next 
2a1b				endm 
# End of macro NEXTW
2a1b			.DEPTH: 
2a1b			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2a1b 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2a1c 58 2a			dw .OVER            
2a1e 06				db 5 + 1 
2a1f .. 00			db "DEPTH",0              
2a25				endm 
# End of macro CWHEAD
2a25			; | DEPTH ( -- u ) Push count of stack | DONE 
2a25				; take current TOS and remove from base value div by two to get count 
2a25				if DEBUG_FORTH_WORDS_KEY 
2a25					DMARK "DEP" 
2a25 f5				push af  
2a26 3a 3a 2a			ld a, (.dmark)  
2a29 32 a6 fd			ld (debug_mark),a  
2a2c 3a 3b 2a			ld a, (.dmark+1)  
2a2f 32 a7 fd			ld (debug_mark+1),a  
2a32 3a 3c 2a			ld a, (.dmark+2)  
2a35 32 a8 fd			ld (debug_mark+2),a  
2a38 18 03			jr .pastdmark  
2a3a ..			.dmark: db "DEP"  
2a3d f1			.pastdmark: pop af  
2a3e			endm  
# End of macro DMARK
2a3e					CALLMONITOR 
2a3e cd aa fd			call debug_vector  
2a41				endm  
# End of macro CALLMONITOR
2a41				endif 
2a41			 
2a41			 
2a41 2a 29 f9		ld hl, (cli_data_sp) 
2a44 11 63 f6		ld de, cli_data_stack 
2a47 ed 52		sbc hl,de 
2a49			 
2a49			; div by size of stack item 
2a49			 
2a49 5d			ld e,l 
2a4a 0e 03		ld c, 3 
2a4c cd 5f 0f		call Div8 
2a4f			 
2a4f 6f			ld l,a 
2a50 26 00		ld h,0 
2a52			 
2a52			;srl h 
2a52			;rr l 
2a52			 
2a52 cd 5c 20			call forth_push_numhl 
2a55				NEXTW 
2a55 c3 09 24			jp macro_next 
2a58				endm 
# End of macro NEXTW
2a58			.OVER: 
2a58			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2a58 42				db WORD_SYS_CORE+46             
2a59 9f 2a			dw .PAUSE            
2a5b 05				db 4 + 1 
2a5c .. 00			db "OVER",0              
2a61				endm 
# End of macro CWHEAD
2a61			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2a61				if DEBUG_FORTH_WORDS_KEY 
2a61					DMARK "OVR" 
2a61 f5				push af  
2a62 3a 76 2a			ld a, (.dmark)  
2a65 32 a6 fd			ld (debug_mark),a  
2a68 3a 77 2a			ld a, (.dmark+1)  
2a6b 32 a7 fd			ld (debug_mark+1),a  
2a6e 3a 78 2a			ld a, (.dmark+2)  
2a71 32 a8 fd			ld (debug_mark+2),a  
2a74 18 03			jr .pastdmark  
2a76 ..			.dmark: db "OVR"  
2a79 f1			.pastdmark: pop af  
2a7a			endm  
# End of macro DMARK
2a7a					CALLMONITOR 
2a7a cd aa fd			call debug_vector  
2a7d				endm  
# End of macro CALLMONITOR
2a7d				endif 
2a7d			 
2a7d			; TODO Use os stack swap memory 
2a7d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a7d cd 53 22			call macro_dsp_valuehl 
2a80				endm 
# End of macro FORTH_DSP_VALUEHL
2a80 e5				push hl    ; n2 
2a81				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a81 cd 0b 23			call macro_forth_dsp_pop 
2a84				endm 
# End of macro FORTH_DSP_POP
2a84			 
2a84				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a84 cd 53 22			call macro_dsp_valuehl 
2a87				endm 
# End of macro FORTH_DSP_VALUEHL
2a87 e5				push hl    ; n1 
2a88				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a88 cd 0b 23			call macro_forth_dsp_pop 
2a8b				endm 
# End of macro FORTH_DSP_POP
2a8b			 
2a8b d1				pop de     ; n1 
2a8c e1				pop hl     ; n2 
2a8d			 
2a8d d5				push de 
2a8e e5				push hl 
2a8f d5				push de 
2a90			 
2a90				; push back  
2a90			 
2a90 e1				pop hl 
2a91 cd 5c 20			call forth_push_numhl 
2a94 e1				pop hl 
2a95 cd 5c 20			call forth_push_numhl 
2a98 e1				pop hl 
2a99 cd 5c 20			call forth_push_numhl 
2a9c				NEXTW 
2a9c c3 09 24			jp macro_next 
2a9f				endm 
# End of macro NEXTW
2a9f			 
2a9f			.PAUSE: 
2a9f			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2a9f 43				db WORD_SYS_CORE+47             
2aa0 d4 2a			dw .PAUSES            
2aa2 08				db 7 + 1 
2aa3 .. 00			db "PAUSEMS",0              
2aab				endm 
# End of macro CWHEAD
2aab			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2aab				if DEBUG_FORTH_WORDS_KEY 
2aab					DMARK "PMS" 
2aab f5				push af  
2aac 3a c0 2a			ld a, (.dmark)  
2aaf 32 a6 fd			ld (debug_mark),a  
2ab2 3a c1 2a			ld a, (.dmark+1)  
2ab5 32 a7 fd			ld (debug_mark+1),a  
2ab8 3a c2 2a			ld a, (.dmark+2)  
2abb 32 a8 fd			ld (debug_mark+2),a  
2abe 18 03			jr .pastdmark  
2ac0 ..			.dmark: db "PMS"  
2ac3 f1			.pastdmark: pop af  
2ac4			endm  
# End of macro DMARK
2ac4					CALLMONITOR 
2ac4 cd aa fd			call debug_vector  
2ac7				endm  
# End of macro CALLMONITOR
2ac7				endif 
2ac7				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ac7 cd 53 22			call macro_dsp_valuehl 
2aca				endm 
# End of macro FORTH_DSP_VALUEHL
2aca			;		push hl    ; n2 
2aca				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2aca cd 0b 23			call macro_forth_dsp_pop 
2acd				endm 
# End of macro FORTH_DSP_POP
2acd			;		pop hl 
2acd			 
2acd 7d				ld a, l 
2ace cd c3 0c			call aDelayInMS 
2ad1			       NEXTW 
2ad1 c3 09 24			jp macro_next 
2ad4				endm 
# End of macro NEXTW
2ad4			.PAUSES:  
2ad4			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2ad4 44				db WORD_SYS_CORE+48             
2ad5 43 2b			dw .ROT            
2ad7 06				db 5 + 1 
2ad8 .. 00			db "PAUSE",0              
2ade				endm 
# End of macro CWHEAD
2ade			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2ade				if DEBUG_FORTH_WORDS_KEY 
2ade					DMARK "PAU" 
2ade f5				push af  
2adf 3a f3 2a			ld a, (.dmark)  
2ae2 32 a6 fd			ld (debug_mark),a  
2ae5 3a f4 2a			ld a, (.dmark+1)  
2ae8 32 a7 fd			ld (debug_mark+1),a  
2aeb 3a f5 2a			ld a, (.dmark+2)  
2aee 32 a8 fd			ld (debug_mark+2),a  
2af1 18 03			jr .pastdmark  
2af3 ..			.dmark: db "PAU"  
2af6 f1			.pastdmark: pop af  
2af7			endm  
# End of macro DMARK
2af7					CALLMONITOR 
2af7 cd aa fd			call debug_vector  
2afa				endm  
# End of macro CALLMONITOR
2afa				endif 
2afa				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2afa cd 53 22			call macro_dsp_valuehl 
2afd				endm 
# End of macro FORTH_DSP_VALUEHL
2afd			;		push hl    ; n2 
2afd				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2afd cd 0b 23			call macro_forth_dsp_pop 
2b00				endm 
# End of macro FORTH_DSP_POP
2b00			;		pop hl 
2b00 45				ld b, l 
2b01				if DEBUG_FORTH_WORDS 
2b01					DMARK "PAU" 
2b01 f5				push af  
2b02 3a 16 2b			ld a, (.dmark)  
2b05 32 a6 fd			ld (debug_mark),a  
2b08 3a 17 2b			ld a, (.dmark+1)  
2b0b 32 a7 fd			ld (debug_mark+1),a  
2b0e 3a 18 2b			ld a, (.dmark+2)  
2b11 32 a8 fd			ld (debug_mark+2),a  
2b14 18 03			jr .pastdmark  
2b16 ..			.dmark: db "PAU"  
2b19 f1			.pastdmark: pop af  
2b1a			endm  
# End of macro DMARK
2b1a					CALLMONITOR 
2b1a cd aa fd			call debug_vector  
2b1d				endm  
# End of macro CALLMONITOR
2b1d				endif 
2b1d c5			.pauses1:	push bc 
2b1e cd de 0c			call delay1s 
2b21 c1				pop bc 
2b22				if DEBUG_FORTH_WORDS 
2b22					DMARK "PA1" 
2b22 f5				push af  
2b23 3a 37 2b			ld a, (.dmark)  
2b26 32 a6 fd			ld (debug_mark),a  
2b29 3a 38 2b			ld a, (.dmark+1)  
2b2c 32 a7 fd			ld (debug_mark+1),a  
2b2f 3a 39 2b			ld a, (.dmark+2)  
2b32 32 a8 fd			ld (debug_mark+2),a  
2b35 18 03			jr .pastdmark  
2b37 ..			.dmark: db "PA1"  
2b3a f1			.pastdmark: pop af  
2b3b			endm  
# End of macro DMARK
2b3b					CALLMONITOR 
2b3b cd aa fd			call debug_vector  
2b3e				endm  
# End of macro CALLMONITOR
2b3e				endif 
2b3e 10 dd			djnz .pauses1 
2b40			 
2b40			       NEXTW 
2b40 c3 09 24			jp macro_next 
2b43				endm 
# End of macro NEXTW
2b43			.ROT: 
2b43			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2b43 45				db WORD_SYS_CORE+49             
2b44 91 2b			dw .UWORDS            
2b46 04				db 3 + 1 
2b47 .. 00			db "ROT",0              
2b4b				endm 
# End of macro CWHEAD
2b4b			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2b4b				if DEBUG_FORTH_WORDS_KEY 
2b4b					DMARK "ROT" 
2b4b f5				push af  
2b4c 3a 60 2b			ld a, (.dmark)  
2b4f 32 a6 fd			ld (debug_mark),a  
2b52 3a 61 2b			ld a, (.dmark+1)  
2b55 32 a7 fd			ld (debug_mark+1),a  
2b58 3a 62 2b			ld a, (.dmark+2)  
2b5b 32 a8 fd			ld (debug_mark+2),a  
2b5e 18 03			jr .pastdmark  
2b60 ..			.dmark: db "ROT"  
2b63 f1			.pastdmark: pop af  
2b64			endm  
# End of macro DMARK
2b64					CALLMONITOR 
2b64 cd aa fd			call debug_vector  
2b67				endm  
# End of macro CALLMONITOR
2b67				endif 
2b67			 
2b67			; TODO Use os stack swap memory 
2b67				FORTH_DSP_VALUEHL 
2b67 cd 53 22			call macro_dsp_valuehl 
2b6a				endm 
# End of macro FORTH_DSP_VALUEHL
2b6a e5				push hl    ; u3  
2b6b			 
2b6b				FORTH_DSP_POP 
2b6b cd 0b 23			call macro_forth_dsp_pop 
2b6e				endm 
# End of macro FORTH_DSP_POP
2b6e			 
2b6e				FORTH_DSP_VALUEHL 
2b6e cd 53 22			call macro_dsp_valuehl 
2b71				endm 
# End of macro FORTH_DSP_VALUEHL
2b71 e5				push hl     ; u2 
2b72			 
2b72				FORTH_DSP_POP 
2b72 cd 0b 23			call macro_forth_dsp_pop 
2b75				endm 
# End of macro FORTH_DSP_POP
2b75			 
2b75				FORTH_DSP_VALUEHL 
2b75 cd 53 22			call macro_dsp_valuehl 
2b78				endm 
# End of macro FORTH_DSP_VALUEHL
2b78 e5				push hl     ; u1 
2b79			 
2b79				FORTH_DSP_POP 
2b79 cd 0b 23			call macro_forth_dsp_pop 
2b7c				endm 
# End of macro FORTH_DSP_POP
2b7c			 
2b7c c1				pop bc      ; u1 
2b7d e1				pop hl      ; u2 
2b7e d1				pop de      ; u3 
2b7f			 
2b7f			 
2b7f c5				push bc 
2b80 d5				push de 
2b81 e5				push hl 
2b82			 
2b82			 
2b82 e1				pop hl 
2b83 cd 5c 20			call forth_push_numhl 
2b86			 
2b86 e1				pop hl 
2b87 cd 5c 20			call forth_push_numhl 
2b8a			 
2b8a e1				pop hl 
2b8b cd 5c 20			call forth_push_numhl 
2b8e				 
2b8e			 
2b8e			 
2b8e			 
2b8e			 
2b8e			 
2b8e			       NEXTW 
2b8e c3 09 24			jp macro_next 
2b91				endm 
# End of macro NEXTW
2b91			 
2b91			.UWORDS: 
2b91			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2b91 50				db WORD_SYS_CORE+60             
2b92 53 2c			dw .BP            
2b94 07				db 6 + 1 
2b95 .. 00			db "UWORDS",0              
2b9c				endm 
# End of macro CWHEAD
2b9c			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2b9c			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2b9c			; | | Following the count are the individual words. 
2b9c			; | | 
2b9c			; | | e.g. UWORDS 
2b9c			; | | BOX DIRLIST 2 
2b9c			; | |  
2b9c			; | | Can be used to save the words to storage via: 
2b9c			; | | UWORDS $01 DO $01 APPEND LOOP 
2b9c			if DEBUG_FORTH_WORDS_KEY 
2b9c				DMARK "UWR" 
2b9c f5				push af  
2b9d 3a b1 2b			ld a, (.dmark)  
2ba0 32 a6 fd			ld (debug_mark),a  
2ba3 3a b2 2b			ld a, (.dmark+1)  
2ba6 32 a7 fd			ld (debug_mark+1),a  
2ba9 3a b3 2b			ld a, (.dmark+2)  
2bac 32 a8 fd			ld (debug_mark+2),a  
2baf 18 03			jr .pastdmark  
2bb1 ..			.dmark: db "UWR"  
2bb4 f1			.pastdmark: pop af  
2bb5			endm  
# End of macro DMARK
2bb5				CALLMONITOR 
2bb5 cd aa fd			call debug_vector  
2bb8				endm  
# End of macro CALLMONITOR
2bb8			endif 
2bb8 21 00 80			ld hl, baseram 
2bbb				;ld hl, baseusermem 
2bbb 01 00 00			ld bc, 0    ; start a counter 
2bbe			 
2bbe			; skip dict stub 
2bbe			 
2bbe cd 5a 25			call forth_tok_next 
2bc1			 
2bc1			 
2bc1			; while we have words to look for 
2bc1			 
2bc1 7e			.douscan:	ld a, (hl)      
2bc2			if DEBUG_FORTH_WORDS 
2bc2				DMARK "UWs" 
2bc2 f5				push af  
2bc3 3a d7 2b			ld a, (.dmark)  
2bc6 32 a6 fd			ld (debug_mark),a  
2bc9 3a d8 2b			ld a, (.dmark+1)  
2bcc 32 a7 fd			ld (debug_mark+1),a  
2bcf 3a d9 2b			ld a, (.dmark+2)  
2bd2 32 a8 fd			ld (debug_mark+2),a  
2bd5 18 03			jr .pastdmark  
2bd7 ..			.dmark: db "UWs"  
2bda f1			.pastdmark: pop af  
2bdb			endm  
# End of macro DMARK
2bdb				CALLMONITOR 
2bdb cd aa fd			call debug_vector  
2bde				endm  
# End of macro CALLMONITOR
2bde			endif 
2bde fe 00			cp WORD_SYS_END 
2be0 28 4d			jr z, .udone 
2be2 fe 01			cp WORD_SYS_UWORD 
2be4 20 44			jr nz, .nuword 
2be6			 
2be6			if DEBUG_FORTH_WORDS 
2be6				DMARK "UWu" 
2be6 f5				push af  
2be7 3a fb 2b			ld a, (.dmark)  
2bea 32 a6 fd			ld (debug_mark),a  
2bed 3a fc 2b			ld a, (.dmark+1)  
2bf0 32 a7 fd			ld (debug_mark+1),a  
2bf3 3a fd 2b			ld a, (.dmark+2)  
2bf6 32 a8 fd			ld (debug_mark+2),a  
2bf9 18 03			jr .pastdmark  
2bfb ..			.dmark: db "UWu"  
2bfe f1			.pastdmark: pop af  
2bff			endm  
# End of macro DMARK
2bff				CALLMONITOR 
2bff cd aa fd			call debug_vector  
2c02				endm  
# End of macro CALLMONITOR
2c02			endif 
2c02				; we have a uword so push its name to the stack 
2c02			 
2c02 e5				push hl  ; save so we can move to next dict block 
2c03			 
2c03				; skip opcode 
2c03 23				inc hl  
2c04				; skip next ptr 
2c04 23				inc hl  
2c05 23				inc hl 
2c06				; skip len 
2c06 23				inc hl 
2c07			if DEBUG_FORTH_WORDS 
2c07				DMARK "UWt" 
2c07 f5				push af  
2c08 3a 1c 2c			ld a, (.dmark)  
2c0b 32 a6 fd			ld (debug_mark),a  
2c0e 3a 1d 2c			ld a, (.dmark+1)  
2c11 32 a7 fd			ld (debug_mark+1),a  
2c14 3a 1e 2c			ld a, (.dmark+2)  
2c17 32 a8 fd			ld (debug_mark+2),a  
2c1a 18 03			jr .pastdmark  
2c1c ..			.dmark: db "UWt"  
2c1f f1			.pastdmark: pop af  
2c20			endm  
# End of macro DMARK
2c20				CALLMONITOR 
2c20 cd aa fd			call debug_vector  
2c23				endm  
# End of macro CALLMONITOR
2c23			endif 
2c23 03				inc bc 
2c24			 
2c24 c5				push bc 
2c25 cd ca 20			call forth_push_str 
2c28 c1				pop bc 
2c29			 
2c29 e1				pop hl 	 
2c2a			 
2c2a cd 5a 25		.nuword:	call forth_tok_next 
2c2d 18 92			jr .douscan  
2c2f			 
2c2f			.udone:		 ; push count of uwords found 
2c2f c5				push bc 
2c30 e1				pop hl 
2c31			 
2c31			if DEBUG_FORTH_WORDS 
2c31				DMARK "UWc" 
2c31 f5				push af  
2c32 3a 46 2c			ld a, (.dmark)  
2c35 32 a6 fd			ld (debug_mark),a  
2c38 3a 47 2c			ld a, (.dmark+1)  
2c3b 32 a7 fd			ld (debug_mark+1),a  
2c3e 3a 48 2c			ld a, (.dmark+2)  
2c41 32 a8 fd			ld (debug_mark+2),a  
2c44 18 03			jr .pastdmark  
2c46 ..			.dmark: db "UWc"  
2c49 f1			.pastdmark: pop af  
2c4a			endm  
# End of macro DMARK
2c4a				CALLMONITOR 
2c4a cd aa fd			call debug_vector  
2c4d				endm  
# End of macro CALLMONITOR
2c4d			endif 
2c4d cd 5c 20			call forth_push_numhl 
2c50			 
2c50			 
2c50			       NEXTW 
2c50 c3 09 24			jp macro_next 
2c53				endm 
# End of macro NEXTW
2c53			 
2c53			.BP: 
2c53			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2c53 54				db WORD_SYS_CORE+64             
2c54 8d 2c			dw .MONITOR            
2c56 03				db 2 + 1 
2c57 .. 00			db "BP",0              
2c5a				endm 
# End of macro CWHEAD
2c5a			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2c5a			; | | $00 Will enable the break points within specific code paths 
2c5a			; | | $01 Will disable break points 
2c5a			; | |  
2c5a			; | | By default break points are off. Either the above can be used to enable them 
2c5a			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2c5a			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2c5a			; | | can disable break points. Exiting will then continue boot process. 
2c5a				; get byte count 
2c5a				if DEBUG_FORTH_WORDS_KEY 
2c5a					DMARK "BP." 
2c5a f5				push af  
2c5b 3a 6f 2c			ld a, (.dmark)  
2c5e 32 a6 fd			ld (debug_mark),a  
2c61 3a 70 2c			ld a, (.dmark+1)  
2c64 32 a7 fd			ld (debug_mark+1),a  
2c67 3a 71 2c			ld a, (.dmark+2)  
2c6a 32 a8 fd			ld (debug_mark+2),a  
2c6d 18 03			jr .pastdmark  
2c6f ..			.dmark: db "BP."  
2c72 f1			.pastdmark: pop af  
2c73			endm  
# End of macro DMARK
2c73					CALLMONITOR 
2c73 cd aa fd			call debug_vector  
2c76				endm  
# End of macro CALLMONITOR
2c76				endif 
2c76			 
2c76				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c76 cd 53 22			call macro_dsp_valuehl 
2c79				endm 
# End of macro FORTH_DSP_VALUEHL
2c79			 
2c79			;		push hl 
2c79			 
2c79				; destroy value TOS 
2c79			 
2c79				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c79 cd 0b 23			call macro_forth_dsp_pop 
2c7c				endm 
# End of macro FORTH_DSP_POP
2c7c			 
2c7c			;		pop hl 
2c7c			 
2c7c 3e 00			ld a,0 
2c7e bd				cp l 
2c7f 28 06			jr z, .bpset 
2c81			;		ld a, '*' 
2c81 cd 9a 19			call bp_off 
2c84				NEXTW 
2c84 c3 09 24			jp macro_next 
2c87				endm 
# End of macro NEXTW
2c87			 
2c87			.bpset:	 
2c87				;	ld (os_view_disable), a 
2c87 cd 8e 19			call bp_on 
2c8a			 
2c8a			 
2c8a				NEXTW 
2c8a c3 09 24			jp macro_next 
2c8d				endm 
# End of macro NEXTW
2c8d			 
2c8d			 
2c8d			.MONITOR: 
2c8d			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2c8d 55				db WORD_SYS_CORE+65             
2c8e be 2c			dw .MALLOC            
2c90 08				db 7 + 1 
2c91 .. 00			db "MONITOR",0              
2c99				endm 
# End of macro CWHEAD
2c99			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2c99			; | | At start the current various registers will be displayed with contents. 
2c99			; | | Top right corner will show the most recent debug marker seen. 
2c99			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2c99			; | | and the return stack pointer (RSP). 
2c99			; | | Pressing: 
2c99			; | |    1 - Initial screen 
2c99			; | |    2 - Display a data dump of HL 
2c99			; | |    3 - Display a data dump of DE 
2c99			; | |    4 - Display a data dump of BC 
2c99			; | |    5 - Display a data dump of HL 
2c99			; | |    6 - Display a data dump of DSP 
2c99			; | |    7 - Display a data dump of RSP 
2c99			; | |    8 - Display a data dump of what is at DSP 
2c99			; | |    9 - Display a data dump of what is at RSP 
2c99			; | |    0 - Exit monitor and continue running. This will also enable break points 
2c99			; | |    * - Disable break points 
2c99			; | |    # - Enter traditional monitor mode 
2c99			; | | 
2c99			; | | Monitor Mode 
2c99			; | | ------------ 
2c99			; | | A prompt of '>' will be shown for various commands: 
2c99			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2c99			; | |    C - Continue display a data dump from the last set address 
2c99			; | |    M xxxx - Set start of memory edit at address xx 
2c99			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2c99			; | |    G xxxx - Exec code at specific address 
2c99			; | |    Q - Return to previous 
2c99				if DEBUG_FORTH_WORDS_KEY 
2c99					DMARK "MON" 
2c99 f5				push af  
2c9a 3a ae 2c			ld a, (.dmark)  
2c9d 32 a6 fd			ld (debug_mark),a  
2ca0 3a af 2c			ld a, (.dmark+1)  
2ca3 32 a7 fd			ld (debug_mark+1),a  
2ca6 3a b0 2c			ld a, (.dmark+2)  
2ca9 32 a8 fd			ld (debug_mark+2),a  
2cac 18 03			jr .pastdmark  
2cae ..			.dmark: db "MON"  
2cb1 f1			.pastdmark: pop af  
2cb2			endm  
# End of macro DMARK
2cb2					CALLMONITOR 
2cb2 cd aa fd			call debug_vector  
2cb5				endm  
# End of macro CALLMONITOR
2cb5				endif 
2cb5			;		ld a, 0 
2cb5			;		ld (os_view_disable), a 
2cb5 cd 8e 19			call bp_on 
2cb8			 
2cb8				CALLMONITOR 
2cb8 cd aa fd			call debug_vector  
2cbb				endm  
# End of macro CALLMONITOR
2cbb			 
2cbb			;	call monitor 
2cbb			 
2cbb				NEXTW 
2cbb c3 09 24			jp macro_next 
2cbe				endm 
# End of macro NEXTW
2cbe			 
2cbe			 
2cbe			.MALLOC: 
2cbe			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2cbe 56				db WORD_SYS_CORE+66             
2cbf e7 2c			dw .MALLOC2            
2cc1 06				db 5 + 1 
2cc2 .. 00			db "ALLOT",0              
2cc8				endm 
# End of macro CWHEAD
2cc8			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2cc8				if DEBUG_FORTH_WORDS_KEY 
2cc8					DMARK "ALL" 
2cc8 f5				push af  
2cc9 3a dd 2c			ld a, (.dmark)  
2ccc 32 a6 fd			ld (debug_mark),a  
2ccf 3a de 2c			ld a, (.dmark+1)  
2cd2 32 a7 fd			ld (debug_mark+1),a  
2cd5 3a df 2c			ld a, (.dmark+2)  
2cd8 32 a8 fd			ld (debug_mark+2),a  
2cdb 18 03			jr .pastdmark  
2cdd ..			.dmark: db "ALL"  
2ce0 f1			.pastdmark: pop af  
2ce1			endm  
# End of macro DMARK
2ce1					CALLMONITOR 
2ce1 cd aa fd			call debug_vector  
2ce4				endm  
# End of macro CALLMONITOR
2ce4				endif 
2ce4 c3 0e 2d			jp .mallocc 
2ce7			.MALLOC2: 
2ce7			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2ce7 56				db WORD_SYS_CORE+66             
2ce8 25 2d			dw .FREE            
2cea 07				db 6 + 1 
2ceb .. 00			db "MALLOC",0              
2cf2				endm 
# End of macro CWHEAD
2cf2			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2cf2				; get byte count 
2cf2				if DEBUG_FORTH_WORDS_KEY 
2cf2					DMARK "MAL" 
2cf2 f5				push af  
2cf3 3a 07 2d			ld a, (.dmark)  
2cf6 32 a6 fd			ld (debug_mark),a  
2cf9 3a 08 2d			ld a, (.dmark+1)  
2cfc 32 a7 fd			ld (debug_mark+1),a  
2cff 3a 09 2d			ld a, (.dmark+2)  
2d02 32 a8 fd			ld (debug_mark+2),a  
2d05 18 03			jr .pastdmark  
2d07 ..			.dmark: db "MAL"  
2d0a f1			.pastdmark: pop af  
2d0b			endm  
# End of macro DMARK
2d0b					CALLMONITOR 
2d0b cd aa fd			call debug_vector  
2d0e				endm  
# End of macro CALLMONITOR
2d0e				endif 
2d0e			.mallocc: 
2d0e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d0e cd 53 22			call macro_dsp_valuehl 
2d11				endm 
# End of macro FORTH_DSP_VALUEHL
2d11			 
2d11			;		push hl 
2d11			 
2d11				; destroy value TOS 
2d11			 
2d11				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d11 cd 0b 23			call macro_forth_dsp_pop 
2d14				endm 
# End of macro FORTH_DSP_POP
2d14			 
2d14			;		pop hl 
2d14 cd fb 13			call malloc 
2d17			if DEBUG_FORTH_MALLOC_GUARD 
2d17 f5				push af 
2d18 cd f8 0f			call ishlzero 
2d1b			;		ld a, l 
2d1b			;		add h 
2d1b			;		cp 0 
2d1b f1				pop af 
2d1c				 
2d1c cc dc 5d			call z,malloc_error 
2d1f			endif 
2d1f			 
2d1f cd 5c 20			call forth_push_numhl 
2d22				NEXTW 
2d22 c3 09 24			jp macro_next 
2d25				endm 
# End of macro NEXTW
2d25			 
2d25			.FREE: 
2d25			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2d25 57				db WORD_SYS_CORE+67             
2d26 56 2d			dw .LIST            
2d28 05				db 4 + 1 
2d29 .. 00			db "FREE",0              
2d2e				endm 
# End of macro CWHEAD
2d2e			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2d2e				if DEBUG_FORTH_WORDS_KEY 
2d2e					DMARK "FRE" 
2d2e f5				push af  
2d2f 3a 43 2d			ld a, (.dmark)  
2d32 32 a6 fd			ld (debug_mark),a  
2d35 3a 44 2d			ld a, (.dmark+1)  
2d38 32 a7 fd			ld (debug_mark+1),a  
2d3b 3a 45 2d			ld a, (.dmark+2)  
2d3e 32 a8 fd			ld (debug_mark+2),a  
2d41 18 03			jr .pastdmark  
2d43 ..			.dmark: db "FRE"  
2d46 f1			.pastdmark: pop af  
2d47			endm  
# End of macro DMARK
2d47					CALLMONITOR 
2d47 cd aa fd			call debug_vector  
2d4a				endm  
# End of macro CALLMONITOR
2d4a				endif 
2d4a				; get address 
2d4a			 
2d4a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d4a cd 53 22			call macro_dsp_valuehl 
2d4d				endm 
# End of macro FORTH_DSP_VALUEHL
2d4d			 
2d4d			;		push hl 
2d4d			 
2d4d				; destroy value TOS 
2d4d			 
2d4d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d4d cd 0b 23			call macro_forth_dsp_pop 
2d50				endm 
# End of macro FORTH_DSP_POP
2d50			 
2d50			;		pop hl 
2d50			if FORTH_ENABLE_MALLOCFREE 
2d50 cd c5 14			call free 
2d53			endif 
2d53				NEXTW 
2d53 c3 09 24			jp macro_next 
2d56				endm 
# End of macro NEXTW
2d56			.LIST: 
2d56			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2d56 5c				db WORD_SYS_CORE+72             
2d57 46 2f			dw .FORGET            
2d59 05				db 4 + 1 
2d5a .. 00			db "LIST",0              
2d5f				endm 
# End of macro CWHEAD
2d5f			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2d5f			; | | The quoted word must be in upper case. 
2d5f			if DEBUG_FORTH_WORDS_KEY 
2d5f				DMARK "LST" 
2d5f f5				push af  
2d60 3a 74 2d			ld a, (.dmark)  
2d63 32 a6 fd			ld (debug_mark),a  
2d66 3a 75 2d			ld a, (.dmark+1)  
2d69 32 a7 fd			ld (debug_mark+1),a  
2d6c 3a 76 2d			ld a, (.dmark+2)  
2d6f 32 a8 fd			ld (debug_mark+2),a  
2d72 18 03			jr .pastdmark  
2d74 ..			.dmark: db "LST"  
2d77 f1			.pastdmark: pop af  
2d78			endm  
# End of macro DMARK
2d78				CALLMONITOR 
2d78 cd aa fd			call debug_vector  
2d7b				endm  
# End of macro CALLMONITOR
2d7b			endif 
2d7b			 
2d7b				FORTH_DSP_VALUEHL 
2d7b cd 53 22			call macro_dsp_valuehl 
2d7e				endm 
# End of macro FORTH_DSP_VALUEHL
2d7e			 
2d7e e5				push hl 
2d7f				FORTH_DSP_POP 
2d7f cd 0b 23			call macro_forth_dsp_pop 
2d82				endm 
# End of macro FORTH_DSP_POP
2d82 c1				pop bc 
2d83			 
2d83			; Start format of scratch string 
2d83			 
2d83 21 fc f0			ld hl, scratch 
2d86			 
2d86 3e 3a			ld a, ':' 
2d88 77				ld (hl),a 
2d89 23				inc hl 
2d8a 3e 20			ld a, ' ' 
2d8c 77				ld (hl), a 
2d8d			 
2d8d				; Get ptr to the word we need to look up 
2d8d			 
2d8d			;		FORTH_DSP_VALUEHL 
2d8d				;v5 FORTH_DSP_VALUE 
2d8d			; TODO type check 
2d8d			;		inc hl    ; Skip type check  
2d8d			;		push hl 
2d8d			;		ex de, hl    ; put into DE 
2d8d			 
2d8d			 
2d8d 21 00 80			ld hl, baseram 
2d90				;ld hl, baseusermem 
2d90			 
2d90 e5			push hl   ; sacreifical push 
2d91			 
2d91			.ldouscanm: 
2d91 e1			pop hl 
2d92			.ldouscan: 
2d92			if DEBUG_FORTH_WORDS 
2d92				DMARK "LSs" 
2d92 f5				push af  
2d93 3a a7 2d			ld a, (.dmark)  
2d96 32 a6 fd			ld (debug_mark),a  
2d99 3a a8 2d			ld a, (.dmark+1)  
2d9c 32 a7 fd			ld (debug_mark+1),a  
2d9f 3a a9 2d			ld a, (.dmark+2)  
2da2 32 a8 fd			ld (debug_mark+2),a  
2da5 18 03			jr .pastdmark  
2da7 ..			.dmark: db "LSs"  
2daa f1			.pastdmark: pop af  
2dab			endm  
# End of macro DMARK
2dab				CALLMONITOR 
2dab cd aa fd			call debug_vector  
2dae				endm  
# End of macro CALLMONITOR
2dae			endif 
2dae			; skip dict stub 
2dae cd 5a 25			call forth_tok_next 
2db1			 
2db1			 
2db1			; while we have words to look for 
2db1			 
2db1 7e			ld a, (hl)      
2db2			if DEBUG_FORTH_WORDS 
2db2				DMARK "LSk" 
2db2 f5				push af  
2db3 3a c7 2d			ld a, (.dmark)  
2db6 32 a6 fd			ld (debug_mark),a  
2db9 3a c8 2d			ld a, (.dmark+1)  
2dbc 32 a7 fd			ld (debug_mark+1),a  
2dbf 3a c9 2d			ld a, (.dmark+2)  
2dc2 32 a8 fd			ld (debug_mark+2),a  
2dc5 18 03			jr .pastdmark  
2dc7 ..			.dmark: db "LSk"  
2dca f1			.pastdmark: pop af  
2dcb			endm  
# End of macro DMARK
2dcb				CALLMONITOR 
2dcb cd aa fd			call debug_vector  
2dce				endm  
# End of macro CALLMONITOR
2dce			endif 
2dce				;cp WORD_SYS_END 
2dce				;jp z, .lunotfound 
2dce			 
2dce					; if we hit non uwords then gone too far 
2dce fe 01				cp WORD_SYS_UWORD 
2dd0 c2 02 2f				jp nz, .lunotfound 
2dd3			 
2dd3				if DEBUG_FORTH_WORDS 
2dd3					DMARK "LSu" 
2dd3 f5				push af  
2dd4 3a e8 2d			ld a, (.dmark)  
2dd7 32 a6 fd			ld (debug_mark),a  
2dda 3a e9 2d			ld a, (.dmark+1)  
2ddd 32 a7 fd			ld (debug_mark+1),a  
2de0 3a ea 2d			ld a, (.dmark+2)  
2de3 32 a8 fd			ld (debug_mark+2),a  
2de6 18 03			jr .pastdmark  
2de8 ..			.dmark: db "LSu"  
2deb f1			.pastdmark: pop af  
2dec			endm  
# End of macro DMARK
2dec					CALLMONITOR 
2dec cd aa fd			call debug_vector  
2def				endm  
# End of macro CALLMONITOR
2def				endif 
2def			 
2def					; found a uword but is it the one we want... 
2def			 
2def c5					push bc     ; uword to find is on bc 
2df0 d1					pop de 
2df1			 
2df1 e5					push hl  ; to save the ptr 
2df2			 
2df2					; skip opcode 
2df2 23					inc hl  
2df3					; skip next ptr 
2df3 23					inc hl  
2df4 23					inc hl 
2df5					; skip len 
2df5 23					inc hl 
2df6			 
2df6				if DEBUG_FORTH_WORDS 
2df6					DMARK "LSc" 
2df6 f5				push af  
2df7 3a 0b 2e			ld a, (.dmark)  
2dfa 32 a6 fd			ld (debug_mark),a  
2dfd 3a 0c 2e			ld a, (.dmark+1)  
2e00 32 a7 fd			ld (debug_mark+1),a  
2e03 3a 0d 2e			ld a, (.dmark+2)  
2e06 32 a8 fd			ld (debug_mark+2),a  
2e09 18 03			jr .pastdmark  
2e0b ..			.dmark: db "LSc"  
2e0e f1			.pastdmark: pop af  
2e0f			endm  
# End of macro DMARK
2e0f					CALLMONITOR 
2e0f cd aa fd			call debug_vector  
2e12				endm  
# End of macro CALLMONITOR
2e12				endif 
2e12			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2e12			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2e12			; Nope that has gone the other way. It needs to be exact not on first zero 
2e12			;		call strcmp 
2e12 c5					push bc 
2e13 cd cb 13				call StrictStrCmp 
2e16 c1					pop bc 
2e17 c2 91 2d				jp nz, .ldouscanm 
2e1a				 
2e1a			 
2e1a			 
2e1a					; we have a uword so push its name to the stack 
2e1a			 
2e1a			;	   	push hl  ; save so we can move to next dict block 
2e1a e1			pop hl 
2e1b			 
2e1b				if DEBUG_FORTH_WORDS 
2e1b					DMARK "LSm" 
2e1b f5				push af  
2e1c 3a 30 2e			ld a, (.dmark)  
2e1f 32 a6 fd			ld (debug_mark),a  
2e22 3a 31 2e			ld a, (.dmark+1)  
2e25 32 a7 fd			ld (debug_mark+1),a  
2e28 3a 32 2e			ld a, (.dmark+2)  
2e2b 32 a8 fd			ld (debug_mark+2),a  
2e2e 18 03			jr .pastdmark  
2e30 ..			.dmark: db "LSm"  
2e33 f1			.pastdmark: pop af  
2e34			endm  
# End of macro DMARK
2e34					CALLMONITOR 
2e34 cd aa fd			call debug_vector  
2e37				endm  
# End of macro CALLMONITOR
2e37				endif 
2e37			 
2e37					; skip opcode 
2e37 23					inc hl  
2e38					; skip next ptr 
2e38 23					inc hl  
2e39 23					inc hl 
2e3a					; skip len 
2e3a 7e					ld a, (hl)   ; save length to add 
2e3b				if DEBUG_FORTH_WORDS 
2e3b					DMARK "LS2" 
2e3b f5				push af  
2e3c 3a 50 2e			ld a, (.dmark)  
2e3f 32 a6 fd			ld (debug_mark),a  
2e42 3a 51 2e			ld a, (.dmark+1)  
2e45 32 a7 fd			ld (debug_mark+1),a  
2e48 3a 52 2e			ld a, (.dmark+2)  
2e4b 32 a8 fd			ld (debug_mark+2),a  
2e4e 18 03			jr .pastdmark  
2e50 ..			.dmark: db "LS2"  
2e53 f1			.pastdmark: pop af  
2e54			endm  
# End of macro DMARK
2e54					CALLMONITOR 
2e54 cd aa fd			call debug_vector  
2e57				endm  
# End of macro CALLMONITOR
2e57				endif 
2e57			 
2e57					; save this location 
2e57				 
2e57 e5					push hl 
2e58			 
2e58 23					inc hl 
2e59 11 fe f0				ld de, scratch+2 
2e5c 4f					ld c, a 
2e5d 06 00				ld b, 0 
2e5f			 
2e5f				if DEBUG_FORTH_WORDS 
2e5f					DMARK "LSn" 
2e5f f5				push af  
2e60 3a 74 2e			ld a, (.dmark)  
2e63 32 a6 fd			ld (debug_mark),a  
2e66 3a 75 2e			ld a, (.dmark+1)  
2e69 32 a7 fd			ld (debug_mark+1),a  
2e6c 3a 76 2e			ld a, (.dmark+2)  
2e6f 32 a8 fd			ld (debug_mark+2),a  
2e72 18 03			jr .pastdmark  
2e74 ..			.dmark: db "LSn"  
2e77 f1			.pastdmark: pop af  
2e78			endm  
# End of macro DMARK
2e78					CALLMONITOR 
2e78 cd aa fd			call debug_vector  
2e7b				endm  
# End of macro CALLMONITOR
2e7b				endif 
2e7b			 
2e7b					; copy uword name to scratch 
2e7b			 
2e7b ed b0				ldir 
2e7d			 
2e7d 1b					dec de 
2e7e 3e 20				ld a, ' '    ; change null to space 
2e80 12					ld (de), a 
2e81			 
2e81 13					inc de 
2e82			 
2e82 d5					push de 
2e83 c1					pop bc     ; move scratch pointer to end of word name and save it 
2e84			 
2e84 e1					pop hl 
2e85 7e					ld a, (hl) 
2e86					;inc hl 
2e86					; skip word string 
2e86 cd cf 0f				call addatohl 
2e89			 
2e89 23					inc hl 
2e8a			 
2e8a				if DEBUG_FORTH_WORDS 
2e8a					DMARK "LS3" 
2e8a f5				push af  
2e8b 3a 9f 2e			ld a, (.dmark)  
2e8e 32 a6 fd			ld (debug_mark),a  
2e91 3a a0 2e			ld a, (.dmark+1)  
2e94 32 a7 fd			ld (debug_mark+1),a  
2e97 3a a1 2e			ld a, (.dmark+2)  
2e9a 32 a8 fd			ld (debug_mark+2),a  
2e9d 18 03			jr .pastdmark  
2e9f ..			.dmark: db "LS3"  
2ea2 f1			.pastdmark: pop af  
2ea3			endm  
# End of macro DMARK
2ea3					CALLMONITOR 
2ea3 cd aa fd			call debug_vector  
2ea6				endm  
# End of macro CALLMONITOR
2ea6				endif 
2ea6					; should now be at the start of the machine code to setup the eval of the uword 
2ea6					; now locate the ptr to the string defintion 
2ea6			 
2ea6					; skip ld hl, 
2ea6					; then load the ptr 
2ea6			; TODO use get from hl ptr 
2ea6 23					inc hl 
2ea7 5e					ld e, (hl) 
2ea8 23					inc hl 
2ea9 56					ld d, (hl) 
2eaa eb					ex de, hl 
2eab			 
2eab			 
2eab				if DEBUG_FORTH_WORDS 
2eab					DMARK "LSt" 
2eab f5				push af  
2eac 3a c0 2e			ld a, (.dmark)  
2eaf 32 a6 fd			ld (debug_mark),a  
2eb2 3a c1 2e			ld a, (.dmark+1)  
2eb5 32 a7 fd			ld (debug_mark+1),a  
2eb8 3a c2 2e			ld a, (.dmark+2)  
2ebb 32 a8 fd			ld (debug_mark+2),a  
2ebe 18 03			jr .pastdmark  
2ec0 ..			.dmark: db "LSt"  
2ec3 f1			.pastdmark: pop af  
2ec4			endm  
# End of macro DMARK
2ec4					CALLMONITOR 
2ec4 cd aa fd			call debug_vector  
2ec7				endm  
# End of macro CALLMONITOR
2ec7				endif 
2ec7			 
2ec7			; cant push right now due to tokenised strings  
2ec7			 
2ec7			; get the destination of where to copy this definition to. 
2ec7			 
2ec7 c5					push bc 
2ec8 d1					pop de 
2ec9			 
2ec9 7e			.listl:         ld a,(hl) 
2eca fe 00				cp 0 
2ecc 28 09				jr z, .lreplsp     ; replace zero with space 
2ece					;cp FORTH_END_BUFFER 
2ece fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2ed0 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2ed2				 
2ed2					; just copy this char as is then 
2ed2			 
2ed2 12					ld (de), a 
2ed3			 
2ed3 23			.listnxt:	inc hl 
2ed4 13					inc de 
2ed5 18 f2				jr .listl 
2ed7			 
2ed7 3e 20		.lreplsp:	ld a,' ' 
2ed9 12					ld (de), a 
2eda 18 f7				jr .listnxt 
2edc			 
2edc			; close up uword def 
2edc			 
2edc			.listdone: 
2edc 12					ld (de), a 
2edd 13					inc de 
2ede 3e 00				ld a, 0 
2ee0 12					ld (de), a 
2ee1			 
2ee1			; now have def so clean up and push to stack 
2ee1			 
2ee1 21 fc f0				ld hl, scratch 
2ee4				if DEBUG_FORTH_WORDS 
2ee4					DMARK "Ltp" 
2ee4 f5				push af  
2ee5 3a f9 2e			ld a, (.dmark)  
2ee8 32 a6 fd			ld (debug_mark),a  
2eeb 3a fa 2e			ld a, (.dmark+1)  
2eee 32 a7 fd			ld (debug_mark+1),a  
2ef1 3a fb 2e			ld a, (.dmark+2)  
2ef4 32 a8 fd			ld (debug_mark+2),a  
2ef7 18 03			jr .pastdmark  
2ef9 ..			.dmark: db "Ltp"  
2efc f1			.pastdmark: pop af  
2efd			endm  
# End of macro DMARK
2efd					CALLMONITOR 
2efd cd aa fd			call debug_vector  
2f00				endm  
# End of macro CALLMONITOR
2f00				endif 
2f00			 
2f00 18 1f			jr .listpush 
2f02			 
2f02			;.lnuword:	pop hl 
2f02			;		call forth_tok_next 
2f02			;		jp .ldouscan  
2f02			 
2f02			.lunotfound:		  
2f02			 
2f02				if DEBUG_FORTH_WORDS 
2f02					DMARK "LSn" 
2f02 f5				push af  
2f03 3a 17 2f			ld a, (.dmark)  
2f06 32 a6 fd			ld (debug_mark),a  
2f09 3a 18 2f			ld a, (.dmark+1)  
2f0c 32 a7 fd			ld (debug_mark+1),a  
2f0f 3a 19 2f			ld a, (.dmark+2)  
2f12 32 a8 fd			ld (debug_mark+2),a  
2f15 18 03			jr .pastdmark  
2f17 ..			.dmark: db "LSn"  
2f1a f1			.pastdmark: pop af  
2f1b			endm  
# End of macro DMARK
2f1b					CALLMONITOR 
2f1b cd aa fd			call debug_vector  
2f1e				endm  
# End of macro CALLMONITOR
2f1e				endif 
2f1e			 
2f1e					 
2f1e			;		FORTH_DSP_POP 
2f1e			;		ld hl, .luno 
2f1e			 
2f1e					NEXTW			 
2f1e c3 09 24			jp macro_next 
2f21				endm 
# End of macro NEXTW
2f21			 
2f21			.listpush: 
2f21				if DEBUG_FORTH_WORDS 
2f21					DMARK "LS>" 
2f21 f5				push af  
2f22 3a 36 2f			ld a, (.dmark)  
2f25 32 a6 fd			ld (debug_mark),a  
2f28 3a 37 2f			ld a, (.dmark+1)  
2f2b 32 a7 fd			ld (debug_mark+1),a  
2f2e 3a 38 2f			ld a, (.dmark+2)  
2f31 32 a8 fd			ld (debug_mark+2),a  
2f34 18 03			jr .pastdmark  
2f36 ..			.dmark: db "LS>"  
2f39 f1			.pastdmark: pop af  
2f3a			endm  
# End of macro DMARK
2f3a					CALLMONITOR 
2f3a cd aa fd			call debug_vector  
2f3d				endm  
# End of macro CALLMONITOR
2f3d				endif 
2f3d cd ca 20				call forth_push_str 
2f40			 
2f40			 
2f40			 
2f40					NEXTW 
2f40 c3 09 24			jp macro_next 
2f43				endm 
# End of macro NEXTW
2f43			 
2f43			;.luno:    db "Word not found",0 
2f43			 
2f43			 
2f43			 
2f43			 
2f43			 
2f43			;		push hl   ; save pointer to start of uword def string 
2f43			; 
2f43			;; look for FORTH_EOL_LINE 
2f43			;		ld a, FORTH_END_BUFFER 
2f43			;		call strlent 
2f43			; 
2f43			;		inc hl		 ; space for coln def 
2f43			;		inc hl 
2f43			;		inc hl          ; space for terms 
2f43			;		inc hl 
2f43			; 
2f43			;		ld a, 20   ; TODO get actual length 
2f43			;		call addatohl    ; include a random amount of room for the uword name 
2f43			; 
2f43			;		 
2f43			;	if DEBUG_FORTH_WORDS 
2f43			;		DMARK "Lt1" 
2f43			;		CALLMONITOR 
2f43			;	endif 
2f43			;		 
2f43			; 
2f43			;; malloc space for the string because we cant change it 
2f43			; 
2f43			;		call malloc 
2f43			;	if DEBUG_FORTH_MALLOC_GUARD 
2f43			;		push af 
2f43			;		call ishlzero 
2f43			;		pop af 
2f43			;		 
2f43			;		call z,malloc_error 
2f43			;	endif 
2f43			; 
2f43			;	if DEBUG_FORTH_WORDS 
2f43			;		DMARK "Lt2" 
2f43			;		CALLMONITOR 
2f43			;	endif 
2f43			;		pop de 
2f43			;		push hl    ; push the malloc to release later 
2f43			;		push hl   ;  push back a copy for the later stack push 
2f43			;		 
2f43			;; copy the string swapping out the zero terms for spaces 
2f43			; 
2f43			;		; de has our source 
2f43			;		; hl has our dest 
2f43			; 
2f43			;; add the coln def 
2f43			; 
2f43			;		ld a, ':' 
2f43			;		ld (hl), a 
2f43			;		inc hl 
2f43			;		ld a, ' ' 
2f43			;		ld (hl), a 
2f43			;		inc hl 
2f43			; 
2f43			;; add the uname word 
2f43			;		push de   ; save our string for now 
2f43			;		ex de, hl 
2f43			; 
2f43			;		FORTH_DSP_VALUE 
2f43			;		;v5 FORTH_DSP_VALUE 
2f43			; 
2f43			;		inc hl   ; skip type but we know by now this is OK 
2f43			; 
2f43			;.luword:	ld a,(hl) 
2f43			;		cp 0 
2f43			;		jr z, .luword2 
2f43			;		ld (de), a 
2f43			;		inc de 
2f43			;		inc hl 
2f43			;		jr .luword 
2f43			; 
2f43			;.luword2:	ld a, ' ' 
2f43			;		ld (de), a 
2f43			;;		inc hl 
2f43			;;		inc de 
2f43			;;		ld (de), a 
2f43			;;		inc hl 
2f43			;		inc de 
2f43			; 
2f43			;		ex de, hl 
2f43			;		pop de 
2f43			;		 
2f43			;		 
2f43			; 
2f43			;; detoken that string and copy it 
2f43			; 
2f43			;	if DEBUG_FORTH_WORDS 
2f43			;		DMARK "Lt2" 
2f43			;		CALLMONITOR 
2f43			;	endif 
2f43			;.ldetok:	ld a, (de) 
2f43			;		cp FORTH_END_BUFFER 
2f43			;		jr z, .ldetokend 
2f43			;		; swap out any zero term for space 
2f43			;		cp 0 
2f43			;		jr nz, .ldetoknext 
2f43			;		ld a, ' ' 
2f43			; 
2f43			;	if DEBUG_FORTH_WORDS 
2f43			;		DMARK "LtS" 
2f43			;		CALLMONITOR 
2f43			;	endif 
2f43			;.ldetoknext:	ld (hl), a 
2f43			;		inc de 
2f43			;		inc hl 
2f43			;		jr .ldetok 
2f43			; 
2f43			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2f43			;		ld (hl), a  
2f43			; 
2f43			;; free that temp malloc 
2f43			; 
2f43			;		pop hl    
2f43			; 
2f43			;	if DEBUG_FORTH_WORDS 
2f43			;		DMARK "Lt4" 
2f43			;		CALLMONITOR 
2f43			;	endif 
2f43			;		call forth_apushstrhl 
2f43			; 
2f43			;		; get rid of temp malloc area 
2f43			; 
2f43			;		pop hl 
2f43			;		call free 
2f43			; 
2f43			;		jr .ludone 
2f43			; 
2f43			;.lnuword:	pop hl 
2f43			;		call forth_tok_next 
2f43			;		jp .ldouscan  
2f43			; 
2f43			;.ludone:		 pop hl 
2f43			; 
2f43					NEXTW 
2f43 c3 09 24			jp macro_next 
2f46				endm 
# End of macro NEXTW
2f46			 
2f46			.FORGET: 
2f46				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2f46 5d				db WORD_SYS_CORE+73             
2f47 bf 2f			dw .NOP            
2f49 07				db 6 + 1 
2f4a .. 00			db "FORGET",0              
2f51				endm 
# End of macro CWHEAD
2f51			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2f51			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2f51			; | |  
2f51			; | | e.g. "MORE" forget 
2f51					if DEBUG_FORTH_WORDS_KEY 
2f51						DMARK "FRG" 
2f51 f5				push af  
2f52 3a 66 2f			ld a, (.dmark)  
2f55 32 a6 fd			ld (debug_mark),a  
2f58 3a 67 2f			ld a, (.dmark+1)  
2f5b 32 a7 fd			ld (debug_mark+1),a  
2f5e 3a 68 2f			ld a, (.dmark+2)  
2f61 32 a8 fd			ld (debug_mark+2),a  
2f64 18 03			jr .pastdmark  
2f66 ..			.dmark: db "FRG"  
2f69 f1			.pastdmark: pop af  
2f6a			endm  
# End of macro DMARK
2f6a						CALLMONITOR 
2f6a cd aa fd			call debug_vector  
2f6d				endm  
# End of macro CALLMONITOR
2f6d					endif 
2f6d			 
2f6d				; find uword 
2f6d			        ; update start of word with "_" 
2f6d				; replace uword with deleted flag 
2f6d			 
2f6d			 
2f6d			;	if DEBUG_FORTH_WORDS 
2f6d			;		DMARK "FOG" 
2f6d			;		CALLMONITOR 
2f6d			;	endif 
2f6d			 
2f6d			 
2f6d					; Get ptr to the word we need to look up 
2f6d			 
2f6d					FORTH_DSP_VALUEHL 
2f6d cd 53 22			call macro_dsp_valuehl 
2f70				endm 
# End of macro FORTH_DSP_VALUEHL
2f70					;v5 FORTH_DSP_VALUE 
2f70				; TODO type check 
2f70			;		inc hl    ; Skip type check  
2f70 e5					push hl 
2f71 c1					pop bc 
2f72			;		ex de, hl    ; put into DE 
2f72			 
2f72			 
2f72 21 00 80				ld hl, baseram 
2f75					;ld hl, baseusermem 
2f75			 
2f75				; skip dict stub 
2f75			;	call forth_tok_next 
2f75 e5			push hl   ; sacreifical push 
2f76			 
2f76			.fldouscanm: 
2f76 e1				pop hl 
2f77			.fldouscan: 
2f77			;	if DEBUG_FORTH_WORDS 
2f77			;		DMARK "LSs" 
2f77			;		CALLMONITOR 
2f77			;	endif 
2f77				; skip dict stub 
2f77 cd 5a 25				call forth_tok_next 
2f7a			 
2f7a			 
2f7a			; while we have words to look for 
2f7a			 
2f7a 7e				ld a, (hl)      
2f7b			;	if DEBUG_FORTH_WORDS 
2f7b			;		DMARK "LSk" 
2f7b			;		CALLMONITOR 
2f7b			;	endif 
2f7b fe 00				cp WORD_SYS_END 
2f7d ca b9 2f				jp z, .flunotfound 
2f80 fe 01				cp WORD_SYS_UWORD 
2f82 c2 77 2f				jp nz, .fldouscan 
2f85			 
2f85			;	if DEBUG_FORTH_WORDS 
2f85			;		DMARK "LSu" 
2f85			;		CALLMONITOR 
2f85			;	endif 
2f85			 
2f85					; found a uword but is it the one we want... 
2f85			 
2f85 c5					push bc     ; uword to find is on bc 
2f86 d1					pop de 
2f87			 
2f87 e5					push hl  ; to save the ptr 
2f88			 
2f88					; skip opcode 
2f88 23					inc hl  
2f89					; skip next ptr 
2f89 23					inc hl  
2f8a 23					inc hl 
2f8b					; skip len 
2f8b 23					inc hl 
2f8c			 
2f8c			;	if DEBUG_FORTH_WORDS 
2f8c			;		DMARK "LSc" 
2f8c			;		CALLMONITOR 
2f8c			;	endif 
2f8c cd be 13				call strcmp 
2f8f c2 76 2f				jp nz, .fldouscanm 
2f92			; 
2f92			; 
2f92			;; while we have words to look for 
2f92			; 
2f92			;.fdouscan:	ld a, (hl)      
2f92			;	if DEBUG_FORTH_WORDS 
2f92			;		DMARK "LSs" 
2f92			;		CALLMONITOR 
2f92			;	endif 
2f92			;		cp WORD_SYS_END 
2f92			;		jp z, .fudone 
2f92			;		cp WORD_SYS_UWORD 
2f92			;		jp nz, .fnuword 
2f92			; 
2f92			;	if DEBUG_FORTH_WORDS 
2f92			;		DMARK "FGu" 
2f92			;		CALLMONITOR 
2f92			;	endif 
2f92			; 
2f92			;		; found a uword but is it the one we want... 
2f92			; 
2f92			; 
2f92			;	        pop de   ; get back the dsp name 
2f92			;		push de 
2f92			; 
2f92			;		push hl  ; to save the ptr 
2f92			; 
2f92			;		; skip opcode 
2f92			;		inc hl  
2f92			;		; skip next ptr 
2f92			;		inc hl  
2f92			;		inc hl 
2f92			;		; skip len 
2f92			;		inc hl 
2f92			; 
2f92			;	if DEBUG_FORTH_WORDS 
2f92			;		DMARK "FGc" 
2f92			;		CALLMONITOR 
2f92			;	endif 
2f92			;		call strcmp 
2f92			;		jp nz, .fnuword 
2f92			 
2f92			 
2f92 e1			pop hl 
2f93			 
2f93				 
2f93				if DEBUG_FORTH_WORDS 
2f93					DMARK "FGm" 
2f93 f5				push af  
2f94 3a a8 2f			ld a, (.dmark)  
2f97 32 a6 fd			ld (debug_mark),a  
2f9a 3a a9 2f			ld a, (.dmark+1)  
2f9d 32 a7 fd			ld (debug_mark+1),a  
2fa0 3a aa 2f			ld a, (.dmark+2)  
2fa3 32 a8 fd			ld (debug_mark+2),a  
2fa6 18 03			jr .pastdmark  
2fa8 ..			.dmark: db "FGm"  
2fab f1			.pastdmark: pop af  
2fac			endm  
# End of macro DMARK
2fac					CALLMONITOR 
2fac cd aa fd			call debug_vector  
2faf				endm  
# End of macro CALLMONITOR
2faf				endif 
2faf			 
2faf			 
2faf			 
2faf					; we have a uword so push its name to the stack 
2faf			 
2faf			;	   	push hl  ; save so we can move to next dict block 
2faf			;pop hl 
2faf			 
2faf					; update opcode to deleted 
2faf 3e 03				ld a, WORD_SYS_DELETED 
2fb1 77					ld (hl), a 
2fb2			 
2fb2 23					inc hl  
2fb3					; skip next ptr 
2fb3 23					inc hl  
2fb4 23					inc hl 
2fb5					; skip len 
2fb5 23					inc hl 
2fb6			 
2fb6					; TODO change parser to skip deleted words but for now mark it out 
2fb6 3e 5f				ld a, "_" 
2fb8 77					ld  (hl),a 
2fb9			 
2fb9			;		jr .fudone 
2fb9			; 
2fb9			;.fnuword:	pop hl 
2fb9			;		call forth_tok_next 
2fb9			;		jp .fdouscan  
2fb9			 
2fb9			.flunotfound:		  
2fb9			 
2fb9			 
2fb9					 
2fb9					FORTH_DSP_POP 
2fb9 cd 0b 23			call macro_forth_dsp_pop 
2fbc				endm 
# End of macro FORTH_DSP_POP
2fbc			;		ld hl, .luno 
2fbc			;.fudone:		 pop hl 
2fbc					NEXTW 
2fbc c3 09 24			jp macro_next 
2fbf				endm 
# End of macro NEXTW
2fbf			.NOP: 
2fbf				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2fbf 61				db WORD_SYS_CORE+77             
2fc0 e6 2f			dw .COMO            
2fc2 04				db 3 + 1 
2fc3 .. 00			db "NOP",0              
2fc7				endm 
# End of macro CWHEAD
2fc7			; | NOP (  --  ) Do nothing | DONE 
2fc7					if DEBUG_FORTH_WORDS_KEY 
2fc7						DMARK "NOP" 
2fc7 f5				push af  
2fc8 3a dc 2f			ld a, (.dmark)  
2fcb 32 a6 fd			ld (debug_mark),a  
2fce 3a dd 2f			ld a, (.dmark+1)  
2fd1 32 a7 fd			ld (debug_mark+1),a  
2fd4 3a de 2f			ld a, (.dmark+2)  
2fd7 32 a8 fd			ld (debug_mark+2),a  
2fda 18 03			jr .pastdmark  
2fdc ..			.dmark: db "NOP"  
2fdf f1			.pastdmark: pop af  
2fe0			endm  
# End of macro DMARK
2fe0						CALLMONITOR 
2fe0 cd aa fd			call debug_vector  
2fe3				endm  
# End of macro CALLMONITOR
2fe3					endif 
2fe3				       NEXTW 
2fe3 c3 09 24			jp macro_next 
2fe6				endm 
# End of macro NEXTW
2fe6			.COMO: 
2fe6				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2fe6 6e				db WORD_SYS_CORE+90             
2fe7 38 30			dw .COMC            
2fe9 02				db 1 + 1 
2fea .. 00			db "(",0              
2fec				endm 
# End of macro CWHEAD
2fec			; | ( ( -- )  Start of comment | DONE 
2fec			 
2fec			 
2fec 2a fd f3				ld hl, ( os_tok_ptr) 
2fef 11 33 30			ld de, .closepar 
2ff2					 
2ff2					if DEBUG_FORTH_WORDS 
2ff2						DMARK ").." 
2ff2 f5				push af  
2ff3 3a 07 30			ld a, (.dmark)  
2ff6 32 a6 fd			ld (debug_mark),a  
2ff9 3a 08 30			ld a, (.dmark+1)  
2ffc 32 a7 fd			ld (debug_mark+1),a  
2fff 3a 09 30			ld a, (.dmark+2)  
3002 32 a8 fd			ld (debug_mark+2),a  
3005 18 03			jr .pastdmark  
3007 ..			.dmark: db ").."  
300a f1			.pastdmark: pop af  
300b			endm  
# End of macro DMARK
300b						CALLMONITOR 
300b cd aa fd			call debug_vector  
300e				endm  
# End of macro CALLMONITOR
300e					endif 
300e cd 24 25			call findnexttok  
3011			 
3011					if DEBUG_FORTH_WORDS 
3011						DMARK "IF5" 
3011 f5				push af  
3012 3a 26 30			ld a, (.dmark)  
3015 32 a6 fd			ld (debug_mark),a  
3018 3a 27 30			ld a, (.dmark+1)  
301b 32 a7 fd			ld (debug_mark+1),a  
301e 3a 28 30			ld a, (.dmark+2)  
3021 32 a8 fd			ld (debug_mark+2),a  
3024 18 03			jr .pastdmark  
3026 ..			.dmark: db "IF5"  
3029 f1			.pastdmark: pop af  
302a			endm  
# End of macro DMARK
302a						CALLMONITOR 
302a cd aa fd			call debug_vector  
302d				endm  
# End of macro CALLMONITOR
302d					endif 
302d				; replace below with ) exec using tok_ptr 
302d 22 fd f3			ld (os_tok_ptr), hl 
3030 c3 9a 24			jp exec1 
3033			 
3033 .. 00			.closepar:   db ")",0 
3035			 
3035				       NEXTW 
3035 c3 09 24			jp macro_next 
3038				endm 
# End of macro NEXTW
3038			.COMC: 
3038				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
3038 6f				db WORD_SYS_CORE+91             
3039 41 30			dw .SCRATCH            
303b 02				db 1 + 1 
303c .. 00			db ")",0              
303e				endm 
# End of macro CWHEAD
303e			; | ) ( -- )  End of comment |  DONE  
303e				       NEXTW 
303e c3 09 24			jp macro_next 
3041				endm 
# End of macro NEXTW
3041			 
3041			.SCRATCH: 
3041				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
3041 6f				db WORD_SYS_CORE+91             
3042 7c 30			dw .INC            
3044 08				db 7 + 1 
3045 .. 00			db "SCRATCH",0              
304d				endm 
# End of macro CWHEAD
304d			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
304d			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
304d			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
304d			; | |  
304d			; | | e.g.    : score $00 scratch ; 
304d			; | |  
304d			; | | $00 score ! 
304d			; | | $01 score +! 
304d			; | |  
304d			; | | e.g.   : varword $0a scratch ;  
304d			; | | 
304d			; | | $8000 varword ! 
304d					if DEBUG_FORTH_WORDS_KEY 
304d						DMARK "SCR" 
304d f5				push af  
304e 3a 62 30			ld a, (.dmark)  
3051 32 a6 fd			ld (debug_mark),a  
3054 3a 63 30			ld a, (.dmark+1)  
3057 32 a7 fd			ld (debug_mark+1),a  
305a 3a 64 30			ld a, (.dmark+2)  
305d 32 a8 fd			ld (debug_mark+2),a  
3060 18 03			jr .pastdmark  
3062 ..			.dmark: db "SCR"  
3065 f1			.pastdmark: pop af  
3066			endm  
# End of macro DMARK
3066						CALLMONITOR 
3066 cd aa fd			call debug_vector  
3069				endm  
# End of macro CALLMONITOR
3069					endif 
3069			 
3069					FORTH_DSP_VALUEHL 
3069 cd 53 22			call macro_dsp_valuehl 
306c				endm 
# End of macro FORTH_DSP_VALUEHL
306c				 
306c					FORTH_DSP_POP 
306c cd 0b 23			call macro_forth_dsp_pop 
306f				endm 
# End of macro FORTH_DSP_POP
306f			 
306f 7d					ld a, l 
3070 21 21 f6				ld hl, os_var_array 
3073 cd cf 0f				call addatohl 
3076			 
3076 cd 5c 20				call forth_push_numhl 
3079			 
3079				       NEXTW 
3079 c3 09 24			jp macro_next 
307c				endm 
# End of macro NEXTW
307c			 
307c			.INC: 
307c				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
307c 6f				db WORD_SYS_CORE+91             
307d d2 30			dw .DEC            
307f 03				db 2 + 1 
3080 .. 00			db "+!",0              
3083				endm 
# End of macro CWHEAD
3083			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
3083					if DEBUG_FORTH_WORDS_KEY 
3083						DMARK "+s_" 
3083 f5				push af  
3084 3a 98 30			ld a, (.dmark)  
3087 32 a6 fd			ld (debug_mark),a  
308a 3a 99 30			ld a, (.dmark+1)  
308d 32 a7 fd			ld (debug_mark+1),a  
3090 3a 9a 30			ld a, (.dmark+2)  
3093 32 a8 fd			ld (debug_mark+2),a  
3096 18 03			jr .pastdmark  
3098 ..			.dmark: db "+s_"  
309b f1			.pastdmark: pop af  
309c			endm  
# End of macro DMARK
309c						CALLMONITOR 
309c cd aa fd			call debug_vector  
309f				endm  
# End of macro CALLMONITOR
309f					endif 
309f			 
309f					FORTH_DSP_VALUEHL 
309f cd 53 22			call macro_dsp_valuehl 
30a2				endm 
# End of macro FORTH_DSP_VALUEHL
30a2			 
30a2 e5					push hl   ; save address 
30a3			 
30a3					FORTH_DSP_POP 
30a3 cd 0b 23			call macro_forth_dsp_pop 
30a6				endm 
# End of macro FORTH_DSP_POP
30a6			 
30a6					FORTH_DSP_VALUEHL 
30a6 cd 53 22			call macro_dsp_valuehl 
30a9				endm 
# End of macro FORTH_DSP_VALUEHL
30a9			 
30a9 e5					push hl 
30aa					FORTH_DSP_POP 
30aa cd 0b 23			call macro_forth_dsp_pop 
30ad				endm 
# End of macro FORTH_DSP_POP
30ad e1					pop hl 
30ae			 
30ae					; hl contains value to add to byte at a 
30ae				 
30ae eb					ex de, hl 
30af			 
30af e1					pop hl 
30b0			 
30b0					if DEBUG_FORTH_WORDS 
30b0						DMARK "INC" 
30b0 f5				push af  
30b1 3a c5 30			ld a, (.dmark)  
30b4 32 a6 fd			ld (debug_mark),a  
30b7 3a c6 30			ld a, (.dmark+1)  
30ba 32 a7 fd			ld (debug_mark+1),a  
30bd 3a c7 30			ld a, (.dmark+2)  
30c0 32 a8 fd			ld (debug_mark+2),a  
30c3 18 03			jr .pastdmark  
30c5 ..			.dmark: db "INC"  
30c8 f1			.pastdmark: pop af  
30c9			endm  
# End of macro DMARK
30c9						CALLMONITOR 
30c9 cd aa fd			call debug_vector  
30cc				endm  
# End of macro CALLMONITOR
30cc					endif 
30cc			 
30cc 7e					ld a,(hl) 
30cd 83					add e 
30ce 77					ld (hl),a 
30cf			 
30cf			 
30cf			 
30cf				       NEXTW 
30cf c3 09 24			jp macro_next 
30d2				endm 
# End of macro NEXTW
30d2			 
30d2			.DEC: 
30d2				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
30d2 6f				db WORD_SYS_CORE+91             
30d3 26 31			dw .INC2            
30d5 03				db 2 + 1 
30d6 .. 00			db "-!",0              
30d9				endm 
# End of macro CWHEAD
30d9			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
30d9					if DEBUG_FORTH_WORDS_KEY 
30d9						DMARK "-s_" 
30d9 f5				push af  
30da 3a ee 30			ld a, (.dmark)  
30dd 32 a6 fd			ld (debug_mark),a  
30e0 3a ef 30			ld a, (.dmark+1)  
30e3 32 a7 fd			ld (debug_mark+1),a  
30e6 3a f0 30			ld a, (.dmark+2)  
30e9 32 a8 fd			ld (debug_mark+2),a  
30ec 18 03			jr .pastdmark  
30ee ..			.dmark: db "-s_"  
30f1 f1			.pastdmark: pop af  
30f2			endm  
# End of macro DMARK
30f2						CALLMONITOR 
30f2 cd aa fd			call debug_vector  
30f5				endm  
# End of macro CALLMONITOR
30f5					endif 
30f5			 
30f5					FORTH_DSP_VALUEHL 
30f5 cd 53 22			call macro_dsp_valuehl 
30f8				endm 
# End of macro FORTH_DSP_VALUEHL
30f8			 
30f8 e5					push hl   ; save address 
30f9			 
30f9					FORTH_DSP_POP 
30f9 cd 0b 23			call macro_forth_dsp_pop 
30fc				endm 
# End of macro FORTH_DSP_POP
30fc			 
30fc					FORTH_DSP_VALUEHL 
30fc cd 53 22			call macro_dsp_valuehl 
30ff				endm 
# End of macro FORTH_DSP_VALUEHL
30ff			 
30ff					; hl contains value to add to byte at a 
30ff				 
30ff eb					ex de, hl 
3100			 
3100 e1					pop hl 
3101			 
3101					if DEBUG_FORTH_WORDS 
3101						DMARK "DEC" 
3101 f5				push af  
3102 3a 16 31			ld a, (.dmark)  
3105 32 a6 fd			ld (debug_mark),a  
3108 3a 17 31			ld a, (.dmark+1)  
310b 32 a7 fd			ld (debug_mark+1),a  
310e 3a 18 31			ld a, (.dmark+2)  
3111 32 a8 fd			ld (debug_mark+2),a  
3114 18 03			jr .pastdmark  
3116 ..			.dmark: db "DEC"  
3119 f1			.pastdmark: pop af  
311a			endm  
# End of macro DMARK
311a						CALLMONITOR 
311a cd aa fd			call debug_vector  
311d				endm  
# End of macro CALLMONITOR
311d					endif 
311d			 
311d 7e					ld a,(hl) 
311e 93					sub e 
311f 77					ld (hl),a 
3120			 
3120			 
3120					FORTH_DSP_POP 
3120 cd 0b 23			call macro_forth_dsp_pop 
3123				endm 
# End of macro FORTH_DSP_POP
3123			 
3123				       NEXTW 
3123 c3 09 24			jp macro_next 
3126				endm 
# End of macro NEXTW
3126			 
3126			.INC2: 
3126				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
3126 6f				db WORD_SYS_CORE+91             
3127 d3 31			dw .DEC2            
3129 04				db 3 + 1 
312a .. 00			db "+2!",0              
312e				endm 
# End of macro CWHEAD
312e			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
312e			 
312e					if DEBUG_FORTH_WORDS_KEY 
312e						DMARK "+2s" 
312e f5				push af  
312f 3a 43 31			ld a, (.dmark)  
3132 32 a6 fd			ld (debug_mark),a  
3135 3a 44 31			ld a, (.dmark+1)  
3138 32 a7 fd			ld (debug_mark+1),a  
313b 3a 45 31			ld a, (.dmark+2)  
313e 32 a8 fd			ld (debug_mark+2),a  
3141 18 03			jr .pastdmark  
3143 ..			.dmark: db "+2s"  
3146 f1			.pastdmark: pop af  
3147			endm  
# End of macro DMARK
3147						CALLMONITOR 
3147 cd aa fd			call debug_vector  
314a				endm  
# End of macro CALLMONITOR
314a					endif 
314a			 
314a					; Address 
314a			 
314a					FORTH_DSP_VALUEHL 
314a cd 53 22			call macro_dsp_valuehl 
314d				endm 
# End of macro FORTH_DSP_VALUEHL
314d			 
314d e5					push hl    ; save address 
314e			 
314e					; load content into de 
314e			 
314e 5e					ld e,(hl) 
314f 23					inc hl 
3150 56					ld d, (hl) 
3151			 
3151					if DEBUG_FORTH_WORDS 
3151						DMARK "+2a" 
3151 f5				push af  
3152 3a 66 31			ld a, (.dmark)  
3155 32 a6 fd			ld (debug_mark),a  
3158 3a 67 31			ld a, (.dmark+1)  
315b 32 a7 fd			ld (debug_mark+1),a  
315e 3a 68 31			ld a, (.dmark+2)  
3161 32 a8 fd			ld (debug_mark+2),a  
3164 18 03			jr .pastdmark  
3166 ..			.dmark: db "+2a"  
3169 f1			.pastdmark: pop af  
316a			endm  
# End of macro DMARK
316a						CALLMONITOR 
316a cd aa fd			call debug_vector  
316d				endm  
# End of macro CALLMONITOR
316d					endif 
316d			 
316d					FORTH_DSP_POP 
316d cd 0b 23			call macro_forth_dsp_pop 
3170				endm 
# End of macro FORTH_DSP_POP
3170			 
3170					; Get value to add 
3170			 
3170					FORTH_DSP_VALUE 
3170 cd 3c 22			call macro_forth_dsp_value 
3173				endm 
# End of macro FORTH_DSP_VALUE
3173			 
3173					if DEBUG_FORTH_WORDS 
3173						DMARK "+2v" 
3173 f5				push af  
3174 3a 88 31			ld a, (.dmark)  
3177 32 a6 fd			ld (debug_mark),a  
317a 3a 89 31			ld a, (.dmark+1)  
317d 32 a7 fd			ld (debug_mark+1),a  
3180 3a 8a 31			ld a, (.dmark+2)  
3183 32 a8 fd			ld (debug_mark+2),a  
3186 18 03			jr .pastdmark  
3188 ..			.dmark: db "+2v"  
318b f1			.pastdmark: pop af  
318c			endm  
# End of macro DMARK
318c						CALLMONITOR 
318c cd aa fd			call debug_vector  
318f				endm  
# End of macro CALLMONITOR
318f					endif 
318f			 
318f 19					add hl, de 
3190			 
3190					if DEBUG_FORTH_WORDS 
3190						DMARK "+2+" 
3190 f5				push af  
3191 3a a5 31			ld a, (.dmark)  
3194 32 a6 fd			ld (debug_mark),a  
3197 3a a6 31			ld a, (.dmark+1)  
319a 32 a7 fd			ld (debug_mark+1),a  
319d 3a a7 31			ld a, (.dmark+2)  
31a0 32 a8 fd			ld (debug_mark+2),a  
31a3 18 03			jr .pastdmark  
31a5 ..			.dmark: db "+2+"  
31a8 f1			.pastdmark: pop af  
31a9			endm  
# End of macro DMARK
31a9						CALLMONITOR 
31a9 cd aa fd			call debug_vector  
31ac				endm  
# End of macro CALLMONITOR
31ac					endif 
31ac			 
31ac					; move result to de 
31ac			 
31ac eb					ex de, hl 
31ad			 
31ad					; Address 
31ad			 
31ad e1					pop hl 
31ae			 
31ae					; save it back 
31ae			 
31ae 73					ld (hl), e 
31af 23					inc hl 
31b0 72					ld (hl), d 
31b1			 
31b1					if DEBUG_FORTH_WORDS 
31b1						DMARK "+2e" 
31b1 f5				push af  
31b2 3a c6 31			ld a, (.dmark)  
31b5 32 a6 fd			ld (debug_mark),a  
31b8 3a c7 31			ld a, (.dmark+1)  
31bb 32 a7 fd			ld (debug_mark+1),a  
31be 3a c8 31			ld a, (.dmark+2)  
31c1 32 a8 fd			ld (debug_mark+2),a  
31c4 18 03			jr .pastdmark  
31c6 ..			.dmark: db "+2e"  
31c9 f1			.pastdmark: pop af  
31ca			endm  
# End of macro DMARK
31ca						CALLMONITOR 
31ca cd aa fd			call debug_vector  
31cd				endm  
# End of macro CALLMONITOR
31cd					endif 
31cd			 
31cd			 
31cd			 
31cd					FORTH_DSP_POP 
31cd cd 0b 23			call macro_forth_dsp_pop 
31d0				endm 
# End of macro FORTH_DSP_POP
31d0			 
31d0			 
31d0				       NEXTW 
31d0 c3 09 24			jp macro_next 
31d3				endm 
# End of macro NEXTW
31d3			 
31d3			.DEC2: 
31d3				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
31d3 6f				db WORD_SYS_CORE+91             
31d4 82 32			dw .GET2            
31d6 04				db 3 + 1 
31d7 .. 00			db "-2!",0              
31db				endm 
# End of macro CWHEAD
31db			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
31db			 
31db			 
31db					if DEBUG_FORTH_WORDS_KEY 
31db						DMARK "-2s" 
31db f5				push af  
31dc 3a f0 31			ld a, (.dmark)  
31df 32 a6 fd			ld (debug_mark),a  
31e2 3a f1 31			ld a, (.dmark+1)  
31e5 32 a7 fd			ld (debug_mark+1),a  
31e8 3a f2 31			ld a, (.dmark+2)  
31eb 32 a8 fd			ld (debug_mark+2),a  
31ee 18 03			jr .pastdmark  
31f0 ..			.dmark: db "-2s"  
31f3 f1			.pastdmark: pop af  
31f4			endm  
# End of macro DMARK
31f4						CALLMONITOR 
31f4 cd aa fd			call debug_vector  
31f7				endm  
# End of macro CALLMONITOR
31f7					endif 
31f7			 
31f7					; Address 
31f7			 
31f7					FORTH_DSP_VALUEHL 
31f7 cd 53 22			call macro_dsp_valuehl 
31fa				endm 
# End of macro FORTH_DSP_VALUEHL
31fa			 
31fa e5					push hl    ; save address 
31fb			 
31fb					; load content into de 
31fb			 
31fb 5e					ld e,(hl) 
31fc 23					inc hl 
31fd 56					ld d, (hl) 
31fe			 
31fe					if DEBUG_FORTH_WORDS 
31fe						DMARK "-2a" 
31fe f5				push af  
31ff 3a 13 32			ld a, (.dmark)  
3202 32 a6 fd			ld (debug_mark),a  
3205 3a 14 32			ld a, (.dmark+1)  
3208 32 a7 fd			ld (debug_mark+1),a  
320b 3a 15 32			ld a, (.dmark+2)  
320e 32 a8 fd			ld (debug_mark+2),a  
3211 18 03			jr .pastdmark  
3213 ..			.dmark: db "-2a"  
3216 f1			.pastdmark: pop af  
3217			endm  
# End of macro DMARK
3217						CALLMONITOR 
3217 cd aa fd			call debug_vector  
321a				endm  
# End of macro CALLMONITOR
321a					endif 
321a			 
321a					FORTH_DSP_POP 
321a cd 0b 23			call macro_forth_dsp_pop 
321d				endm 
# End of macro FORTH_DSP_POP
321d			 
321d					; Get value to remove 
321d			 
321d					FORTH_DSP_VALUE 
321d cd 3c 22			call macro_forth_dsp_value 
3220				endm 
# End of macro FORTH_DSP_VALUE
3220			 
3220					if DEBUG_FORTH_WORDS 
3220						DMARK "-2v" 
3220 f5				push af  
3221 3a 35 32			ld a, (.dmark)  
3224 32 a6 fd			ld (debug_mark),a  
3227 3a 36 32			ld a, (.dmark+1)  
322a 32 a7 fd			ld (debug_mark+1),a  
322d 3a 37 32			ld a, (.dmark+2)  
3230 32 a8 fd			ld (debug_mark+2),a  
3233 18 03			jr .pastdmark  
3235 ..			.dmark: db "-2v"  
3238 f1			.pastdmark: pop af  
3239			endm  
# End of macro DMARK
3239						CALLMONITOR 
3239 cd aa fd			call debug_vector  
323c				endm  
# End of macro CALLMONITOR
323c					endif 
323c			 
323c eb					ex de, hl 
323d ed 52				sbc hl, de 
323f			 
323f					if DEBUG_FORTH_WORDS 
323f						DMARK "-2d" 
323f f5				push af  
3240 3a 54 32			ld a, (.dmark)  
3243 32 a6 fd			ld (debug_mark),a  
3246 3a 55 32			ld a, (.dmark+1)  
3249 32 a7 fd			ld (debug_mark+1),a  
324c 3a 56 32			ld a, (.dmark+2)  
324f 32 a8 fd			ld (debug_mark+2),a  
3252 18 03			jr .pastdmark  
3254 ..			.dmark: db "-2d"  
3257 f1			.pastdmark: pop af  
3258			endm  
# End of macro DMARK
3258						CALLMONITOR 
3258 cd aa fd			call debug_vector  
325b				endm  
# End of macro CALLMONITOR
325b					endif 
325b			 
325b					; move result to de 
325b			 
325b eb					ex de, hl 
325c			 
325c					; Address 
325c			 
325c e1					pop hl 
325d			 
325d					; save it back 
325d			 
325d 73					ld (hl), e 
325e 23					inc hl 
325f 72					ld (hl), d 
3260			 
3260					if DEBUG_FORTH_WORDS 
3260						DMARK "-2e" 
3260 f5				push af  
3261 3a 75 32			ld a, (.dmark)  
3264 32 a6 fd			ld (debug_mark),a  
3267 3a 76 32			ld a, (.dmark+1)  
326a 32 a7 fd			ld (debug_mark+1),a  
326d 3a 77 32			ld a, (.dmark+2)  
3270 32 a8 fd			ld (debug_mark+2),a  
3273 18 03			jr .pastdmark  
3275 ..			.dmark: db "-2e"  
3278 f1			.pastdmark: pop af  
3279			endm  
# End of macro DMARK
3279						CALLMONITOR 
3279 cd aa fd			call debug_vector  
327c				endm  
# End of macro CALLMONITOR
327c					endif 
327c			 
327c			 
327c					FORTH_DSP_POP 
327c cd 0b 23			call macro_forth_dsp_pop 
327f				endm 
# End of macro FORTH_DSP_POP
327f			 
327f			 
327f			 
327f				       NEXTW 
327f c3 09 24			jp macro_next 
3282				endm 
# End of macro NEXTW
3282			.GET2: 
3282				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
3282 6f				db WORD_SYS_CORE+91             
3283 b7 32			dw .BANG2            
3285 03				db 2 + 1 
3286 .. 00			db "2@",0              
3289				endm 
# End of macro CWHEAD
3289			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3289					if DEBUG_FORTH_WORDS_KEY 
3289						DMARK "2A_" 
3289 f5				push af  
328a 3a 9e 32			ld a, (.dmark)  
328d 32 a6 fd			ld (debug_mark),a  
3290 3a 9f 32			ld a, (.dmark+1)  
3293 32 a7 fd			ld (debug_mark+1),a  
3296 3a a0 32			ld a, (.dmark+2)  
3299 32 a8 fd			ld (debug_mark+2),a  
329c 18 03			jr .pastdmark  
329e ..			.dmark: db "2A_"  
32a1 f1			.pastdmark: pop af  
32a2			endm  
# End of macro DMARK
32a2						CALLMONITOR 
32a2 cd aa fd			call debug_vector  
32a5				endm  
# End of macro CALLMONITOR
32a5					endif 
32a5			 
32a5					FORTH_DSP_VALUEHL 
32a5 cd 53 22			call macro_dsp_valuehl 
32a8				endm 
# End of macro FORTH_DSP_VALUEHL
32a8			 
32a8 e5					push hl   ; save address 
32a9			 
32a9					FORTH_DSP_POP 
32a9 cd 0b 23			call macro_forth_dsp_pop 
32ac				endm 
# End of macro FORTH_DSP_POP
32ac			 
32ac e1					pop hl 
32ad			 
32ad 5e					ld e, (hl) 
32ae 23					inc hl 
32af 56					ld d, (hl) 
32b0			 
32b0 eb					ex de, hl 
32b1			 
32b1 cd 5c 20				call forth_push_numhl 
32b4			 
32b4				       NEXTW 
32b4 c3 09 24			jp macro_next 
32b7				endm 
# End of macro NEXTW
32b7			.BANG2: 
32b7				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
32b7 6f				db WORD_SYS_CORE+91             
32b8 ef 32			dw .CONFIG            
32ba 03				db 2 + 1 
32bb .. 00			db "2!",0              
32be				endm 
# End of macro CWHEAD
32be			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
32be					if DEBUG_FORTH_WORDS_KEY 
32be						DMARK "2S_" 
32be f5				push af  
32bf 3a d3 32			ld a, (.dmark)  
32c2 32 a6 fd			ld (debug_mark),a  
32c5 3a d4 32			ld a, (.dmark+1)  
32c8 32 a7 fd			ld (debug_mark+1),a  
32cb 3a d5 32			ld a, (.dmark+2)  
32ce 32 a8 fd			ld (debug_mark+2),a  
32d1 18 03			jr .pastdmark  
32d3 ..			.dmark: db "2S_"  
32d6 f1			.pastdmark: pop af  
32d7			endm  
# End of macro DMARK
32d7						CALLMONITOR 
32d7 cd aa fd			call debug_vector  
32da				endm  
# End of macro CALLMONITOR
32da					endif 
32da			 
32da					FORTH_DSP_VALUEHL 
32da cd 53 22			call macro_dsp_valuehl 
32dd				endm 
# End of macro FORTH_DSP_VALUEHL
32dd			 
32dd e5					push hl   ; save address 
32de			 
32de			 
32de					FORTH_DSP_POP 
32de cd 0b 23			call macro_forth_dsp_pop 
32e1				endm 
# End of macro FORTH_DSP_POP
32e1			 
32e1					 
32e1					FORTH_DSP_VALUEHL 
32e1 cd 53 22			call macro_dsp_valuehl 
32e4				endm 
# End of macro FORTH_DSP_VALUEHL
32e4			 
32e4					FORTH_DSP_POP 
32e4 cd 0b 23			call macro_forth_dsp_pop 
32e7				endm 
# End of macro FORTH_DSP_POP
32e7			 
32e7 eb					ex de, hl    ; value now in de 
32e8			 
32e8 e1					pop hl 
32e9			 
32e9 73					ld (hl), e 
32ea			 
32ea 23					inc hl 
32eb			 
32eb 72					ld (hl), d 
32ec			 
32ec			 
32ec				       NEXTW 
32ec c3 09 24			jp macro_next 
32ef				endm 
# End of macro NEXTW
32ef			.CONFIG: 
32ef				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
32ef 6f				db WORD_SYS_CORE+91             
32f0 00 33			dw .ADTOS            
32f2 07				db 6 + 1 
32f3 .. 00			db "CONFIG",0              
32fa				endm 
# End of macro CWHEAD
32fa			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
32fa			 
32fa cd 94 15				call config 
32fd					NEXTW 
32fd c3 09 24			jp macro_next 
3300				endm 
# End of macro NEXTW
3300			 
3300			.ADTOS: 
3300				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
3300 6f				db WORD_SYS_CORE+91             
3301 16 33			dw .SBTOS            
3303 03				db 2 + 1 
3304 .. 00			db "1+",0              
3307				endm 
# End of macro CWHEAD
3307			; | 1+ ( u -- u )  Increment value on TOS | DONE 
3307			 
3307					FORTH_DSP_VALUEHL 
3307 cd 53 22			call macro_dsp_valuehl 
330a				endm 
# End of macro FORTH_DSP_VALUEHL
330a e5					push hl 
330b			 
330b					FORTH_DSP_POP 
330b cd 0b 23			call macro_forth_dsp_pop 
330e				endm 
# End of macro FORTH_DSP_POP
330e e1					pop hl 
330f			 
330f 23					inc hl 
3310 cd 5c 20				call forth_push_numhl 
3313					 
3313					NEXTW 
3313 c3 09 24			jp macro_next 
3316				endm 
# End of macro NEXTW
3316			.SBTOS: 
3316				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
3316 6f				db WORD_SYS_CORE+91             
3317 2c 33			dw .ADSTORE            
3319 03				db 2 + 1 
331a .. 00			db "1-",0              
331d				endm 
# End of macro CWHEAD
331d			; | 1- ( u -- u )  Decrement value on TOS | DONE 
331d			 
331d					FORTH_DSP_VALUEHL 
331d cd 53 22			call macro_dsp_valuehl 
3320				endm 
# End of macro FORTH_DSP_VALUEHL
3320 e5					push hl 
3321			 
3321					FORTH_DSP_POP 
3321 cd 0b 23			call macro_forth_dsp_pop 
3324				endm 
# End of macro FORTH_DSP_POP
3324 e1					pop hl 
3325			 
3325 2b					dec hl 
3326 cd 5c 20				call forth_push_numhl 
3329					 
3329					NEXTW 
3329 c3 09 24			jp macro_next 
332c				endm 
# End of macro NEXTW
332c			.ADSTORE: 
332c				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
332c 6f				db WORD_SYS_CORE+91             
332d 42 33			dw .ADWSTORE            
332f 04				db 3 + 1 
3330 .. 00			db "1+!",0              
3334				endm 
# End of macro CWHEAD
3334			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
3334			 
3334					FORTH_DSP_VALUEHL 
3334 cd 53 22			call macro_dsp_valuehl 
3337				endm 
# End of macro FORTH_DSP_VALUEHL
3337 e5					push hl 
3338			 
3338					FORTH_DSP_POP 
3338 cd 0b 23			call macro_forth_dsp_pop 
333b				endm 
# End of macro FORTH_DSP_POP
333b e1					pop hl 
333c			 
333c 7e					ld a, (hl) 
333d 3c					inc a 
333e 77					ld (hl), a 
333f					 
333f					NEXTW 
333f c3 09 24			jp macro_next 
3342				endm 
# End of macro NEXTW
3342			.ADWSTORE: 
3342				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
3342 6f				db WORD_SYS_CORE+91             
3343 60 33			dw .SBSTORE            
3345 05				db 4 + 1 
3346 .. 00			db "1+2!",0              
334b				endm 
# End of macro CWHEAD
334b			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
334b			 
334b					FORTH_DSP_VALUEHL 
334b cd 53 22			call macro_dsp_valuehl 
334e				endm 
# End of macro FORTH_DSP_VALUEHL
334e e5					push hl 
334f			 
334f					FORTH_DSP_POP 
334f cd 0b 23			call macro_forth_dsp_pop 
3352				endm 
# End of macro FORTH_DSP_POP
3352 e1					pop hl 
3353			 
3353 e5					push hl 
3354			 
3354 cd 8b 23				call loadwordinhl 
3357 23					inc hl 
3358			 
3358 d1					pop de 
3359 eb					ex de, hl 
335a 73					ld (hl), e 
335b 23					inc hl 
335c 72					ld (hl), d 
335d					 
335d					NEXTW 
335d c3 09 24			jp macro_next 
3360				endm 
# End of macro NEXTW
3360			.SBSTORE: 
3360				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
3360 6f				db WORD_SYS_CORE+91             
3361 76 33			dw .SBWSTORE            
3363 04				db 3 + 1 
3364 .. 00			db "1-!",0              
3368				endm 
# End of macro CWHEAD
3368			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
3368			 
3368					FORTH_DSP_VALUEHL 
3368 cd 53 22			call macro_dsp_valuehl 
336b				endm 
# End of macro FORTH_DSP_VALUEHL
336b e5					push hl 
336c			 
336c					FORTH_DSP_POP 
336c cd 0b 23			call macro_forth_dsp_pop 
336f				endm 
# End of macro FORTH_DSP_POP
336f e1					pop hl 
3370			 
3370 7e					ld a, (hl) 
3371 3d					dec a 
3372 77					ld (hl), a 
3373					 
3373					NEXTW 
3373 c3 09 24			jp macro_next 
3376				endm 
# End of macro NEXTW
3376			.SBWSTORE: 
3376				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
3376 6f				db WORD_SYS_CORE+91             
3377 94 33			dw .ENDCORE            
3379 05				db 4 + 1 
337a .. 00			db "1-2!",0              
337f				endm 
# End of macro CWHEAD
337f			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
337f			 
337f					FORTH_DSP_VALUEHL 
337f cd 53 22			call macro_dsp_valuehl 
3382				endm 
# End of macro FORTH_DSP_VALUEHL
3382 e5					push hl 
3383			 
3383					FORTH_DSP_POP 
3383 cd 0b 23			call macro_forth_dsp_pop 
3386				endm 
# End of macro FORTH_DSP_POP
3386 e1					pop hl 
3387			 
3387 e5					push hl 
3388			 
3388 cd 8b 23				call loadwordinhl 
338b 2b					dec hl 
338c			 
338c d1					pop de 
338d eb					ex de, hl 
338e 73					ld (hl), e 
338f 23					inc hl 
3390 72					ld (hl), d 
3391					 
3391					NEXTW 
3391 c3 09 24			jp macro_next 
3394				endm 
# End of macro NEXTW
3394			.ENDCORE: 
3394			 
3394			; eof 
3394			 
3394			 
# End of file forth_words_core.asm
3394			include "forth_words_flow.asm" 
3394			 
3394			; | ## Program Flow Words 
3394			 
3394			.IF: 
3394				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
3394 1e				db WORD_SYS_CORE+10             
3395 89 34			dw .THEN            
3397 03				db 2 + 1 
3398 .. 00			db "IF",0              
339b				endm 
# End of macro CWHEAD
339b			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
339b			; 
339b					if DEBUG_FORTH_WORDS_KEY 
339b						DMARK "IF." 
339b f5				push af  
339c 3a b0 33			ld a, (.dmark)  
339f 32 a6 fd			ld (debug_mark),a  
33a2 3a b1 33			ld a, (.dmark+1)  
33a5 32 a7 fd			ld (debug_mark+1),a  
33a8 3a b2 33			ld a, (.dmark+2)  
33ab 32 a8 fd			ld (debug_mark+2),a  
33ae 18 03			jr .pastdmark  
33b0 ..			.dmark: db "IF."  
33b3 f1			.pastdmark: pop af  
33b4			endm  
# End of macro DMARK
33b4						CALLMONITOR 
33b4 cd aa fd			call debug_vector  
33b7				endm  
# End of macro CALLMONITOR
33b7					endif 
33b7			; eval TOS 
33b7			 
33b7				FORTH_DSP_VALUEHL 
33b7 cd 53 22			call macro_dsp_valuehl 
33ba				endm 
# End of macro FORTH_DSP_VALUEHL
33ba			 
33ba			;	push hl 
33ba				FORTH_DSP_POP 
33ba cd 0b 23			call macro_forth_dsp_pop 
33bd				endm 
# End of macro FORTH_DSP_POP
33bd			;	pop hl 
33bd			 
33bd					if DEBUG_FORTH_WORDS 
33bd						DMARK "IF1" 
33bd f5				push af  
33be 3a d2 33			ld a, (.dmark)  
33c1 32 a6 fd			ld (debug_mark),a  
33c4 3a d3 33			ld a, (.dmark+1)  
33c7 32 a7 fd			ld (debug_mark+1),a  
33ca 3a d4 33			ld a, (.dmark+2)  
33cd 32 a8 fd			ld (debug_mark+2),a  
33d0 18 03			jr .pastdmark  
33d2 ..			.dmark: db "IF1"  
33d5 f1			.pastdmark: pop af  
33d6			endm  
# End of macro DMARK
33d6						CALLMONITOR 
33d6 cd aa fd			call debug_vector  
33d9				endm  
# End of macro CALLMONITOR
33d9					endif 
33d9 b7				or a        ; clear carry flag 
33da 11 00 00			ld de, 0 
33dd eb				ex de,hl 
33de ed 52			sbc hl, de 
33e0 c2 6a 34			jp nz, .iftrue 
33e3			 
33e3					if DEBUG_FORTH_WORDS 
33e3						DMARK "IF2" 
33e3 f5				push af  
33e4 3a f8 33			ld a, (.dmark)  
33e7 32 a6 fd			ld (debug_mark),a  
33ea 3a f9 33			ld a, (.dmark+1)  
33ed 32 a7 fd			ld (debug_mark+1),a  
33f0 3a fa 33			ld a, (.dmark+2)  
33f3 32 a8 fd			ld (debug_mark+2),a  
33f6 18 03			jr .pastdmark  
33f8 ..			.dmark: db "IF2"  
33fb f1			.pastdmark: pop af  
33fc			endm  
# End of macro DMARK
33fc						CALLMONITOR 
33fc cd aa fd			call debug_vector  
33ff				endm  
# End of macro CALLMONITOR
33ff					endif 
33ff			 
33ff			; if not true then skip to THEN 
33ff			 
33ff				; TODO get tok_ptr 
33ff				; TODO consume toks until we get to THEN 
33ff			 
33ff 2a fd f3			ld hl, (os_tok_ptr) 
3402					if DEBUG_FORTH_WORDS 
3402						DMARK "IF3" 
3402 f5				push af  
3403 3a 17 34			ld a, (.dmark)  
3406 32 a6 fd			ld (debug_mark),a  
3409 3a 18 34			ld a, (.dmark+1)  
340c 32 a7 fd			ld (debug_mark+1),a  
340f 3a 19 34			ld a, (.dmark+2)  
3412 32 a8 fd			ld (debug_mark+2),a  
3415 18 03			jr .pastdmark  
3417 ..			.dmark: db "IF3"  
341a f1			.pastdmark: pop af  
341b			endm  
# End of macro DMARK
341b						CALLMONITOR 
341b cd aa fd			call debug_vector  
341e				endm  
# End of macro CALLMONITOR
341e						 
341e					endif 
341e 11 65 34			ld de, .ifthen 
3421					if DEBUG_FORTH_WORDS 
3421						DMARK "IF4" 
3421 f5				push af  
3422 3a 36 34			ld a, (.dmark)  
3425 32 a6 fd			ld (debug_mark),a  
3428 3a 37 34			ld a, (.dmark+1)  
342b 32 a7 fd			ld (debug_mark+1),a  
342e 3a 38 34			ld a, (.dmark+2)  
3431 32 a8 fd			ld (debug_mark+2),a  
3434 18 03			jr .pastdmark  
3436 ..			.dmark: db "IF4"  
3439 f1			.pastdmark: pop af  
343a			endm  
# End of macro DMARK
343a						CALLMONITOR 
343a cd aa fd			call debug_vector  
343d				endm  
# End of macro CALLMONITOR
343d					endif 
343d cd 24 25			call findnexttok  
3440			 
3440					if DEBUG_FORTH_WORDS 
3440						DMARK "IF5" 
3440 f5				push af  
3441 3a 55 34			ld a, (.dmark)  
3444 32 a6 fd			ld (debug_mark),a  
3447 3a 56 34			ld a, (.dmark+1)  
344a 32 a7 fd			ld (debug_mark+1),a  
344d 3a 57 34			ld a, (.dmark+2)  
3450 32 a8 fd			ld (debug_mark+2),a  
3453 18 03			jr .pastdmark  
3455 ..			.dmark: db "IF5"  
3458 f1			.pastdmark: pop af  
3459			endm  
# End of macro DMARK
3459						CALLMONITOR 
3459 cd aa fd			call debug_vector  
345c				endm  
# End of macro CALLMONITOR
345c					endif 
345c				; TODO replace below with ; exec using tok_ptr 
345c 22 fd f3			ld (os_tok_ptr), hl 
345f c3 9a 24			jp exec1 
3462				NEXTW 
3462 c3 09 24			jp macro_next 
3465				endm 
# End of macro NEXTW
3465			 
3465 .. 00		.ifthen:  db "THEN",0 
346a			 
346a			.iftrue:		 
346a				; Exec next words normally 
346a			 
346a				; if true then exec following IF as normal 
346a					if DEBUG_FORTH_WORDS 
346a						DMARK "IFT" 
346a f5				push af  
346b 3a 7f 34			ld a, (.dmark)  
346e 32 a6 fd			ld (debug_mark),a  
3471 3a 80 34			ld a, (.dmark+1)  
3474 32 a7 fd			ld (debug_mark+1),a  
3477 3a 81 34			ld a, (.dmark+2)  
347a 32 a8 fd			ld (debug_mark+2),a  
347d 18 03			jr .pastdmark  
347f ..			.dmark: db "IFT"  
3482 f1			.pastdmark: pop af  
3483			endm  
# End of macro DMARK
3483						CALLMONITOR 
3483 cd aa fd			call debug_vector  
3486				endm  
# End of macro CALLMONITOR
3486					endif 
3486			 
3486					NEXTW 
3486 c3 09 24			jp macro_next 
3489				endm 
# End of macro NEXTW
3489			.THEN: 
3489				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3489 1f				db WORD_SYS_CORE+11             
348a b1 34			dw .ELSE            
348c 05				db 4 + 1 
348d .. 00			db "THEN",0              
3492				endm 
# End of macro CWHEAD
3492			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3492					if DEBUG_FORTH_WORDS_KEY 
3492						DMARK "THN" 
3492 f5				push af  
3493 3a a7 34			ld a, (.dmark)  
3496 32 a6 fd			ld (debug_mark),a  
3499 3a a8 34			ld a, (.dmark+1)  
349c 32 a7 fd			ld (debug_mark+1),a  
349f 3a a9 34			ld a, (.dmark+2)  
34a2 32 a8 fd			ld (debug_mark+2),a  
34a5 18 03			jr .pastdmark  
34a7 ..			.dmark: db "THN"  
34aa f1			.pastdmark: pop af  
34ab			endm  
# End of macro DMARK
34ab						CALLMONITOR 
34ab cd aa fd			call debug_vector  
34ae				endm  
# End of macro CALLMONITOR
34ae					endif 
34ae					NEXTW 
34ae c3 09 24			jp macro_next 
34b1				endm 
# End of macro NEXTW
34b1			.ELSE: 
34b1				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
34b1 20				db WORD_SYS_CORE+12             
34b2 d9 34			dw .DO            
34b4 03				db 2 + 1 
34b5 .. 00			db "ELSE",0              
34ba				endm 
# End of macro CWHEAD
34ba			; | ELSE ( -- ) Not supported - does nothing | TODO 
34ba			 
34ba					if DEBUG_FORTH_WORDS_KEY 
34ba						DMARK "ELS" 
34ba f5				push af  
34bb 3a cf 34			ld a, (.dmark)  
34be 32 a6 fd			ld (debug_mark),a  
34c1 3a d0 34			ld a, (.dmark+1)  
34c4 32 a7 fd			ld (debug_mark+1),a  
34c7 3a d1 34			ld a, (.dmark+2)  
34ca 32 a8 fd			ld (debug_mark+2),a  
34cd 18 03			jr .pastdmark  
34cf ..			.dmark: db "ELS"  
34d2 f1			.pastdmark: pop af  
34d3			endm  
# End of macro DMARK
34d3						CALLMONITOR 
34d3 cd aa fd			call debug_vector  
34d6				endm  
# End of macro CALLMONITOR
34d6					endif 
34d6			 
34d6			 
34d6					NEXTW 
34d6 c3 09 24			jp macro_next 
34d9				endm 
# End of macro NEXTW
34d9			.DO: 
34d9				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
34d9 21				db WORD_SYS_CORE+13             
34da 00 36			dw .LOOP            
34dc 03				db 2 + 1 
34dd .. 00			db "DO",0              
34e0				endm 
# End of macro CWHEAD
34e0			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
34e0			 
34e0					if DEBUG_FORTH_WORDS_KEY 
34e0						DMARK "DO." 
34e0 f5				push af  
34e1 3a f5 34			ld a, (.dmark)  
34e4 32 a6 fd			ld (debug_mark),a  
34e7 3a f6 34			ld a, (.dmark+1)  
34ea 32 a7 fd			ld (debug_mark+1),a  
34ed 3a f7 34			ld a, (.dmark+2)  
34f0 32 a8 fd			ld (debug_mark+2),a  
34f3 18 03			jr .pastdmark  
34f5 ..			.dmark: db "DO."  
34f8 f1			.pastdmark: pop af  
34f9			endm  
# End of macro DMARK
34f9						CALLMONITOR 
34f9 cd aa fd			call debug_vector  
34fc				endm  
# End of macro CALLMONITOR
34fc					endif 
34fc			;  push pc to rsp stack past the DO 
34fc			 
34fc 2a fd f3				ld hl, (os_tok_ptr) 
34ff 23					inc hl   ; D 
3500 23					inc hl  ; O 
3501 23					inc hl   ; null 
3502					if DEBUG_FORTH_WORDS 
3502						DMARK "DO2" 
3502 f5				push af  
3503 3a 17 35			ld a, (.dmark)  
3506 32 a6 fd			ld (debug_mark),a  
3509 3a 18 35			ld a, (.dmark+1)  
350c 32 a7 fd			ld (debug_mark+1),a  
350f 3a 19 35			ld a, (.dmark+2)  
3512 32 a8 fd			ld (debug_mark+2),a  
3515 18 03			jr .pastdmark  
3517 ..			.dmark: db "DO2"  
351a f1			.pastdmark: pop af  
351b			endm  
# End of macro DMARK
351b						CALLMONITOR 
351b cd aa fd			call debug_vector  
351e				endm  
# End of macro CALLMONITOR
351e					endif 
351e					FORTH_RSP_NEXT 
351e cd 03 20			call macro_forth_rsp_next 
3521				endm 
# End of macro FORTH_RSP_NEXT
3521					if DEBUG_FORTH_WORDS 
3521						DMARK "DO3" 
3521 f5				push af  
3522 3a 36 35			ld a, (.dmark)  
3525 32 a6 fd			ld (debug_mark),a  
3528 3a 37 35			ld a, (.dmark+1)  
352b 32 a7 fd			ld (debug_mark+1),a  
352e 3a 38 35			ld a, (.dmark+2)  
3531 32 a8 fd			ld (debug_mark+2),a  
3534 18 03			jr .pastdmark  
3536 ..			.dmark: db "DO3"  
3539 f1			.pastdmark: pop af  
353a			endm  
# End of macro DMARK
353a						CALLMONITOR 
353a cd aa fd			call debug_vector  
353d				endm  
# End of macro CALLMONITOR
353d					endif 
353d			 
353d					;if DEBUG_FORTH_WORDS 
353d				;		push hl 
353d			;		endif  
353d			 
353d			; get counters from data stack 
353d			 
353d			 
353d					FORTH_DSP_VALUEHL 
353d cd 53 22			call macro_dsp_valuehl 
3540				endm 
# End of macro FORTH_DSP_VALUEHL
3540 e5					push hl		 ; hl now has starting counter which needs to be tos 
3541			 
3541					if DEBUG_FORTH_WORDS 
3541						DMARK "DO4" 
3541 f5				push af  
3542 3a 56 35			ld a, (.dmark)  
3545 32 a6 fd			ld (debug_mark),a  
3548 3a 57 35			ld a, (.dmark+1)  
354b 32 a7 fd			ld (debug_mark+1),a  
354e 3a 58 35			ld a, (.dmark+2)  
3551 32 a8 fd			ld (debug_mark+2),a  
3554 18 03			jr .pastdmark  
3556 ..			.dmark: db "DO4"  
3559 f1			.pastdmark: pop af  
355a			endm  
# End of macro DMARK
355a						CALLMONITOR 
355a cd aa fd			call debug_vector  
355d				endm  
# End of macro CALLMONITOR
355d					endif 
355d					FORTH_DSP_POP 
355d cd 0b 23			call macro_forth_dsp_pop 
3560				endm 
# End of macro FORTH_DSP_POP
3560			 
3560					if DEBUG_FORTH_WORDS 
3560						DMARK "DO5" 
3560 f5				push af  
3561 3a 75 35			ld a, (.dmark)  
3564 32 a6 fd			ld (debug_mark),a  
3567 3a 76 35			ld a, (.dmark+1)  
356a 32 a7 fd			ld (debug_mark+1),a  
356d 3a 77 35			ld a, (.dmark+2)  
3570 32 a8 fd			ld (debug_mark+2),a  
3573 18 03			jr .pastdmark  
3575 ..			.dmark: db "DO5"  
3578 f1			.pastdmark: pop af  
3579			endm  
# End of macro DMARK
3579						CALLMONITOR 
3579 cd aa fd			call debug_vector  
357c				endm  
# End of macro CALLMONITOR
357c					endif 
357c			 
357c					FORTH_DSP_VALUEHL 
357c cd 53 22			call macro_dsp_valuehl 
357f				endm 
# End of macro FORTH_DSP_VALUEHL
357f			;		push hl		 ; hl now has starting limit counter 
357f			 
357f					if DEBUG_FORTH_WORDS 
357f						DMARK "DO6" 
357f f5				push af  
3580 3a 94 35			ld a, (.dmark)  
3583 32 a6 fd			ld (debug_mark),a  
3586 3a 95 35			ld a, (.dmark+1)  
3589 32 a7 fd			ld (debug_mark+1),a  
358c 3a 96 35			ld a, (.dmark+2)  
358f 32 a8 fd			ld (debug_mark+2),a  
3592 18 03			jr .pastdmark  
3594 ..			.dmark: db "DO6"  
3597 f1			.pastdmark: pop af  
3598			endm  
# End of macro DMARK
3598						CALLMONITOR 
3598 cd aa fd			call debug_vector  
359b				endm  
# End of macro CALLMONITOR
359b					endif 
359b					FORTH_DSP_POP 
359b cd 0b 23			call macro_forth_dsp_pop 
359e				endm 
# End of macro FORTH_DSP_POP
359e			 
359e			; put counters on the loop stack 
359e			 
359e			;		pop hl			 ; limit counter 
359e d1					pop de			; start counter 
359f			 
359f					; push limit counter 
359f			 
359f					if DEBUG_FORTH_WORDS 
359f						DMARK "DO7" 
359f f5				push af  
35a0 3a b4 35			ld a, (.dmark)  
35a3 32 a6 fd			ld (debug_mark),a  
35a6 3a b5 35			ld a, (.dmark+1)  
35a9 32 a7 fd			ld (debug_mark+1),a  
35ac 3a b6 35			ld a, (.dmark+2)  
35af 32 a8 fd			ld (debug_mark+2),a  
35b2 18 03			jr .pastdmark  
35b4 ..			.dmark: db "DO7"  
35b7 f1			.pastdmark: pop af  
35b8			endm  
# End of macro DMARK
35b8						CALLMONITOR 
35b8 cd aa fd			call debug_vector  
35bb				endm  
# End of macro CALLMONITOR
35bb					endif 
35bb					FORTH_LOOP_NEXT 
35bb cd 84 22			call macro_forth_loop_next 
35be				endm 
# End of macro FORTH_LOOP_NEXT
35be			 
35be					; push start counter 
35be			 
35be eb					ex de, hl 
35bf					if DEBUG_FORTH_WORDS 
35bf						DMARK "DO7" 
35bf f5				push af  
35c0 3a d4 35			ld a, (.dmark)  
35c3 32 a6 fd			ld (debug_mark),a  
35c6 3a d5 35			ld a, (.dmark+1)  
35c9 32 a7 fd			ld (debug_mark+1),a  
35cc 3a d6 35			ld a, (.dmark+2)  
35cf 32 a8 fd			ld (debug_mark+2),a  
35d2 18 03			jr .pastdmark  
35d4 ..			.dmark: db "DO7"  
35d7 f1			.pastdmark: pop af  
35d8			endm  
# End of macro DMARK
35d8						CALLMONITOR 
35d8 cd aa fd			call debug_vector  
35db				endm  
# End of macro CALLMONITOR
35db					endif 
35db					FORTH_LOOP_NEXT 
35db cd 84 22			call macro_forth_loop_next 
35de				endm 
# End of macro FORTH_LOOP_NEXT
35de			 
35de			 
35de					; init first round of I counter 
35de			 
35de 22 21 f4				ld (os_current_i), hl 
35e1			 
35e1					if DEBUG_FORTH_WORDS 
35e1						DMARK "DO8" 
35e1 f5				push af  
35e2 3a f6 35			ld a, (.dmark)  
35e5 32 a6 fd			ld (debug_mark),a  
35e8 3a f7 35			ld a, (.dmark+1)  
35eb 32 a7 fd			ld (debug_mark+1),a  
35ee 3a f8 35			ld a, (.dmark+2)  
35f1 32 a8 fd			ld (debug_mark+2),a  
35f4 18 03			jr .pastdmark  
35f6 ..			.dmark: db "DO8"  
35f9 f1			.pastdmark: pop af  
35fa			endm  
# End of macro DMARK
35fa						CALLMONITOR 
35fa cd aa fd			call debug_vector  
35fd				endm  
# End of macro CALLMONITOR
35fd					endif 
35fd			 
35fd					NEXTW 
35fd c3 09 24			jp macro_next 
3600				endm 
# End of macro NEXTW
3600			.LOOP: 
3600				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
3600 22				db WORD_SYS_CORE+14             
3601 18 37			dw .I            
3603 05				db 4 + 1 
3604 .. 00			db "LOOP",0              
3609				endm 
# End of macro CWHEAD
3609			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3609			 
3609				; pop tos as current loop count to hl 
3609			 
3609				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3609			 
3609				FORTH_LOOP_TOS 
3609 cd b7 22			call macro_forth_loop_tos 
360c				endm 
# End of macro FORTH_LOOP_TOS
360c e5				push hl 
360d			 
360d					if DEBUG_FORTH_WORDS_KEY 
360d						DMARK "LOP" 
360d f5				push af  
360e 3a 22 36			ld a, (.dmark)  
3611 32 a6 fd			ld (debug_mark),a  
3614 3a 23 36			ld a, (.dmark+1)  
3617 32 a7 fd			ld (debug_mark+1),a  
361a 3a 24 36			ld a, (.dmark+2)  
361d 32 a8 fd			ld (debug_mark+2),a  
3620 18 03			jr .pastdmark  
3622 ..			.dmark: db "LOP"  
3625 f1			.pastdmark: pop af  
3626			endm  
# End of macro DMARK
3626						CALLMONITOR 
3626 cd aa fd			call debug_vector  
3629				endm  
# End of macro CALLMONITOR
3629					endif 
3629				; next item on the stack is the limit. get it 
3629			 
3629			 
3629				FORTH_LOOP_POP 
3629 cd c1 22			call macro_forth_loop_pop 
362c				endm 
# End of macro FORTH_LOOP_POP
362c			 
362c				FORTH_LOOP_TOS 
362c cd b7 22			call macro_forth_loop_tos 
362f				endm 
# End of macro FORTH_LOOP_TOS
362f			 
362f d1				pop de		 ; de = i, hl = limit 
3630			 
3630					if DEBUG_FORTH_WORDS 
3630						DMARK "LP1" 
3630 f5				push af  
3631 3a 45 36			ld a, (.dmark)  
3634 32 a6 fd			ld (debug_mark),a  
3637 3a 46 36			ld a, (.dmark+1)  
363a 32 a7 fd			ld (debug_mark+1),a  
363d 3a 47 36			ld a, (.dmark+2)  
3640 32 a8 fd			ld (debug_mark+2),a  
3643 18 03			jr .pastdmark  
3645 ..			.dmark: db "LP1"  
3648 f1			.pastdmark: pop af  
3649			endm  
# End of macro DMARK
3649						CALLMONITOR 
3649 cd aa fd			call debug_vector  
364c				endm  
# End of macro CALLMONITOR
364c					endif 
364c			 
364c				; go back to previous word 
364c			 
364c d5				push de    ; save I for inc later 
364d			 
364d			 
364d				; get limit 
364d				;  is I at limit? 
364d			 
364d			 
364d					if DEBUG_FORTH_WORDS 
364d						DMARK "LP1" 
364d f5				push af  
364e 3a 62 36			ld a, (.dmark)  
3651 32 a6 fd			ld (debug_mark),a  
3654 3a 63 36			ld a, (.dmark+1)  
3657 32 a7 fd			ld (debug_mark+1),a  
365a 3a 64 36			ld a, (.dmark+2)  
365d 32 a8 fd			ld (debug_mark+2),a  
3660 18 03			jr .pastdmark  
3662 ..			.dmark: db "LP1"  
3665 f1			.pastdmark: pop af  
3666			endm  
# End of macro DMARK
3666						CALLMONITOR 
3666 cd aa fd			call debug_vector  
3669				endm  
# End of macro CALLMONITOR
3669					endif 
3669			 
3669 ed 52			sbc hl, de 
366b			 
366b			 
366b				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
366b			 
366b 20 26				jr nz, .loopnotdone 
366d			 
366d e1				pop hl   ; get rid of saved I 
366e				FORTH_LOOP_POP     ; get rid of limit 
366e cd c1 22			call macro_forth_loop_pop 
3671				endm 
# End of macro FORTH_LOOP_POP
3671			 
3671				FORTH_RSP_POP     ; get rid of DO ptr 
3671 cd 24 20			call macro_forth_rsp_pop 
3674				endm 
# End of macro FORTH_RSP_POP
3674			 
3674			if DEBUG_FORTH_WORDS 
3674						DMARK "LP>" 
3674 f5				push af  
3675 3a 89 36			ld a, (.dmark)  
3678 32 a6 fd			ld (debug_mark),a  
367b 3a 8a 36			ld a, (.dmark+1)  
367e 32 a7 fd			ld (debug_mark+1),a  
3681 3a 8b 36			ld a, (.dmark+2)  
3684 32 a8 fd			ld (debug_mark+2),a  
3687 18 03			jr .pastdmark  
3689 ..			.dmark: db "LP>"  
368c f1			.pastdmark: pop af  
368d			endm  
# End of macro DMARK
368d				CALLMONITOR 
368d cd aa fd			call debug_vector  
3690				endm  
# End of macro CALLMONITOR
3690			endif 
3690			 
3690					NEXTW 
3690 c3 09 24			jp macro_next 
3693				endm 
# End of macro NEXTW
3693				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3693			 
3693			.loopnotdone: 
3693			 
3693 e1				pop hl    ; get I 
3694 23				inc hl 
3695			 
3695			   	; save new I 
3695			 
3695			 
3695					; set I counter 
3695			 
3695 22 21 f4				ld (os_current_i), hl 
3698			 
3698					if DEBUG_FORTH_WORDS 
3698						DMARK "LPN" 
3698 f5				push af  
3699 3a ad 36			ld a, (.dmark)  
369c 32 a6 fd			ld (debug_mark),a  
369f 3a ae 36			ld a, (.dmark+1)  
36a2 32 a7 fd			ld (debug_mark+1),a  
36a5 3a af 36			ld a, (.dmark+2)  
36a8 32 a8 fd			ld (debug_mark+2),a  
36ab 18 03			jr .pastdmark  
36ad ..			.dmark: db "LPN"  
36b0 f1			.pastdmark: pop af  
36b1			endm  
# End of macro DMARK
36b1					CALLMONITOR 
36b1 cd aa fd			call debug_vector  
36b4				endm  
# End of macro CALLMONITOR
36b4					endif 
36b4					 
36b4				FORTH_LOOP_NEXT 
36b4 cd 84 22			call macro_forth_loop_next 
36b7				endm 
# End of macro FORTH_LOOP_NEXT
36b7			 
36b7			 
36b7					if DEBUG_FORTH_WORDS 
36b7 eb						ex de,hl 
36b8					endif 
36b8			 
36b8			;	; get DO ptr 
36b8			; 
36b8					if DEBUG_FORTH_WORDS 
36b8						DMARK "LP7" 
36b8 f5				push af  
36b9 3a cd 36			ld a, (.dmark)  
36bc 32 a6 fd			ld (debug_mark),a  
36bf 3a ce 36			ld a, (.dmark+1)  
36c2 32 a7 fd			ld (debug_mark+1),a  
36c5 3a cf 36			ld a, (.dmark+2)  
36c8 32 a8 fd			ld (debug_mark+2),a  
36cb 18 03			jr .pastdmark  
36cd ..			.dmark: db "LP7"  
36d0 f1			.pastdmark: pop af  
36d1			endm  
# End of macro DMARK
36d1					CALLMONITOR 
36d1 cd aa fd			call debug_vector  
36d4				endm  
# End of macro CALLMONITOR
36d4					endif 
36d4				FORTH_RSP_TOS 
36d4 cd 1a 20			call macro_forth_rsp_tos 
36d7				endm 
# End of macro FORTH_RSP_TOS
36d7			 
36d7					if DEBUG_FORTH_WORDS 
36d7						DMARK "LP8" 
36d7 f5				push af  
36d8 3a ec 36			ld a, (.dmark)  
36db 32 a6 fd			ld (debug_mark),a  
36de 3a ed 36			ld a, (.dmark+1)  
36e1 32 a7 fd			ld (debug_mark+1),a  
36e4 3a ee 36			ld a, (.dmark+2)  
36e7 32 a8 fd			ld (debug_mark+2),a  
36ea 18 03			jr .pastdmark  
36ec ..			.dmark: db "LP8"  
36ef f1			.pastdmark: pop af  
36f0			endm  
# End of macro DMARK
36f0					CALLMONITOR 
36f0 cd aa fd			call debug_vector  
36f3				endm  
# End of macro CALLMONITOR
36f3					endif 
36f3				;push hl 
36f3			 
36f3				; not going to DO any more 
36f3				; get rid of the RSP pointer as DO will add it back in 
36f3				;FORTH_RSP_POP 
36f3				;pop hl 
36f3			 
36f3				;ld hl,(cli_ret_sp) 
36f3				;ld e, (hl) 
36f3				;inc hl 
36f3				;ld d, (hl) 
36f3				;ex de,hl 
36f3 22 fd f3			ld (os_tok_ptr), hl 
36f6					if DEBUG_FORTH_WORDS 
36f6						DMARK "LP<" 
36f6 f5				push af  
36f7 3a 0b 37			ld a, (.dmark)  
36fa 32 a6 fd			ld (debug_mark),a  
36fd 3a 0c 37			ld a, (.dmark+1)  
3700 32 a7 fd			ld (debug_mark+1),a  
3703 3a 0d 37			ld a, (.dmark+2)  
3706 32 a8 fd			ld (debug_mark+2),a  
3709 18 03			jr .pastdmark  
370b ..			.dmark: db "LP<"  
370e f1			.pastdmark: pop af  
370f			endm  
# End of macro DMARK
370f					CALLMONITOR 
370f cd aa fd			call debug_vector  
3712				endm  
# End of macro CALLMONITOR
3712				endif 
3712 c3 9a 24			jp exec1 
3715			 
3715					 
3715			 
3715			 
3715					NEXTW 
3715 c3 09 24			jp macro_next 
3718				endm 
# End of macro NEXTW
3718			.I:  
3718			 
3718				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3718 5e				db WORD_SYS_CORE+74             
3719 43 37			dw .DLOOP            
371b 02				db 1 + 1 
371c .. 00			db "I",0              
371e				endm 
# End of macro CWHEAD
371e			; | I ( -- ) Current loop counter | DONE 
371e					if DEBUG_FORTH_WORDS_KEY 
371e						DMARK "I.." 
371e f5				push af  
371f 3a 33 37			ld a, (.dmark)  
3722 32 a6 fd			ld (debug_mark),a  
3725 3a 34 37			ld a, (.dmark+1)  
3728 32 a7 fd			ld (debug_mark+1),a  
372b 3a 35 37			ld a, (.dmark+2)  
372e 32 a8 fd			ld (debug_mark+2),a  
3731 18 03			jr .pastdmark  
3733 ..			.dmark: db "I.."  
3736 f1			.pastdmark: pop af  
3737			endm  
# End of macro DMARK
3737						CALLMONITOR 
3737 cd aa fd			call debug_vector  
373a				endm  
# End of macro CALLMONITOR
373a					endif 
373a			 
373a 2a 21 f4				ld hl,(os_current_i) 
373d cd 5c 20				call forth_push_numhl 
3740			 
3740					NEXTW 
3740 c3 09 24			jp macro_next 
3743				endm 
# End of macro NEXTW
3743			.DLOOP: 
3743				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3743 5f				db WORD_SYS_CORE+75             
3744 24 38			dw .REPEAT            
3746 06				db 5 + 1 
3747 .. 00			db "-LOOP",0              
374d				endm 
# End of macro CWHEAD
374d			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
374d				; pop tos as current loop count to hl 
374d					if DEBUG_FORTH_WORDS_KEY 
374d						DMARK "-LP" 
374d f5				push af  
374e 3a 62 37			ld a, (.dmark)  
3751 32 a6 fd			ld (debug_mark),a  
3754 3a 63 37			ld a, (.dmark+1)  
3757 32 a7 fd			ld (debug_mark+1),a  
375a 3a 64 37			ld a, (.dmark+2)  
375d 32 a8 fd			ld (debug_mark+2),a  
3760 18 03			jr .pastdmark  
3762 ..			.dmark: db "-LP"  
3765 f1			.pastdmark: pop af  
3766			endm  
# End of macro DMARK
3766						CALLMONITOR 
3766 cd aa fd			call debug_vector  
3769				endm  
# End of macro CALLMONITOR
3769					endif 
3769			 
3769				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3769			 
3769				FORTH_LOOP_TOS 
3769 cd b7 22			call macro_forth_loop_tos 
376c				endm 
# End of macro FORTH_LOOP_TOS
376c e5				push hl 
376d			 
376d					if DEBUG_FORTH_WORDS 
376d						DMARK "-LP" 
376d f5				push af  
376e 3a 82 37			ld a, (.dmark)  
3771 32 a6 fd			ld (debug_mark),a  
3774 3a 83 37			ld a, (.dmark+1)  
3777 32 a7 fd			ld (debug_mark+1),a  
377a 3a 84 37			ld a, (.dmark+2)  
377d 32 a8 fd			ld (debug_mark+2),a  
3780 18 03			jr .pastdmark  
3782 ..			.dmark: db "-LP"  
3785 f1			.pastdmark: pop af  
3786			endm  
# End of macro DMARK
3786						CALLMONITOR 
3786 cd aa fd			call debug_vector  
3789				endm  
# End of macro CALLMONITOR
3789					endif 
3789				; next item on the stack is the limit. get it 
3789			 
3789			 
3789				FORTH_LOOP_POP 
3789 cd c1 22			call macro_forth_loop_pop 
378c				endm 
# End of macro FORTH_LOOP_POP
378c			 
378c				FORTH_LOOP_TOS 
378c cd b7 22			call macro_forth_loop_tos 
378f				endm 
# End of macro FORTH_LOOP_TOS
378f			 
378f d1				pop de		 ; de = i, hl = limit 
3790			 
3790					if DEBUG_FORTH_WORDS 
3790						DMARK "-L1" 
3790 f5				push af  
3791 3a a5 37			ld a, (.dmark)  
3794 32 a6 fd			ld (debug_mark),a  
3797 3a a6 37			ld a, (.dmark+1)  
379a 32 a7 fd			ld (debug_mark+1),a  
379d 3a a7 37			ld a, (.dmark+2)  
37a0 32 a8 fd			ld (debug_mark+2),a  
37a3 18 03			jr .pastdmark  
37a5 ..			.dmark: db "-L1"  
37a8 f1			.pastdmark: pop af  
37a9			endm  
# End of macro DMARK
37a9						CALLMONITOR 
37a9 cd aa fd			call debug_vector  
37ac				endm  
# End of macro CALLMONITOR
37ac					endif 
37ac			 
37ac				; go back to previous word 
37ac			 
37ac d5				push de    ; save I for inc later 
37ad			 
37ad			 
37ad				; get limit 
37ad				;  is I at limit? 
37ad			 
37ad			 
37ad					if DEBUG_FORTH_WORDS 
37ad						DMARK "-L1" 
37ad f5				push af  
37ae 3a c2 37			ld a, (.dmark)  
37b1 32 a6 fd			ld (debug_mark),a  
37b4 3a c3 37			ld a, (.dmark+1)  
37b7 32 a7 fd			ld (debug_mark+1),a  
37ba 3a c4 37			ld a, (.dmark+2)  
37bd 32 a8 fd			ld (debug_mark+2),a  
37c0 18 03			jr .pastdmark  
37c2 ..			.dmark: db "-L1"  
37c5 f1			.pastdmark: pop af  
37c6			endm  
# End of macro DMARK
37c6						CALLMONITOR 
37c6 cd aa fd			call debug_vector  
37c9				endm  
# End of macro CALLMONITOR
37c9					endif 
37c9			 
37c9 ed 52			sbc hl, de 
37cb			 
37cb			 
37cb				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
37cb			 
37cb 20 26				jr nz, .mloopnotdone 
37cd			 
37cd e1				pop hl   ; get rid of saved I 
37ce				FORTH_LOOP_POP     ; get rid of limit 
37ce cd c1 22			call macro_forth_loop_pop 
37d1				endm 
# End of macro FORTH_LOOP_POP
37d1			 
37d1				FORTH_RSP_POP     ; get rid of DO ptr 
37d1 cd 24 20			call macro_forth_rsp_pop 
37d4				endm 
# End of macro FORTH_RSP_POP
37d4			 
37d4			if DEBUG_FORTH_WORDS 
37d4						DMARK "-L>" 
37d4 f5				push af  
37d5 3a e9 37			ld a, (.dmark)  
37d8 32 a6 fd			ld (debug_mark),a  
37db 3a ea 37			ld a, (.dmark+1)  
37de 32 a7 fd			ld (debug_mark+1),a  
37e1 3a eb 37			ld a, (.dmark+2)  
37e4 32 a8 fd			ld (debug_mark+2),a  
37e7 18 03			jr .pastdmark  
37e9 ..			.dmark: db "-L>"  
37ec f1			.pastdmark: pop af  
37ed			endm  
# End of macro DMARK
37ed				CALLMONITOR 
37ed cd aa fd			call debug_vector  
37f0				endm  
# End of macro CALLMONITOR
37f0			endif 
37f0			 
37f0					NEXTW 
37f0 c3 09 24			jp macro_next 
37f3				endm 
# End of macro NEXTW
37f3				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
37f3			 
37f3			.mloopnotdone: 
37f3			 
37f3 e1				pop hl    ; get I 
37f4 2b				dec hl 
37f5			 
37f5			   	; save new I 
37f5			 
37f5			 
37f5					; set I counter 
37f5			 
37f5 22 21 f4				ld (os_current_i), hl 
37f8			 
37f8					 
37f8				FORTH_LOOP_NEXT 
37f8 cd 84 22			call macro_forth_loop_next 
37fb				endm 
# End of macro FORTH_LOOP_NEXT
37fb			 
37fb			 
37fb					if DEBUG_FORTH_WORDS 
37fb eb						ex de,hl 
37fc					endif 
37fc			 
37fc			;	; get DO ptr 
37fc			; 
37fc				FORTH_RSP_TOS 
37fc cd 1a 20			call macro_forth_rsp_tos 
37ff				endm 
# End of macro FORTH_RSP_TOS
37ff			 
37ff				;push hl 
37ff			 
37ff				; not going to DO any more 
37ff				; get rid of the RSP pointer as DO will add it back in 
37ff				;FORTH_RSP_POP 
37ff				;pop hl 
37ff			 
37ff			 
37ff 22 fd f3			ld (os_tok_ptr), hl 
3802					if DEBUG_FORTH_WORDS 
3802						DMARK "-L<" 
3802 f5				push af  
3803 3a 17 38			ld a, (.dmark)  
3806 32 a6 fd			ld (debug_mark),a  
3809 3a 18 38			ld a, (.dmark+1)  
380c 32 a7 fd			ld (debug_mark+1),a  
380f 3a 19 38			ld a, (.dmark+2)  
3812 32 a8 fd			ld (debug_mark+2),a  
3815 18 03			jr .pastdmark  
3817 ..			.dmark: db "-L<"  
381a f1			.pastdmark: pop af  
381b			endm  
# End of macro DMARK
381b					CALLMONITOR 
381b cd aa fd			call debug_vector  
381e				endm  
# End of macro CALLMONITOR
381e				endif 
381e c3 9a 24			jp exec1 
3821			 
3821					 
3821			 
3821			 
3821			 
3821				NEXTW 
3821 c3 09 24			jp macro_next 
3824				endm 
# End of macro NEXTW
3824			 
3824			 
3824			 
3824			 
3824			.REPEAT: 
3824				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3824 71				db WORD_SYS_CORE+93             
3825 77 38			dw .UNTIL            
3827 06				db 5 + 1 
3828 .. 00			db "REPEAT",0              
382f				endm 
# End of macro CWHEAD
382f			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
382f			;  push pc to rsp stack past the REPEAT 
382f					if DEBUG_FORTH_WORDS_KEY 
382f						DMARK "REP" 
382f f5				push af  
3830 3a 44 38			ld a, (.dmark)  
3833 32 a6 fd			ld (debug_mark),a  
3836 3a 45 38			ld a, (.dmark+1)  
3839 32 a7 fd			ld (debug_mark+1),a  
383c 3a 46 38			ld a, (.dmark+2)  
383f 32 a8 fd			ld (debug_mark+2),a  
3842 18 03			jr .pastdmark  
3844 ..			.dmark: db "REP"  
3847 f1			.pastdmark: pop af  
3848			endm  
# End of macro DMARK
3848						CALLMONITOR 
3848 cd aa fd			call debug_vector  
384b				endm  
# End of macro CALLMONITOR
384b					endif 
384b			 
384b 2a fd f3				ld hl, (os_tok_ptr) 
384e 23					inc hl   ; R 
384f 23					inc hl  ; E 
3850 23					inc hl   ; P 
3851 23					inc hl   ; E 
3852 23					inc hl   ; A 
3853 23					inc hl   ; T 
3854 23					inc hl   ; zero 
3855					FORTH_RSP_NEXT 
3855 cd 03 20			call macro_forth_rsp_next 
3858				endm 
# End of macro FORTH_RSP_NEXT
3858			 
3858			 
3858					if DEBUG_FORTH_WORDS 
3858						DMARK "REP" 
3858 f5				push af  
3859 3a 6d 38			ld a, (.dmark)  
385c 32 a6 fd			ld (debug_mark),a  
385f 3a 6e 38			ld a, (.dmark+1)  
3862 32 a7 fd			ld (debug_mark+1),a  
3865 3a 6f 38			ld a, (.dmark+2)  
3868 32 a8 fd			ld (debug_mark+2),a  
386b 18 03			jr .pastdmark  
386d ..			.dmark: db "REP"  
3870 f1			.pastdmark: pop af  
3871			endm  
# End of macro DMARK
3871						;pop bc    ; TODO BUG ?????? what is this for???? 
3871						CALLMONITOR 
3871 cd aa fd			call debug_vector  
3874				endm  
# End of macro CALLMONITOR
3874					endif 
3874			 
3874					NEXTW 
3874 c3 09 24			jp macro_next 
3877				endm 
# End of macro NEXTW
3877			;	       NEXTW 
3877			 
3877			.UNTIL: 
3877				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3877 72				db WORD_SYS_CORE+94             
3878 0e 39			dw .ENDFLOW            
387a 06				db 5 + 1 
387b .. 00			db "UNTIL",0              
3881				endm 
# End of macro CWHEAD
3881			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3881			 
3881				; pop tos as check 
3881			 
3881				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3881			 
3881				FORTH_DSP_VALUEHL 
3881 cd 53 22			call macro_dsp_valuehl 
3884				endm 
# End of macro FORTH_DSP_VALUEHL
3884			 
3884					if DEBUG_FORTH_WORDS_KEY 
3884						DMARK "UNT" 
3884 f5				push af  
3885 3a 99 38			ld a, (.dmark)  
3888 32 a6 fd			ld (debug_mark),a  
388b 3a 9a 38			ld a, (.dmark+1)  
388e 32 a7 fd			ld (debug_mark+1),a  
3891 3a 9b 38			ld a, (.dmark+2)  
3894 32 a8 fd			ld (debug_mark+2),a  
3897 18 03			jr .pastdmark  
3899 ..			.dmark: db "UNT"  
389c f1			.pastdmark: pop af  
389d			endm  
# End of macro DMARK
389d						CALLMONITOR 
389d cd aa fd			call debug_vector  
38a0				endm  
# End of macro CALLMONITOR
38a0					endif 
38a0			 
38a0			;	push hl 
38a0				FORTH_DSP_POP 
38a0 cd 0b 23			call macro_forth_dsp_pop 
38a3				endm 
# End of macro FORTH_DSP_POP
38a3			 
38a3			;	pop hl 
38a3			 
38a3				; test if true 
38a3			 
38a3 cd f8 0f			call ishlzero 
38a6			;	ld a,l 
38a6			;	add h 
38a6			; 
38a6			;	cp 0 
38a6			 
38a6 20 3e			jr nz, .untilnotdone 
38a8			 
38a8					if DEBUG_FORTH_WORDS 
38a8						DMARK "UNf" 
38a8 f5				push af  
38a9 3a bd 38			ld a, (.dmark)  
38ac 32 a6 fd			ld (debug_mark),a  
38af 3a be 38			ld a, (.dmark+1)  
38b2 32 a7 fd			ld (debug_mark+1),a  
38b5 3a bf 38			ld a, (.dmark+2)  
38b8 32 a8 fd			ld (debug_mark+2),a  
38bb 18 03			jr .pastdmark  
38bd ..			.dmark: db "UNf"  
38c0 f1			.pastdmark: pop af  
38c1			endm  
# End of macro DMARK
38c1						CALLMONITOR 
38c1 cd aa fd			call debug_vector  
38c4				endm  
# End of macro CALLMONITOR
38c4					endif 
38c4			 
38c4			 
38c4			 
38c4				FORTH_RSP_POP     ; get rid of DO ptr 
38c4 cd 24 20			call macro_forth_rsp_pop 
38c7				endm 
# End of macro FORTH_RSP_POP
38c7			 
38c7			if DEBUG_FORTH_WORDS 
38c7						DMARK "UN>" 
38c7 f5				push af  
38c8 3a dc 38			ld a, (.dmark)  
38cb 32 a6 fd			ld (debug_mark),a  
38ce 3a dd 38			ld a, (.dmark+1)  
38d1 32 a7 fd			ld (debug_mark+1),a  
38d4 3a de 38			ld a, (.dmark+2)  
38d7 32 a8 fd			ld (debug_mark+2),a  
38da 18 03			jr .pastdmark  
38dc ..			.dmark: db "UN>"  
38df f1			.pastdmark: pop af  
38e0			endm  
# End of macro DMARK
38e0				CALLMONITOR 
38e0 cd aa fd			call debug_vector  
38e3				endm  
# End of macro CALLMONITOR
38e3			endif 
38e3			 
38e3					NEXTW 
38e3 c3 09 24			jp macro_next 
38e6				endm 
# End of macro NEXTW
38e6				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
38e6			 
38e6			.untilnotdone: 
38e6			 
38e6			 
38e6			;	; get DO ptr 
38e6			; 
38e6				FORTH_RSP_TOS 
38e6 cd 1a 20			call macro_forth_rsp_tos 
38e9				endm 
# End of macro FORTH_RSP_TOS
38e9			 
38e9				;push hl 
38e9			 
38e9				; not going to DO any more 
38e9				; get rid of the RSP pointer as DO will add it back in 
38e9				;FORTH_RSP_POP 
38e9				;pop hl 
38e9			 
38e9			 
38e9 22 fd f3			ld (os_tok_ptr), hl 
38ec					if DEBUG_FORTH_WORDS 
38ec						DMARK "UN<" 
38ec f5				push af  
38ed 3a 01 39			ld a, (.dmark)  
38f0 32 a6 fd			ld (debug_mark),a  
38f3 3a 02 39			ld a, (.dmark+1)  
38f6 32 a7 fd			ld (debug_mark+1),a  
38f9 3a 03 39			ld a, (.dmark+2)  
38fc 32 a8 fd			ld (debug_mark+2),a  
38ff 18 03			jr .pastdmark  
3901 ..			.dmark: db "UN<"  
3904 f1			.pastdmark: pop af  
3905			endm  
# End of macro DMARK
3905					CALLMONITOR 
3905 cd aa fd			call debug_vector  
3908				endm  
# End of macro CALLMONITOR
3908				endif 
3908 c3 9a 24			jp exec1 
390b			 
390b					 
390b			 
390b			 
390b					NEXTW 
390b c3 09 24			jp macro_next 
390e				endm 
# End of macro NEXTW
390e			 
390e			 
390e			.ENDFLOW: 
390e			 
390e			; eof 
390e			 
# End of file forth_words_flow.asm
390e			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
390e			include "forth_words_logic.asm" 
390e			 
390e			; | ## Logic Words 
390e			 
390e			.NOT: 
390e				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
390e 2d				db WORD_SYS_CORE+25             
390f 56 39			dw .IS            
3911 04				db 3 + 1 
3912 .. 00			db "NOT",0              
3916				endm 
# End of macro CWHEAD
3916			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3916					if DEBUG_FORTH_WORDS_KEY 
3916						DMARK "NOT" 
3916 f5				push af  
3917 3a 2b 39			ld a, (.dmark)  
391a 32 a6 fd			ld (debug_mark),a  
391d 3a 2c 39			ld a, (.dmark+1)  
3920 32 a7 fd			ld (debug_mark+1),a  
3923 3a 2d 39			ld a, (.dmark+2)  
3926 32 a8 fd			ld (debug_mark+2),a  
3929 18 03			jr .pastdmark  
392b ..			.dmark: db "NOT"  
392e f1			.pastdmark: pop af  
392f			endm  
# End of macro DMARK
392f						CALLMONITOR 
392f cd aa fd			call debug_vector  
3932				endm  
# End of macro CALLMONITOR
3932					endif 
3932					FORTH_DSP 
3932 cd 19 22			call macro_forth_dsp 
3935				endm 
# End of macro FORTH_DSP
3935 7e					ld a,(hl)	; get type of value on TOS 
3936 fe 02				cp DS_TYPE_INUM  
3938 28 03				jr z, .noti 
393a					NEXTW 
393a c3 09 24			jp macro_next 
393d				endm 
# End of macro NEXTW
393d			.noti:          FORTH_DSP_VALUEHL 
393d cd 53 22			call macro_dsp_valuehl 
3940				endm 
# End of macro FORTH_DSP_VALUEHL
3940			;		push hl 
3940					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3940 cd 0b 23			call macro_forth_dsp_pop 
3943				endm 
# End of macro FORTH_DSP_POP
3943			;		pop hl 
3943 3e 00				ld a,0 
3945 bd					cp l 
3946 28 04				jr z, .not2t 
3948 2e 00				ld l, 0 
394a 18 02				jr .notip 
394c			 
394c 2e ff		.not2t:		ld l, 255 
394e			 
394e 26 00		.notip:		ld h, 0	 
3950			 
3950 cd 5c 20				call forth_push_numhl 
3953					NEXTW 
3953 c3 09 24			jp macro_next 
3956				endm 
# End of macro NEXTW
3956			 
3956			.IS: 
3956				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3956 2d				db WORD_SYS_CORE+25             
3957 7c 39			dw .LZERO            
3959 03				db 2 + 1 
395a .. 00			db "IS",0              
395d				endm 
# End of macro CWHEAD
395d			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
395d					if DEBUG_FORTH_WORDS_KEY 
395d						DMARK "IS." 
395d f5				push af  
395e 3a 72 39			ld a, (.dmark)  
3961 32 a6 fd			ld (debug_mark),a  
3964 3a 73 39			ld a, (.dmark+1)  
3967 32 a7 fd			ld (debug_mark+1),a  
396a 3a 74 39			ld a, (.dmark+2)  
396d 32 a8 fd			ld (debug_mark+2),a  
3970 18 03			jr .pastdmark  
3972 ..			.dmark: db "IS."  
3975 f1			.pastdmark: pop af  
3976			endm  
# End of macro DMARK
3976						CALLMONITOR 
3976 cd aa fd			call debug_vector  
3979				endm  
# End of macro CALLMONITOR
3979					endif 
3979					NEXTW 
3979 c3 09 24			jp macro_next 
397c				endm 
# End of macro NEXTW
397c			.LZERO: 
397c				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
397c 2d				db WORD_SYS_CORE+25             
397d 86 39			dw .TZERO            
397f 03				db 2 + 1 
3980 .. 00			db "0<",0              
3983				endm 
# End of macro CWHEAD
3983			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3983					NEXTW 
3983 c3 09 24			jp macro_next 
3986				endm 
# End of macro NEXTW
3986			.TZERO: 
3986				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3986 2e				db WORD_SYS_CORE+26             
3987 cd 39			dw .LESS            
3989 03				db 2 + 1 
398a .. 00			db "0=",0              
398d				endm 
# End of macro CWHEAD
398d			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
398d				; TODO add floating point number detection 
398d					;v5 FORTH_DSP_VALUE 
398d					if DEBUG_FORTH_WORDS_KEY 
398d						DMARK "0=." 
398d f5				push af  
398e 3a a2 39			ld a, (.dmark)  
3991 32 a6 fd			ld (debug_mark),a  
3994 3a a3 39			ld a, (.dmark+1)  
3997 32 a7 fd			ld (debug_mark+1),a  
399a 3a a4 39			ld a, (.dmark+2)  
399d 32 a8 fd			ld (debug_mark+2),a  
39a0 18 03			jr .pastdmark  
39a2 ..			.dmark: db "0=."  
39a5 f1			.pastdmark: pop af  
39a6			endm  
# End of macro DMARK
39a6						CALLMONITOR 
39a6 cd aa fd			call debug_vector  
39a9				endm  
# End of macro CALLMONITOR
39a9					endif 
39a9					FORTH_DSP 
39a9 cd 19 22			call macro_forth_dsp 
39ac				endm 
# End of macro FORTH_DSP
39ac 7e					ld a,(hl)	; get type of value on TOS 
39ad fe 02				cp DS_TYPE_INUM  
39af 28 00				jr z, .tz_inum 
39b1			 
39b1				if FORTH_ENABLE_FLOATMATH 
39b1					jr .tz_done 
39b1			 
39b1				endif 
39b1					 
39b1			 
39b1			.tz_inum: 
39b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39b1 cd 53 22			call macro_dsp_valuehl 
39b4				endm 
# End of macro FORTH_DSP_VALUEHL
39b4			 
39b4			;		push hl 
39b4			 
39b4					; destroy value TOS 
39b4			 
39b4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39b4 cd 0b 23			call macro_forth_dsp_pop 
39b7				endm 
# End of macro FORTH_DSP_POP
39b7			 
39b7			;		pop hl 
39b7			 
39b7 3e 00				ld a,0 
39b9			 
39b9 bd					cp l 
39ba 20 08				jr nz, .tz_notzero 
39bc			 
39bc bc					cp h 
39bd			 
39bd 20 05				jr nz, .tz_notzero 
39bf			 
39bf			 
39bf 21 01 00				ld hl, FORTH_TRUE 
39c2 18 03				jr .tz_done 
39c4			 
39c4 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
39c7			 
39c7					; push value back onto stack for another op etc 
39c7			 
39c7			.tz_done: 
39c7 cd 5c 20				call forth_push_numhl 
39ca			 
39ca					NEXTW 
39ca c3 09 24			jp macro_next 
39cd				endm 
# End of macro NEXTW
39cd			.LESS: 
39cd				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
39cd 2f				db WORD_SYS_CORE+27             
39ce 36 3a			dw .GT            
39d0 02				db 1 + 1 
39d1 .. 00			db "<",0              
39d3				endm 
# End of macro CWHEAD
39d3			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
39d3				; TODO add floating point number detection 
39d3					if DEBUG_FORTH_WORDS_KEY 
39d3						DMARK "LES" 
39d3 f5				push af  
39d4 3a e8 39			ld a, (.dmark)  
39d7 32 a6 fd			ld (debug_mark),a  
39da 3a e9 39			ld a, (.dmark+1)  
39dd 32 a7 fd			ld (debug_mark+1),a  
39e0 3a ea 39			ld a, (.dmark+2)  
39e3 32 a8 fd			ld (debug_mark+2),a  
39e6 18 03			jr .pastdmark  
39e8 ..			.dmark: db "LES"  
39eb f1			.pastdmark: pop af  
39ec			endm  
# End of macro DMARK
39ec						CALLMONITOR 
39ec cd aa fd			call debug_vector  
39ef				endm  
# End of macro CALLMONITOR
39ef					endif 
39ef					FORTH_DSP 
39ef cd 19 22			call macro_forth_dsp 
39f2				endm 
# End of macro FORTH_DSP
39f2					;v5 FORTH_DSP_VALUE 
39f2 7e					ld a,(hl)	; get type of value on TOS 
39f3 fe 02				cp DS_TYPE_INUM  
39f5 28 00				jr z, .less_inum 
39f7			 
39f7				if FORTH_ENABLE_FLOATMATH 
39f7					jr .less_done 
39f7			 
39f7				endif 
39f7					 
39f7			 
39f7			.less_inum: 
39f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39f7 cd 53 22			call macro_dsp_valuehl 
39fa				endm 
# End of macro FORTH_DSP_VALUEHL
39fa			 
39fa e5					push hl  ; u2 
39fb			 
39fb					; destroy value TOS 
39fb			 
39fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39fb cd 0b 23			call macro_forth_dsp_pop 
39fe				endm 
# End of macro FORTH_DSP_POP
39fe			 
39fe			 
39fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39fe cd 53 22			call macro_dsp_valuehl 
3a01				endm 
# End of macro FORTH_DSP_VALUEHL
3a01			 
3a01 e5					push hl    ; u1 
3a02			 
3a02					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a02 cd 0b 23			call macro_forth_dsp_pop 
3a05				endm 
# End of macro FORTH_DSP_POP
3a05			 
3a05			 
3a05 b7			 or a      ;clear carry flag 
3a06 01 00 00		 ld bc, FORTH_FALSE 
3a09 e1			  pop hl    ; u1 
3a0a d1			  pop de    ; u2 
3a0b ed 52		  sbc hl,de 
3a0d 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3a0f			 
3a0f 01 01 00		 ld bc, FORTH_TRUE 
3a12			.lscont:  
3a12 c5					push bc 
3a13 e1					pop hl 
3a14			 
3a14					if DEBUG_FORTH_WORDS 
3a14						DMARK "LT1" 
3a14 f5				push af  
3a15 3a 29 3a			ld a, (.dmark)  
3a18 32 a6 fd			ld (debug_mark),a  
3a1b 3a 2a 3a			ld a, (.dmark+1)  
3a1e 32 a7 fd			ld (debug_mark+1),a  
3a21 3a 2b 3a			ld a, (.dmark+2)  
3a24 32 a8 fd			ld (debug_mark+2),a  
3a27 18 03			jr .pastdmark  
3a29 ..			.dmark: db "LT1"  
3a2c f1			.pastdmark: pop af  
3a2d			endm  
# End of macro DMARK
3a2d						CALLMONITOR 
3a2d cd aa fd			call debug_vector  
3a30				endm  
# End of macro CALLMONITOR
3a30					endif 
3a30 cd 5c 20				call forth_push_numhl 
3a33			 
3a33					NEXTW 
3a33 c3 09 24			jp macro_next 
3a36				endm 
# End of macro NEXTW
3a36			.GT: 
3a36				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3a36 30				db WORD_SYS_CORE+28             
3a37 9f 3a			dw .EQUAL            
3a39 02				db 1 + 1 
3a3a .. 00			db ">",0              
3a3c				endm 
# End of macro CWHEAD
3a3c			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3a3c				; TODO add floating point number detection 
3a3c					if DEBUG_FORTH_WORDS_KEY 
3a3c						DMARK "GRT" 
3a3c f5				push af  
3a3d 3a 51 3a			ld a, (.dmark)  
3a40 32 a6 fd			ld (debug_mark),a  
3a43 3a 52 3a			ld a, (.dmark+1)  
3a46 32 a7 fd			ld (debug_mark+1),a  
3a49 3a 53 3a			ld a, (.dmark+2)  
3a4c 32 a8 fd			ld (debug_mark+2),a  
3a4f 18 03			jr .pastdmark  
3a51 ..			.dmark: db "GRT"  
3a54 f1			.pastdmark: pop af  
3a55			endm  
# End of macro DMARK
3a55						CALLMONITOR 
3a55 cd aa fd			call debug_vector  
3a58				endm  
# End of macro CALLMONITOR
3a58					endif 
3a58					FORTH_DSP 
3a58 cd 19 22			call macro_forth_dsp 
3a5b				endm 
# End of macro FORTH_DSP
3a5b					;FORTH_DSP_VALUE 
3a5b 7e					ld a,(hl)	; get type of value on TOS 
3a5c fe 02				cp DS_TYPE_INUM  
3a5e 28 00				jr z, .gt_inum 
3a60			 
3a60				if FORTH_ENABLE_FLOATMATH 
3a60					jr .gt_done 
3a60			 
3a60				endif 
3a60					 
3a60			 
3a60			.gt_inum: 
3a60					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a60 cd 53 22			call macro_dsp_valuehl 
3a63				endm 
# End of macro FORTH_DSP_VALUEHL
3a63			 
3a63 e5					push hl  ; u2 
3a64			 
3a64					; destroy value TOS 
3a64			 
3a64					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a64 cd 0b 23			call macro_forth_dsp_pop 
3a67				endm 
# End of macro FORTH_DSP_POP
3a67			 
3a67			 
3a67					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a67 cd 53 22			call macro_dsp_valuehl 
3a6a				endm 
# End of macro FORTH_DSP_VALUEHL
3a6a			 
3a6a e5					push hl    ; u1 
3a6b			 
3a6b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a6b cd 0b 23			call macro_forth_dsp_pop 
3a6e				endm 
# End of macro FORTH_DSP_POP
3a6e			 
3a6e			 
3a6e b7			 or a      ;clear carry flag 
3a6f 01 00 00		 ld bc, FORTH_FALSE 
3a72 e1			  pop hl    ; u1 
3a73 d1			  pop de    ; u2 
3a74 ed 52		  sbc hl,de 
3a76 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3a78			 
3a78 01 01 00		 ld bc, FORTH_TRUE 
3a7b			.gtcont:  
3a7b c5					push bc 
3a7c e1					pop hl 
3a7d			 
3a7d					if DEBUG_FORTH_WORDS 
3a7d						DMARK "GT1" 
3a7d f5				push af  
3a7e 3a 92 3a			ld a, (.dmark)  
3a81 32 a6 fd			ld (debug_mark),a  
3a84 3a 93 3a			ld a, (.dmark+1)  
3a87 32 a7 fd			ld (debug_mark+1),a  
3a8a 3a 94 3a			ld a, (.dmark+2)  
3a8d 32 a8 fd			ld (debug_mark+2),a  
3a90 18 03			jr .pastdmark  
3a92 ..			.dmark: db "GT1"  
3a95 f1			.pastdmark: pop af  
3a96			endm  
# End of macro DMARK
3a96						CALLMONITOR 
3a96 cd aa fd			call debug_vector  
3a99				endm  
# End of macro CALLMONITOR
3a99					endif 
3a99 cd 5c 20				call forth_push_numhl 
3a9c			 
3a9c					NEXTW 
3a9c c3 09 24			jp macro_next 
3a9f				endm 
# End of macro NEXTW
3a9f			.EQUAL: 
3a9f				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3a9f 31				db WORD_SYS_CORE+29             
3aa0 0a 3b			dw .ENDLOGIC            
3aa2 02				db 1 + 1 
3aa3 .. 00			db "=",0              
3aa5				endm 
# End of macro CWHEAD
3aa5			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3aa5				; TODO add floating point number detection 
3aa5					if DEBUG_FORTH_WORDS_KEY 
3aa5						DMARK "EQ." 
3aa5 f5				push af  
3aa6 3a ba 3a			ld a, (.dmark)  
3aa9 32 a6 fd			ld (debug_mark),a  
3aac 3a bb 3a			ld a, (.dmark+1)  
3aaf 32 a7 fd			ld (debug_mark+1),a  
3ab2 3a bc 3a			ld a, (.dmark+2)  
3ab5 32 a8 fd			ld (debug_mark+2),a  
3ab8 18 03			jr .pastdmark  
3aba ..			.dmark: db "EQ."  
3abd f1			.pastdmark: pop af  
3abe			endm  
# End of macro DMARK
3abe						CALLMONITOR 
3abe cd aa fd			call debug_vector  
3ac1				endm  
# End of macro CALLMONITOR
3ac1					endif 
3ac1					FORTH_DSP 
3ac1 cd 19 22			call macro_forth_dsp 
3ac4				endm 
# End of macro FORTH_DSP
3ac4					;v5 FORTH_DSP_VALUE 
3ac4 7e					ld a,(hl)	; get type of value on TOS 
3ac5 fe 02				cp DS_TYPE_INUM  
3ac7 28 00				jr z, .eq_inum 
3ac9			 
3ac9				if FORTH_ENABLE_FLOATMATH 
3ac9					jr .eq_done 
3ac9			 
3ac9				endif 
3ac9					 
3ac9			 
3ac9			.eq_inum: 
3ac9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ac9 cd 53 22			call macro_dsp_valuehl 
3acc				endm 
# End of macro FORTH_DSP_VALUEHL
3acc			 
3acc e5					push hl 
3acd			 
3acd					; destroy value TOS 
3acd			 
3acd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3acd cd 0b 23			call macro_forth_dsp_pop 
3ad0				endm 
# End of macro FORTH_DSP_POP
3ad0			 
3ad0			 
3ad0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ad0 cd 53 22			call macro_dsp_valuehl 
3ad3				endm 
# End of macro FORTH_DSP_VALUEHL
3ad3			 
3ad3					; one value on hl get other one back 
3ad3			 
3ad3 e5					push hl 
3ad4			 
3ad4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ad4 cd 0b 23			call macro_forth_dsp_pop 
3ad7				endm 
# End of macro FORTH_DSP_POP
3ad7			 
3ad7 0e 00				ld c, FORTH_FALSE 
3ad9			 
3ad9 e1					pop hl 
3ada d1					pop de 
3adb			 
3adb 7b					ld a, e 
3adc bd					cp l 
3add			 
3add 20 06				jr nz, .eq_done 
3adf			 
3adf 7a					ld a, d 
3ae0 bc					cp h 
3ae1			 
3ae1 20 02				jr nz, .eq_done 
3ae3			 
3ae3 0e 01				ld c, FORTH_TRUE 
3ae5					 
3ae5			 
3ae5			 
3ae5			.eq_done: 
3ae5			 
3ae5					; TODO push value back onto stack for another op etc 
3ae5			 
3ae5 26 00				ld h, 0 
3ae7 69					ld l, c 
3ae8					if DEBUG_FORTH_WORDS 
3ae8						DMARK "EQ1" 
3ae8 f5				push af  
3ae9 3a fd 3a			ld a, (.dmark)  
3aec 32 a6 fd			ld (debug_mark),a  
3aef 3a fe 3a			ld a, (.dmark+1)  
3af2 32 a7 fd			ld (debug_mark+1),a  
3af5 3a ff 3a			ld a, (.dmark+2)  
3af8 32 a8 fd			ld (debug_mark+2),a  
3afb 18 03			jr .pastdmark  
3afd ..			.dmark: db "EQ1"  
3b00 f1			.pastdmark: pop af  
3b01			endm  
# End of macro DMARK
3b01						CALLMONITOR 
3b01 cd aa fd			call debug_vector  
3b04				endm  
# End of macro CALLMONITOR
3b04					endif 
3b04 cd 5c 20				call forth_push_numhl 
3b07			 
3b07					NEXTW 
3b07 c3 09 24			jp macro_next 
3b0a				endm 
# End of macro NEXTW
3b0a			 
3b0a			 
3b0a			.ENDLOGIC: 
3b0a			; eof 
3b0a			 
3b0a			 
# End of file forth_words_logic.asm
3b0a			include "forth_words_maths.asm" 
3b0a			 
3b0a			; | ## Maths Words 
3b0a			 
3b0a			.PLUS:	 
3b0a				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3b0a 15				db WORD_SYS_CORE+1             
3b0b 68 3b			dw .NEG            
3b0d 02				db 1 + 1 
3b0e .. 00			db "+",0              
3b10				endm 
# End of macro CWHEAD
3b10			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3b10					if DEBUG_FORTH_WORDS_KEY 
3b10						DMARK "PLU" 
3b10 f5				push af  
3b11 3a 25 3b			ld a, (.dmark)  
3b14 32 a6 fd			ld (debug_mark),a  
3b17 3a 26 3b			ld a, (.dmark+1)  
3b1a 32 a7 fd			ld (debug_mark+1),a  
3b1d 3a 27 3b			ld a, (.dmark+2)  
3b20 32 a8 fd			ld (debug_mark+2),a  
3b23 18 03			jr .pastdmark  
3b25 ..			.dmark: db "PLU"  
3b28 f1			.pastdmark: pop af  
3b29			endm  
# End of macro DMARK
3b29						CALLMONITOR 
3b29 cd aa fd			call debug_vector  
3b2c				endm  
# End of macro CALLMONITOR
3b2c					endif 
3b2c					; add top two values and push back result 
3b2c			 
3b2c					;for v5 FORTH_DSP_VALUE 
3b2c					FORTH_DSP 
3b2c cd 19 22			call macro_forth_dsp 
3b2f				endm 
# End of macro FORTH_DSP
3b2f 7e					ld a,(hl)	; get type of value on TOS 
3b30 fe 02				cp DS_TYPE_INUM  
3b32 28 03				jr z, .dot_inum 
3b34			 
3b34					NEXTW 
3b34 c3 09 24			jp macro_next 
3b37				endm 
# End of macro NEXTW
3b37			 
3b37			; float maths 
3b37			 
3b37				if FORTH_ENABLE_FLOATMATH 
3b37						inc hl      ; now at start of numeric as string 
3b37			 
3b37					if DEBUG_FORTH_MATHS 
3b37						DMARK "ADD" 
3b37				CALLMONITOR 
3b37					endif 
3b37			 
3b37					;ld ix, hl 
3b37					call CON 
3b37			 
3b37			 
3b37					push hl 
3b37					 
3b37					 
3b37			 
3b37						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3b37			 
3b37					; get next number 
3b37			 
3b37						FORTH_DSP_VALUE 
3b37			 
3b37						inc hl      ; now at start of numeric as string 
3b37			 
3b37					;ld ix, hl 
3b37					call CON 
3b37			 
3b37					push hl 
3b37			 
3b37			 
3b37						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b37			 
3b37						; TODO do add 
3b37			 
3b37						call IADD 
3b37			 
3b37						; TODO get result back as ascii 
3b37			 
3b37						; TODO push result  
3b37			 
3b37			 
3b37			 
3b37						jr .dot_done 
3b37				endif 
3b37			 
3b37			.dot_inum: 
3b37			 
3b37			 
3b37					if DEBUG_FORTH_DOT 
3b37						DMARK "+IT" 
3b37 f5				push af  
3b38 3a 4c 3b			ld a, (.dmark)  
3b3b 32 a6 fd			ld (debug_mark),a  
3b3e 3a 4d 3b			ld a, (.dmark+1)  
3b41 32 a7 fd			ld (debug_mark+1),a  
3b44 3a 4e 3b			ld a, (.dmark+2)  
3b47 32 a8 fd			ld (debug_mark+2),a  
3b4a 18 03			jr .pastdmark  
3b4c ..			.dmark: db "+IT"  
3b4f f1			.pastdmark: pop af  
3b50			endm  
# End of macro DMARK
3b50				CALLMONITOR 
3b50 cd aa fd			call debug_vector  
3b53				endm  
# End of macro CALLMONITOR
3b53					endif 
3b53			 
3b53					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b53 cd 53 22			call macro_dsp_valuehl 
3b56				endm 
# End of macro FORTH_DSP_VALUEHL
3b56			 
3b56				; TODO add floating point number detection 
3b56			 
3b56 e5					push hl 
3b57			 
3b57					; destroy value TOS 
3b57			 
3b57					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b57 cd 0b 23			call macro_forth_dsp_pop 
3b5a				endm 
# End of macro FORTH_DSP_POP
3b5a			 
3b5a			 
3b5a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b5a cd 53 22			call macro_dsp_valuehl 
3b5d				endm 
# End of macro FORTH_DSP_VALUEHL
3b5d			 
3b5d					; one value on hl get other one back 
3b5d			 
3b5d d1					pop de 
3b5e			 
3b5e					; do the add 
3b5e			 
3b5e 19					add hl,de 
3b5f			 
3b5f					; save it 
3b5f			 
3b5f			;		push hl	 
3b5f			 
3b5f					; 
3b5f			 
3b5f					; destroy value TOS 
3b5f			 
3b5f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b5f cd 0b 23			call macro_forth_dsp_pop 
3b62				endm 
# End of macro FORTH_DSP_POP
3b62			 
3b62					; TODO push value back onto stack for another op etc 
3b62			 
3b62			;		pop hl 
3b62			 
3b62			.dot_done: 
3b62 cd 5c 20				call forth_push_numhl 
3b65			 
3b65					NEXTW 
3b65 c3 09 24			jp macro_next 
3b68				endm 
# End of macro NEXTW
3b68			.NEG: 
3b68			 
3b68				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3b68 17				db WORD_SYS_CORE+3             
3b69 ab 3b			dw .DIV            
3b6b 02				db 1 + 1 
3b6c .. 00			db "-",0              
3b6e				endm 
# End of macro CWHEAD
3b6e			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3b6e					if DEBUG_FORTH_WORDS_KEY 
3b6e						DMARK "SUB" 
3b6e f5				push af  
3b6f 3a 83 3b			ld a, (.dmark)  
3b72 32 a6 fd			ld (debug_mark),a  
3b75 3a 84 3b			ld a, (.dmark+1)  
3b78 32 a7 fd			ld (debug_mark+1),a  
3b7b 3a 85 3b			ld a, (.dmark+2)  
3b7e 32 a8 fd			ld (debug_mark+2),a  
3b81 18 03			jr .pastdmark  
3b83 ..			.dmark: db "SUB"  
3b86 f1			.pastdmark: pop af  
3b87			endm  
# End of macro DMARK
3b87						CALLMONITOR 
3b87 cd aa fd			call debug_vector  
3b8a				endm  
# End of macro CALLMONITOR
3b8a					endif 
3b8a			 
3b8a			 
3b8a				; TODO add floating point number detection 
3b8a					; v5 FORTH_DSP_VALUE 
3b8a					FORTH_DSP 
3b8a cd 19 22			call macro_forth_dsp 
3b8d				endm 
# End of macro FORTH_DSP
3b8d 7e					ld a,(hl)	; get type of value on TOS 
3b8e fe 02				cp DS_TYPE_INUM  
3b90 28 03				jr z, .neg_inum 
3b92			 
3b92					NEXTW 
3b92 c3 09 24			jp macro_next 
3b95				endm 
# End of macro NEXTW
3b95			 
3b95			; float maths 
3b95			 
3b95				if FORTH_ENABLE_FLOATMATH 
3b95					jr .neg_done 
3b95			 
3b95				endif 
3b95					 
3b95			 
3b95			.neg_inum: 
3b95					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b95 cd 53 22			call macro_dsp_valuehl 
3b98				endm 
# End of macro FORTH_DSP_VALUEHL
3b98			 
3b98 e5					push hl 
3b99			 
3b99					; destroy value TOS 
3b99			 
3b99					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b99 cd 0b 23			call macro_forth_dsp_pop 
3b9c				endm 
# End of macro FORTH_DSP_POP
3b9c			 
3b9c			 
3b9c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b9c cd 53 22			call macro_dsp_valuehl 
3b9f				endm 
# End of macro FORTH_DSP_VALUEHL
3b9f			 
3b9f					; one value on hl get other one back 
3b9f			 
3b9f d1					pop de 
3ba0			 
3ba0					; do the sub 
3ba0			;		ex de, hl 
3ba0			 
3ba0 ed 52				sbc hl,de 
3ba2			 
3ba2					; save it 
3ba2			 
3ba2			;		push hl	 
3ba2			 
3ba2					; 
3ba2			 
3ba2					; destroy value TOS 
3ba2			 
3ba2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ba2 cd 0b 23			call macro_forth_dsp_pop 
3ba5				endm 
# End of macro FORTH_DSP_POP
3ba5			 
3ba5					; TODO push value back onto stack for another op etc 
3ba5			 
3ba5			;		pop hl 
3ba5			 
3ba5 cd 5c 20				call forth_push_numhl 
3ba8			.neg_done: 
3ba8			 
3ba8					NEXTW 
3ba8 c3 09 24			jp macro_next 
3bab				endm 
# End of macro NEXTW
3bab			.DIV: 
3bab				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3bab 18				db WORD_SYS_CORE+4             
3bac f8 3b			dw .MUL            
3bae 02				db 1 + 1 
3baf .. 00			db "/",0              
3bb1				endm 
# End of macro CWHEAD
3bb1			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3bb1					if DEBUG_FORTH_WORDS_KEY 
3bb1						DMARK "DIV" 
3bb1 f5				push af  
3bb2 3a c6 3b			ld a, (.dmark)  
3bb5 32 a6 fd			ld (debug_mark),a  
3bb8 3a c7 3b			ld a, (.dmark+1)  
3bbb 32 a7 fd			ld (debug_mark+1),a  
3bbe 3a c8 3b			ld a, (.dmark+2)  
3bc1 32 a8 fd			ld (debug_mark+2),a  
3bc4 18 03			jr .pastdmark  
3bc6 ..			.dmark: db "DIV"  
3bc9 f1			.pastdmark: pop af  
3bca			endm  
# End of macro DMARK
3bca						CALLMONITOR 
3bca cd aa fd			call debug_vector  
3bcd				endm  
# End of macro CALLMONITOR
3bcd					endif 
3bcd				; TODO add floating point number detection 
3bcd					; v5 FORTH_DSP_VALUE 
3bcd					FORTH_DSP 
3bcd cd 19 22			call macro_forth_dsp 
3bd0				endm 
# End of macro FORTH_DSP
3bd0 7e					ld a,(hl)	; get type of value on TOS 
3bd1 fe 02				cp DS_TYPE_INUM  
3bd3 28 03				jr z, .div_inum 
3bd5			 
3bd5				if FORTH_ENABLE_FLOATMATH 
3bd5					jr .div_done 
3bd5			 
3bd5				endif 
3bd5					NEXTW 
3bd5 c3 09 24			jp macro_next 
3bd8				endm 
# End of macro NEXTW
3bd8			.div_inum: 
3bd8			 
3bd8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bd8 cd 53 22			call macro_dsp_valuehl 
3bdb				endm 
# End of macro FORTH_DSP_VALUEHL
3bdb			 
3bdb e5					push hl    ; to go to bc 
3bdc			 
3bdc					; destroy value TOS 
3bdc			 
3bdc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bdc cd 0b 23			call macro_forth_dsp_pop 
3bdf				endm 
# End of macro FORTH_DSP_POP
3bdf			 
3bdf			 
3bdf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bdf cd 53 22			call macro_dsp_valuehl 
3be2				endm 
# End of macro FORTH_DSP_VALUEHL
3be2			 
3be2					; hl to go to de 
3be2			 
3be2 e5					push hl 
3be3			 
3be3 c1					pop bc 
3be4 d1					pop de		 
3be5			 
3be5			 
3be5					if DEBUG_FORTH_MATHS 
3be5						DMARK "DIV" 
3be5				CALLMONITOR 
3be5					endif 
3be5					; one value on hl but move to a get other one back 
3be5			 
3be5			        
3be5 cd 2c 0f			call Div16 
3be8			 
3be8			;	push af	 
3be8 e5				push hl 
3be9 c5				push bc 
3bea			 
3bea					if DEBUG_FORTH_MATHS 
3bea						DMARK "DI1" 
3bea				CALLMONITOR 
3bea					endif 
3bea			 
3bea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bea cd 0b 23			call macro_forth_dsp_pop 
3bed				endm 
# End of macro FORTH_DSP_POP
3bed			 
3bed			 
3bed			 
3bed e1					pop hl    ; result 
3bee			 
3bee cd 5c 20				call forth_push_numhl 
3bf1			 
3bf1 e1					pop hl    ; reminder 
3bf2			;		ld h,0 
3bf2			;		ld l,d 
3bf2			 
3bf2 cd 5c 20				call forth_push_numhl 
3bf5			.div_done: 
3bf5					NEXTW 
3bf5 c3 09 24			jp macro_next 
3bf8				endm 
# End of macro NEXTW
3bf8			.MUL: 
3bf8				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3bf8 19				db WORD_SYS_CORE+5             
3bf9 3d 3c			dw .MIN            
3bfb 02				db 1 + 1 
3bfc .. 00			db "*",0              
3bfe				endm 
# End of macro CWHEAD
3bfe			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3bfe				; TODO add floating point number detection 
3bfe					if DEBUG_FORTH_WORDS_KEY 
3bfe						DMARK "MUL" 
3bfe f5				push af  
3bff 3a 13 3c			ld a, (.dmark)  
3c02 32 a6 fd			ld (debug_mark),a  
3c05 3a 14 3c			ld a, (.dmark+1)  
3c08 32 a7 fd			ld (debug_mark+1),a  
3c0b 3a 15 3c			ld a, (.dmark+2)  
3c0e 32 a8 fd			ld (debug_mark+2),a  
3c11 18 03			jr .pastdmark  
3c13 ..			.dmark: db "MUL"  
3c16 f1			.pastdmark: pop af  
3c17			endm  
# End of macro DMARK
3c17						CALLMONITOR 
3c17 cd aa fd			call debug_vector  
3c1a				endm  
# End of macro CALLMONITOR
3c1a					endif 
3c1a					FORTH_DSP 
3c1a cd 19 22			call macro_forth_dsp 
3c1d				endm 
# End of macro FORTH_DSP
3c1d					; v5 FORTH_DSP_VALUE 
3c1d 7e					ld a,(hl)	; get type of value on TOS 
3c1e fe 02				cp DS_TYPE_INUM  
3c20 28 03				jr z, .mul_inum 
3c22			 
3c22				if FORTH_ENABLE_FLOATMATH 
3c22					jr .mul_done 
3c22			 
3c22				endif 
3c22			 
3c22					NEXTW 
3c22 c3 09 24			jp macro_next 
3c25				endm 
# End of macro NEXTW
3c25			.mul_inum:	 
3c25			 
3c25					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c25 cd 53 22			call macro_dsp_valuehl 
3c28				endm 
# End of macro FORTH_DSP_VALUEHL
3c28			 
3c28 e5					push hl 
3c29			 
3c29					; destroy value TOS 
3c29			 
3c29					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c29 cd 0b 23			call macro_forth_dsp_pop 
3c2c				endm 
# End of macro FORTH_DSP_POP
3c2c			 
3c2c			 
3c2c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c2c cd 53 22			call macro_dsp_valuehl 
3c2f				endm 
# End of macro FORTH_DSP_VALUEHL
3c2f			 
3c2f					; one value on hl but move to a get other one back 
3c2f			 
3c2f 7d					ld a, l 
3c30			 
3c30 d1					pop de 
3c31			 
3c31					; do the mull 
3c31			;		ex de, hl 
3c31			 
3c31 cd 52 0f				call Mult16 
3c34					; save it 
3c34			 
3c34			;		push hl	 
3c34			 
3c34					; 
3c34			 
3c34					; destroy value TOS 
3c34			 
3c34					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c34 cd 0b 23			call macro_forth_dsp_pop 
3c37				endm 
# End of macro FORTH_DSP_POP
3c37			 
3c37					; TODO push value back onto stack for another op etc 
3c37			 
3c37			;		pop hl 
3c37			 
3c37 cd 5c 20				call forth_push_numhl 
3c3a			 
3c3a			.mul_done: 
3c3a					NEXTW 
3c3a c3 09 24			jp macro_next 
3c3d				endm 
# End of macro NEXTW
3c3d			 
3c3d			 
3c3d			 
3c3d			 
3c3d			.MIN: 
3c3d				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3c3d 49				db WORD_SYS_CORE+53             
3c3e be 3c			dw .MAX            
3c40 04				db 3 + 1 
3c41 .. 00			db "MIN",0              
3c45				endm 
# End of macro CWHEAD
3c45			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3c45					if DEBUG_FORTH_WORDS_KEY 
3c45						DMARK "MIN" 
3c45 f5				push af  
3c46 3a 5a 3c			ld a, (.dmark)  
3c49 32 a6 fd			ld (debug_mark),a  
3c4c 3a 5b 3c			ld a, (.dmark+1)  
3c4f 32 a7 fd			ld (debug_mark+1),a  
3c52 3a 5c 3c			ld a, (.dmark+2)  
3c55 32 a8 fd			ld (debug_mark+2),a  
3c58 18 03			jr .pastdmark  
3c5a ..			.dmark: db "MIN"  
3c5d f1			.pastdmark: pop af  
3c5e			endm  
# End of macro DMARK
3c5e						CALLMONITOR 
3c5e cd aa fd			call debug_vector  
3c61				endm  
# End of macro CALLMONITOR
3c61					endif 
3c61					; get u2 
3c61			 
3c61					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c61 cd 53 22			call macro_dsp_valuehl 
3c64				endm 
# End of macro FORTH_DSP_VALUEHL
3c64			 
3c64 e5					push hl   ; u2 
3c65			 
3c65					; destroy value TOS 
3c65			 
3c65					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c65 cd 0b 23			call macro_forth_dsp_pop 
3c68				endm 
# End of macro FORTH_DSP_POP
3c68			 
3c68					; get u1 
3c68			 
3c68					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c68 cd 53 22			call macro_dsp_valuehl 
3c6b				endm 
# End of macro FORTH_DSP_VALUEHL
3c6b			 
3c6b e5					push hl  ; u1 
3c6c			 
3c6c					; destroy value TOS 
3c6c			 
3c6c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c6c cd 0b 23			call macro_forth_dsp_pop 
3c6f				endm 
# End of macro FORTH_DSP_POP
3c6f			 
3c6f b7			 or a      ;clear carry flag 
3c70 e1			  pop hl    ; u1 
3c71 d1			  pop de    ; u2 
3c72 e5				push hl   ; saved in case hl is lowest 
3c73 ed 52		  sbc hl,de 
3c75 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3c77			 
3c77 e1				pop hl 
3c78					if DEBUG_FORTH_WORDS 
3c78						DMARK "MIN" 
3c78 f5				push af  
3c79 3a 8d 3c			ld a, (.dmark)  
3c7c 32 a6 fd			ld (debug_mark),a  
3c7f 3a 8e 3c			ld a, (.dmark+1)  
3c82 32 a7 fd			ld (debug_mark+1),a  
3c85 3a 8f 3c			ld a, (.dmark+2)  
3c88 32 a8 fd			ld (debug_mark+2),a  
3c8b 18 03			jr .pastdmark  
3c8d ..			.dmark: db "MIN"  
3c90 f1			.pastdmark: pop af  
3c91			endm  
# End of macro DMARK
3c91						CALLMONITOR 
3c91 cd aa fd			call debug_vector  
3c94				endm  
# End of macro CALLMONITOR
3c94					endif 
3c94 cd 5c 20				call forth_push_numhl 
3c97			 
3c97				       NEXTW 
3c97 c3 09 24			jp macro_next 
3c9a				endm 
# End of macro NEXTW
3c9a			 
3c9a			.mincont:  
3c9a c1				pop bc   ; tidy up 
3c9b eb				ex de , hl  
3c9c					if DEBUG_FORTH_WORDS 
3c9c						DMARK "MI1" 
3c9c f5				push af  
3c9d 3a b1 3c			ld a, (.dmark)  
3ca0 32 a6 fd			ld (debug_mark),a  
3ca3 3a b2 3c			ld a, (.dmark+1)  
3ca6 32 a7 fd			ld (debug_mark+1),a  
3ca9 3a b3 3c			ld a, (.dmark+2)  
3cac 32 a8 fd			ld (debug_mark+2),a  
3caf 18 03			jr .pastdmark  
3cb1 ..			.dmark: db "MI1"  
3cb4 f1			.pastdmark: pop af  
3cb5			endm  
# End of macro DMARK
3cb5						CALLMONITOR 
3cb5 cd aa fd			call debug_vector  
3cb8				endm  
# End of macro CALLMONITOR
3cb8					endif 
3cb8 cd 5c 20				call forth_push_numhl 
3cbb			 
3cbb				       NEXTW 
3cbb c3 09 24			jp macro_next 
3cbe				endm 
# End of macro NEXTW
3cbe			.MAX: 
3cbe				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3cbe 4a				db WORD_SYS_CORE+54             
3cbf 3f 3d			dw .RND16            
3cc1 04				db 3 + 1 
3cc2 .. 00			db "MAX",0              
3cc6				endm 
# End of macro CWHEAD
3cc6			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3cc6					if DEBUG_FORTH_WORDS_KEY 
3cc6						DMARK "MAX" 
3cc6 f5				push af  
3cc7 3a db 3c			ld a, (.dmark)  
3cca 32 a6 fd			ld (debug_mark),a  
3ccd 3a dc 3c			ld a, (.dmark+1)  
3cd0 32 a7 fd			ld (debug_mark+1),a  
3cd3 3a dd 3c			ld a, (.dmark+2)  
3cd6 32 a8 fd			ld (debug_mark+2),a  
3cd9 18 03			jr .pastdmark  
3cdb ..			.dmark: db "MAX"  
3cde f1			.pastdmark: pop af  
3cdf			endm  
# End of macro DMARK
3cdf						CALLMONITOR 
3cdf cd aa fd			call debug_vector  
3ce2				endm  
# End of macro CALLMONITOR
3ce2					endif 
3ce2					; get u2 
3ce2			 
3ce2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ce2 cd 53 22			call macro_dsp_valuehl 
3ce5				endm 
# End of macro FORTH_DSP_VALUEHL
3ce5			 
3ce5 e5					push hl   ; u2 
3ce6			 
3ce6					; destroy value TOS 
3ce6			 
3ce6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ce6 cd 0b 23			call macro_forth_dsp_pop 
3ce9				endm 
# End of macro FORTH_DSP_POP
3ce9			 
3ce9					; get u1 
3ce9			 
3ce9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ce9 cd 53 22			call macro_dsp_valuehl 
3cec				endm 
# End of macro FORTH_DSP_VALUEHL
3cec			 
3cec e5					push hl  ; u1 
3ced			 
3ced					; destroy value TOS 
3ced			 
3ced					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ced cd 0b 23			call macro_forth_dsp_pop 
3cf0				endm 
# End of macro FORTH_DSP_POP
3cf0			 
3cf0 b7			 or a      ;clear carry flag 
3cf1 e1			  pop hl    ; u1 
3cf2 d1			  pop de    ; u2 
3cf3 e5				push hl   ; saved in case hl is lowest 
3cf4 ed 52		  sbc hl,de 
3cf6 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3cf8			 
3cf8 e1				pop hl 
3cf9					if DEBUG_FORTH_WORDS 
3cf9						DMARK "MAX" 
3cf9 f5				push af  
3cfa 3a 0e 3d			ld a, (.dmark)  
3cfd 32 a6 fd			ld (debug_mark),a  
3d00 3a 0f 3d			ld a, (.dmark+1)  
3d03 32 a7 fd			ld (debug_mark+1),a  
3d06 3a 10 3d			ld a, (.dmark+2)  
3d09 32 a8 fd			ld (debug_mark+2),a  
3d0c 18 03			jr .pastdmark  
3d0e ..			.dmark: db "MAX"  
3d11 f1			.pastdmark: pop af  
3d12			endm  
# End of macro DMARK
3d12						CALLMONITOR 
3d12 cd aa fd			call debug_vector  
3d15				endm  
# End of macro CALLMONITOR
3d15					endif 
3d15 cd 5c 20				call forth_push_numhl 
3d18			 
3d18				       NEXTW 
3d18 c3 09 24			jp macro_next 
3d1b				endm 
# End of macro NEXTW
3d1b			 
3d1b			.maxcont:  
3d1b c1				pop bc   ; tidy up 
3d1c eb				ex de , hl  
3d1d					if DEBUG_FORTH_WORDS 
3d1d						DMARK "MA1" 
3d1d f5				push af  
3d1e 3a 32 3d			ld a, (.dmark)  
3d21 32 a6 fd			ld (debug_mark),a  
3d24 3a 33 3d			ld a, (.dmark+1)  
3d27 32 a7 fd			ld (debug_mark+1),a  
3d2a 3a 34 3d			ld a, (.dmark+2)  
3d2d 32 a8 fd			ld (debug_mark+2),a  
3d30 18 03			jr .pastdmark  
3d32 ..			.dmark: db "MA1"  
3d35 f1			.pastdmark: pop af  
3d36			endm  
# End of macro DMARK
3d36						CALLMONITOR 
3d36 cd aa fd			call debug_vector  
3d39				endm  
# End of macro CALLMONITOR
3d39					endif 
3d39 cd 5c 20				call forth_push_numhl 
3d3c				       NEXTW 
3d3c c3 09 24			jp macro_next 
3d3f				endm 
# End of macro NEXTW
3d3f			 
3d3f			.RND16: 
3d3f				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3d3f 4e				db WORD_SYS_CORE+58             
3d40 6e 3d			dw .RND8            
3d42 06				db 5 + 1 
3d43 .. 00			db "RND16",0              
3d49				endm 
# End of macro CWHEAD
3d49			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3d49					if DEBUG_FORTH_WORDS_KEY 
3d49						DMARK "R16" 
3d49 f5				push af  
3d4a 3a 5e 3d			ld a, (.dmark)  
3d4d 32 a6 fd			ld (debug_mark),a  
3d50 3a 5f 3d			ld a, (.dmark+1)  
3d53 32 a7 fd			ld (debug_mark+1),a  
3d56 3a 60 3d			ld a, (.dmark+2)  
3d59 32 a8 fd			ld (debug_mark+2),a  
3d5c 18 03			jr .pastdmark  
3d5e ..			.dmark: db "R16"  
3d61 f1			.pastdmark: pop af  
3d62			endm  
# End of macro DMARK
3d62						CALLMONITOR 
3d62 cd aa fd			call debug_vector  
3d65				endm  
# End of macro CALLMONITOR
3d65					endif 
3d65 cd f6 0e				call prng16  
3d68 cd 5c 20				call forth_push_numhl 
3d6b				       NEXTW 
3d6b c3 09 24			jp macro_next 
3d6e				endm 
# End of macro NEXTW
3d6e			.RND8: 
3d6e				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3d6e 60				db WORD_SYS_CORE+76             
3d6f a3 3d			dw .RND            
3d71 05				db 4 + 1 
3d72 .. 00			db "RND8",0              
3d77				endm 
# End of macro CWHEAD
3d77			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3d77					if DEBUG_FORTH_WORDS_KEY 
3d77						DMARK "RN8" 
3d77 f5				push af  
3d78 3a 8c 3d			ld a, (.dmark)  
3d7b 32 a6 fd			ld (debug_mark),a  
3d7e 3a 8d 3d			ld a, (.dmark+1)  
3d81 32 a7 fd			ld (debug_mark+1),a  
3d84 3a 8e 3d			ld a, (.dmark+2)  
3d87 32 a8 fd			ld (debug_mark+2),a  
3d8a 18 03			jr .pastdmark  
3d8c ..			.dmark: db "RN8"  
3d8f f1			.pastdmark: pop af  
3d90			endm  
# End of macro DMARK
3d90						CALLMONITOR 
3d90 cd aa fd			call debug_vector  
3d93				endm  
# End of macro CALLMONITOR
3d93					endif 
3d93 2a e4 fa				ld hl,(xrandc) 
3d96 23					inc hl 
3d97 cd 10 0f				call xrnd 
3d9a 6f					ld l,a	 
3d9b 26 00				ld h,0 
3d9d cd 5c 20				call forth_push_numhl 
3da0				       NEXTW 
3da0 c3 09 24			jp macro_next 
3da3				endm 
# End of macro NEXTW
3da3			.RND: 
3da3				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3da3 60				db WORD_SYS_CORE+76             
3da4 a9 3e			dw .ENDMATHS            
3da6 04				db 3 + 1 
3da7 .. 00			db "RND",0              
3dab				endm 
# End of macro CWHEAD
3dab			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3dab			 
3dab					if DEBUG_FORTH_WORDS_KEY 
3dab						DMARK "RND" 
3dab f5				push af  
3dac 3a c0 3d			ld a, (.dmark)  
3daf 32 a6 fd			ld (debug_mark),a  
3db2 3a c1 3d			ld a, (.dmark+1)  
3db5 32 a7 fd			ld (debug_mark+1),a  
3db8 3a c2 3d			ld a, (.dmark+2)  
3dbb 32 a8 fd			ld (debug_mark+2),a  
3dbe 18 03			jr .pastdmark  
3dc0 ..			.dmark: db "RND"  
3dc3 f1			.pastdmark: pop af  
3dc4			endm  
# End of macro DMARK
3dc4						CALLMONITOR 
3dc4 cd aa fd			call debug_vector  
3dc7				endm  
# End of macro CALLMONITOR
3dc7					endif 
3dc7					 
3dc7					FORTH_DSP_VALUEHL    ; upper range 
3dc7 cd 53 22			call macro_dsp_valuehl 
3dca				endm 
# End of macro FORTH_DSP_VALUEHL
3dca			 
3dca 22 e8 fa				ld (LFSRSeed), hl	 
3dcd			 
3dcd					if DEBUG_FORTH_WORDS 
3dcd						DMARK "RN1" 
3dcd f5				push af  
3dce 3a e2 3d			ld a, (.dmark)  
3dd1 32 a6 fd			ld (debug_mark),a  
3dd4 3a e3 3d			ld a, (.dmark+1)  
3dd7 32 a7 fd			ld (debug_mark+1),a  
3dda 3a e4 3d			ld a, (.dmark+2)  
3ddd 32 a8 fd			ld (debug_mark+2),a  
3de0 18 03			jr .pastdmark  
3de2 ..			.dmark: db "RN1"  
3de5 f1			.pastdmark: pop af  
3de6			endm  
# End of macro DMARK
3de6						CALLMONITOR 
3de6 cd aa fd			call debug_vector  
3de9				endm  
# End of macro CALLMONITOR
3de9					endif 
3de9					FORTH_DSP_POP 
3de9 cd 0b 23			call macro_forth_dsp_pop 
3dec				endm 
# End of macro FORTH_DSP_POP
3dec			 
3dec					FORTH_DSP_VALUEHL    ; low range 
3dec cd 53 22			call macro_dsp_valuehl 
3def				endm 
# End of macro FORTH_DSP_VALUEHL
3def			 
3def					if DEBUG_FORTH_WORDS 
3def						DMARK "RN2" 
3def f5				push af  
3df0 3a 04 3e			ld a, (.dmark)  
3df3 32 a6 fd			ld (debug_mark),a  
3df6 3a 05 3e			ld a, (.dmark+1)  
3df9 32 a7 fd			ld (debug_mark+1),a  
3dfc 3a 06 3e			ld a, (.dmark+2)  
3dff 32 a8 fd			ld (debug_mark+2),a  
3e02 18 03			jr .pastdmark  
3e04 ..			.dmark: db "RN2"  
3e07 f1			.pastdmark: pop af  
3e08			endm  
# End of macro DMARK
3e08						CALLMONITOR 
3e08 cd aa fd			call debug_vector  
3e0b				endm  
# End of macro CALLMONITOR
3e0b					endif 
3e0b 22 ea fa				ld (LFSRSeed+2), hl 
3e0e			 
3e0e					FORTH_DSP_POP 
3e0e cd 0b 23			call macro_forth_dsp_pop 
3e11				endm 
# End of macro FORTH_DSP_POP
3e11			 
3e11 e5					push hl 
3e12			 
3e12 e1			.inrange:	pop hl 
3e13 cd f6 0e				call prng16  
3e16					if DEBUG_FORTH_WORDS 
3e16						DMARK "RN3" 
3e16 f5				push af  
3e17 3a 2b 3e			ld a, (.dmark)  
3e1a 32 a6 fd			ld (debug_mark),a  
3e1d 3a 2c 3e			ld a, (.dmark+1)  
3e20 32 a7 fd			ld (debug_mark+1),a  
3e23 3a 2d 3e			ld a, (.dmark+2)  
3e26 32 a8 fd			ld (debug_mark+2),a  
3e29 18 03			jr .pastdmark  
3e2b ..			.dmark: db "RN3"  
3e2e f1			.pastdmark: pop af  
3e2f			endm  
# End of macro DMARK
3e2f						CALLMONITOR 
3e2f cd aa fd			call debug_vector  
3e32				endm  
# End of macro CALLMONITOR
3e32					endif 
3e32					 
3e32					; if the range is 8bit knock out the high byte 
3e32			 
3e32 ed 5b e8 fa			ld de, (LFSRSeed)     ; check high level 
3e36			 
3e36 3e 00				ld a, 0 
3e38 ba					cp d  
3e39 20 1e				jr nz, .hirange 
3e3b 26 00				ld h, 0   ; knock it down to 8bit 
3e3d			 
3e3d					if DEBUG_FORTH_WORDS 
3e3d						DMARK "RNk" 
3e3d f5				push af  
3e3e 3a 52 3e			ld a, (.dmark)  
3e41 32 a6 fd			ld (debug_mark),a  
3e44 3a 53 3e			ld a, (.dmark+1)  
3e47 32 a7 fd			ld (debug_mark+1),a  
3e4a 3a 54 3e			ld a, (.dmark+2)  
3e4d 32 a8 fd			ld (debug_mark+2),a  
3e50 18 03			jr .pastdmark  
3e52 ..			.dmark: db "RNk"  
3e55 f1			.pastdmark: pop af  
3e56			endm  
# End of macro DMARK
3e56						CALLMONITOR 
3e56 cd aa fd			call debug_vector  
3e59				endm  
# End of macro CALLMONITOR
3e59					endif 
3e59			.hirange:   
3e59 e5					push hl  
3e5a b7					or a  
3e5b ed 52		                sbc hl, de 
3e5d			 
3e5d					;call cmp16 
3e5d			 
3e5d 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3e5f e1					pop hl 
3e60 e5					push hl 
3e61			 
3e61					if DEBUG_FORTH_WORDS 
3e61						DMARK "RN4" 
3e61 f5				push af  
3e62 3a 76 3e			ld a, (.dmark)  
3e65 32 a6 fd			ld (debug_mark),a  
3e68 3a 77 3e			ld a, (.dmark+1)  
3e6b 32 a7 fd			ld (debug_mark+1),a  
3e6e 3a 78 3e			ld a, (.dmark+2)  
3e71 32 a8 fd			ld (debug_mark+2),a  
3e74 18 03			jr .pastdmark  
3e76 ..			.dmark: db "RN4"  
3e79 f1			.pastdmark: pop af  
3e7a			endm  
# End of macro DMARK
3e7a						CALLMONITOR 
3e7a cd aa fd			call debug_vector  
3e7d				endm  
# End of macro CALLMONITOR
3e7d					endif 
3e7d ed 5b ea fa			ld de, (LFSRSeed+2)   ; check low range 
3e81					;call cmp16 
3e81				 
3e81 b7					or a  
3e82 ed 52		                sbc hl, de 
3e84 38 8c				jr c, .inrange 
3e86			 
3e86 e1					pop hl 
3e87					 
3e87					if DEBUG_FORTH_WORDS 
3e87						DMARK "RNd" 
3e87 f5				push af  
3e88 3a 9c 3e			ld a, (.dmark)  
3e8b 32 a6 fd			ld (debug_mark),a  
3e8e 3a 9d 3e			ld a, (.dmark+1)  
3e91 32 a7 fd			ld (debug_mark+1),a  
3e94 3a 9e 3e			ld a, (.dmark+2)  
3e97 32 a8 fd			ld (debug_mark+2),a  
3e9a 18 03			jr .pastdmark  
3e9c ..			.dmark: db "RNd"  
3e9f f1			.pastdmark: pop af  
3ea0			endm  
# End of macro DMARK
3ea0						CALLMONITOR 
3ea0 cd aa fd			call debug_vector  
3ea3				endm  
# End of macro CALLMONITOR
3ea3					endif 
3ea3			 
3ea3			 
3ea3 cd 5c 20				call forth_push_numhl 
3ea6				       NEXTW 
3ea6 c3 09 24			jp macro_next 
3ea9				endm 
# End of macro NEXTW
3ea9			 
3ea9			.ENDMATHS: 
3ea9			 
3ea9			; eof 
3ea9			 
# End of file forth_words_maths.asm
3ea9			include "forth_words_display.asm" 
3ea9			 
3ea9			; | ## Display Words 
3ea9			 
3ea9			.ACT: 
3ea9			 
3ea9				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3ea9 62				db WORD_SYS_CORE+78             
3eaa f5 3e			dw .INFO            
3eac 07				db 6 + 1 
3ead .. 00			db "ACTIVE",0              
3eb4				endm 
# End of macro CWHEAD
3eb4			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3eb4			;  
3eb4			; | | To display a pulsing activity indicator in a processing loop do this... 
3eb4			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
3eb4			 
3eb4					if DEBUG_FORTH_WORDS_KEY 
3eb4						DMARK "ACT" 
3eb4 f5				push af  
3eb5 3a c9 3e			ld a, (.dmark)  
3eb8 32 a6 fd			ld (debug_mark),a  
3ebb 3a ca 3e			ld a, (.dmark+1)  
3ebe 32 a7 fd			ld (debug_mark+1),a  
3ec1 3a cb 3e			ld a, (.dmark+2)  
3ec4 32 a8 fd			ld (debug_mark+2),a  
3ec7 18 03			jr .pastdmark  
3ec9 ..			.dmark: db "ACT"  
3ecc f1			.pastdmark: pop af  
3ecd			endm  
# End of macro DMARK
3ecd						CALLMONITOR 
3ecd cd aa fd			call debug_vector  
3ed0				endm  
# End of macro CALLMONITOR
3ed0					endif 
3ed0 cd f2 0c				call active 
3ed3					if DEBUG_FORTH_WORDS 
3ed3						DMARK "ACp" 
3ed3 f5				push af  
3ed4 3a e8 3e			ld a, (.dmark)  
3ed7 32 a6 fd			ld (debug_mark),a  
3eda 3a e9 3e			ld a, (.dmark+1)  
3edd 32 a7 fd			ld (debug_mark+1),a  
3ee0 3a ea 3e			ld a, (.dmark+2)  
3ee3 32 a8 fd			ld (debug_mark+2),a  
3ee6 18 03			jr .pastdmark  
3ee8 ..			.dmark: db "ACp"  
3eeb f1			.pastdmark: pop af  
3eec			endm  
# End of macro DMARK
3eec						CALLMONITOR 
3eec cd aa fd			call debug_vector  
3eef				endm  
# End of macro CALLMONITOR
3eef					endif 
3eef cd ca 20				call forth_push_str 
3ef2			 
3ef2					NEXTW 
3ef2 c3 09 24			jp macro_next 
3ef5				endm 
# End of macro NEXTW
3ef5			.INFO: 
3ef5			 
3ef5				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3ef5 62				db WORD_SYS_CORE+78             
3ef6 12 3f			dw .ATP            
3ef8 05				db 4 + 1 
3ef9 .. 00			db "INFO",0              
3efe				endm 
# End of macro CWHEAD
3efe			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3efe					FORTH_DSP_VALUEHL 
3efe cd 53 22			call macro_dsp_valuehl 
3f01				endm 
# End of macro FORTH_DSP_VALUEHL
3f01			 
3f01					FORTH_DSP_POP 
3f01 cd 0b 23			call macro_forth_dsp_pop 
3f04				endm 
# End of macro FORTH_DSP_POP
3f04			 
3f04 e5					push hl 
3f05			 
3f05					FORTH_DSP_VALUEHL 
3f05 cd 53 22			call macro_dsp_valuehl 
3f08				endm 
# End of macro FORTH_DSP_VALUEHL
3f08			 
3f08					FORTH_DSP_POP 
3f08 cd 0b 23			call macro_forth_dsp_pop 
3f0b				endm 
# End of macro FORTH_DSP_POP
3f0b			 
3f0b d1					pop de 
3f0c			 
3f0c cd 2c 0d				call info_panel 
3f0f			 
3f0f			 
3f0f					NEXTW 
3f0f c3 09 24			jp macro_next 
3f12				endm 
# End of macro NEXTW
3f12			.ATP: 
3f12				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3f12 62				db WORD_SYS_CORE+78             
3f13 89 3f			dw .FB            
3f15 04				db 3 + 1 
3f16 .. 00			db "AT?",0              
3f1a				endm 
# End of macro CWHEAD
3f1a			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3f1a					if DEBUG_FORTH_WORDS_KEY 
3f1a						DMARK "AT?" 
3f1a f5				push af  
3f1b 3a 2f 3f			ld a, (.dmark)  
3f1e 32 a6 fd			ld (debug_mark),a  
3f21 3a 30 3f			ld a, (.dmark+1)  
3f24 32 a7 fd			ld (debug_mark+1),a  
3f27 3a 31 3f			ld a, (.dmark+2)  
3f2a 32 a8 fd			ld (debug_mark+2),a  
3f2d 18 03			jr .pastdmark  
3f2f ..			.dmark: db "AT?"  
3f32 f1			.pastdmark: pop af  
3f33			endm  
# End of macro DMARK
3f33						CALLMONITOR 
3f33 cd aa fd			call debug_vector  
3f36				endm  
# End of macro CALLMONITOR
3f36					endif 
3f36 3a 99 f9				ld a, (f_cursor_ptr) 
3f39			 
3f39			if DEBUG_FORTH_WORDS 
3f39				DMARK "AT?" 
3f39 f5				push af  
3f3a 3a 4e 3f			ld a, (.dmark)  
3f3d 32 a6 fd			ld (debug_mark),a  
3f40 3a 4f 3f			ld a, (.dmark+1)  
3f43 32 a7 fd			ld (debug_mark+1),a  
3f46 3a 50 3f			ld a, (.dmark+2)  
3f49 32 a8 fd			ld (debug_mark+2),a  
3f4c 18 03			jr .pastdmark  
3f4e ..			.dmark: db "AT?"  
3f51 f1			.pastdmark: pop af  
3f52			endm  
# End of macro DMARK
3f52				CALLMONITOR 
3f52 cd aa fd			call debug_vector  
3f55				endm  
# End of macro CALLMONITOR
3f55			endif	 
3f55					; count the number of rows 
3f55			 
3f55 06 00				ld b, 0 
3f57 4f			.atpr:		ld c, a    ; save in case we go below zero 
3f58 d6 28				sub display_cols 
3f5a f2 60 3f				jp p, .atprunder 
3f5d 04					inc b 
3f5e 18 f7				jr .atpr 
3f60			.atprunder:	 
3f60			if DEBUG_FORTH_WORDS 
3f60				DMARK "A?2" 
3f60 f5				push af  
3f61 3a 75 3f			ld a, (.dmark)  
3f64 32 a6 fd			ld (debug_mark),a  
3f67 3a 76 3f			ld a, (.dmark+1)  
3f6a 32 a7 fd			ld (debug_mark+1),a  
3f6d 3a 77 3f			ld a, (.dmark+2)  
3f70 32 a8 fd			ld (debug_mark+2),a  
3f73 18 03			jr .pastdmark  
3f75 ..			.dmark: db "A?2"  
3f78 f1			.pastdmark: pop af  
3f79			endm  
# End of macro DMARK
3f79				CALLMONITOR 
3f79 cd aa fd			call debug_vector  
3f7c				endm  
# End of macro CALLMONITOR
3f7c			endif	 
3f7c 26 00				ld h, 0 
3f7e 69					ld l, c 
3f7f cd 5c 20				call forth_push_numhl 
3f82 68					ld l, b  
3f83 cd 5c 20				call forth_push_numhl 
3f86			 
3f86			 
3f86				NEXTW 
3f86 c3 09 24			jp macro_next 
3f89				endm 
# End of macro NEXTW
3f89			 
3f89			.FB: 
3f89				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3f89 1b				db WORD_SYS_CORE+7             
3f8a d7 3f			dw .EMIT            
3f8c 03				db 2 + 1 
3f8d .. 00			db "FB",0              
3f90				endm 
# End of macro CWHEAD
3f90			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3f90			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3f90			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3f90			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3f90					if DEBUG_FORTH_WORDS_KEY 
3f90						DMARK "FB." 
3f90 f5				push af  
3f91 3a a5 3f			ld a, (.dmark)  
3f94 32 a6 fd			ld (debug_mark),a  
3f97 3a a6 3f			ld a, (.dmark+1)  
3f9a 32 a7 fd			ld (debug_mark+1),a  
3f9d 3a a7 3f			ld a, (.dmark+2)  
3fa0 32 a8 fd			ld (debug_mark+2),a  
3fa3 18 03			jr .pastdmark  
3fa5 ..			.dmark: db "FB."  
3fa8 f1			.pastdmark: pop af  
3fa9			endm  
# End of macro DMARK
3fa9						CALLMONITOR 
3fa9 cd aa fd			call debug_vector  
3fac				endm  
# End of macro CALLMONITOR
3fac					endif 
3fac			 
3fac					FORTH_DSP_VALUEHL 
3fac cd 53 22			call macro_dsp_valuehl 
3faf				endm 
# End of macro FORTH_DSP_VALUEHL
3faf			 
3faf 7d					ld a, l 
3fb0 fe 01				cp 1 
3fb2 20 05				jr nz, .fbn1 
3fb4 21 4b fc				ld hl, display_fb1 
3fb7 18 15				jr .fbset 
3fb9 fe 02		.fbn1:		cp 2 
3fbb 20 05				jr nz, .fbn2 
3fbd 21 09 fb				ld hl, display_fb2 
3fc0 18 0c				jr .fbset 
3fc2 fe 03		.fbn2:		cp 3 
3fc4 20 05				jr nz, .fbn3 
3fc6 21 aa fb				ld hl, display_fb3 
3fc9 18 03				jr .fbset 
3fcb			.fbn3:		 ; if invalid number select first 
3fcb 21 4b fc				ld hl, display_fb1 
3fce 22 07 fb		.fbset:		ld (display_fb_active), hl 
3fd1			 
3fd1					FORTH_DSP_POP 
3fd1 cd 0b 23			call macro_forth_dsp_pop 
3fd4				endm 
# End of macro FORTH_DSP_POP
3fd4			 
3fd4					NEXTW 
3fd4 c3 09 24			jp macro_next 
3fd7				endm 
# End of macro NEXTW
3fd7			 
3fd7			 
3fd7			.EMIT: 
3fd7				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3fd7 1b				db WORD_SYS_CORE+7             
3fd8 28 40			dw .DOTH            
3fda 05				db 4 + 1 
3fdb .. 00			db "EMIT",0              
3fe0				endm 
# End of macro CWHEAD
3fe0			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3fe0					; get value off TOS and display it 
3fe0			 
3fe0					if DEBUG_FORTH_WORDS_KEY 
3fe0						DMARK "EMT" 
3fe0 f5				push af  
3fe1 3a f5 3f			ld a, (.dmark)  
3fe4 32 a6 fd			ld (debug_mark),a  
3fe7 3a f6 3f			ld a, (.dmark+1)  
3fea 32 a7 fd			ld (debug_mark+1),a  
3fed 3a f7 3f			ld a, (.dmark+2)  
3ff0 32 a8 fd			ld (debug_mark+2),a  
3ff3 18 03			jr .pastdmark  
3ff5 ..			.dmark: db "EMT"  
3ff8 f1			.pastdmark: pop af  
3ff9			endm  
# End of macro DMARK
3ff9						CALLMONITOR 
3ff9 cd aa fd			call debug_vector  
3ffc				endm  
# End of macro CALLMONITOR
3ffc					endif 
3ffc			 
3ffc					FORTH_DSP_VALUEHL 
3ffc cd 53 22			call macro_dsp_valuehl 
3fff				endm 
# End of macro FORTH_DSP_VALUEHL
3fff			 
3fff 7d					ld a,l 
4000			 
4000					; TODO write to display 
4000			 
4000 32 fa f2				ld (os_input), a 
4003 3e 00				ld a, 0 
4005 32 fb f2				ld (os_input+1), a 
4008					 
4008 3a 99 f9				ld a, (f_cursor_ptr) 
400b 11 fa f2				ld de, os_input 
400e cd ae 0d				call str_at_display 
4011			 
4011			 
4011 3a 77 f9				ld a,(cli_autodisplay) 
4014 fe 00				cp 0 
4016 28 03				jr z, .enoupdate 
4018 cd be 0d						call update_display 
401b					.enoupdate: 
401b			 
401b 3a 99 f9				ld a, (f_cursor_ptr) 
401e 3c					inc a 
401f 32 99 f9				ld (f_cursor_ptr), a   ; save new pos 
4022			 
4022			 
4022					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4022 cd 0b 23			call macro_forth_dsp_pop 
4025				endm 
# End of macro FORTH_DSP_POP
4025			  
4025			 
4025					NEXTW 
4025 c3 09 24			jp macro_next 
4028				endm 
# End of macro NEXTW
4028			.DOTH: 
4028				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
4028 1c				db WORD_SYS_CORE+8             
4029 58 40			dw .DOTF            
402b 03				db 2 + 1 
402c .. 00			db ".-",0              
402f				endm 
# End of macro CWHEAD
402f			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
402f					; get value off TOS and display it 
402f					if DEBUG_FORTH_WORDS_KEY 
402f						DMARK "DTD" 
402f f5				push af  
4030 3a 44 40			ld a, (.dmark)  
4033 32 a6 fd			ld (debug_mark),a  
4036 3a 45 40			ld a, (.dmark+1)  
4039 32 a7 fd			ld (debug_mark+1),a  
403c 3a 46 40			ld a, (.dmark+2)  
403f 32 a8 fd			ld (debug_mark+2),a  
4042 18 03			jr .pastdmark  
4044 ..			.dmark: db "DTD"  
4047 f1			.pastdmark: pop af  
4048			endm  
# End of macro DMARK
4048						CALLMONITOR 
4048 cd aa fd			call debug_vector  
404b				endm  
# End of macro CALLMONITOR
404b					endif 
404b 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
404d 3e 00			ld a, 0 
404f 32 78 f9			ld (cli_mvdot), a 
4052 c3 af 40			jp .dotgo 
4055				NEXTW 
4055 c3 09 24			jp macro_next 
4058				endm 
# End of macro NEXTW
4058			.DOTF: 
4058				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
4058 1c				db WORD_SYS_CORE+8             
4059 86 40			dw .DOT            
405b 03				db 2 + 1 
405c .. 00			db ".>",0              
405f				endm 
# End of macro CWHEAD
405f			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
405f					; get value off TOS and display it 
405f			        ; TODO BUG adds extra spaces 
405f			        ; TODO BUG handle numerics? 
405f					if DEBUG_FORTH_WORDS_KEY 
405f						DMARK "DTC" 
405f f5				push af  
4060 3a 74 40			ld a, (.dmark)  
4063 32 a6 fd			ld (debug_mark),a  
4066 3a 75 40			ld a, (.dmark+1)  
4069 32 a7 fd			ld (debug_mark+1),a  
406c 3a 76 40			ld a, (.dmark+2)  
406f 32 a8 fd			ld (debug_mark+2),a  
4072 18 03			jr .pastdmark  
4074 ..			.dmark: db "DTC"  
4077 f1			.pastdmark: pop af  
4078			endm  
# End of macro DMARK
4078						CALLMONITOR 
4078 cd aa fd			call debug_vector  
407b				endm  
# End of macro CALLMONITOR
407b					endif 
407b 3e 01			ld a, 1 
407d 32 78 f9			ld (cli_mvdot), a 
4080 c3 af 40			jp .dotgo 
4083				NEXTW 
4083 c3 09 24			jp macro_next 
4086				endm 
# End of macro NEXTW
4086			 
4086			.DOT: 
4086				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
4086 1c				db WORD_SYS_CORE+8             
4087 62 42			dw .CLS            
4089 02				db 1 + 1 
408a .. 00			db ".",0              
408c				endm 
# End of macro CWHEAD
408c			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
408c					; get value off TOS and display it 
408c			 
408c					if DEBUG_FORTH_WORDS_KEY 
408c						DMARK "DOT" 
408c f5				push af  
408d 3a a1 40			ld a, (.dmark)  
4090 32 a6 fd			ld (debug_mark),a  
4093 3a a2 40			ld a, (.dmark+1)  
4096 32 a7 fd			ld (debug_mark+1),a  
4099 3a a3 40			ld a, (.dmark+2)  
409c 32 a8 fd			ld (debug_mark+2),a  
409f 18 03			jr .pastdmark  
40a1 ..			.dmark: db "DOT"  
40a4 f1			.pastdmark: pop af  
40a5			endm  
# End of macro DMARK
40a5						CALLMONITOR 
40a5 cd aa fd			call debug_vector  
40a8				endm  
# End of macro CALLMONITOR
40a8					endif 
40a8 3e 00			ld a, 0 
40aa 32 78 f9			ld (cli_mvdot), a 
40ad 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
40af				 
40af			 
40af			.dotgo: 
40af			 
40af			; move up type to on stack for parserv5 
40af					FORTH_DSP 
40af cd 19 22			call macro_forth_dsp 
40b2				endm 
# End of macro FORTH_DSP
40b2				;FORTH_DSP_VALUE  
40b2			 
40b2			if DEBUG_FORTH_DOT 
40b2				DMARK "DOT" 
40b2 f5				push af  
40b3 3a c7 40			ld a, (.dmark)  
40b6 32 a6 fd			ld (debug_mark),a  
40b9 3a c8 40			ld a, (.dmark+1)  
40bc 32 a7 fd			ld (debug_mark+1),a  
40bf 3a c9 40			ld a, (.dmark+2)  
40c2 32 a8 fd			ld (debug_mark+2),a  
40c5 18 03			jr .pastdmark  
40c7 ..			.dmark: db "DOT"  
40ca f1			.pastdmark: pop af  
40cb			endm  
# End of macro DMARK
40cb				CALLMONITOR 
40cb cd aa fd			call debug_vector  
40ce				endm  
# End of macro CALLMONITOR
40ce			endif	 
40ce			;		.print: 
40ce			 
40ce 7e				ld a,(hl)  ; work out what type of value is on the TOS 
40cf 23				inc hl   ; position to the actual value 
40d0 fe 01			cp DS_TYPE_STR 
40d2 20 06			jr nz, .dotnum1  
40d4			 
40d4			; display string 
40d4				FORTH_DSP_VALUE  
40d4 cd 3c 22			call macro_forth_dsp_value 
40d7				endm 
# End of macro FORTH_DSP_VALUE
40d7 eb				ex de,hl 
40d8 18 49			jr .dotwrite 
40da			 
40da			.dotnum1: 
40da fe 02			cp DS_TYPE_INUM 
40dc 20 44			jr nz, .dotflot 
40de			 
40de			 
40de			; display number 
40de			 
40de			;	push hl 
40de			;	call clear_display 
40de			;	pop hl 
40de			 
40de 5e				ld e, (hl) 
40df 23				inc hl 
40e0 56				ld d, (hl) 
40e1 21 fc f0			ld hl, scratch 
40e4			if DEBUG_FORTH_DOT 
40e4				DMARK "DT1" 
40e4 f5				push af  
40e5 3a f9 40			ld a, (.dmark)  
40e8 32 a6 fd			ld (debug_mark),a  
40eb 3a fa 40			ld a, (.dmark+1)  
40ee 32 a7 fd			ld (debug_mark+1),a  
40f1 3a fb 40			ld a, (.dmark+2)  
40f4 32 a8 fd			ld (debug_mark+2),a  
40f7 18 03			jr .pastdmark  
40f9 ..			.dmark: db "DT1"  
40fc f1			.pastdmark: pop af  
40fd			endm  
# End of macro DMARK
40fd				CALLMONITOR 
40fd cd aa fd			call debug_vector  
4100				endm  
# End of macro CALLMONITOR
4100			endif	 
4100			 
4100 cd 35 13			call uitoa_16 
4103 eb				ex de,hl 
4104			 
4104			if DEBUG_FORTH_DOT 
4104				DMARK "DT2" 
4104 f5				push af  
4105 3a 19 41			ld a, (.dmark)  
4108 32 a6 fd			ld (debug_mark),a  
410b 3a 1a 41			ld a, (.dmark+1)  
410e 32 a7 fd			ld (debug_mark+1),a  
4111 3a 1b 41			ld a, (.dmark+2)  
4114 32 a8 fd			ld (debug_mark+2),a  
4117 18 03			jr .pastdmark  
4119 ..			.dmark: db "DT2"  
411c f1			.pastdmark: pop af  
411d			endm  
# End of macro DMARK
411d				CALLMONITOR 
411d cd aa fd			call debug_vector  
4120				endm  
# End of macro CALLMONITOR
4120			endif	 
4120			 
4120			;	ld de, os_word_scratch 
4120 18 01			jr .dotwrite 
4122			 
4122 00			.dotflot:   nop 
4123			; TODO print floating point number 
4123			 
4123			.dotwrite:		 
4123			 
4123					; if c is set then set all '-' to spaces 
4123					; need to also take into account .>  
4123			 
4123 3e 01				ld a, 1 
4125 b9					cp c 
4126 20 67				jr nz, .nodashswap 
4128			 
4128					; DE has the string to write, working with HL 
4128			 
4128 06 ff				ld b, 255 
412a d5					push de 
412b e1					pop hl 
412c			 
412c			if DEBUG_FORTH_DOT 
412c				DMARK "DT-" 
412c f5				push af  
412d 3a 41 41			ld a, (.dmark)  
4130 32 a6 fd			ld (debug_mark),a  
4133 3a 42 41			ld a, (.dmark+1)  
4136 32 a7 fd			ld (debug_mark+1),a  
4139 3a 43 41			ld a, (.dmark+2)  
413c 32 a8 fd			ld (debug_mark+2),a  
413f 18 03			jr .pastdmark  
4141 ..			.dmark: db "DT-"  
4144 f1			.pastdmark: pop af  
4145			endm  
# End of macro DMARK
4145				CALLMONITOR 
4145 cd aa fd			call debug_vector  
4148				endm  
# End of macro CALLMONITOR
4148			endif	 
4148 7e			.dashscan:	ld a, (hl) 
4149 fe 00				cp 0 
414b 28 42				jr z, .nodashswap 
414d fe 2d				cp '-' 
414f 20 03				jr nz, .dashskip 
4151 3e 20				ld a, ' ' 
4153 77					ld (hl), a 
4154 23			.dashskip:	inc hl 
4155			if DEBUG_FORTH_DOT 
4155				DMARK "D-2" 
4155 f5				push af  
4156 3a 6a 41			ld a, (.dmark)  
4159 32 a6 fd			ld (debug_mark),a  
415c 3a 6b 41			ld a, (.dmark+1)  
415f 32 a7 fd			ld (debug_mark+1),a  
4162 3a 6c 41			ld a, (.dmark+2)  
4165 32 a8 fd			ld (debug_mark+2),a  
4168 18 03			jr .pastdmark  
416a ..			.dmark: db "D-2"  
416d f1			.pastdmark: pop af  
416e			endm  
# End of macro DMARK
416e				CALLMONITOR 
416e cd aa fd			call debug_vector  
4171				endm  
# End of macro CALLMONITOR
4171			endif	 
4171 10 d5				djnz .dashscan 
4173			 
4173			if DEBUG_FORTH_DOT 
4173				DMARK "D-1" 
4173 f5				push af  
4174 3a 88 41			ld a, (.dmark)  
4177 32 a6 fd			ld (debug_mark),a  
417a 3a 89 41			ld a, (.dmark+1)  
417d 32 a7 fd			ld (debug_mark+1),a  
4180 3a 8a 41			ld a, (.dmark+2)  
4183 32 a8 fd			ld (debug_mark+2),a  
4186 18 03			jr .pastdmark  
4188 ..			.dmark: db "D-1"  
418b f1			.pastdmark: pop af  
418c			endm  
# End of macro DMARK
418c				CALLMONITOR 
418c cd aa fd			call debug_vector  
418f				endm  
# End of macro CALLMONITOR
418f			endif	 
418f			 
418f			.nodashswap: 
418f			 
418f			if DEBUG_FORTH_DOT 
418f				DMARK "D-o" 
418f f5				push af  
4190 3a a4 41			ld a, (.dmark)  
4193 32 a6 fd			ld (debug_mark),a  
4196 3a a5 41			ld a, (.dmark+1)  
4199 32 a7 fd			ld (debug_mark+1),a  
419c 3a a6 41			ld a, (.dmark+2)  
419f 32 a8 fd			ld (debug_mark+2),a  
41a2 18 03			jr .pastdmark  
41a4 ..			.dmark: db "D-o"  
41a7 f1			.pastdmark: pop af  
41a8			endm  
# End of macro DMARK
41a8				CALLMONITOR 
41a8 cd aa fd			call debug_vector  
41ab				endm  
# End of macro CALLMONITOR
41ab			endif	 
41ab			 
41ab d5					push de   ; save string start in case we need to advance print 
41ac			 
41ac 3a 99 f9				ld a, (f_cursor_ptr) 
41af cd ae 0d				call str_at_display 
41b2 3a 77 f9				ld a,(cli_autodisplay) 
41b5 fe 00				cp 0 
41b7 28 03				jr z, .noupdate 
41b9 cd be 0d						call update_display 
41bc					.noupdate: 
41bc			 
41bc			 
41bc					; see if we need to advance the print position 
41bc			 
41bc e1					pop hl   ; get back string 
41bd			;		ex de,hl 
41bd			 
41bd 3a 78 f9				ld a, (cli_mvdot) 
41c0			if DEBUG_FORTH_DOT 
41c0			;		ld e,a 
41c0				DMARK "D>1" 
41c0 f5				push af  
41c1 3a d5 41			ld a, (.dmark)  
41c4 32 a6 fd			ld (debug_mark),a  
41c7 3a d6 41			ld a, (.dmark+1)  
41ca 32 a7 fd			ld (debug_mark+1),a  
41cd 3a d7 41			ld a, (.dmark+2)  
41d0 32 a8 fd			ld (debug_mark+2),a  
41d3 18 03			jr .pastdmark  
41d5 ..			.dmark: db "D>1"  
41d8 f1			.pastdmark: pop af  
41d9			endm  
# End of macro DMARK
41d9				CALLMONITOR 
41d9 cd aa fd			call debug_vector  
41dc				endm  
# End of macro CALLMONITOR
41dc			endif	 
41dc fe 00				cp 0 
41de 28 44				jr z, .noadv 
41e0					; yes, lets advance the print position 
41e0 3e 00				ld a, 0 
41e2 cd 91 13				call strlent 
41e5			if DEBUG_FORTH_DOT 
41e5				DMARK "D-?" 
41e5 f5				push af  
41e6 3a fa 41			ld a, (.dmark)  
41e9 32 a6 fd			ld (debug_mark),a  
41ec 3a fb 41			ld a, (.dmark+1)  
41ef 32 a7 fd			ld (debug_mark+1),a  
41f2 3a fc 41			ld a, (.dmark+2)  
41f5 32 a8 fd			ld (debug_mark+2),a  
41f8 18 03			jr .pastdmark  
41fa ..			.dmark: db "D-?"  
41fd f1			.pastdmark: pop af  
41fe			endm  
# End of macro DMARK
41fe				CALLMONITOR 
41fe cd aa fd			call debug_vector  
4201				endm  
# End of macro CALLMONITOR
4201			endif	 
4201 3a 99 f9				ld a, (f_cursor_ptr) 
4204 85					add a,l 
4205					;call addatohl 
4205					;ld a, l 
4205 32 99 f9				ld (f_cursor_ptr), a   ; save new pos 
4208			 
4208			if DEBUG_FORTH_DOT 
4208				DMARK "D->" 
4208 f5				push af  
4209 3a 1d 42			ld a, (.dmark)  
420c 32 a6 fd			ld (debug_mark),a  
420f 3a 1e 42			ld a, (.dmark+1)  
4212 32 a7 fd			ld (debug_mark+1),a  
4215 3a 1f 42			ld a, (.dmark+2)  
4218 32 a8 fd			ld (debug_mark+2),a  
421b 18 03			jr .pastdmark  
421d ..			.dmark: db "D->"  
4220 f1			.pastdmark: pop af  
4221			endm  
# End of macro DMARK
4221				CALLMONITOR 
4221 cd aa fd			call debug_vector  
4224				endm  
# End of macro CALLMONITOR
4224			endif	 
4224			 
4224			.noadv:	 
4224			 
4224					if DEBUG_FORTH_DOT_WAIT 
4224							call next_page_prompt 
4224					endif	 
4224			; TODO this pop off the stack causes a crash. i dont know why 
4224			 
4224			 
4224			if DEBUG_FORTH_DOT 
4224				DMARK "DTh" 
4224 f5				push af  
4225 3a 39 42			ld a, (.dmark)  
4228 32 a6 fd			ld (debug_mark),a  
422b 3a 3a 42			ld a, (.dmark+1)  
422e 32 a7 fd			ld (debug_mark+1),a  
4231 3a 3b 42			ld a, (.dmark+2)  
4234 32 a8 fd			ld (debug_mark+2),a  
4237 18 03			jr .pastdmark  
4239 ..			.dmark: db "DTh"  
423c f1			.pastdmark: pop af  
423d			endm  
# End of macro DMARK
423d				CALLMONITOR 
423d cd aa fd			call debug_vector  
4240				endm  
# End of macro CALLMONITOR
4240			endif	 
4240			 
4240					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4240 cd 0b 23			call macro_forth_dsp_pop 
4243				endm 
# End of macro FORTH_DSP_POP
4243			 
4243			if DEBUG_FORTH_DOT 
4243				DMARK "DTi" 
4243 f5				push af  
4244 3a 58 42			ld a, (.dmark)  
4247 32 a6 fd			ld (debug_mark),a  
424a 3a 59 42			ld a, (.dmark+1)  
424d 32 a7 fd			ld (debug_mark+1),a  
4250 3a 5a 42			ld a, (.dmark+2)  
4253 32 a8 fd			ld (debug_mark+2),a  
4256 18 03			jr .pastdmark  
4258 ..			.dmark: db "DTi"  
425b f1			.pastdmark: pop af  
425c			endm  
# End of macro DMARK
425c				CALLMONITOR 
425c cd aa fd			call debug_vector  
425f				endm  
# End of macro CALLMONITOR
425f			endif	 
425f			 
425f			 
425f					NEXTW 
425f c3 09 24			jp macro_next 
4262				endm 
# End of macro NEXTW
4262			 
4262			.CLS: 
4262				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
4262 35				db WORD_SYS_CORE+33             
4263 8f 42			dw .DRAW            
4265 04				db 3 + 1 
4266 .. 00			db "CLS",0              
426a				endm 
# End of macro CWHEAD
426a			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
426a					if DEBUG_FORTH_WORDS_KEY 
426a						DMARK "CLS" 
426a f5				push af  
426b 3a 7f 42			ld a, (.dmark)  
426e 32 a6 fd			ld (debug_mark),a  
4271 3a 80 42			ld a, (.dmark+1)  
4274 32 a7 fd			ld (debug_mark+1),a  
4277 3a 81 42			ld a, (.dmark+2)  
427a 32 a8 fd			ld (debug_mark+2),a  
427d 18 03			jr .pastdmark  
427f ..			.dmark: db "CLS"  
4282 f1			.pastdmark: pop af  
4283			endm  
# End of macro DMARK
4283						CALLMONITOR 
4283 cd aa fd			call debug_vector  
4286				endm  
# End of macro CALLMONITOR
4286					endif 
4286 cd 9b 0d				call clear_display 
4289 c3 9d 43				jp .home		; and home cursor 
428c					NEXTW 
428c c3 09 24			jp macro_next 
428f				endm 
# End of macro NEXTW
428f			 
428f			.DRAW: 
428f				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
428f 36				db WORD_SYS_CORE+34             
4290 ba 42			dw .DUMP            
4292 05				db 4 + 1 
4293 .. 00			db "DRAW",0              
4298				endm 
# End of macro CWHEAD
4298			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
4298					if DEBUG_FORTH_WORDS_KEY 
4298						DMARK "DRW" 
4298 f5				push af  
4299 3a ad 42			ld a, (.dmark)  
429c 32 a6 fd			ld (debug_mark),a  
429f 3a ae 42			ld a, (.dmark+1)  
42a2 32 a7 fd			ld (debug_mark+1),a  
42a5 3a af 42			ld a, (.dmark+2)  
42a8 32 a8 fd			ld (debug_mark+2),a  
42ab 18 03			jr .pastdmark  
42ad ..			.dmark: db "DRW"  
42b0 f1			.pastdmark: pop af  
42b1			endm  
# End of macro DMARK
42b1						CALLMONITOR 
42b1 cd aa fd			call debug_vector  
42b4				endm  
# End of macro CALLMONITOR
42b4					endif 
42b4 cd be 0d				call update_display 
42b7					NEXTW 
42b7 c3 09 24			jp macro_next 
42ba				endm 
# End of macro NEXTW
42ba			 
42ba			.DUMP: 
42ba				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
42ba 37				db WORD_SYS_CORE+35             
42bb f2 42			dw .CDUMP            
42bd 05				db 4 + 1 
42be .. 00			db "DUMP",0              
42c3				endm 
# End of macro CWHEAD
42c3			; | DUMP ( x -- ) With address x display dump   | DONE 
42c3			; TODO pop address to use off of the stack 
42c3					if DEBUG_FORTH_WORDS_KEY 
42c3						DMARK "DUM" 
42c3 f5				push af  
42c4 3a d8 42			ld a, (.dmark)  
42c7 32 a6 fd			ld (debug_mark),a  
42ca 3a d9 42			ld a, (.dmark+1)  
42cd 32 a7 fd			ld (debug_mark+1),a  
42d0 3a da 42			ld a, (.dmark+2)  
42d3 32 a8 fd			ld (debug_mark+2),a  
42d6 18 03			jr .pastdmark  
42d8 ..			.dmark: db "DUM"  
42db f1			.pastdmark: pop af  
42dc			endm  
# End of macro DMARK
42dc						CALLMONITOR 
42dc cd aa fd			call debug_vector  
42df				endm  
# End of macro CALLMONITOR
42df					endif 
42df cd 9b 0d				call clear_display 
42e2			 
42e2					; get address 
42e2			 
42e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
42e2 cd 53 22			call macro_dsp_valuehl 
42e5				endm 
# End of macro FORTH_DSP_VALUEHL
42e5				 
42e5					; save it for cdump 
42e5			 
42e5 22 1f f4				ld (os_cur_ptr),hl 
42e8			 
42e8					; destroy value TOS 
42e8			 
42e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42e8 cd 0b 23			call macro_forth_dsp_pop 
42eb				endm 
# End of macro FORTH_DSP_POP
42eb			 
42eb cd dc 1e				call dumpcont	; skip old style of param parsing	 
42ee c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
42ef					NEXTW 
42ef c3 09 24			jp macro_next 
42f2				endm 
# End of macro NEXTW
42f2			.CDUMP: 
42f2				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
42f2 38				db WORD_SYS_CORE+36             
42f3 22 43			dw .DAT            
42f5 06				db 5 + 1 
42f6 .. 00			db "CDUMP",0              
42fc				endm 
# End of macro CWHEAD
42fc			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
42fc					if DEBUG_FORTH_WORDS_KEY 
42fc						DMARK "CDP" 
42fc f5				push af  
42fd 3a 11 43			ld a, (.dmark)  
4300 32 a6 fd			ld (debug_mark),a  
4303 3a 12 43			ld a, (.dmark+1)  
4306 32 a7 fd			ld (debug_mark+1),a  
4309 3a 13 43			ld a, (.dmark+2)  
430c 32 a8 fd			ld (debug_mark+2),a  
430f 18 03			jr .pastdmark  
4311 ..			.dmark: db "CDP"  
4314 f1			.pastdmark: pop af  
4315			endm  
# End of macro DMARK
4315						CALLMONITOR 
4315 cd aa fd			call debug_vector  
4318				endm  
# End of macro CALLMONITOR
4318					endif 
4318 cd 9b 0d				call clear_display 
431b cd dc 1e				call dumpcont	 
431e c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
431f					NEXTW 
431f c3 09 24			jp macro_next 
4322				endm 
# End of macro NEXTW
4322			 
4322			 
4322			 
4322			 
4322			.DAT: 
4322				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
4322 3d				db WORD_SYS_CORE+41             
4323 78 43			dw .HOME            
4325 03				db 2 + 1 
4326 .. 00			db "AT",0              
4329				endm 
# End of macro CWHEAD
4329			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
4329					if DEBUG_FORTH_WORDS_KEY 
4329						DMARK "AT." 
4329 f5				push af  
432a 3a 3e 43			ld a, (.dmark)  
432d 32 a6 fd			ld (debug_mark),a  
4330 3a 3f 43			ld a, (.dmark+1)  
4333 32 a7 fd			ld (debug_mark+1),a  
4336 3a 40 43			ld a, (.dmark+2)  
4339 32 a8 fd			ld (debug_mark+2),a  
433c 18 03			jr .pastdmark  
433e ..			.dmark: db "AT."  
4341 f1			.pastdmark: pop af  
4342			endm  
# End of macro DMARK
4342						CALLMONITOR 
4342 cd aa fd			call debug_vector  
4345				endm  
# End of macro CALLMONITOR
4345					endif 
4345					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4345 cd 53 22			call macro_dsp_valuehl 
4348				endm 
# End of macro FORTH_DSP_VALUEHL
4348			 
4348			 
4348					; TODO save cursor row 
4348 7d					ld a,l 
4349 fe 02				cp 2 
434b 20 04				jr nz, .crow3 
434d 3e 28				ld a, display_row_2 
434f 18 12				jr .ccol1 
4351 fe 03		.crow3:		cp 3 
4353 20 04				jr nz, .crow4 
4355 3e 50				ld a, display_row_3 
4357 18 0a				jr .ccol1 
4359 fe 04		.crow4:		cp 4 
435b 20 04				jr nz, .crow1 
435d 3e 78				ld a, display_row_4 
435f 18 02				jr .ccol1 
4361 3e 00		.crow1:		ld a,display_row_1 
4363 f5			.ccol1:		push af			; got row offset 
4364 6f					ld l,a 
4365 26 00				ld h,0 
4367					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4367 cd 0b 23			call macro_forth_dsp_pop 
436a				endm 
# End of macro FORTH_DSP_POP
436a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
436a cd 53 22			call macro_dsp_valuehl 
436d				endm 
# End of macro FORTH_DSP_VALUEHL
436d					; TODO save cursor col 
436d f1					pop af 
436e 85					add l		; add col offset 
436f 32 99 f9				ld (f_cursor_ptr), a 
4372					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4372 cd 0b 23			call macro_forth_dsp_pop 
4375				endm 
# End of macro FORTH_DSP_POP
4375			 
4375					; calculate  
4375			 
4375					NEXTW 
4375 c3 09 24			jp macro_next 
4378				endm 
# End of macro NEXTW
4378			 
4378			 
4378			.HOME: 
4378				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
4378 41				db WORD_SYS_CORE+45             
4379 a5 43			dw .CR            
437b 05				db 4 + 1 
437c .. 00			db "HOME",0              
4381				endm 
# End of macro CWHEAD
4381			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4381					if DEBUG_FORTH_WORDS_KEY 
4381						DMARK "HOM" 
4381 f5				push af  
4382 3a 96 43			ld a, (.dmark)  
4385 32 a6 fd			ld (debug_mark),a  
4388 3a 97 43			ld a, (.dmark+1)  
438b 32 a7 fd			ld (debug_mark+1),a  
438e 3a 98 43			ld a, (.dmark+2)  
4391 32 a8 fd			ld (debug_mark+2),a  
4394 18 03			jr .pastdmark  
4396 ..			.dmark: db "HOM"  
4399 f1			.pastdmark: pop af  
439a			endm  
# End of macro DMARK
439a						CALLMONITOR 
439a cd aa fd			call debug_vector  
439d				endm  
# End of macro CALLMONITOR
439d					endif 
439d 3e 00		.home:		ld a, 0		; and home cursor 
439f 32 99 f9				ld (f_cursor_ptr), a 
43a2					NEXTW 
43a2 c3 09 24			jp macro_next 
43a5				endm 
# End of macro NEXTW
43a5			 
43a5			 
43a5			.CR: 
43a5				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
43a5 46				db WORD_SYS_CORE+50             
43a6 e0 43			dw .SPACE            
43a8 03				db 2 + 1 
43a9 .. 00			db "CR",0              
43ac				endm 
# End of macro CWHEAD
43ac			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
43ac					if DEBUG_FORTH_WORDS_KEY 
43ac						DMARK "CR." 
43ac f5				push af  
43ad 3a c1 43			ld a, (.dmark)  
43b0 32 a6 fd			ld (debug_mark),a  
43b3 3a c2 43			ld a, (.dmark+1)  
43b6 32 a7 fd			ld (debug_mark+1),a  
43b9 3a c3 43			ld a, (.dmark+2)  
43bc 32 a8 fd			ld (debug_mark+2),a  
43bf 18 03			jr .pastdmark  
43c1 ..			.dmark: db "CR."  
43c4 f1			.pastdmark: pop af  
43c5			endm  
# End of macro DMARK
43c5						CALLMONITOR 
43c5 cd aa fd			call debug_vector  
43c8				endm  
# End of macro CALLMONITOR
43c8					endif 
43c8 3e 0d				ld a, 13 
43ca 32 fc f0				ld (scratch),a 
43cd 3e 0a				ld a, 10 
43cf 32 fd f0				ld (scratch+1),a 
43d2 3e 00				ld a, 0 
43d4 32 fe f0				ld (scratch+2),a 
43d7 21 fc f0				ld hl, scratch 
43da cd ca 20				call forth_push_str 
43dd					 
43dd				       NEXTW 
43dd c3 09 24			jp macro_next 
43e0				endm 
# End of macro NEXTW
43e0			.SPACE: 
43e0				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
43e0 46				db WORD_SYS_CORE+50             
43e1 16 44			dw .SPACES            
43e3 03				db 2 + 1 
43e4 .. 00			db "BL",0              
43e7				endm 
# End of macro CWHEAD
43e7			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
43e7					if DEBUG_FORTH_WORDS_KEY 
43e7						DMARK "BL." 
43e7 f5				push af  
43e8 3a fc 43			ld a, (.dmark)  
43eb 32 a6 fd			ld (debug_mark),a  
43ee 3a fd 43			ld a, (.dmark+1)  
43f1 32 a7 fd			ld (debug_mark+1),a  
43f4 3a fe 43			ld a, (.dmark+2)  
43f7 32 a8 fd			ld (debug_mark+2),a  
43fa 18 03			jr .pastdmark  
43fc ..			.dmark: db "BL."  
43ff f1			.pastdmark: pop af  
4400			endm  
# End of macro DMARK
4400						CALLMONITOR 
4400 cd aa fd			call debug_vector  
4403				endm  
# End of macro CALLMONITOR
4403					endif 
4403 3e 20				ld a, " " 
4405 32 fc f0				ld (scratch),a 
4408 3e 00				ld a, 0 
440a 32 fd f0				ld (scratch+1),a 
440d 21 fc f0				ld hl, scratch 
4410 cd ca 20				call forth_push_str 
4413					 
4413				       NEXTW 
4413 c3 09 24			jp macro_next 
4416				endm 
# End of macro NEXTW
4416			 
4416			;.blstr: db " ", 0 
4416			 
4416			.SPACES: 
4416				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
4416 47				db WORD_SYS_CORE+51             
4417 b1 44			dw .SCROLL            
4419 07				db 6 + 1 
441a .. 00			db "SPACES",0              
4421				endm 
# End of macro CWHEAD
4421			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
4421					if DEBUG_FORTH_WORDS_KEY 
4421						DMARK "SPS" 
4421 f5				push af  
4422 3a 36 44			ld a, (.dmark)  
4425 32 a6 fd			ld (debug_mark),a  
4428 3a 37 44			ld a, (.dmark+1)  
442b 32 a7 fd			ld (debug_mark+1),a  
442e 3a 38 44			ld a, (.dmark+2)  
4431 32 a8 fd			ld (debug_mark+2),a  
4434 18 03			jr .pastdmark  
4436 ..			.dmark: db "SPS"  
4439 f1			.pastdmark: pop af  
443a			endm  
# End of macro DMARK
443a						CALLMONITOR 
443a cd aa fd			call debug_vector  
443d				endm  
# End of macro CALLMONITOR
443d					endif 
443d			 
443d			 
443d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
443d cd 53 22			call macro_dsp_valuehl 
4440				endm 
# End of macro FORTH_DSP_VALUEHL
4440			 
4440 e5					push hl    ; u 
4441					if DEBUG_FORTH_WORDS 
4441						DMARK "SPA" 
4441 f5				push af  
4442 3a 56 44			ld a, (.dmark)  
4445 32 a6 fd			ld (debug_mark),a  
4448 3a 57 44			ld a, (.dmark+1)  
444b 32 a7 fd			ld (debug_mark+1),a  
444e 3a 58 44			ld a, (.dmark+2)  
4451 32 a8 fd			ld (debug_mark+2),a  
4454 18 03			jr .pastdmark  
4456 ..			.dmark: db "SPA"  
4459 f1			.pastdmark: pop af  
445a			endm  
# End of macro DMARK
445a						CALLMONITOR 
445a cd aa fd			call debug_vector  
445d				endm  
# End of macro CALLMONITOR
445d					endif 
445d			 
445d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
445d cd 0b 23			call macro_forth_dsp_pop 
4460				endm 
# End of macro FORTH_DSP_POP
4460 e1					pop hl 
4461 0e 00				ld c, 0 
4463 45					ld b, l 
4464 21 fc f0				ld hl, scratch  
4467			 
4467					if DEBUG_FORTH_WORDS 
4467						DMARK "SP2" 
4467 f5				push af  
4468 3a 7c 44			ld a, (.dmark)  
446b 32 a6 fd			ld (debug_mark),a  
446e 3a 7d 44			ld a, (.dmark+1)  
4471 32 a7 fd			ld (debug_mark+1),a  
4474 3a 7e 44			ld a, (.dmark+2)  
4477 32 a8 fd			ld (debug_mark+2),a  
447a 18 03			jr .pastdmark  
447c ..			.dmark: db "SP2"  
447f f1			.pastdmark: pop af  
4480			endm  
# End of macro DMARK
4480						CALLMONITOR 
4480 cd aa fd			call debug_vector  
4483				endm  
# End of macro CALLMONITOR
4483					endif 
4483 3e 20				ld a, ' ' 
4485			.spaces1:	 
4485 77					ld (hl),a 
4486 23					inc hl 
4487					 
4487 10 fc				djnz .spaces1 
4489 3e 00				ld a,0 
448b 77					ld (hl),a 
448c 21 fc f0				ld hl, scratch 
448f					if DEBUG_FORTH_WORDS 
448f						DMARK "SP3" 
448f f5				push af  
4490 3a a4 44			ld a, (.dmark)  
4493 32 a6 fd			ld (debug_mark),a  
4496 3a a5 44			ld a, (.dmark+1)  
4499 32 a7 fd			ld (debug_mark+1),a  
449c 3a a6 44			ld a, (.dmark+2)  
449f 32 a8 fd			ld (debug_mark+2),a  
44a2 18 03			jr .pastdmark  
44a4 ..			.dmark: db "SP3"  
44a7 f1			.pastdmark: pop af  
44a8			endm  
# End of macro DMARK
44a8						CALLMONITOR 
44a8 cd aa fd			call debug_vector  
44ab				endm  
# End of macro CALLMONITOR
44ab					endif 
44ab cd ca 20				call forth_push_str 
44ae			 
44ae				       NEXTW 
44ae c3 09 24			jp macro_next 
44b1				endm 
# End of macro NEXTW
44b1			 
44b1			 
44b1			 
44b1			.SCROLL: 
44b1				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
44b1 53				db WORD_SYS_CORE+63             
44b2 de 44			dw .SCROLLD            
44b4 07				db 6 + 1 
44b5 .. 00			db "SCROLL",0              
44bc				endm 
# End of macro CWHEAD
44bc			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
44bc					if DEBUG_FORTH_WORDS_KEY 
44bc						DMARK "SCR" 
44bc f5				push af  
44bd 3a d1 44			ld a, (.dmark)  
44c0 32 a6 fd			ld (debug_mark),a  
44c3 3a d2 44			ld a, (.dmark+1)  
44c6 32 a7 fd			ld (debug_mark+1),a  
44c9 3a d3 44			ld a, (.dmark+2)  
44cc 32 a8 fd			ld (debug_mark+2),a  
44cf 18 03			jr .pastdmark  
44d1 ..			.dmark: db "SCR"  
44d4 f1			.pastdmark: pop af  
44d5			endm  
# End of macro DMARK
44d5						CALLMONITOR 
44d5 cd aa fd			call debug_vector  
44d8				endm  
# End of macro CALLMONITOR
44d8					endif 
44d8			 
44d8 cd 5d 0d			call scroll_up 
44db			;	call update_display 
44db			 
44db					NEXTW 
44db c3 09 24			jp macro_next 
44de				endm 
# End of macro NEXTW
44de			 
44de			 
44de			 
44de			;		; get dir 
44de			; 
44de			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44de			; 
44de			;		push hl 
44de			; 
44de			;		; destroy value TOS 
44de			; 
44de			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44de			; 
44de			;		; get count 
44de			; 
44de			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44de			; 
44de			;		push hl 
44de			; 
44de			;		; destroy value TOS 
44de			; 
44de			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44de			; 
44de			;		; one value on hl get other one back 
44de			; 
44de			;		pop bc    ; count 
44de			; 
44de			;		pop de   ; dir 
44de			; 
44de			; 
44de			;		ld b, c 
44de			; 
44de			;.scrolldir:     push bc 
44de			;		push de 
44de			; 
44de			;		ld a, 0 
44de			;		cp e 
44de			;		jr z, .scrollup  
44de			;		call scroll_down 
44de			;		jr .scrollnext 
44de			;.scrollup:	call scroll_up 
44de			; 
44de			;		 
44de			;.scrollnext: 
44de			;		pop de 
44de			;		pop bc 
44de			;		djnz .scrolldir 
44de			; 
44de			; 
44de			; 
44de			; 
44de			; 
44de			;		NEXTW 
44de			 
44de			.SCROLLD: 
44de				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
44de 53				db WORD_SYS_CORE+63             
44df 0c 45			dw .ATQ            
44e1 08				db 7 + 1 
44e2 .. 00			db "SCROLLD",0              
44ea				endm 
# End of macro CWHEAD
44ea			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
44ea					if DEBUG_FORTH_WORDS_KEY 
44ea						DMARK "SCD" 
44ea f5				push af  
44eb 3a ff 44			ld a, (.dmark)  
44ee 32 a6 fd			ld (debug_mark),a  
44f1 3a 00 45			ld a, (.dmark+1)  
44f4 32 a7 fd			ld (debug_mark+1),a  
44f7 3a 01 45			ld a, (.dmark+2)  
44fa 32 a8 fd			ld (debug_mark+2),a  
44fd 18 03			jr .pastdmark  
44ff ..			.dmark: db "SCD"  
4502 f1			.pastdmark: pop af  
4503			endm  
# End of macro DMARK
4503						CALLMONITOR 
4503 cd aa fd			call debug_vector  
4506				endm  
# End of macro CALLMONITOR
4506					endif 
4506			 
4506 cd 81 0d			call scroll_down 
4509			;	call update_display 
4509			 
4509					NEXTW 
4509 c3 09 24			jp macro_next 
450c				endm 
# End of macro NEXTW
450c			 
450c			 
450c			.ATQ: 
450c				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
450c 62				db WORD_SYS_CORE+78             
450d 6a 45			dw .AUTODSP            
450f 04				db 3 + 1 
4510 .. 00			db "AT@",0              
4514				endm 
# End of macro CWHEAD
4514			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
4514					if DEBUG_FORTH_WORDS_KEY 
4514						DMARK "ATA" 
4514 f5				push af  
4515 3a 29 45			ld a, (.dmark)  
4518 32 a6 fd			ld (debug_mark),a  
451b 3a 2a 45			ld a, (.dmark+1)  
451e 32 a7 fd			ld (debug_mark+1),a  
4521 3a 2b 45			ld a, (.dmark+2)  
4524 32 a8 fd			ld (debug_mark+2),a  
4527 18 03			jr .pastdmark  
4529 ..			.dmark: db "ATA"  
452c f1			.pastdmark: pop af  
452d			endm  
# End of macro DMARK
452d						CALLMONITOR 
452d cd aa fd			call debug_vector  
4530				endm  
# End of macro CALLMONITOR
4530					endif 
4530			 
4530			 
4530					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4530 cd 53 22			call macro_dsp_valuehl 
4533				endm 
# End of macro FORTH_DSP_VALUEHL
4533			 
4533					; TODO save cursor row 
4533 7d					ld a,l 
4534 fe 02				cp 2 
4536 20 04				jr nz, .crow3aq 
4538 3e 28				ld a, display_row_2 
453a 18 12				jr .ccol1aq 
453c fe 03		.crow3aq:		cp 3 
453e 20 04				jr nz, .crow4aq 
4540 3e 50				ld a, display_row_3 
4542 18 0a				jr .ccol1aq 
4544 fe 04		.crow4aq:		cp 4 
4546 20 04				jr nz, .crow1aq 
4548 3e 78				ld a, display_row_4 
454a 18 02				jr .ccol1aq 
454c 3e 00		.crow1aq:		ld a,display_row_1 
454e f5			.ccol1aq:		push af			; got row offset 
454f 6f					ld l,a 
4550 26 00				ld h,0 
4552					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4552 cd 0b 23			call macro_forth_dsp_pop 
4555				endm 
# End of macro FORTH_DSP_POP
4555					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4555 cd 53 22			call macro_dsp_valuehl 
4558				endm 
# End of macro FORTH_DSP_VALUEHL
4558					; TODO save cursor col 
4558 f1					pop af 
4559 85					add l		; add col offset 
455a			 
455a					; add current frame buffer address 
455a 2a 07 fb				ld hl, (display_fb_active) 
455d cd cf 0f				call addatohl 
4560			 
4560			 
4560			 
4560			 
4560					; get char frame buffer location offset in hl 
4560			 
4560 7e					ld a,(hl) 
4561 26 00				ld h, 0 
4563 6f					ld l, a 
4564			 
4564 cd 5c 20				call forth_push_numhl 
4567			 
4567			 
4567					NEXTW 
4567 c3 09 24			jp macro_next 
456a				endm 
# End of macro NEXTW
456a			 
456a			.AUTODSP: 
456a				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
456a 63				db WORD_SYS_CORE+79             
456b 80 45			dw .MENU            
456d 05				db 4 + 1 
456e .. 00			db "ADSP",0              
4573				endm 
# End of macro CWHEAD
4573			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4573			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4573			 
4573					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4573 cd 53 22			call macro_dsp_valuehl 
4576				endm 
# End of macro FORTH_DSP_VALUEHL
4576			 
4576			;		push hl 
4576			 
4576					; destroy value TOS 
4576			 
4576					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4576 cd 0b 23			call macro_forth_dsp_pop 
4579				endm 
# End of macro FORTH_DSP_POP
4579			 
4579			;		pop hl 
4579			 
4579 7d					ld a,l 
457a 32 77 f9				ld (cli_autodisplay), a 
457d				       NEXTW 
457d c3 09 24			jp macro_next 
4580				endm 
# End of macro NEXTW
4580			 
4580			.MENU: 
4580				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4580 70				db WORD_SYS_CORE+92             
4581 29 46			dw .ENDDISPLAY            
4583 05				db 4 + 1 
4584 .. 00			db "MENU",0              
4589				endm 
# End of macro CWHEAD
4589			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
4589			 
4589			;		; get number of items on the stack 
4589			; 
4589				 
4589					FORTH_DSP_VALUEHL 
4589 cd 53 22			call macro_dsp_valuehl 
458c				endm 
# End of macro FORTH_DSP_VALUEHL
458c				 
458c					if DEBUG_FORTH_WORDS_KEY 
458c						DMARK "MNU" 
458c f5				push af  
458d 3a a1 45			ld a, (.dmark)  
4590 32 a6 fd			ld (debug_mark),a  
4593 3a a2 45			ld a, (.dmark+1)  
4596 32 a7 fd			ld (debug_mark+1),a  
4599 3a a3 45			ld a, (.dmark+2)  
459c 32 a8 fd			ld (debug_mark+2),a  
459f 18 03			jr .pastdmark  
45a1 ..			.dmark: db "MNU"  
45a4 f1			.pastdmark: pop af  
45a5			endm  
# End of macro DMARK
45a5						CALLMONITOR 
45a5 cd aa fd			call debug_vector  
45a8				endm  
# End of macro CALLMONITOR
45a8					endif 
45a8			 
45a8 45					ld b, l	 
45a9 05					dec b 
45aa			 
45aa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45aa cd 0b 23			call macro_forth_dsp_pop 
45ad				endm 
# End of macro FORTH_DSP_POP
45ad			 
45ad			 
45ad					; go directly through the stack to pluck out the string pointers and build an array 
45ad			 
45ad			;		FORTH_DSP 
45ad			 
45ad					; hl contains top most stack item 
45ad				 
45ad 11 fc f0				ld de, scratch 
45b0			 
45b0			.mbuild: 
45b0			 
45b0					FORTH_DSP_VALUEHL 
45b0 cd 53 22			call macro_dsp_valuehl 
45b3				endm 
# End of macro FORTH_DSP_VALUEHL
45b3			 
45b3					if DEBUG_FORTH_WORDS 
45b3						DMARK "MN3" 
45b3 f5				push af  
45b4 3a c8 45			ld a, (.dmark)  
45b7 32 a6 fd			ld (debug_mark),a  
45ba 3a c9 45			ld a, (.dmark+1)  
45bd 32 a7 fd			ld (debug_mark+1),a  
45c0 3a ca 45			ld a, (.dmark+2)  
45c3 32 a8 fd			ld (debug_mark+2),a  
45c6 18 03			jr .pastdmark  
45c8 ..			.dmark: db "MN3"  
45cb f1			.pastdmark: pop af  
45cc			endm  
# End of macro DMARK
45cc						CALLMONITOR 
45cc cd aa fd			call debug_vector  
45cf				endm  
# End of macro CALLMONITOR
45cf					endif 
45cf eb					ex de, hl 
45d0 73					ld (hl), e 
45d1 23					inc hl 
45d2 72					ld (hl), d 
45d3 23					inc hl 
45d4 eb					ex de, hl 
45d5			 
45d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45d5 cd 0b 23			call macro_forth_dsp_pop 
45d8				endm 
# End of macro FORTH_DSP_POP
45d8			 
45d8 10 d6				djnz .mbuild 
45da			 
45da					; done add term 
45da			 
45da eb					ex de, hl 
45db 36 00				ld (hl), 0 
45dd 23					inc hl 
45de 36 00				ld (hl), 0 
45e0			 
45e0				 
45e0					 
45e0 21 fc f0				ld hl, scratch 
45e3			 
45e3					if DEBUG_FORTH_WORDS 
45e3						DMARK "MNx" 
45e3 f5				push af  
45e4 3a f8 45			ld a, (.dmark)  
45e7 32 a6 fd			ld (debug_mark),a  
45ea 3a f9 45			ld a, (.dmark+1)  
45ed 32 a7 fd			ld (debug_mark+1),a  
45f0 3a fa 45			ld a, (.dmark+2)  
45f3 32 a8 fd			ld (debug_mark+2),a  
45f6 18 03			jr .pastdmark  
45f8 ..			.dmark: db "MNx"  
45fb f1			.pastdmark: pop af  
45fc			endm  
# End of macro DMARK
45fc						CALLMONITOR 
45fc cd aa fd			call debug_vector  
45ff				endm  
# End of macro CALLMONITOR
45ff					endif 
45ff			 
45ff			 
45ff			 
45ff 3e 00				ld a, 0 
4601 cd cc 0d				call menu 
4604			 
4604			 
4604 6f					ld l, a 
4605 26 00				ld h, 0 
4607			 
4607					if DEBUG_FORTH_WORDS 
4607						DMARK "MNr" 
4607 f5				push af  
4608 3a 1c 46			ld a, (.dmark)  
460b 32 a6 fd			ld (debug_mark),a  
460e 3a 1d 46			ld a, (.dmark+1)  
4611 32 a7 fd			ld (debug_mark+1),a  
4614 3a 1e 46			ld a, (.dmark+2)  
4617 32 a8 fd			ld (debug_mark+2),a  
461a 18 03			jr .pastdmark  
461c ..			.dmark: db "MNr"  
461f f1			.pastdmark: pop af  
4620			endm  
# End of macro DMARK
4620						CALLMONITOR 
4620 cd aa fd			call debug_vector  
4623				endm  
# End of macro CALLMONITOR
4623					endif 
4623			 
4623 cd 5c 20				call forth_push_numhl 
4626			 
4626			 
4626			 
4626			 
4626				       NEXTW 
4626 c3 09 24			jp macro_next 
4629				endm 
# End of macro NEXTW
4629			 
4629			 
4629			.ENDDISPLAY: 
4629			 
4629			; eof 
# End of file forth_words_display.asm
4629			include "forth_words_str.asm" 
4629			 
4629			; | ## String Words 
4629			 
4629			.PTR:   
4629			 
4629				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4629 48				db WORD_SYS_CORE+52             
462a 56 46			dw .STYPE            
462c 04				db 3 + 1 
462d .. 00			db "PTR",0              
4631				endm 
# End of macro CWHEAD
4631			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4631			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4631			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4631			 
4631					if DEBUG_FORTH_WORDS_KEY 
4631						DMARK "PTR" 
4631 f5				push af  
4632 3a 46 46			ld a, (.dmark)  
4635 32 a6 fd			ld (debug_mark),a  
4638 3a 47 46			ld a, (.dmark+1)  
463b 32 a7 fd			ld (debug_mark+1),a  
463e 3a 48 46			ld a, (.dmark+2)  
4641 32 a8 fd			ld (debug_mark+2),a  
4644 18 03			jr .pastdmark  
4646 ..			.dmark: db "PTR"  
4649 f1			.pastdmark: pop af  
464a			endm  
# End of macro DMARK
464a						CALLMONITOR 
464a cd aa fd			call debug_vector  
464d				endm  
# End of macro CALLMONITOR
464d					endif 
464d					FORTH_DSP_VALUEHL 
464d cd 53 22			call macro_dsp_valuehl 
4650				endm 
# End of macro FORTH_DSP_VALUEHL
4650 cd 5c 20				call forth_push_numhl 
4653			 
4653			 
4653					NEXTW 
4653 c3 09 24			jp macro_next 
4656				endm 
# End of macro NEXTW
4656			.STYPE: 
4656				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4656 48				db WORD_SYS_CORE+52             
4657 a5 46			dw .UPPER            
4659 06				db 5 + 1 
465a .. 00			db "STYPE",0              
4660				endm 
# End of macro CWHEAD
4660			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4660					if DEBUG_FORTH_WORDS_KEY 
4660						DMARK "STY" 
4660 f5				push af  
4661 3a 75 46			ld a, (.dmark)  
4664 32 a6 fd			ld (debug_mark),a  
4667 3a 76 46			ld a, (.dmark+1)  
466a 32 a7 fd			ld (debug_mark+1),a  
466d 3a 77 46			ld a, (.dmark+2)  
4670 32 a8 fd			ld (debug_mark+2),a  
4673 18 03			jr .pastdmark  
4675 ..			.dmark: db "STY"  
4678 f1			.pastdmark: pop af  
4679			endm  
# End of macro DMARK
4679						CALLMONITOR 
4679 cd aa fd			call debug_vector  
467c				endm  
# End of macro CALLMONITOR
467c					endif 
467c					FORTH_DSP 
467c cd 19 22			call macro_forth_dsp 
467f				endm 
# End of macro FORTH_DSP
467f					;v5 FORTH_DSP_VALUE 
467f			 
467f 7e					ld a, (hl) 
4680			 
4680 f5					push af 
4681			 
4681			; Dont destroy TOS		FORTH_DSP_POP 
4681			 
4681 f1					pop af 
4682			 
4682 fe 01				cp DS_TYPE_STR 
4684 28 09				jr z, .typestr 
4686			 
4686 fe 02				cp DS_TYPE_INUM 
4688 28 0a				jr z, .typeinum 
468a			 
468a 21 a3 46				ld hl, .tna 
468d 18 0a				jr .tpush 
468f			 
468f 21 9f 46		.typestr:	ld hl, .tstr 
4692 18 05				jr .tpush 
4694 21 a1 46		.typeinum:	ld hl, .tinum 
4697 18 00				jr .tpush 
4699			 
4699			.tpush: 
4699			 
4699 cd ca 20				call forth_push_str 
469c			 
469c					NEXTW 
469c c3 09 24			jp macro_next 
469f				endm 
# End of macro NEXTW
469f .. 00		.tstr:	db "s",0 
46a1 .. 00		.tinum:  db "i",0 
46a3 .. 00		.tna:   db "?", 0 
46a5			 
46a5			 
46a5			.UPPER: 
46a5				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
46a5 48				db WORD_SYS_CORE+52             
46a6 e0 46			dw .LOWER            
46a8 06				db 5 + 1 
46a9 .. 00			db "UPPER",0              
46af				endm 
# End of macro CWHEAD
46af			; | UPPER ( s -- s ) Upper case string s  | DONE 
46af					if DEBUG_FORTH_WORDS_KEY 
46af						DMARK "UPR" 
46af f5				push af  
46b0 3a c4 46			ld a, (.dmark)  
46b3 32 a6 fd			ld (debug_mark),a  
46b6 3a c5 46			ld a, (.dmark+1)  
46b9 32 a7 fd			ld (debug_mark+1),a  
46bc 3a c6 46			ld a, (.dmark+2)  
46bf 32 a8 fd			ld (debug_mark+2),a  
46c2 18 03			jr .pastdmark  
46c4 ..			.dmark: db "UPR"  
46c7 f1			.pastdmark: pop af  
46c8			endm  
# End of macro DMARK
46c8						CALLMONITOR 
46c8 cd aa fd			call debug_vector  
46cb				endm  
# End of macro CALLMONITOR
46cb					endif 
46cb			 
46cb					FORTH_DSP 
46cb cd 19 22			call macro_forth_dsp 
46ce				endm 
# End of macro FORTH_DSP
46ce					 
46ce			; TODO check is string type 
46ce			 
46ce					FORTH_DSP_VALUEHL 
46ce cd 53 22			call macro_dsp_valuehl 
46d1				endm 
# End of macro FORTH_DSP_VALUEHL
46d1			; get pointer to string in hl 
46d1			 
46d1 7e			.toup:		ld a, (hl) 
46d2 fe 00				cp 0 
46d4 28 07				jr z, .toupdone 
46d6			 
46d6 cd 95 12				call to_upper 
46d9			 
46d9 77					ld (hl), a 
46da 23					inc hl 
46db 18 f4				jr .toup 
46dd			 
46dd					 
46dd			 
46dd			 
46dd			; for each char convert to upper 
46dd					 
46dd			.toupdone: 
46dd			 
46dd			 
46dd					NEXTW 
46dd c3 09 24			jp macro_next 
46e0				endm 
# End of macro NEXTW
46e0			.LOWER: 
46e0				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
46e0 48				db WORD_SYS_CORE+52             
46e1 1b 47			dw .TCASE            
46e3 06				db 5 + 1 
46e4 .. 00			db "LOWER",0              
46ea				endm 
# End of macro CWHEAD
46ea			; | LOWER ( s -- s ) Lower case string s  | DONE 
46ea					if DEBUG_FORTH_WORDS_KEY 
46ea						DMARK "LWR" 
46ea f5				push af  
46eb 3a ff 46			ld a, (.dmark)  
46ee 32 a6 fd			ld (debug_mark),a  
46f1 3a 00 47			ld a, (.dmark+1)  
46f4 32 a7 fd			ld (debug_mark+1),a  
46f7 3a 01 47			ld a, (.dmark+2)  
46fa 32 a8 fd			ld (debug_mark+2),a  
46fd 18 03			jr .pastdmark  
46ff ..			.dmark: db "LWR"  
4702 f1			.pastdmark: pop af  
4703			endm  
# End of macro DMARK
4703						CALLMONITOR 
4703 cd aa fd			call debug_vector  
4706				endm  
# End of macro CALLMONITOR
4706					endif 
4706			 
4706					FORTH_DSP 
4706 cd 19 22			call macro_forth_dsp 
4709				endm 
# End of macro FORTH_DSP
4709					 
4709			; TODO check is string type 
4709			 
4709					FORTH_DSP_VALUEHL 
4709 cd 53 22			call macro_dsp_valuehl 
470c				endm 
# End of macro FORTH_DSP_VALUEHL
470c			; get pointer to string in hl 
470c			 
470c 7e			.tolow:		ld a, (hl) 
470d fe 00				cp 0 
470f 28 07				jr z, .tolowdone 
4711			 
4711 cd 9e 12				call to_lower 
4714			 
4714 77					ld (hl), a 
4715 23					inc hl 
4716 18 f4				jr .tolow 
4718			 
4718					 
4718			 
4718			 
4718			; for each char convert to low 
4718					 
4718			.tolowdone: 
4718					NEXTW 
4718 c3 09 24			jp macro_next 
471b				endm 
# End of macro NEXTW
471b			.TCASE: 
471b				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
471b 48				db WORD_SYS_CORE+52             
471c 51 48			dw .SUBSTR            
471e 06				db 5 + 1 
471f .. 00			db "TCASE",0              
4725				endm 
# End of macro CWHEAD
4725			; | TCASE ( s -- s ) Title case string s  | DONE 
4725					if DEBUG_FORTH_WORDS_KEY 
4725						DMARK "TCS" 
4725 f5				push af  
4726 3a 3a 47			ld a, (.dmark)  
4729 32 a6 fd			ld (debug_mark),a  
472c 3a 3b 47			ld a, (.dmark+1)  
472f 32 a7 fd			ld (debug_mark+1),a  
4732 3a 3c 47			ld a, (.dmark+2)  
4735 32 a8 fd			ld (debug_mark+2),a  
4738 18 03			jr .pastdmark  
473a ..			.dmark: db "TCS"  
473d f1			.pastdmark: pop af  
473e			endm  
# End of macro DMARK
473e						CALLMONITOR 
473e cd aa fd			call debug_vector  
4741				endm  
# End of macro CALLMONITOR
4741					endif 
4741			 
4741					FORTH_DSP 
4741 cd 19 22			call macro_forth_dsp 
4744				endm 
# End of macro FORTH_DSP
4744					 
4744			; TODO check is string type 
4744			 
4744					FORTH_DSP_VALUEHL 
4744 cd 53 22			call macro_dsp_valuehl 
4747				endm 
# End of macro FORTH_DSP_VALUEHL
4747			; get pointer to string in hl 
4747			 
4747					if DEBUG_FORTH_WORDS 
4747						DMARK "TC1" 
4747 f5				push af  
4748 3a 5c 47			ld a, (.dmark)  
474b 32 a6 fd			ld (debug_mark),a  
474e 3a 5d 47			ld a, (.dmark+1)  
4751 32 a7 fd			ld (debug_mark+1),a  
4754 3a 5e 47			ld a, (.dmark+2)  
4757 32 a8 fd			ld (debug_mark+2),a  
475a 18 03			jr .pastdmark  
475c ..			.dmark: db "TC1"  
475f f1			.pastdmark: pop af  
4760			endm  
# End of macro DMARK
4760						CALLMONITOR 
4760 cd aa fd			call debug_vector  
4763				endm  
# End of macro CALLMONITOR
4763					endif 
4763			 
4763					; first time in turn to upper case first char 
4763			 
4763 7e					ld a, (hl) 
4764 c3 ee 47				jp .totsiptou 
4767			 
4767			 
4767 7e			.tot:		ld a, (hl) 
4768 fe 00				cp 0 
476a ca 32 48				jp z, .totdone 
476d			 
476d					if DEBUG_FORTH_WORDS 
476d						DMARK "TC2" 
476d f5				push af  
476e 3a 82 47			ld a, (.dmark)  
4771 32 a6 fd			ld (debug_mark),a  
4774 3a 83 47			ld a, (.dmark+1)  
4777 32 a7 fd			ld (debug_mark+1),a  
477a 3a 84 47			ld a, (.dmark+2)  
477d 32 a8 fd			ld (debug_mark+2),a  
4780 18 03			jr .pastdmark  
4782 ..			.dmark: db "TC2"  
4785 f1			.pastdmark: pop af  
4786			endm  
# End of macro DMARK
4786						CALLMONITOR 
4786 cd aa fd			call debug_vector  
4789				endm  
# End of macro CALLMONITOR
4789					endif 
4789					; check to see if current char is a space 
4789			 
4789 fe 20				cp ' ' 
478b 28 21				jr z, .totsp 
478d cd 9e 12				call to_lower 
4790					if DEBUG_FORTH_WORDS 
4790						DMARK "TC3" 
4790 f5				push af  
4791 3a a5 47			ld a, (.dmark)  
4794 32 a6 fd			ld (debug_mark),a  
4797 3a a6 47			ld a, (.dmark+1)  
479a 32 a7 fd			ld (debug_mark+1),a  
479d 3a a7 47			ld a, (.dmark+2)  
47a0 32 a8 fd			ld (debug_mark+2),a  
47a3 18 03			jr .pastdmark  
47a5 ..			.dmark: db "TC3"  
47a8 f1			.pastdmark: pop af  
47a9			endm  
# End of macro DMARK
47a9						CALLMONITOR 
47a9 cd aa fd			call debug_vector  
47ac				endm  
# End of macro CALLMONITOR
47ac					endif 
47ac 18 63				jr .totnxt 
47ae			 
47ae			.totsp:         ; on a space, find next char which should be upper 
47ae			 
47ae					if DEBUG_FORTH_WORDS 
47ae						DMARK "TC4" 
47ae f5				push af  
47af 3a c3 47			ld a, (.dmark)  
47b2 32 a6 fd			ld (debug_mark),a  
47b5 3a c4 47			ld a, (.dmark+1)  
47b8 32 a7 fd			ld (debug_mark+1),a  
47bb 3a c5 47			ld a, (.dmark+2)  
47be 32 a8 fd			ld (debug_mark+2),a  
47c1 18 03			jr .pastdmark  
47c3 ..			.dmark: db "TC4"  
47c6 f1			.pastdmark: pop af  
47c7			endm  
# End of macro DMARK
47c7						CALLMONITOR 
47c7 cd aa fd			call debug_vector  
47ca				endm  
# End of macro CALLMONITOR
47ca					endif 
47ca					;; 
47ca			 
47ca fe 20				cp ' ' 
47cc 20 20				jr nz, .totsiptou 
47ce 23					inc hl 
47cf 7e					ld a, (hl) 
47d0					if DEBUG_FORTH_WORDS 
47d0						DMARK "TC5" 
47d0 f5				push af  
47d1 3a e5 47			ld a, (.dmark)  
47d4 32 a6 fd			ld (debug_mark),a  
47d7 3a e6 47			ld a, (.dmark+1)  
47da 32 a7 fd			ld (debug_mark+1),a  
47dd 3a e7 47			ld a, (.dmark+2)  
47e0 32 a8 fd			ld (debug_mark+2),a  
47e3 18 03			jr .pastdmark  
47e5 ..			.dmark: db "TC5"  
47e8 f1			.pastdmark: pop af  
47e9			endm  
# End of macro DMARK
47e9						CALLMONITOR 
47e9 cd aa fd			call debug_vector  
47ec				endm  
# End of macro CALLMONITOR
47ec					endif 
47ec 18 c0				jr .totsp 
47ee fe 00		.totsiptou:    cp 0 
47f0 28 40				jr z, .totdone 
47f2					; not space and not zero term so upper case it 
47f2 cd 95 12				call to_upper 
47f5			 
47f5					if DEBUG_FORTH_WORDS 
47f5						DMARK "TC6" 
47f5 f5				push af  
47f6 3a 0a 48			ld a, (.dmark)  
47f9 32 a6 fd			ld (debug_mark),a  
47fc 3a 0b 48			ld a, (.dmark+1)  
47ff 32 a7 fd			ld (debug_mark+1),a  
4802 3a 0c 48			ld a, (.dmark+2)  
4805 32 a8 fd			ld (debug_mark+2),a  
4808 18 03			jr .pastdmark  
480a ..			.dmark: db "TC6"  
480d f1			.pastdmark: pop af  
480e			endm  
# End of macro DMARK
480e						CALLMONITOR 
480e cd aa fd			call debug_vector  
4811				endm  
# End of macro CALLMONITOR
4811					endif 
4811			 
4811			 
4811			.totnxt: 
4811			 
4811 77					ld (hl), a 
4812 23					inc hl 
4813					if DEBUG_FORTH_WORDS 
4813						DMARK "TC7" 
4813 f5				push af  
4814 3a 28 48			ld a, (.dmark)  
4817 32 a6 fd			ld (debug_mark),a  
481a 3a 29 48			ld a, (.dmark+1)  
481d 32 a7 fd			ld (debug_mark+1),a  
4820 3a 2a 48			ld a, (.dmark+2)  
4823 32 a8 fd			ld (debug_mark+2),a  
4826 18 03			jr .pastdmark  
4828 ..			.dmark: db "TC7"  
482b f1			.pastdmark: pop af  
482c			endm  
# End of macro DMARK
482c						CALLMONITOR 
482c cd aa fd			call debug_vector  
482f				endm  
# End of macro CALLMONITOR
482f					endif 
482f c3 67 47				jp .tot 
4832			 
4832					 
4832			 
4832			 
4832			; for each char convert to low 
4832					 
4832			.totdone: 
4832					if DEBUG_FORTH_WORDS 
4832						DMARK "TCd" 
4832 f5				push af  
4833 3a 47 48			ld a, (.dmark)  
4836 32 a6 fd			ld (debug_mark),a  
4839 3a 48 48			ld a, (.dmark+1)  
483c 32 a7 fd			ld (debug_mark+1),a  
483f 3a 49 48			ld a, (.dmark+2)  
4842 32 a8 fd			ld (debug_mark+2),a  
4845 18 03			jr .pastdmark  
4847 ..			.dmark: db "TCd"  
484a f1			.pastdmark: pop af  
484b			endm  
# End of macro DMARK
484b						CALLMONITOR 
484b cd aa fd			call debug_vector  
484e				endm  
# End of macro CALLMONITOR
484e					endif 
484e					NEXTW 
484e c3 09 24			jp macro_next 
4851				endm 
# End of macro NEXTW
4851			 
4851			.SUBSTR: 
4851				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4851 48				db WORD_SYS_CORE+52             
4852 af 48			dw .LEFT            
4854 07				db 6 + 1 
4855 .. 00			db "SUBSTR",0              
485c				endm 
# End of macro CWHEAD
485c			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
485c			 
485c					if DEBUG_FORTH_WORDS_KEY 
485c						DMARK "SST" 
485c f5				push af  
485d 3a 71 48			ld a, (.dmark)  
4860 32 a6 fd			ld (debug_mark),a  
4863 3a 72 48			ld a, (.dmark+1)  
4866 32 a7 fd			ld (debug_mark+1),a  
4869 3a 73 48			ld a, (.dmark+2)  
486c 32 a8 fd			ld (debug_mark+2),a  
486f 18 03			jr .pastdmark  
4871 ..			.dmark: db "SST"  
4874 f1			.pastdmark: pop af  
4875			endm  
# End of macro DMARK
4875						CALLMONITOR 
4875 cd aa fd			call debug_vector  
4878				endm  
# End of macro CALLMONITOR
4878					endif 
4878			; TODO check string type 
4878					FORTH_DSP_VALUEHL 
4878 cd 53 22			call macro_dsp_valuehl 
487b				endm 
# End of macro FORTH_DSP_VALUEHL
487b			 
487b e5					push hl      ; string length 
487c			 
487c					FORTH_DSP_POP 
487c cd 0b 23			call macro_forth_dsp_pop 
487f				endm 
# End of macro FORTH_DSP_POP
487f			 
487f					FORTH_DSP_VALUEHL 
487f cd 53 22			call macro_dsp_valuehl 
4882				endm 
# End of macro FORTH_DSP_VALUEHL
4882			 
4882 e5					push hl     ; start char 
4883			 
4883					FORTH_DSP_POP 
4883 cd 0b 23			call macro_forth_dsp_pop 
4886				endm 
# End of macro FORTH_DSP_POP
4886			 
4886			 
4886					FORTH_DSP_VALUE 
4886 cd 3c 22			call macro_forth_dsp_value 
4889				endm 
# End of macro FORTH_DSP_VALUE
4889			 
4889 d1					pop de    ; get start post offset 
488a			 
488a 19					add hl, de    ; starting offset 
488b			 
488b c1					pop bc 
488c c5					push bc      ; grab size of string 
488d			 
488d e5					push hl    ; save string start  
488e			 
488e 26 00				ld h, 0 
4890 69					ld l, c 
4891 23					inc hl 
4892 23					inc hl 
4893			 
4893 cd fb 13				call malloc 
4896				if DEBUG_FORTH_MALLOC_GUARD 
4896 cc dc 5d				call z,malloc_error 
4899				endif 
4899			 
4899 eb					ex de, hl      ; save malloc area for string copy 
489a e1					pop hl    ; get back source 
489b c1					pop bc    ; get length of string back 
489c			 
489c d5					push de    ; save malloc area for after we push 
489d ed b0				ldir     ; copy substr 
489f			 
489f			 
489f eb					ex de, hl 
48a0 3e 00				ld a, 0 
48a2 77					ld (hl), a   ; term substr 
48a3			 
48a3					 
48a3 e1					pop hl    ; get malloc so we can push it 
48a4 e5					push hl   ; save so we can free it afterwards 
48a5			 
48a5 cd ca 20				call forth_push_str 
48a8			 
48a8 e1					pop hl 
48a9 cd c5 14				call free 
48ac			 
48ac					 
48ac					 
48ac			 
48ac			 
48ac					NEXTW 
48ac c3 09 24			jp macro_next 
48af				endm 
# End of macro NEXTW
48af			 
48af			.LEFT: 
48af				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
48af 48				db WORD_SYS_CORE+52             
48b0 d7 48			dw .RIGHT            
48b2 05				db 4 + 1 
48b3 .. 00			db "LEFT",0              
48b8				endm 
# End of macro CWHEAD
48b8			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
48b8					if DEBUG_FORTH_WORDS_KEY 
48b8						DMARK "LEF" 
48b8 f5				push af  
48b9 3a cd 48			ld a, (.dmark)  
48bc 32 a6 fd			ld (debug_mark),a  
48bf 3a ce 48			ld a, (.dmark+1)  
48c2 32 a7 fd			ld (debug_mark+1),a  
48c5 3a cf 48			ld a, (.dmark+2)  
48c8 32 a8 fd			ld (debug_mark+2),a  
48cb 18 03			jr .pastdmark  
48cd ..			.dmark: db "LEF"  
48d0 f1			.pastdmark: pop af  
48d1			endm  
# End of macro DMARK
48d1						CALLMONITOR 
48d1 cd aa fd			call debug_vector  
48d4				endm  
# End of macro CALLMONITOR
48d4					endif 
48d4			 
48d4					NEXTW 
48d4 c3 09 24			jp macro_next 
48d7				endm 
# End of macro NEXTW
48d7			.RIGHT: 
48d7				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
48d7 48				db WORD_SYS_CORE+52             
48d8 00 49			dw .STR2NUM            
48da 06				db 5 + 1 
48db .. 00			db "RIGHT",0              
48e1				endm 
# End of macro CWHEAD
48e1			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
48e1					if DEBUG_FORTH_WORDS_KEY 
48e1						DMARK "RIG" 
48e1 f5				push af  
48e2 3a f6 48			ld a, (.dmark)  
48e5 32 a6 fd			ld (debug_mark),a  
48e8 3a f7 48			ld a, (.dmark+1)  
48eb 32 a7 fd			ld (debug_mark+1),a  
48ee 3a f8 48			ld a, (.dmark+2)  
48f1 32 a8 fd			ld (debug_mark+2),a  
48f4 18 03			jr .pastdmark  
48f6 ..			.dmark: db "RIG"  
48f9 f1			.pastdmark: pop af  
48fa			endm  
# End of macro DMARK
48fa						CALLMONITOR 
48fa cd aa fd			call debug_vector  
48fd				endm  
# End of macro CALLMONITOR
48fd					endif 
48fd			 
48fd					NEXTW 
48fd c3 09 24			jp macro_next 
4900				endm 
# End of macro NEXTW
4900			 
4900			 
4900			.STR2NUM: 
4900				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4900 48				db WORD_SYS_CORE+52             
4901 8c 49			dw .NUM2STR            
4903 08				db 7 + 1 
4904 .. 00			db "STR2NUM",0              
490c				endm 
# End of macro CWHEAD
490c			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
490c			 
490c			 
490c			; TODO STR type check to do 
490c					if DEBUG_FORTH_WORDS_KEY 
490c						DMARK "S2N" 
490c f5				push af  
490d 3a 21 49			ld a, (.dmark)  
4910 32 a6 fd			ld (debug_mark),a  
4913 3a 22 49			ld a, (.dmark+1)  
4916 32 a7 fd			ld (debug_mark+1),a  
4919 3a 23 49			ld a, (.dmark+2)  
491c 32 a8 fd			ld (debug_mark+2),a  
491f 18 03			jr .pastdmark  
4921 ..			.dmark: db "S2N"  
4924 f1			.pastdmark: pop af  
4925			endm  
# End of macro DMARK
4925						CALLMONITOR 
4925 cd aa fd			call debug_vector  
4928				endm  
# End of macro CALLMONITOR
4928					endif 
4928			 
4928					;FORTH_DSP 
4928					FORTH_DSP_VALUE 
4928 cd 3c 22			call macro_forth_dsp_value 
492b				endm 
# End of macro FORTH_DSP_VALUE
492b					;inc hl 
492b			 
492b eb					ex de, hl 
492c					if DEBUG_FORTH_WORDS 
492c						DMARK "S2a" 
492c f5				push af  
492d 3a 41 49			ld a, (.dmark)  
4930 32 a6 fd			ld (debug_mark),a  
4933 3a 42 49			ld a, (.dmark+1)  
4936 32 a7 fd			ld (debug_mark+1),a  
4939 3a 43 49			ld a, (.dmark+2)  
493c 32 a8 fd			ld (debug_mark+2),a  
493f 18 03			jr .pastdmark  
4941 ..			.dmark: db "S2a"  
4944 f1			.pastdmark: pop af  
4945			endm  
# End of macro DMARK
4945						CALLMONITOR 
4945 cd aa fd			call debug_vector  
4948				endm  
# End of macro CALLMONITOR
4948					endif 
4948 cd 1d 13				call string_to_uint16 
494b			 
494b					if DEBUG_FORTH_WORDS 
494b						DMARK "S2b" 
494b f5				push af  
494c 3a 60 49			ld a, (.dmark)  
494f 32 a6 fd			ld (debug_mark),a  
4952 3a 61 49			ld a, (.dmark+1)  
4955 32 a7 fd			ld (debug_mark+1),a  
4958 3a 62 49			ld a, (.dmark+2)  
495b 32 a8 fd			ld (debug_mark+2),a  
495e 18 03			jr .pastdmark  
4960 ..			.dmark: db "S2b"  
4963 f1			.pastdmark: pop af  
4964			endm  
# End of macro DMARK
4964						CALLMONITOR 
4964 cd aa fd			call debug_vector  
4967				endm  
# End of macro CALLMONITOR
4967					endif 
4967			;		push hl 
4967					FORTH_DSP_POP 
4967 cd 0b 23			call macro_forth_dsp_pop 
496a				endm 
# End of macro FORTH_DSP_POP
496a			;		pop hl 
496a					 
496a					if DEBUG_FORTH_WORDS 
496a						DMARK "S2b" 
496a f5				push af  
496b 3a 7f 49			ld a, (.dmark)  
496e 32 a6 fd			ld (debug_mark),a  
4971 3a 80 49			ld a, (.dmark+1)  
4974 32 a7 fd			ld (debug_mark+1),a  
4977 3a 81 49			ld a, (.dmark+2)  
497a 32 a8 fd			ld (debug_mark+2),a  
497d 18 03			jr .pastdmark  
497f ..			.dmark: db "S2b"  
4982 f1			.pastdmark: pop af  
4983			endm  
# End of macro DMARK
4983						CALLMONITOR 
4983 cd aa fd			call debug_vector  
4986				endm  
# End of macro CALLMONITOR
4986					endif 
4986 cd 5c 20				call forth_push_numhl	 
4989			 
4989				 
4989				       NEXTW 
4989 c3 09 24			jp macro_next 
498c				endm 
# End of macro NEXTW
498c			.NUM2STR: 
498c				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
498c 48				db WORD_SYS_CORE+52             
498d 9b 49			dw .CONCAT            
498f 08				db 7 + 1 
4990 .. 00			db "NUM2STR",0              
4998				endm 
# End of macro CWHEAD
4998			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
4998			 
4998			;		; malloc a string to target 
4998			;		ld hl, 10     ; TODO max string size should be fine 
4998			;		call malloc 
4998			;		push hl    ; save malloc location 
4998			; 
4998			; 
4998			;; TODO check int type 
4998			;		FORTH_DSP_VALUEHL 
4998			;		ld a, l 
4998			;		call DispAToASCII   
4998			;;TODO need to chage above call to dump into string 
4998			; 
4998			; 
4998			 
4998				       NEXTW 
4998 c3 09 24			jp macro_next 
499b				endm 
# End of macro NEXTW
499b			 
499b			.CONCAT: 
499b				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
499b 48				db WORD_SYS_CORE+52             
499c 4e 4a			dw .FIND            
499e 07				db 6 + 1 
499f .. 00			db "CONCAT",0              
49a6				endm 
# End of macro CWHEAD
49a6			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
49a6			 
49a6			; TODO check string type 
49a6			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
49a6			 
49a6					if DEBUG_FORTH_WORDS_KEY 
49a6						DMARK "CON" 
49a6 f5				push af  
49a7 3a bb 49			ld a, (.dmark)  
49aa 32 a6 fd			ld (debug_mark),a  
49ad 3a bc 49			ld a, (.dmark+1)  
49b0 32 a7 fd			ld (debug_mark+1),a  
49b3 3a bd 49			ld a, (.dmark+2)  
49b6 32 a8 fd			ld (debug_mark+2),a  
49b9 18 03			jr .pastdmark  
49bb ..			.dmark: db "CON"  
49be f1			.pastdmark: pop af  
49bf			endm  
# End of macro DMARK
49bf						CALLMONITOR 
49bf cd aa fd			call debug_vector  
49c2				endm  
# End of macro CALLMONITOR
49c2					endif 
49c2			 
49c2			 
49c2					FORTH_DSP_VALUE 
49c2 cd 3c 22			call macro_forth_dsp_value 
49c5				endm 
# End of macro FORTH_DSP_VALUE
49c5 e5					push hl   ; s2 
49c6			 
49c6					FORTH_DSP_POP 
49c6 cd 0b 23			call macro_forth_dsp_pop 
49c9				endm 
# End of macro FORTH_DSP_POP
49c9			 
49c9					FORTH_DSP_VALUE 
49c9 cd 3c 22			call macro_forth_dsp_value 
49cc				endm 
# End of macro FORTH_DSP_VALUE
49cc			 
49cc e5					push hl   ; s1 
49cd			 
49cd					FORTH_DSP_POP 
49cd cd 0b 23			call macro_forth_dsp_pop 
49d0				endm 
# End of macro FORTH_DSP_POP
49d0					 
49d0			 
49d0					; copy s1 
49d0			 
49d0				 
49d0					; save ptr 
49d0 e1					pop hl  
49d1 e5					push hl 
49d2 3e 00				ld a, 0 
49d4 cd 91 13				call strlent 
49d7					;inc hl    ; zer0 
49d7 06 00				ld b, 0 
49d9 4d					ld c, l 
49da e1					pop hl		 
49db 11 fc f0				ld de, scratch	 
49de					if DEBUG_FORTH_WORDS 
49de						DMARK "CO1" 
49de f5				push af  
49df 3a f3 49			ld a, (.dmark)  
49e2 32 a6 fd			ld (debug_mark),a  
49e5 3a f4 49			ld a, (.dmark+1)  
49e8 32 a7 fd			ld (debug_mark+1),a  
49eb 3a f5 49			ld a, (.dmark+2)  
49ee 32 a8 fd			ld (debug_mark+2),a  
49f1 18 03			jr .pastdmark  
49f3 ..			.dmark: db "CO1"  
49f6 f1			.pastdmark: pop af  
49f7			endm  
# End of macro DMARK
49f7						CALLMONITOR 
49f7 cd aa fd			call debug_vector  
49fa				endm  
# End of macro CALLMONITOR
49fa					endif 
49fa ed b0				ldir 
49fc			 
49fc e1					pop hl 
49fd e5					push hl 
49fe d5					push de 
49ff			 
49ff			 
49ff 3e 00				ld a, 0 
4a01 cd 91 13				call strlent 
4a04 23					inc hl    ; zer0 
4a05 23					inc hl 
4a06 06 00				ld b, 0 
4a08 4d					ld c, l 
4a09 d1					pop de 
4a0a e1					pop hl		 
4a0b					if DEBUG_FORTH_WORDS 
4a0b						DMARK "CO2" 
4a0b f5				push af  
4a0c 3a 20 4a			ld a, (.dmark)  
4a0f 32 a6 fd			ld (debug_mark),a  
4a12 3a 21 4a			ld a, (.dmark+1)  
4a15 32 a7 fd			ld (debug_mark+1),a  
4a18 3a 22 4a			ld a, (.dmark+2)  
4a1b 32 a8 fd			ld (debug_mark+2),a  
4a1e 18 03			jr .pastdmark  
4a20 ..			.dmark: db "CO2"  
4a23 f1			.pastdmark: pop af  
4a24			endm  
# End of macro DMARK
4a24						CALLMONITOR 
4a24 cd aa fd			call debug_vector  
4a27				endm  
# End of macro CALLMONITOR
4a27					endif 
4a27 ed b0				ldir 
4a29			 
4a29			 
4a29			 
4a29 21 fc f0				ld hl, scratch 
4a2c					if DEBUG_FORTH_WORDS 
4a2c						DMARK "CO5" 
4a2c f5				push af  
4a2d 3a 41 4a			ld a, (.dmark)  
4a30 32 a6 fd			ld (debug_mark),a  
4a33 3a 42 4a			ld a, (.dmark+1)  
4a36 32 a7 fd			ld (debug_mark+1),a  
4a39 3a 43 4a			ld a, (.dmark+2)  
4a3c 32 a8 fd			ld (debug_mark+2),a  
4a3f 18 03			jr .pastdmark  
4a41 ..			.dmark: db "CO5"  
4a44 f1			.pastdmark: pop af  
4a45			endm  
# End of macro DMARK
4a45						CALLMONITOR 
4a45 cd aa fd			call debug_vector  
4a48				endm  
# End of macro CALLMONITOR
4a48					endif 
4a48			 
4a48 cd ca 20				call forth_push_str 
4a4b			 
4a4b			 
4a4b			 
4a4b			 
4a4b				       NEXTW 
4a4b c3 09 24			jp macro_next 
4a4e				endm 
# End of macro NEXTW
4a4e			 
4a4e			 
4a4e			.FIND: 
4a4e				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4a4e 4b				db WORD_SYS_CORE+55             
4a4f 0c 4b			dw .LEN            
4a51 05				db 4 + 1 
4a52 .. 00			db "FIND",0              
4a57				endm 
# End of macro CWHEAD
4a57			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4a57			 
4a57					if DEBUG_FORTH_WORDS_KEY 
4a57						DMARK "FND" 
4a57 f5				push af  
4a58 3a 6c 4a			ld a, (.dmark)  
4a5b 32 a6 fd			ld (debug_mark),a  
4a5e 3a 6d 4a			ld a, (.dmark+1)  
4a61 32 a7 fd			ld (debug_mark+1),a  
4a64 3a 6e 4a			ld a, (.dmark+2)  
4a67 32 a8 fd			ld (debug_mark+2),a  
4a6a 18 03			jr .pastdmark  
4a6c ..			.dmark: db "FND"  
4a6f f1			.pastdmark: pop af  
4a70			endm  
# End of macro DMARK
4a70						CALLMONITOR 
4a70 cd aa fd			call debug_vector  
4a73				endm  
# End of macro CALLMONITOR
4a73					endif 
4a73			 
4a73			; TODO check string type 
4a73					FORTH_DSP_VALUE 
4a73 cd 3c 22			call macro_forth_dsp_value 
4a76				endm 
# End of macro FORTH_DSP_VALUE
4a76			 
4a76 e5					push hl    
4a77 7e					ld a,(hl)    ; char to find   
4a78			; TODO change char to substr 
4a78			 
4a78 f5					push af 
4a79					 
4a79			 
4a79			 
4a79					if DEBUG_FORTH_WORDS 
4a79						DMARK "FN1" 
4a79 f5				push af  
4a7a 3a 8e 4a			ld a, (.dmark)  
4a7d 32 a6 fd			ld (debug_mark),a  
4a80 3a 8f 4a			ld a, (.dmark+1)  
4a83 32 a7 fd			ld (debug_mark+1),a  
4a86 3a 90 4a			ld a, (.dmark+2)  
4a89 32 a8 fd			ld (debug_mark+2),a  
4a8c 18 03			jr .pastdmark  
4a8e ..			.dmark: db "FN1"  
4a91 f1			.pastdmark: pop af  
4a92			endm  
# End of macro DMARK
4a92						CALLMONITOR 
4a92 cd aa fd			call debug_vector  
4a95				endm  
# End of macro CALLMONITOR
4a95					endif 
4a95			 
4a95					FORTH_DSP_POP 
4a95 cd 0b 23			call macro_forth_dsp_pop 
4a98				endm 
# End of macro FORTH_DSP_POP
4a98			 
4a98					; string to search 
4a98			 
4a98					FORTH_DSP_VALUE 
4a98 cd 3c 22			call macro_forth_dsp_value 
4a9b				endm 
# End of macro FORTH_DSP_VALUE
4a9b			 
4a9b d1					pop de  ; d is char to find  
4a9c			 
4a9c					if DEBUG_FORTH_WORDS 
4a9c						DMARK "FN2" 
4a9c f5				push af  
4a9d 3a b1 4a			ld a, (.dmark)  
4aa0 32 a6 fd			ld (debug_mark),a  
4aa3 3a b2 4a			ld a, (.dmark+1)  
4aa6 32 a7 fd			ld (debug_mark+1),a  
4aa9 3a b3 4a			ld a, (.dmark+2)  
4aac 32 a8 fd			ld (debug_mark+2),a  
4aaf 18 03			jr .pastdmark  
4ab1 ..			.dmark: db "FN2"  
4ab4 f1			.pastdmark: pop af  
4ab5			endm  
# End of macro DMARK
4ab5						CALLMONITOR 
4ab5 cd aa fd			call debug_vector  
4ab8				endm  
# End of macro CALLMONITOR
4ab8					endif 
4ab8					 
4ab8 01 00 00				ld bc, 0 
4abb 7e			.findchar:      ld a,(hl) 
4abc fe 00				cp 0   		 
4abe 28 27				jr z, .finddone     
4ac0 ba					cp d 
4ac1 28 20				jr z, .foundchar 
4ac3 03					inc bc 
4ac4 23					inc hl 
4ac5					if DEBUG_FORTH_WORDS 
4ac5						DMARK "FN3" 
4ac5 f5				push af  
4ac6 3a da 4a			ld a, (.dmark)  
4ac9 32 a6 fd			ld (debug_mark),a  
4acc 3a db 4a			ld a, (.dmark+1)  
4acf 32 a7 fd			ld (debug_mark+1),a  
4ad2 3a dc 4a			ld a, (.dmark+2)  
4ad5 32 a8 fd			ld (debug_mark+2),a  
4ad8 18 03			jr .pastdmark  
4ada ..			.dmark: db "FN3"  
4add f1			.pastdmark: pop af  
4ade			endm  
# End of macro DMARK
4ade						CALLMONITOR 
4ade cd aa fd			call debug_vector  
4ae1				endm  
# End of macro CALLMONITOR
4ae1					endif 
4ae1 18 d8				jr .findchar 
4ae3			 
4ae3			 
4ae3 c5			.foundchar:	push bc 
4ae4 e1					pop hl 
4ae5 18 03				jr .findexit 
4ae7			 
4ae7			 
4ae7							 
4ae7			 
4ae7			.finddone:     ; got to end of string with no find 
4ae7 21 00 00				ld hl, 0 
4aea			.findexit: 
4aea			 
4aea					if DEBUG_FORTH_WORDS 
4aea						DMARK "FNd" 
4aea f5				push af  
4aeb 3a ff 4a			ld a, (.dmark)  
4aee 32 a6 fd			ld (debug_mark),a  
4af1 3a 00 4b			ld a, (.dmark+1)  
4af4 32 a7 fd			ld (debug_mark+1),a  
4af7 3a 01 4b			ld a, (.dmark+2)  
4afa 32 a8 fd			ld (debug_mark+2),a  
4afd 18 03			jr .pastdmark  
4aff ..			.dmark: db "FNd"  
4b02 f1			.pastdmark: pop af  
4b03			endm  
# End of macro DMARK
4b03						CALLMONITOR 
4b03 cd aa fd			call debug_vector  
4b06				endm  
# End of macro CALLMONITOR
4b06					endif 
4b06 cd 5c 20			call forth_push_numhl 
4b09			 
4b09				       NEXTW 
4b09 c3 09 24			jp macro_next 
4b0c				endm 
# End of macro NEXTW
4b0c			 
4b0c			.LEN: 
4b0c				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4b0c 4c				db WORD_SYS_CORE+56             
4b0d 76 4b			dw .ASC            
4b0f 06				db 5 + 1 
4b10 .. 00			db "COUNT",0              
4b16				endm 
# End of macro CWHEAD
4b16			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4b16			 
4b16					if DEBUG_FORTH_WORDS_KEY 
4b16						DMARK "CNT" 
4b16 f5				push af  
4b17 3a 2b 4b			ld a, (.dmark)  
4b1a 32 a6 fd			ld (debug_mark),a  
4b1d 3a 2c 4b			ld a, (.dmark+1)  
4b20 32 a7 fd			ld (debug_mark+1),a  
4b23 3a 2d 4b			ld a, (.dmark+2)  
4b26 32 a8 fd			ld (debug_mark+2),a  
4b29 18 03			jr .pastdmark  
4b2b ..			.dmark: db "CNT"  
4b2e f1			.pastdmark: pop af  
4b2f			endm  
# End of macro DMARK
4b2f						CALLMONITOR 
4b2f cd aa fd			call debug_vector  
4b32				endm  
# End of macro CALLMONITOR
4b32					endif 
4b32			; TODO check string type 
4b32					FORTH_DSP_VALUE 
4b32 cd 3c 22			call macro_forth_dsp_value 
4b35				endm 
# End of macro FORTH_DSP_VALUE
4b35			 
4b35			 
4b35					if DEBUG_FORTH_WORDS 
4b35						DMARK "CN?" 
4b35 f5				push af  
4b36 3a 4a 4b			ld a, (.dmark)  
4b39 32 a6 fd			ld (debug_mark),a  
4b3c 3a 4b 4b			ld a, (.dmark+1)  
4b3f 32 a7 fd			ld (debug_mark+1),a  
4b42 3a 4c 4b			ld a, (.dmark+2)  
4b45 32 a8 fd			ld (debug_mark+2),a  
4b48 18 03			jr .pastdmark  
4b4a ..			.dmark: db "CN?"  
4b4d f1			.pastdmark: pop af  
4b4e			endm  
# End of macro DMARK
4b4e						CALLMONITOR 
4b4e cd aa fd			call debug_vector  
4b51				endm  
# End of macro CALLMONITOR
4b51					endif 
4b51 cd 86 13				call strlenz 
4b54					if DEBUG_FORTH_WORDS 
4b54						DMARK "CNl" 
4b54 f5				push af  
4b55 3a 69 4b			ld a, (.dmark)  
4b58 32 a6 fd			ld (debug_mark),a  
4b5b 3a 6a 4b			ld a, (.dmark+1)  
4b5e 32 a7 fd			ld (debug_mark+1),a  
4b61 3a 6b 4b			ld a, (.dmark+2)  
4b64 32 a8 fd			ld (debug_mark+2),a  
4b67 18 03			jr .pastdmark  
4b69 ..			.dmark: db "CNl"  
4b6c f1			.pastdmark: pop af  
4b6d			endm  
# End of macro DMARK
4b6d						CALLMONITOR 
4b6d cd aa fd			call debug_vector  
4b70				endm  
# End of macro CALLMONITOR
4b70					endif 
4b70			 
4b70 cd 5c 20				call forth_push_numhl 
4b73			 
4b73			 
4b73			 
4b73				       NEXTW 
4b73 c3 09 24			jp macro_next 
4b76				endm 
# End of macro NEXTW
4b76			.ASC: 
4b76				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4b76 4d				db WORD_SYS_CORE+57             
4b77 e4 4b			dw .CHR            
4b79 04				db 3 + 1 
4b7a .. 00			db "ASC",0              
4b7e				endm 
# End of macro CWHEAD
4b7e			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4b7e					if DEBUG_FORTH_WORDS_KEY 
4b7e						DMARK "ASC" 
4b7e f5				push af  
4b7f 3a 93 4b			ld a, (.dmark)  
4b82 32 a6 fd			ld (debug_mark),a  
4b85 3a 94 4b			ld a, (.dmark+1)  
4b88 32 a7 fd			ld (debug_mark+1),a  
4b8b 3a 95 4b			ld a, (.dmark+2)  
4b8e 32 a8 fd			ld (debug_mark+2),a  
4b91 18 03			jr .pastdmark  
4b93 ..			.dmark: db "ASC"  
4b96 f1			.pastdmark: pop af  
4b97			endm  
# End of macro DMARK
4b97						CALLMONITOR 
4b97 cd aa fd			call debug_vector  
4b9a				endm  
# End of macro CALLMONITOR
4b9a					endif 
4b9a					FORTH_DSP_VALUE 
4b9a cd 3c 22			call macro_forth_dsp_value 
4b9d				endm 
# End of macro FORTH_DSP_VALUE
4b9d					;v5 FORTH_DSP_VALUE 
4b9d			;		inc hl      ; now at start of numeric as string 
4b9d			 
4b9d e5					push hl 
4b9e			 
4b9e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b9e cd 0b 23			call macro_forth_dsp_pop 
4ba1				endm 
# End of macro FORTH_DSP_POP
4ba1			 
4ba1 e1					pop hl 
4ba2			 
4ba2					if DEBUG_FORTH_WORDS 
4ba2						DMARK "AS1" 
4ba2 f5				push af  
4ba3 3a b7 4b			ld a, (.dmark)  
4ba6 32 a6 fd			ld (debug_mark),a  
4ba9 3a b8 4b			ld a, (.dmark+1)  
4bac 32 a7 fd			ld (debug_mark+1),a  
4baf 3a b9 4b			ld a, (.dmark+2)  
4bb2 32 a8 fd			ld (debug_mark+2),a  
4bb5 18 03			jr .pastdmark  
4bb7 ..			.dmark: db "AS1"  
4bba f1			.pastdmark: pop af  
4bbb			endm  
# End of macro DMARK
4bbb						CALLMONITOR 
4bbb cd aa fd			call debug_vector  
4bbe				endm  
# End of macro CALLMONITOR
4bbe					endif 
4bbe					; push the content of a onto the stack as a value 
4bbe			 
4bbe 7e					ld a,(hl)   ; get char 
4bbf 26 00				ld h,0 
4bc1 6f					ld l,a 
4bc2					if DEBUG_FORTH_WORDS 
4bc2						DMARK "AS2" 
4bc2 f5				push af  
4bc3 3a d7 4b			ld a, (.dmark)  
4bc6 32 a6 fd			ld (debug_mark),a  
4bc9 3a d8 4b			ld a, (.dmark+1)  
4bcc 32 a7 fd			ld (debug_mark+1),a  
4bcf 3a d9 4b			ld a, (.dmark+2)  
4bd2 32 a8 fd			ld (debug_mark+2),a  
4bd5 18 03			jr .pastdmark  
4bd7 ..			.dmark: db "AS2"  
4bda f1			.pastdmark: pop af  
4bdb			endm  
# End of macro DMARK
4bdb						CALLMONITOR 
4bdb cd aa fd			call debug_vector  
4bde				endm  
# End of macro CALLMONITOR
4bde					endif 
4bde cd 5c 20				call forth_push_numhl 
4be1			 
4be1				       NEXTW 
4be1 c3 09 24			jp macro_next 
4be4				endm 
# End of macro NEXTW
4be4			 
4be4			.CHR: 
4be4				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4be4 4d				db WORD_SYS_CORE+57             
4be5 20 4c			dw .ENDSTR            
4be7 04				db 3 + 1 
4be8 .. 00			db "CHR",0              
4bec				endm 
# End of macro CWHEAD
4bec			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4bec					if DEBUG_FORTH_WORDS_KEY 
4bec						DMARK "CHR" 
4bec f5				push af  
4bed 3a 01 4c			ld a, (.dmark)  
4bf0 32 a6 fd			ld (debug_mark),a  
4bf3 3a 02 4c			ld a, (.dmark+1)  
4bf6 32 a7 fd			ld (debug_mark+1),a  
4bf9 3a 03 4c			ld a, (.dmark+2)  
4bfc 32 a8 fd			ld (debug_mark+2),a  
4bff 18 03			jr .pastdmark  
4c01 ..			.dmark: db "CHR"  
4c04 f1			.pastdmark: pop af  
4c05			endm  
# End of macro DMARK
4c05						CALLMONITOR 
4c05 cd aa fd			call debug_vector  
4c08				endm  
# End of macro CALLMONITOR
4c08					endif 
4c08					FORTH_DSP_VALUEHL 
4c08 cd 53 22			call macro_dsp_valuehl 
4c0b				endm 
# End of macro FORTH_DSP_VALUEHL
4c0b			 
4c0b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c0b cd 0b 23			call macro_forth_dsp_pop 
4c0e				endm 
# End of macro FORTH_DSP_POP
4c0e			 
4c0e					; save asci byte as a zero term string and push string 
4c0e			 
4c0e 7d					ld a,l 
4c0f 32 fc f0				ld (scratch), a 
4c12			 
4c12 3e 00				ld a, 0 
4c14 32 fd f0				ld (scratch+1), a 
4c17			 
4c17 21 fc f0				ld hl, scratch 
4c1a cd ca 20				call forth_push_str 
4c1d			 
4c1d			 
4c1d				       NEXTW 
4c1d c3 09 24			jp macro_next 
4c20				endm 
# End of macro NEXTW
4c20			 
4c20			 
4c20			 
4c20			 
4c20			.ENDSTR: 
4c20			; eof 
4c20			 
# End of file forth_words_str.asm
4c20			include "forth_words_key.asm" 
4c20			 
4c20			; | ## Keyboard Words 
4c20			 
4c20			.KEY: 
4c20				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4c20 3e				db WORD_SYS_CORE+42             
4c21 50 4c			dw .WAITK            
4c23 04				db 3 + 1 
4c24 .. 00			db "KEY",0              
4c28				endm 
# End of macro CWHEAD
4c28			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4c28			 
4c28					if DEBUG_FORTH_WORDS_KEY 
4c28						DMARK "KEY" 
4c28 f5				push af  
4c29 3a 3d 4c			ld a, (.dmark)  
4c2c 32 a6 fd			ld (debug_mark),a  
4c2f 3a 3e 4c			ld a, (.dmark+1)  
4c32 32 a7 fd			ld (debug_mark+1),a  
4c35 3a 3f 4c			ld a, (.dmark+2)  
4c38 32 a8 fd			ld (debug_mark+2),a  
4c3b 18 03			jr .pastdmark  
4c3d ..			.dmark: db "KEY"  
4c40 f1			.pastdmark: pop af  
4c41			endm  
# End of macro DMARK
4c41						CALLMONITOR 
4c41 cd aa fd			call debug_vector  
4c44				endm  
# End of macro CALLMONITOR
4c44					endif 
4c44			; TODO currently waits 
4c44 cd d6 79				call cin 
4c47					;call cin_wait 
4c47 6f					ld l, a 
4c48 26 00				ld h, 0 
4c4a cd 5c 20				call forth_push_numhl 
4c4d					NEXTW 
4c4d c3 09 24			jp macro_next 
4c50				endm 
# End of macro NEXTW
4c50			.WAITK: 
4c50				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4c50 3f				db WORD_SYS_CORE+43             
4c51 82 4c			dw .ACCEPT            
4c53 06				db 5 + 1 
4c54 .. 00			db "WAITK",0              
4c5a				endm 
# End of macro CWHEAD
4c5a			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4c5a					if DEBUG_FORTH_WORDS_KEY 
4c5a						DMARK "WAI" 
4c5a f5				push af  
4c5b 3a 6f 4c			ld a, (.dmark)  
4c5e 32 a6 fd			ld (debug_mark),a  
4c61 3a 70 4c			ld a, (.dmark+1)  
4c64 32 a7 fd			ld (debug_mark+1),a  
4c67 3a 71 4c			ld a, (.dmark+2)  
4c6a 32 a8 fd			ld (debug_mark+2),a  
4c6d 18 03			jr .pastdmark  
4c6f ..			.dmark: db "WAI"  
4c72 f1			.pastdmark: pop af  
4c73			endm  
# End of macro DMARK
4c73						CALLMONITOR 
4c73 cd aa fd			call debug_vector  
4c76				endm  
# End of macro CALLMONITOR
4c76					endif 
4c76 cd c5 79				call cin_wait 
4c79 6f					ld l, a 
4c7a 26 00				ld h, 0 
4c7c cd 5c 20				call forth_push_numhl 
4c7f					NEXTW 
4c7f c3 09 24			jp macro_next 
4c82				endm 
# End of macro NEXTW
4c82			.ACCEPT: 
4c82				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4c82 40				db WORD_SYS_CORE+44             
4c83 e0 4c			dw .EDIT            
4c85 07				db 6 + 1 
4c86 .. 00			db "ACCEPT",0              
4c8d				endm 
# End of macro CWHEAD
4c8d			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4c8d					; TODO crashes on push 
4c8d					if DEBUG_FORTH_WORDS_KEY 
4c8d						DMARK "ACC" 
4c8d f5				push af  
4c8e 3a a2 4c			ld a, (.dmark)  
4c91 32 a6 fd			ld (debug_mark),a  
4c94 3a a3 4c			ld a, (.dmark+1)  
4c97 32 a7 fd			ld (debug_mark+1),a  
4c9a 3a a4 4c			ld a, (.dmark+2)  
4c9d 32 a8 fd			ld (debug_mark+2),a  
4ca0 18 03			jr .pastdmark  
4ca2 ..			.dmark: db "ACC"  
4ca5 f1			.pastdmark: pop af  
4ca6			endm  
# End of macro DMARK
4ca6						CALLMONITOR 
4ca6 cd aa fd			call debug_vector  
4ca9				endm  
# End of macro CALLMONITOR
4ca9					endif 
4ca9 21 fa f2				ld hl, os_input 
4cac 3e 00				ld a, 0 
4cae 77					ld (hl),a 
4caf 3a 99 f9				ld a,(f_cursor_ptr) 
4cb2 16 64				ld d, 100 
4cb4 0e 00				ld c, 0 
4cb6 1e 28				ld e, 40 
4cb8 cd fc 0f				call input_str 
4cbb					; TODO perhaps do a type check and wrap in quotes if not a number 
4cbb 21 fa f2				ld hl, os_input 
4cbe					if DEBUG_FORTH_WORDS 
4cbe						DMARK "AC1" 
4cbe f5				push af  
4cbf 3a d3 4c			ld a, (.dmark)  
4cc2 32 a6 fd			ld (debug_mark),a  
4cc5 3a d4 4c			ld a, (.dmark+1)  
4cc8 32 a7 fd			ld (debug_mark+1),a  
4ccb 3a d5 4c			ld a, (.dmark+2)  
4cce 32 a8 fd			ld (debug_mark+2),a  
4cd1 18 03			jr .pastdmark  
4cd3 ..			.dmark: db "AC1"  
4cd6 f1			.pastdmark: pop af  
4cd7			endm  
# End of macro DMARK
4cd7						CALLMONITOR 
4cd7 cd aa fd			call debug_vector  
4cda				endm  
# End of macro CALLMONITOR
4cda					endif 
4cda cd ca 20				call forth_push_str 
4cdd					NEXTW 
4cdd c3 09 24			jp macro_next 
4ce0				endm 
# End of macro NEXTW
4ce0			 
4ce0			.EDIT: 
4ce0				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4ce0 40				db WORD_SYS_CORE+44             
4ce1 82 4d			dw .DEDIT            
4ce3 05				db 4 + 1 
4ce4 .. 00			db "EDIT",0              
4ce9				endm 
# End of macro CWHEAD
4ce9			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4ce9			 
4ce9					; TODO does not copy from stack 
4ce9					if DEBUG_FORTH_WORDS_KEY 
4ce9						DMARK "EDT" 
4ce9 f5				push af  
4cea 3a fe 4c			ld a, (.dmark)  
4ced 32 a6 fd			ld (debug_mark),a  
4cf0 3a ff 4c			ld a, (.dmark+1)  
4cf3 32 a7 fd			ld (debug_mark+1),a  
4cf6 3a 00 4d			ld a, (.dmark+2)  
4cf9 32 a8 fd			ld (debug_mark+2),a  
4cfc 18 03			jr .pastdmark  
4cfe ..			.dmark: db "EDT"  
4d01 f1			.pastdmark: pop af  
4d02			endm  
# End of macro DMARK
4d02						CALLMONITOR 
4d02 cd aa fd			call debug_vector  
4d05				endm  
# End of macro CALLMONITOR
4d05					endif 
4d05			 
4d05					;FORTH_DSP 
4d05					FORTH_DSP_VALUEHL 
4d05 cd 53 22			call macro_dsp_valuehl 
4d08				endm 
# End of macro FORTH_DSP_VALUEHL
4d08			;		inc hl    ; TODO do type check 
4d08			 
4d08			;		call get_word_hl 
4d08 e5					push hl 
4d09					if DEBUG_FORTH_WORDS 
4d09						DMARK "EDp" 
4d09 f5				push af  
4d0a 3a 1e 4d			ld a, (.dmark)  
4d0d 32 a6 fd			ld (debug_mark),a  
4d10 3a 1f 4d			ld a, (.dmark+1)  
4d13 32 a7 fd			ld (debug_mark+1),a  
4d16 3a 20 4d			ld a, (.dmark+2)  
4d19 32 a8 fd			ld (debug_mark+2),a  
4d1c 18 03			jr .pastdmark  
4d1e ..			.dmark: db "EDp"  
4d21 f1			.pastdmark: pop af  
4d22			endm  
# End of macro DMARK
4d22						CALLMONITOR 
4d22 cd aa fd			call debug_vector  
4d25				endm  
# End of macro CALLMONITOR
4d25					endif 
4d25				;	ld a, 0 
4d25 cd 86 13				call strlenz 
4d28 23					inc hl 
4d29			 
4d29 06 00				ld b, 0 
4d2b 4d					ld c, l 
4d2c			 
4d2c e1					pop hl 
4d2d 11 fa f2				ld de, os_input 
4d30					if DEBUG_FORTH_WORDS_KEY 
4d30						DMARK "EDc" 
4d30 f5				push af  
4d31 3a 45 4d			ld a, (.dmark)  
4d34 32 a6 fd			ld (debug_mark),a  
4d37 3a 46 4d			ld a, (.dmark+1)  
4d3a 32 a7 fd			ld (debug_mark+1),a  
4d3d 3a 47 4d			ld a, (.dmark+2)  
4d40 32 a8 fd			ld (debug_mark+2),a  
4d43 18 03			jr .pastdmark  
4d45 ..			.dmark: db "EDc"  
4d48 f1			.pastdmark: pop af  
4d49			endm  
# End of macro DMARK
4d49						CALLMONITOR 
4d49 cd aa fd			call debug_vector  
4d4c				endm  
# End of macro CALLMONITOR
4d4c					endif 
4d4c ed b0				ldir 
4d4e			 
4d4e			 
4d4e 21 fa f2				ld hl, os_input 
4d51					;ld a, 0 
4d51					;ld (hl),a 
4d51 3a 99 f9				ld a,(f_cursor_ptr) 
4d54 16 64				ld d, 100 
4d56 0e 00				ld c, 0 
4d58 1e 28				ld e, 40 
4d5a cd fc 0f				call input_str 
4d5d					; TODO perhaps do a type check and wrap in quotes if not a number 
4d5d 21 fa f2				ld hl, os_input 
4d60					if DEBUG_FORTH_WORDS 
4d60						DMARK "ED1" 
4d60 f5				push af  
4d61 3a 75 4d			ld a, (.dmark)  
4d64 32 a6 fd			ld (debug_mark),a  
4d67 3a 76 4d			ld a, (.dmark+1)  
4d6a 32 a7 fd			ld (debug_mark+1),a  
4d6d 3a 77 4d			ld a, (.dmark+2)  
4d70 32 a8 fd			ld (debug_mark+2),a  
4d73 18 03			jr .pastdmark  
4d75 ..			.dmark: db "ED1"  
4d78 f1			.pastdmark: pop af  
4d79			endm  
# End of macro DMARK
4d79						CALLMONITOR 
4d79 cd aa fd			call debug_vector  
4d7c				endm  
# End of macro CALLMONITOR
4d7c					endif 
4d7c cd ca 20				call forth_push_str 
4d7f					NEXTW 
4d7f c3 09 24			jp macro_next 
4d82				endm 
# End of macro NEXTW
4d82			 
4d82			.DEDIT: 
4d82				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4d82 40				db WORD_SYS_CORE+44             
4d83 e4 4d			dw .ENDKEY            
4d85 06				db 5 + 1 
4d86 .. 00			db "DEDIT",0              
4d8c				endm 
# End of macro CWHEAD
4d8c			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4d8c			 
4d8c					; TODO does not copy from stack 
4d8c					if DEBUG_FORTH_WORDS_KEY 
4d8c						DMARK "DED" 
4d8c f5				push af  
4d8d 3a a1 4d			ld a, (.dmark)  
4d90 32 a6 fd			ld (debug_mark),a  
4d93 3a a2 4d			ld a, (.dmark+1)  
4d96 32 a7 fd			ld (debug_mark+1),a  
4d99 3a a3 4d			ld a, (.dmark+2)  
4d9c 32 a8 fd			ld (debug_mark+2),a  
4d9f 18 03			jr .pastdmark  
4da1 ..			.dmark: db "DED"  
4da4 f1			.pastdmark: pop af  
4da5			endm  
# End of macro DMARK
4da5						CALLMONITOR 
4da5 cd aa fd			call debug_vector  
4da8				endm  
# End of macro CALLMONITOR
4da8					endif 
4da8			 
4da8					;FORTH_DSP 
4da8					FORTH_DSP_VALUEHL 
4da8 cd 53 22			call macro_dsp_valuehl 
4dab				endm 
# End of macro FORTH_DSP_VALUEHL
4dab			;		inc hl    ; TODO do type check 
4dab			 
4dab			;		call get_word_hl 
4dab e5					push hl 
4dac e5					push hl 
4dad					FORTH_DSP_POP 
4dad cd 0b 23			call macro_forth_dsp_pop 
4db0				endm 
# End of macro FORTH_DSP_POP
4db0 e1					pop hl 
4db1					if DEBUG_FORTH_WORDS 
4db1						DMARK "EDp" 
4db1 f5				push af  
4db2 3a c6 4d			ld a, (.dmark)  
4db5 32 a6 fd			ld (debug_mark),a  
4db8 3a c7 4d			ld a, (.dmark+1)  
4dbb 32 a7 fd			ld (debug_mark+1),a  
4dbe 3a c8 4d			ld a, (.dmark+2)  
4dc1 32 a8 fd			ld (debug_mark+2),a  
4dc4 18 03			jr .pastdmark  
4dc6 ..			.dmark: db "EDp"  
4dc9 f1			.pastdmark: pop af  
4dca			endm  
# End of macro DMARK
4dca						CALLMONITOR 
4dca cd aa fd			call debug_vector  
4dcd				endm  
# End of macro CALLMONITOR
4dcd					endif 
4dcd				;	ld a, 0 
4dcd cd 86 13				call strlenz 
4dd0 23					inc hl 
4dd1			 
4dd1 06 00				ld b, 0 
4dd3 4d					ld c, l 
4dd4			 
4dd4 e1					pop hl 
4dd5			 
4dd5					;ld a, 0 
4dd5					;ld (hl),a 
4dd5 3a 99 f9				ld a,(f_cursor_ptr) 
4dd8 16 64				ld d, 100 
4dda 0e 00				ld c, 0 
4ddc 1e 28				ld e, 40 
4dde cd fc 0f				call input_str 
4de1					; TODO perhaps do a type check and wrap in quotes if not a number 
4de1					NEXTW 
4de1 c3 09 24			jp macro_next 
4de4				endm 
# End of macro NEXTW
4de4			 
4de4			 
4de4			.ENDKEY: 
4de4			; eof 
4de4			 
# End of file forth_words_key.asm
4de4			include "forth_words_const.asm" 
4de4			 
4de4			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4de4			 
4de4			 
4de4			.SPITIME: 
4de4				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4de4 77				db WORD_SYS_CORE+99             
4de5 f9 4d			dw .VA            
4de7 08				db 7 + 1 
4de8 .. 00			db "SPITIME",0              
4df0				endm 
# End of macro CWHEAD
4df0			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
4df0			; 
4df0			; | | If using BANK devices then leave as is. 
4df0			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
4df0			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
4df0			 
4df0 21 9f f9				ld hl, spi_clktime  
4df3 cd 5c 20				call forth_push_numhl 
4df6			 
4df6					NEXTW 
4df6 c3 09 24			jp macro_next 
4df9				endm 
# End of macro NEXTW
4df9			 
4df9			 
4df9			.VA: 
4df9				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4df9 77				db WORD_SYS_CORE+99             
4dfa 09 4e			dw .SYMBOL            
4dfc 03				db 2 + 1 
4dfd .. 00			db "VA",0              
4e00				endm 
# End of macro CWHEAD
4e00			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
4e00 21 63 f9				ld hl, cli_var_array 
4e03 cd 5c 20				call forth_push_numhl 
4e06			 
4e06					NEXTW 
4e06 c3 09 24			jp macro_next 
4e09				endm 
# End of macro NEXTW
4e09			 
4e09			.SYMBOL: 
4e09				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4e09 77				db WORD_SYS_CORE+99             
4e0a 13 4f			dw .ENDCONST            
4e0c 07				db 6 + 1 
4e0d .. 00			db "SYMBOL",0              
4e14				endm 
# End of macro CWHEAD
4e14			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4e14			; | 
4e14			; | | The value is the number reference and the final address is pushed to stack 
4e14			 
4e14			; | | ``` 
4e14			; | | dw sym_table 
4e14			; | | dw nmi_vector 
4e14			; | | dw cli_autodisplay 
4e14			; | | dw cli_data_sp 
4e14			; | | dw cli_data_stack 
4e14			; | | dw cli_loop_sp 
4e14			; | | dw cli_loop_stack 
4e14			; | | dw cli_var_array 
4e14			; | | dw cursor_col 
4e14			; | | dw cursor_ptr 
4e14			; | | ; 10 
4e14			; | | dw cursor_row 
4e14			; | | dw debug_mark 
4e14			; | | dw display_fb0 
4e14			; | | dw display_fb1 
4e14			; | | dw display_fb2 
4e14			; | | dw display_fb3 
4e14			; | | dw display_fb_active 
4e14			; | | dw execscratch 
4e14			; | | dw f_cursor_ptr 
4e14			; | | dw hardware_word 
4e14			; | | ;20 
4e14			; | | dw input_at_cursor 
4e14			; | | dw input_at_pos 
4e14			; | | dw input_cur_flash 
4e14			; | | dw input_cur_onoff 
4e14			; | | dw input_cursor 
4e14			; | | dw input_display_size 
4e14			; | | dw input_len 
4e14			; | | dw input_ptr 
4e14			; | | dw input_size 
4e14			; | | dw input_start 
4e14			; | | ; 30 
4e14			; | | dw input_str 
4e14			; | | dw input_under_cursor 
4e14			; | | dw os_cli_cmd 
4e14			; | | dw os_cur_ptr 
4e14			; | | dw os_current_i 
4e14			; | | dw os_input 
4e14			; | | dw os_last_cmd 
4e14			; | | dw os_last_new_uword 
4e14			; | | dw debug_vector 
4e14			; | | dw os_view_hl 
4e14			; | | ;40 
4e14			; | | dw os_word_scratch 
4e14			; | | dw portbctl 
4e14			; | | dw portbdata 
4e14			; | | dw spi_cartdev 
4e14			; | | dw spi_cartdev2 
4e14			; | | dw spi_clktime 
4e14			; | | dw spi_device 
4e14			; | | dw spi_device_id 
4e14			; | | dw spi_portbyte 
4e14			; | | dw stackstore 
4e14			; | | ; 50 
4e14			; | | if STORAGE_SE 
4e14			; | | dw storage_actl 
4e14			; | | dw storage_adata 
4e14			; | | else 
4e14			; | | dw 0 
4e14			; | | dw 0 
4e14			; | | endif 
4e14			; | | dw storage_append 
4e14			; | | if STORAGE_SE 
4e14			; | | dw storage_bctl 
4e14			; | | else 
4e14			; | | dw 0 
4e14			; | | endif 
4e14			; | | dw store_bank_active 
4e14			; | | dw store_filecache 
4e14			; | | dw store_longread 
4e14			; | | dw store_openaddr 
4e14			; | | dw store_openext 
4e14			; | | dw store_openmaxext 
4e14			; | | ; 60 
4e14			; | | dw store_page 
4e14			; | | dw store_readbuf 
4e14			; | | dw store_readcont 
4e14			; | | dw store_readptr 
4e14			; | | dw store_tmpext 
4e14			; | | dw store_tmpid 
4e14			; | | dw store_tmppageid 
4e14			; | | dw malloc 
4e14			; | | dw free 
4e14			; | | dw cin 
4e14			; | | ; 70 
4e14			; | | dw cin_wait 
4e14			; | | dw forth_push_numhl 
4e14			; | | dw forth_push_str 
4e14			; | | ``` 
4e14			 
4e14					if DEBUG_FORTH_WORDS_KEY 
4e14						DMARK "SYM" 
4e14 f5				push af  
4e15 3a 29 4e			ld a, (.dmark)  
4e18 32 a6 fd			ld (debug_mark),a  
4e1b 3a 2a 4e			ld a, (.dmark+1)  
4e1e 32 a7 fd			ld (debug_mark+1),a  
4e21 3a 2b 4e			ld a, (.dmark+2)  
4e24 32 a8 fd			ld (debug_mark+2),a  
4e27 18 03			jr .pastdmark  
4e29 ..			.dmark: db "SYM"  
4e2c f1			.pastdmark: pop af  
4e2d			endm  
# End of macro DMARK
4e2d						CALLMONITOR 
4e2d cd aa fd			call debug_vector  
4e30				endm  
# End of macro CALLMONITOR
4e30					endif 
4e30			 
4e30					FORTH_DSP_VALUEHL 
4e30 cd 53 22			call macro_dsp_valuehl 
4e33				endm 
# End of macro FORTH_DSP_VALUEHL
4e33			 
4e33 7d					ld a, l     
4e34			 
4e34			 
4e34					if DEBUG_FORTH_WORDS 
4e34						DMARK "SY1" 
4e34 f5				push af  
4e35 3a 49 4e			ld a, (.dmark)  
4e38 32 a6 fd			ld (debug_mark),a  
4e3b 3a 4a 4e			ld a, (.dmark+1)  
4e3e 32 a7 fd			ld (debug_mark+1),a  
4e41 3a 4b 4e			ld a, (.dmark+2)  
4e44 32 a8 fd			ld (debug_mark+2),a  
4e47 18 03			jr .pastdmark  
4e49 ..			.dmark: db "SY1"  
4e4c f1			.pastdmark: pop af  
4e4d			endm  
# End of macro DMARK
4e4d						CALLMONITOR 
4e4d cd aa fd			call debug_vector  
4e50				endm  
# End of macro CALLMONITOR
4e50					endif 
4e50					 
4e50 f5					push af	 
4e51					FORTH_DSP_POP 
4e51 cd 0b 23			call macro_forth_dsp_pop 
4e54				endm 
# End of macro FORTH_DSP_POP
4e54 f1					pop af 
4e55			 
4e55 cb 27				sla a  
4e57				 
4e57					 
4e57					if DEBUG_FORTH_WORDS 
4e57						DMARK "SY" 
4e57 f5				push af  
4e58 3a 6c 4e			ld a, (.dmark)  
4e5b 32 a6 fd			ld (debug_mark),a  
4e5e 3a 6d 4e			ld a, (.dmark+1)  
4e61 32 a7 fd			ld (debug_mark+1),a  
4e64 3a 6e 4e			ld a, (.dmark+2)  
4e67 32 a8 fd			ld (debug_mark+2),a  
4e6a 18 02			jr .pastdmark  
4e6c ..			.dmark: db "SY"  
4e6e f1			.pastdmark: pop af  
4e6f			endm  
# End of macro DMARK
4e6f						CALLMONITOR 
4e6f cd aa fd			call debug_vector  
4e72				endm  
# End of macro CALLMONITOR
4e72					endif 
4e72			 
4e72 21 81 4e				ld hl, sym_table 
4e75 cd cf 0f				call addatohl 
4e78 cd 8b 23				call loadwordinhl 
4e7b cd 5c 20				call forth_push_numhl 
4e7e			 
4e7e			 
4e7e				       NEXTW 
4e7e c3 09 24			jp macro_next 
4e81				endm 
# End of macro NEXTW
4e81			 
4e81			sym_table: 
4e81			 
4e81			; 0 
4e81 81 4e		dw sym_table 
4e83 ad fd		dw nmi_vector 
4e85 77 f9		dw cli_autodisplay 
4e87 29 f9		dw cli_data_sp 
4e89 63 f6		dw cli_data_stack 
4e8b 2b f9		dw cli_loop_sp 
4e8d 65 f8		dw cli_loop_stack 
4e8f 63 f9		dw cli_var_array 
4e91 00 fb		dw cursor_col 
4e93 fe fa		dw cursor_ptr 
4e95			; 10 
4e95 ff fa		dw cursor_row 
4e97 a6 fd		dw debug_mark 
4e99 ec fc		dw display_fb0 
4e9b 4b fc		dw display_fb1 
4e9d 09 fb		dw display_fb2 
4e9f aa fb		dw display_fb3 
4ea1 07 fb		dw display_fb_active 
4ea3 fb f1		dw execscratch 
4ea5 99 f9		dw f_cursor_ptr 
4ea7 b0 fd		dw hardware_word 
4ea9			;20 
4ea9 9d fd		dw input_at_cursor 
4eab 9f fd		dw input_at_pos 
4ead 9b fd		dw input_cur_flash 
4eaf 9a fd		dw input_cur_onoff 
4eb1 90 fd		dw input_cursor 
4eb3 a0 fd		dw input_display_size 
4eb5 95 fd		dw input_len 
4eb7 a4 fd		dw input_ptr 
4eb9 a1 fd		dw input_size 
4ebb a2 fd		dw input_start 
4ebd			; 30 
4ebd fc 0f		dw input_str 
4ebf 9e fd		dw input_under_cursor 
4ec1 23 f4		dw os_cli_cmd 
4ec3 1f f4		dw os_cur_ptr 
4ec5 21 f4		dw os_current_i 
4ec7 fa f2		dw os_input 
4ec9 22 f5		dw os_last_cmd 
4ecb f9 f3		dw os_last_new_uword 
4ecd aa fd		dw debug_vector 
4ecf de f0		dw os_view_hl 
4ed1			;40 
4ed1 01 f4		dw os_word_scratch 
4ed3 c3 00		dw portbctl 
4ed5 c1 00		dw portbdata 
4ed7 9e f9		dw spi_cartdev 
4ed9 9d f9		dw spi_cartdev2 
4edb 9f f9		dw spi_clktime 
4edd 9b f9		dw spi_device 
4edf 9a f9		dw spi_device_id 
4ee1 9c f9		dw spi_portbyte 
4ee3 e2 fa		dw stackstore 
4ee5			; 50 
4ee5			if STORAGE_SE 
4ee5 82 00		dw storage_actl 
4ee7 80 00		dw storage_adata 
4ee9			else 
4ee9			dw 0 
4ee9			dw 0 
4ee9			endif 
4ee9 55 0b		dw storage_append 
4eeb			if STORAGE_SE 
4eeb 83 00		dw storage_bctl 
4eed			else 
4eed			dw 0 
4eed			endif 
4eed ce fa		dw store_bank_active 
4eef a2 f9		dw store_filecache 
4ef1 b0 f9		dw store_longread 
4ef3 a6 f9		dw store_openaddr 
4ef5 a5 f9		dw store_openext 
4ef7 a4 f9		dw store_openmaxext 
4ef9			; 60 
4ef9 b5 f9		dw store_page 
4efb b1 f9		dw store_readbuf 
4efd a8 f9		dw store_readcont 
4eff b3 f9		dw store_readptr 
4f01 a8 f9		dw store_tmpext 
4f03 a9 f9		dw store_tmpid 
4f05 a0 f9		dw store_tmppageid 
4f07 fb 13		dw malloc 
4f09 c5 14		dw free 
4f0b d6 79		dw cin 
4f0d			; 70 
4f0d c5 79		dw cin_wait 
4f0f 5c 20		dw forth_push_numhl 
4f11 ca 20		dw forth_push_str 
4f13			 
4f13			 
4f13			.ENDCONST: 
4f13			 
4f13			; eof 
4f13			 
4f13			 
# End of file forth_words_const.asm
4f13			 
4f13			if STORAGE_SE 
4f13			   	include "forth_words_storage.asm" 
4f13			 
4f13			; | ## Fixed Storage Words 
4f13			 
4f13			.RENAME: 
4f13			  
4f13				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
4f13 3a				db WORD_SYS_CORE+38             
4f14 09 50			dw .RECORD            
4f16 07				db 6 + 1 
4f17 .. 00			db "RENAME",0              
4f1e				endm 
# End of macro CWHEAD
4f1e			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
4f1e			; | | > [!NOTE] 
4f1e			; | | > Compatible with PicoSPINet  
4f1e					if DEBUG_FORTH_WORDS_KEY 
4f1e						DMARK "REN" 
4f1e f5				push af  
4f1f 3a 33 4f			ld a, (.dmark)  
4f22 32 a6 fd			ld (debug_mark),a  
4f25 3a 34 4f			ld a, (.dmark+1)  
4f28 32 a7 fd			ld (debug_mark+1),a  
4f2b 3a 35 4f			ld a, (.dmark+2)  
4f2e 32 a8 fd			ld (debug_mark+2),a  
4f31 18 03			jr .pastdmark  
4f33 ..			.dmark: db "REN"  
4f36 f1			.pastdmark: pop af  
4f37			endm  
# End of macro DMARK
4f37						CALLMONITOR 
4f37 cd aa fd			call debug_vector  
4f3a				endm  
# End of macro CALLMONITOR
4f3a					endif 
4f3a			 
4f3a			 
4f3a					; preserve some internal vars used by other file handing routines 
4f3a			 
4f3a 2a a6 f9				ld hl, (store_openaddr) 
4f3d e5					push hl 
4f3e 3a a8 f9				ld a, (store_readcont) 
4f41 f5					push af 
4f42			 
4f42					FORTH_DSP_VALUEHL 
4f42 cd 53 22			call macro_dsp_valuehl 
4f45				endm 
# End of macro FORTH_DSP_VALUEHL
4f45			 
4f45					; move ext and id around for the file header 
4f45			 
4f45 65					ld h, l 
4f46 2e 00				ld l, 0 
4f48			 
4f48 e5					push hl    ; id 
4f49			 
4f49					FORTH_DSP_POP 
4f49 cd 0b 23			call macro_forth_dsp_pop 
4f4c				endm 
# End of macro FORTH_DSP_POP
4f4c			 
4f4c					; Locate the file header 
4f4c			 
4f4c e1					pop hl 
4f4d e5					push hl 
4f4e 11 b5 f9				ld de, store_page      ; get block zero of file 
4f51					if DEBUG_FORTH_WORDS 
4f51						DMARK "REr" 
4f51 f5				push af  
4f52 3a 66 4f			ld a, (.dmark)  
4f55 32 a6 fd			ld (debug_mark),a  
4f58 3a 67 4f			ld a, (.dmark+1)  
4f5b 32 a7 fd			ld (debug_mark+1),a  
4f5e 3a 68 4f			ld a, (.dmark+2)  
4f61 32 a8 fd			ld (debug_mark+2),a  
4f64 18 03			jr .pastdmark  
4f66 ..			.dmark: db "REr"  
4f69 f1			.pastdmark: pop af  
4f6a			endm  
# End of macro DMARK
4f6a						CALLMONITOR 
4f6a cd aa fd			call debug_vector  
4f6d				endm  
# End of macro CALLMONITOR
4f6d					endif 
4f6d cd be 09				call storage_read 
4f70			 
4f70 cd f8 0f			call ishlzero 
4f73 20 05			jr nz, .rnfound 
4f75			 
4f75				; file does not exist so indicate with 255 extents in use 
4f75			 
4f75 3e ff			ld a, 255 
4f77 e1				pop hl ; clear dup hl 
4f78 18 7b			jr .skiprneof 
4f7a			 
4f7a			 
4f7a			.rnfound: 
4f7a					; file found so rename 
4f7a			 
4f7a					FORTH_DSP_VALUEHL 
4f7a cd 53 22			call macro_dsp_valuehl 
4f7d				endm 
# End of macro FORTH_DSP_VALUEHL
4f7d			 
4f7d e5				push hl 
4f7e 3e 00			ld a, 0 
4f80 cd 91 13			call strlent 
4f83 23				inc hl   ; cover zero term 
4f84 06 00			ld b,0 
4f86 4d				ld c,l 
4f87 e1				pop hl 
4f88 11 b8 f9				ld de, store_page + 3 
4f8b ed b0				ldir 
4f8d			 
4f8d 11 b5 f9				ld de, store_page 
4f90					if DEBUG_FORTH_WORDS 
4f90						DMARK "RER" 
4f90 f5				push af  
4f91 3a a5 4f			ld a, (.dmark)  
4f94 32 a6 fd			ld (debug_mark),a  
4f97 3a a6 4f			ld a, (.dmark+1)  
4f9a 32 a7 fd			ld (debug_mark+1),a  
4f9d 3a a7 4f			ld a, (.dmark+2)  
4fa0 32 a8 fd			ld (debug_mark+2),a  
4fa3 18 03			jr .pastdmark  
4fa5 ..			.dmark: db "RER"  
4fa8 f1			.pastdmark: pop af  
4fa9			endm  
# End of macro DMARK
4fa9						CALLMONITOR 
4fa9 cd aa fd			call debug_vector  
4fac				endm  
# End of macro CALLMONITOR
4fac					endif 
4fac			 
4fac e1					pop hl    ; get orig file id and mangle it for find id 
4fad 55					ld d, l 
4fae 5c					ld e, h 
4faf			 
4faf 21 00 00				ld hl, 0 
4fb2					if DEBUG_FORTH_WORDS 
4fb2						DMARK "REf" 
4fb2 f5				push af  
4fb3 3a c7 4f			ld a, (.dmark)  
4fb6 32 a6 fd			ld (debug_mark),a  
4fb9 3a c8 4f			ld a, (.dmark+1)  
4fbc 32 a7 fd			ld (debug_mark+1),a  
4fbf 3a c9 4f			ld a, (.dmark+2)  
4fc2 32 a8 fd			ld (debug_mark+2),a  
4fc5 18 03			jr .pastdmark  
4fc7 ..			.dmark: db "REf"  
4fca f1			.pastdmark: pop af  
4fcb			endm  
# End of macro DMARK
4fcb						CALLMONITOR 
4fcb cd aa fd			call debug_vector  
4fce				endm  
# End of macro CALLMONITOR
4fce					endif 
4fce cd 98 07				call storage_findnextid 
4fd1 11 b5 f9				ld de, store_page 
4fd4					if DEBUG_FORTH_WORDS 
4fd4						DMARK "REw" 
4fd4 f5				push af  
4fd5 3a e9 4f			ld a, (.dmark)  
4fd8 32 a6 fd			ld (debug_mark),a  
4fdb 3a ea 4f			ld a, (.dmark+1)  
4fde 32 a7 fd			ld (debug_mark+1),a  
4fe1 3a eb 4f			ld a, (.dmark+2)  
4fe4 32 a8 fd			ld (debug_mark+2),a  
4fe7 18 03			jr .pastdmark  
4fe9 ..			.dmark: db "REw"  
4fec f1			.pastdmark: pop af  
4fed			endm  
# End of macro DMARK
4fed						CALLMONITOR 
4fed cd aa fd			call debug_vector  
4ff0				endm  
# End of macro CALLMONITOR
4ff0					endif 
4ff0 cd ca 04				call storage_write_block 
4ff3			 
4ff3 3e 00				ld a, 0 
4ff5			.skiprneof: 
4ff5					; drop file name 
4ff5					FORTH_DSP_POP 
4ff5 cd 0b 23			call macro_forth_dsp_pop 
4ff8				endm 
# End of macro FORTH_DSP_POP
4ff8			 
4ff8 6f					ld l, a 
4ff9 26 00				ld h, 0 
4ffb cd 5c 20				call forth_push_numhl 
4ffe			 
4ffe			 
4ffe f1					pop af 
4fff 32 a8 f9				ld (store_readcont),a 
5002 e1					pop hl 
5003 22 a6 f9				ld (store_openaddr), hl 
5006						 
5006				NEXTW 
5006 c3 09 24			jp macro_next 
5009				endm 
# End of macro NEXTW
5009			.RECORD: 
5009			  
5009				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
5009 3a				db WORD_SYS_CORE+38             
500a ad 50			dw .BREAD            
500c 07				db 6 + 1 
500d .. 00			db "RECORD",0              
5014				endm 
# End of macro CWHEAD
5014			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
5014			; | | > [!NOTE] 
5014			; | | > Compatible with PicoSPINet  
5014			 
5014					if DEBUG_FORTH_WORDS_KEY 
5014						DMARK "REC" 
5014 f5				push af  
5015 3a 29 50			ld a, (.dmark)  
5018 32 a6 fd			ld (debug_mark),a  
501b 3a 2a 50			ld a, (.dmark+1)  
501e 32 a7 fd			ld (debug_mark+1),a  
5021 3a 2b 50			ld a, (.dmark+2)  
5024 32 a8 fd			ld (debug_mark+2),a  
5027 18 03			jr .pastdmark  
5029 ..			.dmark: db "REC"  
502c f1			.pastdmark: pop af  
502d			endm  
# End of macro DMARK
502d						CALLMONITOR 
502d cd aa fd			call debug_vector  
5030				endm  
# End of macro CALLMONITOR
5030					endif 
5030			 
5030					FORTH_DSP_VALUEHL 
5030 cd 53 22			call macro_dsp_valuehl 
5033				endm 
# End of macro FORTH_DSP_VALUEHL
5033			 
5033 e5					push hl    ; id 
5034			 
5034					FORTH_DSP_POP 
5034 cd 0b 23			call macro_forth_dsp_pop 
5037				endm 
# End of macro FORTH_DSP_POP
5037			 
5037					FORTH_DSP_VALUEHL 
5037 cd 53 22			call macro_dsp_valuehl 
503a				endm 
# End of macro FORTH_DSP_VALUEHL
503a			 
503a					FORTH_DSP_POP 
503a cd 0b 23			call macro_forth_dsp_pop 
503d				endm 
# End of macro FORTH_DSP_POP
503d			 
503d d1					pop de     ; get file id 
503e			 
503e					; e = file id 
503e					; l = file extent 
503e			 
503e			 
503e					; construct request to access file extent 
503e			 
503e			;		ld a, e 
503e 63					ld h, e 
503f					 
503f					 
503f					 
503f			 
503f					; e has id 
503f			 
503f 11 b5 f9			ld de, store_page 
5042					if DEBUG_FORTH_WORDS 
5042						DMARK "REr" 
5042 f5				push af  
5043 3a 57 50			ld a, (.dmark)  
5046 32 a6 fd			ld (debug_mark),a  
5049 3a 58 50			ld a, (.dmark+1)  
504c 32 a7 fd			ld (debug_mark+1),a  
504f 3a 59 50			ld a, (.dmark+2)  
5052 32 a8 fd			ld (debug_mark+2),a  
5055 18 03			jr .pastdmark  
5057 ..			.dmark: db "REr"  
505a f1			.pastdmark: pop af  
505b			endm  
# End of macro DMARK
505b						CALLMONITOR 
505b cd aa fd			call debug_vector  
505e				endm  
# End of macro CALLMONITOR
505e					endif 
505e cd be 09				call storage_read 
5061 cd f8 0f			call ishlzero 
5064 28 22			jr z, .recnotfound 
5066			 
5066			 
5066					if DEBUG_FORTH_WORDS 
5066						DMARK "REe" 
5066 f5				push af  
5067 3a 7b 50			ld a, (.dmark)  
506a 32 a6 fd			ld (debug_mark),a  
506d 3a 7c 50			ld a, (.dmark+1)  
5070 32 a7 fd			ld (debug_mark+1),a  
5073 3a 7d 50			ld a, (.dmark+2)  
5076 32 a8 fd			ld (debug_mark+2),a  
5079 18 03			jr .pastdmark  
507b ..			.dmark: db "REe"  
507e f1			.pastdmark: pop af  
507f			endm  
# End of macro DMARK
507f						CALLMONITOR 
507f cd aa fd			call debug_vector  
5082				endm  
# End of macro CALLMONITOR
5082					endif 
5082 cd ca 20			call forth_push_str 
5085			 
5085					NEXTW 
5085 c3 09 24			jp macro_next 
5088				endm 
# End of macro NEXTW
5088			 
5088			.recnotfound: 
5088					if DEBUG_FORTH_WORDS 
5088						DMARK "REf" 
5088 f5				push af  
5089 3a 9d 50			ld a, (.dmark)  
508c 32 a6 fd			ld (debug_mark),a  
508f 3a 9e 50			ld a, (.dmark+1)  
5092 32 a7 fd			ld (debug_mark+1),a  
5095 3a 9f 50			ld a, (.dmark+2)  
5098 32 a8 fd			ld (debug_mark+2),a  
509b 18 03			jr .pastdmark  
509d ..			.dmark: db "REf"  
50a0 f1			.pastdmark: pop af  
50a1			endm  
# End of macro DMARK
50a1						CALLMONITOR 
50a1 cd aa fd			call debug_vector  
50a4				endm  
# End of macro CALLMONITOR
50a4					endif 
50a4 21 ff 00			ld hl, 255 
50a7 cd 5c 20			call forth_push_numhl 
50aa				NEXTW 
50aa c3 09 24			jp macro_next 
50ad				endm 
# End of macro NEXTW
50ad			 
50ad			 
50ad			.BREAD: 
50ad			  
50ad				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
50ad 3a				db WORD_SYS_CORE+38             
50ae 30 51			dw .BWRITE            
50b0 06				db 5 + 1 
50b1 .. 00			db "BREAD",0              
50b7				endm 
# End of macro CWHEAD
50b7			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
50b7			; | | > [!NOTE] 
50b7			; | | > Compatible with PicoSPINet  
50b7				 
50b7					if DEBUG_FORTH_WORDS_KEY 
50b7						DMARK "BRD" 
50b7 f5				push af  
50b8 3a cc 50			ld a, (.dmark)  
50bb 32 a6 fd			ld (debug_mark),a  
50be 3a cd 50			ld a, (.dmark+1)  
50c1 32 a7 fd			ld (debug_mark+1),a  
50c4 3a ce 50			ld a, (.dmark+2)  
50c7 32 a8 fd			ld (debug_mark+2),a  
50ca 18 03			jr .pastdmark  
50cc ..			.dmark: db "BRD"  
50cf f1			.pastdmark: pop af  
50d0			endm  
# End of macro DMARK
50d0						CALLMONITOR 
50d0 cd aa fd			call debug_vector  
50d3				endm  
# End of macro CALLMONITOR
50d3					endif 
50d3			 
50d3				FORTH_DSP_VALUEHL 
50d3 cd 53 22			call macro_dsp_valuehl 
50d6				endm 
# End of macro FORTH_DSP_VALUEHL
50d6			 
50d6				FORTH_DSP_POP 
50d6 cd 0b 23			call macro_forth_dsp_pop 
50d9				endm 
# End of macro FORTH_DSP_POP
50d9			 
50d9				; calc block address 
50d9			 
50d9 eb				ex de, hl 
50da 3e 40			ld a, STORE_BLOCK_PHY 
50dc cd 52 0f			call Mult16 
50df			 
50df			 
50df 11 b5 f9			ld de, store_page 
50e2			 
50e2					if DEBUG_FORTH_WORDS 
50e2						DMARK "BR1" 
50e2 f5				push af  
50e3 3a f7 50			ld a, (.dmark)  
50e6 32 a6 fd			ld (debug_mark),a  
50e9 3a f8 50			ld a, (.dmark+1)  
50ec 32 a7 fd			ld (debug_mark+1),a  
50ef 3a f9 50			ld a, (.dmark+2)  
50f2 32 a8 fd			ld (debug_mark+2),a  
50f5 18 03			jr .pastdmark  
50f7 ..			.dmark: db "BR1"  
50fa f1			.pastdmark: pop af  
50fb			endm  
# End of macro DMARK
50fb						CALLMONITOR 
50fb cd aa fd			call debug_vector  
50fe				endm  
# End of macro CALLMONITOR
50fe					endif 
50fe			 
50fe cd 65 04			call storage_read_block 
5101			 
5101 cd f8 0f			call ishlzero 
5104 20 05			jr nz, .brfound 
5106			 
5106 cd 5c 20			call forth_push_numhl 
5109 18 22			jr .brdone 
510b			 
510b			 
510b			.brfound: 
510b 21 b7 f9		        ld hl, store_page+2 
510e			 
510e					if DEBUG_FORTH_WORDS 
510e						DMARK "BR2" 
510e f5				push af  
510f 3a 23 51			ld a, (.dmark)  
5112 32 a6 fd			ld (debug_mark),a  
5115 3a 24 51			ld a, (.dmark+1)  
5118 32 a7 fd			ld (debug_mark+1),a  
511b 3a 25 51			ld a, (.dmark+2)  
511e 32 a8 fd			ld (debug_mark+2),a  
5121 18 03			jr .pastdmark  
5123 ..			.dmark: db "BR2"  
5126 f1			.pastdmark: pop af  
5127			endm  
# End of macro DMARK
5127						CALLMONITOR 
5127 cd aa fd			call debug_vector  
512a				endm  
# End of macro CALLMONITOR
512a					endif 
512a			 
512a cd ca 20			call forth_push_str 
512d			 
512d			 
512d			.brdone: 
512d			 
512d					NEXTW 
512d c3 09 24			jp macro_next 
5130				endm 
# End of macro NEXTW
5130			.BWRITE: 
5130				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
5130 3a				db WORD_SYS_CORE+38             
5131 c5 51			dw .BUPD            
5133 07				db 6 + 1 
5134 .. 00			db "BWRITE",0              
513b				endm 
# End of macro CWHEAD
513b			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
513b			; | | > [!NOTE] 
513b			; | | > Compatible with PicoSPINet  
513b			 
513b					if DEBUG_FORTH_WORDS_KEY 
513b						DMARK "BWR" 
513b f5				push af  
513c 3a 50 51			ld a, (.dmark)  
513f 32 a6 fd			ld (debug_mark),a  
5142 3a 51 51			ld a, (.dmark+1)  
5145 32 a7 fd			ld (debug_mark+1),a  
5148 3a 52 51			ld a, (.dmark+2)  
514b 32 a8 fd			ld (debug_mark+2),a  
514e 18 03			jr .pastdmark  
5150 ..			.dmark: db "BWR"  
5153 f1			.pastdmark: pop af  
5154			endm  
# End of macro DMARK
5154						CALLMONITOR 
5154 cd aa fd			call debug_vector  
5157				endm  
# End of macro CALLMONITOR
5157					endif 
5157			 
5157				FORTH_DSP_VALUEHL 
5157 cd 53 22			call macro_dsp_valuehl 
515a				endm 
# End of macro FORTH_DSP_VALUEHL
515a			 
515a				; calc block address 
515a			 
515a eb				ex de, hl 
515b 3e 40			ld a, STORE_BLOCK_PHY 
515d cd 52 0f			call Mult16 
5160			 
5160 e5				push hl         ; address 
5161			 
5161				FORTH_DSP_POP 
5161 cd 0b 23			call macro_forth_dsp_pop 
5164				endm 
# End of macro FORTH_DSP_POP
5164			 
5164				FORTH_DSP_VALUEHL 
5164 cd 53 22			call macro_dsp_valuehl 
5167				endm 
# End of macro FORTH_DSP_VALUEHL
5167			 
5167				FORTH_DSP_POP 
5167 cd 0b 23			call macro_forth_dsp_pop 
516a				endm 
# End of macro FORTH_DSP_POP
516a			 
516a cd a1 0c			call storage_clear_page 
516d			 
516d				; copy string to store page 
516d			 
516d e5				push hl     ; save string address 
516e			 
516e 3e 00			ld a, 0 
5170 cd 91 13			call strlent 
5173			 
5173 23				inc hl 
5174			 
5174 4d				ld c, l 
5175 06 00			ld b, 0 
5177			 
5177 e1				pop hl 
5178 11 b7 f9			ld de, store_page + 2 
517b					if DEBUG_FORTH_WORDS 
517b						DMARK "BW1" 
517b f5				push af  
517c 3a 90 51			ld a, (.dmark)  
517f 32 a6 fd			ld (debug_mark),a  
5182 3a 91 51			ld a, (.dmark+1)  
5185 32 a7 fd			ld (debug_mark+1),a  
5188 3a 92 51			ld a, (.dmark+2)  
518b 32 a8 fd			ld (debug_mark+2),a  
518e 18 03			jr .pastdmark  
5190 ..			.dmark: db "BW1"  
5193 f1			.pastdmark: pop af  
5194			endm  
# End of macro DMARK
5194						CALLMONITOR 
5194 cd aa fd			call debug_vector  
5197				endm  
# End of macro CALLMONITOR
5197					endif 
5197 ed b0			ldir 
5199			 
5199			 
5199				; poke the start of the block with flags to prevent high level file ops hitting the block 
5199			 
5199 21 ff ff			ld hl, $ffff 
519c			 
519c 22 b5 f9			ld (store_page), hl	 
519f				 
519f e1				pop hl    ; get address 
51a0 11 b5 f9			ld de, store_page 
51a3			 
51a3					if DEBUG_FORTH_WORDS 
51a3						DMARK "BW2" 
51a3 f5				push af  
51a4 3a b8 51			ld a, (.dmark)  
51a7 32 a6 fd			ld (debug_mark),a  
51aa 3a b9 51			ld a, (.dmark+1)  
51ad 32 a7 fd			ld (debug_mark+1),a  
51b0 3a ba 51			ld a, (.dmark+2)  
51b3 32 a8 fd			ld (debug_mark+2),a  
51b6 18 03			jr .pastdmark  
51b8 ..			.dmark: db "BW2"  
51bb f1			.pastdmark: pop af  
51bc			endm  
# End of macro DMARK
51bc						CALLMONITOR 
51bc cd aa fd			call debug_vector  
51bf				endm  
# End of macro CALLMONITOR
51bf					endif 
51bf			 
51bf cd ca 04			call storage_write_block 
51c2			 
51c2					NEXTW 
51c2 c3 09 24			jp macro_next 
51c5				endm 
# End of macro NEXTW
51c5			 
51c5			.BUPD: 
51c5				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
51c5 3a				db WORD_SYS_CORE+38             
51c6 1b 52			dw .BYID            
51c8 05				db 4 + 1 
51c9 .. 00			db "BUPD",0              
51ce				endm 
# End of macro CWHEAD
51ce			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
51ce			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
51ce			; | | or completely different file system structure. 
51ce			; | | > [!NOTE] 
51ce			; | | > Compatible with PicoSPINet  
51ce			 
51ce					if DEBUG_FORTH_WORDS_KEY 
51ce						DMARK "BUD" 
51ce f5				push af  
51cf 3a e3 51			ld a, (.dmark)  
51d2 32 a6 fd			ld (debug_mark),a  
51d5 3a e4 51			ld a, (.dmark+1)  
51d8 32 a7 fd			ld (debug_mark+1),a  
51db 3a e5 51			ld a, (.dmark+2)  
51de 32 a8 fd			ld (debug_mark+2),a  
51e1 18 03			jr .pastdmark  
51e3 ..			.dmark: db "BUD"  
51e6 f1			.pastdmark: pop af  
51e7			endm  
# End of macro DMARK
51e7						CALLMONITOR 
51e7 cd aa fd			call debug_vector  
51ea				endm  
# End of macro CALLMONITOR
51ea					endif 
51ea			 
51ea				FORTH_DSP_VALUEHL 
51ea cd 53 22			call macro_dsp_valuehl 
51ed				endm 
# End of macro FORTH_DSP_VALUEHL
51ed			 
51ed				; calc block address 
51ed			 
51ed eb				ex de, hl 
51ee 3e 40			ld a, STORE_BLOCK_PHY 
51f0 cd 52 0f			call Mult16 
51f3			 
51f3				FORTH_DSP_POP 
51f3 cd 0b 23			call macro_forth_dsp_pop 
51f6				endm 
# End of macro FORTH_DSP_POP
51f6			 
51f6			 
51f6 11 b5 f9			ld de, store_page 
51f9			 
51f9					if DEBUG_FORTH_WORDS 
51f9						DMARK "BUe" 
51f9 f5				push af  
51fa 3a 0e 52			ld a, (.dmark)  
51fd 32 a6 fd			ld (debug_mark),a  
5200 3a 0f 52			ld a, (.dmark+1)  
5203 32 a7 fd			ld (debug_mark+1),a  
5206 3a 10 52			ld a, (.dmark+2)  
5209 32 a8 fd			ld (debug_mark+2),a  
520c 18 03			jr .pastdmark  
520e ..			.dmark: db "BUe"  
5211 f1			.pastdmark: pop af  
5212			endm  
# End of macro DMARK
5212						CALLMONITOR 
5212 cd aa fd			call debug_vector  
5215				endm  
# End of macro CALLMONITOR
5215					endif 
5215			 
5215 cd ca 04			call storage_write_block 
5218			 
5218					NEXTW 
5218 c3 09 24			jp macro_next 
521b				endm 
# End of macro NEXTW
521b			 
521b			.BYID: 
521b			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
521b			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
521b			; 
521b			;		 
521b			;		if DEBUG_FORTH_WORDS_KEY 
521b			;			DMARK "BYID" 
521b			;			CALLMONITOR 
521b			;		endif 
521b			; 
521b			;		; get direct address 
521b			; 
521b			;		FORTH_DSP_VALUEHL 
521b			; 
521b			;		FORTH_DSP_POP 
521b			; 
521b			;	; calc block address 
521b			; 
521b			;	ex de, hl 
521b			;	ld a, STORE_BLOCK_PHY 
521b			;	call Mult16 
521b			;	;	do BREAD with number as param 
521b			;	; push the file name	 
521b			;	ld de, store_page 
521b			;	call storage_read_block 
521b			 ;       ld hl, store_page+2 
521b			; 
521b			; 
521b			;		NEXTW 
521b			;.BYNAME: 
521b				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
521b 3a				db WORD_SYS_CORE+38             
521c 34 52			dw .DIR            
521e 06				db 5 + 1 
521f .. 00			db "GETID",0              
5225				endm 
# End of macro CWHEAD
5225			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
5225			; | | > [!NOTE] 
5225			; | | > Compatible with PicoSPINet  
5225			 
5225					; get pointer to file name to seek 
5225			 
5225					FORTH_DSP_VALUEHL 
5225 cd 53 22			call macro_dsp_valuehl 
5228				endm 
# End of macro FORTH_DSP_VALUEHL
5228			 
5228			 
5228 cd 8c 03				call storage_getid  
522b			 
522b					FORTH_DSP_POP 
522b cd 0b 23			call macro_forth_dsp_pop 
522e				endm 
# End of macro FORTH_DSP_POP
522e			 
522e cd 5c 20				call forth_push_numhl 
5231			 
5231					NEXTW 
5231 c3 09 24			jp macro_next 
5234				endm 
# End of macro NEXTW
5234			; 
5234			.DIR: 
5234				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
5234 3a				db WORD_SYS_CORE+38             
5235 38 53			dw .SAVE            
5237 04				db 3 + 1 
5238 .. 00			db "DIR",0              
523c				endm 
# End of macro CWHEAD
523c			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
523c			; | | > [!NOTE] 
523c			; | | > Compatible with PicoSPINet  
523c			 
523c					if DEBUG_FORTH_WORDS_KEY 
523c						DMARK "DIR" 
523c f5				push af  
523d 3a 51 52			ld a, (.dmark)  
5240 32 a6 fd			ld (debug_mark),a  
5243 3a 52 52			ld a, (.dmark+1)  
5246 32 a7 fd			ld (debug_mark+1),a  
5249 3a 53 52			ld a, (.dmark+2)  
524c 32 a8 fd			ld (debug_mark+2),a  
524f 18 03			jr .pastdmark  
5251 ..			.dmark: db "DIR"  
5254 f1			.pastdmark: pop af  
5255			endm  
# End of macro DMARK
5255						CALLMONITOR 
5255 cd aa fd			call debug_vector  
5258				endm  
# End of macro CALLMONITOR
5258					endif 
5258 cd 16 05			call storage_get_block_0 
525b			 
525b 21 b5 f9			ld hl, store_page     ; get current id count 
525e 46				ld b, (hl) 
525f 0e 00			ld c, 0    ; count of files   
5261					if DEBUG_FORTH_WORDS 
5261						DMARK "DI1" 
5261 f5				push af  
5262 3a 76 52			ld a, (.dmark)  
5265 32 a6 fd			ld (debug_mark),a  
5268 3a 77 52			ld a, (.dmark+1)  
526b 32 a7 fd			ld (debug_mark+1),a  
526e 3a 78 52			ld a, (.dmark+2)  
5271 32 a8 fd			ld (debug_mark+2),a  
5274 18 03			jr .pastdmark  
5276 ..			.dmark: db "DI1"  
5279 f1			.pastdmark: pop af  
527a			endm  
# End of macro DMARK
527a						CALLMONITOR 
527a cd aa fd			call debug_vector  
527d				endm  
# End of macro CALLMONITOR
527d					endif 
527d			 
527d				; check for empty drive 
527d			 
527d 3e 00			ld a, 0 
527f b8				cp b 
5280 ca ee 52			jp z, .dirdone 
5283			 
5283				; for each of the current ids do a search for them and if found push to stack 
5283			 
5283 c5			.diritem:	push bc 
5284 21 40 00				ld hl, STORE_BLOCK_PHY 
5287 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
5289 58					ld e,b 
528a			 
528a			;		if DEBUG_FORTH_WORDS 
528a			;			DMARK "DI2" 
528a			;			CALLMONITOR 
528a			;		endif 
528a			 
528a cd 98 07				call storage_findnextid 
528d			 
528d			;		if DEBUG_FORTH_WORDS 
528d			;			DMARK "DI3" 
528d			;			CALLMONITOR 
528d			;		endif 
528d			 
528d					; if found hl will be non zero 
528d			 
528d cd f8 0f				call ishlzero 
5290			;		ld a, l 
5290			;		add h 
5290			; 
5290			;		cp 0 
5290 28 59				jr z, .dirnotfound 
5292			 
5292					; increase count 
5292			 
5292 c1					pop bc	 
5293 0c					inc c 
5294 c5					push bc 
5295					 
5295			 
5295					; get file header and push the file name 
5295			 
5295 11 b5 f9				ld de, store_page 
5298 cd 65 04				call storage_read_block 
529b			 
529b					; push file id to stack 
529b				 
529b 3a b5 f9				ld a, (store_page) 
529e 26 00				ld h, 0 
52a0 6f					ld l, a 
52a1 cd 5c 20				call forth_push_numhl 
52a4			 
52a4					; push extent count to stack  
52a4				 
52a4 3a b7 f9				ld a, (store_page+2) 
52a7 26 00				ld h, 0 
52a9 6f					ld l, a 
52aa cd 5c 20				call forth_push_numhl 
52ad			 
52ad					; push file name 
52ad			 
52ad 21 b8 f9				ld hl, store_page+3 
52b0					if DEBUG_FORTH_WORDS 
52b0						DMARK "DI5" 
52b0 f5				push af  
52b1 3a c5 52			ld a, (.dmark)  
52b4 32 a6 fd			ld (debug_mark),a  
52b7 3a c6 52			ld a, (.dmark+1)  
52ba 32 a7 fd			ld (debug_mark+1),a  
52bd 3a c7 52			ld a, (.dmark+2)  
52c0 32 a8 fd			ld (debug_mark+2),a  
52c3 18 03			jr .pastdmark  
52c5 ..			.dmark: db "DI5"  
52c8 f1			.pastdmark: pop af  
52c9			endm  
# End of macro DMARK
52c9						CALLMONITOR 
52c9 cd aa fd			call debug_vector  
52cc				endm  
# End of macro CALLMONITOR
52cc					endif 
52cc cd ca 20				call forth_push_str 
52cf					if DEBUG_FORTH_WORDS 
52cf						DMARK "DI6" 
52cf f5				push af  
52d0 3a e4 52			ld a, (.dmark)  
52d3 32 a6 fd			ld (debug_mark),a  
52d6 3a e5 52			ld a, (.dmark+1)  
52d9 32 a7 fd			ld (debug_mark+1),a  
52dc 3a e6 52			ld a, (.dmark+2)  
52df 32 a8 fd			ld (debug_mark+2),a  
52e2 18 03			jr .pastdmark  
52e4 ..			.dmark: db "DI6"  
52e7 f1			.pastdmark: pop af  
52e8			endm  
# End of macro DMARK
52e8						CALLMONITOR 
52e8 cd aa fd			call debug_vector  
52eb				endm  
# End of macro CALLMONITOR
52eb					endif 
52eb			.dirnotfound: 
52eb c1					pop bc     
52ec 10 95				djnz .diritem 
52ee				 
52ee			.dirdone:	 
52ee					if DEBUG_FORTH_WORDS 
52ee						DMARK "DI7" 
52ee f5				push af  
52ef 3a 03 53			ld a, (.dmark)  
52f2 32 a6 fd			ld (debug_mark),a  
52f5 3a 04 53			ld a, (.dmark+1)  
52f8 32 a7 fd			ld (debug_mark+1),a  
52fb 3a 05 53			ld a, (.dmark+2)  
52fe 32 a8 fd			ld (debug_mark+2),a  
5301 18 03			jr .pastdmark  
5303 ..			.dmark: db "DI7"  
5306 f1			.pastdmark: pop af  
5307			endm  
# End of macro DMARK
5307						CALLMONITOR 
5307 cd aa fd			call debug_vector  
530a				endm  
# End of macro CALLMONITOR
530a					endif 
530a			 
530a					; push a count of the dir items found 
530a			 
530a 26 00				ld h, 0 
530c 69					ld l, c 
530d cd 5c 20				call forth_push_numhl 
5310			 
5310					; push the bank label 
5310			 
5310 cd 16 05				call storage_get_block_0 
5313			 
5313				 
5313 21 b8 f9		 		ld hl, store_page+3 
5316			 
5316					if DEBUG_FORTH_WORDS 
5316						DMARK "DI8" 
5316 f5				push af  
5317 3a 2b 53			ld a, (.dmark)  
531a 32 a6 fd			ld (debug_mark),a  
531d 3a 2c 53			ld a, (.dmark+1)  
5320 32 a7 fd			ld (debug_mark+1),a  
5323 3a 2d 53			ld a, (.dmark+2)  
5326 32 a8 fd			ld (debug_mark+2),a  
5329 18 03			jr .pastdmark  
532b ..			.dmark: db "DI8"  
532e f1			.pastdmark: pop af  
532f			endm  
# End of macro DMARK
532f						CALLMONITOR 
532f cd aa fd			call debug_vector  
5332				endm  
# End of macro CALLMONITOR
5332					endif 
5332 cd ca 20				call forth_push_str 
5335			 
5335			 
5335				 
5335					NEXTW 
5335 c3 09 24			jp macro_next 
5338				endm 
# End of macro NEXTW
5338			.SAVE: 
5338			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
5338			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
5338			;		NEXTW 
5338			;.LOAD: 
5338			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
5338			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
5338			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
5338			;; > > The LOAD command can not be used in any user words or compound lines. 
5338			; 
5338			;		; store_openext use it. If zero it is EOF 
5338			; 
5338			;		; read block from current stream id 
5338			;		; if the block does not contain zero term keep reading blocks until zero found 
5338			;		; push the block to stack 
5338			;		; save the block id to stream 
5338			; 
5338			; 
5338			;		FORTH_DSP_VALUEHL 
5338			; 
5338			;;		push hl 
5338			; 
5338			;	if DEBUG_STORESE 
5338			;		DMARK "LOA" 
5338			;		CALLMONITOR 
5338			;	endif 
5338			;		FORTH_DSP_POP 
5338			; 
5338			;;		pop hl 
5338			; 
5338			;		ld h, l 
5338			;		ld l, 0 
5338			; 
5338			;		push hl     ; stack holds current file id and extent to work with 
5338			; 
5338			; 
5338			;		ld de, store_page      ; get block zero of file 
5338			;	if DEBUG_STORESE 
5338			;		DMARK "LO0" 
5338			;		CALLMONITOR 
5338			;	endif 
5338			;		call storage_read 
5338			; 
5338			;		ld a, (store_page+2)    ; max extents for this file 
5338			;		ld  (store_openmaxext),a   ; get our limit 
5338			; 
5338			;	if DEBUG_STORESE 
5338			;		DMARK "LOE" 
5338			;		CALLMONITOR 
5338			;	endif 
5338			; 
5338			;; TODO dont know why max extents are not present 
5338			;;		cp 0 
5338			;;		jp z, .loadeof     ; dont read past eof 
5338			; 
5338			;;		ld a, 1   ; start from the head of the file 
5338			; 
5338			;.loadline:	pop hl 
5338			;		inc hl 
5338			;		ld  a, (store_openmaxext)   ; get our limit 
5338			;	if DEBUG_STORESE 
5338			;		DMARK "LOx" 
5338			;		CALLMONITOR 
5338			;	endif 
5338			;		inc a 
5338			;		cp l 
5338			;		jp z, .loadeof 
5338			;		push hl    ; save current extent 
5338			; 
5338			;		ld de, store_page 
5338			; 
5338			;	if DEBUG_STORESE 
5338			;		DMARK "LO1" 
5338			;		CALLMONITOR 
5338			;	endif 
5338			;		call storage_read 
5338			; 
5338			;	if DEBUG_STORESE 
5338			;		DMARK "LO2" 
5338			;		CALLMONITOR 
5338			;	endif 
5338			;	call ishlzero 
5338			;	ld a, l 
5338			;	add h 
5338			;	cp 0 
5338			;	jr z, .loadeof 
5338			; 
5338			;	; not eof so hl should point to data to exec 
5338			; 
5338			;	; will need to add the FORTH_END_BUFFER flag 
5338			 ; 
5338			;	ld hl, store_page+2 
5338			;	ld bc, 255 
5338			;	ld a, 0 
5338			;	cpir 
5338			;	if DEBUG_STORESE 
5338			;		DMARK "LOt" 
5338			;		CALLMONITOR 
5338			;	endif 
5338			;	dec hl 
5338			;	ld a, ' ' 
5338			;	ld (hl), a 
5338			;	inc hl 
5338			;	ld (hl), a 
5338			;	inc hl 
5338			;	ld (hl), a 
5338			;	inc hl 
5338			;	ld a, FORTH_END_BUFFER 
5338			;	ld (hl), a 
5338			; 
5338			;	; TODO handle more than a single block read 
5338			; 
5338			; 
5338			;	ld hl, store_page+2 
5338			; 
5338			;	ld (os_tok_ptr), hl 
5338			; 
5338			;	if DEBUG_STORESE 
5338			;		DMARK "LO3" 
5338			;		CALLMONITOR 
5338			;	endif 
5338			; 
5338			;	call forthparse 
5338			;	call forthexec 
5338			;	call forthexec_cleanup 
5338			; 
5338			;	; go to next extent 
5338			; 
5338			;	; get next block  or mark as eof 
5338			;	jp .loadline 
5338			; 
5338			; 
5338			; 
5338			;	       NEXTW 
5338			;.loadeof:	ld a, 0 
5338			;		ld (store_openext), a 
5338			; 
5338			;	if DEBUG_STORESE 
5338			;		DMARK "LOF" 
5338			;		CALLMONITOR 
5338			;	endif 
5338			;		ret 
5338			;		;NEXTW 
5338			;.BSAVE:   
5338			; 
5338			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
5338			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
5338			;		NEXTW 
5338			;.BLOAD: 
5338			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
5338			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
5338			;		NEXTW 
5338			;;;; counter gap 
5338			 
5338			 
5338			.SEO: 
5338				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
5338 64				db WORD_SYS_CORE+80             
5339 57 53			dw .SEI            
533b 04				db 3 + 1 
533c .. 00			db "SEO",0              
5340				endm 
# End of macro CWHEAD
5340			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
5340			 
5340					; get port 
5340			 
5340					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5340 cd 53 22			call macro_dsp_valuehl 
5343				endm 
# End of macro FORTH_DSP_VALUEHL
5343			 
5343 e5					push hl    ; u2 - byte 
5344			 
5344					; destroy value TOS 
5344			 
5344					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5344 cd 0b 23			call macro_forth_dsp_pop 
5347				endm 
# End of macro FORTH_DSP_POP
5347			 
5347					; get byte to send 
5347			 
5347					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5347 cd 53 22			call macro_dsp_valuehl 
534a				endm 
# End of macro FORTH_DSP_VALUEHL
534a			 
534a e5					push hl    ; u1 - addr 
534b			 
534b					; destroy value TOS 
534b			 
534b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
534b cd 0b 23			call macro_forth_dsp_pop 
534e				endm 
# End of macro FORTH_DSP_POP
534e			 
534e					; one value on hl get other one back 
534e			 
534e d1					pop de   ; u1 - byte 
534f			 
534f e1					pop hl   ; u2 - addr 
5350			 
5350					; TODO Send SPI byte 
5350			 
5350			 
5350 7b					ld a, e 
5351 cd 6a 02				call se_writebyte 
5354			 
5354					 
5354			 
5354					NEXTW 
5354 c3 09 24			jp macro_next 
5357				endm 
# End of macro NEXTW
5357			 
5357			.SEI: 
5357				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
5357 65				db WORD_SYS_CORE+81             
5358 71 53			dw .SFREE            
535a 04				db 3 + 1 
535b .. 00			db "SEI",0              
535f				endm 
# End of macro CWHEAD
535f			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
535f			 
535f					; get port 
535f			 
535f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
535f cd 53 22			call macro_dsp_valuehl 
5362				endm 
# End of macro FORTH_DSP_VALUEHL
5362			 
5362			;		push hl 
5362			 
5362					; destroy value TOS 
5362			 
5362					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5362 cd 0b 23			call macro_forth_dsp_pop 
5365				endm 
# End of macro FORTH_DSP_POP
5365			 
5365					; one value on hl get other one back 
5365			 
5365			;		pop hl 
5365			 
5365			 
5365					; TODO Get SPI byte 
5365			 
5365 cd 0c 03				call se_readbyte 
5368			 
5368 26 00				ld h, 0 
536a 6f					ld l, a 
536b cd 5c 20				call forth_push_numhl 
536e			 
536e					NEXTW 
536e c3 09 24			jp macro_next 
5371				endm 
# End of macro NEXTW
5371			 
5371			.SFREE: 
5371				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
5371 67				db WORD_SYS_CORE+83             
5372 a0 53			dw .SIZE            
5374 06				db 5 + 1 
5375 .. 00			db "FFREE",0              
537b				endm 
# End of macro CWHEAD
537b			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
537b			; | | > [!NOTE] 
537b			; | | > Compatible with PicoSPINet  
537b					if DEBUG_FORTH_WORDS_KEY 
537b						DMARK "FFR" 
537b f5				push af  
537c 3a 90 53			ld a, (.dmark)  
537f 32 a6 fd			ld (debug_mark),a  
5382 3a 91 53			ld a, (.dmark+1)  
5385 32 a7 fd			ld (debug_mark+1),a  
5388 3a 92 53			ld a, (.dmark+2)  
538b 32 a8 fd			ld (debug_mark+2),a  
538e 18 03			jr .pastdmark  
5390 ..			.dmark: db "FFR"  
5393 f1			.pastdmark: pop af  
5394			endm  
# End of macro DMARK
5394						CALLMONITOR 
5394 cd aa fd			call debug_vector  
5397				endm  
# End of macro CALLMONITOR
5397					endif 
5397			 
5397 cd 32 08				call storage_freeblocks 
539a			 
539a cd 5c 20				call forth_push_numhl 
539d			 
539d				       NEXTW 
539d c3 09 24			jp macro_next 
53a0				endm 
# End of macro NEXTW
53a0			.SIZE: 
53a0				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
53a0 67				db WORD_SYS_CORE+83             
53a1 d4 53			dw .CREATE            
53a3 05				db 4 + 1 
53a4 .. 00			db "SIZE",0              
53a9				endm 
# End of macro CWHEAD
53a9			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
53a9			; | | > [!NOTE] 
53a9			; | | > Compatible with PicoSPINet  
53a9					if DEBUG_FORTH_WORDS_KEY 
53a9						DMARK "SIZ" 
53a9 f5				push af  
53aa 3a be 53			ld a, (.dmark)  
53ad 32 a6 fd			ld (debug_mark),a  
53b0 3a bf 53			ld a, (.dmark+1)  
53b3 32 a7 fd			ld (debug_mark+1),a  
53b6 3a c0 53			ld a, (.dmark+2)  
53b9 32 a8 fd			ld (debug_mark+2),a  
53bc 18 03			jr .pastdmark  
53be ..			.dmark: db "SIZ"  
53c1 f1			.pastdmark: pop af  
53c2			endm  
# End of macro DMARK
53c2						CALLMONITOR 
53c2 cd aa fd			call debug_vector  
53c5				endm  
# End of macro CALLMONITOR
53c5					endif 
53c5			 
53c5					FORTH_DSP_VALUEHL 
53c5 cd 53 22			call macro_dsp_valuehl 
53c8				endm 
# End of macro FORTH_DSP_VALUEHL
53c8			;		push hl 
53c8					FORTH_DSP_POP 
53c8 cd 0b 23			call macro_forth_dsp_pop 
53cb				endm 
# End of macro FORTH_DSP_POP
53cb			;		pop hl 
53cb cd 94 04				call storage_file_size 
53ce			 
53ce cd 5c 20				call forth_push_numhl 
53d1			  
53d1			 
53d1				       NEXTW 
53d1 c3 09 24			jp macro_next 
53d4				endm 
# End of macro NEXTW
53d4			 
53d4			.CREATE: 
53d4				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
53d4 68				db WORD_SYS_CORE+84             
53d5 42 54			dw .APPEND            
53d7 07				db 6 + 1 
53d8 .. 00			db "CREATE",0              
53df				endm 
# End of macro CWHEAD
53df			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
53df			; | | e.g.  
53df			; | | TestProgram CREATE 
53df			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
53df			; | |  
53df			; | | Max file IDs are 255. 
53df			; | |  
53df			; | | > [!NOTE] 
53df			; | | > Compatible with PicoSPINet  
53df					 
53df					if DEBUG_FORTH_WORDS_KEY 
53df						DMARK "CRT" 
53df f5				push af  
53e0 3a f4 53			ld a, (.dmark)  
53e3 32 a6 fd			ld (debug_mark),a  
53e6 3a f5 53			ld a, (.dmark+1)  
53e9 32 a7 fd			ld (debug_mark+1),a  
53ec 3a f6 53			ld a, (.dmark+2)  
53ef 32 a8 fd			ld (debug_mark+2),a  
53f2 18 03			jr .pastdmark  
53f4 ..			.dmark: db "CRT"  
53f7 f1			.pastdmark: pop af  
53f8			endm  
# End of macro DMARK
53f8						CALLMONITOR 
53f8 cd aa fd			call debug_vector  
53fb				endm  
# End of macro CALLMONITOR
53fb					endif 
53fb			;		call storage_get_block_0 
53fb			 
53fb					; TODO pop hl 
53fb			 
53fb					;v5 FORTH_DSP_VALUE 
53fb					FORTH_DSP_VALUE 
53fb cd 3c 22			call macro_forth_dsp_value 
53fe				endm 
# End of macro FORTH_DSP_VALUE
53fe			 
53fe				if DEBUG_STORESE 
53fe					DMARK "CR1" 
53fe f5				push af  
53ff 3a 13 54			ld a, (.dmark)  
5402 32 a6 fd			ld (debug_mark),a  
5405 3a 14 54			ld a, (.dmark+1)  
5408 32 a7 fd			ld (debug_mark+1),a  
540b 3a 15 54			ld a, (.dmark+2)  
540e 32 a8 fd			ld (debug_mark+2),a  
5411 18 03			jr .pastdmark  
5413 ..			.dmark: db "CR1"  
5416 f1			.pastdmark: pop af  
5417			endm  
# End of macro DMARK
5417					CALLMONITOR 
5417 cd aa fd			call debug_vector  
541a				endm  
# End of macro CALLMONITOR
541a				endif 
541a			;		push hl 
541a			;		FORTH_DSP_POP 
541a			;		pop hl 
541a			 
541a			;		inc hl   ; move past the type marker 
541a			 
541a cd 68 08				call storage_create 
541d			 
541d				if DEBUG_STORESE 
541d					DMARK "CT1" 
541d f5				push af  
541e 3a 32 54			ld a, (.dmark)  
5421 32 a6 fd			ld (debug_mark),a  
5424 3a 33 54			ld a, (.dmark+1)  
5427 32 a7 fd			ld (debug_mark+1),a  
542a 3a 34 54			ld a, (.dmark+2)  
542d 32 a8 fd			ld (debug_mark+2),a  
5430 18 03			jr .pastdmark  
5432 ..			.dmark: db "CT1"  
5435 f1			.pastdmark: pop af  
5436			endm  
# End of macro DMARK
5436					CALLMONITOR 
5436 cd aa fd			call debug_vector  
5439				endm  
# End of macro CALLMONITOR
5439				endif 
5439			;		push hl 
5439					FORTH_DSP_POP 
5439 cd 0b 23			call macro_forth_dsp_pop 
543c				endm 
# End of macro FORTH_DSP_POP
543c			;		pop hl 
543c					; push file id to stack 
543c cd 5c 20				call forth_push_numhl 
543f			 
543f			 
543f			 
543f				       NEXTW 
543f c3 09 24			jp macro_next 
5442				endm 
# End of macro NEXTW
5442			 
5442			.APPEND: 
5442				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
5442 69				db WORD_SYS_CORE+85             
5443 d3 54			dw .SDEL            
5445 07				db 6 + 1 
5446 .. 00			db "APPEND",0              
544d				endm 
# End of macro CWHEAD
544d			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
544d			; | | e.g. 
544d			; | | Test CREATE      -> $01 
544d			; | | "A string to add to file" $01 APPEND 
544d			; | |  
544d			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
544d			; | | > [!NOTE] 
544d			; | | > Compatible with PicoSPINet  
544d					if DEBUG_FORTH_WORDS_KEY 
544d						DMARK "APP" 
544d f5				push af  
544e 3a 62 54			ld a, (.dmark)  
5451 32 a6 fd			ld (debug_mark),a  
5454 3a 63 54			ld a, (.dmark+1)  
5457 32 a7 fd			ld (debug_mark+1),a  
545a 3a 64 54			ld a, (.dmark+2)  
545d 32 a8 fd			ld (debug_mark+2),a  
5460 18 03			jr .pastdmark  
5462 ..			.dmark: db "APP"  
5465 f1			.pastdmark: pop af  
5466			endm  
# End of macro DMARK
5466						CALLMONITOR 
5466 cd aa fd			call debug_vector  
5469				endm  
# End of macro CALLMONITOR
5469					endif 
5469			 
5469					FORTH_DSP_VALUEHL 
5469 cd 53 22			call macro_dsp_valuehl 
546c				endm 
# End of macro FORTH_DSP_VALUEHL
546c e5					push hl 	; save file id 
546d			 
546d				if DEBUG_STORESE 
546d					DMARK "AP1" 
546d f5				push af  
546e 3a 82 54			ld a, (.dmark)  
5471 32 a6 fd			ld (debug_mark),a  
5474 3a 83 54			ld a, (.dmark+1)  
5477 32 a7 fd			ld (debug_mark+1),a  
547a 3a 84 54			ld a, (.dmark+2)  
547d 32 a8 fd			ld (debug_mark+2),a  
5480 18 03			jr .pastdmark  
5482 ..			.dmark: db "AP1"  
5485 f1			.pastdmark: pop af  
5486			endm  
# End of macro DMARK
5486					CALLMONITOR 
5486 cd aa fd			call debug_vector  
5489				endm  
# End of macro CALLMONITOR
5489				endif 
5489					FORTH_DSP_POP 
5489 cd 0b 23			call macro_forth_dsp_pop 
548c				endm 
# End of macro FORTH_DSP_POP
548c			 
548c					FORTH_DSP_VALUEHL 
548c cd 53 22			call macro_dsp_valuehl 
548f				endm 
# End of macro FORTH_DSP_VALUEHL
548f					;v5 FORTH_DSP_VALUE 
548f e5					push hl 	; save ptr to string to save 
5490			 
5490				if DEBUG_STORESE 
5490					DMARK "AP1" 
5490 f5				push af  
5491 3a a5 54			ld a, (.dmark)  
5494 32 a6 fd			ld (debug_mark),a  
5497 3a a6 54			ld a, (.dmark+1)  
549a 32 a7 fd			ld (debug_mark+1),a  
549d 3a a7 54			ld a, (.dmark+2)  
54a0 32 a8 fd			ld (debug_mark+2),a  
54a3 18 03			jr .pastdmark  
54a5 ..			.dmark: db "AP1"  
54a8 f1			.pastdmark: pop af  
54a9			endm  
# End of macro DMARK
54a9					CALLMONITOR 
54a9 cd aa fd			call debug_vector  
54ac				endm  
# End of macro CALLMONITOR
54ac				endif 
54ac					FORTH_DSP_POP 
54ac cd 0b 23			call macro_forth_dsp_pop 
54af				endm 
# End of macro FORTH_DSP_POP
54af			 
54af d1					pop de 
54b0 e1					pop hl 
54b1				if DEBUG_STORESE 
54b1					DMARK "AP2" 
54b1 f5				push af  
54b2 3a c6 54			ld a, (.dmark)  
54b5 32 a6 fd			ld (debug_mark),a  
54b8 3a c7 54			ld a, (.dmark+1)  
54bb 32 a7 fd			ld (debug_mark+1),a  
54be 3a c8 54			ld a, (.dmark+2)  
54c1 32 a8 fd			ld (debug_mark+2),a  
54c4 18 03			jr .pastdmark  
54c6 ..			.dmark: db "AP2"  
54c9 f1			.pastdmark: pop af  
54ca			endm  
# End of macro DMARK
54ca					CALLMONITOR 
54ca cd aa fd			call debug_vector  
54cd				endm  
# End of macro CALLMONITOR
54cd				endif 
54cd					;inc de ; skip var type indicator 
54cd			 
54cd					; TODO how to append numerics???? 
54cd			 
54cd cd 55 0b				call storage_append		 
54d0			 
54d0				       NEXTW 
54d0 c3 09 24			jp macro_next 
54d3				endm 
# End of macro NEXTW
54d3			.SDEL: 
54d3				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
54d3 6a				db WORD_SYS_CORE+86             
54d4 1f 55			dw .OPEN            
54d6 05				db 4 + 1 
54d7 .. 00			db "ERA",0              
54db				endm 
# End of macro CWHEAD
54db			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
54db			; | | > [!NOTE] 
54db			; | | > Compatible with PicoSPINet  
54db					FORTH_DSP_VALUEHL 
54db cd 53 22			call macro_dsp_valuehl 
54de				endm 
# End of macro FORTH_DSP_VALUEHL
54de			;		push hl 	; save file id 
54de			 
54de					if DEBUG_FORTH_WORDS_KEY 
54de						DMARK "ERA" 
54de f5				push af  
54df 3a f3 54			ld a, (.dmark)  
54e2 32 a6 fd			ld (debug_mark),a  
54e5 3a f4 54			ld a, (.dmark+1)  
54e8 32 a7 fd			ld (debug_mark+1),a  
54eb 3a f5 54			ld a, (.dmark+2)  
54ee 32 a8 fd			ld (debug_mark+2),a  
54f1 18 03			jr .pastdmark  
54f3 ..			.dmark: db "ERA"  
54f6 f1			.pastdmark: pop af  
54f7			endm  
# End of macro DMARK
54f7						CALLMONITOR 
54f7 cd aa fd			call debug_vector  
54fa				endm  
# End of macro CALLMONITOR
54fa					endif 
54fa				if DEBUG_STORESE 
54fa					DMARK "ER1" 
54fa f5				push af  
54fb 3a 0f 55			ld a, (.dmark)  
54fe 32 a6 fd			ld (debug_mark),a  
5501 3a 10 55			ld a, (.dmark+1)  
5504 32 a7 fd			ld (debug_mark+1),a  
5507 3a 11 55			ld a, (.dmark+2)  
550a 32 a8 fd			ld (debug_mark+2),a  
550d 18 03			jr .pastdmark  
550f ..			.dmark: db "ER1"  
5512 f1			.pastdmark: pop af  
5513			endm  
# End of macro DMARK
5513					CALLMONITOR 
5513 cd aa fd			call debug_vector  
5516				endm  
# End of macro CALLMONITOR
5516				endif 
5516					FORTH_DSP_POP 
5516 cd 0b 23			call macro_forth_dsp_pop 
5519				endm 
# End of macro FORTH_DSP_POP
5519			 
5519			;		pop hl 
5519			 
5519 cd a7 06				call storage_erase 
551c				       NEXTW 
551c c3 09 24			jp macro_next 
551f				endm 
# End of macro NEXTW
551f			 
551f			.OPEN: 
551f				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
551f 6b				db WORD_SYS_CORE+87             
5520 b3 55			dw .READ            
5522 05				db 4 + 1 
5523 .. 00			db "OPEN",0              
5528				endm 
# End of macro CWHEAD
5528			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
5528			; | | e.g. 
5528			; | | $01 OPEN $01 DO $01 READ . LOOP 
5528			; | | 
5528			; | | Will return with 255 blocks if the file does not exist 
5528			; | | > [!NOTE] 
5528			; | | > Compatible with PicoSPINet  
5528			 
5528					if DEBUG_FORTH_WORDS_KEY 
5528						DMARK "OPN" 
5528 f5				push af  
5529 3a 3d 55			ld a, (.dmark)  
552c 32 a6 fd			ld (debug_mark),a  
552f 3a 3e 55			ld a, (.dmark+1)  
5532 32 a7 fd			ld (debug_mark+1),a  
5535 3a 3f 55			ld a, (.dmark+2)  
5538 32 a8 fd			ld (debug_mark+2),a  
553b 18 03			jr .pastdmark  
553d ..			.dmark: db "OPN"  
5540 f1			.pastdmark: pop af  
5541			endm  
# End of macro DMARK
5541						CALLMONITOR 
5541 cd aa fd			call debug_vector  
5544				endm  
# End of macro CALLMONITOR
5544					endif 
5544					; TODO handle multiple file opens 
5544			 
5544 3e 01			       	ld a, 1 
5546 32 a5 f9				ld (store_openext), a 
5549			 
5549					; get max extents for this file 
5549				 
5549								 
5549					FORTH_DSP_VALUEHL 
5549 cd 53 22			call macro_dsp_valuehl 
554c				endm 
# End of macro FORTH_DSP_VALUEHL
554c			 
554c 65					ld h, l 
554d 2e 00				ld l, 0 
554f			 
554f					; store file id 
554f			 
554f 7c					ld a, h 
5550 32 a2 f9				ld (store_filecache), a 
5553			 
5553				if DEBUG_STORESE 
5553					DMARK "OPN" 
5553 f5				push af  
5554 3a 68 55			ld a, (.dmark)  
5557 32 a6 fd			ld (debug_mark),a  
555a 3a 69 55			ld a, (.dmark+1)  
555d 32 a7 fd			ld (debug_mark+1),a  
5560 3a 6a 55			ld a, (.dmark+2)  
5563 32 a8 fd			ld (debug_mark+2),a  
5566 18 03			jr .pastdmark  
5568 ..			.dmark: db "OPN"  
556b f1			.pastdmark: pop af  
556c			endm  
# End of macro DMARK
556c					CALLMONITOR 
556c cd aa fd			call debug_vector  
556f				endm  
# End of macro CALLMONITOR
556f				endif 
556f			;		push hl 
556f					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
556f cd 0b 23			call macro_forth_dsp_pop 
5572				endm 
# End of macro FORTH_DSP_POP
5572			;		pop hl 
5572						 
5572 11 b5 f9				ld de, store_page      ; get block zero of file 
5575 cd be 09				call storage_read 
5578 cd f8 0f			call ishlzero 
557b 20 04			jr nz, .opfound 
557d			 
557d				; file does not exist so indicate with 255 extents in use 
557d			 
557d 3e ff			ld a, 255 
557f 18 29			jr .skipopeneof 
5581			 
5581			 
5581			.opfound: 
5581			 
5581			 
5581 3a b7 f9				ld a, (store_page+2)    ; max extents for this file 
5584 32 a4 f9				ld  (store_openmaxext), a   ; get our limit and push 
5587					 
5587				if DEBUG_STORESE 
5587					DMARK "OPx" 
5587 f5				push af  
5588 3a 9c 55			ld a, (.dmark)  
558b 32 a6 fd			ld (debug_mark),a  
558e 3a 9d 55			ld a, (.dmark+1)  
5591 32 a7 fd			ld (debug_mark+1),a  
5594 3a 9e 55			ld a, (.dmark+2)  
5597 32 a8 fd			ld (debug_mark+2),a  
559a 18 03			jr .pastdmark  
559c ..			.dmark: db "OPx"  
559f f1			.pastdmark: pop af  
55a0			endm  
# End of macro DMARK
55a0					CALLMONITOR 
55a0 cd aa fd			call debug_vector  
55a3				endm  
# End of macro CALLMONITOR
55a3				endif 
55a3 fe 00				cp 0 
55a5 20 03				jr nz, .skipopeneof 
55a7					; have opened an empty file 
55a7					 
55a7 32 a5 f9				ld (store_openext), a 
55aa			 
55aa			.skipopeneof: 
55aa			 
55aa 6f					ld l, a 
55ab 26 00				ld h, 0 
55ad cd 5c 20				call forth_push_numhl 
55b0			 
55b0			 
55b0				       NEXTW 
55b0 c3 09 24			jp macro_next 
55b3				endm 
# End of macro NEXTW
55b3			.READ: 
55b3				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
55b3 6c				db WORD_SYS_CORE+88             
55b4 dd 56			dw .EOF            
55b6 05				db 4 + 1 
55b7 .. 00			db "READ",0              
55bc				endm 
# End of macro CWHEAD
55bc			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
55bc			; | | e.g. 
55bc			; | | $01 OPEN $01 DO READ . LOOP 
55bc			; | | 
55bc			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
55bc			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
55bc			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
55bc			; | | two bytes contain the file id and extent. 
55bc			; | |  
55bc			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
55bc			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
55bc			; | | > [!NOTE] 
55bc			; | | > Compatible with PicoSPINet  
55bc			 
55bc					if DEBUG_FORTH_WORDS_KEY 
55bc						DMARK "REA" 
55bc f5				push af  
55bd 3a d1 55			ld a, (.dmark)  
55c0 32 a6 fd			ld (debug_mark),a  
55c3 3a d2 55			ld a, (.dmark+1)  
55c6 32 a7 fd			ld (debug_mark+1),a  
55c9 3a d3 55			ld a, (.dmark+2)  
55cc 32 a8 fd			ld (debug_mark+2),a  
55cf 18 03			jr .pastdmark  
55d1 ..			.dmark: db "REA"  
55d4 f1			.pastdmark: pop af  
55d5			endm  
# End of macro DMARK
55d5						CALLMONITOR 
55d5 cd aa fd			call debug_vector  
55d8				endm  
# End of macro CALLMONITOR
55d8					endif 
55d8					; store_openext use it. If zero it is EOF 
55d8			 
55d8					; read block from current stream id 
55d8					; if the block does not contain zero term keep reading blocks until zero found 
55d8					; push the block to stack 
55d8					; save the block id to stream 
55d8			 
55d8			 
55d8 cd 0a 57				call .testeof 
55db 3e 01				ld a, 1 
55dd bd					cp l 
55de ca b9 56				jp z, .ateof 
55e1			 
55e1			 
55e1			;		FORTH_DSP_VALUEHL 
55e1			 
55e1			;		push hl 
55e1			 
55e1			;	if DEBUG_STORESE 
55e1			;		DMARK "REA" 
55e1			;		CALLMONITOR 
55e1			;	endif 
55e1			;		FORTH_DSP_POP 
55e1			 
55e1			;		pop hl 
55e1				 
55e1 3a a2 f9				ld a, (store_filecache) 
55e4 67					ld h,a 
55e5			 
55e5 3a a5 f9				ld a, (store_openext) 
55e8 6f					ld l, a 
55e9					 
55e9 fe 00				cp 0 
55eb ca b9 56				jp z, .ateof     ; dont read past eof 
55ee			 
55ee cd a1 0c				call storage_clear_page 
55f1			 
55f1 11 b5 f9				ld de, store_page 
55f4				if DEBUG_STORESE 
55f4					DMARK "RE1" 
55f4 f5				push af  
55f5 3a 09 56			ld a, (.dmark)  
55f8 32 a6 fd			ld (debug_mark),a  
55fb 3a 0a 56			ld a, (.dmark+1)  
55fe 32 a7 fd			ld (debug_mark+1),a  
5601 3a 0b 56			ld a, (.dmark+2)  
5604 32 a8 fd			ld (debug_mark+2),a  
5607 18 03			jr .pastdmark  
5609 ..			.dmark: db "RE1"  
560c f1			.pastdmark: pop af  
560d			endm  
# End of macro DMARK
560d					CALLMONITOR 
560d cd aa fd			call debug_vector  
5610				endm  
# End of macro CALLMONITOR
5610				endif 
5610 cd be 09				call storage_read 
5613			 
5613				if DEBUG_STORESE 
5613					DMARK "RE2" 
5613 f5				push af  
5614 3a 28 56			ld a, (.dmark)  
5617 32 a6 fd			ld (debug_mark),a  
561a 3a 29 56			ld a, (.dmark+1)  
561d 32 a7 fd			ld (debug_mark+1),a  
5620 3a 2a 56			ld a, (.dmark+2)  
5623 32 a8 fd			ld (debug_mark+2),a  
5626 18 03			jr .pastdmark  
5628 ..			.dmark: db "RE2"  
562b f1			.pastdmark: pop af  
562c			endm  
# End of macro DMARK
562c					CALLMONITOR 
562c cd aa fd			call debug_vector  
562f				endm  
# End of macro CALLMONITOR
562f				endif 
562f cd f8 0f			call ishlzero 
5632			;	ld a, l 
5632			;	add h 
5632			;	cp 0 
5632 ca b9 56			jp z, .readeof 
5635			 
5635				; not eof so hl should point to data to push to stack 
5635			 
5635				if DEBUG_STORESE 
5635					DMARK "RE3" 
5635 f5				push af  
5636 3a 4a 56			ld a, (.dmark)  
5639 32 a6 fd			ld (debug_mark),a  
563c 3a 4b 56			ld a, (.dmark+1)  
563f 32 a7 fd			ld (debug_mark+1),a  
5642 3a 4c 56			ld a, (.dmark+2)  
5645 32 a8 fd			ld (debug_mark+2),a  
5648 18 03			jr .pastdmark  
564a ..			.dmark: db "RE3"  
564d f1			.pastdmark: pop af  
564e			endm  
# End of macro DMARK
564e					CALLMONITOR 
564e cd aa fd			call debug_vector  
5651				endm  
# End of macro CALLMONITOR
5651				endif 
5651 cd ca 20			call forth_push_str 
5654			 
5654				if DEBUG_STORESE 
5654					DMARK "RE4" 
5654 f5				push af  
5655 3a 69 56			ld a, (.dmark)  
5658 32 a6 fd			ld (debug_mark),a  
565b 3a 6a 56			ld a, (.dmark+1)  
565e 32 a7 fd			ld (debug_mark+1),a  
5661 3a 6b 56			ld a, (.dmark+2)  
5664 32 a8 fd			ld (debug_mark+2),a  
5667 18 03			jr .pastdmark  
5669 ..			.dmark: db "RE4"  
566c f1			.pastdmark: pop af  
566d			endm  
# End of macro DMARK
566d					CALLMONITOR 
566d cd aa fd			call debug_vector  
5670				endm  
# End of macro CALLMONITOR
5670				endif 
5670				; get next block  or mark as eof 
5670			 
5670 3a a4 f9			ld a, (store_openmaxext)   ; get our limit 
5673 4f				ld c, a	 
5674 3a a5 f9			ld a, (store_openext) 
5677			 
5677				if DEBUG_STORESE 
5677					DMARK "RE5" 
5677 f5				push af  
5678 3a 8c 56			ld a, (.dmark)  
567b 32 a6 fd			ld (debug_mark),a  
567e 3a 8d 56			ld a, (.dmark+1)  
5681 32 a7 fd			ld (debug_mark+1),a  
5684 3a 8e 56			ld a, (.dmark+2)  
5687 32 a8 fd			ld (debug_mark+2),a  
568a 18 03			jr .pastdmark  
568c ..			.dmark: db "RE5"  
568f f1			.pastdmark: pop af  
5690			endm  
# End of macro DMARK
5690					CALLMONITOR 
5690 cd aa fd			call debug_vector  
5693				endm  
# End of macro CALLMONITOR
5693				endif 
5693 b9				cp c 
5694 28 23			jr z, .readeof     ; at last extent 
5696			 
5696 3c					inc a 
5697 32 a5 f9				ld (store_openext), a 
569a			 
569a				if DEBUG_STORESE 
569a					DMARK "RE6" 
569a f5				push af  
569b 3a af 56			ld a, (.dmark)  
569e 32 a6 fd			ld (debug_mark),a  
56a1 3a b0 56			ld a, (.dmark+1)  
56a4 32 a7 fd			ld (debug_mark+1),a  
56a7 3a b1 56			ld a, (.dmark+2)  
56aa 32 a8 fd			ld (debug_mark+2),a  
56ad 18 03			jr .pastdmark  
56af ..			.dmark: db "RE6"  
56b2 f1			.pastdmark: pop af  
56b3			endm  
# End of macro DMARK
56b3					CALLMONITOR 
56b3 cd aa fd			call debug_vector  
56b6				endm  
# End of macro CALLMONITOR
56b6				endif 
56b6			 
56b6			 
56b6				       NEXTW 
56b6 c3 09 24			jp macro_next 
56b9				endm 
# End of macro NEXTW
56b9			.ateof: 
56b9				;	ld hl, .showeof 
56b9				;	call forth_push_str 
56b9 3e 00		.readeof:	ld a, 0 
56bb 32 a5 f9				ld (store_openext), a 
56be			 
56be					 
56be				if DEBUG_STORESE 
56be					DMARK "REF" 
56be f5				push af  
56bf 3a d3 56			ld a, (.dmark)  
56c2 32 a6 fd			ld (debug_mark),a  
56c5 3a d4 56			ld a, (.dmark+1)  
56c8 32 a7 fd			ld (debug_mark+1),a  
56cb 3a d5 56			ld a, (.dmark+2)  
56ce 32 a8 fd			ld (debug_mark+2),a  
56d1 18 03			jr .pastdmark  
56d3 ..			.dmark: db "REF"  
56d6 f1			.pastdmark: pop af  
56d7			endm  
# End of macro DMARK
56d7					CALLMONITOR 
56d7 cd aa fd			call debug_vector  
56da				endm  
# End of macro CALLMONITOR
56da				endif 
56da				       NEXTW 
56da c3 09 24			jp macro_next 
56dd				endm 
# End of macro NEXTW
56dd			 
56dd			;.showeof:   db "eof", 0 
56dd			 
56dd			 
56dd			.EOF: 
56dd				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
56dd 6d				db WORD_SYS_CORE+89             
56de 1f 57			dw .FORMAT            
56e0 04				db 3 + 1 
56e1 .. 00			db "EOF",0              
56e5				endm 
# End of macro CWHEAD
56e5			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
56e5			; | | e.g. 
56e5			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
56e5			; | | > [!NOTE] 
56e5			; | | > Compatible with PicoSPINet  
56e5					; TODO if current block id for stream is zero then push true else false 
56e5			 
56e5					if DEBUG_FORTH_WORDS_KEY 
56e5						DMARK "EOF" 
56e5 f5				push af  
56e6 3a fa 56			ld a, (.dmark)  
56e9 32 a6 fd			ld (debug_mark),a  
56ec 3a fb 56			ld a, (.dmark+1)  
56ef 32 a7 fd			ld (debug_mark+1),a  
56f2 3a fc 56			ld a, (.dmark+2)  
56f5 32 a8 fd			ld (debug_mark+2),a  
56f8 18 03			jr .pastdmark  
56fa ..			.dmark: db "EOF"  
56fd f1			.pastdmark: pop af  
56fe			endm  
# End of macro DMARK
56fe						CALLMONITOR 
56fe cd aa fd			call debug_vector  
5701				endm  
# End of macro CALLMONITOR
5701					endif 
5701			 
5701					; TODO handlue multiple file streams 
5701			 
5701			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
5701 cd 0a 57				call .testeof 
5704 cd 5c 20				call forth_push_numhl 
5707			 
5707			 
5707				       NEXTW 
5707 c3 09 24			jp macro_next 
570a				endm 
# End of macro NEXTW
570a			 
570a			.testeof: 
570a 2e 01				ld l, 1 
570c 3a a4 f9				ld a, (store_openmaxext) 
570f fe 00				cp 0 
5711 28 09				jr  z, .eofdone   ; empty file 
5713 3a a5 f9				ld a, (store_openext) 
5716 fe 00				cp 0 
5718 28 02				jr  z, .eofdone 
571a 2e 00				ld l, 0 
571c 26 00		.eofdone:	ld h, 0 
571e c9					ret 
571f			 
571f			 
571f			 
571f			 
571f			.FORMAT: 
571f				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
571f 6d				db WORD_SYS_CORE+89             
5720 70 57			dw .LABEL            
5722 07				db 6 + 1 
5723 .. 00			db "FORMAT",0              
572a				endm 
# End of macro CWHEAD
572a			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
572a			; | | > [!NOTE] 
572a			; | | > Compatible with PicoSPINet  
572a					; TODO if current block id for stream is zero then push true else false 
572a				 
572a				if DEBUG_STORESE 
572a					DMARK "FOR" 
572a f5				push af  
572b 3a 3f 57			ld a, (.dmark)  
572e 32 a6 fd			ld (debug_mark),a  
5731 3a 40 57			ld a, (.dmark+1)  
5734 32 a7 fd			ld (debug_mark+1),a  
5737 3a 41 57			ld a, (.dmark+2)  
573a 32 a8 fd			ld (debug_mark+2),a  
573d 18 03			jr .pastdmark  
573f ..			.dmark: db "FOR"  
5742 f1			.pastdmark: pop af  
5743			endm  
# End of macro DMARK
5743					CALLMONITOR 
5743 cd aa fd			call debug_vector  
5746				endm  
# End of macro CALLMONITOR
5746				endif 
5746					; Wipes the bank check flags to cause a reformat on next block 0 read 
5746			 
5746 21 01 00				ld hl, 1 
5749 3e 00				ld a, 0 
574b cd 6a 02				call se_writebyte 
574e			 
574e				if DEBUG_STORESE 
574e					DMARK "FO0" 
574e f5				push af  
574f 3a 63 57			ld a, (.dmark)  
5752 32 a6 fd			ld (debug_mark),a  
5755 3a 64 57			ld a, (.dmark+1)  
5758 32 a7 fd			ld (debug_mark+1),a  
575b 3a 65 57			ld a, (.dmark+2)  
575e 32 a8 fd			ld (debug_mark+2),a  
5761 18 03			jr .pastdmark  
5763 ..			.dmark: db "FO0"  
5766 f1			.pastdmark: pop af  
5767			endm  
# End of macro DMARK
5767					CALLMONITOR 
5767 cd aa fd			call debug_vector  
576a				endm  
# End of macro CALLMONITOR
576a				endif 
576a					; force bank init 
576a			 
576a cd 16 05				call storage_get_block_0 
576d					 
576d				       NEXTW 
576d c3 09 24			jp macro_next 
5770				endm 
# End of macro NEXTW
5770			.LABEL: 
5770				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5770 6d				db WORD_SYS_CORE+89             
5771 be 57			dw .STOREPAGE            
5773 06				db 5 + 1 
5774 .. 00			db "LABEL",0              
577a				endm 
# End of macro CWHEAD
577a			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
577a			; | | > [!NOTE] 
577a			; | | > Compatible with PicoSPINet  
577a					; TODO test to see if bank is selected 
577a				 
577a					if DEBUG_FORTH_WORDS_KEY 
577a						DMARK "LBL" 
577a f5				push af  
577b 3a 8f 57			ld a, (.dmark)  
577e 32 a6 fd			ld (debug_mark),a  
5781 3a 90 57			ld a, (.dmark+1)  
5784 32 a7 fd			ld (debug_mark+1),a  
5787 3a 91 57			ld a, (.dmark+2)  
578a 32 a8 fd			ld (debug_mark+2),a  
578d 18 03			jr .pastdmark  
578f ..			.dmark: db "LBL"  
5792 f1			.pastdmark: pop af  
5793			endm  
# End of macro DMARK
5793						CALLMONITOR 
5793 cd aa fd			call debug_vector  
5796				endm  
# End of macro CALLMONITOR
5796					endif 
5796			;	if DEBUG_STORESE 
5796			;		DMARK "LBL" 
5796			;		CALLMONITOR 
5796			;	endif 
5796					FORTH_DSP_VALUEHL 
5796 cd 53 22			call macro_dsp_valuehl 
5799				endm 
# End of macro FORTH_DSP_VALUEHL
5799					;v5FORTH_DSP_VALUE 
5799					 
5799			;		push hl 
5799					FORTH_DSP_POP 
5799 cd 0b 23			call macro_forth_dsp_pop 
579c				endm 
# End of macro FORTH_DSP_POP
579c			;		pop hl 
579c			 
579c			;v5		inc hl   ; move past the type marker 
579c			 
579c				if DEBUG_STORESE 
579c					DMARK "LBl" 
579c f5				push af  
579d 3a b1 57			ld a, (.dmark)  
57a0 32 a6 fd			ld (debug_mark),a  
57a3 3a b2 57			ld a, (.dmark+1)  
57a6 32 a7 fd			ld (debug_mark+1),a  
57a9 3a b3 57			ld a, (.dmark+2)  
57ac 32 a8 fd			ld (debug_mark+2),a  
57af 18 03			jr .pastdmark  
57b1 ..			.dmark: db "LBl"  
57b4 f1			.pastdmark: pop af  
57b5			endm  
# End of macro DMARK
57b5					CALLMONITOR 
57b5 cd aa fd			call debug_vector  
57b8				endm  
# End of macro CALLMONITOR
57b8				endif 
57b8 cd 3a 06				call storage_label 
57bb			 
57bb				       NEXTW 
57bb c3 09 24			jp macro_next 
57be				endm 
# End of macro NEXTW
57be			.STOREPAGE: 
57be				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
57be 6d				db WORD_SYS_CORE+89             
57bf f1 57			dw .LABELS            
57c1 0a				db 9 + 1 
57c2 .. 00			db "STOREPAGE",0              
57cc				endm 
# End of macro CWHEAD
57cc			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
57cc			; | | > [!NOTE] 
57cc			; | | > Compatible with PicoSPINet  
57cc					; TODO test to see if bank is selected 
57cc				 
57cc					if DEBUG_FORTH_WORDS_KEY 
57cc						DMARK "STP" 
57cc f5				push af  
57cd 3a e1 57			ld a, (.dmark)  
57d0 32 a6 fd			ld (debug_mark),a  
57d3 3a e2 57			ld a, (.dmark+1)  
57d6 32 a7 fd			ld (debug_mark+1),a  
57d9 3a e3 57			ld a, (.dmark+2)  
57dc 32 a8 fd			ld (debug_mark+2),a  
57df 18 03			jr .pastdmark  
57e1 ..			.dmark: db "STP"  
57e4 f1			.pastdmark: pop af  
57e5			endm  
# End of macro DMARK
57e5						CALLMONITOR 
57e5 cd aa fd			call debug_vector  
57e8				endm  
# End of macro CALLMONITOR
57e8					endif 
57e8			;	if DEBUG_STORESE 
57e8			;		DMARK "STP" 
57e8			;		CALLMONITOR 
57e8			;	endif 
57e8			 
57e8 21 b5 f9			ld hl, store_page 
57eb cd 5c 20			call forth_push_numhl 
57ee			 
57ee			 
57ee				       NEXTW 
57ee c3 09 24			jp macro_next 
57f1				endm 
# End of macro NEXTW
57f1			.LABELS: 
57f1				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
57f1 6d				db WORD_SYS_CORE+89             
57f2 7b 58			dw .SCONST1            
57f4 07				db 6 + 1 
57f5 .. 00			db "LABELS",0              
57fc				endm 
# End of macro CWHEAD
57fc			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | DONE 
57fc			; | | > [!CAUTION] 
57fc			; | | > *NOT* Compatible with PicoSPINet  
57fc					;  
57fc			 
57fc					; save the current device selected to restore afterwards 
57fc				 
57fc 3a 9b f9				ld a, (spi_device) 
57ff f5					push af 
5800			 
5800			 
5800					; run through each of the banks 
5800			 
5800 21 01 00				ld hl, 1 
5803 cd 5c 20				call forth_push_numhl 
5806 3e ff				ld a, SPI_CE_HIGH 
5808 cb 87				res SPI_CE0, a 
580a 32 9b f9				ld (spi_device), a 
580d cd 16 05				call storage_get_block_0 
5810 21 b8 f9				ld hl, store_page+3 
5813 cd ca 20				call forth_push_str 
5816			 
5816					 
5816 21 02 00				ld hl, 2 
5819 cd 5c 20				call forth_push_numhl 
581c 3e ff				ld a, SPI_CE_HIGH 
581e cb 8f				res SPI_CE1, a 
5820 32 9b f9				ld (spi_device), a 
5823 cd 16 05				call storage_get_block_0 
5826 21 b8 f9				ld hl, store_page+3 
5829 cd ca 20				call forth_push_str 
582c			 
582c					 
582c 21 03 00				ld hl, 3 
582f cd 5c 20				call forth_push_numhl 
5832 3e ff				ld a, SPI_CE_HIGH 
5834 cb 97				res SPI_CE2, a 
5836 32 9b f9				ld (spi_device), a 
5839 cd 16 05				call storage_get_block_0 
583c 21 b8 f9				ld hl, store_page+3 
583f cd ca 20				call forth_push_str 
5842			 
5842			 
5842 21 04 00				ld hl, 4 
5845 cd 5c 20				call forth_push_numhl 
5848 3e ff				ld a, SPI_CE_HIGH 
584a cb 9f				res SPI_CE3, a 
584c 32 9b f9				ld (spi_device), a 
584f cd 16 05				call storage_get_block_0 
5852 21 b8 f9				ld hl, store_page+3 
5855 cd ca 20				call forth_push_str 
5858			 
5858					 
5858			 
5858 21 05 00				ld hl, 5 
585b cd 5c 20				call forth_push_numhl 
585e 3e ff				ld a, SPI_CE_HIGH 
5860 cb a7				res SPI_CE4, a 
5862 32 9b f9				ld (spi_device), a 
5865 cd 16 05				call storage_get_block_0 
5868 21 b8 f9				ld hl, store_page+3 
586b cd ca 20				call forth_push_str 
586e			 
586e					 
586e					; push fixed count of storage devices (on board) for now 
586e			 
586e 21 05 00				ld hl, 5 
5871 cd 5c 20				call forth_push_numhl 
5874			 
5874					; restore selected device  
5874				 
5874 f1					pop af 
5875 32 9b f9				ld (spi_device), a 
5878			 
5878				       NEXTW 
5878 c3 09 24			jp macro_next 
587b				endm 
# End of macro NEXTW
587b			 
587b			.SCONST1: 
587b				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
587b 6d				db WORD_SYS_CORE+89             
587c 92 58			dw .SCONST2            
587e 07				db 6 + 1 
587f .. 00			db "FILEID",0              
5886				endm 
# End of macro CWHEAD
5886			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5886			; | | > [!NOTE] 
5886			; | | > Compatible with PicoSPINet  
5886 3a a2 f9				ld a, (store_filecache) 
5889 26 00				ld h, 0 
588b 6f					ld l, a 
588c cd 5c 20				call forth_push_numhl 
588f					NEXTW 
588f c3 09 24			jp macro_next 
5892				endm 
# End of macro NEXTW
5892			.SCONST2: 
5892				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5892 6d				db WORD_SYS_CORE+89             
5893 aa 58			dw .SCONST3            
5895 08				db 7 + 1 
5896 .. 00			db "FILEEXT",0              
589e				endm 
# End of macro CWHEAD
589e			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
589e			; | | > [!NOTE] 
589e			; | | > Compatible with PicoSPINet  
589e 3a a5 f9				ld a, (store_openext) 
58a1 26 00				ld h, 0 
58a3 6f					ld l, a 
58a4 cd 5c 20				call forth_push_numhl 
58a7					NEXTW 
58a7 c3 09 24			jp macro_next 
58aa				endm 
# End of macro NEXTW
58aa			.SCONST3: 
58aa				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
58aa 6d				db WORD_SYS_CORE+89             
58ab c2 58			dw .SCONST4            
58ad 08				db 7 + 1 
58ae .. 00			db "FILEMAX",0              
58b6				endm 
# End of macro CWHEAD
58b6			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
58b6			; | | > [!NOTE] 
58b6			; | | > Compatible with PicoSPINet  
58b6 3a a4 f9				ld a, (store_openmaxext) 
58b9 26 00				ld h, 0 
58bb 6f					ld l, a 
58bc cd 5c 20				call forth_push_numhl 
58bf					NEXTW 
58bf c3 09 24			jp macro_next 
58c2				endm 
# End of macro NEXTW
58c2			.SCONST4: 
58c2				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
58c2 6d				db WORD_SYS_CORE+89             
58c3 d8 58			dw .SCONST5            
58c5 09				db 8 + 1 
58c6 .. 00			db "FILEADDR",0              
58cf				endm 
# End of macro CWHEAD
58cf			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currently open file to stack | DONE 
58cf			; | | > [!NOTE] 
58cf			; | | > Compatible with PicoSPINet  
58cf 2a a6 f9				ld hl, (store_openaddr) 
58d2 cd 5c 20				call forth_push_numhl 
58d5					NEXTW 
58d5 c3 09 24			jp macro_next 
58d8				endm 
# End of macro NEXTW
58d8			.SCONST5: 
58d8				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
58d8 6d				db WORD_SYS_CORE+89             
58d9 f9 58			dw .SCONST6            
58db 09				db 8 + 1 
58dc .. 00			db "FILEPAGE",0              
58e5				endm 
# End of macro CWHEAD
58e5			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
58e5			; | | > [!NOTE] 
58e5			; | | > Compatible with PicoSPINet  
58e5 2a a6 f9				ld hl, (store_openaddr) 
58e8 e5					push hl 
58e9 c1					pop bc 
58ea 16 00				ld d, 0 
58ec 1e 40				ld e, STORE_BLOCK_PHY 
58ee cd 2c 0f				call Div16 
58f1 c5					push bc 
58f2 e1					pop hl 
58f3 cd 5c 20				call forth_push_numhl 
58f6					NEXTW 
58f6 c3 09 24			jp macro_next 
58f9				endm 
# End of macro NEXTW
58f9			.SCONST6: 
58f9				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
58f9 6d				db WORD_SYS_CORE+89             
58fa 12 59			dw .ENDSTORAGE            
58fc 09				db 8 + 1 
58fd .. 00			db "READCONT",0              
5906				endm 
# End of macro CWHEAD
5906			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
5906			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
5906			; | | a further read should, if applicable, be CONCAT to the previous read. 
5906			; | | > [!NOTE] 
5906			; | | > Compatible with PicoSPINet  
5906 3a a8 f9				ld a, (store_readcont) 
5909 26 00				ld h, 0 
590b 6f					ld l, a 
590c cd 5c 20				call forth_push_numhl 
590f					NEXTW 
590f c3 09 24			jp macro_next 
5912				endm 
# End of macro NEXTW
5912			.ENDSTORAGE: 
5912			; eof 
# End of file forth_words_storage.asm
5912			endif 
5912				include "forth_words_device.asm" 
5912			; Device related words 
5912			 
5912			; | ## Device Words 
5912			 
5912			;if SOUND_ENABLE 
5912			;.NOTE: 
5912			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
5912			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
5912			;		if DEBUG_FORTH_WORDS_KEY 
5912			;			DMARK "NTE" 
5912			;			CALLMONITOR 
5912			;		endif 
5912			; 
5912			;	 
5912			; 
5912			;		NEXTW 
5912			;.AFTERSOUND: 
5912			;endif 
5912			 
5912			 
5912			USE_GPIO: equ 0 
5912			 
5912			if USE_GPIO 
5912			.GP1: 
5912				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
5912			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
5912					NEXTW 
5912			.GP2: 
5912				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
5912			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
5912			 
5912					NEXTW 
5912			 
5912			.GP3: 
5912				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
5912			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
5912			 
5912					NEXTW 
5912			 
5912			.GP4: 
5912				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
5912			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
5912			 
5912					NEXTW 
5912			.SIN: 
5912			 
5912			 
5912			endif 
5912			 
5912			 
5912				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
5912 33				db WORD_SYS_CORE+31             
5913 47 59			dw .SOUT            
5915 03				db 2 + 1 
5916 .. 00			db "IN",0              
5919				endm 
# End of macro CWHEAD
5919			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5919					if DEBUG_FORTH_WORDS_KEY 
5919						DMARK "IN." 
5919 f5				push af  
591a 3a 2e 59			ld a, (.dmark)  
591d 32 a6 fd			ld (debug_mark),a  
5920 3a 2f 59			ld a, (.dmark+1)  
5923 32 a7 fd			ld (debug_mark+1),a  
5926 3a 30 59			ld a, (.dmark+2)  
5929 32 a8 fd			ld (debug_mark+2),a  
592c 18 03			jr .pastdmark  
592e ..			.dmark: db "IN."  
5931 f1			.pastdmark: pop af  
5932			endm  
# End of macro DMARK
5932						CALLMONITOR 
5932 cd aa fd			call debug_vector  
5935				endm  
# End of macro CALLMONITOR
5935					endif 
5935					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5935 cd 53 22			call macro_dsp_valuehl 
5938				endm 
# End of macro FORTH_DSP_VALUEHL
5938			 
5938 e5					push hl 
5939			 
5939					; destroy value TOS 
5939			 
5939					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5939 cd 0b 23			call macro_forth_dsp_pop 
593c				endm 
# End of macro FORTH_DSP_POP
593c			 
593c					; one value on hl get other one back 
593c			 
593c c1					pop bc 
593d			 
593d					; do the sub 
593d			;		ex de, hl 
593d			 
593d ed 68				in l,(c) 
593f			 
593f					; save it 
593f			 
593f 26 00				ld h,0 
5941			 
5941					; TODO push value back onto stack for another op etc 
5941			 
5941 cd 5c 20				call forth_push_numhl 
5944					NEXTW 
5944 c3 09 24			jp macro_next 
5947				endm 
# End of macro NEXTW
5947			.SOUT: 
5947				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5947 34				db WORD_SYS_CORE+32             
5948 9a 59			dw .SPIO            
594a 04				db 3 + 1 
594b .. 00			db "OUT",0              
594f				endm 
# End of macro CWHEAD
594f			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
594f					if DEBUG_FORTH_WORDS_KEY 
594f						DMARK "OUT" 
594f f5				push af  
5950 3a 64 59			ld a, (.dmark)  
5953 32 a6 fd			ld (debug_mark),a  
5956 3a 65 59			ld a, (.dmark+1)  
5959 32 a7 fd			ld (debug_mark+1),a  
595c 3a 66 59			ld a, (.dmark+2)  
595f 32 a8 fd			ld (debug_mark+2),a  
5962 18 03			jr .pastdmark  
5964 ..			.dmark: db "OUT"  
5967 f1			.pastdmark: pop af  
5968			endm  
# End of macro DMARK
5968						CALLMONITOR 
5968 cd aa fd			call debug_vector  
596b				endm  
# End of macro CALLMONITOR
596b					endif 
596b			 
596b					; get port 
596b			 
596b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
596b cd 53 22			call macro_dsp_valuehl 
596e				endm 
# End of macro FORTH_DSP_VALUEHL
596e			 
596e e5					push hl 
596f			 
596f					; destroy value TOS 
596f			 
596f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
596f cd 0b 23			call macro_forth_dsp_pop 
5972				endm 
# End of macro FORTH_DSP_POP
5972			 
5972					; get byte to send 
5972			 
5972					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5972 cd 53 22			call macro_dsp_valuehl 
5975				endm 
# End of macro FORTH_DSP_VALUEHL
5975			 
5975			;		push hl 
5975			 
5975					; destroy value TOS 
5975			 
5975					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5975 cd 0b 23			call macro_forth_dsp_pop 
5978				endm 
# End of macro FORTH_DSP_POP
5978			 
5978					; one value on hl get other one back 
5978			 
5978			;		pop hl 
5978			 
5978 c1					pop bc 
5979			 
5979					if DEBUG_FORTH_WORDS 
5979						DMARK "OUT" 
5979 f5				push af  
597a 3a 8e 59			ld a, (.dmark)  
597d 32 a6 fd			ld (debug_mark),a  
5980 3a 8f 59			ld a, (.dmark+1)  
5983 32 a7 fd			ld (debug_mark+1),a  
5986 3a 90 59			ld a, (.dmark+2)  
5989 32 a8 fd			ld (debug_mark+2),a  
598c 18 03			jr .pastdmark  
598e ..			.dmark: db "OUT"  
5991 f1			.pastdmark: pop af  
5992			endm  
# End of macro DMARK
5992						CALLMONITOR 
5992 cd aa fd			call debug_vector  
5995				endm  
# End of macro CALLMONITOR
5995					endif 
5995			 
5995 ed 69				out (c), l 
5997			 
5997					NEXTW 
5997 c3 09 24			jp macro_next 
599a				endm 
# End of macro NEXTW
599a			 
599a			 
599a			.SPIO: 
599a			 
599a			if STORAGE_SE 
599a				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
599a 51				db WORD_SYS_CORE+61             
599b ab 59			dw .SPICEH            
599d 07				db 6 + 1 
599e .. 00			db "SPICEL",0              
59a5				endm 
# End of macro CWHEAD
59a5			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
59a5			 
59a5 cd 13 02				call spi_ce_low 
59a8			    NEXTW 
59a8 c3 09 24			jp macro_next 
59ab				endm 
# End of macro NEXTW
59ab			 
59ab			.SPICEH: 
59ab				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
59ab 51				db WORD_SYS_CORE+61             
59ac bc 59			dw .SPIOb            
59ae 07				db 6 + 1 
59af .. 00			db "SPICEH",0              
59b6				endm 
# End of macro CWHEAD
59b6			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
59b6			 
59b6 cd 02 02				call spi_ce_high 
59b9			    NEXTW 
59b9 c3 09 24			jp macro_next 
59bc				endm 
# End of macro NEXTW
59bc			 
59bc			 
59bc			.SPIOb: 
59bc			 
59bc				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
59bc 51				db WORD_SYS_CORE+61             
59bd ee 59			dw .SPII            
59bf 05				db 4 + 1 
59c0 .. 00			db "SPIO",0              
59c5				endm 
# End of macro CWHEAD
59c5			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
59c5			 
59c5					if DEBUG_FORTH_WORDS_KEY 
59c5						DMARK "SPo" 
59c5 f5				push af  
59c6 3a da 59			ld a, (.dmark)  
59c9 32 a6 fd			ld (debug_mark),a  
59cc 3a db 59			ld a, (.dmark+1)  
59cf 32 a7 fd			ld (debug_mark+1),a  
59d2 3a dc 59			ld a, (.dmark+2)  
59d5 32 a8 fd			ld (debug_mark+2),a  
59d8 18 03			jr .pastdmark  
59da ..			.dmark: db "SPo"  
59dd f1			.pastdmark: pop af  
59de			endm  
# End of macro DMARK
59de						CALLMONITOR 
59de cd aa fd			call debug_vector  
59e1				endm  
# End of macro CALLMONITOR
59e1					endif 
59e1					; get port 
59e1			 
59e1			 
59e1					; get byte to send 
59e1			 
59e1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
59e1 cd 53 22			call macro_dsp_valuehl 
59e4				endm 
# End of macro FORTH_DSP_VALUEHL
59e4			 
59e4			;		push hl    ; u1  
59e4			 
59e4					; destroy value TOS 
59e4			 
59e4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59e4 cd 0b 23			call macro_forth_dsp_pop 
59e7				endm 
# End of macro FORTH_DSP_POP
59e7			 
59e7					; one value on hl get other one back 
59e7			 
59e7			;		pop hl   ; u2 - addr 
59e7			 
59e7					; TODO Send SPI byte 
59e7			 
59e7			;		push hl 
59e7			;		call spi_ce_low 
59e7			;		pop hl 
59e7 7d					ld a, l 
59e8 cd 01 01				call spi_send_byte 
59eb			;		call spi_ce_high 
59eb			 
59eb					NEXTW 
59eb c3 09 24			jp macro_next 
59ee				endm 
# End of macro NEXTW
59ee			 
59ee			.SPII: 
59ee				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
59ee 52				db WORD_SYS_CORE+62             
59ef 57 5a			dw .SESEL            
59f1 06				db 5 + 1 
59f2 .. 00			db "SPII",0              
59f7				endm 
# End of macro CWHEAD
59f7			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
59f7					if DEBUG_FORTH_WORDS_KEY 
59f7						DMARK "SPi" 
59f7 f5				push af  
59f8 3a 0c 5a			ld a, (.dmark)  
59fb 32 a6 fd			ld (debug_mark),a  
59fe 3a 0d 5a			ld a, (.dmark+1)  
5a01 32 a7 fd			ld (debug_mark+1),a  
5a04 3a 0e 5a			ld a, (.dmark+2)  
5a07 32 a8 fd			ld (debug_mark+2),a  
5a0a 18 03			jr .pastdmark  
5a0c ..			.dmark: db "SPi"  
5a0f f1			.pastdmark: pop af  
5a10			endm  
# End of macro DMARK
5a10						CALLMONITOR 
5a10 cd aa fd			call debug_vector  
5a13				endm  
# End of macro CALLMONITOR
5a13					endif 
5a13			 
5a13					; TODO Get SPI byte 
5a13			 
5a13 cd 28 01				call spi_read_byte 
5a16			 
5a16					if DEBUG_FORTH_WORDS 
5a16						DMARK "Si2" 
5a16 f5				push af  
5a17 3a 2b 5a			ld a, (.dmark)  
5a1a 32 a6 fd			ld (debug_mark),a  
5a1d 3a 2c 5a			ld a, (.dmark+1)  
5a20 32 a7 fd			ld (debug_mark+1),a  
5a23 3a 2d 5a			ld a, (.dmark+2)  
5a26 32 a8 fd			ld (debug_mark+2),a  
5a29 18 03			jr .pastdmark  
5a2b ..			.dmark: db "Si2"  
5a2e f1			.pastdmark: pop af  
5a2f			endm  
# End of macro DMARK
5a2f						CALLMONITOR 
5a2f cd aa fd			call debug_vector  
5a32				endm  
# End of macro CALLMONITOR
5a32					endif 
5a32 26 00				ld h, 0 
5a34 6f					ld l, a 
5a35					if DEBUG_FORTH_WORDS 
5a35						DMARK "Si3" 
5a35 f5				push af  
5a36 3a 4a 5a			ld a, (.dmark)  
5a39 32 a6 fd			ld (debug_mark),a  
5a3c 3a 4b 5a			ld a, (.dmark+1)  
5a3f 32 a7 fd			ld (debug_mark+1),a  
5a42 3a 4c 5a			ld a, (.dmark+2)  
5a45 32 a8 fd			ld (debug_mark+2),a  
5a48 18 03			jr .pastdmark  
5a4a ..			.dmark: db "Si3"  
5a4d f1			.pastdmark: pop af  
5a4e			endm  
# End of macro DMARK
5a4e						CALLMONITOR 
5a4e cd aa fd			call debug_vector  
5a51				endm  
# End of macro CALLMONITOR
5a51					endif 
5a51 cd 5c 20				call forth_push_numhl 
5a54			 
5a54					NEXTW 
5a54 c3 09 24			jp macro_next 
5a57				endm 
# End of macro NEXTW
5a57			 
5a57			 
5a57			 
5a57			.SESEL: 
5a57				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5a57 66				db WORD_SYS_CORE+82             
5a58 00 5b			dw .CARTDEV            
5a5a 05				db 4 + 1 
5a5b .. 00			db "BANK",0              
5a60				endm 
# End of macro CWHEAD
5a60			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5a60					if DEBUG_FORTH_WORDS_KEY 
5a60						DMARK "BNK" 
5a60 f5				push af  
5a61 3a 75 5a			ld a, (.dmark)  
5a64 32 a6 fd			ld (debug_mark),a  
5a67 3a 76 5a			ld a, (.dmark+1)  
5a6a 32 a7 fd			ld (debug_mark+1),a  
5a6d 3a 77 5a			ld a, (.dmark+2)  
5a70 32 a8 fd			ld (debug_mark+2),a  
5a73 18 03			jr .pastdmark  
5a75 ..			.dmark: db "BNK"  
5a78 f1			.pastdmark: pop af  
5a79			endm  
# End of macro DMARK
5a79						CALLMONITOR 
5a79 cd aa fd			call debug_vector  
5a7c				endm  
# End of macro CALLMONITOR
5a7c					endif 
5a7c			 
5a7c 3e ff				ld a, 255 
5a7e 32 9e f9				ld (spi_cartdev), a 
5a81			 
5a81					; get bank 
5a81			 
5a81					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a81 cd 53 22			call macro_dsp_valuehl 
5a84				endm 
# End of macro FORTH_DSP_VALUEHL
5a84			 
5a84			;		push hl 
5a84			 
5a84					; destroy value TOS 
5a84			 
5a84					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a84 cd 0b 23			call macro_forth_dsp_pop 
5a87				endm 
# End of macro FORTH_DSP_POP
5a87			 
5a87					; one value on hl get other one back 
5a87			 
5a87			;		pop hl 
5a87			 
5a87			 
5a87 0e ff				ld c, SPI_CE_HIGH 
5a89 06 30				ld b, '0'    ; human readable bank number 
5a8b			 
5a8b 7d					ld a, l 
5a8c			 
5a8c					if DEBUG_FORTH_WORDS 
5a8c						DMARK "BNK" 
5a8c f5				push af  
5a8d 3a a1 5a			ld a, (.dmark)  
5a90 32 a6 fd			ld (debug_mark),a  
5a93 3a a2 5a			ld a, (.dmark+1)  
5a96 32 a7 fd			ld (debug_mark+1),a  
5a99 3a a3 5a			ld a, (.dmark+2)  
5a9c 32 a8 fd			ld (debug_mark+2),a  
5a9f 18 03			jr .pastdmark  
5aa1 ..			.dmark: db "BNK"  
5aa4 f1			.pastdmark: pop af  
5aa5			endm  
# End of macro DMARK
5aa5						CALLMONITOR 
5aa5 cd aa fd			call debug_vector  
5aa8				endm  
# End of macro CALLMONITOR
5aa8					endif 
5aa8			 
5aa8					; active low 
5aa8			 
5aa8 fe 00				cp 0 
5aaa 28 28				jr z, .bset 
5aac fe 01				cp 1 
5aae 20 04				jr nz, .b2 
5ab0 cb 81				res 0, c 
5ab2 06 31				ld b, '1'    ; human readable bank number 
5ab4 fe 02		.b2:		cp 2 
5ab6 20 04				jr nz, .b3 
5ab8 cb 89				res 1, c 
5aba 06 32				ld b, '2'    ; human readable bank number 
5abc fe 03		.b3:		cp 3 
5abe 20 04				jr nz, .b4 
5ac0 cb 91				res 2, c 
5ac2 06 33				ld b, '3'    ; human readable bank number 
5ac4 fe 04		.b4:		cp 4 
5ac6 20 04				jr nz, .b5 
5ac8 cb 99				res 3, c 
5aca 06 34				ld b, '4'    ; human readable bank number 
5acc fe 05		.b5:		cp 5 
5ace 20 04				jr nz, .bset 
5ad0 cb a1				res 4, c 
5ad2 06 35				ld b, '5'    ; human readable bank number 
5ad4			 
5ad4			.bset: 
5ad4 79					ld a, c 
5ad5 32 9b f9				ld (spi_device),a 
5ad8 78					ld a, b 
5ad9 32 9a f9				ld (spi_device_id),a 
5adc					if DEBUG_FORTH_WORDS 
5adc						DMARK "BN2" 
5adc f5				push af  
5add 3a f1 5a			ld a, (.dmark)  
5ae0 32 a6 fd			ld (debug_mark),a  
5ae3 3a f2 5a			ld a, (.dmark+1)  
5ae6 32 a7 fd			ld (debug_mark+1),a  
5ae9 3a f3 5a			ld a, (.dmark+2)  
5aec 32 a8 fd			ld (debug_mark+2),a  
5aef 18 03			jr .pastdmark  
5af1 ..			.dmark: db "BN2"  
5af4 f1			.pastdmark: pop af  
5af5			endm  
# End of macro DMARK
5af5						CALLMONITOR 
5af5 cd aa fd			call debug_vector  
5af8				endm  
# End of macro CALLMONITOR
5af8					endif 
5af8			 
5af8					; set default SPI clk pulse time as disabled for BANK use 
5af8			 
5af8 3e 00				ld a, 0 
5afa 32 9f f9				ld (spi_clktime), a 
5afd			 
5afd					NEXTW 
5afd c3 09 24			jp macro_next 
5b00				endm 
# End of macro NEXTW
5b00			 
5b00			.CARTDEV: 
5b00				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5b00 66				db WORD_SYS_CORE+82             
5b01 ae 5b			dw .ENDDEVICE            
5b03 08				db 7 + 1 
5b04 .. 00			db "CARTDEV",0              
5b0c				endm 
# End of macro CWHEAD
5b0c			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5b0c					if DEBUG_FORTH_WORDS_KEY 
5b0c						DMARK "CDV" 
5b0c f5				push af  
5b0d 3a 21 5b			ld a, (.dmark)  
5b10 32 a6 fd			ld (debug_mark),a  
5b13 3a 22 5b			ld a, (.dmark+1)  
5b16 32 a7 fd			ld (debug_mark+1),a  
5b19 3a 23 5b			ld a, (.dmark+2)  
5b1c 32 a8 fd			ld (debug_mark+2),a  
5b1f 18 03			jr .pastdmark  
5b21 ..			.dmark: db "CDV"  
5b24 f1			.pastdmark: pop af  
5b25			endm  
# End of macro DMARK
5b25						CALLMONITOR 
5b25 cd aa fd			call debug_vector  
5b28				endm  
# End of macro CALLMONITOR
5b28					endif 
5b28			 
5b28					; disable se storage bank selection 
5b28			 
5b28 3e ff				ld a, SPI_CE_HIGH		; ce high 
5b2a 32 9b f9				ld (spi_device), a 
5b2d			 
5b2d					; get bank 
5b2d			 
5b2d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b2d cd 53 22			call macro_dsp_valuehl 
5b30				endm 
# End of macro FORTH_DSP_VALUEHL
5b30			 
5b30			;		push hl 
5b30			 
5b30					; destroy value TOS 
5b30			 
5b30					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b30 cd 0b 23			call macro_forth_dsp_pop 
5b33				endm 
# End of macro FORTH_DSP_POP
5b33			 
5b33					; one value on hl get other one back 
5b33			 
5b33			;		pop hl 
5b33			 
5b33					; active low 
5b33			 
5b33 0e ff				ld c, 255 
5b35			 
5b35 7d					ld a, l 
5b36					if DEBUG_FORTH_WORDS 
5b36						DMARK "CDV" 
5b36 f5				push af  
5b37 3a 4b 5b			ld a, (.dmark)  
5b3a 32 a6 fd			ld (debug_mark),a  
5b3d 3a 4c 5b			ld a, (.dmark+1)  
5b40 32 a7 fd			ld (debug_mark+1),a  
5b43 3a 4d 5b			ld a, (.dmark+2)  
5b46 32 a8 fd			ld (debug_mark+2),a  
5b49 18 03			jr .pastdmark  
5b4b ..			.dmark: db "CDV"  
5b4e f1			.pastdmark: pop af  
5b4f			endm  
# End of macro DMARK
5b4f						CALLMONITOR 
5b4f cd aa fd			call debug_vector  
5b52				endm  
# End of macro CALLMONITOR
5b52					endif 
5b52 fe 00				cp 0 
5b54 28 30				jr z, .cset 
5b56 fe 01				cp 1 
5b58 20 02				jr nz, .c2 
5b5a cb 81				res 0, c 
5b5c fe 02		.c2:		cp 2 
5b5e 20 02				jr nz, .c3 
5b60 cb 89				res 1, c 
5b62 fe 03		.c3:		cp 3 
5b64 20 02				jr nz, .c4 
5b66 cb 91				res 2, c 
5b68 fe 04		.c4:		cp 4 
5b6a 20 02				jr nz, .c5 
5b6c cb 99				res 3, c 
5b6e fe 05		.c5:		cp 5 
5b70 20 02				jr nz, .c6 
5b72 cb a1				res 4, c 
5b74 fe 06		.c6:		cp 6 
5b76 20 02				jr nz, .c7 
5b78 cb a9				res 5, c 
5b7a fe 07		.c7:		cp 7 
5b7c 20 02				jr nz, .c8 
5b7e cb b1				res 6, c 
5b80 fe 08		.c8:		cp 8 
5b82 20 02				jr nz, .cset 
5b84 cb b9				res 7, c 
5b86 79			.cset:		ld a, c 
5b87 32 9e f9				ld (spi_cartdev),a 
5b8a			 
5b8a					if DEBUG_FORTH_WORDS 
5b8a						DMARK "CD2" 
5b8a f5				push af  
5b8b 3a 9f 5b			ld a, (.dmark)  
5b8e 32 a6 fd			ld (debug_mark),a  
5b91 3a a0 5b			ld a, (.dmark+1)  
5b94 32 a7 fd			ld (debug_mark+1),a  
5b97 3a a1 5b			ld a, (.dmark+2)  
5b9a 32 a8 fd			ld (debug_mark+2),a  
5b9d 18 03			jr .pastdmark  
5b9f ..			.dmark: db "CD2"  
5ba2 f1			.pastdmark: pop af  
5ba3			endm  
# End of macro DMARK
5ba3						CALLMONITOR 
5ba3 cd aa fd			call debug_vector  
5ba6				endm  
# End of macro CALLMONITOR
5ba6					endif 
5ba6			 
5ba6					; set default SPI clk pulse time as 10ms for CARTDEV use 
5ba6			 
5ba6 3e 0a				ld a, $0a 
5ba8 32 9f f9				ld (spi_clktime), a 
5bab					NEXTW 
5bab c3 09 24			jp macro_next 
5bae				endm 
# End of macro NEXTW
5bae			endif 
5bae			 
5bae			.ENDDEVICE: 
5bae			; eof 
5bae			 
# End of file forth_words_device.asm
5bae			 
5bae			; var handler 
5bae			 
5bae			 
5bae			.VARS: 
5bae				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5bae 77				db WORD_SYS_CORE+99             
5baf 5f 5c			dw .V0            
5bb1 04				db 3 + 1 
5bb2 .. 00			db "VAR",0              
5bb6				endm 
# End of macro CWHEAD
5bb6			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5bb6			;| 
5bb6			;| The variable name should consist of a single letter. e.g. "a" 
5bb6			;! If a full string is passed then only the first char is looked at 
5bb6			;| Any other char could exceed bounds checks!  
5bb6			 
5bb6					if DEBUG_FORTH_WORDS_KEY 
5bb6						DMARK "VAR" 
5bb6 f5				push af  
5bb7 3a cb 5b			ld a, (.dmark)  
5bba 32 a6 fd			ld (debug_mark),a  
5bbd 3a cc 5b			ld a, (.dmark+1)  
5bc0 32 a7 fd			ld (debug_mark+1),a  
5bc3 3a cd 5b			ld a, (.dmark+2)  
5bc6 32 a8 fd			ld (debug_mark+2),a  
5bc9 18 03			jr .pastdmark  
5bcb ..			.dmark: db "VAR"  
5bce f1			.pastdmark: pop af  
5bcf			endm  
# End of macro DMARK
5bcf						CALLMONITOR 
5bcf cd aa fd			call debug_vector  
5bd2				endm  
# End of macro CALLMONITOR
5bd2					endif 
5bd2			 
5bd2					FORTH_DSP_VALUEHL 
5bd2 cd 53 22			call macro_dsp_valuehl 
5bd5				endm 
# End of macro FORTH_DSP_VALUEHL
5bd5			 
5bd5 7e					ld a, (hl)    ; get first char on of the string 
5bd6			 
5bd6			 
5bd6					if DEBUG_FORTH_WORDS 
5bd6						DMARK "VR1" 
5bd6 f5				push af  
5bd7 3a eb 5b			ld a, (.dmark)  
5bda 32 a6 fd			ld (debug_mark),a  
5bdd 3a ec 5b			ld a, (.dmark+1)  
5be0 32 a7 fd			ld (debug_mark+1),a  
5be3 3a ed 5b			ld a, (.dmark+2)  
5be6 32 a8 fd			ld (debug_mark+2),a  
5be9 18 03			jr .pastdmark  
5beb ..			.dmark: db "VR1"  
5bee f1			.pastdmark: pop af  
5bef			endm  
# End of macro DMARK
5bef						CALLMONITOR 
5bef cd aa fd			call debug_vector  
5bf2				endm  
# End of macro CALLMONITOR
5bf2					endif 
5bf2					 
5bf2 f5					push af	 
5bf3					FORTH_DSP_POP 
5bf3 cd 0b 23			call macro_forth_dsp_pop 
5bf6				endm 
# End of macro FORTH_DSP_POP
5bf6 f1					pop af 
5bf7			 
5bf7					; convert to upper 
5bf7			 
5bf7 cd 95 12				call to_upper 
5bfa					if DEBUG_FORTH_WORDS 
5bfa						DMARK "Vaa" 
5bfa f5				push af  
5bfb 3a 0f 5c			ld a, (.dmark)  
5bfe 32 a6 fd			ld (debug_mark),a  
5c01 3a 10 5c			ld a, (.dmark+1)  
5c04 32 a7 fd			ld (debug_mark+1),a  
5c07 3a 11 5c			ld a, (.dmark+2)  
5c0a 32 a8 fd			ld (debug_mark+2),a  
5c0d 18 03			jr .pastdmark  
5c0f ..			.dmark: db "Vaa"  
5c12 f1			.pastdmark: pop af  
5c13			endm  
# End of macro DMARK
5c13						CALLMONITOR 
5c13 cd aa fd			call debug_vector  
5c16				endm  
# End of macro CALLMONITOR
5c16					endif 
5c16 06 41				ld b, 'A' 
5c18 90					sub b			; set offset 
5c19					if DEBUG_FORTH_WORDS 
5c19						DMARK "Vbb" 
5c19 f5				push af  
5c1a 3a 2e 5c			ld a, (.dmark)  
5c1d 32 a6 fd			ld (debug_mark),a  
5c20 3a 2f 5c			ld a, (.dmark+1)  
5c23 32 a7 fd			ld (debug_mark+1),a  
5c26 3a 30 5c			ld a, (.dmark+2)  
5c29 32 a8 fd			ld (debug_mark+2),a  
5c2c 18 03			jr .pastdmark  
5c2e ..			.dmark: db "Vbb"  
5c31 f1			.pastdmark: pop af  
5c32			endm  
# End of macro DMARK
5c32						CALLMONITOR 
5c32 cd aa fd			call debug_vector  
5c35				endm  
# End of macro CALLMONITOR
5c35					endif 
5c35 cb 27				sla a  
5c37				 
5c37					 
5c37					if DEBUG_FORTH_WORDS 
5c37						DMARK "VR2" 
5c37 f5				push af  
5c38 3a 4c 5c			ld a, (.dmark)  
5c3b 32 a6 fd			ld (debug_mark),a  
5c3e 3a 4d 5c			ld a, (.dmark+1)  
5c41 32 a7 fd			ld (debug_mark+1),a  
5c44 3a 4e 5c			ld a, (.dmark+2)  
5c47 32 a8 fd			ld (debug_mark+2),a  
5c4a 18 03			jr .pastdmark  
5c4c ..			.dmark: db "VR2"  
5c4f f1			.pastdmark: pop af  
5c50			endm  
# End of macro DMARK
5c50						CALLMONITOR 
5c50 cd aa fd			call debug_vector  
5c53				endm  
# End of macro CALLMONITOR
5c53					endif 
5c53			 
5c53 21 2f f9				ld hl, cli_var_array2 
5c56 cd cf 0f				call addatohl 
5c59 cd 5c 20				call forth_push_numhl 
5c5c			 
5c5c			 
5c5c				       NEXTW 
5c5c c3 09 24			jp macro_next 
5c5f				endm 
# End of macro NEXTW
5c5f			.V0: 
5c5f				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5c5f 78				db WORD_SYS_CORE+100             
5c60 77 5c			dw .V0Q            
5c62 04				db 3 + 1 
5c63 .. 00			db "V0!",0              
5c67				endm 
# End of macro CWHEAD
5c67			;| V0! ( u1 -- )  Store value to v0  | DONE 
5c67			 
5c67					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c67 cd 53 22			call macro_dsp_valuehl 
5c6a				endm 
# End of macro FORTH_DSP_VALUEHL
5c6a			 
5c6a 11 63 f9				ld de, cli_var_array 
5c6d			 
5c6d eb					ex de, hl 
5c6e 73					ld (hl), e 
5c6f 23					inc hl 
5c70 72					ld (hl), d 
5c71			 
5c71					; destroy value TOS 
5c71			 
5c71					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c71 cd 0b 23			call macro_forth_dsp_pop 
5c74				endm 
# End of macro FORTH_DSP_POP
5c74			 
5c74				       NEXTW 
5c74 c3 09 24			jp macro_next 
5c77				endm 
# End of macro NEXTW
5c77			.V0Q: 
5c77				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5c77 79				db WORD_SYS_CORE+101             
5c78 88 5c			dw .V1S            
5c7a 04				db 3 + 1 
5c7b .. 00			db "V0@",0              
5c7f				endm 
# End of macro CWHEAD
5c7f			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5c7f 2a 63 f9				ld hl, (cli_var_array) 
5c82 cd 5c 20				call forth_push_numhl 
5c85			 
5c85				       NEXTW 
5c85 c3 09 24			jp macro_next 
5c88				endm 
# End of macro NEXTW
5c88			.V1S: 
5c88				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5c88 7a				db WORD_SYS_CORE+102             
5c89 a0 5c			dw .V1Q            
5c8b 04				db 3 + 1 
5c8c .. 00			db "V1!",0              
5c90				endm 
# End of macro CWHEAD
5c90			;| V1! ( u1 -- )  Store value to v1 | DONE 
5c90					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c90 cd 53 22			call macro_dsp_valuehl 
5c93				endm 
# End of macro FORTH_DSP_VALUEHL
5c93			 
5c93 11 65 f9				ld de, cli_var_array+2 
5c96				 
5c96 eb					ex de, hl 
5c97 73					ld (hl), e 
5c98 23					inc hl 
5c99 72					ld (hl), d 
5c9a			 
5c9a					; destroy value TOS 
5c9a			 
5c9a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c9a cd 0b 23			call macro_forth_dsp_pop 
5c9d				endm 
# End of macro FORTH_DSP_POP
5c9d				       NEXTW 
5c9d c3 09 24			jp macro_next 
5ca0				endm 
# End of macro NEXTW
5ca0			.V1Q: 
5ca0				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5ca0 7b				db WORD_SYS_CORE+103             
5ca1 b1 5c			dw .V2S            
5ca3 04				db 3 + 1 
5ca4 .. 00			db "V1@",0              
5ca8				endm 
# End of macro CWHEAD
5ca8			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5ca8 2a 65 f9				ld hl, (cli_var_array+2) 
5cab cd 5c 20				call forth_push_numhl 
5cae				       NEXTW 
5cae c3 09 24			jp macro_next 
5cb1				endm 
# End of macro NEXTW
5cb1			.V2S: 
5cb1				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5cb1 7c				db WORD_SYS_CORE+104             
5cb2 c9 5c			dw .V2Q            
5cb4 04				db 3 + 1 
5cb5 .. 00			db "V2!",0              
5cb9				endm 
# End of macro CWHEAD
5cb9			;| V2! ( u1 -- )  Store value to v2 | DONE 
5cb9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5cb9 cd 53 22			call macro_dsp_valuehl 
5cbc				endm 
# End of macro FORTH_DSP_VALUEHL
5cbc			 
5cbc 11 67 f9				ld de, cli_var_array+4 
5cbf				 
5cbf eb					ex de, hl 
5cc0 73					ld (hl), e 
5cc1 23					inc hl 
5cc2 72					ld (hl), d 
5cc3			 
5cc3					; destroy value TOS 
5cc3			 
5cc3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cc3 cd 0b 23			call macro_forth_dsp_pop 
5cc6				endm 
# End of macro FORTH_DSP_POP
5cc6				       NEXTW 
5cc6 c3 09 24			jp macro_next 
5cc9				endm 
# End of macro NEXTW
5cc9			.V2Q: 
5cc9				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5cc9 7d				db WORD_SYS_CORE+105             
5cca da 5c			dw .V3S            
5ccc 04				db 3 + 1 
5ccd .. 00			db "V2@",0              
5cd1				endm 
# End of macro CWHEAD
5cd1			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5cd1 2a 67 f9				ld hl, (cli_var_array+4) 
5cd4 cd 5c 20				call forth_push_numhl 
5cd7				       NEXTW 
5cd7 c3 09 24			jp macro_next 
5cda				endm 
# End of macro NEXTW
5cda			.V3S: 
5cda				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5cda 7c				db WORD_SYS_CORE+104             
5cdb f2 5c			dw .V3Q            
5cdd 04				db 3 + 1 
5cde .. 00			db "V3!",0              
5ce2				endm 
# End of macro CWHEAD
5ce2			;| V3! ( u1 -- )  Store value to v3 | DONE 
5ce2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ce2 cd 53 22			call macro_dsp_valuehl 
5ce5				endm 
# End of macro FORTH_DSP_VALUEHL
5ce5			 
5ce5 11 69 f9				ld de, cli_var_array+6 
5ce8				 
5ce8 eb					ex de, hl 
5ce9 73					ld (hl), e 
5cea 23					inc hl 
5ceb 72					ld (hl), d 
5cec			 
5cec					; destroy value TOS 
5cec			 
5cec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5cec cd 0b 23			call macro_forth_dsp_pop 
5cef				endm 
# End of macro FORTH_DSP_POP
5cef				       NEXTW 
5cef c3 09 24			jp macro_next 
5cf2				endm 
# End of macro NEXTW
5cf2			.V3Q: 
5cf2				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5cf2 7d				db WORD_SYS_CORE+105             
5cf3 03 5d			dw .END            
5cf5 04				db 3 + 1 
5cf6 .. 00			db "V3@",0              
5cfa				endm 
# End of macro CWHEAD
5cfa			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5cfa 2a 69 f9				ld hl, (cli_var_array+6) 
5cfd cd 5c 20				call forth_push_numhl 
5d00				       NEXTW 
5d00 c3 09 24			jp macro_next 
5d03				endm 
# End of macro NEXTW
5d03			 
5d03			 
5d03			 
5d03			 
5d03			 
5d03			; end of dict marker 
5d03			 
5d03 00			.END:    db WORD_SYS_END 
5d04 00 00			dw 0 
5d06 00				db 0 
5d07			 
5d07			; use to jp here for user dict words to save on macro expansion  
5d07			 
5d07			user_dict_next: 
5d07				NEXTW 
5d07 c3 09 24			jp macro_next 
5d0a				endm 
# End of macro NEXTW
5d0a			 
5d0a			 
5d0a			user_exec: 
5d0a				;    ld hl, <word code> 
5d0a				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5d0a				;    call forthexec 
5d0a				;    jp user_dict_next   (NEXT) 
5d0a			        ;    <word code bytes> 
5d0a eb				ex de, hl 
5d0b 2a fd f3			ld hl,(os_tok_ptr) 
5d0e				 
5d0e				FORTH_RSP_NEXT 
5d0e cd 03 20			call macro_forth_rsp_next 
5d11				endm 
# End of macro FORTH_RSP_NEXT
5d11			 
5d11			if DEBUG_FORTH_UWORD 
5d11						DMARK "UEX" 
5d11 f5				push af  
5d12 3a 26 5d			ld a, (.dmark)  
5d15 32 a6 fd			ld (debug_mark),a  
5d18 3a 27 5d			ld a, (.dmark+1)  
5d1b 32 a7 fd			ld (debug_mark+1),a  
5d1e 3a 28 5d			ld a, (.dmark+2)  
5d21 32 a8 fd			ld (debug_mark+2),a  
5d24 18 03			jr .pastdmark  
5d26 ..			.dmark: db "UEX"  
5d29 f1			.pastdmark: pop af  
5d2a			endm  
# End of macro DMARK
5d2a				CALLMONITOR 
5d2a cd aa fd			call debug_vector  
5d2d				endm  
# End of macro CALLMONITOR
5d2d			endif 
5d2d			 
5d2d			 
5d2d			 
5d2d eb				ex de, hl 
5d2e 22 fd f3			ld (os_tok_ptr), hl 
5d31				 
5d31				; Don't use next - Skips the first word in uword. 
5d31			 
5d31 c3 9a 24			jp exec1 
5d34			;	NEXT 
5d34			 
5d34			 
5d34			; eof 
# End of file forth_wordsv4.asm
5d34			endif 
5d34			;;;;;;;;;;;;;; Debug code 
5d34			 
5d34			 
5d34			;if DEBUG_FORTH_PARSE 
5d34 .. 00		.nowordfound: db "No match",0 
5d3d .. 00		.compword:	db "Comparing word ",0 
5d4d .. 00		.nextwordat:	db "Next word at",0 
5d5a .. 00		.charmatch:	db "Char match",0 
5d65			;endif 
5d65			if DEBUG_FORTH_JP 
5d65			.foundword:	db "Word match. Exec..",0 
5d65			endif 
5d65			;if DEBUG_FORTH_PUSH 
5d65 .. 00		.enddict:	db "Dict end. Push.",0 
5d75 .. 00		.push_str:	db "Pushing string",0 
5d84 .. 00		.push_num:	db "Pushing number",0 
5d93 .. 00		.data_sp:	db "SP:",0 
5d97 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5da9 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5dbb .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5dcd			;endif 
5dcd			;if DEBUG_FORTH_MALLOC 
5dcd .. 00		.push_malloc:	db "Malloc address",0 
5ddc			;endif 
5ddc			 
5ddc			 
5ddc			 
5ddc			; display malloc address and current data stack pointer  
5ddc			 
5ddc			malloc_error: 
5ddc d5				push de 
5ddd f5				push af 
5dde e5				push hl 
5ddf cd 9b 0d			call clear_display 
5de2 11 02 5e			ld de, .mallocerr 
5de5 3e 00			ld a,0 
5de7			;	ld de,os_word_scratch 
5de7 cd ae 0d			call str_at_display 
5dea 3e 11			ld a, display_row_1+17 
5dec 11 a6 fd			ld de, debug_mark 
5def cd ae 0d			call str_at_display 
5df2 cd be 0d			call update_display 
5df5				;call break_point_state 
5df5 cd c5 79			call cin_wait 
5df8			 
5df8			;	ld a, ' ' 
5df8			;	ld (os_view_disable), a 
5df8 cd 8e 19			call bp_on 
5dfb e1				pop hl 
5dfc f1				pop af 
5dfd d1				pop de	 
5dfe				CALLMONITOR 
5dfe cd aa fd			call debug_vector  
5e01				endm  
# End of macro CALLMONITOR
5e01 c9				ret 
5e02			 
5e02 .. 00		.mallocerr: 	db "Malloc Error",0 
5e0f			;if DEBUG_FORTH_PUSH 
5e0f			display_data_sp: 
5e0f f5				push af 
5e10			 
5e10				; see if disabled 
5e10			 
5e10			 
5e10 3a aa fd			ld a, (debug_vector) 
5e13 fe c9			cp $C9  ; RET 
5e15				;ld a, (os_view_disable) 
5e15				;cp '*' 
5e15 28 67			jr z, .skipdsp 
5e17			 
5e17 e5				push hl 
5e18 e5				push hl 
5e19 e5			push hl 
5e1a cd 9b 0d			call clear_display 
5e1d e1			pop hl 
5e1e 7c				ld a,h 
5e1f 21 01 f4			ld hl, os_word_scratch 
5e22 cd 29 12			call hexout 
5e25 e1				pop hl 
5e26 7d				ld a,l 
5e27 21 03 f4			ld hl, os_word_scratch+2 
5e2a cd 29 12			call hexout 
5e2d 21 05 f4			ld hl, os_word_scratch+4 
5e30 3e 00			ld a,0 
5e32 77				ld (hl),a 
5e33 11 01 f4			ld de,os_word_scratch 
5e36 3e 28				ld a, display_row_2 
5e38 cd ae 0d				call str_at_display 
5e3b 11 97 5d			ld de, .wordinhl 
5e3e 3e 00			ld a, display_row_1 
5e40			 
5e40 cd ae 0d				call str_at_display 
5e43 11 a6 fd			ld de, debug_mark 
5e46 3e 11			ld a, display_row_1+17 
5e48			 
5e48 cd ae 0d				call str_at_display 
5e4b			 
5e4b				; display current data stack pointer 
5e4b 11 93 5d			ld de,.data_sp 
5e4e 3e 30				ld a, display_row_2 + 8 
5e50 cd ae 0d				call str_at_display 
5e53			 
5e53 2a 29 f9			ld hl,(cli_data_sp) 
5e56 e5				push hl 
5e57 7c				ld a,h 
5e58 21 01 f4			ld hl, os_word_scratch 
5e5b cd 29 12			call hexout 
5e5e e1				pop hl 
5e5f 7d				ld a,l 
5e60 21 03 f4			ld hl, os_word_scratch+2 
5e63 cd 29 12			call hexout 
5e66 21 05 f4			ld hl, os_word_scratch+4 
5e69 3e 00			ld a,0 
5e6b 77				ld (hl),a 
5e6c 11 01 f4			ld de,os_word_scratch 
5e6f 3e 33				ld a, display_row_2 + 11 
5e71 cd ae 0d				call str_at_display 
5e74			 
5e74			 
5e74 cd be 0d			call update_display 
5e77 cd de 0c			call delay1s 
5e7a cd de 0c			call delay1s 
5e7d e1				pop hl 
5e7e			.skipdsp: 
5e7e f1				pop af 
5e7f c9				ret 
5e80			 
5e80			display_data_malloc: 
5e80			 
5e80 f5				push af 
5e81 e5				push hl 
5e82 e5				push hl 
5e83 e5			push hl 
5e84 cd 9b 0d			call clear_display 
5e87 e1			pop hl 
5e88 7c				ld a,h 
5e89 21 01 f4			ld hl, os_word_scratch 
5e8c cd 29 12			call hexout 
5e8f e1				pop hl 
5e90 7d				ld a,l 
5e91 21 03 f4			ld hl, os_word_scratch+2 
5e94 cd 29 12			call hexout 
5e97 21 05 f4			ld hl, os_word_scratch+4 
5e9a 3e 00			ld a,0 
5e9c 77				ld (hl),a 
5e9d 11 01 f4			ld de,os_word_scratch 
5ea0 3e 28				ld a, display_row_2 
5ea2 cd ae 0d				call str_at_display 
5ea5 11 cd 5d			ld de, .push_malloc 
5ea8 3e 00			ld a, display_row_1 
5eaa			 
5eaa cd ae 0d				call str_at_display 
5ead			 
5ead				; display current data stack pointer 
5ead 11 93 5d			ld de,.data_sp 
5eb0 3e 30				ld a, display_row_2 + 8 
5eb2 cd ae 0d				call str_at_display 
5eb5			 
5eb5 2a 29 f9			ld hl,(cli_data_sp) 
5eb8 e5				push hl 
5eb9 7c				ld a,h 
5eba 21 01 f4			ld hl, os_word_scratch 
5ebd cd 29 12			call hexout 
5ec0 e1				pop hl 
5ec1 7d				ld a,l 
5ec2 21 03 f4			ld hl, os_word_scratch+2 
5ec5 cd 29 12			call hexout 
5ec8 21 05 f4			ld hl, os_word_scratch+4 
5ecb 3e 00			ld a,0 
5ecd 77				ld (hl),a 
5ece 11 01 f4			ld de,os_word_scratch 
5ed1 3e 33				ld a, display_row_2 + 11 
5ed3 cd ae 0d				call str_at_display 
5ed6			 
5ed6 cd be 0d			call update_display 
5ed9 cd de 0c			call delay1s 
5edc cd de 0c			call delay1s 
5edf e1				pop hl 
5ee0 f1				pop af 
5ee1 c9				ret 
5ee2			;endif 
5ee2			 
5ee2			include "forth_autostart.asm" 
5ee2			; list of commands to perform at system start up 
5ee2			 
5ee2			startcmds: 
5ee2			;	dw test11 
5ee2			;	dw test12 
5ee2			;	dw test13 
5ee2			;	dw test14 
5ee2			;	dw test15 
5ee2			;	dw test16 
5ee2			;	dw test17 
5ee2			;	dw ifthtest1 
5ee2			;	dw ifthtest2 
5ee2			;	dw ifthtest3 
5ee2			;	dw mmtest1 
5ee2			;	dw mmtest2 
5ee2			;	dw mmtest3 
5ee2			;	dw mmtest4 
5ee2			;	dw mmtest5 
5ee2			;	dw mmtest6 
5ee2			;	dw iftest1 
5ee2			;	dw iftest2 
5ee2			;	dw iftest3 
5ee2			;	dw looptest1 
5ee2			;	dw looptest2 
5ee2			;	dw test1 
5ee2			;	dw test2 
5ee2			;	dw test3 
5ee2			;	dw test4 
5ee2			;	dw game2r 
5ee2			;	dw game2b1 
5ee2			;	dw game2b2 
5ee2			 
5ee2				; start up words that are actually useful 
5ee2			 
5ee2			;    dw spi1 
5ee2			;    dw spi2 
5ee2			;    dw spi3 
5ee2			;    dw spi4 
5ee2			;    dw spi5 
5ee2			;    dw spi6 
5ee2			;    dw spi7 
5ee2			; 
5ee2			;    dw spi8 
5ee2			;    dw spi9 
5ee2			;    dw spi10 
5ee2			 
5ee2			; file editor 
5ee2			;	dw edit1 
5ee2			;	dw edit2 
5ee2			;	dw edit3 
5ee2			 
5ee2			;	dw longread 
5ee2 0c 63			dw clrstack 
5ee4 40 63			dw type 
5ee6			;	dw stest 
5ee6 65 63			dw strncpy 
5ee8			;	dw list 
5ee8 c6 63			dw start1 
5eea d6 63			dw start2 
5eec			;	dw start3 
5eec			;	dw start3b 
5eec			;	dw start3c 
5eec			 
5eec				; (unit) testing words 
5eec			 
5eec			;	dw mtesta 
5eec			;	dw mtestb 
5eec			;	dw mtestc 
5eec			;	dw mtestd 
5eec			;	dw mteste 
5eec			 
5eec				; demo/game words 
5eec			 
5eec			;        dw game3w 
5eec			;        dw game3p 
5eec			;        dw game3sc 
5eec			;        dw game3vsi 
5eec			;        dw game3vs 
5eec				 
5eec 2f 6e			dw game2b 
5eee 9d 6e			dw game2bf 
5ef0 e7 6e			dw game2mba 
5ef2 7d 6f			dw game2mbas 
5ef4 bf 6f			dw game2mb 
5ef6			 
5ef6 f0 6a			dw game1 
5ef8 01 6b			dw game1a 
5efa 63 6b			dw game1b 
5efc 98 6b			dw game1c 
5efe ce 6b			dw game1d 
5f00 ff 6b			dw game1s 
5f02 13 6c			dw game1t 
5f04 28 6c			dw game1f 
5f06 5c 6c			dw game1z 
5f08 a0 6c			dw game1zz 
5f0a			 
5f0a 0a 69			dw test5 
5f0c 42 69			dw test6 
5f0e 7a 69			dw test7 
5f10 8e 69			dw test8 
5f12 ba 69			dw test9 
5f14 d0 69			dw test10 
5f16				 
5f16 77 6d		        dw ssv5 
5f18 5b 6d		        dw ssv4 
5f1a 3f 6d		        dw ssv3 
5f1c 09 6d		        dw ssv2 
5f1e 90 6d		        dw ssv1 
5f20 d8 6d		        dw ssv1cpm 
5f22			;	dw keyup 
5f22			;	dw keydown 
5f22			;	dw keyleft 
5f22			;	dw keyright 
5f22			;	dw 	keyf1 
5f22			;	dw keyf2 
5f22			;	dw keyf3 
5f22			;	dw keyf4 
5f22			;	dw keyf5 
5f22			;	dw keyf6 
5f22			;	dw keyf7 
5f22			;	dw keyf8 
5f22			;	dw keyf9 
5f22			;	dw keyf10 
5f22			;	dw keyf11 
5f22			;	dw keyf12 
5f22			;	dw keytab 
5f22			;	dw keycr 
5f22			;	dw keyhome 
5f22			;	dw keyend 
5f22			;	dw keybs 
5f22 00 00			db 0, 0	 
5f24			 
5f24			 
5f24			; File Editor 
5f24			 
5f24			; ( id - ) use 'e' to edit the displayed line 
5f24 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5f45 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5f7a			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5f7a .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
5fb2			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5fb2			 
5fb2			; SPI Net support words 
5fb2			 
5fb2			; v0! = node to send to 
5fb2			; ( str count - ) 
5fb2 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
600b			 
600b			; spiputc ( char node - ) 
600b .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
603f			; spiputc ( u node - ) 
603f .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
606d			 
606d			; spigetc ( - n ) 
606d .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
6096			 
6096			; getnode ( - n ) 
6096 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
60c3			 
60c3			; ( str node - )  
60c3 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
6129			; store string ( str i - ) 
6129			 
6129			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
6129 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
617e			 
617e			; get string ( addr i -  )    TO FIX 
617e			 
617e .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
61d6			 
61d6			 
61d6			; NETCHAT (TODO) 
61d6			; Program to allow two nodes to chat with eachother 
61d6			; 
61d6			; v0 - target node 
61d6			;  
61d6			; accept input at 0,0 
61d6			; if input is string send spitype to target node 
61d6			; starting at row 2,0 , while spigetchr is not zero ->  
61d6			; 
61d6			; 
61d6			; TODO add paging of get request 
61d6			 
61d6			; ( node - ) 
61d6 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
61f5 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
624d .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
62c5			 
62c5			 
62c5			; Long read of currently open file 
62c5 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
630c			 
630c			; clear stack  
630c			 
630c .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
6340			 
6340			; type ( addr count - ) 
6340 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
6365			 
6365			; some direct memory words 
6365			; strncpy ( len t f -- t ) 
6365			 
6365 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
63c6			 
63c6 .. 00		start1:     	db ": bpon $00 bp ;",0 
63d6 .. 00		start2:     	db ": bpoff $01 bp ;",0 
63e7 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
6462 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
64c2			 
64c2			 
64c2			; a handy word to list items on the stack 
64c2			 
64c2 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
652c			 
652c			 
652c			; test stack  
652c			; rnd8 stest 
652c			 
652c .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
65a3			 
65a3			; random malloc and free cycles 
65a3			 
65a3 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6658			 
6658			; fixed malloc and free cycles 
6658			 
6658 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
66fb			 
66fb			; fixed double string push and drop cycle  
66fb			 
66fb .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
67b0			 
67b0			; consistent fixed string push and drop cycle  
67b0			 
67b0 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6854			 
6854 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
690a			 
690a			;test1:		db ": aa 1 2 3 ;", 0 
690a			;test2:     	db "111 aa 888 999",0 
690a			;test3:     	db ": bb 77 ;",0 
690a			;test4:     	db "$02 $01 do i . loop bb",0 
690a			 
690a .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
6942 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
697a .. 00		test7:     	db ": box hline vline ;",0 
698e .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
69ba .. 00		test9:     	db ": sw $01 adsp world ;",0 
69d0 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
69f5 .. 00		test11:     	db "hello create .",0 
6a04 .. 00		test12:     	db "hello2 create .",0 
6a14			 
6a14			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
6a14			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
6a14			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
6a14			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
6a14			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
6a14			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
6a14			 
6a14			;iftest1:     	db "$0001 IF cls .",0 
6a14			;iftest2:     	db "$0000 IF cls .",0 
6a14			;iftest3:     	db "$0002 $0003 - IF cls .",0 
6a14			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
6a14			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
6a14			 
6a14			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6a14			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6a14			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6a14			 
6a14			 
6a14 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
6a38 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
6a68 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
6a8d .. 00		sound4: db ": cha $00 ; ",0 
6a9a .. 00		sound5: db ": chb $20 ; ",0 
6aa7 .. 00		sound6: db ": chc $40 ; ",0 
6ab4 .. 00		sound7: db ": chd $60 ; ",0 
6ac1 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
6ad9 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
6af0			 
6af0			 
6af0			 
6af0			 
6af0			; a small guess the number game 
6af0			 
6af0 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6b01 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6b63			 
6b63 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6b98 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6bce .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6bff .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6c13 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6c28 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6c5c .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6ca0			 
6ca0			; Using 'ga' save a high score across multiple runs using external storage 
6ca0			 
6ca0 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6d09			 
6d09			 
6d09			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6d09			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6d09			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6d09			 
6d09			; simple screen saver to test code memory reuse to destruction 
6d09			 
6d09 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6d3f .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6d5b .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6d77 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6d90 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6dd8 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6e2f			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6e2f			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6e2f			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6e2f			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6e2f			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6e2f			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6e2f			 
6e2f			 
6e2f			 
6e2f			; minesweeper/battleship finding game 
6e2f			; draws a game board of random ship/mine positions 
6e2f			; user enters coords to see if it hits on 
6e2f			; game ends when all are hit 
6e2f			; when hit or miss says how many may be in the area 
6e2f			 
6e2f			; setup the game board and then hide it 
6e2f .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6e9d .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6ee7			; prompt for where to target 
6ee7 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6f7d .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6fa2			; TODO see if the entered coords hits or misses pushes char hit of miss 
6fa2 .. 00		game2mbht:      db ": mbckht nop ;",0 
6fb1 .. 00		game2mbms:      db ": mbcms nop ;",0 
6fbf			; TODO how many might be near by 
6fbf .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
703c			 
703c			; Game 3 
703c			 
703c			; Vert scroller ski game - avoid the trees! 
703c			 
703c			; v0 score (ie turns) 
703c			; v1 player pos 
703c			; v2 left wall 
703c			; v3 right wall 
703c			 
703c			; Draw side walls randomly 
703c			 
703c .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
706a			 
706a			; Draw player 
706a .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
7088			 
7088			; TODO Get Key 
7088			 
7088			; TODO Move left right 
7088			 
7088			; scroll and move walls a bit 
7088			 
7088 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
70b9			 
70b9			; main game loop 
70b9			 
70b9 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
70e5 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
7124			 
7124			; key board defs 
7124			 
7124 .. 00		keyup:       db ": keyup $05 ;",0 
7132 .. 00		keydown:       db ": keydown $0a ;",0 
7142 .. 00		keyleft:       db ": keyleft $0b ;",0 
7152 .. 00		keyright:       db ": keyright $0c ;",0 
7163 .. 00		keyf1:       db ": keyf1 $10 ;",0 
7171 .. 00		keyf2:       db ": keyf2 $11 ;",0 
717f .. 00		keyf3:       db ": keyf3 $12 ;",0 
718d .. 00		keyf4:       db ": keyf4 $13 ;",0 
719b .. 00		keyf5:       db ": keyf5 $14 ;",0 
71a9 .. 00		keyf6:       db ": keyf6 $15 ;",0 
71b7 .. 00		keyf7:       db ": keyf7 $16 ;",0 
71c5 .. 00		keyf8:       db ": keyf8 $17 ;",0 
71d3 .. 00		keyf9:       db ": keyf9 $18 ;",0 
71e1 .. 00		keyf10:       db ": keyf10 $19 ;",0 
71f0 .. 00		keyf11:       db ": keyf11 $1a ;",0 
71ff .. 00		keyf12:       db ": keyf12 $1b ;",0 
720e			 
720e .. 00		keytab:       db ": keytab $09 ;",0 
721d .. 00		keycr:       db ": keycr $0d ;",0 
722b .. 00		keyhome:       db ": keyhome $0e ;",0 
723b .. 00		keyend:       db ": keyend $0f ;",0 
724a .. 00		keybs:       db ": keybs $08 ;",0 
7258			 
7258			   
7258			 
7258			 
7258			 
7258			; eof 
# End of file forth_autostart.asm
7258			 
7258			 
7258			 
7258			; stack over and underflow checks 
7258			 
7258			; init the words to detect the under/overflow 
7258			 
7258			chk_stk_init: 
7258				; a vague random number to check so we dont get any "lucky" hits 
7258 3e 2d			ld a, 45 
725a 6f				ld l, a 
725b 00				nop 
725c 3e 17			ld a, 23 
725e 67				ld h, a 
725f			 
725f 22 d8 f0			ld (chk_word), hl     ; the word we need to check against 
7262			 
7262			;	ld (chk_stund), hl	; stack points.... 
7262 22 3b fe			ld (chk_stovr), hl 
7265 22 27 f9			ld (chk_ret_und), hl 
7268 22 e5 f8			ld (chk_ret_ovr), hl 
726b 22 63 f8			ld (chk_loop_ovr), hl 
726e 22 61 f6			ld (chk_data_ovr), hl 
7271 c9				ret 
7272				 
7272			check_stacks: 
7272				; check all stack words 
7272			 
7272 e5				push hl 
7273 d5				push de 
7274			 
7274			;	ld de,(chk_word) 
7274			;	ld hl, (chk_stund)	; stack points.... 
7274			;	if DEBUG_STK_FAULT 
7274			;		DMARK "FAa" 
7274			;		CALLMONITOR 
7274			;	endif 
7274			;	call cmp16 
7274			;	jp z, .chk_faulta 
7274			; 
7274			;	ld de, sfaultsu 
7274			;	jp .chk_fault 
7274			 
7274 2a 3b fe		.chk_faulta: ld hl, (chk_stovr) 
7277 ed 5b d8 f0		ld de,(chk_word) 
727b				if DEBUG_STK_FAULT 
727b					DMARK "FAb" 
727b					CALLMONITOR 
727b				endif 
727b cd ed 0f			call cmp16 
727e 28 06			jr z, .chk_fault1 
7280 11 21 73			ld de, sfaultso 
7283 c3 d5 72			jp .chk_fault 
7286			.chk_fault1:  
7286 2a 27 f9			ld hl, (chk_ret_und) 
7289 ed 5b d8 f0		ld de,(chk_word) 
728d				if DEBUG_STK_FAULT 
728d					DMARK "FAU" 
728d					CALLMONITOR 
728d				endif 
728d cd ed 0f			call cmp16 
7290 ca 99 72			jp z, .chk_fault2 
7293 11 31 73			ld de, sfaultru 
7296 c3 d5 72			jp .chk_fault 
7299			.chk_fault2:  
7299 2a e5 f8			ld hl, (chk_ret_ovr) 
729c ed 5b d8 f0		ld de,(chk_word) 
72a0				if DEBUG_STK_FAULT 
72a0					DMARK "FA1" 
72a0					CALLMONITOR 
72a0				endif 
72a0 cd ed 0f			call cmp16 
72a3 ca ac 72			jp z, .chk_fault3 
72a6 11 3f 73			ld de, sfaultro 
72a9 c3 d5 72			jp .chk_fault 
72ac			.chk_fault3:  
72ac 2a 63 f8			ld hl, (chk_loop_ovr) 
72af ed 5b d8 f0		ld de,(chk_word) 
72b3				if DEBUG_STK_FAULT 
72b3					DMARK "FA2" 
72b3					CALLMONITOR 
72b3				endif 
72b3 cd ed 0f			call cmp16 
72b6 ca bf 72			jp z, .chk_fault4 
72b9 11 59 73			ld de, sfaultlo 
72bc c3 d5 72			jp .chk_fault 
72bf			.chk_fault4:  
72bf 2a 61 f6			ld hl, (chk_data_ovr) 
72c2 ed 5b d8 f0		ld de,(chk_word) 
72c6				if DEBUG_STK_FAULT 
72c6					DMARK "FA3" 
72c6					CALLMONITOR 
72c6				endif 
72c6 cd ed 0f			call cmp16 
72c9 ca d2 72			jp z, .chk_fault5 
72cc 11 73 73			ld de, sfaultdo 
72cf c3 d5 72			jp .chk_fault 
72d2			 
72d2			 
72d2			.chk_fault5:  
72d2 d1				pop de 
72d3 e1				pop hl 
72d4			 
72d4 c9				ret 
72d5			 
72d5 cd 9b 0d		.chk_fault: 	call clear_display 
72d8 3e 28				ld a, display_row_2 
72da cd ae 0d				call str_at_display 
72dd 11 03 73				   ld de, .stackfault 
72e0 3e 00				ld a, display_row_1 
72e2 cd ae 0d				call str_at_display 
72e5 11 a6 fd				    ld de, debug_mark 
72e8 3e 11				ld a, display_row_1+17 
72ea cd ae 0d				call str_at_display 
72ed cd be 0d				call update_display 
72f0			 
72f0				; prompt before entering montior for investigating issue 
72f0			 
72f0 3e 78			ld a, display_row_4 
72f2 11 4e 1d			ld de, endprog 
72f5			 
72f5 cd be 0d			call update_display		 
72f8			 
72f8 cd d4 1f			call next_page_prompt 
72fb			 
72fb d1				pop de 
72fc e1				pop hl 
72fd cd a2 1d				call monitor 
7300 c3 ab 1c				jp warmstart 
7303					;jp 0 
7303					;halt 
7303			 
7303			 
7303			 
7303 .. 00		.stackfault: 	db "Stack fault:",0 
7310			 
7310 .. 00		sfaultsu: 	db	"Stack under flow",0 
7321 .. 00		sfaultso: 	db	"Stack over flow",0 
7331 .. 00		sfaultru:	db "RTS underflow",0 
733f .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
7359 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
7373 .. 00		sfaultdo:	db "DTS overflow", 0 
7380			 
7380			 
7380			fault_dsp_under: 
7380 11 92 73			ld de, .dsp_under 
7383 c3 42 74			jp .show_fault 
7386			 
7386			fault_rsp_under: 
7386 11 a0 73			ld de, .rsp_under 
7389 c3 42 74			jp .show_fault 
738c			fault_loop_under: 
738c 11 ae 73			ld de, .loop_under 
738f c3 42 74			jp .show_fault 
7392			 
7392 .. 00		.dsp_under: db "DSP Underflow",0 
73a0 .. 00		.rsp_under: db "RSP Underflow",0 
73ae .. 00		.loop_under: db "LOOP Underflow",0 
73bd			 
73bd			 
73bd d5			type_faultn: 	push de 
73be e5					push hl 
73bf cd 9b 0d				call clear_display 
73c2 11 e9 73				   ld de, .typefaultn 
73c5 3e 00				ld a, display_row_1 
73c7 cd ae 0d				call str_at_display 
73ca 11 a6 fd				    ld de, debug_mark 
73cd 3e 11				ld a, display_row_1+17 
73cf cd ae 0d				call str_at_display 
73d2 cd be 0d				call update_display 
73d5			 
73d5				; prompt before entering montior for investigating issue 
73d5			 
73d5 3e 78			ld a, display_row_4 
73d7 11 4e 1d			ld de, endprog 
73da			 
73da cd be 0d			call update_display		 
73dd			 
73dd cd d4 1f			call next_page_prompt 
73e0			 
73e0 e5					push hl 
73e1 d5					push de 
73e2 cd a2 1d				call monitor 
73e5 c3 ab 1c				jp warmstart 
73e8 76					halt 
73e9			 
73e9			 
73e9 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
7400			 
7400 d5			type_faults: 	push de 
7401 e5					push hl 
7402 cd 9b 0d				call clear_display 
7405 11 2b 74				   ld de, .typefaults 
7408 3e 00				ld a, display_row_1 
740a cd ae 0d				call str_at_display 
740d 11 a6 fd				    ld de, debug_mark 
7410 3e 11				ld a, display_row_1+17 
7412 cd ae 0d				call str_at_display 
7415 cd be 0d				call update_display 
7418			 
7418				; prompt before entering montior for investigating issue 
7418			 
7418 3e 78			ld a, display_row_4 
741a 11 4e 1d			ld de, endprog 
741d			 
741d cd be 0d			call update_display		 
7420			 
7420 cd d4 1f			call next_page_prompt 
7423			 
7423 e1					pop hl 
7424 d1					pop de 
7425 cd a2 1d				call monitor 
7428 c3 ab 1c				jp warmstart 
742b			 
742b			 
742b .. 00		.typefaults: db "STR Type Expected TOS!",0 
7442			 
7442			.show_fault: 	 
7442 d5					push de 
7443 cd 9b 0d				call clear_display 
7446 d1					pop de 
7447 3e 00				ld a, display_row_1 
7449 cd ae 0d				call str_at_display 
744c 11 a6 fd				    ld de, debug_mark 
744f 3e 11				ld a, display_row_1+17 
7451 cd ae 0d				call str_at_display 
7454 cd be 0d				call update_display 
7457			 
7457				; prompt before entering montior for investigating issue 
7457			 
7457 3e 78			ld a, display_row_4 
7459 11 4e 1d			ld de, endprog 
745c			 
745c cd be 0d			call update_display		 
745f			 
745f cd d4 1f			call next_page_prompt 
7462			 
7462 e1					pop hl 
7463 d1					pop de 
7464 cd a2 1d				call monitor 
7467			; do a dump to cli and not warmstart so we preserve all of the uwords.  
7467			; TODO Make optional fault restart to cli or warm boot? 
7467					;jp warmstart 
7467 c3 f5 1c				jp cli 
746a 76					halt 
746b			 
746b			; handle the auto run of code from files in storage 
746b			 
746b			 
746b			include "forth_startup.asm" 
746b			; Which startup method to use? 
746b			; 
746b			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
746b			; followed by loading of a list of scripts in eeprom 
746b			 
746b			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
746b			; from eeprom 
746b			 
746b			; Select with define in main stubs 
746b			 
746b			if STARTUP_V1 
746b				include "forth_startupv1.asm" 
746b			endif 
746b			if STARTUP_V2 
746b				include "forth_startupv2.asm" 
746b			; Version 2 of the startup  
746b			;  
746b			; Auto load any files in bank 1 that start with a '*' 
746b			; If no se storage then revert to using eprom 
746b			 
746b			 
746b			if STORAGE_SE = 0 
746b			 
746b			sprompt1: db "Startup load...",0 
746b			sprompt2: db "Run? 1=No *=End #=All",0 
746b			 
746b			 
746b			 
746b			 
746b			forth_startup: 
746b				ld hl, startcmds 
746b				ld a, 0 
746b				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
746b			 
746b			.start1:	push hl 
746b				call clear_display 
746b				ld de, sprompt1 
746b			        ld a, display_row_1 
746b				call str_at_display 
746b				ld de, sprompt2 
746b			        ld a, display_row_2 
746b				call str_at_display 
746b				pop hl 
746b				push hl 
746b				ld e,(hl) 
746b				inc hl 
746b				ld d,(hl) 
746b			        ld a, display_row_3 
746b				call str_at_display 
746b				call update_display 
746b			 
746b			 
746b				ld a, (os_last_cmd) 
746b				cp 0 
746b				jr z, .startprompt 
746b				call delay250ms 
746b				jr .startdo 
746b				 
746b				 
746b			 
746b			.startprompt: 
746b			 
746b				ld a,display_row_4 + display_cols - 1 
746b			        ld de, endprg 
746b				call str_at_display 
746b				call update_display 
746b				call delay1s 
746b				call cin_wait 
746b						 
746b				cp '*' 
746b				jr z, .startupend1 
746b				cp '#' 
746b				jr nz, .startno 
746b				ld a, 1 
746b				ld (os_last_cmd),a 
746b				jr .startdo 
746b			.startno:	cp '1' 
746b				jr z,.startnxt  
746b			 
746b				; exec startup line 
746b			.startdo:	 
746b				pop hl 
746b				push hl 
746b				 
746b				ld e,(hl) 
746b				inc hl 
746b				ld d,(hl) 
746b				ex de,hl 
746b			 
746b				push hl 
746b			 
746b				ld a, 0 
746b				;ld a, FORTH_END_BUFFER 
746b				call strlent 
746b				inc hl   ; include zero term to copy 
746b				ld b,0 
746b				ld c,l 
746b				pop hl 
746b				ld de, scratch 
746b				ldir 
746b			 
746b			 
746b				ld hl, scratch 
746b				call forthparse 
746b				call forthexec 
746b				call forthexec_cleanup 
746b			 
746b				ld a, display_row_4 
746b				ld de, endprog 
746b			 
746b				call update_display		 
746b			 
746b				ld a, (os_last_cmd) 
746b				cp 0 
746b				jr nz, .startnxt 
746b				call next_page_prompt 
746b			        call clear_display 
746b				call update_display		 
746b			 
746b				; move onto next startup line? 
746b			.startnxt: 
746b			 
746b				call delay250ms 
746b				pop hl 
746b			 
746b				inc hl 
746b				inc hl 
746b			 
746b				push hl 
746b				ld e, (hl) 
746b				inc hl 
746b				ld d, (hl) 
746b				pop hl 
746b				; TODO replace 0 test 
746b			 
746b				ex de, hl 
746b				call ishlzero 
746b			;	ld a,e 
746b			;	add d 
746b			;	cp 0    ; any left to do? 
746b				ex de, hl 
746b				jp nz, .start1 
746b				jr .startupend 
746b			 
746b			.startupend1: pop hl 
746b			.startupend: 
746b			 
746b				call clear_display 
746b				call update_display 
746b				ret 
746b			endif 
746b			 
746b			 
746b			if STORAGE_SE 
746b			 
746b			;sprompt3: db "Loading from start-up file:",0 
746b .. 00		sprompt3: db "  Searching...",0 
747a			;sprompt4: db "(Any key to stop)",0 
747a			 
747a			 
747a			forth_autoload: 
747a			 
747a				; load block 0 of store 1 
747a				 
747a 3e fe			ld a, $fe      ; bit 0 clear 
747c 32 9b f9			ld (spi_device), a 
747f			 
747f cd 16 05			call storage_get_block_0 
7482			 
7482 3a d6 f9			ld a, (store_page+STORE_0_AUTOFILE) 
7485			 
7485 fe 00			cp 0 
7487 c8				ret z     ; auto start not enabled 
7488			 
7488 cd 9b 0d			call clear_display 
748b			 
748b				; set bank 
748b			 
748b 3a d8 f9				ld a, (store_page+STORE_0_BANKRUN) 
748e 32 9b f9				ld (spi_device), a 
7491			 
7491			 
7491				; generate a directory of bank 1 and search for flagged files 
7491			 
7491					if DEBUG_FORTH_WORDS_KEY 
7491						DMARK "DIR" 
7491 f5				push af  
7492 3a a6 74			ld a, (.dmark)  
7495 32 a6 fd			ld (debug_mark),a  
7498 3a a7 74			ld a, (.dmark+1)  
749b 32 a7 fd			ld (debug_mark+1),a  
749e 3a a8 74			ld a, (.dmark+2)  
74a1 32 a8 fd			ld (debug_mark+2),a  
74a4 18 03			jr .pastdmark  
74a6 ..			.dmark: db "DIR"  
74a9 f1			.pastdmark: pop af  
74aa			endm  
# End of macro DMARK
74aa						CALLMONITOR 
74aa cd aa fd			call debug_vector  
74ad				endm  
# End of macro CALLMONITOR
74ad					endif 
74ad			 
74ad cd 16 05			call storage_get_block_0 
74b0			 
74b0 21 b5 f9			ld hl, store_page     ; get current id count 
74b3 46				ld b, (hl) 
74b4 0e 00			ld c, 0    ; count of files   
74b6					if DEBUG_FORTH_WORDS 
74b6						DMARK "DI1" 
74b6 f5				push af  
74b7 3a cb 74			ld a, (.dmark)  
74ba 32 a6 fd			ld (debug_mark),a  
74bd 3a cc 74			ld a, (.dmark+1)  
74c0 32 a7 fd			ld (debug_mark+1),a  
74c3 3a cd 74			ld a, (.dmark+2)  
74c6 32 a8 fd			ld (debug_mark+2),a  
74c9 18 03			jr .pastdmark  
74cb ..			.dmark: db "DI1"  
74ce f1			.pastdmark: pop af  
74cf			endm  
# End of macro DMARK
74cf						CALLMONITOR 
74cf cd aa fd			call debug_vector  
74d2				endm  
# End of macro CALLMONITOR
74d2					endif 
74d2			 
74d2				; check for empty drive 
74d2			 
74d2 3e 00			ld a, 0 
74d4 b8				cp b 
74d5 ca 22 75			jp z, .dirdone 
74d8			 
74d8				; for each of the current ids do a search for them and if found push to stack 
74d8			 
74d8 c5			.diritem:	push bc 
74d9 21 40 00				ld hl, STORE_BLOCK_PHY 
74dc 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
74de 58					ld e,b 
74df			 
74df d5					push de 
74e0 e5					push hl 
74e1 cd 9b 0d			call clear_display 
74e4 3e 32			ld a, display_row_2 + 10 
74e6 11 6b 74			ld de, sprompt3 
74e9 cd ae 0d			call str_at_display 
74ec cd f2 0c			call active 
74ef eb				ex de, hl 
74f0 3e 2f			ld a, display_row_2 + 7 
74f2 cd ae 0d			call str_at_display 
74f5 cd be 0d			call update_display 
74f8 e1				pop hl 
74f9 d1				pop de 
74fa			 
74fa			;		if DEBUG_FORTH_WORDS 
74fa			;			DMARK "DI2" 
74fa			;			CALLMONITOR 
74fa			;		endif 
74fa			 
74fa cd 98 07				call storage_findnextid 
74fd			 
74fd			;		if DEBUG_FORTH_WORDS 
74fd			;			DMARK "DI3" 
74fd			;			CALLMONITOR 
74fd			;		endif 
74fd			 
74fd					; if found hl will be non zero 
74fd			 
74fd cd f8 0f				call ishlzero 
7500			;		ld a, l 
7500			;		add h 
7500			; 
7500			;		cp 0 
7500 28 1d				jr z, .dirnotfound 
7502			 
7502					; increase count 
7502			 
7502 c1					pop bc	 
7503 0c					inc c 
7504 c5					push bc 
7505					 
7505			 
7505					; get file header and push the file name 
7505			 
7505 11 b5 f9				ld de, store_page 
7508 cd 65 04				call storage_read_block 
750b			 
750b					; push file id to stack 
750b				 
750b			 
750b					; is this a file we want to run? 
750b			 
750b 21 b8 f9				ld hl, store_page+3 
750e 7e					ld a,(hl) 
750f fe 2a				cp '*' 
7511 20 0c				jr nz,  .dirnotfound 
7513					 
7513			 
7513			 
7513 3a b5 f9				ld a, (store_page) 
7516 d5					push de 
7517 e5					push hl 
7518 c5					push bc 
7519 cd 45 75				call .autorunf 
751c c1					pop bc 
751d e1					pop hl 
751e d1					pop de 
751f			 
751f			 
751f			 
751f				; save this extent 
751f			 
751f					; push file name 
751f			;display file name to run 
751f			 
751f			;		ld hl, store_page+3 
751f			;		if DEBUG_FORTH_WORDS 
751f			;			DMARK "DI5" 
751f			;			CALLMONITOR 
751f			;		endif 
751f			; 
751f			;		 
751f			; 
751f			;		call forth_push_str 
751f			;		if DEBUG_FORTH_WORDS 
751f			;			DMARK "DI6" 
751f			;			CALLMONITOR 
751f			;		endif 
751f			.dirnotfound: 
751f c1					pop bc     
7520 10 b6				djnz .diritem 
7522				 
7522			.dirdone:	 
7522					if DEBUG_FORTH_WORDS 
7522						DMARK "DI7" 
7522 f5				push af  
7523 3a 37 75			ld a, (.dmark)  
7526 32 a6 fd			ld (debug_mark),a  
7529 3a 38 75			ld a, (.dmark+1)  
752c 32 a7 fd			ld (debug_mark+1),a  
752f 3a 39 75			ld a, (.dmark+2)  
7532 32 a8 fd			ld (debug_mark+2),a  
7535 18 03			jr .pastdmark  
7537 ..			.dmark: db "DI7"  
753a f1			.pastdmark: pop af  
753b			endm  
# End of macro DMARK
753b						CALLMONITOR 
753b cd aa fd			call debug_vector  
753e				endm  
# End of macro CALLMONITOR
753e					endif 
753e			 
753e cd 9b 0d				call clear_display 
7541 cd be 0d				call update_display 
7544			 
7544 c9					ret 
7545			 
7545			 
7545			 
7545			 
7545			 
7545			.autorunf: 
7545			 
7545			 
7545				; get file id to load from and get the file name to display 
7545			 
7545			;		ld a, (store_page+STORE_0_FILERUN) 
7545			 
7545 2e 00				ld l, 0 
7547 67					ld h, a 
7548 11 b5 f9				ld de, store_page 
754b			 
754b					if DEBUG_FORTH_WORDS 
754b						DMARK "ASp" 
754b f5				push af  
754c 3a 60 75			ld a, (.dmark)  
754f 32 a6 fd			ld (debug_mark),a  
7552 3a 61 75			ld a, (.dmark+1)  
7555 32 a7 fd			ld (debug_mark+1),a  
7558 3a 62 75			ld a, (.dmark+2)  
755b 32 a8 fd			ld (debug_mark+2),a  
755e 18 03			jr .pastdmark  
7560 ..			.dmark: db "ASp"  
7563 f1			.pastdmark: pop af  
7564			endm  
# End of macro DMARK
7564						CALLMONITOR 
7564 cd aa fd			call debug_vector  
7567				endm  
# End of macro CALLMONITOR
7567					endif 
7567 cd be 09				call storage_read 
756a			 
756a					if DEBUG_FORTH_WORDS 
756a						DMARK "ASr" 
756a f5				push af  
756b 3a 7f 75			ld a, (.dmark)  
756e 32 a6 fd			ld (debug_mark),a  
7571 3a 80 75			ld a, (.dmark+1)  
7574 32 a7 fd			ld (debug_mark+1),a  
7577 3a 81 75			ld a, (.dmark+2)  
757a 32 a8 fd			ld (debug_mark+2),a  
757d 18 03			jr .pastdmark  
757f ..			.dmark: db "ASr"  
7582 f1			.pastdmark: pop af  
7583			endm  
# End of macro DMARK
7583						CALLMONITOR 
7583 cd aa fd			call debug_vector  
7586				endm  
# End of macro CALLMONITOR
7586					endif 
7586			 
7586 cd f8 0f				call ishlzero 
7589 c8					ret z             ; file not found 
758a			 
758a					; display file name we are loading 
758a			 
758a cd 9b 0d				call clear_display 
758d			 
758d 3e 32				ld a, display_row_2 + 10 
758f 11 b8 f9				ld de, store_page+3 
7592 cd ae 0d				call str_at_display 
7595				 
7595			; 
7595			 
7595			;	ld a, display_row_1+5 
7595			;	ld de, sprompt3 
7595			;	call str_at_display 
7595			;	ld a, display_row_2+7 
7595			;	call active 
7595			;	ex de, hl 
7595			;;	ld de, sprompt4 
7595			;	call str_at_display 
7595			; 
7595 cd be 0d			call update_display 
7598			 
7598			;	call cin_wait 
7598			;	cp 'n' 
7598			;	ret z 
7598			;	cp 'N' 
7598			;	ret z 
7598			 
7598			;	call delay1s 
7598			 
7598 3a b7 f9			ld a, (store_page+2) 
759b 32 a4 f9			ld (store_openmaxext), a    ; save count of ext 
759e 3e 01			ld a, 1  
75a0 32 a5 f9			ld (store_openext), a    ; save count of ext 
75a3			 
75a3			.autof: 
75a3				; begin to read a line from file 
75a3			 
75a3 21 23 f4			ld hl, os_cli_cmd 
75a6 22 21 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
75a9			  
75a9			.readext: 
75a9 3a a5 f9			ld a, (store_openext) 
75ac 6f				ld l , a 
75ad				 
75ad 3a b5 f9			ld a, (store_page) 
75b0 67				ld h, a	 
75b1 11 b5 f9			ld de, store_page 
75b4					if DEBUG_FORTH_WORDS 
75b4						DMARK "ASl" 
75b4 f5				push af  
75b5 3a c9 75			ld a, (.dmark)  
75b8 32 a6 fd			ld (debug_mark),a  
75bb 3a ca 75			ld a, (.dmark+1)  
75be 32 a7 fd			ld (debug_mark+1),a  
75c1 3a cb 75			ld a, (.dmark+2)  
75c4 32 a8 fd			ld (debug_mark+2),a  
75c7 18 03			jr .pastdmark  
75c9 ..			.dmark: db "ASl"  
75cc f1			.pastdmark: pop af  
75cd			endm  
# End of macro DMARK
75cd						CALLMONITOR 
75cd cd aa fd			call debug_vector  
75d0				endm  
# End of macro CALLMONITOR
75d0					endif 
75d0 cd be 09				call storage_read 
75d3 cd f8 0f			call ishlzero 
75d6 c8				ret z 
75d7			 
75d7			; TODO copy to exec buffer 
75d7			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
75d7			 
75d7				; copy the record buffer to the cli buffer 
75d7			 
75d7 ed 5b 21 f6		ld de, (os_var_array) 
75db 21 b7 f9			ld hl, store_page+2 
75de			;	ex de, hl 
75de 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
75e1 ed b0			ldir 
75e3 ed 53 21 f6		ld (os_var_array), de 
75e7				 
75e7 3a a5 f9			ld a, (store_openext) 
75ea 3c				inc a 
75eb 32 a5 f9			ld (store_openext), a    ; save count of ext 
75ee			 
75ee			 
75ee			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
75ee				 
75ee 3a a8 f9			ld a, (store_readcont) 
75f1 fe 00			cp 0 
75f3 20 b4			jr nz, .readext 
75f5			 
75f5			;	jr z, .autoend 
75f5			 
75f5					if DEBUG_FORTH_WORDS 
75f5						DMARK "ASc" 
75f5 f5				push af  
75f6 3a 0a 76			ld a, (.dmark)  
75f9 32 a6 fd			ld (debug_mark),a  
75fc 3a 0b 76			ld a, (.dmark+1)  
75ff 32 a7 fd			ld (debug_mark+1),a  
7602 3a 0c 76			ld a, (.dmark+2)  
7605 32 a8 fd			ld (debug_mark+2),a  
7608 18 03			jr .pastdmark  
760a ..			.dmark: db "ASc"  
760d f1			.pastdmark: pop af  
760e			endm  
# End of macro DMARK
760e						CALLMONITOR 
760e cd aa fd			call debug_vector  
7611				endm  
# End of macro CALLMONITOR
7611					endif 
7611 e5				push hl	 
7612 d5				push de 
7613 cd f2 0c			call active 
7616 eb				ex de, hl 
7617 3e 2f			ld a, display_row_2 + 7 
7619 cd ae 0d			call str_at_display 
761c			 
761c cd be 0d			call update_display 
761f d1				pop de  
7620 e1				pop hl 
7621			;	call delay250ms 
7621			 
7621			 
7621			 
7621			 
7621			.autoexec: 
7621			 
7621			 
7621 21 23 f4			ld hl, os_cli_cmd 
7624					if DEBUG_FORTH_WORDS 
7624						DMARK "ASx" 
7624 f5				push af  
7625 3a 39 76			ld a, (.dmark)  
7628 32 a6 fd			ld (debug_mark),a  
762b 3a 3a 76			ld a, (.dmark+1)  
762e 32 a7 fd			ld (debug_mark+1),a  
7631 3a 3b 76			ld a, (.dmark+2)  
7634 32 a8 fd			ld (debug_mark+2),a  
7637 18 03			jr .pastdmark  
7639 ..			.dmark: db "ASx"  
763c f1			.pastdmark: pop af  
763d			endm  
# End of macro DMARK
763d						CALLMONITOR 
763d cd aa fd			call debug_vector  
7640				endm  
# End of macro CALLMONITOR
7640					endif 
7640 cd 57 24			call forthparse 
7643 cd 97 24			call forthexec 
7646 cd a9 23			call forthexec_cleanup 
7649			 
7649			 
7649			 
7649 c3 a3 75			jp .autof 
764c			;.autofdone: 
764c			; 
764c			;		if DEBUG_FORTH_WORDS 
764c			;			DMARK "ASx" 
764c			;			CALLMONITOR 
764c			;		endif 
764c			;;	call clear_display 
764c			;	ret 
764c			 
764c			 
764c			 
764c			endif 
# End of file forth_startupv2.asm
764c			endif 
764c			 
# End of file forth_startup.asm
764c			 
764c			; eof 
# End of file forth_kernel.asm
764c			;include "nascombasic.asm" 
764c			 
764c			 
764c			; find out where the code ends if loaded into RAM (for SC114) 
764c			;endofcode:  
764c			;	nop 
764c			 
764c			 
764c			; jump to nmi vector 
764c			 
764c			init_nmi: 
764c 3e c9			ld a, $c9   ; RET 
764e 32 ad fd			ld (nmi_vector), a 
7651 c9				ret 
7652			nmi: 
7652 e5				push hl 
7653 d5				push de 
7654 c5				push bc 
7655 f5				push af 
7656 cd ad fd			call nmi_vector 
7659 f5				push af 
765a c5				push bc 
765b d5				push de 
765c e5				push hl 
765d ed 4d			reti 
765f			 
765f			 
765f			; eof 
765f			 
# End of file main.asm
765f			include "firmware_lcd_4x40.asm" 
765f			; **********************************************************************  
765f			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
765f			; **********************************************************************  
765f			;  
765f			; **  Written as a Small Computer Monitor App  
765f			; **  www.scc.me.uk  
765f			;  
765f			; History  
765f			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
765f			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
765f			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
765f			;  
765f			; **********************************************************************  
765f			;  
765f			; This program is an example of one of the methods of interfacing an   
765f			; alphanumeric LCD module.   
765f			;  
765f			; In this example the display is connected to either a Z80 PIO or a   
765f			; simple 8-bit output port.   
765f			;  
765f			; This interfacing method uses 4-bit data mode and uses time delays  
765f			; rather than polling the display's ready status. As a result the   
765f			; interface only requires 6 simple output lines:  
765f			;   Output bit 0 = not used  
765f			;   Output bit 1 = not used  
765f			;   Output bit 2 = RS         High = data, Low = instruction  
765f			;   Output bit 3 = E          Active high  
765f			;   Output bit 4 = DB4  
765f			;   Output bit 5 = DB5  
765f			;   Output bit 6 = DB6  
765f			;   Output bit 7 = DB7  
765f			; Display's R/W is connected to 0v so it is always in write mode  
765f			;  
765f			; This set up should work with any system supporting the RC2014 bus  
765f			  
765f			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
765f			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
765f			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
765f			;  
765f			; **********************************************************************  
765f			  
765f			; Additonal for 4x40. E1 and E2 instead of just E   
765f			; TODO swipe vidout signal on port a to activate E2  
765f			  
765f			; **********************************************************************  
765f			; **  Constants  
765f			; **********************************************************************  
765f			; LCD constants required by LCD support module  
765f			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
765f			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
765f			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
765f			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
765f			; TODO Decide which E is being set  
765f			kLCDWidth:  EQU display_cols             ;Width in characters  
765f			  
765f			; **********************************************************************  
765f			; **  Code library usage  
765f			; **********************************************************************  
765f			  
765f			; send character to current cursor position  
765f			; wraps and/or scrolls screen automatically  
765f			  
765f			  
765f			  
765f			lcd_init:  
765f			  
765f			; SCMonAPI functions used  
765f			  
765f			; Alphanumeric LCD functions used  
765f			; no need to specify specific functions for this module  
765f			  
765f 3e cf		            LD   A, 11001111b  
7661 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
7663 3e 00		            LD   A, 00000000b  
7665 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
7667			  
7667			; Initialise alphanumeric LCD module  
7667 3e 00				ld a, 0  
7669 32 06 fb				ld (display_lcde1e2), a  
766c cd ed 76		            CALL fLCD_Init      ;Initialise LCD module  
766f 3e 01				ld a, 1  
7671 32 06 fb				ld (display_lcde1e2), a  
7674 cd ed 76		            CALL fLCD_Init      ;Initialise LCD module  
7677			  
7677 c9				ret  
7678			  
7678			;  
7678			;;  
7678			; lcd functions  
7678			;  
7678			;  
7678			  
7678			; what is at cursor position   
7678			  
7678			;get_cursor:	ld de, (cursor_row)   ;  row + col  
7678			;		call curptr  
7678			;		ret  
7678			  
7678			  
7678			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
7678			  
7678			curptr:  
7678 c5				push bc  
7679 21 ec fc			ld hl, display_fb0  
767c			cpr:	  
767c				; loop for cursor whole row  
767c 0e 28			ld c, display_cols  
767e 23			cpr1:	inc hl  
767f 0d				dec c  
7680 20 fc			jr nz, cpr1  
7682 05				dec b  
7683 20 f7			jr nz, cpr  
7685			  
7685				; add col	  
7685			  
7685 23			cpr2:	inc hl  
7686 1d				dec e  
7687 20 fc			jr nz, cpr2  
7689			  
7689 c1				pop bc  
768a c9				ret  
768b				  
768b			  
768b			  
768b			  
768b			  
768b			; write the frame buffer given in hl to hardware   
768b 22 04 fb		write_display: ld (display_write_tmp), hl 	   
768e 3e 00			ld a, kLCD_Line1  
7690 cd 9a 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7693 06 28			ld b, display_cols  
7695 ed 5b 04 fb		ld de, (display_write_tmp)  
7699 cd e5 76			call write_len_string  
769c				  
769c				  
769c 2a 04 fb			ld hl, (display_write_tmp)  
769f 11 28 00			ld de, display_cols  
76a2 19				add hl,de  
76a3 22 04 fb			ld (display_write_tmp),hl  
76a6			  
76a6				  
76a6 3e 28			ld a, kLCD_Line2  
76a8 cd 9a 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76ab 06 28			ld b, display_cols  
76ad ed 5b 04 fb		ld de, (display_write_tmp)  
76b1 cd e5 76			call write_len_string  
76b4				  
76b4 2a 04 fb			ld hl, (display_write_tmp)  
76b7 11 28 00			ld de, display_cols  
76ba 19				add hl,de  
76bb 22 04 fb			ld (display_write_tmp),hl  
76be			  
76be				  
76be 3e 50			ld a, kLCD_Line3  
76c0 cd 9a 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76c3 06 28			ld b, display_cols  
76c5 ed 5b 04 fb		ld de, (display_write_tmp)  
76c9 cd e5 76			call write_len_string  
76cc				  
76cc 2a 04 fb			ld hl, (display_write_tmp)  
76cf 11 28 00			ld de, display_cols  
76d2 19				add hl,de  
76d3 22 04 fb			ld (display_write_tmp),hl  
76d6			  
76d6				  
76d6 3e 78			ld a, kLCD_Line4  
76d8 cd 9a 77		            CALL fLCD_Pos       ;Position cursor to location in A  
76db 06 28			ld b, display_cols  
76dd ed 5b 04 fb		ld de, (display_write_tmp)  
76e1 cd e5 76			call write_len_string  
76e4 c9					ret  
76e5				  
76e5				; write out a fixed length string given in b from de  
76e5			  
76e5 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
76e6 cd 52 77		            CALL fLCD_Data      ;Write character to display  
76e9 13				inc de  
76ea 10 f9			djnz write_len_string  
76ec c9				ret  
76ed			  
76ed			; Some other things to do  
76ed			;            LD   A, kLCD_Clear ;Display clear  
76ed			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
76ed			;            LD   A, kLCD_Under ;Display on with underscore cursor  
76ed			;            LD   A, kLCD_On     ;Display on with no cursor  
76ed			;            ;LD   A, kLCD_Off   ;Display off  
76ed			;            CALL fLCD_Inst      ;Send instruction to display  
76ed			;  
76ed			;  
76ed			;            halt  
76ed			;  
76ed			;  
76ed			;MsgHello:   DB  "Hello World!",0  
76ed			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
76ed			  
76ed			; Custom characters 5 pixels wide by 8 pixels high  
76ed			; Up to 8 custom characters can be defined  
76ed			;BitMaps:      
76ed			;; Character 0x00 = Battery icon  
76ed			;            DB  01110b  
76ed			;            DB  11011b  
76ed			;            DB  10001b  
76ed			;            DB  10001b  
76ed			;            DB  11111b  
76ed			;            DB  11111b  
76ed			;            DB  11111b  
76ed			;            DB  11111b  
76ed			;; Character 0x01 = Bluetooth icon  
76ed			;            DB  01100b  
76ed			;            DB  01010b  
76ed			;            DB  11100b  
76ed			;            DB  01000b  
76ed			;            DB  11100b  
76ed			;            DB  01010b  
76ed			;            DB  01100b  
76ed			;            DB  00000b  
76ed			;  
76ed			  
76ed			  
76ed			; **********************************************************************  
76ed			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
76ed			; **********************************************************************  
76ed			;  
76ed			; **  Written as a Small Computer Monitor App   
76ed			; **  Version 0.1 SCC 2018-05-16  
76ed			; **  www.scc.me.uk  
76ed			;  
76ed			; **********************************************************************  
76ed			;  
76ed			; This module provides support for alphanumeric LCD modules using with  
76ed			; *  HD44780 (or compatible) controller  
76ed			; *  5 x 7 pixel fonts  
76ed			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
76ed			; *  Interface via six digital outputs to the display (see below)  
76ed			;  
76ed			; LCD module pinout:  
76ed			;   1  Vss   0v supply  
76ed			;   2  Vdd   5v supply  
76ed			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
76ed			;   4  RS    High = data, Low = instruction  
76ed			;   5  R/W   High = Read, Low = Write  
76ed			;   6  E     Enable signal (active high)  
76ed			;   7  DB0   Data bit 0  
76ed			;   8  DB1   Data bit 1  
76ed			;   9  DB2   Data bit 2  
76ed			;  10  DB3   Data bit 3  
76ed			;  11  DB4   Data bit 4  
76ed			;  12  DB5   Data bit 5  
76ed			;  13  DB6   Data bit 6  
76ed			;  14  DB7   Data bit 7  
76ed			;  15  A     Backlight anode (+)  
76ed			;  16  K     Backlight cathode (-)  
76ed			;  
76ed			; This interfacing method uses 4-bit data mode and uses time delays  
76ed			; rather than polling the display's ready status. As a result the   
76ed			; interface only requires 6 simple output lines:  
76ed			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
76ed			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
76ed			;   LCD DB4 = Microcomputer output port bit 4  
76ed			;   LCD DB5 = Microcomputer output port bit 5  
76ed			;   LCD DB6 = Microcomputer output port bit 6  
76ed			;   LCD DB7 = Microcomputer output port bit 7  
76ed			; Display's R/W is connected to 0v so it is always in write mode  
76ed			; All 6 connections must be on the same port address <kLCDPrt>  
76ed			; This method also allows a decent length of cable from micro to LCD  
76ed			;  
76ed			; **********************************************************************  
76ed			;  
76ed			; To include the code for any given function provided by this module,   
76ed			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
76ed			; the parent source file.  
76ed			; For example:  #REQUIRES   uHexPrefix  
76ed			;  
76ed			; Also #INCLUDE this file at some point after the #REQUIRES statements  
76ed			; in the parent source file.  
76ed			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
76ed			;  
76ed			; These are the function names provided by this module:  
76ed			; fLCD_Init                     ;Initialise LCD  
76ed			; fLCD_Inst                     ;Send instruction to LCD  
76ed			; fLCD_Data                     ;Send data byte to LCD  
76ed			; fLCD_Pos                      ;Position cursor  
76ed			; fLCD_Str                      ;Display string  
76ed			; fLCD_Def                      ;Define custom character  
76ed			;  
76ed			; **********************************************************************  
76ed			;  
76ed			; Requires SCMonAPI.asm to also be included in the project  
76ed			;  
76ed			  
76ed			  
76ed			; **********************************************************************  
76ed			; **  Constants  
76ed			; **********************************************************************  
76ed			  
76ed			; Constants that must be defined externally  
76ed			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
76ed			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
76ed			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
76ed			;kLCDWidth: EQU 20             ;Width in characters  
76ed			  
76ed			; general line offsets in any frame buffer  
76ed			  
76ed			  
76ed			display_row_1: equ 0  
76ed			display_row_2: equ display_row_1+display_cols  
76ed			display_row_3: equ display_row_2 + display_cols  
76ed			display_row_4: equ display_row_3 + display_cols  
76ed			;display_row_4_eol:   
76ed			  
76ed			  
76ed			; Cursor position values for the start of each line  
76ed			  
76ed			; E  
76ed			kLCD_Line1: EQU 0x00   
76ed			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
76ed			; E1  
76ed			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
76ed			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
76ed			  
76ed			; Instructions to send as A register to fLCD_Inst  
76ed			kLCD_Clear: EQU 00000001b     ;LCD clear  
76ed			kLCD_Off:   EQU 00001000b     ;LCD off  
76ed			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
76ed			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
76ed			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
76ed			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
76ed			  
76ed			; Constants used by this code module  
76ed			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
76ed			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
76ed			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
76ed			  
76ed			  
76ed			  
76ed			; **********************************************************************  
76ed			; **  LCD support functions  
76ed			; **********************************************************************  
76ed			  
76ed			; Initialise alphanumeric LCD module  
76ed			; LCD control register codes:  
76ed			;   DL   0 = 4-bit mode        1 = 8-bit mode  
76ed			;   N    0 = 1-line mode       1 = 2-line mode  
76ed			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
76ed			;   D    0 = Display off       1 = Display on  
76ed			;   C    0 = Cursor off        1 = Cursor on  
76ed			;   B    0 = Blinking off      1 = Blinking on  
76ed			;   ID   0 = Decrement mode    1 = Increment mode  
76ed			;   SH   0 = Entire shift off  1 = Entire shift on  
76ed 3e 28		fLCD_Init:  LD   A, 40  
76ef cd 14 78		            CALL LCDDelay       ;Delay 40ms after power up  
76f2			; For reliable reset set 8-bit mode - 3 times  
76f2 cd e4 77		            CALL WrFn8bit       ;Function = 8-bit mode  
76f5 cd e4 77		            CALL WrFn8bit       ;Function = 8-bit mode  
76f8 cd e4 77		            CALL WrFn8bit       ;Function = 8-bit mode  
76fb			; Set 4-bit mode  
76fb cd e0 77		            CALL WrFn4bit       ;Function = 4-bit mode  
76fe cd 12 78		            CALL LCDDelay1      ;Delay 37 us or more  
7701			; Function set  
7701 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
7703 cd 16 77		            CALL fLCD_Inst      ;2 line, display on  
7706			; Display On/Off control  
7706 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
7708 cd 16 77		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
770b			; Display Clear  
770b 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
770d cd 16 77		            CALL fLCD_Inst      ;Clear display  
7710			; Entry mode  
7710 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
7712 cd 16 77		            CALL fLCD_Inst      ;Increment mode, shift off  
7715			; Display module now initialised  
7715 c9			            RET  
7716			; ok to here  
7716			  
7716			; Write instruction to LCD  
7716			;   On entry: A = Instruction byte to be written  
7716			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7716 f5			fLCD_Inst:  PUSH AF  
7717 f5			            PUSH AF  
7718 cd 2a 77		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
771b f1			            POP  AF  
771c 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
771d 17			            RLA  
771e 17			            RLA  
771f 17			            RLA  
7720 cd 2a 77		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
7723 3e 02		            LD   A, 2  
7725 cd 14 78		            CALL LCDDelay       ;Delay 2 ms to complete   
7728 f1			            POP  AF  
7729 c9			            RET  
772a			Wr4bits:   
772a f5					push af  
772b 3a 06 fb				ld a, (display_lcde1e2)  
772e fe 00				cp 0     ; e  
7730 20 10				jr nz, .wea2	  
7732 f1					pop af  
7733 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7735 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7737 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
7739 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
773b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
773d cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
773f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7741 c9			            RET  
7742 f1			.wea2:		pop af  
7743 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7745 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7747 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
7749 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
774b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
774d cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
774f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7751 c9			            RET  
7752			  
7752			  
7752			; Write data to LCD  
7752			;   On entry: A = Data byte to be written  
7752			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7752 f5			fLCD_Data:  PUSH AF  
7753 f5			            PUSH AF  
7754 cd 66 77		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
7757 f1			            POP  AF  
7758 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7759 17			            RLA  
775a 17			            RLA  
775b 17			            RLA  
775c cd 66 77		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
775f 3e 96		            LD   A, 150  
7761 3d			Wait:      DEC  A              ;Wait a while to allow data   
7762 20 fd		            JR   NZ, Wait      ;  write to complete  
7764 f1			            POP  AF  
7765 c9			            RET  
7766			Wr4bitsa:     
7766 f5					push af  
7767 3a 06 fb				ld a, (display_lcde1e2)  
776a fe 00				cp 0     ; e1  
776c 20 16				jr nz, .we2	  
776e f1					pop af  
776f e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7771 cb d7		            SET  kLCDBitRS, A  
7773 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7775 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
7777 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
7779 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
777b cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
777d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
777f cb 97		            RES  kLCDBitRS, A  
7781 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7783 c9			            RET  
7784 f1			.we2:		pop af  
7785 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7787 cb d7		            SET  kLCDBitRS, A  
7789 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
778b cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
778d cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
778f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7791 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
7793 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7795 cb 97		            RES  kLCDBitRS, A  
7797 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7799 c9			            RET  
779a			  
779a			  
779a			; Position cursor to specified location  
779a			;   On entry: A = Cursor position  
779a			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
779a f5			fLCD_Pos:   PUSH AF  
779b					; at this point set the E1 or E2 flag depending on position  
779b			  
779b c5					push bc  
779c			;		push af  
779c 06 00				ld b, 0  
779e 4f					ld c, a  
779f 3e 4f				ld a, kLCD_Line3-1  
77a1 b7			 		or a      ;clear carry flag  
77a2 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
77a3 38 04				jr c, .pe1  
77a5			  
77a5					; E selection  
77a5 cb 80				res 0, b         ; bit 0 unset e  
77a7			;		pop af    ; before line 3 so recover orig pos  
77a7			;		ld c, a    ; save for poking back  
77a7 18 06				jr .peset	          
77a9			.pe1:          	; E2 selection  
77a9 cb c0				set 0, b         ; bit 0 set e1  
77ab 79					ld a, c  
77ac de 4f				sbc a, kLCD_Line3-1  
77ae 4f					ld c, a	         ; save caculated offset  
77af			;		pop af     ; bin this original value now we have calculated form  
77af			  
77af			.peset:		; set bit  
77af 78					ld a, b  
77b0 32 06 fb				ld (display_lcde1e2), a 	  
77b3 79					ld a, c  
77b4 c1					pop bc  
77b5			  
77b5 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
77b7 cd 16 77		            CALL fLCD_Inst      ;Write instruction to LCD  
77ba f1			            POP  AF  
77bb c9			            RET  
77bc			  
77bc			  
77bc			; Output text string to LCD  
77bc			;   On entry: DE = Pointer to null terminated text string  
77bc			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
77bc 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
77bd b7			            OR   A              ;Null terminator?  
77be c8			            RET  Z              ;Yes, so finished  
77bf cd 52 77		            CALL fLCD_Data      ;Write character to display  
77c2 13			            INC  DE             ;Point to next character  
77c3 18 f7		            JR   fLCD_Str       ;Repeat  
77c5 c9					ret  
77c6			  
77c6			; Define custom character  
77c6			;   On entry: A = Character number (0 to 7)  
77c6			;             DE = Pointer to character bitmap data  
77c6			;   On exit:  A = Next character number  
77c6			;             DE = Next location following bitmap  
77c6			;             BC HL IX IY I AF' BC' DE' HL' preserved  
77c6			; Character is   
77c6 c5			fLCD_Def:   PUSH BC  
77c7 f5			            PUSH AF  
77c8 07			            RLCA                ;Calculate location  
77c9 07			            RLCA                ;  for bitmap data  
77ca 07			            RLCA                ;  = 8 x CharacterNumber  
77cb f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
77cd cd 16 77		            CALL fLCD_Inst      ;Write instruction to LCD  
77d0 06 00		            LD   B, 0  
77d2 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
77d3 cd 52 77		            CALL fLCD_Data      ;Write byte to display  
77d6 13			            INC  DE             ;Point to next byte  
77d7 04			            INC  B              ;Count bytes  
77d8 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
77da 28 f6		            JR   Z, Loop       ;No, so repeat  
77dc f1			            POP  AF  
77dd 3c			            INC  A              ;Increment character number  
77de c1			            POP  BC  
77df c9			            RET  
77e0			  
77e0			  
77e0			; **********************************************************************  
77e0			; **  Private functions  
77e0			; **********************************************************************  
77e0			  
77e0			; Write function to LCD  
77e0			;   On entry: A = Function byte to be written  
77e0			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
77e0 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
77e2 18 02		            JR   WrFunc  
77e4 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
77e6 f5			WrFunc:     PUSH AF  
77e7 f5					push af  
77e8 3a 06 fb				ld a, (display_lcde1e2)  
77eb fe 00				cp 0     ; e1  
77ed 20 0f				jr nz, .wfea2	  
77ef f1					pop af  
77f0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77f2 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
77f4 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
77f6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
77f8 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
77fa d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77fc 18 0d			jr .wfskip  
77fe f1			.wfea2:		pop af  
77ff d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7801 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
7803 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7805 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7807 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7809 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
780b 3e 05		.wfskip:            LD  A, 5  
780d cd 14 78		            CALL LCDDelay       ;Delay 5 ms to complete  
7810 f1			            POP  AF  
7811 c9			            RET  
7812			  
7812			  
7812			; Delay in milliseconds  
7812			;   On entry: A = Number of milliseconds delay  
7812			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7812 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
7814 d5			LCDDelay:   PUSH DE  
7815 5f			            LD   E, A           ;Delay by 'A' ms  
7816 16 00		            LD   D, 0  
7818 cd c3 0c		            CALL aDelayInMS  
781b d1			            POP  DE  
781c c9			            RET  
781d			  
781d			  
781d			testlcd:  
781d 3e 00			ld a, kLCD_Line1  
781f cd 9a 77			call fLCD_Pos  
7822 06 28			ld b, 40  
7824 11 52 78			ld de, .ttext1  
7827 cd e5 76			call write_len_string  
782a			  
782a 3e 28			ld a, kLCD_Line2  
782c cd 9a 77			call fLCD_Pos  
782f 06 28			ld b, 40  
7831 11 7b 78			ld de, .ttext2  
7834 cd e5 76			call write_len_string  
7837 3e 50			ld a, kLCD_Line3  
7839 cd 9a 77			call fLCD_Pos  
783c 06 28			ld b, 40  
783e 11 a4 78			ld de, .ttext3  
7841 cd e5 76			call write_len_string  
7844 3e 78			ld a, kLCD_Line4  
7846 cd 9a 77			call fLCD_Pos  
7849 06 28			ld b, 40  
784b 11 cd 78			ld de, .ttext4  
784e cd e5 76			call write_len_string  
7851			  
7851 76				halt  
7852			  
7852			  
7852 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
787b .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
78a4 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
78cd .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
78f6			   
78f6			  
78f6			  
78f6			; eof  
78f6			  
# End of file firmware_lcd_4x40.asm
78f6			;include "firmware_lcd_4x20.asm" 
78f6			include "firmware_key_5x10.asm" 
78f6			; 5 x 10 decade counter scanner  
78f6			  
78f6			  
78f6			; TODO do cursor shape change for shift keys  
78f6			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
78f6			  
78f6			  
78f6			; bit mask for each scan column and row for teing the matrix  
78f6			  
78f6			  
78f6			key_init:  
78f6			  
78f6			; SCMonAPI functions used  
78f6			  
78f6			; Alphanumeric LCD functions used  
78f6			; no need to specify specific functions for this module  
78f6			  
78f6			  
78f6 3e cf		            LD   A, 11001111b  
78f8 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
78fa			;            LD   A, 00000000b  
78fa 3e 1f		            LD   A, 00011111b  
78fc d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
78fe			  
78fe			  
78fe				; TODO Configure cursor shapes  
78fe			  
78fe				; Load cursor shapes   
78fe 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
7900 11 10 79		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
7903 06 02		            LD   B, 2           ;Number of characters to define  
7905 cd c6 77		.DefLoop:   CALL fLCD_Def       ;Define custom character  
7908 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
790a			  
790a 3e 01				ld a, 1  
790c 32 fc fa			ld (cursor_shape),a  
790f c9				ret  
7910			  
7910			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
7910			; Up to 8 custom characters can be defined  
7910			.cursor_shapes:      
7910			;; Character 0x00 = Normal  
7910 1f			            DB  11111b  
7911 1f			            DB  11111b  
7912 1f			            DB  11111b  
7913 1f			            DB  11111b  
7914 1f			            DB  11111b  
7915 1f			            DB  11111b  
7916 1f			            DB  11111b  
7917 1f			            DB  11111b  
7918			;; Character 0x01 = Modifier  
7918 1f			            DB  11111b  
7919 1b			            DB  11011b  
791a 1b			            DB  11011b  
791b 1b			            DB  11011b  
791c 1b			            DB  11011b  
791d 1f			            DB  11111b  
791e 1b			            DB  11011b  
791f 1f			            DB  11111b  
7920			  
7920			  
7920			  
7920			  
7920			; Display custom character 0  
7920			;            LD   A, kLCD_Line1+14  
7920			;            CALL fLCD_Pos       ;Position cursor to location in A  
7920			;            LD   A, 0  
7920			;            CALL fLCD_Data      ;Write character in A at cursor  
7920			  
7920			; Display custom character 1  
7920			;            LD   A, kLCD_Line2+14  
7920			;            CALL fLCD_Pos      ;Position cursor to location in A  
7920			;            LD   A, 1  
7920			;            CALL fLCD_Data     ;Write character in A at cursor  
7920			  
7920			; keyboard scanning   
7920			  
7920			; character in from keyboard  
7920			  
7920			; mapping for the pcb layout  
7920			  
7920			.matrix_to_char:  
7920 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
792b .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
7936 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
7941 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
794c .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
7957			.matrix_to_shift:  
7957			  
7957 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
7962 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
796d 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
7978 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
7983 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
798e			  
798e			.matrix_to_symbolshift:  
798e			  
798e fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7999 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
79a4 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
79af			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
79af 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
79ba .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
79c5			  
79c5			  
79c5			  
79c5			; mapping for a simple straight through breadboard layout  
79c5			  
79c5			;.matrix_to_char:  
79c5			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
79c5			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
79c5			;		db "asdfghjkl",KEY_CR,0  
79c5			;		db "qwertyuiop",0  
79c5			;		 db "1234567890",0  
79c5			;.matrix_to_shift:  
79c5			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
79c5			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
79c5			;		db "ASDFGHJKL",KEY_CR,0  
79c5			;		db "QWERTYUIOP",0  
79c5			;		 db "!",'"',"#$%^&*()",0  
79c5			;.matrix_to_symbolshift:  
79c5			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
79c5			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
79c5			;		db "_?*fghjk=",KEY_CR,0  
79c5			;		db "-/+*[]{}@#",0  
79c5			;		 db "1234567890",0  
79c5			  
79c5			;.matrix_to_char: db "D#0*C987B654A321"  
79c5			  
79c5			  
79c5				  
79c5			  
79c5			; add cin and cin_wait  
79c5			  
79c5 cd d6 79		cin_wait: 	call cin  
79c8						if DEBUG_KEYCINWAIT  
79c8							push af  
79c8							  
79c8							ld hl,key_repeat_ct  
79c8							ld (hl),a  
79c8							inc hl  
79c8							call hexout  
79c8							ld hl,key_repeat_ct+3  
79c8							ld a,0  
79c8							ld (hl),a  
79c8			  
79c8							    LD   A, kLCD_Line1+11  
79c8							    CALL fLCD_Pos       ;Position cursor to location in A  
79c8							    LD   DE, key_repeat_ct  
79c8							    ;LD   DE, MsgHello  
79c8							    CALL fLCD_Str       ;Display string pointed to by DE  
79c8			  
79c8			  
79c8			  
79c8							pop af  
79c8						endif  
79c8 fe 00			cp 0  
79ca 28 f9			jr z, cin_wait   ; block until key press  
79cc			  
79cc							if DEBUG_KEYCINWAIT  
79cc								push af  
79cc			  
79cc								ld a, 'A'	  
79cc								ld hl,key_repeat_ct  
79cc								ld (hl),a  
79cc								inc hl  
79cc								ld a,0  
79cc								ld (hl),a  
79cc			  
79cc								    LD   A, kLCD_Line2+11  
79cc								    CALL fLCD_Pos       ;Position cursor to location in A  
79cc								    LD   DE, key_repeat_ct  
79cc								    ;LD   DE, MsgHello  
79cc								    CALL fLCD_Str       ;Display string pointed to by DE  
79cc			  
79cc							call delay500ms  
79cc			  
79cc								pop af  
79cc							endif  
79cc f5				push af   ; save key pressed  
79cd			  
79cd			.cin_wait1:	  
79cd							if DEBUG_KEYCINWAIT  
79cd								push af  
79cd			  
79cd								ld a, 'b'	  
79cd								ld hl,key_repeat_ct  
79cd								ld (hl),a  
79cd								inc hl  
79cd								ld a,0  
79cd								ld (hl),a  
79cd			  
79cd								    LD   A, kLCD_Line2+11  
79cd								    CALL fLCD_Pos       ;Position cursor to location in A  
79cd								    LD   DE, key_repeat_ct  
79cd								    ;LD   DE, MsgHello  
79cd								    CALL fLCD_Str       ;Display string pointed to by DE  
79cd			  
79cd			  
79cd							call delay500ms  
79cd			  
79cd								pop af  
79cd							endif  
79cd			  
79cd cd d6 79		call cin  
79d0 fe 00			cp 0  
79d2 20 f9			jr nz, .cin_wait1  	; wait for key release  
79d4			if DEBUG_KEYCINWAIT  
79d4				push af  
79d4			  
79d4				ld a, '3'	  
79d4				ld hl,key_repeat_ct  
79d4				ld (hl),a  
79d4				inc hl  
79d4				ld a,0  
79d4				ld (hl),a  
79d4			  
79d4			            LD   A, kLCD_Line2+11  
79d4			            CALL fLCD_Pos       ;Position cursor to location in A  
79d4			            LD   DE, key_repeat_ct  
79d4			            ;LD   DE, MsgHello  
79d4			            CALL fLCD_Str       ;Display string pointed to by DE  
79d4			  
79d4			  
79d4			call delay500ms  
79d4			  
79d4				pop af  
79d4			endif  
79d4			  
79d4 f1				pop af   ; get key  
79d5 c9				ret  
79d6			  
79d6			  
79d6 cd ea 79		cin: 	call .mtoc  
79d9			  
79d9			if DEBUG_KEYCIN  
79d9				push af  
79d9				  
79d9				ld hl,key_repeat_ct  
79d9				ld (hl),a  
79d9				inc hl  
79d9				call hexout  
79d9				ld hl,key_repeat_ct+3  
79d9				ld a,0  
79d9				ld (hl),a  
79d9			  
79d9			            LD   A, kLCD_Line3+15  
79d9			            CALL fLCD_Pos       ;Position cursor to location in A  
79d9			            LD   DE, key_repeat_ct  
79d9			            ;LD   DE, MsgHello  
79d9			            CALL fLCD_Str       ;Display string pointed to by DE  
79d9			  
79d9			  
79d9			call delay500ms  
79d9			  
79d9				pop af  
79d9			endif  
79d9			  
79d9			  
79d9				; no key held  
79d9 fe 00			cp 0  
79db c8				ret z  
79dc			  
79dc			if DEBUG_KEYCIN  
79dc				push af  
79dc			  
79dc				ld a, '1'	  
79dc				ld hl,key_repeat_ct  
79dc				ld (hl),a  
79dc				inc hl  
79dc				ld a,0  
79dc				ld (hl),a  
79dc			  
79dc			            LD   A, kLCD_Line4+15  
79dc			            CALL fLCD_Pos       ;Position cursor to location in A  
79dc			            LD   DE, key_repeat_ct  
79dc			            ;LD   DE, MsgHello  
79dc			            CALL fLCD_Str       ;Display string pointed to by DE  
79dc			  
79dc			  
79dc			call delay500ms  
79dc			  
79dc				pop af  
79dc			endif  
79dc			  
79dc				; stop key bounce  
79dc			  
79dc 32 c6 fd			ld (key_held),a		 ; save it  
79df 47				ld b, a  
79e0			  
79e0 c5			.cina1:	push bc  
79e1			if DEBUG_KEYCIN  
79e1				push af  
79e1			  
79e1				ld hl,key_repeat_ct  
79e1				inc hl  
79e1				call hexout  
79e1				ld hl,key_repeat_ct+3  
79e1				ld a,0  
79e1				ld (hl),a  
79e1				ld hl,key_repeat_ct  
79e1				ld a, '2'	  
79e1				ld (hl),a  
79e1			  
79e1			            LD   A, kLCD_Line4+15  
79e1			            CALL fLCD_Pos       ;Position cursor to location in A  
79e1			            LD   DE, key_repeat_ct  
79e1			            ;LD   DE, MsgHello  
79e1			            CALL fLCD_Str       ;Display string pointed to by DE  
79e1			  
79e1				pop af  
79e1			endif  
79e1 cd ea 79			call .mtoc  
79e4 c1				pop bc  
79e5 b8				cp b  
79e6 28 f8			jr z, .cina1  
79e8 78				ld a,b		  
79e9			if DEBUG_KEYCIN  
79e9				push af  
79e9			  
79e9				ld hl,key_repeat_ct  
79e9				inc hl  
79e9				call hexout  
79e9				ld hl,key_repeat_ct+3  
79e9				ld a,0  
79e9				ld (hl),a  
79e9				ld hl,key_repeat_ct  
79e9				ld a, '3'	  
79e9				ld (hl),a  
79e9			  
79e9			            LD   A, kLCD_Line4+15  
79e9			            CALL fLCD_Pos       ;Position cursor to location in A  
79e9			            LD   DE, key_repeat_ct  
79e9			            ;LD   DE, MsgHello  
79e9			            CALL fLCD_Str       ;Display string pointed to by DE  
79e9			  
79e9				pop af  
79e9			endif  
79e9 c9				ret  
79ea			  
79ea			; detect keyboard modifier key press and apply new overlay to the face key held  
79ea			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
79ea			  
79ea			;.cin_map_modifier:   
79ea			;	ld a, (hl)  
79ea			;	and 255  
79ea			;	ret NZ		; modifier key not flagged  
79ea			;  
79ea			;	; get key face  
79ea			;  
79ea			;	ld b,(key_face_held)  
79ea			;  
79ea			;	ld b, key_cols * key_rows  
79ea			;  
79ea			;	push de  
79ea			;	pop hl  
79ea			;  
79ea			;.mmod1: ld a,(hl)   ; get map test  
79ea			;	cp b  
79ea			;	jr z, .mmod2  
79ea			;  
79ea			;  
79ea			;  
79ea			;.mmod2: inc hl    ;   
79ea			;  
79ea			;	  
79ea			;  
79ea			;	  
79ea			;  
79ea			;	ld hl,key_actual_pressed  
79ea			;	ld (hl),a,  
79ea			;	ret  
79ea			  
79ea			; map matrix key held to char on face of key  
79ea			  
79ea			.mtoc:  
79ea			  
79ea			; test decade counter strobes  
79ea			  
79ea			;.decadetest1:  
79ea			  
79ea			; reset counter  
79ea			;ld a, 128  
79ea			;out (portbdata),a  
79ea			  
79ea			  
79ea			;ld b, 5  
79ea			;.dec1:  
79ea			;ld a, 0  
79ea			;out (portbdata),a  
79ea			;call delay1s  
79ea			  
79ea			;ld a, 32  
79ea			;out (portbdata),a  
79ea			;call delay1s  
79ea			;call delay1s  
79ea			;call delay1s  
79ea			;  
79ea			;ld a, 64+32  
79ea			;out (portbdata),a  
79ea			;call delay1s  
79ea			;;djnz .dec1  
79ea			;  
79ea			;jp .decadetest1  
79ea			  
79ea			  
79ea			  
79ea			  
79ea			  
79ea			  
79ea			  
79ea			  
79ea			  
79ea			  
79ea				; scan keyboard matrix and generate raw scan map  
79ea cd 7d 7a			call matrix  
79ed			  
79ed				; reuse c bit 0 left modifer button - ie shift  
79ed			        ; reuse c bit 1 for right modifer button - ie symbol shift  
79ed				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
79ed			  
79ed 0e 00			ld c, 0  
79ef			  
79ef				; TODO set flags for modifer key presses   
79ef				; TODO do a search for modifer key...  
79ef			  
79ef				;ld hl,keyscan_table_row4  
79ef 21 25 fe			ld hl,keyscan_table_row2  
79f2			  
79f2 7e				ld a, (hl)  
79f3 fe 23			cp '#'  
79f5 20 07			jr nz, .nextmodcheck  
79f7 cb c1			set 0, c  
79f9 21 57 79			ld hl, .matrix_to_shift  
79fc 18 21			jr .dokeymap  
79fe				; TODO for now igonre  
79fe			.nextmodcheck:  
79fe 21 1a fe			ld hl,keyscan_table_row3  
7a01			  
7a01 7e				ld a, (hl)  
7a02 fe 23			cp '#'  
7a04 20 07			jr nz, .nextmodcheck2  
7a06 cb c9			set 1, c   
7a08 21 8e 79			ld hl, .matrix_to_symbolshift  
7a0b 18 12			jr .dokeymap  
7a0d			.nextmodcheck2:  
7a0d 21 2e fe			ld hl,keyscan_table_row2+9    ; right shift  
7a10			  
7a10 7e				ld a, (hl)  
7a11 fe 23			cp '#'  
7a13 20 07			jr nz, .donemodcheck  
7a15 cb c9			set 1, c   
7a17 21 57 79			ld hl, .matrix_to_shift  
7a1a 18 03			jr .dokeymap  
7a1c			  
7a1c				; no modifer found so just map to normal keys  
7a1c				; get mtoc map matrix to respective keys  
7a1c			;	ld hl, .matrix_to_char  
7a1c			;	ld hl, .matrix_to_char  
7a1c			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7a1c			;	ld a, KEY_SHIFT  
7a1c			;	call findchar  
7a1c			;  
7a1c			;	; got offset to key modifer in b  
7a1c			;  
7a1c			;	ld hl,keyscan_table_row5  
7a1c			;  
7a1c			;	ld a,b  
7a1c			;	call addatohl  
7a1c			;	ld a,(hl)  
7a1c			;  
7a1c			;	cp '#'  
7a1c			;	jr nz, .nextmodcheck  
7a1c			;	set 0, c  
7a1c			;	ld hl, .matrix_to_char  
7a1c			;	jr .dokeymap  
7a1c			;	; TODO for now igonre  
7a1c			;.nextmodcheck:  
7a1c			;	ld hl, .matrix_to_symbolshift  
7a1c			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7a1c			;	ld a, KEY_SYMBOLSHIFT  
7a1c			;	call findchar  
7a1c			;  
7a1c			;  
7a1c			;	; got offset to key modifer in b  
7a1c			;  
7a1c			;	ld hl,keyscan_table_row5  
7a1c			;  
7a1c			;	ld a,b  
7a1c			;	call addatohl  
7a1c			;	ld a,(hl)  
7a1c			;  
7a1c			;	cp '#'  
7a1c			;	jr nz, .donemodcheck  
7a1c			;	set 1, c   
7a1c			;	ld hl, .matrix_to_symbolshift  
7a1c			;	jr .dokeymap  
7a1c			  
7a1c			  
7a1c			  
7a1c			.donemodcheck:  
7a1c				; no modifer found so just map to normal keys  
7a1c				; get mtoc map matrix to respective keys  
7a1c 21 20 79			ld hl, .matrix_to_char  
7a1f			  
7a1f			.dokeymap:  
7a1f				;ld (key_fa), c   
7a1f cd 38 7a			call .mapkeys  
7a22			  
7a22			  
7a22			if DEBUG_KEY  
7a22			  
7a22			; Display text on first line  
7a22			            LD   A, kLCD_Line1  
7a22			            CALL fLCD_Pos       ;Position cursor to location in A  
7a22			            LD   DE, keyscan_table_row1  
7a22			            ;LD   DE, MsgHello  
7a22			            CALL fLCD_Str       ;Display string pointed to by DE  
7a22			  
7a22			; Display text on second line  
7a22			            LD   A, kLCD_Line2  
7a22			            CALL fLCD_Pos       ;Position cursor to location in A  
7a22			            LD   DE, keyscan_table_row2  
7a22			            CALL fLCD_Str       ;Display string pointed to by DE  
7a22			            LD   A, kLCD_Line3  
7a22			            CALL fLCD_Pos       ;Position cursor to location in A  
7a22			            LD   DE, keyscan_table_row3  
7a22			            CALL fLCD_Str       ;Display string pointed to by DE  
7a22			            LD   A, kLCD_Line4  
7a22			            CALL fLCD_Pos       ;Position cursor to location in A  
7a22			            LD   DE, keyscan_table_row4  
7a22			            CALL fLCD_Str       ;Display string pointed to by DE  
7a22			            LD   A, kLCD_Line1+10  
7a22			            CALL fLCD_Pos       ;Position cursor to location in A  
7a22			            LD   DE, keyscan_table_row5  
7a22			            CALL fLCD_Str       ;Display string pointed to by DE  
7a22			  
7a22				;call delay250ms  
7a22			endif  
7a22			;	jp testkey  
7a22			  
7a22			; get first char reported  
7a22			  
7a22 21 04 fe			ld hl,keyscan_table_row5  
7a25			  
7a25				;ld b, 46   ; 30 keys to remap + 8 nulls   
7a25 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7a27			.findkey:  
7a27 7e				ld a,(hl)  
7a28 fe 00			cp 0  
7a2a 28 04			jr z, .nextkey  
7a2c fe 7e			cp KEY_MATRIX_NO_PRESS  
7a2e 20 06			jr nz, .foundkey  
7a30			.nextkey:  
7a30 23				inc hl  
7a31 10 f4			djnz .findkey  
7a33 3e 00			ld a,0  
7a35 c9				ret  
7a36			.foundkey:  
7a36 7e				ld a,(hl)  
7a37 c9				ret  
7a38				  
7a38			  
7a38			; convert the raw key map given hl for destination key  
7a38			.mapkeys:  
7a38 11 04 fe			ld de,keyscan_table_row5  
7a3b			  
7a3b 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7a3d			.remap:  
7a3d 1a				ld a,(de)  
7a3e fe 23			cp '#'  
7a40 20 02			jr nz, .remapnext  
7a42				;CALLMONITOR  
7a42 7e				ld a,(hl)  
7a43 12				ld (de),a  
7a44			  
7a44			  
7a44			  
7a44			.remapnext:  
7a44 23				inc hl  
7a45 13				inc de  
7a46 10 f5			djnz .remap  
7a48				  
7a48 c9				ret  
7a49			  
7a49			  
7a49			  
7a49			.mtocold2:  
7a49			  
7a49			;	; flag if key D is held down and remove from reporting  
7a49			;	ld bc, .key_map_fd    
7a49			;	ld hl, keyscan_table  
7a49			;	ld de, key_fd  
7a49			;	call .key_shift_hold  
7a49			;	cp 255  
7a49			;	jr z, .cinmap  
7a49			;	; flag if key C is held down and remove from reporting  
7a49			;	ld bc, .key_map_fc    
7a49			;	ld hl, keyscan_table+key_cols  
7a49			;	ld de, key_fc  
7a49			;	call .key_shift_hold  
7a49			;	cp 255  
7a49			;	jr z, .cinmap  
7a49			;	; flag if key B is held down and remove from reporting  
7a49			;	ld bc, .key_map_fb    
7a49			;	ld hl, keyscan_table+(key_cols*2)  
7a49			;	ld de, key_fb  
7a49			;	call .key_shift_hold  
7a49			;	cp 255  
7a49			;	jr z, .cinmap  
7a49			;	; flag if key A is held down and remove from reporting  
7a49			;	ld bc, .key_map_fa    
7a49			;	ld hl, keyscan_table+(key_cols*3)  
7a49			;	ld de, key_fa  
7a49			;	call .key_shift_hold  
7a49			;	cp 255  
7a49			;	jr z, .cinmap  
7a49			  
7a49 11 20 79			ld de, .matrix_to_char  
7a4c			  
7a4c			  
7a4c			.cinmap1:   
7a4c				if DEBUG_KEY  
7a4c			            LD   A, kLCD_Line4  
7a4c			            CALL fLCD_Pos       ;Position cursor to location in A  
7a4c					push de  
7a4c			            LD   DE, keyscan_table  
7a4c			            CALL fLCD_Str       ;Display string pointed to by DE  
7a4c					pop de  
7a4c				endif  
7a4c			  
7a4c				; scan key matrix table for any held key  
7a4c			  
7a4c				; de holds either the default matrix or one selected above  
7a4c			  
7a4c 21 d1 fd			ld hl, keyscan_table  
7a4f 06 32			ld b,key_cols*key_rows  
7a51			  
7a51 7e			.cin11:	ld a,(hl)  
7a52 fe 23			cp '#'  
7a54 28 08			jr z, .cinhit1  
7a56 23				inc hl  
7a57 13				inc de  
7a58 05				dec b  
7a59 20 f6			jr nz, .cin11  
7a5b				; no key found held  
7a5b 3e 00			ld a,0  
7a5d c9				ret  
7a5e d5			.cinhit1: push de  
7a5f e1				pop hl  
7a60 7e				ld a,(hl)  
7a61 c9				ret  
7a62			  
7a62			; flag a control key is held   
7a62			; hl is key pin, de is flag indicator  
7a62			  
7a62			.key_shift_hold1:  
7a62 c5				push bc  
7a63 3e 01			ld a, 1  
7a65 32 fc fa			ld (cursor_shape),a  
7a68 06 00			ld b, 0  
7a6a 7e				ld a, (hl)  
7a6b fe 2e			cp '.'  
7a6d 28 0a			jr z, .key_shift11  
7a6f 06 ff			ld b, 255  
7a71 3e 2b			ld a, '+'    ; hide key from later scans  
7a73 77				ld (hl),a  
7a74 3e 02			ld a, 2  
7a76 32 fc fa			ld (cursor_shape),a  
7a79			.key_shift11:  
7a79				; write flag indicator  
7a79 78				ld a,b  
7a7a 12				ld (de),a  
7a7b			  
7a7b d1				pop de    ; de now holds the key map ptr  
7a7c c9				ret  
7a7d			  
7a7d				  
7a7d			  
7a7d			; scans keyboard matrix and flags key press in memory array	  
7a7d				  
7a7d			matrix:  
7a7d				;call matrix  
7a7d				; TODO optimise the code....  
7a7d			  
7a7d			  
7a7d			;ld hl, keyscan_table_row1  
7a7d			;ld de, keyscan_table_row1+1  
7a7d			;ld bc,46  
7a7d			;ld a,KEY_MATRIX_NO_PRESS  
7a7d			;ldir  
7a7d			  
7a7d			  
7a7d			  
7a7d			; reset counter  
7a7d 3e 80		ld a, 128  
7a7f d3 c1		out (portbdata),a  
7a81			  
7a81 06 0a		ld b, 10  
7a83 0e 00		ld c, 0       ; current clock toggle  
7a85			  
7a85			.colscan:  
7a85			  
7a85			; set current column  
7a85			; disable clock enable and set clock low  
7a85			  
7a85			;ld a, 0  
7a85			;out (portbdata),a  
7a85			  
7a85			; For each column scan for switches  
7a85			  
7a85 c5			push bc  
7a86 21 c7 fd		ld hl, keyscan_scancol  
7a89 cd 92 7b		call .rowscan  
7a8c c1			pop bc  
7a8d			  
7a8d			  
7a8d			; get back current column  
7a8d			  
7a8d			; translate the row scan  
7a8d			  
7a8d			;   
7a8d			; row 1  
7a8d			  
7a8d 78			ld a,b  
7a8e			  
7a8e 21 3a fe		LD   hl, keyscan_table_row1+10  
7a91			  
7a91 cd e1 0f		call subafromhl  
7a94			;call addatohl  
7a94			  
7a94 11 c7 fd		ld de, keyscan_scancol  
7a97			  
7a97 1a			ld a,(de)  
7a98 77			ld (hl),a  
7a99			  
7a99			  
7a99			  
7a99			  
7a99			; row 2  
7a99			  
7a99 78			ld a,b  
7a9a			  
7a9a 21 2f fe		LD   hl, keyscan_table_row2+10  
7a9d			  
7a9d			;call addatohl  
7a9d cd e1 0f		call subafromhl  
7aa0			  
7aa0			  
7aa0 11 c8 fd		ld de, keyscan_scancol+1  
7aa3			  
7aa3 1a			ld a,(de)  
7aa4 77			ld (hl),a  
7aa5			  
7aa5			  
7aa5			; row 3  
7aa5			  
7aa5 78			ld a,b  
7aa6			  
7aa6 21 24 fe		LD   hl, keyscan_table_row3+10  
7aa9			  
7aa9			;call addatohl  
7aa9 cd e1 0f		call subafromhl  
7aac			  
7aac 11 c9 fd		ld de, keyscan_scancol+2  
7aaf			  
7aaf 1a			ld a,(de)  
7ab0 77			ld (hl),a  
7ab1			  
7ab1			  
7ab1			  
7ab1			; row 4  
7ab1			  
7ab1 78			ld a,b  
7ab2			  
7ab2 21 19 fe		LD   hl, keyscan_table_row4+10  
7ab5			  
7ab5			;call addatohl  
7ab5 cd e1 0f		call subafromhl  
7ab8			  
7ab8 11 ca fd		ld de, keyscan_scancol+3  
7abb			  
7abb 1a			ld a,(de)  
7abc 77			ld (hl),a  
7abd			  
7abd			; row 5  
7abd			  
7abd 78			ld a,b  
7abe			  
7abe 21 0e fe		LD   hl, keyscan_table_row5+10  
7ac1			  
7ac1			;call addatohl  
7ac1 cd e1 0f		call subafromhl  
7ac4			  
7ac4 11 cb fd		ld de, keyscan_scancol+4  
7ac7			  
7ac7 1a			ld a,(de)  
7ac8 77			ld (hl),a  
7ac9			  
7ac9			; handshake next column  
7ac9			  
7ac9			  
7ac9 3e 40		ld a, 64  
7acb d3 c1		out (portbdata),a  
7acd			  
7acd 3e 00		ld a, 0  
7acf d3 c1		out (portbdata),a  
7ad1			  
7ad1			; toggle clk and move to next column  
7ad1			;ld a, 64  
7ad1			;cp c  
7ad1			;  
7ad1			;jr z, .coltoglow  
7ad1			;ld c, a  
7ad1			;jr .coltog  
7ad1			;.coltoglow:  
7ad1			;ld c, 0  
7ad1			;.coltog:  
7ad1			;ld a, c  
7ad1			;out (portbdata),a  
7ad1			  
7ad1 10 b2		djnz .colscan  
7ad3			  
7ad3 3e 0a		ld a,10  
7ad5 21 30 fe		LD   hl, keyscan_table_row1  
7ad8 cd cf 0f		call addatohl  
7adb 3e 00		ld a, 0  
7add 77			ld (hl), a  
7ade			  
7ade			  
7ade 3e 0a		ld a,10  
7ae0 21 25 fe		LD   hl, keyscan_table_row2  
7ae3 cd cf 0f		call addatohl  
7ae6 3e 00		ld a, 0  
7ae8 77			ld (hl), a  
7ae9			  
7ae9 3e 0a		ld a,10  
7aeb 21 1a fe		LD   hl, keyscan_table_row3  
7aee cd cf 0f		call addatohl  
7af1 3e 00		ld a, 0  
7af3 77			ld (hl), a  
7af4			  
7af4 3e 0a		ld a,10  
7af6 21 0f fe		LD   hl, keyscan_table_row4  
7af9 cd cf 0f		call addatohl  
7afc 3e 00		ld a, 0  
7afe 77			ld (hl), a  
7aff			  
7aff 3e 0a		ld a,10  
7b01 21 04 fe		LD   hl, keyscan_table_row5  
7b04 cd cf 0f		call addatohl  
7b07 3e 00		ld a, 0  
7b09 77			ld (hl), a  
7b0a			  
7b0a			if DEBUG_KEY_MATRIX  
7b0a			  
7b0a			; Display text on first line  
7b0a			            LD   A, kLCD_Line1  
7b0a			            CALL fLCD_Pos       ;Position cursor to location in A  
7b0a			            LD   DE, keyscan_table_row1  
7b0a			            ;LD   DE, MsgHello  
7b0a			            CALL fLCD_Str       ;Display string pointed to by DE  
7b0a			  
7b0a			; Display text on second line  
7b0a			            LD   A, kLCD_Line2  
7b0a			            CALL fLCD_Pos       ;Position cursor to location in A  
7b0a			            LD   DE, keyscan_table_row2  
7b0a			            CALL fLCD_Str       ;Display string pointed to by DE  
7b0a			            LD   A, kLCD_Line3  
7b0a			            CALL fLCD_Pos       ;Position cursor to location in A  
7b0a			            LD   DE, keyscan_table_row3  
7b0a			            CALL fLCD_Str       ;Display string pointed to by DE  
7b0a			            LD   A, kLCD_Line4  
7b0a			            CALL fLCD_Pos       ;Position cursor to location in A  
7b0a			            LD   DE, keyscan_table_row4  
7b0a			            CALL fLCD_Str       ;Display string pointed to by DE  
7b0a			            LD   A, kLCD_Line4+10  
7b0a			            CALL fLCD_Pos       ;Position cursor to location in A  
7b0a			            LD   DE, keyscan_table_row5  
7b0a			            CALL fLCD_Str       ;Display string pointed to by DE  
7b0a			  
7b0a			;call delay250ms  
7b0a				jp matrix  
7b0a			endif  
7b0a c9			ret  
7b0b			  
7b0b			; using decade counter....  
7b0b			  
7b0b			  
7b0b			; TODO reset decade counter to start of scan  
7b0b			  
7b0b			; reset 15  
7b0b			; clock 14  
7b0b			; ce 13  
7b0b			  
7b0b			; 1 - q5  
7b0b			; 2 - q1  
7b0b			; 3 - q0  
7b0b			; 4 - q2  
7b0b			; 5 - q6  
7b0b			; 6 - q7  
7b0b			; 7 - q3  
7b0b			; 8 - vss  
7b0b			; 9 - q8  
7b0b			; 10 - q4  
7b0b			; 11 - q9  
7b0b			; 12 - cout  
7b0b			; 16 - vdd  
7b0b			  
7b0b			; clock      ce       reset     output  
7b0b			; 0          x        0         n  
7b0b			; x          1        0         n  
7b0b			; x          x        1         q0  
7b0b			; rising     0        0         n+1  
7b0b			; falling    x        0         n  
7b0b			; x          rising   0         n  
7b0b			; 1          falling  0         x+1  
7b0b			;  
7b0b			; x = dont care, if n < 5 carry = 1 otherwise 0  
7b0b			  
7b0b			;   
7b0b			; reset   
7b0b			; 13=0, 14=0, 15=1 .. 15=0  
7b0b			;  
7b0b			; handshake line  
7b0b			; 14=1.... read line 14=0  
7b0b			  
7b0b			  
7b0b			  
7b0b			  
7b0b			  
7b0b			; TODO hand shake clock for next column scan  
7b0b			; TODO detect each row  
7b0b			  
7b0b			  
7b0b			  
7b0b			  
7b0b			; reset 128  
7b0b			; clock 64  
7b0b			; ce 32  
7b0b			  
7b0b			  
7b0b			.cyclestart:  
7b0b			  
7b0b			; reset counter  
7b0b 3e 80		ld a, 128  
7b0d d3 c1		out (portbdata),a  
7b0f			  
7b0f			; loop leds  
7b0f 06 0a		ld b,10  
7b11			  
7b11			.cycle1:  
7b11 c5			push bc  
7b12 3e 00		ld a, 0  
7b14 d3 c1		out (portbdata),a  
7b16 cd d2 0c		call delay250ms  
7b19			  
7b19 3e 40		ld a, 64  
7b1b d3 c1		out (portbdata),a  
7b1d cd d2 0c		call delay250ms  
7b20			  
7b20 3e 00		ld a, 0  
7b22 d3 c1		out (portbdata),a  
7b24 cd d2 0c		call delay250ms  
7b27			  
7b27 c1			pop bc  
7b28 10 e7		djnz .cycle1  
7b2a			  
7b2a			  
7b2a 18 df		jr .cyclestart  
7b2c			  
7b2c			  
7b2c			  
7b2c			  
7b2c			  
7b2c			  
7b2c			  
7b2c			  
7b2c			  
7b2c			; map matrix key held to char on face of key  
7b2c			  
7b2c			;.mtocold:  
7b2c			;  
7b2c			;  
7b2c			;; reset counter  
7b2c			;ld a, 128  
7b2c			;out (portbdata),a  
7b2c			;  
7b2c			;  
7b2c			;; scan keyboard row 1  
7b2c			;ld a, 0  
7b2c			;out (portbdata),a  
7b2c			;;ld a, 64  
7b2c			;;out (portbdata),a  
7b2c			;  
7b2c			;  
7b2c			;	ld a, 128  
7b2c			;	ld hl, keyscan_table  
7b2c			;	call .rowscan  
7b2c			;  
7b2c			;;ld a, 0  
7b2c			;;out (portbdata),a  
7b2c			;ld a, 64  
7b2c			;out (portbdata),a  
7b2c			;  
7b2c			;	ld a, 64  
7b2c			;	ld hl, keyscan_table+key_cols  
7b2c			;	call .rowscan  
7b2c			;  
7b2c			;ld a, 0  
7b2c			;out (portbdata),a  
7b2c			;;ld a, 64  
7b2c			;;out (portbdata),a  
7b2c			;	ld a, 32  
7b2c			;	ld hl, keyscan_table+(key_cols*2)  
7b2c			;	call .rowscan  
7b2c			;  
7b2c			;  
7b2c			;;ld a, 0  
7b2c			;;out (portbdata),a  
7b2c			;ld a, 64  
7b2c			;out (portbdata),a  
7b2c			;  
7b2c			;	ld a, 16  
7b2c			;	ld hl, keyscan_table+(key_cols*3)  
7b2c			;	call .rowscan  
7b2c			;  
7b2c			;  
7b2c			;	; flag if key D is held down and remove from reporting  
7b2c			;	ld bc, .key_map_fd    
7b2c			;	ld hl, keyscan_table  
7b2c			;	ld de, key_fd  
7b2c			;	call .key_shift_hold  
7b2c			;	cp 255  
7b2c			;	jr z, .cinmap  
7b2c			;	; flag if key C is held down and remove from reporting  
7b2c			;	ld bc, .key_map_fc    
7b2c			;	ld hl, keyscan_table+key_cols  
7b2c			;	ld de, key_fc  
7b2c			;	call .key_shift_hold  
7b2c			;	cp 255  
7b2c			;	jr z, .cinmap  
7b2c			;	; flag if key B is held down and remove from reporting  
7b2c			;	ld bc, .key_map_fb    
7b2c			;	ld hl, keyscan_table+(key_cols*2)  
7b2c			;	ld de, key_fb  
7b2c			;	call .key_shift_hold  
7b2c			;	cp 255  
7b2c			;	jr z, .cinmap  
7b2c			;	; flag if key A is held down and remove from reporting  
7b2c			;	ld bc, .key_map_fa    
7b2c			;	ld hl, keyscan_table+(key_cols*3)  
7b2c			;	ld de, key_fa  
7b2c			;	call .key_shift_hold  
7b2c			;	cp 255  
7b2c			;	jr z, .cinmap  
7b2c			;  
7b2c			;	ld de, .matrix_to_char  
7b2c			;  
7b2c			;  
7b2c			;.cinmap:   
7b2c			;	if DEBUG_KEY  
7b2c			;            LD   A, kLCD_Line4  
7b2c			;            CALL fLCD_Pos       ;Position cursor to location in A  
7b2c			;		push de  
7b2c			;            LD   DE, keyscan_table  
7b2c			;            CALL fLCD_Str       ;Display string pointed to by DE  
7b2c			;		pop de  
7b2c			;	endif  
7b2c			  
7b2c				; scan key matrix table for any held key  
7b2c			  
7b2c				; de holds either the default matrix or one selected above  
7b2c			  
7b2c			;	ld hl, keyscan_table  
7b2c			;	ld b,key_cols*key_rows  
7b2c			;  
7b2c			;.cin1:	ld a,(hl)  
7b2c			;	cp '#'  
7b2c			;	jr z, .cinhit  
7b2c			;	inc hl  
7b2c			;	inc de  
7b2c			;	dec b  
7b2c			;	jr nz, .cin1  
7b2c			;	; no key found held  
7b2c			;	ld a,0  
7b2c			;	ret  
7b2c			;.cinhit: push de  
7b2c			;	pop hl  
7b2c			;	ld a,(hl)  
7b2c			;	ret  
7b2c			  
7b2c			; flag a control key is held   
7b2c			; hl is key pin, de is flag indicator  
7b2c			  
7b2c			;.key_shift_hold:  
7b2c			;	push bc  
7b2c			;	ld a, 1  
7b2c			;	ld (cursor_shape),a  
7b2c			;	ld b, 0  
7b2c			;	ld a, (hl)  
7b2c			;	cp '.'  
7b2c			;	jr z, .key_shift1  
7b2c			;	ld b, 255  
7b2c			;	ld a, '+'    ; hide key from later scans  
7b2c			;	ld (hl),a  
7b2c			;	ld a, 2  
7b2c			;	ld (cursor_shape),a  
7b2c			;.key_shift1:  
7b2c			;	; write flag indicator  
7b2c			;	ld a,b  
7b2c			;	ld (de),a  
7b2c			;  
7b2c			;	pop de    ; de now holds the key map ptr  
7b2c			;	ret  
7b2c			  
7b2c				  
7b2c				  
7b2c			  
7b2c			  
7b2c			  
7b2c			  
7b2c			  
7b2c			  
7b2c			  
7b2c			  
7b2c			  
7b2c			  
7b2c			  
7b2c			;	push hl  
7b2c			;	push de  
7b2c			;	push bc  
7b2c			;	call keyscan  
7b2c			;	; map key matrix to ascii value of key face  
7b2c			;  
7b2c			;	ld hl, key_face_map  
7b2c			;	ld de, keyscan_table  
7b2c			;  
7b2c			;	; get how many keys to look at  
7b2c			;	ld b, keyscan_table_len  
7b2c			;	  
7b2c			;  
7b2c			;	; at this stage fall out on first key hit  
7b2c			;	; TODO handle multiple key press  
7b2c			;  
7b2c			;map1:	ld a,(hl)  
7b2c			;	cp '#'  
7b2c			;	jr z, keyhit  
7b2c			;	inc hl  
7b2c			;	inc de  
7b2c			;	dec b  
7b2c			;	jr nz, map1  
7b2c			;nohit:	ld a, 0  
7b2c			;	jr keydone  
7b2c			;keyhit: push de  
7b2c			;	pop hl  
7b2c			;	ld a,(hl)  
7b2c			;keydone:  
7b2c			;	push bc  
7b2c			;	push de  
7b2c			; 	push hl  
7b2c			;	ret   
7b2c			;  
7b2c			  
7b2c			  
7b2c			  
7b2c			  
7b2c			; scan physical key matrix  
7b2c			  
7b2c			  
7b2c			;keyscan:  
7b2c			;  
7b2c			;; for each key_row use keyscanr bit mask for out  
7b2c			;; then read in for keyscanc bitmask  
7b2c			;; save result of row scan to keyscantable  
7b2c			;  
7b2c			;; scan keyboard row 1  
7b2c			;  
7b2c			;	ld b, key_rows  
7b2c			;	ld hl, key_scanr  
7b2c			;	ld de, keyscan_table  
7b2c			;  
7b2c			;rowloop:  
7b2c			;  
7b2c			;	ld a,(hl)		; out bit mask to energise keyboard row  
7b2c			;	call rowscan  
7b2c			;	inc hl  
7b2c			;	dec b  
7b2c			;	jr nz, rowloop  
7b2c			;  
7b2c			;	ret  
7b2c			;  
7b2c			;  
7b2c			;; pass a out bitmask, b row number  
7b2c			;arowscan:   
7b2c			;	push bc  
7b2c			;  
7b2c			;	ld d, b  
7b2c			;  
7b2c			;	; calculate buffer location for this row  
7b2c			;  
7b2c			;	ld hl, keyscan_table	  
7b2c			;kbufr:  ld e, key_cols  
7b2c			;kbufc:	inc hl  
7b2c			;	dec e  
7b2c			;	jr nz, kbufc  
7b2c			;	dec d  
7b2c			;	jr nz, kbufr  
7b2c			;  
7b2c			;	; energise row and read columns  
7b2c			;  
7b2c			;	out (portbdata),a  
7b2c			;	in a,(portbdata)  
7b2c			;	ld c,a  
7b2c			;  
7b2c			;  
7b2c			;	; save buffer loc  
7b2c			;  
7b2c			;	ld (keybufptr), hl  
7b2c			;  
7b2c			;	ld hl, key_scanc  
7b2c			;	ld d, key_cols  
7b2c			;  
7b2c			;	; for each column check each bit mask  
7b2c			;  
7b2c			;colloop:  
7b2c			;	  
7b2c			;  
7b2c			;	; reset flags for the row   
7b2c			;  
7b2c			;	ld b,'.'  
7b2c			;	and (hl)  
7b2c			;	jr z, maskskip  
7b2c			;	ld b,'#'  
7b2c			;maskskip:  
7b2c			;	; save  key state  
7b2c			;	push hl  
7b2c			;	ld hl, (keybufptr)  
7b2c			;	ld (hl), b  
7b2c			;	inc hl  
7b2c			;	ld (keybufptr), hl  
7b2c			;  
7b2c			;	; move to next bit mask  
7b2c			;	pop hl  
7b2c			;	inc hl  
7b2c			;  
7b2c			;	dec d  
7b2c			;	jr nz, colloop  
7b2c			;  
7b2c			;	ret  
7b2c			;  
7b2c			;  
7b2c			;;  
7b2c			; lcd functions  
7b2c			;  
7b2c			;  
7b2c			  
7b2c			;if DEBUG_KEY_MATRIX  
7b2c			  
7b2c			; test function to display hardware view of matrix state  
7b2c			  
7b2c			matrixold:  
7b2c			  
7b2c			  
7b2c			  
7b2c			; reset counter  
7b2c 3e 80		ld a, 128  
7b2e d3 c1		out (portbdata),a  
7b30			; scan keyboard row 1  
7b30 3e 00		ld a, 0  
7b32 d3 c1		out (portbdata),a  
7b34			;ld a, 64  
7b34			;out (portbdata),a  
7b34 3e 80			ld a, 128  
7b36 21 30 fe			ld hl, keyscan_table_row1  
7b39 cd 92 7b			call .rowscan  
7b3c			  
7b3c			;ld a, 0  
7b3c			;out (portbdata),a  
7b3c 3e 40		ld a, 64  
7b3e d3 c1		out (portbdata),a  
7b40 3e 40			ld a, 64  
7b42 21 25 fe			ld hl, keyscan_table_row2  
7b45 cd 92 7b			call .rowscan  
7b48			  
7b48 3e 00		ld a, 0  
7b4a d3 c1		out (portbdata),a  
7b4c			;ld a, 64  
7b4c			;out (portbdata),a  
7b4c 3e 20			ld a, 32  
7b4e 21 1a fe			ld hl, keyscan_table_row3  
7b51 cd 92 7b			call .rowscan  
7b54			  
7b54			;ld a, 0  
7b54			;out (portbdata),a  
7b54 3e 40		ld a, 64  
7b56 d3 c1		out (portbdata),a  
7b58 3e 10			ld a, 16  
7b5a 21 0f fe			ld hl, keyscan_table_row4  
7b5d cd 92 7b			call .rowscan  
7b60			  
7b60			; Display text on first line  
7b60 3e 00		            LD   A, kLCD_Line1  
7b62 cd 9a 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b65 11 30 fe		            LD   DE, keyscan_table_row1  
7b68			            ;LD   DE, MsgHello  
7b68 cd bc 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b6b			  
7b6b			; Display text on second line  
7b6b 3e 28		            LD   A, kLCD_Line2  
7b6d cd 9a 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b70 11 25 fe		            LD   DE, keyscan_table_row2  
7b73 cd bc 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b76 3e 50		            LD   A, kLCD_Line3  
7b78 cd 9a 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b7b 11 1a fe		            LD   DE, keyscan_table_row3  
7b7e cd bc 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b81 3e 78		            LD   A, kLCD_Line4  
7b83 cd 9a 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b86 11 0f fe		            LD   DE, keyscan_table_row4  
7b89 cd bc 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b8c			  
7b8c cd d2 0c			call delay250ms  
7b8f c3 7d 7a			jp matrix  
7b92			  
7b92			; pass de as row display flags  
7b92			.rowscan:   
7b92			;	out (portbdata),a  
7b92 db c1			in a,(portbdata)  
7b94 4f				ld c,a  
7b95				; reset flags for the row   
7b95 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7b97 e6 01			and 1  
7b99 28 02			jr z, .p1on  
7b9b 06 23			ld b,'#'  
7b9d			.p1on:  
7b9d 70				ld (hl), b  
7b9e 23				inc hl  
7b9f			  
7b9f 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7ba1 79				ld a,c  
7ba2 e6 02			and 2  
7ba4			;	bit 0,a  
7ba4 28 02			jr z, .p2on  
7ba6 06 23			ld b,'#'  
7ba8			.p2on:  
7ba8 70				ld (hl), b  
7ba9 23				inc hl  
7baa			;  
7baa 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7bac 79				ld a,c  
7bad e6 04			and 4  
7baf			;;	bit 0,a  
7baf 28 02			jr z, .p3on  
7bb1 06 23			ld b,'#'  
7bb3			.p3on:  
7bb3 70				ld (hl), b  
7bb4 23				inc hl  
7bb5			;;  
7bb5 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7bb7			;;	bit 0,a  
7bb7 79				ld a,c  
7bb8 e6 08			and 8  
7bba 28 02			jr z, .p4on  
7bbc 06 23			ld b,'#'  
7bbe			.p4on:  
7bbe 70				ld (hl), b  
7bbf 23				inc hl  
7bc0			  
7bc0 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7bc2			;;	bit 0,a  
7bc2 79				ld a,c  
7bc3 e6 10			and 16  
7bc5 28 02			jr z, .p5on  
7bc7 06 23			ld b,'#'  
7bc9			.p5on:  
7bc9 70				ld (hl), b  
7bca 23				inc hl  
7bcb			; zero term  
7bcb 06 00			ld b,0  
7bcd 70				ld (hl), b  
7bce			  
7bce c9			.rscandone: ret  
7bcf			  
7bcf			;addatohl:  
7bcf			;  
7bcf			 ;add   a, l    ; A = A+L  
7bcf			  ;  ld    l, a    ; L = A+L  
7bcf			   ; adc   a, h    ; A = A+L+H+carry  
7bcf			   ; sub   l       ; A = H+carry  
7bcf			   ; ld    h, a    ; H = H+carry  
7bcf			  
7bcf			;ret  
7bcf			; eof  
# End of file firmware_key_5x10.asm
7bcf			;include "firmware_key_4x10.asm" 
7bcf			 
7bcf			heap_size:    equ heap_end - heap_start 
7bcf			;eof 
# End of file os_mega.asm
7bcf
