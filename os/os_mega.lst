# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 16 1b			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
001c			 
001c			 
001c			;        nop  
001c			;        nop 
001c			;;	org 05h		; null out bdos call 
001c			; 
001c			;        nop  
001c			;        nop  
001c			;        nop 
001c			;;	org 08h 
001c			;;; 
001c			;;	jp cin		; rst 8 - char in 
001c			;;; 
001c			; 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;        nop 
001c			;	org 010h 
001c			;; 
001c			;	jp cout		; rest 010h  - char out 
001c			;; 
001c			;	org 01bh   
001c			; 
001c			;	;jp  		; rst 01bh   - write string to display 
001c			;	jp str_at_display 
001c			; 
001c			; 
001c			;	org 020h 
001c			; 
001c			;	; jp		 ; rst 020h - read char at screen location 
001c			; 
001c			;	org 028h 
001c			 
001c				; jp		 ; rst 028h  - storage i/o 
001c			 
001c			; 	org 030h 
001c			;	jp break_point_state 
001c			  
001c			; $30  
001c			; org 038h 
001c			; $38 
001c			 
001c			; TODO any more important entry points to add to jump table for easier coding use? 
001c			 
001c			 
001c			include "firmware.asm" 
001c			  
001c			; main constants (used here and in firmware)  
001c			  
001c			; TODO have page 0 of storage as bios  
001c			  
001c			Device_A: equ 0h  
001c			Device_B: equ 040h          ; Sound  
001c			  
001c			if BASE_KEV  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_SC114  
001c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			; TODO fixup for CPM  
001c			Device_C: equ 080h          ; Storage and ext cart devices  
001c			endif  
001c			  
001c			Device_D: equ 0c0h             ; Keyboard and LCD  
001c			  
001c			; Odd specific debug points for testing hardware dev  
001c			  
001c			DEBUG_SOUND: equ 1  
001c			DEBUG_STK_FAULT: equ 0  
001c			DEBUG_INPUT: equ 0     ; Debug input entry code  
001c			DEBUG_KEYCINWAIT: equ 0  
001c			DEBUG_KEYCIN: equ 0  
001c			DEBUG_KEY: equ 0  
001c			DEBUG_KEY_MATRIX: equ 0  
001c			DEBUG_STORECF: equ 0  
001c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
001c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
001c			DEBUG_SPI: equ 0    ; low level spi tests  
001c			  
001c			; Enable many break points  
001c			  
001c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
001c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
001c			DEBUG_FORTH_JP: equ 0    ; 4  
001c			DEBUG_FORTH_MALLOC: equ 0  
001c			DEBUG_FORTH_MALLOC_INT: equ 0  
001c			DEBUG_FORTH_DOT: equ 0  
001c			DEBUG_FORTH_DOT_WAIT: equ 0  
001c			DEBUG_FORTH_MATHS: equ 0  
001c			DEBUG_FORTH_TOK: equ 0    ; 4  
001c			DEBUG_FORTH_PARSE: equ 0    ; 3  
001c			DEBUG_FORTH: equ 0  ;2  
001c			DEBUG_FORTH_WORDS: equ 1   ; 1  
001c			DEBUG_FORTH_PUSH: equ 1   ; 1  
001c			DEBUG_FORTH_UWORD: equ 1   ; 1  
001c			  
001c			; Enable key point breakpoints  
001c			  
001c			DEBUG_FORTH_DOT_KEY: equ 0  
001c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
001c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
001c			  
001c			; Debug stack imbalances  
001c			  
001c			ON: equ 1  
001c			OFF: equ 0  
001c			  
001c			DEBUG_STACK_IMB: equ 0  
001c			STACK_IMB_STORE: equ 20  
001c			  
001c			; House keeping and protections  
001c			  
001c			DEBUG_FORTH_STACK_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
001c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
001c			FORTH_ENABLE_FREE: equ 0  
001c			FORTH_ENABLE_MALLOCFREE: equ 1  
001c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
001c			FORTH_ENABLE_FLOATMATH: equ 0  
001c			  
001c			  
001c			CALLMONITOR: macro  
001c				call break_point_state  
001c				endm  
001c			  
001c			MALLOC_1: equ 1        ; from dk88   
001c			MALLOC_2: equ 0           ; broke  
001c			MALLOC_3: equ 0           ; really broke  
001c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
001c			  
001c			if BASE_KEV   
001c			stacksize: equ 256  
001c			  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 512  
001c			endif  
001c			if BASE_SC114  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			if BASE_CPM  
001c			;tos:	equ 0f000h  
001c			stacksize: equ 256  
001c			STACK_RET_SIZE: equ 64  
001c			STACK_LOOP_SIZE: equ 128  
001c			STACK_DATA_SIZE: equ 256  
001c			endif  
001c			  
001c			;if STORAGE_SE == 0  
001c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
001c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
001c			;endif  
001c			  
001c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
001c			  
001c			STORE_0_AUTORUN: equ $20  
001c			  
001c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
001c			  
001c			STORE_0_AUTOFILE: equ $21  
001c			STORE_0_BANKRUN: equ $23  
001c			STORE_0_FILERUN: equ $24  
001c			  
001c			; Block 0 offsets for settings  
001c			  
001c			; if set then skip prompt for start up and accept all  
001c			  
001c			STORE_0_QUICKSTART: equ $25  
001c			  
001c			; Blocks where directory table is held  
001c			  
001c			; Reducing the number of entries increases the max file size  
001c			  
001c			;STORE_DIR_START: equ 1  
001c			;STORE_DIR_END: equ 33  
001c			  
001c			; Blocks from where file data is stored  
001c			  
001c			;STORE_DATA_START: equ STORE_DIR_END + 1  
001c			  
001c			; Block indicators (<32 are data files)  
001c			  
001c			;STORE_BLOCK_CFG: equ $8f       ; config block  
001c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
001c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
001c			;STORE_BLOCK_FREE: equ $85       ; data block free  
001c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
001c			  
001c			  
001c			  
001c			; Directory entry flags  
001c			  
001c			;STORE_DIR_FREE: equ 0  
001c			;STORE_DIR_FILE:  equ 1  
001c			  
001c			; Structure offsets to directory entries  
001c			;STORE_DE_FLAG: equ 0  
001c			;STORE_DE_MAXEXT: equ 1  
001c			;STORE_DE_FILENAME: equ 2  
001c			  
001c			; Structure offsets to block 0  
001c			  
001c			;STORE_BK0_ISFOR: equ 1  
001c			;STORE_BK0_LABEL: equ 3  
001c			  
001c			; memory allocation   
001c			  
001c			chk_stund: equ tos+2           ; underflow check word  
001c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
001c			  
001c			; keyscan table needs rows x cols buffer  
001c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
001c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
001c			  
001c			keyscan_table_row1: equ chk_stovr -key_cols-1  
001c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
001c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
001c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
001c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
001c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
001c			keyscan_scancol: equ keyscan_table-key_cols  
001c			;keyscan_table_len: equ key_rows*key_cols  
001c			;keybufptr: equ keyscan_table - 2  
001c			;keysymbol: equ keybufptr - 1  
001c			key_held: equ keyscan_scancol-1	; currently held  
001c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
001c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
001c			key_fa: equ key_repeat_ct -1 ;  
001c			key_fb: equ key_fa -1 ;  
001c			key_fc: equ key_fb -1 ;  
001c			key_fd: equ key_fc -1 ;  
001c			key_face_held: equ key_fd - 1   
001c			  
001c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
001c			  
001c			hardware_config: equ key_face_held - 10  
001c			  
001c			; hardware config switches  
001c			; TODO add bitmasks on includes for hardware  
001c			; high byte for expansion ids  
001c			;     0000 0000  no card inserted  
001c			;     0000 0001  storage card inserted  
001c			;     0000 0010  spi sd card active  
001c			  
001c			;       
001c			; low byte:  
001c			;     0000 0001   4x4 keypad  
001c			;     0000 0010   full keyboard  
001c			;     0000 0011   spi/ext keyboard  
001c			;     0000 0100   20x4 lcd  
001c			;     0000 1000   40x4 lcd  
001c			;     0000 1100   spi/ext display  
001c			;     0001 0000   ide interface available  
001c			  
001c			hardware_word: equ hardware_config - 2  
001c			  
001c			; debug marker - optional display of debug point on the debug screens  
001c			  
001c			debug_mark: equ hardware_word - 4  
001c			  
001c			; input_str vars  
001c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
001c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
001c			input_size: equ input_start -1  ; number of chars  
001c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
001c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
001c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
001c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
001c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
001c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
001c			input_len: equ input_cur_onoff - 5 ; length of current input  
001c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
001c			  
001c			CUR_BLINK_RATE: equ 15  
001c			  
001c			key_actual_pressed: equ input_cursor - 1   
001c			key_symbol: equ key_actual_pressed - 1   
001c			key_shift: equ key_symbol - 1   
001c			  
001c			; Display allocation  
001c			  
001c			;display_rows: equ 4     ; move out to mini and mega files  
001c			;display_cols: equ 20  
001c			  
001c			display_fb_len: equ display_rows*display_cols  
001c			  
001c			; primary frame buffer     
001c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
001c			; working frame buffers  
001c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
001c			display_fb3: equ  display_fb1-display_fb_len - 1  
001c			display_fb2: equ  display_fb3-display_fb_len - 1  
001c			;  
001c			; pointer to active frame buffer  
001c			display_fb_active: equ display_fb2 - 2  
001c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
001c			display_write_tmp: equ display_lcde1e2 - 2  
001c			  
001c			  
001c			;  
001c			  
001c			;; can load into de directory  
001c			cursor_col: equ display_write_tmp-1  
001c			cursor_row: equ cursor_col-1  
001c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
001c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
001c			  
001c			; maths vars  
001c			  
001c			LFSRSeed: equ cursor_shape -20   
001c			randData: equ LFSRSeed - 2  
001c			xrandc: equ randData - 2  
001c			stackstore: equ xrandc - 2  
001c			seed1: equ  stackstore -2   
001c			seed2: equ seed1 - 2  
001c			  
001c			; cf storage vars  
001c			  
001c			iErrorNum:  equ seed2-1         ;Error number  
001c			iErrorReg:  equ iErrorNum -1              ;Error register  
001c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
001c			  
001c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
001c			  
001c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
001c			  
001c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
001c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
001c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
001c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
001c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
001c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
001c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
001c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
001c			store_tmpid: equ store_tmp3 - 1		; page temp id  
001c			store_tmpext: equ store_tmpid - 1		; file extent temp  
001c			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
001c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
001c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
001c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
001c			;  
001c			; spi vars  
001c			  
001c			  
001c			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
001c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
001c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
001c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
001c			spi_device_id: equ spi_device - 1    ; human readable bank number  
001c			  
001c			;;;;; forth cli params  
001c			  
001c			; TODO use a different frame buffer for forth???  
001c			  
001c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
001c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
001c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
001c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
001c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
001c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
001c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
001c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
001c			  
001c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
001c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
001c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
001c			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
001c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
001c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
001c			  
001c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
001c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
001c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
001c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
001c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
001c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
001c			  
001c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
001c			  
001c			; os/forth token vars  
001c			  
001c			os_last_cmd: equ os_var_array-255  
001c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
001c			os_current_i: equ os_cli_cmd-2  
001c			os_cur_ptr: equ os_current_i-2  
001c			os_word_scratch: equ os_cur_ptr-30  
001c			os_tok_len: equ os_word_scratch - 2  
001c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
001c			os_tok_malloc: equ os_tok_ptr - 2  
001c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
001c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
001c			execscratch: equ os_input-255        ; exec cmd eval buffer  
001c			scratch: equ execscratch-255  
001c			  
001c			  
001c			; temp locations for new word processing to save on adding more   
001c			  
001c			os_new_malloc: equ scratch-2  
001c			os_new_parse_len: equ os_new_malloc - 2  
001c			os_new_word_len: equ os_new_parse_len - 2  
001c			os_new_work_ptr: equ os_new_word_len - 2  
001c			os_new_src_ptr: equ os_new_work_ptr - 2  
001c			os_new_exec: equ os_new_src_ptr - 2  
001c			os_new_exec_ptr: equ os_new_exec - 2  
001c			  
001c			; resume memory alloocations....  
001c			  
001c			os_view_disable: equ os_new_exec_ptr - 1  
001c			os_view_af: equ os_view_disable - 2  
001c			os_view_hl: equ os_view_af -2  
001c			os_view_de: equ os_view_hl - 2  
001c			os_view_bc: equ os_view_de - 2  
001c			  
001c			; stack checksum word  
001c			if DEBUG_STACK_IMB  
001c				curframe: equ  os_view_de - 5  
001c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
001c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			else  
001c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
001c			endif  
001c			  
001c			; with data stack could see memory filled with junk. need some memory management   
001c			; malloc and free entry points added  
001c			  
001c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
001c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			;heap_end: equ free_list-1  ; Starting address of heap  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			  
001c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
001c			heap_end: equ chk_word-1  ; Starting address of heap  
001c			  
001c			  
001c			;if BASE_KEV   
001c			;heap_start: equ 0800eh  ; Starting address of heap  
001c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;heap_start: equ baseram+15  ; Starting address of heap  
001c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
001c			;endif  
001c			  
001c			  
001c			;;;;  
001c			  
001c			  
001c			; change below to point to last memory alloc above  
001c			topusermem:  equ   heap_start  
001c			  
001c			;if BASE_KEV   
001c			;baseusermem: equ 08000h  
001c			;endif  
001c			  
001c			;if BASE_SC114  
001c			;;aseusermem:     equ    12  
001c			;baseusermem:     equ    prompt  
001c			;;baseusermem:     equ    endofcode  
001c			;endif  
001c			  
001c			  
001c			; **********************************************************************  
001c			; **  Constants  
001c			; **********************************************************************  
001c			  
001c			; Constants used by this code module  
001c			kDataReg:   EQU Device_D           ;PIO port A data register  
001c			kContReg:   EQU Device_D+2           ;PIO port A control register  
001c			  
001c			  
001c			portbdata:  equ Device_D+1    ; port b data  
001c			portbctl:   equ Device_D+3    ; port b control  
001c			  
001c			  
001c			;KEY_SHIFT:   equ 5  
001c			;KEY_SYMBOLSHIFT:  equ 6  
001c			  
001c			KEY_SHIFTLOCK: equ 4  
001c			  
001c			  
001c			KEY_UP: equ 5  
001c			KEY_NEXTWORD: equ 6  
001c			KEY_PREVWORD: equ 7  
001c			KEY_BS: equ 8  
001c			KEY_TAB:  equ 9  
001c			KEY_DOWN: equ 10  
001c			KEY_LEFT: equ 11  
001c			KEY_RIGHT: equ 12  
001c			KEY_CR:   equ 13  
001c			KEY_HOME: equ 14  
001c			KEY_END: equ 15  
001c			  
001c			KEY_F1: equ 16  
001c			KEY_F2: equ 17  
001c			KEY_F3: equ 18  
001c			KEY_F4: equ 19  
001c			  
001c			KEY_F5: equ 20  
001c			KEY_F6: equ 21  
001c			KEY_F7: equ 22  
001c			KEY_F8: equ 23  
001c			  
001c			KEY_F9: equ 24  
001c			KEY_F10: equ 25  
001c			KEY_F11: equ 26  
001c			KEY_F12: equ 27  
001c			  
001c			;if DEBUG_KEY  
001c			;	KEY_MATRIX_NO_PRESS: equ '.'  
001c			;	KEY_SHIFT:   equ '.'  
001c			;	KEY_SYMBOLSHIFT:  equ '.'  
001c			;else  
001c				KEY_SHIFT:   equ '~'  
001c				KEY_SYMBOLSHIFT:  equ '~'  
001c				KEY_MATRIX_NO_PRESS: equ '~'  
001c			;endi  
001c			  
001c			  
001c			  
001c			  
001c			; Macro to make adding debug marks easier  
001c			  
001c			DMARK: macro str  
001c				push af  
001c				ld a, (.dmark)  
001c				ld (debug_mark),a  
001c				ld a, (.dmark+1)  
001c				ld (debug_mark+1),a  
001c				ld a, (.dmark+2)  
001c				ld (debug_mark+2),a  
001c				jr .pastdmark  
001c			.dmark: db str  
001c			.pastdmark: pop af  
001c			  
001c			endm  
001c			  
001c			  
001c			; macro to detect for stack imbalances  
001c			  
001c			include "stackimbal.asm"  
001c			; Macro and code to detect stock imbalances 
001c			 
001c			SPPUSH: equ 0 
001c			 
001c			; Add a stack frame which can be checked before return 
001c			 
001c			STACKFRAME: macro onoff frame1 frame2 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c						exx 
001c			 
001c						ld de, frame1 
001c						ld a, d 
001c						ld hl, curframe 
001c						call hexout 
001c						ld a, e 
001c						ld hl, curframe+2 
001c						call hexout 
001c			  
001c						ld hl, frame1 
001c						push hl 
001c						ld hl, frame2 
001c						push hl 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			endm 
001c			 
001c			STACKFRAMECHK: macro onoff frame1 frame2 
001c			 
001c					 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						exx 
001c						; check stack frame SP 
001c			 
001c						ld hl, frame2 
001c						pop de   ; frame2 
001c			 
001c						call cmp16 
001c						jr nz, .spnosame 
001c						 
001c			 
001c						ld hl, frame1 
001c						pop de   ; frame1 
001c			 
001c						call cmp16 
001c						jr z, .spfrsame 
001c			 
001c						.spnosame: call showsperror 
001c			 
001c						.spfrsame: nop 
001c			 
001c						exx 
001c					endif 
001c					 
001c				endif 
001c			 
001c			 
001c			endm 
001c			 
001c			 
001c			; for a sub routine, wrap SP collection and comparisons 
001c			 
001c			; Usage: 
001c			; 
001c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
001c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
001c			 
001c			SAVESP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c						; save current SP 
001c			 
001c						ld (store_sp+(storeword*4)), sp 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			CHECKSP: macro onoff storeword 
001c			 
001c				if DEBUG_STACK_IMB 
001c					if onoff 
001c			 
001c						; save SP after last save 
001c				 
001c						ld (store_sp+(storeword*4)+2), sp 
001c			 
001c						push hl 
001c						ld hl, store_sp+(storeword*4) 
001c						call check_stack_sp  
001c						pop hl 
001c			 
001c			 
001c					endif 
001c					 
001c				endif 
001c			 
001c			endm 
001c			 
001c			if DEBUG_STACK_IMB 
001c			 
001c			check_stack_sp: 
001c					push de 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					push de 
001c			 
001c			 
001c					ld e, (hl) 
001c					inc hl 
001c					ld d, (hl) 
001c					inc hl 
001c			 
001c					pop hl 
001c			 
001c			 
001c					; check to see if the same 
001c			 
001c					call cmp16 
001c					jr z, .spsame 
001c			 
001c					; not same 
001c			 
001c					call showsperror 
001c			.spsame: 
001c			 
001c					pop de 
001c			 
001c					ret 
001c			 
001c			.sperr:  db "Stack imbalance",0 
001c			 
001c			 
001c			showsperror: 
001c			 
001c			 
001c				push hl 
001c				push af 
001c				push de 
001c				call clear_display 
001c				ld de, .sperr 
001c				ld a,0 
001c			;	ld de,os_word_scratch 
001c				call str_at_display 
001c				ld a, display_row_1+17 
001c				ld de, debug_mark 
001c				call str_at_display 
001c				ld a, 0 
001c				ld (curframe+4),a 
001c				ld hl, curframe 
001c				ld de, os_word_scratch 
001c				ld a, display_row_4 
001c				call str_at_display 
001c				call update_display 
001c				;call break_point_state 
001c				call cin_wait 
001c			 
001c				ld a, ' ' 
001c				ld (os_view_disable), a 
001c				pop de	 
001c				pop af 
001c				pop hl 
001c				CALLMONITOR 
001c				ret 
001c			 
001c			endif 
001c			 
001c			 
001c			 
001c			; eof 
# End of file stackimbal.asm
001c			  
001c			;TODO macro to calc col and row offset into screen  
001c			  
001c			  
001c			  
001c			hardware_init:  
001c			  
001c				  
001c			  
001c					;ld a, 0  
001c					;ld (hardware_diag), a  
001c			  
001c					; clear all the buffers  
001c			  
001c 21 13 fd				ld hl, display_fb1  
001f 22 cf fb				ld (display_fb_active), hl  
0022			  
0022 cd 98 0c				call clear_display  
0025			  
0025 21 d1 fb				ld hl, display_fb2  
0028 22 cf fb				ld (display_fb_active), hl  
002b			  
002b cd 98 0c				call clear_display  
002e			  
002e					; init primary frame buffer area  
002e 21 b4 fd				ld hl, display_fb0  
0031 22 cf fb				ld (display_fb_active), hl  
0034			  
0034 cd 98 0c				call clear_display  
0037			  
0037			  
0037 cd 62 69				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
003a			  
003a cd f9 6b			call key_init  
003d cd bb 01			call storage_init  
0040			  
0040				; setup malloc functions  
0040			  
0040				if MALLOC_1  
0040 cd 6f 13				call  heap_init  
0043				endif  
0043				if MALLOC_4  
0043					call  heap_init  
0043				endif  
0043			  
0043				; init sound hardware if present  
0043			  
0043				if SOUND_ENABLE  
0043 cd 2c 15				call sound_init  
0046				endif  
0046			  
0046				; lcd test sequence  
0046					  
0046 cd bb 0c			call update_display  
0049 cd 15 0c			call delay1s  
004c 3e 2b			ld a,'+'  
004e cd 9d 0c			call fill_display  
0051 cd bb 0c			call update_display  
0054 cd 15 0c			call delay1s  
0057 3e 2a			ld a,'*'  
0059 cd 9d 0c			call fill_display  
005c cd bb 0c			call update_display  
005f cd 15 0c			call delay1s  
0062 3e 2d			ld a,'-'  
0064 cd 9d 0c			call fill_display  
0067 cd bb 0c			call update_display  
006a cd 15 0c			call delay1s  
006d			  
006d			; boot splash screen  
006d			if display_cols == 20	  
006d			        ld a, display_row_1    
006d			else  
006d 3e 0a		        ld a, display_row_1 +10   
006f			endif  
006f 11 49 1a			ld de, prom_bootmsg  
0072 cd ab 0c			call str_at_display  
0075 cd bb 0c			call update_display  
0078			  
0078			  
0078 cd 15 0c			call delay1s  
007b cd 15 0c			call delay1s  
007e			if display_cols == 20	  
007e			            LD   A, display_row_3+2  
007e			else  
007e 3e 5c		            LD   A, display_row_3+12  
0080			endif  
0080 11 5e 1a			ld de, prom_bootmsg1  
0083 cd ab 0c			call str_at_display  
0086 cd bb 0c			call update_display  
0089 cd 15 0c			call delay1s  
008c cd 15 0c			call delay1s  
008f			  
008f			;	ld a, display_row_4+3  
008f			;	ld de, bootmsg2  
008f			;	call str_at_display  
008f			;	call update_display  
008f			;	call delay1s  
008f			;	call delay1s  
008f			  
008f			; debug mark setup  
008f			  
008f 3e 5f		ld a, '_'  
0091 32 6e fe		ld (debug_mark),a  
0094 32 6f fe		ld (debug_mark+1),a  
0097 32 70 fe		ld (debug_mark+2),a  
009a 3e 00		ld a,0  
009c 32 71 fe		ld (debug_mark+3),a  
009f			  
009f c9					ret  
00a0			  
00a0			  
00a0			;bootmsg2:	db "Firmware v0.1",0  
00a0			  
00a0			; a 4x20 lcd  
00a0			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00a0			  
00a0			;if display_cols == 20  
00a0			;	include "firmware_lcd_4x20.asm"  
00a0			;endif  
00a0			  
00a0			;if display_cols == 40  
00a0			;	include "firmware_lcd_4x40.asm"  
00a0			;endif  
00a0			  
00a0			;  
00a0			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00a0			; TODO abstract the bit bang video out interface for dual display  
00a0			; TODO wire video out to tx pin on rc2014 bus  
00a0			  
00a0			; must supply cin, and cin_wait for low level hardware abstraction   
00a0			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00a0			; test scancode  
00a0			  
00a0			;;;;;  
00a0			;;;  
00a0			; Moved out to mini and maxi versions  
00a0			;  
00a0			; include "firmware_key_4x4.asm"  
00a0			; using existing 4 wire x 4 resistor array for input  
00a0			;include "firmware_key_4x10.asm"  
00a0			; need to mod the board for 5 rows due to resistor array  
00a0			;include "firmware_key_5x10.asm"  
00a0			  
00a0			; storage hardware interface  
00a0			  
00a0			; use microchip serial eeprom for storage  
00a0			  
00a0			  
00a0			if STORAGE_SE  
00a0				include "firmware_spi.asm"  
00a0			; my spi protocol (used by storage) 
00a0			 
00a0			; SPI pins 
00a0			 
00a0			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00a0			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00a0			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00a0			 
00a0			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00a0			; chip pin 4 gnd 
00a0			 
00a0			 
00a0			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00a0			SPI_CE1: equ 1      ;    port a1 pin 14  
00a0			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00a0			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00a0			SPI_CE4: equ 4      ; port a4     pin 10 
00a0			 
00a0			; active low AND masks 
00a0			 
00a0			;SPI_CE0_MASK: equ    255-1 
00a0			;SPI_CE1_MASK: equ   255-2 
00a0			;SPI_CE2_MASK: equ   255-4 
00a0			;SPI_CE3_MASK: equ   255-8 
00a0			;SPI_CE4_MASK: equ   255-16 
00a0			SPI_CE_HIGH:  equ 255 
00a0			 
00a0			 
00a0			 
00a0			 
00a0			; TODO store port id for spi device ie dev c 
00a0			; TODO store pin for SO 
00a0			; TODO store pin for SI 
00a0			; TODO store pin for SCLK 
00a0			 
00a0			; 
00a0			 
00a0			; ensure that spi bus is in a stable state with default pins  
00a0			 
00a0			se_stable_spi:   
00a0			 
00a0				 ; set DI high, CE high , SCLK low 
00a0				;ld a, SPI_DI | SPI_CE0 
00a0 3e 07			ld a, SPI_DI  
00a2 cd 76 01			call spi_ce_high 
00a5 d3 80			 out (storage_adata),a 
00a7 32 6b fa			ld (spi_portbyte),a 
00aa			 
00aa				if DEBUG_SPI 
00aa					push hl 
00aa					ld l, a 
00aa					DMARK "SPI" 
00aa					CALLMONITOR 
00aa					pop hl 
00aa				endif 
00aa c9				ret 
00ab			 
00ab			; byte to send in a 
00ab			 
00ab			spi_send_byte: 
00ab				; save byte to send for bit mask shift out 
00ab 4f			        ld c,a 
00ac 3a 6b fa			ld a,(spi_portbyte) 
00af				  
00af				; clock out	each bit of the byte msb first 
00af			 
00af 06 08			ld b, 8 
00b1			.ssb1: 
00b1				; clear so bit  
00b1 cb bf			res SPI_DI, a 
00b3 cb 11			rl c 
00b5				; if bit 7 is set then carry is set 
00b5 30 02			jr nc, .ssb2 
00b7 cb ff			set SPI_DI,a 
00b9			.ssb2:  ; output bit to ensure it is stable 
00b9 d3 80			out (storage_adata),a 
00bb 00				nop 
00bc				; clock bit high 
00bc cb ef			set SPI_SCLK,a 
00be d3 80			out (storage_adata),a 
00c0 00				nop 
00c1				; then low 
00c1 cb af			res SPI_SCLK,a 
00c3 d3 80			out (storage_adata),a 
00c5 00				nop 
00c6 10 e9			djnz .ssb1 
00c8			 
00c8 32 6b fa			ld (spi_portbyte),a 
00cb c9				ret 
00cc			 
00cc			; TODO low level get byte into A on spi 
00cc			 
00cc			spi_read_byte:  
00cc			 
00cc				; save byte to send for bit mask shift out 
00cc 0e 00		    ld c,0 
00ce 3a 6b fa			ld a,(spi_portbyte) 
00d1				  
00d1				; clock out	each bit of the byte msb first 
00d1			 
00d1			 
00d1				; clock bit high 
00d1 cb ef			set SPI_SCLK,a 
00d3 d3 80			out (storage_adata),a 
00d5 00				nop 
00d6			 
00d6			    ; read DO  
00d6			 
00d6 cb f9		    set 7,c 
00d8 db 80			in a,(storage_adata) 
00da cb 77		    bit SPI_DO,a 
00dc 20 02		    jr nz, .b7 
00de cb b9		    res 7,c 
00e0			.b7: 
00e0				; then low 
00e0 cb af			res SPI_SCLK,a 
00e2 d3 80			out (storage_adata),a 
00e4 00				nop 
00e5			     
00e5			 
00e5				; clock bit high 
00e5 cb ef			set SPI_SCLK,a 
00e7 d3 80			out (storage_adata),a 
00e9 00				nop 
00ea			 
00ea			    ; read DO  
00ea			 
00ea cb f1		    set 6,c 
00ec db 80			in a,(storage_adata) 
00ee cb 77		    bit SPI_DO,a 
00f0 20 02		    jr nz, .b6 
00f2 cb b1		    res 6,c 
00f4			.b6: 
00f4				; then low 
00f4 cb af			res SPI_SCLK,a 
00f6 d3 80			out (storage_adata),a 
00f8 00				nop 
00f9			 
00f9				; clock bit high 
00f9 cb ef			set SPI_SCLK,a 
00fb d3 80			out (storage_adata),a 
00fd 00				nop 
00fe			 
00fe			 
00fe			    ; read DO  
00fe			 
00fe cb e9		    set 5,c 
0100 db 80			in a,(storage_adata) 
0102 cb 77		    bit SPI_DO,a 
0104 20 02		    jr nz, .b5 
0106 cb a9		    res 5,c 
0108			.b5: 
0108				; then low 
0108 cb af			res SPI_SCLK,a 
010a d3 80			out (storage_adata),a 
010c 00				nop 
010d				; clock bit high 
010d cb ef			set SPI_SCLK,a 
010f d3 80			out (storage_adata),a 
0111 00				nop 
0112			 
0112			    ; read DO  
0112			 
0112 cb e1		    set 4,c 
0114 db 80			in a,(storage_adata) 
0116 cb 77		    bit SPI_DO,a 
0118 20 02		    jr nz, .b4 
011a cb a1		    res 4,c 
011c			.b4: 
011c				; then low 
011c cb af			res SPI_SCLK,a 
011e d3 80			out (storage_adata),a 
0120 00				nop 
0121				; clock bit high 
0121 cb ef			set SPI_SCLK,a 
0123 d3 80			out (storage_adata),a 
0125 00				nop 
0126			 
0126			    ; read DO  
0126			 
0126 cb d9		    set 3,c 
0128 db 80			in a,(storage_adata) 
012a cb 77		    bit SPI_DO,a 
012c 20 02		    jr nz, .b3 
012e cb 99		    res 3,c 
0130			.b3: 
0130				; then low 
0130 cb af			res SPI_SCLK,a 
0132 d3 80			out (storage_adata),a 
0134 00				nop 
0135				; clock bit high 
0135 cb ef			set SPI_SCLK,a 
0137 d3 80			out (storage_adata),a 
0139 00				nop 
013a			 
013a			    ; read DO  
013a			 
013a cb d1		    set 2,c 
013c db 80			in a,(storage_adata) 
013e cb 77		    bit SPI_DO,a 
0140 20 02		    jr nz, .b2 
0142 cb 91		    res 2,c 
0144			.b2: 
0144				; then low 
0144 cb af			res SPI_SCLK,a 
0146 d3 80			out (storage_adata),a 
0148 00				nop 
0149				; clock bit high 
0149 cb ef			set SPI_SCLK,a 
014b d3 80			out (storage_adata),a 
014d 00				nop 
014e			 
014e			    ; read DO  
014e			 
014e cb c9		    set 1,c 
0150 db 80			in a,(storage_adata) 
0152 cb 77		    bit SPI_DO,a 
0154 20 02		    jr nz, .b1 
0156 cb 89		    res 1,c 
0158			.b1: 
0158				; then low 
0158 cb af			res SPI_SCLK,a 
015a d3 80			out (storage_adata),a 
015c 00				nop 
015d				; clock bit high 
015d cb ef			set SPI_SCLK,a 
015f d3 80			out (storage_adata),a 
0161 00				nop 
0162			 
0162			    ; read DO  
0162			 
0162 cb c1		    set 0,c 
0164 db 80			in a,(storage_adata) 
0166 cb 77		    bit SPI_DO,a 
0168 20 02		    jr nz, .b0 
016a cb 81		    res 0,c 
016c			.b0: 
016c				; then low 
016c cb af			res SPI_SCLK,a 
016e d3 80			out (storage_adata),a 
0170 00				nop 
0171			 
0171			 
0171 32 6b fa			ld (spi_portbyte),a 
0174			 
0174			    ; return byte 
0174 79			    ld a,c 
0175			 
0175			 
0175 c9				ret 
0176			 
0176			 
0176			 
0176			spi_ce_high: 
0176			 
0176				if DEBUG_SPI_HARD_CE0 
0176			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0176					ret 
0176			 
0176				endif 
0176			 
0176			 
0176 f5				push af 
0177			 
0177				; send direct ce to port b 
0177 3e ff			ld a, 255 
0179 d3 81			out (storage_bdata), a 
017b			 
017b f1				pop af 
017c			 
017c				; for port a that shares with spi lines AND the mask 
017c			  
017c				if DEBUG_SPI 
017c					push hl 
017c					ld h, a 
017c				endif 
017c			;	ld c, SPI_CE_HIGH 
017c			;	and c 
017c cb c7			set SPI_CE0, a 
017e cb cf			set SPI_CE1, a 
0180 cb d7			set SPI_CE2, a 
0182 cb df			set SPI_CE3, a 
0184 cb e7			set SPI_CE4, a 
0186			 
0186				if DEBUG_SPI 
0186					ld l, a 
0186					DMARK "CEh" 
0186					CALLMONITOR 
0186					pop hl 
0186				endif 
0186 c9				ret 
0187			 
0187			 
0187			spi_ce_low: 
0187			 
0187				if DEBUG_SPI_HARD_CE0 
0187			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0187					ret 
0187			 
0187				endif 
0187			 
0187 c5				push bc 
0188 f5				push af 
0189			 
0189				; send direct ce to port b 
0189 3a 6d fa			ld a, (spi_cartdev) 
018c d3 81			out (storage_bdata), a 
018e			 
018e			 
018e			 
018e				; for port a that shares with spi lines AND the mask 
018e			 
018e 3a 6a fa			ld a, (spi_device)  
0191 4f				ld c, a 
0192			 
0192 f1				pop af 
0193			 
0193				; detect CEx 
0193			 
0193				if DEBUG_SPI 
0193					push hl 
0193					ld h, a 
0193				endif 
0193			 
0193 cb 41			bit SPI_CE0, c 
0195 20 04			jr nz, .cel1 
0197 cb 87			res SPI_CE0, a 
0199 18 1e			jr .celn 
019b			.cel1: 
019b cb 49			bit SPI_CE1, c 
019d 20 04			jr nz, .cel2 
019f cb 8f			res SPI_CE1, a 
01a1 18 16			jr .celn 
01a3			.cel2: 
01a3 cb 51			bit SPI_CE2, c 
01a5 20 04			jr nz, .cel3 
01a7 cb 97			res SPI_CE2, a 
01a9 18 0e			jr .celn 
01ab			.cel3: 
01ab cb 59			bit SPI_CE3, c 
01ad 20 04			jr nz, .cel4 
01af cb 9f			res SPI_CE3, a 
01b1 18 06			jr .celn 
01b3			.cel4: 
01b3 cb 61			bit SPI_CE4, c 
01b5 20 02			jr nz, .celn 
01b7 cb a7			res SPI_CE4, a 
01b9			.celn: 
01b9			 
01b9			 
01b9			 
01b9			;	add c 
01b9			 
01b9				if DEBUG_SPI 
01b9					ld l, a 
01b9					DMARK "CEl" 
01b9					CALLMONITOR 
01b9					pop hl 
01b9				endif 
01b9 c1				pop bc 
01ba c9				ret 
01bb			 
01bb			 
01bb			 
01bb			; eof 
01bb			 
01bb			 
01bb			 
01bb			 
01bb			 
# End of file firmware_spi.asm
01bb				include "firmware_seeprom.asm"  
01bb			; 
01bb			; persisent storage interface via microchip serial eeprom 
01bb			 
01bb			; port a pio 2 
01bb			; pa 7 - si 
01bb			; pa 6 - sclk  
01bb			; pa 5 - so 
01bb			; pa 4 - cs 
01bb			; pa 3 - cs 
01bb			; pa 2 - cs 
01bb			; pa 1 - cs 
01bb			; pa 0 - cs 
01bb			; 
01bb			; TODO get block 
01bb			; TODO save block 
01bb			; TODO load file 
01bb			; TODO save file 
01bb			; TODO get dir  
01bb			 
01bb			;  
01bb			storage_adata: equ Device_C    ; device c port a - onboard storage 
01bb			storage_actl: equ Device_C+2     ; device c port a 
01bb			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01bb			storage_bctl: equ Device_C+3     ; device c port b 
01bb			 
01bb			 
01bb			; TODO move these to hardware driver file 
01bb			 
01bb			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01bb			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01bb			; storage bank file system format 
01bb			; 
01bb			; first page of bank: 
01bb			; 	addr 0 - status check 
01bb			;       addr 1 - write protect flag 
01bb			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01bb			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01bb			;         TODO see if scanning whole of for available next file id is fast enough 
01bb			;	addr 4 > zero term string of bank label 
01bb			; 
01bb			;        
01bb			;  
01bb			; first page of any file: 
01bb			;      byte 0 - file id  
01bb			;      byte 1-17 - fixed file name  
01bb			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01bb			; 
01bb			; other pages of any file: 
01bb			;      byte 0 - file id 
01bb			;      byte 1> - file data 
01bb			; 
01bb			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01bb			;  
01bb			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01bb			 
01bb			 
01bb			;storage_so_bit: 5 
01bb			;storage_si_bit: 7 
01bb			;storage_sclk_bit: 6 
01bb			  
01bb			 
01bb			; init storage pio 
01bb			 
01bb			storage_init: 
01bb			 
01bb 3e cf		            LD   A, 11001111b 
01bd d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01bf 3e 00		            LD   A, 00000000b 
01c1 cb f7			set SPI_DO,a 
01c3			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01c3 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01c5			 
01c5 3e cf		            LD   A, 11001111b 
01c7 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01c9 3e 00		            LD   A, 00000000b 
01cb d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01cd			 
01cd				; set all external spi devices off 
01cd 3e 00			ld a, 0 
01cf 32 6a fa			ld (spi_device), a 
01d2 32 6d fa			ld (spi_cartdev), a 
01d5			 
01d5					; ensure the spi bus is in a default stable state 
01d5 cd a0 00				call se_stable_spi 
01d8			 
01d8			; TODO scan spi bus and gather which storage banks are present 
01d8			 
01d8			; populate store_bank_active  
01d8			; for each ce line activate and attempt to write first byte of bank and read back 
01d8			; if zero is returned then bank is empty 
01d8			;   
01d8			; 
01d8			 
01d8					; init file extent cache to save on slow reads 
01d8			 
01d8			;	ld hl, store_filecache 
01d8			;	ld de, 0 
01d8			;	ld hl,(de)	 
01d8			 
01d8			 
01d8 c9			    ret 
01d9			 
01d9			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01d9			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01d9			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01d9			 
01d9			; INSTRUCTION SET 
01d9			; READ 0000 0011 Read data from memory array beginning at selected address 
01d9			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01d9			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01d9			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01d9			; RDSR 0000 0101 Read STATUS register 
01d9			; WRSR 0000 0001 Write STATUS register 
01d9			; PE 0100 0010 Page Erase – erase one page in memory array 
01d9			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01d9			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01d9			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01d9			 
01d9			; TODO send byte steam for page without setting the address for every single byte 
01d9			; TODO read byte  
01d9			 
01d9			; byte in a 
01d9			; address in hl  
01d9			se_writebyte: 
01d9			        
01d9			    ;   ld c, a 
01d9 f5			        push af 
01da e5			        push hl 
01db			 
01db			    ; initi write mode 
01db			    ; 
01db			    ;CS low 
01db			 
01db 3a 6b fa		       ld a,(spi_portbyte) 
01de cd 87 01			call spi_ce_low 
01e1			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01e1 d3 80		       out (storage_adata),a 
01e3 32 6b fa		       ld (spi_portbyte), a 
01e6			 
01e6			    ;clock out wren instruction 
01e6			 
01e6 3e 06		    ld a, store_wren_ins 
01e8 cd ab 00		    call spi_send_byte  
01eb			 
01eb			    ;cs high to enable write latch 
01eb			 
01eb 3a 6b fa		       ld a,(spi_portbyte) 
01ee cd 76 01			call spi_ce_high 
01f1			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01f1 d3 80		       out (storage_adata),a 
01f3 32 6b fa		       ld (spi_portbyte), a 
01f6			 
01f6 00				nop 
01f7			    ; 
01f7			    ; intial write data 
01f7			    ; 
01f7			    ; cs low 
01f7			     
01f7 3a 6b fa		       ld a,(spi_portbyte) 
01fa cd 87 01			call spi_ce_low 
01fd			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01fd d3 80		       out (storage_adata),a 
01ff 32 6b fa		       ld (spi_portbyte), a 
0202			 
0202			    ; clock out write instruction 
0202			     
0202 3e 02		    ld a, store_write_ins  
0204 cd ab 00		    call spi_send_byte  
0207			 
0207			    ; clock out address (depending on address size) 
0207			     
0207 e1			    pop hl 
0208 7c			    ld a,h    ; address out msb first 
0209 cd ab 00		    call spi_send_byte  
020c 7d			    ld a,l 
020d cd ab 00		    call spi_send_byte  
0210			 
0210			    ; clock out byte(s) for page 
0210			 
0210 f1			    pop af 
0211 cd ab 00		    call spi_send_byte  
0214			 
0214			    ; end write with ce high 
0214 3a 6b fa		       ld a,(spi_portbyte) 
0217			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0217 cd 76 01			call spi_ce_high 
021a d3 80		       out (storage_adata),a 
021c 32 6b fa		       ld (spi_portbyte), a 
021f			 
021f				; pause for internal write cycle 
021f 3e 0a			ld a, 10 
0221 cd fa 0b			call aDelayInMS 
0224 c9			    ret 
0225			 
0225			; buffer to write in de 
0225			; address in hl  
0225			se_writepage: 
0225			        
0225			    ;   ld c, a 
0225 d5				push de 
0226 e5			        push hl 
0227			 
0227			    ; initi write mode 
0227			    ; 
0227			    ;CS low 
0227			 
0227 3a 6b fa		       ld a,(spi_portbyte) 
022a cd 87 01			call spi_ce_low 
022d			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
022d d3 80		       out (storage_adata),a 
022f 32 6b fa		       ld (spi_portbyte), a 
0232			 
0232			    ;clock out wren instruction 
0232			 
0232 3e 06		    ld a, store_wren_ins 
0234 cd ab 00		    call spi_send_byte  
0237			 
0237			    ;cs high to enable write latch 
0237			 
0237 3a 6b fa		       ld a,(spi_portbyte) 
023a cd 76 01			call spi_ce_high 
023d			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
023d d3 80		       out (storage_adata),a 
023f 32 6b fa		       ld (spi_portbyte), a 
0242			 
0242 00				nop 
0243			    ; 
0243			    ; intial write data 
0243			    ; 
0243			    ; cs low 
0243			     
0243 3a 6b fa		       ld a,(spi_portbyte) 
0246			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0246 cd 87 01			call spi_ce_low 
0249 d3 80		       out (storage_adata),a 
024b 32 6b fa		       ld (spi_portbyte), a 
024e			 
024e			    ; clock out write instruction 
024e			     
024e 3e 02		    ld a, store_write_ins  
0250 cd ab 00		    call spi_send_byte  
0253			 
0253			    ; clock out address (depending on address size) 
0253			     
0253 e1			    pop hl 
0254 7c			    ld a,h    ; address out msb first 
0255 cd ab 00		    call spi_send_byte  
0258 7d			    ld a,l 
0259 cd ab 00		    call spi_send_byte  
025c			 
025c			    ; clock out byte(s) for page 
025c			 
025c e1				pop hl 
025d 06 40			ld b, STORE_BLOCK_PHY 
025f			.bytewrite: 
025f			 
025f 7e				ld a,(hl) 
0260 e5			    push hl 
0261 c5				push bc 
0262 cd ab 00		    call spi_send_byte  
0265 c1				pop bc 
0266 e1				pop hl 
0267			 
0267			    ; end write with ce high 
0267 3a 6b fa		       ld a,(spi_portbyte) 
026a cd 76 01			call spi_ce_high 
026d			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
026d d3 80		       out (storage_adata),a 
026f 32 6b fa		       ld (spi_portbyte), a 
0272			 
0272 23				inc hl 
0273 10 ea			djnz .bytewrite 
0275			 
0275				; pause for internal write cycle 
0275 3e 64			ld a, 100 
0277 cd fa 0b			call aDelayInMS 
027a c9			    ret 
027b			; returns byte in a 
027b			; address in hl  
027b			se_readbyte: 
027b d5				push de 
027c c5				push bc 
027d			 
027d			    ;   ld c, a 
027d e5			        push hl 
027e			 
027e			    ; initi write mode 
027e			    ; 
027e			    ;CS low 
027e			 
027e 3a 6b fa		       ld a,(spi_portbyte) 
0281 cd 87 01			call spi_ce_low 
0284			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0284 d3 80		       out (storage_adata),a 
0286 32 6b fa		       ld (spi_portbyte), a 
0289			 
0289			    ;clock out wren instruction 
0289			 
0289 3e 03		    ld a, store_read_ins 
028b cd ab 00		    call spi_send_byte  
028e			 
028e			 
028e			    ; clock out address (depending on address size) 
028e			     
028e e1			    pop hl 
028f 7c			    ld a,h    ; address out msb first 
0290 cd ab 00		    call spi_send_byte  
0293 7d			    ld a,l 
0294 cd ab 00		    call spi_send_byte  
0297			 
0297			    ; clock in byte(s) for page 
0297			 
0297 cd cc 00		    call spi_read_byte  
029a f5				push af 
029b			 
029b			    ; end write with ce high 
029b 3a 6b fa		       ld a,(spi_portbyte) 
029e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
029e cd 76 01			call spi_ce_high 
02a1 d3 80		       out (storage_adata),a 
02a3 32 6b fa		       ld (spi_portbyte), a 
02a6			 
02a6 f1				pop af 
02a7			 
02a7 c1				pop bc 
02a8 d1				pop de 
02a9			 
02a9 c9			    ret 
02aa			 
02aa			if DEBUG_STORESE 
02aa			 
02aa			storageput:  
02aa			 
02aa			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02aa			 
02aa 21 01 f2			ld hl,scratch+2 
02ad cd 83 12			call get_word_hl 
02b0			 
02b0				; stuff it here for the moment as it will be overwritten later anyway 
02b0			 
02b0 22 22 f5			ld (os_cur_ptr),hl	 
02b3			 
02b3			 
02b3			; get pointer to start of string 
02b3			 
02b3 21 06 f2			ld hl, scratch+7 
02b6			 
02b6			; loop writing char of string to eeprom 
02b6			 
02b6 7e			.writestr:	ld a,(hl) 
02b7 fe 00				cp 0 
02b9 28 12				jr z, .wsdone		; done writing 
02bb e5					push hl 
02bc 2a 22 f5				ld hl,(os_cur_ptr) 
02bf cd d9 01				call se_writebyte 
02c2			 
02c2 2a 22 f5				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02c5 23					inc hl 
02c6 22 22 f5				ld (os_cur_ptr),hl 
02c9			 
02c9					; restore string pointer and get next char 
02c9			 
02c9 e1					pop hl 
02ca 23					inc hl 
02cb 18 e9				jr .writestr 
02cd			 
02cd			 
02cd			 
02cd			.wsdone: 
02cd			 
02cd			 
02cd			; when done load first page into a buffer  
02cd			 
02cd 21 00 80				ld hl,08000h		; start in ram 
02d0 22 22 f5				ld (os_cur_ptr),hl 
02d3 21 00 00				ld hl, 0		 ; start of page 
02d6 22 27 f2				ld (scratch+40),hl	; hang on to it 
02d9			 
02d9 06 80				ld b, 128		; actually get more then one page 
02db c5			.wsload:	push bc 
02dc 2a 27 f2				ld hl,(scratch+40) 
02df e5					push hl 
02e0 cd 7b 02				call se_readbyte 
02e3			 
02e3					; a now as the byte 
02e3			 
02e3 2a 22 f5				ld hl,(os_cur_ptr) 
02e6 77					ld (hl),a 
02e7					; inc next buffer area 
02e7 23					inc hl 
02e8 22 22 f5				ld (os_cur_ptr),hl 
02eb			 
02eb					; get eeprom position, inc and save for next round 
02eb e1					pop hl		 
02ec 23					inc hl 
02ed 22 27 f2				ld (scratch+40),hl 
02f0 c1					pop bc 
02f1 10 e8				djnz .wsload 
02f3			 
02f3			; set 'd' pointer to start of buffer 
02f3			 
02f3 21 00 80				ld hl,08000h 
02f6 22 22 f5				ld (os_cur_ptr),hl 
02f9			 
02f9			 
02f9 c9			ret 
02fa			 
02fa			 
02fa c9			storageread: ret 
02fb			 
02fb			 
02fb			 
02fb			 
02fb			 
02fb			 
02fb			endif 
02fb			 
02fb			 
02fb			 
# End of file firmware_seeprom.asm
02fb			else  
02fb			   ; create some stubs for the labels  
02fb			se_readbyte: ret  
02fb			se_writebyte: ret  
02fb			storage_init: ret  
02fb			  
02fb			endif  
02fb			  
02fb			; use cf card for storage - throwing timeout errors. Hardware or software?????  
02fb			;include "firmware_cf.asm"  
02fb			  
02fb			; load up high level storage hardward abstractions  
02fb			include "firmware_storage.asm"  
02fb			 
02fb			; persisent storage hardware abstraction layer  
02fb			 
02fb			 
02fb			 
02fb			; Block 0 on storage is a config state 
02fb			 
02fb			 
02fb			 
02fb			; TODO add read phy block and write phy block functions 
02fb			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
02fb			 
02fb			; Abstraction layer  
02fb			 
02fb			; Logocial block size is same size as physical size - using tape concept 
02fb			 
02fb			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
02fb			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
02fb			 
02fb			 
02fb			 
02fb			; Filesystem layout (Logical layout) 
02fb			; 
02fb			; Block 0 - Bank config  
02fb			; 
02fb			;      Byte - 0 file id counter 
02fb			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
02fb			;      Byte - 3-20 zero terminated bank label 
02fb			; 
02fb			; Block 1 > File storage 
02fb			; 
02fb			;      Byte 0 file id    - block 0 file details 
02fb			;      Byte 1 block id - block 0 is file  
02fb			;            Byte 2-15 - File name 
02fb			; 
02fb			;       - to end of block data 
02fb			; 
02fb			 
02fb			; Get ID for the file named in pointer held HL 
02fb			; Returns ID in HL = 255 if no file found 
02fb			 
02fb			storage_getid: 
02fb			 
02fb 22 7a fa			ld (store_tmp1), hl 
02fe			 
02fe				if DEBUG_STORESE 
02fe					DMARK "SGI" 
02fe f5				push af  
02ff 3a 13 03			ld a, (.dmark)  
0302 32 6e fe			ld (debug_mark),a  
0305 3a 14 03			ld a, (.dmark+1)  
0308 32 6f fe			ld (debug_mark+1),a  
030b 3a 15 03			ld a, (.dmark+2)  
030e 32 70 fe			ld (debug_mark+2),a  
0311 18 03			jr .pastdmark  
0313 ..			.dmark: db "SGI"  
0316 f1			.pastdmark: pop af  
0317			endm  
# End of macro DMARK
0317					CALLMONITOR 
0317 cd 73 18			call break_point_state  
031a				endm  
# End of macro CALLMONITOR
031a				endif 
031a				; get block 0 and set counter for number of files to scan 
031a			 
031a cd 85 04			call storage_get_block_0 
031d			 
031d 3a 81 fa			ld a, (store_page) 
0320 47				ld b, a 
0321			 
0321				; get extent 0 of each file id 
0321			 
0321				if DEBUG_STORESE 
0321					DMARK "SGc" 
0321 f5				push af  
0322 3a 36 03			ld a, (.dmark)  
0325 32 6e fe			ld (debug_mark),a  
0328 3a 37 03			ld a, (.dmark+1)  
032b 32 6f fe			ld (debug_mark+1),a  
032e 3a 38 03			ld a, (.dmark+2)  
0331 32 70 fe			ld (debug_mark+2),a  
0334 18 03			jr .pastdmark  
0336 ..			.dmark: db "SGc"  
0339 f1			.pastdmark: pop af  
033a			endm  
# End of macro DMARK
033a					CALLMONITOR 
033a cd 73 18			call break_point_state  
033d				endm  
# End of macro CALLMONITOR
033d				endif 
033d 60			.getloop:	ld h, b 
033e 2e 00				ld l, 0 
0340 c5					push bc 
0341			 
0341 11 81 fa				ld de, store_page 
0344				if DEBUG_STORESE 
0344					DMARK "SGr" 
0344 f5				push af  
0345 3a 59 03			ld a, (.dmark)  
0348 32 6e fe			ld (debug_mark),a  
034b 3a 5a 03			ld a, (.dmark+1)  
034e 32 6f fe			ld (debug_mark+1),a  
0351 3a 5b 03			ld a, (.dmark+2)  
0354 32 70 fe			ld (debug_mark+2),a  
0357 18 03			jr .pastdmark  
0359 ..			.dmark: db "SGr"  
035c f1			.pastdmark: pop af  
035d			endm  
# End of macro DMARK
035d					CALLMONITOR 
035d cd 73 18			call break_point_state  
0360				endm  
# End of macro CALLMONITOR
0360				endif 
0360 cd 2d 09				call storage_read 
0363 cd f5 0e				call ishlzero 
0366 28 2d				jr z, .gap 
0368					 
0368					; have a file name read. Is it one we want. 
0368			 
0368 2a 7a fa				ld hl, (store_tmp1) 
036b 11 84 fa				ld de, store_page+3   ; file name 
036e			 
036e				if DEBUG_STORESE 
036e					DMARK "SGc" 
036e f5				push af  
036f 3a 83 03			ld a, (.dmark)  
0372 32 6e fe			ld (debug_mark),a  
0375 3a 84 03			ld a, (.dmark+1)  
0378 32 6f fe			ld (debug_mark+1),a  
037b 3a 85 03			ld a, (.dmark+2)  
037e 32 70 fe			ld (debug_mark+2),a  
0381 18 03			jr .pastdmark  
0383 ..			.dmark: db "SGc"  
0386 f1			.pastdmark: pop af  
0387			endm  
# End of macro DMARK
0387					CALLMONITOR 
0387 cd 73 18			call break_point_state  
038a				endm  
# End of macro CALLMONITOR
038a				endif 
038a cd 62 13				call strcmp 
038d 20 06				jr nz, .gap   ; not this one 
038f			 
038f c1				        pop bc 
0390			 
0390 26 00				ld h, 0 
0392 68					ld l, b 
0393 18 22				jr .getdone 
0395						 
0395			 
0395			 
0395			 
0395			.gap: 
0395				if DEBUG_STORESE 
0395					DMARK "SGg" 
0395 f5				push af  
0396 3a aa 03			ld a, (.dmark)  
0399 32 6e fe			ld (debug_mark),a  
039c 3a ab 03			ld a, (.dmark+1)  
039f 32 6f fe			ld (debug_mark+1),a  
03a2 3a ac 03			ld a, (.dmark+2)  
03a5 32 70 fe			ld (debug_mark+2),a  
03a8 18 03			jr .pastdmark  
03aa ..			.dmark: db "SGg"  
03ad f1			.pastdmark: pop af  
03ae			endm  
# End of macro DMARK
03ae					CALLMONITOR 
03ae cd 73 18			call break_point_state  
03b1				endm  
# End of macro CALLMONITOR
03b1				endif 
03b1			 
03b1 c1					pop bc 
03b2 10 89				djnz .getloop 
03b4 21 ff 00				ld hl, 255 
03b7			.getdone: 
03b7			 
03b7				if DEBUG_STORESE 
03b7					DMARK "SGe" 
03b7 f5				push af  
03b8 3a cc 03			ld a, (.dmark)  
03bb 32 6e fe			ld (debug_mark),a  
03be 3a cd 03			ld a, (.dmark+1)  
03c1 32 6f fe			ld (debug_mark+1),a  
03c4 3a ce 03			ld a, (.dmark+2)  
03c7 32 70 fe			ld (debug_mark+2),a  
03ca 18 03			jr .pastdmark  
03cc ..			.dmark: db "SGe"  
03cf f1			.pastdmark: pop af  
03d0			endm  
# End of macro DMARK
03d0					CALLMONITOR 
03d0 cd 73 18			call break_point_state  
03d3				endm  
# End of macro CALLMONITOR
03d3				endif 
03d3			 
03d3 c9				ret 
03d4			 
03d4			 
03d4			 
03d4			 
03d4			 
03d4			 
03d4			 
03d4			 
03d4			; Read Block 
03d4			; ---------- 
03d4			; 
03d4			; With current bank 
03d4			;  
03d4			; Get block number to read 
03d4			; Load physical blocks starting at start block into buffer 
03d4			 
03d4			; de points to buffer to use 
03d4			; hl holds logical block number  
03d4			 
03d4			storage_read_block: 
03d4			 
03d4				; TODO bank selection 
03d4			 
03d4				; for each of the physical blocks read it into the buffer 
03d4 06 40			ld b, STORE_BLOCK_PHY 
03d6			 
03d6				if DEBUG_STORESE 
03d6 d5					push de 
03d7				endif 
03d7				 
03d7			.rl1:    
03d7			 
03d7				; read physical block at hl into de 
03d7			        ; increment hl and de to next read position on exit 
03d7			 
03d7 e5				push hl 
03d8 d5				push de	 
03d9 c5				push bc 
03da			;	if DEBUG_STORESE 
03da			;		push af 
03da			;		ld a, 'R' 
03da			;		ld (debug_mark),a 
03da			;		pop af 
03da			;		CALLMONITOR 
03da			;	endif 
03da cd 7b 02			call se_readbyte 
03dd			;	if DEBUG_STORESE 
03dd			;		ld a,(spi_portbyte) 
03dd			;		ld l, a 
03dd			;		push af 
03dd			;		ld a, '1' 
03dd			;		ld (debug_mark),a 
03dd			;		pop af 
03dd			;		CALLMONITOR 
03dd			;	endif 
03dd c1				pop bc 
03de d1				pop de 
03df e1				pop hl 
03e0 12				ld (de),a 
03e1 23				inc hl 
03e2 13				inc de 
03e3			 
03e3			;	if DEBUG_STORESE 
03e3			;		push af 
03e3			;		ld a, 'r' 
03e3			;		ld (debug_mark),a 
03e3			;		pop af 
03e3			;		CALLMONITOR 
03e3			;	endif 
03e3			 
03e3 10 f2			djnz .rl1 
03e5			 
03e5				if DEBUG_STORESE 
03e5					DMARK "SRB" 
03e5 f5				push af  
03e6 3a fa 03			ld a, (.dmark)  
03e9 32 6e fe			ld (debug_mark),a  
03ec 3a fb 03			ld a, (.dmark+1)  
03ef 32 6f fe			ld (debug_mark+1),a  
03f2 3a fc 03			ld a, (.dmark+2)  
03f5 32 70 fe			ld (debug_mark+2),a  
03f8 18 03			jr .pastdmark  
03fa ..			.dmark: db "SRB"  
03fd f1			.pastdmark: pop af  
03fe			endm  
# End of macro DMARK
03fe d1					pop de 
03ff			; 
03ff			;		push af 
03ff			;		ld a, 'R' 
03ff			;		ld (debug_mark),a 
03ff			;		pop af 
03ff					CALLMONITOR 
03ff cd 73 18			call break_point_state  
0402				endm  
# End of macro CALLMONITOR
0402				endif 
0402 c9				ret	 
0403				 
0403			 
0403			; File Size 
0403			; --------- 
0403			; 
0403			;   hl file id 
0403			; 
0403			;  returns in hl the number of blocks 
0403			 
0403			storage_file_size: 
0403 5d				ld e, l 
0404 16 00			ld d, 0 
0406 21 40 00			ld hl, STORE_BLOCK_PHY 
0409					if DEBUG_FORTH_WORDS 
0409						DMARK "SIZ" 
0409 f5				push af  
040a 3a 1e 04			ld a, (.dmark)  
040d 32 6e fe			ld (debug_mark),a  
0410 3a 1f 04			ld a, (.dmark+1)  
0413 32 6f fe			ld (debug_mark+1),a  
0416 3a 20 04			ld a, (.dmark+2)  
0419 32 70 fe			ld (debug_mark+2),a  
041c 18 03			jr .pastdmark  
041e ..			.dmark: db "SIZ"  
0421 f1			.pastdmark: pop af  
0422			endm  
# End of macro DMARK
0422						CALLMONITOR 
0422 cd 73 18			call break_point_state  
0425				endm  
# End of macro CALLMONITOR
0425					endif 
0425 cd 07 07			call storage_findnextid 
0428			 
0428 cd f5 0e			call ishlzero 
042b			;	ld a, l 
042b			;	add h 
042b			;	cp 0 
042b c8				ret z			; block not found so EOF 
042c			 
042c 11 81 fa			ld de, store_page 
042f cd d4 03			call storage_read_block 
0432			 
0432 3a 83 fa			ld a, (store_page+2)	 ; get extent count 
0435 6f				ld l, a 
0436 26 00			ld h, 0 
0438 c9			 	ret 
0439			 
0439			 
0439			; Write Block 
0439			; ----------- 
0439			; 
0439			; With current bank 
0439			;  
0439			; Get block number to write 
0439			; Write physical blocks starting at start block from buffer 
0439			  
0439			storage_write_block: 
0439				; TODO bank selection 
0439			 
0439				; for each of the physical blocks read it into the buffer 
0439 06 40			ld b, STORE_BLOCK_PHY 
043b			 
043b				if DEBUG_STORESE 
043b					DMARK "SWB" 
043b f5				push af  
043c 3a 50 04			ld a, (.dmark)  
043f 32 6e fe			ld (debug_mark),a  
0442 3a 51 04			ld a, (.dmark+1)  
0445 32 6f fe			ld (debug_mark+1),a  
0448 3a 52 04			ld a, (.dmark+2)  
044b 32 70 fe			ld (debug_mark+2),a  
044e 18 03			jr .pastdmark  
0450 ..			.dmark: db "SWB"  
0453 f1			.pastdmark: pop af  
0454			endm  
# End of macro DMARK
0454			 
0454					;push af 
0454					;ld a, 'W' 
0454					;ld (debug_mark),a 
0454					;pop af 
0454					CALLMONITOR 
0454 cd 73 18			call break_point_state  
0457				endm  
# End of macro CALLMONITOR
0457				endif 
0457			 
0457			; might not be working 
0457			;	call se_writepage 
0457			 
0457			;	ret 
0457			; 
0457			 
0457			 
0457			 
0457			.wl1:    
0457			 
0457				; read physical block at hl into de 
0457			        ; increment hl and de to next read position on exit 
0457			 
0457 e5				push hl 
0458 d5				push de	 
0459 c5				push bc 
045a 1a				ld a,(de) 
045b				;if DEBUG_STORESE 
045b			;		push af 
045b			;		ld a, 'W' 
045b			;		ld (debug_mark),a 
045b			;		pop af 
045b			;		CALLMONITOR 
045b			;	endif 
045b cd d9 01			call se_writebyte 
045e			;	call delay250ms 
045e 00				nop 
045f 00				nop 
0460 00				nop 
0461			;	if DEBUG_STORESE 
0461			;		push af 
0461			;		ld a, 'w' 
0461			;		ld (debug_mark),a 
0461			;		pop af 
0461			;		CALLMONITOR 
0461			;	endif 
0461 c1				pop bc 
0462 d1				pop de 
0463 e1				pop hl 
0464 23				inc hl 
0465 13				inc de 
0466			 
0466			 
0466 10 ef			djnz .wl1 
0468			 
0468				if DEBUG_STORESE 
0468					DMARK "SW2" 
0468 f5				push af  
0469 3a 7d 04			ld a, (.dmark)  
046c 32 6e fe			ld (debug_mark),a  
046f 3a 7e 04			ld a, (.dmark+1)  
0472 32 6f fe			ld (debug_mark+1),a  
0475 3a 7f 04			ld a, (.dmark+2)  
0478 32 70 fe			ld (debug_mark+2),a  
047b 18 03			jr .pastdmark  
047d ..			.dmark: db "SW2"  
0480 f1			.pastdmark: pop af  
0481			endm  
# End of macro DMARK
0481			 
0481					;push af 
0481					;ld a, 'W' 
0481					;ld (debug_mark),a 
0481					;pop af 
0481					CALLMONITOR 
0481 cd 73 18			call break_point_state  
0484				endm  
# End of macro CALLMONITOR
0484				endif 
0484 c9				ret	 
0485			 
0485			; Init bank 
0485			; --------- 
0485			; 
0485			; With current bank 
0485			; 
0485			; Setup block 0 config 
0485			;     Set 0 file id counter 
0485			;     Set formatted byte pattern 
0485			;     Zero out bank label 
0485			;      
0485			; For every logical block write 0-1 byte as null 
0485			 
0485			storage_get_block_0: 
0485			 
0485				; TODO check presence 
0485			 
0485				; get block 0 config 
0485			 
0485 21 00 00			ld hl, 0 
0488 11 81 fa			ld de, store_page 
048b cd d4 03			call storage_read_block 
048e			 
048e				if DEBUG_STORESE 
048e					DMARK "SB0" 
048e f5				push af  
048f 3a a3 04			ld a, (.dmark)  
0492 32 6e fe			ld (debug_mark),a  
0495 3a a4 04			ld a, (.dmark+1)  
0498 32 6f fe			ld (debug_mark+1),a  
049b 3a a5 04			ld a, (.dmark+2)  
049e 32 70 fe			ld (debug_mark+2),a  
04a1 18 03			jr .pastdmark  
04a3 ..			.dmark: db "SB0"  
04a6 f1			.pastdmark: pop af  
04a7			endm  
# End of macro DMARK
04a7 11 81 fa				ld de, store_page 
04aa			;		push af 
04aa			;		ld a, 'i' 
04aa			;		ld (debug_mark),a 
04aa			;		pop af 
04aa					CALLMONITOR 
04aa cd 73 18			call break_point_state  
04ad				endm  
# End of macro CALLMONITOR
04ad				endif 
04ad			 
04ad				; is this area formatted? 
04ad			 
04ad			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04ad 2a 82 fa			ld hl, (store_page+1) 
04b0 3e 80			ld a,0x80 
04b2 bd				cp l 
04b3 20 22			jr nz, .ininotformatted 
04b5				; do a double check 
04b5 3e 27			ld a, 0x27 
04b7 bc				cp h 
04b8 20 1d			jr nz, .ininotformatted 
04ba			 
04ba				; formatted then 
04ba			 
04ba				if DEBUG_STORESE 
04ba					DMARK "SB1" 
04ba f5				push af  
04bb 3a cf 04			ld a, (.dmark)  
04be 32 6e fe			ld (debug_mark),a  
04c1 3a d0 04			ld a, (.dmark+1)  
04c4 32 6f fe			ld (debug_mark+1),a  
04c7 3a d1 04			ld a, (.dmark+2)  
04ca 32 70 fe			ld (debug_mark+2),a  
04cd 18 03			jr .pastdmark  
04cf ..			.dmark: db "SB1"  
04d2 f1			.pastdmark: pop af  
04d3			endm  
# End of macro DMARK
04d3					;push af 
04d3					;ld a, 'I' 
04d3					;ld (debug_mark),a 
04d3					;pop af 
04d3					CALLMONITOR 
04d3 cd 73 18			call break_point_state  
04d6				endm  
# End of macro CALLMONITOR
04d6				endif 
04d6 c9				ret 
04d7			 
04d7			.ininotformatted: 
04d7				; bank not formatted so poke various bits to make sure 
04d7			 
04d7				if DEBUG_STORESE 
04d7					DMARK "SB2" 
04d7 f5				push af  
04d8 3a ec 04			ld a, (.dmark)  
04db 32 6e fe			ld (debug_mark),a  
04de 3a ed 04			ld a, (.dmark+1)  
04e1 32 6f fe			ld (debug_mark+1),a  
04e4 3a ee 04			ld a, (.dmark+2)  
04e7 32 70 fe			ld (debug_mark+2),a  
04ea 18 03			jr .pastdmark  
04ec ..			.dmark: db "SB2"  
04ef f1			.pastdmark: pop af  
04f0			endm  
# End of macro DMARK
04f0					;push af 
04f0					;ld a, 'f' 
04f0					;ld (debug_mark),a 
04f0					;pop af 
04f0					CALLMONITOR 
04f0 cd 73 18			call break_point_state  
04f3				endm  
# End of macro CALLMONITOR
04f3				endif 
04f3			 
04f3 cd d8 0b			call storage_clear_page 
04f6			 
04f6 21 81 fa			ld hl, store_page 
04f9 3e 00			ld a, 0 
04fb				 
04fb 77				ld (hl),a   ; reset file counter 
04fc			 
04fc 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
04ff 22 82 fa		 	ld (store_page+1), hl	 
0502			 
0502				; set default label 
0502			 
0502 21 9e 05			ld hl, .defaultbanklabl 
0505 11 84 fa		 	ld de, store_page+3 
0508 01 0f 00			ld bc, 15 
050b ed b0			ldir 
050d			 
050d				; Append the current bank id 
050d 21 8d fa			ld hl, store_page+3+9 
0510 3a 69 fa			ld a, (spi_device_id) 
0513 77				ld (hl), a 
0514			 
0514				; save default page 0 
0514			 
0514 21 00 00			ld hl, 0 
0517 11 81 fa			ld de, store_page 
051a				if DEBUG_STORESE 
051a					DMARK "SB3" 
051a f5				push af  
051b 3a 2f 05			ld a, (.dmark)  
051e 32 6e fe			ld (debug_mark),a  
0521 3a 30 05			ld a, (.dmark+1)  
0524 32 6f fe			ld (debug_mark+1),a  
0527 3a 31 05			ld a, (.dmark+2)  
052a 32 70 fe			ld (debug_mark+2),a  
052d 18 03			jr .pastdmark  
052f ..			.dmark: db "SB3"  
0532 f1			.pastdmark: pop af  
0533			endm  
# End of macro DMARK
0533			;		push af 
0533			;		ld a, 'F' 
0533			;		ld (debug_mark),a 
0533			;		pop af 
0533					CALLMONITOR 
0533 cd 73 18			call break_point_state  
0536				endm  
# End of macro CALLMONITOR
0536				endif 
0536 cd 39 04			call storage_write_block 
0539				if DEBUG_STORESE 
0539					DMARK "SB4" 
0539 f5				push af  
053a 3a 4e 05			ld a, (.dmark)  
053d 32 6e fe			ld (debug_mark),a  
0540 3a 4f 05			ld a, (.dmark+1)  
0543 32 6f fe			ld (debug_mark+1),a  
0546 3a 50 05			ld a, (.dmark+2)  
0549 32 70 fe			ld (debug_mark+2),a  
054c 18 03			jr .pastdmark  
054e ..			.dmark: db "SB4"  
0551 f1			.pastdmark: pop af  
0552			endm  
# End of macro DMARK
0552			;		push af 
0552			;		ld a, '>' 
0552			;		ld (debug_mark),a 
0552			;		pop af 
0552					CALLMONITOR 
0552 cd 73 18			call break_point_state  
0555				endm  
# End of macro CALLMONITOR
0555				endif 
0555			 
0555 00				nop 
0556 00				nop 
0557 00				nop 
0558			 
0558				; now set 0 in every page to mark as a free block 
0558			 
0558 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
055a 21 40 00			ld hl, STORE_BLOCK_PHY 
055d			 
055d 3e 00		.setmark1:   	ld a,0 
055f e5					push hl 
0560 c5					push bc 
0561 cd d9 01				call se_writebyte 
0564 3e 0a			ld a, 10 
0566 cd fa 0b			call aDelayInMS 
0569 23				inc hl 
056a cd d9 01				call se_writebyte 
056d 3e 0a			ld a, 10 
056f cd fa 0b			call aDelayInMS 
0572 2b				dec hl 
0573 c1					pop bc 
0574 e1					pop hl 
0575 3e 40				ld a, STORE_BLOCK_PHY 
0577 cd cc 0e				call addatohl 
057a 10 e1				djnz .setmark1 
057c			 
057c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
057e 3e 00		.setmark2:   	ld a,0 
0580 e5					push hl 
0581 c5					push bc 
0582 cd d9 01				call se_writebyte 
0585 3e 0a			ld a, 10 
0587 cd fa 0b			call aDelayInMS 
058a 23				inc hl 
058b cd d9 01				call se_writebyte 
058e 3e 0a			ld a, 10 
0590 cd fa 0b			call aDelayInMS 
0593 2b				dec hl 
0594 c1					pop bc 
0595 e1					pop hl 
0596 3e 40				ld a, STORE_BLOCK_PHY 
0598 cd cc 0e				call addatohl 
059b 10 e1				djnz .setmark2 
059d			 
059d					 
059d			 
059d			 
059d c9				ret 
059e			 
059e			 
059e			 
059e			 
059e .. 00		.defaultbanklabl:   db "BankLabel_",0 
05a9			 
05a9			 
05a9			 
05a9			; Label Bank 
05a9			; ---------- 
05a9			; 
05a9			; With current bank 
05a9			; Read block 0 
05a9			; Set label 
05a9			; Write block 0 
05a9			 
05a9			; label str pointer in hl 
05a9			 
05a9			storage_label:     
05a9			 
05a9				if DEBUG_STORESE 
05a9					DMARK "LBL" 
05a9 f5				push af  
05aa 3a be 05			ld a, (.dmark)  
05ad 32 6e fe			ld (debug_mark),a  
05b0 3a bf 05			ld a, (.dmark+1)  
05b3 32 6f fe			ld (debug_mark+1),a  
05b6 3a c0 05			ld a, (.dmark+2)  
05b9 32 70 fe			ld (debug_mark+2),a  
05bc 18 03			jr .pastdmark  
05be ..			.dmark: db "LBL"  
05c1 f1			.pastdmark: pop af  
05c2			endm  
# End of macro DMARK
05c2					CALLMONITOR 
05c2 cd 73 18			call break_point_state  
05c5				endm  
# End of macro CALLMONITOR
05c5				endif 
05c5			 
05c5 e5				push hl 
05c6			 
05c6 cd 85 04			call storage_get_block_0 
05c9			 
05c9				; set default label 
05c9			 
05c9 e1				pop hl 
05ca			 
05ca 11 84 fa		 	ld de, store_page+3 
05cd 01 0f 00			ld bc, 15 
05d0				if DEBUG_STORESE 
05d0					DMARK "LB3" 
05d0 f5				push af  
05d1 3a e5 05			ld a, (.dmark)  
05d4 32 6e fe			ld (debug_mark),a  
05d7 3a e6 05			ld a, (.dmark+1)  
05da 32 6f fe			ld (debug_mark+1),a  
05dd 3a e7 05			ld a, (.dmark+2)  
05e0 32 70 fe			ld (debug_mark+2),a  
05e3 18 03			jr .pastdmark  
05e5 ..			.dmark: db "LB3"  
05e8 f1			.pastdmark: pop af  
05e9			endm  
# End of macro DMARK
05e9					CALLMONITOR 
05e9 cd 73 18			call break_point_state  
05ec				endm  
# End of macro CALLMONITOR
05ec				endif 
05ec ed b0			ldir 
05ee				; save default page 0 
05ee			 
05ee 21 00 00			ld hl, 0 
05f1 11 81 fa			ld de, store_page 
05f4				if DEBUG_STORESE 
05f4					DMARK "LBW" 
05f4 f5				push af  
05f5 3a 09 06			ld a, (.dmark)  
05f8 32 6e fe			ld (debug_mark),a  
05fb 3a 0a 06			ld a, (.dmark+1)  
05fe 32 6f fe			ld (debug_mark+1),a  
0601 3a 0b 06			ld a, (.dmark+2)  
0604 32 70 fe			ld (debug_mark+2),a  
0607 18 03			jr .pastdmark  
0609 ..			.dmark: db "LBW"  
060c f1			.pastdmark: pop af  
060d			endm  
# End of macro DMARK
060d					CALLMONITOR 
060d cd 73 18			call break_point_state  
0610				endm  
# End of macro CALLMONITOR
0610				endif 
0610 cd 39 04			call storage_write_block 
0613			 
0613 c9				ret 
0614			 
0614			 
0614			 
0614			; Read Block 0 - Config 
0614			; --------------------- 
0614			; 
0614			; With current bank 
0614			; Call presence test 
0614			;    If not present format/init bank  
0614			; Read block 0  
0614			;  
0614			 
0614			 
0614			; Dir 
0614			; --- 
0614			; 
0614			; With current bank 
0614			; Load Block 0 Config 
0614			; Get max file id number 
0614			; For each logical block 
0614			;    Read block read byte 2 
0614			;      if first block of file 
0614			;         Display file name 
0614			;         Display type flags for file 
0614			;        
0614			 
0614			; moving to words as this requires stack control 
0614			 
0614			 
0614			; Delete File 
0614			; ----------- 
0614			; 
0614			; With current bank 
0614			; 
0614			; Load Block 0 Config 
0614			; Get max file id number 
0614			; For each logical block 
0614			;    Read block file id 
0614			;      If first block of file and dont have file id 
0614			;         if file to delete 
0614			;         Save file id 
0614			;         Null file id 
0614			;         Write this block back 
0614			;      If file id is one saved 
0614			;         Null file id 
0614			;         Write this block back 
0614			 
0614			 
0614			.se_done: 
0614 e1				pop hl 
0615 c9				ret 
0616			 
0616			storage_erase: 
0616			 
0616				; hl contains the file id 
0616			 
0616 5d				ld e, l 
0617 16 00			ld d, 0 
0619 21 40 00			ld hl, STORE_BLOCK_PHY 
061c					if DEBUG_FORTH_WORDS 
061c						DMARK "ERA" 
061c f5				push af  
061d 3a 31 06			ld a, (.dmark)  
0620 32 6e fe			ld (debug_mark),a  
0623 3a 32 06			ld a, (.dmark+1)  
0626 32 6f fe			ld (debug_mark+1),a  
0629 3a 33 06			ld a, (.dmark+2)  
062c 32 70 fe			ld (debug_mark+2),a  
062f 18 03			jr .pastdmark  
0631 ..			.dmark: db "ERA"  
0634 f1			.pastdmark: pop af  
0635			endm  
# End of macro DMARK
0635						CALLMONITOR 
0635 cd 73 18			call break_point_state  
0638				endm  
# End of macro CALLMONITOR
0638					endif 
0638 cd 07 07			call storage_findnextid 
063b cd f5 0e			call ishlzero 
063e c8				ret z 
063f			 
063f e5				push hl 
0640			 
0640				; TODO check file not found 
0640			 
0640 11 81 fa			ld de, store_page 
0643 cd d4 03			call storage_read_block 
0646			 
0646 cd f5 0e			call ishlzero 
0649 ca 14 06			jp z,.se_done 
064c			 
064c					if DEBUG_FORTH_WORDS 
064c						DMARK "ER1" 
064c f5				push af  
064d 3a 61 06			ld a, (.dmark)  
0650 32 6e fe			ld (debug_mark),a  
0653 3a 62 06			ld a, (.dmark+1)  
0656 32 6f fe			ld (debug_mark+1),a  
0659 3a 63 06			ld a, (.dmark+2)  
065c 32 70 fe			ld (debug_mark+2),a  
065f 18 03			jr .pastdmark  
0661 ..			.dmark: db "ER1"  
0664 f1			.pastdmark: pop af  
0665			endm  
# End of macro DMARK
0665						CALLMONITOR 
0665 cd 73 18			call break_point_state  
0668				endm  
# End of macro CALLMONITOR
0668					endif 
0668 3a 81 fa			ld a, (store_page)	; get file id 
066b 32 75 fa			ld (store_tmpid), a 
066e			 
066e 3a 83 fa			ld a, (store_page+2)    ; get count of extends 
0671 32 74 fa			ld (store_tmpext), a 
0674			 
0674				; wipe file header 
0674			 
0674 e1				pop hl 
0675 3e 00			ld a, 0 
0677 32 81 fa			ld (store_page), a 
067a 32 82 fa			ld (store_page+1),a 
067d 11 81 fa			ld de, store_page 
0680					if DEBUG_FORTH_WORDS 
0680						DMARK "ER2" 
0680 f5				push af  
0681 3a 95 06			ld a, (.dmark)  
0684 32 6e fe			ld (debug_mark),a  
0687 3a 96 06			ld a, (.dmark+1)  
068a 32 6f fe			ld (debug_mark+1),a  
068d 3a 97 06			ld a, (.dmark+2)  
0690 32 70 fe			ld (debug_mark+2),a  
0693 18 03			jr .pastdmark  
0695 ..			.dmark: db "ER2"  
0698 f1			.pastdmark: pop af  
0699			endm  
# End of macro DMARK
0699						CALLMONITOR 
0699 cd 73 18			call break_point_state  
069c				endm  
# End of macro CALLMONITOR
069c					endif 
069c cd 39 04			call storage_write_block 
069f			 
069f			 
069f				; wipe file extents 
069f			 
069f 3a 74 fa			ld a, (store_tmpext) 
06a2 47				ld b, a 
06a3			 
06a3			.eraext:	  
06a3 c5				push bc 
06a4			 
06a4 21 40 00			ld hl, STORE_BLOCK_PHY 
06a7 3a 75 fa			ld a,(store_tmpid) 
06aa 5f				ld e, a 
06ab 50				ld d, b	 
06ac					if DEBUG_FORTH_WORDS 
06ac						DMARK "ER3" 
06ac f5				push af  
06ad 3a c1 06			ld a, (.dmark)  
06b0 32 6e fe			ld (debug_mark),a  
06b3 3a c2 06			ld a, (.dmark+1)  
06b6 32 6f fe			ld (debug_mark+1),a  
06b9 3a c3 06			ld a, (.dmark+2)  
06bc 32 70 fe			ld (debug_mark+2),a  
06bf 18 03			jr .pastdmark  
06c1 ..			.dmark: db "ER3"  
06c4 f1			.pastdmark: pop af  
06c5			endm  
# End of macro DMARK
06c5						CALLMONITOR 
06c5 cd 73 18			call break_point_state  
06c8				endm  
# End of macro CALLMONITOR
06c8					endif 
06c8 cd 07 07			call storage_findnextid 
06cb cd f5 0e			call ishlzero 
06ce ca 14 06			jp z,.se_done 
06d1			 
06d1 e5				push hl 
06d2 11 81 fa			ld de, store_page 
06d5 cd d4 03			call storage_read_block 
06d8			 
06d8				; free block	 
06d8			 
06d8 3e 00			ld a, 0 
06da 32 81 fa			ld (store_page), a 
06dd 32 82 fa			ld (store_page+1),a 
06e0 11 81 fa			ld de, store_page 
06e3 e1				pop hl 
06e4					if DEBUG_FORTH_WORDS 
06e4						DMARK "ER4" 
06e4 f5				push af  
06e5 3a f9 06			ld a, (.dmark)  
06e8 32 6e fe			ld (debug_mark),a  
06eb 3a fa 06			ld a, (.dmark+1)  
06ee 32 6f fe			ld (debug_mark+1),a  
06f1 3a fb 06			ld a, (.dmark+2)  
06f4 32 70 fe			ld (debug_mark+2),a  
06f7 18 03			jr .pastdmark  
06f9 ..			.dmark: db "ER4"  
06fc f1			.pastdmark: pop af  
06fd			endm  
# End of macro DMARK
06fd						CALLMONITOR 
06fd cd 73 18			call break_point_state  
0700				endm  
# End of macro CALLMONITOR
0700					endif 
0700 cd 39 04			call storage_write_block 
0703			 
0703 c1				pop bc 
0704 10 9d			djnz .eraext 
0706			 
0706 c9				ret 
0707			 
0707			 
0707			; Find Free Block 
0707			; --------------- 
0707			; 
0707			; With current bank 
0707			;  
0707			; From given starting logical block 
0707			;    Read block  
0707			;    If no file id 
0707			;         Return block id 
0707			 
0707			 
0707			; hl starting page number 
0707			; hl contains free page number or zero if no pages free 
0707			; e contains the file id to locate 
0707			; d contains the block number 
0707			 
0707			; TODO change to find file id and use zero for free block 
0707			 
0707			storage_findnextid: 
0707			 
0707				; now locate first 0 page to mark as a free block 
0707			 
0707 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0709			;	ld hl, STORE_BLOCK_PHY 
0709			 
0709					if DEBUG_FORTH_WORDS 
0709					DMARK "FNI" 
0709 f5				push af  
070a 3a 1e 07			ld a, (.dmark)  
070d 32 6e fe			ld (debug_mark),a  
0710 3a 1f 07			ld a, (.dmark+1)  
0713 32 6f fe			ld (debug_mark+1),a  
0716 3a 20 07			ld a, (.dmark+2)  
0719 32 70 fe			ld (debug_mark+2),a  
071c 18 03			jr .pastdmark  
071e ..			.dmark: db "FNI"  
0721 f1			.pastdmark: pop af  
0722			endm  
# End of macro DMARK
0722						CALLMONITOR 
0722 cd 73 18			call break_point_state  
0725				endm  
# End of macro CALLMONITOR
0725					endif 
0725			.ff1:   	 
0725 e5					push hl 
0726 c5					push bc 
0727 d5					push de 
0728 cd 7b 02				call se_readbyte 
072b 5f					ld e,a 
072c 23					inc hl 
072d cd 7b 02				call se_readbyte 
0730 57					ld d, a 
0731 e1					pop hl 
0732 e5					push hl 
0733 cd ea 0e				call cmp16 
0736 28 49				jr z, .fffound 
0738			 
0738 d1					pop de 
0739 c1					pop bc 
073a e1					pop hl 
073b			 
073b					; is found? 
073b					;cp e 
073b					;ret z 
073b			 
073b 3e 40				ld a, STORE_BLOCK_PHY 
073d cd cc 0e				call addatohl 
0740 10 e3				djnz .ff1 
0742			 
0742 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0744			.ff2:   	 
0744			 
0744 e5					push hl 
0745 c5					push bc 
0746 d5					push de 
0747 cd 7b 02				call se_readbyte 
074a 5f					ld e,a 
074b 23					inc hl 
074c cd 7b 02				call se_readbyte 
074f 57					ld d, a 
0750			 
0750 e1					pop hl 
0751 e5					push hl 
0752 cd ea 0e				call cmp16 
0755 28 2a				jr z, .fffound 
0757			 
0757 d1					pop de 
0758 c1					pop bc 
0759 e1					pop hl 
075a					; is found? 
075a					;cp e 
075a					;ret z 
075a			 
075a 3e 40				ld a, STORE_BLOCK_PHY 
075c cd cc 0e				call addatohl 
075f 10 e3				djnz .ff2 
0761			 
0761			 
0761					if DEBUG_FORTH_WORDS 
0761					DMARK "FN-" 
0761 f5				push af  
0762 3a 76 07			ld a, (.dmark)  
0765 32 6e fe			ld (debug_mark),a  
0768 3a 77 07			ld a, (.dmark+1)  
076b 32 6f fe			ld (debug_mark+1),a  
076e 3a 78 07			ld a, (.dmark+2)  
0771 32 70 fe			ld (debug_mark+2),a  
0774 18 03			jr .pastdmark  
0776 ..			.dmark: db "FN-"  
0779 f1			.pastdmark: pop af  
077a			endm  
# End of macro DMARK
077a					;	push af 
077a					;	ld a, 'n' 
077a					;	ld (debug_mark),a 
077a					;	pop af 
077a						CALLMONITOR 
077a cd 73 18			call break_point_state  
077d				endm  
# End of macro CALLMONITOR
077d					endif 
077d				; no free marks! 
077d 21 00 00				ld hl, 0 
0780 c9				ret 
0781			.fffound: 
0781				 
0781			 
0781 d1					pop de 
0782 c1					pop bc 
0783 e1					pop hl 
0784					if DEBUG_FORTH_WORDS 
0784					DMARK "FNF" 
0784 f5				push af  
0785 3a 99 07			ld a, (.dmark)  
0788 32 6e fe			ld (debug_mark),a  
078b 3a 9a 07			ld a, (.dmark+1)  
078e 32 6f fe			ld (debug_mark+1),a  
0791 3a 9b 07			ld a, (.dmark+2)  
0794 32 70 fe			ld (debug_mark+2),a  
0797 18 03			jr .pastdmark  
0799 ..			.dmark: db "FNF"  
079c f1			.pastdmark: pop af  
079d			endm  
# End of macro DMARK
079d					;	push af 
079d					;	ld a, 'n' 
079d					;	ld (debug_mark),a 
079d					;	pop af 
079d						CALLMONITOR 
079d cd 73 18			call break_point_state  
07a0				endm  
# End of macro CALLMONITOR
07a0					endif 
07a0 c9				ret 
07a1			 
07a1			 
07a1			 
07a1			; Free Space 
07a1			; ---------- 
07a1			; 
07a1			; With current bank 
07a1			; 
07a1			; Set block count to zero 
07a1			; Starting with first logical block 
07a1			;      Find free block  
07a1			;      If block id given, increment block count 
07a1			; 
07a1			;  
07a1			 
07a1			 
07a1			; hl contains count of free blocks 
07a1			 
07a1			storage_freeblocks: 
07a1			 
07a1				; now locate first 0 page to mark as a free block 
07a1			 
07a1 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07a3 21 40 00			ld hl, STORE_BLOCK_PHY 
07a6 11 00 00			ld de, 0 
07a9			 
07a9			.fb1:   	 
07a9 e5					push hl 
07aa c5					push bc 
07ab d5					push de 
07ac cd 7b 02				call se_readbyte 
07af d1					pop de 
07b0 c1					pop bc 
07b1 e1					pop hl 
07b2			 
07b2					; is free? 
07b2 fe 00				cp 0 
07b4 20 01				jr nz, .ff1cont 
07b6 13					inc de 
07b7			 
07b7			.ff1cont: 
07b7			 
07b7			 
07b7 3e 40				ld a, STORE_BLOCK_PHY 
07b9 cd cc 0e				call addatohl 
07bc 10 eb				djnz .fb1 
07be			 
07be 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07c0			.fb2:   	 
07c0 e5					push hl 
07c1 c5					push bc 
07c2 d5					push de 
07c3 cd 7b 02				call se_readbyte 
07c6 d1					pop de 
07c7 c1					pop bc 
07c8 e1					pop hl 
07c9			 
07c9					; is free? 
07c9 fe 00				cp 0 
07cb 20 01				jr nz, .ff2cont 
07cd 13					inc de 
07ce			 
07ce			.ff2cont: 
07ce			 
07ce 3e 40				ld a, STORE_BLOCK_PHY 
07d0 cd cc 0e				call addatohl 
07d3 10 eb				djnz .fb2 
07d5			 
07d5 eb				ex de, hl 
07d6 c9				ret 
07d7			 
07d7			; Get File ID 
07d7			; ----------- 
07d7			; 
07d7			; With current bank 
07d7			;  
07d7			; Load Block 0 Config 
07d7			; Get max file id number 
07d7			; For each logical block 
07d7			;    Read block file id 
07d7			;      If first block of file and dont have file id 
07d7			;         if file get id and exit 
07d7			 
07d7			 
07d7			 
07d7			 
07d7			; Create File 
07d7			; ----------- 
07d7			; 
07d7			; With current bank  
07d7			; Load Block 0 Config 
07d7			; Get max file id number 
07d7			; Increment file id number 
07d7			; Save Config 
07d7			; Find free block 
07d7			; Set buffer with file name and file id 
07d7			; Write buffer to free block  
07d7			 
07d7			 
07d7			; hl point to file name 
07d7			; hl returns file id 
07d7			 
07d7			; file format: 
07d7			; byte 0 - file id 
07d7			; byte 1 - extent number 
07d7			; byte 2-> data 
07d7			 
07d7			; format for extent number 0: 
07d7			; 
07d7			; byte 0 - file id 
07d7			; byte 1 - extent 0 
07d7			; byte 2 - extent count 
07d7			; byte 3 -> file name and meta data 
07d7			 
07d7			 
07d7			storage_create: 
07d7				if DEBUG_STORESE 
07d7					DMARK "SCR" 
07d7 f5				push af  
07d8 3a ec 07			ld a, (.dmark)  
07db 32 6e fe			ld (debug_mark),a  
07de 3a ed 07			ld a, (.dmark+1)  
07e1 32 6f fe			ld (debug_mark+1),a  
07e4 3a ee 07			ld a, (.dmark+2)  
07e7 32 70 fe			ld (debug_mark+2),a  
07ea 18 03			jr .pastdmark  
07ec ..			.dmark: db "SCR"  
07ef f1			.pastdmark: pop af  
07f0			endm  
# End of macro DMARK
07f0					CALLMONITOR 
07f0 cd 73 18			call break_point_state  
07f3				endm  
# End of macro CALLMONITOR
07f3				endif 
07f3			 
07f3 e5				push hl		; save file name pointer 
07f4			 
07f4 cd 85 04			call storage_get_block_0 
07f7			 
07f7 3a 81 fa			ld a,(store_page)	; get current file id 
07fa 3c				inc a 
07fb 32 81 fa			ld (store_page),a 
07fe				 
07fe 32 75 fa			ld (store_tmpid),a			; save id 
0801			 
0801 21 00 00			ld hl, 0 
0804 11 81 fa			ld de, store_page 
0807				if DEBUG_STORESE 
0807					DMARK "SCw" 
0807 f5				push af  
0808 3a 1c 08			ld a, (.dmark)  
080b 32 6e fe			ld (debug_mark),a  
080e 3a 1d 08			ld a, (.dmark+1)  
0811 32 6f fe			ld (debug_mark+1),a  
0814 3a 1e 08			ld a, (.dmark+2)  
0817 32 70 fe			ld (debug_mark+2),a  
081a 18 03			jr .pastdmark  
081c ..			.dmark: db "SCw"  
081f f1			.pastdmark: pop af  
0820			endm  
# End of macro DMARK
0820					CALLMONITOR 
0820 cd 73 18			call break_point_state  
0823				endm  
# End of macro CALLMONITOR
0823				endif 
0823 cd 39 04			call storage_write_block	 ; save update 
0826			 
0826				if DEBUG_STORESE 
0826 11 81 fa				ld de, store_page 
0829					DMARK "SCC" 
0829 f5				push af  
082a 3a 3e 08			ld a, (.dmark)  
082d 32 6e fe			ld (debug_mark),a  
0830 3a 3f 08			ld a, (.dmark+1)  
0833 32 6f fe			ld (debug_mark+1),a  
0836 3a 40 08			ld a, (.dmark+2)  
0839 32 70 fe			ld (debug_mark+2),a  
083c 18 03			jr .pastdmark  
083e ..			.dmark: db "SCC"  
0841 f1			.pastdmark: pop af  
0842			endm  
# End of macro DMARK
0842					CALLMONITOR 
0842 cd 73 18			call break_point_state  
0845				endm  
# End of macro CALLMONITOR
0845				endif 
0845				;  
0845				 
0845 21 40 00			ld hl, STORE_BLOCK_PHY 
0848 11 00 00			ld de, 0 
084b cd 07 07			call storage_findnextid 
084e			 
084e 22 6e fa			ld (store_tmppageid), hl    ; save page to use  
0851			 
0851				; TODO detect 0 = no spare blocks 
0851			 
0851				; hl now contains the free page to use for the file header page 
0851			 
0851				if DEBUG_STORESE 
0851				DMARK "SCF" 
0851 f5				push af  
0852 3a 66 08			ld a, (.dmark)  
0855 32 6e fe			ld (debug_mark),a  
0858 3a 67 08			ld a, (.dmark+1)  
085b 32 6f fe			ld (debug_mark+1),a  
085e 3a 68 08			ld a, (.dmark+2)  
0861 32 70 fe			ld (debug_mark+2),a  
0864 18 03			jr .pastdmark  
0866 ..			.dmark: db "SCF"  
0869 f1			.pastdmark: pop af  
086a			endm  
# End of macro DMARK
086a					CALLMONITOR 
086a cd 73 18			call break_point_state  
086d				endm  
# End of macro CALLMONITOR
086d				endif 
086d			 
086d 22 6e fa			ld (store_tmppageid), hl 
0870				 
0870 3a 75 fa			ld a,(store_tmpid)    ; get file id 
0873			;	ld a, (store_filecache)			; save to cache 
0873			 
0873 32 81 fa			ld (store_page),a    ; set page id 
0876 3e 00			ld a, 0			 ; extent 0 is file header 
0878 32 82 fa			ld (store_page+1), a   ; set file extent 
087b			 
087b 32 83 fa			ld (store_page+2), a   ; extent count for the file 
087e			 
087e			;	inc hl 		; init block 0 of file 
087e			;	inc hl   		; skip file and extent id 
087e			 ;       ld a, 0 
087e			;	ld (hl),a 
087e			;	ld a, (store_filecache+1)  	; save to cache 
087e			 
087e			;	inc hl    ; file name 
087e				 
087e				 
087e 11 84 fa			ld de, store_page+3    ; get buffer for term string to use as file name 
0881				if DEBUG_STORESE 
0881					DMARK "SCc" 
0881 f5				push af  
0882 3a 96 08			ld a, (.dmark)  
0885 32 6e fe			ld (debug_mark),a  
0888 3a 97 08			ld a, (.dmark+1)  
088b 32 6f fe			ld (debug_mark+1),a  
088e 3a 98 08			ld a, (.dmark+2)  
0891 32 70 fe			ld (debug_mark+2),a  
0894 18 03			jr .pastdmark  
0896 ..			.dmark: db "SCc"  
0899 f1			.pastdmark: pop af  
089a			endm  
# End of macro DMARK
089a					CALLMONITOR 
089a cd 73 18			call break_point_state  
089d				endm  
# End of macro CALLMONITOR
089d				endif 
089d e1				pop hl    ; get zero term string 
089e e5				push hl 
089f 3e 00			ld a, 0 
08a1 cd 35 13			call strlent 
08a4 23				inc hl   ; cover zero term 
08a5 06 00			ld b,0 
08a7 4d				ld c,l 
08a8 e1				pop hl 
08a9				;ex de, hl 
08a9				if DEBUG_STORESE 
08a9					DMARK "SCa" 
08a9 f5				push af  
08aa 3a be 08			ld a, (.dmark)  
08ad 32 6e fe			ld (debug_mark),a  
08b0 3a bf 08			ld a, (.dmark+1)  
08b3 32 6f fe			ld (debug_mark+1),a  
08b6 3a c0 08			ld a, (.dmark+2)  
08b9 32 70 fe			ld (debug_mark+2),a  
08bc 18 03			jr .pastdmark  
08be ..			.dmark: db "SCa"  
08c1 f1			.pastdmark: pop af  
08c2			endm  
# End of macro DMARK
08c2					;push af 
08c2					;ld a, 'a' 
08c2					;ld (debug_mark),a 
08c2					;pop af 
08c2					CALLMONITOR 
08c2 cd 73 18			call break_point_state  
08c5				endm  
# End of macro CALLMONITOR
08c5				endif 
08c5 ed b0			ldir    ; copy zero term string 
08c7				if DEBUG_STORESE 
08c7					DMARK "SCA" 
08c7 f5				push af  
08c8 3a dc 08			ld a, (.dmark)  
08cb 32 6e fe			ld (debug_mark),a  
08ce 3a dd 08			ld a, (.dmark+1)  
08d1 32 6f fe			ld (debug_mark+1),a  
08d4 3a de 08			ld a, (.dmark+2)  
08d7 32 70 fe			ld (debug_mark+2),a  
08da 18 03			jr .pastdmark  
08dc ..			.dmark: db "SCA"  
08df f1			.pastdmark: pop af  
08e0			endm  
# End of macro DMARK
08e0					CALLMONITOR 
08e0 cd 73 18			call break_point_state  
08e3				endm  
# End of macro CALLMONITOR
08e3				endif 
08e3			 
08e3				; write file header page 
08e3			 
08e3 2a 6e fa			ld hl,(store_tmppageid) 
08e6 11 81 fa			ld de, store_page 
08e9				if DEBUG_STORESE 
08e9					DMARK "SCb" 
08e9 f5				push af  
08ea 3a fe 08			ld a, (.dmark)  
08ed 32 6e fe			ld (debug_mark),a  
08f0 3a ff 08			ld a, (.dmark+1)  
08f3 32 6f fe			ld (debug_mark+1),a  
08f6 3a 00 09			ld a, (.dmark+2)  
08f9 32 70 fe			ld (debug_mark+2),a  
08fc 18 03			jr .pastdmark  
08fe ..			.dmark: db "SCb"  
0901 f1			.pastdmark: pop af  
0902			endm  
# End of macro DMARK
0902					;push af 
0902					;ld a, 'b' 
0902					;ld (debug_mark),a 
0902					;pop af 
0902					CALLMONITOR 
0902 cd 73 18			call break_point_state  
0905				endm  
# End of macro CALLMONITOR
0905				endif 
0905 cd 39 04			call storage_write_block 
0908			 
0908 3a 75 fa			ld a, (store_tmpid) 
090b 6f				ld l, a 
090c 26 00			ld h,0 
090e				if DEBUG_STORESE 
090e					DMARK "SCz" 
090e f5				push af  
090f 3a 23 09			ld a, (.dmark)  
0912 32 6e fe			ld (debug_mark),a  
0915 3a 24 09			ld a, (.dmark+1)  
0918 32 6f fe			ld (debug_mark+1),a  
091b 3a 25 09			ld a, (.dmark+2)  
091e 32 70 fe			ld (debug_mark+2),a  
0921 18 03			jr .pastdmark  
0923 ..			.dmark: db "SCz"  
0926 f1			.pastdmark: pop af  
0927			endm  
# End of macro DMARK
0927					CALLMONITOR 
0927 cd 73 18			call break_point_state  
092a				endm  
# End of macro CALLMONITOR
092a				endif 
092a c9				ret 
092b				 
092b			 
092b			 
092b			; 
092b			; Read File 
092b			; 
092b			; h - file id to locate 
092b			; l - extent to locate 
092b			; de - pointer to string to read into 
092b			; 
092b			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
092b			 
092b			.sr_fail: 
092b d1				pop de 
092c c9				ret 
092d			 
092d			storage_read: 
092d			 
092d			 
092d			 
092d d5				push de 
092e			 
092e			; TODO BUG the above push is it popped before the RET Z? 
092e			 
092e			; TODO how to handle multiple part blocks 
092e			 
092e				; locate file extent to read 
092e			 
092e 5c				ld e, h 
092f 55				ld d, l 
0930			 
0930			.srext: 
0930 22 7f fa			ld (store_readptr), hl     ; save the current extent to load 
0933 ed 53 7d fa		ld (store_readbuf), de     ; save the current buffer to load in to 
0937			 
0937 21 40 00			ld hl, STORE_BLOCK_PHY 
093a				if DEBUG_STORESE 
093a					DMARK "sre" 
093a f5				push af  
093b 3a 4f 09			ld a, (.dmark)  
093e 32 6e fe			ld (debug_mark),a  
0941 3a 50 09			ld a, (.dmark+1)  
0944 32 6f fe			ld (debug_mark+1),a  
0947 3a 51 09			ld a, (.dmark+2)  
094a 32 70 fe			ld (debug_mark+2),a  
094d 18 03			jr .pastdmark  
094f ..			.dmark: db "sre"  
0952 f1			.pastdmark: pop af  
0953			endm  
# End of macro DMARK
0953					CALLMONITOR 
0953 cd 73 18			call break_point_state  
0956				endm  
# End of macro CALLMONITOR
0956				endif 
0956 cd 07 07			call storage_findnextid 
0959			 
0959				if DEBUG_STORESE 
0959					DMARK "srf" 
0959 f5				push af  
095a 3a 6e 09			ld a, (.dmark)  
095d 32 6e fe			ld (debug_mark),a  
0960 3a 6f 09			ld a, (.dmark+1)  
0963 32 6f fe			ld (debug_mark+1),a  
0966 3a 70 09			ld a, (.dmark+2)  
0969 32 70 fe			ld (debug_mark+2),a  
096c 18 03			jr .pastdmark  
096e ..			.dmark: db "srf"  
0971 f1			.pastdmark: pop af  
0972			endm  
# End of macro DMARK
0972					CALLMONITOR 
0972 cd 73 18			call break_point_state  
0975				endm  
# End of macro CALLMONITOR
0975				endif 
0975 cd f5 0e			call ishlzero 
0978			;	ld a, l 
0978			;	add h 
0978			;	cp 0 
0978 28 b1			jr z,.sr_fail			; block not found so EOF 
097a			 
097a				; hl contains page number to load 
097a d1				pop de   ; get storage 
097b d5				push de 
097c				if DEBUG_STORESE 
097c					DMARK "srg" 
097c f5				push af  
097d 3a 91 09			ld a, (.dmark)  
0980 32 6e fe			ld (debug_mark),a  
0983 3a 92 09			ld a, (.dmark+1)  
0986 32 6f fe			ld (debug_mark+1),a  
0989 3a 93 09			ld a, (.dmark+2)  
098c 32 70 fe			ld (debug_mark+2),a  
098f 18 03			jr .pastdmark  
0991 ..			.dmark: db "srg"  
0994 f1			.pastdmark: pop af  
0995			endm  
# End of macro DMARK
0995					CALLMONITOR 
0995 cd 73 18			call break_point_state  
0998				endm  
# End of macro CALLMONITOR
0998				endif 
0998 cd d4 03			call storage_read_block 
099b			 
099b			 
099b				; only short reads enabled 
099b			 
099b 3a 7c fa			ld a, (store_longread) 
099e fe 00			cp 0 
09a0 ca 6a 0a			jp z, .readdone 
09a3			 
09a3			; TODO if block has no zeros then need to read next block  
09a3			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
09a3			; check last byte of physical block. 
09a3			; if not zero then the next block needs to be loaded 
09a3			 
09a3			 
09a3 2a 7d fa			ld hl, (store_readbuf)     ; current buffer to load in to 
09a6			 
09a6 3e 3f			ld a, STORE_BLOCK_PHY-1 
09a8 cd cc 0e			call addatohl 
09ab				;dec hl 
09ab 7e				ld a,(hl) 
09ac				if DEBUG_STORESE 
09ac					DMARK "sr?" 
09ac f5				push af  
09ad 3a c1 09			ld a, (.dmark)  
09b0 32 6e fe			ld (debug_mark),a  
09b3 3a c2 09			ld a, (.dmark+1)  
09b6 32 6f fe			ld (debug_mark+1),a  
09b9 3a c3 09			ld a, (.dmark+2)  
09bc 32 70 fe			ld (debug_mark+2),a  
09bf 18 03			jr .pastdmark  
09c1 ..			.dmark: db "sr?"  
09c4 f1			.pastdmark: pop af  
09c5			endm  
# End of macro DMARK
09c5					CALLMONITOR 
09c5 cd 73 18			call break_point_state  
09c8				endm  
# End of macro CALLMONITOR
09c8				endif 
09c8 fe 00			cp 0 
09ca ca 6a 0a			jp z, .readdone 
09cd			 
09cd				; last byte is not zero so there is more in the next extent. Load it on the end.	 
09cd			 
09cd 23				inc hl 
09ce			 
09ce 22 7d fa			ld (store_readbuf), hl     ; save the current buffer to load in to 
09d1			 
09d1 ed 5b 7f fa		ld de, (store_readptr)     ; save the current extent to load 
09d5			 
09d5 eb				ex de, hl 
09d6			 
09d6				; next ext 
09d6			 
09d6 23				inc hl 
09d7 22 7f fa			ld  (store_readptr), hl     ; save the current extent to load 
09da			 
09da				if DEBUG_STORESE 
09da					DMARK "sF2" 
09da f5				push af  
09db 3a ef 09			ld a, (.dmark)  
09de 32 6e fe			ld (debug_mark),a  
09e1 3a f0 09			ld a, (.dmark+1)  
09e4 32 6f fe			ld (debug_mark+1),a  
09e7 3a f1 09			ld a, (.dmark+2)  
09ea 32 70 fe			ld (debug_mark+2),a  
09ed 18 03			jr .pastdmark  
09ef ..			.dmark: db "sF2"  
09f2 f1			.pastdmark: pop af  
09f3			endm  
# End of macro DMARK
09f3					CALLMONITOR 
09f3 cd 73 18			call break_point_state  
09f6				endm  
# End of macro CALLMONITOR
09f6				endif 
09f6			 
09f6				; get and load block 
09f6			 
09f6 cd 07 07			call storage_findnextid 
09f9			 
09f9				if DEBUG_STORESE 
09f9					DMARK "sf2" 
09f9 f5				push af  
09fa 3a 0e 0a			ld a, (.dmark)  
09fd 32 6e fe			ld (debug_mark),a  
0a00 3a 0f 0a			ld a, (.dmark+1)  
0a03 32 6f fe			ld (debug_mark+1),a  
0a06 3a 10 0a			ld a, (.dmark+2)  
0a09 32 70 fe			ld (debug_mark+2),a  
0a0c 18 03			jr .pastdmark  
0a0e ..			.dmark: db "sf2"  
0a11 f1			.pastdmark: pop af  
0a12			endm  
# End of macro DMARK
0a12					CALLMONITOR 
0a12 cd 73 18			call break_point_state  
0a15				endm  
# End of macro CALLMONITOR
0a15				endif 
0a15 cd f5 0e			call ishlzero 
0a18			;	ld a, l 
0a18			;	add h 
0a18			;	cp 0 
0a18 ca 2b 09			jp z,.sr_fail			; block not found so EOF 
0a1b				 
0a1b cd d4 03			call storage_read_block 
0a1e			 
0a1e				; on a continuation block, we now have the file id and ext in the middle of the block 
0a1e				; we need to pull everything back  
0a1e			 
0a1e ed 5b 7d fa		ld de, (store_readbuf)     ; current buffer to nudge into 
0a22 2a 7d fa			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0a25 23				inc hl 
0a26 23				inc hl     ; skip id and ext 
0a27 01 40 00			ld bc, STORE_BLOCK_PHY 
0a2a				if DEBUG_STORESE 
0a2a					DMARK "SR<" 
0a2a f5				push af  
0a2b 3a 3f 0a			ld a, (.dmark)  
0a2e 32 6e fe			ld (debug_mark),a  
0a31 3a 40 0a			ld a, (.dmark+1)  
0a34 32 6f fe			ld (debug_mark+1),a  
0a37 3a 41 0a			ld a, (.dmark+2)  
0a3a 32 70 fe			ld (debug_mark+2),a  
0a3d 18 03			jr .pastdmark  
0a3f ..			.dmark: db "SR<"  
0a42 f1			.pastdmark: pop af  
0a43			endm  
# End of macro DMARK
0a43					CALLMONITOR 
0a43 cd 73 18			call break_point_state  
0a46				endm  
# End of macro CALLMONITOR
0a46				endif 
0a46 ed b0			ldir     ; copy data 
0a48			 
0a48				; move the pointer back and pretend we have a full buffer for next recheck 
0a48			 
0a48 1b				dec de 
0a49 1b				dec de 
0a4a			 
0a4a			; TODO do pop below now short circuit loop????? 
0a4a c1				pop bc     ; get rid of spare de on stack 
0a4b				if DEBUG_STORESE 
0a4b					DMARK "SR>" 
0a4b f5				push af  
0a4c 3a 60 0a			ld a, (.dmark)  
0a4f 32 6e fe			ld (debug_mark),a  
0a52 3a 61 0a			ld a, (.dmark+1)  
0a55 32 6f fe			ld (debug_mark+1),a  
0a58 3a 62 0a			ld a, (.dmark+2)  
0a5b 32 70 fe			ld (debug_mark+2),a  
0a5e 18 03			jr .pastdmark  
0a60 ..			.dmark: db "SR>"  
0a63 f1			.pastdmark: pop af  
0a64			endm  
# End of macro DMARK
0a64					CALLMONITOR 
0a64 cd 73 18			call break_point_state  
0a67				endm  
# End of macro CALLMONITOR
0a67				endif 
0a67 c3 30 09			jp .srext 
0a6a			 
0a6a			 
0a6a			 
0a6a			 
0a6a			 
0a6a			.readdone:		 
0a6a e1				pop hl 		 ; return start of data to show as not EOF 
0a6b 23				inc hl   ; past file id 
0a6c 23				inc hl   ; past ext 
0a6d				if DEBUG_STORESE 
0a6d					DMARK "SRe" 
0a6d f5				push af  
0a6e 3a 82 0a			ld a, (.dmark)  
0a71 32 6e fe			ld (debug_mark),a  
0a74 3a 83 0a			ld a, (.dmark+1)  
0a77 32 6f fe			ld (debug_mark+1),a  
0a7a 3a 84 0a			ld a, (.dmark+2)  
0a7d 32 70 fe			ld (debug_mark+2),a  
0a80 18 03			jr .pastdmark  
0a82 ..			.dmark: db "SRe"  
0a85 f1			.pastdmark: pop af  
0a86			endm  
# End of macro DMARK
0a86					CALLMONITOR 
0a86 cd 73 18			call break_point_state  
0a89				endm  
# End of macro CALLMONITOR
0a89				endif 
0a89 c9					ret 
0a8a			 
0a8a			 
0a8a			 
0a8a			; 
0a8a			; Append File 
0a8a			; 
0a8a			; hl - file id to locate 
0a8a			; de - pointer to (multi block) string to write 
0a8a			 
0a8a			.sa_notfound: 
0a8a d1				pop de 
0a8b c9				ret 
0a8c			 
0a8c			 
0a8c			storage_append: 
0a8c				; hl -  file id to append to 
0a8c				; de - string to append 
0a8c			 
0a8c d5				push de 
0a8d				 
0a8d				if DEBUG_STORESE 
0a8d					DMARK "AP1" 
0a8d f5				push af  
0a8e 3a a2 0a			ld a, (.dmark)  
0a91 32 6e fe			ld (debug_mark),a  
0a94 3a a3 0a			ld a, (.dmark+1)  
0a97 32 6f fe			ld (debug_mark+1),a  
0a9a 3a a4 0a			ld a, (.dmark+2)  
0a9d 32 70 fe			ld (debug_mark+2),a  
0aa0 18 03			jr .pastdmark  
0aa2 ..			.dmark: db "AP1"  
0aa5 f1			.pastdmark: pop af  
0aa6			endm  
# End of macro DMARK
0aa6					CALLMONITOR 
0aa6 cd 73 18			call break_point_state  
0aa9				endm  
# End of macro CALLMONITOR
0aa9				endif 
0aa9			 
0aa9 7d				ld a, l 
0aaa 32 75 fa			ld (store_tmpid), a 
0aad			 
0aad				; get file header  
0aad			 
0aad 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0aaf 3a 75 fa			ld a, (store_tmpid) 
0ab2 5f				ld e, a 
0ab3			 
0ab3 21 40 00				ld hl, STORE_BLOCK_PHY 
0ab6 cd 07 07				call storage_findnextid 
0ab9			 
0ab9 cd f5 0e			call ishlzero 
0abc 28 cc			jr z, .sa_notfound 
0abe			 
0abe 22 6e fa			ld (store_tmppageid), hl 
0ac1			 
0ac1				; TODO handle file id not found 
0ac1			 
0ac1				if DEBUG_STORESE 
0ac1					DMARK "AP2" 
0ac1 f5				push af  
0ac2 3a d6 0a			ld a, (.dmark)  
0ac5 32 6e fe			ld (debug_mark),a  
0ac8 3a d7 0a			ld a, (.dmark+1)  
0acb 32 6f fe			ld (debug_mark+1),a  
0ace 3a d8 0a			ld a, (.dmark+2)  
0ad1 32 70 fe			ld (debug_mark+2),a  
0ad4 18 03			jr .pastdmark  
0ad6 ..			.dmark: db "AP2"  
0ad9 f1			.pastdmark: pop af  
0ada			endm  
# End of macro DMARK
0ada					CALLMONITOR 
0ada cd 73 18			call break_point_state  
0add				endm  
# End of macro CALLMONITOR
0add				endif 
0add			 
0add				; update file extent count 
0add			 
0add 11 81 fa			ld de, store_page 
0ae0			 
0ae0 cd d4 03			call storage_read_block 
0ae3			 
0ae3				if DEBUG_STORESE 
0ae3					DMARK "AP3" 
0ae3 f5				push af  
0ae4 3a f8 0a			ld a, (.dmark)  
0ae7 32 6e fe			ld (debug_mark),a  
0aea 3a f9 0a			ld a, (.dmark+1)  
0aed 32 6f fe			ld (debug_mark+1),a  
0af0 3a fa 0a			ld a, (.dmark+2)  
0af3 32 70 fe			ld (debug_mark+2),a  
0af6 18 03			jr .pastdmark  
0af8 ..			.dmark: db "AP3"  
0afb f1			.pastdmark: pop af  
0afc			endm  
# End of macro DMARK
0afc					CALLMONITOR 
0afc cd 73 18			call break_point_state  
0aff				endm  
# End of macro CALLMONITOR
0aff				endif 
0aff			;	ld (store_tmppageid), hl 
0aff			 
0aff 3a 83 fa			ld a, (store_page+2) 
0b02 3c				inc a 
0b03 32 83 fa			ld (store_page+2), a 
0b06 32 74 fa			ld (store_tmpext), a 
0b09				 
0b09				if DEBUG_STORESE 
0b09					DMARK "AP3" 
0b09 f5				push af  
0b0a 3a 1e 0b			ld a, (.dmark)  
0b0d 32 6e fe			ld (debug_mark),a  
0b10 3a 1f 0b			ld a, (.dmark+1)  
0b13 32 6f fe			ld (debug_mark+1),a  
0b16 3a 20 0b			ld a, (.dmark+2)  
0b19 32 70 fe			ld (debug_mark+2),a  
0b1c 18 03			jr .pastdmark  
0b1e ..			.dmark: db "AP3"  
0b21 f1			.pastdmark: pop af  
0b22			endm  
# End of macro DMARK
0b22					CALLMONITOR 
0b22 cd 73 18			call break_point_state  
0b25				endm  
# End of macro CALLMONITOR
0b25				endif 
0b25 2a 6e fa			ld hl, (store_tmppageid) 
0b28 11 81 fa			ld de, store_page 
0b2b cd 39 04			call storage_write_block 
0b2e			 
0b2e				; find free block 
0b2e			 
0b2e 11 00 00			ld de, 0			 ; file extent to locate 
0b31			 
0b31 21 40 00				ld hl, STORE_BLOCK_PHY 
0b34 cd 07 07				call storage_findnextid 
0b37 cd f5 0e			call ishlzero 
0b3a ca 8a 0a			jp z, .sa_notfound 
0b3d			 
0b3d					; TODO handle no space left 
0b3d					 
0b3d 22 6e fa				ld (store_tmppageid), hl 
0b40			 
0b40				if DEBUG_STORESE 
0b40					DMARK "AP4" 
0b40 f5				push af  
0b41 3a 55 0b			ld a, (.dmark)  
0b44 32 6e fe			ld (debug_mark),a  
0b47 3a 56 0b			ld a, (.dmark+1)  
0b4a 32 6f fe			ld (debug_mark+1),a  
0b4d 3a 57 0b			ld a, (.dmark+2)  
0b50 32 70 fe			ld (debug_mark+2),a  
0b53 18 03			jr .pastdmark  
0b55 ..			.dmark: db "AP4"  
0b58 f1			.pastdmark: pop af  
0b59			endm  
# End of macro DMARK
0b59					CALLMONITOR 
0b59 cd 73 18			call break_point_state  
0b5c				endm  
# End of macro CALLMONITOR
0b5c				endif 
0b5c					; init the buffer with zeros so we can id if the buffer is full or not 
0b5c			 
0b5c e5					push hl 
0b5d c5					push bc 
0b5e			 
0b5e 21 81 fa				ld hl, store_page 
0b61 06 40				ld b, STORE_BLOCK_PHY 
0b63 3e 00				ld a, 0 
0b65 77			.zeroblock:	ld (hl), a 
0b66 23					inc hl 
0b67 10 fc				djnz .zeroblock 
0b69			 
0b69 c1					pop bc 
0b6a e1					pop hl 
0b6b			 
0b6b					; construct block 
0b6b			 
0b6b 3a 75 fa				ld a, (store_tmpid) 
0b6e 32 81 fa				ld (store_page), a   ; file id 
0b71 3a 74 fa				ld a, (store_tmpext)   ; extent for this block 
0b74 32 82 fa				ld (store_page+1), a 
0b77			 
0b77 e1					pop hl    ; get string to write 
0b78 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0b7a 11 83 fa				ld de, store_page+2 
0b7d			 
0b7d				if DEBUG_STORESE 
0b7d					DMARK "AP5" 
0b7d f5				push af  
0b7e 3a 92 0b			ld a, (.dmark)  
0b81 32 6e fe			ld (debug_mark),a  
0b84 3a 93 0b			ld a, (.dmark+1)  
0b87 32 6f fe			ld (debug_mark+1),a  
0b8a 3a 94 0b			ld a, (.dmark+2)  
0b8d 32 70 fe			ld (debug_mark+2),a  
0b90 18 03			jr .pastdmark  
0b92 ..			.dmark: db "AP5"  
0b95 f1			.pastdmark: pop af  
0b96			endm  
# End of macro DMARK
0b96					CALLMONITOR 
0b96 cd 73 18			call break_point_state  
0b99				endm  
# End of macro CALLMONITOR
0b99				endif 
0b99			 
0b99			 
0b99			 
0b99					; fill buffer with data until end of string or full block 
0b99			 
0b99 7e			.appd:		ld a, (hl) 
0b9a 12					ld (de), a 
0b9b fe 00				cp 0 
0b9d 28 04				jr z, .appdone 
0b9f 23					inc hl 
0ba0 13					inc de 
0ba1 10 f6				djnz .appd 
0ba3			 
0ba3 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0ba4 f5					push af   		; save last byte dumped 
0ba5			 
0ba5			 
0ba5 2a 6e fa			ld hl, (store_tmppageid) 
0ba8 11 81 fa			ld de, store_page 
0bab				if DEBUG_STORESE 
0bab					DMARK "AP6" 
0bab f5				push af  
0bac 3a c0 0b			ld a, (.dmark)  
0baf 32 6e fe			ld (debug_mark),a  
0bb2 3a c1 0b			ld a, (.dmark+1)  
0bb5 32 6f fe			ld (debug_mark+1),a  
0bb8 3a c2 0b			ld a, (.dmark+2)  
0bbb 32 70 fe			ld (debug_mark+2),a  
0bbe 18 03			jr .pastdmark  
0bc0 ..			.dmark: db "AP6"  
0bc3 f1			.pastdmark: pop af  
0bc4			endm  
# End of macro DMARK
0bc4					CALLMONITOR 
0bc4 cd 73 18			call break_point_state  
0bc7				endm  
# End of macro CALLMONITOR
0bc7				endif 
0bc7 cd 39 04				call storage_write_block 
0bca			 
0bca			 
0bca				; was that a full block of data written? 
0bca				; any more to write out? 
0bca			 
0bca				; if yes then set vars and jump to start of function again 
0bca			 
0bca f1					pop af 
0bcb d1					pop de 
0bcc			 
0bcc fe 00				cp 0		 ; no, string was fully written 
0bce c8					ret z 
0bcf			 
0bcf					; setup vars for next cycle 
0bcf			 
0bcf 3a 75 fa				ld a, (store_tmpid) 
0bd2 6f					ld l, a 
0bd3 26 00				ld h, 0 
0bd5			 
0bd5 c3 8c 0a			 	jp storage_append	 ; yes, need to write out some more 
0bd8			 
0bd8			 
0bd8			 
0bd8			 
0bd8			 
0bd8			 
0bd8			 
0bd8			if DEBUG_STORECF 
0bd8			storageput:	 
0bd8					ret 
0bd8			storageread: 
0bd8					ld hl, store_page 
0bd8					ld b, 200 
0bd8					ld a,0 
0bd8			.src:		ld (hl),a 
0bd8					inc hl 
0bd8					djnz .src 
0bd8					 
0bd8			 
0bd8					ld de, 0 
0bd8					ld bc, 1 
0bd8					ld hl, store_page 
0bd8					call cfRead 
0bd8			 
0bd8				call cfGetError 
0bd8				ld hl,scratch 
0bd8				call hexout 
0bd8				ld hl, scratch+2 
0bd8				ld a, 0 
0bd8				ld (hl),a 
0bd8				ld de, scratch 
0bd8				ld a,display_row_1 
0bd8				call str_at_display 
0bd8				call update_display 
0bd8			 
0bd8					ld hl, store_page 
0bd8					ld (os_cur_ptr),hl 
0bd8			 
0bd8					ret 
0bd8			endif 
0bd8			 
0bd8			 
0bd8			; Clear out the main buffer store (used to remove junk before writing a new block) 
0bd8			 
0bd8			storage_clear_page: 
0bd8 e5				push hl 
0bd9 d5				push de 
0bda c5				push bc 
0bdb 21 81 fa			ld hl, store_page 
0bde 3e 00			ld a, 0 
0be0 77				ld (hl), a 
0be1			 
0be1 11 82 fa			ld de, store_page+1 
0be4 01 18 01			ld bc, STORE_BLOCK_LOG 
0be7			 
0be7 ed b0			ldir 
0be9				 
0be9 c1				pop bc 
0bea d1				pop de 
0beb e1				pop hl 
0bec c9				ret 
0bed			 
0bed			; eof 
# End of file firmware_storage.asm
0bed			  
0bed			; support routines for above hardware abstraction layer  
0bed			  
0bed			include "firmware_general.asm"        ; general support functions  
0bed			 
0bed			; word look up 
0bed			 
0bed			; in 
0bed			; a is the index 
0bed			; hl is pointer start of array 
0bed			; 
0bed			; returns 
0bed			; hl to the word 
0bed			; 
0bed			 
0bed			table_lookup:  
0bed d5					push de 
0bee eb					ex de, hl 
0bef			 
0bef 6f					ld l, a 
0bf0 26 00				ld h, 0 
0bf2 29					add hl, hl 
0bf3 19					add hl, de 
0bf4 7e					ld a, (hl) 
0bf5 23					inc hl 
0bf6 66					ld h,(hl) 
0bf7 6f					ld l, a 
0bf8			 
0bf8 d1					pop de 
0bf9 c9					ret 
0bfa			 
0bfa			; Delay loops 
0bfa			 
0bfa			 
0bfa			 
0bfa			aDelayInMS: 
0bfa c5				push bc 
0bfb 47				ld b,a 
0bfc			msdelay: 
0bfc c5				push bc 
0bfd				 
0bfd			 
0bfd 01 41 00			ld bc,041h 
0c00 cd 18 0c			call delayloop 
0c03 c1				pop bc 
0c04 05				dec b 
0c05 20 f5			jr nz,msdelay 
0c07			 
0c07			;if CPU_CLOCK_8MHZ 
0c07			;msdelay8: 
0c07			;	push bc 
0c07			;	 
0c07			; 
0c07			;	ld bc,041h 
0c07			;	call delayloop 
0c07			;	pop bc 
0c07			;	dec b 
0c07			;	jr nz,msdelay8 
0c07			;endif 
0c07			 
0c07			 
0c07 c1				pop bc 
0c08 c9				ret 
0c09			 
0c09			 
0c09			delay250ms: 
0c09				;push de 
0c09 01 00 40			ld bc, 04000h 
0c0c c3 18 0c			jp delayloop 
0c0f			delay500ms: 
0c0f				;push de 
0c0f 01 00 80			ld bc, 08000h 
0c12 c3 18 0c			jp delayloop 
0c15			delay1s: 
0c15				;push bc 
0c15			   ; Clobbers A, d and e 
0c15 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0c18			delayloop: 
0c18 c5			    push bc 
0c19			 
0c19			if BASE_CPM 
0c19				ld bc, CPM_DELAY_TUNE 
0c19			.cpmloop: 
0c19				push bc 
0c19			 
0c19			endif 
0c19			 
0c19			 
0c19			 
0c19			delayloopi: 
0c19			;	push bc 
0c19			;.dl: 
0c19 cb 47		    bit     0,a    	; 8 
0c1b cb 47		    bit     0,a    	; 8 
0c1d cb 47		    bit     0,a    	; 8 
0c1f e6 ff		    and     255  	; 7 
0c21 0b			    dec     bc      	; 6 
0c22 79			    ld      a,c     	; 4 
0c23 b0			    or      b     	; 4 
0c24 c2 19 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0c27			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0c27				;pop de 
0c27			;pop bc 
0c27			 
0c27			if BASE_CPM 
0c27				pop bc 
0c27				 
0c27			    dec     bc      	; 6 
0c27			    ld      a,c     	; 4 
0c27			    or      b     	; 4 
0c27			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0c27				 
0c27			 
0c27			endif 
0c27			;if CPU_CLOCK_8MHZ 
0c27			;    pop bc 
0c27			;    push bc 
0c27			;.dl8: 
0c27			;    bit     0,a    	; 8 
0c27			;    bit     0,a    	; 8 
0c27			;    bit     0,a    	; 8 
0c27			;    and     255  	; 7 
0c27			;    dec     bc      	; 6 
0c27			;    ld      a,c     	; 4 
0c27			;    or      b     	; 4 
0c27			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0c27			;endif 
0c27			 
0c27			;if CPU_CLOCK_10MHZ 
0c27			;    pop bc 
0c27			;    push bc 
0c27			;.dl8: 
0c27			;    bit     0,a    	; 8 
0c27			;    bit     0,a    	; 8 
0c27			;    bit     0,a    	; 8 
0c27			;    and     255  	; 7 
0c27			;    dec     bc      	; 6 
0c27			;    ld      a,c     	; 4 
0c27			;    or      b     	; 4 
0c27			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0c27			;endif 
0c27 c1			    pop bc 
0c28			 
0c28 c9				ret 
0c29			 
0c29			 
0c29			 
0c29			; eof 
# End of file firmware_general.asm
0c29			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0c29			; display routines that use the physical hardware abstraction layer 
0c29			 
0c29			 
0c29			; information window 
0c29			 
0c29			; pass hl with 1st string to display 
0c29			; pass de with 2nd string to display 
0c29			 
0c29			info_panel: 
0c29 e5				push hl 
0c2a			 
0c2a 2a cf fb			ld hl, (display_fb_active) 
0c2d e5				push hl    ; future de destination 
0c2e 21 b4 fd				ld hl, display_fb0 
0c31 22 cf fb				ld (display_fb_active), hl 
0c34			 
0c34			;	call clear_display 
0c34			 
0c34				if BASE_CPM 
0c34				ld a, '.' 
0c34				else 
0c34 3e a5			ld a, 165 
0c36				endif 
0c36 cd 9d 0c			call fill_display 
0c39			 
0c39			 
0c39 3e 55			ld a, display_row_3 + 5 
0c3b cd ab 0c			call str_at_display 
0c3e			 
0c3e e1				pop hl 
0c3f d1				pop de 
0c40			 
0c40 e5				push hl 
0c41			 
0c41			 
0c41 3e 2d			ld a, display_row_2 + 5 
0c43 cd ab 0c			call str_at_display 
0c46			 
0c46			 
0c46 cd bb 0c			call update_display 
0c49 cd 5f 1e			call next_page_prompt 
0c4c cd 98 0c			call clear_display 
0c4f			 
0c4f				 
0c4f 21 13 fd				ld hl, display_fb1 
0c52 22 cf fb				ld (display_fb_active), hl 
0c55 cd bb 0c			call update_display 
0c58			 
0c58 e1				pop hl 
0c59			 
0c59 c9				ret 
0c5a			 
0c5a			 
0c5a			 
0c5a			 
0c5a			; TODO windowing? 
0c5a			 
0c5a			; TODO scroll line up 
0c5a			 
0c5a			scroll_up: 
0c5a			 
0c5a e5				push hl 
0c5b d5				push de 
0c5c c5				push bc 
0c5d			 
0c5d				; get frame buffer  
0c5d			 
0c5d 2a cf fb			ld hl, (display_fb_active) 
0c60 e5				push hl    ; future de destination 
0c61			 
0c61 11 28 00			ld  de, display_cols 
0c64 19				add hl, de 
0c65			 
0c65 d1				pop de 
0c66			 
0c66				;ex de, hl 
0c66 01 9f 00			ld bc, display_fb_len -1  
0c69			;if DEBUG_FORTH_WORDS 
0c69			;	DMARK "SCL" 
0c69			;	CALLMONITOR 
0c69			;endif	 
0c69 ed b0			ldir 
0c6b			 
0c6b				; wipe bottom row 
0c6b			 
0c6b			 
0c6b 2a cf fb			ld hl, (display_fb_active) 
0c6e 11 a0 00			ld de, display_cols*display_rows 
0c71 19				add hl, de 
0c72 06 28			ld b, display_cols 
0c74 3e 20			ld a, ' ' 
0c76			.scwipe: 
0c76 77				ld (hl), a 
0c77 2b				dec hl 
0c78 10 fc			djnz .scwipe 
0c7a			 
0c7a				;pop hl 
0c7a			 
0c7a c1				pop bc 
0c7b d1				pop de 
0c7c e1				pop hl 
0c7d			 
0c7d c9				ret 
0c7e			 
0c7e			 
0c7e			;scroll_upo: 
0c7e			;	ld de, display_row_1 
0c7e			 ;	ld hl, display_row_2 
0c7e			;	ld bc, display_cols 
0c7e			;	ldir 
0c7e			;	ld de, display_row_2 
0c7e			 ;	ld hl, display_row_3 
0c7e			;	ld bc, display_cols 
0c7e			;	ldir 
0c7e			;	ld de, display_row_3 
0c7e			 ;	ld hl, display_row_4 
0c7e			;	ld bc, display_cols 
0c7e			;	ldir 
0c7e			 
0c7e			; TODO clear row 4 
0c7e			 
0c7e			;	ret 
0c7e			 
0c7e				 
0c7e			scroll_down: 
0c7e			 
0c7e e5				push hl 
0c7f d5				push de 
0c80 c5				push bc 
0c81			 
0c81				; get frame buffer  
0c81			 
0c81 2a cf fb			ld hl, (display_fb_active) 
0c84			 
0c84 11 9f 00			ld de, display_fb_len - 1 
0c87 19				add hl, de 
0c88			 
0c88 e5			push hl    ; future de destination 
0c89			 
0c89 11 28 00			ld  de, display_cols 
0c8c ed 52			sbc hl, de 
0c8e			 
0c8e			 
0c8e d1				pop de 
0c8f			 
0c8f			;	ex de, hl 
0c8f 01 9f 00			ld bc, display_fb_len -1  
0c92			 
0c92			 
0c92				 
0c92			 
0c92 ed b0			ldir 
0c94			 
0c94				; wipe bottom row 
0c94			 
0c94			 
0c94			;	ld hl, (display_fb_active) 
0c94			;;	ld de, display_cols*display_rows 
0c94			;;	add hl, de 
0c94			;	ld b, display_cols 
0c94			;	ld a, ' ' 
0c94			;.scwiped: 
0c94			;	ld (hl), a 
0c94			;	dec hl 
0c94			;	djnz .scwiped 
0c94			 
0c94				;pop hl 
0c94			 
0c94 c1				pop bc 
0c95 d1				pop de 
0c96 e1				pop hl 
0c97			 
0c97 c9				ret 
0c98			;scroll_down: 
0c98			;	ld de, display_row_4 
0c98			;	ld hl, display_row_3 
0c98			;	ld bc, display_cols 
0c98			;	ldir 
0c98			;	ld de, display_row_3 
0c98			; 	ld hl, display_row_2 
0c98			;	ld bc, display_cols 
0c98			;	ldir 
0c98			;	ld de, display_row_2 
0c98			;	ld hl, display_row_1 
0c98			;	ld bc, display_cols 
0c98			;	ldir 
0c98			;;; TODO clear row 1 
0c98			;	ret 
0c98			 
0c98			 
0c98			 
0c98			 
0c98			 
0c98			; clear active frame buffer 
0c98			 
0c98			clear_display: 
0c98 3e 20			ld a, ' ' 
0c9a c3 9d 0c			jp fill_display 
0c9d			 
0c9d			; fill active frame buffer with a char in A 
0c9d			 
0c9d			fill_display: 
0c9d 06 a0			ld b,display_fb_len 
0c9f 2a cf fb			ld hl, (display_fb_active) 
0ca2 77			.fd1:	ld (hl),a 
0ca3 23				inc hl 
0ca4 10 fc			djnz .fd1 
0ca6 23				inc hl 
0ca7 3e 00			ld a,0 
0ca9 77				ld (hl),a 
0caa			 
0caa			 
0caa c9				ret 
0cab			; Write string (DE) at pos (A) to active frame buffer 
0cab			 
0cab 2a cf fb		str_at_display:    ld hl,(display_fb_active) 
0cae 06 00					ld b,0 
0cb0 4f					ld c,a 
0cb1 09					add hl,bc 
0cb2 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0cb3 b7			            OR   A              ;Null terminator? 
0cb4 c8			            RET  Z              ;Yes, so finished 
0cb5 77					ld (hl),a 
0cb6 23				inc hl 
0cb7 13			            INC  DE             ;Point to next character 
0cb8 18 f8		            JR   .sad1     ;Repeat 
0cba c9					ret 
0cbb			 
0cbb			; using current frame buffer write to physical display 
0cbb			 
0cbb			update_display: 
0cbb e5				push hl 
0cbc 2a cf fb			ld hl, (display_fb_active) 
0cbf cd 8e 69			call write_display 
0cc2 e1				pop hl 
0cc3 c9				ret 
0cc4			 
0cc4			; TODO scrolling 
0cc4			 
0cc4			 
0cc4			; move cursor right one char 
0cc4			cursor_right: 
0cc4			 
0cc4				; TODO shift right 
0cc4				; TODO if beyond max col 
0cc4				; TODO       cursor_next_line 
0cc4			 
0cc4 c9				ret 
0cc5			 
0cc5			 
0cc5			cursor_next_line: 
0cc5				; TODO first char 
0cc5				; TODO line down 
0cc5				; TODO if past last row 
0cc5				; TODO    scroll up 
0cc5			 
0cc5 c9				ret 
0cc6			 
0cc6			cursor_left: 
0cc6				; TODO shift left 
0cc6				; TODO if beyond left  
0cc6				; TODO     cursor prev line 
0cc6				 
0cc6 c9				ret 
0cc7			 
0cc7			cursor_prev_line: 
0cc7				; TODO last char 
0cc7				; TODO line up 
0cc7				; TODO if past first row 
0cc7				; TODO   scroll down 
0cc7			 
0cc7 c9				ret 
0cc8			 
0cc8			 
0cc8			cout: 
0cc8				; A - char 
0cc8 c9				ret 
0cc9			 
0cc9			 
0cc9			; Display a menu and allow item selection (optional toggle items) 
0cc9			; 
0cc9			; format: 
0cc9			; hl pointer to word array with zero term for items 
0cc9			; e.g.    db item1 
0cc9			;         db .... 
0cc9			;         db 0 
0cc9			; 
0cc9			; a = starting menu item  
0cc9			; 
0cc9			; de = pointer item toggle array   (todo) 
0cc9			; 
0cc9			; returns item selected in a 1-... 
0cc9			; returns 0 if back button pressed 
0cc9			; 
0cc9			; NOTE: Uses system frame buffer to display 
0cc9			; 
0cc9			; LEFT, Q = go back 
0cc9			; RIGHT, SPACE, CR = select 
0cc9			; UP, A - Up 
0cc9			; DOWN, Z - Down 
0cc9			 
0cc9			 
0cc9			 
0cc9			 
0cc9			 
0cc9			menu: 
0cc9			 
0cc9					; keep array pointer 
0cc9			 
0cc9 22 7a fa				ld (store_tmp1), hl 
0ccc 32 78 fa				ld (store_tmp2), a 
0ccf			 
0ccf					; check for key bounce 
0ccf			 
0ccf			if BASE_KEV 
0ccf			 
0ccf cd d9 6c		.mbounce:	call cin 
0cd2 fe 00				cp 0 
0cd4 20 f9				jr nz, .mbounce 
0cd6			endif 
0cd6					; for ease use ex 
0cd6			 
0cd6					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0cd6 21 b4 fd				ld hl, display_fb0 
0cd9 22 cf fb				ld (display_fb_active), hl 
0cdc			 
0cdc cd 98 0c		.mloop:		call clear_display 
0cdf cd bb 0c				call update_display 
0ce2			 
0ce2					; draw selection id '>' at 1 
0ce2			 
0ce2					; init start of list display 
0ce2			 
0ce2 3e 05				ld a, 5 
0ce4 32 76 fa				ld (store_tmp3), a   ; display row count 
0ce7 3a 78 fa				ld a,( store_tmp2) 
0cea 32 79 fa				ld (store_tmp2+1), a   ; display item count 
0ced			 
0ced					 
0ced			.mitem:	 
0ced			 
0ced			 
0ced 3a 79 fa				ld a,(store_tmp2+1) 
0cf0 6f					ld l, a 
0cf1 26 00				ld h, 0 
0cf3 29					add hl, hl 
0cf4 ed 5b 7a fa			ld de, (store_tmp1) 
0cf8 19					add hl, de 
0cf9 7e					ld a, (hl) 
0cfa 23					inc hl 
0cfb 66					ld h,(hl) 
0cfc 6f					ld l, a 
0cfd			 
0cfd cd f5 0e				call ishlzero 
0d00 28 1a				jr z, .mdone 
0d02			 
0d02 eb					ex de, hl 
0d03 3a 76 fa				ld a, (store_tmp3) 
0d06 cd ab 0c				call str_at_display 
0d09					 
0d09			 
0d09					; next item 
0d09 3a 79 fa				ld a, (store_tmp2+1) 
0d0c 3c					inc a 
0d0d 32 79 fa				ld (store_tmp2+1), a   ; display item count 
0d10			 
0d10			 		; next row 
0d10			 
0d10 3a 76 fa				ld a, (store_tmp3) 
0d13 c6 28				add display_cols 
0d15 32 76 fa				ld (store_tmp3), a 
0d18			 
0d18					; at end of screen? 
0d18			 
0d18 fe 10				cp display_rows*4 
0d1a 20 d1				jr nz, .mitem 
0d1c			 
0d1c			 
0d1c			.mdone: 
0d1c cd f5 0e				call ishlzero 
0d1f 28 08				jr z, .nodn 
0d21			 
0d21 3e 78				ld a, display_row_4 
0d23 11 a2 0d				ld de, .mdown 
0d26 cd ab 0c				call str_at_display 
0d29			 
0d29					; draw options to fill the screens with active item on line 1 
0d29					; if current option is 2 or more then display ^ in top 
0d29			 
0d29 3a 78 fa		.nodn:		ld a, (store_tmp2) 
0d2c fe 00				cp 0 
0d2e 28 08				jr z, .noup 
0d30			 
0d30 3e 00				ld a, 0 
0d32 11 a0 0d				ld de, .mup 
0d35 cd ab 0c				call str_at_display 
0d38			 
0d38 3e 02		.noup:		ld a, 2 
0d3a 11 9e 0d				ld de, .msel 
0d3d cd ab 0c				call str_at_display 
0d40			 
0d40					; if current option + 1 is not null then display V in bottom 
0d40					; get key 
0d40 cd bb 0c				call update_display 
0d43			 
0d43			 
0d43					; handle key 
0d43			 
0d43 cd c8 6c				call cin_wait 
0d46			 
0d46 fe 05				cp KEY_UP 
0d48 28 2b				jr z, .mgoup 
0d4a fe 61				cp 'a' 
0d4c 28 27				jr z, .mgoup 
0d4e fe 0a				cp KEY_DOWN 
0d50 28 32				jr z, .mgod 
0d52 fe 7a				cp 'z' 
0d54 28 2e				jr z, .mgod 
0d56 fe 20				cp ' ' 
0d58 28 34				jr z, .goend 
0d5a fe 0c				cp KEY_RIGHT 
0d5c 28 30				jr z, .goend 
0d5e fe 0d				cp KEY_CR 
0d60 28 2c				jr z, .goend 
0d62 fe 71				cp 'q' 
0d64 28 0b				jr z, .goback 
0d66			 
0d66 fe 0b				cp KEY_LEFT 
0d68 28 07				jr z, .goback 
0d6a fe 08				cp KEY_BS 
0d6c 28 03				jr z, .goback 
0d6e c3 dc 0c				jp .mloop 
0d71			 
0d71			.goback: 
0d71 3e 00			ld a, 0 
0d73 18 1d			jr .goend2 
0d75			 
0d75				; move up one 
0d75			.mgoup: 
0d75 3a 78 fa				ld a, (store_tmp2) 
0d78 fe 00				cp 0 
0d7a ca dc 0c				jp z, .mloop 
0d7d 3d					dec a 
0d7e 32 78 fa				ld (store_tmp2), a 
0d81 c3 dc 0c				jp .mloop 
0d84			 
0d84				; move down one 
0d84			.mgod: 
0d84 3a 78 fa				ld a, (store_tmp2) 
0d87 3c					inc a 
0d88 32 78 fa				ld (store_tmp2), a 
0d8b c3 dc 0c				jp .mloop 
0d8e			 
0d8e			 
0d8e			.goend: 
0d8e					; get selected item number 
0d8e			 
0d8e 3a 78 fa				ld a, (store_tmp2) 
0d91 3c					inc a 
0d92			 
0d92			.goend2: 
0d92 f5					push af 
0d93			 
0d93					; restore active fb 
0d93					; TODO BUG assumes fb1 
0d93			 
0d93 21 13 fd				ld hl, display_fb1 
0d96 22 cf fb				ld (display_fb_active), hl 
0d99			 
0d99					; restore main regs 
0d99			 
0d99			 
0d99 cd bb 0c				call update_display 
0d9c			 
0d9c f1					pop af 
0d9d			 
0d9d c9				ret 
0d9e			 
0d9e .. 00		.msel:   db ">",0 
0da0 .. 00		.mup:   db "^",0 
0da2 .. 00		.mdown:   db "v",0 
0da4			 
0da4			 
0da4			; eof 
0da4			 
# End of file firmware_display.asm
0da4			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0da4			; random number generators 
0da4			 
0da4			 
0da4			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0da4			 
0da4			 
0da4			;-----> Generate a random number 
0da4			; output a=answer 0<=a<=255 
0da4			; all registers are preserved except: af 
0da4			random: 
0da4 e5			        push    hl 
0da5 d5			        push    de 
0da6 2a b1 fb		        ld      hl,(randData) 
0da9 ed 5f		        ld      a,r 
0dab 57			        ld      d,a 
0dac 5e			        ld      e,(hl) 
0dad 19			        add     hl,de 
0dae 85			        add     a,l 
0daf ac			        xor     h 
0db0 22 b1 fb		        ld      (randData),hl 
0db3 d1			        pop     de 
0db4 e1			        pop     hl 
0db5 c9			        ret 
0db6			 
0db6			 
0db6			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0db6			 
0db6			 
0db6			 
0db6			;------LFSR------ 
0db6			;James Montelongo 
0db6			;optimized by Spencer Putt 
0db6			;out: 
0db6			; a = 8 bit random number 
0db6			RandLFSR: 
0db6 21 b7 fb		        ld hl,LFSRSeed+4 
0db9 5e			        ld e,(hl) 
0dba 23			        inc hl 
0dbb 56			        ld d,(hl) 
0dbc 23			        inc hl 
0dbd 4e			        ld c,(hl) 
0dbe 23			        inc hl 
0dbf 7e			        ld a,(hl) 
0dc0 47			        ld b,a 
0dc1 cb 13		        rl e  
0dc3 cb 12			rl d 
0dc5 cb 11		        rl c  
0dc7 17				rla 
0dc8 cb 13		        rl e  
0dca cb 12			rl d 
0dcc cb 11		        rl c  
0dce 17				rla 
0dcf cb 13		        rl e  
0dd1 cb 12			rl d 
0dd3 cb 11		        rl c  
0dd5 17				rla 
0dd6 67			        ld h,a 
0dd7 cb 13		        rl e  
0dd9 cb 12			rl d 
0ddb cb 11		        rl c  
0ddd 17				rla 
0dde a8			        xor b 
0ddf cb 13		        rl e  
0de1 cb 12			rl d 
0de3 ac			        xor h 
0de4 a9			        xor c 
0de5 aa			        xor d 
0de6 21 b9 fb		        ld hl,LFSRSeed+6 
0de9 11 ba fb		        ld de,LFSRSeed+7 
0dec 01 07 00		        ld bc,7 
0def ed b8		        lddr 
0df1 12			        ld (de),a 
0df2 c9			        ret 
0df3			 
0df3			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0df3			 
0df3			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0df3			 
0df3			 
0df3			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0df3			 
0df3			prng16: 
0df3			;Inputs: 
0df3			;   (seed1) contains a 16-bit seed value 
0df3			;   (seed2) contains a NON-ZERO 16-bit seed value 
0df3			;Outputs: 
0df3			;   HL is the result 
0df3			;   BC is the result of the LCG, so not that great of quality 
0df3			;   DE is preserved 
0df3			;Destroys: 
0df3			;   AF 
0df3			;cycle: 4,294,901,760 (almost 4.3 billion) 
0df3			;160cc 
0df3			;26 bytes 
0df3 2a ab fb		    ld hl,(seed1) 
0df6 44			    ld b,h 
0df7 4d			    ld c,l 
0df8 29			    add hl,hl 
0df9 29			    add hl,hl 
0dfa 2c			    inc l 
0dfb 09			    add hl,bc 
0dfc 22 ab fb		    ld (seed1),hl 
0dff 2a a9 fb		    ld hl,(seed2) 
0e02 29			    add hl,hl 
0e03 9f			    sbc a,a 
0e04 e6 2d		    and %00101101 
0e06 ad			    xor l 
0e07 6f			    ld l,a 
0e08 22 a9 fb		    ld (seed2),hl 
0e0b 09			    add hl,bc 
0e0c c9			    ret 
0e0d			 
0e0d			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0e0d			 
0e0d			rand32: 
0e0d			;Inputs: 
0e0d			;   (seed1_0) holds the lower 16 bits of the first seed 
0e0d			;   (seed1_1) holds the upper 16 bits of the first seed 
0e0d			;   (seed2_0) holds the lower 16 bits of the second seed 
0e0d			;   (seed2_1) holds the upper 16 bits of the second seed 
0e0d			;   **NOTE: seed2 must be non-zero 
0e0d			;Outputs: 
0e0d			;   HL is the result 
0e0d			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0e0d			;Destroys: 
0e0d			;   AF 
0e0d			;Tested and passes all CAcert tests 
0e0d			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0e0d			;it has a period of 18,446,744,069,414,584,320 
0e0d			;roughly 18.4 quintillion. 
0e0d			;LFSR taps: 0,2,6,7  = 11000101 
0e0d			;291cc 
0e0d			;seed1_0=$+1 
0e0d			;    ld hl,12345 
0e0d			;seed1_1=$+1 
0e0d			;    ld de,6789 
0e0d			;    ld b,h 
0e0d			;    ld c,l 
0e0d			;    add hl,hl \ rl e \ rl d 
0e0d			;    add hl,hl \ rl e \ rl d 
0e0d			;    inc l 
0e0d			;    add hl,bc 
0e0d			;    ld (seed1_0),hl 
0e0d			;    ld hl,(seed1_1) 
0e0d			;    adc hl,de 
0e0d			;    ld (seed1_1),hl 
0e0d			;    ex de,hl 
0e0d			;seed2_0=$+1 
0e0d			;    ld hl,9876 
0e0d			;seed2_1=$+1 
0e0d			;    ld bc,54321 
0e0d			;    add hl,hl \ rl c \ rl b 
0e0d			;    ld (seed2_1),bc 
0e0d			;    sbc a,a 
0e0d			;    and %11000101 
0e0d			;    xor l 
0e0d			;    ld l,a 
0e0d			;    ld (seed2_0),hl 
0e0d			;    ex de,hl 
0e0d			;    add hl,bc 
0e0d			;    ret 
0e0d			; 
0e0d			 
0e0d			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0e0d			; 20 bytes, 86 cycles (excluding ret) 
0e0d			 
0e0d			; returns   hl = pseudorandom number 
0e0d			; corrupts   a 
0e0d			 
0e0d			; generates 16-bit pseudorandom numbers with a period of 65535 
0e0d			; using the xorshift method: 
0e0d			 
0e0d			; hl ^= hl << 7 
0e0d			; hl ^= hl >> 9 
0e0d			; hl ^= hl << 8 
0e0d			 
0e0d			; some alternative shift triplets which also perform well are: 
0e0d			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0e0d			 
0e0d			;  org 32768 
0e0d			 
0e0d			xrnd: 
0e0d 2a af fb		  ld hl,(xrandc)       ; seed must not be 0 
0e10 3e 00		  ld a,0 
0e12 bd			  cp l 
0e13 20 02		  jr nz, .xrnd1 
0e15 2e 01		  ld l, 1 
0e17			.xrnd1: 
0e17			 
0e17 7c			  ld a,h 
0e18 1f			  rra 
0e19 7d			  ld a,l 
0e1a 1f			  rra 
0e1b ac			  xor h 
0e1c 67			  ld h,a 
0e1d 7d			  ld a,l 
0e1e 1f			  rra 
0e1f 7c			  ld a,h 
0e20 1f			  rra 
0e21 ad			  xor l 
0e22 6f			  ld l,a 
0e23 ac			  xor h 
0e24 67			  ld h,a 
0e25			 
0e25 22 af fb		  ld (xrandc),hl 
0e28			 
0e28 c9			  ret 
0e29			;  
0e29			 
0e29			 
0e29			;;;; int maths 
0e29			 
0e29			; https://map.grauw.nl/articles/mult_div_shifts.php 
0e29			; Divide 16-bit values (with 16-bit result) 
0e29			; In: Divide BC by divider DE 
0e29			; Out: BC = result, HL = rest 
0e29			; 
0e29			Div16: 
0e29 21 00 00		    ld hl,0 
0e2c 78			    ld a,b 
0e2d 06 08		    ld b,8 
0e2f			Div16_Loop1: 
0e2f 17			    rla 
0e30 ed 6a		    adc hl,hl 
0e32 ed 52		    sbc hl,de 
0e34 30 01		    jr nc,Div16_NoAdd1 
0e36 19			    add hl,de 
0e37			Div16_NoAdd1: 
0e37 10 f6		    djnz Div16_Loop1 
0e39 17			    rla 
0e3a 2f			    cpl 
0e3b 47			    ld b,a 
0e3c 79			    ld a,c 
0e3d 48			    ld c,b 
0e3e 06 08		    ld b,8 
0e40			Div16_Loop2: 
0e40 17			    rla 
0e41 ed 6a		    adc hl,hl 
0e43 ed 52		    sbc hl,de 
0e45 30 01		    jr nc,Div16_NoAdd2 
0e47 19			    add hl,de 
0e48			Div16_NoAdd2: 
0e48 10 f6		    djnz Div16_Loop2 
0e4a 17			    rla 
0e4b 2f			    cpl 
0e4c 41			    ld b,c 
0e4d 4f			    ld c,a 
0e4e c9			ret 
0e4f			 
0e4f			 
0e4f			;http://z80-heaven.wikidot.com/math 
0e4f			; 
0e4f			;Inputs: 
0e4f			;     DE and A are factors 
0e4f			;Outputs: 
0e4f			;     A is not changed 
0e4f			;     B is 0 
0e4f			;     C is not changed 
0e4f			;     DE is not changed 
0e4f			;     HL is the product 
0e4f			;Time: 
0e4f			;     342+6x 
0e4f			; 
0e4f			Mult16: 
0e4f			 
0e4f 06 08		     ld b,8          ;7           7 
0e51 21 00 00		     ld hl,0         ;10         10 
0e54 29			       add hl,hl     ;11*8       88 
0e55 07			       rlca          ;4*8        32 
0e56 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0e58 19			         add hl,de   ;--         -- 
0e59 10 f9		       djnz $-5      ;13*7+8     99 
0e5b c9			ret 
0e5c			 
0e5c			; 
0e5c			; Square root of 16-bit value 
0e5c			; In:  HL = value 
0e5c			; Out:  D = result (rounded down) 
0e5c			; 
0e5c			;Sqr16: 
0e5c			;    ld de,#0040 
0e5c			;    ld a,l 
0e5c			;    ld l,h 
0e5c			;    ld h,d 
0e5c			;    or a 
0e5c			;    ld b,8 
0e5c			;Sqr16_Loop: 
0e5c			;    sbc hl,de 
0e5c			;    jr nc,Sqr16_Skip 
0e5c			;    add hl,de 
0e5c			;Sqr16_Skip: 
0e5c			;    ccf 
0e5c			;    rl d 
0e5c			;    add a,a 
0e5c			;    adc hl,hl 
0e5c			;    add a,a 
0e5c			;    adc hl,hl 
0e5c			;    djnz Sqr16_Loop 
0e5c			;    ret 
0e5c			; 
0e5c			; 
0e5c			; Divide 8-bit values 
0e5c			; In: Divide E by divider C 
0e5c			; Out: A = result, B = rest 
0e5c			; 
0e5c			Div8: 
0e5c af			    xor a 
0e5d 06 08		    ld b,8 
0e5f			Div8_Loop: 
0e5f cb 13		    rl e 
0e61 17			    rla 
0e62 91			    sub c 
0e63 30 01		    jr nc,Div8_NoAdd 
0e65 81			    add a,c 
0e66			Div8_NoAdd: 
0e66 10 f7		    djnz Div8_Loop 
0e68 47			    ld b,a 
0e69 7b			    ld a,e 
0e6a 17			    rla 
0e6b 2f			    cpl 
0e6c c9			    ret 
0e6d			 
0e6d			; 
0e6d			; Multiply 8-bit value with a 16-bit value (unrolled) 
0e6d			; In: Multiply A with DE 
0e6d			; Out: HL = result 
0e6d			; 
0e6d			Mult12U: 
0e6d 2e 00		    ld l,0 
0e6f 87			    add a,a 
0e70 30 01		    jr nc,Mult12U_NoAdd0 
0e72 19			    add hl,de 
0e73			Mult12U_NoAdd0: 
0e73 29			    add hl,hl 
0e74 87			    add a,a 
0e75 30 01		    jr nc,Mult12U_NoAdd1 
0e77 19			    add hl,de 
0e78			Mult12U_NoAdd1: 
0e78 29			    add hl,hl 
0e79 87			    add a,a 
0e7a 30 01		    jr nc,Mult12U_NoAdd2 
0e7c 19			    add hl,de 
0e7d			Mult12U_NoAdd2: 
0e7d 29			    add hl,hl 
0e7e 87			    add a,a 
0e7f 30 01		    jr nc,Mult12U_NoAdd3 
0e81 19			    add hl,de 
0e82			Mult12U_NoAdd3: 
0e82 29			    add hl,hl 
0e83 87			    add a,a 
0e84 30 01		    jr nc,Mult12U_NoAdd4 
0e86 19			    add hl,de 
0e87			Mult12U_NoAdd4: 
0e87 29			    add hl,hl 
0e88 87			    add a,a 
0e89 30 01		    jr nc,Mult12U_NoAdd5 
0e8b 19			    add hl,de 
0e8c			Mult12U_NoAdd5: 
0e8c 29			    add hl,hl 
0e8d 87			    add a,a 
0e8e 30 01		    jr nc,Mult12U_NoAdd6 
0e90 19			    add hl,de 
0e91			Mult12U_NoAdd6: 
0e91 29			    add hl,hl 
0e92 87			    add a,a 
0e93 d0			    ret nc 
0e94 19			    add hl,de 
0e95 c9			    ret 
0e96			 
0e96			; 
0e96			; Multiply 8-bit value with a 16-bit value (right rotating) 
0e96			; In: Multiply A with DE 
0e96			;      Put lowest value in A for most efficient calculation 
0e96			; Out: HL = result 
0e96			; 
0e96			Mult12R: 
0e96 21 00 00		    ld hl,0 
0e99			Mult12R_Loop: 
0e99 cb 3f		    srl a 
0e9b 30 01		    jr nc,Mult12R_NoAdd 
0e9d 19			    add hl,de 
0e9e			Mult12R_NoAdd: 
0e9e cb 23		    sla e 
0ea0 cb 12		    rl d 
0ea2 b7			    or a 
0ea3 c2 99 0e		    jp nz,Mult12R_Loop 
0ea6 c9			    ret 
0ea7			 
0ea7			; 
0ea7			; Multiply 16-bit values (with 32-bit result) 
0ea7			; In: Multiply BC with DE 
0ea7			; Out: BCHL = result 
0ea7			; 
0ea7			Mult32: 
0ea7 79			    ld a,c 
0ea8 48			    ld c,b 
0ea9 21 00 00		    ld hl,0 
0eac 06 10		    ld b,16 
0eae			Mult32_Loop: 
0eae 29			    add hl,hl 
0eaf 17			    rla 
0eb0 cb 11		    rl c 
0eb2 30 07		    jr nc,Mult32_NoAdd 
0eb4 19			    add hl,de 
0eb5 ce 00		    adc a,0 
0eb7 d2 bb 0e		    jp nc,Mult32_NoAdd 
0eba 0c			    inc c 
0ebb			Mult32_NoAdd: 
0ebb 10 f1		    djnz Mult32_Loop 
0ebd 41			    ld b,c 
0ebe 4f			    ld c,a 
0ebf c9			    ret 
0ec0			 
0ec0			 
0ec0			 
0ec0			; 
0ec0			; Multiply 8-bit values 
0ec0			; In:  Multiply H with E 
0ec0			; Out: HL = result 
0ec0			; 
0ec0			Mult8: 
0ec0 16 00		    ld d,0 
0ec2 6a			    ld l,d 
0ec3 06 08		    ld b,8 
0ec5			Mult8_Loop: 
0ec5 29			    add hl,hl 
0ec6 30 01		    jr nc,Mult8_NoAdd 
0ec8 19			    add hl,de 
0ec9			Mult8_NoAdd: 
0ec9 10 fa		    djnz Mult8_Loop 
0ecb c9			    ret 
0ecc			 
0ecc			 
0ecc			 
0ecc			 
0ecc			 
0ecc			 
0ecc			 
0ecc			 
0ecc			;;http://z80-heaven.wikidot.com/math 
0ecc			;;This divides DE by BC, storing the result in DE, remainder in HL 
0ecc			; 
0ecc			;DE_Div_BC:          ;1281-2x, x is at most 16 
0ecc			;     ld a,16        ;7 
0ecc			;     ld hl,0        ;10 
0ecc			;     jp $+5         ;10 
0ecc			;.DivLoop: 
0ecc			;       add hl,bc    ;-- 
0ecc			;       dec a        ;64 
0ecc			;       jr z,.DivLoopEnd        ;86 
0ecc			; 
0ecc			;       sla e        ;128 
0ecc			;       rl d         ;128 
0ecc			;       adc hl,hl    ;240 
0ecc			;       sbc hl,bc    ;240 
0ecc			;       jr nc,.DivLoop ;23|21 
0ecc			;       inc e        ;-- 
0ecc			;       jp .DivLoop+1 
0ecc			; 
0ecc			;.DivLoopEnd: 
0ecc			 
0ecc			;HL_Div_C: 
0ecc			;Inputs: 
0ecc			;     HL is the numerator 
0ecc			;     C is the denominator 
0ecc			;Outputs: 
0ecc			;     A is the remainder 
0ecc			;     B is 0 
0ecc			;     C is not changed 
0ecc			;     DE is not changed 
0ecc			;     HL is the quotient 
0ecc			; 
0ecc			;       ld b,16 
0ecc			;       xor a 
0ecc			;         add hl,hl 
0ecc			;         rla 
0ecc			;         cp c 
0ecc			;         jr c,$+4 
0ecc			;           inc l 
0ecc			;           sub c 
0ecc			;         djnz $-7 
0ecc			 
0ecc			; https://plutiedev.com/z80-add-8bit-to-16bit 
0ecc			 
0ecc			addatohl: 
0ecc 85			    add   a, l    ; A = A+L 
0ecd 6f			    ld    l, a    ; L = A+L 
0ece 8c			    adc   a, h    ; A = A+L+H+carry 
0ecf 95			    sub   l       ; A = H+carry 
0ed0 67			    ld    h, a    ; H = H+carry 
0ed1 c9			ret 
0ed2			 
0ed2			addatode: 
0ed2 83			    add   a, e    ; A = A+L 
0ed3 5f			    ld    e, a    ; L = A+L 
0ed4 8a			    adc   a, d    ; A = A+L+H+carry 
0ed5 93			    sub   e       ; A = H+carry 
0ed6 57			    ld    d, a    ; H = H+carry 
0ed7 c9			ret 
0ed8			 
0ed8			 
0ed8			addatobc: 
0ed8 81			    add   a, c    ; A = A+L 
0ed9 4f			    ld    c, a    ; L = A+L 
0eda 88			    adc   a, b    ; A = A+L+H+carry 
0edb 91			    sub   c       ; A = H+carry 
0edc 47			    ld    b, a    ; H = H+carry 
0edd c9			ret 
0ede			 
0ede			subafromhl: 
0ede			   ; If A=0 do nothing 
0ede			    ; Otherwise flip A's sign. Since 
0ede			    ; the upper byte becomes -1, also 
0ede			    ; substract 1 from H. 
0ede ed 44		    neg 
0ee0 ca e9 0e		    jp    z, Skip 
0ee3 25			    dec   h 
0ee4			     
0ee4			    ; Now add the low byte as usual 
0ee4			    ; Two's complement takes care of 
0ee4			    ; ensuring the result is correct 
0ee4 85			    add   a, l 
0ee5 6f			    ld    l, a 
0ee6 8c			    adc   a, h 
0ee7 95			    sub   l 
0ee8 67			    ld    h, a 
0ee9			Skip: 
0ee9 c9				ret 
0eea			 
0eea			 
0eea			; compare hl and de 
0eea			; returns:  
0eea			; if hl = de, z=1, s=0, c0=0 
0eea			; if hl > de, z=0, s=0, c=0 
0eea			; if hl < de, z=0, s=1, c=1 
0eea			cmp16:	 
0eea b7				or a 
0eeb ed 52			sbc hl,de 
0eed e0				ret po 
0eee 7c				ld a,h 
0eef 1f				rra 
0ef0 ee 40			xor 01000000B 
0ef2 37				scf 
0ef3 8f				adc a,a 
0ef4 c9				ret 
0ef5			 
0ef5			 
0ef5			; test if hl contains zero   - A is destroyed 
0ef5			 
0ef5			ishlzero:    
0ef5 b7				or a     ; reset flags 
0ef6 7c				ld a, h 
0ef7 b5				or l        	 
0ef8			 
0ef8 c9				ret 
0ef9			 
0ef9			 
0ef9			 
0ef9			 
0ef9			if FORTH_ENABLE_FLOATMATH 
0ef9			;include "float/bbcmath.z80" 
0ef9			include "float/lpfpcalc.asm" 
0ef9			endif 
0ef9			 
0ef9			 
0ef9			; eof 
0ef9			 
# End of file firmware_maths.asm
0ef9			include "firmware_strings.asm"   ; string handling  
0ef9			 
0ef9			 
0ef9			; TODO string len 
0ef9			; input text string, end on cr with zero term 
0ef9			; a offset into frame buffer to start prompt 
0ef9			; d is max length 
0ef9			; e is display size TODO 
0ef9			; c is current cursor position 
0ef9			; hl is ptr to where string will be stored 
0ef9			 
0ef9			 
0ef9			; TODO check limit of buffer for new inserts 
0ef9			; TODO check insert does not push beyond buffer 
0ef9			; TODO scroll in a limited display area 
0ef9			; TODO scroll whole screen on page wrap 
0ef9			 
0ef9			 
0ef9			; TODO handle KEY_PREVWORD 
0ef9			; TODO handle KEY_NEXTWORD 
0ef9			; TODO handle KEY_HOME 
0ef9			; TODO handle KEY_END 
0ef9			; TODO use LCD cursor? 
0ef9			 
0ef9 32 67 fe		input_str:    	ld (input_at_pos),a      ; save display position to start 
0efc 81					add c 
0efd 32 65 fe				ld (input_at_cursor),a	; save draw pos of cursor 
0f00 22 6a fe				ld (input_start), hl     ; save ptr to buffer 
0f03 79					ld a, c 
0f04 cd cc 0e				call addatohl 
0f07 22 6c fe				ld (input_ptr), hl     ; save ptr to point under the cursor 
0f0a 7a					ld a,d 
0f0b 32 69 fe			        ld (input_size), a       ; save length of input area 
0f0e 79					ld a, c 
0f0f 32 58 fe				ld (input_cursor),a      ; init cursor start position  
0f12 7b					ld a,e 
0f13 32 68 fe			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0f16					 
0f16					 
0f16			 
0f16			;		ld a,(input_ptr) 
0f16			;		ld (input_under_cursor),a 	; save what is under the cursor 
0f16			 
0f16			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0f16					; init cursor shape if not set by the cin routines 
0f16 21 c7 fb				ld hl, cursor_shape 
0f19 3e ff				ld a, 255 
0f1b 77					ld (hl), a 
0f1c 23					inc hl 
0f1d 3e 00				ld a, 0 
0f1f 77					ld (hl), a 
0f20			 
0f20 3e 0f				ld a, CUR_BLINK_RATE 
0f22 32 63 fe				ld (input_cur_flash), a 
0f25 3e 01				ld a, 1 
0f27 32 62 fe				ld (input_cur_onoff),a 
0f2a			 
0f2a			;	if DEBUG_INPUT 
0f2a			;		push af 
0f2a			;		ld a, 'I' 
0f2a			;		ld (debug_mark),a 
0f2a			;		pop af 
0f2a			;		CALLMONITOR 
0f2a			;	endif 
0f2a			.is1:		; main entry loop 
0f2a			 
0f2a			 
0f2a			 
0f2a					; pause 1ms 
0f2a			 
0f2a 3e 01				ld a, 1 
0f2c cd fa 0b				call aDelayInMS 
0f2f			 
0f2f					; dec flash counter 
0f2f 3a 63 fe				ld a, (input_cur_flash) 
0f32 3d					dec a 
0f33 32 63 fe				ld (input_cur_flash), a 
0f36 fe 00				cp 0 
0f38 20 0d				jr nz, .nochgstate 
0f3a			 
0f3a			 
0f3a					; change state 
0f3a 3a 62 fe				ld a,(input_cur_onoff) 
0f3d ed 44				neg 
0f3f 32 62 fe				ld (input_cur_onoff),a 
0f42			 
0f42			 
0f42					; reset on change of state 
0f42 3e 0f				ld a, CUR_BLINK_RATE 
0f44 32 63 fe				ld (input_cur_flash), a 
0f47			 
0f47			.nochgstate: 
0f47					 
0f47					 
0f47			 
0f47					; display cursor  
0f47			 
0f47			;		ld hl, (input_start) 
0f47			;		ld a, (input_cursor) 
0f47			;		call addatohl 
0f47			 
0f47					; get char under cursor and replace with cursor 
0f47 2a 6c fe		ld hl, (input_ptr) 
0f4a			;		ld a, (hl) 
0f4a			;		ld (input_under_cursor),a 
0f4a			;		ld a, '_' 
0f4a			;		ld (hl), a 
0f4a			 
0f4a					; display string 
0f4a			 
0f4a ed 5b 6a fe			ld de, (input_start) 
0f4e 3a 67 fe				ld a, (input_at_pos) 
0f51 cd ab 0c				call str_at_display 
0f54			;	        call update_display 
0f54			 
0f54					; find place to put the cursor 
0f54			;		add h 
0f54			;		ld l, display_row_1 
0f54			;		sub l 
0f54			; (input_at_pos) 
0f54					;ld c, a 
0f54			;		ld a, (input_cursor) 
0f54			;		ld l, (input_at_pos) 
0f54			;		;ld b, h 
0f54			;		add l 
0f54			;		ld (input_at_cursor),a 
0f54					;ld l,h 
0f54			 
0f54			;		ld h, 0 
0f54			;		ld l,(input_at_pos) 
0f54			;		ld a, (input_cursor) 
0f54			;		call addatohl 
0f54			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0f54			;		call subafromhl 
0f54			;		ld a,l 
0f54			;		ld (input_at_cursor), a 
0f54			 
0f54				if DEBUG_INPUT 
0f54					ld a, (hardware_diag) 
0f54					cp 0 
0f54					jr z, .skip_input_diag 
0f54			 
0f54					ld a,(input_at_pos) 
0f54					ld hl, LFSRSeed 
0f54					call hexout 
0f54					ld a, (input_cursor) 
0f54					ld hl, LFSRSeed+2 
0f54					call hexout 
0f54					ld a,(input_at_cursor) 
0f54					ld hl, LFSRSeed+4 
0f54					call hexout 
0f54			 
0f54					ld a,(input_cur_onoff) 
0f54					ld hl, LFSRSeed+6 
0f54					call hexout 
0f54			 
0f54					ld a,(input_cur_flash) 
0f54					ld hl, LFSRSeed+8 
0f54					call hexout 
0f54			 
0f54					ld a,(input_len) 
0f54					ld hl, LFSRSeed+10 
0f54					call hexout 
0f54					ld hl, LFSRSeed+12 
0f54					ld a, 0 
0f54					ld (hl),a 
0f54					ld a, display_row_4 
0f54					ld de, LFSRSeed 
0f54					call str_at_display 
0f54					.skip_input_diag: 
0f54				endif 
0f54			 
0f54					; decide on if we are showing the cursor this time round 
0f54			 
0f54 3a 62 fe				ld a, (input_cur_onoff) 
0f57 fe ff				cp 255 
0f59 28 13				jr z, .skipcur 
0f5b			 
0f5b			 
0f5b 3a 65 fe				ld a,(input_at_cursor) 
0f5e 11 c7 fb				ld de, cursor_shape 
0f61 cd ab 0c				call str_at_display 
0f64			 
0f64					; save length of current input string 
0f64 2a 6a fe				ld hl, (input_start) 
0f67 cd 2a 13				call strlenz 
0f6a 7d					ld a,l 
0f6b 32 5d fe				ld (input_len),a 
0f6e			 
0f6e			.skipcur: 
0f6e			 
0f6e cd bb 0c			        call update_display 
0f71					 
0f71			 
0f71			 
0f71					; wait 
0f71				 
0f71					; TODO loop without wait to flash the cursor and char under cursor	 
0f71 cd d9 6c				call cin    ; _wait 
0f74			 
0f74 fe 00				cp 0 
0f76 ca 2a 0f				jp z, .is1 
0f79			 
0f79					; get ptr to char to input into 
0f79			 
0f79 4f					ld c,a 
0f7a 2a 6a fe				ld hl, (input_start) 
0f7d 3a 58 fe				ld a, (input_cursor) 
0f80 cd cc 0e				call addatohl 
0f83 22 6c fe				ld (input_ptr), hl 
0f86 79					ld a,c 
0f87			 
0f87					; replace char under cursor 
0f87			 
0f87			;		ld hl, (input_ptr) 
0f87			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0f87			;		ld (hl), a 
0f87			 
0f87			;	if DEBUG_INPUT 
0f87			;		push af 
0f87			;		ld a, 'i' 
0f87			;		ld (debug_mark),a 
0f87			;		pop af 
0f87			;		CALLMONITOR 
0f87			;	endif 
0f87 fe 0e				cp KEY_HOME 
0f89 20 0e				jr nz, .iske 
0f8b			 
0f8b 3a 67 fe				ld a, (input_at_pos) 
0f8e 32 65 fe				ld (input_at_cursor),a 
0f91 3e 00				ld a, 0 
0f93 32 58 fe				ld (input_cursor), a 
0f96 c3 2a 0f				jp .is1 
0f99					 
0f99 fe 0f		.iske:		cp KEY_END 
0f9b 20 03				jr nz, .isknw 
0f9d c3 2a 0f				jp .is1 
0fa0			 
0fa0 fe 06		.isknw:		cp KEY_NEXTWORD 
0fa2 20 1b				jr nz, .iskpw 
0fa4			 
0fa4 2a 6c fe		.isknwm:	ld hl, (input_ptr) 
0fa7 7e					ld a,(hl)	 
0fa8 fe 00				cp 0 
0faa ca 2a 0f				jp z, .is1    ; end of string 
0fad fe 20				cp ' ' 
0faf ca 2a 0f				jp z, .is1    ; end of word 
0fb2 23					inc hl 
0fb3 22 6c fe				ld (input_ptr), hl 
0fb6 3a 65 fe				ld a, (input_at_cursor) 
0fb9 3c					inc a 
0fba 32 65 fe				ld (input_at_cursor), a 
0fbd 18 e5				jr .isknwm 
0fbf			 
0fbf fe 07		.iskpw:		cp KEY_PREVWORD 
0fc1 20 1b				jr nz, .iskl 
0fc3			.iskpwm:	 
0fc3 2a 6c fe				ld hl, (input_ptr) 
0fc6 7e					ld a,(hl)	 
0fc7 fe 00				cp 0  
0fc9 ca 2a 0f				jp z, .is1    ; end of string 
0fcc fe 20				cp ' ' 
0fce ca 2a 0f				jp z, .is1    ; end of word 
0fd1 2b					dec hl 
0fd2 22 6c fe				ld (input_ptr), hl 
0fd5 3a 65 fe				ld a, (input_at_cursor) 
0fd8 3d					dec a 
0fd9 32 65 fe				ld (input_at_cursor), a 
0fdc 18 e5				jr .iskpwm 
0fde			 
0fde			 
0fde fe 0b		.iskl:		cp KEY_LEFT 
0fe0 20 27				jr nz, .isk1 
0fe2			 
0fe2 3a 58 fe				ld a, (input_cursor) 
0fe5			 
0fe5 fe 00				cp 0 
0fe7 ca 2a 0f				jp z, .is1 		; at start of line to ignore  
0fea			 
0fea 3d					dec  a 		; TODO check underflow 
0feb 32 58 fe				ld (input_cursor), a 
0fee			 
0fee 2a 6c fe				ld hl, (input_ptr) 
0ff1 2b					dec hl 
0ff2 22 6c fe				ld (input_ptr), hl 
0ff5					 
0ff5 3a 65 fe				ld a, (input_at_cursor) 
0ff8 3d					dec a 
0ff9 32 65 fe				ld (input_at_cursor), a 
0ffc			 
0ffc 3e 01				ld a, 1		; show cursor moving 
0ffe 32 62 fe				ld (input_cur_onoff),a 
1001 3e 0f				ld a, CUR_BLINK_RATE 
1003 32 63 fe				ld (input_cur_flash), a 
1006			 
1006 c3 2a 0f				jp .is1 
1009			 
1009 fe 0c		.isk1:		cp KEY_RIGHT 
100b 20 2a				jr nz, .isk2 
100d			 
100d 3a 5d fe				ld a,(input_len)		; TODO BUG why cant i load e direct? 
1010 5f					ld e,a 
1011 3a 58 fe				ld a, (input_cursor) 
1014 bb					cp e 
1015 ca 2a 0f				jp z, .is1		; at the end of string so dont go right 
1018			 
1018 3c					inc  a 		; TODO check overflow 
1019 32 58 fe				ld (input_cursor), a 
101c			 
101c 3a 65 fe				ld a, (input_at_cursor) 
101f 3c					inc a 
1020 32 65 fe				ld (input_at_cursor), a 
1023			 
1023 2a 6c fe				ld hl, (input_ptr) 
1026 23					inc hl 
1027 22 6c fe				ld (input_ptr), hl 
102a			 
102a 3e 01				ld a, 1		; show cursor moving 
102c 32 62 fe				ld (input_cur_onoff),a 
102f 3e 0f				ld a, CUR_BLINK_RATE 
1031 32 63 fe				ld (input_cur_flash), a 
1034			 
1034 c3 2a 0f				jp .is1 
1037			 
1037 fe 05		.isk2:		cp KEY_UP 
1039			 
1039 20 26				jr nz, .isk3 
103b			 
103b					; swap last command with the current on 
103b			 
103b					; move cursor to start of string 
103b 2a 6a fe				ld hl, (input_start) 
103e 22 6c fe				ld (input_ptr), hl 
1041			 
1041 3a 67 fe				ld a, (input_at_pos) 
1044 32 65 fe				ld (input_at_cursor), a 
1047			 
1047 3e 00				ld a, 0 
1049 32 58 fe				ld (input_cursor), a 
104c					 
104c					; swap input and last command buffers 
104c			 
104c 21 26 f5				ld hl, os_cli_cmd 
104f 11 25 f6				ld de, os_last_cmd 
1052 06 ff				ld b, 255 
1054 7e			.swap1:		ld a, (hl) 
1055 4f					ld c,a 
1056 1a					ld a, (de) 
1057 77					ld (hl), a 
1058 79					ld a,c 
1059 12					ld (de),a 
105a 23					inc hl 
105b 13					inc de 
105c 10 f6				djnz .swap1 
105e			 
105e			 
105e			 
105e			 
105e			 
105e c3 2a 0f				jp .is1 
1061			 
1061 fe 08		.isk3:		cp KEY_BS 
1063 20 3c				jr nz, .isk4 
1065			 
1065 3a 58 fe				ld a, (input_cursor) 
1068			 
1068 fe 00				cp 0 
106a ca 2a 0f				jp z, .is1 		; at start of line to ignore  
106d			 
106d 3d					dec  a 		; TODO check underflow 
106e 32 58 fe				ld (input_cursor), a 
1071			 
1071					; hl is source 
1071					; de needs to be source - 1 
1071			 
1071			;		ld a, 0 
1071			;		dec hl 
1071			;		ld (hl), a 
1071			 
1071 2a 6c fe				ld hl, (input_ptr) 
1074 2b					dec hl 
1075 22 6c fe				ld (input_ptr), hl 
1078			 
1078					; shift all data 
1078			 
1078 e5					push hl 
1079 23					inc hl 
107a d1					pop de 
107b 3a 5d fe				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
107e 4f					ld c,a 
107f 06 00				ld b,0 
1081 ed b0				ldir  
1083			 
1083			 
1083			 
1083			 
1083 3a 65 fe				ld a, (input_at_cursor) 
1086 3d					dec a 
1087 32 65 fe				ld (input_at_cursor), a 
108a			 
108a			 
108a 3e 01				ld a, 1		; show cursor moving 
108c 32 62 fe				ld (input_cur_onoff),a 
108f 3e 0f				ld a, CUR_BLINK_RATE 
1091 32 63 fe				ld (input_cur_flash), a 
1094			 
1094					; remove char 
1094 3a 65 fe				ld a, (input_at_cursor) 
1097 3c					inc a 
1098 11 22 11				ld de,.iblank 
109b cd ab 0c				call str_at_display 
109e			 
109e c3 2a 0f				jp .is1 
10a1			 
10a1 fe 0d		.isk4:		cp KEY_CR 
10a3 28 6c				jr z, .endinput 
10a5			 
10a5					; else add the key press to the end 
10a5			 
10a5 4f					ld c, a			; save key pressed 
10a6			 
10a6 7e					ld a,(hl)		; get what is currently under char 
10a7			 
10a7 fe 00				cp 0			; we are at the end of the string 
10a9 20 2f				jr nz, .onchar 
10ab					 
10ab					; add a char to the end of the string 
10ab				 
10ab 71					ld (hl),c 
10ac 23					inc hl 
10ad			;		ld a,' ' 
10ad			;		ld (hl),a 
10ad			;		inc hl 
10ad 3e 00				ld a,0 
10af 77					ld (hl),a 
10b0 2b					dec hl 
10b1			 
10b1 3a 58 fe				ld a, (input_cursor) 
10b4 3c					inc a				; TODO check max string length and scroll  
10b5 32 58 fe				ld (input_cursor), a		; inc cursor pos 
10b8							 
10b8 3a 65 fe				ld a, (input_at_cursor) 
10bb 3c					inc a 
10bc 32 65 fe				ld (input_at_cursor), a 
10bf			 
10bf 2a 6c fe				ld hl, (input_ptr) 
10c2 23					inc hl 
10c3 22 6c fe				ld (input_ptr), hl 
10c6			 
10c6 2a 6c fe				ld hl, (input_ptr) 
10c9 23					inc hl 
10ca 22 6c fe				ld (input_ptr), hl 
10cd			;	if DEBUG_INPUT 
10cd			;		push af 
10cd			;		ld a, '+' 
10cd			;		ld (debug_mark),a 
10cd			;		pop af 
10cd			;		CALLMONITOR 
10cd			;	endif 
10cd 3e 01				ld a, 1		; show cursor moving 
10cf 32 62 fe				ld (input_cur_onoff),a 
10d2 3e 0f				ld a, CUR_BLINK_RATE 
10d4 32 63 fe				ld (input_cur_flash), a 
10d7 c3 2a 0f				jp .is1 
10da					 
10da			 
10da			 
10da					; if on a char then insert 
10da			.onchar: 
10da			 
10da					; TODO over flow check: make sure insert does not blow out buffer 
10da			 
10da					; need to do some maths to use lddr 
10da			 
10da e5					push hl   ; save char pos 
10db c5					push bc 
10dc			 
10dc 2a 6a fe				ld hl, (input_start) 
10df 3a 5d fe				ld a, (input_len) 
10e2 cd cc 0e				call addatohl  		; end of string 
10e5 23					inc hl 
10e6 23					inc hl		; past zero term 
10e7 e5					push hl 
10e8 23					inc hl 
10e9 e5					push hl  
10ea			 
10ea								; start and end of lddr set, now how much to move? 
10ea			 
10ea							 
10ea 3a 58 fe				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
10ed 47					ld b,a 
10ee 3a 5d fe				ld a,(input_len) 
10f1 5f					ld e,a 
10f2 90					sub b 
10f3 3c					inc a		;?? 
10f4 3c					inc a		;?? 
10f5 3c					inc a		;?? 
10f6			 
10f6 06 00				ld b,0 
10f8 4f					ld c,a 
10f9			 
10f9				if DEBUG_INPUT 
10f9					push af 
10f9					ld a, 'i' 
10f9					ld (debug_mark),a 
10f9					pop af 
10f9			;		CALLMONITOR 
10f9				endif 
10f9 d1					pop de 
10fa e1					pop hl 
10fb				if DEBUG_INPUT 
10fb					push af 
10fb					ld a, 'I' 
10fb					ld (debug_mark),a 
10fb					pop af 
10fb			;		CALLMONITOR 
10fb				endif 
10fb ed b8				lddr 
10fd				 
10fd			 
10fd			 
10fd					; TODO have a key for insert/overwrite mode???? 
10fd c1					pop bc 
10fe e1					pop hl 
10ff 71					ld (hl), c		; otherwise overwrite current char 
1100					 
1100			 
1100			 
1100			 
1100 3a 58 fe				ld a, (input_cursor) 
1103 3c					inc  a 		; TODO check overflow 
1104 32 58 fe				ld (input_cursor), a 
1107			 
1107 3a 65 fe				ld a, (input_at_cursor) 
110a 3c					inc a 
110b 32 65 fe				ld (input_at_cursor), a 
110e			 
110e c3 2a 0f				jp .is1 
1111			 
1111			.endinput:	; TODO look for end of string 
1111			 
1111					; add trailing space for end of token 
1111			 
1111 2a 6a fe				ld hl, (input_start) 
1114 3a 5d fe				ld a,(input_len) 
1117 cd cc 0e				call addatohl 
111a 3e 20				ld a, ' ' 
111c 77					ld (hl),a 
111d					; TODO eof of parse marker 
111d			 
111d 23					inc hl 
111e 3e 00				ld a, 0 
1120 77					ld (hl),a 
1121			 
1121			 
1121 c9					ret 
1122			 
1122 .. 00		.iblank: db " ",0 
1124			 
1124			 
1124 32 67 fe		input_str_prev:	ld (input_at_pos), a 
1127 22 6a fe				ld (input_start), hl 
112a 3e 01				ld a,1			; add cursor 
112c 77					ld (hl),a 
112d 23					inc hl 
112e 3e 00				ld a,0 
1130 77					ld (hl),a 
1131 22 6c fe				ld (input_ptr), hl 
1134 7a					ld a,d 
1135 32 69 fe				ld (input_size), a 
1138 3e 00				ld a,0 
113a 32 58 fe				ld (input_cursor),a 
113d			.instr1:	 
113d			 
113d					; TODO do block cursor 
113d					; TODO switch cursor depending on the modifer key 
113d			 
113d					; update cursor shape change on key hold 
113d			 
113d 2a 6c fe				ld hl, (input_ptr) 
1140 2b					dec hl 
1141 3a c7 fb				ld a,(cursor_shape) 
1144 77					ld (hl), a 
1145			 
1145					; display entered text 
1145 3a 67 fe				ld a,(input_at_pos) 
1148 cd 9d 6a		            	CALL fLCD_Pos       ;Position cursor to location in A 
114b ed 5b 6a fe	            	LD   de, (input_start) 
114f cd bf 6a		            	CALL fLCD_Str       ;Display string pointed to by DE 
1152			 
1152 cd d9 6c				call cin 
1155 fe 00				cp 0 
1157 28 e4				jr z, .instr1 
1159			 
1159					; proecess keyboard controls first 
1159			 
1159 2a 6c fe				ld hl,(input_ptr) 
115c			 
115c fe 0d				cp KEY_CR	 ; pressing enter ends input 
115e 28 5a				jr z, .instrcr 
1160			 
1160 fe 08				cp KEY_BS 	; back space 
1162 20 0f				jr nz, .instr2 
1164					; process back space 
1164			 
1164					; TODO stop back space if at start of string 
1164 2b					dec hl 
1165 2b					dec hl ; to over write cursor 
1166 3a c7 fb				ld a,(cursor_shape) 
1169					;ld a,0 
1169 77					ld (hl),a 
116a 23					inc hl 
116b 3e 20				ld a," " 
116d 77					ld (hl),a 
116e 22 6c fe				ld (input_ptr),hl 
1171					 
1171			 
1171 18 ca				jr .instr1 
1173			 
1173 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
1175 20 06				jr nz, .instr3 
1177 2b					dec hl 
1178 22 6c fe				ld (input_ptr),hl 
117b 18 c0				jr .instr1 
117d				 
117d fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
117f 20 06				jr nz, .instr4 
1181 23					inc hl 
1182 22 6c fe				ld (input_ptr),hl 
1185 18 b6				jr .instr1 
1187			 
1187 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
1189 20 06				jr nz, .instr5 
118b 2b					dec hl 
118c 22 6c fe				ld (input_ptr),hl 
118f 18 ac				jr .instr1 
1191			 
1191 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
1193 20 06				jr nz, .instr6 
1195 2b					dec hl 
1196 22 6c fe				ld (input_ptr),hl 
1199 18 a2				jr .instr1 
119b fe 05		.instr6:        cp KEY_UP      ; recall last command 
119d 20 0b				jr nz, .instrnew 
119f			 
119f 21 ff f1			ld hl, scratch 
11a2 11 25 f6			ld de, os_last_cmd 
11a5 cd c3 11			call strcpy 
11a8 18 93				jr .instr1 
11aa			 
11aa			 
11aa			.instrnew:	; no special key pressed to see if we have room to store it 
11aa			 
11aa					; TODO do string size test 
11aa			 
11aa 2b					dec hl ; to over write cursor 
11ab 77					ld (hl),a 
11ac 23					inc hl 
11ad 3a c7 fb				ld a,(cursor_shape) 
11b0 77					ld (hl),a 
11b1 23					inc hl 
11b2 3e 00				ld a,0 
11b4 77					ld (hl),a 
11b5			 
11b5 22 6c fe				ld (input_ptr),hl 
11b8					 
11b8 18 83				jr .instr1 
11ba 2b			.instrcr:	dec hl		; remove cursor 
11bb 3e 20				ld a,' '	; TODO add a trailing space for safety 
11bd 77					ld (hl),a 
11be 23					inc hl 
11bf 3e 00				ld a,0 
11c1 77					ld (hl),a 
11c2			 
11c2			 
11c2					; if at end of line scroll up    
11c2					; TODO detecting only end of line 4 for scroll up  
11c2			 
11c2					;ld   
11c2			 
11c2 c9					ret 
11c3			 
11c3			 
11c3			; strcpy hl = dest, de source 
11c3			 
11c3 1a			strcpy:   LD   A, (DE)        ;Get character from string 
11c4 b7			            OR   A              ;Null terminator? 
11c5 c8			            RET  Z              ;Yes, so finished 
11c6 1a					ld a,(de) 
11c7 77					ld (hl),a 
11c8 13			            INC  DE             ;Point to next character 
11c9 23					inc hl 
11ca 18 f7		            JR   strcpy       ;Repeat 
11cc c9					ret 
11cd			 
11cd			 
11cd			; TODO string_at  
11cd			; pass string which starts with lcd offset address and then null term string 
11cd			 
11cd			; TODO string to dec 
11cd			; TODO string to hex 
11cd			; TODO byte to string hex 
11cd			; TODO byte to string dec 
11cd			 
11cd			 
11cd			 
11cd			; from z80uartmonitor 
11cd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11cd			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
11cd			; pass hl for where to put the text 
11cd			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11cd c5			hexout:	PUSH BC 
11ce f5					PUSH AF 
11cf 47					LD B, A 
11d0					; Upper nybble 
11d0 cb 3f				SRL A 
11d2 cb 3f				SRL A 
11d4 cb 3f				SRL A 
11d6 cb 3f				SRL A 
11d8 cd e8 11				CALL tohex 
11db 77					ld (hl),a 
11dc 23					inc hl	 
11dd					 
11dd					; Lower nybble 
11dd 78					LD A, B 
11de e6 0f				AND 0FH 
11e0 cd e8 11				CALL tohex 
11e3 77					ld (hl),a 
11e4 23					inc hl	 
11e5					 
11e5 f1					POP AF 
11e6 c1					POP BC 
11e7 c9					RET 
11e8					 
11e8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e8			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
11e8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e8			tohex: 
11e8 e5					PUSH HL 
11e9 d5					PUSH DE 
11ea 16 00				LD D, 0 
11ec 5f					LD E, A 
11ed 21 f5 11				LD HL, .DATA 
11f0 19					ADD HL, DE 
11f1 7e					LD A, (HL) 
11f2 d1					POP DE 
11f3 e1					POP HL 
11f4 c9					RET 
11f5			 
11f5			.DATA: 
11f5 30					DEFB	30h	; 0 
11f6 31					DEFB	31h	; 1 
11f7 32					DEFB	32h	; 2 
11f8 33					DEFB	33h	; 3 
11f9 34					DEFB	34h	; 4 
11fa 35					DEFB	35h	; 5 
11fb 36					DEFB	36h	; 6 
11fc 37					DEFB	37h	; 7 
11fd 38					DEFB	38h	; 8 
11fe 39					DEFB	39h	; 9 
11ff 41					DEFB	41h	; A 
1200 42					DEFB	42h	; B 
1201 43					DEFB	43h	; C 
1202 44					DEFB	44h	; D 
1203 45					DEFB	45h	; E 
1204 46					DEFB	46h	; F 
1205			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1205			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1205			;;    subtract $30, if result > 9 then subtract $7 more 
1205			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1205			atohex: 
1205 d6 30				SUB $30 
1207 fe 0a				CP 10 
1209 f8					RET M		; If result negative it was 0-9 so we're done 
120a d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
120c c9					RET		 
120d			 
120d			 
120d			 
120d			 
120d			; Get 2 ASCII characters as hex byte from pointer in hl 
120d			 
120d			BYTERD: 
120d 16 00			LD	D,00h		;Set up 
120f cd 17 12			CALL	HEXCON		;Get byte and convert to hex 
1212 87				ADD	A,A		;First nibble so 
1213 87				ADD	A,A		;multiply by 16 
1214 87				ADD	A,A		; 
1215 87				ADD	A,A		; 
1216 57				LD	D,A		;Save hi nibble in D 
1217			HEXCON: 
1217 7e				ld a, (hl)		;Get next chr 
1218 23				inc hl 
1219 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
121b fe 0a			CP	00Ah		;Is it 0-9 ? 
121d 38 02			JR	C,NALPHA	;If so miss next bit 
121f d6 07			SUB	007h		;Else convert alpha 
1221			NALPHA: 
1221 b2				OR	D		;Add hi nibble back 
1222 c9				RET			; 
1223			 
1223			 
1223			; 
1223			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1223			; Since the routines get_byte and therefore get_nibble are called, only valid 
1223			; characters (0-9a-f) are accepted. 
1223			; 
1223			;get_word        push    af 
1223			;                call    get_byte        ; Get the upper byte 
1223			;                ld      h, a 
1223			;                call    get_byte        ; Get the lower byte 
1223			;                ld      l, a 
1223			;                pop     af 
1223			;                ret 
1223			; 
1223			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1223			; the routine get_nibble is used only valid characters are accepted - the  
1223			; input routine only accepts characters 0-9a-f. 
1223			; 
1223 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1224 7e					ld a,(hl) 
1225 23					inc hl 
1226 cd 4b 12		                call    nibble2val      ; Get upper nibble 
1229 cb 07		                rlc     a 
122b cb 07		                rlc     a 
122d cb 07		                rlc     a 
122f cb 07		                rlc     a 
1231 47			                ld      b, a            ; Save upper four bits 
1232 7e					ld a,(hl) 
1233 cd 4b 12		                call    nibble2val      ; Get lower nibble 
1236 b0			                or      b               ; Combine both nibbles 
1237 c1			                pop     bc              ; Restore B (and C) 
1238 c9			                ret 
1239			; 
1239			; Get a hexadecimal digit from the serial line. This routine blocks until 
1239			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1239			; to the serial line interface. The lower 4 bits of A contain the value of  
1239			; that particular digit. 
1239			; 
1239			;get_nibble      ld a,(hl)           ; Read a character 
1239			;                call    to_upper        ; Convert to upper case 
1239			;                call    is_hex          ; Was it a hex digit? 
1239			;                jr      nc, get_nibble  ; No, get another character 
1239			 ;               call    nibble2val      ; Convert nibble to value 
1239			 ;               call    print_nibble 
1239			 ;               ret 
1239			; 
1239			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1239			; A valid hexadecimal digit is denoted by a set C flag. 
1239			; 
1239			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1239			;                ret     nc              ; Yes 
1239			;                cp      '0'             ; Less than '0'? 
1239			;                jr      nc, is_hex_1    ; No, continue 
1239			;                ccf                     ; Complement carry (i.e. clear it) 
1239			;                ret 
1239			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1239			;                ret     c               ; Yes 
1239			;                cp      'A'             ; Less than 'A'? 
1239			;                jr      nc, is_hex_2    ; No, continue 
1239			;                ccf                     ; Yes - clear carry and return 
1239			;                ret 
1239			;is_hex_2        scf                     ; Set carry 
1239			;                ret 
1239			; 
1239			; Convert a single character contained in A to upper case: 
1239			; 
1239 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
123b d8			                ret     c 
123c fe 7b		                cp      'z' + 1         ; > 'z'? 
123e d0			                ret     nc              ; Nothing to do, either 
123f e6 5f		                and     $5f             ; Convert to upper case 
1241 c9			                ret 
1242			 
1242			 
1242			to_lower: 
1242			 
1242			   ; if char is in [A-Z] make it lower case 
1242			 
1242			   ; enter : a = char 
1242			   ; exit  : a = lower case char 
1242			   ; uses  : af 
1242			 
1242 fe 41		   cp 'A' 
1244 d8			   ret c 
1245			    
1245 fe 5b		   cp 'Z'+1 
1247 d0			   ret nc 
1248			    
1248 f6 20		   or $20 
124a c9			   ret 
124b			 
124b			; 
124b			; Expects a hexadecimal digit (upper case!) in A and returns the 
124b			; corresponding value in A. 
124b			; 
124b fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
124d 38 02		                jr      c, nibble2val_1 ; Yes 
124f d6 07		                sub     7               ; Adjust for A-F 
1251 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1253 e6 0f		                and     $f              ; Only return lower 4 bits 
1255 c9			                ret 
1256			; 
1256			; Print_nibble prints a single hex nibble which is contained in the lower  
1256			; four bits of A: 
1256			; 
1256			;print_nibble    push    af              ; We won't destroy the contents of A 
1256			;                and     $f              ; Just in case... 
1256			;                add     a, '0'             ; If we have a digit we are done here. 
1256			;                cp      '9' + 1         ; Is the result > 9? 
1256			;                jr      c, print_nibble_1 
1256			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1256			;print_nibble_1  call    putc            ; Print the nibble and 
1256			;                pop     af              ; restore the original value of A 
1256			;                ret 
1256			;; 
1256			;; Send a CR/LF pair: 
1256			; 
1256			;crlf            push    af 
1256			;                ld      a, cr 
1256			;                call    putc 
1256			;                ld      a, lf 
1256			;                call    putc 
1256			;                pop     af 
1256			;                ret 
1256			; 
1256			; Print_word prints the four hex digits of a word to the serial line. The  
1256			; word is expected to be in HL. 
1256			; 
1256			;print_word      push    hl 
1256			;                push    af 
1256			;                ld      a, h 
1256			;                call    print_byte 
1256			;                ld      a, l 
1256			;                call    print_byte 
1256			;                pop     af 
1256			;                pop     hl 
1256			;                ret 
1256			; 
1256			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1256			; The byte to be printed is expected to be in A. 
1256			; 
1256			;print_byte      push    af              ; Save the contents of the registers 
1256			;                push    bc 
1256			;                ld      b, a 
1256			;                rrca 
1256			;                rrca 
1256			;                rrca 
1256			;                rrca 
1256			;                call    print_nibble    ; Print high nibble 
1256			;                ld      a, b 
1256			;                call    print_nibble    ; Print low nibble 
1256			;                pop     bc              ; Restore original register contents 
1256			;                pop     af 
1256			;                ret 
1256			 
1256			 
1256			 
1256			 
1256			 
1256			fourehexhl:  
1256 7e				ld a,(hl) 
1257 cd 05 12			call atohex 
125a cb 3f				SRL A 
125c cb 3f				SRL A 
125e cb 3f				SRL A 
1260 cb 3f				SRL A 
1262 47				ld b, a 
1263 23				inc hl 
1264 7e				ld a,(hl) 
1265 23				inc hl 
1266 cd 05 12			call atohex 
1269 80				add b 
126a 57				ld d,a 
126b 7e				ld a,(hl) 
126c cd 05 12			call atohex 
126f cb 3f				SRL A 
1271 cb 3f				SRL A 
1273 cb 3f				SRL A 
1275 cb 3f				SRL A 
1277 47				ld b, a 
1278 23				inc hl 
1279 7e				ld a,(hl) 
127a 23				inc hl 
127b cd 05 12			call atohex 
127e 80				add b 
127f 5f				ld e, a 
1280 d5				push de 
1281 e1				pop hl 
1282 c9				ret 
1283			 
1283			; pass hl. returns z set if the byte at hl is a digit 
1283			;isdigithl:  
1283			;	push bc 
1283			;	ld a,(hl) 
1283			;	cp ':' 
1283			;	jr nc, .isdf 		; > 
1283			;	cp '0' 
1283			;	jr c, .isdf		; < 
1283			; 
1283			;	; TODO find a better way to set z 
1283			; 
1283			;	ld b,a 
1283			;	cp b 
1283			;	pop bc 
1283			;	ret 
1283			; 
1283			;.isdf:	; not digit so clear z 
1283			; 
1283			;	; TODO find a better way to unset z 
1283			; 
1283			;	ld b,a 
1283			;	inc b 
1283			;	cp b 
1283			; 
1283			;	pop bc 
1283			;	ret 
1283				 
1283				 
1283			 
1283			 
1283			; pass hl as the four byte address to load 
1283			 
1283			get_word_hl:  
1283 e5				push hl 
1284 cd 23 12			call get_byte 
1287				 
1287 47				ld b, a 
1288			 
1288 e1				pop hl 
1289 23				inc hl 
128a 23				inc hl 
128b			 
128b			; TODO not able to handle a-f  
128b 7e				ld a,(hl) 
128c			;	;cp ':' 
128c			;	cp 'g' 
128c			;	jr nc, .single_byte_hl 		; > 
128c			;	cp 'G' 
128c			;	jr nc, .single_byte_hl 		; > 
128c			;	cp '0' 
128c			;	jr c, .single_byte_hl		; < 
128c			 
128c				;call isdigithl 
128c fe 00			cp 0 
128e 28 06			jr z, .single_byte_hl 
1290			 
1290			.getwhln:   ; hex word so get next byte 
1290			 
1290 cd 23 12			call get_byte 
1293 6f				ld l, a 
1294 60				ld h,b 
1295 c9				ret 
1296 68			.single_byte_hl:   ld l,b 
1297 26 00				ld h,0 
1299 c9					ret 
129a			 
129a			 
129a			 
129a			 
129a 21 fe 1b			ld hl,asc+1 
129d			;	ld a, (hl) 
129d			;	call nibble2val 
129d cd 23 12			call get_byte 
12a0			 
12a0			;	call fourehexhl 
12a0 32 33 f2			ld (scratch+52),a 
12a3				 
12a3 21 31 f2			ld hl,scratch+50 
12a6 22 22 f5			ld (os_cur_ptr),hl 
12a9			 
12a9 c9				ret 
12aa			 
12aa			 
12aa			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
12aa			 
12aa			; Decimal Unsigned Version 
12aa			 
12aa			;Number in a to decimal ASCII 
12aa			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
12aa			;Example: display a=56 as "056" 
12aa			;input: a = number 
12aa			;Output: a=0,value of a in the screen 
12aa			;destroys af,bc (don't know about hl and de) 
12aa			DispAToASCII: 
12aa 0e 9c			ld	c,-100 
12ac cd b6 12			call	.Na1 
12af 0e f6			ld	c,-10 
12b1 cd b6 12			call	.Na1 
12b4 0e ff			ld	c,-1 
12b6 06 2f		.Na1:	ld	b,'0'-1 
12b8 04			.Na2:	inc	b 
12b9 81				add	a,c 
12ba 38 fc			jr	c,.Na2 
12bc 91				sub	c		;works as add 100/10/1 
12bd f5				push af		;safer than ld c,a 
12be 78				ld	a,b		;char is in b 
12bf			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
12bf f1				pop af		;safer than ld a,c 
12c0 c9				ret 
12c1			 
12c1			; Decimal Signed Version 
12c1			 
12c1			; DispA 
12c1			; -------------------------------------------------------------- 
12c1			; Converts a signed integer value to a zero-terminated ASCII 
12c1			; string representative of that value (using radix 10). 
12c1			; -------------------------------------------------------------- 
12c1			; INPUTS: 
12c1			;     HL     Value to convert (two's complement integer). 
12c1			;     DE     Base address of string destination. (pointer). 
12c1			; -------------------------------------------------------------- 
12c1			; OUTPUTS: 
12c1			;     None 
12c1			; -------------------------------------------------------------- 
12c1			; REGISTERS/MEMORY DESTROYED 
12c1			; AF HL 
12c1			; -------------------------------------------------------------- 
12c1			 
12c1			;DispHLToASCII: 
12c1			;   push    de 
12c1			;   push    bc 
12c1			; 
12c1			;; Detect sign of HL. 
12c1			;    bit    7, h 
12c1			;    jr     z, ._DoConvert 
12c1			; 
12c1			;; HL is negative. Output '-' to string and negate HL. 
12c1			;    ld     a, '-' 
12c1			;    ld     (de), a 
12c1			;    inc    de 
12c1			; 
12c1			;; Negate HL (using two's complement) 
12c1			;    xor    a 
12c1			;    sub    l 
12c1			;    ld     l, a 
12c1			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
12c1			;    sbc    a, h 
12c1			;    ld     h, a 
12c1			; 
12c1			;; Convert HL to digit characters 
12c1			;._DoConvert: 
12c1			;    ld     b, 0     ; B will count character length of number 
12c1			;-   ld     a, 10 
12c1			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
12c1			;    push   af 
12c1			;    inc    b 
12c1			;    ld     a, h 
12c1			;    or     l 
12c1			;    jr     nz, - 
12c1			; 
12c1			;; Retrieve digits from stack 
12c1			;-   pop    af 
12c1			;    or     $30 
12c1			;    ld     (de), a 
12c1			;    inc    de 
12c1			;    djnz   - 
12c1			; 
12c1			;; Terminate string with NULL 
12c1			;    xor    a 
12c1			;    ld     (de), a 
12c1			; 
12c1			;    pop    bc 
12c1			;    pop    de 
12c1			;    ret 
12c1			 
12c1			;Comments 
12c1			; 
12c1			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
12c1			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
12c1			;    Note that the output string will not be fixed-width. 
12c1			; 
12c1			;Example Usage 
12c1			; 
12c1			;    ld    hl, -1004 
12c1			;    ld    de, OP1 
12c1			;    call  DispA 
12c1			;    ld    hl, OP1 
12c1			;    syscall  PutS 
12c1			 
12c1			 
12c1			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12c1			 
12c1			 
12c1			;Converts an ASCII string to an unsigned 16-bit integer 
12c1			;Quits when it reaches a non-decimal digit 
12c1			 
12c1			string_to_uint16: 
12c1			atoui_16: 
12c1			;Input: 
12c1			;     DE points to the string 
12c1			;Outputs: 
12c1			;     HL is the result 
12c1			;     A is the 8-bit value of the number 
12c1			;     DE points to the byte after the number 
12c1			;Destroys: 
12c1			;     BC 
12c1			;       if the string is non-empty, BC is HL/10 
12c1			;Size:  24 bytes 
12c1			;Speed: 42+d(104+{0,9}) 
12c1			;       d is the number of digits in the number 
12c1			;       max is 640 cycles for a 5 digit number 
12c1			;Assuming no leading zeros: 
12c1			;1 digit:  146cc 
12c1			;2 digit:  250cc 
12c1			;3 digit:  354cc or 363cc (avg: 354.126cc) 
12c1			;4 digit:  458cc or 467cc (avg: 458.27cc) 
12c1			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
12c1			;avg: 544.81158447265625cc (544+13297/16384) 
12c1			;=============================================================== 
12c1 21 00 00		  ld hl,0 
12c4			.u16a: 
12c4 1a			  ld a,(de) 
12c5 d6 30		  sub 30h 
12c7 fe 0a		  cp 10 
12c9 d0			  ret nc 
12ca 13			  inc de 
12cb 44			  ld b,h 
12cc 4d			  ld c,l 
12cd 29			  add hl,hl 
12ce 29			  add hl,hl 
12cf 09			  add hl,bc 
12d0 29			  add hl,hl 
12d1 85			  add a,l 
12d2 6f			  ld l,a 
12d3 30 ef		  jr nc,.u16a 
12d5 24			  inc h 
12d6 c3 c4 12		  jp .u16a 
12d9			 
12d9			 
12d9			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12d9			 
12d9			;written by Zeda 
12d9			;Converts a 16-bit unsigned integer to an ASCII string. 
12d9			 
12d9			uitoa_16: 
12d9			;Input: 
12d9			;   DE is the number to convert 
12d9			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
12d9			;Output: 
12d9			;   HL points to the null-terminated ASCII string 
12d9			;      NOTE: This isn't necessarily the same as the input HL. 
12d9 d5			  push de 
12da c5			  push bc 
12db f5			  push af 
12dc eb			  ex de,hl 
12dd			 
12dd 01 f0 d8		  ld bc,-10000 
12e0 3e 2f		  ld a,'0'-1 
12e2 3c			  inc a 
12e3 09			  add hl,bc  
12e4 38 fc		   jr c,$-2 
12e6 12			  ld (de),a 
12e7 13			  inc de 
12e8			 
12e8 01 e8 03		  ld bc,1000 
12eb 3e 3a		  ld a,'9'+1 
12ed 3d			  dec a  
12ee 09			  add hl,bc  
12ef 30 fc		   jr nc,$-2 
12f1 12			  ld (de),a 
12f2 13			  inc de 
12f3			 
12f3 01 9c ff		  ld bc,-100 
12f6 3e 2f		  ld a,'0'-1 
12f8 3c			  inc a  
12f9 09			  add hl,bc  
12fa 38 fc		   jr c,$-2 
12fc 12			  ld (de),a 
12fd 13			  inc de 
12fe			 
12fe 7d			  ld a,l 
12ff 26 3a		  ld h,'9'+1 
1301 25			  dec h  
1302 c6 0a		  add a,10  
1304 30 fb		   jr nc,$-3 
1306 c6 30		  add a,'0' 
1308 eb			  ex de,hl 
1309 72			  ld (hl),d 
130a 23			  inc hl 
130b 77			  ld (hl),a 
130c 23			  inc hl 
130d 36 00		  ld (hl),0 
130f			 
130f			;Now strip the leading zeros 
130f 0e fa		  ld c,-6 
1311 09			  add hl,bc 
1312 3e 30		  ld a,'0' 
1314 23			  inc hl  
1315 be			  cp (hl)  
1316 28 fc		  jr z,$-2 
1318			 
1318			;Make sure that the string is non-empty! 
1318 7e			  ld a,(hl) 
1319 b7			  or a 
131a 20 01		  jr nz,.atoub 
131c 2b			  dec hl 
131d			.atoub: 
131d			 
131d f1			  pop af 
131e c1			  pop bc 
131f d1			  pop de 
1320 c9			  ret 
1321			 
1321			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1321			 
1321			toUpper: 
1321			;A is the char. 
1321			;If A is a lowercase letter, this sets it to the matching uppercase 
1321			;18cc or 30cc or 41cc 
1321			;avg: 26.75cc 
1321 fe 61		  cp 'a' 
1323 d8			  ret c 
1324 fe 7b		  cp 'z'+1 
1326 d0			  ret nc 
1327 d6 20		  sub 'a'-'A' 
1329 c9			  ret 
132a			 
132a			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
132a			 
132a			; String Length 
132a			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
132a			 
132a			; Get the length of the null-terminated string starting at $8000 hl 
132a			;    LD     HL, $8000 
132a			 
132a			strlenz: 
132a			 
132a af			    XOR    A               ; Zero is the value we are looking for. 
132b 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
132c 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
132d			                           ; 65, 536 bytes (the entire addressable memory space). 
132d ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
132f			 
132f			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
132f 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1330 6f			    LD     L, A             ; number of bytes 
1331 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1333 2b			    DEC    HL              ; Compensate for null. 
1334 c9				ret 
1335			 
1335			; Get the length of the A terminated string starting at $8000 hl 
1335			;    LD     HL, $8000 
1335			 
1335			strlent: 
1335			 
1335			                  ; A is the value we are looking for. 
1335 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1337 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1339			                           ; 65, 536 bytes (the entire addressable memory space). 
1339 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
133b			 
133b			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
133b 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
133d 2e 00		    LD     L, 0             ; number of bytes 
133f ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1341 2b			    DEC    HL              ; Compensate for null. 
1342 c9				ret 
1343			 
1343			 
1343			;Comparing Strings 
1343			 
1343			;IN    HL     Address of string1. 
1343			;      DE     Address of string2. 
1343			 
1343			; doc given but wrong??? 
1343			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1343			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1343			; tested 
1343			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1343			 
1343			strcmp_old: 
1343 e5			    PUSH   HL 
1344 d5			    PUSH   DE 
1345			 
1345 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1346 be			    CP     (HL)            ; (want to minimize work). 
1347 38 01		    JR     C, Str1IsBigger 
1349 7e			    LD     A, (HL) 
134a			 
134a			Str1IsBigger: 
134a 4f			    LD     C, A             ; Put length in BC 
134b 06 00		    LD     B, 0 
134d 13			    INC    DE              ; Increment pointers to meat of string. 
134e 23			    INC    HL 
134f			 
134f			CmpLoop: 
134f 1a			    LD     A, (DE)          ; Compare bytes. 
1350 ed a1		    CPI 
1352 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1354 13			    INC    DE              ; Update pointer. 
1355 ea 4f 13		    JP     PE, CmpLoop 
1358			 
1358 d1			    POP    DE 
1359 e1			    POP    HL 
135a 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
135b be			    CP     (HL) 
135c c9			    RET 
135d			 
135d			NoMatch: 
135d 2b			    DEC    HL 
135e be			    CP     (HL)            ; Compare again to affect carry. 
135f d1			    POP    DE 
1360 e1			    POP    HL 
1361 c9			    RET 
1362			 
1362			;; test strmp 
1362			; 
1362			;ld de, .str1 
1362			;ld hl, .str2 
1362			;call strcmp 
1362			;jr z, .z1 
1362			;;this 
1362			;	if DEBUG_FORTH_WORDS 
1362			;		DMARK "NZ1" 
1362			;		CALLMONITOR 
1362			;	endif 
1362			;.z1: 
1362			; 
1362			;	if DEBUG_FORTH_WORDS 
1362			;		DMARK "ZZ1" 
1362			;		CALLMONITOR 
1362			;	endif 
1362			; 
1362			;ld de, .str1 
1362			;ld hl, .str1 
1362			;call strcmp 
1362			;jr z, .z2 
1362			;;this 
1362			;	if DEBUG_FORTH_WORDS 
1362			;		DMARK "NZ2" 
1362			;		CALLMONITOR 
1362			;	endif 
1362			;.z2: 
1362			; 
1362			;	if DEBUG_FORTH_WORDS 
1362			;		DMARK "ZZ2" 
1362			;		CALLMONITOR 
1362			;	endif 
1362			; 
1362			;ld de, .str1 
1362			;ld hl, .str2 
1362			;call strcmp 
1362			;jr c, .c1 
1362			; 
1362			;	if DEBUG_FORTH_WORDS 
1362			;		DMARK "Nc1" 
1362			;		CALLMONITOR 
1362			;	endif 
1362			;.c1: 
1362			;;this 
1362			;	if DEBUG_FORTH_WORDS 
1362			;		DMARK "cc1" 
1362			;		CALLMONITOR 
1362			;	endif 
1362			; 
1362			;ld de, .str1 
1362			;ld hl, .str1 
1362			;call strcmp 
1362			;jr c, .c2 
1362			;;this 
1362			;	if DEBUG_FORTH_WORDS 
1362			;		DMARK "Nc2" 
1362			;		CALLMONITOR 
1362			;	endif 
1362			;.c2: 
1362			; 
1362			;	if DEBUG_FORTH_WORDS 
1362			;		DMARK "cc2" 
1362			;		CALLMONITOR 
1362			;	endif 
1362			;	NEXTW 
1362			;.str1:   db "string1",0 
1362			;.str2:   db "string2",0 
1362			 
1362			; only care about direct match or not 
1362			; hl and de strings 
1362			; zero set if the same 
1362			 
1362			strcmp: 
1362 1a				ld a, (de) 
1363 be				cp (hl) 
1364 28 02			jr z, .ssame 
1366 b7				or a 
1367 c9				ret 
1368			 
1368			.ssame:  
1368 fe 00			cp 0 
136a c8				ret z 
136b			 
136b 23				inc hl 
136c 13				inc de 
136d 18 f3			jr strcmp 
136f				 
136f				 
136f			 
136f			 
136f			 
136f			 
136f			; eof 
136f			 
136f			 
136f			 
136f			 
136f			 
136f			 
# End of file firmware_strings.asm
136f			include "firmware_memory.asm"   ; malloc and free  
136f			 
136f			if DEBUG_FORTH_MALLOC_HIGH 
136f			.mallocsize: db "Wants malloc >256",0 
136f			.mallocasize: db "MALLOC gives >256",0 
136f			.malloczero: db "MALLOC gives zero",0 
136f			 
136f			malloc_guard_zerolen: 
136f				push hl 
136f				push de 
136f				push af 
136f			 
136f				ld de, 0 
136f			        call cmp16 
136f				jr nz, .lowalloz 
136f			 
136f				push hl 
136f				push de 
136f					ld hl, display_fb0 
136f					ld (display_fb_active), hl 
136f				call clear_display 
136f				ld a, 0 
136f				ld de, .malloczero 
136f				call str_at_display 
136f				call update_display 
136f				call delay1s 
136f				call delay1s 
136f				ld a, 0 
136f				ld (os_view_disable), a 
136f			 
136f				pop de 
136f				pop hl 
136f			 
136f				 
136f			 
136f				CALLMONITOR 
136f			.lowalloz: 
136f			 
136f			 
136f				pop af 
136f				pop de 
136f				pop hl 
136f			ret 
136f			 
136f			malloc_guard_entry: 
136f				push hl 
136f				push de 
136f				push af 
136f			 
136f			 	or a      ;clear carry flag 
136f				push hl 
136f				ld de, 255 
136f				sbc hl, de 
136f				jr c, .lowalloc 
136f			 
136f				push de 
136f					ld hl, display_fb0 
136f					ld (display_fb_active), hl 
136f				call clear_display 
136f				ld a, 0 
136f				ld de, .mallocsize 
136f				call str_at_display 
136f				call update_display 
136f				call delay1s 
136f				call delay1s 
136f				ld a, 0 
136f				ld (os_view_disable), a 
136f			 
136f				pop de 
136f				pop hl 
136f			 
136f				 
136f			 
136f				CALLMONITOR 
136f				jr .lowdone 
136f			.lowalloc: 
136f			 
136f			 
136f				pop hl 
136f			.lowdone:	pop af 
136f				pop de 
136f				pop hl 
136f			ret 
136f			 
136f			malloc_guard_exit: 
136f				push hl 
136f				push de 
136f				push af 
136f			 
136f			 	or a      ;clear carry flag 
136f				push hl 
136f				ld de, 255 
136f				sbc hl, de 
136f				jr c, .lowallocx 
136f			 
136f				push de 
136f					ld hl, display_fb0 
136f					ld (display_fb_active), hl 
136f				call clear_display 
136f				ld a, 0 
136f				ld de, .mallocasize 
136f				call str_at_display 
136f				call update_display 
136f				call delay1s 
136f				call delay1s 
136f				ld a, 0 
136f				ld (os_view_disable), a 
136f				pop de 
136f				pop hl 
136f			 
136f				CALLMONITOR 
136f				jr .lowdonex 
136f			.lowallocx: 
136f			 
136f				pop hl 
136f			.lowdonex:	pop af 
136f				pop de 
136f				pop hl 
136f			ret 
136f			endif 
136f			 
136f			if MALLOC_2 
136f			; Z80 Malloc and Free Functions 
136f			 
136f			; Malloc Function: 
136f			; Input: 
136f			;   HL: Size of block to allocate 
136f			; Output: 
136f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
136f			 
136f			malloc: 
136f				 
136f			if DEBUG_FORTH_MALLOC_HIGH 
136f			call malloc_guard_entry 
136f			endif 
136f			 
136f			 
136f			 
136f			 
136f					if DEBUG_FORTH_MALLOC 
136f						DMARK "mal" 
136f						CALLMONITOR 
136f					endif 
136f			    push af            ; Save AF register 
136f			    ld a, l            ; Load low byte of size into A 
136f			    or h               ; Check if size is zero 
136f			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
136f			 
136f			    ; Allocate memory 
136f			    ld hl, (heap_start) ; Load start of heap into HL 
136f					if DEBUG_FORTH_MALLOC 
136f						DMARK "ma1" 
136f						CALLMONITOR 
136f					endif 
136f			    call malloc_internal ; Call internal malloc function 
136f			    pop af             ; Restore AF register 
136f			if DEBUG_FORTH_MALLOC_HIGH 
136f			call malloc_guard_exit 
136f			call malloc_guard_zerolen 
136f			endif 
136f			    ret                ; Return 
136f			 
136f			; Free Function: 
136f			; Input: 
136f			;   HL: Pointer to memory block to free 
136f			; Output: 
136f			;   None 
136f			 
136f			free: 
136f			    push af            ; Save AF register 
136f			    ld a, l            ; Load low byte of pointer into A 
136f			    or h               ; Check if pointer is NULL 
136f			    jp z, free_exit    ; If pointer is NULL, exit 
136f			 
136f			    ; Free memory 
136f			    ld hl, (heap_start) ; Load start of heap into HL 
136f			    call free_internal  ; Call internal free function 
136f			    pop af             ; Restore AF register 
136f			    ret                ; Return 
136f			 
136f			; Internal Malloc Function: 
136f			; Input: 
136f			;   HL: Size of block to allocate 
136f			; Output: 
136f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
136f			 
136f			malloc_internal: 
136f			    ld bc, 2           ; Number of bytes to allocate for management overhead 
136f			    add hl, bc         ; Add management overhead to requested size 
136f			    ex de, hl          ; Save total size in DE, and keep it in HL 
136f					if DEBUG_FORTH_MALLOC 
136f						DMARK "ma2" 
136f						CALLMONITOR 
136f					endif 
136f			 
136f			    ; Search for free memory block 
136f			    ld de, (heap_end)  ; Load end of heap into DE 
136f			    ld bc, 0           ; Initialize counter 
136f			 
136f					if DEBUG_FORTH_MALLOC 
136f						DMARK "ma2" 
136f						CALLMONITOR 
136f					endif 
136f			malloc_search_loop: 
136f			    ; Check if current block is free 
136f			    ld a, (hl)         ; Load current block's status (free or used) 
136f			    cp 0               ; Compare with zero (free) 
136f			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
136f			 
136f			    ; Check if current block is large enough 
136f			    ld a, (hl+1)       ; Load high byte of block size 
136f			    cp l               ; Compare with low byte of requested size 
136f			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
136f			 
136f			    ld a, (hl+2)       ; Load low byte of block size 
136f			    cp h               ; Compare with high byte of requested size 
136f			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
136f			 
136f			    ; Mark block as used 
136f			    ld (hl), 0xFF      ; Set status byte to indicate used block 
136f			 
136f			    ; Calculate remaining space in block 
136f			    ld bc, 0           ; Clear BC 
136f			    add hl, bc         ; Increment HL to point to start of data block 
136f			    add hl, de         ; HL = HL + DE (total size) 
136f			    ld bc, 1           ; Number of bytes to allocate for management overhead 
136f			    add hl, bc         ; Add management overhead to start of data block 
136f			 
136f			    ; Save pointer to allocated block in HL 
136f			if DEBUG_FORTH_MALLOC_HIGH 
136f						DMARK "ma5" 
136f			call malloc_guard_exit 
136f			call malloc_guard_zerolen 
136f			endif 
136f			    ret 
136f			 
136f			malloc_skip_block_check: 
136f			    ; Move to the next block 
136f			    ld bc, 3           ; Size of management overhead 
136f			    add hl, bc         ; Move to the next block 
136f			    inc de             ; Increment counter 
136f			 
136f			    ; Check if we have reached the end of heap 
136f			    ld a, e            ; Load low byte of heap end address 
136f			    cp (hl)            ; Compare with low byte of current address 
136f			    jr nz, malloc_search_loop  ; If not equal, continue searching 
136f			    ld a, d            ; Load high byte of heap end address 
136f			    cp 0               ; Check if it's zero (end of memory) 
136f			    jr nz, malloc_search_loop  ; If not zero, continue searching 
136f			 
136f			    ; If we reached here, allocation failed 
136f			    xor a              ; Set result to NULL 
136f			if DEBUG_FORTH_MALLOC_HIGH 
136f						DMARK "ma6" 
136f			call malloc_guard_exit 
136f			call malloc_guard_zerolen 
136f			endif 
136f			    ret 
136f			malloc_exit: 
136f			if DEBUG_FORTH_MALLOC_HIGH 
136f						DMARK "ma7" 
136f			call malloc_guard_exit 
136f			call malloc_guard_zerolen 
136f			endif 
136f			    ret 
136f			 
136f			; Internal Free Function: 
136f			; Input: 
136f			;   HL: Pointer to memory block to free 
136f			; Output: 
136f			;   None 
136f			 
136f			free_internal: 
136f			    ld de, (heap_start) ; Load start of heap into DE 
136f			    ld bc, 0            ; Initialize counter 
136f			 
136f			free_search_loop: 
136f			    ; Check if current block contains the pointer 
136f			    ld a, l             ; Load low byte of pointer 
136f			    cp (hl+1)           ; Compare with high byte of current block's address 
136f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
136f			    ld a, h             ; Load high byte of pointer 
136f			    cp (hl+2)           ; Compare with low byte of current block's address 
136f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
136f			 
136f			    ; Mark block as free 
136f			    ld (hl), 0          ; Set status byte to indicate free block 
136f			    ret                 ; Return 
136f			 
136f			free_skip_block_check: 
136f			    ; Move to the next block 
136f			    ld bc, 3            ; Size of management overhead 
136f			    add hl, bc          ; Move to the next block 
136f			    inc de              ; Increment counter 
136f			 
136f			    ; Check if we have reached the end of heap 
136f			    ld a, e             ; Load low byte of heap end address 
136f			    cp (hl)             ; Compare with low byte of current address 
136f			    jr nz, free_search_loop  ; If not equal, continue searching 
136f			    ld a, d             ; Load high byte of heap end address 
136f			    cp 0                ; Check if it's zero (end of memory) 
136f			    jr nz, free_search_loop  ; If not zero, continue searching 
136f			 
136f			    ; If we reached here, pointer is not found in heap 
136f			    ret 
136f			 
136f			free_exit: 
136f			    ret                 ; Return 
136f			 
136f			; Define heap start and end addresses 
136f			;heap_start:    .dw 0xC000   ; Start of heap 
136f			;heap_end:      .dw 0xE000   ; End of heap 
136f			 
136f			endif 
136f			 
136f			 
136f			if MALLOC_1 
136f			 
136f			 
136f			 
136f			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
136f			 
136f			;moved to firmware.asm 
136f			;heap_start        .equ  0x9000      ; Starting address of heap 
136f			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
136f			 
136f			;      .org 0 
136f			;      jp    main 
136f			 
136f			 
136f			;      .org  0x100 
136f			;main: 
136f			;      ld    HL, 0x8100 
136f			;      ld    SP, HL 
136f			; 
136f			;      call  heap_init 
136f			; 
136f			;      ; Make some allocations 
136f			;      ld    HL, 12 
136f			;      call  malloc            ; Allocates 0x9004 
136f			; 
136f			;      ld    HL, 12 
136f			;      call  malloc            ; Allocates 0x9014 
136f			; 
136f			;      ld    HL, 12 
136f			;      call  malloc            ; Allocates 0x9024 
136f			; 
136f			;      ; Free some allocations 
136f			;      ld    HL, 0x9014 
136f			;      call  free 
136f			; 
136f			;      ld    HL, 0x9004 
136f			;      call  free 
136f			; 
136f			;      ld    HL, 0x9024 
136f			;      call  free 
136f			; 
136f			; 
136f			;      halt 
136f			 
136f			 
136f			;------------------------------------------------------------------------------ 
136f			;     heap_init                                                               : 
136f			;                                                                             : 
136f			; Description                                                                 : 
136f			;     Initialise the heap and make it ready for malloc and free operations.   : 
136f			;                                                                             : 
136f			;     The heap is maintained as a linked list, starting with an initial       : 
136f			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
136f			;     the first free block in the heap. Each block then points to the next    : 
136f			;     free block within the heap, and the free list ends at the first block   : 
136f			;     with a null pointer to the next free block.                             : 
136f			;                                                                             : 
136f			; Parameters                                                                  : 
136f			;     Inputs are compile-time only. Two defines which specify the starting    : 
136f			;     address of the heap and its size are required, along with a memory      : 
136f			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
136f			;     principally stores a pointer to the first free block in the heap.       : 
136f			;                                                                             : 
136f			; Returns                                                                     : 
136f			;     Nothing                                                                 : 
136f			;------------------------------------------------------------------------------ 
136f			heap_init: 
136f e5			      push  HL 
1370			 
1370			      ; Initialise free list struct 
1370 21 0e 80		      ld    HL, heap_start 
1373 22 0a 80		      ld    (free_list), HL 
1376 21 00 00		      ld    HL, 0 
1379 22 0c 80		      ld    (free_list+2), HL 
137c			 
137c			      ; Insert first free block at bottom of heap, consumes entire heap 
137c 21 e1 f1		      ld    HL, heap_start+heap_size-4 
137f 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1382 21 d3 71		      ld    HL, heap_size-4 
1385 22 10 80		      ld    (heap_start+2), HL      ; Block size 
1388			 
1388			      ; Insert end of free list block at top of heap - two null words will 
1388			      ; terminate the free list 
1388 21 00 00		      ld    HL, 0 
138b 22 e3 f1		      ld    (heap_start+heap_size-2), HL 
138e 22 e1 f1		      ld    (heap_start+heap_size-4), HL 
1391			 
1391 e1			      pop   HL 
1392			 
1392 c9			      ret 
1393			 
1393			 
1393			;------------------------------------------------------------------------------ 
1393			;     malloc                                                                  : 
1393			;                                                                             : 
1393			; Description                                                                 : 
1393			;     Allocates the wanted space from the heap and returns the address of the : 
1393			;     first useable byte of the allocation.                                   : 
1393			;                                                                             : 
1393			;     Allocations can happen in one of two ways:                              : 
1393			;                                                                             : 
1393			;     1. A free block may be found which is the exact size wanted. In this    : 
1393			;        case the block is removed from the free list and retuedn to the      : 
1393			;        caller.                                                              : 
1393			;     2. A free block may be found which is larger than the size wanted. In   : 
1393			;        this case, the larger block is split into two. The first portion of  : 
1393			;        this block will become the requested space by the malloc call and    : 
1393			;        is returned to the caller. The second portion becomes a new free     : 
1393			;        block, and the free list is adjusted to maintain continuity via this : 
1393			;        newly created block.                                                 : 
1393			;                                                                             : 
1393			;     malloc does not set any initial value in the allocated space, the       : 
1393			;     caller is required to do this as required.                              : 
1393			;                                                                             : 
1393			;     This implementation of malloc uses the stack exclusively, and is        : 
1393			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1393			;     advisable to disable interrupts before calling malloc, and recommended  : 
1393			;     to avoid the use of malloc inside ISRs in general.                      : 
1393			;                                                                             : 
1393			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1393			;                                                                             : 
1393			; Parameters                                                                  : 
1393			;     HL  Number of bytes wanted                                              : 
1393			;                                                                             : 
1393			; Returns                                                                     : 
1393			;     HL  Address of the first useable byte of the allocation                 : 
1393			;                                                                             : 
1393			; Flags                                                                       : 
1393			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1393			;                                                                             : 
1393			; Stack frame                                                                 : 
1393			;       |             |                                                       : 
1393			;       +-------------+                                                       : 
1393			;       |     BC      |                                                       : 
1393			;       +-------------+                                                       : 
1393			;       |     DE      |                                                       : 
1393			;       +-------------+                                                       : 
1393			;       |     IX      |                                                       : 
1393			;       +-------------+                                                       : 
1393			;       |  prev_free  |                                                       : 
1393			;   +4  +-------------+                                                       : 
1393			;       |  this_free  |                                                       : 
1393			;   +2  +-------------+                                                       : 
1393			;       |  next_free  |                                                       : 
1393			;   +0  +-------------+                                                       : 
1393			;       |             |                                                       : 
1393			;                                                                             : 
1393			;------------------------------------------------------------------------------ 
1393			 
1393			 
1393			;malloc: 
1393			; 
1393			;	SAVESP ON 1 
1393			; 
1393			;	call malloc_code 
1393			; 
1393			;	CHECKSP ON 1 
1393			;	ret 
1393			 
1393			 
1393			malloc: 
1393 c5			      push  BC 
1394 d5			      push  DE 
1395 dd e5		      push  IX 
1397			if DEBUG_FORTH_MALLOC_HIGH 
1397			call malloc_guard_entry 
1397			endif 
1397			 
1397					if DEBUG_FORTH_MALLOC 
1397						DMARK "mal" 
1397						CALLMONITOR 
1397					endif 
1397 7c			      ld    A, H                    ; Exit if no space requested 
1398 b5			      or    L 
1399 ca 58 14		      jp    Z, malloc_early_exit 
139c			 
139c			;inc hl 
139c			;inc hl 
139c			;inc hl 
139c			; 
139c			;inc hl 
139c			;inc hl 
139c			;inc hl 
139c			;inc hl 
139c			;inc hl 
139c			;inc hl 
139c			;inc hl 
139c			;inc hl 
139c			;inc hl 
139c			 
139c			 
139c			 
139c			 
139c					if DEBUG_FORTH_MALLOC 
139c						DMARK "maA" 
139c						CALLMONITOR 
139c					endif 
139c			      ; Set up stack frame 
139c eb			      ex    DE, HL 
139d 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
13a0 39			      add   HL, SP 
13a1 f9			      ld    SP, HL 
13a2 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
13a6 dd 39		      add   IX, SP 
13a8			 
13a8			      ; Setup initial state 
13a8 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
13ab 19			      add   HL, DE 
13ac			 
13ac 44			      ld    B, H                    ; Move want to BC 
13ad 4d			      ld    C, L 
13ae			 
13ae 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
13b1 dd 75 04		      ld    (IX+4), L 
13b4 dd 74 05		      ld    (IX+5), H 
13b7			 
13b7 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
13b8 23			      inc   HL 
13b9 56			      ld    D, (HL) 
13ba dd 73 02		      ld    (IX+2), E 
13bd dd 72 03		      ld    (IX+3), D 
13c0 eb			      ex    DE, HL                  ; this_free ptr into HL 
13c1			 
13c1					if DEBUG_FORTH_MALLOC 
13c1						DMARK "maB" 
13c1						CALLMONITOR 
13c1					endif 
13c1			      ; Loop through free block list to find some space 
13c1			malloc_find_space: 
13c1 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
13c2 23			      inc   HL 
13c3 56			      ld    D, (HL) 
13c4			 
13c4 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13c5 b3			      or    E 
13c6 ca 52 14		      jp    Z, malloc_no_space 
13c9			 
13c9 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
13cc dd 72 01		      ld    (IX+1), D 
13cf			 
13cf			      ; Does this block have enough space to make the allocation? 
13cf 23			      inc   HL                      ; Load free block size into DE 
13d0 5e			      ld    E, (HL) 
13d1 23			      inc   HL 
13d2 56			      ld    D, (HL) 
13d3			 
13d3 eb			      ex    DE, HL                  ; Check size of block against want 
13d4 b7			      or    A                       ; Ensure carry flag clear 
13d5 ed 42		      sbc   HL, BC 
13d7 e5			      push  HL                      ; Store the result for later (new block size) 
13d8			 
13d8 ca 27 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
13db 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
13dd			 
13dd			      ; this_free block is not big enough, setup ptrs to test next free block 
13dd e1			      pop   HL                      ; Discard previous result 
13de			 
13de dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
13e1 dd 66 03		      ld    H, (IX+3) 
13e4 dd 75 04		      ld    (IX+4), L 
13e7 dd 74 05		      ld    (IX+5), H 
13ea			 
13ea dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
13ed dd 66 01		      ld    H, (IX+1) 
13f0 dd 75 02		      ld    (IX+2), L 
13f3 dd 74 03		      ld    (IX+3), H 
13f6			 
13f6					if DEBUG_FORTH_MALLOC 
13f6						DMARK "MA>" 
13f6						CALLMONITOR 
13f6					endif 
13f6 18 c9		      jr    malloc_find_space 
13f8			 
13f8			      ; split a bigger block into two - requested size and remaining size 
13f8			malloc_alloc_split: 
13f8					if DEBUG_FORTH_MALLOC 
13f8						DMARK "MAs" 
13f8						CALLMONITOR 
13f8					endif 
13f8 eb			      ex    DE, HL                  ; Calculate address of new free block 
13f9 2b			      dec   HL 
13fa 2b			      dec   HL 
13fb 2b			      dec   HL 
13fc 09			      add   HL, BC 
13fd			 
13fd			      ; Create a new block and point it at next_free 
13fd dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1400 dd 56 01		      ld    D, (IX+1) 
1403			 
1403 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1404 23			      inc   HL 
1405 72			      ld    (HL), D 
1406			 
1406 d1			      pop   DE                      ; Store size of new block into new block 
1407 23			      inc   HL 
1408 73			      ld    (HL), E 
1409 23			      inc   HL 
140a 72			      ld    (HL), D 
140b			 
140b			      ; Update this_free ptr to point to new block 
140b 2b			      dec   HL 
140c 2b			      dec   HL 
140d 2b			      dec   HL 
140e			 
140e dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1411 dd 56 03		      ld    D, (IX+3) 
1414			 
1414 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1417 dd 74 03		      ld    (IX+3), H 
141a			 
141a			      ; Modify this_free block to be allocation 
141a eb			      ex    DE, HL 
141b af			      xor   A                       ; Null the next block ptr of allocated block 
141c 77			      ld    (HL), A 
141d 23			      inc   HL 
141e 77			      ld    (HL), A 
141f			 
141f 23			      inc   HL                      ; Store want size into allocated block 
1420 71			      ld    (HL), C 
1421 23			      inc   HL 
1422 70			      ld    (HL), B 
1423 23			      inc   HL 
1424 e5			      push  HL                      ; Address of allocation to return 
1425			 
1425 18 19		      jr    malloc_update_links 
1427			 
1427			malloc_alloc_fit: 
1427 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1428			 
1428					if DEBUG_FORTH_MALLOC 
1428						DMARK "MAf" 
1428						CALLMONITOR 
1428					endif 
1428			      ; Modify this_free block to be allocation 
1428 eb			      ex    DE, HL 
1429 2b			      dec   HL 
142a 2b			      dec   HL 
142b 2b			      dec   HL 
142c			 
142c af			      xor   A                       ; Null the next block ptr of allocated block 
142d 77			      ld    (HL), A 
142e 23			      inc   HL 
142f 77			      ld    (HL), A 
1430			 
1430 23			      inc   HL                      ; Store address of allocation to return 
1431 23			      inc   HL 
1432 23			      inc   HL 
1433 e5			      push  HL 
1434			 
1434			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1434 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1437 dd 66 01		      ld    H, (IX+1) 
143a			 
143a dd 75 02		      ld    (IX+2), L               ; HL to this_free 
143d dd 74 03		      ld    (IX+3), H 
1440			 
1440			 
1440			malloc_update_links: 
1440			      ; Update prev_free ptr to point to this_free 
1440 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1443 dd 66 05		      ld    H, (IX+5) 
1446			 
1446 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1449 dd 56 03		      ld    D, (IX+3) 
144c			 
144c 73			      ld    (HL), E                 ; this_free ptr into prev_free 
144d 23			      inc   HL 
144e 72			      ld    (HL), D 
144f			 
144f					if DEBUG_FORTH_MALLOC 
144f						DMARK "Mul" 
144f						CALLMONITOR 
144f					endif 
144f			      ; Clear the Z flag to indicate successful allocation 
144f 7a			      ld    A, D 
1450 b3			      or    E 
1451			 
1451 d1			      pop   DE                      ; Address of allocation 
1452					if DEBUG_FORTH_MALLOC 
1452						DMARK "MAu" 
1452						CALLMONITOR 
1452					endif 
1452			 
1452			malloc_no_space: 
1452 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1455 39			      add   HL, SP 
1456 f9			      ld    SP, HL 
1457			 
1457 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1458					if DEBUG_FORTH_MALLOC 
1458						DMARK "MAN" 
1458						CALLMONITOR 
1458					endif 
1458			 
1458			malloc_early_exit: 
1458					if DEBUG_FORTH_MALLOC 
1458						DMARK "MAx" 
1458						CALLMONITOR 
1458					endif 
1458 dd e1		      pop   IX 
145a d1			      pop   DE 
145b c1			      pop   BC 
145c			 
145c			if DEBUG_FORTH_MALLOC_HIGH 
145c			call malloc_guard_exit 
145c			call malloc_guard_zerolen 
145c			endif 
145c c9			      ret 
145d			 
145d			 
145d			;------------------------------------------------------------------------------ 
145d			;     free                                                                    : 
145d			;                                                                             : 
145d			; Description                                                                 : 
145d			;     Return the space pointed to by HL to the heap. HL must be an address as : 
145d			;     returned by malloc, otherwise the behaviour is undefined.               : 
145d			;                                                                             : 
145d			;     Where possible, directly adjacent free blocks will be merged together   : 
145d			;     into larger blocks to help ensure that the heap does not become         : 
145d			;     excessively fragmented.                                                 : 
145d			;                                                                             : 
145d			;     free does not clear or set any other value into the freed space, and    : 
145d			;     therefore its contents may be visible through subsequent malloc's. The  : 
145d			;     caller should clear the freed space as required.                        : 
145d			;                                                                             : 
145d			;     This implementation of free uses the stack exclusively, and is          : 
145d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
145d			;     advisable to disable interrupts before calling free, and recommended    : 
145d			;     to avoid the use of free inside ISRs in general.                        : 
145d			;                                                                             : 
145d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
145d			;                                                                             : 
145d			; Parameters                                                                  : 
145d			;     HL  Pointer to address of first byte of allocation to be freed          : 
145d			;                                                                             : 
145d			; Returns                                                                     : 
145d			;     Nothing                                                                 : 
145d			;                                                                             : 
145d			; Stack frame                                                                 : 
145d			;       |             |                                                       : 
145d			;       +-------------+                                                       : 
145d			;       |     BC      |                                                       : 
145d			;       +-------------+                                                       : 
145d			;       |     DE      |                                                       : 
145d			;       +-------------+                                                       : 
145d			;       |     IX      |                                                       : 
145d			;       +-------------+                                                       : 
145d			;       |  prev_free  |                                                       : 
145d			;   +2  +-------------+                                                       : 
145d			;       |  next_free  |                                                       : 
145d			;   +0  +-------------+                                                       : 
145d			;       |             |                                                       : 
145d			;                                                                             : 
145d			;------------------------------------------------------------------------------ 
145d			free: 
145d c5			      push  BC 
145e d5			      push  DE 
145f dd e5		      push  IX 
1461			 
1461 7c			      ld    A, H                    ; Exit if ptr is null 
1462 b5			      or    L 
1463 ca 27 15		      jp    Z, free_early_exit 
1466			 
1466			      ; Set up stack frame 
1466 eb			      ex    DE, HL 
1467 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
146a 39			      add   HL, SP 
146b f9			      ld    SP, HL 
146c dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1470 dd 39		      add   IX, SP 
1472			 
1472			      ; The address in HL points to the start of the useable allocated space, 
1472			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1472			      ; address of the block itself. 
1472 eb			      ex    DE, HL 
1473 11 fc ff		      ld    DE, -4 
1476 19			      add   HL, DE 
1477			 
1477			      ; An allocated block must have a null next block pointer in it 
1477 7e			      ld    A, (HL) 
1478 23			      inc   HL 
1479 b6			      or    (HL) 
147a c2 22 15		      jp    NZ, free_done 
147d			 
147d 2b			      dec   HL 
147e			 
147e 44			      ld    B, H                    ; Copy HL to BC 
147f 4d			      ld    C, L 
1480			 
1480			      ; Loop through the free list to find the first block with an address 
1480			      ; higher than the block being freed 
1480 21 0a 80		      ld    HL, free_list 
1483			 
1483			free_find_higher_block: 
1483 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1484 23			      inc   HL 
1485 56			      ld    D, (HL) 
1486 2b			      dec   HL 
1487			 
1487 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
148a dd 72 01		      ld    (IX+1), D 
148d dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1490 dd 74 03		      ld    (IX+3), H 
1493			 
1493 78			      ld    A, B                    ; Check if DE is greater than BC 
1494 ba			      cp    D                       ; Compare MSB first 
1495 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1497 30 04		      jr    NC, free_find_higher_block_skip 
1499 79			      ld    A, C 
149a bb			      cp    E                       ; Then compare LSB 
149b 38 08		      jr    C, free_found_higher_block 
149d			 
149d			free_find_higher_block_skip: 
149d 7a			      ld    A, D                    ; Reached the end of the free list? 
149e b3			      or    E 
149f ca 22 15		      jp    Z, free_done 
14a2			 
14a2 eb			      ex    DE, HL 
14a3			 
14a3 18 de		      jr    free_find_higher_block 
14a5			 
14a5			free_found_higher_block: 
14a5			      ; Insert freed block between prev and next free blocks 
14a5 71			      ld    (HL), C                 ; Point prev free block to freed block 
14a6 23			      inc   HL 
14a7 70			      ld    (HL), B 
14a8			 
14a8 60			      ld    H, B                    ; Point freed block at next free block 
14a9 69			      ld    L, C 
14aa 73			      ld    (HL), E 
14ab 23			      inc   HL 
14ac 72			      ld    (HL), D 
14ad			 
14ad			      ; Check if the freed block is adjacent to the next free block 
14ad 23			      inc   HL                      ; Load size of freed block into HL 
14ae 5e			      ld    E, (HL) 
14af 23			      inc   HL 
14b0 56			      ld    D, (HL) 
14b1 eb			      ex    DE, HL 
14b2			 
14b2 09			      add   HL, BC                  ; Add addr of freed block and its size 
14b3			 
14b3 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
14b6 dd 56 01		      ld    D, (IX+1) 
14b9			 
14b9 b7			      or    A                       ; Clear the carry flag 
14ba ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
14bc 20 22		      jr    NZ, free_check_adjacent_to_prev 
14be			 
14be			      ; Freed block is adjacent to next, merge into one bigger block 
14be eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
14bf 5e			      ld    E, (HL) 
14c0 23			      inc   HL 
14c1 56			      ld    D, (HL) 
14c2 e5			      push  HL                      ; Save ptr to next block for later 
14c3			 
14c3 60			      ld    H, B                    ; Store ptr from next block into freed block 
14c4 69			      ld    L, C 
14c5 73			      ld    (HL), E 
14c6 23			      inc   HL 
14c7 72			      ld    (HL), D 
14c8			 
14c8 e1			      pop   HL                      ; Restore ptr to next block 
14c9 23			      inc   HL                      ; Load size of next block into DE 
14ca 5e			      ld    E, (HL) 
14cb 23			      inc   HL 
14cc 56			      ld    D, (HL) 
14cd d5			      push  DE                      ; Save next block size for later 
14ce			 
14ce 60			      ld    H, B                    ; Load size of freed block into HL 
14cf 69			      ld    L, C 
14d0 23			      inc   HL 
14d1 23			      inc   HL 
14d2 5e			      ld    E, (HL) 
14d3 23			      inc   HL 
14d4 56			      ld    D, (HL) 
14d5 eb			      ex    DE, HL 
14d6			 
14d6 d1			      pop   DE                      ; Restore size of next block 
14d7 19			      add   HL, DE                  ; Add sizes of both blocks 
14d8 eb			      ex    DE, HL 
14d9			 
14d9 60			      ld    H, B                    ; Store new bigger size into freed block 
14da 69			      ld    L, C 
14db 23			      inc   HL 
14dc 23			      inc   HL 
14dd 73			      ld    (HL), E 
14de 23			      inc   HL 
14df 72			      ld    (HL), D 
14e0			 
14e0			free_check_adjacent_to_prev: 
14e0			      ; Check if the freed block is adjacent to the prev free block 
14e0 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
14e3 dd 66 03		      ld    H, (IX+3) 
14e6			 
14e6 23			      inc   HL                      ; Size of prev free block into DE 
14e7 23			      inc   HL 
14e8 5e			      ld    E, (HL) 
14e9 23			      inc   HL 
14ea 56			      ld    D, (HL) 
14eb 2b			      dec   HL 
14ec 2b			      dec   HL 
14ed 2b			      dec   HL 
14ee			 
14ee 19			      add   HL, DE                  ; Add prev block addr and size 
14ef			 
14ef b7			      or    A                       ; Clear the carry flag 
14f0 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
14f2 20 2e		      jr    NZ, free_done 
14f4			 
14f4			      ; Freed block is adjacent to prev, merge into one bigger block 
14f4 60			      ld    H, B                    ; Load next ptr from freed block into DE 
14f5 69			      ld    L, C 
14f6 5e			      ld    E, (HL) 
14f7 23			      inc   HL 
14f8 56			      ld    D, (HL) 
14f9 e5			      push  HL                      ; Save freed block ptr for later 
14fa			 
14fa dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
14fd dd 66 03		      ld    H, (IX+3) 
1500 73			      ld    (HL), E 
1501 23			      inc   HL 
1502 72			      ld    (HL), D 
1503			 
1503 e1			      pop   HL                      ; Restore freed block ptr 
1504 23			      inc   HL                      ; Load size of freed block into DE 
1505 5e			      ld    E, (HL) 
1506 23			      inc   HL 
1507 56			      ld    D, (HL) 
1508 d5			      push  DE                      ; Save freed block size for later 
1509			 
1509 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
150c dd 66 03		      ld    H, (IX+3) 
150f 23			      inc   HL 
1510 23			      inc   HL 
1511 5e			      ld    E, (HL) 
1512 23			      inc   HL 
1513 56			      ld    D, (HL) 
1514			 
1514 e1			      pop   HL                      ; Add sizes of both blocks 
1515 19			      add   HL, DE 
1516 eb			      ex    DE, HL 
1517			 
1517 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
151a dd 66 03		      ld    H, (IX+3) 
151d 23			      inc   HL 
151e 23			      inc   HL 
151f 73			      ld    (HL), E 
1520 23			      inc   HL 
1521 72			      ld    (HL), D 
1522			 
1522			free_done: 
1522 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1525 39			      add   HL, SP 
1526 f9			      ld    SP, HL 
1527			 
1527			free_early_exit: 
1527 dd e1		      pop   IX 
1529 d1			      pop   DE 
152a c1			      pop   BC 
152b			 
152b c9			      ret 
152c			 
152c			; moved to firmware.asm 
152c			; 
152c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
152c			;                  .dw   0 
152c			 
152c			 
152c			endif 
152c			 
152c			 
152c			if MALLOC_3 
152c			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
152c			;heap_start        .equ  0x9000      ; Starting address of heap 
152c			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
152c			; 
152c			 ;     .org 0 
152c			  ;    jp    main 
152c			; 
152c			; 
152c			 ;     .org  0x100 
152c			;main: 
152c			 ;     ld    HL, 0x8100 
152c			  ;    ld    SP, HL 
152c			; 
152c			;      call  heap_init 
152c			 
152c			      ; Make some allocations 
152c			;      ld    HL, 12 
152c			;      call  malloc            ; Allocates 0x9004 
152c			; 
152c			 ;     ld    HL, 12 
152c			;      call  malloc            ; Allocates 0x9014 
152c			 
152c			;      ld    HL, 12 
152c			;      call  malloc            ; Allocates 0x9024 
152c			 
152c			      ; Free some allocations 
152c			;      ld    HL, 0x9014 
152c			;      call  free 
152c			 
152c			;      ld    HL, 0x9004 
152c			;      call  free 
152c			; 
152c			;      ld    HL, 0x9024 
152c			;      call  free 
152c			 
152c			 
152c			 ;     halt 
152c			 
152c			 
152c			;------------------------------------------------------------------------------ 
152c			;     heap_init                                                               : 
152c			;                                                                             : 
152c			; Description                                                                 : 
152c			;     Initialise the heap and make it ready for malloc and free operations.   : 
152c			;                                                                             : 
152c			;     The heap is maintained as a linked list, starting with an initial       : 
152c			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
152c			;     the first free block in the heap. Each block then points to the next    : 
152c			;     free block within the heap, and the free list ends at the first block   : 
152c			;     with a null pointer to the next free block.                             : 
152c			;                                                                             : 
152c			; Parameters                                                                  : 
152c			;     Inputs are compile-time only. Two defines which specify the starting    : 
152c			;     address of the heap and its size are required, along with a memory      : 
152c			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
152c			;     principally stores a pointer to the first free block in the heap.       : 
152c			;                                                                             : 
152c			; Returns                                                                     : 
152c			;     Nothing                                                                 : 
152c			;------------------------------------------------------------------------------ 
152c			heap_init: 
152c			      push  HL 
152c			 
152c			      ; Initialise free list struct 
152c			      ld    HL, heap_start 
152c			      ld    (free_list), HL 
152c			      ld    HL, 0 
152c			      ld    (free_list+2), HL 
152c			 
152c			      ; Insert first free block at bottom of heap, consumes entire heap 
152c			      ld    HL, heap_start+heap_size-4 
152c			      ld    (heap_start), HL        ; Next block (end of free list) 
152c			      ld    HL, heap_size-4 
152c			      ld    (heap_start+2), HL      ; Block size 
152c			 
152c			      ; Insert end of free list block at top of heap - two null words will 
152c			      ; terminate the free list 
152c			      ld    HL, 0 
152c			      ld    (heap_start+heap_size-2), HL 
152c			      ld    (heap_start+heap_size-4), HL 
152c			 
152c			      pop   HL 
152c			 
152c			      ret 
152c			 
152c			 
152c			;------------------------------------------------------------------------------ 
152c			;     malloc                                                                  : 
152c			;                                                                             : 
152c			; Description                                                                 : 
152c			;     Allocates the wanted space from the heap and returns the address of the : 
152c			;     first useable byte of the allocation.                                   : 
152c			;                                                                             : 
152c			;     Allocations can happen in one of two ways:                              : 
152c			;                                                                             : 
152c			;     1. A free block may be found which is the exact size wanted. In this    : 
152c			;        case the block is removed from the free list and retuedn to the      : 
152c			;        caller.                                                              : 
152c			;     2. A free block may be found which is larger than the size wanted. In   : 
152c			;        this case, the larger block is split into two. The first portion of  : 
152c			;        this block will become the requested space by the malloc call and    : 
152c			;        is returned to the caller. The second portion becomes a new free     : 
152c			;        block, and the free list is adjusted to maintain continuity via this : 
152c			;        newly created block.                                                 : 
152c			;                                                                             : 
152c			;     malloc does not set any initial value in the allocated space, the       : 
152c			;     caller is required to do this as required.                              : 
152c			;                                                                             : 
152c			;     This implementation of malloc uses the stack exclusively, and is        : 
152c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
152c			;     advisable to disable interrupts before calling malloc, and recommended  : 
152c			;     to avoid the use of malloc inside ISRs in general.                      : 
152c			;                                                                             : 
152c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
152c			;                                                                             : 
152c			; Parameters                                                                  : 
152c			;     HL  Number of bytes wanted                                              : 
152c			;                                                                             : 
152c			; Returns                                                                     : 
152c			;     HL  Address of the first useable byte of the allocation                 : 
152c			;                                                                             : 
152c			; Flags                                                                       : 
152c			;     Z   Set if the allocation did not succeed, clear otherwise              : 
152c			;                                                                             : 
152c			; Stack frame                                                                 : 
152c			;       |             |                                                       : 
152c			;       +-------------+                                                       : 
152c			;       |     BC      |                                                       : 
152c			;       +-------------+                                                       : 
152c			;       |     DE      |                                                       : 
152c			;       +-------------+                                                       : 
152c			;       |     IX      |                                                       : 
152c			;       +-------------+                                                       : 
152c			;       |  prev_free  |                                                       : 
152c			;   +4  +-------------+                                                       : 
152c			;       |  this_free  |                                                       : 
152c			;   +2  +-------------+                                                       : 
152c			;       |  next_free  |                                                       : 
152c			;   +0  +-------------+                                                       : 
152c			;       |             |                                                       : 
152c			;                                                                             : 
152c			;------------------------------------------------------------------------------ 
152c			malloc: 
152c			      push  BC 
152c			      push  DE 
152c			      push  IX 
152c			 
152c			      ld    A, H                    ; Exit if no space requested 
152c			      or    L 
152c			      jp    Z, malloc_early_exit 
152c			 
152c			      ; Set up stack frame 
152c			      ex    DE, HL 
152c			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
152c			      add   HL, SP 
152c			      ld    SP, HL 
152c			      ld    IX, 0                   ; Use IX as a frame pointer 
152c			      add   IX, SP 
152c			 
152c			      ; Setup initial state 
152c			      ld    HL, 4                   ; want must also include space used by block struct 
152c			      add   HL, DE 
152c			 
152c			      ld    B, H                    ; Move want to BC 
152c			      ld    C, L 
152c			 
152c			      ld    HL, free_list           ; Store prev_free ptr to stack 
152c			      ld    (IX+4), L 
152c			      ld    (IX+5), H 
152c			 
152c			      ld    E, (HL)                 ; Store this_free ptr to stack 
152c			      inc   HL 
152c			      ld    D, (HL) 
152c			      ld    (IX+2), E 
152c			      ld    (IX+3), D 
152c			      ex    DE, HL                  ; this_free ptr into HL 
152c			 
152c			      ; Loop through free block list to find some space 
152c			malloc_find_space: 
152c			      ld    E, (HL)                 ; Load next_free ptr into DE 
152c			      inc   HL 
152c			      ld    D, (HL) 
152c			 
152c			      ld    A, D                    ; Check for null next_free ptr - end of free list 
152c			      or    E 
152c			      jp    Z, malloc_no_space 
152c			 
152c			      ld    (IX+0), E               ; Store next_free ptr to stack 
152c			      ld    (IX+1), D 
152c			 
152c			      ; Does this block have enough space to make the allocation? 
152c			      inc   HL                      ; Load free block size into DE 
152c			      ld    E, (HL) 
152c			      inc   HL 
152c			      ld    D, (HL) 
152c			 
152c			      ex    DE, HL                  ; Check size of block against want 
152c			      or    A                       ; Ensure carry flag clear 
152c			      sbc   HL, BC 
152c			      push  HL                      ; Store the result for later (new block size) 
152c			 
152c			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
152c			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
152c			 
152c			      ; this_free block is not big enough, setup ptrs to test next free block 
152c			      pop   HL                      ; Discard previous result 
152c			 
152c			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
152c			      ld    H, (IX+3) 
152c			      ld    (IX+4), L 
152c			      ld    (IX+5), H 
152c			 
152c			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
152c			      ld    H, (IX+1) 
152c			      ld    (IX+2), L 
152c			      ld    (IX+3), H 
152c			 
152c			      jr    malloc_find_space 
152c			 
152c			      ; split a bigger block into two - requested size and remaining size 
152c			malloc_alloc_split: 
152c			      ex    DE, HL                  ; Calculate address of new free block 
152c			      dec   HL 
152c			      dec   HL 
152c			      dec   HL 
152c			      add   HL, BC 
152c			 
152c			      ; Create a new block and point it at next_free 
152c			      ld    E, (IX+0)               ; Load next_free ptr into DE 
152c			      ld    D, (IX+1) 
152c			 
152c			      ld    (HL), E                 ; Store next_free ptr into new block 
152c			      inc   HL 
152c			      ld    (HL), D 
152c			 
152c			      pop   DE                      ; Store size of new block into new block 
152c			      inc   HL 
152c			      ld    (HL), E 
152c			      inc   HL 
152c			      ld    (HL), D 
152c			 
152c			      ; Update this_free ptr to point to new block 
152c			      dec   HL 
152c			      dec   HL 
152c			      dec   HL 
152c			 
152c			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
152c			      ld    D, (IX+3) 
152c			 
152c			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
152c			      ld    (IX+3), H 
152c			 
152c			      ; Modify this_free block to be allocation 
152c			      ex    DE, HL 
152c			      xor   A                       ; Null the next block ptr of allocated block 
152c			      ld    (HL), A 
152c			      inc   HL 
152c			      ld    (HL), A 
152c			 
152c			      inc   HL                      ; Store want size into allocated block 
152c			      ld    (HL), C 
152c			      inc   HL 
152c			      ld    (HL), B 
152c			      inc   HL 
152c			      push  HL                      ; Address of allocation to return 
152c			 
152c			      jr    malloc_update_links 
152c			 
152c			malloc_alloc_fit: 
152c			      pop   HL                      ; Dont need new block size, want is exact fit 
152c			 
152c			      ; Modify this_free block to be allocation 
152c			      ex    DE, HL 
152c			      dec   HL 
152c			      dec   HL 
152c			      dec   HL 
152c			 
152c			      xor   A                       ; Null the next block ptr of allocated block 
152c			      ld    (HL), A 
152c			      inc   HL 
152c			      ld    (HL), A 
152c			 
152c			      inc   HL                      ; Store address of allocation to return 
152c			      inc   HL 
152c			      inc   HL 
152c			      push  HL 
152c			 
152c			      ; Copy next_free ptr to this_free, remove allocated block from free list 
152c			      ld    L, (IX+0)               ; next_free to HL 
152c			      ld    H, (IX+1) 
152c			 
152c			      ld    (IX+2), L               ; HL to this_free 
152c			      ld    (IX+3), H 
152c			 
152c			 
152c			malloc_update_links: 
152c			      ; Update prev_free ptr to point to this_free 
152c			      ld    L, (IX+4)               ; prev_free ptr to HL 
152c			      ld    H, (IX+5) 
152c			 
152c			      ld    E, (IX+2)               ; this_free ptr to DE 
152c			      ld    D, (IX+3) 
152c			 
152c			      ld    (HL), E                 ; this_free ptr into prev_free 
152c			      inc   HL 
152c			      ld    (HL), D 
152c			 
152c			      ; Clear the Z flag to indicate successful allocation 
152c			      ld    A, D 
152c			      or    E 
152c			 
152c			      pop   DE                      ; Address of allocation 
152c			 
152c			malloc_no_space: 
152c			      ld    HL, 6                   ; Clean up stack frame 
152c			      add   HL, SP 
152c			      ld    SP, HL 
152c			 
152c			      ex    DE, HL                  ; Alloc addr into HL for return 
152c			 
152c			malloc_early_exit: 
152c			      pop   IX 
152c			      pop   DE 
152c			      pop   BC 
152c			 
152c			      ret 
152c			 
152c			 
152c			;------------------------------------------------------------------------------ 
152c			;     free                                                                    : 
152c			;                                                                             : 
152c			; Description                                                                 : 
152c			;     Return the space pointed to by HL to the heap. HL must be an address as : 
152c			;     returned by malloc, otherwise the behaviour is undefined.               : 
152c			;                                                                             : 
152c			;     Where possible, directly adjacent free blocks will be merged together   : 
152c			;     into larger blocks to help ensure that the heap does not become         : 
152c			;     excessively fragmented.                                                 : 
152c			;                                                                             : 
152c			;     free does not clear or set any other value into the freed space, and    : 
152c			;     therefore its contents may be visible through subsequent malloc's. The  : 
152c			;     caller should clear the freed space as required.                        : 
152c			;                                                                             : 
152c			;     This implementation of free uses the stack exclusively, and is          : 
152c			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
152c			;     advisable to disable interrupts before calling free, and recommended    : 
152c			;     to avoid the use of free inside ISRs in general.                        : 
152c			;                                                                             : 
152c			;     NOTE: heap_init must be called before malloc and free can be used.      : 
152c			;                                                                             : 
152c			; Parameters                                                                  : 
152c			;     HL  Pointer to address of first byte of allocation to be freed          : 
152c			;                                                                             : 
152c			; Returns                                                                     : 
152c			;     Nothing                                                                 : 
152c			;                                                                             : 
152c			; Stack frame                                                                 : 
152c			;       |             |                                                       : 
152c			;       +-------------+                                                       : 
152c			;       |     BC      |                                                       : 
152c			;       +-------------+                                                       : 
152c			;       |     DE      |                                                       : 
152c			;       +-------------+                                                       : 
152c			;       |     IX      |                                                       : 
152c			;       +-------------+                                                       : 
152c			;       |  prev_free  |                                                       : 
152c			;   +2  +-------------+                                                       : 
152c			;       |  next_free  |                                                       : 
152c			;   +0  +-------------+                                                       : 
152c			;       |             |                                                       : 
152c			;                                                                             : 
152c			;------------------------------------------------------------------------------ 
152c			free: 
152c			      push  BC 
152c			      push  DE 
152c			      push  IX 
152c			 
152c			      ld    A, H                    ; Exit if ptr is null 
152c			      or    L 
152c			      jp    Z, free_early_exit 
152c			 
152c			      ; Set up stack frame 
152c			      ex    DE, HL 
152c			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
152c			      add   HL, SP 
152c			      ld    SP, HL 
152c			      ld    IX, 0                   ; Use IX as a frame pointer 
152c			      add   IX, SP 
152c			 
152c			      ; The address in HL points to the start of the useable allocated space, 
152c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
152c			      ; address of the block itself. 
152c			      ex    DE, HL 
152c			      ld    DE, -4 
152c			      add   HL, DE 
152c			 
152c			      ; An allocated block must have a null next block pointer in it 
152c			      ld    A, (HL) 
152c			      inc   HL 
152c			      or    (HL) 
152c			      jp    NZ, free_done 
152c			 
152c			      dec   HL 
152c			 
152c			      ld    B, H                    ; Copy HL to BC 
152c			      ld    C, L 
152c			 
152c			      ; Loop through the free list to find the first block with an address 
152c			      ; higher than the block being freed 
152c			      ld    HL, free_list 
152c			 
152c			free_find_higher_block: 
152c			      ld    E, (HL)                 ; Load next ptr from free block 
152c			      inc   HL 
152c			      ld    D, (HL) 
152c			      dec   HL 
152c			 
152c			      ld    (IX+0), E               ; Save ptr to next free block 
152c			      ld    (IX+1), D 
152c			      ld    (IX+2), L               ; Save ptr to prev free block 
152c			      ld    (IX+3), H 
152c			 
152c			      ld    A, B                    ; Check if DE is greater than BC 
152c			      cp    D                       ; Compare MSB first 
152c			      jr    Z, $+4                  ; MSB the same, compare LSB 
152c			      jr    NC, free_find_higher_block_skip 
152c			      ld    A, C 
152c			      cp    E                       ; Then compare LSB 
152c			      jr    C, free_found_higher_block 
152c			 
152c			free_find_higher_block_skip: 
152c			      ld    A, D                    ; Reached the end of the free list? 
152c			      or    E 
152c			      jp    Z, free_done 
152c			 
152c			      ex    DE, HL 
152c			 
152c			      jr    free_find_higher_block 
152c			 
152c			free_found_higher_block: 
152c			      ; Insert freed block between prev and next free blocks 
152c			      ld    (HL), C                 ; Point prev free block to freed block 
152c			      inc   HL 
152c			      ld    (HL), B 
152c			 
152c			      ld    H, B                    ; Point freed block at next free block 
152c			      ld    L, C 
152c			      ld    (HL), E 
152c			      inc   HL 
152c			      ld    (HL), D 
152c			 
152c			      ; Check if the freed block is adjacent to the next free block 
152c			      inc   HL                      ; Load size of freed block into HL 
152c			      ld    E, (HL) 
152c			      inc   HL 
152c			      ld    D, (HL) 
152c			      ex    DE, HL 
152c			 
152c			      add   HL, BC                  ; Add addr of freed block and its size 
152c			 
152c			      ld    E, (IX+0)               ; Load addr of next free block into DE 
152c			      ld    D, (IX+1) 
152c			 
152c			      or    A                       ; Clear the carry flag 
152c			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
152c			      jr    NZ, free_check_adjacent_to_prev 
152c			 
152c			      ; Freed block is adjacent to next, merge into one bigger block 
152c			      ex    DE, HL                  ; Load next ptr from next block into DE 
152c			      ld    E, (HL) 
152c			      inc   HL 
152c			      ld    D, (HL) 
152c			      push  HL                      ; Save ptr to next block for later 
152c			 
152c			      ld    H, B                    ; Store ptr from next block into freed block 
152c			      ld    L, C 
152c			      ld    (HL), E 
152c			      inc   HL 
152c			      ld    (HL), D 
152c			 
152c			      pop   HL                      ; Restore ptr to next block 
152c			      inc   HL                      ; Load size of next block into DE 
152c			      ld    E, (HL) 
152c			      inc   HL 
152c			      ld    D, (HL) 
152c			      push  DE                      ; Save next block size for later 
152c			 
152c			      ld    H, B                    ; Load size of freed block into HL 
152c			      ld    L, C 
152c			      inc   HL 
152c			      inc   HL 
152c			      ld    E, (HL) 
152c			      inc   HL 
152c			      ld    D, (HL) 
152c			      ex    DE, HL 
152c			 
152c			      pop   DE                      ; Restore size of next block 
152c			      add   HL, DE                  ; Add sizes of both blocks 
152c			      ex    DE, HL 
152c			 
152c			      ld    H, B                    ; Store new bigger size into freed block 
152c			      ld    L, C 
152c			      inc   HL 
152c			      inc   HL 
152c			      ld    (HL), E 
152c			      inc   HL 
152c			      ld    (HL), D 
152c			 
152c			free_check_adjacent_to_prev: 
152c			      ; Check if the freed block is adjacent to the prev free block 
152c			      ld    L, (IX+2)               ; Prev free block ptr into HL 
152c			      ld    H, (IX+3) 
152c			 
152c			      inc   HL                      ; Size of prev free block into DE 
152c			      inc   HL 
152c			      ld    E, (HL) 
152c			      inc   HL 
152c			      ld    D, (HL) 
152c			      dec   HL 
152c			      dec   HL 
152c			      dec   HL 
152c			 
152c			      add   HL, DE                  ; Add prev block addr and size 
152c			 
152c			      or    A                       ; Clear the carry flag 
152c			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
152c			      jr    NZ, free_done 
152c			 
152c			      ; Freed block is adjacent to prev, merge into one bigger block 
152c			      ld    H, B                    ; Load next ptr from freed block into DE 
152c			      ld    L, C 
152c			      ld    E, (HL) 
152c			      inc   HL 
152c			      ld    D, (HL) 
152c			      push  HL                      ; Save freed block ptr for later 
152c			 
152c			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
152c			      ld    H, (IX+3) 
152c			      ld    (HL), E 
152c			      inc   HL 
152c			      ld    (HL), D 
152c			 
152c			      pop   HL                      ; Restore freed block ptr 
152c			      inc   HL                      ; Load size of freed block into DE 
152c			      ld    E, (HL) 
152c			      inc   HL 
152c			      ld    D, (HL) 
152c			      push  DE                      ; Save freed block size for later 
152c			 
152c			      ld    L, (IX+2)               ; Load size of prev block into DE 
152c			      ld    H, (IX+3) 
152c			      inc   HL 
152c			      inc   HL 
152c			      ld    E, (HL) 
152c			      inc   HL 
152c			      ld    D, (HL) 
152c			 
152c			      pop   HL                      ; Add sizes of both blocks 
152c			      add   HL, DE 
152c			      ex    DE, HL 
152c			 
152c			      ld    L, (IX+2)               ; Store new bigger size into prev block 
152c			      ld    H, (IX+3) 
152c			      inc   HL 
152c			      inc   HL 
152c			      ld    (HL), E 
152c			      inc   HL 
152c			      ld    (HL), D 
152c			 
152c			free_done: 
152c			      ld    HL, 4                   ; Clean up stack frame 
152c			      add   HL, SP 
152c			      ld    SP, HL 
152c			 
152c			free_early_exit: 
152c			      pop   IX 
152c			      pop   DE 
152c			      pop   BC 
152c			 
152c			      ret 
152c			 
152c			 
152c			;      .org 0x8000 
152c			; 
152c			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
152c			 ;                 .dw   0 
152c			 
152c			endif 
152c			 
152c			 
152c			if MALLOC_4 
152c			 
152c			; My memory allocation code. Very very simple.... 
152c			; allocate space under 250 chars 
152c			 
152c			heap_init: 
152c				; init start of heap as zero 
152c				;  
152c			 
152c				ld hl, heap_start 
152c				ld a, 0 
152c				ld (hl), a      ; empty block 
152c				inc hl 
152c				ld a, 0 
152c				ld (hl), a      ; length of block 
152c				; write end of list 
152c				inc hl 
152c				ld a,(hl) 
152c				inc hl 
152c				ld a,(hl) 
152c				 
152c			 
152c				; init some malloc vars 
152c			 
152c				ld hl, 0 
152c				ld (free_list), hl       ; store last malloc location 
152c			 
152c				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
152c				ld a, 0 
152c				ld (hl), a 
152c			 
152c			 
152c				ld hl, heap_start 
152c				;  
152c				  
152c				ret 
152c			 
152c			 
152c			;    free block marker 
152c			;    requested size  
152c			;    pointer to next block 
152c			;    .... 
152c			;    next block marker 
152c			 
152c			 
152c			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
152c			; 
152c			 
152c			 
152c			malloc:  
152c				push de 
152c				push bc 
152c				push af 
152c			 
152c				; hl space required 
152c				 
152c				ld c, l    ; hold space   (TODO only a max of 255) 
152c			 
152c			;	inc c     ; TODO BUG need to fix memory leak on push str 
152c			;	inc c 
152c			;	inc c 
152c			;	inc c 
152c			;	inc c 
152c			;	inc c 
152c			;	inc c 
152c			 
152c			 
152c			 
152c				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
152c			 
152c				ld a, (free_list+3) 
152c				cp 0 
152c				jr z, .contheap 
152c			 
152c				ld hl, (free_list)     ; get last alloc 
152c					if DEBUG_FORTH_MALLOC_INT 
152c						DMARK "mrs" 
152c						CALLMONITOR 
152c					endif 
152c				jr .startalloc 
152c			 
152c			.contheap: 
152c				ld hl, heap_start 
152c			 
152c			.startalloc: 
152c			 
152c					if DEBUG_FORTH_MALLOC_INT 
152c						DMARK "mym" 
152c						CALLMONITOR 
152c					endif 
152c			.findblock: 
152c					if DEBUG_FORTH_MALLOC_INT 
152c						DMARK "mmf" 
152c						CALLMONITOR 
152c					endif 
152c			 
152c				ld a,(hl)  
152c				; if byte is zero then clear to use 
152c			 
152c				cp 0 
152c				jr z, .foundemptyblock 
152c			 
152c				; if byte is not clear 
152c				;     then byte is offset to next block 
152c			 
152c				inc hl 
152c				ld a, (hl) ; get size 
152c			.nextblock:	inc hl 
152c					ld e, (hl) 
152c					inc hl 
152c					ld d, (hl) 
152c					ex de, hl 
152c			;	inc hl  ; move past the store space 
152c			;	inc hl  ; move past zero index  
152c			 
152c				; TODO detect no more space 
152c			 
152c				push hl 
152c				ld de, heap_end 
152c				call cmp16 
152c				pop hl 
152c				jr nc, .nospace 
152c			 
152c				jr .findblock 
152c			 
152c			.nospace: ld hl, 0 
152c				jp .exit 
152c			 
152c			 
152c			.foundemptyblock:	 
152c					if DEBUG_FORTH_MALLOC_INT 
152c						DMARK "mme" 
152c						CALLMONITOR 
152c					endif 
152c			 
152c			; TODO has block enough space if reusing??? 
152c			 
152c				;  
152c			 
152c			; see if this block has been previously used 
152c				inc hl 
152c				ld a, (hl) 
152c				dec hl 
152c				cp 0 
152c				jr z, .newblock 
152c			 
152c					if DEBUG_FORTH_MALLOC_INT 
152c						DMARK "meR" 
152c						CALLMONITOR 
152c					endif 
152c			 
152c			; no reusing previously allocated block 
152c			 
152c			; is it smaller than previously used? 
152c				 
152c				inc hl    ; move to size 
152c				ld a, c 
152c				sub (hl)        ; we want c < (hl) 
152c				dec hl    ; move back to marker 
152c			        jr z, .findblock 
152c			 
152c				; update with the new size which should be lower 
152c			 
152c			        ;inc  hl   ; negate next move. move back to size  
152c			 
152c			.newblock: 
152c				; need to be at marker here 
152c			 
152c					if DEBUG_FORTH_MALLOC_INT 
152c						DMARK "meN" 
152c						CALLMONITOR 
152c					endif 
152c			 
152c			 
152c				ld a, c 
152c			 
152c				ld (free_list+3), a	 ; flag resume from last malloc  
152c				ld (free_list), hl    ; save out last location 
152c			 
152c			 
152c				;inc a     ; space for length byte 
152c				ld (hl), a     ; save block in use marker 
152c			 
152c				inc hl   ; move to space marker 
152c				ld (hl), a    ; save new space 
152c			 
152c				inc hl   ; move to start of allocated area 
152c				 
152c			;	push hl     ; save where we are - 1  
152c			 
152c			;	inc hl  ; move past zero index  
152c				; skip space to set down new marker 
152c			 
152c				; provide some extra space for now 
152c			 
152c				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
152c				inc a 
152c				inc a 
152c			 
152c				push hl   ; save where we are in the node block 
152c			 
152c				call addatohl 
152c			 
152c				; write linked list point 
152c			 
152c				pop de     ; get our node position 
152c				ex de, hl 
152c			 
152c				ld (hl), e 
152c				inc hl 
152c				ld (hl), d 
152c			 
152c				inc hl 
152c			 
152c				; now at start of allocated data so save pointer 
152c			 
152c				push hl 
152c			 
152c				; jump to position of next node and setup empty header in DE 
152c			 
152c				ex de, hl 
152c			 
152c			;	inc hl ; move past end of block 
152c			 
152c				ld a, 0 
152c				ld (hl), a   ; empty marker 
152c				inc hl 
152c				ld (hl), a   ; size 
152c				inc hl  
152c				ld (hl), a   ; ptr 
152c				inc hl 
152c				ld (hl), a   ; ptr 
152c			 
152c			 
152c				pop hl 
152c			 
152c					if DEBUG_FORTH_MALLOC_INT 
152c						DMARK "mmr" 
152c						CALLMONITOR 
152c					endif 
152c			 
152c			.exit: 
152c				pop af 
152c				pop bc 
152c				pop de  
152c				ret 
152c			 
152c			 
152c			 
152c			 
152c			free:  
152c				push hl 
152c				push af 
152c				; get address in hl 
152c			 
152c					if DEBUG_FORTH_MALLOC_INT 
152c						DMARK "fre" 
152c						CALLMONITOR 
152c					endif 
152c				; data is at hl - move to block count 
152c				dec hl 
152c				dec hl    ; get past pointer 
152c				dec hl 
152c			 
152c				ld a, (hl)    ; need this for a validation check 
152c			 
152c				dec hl    ; move to block marker 
152c			 
152c				; now check that the block count and block marker are the same  
152c			        ; this checks that we are on a malloc node and not random memory 
152c			        ; OK a faint chance this could be a problem but rare - famous last words! 
152c			 
152c				ld c, a 
152c				ld a, (hl)    
152c			 
152c				cp c 
152c				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
152c			 
152c				; yes good chance we are on a malloc node 
152c			 
152c				ld a, 0      
152c				ld (hl), a   ; mark as free 
152c			 
152c				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
152c			 
152c			.freeignore:  
152c			 
152c				pop af 
152c				pop hl 
152c			 
152c				ret 
152c			 
152c			 
152c			 
152c			endif 
152c			 
152c			; eof 
# End of file firmware_memory.asm
152c			  
152c			; device C  
152c			if SOUND_ENABLE  
152c				include "firmware_sound.asm"  
152c			; Sound abstraction layer 
152c			 
152c			; support different sound chips through common interface 
152c			 
152c			SOUND_DEVICE_AY: equ 0 
152c			 
152c			SOUND_DEVICE: equ Device_A 
152c			 
152c			 
152c			 
152c			if SOUND_DEVICE_AY 
152c				include "firmware_sound_ay38910.asm" 
152c			else 
152c				include "firmware_sound_sn76489an.asm" 
152c			 
152c			; Device support for SN76489AN sound chip 
152c			 
152c			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
152c			; http://danceswithferrets.org/geekblog/?p=93 
152c			; https://www.smspower.org/Development/SN76489 
152c			 
152c			; D0 [ 3] 
152c			; D1 [ 2] 
152c			; D2 [ 1] 
152c			; D3 [15] 
152c			; D4 [13] 
152c			; D5 [12] 
152c			; D6 [11] 
152c			; D7 [10] 
152c			; /WE [ 5] 
152c			; CLK [14] 
152c			; /OE [ 6] 
152c			; AUDIO [ 7] 
152c			; GND 8 
152c			; +5 16 
152c			; 
152c			 
152c			; Write sequence: 
152c			; CE low 
152c			; Data bus 
152c			; WE low then high 
152c			; 32 clock cycles / 8ns write time at 4mhz 
152c			; 
152c			; https://github.com/jblang/SN76489 
152c			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
152c			; Tried: 
152c			; 
152c			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
152c			; 
152c			; Connected WE to OR too 
152c			;  
152c			; That enabled the clock when required 
152c			; However still random bus corruption. Need further investigation 
152c			 
152c			 
152c			SOUND_LATCH: equ 10000000B 
152c			SOUND_DATA: equ 0B 
152c			SOUND_CH0:  equ 0B    ; Tone 
152c			SOUND_CH1: equ 0100000B        ; Tone 
152c			SOUND_CH2: equ 1000000B   ; Tone 
152c			SOUND_CH3: equ 1100000B    ; Noise 
152c			SOUND_VOL: equ 10000B 
152c			SOUND_TONE: equ 0B 
152c			 
152c			 
152c			sound_init: 
152c 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
152e cd 43 15			call note_send_byte 
1531 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
1533 cd 43 15			call note_send_byte 
1536 cd 09 0c			call delay250ms 
1539 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
153b cd 43 15			call note_send_byte 
153e cd 09 0c			call delay250ms 
1541 c9				ret 
1542			 
1542			; Play a note 
1542			; h = note 
1542			; l = duration 
1542			; a = channel 
1542			 
1542			 
1542			;  frequ = clock / ( 2 x reg valu x 32 )  
1542			 
1542			note:  
1542				 
1542			 
1542 c9				ret 
1543			 
1543			note_send_byte: 
1543				; byte in a 
1543			 
1543				; we high 
1543 d3 40			out (Device_B), a 
1545			;	ld a, 1 
1545			;	call aDelayInMS 
1545 00				nop  
1546 00				nop  
1547 00				nop  
1548 00				nop  
1549				; we low 
1549 d3 40			out (Device_B), a 
154b			;	ld a, 1 
154b			;	call aDelayInMS 
154b 00				nop  
154c 00				nop  
154d 00				nop  
154e 00				nop  
154f				; we high 
154f d3 40			out (Device_B), a 
1551			;	ld a, 1 
1551			;	call aDelayInMS 
1551 00				nop  
1552 00				nop  
1553 00				nop  
1554 00				nop  
1555			 
1555			 
1555 c9				ret 
1556			 
1556			;void SilenceAllChannels() 
1556			;{ 
1556			;  SendByte(0x9f); 
1556			;  SendByte(0xbf); 
1556			;  SendByte(0xdf); 
1556			;  SendByte(0xff); 
1556			;} 
1556			 
1556			 
1556			; eof 
1556			 
# End of file firmware_sound_sn76489an.asm
1556			endif 
1556			 
1556			 
1556			; Abstraction entry points 
1556			 
1556			; init  
1556			 
1556			; sound_init in specific hardware files 
1556			 
1556			; Play a note 
1556			; h = note 
1556			; l = duration 
1556			; a = channel 
1556			 
1556			;note:     
1556			;	ret 
1556			 
1556			 
1556			 
1556			 
1556			; eof 
1556			 
# End of file firmware_sound.asm
1556			endif  
1556			  
1556			include "firmware_diags.asm"  
1556			; Hardware diags menu 
1556			 
1556			 
1556			config: 
1556			 
1556 3e 00			ld a, 0 
1558 21 86 15			ld hl, .configmn 
155b cd c9 0c			call menu 
155e			 
155e fe 00			cp 0 
1560 c8				ret z 
1561			 
1561 fe 01			cp 1 
1563 cc 5f 16			call z, .savetostore 
1566			 
1566 fe 02			cp 2 
1568 cc ad 15			call z, .selautoload 
156b fe 03			cp 3 
156d cc 96 15			call z, .disautoload 
1570 fe 04			cp 4 
1572 cc 5d 16			call z, .selbank 
1575 fe 05			cp 5 
1577 cc 3a 17			call z, .debug_tog 
157a fe 06			cp 6 
157c cc 7d 18			call z, .bpsgo 
157f fe 07			cp 7 
1581 cc 60 17			call z, hardware_diags 
1584			 
1584 18 d0			jr config 
1586			 
1586			.configmn: 
1586 6e 1a			dw prom_c3 
1588 85 1a			dw prom_c2 
158a 9a 1a			dw prom_c2a 
158c b0 1a			dw prom_c2b 
158e			;	dw prom_c4 
158e cd 1a			dw prom_m4 
1590 e8 1a			dw prom_m4b 
1592 f0 1a			dw prom_c1 
1594 00 00			dw 0 
1596				 
1596			 
1596			 
1596			 
1596			.disautoload: 
1596				if STORAGE_SE 
1596 3e fe			ld a, $fe      ; bit 0 clear 
1598 32 6a fa			ld (spi_device), a 
159b			 
159b cd 85 04			call storage_get_block_0 
159e			 
159e 3e 00			ld a, 0 
15a0 32 a2 fa			ld (store_page+STORE_0_AUTOFILE), a 
15a3			 
15a3 21 00 00				ld hl, 0 
15a6 11 81 fa				ld de, store_page 
15a9 cd 39 04			call storage_write_block	 ; save update 
15ac				else 
15ac			 
15ac				ld hl, prom_notav 
15ac				ld de, prom_empty 
15ac				call info_panel 
15ac				endif 
15ac			 
15ac			 
15ac c9				ret 
15ad			 
15ad			 
15ad			 
15ad			; Select auto start 
15ad			 
15ad			.selautoload: 
15ad			 
15ad				 
15ad				if STORAGE_SE 
15ad			 
15ad cd 84 16				call config_dir 
15b0 21 ff f1			        ld hl, scratch 
15b3 3e 00				ld a, 0 
15b5 cd c9 0c				call menu 
15b8			 
15b8 fe 00				cp 0 
15ba c8					ret z 
15bb			 
15bb 3d					dec a 
15bc			 
15bc			 
15bc					; locate menu option 
15bc			 
15bc 21 ff f1				ld hl, scratch 
15bf cd ed 0b				call table_lookup 
15c2			 
15c2					if DEBUG_FORTH_WORDS 
15c2						DMARK "ALl" 
15c2 f5				push af  
15c3 3a d7 15			ld a, (.dmark)  
15c6 32 6e fe			ld (debug_mark),a  
15c9 3a d8 15			ld a, (.dmark+1)  
15cc 32 6f fe			ld (debug_mark+1),a  
15cf 3a d9 15			ld a, (.dmark+2)  
15d2 32 70 fe			ld (debug_mark+2),a  
15d5 18 03			jr .pastdmark  
15d7 ..			.dmark: db "ALl"  
15da f1			.pastdmark: pop af  
15db			endm  
# End of macro DMARK
15db						CALLMONITOR 
15db cd 73 18			call break_point_state  
15de				endm  
# End of macro CALLMONITOR
15de					endif 
15de					; with the pointer to the menu it, the byte following the zero term is the file id 
15de			 
15de 3e 00				ld a, 0 
15e0 01 32 00				ld bc, 50   ; max of bytes to look at 
15e3 ed b1				cpir  
15e5			 
15e5					if DEBUG_FORTH_WORDS 
15e5						DMARK "ALb" 
15e5 f5				push af  
15e6 3a fa 15			ld a, (.dmark)  
15e9 32 6e fe			ld (debug_mark),a  
15ec 3a fb 15			ld a, (.dmark+1)  
15ef 32 6f fe			ld (debug_mark+1),a  
15f2 3a fc 15			ld a, (.dmark+2)  
15f5 32 70 fe			ld (debug_mark+2),a  
15f8 18 03			jr .pastdmark  
15fa ..			.dmark: db "ALb"  
15fd f1			.pastdmark: pop af  
15fe			endm  
# End of macro DMARK
15fe						CALLMONITOR 
15fe cd 73 18			call break_point_state  
1601				endm  
# End of macro CALLMONITOR
1601					endif 
1601					;inc hl 
1601			 
1601 7e					ld a, (hl)   ; file id 
1602					 
1602				        ; save bank and file ids 
1602			 
1602 f5					push af 
1603			 
1603			; TODO need to save to block 0 on bank 1	 
1603			 
1603 cd 85 04				call storage_get_block_0 
1606			 
1606					if DEBUG_FORTH_WORDS 
1606						DMARK "AL0" 
1606 f5				push af  
1607 3a 1b 16			ld a, (.dmark)  
160a 32 6e fe			ld (debug_mark),a  
160d 3a 1c 16			ld a, (.dmark+1)  
1610 32 6f fe			ld (debug_mark+1),a  
1613 3a 1d 16			ld a, (.dmark+2)  
1616 32 70 fe			ld (debug_mark+2),a  
1619 18 03			jr .pastdmark  
161b ..			.dmark: db "AL0"  
161e f1			.pastdmark: pop af  
161f			endm  
# End of macro DMARK
161f						CALLMONITOR 
161f cd 73 18			call break_point_state  
1622				endm  
# End of macro CALLMONITOR
1622					endif 
1622 f1					pop af 
1623			 
1623 32 a5 fa				ld (store_page+STORE_0_FILERUN),a 
1626					 
1626					; save bank id 
1626			 
1626 3a 6a fa				ld a,(spi_device) 
1629 32 a4 fa				ld (store_page+STORE_0_BANKRUN),a 
162c			 
162c					; enable auto run of store file 
162c			 
162c 3e 01				ld a, 1 
162e 32 a2 fa				ld (store_page+STORE_0_AUTOFILE),a 
1631			 
1631					; save buffer 
1631			 
1631 21 00 00				ld hl, 0 
1634 11 81 fa				ld de, store_page 
1637					if DEBUG_FORTH_WORDS 
1637						DMARK "ALw" 
1637 f5				push af  
1638 3a 4c 16			ld a, (.dmark)  
163b 32 6e fe			ld (debug_mark),a  
163e 3a 4d 16			ld a, (.dmark+1)  
1641 32 6f fe			ld (debug_mark+1),a  
1644 3a 4e 16			ld a, (.dmark+2)  
1647 32 70 fe			ld (debug_mark+2),a  
164a 18 03			jr .pastdmark  
164c ..			.dmark: db "ALw"  
164f f1			.pastdmark: pop af  
1650			endm  
# End of macro DMARK
1650						CALLMONITOR 
1650 cd 73 18			call break_point_state  
1653				endm  
# End of macro CALLMONITOR
1653					endif 
1653 cd 39 04			call storage_write_block	 ; save update 
1656			  
1656			 
1656			 
1656			 
1656 21 ff f1				ld hl, scratch 
1659 cd 71 16				call config_fdir 
165c			 
165c				else 
165c			 
165c				ld hl, prom_notav 
165c				ld de, prom_empty 
165c				call info_panel 
165c			 
165c				endif 
165c c9				ret 
165d			 
165d			 
165d			 
165d			; Select storage bank 
165d			 
165d			.selbank: 
165d			 
165d				if STORAGE_SE 
165d				else 
165d			 
165d				ld hl, prom_notav 
165d				ld de, prom_empty 
165d				call info_panel 
165d				endif 
165d				 
165d c9				ret 
165e			 
165e			if STORAGE_SE 
165e			 
165e			.config_ldir:   
165e				; Load storage bank labels into menu array 
165e			 
165e				 
165e			 
165e			 
165e c9				ret 
165f			 
165f			 
165f			endif 
165f			 
165f			 
165f			; Save user words to storage 
165f			 
165f			.savetostore: 
165f			 
165f				if STORAGE_SE 
165f			 
165f cd 84 16				call config_dir 
1662 21 ff f1			        ld hl, scratch 
1665 3e 00				ld a, 0 
1667 cd c9 0c				call menu 
166a					 
166a 21 ff f1				ld hl, scratch 
166d cd 71 16				call config_fdir 
1670			 
1670				else 
1670			 
1670				ld hl, prom_notav 
1670				ld de, prom_empty 
1670				call info_panel 
1670			 
1670				endif 
1670			 
1670 c9				ret 
1671			 
1671			 
1671			 
1671			if STORAGE_SE 
1671			 
1671			config_fdir: 
1671				; using the scratch dir go through and release the memory allocated for each string 
1671				 
1671 21 ff f1			ld hl, scratch 
1674 5e			.cfdir:	ld e,(hl) 
1675 23				inc hl 
1676 56				ld d,(hl) 
1677 23				inc hl 
1678			 
1678 eb				ex de, hl 
1679 cd f5 0e			call ishlzero 
167c c8				ret z     ; return on null pointer 
167d cd 5d 14			call free 
1680 eb				ex de, hl 
1681 18 f1			jr .cfdir 
1683			 
1683			 
1683 c9				ret 
1684			 
1684			 
1684			config_dir: 
1684			 
1684				; for the config menus that need to build a directory of storage call this routine 
1684				; it will construct a menu in scratch to pass to menu 
1684			 
1684				; open storage device 
1684			 
1684				; execute DIR to build a list of files and their ids into scratch in menu format 
1684				; once the menu has finished then will need to call config_fdir to release the strings 
1684				 
1684				; c = number items 
1684			 
1684				 
1684 cd 85 04			call storage_get_block_0 
1687			 
1687 21 81 fa			ld hl, store_page     ; get current id count 
168a 46				ld b, (hl) 
168b 0e 00			ld c, 0    ; count of files   
168d			 
168d			 
168d 21 ff f1			ld hl, scratch 
1690 22 78 fa			ld (store_tmp2), hl    ; location to poke strings 
1693			 
1693				; check for empty drive 
1693			 
1693 3e 00			ld a, 0 
1695 b8				cp b 
1696 ca 30 17			jp z, .dirdone 
1699			 
1699				 
1699					if DEBUG_FORTH_WORDS 
1699						DMARK "Cdc" 
1699 f5				push af  
169a 3a ae 16			ld a, (.dmark)  
169d 32 6e fe			ld (debug_mark),a  
16a0 3a af 16			ld a, (.dmark+1)  
16a3 32 6f fe			ld (debug_mark+1),a  
16a6 3a b0 16			ld a, (.dmark+2)  
16a9 32 70 fe			ld (debug_mark+2),a  
16ac 18 03			jr .pastdmark  
16ae ..			.dmark: db "Cdc"  
16b1 f1			.pastdmark: pop af  
16b2			endm  
# End of macro DMARK
16b2						CALLMONITOR 
16b2 cd 73 18			call break_point_state  
16b5				endm  
# End of macro CALLMONITOR
16b5					endif 
16b5			 
16b5			 
16b5			.diritem:	 
16b5 c5				push bc 
16b6				; for each of the current ids do a search for them and if found push to stack 
16b6			 
16b6 21 40 00				ld hl, STORE_BLOCK_PHY 
16b9 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
16bb 58					ld e,b 
16bc			 
16bc cd 07 07				call storage_findnextid 
16bf			 
16bf			 
16bf					; if found hl will be non zero 
16bf			 
16bf cd f5 0e				call ishlzero 
16c2 28 69				jr z, .dirnotfound 
16c4			 
16c4					; increase count 
16c4			 
16c4 c1					pop bc	 
16c5 0c					inc c 
16c6 c5					push bc 
16c7					 
16c7			 
16c7					; get file header and push the file name 
16c7			 
16c7 11 81 fa				ld de, store_page 
16ca cd d4 03				call storage_read_block 
16cd			 
16cd					; push file id to stack 
16cd				 
16cd 3a 81 fa				ld a, (store_page) 
16d0 26 00				ld h, 0 
16d2 6f					ld l, a 
16d3			 
16d3					;call forth_push_numhl 
16d3					; TODO store id 
16d3			 
16d3 e5					push hl 
16d4			 
16d4					; push extent count to stack  
16d4				 
16d4 21 84 fa				ld hl, store_page+3 
16d7			 
16d7					; get file name length 
16d7			 
16d7 cd 2a 13				call strlenz   
16da			 
16da 23					inc hl   ; cover zero term 
16db 23					inc hl  ; stick the id at the end of the area 
16dc			 
16dc e5					push hl 
16dd c1					pop bc    ; move length to bc 
16de			 
16de cd 93 13				call malloc 
16e1			 
16e1					; TODO save malloc area to scratch 
16e1			 
16e1 eb					ex de, hl 
16e2 2a 78 fa				ld hl, (store_tmp2) 
16e5 73					ld (hl), e 
16e6 23					inc hl 
16e7 72					ld (hl), d 
16e8 23					inc hl 
16e9 22 78 fa				ld (store_tmp2), hl 
16ec			 
16ec					 
16ec			 
16ec					;pop hl   ; get source 
16ec			;		ex de, hl    ; swap aronund	 
16ec			 
16ec 21 84 fa				ld hl, store_page+3 
16ef					if DEBUG_FORTH_WORDS 
16ef						DMARK "CFd" 
16ef f5				push af  
16f0 3a 04 17			ld a, (.dmark)  
16f3 32 6e fe			ld (debug_mark),a  
16f6 3a 05 17			ld a, (.dmark+1)  
16f9 32 6f fe			ld (debug_mark+1),a  
16fc 3a 06 17			ld a, (.dmark+2)  
16ff 32 70 fe			ld (debug_mark+2),a  
1702 18 03			jr .pastdmark  
1704 ..			.dmark: db "CFd"  
1707 f1			.pastdmark: pop af  
1708			endm  
# End of macro DMARK
1708						CALLMONITOR 
1708 cd 73 18			call break_point_state  
170b				endm  
# End of macro CALLMONITOR
170b					endif 
170b ed b0				ldir 
170d			 
170d					; de is past string, move back one and store id 
170d					 
170d 1b					dec de 
170e			 
170e					; store file id 
170e			 
170e e1					pop hl 
170f eb					ex de,hl 
1710 73					ld (hl), e 
1711			 
1711					if DEBUG_FORTH_WORDS 
1711						DMARK "Cdi" 
1711 f5				push af  
1712 3a 26 17			ld a, (.dmark)  
1715 32 6e fe			ld (debug_mark),a  
1718 3a 27 17			ld a, (.dmark+1)  
171b 32 6f fe			ld (debug_mark+1),a  
171e 3a 28 17			ld a, (.dmark+2)  
1721 32 70 fe			ld (debug_mark+2),a  
1724 18 03			jr .pastdmark  
1726 ..			.dmark: db "Cdi"  
1729 f1			.pastdmark: pop af  
172a			endm  
# End of macro DMARK
172a						CALLMONITOR 
172a cd 73 18			call break_point_state  
172d				endm  
# End of macro CALLMONITOR
172d					endif 
172d					 
172d			.dirnotfound: 
172d c1					pop bc     
172e 10 85				djnz .diritem 
1730				 
1730			.dirdone:	 
1730			 
1730 3e 00				ld a, 0 
1732 2a 78 fa				ld hl, (store_tmp2) 
1735 77					ld (hl), a 
1736 23					inc hl 
1737 77					ld (hl), a 
1738 23					inc hl 
1739					; push a count of the dir items found 
1739			 
1739			;		ld h, 0 
1739			;		ld l, c 
1739			 
1739 c9				ret 
173a			 
173a			endif 
173a			 
173a			 
173a			; Settings 
173a			; Run  
173a			 
173a			 
173a			 
173a			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
173a			;;hd_menu2:   db "        2: Editor",0   
173a			;hd_menu2:   db "        2: Editor       6: Menu",0   
173a			;hd_menu3:   db "        3: Storage",0 
173a			;hd_menu4:   db "0=quit  4: Debug",0 
173a			;hd_don:     db "ON",0 
173a			;hd_doff:     db "OFF",0 
173a			; 
173a			; 
173a			; 
173a			;hardware_diags_old:       
173a			; 
173a			;.diagmenu: 
173a			;	call clear_display 
173a			;	ld a, display_row_1 
173a			;	ld de, hd_menu1 
173a			;	call str_at_display 
173a			; 
173a			;	ld a, display_row_2 
173a			;	ld de, hd_menu2 
173a			;	call str_at_display 
173a			; 
173a			;	ld a, display_row_3 
173a			;	ld de, hd_menu3 
173a			;	call str_at_display 
173a			; 
173a			;	ld a,  display_row_4 
173a			;	ld de, hd_menu4 
173a			;	call str_at_display 
173a			; 
173a			;	; display debug state 
173a			; 
173a			;	ld de, hd_don 
173a			;	ld a, (os_view_disable) 
173a			;	cp 0 
173a			;	jr z, .distog 
173a			;	ld de, hd_doff 
173a			;.distog: ld a, display_row_4+17 
173a			;	call str_at_display 
173a			; 
173a			;	call update_display 
173a			; 
173a			;	call cin_wait 
173a			; 
173a			; 
173a			; 
173a			;	cp '4' 
173a			;	jr nz, .diagn1 
173a			; 
173a			;	; debug toggle 
173a			; 
173a			;	ld a, (os_view_disable) 
173a			;	ld b, '*' 
173a			;	cp 0 
173a			;	jr z, .debtog 
173a			;	ld b, 0 
173a			;.debtog:	 
173a			;	ld a,b 
173a			;	ld (os_view_disable),a 
173a			; 
173a			;.diagn1: cp '0' 
173a			;	 ret z 
173a			; 
173a			;;	cp '1' 
173a			;;       jp z, matrix	 
173a			;;   TODO keyboard matrix test 
173a			; 
173a			;	cp '2' 
173a			;	jp z, .diagedit 
173a			; 
173a			;;	cp '6' 
173a			;;	jp z, .menutest 
173a			;;if ENABLE_BASIC 
173a			;;	cp '6' 
173a			;;	jp z, basic 
173a			;;endif 
173a			 ; 
173a			;	jp .diagmenu 
173a			; 
173a			; 
173a			;	ret 
173a			 
173a			 
173a			.debug_tog: 
173a 21 81 17			ld hl, .menudebug 
173d				 
173d 3a f0 f1			ld a, (os_view_disable) 
1740 fe 2a			cp '*' 
1742 20 04			jr nz,.tdon  
1744 3e 01			ld a, 1 
1746 18 02			jr .tog1 
1748 3e 00		.tdon: ld a, 0 
174a			 
174a			.tog1: 
174a cd c9 0c			call menu 
174d fe 00			cp 0 
174f c8				ret z 
1750 fe 01			cp 1    ; disable debug 
1752 28 04			jr z, .dtog0 
1754 3e 2a			ld a, '*' 
1756 18 02			jr .dtogset 
1758 3e 00		.dtog0: ld a, 0 
175a 32 f0 f1		.dtogset:  ld (os_view_disable), a 
175d c3 3a 17			jp .debug_tog 
1760			 
1760			 
1760			hardware_diags:       
1760			 
1760			.diagm: 
1760 21 73 17			ld hl, .menuitems 
1763 3e 00			ld a, 0 
1765 cd c9 0c			call menu 
1768			 
1768 fe 00		         cp 0 
176a c8				 ret z 
176b			 
176b fe 02			cp 2 
176d ca cc 17			jp z, .diagedit 
1770			 
1770			;	cp '6' 
1770			;	jp z, .menutest 
1770			;if ENABLE_BASIC 
1770			;	cp '6' 
1770			;	jp z, basic 
1770			;endif 
1770			  
1770 c3 60 17			jp .diagm 
1773			 
1773				 
1773 87 17		.menuitems:   	dw .m1 
1775 92 17				dw .m2 
1777 99 17				dw .m3 
1779 a1 17				dw .m5 
177b a7 17				dw .m5a 
177d b0 17				dw .m5b 
177f 00 00				dw 0 
1781			 
1781			.menudebug: 
1781 b9 17				dw .m6 
1783 c2 17				dw .m7 
1785 00 00				dw 0 
1787			 
1787 .. 00		.m1:   db "Key Matrix",0 
1792 .. 00		.m2:   db "Editor",0 
1799 .. 00		.m3:   db "Storage",0 
17a1 .. 00		.m5:   db "Sound",0 
17a7 .. 00		.m5a:  db "RAM Test",0 
17b0 .. 00		.m5b:  db "LCD Test",0 
17b9			 
17b9 .. 00		.m6:   db "Debug ON",0 
17c2 .. 00		.m7:   db "Debug OFF",0 
17cc			 
17cc			; debug editor 
17cc			 
17cc			.diagedit: 
17cc			 
17cc 21 ff f1			ld hl, scratch 
17cf			;	ld bc, 250 
17cf			;	ldir 
17cf				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
17cf 3e 00			ld a, 0 
17d1 77				ld (hl), a 
17d2 23				inc hl 
17d3 77				ld (hl), a 
17d4 23				inc hl 
17d5 77				ld (hl), a 
17d6			 
17d6 cd 98 0c		        call clear_display 
17d9 cd bb 0c			call update_display 
17dc				;ld a, 1 
17dc				;ld (hardware_diag), a 
17dc			.diloop: 
17dc 3e 00			ld a, display_row_1 
17de 0e 00			ld c, 0 
17e0 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
17e2 1e 28			ld e, 40 
17e4			 
17e4 21 ff f1			ld hl, scratch	 
17e7 cd f9 0e			call input_str 
17ea			 
17ea 3e 28			ld a, display_row_2 
17ec 11 ff f1			ld de, scratch 
17ef cd ab 0c			call str_at_display 
17f2 cd bb 0c			call update_display 
17f5			 
17f5 c3 dc 17			jp .diloop 
17f8			 
17f8			 
17f8			; pass word in hl 
17f8			; a has display location 
17f8			display_word_at: 
17f8 f5				push af 
17f9 e5				push hl 
17fa 7c				ld a,h 
17fb 21 04 f5			ld hl, os_word_scratch 
17fe cd cd 11			call hexout 
1801 e1				pop hl 
1802 7d				ld a,l 
1803 21 06 f5			ld hl, os_word_scratch+2 
1806 cd cd 11			call hexout 
1809 21 08 f5			ld hl, os_word_scratch+4 
180c 3e 00			ld a,0 
180e 77				ld (hl),a 
180f 11 04 f5			ld de,os_word_scratch 
1812 f1				pop af 
1813 cd ab 0c				call str_at_display 
1816 c9				ret 
1817			 
1817			display_ptr_state: 
1817			 
1817				; to restore afterwards 
1817			 
1817 d5				push de 
1818 c5				push bc 
1819 e5				push hl 
181a f5				push af 
181b			 
181b				; for use in here 
181b			 
181b			;	push bc 
181b			;	push de 
181b			;	push hl 
181b			;	push af 
181b			 
181b cd 98 0c			call clear_display 
181e			 
181e 11 f1 19			ld de, .ptrstate 
1821 3e 00			ld a, display_row_1 
1823 cd ab 0c			call str_at_display 
1826			 
1826				; display debug step 
1826			 
1826			 
1826 11 6e fe			ld de, debug_mark 
1829 3e 26			ld a, display_row_1+display_cols-2 
182b cd ab 0c			call str_at_display 
182e			 
182e				; display a 
182e 11 fb 19			ld de, .ptrcliptr 
1831 3e 28			ld a, display_row_2 
1833 cd ab 0c			call str_at_display 
1836			 
1836 f1				pop af 
1837 2a 4a fa			ld hl,(cli_ptr) 
183a 3e 30			ld a, display_row_2+8 
183c cd f8 17			call display_word_at 
183f			 
183f			 
183f				; display hl 
183f			 
183f			 
183f 11 03 1a			ld de, .ptrclioptr 
1842 3e 32			ld a, display_row_2+10 
1844 cd ab 0c			call str_at_display 
1847			; 
1847			;	pop hl 
1847 3e 35			ld a, display_row_2+13 
1849 2a 48 fa			ld hl,(cli_origptr) 
184c cd f8 17			call display_word_at 
184f			; 
184f			;	 
184f			;	; display de 
184f			 
184f			;	ld de, .regstatede 
184f			;	ld a, display_row_3 
184f			;	call str_at_display 
184f			 
184f			;	pop de 
184f			;	ld h,d 
184f			;	ld l, e 
184f			;	ld a, display_row_3+3 
184f			;	call display_word_at 
184f			 
184f			 
184f				; display bc 
184f			 
184f			;	ld de, .regstatebc 
184f			;	ld a, display_row_3+10 
184f			;	call str_at_display 
184f			 
184f			;	pop bc 
184f			;	ld h,b 
184f			;	ld l, c 
184f			;	ld a, display_row_3+13 
184f			;	call display_word_at 
184f			 
184f			 
184f				; display dsp 
184f			 
184f			;	ld de, .regstatedsp 
184f			;	ld a, display_row_4 
184f			;	call str_at_display 
184f			 
184f				 
184f			;	ld hl,(cli_data_sp) 
184f			;	ld a, display_row_4+4 
184f			;	call display_word_at 
184f			 
184f				; display rsp 
184f			 
184f 11 32 1a			ld de, .regstatersp 
1852 3e 82			ld a, display_row_4+10 
1854 cd ab 0c			call str_at_display 
1857			 
1857				 
1857 2a 30 fa			ld hl,(cli_ret_sp) 
185a 3e 86			ld a, display_row_4+14 
185c cd f8 17			call display_word_at 
185f			 
185f cd bb 0c			call update_display 
1862			 
1862 cd 15 0c			call delay1s 
1865 cd 15 0c			call delay1s 
1868 cd 15 0c			call delay1s 
186b			 
186b			 
186b cd 5f 1e			call next_page_prompt 
186e			 
186e				; restore  
186e			 
186e f1				pop af 
186f e1				pop hl 
1870 c1				pop bc 
1871 d1				pop de 
1872 c9				ret 
1873			 
1873			break_point_state: 
1873 f5				push af 
1874			 
1874				; see if disabled 
1874			 
1874 3a f0 f1			ld a, (os_view_disable) 
1877 fe 2a			cp '*' 
1879 20 02			jr nz, .bpsgo 
187b f1				pop af 
187c c9				ret 
187d			 
187d			.bpsgo: 
187d f1				pop af 
187e f5				push af 
187f 22 ec f1			ld (os_view_hl), hl 
1882 ed 53 ea f1		ld (os_view_de), de 
1886 ed 43 e8 f1		ld (os_view_bc), bc 
188a e5				push hl 
188b 6f				ld l, a 
188c 26 00			ld h, 0 
188e 22 ee f1			ld (os_view_af),hl 
1891			 
1891 21 b4 fd				ld hl, display_fb0 
1894 22 cf fb				ld (display_fb_active), hl 
1897 e1				pop hl	 
1898			 
1898 3e 31			ld a, '1' 
189a fe 2a		.bps1:  cp '*' 
189c 20 03			jr nz, .bps1b 
189e 32 f0 f1			ld (os_view_disable),a 
18a1 fe 31		.bps1b:  cp '1' 
18a3 20 14			jr nz, .bps2 
18a5			 
18a5				; display reg 
18a5			 
18a5				 
18a5			 
18a5 3a ee f1			ld a, (os_view_af) 
18a8 2a ec f1			ld hl, (os_view_hl) 
18ab ed 5b ea f1		ld de, (os_view_de) 
18af ed 4b e8 f1		ld bc, (os_view_bc) 
18b3 cd 4d 19			call display_reg_state 
18b6 c3 39 19			jp .bpschk 
18b9			 
18b9 fe 32		.bps2:  cp '2' 
18bb 20 08			jr nz, .bps3 
18bd				 
18bd				; display hl 
18bd 2a ec f1			ld hl, (os_view_hl) 
18c0 cd 37 1a			call display_dump_at_hl 
18c3			 
18c3 18 74			jr .bpschk 
18c5			 
18c5 fe 33		.bps3:  cp '3' 
18c7 20 08			jr nz, .bps4 
18c9			 
18c9			        ; display de 
18c9 2a ea f1			ld hl, (os_view_de) 
18cc cd 37 1a			call display_dump_at_hl 
18cf			 
18cf 18 68			jr .bpschk 
18d1 fe 34		.bps4:  cp '4' 
18d3 20 08			jr nz, .bps5 
18d5			 
18d5			        ; display bc 
18d5 2a e8 f1			ld hl, (os_view_bc) 
18d8 cd 37 1a			call display_dump_at_hl 
18db			 
18db 18 5c			jr .bpschk 
18dd fe 35		.bps5:  cp '5' 
18df 20 08		        jr nz, .bps7 
18e1			 
18e1				; display cur ptr 
18e1 2a 4a fa			ld hl, (cli_ptr) 
18e4 cd 37 1a			call display_dump_at_hl 
18e7			 
18e7 18 50			jr .bpschk 
18e9 fe 36		.bps7:  cp '6' 
18eb 20 08			jr nz, .bps8b 
18ed				 
18ed				; display cur orig ptr 
18ed 2a 48 fa			ld hl, (cli_origptr) 
18f0 cd 37 1a			call display_dump_at_hl 
18f3 18 44			jr .bpschk 
18f5 fe 37		.bps8b:  cp '7' 
18f7 20 08			jr nz, .bps9 
18f9				 
18f9				; display dsp 
18f9 2a 2c fa			ld hl, (cli_data_sp) 
18fc cd 37 1a			call display_dump_at_hl 
18ff			 
18ff 18 38			jr .bpschk 
1901 fe 39		.bps9:  cp '9' 
1903 20 05			jr nz, .bps8c 
1905				 
1905				; display SP 
1905			;	ld hl, sp 
1905 cd 37 1a			call display_dump_at_hl 
1908			 
1908 18 2f			jr .bpschk 
190a fe 38		.bps8c:  cp '8' 
190c 20 08			jr nz, .bps8d 
190e				 
190e				; display rsp 
190e 2a 30 fa			ld hl, (cli_ret_sp) 
1911 cd 37 1a			call display_dump_at_hl 
1914			 
1914 18 23			jr .bpschk 
1916 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1918 20 05			jr nz, .bps8 
191a cd 55 1c			call monitor 
191d			 
191d 18 1a			jr .bpschk 
191f fe 30		.bps8:  cp '0' 
1921 20 16			jr nz, .bpschk 
1923			 
1923 21 13 fd				ld hl, display_fb1 
1926 22 cf fb				ld (display_fb_active), hl 
1929 cd bb 0c				call update_display 
192c			 
192c				;ld a, (os_view_af) 
192c 2a ec f1			ld hl, (os_view_hl) 
192f ed 5b ea f1		ld de, (os_view_de) 
1933 ed 4b e8 f1		ld bc, (os_view_bc) 
1937 f1				pop af 
1938 c9				ret 
1939			 
1939			.bpschk:   
1939 cd 15 0c			call delay1s 
193c 3e 9f		ld a,display_row_4 + display_cols - 1 
193e 11 5d 1e		        ld de, endprg 
1941 cd ab 0c			call str_at_display 
1944 cd bb 0c			call update_display 
1947 cd c8 6c			call cin_wait 
194a			 
194a c3 9a 18			jp .bps1 
194d			 
194d			 
194d			display_reg_state: 
194d			 
194d				; to restore afterwards 
194d			 
194d d5				push de 
194e c5				push bc 
194f e5				push hl 
1950 f5				push af 
1951			 
1951				; for use in here 
1951			 
1951 c5				push bc 
1952 d5				push de 
1953 e5				push hl 
1954 f5				push af 
1955			 
1955 cd 98 0c			call clear_display 
1958			 
1958 11 0d 1a			ld de, .regstate 
195b 3e 00			ld a, display_row_1 
195d cd ab 0c			call str_at_display 
1960			 
1960				; display debug step 
1960			 
1960			 
1960 11 6e fe			ld de, debug_mark 
1963 3e 25			ld a, display_row_1+display_cols-3 
1965 cd ab 0c			call str_at_display 
1968			 
1968				; display a 
1968 11 29 1a			ld de, .regstatea 
196b 3e 28			ld a, display_row_2 
196d cd ab 0c			call str_at_display 
1970			 
1970 e1				pop hl 
1971			;	ld h,0 
1971			;	ld l, a 
1971 3e 2b			ld a, display_row_2+3 
1973 cd f8 17			call display_word_at 
1976			 
1976			 
1976				; display hl 
1976			 
1976			 
1976 11 1d 1a			ld de, .regstatehl 
1979 3e 32			ld a, display_row_2+10 
197b cd ab 0c			call str_at_display 
197e			 
197e e1				pop hl 
197f 3e 35			ld a, display_row_2+13 
1981 cd f8 17			call display_word_at 
1984			 
1984				 
1984				; display de 
1984			 
1984 11 21 1a			ld de, .regstatede 
1987 3e 50			ld a, display_row_3 
1989 cd ab 0c			call str_at_display 
198c			 
198c e1				pop hl 
198d			;	ld h,d 
198d			;	ld l, e 
198d 3e 53			ld a, display_row_3+3 
198f cd f8 17			call display_word_at 
1992			 
1992			 
1992				; display bc 
1992			 
1992 11 25 1a			ld de, .regstatebc 
1995 3e 5a			ld a, display_row_3+10 
1997 cd ab 0c			call str_at_display 
199a			 
199a e1				pop hl 
199b			;	ld h,b 
199b			;	ld l, c 
199b 3e 5d			ld a, display_row_3+13 
199d cd f8 17			call display_word_at 
19a0			 
19a0			 
19a0				; display dsp 
19a0			 
19a0 11 2d 1a			ld de, .regstatedsp 
19a3 3e 78			ld a, display_row_4 
19a5 cd ab 0c			call str_at_display 
19a8			 
19a8				 
19a8 2a 2c fa			ld hl,(cli_data_sp) 
19ab 3e 7c			ld a, display_row_4+4 
19ad cd f8 17			call display_word_at 
19b0			 
19b0				; display rsp 
19b0			 
19b0 11 32 1a			ld de, .regstatersp 
19b3 3e 82			ld a, display_row_4+10 
19b5 cd ab 0c			call str_at_display 
19b8			 
19b8				 
19b8 2a 30 fa			ld hl,(cli_ret_sp) 
19bb 3e 86			ld a, display_row_4+14 
19bd cd f8 17			call display_word_at 
19c0			 
19c0 cd bb 0c			call update_display 
19c3			 
19c3			;	call delay1s 
19c3			;	call delay1s 
19c3			;	call delay1s 
19c3			 
19c3			 
19c3			;	call next_page_prompt 
19c3			 
19c3				; restore  
19c3			 
19c3 f1				pop af 
19c4 e1				pop hl 
19c5 c1				pop bc 
19c6 d1				pop de 
19c7 c9				ret 
19c8			 
19c8 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
19dc .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
19f1 .. 00		.ptrstate:	db "Ptr State",0 
19fb .. 00		.ptrcliptr:     db "cli_ptr",0 
1a03 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1a0d .. 00		.regstate:	db "Reg State (1/0)",0 
1a1d .. 00		.regstatehl:	db "HL:",0 
1a21 .. 00		.regstatede:	db "DE:",0 
1a25 .. 00		.regstatebc:	db "BC:",0 
1a29 .. 00		.regstatea:	db "A :",0 
1a2d .. 00		.regstatedsp:	db "DSP:",0 
1a32 .. 00		.regstatersp:	db "RSP:",0 
1a37			 
1a37			display_dump_at_hl: 
1a37 e5				push hl 
1a38 d5				push de 
1a39 c5				push bc 
1a3a f5				push af 
1a3b			 
1a3b 22 22 f5			ld (os_cur_ptr),hl	 
1a3e cd 98 0c			call clear_display 
1a41 cd 67 1d			call dumpcont 
1a44			;	call delay1s 
1a44			;	call next_page_prompt 
1a44			 
1a44			 
1a44 f1				pop af 
1a45 c1				pop bc 
1a46 d1				pop de 
1a47 e1				pop hl 
1a48 c9				ret 
1a49			 
1a49			;if ENABLE_BASIC 
1a49			;	include "nascombasic.asm" 
1a49			;	basic: 
1a49			;	include "forth/FORTH.ASM" 
1a49			;endif 
1a49			 
1a49			; eof 
1a49			 
1a49			 
# End of file firmware_diags.asm
1a49			  
1a49			include "firmware_prompts.asm"  
1a49			; Prompts  
1a49			 
1a49			; boot messages 
1a49			 
1a49 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1a5e .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1a6e			 
1a6e			 
1a6e			; config menus 
1a6e			 
1a6e .. 00		prom_c3: db "Add Dictionary To File",0 
1a85 .. 00		prom_c2: db "Select Autoload File",0 
1a9a .. 00		prom_c2a: db "Disable Autoload File", 0 
1ab0 .. 00		prom_c2b: db "Select Storage Bank",0 
1ac4 .. 00		prom_c4: db "Settings",0 
1acd .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1ae8 .. 00		prom_m4b:   db "Monitor",0 
1af0 .. 00		prom_c1: db "Hardware Diags",0 
1aff			 
1aff			 
1aff .. 00		prom_notav:    db "Feature not available",0 
1b15 .. 00		prom_empty:    db "",0 
1b16			 
1b16			; eof 
1b16			 
# End of file firmware_prompts.asm
1b16			  
1b16			  
1b16			; eof  
1b16			  
# End of file firmware.asm
1b16			 
1b16			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1b16			;if BASE_KEV  
1b16			;baseram: equ 08000h 
1b16			;endif 
1b16			 
1b16			;if BASE_SC114 
1b16			;baseram:     equ    endofcode 
1b16			;endif 
1b16			 
1b16			 
1b16			; start system 
1b16			 
1b16			coldstart: 
1b16				; set sp 
1b16				; di/ei 
1b16			 
1b16 f3				di 
1b17 31 fd ff			ld sp, tos 
1b1a			;	ei 
1b1a			 
1b1a			 
1b1a				; disable breakpoint by default 
1b1a			 
1b1a 3e 2a			ld a,'*' 
1b1c 32 f0 f1			ld (os_view_disable),a 
1b1f			 
1b1f				; init hardware 
1b1f			 
1b1f				; init keyboard and screen hardware 
1b1f			 
1b1f cd 1c 00			call hardware_init 
1b22			 
1b22			 
1b22 cd 15 0c			call delay1s 
1b25 3e 58			ld a, display_row_3+8 
1b27 11 03 00			ld de, buildtime 
1b2a cd ab 0c			call str_at_display 
1b2d cd bb 0c			call update_display 
1b30			 
1b30 cd 15 0c			call delay1s 
1b33 cd 15 0c			call delay1s 
1b36 cd 15 0c			call delay1s 
1b39			 
1b39				; detect if any keys are held down to enable breakpoints at start up 
1b39			 
1b39 cd d9 6c			call cin  
1b3c fe 00			cp 0 
1b3e 28 03			jr z, .nokeys 
1b40			 
1b40				;call hardware_diags 
1b40 cd 56 15			call config 
1b43			 
1b43			;	ld de, .bpen 
1b43			;	ld a, display_row_4 
1b43			;	call str_at_display 
1b43			;	call update_display 
1b43			; 
1b43			;	ld a,0 
1b43			;	ld (os_view_disable),a 
1b43			; 
1b43			;.bpwait: 
1b43			;	call cin 
1b43			;	cp 0 
1b43			;	jr z, .bpwait 
1b43			;	jr .nokeys 
1b43			; 
1b43			; 
1b43			;.bpen:  db "Break points enabled!",0 
1b43			 
1b43			 
1b43			 
1b43			 
1b43			 
1b43			 
1b43			.nokeys: 
1b43			 
1b43			 
1b43				 
1b43			 
1b43			;jp  testkey 
1b43			 
1b43			;call storage_get_block_0 
1b43			; 
1b43			;ld hl, 0 
1b43			;ld de, store_page 
1b43			;call storage_read_block 
1b43			 
1b43				 
1b43			;ld hl, 10 
1b43			;ld de, store_page 
1b43			;call storage_read_block 
1b43			 
1b43			 
1b43			 
1b43			 
1b43			 
1b43			;stop:	nop 
1b43			;	jp stop 
1b43			 
1b43			 
1b43			 
1b43			main: 
1b43 cd 98 0c			call clear_display 
1b46 cd bb 0c			call update_display 
1b49			 
1b49			 
1b49			 
1b49			;	call testlcd 
1b49			 
1b49			 
1b49			 
1b49 cd 25 22			call forth_init 
1b4c			 
1b4c			 
1b4c			warmstart: 
1b4c cd fb 21			call forth_warmstart 
1b4f			 
1b4f				; run startup word load 
1b4f			        ; TODO prevent this running at warmstart after crash  
1b4f			 
1b4f				if STARTUP_ENABLE 
1b4f					if STORAGE_SE 
1b4f cd 67 68					call forth_autoload 
1b52					endif 
1b52 cd 76 65				call forth_startup 
1b55			 
1b55			 
1b55				endif 
1b55			 
1b55				; show free memory after boot 
1b55 11 ef 1b			ld de, freeram 
1b58 3e 00			ld a, display_row_1 
1b5a cd ab 0c			call str_at_display 
1b5d			 
1b5d			; Or use heap_size word???? 
1b5d 21 e5 f1			ld hl, heap_end 
1b60 11 0e 80			ld de, heap_start 
1b63 ed 52			sbc hl, de 
1b65 e5				push hl 
1b66 7c				ld a,h	         	 
1b67 21 04 f5			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b6a cd cd 11			call hexout 
1b6d e1			   	pop hl 
1b6e			 
1b6e 7d				ld a,l 
1b6f 21 06 f5			ld hl, os_word_scratch+2 
1b72 cd cd 11			call hexout 
1b75 21 08 f5			ld hl, os_word_scratch+4 
1b78 3e 00			ld a, 0 
1b7a 77				ld (hl),a 
1b7b 11 04 f5			ld de, os_word_scratch 
1b7e 3e 0d			ld a, display_row_1 + 13 
1b80 cd ab 0c			call str_at_display 
1b83 cd bb 0c			call update_display 
1b86			 
1b86			 
1b86				;call demo 
1b86			 
1b86			 
1b86				; init scratch input area for cli commands 
1b86			 
1b86 21 26 f5			ld hl, os_cli_cmd 
1b89 3e 00			ld a,0 
1b8b 77				ld (hl),a 
1b8c 23				inc hl 
1b8d 77				ld (hl),a 
1b8e			 
1b8e 3e 00			ld a,0 
1b90 32 25 f6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1b93			 
1b93 32 22 f5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1b96 32 23 f5			ld (os_cur_ptr+1),a	 
1b99			 
1b99 32 04 f5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1b9c 32 05 f5			ld (os_word_scratch+1),a	 
1b9f				 
1b9f			 
1b9f				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1b9f 21 26 f5			ld hl, os_cli_cmd 
1ba2			 
1ba2 3e 00			ld a, 0		 ; init cli input 
1ba4 77				ld (hl), a 
1ba5 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ba7			cli: 
1ba7				; show cli prompt 
1ba7				;push af 
1ba7				;ld a, 0 
1ba7				;ld de, prompt 
1ba7				;call str_at_display 
1ba7			 
1ba7				;call update_display 
1ba7				;pop af 
1ba7				;inc a 
1ba7				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1ba7 0e 00			ld c, 0 
1ba9 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1bab 1e 28			ld e, 40 
1bad			 
1bad 21 26 f5			ld hl, os_cli_cmd 
1bb0			 
1bb0				STACKFRAME OFF $fefe $9f9f 
1bb0				if DEBUG_STACK_IMB 
1bb0					if OFF 
1bb0						exx 
1bb0						ld de, $fefe 
1bb0						ld a, d 
1bb0						ld hl, curframe 
1bb0						call hexout 
1bb0						ld a, e 
1bb0						ld hl, curframe+2 
1bb0						call hexout 
1bb0						ld hl, $fefe 
1bb0						push hl 
1bb0						ld hl, $9f9f 
1bb0						push hl 
1bb0						exx 
1bb0					endif 
1bb0				endif 
1bb0			endm 
# End of macro STACKFRAME
1bb0			 
1bb0 cd f9 0e			call input_str 
1bb3			 
1bb3				STACKFRAMECHK OFF $fefe $9f9f 
1bb3				if DEBUG_STACK_IMB 
1bb3					if OFF 
1bb3						exx 
1bb3						ld hl, $9f9f 
1bb3						pop de   ; $9f9f 
1bb3						call cmp16 
1bb3						jr nz, .spnosame 
1bb3						ld hl, $fefe 
1bb3						pop de   ; $fefe 
1bb3						call cmp16 
1bb3						jr z, .spfrsame 
1bb3						.spnosame: call showsperror 
1bb3						.spfrsame: nop 
1bb3						exx 
1bb3					endif 
1bb3				endif 
1bb3			endm 
# End of macro STACKFRAMECHK
1bb3			 
1bb3				; copy input to last command 
1bb3			 
1bb3 21 26 f5			ld hl, os_cli_cmd 
1bb6 11 25 f6			ld de, os_last_cmd 
1bb9 01 ff 00			ld bc, 255 
1bbc ed b0			ldir 
1bbe			 
1bbe				; wipe current buffer 
1bbe			 
1bbe			;	ld a, 0 
1bbe			;	ld hl, os_cli_cmd 
1bbe			;	ld de, os_cli_cmd+1 
1bbe			;	ld bc, 254 
1bbe			;	ldir 
1bbe				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1bbe			;	call strcpy 
1bbe			;	ld a, 0 
1bbe			;	ld (hl), a 
1bbe			;	inc hl 
1bbe			;	ld (hl), a 
1bbe			;	inc hl 
1bbe			;	ld (hl), a 
1bbe			 
1bbe				; switch frame buffer to program  
1bbe			 
1bbe 21 13 fd				ld hl, display_fb1 
1bc1 22 cf fb				ld (display_fb_active), hl 
1bc4			 
1bc4			;	nop 
1bc4				STACKFRAME ON $fbfe $8f9f 
1bc4				if DEBUG_STACK_IMB 
1bc4					if ON 
1bc4						exx 
1bc4						ld de, $fbfe 
1bc4						ld a, d 
1bc4						ld hl, curframe 
1bc4						call hexout 
1bc4						ld a, e 
1bc4						ld hl, curframe+2 
1bc4						call hexout 
1bc4						ld hl, $fbfe 
1bc4						push hl 
1bc4						ld hl, $8f9f 
1bc4						push hl 
1bc4						exx 
1bc4					endif 
1bc4				endif 
1bc4			endm 
# End of macro STACKFRAME
1bc4				; first time into the parser so pass over the current scratch pad 
1bc4 21 26 f5			ld hl,os_cli_cmd 
1bc7				; tokenise the entered statement(s) in HL 
1bc7 cd a3 22			call forthparse 
1bca			        ; exec forth statements in top of return stack 
1bca cd e3 22			call forthexec 
1bcd				;call forthexec_cleanup 
1bcd			;	call parsenext 
1bcd			 
1bcd				STACKFRAMECHK ON $fbfe $8f9f 
1bcd				if DEBUG_STACK_IMB 
1bcd					if ON 
1bcd						exx 
1bcd						ld hl, $8f9f 
1bcd						pop de   ; $8f9f 
1bcd						call cmp16 
1bcd						jr nz, .spnosame 
1bcd						ld hl, $fbfe 
1bcd						pop de   ; $fbfe 
1bcd						call cmp16 
1bcd						jr z, .spfrsame 
1bcd						.spnosame: call showsperror 
1bcd						.spfrsame: nop 
1bcd						exx 
1bcd					endif 
1bcd				endif 
1bcd			endm 
# End of macro STACKFRAMECHK
1bcd				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1bcd			 
1bcd 3e 78			ld a, display_row_4 
1bcf 11 01 1c			ld de, endprog 
1bd2			 
1bd2 cd bb 0c			call update_display		 
1bd5			 
1bd5 cd 5f 1e			call next_page_prompt 
1bd8			 
1bd8				; switch frame buffer to cli 
1bd8			 
1bd8 21 b4 fd				ld hl, display_fb0 
1bdb 22 cf fb				ld (display_fb_active), hl 
1bde			 
1bde			 
1bde cd 98 0c		        call clear_display 
1be1 cd bb 0c			call update_display		 
1be4			 
1be4 21 26 f5			ld hl, os_cli_cmd 
1be7			 
1be7 3e 00			ld a, 0		 ; init cli input 
1be9 77				ld (hl), a 
1bea			 
1bea				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1bea			 
1bea				; now on last line 
1bea			 
1bea				; TODO scroll screen up 
1bea			 
1bea				; TODO instead just clear screen and place at top of screen 
1bea			 
1bea			;	ld a, 0 
1bea			;	ld (f_cursor_ptr),a 
1bea			 
1bea				;call clear_display 
1bea				;call update_display 
1bea			 
1bea				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bea 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1bec c3 a7 1b			jp cli 
1bef			 
1bef .. 00		freeram: db "Free bytes: $",0 
1bfd ..			asc: db "1A2F" 
1c01 .. 00		endprog: db "End prog...",0 
1c0d			 
1c0d			testenter2:   
1c0d 21 31 f2			ld hl,scratch+50 
1c10 22 22 f5			ld (os_cur_ptr),hl 
1c13 c3 a7 1b			jp cli 
1c16			 
1c16			testenter:  
1c16			 
1c16 21 fd 1b			ld hl,asc 
1c19			;	ld a,(hl) 
1c19			;	call nibble2val 
1c19 cd 23 12			call get_byte 
1c1c			 
1c1c			 
1c1c			;	ld a,(hl) 
1c1c			;	call atohex 
1c1c			 
1c1c			;	call fourehexhl 
1c1c 32 31 f2			ld (scratch+50),a 
1c1f			 
1c1f			 
1c1f			 
1c1f 21 ff 1b			ld hl,asc+2 
1c22			;	ld a, (hl) 
1c22			;	call nibble2val 
1c22 cd 23 12			call get_byte 
1c25			 
1c25			;	call fourehexhl 
1c25 32 33 f2			ld (scratch+52),a 
1c28				 
1c28 21 31 f2			ld hl,scratch+50 
1c2b 22 22 f5			ld (os_cur_ptr),hl 
1c2e c3 a7 1b			jp cli 
1c31			 
1c31			enter:	 
1c31 3a 03 f2			ld a,(scratch+4) 
1c34 fe 00			cp 0 
1c36 28 0c			jr z, .entercont 
1c38				; no, not a null term line so has an address to work out.... 
1c38			 
1c38 21 01 f2			ld hl,scratch+2 
1c3b cd 83 12			call get_word_hl 
1c3e			 
1c3e 22 22 f5			ld (os_cur_ptr),hl	 
1c41 c3 a7 1b			jp cli 
1c44			 
1c44			 
1c44			.entercont:  
1c44			 
1c44 21 01 f2			ld hl, scratch+2 
1c47 cd 23 12			call get_byte 
1c4a			 
1c4a 2a 22 f5		   	ld hl,(os_cur_ptr) 
1c4d 77					ld (hl),a 
1c4e 23					inc hl 
1c4f 22 22 f5				ld (os_cur_ptr),hl 
1c52				 
1c52			; get byte  
1c52			 
1c52			 
1c52 c3 a7 1b			jp cli 
1c55			 
1c55			 
1c55			; basic monitor support 
1c55			 
1c55			monitor: 
1c55				;  
1c55 cd 98 0c			call clear_display 
1c58 3e 00			ld a, 0 
1c5a 11 a2 1c			ld de, .monprompt 
1c5d cd ab 0c			call str_at_display 
1c60 cd bb 0c			call update_display 
1c63			 
1c63				; get a monitor command 
1c63			 
1c63 0e 00			ld c, 0     ; entry at top left 
1c65 16 64			ld d, 100   ; max buffer size 
1c67 1e 0f			ld e, 15    ; input scroll area 
1c69 3e 00			ld a, 0     ; init string 
1c6b 21 fd f3			ld hl, os_input 
1c6e 77				ld (hl), a 
1c6f 23				inc hl 
1c70 77				ld (hl), a 
1c71 21 fd f3			ld hl, os_input 
1c74 3e 01			ld a, 1     ; init string 
1c76 cd f9 0e			call input_str 
1c79			 
1c79 cd 98 0c		        call clear_display 
1c7c cd bb 0c			call update_display		 
1c7f			 
1c7f 3a fd f3			ld a, (os_input) 
1c82 cd 21 13			call toUpper 
1c85 fe 48		        cp 'H' 
1c87 28 6f		        jr z, .monhelp 
1c89 fe 44			cp 'D'		; dump 
1c8b ca 19 1d			jp z, .mondump	 
1c8e fe 43			cp 'C'		; dump 
1c90 ca 33 1d			jp z, .moncdump	 
1c93 fe 4d			cp 'M'		; dump 
1c95 ca a4 1c			jp z, .moneditstart 
1c98 fe 55			cp 'U'		; dump 
1c9a 28 14			jr z, .monedit	 
1c9c fe 51			cp 'Q'		; dump 
1c9e c8				ret z	 
1c9f			 
1c9f			 
1c9f				; TODO "S" to access symbol by name and not need the address 
1c9f				; TODO "F" to find a string in memory 
1c9f			 
1c9f c3 55 1c			jp monitor 
1ca2			 
1ca2 .. 00		.monprompt: db ">", 0 
1ca4			 
1ca4			.moneditstart: 
1ca4				; get starting address 
1ca4			 
1ca4 21 ff f3			ld hl,os_input+2 
1ca7 cd 83 12			call get_word_hl 
1caa			 
1caa 22 22 f5			ld (os_cur_ptr),hl	 
1cad			 
1cad c3 55 1c			jp monitor 
1cb0			 
1cb0			.monedit: 
1cb0				; get byte to load 
1cb0			 
1cb0 21 ff f3			ld hl,os_input+2 
1cb3 cd 23 12			call get_byte 
1cb6			 
1cb6				; get address to update 
1cb6 2a 22 f5			ld hl, (os_cur_ptr) 
1cb9			 
1cb9				; update byte 
1cb9			 
1cb9 77				ld (hl), a 
1cba			 
1cba				; move to next address and save it 
1cba			 
1cba 23				inc hl 
1cbb 22 22 f5			ld (os_cur_ptr),hl	 
1cbe			 
1cbe c3 55 1c			jp monitor 
1cc1			 
1cc1			 
1cc1 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1cd5 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1cf1 .. 00		.monhelptext3:  db "Q-Quit",0 
1cf8			        
1cf8			.monhelp: 
1cf8 3e 00			ld a, display_row_1 
1cfa 11 c1 1c		        ld de, .monhelptext1 
1cfd			 
1cfd cd ab 0c			call str_at_display 
1d00 3e 28			ld a, display_row_2 
1d02 11 d5 1c		        ld de, .monhelptext2 
1d05					 
1d05 cd ab 0c			call str_at_display 
1d08 3e 50			ld a, display_row_3 
1d0a 11 f1 1c		        ld de, .monhelptext3 
1d0d					 
1d0d cd ab 0c			call str_at_display 
1d10 cd bb 0c			call update_display		 
1d13			 
1d13 cd 5f 1e			call next_page_prompt 
1d16 c3 55 1c			jp monitor 
1d19			 
1d19			.mondump:    
1d19 21 ff f3			ld hl,os_input+2 
1d1c cd 83 12			call get_word_hl 
1d1f			 
1d1f 22 22 f5			ld (os_cur_ptr),hl	 
1d22 cd 67 1d			call dumpcont 
1d25 3e 78			ld a, display_row_4 
1d27 11 01 1c			ld de, endprog 
1d2a			 
1d2a cd bb 0c			call update_display		 
1d2d			 
1d2d cd 5f 1e			call next_page_prompt 
1d30 c3 55 1c			jp monitor 
1d33			.moncdump: 
1d33 cd 67 1d			call dumpcont 
1d36 3e 78			ld a, display_row_4 
1d38 11 01 1c			ld de, endprog 
1d3b			 
1d3b cd bb 0c			call update_display		 
1d3e			 
1d3e cd 5f 1e			call next_page_prompt 
1d41 c3 55 1c			jp monitor 
1d44			 
1d44			 
1d44			; TODO symbol access  
1d44			 
1d44			.symbols:     ;; A list of symbols that can be called up  
1d44 b4 fd			dw display_fb0 
1d46 .. 00			db "fb0",0  
1d4a 81 fa		     	dw store_page 
1d4c .. 00			db "store_page",0 
1d57			 
1d57			 
1d57			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1d57			 
1d57 3a 00 f2			ld a,(scratch+1) 
1d5a fe 00			cp 0 
1d5c 28 09			jr z, dumpcont 
1d5e			 
1d5e				; no, not a null term line so has an address to work out.... 
1d5e			 
1d5e 21 01 f2			ld hl,scratch+2 
1d61 cd 83 12			call get_word_hl 
1d64			 
1d64 22 22 f5			ld (os_cur_ptr),hl	 
1d67			 
1d67			 
1d67			 
1d67			dumpcont: 
1d67			 
1d67				; dump bytes at ptr 
1d67			 
1d67			 
1d67 3e 00			ld a, display_row_1 
1d69 2a cf fb			ld hl, (display_fb_active) 
1d6c cd cc 0e			call addatohl 
1d6f cd 97 1d			call .dumpbyterow 
1d72			 
1d72 3e 28			ld a, display_row_2 
1d74 2a cf fb			ld hl, (display_fb_active) 
1d77 cd cc 0e			call addatohl 
1d7a cd 97 1d			call .dumpbyterow 
1d7d			 
1d7d			 
1d7d 3e 50			ld a, display_row_3 
1d7f 2a cf fb			ld hl, (display_fb_active) 
1d82 cd cc 0e			call addatohl 
1d85 cd 97 1d			call .dumpbyterow 
1d88			 
1d88 3e 78			ld a, display_row_4 
1d8a 2a cf fb			ld hl, (display_fb_active) 
1d8d cd cc 0e			call addatohl 
1d90 cd 97 1d			call .dumpbyterow 
1d93			 
1d93 cd bb 0c			call update_display 
1d96			;		jp cli 
1d96 c9				ret 
1d97			 
1d97			.dumpbyterow: 
1d97			 
1d97				;push af 
1d97			 
1d97 e5				push hl 
1d98			 
1d98				; calc where to poke the ascii 
1d98			if display_cols == 20 
1d98				ld a, 16 
1d98			else 
1d98 3e 1f			ld a, 31 
1d9a			endif 
1d9a			 
1d9a cd cc 0e			call addatohl 
1d9d 22 04 f5			ld (os_word_scratch),hl  		; save pos for later 
1da0			 
1da0			 
1da0			; display decoding address 
1da0 2a 22 f5		   	ld hl,(os_cur_ptr) 
1da3			 
1da3 7c				ld a,h 
1da4 e1				pop hl 
1da5 e5				push hl 
1da6			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1da6 cd cd 11			call hexout 
1da9 2a 22 f5		   	ld hl,(os_cur_ptr) 
1dac			 
1dac 7d				ld a,l 
1dad e1				pop hl 
1dae 23				inc hl 
1daf 23				inc hl 
1db0 e5				push hl 
1db1			;	ld hl, os_word_scratch+2 
1db1 cd cd 11			call hexout 
1db4 e1				pop hl 
1db5 23				inc hl 
1db6 23				inc hl 
1db7				;ld hl, os_word_scratch+4 
1db7 3e 3a			ld a, ':' 
1db9 77				ld (hl),a 
1dba 23				inc hl 
1dbb				;ld a, 0 
1dbb				;ld (hl),a 
1dbb				;ld de, os_word_scratch 
1dbb				;pop af 
1dbb				;push af 
1dbb			;		ld a, display_row_2 
1dbb			;		call str_at_display 
1dbb			;		call update_display 
1dbb			 
1dbb			 
1dbb			;pop af 
1dbb			;	add 5 
1dbb			 
1dbb			if display_cols == 20 
1dbb				ld b, 4 
1dbb			else 
1dbb 06 08			ld b, 8 
1dbd			endif	 
1dbd			 
1dbd			.dumpbyte: 
1dbd c5				push bc 
1dbe e5				push hl 
1dbf			 
1dbf			 
1dbf 2a 22 f5		   	ld hl,(os_cur_ptr) 
1dc2 7e					ld a,(hl) 
1dc3			 
1dc3					; poke the ascii to display 
1dc3 2a 04 f5				ld hl,(os_word_scratch) 
1dc6 77					ld (hl),a 
1dc7 23					inc hl 
1dc8 22 04 f5				ld (os_word_scratch),hl 
1dcb			 
1dcb					 
1dcb			 
1dcb			 
1dcb e1					pop hl 
1dcc e5					push hl 
1dcd			 
1dcd cd cd 11				call hexout 
1dd0			 
1dd0					 
1dd0 2a 22 f5		   	ld hl,(os_cur_ptr) 
1dd3 23				inc hl 
1dd4 22 22 f5		   	ld (os_cur_ptr),hl 
1dd7			 
1dd7 e1					pop hl 
1dd8 23					inc hl 
1dd9 23					inc hl 
1dda 23					inc hl 
1ddb			 
1ddb			 
1ddb			 
1ddb					;ld a,0 
1ddb					;ld (os_word_scratch+2),a 
1ddb					;pop af 
1ddb					;push af 
1ddb			 
1ddb					;ld de, os_word_scratch 
1ddb					;call str_at_display 
1ddb			;		call update_display 
1ddb			;		pop af 
1ddb c1					pop bc 
1ddc c6 03				add 3 
1dde 10 dd			djnz .dumpbyte 
1de0			 
1de0				 
1de0			 
1de0 c9				ret 
1de1			 
1de1			jump:	 
1de1			 
1de1 21 01 f2			ld hl,scratch+2 
1de4 cd 83 12			call get_word_hl 
1de7				;ld hl,(scratch+2) 
1de7				;call fourehexhl 
1de7			 
1de7 22 22 f5			ld (os_cur_ptr),hl	 
1dea			 
1dea e9				jp (hl) 
1deb			 
1deb			 
1deb			 
1deb			; TODO implement a basic monitor mode to start with 
1deb			 
1deb			 
1deb			 
1deb			 
1deb			 
1deb			 
1deb			 
1deb			 
1deb			 
1deb			; testing and demo code during development 
1deb			 
1deb			 
1deb .. 00		str1: db "Enter some text...",0 
1dfe .. 00		clear: db "                    ",0 
1e13			 
1e13			demo: 
1e13			 
1e13			 
1e13			 
1e13			;	call update_display 
1e13			 
1e13				; init scratch input area for testing 
1e13 21 ff f1			ld hl, scratch	 
1e16 3e 00			ld a,0 
1e18 77				ld (hl),a 
1e19			 
1e19			 
1e19 3e 28		            LD   A, display_row_2 
1e1b			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e1b 11 eb 1d		            LD   DE, str1 
1e1e cd ab 0c			call str_at_display 
1e21			 
1e21			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e21			cloop:	 
1e21 3e 50		            LD   A, display_row_3 
1e23			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e23 11 fe 1d		            LD   DE, clear 
1e26			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1e26 cd ab 0c				call str_at_display 
1e29 3e 78			ld a, display_row_4 
1e2b 11 5b 1e			ld de, prompt 
1e2e			 
1e2e cd ab 0c				call str_at_display 
1e31 cd bb 0c			call update_display 
1e34			 
1e34 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1e36 16 0a			ld d, 10 
1e38 21 ff f1			ld hl, scratch	 
1e3b cd f9 0e			call input_str 
1e3e			 
1e3e			;	call clear_display 
1e3e			;'	call update_display 
1e3e			 
1e3e 3e 00		            LD   A, display_row_1 
1e40			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e40 11 fe 1d		            LD   DE, clear 
1e43 cd ab 0c				call str_at_display 
1e46			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e46 3e 00		            LD   A, display_row_1 
1e48			;            CALL fLCD_Pos       ;Position cursor to location in A 
1e48 11 ff f1		            LD   DE, scratch 
1e4b			;            CALL fLCD_Str       ;Display string pointed to by DE 
1e4b cd ab 0c				call str_at_display 
1e4e cd bb 0c			call update_display 
1e51			 
1e51 3e 00				ld a,0 
1e53 21 ff f1			ld hl, scratch 
1e56 77				ld (hl),a 
1e57			 
1e57 00				nop 
1e58 c3 21 1e			jp cloop 
1e5b			 
1e5b			 
1e5b			 
1e5b			; OS Prompt 
1e5b			 
1e5b .. 00		prompt: db ">",0 
1e5d .. 00		endprg: db "?",0 
1e5f			 
1e5f			 
1e5f			; handy next page prompt 
1e5f			next_page_prompt: 
1e5f e5				push hl 
1e60 d5				push de 
1e61 f5				push af 
1e62 c5				push bc 
1e63			 
1e63 3e 9f			ld a,display_row_4 + display_cols - 1 
1e65 11 5d 1e		        ld de, endprg 
1e68 cd ab 0c			call str_at_display 
1e6b cd bb 0c			call update_display 
1e6e cd c8 6c			call cin_wait 
1e71 c1				pop bc 
1e72 f1				pop af 
1e73 d1				pop de 
1e74 e1				pop hl 
1e75			 
1e75			 
1e75 c9				ret 
1e76			 
1e76			 
1e76			; forth parser 
1e76			 
1e76			; My forth kernel 
1e76			include "forth_kernel.asm" 
1e76			; 
1e76			; kernel to the forth OS 
1e76			 
1e76			DS_TYPE_STR: equ 1     ; string type 
1e76			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1e76			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1e76			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1e76			 
1e76			FORTH_PARSEV1: equ 0 
1e76			FORTH_PARSEV2: equ 0 
1e76			FORTH_PARSEV3: equ 0 
1e76			FORTH_PARSEV4: equ 0 
1e76			FORTH_PARSEV5: equ 1 
1e76			 
1e76			;if FORTH_PARSEV5 
1e76			;	FORTH_END_BUFFER: equ 0 
1e76			;else 
1e76			FORTH_END_BUFFER: equ 127 
1e76			;endif 
1e76			 
1e76			FORTH_TRUE: equ 1 
1e76			FORTH_FALSE: equ 0 
1e76			 
1e76			if FORTH_PARSEV4 
1e76			include "forth_stackops.asm" 
1e76			endif 
1e76			 
1e76			if FORTH_PARSEV5 
1e76			include "forth_stackopsv5.asm" 
1e76			 
1e76			; Stack operations for v5 parser on wards 
1e76			; * DATA stack 
1e76			; * LOOP stack 
1e76			; * RETURN stack 
1e76			 
1e76			 
1e76			 
1e76			FORTH_CHK_DSP_UNDER: macro 
1e76				push hl 
1e76				push de 
1e76				ld hl,(cli_data_sp) 
1e76				ld de, cli_data_stack 
1e76				call cmp16 
1e76				jp c, fault_dsp_under 
1e76				pop de 
1e76				pop hl 
1e76				endm 
1e76			 
1e76			 
1e76			FORTH_CHK_RSP_UNDER: macro 
1e76				push hl 
1e76				push de 
1e76				ld hl,(cli_ret_sp) 
1e76				ld de, cli_ret_stack 
1e76				call cmp16 
1e76				jp c, fault_rsp_under 
1e76				pop de 
1e76				pop hl 
1e76				endm 
1e76			 
1e76			FORTH_CHK_LOOP_UNDER: macro 
1e76				push hl 
1e76				push de 
1e76				ld hl,(cli_loop_sp) 
1e76				ld de, cli_loop_stack 
1e76				call cmp16 
1e76				jp c, fault_loop_under 
1e76				pop de 
1e76				pop hl 
1e76				endm 
1e76			 
1e76			FORTH_ERR_TOS_NOTSTR: macro 
1e76				; TOSO might need more for checks when used 
1e76				push af 
1e76				ld a,(hl) 
1e76				cp DS_TYPE_STR 
1e76				jp nz, type_faultn   
1e76				pop af 
1e76				endm 
1e76			 
1e76			FORTH_ERR_TOS_NOTNUM: macro 
1e76				push af 
1e76				ld a,(hl) 
1e76				cp DS_TYPE_INUM 
1e76				jp nz, type_faultn   
1e76				pop af 
1e76				endm 
1e76			 
1e76			 
1e76			; increase data stack pointer and save hl to it 
1e76				 
1e76			FORTH_DSP_NEXT: macro 
1e76				call macro_forth_dsp_next 
1e76				endm 
1e76			 
1e76			 
1e76			macro_forth_dsp_next: 
1e76				if DEBUG_FORTH_STACK_GUARD 
1e76 cd 40 66				call check_stacks 
1e79				endif 
1e79 e5				push hl 
1e7a d5				push de 
1e7b eb				ex de,hl 
1e7c 2a 2c fa			ld hl,(cli_data_sp) 
1e7f 23				inc hl 
1e80 23				inc hl 
1e81			 
1e81			; PARSEV5 
1e81 23				inc hl 
1e82 22 2c fa			ld (cli_data_sp),hl 
1e85 73				ld (hl), e 
1e86 23				inc hl 
1e87 72				ld (hl), d 
1e88 d1				pop de 
1e89 e1				pop hl 
1e8a				if DEBUG_FORTH_STACK_GUARD 
1e8a cd 40 66				call check_stacks 
1e8d				endif 
1e8d c9				ret 
1e8e			 
1e8e			 
1e8e			; increase ret stack pointer and save hl to it 
1e8e				 
1e8e			FORTH_RSP_NEXT: macro 
1e8e				call macro_forth_rsp_next 
1e8e				endm 
1e8e			 
1e8e			macro_forth_rsp_next: 
1e8e				if DEBUG_FORTH_STACK_GUARD 
1e8e cd 40 66				call check_stacks 
1e91				endif 
1e91 e5				push hl 
1e92 d5				push de 
1e93 eb				ex de,hl 
1e94 2a 30 fa			ld hl,(cli_ret_sp) 
1e97 23				inc hl 
1e98 23				inc hl 
1e99 22 30 fa			ld (cli_ret_sp),hl 
1e9c 73				ld (hl), e 
1e9d 23				inc hl 
1e9e 72				ld (hl), d 
1e9f d1				pop de 
1ea0 e1				pop hl 
1ea1				if DEBUG_FORTH_STACK_GUARD 
1ea1 cd 40 66				call check_stacks 
1ea4				endif 
1ea4 c9				ret 
1ea5			 
1ea5			; get current ret stack pointer and save to hl  
1ea5				 
1ea5			FORTH_RSP_TOS: macro 
1ea5				call macro_forth_rsp_tos 
1ea5				endm 
1ea5			 
1ea5			macro_forth_rsp_tos: 
1ea5				;push de 
1ea5 2a 30 fa			ld hl,(cli_ret_sp) 
1ea8 cd e0 1e			call loadhlptrtohl 
1eab				;ld e, (hl) 
1eab				;inc hl 
1eab				;ld d, (hl) 
1eab				;ex de, hl 
1eab					if DEBUG_FORTH_WORDS 
1eab			;			DMARK "RST" 
1eab						CALLMONITOR 
1eab cd 73 18			call break_point_state  
1eae				endm  
# End of macro CALLMONITOR
1eae					endif 
1eae				;pop de 
1eae c9				ret 
1eaf			 
1eaf			; pop ret stack pointer 
1eaf				 
1eaf			FORTH_RSP_POP: macro 
1eaf				call macro_forth_rsp_pop 
1eaf				endm 
1eaf			 
1eaf			 
1eaf			macro_forth_rsp_pop: 
1eaf				if DEBUG_FORTH_STACK_GUARD 
1eaf			;		DMARK "RPP" 
1eaf cd 40 66				call check_stacks 
1eb2					FORTH_CHK_RSP_UNDER 
1eb2 e5				push hl 
1eb3 d5				push de 
1eb4 2a 30 fa			ld hl,(cli_ret_sp) 
1eb7 11 ea f9			ld de, cli_ret_stack 
1eba cd ea 0e			call cmp16 
1ebd da 54 67			jp c, fault_rsp_under 
1ec0 d1				pop de 
1ec1 e1				pop hl 
1ec2				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ec2				endif 
1ec2 e5				push hl 
1ec3 2a 30 fa			ld hl,(cli_ret_sp) 
1ec6			 
1ec6			 
1ec6				if FORTH_ENABLE_FREE 
1ec6			 
1ec6					; get pointer 
1ec6			 
1ec6					push de 
1ec6					push hl 
1ec6			 
1ec6					ld e, (hl) 
1ec6					inc hl 
1ec6					ld d, (hl) 
1ec6			 
1ec6					ex de, hl 
1ec6					call free 
1ec6			 
1ec6					pop hl 
1ec6					pop de 
1ec6			 
1ec6			 
1ec6				endif 
1ec6			 
1ec6			 
1ec6 2b				dec hl 
1ec7 2b				dec hl 
1ec8 22 30 fa			ld (cli_ret_sp), hl 
1ecb				; do stack underflow checks 
1ecb e1				pop hl 
1ecc				if DEBUG_FORTH_STACK_GUARD 
1ecc cd 40 66				call check_stacks 
1ecf					FORTH_CHK_RSP_UNDER 
1ecf e5				push hl 
1ed0 d5				push de 
1ed1 2a 30 fa			ld hl,(cli_ret_sp) 
1ed4 11 ea f9			ld de, cli_ret_stack 
1ed7 cd ea 0e			call cmp16 
1eda da 54 67			jp c, fault_rsp_under 
1edd d1				pop de 
1ede e1				pop hl 
1edf				endm 
# End of macro FORTH_CHK_RSP_UNDER
1edf				endif 
1edf c9				ret 
1ee0			 
1ee0			 
1ee0			 
1ee0			; routine to load word pointed to by hl into hl 
1ee0			 
1ee0			loadhlptrtohl: 
1ee0			 
1ee0 d5				push de 
1ee1 5e				ld e, (hl) 
1ee2 23				inc hl 
1ee3 56				ld d, (hl) 
1ee4 eb				ex de, hl 
1ee5 d1				pop de 
1ee6			 
1ee6 c9				ret 
1ee7			 
1ee7			 
1ee7			 
1ee7			 
1ee7			 
1ee7			; push a number held in HL onto the data stack 
1ee7			; entry point for pushing a value when already in hl used in function above 
1ee7			 
1ee7			forth_push_numhl: 
1ee7			 
1ee7 e5				push hl    ; save value to push 
1ee8			 
1ee8			if DEBUG_FORTH_PUSH 
1ee8				; see if disabled 
1ee8			 
1ee8			 
1ee8 f5				push af 
1ee9 3a f0 f1			ld a, (os_view_disable) 
1eec fe 2a			cp '*' 
1eee 28 34			jr z, .pskip2 
1ef0 e5				push hl 
1ef1 e5			push hl 
1ef2 cd 98 0c			call clear_display 
1ef5 e1			pop hl 
1ef6 7c				ld a,h 
1ef7 21 04 f5			ld hl, os_word_scratch 
1efa cd cd 11			call hexout 
1efd e1				pop hl 
1efe 7d				ld a,l 
1eff 21 06 f5			ld hl, os_word_scratch+2 
1f02 cd cd 11			call hexout 
1f05			 
1f05 21 08 f5			ld hl, os_word_scratch+4 
1f08 3e 00			ld a,0 
1f0a 77				ld (hl),a 
1f0b 11 04 f5			ld de,os_word_scratch 
1f0e 3e 28				ld a, display_row_2 
1f10 cd ab 0c				call str_at_display 
1f13 11 f7 54			ld de, .push_num 
1f16 3e 00			ld a, display_row_1 
1f18			 
1f18 cd ab 0c				call str_at_display 
1f1b			 
1f1b			 
1f1b cd bb 0c			call update_display 
1f1e cd 15 0c			call delay1s 
1f21 cd 15 0c			call delay1s 
1f24			.pskip2:  
1f24			 
1f24 f1				pop af 
1f25			endif	 
1f25			 
1f25			 
1f25				FORTH_DSP_NEXT 
1f25 cd 76 1e			call macro_forth_dsp_next 
1f28				endm 
# End of macro FORTH_DSP_NEXT
1f28			 
1f28 2a 2c fa			ld hl, (cli_data_sp) 
1f2b			 
1f2b				; save item type 
1f2b 3e 02			ld a,  DS_TYPE_INUM 
1f2d 77				ld (hl), a 
1f2e 23				inc hl 
1f2f			 
1f2f				; get word off stack 
1f2f d1				pop de 
1f30 7b				ld a,e 
1f31 77				ld (hl), a 
1f32 23				inc hl 
1f33 7a				ld a,d 
1f34 77				ld (hl), a 
1f35			 
1f35			if DEBUG_FORTH_PUSH 
1f35 2b				dec hl 
1f36 2b				dec hl 
1f37 2b				dec hl 
1f38						DMARK "PH5" 
1f38 f5				push af  
1f39 3a 4d 1f			ld a, (.dmark)  
1f3c 32 6e fe			ld (debug_mark),a  
1f3f 3a 4e 1f			ld a, (.dmark+1)  
1f42 32 6f fe			ld (debug_mark+1),a  
1f45 3a 4f 1f			ld a, (.dmark+2)  
1f48 32 70 fe			ld (debug_mark+2),a  
1f4b 18 03			jr .pastdmark  
1f4d ..			.dmark: db "PH5"  
1f50 f1			.pastdmark: pop af  
1f51			endm  
# End of macro DMARK
1f51				CALLMONITOR 
1f51 cd 73 18			call break_point_state  
1f54				endm  
# End of macro CALLMONITOR
1f54			endif	 
1f54			 
1f54 c9				ret 
1f55			 
1f55			 
1f55			; Push a string to stack pointed to by hl 
1f55			 
1f55			forth_push_str: 
1f55			 
1f55			if DEBUG_FORTH_PUSH 
1f55						DMARK "PSQ" 
1f55 f5				push af  
1f56 3a 6a 1f			ld a, (.dmark)  
1f59 32 6e fe			ld (debug_mark),a  
1f5c 3a 6b 1f			ld a, (.dmark+1)  
1f5f 32 6f fe			ld (debug_mark+1),a  
1f62 3a 6c 1f			ld a, (.dmark+2)  
1f65 32 70 fe			ld (debug_mark+2),a  
1f68 18 03			jr .pastdmark  
1f6a ..			.dmark: db "PSQ"  
1f6d f1			.pastdmark: pop af  
1f6e			endm  
# End of macro DMARK
1f6e				CALLMONITOR 
1f6e cd 73 18			call break_point_state  
1f71				endm  
# End of macro CALLMONITOR
1f71			endif	 
1f71			    
1f71 e5				push hl 
1f72 e5				push hl 
1f73			 
1f73			;	ld a, 0   ; find end of string 
1f73 cd 2a 13			call strlenz 
1f76			if DEBUG_FORTH_PUSH 
1f76						DMARK "PQ2" 
1f76 f5				push af  
1f77 3a 8b 1f			ld a, (.dmark)  
1f7a 32 6e fe			ld (debug_mark),a  
1f7d 3a 8c 1f			ld a, (.dmark+1)  
1f80 32 6f fe			ld (debug_mark+1),a  
1f83 3a 8d 1f			ld a, (.dmark+2)  
1f86 32 70 fe			ld (debug_mark+2),a  
1f89 18 03			jr .pastdmark  
1f8b ..			.dmark: db "PQ2"  
1f8e f1			.pastdmark: pop af  
1f8f			endm  
# End of macro DMARK
1f8f				CALLMONITOR 
1f8f cd 73 18			call break_point_state  
1f92				endm  
# End of macro CALLMONITOR
1f92			endif	 
1f92 eb				ex de, hl 
1f93 e1				pop hl   ; get ptr to start of string 
1f94			if DEBUG_FORTH_PUSH 
1f94						DMARK "PQ3" 
1f94 f5				push af  
1f95 3a a9 1f			ld a, (.dmark)  
1f98 32 6e fe			ld (debug_mark),a  
1f9b 3a aa 1f			ld a, (.dmark+1)  
1f9e 32 6f fe			ld (debug_mark+1),a  
1fa1 3a ab 1f			ld a, (.dmark+2)  
1fa4 32 70 fe			ld (debug_mark+2),a  
1fa7 18 03			jr .pastdmark  
1fa9 ..			.dmark: db "PQ3"  
1fac f1			.pastdmark: pop af  
1fad			endm  
# End of macro DMARK
1fad				CALLMONITOR 
1fad cd 73 18			call break_point_state  
1fb0				endm  
# End of macro CALLMONITOR
1fb0			endif	 
1fb0 19				add hl,de 
1fb1			if DEBUG_FORTH_PUSH 
1fb1						DMARK "PQE" 
1fb1 f5				push af  
1fb2 3a c6 1f			ld a, (.dmark)  
1fb5 32 6e fe			ld (debug_mark),a  
1fb8 3a c7 1f			ld a, (.dmark+1)  
1fbb 32 6f fe			ld (debug_mark+1),a  
1fbe 3a c8 1f			ld a, (.dmark+2)  
1fc1 32 70 fe			ld (debug_mark+2),a  
1fc4 18 03			jr .pastdmark  
1fc6 ..			.dmark: db "PQE"  
1fc9 f1			.pastdmark: pop af  
1fca			endm  
# End of macro DMARK
1fca				CALLMONITOR 
1fca cd 73 18			call break_point_state  
1fcd				endm  
# End of macro CALLMONITOR
1fcd			endif	 
1fcd			 
1fcd 2b				dec hl    ; see if there is an optional trailing double quote 
1fce 7e				ld a,(hl) 
1fcf fe 22			cp '"' 
1fd1 20 03			jr nz, .strnoq 
1fd3 3e 00			ld a, 0      ; get rid of double quote 
1fd5 77				ld (hl), a 
1fd6 23			.strnoq: inc hl 
1fd7			 
1fd7 3e 00			ld a, 0 
1fd9 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1fda			 
1fda 13				inc de ; add one for the type string 
1fdb 13				inc de ; add one for null term??? 
1fdc			 
1fdc				; tos is get string pointer again 
1fdc				; de contains space to allocate 
1fdc				 
1fdc d5				push de 
1fdd			 
1fdd eb				ex de, hl 
1fde			 
1fde				;push af 
1fde			 
1fde			if DEBUG_FORTH_PUSH 
1fde						DMARK "PHm" 
1fde f5				push af  
1fdf 3a f3 1f			ld a, (.dmark)  
1fe2 32 6e fe			ld (debug_mark),a  
1fe5 3a f4 1f			ld a, (.dmark+1)  
1fe8 32 6f fe			ld (debug_mark+1),a  
1feb 3a f5 1f			ld a, (.dmark+2)  
1fee 32 70 fe			ld (debug_mark+2),a  
1ff1 18 03			jr .pastdmark  
1ff3 ..			.dmark: db "PHm"  
1ff6 f1			.pastdmark: pop af  
1ff7			endm  
# End of macro DMARK
1ff7				CALLMONITOR 
1ff7 cd 73 18			call break_point_state  
1ffa				endm  
# End of macro CALLMONITOR
1ffa			endif	 
1ffa cd 93 13			call malloc	; on ret hl now contains allocated memory 
1ffd				if DEBUG_FORTH_MALLOC_GUARD 
1ffd cc 4f 55				call z,malloc_error 
2000				endif 
2000			 
2000				 
2000 c1				pop bc    ; get length 
2001 d1				pop de   ;  get string start    
2002			 
2002				; hl has destination from malloc 
2002			 
2002 eb				ex de, hl    ; prep for ldir 
2003			 
2003 d5				push de   ; save malloc area for DSP later 
2004				;push hl   ; save malloc area for DSP later 
2004			 
2004			if DEBUG_FORTH_PUSH 
2004						DMARK "PHc" 
2004 f5				push af  
2005 3a 19 20			ld a, (.dmark)  
2008 32 6e fe			ld (debug_mark),a  
200b 3a 1a 20			ld a, (.dmark+1)  
200e 32 6f fe			ld (debug_mark+1),a  
2011 3a 1b 20			ld a, (.dmark+2)  
2014 32 70 fe			ld (debug_mark+2),a  
2017 18 03			jr .pastdmark  
2019 ..			.dmark: db "PHc"  
201c f1			.pastdmark: pop af  
201d			endm  
# End of macro DMARK
201d				CALLMONITOR 
201d cd 73 18			call break_point_state  
2020				endm  
# End of macro CALLMONITOR
2020			endif	 
2020			 
2020			 
2020 ed b0			ldir 
2022			 
2022			 
2022				; push malloc to data stack     macro?????  
2022			 
2022				FORTH_DSP_NEXT 
2022 cd 76 1e			call macro_forth_dsp_next 
2025				endm 
# End of macro FORTH_DSP_NEXT
2025			 
2025				; save value and type 
2025			 
2025 2a 2c fa			ld hl, (cli_data_sp) 
2028			 
2028				; save item type 
2028 3e 01			ld a,  DS_TYPE_STR 
202a 77				ld (hl), a 
202b 23				inc hl 
202c			 
202c				; get malloc word off stack 
202c d1				pop de 
202d 73				ld (hl), e 
202e 23				inc hl 
202f 72				ld (hl), d 
2030			 
2030			 
2030			 
2030			if DEBUG_FORTH_PUSH 
2030 2a 2c fa			ld hl, (cli_data_sp) 
2033						DMARK "PHS" 
2033 f5				push af  
2034 3a 48 20			ld a, (.dmark)  
2037 32 6e fe			ld (debug_mark),a  
203a 3a 49 20			ld a, (.dmark+1)  
203d 32 6f fe			ld (debug_mark+1),a  
2040 3a 4a 20			ld a, (.dmark+2)  
2043 32 70 fe			ld (debug_mark+2),a  
2046 18 03			jr .pastdmark  
2048 ..			.dmark: db "PHS"  
204b f1			.pastdmark: pop af  
204c			endm  
# End of macro DMARK
204c				CALLMONITOR 
204c cd 73 18			call break_point_state  
204f				endm  
# End of macro CALLMONITOR
204f			;	ex de,hl 
204f			endif	 
204f				; in case of spaces, skip the ptr past the copied string 
204f				;pop af 
204f				;ld (cli_origptr),hl 
204f			 
204f c9				ret 
2050			 
2050			 
2050			 
2050			; TODO ascii push input onto stack given hl to start of input 
2050			 
2050			; identify type 
2050			; if starts with a " then a string 
2050			; otherwise it is a number 
2050			;  
2050			; if a string 
2050			;     scan for ending " to get length of string to malloc for + 1 
2050			;     malloc 
2050			;     put pointer to string on stack first byte flags as string 
2050			; 
2050			; else a number 
2050			;    look for number format identifier 
2050			;    $xx hex 
2050			;    %xxxxx bin 
2050			;    xxxxx decimal 
2050			;    convert number to 16bit word.  
2050			;    malloc word + 1 with flag to identiy as num 
2050			;    put pointer to number on stack 
2050			;   
2050			;  
2050			  
2050			forth_apush: 
2050				; kernel push 
2050			 
2050			if DEBUG_FORTH_PUSH 
2050						DMARK "PSH" 
2050 f5				push af  
2051 3a 65 20			ld a, (.dmark)  
2054 32 6e fe			ld (debug_mark),a  
2057 3a 66 20			ld a, (.dmark+1)  
205a 32 6f fe			ld (debug_mark+1),a  
205d 3a 67 20			ld a, (.dmark+2)  
2060 32 70 fe			ld (debug_mark+2),a  
2063 18 03			jr .pastdmark  
2065 ..			.dmark: db "PSH"  
2068 f1			.pastdmark: pop af  
2069			endm  
# End of macro DMARK
2069				CALLMONITOR 
2069 cd 73 18			call break_point_state  
206c				endm  
# End of macro CALLMONITOR
206c			endif	 
206c				; identify input type 
206c			 
206c 7e				ld a,(hl) 
206d fe 22			cp '"' 
206f 28 0a			jr z, .fapstr 
2071 fe 24			cp '$' 
2073 ca 9b 20			jp z, .faphex 
2076 fe 25			cp '%' 
2078 ca 83 20			jp z, .fapbin 
207b			;	cp 'b' 
207b			;	jp z, .fabin 
207b				; else decimal 
207b			 
207b				; TODO do decimal conversion 
207b				; decimal is stored as a 16bit word 
207b			 
207b				; by default everything is a string if type is not detected 
207b			.fapstr: ; 
207b fe 22			cp '"' 
207d 20 01			jr nz, .strnoqu 
207f 23				inc hl 
2080			.strnoqu: 
2080 c3 55 1f			jp forth_push_str 
2083			 
2083			 
2083			 
2083			.fapbin:    ; push a binary string.  
2083 11 00 00			ld de, 0   ; hold a 16bit value 
2086			 
2086 23			.fapbinshift:	inc hl  
2087 7e				ld a,(hl) 
2088 fe 00			cp 0     ; done scanning  
208a 28 0b			jr z, .fapbdone  	; got it in HL so push  
208c			 
208c				; left shift de 
208c eb				ex de, hl	 
208d 29				add hl, hl 
208e			 
208e				; is 1 
208e fe 31			cp '1' 
2090 20 02			jr nz, .binzero 
2092 cb 4d			bit 1, l 
2094			.binzero: 
2094 eb				ex de, hl	 ; save current de 
2095 18 ef			jr .fapbinshift 
2097			 
2097			.fapbdone: 
2097 eb				ex de, hl 
2098 c3 e7 1e			jp forth_push_numhl 
209b			 
209b			 
209b			.faphex:   ; hex is always stored as a 16bit word 
209b				; skip number prefix 
209b 23				inc hl 
209c				; turn ascii into number 
209c cd 83 12			call get_word_hl	; ret 16bit word in hl 
209f			 
209f c3 e7 1e			jp forth_push_numhl 
20a2			 
20a2 00				 nop 
20a3			 
20a3			.fabin:   ; TODO bin conversion 
20a3			 
20a3			 
20a3 c9				ret 
20a4			 
20a4			 
20a4			; get either a string ptr or a 16bit word from the data stack 
20a4			 
20a4			FORTH_DSP: macro 
20a4				call macro_forth_dsp 
20a4				endm 
20a4			 
20a4			macro_forth_dsp: 
20a4				; data stack pointer points to current word on tos 
20a4			 
20a4 2a 2c fa			ld hl,(cli_data_sp) 
20a7			 
20a7				if DEBUG_FORTH_PUSH 
20a7						DMARK "DSP" 
20a7 f5				push af  
20a8 3a bc 20			ld a, (.dmark)  
20ab 32 6e fe			ld (debug_mark),a  
20ae 3a bd 20			ld a, (.dmark+1)  
20b1 32 6f fe			ld (debug_mark+1),a  
20b4 3a be 20			ld a, (.dmark+2)  
20b7 32 70 fe			ld (debug_mark+2),a  
20ba 18 03			jr .pastdmark  
20bc ..			.dmark: db "DSP"  
20bf f1			.pastdmark: pop af  
20c0			endm  
# End of macro DMARK
20c0			 
20c0 cd 84 55				call display_data_sp 
20c3				;call break_point_state 
20c3				;rst 030h 
20c3				CALLMONITOR 
20c3 cd 73 18			call break_point_state  
20c6				endm  
# End of macro CALLMONITOR
20c6				endif 
20c6			 
20c6 c9				ret 
20c7			 
20c7			; return hl to start of value on stack 
20c7			 
20c7			FORTH_DSP_VALUE: macro 
20c7				call macro_forth_dsp_value 
20c7				endm 
20c7			 
20c7			macro_forth_dsp_value: 
20c7			 
20c7				FORTH_DSP 
20c7 cd a4 20			call macro_forth_dsp 
20ca				endm 
# End of macro FORTH_DSP
20ca			 
20ca d5				push de 
20cb			 
20cb 23				inc hl ; skip type 
20cc			 
20cc 5e				ld e, (hl) 
20cd 23				inc hl 
20ce 56				ld d, (hl) 
20cf eb				ex de,hl  
20d0			 
20d0 d1				pop de 
20d1			 
20d1 c9				ret 
20d2			 
20d2			; return hl to start of value to second item on stack 
20d2			 
20d2			FORTH_DSP_VALUEM1: macro 
20d2				call macro_forth_dsp_value_m1 
20d2				endm 
20d2			 
20d2			macro_forth_dsp_value_m1: 
20d2			 
20d2				FORTH_DSP 
20d2 cd a4 20			call macro_forth_dsp 
20d5				endm 
# End of macro FORTH_DSP
20d5			 
20d5 2b				dec hl 
20d6 2b				dec hl 
20d7			;	dec hl 
20d7			 
20d7 d5				push de 
20d8			 
20d8 5e				ld e, (hl) 
20d9 23				inc hl 
20da 56				ld d, (hl) 
20db eb				ex de,hl  
20dc			 
20dc d1				pop de 
20dd			 
20dd c9				ret 
20de			 
20de				 
20de			 
20de			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
20de			 
20de			FORTH_DSP_POP: macro 
20de				call macro_forth_dsp_pop 
20de				endm 
20de			 
20de			 
20de			; get the tos data type 
20de			 
20de			FORTH_DSP_TYPE:   macro 
20de			 
20de				;FORTH_DSP_VALUE 
20de				FORTH_DSP 
20de				 
20de				; hl points to value 
20de				; check type 
20de			 
20de				ld a,(hl) 
20de			 
20de				endm 
20de			 
20de			; load the tos value into hl 
20de			 
20de			 
20de			FORTH_DSP_VALUEHL:  macro 
20de				call macro_dsp_valuehl 
20de				endm 
20de			 
20de			 
20de			 
20de			macro_dsp_valuehl: 
20de				FORTH_DSP_VALUE 
20de cd c7 20			call macro_forth_dsp_value 
20e1				endm 
# End of macro FORTH_DSP_VALUE
20e1			 
20e1				;FORTH_ERR_TOS_NOTNUM 
20e1			 
20e1				;inc hl   ; skip type id 
20e1			 
20e1			;	push de 
20e1			; 
20e1			;	ld e, (hl) 
20e1			;	inc hl 
20e1			;	ld d, (hl) 
20e1			;	ex de,hl  
20e1			 
20e1			;	pop de 
20e1			 
20e1				if DEBUG_FORTH_PUSH 
20e1						DMARK "DVL" 
20e1 f5				push af  
20e2 3a f6 20			ld a, (.dmark)  
20e5 32 6e fe			ld (debug_mark),a  
20e8 3a f7 20			ld a, (.dmark+1)  
20eb 32 6f fe			ld (debug_mark+1),a  
20ee 3a f8 20			ld a, (.dmark+2)  
20f1 32 70 fe			ld (debug_mark+2),a  
20f4 18 03			jr .pastdmark  
20f6 ..			.dmark: db "DVL"  
20f9 f1			.pastdmark: pop af  
20fa			endm  
# End of macro DMARK
20fa				CALLMONITOR 
20fa cd 73 18			call break_point_state  
20fd				endm  
# End of macro CALLMONITOR
20fd				endif 
20fd c9				ret 
20fe			 
20fe			forth_apushstrhl:      
20fe				; push of string requires use of cli_origptr 
20fe				; bodge use 
20fe			 
20fe				; get current cli_origptr, save, update with temp pointer  
20fe ed 5b 48 fa		ld de, (cli_origptr) 
2102 22 48 fa			ld (cli_origptr), hl 
2105 d5				push de 
2106 cd 50 20			call forth_apush 
2109 d1				pop de 
210a ed 53 48 fa		ld (cli_origptr), de 
210e c9			        ret	 
210f			 
210f			 
210f			; increase loop stack pointer and save hl to it 
210f				 
210f			FORTH_LOOP_NEXT: macro 
210f				call macro_forth_loop_next 
210f				;nop 
210f				endm 
210f			 
210f			macro_forth_loop_next: 
210f				if DEBUG_FORTH_STACK_GUARD 
210f cd 40 66				call check_stacks 
2112				endif 
2112 e5				push hl 
2113 d5				push de 
2114 eb				ex de,hl 
2115 2a 2e fa			ld hl,(cli_loop_sp) 
2118 23				inc hl 
2119 23				inc hl 
211a					if DEBUG_FORTH_WORDS 
211a						DMARK "LNX" 
211a f5				push af  
211b 3a 2f 21			ld a, (.dmark)  
211e 32 6e fe			ld (debug_mark),a  
2121 3a 30 21			ld a, (.dmark+1)  
2124 32 6f fe			ld (debug_mark+1),a  
2127 3a 31 21			ld a, (.dmark+2)  
212a 32 70 fe			ld (debug_mark+2),a  
212d 18 03			jr .pastdmark  
212f ..			.dmark: db "LNX"  
2132 f1			.pastdmark: pop af  
2133			endm  
# End of macro DMARK
2133						CALLMONITOR 
2133 cd 73 18			call break_point_state  
2136				endm  
# End of macro CALLMONITOR
2136					endif 
2136 22 2e fa			ld (cli_loop_sp),hl 
2139 73				ld (hl), e 
213a 23				inc hl 
213b 72				ld (hl), d 
213c d1				pop de    ; been reversed so save a swap on restore 
213d e1				pop hl 
213e				if DEBUG_FORTH_STACK_GUARD 
213e cd 40 66				call check_stacks 
2141				endif 
2141 c9				ret 
2142			 
2142			; get current ret stack pointer and save to hl  
2142				 
2142			FORTH_LOOP_TOS: macro 
2142				call macro_forth_loop_tos 
2142				endm 
2142			 
2142			macro_forth_loop_tos: 
2142 d5				push de 
2143 2a 2e fa			ld hl,(cli_loop_sp) 
2146 5e				ld e, (hl) 
2147 23				inc hl 
2148 56				ld d, (hl) 
2149 eb				ex de, hl 
214a d1				pop de 
214b c9				ret 
214c			 
214c			; pop loop stack pointer 
214c				 
214c			FORTH_LOOP_POP: macro 
214c				call macro_forth_loop_pop 
214c				endm 
214c			 
214c			 
214c			macro_forth_loop_pop: 
214c				if DEBUG_FORTH_STACK_GUARD 
214c					DMARK "LPP" 
214c f5				push af  
214d 3a 61 21			ld a, (.dmark)  
2150 32 6e fe			ld (debug_mark),a  
2153 3a 62 21			ld a, (.dmark+1)  
2156 32 6f fe			ld (debug_mark+1),a  
2159 3a 63 21			ld a, (.dmark+2)  
215c 32 70 fe			ld (debug_mark+2),a  
215f 18 03			jr .pastdmark  
2161 ..			.dmark: db "LPP"  
2164 f1			.pastdmark: pop af  
2165			endm  
# End of macro DMARK
2165 cd 40 66				call check_stacks 
2168					FORTH_CHK_LOOP_UNDER 
2168 e5				push hl 
2169 d5				push de 
216a 2a 2e fa			ld hl,(cli_loop_sp) 
216d 11 68 f9			ld de, cli_loop_stack 
2170 cd ea 0e			call cmp16 
2173 da 5a 67			jp c, fault_loop_under 
2176 d1				pop de 
2177 e1				pop hl 
2178				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2178				endif 
2178 e5				push hl 
2179 2a 2e fa			ld hl,(cli_loop_sp) 
217c 2b				dec hl 
217d 2b				dec hl 
217e 22 2e fa			ld (cli_loop_sp), hl 
2181				; TODO do stack underflow checks 
2181 e1				pop hl 
2182				if DEBUG_FORTH_STACK_GUARD 
2182 cd 40 66				call check_stacks 
2185					FORTH_CHK_LOOP_UNDER 
2185 e5				push hl 
2186 d5				push de 
2187 2a 2e fa			ld hl,(cli_loop_sp) 
218a 11 68 f9			ld de, cli_loop_stack 
218d cd ea 0e			call cmp16 
2190 da 5a 67			jp c, fault_loop_under 
2193 d1				pop de 
2194 e1				pop hl 
2195				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2195				endif 
2195 c9				ret 
2196			 
2196			macro_forth_dsp_pop: 
2196			 
2196 e5				push hl 
2197			 
2197				; release malloc data 
2197			 
2197				if DEBUG_FORTH_STACK_GUARD 
2197 cd 40 66				call check_stacks 
219a					FORTH_CHK_DSP_UNDER 
219a e5				push hl 
219b d5				push de 
219c 2a 2c fa			ld hl,(cli_data_sp) 
219f 11 66 f7			ld de, cli_data_stack 
21a2 cd ea 0e			call cmp16 
21a5 da 4e 67			jp c, fault_dsp_under 
21a8 d1				pop de 
21a9 e1				pop hl 
21aa				endm 
# End of macro FORTH_CHK_DSP_UNDER
21aa				endif 
21aa				;ld hl,(cli_data_sp) 
21aa			if DEBUG_FORTH_DOT 
21aa				DMARK "DPP" 
21aa				CALLMONITOR 
21aa			endif	 
21aa			 
21aa			 
21aa			if FORTH_ENABLE_DSPPOPFREE 
21aa			 
21aa				FORTH_DSP 
21aa cd a4 20			call macro_forth_dsp 
21ad				endm 
# End of macro FORTH_DSP
21ad			 
21ad 7e				ld a, (hl) 
21ae fe 01			cp DS_TYPE_STR 
21b0 20 07			jr nz, .skippopfree 
21b2			 
21b2				FORTH_DSP_VALUEHL 
21b2 cd de 20			call macro_dsp_valuehl 
21b5				endm 
# End of macro FORTH_DSP_VALUEHL
21b5 00				nop 
21b6			if DEBUG_FORTH_DOT 
21b6				DMARK "DPf" 
21b6				CALLMONITOR 
21b6			endif	 
21b6 cd 5d 14			call free 
21b9			.skippopfree: 
21b9				 
21b9			 
21b9			endif 
21b9			 
21b9			if DEBUG_FORTH_DOT_KEY 
21b9				DMARK "DP2" 
21b9				CALLMONITOR 
21b9			endif	 
21b9			 
21b9				; move pointer down 
21b9			 
21b9 2a 2c fa			ld hl,(cli_data_sp) 
21bc 2b				dec hl 
21bd 2b				dec hl 
21be			; PARSEV5 
21be 2b				dec hl 
21bf 22 2c fa			ld (cli_data_sp), hl 
21c2			 
21c2				if DEBUG_FORTH_STACK_GUARD 
21c2 cd 40 66				call check_stacks 
21c5					FORTH_CHK_DSP_UNDER 
21c5 e5				push hl 
21c6 d5				push de 
21c7 2a 2c fa			ld hl,(cli_data_sp) 
21ca 11 66 f7			ld de, cli_data_stack 
21cd cd ea 0e			call cmp16 
21d0 da 4e 67			jp c, fault_dsp_under 
21d3 d1				pop de 
21d4 e1				pop hl 
21d5				endm 
# End of macro FORTH_CHK_DSP_UNDER
21d5				endif 
21d5			 
21d5 e1				pop hl 
21d6			 
21d6 c9				ret 
21d7			 
21d7			getwordathl: 
21d7				; hl points to an address 
21d7				; load hl with the word at that address 
21d7			 
21d7 d5				push de 
21d8			 
21d8 5e				ld e, (hl) 
21d9 23				inc hl 
21da 56				ld d, (hl) 
21db eb				ex de, hl 
21dc			 
21dc d1				pop de 
21dd c9				ret 
21de			 
21de			 
21de			 
21de			 
21de			 
21de			; eof 
21de			 
# End of file forth_stackopsv5.asm
21de			endif 
21de			 
21de			user_word_eol:  
21de				; hl contains the pointer to where to create a linked list item from the end 
21de				; of the user dict to continue on at the system word dict 
21de				 
21de				; poke the stub of the word list linked list to repoint to rom words 
21de			 
21de				; stub format 
21de				; db   word id 
21de				; dw    link to next word 
21de			        ; db char length of token 
21de				; db string + 0 term 
21de				; db exec code....  
21de			 
21de 3e 00			ld a, WORD_SYS_ROOT     ; root word 
21e0 77				ld (hl), a		; word id 
21e1 23				inc hl 
21e2			 
21e2 11 ad 23			ld de, sysdict 
21e5 73				ld (hl), e		; next word link ie system dict 
21e6 23				inc hl 
21e7 72				ld (hl), d		; next word link ie system dict 
21e8 23				inc hl	 
21e9			 
21e9			;	ld (hl), sysdict		; next word link ie system dict 
21e9			;	inc hl 
21e9			;	inc hl 
21e9			 
21e9			;	inc hl 
21e9			;	inc hl 
21e9			 
21e9 3e 02			ld a, 2			; word length is 0 
21eb 77				ld (hl), a	 
21ec 23				inc hl 
21ed			 
21ed 3e 7e			ld a, '~'			; word length is 0 
21ef 77				ld (hl), a	 
21f0 23				inc hl 
21f1 3e 00			ld a, 0			; save empty word 
21f3 77				ld (hl), a 
21f4			 
21f4 c9				ret 
21f5			 
21f5				 
21f5			 
21f5			forthexec_cleanup: 
21f5				FORTH_RSP_POP 
21f5 cd af 1e			call macro_forth_rsp_pop 
21f8				endm 
# End of macro FORTH_RSP_POP
21f8 c9				ret 
21f9			 
21f9			forth_call_hl: 
21f9				; taking hl 
21f9 e5				push hl 
21fa c9				ret 
21fb			 
21fb			; this is called to reset Forth system but keep existing uwords etc 
21fb			 
21fb			forth_warmstart: 
21fb				; setup stack over/under flow checks 
21fb				if DEBUG_FORTH_STACK_GUARD 
21fb cd 26 66				call chk_stk_init 
21fe				endif 
21fe			 
21fe				; init stack pointers  - * these stacks go upwards *  
21fe 21 ea f9			ld hl, cli_ret_stack 
2201 22 30 fa			ld (cli_ret_sp), hl	 
2204				; set bottom of stack 
2204 3e 00			ld a,0 
2206 77				ld (hl),a 
2207 23				inc hl 
2208 77				ld (hl),a 
2209			 
2209 21 66 f7			ld hl, cli_data_stack 
220c 22 2c fa			ld (cli_data_sp), hl	 
220f				; set bottom of stack 
220f 3e 00			ld a,0 
2211 77				ld (hl),a 
2212 23				inc hl 
2213 77				ld (hl),a 
2214			 
2214 21 68 f9			ld hl, cli_loop_stack 
2217 22 2e fa			ld (cli_loop_sp), hl	 
221a				; set bottom of stack 
221a 3e 00			ld a,0 
221c 77				ld (hl),a 
221d 23				inc hl 
221e 77				ld (hl),a 
221f			 
221f				; init extent of current open file 
221f			 
221f 3e 00			ld a, 0 
2221 32 73 fa			ld (store_openext), a 
2224			 
2224 c9				ret 
2225			 
2225			 
2225			; Cold Start - this is called to setup the whole Forth system 
2225			 
2225			forth_init: 
2225			 
2225				; setup stack over/under flow checks 
2225			 
2225			;	if DEBUG_FORTH_STACK_GUARD 
2225			;		call chk_stk_init 
2225			;	endif 
2225			 
2225				; enable auto display updates (slow.....) 
2225			 
2225 3e 01			ld a, 1 
2227 32 46 fa			ld (cli_autodisplay), a 
222a			 
222a				; if storage is in use disable long reads for now 
222a 3e 00			ld a, 0 
222c 32 7c fa			ld (store_longread), a 
222f			 
222f			 
222f				; show start up screen 
222f			 
222f cd 98 0c			call clear_display 
2232			 
2232 3e 00			ld a,0 
2234 32 68 fa			ld (f_cursor_ptr), a 
2237			 
2237				; set start of word list in start of ram - for use when creating user words 
2237			 
2237 21 00 80			ld hl, baseram 
223a 22 fc f4			ld (os_last_new_uword), hl 
223d cd de 21			call user_word_eol 
2240				 
2240			;		call display_data_sp 
2240			;		call next_page_prompt 
2240			 
2240			 
2240			 
2240			 
2240 c9				ret 
2241			 
2241 .. 00		.bootforth: db " Forth Kernel Init ",0 
2255			 
2255			; TODO push to stack 
2255			 
2255			;  
2255			 
2255			if FORTH_PARSEV2 
2255			 
2255			 
2255				include "forth_parserv2.asm" 
2255			 
2255			endif 
2255			 
2255			 
2255			; parse cli version 1 
2255			 
2255			if FORTH_PARSEV1 
2255			 
2255			 
2255			 
2255			      include "forth_parserv1.asm" 
2255			endif 
2255				 
2255			if FORTH_PARSEV3 
2255			 
2255			 
2255			 
2255			      include "forth_parserv3.asm" 
2255				include "forth_wordsv3.asm" 
2255			endif 
2255			 
2255			if FORTH_PARSEV4 
2255			 
2255			 
2255			 
2255			      include "forth_parserv4.asm" 
2255				include "forth_wordsv4.asm" 
2255			endif 
2255			 
2255			if FORTH_PARSEV5 
2255			 
2255			 
2255			 
2255			      include "forth_parserv5.asm" 
2255			 
2255			 
2255			; A better parser without using malloc and string copies all over the place.  
2255			; Exec in situ should be faster 
2255			 
2255			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2255			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2255			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2255			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2255			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2255			WORD_SYS_END: equ 0   ; Opcode for all user words 
2255			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2255			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2255			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2255			 
2255			; Core word preamble macro 
2255			 
2255			CWHEAD:   macro nxtword opcode lit len opflags 
2255				db WORD_SYS_CORE+opcode             
2255				; internal op code number 
2255				dw nxtword            
2255				; link to next dict word block 
2255				db len + 1 
2255				; literal length of dict word inc zero term 
2255				db lit,0              
2255				; literal dict word 
2255			        ; TODO db opflags        
2255				endm 
2255			 
2255			 
2255			NEXTW: macro  
2255				jp macro_next 
2255				endm 
2255			 
2255			macro_next: 
2255			if DEBUG_FORTH_PARSE_KEY 
2255				DMARK "NXT" 
2255				CALLMONITOR 
2255			endif	 
2255			;	inc hl  ; skip token null term  
2255 ed 4b 4a fa		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2259 ed 5b 48 fa		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
225d 2a 00 f5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2260			if DEBUG_FORTH_PARSE_KEY 
2260				DMARK "}AA" 
2260				CALLMONITOR 
2260			endif	 
2260 c3 63 23			jp execnext 
2263				;jp exec1 
2263			       
2263			 
2263			 
2263			; Another go at the parser to compile  
2263			 
2263			 
2263			; TODO rework parser to change all of the string words to byte tokens 
2263			; TODO do a search for  
2263			 
2263			; TODO first run normal parser to zero term sections 
2263			; TODO for each word do a token look up to get the op code 
2263			; TODO need some means to flag to the exec that this is a byte code form    
2263			 
2263			 
2263			forthcompile: 
2263			 
2263			; 
2263			; line parse: 
2263			;       parse raw input buffer 
2263			;       tokenise the words 
2263			;       malloc new copy (for looping etc) 
2263			;       copy to malloc + current pc in line to start of string and add line term 
2263			;       save on new rsp 
2263			; 
2263			 
2263			; hl to point to the line to tokenise 
2263			 
2263			;	push hl 
2263 22 00 f5			ld (os_tok_ptr), hl  ; save ptr to string 
2266			 
2266			;	ld a,0		; string term on input 
2266			;	call strlent 
2266			 
2266			;	ld (os_tok_len), hl	 ; save string length 
2266			 
2266			;if DEBUG_FORTH_TOK 
2266			;	ex de,hl		 
2266			;endif 
2266			 
2266			;	pop hl 		; get back string pointer 
2266			 
2266			if DEBUG_FORTH_TOK 
2266						DMARK "TOc" 
2266				CALLMONITOR 
2266			endif 
2266 7e			.cptoken2:    ld a,(hl) 
2267 23				inc hl 
2268 fe 7f			cp FORTH_END_BUFFER 
226a 28 29			jr z, .cptokendone2 
226c fe 00			cp 0 
226e 28 25			jr z, .cptokendone2 
2270 fe 22			cp '"' 
2272 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2274 fe 20			cp ' ' 
2276 20 ee			jr nz,  .cptoken2 
2278			 
2278			; TODO consume comments held between ( and ) 
2278			 
2278				; we have a space so change to zero term for dict match later 
2278 2b				dec hl 
2279 3e 00			ld a,0 
227b 77				ld (hl), a 
227c 23				inc hl 
227d 18 e7			jr .cptoken2 
227f				 
227f			 
227f			.cptokenstr2: 
227f				; skip all white space until either eol (because forgot to term) or end double quote 
227f			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
227f				;inc hl ; skip current double quote 
227f 7e				ld a,(hl) 
2280 23				inc hl 
2281 fe 22			cp '"' 
2283 28 e1			jr z, .cptoken2 
2285 fe 7f			cp FORTH_END_BUFFER 
2287 28 0c			jr z, .cptokendone2 
2289 fe 00			cp 0 
228b 28 08			jr z, .cptokendone2 
228d fe 20			cp ' ' 
228f 28 02			jr z, .cptmp2 
2291 18 ec			jr .cptokenstr2 
2293			 
2293			.cptmp2:	; we have a space so change to zero term for dict match later 
2293				;dec hl 
2293				;ld a,"-"	; TODO remove this when working 
2293				;ld (hl), a 
2293				;inc hl 
2293 18 ea			jr .cptokenstr2 
2295			 
2295			.cptokendone2: 
2295				;inc hl 
2295 3e 7f			ld a, FORTH_END_BUFFER 
2297 77				ld (hl),a 
2298 23				inc hl 
2299 3e 21			ld a, '!' 
229b 77				ld (hl),a 
229c			 
229c 2a 00 f5			ld hl,(os_tok_ptr) 
229f			         
229f			if DEBUG_FORTH_TOK 
229f						DMARK "Tc1" 
229f				CALLMONITOR 
229f			endif 
229f			 
229f				; push exec string to top of return stack 
229f				FORTH_RSP_NEXT 
229f cd 8e 1e			call macro_forth_rsp_next 
22a2				endm 
# End of macro FORTH_RSP_NEXT
22a2 c9				ret 
22a3			 
22a3			; Another go at the parser need to simplify the process 
22a3			 
22a3			forthparse: 
22a3			 
22a3			; 
22a3			; line parse: 
22a3			;       parse raw input buffer 
22a3			;       tokenise the words 
22a3			;       malloc new copy (for looping etc) 
22a3			;       copy to malloc + current pc in line to start of string and add line term 
22a3			;       save on new rsp 
22a3			; 
22a3			 
22a3			; hl to point to the line to tokenise 
22a3			 
22a3			;	push hl 
22a3 22 00 f5			ld (os_tok_ptr), hl  ; save ptr to string 
22a6			 
22a6			;	ld a,0		; string term on input 
22a6			;	call strlent 
22a6			 
22a6			;	ld (os_tok_len), hl	 ; save string length 
22a6			 
22a6			;if DEBUG_FORTH_TOK 
22a6			;	ex de,hl		 
22a6			;endif 
22a6			 
22a6			;	pop hl 		; get back string pointer 
22a6			 
22a6			if DEBUG_FORTH_TOK 
22a6						DMARK "TOK" 
22a6				CALLMONITOR 
22a6			endif 
22a6 7e			.ptoken2:    ld a,(hl) 
22a7 23				inc hl 
22a8 fe 7f			cp FORTH_END_BUFFER 
22aa 28 29			jr z, .ptokendone2 
22ac fe 00			cp 0 
22ae 28 25			jr z, .ptokendone2 
22b0 fe 22			cp '"' 
22b2 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
22b4 fe 20			cp ' ' 
22b6 20 ee			jr nz,  .ptoken2 
22b8			 
22b8			; TODO consume comments held between ( and ) 
22b8			 
22b8				; we have a space so change to zero term for dict match later 
22b8 2b				dec hl 
22b9 3e 00			ld a,0 
22bb 77				ld (hl), a 
22bc 23				inc hl 
22bd 18 e7			jr .ptoken2 
22bf				 
22bf			 
22bf			.ptokenstr2: 
22bf				; skip all white space until either eol (because forgot to term) or end double quote 
22bf			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
22bf				;inc hl ; skip current double quote 
22bf 7e				ld a,(hl) 
22c0 23				inc hl 
22c1 fe 22			cp '"' 
22c3 28 e1			jr z, .ptoken2 
22c5 fe 7f			cp FORTH_END_BUFFER 
22c7 28 0c			jr z, .ptokendone2 
22c9 fe 00			cp 0 
22cb 28 08			jr z, .ptokendone2 
22cd fe 20			cp ' ' 
22cf 28 02			jr z, .ptmp2 
22d1 18 ec			jr .ptokenstr2 
22d3			 
22d3			.ptmp2:	; we have a space so change to zero term for dict match later 
22d3				;dec hl 
22d3				;ld a,"-"	; TODO remove this when working 
22d3				;ld (hl), a 
22d3				;inc hl 
22d3 18 ea			jr .ptokenstr2 
22d5			 
22d5			.ptokendone2: 
22d5				;inc hl 
22d5 3e 7f			ld a, FORTH_END_BUFFER 
22d7 77				ld (hl),a 
22d8 23				inc hl 
22d9 3e 21			ld a, '!' 
22db 77				ld (hl),a 
22dc			 
22dc 2a 00 f5			ld hl,(os_tok_ptr) 
22df			         
22df			if DEBUG_FORTH_TOK 
22df						DMARK "TK1" 
22df				CALLMONITOR 
22df			endif 
22df			 
22df				; push exec string to top of return stack 
22df				FORTH_RSP_NEXT 
22df cd 8e 1e			call macro_forth_rsp_next 
22e2				endm 
# End of macro FORTH_RSP_NEXT
22e2 c9				ret 
22e3			 
22e3			; 
22e3			;	; malloc size + buffer pointer + if is loop flag 
22e3			;	ld hl,(os_tok_len) 		 ; get string length 
22e3			; 
22e3			;	ld a,l 
22e3			; 
22e3			;	cp 0			; we dont want to use a null string 
22e3			;	ret z 
22e3			; 
22e3			;;	add 3    ; prefix malloc with buffer for current word ptr 
22e3			; 
22e3			;	add 5     ; TODO when certain not over writing memory remove 
22e3			; 
22e3			;		 
22e3			; 
22e3			;if DEBUG_FORTH_TOK 
22e3			;			DMARK "TKE" 
22e3			;	CALLMONITOR 
22e3			;endif 
22e3			; 
22e3			;	ld l,a 
22e3			;	ld h,0 
22e3			;;	push hl   ; save required space for the copy later 
22e3			;	call malloc 
22e3			;if DEBUG_FORTH_TOK 
22e3			;			DMARK "TKM" 
22e3			;	CALLMONITOR 
22e3			;endif 
22e3			;	if DEBUG_FORTH_MALLOC_GUARD 
22e3			;		push af 
22e3			;		call ishlzero 
22e3			;;		ld a, l 
22e3			;;		add h 
22e3			;;		cp 0 
22e3			;		pop af 
22e3			;		 
22e3			;		call z,malloc_error 
22e3			;	endif 
22e3			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
22e3			; 
22e3			; 
22e3			;if DEBUG_FORTH_TOK 
22e3			;			DMARK "TKR" 
22e3			;	CALLMONITOR 
22e3			;endif 
22e3			; 
22e3			;	FORTH_RSP_NEXT 
22e3			; 
22e3			;	;inc hl	 ; go past current buffer pointer 
22e3			;	;inc hl 
22e3			;	;inc hl   ; and past if loop flag 
22e3			;		; TODO Need to set flag  
22e3			; 
22e3			;	 
22e3			;	 
22e3			;	ex de,hl	; malloc is dest 
22e3			;	ld hl, (os_tok_len) 
22e3			;;	pop bc 
22e3			;	ld c, l                
22e3			;	ld b,0 
22e3			;	ld hl, (os_tok_ptr) 
22e3			; 
22e3			;if DEBUG_FORTH_TOK 
22e3			;			DMARK "TKT" 
22e3			;	CALLMONITOR 
22e3			;endif 
22e3			; 
22e3			;	; do str cpy 
22e3			; 
22e3			;	ldir      ; copy byte in hl to de 
22e3			; 
22e3			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
22e3			; 
22e3			;if DEBUG_FORTH_TOK 
22e3			; 
22e3			;			DMARK "TKY" 
22e3			;	CALLMONITOR 
22e3			;endif 
22e3			;	;ld a,0 
22e3			;	;ld a,FORTH_END_BUFFER 
22e3			;	ex de, hl 
22e3			;	;dec hl			 ; go back over the space delim at the end of word 
22e3			;	;ld (hl),a 
22e3			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
22e3			;	ld a,FORTH_END_BUFFER 
22e3			;	ld (hl),a 
22e3			;	inc hl 
22e3			;	ld a,FORTH_END_BUFFER 
22e3			;	ld (hl),a 
22e3			; 
22e3			;	; init the malloc area data 
22e3			;	; set pc for in current area 
22e3			;	;ld hl, (os_tok_malloc) 
22e3			;	;inc hl 
22e3			;	;inc hl 
22e3			;	;inc hl 
22e3			;	;ex de,hl 
22e3			;	;ld hl, (os_tok_malloc) 
22e3			;	;ld (hl),e 
22e3			;	;inc hl 
22e3			;	;ld (hl),d 
22e3			; 
22e3			; 
22e3			;	ld hl,(os_tok_malloc) 
22e3			;if DEBUG_FORTH_PARSE_KEY 
22e3			;			DMARK "TKU" 
22e3			;	CALLMONITOR 
22e3			;endif 
22e3			; 
22e3			;	ret 
22e3			 
22e3			forthexec: 
22e3			 
22e3			; line exec: 
22e3			; forth parser 
22e3			 
22e3			; 
22e3			;       get current exec line on rsp 
22e3			 
22e3				FORTH_RSP_TOS 
22e3 cd a5 1e			call macro_forth_rsp_tos 
22e6				endm 
# End of macro FORTH_RSP_TOS
22e6			 
22e6			;       restore current pc - hl points to malloc of data 
22e6			 
22e6				;ld e, (hl) 
22e6				;inc hl 
22e6				;ld d, (hl) 
22e6				;ex de,hl 
22e6			 
22e6			 
22e6			exec1: 
22e6 22 00 f5			ld (os_tok_ptr), hl 
22e9			 
22e9				; copy our PC to working vars  
22e9 22 4a fa			ld (cli_ptr), hl 
22ec 22 48 fa			ld (cli_origptr), hl 
22ef			 
22ef 7e				ld a,(hl) 
22f0 fe 7f			cp FORTH_END_BUFFER 
22f2 c8				ret z 
22f3			 
22f3				; skip any nulls 
22f3			 
22f3 fe 00			cp 0 
22f5 20 03			jr nz, .execword 
22f7 23				inc hl 
22f8 18 ec			jr exec1 
22fa			 
22fa			 
22fa			.execword: 
22fa			 
22fa			 
22fa			 
22fa			if DEBUG_FORTH_PARSE_KEY 
22fa						DMARK "KYQ" 
22fa				CALLMONITOR 
22fa			endif 
22fa			;       while at start of word: 
22fa			; get start of dict (in user area first) 
22fa			 
22fa 21 00 80		ld hl, baseram 
22fd			;ld hl, sysdict 
22fd 22 4c fa		ld (cli_nextword),hl 
2300			;           match word at pc 
2300			;           exec word 
2300			;           or push to dsp 
2300			;           forward to next token 
2300			;           if line term pop rsp and exit 
2300			;        
2300			 
2300			if DEBUG_FORTH_PARSE_KEY 
2300						DMARK "KYq" 
2300				CALLMONITOR 
2300			endif 
2300			 
2300			; 
2300			; word comp 
2300			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2300			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2300			;    move to start of word  
2300			;    compare word to cli_token 
2300			 
2300			.execpnword:	; HL at start of a word in the dictionary to check 
2300			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2300			;	ld (cli_ptr), hl 
2300			 
2300 2a 4c fa			ld hl,(cli_nextword) 
2303			 
2303 cd a6 23			call forth_tok_next 
2306			; tok next start here 
2306			;	; TODO skip compiled symbol for now 
2306			;	inc hl 
2306			; 
2306			;	; save pointer to next word 
2306			; 
2306			;	; hl now points to the address of the next word pointer  
2306			;	ld e, (hl) 
2306			;	inc hl 
2306			;	ld d, (hl) 
2306			;	inc l 
2306			; 
2306			;	ex de,hl 
2306			;if DEBUG_FORTH_PARSE_NEXTWORD 
2306			;	push bc 
2306			;	ld bc, (cli_nextword) 
2306			;			DMARK "NXW" 
2306			;	CALLMONITOR 
2306			;	pop bc 
2306			;endif 
2306			; tok next end here 
2306 22 4c fa			ld (cli_nextword), hl     ; save for next check if no match on this word 
2309 eb				ex de, hl 
230a			 
230a			 
230a				; save the pointer of the current token - 1 to check against 
230a				 
230a 22 50 fa			ld (cli_token), hl   
230d				; TODO maybe remove below save if no debug 
230d				; save token string ptr for any debug later 
230d 23				inc hl  
230e 22 52 fa			ld (cli_origtoken), hl 
2311 2b				dec hl 
2312				; save pointer to the start of the next dictionay word 
2312 7e				ld a,(hl)   ; get string length 
2313 47				ld b,a 
2314			.execpnwordinc:  
2314 23				inc hl 
2315 10 fd			djnz .execpnwordinc 
2317 22 4e fa			ld (cli_execword), hl      ; save start of this words code 
231a			 
231a				; now check the word token against the string being parsed 
231a			 
231a 2a 50 fa			ld hl,(cli_token) 
231d 23				inc hl     ; skip string length (use zero term instead to end) 
231e 22 50 fa			ld (cli_token), hl 
2321			 
2321			if DEBUG_FORTH_PARSE_KEY 
2321						DMARK "KY2" 
2321			endif 
2321			if DEBUG_FORTH_PARSE_EXEC 
2321				; see if disabled 
2321			 
2321				ld a, (os_view_disable) 
2321				cp '*' 
2321				jr z, .skip 
2321			 
2321				push hl 
2321				push hl 
2321				call clear_display 
2321				ld de, .compword 
2321				ld a, display_row_1 
2321				call str_at_display 
2321				pop de 
2321				ld a, display_row_2 
2321				call str_at_display 
2321				ld hl,(cli_ptr) 
2321				ld a,(hl) 
2321			        ld hl, os_word_scratch 
2321				ld (hl),a 
2321				ld a,0 
2321				inc hl 
2321				ld (hl),a 	 
2321				ld de, os_word_scratch 
2321				ld a, display_row_2+10 
2321				call str_at_display 
2321				call update_display 
2321				ld a, 100 
2321				call aDelayInMS 
2321				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2321				call delay250ms 
2321				endif 
2321				pop hl 
2321			.skip:  
2321			endif	 
2321			.execpnchar:    ; compare char between token and string to parse 
2321			 
2321			if DEBUG_FORTH_PARSE_KEY 
2321						DMARK "Ky3" 
2321			endif 
2321			if DEBUG_FORTH_PARSE_EXEC 
2321				; see if disabled 
2321			 
2321				ld a, (os_view_disable) 
2321				cp '*' 
2321				jr z, .skip2 
2321			 
2321			;	call clear_display 
2321			ld hl,(cli_token) 
2321			ld a,(hl) 
2321			ld (os_word_scratch),a 
2321				ld hl,(cli_ptr) 
2321			ld a,(hl) 
2321				ld (os_word_scratch+1),a 
2321				ld a,0 
2321				ld (os_word_scratch+2),a 
2321				ld de,os_word_scratch 
2321				ld a,display_row_4 
2321				call str_at_display 
2321				call update_display 
2321			.skip2:  
2321			endif 
2321 2a 50 fa			ld hl,(cli_token) 
2324 7e				ld a, (hl)	 ; char in word token 
2325 23				inc hl 		; move to next char 
2326 22 50 fa			ld (cli_token), hl ; and save it 
2329 47				ld b,a 
232a			 
232a 2a 4a fa			ld hl,(cli_ptr) ;	get the char from the string to parse 
232d 7e				ld a,(hl) 
232e 23				inc hl 
232f 22 4a fa			ld (cli_ptr), hl		; move to next char 
2332 cd 21 13			call toUpper 		; make sure the input string matches case 
2335			 
2335			if DEBUG_FORTH_PARSE 
2335			endif 
2335			 
2335				; input stream end of token is a space so get rid of it 
2335			 
2335			;	cp ' ' 
2335			;	jr nz, .pnskipspace 
2335			; 
2335			;	ld a, 0		; make same term as word token term 
2335			; 
2335			;.pnskipspace: 
2335			 
2335			if DEBUG_FORTH_PARSE_KEY 
2335						DMARK "KY7" 
2335			endif 
2335 b8				cp b 
2336 c2 4c 23			jp nz, .execpnskipword	 ; no match so move to next word 
2339				 
2339			;    if same 
2339			;       scan for string terms 0 for token and 32 for input 
2339			 
2339				 
2339			if DEBUG_FORTH_PARSE_KEY 
2339						DMARK "KY8" 
2339			endif 
2339			 
2339 80				add b			 
233a fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
233c							; TODO need to make sure last word in zero term string is accounted for 
233c 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
233e			 
233e			 
233e				; at end of both strings so both are exact match 
233e			 
233e			;       skip ptr for next word 
233e			 
233e 2a 4a fa			ld hl,(cli_ptr) 	; at input string term 
2341 23				inc hl			 ; at next char 
2342 22 4a fa			ld (cli_ptr), hl     ; save for next round of the parser 
2345 22 48 fa			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2348				 
2348				 
2348			if DEBUG_FORTH_PARSE_KEY 
2348						DMARK "KY3" 
2348			endif 
2348			 
2348			 
2348			 
2348			;       exec code block 
2348			if DEBUG_FORTH_JP 
2348				call clear_display 
2348				call update_display 
2348				call delay1s 
2348				ld hl, (cli_execword)     ; save for next check if no match on this word 
2348				ld a,h 
2348				ld hl, os_word_scratch 
2348				call hexout 
2348				ld hl, (cli_execword)     ; save for next check if no match on this word 
2348				ld a,l 
2348				ld hl, os_word_scratch+2 
2348				call hexout 
2348				ld hl, os_word_scratch+4 
2348				ld a,0 
2348				ld (hl),a 
2348				ld de,os_word_scratch 
2348				call str_at_display 
2348					ld a, display_row_2 
2348					call str_at_display 
2348				ld de, (cli_origtoken) 
2348				ld a, display_row_1+10 
2348					call str_at_display 
2348			 
2348				ld a,display_row_1 
2348				ld de, .foundword 
2348				ld a, display_row_3 
2348				call str_at_display 
2348				call update_display 
2348				call delay1s 
2348				call delay1s 
2348				call delay1s 
2348			endif 
2348			 
2348			if DEBUG_FORTH_PARSE_KEY 
2348						DMARK "KYj" 
2348			endif 
2348				; TODO save the word pointer in this exec 
2348			 
2348 2a 4e fa			ld hl,(cli_execword) 
234b e9				jp (hl) 
234c			 
234c			 
234c			;    if not same 
234c			;	scan for zero term 
234c			;	get ptr for next word 
234c			;	goto word comp 
234c			 
234c			.execpnskipword:	; get pointer to next word 
234c 2a 4c fa			ld hl,(cli_nextword) 
234f			 
234f 7e				ld a,(hl) 
2350 fe 00			cp WORD_SYS_END 
2352			;	cp 0 
2352 28 09			jr z, .execendofdict			 ; at end of words 
2354			 
2354			if DEBUG_FORTH_PARSE_KEY 
2354						DMARK "KY4" 
2354			endif 
2354			if DEBUG_FORTH_PARSE_EXEC 
2354			 
2354				; see if disabled 
2354			 
2354				ld a, (os_view_disable) 
2354				cp '*' 
2354				jr z, .noskip 
2354			 
2354			 
2354				ld de, .nowordfound 
2354				ld a, display_row_3 
2354				call str_at_display 
2354				call update_display 
2354				ld a, 100 
2354				call aDelayInMS 
2354				 
2354				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2354					call delay250ms 
2354				endif 
2354			.noskip:  
2354			 
2354			endif	 
2354			 
2354 2a 48 fa			ld hl,(cli_origptr) 
2357 22 4a fa			ld (cli_ptr),hl 
235a			 
235a			if DEBUG_FORTH_PARSE_KEY 
235a						DMARK "KY5" 
235a			endif 
235a c3 00 23			jp .execpnword			; else go to next word 
235d			 
235d			.execendofdict:  
235d			 
235d			if DEBUG_FORTH_PARSE_KEY 
235d						DMARK "KYe" 
235d			endif 
235d			if DEBUG_FORTH_PARSE_EXEC 
235d				; see if disabled 
235d			 
235d				ld a, (os_view_disable) 
235d				cp '*' 
235d				jr z, .ispskip 
235d			 
235d				call clear_display 
235d				call update_display 
235d				call delay1s 
235d				ld de, (cli_origptr) 
235d				ld a, display_row_1 
235d				call str_at_display 
235d				 
235d				ld de, .enddict 
235d				ld a, display_row_3 
235d				call str_at_display 
235d				call update_display 
235d				ld a, 100 
235d				call aDelayInMS 
235d				if DEBUG_FORTH_PARSE_EXEC_SLOW 
235d				call delay1s 
235d				call delay1s 
235d				call delay1s 
235d				endif 
235d			.ispskip:  
235d				 
235d			endif	 
235d			 
235d			 
235d			 
235d				; if the word is not a keyword then must be a literal so push it to stack 
235d			 
235d			; push token to stack to end of word 
235d			 
235d				STACKFRAME ON $1efe $2f9f 
235d				if DEBUG_STACK_IMB 
235d					if ON 
235d						exx 
235d						ld de, $1efe 
235d						ld a, d 
235d						ld hl, curframe 
235d						call hexout 
235d						ld a, e 
235d						ld hl, curframe+2 
235d						call hexout 
235d						ld hl, $1efe 
235d						push hl 
235d						ld hl, $2f9f 
235d						push hl 
235d						exx 
235d					endif 
235d				endif 
235d			endm 
# End of macro STACKFRAME
235d			 
235d 2a 00 f5		ld hl,(os_tok_ptr) 
2360 cd 50 20		call forth_apush 
2363			 
2363				STACKFRAMECHK ON $1efe $2f9f 
2363				if DEBUG_STACK_IMB 
2363					if ON 
2363						exx 
2363						ld hl, $2f9f 
2363						pop de   ; $2f9f 
2363						call cmp16 
2363						jr nz, .spnosame 
2363						ld hl, $1efe 
2363						pop de   ; $1efe 
2363						call cmp16 
2363						jr z, .spfrsame 
2363						.spnosame: call showsperror 
2363						.spfrsame: nop 
2363						exx 
2363					endif 
2363				endif 
2363			endm 
# End of macro STACKFRAMECHK
2363			 
2363			execnext: 
2363			 
2363			if DEBUG_FORTH_PARSE_KEY 
2363						DMARK "KY>" 
2363			endif 
2363			; move past token to next word 
2363			 
2363 2a 00 f5		ld hl, (os_tok_ptr) 
2366 3e 00		ld a, 0 
2368 01 ff 00		ld bc, 255     ; input buffer size 
236b ed b1		cpir 
236d			 
236d			if DEBUG_FORTH_PARSE_KEY 
236d						DMARK "KY!" 
236d				CALLMONITOR 
236d			endif	 
236d			; TODO this might place hl on the null, so will need to forward on??? 
236d			;inc hl   ; see if this gets onto the next item 
236d			 
236d			 
236d			; TODO pass a pointer to the buffer to push 
236d			; TODO call function to push 
236d			 
236d			; look for end of input 
236d			 
236d			;inc hl 
236d			;ld a,(hl) 
236d			;cp FORTH_END_BUFFER 
236d			;ret z 
236d			 
236d			 
236d c3 e6 22		jp exec1 
2370			 
2370			 
2370			 
2370			 
2370			 
2370			 
2370			 
2370			 
2370			 
2370			findnexttok: 
2370			 
2370				; hl is pointer to move 
2370				; de is the token to locate 
2370			 
2370					if DEBUG_FORTH 
2370						DMARK "NTK" 
2370						CALLMONITOR 
2370					endif 
2370 d5				push de 
2371			 
2371			.fnt1:	 
2371				; find first char of token to locate 
2371			 
2371 1a				ld a, (de) 
2372 4f				ld c,a 
2373 7e				ld a,(hl) 
2374 cd 21 13			call toUpper 
2377					if DEBUG_FORTH 
2377						DMARK "NT1" 
2377						CALLMONITOR 
2377					endif 
2377 b9				cp c 
2378			 
2378 28 03			jr z, .fnt2cmpmorefirst	 
237a			 
237a				; first char not found move to next char 
237a			 
237a 23				inc hl 
237b 18 f4			jr .fnt1 
237d			 
237d			.fnt2cmpmorefirst:	 
237d				; first char of token found.  
237d			 
237d e5				push hl     ; save start of token just in case it is the right one 
237e d9				exx 
237f e1				pop hl        ; save it to hl' 
2380 d9				exx 
2381			 
2381			 
2381			.fnt2cmpmore:	 
2381				; compare the rest 
2381				 
2381 23				inc hl 
2382 13				inc de 
2383				 
2383 1a				ld a, (de) 
2384 4f				ld c,a 
2385 7e				ld a,(hl) 
2386 cd 21 13			call toUpper 
2389			 
2389					if DEBUG_FORTH 
2389						DMARK "NT2" 
2389						CALLMONITOR 
2389					endif 
2389				; c has the token to find char 
2389				; a has the mem to scan char 
2389			 
2389 b9				cp c 
238a 28 04			jr z,.fntmatch1 
238c			 
238c				; they are not the same 
238c			 
238c					if DEBUG_FORTH 
238c						DMARK "NT3" 
238c						CALLMONITOR 
238c					endif 
238c d1				pop de	; reset de token to look for 
238d d5				push de 
238e 18 e1			jr .fnt1 
2390				 
2390			.fntmatch1: 
2390			 
2390				; is the same char a null which means we might have a full hit? 
2390					if DEBUG_FORTH 
2390						DMARK "NT4" 
2390						CALLMONITOR 
2390					endif 
2390			 
2390 fe 00			cp 0 
2392 28 0b			jr z, .fntmatchyes 
2394			 
2394				; are we at the end of the token to find? 
2394			 
2394					if DEBUG_FORTH 
2394						DMARK "NT5" 
2394						CALLMONITOR 
2394					endif 
2394 3e 00			ld a, 0 
2396 b9				cp c 
2397			 
2397 c2 81 23			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
239a			 
239a					if DEBUG_FORTH 
239a						DMARK "NT6" 
239a						CALLMONITOR 
239a					endif 
239a				; token to find is exhusted but no match to stream 
239a			 
239a				; restore tok pointer and continue on 
239a d1				pop de 
239b d5				push de 
239c c3 71 23			jp .fnt1 
239f			 
239f			 
239f			.fntmatchyes: 
239f			 
239f				; hl now contains the end of the found token 
239f			 
239f				; get rid of saved token pointer to find 
239f			 
239f d1				pop de 
23a0			 
23a0					if DEBUG_FORTH 
23a0						DMARK "NT9" 
23a0						CALLMONITOR 
23a0					endif 
23a0			 
23a0				; hl will be on the null term so forward on 
23a0			 
23a0				; get back the saved start of the token 
23a0			 
23a0 d9				exx 
23a1 e5				push hl     ; save start of token just in case it is the right one 
23a2 d9				exx 
23a3 e1				pop hl        ; save it to hl 
23a4			 
23a4 c9				ret 
23a5			 
23a5			 
23a5			; LIST needs to find a specific token   
23a5			; FORGET needs to find a spefici token 
23a5			 
23a5			; SAVE needs to find all tokens by flag 
23a5			; WORDS just needs to scan through all  by flag 
23a5			; UWORDS needs to scan through all by flag 
23a5			 
23a5			 
23a5			; given hl as pointer to start of dict look up string 
23a5			; return hl as pointer to start of word block 
23a5			; or 0 if not found 
23a5			 
23a5			forth_find_tok: 
23a5 c9				ret 
23a6			 
23a6			; given hl as pointer to dict structure 
23a6			; move to the next dict block structure 
23a6			 
23a6			forth_tok_next: 
23a6				; hl now points to the address of the next word pointer  
23a6				; TODO skip compiled symbol for now 
23a6			;	push de 
23a6 23				inc hl 
23a7 5e				ld e, (hl) 
23a8 23				inc hl 
23a9 56				ld d, (hl) 
23aa 23				inc hl 
23ab			 
23ab eb				ex de,hl 
23ac			if DEBUG_FORTH_PARSE_NEXTWORD 
23ac				push bc 
23ac				ld bc, (cli_nextword) 
23ac						DMARK "NXW" 
23ac				CALLMONITOR 
23ac				pop bc 
23ac			endif 
23ac			;	pop de	 
23ac c9				ret 
23ad			 
23ad			 
23ad			 
23ad			; eof 
# End of file forth_parserv5.asm
23ad				include "forth_wordsv4.asm" 
23ad			 
23ad			; the core word dictionary v4 
23ad			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
23ad			 
23ad			; this is a linked list for each of the system words used 
23ad			; user defined words will follow the same format but will be in ram 
23ad			 
23ad			 
23ad			; 
23ad			; 
23ad			; define linked list: 
23ad			; 
23ad			; 1. compiled byte op code 
23ad			; 2. len of text word 
23ad			; 3. text word 
23ad			; 4. ptr to next dictionary word 
23ad			; 5. asm, calls etc for the word 
23ad			; 
23ad			;  if 1 == 0 then last word in dict  
23ad			;   
23ad			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
23ad			;  
23ad			;  
23ad			; create basic standard set of words 
23ad			; 
23ad			;  
23ad			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
23ad			; 2DUP 2DROP 2SWAP  
23ad			; @ C@ - get byte  
23ad			; ! C! - store byte 
23ad			; 0< true if less than zero 
23ad			; 0= true if zero 
23ad			; < >  
23ad			; = true if same 
23ad			; variables 
23ad			 
23ad			 
23ad			; Hardware specific words I may need 
23ad			; 
23ad			; IN OUT  
23ad			; calls to key util functions 
23ad			; calls to hardward abstraction stuff 
23ad			; easy control of frame buffers and lcd i/o 
23ad			; keyboard  
23ad			 
23ad			 
23ad			;DICT: macro 
23ad			; op_code, len, word, next 
23ad			;    word: 
23ad			;    db op_code 
23ad			;    ds word zero term 
23ad			;    dw next 
23ad			;    endm 
23ad			 
23ad			 
23ad			 
23ad			 
23ad			; op code 1 is a flag for user define words which are to be handled differently 
23ad			 
23ad			 
23ad			; 
23ad			; 
23ad			;    TODO on entry to a word this should be the expected environment 
23ad			;    hl - tos value if number then held, if string this is the ptr 
23ad			;    de -  
23ad			 
23ad			 
23ad			; opcode ranges 
23ad			; 0 - end of word dict 
23ad			; 255 - user define words 
23ad			 
23ad			sysdict: 
23ad			include "forth_opcodes.asm" 
23ad			; op codes for forth keywords 
23ad			; free to use code 0  
23ad				OPCODE_HEAP: equ  1 
23ad				OPCODE_EXEC: equ 2 
23ad				OPCODE_DUP: equ 3 
23ad				OPCODE_SWAP: equ 4 
23ad				OPCODE_COLN: equ 5 
23ad				OPCODE_SCOLN: equ 6 
23ad				OPCODE_DROP: equ 7 
23ad				OPCODE_DUP2: equ 8 
23ad				OPCODE_DROP2: equ 9 
23ad				OPCODE_SWAP2: equ 10 
23ad				OPCODE_AT: equ 11 
23ad				OPCODE_CAT: equ 12 
23ad				OPCODE_BANG: equ 13 
23ad				OPCODE_CBANG: equ 14 
23ad				OPCODE_SCALL: equ 15 
23ad				OPCODE_DEPTH: equ 16 
23ad				OPCODE_OVER: equ 17 
23ad				OPCODE_PAUSE: equ 18 
23ad				OPCODE_PAUSES: equ 19 
23ad				OPCODE_ROT: equ 20 
23ad			;free to reuse	OPCODE_WORDS: equ 21 
23ad			        OPCODE_NOT: equ 21 
23ad				OPCODE_UWORDS: equ 22 
23ad				OPCODE_BP: equ 23 
23ad				OPCODE_MONITOR: equ 24  
23ad				OPCODE_MALLOC: equ 25 
23ad				OPCODE_FREE: equ 26 
23ad				OPCODE_LIST: equ 27 
23ad				OPCODE_FORGET: equ 28 
23ad				OPCODE_NOP: equ 29 
23ad				OPCODE_COMO: equ 30 
23ad				OPCODE_COMC: equ 31 
23ad			;free to reuse	OPCODE_ENDCORE: equ 32 
23ad				OPCODE_AFTERSOUND: equ 33 
23ad				OPCODE_GP2: equ 34 
23ad				OPCODE_GP3: equ 35 
23ad				OPCODE_GP4: equ 36 
23ad				OPCODE_SIN: equ 37 
23ad				OPCODE_SOUT: equ 38 
23ad				OPCODE_SPIO: equ 39 
23ad				OPCODE_SPICEH: equ 40 
23ad				OPCODE_SPIOb: equ 41 
23ad				OPCODE_SPII: equ 42 
23ad				OPCODE_SESEL: equ 43 
23ad				OPCODE_CARTDEV: equ 44 
23ad			; free to reuse	OPCODE_ENDDEVICE: equ 45 
23ad				OPCODE_FB: equ 46 
23ad				OPCODE_EMIT: equ 47 
23ad				OPCODE_DOTH: equ 48 
23ad				OPCODE_DOTF: equ 49 
23ad				OPCODE_DOT: equ 50 
23ad				OPCODE_CLS: equ 51 
23ad				OPCODE_DRAW: equ 52 
23ad				OPCODE_DUMP: equ 53 
23ad				OPCODE_CDUMP: equ 54 
23ad				OPCODE_DAT: equ 55 
23ad				OPCODE_HOME: equ 56 
23ad				OPCODE_SPACE: equ 57 
23ad				OPCODE_SPACES: equ 58 
23ad				OPCODE_SCROLL: equ 59 
23ad				OPCODE_ATQ: equ 60 
23ad				OPCODE_AUTODSP: equ 61 
23ad				OPCODE_MENU: equ 62 
23ad			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
23ad				OPCODE_THEN: equ 64 
23ad				OPCODE_ELSE: equ 65 
23ad				OPCODE_DO: equ 66 
23ad				OPCODE_LOOP: equ 67 
23ad				OPCODE_I: equ 68 
23ad				OPCODE_DLOOP: equ 69  
23ad				OPCODE_REPEAT: equ 70  
23ad				OPCODE_UNTIL: equ 71 
23ad				OPCODE_ENDFLOW: equ 72 
23ad				OPCODE_WAITK: equ 73 
23ad				OPCODE_ACCEPT: equ 74 
23ad				OPCODE_EDIT: equ 75 
23ad			;free to reuse	OPCODE_ENDKEY: equ 76 
23ad				OPCODE_LZERO: equ 77 
23ad				OPCODE_TZERO: equ 78 
23ad				OPCODE_LESS: equ 79 
23ad				OPCODE_GT: equ 80 
23ad				OPCODE_EQUAL: equ 81  
23ad			;free to reuse	OPCODE_ENDLOGIC: equ 82 
23ad				OPCODE_NEG: equ 83 
23ad				OPCODE_DIV: equ 84 
23ad				OPCODE_MUL: equ 85 
23ad				OPCODE_MIN: equ 86 
23ad				OPCODE_MAX: equ 87 
23ad				OPCODE_RND16: equ 88 
23ad				OPCODE_RND8: equ 89 
23ad				OPCODE_RND: equ 90 
23ad			;free to reuse	OPCODE_ENDMATHS: equ 91  
23ad				OPCODE_BYNAME: equ 92 
23ad				OPCODE_DIR: equ 93 
23ad				OPCODE_SAVE: equ 94 
23ad				OPCODE_LOAD: equ 95 
23ad				OPCODE_BSAVE: equ 96 
23ad				OPCODE_BLOAD: equ 97 
23ad				OPCODE_SEO: equ 98  
23ad				OPCODE_SEI: equ 99 
23ad				OPCODE_SFREE: equ 100 
23ad				OPCODE_SIZE: equ 101 
23ad				OPCODE_CREATE: equ 102 
23ad				OPCODE_APPEND: equ 103 
23ad				OPCODE_SDEL: equ 104 
23ad				OPCODE_OPEN: equ 105 
23ad				OPCODE_READ: equ 106 
23ad				OPCODE_EOF: equ 106 
23ad				OPCODE_FORMAT: equ 107 
23ad				OPCODE_LABEL: equ 108 
23ad				OPCODE_LABELS: equ 109 
23ad			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
23ad				OPCODE_UPPER: equ 111 
23ad				OPCODE_LOWER: equ 112 
23ad				OPCODE_SUBSTR: equ 113 
23ad				OPCODE_LEFT: equ 114 
23ad				OPCODE_RIGHT: equ 115 
23ad				OPCODE_STR2NUM: equ 116 
23ad				OPCODE_NUM2STR: equ 117 
23ad				OPCODE_CONCAT: equ 118 
23ad				OPCODE_FIND: equ 119 
23ad				OPCODE_LEN: equ 120 
23ad				OPCODE_CHAR: equ 121 
23ad			; free to reuse	OPCODE_STRLEN: equ 122 
23ad			; free to reuse	OPCODE_ENDSTR: equ 123 
23ad				OPCODE_V0S: equ 124 
23ad				OPCODE_V0Q: equ 125 
23ad				OPCODE_V1S: equ 126 
23ad				OPCODE_V1Q: equ 127 
23ad				OPCODE_V2S: equ 128 
23ad				OPCODE_V2Q: equ 129 
23ad				OPCODE_V3S: equ 130 
23ad				OPCODE_V3Q: equ 131 
23ad			;free to reuse	OPCODE_END: equ 132 
23ad				OPCODE_ZDUP: equ 133 
23ad			 
23ad			; eof 
# End of file forth_opcodes.asm
23ad			 
23ad			include "forth_words_core.asm" 
23ad			 
23ad			; | ## Core Words 
23ad			 
23ad			;if MALLOC_4 
23ad			 
23ad			.HEAP: 
23ad				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
23ad 15				db WORD_SYS_CORE+OPCODE_HEAP             
23ae ec 23			dw .EXEC            
23b0 05				db 4 + 1 
23b1 .. 00			db "HEAP",0              
23b6				endm 
# End of macro CWHEAD
23b6			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
23b6			; | | u1 - Current number of bytes in the heap 
23b6			; | | u2 - Remaining bytes left on the heap 
23b6			; | |  
23b6			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
23b6			 
23b6			 
23b6					if DEBUG_FORTH_WORDS_KEY 
23b6						DMARK "HEP" 
23b6 f5				push af  
23b7 3a cb 23			ld a, (.dmark)  
23ba 32 6e fe			ld (debug_mark),a  
23bd 3a cc 23			ld a, (.dmark+1)  
23c0 32 6f fe			ld (debug_mark+1),a  
23c3 3a cd 23			ld a, (.dmark+2)  
23c6 32 70 fe			ld (debug_mark+2),a  
23c9 18 03			jr .pastdmark  
23cb ..			.dmark: db "HEP"  
23ce f1			.pastdmark: pop af  
23cf			endm  
# End of macro DMARK
23cf						CALLMONITOR 
23cf cd 73 18			call break_point_state  
23d2				endm  
# End of macro CALLMONITOR
23d2					endif 
23d2 2a 0a 80				ld hl, (free_list )      
23d5 11 0e 80				ld de, heap_start 
23d8			 
23d8 ed 52				sbc hl, de  
23da			 
23da cd e7 1e				call forth_push_numhl 
23dd			 
23dd			 
23dd ed 5b 0a 80			ld de, (free_list )      
23e1 21 e5 f1				ld hl, heap_end 
23e4			 
23e4 ed 52				sbc hl, de 
23e6			 
23e6 cd e7 1e				call forth_push_numhl 
23e9					 
23e9			 
23e9					 
23e9			 
23e9			 
23e9			 
23e9					NEXTW 
23e9 c3 55 22			jp macro_next 
23ec				endm 
# End of macro NEXTW
23ec			;endif 
23ec			 
23ec			.EXEC: 
23ec			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
23ec			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
23ec			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
23ec			;; > > 
23ec			;; > >   
23ec			;	STACKFRAME OFF $5efe $5f9f 
23ec			; 
23ec			;		if DEBUG_FORTH_WORDS_KEY 
23ec			;			DMARK "EXE" 
23ec			;			CALLMONITOR 
23ec			;		endif 
23ec			; 
23ec			;	FORTH_DSP_VALUEHL 
23ec			; 
23ec			;	FORTH_DSP_POP 
23ec			; 
23ec			;		if DEBUG_FORTH_WORDS 
23ec			;			DMARK "EX1" 
23ec			;			CALLMONITOR 
23ec			;		endif 
23ec			;;	ld e,(hl) 
23ec			;;	inc hl 
23ec			;;	ld d,(hl) 
23ec			;;	ex de,hl 
23ec			; 
23ec			;;		if DEBUG_FORTH_WORDS 
23ec			;;			DMARK "EX2" 
23ec			;;			CALLMONITOR 
23ec			;;		endif 
23ec			;	push hl 
23ec			; 
23ec			;	;ld a, 0 
23ec			;	;ld a, FORTH_END_BUFFER 
23ec			;	call strlenz 
23ec			;	inc hl   ; include zero term to copy 
23ec			;	inc hl   ; include term 
23ec			;	inc hl   ; include term 
23ec			;	ld b,0 
23ec			;	ld c,l 
23ec			;	pop hl 
23ec			;	ld de, execscratch 
23ec			;		if DEBUG_FORTH_WORDS 
23ec			;			DMARK "EX3" 
23ec			;			CALLMONITOR 
23ec			;		endif 
23ec			;	ldir 
23ec			; 
23ec			; 
23ec			;	ld hl, execscratch 
23ec			; 
23ec			;		if DEBUG_FORTH_WORDS 
23ec			;			DMARK "EXe" 
23ec			;			CALLMONITOR 
23ec			;		endif 
23ec			; 
23ec			;	call forthparse 
23ec			;	call forthexec 
23ec			;;	call forthexec_cleanup 
23ec			;;	call forthparse 
23ec			;;	call forthexec 
23ec			; 
23ec			;	STACKFRAMECHK OFF $5efe $5f9f 
23ec			; 
23ec			;	; an immediate word so no need to process any more words 
23ec			;	ret 
23ec			;	NEXTW 
23ec			 
23ec			; dead code - old version  
23ec			;	FORTH_RSP_NEXT 
23ec			 
23ec			;  
23ec			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
23ec			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
23ec			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
23ec			;	push hl 
23ec			;	push de 
23ec			;	push bc 
23ec			; 
23ec			; 
23ec			;		if DEBUG_FORTH_WORDS_KEY 
23ec			;			DMARK "EXR" 
23ec			;			CALLMONITOR 
23ec			;		endif 
23ec			; 
23ec			; 
23ec			; 
23ec			;	;v5 FORTH_DSP_VALUE 
23ec			;	FORTH_DSP_VALUEHL 
23ec			; 
23ec			;	; TODO do string type checks 
23ec			; 
23ec			;;v5	inc hl   ; skip type 
23ec			; 
23ec			;	push hl  ; source code  
23ec			;		if DEBUG_FORTH_WORDS 
23ec			;			DMARK "EX1" 
23ec			;			CALLMONITOR 
23ec			;		endif 
23ec			;	ld a, 0 
23ec			;	call strlent 
23ec			; 
23ec			;	inc hl 
23ec			;	inc hl 
23ec			;	inc hl 
23ec			;	inc hl 
23ec			; 
23ec			;	push hl    ; size 
23ec			; 
23ec			;		if DEBUG_FORTH_WORDS 
23ec			;			DMARK "EX2" 
23ec			;			CALLMONITOR 
23ec			;		endif 
23ec			;	call malloc 
23ec			; 
23ec			;	ex de, hl    ; de now contains malloc area 
23ec			;	pop bc   	; get byte count 
23ec			;	pop hl      ; get string to copy 
23ec			; 
23ec			;	push de     ; save malloc for free later 
23ec			; 
23ec			;		if DEBUG_FORTH_WORDS 
23ec			;			DMARK "EX3" 
23ec			;			CALLMONITOR 
23ec			;		endif 
23ec			;	ldir       ; duplicate string 
23ec			; 
23ec			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
23ec			;	 
23ec			;	; TODO fix the parse would be better than this...  
23ec			;	ex de, hl 
23ec			;	dec hl 
23ec			;	ld a, 0 
23ec			;	ld (hl), a 
23ec			;	dec hl 
23ec			;	ld a, ' ' 
23ec			;	ld (hl), a 
23ec			;	dec hl 
23ec			;	ld (hl), a 
23ec			; 
23ec			;	dec hl 
23ec			;	ld (hl), a 
23ec			; 
23ec			; 
23ec			;	FORTH_DSP_POP  
23ec			; 
23ec			;	pop hl     
23ec			;	push hl    ; save malloc area 
23ec			; 
23ec			;		if DEBUG_FORTH_WORDS 
23ec			;			DMARK "EX4" 
23ec			;			CALLMONITOR 
23ec			;		endif 
23ec			; 
23ec			;	call forthparse 
23ec			;	call forthexec 
23ec			;	 
23ec			;	pop hl 
23ec			;	if DEBUG_FORTH_WORDS 
23ec			;		DMARK "EX5" 
23ec			;		CALLMONITOR 
23ec			;	endif 
23ec			; 
23ec			;	if FORTH_ENABLE_FREE 
23ec			;	call free 
23ec			;	endif 
23ec			; 
23ec			;	if DEBUG_FORTH_WORDS 
23ec			;		DMARK "EX6" 
23ec			;		CALLMONITOR 
23ec			;	endif 
23ec			; 
23ec			;	pop bc 
23ec			;	pop de 
23ec			;	pop hl 
23ec			;;	FORTH_RSP_POP	  
23ec			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
23ec			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
23ec			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
23ec			; 
23ec			;	if DEBUG_FORTH_WORDS 
23ec			;		DMARK "EX7" 
23ec			;		CALLMONITOR 
23ec			;	endif 
23ec			;	NEXTW 
23ec			 
23ec			;.STKEXEC: 
23ec			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
23ec			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
23ec			; 
23ec			; 
23ec			;		if DEBUG_FORTH_WORDS_KEY 
23ec			;			DMARK "STX" 
23ec			;			CALLMONITOR 
23ec			;		endif 
23ec			; 
23ec			;	FORTH_DSP_VALUEHL 
23ec			; 
23ec			;	ld (store_tmp1), hl    ; count 
23ec			; 
23ec			;	FORTH_DSP_POP 
23ec			;.stkexec1: 
23ec			;	ld hl, (store_tmp1)   ; count 
23ec			;	ld a, 0 
23ec			;	cp l 
23ec			;	ret z 
23ec			; 
23ec			;	dec hl 
23ec			;	ld (store_tmp1), hl    ; count 
23ec			;	 
23ec			;	FORTH_DSP_VALUEHL 
23ec			;	push hl 
23ec			;	 
23ec			;		if DEBUG_FORTH_WORDS 
23ec			;			DMARK "EXp" 
23ec			;			CALLMONITOR 
23ec			;		endif 
23ec			;	FORTH_DSP_POP 
23ec			; 
23ec			;	call strlenz 
23ec			;	inc hl   ; include zero term to copy 
23ec			;	inc hl   ; include zero term to copy 
23ec			;	inc hl   ; include zero term to copy 
23ec			;	ld b,0 
23ec			;	ld c,l 
23ec			;	pop hl 
23ec			;	ld de, execscratch 
23ec			;		if DEBUG_FORTH_WORDS 
23ec			;			DMARK "EX3" 
23ec			;			CALLMONITOR 
23ec			;		endif 
23ec			;	ldir 
23ec			; 
23ec			; 
23ec			;	ld hl, execscratch 
23ec			; 
23ec			;		if DEBUG_FORTH_WORDS 
23ec			;			DMARK "EXP" 
23ec			;			CALLMONITOR 
23ec			;		endif 
23ec			; 
23ec			;	call forthparse 
23ec			;	ld hl, execscratch 
23ec			;		if DEBUG_FORTH_WORDS 
23ec			;			DMARK "EXx" 
23ec			;			CALLMONITOR 
23ec			;		endif 
23ec			;	call forthexec 
23ec			; 
23ec			;	jp .stkexec1 
23ec			; 
23ec			;	ret 
23ec			 
23ec			 
23ec			.DUP: 
23ec				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
23ec 17				db WORD_SYS_CORE+OPCODE_DUP             
23ed 62 24			dw .ZDUP            
23ef 04				db 3 + 1 
23f0 .. 00			db "DUP",0              
23f4				endm 
# End of macro CWHEAD
23f4			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
23f4			 
23f4					if DEBUG_FORTH_WORDS_KEY 
23f4						DMARK "DUP" 
23f4 f5				push af  
23f5 3a 09 24			ld a, (.dmark)  
23f8 32 6e fe			ld (debug_mark),a  
23fb 3a 0a 24			ld a, (.dmark+1)  
23fe 32 6f fe			ld (debug_mark+1),a  
2401 3a 0b 24			ld a, (.dmark+2)  
2404 32 70 fe			ld (debug_mark+2),a  
2407 18 03			jr .pastdmark  
2409 ..			.dmark: db "DUP"  
240c f1			.pastdmark: pop af  
240d			endm  
# End of macro DMARK
240d						CALLMONITOR 
240d cd 73 18			call break_point_state  
2410				endm  
# End of macro CALLMONITOR
2410					endif 
2410			 
2410					FORTH_DSP 
2410 cd a4 20			call macro_forth_dsp 
2413				endm 
# End of macro FORTH_DSP
2413			 
2413 7e					ld a, (HL) 
2414 fe 01				cp DS_TYPE_STR 
2416 20 25				jr nz, .dupinum 
2418			 
2418					; push another string 
2418			 
2418					FORTH_DSP_VALUEHL     		 
2418 cd de 20			call macro_dsp_valuehl 
241b				endm 
# End of macro FORTH_DSP_VALUEHL
241b			 
241b				if DEBUG_FORTH_WORDS 
241b					DMARK "DUs" 
241b f5				push af  
241c 3a 30 24			ld a, (.dmark)  
241f 32 6e fe			ld (debug_mark),a  
2422 3a 31 24			ld a, (.dmark+1)  
2425 32 6f fe			ld (debug_mark+1),a  
2428 3a 32 24			ld a, (.dmark+2)  
242b 32 70 fe			ld (debug_mark+2),a  
242e 18 03			jr .pastdmark  
2430 ..			.dmark: db "DUs"  
2433 f1			.pastdmark: pop af  
2434			endm  
# End of macro DMARK
2434					CALLMONITOR 
2434 cd 73 18			call break_point_state  
2437				endm  
# End of macro CALLMONITOR
2437				endif 
2437 cd 55 1f				call forth_push_str 
243a			 
243a					NEXTW 
243a c3 55 22			jp macro_next 
243d				endm 
# End of macro NEXTW
243d			 
243d			 
243d			.dupinum: 
243d					 
243d			 
243d			 
243d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
243d cd de 20			call macro_dsp_valuehl 
2440				endm 
# End of macro FORTH_DSP_VALUEHL
2440			 
2440				; TODO add floating point number detection 
2440			 
2440				if DEBUG_FORTH_WORDS 
2440					DMARK "DUi" 
2440 f5				push af  
2441 3a 55 24			ld a, (.dmark)  
2444 32 6e fe			ld (debug_mark),a  
2447 3a 56 24			ld a, (.dmark+1)  
244a 32 6f fe			ld (debug_mark+1),a  
244d 3a 57 24			ld a, (.dmark+2)  
2450 32 70 fe			ld (debug_mark+2),a  
2453 18 03			jr .pastdmark  
2455 ..			.dmark: db "DUi"  
2458 f1			.pastdmark: pop af  
2459			endm  
# End of macro DMARK
2459					CALLMONITOR 
2459 cd 73 18			call break_point_state  
245c				endm  
# End of macro CALLMONITOR
245c				endif 
245c			 
245c cd e7 1e				call forth_push_numhl 
245f					NEXTW 
245f c3 55 22			jp macro_next 
2462				endm 
# End of macro NEXTW
2462			.ZDUP: 
2462				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2462 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2463 9a 24			dw .SWAP            
2465 05				db 4 + 1 
2466 .. 00			db "?DUP",0              
246b				endm 
# End of macro CWHEAD
246b			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
246b			 
246b					if DEBUG_FORTH_WORDS_KEY 
246b						DMARK "qDU" 
246b f5				push af  
246c 3a 80 24			ld a, (.dmark)  
246f 32 6e fe			ld (debug_mark),a  
2472 3a 81 24			ld a, (.dmark+1)  
2475 32 6f fe			ld (debug_mark+1),a  
2478 3a 82 24			ld a, (.dmark+2)  
247b 32 70 fe			ld (debug_mark+2),a  
247e 18 03			jr .pastdmark  
2480 ..			.dmark: db "qDU"  
2483 f1			.pastdmark: pop af  
2484			endm  
# End of macro DMARK
2484						CALLMONITOR 
2484 cd 73 18			call break_point_state  
2487				endm  
# End of macro CALLMONITOR
2487					endif 
2487					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2487 cd de 20			call macro_dsp_valuehl 
248a				endm 
# End of macro FORTH_DSP_VALUEHL
248a			 
248a e5					push hl 
248b			 
248b					; is it a zero? 
248b			 
248b 3e 00				ld a, 0 
248d 84					add h 
248e 85					add l 
248f			 
248f e1					pop hl 
2490			 
2490 fe 00				cp 0 
2492 28 03				jr z, .dup2orig 
2494			 
2494			 
2494 cd e7 1e				call forth_push_numhl 
2497			 
2497			 
2497				; TODO add floating point number detection 
2497			 
2497			.dup2orig: 
2497			 
2497					NEXTW 
2497 c3 55 22			jp macro_next 
249a				endm 
# End of macro NEXTW
249a			.SWAP: 
249a				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
249a 18				db WORD_SYS_CORE+OPCODE_SWAP             
249b d9 24			dw .COLN            
249d 05				db 4 + 1 
249e .. 00			db "SWAP",0              
24a3				endm 
# End of macro CWHEAD
24a3			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
24a3					if DEBUG_FORTH_WORDS_KEY 
24a3						DMARK "SWP" 
24a3 f5				push af  
24a4 3a b8 24			ld a, (.dmark)  
24a7 32 6e fe			ld (debug_mark),a  
24aa 3a b9 24			ld a, (.dmark+1)  
24ad 32 6f fe			ld (debug_mark+1),a  
24b0 3a ba 24			ld a, (.dmark+2)  
24b3 32 70 fe			ld (debug_mark+2),a  
24b6 18 03			jr .pastdmark  
24b8 ..			.dmark: db "SWP"  
24bb f1			.pastdmark: pop af  
24bc			endm  
# End of macro DMARK
24bc						CALLMONITOR 
24bc cd 73 18			call break_point_state  
24bf				endm  
# End of macro CALLMONITOR
24bf					endif 
24bf			 
24bf					FORTH_DSP_VALUEHL 
24bf cd de 20			call macro_dsp_valuehl 
24c2				endm 
# End of macro FORTH_DSP_VALUEHL
24c2 e5					push hl     ; w2 
24c3			 
24c3					FORTH_DSP_POP 
24c3 cd 96 21			call macro_forth_dsp_pop 
24c6				endm 
# End of macro FORTH_DSP_POP
24c6			 
24c6					FORTH_DSP_VALUEHL 
24c6 cd de 20			call macro_dsp_valuehl 
24c9				endm 
# End of macro FORTH_DSP_VALUEHL
24c9			 
24c9					FORTH_DSP_POP 
24c9 cd 96 21			call macro_forth_dsp_pop 
24cc				endm 
# End of macro FORTH_DSP_POP
24cc			 
24cc d1					pop de     ; w2	, hl = w1 
24cd			 
24cd eb					ex de, hl 
24ce d5					push de 
24cf			 
24cf cd e7 1e				call forth_push_numhl 
24d2			 
24d2 e1					pop hl 
24d3			 
24d3 cd e7 1e				call forth_push_numhl 
24d6					 
24d6			 
24d6					NEXTW 
24d6 c3 55 22			jp macro_next 
24d9				endm 
# End of macro NEXTW
24d9			.COLN: 
24d9				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
24d9 19				db WORD_SYS_CORE+OPCODE_COLN             
24da 65 26			dw .SCOLN            
24dc 02				db 1 + 1 
24dd .. 00			db ":",0              
24df				endm 
# End of macro CWHEAD
24df			; | : ( -- )         Create new word | DONE 
24df			 
24df					if DEBUG_FORTH_WORDS_KEY 
24df						DMARK "CLN" 
24df f5				push af  
24e0 3a f4 24			ld a, (.dmark)  
24e3 32 6e fe			ld (debug_mark),a  
24e6 3a f5 24			ld a, (.dmark+1)  
24e9 32 6f fe			ld (debug_mark+1),a  
24ec 3a f6 24			ld a, (.dmark+2)  
24ef 32 70 fe			ld (debug_mark+2),a  
24f2 18 03			jr .pastdmark  
24f4 ..			.dmark: db "CLN"  
24f7 f1			.pastdmark: pop af  
24f8			endm  
# End of macro DMARK
24f8						CALLMONITOR 
24f8 cd 73 18			call break_point_state  
24fb				endm  
# End of macro CALLMONITOR
24fb					endif 
24fb				STACKFRAME OFF $8efe $989f 
24fb				if DEBUG_STACK_IMB 
24fb					if OFF 
24fb						exx 
24fb						ld de, $8efe 
24fb						ld a, d 
24fb						ld hl, curframe 
24fb						call hexout 
24fb						ld a, e 
24fb						ld hl, curframe+2 
24fb						call hexout 
24fb						ld hl, $8efe 
24fb						push hl 
24fb						ld hl, $989f 
24fb						push hl 
24fb						exx 
24fb					endif 
24fb				endif 
24fb			endm 
# End of macro STACKFRAME
24fb				; get parser buffer length  of new word 
24fb			 
24fb				 
24fb			 
24fb					; move tok past this to start of name defintition 
24fb					; TODO get word to define 
24fb					; TODO Move past word token 
24fb					; TODO get length of string up to the ';' 
24fb			 
24fb 2a 00 f5			ld hl, (os_tok_ptr) 
24fe 23				inc hl 
24ff 23				inc hl 
2500			 
2500 3e 3b			ld a, ';' 
2502 cd 35 13			call strlent 
2505			 
2505 7d				ld a,l 
2506 32 fb f1			ld (os_new_parse_len), a 
2509			 
2509			 
2509			if DEBUG_FORTH_UWORD 
2509 ed 5b 00 f5		ld de, (os_tok_ptr) 
250d						DMARK ":01" 
250d f5				push af  
250e 3a 22 25			ld a, (.dmark)  
2511 32 6e fe			ld (debug_mark),a  
2514 3a 23 25			ld a, (.dmark+1)  
2517 32 6f fe			ld (debug_mark+1),a  
251a 3a 24 25			ld a, (.dmark+2)  
251d 32 70 fe			ld (debug_mark+2),a  
2520 18 03			jr .pastdmark  
2522 ..			.dmark: db ":01"  
2525 f1			.pastdmark: pop af  
2526			endm  
# End of macro DMARK
2526				CALLMONITOR 
2526 cd 73 18			call break_point_state  
2529				endm  
# End of macro CALLMONITOR
2529			endif 
2529			 
2529			; 
2529			;  new word memory layout: 
2529			;  
2529			;    : adg 6666 ;  
2529			; 
2529			;    db   1     ; user defined word  
2529 23				inc hl    
252a			;    dw   sysdict 
252a 23				inc hl 
252b 23				inc hl 
252c			;    db <word len>+1 (for null) 
252c 23				inc hl 
252d			;    db .... <word> 
252d			; 
252d			 
252d 23				inc hl    ; some extras for the word preamble before the above 
252e 23				inc hl 
252f 23				inc hl 
2530 23				inc hl 
2531 23				inc hl 
2532 23				inc hl 
2533 23				inc hl  
2534 23				inc hl 
2535 23				inc hl 
2536 23				inc hl 
2537 23				inc hl 
2538 23				inc hl 
2539 23				inc hl 
253a 23				inc hl     ; TODO how many do we really need?     maybe only 6 
253b			;       exec word buffer 
253b			;	<ptr word>   
253b 23				inc hl 
253c 23				inc hl 
253d			;       <word list><null term> 7F final term 
253d			 
253d			 
253d			if DEBUG_FORTH_UWORD 
253d						DMARK ":02" 
253d f5				push af  
253e 3a 52 25			ld a, (.dmark)  
2541 32 6e fe			ld (debug_mark),a  
2544 3a 53 25			ld a, (.dmark+1)  
2547 32 6f fe			ld (debug_mark+1),a  
254a 3a 54 25			ld a, (.dmark+2)  
254d 32 70 fe			ld (debug_mark+2),a  
2550 18 03			jr .pastdmark  
2552 ..			.dmark: db ":02"  
2555 f1			.pastdmark: pop af  
2556			endm  
# End of macro DMARK
2556				CALLMONITOR 
2556 cd 73 18			call break_point_state  
2559				endm  
# End of macro CALLMONITOR
2559			endif 
2559			 
2559				 
2559					; malloc the size 
2559			 
2559 cd 93 13				call malloc 
255c 22 fd f1				ld (os_new_malloc), hl     ; save malloc start 
255f			 
255f			;    db   1     ; user defined word  
255f 3e 01				ld a, WORD_SYS_UWORD  
2561 77					ld (hl), a 
2562				 
2562 23				inc hl    
2563			;    dw   sysdict 
2563 11 ad 23			ld de, sysdict       ; continue on with the scan to the system dict 
2566 73				ld (hl), e 
2567 23				inc hl 
2568 72				ld (hl), d 
2569 23				inc hl 
256a			 
256a			 
256a			;    Setup dict word 
256a			 
256a 23				inc hl 
256b 22 f7 f1			ld (os_new_work_ptr), hl     ; save start of dict word  
256e			 
256e				; 1. get length of dict word 
256e			 
256e			 
256e 2a 00 f5			ld hl, (os_tok_ptr) 
2571 23				inc hl 
2572 23				inc hl    ; position to start of dict word 
2573 3e 00			ld a, 0 
2575 cd 35 13			call strlent 
2578			 
2578			 
2578 23				inc hl    ; to include null??? 
2579			 
2579				; write length of dict word 
2579			 
2579 ed 5b f7 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
257d 1b				dec de 
257e eb				ex de, hl 
257f 73				ld (hl), e 
2580 eb				ex de, hl 
2581			 
2581				 
2581			 
2581				; copy  
2581 4d				ld c, l 
2582 06 00			ld b, 0 
2584 ed 5b f7 f1		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2588 2a 00 f5			ld hl, (os_tok_ptr) 
258b 23				inc hl 
258c 23				inc hl    ; position to start of dict word 
258d				 
258d			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
258d				 
258d				; TODO need to convert word to upper case 
258d			 
258d			ucasetok:	 
258d 7e				ld a,(hl) 
258e cd 21 13			call toUpper 
2591 77				ld (hl),a 
2592 ed a0			ldi 
2594 f2 8d 25		 	jp p, ucasetok 
2597			 
2597			 
2597			 
2597				; de now points to start of where the word body code should be placed 
2597 ed 53 f7 f1		ld (os_new_work_ptr), de 
259b				; hl now points to the words to throw at forthexec which needs to be copied 
259b 22 f5 f1			ld (os_new_src_ptr), hl 
259e			 
259e				; TODO add 'call to forthexec' 
259e			 
259e			if DEBUG_FORTH_UWORD 
259e c5				push bc 
259f ed 4b fd f1		ld bc, (os_new_malloc) 
25a3						DMARK ":0x" 
25a3 f5				push af  
25a4 3a b8 25			ld a, (.dmark)  
25a7 32 6e fe			ld (debug_mark),a  
25aa 3a b9 25			ld a, (.dmark+1)  
25ad 32 6f fe			ld (debug_mark+1),a  
25b0 3a ba 25			ld a, (.dmark+2)  
25b3 32 70 fe			ld (debug_mark+2),a  
25b6 18 03			jr .pastdmark  
25b8 ..			.dmark: db ":0x"  
25bb f1			.pastdmark: pop af  
25bc			endm  
# End of macro DMARK
25bc				CALLMONITOR 
25bc cd 73 18			call break_point_state  
25bf				endm  
# End of macro CALLMONITOR
25bf c1				pop bc 
25c0			endif 
25c0			 
25c0			 
25c0				; create word preamble which should be: 
25c0			 
25c0			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
25c0			 
25c0				;    ld hl, <word code> 
25c0				;    jp user_exec 
25c0			        ;    <word code bytes> 
25c0			 
25c0			 
25c0			;	inc de     ; TODO ??? or are we already past the word's null 
25c0 eb				ex de, hl 
25c1			 
25c1 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
25c3			 
25c3 23				inc hl 
25c4 22 f1 f1			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
25c7 23				inc hl 
25c8			 
25c8 23				inc hl 
25c9 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
25cb			 
25cb 01 7d 54			ld bc, user_exec 
25ce 23				inc hl 
25cf 71				ld (hl), c     ; poke address of user_exec 
25d0 23				inc hl 
25d1 70				ld (hl), b     
25d2			 ; 
25d2			;	inc hl 
25d2			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
25d2			; 
25d2			; 
25d2			;	ld bc, macro_forth_rsp_next 
25d2			;	inc hl 
25d2			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
25d2			;	inc hl 
25d2			;	ld (hl), b     
25d2			 ; 
25d2			;	inc hl 
25d2			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
25d2			; 
25d2			; 
25d2			;	inc hl 
25d2			;	ld bc, forthexec 
25d2			;	ld (hl), c     ; poke address of forthexec 
25d2			;	inc hl 
25d2			;	ld (hl), b      
25d2			; 
25d2			;	inc hl 
25d2			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
25d2			; 
25d2			;	ld bc, user_dict_next 
25d2			;	inc hl 
25d2			;	ld (hl), c     ; poke address of forthexec 
25d2			;	inc hl 
25d2			;	ld (hl), b      
25d2			 
25d2				; hl is now where we need to copy the word byte data to save this 
25d2			 
25d2 23				inc hl 
25d3 22 f3 f1			ld (os_new_exec), hl 
25d6				 
25d6				; copy definition 
25d6			 
25d6 eb				ex de, hl 
25d7			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
25d7			;	inc de    ; skip the PC for this parse 
25d7 3a fb f1			ld a, (os_new_parse_len) 
25da 4f				ld c, a 
25db 06 00			ld b, 0 
25dd ed b0			ldir		 ; copy defintion 
25df			 
25df			 
25df				; poke the address of where the new word bytes live for forthexec 
25df			 
25df 2a f1 f1			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
25e2			 
25e2 ed 5b f3 f1		ld de, (os_new_exec)      
25e6				 
25e6 73				ld (hl), e 
25e7 23				inc hl 
25e8 72				ld (hl), d 
25e9			 
25e9					; TODO copy last user dict word next link to this word 
25e9					; TODO update last user dict word to point to this word 
25e9			; 
25e9			; hl f923 de 812a ; bc 811a 
25e9			 
25e9			if DEBUG_FORTH_UWORD 
25e9 c5				push bc 
25ea ed 4b fd f1		ld bc, (os_new_malloc) 
25ee						DMARK ":0A" 
25ee f5				push af  
25ef 3a 03 26			ld a, (.dmark)  
25f2 32 6e fe			ld (debug_mark),a  
25f5 3a 04 26			ld a, (.dmark+1)  
25f8 32 6f fe			ld (debug_mark+1),a  
25fb 3a 05 26			ld a, (.dmark+2)  
25fe 32 70 fe			ld (debug_mark+2),a  
2601 18 03			jr .pastdmark  
2603 ..			.dmark: db ":0A"  
2606 f1			.pastdmark: pop af  
2607			endm  
# End of macro DMARK
2607				CALLMONITOR 
2607 cd 73 18			call break_point_state  
260a				endm  
# End of macro CALLMONITOR
260a c1				pop bc 
260b			endif 
260b			if DEBUG_FORTH_UWORD 
260b c5				push bc 
260c ed 4b fd f1		ld bc, (os_new_malloc) 
2610 03				inc bc 
2611 03				inc bc 
2612 03				inc bc 
2613 03				inc bc 
2614 03				inc bc 
2615 03				inc bc 
2616 03				inc bc 
2617 03				inc bc 
2618			 
2618						DMARK ":0B" 
2618 f5				push af  
2619 3a 2d 26			ld a, (.dmark)  
261c 32 6e fe			ld (debug_mark),a  
261f 3a 2e 26			ld a, (.dmark+1)  
2622 32 6f fe			ld (debug_mark+1),a  
2625 3a 2f 26			ld a, (.dmark+2)  
2628 32 70 fe			ld (debug_mark+2),a  
262b 18 03			jr .pastdmark  
262d ..			.dmark: db ":0B"  
2630 f1			.pastdmark: pop af  
2631			endm  
# End of macro DMARK
2631				CALLMONITOR 
2631 cd 73 18			call break_point_state  
2634				endm  
# End of macro CALLMONITOR
2634 c1				pop bc 
2635			endif 
2635			 
2635			; update word dict linked list for new word 
2635			 
2635			 
2635 2a fc f4		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2638 23			inc hl     ; move to next work linked list ptr 
2639			 
2639 ed 5b fd f1	ld de, (os_new_malloc)		 ; new next word 
263d 73			ld (hl), e 
263e 23			inc hl 
263f 72			ld (hl), d 
2640			 
2640			if DEBUG_FORTH_UWORD 
2640 ed 4b fc f4		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2644			endif 
2644			 
2644 ed 53 fc f4	ld (os_last_new_uword), de      ; update last new uword ptr 
2648			 
2648			 
2648			if DEBUG_FORTH_UWORD 
2648						DMARK ":0+" 
2648 f5				push af  
2649 3a 5d 26			ld a, (.dmark)  
264c 32 6e fe			ld (debug_mark),a  
264f 3a 5e 26			ld a, (.dmark+1)  
2652 32 6f fe			ld (debug_mark+1),a  
2655 3a 5f 26			ld a, (.dmark+2)  
2658 32 70 fe			ld (debug_mark+2),a  
265b 18 03			jr .pastdmark  
265d ..			.dmark: db ":0+"  
2660 f1			.pastdmark: pop af  
2661			endm  
# End of macro DMARK
2661				CALLMONITOR 
2661 cd 73 18			call break_point_state  
2664				endm  
# End of macro CALLMONITOR
2664			endif 
2664			 
2664				STACKFRAMECHK OFF $8efe $989f 
2664				if DEBUG_STACK_IMB 
2664					if OFF 
2664						exx 
2664						ld hl, $989f 
2664						pop de   ; $989f 
2664						call cmp16 
2664						jr nz, .spnosame 
2664						ld hl, $8efe 
2664						pop de   ; $8efe 
2664						call cmp16 
2664						jr z, .spfrsame 
2664						.spnosame: call showsperror 
2664						.spfrsame: nop 
2664						exx 
2664					endif 
2664				endif 
2664			endm 
# End of macro STACKFRAMECHK
2664			 
2664 c9			ret    ; dont process any remaining parser tokens as they form new word 
2665			 
2665			 
2665			 
2665			 
2665			;		NEXT 
2665			.SCOLN: 
2665			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2665 06				db OPCODE_SCOLN 
2666 b1 26			dw .DROP 
2668 02				db 2 
2669 .. 00			db ";",0           
266b			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
266b					if DEBUG_FORTH_WORDS_KEY 
266b						DMARK "SCN" 
266b f5				push af  
266c 3a 80 26			ld a, (.dmark)  
266f 32 6e fe			ld (debug_mark),a  
2672 3a 81 26			ld a, (.dmark+1)  
2675 32 6f fe			ld (debug_mark+1),a  
2678 3a 82 26			ld a, (.dmark+2)  
267b 32 70 fe			ld (debug_mark+2),a  
267e 18 03			jr .pastdmark  
2680 ..			.dmark: db "SCN"  
2683 f1			.pastdmark: pop af  
2684			endm  
# End of macro DMARK
2684						CALLMONITOR 
2684 cd 73 18			call break_point_state  
2687				endm  
# End of macro CALLMONITOR
2687					endif 
2687					FORTH_RSP_TOS 
2687 cd a5 1e			call macro_forth_rsp_tos 
268a				endm 
# End of macro FORTH_RSP_TOS
268a e5					push hl 
268b					FORTH_RSP_POP 
268b cd af 1e			call macro_forth_rsp_pop 
268e				endm 
# End of macro FORTH_RSP_POP
268e e1					pop hl 
268f			;		ex de,hl 
268f 22 00 f5				ld (os_tok_ptr),hl 
2692			 
2692			if DEBUG_FORTH_UWORD 
2692						DMARK "SCL" 
2692 f5				push af  
2693 3a a7 26			ld a, (.dmark)  
2696 32 6e fe			ld (debug_mark),a  
2699 3a a8 26			ld a, (.dmark+1)  
269c 32 6f fe			ld (debug_mark+1),a  
269f 3a a9 26			ld a, (.dmark+2)  
26a2 32 70 fe			ld (debug_mark+2),a  
26a5 18 03			jr .pastdmark  
26a7 ..			.dmark: db "SCL"  
26aa f1			.pastdmark: pop af  
26ab			endm  
# End of macro DMARK
26ab				CALLMONITOR 
26ab cd 73 18			call break_point_state  
26ae				endm  
# End of macro CALLMONITOR
26ae			endif 
26ae					NEXTW 
26ae c3 55 22			jp macro_next 
26b1				endm 
# End of macro NEXTW
26b1			 
26b1			.DROP: 
26b1				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
26b1 1b				db WORD_SYS_CORE+OPCODE_DROP             
26b2 dc 26			dw .DUP2            
26b4 05				db 4 + 1 
26b5 .. 00			db "DROP",0              
26ba				endm 
# End of macro CWHEAD
26ba			; | DROP ( w -- )   drop the TOS item   | DONE 
26ba					if DEBUG_FORTH_WORDS_KEY 
26ba						DMARK "DRP" 
26ba f5				push af  
26bb 3a cf 26			ld a, (.dmark)  
26be 32 6e fe			ld (debug_mark),a  
26c1 3a d0 26			ld a, (.dmark+1)  
26c4 32 6f fe			ld (debug_mark+1),a  
26c7 3a d1 26			ld a, (.dmark+2)  
26ca 32 70 fe			ld (debug_mark+2),a  
26cd 18 03			jr .pastdmark  
26cf ..			.dmark: db "DRP"  
26d2 f1			.pastdmark: pop af  
26d3			endm  
# End of macro DMARK
26d3						CALLMONITOR 
26d3 cd 73 18			call break_point_state  
26d6				endm  
# End of macro CALLMONITOR
26d6					endif 
26d6					FORTH_DSP_POP 
26d6 cd 96 21			call macro_forth_dsp_pop 
26d9				endm 
# End of macro FORTH_DSP_POP
26d9					NEXTW 
26d9 c3 55 22			jp macro_next 
26dc				endm 
# End of macro NEXTW
26dc			.DUP2: 
26dc				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
26dc 1c				db WORD_SYS_CORE+OPCODE_DUP2             
26dd 21 27			dw .DROP2            
26df 05				db 4 + 1 
26e0 .. 00			db "2DUP",0              
26e5				endm 
# End of macro CWHEAD
26e5			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
26e5					if DEBUG_FORTH_WORDS_KEY 
26e5						DMARK "2DU" 
26e5 f5				push af  
26e6 3a fa 26			ld a, (.dmark)  
26e9 32 6e fe			ld (debug_mark),a  
26ec 3a fb 26			ld a, (.dmark+1)  
26ef 32 6f fe			ld (debug_mark+1),a  
26f2 3a fc 26			ld a, (.dmark+2)  
26f5 32 70 fe			ld (debug_mark+2),a  
26f8 18 03			jr .pastdmark  
26fa ..			.dmark: db "2DU"  
26fd f1			.pastdmark: pop af  
26fe			endm  
# End of macro DMARK
26fe						CALLMONITOR 
26fe cd 73 18			call break_point_state  
2701				endm  
# End of macro CALLMONITOR
2701					endif 
2701					FORTH_DSP_VALUEHL 
2701 cd de 20			call macro_dsp_valuehl 
2704				endm 
# End of macro FORTH_DSP_VALUEHL
2704 e5					push hl      ; 2 
2705			 
2705					FORTH_DSP_POP 
2705 cd 96 21			call macro_forth_dsp_pop 
2708				endm 
# End of macro FORTH_DSP_POP
2708					 
2708					FORTH_DSP_VALUEHL 
2708 cd de 20			call macro_dsp_valuehl 
270b				endm 
# End of macro FORTH_DSP_VALUEHL
270b			;		push hl      ; 1 
270b			 
270b					FORTH_DSP_POP 
270b cd 96 21			call macro_forth_dsp_pop 
270e				endm 
# End of macro FORTH_DSP_POP
270e			 
270e			;		pop hl       ; 1 
270e d1					pop de       ; 2 
270f			 
270f cd e7 1e				call forth_push_numhl 
2712 eb					ex de, hl 
2713 cd e7 1e				call forth_push_numhl 
2716			 
2716					 
2716 eb					ex de, hl 
2717			 
2717 cd e7 1e				call forth_push_numhl 
271a eb					ex de, hl 
271b cd e7 1e				call forth_push_numhl 
271e			 
271e			 
271e					NEXTW 
271e c3 55 22			jp macro_next 
2721				endm 
# End of macro NEXTW
2721			.DROP2: 
2721				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2721 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2722 50 27			dw .SWAP2            
2724 06				db 5 + 1 
2725 .. 00			db "2DROP",0              
272b				endm 
# End of macro CWHEAD
272b			; | 2DROP ( w w -- )    Double drop | DONE 
272b					if DEBUG_FORTH_WORDS_KEY 
272b						DMARK "2DR" 
272b f5				push af  
272c 3a 40 27			ld a, (.dmark)  
272f 32 6e fe			ld (debug_mark),a  
2732 3a 41 27			ld a, (.dmark+1)  
2735 32 6f fe			ld (debug_mark+1),a  
2738 3a 42 27			ld a, (.dmark+2)  
273b 32 70 fe			ld (debug_mark+2),a  
273e 18 03			jr .pastdmark  
2740 ..			.dmark: db "2DR"  
2743 f1			.pastdmark: pop af  
2744			endm  
# End of macro DMARK
2744						CALLMONITOR 
2744 cd 73 18			call break_point_state  
2747				endm  
# End of macro CALLMONITOR
2747					endif 
2747					FORTH_DSP_POP 
2747 cd 96 21			call macro_forth_dsp_pop 
274a				endm 
# End of macro FORTH_DSP_POP
274a					FORTH_DSP_POP 
274a cd 96 21			call macro_forth_dsp_pop 
274d				endm 
# End of macro FORTH_DSP_POP
274d					NEXTW 
274d c3 55 22			jp macro_next 
2750				endm 
# End of macro NEXTW
2750			.SWAP2: 
2750				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2750 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2751 79 27			dw .AT            
2753 06				db 5 + 1 
2754 .. 00			db "2SWAP",0              
275a				endm 
# End of macro CWHEAD
275a			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
275a					if DEBUG_FORTH_WORDS_KEY 
275a						DMARK "2SW" 
275a f5				push af  
275b 3a 6f 27			ld a, (.dmark)  
275e 32 6e fe			ld (debug_mark),a  
2761 3a 70 27			ld a, (.dmark+1)  
2764 32 6f fe			ld (debug_mark+1),a  
2767 3a 71 27			ld a, (.dmark+2)  
276a 32 70 fe			ld (debug_mark+2),a  
276d 18 03			jr .pastdmark  
276f ..			.dmark: db "2SW"  
2772 f1			.pastdmark: pop af  
2773			endm  
# End of macro DMARK
2773						CALLMONITOR 
2773 cd 73 18			call break_point_state  
2776				endm  
# End of macro CALLMONITOR
2776					endif 
2776					NEXTW 
2776 c3 55 22			jp macro_next 
2779				endm 
# End of macro NEXTW
2779			.AT: 
2779				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2779 1f				db WORD_SYS_CORE+OPCODE_AT             
277a ab 27			dw .CAT            
277c 02				db 1 + 1 
277d .. 00			db "@",0              
277f				endm 
# End of macro CWHEAD
277f			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
277f			 
277f					if DEBUG_FORTH_WORDS_KEY 
277f						DMARK "AT." 
277f f5				push af  
2780 3a 94 27			ld a, (.dmark)  
2783 32 6e fe			ld (debug_mark),a  
2786 3a 95 27			ld a, (.dmark+1)  
2789 32 6f fe			ld (debug_mark+1),a  
278c 3a 96 27			ld a, (.dmark+2)  
278f 32 70 fe			ld (debug_mark+2),a  
2792 18 03			jr .pastdmark  
2794 ..			.dmark: db "AT."  
2797 f1			.pastdmark: pop af  
2798			endm  
# End of macro DMARK
2798						CALLMONITOR 
2798 cd 73 18			call break_point_state  
279b				endm  
# End of macro CALLMONITOR
279b					endif 
279b			.getbyteat:	 
279b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
279b cd de 20			call macro_dsp_valuehl 
279e				endm 
# End of macro FORTH_DSP_VALUEHL
279e					 
279e			;		push hl 
279e				 
279e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
279e cd 96 21			call macro_forth_dsp_pop 
27a1				endm 
# End of macro FORTH_DSP_POP
27a1			 
27a1			;		pop hl 
27a1			 
27a1 7e					ld a, (hl) 
27a2			 
27a2 6f					ld l, a 
27a3 26 00				ld h, 0 
27a5 cd e7 1e				call forth_push_numhl 
27a8			 
27a8					NEXTW 
27a8 c3 55 22			jp macro_next 
27ab				endm 
# End of macro NEXTW
27ab			.CAT: 
27ab				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
27ab 20				db WORD_SYS_CORE+OPCODE_CAT             
27ac d4 27			dw .BANG            
27ae 03				db 2 + 1 
27af .. 00			db "C@",0              
27b2				endm 
# End of macro CWHEAD
27b2			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
27b2					if DEBUG_FORTH_WORDS_KEY 
27b2						DMARK "CAA" 
27b2 f5				push af  
27b3 3a c7 27			ld a, (.dmark)  
27b6 32 6e fe			ld (debug_mark),a  
27b9 3a c8 27			ld a, (.dmark+1)  
27bc 32 6f fe			ld (debug_mark+1),a  
27bf 3a c9 27			ld a, (.dmark+2)  
27c2 32 70 fe			ld (debug_mark+2),a  
27c5 18 03			jr .pastdmark  
27c7 ..			.dmark: db "CAA"  
27ca f1			.pastdmark: pop af  
27cb			endm  
# End of macro DMARK
27cb						CALLMONITOR 
27cb cd 73 18			call break_point_state  
27ce				endm  
# End of macro CALLMONITOR
27ce					endif 
27ce c3 9b 27				jp .getbyteat 
27d1					NEXTW 
27d1 c3 55 22			jp macro_next 
27d4				endm 
# End of macro NEXTW
27d4			.BANG: 
27d4				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
27d4 21				db WORD_SYS_CORE+OPCODE_BANG             
27d5 0a 28			dw .CBANG            
27d7 02				db 1 + 1 
27d8 .. 00			db "!",0              
27da				endm 
# End of macro CWHEAD
27da			; | ! ( x w -- ) Store x at address w      | DONE 
27da					if DEBUG_FORTH_WORDS_KEY 
27da						DMARK "BNG" 
27da f5				push af  
27db 3a ef 27			ld a, (.dmark)  
27de 32 6e fe			ld (debug_mark),a  
27e1 3a f0 27			ld a, (.dmark+1)  
27e4 32 6f fe			ld (debug_mark+1),a  
27e7 3a f1 27			ld a, (.dmark+2)  
27ea 32 70 fe			ld (debug_mark+2),a  
27ed 18 03			jr .pastdmark  
27ef ..			.dmark: db "BNG"  
27f2 f1			.pastdmark: pop af  
27f3			endm  
# End of macro DMARK
27f3						CALLMONITOR 
27f3 cd 73 18			call break_point_state  
27f6				endm  
# End of macro CALLMONITOR
27f6					endif 
27f6			 
27f6			.storebyteat:		 
27f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27f6 cd de 20			call macro_dsp_valuehl 
27f9				endm 
# End of macro FORTH_DSP_VALUEHL
27f9					 
27f9 e5					push hl 
27fa				 
27fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
27fa cd 96 21			call macro_forth_dsp_pop 
27fd				endm 
# End of macro FORTH_DSP_POP
27fd			 
27fd					; get byte to poke 
27fd			 
27fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
27fd cd de 20			call macro_dsp_valuehl 
2800				endm 
# End of macro FORTH_DSP_VALUEHL
2800 e5					push hl 
2801			 
2801			 
2801					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2801 cd 96 21			call macro_forth_dsp_pop 
2804				endm 
# End of macro FORTH_DSP_POP
2804			 
2804			 
2804 d1					pop de 
2805 e1					pop hl 
2806			 
2806 73					ld (hl),e 
2807			 
2807			 
2807					NEXTW 
2807 c3 55 22			jp macro_next 
280a				endm 
# End of macro NEXTW
280a			.CBANG: 
280a				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
280a 22				db WORD_SYS_CORE+OPCODE_CBANG             
280b 33 28			dw .SCALL            
280d 03				db 2 + 1 
280e .. 00			db "C!",0              
2811				endm 
# End of macro CWHEAD
2811			; | C!  ( x w -- ) Store x at address w  | DONE 
2811					if DEBUG_FORTH_WORDS_KEY 
2811						DMARK "CBA" 
2811 f5				push af  
2812 3a 26 28			ld a, (.dmark)  
2815 32 6e fe			ld (debug_mark),a  
2818 3a 27 28			ld a, (.dmark+1)  
281b 32 6f fe			ld (debug_mark+1),a  
281e 3a 28 28			ld a, (.dmark+2)  
2821 32 70 fe			ld (debug_mark+2),a  
2824 18 03			jr .pastdmark  
2826 ..			.dmark: db "CBA"  
2829 f1			.pastdmark: pop af  
282a			endm  
# End of macro DMARK
282a						CALLMONITOR 
282a cd 73 18			call break_point_state  
282d				endm  
# End of macro CALLMONITOR
282d					endif 
282d c3 f6 27				jp .storebyteat 
2830					NEXTW 
2830 c3 55 22			jp macro_next 
2833				endm 
# End of macro NEXTW
2833			.SCALL: 
2833				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2833 23				db WORD_SYS_CORE+OPCODE_SCALL             
2834 67 28			dw .DEPTH            
2836 05				db 4 + 1 
2837 .. 00			db "CALL",0              
283c				endm 
# End of macro CWHEAD
283c			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
283c					if DEBUG_FORTH_WORDS_KEY 
283c						DMARK "CLL" 
283c f5				push af  
283d 3a 51 28			ld a, (.dmark)  
2840 32 6e fe			ld (debug_mark),a  
2843 3a 52 28			ld a, (.dmark+1)  
2846 32 6f fe			ld (debug_mark+1),a  
2849 3a 53 28			ld a, (.dmark+2)  
284c 32 70 fe			ld (debug_mark+2),a  
284f 18 03			jr .pastdmark  
2851 ..			.dmark: db "CLL"  
2854 f1			.pastdmark: pop af  
2855			endm  
# End of macro DMARK
2855						CALLMONITOR 
2855 cd 73 18			call break_point_state  
2858				endm  
# End of macro CALLMONITOR
2858					endif 
2858			 
2858					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2858 cd de 20			call macro_dsp_valuehl 
285b				endm 
# End of macro FORTH_DSP_VALUEHL
285b			 
285b			;		push hl 
285b			 
285b					; destroy value TOS 
285b			 
285b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
285b cd 96 21			call macro_forth_dsp_pop 
285e				endm 
# End of macro FORTH_DSP_POP
285e			 
285e						 
285e			;		pop hl 
285e			 
285e					; how to do a call with hl???? save SP? 
285e cd f9 21				call forth_call_hl 
2861			 
2861			 
2861					; TODO push value back onto stack for another op etc 
2861			 
2861 cd e7 1e				call forth_push_numhl 
2864					NEXTW 
2864 c3 55 22			jp macro_next 
2867				endm 
# End of macro NEXTW
2867			.DEPTH: 
2867				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2867 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2868 a4 28			dw .OVER            
286a 06				db 5 + 1 
286b .. 00			db "DEPTH",0              
2871				endm 
# End of macro CWHEAD
2871			; | DEPTH ( -- u ) Push count of stack | DONE 
2871					; take current TOS and remove from base value div by two to get count 
2871					if DEBUG_FORTH_WORDS_KEY 
2871						DMARK "DEP" 
2871 f5				push af  
2872 3a 86 28			ld a, (.dmark)  
2875 32 6e fe			ld (debug_mark),a  
2878 3a 87 28			ld a, (.dmark+1)  
287b 32 6f fe			ld (debug_mark+1),a  
287e 3a 88 28			ld a, (.dmark+2)  
2881 32 70 fe			ld (debug_mark+2),a  
2884 18 03			jr .pastdmark  
2886 ..			.dmark: db "DEP"  
2889 f1			.pastdmark: pop af  
288a			endm  
# End of macro DMARK
288a						CALLMONITOR 
288a cd 73 18			call break_point_state  
288d				endm  
# End of macro CALLMONITOR
288d					endif 
288d			 
288d			 
288d 2a 2c fa			ld hl, (cli_data_sp) 
2890 11 66 f7			ld de, cli_data_stack 
2893 ed 52			sbc hl,de 
2895				 
2895				; div by size of stack item 
2895			 
2895 5d				ld e,l 
2896 0e 03			ld c, 3 
2898 cd 5c 0e			call Div8 
289b			 
289b 6f				ld l,a 
289c 26 00			ld h,0 
289e			 
289e				;srl h 
289e				;rr l 
289e			 
289e cd e7 1e				call forth_push_numhl 
28a1					NEXTW 
28a1 c3 55 22			jp macro_next 
28a4				endm 
# End of macro NEXTW
28a4			.OVER: 
28a4				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
28a4 42				db WORD_SYS_CORE+46             
28a5 eb 28			dw .PAUSE            
28a7 05				db 4 + 1 
28a8 .. 00			db "OVER",0              
28ad				endm 
# End of macro CWHEAD
28ad			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
28ad					if DEBUG_FORTH_WORDS_KEY 
28ad						DMARK "OVR" 
28ad f5				push af  
28ae 3a c2 28			ld a, (.dmark)  
28b1 32 6e fe			ld (debug_mark),a  
28b4 3a c3 28			ld a, (.dmark+1)  
28b7 32 6f fe			ld (debug_mark+1),a  
28ba 3a c4 28			ld a, (.dmark+2)  
28bd 32 70 fe			ld (debug_mark+2),a  
28c0 18 03			jr .pastdmark  
28c2 ..			.dmark: db "OVR"  
28c5 f1			.pastdmark: pop af  
28c6			endm  
# End of macro DMARK
28c6						CALLMONITOR 
28c6 cd 73 18			call break_point_state  
28c9				endm  
# End of macro CALLMONITOR
28c9					endif 
28c9			 
28c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28c9 cd de 20			call macro_dsp_valuehl 
28cc				endm 
# End of macro FORTH_DSP_VALUEHL
28cc e5					push hl    ; n2 
28cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28cd cd 96 21			call macro_forth_dsp_pop 
28d0				endm 
# End of macro FORTH_DSP_POP
28d0			 
28d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28d0 cd de 20			call macro_dsp_valuehl 
28d3				endm 
# End of macro FORTH_DSP_VALUEHL
28d3 e5					push hl    ; n1 
28d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28d4 cd 96 21			call macro_forth_dsp_pop 
28d7				endm 
# End of macro FORTH_DSP_POP
28d7			 
28d7 d1					pop de     ; n1 
28d8 e1					pop hl     ; n2 
28d9			 
28d9 d5					push de 
28da e5					push hl 
28db d5					push de 
28dc			 
28dc					; push back  
28dc			 
28dc e1					pop hl 
28dd cd e7 1e				call forth_push_numhl 
28e0 e1					pop hl 
28e1 cd e7 1e				call forth_push_numhl 
28e4 e1					pop hl 
28e5 cd e7 1e				call forth_push_numhl 
28e8					NEXTW 
28e8 c3 55 22			jp macro_next 
28eb				endm 
# End of macro NEXTW
28eb			 
28eb			.PAUSE: 
28eb				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
28eb 43				db WORD_SYS_CORE+47             
28ec 20 29			dw .PAUSES            
28ee 08				db 7 + 1 
28ef .. 00			db "PAUSEMS",0              
28f7				endm 
# End of macro CWHEAD
28f7			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
28f7					if DEBUG_FORTH_WORDS_KEY 
28f7						DMARK "PMS" 
28f7 f5				push af  
28f8 3a 0c 29			ld a, (.dmark)  
28fb 32 6e fe			ld (debug_mark),a  
28fe 3a 0d 29			ld a, (.dmark+1)  
2901 32 6f fe			ld (debug_mark+1),a  
2904 3a 0e 29			ld a, (.dmark+2)  
2907 32 70 fe			ld (debug_mark+2),a  
290a 18 03			jr .pastdmark  
290c ..			.dmark: db "PMS"  
290f f1			.pastdmark: pop af  
2910			endm  
# End of macro DMARK
2910						CALLMONITOR 
2910 cd 73 18			call break_point_state  
2913				endm  
# End of macro CALLMONITOR
2913					endif 
2913					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2913 cd de 20			call macro_dsp_valuehl 
2916				endm 
# End of macro FORTH_DSP_VALUEHL
2916			;		push hl    ; n2 
2916					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2916 cd 96 21			call macro_forth_dsp_pop 
2919				endm 
# End of macro FORTH_DSP_POP
2919			;		pop hl 
2919			 
2919 7d					ld a, l 
291a cd fa 0b				call aDelayInMS 
291d				       NEXTW 
291d c3 55 22			jp macro_next 
2920				endm 
# End of macro NEXTW
2920			.PAUSES:  
2920				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2920 44				db WORD_SYS_CORE+48             
2921 8f 29			dw .ROT            
2923 06				db 5 + 1 
2924 .. 00			db "PAUSE",0              
292a				endm 
# End of macro CWHEAD
292a			; | PAUSE ( n -- )  Pause for n seconds | DONE 
292a					if DEBUG_FORTH_WORDS_KEY 
292a						DMARK "PAU" 
292a f5				push af  
292b 3a 3f 29			ld a, (.dmark)  
292e 32 6e fe			ld (debug_mark),a  
2931 3a 40 29			ld a, (.dmark+1)  
2934 32 6f fe			ld (debug_mark+1),a  
2937 3a 41 29			ld a, (.dmark+2)  
293a 32 70 fe			ld (debug_mark+2),a  
293d 18 03			jr .pastdmark  
293f ..			.dmark: db "PAU"  
2942 f1			.pastdmark: pop af  
2943			endm  
# End of macro DMARK
2943						CALLMONITOR 
2943 cd 73 18			call break_point_state  
2946				endm  
# End of macro CALLMONITOR
2946					endif 
2946					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2946 cd de 20			call macro_dsp_valuehl 
2949				endm 
# End of macro FORTH_DSP_VALUEHL
2949			;		push hl    ; n2 
2949					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2949 cd 96 21			call macro_forth_dsp_pop 
294c				endm 
# End of macro FORTH_DSP_POP
294c			;		pop hl 
294c 45					ld b, l 
294d					if DEBUG_FORTH_WORDS 
294d						DMARK "PAU" 
294d f5				push af  
294e 3a 62 29			ld a, (.dmark)  
2951 32 6e fe			ld (debug_mark),a  
2954 3a 63 29			ld a, (.dmark+1)  
2957 32 6f fe			ld (debug_mark+1),a  
295a 3a 64 29			ld a, (.dmark+2)  
295d 32 70 fe			ld (debug_mark+2),a  
2960 18 03			jr .pastdmark  
2962 ..			.dmark: db "PAU"  
2965 f1			.pastdmark: pop af  
2966			endm  
# End of macro DMARK
2966						CALLMONITOR 
2966 cd 73 18			call break_point_state  
2969				endm  
# End of macro CALLMONITOR
2969					endif 
2969 c5			.pauses1:	push bc 
296a cd 15 0c				call delay1s 
296d c1					pop bc 
296e					if DEBUG_FORTH_WORDS 
296e						DMARK "PA1" 
296e f5				push af  
296f 3a 83 29			ld a, (.dmark)  
2972 32 6e fe			ld (debug_mark),a  
2975 3a 84 29			ld a, (.dmark+1)  
2978 32 6f fe			ld (debug_mark+1),a  
297b 3a 85 29			ld a, (.dmark+2)  
297e 32 70 fe			ld (debug_mark+2),a  
2981 18 03			jr .pastdmark  
2983 ..			.dmark: db "PA1"  
2986 f1			.pastdmark: pop af  
2987			endm  
# End of macro DMARK
2987						CALLMONITOR 
2987 cd 73 18			call break_point_state  
298a				endm  
# End of macro CALLMONITOR
298a					endif 
298a 10 dd				djnz .pauses1 
298c			 
298c				       NEXTW 
298c c3 55 22			jp macro_next 
298f				endm 
# End of macro NEXTW
298f			.ROT: 
298f				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
298f 45				db WORD_SYS_CORE+49             
2990 dd 29			dw .UWORDS            
2992 04				db 3 + 1 
2993 .. 00			db "ROT",0              
2997				endm 
# End of macro CWHEAD
2997			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2997					if DEBUG_FORTH_WORDS_KEY 
2997						DMARK "ROT" 
2997 f5				push af  
2998 3a ac 29			ld a, (.dmark)  
299b 32 6e fe			ld (debug_mark),a  
299e 3a ad 29			ld a, (.dmark+1)  
29a1 32 6f fe			ld (debug_mark+1),a  
29a4 3a ae 29			ld a, (.dmark+2)  
29a7 32 70 fe			ld (debug_mark+2),a  
29aa 18 03			jr .pastdmark  
29ac ..			.dmark: db "ROT"  
29af f1			.pastdmark: pop af  
29b0			endm  
# End of macro DMARK
29b0						CALLMONITOR 
29b0 cd 73 18			call break_point_state  
29b3				endm  
# End of macro CALLMONITOR
29b3					endif 
29b3			 
29b3					FORTH_DSP_VALUEHL 
29b3 cd de 20			call macro_dsp_valuehl 
29b6				endm 
# End of macro FORTH_DSP_VALUEHL
29b6 e5					push hl    ; u3  
29b7			 
29b7					FORTH_DSP_POP 
29b7 cd 96 21			call macro_forth_dsp_pop 
29ba				endm 
# End of macro FORTH_DSP_POP
29ba			   
29ba					FORTH_DSP_VALUEHL 
29ba cd de 20			call macro_dsp_valuehl 
29bd				endm 
# End of macro FORTH_DSP_VALUEHL
29bd e5					push hl     ; u2 
29be			 
29be					FORTH_DSP_POP 
29be cd 96 21			call macro_forth_dsp_pop 
29c1				endm 
# End of macro FORTH_DSP_POP
29c1			 
29c1					FORTH_DSP_VALUEHL 
29c1 cd de 20			call macro_dsp_valuehl 
29c4				endm 
# End of macro FORTH_DSP_VALUEHL
29c4 e5					push hl     ; u1 
29c5			 
29c5					FORTH_DSP_POP 
29c5 cd 96 21			call macro_forth_dsp_pop 
29c8				endm 
# End of macro FORTH_DSP_POP
29c8			 
29c8 c1					pop bc      ; u1 
29c9 e1					pop hl      ; u2 
29ca d1					pop de      ; u3 
29cb			 
29cb			 
29cb c5					push bc 
29cc d5					push de 
29cd e5					push hl 
29ce			 
29ce			 
29ce e1					pop hl 
29cf cd e7 1e				call forth_push_numhl 
29d2			 
29d2 e1					pop hl 
29d3 cd e7 1e				call forth_push_numhl 
29d6			 
29d6 e1					pop hl 
29d7 cd e7 1e				call forth_push_numhl 
29da					 
29da			 
29da			 
29da			 
29da			 
29da			 
29da				       NEXTW 
29da c3 55 22			jp macro_next 
29dd				endm 
# End of macro NEXTW
29dd			 
29dd			.UWORDS: 
29dd				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
29dd 50				db WORD_SYS_CORE+60             
29de 9f 2a			dw .BP            
29e0 07				db 6 + 1 
29e1 .. 00			db "UWORDS",0              
29e8				endm 
# End of macro CWHEAD
29e8			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
29e8			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
29e8			; | | Following the count are the individual words. 
29e8			; | | 
29e8			; | | e.g. UWORDS 
29e8			; | | BOX DIRLIST 2 
29e8			; | |  
29e8			; | | Can be used to save the words to storage via: 
29e8			; | | UWORDS $01 DO $01 APPEND LOOP 
29e8				if DEBUG_FORTH_WORDS_KEY 
29e8					DMARK "UWR" 
29e8 f5				push af  
29e9 3a fd 29			ld a, (.dmark)  
29ec 32 6e fe			ld (debug_mark),a  
29ef 3a fe 29			ld a, (.dmark+1)  
29f2 32 6f fe			ld (debug_mark+1),a  
29f5 3a ff 29			ld a, (.dmark+2)  
29f8 32 70 fe			ld (debug_mark+2),a  
29fb 18 03			jr .pastdmark  
29fd ..			.dmark: db "UWR"  
2a00 f1			.pastdmark: pop af  
2a01			endm  
# End of macro DMARK
2a01					CALLMONITOR 
2a01 cd 73 18			call break_point_state  
2a04				endm  
# End of macro CALLMONITOR
2a04				endif 
2a04 21 00 80				ld hl, baseram 
2a07					;ld hl, baseusermem 
2a07 01 00 00				ld bc, 0    ; start a counter 
2a0a			 
2a0a				; skip dict stub 
2a0a			 
2a0a cd a6 23				call forth_tok_next 
2a0d			 
2a0d			 
2a0d			; while we have words to look for 
2a0d			 
2a0d 7e			.douscan:	ld a, (hl)      
2a0e				if DEBUG_FORTH_WORDS 
2a0e					DMARK "UWs" 
2a0e f5				push af  
2a0f 3a 23 2a			ld a, (.dmark)  
2a12 32 6e fe			ld (debug_mark),a  
2a15 3a 24 2a			ld a, (.dmark+1)  
2a18 32 6f fe			ld (debug_mark+1),a  
2a1b 3a 25 2a			ld a, (.dmark+2)  
2a1e 32 70 fe			ld (debug_mark+2),a  
2a21 18 03			jr .pastdmark  
2a23 ..			.dmark: db "UWs"  
2a26 f1			.pastdmark: pop af  
2a27			endm  
# End of macro DMARK
2a27					CALLMONITOR 
2a27 cd 73 18			call break_point_state  
2a2a				endm  
# End of macro CALLMONITOR
2a2a				endif 
2a2a fe 00				cp WORD_SYS_END 
2a2c 28 4d				jr z, .udone 
2a2e fe 01				cp WORD_SYS_UWORD 
2a30 20 44				jr nz, .nuword 
2a32			 
2a32				if DEBUG_FORTH_WORDS 
2a32					DMARK "UWu" 
2a32 f5				push af  
2a33 3a 47 2a			ld a, (.dmark)  
2a36 32 6e fe			ld (debug_mark),a  
2a39 3a 48 2a			ld a, (.dmark+1)  
2a3c 32 6f fe			ld (debug_mark+1),a  
2a3f 3a 49 2a			ld a, (.dmark+2)  
2a42 32 70 fe			ld (debug_mark+2),a  
2a45 18 03			jr .pastdmark  
2a47 ..			.dmark: db "UWu"  
2a4a f1			.pastdmark: pop af  
2a4b			endm  
# End of macro DMARK
2a4b					CALLMONITOR 
2a4b cd 73 18			call break_point_state  
2a4e				endm  
# End of macro CALLMONITOR
2a4e				endif 
2a4e					; we have a uword so push its name to the stack 
2a4e			 
2a4e e5				   	push hl  ; save so we can move to next dict block 
2a4f			 
2a4f					; skip opcode 
2a4f 23					inc hl  
2a50					; skip next ptr 
2a50 23					inc hl  
2a51 23					inc hl 
2a52					; skip len 
2a52 23					inc hl 
2a53				if DEBUG_FORTH_WORDS 
2a53					DMARK "UWt" 
2a53 f5				push af  
2a54 3a 68 2a			ld a, (.dmark)  
2a57 32 6e fe			ld (debug_mark),a  
2a5a 3a 69 2a			ld a, (.dmark+1)  
2a5d 32 6f fe			ld (debug_mark+1),a  
2a60 3a 6a 2a			ld a, (.dmark+2)  
2a63 32 70 fe			ld (debug_mark+2),a  
2a66 18 03			jr .pastdmark  
2a68 ..			.dmark: db "UWt"  
2a6b f1			.pastdmark: pop af  
2a6c			endm  
# End of macro DMARK
2a6c					CALLMONITOR 
2a6c cd 73 18			call break_point_state  
2a6f				endm  
# End of macro CALLMONITOR
2a6f				endif 
2a6f 03					inc bc 
2a70			 
2a70 c5					push bc 
2a71 cd 55 1f				call forth_push_str 
2a74 c1					pop bc 
2a75			 
2a75 e1					pop hl 	 
2a76			 
2a76 cd a6 23		.nuword:	call forth_tok_next 
2a79 18 92				jr .douscan  
2a7b			 
2a7b			.udone:		 ; push count of uwords found 
2a7b c5					push bc 
2a7c e1					pop hl 
2a7d			 
2a7d				if DEBUG_FORTH_WORDS 
2a7d					DMARK "UWc" 
2a7d f5				push af  
2a7e 3a 92 2a			ld a, (.dmark)  
2a81 32 6e fe			ld (debug_mark),a  
2a84 3a 93 2a			ld a, (.dmark+1)  
2a87 32 6f fe			ld (debug_mark+1),a  
2a8a 3a 94 2a			ld a, (.dmark+2)  
2a8d 32 70 fe			ld (debug_mark+2),a  
2a90 18 03			jr .pastdmark  
2a92 ..			.dmark: db "UWc"  
2a95 f1			.pastdmark: pop af  
2a96			endm  
# End of macro DMARK
2a96					CALLMONITOR 
2a96 cd 73 18			call break_point_state  
2a99				endm  
# End of macro CALLMONITOR
2a99				endif 
2a99 cd e7 1e				call forth_push_numhl 
2a9c			 
2a9c			 
2a9c				       NEXTW 
2a9c c3 55 22			jp macro_next 
2a9f				endm 
# End of macro NEXTW
2a9f			 
2a9f			.BP: 
2a9f				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2a9f 54				db WORD_SYS_CORE+64             
2aa0 d5 2a			dw .MONITOR            
2aa2 03				db 2 + 1 
2aa3 .. 00			db "BP",0              
2aa6				endm 
# End of macro CWHEAD
2aa6			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2aa6			; | | $00 Will enable the break points within specific code paths 
2aa6			; | | $01 Will disable break points 
2aa6			; | |  
2aa6			; | | By default break points are off. Either the above can be used to enable them 
2aa6			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2aa6			; | | and on release of the pressed key a message will be disaplayed to notify 
2aa6			; | | that break points are enabled. Pressing any key will then continue boot process. 
2aa6					; get byte count 
2aa6					if DEBUG_FORTH_WORDS_KEY 
2aa6						DMARK "BP." 
2aa6 f5				push af  
2aa7 3a bb 2a			ld a, (.dmark)  
2aaa 32 6e fe			ld (debug_mark),a  
2aad 3a bc 2a			ld a, (.dmark+1)  
2ab0 32 6f fe			ld (debug_mark+1),a  
2ab3 3a bd 2a			ld a, (.dmark+2)  
2ab6 32 70 fe			ld (debug_mark+2),a  
2ab9 18 03			jr .pastdmark  
2abb ..			.dmark: db "BP."  
2abe f1			.pastdmark: pop af  
2abf			endm  
# End of macro DMARK
2abf						CALLMONITOR 
2abf cd 73 18			call break_point_state  
2ac2				endm  
# End of macro CALLMONITOR
2ac2					endif 
2ac2			 
2ac2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ac2 cd de 20			call macro_dsp_valuehl 
2ac5				endm 
# End of macro FORTH_DSP_VALUEHL
2ac5			 
2ac5			;		push hl 
2ac5			 
2ac5					; destroy value TOS 
2ac5			 
2ac5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ac5 cd 96 21			call macro_forth_dsp_pop 
2ac8				endm 
# End of macro FORTH_DSP_POP
2ac8			 
2ac8			;		pop hl 
2ac8			 
2ac8 3e 00				ld a,0 
2aca bd					cp l 
2acb 28 02				jr z, .bpset 
2acd 3e 2a				ld a, '*' 
2acf			 
2acf 32 f0 f1		.bpset:		ld (os_view_disable), a 
2ad2			 
2ad2			 
2ad2					NEXTW 
2ad2 c3 55 22			jp macro_next 
2ad5				endm 
# End of macro NEXTW
2ad5			 
2ad5			 
2ad5			.MONITOR: 
2ad5				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2ad5 55				db WORD_SYS_CORE+65             
2ad6 08 2b			dw .MALLOC            
2ad8 08				db 7 + 1 
2ad9 .. 00			db "MONITOR",0              
2ae1				endm 
# End of macro CWHEAD
2ae1			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2ae1			; | | At start the current various registers will be displayed with contents. 
2ae1			; | | Top right corner will show the most recent debug marker seen. 
2ae1			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2ae1			; | | and the return stack pointer (RSP). 
2ae1			; | | Pressing: 
2ae1			; | |    1 - Initial screen 
2ae1			; | |    2 - Display a data dump of HL 
2ae1			; | |    3 - Display a data dump of DE 
2ae1			; | |    4 - Display a data dump of BC 
2ae1			; | |    5 - Display a data dump of HL 
2ae1			; | |    6 - Display a data dump of DSP 
2ae1			; | |    7 - Display a data dump of RSP 
2ae1			; | |    8 - Display a data dump of what is at DSP 
2ae1			; | |    9 - Display a data dump of what is at RSP 
2ae1			; | |    0 - Exit monitor and continue running. This will also enable break points 
2ae1			; | |    * - Disable break points 
2ae1			; | |    # - Enter traditional monitor mode 
2ae1			; | | 
2ae1			; | | Monitor Mode 
2ae1			; | | ------------ 
2ae1			; | | A prompt of '>' will be shown for various commands: 
2ae1			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2ae1			; | |    C - Continue display a data dump from the last set address 
2ae1			; | |    M xxxx - Set start of memory edit at address xx 
2ae1			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2ae1			; | |    Q - Return to previous 
2ae1					if DEBUG_FORTH_WORDS_KEY 
2ae1						DMARK "MON" 
2ae1 f5				push af  
2ae2 3a f6 2a			ld a, (.dmark)  
2ae5 32 6e fe			ld (debug_mark),a  
2ae8 3a f7 2a			ld a, (.dmark+1)  
2aeb 32 6f fe			ld (debug_mark+1),a  
2aee 3a f8 2a			ld a, (.dmark+2)  
2af1 32 70 fe			ld (debug_mark+2),a  
2af4 18 03			jr .pastdmark  
2af6 ..			.dmark: db "MON"  
2af9 f1			.pastdmark: pop af  
2afa			endm  
# End of macro DMARK
2afa						CALLMONITOR 
2afa cd 73 18			call break_point_state  
2afd				endm  
# End of macro CALLMONITOR
2afd					endif 
2afd 3e 00				ld a, 0 
2aff 32 f0 f1				ld (os_view_disable), a 
2b02			 
2b02					CALLMONITOR 
2b02 cd 73 18			call break_point_state  
2b05				endm  
# End of macro CALLMONITOR
2b05			 
2b05			;	call monitor 
2b05			 
2b05					NEXTW 
2b05 c3 55 22			jp macro_next 
2b08				endm 
# End of macro NEXTW
2b08			 
2b08			 
2b08			.MALLOC: 
2b08				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2b08 56				db WORD_SYS_CORE+66             
2b09 31 2b			dw .MALLOC2            
2b0b 06				db 5 + 1 
2b0c .. 00			db "ALLOT",0              
2b12				endm 
# End of macro CWHEAD
2b12			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2b12					if DEBUG_FORTH_WORDS_KEY 
2b12						DMARK "ALL" 
2b12 f5				push af  
2b13 3a 27 2b			ld a, (.dmark)  
2b16 32 6e fe			ld (debug_mark),a  
2b19 3a 28 2b			ld a, (.dmark+1)  
2b1c 32 6f fe			ld (debug_mark+1),a  
2b1f 3a 29 2b			ld a, (.dmark+2)  
2b22 32 70 fe			ld (debug_mark+2),a  
2b25 18 03			jr .pastdmark  
2b27 ..			.dmark: db "ALL"  
2b2a f1			.pastdmark: pop af  
2b2b			endm  
# End of macro DMARK
2b2b						CALLMONITOR 
2b2b cd 73 18			call break_point_state  
2b2e				endm  
# End of macro CALLMONITOR
2b2e					endif 
2b2e c3 58 2b				jp .mallocc 
2b31			.MALLOC2: 
2b31				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2b31 56				db WORD_SYS_CORE+66             
2b32 6f 2b			dw .FREE            
2b34 07				db 6 + 1 
2b35 .. 00			db "MALLOC",0              
2b3c				endm 
# End of macro CWHEAD
2b3c			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2b3c					; get byte count 
2b3c					if DEBUG_FORTH_WORDS_KEY 
2b3c						DMARK "MAL" 
2b3c f5				push af  
2b3d 3a 51 2b			ld a, (.dmark)  
2b40 32 6e fe			ld (debug_mark),a  
2b43 3a 52 2b			ld a, (.dmark+1)  
2b46 32 6f fe			ld (debug_mark+1),a  
2b49 3a 53 2b			ld a, (.dmark+2)  
2b4c 32 70 fe			ld (debug_mark+2),a  
2b4f 18 03			jr .pastdmark  
2b51 ..			.dmark: db "MAL"  
2b54 f1			.pastdmark: pop af  
2b55			endm  
# End of macro DMARK
2b55						CALLMONITOR 
2b55 cd 73 18			call break_point_state  
2b58				endm  
# End of macro CALLMONITOR
2b58					endif 
2b58			.mallocc: 
2b58					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b58 cd de 20			call macro_dsp_valuehl 
2b5b				endm 
# End of macro FORTH_DSP_VALUEHL
2b5b			 
2b5b			;		push hl 
2b5b			 
2b5b					; destroy value TOS 
2b5b			 
2b5b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b5b cd 96 21			call macro_forth_dsp_pop 
2b5e				endm 
# End of macro FORTH_DSP_POP
2b5e			 
2b5e			;		pop hl 
2b5e cd 93 13				call malloc 
2b61				if DEBUG_FORTH_MALLOC_GUARD 
2b61 f5					push af 
2b62 cd f5 0e				call ishlzero 
2b65			;		ld a, l 
2b65			;		add h 
2b65			;		cp 0 
2b65 f1					pop af 
2b66					 
2b66 cc 4f 55				call z,malloc_error 
2b69				endif 
2b69			 
2b69 cd e7 1e				call forth_push_numhl 
2b6c					NEXTW 
2b6c c3 55 22			jp macro_next 
2b6f				endm 
# End of macro NEXTW
2b6f			 
2b6f			.FREE: 
2b6f				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2b6f 57				db WORD_SYS_CORE+67             
2b70 a0 2b			dw .LIST            
2b72 05				db 4 + 1 
2b73 .. 00			db "FREE",0              
2b78				endm 
# End of macro CWHEAD
2b78			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2b78					if DEBUG_FORTH_WORDS_KEY 
2b78						DMARK "FRE" 
2b78 f5				push af  
2b79 3a 8d 2b			ld a, (.dmark)  
2b7c 32 6e fe			ld (debug_mark),a  
2b7f 3a 8e 2b			ld a, (.dmark+1)  
2b82 32 6f fe			ld (debug_mark+1),a  
2b85 3a 8f 2b			ld a, (.dmark+2)  
2b88 32 70 fe			ld (debug_mark+2),a  
2b8b 18 03			jr .pastdmark  
2b8d ..			.dmark: db "FRE"  
2b90 f1			.pastdmark: pop af  
2b91			endm  
# End of macro DMARK
2b91						CALLMONITOR 
2b91 cd 73 18			call break_point_state  
2b94				endm  
# End of macro CALLMONITOR
2b94					endif 
2b94					; get address 
2b94			 
2b94					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b94 cd de 20			call macro_dsp_valuehl 
2b97				endm 
# End of macro FORTH_DSP_VALUEHL
2b97			 
2b97			;		push hl 
2b97			 
2b97					; destroy value TOS 
2b97			 
2b97					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b97 cd 96 21			call macro_forth_dsp_pop 
2b9a				endm 
# End of macro FORTH_DSP_POP
2b9a			 
2b9a			;		pop hl 
2b9a			if FORTH_ENABLE_MALLOCFREE 
2b9a cd 5d 14				call free 
2b9d			endif 
2b9d					NEXTW 
2b9d c3 55 22			jp macro_next 
2ba0				endm 
# End of macro NEXTW
2ba0			.LIST: 
2ba0				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2ba0 5c				db WORD_SYS_CORE+72             
2ba1 8e 2d			dw .FORGET            
2ba3 05				db 4 + 1 
2ba4 .. 00			db "LIST",0              
2ba9				endm 
# End of macro CWHEAD
2ba9			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2ba9			; | | The quoted word must be in upper case. 
2ba9				if DEBUG_FORTH_WORDS_KEY 
2ba9					DMARK "LST" 
2ba9 f5				push af  
2baa 3a be 2b			ld a, (.dmark)  
2bad 32 6e fe			ld (debug_mark),a  
2bb0 3a bf 2b			ld a, (.dmark+1)  
2bb3 32 6f fe			ld (debug_mark+1),a  
2bb6 3a c0 2b			ld a, (.dmark+2)  
2bb9 32 70 fe			ld (debug_mark+2),a  
2bbc 18 03			jr .pastdmark  
2bbe ..			.dmark: db "LST"  
2bc1 f1			.pastdmark: pop af  
2bc2			endm  
# End of macro DMARK
2bc2					CALLMONITOR 
2bc2 cd 73 18			call break_point_state  
2bc5				endm  
# End of macro CALLMONITOR
2bc5				endif 
2bc5			 
2bc5					FORTH_DSP_VALUEHL 
2bc5 cd de 20			call macro_dsp_valuehl 
2bc8				endm 
# End of macro FORTH_DSP_VALUEHL
2bc8			 
2bc8 e5					push hl 
2bc9					FORTH_DSP_POP 
2bc9 cd 96 21			call macro_forth_dsp_pop 
2bcc				endm 
# End of macro FORTH_DSP_POP
2bcc c1					pop bc 
2bcd			 
2bcd			; Start format of scratch string 
2bcd			 
2bcd 21 ff f1				ld hl, scratch 
2bd0			 
2bd0 3e 3a				ld a, ':' 
2bd2 77					ld (hl),a 
2bd3 23					inc hl 
2bd4 3e 20				ld a, ' ' 
2bd6 77					ld (hl), a 
2bd7			 
2bd7					; Get ptr to the word we need to look up 
2bd7			 
2bd7			;		FORTH_DSP_VALUEHL 
2bd7					;v5 FORTH_DSP_VALUE 
2bd7				; TODO type check 
2bd7			;		inc hl    ; Skip type check  
2bd7			;		push hl 
2bd7			;		ex de, hl    ; put into DE 
2bd7			 
2bd7			 
2bd7 21 00 80				ld hl, baseram 
2bda					;ld hl, baseusermem 
2bda			 
2bda e5			push hl   ; sacreifical push 
2bdb			 
2bdb			.ldouscanm: 
2bdb e1				pop hl 
2bdc			.ldouscan: 
2bdc				if DEBUG_FORTH_WORDS 
2bdc					DMARK "LSs" 
2bdc f5				push af  
2bdd 3a f1 2b			ld a, (.dmark)  
2be0 32 6e fe			ld (debug_mark),a  
2be3 3a f2 2b			ld a, (.dmark+1)  
2be6 32 6f fe			ld (debug_mark+1),a  
2be9 3a f3 2b			ld a, (.dmark+2)  
2bec 32 70 fe			ld (debug_mark+2),a  
2bef 18 03			jr .pastdmark  
2bf1 ..			.dmark: db "LSs"  
2bf4 f1			.pastdmark: pop af  
2bf5			endm  
# End of macro DMARK
2bf5					CALLMONITOR 
2bf5 cd 73 18			call break_point_state  
2bf8				endm  
# End of macro CALLMONITOR
2bf8				endif 
2bf8				; skip dict stub 
2bf8 cd a6 23				call forth_tok_next 
2bfb			 
2bfb			 
2bfb			; while we have words to look for 
2bfb			 
2bfb 7e				ld a, (hl)      
2bfc				if DEBUG_FORTH_WORDS 
2bfc					DMARK "LSk" 
2bfc f5				push af  
2bfd 3a 11 2c			ld a, (.dmark)  
2c00 32 6e fe			ld (debug_mark),a  
2c03 3a 12 2c			ld a, (.dmark+1)  
2c06 32 6f fe			ld (debug_mark+1),a  
2c09 3a 13 2c			ld a, (.dmark+2)  
2c0c 32 70 fe			ld (debug_mark+2),a  
2c0f 18 03			jr .pastdmark  
2c11 ..			.dmark: db "LSk"  
2c14 f1			.pastdmark: pop af  
2c15			endm  
# End of macro DMARK
2c15					CALLMONITOR 
2c15 cd 73 18			call break_point_state  
2c18				endm  
# End of macro CALLMONITOR
2c18				endif 
2c18					;cp WORD_SYS_END 
2c18					;jp z, .lunotfound 
2c18			 
2c18					; if we hit non uwords then gone too far 
2c18 fe 01				cp WORD_SYS_UWORD 
2c1a c2 4a 2d				jp nz, .lunotfound 
2c1d			 
2c1d				if DEBUG_FORTH_WORDS 
2c1d					DMARK "LSu" 
2c1d f5				push af  
2c1e 3a 32 2c			ld a, (.dmark)  
2c21 32 6e fe			ld (debug_mark),a  
2c24 3a 33 2c			ld a, (.dmark+1)  
2c27 32 6f fe			ld (debug_mark+1),a  
2c2a 3a 34 2c			ld a, (.dmark+2)  
2c2d 32 70 fe			ld (debug_mark+2),a  
2c30 18 03			jr .pastdmark  
2c32 ..			.dmark: db "LSu"  
2c35 f1			.pastdmark: pop af  
2c36			endm  
# End of macro DMARK
2c36					CALLMONITOR 
2c36 cd 73 18			call break_point_state  
2c39				endm  
# End of macro CALLMONITOR
2c39				endif 
2c39			 
2c39					; found a uword but is it the one we want... 
2c39			 
2c39 c5					push bc     ; uword to find is on bc 
2c3a d1					pop de 
2c3b			 
2c3b e5					push hl  ; to save the ptr 
2c3c			 
2c3c					; skip opcode 
2c3c 23					inc hl  
2c3d					; skip next ptr 
2c3d 23					inc hl  
2c3e 23					inc hl 
2c3f					; skip len 
2c3f 23					inc hl 
2c40			 
2c40				if DEBUG_FORTH_WORDS 
2c40					DMARK "LSc" 
2c40 f5				push af  
2c41 3a 55 2c			ld a, (.dmark)  
2c44 32 6e fe			ld (debug_mark),a  
2c47 3a 56 2c			ld a, (.dmark+1)  
2c4a 32 6f fe			ld (debug_mark+1),a  
2c4d 3a 57 2c			ld a, (.dmark+2)  
2c50 32 70 fe			ld (debug_mark+2),a  
2c53 18 03			jr .pastdmark  
2c55 ..			.dmark: db "LSc"  
2c58 f1			.pastdmark: pop af  
2c59			endm  
# End of macro DMARK
2c59					CALLMONITOR 
2c59 cd 73 18			call break_point_state  
2c5c				endm  
# End of macro CALLMONITOR
2c5c				endif 
2c5c cd 62 13				call strcmp 
2c5f c2 db 2b				jp nz, .ldouscanm 
2c62				 
2c62			 
2c62			 
2c62					; we have a uword so push its name to the stack 
2c62			 
2c62			;	   	push hl  ; save so we can move to next dict block 
2c62 e1			pop hl 
2c63			 
2c63				if DEBUG_FORTH_WORDS 
2c63					DMARK "LSm" 
2c63 f5				push af  
2c64 3a 78 2c			ld a, (.dmark)  
2c67 32 6e fe			ld (debug_mark),a  
2c6a 3a 79 2c			ld a, (.dmark+1)  
2c6d 32 6f fe			ld (debug_mark+1),a  
2c70 3a 7a 2c			ld a, (.dmark+2)  
2c73 32 70 fe			ld (debug_mark+2),a  
2c76 18 03			jr .pastdmark  
2c78 ..			.dmark: db "LSm"  
2c7b f1			.pastdmark: pop af  
2c7c			endm  
# End of macro DMARK
2c7c					CALLMONITOR 
2c7c cd 73 18			call break_point_state  
2c7f				endm  
# End of macro CALLMONITOR
2c7f				endif 
2c7f			 
2c7f					; skip opcode 
2c7f 23					inc hl  
2c80					; skip next ptr 
2c80 23					inc hl  
2c81 23					inc hl 
2c82					; skip len 
2c82 7e					ld a, (hl)   ; save length to add 
2c83				if DEBUG_FORTH_WORDS 
2c83					DMARK "LS2" 
2c83 f5				push af  
2c84 3a 98 2c			ld a, (.dmark)  
2c87 32 6e fe			ld (debug_mark),a  
2c8a 3a 99 2c			ld a, (.dmark+1)  
2c8d 32 6f fe			ld (debug_mark+1),a  
2c90 3a 9a 2c			ld a, (.dmark+2)  
2c93 32 70 fe			ld (debug_mark+2),a  
2c96 18 03			jr .pastdmark  
2c98 ..			.dmark: db "LS2"  
2c9b f1			.pastdmark: pop af  
2c9c			endm  
# End of macro DMARK
2c9c					CALLMONITOR 
2c9c cd 73 18			call break_point_state  
2c9f				endm  
# End of macro CALLMONITOR
2c9f				endif 
2c9f			 
2c9f					; save this location 
2c9f				 
2c9f e5					push hl 
2ca0			 
2ca0 23					inc hl 
2ca1 11 01 f2				ld de, scratch+2 
2ca4 4f					ld c, a 
2ca5 06 00				ld b, 0 
2ca7			 
2ca7				if DEBUG_FORTH_WORDS 
2ca7					DMARK "LSn" 
2ca7 f5				push af  
2ca8 3a bc 2c			ld a, (.dmark)  
2cab 32 6e fe			ld (debug_mark),a  
2cae 3a bd 2c			ld a, (.dmark+1)  
2cb1 32 6f fe			ld (debug_mark+1),a  
2cb4 3a be 2c			ld a, (.dmark+2)  
2cb7 32 70 fe			ld (debug_mark+2),a  
2cba 18 03			jr .pastdmark  
2cbc ..			.dmark: db "LSn"  
2cbf f1			.pastdmark: pop af  
2cc0			endm  
# End of macro DMARK
2cc0					CALLMONITOR 
2cc0 cd 73 18			call break_point_state  
2cc3				endm  
# End of macro CALLMONITOR
2cc3				endif 
2cc3			 
2cc3					; copy uword name to scratch 
2cc3			 
2cc3 ed b0				ldir 
2cc5			 
2cc5 1b					dec de 
2cc6 3e 20				ld a, ' '    ; change null to space 
2cc8 12					ld (de), a 
2cc9			 
2cc9 13					inc de 
2cca			 
2cca d5					push de 
2ccb c1					pop bc     ; move scratch pointer to end of word name and save it 
2ccc			 
2ccc e1					pop hl 
2ccd 7e					ld a, (hl) 
2cce					;inc hl 
2cce					; skip word string 
2cce cd cc 0e				call addatohl 
2cd1			 
2cd1 23					inc hl 
2cd2			 
2cd2				if DEBUG_FORTH_WORDS 
2cd2					DMARK "LS3" 
2cd2 f5				push af  
2cd3 3a e7 2c			ld a, (.dmark)  
2cd6 32 6e fe			ld (debug_mark),a  
2cd9 3a e8 2c			ld a, (.dmark+1)  
2cdc 32 6f fe			ld (debug_mark+1),a  
2cdf 3a e9 2c			ld a, (.dmark+2)  
2ce2 32 70 fe			ld (debug_mark+2),a  
2ce5 18 03			jr .pastdmark  
2ce7 ..			.dmark: db "LS3"  
2cea f1			.pastdmark: pop af  
2ceb			endm  
# End of macro DMARK
2ceb					CALLMONITOR 
2ceb cd 73 18			call break_point_state  
2cee				endm  
# End of macro CALLMONITOR
2cee				endif 
2cee					; should now be at the start of the machine code to setup the eval of the uword 
2cee					; now locate the ptr to the string defintion 
2cee			 
2cee					; skip ld hl, 
2cee					; then load the ptr 
2cee			; TODO use get from hl ptr 
2cee 23					inc hl 
2cef 5e					ld e, (hl) 
2cf0 23					inc hl 
2cf1 56					ld d, (hl) 
2cf2 eb					ex de, hl 
2cf3			 
2cf3			 
2cf3				if DEBUG_FORTH_WORDS 
2cf3					DMARK "LSt" 
2cf3 f5				push af  
2cf4 3a 08 2d			ld a, (.dmark)  
2cf7 32 6e fe			ld (debug_mark),a  
2cfa 3a 09 2d			ld a, (.dmark+1)  
2cfd 32 6f fe			ld (debug_mark+1),a  
2d00 3a 0a 2d			ld a, (.dmark+2)  
2d03 32 70 fe			ld (debug_mark+2),a  
2d06 18 03			jr .pastdmark  
2d08 ..			.dmark: db "LSt"  
2d0b f1			.pastdmark: pop af  
2d0c			endm  
# End of macro DMARK
2d0c					CALLMONITOR 
2d0c cd 73 18			call break_point_state  
2d0f				endm  
# End of macro CALLMONITOR
2d0f				endif 
2d0f			 
2d0f			; cant push right now due to tokenised strings  
2d0f			 
2d0f			; get the destination of where to copy this definition to. 
2d0f			 
2d0f c5					push bc 
2d10 d1					pop de 
2d11			 
2d11 7e			.listl:         ld a,(hl) 
2d12 fe 00				cp 0 
2d14 28 09				jr z, .lreplsp     ; replace zero with space 
2d16					;cp FORTH_END_BUFFER 
2d16 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2d18 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2d1a				 
2d1a					; just copy this char as is then 
2d1a			 
2d1a 12					ld (de), a 
2d1b			 
2d1b 23			.listnxt:	inc hl 
2d1c 13					inc de 
2d1d 18 f2				jr .listl 
2d1f			 
2d1f 3e 20		.lreplsp:	ld a,' ' 
2d21 12					ld (de), a 
2d22 18 f7				jr .listnxt 
2d24			 
2d24			; close up uword def 
2d24			 
2d24			.listdone: 
2d24 12					ld (de), a 
2d25 13					inc de 
2d26 3e 00				ld a, 0 
2d28 12					ld (de), a 
2d29			 
2d29			; now have def so clean up and push to stack 
2d29			 
2d29 21 ff f1				ld hl, scratch 
2d2c				if DEBUG_FORTH_WORDS 
2d2c					DMARK "Ltp" 
2d2c f5				push af  
2d2d 3a 41 2d			ld a, (.dmark)  
2d30 32 6e fe			ld (debug_mark),a  
2d33 3a 42 2d			ld a, (.dmark+1)  
2d36 32 6f fe			ld (debug_mark+1),a  
2d39 3a 43 2d			ld a, (.dmark+2)  
2d3c 32 70 fe			ld (debug_mark+2),a  
2d3f 18 03			jr .pastdmark  
2d41 ..			.dmark: db "Ltp"  
2d44 f1			.pastdmark: pop af  
2d45			endm  
# End of macro DMARK
2d45					CALLMONITOR 
2d45 cd 73 18			call break_point_state  
2d48				endm  
# End of macro CALLMONITOR
2d48				endif 
2d48			 
2d48 18 1f			jr .listpush 
2d4a			 
2d4a			;.lnuword:	pop hl 
2d4a			;		call forth_tok_next 
2d4a			;		jp .ldouscan  
2d4a			 
2d4a			.lunotfound:		  
2d4a			 
2d4a				if DEBUG_FORTH_WORDS 
2d4a					DMARK "LSn" 
2d4a f5				push af  
2d4b 3a 5f 2d			ld a, (.dmark)  
2d4e 32 6e fe			ld (debug_mark),a  
2d51 3a 60 2d			ld a, (.dmark+1)  
2d54 32 6f fe			ld (debug_mark+1),a  
2d57 3a 61 2d			ld a, (.dmark+2)  
2d5a 32 70 fe			ld (debug_mark+2),a  
2d5d 18 03			jr .pastdmark  
2d5f ..			.dmark: db "LSn"  
2d62 f1			.pastdmark: pop af  
2d63			endm  
# End of macro DMARK
2d63					CALLMONITOR 
2d63 cd 73 18			call break_point_state  
2d66				endm  
# End of macro CALLMONITOR
2d66				endif 
2d66			 
2d66					 
2d66			;		FORTH_DSP_POP 
2d66			;		ld hl, .luno 
2d66			 
2d66					NEXTW			 
2d66 c3 55 22			jp macro_next 
2d69				endm 
# End of macro NEXTW
2d69			 
2d69			.listpush: 
2d69				if DEBUG_FORTH_WORDS 
2d69					DMARK "LS>" 
2d69 f5				push af  
2d6a 3a 7e 2d			ld a, (.dmark)  
2d6d 32 6e fe			ld (debug_mark),a  
2d70 3a 7f 2d			ld a, (.dmark+1)  
2d73 32 6f fe			ld (debug_mark+1),a  
2d76 3a 80 2d			ld a, (.dmark+2)  
2d79 32 70 fe			ld (debug_mark+2),a  
2d7c 18 03			jr .pastdmark  
2d7e ..			.dmark: db "LS>"  
2d81 f1			.pastdmark: pop af  
2d82			endm  
# End of macro DMARK
2d82					CALLMONITOR 
2d82 cd 73 18			call break_point_state  
2d85				endm  
# End of macro CALLMONITOR
2d85				endif 
2d85 cd 55 1f				call forth_push_str 
2d88			 
2d88			 
2d88			 
2d88					NEXTW 
2d88 c3 55 22			jp macro_next 
2d8b				endm 
# End of macro NEXTW
2d8b			 
2d8b			;.luno:    db "Word not found",0 
2d8b			 
2d8b			 
2d8b			 
2d8b			 
2d8b			 
2d8b			;		push hl   ; save pointer to start of uword def string 
2d8b			; 
2d8b			;; look for FORTH_EOL_LINE 
2d8b			;		ld a, FORTH_END_BUFFER 
2d8b			;		call strlent 
2d8b			; 
2d8b			;		inc hl		 ; space for coln def 
2d8b			;		inc hl 
2d8b			;		inc hl          ; space for terms 
2d8b			;		inc hl 
2d8b			; 
2d8b			;		ld a, 20   ; TODO get actual length 
2d8b			;		call addatohl    ; include a random amount of room for the uword name 
2d8b			; 
2d8b			;		 
2d8b			;	if DEBUG_FORTH_WORDS 
2d8b			;		DMARK "Lt1" 
2d8b			;		CALLMONITOR 
2d8b			;	endif 
2d8b			;		 
2d8b			; 
2d8b			;; malloc space for the string because we cant change it 
2d8b			; 
2d8b			;		call malloc 
2d8b			;	if DEBUG_FORTH_MALLOC_GUARD 
2d8b			;		push af 
2d8b			;		call ishlzero 
2d8b			;		pop af 
2d8b			;		 
2d8b			;		call z,malloc_error 
2d8b			;	endif 
2d8b			; 
2d8b			;	if DEBUG_FORTH_WORDS 
2d8b			;		DMARK "Lt2" 
2d8b			;		CALLMONITOR 
2d8b			;	endif 
2d8b			;		pop de 
2d8b			;		push hl    ; push the malloc to release later 
2d8b			;		push hl   ;  push back a copy for the later stack push 
2d8b			;		 
2d8b			;; copy the string swapping out the zero terms for spaces 
2d8b			; 
2d8b			;		; de has our source 
2d8b			;		; hl has our dest 
2d8b			; 
2d8b			;; add the coln def 
2d8b			; 
2d8b			;		ld a, ':' 
2d8b			;		ld (hl), a 
2d8b			;		inc hl 
2d8b			;		ld a, ' ' 
2d8b			;		ld (hl), a 
2d8b			;		inc hl 
2d8b			; 
2d8b			;; add the uname word 
2d8b			;		push de   ; save our string for now 
2d8b			;		ex de, hl 
2d8b			; 
2d8b			;		FORTH_DSP_VALUE 
2d8b			;		;v5 FORTH_DSP_VALUE 
2d8b			; 
2d8b			;		inc hl   ; skip type but we know by now this is OK 
2d8b			; 
2d8b			;.luword:	ld a,(hl) 
2d8b			;		cp 0 
2d8b			;		jr z, .luword2 
2d8b			;		ld (de), a 
2d8b			;		inc de 
2d8b			;		inc hl 
2d8b			;		jr .luword 
2d8b			; 
2d8b			;.luword2:	ld a, ' ' 
2d8b			;		ld (de), a 
2d8b			;;		inc hl 
2d8b			;;		inc de 
2d8b			;;		ld (de), a 
2d8b			;;		inc hl 
2d8b			;		inc de 
2d8b			; 
2d8b			;		ex de, hl 
2d8b			;		pop de 
2d8b			;		 
2d8b			;		 
2d8b			; 
2d8b			;; detoken that string and copy it 
2d8b			; 
2d8b			;	if DEBUG_FORTH_WORDS 
2d8b			;		DMARK "Lt2" 
2d8b			;		CALLMONITOR 
2d8b			;	endif 
2d8b			;.ldetok:	ld a, (de) 
2d8b			;		cp FORTH_END_BUFFER 
2d8b			;		jr z, .ldetokend 
2d8b			;		; swap out any zero term for space 
2d8b			;		cp 0 
2d8b			;		jr nz, .ldetoknext 
2d8b			;		ld a, ' ' 
2d8b			; 
2d8b			;	if DEBUG_FORTH_WORDS 
2d8b			;		DMARK "LtS" 
2d8b			;		CALLMONITOR 
2d8b			;	endif 
2d8b			;.ldetoknext:	ld (hl), a 
2d8b			;		inc de 
2d8b			;		inc hl 
2d8b			;		jr .ldetok 
2d8b			; 
2d8b			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2d8b			;		ld (hl), a  
2d8b			; 
2d8b			;; free that temp malloc 
2d8b			; 
2d8b			;		pop hl    
2d8b			; 
2d8b			;	if DEBUG_FORTH_WORDS 
2d8b			;		DMARK "Lt4" 
2d8b			;		CALLMONITOR 
2d8b			;	endif 
2d8b			;		call forth_apushstrhl 
2d8b			; 
2d8b			;		; get rid of temp malloc area 
2d8b			; 
2d8b			;		pop hl 
2d8b			;		call free 
2d8b			; 
2d8b			;		jr .ludone 
2d8b			; 
2d8b			;.lnuword:	pop hl 
2d8b			;		call forth_tok_next 
2d8b			;		jp .ldouscan  
2d8b			; 
2d8b			;.ludone:		 pop hl 
2d8b			; 
2d8b					NEXTW 
2d8b c3 55 22			jp macro_next 
2d8e				endm 
# End of macro NEXTW
2d8e			 
2d8e			.FORGET: 
2d8e				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2d8e 5d				db WORD_SYS_CORE+73             
2d8f 07 2e			dw .NOP            
2d91 07				db 6 + 1 
2d92 .. 00			db "FORGET",0              
2d99				endm 
# End of macro CWHEAD
2d99			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2d99			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2d99			; | |  
2d99			; | | e.g. "MORE" forget 
2d99					if DEBUG_FORTH_WORDS_KEY 
2d99						DMARK "FRG" 
2d99 f5				push af  
2d9a 3a ae 2d			ld a, (.dmark)  
2d9d 32 6e fe			ld (debug_mark),a  
2da0 3a af 2d			ld a, (.dmark+1)  
2da3 32 6f fe			ld (debug_mark+1),a  
2da6 3a b0 2d			ld a, (.dmark+2)  
2da9 32 70 fe			ld (debug_mark+2),a  
2dac 18 03			jr .pastdmark  
2dae ..			.dmark: db "FRG"  
2db1 f1			.pastdmark: pop af  
2db2			endm  
# End of macro DMARK
2db2						CALLMONITOR 
2db2 cd 73 18			call break_point_state  
2db5				endm  
# End of macro CALLMONITOR
2db5					endif 
2db5			 
2db5				; find uword 
2db5			        ; update start of word with "_" 
2db5				; replace uword with deleted flag 
2db5			 
2db5			 
2db5			;	if DEBUG_FORTH_WORDS 
2db5			;		DMARK "FOG" 
2db5			;		CALLMONITOR 
2db5			;	endif 
2db5			 
2db5			 
2db5					; Get ptr to the word we need to look up 
2db5			 
2db5					FORTH_DSP_VALUEHL 
2db5 cd de 20			call macro_dsp_valuehl 
2db8				endm 
# End of macro FORTH_DSP_VALUEHL
2db8					;v5 FORTH_DSP_VALUE 
2db8				; TODO type check 
2db8			;		inc hl    ; Skip type check  
2db8 e5					push hl 
2db9 c1					pop bc 
2dba			;		ex de, hl    ; put into DE 
2dba			 
2dba			 
2dba 21 00 80				ld hl, baseram 
2dbd					;ld hl, baseusermem 
2dbd			 
2dbd				; skip dict stub 
2dbd			;	call forth_tok_next 
2dbd e5			push hl   ; sacreifical push 
2dbe			 
2dbe			.fldouscanm: 
2dbe e1				pop hl 
2dbf			.fldouscan: 
2dbf			;	if DEBUG_FORTH_WORDS 
2dbf			;		DMARK "LSs" 
2dbf			;		CALLMONITOR 
2dbf			;	endif 
2dbf				; skip dict stub 
2dbf cd a6 23				call forth_tok_next 
2dc2			 
2dc2			 
2dc2			; while we have words to look for 
2dc2			 
2dc2 7e				ld a, (hl)      
2dc3			;	if DEBUG_FORTH_WORDS 
2dc3			;		DMARK "LSk" 
2dc3			;		CALLMONITOR 
2dc3			;	endif 
2dc3 fe 00				cp WORD_SYS_END 
2dc5 ca 01 2e				jp z, .flunotfound 
2dc8 fe 01				cp WORD_SYS_UWORD 
2dca c2 bf 2d				jp nz, .fldouscan 
2dcd			 
2dcd			;	if DEBUG_FORTH_WORDS 
2dcd			;		DMARK "LSu" 
2dcd			;		CALLMONITOR 
2dcd			;	endif 
2dcd			 
2dcd					; found a uword but is it the one we want... 
2dcd			 
2dcd c5					push bc     ; uword to find is on bc 
2dce d1					pop de 
2dcf			 
2dcf e5					push hl  ; to save the ptr 
2dd0			 
2dd0					; skip opcode 
2dd0 23					inc hl  
2dd1					; skip next ptr 
2dd1 23					inc hl  
2dd2 23					inc hl 
2dd3					; skip len 
2dd3 23					inc hl 
2dd4			 
2dd4			;	if DEBUG_FORTH_WORDS 
2dd4			;		DMARK "LSc" 
2dd4			;		CALLMONITOR 
2dd4			;	endif 
2dd4 cd 62 13				call strcmp 
2dd7 c2 be 2d				jp nz, .fldouscanm 
2dda			; 
2dda			; 
2dda			;; while we have words to look for 
2dda			; 
2dda			;.fdouscan:	ld a, (hl)      
2dda			;	if DEBUG_FORTH_WORDS 
2dda			;		DMARK "LSs" 
2dda			;		CALLMONITOR 
2dda			;	endif 
2dda			;		cp WORD_SYS_END 
2dda			;		jp z, .fudone 
2dda			;		cp WORD_SYS_UWORD 
2dda			;		jp nz, .fnuword 
2dda			; 
2dda			;	if DEBUG_FORTH_WORDS 
2dda			;		DMARK "FGu" 
2dda			;		CALLMONITOR 
2dda			;	endif 
2dda			; 
2dda			;		; found a uword but is it the one we want... 
2dda			; 
2dda			; 
2dda			;	        pop de   ; get back the dsp name 
2dda			;		push de 
2dda			; 
2dda			;		push hl  ; to save the ptr 
2dda			; 
2dda			;		; skip opcode 
2dda			;		inc hl  
2dda			;		; skip next ptr 
2dda			;		inc hl  
2dda			;		inc hl 
2dda			;		; skip len 
2dda			;		inc hl 
2dda			; 
2dda			;	if DEBUG_FORTH_WORDS 
2dda			;		DMARK "FGc" 
2dda			;		CALLMONITOR 
2dda			;	endif 
2dda			;		call strcmp 
2dda			;		jp nz, .fnuword 
2dda			 
2dda			 
2dda e1			pop hl 
2ddb			 
2ddb				 
2ddb				if DEBUG_FORTH_WORDS 
2ddb					DMARK "FGm" 
2ddb f5				push af  
2ddc 3a f0 2d			ld a, (.dmark)  
2ddf 32 6e fe			ld (debug_mark),a  
2de2 3a f1 2d			ld a, (.dmark+1)  
2de5 32 6f fe			ld (debug_mark+1),a  
2de8 3a f2 2d			ld a, (.dmark+2)  
2deb 32 70 fe			ld (debug_mark+2),a  
2dee 18 03			jr .pastdmark  
2df0 ..			.dmark: db "FGm"  
2df3 f1			.pastdmark: pop af  
2df4			endm  
# End of macro DMARK
2df4					CALLMONITOR 
2df4 cd 73 18			call break_point_state  
2df7				endm  
# End of macro CALLMONITOR
2df7				endif 
2df7			 
2df7			 
2df7			 
2df7					; we have a uword so push its name to the stack 
2df7			 
2df7			;	   	push hl  ; save so we can move to next dict block 
2df7			;pop hl 
2df7			 
2df7					; update opcode to deleted 
2df7 3e 03				ld a, WORD_SYS_DELETED 
2df9 77					ld (hl), a 
2dfa			 
2dfa 23					inc hl  
2dfb					; skip next ptr 
2dfb 23					inc hl  
2dfc 23					inc hl 
2dfd					; skip len 
2dfd 23					inc hl 
2dfe			 
2dfe					; TODO change parser to skip deleted words but for now mark it out 
2dfe 3e 5f				ld a, "_" 
2e00 77					ld  (hl),a 
2e01			 
2e01			;		jr .fudone 
2e01			; 
2e01			;.fnuword:	pop hl 
2e01			;		call forth_tok_next 
2e01			;		jp .fdouscan  
2e01			 
2e01			.flunotfound:		  
2e01			 
2e01			 
2e01					 
2e01					FORTH_DSP_POP 
2e01 cd 96 21			call macro_forth_dsp_pop 
2e04				endm 
# End of macro FORTH_DSP_POP
2e04			;		ld hl, .luno 
2e04			;.fudone:		 pop hl 
2e04					NEXTW 
2e04 c3 55 22			jp macro_next 
2e07				endm 
# End of macro NEXTW
2e07			.NOP: 
2e07				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2e07 61				db WORD_SYS_CORE+77             
2e08 2e 2e			dw .COMO            
2e0a 04				db 3 + 1 
2e0b .. 00			db "NOP",0              
2e0f				endm 
# End of macro CWHEAD
2e0f			; | NOP (  --  ) Do nothing | DONE 
2e0f					if DEBUG_FORTH_WORDS_KEY 
2e0f						DMARK "NOP" 
2e0f f5				push af  
2e10 3a 24 2e			ld a, (.dmark)  
2e13 32 6e fe			ld (debug_mark),a  
2e16 3a 25 2e			ld a, (.dmark+1)  
2e19 32 6f fe			ld (debug_mark+1),a  
2e1c 3a 26 2e			ld a, (.dmark+2)  
2e1f 32 70 fe			ld (debug_mark+2),a  
2e22 18 03			jr .pastdmark  
2e24 ..			.dmark: db "NOP"  
2e27 f1			.pastdmark: pop af  
2e28			endm  
# End of macro DMARK
2e28						CALLMONITOR 
2e28 cd 73 18			call break_point_state  
2e2b				endm  
# End of macro CALLMONITOR
2e2b					endif 
2e2b				       NEXTW 
2e2b c3 55 22			jp macro_next 
2e2e				endm 
# End of macro NEXTW
2e2e			.COMO: 
2e2e				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2e2e 6e				db WORD_SYS_CORE+90             
2e2f 80 2e			dw .COMC            
2e31 02				db 1 + 1 
2e32 .. 00			db "(",0              
2e34				endm 
# End of macro CWHEAD
2e34			; | ( ( -- )  Start of comment | DONE 
2e34			 
2e34			 
2e34 2a 00 f5				ld hl, ( os_tok_ptr) 
2e37 11 7b 2e			ld de, .closepar 
2e3a					 
2e3a					if DEBUG_FORTH_WORDS 
2e3a						DMARK ").." 
2e3a f5				push af  
2e3b 3a 4f 2e			ld a, (.dmark)  
2e3e 32 6e fe			ld (debug_mark),a  
2e41 3a 50 2e			ld a, (.dmark+1)  
2e44 32 6f fe			ld (debug_mark+1),a  
2e47 3a 51 2e			ld a, (.dmark+2)  
2e4a 32 70 fe			ld (debug_mark+2),a  
2e4d 18 03			jr .pastdmark  
2e4f ..			.dmark: db ").."  
2e52 f1			.pastdmark: pop af  
2e53			endm  
# End of macro DMARK
2e53						CALLMONITOR 
2e53 cd 73 18			call break_point_state  
2e56				endm  
# End of macro CALLMONITOR
2e56					endif 
2e56 cd 70 23			call findnexttok  
2e59			 
2e59					if DEBUG_FORTH_WORDS 
2e59						DMARK "IF5" 
2e59 f5				push af  
2e5a 3a 6e 2e			ld a, (.dmark)  
2e5d 32 6e fe			ld (debug_mark),a  
2e60 3a 6f 2e			ld a, (.dmark+1)  
2e63 32 6f fe			ld (debug_mark+1),a  
2e66 3a 70 2e			ld a, (.dmark+2)  
2e69 32 70 fe			ld (debug_mark+2),a  
2e6c 18 03			jr .pastdmark  
2e6e ..			.dmark: db "IF5"  
2e71 f1			.pastdmark: pop af  
2e72			endm  
# End of macro DMARK
2e72						CALLMONITOR 
2e72 cd 73 18			call break_point_state  
2e75				endm  
# End of macro CALLMONITOR
2e75					endif 
2e75				; replace below with ) exec using tok_ptr 
2e75 22 00 f5			ld (os_tok_ptr), hl 
2e78 c3 e6 22			jp exec1 
2e7b			 
2e7b .. 00			.closepar:   db ")",0 
2e7d			 
2e7d				       NEXTW 
2e7d c3 55 22			jp macro_next 
2e80				endm 
# End of macro NEXTW
2e80			.COMC: 
2e80				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2e80 6f				db WORD_SYS_CORE+91             
2e81 89 2e			dw .SCRATCH            
2e83 02				db 1 + 1 
2e84 .. 00			db ")",0              
2e86				endm 
# End of macro CWHEAD
2e86			; | ) ( -- )  End of comment |  DONE  
2e86				       NEXTW 
2e86 c3 55 22			jp macro_next 
2e89				endm 
# End of macro NEXTW
2e89			 
2e89			.SCRATCH: 
2e89				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2e89 6f				db WORD_SYS_CORE+91             
2e8a c4 2e			dw .INC            
2e8c 08				db 7 + 1 
2e8d .. 00			db "SCRATCH",0              
2e95				endm 
# End of macro CWHEAD
2e95			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2e95			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2e95			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2e95			; | |  
2e95			; | | e.g.    : score $00 scratch ; 
2e95			; | |  
2e95			; | | $00 score ! 
2e95			; | | $01 score +! 
2e95			; | |  
2e95			; | | e.g.   : varword $0a scratch ;  
2e95			; | | 
2e95			; | | $8000 varword ! 
2e95					if DEBUG_FORTH_WORDS_KEY 
2e95						DMARK "SCR" 
2e95 f5				push af  
2e96 3a aa 2e			ld a, (.dmark)  
2e99 32 6e fe			ld (debug_mark),a  
2e9c 3a ab 2e			ld a, (.dmark+1)  
2e9f 32 6f fe			ld (debug_mark+1),a  
2ea2 3a ac 2e			ld a, (.dmark+2)  
2ea5 32 70 fe			ld (debug_mark+2),a  
2ea8 18 03			jr .pastdmark  
2eaa ..			.dmark: db "SCR"  
2ead f1			.pastdmark: pop af  
2eae			endm  
# End of macro DMARK
2eae						CALLMONITOR 
2eae cd 73 18			call break_point_state  
2eb1				endm  
# End of macro CALLMONITOR
2eb1					endif 
2eb1			 
2eb1					FORTH_DSP_VALUEHL 
2eb1 cd de 20			call macro_dsp_valuehl 
2eb4				endm 
# End of macro FORTH_DSP_VALUEHL
2eb4				 
2eb4					FORTH_DSP_POP 
2eb4 cd 96 21			call macro_forth_dsp_pop 
2eb7				endm 
# End of macro FORTH_DSP_POP
2eb7			 
2eb7 7d					ld a, l 
2eb8 21 24 f7				ld hl, os_var_array 
2ebb cd cc 0e				call addatohl 
2ebe			 
2ebe cd e7 1e				call forth_push_numhl 
2ec1			 
2ec1				       NEXTW 
2ec1 c3 55 22			jp macro_next 
2ec4				endm 
# End of macro NEXTW
2ec4			 
2ec4			.INC: 
2ec4				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2ec4 6f				db WORD_SYS_CORE+91             
2ec5 18 2f			dw .DEC            
2ec7 03				db 2 + 1 
2ec8 .. 00			db "+!",0              
2ecb				endm 
# End of macro CWHEAD
2ecb			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2ecb					if DEBUG_FORTH_WORDS_KEY 
2ecb						DMARK "+s_" 
2ecb f5				push af  
2ecc 3a e0 2e			ld a, (.dmark)  
2ecf 32 6e fe			ld (debug_mark),a  
2ed2 3a e1 2e			ld a, (.dmark+1)  
2ed5 32 6f fe			ld (debug_mark+1),a  
2ed8 3a e2 2e			ld a, (.dmark+2)  
2edb 32 70 fe			ld (debug_mark+2),a  
2ede 18 03			jr .pastdmark  
2ee0 ..			.dmark: db "+s_"  
2ee3 f1			.pastdmark: pop af  
2ee4			endm  
# End of macro DMARK
2ee4						CALLMONITOR 
2ee4 cd 73 18			call break_point_state  
2ee7				endm  
# End of macro CALLMONITOR
2ee7					endif 
2ee7			 
2ee7					FORTH_DSP_VALUEHL 
2ee7 cd de 20			call macro_dsp_valuehl 
2eea				endm 
# End of macro FORTH_DSP_VALUEHL
2eea			 
2eea e5					push hl   ; save address 
2eeb			 
2eeb					FORTH_DSP_POP 
2eeb cd 96 21			call macro_forth_dsp_pop 
2eee				endm 
# End of macro FORTH_DSP_POP
2eee			 
2eee					FORTH_DSP_VALUEHL 
2eee cd de 20			call macro_dsp_valuehl 
2ef1				endm 
# End of macro FORTH_DSP_VALUEHL
2ef1			 
2ef1					FORTH_DSP_POP 
2ef1 cd 96 21			call macro_forth_dsp_pop 
2ef4				endm 
# End of macro FORTH_DSP_POP
2ef4			 
2ef4					; hl contains value to add to byte at a 
2ef4				 
2ef4 eb					ex de, hl 
2ef5			 
2ef5 e1					pop hl 
2ef6			 
2ef6					if DEBUG_FORTH_WORDS 
2ef6						DMARK "INC" 
2ef6 f5				push af  
2ef7 3a 0b 2f			ld a, (.dmark)  
2efa 32 6e fe			ld (debug_mark),a  
2efd 3a 0c 2f			ld a, (.dmark+1)  
2f00 32 6f fe			ld (debug_mark+1),a  
2f03 3a 0d 2f			ld a, (.dmark+2)  
2f06 32 70 fe			ld (debug_mark+2),a  
2f09 18 03			jr .pastdmark  
2f0b ..			.dmark: db "INC"  
2f0e f1			.pastdmark: pop af  
2f0f			endm  
# End of macro DMARK
2f0f						CALLMONITOR 
2f0f cd 73 18			call break_point_state  
2f12				endm  
# End of macro CALLMONITOR
2f12					endif 
2f12			 
2f12 7e					ld a,(hl) 
2f13 83					add e 
2f14 77					ld (hl),a 
2f15			 
2f15			 
2f15			 
2f15				       NEXTW 
2f15 c3 55 22			jp macro_next 
2f18				endm 
# End of macro NEXTW
2f18			 
2f18			.DEC: 
2f18				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2f18 6f				db WORD_SYS_CORE+91             
2f19 69 2f			dw .INC2            
2f1b 03				db 2 + 1 
2f1c .. 00			db "-!",0              
2f1f				endm 
# End of macro CWHEAD
2f1f			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2f1f					if DEBUG_FORTH_WORDS_KEY 
2f1f						DMARK "-s_" 
2f1f f5				push af  
2f20 3a 34 2f			ld a, (.dmark)  
2f23 32 6e fe			ld (debug_mark),a  
2f26 3a 35 2f			ld a, (.dmark+1)  
2f29 32 6f fe			ld (debug_mark+1),a  
2f2c 3a 36 2f			ld a, (.dmark+2)  
2f2f 32 70 fe			ld (debug_mark+2),a  
2f32 18 03			jr .pastdmark  
2f34 ..			.dmark: db "-s_"  
2f37 f1			.pastdmark: pop af  
2f38			endm  
# End of macro DMARK
2f38						CALLMONITOR 
2f38 cd 73 18			call break_point_state  
2f3b				endm  
# End of macro CALLMONITOR
2f3b					endif 
2f3b			 
2f3b					FORTH_DSP_VALUEHL 
2f3b cd de 20			call macro_dsp_valuehl 
2f3e				endm 
# End of macro FORTH_DSP_VALUEHL
2f3e			 
2f3e e5					push hl   ; save address 
2f3f			 
2f3f					FORTH_DSP_POP 
2f3f cd 96 21			call macro_forth_dsp_pop 
2f42				endm 
# End of macro FORTH_DSP_POP
2f42			 
2f42					FORTH_DSP_VALUEHL 
2f42 cd de 20			call macro_dsp_valuehl 
2f45				endm 
# End of macro FORTH_DSP_VALUEHL
2f45			 
2f45					; hl contains value to add to byte at a 
2f45				 
2f45 eb					ex de, hl 
2f46			 
2f46 e1					pop hl 
2f47			 
2f47					if DEBUG_FORTH_WORDS 
2f47						DMARK "DEC" 
2f47 f5				push af  
2f48 3a 5c 2f			ld a, (.dmark)  
2f4b 32 6e fe			ld (debug_mark),a  
2f4e 3a 5d 2f			ld a, (.dmark+1)  
2f51 32 6f fe			ld (debug_mark+1),a  
2f54 3a 5e 2f			ld a, (.dmark+2)  
2f57 32 70 fe			ld (debug_mark+2),a  
2f5a 18 03			jr .pastdmark  
2f5c ..			.dmark: db "DEC"  
2f5f f1			.pastdmark: pop af  
2f60			endm  
# End of macro DMARK
2f60						CALLMONITOR 
2f60 cd 73 18			call break_point_state  
2f63				endm  
# End of macro CALLMONITOR
2f63					endif 
2f63			 
2f63 7e					ld a,(hl) 
2f64 93					sub e 
2f65 77					ld (hl),a 
2f66			 
2f66			 
2f66			 
2f66				       NEXTW 
2f66 c3 55 22			jp macro_next 
2f69				endm 
# End of macro NEXTW
2f69			 
2f69			.INC2: 
2f69				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2f69 6f				db WORD_SYS_CORE+91             
2f6a 13 30			dw .DEC2            
2f6c 04				db 3 + 1 
2f6d .. 00			db "+2!",0              
2f71				endm 
# End of macro CWHEAD
2f71			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2f71			 
2f71					if DEBUG_FORTH_WORDS_KEY 
2f71						DMARK "+2s" 
2f71 f5				push af  
2f72 3a 86 2f			ld a, (.dmark)  
2f75 32 6e fe			ld (debug_mark),a  
2f78 3a 87 2f			ld a, (.dmark+1)  
2f7b 32 6f fe			ld (debug_mark+1),a  
2f7e 3a 88 2f			ld a, (.dmark+2)  
2f81 32 70 fe			ld (debug_mark+2),a  
2f84 18 03			jr .pastdmark  
2f86 ..			.dmark: db "+2s"  
2f89 f1			.pastdmark: pop af  
2f8a			endm  
# End of macro DMARK
2f8a						CALLMONITOR 
2f8a cd 73 18			call break_point_state  
2f8d				endm  
# End of macro CALLMONITOR
2f8d					endif 
2f8d			 
2f8d					; Address 
2f8d			 
2f8d					FORTH_DSP_VALUEHL 
2f8d cd de 20			call macro_dsp_valuehl 
2f90				endm 
# End of macro FORTH_DSP_VALUEHL
2f90			 
2f90 e5					push hl    ; save address 
2f91			 
2f91					; load content into de 
2f91			 
2f91 5e					ld e,(hl) 
2f92 23					inc hl 
2f93 56					ld d, (hl) 
2f94			 
2f94					if DEBUG_FORTH_WORDS 
2f94						DMARK "+2a" 
2f94 f5				push af  
2f95 3a a9 2f			ld a, (.dmark)  
2f98 32 6e fe			ld (debug_mark),a  
2f9b 3a aa 2f			ld a, (.dmark+1)  
2f9e 32 6f fe			ld (debug_mark+1),a  
2fa1 3a ab 2f			ld a, (.dmark+2)  
2fa4 32 70 fe			ld (debug_mark+2),a  
2fa7 18 03			jr .pastdmark  
2fa9 ..			.dmark: db "+2a"  
2fac f1			.pastdmark: pop af  
2fad			endm  
# End of macro DMARK
2fad						CALLMONITOR 
2fad cd 73 18			call break_point_state  
2fb0				endm  
# End of macro CALLMONITOR
2fb0					endif 
2fb0			 
2fb0					FORTH_DSP_POP 
2fb0 cd 96 21			call macro_forth_dsp_pop 
2fb3				endm 
# End of macro FORTH_DSP_POP
2fb3			 
2fb3					; Get value to add 
2fb3			 
2fb3					FORTH_DSP_VALUE 
2fb3 cd c7 20			call macro_forth_dsp_value 
2fb6				endm 
# End of macro FORTH_DSP_VALUE
2fb6			 
2fb6					if DEBUG_FORTH_WORDS 
2fb6						DMARK "+2v" 
2fb6 f5				push af  
2fb7 3a cb 2f			ld a, (.dmark)  
2fba 32 6e fe			ld (debug_mark),a  
2fbd 3a cc 2f			ld a, (.dmark+1)  
2fc0 32 6f fe			ld (debug_mark+1),a  
2fc3 3a cd 2f			ld a, (.dmark+2)  
2fc6 32 70 fe			ld (debug_mark+2),a  
2fc9 18 03			jr .pastdmark  
2fcb ..			.dmark: db "+2v"  
2fce f1			.pastdmark: pop af  
2fcf			endm  
# End of macro DMARK
2fcf						CALLMONITOR 
2fcf cd 73 18			call break_point_state  
2fd2				endm  
# End of macro CALLMONITOR
2fd2					endif 
2fd2			 
2fd2 19					add hl, de 
2fd3			 
2fd3					if DEBUG_FORTH_WORDS 
2fd3						DMARK "+2+" 
2fd3 f5				push af  
2fd4 3a e8 2f			ld a, (.dmark)  
2fd7 32 6e fe			ld (debug_mark),a  
2fda 3a e9 2f			ld a, (.dmark+1)  
2fdd 32 6f fe			ld (debug_mark+1),a  
2fe0 3a ea 2f			ld a, (.dmark+2)  
2fe3 32 70 fe			ld (debug_mark+2),a  
2fe6 18 03			jr .pastdmark  
2fe8 ..			.dmark: db "+2+"  
2feb f1			.pastdmark: pop af  
2fec			endm  
# End of macro DMARK
2fec						CALLMONITOR 
2fec cd 73 18			call break_point_state  
2fef				endm  
# End of macro CALLMONITOR
2fef					endif 
2fef			 
2fef					; move result to de 
2fef			 
2fef eb					ex de, hl 
2ff0			 
2ff0					; Address 
2ff0			 
2ff0 e1					pop hl 
2ff1			 
2ff1					; save it back 
2ff1			 
2ff1 73					ld (hl), e 
2ff2 23					inc hl 
2ff3 72					ld (hl), d 
2ff4			 
2ff4					if DEBUG_FORTH_WORDS 
2ff4						DMARK "+2e" 
2ff4 f5				push af  
2ff5 3a 09 30			ld a, (.dmark)  
2ff8 32 6e fe			ld (debug_mark),a  
2ffb 3a 0a 30			ld a, (.dmark+1)  
2ffe 32 6f fe			ld (debug_mark+1),a  
3001 3a 0b 30			ld a, (.dmark+2)  
3004 32 70 fe			ld (debug_mark+2),a  
3007 18 03			jr .pastdmark  
3009 ..			.dmark: db "+2e"  
300c f1			.pastdmark: pop af  
300d			endm  
# End of macro DMARK
300d						CALLMONITOR 
300d cd 73 18			call break_point_state  
3010				endm  
# End of macro CALLMONITOR
3010					endif 
3010			 
3010			 
3010			 
3010			 
3010			 
3010				       NEXTW 
3010 c3 55 22			jp macro_next 
3013				endm 
# End of macro NEXTW
3013			 
3013			.DEC2: 
3013				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
3013 6f				db WORD_SYS_CORE+91             
3014 bf 30			dw .GET2            
3016 04				db 3 + 1 
3017 .. 00			db "-2!",0              
301b				endm 
# End of macro CWHEAD
301b			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
301b			 
301b			 
301b					if DEBUG_FORTH_WORDS_KEY 
301b						DMARK "-2s" 
301b f5				push af  
301c 3a 30 30			ld a, (.dmark)  
301f 32 6e fe			ld (debug_mark),a  
3022 3a 31 30			ld a, (.dmark+1)  
3025 32 6f fe			ld (debug_mark+1),a  
3028 3a 32 30			ld a, (.dmark+2)  
302b 32 70 fe			ld (debug_mark+2),a  
302e 18 03			jr .pastdmark  
3030 ..			.dmark: db "-2s"  
3033 f1			.pastdmark: pop af  
3034			endm  
# End of macro DMARK
3034						CALLMONITOR 
3034 cd 73 18			call break_point_state  
3037				endm  
# End of macro CALLMONITOR
3037					endif 
3037			 
3037					; Address 
3037			 
3037					FORTH_DSP_VALUEHL 
3037 cd de 20			call macro_dsp_valuehl 
303a				endm 
# End of macro FORTH_DSP_VALUEHL
303a			 
303a e5					push hl    ; save address 
303b			 
303b					; load content into de 
303b			 
303b 5e					ld e,(hl) 
303c 23					inc hl 
303d 56					ld d, (hl) 
303e			 
303e					if DEBUG_FORTH_WORDS 
303e						DMARK "-2a" 
303e f5				push af  
303f 3a 53 30			ld a, (.dmark)  
3042 32 6e fe			ld (debug_mark),a  
3045 3a 54 30			ld a, (.dmark+1)  
3048 32 6f fe			ld (debug_mark+1),a  
304b 3a 55 30			ld a, (.dmark+2)  
304e 32 70 fe			ld (debug_mark+2),a  
3051 18 03			jr .pastdmark  
3053 ..			.dmark: db "-2a"  
3056 f1			.pastdmark: pop af  
3057			endm  
# End of macro DMARK
3057						CALLMONITOR 
3057 cd 73 18			call break_point_state  
305a				endm  
# End of macro CALLMONITOR
305a					endif 
305a			 
305a					FORTH_DSP_POP 
305a cd 96 21			call macro_forth_dsp_pop 
305d				endm 
# End of macro FORTH_DSP_POP
305d			 
305d					; Get value to remove 
305d			 
305d					FORTH_DSP_VALUE 
305d cd c7 20			call macro_forth_dsp_value 
3060				endm 
# End of macro FORTH_DSP_VALUE
3060			 
3060					if DEBUG_FORTH_WORDS 
3060						DMARK "-2v" 
3060 f5				push af  
3061 3a 75 30			ld a, (.dmark)  
3064 32 6e fe			ld (debug_mark),a  
3067 3a 76 30			ld a, (.dmark+1)  
306a 32 6f fe			ld (debug_mark+1),a  
306d 3a 77 30			ld a, (.dmark+2)  
3070 32 70 fe			ld (debug_mark+2),a  
3073 18 03			jr .pastdmark  
3075 ..			.dmark: db "-2v"  
3078 f1			.pastdmark: pop af  
3079			endm  
# End of macro DMARK
3079						CALLMONITOR 
3079 cd 73 18			call break_point_state  
307c				endm  
# End of macro CALLMONITOR
307c					endif 
307c			 
307c eb					ex de, hl 
307d ed 52				sbc hl, de 
307f			 
307f					if DEBUG_FORTH_WORDS 
307f						DMARK "-2d" 
307f f5				push af  
3080 3a 94 30			ld a, (.dmark)  
3083 32 6e fe			ld (debug_mark),a  
3086 3a 95 30			ld a, (.dmark+1)  
3089 32 6f fe			ld (debug_mark+1),a  
308c 3a 96 30			ld a, (.dmark+2)  
308f 32 70 fe			ld (debug_mark+2),a  
3092 18 03			jr .pastdmark  
3094 ..			.dmark: db "-2d"  
3097 f1			.pastdmark: pop af  
3098			endm  
# End of macro DMARK
3098						CALLMONITOR 
3098 cd 73 18			call break_point_state  
309b				endm  
# End of macro CALLMONITOR
309b					endif 
309b			 
309b					; move result to de 
309b			 
309b eb					ex de, hl 
309c			 
309c					; Address 
309c			 
309c e1					pop hl 
309d			 
309d					; save it back 
309d			 
309d 73					ld (hl), e 
309e 23					inc hl 
309f 72					ld (hl), d 
30a0			 
30a0					if DEBUG_FORTH_WORDS 
30a0						DMARK "-2e" 
30a0 f5				push af  
30a1 3a b5 30			ld a, (.dmark)  
30a4 32 6e fe			ld (debug_mark),a  
30a7 3a b6 30			ld a, (.dmark+1)  
30aa 32 6f fe			ld (debug_mark+1),a  
30ad 3a b7 30			ld a, (.dmark+2)  
30b0 32 70 fe			ld (debug_mark+2),a  
30b3 18 03			jr .pastdmark  
30b5 ..			.dmark: db "-2e"  
30b8 f1			.pastdmark: pop af  
30b9			endm  
# End of macro DMARK
30b9						CALLMONITOR 
30b9 cd 73 18			call break_point_state  
30bc				endm  
# End of macro CALLMONITOR
30bc					endif 
30bc			 
30bc			 
30bc			 
30bc			 
30bc			 
30bc				       NEXTW 
30bc c3 55 22			jp macro_next 
30bf				endm 
# End of macro NEXTW
30bf			.GET2: 
30bf				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
30bf 6f				db WORD_SYS_CORE+91             
30c0 ef 30			dw .BANG2            
30c2 03				db 2 + 1 
30c3 .. 00			db "2@",0              
30c6				endm 
# End of macro CWHEAD
30c6			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
30c6					if DEBUG_FORTH_WORDS_KEY 
30c6						DMARK "2A_" 
30c6 f5				push af  
30c7 3a db 30			ld a, (.dmark)  
30ca 32 6e fe			ld (debug_mark),a  
30cd 3a dc 30			ld a, (.dmark+1)  
30d0 32 6f fe			ld (debug_mark+1),a  
30d3 3a dd 30			ld a, (.dmark+2)  
30d6 32 70 fe			ld (debug_mark+2),a  
30d9 18 03			jr .pastdmark  
30db ..			.dmark: db "2A_"  
30de f1			.pastdmark: pop af  
30df			endm  
# End of macro DMARK
30df						CALLMONITOR 
30df cd 73 18			call break_point_state  
30e2				endm  
# End of macro CALLMONITOR
30e2					endif 
30e2			 
30e2					FORTH_DSP_VALUEHL 
30e2 cd de 20			call macro_dsp_valuehl 
30e5				endm 
# End of macro FORTH_DSP_VALUEHL
30e5			 
30e5 5e					ld e, (hl) 
30e6 23					inc hl 
30e7 56					ld d, (hl) 
30e8			 
30e8 eb					ex de, hl 
30e9			 
30e9 cd e7 1e				call forth_push_numhl 
30ec			 
30ec				       NEXTW 
30ec c3 55 22			jp macro_next 
30ef				endm 
# End of macro NEXTW
30ef			.BANG2: 
30ef				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
30ef 6f				db WORD_SYS_CORE+91             
30f0 27 31			dw .CONFIG            
30f2 03				db 2 + 1 
30f3 .. 00			db "2!",0              
30f6				endm 
# End of macro CWHEAD
30f6			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
30f6					if DEBUG_FORTH_WORDS_KEY 
30f6						DMARK "2S_" 
30f6 f5				push af  
30f7 3a 0b 31			ld a, (.dmark)  
30fa 32 6e fe			ld (debug_mark),a  
30fd 3a 0c 31			ld a, (.dmark+1)  
3100 32 6f fe			ld (debug_mark+1),a  
3103 3a 0d 31			ld a, (.dmark+2)  
3106 32 70 fe			ld (debug_mark+2),a  
3109 18 03			jr .pastdmark  
310b ..			.dmark: db "2S_"  
310e f1			.pastdmark: pop af  
310f			endm  
# End of macro DMARK
310f						CALLMONITOR 
310f cd 73 18			call break_point_state  
3112				endm  
# End of macro CALLMONITOR
3112					endif 
3112			 
3112					FORTH_DSP_VALUEHL 
3112 cd de 20			call macro_dsp_valuehl 
3115				endm 
# End of macro FORTH_DSP_VALUEHL
3115			 
3115 e5					push hl   ; save address 
3116			 
3116			 
3116					FORTH_DSP_POP 
3116 cd 96 21			call macro_forth_dsp_pop 
3119				endm 
# End of macro FORTH_DSP_POP
3119			 
3119					 
3119					FORTH_DSP_VALUEHL 
3119 cd de 20			call macro_dsp_valuehl 
311c				endm 
# End of macro FORTH_DSP_VALUEHL
311c			 
311c					FORTH_DSP_POP 
311c cd 96 21			call macro_forth_dsp_pop 
311f				endm 
# End of macro FORTH_DSP_POP
311f			 
311f eb					ex de, hl    ; value now in de 
3120			 
3120 e1					pop hl 
3121			 
3121 73					ld (hl), e 
3122			 
3122 23					inc hl 
3123			 
3123 72					ld (hl), d 
3124			 
3124			 
3124				       NEXTW 
3124 c3 55 22			jp macro_next 
3127				endm 
# End of macro NEXTW
3127			.CONFIG: 
3127				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
3127 6f				db WORD_SYS_CORE+91             
3128 38 31			dw .ENDCORE            
312a 07				db 6 + 1 
312b .. 00			db "CONFIG",0              
3132				endm 
# End of macro CWHEAD
3132			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3132			 
3132 cd 56 15				call config 
3135					NEXTW 
3135 c3 55 22			jp macro_next 
3138				endm 
# End of macro NEXTW
3138			.ENDCORE: 
3138			 
3138			; eof 
3138			 
3138			 
# End of file forth_words_core.asm
3138			include "forth_words_flow.asm" 
3138			 
3138			; | ## Program Flow Words 
3138			 
3138			.IF: 
3138				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
3138 1e				db WORD_SYS_CORE+10             
3139 2d 32			dw .THEN            
313b 03				db 2 + 1 
313c .. 00			db "IF",0              
313f				endm 
# End of macro CWHEAD
313f			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
313f			; 
313f					if DEBUG_FORTH_WORDS_KEY 
313f						DMARK "IF." 
313f f5				push af  
3140 3a 54 31			ld a, (.dmark)  
3143 32 6e fe			ld (debug_mark),a  
3146 3a 55 31			ld a, (.dmark+1)  
3149 32 6f fe			ld (debug_mark+1),a  
314c 3a 56 31			ld a, (.dmark+2)  
314f 32 70 fe			ld (debug_mark+2),a  
3152 18 03			jr .pastdmark  
3154 ..			.dmark: db "IF."  
3157 f1			.pastdmark: pop af  
3158			endm  
# End of macro DMARK
3158						CALLMONITOR 
3158 cd 73 18			call break_point_state  
315b				endm  
# End of macro CALLMONITOR
315b					endif 
315b			; eval TOS 
315b			 
315b				FORTH_DSP_VALUEHL 
315b cd de 20			call macro_dsp_valuehl 
315e				endm 
# End of macro FORTH_DSP_VALUEHL
315e			 
315e			;	push hl 
315e				FORTH_DSP_POP 
315e cd 96 21			call macro_forth_dsp_pop 
3161				endm 
# End of macro FORTH_DSP_POP
3161			;	pop hl 
3161			 
3161					if DEBUG_FORTH_WORDS 
3161						DMARK "IF1" 
3161 f5				push af  
3162 3a 76 31			ld a, (.dmark)  
3165 32 6e fe			ld (debug_mark),a  
3168 3a 77 31			ld a, (.dmark+1)  
316b 32 6f fe			ld (debug_mark+1),a  
316e 3a 78 31			ld a, (.dmark+2)  
3171 32 70 fe			ld (debug_mark+2),a  
3174 18 03			jr .pastdmark  
3176 ..			.dmark: db "IF1"  
3179 f1			.pastdmark: pop af  
317a			endm  
# End of macro DMARK
317a						CALLMONITOR 
317a cd 73 18			call break_point_state  
317d				endm  
# End of macro CALLMONITOR
317d					endif 
317d b7				or a        ; clear carry flag 
317e 11 00 00			ld de, 0 
3181 eb				ex de,hl 
3182 ed 52			sbc hl, de 
3184 c2 0e 32			jp nz, .iftrue 
3187			 
3187					if DEBUG_FORTH_WORDS 
3187						DMARK "IF2" 
3187 f5				push af  
3188 3a 9c 31			ld a, (.dmark)  
318b 32 6e fe			ld (debug_mark),a  
318e 3a 9d 31			ld a, (.dmark+1)  
3191 32 6f fe			ld (debug_mark+1),a  
3194 3a 9e 31			ld a, (.dmark+2)  
3197 32 70 fe			ld (debug_mark+2),a  
319a 18 03			jr .pastdmark  
319c ..			.dmark: db "IF2"  
319f f1			.pastdmark: pop af  
31a0			endm  
# End of macro DMARK
31a0						CALLMONITOR 
31a0 cd 73 18			call break_point_state  
31a3				endm  
# End of macro CALLMONITOR
31a3					endif 
31a3			 
31a3			; if not true then skip to THEN 
31a3			 
31a3				; TODO get tok_ptr 
31a3				; TODO consume toks until we get to THEN 
31a3			 
31a3 2a 00 f5			ld hl, (os_tok_ptr) 
31a6					if DEBUG_FORTH_WORDS 
31a6						DMARK "IF3" 
31a6 f5				push af  
31a7 3a bb 31			ld a, (.dmark)  
31aa 32 6e fe			ld (debug_mark),a  
31ad 3a bc 31			ld a, (.dmark+1)  
31b0 32 6f fe			ld (debug_mark+1),a  
31b3 3a bd 31			ld a, (.dmark+2)  
31b6 32 70 fe			ld (debug_mark+2),a  
31b9 18 03			jr .pastdmark  
31bb ..			.dmark: db "IF3"  
31be f1			.pastdmark: pop af  
31bf			endm  
# End of macro DMARK
31bf						CALLMONITOR 
31bf cd 73 18			call break_point_state  
31c2				endm  
# End of macro CALLMONITOR
31c2						 
31c2					endif 
31c2 11 09 32			ld de, .ifthen 
31c5					if DEBUG_FORTH_WORDS 
31c5						DMARK "IF4" 
31c5 f5				push af  
31c6 3a da 31			ld a, (.dmark)  
31c9 32 6e fe			ld (debug_mark),a  
31cc 3a db 31			ld a, (.dmark+1)  
31cf 32 6f fe			ld (debug_mark+1),a  
31d2 3a dc 31			ld a, (.dmark+2)  
31d5 32 70 fe			ld (debug_mark+2),a  
31d8 18 03			jr .pastdmark  
31da ..			.dmark: db "IF4"  
31dd f1			.pastdmark: pop af  
31de			endm  
# End of macro DMARK
31de						CALLMONITOR 
31de cd 73 18			call break_point_state  
31e1				endm  
# End of macro CALLMONITOR
31e1					endif 
31e1 cd 70 23			call findnexttok  
31e4			 
31e4					if DEBUG_FORTH_WORDS 
31e4						DMARK "IF5" 
31e4 f5				push af  
31e5 3a f9 31			ld a, (.dmark)  
31e8 32 6e fe			ld (debug_mark),a  
31eb 3a fa 31			ld a, (.dmark+1)  
31ee 32 6f fe			ld (debug_mark+1),a  
31f1 3a fb 31			ld a, (.dmark+2)  
31f4 32 70 fe			ld (debug_mark+2),a  
31f7 18 03			jr .pastdmark  
31f9 ..			.dmark: db "IF5"  
31fc f1			.pastdmark: pop af  
31fd			endm  
# End of macro DMARK
31fd						CALLMONITOR 
31fd cd 73 18			call break_point_state  
3200				endm  
# End of macro CALLMONITOR
3200					endif 
3200				; TODO replace below with ; exec using tok_ptr 
3200 22 00 f5			ld (os_tok_ptr), hl 
3203 c3 e6 22			jp exec1 
3206				NEXTW 
3206 c3 55 22			jp macro_next 
3209				endm 
# End of macro NEXTW
3209			 
3209 .. 00		.ifthen:  db "THEN",0 
320e			 
320e			.iftrue:		 
320e				; Exec next words normally 
320e			 
320e				; if true then exec following IF as normal 
320e					if DEBUG_FORTH_WORDS 
320e						DMARK "IFT" 
320e f5				push af  
320f 3a 23 32			ld a, (.dmark)  
3212 32 6e fe			ld (debug_mark),a  
3215 3a 24 32			ld a, (.dmark+1)  
3218 32 6f fe			ld (debug_mark+1),a  
321b 3a 25 32			ld a, (.dmark+2)  
321e 32 70 fe			ld (debug_mark+2),a  
3221 18 03			jr .pastdmark  
3223 ..			.dmark: db "IFT"  
3226 f1			.pastdmark: pop af  
3227			endm  
# End of macro DMARK
3227						CALLMONITOR 
3227 cd 73 18			call break_point_state  
322a				endm  
# End of macro CALLMONITOR
322a					endif 
322a			 
322a					NEXTW 
322a c3 55 22			jp macro_next 
322d				endm 
# End of macro NEXTW
322d			.THEN: 
322d				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
322d 1f				db WORD_SYS_CORE+11             
322e 55 32			dw .ELSE            
3230 05				db 4 + 1 
3231 .. 00			db "THEN",0              
3236				endm 
# End of macro CWHEAD
3236			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3236					if DEBUG_FORTH_WORDS_KEY 
3236						DMARK "THN" 
3236 f5				push af  
3237 3a 4b 32			ld a, (.dmark)  
323a 32 6e fe			ld (debug_mark),a  
323d 3a 4c 32			ld a, (.dmark+1)  
3240 32 6f fe			ld (debug_mark+1),a  
3243 3a 4d 32			ld a, (.dmark+2)  
3246 32 70 fe			ld (debug_mark+2),a  
3249 18 03			jr .pastdmark  
324b ..			.dmark: db "THN"  
324e f1			.pastdmark: pop af  
324f			endm  
# End of macro DMARK
324f						CALLMONITOR 
324f cd 73 18			call break_point_state  
3252				endm  
# End of macro CALLMONITOR
3252					endif 
3252					NEXTW 
3252 c3 55 22			jp macro_next 
3255				endm 
# End of macro NEXTW
3255			.ELSE: 
3255				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3255 20				db WORD_SYS_CORE+12             
3256 7d 32			dw .DO            
3258 03				db 2 + 1 
3259 .. 00			db "ELSE",0              
325e				endm 
# End of macro CWHEAD
325e			; | ELSE ( -- ) Not supported - does nothing | TODO 
325e			 
325e					if DEBUG_FORTH_WORDS_KEY 
325e						DMARK "ELS" 
325e f5				push af  
325f 3a 73 32			ld a, (.dmark)  
3262 32 6e fe			ld (debug_mark),a  
3265 3a 74 32			ld a, (.dmark+1)  
3268 32 6f fe			ld (debug_mark+1),a  
326b 3a 75 32			ld a, (.dmark+2)  
326e 32 70 fe			ld (debug_mark+2),a  
3271 18 03			jr .pastdmark  
3273 ..			.dmark: db "ELS"  
3276 f1			.pastdmark: pop af  
3277			endm  
# End of macro DMARK
3277						CALLMONITOR 
3277 cd 73 18			call break_point_state  
327a				endm  
# End of macro CALLMONITOR
327a					endif 
327a			 
327a			 
327a					NEXTW 
327a c3 55 22			jp macro_next 
327d				endm 
# End of macro NEXTW
327d			.DO: 
327d				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
327d 21				db WORD_SYS_CORE+13             
327e a4 33			dw .LOOP            
3280 03				db 2 + 1 
3281 .. 00			db "DO",0              
3284				endm 
# End of macro CWHEAD
3284			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3284			 
3284					if DEBUG_FORTH_WORDS_KEY 
3284						DMARK "DO." 
3284 f5				push af  
3285 3a 99 32			ld a, (.dmark)  
3288 32 6e fe			ld (debug_mark),a  
328b 3a 9a 32			ld a, (.dmark+1)  
328e 32 6f fe			ld (debug_mark+1),a  
3291 3a 9b 32			ld a, (.dmark+2)  
3294 32 70 fe			ld (debug_mark+2),a  
3297 18 03			jr .pastdmark  
3299 ..			.dmark: db "DO."  
329c f1			.pastdmark: pop af  
329d			endm  
# End of macro DMARK
329d						CALLMONITOR 
329d cd 73 18			call break_point_state  
32a0				endm  
# End of macro CALLMONITOR
32a0					endif 
32a0			;  push pc to rsp stack past the DO 
32a0			 
32a0 2a 00 f5				ld hl, (os_tok_ptr) 
32a3 23					inc hl   ; D 
32a4 23					inc hl  ; O 
32a5 23					inc hl   ; null 
32a6					if DEBUG_FORTH_WORDS 
32a6						DMARK "DO2" 
32a6 f5				push af  
32a7 3a bb 32			ld a, (.dmark)  
32aa 32 6e fe			ld (debug_mark),a  
32ad 3a bc 32			ld a, (.dmark+1)  
32b0 32 6f fe			ld (debug_mark+1),a  
32b3 3a bd 32			ld a, (.dmark+2)  
32b6 32 70 fe			ld (debug_mark+2),a  
32b9 18 03			jr .pastdmark  
32bb ..			.dmark: db "DO2"  
32be f1			.pastdmark: pop af  
32bf			endm  
# End of macro DMARK
32bf						CALLMONITOR 
32bf cd 73 18			call break_point_state  
32c2				endm  
# End of macro CALLMONITOR
32c2					endif 
32c2					FORTH_RSP_NEXT 
32c2 cd 8e 1e			call macro_forth_rsp_next 
32c5				endm 
# End of macro FORTH_RSP_NEXT
32c5					if DEBUG_FORTH_WORDS 
32c5						DMARK "DO3" 
32c5 f5				push af  
32c6 3a da 32			ld a, (.dmark)  
32c9 32 6e fe			ld (debug_mark),a  
32cc 3a db 32			ld a, (.dmark+1)  
32cf 32 6f fe			ld (debug_mark+1),a  
32d2 3a dc 32			ld a, (.dmark+2)  
32d5 32 70 fe			ld (debug_mark+2),a  
32d8 18 03			jr .pastdmark  
32da ..			.dmark: db "DO3"  
32dd f1			.pastdmark: pop af  
32de			endm  
# End of macro DMARK
32de						CALLMONITOR 
32de cd 73 18			call break_point_state  
32e1				endm  
# End of macro CALLMONITOR
32e1					endif 
32e1			 
32e1					;if DEBUG_FORTH_WORDS 
32e1				;		push hl 
32e1			;		endif  
32e1			 
32e1			; get counters from data stack 
32e1			 
32e1			 
32e1					FORTH_DSP_VALUEHL 
32e1 cd de 20			call macro_dsp_valuehl 
32e4				endm 
# End of macro FORTH_DSP_VALUEHL
32e4 e5					push hl		 ; hl now has starting counter which needs to be tos 
32e5			 
32e5					if DEBUG_FORTH_WORDS 
32e5						DMARK "DO4" 
32e5 f5				push af  
32e6 3a fa 32			ld a, (.dmark)  
32e9 32 6e fe			ld (debug_mark),a  
32ec 3a fb 32			ld a, (.dmark+1)  
32ef 32 6f fe			ld (debug_mark+1),a  
32f2 3a fc 32			ld a, (.dmark+2)  
32f5 32 70 fe			ld (debug_mark+2),a  
32f8 18 03			jr .pastdmark  
32fa ..			.dmark: db "DO4"  
32fd f1			.pastdmark: pop af  
32fe			endm  
# End of macro DMARK
32fe						CALLMONITOR 
32fe cd 73 18			call break_point_state  
3301				endm  
# End of macro CALLMONITOR
3301					endif 
3301					FORTH_DSP_POP 
3301 cd 96 21			call macro_forth_dsp_pop 
3304				endm 
# End of macro FORTH_DSP_POP
3304			 
3304					if DEBUG_FORTH_WORDS 
3304						DMARK "DO5" 
3304 f5				push af  
3305 3a 19 33			ld a, (.dmark)  
3308 32 6e fe			ld (debug_mark),a  
330b 3a 1a 33			ld a, (.dmark+1)  
330e 32 6f fe			ld (debug_mark+1),a  
3311 3a 1b 33			ld a, (.dmark+2)  
3314 32 70 fe			ld (debug_mark+2),a  
3317 18 03			jr .pastdmark  
3319 ..			.dmark: db "DO5"  
331c f1			.pastdmark: pop af  
331d			endm  
# End of macro DMARK
331d						CALLMONITOR 
331d cd 73 18			call break_point_state  
3320				endm  
# End of macro CALLMONITOR
3320					endif 
3320			 
3320					FORTH_DSP_VALUEHL 
3320 cd de 20			call macro_dsp_valuehl 
3323				endm 
# End of macro FORTH_DSP_VALUEHL
3323			;		push hl		 ; hl now has starting limit counter 
3323			 
3323					if DEBUG_FORTH_WORDS 
3323						DMARK "DO6" 
3323 f5				push af  
3324 3a 38 33			ld a, (.dmark)  
3327 32 6e fe			ld (debug_mark),a  
332a 3a 39 33			ld a, (.dmark+1)  
332d 32 6f fe			ld (debug_mark+1),a  
3330 3a 3a 33			ld a, (.dmark+2)  
3333 32 70 fe			ld (debug_mark+2),a  
3336 18 03			jr .pastdmark  
3338 ..			.dmark: db "DO6"  
333b f1			.pastdmark: pop af  
333c			endm  
# End of macro DMARK
333c						CALLMONITOR 
333c cd 73 18			call break_point_state  
333f				endm  
# End of macro CALLMONITOR
333f					endif 
333f					FORTH_DSP_POP 
333f cd 96 21			call macro_forth_dsp_pop 
3342				endm 
# End of macro FORTH_DSP_POP
3342			 
3342			; put counters on the loop stack 
3342			 
3342			;		pop hl			 ; limit counter 
3342 d1					pop de			; start counter 
3343			 
3343					; push limit counter 
3343			 
3343					if DEBUG_FORTH_WORDS 
3343						DMARK "DO7" 
3343 f5				push af  
3344 3a 58 33			ld a, (.dmark)  
3347 32 6e fe			ld (debug_mark),a  
334a 3a 59 33			ld a, (.dmark+1)  
334d 32 6f fe			ld (debug_mark+1),a  
3350 3a 5a 33			ld a, (.dmark+2)  
3353 32 70 fe			ld (debug_mark+2),a  
3356 18 03			jr .pastdmark  
3358 ..			.dmark: db "DO7"  
335b f1			.pastdmark: pop af  
335c			endm  
# End of macro DMARK
335c						CALLMONITOR 
335c cd 73 18			call break_point_state  
335f				endm  
# End of macro CALLMONITOR
335f					endif 
335f					FORTH_LOOP_NEXT 
335f cd 0f 21			call macro_forth_loop_next 
3362				endm 
# End of macro FORTH_LOOP_NEXT
3362			 
3362					; push start counter 
3362			 
3362 eb					ex de, hl 
3363					if DEBUG_FORTH_WORDS 
3363						DMARK "DO7" 
3363 f5				push af  
3364 3a 78 33			ld a, (.dmark)  
3367 32 6e fe			ld (debug_mark),a  
336a 3a 79 33			ld a, (.dmark+1)  
336d 32 6f fe			ld (debug_mark+1),a  
3370 3a 7a 33			ld a, (.dmark+2)  
3373 32 70 fe			ld (debug_mark+2),a  
3376 18 03			jr .pastdmark  
3378 ..			.dmark: db "DO7"  
337b f1			.pastdmark: pop af  
337c			endm  
# End of macro DMARK
337c						CALLMONITOR 
337c cd 73 18			call break_point_state  
337f				endm  
# End of macro CALLMONITOR
337f					endif 
337f					FORTH_LOOP_NEXT 
337f cd 0f 21			call macro_forth_loop_next 
3382				endm 
# End of macro FORTH_LOOP_NEXT
3382			 
3382			 
3382					; init first round of I counter 
3382			 
3382 22 24 f5				ld (os_current_i), hl 
3385			 
3385					if DEBUG_FORTH_WORDS 
3385						DMARK "DO8" 
3385 f5				push af  
3386 3a 9a 33			ld a, (.dmark)  
3389 32 6e fe			ld (debug_mark),a  
338c 3a 9b 33			ld a, (.dmark+1)  
338f 32 6f fe			ld (debug_mark+1),a  
3392 3a 9c 33			ld a, (.dmark+2)  
3395 32 70 fe			ld (debug_mark+2),a  
3398 18 03			jr .pastdmark  
339a ..			.dmark: db "DO8"  
339d f1			.pastdmark: pop af  
339e			endm  
# End of macro DMARK
339e						CALLMONITOR 
339e cd 73 18			call break_point_state  
33a1				endm  
# End of macro CALLMONITOR
33a1					endif 
33a1			 
33a1					NEXTW 
33a1 c3 55 22			jp macro_next 
33a4				endm 
# End of macro NEXTW
33a4			.LOOP: 
33a4				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
33a4 22				db WORD_SYS_CORE+14             
33a5 bc 34			dw .I            
33a7 05				db 4 + 1 
33a8 .. 00			db "LOOP",0              
33ad				endm 
# End of macro CWHEAD
33ad			; | LOOP ( -- ) Increment and test loop counter  | DONE 
33ad			 
33ad				; pop tos as current loop count to hl 
33ad			 
33ad				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33ad			 
33ad				FORTH_LOOP_TOS 
33ad cd 42 21			call macro_forth_loop_tos 
33b0				endm 
# End of macro FORTH_LOOP_TOS
33b0 e5				push hl 
33b1			 
33b1					if DEBUG_FORTH_WORDS_KEY 
33b1						DMARK "LOP" 
33b1 f5				push af  
33b2 3a c6 33			ld a, (.dmark)  
33b5 32 6e fe			ld (debug_mark),a  
33b8 3a c7 33			ld a, (.dmark+1)  
33bb 32 6f fe			ld (debug_mark+1),a  
33be 3a c8 33			ld a, (.dmark+2)  
33c1 32 70 fe			ld (debug_mark+2),a  
33c4 18 03			jr .pastdmark  
33c6 ..			.dmark: db "LOP"  
33c9 f1			.pastdmark: pop af  
33ca			endm  
# End of macro DMARK
33ca						CALLMONITOR 
33ca cd 73 18			call break_point_state  
33cd				endm  
# End of macro CALLMONITOR
33cd					endif 
33cd				; next item on the stack is the limit. get it 
33cd			 
33cd			 
33cd				FORTH_LOOP_POP 
33cd cd 4c 21			call macro_forth_loop_pop 
33d0				endm 
# End of macro FORTH_LOOP_POP
33d0			 
33d0				FORTH_LOOP_TOS 
33d0 cd 42 21			call macro_forth_loop_tos 
33d3				endm 
# End of macro FORTH_LOOP_TOS
33d3			 
33d3 d1				pop de		 ; de = i, hl = limit 
33d4			 
33d4					if DEBUG_FORTH_WORDS 
33d4						DMARK "LP1" 
33d4 f5				push af  
33d5 3a e9 33			ld a, (.dmark)  
33d8 32 6e fe			ld (debug_mark),a  
33db 3a ea 33			ld a, (.dmark+1)  
33de 32 6f fe			ld (debug_mark+1),a  
33e1 3a eb 33			ld a, (.dmark+2)  
33e4 32 70 fe			ld (debug_mark+2),a  
33e7 18 03			jr .pastdmark  
33e9 ..			.dmark: db "LP1"  
33ec f1			.pastdmark: pop af  
33ed			endm  
# End of macro DMARK
33ed						CALLMONITOR 
33ed cd 73 18			call break_point_state  
33f0				endm  
# End of macro CALLMONITOR
33f0					endif 
33f0			 
33f0				; go back to previous word 
33f0			 
33f0 d5				push de    ; save I for inc later 
33f1			 
33f1			 
33f1				; get limit 
33f1				;  is I at limit? 
33f1			 
33f1			 
33f1					if DEBUG_FORTH_WORDS 
33f1						DMARK "LP1" 
33f1 f5				push af  
33f2 3a 06 34			ld a, (.dmark)  
33f5 32 6e fe			ld (debug_mark),a  
33f8 3a 07 34			ld a, (.dmark+1)  
33fb 32 6f fe			ld (debug_mark+1),a  
33fe 3a 08 34			ld a, (.dmark+2)  
3401 32 70 fe			ld (debug_mark+2),a  
3404 18 03			jr .pastdmark  
3406 ..			.dmark: db "LP1"  
3409 f1			.pastdmark: pop af  
340a			endm  
# End of macro DMARK
340a						CALLMONITOR 
340a cd 73 18			call break_point_state  
340d				endm  
# End of macro CALLMONITOR
340d					endif 
340d			 
340d ed 52			sbc hl, de 
340f			 
340f			 
340f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
340f			 
340f 20 26				jr nz, .loopnotdone 
3411			 
3411 e1				pop hl   ; get rid of saved I 
3412				FORTH_LOOP_POP     ; get rid of limit 
3412 cd 4c 21			call macro_forth_loop_pop 
3415				endm 
# End of macro FORTH_LOOP_POP
3415			 
3415				FORTH_RSP_POP     ; get rid of DO ptr 
3415 cd af 1e			call macro_forth_rsp_pop 
3418				endm 
# End of macro FORTH_RSP_POP
3418			 
3418			if DEBUG_FORTH_WORDS 
3418						DMARK "LP>" 
3418 f5				push af  
3419 3a 2d 34			ld a, (.dmark)  
341c 32 6e fe			ld (debug_mark),a  
341f 3a 2e 34			ld a, (.dmark+1)  
3422 32 6f fe			ld (debug_mark+1),a  
3425 3a 2f 34			ld a, (.dmark+2)  
3428 32 70 fe			ld (debug_mark+2),a  
342b 18 03			jr .pastdmark  
342d ..			.dmark: db "LP>"  
3430 f1			.pastdmark: pop af  
3431			endm  
# End of macro DMARK
3431				CALLMONITOR 
3431 cd 73 18			call break_point_state  
3434				endm  
# End of macro CALLMONITOR
3434			endif 
3434			 
3434					NEXTW 
3434 c3 55 22			jp macro_next 
3437				endm 
# End of macro NEXTW
3437				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3437			 
3437			.loopnotdone: 
3437			 
3437 e1				pop hl    ; get I 
3438 23				inc hl 
3439			 
3439			   	; save new I 
3439			 
3439			 
3439					; set I counter 
3439			 
3439 22 24 f5				ld (os_current_i), hl 
343c			 
343c					if DEBUG_FORTH_WORDS 
343c						DMARK "LPN" 
343c f5				push af  
343d 3a 51 34			ld a, (.dmark)  
3440 32 6e fe			ld (debug_mark),a  
3443 3a 52 34			ld a, (.dmark+1)  
3446 32 6f fe			ld (debug_mark+1),a  
3449 3a 53 34			ld a, (.dmark+2)  
344c 32 70 fe			ld (debug_mark+2),a  
344f 18 03			jr .pastdmark  
3451 ..			.dmark: db "LPN"  
3454 f1			.pastdmark: pop af  
3455			endm  
# End of macro DMARK
3455					CALLMONITOR 
3455 cd 73 18			call break_point_state  
3458				endm  
# End of macro CALLMONITOR
3458					endif 
3458					 
3458				FORTH_LOOP_NEXT 
3458 cd 0f 21			call macro_forth_loop_next 
345b				endm 
# End of macro FORTH_LOOP_NEXT
345b			 
345b			 
345b					if DEBUG_FORTH_WORDS 
345b eb						ex de,hl 
345c					endif 
345c			 
345c			;	; get DO ptr 
345c			; 
345c					if DEBUG_FORTH_WORDS 
345c						DMARK "LP7" 
345c f5				push af  
345d 3a 71 34			ld a, (.dmark)  
3460 32 6e fe			ld (debug_mark),a  
3463 3a 72 34			ld a, (.dmark+1)  
3466 32 6f fe			ld (debug_mark+1),a  
3469 3a 73 34			ld a, (.dmark+2)  
346c 32 70 fe			ld (debug_mark+2),a  
346f 18 03			jr .pastdmark  
3471 ..			.dmark: db "LP7"  
3474 f1			.pastdmark: pop af  
3475			endm  
# End of macro DMARK
3475					CALLMONITOR 
3475 cd 73 18			call break_point_state  
3478				endm  
# End of macro CALLMONITOR
3478					endif 
3478				FORTH_RSP_TOS 
3478 cd a5 1e			call macro_forth_rsp_tos 
347b				endm 
# End of macro FORTH_RSP_TOS
347b			 
347b					if DEBUG_FORTH_WORDS 
347b						DMARK "LP8" 
347b f5				push af  
347c 3a 90 34			ld a, (.dmark)  
347f 32 6e fe			ld (debug_mark),a  
3482 3a 91 34			ld a, (.dmark+1)  
3485 32 6f fe			ld (debug_mark+1),a  
3488 3a 92 34			ld a, (.dmark+2)  
348b 32 70 fe			ld (debug_mark+2),a  
348e 18 03			jr .pastdmark  
3490 ..			.dmark: db "LP8"  
3493 f1			.pastdmark: pop af  
3494			endm  
# End of macro DMARK
3494					CALLMONITOR 
3494 cd 73 18			call break_point_state  
3497				endm  
# End of macro CALLMONITOR
3497					endif 
3497				;push hl 
3497			 
3497				; not going to DO any more 
3497				; get rid of the RSP pointer as DO will add it back in 
3497				;FORTH_RSP_POP 
3497				;pop hl 
3497			 
3497				;ld hl,(cli_ret_sp) 
3497				;ld e, (hl) 
3497				;inc hl 
3497				;ld d, (hl) 
3497				;ex de,hl 
3497 22 00 f5			ld (os_tok_ptr), hl 
349a					if DEBUG_FORTH_WORDS 
349a						DMARK "LP<" 
349a f5				push af  
349b 3a af 34			ld a, (.dmark)  
349e 32 6e fe			ld (debug_mark),a  
34a1 3a b0 34			ld a, (.dmark+1)  
34a4 32 6f fe			ld (debug_mark+1),a  
34a7 3a b1 34			ld a, (.dmark+2)  
34aa 32 70 fe			ld (debug_mark+2),a  
34ad 18 03			jr .pastdmark  
34af ..			.dmark: db "LP<"  
34b2 f1			.pastdmark: pop af  
34b3			endm  
# End of macro DMARK
34b3					CALLMONITOR 
34b3 cd 73 18			call break_point_state  
34b6				endm  
# End of macro CALLMONITOR
34b6				endif 
34b6 c3 e6 22			jp exec1 
34b9			 
34b9					 
34b9			 
34b9			 
34b9					NEXTW 
34b9 c3 55 22			jp macro_next 
34bc				endm 
# End of macro NEXTW
34bc			.I:  
34bc			 
34bc				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
34bc 5e				db WORD_SYS_CORE+74             
34bd e7 34			dw .DLOOP            
34bf 02				db 1 + 1 
34c0 .. 00			db "I",0              
34c2				endm 
# End of macro CWHEAD
34c2			; | I ( -- ) Current loop counter | DONE 
34c2					if DEBUG_FORTH_WORDS_KEY 
34c2						DMARK "I.." 
34c2 f5				push af  
34c3 3a d7 34			ld a, (.dmark)  
34c6 32 6e fe			ld (debug_mark),a  
34c9 3a d8 34			ld a, (.dmark+1)  
34cc 32 6f fe			ld (debug_mark+1),a  
34cf 3a d9 34			ld a, (.dmark+2)  
34d2 32 70 fe			ld (debug_mark+2),a  
34d5 18 03			jr .pastdmark  
34d7 ..			.dmark: db "I.."  
34da f1			.pastdmark: pop af  
34db			endm  
# End of macro DMARK
34db						CALLMONITOR 
34db cd 73 18			call break_point_state  
34de				endm  
# End of macro CALLMONITOR
34de					endif 
34de			 
34de 2a 24 f5				ld hl,(os_current_i) 
34e1 cd e7 1e				call forth_push_numhl 
34e4			 
34e4					NEXTW 
34e4 c3 55 22			jp macro_next 
34e7				endm 
# End of macro NEXTW
34e7			.DLOOP: 
34e7				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
34e7 5f				db WORD_SYS_CORE+75             
34e8 c8 35			dw .REPEAT            
34ea 06				db 5 + 1 
34eb .. 00			db "-LOOP",0              
34f1				endm 
# End of macro CWHEAD
34f1			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
34f1				; pop tos as current loop count to hl 
34f1					if DEBUG_FORTH_WORDS_KEY 
34f1						DMARK "-LP" 
34f1 f5				push af  
34f2 3a 06 35			ld a, (.dmark)  
34f5 32 6e fe			ld (debug_mark),a  
34f8 3a 07 35			ld a, (.dmark+1)  
34fb 32 6f fe			ld (debug_mark+1),a  
34fe 3a 08 35			ld a, (.dmark+2)  
3501 32 70 fe			ld (debug_mark+2),a  
3504 18 03			jr .pastdmark  
3506 ..			.dmark: db "-LP"  
3509 f1			.pastdmark: pop af  
350a			endm  
# End of macro DMARK
350a						CALLMONITOR 
350a cd 73 18			call break_point_state  
350d				endm  
# End of macro CALLMONITOR
350d					endif 
350d			 
350d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
350d			 
350d				FORTH_LOOP_TOS 
350d cd 42 21			call macro_forth_loop_tos 
3510				endm 
# End of macro FORTH_LOOP_TOS
3510 e5				push hl 
3511			 
3511					if DEBUG_FORTH_WORDS 
3511						DMARK "-LP" 
3511 f5				push af  
3512 3a 26 35			ld a, (.dmark)  
3515 32 6e fe			ld (debug_mark),a  
3518 3a 27 35			ld a, (.dmark+1)  
351b 32 6f fe			ld (debug_mark+1),a  
351e 3a 28 35			ld a, (.dmark+2)  
3521 32 70 fe			ld (debug_mark+2),a  
3524 18 03			jr .pastdmark  
3526 ..			.dmark: db "-LP"  
3529 f1			.pastdmark: pop af  
352a			endm  
# End of macro DMARK
352a						CALLMONITOR 
352a cd 73 18			call break_point_state  
352d				endm  
# End of macro CALLMONITOR
352d					endif 
352d				; next item on the stack is the limit. get it 
352d			 
352d			 
352d				FORTH_LOOP_POP 
352d cd 4c 21			call macro_forth_loop_pop 
3530				endm 
# End of macro FORTH_LOOP_POP
3530			 
3530				FORTH_LOOP_TOS 
3530 cd 42 21			call macro_forth_loop_tos 
3533				endm 
# End of macro FORTH_LOOP_TOS
3533			 
3533 d1				pop de		 ; de = i, hl = limit 
3534			 
3534					if DEBUG_FORTH_WORDS 
3534						DMARK "-L1" 
3534 f5				push af  
3535 3a 49 35			ld a, (.dmark)  
3538 32 6e fe			ld (debug_mark),a  
353b 3a 4a 35			ld a, (.dmark+1)  
353e 32 6f fe			ld (debug_mark+1),a  
3541 3a 4b 35			ld a, (.dmark+2)  
3544 32 70 fe			ld (debug_mark+2),a  
3547 18 03			jr .pastdmark  
3549 ..			.dmark: db "-L1"  
354c f1			.pastdmark: pop af  
354d			endm  
# End of macro DMARK
354d						CALLMONITOR 
354d cd 73 18			call break_point_state  
3550				endm  
# End of macro CALLMONITOR
3550					endif 
3550			 
3550				; go back to previous word 
3550			 
3550 d5				push de    ; save I for inc later 
3551			 
3551			 
3551				; get limit 
3551				;  is I at limit? 
3551			 
3551			 
3551					if DEBUG_FORTH_WORDS 
3551						DMARK "-L1" 
3551 f5				push af  
3552 3a 66 35			ld a, (.dmark)  
3555 32 6e fe			ld (debug_mark),a  
3558 3a 67 35			ld a, (.dmark+1)  
355b 32 6f fe			ld (debug_mark+1),a  
355e 3a 68 35			ld a, (.dmark+2)  
3561 32 70 fe			ld (debug_mark+2),a  
3564 18 03			jr .pastdmark  
3566 ..			.dmark: db "-L1"  
3569 f1			.pastdmark: pop af  
356a			endm  
# End of macro DMARK
356a						CALLMONITOR 
356a cd 73 18			call break_point_state  
356d				endm  
# End of macro CALLMONITOR
356d					endif 
356d			 
356d ed 52			sbc hl, de 
356f			 
356f			 
356f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
356f			 
356f 20 26				jr nz, .mloopnotdone 
3571			 
3571 e1				pop hl   ; get rid of saved I 
3572				FORTH_LOOP_POP     ; get rid of limit 
3572 cd 4c 21			call macro_forth_loop_pop 
3575				endm 
# End of macro FORTH_LOOP_POP
3575			 
3575				FORTH_RSP_POP     ; get rid of DO ptr 
3575 cd af 1e			call macro_forth_rsp_pop 
3578				endm 
# End of macro FORTH_RSP_POP
3578			 
3578			if DEBUG_FORTH_WORDS 
3578						DMARK "-L>" 
3578 f5				push af  
3579 3a 8d 35			ld a, (.dmark)  
357c 32 6e fe			ld (debug_mark),a  
357f 3a 8e 35			ld a, (.dmark+1)  
3582 32 6f fe			ld (debug_mark+1),a  
3585 3a 8f 35			ld a, (.dmark+2)  
3588 32 70 fe			ld (debug_mark+2),a  
358b 18 03			jr .pastdmark  
358d ..			.dmark: db "-L>"  
3590 f1			.pastdmark: pop af  
3591			endm  
# End of macro DMARK
3591				CALLMONITOR 
3591 cd 73 18			call break_point_state  
3594				endm  
# End of macro CALLMONITOR
3594			endif 
3594			 
3594					NEXTW 
3594 c3 55 22			jp macro_next 
3597				endm 
# End of macro NEXTW
3597				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3597			 
3597			.mloopnotdone: 
3597			 
3597 e1				pop hl    ; get I 
3598 2b				dec hl 
3599			 
3599			   	; save new I 
3599			 
3599			 
3599					; set I counter 
3599			 
3599 22 24 f5				ld (os_current_i), hl 
359c			 
359c					 
359c				FORTH_LOOP_NEXT 
359c cd 0f 21			call macro_forth_loop_next 
359f				endm 
# End of macro FORTH_LOOP_NEXT
359f			 
359f			 
359f					if DEBUG_FORTH_WORDS 
359f eb						ex de,hl 
35a0					endif 
35a0			 
35a0			;	; get DO ptr 
35a0			; 
35a0				FORTH_RSP_TOS 
35a0 cd a5 1e			call macro_forth_rsp_tos 
35a3				endm 
# End of macro FORTH_RSP_TOS
35a3			 
35a3				;push hl 
35a3			 
35a3				; not going to DO any more 
35a3				; get rid of the RSP pointer as DO will add it back in 
35a3				;FORTH_RSP_POP 
35a3				;pop hl 
35a3			 
35a3			 
35a3 22 00 f5			ld (os_tok_ptr), hl 
35a6					if DEBUG_FORTH_WORDS 
35a6						DMARK "-L<" 
35a6 f5				push af  
35a7 3a bb 35			ld a, (.dmark)  
35aa 32 6e fe			ld (debug_mark),a  
35ad 3a bc 35			ld a, (.dmark+1)  
35b0 32 6f fe			ld (debug_mark+1),a  
35b3 3a bd 35			ld a, (.dmark+2)  
35b6 32 70 fe			ld (debug_mark+2),a  
35b9 18 03			jr .pastdmark  
35bb ..			.dmark: db "-L<"  
35be f1			.pastdmark: pop af  
35bf			endm  
# End of macro DMARK
35bf					CALLMONITOR 
35bf cd 73 18			call break_point_state  
35c2				endm  
# End of macro CALLMONITOR
35c2				endif 
35c2 c3 e6 22			jp exec1 
35c5			 
35c5					 
35c5			 
35c5			 
35c5			 
35c5				NEXTW 
35c5 c3 55 22			jp macro_next 
35c8				endm 
# End of macro NEXTW
35c8			 
35c8			 
35c8			 
35c8			 
35c8			.REPEAT: 
35c8				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
35c8 71				db WORD_SYS_CORE+93             
35c9 1b 36			dw .UNTIL            
35cb 06				db 5 + 1 
35cc .. 00			db "REPEAT",0              
35d3				endm 
# End of macro CWHEAD
35d3			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
35d3			;  push pc to rsp stack past the REPEAT 
35d3					if DEBUG_FORTH_WORDS_KEY 
35d3						DMARK "REP" 
35d3 f5				push af  
35d4 3a e8 35			ld a, (.dmark)  
35d7 32 6e fe			ld (debug_mark),a  
35da 3a e9 35			ld a, (.dmark+1)  
35dd 32 6f fe			ld (debug_mark+1),a  
35e0 3a ea 35			ld a, (.dmark+2)  
35e3 32 70 fe			ld (debug_mark+2),a  
35e6 18 03			jr .pastdmark  
35e8 ..			.dmark: db "REP"  
35eb f1			.pastdmark: pop af  
35ec			endm  
# End of macro DMARK
35ec						CALLMONITOR 
35ec cd 73 18			call break_point_state  
35ef				endm  
# End of macro CALLMONITOR
35ef					endif 
35ef			 
35ef 2a 00 f5				ld hl, (os_tok_ptr) 
35f2 23					inc hl   ; R 
35f3 23					inc hl  ; E 
35f4 23					inc hl   ; P 
35f5 23					inc hl   ; E 
35f6 23					inc hl   ; A 
35f7 23					inc hl   ; T 
35f8 23					inc hl   ; zero 
35f9					FORTH_RSP_NEXT 
35f9 cd 8e 1e			call macro_forth_rsp_next 
35fc				endm 
# End of macro FORTH_RSP_NEXT
35fc			 
35fc			 
35fc					if DEBUG_FORTH_WORDS 
35fc						DMARK "REP" 
35fc f5				push af  
35fd 3a 11 36			ld a, (.dmark)  
3600 32 6e fe			ld (debug_mark),a  
3603 3a 12 36			ld a, (.dmark+1)  
3606 32 6f fe			ld (debug_mark+1),a  
3609 3a 13 36			ld a, (.dmark+2)  
360c 32 70 fe			ld (debug_mark+2),a  
360f 18 03			jr .pastdmark  
3611 ..			.dmark: db "REP"  
3614 f1			.pastdmark: pop af  
3615			endm  
# End of macro DMARK
3615						;pop bc    ; TODO BUG ?????? what is this for???? 
3615						CALLMONITOR 
3615 cd 73 18			call break_point_state  
3618				endm  
# End of macro CALLMONITOR
3618					endif 
3618			 
3618					NEXTW 
3618 c3 55 22			jp macro_next 
361b				endm 
# End of macro NEXTW
361b			;	       NEXTW 
361b			 
361b			.UNTIL: 
361b				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
361b 72				db WORD_SYS_CORE+94             
361c b2 36			dw .ENDFLOW            
361e 06				db 5 + 1 
361f .. 00			db "UNTIL",0              
3625				endm 
# End of macro CWHEAD
3625			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3625			 
3625				; pop tos as check 
3625			 
3625				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3625			 
3625				FORTH_DSP_VALUEHL 
3625 cd de 20			call macro_dsp_valuehl 
3628				endm 
# End of macro FORTH_DSP_VALUEHL
3628			 
3628					if DEBUG_FORTH_WORDS_KEY 
3628						DMARK "UNT" 
3628 f5				push af  
3629 3a 3d 36			ld a, (.dmark)  
362c 32 6e fe			ld (debug_mark),a  
362f 3a 3e 36			ld a, (.dmark+1)  
3632 32 6f fe			ld (debug_mark+1),a  
3635 3a 3f 36			ld a, (.dmark+2)  
3638 32 70 fe			ld (debug_mark+2),a  
363b 18 03			jr .pastdmark  
363d ..			.dmark: db "UNT"  
3640 f1			.pastdmark: pop af  
3641			endm  
# End of macro DMARK
3641						CALLMONITOR 
3641 cd 73 18			call break_point_state  
3644				endm  
# End of macro CALLMONITOR
3644					endif 
3644			 
3644			;	push hl 
3644				FORTH_DSP_POP 
3644 cd 96 21			call macro_forth_dsp_pop 
3647				endm 
# End of macro FORTH_DSP_POP
3647			 
3647			;	pop hl 
3647			 
3647				; test if true 
3647			 
3647 cd f5 0e			call ishlzero 
364a			;	ld a,l 
364a			;	add h 
364a			; 
364a			;	cp 0 
364a			 
364a 20 3e			jr nz, .untilnotdone 
364c			 
364c					if DEBUG_FORTH_WORDS 
364c						DMARK "UNf" 
364c f5				push af  
364d 3a 61 36			ld a, (.dmark)  
3650 32 6e fe			ld (debug_mark),a  
3653 3a 62 36			ld a, (.dmark+1)  
3656 32 6f fe			ld (debug_mark+1),a  
3659 3a 63 36			ld a, (.dmark+2)  
365c 32 70 fe			ld (debug_mark+2),a  
365f 18 03			jr .pastdmark  
3661 ..			.dmark: db "UNf"  
3664 f1			.pastdmark: pop af  
3665			endm  
# End of macro DMARK
3665						CALLMONITOR 
3665 cd 73 18			call break_point_state  
3668				endm  
# End of macro CALLMONITOR
3668					endif 
3668			 
3668			 
3668			 
3668				FORTH_RSP_POP     ; get rid of DO ptr 
3668 cd af 1e			call macro_forth_rsp_pop 
366b				endm 
# End of macro FORTH_RSP_POP
366b			 
366b			if DEBUG_FORTH_WORDS 
366b						DMARK "UN>" 
366b f5				push af  
366c 3a 80 36			ld a, (.dmark)  
366f 32 6e fe			ld (debug_mark),a  
3672 3a 81 36			ld a, (.dmark+1)  
3675 32 6f fe			ld (debug_mark+1),a  
3678 3a 82 36			ld a, (.dmark+2)  
367b 32 70 fe			ld (debug_mark+2),a  
367e 18 03			jr .pastdmark  
3680 ..			.dmark: db "UN>"  
3683 f1			.pastdmark: pop af  
3684			endm  
# End of macro DMARK
3684				CALLMONITOR 
3684 cd 73 18			call break_point_state  
3687				endm  
# End of macro CALLMONITOR
3687			endif 
3687			 
3687					NEXTW 
3687 c3 55 22			jp macro_next 
368a				endm 
# End of macro NEXTW
368a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
368a			 
368a			.untilnotdone: 
368a			 
368a			 
368a			;	; get DO ptr 
368a			; 
368a				FORTH_RSP_TOS 
368a cd a5 1e			call macro_forth_rsp_tos 
368d				endm 
# End of macro FORTH_RSP_TOS
368d			 
368d				;push hl 
368d			 
368d				; not going to DO any more 
368d				; get rid of the RSP pointer as DO will add it back in 
368d				;FORTH_RSP_POP 
368d				;pop hl 
368d			 
368d			 
368d 22 00 f5			ld (os_tok_ptr), hl 
3690					if DEBUG_FORTH_WORDS 
3690						DMARK "UN<" 
3690 f5				push af  
3691 3a a5 36			ld a, (.dmark)  
3694 32 6e fe			ld (debug_mark),a  
3697 3a a6 36			ld a, (.dmark+1)  
369a 32 6f fe			ld (debug_mark+1),a  
369d 3a a7 36			ld a, (.dmark+2)  
36a0 32 70 fe			ld (debug_mark+2),a  
36a3 18 03			jr .pastdmark  
36a5 ..			.dmark: db "UN<"  
36a8 f1			.pastdmark: pop af  
36a9			endm  
# End of macro DMARK
36a9					CALLMONITOR 
36a9 cd 73 18			call break_point_state  
36ac				endm  
# End of macro CALLMONITOR
36ac				endif 
36ac c3 e6 22			jp exec1 
36af			 
36af					 
36af			 
36af			 
36af					NEXTW 
36af c3 55 22			jp macro_next 
36b2				endm 
# End of macro NEXTW
36b2			 
36b2			 
36b2			.ENDFLOW: 
36b2			 
36b2			; eof 
36b2			 
# End of file forth_words_flow.asm
36b2			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
36b2			include "forth_words_logic.asm" 
36b2			 
36b2			; | ## Logic Words 
36b2			 
36b2			.NOT: 
36b2				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
36b2 2d				db WORD_SYS_CORE+25             
36b3 fa 36			dw .IS            
36b5 04				db 3 + 1 
36b6 .. 00			db "NOT",0              
36ba				endm 
# End of macro CWHEAD
36ba			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
36ba					if DEBUG_FORTH_WORDS_KEY 
36ba						DMARK "NOT" 
36ba f5				push af  
36bb 3a cf 36			ld a, (.dmark)  
36be 32 6e fe			ld (debug_mark),a  
36c1 3a d0 36			ld a, (.dmark+1)  
36c4 32 6f fe			ld (debug_mark+1),a  
36c7 3a d1 36			ld a, (.dmark+2)  
36ca 32 70 fe			ld (debug_mark+2),a  
36cd 18 03			jr .pastdmark  
36cf ..			.dmark: db "NOT"  
36d2 f1			.pastdmark: pop af  
36d3			endm  
# End of macro DMARK
36d3						CALLMONITOR 
36d3 cd 73 18			call break_point_state  
36d6				endm  
# End of macro CALLMONITOR
36d6					endif 
36d6					FORTH_DSP 
36d6 cd a4 20			call macro_forth_dsp 
36d9				endm 
# End of macro FORTH_DSP
36d9 7e					ld a,(hl)	; get type of value on TOS 
36da fe 02				cp DS_TYPE_INUM  
36dc 28 03				jr z, .noti 
36de					NEXTW 
36de c3 55 22			jp macro_next 
36e1				endm 
# End of macro NEXTW
36e1			.noti:          FORTH_DSP_VALUEHL 
36e1 cd de 20			call macro_dsp_valuehl 
36e4				endm 
# End of macro FORTH_DSP_VALUEHL
36e4			;		push hl 
36e4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36e4 cd 96 21			call macro_forth_dsp_pop 
36e7				endm 
# End of macro FORTH_DSP_POP
36e7			;		pop hl 
36e7 3e 00				ld a,0 
36e9 bd					cp l 
36ea 28 04				jr z, .not2t 
36ec 2e 00				ld l, 0 
36ee 18 02				jr .notip 
36f0			 
36f0 2e ff		.not2t:		ld l, 255 
36f2			 
36f2 26 00		.notip:		ld h, 0	 
36f4			 
36f4 cd e7 1e				call forth_push_numhl 
36f7					NEXTW 
36f7 c3 55 22			jp macro_next 
36fa				endm 
# End of macro NEXTW
36fa			 
36fa			.IS: 
36fa				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
36fa 2d				db WORD_SYS_CORE+25             
36fb 20 37			dw .LZERO            
36fd 03				db 2 + 1 
36fe .. 00			db "IS",0              
3701				endm 
# End of macro CWHEAD
3701			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3701					if DEBUG_FORTH_WORDS_KEY 
3701						DMARK "IS." 
3701 f5				push af  
3702 3a 16 37			ld a, (.dmark)  
3705 32 6e fe			ld (debug_mark),a  
3708 3a 17 37			ld a, (.dmark+1)  
370b 32 6f fe			ld (debug_mark+1),a  
370e 3a 18 37			ld a, (.dmark+2)  
3711 32 70 fe			ld (debug_mark+2),a  
3714 18 03			jr .pastdmark  
3716 ..			.dmark: db "IS."  
3719 f1			.pastdmark: pop af  
371a			endm  
# End of macro DMARK
371a						CALLMONITOR 
371a cd 73 18			call break_point_state  
371d				endm  
# End of macro CALLMONITOR
371d					endif 
371d					NEXTW 
371d c3 55 22			jp macro_next 
3720				endm 
# End of macro NEXTW
3720			.LZERO: 
3720				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3720 2d				db WORD_SYS_CORE+25             
3721 2a 37			dw .TZERO            
3723 03				db 2 + 1 
3724 .. 00			db "0<",0              
3727				endm 
# End of macro CWHEAD
3727			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3727					NEXTW 
3727 c3 55 22			jp macro_next 
372a				endm 
# End of macro NEXTW
372a			.TZERO: 
372a				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
372a 2e				db WORD_SYS_CORE+26             
372b 71 37			dw .LESS            
372d 03				db 2 + 1 
372e .. 00			db "0=",0              
3731				endm 
# End of macro CWHEAD
3731			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3731				; TODO add floating point number detection 
3731					;v5 FORTH_DSP_VALUE 
3731					if DEBUG_FORTH_WORDS_KEY 
3731						DMARK "0=." 
3731 f5				push af  
3732 3a 46 37			ld a, (.dmark)  
3735 32 6e fe			ld (debug_mark),a  
3738 3a 47 37			ld a, (.dmark+1)  
373b 32 6f fe			ld (debug_mark+1),a  
373e 3a 48 37			ld a, (.dmark+2)  
3741 32 70 fe			ld (debug_mark+2),a  
3744 18 03			jr .pastdmark  
3746 ..			.dmark: db "0=."  
3749 f1			.pastdmark: pop af  
374a			endm  
# End of macro DMARK
374a						CALLMONITOR 
374a cd 73 18			call break_point_state  
374d				endm  
# End of macro CALLMONITOR
374d					endif 
374d					FORTH_DSP 
374d cd a4 20			call macro_forth_dsp 
3750				endm 
# End of macro FORTH_DSP
3750 7e					ld a,(hl)	; get type of value on TOS 
3751 fe 02				cp DS_TYPE_INUM  
3753 28 00				jr z, .tz_inum 
3755			 
3755				if FORTH_ENABLE_FLOATMATH 
3755					jr .tz_done 
3755			 
3755				endif 
3755					 
3755			 
3755			.tz_inum: 
3755					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3755 cd de 20			call macro_dsp_valuehl 
3758				endm 
# End of macro FORTH_DSP_VALUEHL
3758			 
3758			;		push hl 
3758			 
3758					; destroy value TOS 
3758			 
3758					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3758 cd 96 21			call macro_forth_dsp_pop 
375b				endm 
# End of macro FORTH_DSP_POP
375b			 
375b			;		pop hl 
375b			 
375b 3e 00				ld a,0 
375d			 
375d bd					cp l 
375e 20 08				jr nz, .tz_notzero 
3760			 
3760 bc					cp h 
3761			 
3761 20 05				jr nz, .tz_notzero 
3763			 
3763			 
3763 21 01 00				ld hl, FORTH_TRUE 
3766 18 03				jr .tz_done 
3768			 
3768 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
376b			 
376b					; push value back onto stack for another op etc 
376b			 
376b			.tz_done: 
376b cd e7 1e				call forth_push_numhl 
376e			 
376e					NEXTW 
376e c3 55 22			jp macro_next 
3771				endm 
# End of macro NEXTW
3771			.LESS: 
3771				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3771 2f				db WORD_SYS_CORE+27             
3772 da 37			dw .GT            
3774 02				db 1 + 1 
3775 .. 00			db "<",0              
3777				endm 
# End of macro CWHEAD
3777			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3777				; TODO add floating point number detection 
3777					if DEBUG_FORTH_WORDS_KEY 
3777						DMARK "LES" 
3777 f5				push af  
3778 3a 8c 37			ld a, (.dmark)  
377b 32 6e fe			ld (debug_mark),a  
377e 3a 8d 37			ld a, (.dmark+1)  
3781 32 6f fe			ld (debug_mark+1),a  
3784 3a 8e 37			ld a, (.dmark+2)  
3787 32 70 fe			ld (debug_mark+2),a  
378a 18 03			jr .pastdmark  
378c ..			.dmark: db "LES"  
378f f1			.pastdmark: pop af  
3790			endm  
# End of macro DMARK
3790						CALLMONITOR 
3790 cd 73 18			call break_point_state  
3793				endm  
# End of macro CALLMONITOR
3793					endif 
3793					FORTH_DSP 
3793 cd a4 20			call macro_forth_dsp 
3796				endm 
# End of macro FORTH_DSP
3796					;v5 FORTH_DSP_VALUE 
3796 7e					ld a,(hl)	; get type of value on TOS 
3797 fe 02				cp DS_TYPE_INUM  
3799 28 00				jr z, .less_inum 
379b			 
379b				if FORTH_ENABLE_FLOATMATH 
379b					jr .less_done 
379b			 
379b				endif 
379b					 
379b			 
379b			.less_inum: 
379b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
379b cd de 20			call macro_dsp_valuehl 
379e				endm 
# End of macro FORTH_DSP_VALUEHL
379e			 
379e e5					push hl  ; u2 
379f			 
379f					; destroy value TOS 
379f			 
379f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
379f cd 96 21			call macro_forth_dsp_pop 
37a2				endm 
# End of macro FORTH_DSP_POP
37a2			 
37a2			 
37a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37a2 cd de 20			call macro_dsp_valuehl 
37a5				endm 
# End of macro FORTH_DSP_VALUEHL
37a5			 
37a5 e5					push hl    ; u1 
37a6			 
37a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37a6 cd 96 21			call macro_forth_dsp_pop 
37a9				endm 
# End of macro FORTH_DSP_POP
37a9			 
37a9			 
37a9 b7			 or a      ;clear carry flag 
37aa 01 00 00		 ld bc, FORTH_FALSE 
37ad e1			  pop hl    ; u1 
37ae d1			  pop de    ; u2 
37af ed 52		  sbc hl,de 
37b1 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
37b3			 
37b3 01 01 00		 ld bc, FORTH_TRUE 
37b6			.lscont:  
37b6 c5					push bc 
37b7 e1					pop hl 
37b8			 
37b8					if DEBUG_FORTH_WORDS 
37b8						DMARK "LT1" 
37b8 f5				push af  
37b9 3a cd 37			ld a, (.dmark)  
37bc 32 6e fe			ld (debug_mark),a  
37bf 3a ce 37			ld a, (.dmark+1)  
37c2 32 6f fe			ld (debug_mark+1),a  
37c5 3a cf 37			ld a, (.dmark+2)  
37c8 32 70 fe			ld (debug_mark+2),a  
37cb 18 03			jr .pastdmark  
37cd ..			.dmark: db "LT1"  
37d0 f1			.pastdmark: pop af  
37d1			endm  
# End of macro DMARK
37d1						CALLMONITOR 
37d1 cd 73 18			call break_point_state  
37d4				endm  
# End of macro CALLMONITOR
37d4					endif 
37d4 cd e7 1e				call forth_push_numhl 
37d7			 
37d7					NEXTW 
37d7 c3 55 22			jp macro_next 
37da				endm 
# End of macro NEXTW
37da			.GT: 
37da				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
37da 30				db WORD_SYS_CORE+28             
37db 43 38			dw .EQUAL            
37dd 02				db 1 + 1 
37de .. 00			db ">",0              
37e0				endm 
# End of macro CWHEAD
37e0			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
37e0				; TODO add floating point number detection 
37e0					if DEBUG_FORTH_WORDS_KEY 
37e0						DMARK "GRT" 
37e0 f5				push af  
37e1 3a f5 37			ld a, (.dmark)  
37e4 32 6e fe			ld (debug_mark),a  
37e7 3a f6 37			ld a, (.dmark+1)  
37ea 32 6f fe			ld (debug_mark+1),a  
37ed 3a f7 37			ld a, (.dmark+2)  
37f0 32 70 fe			ld (debug_mark+2),a  
37f3 18 03			jr .pastdmark  
37f5 ..			.dmark: db "GRT"  
37f8 f1			.pastdmark: pop af  
37f9			endm  
# End of macro DMARK
37f9						CALLMONITOR 
37f9 cd 73 18			call break_point_state  
37fc				endm  
# End of macro CALLMONITOR
37fc					endif 
37fc					FORTH_DSP 
37fc cd a4 20			call macro_forth_dsp 
37ff				endm 
# End of macro FORTH_DSP
37ff					;FORTH_DSP_VALUE 
37ff 7e					ld a,(hl)	; get type of value on TOS 
3800 fe 02				cp DS_TYPE_INUM  
3802 28 00				jr z, .gt_inum 
3804			 
3804				if FORTH_ENABLE_FLOATMATH 
3804					jr .gt_done 
3804			 
3804				endif 
3804					 
3804			 
3804			.gt_inum: 
3804					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3804 cd de 20			call macro_dsp_valuehl 
3807				endm 
# End of macro FORTH_DSP_VALUEHL
3807			 
3807 e5					push hl  ; u2 
3808			 
3808					; destroy value TOS 
3808			 
3808					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3808 cd 96 21			call macro_forth_dsp_pop 
380b				endm 
# End of macro FORTH_DSP_POP
380b			 
380b			 
380b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
380b cd de 20			call macro_dsp_valuehl 
380e				endm 
# End of macro FORTH_DSP_VALUEHL
380e			 
380e e5					push hl    ; u1 
380f			 
380f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
380f cd 96 21			call macro_forth_dsp_pop 
3812				endm 
# End of macro FORTH_DSP_POP
3812			 
3812			 
3812 b7			 or a      ;clear carry flag 
3813 01 00 00		 ld bc, FORTH_FALSE 
3816 e1			  pop hl    ; u1 
3817 d1			  pop de    ; u2 
3818 ed 52		  sbc hl,de 
381a 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
381c			 
381c 01 01 00		 ld bc, FORTH_TRUE 
381f			.gtcont:  
381f c5					push bc 
3820 e1					pop hl 
3821			 
3821					if DEBUG_FORTH_WORDS 
3821						DMARK "GT1" 
3821 f5				push af  
3822 3a 36 38			ld a, (.dmark)  
3825 32 6e fe			ld (debug_mark),a  
3828 3a 37 38			ld a, (.dmark+1)  
382b 32 6f fe			ld (debug_mark+1),a  
382e 3a 38 38			ld a, (.dmark+2)  
3831 32 70 fe			ld (debug_mark+2),a  
3834 18 03			jr .pastdmark  
3836 ..			.dmark: db "GT1"  
3839 f1			.pastdmark: pop af  
383a			endm  
# End of macro DMARK
383a						CALLMONITOR 
383a cd 73 18			call break_point_state  
383d				endm  
# End of macro CALLMONITOR
383d					endif 
383d cd e7 1e				call forth_push_numhl 
3840			 
3840					NEXTW 
3840 c3 55 22			jp macro_next 
3843				endm 
# End of macro NEXTW
3843			.EQUAL: 
3843				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3843 31				db WORD_SYS_CORE+29             
3844 ae 38			dw .ENDLOGIC            
3846 02				db 1 + 1 
3847 .. 00			db "=",0              
3849				endm 
# End of macro CWHEAD
3849			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3849				; TODO add floating point number detection 
3849					if DEBUG_FORTH_WORDS_KEY 
3849						DMARK "EQ." 
3849 f5				push af  
384a 3a 5e 38			ld a, (.dmark)  
384d 32 6e fe			ld (debug_mark),a  
3850 3a 5f 38			ld a, (.dmark+1)  
3853 32 6f fe			ld (debug_mark+1),a  
3856 3a 60 38			ld a, (.dmark+2)  
3859 32 70 fe			ld (debug_mark+2),a  
385c 18 03			jr .pastdmark  
385e ..			.dmark: db "EQ."  
3861 f1			.pastdmark: pop af  
3862			endm  
# End of macro DMARK
3862						CALLMONITOR 
3862 cd 73 18			call break_point_state  
3865				endm  
# End of macro CALLMONITOR
3865					endif 
3865					FORTH_DSP 
3865 cd a4 20			call macro_forth_dsp 
3868				endm 
# End of macro FORTH_DSP
3868					;v5 FORTH_DSP_VALUE 
3868 7e					ld a,(hl)	; get type of value on TOS 
3869 fe 02				cp DS_TYPE_INUM  
386b 28 00				jr z, .eq_inum 
386d			 
386d				if FORTH_ENABLE_FLOATMATH 
386d					jr .eq_done 
386d			 
386d				endif 
386d					 
386d			 
386d			.eq_inum: 
386d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
386d cd de 20			call macro_dsp_valuehl 
3870				endm 
# End of macro FORTH_DSP_VALUEHL
3870			 
3870 e5					push hl 
3871			 
3871					; destroy value TOS 
3871			 
3871					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3871 cd 96 21			call macro_forth_dsp_pop 
3874				endm 
# End of macro FORTH_DSP_POP
3874			 
3874			 
3874					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3874 cd de 20			call macro_dsp_valuehl 
3877				endm 
# End of macro FORTH_DSP_VALUEHL
3877			 
3877					; one value on hl get other one back 
3877			 
3877 e5					push hl 
3878			 
3878					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3878 cd 96 21			call macro_forth_dsp_pop 
387b				endm 
# End of macro FORTH_DSP_POP
387b			 
387b 0e 00				ld c, FORTH_FALSE 
387d			 
387d e1					pop hl 
387e d1					pop de 
387f			 
387f 7b					ld a, e 
3880 bd					cp l 
3881			 
3881 20 06				jr nz, .eq_done 
3883			 
3883 7a					ld a, d 
3884 bc					cp h 
3885			 
3885 20 02				jr nz, .eq_done 
3887			 
3887 0e 01				ld c, FORTH_TRUE 
3889					 
3889			 
3889			 
3889			.eq_done: 
3889			 
3889					; TODO push value back onto stack for another op etc 
3889			 
3889 26 00				ld h, 0 
388b 69					ld l, c 
388c					if DEBUG_FORTH_WORDS 
388c						DMARK "EQ1" 
388c f5				push af  
388d 3a a1 38			ld a, (.dmark)  
3890 32 6e fe			ld (debug_mark),a  
3893 3a a2 38			ld a, (.dmark+1)  
3896 32 6f fe			ld (debug_mark+1),a  
3899 3a a3 38			ld a, (.dmark+2)  
389c 32 70 fe			ld (debug_mark+2),a  
389f 18 03			jr .pastdmark  
38a1 ..			.dmark: db "EQ1"  
38a4 f1			.pastdmark: pop af  
38a5			endm  
# End of macro DMARK
38a5						CALLMONITOR 
38a5 cd 73 18			call break_point_state  
38a8				endm  
# End of macro CALLMONITOR
38a8					endif 
38a8 cd e7 1e				call forth_push_numhl 
38ab			 
38ab					NEXTW 
38ab c3 55 22			jp macro_next 
38ae				endm 
# End of macro NEXTW
38ae			 
38ae			 
38ae			.ENDLOGIC: 
38ae			; eof 
38ae			 
38ae			 
# End of file forth_words_logic.asm
38ae			include "forth_words_maths.asm" 
38ae			 
38ae			; | ## Maths Words 
38ae			 
38ae			.PLUS:	 
38ae				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
38ae 15				db WORD_SYS_CORE+1             
38af f0 38			dw .NEG            
38b1 02				db 1 + 1 
38b2 .. 00			db "+",0              
38b4				endm 
# End of macro CWHEAD
38b4			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
38b4					if DEBUG_FORTH_WORDS_KEY 
38b4						DMARK "PLU" 
38b4 f5				push af  
38b5 3a c9 38			ld a, (.dmark)  
38b8 32 6e fe			ld (debug_mark),a  
38bb 3a ca 38			ld a, (.dmark+1)  
38be 32 6f fe			ld (debug_mark+1),a  
38c1 3a cb 38			ld a, (.dmark+2)  
38c4 32 70 fe			ld (debug_mark+2),a  
38c7 18 03			jr .pastdmark  
38c9 ..			.dmark: db "PLU"  
38cc f1			.pastdmark: pop af  
38cd			endm  
# End of macro DMARK
38cd						CALLMONITOR 
38cd cd 73 18			call break_point_state  
38d0				endm  
# End of macro CALLMONITOR
38d0					endif 
38d0					; add top two values and push back result 
38d0			 
38d0					;for v5 FORTH_DSP_VALUE 
38d0					FORTH_DSP 
38d0 cd a4 20			call macro_forth_dsp 
38d3				endm 
# End of macro FORTH_DSP
38d3 7e					ld a,(hl)	; get type of value on TOS 
38d4 fe 02				cp DS_TYPE_INUM  
38d6 28 03				jr z, .dot_inum 
38d8			 
38d8					NEXTW 
38d8 c3 55 22			jp macro_next 
38db				endm 
# End of macro NEXTW
38db			 
38db			; float maths 
38db			 
38db				if FORTH_ENABLE_FLOATMATH 
38db						inc hl      ; now at start of numeric as string 
38db			 
38db					if DEBUG_FORTH_MATHS 
38db						DMARK "ADD" 
38db				CALLMONITOR 
38db					endif 
38db			 
38db					;ld ix, hl 
38db					call CON 
38db			 
38db			 
38db					push hl 
38db					 
38db					 
38db			 
38db						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
38db			 
38db					; get next number 
38db			 
38db						FORTH_DSP_VALUE 
38db			 
38db						inc hl      ; now at start of numeric as string 
38db			 
38db					;ld ix, hl 
38db					call CON 
38db			 
38db					push hl 
38db			 
38db			 
38db						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38db			 
38db						; TODO do add 
38db			 
38db						call IADD 
38db			 
38db						; TODO get result back as ascii 
38db			 
38db						; TODO push result  
38db			 
38db			 
38db			 
38db						jr .dot_done 
38db				endif 
38db			 
38db			.dot_inum: 
38db			 
38db			 
38db					if DEBUG_FORTH_DOT 
38db						DMARK "+IT" 
38db				CALLMONITOR 
38db					endif 
38db			 
38db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38db cd de 20			call macro_dsp_valuehl 
38de				endm 
# End of macro FORTH_DSP_VALUEHL
38de			 
38de				; TODO add floating point number detection 
38de			 
38de e5					push hl 
38df			 
38df					; destroy value TOS 
38df			 
38df					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38df cd 96 21			call macro_forth_dsp_pop 
38e2				endm 
# End of macro FORTH_DSP_POP
38e2			 
38e2			 
38e2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38e2 cd de 20			call macro_dsp_valuehl 
38e5				endm 
# End of macro FORTH_DSP_VALUEHL
38e5			 
38e5					; one value on hl get other one back 
38e5			 
38e5 d1					pop de 
38e6			 
38e6					; do the add 
38e6			 
38e6 19					add hl,de 
38e7			 
38e7					; save it 
38e7			 
38e7			;		push hl	 
38e7			 
38e7					; 
38e7			 
38e7					; destroy value TOS 
38e7			 
38e7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38e7 cd 96 21			call macro_forth_dsp_pop 
38ea				endm 
# End of macro FORTH_DSP_POP
38ea			 
38ea					; TODO push value back onto stack for another op etc 
38ea			 
38ea			;		pop hl 
38ea			 
38ea			.dot_done: 
38ea cd e7 1e				call forth_push_numhl 
38ed			 
38ed					NEXTW 
38ed c3 55 22			jp macro_next 
38f0				endm 
# End of macro NEXTW
38f0			.NEG: 
38f0			 
38f0				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
38f0 17				db WORD_SYS_CORE+3             
38f1 33 39			dw .DIV            
38f3 02				db 1 + 1 
38f4 .. 00			db "-",0              
38f6				endm 
# End of macro CWHEAD
38f6			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
38f6					if DEBUG_FORTH_WORDS_KEY 
38f6						DMARK "SUB" 
38f6 f5				push af  
38f7 3a 0b 39			ld a, (.dmark)  
38fa 32 6e fe			ld (debug_mark),a  
38fd 3a 0c 39			ld a, (.dmark+1)  
3900 32 6f fe			ld (debug_mark+1),a  
3903 3a 0d 39			ld a, (.dmark+2)  
3906 32 70 fe			ld (debug_mark+2),a  
3909 18 03			jr .pastdmark  
390b ..			.dmark: db "SUB"  
390e f1			.pastdmark: pop af  
390f			endm  
# End of macro DMARK
390f						CALLMONITOR 
390f cd 73 18			call break_point_state  
3912				endm  
# End of macro CALLMONITOR
3912					endif 
3912			 
3912			 
3912				; TODO add floating point number detection 
3912					; v5 FORTH_DSP_VALUE 
3912					FORTH_DSP 
3912 cd a4 20			call macro_forth_dsp 
3915				endm 
# End of macro FORTH_DSP
3915 7e					ld a,(hl)	; get type of value on TOS 
3916 fe 02				cp DS_TYPE_INUM  
3918 28 03				jr z, .neg_inum 
391a			 
391a					NEXTW 
391a c3 55 22			jp macro_next 
391d				endm 
# End of macro NEXTW
391d			 
391d			; float maths 
391d			 
391d				if FORTH_ENABLE_FLOATMATH 
391d					jr .neg_done 
391d			 
391d				endif 
391d					 
391d			 
391d			.neg_inum: 
391d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
391d cd de 20			call macro_dsp_valuehl 
3920				endm 
# End of macro FORTH_DSP_VALUEHL
3920			 
3920 e5					push hl 
3921			 
3921					; destroy value TOS 
3921			 
3921					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3921 cd 96 21			call macro_forth_dsp_pop 
3924				endm 
# End of macro FORTH_DSP_POP
3924			 
3924			 
3924					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3924 cd de 20			call macro_dsp_valuehl 
3927				endm 
# End of macro FORTH_DSP_VALUEHL
3927			 
3927					; one value on hl get other one back 
3927			 
3927 d1					pop de 
3928			 
3928					; do the sub 
3928			;		ex de, hl 
3928			 
3928 ed 52				sbc hl,de 
392a			 
392a					; save it 
392a			 
392a			;		push hl	 
392a			 
392a					; 
392a			 
392a					; destroy value TOS 
392a			 
392a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
392a cd 96 21			call macro_forth_dsp_pop 
392d				endm 
# End of macro FORTH_DSP_POP
392d			 
392d					; TODO push value back onto stack for another op etc 
392d			 
392d			;		pop hl 
392d			 
392d cd e7 1e				call forth_push_numhl 
3930			.neg_done: 
3930			 
3930					NEXTW 
3930 c3 55 22			jp macro_next 
3933				endm 
# End of macro NEXTW
3933			.DIV: 
3933				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3933 18				db WORD_SYS_CORE+4             
3934 80 39			dw .MUL            
3936 02				db 1 + 1 
3937 .. 00			db "/",0              
3939				endm 
# End of macro CWHEAD
3939			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3939					if DEBUG_FORTH_WORDS_KEY 
3939						DMARK "DIV" 
3939 f5				push af  
393a 3a 4e 39			ld a, (.dmark)  
393d 32 6e fe			ld (debug_mark),a  
3940 3a 4f 39			ld a, (.dmark+1)  
3943 32 6f fe			ld (debug_mark+1),a  
3946 3a 50 39			ld a, (.dmark+2)  
3949 32 70 fe			ld (debug_mark+2),a  
394c 18 03			jr .pastdmark  
394e ..			.dmark: db "DIV"  
3951 f1			.pastdmark: pop af  
3952			endm  
# End of macro DMARK
3952						CALLMONITOR 
3952 cd 73 18			call break_point_state  
3955				endm  
# End of macro CALLMONITOR
3955					endif 
3955				; TODO add floating point number detection 
3955					; v5 FORTH_DSP_VALUE 
3955					FORTH_DSP 
3955 cd a4 20			call macro_forth_dsp 
3958				endm 
# End of macro FORTH_DSP
3958 7e					ld a,(hl)	; get type of value on TOS 
3959 fe 02				cp DS_TYPE_INUM  
395b 28 03				jr z, .div_inum 
395d			 
395d				if FORTH_ENABLE_FLOATMATH 
395d					jr .div_done 
395d			 
395d				endif 
395d					NEXTW 
395d c3 55 22			jp macro_next 
3960				endm 
# End of macro NEXTW
3960			.div_inum: 
3960			 
3960					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3960 cd de 20			call macro_dsp_valuehl 
3963				endm 
# End of macro FORTH_DSP_VALUEHL
3963			 
3963 e5					push hl    ; to go to bc 
3964			 
3964					; destroy value TOS 
3964			 
3964					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3964 cd 96 21			call macro_forth_dsp_pop 
3967				endm 
# End of macro FORTH_DSP_POP
3967			 
3967			 
3967					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3967 cd de 20			call macro_dsp_valuehl 
396a				endm 
# End of macro FORTH_DSP_VALUEHL
396a			 
396a					; hl to go to de 
396a			 
396a e5					push hl 
396b			 
396b c1					pop bc 
396c d1					pop de		 
396d			 
396d			 
396d					if DEBUG_FORTH_MATHS 
396d						DMARK "DIV" 
396d				CALLMONITOR 
396d					endif 
396d					; one value on hl but move to a get other one back 
396d			 
396d			        
396d cd 29 0e			call Div16 
3970			 
3970			;	push af	 
3970 e5				push hl 
3971 c5				push bc 
3972			 
3972					if DEBUG_FORTH_MATHS 
3972						DMARK "DI1" 
3972				CALLMONITOR 
3972					endif 
3972			 
3972					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3972 cd 96 21			call macro_forth_dsp_pop 
3975				endm 
# End of macro FORTH_DSP_POP
3975			 
3975			 
3975			 
3975 e1					pop hl    ; result 
3976			 
3976 cd e7 1e				call forth_push_numhl 
3979			 
3979 e1					pop hl    ; reminder 
397a			;		ld h,0 
397a			;		ld l,d 
397a			 
397a cd e7 1e				call forth_push_numhl 
397d			.div_done: 
397d					NEXTW 
397d c3 55 22			jp macro_next 
3980				endm 
# End of macro NEXTW
3980			.MUL: 
3980				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3980 19				db WORD_SYS_CORE+5             
3981 c5 39			dw .MIN            
3983 02				db 1 + 1 
3984 .. 00			db "*",0              
3986				endm 
# End of macro CWHEAD
3986			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3986				; TODO add floating point number detection 
3986					if DEBUG_FORTH_WORDS_KEY 
3986						DMARK "MUL" 
3986 f5				push af  
3987 3a 9b 39			ld a, (.dmark)  
398a 32 6e fe			ld (debug_mark),a  
398d 3a 9c 39			ld a, (.dmark+1)  
3990 32 6f fe			ld (debug_mark+1),a  
3993 3a 9d 39			ld a, (.dmark+2)  
3996 32 70 fe			ld (debug_mark+2),a  
3999 18 03			jr .pastdmark  
399b ..			.dmark: db "MUL"  
399e f1			.pastdmark: pop af  
399f			endm  
# End of macro DMARK
399f						CALLMONITOR 
399f cd 73 18			call break_point_state  
39a2				endm  
# End of macro CALLMONITOR
39a2					endif 
39a2					FORTH_DSP 
39a2 cd a4 20			call macro_forth_dsp 
39a5				endm 
# End of macro FORTH_DSP
39a5					; v5 FORTH_DSP_VALUE 
39a5 7e					ld a,(hl)	; get type of value on TOS 
39a6 fe 02				cp DS_TYPE_INUM  
39a8 28 03				jr z, .mul_inum 
39aa			 
39aa				if FORTH_ENABLE_FLOATMATH 
39aa					jr .mul_done 
39aa			 
39aa				endif 
39aa			 
39aa					NEXTW 
39aa c3 55 22			jp macro_next 
39ad				endm 
# End of macro NEXTW
39ad			.mul_inum:	 
39ad			 
39ad					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39ad cd de 20			call macro_dsp_valuehl 
39b0				endm 
# End of macro FORTH_DSP_VALUEHL
39b0			 
39b0 e5					push hl 
39b1			 
39b1					; destroy value TOS 
39b1			 
39b1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39b1 cd 96 21			call macro_forth_dsp_pop 
39b4				endm 
# End of macro FORTH_DSP_POP
39b4			 
39b4			 
39b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39b4 cd de 20			call macro_dsp_valuehl 
39b7				endm 
# End of macro FORTH_DSP_VALUEHL
39b7			 
39b7					; one value on hl but move to a get other one back 
39b7			 
39b7 7d					ld a, l 
39b8			 
39b8 d1					pop de 
39b9			 
39b9					; do the mull 
39b9			;		ex de, hl 
39b9			 
39b9 cd 4f 0e				call Mult16 
39bc					; save it 
39bc			 
39bc			;		push hl	 
39bc			 
39bc					; 
39bc			 
39bc					; destroy value TOS 
39bc			 
39bc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39bc cd 96 21			call macro_forth_dsp_pop 
39bf				endm 
# End of macro FORTH_DSP_POP
39bf			 
39bf					; TODO push value back onto stack for another op etc 
39bf			 
39bf			;		pop hl 
39bf			 
39bf cd e7 1e				call forth_push_numhl 
39c2			 
39c2			.mul_done: 
39c2					NEXTW 
39c2 c3 55 22			jp macro_next 
39c5				endm 
# End of macro NEXTW
39c5			 
39c5			 
39c5			 
39c5			 
39c5			.MIN: 
39c5				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
39c5 49				db WORD_SYS_CORE+53             
39c6 46 3a			dw .MAX            
39c8 04				db 3 + 1 
39c9 .. 00			db "MIN",0              
39cd				endm 
# End of macro CWHEAD
39cd			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
39cd					if DEBUG_FORTH_WORDS_KEY 
39cd						DMARK "MIN" 
39cd f5				push af  
39ce 3a e2 39			ld a, (.dmark)  
39d1 32 6e fe			ld (debug_mark),a  
39d4 3a e3 39			ld a, (.dmark+1)  
39d7 32 6f fe			ld (debug_mark+1),a  
39da 3a e4 39			ld a, (.dmark+2)  
39dd 32 70 fe			ld (debug_mark+2),a  
39e0 18 03			jr .pastdmark  
39e2 ..			.dmark: db "MIN"  
39e5 f1			.pastdmark: pop af  
39e6			endm  
# End of macro DMARK
39e6						CALLMONITOR 
39e6 cd 73 18			call break_point_state  
39e9				endm  
# End of macro CALLMONITOR
39e9					endif 
39e9					; get u2 
39e9			 
39e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39e9 cd de 20			call macro_dsp_valuehl 
39ec				endm 
# End of macro FORTH_DSP_VALUEHL
39ec			 
39ec e5					push hl   ; u2 
39ed			 
39ed					; destroy value TOS 
39ed			 
39ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39ed cd 96 21			call macro_forth_dsp_pop 
39f0				endm 
# End of macro FORTH_DSP_POP
39f0			 
39f0					; get u1 
39f0			 
39f0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39f0 cd de 20			call macro_dsp_valuehl 
39f3				endm 
# End of macro FORTH_DSP_VALUEHL
39f3			 
39f3 e5					push hl  ; u1 
39f4			 
39f4					; destroy value TOS 
39f4			 
39f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39f4 cd 96 21			call macro_forth_dsp_pop 
39f7				endm 
# End of macro FORTH_DSP_POP
39f7			 
39f7 b7			 or a      ;clear carry flag 
39f8 e1			  pop hl    ; u1 
39f9 d1			  pop de    ; u2 
39fa e5				push hl   ; saved in case hl is lowest 
39fb ed 52		  sbc hl,de 
39fd 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
39ff			 
39ff e1				pop hl 
3a00					if DEBUG_FORTH_WORDS 
3a00						DMARK "MIN" 
3a00 f5				push af  
3a01 3a 15 3a			ld a, (.dmark)  
3a04 32 6e fe			ld (debug_mark),a  
3a07 3a 16 3a			ld a, (.dmark+1)  
3a0a 32 6f fe			ld (debug_mark+1),a  
3a0d 3a 17 3a			ld a, (.dmark+2)  
3a10 32 70 fe			ld (debug_mark+2),a  
3a13 18 03			jr .pastdmark  
3a15 ..			.dmark: db "MIN"  
3a18 f1			.pastdmark: pop af  
3a19			endm  
# End of macro DMARK
3a19						CALLMONITOR 
3a19 cd 73 18			call break_point_state  
3a1c				endm  
# End of macro CALLMONITOR
3a1c					endif 
3a1c cd e7 1e				call forth_push_numhl 
3a1f			 
3a1f				       NEXTW 
3a1f c3 55 22			jp macro_next 
3a22				endm 
# End of macro NEXTW
3a22			 
3a22			.mincont:  
3a22 c1				pop bc   ; tidy up 
3a23 eb				ex de , hl  
3a24					if DEBUG_FORTH_WORDS 
3a24						DMARK "MI1" 
3a24 f5				push af  
3a25 3a 39 3a			ld a, (.dmark)  
3a28 32 6e fe			ld (debug_mark),a  
3a2b 3a 3a 3a			ld a, (.dmark+1)  
3a2e 32 6f fe			ld (debug_mark+1),a  
3a31 3a 3b 3a			ld a, (.dmark+2)  
3a34 32 70 fe			ld (debug_mark+2),a  
3a37 18 03			jr .pastdmark  
3a39 ..			.dmark: db "MI1"  
3a3c f1			.pastdmark: pop af  
3a3d			endm  
# End of macro DMARK
3a3d						CALLMONITOR 
3a3d cd 73 18			call break_point_state  
3a40				endm  
# End of macro CALLMONITOR
3a40					endif 
3a40 cd e7 1e				call forth_push_numhl 
3a43			 
3a43				       NEXTW 
3a43 c3 55 22			jp macro_next 
3a46				endm 
# End of macro NEXTW
3a46			.MAX: 
3a46				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3a46 4a				db WORD_SYS_CORE+54             
3a47 c7 3a			dw .RND16            
3a49 04				db 3 + 1 
3a4a .. 00			db "MAX",0              
3a4e				endm 
# End of macro CWHEAD
3a4e			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3a4e					if DEBUG_FORTH_WORDS_KEY 
3a4e						DMARK "MAX" 
3a4e f5				push af  
3a4f 3a 63 3a			ld a, (.dmark)  
3a52 32 6e fe			ld (debug_mark),a  
3a55 3a 64 3a			ld a, (.dmark+1)  
3a58 32 6f fe			ld (debug_mark+1),a  
3a5b 3a 65 3a			ld a, (.dmark+2)  
3a5e 32 70 fe			ld (debug_mark+2),a  
3a61 18 03			jr .pastdmark  
3a63 ..			.dmark: db "MAX"  
3a66 f1			.pastdmark: pop af  
3a67			endm  
# End of macro DMARK
3a67						CALLMONITOR 
3a67 cd 73 18			call break_point_state  
3a6a				endm  
# End of macro CALLMONITOR
3a6a					endif 
3a6a					; get u2 
3a6a			 
3a6a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a6a cd de 20			call macro_dsp_valuehl 
3a6d				endm 
# End of macro FORTH_DSP_VALUEHL
3a6d			 
3a6d e5					push hl   ; u2 
3a6e			 
3a6e					; destroy value TOS 
3a6e			 
3a6e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a6e cd 96 21			call macro_forth_dsp_pop 
3a71				endm 
# End of macro FORTH_DSP_POP
3a71			 
3a71					; get u1 
3a71			 
3a71					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a71 cd de 20			call macro_dsp_valuehl 
3a74				endm 
# End of macro FORTH_DSP_VALUEHL
3a74			 
3a74 e5					push hl  ; u1 
3a75			 
3a75					; destroy value TOS 
3a75			 
3a75					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a75 cd 96 21			call macro_forth_dsp_pop 
3a78				endm 
# End of macro FORTH_DSP_POP
3a78			 
3a78 b7			 or a      ;clear carry flag 
3a79 e1			  pop hl    ; u1 
3a7a d1			  pop de    ; u2 
3a7b e5				push hl   ; saved in case hl is lowest 
3a7c ed 52		  sbc hl,de 
3a7e 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3a80			 
3a80 e1				pop hl 
3a81					if DEBUG_FORTH_WORDS 
3a81						DMARK "MAX" 
3a81 f5				push af  
3a82 3a 96 3a			ld a, (.dmark)  
3a85 32 6e fe			ld (debug_mark),a  
3a88 3a 97 3a			ld a, (.dmark+1)  
3a8b 32 6f fe			ld (debug_mark+1),a  
3a8e 3a 98 3a			ld a, (.dmark+2)  
3a91 32 70 fe			ld (debug_mark+2),a  
3a94 18 03			jr .pastdmark  
3a96 ..			.dmark: db "MAX"  
3a99 f1			.pastdmark: pop af  
3a9a			endm  
# End of macro DMARK
3a9a						CALLMONITOR 
3a9a cd 73 18			call break_point_state  
3a9d				endm  
# End of macro CALLMONITOR
3a9d					endif 
3a9d cd e7 1e				call forth_push_numhl 
3aa0			 
3aa0				       NEXTW 
3aa0 c3 55 22			jp macro_next 
3aa3				endm 
# End of macro NEXTW
3aa3			 
3aa3			.maxcont:  
3aa3 c1				pop bc   ; tidy up 
3aa4 eb				ex de , hl  
3aa5					if DEBUG_FORTH_WORDS 
3aa5						DMARK "MA1" 
3aa5 f5				push af  
3aa6 3a ba 3a			ld a, (.dmark)  
3aa9 32 6e fe			ld (debug_mark),a  
3aac 3a bb 3a			ld a, (.dmark+1)  
3aaf 32 6f fe			ld (debug_mark+1),a  
3ab2 3a bc 3a			ld a, (.dmark+2)  
3ab5 32 70 fe			ld (debug_mark+2),a  
3ab8 18 03			jr .pastdmark  
3aba ..			.dmark: db "MA1"  
3abd f1			.pastdmark: pop af  
3abe			endm  
# End of macro DMARK
3abe						CALLMONITOR 
3abe cd 73 18			call break_point_state  
3ac1				endm  
# End of macro CALLMONITOR
3ac1					endif 
3ac1 cd e7 1e				call forth_push_numhl 
3ac4				       NEXTW 
3ac4 c3 55 22			jp macro_next 
3ac7				endm 
# End of macro NEXTW
3ac7			 
3ac7			.RND16: 
3ac7				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3ac7 4e				db WORD_SYS_CORE+58             
3ac8 f6 3a			dw .RND8            
3aca 06				db 5 + 1 
3acb .. 00			db "RND16",0              
3ad1				endm 
# End of macro CWHEAD
3ad1			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3ad1					if DEBUG_FORTH_WORDS_KEY 
3ad1						DMARK "R16" 
3ad1 f5				push af  
3ad2 3a e6 3a			ld a, (.dmark)  
3ad5 32 6e fe			ld (debug_mark),a  
3ad8 3a e7 3a			ld a, (.dmark+1)  
3adb 32 6f fe			ld (debug_mark+1),a  
3ade 3a e8 3a			ld a, (.dmark+2)  
3ae1 32 70 fe			ld (debug_mark+2),a  
3ae4 18 03			jr .pastdmark  
3ae6 ..			.dmark: db "R16"  
3ae9 f1			.pastdmark: pop af  
3aea			endm  
# End of macro DMARK
3aea						CALLMONITOR 
3aea cd 73 18			call break_point_state  
3aed				endm  
# End of macro CALLMONITOR
3aed					endif 
3aed cd f3 0d				call prng16  
3af0 cd e7 1e				call forth_push_numhl 
3af3				       NEXTW 
3af3 c3 55 22			jp macro_next 
3af6				endm 
# End of macro NEXTW
3af6			.RND8: 
3af6				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3af6 60				db WORD_SYS_CORE+76             
3af7 2b 3b			dw .RND            
3af9 05				db 4 + 1 
3afa .. 00			db "RND8",0              
3aff				endm 
# End of macro CWHEAD
3aff			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3aff					if DEBUG_FORTH_WORDS_KEY 
3aff						DMARK "RN8" 
3aff f5				push af  
3b00 3a 14 3b			ld a, (.dmark)  
3b03 32 6e fe			ld (debug_mark),a  
3b06 3a 15 3b			ld a, (.dmark+1)  
3b09 32 6f fe			ld (debug_mark+1),a  
3b0c 3a 16 3b			ld a, (.dmark+2)  
3b0f 32 70 fe			ld (debug_mark+2),a  
3b12 18 03			jr .pastdmark  
3b14 ..			.dmark: db "RN8"  
3b17 f1			.pastdmark: pop af  
3b18			endm  
# End of macro DMARK
3b18						CALLMONITOR 
3b18 cd 73 18			call break_point_state  
3b1b				endm  
# End of macro CALLMONITOR
3b1b					endif 
3b1b 2a af fb				ld hl,(xrandc) 
3b1e 23					inc hl 
3b1f cd 0d 0e				call xrnd 
3b22 6f					ld l,a	 
3b23 26 00				ld h,0 
3b25 cd e7 1e				call forth_push_numhl 
3b28				       NEXTW 
3b28 c3 55 22			jp macro_next 
3b2b				endm 
# End of macro NEXTW
3b2b			.RND: 
3b2b				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3b2b 60				db WORD_SYS_CORE+76             
3b2c 31 3c			dw .ENDMATHS            
3b2e 04				db 3 + 1 
3b2f .. 00			db "RND",0              
3b33				endm 
# End of macro CWHEAD
3b33			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3b33			 
3b33					if DEBUG_FORTH_WORDS_KEY 
3b33						DMARK "RND" 
3b33 f5				push af  
3b34 3a 48 3b			ld a, (.dmark)  
3b37 32 6e fe			ld (debug_mark),a  
3b3a 3a 49 3b			ld a, (.dmark+1)  
3b3d 32 6f fe			ld (debug_mark+1),a  
3b40 3a 4a 3b			ld a, (.dmark+2)  
3b43 32 70 fe			ld (debug_mark+2),a  
3b46 18 03			jr .pastdmark  
3b48 ..			.dmark: db "RND"  
3b4b f1			.pastdmark: pop af  
3b4c			endm  
# End of macro DMARK
3b4c						CALLMONITOR 
3b4c cd 73 18			call break_point_state  
3b4f				endm  
# End of macro CALLMONITOR
3b4f					endif 
3b4f					 
3b4f					FORTH_DSP_VALUEHL    ; upper range 
3b4f cd de 20			call macro_dsp_valuehl 
3b52				endm 
# End of macro FORTH_DSP_VALUEHL
3b52			 
3b52 22 b3 fb				ld (LFSRSeed), hl	 
3b55			 
3b55					if DEBUG_FORTH_WORDS 
3b55						DMARK "RN1" 
3b55 f5				push af  
3b56 3a 6a 3b			ld a, (.dmark)  
3b59 32 6e fe			ld (debug_mark),a  
3b5c 3a 6b 3b			ld a, (.dmark+1)  
3b5f 32 6f fe			ld (debug_mark+1),a  
3b62 3a 6c 3b			ld a, (.dmark+2)  
3b65 32 70 fe			ld (debug_mark+2),a  
3b68 18 03			jr .pastdmark  
3b6a ..			.dmark: db "RN1"  
3b6d f1			.pastdmark: pop af  
3b6e			endm  
# End of macro DMARK
3b6e						CALLMONITOR 
3b6e cd 73 18			call break_point_state  
3b71				endm  
# End of macro CALLMONITOR
3b71					endif 
3b71					FORTH_DSP_POP 
3b71 cd 96 21			call macro_forth_dsp_pop 
3b74				endm 
# End of macro FORTH_DSP_POP
3b74			 
3b74					FORTH_DSP_VALUEHL    ; low range 
3b74 cd de 20			call macro_dsp_valuehl 
3b77				endm 
# End of macro FORTH_DSP_VALUEHL
3b77			 
3b77					if DEBUG_FORTH_WORDS 
3b77						DMARK "RN2" 
3b77 f5				push af  
3b78 3a 8c 3b			ld a, (.dmark)  
3b7b 32 6e fe			ld (debug_mark),a  
3b7e 3a 8d 3b			ld a, (.dmark+1)  
3b81 32 6f fe			ld (debug_mark+1),a  
3b84 3a 8e 3b			ld a, (.dmark+2)  
3b87 32 70 fe			ld (debug_mark+2),a  
3b8a 18 03			jr .pastdmark  
3b8c ..			.dmark: db "RN2"  
3b8f f1			.pastdmark: pop af  
3b90			endm  
# End of macro DMARK
3b90						CALLMONITOR 
3b90 cd 73 18			call break_point_state  
3b93				endm  
# End of macro CALLMONITOR
3b93					endif 
3b93 22 b5 fb				ld (LFSRSeed+2), hl 
3b96			 
3b96					FORTH_DSP_POP 
3b96 cd 96 21			call macro_forth_dsp_pop 
3b99				endm 
# End of macro FORTH_DSP_POP
3b99			 
3b99 e5					push hl 
3b9a			 
3b9a e1			.inrange:	pop hl 
3b9b cd f3 0d				call prng16  
3b9e					if DEBUG_FORTH_WORDS 
3b9e						DMARK "RN3" 
3b9e f5				push af  
3b9f 3a b3 3b			ld a, (.dmark)  
3ba2 32 6e fe			ld (debug_mark),a  
3ba5 3a b4 3b			ld a, (.dmark+1)  
3ba8 32 6f fe			ld (debug_mark+1),a  
3bab 3a b5 3b			ld a, (.dmark+2)  
3bae 32 70 fe			ld (debug_mark+2),a  
3bb1 18 03			jr .pastdmark  
3bb3 ..			.dmark: db "RN3"  
3bb6 f1			.pastdmark: pop af  
3bb7			endm  
# End of macro DMARK
3bb7						CALLMONITOR 
3bb7 cd 73 18			call break_point_state  
3bba				endm  
# End of macro CALLMONITOR
3bba					endif 
3bba					 
3bba					; if the range is 8bit knock out the high byte 
3bba			 
3bba ed 5b b3 fb			ld de, (LFSRSeed)     ; check high level 
3bbe			 
3bbe 3e 00				ld a, 0 
3bc0 ba					cp d  
3bc1 20 1e				jr nz, .hirange 
3bc3 26 00				ld h, 0   ; knock it down to 8bit 
3bc5			 
3bc5					if DEBUG_FORTH_WORDS 
3bc5						DMARK "RNk" 
3bc5 f5				push af  
3bc6 3a da 3b			ld a, (.dmark)  
3bc9 32 6e fe			ld (debug_mark),a  
3bcc 3a db 3b			ld a, (.dmark+1)  
3bcf 32 6f fe			ld (debug_mark+1),a  
3bd2 3a dc 3b			ld a, (.dmark+2)  
3bd5 32 70 fe			ld (debug_mark+2),a  
3bd8 18 03			jr .pastdmark  
3bda ..			.dmark: db "RNk"  
3bdd f1			.pastdmark: pop af  
3bde			endm  
# End of macro DMARK
3bde						CALLMONITOR 
3bde cd 73 18			call break_point_state  
3be1				endm  
# End of macro CALLMONITOR
3be1					endif 
3be1			.hirange:   
3be1 e5					push hl  
3be2 b7					or a  
3be3 ed 52		                sbc hl, de 
3be5			 
3be5					;call cmp16 
3be5			 
3be5 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3be7 e1					pop hl 
3be8 e5					push hl 
3be9			 
3be9					if DEBUG_FORTH_WORDS 
3be9						DMARK "RN4" 
3be9 f5				push af  
3bea 3a fe 3b			ld a, (.dmark)  
3bed 32 6e fe			ld (debug_mark),a  
3bf0 3a ff 3b			ld a, (.dmark+1)  
3bf3 32 6f fe			ld (debug_mark+1),a  
3bf6 3a 00 3c			ld a, (.dmark+2)  
3bf9 32 70 fe			ld (debug_mark+2),a  
3bfc 18 03			jr .pastdmark  
3bfe ..			.dmark: db "RN4"  
3c01 f1			.pastdmark: pop af  
3c02			endm  
# End of macro DMARK
3c02						CALLMONITOR 
3c02 cd 73 18			call break_point_state  
3c05				endm  
# End of macro CALLMONITOR
3c05					endif 
3c05 ed 5b b5 fb			ld de, (LFSRSeed+2)   ; check low range 
3c09					;call cmp16 
3c09				 
3c09 b7					or a  
3c0a ed 52		                sbc hl, de 
3c0c 38 8c				jr c, .inrange 
3c0e			 
3c0e e1					pop hl 
3c0f					 
3c0f					if DEBUG_FORTH_WORDS 
3c0f						DMARK "RNd" 
3c0f f5				push af  
3c10 3a 24 3c			ld a, (.dmark)  
3c13 32 6e fe			ld (debug_mark),a  
3c16 3a 25 3c			ld a, (.dmark+1)  
3c19 32 6f fe			ld (debug_mark+1),a  
3c1c 3a 26 3c			ld a, (.dmark+2)  
3c1f 32 70 fe			ld (debug_mark+2),a  
3c22 18 03			jr .pastdmark  
3c24 ..			.dmark: db "RNd"  
3c27 f1			.pastdmark: pop af  
3c28			endm  
# End of macro DMARK
3c28						CALLMONITOR 
3c28 cd 73 18			call break_point_state  
3c2b				endm  
# End of macro CALLMONITOR
3c2b					endif 
3c2b			 
3c2b			 
3c2b cd e7 1e				call forth_push_numhl 
3c2e				       NEXTW 
3c2e c3 55 22			jp macro_next 
3c31				endm 
# End of macro NEXTW
3c31			 
3c31			.ENDMATHS: 
3c31			 
3c31			; eof 
3c31			 
# End of file forth_words_maths.asm
3c31			include "forth_words_display.asm" 
3c31			 
3c31			; | ## Display Words 
3c31			 
3c31			.INFO: 
3c31			 
3c31				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3c31 62				db WORD_SYS_CORE+78             
3c32 4e 3c			dw .ATP            
3c34 05				db 4 + 1 
3c35 .. 00			db "INFO",0              
3c3a				endm 
# End of macro CWHEAD
3c3a			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3c3a					FORTH_DSP_VALUEHL 
3c3a cd de 20			call macro_dsp_valuehl 
3c3d				endm 
# End of macro FORTH_DSP_VALUEHL
3c3d			 
3c3d					FORTH_DSP_POP 
3c3d cd 96 21			call macro_forth_dsp_pop 
3c40				endm 
# End of macro FORTH_DSP_POP
3c40			 
3c40 e5					push hl 
3c41			 
3c41					FORTH_DSP_VALUEHL 
3c41 cd de 20			call macro_dsp_valuehl 
3c44				endm 
# End of macro FORTH_DSP_VALUEHL
3c44			 
3c44					FORTH_DSP_POP 
3c44 cd 96 21			call macro_forth_dsp_pop 
3c47				endm 
# End of macro FORTH_DSP_POP
3c47			 
3c47 d1					pop de 
3c48			 
3c48 cd 29 0c				call info_panel 
3c4b			 
3c4b			 
3c4b					NEXTW 
3c4b c3 55 22			jp macro_next 
3c4e				endm 
# End of macro NEXTW
3c4e			.ATP: 
3c4e				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3c4e 62				db WORD_SYS_CORE+78             
3c4f c5 3c			dw .FB            
3c51 04				db 3 + 1 
3c52 .. 00			db "AT?",0              
3c56				endm 
# End of macro CWHEAD
3c56			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3c56					if DEBUG_FORTH_WORDS_KEY 
3c56						DMARK "AT?" 
3c56 f5				push af  
3c57 3a 6b 3c			ld a, (.dmark)  
3c5a 32 6e fe			ld (debug_mark),a  
3c5d 3a 6c 3c			ld a, (.dmark+1)  
3c60 32 6f fe			ld (debug_mark+1),a  
3c63 3a 6d 3c			ld a, (.dmark+2)  
3c66 32 70 fe			ld (debug_mark+2),a  
3c69 18 03			jr .pastdmark  
3c6b ..			.dmark: db "AT?"  
3c6e f1			.pastdmark: pop af  
3c6f			endm  
# End of macro DMARK
3c6f						CALLMONITOR 
3c6f cd 73 18			call break_point_state  
3c72				endm  
# End of macro CALLMONITOR
3c72					endif 
3c72 3a 68 fa				ld a, (f_cursor_ptr) 
3c75			 
3c75			if DEBUG_FORTH_WORDS 
3c75				DMARK "AT?" 
3c75 f5				push af  
3c76 3a 8a 3c			ld a, (.dmark)  
3c79 32 6e fe			ld (debug_mark),a  
3c7c 3a 8b 3c			ld a, (.dmark+1)  
3c7f 32 6f fe			ld (debug_mark+1),a  
3c82 3a 8c 3c			ld a, (.dmark+2)  
3c85 32 70 fe			ld (debug_mark+2),a  
3c88 18 03			jr .pastdmark  
3c8a ..			.dmark: db "AT?"  
3c8d f1			.pastdmark: pop af  
3c8e			endm  
# End of macro DMARK
3c8e				CALLMONITOR 
3c8e cd 73 18			call break_point_state  
3c91				endm  
# End of macro CALLMONITOR
3c91			endif	 
3c91					; count the number of rows 
3c91			 
3c91 06 00				ld b, 0 
3c93 4f			.atpr:		ld c, a    ; save in case we go below zero 
3c94 d6 28				sub display_cols 
3c96 f2 9c 3c				jp p, .atprunder 
3c99 04					inc b 
3c9a 18 f7				jr .atpr 
3c9c			.atprunder:	 
3c9c			if DEBUG_FORTH_WORDS 
3c9c				DMARK "A?2" 
3c9c f5				push af  
3c9d 3a b1 3c			ld a, (.dmark)  
3ca0 32 6e fe			ld (debug_mark),a  
3ca3 3a b2 3c			ld a, (.dmark+1)  
3ca6 32 6f fe			ld (debug_mark+1),a  
3ca9 3a b3 3c			ld a, (.dmark+2)  
3cac 32 70 fe			ld (debug_mark+2),a  
3caf 18 03			jr .pastdmark  
3cb1 ..			.dmark: db "A?2"  
3cb4 f1			.pastdmark: pop af  
3cb5			endm  
# End of macro DMARK
3cb5				CALLMONITOR 
3cb5 cd 73 18			call break_point_state  
3cb8				endm  
# End of macro CALLMONITOR
3cb8			endif	 
3cb8 26 00				ld h, 0 
3cba 69					ld l, c 
3cbb cd e7 1e				call forth_push_numhl 
3cbe 68					ld l, b  
3cbf cd e7 1e				call forth_push_numhl 
3cc2			 
3cc2			 
3cc2				NEXTW 
3cc2 c3 55 22			jp macro_next 
3cc5				endm 
# End of macro NEXTW
3cc5			 
3cc5			.FB: 
3cc5				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3cc5 1b				db WORD_SYS_CORE+7             
3cc6 13 3d			dw .EMIT            
3cc8 03				db 2 + 1 
3cc9 .. 00			db "FB",0              
3ccc				endm 
# End of macro CWHEAD
3ccc			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3ccc			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3ccc			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3ccc			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3ccc					if DEBUG_FORTH_WORDS_KEY 
3ccc						DMARK "FB." 
3ccc f5				push af  
3ccd 3a e1 3c			ld a, (.dmark)  
3cd0 32 6e fe			ld (debug_mark),a  
3cd3 3a e2 3c			ld a, (.dmark+1)  
3cd6 32 6f fe			ld (debug_mark+1),a  
3cd9 3a e3 3c			ld a, (.dmark+2)  
3cdc 32 70 fe			ld (debug_mark+2),a  
3cdf 18 03			jr .pastdmark  
3ce1 ..			.dmark: db "FB."  
3ce4 f1			.pastdmark: pop af  
3ce5			endm  
# End of macro DMARK
3ce5						CALLMONITOR 
3ce5 cd 73 18			call break_point_state  
3ce8				endm  
# End of macro CALLMONITOR
3ce8					endif 
3ce8			 
3ce8					FORTH_DSP_VALUEHL 
3ce8 cd de 20			call macro_dsp_valuehl 
3ceb				endm 
# End of macro FORTH_DSP_VALUEHL
3ceb			 
3ceb 7d					ld a, l 
3cec fe 01				cp 1 
3cee 20 05				jr nz, .fbn1 
3cf0 21 13 fd				ld hl, display_fb1 
3cf3 18 15				jr .fbset 
3cf5 fe 02		.fbn1:		cp 2 
3cf7 20 05				jr nz, .fbn2 
3cf9 21 d1 fb				ld hl, display_fb2 
3cfc 18 0c				jr .fbset 
3cfe fe 03		.fbn2:		cp 3 
3d00 20 05				jr nz, .fbn3 
3d02 21 72 fc				ld hl, display_fb3 
3d05 18 03				jr .fbset 
3d07			.fbn3:		 ; if invalid number select first 
3d07 21 13 fd				ld hl, display_fb1 
3d0a 22 cf fb		.fbset:		ld (display_fb_active), hl 
3d0d			 
3d0d					FORTH_DSP_POP 
3d0d cd 96 21			call macro_forth_dsp_pop 
3d10				endm 
# End of macro FORTH_DSP_POP
3d10			 
3d10					NEXTW 
3d10 c3 55 22			jp macro_next 
3d13				endm 
# End of macro NEXTW
3d13			 
3d13			 
3d13			.EMIT: 
3d13				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3d13 1b				db WORD_SYS_CORE+7             
3d14 64 3d			dw .DOTH            
3d16 05				db 4 + 1 
3d17 .. 00			db "EMIT",0              
3d1c				endm 
# End of macro CWHEAD
3d1c			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3d1c					; get value off TOS and display it 
3d1c			 
3d1c					if DEBUG_FORTH_WORDS_KEY 
3d1c						DMARK "EMT" 
3d1c f5				push af  
3d1d 3a 31 3d			ld a, (.dmark)  
3d20 32 6e fe			ld (debug_mark),a  
3d23 3a 32 3d			ld a, (.dmark+1)  
3d26 32 6f fe			ld (debug_mark+1),a  
3d29 3a 33 3d			ld a, (.dmark+2)  
3d2c 32 70 fe			ld (debug_mark+2),a  
3d2f 18 03			jr .pastdmark  
3d31 ..			.dmark: db "EMT"  
3d34 f1			.pastdmark: pop af  
3d35			endm  
# End of macro DMARK
3d35						CALLMONITOR 
3d35 cd 73 18			call break_point_state  
3d38				endm  
# End of macro CALLMONITOR
3d38					endif 
3d38			 
3d38					FORTH_DSP_VALUEHL 
3d38 cd de 20			call macro_dsp_valuehl 
3d3b				endm 
# End of macro FORTH_DSP_VALUEHL
3d3b			 
3d3b 7d					ld a,l 
3d3c			 
3d3c					; TODO write to display 
3d3c			 
3d3c 32 fd f3				ld (os_input), a 
3d3f 3e 00				ld a, 0 
3d41 32 fe f3				ld (os_input+1), a 
3d44					 
3d44 3a 68 fa				ld a, (f_cursor_ptr) 
3d47 11 fd f3				ld de, os_input 
3d4a cd ab 0c				call str_at_display 
3d4d			 
3d4d			 
3d4d 3a 46 fa				ld a,(cli_autodisplay) 
3d50 fe 00				cp 0 
3d52 28 03				jr z, .enoupdate 
3d54 cd bb 0c						call update_display 
3d57					.enoupdate: 
3d57			 
3d57 3a 68 fa				ld a, (f_cursor_ptr) 
3d5a 3c					inc a 
3d5b 32 68 fa				ld (f_cursor_ptr), a   ; save new pos 
3d5e			 
3d5e			 
3d5e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d5e cd 96 21			call macro_forth_dsp_pop 
3d61				endm 
# End of macro FORTH_DSP_POP
3d61			  
3d61			 
3d61					NEXTW 
3d61 c3 55 22			jp macro_next 
3d64				endm 
# End of macro NEXTW
3d64			.DOTH: 
3d64				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3d64 1c				db WORD_SYS_CORE+8             
3d65 94 3d			dw .DOTF            
3d67 03				db 2 + 1 
3d68 .. 00			db ".-",0              
3d6b				endm 
# End of macro CWHEAD
3d6b			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3d6b					; get value off TOS and display it 
3d6b					if DEBUG_FORTH_WORDS_KEY 
3d6b						DMARK "DTD" 
3d6b f5				push af  
3d6c 3a 80 3d			ld a, (.dmark)  
3d6f 32 6e fe			ld (debug_mark),a  
3d72 3a 81 3d			ld a, (.dmark+1)  
3d75 32 6f fe			ld (debug_mark+1),a  
3d78 3a 82 3d			ld a, (.dmark+2)  
3d7b 32 70 fe			ld (debug_mark+2),a  
3d7e 18 03			jr .pastdmark  
3d80 ..			.dmark: db "DTD"  
3d83 f1			.pastdmark: pop af  
3d84			endm  
# End of macro DMARK
3d84						CALLMONITOR 
3d84 cd 73 18			call break_point_state  
3d87				endm  
# End of macro CALLMONITOR
3d87					endif 
3d87 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3d89 3e 00			ld a, 0 
3d8b 32 47 fa			ld (cli_mvdot), a 
3d8e c3 eb 3d			jp .dotgo 
3d91				NEXTW 
3d91 c3 55 22			jp macro_next 
3d94				endm 
# End of macro NEXTW
3d94			.DOTF: 
3d94				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3d94 1c				db WORD_SYS_CORE+8             
3d95 c2 3d			dw .DOT            
3d97 03				db 2 + 1 
3d98 .. 00			db ".>",0              
3d9b				endm 
# End of macro CWHEAD
3d9b			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3d9b					; get value off TOS and display it 
3d9b			        ; TODO BUG adds extra spaces 
3d9b			        ; TODO BUG handle numerics? 
3d9b					if DEBUG_FORTH_WORDS_KEY 
3d9b						DMARK "DTC" 
3d9b f5				push af  
3d9c 3a b0 3d			ld a, (.dmark)  
3d9f 32 6e fe			ld (debug_mark),a  
3da2 3a b1 3d			ld a, (.dmark+1)  
3da5 32 6f fe			ld (debug_mark+1),a  
3da8 3a b2 3d			ld a, (.dmark+2)  
3dab 32 70 fe			ld (debug_mark+2),a  
3dae 18 03			jr .pastdmark  
3db0 ..			.dmark: db "DTC"  
3db3 f1			.pastdmark: pop af  
3db4			endm  
# End of macro DMARK
3db4						CALLMONITOR 
3db4 cd 73 18			call break_point_state  
3db7				endm  
# End of macro CALLMONITOR
3db7					endif 
3db7 3e 01			ld a, 1 
3db9 32 47 fa			ld (cli_mvdot), a 
3dbc c3 eb 3d			jp .dotgo 
3dbf				NEXTW 
3dbf c3 55 22			jp macro_next 
3dc2				endm 
# End of macro NEXTW
3dc2			 
3dc2			.DOT: 
3dc2				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3dc2 1c				db WORD_SYS_CORE+8             
3dc3 4e 3e			dw .CLS            
3dc5 02				db 1 + 1 
3dc6 .. 00			db ".",0              
3dc8				endm 
# End of macro CWHEAD
3dc8			        ; | . ( u -- ) Display TOS | DONE 
3dc8					; get value off TOS and display it 
3dc8			 
3dc8					if DEBUG_FORTH_WORDS_KEY 
3dc8						DMARK "DOT" 
3dc8 f5				push af  
3dc9 3a dd 3d			ld a, (.dmark)  
3dcc 32 6e fe			ld (debug_mark),a  
3dcf 3a de 3d			ld a, (.dmark+1)  
3dd2 32 6f fe			ld (debug_mark+1),a  
3dd5 3a df 3d			ld a, (.dmark+2)  
3dd8 32 70 fe			ld (debug_mark+2),a  
3ddb 18 03			jr .pastdmark  
3ddd ..			.dmark: db "DOT"  
3de0 f1			.pastdmark: pop af  
3de1			endm  
# End of macro DMARK
3de1						CALLMONITOR 
3de1 cd 73 18			call break_point_state  
3de4				endm  
# End of macro CALLMONITOR
3de4					endif 
3de4 3e 00			ld a, 0 
3de6 32 47 fa			ld (cli_mvdot), a 
3de9 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3deb				 
3deb			 
3deb			.dotgo: 
3deb			 
3deb			; move up type to on stack for parserv5 
3deb					FORTH_DSP 
3deb cd a4 20			call macro_forth_dsp 
3dee				endm 
# End of macro FORTH_DSP
3dee				;FORTH_DSP_VALUE  
3dee			 
3dee			if DEBUG_FORTH_DOT 
3dee				DMARK "DOT" 
3dee				CALLMONITOR 
3dee			endif	 
3dee			;		.print: 
3dee			 
3dee 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3def 23				inc hl   ; position to the actual value 
3df0 fe 01			cp DS_TYPE_STR 
3df2 20 06			jr nz, .dotnum1  
3df4			 
3df4			; display string 
3df4				FORTH_DSP_VALUE  
3df4 cd c7 20			call macro_forth_dsp_value 
3df7				endm 
# End of macro FORTH_DSP_VALUE
3df7 eb				ex de,hl 
3df8 18 11			jr .dotwrite 
3dfa			 
3dfa			.dotnum1: 
3dfa fe 02			cp DS_TYPE_INUM 
3dfc 20 0c			jr nz, .dotflot 
3dfe			 
3dfe			 
3dfe			; display number 
3dfe			 
3dfe			;	push hl 
3dfe			;	call clear_display 
3dfe			;	pop hl 
3dfe			 
3dfe 5e				ld e, (hl) 
3dff 23				inc hl 
3e00 56				ld d, (hl) 
3e01 21 ff f1			ld hl, scratch 
3e04			if DEBUG_FORTH_DOT 
3e04				DMARK "DT1" 
3e04				CALLMONITOR 
3e04			endif	 
3e04			 
3e04 cd d9 12			call uitoa_16 
3e07 eb				ex de,hl 
3e08			 
3e08			if DEBUG_FORTH_DOT 
3e08				DMARK "DT2" 
3e08				CALLMONITOR 
3e08			endif	 
3e08			 
3e08			;	ld de, os_word_scratch 
3e08 18 01			jr .dotwrite 
3e0a			 
3e0a 00			.dotflot:   nop 
3e0b			; TODO print floating point number 
3e0b			 
3e0b			.dotwrite:		 
3e0b			 
3e0b					; if c is set then set all '-' to spaces 
3e0b					; need to also take into account .>  
3e0b			 
3e0b 3e 01				ld a, 1 
3e0d b9					cp c 
3e0e 20 13				jr nz, .nodashswap 
3e10			 
3e10					; DE has the string to write, working with HL 
3e10			 
3e10 06 ff				ld b, 255 
3e12 d5					push de 
3e13 e1					pop hl 
3e14			 
3e14			if DEBUG_FORTH_DOT 
3e14				DMARK "DT-" 
3e14				CALLMONITOR 
3e14			endif	 
3e14 7e			.dashscan:	ld a, (hl) 
3e15 fe 00				cp 0 
3e17 28 0a				jr z, .nodashswap 
3e19 fe 2d				cp '-' 
3e1b 20 03				jr nz, .dashskip 
3e1d 3e 20				ld a, ' ' 
3e1f 77					ld (hl), a 
3e20 23			.dashskip:	inc hl 
3e21			if DEBUG_FORTH_DOT 
3e21				DMARK "D-2" 
3e21				CALLMONITOR 
3e21			endif	 
3e21 10 f1				djnz .dashscan 
3e23			 
3e23			if DEBUG_FORTH_DOT 
3e23				DMARK "D-1" 
3e23				CALLMONITOR 
3e23			endif	 
3e23			 
3e23			.nodashswap: 
3e23			 
3e23 e5					push hl   ; save string start in case we need to advance print 
3e24			 
3e24 3a 68 fa				ld a, (f_cursor_ptr) 
3e27 cd ab 0c				call str_at_display 
3e2a 3a 46 fa				ld a,(cli_autodisplay) 
3e2d fe 00				cp 0 
3e2f 28 03				jr z, .noupdate 
3e31 cd bb 0c						call update_display 
3e34					.noupdate: 
3e34			 
3e34			 
3e34					; see if we need to advance the print position 
3e34			 
3e34 e1					pop hl   ; get back string 
3e35			 
3e35 3a 47 fa				ld a, (cli_mvdot) 
3e38			if DEBUG_FORTH_DOT 
3e38					ld e,a 
3e38				DMARK "D>1" 
3e38				CALLMONITOR 
3e38			endif	 
3e38 fe 00				cp 0 
3e3a 28 0c				jr z, .noadv 
3e3c					; yes, lets advance the print position 
3e3c 3e 00				ld a, 0 
3e3e cd 35 13				call strlent 
3e41 3a 68 fa				ld a, (f_cursor_ptr) 
3e44 85					add a,l 
3e45					;call addatohl 
3e45					;ld a, l 
3e45 32 68 fa				ld (f_cursor_ptr), a   ; save new pos 
3e48			 
3e48			if DEBUG_FORTH_DOT 
3e48				DMARK "D->" 
3e48				CALLMONITOR 
3e48			endif	 
3e48			 
3e48			.noadv:	 
3e48			 
3e48					if DEBUG_FORTH_DOT_WAIT 
3e48							call next_page_prompt 
3e48					endif	 
3e48			; TODO this pop off the stack causes a crash. i dont know why 
3e48			 
3e48			 
3e48			if DEBUG_FORTH_DOT 
3e48				DMARK "DTh" 
3e48				CALLMONITOR 
3e48			endif	 
3e48			 
3e48					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e48 cd 96 21			call macro_forth_dsp_pop 
3e4b				endm 
# End of macro FORTH_DSP_POP
3e4b			 
3e4b			if DEBUG_FORTH_DOT 
3e4b				DMARK "DTi" 
3e4b				CALLMONITOR 
3e4b			endif	 
3e4b			 
3e4b			 
3e4b					NEXTW 
3e4b c3 55 22			jp macro_next 
3e4e				endm 
# End of macro NEXTW
3e4e			 
3e4e			.CLS: 
3e4e				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3e4e 35				db WORD_SYS_CORE+33             
3e4f 7b 3e			dw .DRAW            
3e51 04				db 3 + 1 
3e52 .. 00			db "CLS",0              
3e56				endm 
# End of macro CWHEAD
3e56			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3e56					if DEBUG_FORTH_WORDS_KEY 
3e56						DMARK "CLS" 
3e56 f5				push af  
3e57 3a 6b 3e			ld a, (.dmark)  
3e5a 32 6e fe			ld (debug_mark),a  
3e5d 3a 6c 3e			ld a, (.dmark+1)  
3e60 32 6f fe			ld (debug_mark+1),a  
3e63 3a 6d 3e			ld a, (.dmark+2)  
3e66 32 70 fe			ld (debug_mark+2),a  
3e69 18 03			jr .pastdmark  
3e6b ..			.dmark: db "CLS"  
3e6e f1			.pastdmark: pop af  
3e6f			endm  
# End of macro DMARK
3e6f						CALLMONITOR 
3e6f cd 73 18			call break_point_state  
3e72				endm  
# End of macro CALLMONITOR
3e72					endif 
3e72 cd 98 0c				call clear_display 
3e75 c3 89 3f				jp .home		; and home cursor 
3e78					NEXTW 
3e78 c3 55 22			jp macro_next 
3e7b				endm 
# End of macro NEXTW
3e7b			 
3e7b			.DRAW: 
3e7b				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3e7b 36				db WORD_SYS_CORE+34             
3e7c a6 3e			dw .DUMP            
3e7e 05				db 4 + 1 
3e7f .. 00			db "DRAW",0              
3e84				endm 
# End of macro CWHEAD
3e84			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3e84					if DEBUG_FORTH_WORDS_KEY 
3e84						DMARK "DRW" 
3e84 f5				push af  
3e85 3a 99 3e			ld a, (.dmark)  
3e88 32 6e fe			ld (debug_mark),a  
3e8b 3a 9a 3e			ld a, (.dmark+1)  
3e8e 32 6f fe			ld (debug_mark+1),a  
3e91 3a 9b 3e			ld a, (.dmark+2)  
3e94 32 70 fe			ld (debug_mark+2),a  
3e97 18 03			jr .pastdmark  
3e99 ..			.dmark: db "DRW"  
3e9c f1			.pastdmark: pop af  
3e9d			endm  
# End of macro DMARK
3e9d						CALLMONITOR 
3e9d cd 73 18			call break_point_state  
3ea0				endm  
# End of macro CALLMONITOR
3ea0					endif 
3ea0 cd bb 0c				call update_display 
3ea3					NEXTW 
3ea3 c3 55 22			jp macro_next 
3ea6				endm 
# End of macro NEXTW
3ea6			 
3ea6			.DUMP: 
3ea6				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3ea6 37				db WORD_SYS_CORE+35             
3ea7 de 3e			dw .CDUMP            
3ea9 05				db 4 + 1 
3eaa .. 00			db "DUMP",0              
3eaf				endm 
# End of macro CWHEAD
3eaf			; | DUMP ( x -- ) With address x display dump   | DONE 
3eaf			; TODO pop address to use off of the stack 
3eaf					if DEBUG_FORTH_WORDS_KEY 
3eaf						DMARK "DUM" 
3eaf f5				push af  
3eb0 3a c4 3e			ld a, (.dmark)  
3eb3 32 6e fe			ld (debug_mark),a  
3eb6 3a c5 3e			ld a, (.dmark+1)  
3eb9 32 6f fe			ld (debug_mark+1),a  
3ebc 3a c6 3e			ld a, (.dmark+2)  
3ebf 32 70 fe			ld (debug_mark+2),a  
3ec2 18 03			jr .pastdmark  
3ec4 ..			.dmark: db "DUM"  
3ec7 f1			.pastdmark: pop af  
3ec8			endm  
# End of macro DMARK
3ec8						CALLMONITOR 
3ec8 cd 73 18			call break_point_state  
3ecb				endm  
# End of macro CALLMONITOR
3ecb					endif 
3ecb cd 98 0c				call clear_display 
3ece			 
3ece					; get address 
3ece			 
3ece					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ece cd de 20			call macro_dsp_valuehl 
3ed1				endm 
# End of macro FORTH_DSP_VALUEHL
3ed1				 
3ed1					; save it for cdump 
3ed1			 
3ed1 22 22 f5				ld (os_cur_ptr),hl 
3ed4			 
3ed4					; destroy value TOS 
3ed4			 
3ed4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ed4 cd 96 21			call macro_forth_dsp_pop 
3ed7				endm 
# End of macro FORTH_DSP_POP
3ed7			 
3ed7 cd 67 1d				call dumpcont	; skip old style of param parsing	 
3eda c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3edb					NEXTW 
3edb c3 55 22			jp macro_next 
3ede				endm 
# End of macro NEXTW
3ede			.CDUMP: 
3ede				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3ede 38				db WORD_SYS_CORE+36             
3edf 0e 3f			dw .DAT            
3ee1 06				db 5 + 1 
3ee2 .. 00			db "CDUMP",0              
3ee8				endm 
# End of macro CWHEAD
3ee8			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3ee8					if DEBUG_FORTH_WORDS_KEY 
3ee8						DMARK "CDP" 
3ee8 f5				push af  
3ee9 3a fd 3e			ld a, (.dmark)  
3eec 32 6e fe			ld (debug_mark),a  
3eef 3a fe 3e			ld a, (.dmark+1)  
3ef2 32 6f fe			ld (debug_mark+1),a  
3ef5 3a ff 3e			ld a, (.dmark+2)  
3ef8 32 70 fe			ld (debug_mark+2),a  
3efb 18 03			jr .pastdmark  
3efd ..			.dmark: db "CDP"  
3f00 f1			.pastdmark: pop af  
3f01			endm  
# End of macro DMARK
3f01						CALLMONITOR 
3f01 cd 73 18			call break_point_state  
3f04				endm  
# End of macro CALLMONITOR
3f04					endif 
3f04 cd 98 0c				call clear_display 
3f07 cd 67 1d				call dumpcont	 
3f0a c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3f0b					NEXTW 
3f0b c3 55 22			jp macro_next 
3f0e				endm 
# End of macro NEXTW
3f0e			 
3f0e			 
3f0e			 
3f0e			 
3f0e			.DAT: 
3f0e				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3f0e 3d				db WORD_SYS_CORE+41             
3f0f 64 3f			dw .HOME            
3f11 03				db 2 + 1 
3f12 .. 00			db "AT",0              
3f15				endm 
# End of macro CWHEAD
3f15			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3f15					if DEBUG_FORTH_WORDS_KEY 
3f15						DMARK "AT." 
3f15 f5				push af  
3f16 3a 2a 3f			ld a, (.dmark)  
3f19 32 6e fe			ld (debug_mark),a  
3f1c 3a 2b 3f			ld a, (.dmark+1)  
3f1f 32 6f fe			ld (debug_mark+1),a  
3f22 3a 2c 3f			ld a, (.dmark+2)  
3f25 32 70 fe			ld (debug_mark+2),a  
3f28 18 03			jr .pastdmark  
3f2a ..			.dmark: db "AT."  
3f2d f1			.pastdmark: pop af  
3f2e			endm  
# End of macro DMARK
3f2e						CALLMONITOR 
3f2e cd 73 18			call break_point_state  
3f31				endm  
# End of macro CALLMONITOR
3f31					endif 
3f31					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f31 cd de 20			call macro_dsp_valuehl 
3f34				endm 
# End of macro FORTH_DSP_VALUEHL
3f34			 
3f34			 
3f34					; TODO save cursor row 
3f34 7d					ld a,l 
3f35 fe 02				cp 2 
3f37 20 04				jr nz, .crow3 
3f39 3e 28				ld a, display_row_2 
3f3b 18 12				jr .ccol1 
3f3d fe 03		.crow3:		cp 3 
3f3f 20 04				jr nz, .crow4 
3f41 3e 50				ld a, display_row_3 
3f43 18 0a				jr .ccol1 
3f45 fe 04		.crow4:		cp 4 
3f47 20 04				jr nz, .crow1 
3f49 3e 78				ld a, display_row_4 
3f4b 18 02				jr .ccol1 
3f4d 3e 00		.crow1:		ld a,display_row_1 
3f4f f5			.ccol1:		push af			; got row offset 
3f50 6f					ld l,a 
3f51 26 00				ld h,0 
3f53					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f53 cd 96 21			call macro_forth_dsp_pop 
3f56				endm 
# End of macro FORTH_DSP_POP
3f56					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f56 cd de 20			call macro_dsp_valuehl 
3f59				endm 
# End of macro FORTH_DSP_VALUEHL
3f59					; TODO save cursor col 
3f59 f1					pop af 
3f5a 85					add l		; add col offset 
3f5b 32 68 fa				ld (f_cursor_ptr), a 
3f5e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f5e cd 96 21			call macro_forth_dsp_pop 
3f61				endm 
# End of macro FORTH_DSP_POP
3f61			 
3f61					; calculate  
3f61			 
3f61					NEXTW 
3f61 c3 55 22			jp macro_next 
3f64				endm 
# End of macro NEXTW
3f64			 
3f64			 
3f64			.HOME: 
3f64				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3f64 41				db WORD_SYS_CORE+45             
3f65 91 3f			dw .SPACE            
3f67 05				db 4 + 1 
3f68 .. 00			db "HOME",0              
3f6d				endm 
# End of macro CWHEAD
3f6d			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3f6d					if DEBUG_FORTH_WORDS_KEY 
3f6d						DMARK "HOM" 
3f6d f5				push af  
3f6e 3a 82 3f			ld a, (.dmark)  
3f71 32 6e fe			ld (debug_mark),a  
3f74 3a 83 3f			ld a, (.dmark+1)  
3f77 32 6f fe			ld (debug_mark+1),a  
3f7a 3a 84 3f			ld a, (.dmark+2)  
3f7d 32 70 fe			ld (debug_mark+2),a  
3f80 18 03			jr .pastdmark  
3f82 ..			.dmark: db "HOM"  
3f85 f1			.pastdmark: pop af  
3f86			endm  
# End of macro DMARK
3f86						CALLMONITOR 
3f86 cd 73 18			call break_point_state  
3f89				endm  
# End of macro CALLMONITOR
3f89					endif 
3f89 3e 00		.home:		ld a, 0		; and home cursor 
3f8b 32 68 fa				ld (f_cursor_ptr), a 
3f8e					NEXTW 
3f8e c3 55 22			jp macro_next 
3f91				endm 
# End of macro NEXTW
3f91			 
3f91			 
3f91			.SPACE: 
3f91				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3f91 46				db WORD_SYS_CORE+50             
3f92 bf 3f			dw .SPACES            
3f94 03				db 2 + 1 
3f95 .. 00			db "BL",0              
3f98				endm 
# End of macro CWHEAD
3f98			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3f98					if DEBUG_FORTH_WORDS_KEY 
3f98						DMARK "BL." 
3f98 f5				push af  
3f99 3a ad 3f			ld a, (.dmark)  
3f9c 32 6e fe			ld (debug_mark),a  
3f9f 3a ae 3f			ld a, (.dmark+1)  
3fa2 32 6f fe			ld (debug_mark+1),a  
3fa5 3a af 3f			ld a, (.dmark+2)  
3fa8 32 70 fe			ld (debug_mark+2),a  
3fab 18 03			jr .pastdmark  
3fad ..			.dmark: db "BL."  
3fb0 f1			.pastdmark: pop af  
3fb1			endm  
# End of macro DMARK
3fb1						CALLMONITOR 
3fb1 cd 73 18			call break_point_state  
3fb4				endm  
# End of macro CALLMONITOR
3fb4					endif 
3fb4 21 bd 3f				ld hl, .blstr 
3fb7 cd 55 1f				call forth_push_str 
3fba					 
3fba				       NEXTW 
3fba c3 55 22			jp macro_next 
3fbd				endm 
# End of macro NEXTW
3fbd			 
3fbd .. 00		.blstr: db " ", 0 
3fbf			 
3fbf			.SPACES: 
3fbf				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3fbf 47				db WORD_SYS_CORE+51             
3fc0 5a 40			dw .SCROLL            
3fc2 07				db 6 + 1 
3fc3 .. 00			db "SPACES",0              
3fca				endm 
# End of macro CWHEAD
3fca			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3fca					if DEBUG_FORTH_WORDS_KEY 
3fca						DMARK "SPS" 
3fca f5				push af  
3fcb 3a df 3f			ld a, (.dmark)  
3fce 32 6e fe			ld (debug_mark),a  
3fd1 3a e0 3f			ld a, (.dmark+1)  
3fd4 32 6f fe			ld (debug_mark+1),a  
3fd7 3a e1 3f			ld a, (.dmark+2)  
3fda 32 70 fe			ld (debug_mark+2),a  
3fdd 18 03			jr .pastdmark  
3fdf ..			.dmark: db "SPS"  
3fe2 f1			.pastdmark: pop af  
3fe3			endm  
# End of macro DMARK
3fe3						CALLMONITOR 
3fe3 cd 73 18			call break_point_state  
3fe6				endm  
# End of macro CALLMONITOR
3fe6					endif 
3fe6			 
3fe6			 
3fe6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fe6 cd de 20			call macro_dsp_valuehl 
3fe9				endm 
# End of macro FORTH_DSP_VALUEHL
3fe9			 
3fe9			;		push hl    ; u 
3fe9					if DEBUG_FORTH_WORDS 
3fe9						DMARK "SPA" 
3fe9 f5				push af  
3fea 3a fe 3f			ld a, (.dmark)  
3fed 32 6e fe			ld (debug_mark),a  
3ff0 3a ff 3f			ld a, (.dmark+1)  
3ff3 32 6f fe			ld (debug_mark+1),a  
3ff6 3a 00 40			ld a, (.dmark+2)  
3ff9 32 70 fe			ld (debug_mark+2),a  
3ffc 18 03			jr .pastdmark  
3ffe ..			.dmark: db "SPA"  
4001 f1			.pastdmark: pop af  
4002			endm  
# End of macro DMARK
4002						CALLMONITOR 
4002 cd 73 18			call break_point_state  
4005				endm  
# End of macro CALLMONITOR
4005					endif 
4005			 
4005					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4005 cd 96 21			call macro_forth_dsp_pop 
4008				endm 
# End of macro FORTH_DSP_POP
4008			;		pop hl 
4008 4d					ld c, l 
4009 06 00				ld b, 0 
400b 21 ff f1				ld hl, scratch  
400e			 
400e					if DEBUG_FORTH_WORDS 
400e						DMARK "SP2" 
400e f5				push af  
400f 3a 23 40			ld a, (.dmark)  
4012 32 6e fe			ld (debug_mark),a  
4015 3a 24 40			ld a, (.dmark+1)  
4018 32 6f fe			ld (debug_mark+1),a  
401b 3a 25 40			ld a, (.dmark+2)  
401e 32 70 fe			ld (debug_mark+2),a  
4021 18 03			jr .pastdmark  
4023 ..			.dmark: db "SP2"  
4026 f1			.pastdmark: pop af  
4027			endm  
# End of macro DMARK
4027						CALLMONITOR 
4027 cd 73 18			call break_point_state  
402a				endm  
# End of macro CALLMONITOR
402a					endif 
402a 3e 20				ld a, ' ' 
402c c5			.spaces1:	push bc 
402d 77					ld (hl),a 
402e 23					inc hl 
402f c1					pop bc 
4030 10 fa				djnz .spaces1 
4032 3e 00				ld a,0 
4034 77					ld (hl),a 
4035 21 ff f1				ld hl, scratch 
4038					if DEBUG_FORTH_WORDS 
4038						DMARK "SP3" 
4038 f5				push af  
4039 3a 4d 40			ld a, (.dmark)  
403c 32 6e fe			ld (debug_mark),a  
403f 3a 4e 40			ld a, (.dmark+1)  
4042 32 6f fe			ld (debug_mark+1),a  
4045 3a 4f 40			ld a, (.dmark+2)  
4048 32 70 fe			ld (debug_mark+2),a  
404b 18 03			jr .pastdmark  
404d ..			.dmark: db "SP3"  
4050 f1			.pastdmark: pop af  
4051			endm  
# End of macro DMARK
4051						CALLMONITOR 
4051 cd 73 18			call break_point_state  
4054				endm  
# End of macro CALLMONITOR
4054					endif 
4054 cd 50 20				call forth_apush 
4057			 
4057				       NEXTW 
4057 c3 55 22			jp macro_next 
405a				endm 
# End of macro NEXTW
405a			 
405a			 
405a			 
405a			.SCROLL: 
405a				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
405a 53				db WORD_SYS_CORE+63             
405b 87 40			dw .SCROLLD            
405d 07				db 6 + 1 
405e .. 00			db "SCROLL",0              
4065				endm 
# End of macro CWHEAD
4065			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4065					if DEBUG_FORTH_WORDS_KEY 
4065						DMARK "SCR" 
4065 f5				push af  
4066 3a 7a 40			ld a, (.dmark)  
4069 32 6e fe			ld (debug_mark),a  
406c 3a 7b 40			ld a, (.dmark+1)  
406f 32 6f fe			ld (debug_mark+1),a  
4072 3a 7c 40			ld a, (.dmark+2)  
4075 32 70 fe			ld (debug_mark+2),a  
4078 18 03			jr .pastdmark  
407a ..			.dmark: db "SCR"  
407d f1			.pastdmark: pop af  
407e			endm  
# End of macro DMARK
407e						CALLMONITOR 
407e cd 73 18			call break_point_state  
4081				endm  
# End of macro CALLMONITOR
4081					endif 
4081			 
4081 cd 5a 0c			call scroll_up 
4084			;	call update_display 
4084			 
4084					NEXTW 
4084 c3 55 22			jp macro_next 
4087				endm 
# End of macro NEXTW
4087			 
4087			 
4087			 
4087			;		; get dir 
4087			; 
4087			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4087			; 
4087			;		push hl 
4087			; 
4087			;		; destroy value TOS 
4087			; 
4087			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4087			; 
4087			;		; get count 
4087			; 
4087			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4087			; 
4087			;		push hl 
4087			; 
4087			;		; destroy value TOS 
4087			; 
4087			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4087			; 
4087			;		; one value on hl get other one back 
4087			; 
4087			;		pop bc    ; count 
4087			; 
4087			;		pop de   ; dir 
4087			; 
4087			; 
4087			;		ld b, c 
4087			; 
4087			;.scrolldir:     push bc 
4087			;		push de 
4087			; 
4087			;		ld a, 0 
4087			;		cp e 
4087			;		jr z, .scrollup  
4087			;		call scroll_down 
4087			;		jr .scrollnext 
4087			;.scrollup:	call scroll_up 
4087			; 
4087			;		 
4087			;.scrollnext: 
4087			;		pop de 
4087			;		pop bc 
4087			;		djnz .scrolldir 
4087			; 
4087			; 
4087			; 
4087			; 
4087			; 
4087			;		NEXTW 
4087			 
4087			.SCROLLD: 
4087				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4087 53				db WORD_SYS_CORE+63             
4088 b5 40			dw .ATQ            
408a 08				db 7 + 1 
408b .. 00			db "SCROLLD",0              
4093				endm 
# End of macro CWHEAD
4093			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4093					if DEBUG_FORTH_WORDS_KEY 
4093						DMARK "SCD" 
4093 f5				push af  
4094 3a a8 40			ld a, (.dmark)  
4097 32 6e fe			ld (debug_mark),a  
409a 3a a9 40			ld a, (.dmark+1)  
409d 32 6f fe			ld (debug_mark+1),a  
40a0 3a aa 40			ld a, (.dmark+2)  
40a3 32 70 fe			ld (debug_mark+2),a  
40a6 18 03			jr .pastdmark  
40a8 ..			.dmark: db "SCD"  
40ab f1			.pastdmark: pop af  
40ac			endm  
# End of macro DMARK
40ac						CALLMONITOR 
40ac cd 73 18			call break_point_state  
40af				endm  
# End of macro CALLMONITOR
40af					endif 
40af			 
40af cd 7e 0c			call scroll_down 
40b2			;	call update_display 
40b2			 
40b2					NEXTW 
40b2 c3 55 22			jp macro_next 
40b5				endm 
# End of macro NEXTW
40b5			 
40b5			 
40b5			.ATQ: 
40b5				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
40b5 62				db WORD_SYS_CORE+78             
40b6 13 41			dw .AUTODSP            
40b8 04				db 3 + 1 
40b9 .. 00			db "AT@",0              
40bd				endm 
# End of macro CWHEAD
40bd			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
40bd					if DEBUG_FORTH_WORDS_KEY 
40bd						DMARK "ATA" 
40bd f5				push af  
40be 3a d2 40			ld a, (.dmark)  
40c1 32 6e fe			ld (debug_mark),a  
40c4 3a d3 40			ld a, (.dmark+1)  
40c7 32 6f fe			ld (debug_mark+1),a  
40ca 3a d4 40			ld a, (.dmark+2)  
40cd 32 70 fe			ld (debug_mark+2),a  
40d0 18 03			jr .pastdmark  
40d2 ..			.dmark: db "ATA"  
40d5 f1			.pastdmark: pop af  
40d6			endm  
# End of macro DMARK
40d6						CALLMONITOR 
40d6 cd 73 18			call break_point_state  
40d9				endm  
# End of macro CALLMONITOR
40d9					endif 
40d9			 
40d9			 
40d9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40d9 cd de 20			call macro_dsp_valuehl 
40dc				endm 
# End of macro FORTH_DSP_VALUEHL
40dc			 
40dc					; TODO save cursor row 
40dc 7d					ld a,l 
40dd fe 02				cp 2 
40df 20 04				jr nz, .crow3aq 
40e1 3e 28				ld a, display_row_2 
40e3 18 12				jr .ccol1aq 
40e5 fe 03		.crow3aq:		cp 3 
40e7 20 04				jr nz, .crow4aq 
40e9 3e 50				ld a, display_row_3 
40eb 18 0a				jr .ccol1aq 
40ed fe 04		.crow4aq:		cp 4 
40ef 20 04				jr nz, .crow1aq 
40f1 3e 78				ld a, display_row_4 
40f3 18 02				jr .ccol1aq 
40f5 3e 00		.crow1aq:		ld a,display_row_1 
40f7 f5			.ccol1aq:		push af			; got row offset 
40f8 6f					ld l,a 
40f9 26 00				ld h,0 
40fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40fb cd 96 21			call macro_forth_dsp_pop 
40fe				endm 
# End of macro FORTH_DSP_POP
40fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40fe cd de 20			call macro_dsp_valuehl 
4101				endm 
# End of macro FORTH_DSP_VALUEHL
4101					; TODO save cursor col 
4101 f1					pop af 
4102 85					add l		; add col offset 
4103			 
4103					; add current frame buffer address 
4103 2a cf fb				ld hl, (display_fb_active) 
4106 cd cc 0e				call addatohl 
4109			 
4109			 
4109			 
4109			 
4109					; get char frame buffer location offset in hl 
4109			 
4109 7e					ld a,(hl) 
410a 26 00				ld h, 0 
410c 6f					ld l, a 
410d			 
410d cd e7 1e				call forth_push_numhl 
4110			 
4110			 
4110					NEXTW 
4110 c3 55 22			jp macro_next 
4113				endm 
# End of macro NEXTW
4113			 
4113			.AUTODSP: 
4113				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4113 63				db WORD_SYS_CORE+79             
4114 29 41			dw .MENU            
4116 05				db 4 + 1 
4117 .. 00			db "ADSP",0              
411c				endm 
# End of macro CWHEAD
411c			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
411c			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
411c			 
411c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
411c cd de 20			call macro_dsp_valuehl 
411f				endm 
# End of macro FORTH_DSP_VALUEHL
411f			 
411f			;		push hl 
411f			 
411f					; destroy value TOS 
411f			 
411f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
411f cd 96 21			call macro_forth_dsp_pop 
4122				endm 
# End of macro FORTH_DSP_POP
4122			 
4122			;		pop hl 
4122			 
4122 7d					ld a,l 
4123 32 46 fa				ld (cli_autodisplay), a 
4126				       NEXTW 
4126 c3 55 22			jp macro_next 
4129				endm 
# End of macro NEXTW
4129			 
4129			.MENU: 
4129				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4129 70				db WORD_SYS_CORE+92             
412a d2 41			dw .ENDDISPLAY            
412c 05				db 4 + 1 
412d .. 00			db "MENU",0              
4132				endm 
# End of macro CWHEAD
4132			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
4132			 
4132			;		; get number of items on the stack 
4132			; 
4132				 
4132					FORTH_DSP_VALUEHL 
4132 cd de 20			call macro_dsp_valuehl 
4135				endm 
# End of macro FORTH_DSP_VALUEHL
4135				 
4135					if DEBUG_FORTH_WORDS_KEY 
4135						DMARK "MNU" 
4135 f5				push af  
4136 3a 4a 41			ld a, (.dmark)  
4139 32 6e fe			ld (debug_mark),a  
413c 3a 4b 41			ld a, (.dmark+1)  
413f 32 6f fe			ld (debug_mark+1),a  
4142 3a 4c 41			ld a, (.dmark+2)  
4145 32 70 fe			ld (debug_mark+2),a  
4148 18 03			jr .pastdmark  
414a ..			.dmark: db "MNU"  
414d f1			.pastdmark: pop af  
414e			endm  
# End of macro DMARK
414e						CALLMONITOR 
414e cd 73 18			call break_point_state  
4151				endm  
# End of macro CALLMONITOR
4151					endif 
4151			 
4151 45					ld b, l	 
4152 05					dec b 
4153			 
4153					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4153 cd 96 21			call macro_forth_dsp_pop 
4156				endm 
# End of macro FORTH_DSP_POP
4156			 
4156			 
4156					; go directly through the stack to pluck out the string pointers and build an array 
4156			 
4156			;		FORTH_DSP 
4156			 
4156					; hl contains top most stack item 
4156				 
4156 11 ff f1				ld de, scratch 
4159			 
4159			.mbuild: 
4159			 
4159					FORTH_DSP_VALUEHL 
4159 cd de 20			call macro_dsp_valuehl 
415c				endm 
# End of macro FORTH_DSP_VALUEHL
415c			 
415c					if DEBUG_FORTH_WORDS 
415c						DMARK "MN3" 
415c f5				push af  
415d 3a 71 41			ld a, (.dmark)  
4160 32 6e fe			ld (debug_mark),a  
4163 3a 72 41			ld a, (.dmark+1)  
4166 32 6f fe			ld (debug_mark+1),a  
4169 3a 73 41			ld a, (.dmark+2)  
416c 32 70 fe			ld (debug_mark+2),a  
416f 18 03			jr .pastdmark  
4171 ..			.dmark: db "MN3"  
4174 f1			.pastdmark: pop af  
4175			endm  
# End of macro DMARK
4175						CALLMONITOR 
4175 cd 73 18			call break_point_state  
4178				endm  
# End of macro CALLMONITOR
4178					endif 
4178 eb					ex de, hl 
4179 73					ld (hl), e 
417a 23					inc hl 
417b 72					ld (hl), d 
417c 23					inc hl 
417d eb					ex de, hl 
417e			 
417e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
417e cd 96 21			call macro_forth_dsp_pop 
4181				endm 
# End of macro FORTH_DSP_POP
4181			 
4181 10 d6				djnz .mbuild 
4183			 
4183					; done add term 
4183			 
4183 eb					ex de, hl 
4184 36 00				ld (hl), 0 
4186 23					inc hl 
4187 36 00				ld (hl), 0 
4189			 
4189				 
4189					 
4189 21 ff f1				ld hl, scratch 
418c			 
418c					if DEBUG_FORTH_WORDS 
418c						DMARK "MNx" 
418c f5				push af  
418d 3a a1 41			ld a, (.dmark)  
4190 32 6e fe			ld (debug_mark),a  
4193 3a a2 41			ld a, (.dmark+1)  
4196 32 6f fe			ld (debug_mark+1),a  
4199 3a a3 41			ld a, (.dmark+2)  
419c 32 70 fe			ld (debug_mark+2),a  
419f 18 03			jr .pastdmark  
41a1 ..			.dmark: db "MNx"  
41a4 f1			.pastdmark: pop af  
41a5			endm  
# End of macro DMARK
41a5						CALLMONITOR 
41a5 cd 73 18			call break_point_state  
41a8				endm  
# End of macro CALLMONITOR
41a8					endif 
41a8			 
41a8			 
41a8			 
41a8 3e 00				ld a, 0 
41aa cd c9 0c				call menu 
41ad			 
41ad			 
41ad 6f					ld l, a 
41ae 26 00				ld h, 0 
41b0			 
41b0					if DEBUG_FORTH_WORDS 
41b0						DMARK "MNr" 
41b0 f5				push af  
41b1 3a c5 41			ld a, (.dmark)  
41b4 32 6e fe			ld (debug_mark),a  
41b7 3a c6 41			ld a, (.dmark+1)  
41ba 32 6f fe			ld (debug_mark+1),a  
41bd 3a c7 41			ld a, (.dmark+2)  
41c0 32 70 fe			ld (debug_mark+2),a  
41c3 18 03			jr .pastdmark  
41c5 ..			.dmark: db "MNr"  
41c8 f1			.pastdmark: pop af  
41c9			endm  
# End of macro DMARK
41c9						CALLMONITOR 
41c9 cd 73 18			call break_point_state  
41cc				endm  
# End of macro CALLMONITOR
41cc					endif 
41cc			 
41cc cd e7 1e				call forth_push_numhl 
41cf			 
41cf			 
41cf			 
41cf			 
41cf				       NEXTW 
41cf c3 55 22			jp macro_next 
41d2				endm 
# End of macro NEXTW
41d2			 
41d2			 
41d2			.ENDDISPLAY: 
41d2			 
41d2			; eof 
# End of file forth_words_display.asm
41d2			include "forth_words_str.asm" 
41d2			 
41d2			; | ## String Words 
41d2			 
41d2			.PTR:   
41d2			 
41d2				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
41d2 48				db WORD_SYS_CORE+52             
41d3 ff 41			dw .STYPE            
41d5 04				db 3 + 1 
41d6 .. 00			db "PTR",0              
41da				endm 
# End of macro CWHEAD
41da			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
41da			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
41da			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
41da			 
41da					if DEBUG_FORTH_WORDS_KEY 
41da						DMARK "PTR" 
41da f5				push af  
41db 3a ef 41			ld a, (.dmark)  
41de 32 6e fe			ld (debug_mark),a  
41e1 3a f0 41			ld a, (.dmark+1)  
41e4 32 6f fe			ld (debug_mark+1),a  
41e7 3a f1 41			ld a, (.dmark+2)  
41ea 32 70 fe			ld (debug_mark+2),a  
41ed 18 03			jr .pastdmark  
41ef ..			.dmark: db "PTR"  
41f2 f1			.pastdmark: pop af  
41f3			endm  
# End of macro DMARK
41f3						CALLMONITOR 
41f3 cd 73 18			call break_point_state  
41f6				endm  
# End of macro CALLMONITOR
41f6					endif 
41f6					FORTH_DSP_VALUEHL 
41f6 cd de 20			call macro_dsp_valuehl 
41f9				endm 
# End of macro FORTH_DSP_VALUEHL
41f9 cd e7 1e				call forth_push_numhl 
41fc			 
41fc			 
41fc					NEXTW 
41fc c3 55 22			jp macro_next 
41ff				endm 
# End of macro NEXTW
41ff			.STYPE: 
41ff				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
41ff 48				db WORD_SYS_CORE+52             
4200 4e 42			dw .UPPER            
4202 06				db 5 + 1 
4203 .. 00			db "STYPE",0              
4209				endm 
# End of macro CWHEAD
4209			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4209					if DEBUG_FORTH_WORDS_KEY 
4209						DMARK "STY" 
4209 f5				push af  
420a 3a 1e 42			ld a, (.dmark)  
420d 32 6e fe			ld (debug_mark),a  
4210 3a 1f 42			ld a, (.dmark+1)  
4213 32 6f fe			ld (debug_mark+1),a  
4216 3a 20 42			ld a, (.dmark+2)  
4219 32 70 fe			ld (debug_mark+2),a  
421c 18 03			jr .pastdmark  
421e ..			.dmark: db "STY"  
4221 f1			.pastdmark: pop af  
4222			endm  
# End of macro DMARK
4222						CALLMONITOR 
4222 cd 73 18			call break_point_state  
4225				endm  
# End of macro CALLMONITOR
4225					endif 
4225					FORTH_DSP 
4225 cd a4 20			call macro_forth_dsp 
4228				endm 
# End of macro FORTH_DSP
4228					;v5 FORTH_DSP_VALUE 
4228			 
4228 7e					ld a, (hl) 
4229			 
4229 f5					push af 
422a			 
422a			; Dont destroy TOS		FORTH_DSP_POP 
422a			 
422a f1					pop af 
422b			 
422b fe 01				cp DS_TYPE_STR 
422d 28 09				jr z, .typestr 
422f			 
422f fe 02				cp DS_TYPE_INUM 
4231 28 0a				jr z, .typeinum 
4233			 
4233 21 4c 42				ld hl, .tna 
4236 18 0a				jr .tpush 
4238			 
4238 21 48 42		.typestr:	ld hl, .tstr 
423b 18 05				jr .tpush 
423d 21 4a 42		.typeinum:	ld hl, .tinum 
4240 18 00				jr .tpush 
4242			 
4242			.tpush: 
4242			 
4242 cd 55 1f				call forth_push_str 
4245			 
4245					NEXTW 
4245 c3 55 22			jp macro_next 
4248				endm 
# End of macro NEXTW
4248 .. 00		.tstr:	db "s",0 
424a .. 00		.tinum:  db "i",0 
424c .. 00		.tna:   db "?", 0 
424e			 
424e			 
424e			.UPPER: 
424e				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
424e 48				db WORD_SYS_CORE+52             
424f 89 42			dw .LOWER            
4251 06				db 5 + 1 
4252 .. 00			db "UPPER",0              
4258				endm 
# End of macro CWHEAD
4258			; | UPPER ( s -- s ) Upper case string s  | DONE 
4258					if DEBUG_FORTH_WORDS_KEY 
4258						DMARK "UPR" 
4258 f5				push af  
4259 3a 6d 42			ld a, (.dmark)  
425c 32 6e fe			ld (debug_mark),a  
425f 3a 6e 42			ld a, (.dmark+1)  
4262 32 6f fe			ld (debug_mark+1),a  
4265 3a 6f 42			ld a, (.dmark+2)  
4268 32 70 fe			ld (debug_mark+2),a  
426b 18 03			jr .pastdmark  
426d ..			.dmark: db "UPR"  
4270 f1			.pastdmark: pop af  
4271			endm  
# End of macro DMARK
4271						CALLMONITOR 
4271 cd 73 18			call break_point_state  
4274				endm  
# End of macro CALLMONITOR
4274					endif 
4274			 
4274					FORTH_DSP 
4274 cd a4 20			call macro_forth_dsp 
4277				endm 
# End of macro FORTH_DSP
4277					 
4277			; TODO check is string type 
4277			 
4277					FORTH_DSP_VALUEHL 
4277 cd de 20			call macro_dsp_valuehl 
427a				endm 
# End of macro FORTH_DSP_VALUEHL
427a			; get pointer to string in hl 
427a			 
427a 7e			.toup:		ld a, (hl) 
427b fe 00				cp 0 
427d 28 07				jr z, .toupdone 
427f			 
427f cd 39 12				call to_upper 
4282			 
4282 77					ld (hl), a 
4283 23					inc hl 
4284 18 f4				jr .toup 
4286			 
4286					 
4286			 
4286			 
4286			; for each char convert to upper 
4286					 
4286			.toupdone: 
4286			 
4286			 
4286					NEXTW 
4286 c3 55 22			jp macro_next 
4289				endm 
# End of macro NEXTW
4289			.LOWER: 
4289				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4289 48				db WORD_SYS_CORE+52             
428a c4 42			dw .TCASE            
428c 06				db 5 + 1 
428d .. 00			db "LOWER",0              
4293				endm 
# End of macro CWHEAD
4293			; | LOWER ( s -- s ) Lower case string s  | DONE 
4293					if DEBUG_FORTH_WORDS_KEY 
4293						DMARK "LWR" 
4293 f5				push af  
4294 3a a8 42			ld a, (.dmark)  
4297 32 6e fe			ld (debug_mark),a  
429a 3a a9 42			ld a, (.dmark+1)  
429d 32 6f fe			ld (debug_mark+1),a  
42a0 3a aa 42			ld a, (.dmark+2)  
42a3 32 70 fe			ld (debug_mark+2),a  
42a6 18 03			jr .pastdmark  
42a8 ..			.dmark: db "LWR"  
42ab f1			.pastdmark: pop af  
42ac			endm  
# End of macro DMARK
42ac						CALLMONITOR 
42ac cd 73 18			call break_point_state  
42af				endm  
# End of macro CALLMONITOR
42af					endif 
42af			 
42af					FORTH_DSP 
42af cd a4 20			call macro_forth_dsp 
42b2				endm 
# End of macro FORTH_DSP
42b2					 
42b2			; TODO check is string type 
42b2			 
42b2					FORTH_DSP_VALUEHL 
42b2 cd de 20			call macro_dsp_valuehl 
42b5				endm 
# End of macro FORTH_DSP_VALUEHL
42b5			; get pointer to string in hl 
42b5			 
42b5 7e			.tolow:		ld a, (hl) 
42b6 fe 00				cp 0 
42b8 28 07				jr z, .tolowdone 
42ba			 
42ba cd 42 12				call to_lower 
42bd			 
42bd 77					ld (hl), a 
42be 23					inc hl 
42bf 18 f4				jr .tolow 
42c1			 
42c1					 
42c1			 
42c1			 
42c1			; for each char convert to low 
42c1					 
42c1			.tolowdone: 
42c1					NEXTW 
42c1 c3 55 22			jp macro_next 
42c4				endm 
# End of macro NEXTW
42c4			.TCASE: 
42c4				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
42c4 48				db WORD_SYS_CORE+52             
42c5 fa 43			dw .SUBSTR            
42c7 06				db 5 + 1 
42c8 .. 00			db "TCASE",0              
42ce				endm 
# End of macro CWHEAD
42ce			; | TCASE ( s -- s ) Title case string s  | DONE 
42ce					if DEBUG_FORTH_WORDS_KEY 
42ce						DMARK "TCS" 
42ce f5				push af  
42cf 3a e3 42			ld a, (.dmark)  
42d2 32 6e fe			ld (debug_mark),a  
42d5 3a e4 42			ld a, (.dmark+1)  
42d8 32 6f fe			ld (debug_mark+1),a  
42db 3a e5 42			ld a, (.dmark+2)  
42de 32 70 fe			ld (debug_mark+2),a  
42e1 18 03			jr .pastdmark  
42e3 ..			.dmark: db "TCS"  
42e6 f1			.pastdmark: pop af  
42e7			endm  
# End of macro DMARK
42e7						CALLMONITOR 
42e7 cd 73 18			call break_point_state  
42ea				endm  
# End of macro CALLMONITOR
42ea					endif 
42ea			 
42ea					FORTH_DSP 
42ea cd a4 20			call macro_forth_dsp 
42ed				endm 
# End of macro FORTH_DSP
42ed					 
42ed			; TODO check is string type 
42ed			 
42ed					FORTH_DSP_VALUEHL 
42ed cd de 20			call macro_dsp_valuehl 
42f0				endm 
# End of macro FORTH_DSP_VALUEHL
42f0			; get pointer to string in hl 
42f0			 
42f0					if DEBUG_FORTH_WORDS 
42f0						DMARK "TC1" 
42f0 f5				push af  
42f1 3a 05 43			ld a, (.dmark)  
42f4 32 6e fe			ld (debug_mark),a  
42f7 3a 06 43			ld a, (.dmark+1)  
42fa 32 6f fe			ld (debug_mark+1),a  
42fd 3a 07 43			ld a, (.dmark+2)  
4300 32 70 fe			ld (debug_mark+2),a  
4303 18 03			jr .pastdmark  
4305 ..			.dmark: db "TC1"  
4308 f1			.pastdmark: pop af  
4309			endm  
# End of macro DMARK
4309						CALLMONITOR 
4309 cd 73 18			call break_point_state  
430c				endm  
# End of macro CALLMONITOR
430c					endif 
430c			 
430c					; first time in turn to upper case first char 
430c			 
430c 7e					ld a, (hl) 
430d c3 97 43				jp .totsiptou 
4310			 
4310			 
4310 7e			.tot:		ld a, (hl) 
4311 fe 00				cp 0 
4313 ca db 43				jp z, .totdone 
4316			 
4316					if DEBUG_FORTH_WORDS 
4316						DMARK "TC2" 
4316 f5				push af  
4317 3a 2b 43			ld a, (.dmark)  
431a 32 6e fe			ld (debug_mark),a  
431d 3a 2c 43			ld a, (.dmark+1)  
4320 32 6f fe			ld (debug_mark+1),a  
4323 3a 2d 43			ld a, (.dmark+2)  
4326 32 70 fe			ld (debug_mark+2),a  
4329 18 03			jr .pastdmark  
432b ..			.dmark: db "TC2"  
432e f1			.pastdmark: pop af  
432f			endm  
# End of macro DMARK
432f						CALLMONITOR 
432f cd 73 18			call break_point_state  
4332				endm  
# End of macro CALLMONITOR
4332					endif 
4332					; check to see if current char is a space 
4332			 
4332 fe 20				cp ' ' 
4334 28 21				jr z, .totsp 
4336 cd 42 12				call to_lower 
4339					if DEBUG_FORTH_WORDS 
4339						DMARK "TC3" 
4339 f5				push af  
433a 3a 4e 43			ld a, (.dmark)  
433d 32 6e fe			ld (debug_mark),a  
4340 3a 4f 43			ld a, (.dmark+1)  
4343 32 6f fe			ld (debug_mark+1),a  
4346 3a 50 43			ld a, (.dmark+2)  
4349 32 70 fe			ld (debug_mark+2),a  
434c 18 03			jr .pastdmark  
434e ..			.dmark: db "TC3"  
4351 f1			.pastdmark: pop af  
4352			endm  
# End of macro DMARK
4352						CALLMONITOR 
4352 cd 73 18			call break_point_state  
4355				endm  
# End of macro CALLMONITOR
4355					endif 
4355 18 63				jr .totnxt 
4357			 
4357			.totsp:         ; on a space, find next char which should be upper 
4357			 
4357					if DEBUG_FORTH_WORDS 
4357						DMARK "TC4" 
4357 f5				push af  
4358 3a 6c 43			ld a, (.dmark)  
435b 32 6e fe			ld (debug_mark),a  
435e 3a 6d 43			ld a, (.dmark+1)  
4361 32 6f fe			ld (debug_mark+1),a  
4364 3a 6e 43			ld a, (.dmark+2)  
4367 32 70 fe			ld (debug_mark+2),a  
436a 18 03			jr .pastdmark  
436c ..			.dmark: db "TC4"  
436f f1			.pastdmark: pop af  
4370			endm  
# End of macro DMARK
4370						CALLMONITOR 
4370 cd 73 18			call break_point_state  
4373				endm  
# End of macro CALLMONITOR
4373					endif 
4373					;; 
4373			 
4373 fe 20				cp ' ' 
4375 20 20				jr nz, .totsiptou 
4377 23					inc hl 
4378 7e					ld a, (hl) 
4379					if DEBUG_FORTH_WORDS 
4379						DMARK "TC5" 
4379 f5				push af  
437a 3a 8e 43			ld a, (.dmark)  
437d 32 6e fe			ld (debug_mark),a  
4380 3a 8f 43			ld a, (.dmark+1)  
4383 32 6f fe			ld (debug_mark+1),a  
4386 3a 90 43			ld a, (.dmark+2)  
4389 32 70 fe			ld (debug_mark+2),a  
438c 18 03			jr .pastdmark  
438e ..			.dmark: db "TC5"  
4391 f1			.pastdmark: pop af  
4392			endm  
# End of macro DMARK
4392						CALLMONITOR 
4392 cd 73 18			call break_point_state  
4395				endm  
# End of macro CALLMONITOR
4395					endif 
4395 18 c0				jr .totsp 
4397 fe 00		.totsiptou:    cp 0 
4399 28 40				jr z, .totdone 
439b					; not space and not zero term so upper case it 
439b cd 39 12				call to_upper 
439e			 
439e					if DEBUG_FORTH_WORDS 
439e						DMARK "TC6" 
439e f5				push af  
439f 3a b3 43			ld a, (.dmark)  
43a2 32 6e fe			ld (debug_mark),a  
43a5 3a b4 43			ld a, (.dmark+1)  
43a8 32 6f fe			ld (debug_mark+1),a  
43ab 3a b5 43			ld a, (.dmark+2)  
43ae 32 70 fe			ld (debug_mark+2),a  
43b1 18 03			jr .pastdmark  
43b3 ..			.dmark: db "TC6"  
43b6 f1			.pastdmark: pop af  
43b7			endm  
# End of macro DMARK
43b7						CALLMONITOR 
43b7 cd 73 18			call break_point_state  
43ba				endm  
# End of macro CALLMONITOR
43ba					endif 
43ba			 
43ba			 
43ba			.totnxt: 
43ba			 
43ba 77					ld (hl), a 
43bb 23					inc hl 
43bc					if DEBUG_FORTH_WORDS 
43bc						DMARK "TC7" 
43bc f5				push af  
43bd 3a d1 43			ld a, (.dmark)  
43c0 32 6e fe			ld (debug_mark),a  
43c3 3a d2 43			ld a, (.dmark+1)  
43c6 32 6f fe			ld (debug_mark+1),a  
43c9 3a d3 43			ld a, (.dmark+2)  
43cc 32 70 fe			ld (debug_mark+2),a  
43cf 18 03			jr .pastdmark  
43d1 ..			.dmark: db "TC7"  
43d4 f1			.pastdmark: pop af  
43d5			endm  
# End of macro DMARK
43d5						CALLMONITOR 
43d5 cd 73 18			call break_point_state  
43d8				endm  
# End of macro CALLMONITOR
43d8					endif 
43d8 c3 10 43				jp .tot 
43db			 
43db					 
43db			 
43db			 
43db			; for each char convert to low 
43db					 
43db			.totdone: 
43db					if DEBUG_FORTH_WORDS 
43db						DMARK "TCd" 
43db f5				push af  
43dc 3a f0 43			ld a, (.dmark)  
43df 32 6e fe			ld (debug_mark),a  
43e2 3a f1 43			ld a, (.dmark+1)  
43e5 32 6f fe			ld (debug_mark+1),a  
43e8 3a f2 43			ld a, (.dmark+2)  
43eb 32 70 fe			ld (debug_mark+2),a  
43ee 18 03			jr .pastdmark  
43f0 ..			.dmark: db "TCd"  
43f3 f1			.pastdmark: pop af  
43f4			endm  
# End of macro DMARK
43f4						CALLMONITOR 
43f4 cd 73 18			call break_point_state  
43f7				endm  
# End of macro CALLMONITOR
43f7					endif 
43f7					NEXTW 
43f7 c3 55 22			jp macro_next 
43fa				endm 
# End of macro NEXTW
43fa			 
43fa			.SUBSTR: 
43fa				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
43fa 48				db WORD_SYS_CORE+52             
43fb 58 44			dw .LEFT            
43fd 07				db 6 + 1 
43fe .. 00			db "SUBSTR",0              
4405				endm 
# End of macro CWHEAD
4405			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4405			 
4405					if DEBUG_FORTH_WORDS_KEY 
4405						DMARK "SST" 
4405 f5				push af  
4406 3a 1a 44			ld a, (.dmark)  
4409 32 6e fe			ld (debug_mark),a  
440c 3a 1b 44			ld a, (.dmark+1)  
440f 32 6f fe			ld (debug_mark+1),a  
4412 3a 1c 44			ld a, (.dmark+2)  
4415 32 70 fe			ld (debug_mark+2),a  
4418 18 03			jr .pastdmark  
441a ..			.dmark: db "SST"  
441d f1			.pastdmark: pop af  
441e			endm  
# End of macro DMARK
441e						CALLMONITOR 
441e cd 73 18			call break_point_state  
4421				endm  
# End of macro CALLMONITOR
4421					endif 
4421			; TODO check string type 
4421					FORTH_DSP_VALUEHL 
4421 cd de 20			call macro_dsp_valuehl 
4424				endm 
# End of macro FORTH_DSP_VALUEHL
4424			 
4424 e5					push hl      ; string length 
4425			 
4425					FORTH_DSP_POP 
4425 cd 96 21			call macro_forth_dsp_pop 
4428				endm 
# End of macro FORTH_DSP_POP
4428			 
4428					FORTH_DSP_VALUEHL 
4428 cd de 20			call macro_dsp_valuehl 
442b				endm 
# End of macro FORTH_DSP_VALUEHL
442b			 
442b e5					push hl     ; start char 
442c			 
442c					FORTH_DSP_POP 
442c cd 96 21			call macro_forth_dsp_pop 
442f				endm 
# End of macro FORTH_DSP_POP
442f			 
442f			 
442f					FORTH_DSP_VALUE 
442f cd c7 20			call macro_forth_dsp_value 
4432				endm 
# End of macro FORTH_DSP_VALUE
4432			 
4432 d1					pop de    ; get start post offset 
4433			 
4433 19					add hl, de    ; starting offset 
4434			 
4434 c1					pop bc 
4435 c5					push bc      ; grab size of string 
4436			 
4436 e5					push hl    ; save string start  
4437			 
4437 26 00				ld h, 0 
4439 69					ld l, c 
443a 23					inc hl 
443b 23					inc hl 
443c			 
443c cd 93 13				call malloc 
443f				if DEBUG_FORTH_MALLOC_GUARD 
443f cc 4f 55				call z,malloc_error 
4442				endif 
4442			 
4442 eb					ex de, hl      ; save malloc area for string copy 
4443 e1					pop hl    ; get back source 
4444 c1					pop bc    ; get length of string back 
4445			 
4445 d5					push de    ; save malloc area for after we push 
4446 ed b0				ldir     ; copy substr 
4448			 
4448			 
4448 eb					ex de, hl 
4449 3e 00				ld a, 0 
444b 77					ld (hl), a   ; term substr 
444c			 
444c					 
444c e1					pop hl    ; get malloc so we can push it 
444d e5					push hl   ; save so we can free it afterwards 
444e			 
444e cd 55 1f				call forth_push_str 
4451			 
4451 e1					pop hl 
4452 cd 5d 14				call free 
4455			 
4455					 
4455					 
4455			 
4455			 
4455					NEXTW 
4455 c3 55 22			jp macro_next 
4458				endm 
# End of macro NEXTW
4458			 
4458			.LEFT: 
4458				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4458 48				db WORD_SYS_CORE+52             
4459 80 44			dw .RIGHT            
445b 05				db 4 + 1 
445c .. 00			db "LEFT",0              
4461				endm 
# End of macro CWHEAD
4461			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4461					if DEBUG_FORTH_WORDS_KEY 
4461						DMARK "LEF" 
4461 f5				push af  
4462 3a 76 44			ld a, (.dmark)  
4465 32 6e fe			ld (debug_mark),a  
4468 3a 77 44			ld a, (.dmark+1)  
446b 32 6f fe			ld (debug_mark+1),a  
446e 3a 78 44			ld a, (.dmark+2)  
4471 32 70 fe			ld (debug_mark+2),a  
4474 18 03			jr .pastdmark  
4476 ..			.dmark: db "LEF"  
4479 f1			.pastdmark: pop af  
447a			endm  
# End of macro DMARK
447a						CALLMONITOR 
447a cd 73 18			call break_point_state  
447d				endm  
# End of macro CALLMONITOR
447d					endif 
447d			 
447d					NEXTW 
447d c3 55 22			jp macro_next 
4480				endm 
# End of macro NEXTW
4480			.RIGHT: 
4480				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4480 48				db WORD_SYS_CORE+52             
4481 a9 44			dw .STR2NUM            
4483 06				db 5 + 1 
4484 .. 00			db "RIGHT",0              
448a				endm 
# End of macro CWHEAD
448a			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
448a					if DEBUG_FORTH_WORDS_KEY 
448a						DMARK "RIG" 
448a f5				push af  
448b 3a 9f 44			ld a, (.dmark)  
448e 32 6e fe			ld (debug_mark),a  
4491 3a a0 44			ld a, (.dmark+1)  
4494 32 6f fe			ld (debug_mark+1),a  
4497 3a a1 44			ld a, (.dmark+2)  
449a 32 70 fe			ld (debug_mark+2),a  
449d 18 03			jr .pastdmark  
449f ..			.dmark: db "RIG"  
44a2 f1			.pastdmark: pop af  
44a3			endm  
# End of macro DMARK
44a3						CALLMONITOR 
44a3 cd 73 18			call break_point_state  
44a6				endm  
# End of macro CALLMONITOR
44a6					endif 
44a6			 
44a6					NEXTW 
44a6 c3 55 22			jp macro_next 
44a9				endm 
# End of macro NEXTW
44a9			 
44a9			 
44a9			.STR2NUM: 
44a9				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
44a9 48				db WORD_SYS_CORE+52             
44aa 35 45			dw .NUM2STR            
44ac 08				db 7 + 1 
44ad .. 00			db "STR2NUM",0              
44b5				endm 
# End of macro CWHEAD
44b5			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
44b5			 
44b5			 
44b5			; TODO STR type check to do 
44b5					if DEBUG_FORTH_WORDS_KEY 
44b5						DMARK "S2N" 
44b5 f5				push af  
44b6 3a ca 44			ld a, (.dmark)  
44b9 32 6e fe			ld (debug_mark),a  
44bc 3a cb 44			ld a, (.dmark+1)  
44bf 32 6f fe			ld (debug_mark+1),a  
44c2 3a cc 44			ld a, (.dmark+2)  
44c5 32 70 fe			ld (debug_mark+2),a  
44c8 18 03			jr .pastdmark  
44ca ..			.dmark: db "S2N"  
44cd f1			.pastdmark: pop af  
44ce			endm  
# End of macro DMARK
44ce						CALLMONITOR 
44ce cd 73 18			call break_point_state  
44d1				endm  
# End of macro CALLMONITOR
44d1					endif 
44d1			 
44d1					;FORTH_DSP 
44d1					FORTH_DSP_VALUE 
44d1 cd c7 20			call macro_forth_dsp_value 
44d4				endm 
# End of macro FORTH_DSP_VALUE
44d4					;inc hl 
44d4			 
44d4 eb					ex de, hl 
44d5					if DEBUG_FORTH_WORDS 
44d5						DMARK "S2a" 
44d5 f5				push af  
44d6 3a ea 44			ld a, (.dmark)  
44d9 32 6e fe			ld (debug_mark),a  
44dc 3a eb 44			ld a, (.dmark+1)  
44df 32 6f fe			ld (debug_mark+1),a  
44e2 3a ec 44			ld a, (.dmark+2)  
44e5 32 70 fe			ld (debug_mark+2),a  
44e8 18 03			jr .pastdmark  
44ea ..			.dmark: db "S2a"  
44ed f1			.pastdmark: pop af  
44ee			endm  
# End of macro DMARK
44ee						CALLMONITOR 
44ee cd 73 18			call break_point_state  
44f1				endm  
# End of macro CALLMONITOR
44f1					endif 
44f1 cd c1 12				call string_to_uint16 
44f4			 
44f4					if DEBUG_FORTH_WORDS 
44f4						DMARK "S2b" 
44f4 f5				push af  
44f5 3a 09 45			ld a, (.dmark)  
44f8 32 6e fe			ld (debug_mark),a  
44fb 3a 0a 45			ld a, (.dmark+1)  
44fe 32 6f fe			ld (debug_mark+1),a  
4501 3a 0b 45			ld a, (.dmark+2)  
4504 32 70 fe			ld (debug_mark+2),a  
4507 18 03			jr .pastdmark  
4509 ..			.dmark: db "S2b"  
450c f1			.pastdmark: pop af  
450d			endm  
# End of macro DMARK
450d						CALLMONITOR 
450d cd 73 18			call break_point_state  
4510				endm  
# End of macro CALLMONITOR
4510					endif 
4510			;		push hl 
4510					FORTH_DSP_POP 
4510 cd 96 21			call macro_forth_dsp_pop 
4513				endm 
# End of macro FORTH_DSP_POP
4513			;		pop hl 
4513					 
4513					if DEBUG_FORTH_WORDS 
4513						DMARK "S2b" 
4513 f5				push af  
4514 3a 28 45			ld a, (.dmark)  
4517 32 6e fe			ld (debug_mark),a  
451a 3a 29 45			ld a, (.dmark+1)  
451d 32 6f fe			ld (debug_mark+1),a  
4520 3a 2a 45			ld a, (.dmark+2)  
4523 32 70 fe			ld (debug_mark+2),a  
4526 18 03			jr .pastdmark  
4528 ..			.dmark: db "S2b"  
452b f1			.pastdmark: pop af  
452c			endm  
# End of macro DMARK
452c						CALLMONITOR 
452c cd 73 18			call break_point_state  
452f				endm  
# End of macro CALLMONITOR
452f					endif 
452f cd e7 1e				call forth_push_numhl	 
4532			 
4532				 
4532				       NEXTW 
4532 c3 55 22			jp macro_next 
4535				endm 
# End of macro NEXTW
4535			.NUM2STR: 
4535				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4535 48				db WORD_SYS_CORE+52             
4536 44 45			dw .CONCAT            
4538 08				db 7 + 1 
4539 .. 00			db "NUM2STR",0              
4541				endm 
# End of macro CWHEAD
4541			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4541			 
4541			;		; malloc a string to target 
4541			;		ld hl, 10     ; TODO max string size should be fine 
4541			;		call malloc 
4541			;		push hl    ; save malloc location 
4541			; 
4541			; 
4541			;; TODO check int type 
4541			;		FORTH_DSP_VALUEHL 
4541			;		ld a, l 
4541			;		call DispAToASCII   
4541			;;TODO need to chage above call to dump into string 
4541			; 
4541			; 
4541			 
4541				       NEXTW 
4541 c3 55 22			jp macro_next 
4544				endm 
# End of macro NEXTW
4544			 
4544			.CONCAT: 
4544				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4544 48				db WORD_SYS_CORE+52             
4545 f7 45			dw .FIND            
4547 07				db 6 + 1 
4548 .. 00			db "CONCAT",0              
454f				endm 
# End of macro CWHEAD
454f			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
454f			 
454f			; TODO check string type 
454f			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
454f			 
454f					if DEBUG_FORTH_WORDS_KEY 
454f						DMARK "CON" 
454f f5				push af  
4550 3a 64 45			ld a, (.dmark)  
4553 32 6e fe			ld (debug_mark),a  
4556 3a 65 45			ld a, (.dmark+1)  
4559 32 6f fe			ld (debug_mark+1),a  
455c 3a 66 45			ld a, (.dmark+2)  
455f 32 70 fe			ld (debug_mark+2),a  
4562 18 03			jr .pastdmark  
4564 ..			.dmark: db "CON"  
4567 f1			.pastdmark: pop af  
4568			endm  
# End of macro DMARK
4568						CALLMONITOR 
4568 cd 73 18			call break_point_state  
456b				endm  
# End of macro CALLMONITOR
456b					endif 
456b			 
456b			 
456b					FORTH_DSP_VALUE 
456b cd c7 20			call macro_forth_dsp_value 
456e				endm 
# End of macro FORTH_DSP_VALUE
456e e5					push hl   ; s2 
456f			 
456f					FORTH_DSP_POP 
456f cd 96 21			call macro_forth_dsp_pop 
4572				endm 
# End of macro FORTH_DSP_POP
4572			 
4572					FORTH_DSP_VALUE 
4572 cd c7 20			call macro_forth_dsp_value 
4575				endm 
# End of macro FORTH_DSP_VALUE
4575			 
4575 e5					push hl   ; s1 
4576			 
4576					FORTH_DSP_POP 
4576 cd 96 21			call macro_forth_dsp_pop 
4579				endm 
# End of macro FORTH_DSP_POP
4579					 
4579			 
4579					; copy s1 
4579			 
4579				 
4579					; save ptr 
4579 e1					pop hl  
457a e5					push hl 
457b 3e 00				ld a, 0 
457d cd 35 13				call strlent 
4580					;inc hl    ; zer0 
4580 06 00				ld b, 0 
4582 4d					ld c, l 
4583 e1					pop hl		 
4584 11 ff f1				ld de, scratch	 
4587					if DEBUG_FORTH_WORDS 
4587						DMARK "CO1" 
4587 f5				push af  
4588 3a 9c 45			ld a, (.dmark)  
458b 32 6e fe			ld (debug_mark),a  
458e 3a 9d 45			ld a, (.dmark+1)  
4591 32 6f fe			ld (debug_mark+1),a  
4594 3a 9e 45			ld a, (.dmark+2)  
4597 32 70 fe			ld (debug_mark+2),a  
459a 18 03			jr .pastdmark  
459c ..			.dmark: db "CO1"  
459f f1			.pastdmark: pop af  
45a0			endm  
# End of macro DMARK
45a0						CALLMONITOR 
45a0 cd 73 18			call break_point_state  
45a3				endm  
# End of macro CALLMONITOR
45a3					endif 
45a3 ed b0				ldir 
45a5			 
45a5 e1					pop hl 
45a6 e5					push hl 
45a7 d5					push de 
45a8			 
45a8			 
45a8 3e 00				ld a, 0 
45aa cd 35 13				call strlent 
45ad 23					inc hl    ; zer0 
45ae 23					inc hl 
45af 06 00				ld b, 0 
45b1 4d					ld c, l 
45b2 d1					pop de 
45b3 e1					pop hl		 
45b4					if DEBUG_FORTH_WORDS 
45b4						DMARK "CO2" 
45b4 f5				push af  
45b5 3a c9 45			ld a, (.dmark)  
45b8 32 6e fe			ld (debug_mark),a  
45bb 3a ca 45			ld a, (.dmark+1)  
45be 32 6f fe			ld (debug_mark+1),a  
45c1 3a cb 45			ld a, (.dmark+2)  
45c4 32 70 fe			ld (debug_mark+2),a  
45c7 18 03			jr .pastdmark  
45c9 ..			.dmark: db "CO2"  
45cc f1			.pastdmark: pop af  
45cd			endm  
# End of macro DMARK
45cd						CALLMONITOR 
45cd cd 73 18			call break_point_state  
45d0				endm  
# End of macro CALLMONITOR
45d0					endif 
45d0 ed b0				ldir 
45d2			 
45d2			 
45d2			 
45d2 21 ff f1				ld hl, scratch 
45d5					if DEBUG_FORTH_WORDS 
45d5						DMARK "CO5" 
45d5 f5				push af  
45d6 3a ea 45			ld a, (.dmark)  
45d9 32 6e fe			ld (debug_mark),a  
45dc 3a eb 45			ld a, (.dmark+1)  
45df 32 6f fe			ld (debug_mark+1),a  
45e2 3a ec 45			ld a, (.dmark+2)  
45e5 32 70 fe			ld (debug_mark+2),a  
45e8 18 03			jr .pastdmark  
45ea ..			.dmark: db "CO5"  
45ed f1			.pastdmark: pop af  
45ee			endm  
# End of macro DMARK
45ee						CALLMONITOR 
45ee cd 73 18			call break_point_state  
45f1				endm  
# End of macro CALLMONITOR
45f1					endif 
45f1			 
45f1 cd 55 1f				call forth_push_str 
45f4			 
45f4			 
45f4			 
45f4			 
45f4				       NEXTW 
45f4 c3 55 22			jp macro_next 
45f7				endm 
# End of macro NEXTW
45f7			 
45f7			 
45f7			.FIND: 
45f7				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
45f7 4b				db WORD_SYS_CORE+55             
45f8 b5 46			dw .LEN            
45fa 05				db 4 + 1 
45fb .. 00			db "FIND",0              
4600				endm 
# End of macro CWHEAD
4600			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4600			 
4600					if DEBUG_FORTH_WORDS_KEY 
4600						DMARK "FND" 
4600 f5				push af  
4601 3a 15 46			ld a, (.dmark)  
4604 32 6e fe			ld (debug_mark),a  
4607 3a 16 46			ld a, (.dmark+1)  
460a 32 6f fe			ld (debug_mark+1),a  
460d 3a 17 46			ld a, (.dmark+2)  
4610 32 70 fe			ld (debug_mark+2),a  
4613 18 03			jr .pastdmark  
4615 ..			.dmark: db "FND"  
4618 f1			.pastdmark: pop af  
4619			endm  
# End of macro DMARK
4619						CALLMONITOR 
4619 cd 73 18			call break_point_state  
461c				endm  
# End of macro CALLMONITOR
461c					endif 
461c			 
461c			; TODO check string type 
461c					FORTH_DSP_VALUE 
461c cd c7 20			call macro_forth_dsp_value 
461f				endm 
# End of macro FORTH_DSP_VALUE
461f			 
461f e5					push hl    
4620 7e					ld a,(hl)    ; char to find   
4621			; TODO change char to substr 
4621			 
4621 f5					push af 
4622					 
4622			 
4622			 
4622					if DEBUG_FORTH_WORDS 
4622						DMARK "FN1" 
4622 f5				push af  
4623 3a 37 46			ld a, (.dmark)  
4626 32 6e fe			ld (debug_mark),a  
4629 3a 38 46			ld a, (.dmark+1)  
462c 32 6f fe			ld (debug_mark+1),a  
462f 3a 39 46			ld a, (.dmark+2)  
4632 32 70 fe			ld (debug_mark+2),a  
4635 18 03			jr .pastdmark  
4637 ..			.dmark: db "FN1"  
463a f1			.pastdmark: pop af  
463b			endm  
# End of macro DMARK
463b						CALLMONITOR 
463b cd 73 18			call break_point_state  
463e				endm  
# End of macro CALLMONITOR
463e					endif 
463e			 
463e					FORTH_DSP_POP 
463e cd 96 21			call macro_forth_dsp_pop 
4641				endm 
# End of macro FORTH_DSP_POP
4641			 
4641					; string to search 
4641			 
4641					FORTH_DSP_VALUE 
4641 cd c7 20			call macro_forth_dsp_value 
4644				endm 
# End of macro FORTH_DSP_VALUE
4644			 
4644 d1					pop de  ; d is char to find  
4645			 
4645					if DEBUG_FORTH_WORDS 
4645						DMARK "FN2" 
4645 f5				push af  
4646 3a 5a 46			ld a, (.dmark)  
4649 32 6e fe			ld (debug_mark),a  
464c 3a 5b 46			ld a, (.dmark+1)  
464f 32 6f fe			ld (debug_mark+1),a  
4652 3a 5c 46			ld a, (.dmark+2)  
4655 32 70 fe			ld (debug_mark+2),a  
4658 18 03			jr .pastdmark  
465a ..			.dmark: db "FN2"  
465d f1			.pastdmark: pop af  
465e			endm  
# End of macro DMARK
465e						CALLMONITOR 
465e cd 73 18			call break_point_state  
4661				endm  
# End of macro CALLMONITOR
4661					endif 
4661					 
4661 01 00 00				ld bc, 0 
4664 7e			.findchar:      ld a,(hl) 
4665 fe 00				cp 0   		 
4667 28 27				jr z, .finddone     
4669 ba					cp d 
466a 28 20				jr z, .foundchar 
466c 03					inc bc 
466d 23					inc hl 
466e					if DEBUG_FORTH_WORDS 
466e						DMARK "FN3" 
466e f5				push af  
466f 3a 83 46			ld a, (.dmark)  
4672 32 6e fe			ld (debug_mark),a  
4675 3a 84 46			ld a, (.dmark+1)  
4678 32 6f fe			ld (debug_mark+1),a  
467b 3a 85 46			ld a, (.dmark+2)  
467e 32 70 fe			ld (debug_mark+2),a  
4681 18 03			jr .pastdmark  
4683 ..			.dmark: db "FN3"  
4686 f1			.pastdmark: pop af  
4687			endm  
# End of macro DMARK
4687						CALLMONITOR 
4687 cd 73 18			call break_point_state  
468a				endm  
# End of macro CALLMONITOR
468a					endif 
468a 18 d8				jr .findchar 
468c			 
468c			 
468c c5			.foundchar:	push bc 
468d e1					pop hl 
468e 18 03				jr .findexit 
4690			 
4690			 
4690							 
4690			 
4690			.finddone:     ; got to end of string with no find 
4690 21 00 00				ld hl, 0 
4693			.findexit: 
4693			 
4693					if DEBUG_FORTH_WORDS 
4693						DMARK "FNd" 
4693 f5				push af  
4694 3a a8 46			ld a, (.dmark)  
4697 32 6e fe			ld (debug_mark),a  
469a 3a a9 46			ld a, (.dmark+1)  
469d 32 6f fe			ld (debug_mark+1),a  
46a0 3a aa 46			ld a, (.dmark+2)  
46a3 32 70 fe			ld (debug_mark+2),a  
46a6 18 03			jr .pastdmark  
46a8 ..			.dmark: db "FNd"  
46ab f1			.pastdmark: pop af  
46ac			endm  
# End of macro DMARK
46ac						CALLMONITOR 
46ac cd 73 18			call break_point_state  
46af				endm  
# End of macro CALLMONITOR
46af					endif 
46af cd e7 1e			call forth_push_numhl 
46b2			 
46b2				       NEXTW 
46b2 c3 55 22			jp macro_next 
46b5				endm 
# End of macro NEXTW
46b5			 
46b5			.LEN: 
46b5				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
46b5 4c				db WORD_SYS_CORE+56             
46b6 1f 47			dw .CHAR            
46b8 06				db 5 + 1 
46b9 .. 00			db "COUNT",0              
46bf				endm 
# End of macro CWHEAD
46bf			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
46bf			 
46bf					if DEBUG_FORTH_WORDS_KEY 
46bf						DMARK "CNT" 
46bf f5				push af  
46c0 3a d4 46			ld a, (.dmark)  
46c3 32 6e fe			ld (debug_mark),a  
46c6 3a d5 46			ld a, (.dmark+1)  
46c9 32 6f fe			ld (debug_mark+1),a  
46cc 3a d6 46			ld a, (.dmark+2)  
46cf 32 70 fe			ld (debug_mark+2),a  
46d2 18 03			jr .pastdmark  
46d4 ..			.dmark: db "CNT"  
46d7 f1			.pastdmark: pop af  
46d8			endm  
# End of macro DMARK
46d8						CALLMONITOR 
46d8 cd 73 18			call break_point_state  
46db				endm  
# End of macro CALLMONITOR
46db					endif 
46db			; TODO check string type 
46db					FORTH_DSP_VALUE 
46db cd c7 20			call macro_forth_dsp_value 
46de				endm 
# End of macro FORTH_DSP_VALUE
46de			 
46de			 
46de					if DEBUG_FORTH_WORDS 
46de						DMARK "CN?" 
46de f5				push af  
46df 3a f3 46			ld a, (.dmark)  
46e2 32 6e fe			ld (debug_mark),a  
46e5 3a f4 46			ld a, (.dmark+1)  
46e8 32 6f fe			ld (debug_mark+1),a  
46eb 3a f5 46			ld a, (.dmark+2)  
46ee 32 70 fe			ld (debug_mark+2),a  
46f1 18 03			jr .pastdmark  
46f3 ..			.dmark: db "CN?"  
46f6 f1			.pastdmark: pop af  
46f7			endm  
# End of macro DMARK
46f7						CALLMONITOR 
46f7 cd 73 18			call break_point_state  
46fa				endm  
# End of macro CALLMONITOR
46fa					endif 
46fa cd 2a 13				call strlenz 
46fd					if DEBUG_FORTH_WORDS 
46fd						DMARK "CNl" 
46fd f5				push af  
46fe 3a 12 47			ld a, (.dmark)  
4701 32 6e fe			ld (debug_mark),a  
4704 3a 13 47			ld a, (.dmark+1)  
4707 32 6f fe			ld (debug_mark+1),a  
470a 3a 14 47			ld a, (.dmark+2)  
470d 32 70 fe			ld (debug_mark+2),a  
4710 18 03			jr .pastdmark  
4712 ..			.dmark: db "CNl"  
4715 f1			.pastdmark: pop af  
4716			endm  
# End of macro DMARK
4716						CALLMONITOR 
4716 cd 73 18			call break_point_state  
4719				endm  
# End of macro CALLMONITOR
4719					endif 
4719			 
4719 cd e7 1e				call forth_push_numhl 
471c			 
471c			 
471c			 
471c				       NEXTW 
471c c3 55 22			jp macro_next 
471f				endm 
# End of macro NEXTW
471f			.CHAR: 
471f				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
471f 4d				db WORD_SYS_CORE+57             
4720 55 47			dw .ENDSTR            
4722 05				db 4 + 1 
4723 .. 00			db "CHAR",0              
4728				endm 
# End of macro CWHEAD
4728			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4728					if DEBUG_FORTH_WORDS_KEY 
4728						DMARK "CHR" 
4728 f5				push af  
4729 3a 3d 47			ld a, (.dmark)  
472c 32 6e fe			ld (debug_mark),a  
472f 3a 3e 47			ld a, (.dmark+1)  
4732 32 6f fe			ld (debug_mark+1),a  
4735 3a 3f 47			ld a, (.dmark+2)  
4738 32 70 fe			ld (debug_mark+2),a  
473b 18 03			jr .pastdmark  
473d ..			.dmark: db "CHR"  
4740 f1			.pastdmark: pop af  
4741			endm  
# End of macro DMARK
4741						CALLMONITOR 
4741 cd 73 18			call break_point_state  
4744				endm  
# End of macro CALLMONITOR
4744					endif 
4744					FORTH_DSP 
4744 cd a4 20			call macro_forth_dsp 
4747				endm 
# End of macro FORTH_DSP
4747					;v5 FORTH_DSP_VALUE 
4747 23					inc hl      ; now at start of numeric as string 
4748			 
4748			;		push hl 
4748			 
4748					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4748 cd 96 21			call macro_forth_dsp_pop 
474b				endm 
# End of macro FORTH_DSP_POP
474b			 
474b			;		pop hl 
474b			 
474b					; push the content of a onto the stack as a value 
474b			 
474b 7e					ld a,(hl)   ; get char 
474c 26 00				ld h,0 
474e 6f					ld l,a 
474f cd e7 1e				call forth_push_numhl 
4752			 
4752				       NEXTW 
4752 c3 55 22			jp macro_next 
4755				endm 
# End of macro NEXTW
4755			 
4755			 
4755			 
4755			 
4755			.ENDSTR: 
4755			; eof 
4755			 
# End of file forth_words_str.asm
4755			include "forth_words_key.asm" 
4755			 
4755			; | ## Keyboard Words 
4755			 
4755			.KEY: 
4755				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4755 3e				db WORD_SYS_CORE+42             
4756 85 47			dw .WAITK            
4758 04				db 3 + 1 
4759 .. 00			db "KEY",0              
475d				endm 
# End of macro CWHEAD
475d			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
475d			 
475d					if DEBUG_FORTH_WORDS_KEY 
475d						DMARK "KEY" 
475d f5				push af  
475e 3a 72 47			ld a, (.dmark)  
4761 32 6e fe			ld (debug_mark),a  
4764 3a 73 47			ld a, (.dmark+1)  
4767 32 6f fe			ld (debug_mark+1),a  
476a 3a 74 47			ld a, (.dmark+2)  
476d 32 70 fe			ld (debug_mark+2),a  
4770 18 03			jr .pastdmark  
4772 ..			.dmark: db "KEY"  
4775 f1			.pastdmark: pop af  
4776			endm  
# End of macro DMARK
4776						CALLMONITOR 
4776 cd 73 18			call break_point_state  
4779				endm  
# End of macro CALLMONITOR
4779					endif 
4779			; TODO currently waits 
4779 cd d9 6c				call cin 
477c					;call cin_wait 
477c 6f					ld l, a 
477d 26 00				ld h, 0 
477f cd e7 1e				call forth_push_numhl 
4782					NEXTW 
4782 c3 55 22			jp macro_next 
4785				endm 
# End of macro NEXTW
4785			.WAITK: 
4785				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4785 3f				db WORD_SYS_CORE+43             
4786 b7 47			dw .ACCEPT            
4788 06				db 5 + 1 
4789 .. 00			db "WAITK",0              
478f				endm 
# End of macro CWHEAD
478f			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
478f					if DEBUG_FORTH_WORDS_KEY 
478f						DMARK "WAI" 
478f f5				push af  
4790 3a a4 47			ld a, (.dmark)  
4793 32 6e fe			ld (debug_mark),a  
4796 3a a5 47			ld a, (.dmark+1)  
4799 32 6f fe			ld (debug_mark+1),a  
479c 3a a6 47			ld a, (.dmark+2)  
479f 32 70 fe			ld (debug_mark+2),a  
47a2 18 03			jr .pastdmark  
47a4 ..			.dmark: db "WAI"  
47a7 f1			.pastdmark: pop af  
47a8			endm  
# End of macro DMARK
47a8						CALLMONITOR 
47a8 cd 73 18			call break_point_state  
47ab				endm  
# End of macro CALLMONITOR
47ab					endif 
47ab cd c8 6c				call cin_wait 
47ae 6f					ld l, a 
47af 26 00				ld h, 0 
47b1 cd e7 1e				call forth_push_numhl 
47b4					NEXTW 
47b4 c3 55 22			jp macro_next 
47b7				endm 
# End of macro NEXTW
47b7			.ACCEPT: 
47b7				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
47b7 40				db WORD_SYS_CORE+44             
47b8 15 48			dw .EDIT            
47ba 07				db 6 + 1 
47bb .. 00			db "ACCEPT",0              
47c2				endm 
# End of macro CWHEAD
47c2			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
47c2					; TODO crashes on push 
47c2					if DEBUG_FORTH_WORDS_KEY 
47c2						DMARK "ACC" 
47c2 f5				push af  
47c3 3a d7 47			ld a, (.dmark)  
47c6 32 6e fe			ld (debug_mark),a  
47c9 3a d8 47			ld a, (.dmark+1)  
47cc 32 6f fe			ld (debug_mark+1),a  
47cf 3a d9 47			ld a, (.dmark+2)  
47d2 32 70 fe			ld (debug_mark+2),a  
47d5 18 03			jr .pastdmark  
47d7 ..			.dmark: db "ACC"  
47da f1			.pastdmark: pop af  
47db			endm  
# End of macro DMARK
47db						CALLMONITOR 
47db cd 73 18			call break_point_state  
47de				endm  
# End of macro CALLMONITOR
47de					endif 
47de 21 fd f3				ld hl, os_input 
47e1 3e 00				ld a, 0 
47e3 77					ld (hl),a 
47e4 3a 68 fa				ld a,(f_cursor_ptr) 
47e7 16 64				ld d, 100 
47e9 0e 00				ld c, 0 
47eb 1e 28				ld e, 40 
47ed cd f9 0e				call input_str 
47f0					; TODO perhaps do a type check and wrap in quotes if not a number 
47f0 21 fd f3				ld hl, os_input 
47f3					if DEBUG_FORTH_WORDS 
47f3						DMARK "AC1" 
47f3 f5				push af  
47f4 3a 08 48			ld a, (.dmark)  
47f7 32 6e fe			ld (debug_mark),a  
47fa 3a 09 48			ld a, (.dmark+1)  
47fd 32 6f fe			ld (debug_mark+1),a  
4800 3a 0a 48			ld a, (.dmark+2)  
4803 32 70 fe			ld (debug_mark+2),a  
4806 18 03			jr .pastdmark  
4808 ..			.dmark: db "AC1"  
480b f1			.pastdmark: pop af  
480c			endm  
# End of macro DMARK
480c						CALLMONITOR 
480c cd 73 18			call break_point_state  
480f				endm  
# End of macro CALLMONITOR
480f					endif 
480f cd 55 1f				call forth_push_str 
4812					NEXTW 
4812 c3 55 22			jp macro_next 
4815				endm 
# End of macro NEXTW
4815			 
4815			.EDIT: 
4815				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4815 40				db WORD_SYS_CORE+44             
4816 b7 48			dw .ENDKEY            
4818 05				db 4 + 1 
4819 .. 00			db "EDIT",0              
481e				endm 
# End of macro CWHEAD
481e			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
481e			 
481e					; TODO does not copy from stack 
481e					if DEBUG_FORTH_WORDS_KEY 
481e						DMARK "EDT" 
481e f5				push af  
481f 3a 33 48			ld a, (.dmark)  
4822 32 6e fe			ld (debug_mark),a  
4825 3a 34 48			ld a, (.dmark+1)  
4828 32 6f fe			ld (debug_mark+1),a  
482b 3a 35 48			ld a, (.dmark+2)  
482e 32 70 fe			ld (debug_mark+2),a  
4831 18 03			jr .pastdmark  
4833 ..			.dmark: db "EDT"  
4836 f1			.pastdmark: pop af  
4837			endm  
# End of macro DMARK
4837						CALLMONITOR 
4837 cd 73 18			call break_point_state  
483a				endm  
# End of macro CALLMONITOR
483a					endif 
483a			 
483a					;FORTH_DSP 
483a					FORTH_DSP_VALUEHL 
483a cd de 20			call macro_dsp_valuehl 
483d				endm 
# End of macro FORTH_DSP_VALUEHL
483d			;		inc hl    ; TODO do type check 
483d			 
483d			;		call get_word_hl 
483d e5					push hl 
483e					if DEBUG_FORTH_WORDS 
483e						DMARK "EDp" 
483e f5				push af  
483f 3a 53 48			ld a, (.dmark)  
4842 32 6e fe			ld (debug_mark),a  
4845 3a 54 48			ld a, (.dmark+1)  
4848 32 6f fe			ld (debug_mark+1),a  
484b 3a 55 48			ld a, (.dmark+2)  
484e 32 70 fe			ld (debug_mark+2),a  
4851 18 03			jr .pastdmark  
4853 ..			.dmark: db "EDp"  
4856 f1			.pastdmark: pop af  
4857			endm  
# End of macro DMARK
4857						CALLMONITOR 
4857 cd 73 18			call break_point_state  
485a				endm  
# End of macro CALLMONITOR
485a					endif 
485a				;	ld a, 0 
485a cd 2a 13				call strlenz 
485d 23					inc hl 
485e			 
485e 06 00				ld b, 0 
4860 4d					ld c, l 
4861			 
4861 e1					pop hl 
4862 11 fd f3				ld de, os_input 
4865					if DEBUG_FORTH_WORDS_KEY 
4865						DMARK "EDc" 
4865 f5				push af  
4866 3a 7a 48			ld a, (.dmark)  
4869 32 6e fe			ld (debug_mark),a  
486c 3a 7b 48			ld a, (.dmark+1)  
486f 32 6f fe			ld (debug_mark+1),a  
4872 3a 7c 48			ld a, (.dmark+2)  
4875 32 70 fe			ld (debug_mark+2),a  
4878 18 03			jr .pastdmark  
487a ..			.dmark: db "EDc"  
487d f1			.pastdmark: pop af  
487e			endm  
# End of macro DMARK
487e						CALLMONITOR 
487e cd 73 18			call break_point_state  
4881				endm  
# End of macro CALLMONITOR
4881					endif 
4881 ed b0				ldir 
4883			 
4883			 
4883 21 fd f3				ld hl, os_input 
4886					;ld a, 0 
4886					;ld (hl),a 
4886 3a 68 fa				ld a,(f_cursor_ptr) 
4889 16 64				ld d, 100 
488b 0e 00				ld c, 0 
488d 1e 28				ld e, 40 
488f cd f9 0e				call input_str 
4892					; TODO perhaps do a type check and wrap in quotes if not a number 
4892 21 fd f3				ld hl, os_input 
4895					if DEBUG_FORTH_WORDS 
4895						DMARK "ED1" 
4895 f5				push af  
4896 3a aa 48			ld a, (.dmark)  
4899 32 6e fe			ld (debug_mark),a  
489c 3a ab 48			ld a, (.dmark+1)  
489f 32 6f fe			ld (debug_mark+1),a  
48a2 3a ac 48			ld a, (.dmark+2)  
48a5 32 70 fe			ld (debug_mark+2),a  
48a8 18 03			jr .pastdmark  
48aa ..			.dmark: db "ED1"  
48ad f1			.pastdmark: pop af  
48ae			endm  
# End of macro DMARK
48ae						CALLMONITOR 
48ae cd 73 18			call break_point_state  
48b1				endm  
# End of macro CALLMONITOR
48b1					endif 
48b1 cd 55 1f				call forth_push_str 
48b4					NEXTW 
48b4 c3 55 22			jp macro_next 
48b7				endm 
# End of macro NEXTW
48b7			 
48b7			 
48b7			 
48b7			.ENDKEY: 
48b7			; eof 
48b7			 
# End of file forth_words_key.asm
48b7			 
48b7			if STORAGE_SE 
48b7			   	include "forth_words_storage.asm" 
48b7			 
48b7			; | ## Fixed Storage Words 
48b7			 
48b7			.RECORD: 
48b7			  
48b7				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
48b7 3a				db WORD_SYS_CORE+38             
48b8 5b 49			dw .BREAD            
48ba 07				db 6 + 1 
48bb .. 00			db "RECORD",0              
48c2				endm 
# End of macro CWHEAD
48c2			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
48c2			 
48c2					if DEBUG_FORTH_WORDS_KEY 
48c2						DMARK "REC" 
48c2 f5				push af  
48c3 3a d7 48			ld a, (.dmark)  
48c6 32 6e fe			ld (debug_mark),a  
48c9 3a d8 48			ld a, (.dmark+1)  
48cc 32 6f fe			ld (debug_mark+1),a  
48cf 3a d9 48			ld a, (.dmark+2)  
48d2 32 70 fe			ld (debug_mark+2),a  
48d5 18 03			jr .pastdmark  
48d7 ..			.dmark: db "REC"  
48da f1			.pastdmark: pop af  
48db			endm  
# End of macro DMARK
48db						CALLMONITOR 
48db cd 73 18			call break_point_state  
48de				endm  
# End of macro CALLMONITOR
48de					endif 
48de			 
48de					FORTH_DSP_VALUEHL 
48de cd de 20			call macro_dsp_valuehl 
48e1				endm 
# End of macro FORTH_DSP_VALUEHL
48e1			 
48e1 e5					push hl    ; id 
48e2			 
48e2					FORTH_DSP_POP 
48e2 cd 96 21			call macro_forth_dsp_pop 
48e5				endm 
# End of macro FORTH_DSP_POP
48e5			 
48e5					FORTH_DSP_VALUEHL 
48e5 cd de 20			call macro_dsp_valuehl 
48e8				endm 
# End of macro FORTH_DSP_VALUEHL
48e8			 
48e8					FORTH_DSP_POP 
48e8 cd 96 21			call macro_forth_dsp_pop 
48eb				endm 
# End of macro FORTH_DSP_POP
48eb			 
48eb d1					pop de     ; get file id 
48ec			 
48ec					; e = file id 
48ec					; l = file extent 
48ec			 
48ec			 
48ec					; construct request to access file extent 
48ec			 
48ec			;		ld a, e 
48ec 63					ld h, e 
48ed					 
48ed					 
48ed					 
48ed			 
48ed					; e has id 
48ed			 
48ed 11 81 fa			ld de, store_page 
48f0					if DEBUG_FORTH_WORDS 
48f0						DMARK "REr" 
48f0 f5				push af  
48f1 3a 05 49			ld a, (.dmark)  
48f4 32 6e fe			ld (debug_mark),a  
48f7 3a 06 49			ld a, (.dmark+1)  
48fa 32 6f fe			ld (debug_mark+1),a  
48fd 3a 07 49			ld a, (.dmark+2)  
4900 32 70 fe			ld (debug_mark+2),a  
4903 18 03			jr .pastdmark  
4905 ..			.dmark: db "REr"  
4908 f1			.pastdmark: pop af  
4909			endm  
# End of macro DMARK
4909						CALLMONITOR 
4909 cd 73 18			call break_point_state  
490c				endm  
# End of macro CALLMONITOR
490c					endif 
490c cd 2d 09				call storage_read 
490f cd f5 0e			call ishlzero 
4912 28 22			jr z, .recnotfound 
4914			 
4914			 
4914					if DEBUG_FORTH_WORDS 
4914						DMARK "REe" 
4914 f5				push af  
4915 3a 29 49			ld a, (.dmark)  
4918 32 6e fe			ld (debug_mark),a  
491b 3a 2a 49			ld a, (.dmark+1)  
491e 32 6f fe			ld (debug_mark+1),a  
4921 3a 2b 49			ld a, (.dmark+2)  
4924 32 70 fe			ld (debug_mark+2),a  
4927 18 03			jr .pastdmark  
4929 ..			.dmark: db "REe"  
492c f1			.pastdmark: pop af  
492d			endm  
# End of macro DMARK
492d						CALLMONITOR 
492d cd 73 18			call break_point_state  
4930				endm  
# End of macro CALLMONITOR
4930					endif 
4930 cd 55 1f			call forth_push_str 
4933			 
4933					NEXTW 
4933 c3 55 22			jp macro_next 
4936				endm 
# End of macro NEXTW
4936			 
4936			.recnotfound: 
4936					if DEBUG_FORTH_WORDS 
4936						DMARK "REf" 
4936 f5				push af  
4937 3a 4b 49			ld a, (.dmark)  
493a 32 6e fe			ld (debug_mark),a  
493d 3a 4c 49			ld a, (.dmark+1)  
4940 32 6f fe			ld (debug_mark+1),a  
4943 3a 4d 49			ld a, (.dmark+2)  
4946 32 70 fe			ld (debug_mark+2),a  
4949 18 03			jr .pastdmark  
494b ..			.dmark: db "REf"  
494e f1			.pastdmark: pop af  
494f			endm  
# End of macro DMARK
494f						CALLMONITOR 
494f cd 73 18			call break_point_state  
4952				endm  
# End of macro CALLMONITOR
4952					endif 
4952 21 ff 00			ld hl, 255 
4955 cd e7 1e			call forth_push_numhl 
4958				NEXTW 
4958 c3 55 22			jp macro_next 
495b				endm 
# End of macro NEXTW
495b			 
495b			 
495b			.BREAD: 
495b			  
495b				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
495b 3a				db WORD_SYS_CORE+38             
495c de 49			dw .BWRITE            
495e 06				db 5 + 1 
495f .. 00			db "BREAD",0              
4965				endm 
# End of macro CWHEAD
4965			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from block address u (1-512) and push to stack  | DONE 
4965				 
4965					if DEBUG_FORTH_WORDS_KEY 
4965						DMARK "BRD" 
4965 f5				push af  
4966 3a 7a 49			ld a, (.dmark)  
4969 32 6e fe			ld (debug_mark),a  
496c 3a 7b 49			ld a, (.dmark+1)  
496f 32 6f fe			ld (debug_mark+1),a  
4972 3a 7c 49			ld a, (.dmark+2)  
4975 32 70 fe			ld (debug_mark+2),a  
4978 18 03			jr .pastdmark  
497a ..			.dmark: db "BRD"  
497d f1			.pastdmark: pop af  
497e			endm  
# End of macro DMARK
497e						CALLMONITOR 
497e cd 73 18			call break_point_state  
4981				endm  
# End of macro CALLMONITOR
4981					endif 
4981			 
4981				FORTH_DSP_VALUEHL 
4981 cd de 20			call macro_dsp_valuehl 
4984				endm 
# End of macro FORTH_DSP_VALUEHL
4984			 
4984				FORTH_DSP_POP 
4984 cd 96 21			call macro_forth_dsp_pop 
4987				endm 
# End of macro FORTH_DSP_POP
4987			 
4987				; calc block address 
4987			 
4987 eb				ex de, hl 
4988 3e 40			ld a, STORE_BLOCK_PHY 
498a cd 4f 0e			call Mult16 
498d			 
498d			 
498d 11 81 fa			ld de, store_page 
4990			 
4990					if DEBUG_FORTH_WORDS 
4990						DMARK "BR1" 
4990 f5				push af  
4991 3a a5 49			ld a, (.dmark)  
4994 32 6e fe			ld (debug_mark),a  
4997 3a a6 49			ld a, (.dmark+1)  
499a 32 6f fe			ld (debug_mark+1),a  
499d 3a a7 49			ld a, (.dmark+2)  
49a0 32 70 fe			ld (debug_mark+2),a  
49a3 18 03			jr .pastdmark  
49a5 ..			.dmark: db "BR1"  
49a8 f1			.pastdmark: pop af  
49a9			endm  
# End of macro DMARK
49a9						CALLMONITOR 
49a9 cd 73 18			call break_point_state  
49ac				endm  
# End of macro CALLMONITOR
49ac					endif 
49ac			 
49ac cd d4 03			call storage_read_block 
49af			 
49af cd f5 0e			call ishlzero 
49b2 20 05			jr nz, .brfound 
49b4			 
49b4 cd e7 1e			call forth_push_numhl 
49b7 18 22			jr .brdone 
49b9			 
49b9			 
49b9			.brfound: 
49b9 21 83 fa		        ld hl, store_page+2 
49bc			 
49bc					if DEBUG_FORTH_WORDS 
49bc						DMARK "BR2" 
49bc f5				push af  
49bd 3a d1 49			ld a, (.dmark)  
49c0 32 6e fe			ld (debug_mark),a  
49c3 3a d2 49			ld a, (.dmark+1)  
49c6 32 6f fe			ld (debug_mark+1),a  
49c9 3a d3 49			ld a, (.dmark+2)  
49cc 32 70 fe			ld (debug_mark+2),a  
49cf 18 03			jr .pastdmark  
49d1 ..			.dmark: db "BR2"  
49d4 f1			.pastdmark: pop af  
49d5			endm  
# End of macro DMARK
49d5						CALLMONITOR 
49d5 cd 73 18			call break_point_state  
49d8				endm  
# End of macro CALLMONITOR
49d8					endif 
49d8			 
49d8 cd 55 1f			call forth_push_str 
49db			 
49db			 
49db			.brdone: 
49db			 
49db					NEXTW 
49db c3 55 22			jp macro_next 
49de				endm 
# End of macro NEXTW
49de			.BWRITE: 
49de				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
49de 3a				db WORD_SYS_CORE+38             
49df 73 4a			dw .BUPD            
49e1 07				db 6 + 1 
49e2 .. 00			db "BWRITE",0              
49e9				endm 
# End of macro CWHEAD
49e9			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to address u | DONE 
49e9			 
49e9					if DEBUG_FORTH_WORDS_KEY 
49e9						DMARK "BWR" 
49e9 f5				push af  
49ea 3a fe 49			ld a, (.dmark)  
49ed 32 6e fe			ld (debug_mark),a  
49f0 3a ff 49			ld a, (.dmark+1)  
49f3 32 6f fe			ld (debug_mark+1),a  
49f6 3a 00 4a			ld a, (.dmark+2)  
49f9 32 70 fe			ld (debug_mark+2),a  
49fc 18 03			jr .pastdmark  
49fe ..			.dmark: db "BWR"  
4a01 f1			.pastdmark: pop af  
4a02			endm  
# End of macro DMARK
4a02						CALLMONITOR 
4a02 cd 73 18			call break_point_state  
4a05				endm  
# End of macro CALLMONITOR
4a05					endif 
4a05			 
4a05				FORTH_DSP_VALUEHL 
4a05 cd de 20			call macro_dsp_valuehl 
4a08				endm 
# End of macro FORTH_DSP_VALUEHL
4a08			 
4a08				; calc block address 
4a08			 
4a08 eb				ex de, hl 
4a09 3e 40			ld a, STORE_BLOCK_PHY 
4a0b cd 4f 0e			call Mult16 
4a0e			 
4a0e e5				push hl         ; address 
4a0f			 
4a0f				FORTH_DSP_POP 
4a0f cd 96 21			call macro_forth_dsp_pop 
4a12				endm 
# End of macro FORTH_DSP_POP
4a12			 
4a12				FORTH_DSP_VALUEHL 
4a12 cd de 20			call macro_dsp_valuehl 
4a15				endm 
# End of macro FORTH_DSP_VALUEHL
4a15			 
4a15				FORTH_DSP_POP 
4a15 cd 96 21			call macro_forth_dsp_pop 
4a18				endm 
# End of macro FORTH_DSP_POP
4a18			 
4a18 cd d8 0b			call storage_clear_page 
4a1b			 
4a1b				; copy string to store page 
4a1b			 
4a1b e5				push hl     ; save string address 
4a1c			 
4a1c 3e 00			ld a, 0 
4a1e cd 35 13			call strlent 
4a21			 
4a21 23				inc hl 
4a22			 
4a22 4d				ld c, l 
4a23 06 00			ld b, 0 
4a25			 
4a25 e1				pop hl 
4a26 11 83 fa			ld de, store_page + 2 
4a29					if DEBUG_FORTH_WORDS 
4a29						DMARK "BW1" 
4a29 f5				push af  
4a2a 3a 3e 4a			ld a, (.dmark)  
4a2d 32 6e fe			ld (debug_mark),a  
4a30 3a 3f 4a			ld a, (.dmark+1)  
4a33 32 6f fe			ld (debug_mark+1),a  
4a36 3a 40 4a			ld a, (.dmark+2)  
4a39 32 70 fe			ld (debug_mark+2),a  
4a3c 18 03			jr .pastdmark  
4a3e ..			.dmark: db "BW1"  
4a41 f1			.pastdmark: pop af  
4a42			endm  
# End of macro DMARK
4a42						CALLMONITOR 
4a42 cd 73 18			call break_point_state  
4a45				endm  
# End of macro CALLMONITOR
4a45					endif 
4a45 ed b0			ldir 
4a47			 
4a47			 
4a47				; poke the start of the block with flags to prevent high level file ops hitting the block 
4a47			 
4a47 21 ff ff			ld hl, $ffff 
4a4a			 
4a4a 22 81 fa			ld (store_page), hl	 
4a4d				 
4a4d e1				pop hl    ; get address 
4a4e 11 81 fa			ld de, store_page 
4a51			 
4a51					if DEBUG_FORTH_WORDS 
4a51						DMARK "BW2" 
4a51 f5				push af  
4a52 3a 66 4a			ld a, (.dmark)  
4a55 32 6e fe			ld (debug_mark),a  
4a58 3a 67 4a			ld a, (.dmark+1)  
4a5b 32 6f fe			ld (debug_mark+1),a  
4a5e 3a 68 4a			ld a, (.dmark+2)  
4a61 32 70 fe			ld (debug_mark+2),a  
4a64 18 03			jr .pastdmark  
4a66 ..			.dmark: db "BW2"  
4a69 f1			.pastdmark: pop af  
4a6a			endm  
# End of macro DMARK
4a6a						CALLMONITOR 
4a6a cd 73 18			call break_point_state  
4a6d				endm  
# End of macro CALLMONITOR
4a6d					endif 
4a6d			 
4a6d cd 39 04			call storage_write_block 
4a70			 
4a70					NEXTW 
4a70 c3 55 22			jp macro_next 
4a73				endm 
# End of macro NEXTW
4a73			 
4a73			.BUPD: 
4a73				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
4a73 3a				db WORD_SYS_CORE+38             
4a74 c9 4a			dw .BYID            
4a76 05				db 4 + 1 
4a77 .. 00			db "BUPD",0              
4a7c				endm 
# End of macro CWHEAD
4a7c			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to address u | DONE 
4a7c			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4a7c			; | | or completely different file system structure. 
4a7c			 
4a7c					if DEBUG_FORTH_WORDS_KEY 
4a7c						DMARK "BUD" 
4a7c f5				push af  
4a7d 3a 91 4a			ld a, (.dmark)  
4a80 32 6e fe			ld (debug_mark),a  
4a83 3a 92 4a			ld a, (.dmark+1)  
4a86 32 6f fe			ld (debug_mark+1),a  
4a89 3a 93 4a			ld a, (.dmark+2)  
4a8c 32 70 fe			ld (debug_mark+2),a  
4a8f 18 03			jr .pastdmark  
4a91 ..			.dmark: db "BUD"  
4a94 f1			.pastdmark: pop af  
4a95			endm  
# End of macro DMARK
4a95						CALLMONITOR 
4a95 cd 73 18			call break_point_state  
4a98				endm  
# End of macro CALLMONITOR
4a98					endif 
4a98			 
4a98				FORTH_DSP_VALUEHL 
4a98 cd de 20			call macro_dsp_valuehl 
4a9b				endm 
# End of macro FORTH_DSP_VALUEHL
4a9b			 
4a9b				; calc block address 
4a9b			 
4a9b eb				ex de, hl 
4a9c 3e 40			ld a, STORE_BLOCK_PHY 
4a9e cd 4f 0e			call Mult16 
4aa1			 
4aa1				FORTH_DSP_POP 
4aa1 cd 96 21			call macro_forth_dsp_pop 
4aa4				endm 
# End of macro FORTH_DSP_POP
4aa4			 
4aa4			 
4aa4 11 81 fa			ld de, store_page 
4aa7			 
4aa7					if DEBUG_FORTH_WORDS 
4aa7						DMARK "BUe" 
4aa7 f5				push af  
4aa8 3a bc 4a			ld a, (.dmark)  
4aab 32 6e fe			ld (debug_mark),a  
4aae 3a bd 4a			ld a, (.dmark+1)  
4ab1 32 6f fe			ld (debug_mark+1),a  
4ab4 3a be 4a			ld a, (.dmark+2)  
4ab7 32 70 fe			ld (debug_mark+2),a  
4aba 18 03			jr .pastdmark  
4abc ..			.dmark: db "BUe"  
4abf f1			.pastdmark: pop af  
4ac0			endm  
# End of macro DMARK
4ac0						CALLMONITOR 
4ac0 cd 73 18			call break_point_state  
4ac3				endm  
# End of macro CALLMONITOR
4ac3					endif 
4ac3			 
4ac3 cd 39 04			call storage_write_block 
4ac6			 
4ac6					NEXTW 
4ac6 c3 55 22			jp macro_next 
4ac9				endm 
# End of macro NEXTW
4ac9			 
4ac9			.BYID: 
4ac9			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
4ac9			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
4ac9			; 
4ac9			;		 
4ac9			;		if DEBUG_FORTH_WORDS_KEY 
4ac9			;			DMARK "BYID" 
4ac9			;			CALLMONITOR 
4ac9			;		endif 
4ac9			; 
4ac9			;		; get direct address 
4ac9			; 
4ac9			;		FORTH_DSP_VALUEHL 
4ac9			; 
4ac9			;		FORTH_DSP_POP 
4ac9			; 
4ac9			;	; calc block address 
4ac9			; 
4ac9			;	ex de, hl 
4ac9			;	ld a, STORE_BLOCK_PHY 
4ac9			;	call Mult16 
4ac9			;	;	do BREAD with number as param 
4ac9			;	; push the file name	 
4ac9			;	ld de, store_page 
4ac9			;	call storage_read_block 
4ac9			 ;       ld hl, store_page+2 
4ac9			; 
4ac9			; 
4ac9			;		NEXTW 
4ac9			;.BYNAME: 
4ac9				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
4ac9 3a				db WORD_SYS_CORE+38             
4aca e2 4a			dw .DIR            
4acc 06				db 5 + 1 
4acd .. 00			db "GETID",0              
4ad3				endm 
# End of macro CWHEAD
4ad3			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
4ad3			 
4ad3					; get pointer to file name to seek 
4ad3			 
4ad3					FORTH_DSP_VALUEHL 
4ad3 cd de 20			call macro_dsp_valuehl 
4ad6				endm 
# End of macro FORTH_DSP_VALUEHL
4ad6			 
4ad6			 
4ad6 cd fb 02				call storage_getid  
4ad9			 
4ad9					FORTH_DSP_POP 
4ad9 cd 96 21			call macro_forth_dsp_pop 
4adc				endm 
# End of macro FORTH_DSP_POP
4adc			 
4adc cd e7 1e				call forth_push_numhl 
4adf			 
4adf					NEXTW 
4adf c3 55 22			jp macro_next 
4ae2				endm 
# End of macro NEXTW
4ae2			; 
4ae2			.DIR: 
4ae2				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4ae2 3a				db WORD_SYS_CORE+38             
4ae3 e6 4b			dw .SAVE            
4ae5 04				db 3 + 1 
4ae6 .. 00			db "DIR",0              
4aea				endm 
# End of macro CWHEAD
4aea			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
4aea			 
4aea					if DEBUG_FORTH_WORDS_KEY 
4aea						DMARK "DIR" 
4aea f5				push af  
4aeb 3a ff 4a			ld a, (.dmark)  
4aee 32 6e fe			ld (debug_mark),a  
4af1 3a 00 4b			ld a, (.dmark+1)  
4af4 32 6f fe			ld (debug_mark+1),a  
4af7 3a 01 4b			ld a, (.dmark+2)  
4afa 32 70 fe			ld (debug_mark+2),a  
4afd 18 03			jr .pastdmark  
4aff ..			.dmark: db "DIR"  
4b02 f1			.pastdmark: pop af  
4b03			endm  
# End of macro DMARK
4b03						CALLMONITOR 
4b03 cd 73 18			call break_point_state  
4b06				endm  
# End of macro CALLMONITOR
4b06					endif 
4b06 cd 85 04			call storage_get_block_0 
4b09			 
4b09 21 81 fa			ld hl, store_page     ; get current id count 
4b0c 46				ld b, (hl) 
4b0d 0e 00			ld c, 0    ; count of files   
4b0f					if DEBUG_FORTH_WORDS 
4b0f						DMARK "DI1" 
4b0f f5				push af  
4b10 3a 24 4b			ld a, (.dmark)  
4b13 32 6e fe			ld (debug_mark),a  
4b16 3a 25 4b			ld a, (.dmark+1)  
4b19 32 6f fe			ld (debug_mark+1),a  
4b1c 3a 26 4b			ld a, (.dmark+2)  
4b1f 32 70 fe			ld (debug_mark+2),a  
4b22 18 03			jr .pastdmark  
4b24 ..			.dmark: db "DI1"  
4b27 f1			.pastdmark: pop af  
4b28			endm  
# End of macro DMARK
4b28						CALLMONITOR 
4b28 cd 73 18			call break_point_state  
4b2b				endm  
# End of macro CALLMONITOR
4b2b					endif 
4b2b			 
4b2b				; check for empty drive 
4b2b			 
4b2b 3e 00			ld a, 0 
4b2d b8				cp b 
4b2e ca 9c 4b			jp z, .dirdone 
4b31			 
4b31				; for each of the current ids do a search for them and if found push to stack 
4b31			 
4b31 c5			.diritem:	push bc 
4b32 21 40 00				ld hl, STORE_BLOCK_PHY 
4b35 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
4b37 58					ld e,b 
4b38			 
4b38			;		if DEBUG_FORTH_WORDS 
4b38			;			DMARK "DI2" 
4b38			;			CALLMONITOR 
4b38			;		endif 
4b38			 
4b38 cd 07 07				call storage_findnextid 
4b3b			 
4b3b			;		if DEBUG_FORTH_WORDS 
4b3b			;			DMARK "DI3" 
4b3b			;			CALLMONITOR 
4b3b			;		endif 
4b3b			 
4b3b					; if found hl will be non zero 
4b3b			 
4b3b cd f5 0e				call ishlzero 
4b3e			;		ld a, l 
4b3e			;		add h 
4b3e			; 
4b3e			;		cp 0 
4b3e 28 59				jr z, .dirnotfound 
4b40			 
4b40					; increase count 
4b40			 
4b40 c1					pop bc	 
4b41 0c					inc c 
4b42 c5					push bc 
4b43					 
4b43			 
4b43					; get file header and push the file name 
4b43			 
4b43 11 81 fa				ld de, store_page 
4b46 cd d4 03				call storage_read_block 
4b49			 
4b49					; push file id to stack 
4b49				 
4b49 3a 81 fa				ld a, (store_page) 
4b4c 26 00				ld h, 0 
4b4e 6f					ld l, a 
4b4f cd e7 1e				call forth_push_numhl 
4b52			 
4b52					; push extent count to stack  
4b52				 
4b52 3a 83 fa				ld a, (store_page+2) 
4b55 26 00				ld h, 0 
4b57 6f					ld l, a 
4b58 cd e7 1e				call forth_push_numhl 
4b5b			 
4b5b					; push file name 
4b5b			 
4b5b 21 84 fa				ld hl, store_page+3 
4b5e					if DEBUG_FORTH_WORDS 
4b5e						DMARK "DI5" 
4b5e f5				push af  
4b5f 3a 73 4b			ld a, (.dmark)  
4b62 32 6e fe			ld (debug_mark),a  
4b65 3a 74 4b			ld a, (.dmark+1)  
4b68 32 6f fe			ld (debug_mark+1),a  
4b6b 3a 75 4b			ld a, (.dmark+2)  
4b6e 32 70 fe			ld (debug_mark+2),a  
4b71 18 03			jr .pastdmark  
4b73 ..			.dmark: db "DI5"  
4b76 f1			.pastdmark: pop af  
4b77			endm  
# End of macro DMARK
4b77						CALLMONITOR 
4b77 cd 73 18			call break_point_state  
4b7a				endm  
# End of macro CALLMONITOR
4b7a					endif 
4b7a cd 55 1f				call forth_push_str 
4b7d					if DEBUG_FORTH_WORDS 
4b7d						DMARK "DI6" 
4b7d f5				push af  
4b7e 3a 92 4b			ld a, (.dmark)  
4b81 32 6e fe			ld (debug_mark),a  
4b84 3a 93 4b			ld a, (.dmark+1)  
4b87 32 6f fe			ld (debug_mark+1),a  
4b8a 3a 94 4b			ld a, (.dmark+2)  
4b8d 32 70 fe			ld (debug_mark+2),a  
4b90 18 03			jr .pastdmark  
4b92 ..			.dmark: db "DI6"  
4b95 f1			.pastdmark: pop af  
4b96			endm  
# End of macro DMARK
4b96						CALLMONITOR 
4b96 cd 73 18			call break_point_state  
4b99				endm  
# End of macro CALLMONITOR
4b99					endif 
4b99			.dirnotfound: 
4b99 c1					pop bc     
4b9a 10 95				djnz .diritem 
4b9c				 
4b9c			.dirdone:	 
4b9c					if DEBUG_FORTH_WORDS 
4b9c						DMARK "DI7" 
4b9c f5				push af  
4b9d 3a b1 4b			ld a, (.dmark)  
4ba0 32 6e fe			ld (debug_mark),a  
4ba3 3a b2 4b			ld a, (.dmark+1)  
4ba6 32 6f fe			ld (debug_mark+1),a  
4ba9 3a b3 4b			ld a, (.dmark+2)  
4bac 32 70 fe			ld (debug_mark+2),a  
4baf 18 03			jr .pastdmark  
4bb1 ..			.dmark: db "DI7"  
4bb4 f1			.pastdmark: pop af  
4bb5			endm  
# End of macro DMARK
4bb5						CALLMONITOR 
4bb5 cd 73 18			call break_point_state  
4bb8				endm  
# End of macro CALLMONITOR
4bb8					endif 
4bb8			 
4bb8					; push a count of the dir items found 
4bb8			 
4bb8 26 00				ld h, 0 
4bba 69					ld l, c 
4bbb cd e7 1e				call forth_push_numhl 
4bbe			 
4bbe					; push the bank label 
4bbe			 
4bbe cd 85 04				call storage_get_block_0 
4bc1			 
4bc1				 
4bc1 21 84 fa		 		ld hl, store_page+3 
4bc4			 
4bc4					if DEBUG_FORTH_WORDS 
4bc4						DMARK "DI8" 
4bc4 f5				push af  
4bc5 3a d9 4b			ld a, (.dmark)  
4bc8 32 6e fe			ld (debug_mark),a  
4bcb 3a da 4b			ld a, (.dmark+1)  
4bce 32 6f fe			ld (debug_mark+1),a  
4bd1 3a db 4b			ld a, (.dmark+2)  
4bd4 32 70 fe			ld (debug_mark+2),a  
4bd7 18 03			jr .pastdmark  
4bd9 ..			.dmark: db "DI8"  
4bdc f1			.pastdmark: pop af  
4bdd			endm  
# End of macro DMARK
4bdd						CALLMONITOR 
4bdd cd 73 18			call break_point_state  
4be0				endm  
# End of macro CALLMONITOR
4be0					endif 
4be0 cd 55 1f				call forth_push_str 
4be3			 
4be3			 
4be3				 
4be3					NEXTW 
4be3 c3 55 22			jp macro_next 
4be6				endm 
# End of macro NEXTW
4be6			.SAVE: 
4be6			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
4be6			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
4be6			;		NEXTW 
4be6			;.LOAD: 
4be6			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4be6			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
4be6			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
4be6			;; > > The LOAD command can not be used in any user words or compound lines. 
4be6			; 
4be6			;		; store_openext use it. If zero it is EOF 
4be6			; 
4be6			;		; read block from current stream id 
4be6			;		; if the block does not contain zero term keep reading blocks until zero found 
4be6			;		; push the block to stack 
4be6			;		; save the block id to stream 
4be6			; 
4be6			; 
4be6			;		FORTH_DSP_VALUEHL 
4be6			; 
4be6			;;		push hl 
4be6			; 
4be6			;	if DEBUG_STORESE 
4be6			;		DMARK "LOA" 
4be6			;		CALLMONITOR 
4be6			;	endif 
4be6			;		FORTH_DSP_POP 
4be6			; 
4be6			;;		pop hl 
4be6			; 
4be6			;		ld h, l 
4be6			;		ld l, 0 
4be6			; 
4be6			;		push hl     ; stack holds current file id and extent to work with 
4be6			; 
4be6			; 
4be6			;		ld de, store_page      ; get block zero of file 
4be6			;	if DEBUG_STORESE 
4be6			;		DMARK "LO0" 
4be6			;		CALLMONITOR 
4be6			;	endif 
4be6			;		call storage_read 
4be6			; 
4be6			;		ld a, (store_page+2)    ; max extents for this file 
4be6			;		ld  (store_openmaxext),a   ; get our limit 
4be6			; 
4be6			;	if DEBUG_STORESE 
4be6			;		DMARK "LOE" 
4be6			;		CALLMONITOR 
4be6			;	endif 
4be6			; 
4be6			;; TODO dont know why max extents are not present 
4be6			;;		cp 0 
4be6			;;		jp z, .loadeof     ; dont read past eof 
4be6			; 
4be6			;;		ld a, 1   ; start from the head of the file 
4be6			; 
4be6			;.loadline:	pop hl 
4be6			;		inc hl 
4be6			;		ld  a, (store_openmaxext)   ; get our limit 
4be6			;	if DEBUG_STORESE 
4be6			;		DMARK "LOx" 
4be6			;		CALLMONITOR 
4be6			;	endif 
4be6			;		inc a 
4be6			;		cp l 
4be6			;		jp z, .loadeof 
4be6			;		push hl    ; save current extent 
4be6			; 
4be6			;		ld de, store_page 
4be6			; 
4be6			;	if DEBUG_STORESE 
4be6			;		DMARK "LO1" 
4be6			;		CALLMONITOR 
4be6			;	endif 
4be6			;		call storage_read 
4be6			; 
4be6			;	if DEBUG_STORESE 
4be6			;		DMARK "LO2" 
4be6			;		CALLMONITOR 
4be6			;	endif 
4be6			;	call ishlzero 
4be6			;	ld a, l 
4be6			;	add h 
4be6			;	cp 0 
4be6			;	jr z, .loadeof 
4be6			; 
4be6			;	; not eof so hl should point to data to exec 
4be6			; 
4be6			;	; will need to add the FORTH_END_BUFFER flag 
4be6			 ; 
4be6			;	ld hl, store_page+2 
4be6			;	ld bc, 255 
4be6			;	ld a, 0 
4be6			;	cpir 
4be6			;	if DEBUG_STORESE 
4be6			;		DMARK "LOt" 
4be6			;		CALLMONITOR 
4be6			;	endif 
4be6			;	dec hl 
4be6			;	ld a, ' ' 
4be6			;	ld (hl), a 
4be6			;	inc hl 
4be6			;	ld (hl), a 
4be6			;	inc hl 
4be6			;	ld (hl), a 
4be6			;	inc hl 
4be6			;	ld a, FORTH_END_BUFFER 
4be6			;	ld (hl), a 
4be6			; 
4be6			;	; TODO handle more than a single block read 
4be6			; 
4be6			; 
4be6			;	ld hl, store_page+2 
4be6			; 
4be6			;	ld (os_tok_ptr), hl 
4be6			; 
4be6			;	if DEBUG_STORESE 
4be6			;		DMARK "LO3" 
4be6			;		CALLMONITOR 
4be6			;	endif 
4be6			; 
4be6			;	call forthparse 
4be6			;	call forthexec 
4be6			;	call forthexec_cleanup 
4be6			; 
4be6			;	; go to next extent 
4be6			; 
4be6			;	; get next block  or mark as eof 
4be6			;	jp .loadline 
4be6			; 
4be6			; 
4be6			; 
4be6			;	       NEXTW 
4be6			;.loadeof:	ld a, 0 
4be6			;		ld (store_openext), a 
4be6			; 
4be6			;	if DEBUG_STORESE 
4be6			;		DMARK "LOF" 
4be6			;		CALLMONITOR 
4be6			;	endif 
4be6			;		ret 
4be6			;		;NEXTW 
4be6			;.BSAVE:   
4be6			; 
4be6			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
4be6			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
4be6			;		NEXTW 
4be6			;.BLOAD: 
4be6			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
4be6			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
4be6			;		NEXTW 
4be6			;;;; counter gap 
4be6			 
4be6			 
4be6			.SEO: 
4be6				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
4be6 64				db WORD_SYS_CORE+80             
4be7 05 4c			dw .SEI            
4be9 04				db 3 + 1 
4bea .. 00			db "SEO",0              
4bee				endm 
# End of macro CWHEAD
4bee			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
4bee			 
4bee					; get port 
4bee			 
4bee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bee cd de 20			call macro_dsp_valuehl 
4bf1				endm 
# End of macro FORTH_DSP_VALUEHL
4bf1			 
4bf1 e5					push hl    ; u2 - byte 
4bf2			 
4bf2					; destroy value TOS 
4bf2			 
4bf2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bf2 cd 96 21			call macro_forth_dsp_pop 
4bf5				endm 
# End of macro FORTH_DSP_POP
4bf5			 
4bf5					; get byte to send 
4bf5			 
4bf5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bf5 cd de 20			call macro_dsp_valuehl 
4bf8				endm 
# End of macro FORTH_DSP_VALUEHL
4bf8			 
4bf8 e5					push hl    ; u1 - addr 
4bf9			 
4bf9					; destroy value TOS 
4bf9			 
4bf9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bf9 cd 96 21			call macro_forth_dsp_pop 
4bfc				endm 
# End of macro FORTH_DSP_POP
4bfc			 
4bfc					; one value on hl get other one back 
4bfc			 
4bfc d1					pop de   ; u1 - byte 
4bfd			 
4bfd e1					pop hl   ; u2 - addr 
4bfe			 
4bfe					; TODO Send SPI byte 
4bfe			 
4bfe			 
4bfe 7b					ld a, e 
4bff cd d9 01				call se_writebyte 
4c02			 
4c02					 
4c02			 
4c02					NEXTW 
4c02 c3 55 22			jp macro_next 
4c05				endm 
# End of macro NEXTW
4c05			 
4c05			.SEI: 
4c05				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4c05 65				db WORD_SYS_CORE+81             
4c06 1f 4c			dw .SFREE            
4c08 04				db 3 + 1 
4c09 .. 00			db "SEI",0              
4c0d				endm 
# End of macro CWHEAD
4c0d			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
4c0d			 
4c0d					; get port 
4c0d			 
4c0d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c0d cd de 20			call macro_dsp_valuehl 
4c10				endm 
# End of macro FORTH_DSP_VALUEHL
4c10			 
4c10			;		push hl 
4c10			 
4c10					; destroy value TOS 
4c10			 
4c10					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c10 cd 96 21			call macro_forth_dsp_pop 
4c13				endm 
# End of macro FORTH_DSP_POP
4c13			 
4c13					; one value on hl get other one back 
4c13			 
4c13			;		pop hl 
4c13			 
4c13			 
4c13					; TODO Get SPI byte 
4c13			 
4c13 cd 7b 02				call se_readbyte 
4c16			 
4c16 26 00				ld h, 0 
4c18 6f					ld l, a 
4c19 cd e7 1e				call forth_push_numhl 
4c1c			 
4c1c					NEXTW 
4c1c c3 55 22			jp macro_next 
4c1f				endm 
# End of macro NEXTW
4c1f			 
4c1f			.SFREE: 
4c1f				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
4c1f 67				db WORD_SYS_CORE+83             
4c20 4e 4c			dw .SIZE            
4c22 06				db 5 + 1 
4c23 .. 00			db "FFREE",0              
4c29				endm 
# End of macro CWHEAD
4c29			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4c29					if DEBUG_FORTH_WORDS_KEY 
4c29						DMARK "FFR" 
4c29 f5				push af  
4c2a 3a 3e 4c			ld a, (.dmark)  
4c2d 32 6e fe			ld (debug_mark),a  
4c30 3a 3f 4c			ld a, (.dmark+1)  
4c33 32 6f fe			ld (debug_mark+1),a  
4c36 3a 40 4c			ld a, (.dmark+2)  
4c39 32 70 fe			ld (debug_mark+2),a  
4c3c 18 03			jr .pastdmark  
4c3e ..			.dmark: db "FFR"  
4c41 f1			.pastdmark: pop af  
4c42			endm  
# End of macro DMARK
4c42						CALLMONITOR 
4c42 cd 73 18			call break_point_state  
4c45				endm  
# End of macro CALLMONITOR
4c45					endif 
4c45			 
4c45 cd a1 07				call storage_freeblocks 
4c48			 
4c48 cd e7 1e				call forth_push_numhl 
4c4b			 
4c4b				       NEXTW 
4c4b c3 55 22			jp macro_next 
4c4e				endm 
# End of macro NEXTW
4c4e			.SIZE: 
4c4e				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
4c4e 67				db WORD_SYS_CORE+83             
4c4f 82 4c			dw .CREATE            
4c51 05				db 4 + 1 
4c52 .. 00			db "SIZE",0              
4c57				endm 
# End of macro CWHEAD
4c57			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4c57					if DEBUG_FORTH_WORDS_KEY 
4c57						DMARK "SIZ" 
4c57 f5				push af  
4c58 3a 6c 4c			ld a, (.dmark)  
4c5b 32 6e fe			ld (debug_mark),a  
4c5e 3a 6d 4c			ld a, (.dmark+1)  
4c61 32 6f fe			ld (debug_mark+1),a  
4c64 3a 6e 4c			ld a, (.dmark+2)  
4c67 32 70 fe			ld (debug_mark+2),a  
4c6a 18 03			jr .pastdmark  
4c6c ..			.dmark: db "SIZ"  
4c6f f1			.pastdmark: pop af  
4c70			endm  
# End of macro DMARK
4c70						CALLMONITOR 
4c70 cd 73 18			call break_point_state  
4c73				endm  
# End of macro CALLMONITOR
4c73					endif 
4c73			 
4c73					FORTH_DSP_VALUEHL 
4c73 cd de 20			call macro_dsp_valuehl 
4c76				endm 
# End of macro FORTH_DSP_VALUEHL
4c76			;		push hl 
4c76					FORTH_DSP_POP 
4c76 cd 96 21			call macro_forth_dsp_pop 
4c79				endm 
# End of macro FORTH_DSP_POP
4c79			;		pop hl 
4c79 cd 03 04				call storage_file_size 
4c7c			 
4c7c cd e7 1e				call forth_push_numhl 
4c7f			  
4c7f			 
4c7f				       NEXTW 
4c7f c3 55 22			jp macro_next 
4c82				endm 
# End of macro NEXTW
4c82			 
4c82			.CREATE: 
4c82				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
4c82 68				db WORD_SYS_CORE+84             
4c83 f0 4c			dw .APPEND            
4c85 07				db 6 + 1 
4c86 .. 00			db "CREATE",0              
4c8d				endm 
# End of macro CWHEAD
4c8d			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
4c8d			; | | e.g.  
4c8d			; | | TestProgram CREATE 
4c8d			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
4c8d			; | |  
4c8d			; | | Max file IDs are 255. 
4c8d			; | |  
4c8d					 
4c8d					if DEBUG_FORTH_WORDS_KEY 
4c8d						DMARK "CRT" 
4c8d f5				push af  
4c8e 3a a2 4c			ld a, (.dmark)  
4c91 32 6e fe			ld (debug_mark),a  
4c94 3a a3 4c			ld a, (.dmark+1)  
4c97 32 6f fe			ld (debug_mark+1),a  
4c9a 3a a4 4c			ld a, (.dmark+2)  
4c9d 32 70 fe			ld (debug_mark+2),a  
4ca0 18 03			jr .pastdmark  
4ca2 ..			.dmark: db "CRT"  
4ca5 f1			.pastdmark: pop af  
4ca6			endm  
# End of macro DMARK
4ca6						CALLMONITOR 
4ca6 cd 73 18			call break_point_state  
4ca9				endm  
# End of macro CALLMONITOR
4ca9					endif 
4ca9			;		call storage_get_block_0 
4ca9			 
4ca9					; TODO pop hl 
4ca9			 
4ca9					;v5 FORTH_DSP_VALUE 
4ca9					FORTH_DSP_VALUE 
4ca9 cd c7 20			call macro_forth_dsp_value 
4cac				endm 
# End of macro FORTH_DSP_VALUE
4cac			 
4cac				if DEBUG_STORESE 
4cac					DMARK "CR1" 
4cac f5				push af  
4cad 3a c1 4c			ld a, (.dmark)  
4cb0 32 6e fe			ld (debug_mark),a  
4cb3 3a c2 4c			ld a, (.dmark+1)  
4cb6 32 6f fe			ld (debug_mark+1),a  
4cb9 3a c3 4c			ld a, (.dmark+2)  
4cbc 32 70 fe			ld (debug_mark+2),a  
4cbf 18 03			jr .pastdmark  
4cc1 ..			.dmark: db "CR1"  
4cc4 f1			.pastdmark: pop af  
4cc5			endm  
# End of macro DMARK
4cc5					CALLMONITOR 
4cc5 cd 73 18			call break_point_state  
4cc8				endm  
# End of macro CALLMONITOR
4cc8				endif 
4cc8			;		push hl 
4cc8			;		FORTH_DSP_POP 
4cc8			;		pop hl 
4cc8			 
4cc8			;		inc hl   ; move past the type marker 
4cc8			 
4cc8 cd d7 07				call storage_create 
4ccb			 
4ccb				if DEBUG_STORESE 
4ccb					DMARK "CT1" 
4ccb f5				push af  
4ccc 3a e0 4c			ld a, (.dmark)  
4ccf 32 6e fe			ld (debug_mark),a  
4cd2 3a e1 4c			ld a, (.dmark+1)  
4cd5 32 6f fe			ld (debug_mark+1),a  
4cd8 3a e2 4c			ld a, (.dmark+2)  
4cdb 32 70 fe			ld (debug_mark+2),a  
4cde 18 03			jr .pastdmark  
4ce0 ..			.dmark: db "CT1"  
4ce3 f1			.pastdmark: pop af  
4ce4			endm  
# End of macro DMARK
4ce4					CALLMONITOR 
4ce4 cd 73 18			call break_point_state  
4ce7				endm  
# End of macro CALLMONITOR
4ce7				endif 
4ce7			;		push hl 
4ce7					FORTH_DSP_POP 
4ce7 cd 96 21			call macro_forth_dsp_pop 
4cea				endm 
# End of macro FORTH_DSP_POP
4cea			;		pop hl 
4cea					; push file id to stack 
4cea cd e7 1e				call forth_push_numhl 
4ced			 
4ced			 
4ced			 
4ced				       NEXTW 
4ced c3 55 22			jp macro_next 
4cf0				endm 
# End of macro NEXTW
4cf0			 
4cf0			.APPEND: 
4cf0				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
4cf0 69				db WORD_SYS_CORE+85             
4cf1 81 4d			dw .SDEL            
4cf3 07				db 6 + 1 
4cf4 .. 00			db "APPEND",0              
4cfb				endm 
# End of macro CWHEAD
4cfb			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
4cfb			; | | e.g. 
4cfb			; | | Test CREATE      -> $01 
4cfb			; | | "A string to add to file" $01 APPEND 
4cfb			; | |  
4cfb			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4cfb					if DEBUG_FORTH_WORDS_KEY 
4cfb						DMARK "APP" 
4cfb f5				push af  
4cfc 3a 10 4d			ld a, (.dmark)  
4cff 32 6e fe			ld (debug_mark),a  
4d02 3a 11 4d			ld a, (.dmark+1)  
4d05 32 6f fe			ld (debug_mark+1),a  
4d08 3a 12 4d			ld a, (.dmark+2)  
4d0b 32 70 fe			ld (debug_mark+2),a  
4d0e 18 03			jr .pastdmark  
4d10 ..			.dmark: db "APP"  
4d13 f1			.pastdmark: pop af  
4d14			endm  
# End of macro DMARK
4d14						CALLMONITOR 
4d14 cd 73 18			call break_point_state  
4d17				endm  
# End of macro CALLMONITOR
4d17					endif 
4d17			 
4d17					FORTH_DSP_VALUEHL 
4d17 cd de 20			call macro_dsp_valuehl 
4d1a				endm 
# End of macro FORTH_DSP_VALUEHL
4d1a e5					push hl 	; save file id 
4d1b			 
4d1b				if DEBUG_STORESE 
4d1b					DMARK "AP1" 
4d1b f5				push af  
4d1c 3a 30 4d			ld a, (.dmark)  
4d1f 32 6e fe			ld (debug_mark),a  
4d22 3a 31 4d			ld a, (.dmark+1)  
4d25 32 6f fe			ld (debug_mark+1),a  
4d28 3a 32 4d			ld a, (.dmark+2)  
4d2b 32 70 fe			ld (debug_mark+2),a  
4d2e 18 03			jr .pastdmark  
4d30 ..			.dmark: db "AP1"  
4d33 f1			.pastdmark: pop af  
4d34			endm  
# End of macro DMARK
4d34					CALLMONITOR 
4d34 cd 73 18			call break_point_state  
4d37				endm  
# End of macro CALLMONITOR
4d37				endif 
4d37					FORTH_DSP_POP 
4d37 cd 96 21			call macro_forth_dsp_pop 
4d3a				endm 
# End of macro FORTH_DSP_POP
4d3a			 
4d3a					FORTH_DSP_VALUEHL 
4d3a cd de 20			call macro_dsp_valuehl 
4d3d				endm 
# End of macro FORTH_DSP_VALUEHL
4d3d					;v5 FORTH_DSP_VALUE 
4d3d e5					push hl 	; save ptr to string to save 
4d3e			 
4d3e				if DEBUG_STORESE 
4d3e					DMARK "AP1" 
4d3e f5				push af  
4d3f 3a 53 4d			ld a, (.dmark)  
4d42 32 6e fe			ld (debug_mark),a  
4d45 3a 54 4d			ld a, (.dmark+1)  
4d48 32 6f fe			ld (debug_mark+1),a  
4d4b 3a 55 4d			ld a, (.dmark+2)  
4d4e 32 70 fe			ld (debug_mark+2),a  
4d51 18 03			jr .pastdmark  
4d53 ..			.dmark: db "AP1"  
4d56 f1			.pastdmark: pop af  
4d57			endm  
# End of macro DMARK
4d57					CALLMONITOR 
4d57 cd 73 18			call break_point_state  
4d5a				endm  
# End of macro CALLMONITOR
4d5a				endif 
4d5a					FORTH_DSP_POP 
4d5a cd 96 21			call macro_forth_dsp_pop 
4d5d				endm 
# End of macro FORTH_DSP_POP
4d5d			 
4d5d d1					pop de 
4d5e e1					pop hl 
4d5f				if DEBUG_STORESE 
4d5f					DMARK "AP2" 
4d5f f5				push af  
4d60 3a 74 4d			ld a, (.dmark)  
4d63 32 6e fe			ld (debug_mark),a  
4d66 3a 75 4d			ld a, (.dmark+1)  
4d69 32 6f fe			ld (debug_mark+1),a  
4d6c 3a 76 4d			ld a, (.dmark+2)  
4d6f 32 70 fe			ld (debug_mark+2),a  
4d72 18 03			jr .pastdmark  
4d74 ..			.dmark: db "AP2"  
4d77 f1			.pastdmark: pop af  
4d78			endm  
# End of macro DMARK
4d78					CALLMONITOR 
4d78 cd 73 18			call break_point_state  
4d7b				endm  
# End of macro CALLMONITOR
4d7b				endif 
4d7b					;inc de ; skip var type indicator 
4d7b			 
4d7b					; TODO how to append numerics???? 
4d7b			 
4d7b cd 8c 0a				call storage_append		 
4d7e			 
4d7e				       NEXTW 
4d7e c3 55 22			jp macro_next 
4d81				endm 
# End of macro NEXTW
4d81			.SDEL: 
4d81				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
4d81 6a				db WORD_SYS_CORE+86             
4d82 cd 4d			dw .OPEN            
4d84 05				db 4 + 1 
4d85 .. 00			db "ERA",0              
4d89				endm 
# End of macro CWHEAD
4d89			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4d89					FORTH_DSP_VALUEHL 
4d89 cd de 20			call macro_dsp_valuehl 
4d8c				endm 
# End of macro FORTH_DSP_VALUEHL
4d8c			;		push hl 	; save file id 
4d8c			 
4d8c					if DEBUG_FORTH_WORDS_KEY 
4d8c						DMARK "ERA" 
4d8c f5				push af  
4d8d 3a a1 4d			ld a, (.dmark)  
4d90 32 6e fe			ld (debug_mark),a  
4d93 3a a2 4d			ld a, (.dmark+1)  
4d96 32 6f fe			ld (debug_mark+1),a  
4d99 3a a3 4d			ld a, (.dmark+2)  
4d9c 32 70 fe			ld (debug_mark+2),a  
4d9f 18 03			jr .pastdmark  
4da1 ..			.dmark: db "ERA"  
4da4 f1			.pastdmark: pop af  
4da5			endm  
# End of macro DMARK
4da5						CALLMONITOR 
4da5 cd 73 18			call break_point_state  
4da8				endm  
# End of macro CALLMONITOR
4da8					endif 
4da8				if DEBUG_STORESE 
4da8					DMARK "ER1" 
4da8 f5				push af  
4da9 3a bd 4d			ld a, (.dmark)  
4dac 32 6e fe			ld (debug_mark),a  
4daf 3a be 4d			ld a, (.dmark+1)  
4db2 32 6f fe			ld (debug_mark+1),a  
4db5 3a bf 4d			ld a, (.dmark+2)  
4db8 32 70 fe			ld (debug_mark+2),a  
4dbb 18 03			jr .pastdmark  
4dbd ..			.dmark: db "ER1"  
4dc0 f1			.pastdmark: pop af  
4dc1			endm  
# End of macro DMARK
4dc1					CALLMONITOR 
4dc1 cd 73 18			call break_point_state  
4dc4				endm  
# End of macro CALLMONITOR
4dc4				endif 
4dc4					FORTH_DSP_POP 
4dc4 cd 96 21			call macro_forth_dsp_pop 
4dc7				endm 
# End of macro FORTH_DSP_POP
4dc7			 
4dc7			;		pop hl 
4dc7			 
4dc7 cd 16 06				call storage_erase 
4dca				       NEXTW 
4dca c3 55 22			jp macro_next 
4dcd				endm 
# End of macro NEXTW
4dcd			 
4dcd			.OPEN: 
4dcd				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
4dcd 6b				db WORD_SYS_CORE+87             
4dce 5d 4e			dw .READ            
4dd0 05				db 4 + 1 
4dd1 .. 00			db "OPEN",0              
4dd6				endm 
# End of macro CWHEAD
4dd6			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
4dd6			; | | e.g. 
4dd6			; | | $01 OPEN $01 DO $01 READ . LOOP 
4dd6			; | | 
4dd6			; | | Will return with 255 blocks if the file does not exist 
4dd6			 
4dd6					if DEBUG_FORTH_WORDS_KEY 
4dd6						DMARK "OPN" 
4dd6 f5				push af  
4dd7 3a eb 4d			ld a, (.dmark)  
4dda 32 6e fe			ld (debug_mark),a  
4ddd 3a ec 4d			ld a, (.dmark+1)  
4de0 32 6f fe			ld (debug_mark+1),a  
4de3 3a ed 4d			ld a, (.dmark+2)  
4de6 32 70 fe			ld (debug_mark+2),a  
4de9 18 03			jr .pastdmark  
4deb ..			.dmark: db "OPN"  
4dee f1			.pastdmark: pop af  
4def			endm  
# End of macro DMARK
4def						CALLMONITOR 
4def cd 73 18			call break_point_state  
4df2				endm  
# End of macro CALLMONITOR
4df2					endif 
4df2					; TODO handle multiple file opens 
4df2			 
4df2 3e 01			       	ld a, 1 
4df4 32 73 fa				ld (store_openext), a 
4df7			 
4df7					; get max extents for this file 
4df7				 
4df7								 
4df7					FORTH_DSP_VALUEHL 
4df7 cd de 20			call macro_dsp_valuehl 
4dfa				endm 
# End of macro FORTH_DSP_VALUEHL
4dfa			 
4dfa 65					ld h, l 
4dfb 2e 00				ld l, 0 
4dfd			 
4dfd				if DEBUG_STORESE 
4dfd					DMARK "OPN" 
4dfd f5				push af  
4dfe 3a 12 4e			ld a, (.dmark)  
4e01 32 6e fe			ld (debug_mark),a  
4e04 3a 13 4e			ld a, (.dmark+1)  
4e07 32 6f fe			ld (debug_mark+1),a  
4e0a 3a 14 4e			ld a, (.dmark+2)  
4e0d 32 70 fe			ld (debug_mark+2),a  
4e10 18 03			jr .pastdmark  
4e12 ..			.dmark: db "OPN"  
4e15 f1			.pastdmark: pop af  
4e16			endm  
# End of macro DMARK
4e16					CALLMONITOR 
4e16 cd 73 18			call break_point_state  
4e19				endm  
# End of macro CALLMONITOR
4e19				endif 
4e19			;		push hl 
4e19					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4e19 cd 96 21			call macro_forth_dsp_pop 
4e1c				endm 
# End of macro FORTH_DSP_POP
4e1c			;		pop hl 
4e1c						 
4e1c 11 81 fa				ld de, store_page      ; get block zero of file 
4e1f cd 2d 09				call storage_read 
4e22 cd f5 0e			call ishlzero 
4e25 20 04			jr nz, .opfound 
4e27			 
4e27				; file does not exist so indicate with 255 extents in use 
4e27			 
4e27 3e ff			ld a, 255 
4e29 18 29			jr .skipopeneof 
4e2b			 
4e2b			 
4e2b			.opfound: 
4e2b			 
4e2b			 
4e2b 3a 83 fa				ld a, (store_page+2)    ; max extents for this file 
4e2e 32 72 fa				ld  (store_openmaxext), a   ; get our limit and push 
4e31					 
4e31				if DEBUG_STORESE 
4e31					DMARK "OPx" 
4e31 f5				push af  
4e32 3a 46 4e			ld a, (.dmark)  
4e35 32 6e fe			ld (debug_mark),a  
4e38 3a 47 4e			ld a, (.dmark+1)  
4e3b 32 6f fe			ld (debug_mark+1),a  
4e3e 3a 48 4e			ld a, (.dmark+2)  
4e41 32 70 fe			ld (debug_mark+2),a  
4e44 18 03			jr .pastdmark  
4e46 ..			.dmark: db "OPx"  
4e49 f1			.pastdmark: pop af  
4e4a			endm  
# End of macro DMARK
4e4a					CALLMONITOR 
4e4a cd 73 18			call break_point_state  
4e4d				endm  
# End of macro CALLMONITOR
4e4d				endif 
4e4d fe 00				cp 0 
4e4f 20 03				jr nz, .skipopeneof 
4e51					; have opened an empty file 
4e51					 
4e51 32 73 fa				ld (store_openext), a 
4e54			 
4e54			.skipopeneof: 
4e54			 
4e54 6f					ld l, a 
4e55 26 00				ld h, 0 
4e57 cd e7 1e				call forth_push_numhl 
4e5a			 
4e5a			 
4e5a				       NEXTW 
4e5a c3 55 22			jp macro_next 
4e5d				endm 
# End of macro NEXTW
4e5d			.READ: 
4e5d				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4e5d 6c				db WORD_SYS_CORE+88             
4e5e a7 4f			dw .EOF            
4e60 05				db 4 + 1 
4e61 .. 00			db "READ",0              
4e66				endm 
# End of macro CWHEAD
4e66			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
4e66			; | | e.g. 
4e66			; | | $01 OPEN $01 DO $01 READ . LOOP 
4e66			; | | 
4e66			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
4e66			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
4e66			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
4e66			; | | two bytes contain the file id and extent. 
4e66			; | |  
4e66			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
4e66			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
4e66			 
4e66					if DEBUG_FORTH_WORDS_KEY 
4e66						DMARK "REA" 
4e66 f5				push af  
4e67 3a 7b 4e			ld a, (.dmark)  
4e6a 32 6e fe			ld (debug_mark),a  
4e6d 3a 7c 4e			ld a, (.dmark+1)  
4e70 32 6f fe			ld (debug_mark+1),a  
4e73 3a 7d 4e			ld a, (.dmark+2)  
4e76 32 70 fe			ld (debug_mark+2),a  
4e79 18 03			jr .pastdmark  
4e7b ..			.dmark: db "REA"  
4e7e f1			.pastdmark: pop af  
4e7f			endm  
# End of macro DMARK
4e7f						CALLMONITOR 
4e7f cd 73 18			call break_point_state  
4e82				endm  
# End of macro CALLMONITOR
4e82					endif 
4e82					; store_openext use it. If zero it is EOF 
4e82			 
4e82					; read block from current stream id 
4e82					; if the block does not contain zero term keep reading blocks until zero found 
4e82					; push the block to stack 
4e82					; save the block id to stream 
4e82			 
4e82 cd d8 0b				call storage_clear_page 
4e85			 
4e85					FORTH_DSP_VALUEHL 
4e85 cd de 20			call macro_dsp_valuehl 
4e88				endm 
# End of macro FORTH_DSP_VALUEHL
4e88			 
4e88			;		push hl 
4e88			 
4e88				if DEBUG_STORESE 
4e88					DMARK "REA" 
4e88 f5				push af  
4e89 3a 9d 4e			ld a, (.dmark)  
4e8c 32 6e fe			ld (debug_mark),a  
4e8f 3a 9e 4e			ld a, (.dmark+1)  
4e92 32 6f fe			ld (debug_mark+1),a  
4e95 3a 9f 4e			ld a, (.dmark+2)  
4e98 32 70 fe			ld (debug_mark+2),a  
4e9b 18 03			jr .pastdmark  
4e9d ..			.dmark: db "REA"  
4ea0 f1			.pastdmark: pop af  
4ea1			endm  
# End of macro DMARK
4ea1					CALLMONITOR 
4ea1 cd 73 18			call break_point_state  
4ea4				endm  
# End of macro CALLMONITOR
4ea4				endif 
4ea4					FORTH_DSP_POP 
4ea4 cd 96 21			call macro_forth_dsp_pop 
4ea7				endm 
# End of macro FORTH_DSP_POP
4ea7			 
4ea7			;		pop hl 
4ea7				 
4ea7 65					ld h,l 
4ea8			 
4ea8 3a 73 fa				ld a, (store_openext) 
4eab 6f					ld l, a 
4eac					 
4eac fe 00				cp 0 
4eae ca 79 4f				jp z, .ateof     ; dont read past eof 
4eb1			 
4eb1			 
4eb1 11 81 fa				ld de, store_page 
4eb4				if DEBUG_STORESE 
4eb4					DMARK "RE1" 
4eb4 f5				push af  
4eb5 3a c9 4e			ld a, (.dmark)  
4eb8 32 6e fe			ld (debug_mark),a  
4ebb 3a ca 4e			ld a, (.dmark+1)  
4ebe 32 6f fe			ld (debug_mark+1),a  
4ec1 3a cb 4e			ld a, (.dmark+2)  
4ec4 32 70 fe			ld (debug_mark+2),a  
4ec7 18 03			jr .pastdmark  
4ec9 ..			.dmark: db "RE1"  
4ecc f1			.pastdmark: pop af  
4ecd			endm  
# End of macro DMARK
4ecd					CALLMONITOR 
4ecd cd 73 18			call break_point_state  
4ed0				endm  
# End of macro CALLMONITOR
4ed0				endif 
4ed0 cd 2d 09				call storage_read 
4ed3			 
4ed3				if DEBUG_STORESE 
4ed3					DMARK "RE2" 
4ed3 f5				push af  
4ed4 3a e8 4e			ld a, (.dmark)  
4ed7 32 6e fe			ld (debug_mark),a  
4eda 3a e9 4e			ld a, (.dmark+1)  
4edd 32 6f fe			ld (debug_mark+1),a  
4ee0 3a ea 4e			ld a, (.dmark+2)  
4ee3 32 70 fe			ld (debug_mark+2),a  
4ee6 18 03			jr .pastdmark  
4ee8 ..			.dmark: db "RE2"  
4eeb f1			.pastdmark: pop af  
4eec			endm  
# End of macro DMARK
4eec					CALLMONITOR 
4eec cd 73 18			call break_point_state  
4eef				endm  
# End of macro CALLMONITOR
4eef				endif 
4eef cd f5 0e			call ishlzero 
4ef2			;	ld a, l 
4ef2			;	add h 
4ef2			;	cp 0 
4ef2 ca 7f 4f			jp z, .readeof 
4ef5			 
4ef5				; not eof so hl should point to data to push to stack 
4ef5			 
4ef5				if DEBUG_STORESE 
4ef5					DMARK "RE3" 
4ef5 f5				push af  
4ef6 3a 0a 4f			ld a, (.dmark)  
4ef9 32 6e fe			ld (debug_mark),a  
4efc 3a 0b 4f			ld a, (.dmark+1)  
4eff 32 6f fe			ld (debug_mark+1),a  
4f02 3a 0c 4f			ld a, (.dmark+2)  
4f05 32 70 fe			ld (debug_mark+2),a  
4f08 18 03			jr .pastdmark  
4f0a ..			.dmark: db "RE3"  
4f0d f1			.pastdmark: pop af  
4f0e			endm  
# End of macro DMARK
4f0e					CALLMONITOR 
4f0e cd 73 18			call break_point_state  
4f11				endm  
# End of macro CALLMONITOR
4f11				endif 
4f11 cd 55 1f			call forth_push_str 
4f14			 
4f14				if DEBUG_STORESE 
4f14					DMARK "RE4" 
4f14 f5				push af  
4f15 3a 29 4f			ld a, (.dmark)  
4f18 32 6e fe			ld (debug_mark),a  
4f1b 3a 2a 4f			ld a, (.dmark+1)  
4f1e 32 6f fe			ld (debug_mark+1),a  
4f21 3a 2b 4f			ld a, (.dmark+2)  
4f24 32 70 fe			ld (debug_mark+2),a  
4f27 18 03			jr .pastdmark  
4f29 ..			.dmark: db "RE4"  
4f2c f1			.pastdmark: pop af  
4f2d			endm  
# End of macro DMARK
4f2d					CALLMONITOR 
4f2d cd 73 18			call break_point_state  
4f30				endm  
# End of macro CALLMONITOR
4f30				endif 
4f30				; get next block  or mark as eof 
4f30			 
4f30 3a 72 fa			ld a, (store_openmaxext)   ; get our limit 
4f33 4f				ld c, a	 
4f34 3a 73 fa			ld a, (store_openext) 
4f37			 
4f37				if DEBUG_STORESE 
4f37					DMARK "RE5" 
4f37 f5				push af  
4f38 3a 4c 4f			ld a, (.dmark)  
4f3b 32 6e fe			ld (debug_mark),a  
4f3e 3a 4d 4f			ld a, (.dmark+1)  
4f41 32 6f fe			ld (debug_mark+1),a  
4f44 3a 4e 4f			ld a, (.dmark+2)  
4f47 32 70 fe			ld (debug_mark+2),a  
4f4a 18 03			jr .pastdmark  
4f4c ..			.dmark: db "RE5"  
4f4f f1			.pastdmark: pop af  
4f50			endm  
# End of macro DMARK
4f50					CALLMONITOR 
4f50 cd 73 18			call break_point_state  
4f53				endm  
# End of macro CALLMONITOR
4f53				endif 
4f53 b9				cp c 
4f54 28 29			jr z, .readeof     ; at last extent 
4f56			 
4f56 3c					inc a 
4f57 32 73 fa				ld (store_openext), a 
4f5a			 
4f5a				if DEBUG_STORESE 
4f5a					DMARK "RE6" 
4f5a f5				push af  
4f5b 3a 6f 4f			ld a, (.dmark)  
4f5e 32 6e fe			ld (debug_mark),a  
4f61 3a 70 4f			ld a, (.dmark+1)  
4f64 32 6f fe			ld (debug_mark+1),a  
4f67 3a 71 4f			ld a, (.dmark+2)  
4f6a 32 70 fe			ld (debug_mark+2),a  
4f6d 18 03			jr .pastdmark  
4f6f ..			.dmark: db "RE6"  
4f72 f1			.pastdmark: pop af  
4f73			endm  
# End of macro DMARK
4f73					CALLMONITOR 
4f73 cd 73 18			call break_point_state  
4f76				endm  
# End of macro CALLMONITOR
4f76				endif 
4f76			 
4f76			 
4f76				       NEXTW 
4f76 c3 55 22			jp macro_next 
4f79				endm 
# End of macro NEXTW
4f79			.ateof: 
4f79 21 a3 4f				ld hl, .showeof 
4f7c cd 55 1f				call forth_push_str 
4f7f 3e 00		.readeof:	ld a, 0 
4f81 32 73 fa				ld (store_openext), a 
4f84			 
4f84					 
4f84				if DEBUG_STORESE 
4f84					DMARK "REF" 
4f84 f5				push af  
4f85 3a 99 4f			ld a, (.dmark)  
4f88 32 6e fe			ld (debug_mark),a  
4f8b 3a 9a 4f			ld a, (.dmark+1)  
4f8e 32 6f fe			ld (debug_mark+1),a  
4f91 3a 9b 4f			ld a, (.dmark+2)  
4f94 32 70 fe			ld (debug_mark+2),a  
4f97 18 03			jr .pastdmark  
4f99 ..			.dmark: db "REF"  
4f9c f1			.pastdmark: pop af  
4f9d			endm  
# End of macro DMARK
4f9d					CALLMONITOR 
4f9d cd 73 18			call break_point_state  
4fa0				endm  
# End of macro CALLMONITOR
4fa0				endif 
4fa0				       NEXTW 
4fa0 c3 55 22			jp macro_next 
4fa3				endm 
# End of macro NEXTW
4fa3			 
4fa3 .. 00		.showeof:   db "eof", 0 
4fa7			 
4fa7			 
4fa7			.EOF: 
4fa7				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
4fa7 6d				db WORD_SYS_CORE+89             
4fa8 e8 4f			dw .FORMAT            
4faa 04				db 3 + 1 
4fab .. 00			db "EOF",0              
4faf				endm 
# End of macro CWHEAD
4faf			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
4faf			; | | e.g. 
4faf			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
4faf					; TODO if current block id for stream is zero then push true else false 
4faf			 
4faf					if DEBUG_FORTH_WORDS_KEY 
4faf						DMARK "EOF" 
4faf f5				push af  
4fb0 3a c4 4f			ld a, (.dmark)  
4fb3 32 6e fe			ld (debug_mark),a  
4fb6 3a c5 4f			ld a, (.dmark+1)  
4fb9 32 6f fe			ld (debug_mark+1),a  
4fbc 3a c6 4f			ld a, (.dmark+2)  
4fbf 32 70 fe			ld (debug_mark+2),a  
4fc2 18 03			jr .pastdmark  
4fc4 ..			.dmark: db "EOF"  
4fc7 f1			.pastdmark: pop af  
4fc8			endm  
# End of macro DMARK
4fc8						CALLMONITOR 
4fc8 cd 73 18			call break_point_state  
4fcb				endm  
# End of macro CALLMONITOR
4fcb					endif 
4fcb			 
4fcb					; TODO handlue multiple file streams 
4fcb			 
4fcb					FORTH_DSP_POP     ; for now just get rid of stream id 
4fcb cd 96 21			call macro_forth_dsp_pop 
4fce				endm 
# End of macro FORTH_DSP_POP
4fce			 
4fce 2e 01				ld l, 1 
4fd0 3a 72 fa				ld a, (store_openmaxext) 
4fd3 fe 00				cp 0 
4fd5 28 09				jr  z, .eofdone   ; empty file 
4fd7 3a 73 fa				ld a, (store_openext) 
4fda fe 00				cp 0 
4fdc 28 02				jr  z, .eofdone 
4fde 2e 00				ld l, 0 
4fe0 26 00		.eofdone:	ld h, 0 
4fe2 cd e7 1e				call forth_push_numhl 
4fe5			 
4fe5			 
4fe5				       NEXTW 
4fe5 c3 55 22			jp macro_next 
4fe8				endm 
# End of macro NEXTW
4fe8			 
4fe8			.FORMAT: 
4fe8				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
4fe8 6d				db WORD_SYS_CORE+89             
4fe9 39 50			dw .LABEL            
4feb 07				db 6 + 1 
4fec .. 00			db "FORMAT",0              
4ff3				endm 
# End of macro CWHEAD
4ff3			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
4ff3					; TODO if current block id for stream is zero then push true else false 
4ff3				 
4ff3				if DEBUG_STORESE 
4ff3					DMARK "FOR" 
4ff3 f5				push af  
4ff4 3a 08 50			ld a, (.dmark)  
4ff7 32 6e fe			ld (debug_mark),a  
4ffa 3a 09 50			ld a, (.dmark+1)  
4ffd 32 6f fe			ld (debug_mark+1),a  
5000 3a 0a 50			ld a, (.dmark+2)  
5003 32 70 fe			ld (debug_mark+2),a  
5006 18 03			jr .pastdmark  
5008 ..			.dmark: db "FOR"  
500b f1			.pastdmark: pop af  
500c			endm  
# End of macro DMARK
500c					CALLMONITOR 
500c cd 73 18			call break_point_state  
500f				endm  
# End of macro CALLMONITOR
500f				endif 
500f					; Wipes the bank check flags to cause a reformat on next block 0 read 
500f			 
500f 21 01 00				ld hl, 1 
5012 3e 00				ld a, 0 
5014 cd d9 01				call se_writebyte 
5017			 
5017				if DEBUG_STORESE 
5017					DMARK "FO0" 
5017 f5				push af  
5018 3a 2c 50			ld a, (.dmark)  
501b 32 6e fe			ld (debug_mark),a  
501e 3a 2d 50			ld a, (.dmark+1)  
5021 32 6f fe			ld (debug_mark+1),a  
5024 3a 2e 50			ld a, (.dmark+2)  
5027 32 70 fe			ld (debug_mark+2),a  
502a 18 03			jr .pastdmark  
502c ..			.dmark: db "FO0"  
502f f1			.pastdmark: pop af  
5030			endm  
# End of macro DMARK
5030					CALLMONITOR 
5030 cd 73 18			call break_point_state  
5033				endm  
# End of macro CALLMONITOR
5033				endif 
5033					; force bank init 
5033			 
5033 cd 85 04				call storage_get_block_0 
5036					 
5036				       NEXTW 
5036 c3 55 22			jp macro_next 
5039				endm 
# End of macro NEXTW
5039			.LABEL: 
5039				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5039 6d				db WORD_SYS_CORE+89             
503a 87 50			dw .STOREPAGE            
503c 06				db 5 + 1 
503d .. 00			db "LABEL",0              
5043				endm 
# End of macro CWHEAD
5043			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5043					; TODO test to see if bank is selected 
5043				 
5043					if DEBUG_FORTH_WORDS_KEY 
5043						DMARK "LBL" 
5043 f5				push af  
5044 3a 58 50			ld a, (.dmark)  
5047 32 6e fe			ld (debug_mark),a  
504a 3a 59 50			ld a, (.dmark+1)  
504d 32 6f fe			ld (debug_mark+1),a  
5050 3a 5a 50			ld a, (.dmark+2)  
5053 32 70 fe			ld (debug_mark+2),a  
5056 18 03			jr .pastdmark  
5058 ..			.dmark: db "LBL"  
505b f1			.pastdmark: pop af  
505c			endm  
# End of macro DMARK
505c						CALLMONITOR 
505c cd 73 18			call break_point_state  
505f				endm  
# End of macro CALLMONITOR
505f					endif 
505f			;	if DEBUG_STORESE 
505f			;		DMARK "LBL" 
505f			;		CALLMONITOR 
505f			;	endif 
505f					FORTH_DSP_VALUEHL 
505f cd de 20			call macro_dsp_valuehl 
5062				endm 
# End of macro FORTH_DSP_VALUEHL
5062					;v5FORTH_DSP_VALUE 
5062					 
5062			;		push hl 
5062					FORTH_DSP_POP 
5062 cd 96 21			call macro_forth_dsp_pop 
5065				endm 
# End of macro FORTH_DSP_POP
5065			;		pop hl 
5065			 
5065			;v5		inc hl   ; move past the type marker 
5065			 
5065				if DEBUG_STORESE 
5065					DMARK "LBl" 
5065 f5				push af  
5066 3a 7a 50			ld a, (.dmark)  
5069 32 6e fe			ld (debug_mark),a  
506c 3a 7b 50			ld a, (.dmark+1)  
506f 32 6f fe			ld (debug_mark+1),a  
5072 3a 7c 50			ld a, (.dmark+2)  
5075 32 70 fe			ld (debug_mark+2),a  
5078 18 03			jr .pastdmark  
507a ..			.dmark: db "LBl"  
507d f1			.pastdmark: pop af  
507e			endm  
# End of macro DMARK
507e					CALLMONITOR 
507e cd 73 18			call break_point_state  
5081				endm  
# End of macro CALLMONITOR
5081				endif 
5081 cd a9 05				call storage_label 
5084			 
5084				       NEXTW 
5084 c3 55 22			jp macro_next 
5087				endm 
# End of macro NEXTW
5087			.STOREPAGE: 
5087				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5087 6d				db WORD_SYS_CORE+89             
5088 ba 50			dw .LABELS            
508a 0a				db 9 + 1 
508b .. 00			db "STOREPAGE",0              
5095				endm 
# End of macro CWHEAD
5095			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5095					; TODO test to see if bank is selected 
5095				 
5095					if DEBUG_FORTH_WORDS_KEY 
5095						DMARK "STP" 
5095 f5				push af  
5096 3a aa 50			ld a, (.dmark)  
5099 32 6e fe			ld (debug_mark),a  
509c 3a ab 50			ld a, (.dmark+1)  
509f 32 6f fe			ld (debug_mark+1),a  
50a2 3a ac 50			ld a, (.dmark+2)  
50a5 32 70 fe			ld (debug_mark+2),a  
50a8 18 03			jr .pastdmark  
50aa ..			.dmark: db "STP"  
50ad f1			.pastdmark: pop af  
50ae			endm  
# End of macro DMARK
50ae						CALLMONITOR 
50ae cd 73 18			call break_point_state  
50b1				endm  
# End of macro CALLMONITOR
50b1					endif 
50b1			;	if DEBUG_STORESE 
50b1			;		DMARK "STP" 
50b1			;		CALLMONITOR 
50b1			;	endif 
50b1			 
50b1 21 81 fa			ld hl, store_page 
50b4 cd e7 1e			call forth_push_numhl 
50b7			 
50b7			 
50b7				       NEXTW 
50b7 c3 55 22			jp macro_next 
50ba				endm 
# End of macro NEXTW
50ba			.LABELS: 
50ba				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
50ba 6d				db WORD_SYS_CORE+89             
50bb 44 51			dw .SCONST1            
50bd 07				db 6 + 1 
50be .. 00			db "LABELS",0              
50c5				endm 
# End of macro CWHEAD
50c5			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
50c5					;  
50c5			 
50c5					; save the current device selected to restore afterwards 
50c5				 
50c5 3a 6a fa				ld a, (spi_device) 
50c8 f5					push af 
50c9			 
50c9			 
50c9					; run through each of the banks 
50c9			 
50c9 21 01 00				ld hl, 1 
50cc cd e7 1e				call forth_push_numhl 
50cf 3e ff				ld a, SPI_CE_HIGH 
50d1 cb 87				res SPI_CE0, a 
50d3 32 6a fa				ld (spi_device), a 
50d6 cd 85 04				call storage_get_block_0 
50d9 21 84 fa				ld hl, store_page+3 
50dc cd 55 1f				call forth_push_str 
50df			 
50df					 
50df 21 02 00				ld hl, 2 
50e2 cd e7 1e				call forth_push_numhl 
50e5 3e ff				ld a, SPI_CE_HIGH 
50e7 cb 8f				res SPI_CE1, a 
50e9 32 6a fa				ld (spi_device), a 
50ec cd 85 04				call storage_get_block_0 
50ef 21 84 fa				ld hl, store_page+3 
50f2 cd 55 1f				call forth_push_str 
50f5			 
50f5					 
50f5 21 03 00				ld hl, 3 
50f8 cd e7 1e				call forth_push_numhl 
50fb 3e ff				ld a, SPI_CE_HIGH 
50fd cb 97				res SPI_CE2, a 
50ff 32 6a fa				ld (spi_device), a 
5102 cd 85 04				call storage_get_block_0 
5105 21 84 fa				ld hl, store_page+3 
5108 cd 55 1f				call forth_push_str 
510b			 
510b			 
510b 21 04 00				ld hl, 4 
510e cd e7 1e				call forth_push_numhl 
5111 3e ff				ld a, SPI_CE_HIGH 
5113 cb 9f				res SPI_CE3, a 
5115 32 6a fa				ld (spi_device), a 
5118 cd 85 04				call storage_get_block_0 
511b 21 84 fa				ld hl, store_page+3 
511e cd 55 1f				call forth_push_str 
5121			 
5121					 
5121			 
5121 21 05 00				ld hl, 5 
5124 cd e7 1e				call forth_push_numhl 
5127 3e ff				ld a, SPI_CE_HIGH 
5129 cb a7				res SPI_CE4, a 
512b 32 6a fa				ld (spi_device), a 
512e cd 85 04				call storage_get_block_0 
5131 21 84 fa				ld hl, store_page+3 
5134 cd 55 1f				call forth_push_str 
5137			 
5137					 
5137					; push fixed count of storage devices (on board) for now 
5137			 
5137 21 05 00				ld hl, 5 
513a cd e7 1e				call forth_push_numhl 
513d			 
513d					; restore selected device  
513d				 
513d f1					pop af 
513e 32 6a fa				ld (spi_device), a 
5141			 
5141				       NEXTW 
5141 c3 55 22			jp macro_next 
5144				endm 
# End of macro NEXTW
5144			 
5144			.SCONST1: 
5144				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5144 6d				db WORD_SYS_CORE+89             
5145 58 51			dw .SCONST2            
5147 07				db 6 + 1 
5148 .. 00			db "FILEID",0              
514f				endm 
# End of macro CWHEAD
514f			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
514f 2a 70 fa				ld hl, (store_filecache) 
5152 cd e7 1e				call forth_push_numhl 
5155					NEXTW 
5155 c3 55 22			jp macro_next 
5158				endm 
# End of macro NEXTW
5158			.SCONST2: 
5158				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5158 6d				db WORD_SYS_CORE+89             
5159 70 51			dw .SCONST3            
515b 08				db 7 + 1 
515c .. 00			db "FILEEXT",0              
5164				endm 
# End of macro CWHEAD
5164			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5164 3a 73 fa				ld a, (store_openext) 
5167 26 00				ld h, 0 
5169 7d					ld a, l 
516a cd e7 1e				call forth_push_numhl 
516d					NEXTW 
516d c3 55 22			jp macro_next 
5170				endm 
# End of macro NEXTW
5170			.SCONST3: 
5170				CWHEAD .ENDSTORAGE 89 "FILEMAX" 7 WORD_FLAG_CODE 
5170 6d				db WORD_SYS_CORE+89             
5171 88 51			dw .ENDSTORAGE            
5173 08				db 7 + 1 
5174 .. 00			db "FILEMAX",0              
517c				endm 
# End of macro CWHEAD
517c			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
517c 3a 72 fa				ld a, (store_openmaxext) 
517f 26 00				ld h, 0 
5181 7d					ld a, l 
5182 cd e7 1e				call forth_push_numhl 
5185					NEXTW 
5185 c3 55 22			jp macro_next 
5188				endm 
# End of macro NEXTW
5188			.ENDSTORAGE: 
5188			; eof 
# End of file forth_words_storage.asm
5188			endif 
5188				include "forth_words_device.asm" 
5188			; Device related words 
5188			 
5188			; | ## Device Words 
5188			 
5188			if SOUND_ENABLE 
5188			.NOTE: 
5188				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
5188 33				db WORD_SYS_CORE+31             
5189 b0 51			dw .AFTERSOUND            
518b 05				db 4 + 1 
518c .. 00			db "NOTE",0              
5191				endm 
# End of macro CWHEAD
5191			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
5191					if DEBUG_FORTH_WORDS_KEY 
5191						DMARK "NTE" 
5191 f5				push af  
5192 3a a6 51			ld a, (.dmark)  
5195 32 6e fe			ld (debug_mark),a  
5198 3a a7 51			ld a, (.dmark+1)  
519b 32 6f fe			ld (debug_mark+1),a  
519e 3a a8 51			ld a, (.dmark+2)  
51a1 32 70 fe			ld (debug_mark+2),a  
51a4 18 03			jr .pastdmark  
51a6 ..			.dmark: db "NTE"  
51a9 f1			.pastdmark: pop af  
51aa			endm  
# End of macro DMARK
51aa						CALLMONITOR 
51aa cd 73 18			call break_point_state  
51ad				endm  
# End of macro CALLMONITOR
51ad					endif 
51ad			 
51ad				 
51ad			 
51ad					NEXTW 
51ad c3 55 22			jp macro_next 
51b0				endm 
# End of macro NEXTW
51b0			.AFTERSOUND: 
51b0			endif 
51b0			 
51b0			 
51b0			USE_GPIO: equ 0 
51b0			 
51b0			if USE_GPIO 
51b0			.GP1: 
51b0				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
51b0			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
51b0					NEXTW 
51b0			.GP2: 
51b0				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
51b0			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
51b0			 
51b0					NEXTW 
51b0			 
51b0			.GP3: 
51b0				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
51b0			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
51b0			 
51b0					NEXTW 
51b0			 
51b0			.GP4: 
51b0				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
51b0			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
51b0			 
51b0					NEXTW 
51b0			.SIN: 
51b0			 
51b0			 
51b0			endif 
51b0			 
51b0			 
51b0				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
51b0 33				db WORD_SYS_CORE+31             
51b1 e5 51			dw .SOUT            
51b3 03				db 2 + 1 
51b4 .. 00			db "IN",0              
51b7				endm 
# End of macro CWHEAD
51b7			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
51b7					if DEBUG_FORTH_WORDS_KEY 
51b7						DMARK "IN." 
51b7 f5				push af  
51b8 3a cc 51			ld a, (.dmark)  
51bb 32 6e fe			ld (debug_mark),a  
51be 3a cd 51			ld a, (.dmark+1)  
51c1 32 6f fe			ld (debug_mark+1),a  
51c4 3a ce 51			ld a, (.dmark+2)  
51c7 32 70 fe			ld (debug_mark+2),a  
51ca 18 03			jr .pastdmark  
51cc ..			.dmark: db "IN."  
51cf f1			.pastdmark: pop af  
51d0			endm  
# End of macro DMARK
51d0						CALLMONITOR 
51d0 cd 73 18			call break_point_state  
51d3				endm  
# End of macro CALLMONITOR
51d3					endif 
51d3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
51d3 cd de 20			call macro_dsp_valuehl 
51d6				endm 
# End of macro FORTH_DSP_VALUEHL
51d6			 
51d6 e5					push hl 
51d7			 
51d7					; destroy value TOS 
51d7			 
51d7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
51d7 cd 96 21			call macro_forth_dsp_pop 
51da				endm 
# End of macro FORTH_DSP_POP
51da			 
51da					; one value on hl get other one back 
51da			 
51da c1					pop bc 
51db			 
51db					; do the sub 
51db			;		ex de, hl 
51db			 
51db ed 68				in l,(c) 
51dd			 
51dd					; save it 
51dd			 
51dd 26 00				ld h,0 
51df			 
51df					; TODO push value back onto stack for another op etc 
51df			 
51df cd e7 1e				call forth_push_numhl 
51e2					NEXTW 
51e2 c3 55 22			jp macro_next 
51e5				endm 
# End of macro NEXTW
51e5			.SOUT: 
51e5				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
51e5 34				db WORD_SYS_CORE+32             
51e6 38 52			dw .SPIO            
51e8 04				db 3 + 1 
51e9 .. 00			db "OUT",0              
51ed				endm 
# End of macro CWHEAD
51ed			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
51ed					if DEBUG_FORTH_WORDS_KEY 
51ed						DMARK "OUT" 
51ed f5				push af  
51ee 3a 02 52			ld a, (.dmark)  
51f1 32 6e fe			ld (debug_mark),a  
51f4 3a 03 52			ld a, (.dmark+1)  
51f7 32 6f fe			ld (debug_mark+1),a  
51fa 3a 04 52			ld a, (.dmark+2)  
51fd 32 70 fe			ld (debug_mark+2),a  
5200 18 03			jr .pastdmark  
5202 ..			.dmark: db "OUT"  
5205 f1			.pastdmark: pop af  
5206			endm  
# End of macro DMARK
5206						CALLMONITOR 
5206 cd 73 18			call break_point_state  
5209				endm  
# End of macro CALLMONITOR
5209					endif 
5209			 
5209					; get port 
5209			 
5209					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5209 cd de 20			call macro_dsp_valuehl 
520c				endm 
# End of macro FORTH_DSP_VALUEHL
520c			 
520c e5					push hl 
520d			 
520d					; destroy value TOS 
520d			 
520d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
520d cd 96 21			call macro_forth_dsp_pop 
5210				endm 
# End of macro FORTH_DSP_POP
5210			 
5210					; get byte to send 
5210			 
5210					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5210 cd de 20			call macro_dsp_valuehl 
5213				endm 
# End of macro FORTH_DSP_VALUEHL
5213			 
5213			;		push hl 
5213			 
5213					; destroy value TOS 
5213			 
5213					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5213 cd 96 21			call macro_forth_dsp_pop 
5216				endm 
# End of macro FORTH_DSP_POP
5216			 
5216					; one value on hl get other one back 
5216			 
5216			;		pop hl 
5216			 
5216 c1					pop bc 
5217			 
5217					if DEBUG_FORTH_WORDS 
5217						DMARK "OUT" 
5217 f5				push af  
5218 3a 2c 52			ld a, (.dmark)  
521b 32 6e fe			ld (debug_mark),a  
521e 3a 2d 52			ld a, (.dmark+1)  
5221 32 6f fe			ld (debug_mark+1),a  
5224 3a 2e 52			ld a, (.dmark+2)  
5227 32 70 fe			ld (debug_mark+2),a  
522a 18 03			jr .pastdmark  
522c ..			.dmark: db "OUT"  
522f f1			.pastdmark: pop af  
5230			endm  
# End of macro DMARK
5230						CALLMONITOR 
5230 cd 73 18			call break_point_state  
5233				endm  
# End of macro CALLMONITOR
5233					endif 
5233			 
5233 ed 69				out (c), l 
5235			 
5235					NEXTW 
5235 c3 55 22			jp macro_next 
5238				endm 
# End of macro NEXTW
5238			 
5238			 
5238			.SPIO: 
5238			 
5238			if STORAGE_SE 
5238				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5238 51				db WORD_SYS_CORE+61             
5239 49 52			dw .SPICEH            
523b 07				db 6 + 1 
523c .. 00			db "SPICEL",0              
5243				endm 
# End of macro CWHEAD
5243			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5243			 
5243 cd 87 01				call spi_ce_low 
5246			    NEXTW 
5246 c3 55 22			jp macro_next 
5249				endm 
# End of macro NEXTW
5249			 
5249			.SPICEH: 
5249				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5249 51				db WORD_SYS_CORE+61             
524a 5a 52			dw .SPIOb            
524c 07				db 6 + 1 
524d .. 00			db "SPICEH",0              
5254				endm 
# End of macro CWHEAD
5254			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
5254			 
5254 cd 76 01				call spi_ce_high 
5257			    NEXTW 
5257 c3 55 22			jp macro_next 
525a				endm 
# End of macro NEXTW
525a			 
525a			 
525a			.SPIOb: 
525a			 
525a				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
525a 51				db WORD_SYS_CORE+61             
525b 70 52			dw .SPII            
525d 05				db 4 + 1 
525e .. 00			db "SPIO",0              
5263				endm 
# End of macro CWHEAD
5263			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
5263			 
5263					; get port 
5263			 
5263			 
5263					; get byte to send 
5263			 
5263					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5263 cd de 20			call macro_dsp_valuehl 
5266				endm 
# End of macro FORTH_DSP_VALUEHL
5266			 
5266			;		push hl    ; u1  
5266			 
5266					; destroy value TOS 
5266			 
5266					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5266 cd 96 21			call macro_forth_dsp_pop 
5269				endm 
# End of macro FORTH_DSP_POP
5269			 
5269					; one value on hl get other one back 
5269			 
5269			;		pop hl   ; u2 - addr 
5269			 
5269					; TODO Send SPI byte 
5269			 
5269 7d					ld a, l 
526a cd ab 00				call spi_send_byte 
526d			 
526d					NEXTW 
526d c3 55 22			jp macro_next 
5270				endm 
# End of macro NEXTW
5270			 
5270			.SPII: 
5270				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5270 52				db WORD_SYS_CORE+62             
5271 85 52			dw .SESEL            
5273 06				db 5 + 1 
5274 .. 00			db "SPII",0              
5279				endm 
# End of macro CWHEAD
5279			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5279			 
5279					; TODO Get SPI byte 
5279			 
5279 cd cc 00				call spi_read_byte 
527c			 
527c 26 00				ld h, 0 
527e 6f					ld l, a 
527f cd e7 1e				call forth_push_numhl 
5282			 
5282					NEXTW 
5282 c3 55 22			jp macro_next 
5285				endm 
# End of macro NEXTW
5285			 
5285			 
5285			 
5285			.SESEL: 
5285				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5285 66				db WORD_SYS_CORE+82             
5286 29 53			dw .CARTDEV            
5288 05				db 4 + 1 
5289 .. 00			db "BANK",0              
528e				endm 
# End of macro CWHEAD
528e			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
528e					if DEBUG_FORTH_WORDS_KEY 
528e						DMARK "BNK" 
528e f5				push af  
528f 3a a3 52			ld a, (.dmark)  
5292 32 6e fe			ld (debug_mark),a  
5295 3a a4 52			ld a, (.dmark+1)  
5298 32 6f fe			ld (debug_mark+1),a  
529b 3a a5 52			ld a, (.dmark+2)  
529e 32 70 fe			ld (debug_mark+2),a  
52a1 18 03			jr .pastdmark  
52a3 ..			.dmark: db "BNK"  
52a6 f1			.pastdmark: pop af  
52a7			endm  
# End of macro DMARK
52a7						CALLMONITOR 
52a7 cd 73 18			call break_point_state  
52aa				endm  
# End of macro CALLMONITOR
52aa					endif 
52aa			 
52aa 3e ff				ld a, 255 
52ac 32 6d fa				ld (spi_cartdev), a 
52af			 
52af					; get bank 
52af			 
52af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52af cd de 20			call macro_dsp_valuehl 
52b2				endm 
# End of macro FORTH_DSP_VALUEHL
52b2			 
52b2			;		push hl 
52b2			 
52b2					; destroy value TOS 
52b2			 
52b2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52b2 cd 96 21			call macro_forth_dsp_pop 
52b5				endm 
# End of macro FORTH_DSP_POP
52b5			 
52b5					; one value on hl get other one back 
52b5			 
52b5			;		pop hl 
52b5			 
52b5			 
52b5 0e ff				ld c, SPI_CE_HIGH 
52b7 06 30				ld b, '0'    ; human readable bank number 
52b9			 
52b9 7d					ld a, l 
52ba			 
52ba					if DEBUG_FORTH_WORDS 
52ba						DMARK "BNK" 
52ba f5				push af  
52bb 3a cf 52			ld a, (.dmark)  
52be 32 6e fe			ld (debug_mark),a  
52c1 3a d0 52			ld a, (.dmark+1)  
52c4 32 6f fe			ld (debug_mark+1),a  
52c7 3a d1 52			ld a, (.dmark+2)  
52ca 32 70 fe			ld (debug_mark+2),a  
52cd 18 03			jr .pastdmark  
52cf ..			.dmark: db "BNK"  
52d2 f1			.pastdmark: pop af  
52d3			endm  
# End of macro DMARK
52d3						CALLMONITOR 
52d3 cd 73 18			call break_point_state  
52d6				endm  
# End of macro CALLMONITOR
52d6					endif 
52d6			 
52d6					; active low 
52d6			 
52d6 fe 00				cp 0 
52d8 28 28				jr z, .bset 
52da fe 01				cp 1 
52dc 20 04				jr nz, .b2 
52de cb 81				res 0, c 
52e0 06 31				ld b, '1'    ; human readable bank number 
52e2 fe 02		.b2:		cp 2 
52e4 20 04				jr nz, .b3 
52e6 cb 89				res 1, c 
52e8 06 32				ld b, '2'    ; human readable bank number 
52ea fe 03		.b3:		cp 3 
52ec 20 04				jr nz, .b4 
52ee cb 91				res 2, c 
52f0 06 33				ld b, '3'    ; human readable bank number 
52f2 fe 04		.b4:		cp 4 
52f4 20 04				jr nz, .b5 
52f6 cb 99				res 3, c 
52f8 06 34				ld b, '4'    ; human readable bank number 
52fa fe 05		.b5:		cp 5 
52fc 20 04				jr nz, .bset 
52fe cb a1				res 4, c 
5300 06 35				ld b, '5'    ; human readable bank number 
5302			 
5302			.bset: 
5302 79					ld a, c 
5303 32 6a fa				ld (spi_device),a 
5306 78					ld a, b 
5307 32 69 fa				ld (spi_device_id),a 
530a					if DEBUG_FORTH_WORDS 
530a						DMARK "BN2" 
530a f5				push af  
530b 3a 1f 53			ld a, (.dmark)  
530e 32 6e fe			ld (debug_mark),a  
5311 3a 20 53			ld a, (.dmark+1)  
5314 32 6f fe			ld (debug_mark+1),a  
5317 3a 21 53			ld a, (.dmark+2)  
531a 32 70 fe			ld (debug_mark+2),a  
531d 18 03			jr .pastdmark  
531f ..			.dmark: db "BN2"  
5322 f1			.pastdmark: pop af  
5323			endm  
# End of macro DMARK
5323						CALLMONITOR 
5323 cd 73 18			call break_point_state  
5326				endm  
# End of macro CALLMONITOR
5326					endif 
5326			 
5326					NEXTW 
5326 c3 55 22			jp macro_next 
5329				endm 
# End of macro NEXTW
5329			 
5329			.CARTDEV: 
5329				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5329 66				db WORD_SYS_CORE+82             
532a d2 53			dw .ENDDEVICE            
532c 08				db 7 + 1 
532d .. 00			db "CARTDEV",0              
5335				endm 
# End of macro CWHEAD
5335			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5335					if DEBUG_FORTH_WORDS_KEY 
5335						DMARK "CDV" 
5335 f5				push af  
5336 3a 4a 53			ld a, (.dmark)  
5339 32 6e fe			ld (debug_mark),a  
533c 3a 4b 53			ld a, (.dmark+1)  
533f 32 6f fe			ld (debug_mark+1),a  
5342 3a 4c 53			ld a, (.dmark+2)  
5345 32 70 fe			ld (debug_mark+2),a  
5348 18 03			jr .pastdmark  
534a ..			.dmark: db "CDV"  
534d f1			.pastdmark: pop af  
534e			endm  
# End of macro DMARK
534e						CALLMONITOR 
534e cd 73 18			call break_point_state  
5351				endm  
# End of macro CALLMONITOR
5351					endif 
5351			 
5351					; disable se storage bank selection 
5351			 
5351 3e ff				ld a, SPI_CE_HIGH		; ce high 
5353 32 6a fa				ld (spi_device), a 
5356			 
5356					; get bank 
5356			 
5356					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5356 cd de 20			call macro_dsp_valuehl 
5359				endm 
# End of macro FORTH_DSP_VALUEHL
5359			 
5359			;		push hl 
5359			 
5359					; destroy value TOS 
5359			 
5359					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5359 cd 96 21			call macro_forth_dsp_pop 
535c				endm 
# End of macro FORTH_DSP_POP
535c			 
535c					; one value on hl get other one back 
535c			 
535c			;		pop hl 
535c			 
535c					; active low 
535c			 
535c 0e ff				ld c, 255 
535e			 
535e 7d					ld a, l 
535f					if DEBUG_FORTH_WORDS 
535f						DMARK "CDV" 
535f f5				push af  
5360 3a 74 53			ld a, (.dmark)  
5363 32 6e fe			ld (debug_mark),a  
5366 3a 75 53			ld a, (.dmark+1)  
5369 32 6f fe			ld (debug_mark+1),a  
536c 3a 76 53			ld a, (.dmark+2)  
536f 32 70 fe			ld (debug_mark+2),a  
5372 18 03			jr .pastdmark  
5374 ..			.dmark: db "CDV"  
5377 f1			.pastdmark: pop af  
5378			endm  
# End of macro DMARK
5378						CALLMONITOR 
5378 cd 73 18			call break_point_state  
537b				endm  
# End of macro CALLMONITOR
537b					endif 
537b fe 00				cp 0 
537d 28 30				jr z, .cset 
537f fe 01				cp 1 
5381 20 02				jr nz, .c2 
5383 cb 81				res 0, c 
5385 fe 02		.c2:		cp 2 
5387 20 02				jr nz, .c3 
5389 cb 89				res 1, c 
538b fe 03		.c3:		cp 3 
538d 20 02				jr nz, .c4 
538f cb 91				res 2, c 
5391 fe 04		.c4:		cp 4 
5393 20 02				jr nz, .c5 
5395 cb 99				res 3, c 
5397 fe 05		.c5:		cp 5 
5399 20 02				jr nz, .c6 
539b cb a1				res 4, c 
539d fe 06		.c6:		cp 6 
539f 20 02				jr nz, .c7 
53a1 cb a9				res 5, c 
53a3 fe 07		.c7:		cp 7 
53a5 20 02				jr nz, .c8 
53a7 cb b1				res 6, c 
53a9 fe 08		.c8:		cp 8 
53ab 20 02				jr nz, .cset 
53ad cb b9				res 7, c 
53af 79			.cset:		ld a, c 
53b0 32 6d fa				ld (spi_cartdev),a 
53b3			 
53b3					if DEBUG_FORTH_WORDS 
53b3						DMARK "CD2" 
53b3 f5				push af  
53b4 3a c8 53			ld a, (.dmark)  
53b7 32 6e fe			ld (debug_mark),a  
53ba 3a c9 53			ld a, (.dmark+1)  
53bd 32 6f fe			ld (debug_mark+1),a  
53c0 3a ca 53			ld a, (.dmark+2)  
53c3 32 70 fe			ld (debug_mark+2),a  
53c6 18 03			jr .pastdmark  
53c8 ..			.dmark: db "CD2"  
53cb f1			.pastdmark: pop af  
53cc			endm  
# End of macro DMARK
53cc						CALLMONITOR 
53cc cd 73 18			call break_point_state  
53cf				endm  
# End of macro CALLMONITOR
53cf					endif 
53cf					NEXTW 
53cf c3 55 22			jp macro_next 
53d2				endm 
# End of macro NEXTW
53d2			endif 
53d2			 
53d2			.ENDDEVICE: 
53d2			; eof 
53d2			 
# End of file forth_words_device.asm
53d2			 
53d2			; var handler 
53d2			 
53d2			 
53d2			.VARS: 
53d2				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
53d2 78				db WORD_SYS_CORE+100             
53d3 ea 53			dw .V0Q            
53d5 04				db 3 + 1 
53d6 .. 00			db "V0!",0              
53da				endm 
# End of macro CWHEAD
53da			;| V0! ( u1 -- )  Store value to v0  | DONE 
53da			 
53da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
53da cd de 20			call macro_dsp_valuehl 
53dd				endm 
# End of macro FORTH_DSP_VALUEHL
53dd			 
53dd 11 32 fa				ld de, cli_var_array 
53e0			 
53e0 eb					ex de, hl 
53e1 73					ld (hl), e 
53e2 23					inc hl 
53e3 72					ld (hl), d 
53e4			 
53e4					; destroy value TOS 
53e4			 
53e4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
53e4 cd 96 21			call macro_forth_dsp_pop 
53e7				endm 
# End of macro FORTH_DSP_POP
53e7			 
53e7				       NEXTW 
53e7 c3 55 22			jp macro_next 
53ea				endm 
# End of macro NEXTW
53ea			.V0Q: 
53ea				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
53ea 79				db WORD_SYS_CORE+101             
53eb fb 53			dw .V1S            
53ed 04				db 3 + 1 
53ee .. 00			db "V0@",0              
53f2				endm 
# End of macro CWHEAD
53f2			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
53f2 2a 32 fa				ld hl, (cli_var_array) 
53f5 cd e7 1e				call forth_push_numhl 
53f8			 
53f8				       NEXTW 
53f8 c3 55 22			jp macro_next 
53fb				endm 
# End of macro NEXTW
53fb			.V1S: 
53fb				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
53fb 7a				db WORD_SYS_CORE+102             
53fc 13 54			dw .V1Q            
53fe 04				db 3 + 1 
53ff .. 00			db "V1!",0              
5403				endm 
# End of macro CWHEAD
5403			;| V1! ( u1 -- )  Store value to v1 | DONE 
5403					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5403 cd de 20			call macro_dsp_valuehl 
5406				endm 
# End of macro FORTH_DSP_VALUEHL
5406			 
5406 11 34 fa				ld de, cli_var_array+2 
5409				 
5409 eb					ex de, hl 
540a 73					ld (hl), e 
540b 23					inc hl 
540c 72					ld (hl), d 
540d			 
540d					; destroy value TOS 
540d			 
540d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
540d cd 96 21			call macro_forth_dsp_pop 
5410				endm 
# End of macro FORTH_DSP_POP
5410				       NEXTW 
5410 c3 55 22			jp macro_next 
5413				endm 
# End of macro NEXTW
5413			.V1Q: 
5413				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5413 7b				db WORD_SYS_CORE+103             
5414 24 54			dw .V2S            
5416 04				db 3 + 1 
5417 .. 00			db "V1@",0              
541b				endm 
# End of macro CWHEAD
541b			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
541b 2a 34 fa				ld hl, (cli_var_array+2) 
541e cd e7 1e				call forth_push_numhl 
5421				       NEXTW 
5421 c3 55 22			jp macro_next 
5424				endm 
# End of macro NEXTW
5424			.V2S: 
5424				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5424 7c				db WORD_SYS_CORE+104             
5425 3c 54			dw .V2Q            
5427 04				db 3 + 1 
5428 .. 00			db "V2!",0              
542c				endm 
# End of macro CWHEAD
542c			;| V2! ( u1 -- )  Store value to v2 | DONE 
542c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
542c cd de 20			call macro_dsp_valuehl 
542f				endm 
# End of macro FORTH_DSP_VALUEHL
542f			 
542f 11 36 fa				ld de, cli_var_array+4 
5432				 
5432 eb					ex de, hl 
5433 73					ld (hl), e 
5434 23					inc hl 
5435 72					ld (hl), d 
5436			 
5436					; destroy value TOS 
5436			 
5436					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5436 cd 96 21			call macro_forth_dsp_pop 
5439				endm 
# End of macro FORTH_DSP_POP
5439				       NEXTW 
5439 c3 55 22			jp macro_next 
543c				endm 
# End of macro NEXTW
543c			.V2Q: 
543c				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
543c 7d				db WORD_SYS_CORE+105             
543d 4d 54			dw .V3S            
543f 04				db 3 + 1 
5440 .. 00			db "V2@",0              
5444				endm 
# End of macro CWHEAD
5444			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5444 2a 36 fa				ld hl, (cli_var_array+4) 
5447 cd e7 1e				call forth_push_numhl 
544a				       NEXTW 
544a c3 55 22			jp macro_next 
544d				endm 
# End of macro NEXTW
544d			.V3S: 
544d				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
544d 7c				db WORD_SYS_CORE+104             
544e 65 54			dw .V3Q            
5450 04				db 3 + 1 
5451 .. 00			db "V3!",0              
5455				endm 
# End of macro CWHEAD
5455			;| V3! ( u1 -- )  Store value to v3 | DONE 
5455					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5455 cd de 20			call macro_dsp_valuehl 
5458				endm 
# End of macro FORTH_DSP_VALUEHL
5458			 
5458 11 38 fa				ld de, cli_var_array+6 
545b				 
545b eb					ex de, hl 
545c 73					ld (hl), e 
545d 23					inc hl 
545e 72					ld (hl), d 
545f			 
545f					; destroy value TOS 
545f			 
545f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
545f cd 96 21			call macro_forth_dsp_pop 
5462				endm 
# End of macro FORTH_DSP_POP
5462				       NEXTW 
5462 c3 55 22			jp macro_next 
5465				endm 
# End of macro NEXTW
5465			.V3Q: 
5465				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5465 7d				db WORD_SYS_CORE+105             
5466 76 54			dw .END            
5468 04				db 3 + 1 
5469 .. 00			db "V3@",0              
546d				endm 
# End of macro CWHEAD
546d			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
546d 2a 38 fa				ld hl, (cli_var_array+6) 
5470 cd e7 1e				call forth_push_numhl 
5473				       NEXTW 
5473 c3 55 22			jp macro_next 
5476				endm 
# End of macro NEXTW
5476			 
5476			 
5476			 
5476			 
5476			 
5476			; end of dict marker 
5476			 
5476 00			.END:    db WORD_SYS_END 
5477 00 00			dw 0 
5479 00				db 0 
547a			 
547a			; use to jp here for user dict words to save on macro expansion  
547a			 
547a			user_dict_next: 
547a				NEXTW 
547a c3 55 22			jp macro_next 
547d				endm 
# End of macro NEXTW
547d			 
547d			 
547d			user_exec: 
547d				;    ld hl, <word code> 
547d				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
547d				;    call forthexec 
547d				;    jp user_dict_next   (NEXT) 
547d			        ;    <word code bytes> 
547d eb				ex de, hl 
547e 2a 00 f5			ld hl,(os_tok_ptr) 
5481				 
5481				FORTH_RSP_NEXT 
5481 cd 8e 1e			call macro_forth_rsp_next 
5484				endm 
# End of macro FORTH_RSP_NEXT
5484			 
5484			if DEBUG_FORTH_UWORD 
5484						DMARK "UEX" 
5484 f5				push af  
5485 3a 99 54			ld a, (.dmark)  
5488 32 6e fe			ld (debug_mark),a  
548b 3a 9a 54			ld a, (.dmark+1)  
548e 32 6f fe			ld (debug_mark+1),a  
5491 3a 9b 54			ld a, (.dmark+2)  
5494 32 70 fe			ld (debug_mark+2),a  
5497 18 03			jr .pastdmark  
5499 ..			.dmark: db "UEX"  
549c f1			.pastdmark: pop af  
549d			endm  
# End of macro DMARK
549d				CALLMONITOR 
549d cd 73 18			call break_point_state  
54a0				endm  
# End of macro CALLMONITOR
54a0			endif 
54a0			 
54a0			 
54a0			 
54a0 eb				ex de, hl 
54a1 22 00 f5			ld (os_tok_ptr), hl 
54a4				 
54a4				; Don't use next - Skips the first word in uword. 
54a4			 
54a4 c3 e6 22			jp exec1 
54a7			;	NEXT 
54a7			 
54a7			 
54a7			; eof 
# End of file forth_wordsv4.asm
54a7			endif 
54a7			;;;;;;;;;;;;;; Debug code 
54a7			 
54a7			 
54a7			;if DEBUG_FORTH_PARSE 
54a7 .. 00		.nowordfound: db "No match",0 
54b0 .. 00		.compword:	db "Comparing word ",0 
54c0 .. 00		.nextwordat:	db "Next word at",0 
54cd .. 00		.charmatch:	db "Char match",0 
54d8			;endif 
54d8			if DEBUG_FORTH_JP 
54d8			.foundword:	db "Word match. Exec..",0 
54d8			endif 
54d8			;if DEBUG_FORTH_PUSH 
54d8 .. 00		.enddict:	db "Dict end. Push.",0 
54e8 .. 00		.push_str:	db "Pushing string",0 
54f7 .. 00		.push_num:	db "Pushing number",0 
5506 .. 00		.data_sp:	db "SP:",0 
550a .. 00		.wordinhl:	db "Word in HL (2/0):",0 
551c .. 00		.wordinde:	db "Word in DE (3/0):",0 
552e .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5540			;endif 
5540			;if DEBUG_FORTH_MALLOC 
5540 .. 00		.push_malloc:	db "Malloc address",0 
554f			;endif 
554f			 
554f			 
554f			 
554f			; display malloc address and current data stack pointer  
554f			 
554f			malloc_error: 
554f d5				push de 
5550 f5				push af 
5551 e5				push hl 
5552 cd 98 0c			call clear_display 
5555 11 77 55			ld de, .mallocerr 
5558 3e 00			ld a,0 
555a			;	ld de,os_word_scratch 
555a cd ab 0c			call str_at_display 
555d 3e 11			ld a, display_row_1+17 
555f 11 6e fe			ld de, debug_mark 
5562 cd ab 0c			call str_at_display 
5565 cd bb 0c			call update_display 
5568				;call break_point_state 
5568 cd c8 6c			call cin_wait 
556b			 
556b 3e 20			ld a, ' ' 
556d 32 f0 f1			ld (os_view_disable), a 
5570 e1				pop hl 
5571 f1				pop af 
5572 d1				pop de	 
5573				CALLMONITOR 
5573 cd 73 18			call break_point_state  
5576				endm  
# End of macro CALLMONITOR
5576 c9				ret 
5577			 
5577 .. 00		.mallocerr: 	db "Malloc Error",0 
5584			;if DEBUG_FORTH_PUSH 
5584			display_data_sp: 
5584 f5				push af 
5585			 
5585				; see if disabled 
5585			 
5585 3a f0 f1			ld a, (os_view_disable) 
5588 fe 2a			cp '*' 
558a 28 67			jr z, .skipdsp 
558c			 
558c e5				push hl 
558d e5				push hl 
558e e5			push hl 
558f cd 98 0c			call clear_display 
5592 e1			pop hl 
5593 7c				ld a,h 
5594 21 04 f5			ld hl, os_word_scratch 
5597 cd cd 11			call hexout 
559a e1				pop hl 
559b 7d				ld a,l 
559c 21 06 f5			ld hl, os_word_scratch+2 
559f cd cd 11			call hexout 
55a2 21 08 f5			ld hl, os_word_scratch+4 
55a5 3e 00			ld a,0 
55a7 77				ld (hl),a 
55a8 11 04 f5			ld de,os_word_scratch 
55ab 3e 28				ld a, display_row_2 
55ad cd ab 0c				call str_at_display 
55b0 11 0a 55			ld de, .wordinhl 
55b3 3e 00			ld a, display_row_1 
55b5			 
55b5 cd ab 0c				call str_at_display 
55b8 11 6e fe			ld de, debug_mark 
55bb 3e 11			ld a, display_row_1+17 
55bd			 
55bd cd ab 0c				call str_at_display 
55c0			 
55c0				; display current data stack pointer 
55c0 11 06 55			ld de,.data_sp 
55c3 3e 30				ld a, display_row_2 + 8 
55c5 cd ab 0c				call str_at_display 
55c8			 
55c8 2a 2c fa			ld hl,(cli_data_sp) 
55cb e5				push hl 
55cc 7c				ld a,h 
55cd 21 04 f5			ld hl, os_word_scratch 
55d0 cd cd 11			call hexout 
55d3 e1				pop hl 
55d4 7d				ld a,l 
55d5 21 06 f5			ld hl, os_word_scratch+2 
55d8 cd cd 11			call hexout 
55db 21 08 f5			ld hl, os_word_scratch+4 
55de 3e 00			ld a,0 
55e0 77				ld (hl),a 
55e1 11 04 f5			ld de,os_word_scratch 
55e4 3e 33				ld a, display_row_2 + 11 
55e6 cd ab 0c				call str_at_display 
55e9			 
55e9			 
55e9 cd bb 0c			call update_display 
55ec cd 15 0c			call delay1s 
55ef cd 15 0c			call delay1s 
55f2 e1				pop hl 
55f3			.skipdsp: 
55f3 f1				pop af 
55f4 c9				ret 
55f5			 
55f5			display_data_malloc: 
55f5			 
55f5 f5				push af 
55f6 e5				push hl 
55f7 e5				push hl 
55f8 e5			push hl 
55f9 cd 98 0c			call clear_display 
55fc e1			pop hl 
55fd 7c				ld a,h 
55fe 21 04 f5			ld hl, os_word_scratch 
5601 cd cd 11			call hexout 
5604 e1				pop hl 
5605 7d				ld a,l 
5606 21 06 f5			ld hl, os_word_scratch+2 
5609 cd cd 11			call hexout 
560c 21 08 f5			ld hl, os_word_scratch+4 
560f 3e 00			ld a,0 
5611 77				ld (hl),a 
5612 11 04 f5			ld de,os_word_scratch 
5615 3e 28				ld a, display_row_2 
5617 cd ab 0c				call str_at_display 
561a 11 40 55			ld de, .push_malloc 
561d 3e 00			ld a, display_row_1 
561f			 
561f cd ab 0c				call str_at_display 
5622			 
5622				; display current data stack pointer 
5622 11 06 55			ld de,.data_sp 
5625 3e 30				ld a, display_row_2 + 8 
5627 cd ab 0c				call str_at_display 
562a			 
562a 2a 2c fa			ld hl,(cli_data_sp) 
562d e5				push hl 
562e 7c				ld a,h 
562f 21 04 f5			ld hl, os_word_scratch 
5632 cd cd 11			call hexout 
5635 e1				pop hl 
5636 7d				ld a,l 
5637 21 06 f5			ld hl, os_word_scratch+2 
563a cd cd 11			call hexout 
563d 21 08 f5			ld hl, os_word_scratch+4 
5640 3e 00			ld a,0 
5642 77				ld (hl),a 
5643 11 04 f5			ld de,os_word_scratch 
5646 3e 33				ld a, display_row_2 + 11 
5648 cd ab 0c				call str_at_display 
564b			 
564b cd bb 0c			call update_display 
564e cd 15 0c			call delay1s 
5651 cd 15 0c			call delay1s 
5654 e1				pop hl 
5655 f1				pop af 
5656 c9				ret 
5657			;endif 
5657			 
5657			include "forth_autostart.asm" 
5657			; list of commands to perform at system start up 
5657			 
5657			startcmds: 
5657			;	dw test11 
5657			;	dw test12 
5657			;	dw test13 
5657			;	dw test14 
5657			;	dw test15 
5657			;	dw test16 
5657			;	dw test17 
5657			;	dw ifthtest1 
5657			;	dw ifthtest2 
5657			;	dw ifthtest3 
5657			;	dw mmtest1 
5657			;	dw mmtest2 
5657			;	dw mmtest3 
5657			;	dw mmtest4 
5657			;	dw mmtest5 
5657			;	dw mmtest6 
5657			;	dw iftest1 
5657			;	dw iftest2 
5657			;	dw iftest3 
5657			;	dw looptest1 
5657			;	dw looptest2 
5657			;	dw test1 
5657			;	dw test2 
5657			;	dw test3 
5657			;	dw test4 
5657			;	dw game2r 
5657			;	dw game2b1 
5657			;	dw game2b2 
5657			 
5657				; start up words that are actually useful 
5657			 
5657 b7 56			dw longread 
5659 dd 56			dw clrstack 
565b 10 57			dw type 
565d 00 59			dw stest 
565f 34 57			dw strncpy 
5661 96 58			dw list 
5663 95 57			dw start1 
5665 a7 57			dw start2 
5667			;	dw start3 
5667 ba 57			dw start3b 
5669 36 58			dw start3c 
566b			 
566b				; (unit) testing words 
566b			 
566b 77 59			dw mtesta 
566d 2c 5a			dw mtestb 
566f cf 5a			dw mtestc 
5671 84 5b			dw mtestd 
5673 28 5c			dw mteste 
5675			 
5675				; demo/game words 
5675			 
5675 34 63		        dw game3w 
5677 62 63		        dw game3p 
5679 80 63		        dw game3sc 
567b b1 63		        dw game3vsi 
567d dd 63		        dw game3vs 
567f				 
567f 27 61			dw game2b 
5681 95 61			dw game2bf 
5683 df 61			dw game2mba 
5685 75 62			dw game2mbas 
5687 b7 62			dw game2mb 
5689			 
5689 e8 5d			dw game1 
568b f9 5d			dw game1a 
568d 5b 5e			dw game1b 
568f 90 5e			dw game1c 
5691 c6 5e			dw game1d 
5693 f7 5e			dw game1s 
5695 0b 5f			dw game1t 
5697 20 5f			dw game1f 
5699 54 5f			dw game1z 
569b 98 5f			dw game1zz 
569d			 
569d de 5c			dw test5 
569f 16 5d			dw test6 
56a1 4e 5d			dw test7 
56a3 62 5d			dw test8 
56a5 8e 5d			dw test9 
56a7 a4 5d			dw test10 
56a9				 
56a9 6f 60		        dw ssv5 
56ab 53 60		        dw ssv4 
56ad 37 60		        dw ssv3 
56af 01 60		        dw ssv2 
56b1 88 60		        dw ssv1 
56b3 d0 60		        dw ssv1cpm 
56b5			;	dw keyup 
56b5			;	dw keydown 
56b5			;	dw keyleft 
56b5			;	dw keyright 
56b5			;	dw 	keyf1 
56b5			;	dw keyf2 
56b5			;	dw keyf3 
56b5			;	dw keyf4 
56b5			;	dw keyf5 
56b5			;	dw keyf6 
56b5			;	dw keyf7 
56b5			;	dw keyf8 
56b5			;	dw keyf9 
56b5			;	dw keyf10 
56b5			;	dw keyf11 
56b5			;	dw keyf12 
56b5			;	dw keytab 
56b5			;	dw keycr 
56b5			;	dw keyhome 
56b5			;	dw keyend 
56b5			;	dw keybs 
56b5 00 00			db 0, 0	 
56b7			 
56b7			 
56b7			; Long read 
56b7			; e.g. $01 lread 
56b7			; 
56b7			; TODO need some constants 
56b7			 
56b7 .. 00		longread:   db ": lread read repeat count $3e = if ; ", 0 
56dd			 
56dd			; clear stack  
56dd			 
56dd .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5710			 
5710			; type ( addr count - ) 
5710 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
5734			 
5734			; some direct memory words 
5734			; strncpy ( len t f -- t ) 
5734			 
5734 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5795			 
5795 .. 00		start1:     	db ": bpon $0000 bp ;",0 
57a7 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
57ba .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
5836 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5896			 
5896			 
5896			; a handy word to list items on the stack 
5896			 
5896 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
5900			 
5900			 
5900			; test stack  
5900			; rnd8 stest 
5900			 
5900 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5977			 
5977			; random malloc and free cycles 
5977			 
5977 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5a2c			 
5a2c			; fixed malloc and free cycles 
5a2c			 
5a2c .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5acf			 
5acf			; fixed double string push and drop cycle  
5acf			 
5acf .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5b84			 
5b84			; consistent fixed string push and drop cycle  
5b84			 
5b84 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5c28			 
5c28 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5cde			 
5cde			;test1:		db ": aa 1 2 3 ;", 0 
5cde			;test2:     	db "111 aa 888 999",0 
5cde			;test3:     	db ": bb 77 ;",0 
5cde			;test4:     	db "$02 $01 do i . loop bb",0 
5cde			 
5cde .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5d16 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5d4e .. 00		test7:     	db ": box hline vline ;",0 
5d62 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5d8e .. 00		test9:     	db ": sw $01 adsp world ;",0 
5da4 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5dc9 .. 00		test11:     	db "hello create .",0 
5dd8 .. 00		test12:     	db "hello2 create .",0 
5de8			 
5de8			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5de8			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5de8			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5de8			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5de8			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5de8			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5de8			 
5de8			;iftest1:     	db "$0001 IF cls .",0 
5de8			;iftest2:     	db "$0000 IF cls .",0 
5de8			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5de8			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5de8			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5de8			 
5de8			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5de8			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5de8			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5de8			 
5de8			 
5de8			 
5de8			; a small guess the number game 
5de8			 
5de8 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5df9 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5e5b			 
5e5b .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5e90 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5ec6 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5ef7 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5f0b .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5f20 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5f54 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5f98			 
5f98			; Using 'ga' save a high score across multiple runs using external storage 
5f98			 
5f98 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6001			 
6001			 
6001			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6001			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6001			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6001			 
6001			; simple screen saver to test code memory reuse to destruction 
6001			 
6001 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6037 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6053 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
606f .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6088 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
60d0 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6127			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6127			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6127			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6127			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6127			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6127			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6127			 
6127			 
6127			 
6127			; minesweeper/battleship finding game 
6127			; draws a game board of random ship/mine positions 
6127			; user enters coords to see if it hits on 
6127			; game ends when all are hit 
6127			; when hit or miss says how many may be in the area 
6127			 
6127			; setup the game board and then hide it 
6127 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6195 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
61df			; prompt for where to target 
61df .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6275 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
629a			; TODO see if the entered coords hits or misses pushes char hit of miss 
629a .. 00		game2mbht:      db ": mbckht nop ;",0 
62a9 .. 00		game2mbms:      db ": mbcms nop ;",0 
62b7			; TODO how many might be near by 
62b7 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6334			 
6334			; Game 3 
6334			 
6334			; Vert scroller ski game - avoid the trees! 
6334			 
6334			; v0 score (ie turns) 
6334			; v1 player pos 
6334			; v2 left wall 
6334			; v3 right wall 
6334			 
6334			; Draw side walls randomly 
6334			 
6334 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6362			 
6362			; Draw player 
6362 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6380			 
6380			; TODO Get Key 
6380			 
6380			; TODO Move left right 
6380			 
6380			; scroll and move walls a bit 
6380			 
6380 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
63b1			 
63b1			; main game loop 
63b1			 
63b1 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
63dd .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
641c			 
641c			; key board defs 
641c			 
641c .. 00		keyup:       db ": keyup $05 ;",0 
642a .. 00		keydown:       db ": keydown $0a ;",0 
643a .. 00		keyleft:       db ": keyleft $0b ;",0 
644a .. 00		keyright:       db ": keyright $0c ;",0 
645b .. 00		keyf1:       db ": keyf1 $10 ;",0 
6469 .. 00		keyf2:       db ": keyf2 $11 ;",0 
6477 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6485 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6493 .. 00		keyf5:       db ": keyf5 $14 ;",0 
64a1 .. 00		keyf6:       db ": keyf6 $15 ;",0 
64af .. 00		keyf7:       db ": keyf7 $16 ;",0 
64bd .. 00		keyf8:       db ": keyf8 $17 ;",0 
64cb .. 00		keyf9:       db ": keyf9 $18 ;",0 
64d9 .. 00		keyf10:       db ": keyf10 $19 ;",0 
64e8 .. 00		keyf11:       db ": keyf11 $1a ;",0 
64f7 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6506			 
6506 .. 00		keytab:       db ": keytab $09 ;",0 
6515 .. 00		keycr:       db ": keycr $0d ;",0 
6523 .. 00		keyhome:       db ": keyhome $0e ;",0 
6533 .. 00		keyend:       db ": keyend $0f ;",0 
6542 .. 00		keybs:       db ": keybs $08 ;",0 
6550			 
6550			   
6550			 
6550			 
6550			 
6550			; eof 
# End of file forth_autostart.asm
6550			 
6550 .. 00		sprompt1: db "Startup load...",0 
6560 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6576			 
6576			 
6576			 
6576			 
6576			forth_startup: 
6576 21 57 56			ld hl, startcmds 
6579 3e 00			ld a, 0 
657b 32 25 f6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
657e			 
657e e5			.start1:	push hl 
657f cd 98 0c			call clear_display 
6582 11 50 65			ld de, sprompt1 
6585 3e 00		        ld a, display_row_1 
6587 cd ab 0c			call str_at_display 
658a 11 60 65			ld de, sprompt2 
658d 3e 28		        ld a, display_row_2 
658f cd ab 0c			call str_at_display 
6592 e1				pop hl 
6593 e5				push hl 
6594 5e				ld e,(hl) 
6595 23				inc hl 
6596 56				ld d,(hl) 
6597 3e 50		        ld a, display_row_3 
6599 cd ab 0c			call str_at_display 
659c cd bb 0c			call update_display 
659f			 
659f			 
659f 3a 25 f6			ld a, (os_last_cmd) 
65a2 fe 00			cp 0 
65a4 28 05			jr z, .startprompt 
65a6 cd 09 0c			call delay250ms 
65a9 18 24			jr .startdo 
65ab				 
65ab				 
65ab			 
65ab			.startprompt: 
65ab			 
65ab 3e 9f			ld a,display_row_4 + display_cols - 1 
65ad 11 5d 1e		        ld de, endprg 
65b0 cd ab 0c			call str_at_display 
65b3 cd bb 0c			call update_display 
65b6 cd 15 0c			call delay1s 
65b9 cd c8 6c			call cin_wait 
65bc						 
65bc fe 2a			cp '*' 
65be 28 5e			jr z, .startupend1 
65c0 fe 23			cp '#' 
65c2 20 07			jr nz, .startno 
65c4 3e 01			ld a, 1 
65c6 32 25 f6			ld (os_last_cmd),a 
65c9 18 04			jr .startdo 
65cb fe 31		.startno:	cp '1' 
65cd 28 3a			jr z,.startnxt  
65cf			 
65cf				; exec startup line 
65cf			.startdo:	 
65cf e1				pop hl 
65d0 e5				push hl 
65d1				 
65d1 5e				ld e,(hl) 
65d2 23				inc hl 
65d3 56				ld d,(hl) 
65d4 eb				ex de,hl 
65d5			 
65d5 e5				push hl 
65d6			 
65d6 3e 00			ld a, 0 
65d8				;ld a, FORTH_END_BUFFER 
65d8 cd 35 13			call strlent 
65db 23				inc hl   ; include zero term to copy 
65dc 06 00			ld b,0 
65de 4d				ld c,l 
65df e1				pop hl 
65e0 11 ff f1			ld de, scratch 
65e3 ed b0			ldir 
65e5			 
65e5			 
65e5 21 ff f1			ld hl, scratch 
65e8 cd a3 22			call forthparse 
65eb cd e3 22			call forthexec 
65ee cd f5 21			call forthexec_cleanup 
65f1			 
65f1 3e 78			ld a, display_row_4 
65f3 11 01 1c			ld de, endprog 
65f6			 
65f6 cd bb 0c			call update_display		 
65f9			 
65f9 3a 25 f6			ld a, (os_last_cmd) 
65fc fe 00			cp 0 
65fe 20 09			jr nz, .startnxt 
6600 cd 5f 1e			call next_page_prompt 
6603 cd 98 0c		        call clear_display 
6606 cd bb 0c			call update_display		 
6609			 
6609				; move onto next startup line? 
6609			.startnxt: 
6609			 
6609 cd 09 0c			call delay250ms 
660c e1				pop hl 
660d			 
660d 23				inc hl 
660e 23				inc hl 
660f			 
660f e5				push hl 
6610 5e				ld e, (hl) 
6611 23				inc hl 
6612 56				ld d, (hl) 
6613 e1				pop hl 
6614				; TODO replace 0 test 
6614			 
6614 eb				ex de, hl 
6615 cd f5 0e			call ishlzero 
6618			;	ld a,e 
6618			;	add d 
6618			;	cp 0    ; any left to do? 
6618 eb				ex de, hl 
6619 c2 7e 65			jp nz, .start1 
661c 18 01			jr .startupend 
661e			 
661e e1			.startupend1: pop hl 
661f			.startupend: 
661f			 
661f cd 98 0c			call clear_display 
6622 cd bb 0c			call update_display 
6625 c9				ret 
6626			 
6626			 
6626			; stack over and underflow checks 
6626			 
6626			; init the words to detect the under/overflow 
6626			 
6626			chk_stk_init: 
6626				; a vague random number to check so we dont get any "lucky" hits 
6626 3e 2d			ld a, 45 
6628 6f				ld l, a 
6629 00				nop 
662a 3e 17			ld a, 23 
662c 67				ld h, a 
662d			 
662d 22 e6 f1			ld (chk_word), hl     ; the word we need to check against 
6630			 
6630			;	ld (chk_stund), hl	; stack points.... 
6630 22 fd fe			ld (chk_stovr), hl 
6633 22 2a fa			ld (chk_ret_und), hl 
6636 22 e8 f9			ld (chk_ret_ovr), hl 
6639 22 66 f9			ld (chk_loop_ovr), hl 
663c 22 64 f7			ld (chk_data_ovr), hl 
663f c9				ret 
6640				 
6640			check_stacks: 
6640				; check all stack words 
6640			 
6640 e5				push hl 
6641 d5				push de 
6642			 
6642			;	ld de,(chk_word) 
6642			;	ld hl, (chk_stund)	; stack points.... 
6642			;	if DEBUG_STK_FAULT 
6642			;		DMARK "FAa" 
6642			;		CALLMONITOR 
6642			;	endif 
6642			;	call cmp16 
6642			;	jp z, .chk_faulta 
6642			; 
6642			;	ld de, sfaultsu 
6642			;	jp .chk_fault 
6642			 
6642 2a fd fe		.chk_faulta: ld hl, (chk_stovr) 
6645 ed 5b e6 f1		ld de,(chk_word) 
6649				if DEBUG_STK_FAULT 
6649					DMARK "FAb" 
6649					CALLMONITOR 
6649				endif 
6649 cd ea 0e			call cmp16 
664c 28 06			jr z, .chk_fault1 
664e 11 ef 66			ld de, sfaultso 
6651 c3 a3 66			jp .chk_fault 
6654			.chk_fault1:  
6654 2a 2a fa			ld hl, (chk_ret_und) 
6657 ed 5b e6 f1		ld de,(chk_word) 
665b				if DEBUG_STK_FAULT 
665b					DMARK "FAU" 
665b					CALLMONITOR 
665b				endif 
665b cd ea 0e			call cmp16 
665e ca 67 66			jp z, .chk_fault2 
6661 11 ff 66			ld de, sfaultru 
6664 c3 a3 66			jp .chk_fault 
6667			.chk_fault2:  
6667 2a e8 f9			ld hl, (chk_ret_ovr) 
666a ed 5b e6 f1		ld de,(chk_word) 
666e				if DEBUG_STK_FAULT 
666e					DMARK "FA1" 
666e					CALLMONITOR 
666e				endif 
666e cd ea 0e			call cmp16 
6671 ca 7a 66			jp z, .chk_fault3 
6674 11 0d 67			ld de, sfaultro 
6677 c3 a3 66			jp .chk_fault 
667a			.chk_fault3:  
667a 2a 66 f9			ld hl, (chk_loop_ovr) 
667d ed 5b e6 f1		ld de,(chk_word) 
6681				if DEBUG_STK_FAULT 
6681					DMARK "FA2" 
6681					CALLMONITOR 
6681				endif 
6681 cd ea 0e			call cmp16 
6684 ca 8d 66			jp z, .chk_fault4 
6687 11 27 67			ld de, sfaultlo 
668a c3 a3 66			jp .chk_fault 
668d			.chk_fault4:  
668d 2a 64 f7			ld hl, (chk_data_ovr) 
6690 ed 5b e6 f1		ld de,(chk_word) 
6694				if DEBUG_STK_FAULT 
6694					DMARK "FA3" 
6694					CALLMONITOR 
6694				endif 
6694 cd ea 0e			call cmp16 
6697 ca a0 66			jp z, .chk_fault5 
669a 11 41 67			ld de, sfaultdo 
669d c3 a3 66			jp .chk_fault 
66a0			 
66a0			 
66a0			.chk_fault5:  
66a0 d1				pop de 
66a1 e1				pop hl 
66a2			 
66a2 c9				ret 
66a3			 
66a3 cd 98 0c		.chk_fault: 	call clear_display 
66a6 3e 28				ld a, display_row_2 
66a8 cd ab 0c				call str_at_display 
66ab 11 d1 66				   ld de, .stackfault 
66ae 3e 00				ld a, display_row_1 
66b0 cd ab 0c				call str_at_display 
66b3 11 6e fe				    ld de, debug_mark 
66b6 3e 11				ld a, display_row_1+17 
66b8 cd ab 0c				call str_at_display 
66bb cd bb 0c				call update_display 
66be			 
66be				; prompt before entering montior for investigating issue 
66be			 
66be 3e 78			ld a, display_row_4 
66c0 11 01 1c			ld de, endprog 
66c3			 
66c3 cd bb 0c			call update_display		 
66c6			 
66c6 cd 5f 1e			call next_page_prompt 
66c9			 
66c9 d1				pop de 
66ca e1				pop hl 
66cb cd 55 1c				call monitor 
66ce c3 4c 1b				jp warmstart 
66d1					;jp 0 
66d1					;halt 
66d1			 
66d1			 
66d1			 
66d1 .. 00		.stackfault: 	db "Stack fault:",0 
66de			 
66de .. 00		sfaultsu: 	db	"Stack under flow",0 
66ef .. 00		sfaultso: 	db	"Stack over flow",0 
66ff .. 00		sfaultru:	db "RTS underflow",0 
670d .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6727 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6741 .. 00		sfaultdo:	db "DTS overflow", 0 
674e			 
674e			 
674e			fault_dsp_under: 
674e 11 60 67			ld de, .dsp_under 
6751 c3 10 68			jp .show_fault 
6754			 
6754			fault_rsp_under: 
6754 11 6e 67			ld de, .rsp_under 
6757 c3 10 68			jp .show_fault 
675a			fault_loop_under: 
675a 11 7c 67			ld de, .loop_under 
675d c3 10 68			jp .show_fault 
6760			 
6760 .. 00		.dsp_under: db "DSP Underflow",0 
676e .. 00		.rsp_under: db "RSP Underflow",0 
677c .. 00		.loop_under: db "LOOP Underflow",0 
678b			 
678b			 
678b d5			type_faultn: 	push de 
678c e5					push hl 
678d cd 98 0c				call clear_display 
6790 11 b7 67				   ld de, .typefaultn 
6793 3e 00				ld a, display_row_1 
6795 cd ab 0c				call str_at_display 
6798 11 6e fe				    ld de, debug_mark 
679b 3e 11				ld a, display_row_1+17 
679d cd ab 0c				call str_at_display 
67a0 cd bb 0c				call update_display 
67a3			 
67a3				; prompt before entering montior for investigating issue 
67a3			 
67a3 3e 78			ld a, display_row_4 
67a5 11 01 1c			ld de, endprog 
67a8			 
67a8 cd bb 0c			call update_display		 
67ab			 
67ab cd 5f 1e			call next_page_prompt 
67ae			 
67ae e5					push hl 
67af d5					push de 
67b0 cd 55 1c				call monitor 
67b3 c3 4c 1b				jp warmstart 
67b6 76					halt 
67b7			 
67b7			 
67b7 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
67ce			 
67ce d5			type_faults: 	push de 
67cf e5					push hl 
67d0 cd 98 0c				call clear_display 
67d3 11 f9 67				   ld de, .typefaults 
67d6 3e 00				ld a, display_row_1 
67d8 cd ab 0c				call str_at_display 
67db 11 6e fe				    ld de, debug_mark 
67de 3e 11				ld a, display_row_1+17 
67e0 cd ab 0c				call str_at_display 
67e3 cd bb 0c				call update_display 
67e6			 
67e6				; prompt before entering montior for investigating issue 
67e6			 
67e6 3e 78			ld a, display_row_4 
67e8 11 01 1c			ld de, endprog 
67eb			 
67eb cd bb 0c			call update_display		 
67ee			 
67ee cd 5f 1e			call next_page_prompt 
67f1			 
67f1 e1					pop hl 
67f2 d1					pop de 
67f3 cd 55 1c				call monitor 
67f6 c3 4c 1b				jp warmstart 
67f9			 
67f9			 
67f9 .. 00		.typefaults: db "STR Type Expected TOS!",0 
6810			 
6810			.show_fault: 	 
6810 d5					push de 
6811 cd 98 0c				call clear_display 
6814 d1					pop de 
6815 3e 00				ld a, display_row_1 
6817 cd ab 0c				call str_at_display 
681a 11 6e fe				    ld de, debug_mark 
681d 3e 11				ld a, display_row_1+17 
681f cd ab 0c				call str_at_display 
6822 cd bb 0c				call update_display 
6825			 
6825				; prompt before entering montior for investigating issue 
6825			 
6825 3e 78			ld a, display_row_4 
6827 11 01 1c			ld de, endprog 
682a			 
682a cd bb 0c			call update_display		 
682d			 
682d cd 5f 1e			call next_page_prompt 
6830			 
6830 e1					pop hl 
6831 d1					pop de 
6832 cd 55 1c				call monitor 
6835			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6835			; TODO Make optional fault restart to cli or warm boot? 
6835					;jp warmstart 
6835 c3 a7 1b				jp cli 
6838 76					halt 
6839			 
6839			; handle the auto run of code from files in storage 
6839			 
6839			 
6839			if STORAGE_SE 
6839			 
6839 .. 00		sprompt3: db "Loading from start-up file?:",0 
6856 .. 00		sprompt4: db "(Y=Any key/N=No)",0 
6867			 
6867			 
6867			forth_autoload: 
6867			 
6867				; load block 0 of store 1 
6867				 
6867 3e fe			ld a, $fe      ; bit 0 clear 
6869 32 6a fa			ld (spi_device), a 
686c			 
686c cd 85 04			call storage_get_block_0 
686f			 
686f 3a a2 fa			ld a, (store_page+STORE_0_AUTOFILE) 
6872			 
6872 fe 00			cp 0 
6874 c8				ret z     ; auto start not enabled 
6875			 
6875 cd 98 0c			call clear_display 
6878			 
6878				; set bank 
6878			 
6878 3a a4 fa				ld a, (store_page+STORE_0_BANKRUN) 
687b 32 6a fa				ld (spi_device), a 
687e			 
687e				; get file id to load from and get the file name to display 
687e			 
687e 3a a5 fa				ld a, (store_page+STORE_0_FILERUN) 
6881			 
6881 2e 00				ld l, 0 
6883 67					ld h, a 
6884 11 81 fa				ld de, store_page 
6887			 
6887					if DEBUG_FORTH_WORDS 
6887						DMARK "ASp" 
6887 f5				push af  
6888 3a 9c 68			ld a, (.dmark)  
688b 32 6e fe			ld (debug_mark),a  
688e 3a 9d 68			ld a, (.dmark+1)  
6891 32 6f fe			ld (debug_mark+1),a  
6894 3a 9e 68			ld a, (.dmark+2)  
6897 32 70 fe			ld (debug_mark+2),a  
689a 18 03			jr .pastdmark  
689c ..			.dmark: db "ASp"  
689f f1			.pastdmark: pop af  
68a0			endm  
# End of macro DMARK
68a0						CALLMONITOR 
68a0 cd 73 18			call break_point_state  
68a3				endm  
# End of macro CALLMONITOR
68a3					endif 
68a3 cd 2d 09				call storage_read 
68a6			 
68a6					if DEBUG_FORTH_WORDS 
68a6						DMARK "ASr" 
68a6 f5				push af  
68a7 3a bb 68			ld a, (.dmark)  
68aa 32 6e fe			ld (debug_mark),a  
68ad 3a bc 68			ld a, (.dmark+1)  
68b0 32 6f fe			ld (debug_mark+1),a  
68b3 3a bd 68			ld a, (.dmark+2)  
68b6 32 70 fe			ld (debug_mark+2),a  
68b9 18 03			jr .pastdmark  
68bb ..			.dmark: db "ASr"  
68be f1			.pastdmark: pop af  
68bf			endm  
# End of macro DMARK
68bf						CALLMONITOR 
68bf cd 73 18			call break_point_state  
68c2				endm  
# End of macro CALLMONITOR
68c2					endif 
68c2			 
68c2 cd f5 0e				call ishlzero 
68c5 c8					ret z             ; file not found 
68c6			 
68c6 3e 32				ld a, display_row_2 + 10 
68c8 11 84 fa				ld de, store_page+3 
68cb cd ab 0c				call str_at_display 
68ce				 
68ce			; 
68ce			 
68ce 3e 05			ld a, display_row_1+5 
68d0 11 39 68			ld de, sprompt3 
68d3 cd ab 0c			call str_at_display 
68d6 3e 5f			ld a, display_row_3+15 
68d8 11 56 68			ld de, sprompt4 
68db cd ab 0c			call str_at_display 
68de			 
68de cd bb 0c			call update_display 
68e1			 
68e1 cd c8 6c			call cin_wait 
68e4 fe 6e			cp 'n' 
68e6 c8				ret z 
68e7 fe 4e			cp 'N' 
68e9 c8				ret z 
68ea			 
68ea cd 15 0c			call delay1s 
68ed			 
68ed 3a 83 fa			ld a, (store_page+2) 
68f0 32 72 fa			ld (store_openmaxext), a    ; save count of ext 
68f3 3e 01			ld a, 1  
68f5 32 73 fa			ld (store_openext), a    ; save count of ext 
68f8			 
68f8			.autof:  
68f8 6f				ld l , a 
68f9				 
68f9 3a 81 fa			ld a, (store_page) 
68fc 67				ld h, a	 
68fd 11 81 fa			ld de, store_page 
6900					if DEBUG_FORTH_WORDS 
6900						DMARK "ASl" 
6900 f5				push af  
6901 3a 15 69			ld a, (.dmark)  
6904 32 6e fe			ld (debug_mark),a  
6907 3a 16 69			ld a, (.dmark+1)  
690a 32 6f fe			ld (debug_mark+1),a  
690d 3a 17 69			ld a, (.dmark+2)  
6910 32 70 fe			ld (debug_mark+2),a  
6913 18 03			jr .pastdmark  
6915 ..			.dmark: db "ASl"  
6918 f1			.pastdmark: pop af  
6919			endm  
# End of macro DMARK
6919						CALLMONITOR 
6919 cd 73 18			call break_point_state  
691c				endm  
# End of macro CALLMONITOR
691c					endif 
691c cd 2d 09				call storage_read 
691f cd f5 0e			call ishlzero 
6922 c8				ret z 
6923			;	jr z, .autoend 
6923			 
6923					if DEBUG_FORTH_WORDS 
6923						DMARK "ASc" 
6923 f5				push af  
6924 3a 38 69			ld a, (.dmark)  
6927 32 6e fe			ld (debug_mark),a  
692a 3a 39 69			ld a, (.dmark+1)  
692d 32 6f fe			ld (debug_mark+1),a  
6930 3a 3a 69			ld a, (.dmark+2)  
6933 32 70 fe			ld (debug_mark+2),a  
6936 18 03			jr .pastdmark  
6938 ..			.dmark: db "ASc"  
693b f1			.pastdmark: pop af  
693c			endm  
# End of macro DMARK
693c						CALLMONITOR 
693c cd 73 18			call break_point_state  
693f				endm  
# End of macro CALLMONITOR
693f					endif 
693f 11 83 fa			ld de, store_page+2 
6942 3e 78			ld a, display_row_4 
6944 cd ab 0c			call str_at_display 
6947			 
6947 cd bb 0c			call update_display 
694a cd 09 0c			call delay250ms 
694d			 
694d			 
694d			 
694d 21 83 fa			ld hl, store_page+2 
6950 cd a3 22			call forthparse 
6953 cd e3 22			call forthexec 
6956 cd f5 21			call forthexec_cleanup 
6959			 
6959				 
6959 3a 73 fa			ld a, (store_openext) 
695c 3c				inc a 
695d 32 73 fa			ld (store_openext), a    ; save count of ext 
6960			 
6960 18 96			jr .autof 
6962			;.autofdone: 
6962			; 
6962			;		if DEBUG_FORTH_WORDS 
6962			;			DMARK "ASx" 
6962			;			CALLMONITOR 
6962			;		endif 
6962			;;	call clear_display 
6962			;	ret 
6962			 
6962			 
6962			 
6962			endif 
6962			 
6962			 
6962			; eof 
# End of file forth_kernel.asm
6962			;include "nascombasic.asm" 
6962			 
6962			 
6962			; find out where the code ends if loaded into RAM (for SC114) 
6962			;endofcode:  
6962			;	nop 
6962			 
6962			 
6962			; eof 
6962			 
# End of file main.asm
6962			include "firmware_lcd_4x40.asm" 
6962			; **********************************************************************  
6962			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
6962			; **********************************************************************  
6962			;  
6962			; **  Written as a Small Computer Monitor App  
6962			; **  www.scc.me.uk  
6962			;  
6962			; History  
6962			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
6962			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
6962			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
6962			;  
6962			; **********************************************************************  
6962			;  
6962			; This program is an example of one of the methods of interfacing an   
6962			; alphanumeric LCD module.   
6962			;  
6962			; In this example the display is connected to either a Z80 PIO or a   
6962			; simple 8-bit output port.   
6962			;  
6962			; This interfacing method uses 4-bit data mode and uses time delays  
6962			; rather than polling the display's ready status. As a result the   
6962			; interface only requires 6 simple output lines:  
6962			;   Output bit 0 = not used  
6962			;   Output bit 1 = not used  
6962			;   Output bit 2 = RS         High = data, Low = instruction  
6962			;   Output bit 3 = E          Active high  
6962			;   Output bit 4 = DB4  
6962			;   Output bit 5 = DB5  
6962			;   Output bit 6 = DB6  
6962			;   Output bit 7 = DB7  
6962			; Display's R/W is connected to 0v so it is always in write mode  
6962			;  
6962			; This set up should work with any system supporting the RC2014 bus  
6962			  
6962			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
6962			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
6962			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
6962			;  
6962			; **********************************************************************  
6962			  
6962			; Additonal for 4x40. E1 and E2 instead of just E   
6962			; TODO swipe vidout signal on port a to activate E2  
6962			  
6962			; **********************************************************************  
6962			; **  Constants  
6962			; **********************************************************************  
6962			; LCD constants required by LCD support module  
6962			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
6962			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
6962			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
6962			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
6962			; TODO Decide which E is being set  
6962			kLCDWidth:  EQU display_cols             ;Width in characters  
6962			  
6962			; **********************************************************************  
6962			; **  Code library usage  
6962			; **********************************************************************  
6962			  
6962			; send character to current cursor position  
6962			; wraps and/or scrolls screen automatically  
6962			  
6962			  
6962			  
6962			lcd_init:  
6962			  
6962			; SCMonAPI functions used  
6962			  
6962			; Alphanumeric LCD functions used  
6962			; no need to specify specific functions for this module  
6962			  
6962 3e cf		            LD   A, 11001111b  
6964 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
6966 3e 00		            LD   A, 00000000b  
6968 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
696a			  
696a			; Initialise alphanumeric LCD module  
696a 3e 00				ld a, 0  
696c 32 ce fb				ld (display_lcde1e2), a  
696f cd f0 69		            CALL fLCD_Init      ;Initialise LCD module  
6972 3e 01				ld a, 1  
6974 32 ce fb				ld (display_lcde1e2), a  
6977 cd f0 69		            CALL fLCD_Init      ;Initialise LCD module  
697a			  
697a c9				ret  
697b			  
697b			;  
697b			;;  
697b			; lcd functions  
697b			;  
697b			;  
697b			  
697b			; what is at cursor position   
697b			  
697b			;get_cursor:	ld de, (cursor_row)   ;  row + col  
697b			;		call curptr  
697b			;		ret  
697b			  
697b			  
697b			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
697b			  
697b			curptr:  
697b c5				push bc  
697c 21 b4 fd			ld hl, display_fb0  
697f			cpr:	  
697f				; loop for cursor whole row  
697f 0e 28			ld c, display_cols  
6981 23			cpr1:	inc hl  
6982 0d				dec c  
6983 20 fc			jr nz, cpr1  
6985 05				dec b  
6986 20 f7			jr nz, cpr  
6988			  
6988				; add col	  
6988			  
6988 23			cpr2:	inc hl  
6989 1d				dec e  
698a 20 fc			jr nz, cpr2  
698c			  
698c c1				pop bc  
698d c9				ret  
698e				  
698e			  
698e			  
698e			  
698e			  
698e			; write the frame buffer given in hl to hardware   
698e 22 cc fb		write_display: ld (display_write_tmp), hl 	   
6991 3e 00			ld a, kLCD_Line1  
6993 cd 9d 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6996 06 28			ld b, display_cols  
6998 ed 5b cc fb		ld de, (display_write_tmp)  
699c cd e8 69			call write_len_string  
699f				  
699f				  
699f 2a cc fb			ld hl, (display_write_tmp)  
69a2 11 28 00			ld de, display_cols  
69a5 19				add hl,de  
69a6 22 cc fb			ld (display_write_tmp),hl  
69a9			  
69a9				  
69a9 3e 28			ld a, kLCD_Line2  
69ab cd 9d 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
69ae 06 28			ld b, display_cols  
69b0 ed 5b cc fb		ld de, (display_write_tmp)  
69b4 cd e8 69			call write_len_string  
69b7				  
69b7 2a cc fb			ld hl, (display_write_tmp)  
69ba 11 28 00			ld de, display_cols  
69bd 19				add hl,de  
69be 22 cc fb			ld (display_write_tmp),hl  
69c1			  
69c1				  
69c1 3e 50			ld a, kLCD_Line3  
69c3 cd 9d 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
69c6 06 28			ld b, display_cols  
69c8 ed 5b cc fb		ld de, (display_write_tmp)  
69cc cd e8 69			call write_len_string  
69cf				  
69cf 2a cc fb			ld hl, (display_write_tmp)  
69d2 11 28 00			ld de, display_cols  
69d5 19				add hl,de  
69d6 22 cc fb			ld (display_write_tmp),hl  
69d9			  
69d9				  
69d9 3e 78			ld a, kLCD_Line4  
69db cd 9d 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
69de 06 28			ld b, display_cols  
69e0 ed 5b cc fb		ld de, (display_write_tmp)  
69e4 cd e8 69			call write_len_string  
69e7 c9					ret  
69e8				  
69e8				; write out a fixed length string given in b from de  
69e8			  
69e8 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
69e9 cd 55 6a		            CALL fLCD_Data      ;Write character to display  
69ec 13				inc de  
69ed 10 f9			djnz write_len_string  
69ef c9				ret  
69f0			  
69f0			; Some other things to do  
69f0			;            LD   A, kLCD_Clear ;Display clear  
69f0			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
69f0			;            LD   A, kLCD_Under ;Display on with underscore cursor  
69f0			;            LD   A, kLCD_On     ;Display on with no cursor  
69f0			;            ;LD   A, kLCD_Off   ;Display off  
69f0			;            CALL fLCD_Inst      ;Send instruction to display  
69f0			;  
69f0			;  
69f0			;            halt  
69f0			;  
69f0			;  
69f0			;MsgHello:   DB  "Hello World!",0  
69f0			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
69f0			  
69f0			; Custom characters 5 pixels wide by 8 pixels high  
69f0			; Up to 8 custom characters can be defined  
69f0			;BitMaps:      
69f0			;; Character 0x00 = Battery icon  
69f0			;            DB  01110b  
69f0			;            DB  11011b  
69f0			;            DB  10001b  
69f0			;            DB  10001b  
69f0			;            DB  11111b  
69f0			;            DB  11111b  
69f0			;            DB  11111b  
69f0			;            DB  11111b  
69f0			;; Character 0x01 = Bluetooth icon  
69f0			;            DB  01100b  
69f0			;            DB  01010b  
69f0			;            DB  11100b  
69f0			;            DB  01000b  
69f0			;            DB  11100b  
69f0			;            DB  01010b  
69f0			;            DB  01100b  
69f0			;            DB  00000b  
69f0			;  
69f0			  
69f0			  
69f0			; **********************************************************************  
69f0			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
69f0			; **********************************************************************  
69f0			;  
69f0			; **  Written as a Small Computer Monitor App   
69f0			; **  Version 0.1 SCC 2018-05-16  
69f0			; **  www.scc.me.uk  
69f0			;  
69f0			; **********************************************************************  
69f0			;  
69f0			; This module provides support for alphanumeric LCD modules using with  
69f0			; *  HD44780 (or compatible) controller  
69f0			; *  5 x 7 pixel fonts  
69f0			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
69f0			; *  Interface via six digital outputs to the display (see below)  
69f0			;  
69f0			; LCD module pinout:  
69f0			;   1  Vss   0v supply  
69f0			;   2  Vdd   5v supply  
69f0			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
69f0			;   4  RS    High = data, Low = instruction  
69f0			;   5  R/W   High = Read, Low = Write  
69f0			;   6  E     Enable signal (active high)  
69f0			;   7  DB0   Data bit 0  
69f0			;   8  DB1   Data bit 1  
69f0			;   9  DB2   Data bit 2  
69f0			;  10  DB3   Data bit 3  
69f0			;  11  DB4   Data bit 4  
69f0			;  12  DB5   Data bit 5  
69f0			;  13  DB6   Data bit 6  
69f0			;  14  DB7   Data bit 7  
69f0			;  15  A     Backlight anode (+)  
69f0			;  16  K     Backlight cathode (-)  
69f0			;  
69f0			; This interfacing method uses 4-bit data mode and uses time delays  
69f0			; rather than polling the display's ready status. As a result the   
69f0			; interface only requires 6 simple output lines:  
69f0			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
69f0			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
69f0			;   LCD DB4 = Microcomputer output port bit 4  
69f0			;   LCD DB5 = Microcomputer output port bit 5  
69f0			;   LCD DB6 = Microcomputer output port bit 6  
69f0			;   LCD DB7 = Microcomputer output port bit 7  
69f0			; Display's R/W is connected to 0v so it is always in write mode  
69f0			; All 6 connections must be on the same port address <kLCDPrt>  
69f0			; This method also allows a decent length of cable from micro to LCD  
69f0			;  
69f0			; **********************************************************************  
69f0			;  
69f0			; To include the code for any given function provided by this module,   
69f0			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
69f0			; the parent source file.  
69f0			; For example:  #REQUIRES   uHexPrefix  
69f0			;  
69f0			; Also #INCLUDE this file at some point after the #REQUIRES statements  
69f0			; in the parent source file.  
69f0			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
69f0			;  
69f0			; These are the function names provided by this module:  
69f0			; fLCD_Init                     ;Initialise LCD  
69f0			; fLCD_Inst                     ;Send instruction to LCD  
69f0			; fLCD_Data                     ;Send data byte to LCD  
69f0			; fLCD_Pos                      ;Position cursor  
69f0			; fLCD_Str                      ;Display string  
69f0			; fLCD_Def                      ;Define custom character  
69f0			;  
69f0			; **********************************************************************  
69f0			;  
69f0			; Requires SCMonAPI.asm to also be included in the project  
69f0			;  
69f0			  
69f0			  
69f0			; **********************************************************************  
69f0			; **  Constants  
69f0			; **********************************************************************  
69f0			  
69f0			; Constants that must be defined externally  
69f0			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
69f0			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
69f0			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
69f0			;kLCDWidth: EQU 20             ;Width in characters  
69f0			  
69f0			; general line offsets in any frame buffer  
69f0			  
69f0			  
69f0			display_row_1: equ 0  
69f0			display_row_2: equ display_row_1+display_cols  
69f0			display_row_3: equ display_row_2 + display_cols  
69f0			display_row_4: equ display_row_3 + display_cols  
69f0			;display_row_4_eol:   
69f0			  
69f0			  
69f0			; Cursor position values for the start of each line  
69f0			  
69f0			; E  
69f0			kLCD_Line1: EQU 0x00   
69f0			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
69f0			; E1  
69f0			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
69f0			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
69f0			  
69f0			; Instructions to send as A register to fLCD_Inst  
69f0			kLCD_Clear: EQU 00000001b     ;LCD clear  
69f0			kLCD_Off:   EQU 00001000b     ;LCD off  
69f0			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
69f0			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
69f0			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
69f0			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
69f0			  
69f0			; Constants used by this code module  
69f0			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
69f0			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
69f0			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
69f0			  
69f0			  
69f0			  
69f0			; **********************************************************************  
69f0			; **  LCD support functions  
69f0			; **********************************************************************  
69f0			  
69f0			; Initialise alphanumeric LCD module  
69f0			; LCD control register codes:  
69f0			;   DL   0 = 4-bit mode        1 = 8-bit mode  
69f0			;   N    0 = 1-line mode       1 = 2-line mode  
69f0			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
69f0			;   D    0 = Display off       1 = Display on  
69f0			;   C    0 = Cursor off        1 = Cursor on  
69f0			;   B    0 = Blinking off      1 = Blinking on  
69f0			;   ID   0 = Decrement mode    1 = Increment mode  
69f0			;   SH   0 = Entire shift off  1 = Entire shift on  
69f0 3e 28		fLCD_Init:  LD   A, 40  
69f2 cd 17 6b		            CALL LCDDelay       ;Delay 40ms after power up  
69f5			; For reliable reset set 8-bit mode - 3 times  
69f5 cd e7 6a		            CALL WrFn8bit       ;Function = 8-bit mode  
69f8 cd e7 6a		            CALL WrFn8bit       ;Function = 8-bit mode  
69fb cd e7 6a		            CALL WrFn8bit       ;Function = 8-bit mode  
69fe			; Set 4-bit mode  
69fe cd e3 6a		            CALL WrFn4bit       ;Function = 4-bit mode  
6a01 cd 15 6b		            CALL LCDDelay1      ;Delay 37 us or more  
6a04			; Function set  
6a04 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6a06 cd 19 6a		            CALL fLCD_Inst      ;2 line, display on  
6a09			; Display On/Off control  
6a09 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6a0b cd 19 6a		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
6a0e			; Display Clear  
6a0e 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
6a10 cd 19 6a		            CALL fLCD_Inst      ;Clear display  
6a13			; Entry mode  
6a13 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6a15 cd 19 6a		            CALL fLCD_Inst      ;Increment mode, shift off  
6a18			; Display module now initialised  
6a18 c9			            RET  
6a19			; ok to here  
6a19			  
6a19			; Write instruction to LCD  
6a19			;   On entry: A = Instruction byte to be written  
6a19			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6a19 f5			fLCD_Inst:  PUSH AF  
6a1a f5			            PUSH AF  
6a1b cd 2d 6a		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
6a1e f1			            POP  AF  
6a1f 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6a20 17			            RLA  
6a21 17			            RLA  
6a22 17			            RLA  
6a23 cd 2d 6a		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
6a26 3e 02		            LD   A, 2  
6a28 cd 17 6b		            CALL LCDDelay       ;Delay 2 ms to complete   
6a2b f1			            POP  AF  
6a2c c9			            RET  
6a2d			Wr4bits:   
6a2d f5					push af  
6a2e 3a ce fb				ld a, (display_lcde1e2)  
6a31 fe 00				cp 0     ; e  
6a33 20 10				jr nz, .wea2	  
6a35 f1					pop af  
6a36 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6a38 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6a3a cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
6a3c cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
6a3e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6a40 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
6a42 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6a44 c9			            RET  
6a45 f1			.wea2:		pop af  
6a46 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6a48 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6a4a cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
6a4c cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
6a4e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6a50 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
6a52 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6a54 c9			            RET  
6a55			  
6a55			  
6a55			; Write data to LCD  
6a55			;   On entry: A = Data byte to be written  
6a55			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6a55 f5			fLCD_Data:  PUSH AF  
6a56 f5			            PUSH AF  
6a57 cd 69 6a		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
6a5a f1			            POP  AF  
6a5b 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6a5c 17			            RLA  
6a5d 17			            RLA  
6a5e 17			            RLA  
6a5f cd 69 6a		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
6a62 3e 96		            LD   A, 150  
6a64 3d			Wait:      DEC  A              ;Wait a while to allow data   
6a65 20 fd		            JR   NZ, Wait      ;  write to complete  
6a67 f1			            POP  AF  
6a68 c9			            RET  
6a69			Wr4bitsa:     
6a69 f5					push af  
6a6a 3a ce fb				ld a, (display_lcde1e2)  
6a6d fe 00				cp 0     ; e1  
6a6f 20 16				jr nz, .we2	  
6a71 f1					pop af  
6a72 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6a74 cb d7		            SET  kLCDBitRS, A  
6a76 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6a78 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
6a7a cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
6a7c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6a7e cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
6a80 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6a82 cb 97		            RES  kLCDBitRS, A  
6a84 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6a86 c9			            RET  
6a87 f1			.we2:		pop af  
6a88 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6a8a cb d7		            SET  kLCDBitRS, A  
6a8c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6a8e cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
6a90 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
6a92 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
6a94 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
6a96 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
6a98 cb 97		            RES  kLCDBitRS, A  
6a9a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6a9c c9			            RET  
6a9d			  
6a9d			  
6a9d			; Position cursor to specified location  
6a9d			;   On entry: A = Cursor position  
6a9d			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6a9d f5			fLCD_Pos:   PUSH AF  
6a9e					; at this point set the E1 or E2 flag depending on position  
6a9e			  
6a9e c5					push bc  
6a9f			;		push af  
6a9f 06 00				ld b, 0  
6aa1 4f					ld c, a  
6aa2 3e 4f				ld a, kLCD_Line3-1  
6aa4 b7			 		or a      ;clear carry flag  
6aa5 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
6aa6 38 04				jr c, .pe1  
6aa8			  
6aa8					; E selection  
6aa8 cb 80				res 0, b         ; bit 0 unset e  
6aaa			;		pop af    ; before line 3 so recover orig pos  
6aaa			;		ld c, a    ; save for poking back  
6aaa 18 06				jr .peset	          
6aac			.pe1:          	; E2 selection  
6aac cb c0				set 0, b         ; bit 0 set e1  
6aae 79					ld a, c  
6aaf de 4f				sbc a, kLCD_Line3-1  
6ab1 4f					ld c, a	         ; save caculated offset  
6ab2			;		pop af     ; bin this original value now we have calculated form  
6ab2			  
6ab2			.peset:		; set bit  
6ab2 78					ld a, b  
6ab3 32 ce fb				ld (display_lcde1e2), a 	  
6ab6 79					ld a, c  
6ab7 c1					pop bc  
6ab8			  
6ab8 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
6aba cd 19 6a		            CALL fLCD_Inst      ;Write instruction to LCD  
6abd f1			            POP  AF  
6abe c9			            RET  
6abf			  
6abf			  
6abf			; Output text string to LCD  
6abf			;   On entry: DE = Pointer to null terminated text string  
6abf			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
6abf 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
6ac0 b7			            OR   A              ;Null terminator?  
6ac1 c8			            RET  Z              ;Yes, so finished  
6ac2 cd 55 6a		            CALL fLCD_Data      ;Write character to display  
6ac5 13			            INC  DE             ;Point to next character  
6ac6 18 f7		            JR   fLCD_Str       ;Repeat  
6ac8 c9					ret  
6ac9			  
6ac9			; Define custom character  
6ac9			;   On entry: A = Character number (0 to 7)  
6ac9			;             DE = Pointer to character bitmap data  
6ac9			;   On exit:  A = Next character number  
6ac9			;             DE = Next location following bitmap  
6ac9			;             BC HL IX IY I AF' BC' DE' HL' preserved  
6ac9			; Character is   
6ac9 c5			fLCD_Def:   PUSH BC  
6aca f5			            PUSH AF  
6acb 07			            RLCA                ;Calculate location  
6acc 07			            RLCA                ;  for bitmap data  
6acd 07			            RLCA                ;  = 8 x CharacterNumber  
6ace f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
6ad0 cd 19 6a		            CALL fLCD_Inst      ;Write instruction to LCD  
6ad3 06 00		            LD   B, 0  
6ad5 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6ad6 cd 55 6a		            CALL fLCD_Data      ;Write byte to display  
6ad9 13			            INC  DE             ;Point to next byte  
6ada 04			            INC  B              ;Count bytes  
6adb cb 58		            BIT  3, B           ;Finish all 8 bytes?  
6add 28 f6		            JR   Z, Loop       ;No, so repeat  
6adf f1			            POP  AF  
6ae0 3c			            INC  A              ;Increment character number  
6ae1 c1			            POP  BC  
6ae2 c9			            RET  
6ae3			  
6ae3			  
6ae3			; **********************************************************************  
6ae3			; **  Private functions  
6ae3			; **********************************************************************  
6ae3			  
6ae3			; Write function to LCD  
6ae3			;   On entry: A = Function byte to be written  
6ae3			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6ae3 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6ae5 18 02		            JR   WrFunc  
6ae7 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6ae9 f5			WrFunc:     PUSH AF  
6aea f5					push af  
6aeb 3a ce fb				ld a, (display_lcde1e2)  
6aee fe 00				cp 0     ; e1  
6af0 20 0f				jr nz, .wfea2	  
6af2 f1					pop af  
6af3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6af5 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
6af7 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6af9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6afb cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6afd d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6aff 18 0d			jr .wfskip  
6b01 f1			.wfea2:		pop af  
6b02 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6b04 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
6b06 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6b08 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6b0a cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6b0c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6b0e 3e 05		.wfskip:            LD  A, 5  
6b10 cd 17 6b		            CALL LCDDelay       ;Delay 5 ms to complete  
6b13 f1			            POP  AF  
6b14 c9			            RET  
6b15			  
6b15			  
6b15			; Delay in milliseconds  
6b15			;   On entry: A = Number of milliseconds delay  
6b15			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6b15 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6b17 d5			LCDDelay:   PUSH DE  
6b18 5f			            LD   E, A           ;Delay by 'A' ms  
6b19 16 00		            LD   D, 0  
6b1b cd fa 0b		            CALL aDelayInMS  
6b1e d1			            POP  DE  
6b1f c9			            RET  
6b20			  
6b20			  
6b20			testlcd:  
6b20 3e 00			ld a, kLCD_Line1  
6b22 cd 9d 6a			call fLCD_Pos  
6b25 06 28			ld b, 40  
6b27 11 55 6b			ld de, .ttext1  
6b2a cd e8 69			call write_len_string  
6b2d			  
6b2d 3e 28			ld a, kLCD_Line2  
6b2f cd 9d 6a			call fLCD_Pos  
6b32 06 28			ld b, 40  
6b34 11 7e 6b			ld de, .ttext2  
6b37 cd e8 69			call write_len_string  
6b3a 3e 50			ld a, kLCD_Line3  
6b3c cd 9d 6a			call fLCD_Pos  
6b3f 06 28			ld b, 40  
6b41 11 a7 6b			ld de, .ttext3  
6b44 cd e8 69			call write_len_string  
6b47 3e 78			ld a, kLCD_Line4  
6b49 cd 9d 6a			call fLCD_Pos  
6b4c 06 28			ld b, 40  
6b4e 11 d0 6b			ld de, .ttext4  
6b51 cd e8 69			call write_len_string  
6b54			  
6b54 76				halt  
6b55			  
6b55			  
6b55 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
6b7e .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
6ba7 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
6bd0 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
6bf9			   
6bf9			  
6bf9			  
6bf9			; eof  
6bf9			  
# End of file firmware_lcd_4x40.asm
6bf9			;include "firmware_lcd_4x20.asm" 
6bf9			include "firmware_key_5x10.asm" 
6bf9			; 5 x 10 decade counter scanner  
6bf9			  
6bf9			  
6bf9			; TODO do cursor shape change for shift keys  
6bf9			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
6bf9			  
6bf9			  
6bf9			; bit mask for each scan column and row for teing the matrix  
6bf9			  
6bf9			  
6bf9			key_init:  
6bf9			  
6bf9			; SCMonAPI functions used  
6bf9			  
6bf9			; Alphanumeric LCD functions used  
6bf9			; no need to specify specific functions for this module  
6bf9			  
6bf9			  
6bf9 3e cf		            LD   A, 11001111b  
6bfb d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
6bfd			;            LD   A, 00000000b  
6bfd 3e 1f		            LD   A, 00011111b  
6bff d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
6c01			  
6c01			  
6c01				; TODO Configure cursor shapes  
6c01			  
6c01				; Load cursor shapes   
6c01 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
6c03 11 13 6c		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
6c06 06 02		            LD   B, 2           ;Number of characters to define  
6c08 cd c9 6a		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6c0b 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
6c0d			  
6c0d 3e 01				ld a, 1  
6c0f 32 c7 fb			ld (cursor_shape),a  
6c12 c9				ret  
6c13			  
6c13			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
6c13			; Up to 8 custom characters can be defined  
6c13			.cursor_shapes:      
6c13			;; Character 0x00 = Normal  
6c13 1f			            DB  11111b  
6c14 1f			            DB  11111b  
6c15 1f			            DB  11111b  
6c16 1f			            DB  11111b  
6c17 1f			            DB  11111b  
6c18 1f			            DB  11111b  
6c19 1f			            DB  11111b  
6c1a 1f			            DB  11111b  
6c1b			;; Character 0x01 = Modifier  
6c1b 1f			            DB  11111b  
6c1c 1b			            DB  11011b  
6c1d 1b			            DB  11011b  
6c1e 1b			            DB  11011b  
6c1f 1b			            DB  11011b  
6c20 1f			            DB  11111b  
6c21 1b			            DB  11011b  
6c22 1f			            DB  11111b  
6c23			  
6c23			  
6c23			  
6c23			  
6c23			; Display custom character 0  
6c23			;            LD   A, kLCD_Line1+14  
6c23			;            CALL fLCD_Pos       ;Position cursor to location in A  
6c23			;            LD   A, 0  
6c23			;            CALL fLCD_Data      ;Write character in A at cursor  
6c23			  
6c23			; Display custom character 1  
6c23			;            LD   A, kLCD_Line2+14  
6c23			;            CALL fLCD_Pos      ;Position cursor to location in A  
6c23			;            LD   A, 1  
6c23			;            CALL fLCD_Data     ;Write character in A at cursor  
6c23			  
6c23			; keyboard scanning   
6c23			  
6c23			; character in from keyboard  
6c23			  
6c23			; mapping for the pcb layout  
6c23			  
6c23			.matrix_to_char:  
6c23 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
6c2e .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
6c39 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
6c44 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
6c4f .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
6c5a			.matrix_to_shift:  
6c5a			  
6c5a .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
6c65 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
6c70 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
6c7b 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
6c86 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
6c91			  
6c91			.matrix_to_symbolshift:  
6c91			  
6c91 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
6c9c .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
6ca7 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
6cb2			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
6cb2 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
6cbd .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
6cc8			  
6cc8			  
6cc8			  
6cc8			; mapping for a simple straight through breadboard layout  
6cc8			  
6cc8			;.matrix_to_char:  
6cc8			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6cc8			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
6cc8			;		db "asdfghjkl",KEY_CR,0  
6cc8			;		db "qwertyuiop",0  
6cc8			;		 db "1234567890",0  
6cc8			;.matrix_to_shift:  
6cc8			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
6cc8			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
6cc8			;		db "ASDFGHJKL",KEY_CR,0  
6cc8			;		db "QWERTYUIOP",0  
6cc8			;		 db "!",'"',"#$%^&*()",0  
6cc8			;.matrix_to_symbolshift:  
6cc8			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
6cc8			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
6cc8			;		db "_?*fghjk=",KEY_CR,0  
6cc8			;		db "-/+*[]{}@#",0  
6cc8			;		 db "1234567890",0  
6cc8			  
6cc8			;.matrix_to_char: db "D#0*C987B654A321"  
6cc8			  
6cc8			  
6cc8				  
6cc8			  
6cc8			; add cin and cin_wait  
6cc8			  
6cc8 cd d9 6c		cin_wait: 	call cin  
6ccb						if DEBUG_KEYCINWAIT  
6ccb							push af  
6ccb							  
6ccb							ld hl,key_repeat_ct  
6ccb							ld (hl),a  
6ccb							inc hl  
6ccb							call hexout  
6ccb							ld hl,key_repeat_ct+3  
6ccb							ld a,0  
6ccb							ld (hl),a  
6ccb			  
6ccb							    LD   A, kLCD_Line1+11  
6ccb							    CALL fLCD_Pos       ;Position cursor to location in A  
6ccb							    LD   DE, key_repeat_ct  
6ccb							    ;LD   DE, MsgHello  
6ccb							    CALL fLCD_Str       ;Display string pointed to by DE  
6ccb			  
6ccb			  
6ccb			  
6ccb							pop af  
6ccb						endif  
6ccb fe 00			cp 0  
6ccd 28 f9			jr z, cin_wait   ; block until key press  
6ccf			  
6ccf							if DEBUG_KEYCINWAIT  
6ccf								push af  
6ccf			  
6ccf								ld a, 'A'	  
6ccf								ld hl,key_repeat_ct  
6ccf								ld (hl),a  
6ccf								inc hl  
6ccf								ld a,0  
6ccf								ld (hl),a  
6ccf			  
6ccf								    LD   A, kLCD_Line2+11  
6ccf								    CALL fLCD_Pos       ;Position cursor to location in A  
6ccf								    LD   DE, key_repeat_ct  
6ccf								    ;LD   DE, MsgHello  
6ccf								    CALL fLCD_Str       ;Display string pointed to by DE  
6ccf			  
6ccf							call delay500ms  
6ccf			  
6ccf								pop af  
6ccf							endif  
6ccf f5				push af   ; save key pressed  
6cd0			  
6cd0			.cin_wait1:	  
6cd0							if DEBUG_KEYCINWAIT  
6cd0								push af  
6cd0			  
6cd0								ld a, 'b'	  
6cd0								ld hl,key_repeat_ct  
6cd0								ld (hl),a  
6cd0								inc hl  
6cd0								ld a,0  
6cd0								ld (hl),a  
6cd0			  
6cd0								    LD   A, kLCD_Line2+11  
6cd0								    CALL fLCD_Pos       ;Position cursor to location in A  
6cd0								    LD   DE, key_repeat_ct  
6cd0								    ;LD   DE, MsgHello  
6cd0								    CALL fLCD_Str       ;Display string pointed to by DE  
6cd0			  
6cd0			  
6cd0							call delay500ms  
6cd0			  
6cd0								pop af  
6cd0							endif  
6cd0			  
6cd0 cd d9 6c		call cin  
6cd3 fe 00			cp 0  
6cd5 20 f9			jr nz, .cin_wait1  	; wait for key release  
6cd7			if DEBUG_KEYCINWAIT  
6cd7				push af  
6cd7			  
6cd7				ld a, '3'	  
6cd7				ld hl,key_repeat_ct  
6cd7				ld (hl),a  
6cd7				inc hl  
6cd7				ld a,0  
6cd7				ld (hl),a  
6cd7			  
6cd7			            LD   A, kLCD_Line2+11  
6cd7			            CALL fLCD_Pos       ;Position cursor to location in A  
6cd7			            LD   DE, key_repeat_ct  
6cd7			            ;LD   DE, MsgHello  
6cd7			            CALL fLCD_Str       ;Display string pointed to by DE  
6cd7			  
6cd7			  
6cd7			call delay500ms  
6cd7			  
6cd7				pop af  
6cd7			endif  
6cd7			  
6cd7 f1				pop af   ; get key  
6cd8 c9				ret  
6cd9			  
6cd9			  
6cd9 cd ed 6c		cin: 	call .mtoc  
6cdc			  
6cdc			if DEBUG_KEYCIN  
6cdc				push af  
6cdc				  
6cdc				ld hl,key_repeat_ct  
6cdc				ld (hl),a  
6cdc				inc hl  
6cdc				call hexout  
6cdc				ld hl,key_repeat_ct+3  
6cdc				ld a,0  
6cdc				ld (hl),a  
6cdc			  
6cdc			            LD   A, kLCD_Line3+15  
6cdc			            CALL fLCD_Pos       ;Position cursor to location in A  
6cdc			            LD   DE, key_repeat_ct  
6cdc			            ;LD   DE, MsgHello  
6cdc			            CALL fLCD_Str       ;Display string pointed to by DE  
6cdc			  
6cdc			  
6cdc			call delay500ms  
6cdc			  
6cdc				pop af  
6cdc			endif  
6cdc			  
6cdc			  
6cdc				; no key held  
6cdc fe 00			cp 0  
6cde c8				ret z  
6cdf			  
6cdf			if DEBUG_KEYCIN  
6cdf				push af  
6cdf			  
6cdf				ld a, '1'	  
6cdf				ld hl,key_repeat_ct  
6cdf				ld (hl),a  
6cdf				inc hl  
6cdf				ld a,0  
6cdf				ld (hl),a  
6cdf			  
6cdf			            LD   A, kLCD_Line4+15  
6cdf			            CALL fLCD_Pos       ;Position cursor to location in A  
6cdf			            LD   DE, key_repeat_ct  
6cdf			            ;LD   DE, MsgHello  
6cdf			            CALL fLCD_Str       ;Display string pointed to by DE  
6cdf			  
6cdf			  
6cdf			call delay500ms  
6cdf			  
6cdf				pop af  
6cdf			endif  
6cdf			  
6cdf				; stop key bounce  
6cdf			  
6cdf 32 88 fe			ld (key_held),a		 ; save it  
6ce2 47				ld b, a  
6ce3			  
6ce3 c5			.cina1:	push bc  
6ce4			if DEBUG_KEYCIN  
6ce4				push af  
6ce4			  
6ce4				ld hl,key_repeat_ct  
6ce4				inc hl  
6ce4				call hexout  
6ce4				ld hl,key_repeat_ct+3  
6ce4				ld a,0  
6ce4				ld (hl),a  
6ce4				ld hl,key_repeat_ct  
6ce4				ld a, '2'	  
6ce4				ld (hl),a  
6ce4			  
6ce4			            LD   A, kLCD_Line4+15  
6ce4			            CALL fLCD_Pos       ;Position cursor to location in A  
6ce4			            LD   DE, key_repeat_ct  
6ce4			            ;LD   DE, MsgHello  
6ce4			            CALL fLCD_Str       ;Display string pointed to by DE  
6ce4			  
6ce4				pop af  
6ce4			endif  
6ce4 cd ed 6c			call .mtoc  
6ce7 c1				pop bc  
6ce8 b8				cp b  
6ce9 28 f8			jr z, .cina1  
6ceb 78				ld a,b		  
6cec			if DEBUG_KEYCIN  
6cec				push af  
6cec			  
6cec				ld hl,key_repeat_ct  
6cec				inc hl  
6cec				call hexout  
6cec				ld hl,key_repeat_ct+3  
6cec				ld a,0  
6cec				ld (hl),a  
6cec				ld hl,key_repeat_ct  
6cec				ld a, '3'	  
6cec				ld (hl),a  
6cec			  
6cec			            LD   A, kLCD_Line4+15  
6cec			            CALL fLCD_Pos       ;Position cursor to location in A  
6cec			            LD   DE, key_repeat_ct  
6cec			            ;LD   DE, MsgHello  
6cec			            CALL fLCD_Str       ;Display string pointed to by DE  
6cec			  
6cec				pop af  
6cec			endif  
6cec c9				ret  
6ced			  
6ced			; detect keyboard modifier key press and apply new overlay to the face key held  
6ced			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
6ced			  
6ced			;.cin_map_modifier:   
6ced			;	ld a, (hl)  
6ced			;	and 255  
6ced			;	ret NZ		; modifier key not flagged  
6ced			;  
6ced			;	; get key face  
6ced			;  
6ced			;	ld b,(key_face_held)  
6ced			;  
6ced			;	ld b, key_cols * key_rows  
6ced			;  
6ced			;	push de  
6ced			;	pop hl  
6ced			;  
6ced			;.mmod1: ld a,(hl)   ; get map test  
6ced			;	cp b  
6ced			;	jr z, .mmod2  
6ced			;  
6ced			;  
6ced			;  
6ced			;.mmod2: inc hl    ;   
6ced			;  
6ced			;	  
6ced			;  
6ced			;	  
6ced			;  
6ced			;	ld hl,key_actual_pressed  
6ced			;	ld (hl),a,  
6ced			;	ret  
6ced			  
6ced			; map matrix key held to char on face of key  
6ced			  
6ced			.mtoc:  
6ced			  
6ced			; test decade counter strobes  
6ced			  
6ced			;.decadetest1:  
6ced			  
6ced			; reset counter  
6ced			;ld a, 128  
6ced			;out (portbdata),a  
6ced			  
6ced			  
6ced			;ld b, 5  
6ced			;.dec1:  
6ced			;ld a, 0  
6ced			;out (portbdata),a  
6ced			;call delay1s  
6ced			  
6ced			;ld a, 32  
6ced			;out (portbdata),a  
6ced			;call delay1s  
6ced			;call delay1s  
6ced			;call delay1s  
6ced			;  
6ced			;ld a, 64+32  
6ced			;out (portbdata),a  
6ced			;call delay1s  
6ced			;;djnz .dec1  
6ced			;  
6ced			;jp .decadetest1  
6ced			  
6ced			  
6ced			  
6ced			  
6ced			  
6ced			  
6ced			  
6ced			  
6ced			  
6ced			  
6ced				; scan keyboard matrix and generate raw scan map  
6ced cd 80 6d			call matrix  
6cf0			  
6cf0				; reuse c bit 0 left modifer button - ie shift  
6cf0			        ; reuse c bit 1 for right modifer button - ie symbol shift  
6cf0				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
6cf0			  
6cf0 0e 00			ld c, 0  
6cf2			  
6cf2				; TODO set flags for modifer key presses   
6cf2				; TODO do a search for modifer key...  
6cf2			  
6cf2				;ld hl,keyscan_table_row4  
6cf2 21 e7 fe			ld hl,keyscan_table_row2  
6cf5			  
6cf5 7e				ld a, (hl)  
6cf6 fe 23			cp '#'  
6cf8 20 07			jr nz, .nextmodcheck  
6cfa cb c1			set 0, c  
6cfc 21 5a 6c			ld hl, .matrix_to_shift  
6cff 18 21			jr .dokeymap  
6d01				; TODO for now igonre  
6d01			.nextmodcheck:  
6d01 21 dc fe			ld hl,keyscan_table_row3  
6d04			  
6d04 7e				ld a, (hl)  
6d05 fe 23			cp '#'  
6d07 20 07			jr nz, .nextmodcheck2  
6d09 cb c9			set 1, c   
6d0b 21 91 6c			ld hl, .matrix_to_symbolshift  
6d0e 18 12			jr .dokeymap  
6d10			.nextmodcheck2:  
6d10 21 f0 fe			ld hl,keyscan_table_row2+9    ; right shift  
6d13			  
6d13 7e				ld a, (hl)  
6d14 fe 23			cp '#'  
6d16 20 07			jr nz, .donemodcheck  
6d18 cb c9			set 1, c   
6d1a 21 5a 6c			ld hl, .matrix_to_shift  
6d1d 18 03			jr .dokeymap  
6d1f			  
6d1f				; no modifer found so just map to normal keys  
6d1f				; get mtoc map matrix to respective keys  
6d1f			;	ld hl, .matrix_to_char  
6d1f			;	ld hl, .matrix_to_char  
6d1f			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6d1f			;	ld a, KEY_SHIFT  
6d1f			;	call findchar  
6d1f			;  
6d1f			;	; got offset to key modifer in b  
6d1f			;  
6d1f			;	ld hl,keyscan_table_row5  
6d1f			;  
6d1f			;	ld a,b  
6d1f			;	call addatohl  
6d1f			;	ld a,(hl)  
6d1f			;  
6d1f			;	cp '#'  
6d1f			;	jr nz, .nextmodcheck  
6d1f			;	set 0, c  
6d1f			;	ld hl, .matrix_to_char  
6d1f			;	jr .dokeymap  
6d1f			;	; TODO for now igonre  
6d1f			;.nextmodcheck:  
6d1f			;	ld hl, .matrix_to_symbolshift  
6d1f			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
6d1f			;	ld a, KEY_SYMBOLSHIFT  
6d1f			;	call findchar  
6d1f			;  
6d1f			;  
6d1f			;	; got offset to key modifer in b  
6d1f			;  
6d1f			;	ld hl,keyscan_table_row5  
6d1f			;  
6d1f			;	ld a,b  
6d1f			;	call addatohl  
6d1f			;	ld a,(hl)  
6d1f			;  
6d1f			;	cp '#'  
6d1f			;	jr nz, .donemodcheck  
6d1f			;	set 1, c   
6d1f			;	ld hl, .matrix_to_symbolshift  
6d1f			;	jr .dokeymap  
6d1f			  
6d1f			  
6d1f			  
6d1f			.donemodcheck:  
6d1f				; no modifer found so just map to normal keys  
6d1f				; get mtoc map matrix to respective keys  
6d1f 21 23 6c			ld hl, .matrix_to_char  
6d22			  
6d22			.dokeymap:  
6d22				;ld (key_fa), c   
6d22 cd 3b 6d			call .mapkeys  
6d25			  
6d25			  
6d25			if DEBUG_KEY  
6d25			  
6d25			; Display text on first line  
6d25			            LD   A, kLCD_Line1  
6d25			            CALL fLCD_Pos       ;Position cursor to location in A  
6d25			            LD   DE, keyscan_table_row1  
6d25			            ;LD   DE, MsgHello  
6d25			            CALL fLCD_Str       ;Display string pointed to by DE  
6d25			  
6d25			; Display text on second line  
6d25			            LD   A, kLCD_Line2  
6d25			            CALL fLCD_Pos       ;Position cursor to location in A  
6d25			            LD   DE, keyscan_table_row2  
6d25			            CALL fLCD_Str       ;Display string pointed to by DE  
6d25			            LD   A, kLCD_Line3  
6d25			            CALL fLCD_Pos       ;Position cursor to location in A  
6d25			            LD   DE, keyscan_table_row3  
6d25			            CALL fLCD_Str       ;Display string pointed to by DE  
6d25			            LD   A, kLCD_Line4  
6d25			            CALL fLCD_Pos       ;Position cursor to location in A  
6d25			            LD   DE, keyscan_table_row4  
6d25			            CALL fLCD_Str       ;Display string pointed to by DE  
6d25			            LD   A, kLCD_Line1+10  
6d25			            CALL fLCD_Pos       ;Position cursor to location in A  
6d25			            LD   DE, keyscan_table_row5  
6d25			            CALL fLCD_Str       ;Display string pointed to by DE  
6d25			  
6d25				;call delay250ms  
6d25			endif  
6d25			;	jp testkey  
6d25			  
6d25			; get first char reported  
6d25			  
6d25 21 c6 fe			ld hl,keyscan_table_row5  
6d28			  
6d28				;ld b, 46   ; 30 keys to remap + 8 nulls   
6d28 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6d2a			.findkey:  
6d2a 7e				ld a,(hl)  
6d2b fe 00			cp 0  
6d2d 28 04			jr z, .nextkey  
6d2f fe 7e			cp KEY_MATRIX_NO_PRESS  
6d31 20 06			jr nz, .foundkey  
6d33			.nextkey:  
6d33 23				inc hl  
6d34 10 f4			djnz .findkey  
6d36 3e 00			ld a,0  
6d38 c9				ret  
6d39			.foundkey:  
6d39 7e				ld a,(hl)  
6d3a c9				ret  
6d3b				  
6d3b			  
6d3b			; convert the raw key map given hl for destination key  
6d3b			.mapkeys:  
6d3b 11 c6 fe			ld de,keyscan_table_row5  
6d3e			  
6d3e 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6d40			.remap:  
6d40 1a				ld a,(de)  
6d41 fe 23			cp '#'  
6d43 20 02			jr nz, .remapnext  
6d45				;CALLMONITOR  
6d45 7e				ld a,(hl)  
6d46 12				ld (de),a  
6d47			  
6d47			  
6d47			  
6d47			.remapnext:  
6d47 23				inc hl  
6d48 13				inc de  
6d49 10 f5			djnz .remap  
6d4b				  
6d4b c9				ret  
6d4c			  
6d4c			  
6d4c			  
6d4c			.mtocold2:  
6d4c			  
6d4c			;	; flag if key D is held down and remove from reporting  
6d4c			;	ld bc, .key_map_fd    
6d4c			;	ld hl, keyscan_table  
6d4c			;	ld de, key_fd  
6d4c			;	call .key_shift_hold  
6d4c			;	cp 255  
6d4c			;	jr z, .cinmap  
6d4c			;	; flag if key C is held down and remove from reporting  
6d4c			;	ld bc, .key_map_fc    
6d4c			;	ld hl, keyscan_table+key_cols  
6d4c			;	ld de, key_fc  
6d4c			;	call .key_shift_hold  
6d4c			;	cp 255  
6d4c			;	jr z, .cinmap  
6d4c			;	; flag if key B is held down and remove from reporting  
6d4c			;	ld bc, .key_map_fb    
6d4c			;	ld hl, keyscan_table+(key_cols*2)  
6d4c			;	ld de, key_fb  
6d4c			;	call .key_shift_hold  
6d4c			;	cp 255  
6d4c			;	jr z, .cinmap  
6d4c			;	; flag if key A is held down and remove from reporting  
6d4c			;	ld bc, .key_map_fa    
6d4c			;	ld hl, keyscan_table+(key_cols*3)  
6d4c			;	ld de, key_fa  
6d4c			;	call .key_shift_hold  
6d4c			;	cp 255  
6d4c			;	jr z, .cinmap  
6d4c			  
6d4c 11 23 6c			ld de, .matrix_to_char  
6d4f			  
6d4f			  
6d4f			.cinmap1:   
6d4f				if DEBUG_KEY  
6d4f			            LD   A, kLCD_Line4  
6d4f			            CALL fLCD_Pos       ;Position cursor to location in A  
6d4f					push de  
6d4f			            LD   DE, keyscan_table  
6d4f			            CALL fLCD_Str       ;Display string pointed to by DE  
6d4f					pop de  
6d4f				endif  
6d4f			  
6d4f				; scan key matrix table for any held key  
6d4f			  
6d4f				; de holds either the default matrix or one selected above  
6d4f			  
6d4f 21 93 fe			ld hl, keyscan_table  
6d52 06 32			ld b,key_cols*key_rows  
6d54			  
6d54 7e			.cin11:	ld a,(hl)  
6d55 fe 23			cp '#'  
6d57 28 08			jr z, .cinhit1  
6d59 23				inc hl  
6d5a 13				inc de  
6d5b 05				dec b  
6d5c 20 f6			jr nz, .cin11  
6d5e				; no key found held  
6d5e 3e 00			ld a,0  
6d60 c9				ret  
6d61 d5			.cinhit1: push de  
6d62 e1				pop hl  
6d63 7e				ld a,(hl)  
6d64 c9				ret  
6d65			  
6d65			; flag a control key is held   
6d65			; hl is key pin, de is flag indicator  
6d65			  
6d65			.key_shift_hold1:  
6d65 c5				push bc  
6d66 3e 01			ld a, 1  
6d68 32 c7 fb			ld (cursor_shape),a  
6d6b 06 00			ld b, 0  
6d6d 7e				ld a, (hl)  
6d6e fe 2e			cp '.'  
6d70 28 0a			jr z, .key_shift11  
6d72 06 ff			ld b, 255  
6d74 3e 2b			ld a, '+'    ; hide key from later scans  
6d76 77				ld (hl),a  
6d77 3e 02			ld a, 2  
6d79 32 c7 fb			ld (cursor_shape),a  
6d7c			.key_shift11:  
6d7c				; write flag indicator  
6d7c 78				ld a,b  
6d7d 12				ld (de),a  
6d7e			  
6d7e d1				pop de    ; de now holds the key map ptr  
6d7f c9				ret  
6d80			  
6d80				  
6d80			  
6d80			; scans keyboard matrix and flags key press in memory array	  
6d80				  
6d80			matrix:  
6d80				;call matrix  
6d80				; TODO optimise the code....  
6d80			  
6d80			  
6d80			;ld hl, keyscan_table_row1  
6d80			;ld de, keyscan_table_row1+1  
6d80			;ld bc,46  
6d80			;ld a,KEY_MATRIX_NO_PRESS  
6d80			;ldir  
6d80			  
6d80			  
6d80			  
6d80			; reset counter  
6d80 3e 80		ld a, 128  
6d82 d3 c1		out (portbdata),a  
6d84			  
6d84 06 0a		ld b, 10  
6d86 0e 00		ld c, 0       ; current clock toggle  
6d88			  
6d88			.colscan:  
6d88			  
6d88			; set current column  
6d88			; disable clock enable and set clock low  
6d88			  
6d88			;ld a, 0  
6d88			;out (portbdata),a  
6d88			  
6d88			; For each column scan for switches  
6d88			  
6d88 c5			push bc  
6d89 21 89 fe		ld hl, keyscan_scancol  
6d8c cd 95 6e		call .rowscan  
6d8f c1			pop bc  
6d90			  
6d90			  
6d90			; get back current column  
6d90			  
6d90			; translate the row scan  
6d90			  
6d90			;   
6d90			; row 1  
6d90			  
6d90 78			ld a,b  
6d91			  
6d91 21 fc fe		LD   hl, keyscan_table_row1+10  
6d94			  
6d94 cd de 0e		call subafromhl  
6d97			;call addatohl  
6d97			  
6d97 11 89 fe		ld de, keyscan_scancol  
6d9a			  
6d9a 1a			ld a,(de)  
6d9b 77			ld (hl),a  
6d9c			  
6d9c			  
6d9c			  
6d9c			  
6d9c			; row 2  
6d9c			  
6d9c 78			ld a,b  
6d9d			  
6d9d 21 f1 fe		LD   hl, keyscan_table_row2+10  
6da0			  
6da0			;call addatohl  
6da0 cd de 0e		call subafromhl  
6da3			  
6da3			  
6da3 11 8a fe		ld de, keyscan_scancol+1  
6da6			  
6da6 1a			ld a,(de)  
6da7 77			ld (hl),a  
6da8			  
6da8			  
6da8			; row 3  
6da8			  
6da8 78			ld a,b  
6da9			  
6da9 21 e6 fe		LD   hl, keyscan_table_row3+10  
6dac			  
6dac			;call addatohl  
6dac cd de 0e		call subafromhl  
6daf			  
6daf 11 8b fe		ld de, keyscan_scancol+2  
6db2			  
6db2 1a			ld a,(de)  
6db3 77			ld (hl),a  
6db4			  
6db4			  
6db4			  
6db4			; row 4  
6db4			  
6db4 78			ld a,b  
6db5			  
6db5 21 db fe		LD   hl, keyscan_table_row4+10  
6db8			  
6db8			;call addatohl  
6db8 cd de 0e		call subafromhl  
6dbb			  
6dbb 11 8c fe		ld de, keyscan_scancol+3  
6dbe			  
6dbe 1a			ld a,(de)  
6dbf 77			ld (hl),a  
6dc0			  
6dc0			; row 5  
6dc0			  
6dc0 78			ld a,b  
6dc1			  
6dc1 21 d0 fe		LD   hl, keyscan_table_row5+10  
6dc4			  
6dc4			;call addatohl  
6dc4 cd de 0e		call subafromhl  
6dc7			  
6dc7 11 8d fe		ld de, keyscan_scancol+4  
6dca			  
6dca 1a			ld a,(de)  
6dcb 77			ld (hl),a  
6dcc			  
6dcc			; handshake next column  
6dcc			  
6dcc			  
6dcc 3e 40		ld a, 64  
6dce d3 c1		out (portbdata),a  
6dd0			  
6dd0 3e 00		ld a, 0  
6dd2 d3 c1		out (portbdata),a  
6dd4			  
6dd4			; toggle clk and move to next column  
6dd4			;ld a, 64  
6dd4			;cp c  
6dd4			;  
6dd4			;jr z, .coltoglow  
6dd4			;ld c, a  
6dd4			;jr .coltog  
6dd4			;.coltoglow:  
6dd4			;ld c, 0  
6dd4			;.coltog:  
6dd4			;ld a, c  
6dd4			;out (portbdata),a  
6dd4			  
6dd4 10 b2		djnz .colscan  
6dd6			  
6dd6 3e 0a		ld a,10  
6dd8 21 f2 fe		LD   hl, keyscan_table_row1  
6ddb cd cc 0e		call addatohl  
6dde 3e 00		ld a, 0  
6de0 77			ld (hl), a  
6de1			  
6de1			  
6de1 3e 0a		ld a,10  
6de3 21 e7 fe		LD   hl, keyscan_table_row2  
6de6 cd cc 0e		call addatohl  
6de9 3e 00		ld a, 0  
6deb 77			ld (hl), a  
6dec			  
6dec 3e 0a		ld a,10  
6dee 21 dc fe		LD   hl, keyscan_table_row3  
6df1 cd cc 0e		call addatohl  
6df4 3e 00		ld a, 0  
6df6 77			ld (hl), a  
6df7			  
6df7 3e 0a		ld a,10  
6df9 21 d1 fe		LD   hl, keyscan_table_row4  
6dfc cd cc 0e		call addatohl  
6dff 3e 00		ld a, 0  
6e01 77			ld (hl), a  
6e02			  
6e02 3e 0a		ld a,10  
6e04 21 c6 fe		LD   hl, keyscan_table_row5  
6e07 cd cc 0e		call addatohl  
6e0a 3e 00		ld a, 0  
6e0c 77			ld (hl), a  
6e0d			  
6e0d			if DEBUG_KEY_MATRIX  
6e0d			  
6e0d			; Display text on first line  
6e0d			            LD   A, kLCD_Line1  
6e0d			            CALL fLCD_Pos       ;Position cursor to location in A  
6e0d			            LD   DE, keyscan_table_row1  
6e0d			            ;LD   DE, MsgHello  
6e0d			            CALL fLCD_Str       ;Display string pointed to by DE  
6e0d			  
6e0d			; Display text on second line  
6e0d			            LD   A, kLCD_Line2  
6e0d			            CALL fLCD_Pos       ;Position cursor to location in A  
6e0d			            LD   DE, keyscan_table_row2  
6e0d			            CALL fLCD_Str       ;Display string pointed to by DE  
6e0d			            LD   A, kLCD_Line3  
6e0d			            CALL fLCD_Pos       ;Position cursor to location in A  
6e0d			            LD   DE, keyscan_table_row3  
6e0d			            CALL fLCD_Str       ;Display string pointed to by DE  
6e0d			            LD   A, kLCD_Line4  
6e0d			            CALL fLCD_Pos       ;Position cursor to location in A  
6e0d			            LD   DE, keyscan_table_row4  
6e0d			            CALL fLCD_Str       ;Display string pointed to by DE  
6e0d			            LD   A, kLCD_Line4+10  
6e0d			            CALL fLCD_Pos       ;Position cursor to location in A  
6e0d			            LD   DE, keyscan_table_row5  
6e0d			            CALL fLCD_Str       ;Display string pointed to by DE  
6e0d			  
6e0d			;call delay250ms  
6e0d				jp matrix  
6e0d			endif  
6e0d c9			ret  
6e0e			  
6e0e			; using decade counter....  
6e0e			  
6e0e			  
6e0e			; TODO reset decade counter to start of scan  
6e0e			  
6e0e			; reset 15  
6e0e			; clock 14  
6e0e			; ce 13  
6e0e			  
6e0e			; 1 - q5  
6e0e			; 2 - q1  
6e0e			; 3 - q0  
6e0e			; 4 - q2  
6e0e			; 5 - q6  
6e0e			; 6 - q7  
6e0e			; 7 - q3  
6e0e			; 8 - vss  
6e0e			; 9 - q8  
6e0e			; 10 - q4  
6e0e			; 11 - q9  
6e0e			; 12 - cout  
6e0e			; 16 - vdd  
6e0e			  
6e0e			; clock      ce       reset     output  
6e0e			; 0          x        0         n  
6e0e			; x          1        0         n  
6e0e			; x          x        1         q0  
6e0e			; rising     0        0         n+1  
6e0e			; falling    x        0         n  
6e0e			; x          rising   0         n  
6e0e			; 1          falling  0         x+1  
6e0e			;  
6e0e			; x = dont care, if n < 5 carry = 1 otherwise 0  
6e0e			  
6e0e			;   
6e0e			; reset   
6e0e			; 13=0, 14=0, 15=1 .. 15=0  
6e0e			;  
6e0e			; handshake line  
6e0e			; 14=1.... read line 14=0  
6e0e			  
6e0e			  
6e0e			  
6e0e			  
6e0e			  
6e0e			; TODO hand shake clock for next column scan  
6e0e			; TODO detect each row  
6e0e			  
6e0e			  
6e0e			  
6e0e			  
6e0e			; reset 128  
6e0e			; clock 64  
6e0e			; ce 32  
6e0e			  
6e0e			  
6e0e			.cyclestart:  
6e0e			  
6e0e			; reset counter  
6e0e 3e 80		ld a, 128  
6e10 d3 c1		out (portbdata),a  
6e12			  
6e12			; loop leds  
6e12 06 0a		ld b,10  
6e14			  
6e14			.cycle1:  
6e14 c5			push bc  
6e15 3e 00		ld a, 0  
6e17 d3 c1		out (portbdata),a  
6e19 cd 09 0c		call delay250ms  
6e1c			  
6e1c 3e 40		ld a, 64  
6e1e d3 c1		out (portbdata),a  
6e20 cd 09 0c		call delay250ms  
6e23			  
6e23 3e 00		ld a, 0  
6e25 d3 c1		out (portbdata),a  
6e27 cd 09 0c		call delay250ms  
6e2a			  
6e2a c1			pop bc  
6e2b 10 e7		djnz .cycle1  
6e2d			  
6e2d			  
6e2d 18 df		jr .cyclestart  
6e2f			  
6e2f			  
6e2f			  
6e2f			  
6e2f			  
6e2f			  
6e2f			  
6e2f			  
6e2f			  
6e2f			; map matrix key held to char on face of key  
6e2f			  
6e2f			;.mtocold:  
6e2f			;  
6e2f			;  
6e2f			;; reset counter  
6e2f			;ld a, 128  
6e2f			;out (portbdata),a  
6e2f			;  
6e2f			;  
6e2f			;; scan keyboard row 1  
6e2f			;ld a, 0  
6e2f			;out (portbdata),a  
6e2f			;;ld a, 64  
6e2f			;;out (portbdata),a  
6e2f			;  
6e2f			;  
6e2f			;	ld a, 128  
6e2f			;	ld hl, keyscan_table  
6e2f			;	call .rowscan  
6e2f			;  
6e2f			;;ld a, 0  
6e2f			;;out (portbdata),a  
6e2f			;ld a, 64  
6e2f			;out (portbdata),a  
6e2f			;  
6e2f			;	ld a, 64  
6e2f			;	ld hl, keyscan_table+key_cols  
6e2f			;	call .rowscan  
6e2f			;  
6e2f			;ld a, 0  
6e2f			;out (portbdata),a  
6e2f			;;ld a, 64  
6e2f			;;out (portbdata),a  
6e2f			;	ld a, 32  
6e2f			;	ld hl, keyscan_table+(key_cols*2)  
6e2f			;	call .rowscan  
6e2f			;  
6e2f			;  
6e2f			;;ld a, 0  
6e2f			;;out (portbdata),a  
6e2f			;ld a, 64  
6e2f			;out (portbdata),a  
6e2f			;  
6e2f			;	ld a, 16  
6e2f			;	ld hl, keyscan_table+(key_cols*3)  
6e2f			;	call .rowscan  
6e2f			;  
6e2f			;  
6e2f			;	; flag if key D is held down and remove from reporting  
6e2f			;	ld bc, .key_map_fd    
6e2f			;	ld hl, keyscan_table  
6e2f			;	ld de, key_fd  
6e2f			;	call .key_shift_hold  
6e2f			;	cp 255  
6e2f			;	jr z, .cinmap  
6e2f			;	; flag if key C is held down and remove from reporting  
6e2f			;	ld bc, .key_map_fc    
6e2f			;	ld hl, keyscan_table+key_cols  
6e2f			;	ld de, key_fc  
6e2f			;	call .key_shift_hold  
6e2f			;	cp 255  
6e2f			;	jr z, .cinmap  
6e2f			;	; flag if key B is held down and remove from reporting  
6e2f			;	ld bc, .key_map_fb    
6e2f			;	ld hl, keyscan_table+(key_cols*2)  
6e2f			;	ld de, key_fb  
6e2f			;	call .key_shift_hold  
6e2f			;	cp 255  
6e2f			;	jr z, .cinmap  
6e2f			;	; flag if key A is held down and remove from reporting  
6e2f			;	ld bc, .key_map_fa    
6e2f			;	ld hl, keyscan_table+(key_cols*3)  
6e2f			;	ld de, key_fa  
6e2f			;	call .key_shift_hold  
6e2f			;	cp 255  
6e2f			;	jr z, .cinmap  
6e2f			;  
6e2f			;	ld de, .matrix_to_char  
6e2f			;  
6e2f			;  
6e2f			;.cinmap:   
6e2f			;	if DEBUG_KEY  
6e2f			;            LD   A, kLCD_Line4  
6e2f			;            CALL fLCD_Pos       ;Position cursor to location in A  
6e2f			;		push de  
6e2f			;            LD   DE, keyscan_table  
6e2f			;            CALL fLCD_Str       ;Display string pointed to by DE  
6e2f			;		pop de  
6e2f			;	endif  
6e2f			  
6e2f				; scan key matrix table for any held key  
6e2f			  
6e2f				; de holds either the default matrix or one selected above  
6e2f			  
6e2f			;	ld hl, keyscan_table  
6e2f			;	ld b,key_cols*key_rows  
6e2f			;  
6e2f			;.cin1:	ld a,(hl)  
6e2f			;	cp '#'  
6e2f			;	jr z, .cinhit  
6e2f			;	inc hl  
6e2f			;	inc de  
6e2f			;	dec b  
6e2f			;	jr nz, .cin1  
6e2f			;	; no key found held  
6e2f			;	ld a,0  
6e2f			;	ret  
6e2f			;.cinhit: push de  
6e2f			;	pop hl  
6e2f			;	ld a,(hl)  
6e2f			;	ret  
6e2f			  
6e2f			; flag a control key is held   
6e2f			; hl is key pin, de is flag indicator  
6e2f			  
6e2f			;.key_shift_hold:  
6e2f			;	push bc  
6e2f			;	ld a, 1  
6e2f			;	ld (cursor_shape),a  
6e2f			;	ld b, 0  
6e2f			;	ld a, (hl)  
6e2f			;	cp '.'  
6e2f			;	jr z, .key_shift1  
6e2f			;	ld b, 255  
6e2f			;	ld a, '+'    ; hide key from later scans  
6e2f			;	ld (hl),a  
6e2f			;	ld a, 2  
6e2f			;	ld (cursor_shape),a  
6e2f			;.key_shift1:  
6e2f			;	; write flag indicator  
6e2f			;	ld a,b  
6e2f			;	ld (de),a  
6e2f			;  
6e2f			;	pop de    ; de now holds the key map ptr  
6e2f			;	ret  
6e2f			  
6e2f				  
6e2f				  
6e2f			  
6e2f			  
6e2f			  
6e2f			  
6e2f			  
6e2f			  
6e2f			  
6e2f			  
6e2f			  
6e2f			  
6e2f			  
6e2f			;	push hl  
6e2f			;	push de  
6e2f			;	push bc  
6e2f			;	call keyscan  
6e2f			;	; map key matrix to ascii value of key face  
6e2f			;  
6e2f			;	ld hl, key_face_map  
6e2f			;	ld de, keyscan_table  
6e2f			;  
6e2f			;	; get how many keys to look at  
6e2f			;	ld b, keyscan_table_len  
6e2f			;	  
6e2f			;  
6e2f			;	; at this stage fall out on first key hit  
6e2f			;	; TODO handle multiple key press  
6e2f			;  
6e2f			;map1:	ld a,(hl)  
6e2f			;	cp '#'  
6e2f			;	jr z, keyhit  
6e2f			;	inc hl  
6e2f			;	inc de  
6e2f			;	dec b  
6e2f			;	jr nz, map1  
6e2f			;nohit:	ld a, 0  
6e2f			;	jr keydone  
6e2f			;keyhit: push de  
6e2f			;	pop hl  
6e2f			;	ld a,(hl)  
6e2f			;keydone:  
6e2f			;	push bc  
6e2f			;	push de  
6e2f			; 	push hl  
6e2f			;	ret   
6e2f			;  
6e2f			  
6e2f			  
6e2f			  
6e2f			  
6e2f			; scan physical key matrix  
6e2f			  
6e2f			  
6e2f			;keyscan:  
6e2f			;  
6e2f			;; for each key_row use keyscanr bit mask for out  
6e2f			;; then read in for keyscanc bitmask  
6e2f			;; save result of row scan to keyscantable  
6e2f			;  
6e2f			;; scan keyboard row 1  
6e2f			;  
6e2f			;	ld b, key_rows  
6e2f			;	ld hl, key_scanr  
6e2f			;	ld de, keyscan_table  
6e2f			;  
6e2f			;rowloop:  
6e2f			;  
6e2f			;	ld a,(hl)		; out bit mask to energise keyboard row  
6e2f			;	call rowscan  
6e2f			;	inc hl  
6e2f			;	dec b  
6e2f			;	jr nz, rowloop  
6e2f			;  
6e2f			;	ret  
6e2f			;  
6e2f			;  
6e2f			;; pass a out bitmask, b row number  
6e2f			;arowscan:   
6e2f			;	push bc  
6e2f			;  
6e2f			;	ld d, b  
6e2f			;  
6e2f			;	; calculate buffer location for this row  
6e2f			;  
6e2f			;	ld hl, keyscan_table	  
6e2f			;kbufr:  ld e, key_cols  
6e2f			;kbufc:	inc hl  
6e2f			;	dec e  
6e2f			;	jr nz, kbufc  
6e2f			;	dec d  
6e2f			;	jr nz, kbufr  
6e2f			;  
6e2f			;	; energise row and read columns  
6e2f			;  
6e2f			;	out (portbdata),a  
6e2f			;	in a,(portbdata)  
6e2f			;	ld c,a  
6e2f			;  
6e2f			;  
6e2f			;	; save buffer loc  
6e2f			;  
6e2f			;	ld (keybufptr), hl  
6e2f			;  
6e2f			;	ld hl, key_scanc  
6e2f			;	ld d, key_cols  
6e2f			;  
6e2f			;	; for each column check each bit mask  
6e2f			;  
6e2f			;colloop:  
6e2f			;	  
6e2f			;  
6e2f			;	; reset flags for the row   
6e2f			;  
6e2f			;	ld b,'.'  
6e2f			;	and (hl)  
6e2f			;	jr z, maskskip  
6e2f			;	ld b,'#'  
6e2f			;maskskip:  
6e2f			;	; save  key state  
6e2f			;	push hl  
6e2f			;	ld hl, (keybufptr)  
6e2f			;	ld (hl), b  
6e2f			;	inc hl  
6e2f			;	ld (keybufptr), hl  
6e2f			;  
6e2f			;	; move to next bit mask  
6e2f			;	pop hl  
6e2f			;	inc hl  
6e2f			;  
6e2f			;	dec d  
6e2f			;	jr nz, colloop  
6e2f			;  
6e2f			;	ret  
6e2f			;  
6e2f			;  
6e2f			;;  
6e2f			; lcd functions  
6e2f			;  
6e2f			;  
6e2f			  
6e2f			;if DEBUG_KEY_MATRIX  
6e2f			  
6e2f			; test function to display hardware view of matrix state  
6e2f			  
6e2f			matrixold:  
6e2f			  
6e2f			  
6e2f			  
6e2f			; reset counter  
6e2f 3e 80		ld a, 128  
6e31 d3 c1		out (portbdata),a  
6e33			; scan keyboard row 1  
6e33 3e 00		ld a, 0  
6e35 d3 c1		out (portbdata),a  
6e37			;ld a, 64  
6e37			;out (portbdata),a  
6e37 3e 80			ld a, 128  
6e39 21 f2 fe			ld hl, keyscan_table_row1  
6e3c cd 95 6e			call .rowscan  
6e3f			  
6e3f			;ld a, 0  
6e3f			;out (portbdata),a  
6e3f 3e 40		ld a, 64  
6e41 d3 c1		out (portbdata),a  
6e43 3e 40			ld a, 64  
6e45 21 e7 fe			ld hl, keyscan_table_row2  
6e48 cd 95 6e			call .rowscan  
6e4b			  
6e4b 3e 00		ld a, 0  
6e4d d3 c1		out (portbdata),a  
6e4f			;ld a, 64  
6e4f			;out (portbdata),a  
6e4f 3e 20			ld a, 32  
6e51 21 dc fe			ld hl, keyscan_table_row3  
6e54 cd 95 6e			call .rowscan  
6e57			  
6e57			;ld a, 0  
6e57			;out (portbdata),a  
6e57 3e 40		ld a, 64  
6e59 d3 c1		out (portbdata),a  
6e5b 3e 10			ld a, 16  
6e5d 21 d1 fe			ld hl, keyscan_table_row4  
6e60 cd 95 6e			call .rowscan  
6e63			  
6e63			; Display text on first line  
6e63 3e 00		            LD   A, kLCD_Line1  
6e65 cd 9d 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6e68 11 f2 fe		            LD   DE, keyscan_table_row1  
6e6b			            ;LD   DE, MsgHello  
6e6b cd bf 6a		            CALL fLCD_Str       ;Display string pointed to by DE  
6e6e			  
6e6e			; Display text on second line  
6e6e 3e 28		            LD   A, kLCD_Line2  
6e70 cd 9d 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6e73 11 e7 fe		            LD   DE, keyscan_table_row2  
6e76 cd bf 6a		            CALL fLCD_Str       ;Display string pointed to by DE  
6e79 3e 50		            LD   A, kLCD_Line3  
6e7b cd 9d 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6e7e 11 dc fe		            LD   DE, keyscan_table_row3  
6e81 cd bf 6a		            CALL fLCD_Str       ;Display string pointed to by DE  
6e84 3e 78		            LD   A, kLCD_Line4  
6e86 cd 9d 6a		            CALL fLCD_Pos       ;Position cursor to location in A  
6e89 11 d1 fe		            LD   DE, keyscan_table_row4  
6e8c cd bf 6a		            CALL fLCD_Str       ;Display string pointed to by DE  
6e8f			  
6e8f cd 09 0c			call delay250ms  
6e92 c3 80 6d			jp matrix  
6e95			  
6e95			; pass de as row display flags  
6e95			.rowscan:   
6e95			;	out (portbdata),a  
6e95 db c1			in a,(portbdata)  
6e97 4f				ld c,a  
6e98				; reset flags for the row   
6e98 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6e9a e6 01			and 1  
6e9c 28 02			jr z, .p1on  
6e9e 06 23			ld b,'#'  
6ea0			.p1on:  
6ea0 70				ld (hl), b  
6ea1 23				inc hl  
6ea2			  
6ea2 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6ea4 79				ld a,c  
6ea5 e6 02			and 2  
6ea7			;	bit 0,a  
6ea7 28 02			jr z, .p2on  
6ea9 06 23			ld b,'#'  
6eab			.p2on:  
6eab 70				ld (hl), b  
6eac 23				inc hl  
6ead			;  
6ead 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6eaf 79				ld a,c  
6eb0 e6 04			and 4  
6eb2			;;	bit 0,a  
6eb2 28 02			jr z, .p3on  
6eb4 06 23			ld b,'#'  
6eb6			.p3on:  
6eb6 70				ld (hl), b  
6eb7 23				inc hl  
6eb8			;;  
6eb8 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6eba			;;	bit 0,a  
6eba 79				ld a,c  
6ebb e6 08			and 8  
6ebd 28 02			jr z, .p4on  
6ebf 06 23			ld b,'#'  
6ec1			.p4on:  
6ec1 70				ld (hl), b  
6ec2 23				inc hl  
6ec3			  
6ec3 06 7e			ld b,KEY_MATRIX_NO_PRESS  
6ec5			;;	bit 0,a  
6ec5 79				ld a,c  
6ec6 e6 10			and 16  
6ec8 28 02			jr z, .p5on  
6eca 06 23			ld b,'#'  
6ecc			.p5on:  
6ecc 70				ld (hl), b  
6ecd 23				inc hl  
6ece			; zero term  
6ece 06 00			ld b,0  
6ed0 70				ld (hl), b  
6ed1			  
6ed1 c9			.rscandone: ret  
6ed2			  
6ed2			;addatohl:  
6ed2			;  
6ed2			 ;add   a, l    ; A = A+L  
6ed2			  ;  ld    l, a    ; L = A+L  
6ed2			   ; adc   a, h    ; A = A+L+H+carry  
6ed2			   ; sub   l       ; A = H+carry  
6ed2			   ; ld    h, a    ; H = H+carry  
6ed2			  
6ed2			;ret  
6ed2			; eof  
# End of file firmware_key_5x10.asm
6ed2			;include "firmware_key_4x10.asm" 
6ed2			 
6ed2			heap_size:    equ heap_end - heap_start 
6ed2			;eof 
# End of file os_mega.asm
6ed2
