# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 7c 17			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 ..			buildtime: db   "Build: " 
010a					include "romtimestamp.asm" 
010a ..			db '2025-08-11 21:06' 
# End of file romtimestamp.asm
011a 00				   db 0 
011b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
011f			 
011f			 
011f			 
011f			;        nop  
011f			;        nop 
011f			;;	org 05h		; null out bdos call 
011f			; 
011f			;        nop  
011f			;        nop  
011f			;        nop 
011f			;;	org 08h 
011f			;;; 
011f			;;	jp cin		; rst 8 - char in 
011f			;;; 
011f			; 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;        nop 
011f			;	org 010h 
011f			;; 
011f			;	jp cout		; rest 010h  - char out 
011f			;; 
011f			;	org 01bh   
011f			; 
011f			;	;jp  		; rst 01bh   - write string to display 
011f			;	jp str_at_display 
011f			; 
011f			; 
011f			;	org 020h 
011f			; 
011f			;	; jp		 ; rst 020h - read char at screen location 
011f			; 
011f			;	org 028h 
011f			 
011f				; jp		 ; rst 028h  - storage i/o 
011f			 
011f			; 	org 030h 
011f			;	jp break_point_state 
011f			  
011f			; $30  
011f			; org 038h 
011f			; $38 
011f			 
011f			; TODO any more important entry points to add to jump table for easier coding use? 
011f			 
011f			if BASE_KEV = 1  
011f			 
011f				; need to be at $66 for nmi support 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255,0,255,0,255 
011f				db 0,255 
011f				jp nmi 
011f			endif 
011f			 
011f			include "firmware.asm" 
011f			  
011f			; main constants (used here and in firmware)  
011f			  
011f			; TODO have page 0 of storage as bios  
011f			  
011f			Device_A: equ 0h  
011f			Device_B: equ 040h          ; Sound  
011f			  
011f			if BASE_KEV  
011f			Device_C: equ 080h          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			if BASE_SC114  
011f			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			if BASE_CPM  
011f			; TODO fixup for CPM  
011f			Device_C: equ 080h          ; Storage and ext cart devices  
011f			endif  
011f			  
011f			Device_D: equ 0c0h             ; Keyboard and LCD  
011f			  
011f			; Odd specific debug points for testing hardware dev  
011f			  
011f			;if DEBUG_LEVEL0  
011f			;	include "debug_level0.asm"  
011f			;endif  
011f			;if DEBUG_LEVEL1  
011f			;	include "debug_level1.asm"  
011f			;endif  
011f			;if DEBUG_LEVEL2  
011f			;	include "debug_level2.asm"  
011f			;endif  
011f			  
011f			  
011f			CALLMONITOR: macro  
011f			;	call break_point_state  
011f			; now use the break point debug vector  
011f				call debug_vector  
011f				endm  
011f			  
011f			MALLOC_1: equ 1        ; from dk88   
011f			MALLOC_2: equ 0           ; broke  
011f			MALLOC_3: equ 0           ; really broke  
011f			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011f			  
011f			if BASE_KEV   
011f			;stacksize: equ 256  
011f			; each stack entry is three bytes (type + word)  
011f			stacksize: equ 3*150  
011f			  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 512  
011f			endif  
011f			if BASE_SC114  
011f			;tos:	equ 0f000h  
011f			stacksize: equ 256  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 256  
011f			endif  
011f			  
011f			if BASE_CPM  
011f			;tos:	equ 0f000h  
011f			stacksize: equ 256  
011f			STACK_RET_SIZE: equ 64  
011f			STACK_LOOP_SIZE: equ 128  
011f			STACK_DATA_SIZE: equ 256  
011f			endif  
011f			  
011f			;if STORAGE_SE == 0  
011f			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011f			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011f			;endif  
011f			  
011f			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011f			  
011f			STORE_0_AUTORUN: equ $20  
011f			  
011f			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011f			  
011f			STORE_0_AUTOFILE: equ $21  
011f			STORE_0_BANKRUN: equ $23  
011f			STORE_0_FILERUN: equ $24  
011f			  
011f			; Block 0 offsets for settings  
011f			  
011f			; if set then skip prompt for start up and accept all  
011f			  
011f			STORE_0_QUICKSTART: equ $25  
011f			  
011f			; Blocks where directory table is held  
011f			  
011f			; Reducing the number of entries increases the max file size  
011f			  
011f			;STORE_DIR_START: equ 1  
011f			;STORE_DIR_END: equ 33  
011f			  
011f			; Blocks from where file data is stored  
011f			  
011f			;STORE_DATA_START: equ STORE_DIR_END + 1  
011f			  
011f			; Block indicators (<32 are data files)  
011f			  
011f			;STORE_BLOCK_CFG: equ $8f       ; config block  
011f			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011f			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011f			;STORE_BLOCK_FREE: equ $85       ; data block free  
011f			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011f			  
011f			  
011f			  
011f			; Directory entry flags  
011f			  
011f			;STORE_DIR_FREE: equ 0  
011f			;STORE_DIR_FILE:  equ 1  
011f			  
011f			; Structure offsets to directory entries  
011f			;STORE_DE_FLAG: equ 0  
011f			;STORE_DE_MAXEXT: equ 1  
011f			;STORE_DE_FILENAME: equ 2  
011f			  
011f			; Structure offsets to block 0  
011f			  
011f			;STORE_BK0_ISFOR: equ 1  
011f			;STORE_BK0_LABEL: equ 3  
011f			  
011f			; memory allocation   
011f			  
011f			chk_stund: equ tos+2           ; underflow check word  
011f			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011f			  
011f			; keyscan table needs rows x cols buffer  
011f			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011f			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011f			  
011f			keyscan_table_row1: equ chk_stovr -key_cols-1  
011f			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011f			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011f			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011f			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011f			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011f			keyscan_scancol: equ keyscan_table-key_cols  
011f			;keyscan_table_len: equ key_rows*key_cols  
011f			;keybufptr: equ keyscan_table - 2  
011f			;keysymbol: equ keybufptr - 1  
011f			key_held: equ keyscan_scancol-1	; currently held  
011f			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011f			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011f			key_fa: equ key_repeat_ct -1 ;  
011f			key_fb: equ key_fa -1 ;  
011f			key_fc: equ key_fb -1 ;  
011f			key_fd: equ key_fc -1 ;  
011f			key_face_held: equ key_fd - 1   
011f			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011f			  
011f			hardware_config: equ key_face_held - 10  
011f			  
011f			; hardware config switches  
011f			; TODO add bitmasks on includes for hardware  
011f			; high byte for expansion ids  
011f			;     0000 0000  no card inserted  
011f			;     0000 0001  storage card inserted  
011f			;     0000 0010  spi sd card active  
011f			  
011f			;       
011f			; low byte:  
011f			;     0000 0001   4x4 keypad  
011f			;     0000 0010   full keyboard  
011f			;     0000 0011   spi/ext keyboard  
011f			;     0000 0100   20x4 lcd  
011f			;     0000 1000   40x4 lcd  
011f			;     0000 1100   spi/ext display  
011f			;     0001 0000   ide interface available  
011f			  
011f			hardware_word: equ hardware_config - 2  
011f			  
011f			; debug marker - optional display of debug point on the debug screens  
011f			  
011f			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011f			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011f			  
011f			debug_umark: equ debug_vector - 6  ; current user mark  
011f			debug_mark: equ debug_umark - 4    ; internal word debug points  
011f			  
011f			; input_str vars  
011f			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011f			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011f			input_size: equ input_start -1  ; number of chars  
011f			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011f			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011f			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011f			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011f			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011f			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011f			input_len: equ input_cur_onoff - 5 ; length of current input  
011f			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011f			  
011f			; cursor blink rate  
011f			CUR_BLINK_RATE: equ $09  
011f			;CUR_BLINK_RATE: equ 15  
011f			  
011f			key_actual_pressed: equ input_cursor - 1   
011f			key_symbol: equ key_actual_pressed - 1   
011f			key_shift: equ key_symbol - 1   
011f			  
011f			; Display allocation  
011f			  
011f			;display_rows: equ 4     ; move out to mini and mega files  
011f			;display_cols: equ 20  
011f			  
011f			display_fb_len: equ display_rows*display_cols  
011f			  
011f			; primary frame buffer     
011f			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011f			; working frame buffers  
011f			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011f			display_fb3: equ  display_fb1-display_fb_len - 1  
011f			display_fb2: equ  display_fb3-display_fb_len - 1  
011f			;  
011f			; pointer to active frame buffer  
011f			display_fb_active: equ display_fb2 - 2  
011f			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011f			display_write_tmp: equ display_lcde1e2 - 2  
011f			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011f			  
011f			;  
011f			  
011f			;; can load into de directory  
011f			cursor_col: equ display_active-1  
011f			cursor_row: equ cursor_col-1  
011f			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011f			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011f			  
011f			; maths vars  
011f			  
011f			LFSRSeed: equ cursor_shape -20   
011f			randData: equ LFSRSeed - 2  
011f			xrandc: equ randData - 2  
011f			stackstore: equ xrandc - 2  
011f			seed1: equ  stackstore -2   
011f			seed2: equ seed1 - 2  
011f			  
011f			; cf storage vars  
011f			  
011f			iErrorNum:  equ seed2-1         ;Error number  
011f			iErrorReg:  equ iErrorNum -1              ;Error register  
011f			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011f			  
011f			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011f			  
011f			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011f			  
011f			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011f			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011f			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011f			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011f			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011f			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011f			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011f			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011f			store_tmpid: equ store_tmp3 - 1		; page temp id  
011f			store_tmpext: equ store_tmpid - 1		; file extent temp  
011f			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011f			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011f			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011f			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011f			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011f			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011f			;  
011f			; spi vars  
011f			  
011f			  
011f			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011f			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011f			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011f			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011f			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011f			spi_device_id: equ spi_device - 1    ; human readable bank number  
011f			  
011f			;;;;; forth cli params  
011f			  
011f			; TODO use a different frame buffer for forth???  
011f			  
011f			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011f			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011f			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011f			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011f			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011f			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011f			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011f			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011f			  
011f			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011f			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011f			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011f			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011f			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011f			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011f			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011f			  
011f			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011f			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011f			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011f			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011f			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011f			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011f			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011f			  
011f			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011f			  
011f			; os/forth token vars  
011f			  
011f			os_last_cmd: equ os_var_array-255  
011f			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011f			os_current_i: equ os_cli_cmd-2  
011f			os_cur_ptr: equ os_current_i-2  
011f			os_word_scratch: equ os_cur_ptr-30  
011f			os_tok_len: equ os_word_scratch - 2  
011f			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011f			os_tok_malloc: equ os_tok_ptr - 2  
011f			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011f			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011f			execscratch: equ os_input-255        ; exec cmd eval buffer  
011f			scratch: equ execscratch-255  
011f			  
011f			os_stack_1: equ scratch - 3       ; stack holding area 1  
011f			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
011f			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
011f			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
011f			  
011f			  
011f			; temp locations for new word processing to save on adding more   
011f			  
011f			os_new_malloc: equ os_stack_4-2  
011f			os_new_parse_len: equ os_new_malloc - 2  
011f			os_new_word_len: equ os_new_parse_len - 2  
011f			os_new_work_ptr: equ os_new_word_len - 2  
011f			os_new_src_ptr: equ os_new_work_ptr - 2  
011f			os_new_exec: equ os_new_src_ptr - 2  
011f			os_new_exec_ptr: equ os_new_exec - 2  
011f			  
011f			; resume memory alloocations....  
011f			  
011f			;os_view_disable: equ os_new_exec_ptr - 1  
011f			os_view_af: equ os_new_exec_ptr - 2  
011f			os_view_hl: equ os_view_af -2  
011f			os_view_de: equ os_view_hl - 2  
011f			os_view_bc: equ os_view_de - 2  
011f			  
011f			; stack checksum word  
011f			if DEBUG_STACK_IMB  
011f				curframe: equ  os_view_de - 5  
011f				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011f				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011f			else  
011f				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011f			endif  
011f			  
011f			; with data stack could see memory filled with junk. need some memory management   
011f			; malloc and free entry points added  
011f			  
011f			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011f			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011f			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			;heap_end: equ free_list-1  ; Starting address of heap  
011f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			  
011f			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011f			heap_end: equ chk_word-1  ; Starting address of heap  
011f			  
011f			  
011f			;if BASE_KEV   
011f			;heap_start: equ 0800eh  ; Starting address of heap  
011f			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011f			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011f			;endif  
011f			  
011f			;if BASE_SC114  
011f			;heap_start: equ baseram+15  ; Starting address of heap  
011f			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011f			;endif  
011f			  
011f			  
011f			;;;;  
011f			  
011f			  
011f			; change below to point to last memory alloc above  
011f			topusermem:  equ   heap_start  
011f			  
011f			;if BASE_KEV   
011f			;baseusermem: equ 08000h  
011f			;endif  
011f			  
011f			;if BASE_SC114  
011f			;;aseusermem:     equ    12  
011f			;baseusermem:     equ    prompt  
011f			;;baseusermem:     equ    endofcode  
011f			;endif  
011f			  
011f			  
011f			; **********************************************************************  
011f			; **  Constants  
011f			; **********************************************************************  
011f			  
011f			; Constants used by this code module  
011f			kDataReg:   EQU Device_D           ;PIO port A data register  
011f			kContReg:   EQU Device_D+2           ;PIO port A control register  
011f			  
011f			  
011f			portbdata:  equ Device_D+1    ; port b data  
011f			portbctl:   equ Device_D+3    ; port b control  
011f			  
011f			  
011f			;KEY_SHIFT:   equ 5  
011f			;KEY_SYMBOLSHIFT:  equ 6  
011f			  
011f			KEY_SHIFTLOCK: equ 4  
011f			  
011f			  
011f			KEY_UP: equ 5  
011f			KEY_NEXTWORD: equ 6  
011f			KEY_PREVWORD: equ 7  
011f			KEY_BS: equ 8  
011f			KEY_TAB:  equ 9  
011f			KEY_DOWN: equ 10  
011f			KEY_LEFT: equ 11  
011f			KEY_RIGHT: equ 12  
011f			KEY_CR:   equ 13  
011f			KEY_HOME: equ 14  
011f			KEY_END: equ 15  
011f			  
011f			KEY_F1: equ 16  
011f			KEY_F2: equ 17  
011f			KEY_F3: equ 18  
011f			KEY_F4: equ 19  
011f			  
011f			KEY_F5: equ 20  
011f			KEY_F6: equ 21  
011f			KEY_F7: equ 22  
011f			KEY_F8: equ 23  
011f			  
011f			KEY_F9: equ 24  
011f			KEY_F10: equ 25  
011f			KEY_F11: equ 26  
011f			KEY_F12: equ 27  
011f			  
011f			;if DEBUG_KEY  
011f			;	KEY_MATRIX_NO_PRESS: equ '.'  
011f			;	KEY_SHIFT:   equ '.'  
011f			;	KEY_SYMBOLSHIFT:  equ '.'  
011f			;else  
011f				KEY_SHIFT:   equ '~'  
011f				KEY_SYMBOLSHIFT:  equ '~'  
011f				KEY_MATRIX_NO_PRESS: equ '~'  
011f			;endi  
011f			  
011f			  
011f			  
011f			  
011f			; Macro to make adding debug marks easier  
011f			  
011f			DMARK: macro str  
011f				push af  
011f				ld a, (.dmark)  
011f				ld (debug_mark),a  
011f				ld a, (.dmark+1)  
011f				ld (debug_mark+1),a  
011f				ld a, (.dmark+2)  
011f				ld (debug_mark+2),a  
011f				jr .pastdmark  
011f			.dmark: db str  
011f			.pastdmark: pop af  
011f			  
011f			endm  
011f			  
011f			  
011f			; macro to detect for stack imbalances  
011f			  
011f			include "stackimbal.asm"  
011f			; Macro and code to detect stock imbalances 
011f			 
011f			SPPUSH: equ 0 
011f			 
011f			; Add a stack frame which can be checked before return 
011f			 
011f			STACKFRAME: macro onoff frame1 frame2 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						; save current SP 
011f						exx 
011f			 
011f						ld de, frame1 
011f						ld a, d 
011f						ld hl, curframe 
011f						call hexout 
011f						ld a, e 
011f						ld hl, curframe+2 
011f						call hexout 
011f			  
011f						ld hl, frame1 
011f						push hl 
011f						ld hl, frame2 
011f						push hl 
011f						exx 
011f					endif 
011f					 
011f				endif 
011f			endm 
011f			 
011f			STACKFRAMECHK: macro onoff frame1 frame2 
011f			 
011f					 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						exx 
011f						; check stack frame SP 
011f			 
011f						ld hl, frame2 
011f						pop de   ; frame2 
011f			 
011f						call cmp16 
011f						jr nz, .spnosame 
011f						 
011f			 
011f						ld hl, frame1 
011f						pop de   ; frame1 
011f			 
011f						call cmp16 
011f						jr z, .spfrsame 
011f			 
011f						.spnosame: call showsperror 
011f			 
011f						.spfrsame: nop 
011f			 
011f						exx 
011f					endif 
011f					 
011f				endif 
011f			 
011f			 
011f			endm 
011f			 
011f			 
011f			; for a sub routine, wrap SP collection and comparisons 
011f			 
011f			; Usage: 
011f			; 
011f			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011f			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011f			 
011f			SAVESP: macro onoff storeword 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f						; save current SP 
011f			 
011f						ld (store_sp+(storeword*4)), sp 
011f			 
011f					endif 
011f					 
011f				endif 
011f			 
011f			endm 
011f			 
011f			CHECKSP: macro onoff storeword 
011f			 
011f				if DEBUG_STACK_IMB 
011f					if onoff 
011f			 
011f						; save SP after last save 
011f				 
011f						ld (store_sp+(storeword*4)+2), sp 
011f			 
011f						push hl 
011f						ld hl, store_sp+(storeword*4) 
011f						call check_stack_sp  
011f						pop hl 
011f			 
011f			 
011f					endif 
011f					 
011f				endif 
011f			 
011f			endm 
011f			 
011f			if DEBUG_STACK_IMB 
011f			 
011f			check_stack_sp: 
011f					push de 
011f			 
011f					ld e, (hl) 
011f					inc hl 
011f					ld d, (hl) 
011f					inc hl 
011f			 
011f					push de 
011f			 
011f			 
011f					ld e, (hl) 
011f					inc hl 
011f					ld d, (hl) 
011f					inc hl 
011f			 
011f					pop hl 
011f			 
011f			 
011f					; check to see if the same 
011f			 
011f					call cmp16 
011f					jr z, .spsame 
011f			 
011f					; not same 
011f			 
011f					call showsperror 
011f			.spsame: 
011f			 
011f					pop de 
011f			 
011f					ret 
011f			 
011f			.sperr:  db "Stack imbalance",0 
011f			 
011f			 
011f			showsperror: 
011f			 
011f			 
011f				push hl 
011f				push af 
011f				push de 
011f				call clear_display 
011f				ld de, .sperr 
011f				ld a,0 
011f			;	ld de,os_word_scratch 
011f				call str_at_display 
011f				ld a, display_row_1+17 
011f				ld de, debug_mark 
011f				call str_at_display 
011f				ld a, 0 
011f				ld (curframe+4),a 
011f				ld hl, curframe 
011f				ld de, os_word_scratch 
011f				ld a, display_row_4 
011f				call str_at_display 
011f				call update_display 
011f				;call break_point_state 
011f				call cin_wait 
011f			 
011f			;	ld a, ' ' 
011f			;	ld (os_view_disable), a 
011f				call bp_on 
011f				pop de	 
011f				pop af 
011f				pop hl 
011f				CALLMONITOR 
011f				ret 
011f			 
011f			endif 
011f			 
011f			 
011f			 
011f			; eof 
# End of file stackimbal.asm
011f			  
011f			;TODO macro to calc col and row offset into screen  
011f			  
011f			  
011f			  
011f			hardware_init:  
011f			  
011f				  
011f			  
011f					;ld a, 0  
011f					;ld (hardware_diag), a  
011f			  
011f					; clear all the buffers  
011f			  
011f 21 0a ed				ld hl, display_fb1  
0122 22 c6 eb				ld (display_fb_active), hl  
0125			  
0125 cd c8 0b				call clear_display  
0128			  
0128 21 c8 eb				ld hl, display_fb2  
012b 22 c6 eb				ld (display_fb_active), hl  
012e			  
012e cd c8 0b				call clear_display  
0131			  
0131					; init primary frame buffer area  
0131 21 ab ed				ld hl, display_fb0  
0134 22 c6 eb				ld (display_fb_active), hl  
0137			  
0137 cd c8 0b				call clear_display  
013a			  
013a			  
013a cd 02 5e				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
013d			  
013d cd f0 5e			call key_init  
0140 cd ad 01			call storage_init  
0143			  
0143				; setup malloc functions  
0143			  
0143				if MALLOC_1  
0143 cd ac 11				call  heap_init  
0146				endif  
0146				if MALLOC_4  
0146					call  heap_init  
0146				endif  
0146			  
0146				; init sound hardware if present  
0146			  
0146				if SOUND_ENABLE  
0146					call sound_init  
0146				endif  
0146			  
0146				; lcd test sequence  
0146					  
0146 cd eb 0b			call update_display  
0149 cd 00 0b			call delay1s  
014c 3e 2b			ld a,'+'  
014e cd cd 0b			call fill_display  
0151 cd eb 0b			call update_display  
0154 cd 00 0b			call delay1s  
0157 3e 2a			ld a,'*'  
0159 cd cd 0b			call fill_display  
015c cd eb 0b			call update_display  
015f cd 00 0b			call delay1s  
0162 3e 2d			ld a,'-'  
0164 cd cd 0b			call fill_display  
0167 cd eb 0b			call update_display  
016a cd 00 0b			call delay1s  
016d			  
016d			; boot splash screen  
016d			if display_cols == 20	  
016d			        ld a, display_row_1    
016d			else  
016d 3e 0a		        ld a, display_row_1 +10   
016f			endif  
016f 11 da 16			ld de, prom_bootmsg  
0172 cd db 0b			call str_at_display  
0175 cd eb 0b			call update_display  
0178			  
0178			  
0178 cd 00 0b			call delay1s  
017b cd 00 0b			call delay1s  
017e			if display_cols == 20	  
017e			            LD   A, display_row_3+2  
017e			else  
017e 3e 5c		            LD   A, display_row_3+12  
0180			endif  
0180 11 ef 16			ld de, prom_bootmsg1  
0183 cd db 0b			call str_at_display  
0186			; display debug level  
0186 3e 78		            LD   A, display_row_4  
0188 11 1b 01			ld de, debuglevel  
018b cd db 0b			call str_at_display  
018e			  
018e cd eb 0b			call update_display  
0191 cd 00 0b			call delay1s  
0194 cd 00 0b			call delay1s  
0197			  
0197			;	ld a, display_row_4+3  
0197			;	ld de, bootmsg2  
0197			;	call str_at_display  
0197			;	call update_display  
0197			;	call delay1s  
0197			;	call delay1s  
0197			  
0197			; debug mark setup  
0197			  
0197 3e 5f		ld a, '_'  
0199 32 65 ee		ld (debug_mark),a  
019c 32 66 ee		ld (debug_mark+1),a  
019f 32 67 ee		ld (debug_mark+2),a  
01a2 3e 00		ld a,0  
01a4 32 68 ee		ld (debug_mark+3),a  
01a7 32 69 ee		ld (debug_umark),a  
01aa			  
01aa c9					ret  
01ab			  
01ab			  
01ab			;bootmsg2:	db "Firmware v0.1",0  
01ab			  
01ab			; a 4x20 lcd  
01ab			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
01ab			  
01ab			;if display_cols == 20  
01ab			;	include "firmware_lcd_4x20.asm"  
01ab			;endif  
01ab			  
01ab			;if display_cols == 40  
01ab			;	include "firmware_lcd_4x40.asm"  
01ab			;endif  
01ab			  
01ab			;  
01ab			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
01ab			; TODO abstract the bit bang video out interface for dual display  
01ab			; TODO wire video out to tx pin on rc2014 bus  
01ab			  
01ab			; must supply cin, and cin_wait for low level hardware abstraction   
01ab			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
01ab			; test scancode  
01ab			  
01ab			;;;;;  
01ab			;;;  
01ab			; Moved out to mini and maxi versions  
01ab			;  
01ab			; include "firmware_key_4x4.asm"  
01ab			; using existing 4 wire x 4 resistor array for input  
01ab			;include "firmware_key_4x10.asm"  
01ab			; need to mod the board for 5 rows due to resistor array  
01ab			;include "firmware_key_5x10.asm"  
01ab			  
01ab			; storage hardware interface  
01ab			  
01ab			; use microchip serial eeprom for storage  
01ab			  
01ab			  
01ab			if STORAGE_SE  
01ab				include "firmware_spi.asm"  
01ab				include "firmware_seeprom.asm"  
01ab			else  
01ab			   ; create some stubs for the labels  
01ab c9			se_readbyte: ret  
01ac c9			se_writebyte: ret  
01ad c9			storage_init: ret  
01ae			  
01ae			endif  
01ae			  
01ae			; use cf card for storage - throwing timeout errors. Hardware or software?????  
01ae			;include "firmware_cf.asm"  
01ae			  
01ae			; load up high level storage hardward abstractions  
01ae			include "firmware_storage.asm"  
01ae			 
01ae			; persisent storage hardware abstraction layer  
01ae			 
01ae			 
01ae			 
01ae			; Block 0 on storage is a config state 
01ae			 
01ae			 
01ae			 
01ae			; TODO add read phy block and write phy block functions 
01ae			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
01ae			 
01ae			; Abstraction layer  
01ae			 
01ae			; Logocial block size is same size as physical size - using tape concept 
01ae			 
01ae			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
01ae			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
01ae			 
01ae			 
01ae			 
01ae			; Filesystem layout (Logical layout) 
01ae			; 
01ae			; Block 0 - Bank config  
01ae			; 
01ae			;      Byte - 0 file id counter 
01ae			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
01ae			;      Byte - 3-20 zero terminated bank label 
01ae			; 
01ae			; Block 1 > File storage 
01ae			; 
01ae			;      Byte 0 file id    - block 0 file details 
01ae			;      Byte 1 block id - block 0 is file  
01ae			;            Byte 2-15 - File name 
01ae			; 
01ae			;       - to end of block data 
01ae			; 
01ae			 
01ae			; Get ID for the file named in pointer held HL 
01ae			; Returns ID in HL = 255 if no file found 
01ae			 
01ae			storage_getid: 
01ae			 
01ae 22 6d ea			ld (store_tmp1), hl 
01b1			 
01b1				if DEBUG_STORESE 
01b1					DMARK "SGI" 
01b1 f5				push af  
01b2 3a c6 01			ld a, (.dmark)  
01b5 32 65 ee			ld (debug_mark),a  
01b8 3a c7 01			ld a, (.dmark+1)  
01bb 32 66 ee			ld (debug_mark+1),a  
01be 3a c8 01			ld a, (.dmark+2)  
01c1 32 67 ee			ld (debug_mark+2),a  
01c4 18 03			jr .pastdmark  
01c6 ..			.dmark: db "SGI"  
01c9 f1			.pastdmark: pop af  
01ca			endm  
# End of macro DMARK
01ca					CALLMONITOR 
01ca cd 6f ee			call debug_vector  
01cd				endm  
# End of macro CALLMONITOR
01cd				endif 
01cd				; get block 0 and set counter for number of files to scan 
01cd			 
01cd cd 38 03			call storage_get_block_0 
01d0			 
01d0 3a 74 ea			ld a, (store_page) 
01d3 47				ld b, a 
01d4			 
01d4				; get extent 0 of each file id 
01d4			 
01d4				if DEBUG_STORESE 
01d4					DMARK "SGc" 
01d4 f5				push af  
01d5 3a e9 01			ld a, (.dmark)  
01d8 32 65 ee			ld (debug_mark),a  
01db 3a ea 01			ld a, (.dmark+1)  
01de 32 66 ee			ld (debug_mark+1),a  
01e1 3a eb 01			ld a, (.dmark+2)  
01e4 32 67 ee			ld (debug_mark+2),a  
01e7 18 03			jr .pastdmark  
01e9 ..			.dmark: db "SGc"  
01ec f1			.pastdmark: pop af  
01ed			endm  
# End of macro DMARK
01ed					CALLMONITOR 
01ed cd 6f ee			call debug_vector  
01f0				endm  
# End of macro CALLMONITOR
01f0				endif 
01f0 60			.getloop:	ld h, b 
01f1 2e 00				ld l, 0 
01f3 c5					push bc 
01f4			 
01f4 11 74 ea				ld de, store_page 
01f7				if DEBUG_STORESE 
01f7					DMARK "SGr" 
01f7 f5				push af  
01f8 3a 0c 02			ld a, (.dmark)  
01fb 32 65 ee			ld (debug_mark),a  
01fe 3a 0d 02			ld a, (.dmark+1)  
0201 32 66 ee			ld (debug_mark+1),a  
0204 3a 0e 02			ld a, (.dmark+2)  
0207 32 67 ee			ld (debug_mark+2),a  
020a 18 03			jr .pastdmark  
020c ..			.dmark: db "SGr"  
020f f1			.pastdmark: pop af  
0210			endm  
# End of macro DMARK
0210					CALLMONITOR 
0210 cd 6f ee			call debug_vector  
0213				endm  
# End of macro CALLMONITOR
0213				endif 
0213 cd e0 07				call storage_read 
0216 cd 1e 0e				call ishlzero 
0219 28 2d				jr z, .gap 
021b					 
021b					; have a file name read. Is it one we want. 
021b			 
021b 2a 6d ea				ld hl, (store_tmp1) 
021e 11 77 ea				ld de, store_page+3   ; file name 
0221			 
0221				if DEBUG_STORESE 
0221					DMARK "SGc" 
0221 f5				push af  
0222 3a 36 02			ld a, (.dmark)  
0225 32 65 ee			ld (debug_mark),a  
0228 3a 37 02			ld a, (.dmark+1)  
022b 32 66 ee			ld (debug_mark+1),a  
022e 3a 38 02			ld a, (.dmark+2)  
0231 32 67 ee			ld (debug_mark+2),a  
0234 18 03			jr .pastdmark  
0236 ..			.dmark: db "SGc"  
0239 f1			.pastdmark: pop af  
023a			endm  
# End of macro DMARK
023a					CALLMONITOR 
023a cd 6f ee			call debug_vector  
023d				endm  
# End of macro CALLMONITOR
023d				endif 
023d cd 93 11				call strcmp 
0240 20 06				jr nz, .gap   ; not this one 
0242			 
0242 c1				        pop bc 
0243			 
0243 26 00				ld h, 0 
0245 68					ld l, b 
0246 18 22				jr .getdone 
0248						 
0248			 
0248			 
0248			 
0248			.gap: 
0248				if DEBUG_STORESE 
0248					DMARK "SGg" 
0248 f5				push af  
0249 3a 5d 02			ld a, (.dmark)  
024c 32 65 ee			ld (debug_mark),a  
024f 3a 5e 02			ld a, (.dmark+1)  
0252 32 66 ee			ld (debug_mark+1),a  
0255 3a 5f 02			ld a, (.dmark+2)  
0258 32 67 ee			ld (debug_mark+2),a  
025b 18 03			jr .pastdmark  
025d ..			.dmark: db "SGg"  
0260 f1			.pastdmark: pop af  
0261			endm  
# End of macro DMARK
0261					CALLMONITOR 
0261 cd 6f ee			call debug_vector  
0264				endm  
# End of macro CALLMONITOR
0264				endif 
0264			 
0264 c1					pop bc 
0265 10 89				djnz .getloop 
0267 21 ff 00				ld hl, 255 
026a			.getdone: 
026a			 
026a				if DEBUG_STORESE 
026a					DMARK "SGe" 
026a f5				push af  
026b 3a 7f 02			ld a, (.dmark)  
026e 32 65 ee			ld (debug_mark),a  
0271 3a 80 02			ld a, (.dmark+1)  
0274 32 66 ee			ld (debug_mark+1),a  
0277 3a 81 02			ld a, (.dmark+2)  
027a 32 67 ee			ld (debug_mark+2),a  
027d 18 03			jr .pastdmark  
027f ..			.dmark: db "SGe"  
0282 f1			.pastdmark: pop af  
0283			endm  
# End of macro DMARK
0283					CALLMONITOR 
0283 cd 6f ee			call debug_vector  
0286				endm  
# End of macro CALLMONITOR
0286				endif 
0286			 
0286 c9				ret 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			 
0287			; Read Block 
0287			; ---------- 
0287			; 
0287			; With current bank 
0287			;  
0287			; Get block number to read 
0287			; Load physical blocks starting at start block into buffer 
0287			 
0287			; de points to buffer to use 
0287			; hl holds logical block number  
0287			 
0287			storage_read_block: 
0287			 
0287				; TODO bank selection 
0287			 
0287				; for each of the physical blocks read it into the buffer 
0287 06 40			ld b, STORE_BLOCK_PHY 
0289			 
0289				if DEBUG_STORESE 
0289 d5					push de 
028a				endif 
028a				 
028a			.rl1:    
028a			 
028a				; read physical block at hl into de 
028a			        ; increment hl and de to next read position on exit 
028a			 
028a e5				push hl 
028b d5				push de	 
028c c5				push bc 
028d			;	if DEBUG_STORESE 
028d			;		push af 
028d			;		ld a, 'R' 
028d			;		ld (debug_mark),a 
028d			;		pop af 
028d			;		CALLMONITOR 
028d			;	endif 
028d cd ab 01			call se_readbyte 
0290			;	if DEBUG_STORESE 
0290			;		ld a,(spi_portbyte) 
0290			;		ld l, a 
0290			;		push af 
0290			;		ld a, '1' 
0290			;		ld (debug_mark),a 
0290			;		pop af 
0290			;		CALLMONITOR 
0290			;	endif 
0290 c1				pop bc 
0291 d1				pop de 
0292 e1				pop hl 
0293 12				ld (de),a 
0294 23				inc hl 
0295 13				inc de 
0296			 
0296			;	if DEBUG_STORESE 
0296			;		push af 
0296			;		ld a, 'r' 
0296			;		ld (debug_mark),a 
0296			;		pop af 
0296			;		CALLMONITOR 
0296			;	endif 
0296			 
0296 10 f2			djnz .rl1 
0298			 
0298				if DEBUG_STORESE 
0298					DMARK "SRB" 
0298 f5				push af  
0299 3a ad 02			ld a, (.dmark)  
029c 32 65 ee			ld (debug_mark),a  
029f 3a ae 02			ld a, (.dmark+1)  
02a2 32 66 ee			ld (debug_mark+1),a  
02a5 3a af 02			ld a, (.dmark+2)  
02a8 32 67 ee			ld (debug_mark+2),a  
02ab 18 03			jr .pastdmark  
02ad ..			.dmark: db "SRB"  
02b0 f1			.pastdmark: pop af  
02b1			endm  
# End of macro DMARK
02b1 d1					pop de 
02b2			; 
02b2			;		push af 
02b2			;		ld a, 'R' 
02b2			;		ld (debug_mark),a 
02b2			;		pop af 
02b2					CALLMONITOR 
02b2 cd 6f ee			call debug_vector  
02b5				endm  
# End of macro CALLMONITOR
02b5				endif 
02b5 c9				ret	 
02b6				 
02b6			 
02b6			; File Size 
02b6			; --------- 
02b6			; 
02b6			;   hl file id 
02b6			; 
02b6			;  returns in hl the number of blocks 
02b6			 
02b6			storage_file_size: 
02b6 5d				ld e, l 
02b7 16 00			ld d, 0 
02b9 21 40 00			ld hl, STORE_BLOCK_PHY 
02bc					if DEBUG_FORTH_WORDS 
02bc						DMARK "SIZ" 
02bc f5				push af  
02bd 3a d1 02			ld a, (.dmark)  
02c0 32 65 ee			ld (debug_mark),a  
02c3 3a d2 02			ld a, (.dmark+1)  
02c6 32 66 ee			ld (debug_mark+1),a  
02c9 3a d3 02			ld a, (.dmark+2)  
02cc 32 67 ee			ld (debug_mark+2),a  
02cf 18 03			jr .pastdmark  
02d1 ..			.dmark: db "SIZ"  
02d4 f1			.pastdmark: pop af  
02d5			endm  
# End of macro DMARK
02d5						CALLMONITOR 
02d5 cd 6f ee			call debug_vector  
02d8				endm  
# End of macro CALLMONITOR
02d8					endif 
02d8 cd ba 05			call storage_findnextid 
02db			 
02db cd 1e 0e			call ishlzero 
02de			;	ld a, l 
02de			;	add h 
02de			;	cp 0 
02de c8				ret z			; block not found so EOF 
02df			 
02df 11 74 ea			ld de, store_page 
02e2 cd 87 02			call storage_read_block 
02e5			 
02e5 3a 76 ea			ld a, (store_page+2)	 ; get extent count 
02e8 6f				ld l, a 
02e9 26 00			ld h, 0 
02eb c9			 	ret 
02ec			 
02ec			 
02ec			; Write Block 
02ec			; ----------- 
02ec			; 
02ec			; With current bank 
02ec			;  
02ec			; Get block number to write 
02ec			; Write physical blocks starting at start block from buffer 
02ec			  
02ec			storage_write_block: 
02ec				; TODO bank selection 
02ec			 
02ec				; for each of the physical blocks read it into the buffer 
02ec 06 40			ld b, STORE_BLOCK_PHY 
02ee			 
02ee				if DEBUG_STORESE 
02ee					DMARK "SWB" 
02ee f5				push af  
02ef 3a 03 03			ld a, (.dmark)  
02f2 32 65 ee			ld (debug_mark),a  
02f5 3a 04 03			ld a, (.dmark+1)  
02f8 32 66 ee			ld (debug_mark+1),a  
02fb 3a 05 03			ld a, (.dmark+2)  
02fe 32 67 ee			ld (debug_mark+2),a  
0301 18 03			jr .pastdmark  
0303 ..			.dmark: db "SWB"  
0306 f1			.pastdmark: pop af  
0307			endm  
# End of macro DMARK
0307			 
0307					;push af 
0307					;ld a, 'W' 
0307					;ld (debug_mark),a 
0307					;pop af 
0307					CALLMONITOR 
0307 cd 6f ee			call debug_vector  
030a				endm  
# End of macro CALLMONITOR
030a				endif 
030a			 
030a			; might not be working 
030a			;	call se_writepage 
030a			 
030a			;	ret 
030a			; 
030a			 
030a			 
030a			 
030a			.wl1:    
030a			 
030a				; read physical block at hl into de 
030a			        ; increment hl and de to next read position on exit 
030a			 
030a e5				push hl 
030b d5				push de	 
030c c5				push bc 
030d 1a				ld a,(de) 
030e				;if DEBUG_STORESE 
030e			;		push af 
030e			;		ld a, 'W' 
030e			;		ld (debug_mark),a 
030e			;		pop af 
030e			;		CALLMONITOR 
030e			;	endif 
030e cd ac 01			call se_writebyte 
0311			;	call delay250ms 
0311 00				nop 
0312 00				nop 
0313 00				nop 
0314			;	if DEBUG_STORESE 
0314			;		push af 
0314			;		ld a, 'w' 
0314			;		ld (debug_mark),a 
0314			;		pop af 
0314			;		CALLMONITOR 
0314			;	endif 
0314 c1				pop bc 
0315 d1				pop de 
0316 e1				pop hl 
0317 23				inc hl 
0318 13				inc de 
0319			 
0319			 
0319 10 ef			djnz .wl1 
031b			 
031b				if DEBUG_STORESE 
031b					DMARK "SW2" 
031b f5				push af  
031c 3a 30 03			ld a, (.dmark)  
031f 32 65 ee			ld (debug_mark),a  
0322 3a 31 03			ld a, (.dmark+1)  
0325 32 66 ee			ld (debug_mark+1),a  
0328 3a 32 03			ld a, (.dmark+2)  
032b 32 67 ee			ld (debug_mark+2),a  
032e 18 03			jr .pastdmark  
0330 ..			.dmark: db "SW2"  
0333 f1			.pastdmark: pop af  
0334			endm  
# End of macro DMARK
0334			 
0334					;push af 
0334					;ld a, 'W' 
0334					;ld (debug_mark),a 
0334					;pop af 
0334					CALLMONITOR 
0334 cd 6f ee			call debug_vector  
0337				endm  
# End of macro CALLMONITOR
0337				endif 
0337 c9				ret	 
0338			 
0338			; Init bank 
0338			; --------- 
0338			; 
0338			; With current bank 
0338			; 
0338			; Setup block 0 config 
0338			;     Set 0 file id counter 
0338			;     Set formatted byte pattern 
0338			;     Zero out bank label 
0338			;      
0338			; For every logical block write 0-1 byte as null 
0338			 
0338			storage_get_block_0: 
0338			 
0338				; TODO check presence 
0338			 
0338				; get block 0 config 
0338			 
0338 21 00 00			ld hl, 0 
033b 11 74 ea			ld de, store_page 
033e cd 87 02			call storage_read_block 
0341			 
0341				if DEBUG_STORESE 
0341					DMARK "SB0" 
0341 f5				push af  
0342 3a 56 03			ld a, (.dmark)  
0345 32 65 ee			ld (debug_mark),a  
0348 3a 57 03			ld a, (.dmark+1)  
034b 32 66 ee			ld (debug_mark+1),a  
034e 3a 58 03			ld a, (.dmark+2)  
0351 32 67 ee			ld (debug_mark+2),a  
0354 18 03			jr .pastdmark  
0356 ..			.dmark: db "SB0"  
0359 f1			.pastdmark: pop af  
035a			endm  
# End of macro DMARK
035a 11 74 ea				ld de, store_page 
035d			;		push af 
035d			;		ld a, 'i' 
035d			;		ld (debug_mark),a 
035d			;		pop af 
035d					CALLMONITOR 
035d cd 6f ee			call debug_vector  
0360				endm  
# End of macro CALLMONITOR
0360				endif 
0360			 
0360				; is this area formatted? 
0360			 
0360			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0360 2a 75 ea			ld hl, (store_page+1) 
0363 3e 80			ld a,0x80 
0365 bd				cp l 
0366 20 22			jr nz, .ininotformatted 
0368				; do a double check 
0368 3e 27			ld a, 0x27 
036a bc				cp h 
036b 20 1d			jr nz, .ininotformatted 
036d			 
036d				; formatted then 
036d			 
036d				if DEBUG_STORESE 
036d					DMARK "SB1" 
036d f5				push af  
036e 3a 82 03			ld a, (.dmark)  
0371 32 65 ee			ld (debug_mark),a  
0374 3a 83 03			ld a, (.dmark+1)  
0377 32 66 ee			ld (debug_mark+1),a  
037a 3a 84 03			ld a, (.dmark+2)  
037d 32 67 ee			ld (debug_mark+2),a  
0380 18 03			jr .pastdmark  
0382 ..			.dmark: db "SB1"  
0385 f1			.pastdmark: pop af  
0386			endm  
# End of macro DMARK
0386					;push af 
0386					;ld a, 'I' 
0386					;ld (debug_mark),a 
0386					;pop af 
0386					CALLMONITOR 
0386 cd 6f ee			call debug_vector  
0389				endm  
# End of macro CALLMONITOR
0389				endif 
0389 c9				ret 
038a			 
038a			.ininotformatted: 
038a				; bank not formatted so poke various bits to make sure 
038a			 
038a				if DEBUG_STORESE 
038a					DMARK "SB2" 
038a f5				push af  
038b 3a 9f 03			ld a, (.dmark)  
038e 32 65 ee			ld (debug_mark),a  
0391 3a a0 03			ld a, (.dmark+1)  
0394 32 66 ee			ld (debug_mark+1),a  
0397 3a a1 03			ld a, (.dmark+2)  
039a 32 67 ee			ld (debug_mark+2),a  
039d 18 03			jr .pastdmark  
039f ..			.dmark: db "SB2"  
03a2 f1			.pastdmark: pop af  
03a3			endm  
# End of macro DMARK
03a3					;push af 
03a3					;ld a, 'f' 
03a3					;ld (debug_mark),a 
03a3					;pop af 
03a3					CALLMONITOR 
03a3 cd 6f ee			call debug_vector  
03a6				endm  
# End of macro CALLMONITOR
03a6				endif 
03a6			 
03a6 cd c3 0a			call storage_clear_page 
03a9			 
03a9 21 74 ea			ld hl, store_page 
03ac 3e 00			ld a, 0 
03ae				 
03ae 77				ld (hl),a   ; reset file counter 
03af			 
03af 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03b2 22 75 ea		 	ld (store_page+1), hl	 
03b5			 
03b5				; set default label 
03b5			 
03b5 21 51 04			ld hl, .defaultbanklabl 
03b8 11 77 ea		 	ld de, store_page+3 
03bb 01 0f 00			ld bc, 15 
03be ed b0			ldir 
03c0			 
03c0				; Append the current bank id 
03c0 21 80 ea			ld hl, store_page+3+9 
03c3 3a 59 ea			ld a, (spi_device_id) 
03c6 77				ld (hl), a 
03c7			 
03c7				; save default page 0 
03c7			 
03c7 21 00 00			ld hl, 0 
03ca 11 74 ea			ld de, store_page 
03cd				if DEBUG_STORESE 
03cd					DMARK "SB3" 
03cd f5				push af  
03ce 3a e2 03			ld a, (.dmark)  
03d1 32 65 ee			ld (debug_mark),a  
03d4 3a e3 03			ld a, (.dmark+1)  
03d7 32 66 ee			ld (debug_mark+1),a  
03da 3a e4 03			ld a, (.dmark+2)  
03dd 32 67 ee			ld (debug_mark+2),a  
03e0 18 03			jr .pastdmark  
03e2 ..			.dmark: db "SB3"  
03e5 f1			.pastdmark: pop af  
03e6			endm  
# End of macro DMARK
03e6			;		push af 
03e6			;		ld a, 'F' 
03e6			;		ld (debug_mark),a 
03e6			;		pop af 
03e6					CALLMONITOR 
03e6 cd 6f ee			call debug_vector  
03e9				endm  
# End of macro CALLMONITOR
03e9				endif 
03e9 cd ec 02			call storage_write_block 
03ec				if DEBUG_STORESE 
03ec					DMARK "SB4" 
03ec f5				push af  
03ed 3a 01 04			ld a, (.dmark)  
03f0 32 65 ee			ld (debug_mark),a  
03f3 3a 02 04			ld a, (.dmark+1)  
03f6 32 66 ee			ld (debug_mark+1),a  
03f9 3a 03 04			ld a, (.dmark+2)  
03fc 32 67 ee			ld (debug_mark+2),a  
03ff 18 03			jr .pastdmark  
0401 ..			.dmark: db "SB4"  
0404 f1			.pastdmark: pop af  
0405			endm  
# End of macro DMARK
0405			;		push af 
0405			;		ld a, '>' 
0405			;		ld (debug_mark),a 
0405			;		pop af 
0405					CALLMONITOR 
0405 cd 6f ee			call debug_vector  
0408				endm  
# End of macro CALLMONITOR
0408				endif 
0408			 
0408 00				nop 
0409 00				nop 
040a 00				nop 
040b			 
040b				; now set 0 in every page to mark as a free block 
040b			 
040b 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
040d 21 40 00			ld hl, STORE_BLOCK_PHY 
0410			 
0410 3e 00		.setmark1:   	ld a,0 
0412 e5					push hl 
0413 c5					push bc 
0414 cd ac 01				call se_writebyte 
0417 3e 0a			ld a, 10 
0419 cd e5 0a			call aDelayInMS 
041c 23				inc hl 
041d cd ac 01				call se_writebyte 
0420 3e 0a			ld a, 10 
0422 cd e5 0a			call aDelayInMS 
0425 2b				dec hl 
0426 c1					pop bc 
0427 e1					pop hl 
0428 3e 40				ld a, STORE_BLOCK_PHY 
042a cd f5 0d				call addatohl 
042d 10 e1				djnz .setmark1 
042f			 
042f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0431 3e 00		.setmark2:   	ld a,0 
0433 e5					push hl 
0434 c5					push bc 
0435 cd ac 01				call se_writebyte 
0438 3e 0a			ld a, 10 
043a cd e5 0a			call aDelayInMS 
043d 23				inc hl 
043e cd ac 01				call se_writebyte 
0441 3e 0a			ld a, 10 
0443 cd e5 0a			call aDelayInMS 
0446 2b				dec hl 
0447 c1					pop bc 
0448 e1					pop hl 
0449 3e 40				ld a, STORE_BLOCK_PHY 
044b cd f5 0d				call addatohl 
044e 10 e1				djnz .setmark2 
0450			 
0450					 
0450			 
0450			 
0450 c9				ret 
0451			 
0451			 
0451			 
0451			 
0451 .. 00		.defaultbanklabl:   db "BankLabel_",0 
045c			 
045c			 
045c			 
045c			; Label Bank 
045c			; ---------- 
045c			; 
045c			; With current bank 
045c			; Read block 0 
045c			; Set label 
045c			; Write block 0 
045c			 
045c			; label str pointer in hl 
045c			 
045c			storage_label:     
045c			 
045c				if DEBUG_STORESE 
045c					DMARK "LBL" 
045c f5				push af  
045d 3a 71 04			ld a, (.dmark)  
0460 32 65 ee			ld (debug_mark),a  
0463 3a 72 04			ld a, (.dmark+1)  
0466 32 66 ee			ld (debug_mark+1),a  
0469 3a 73 04			ld a, (.dmark+2)  
046c 32 67 ee			ld (debug_mark+2),a  
046f 18 03			jr .pastdmark  
0471 ..			.dmark: db "LBL"  
0474 f1			.pastdmark: pop af  
0475			endm  
# End of macro DMARK
0475					CALLMONITOR 
0475 cd 6f ee			call debug_vector  
0478				endm  
# End of macro CALLMONITOR
0478				endif 
0478			 
0478 e5				push hl 
0479			 
0479 cd 38 03			call storage_get_block_0 
047c			 
047c				; set default label 
047c			 
047c e1				pop hl 
047d			 
047d 11 77 ea		 	ld de, store_page+3 
0480 01 0f 00			ld bc, 15 
0483				if DEBUG_STORESE 
0483					DMARK "LB3" 
0483 f5				push af  
0484 3a 98 04			ld a, (.dmark)  
0487 32 65 ee			ld (debug_mark),a  
048a 3a 99 04			ld a, (.dmark+1)  
048d 32 66 ee			ld (debug_mark+1),a  
0490 3a 9a 04			ld a, (.dmark+2)  
0493 32 67 ee			ld (debug_mark+2),a  
0496 18 03			jr .pastdmark  
0498 ..			.dmark: db "LB3"  
049b f1			.pastdmark: pop af  
049c			endm  
# End of macro DMARK
049c					CALLMONITOR 
049c cd 6f ee			call debug_vector  
049f				endm  
# End of macro CALLMONITOR
049f				endif 
049f ed b0			ldir 
04a1				; save default page 0 
04a1			 
04a1 21 00 00			ld hl, 0 
04a4 11 74 ea			ld de, store_page 
04a7				if DEBUG_STORESE 
04a7					DMARK "LBW" 
04a7 f5				push af  
04a8 3a bc 04			ld a, (.dmark)  
04ab 32 65 ee			ld (debug_mark),a  
04ae 3a bd 04			ld a, (.dmark+1)  
04b1 32 66 ee			ld (debug_mark+1),a  
04b4 3a be 04			ld a, (.dmark+2)  
04b7 32 67 ee			ld (debug_mark+2),a  
04ba 18 03			jr .pastdmark  
04bc ..			.dmark: db "LBW"  
04bf f1			.pastdmark: pop af  
04c0			endm  
# End of macro DMARK
04c0					CALLMONITOR 
04c0 cd 6f ee			call debug_vector  
04c3				endm  
# End of macro CALLMONITOR
04c3				endif 
04c3 cd ec 02			call storage_write_block 
04c6			 
04c6 c9				ret 
04c7			 
04c7			 
04c7			 
04c7			; Read Block 0 - Config 
04c7			; --------------------- 
04c7			; 
04c7			; With current bank 
04c7			; Call presence test 
04c7			;    If not present format/init bank  
04c7			; Read block 0  
04c7			;  
04c7			 
04c7			 
04c7			; Dir 
04c7			; --- 
04c7			; 
04c7			; With current bank 
04c7			; Load Block 0 Config 
04c7			; Get max file id number 
04c7			; For each logical block 
04c7			;    Read block read byte 2 
04c7			;      if first block of file 
04c7			;         Display file name 
04c7			;         Display type flags for file 
04c7			;        
04c7			 
04c7			; moving to words as this requires stack control 
04c7			 
04c7			 
04c7			; Delete File 
04c7			; ----------- 
04c7			; 
04c7			; With current bank 
04c7			; 
04c7			; Load Block 0 Config 
04c7			; Get max file id number 
04c7			; For each logical block 
04c7			;    Read block file id 
04c7			;      If first block of file and dont have file id 
04c7			;         if file to delete 
04c7			;         Save file id 
04c7			;         Null file id 
04c7			;         Write this block back 
04c7			;      If file id is one saved 
04c7			;         Null file id 
04c7			;         Write this block back 
04c7			 
04c7			 
04c7			.se_done: 
04c7 e1				pop hl 
04c8 c9				ret 
04c9			 
04c9			storage_erase: 
04c9			 
04c9				; hl contains the file id 
04c9			 
04c9 5d				ld e, l 
04ca 16 00			ld d, 0 
04cc 21 40 00			ld hl, STORE_BLOCK_PHY 
04cf					if DEBUG_FORTH_WORDS 
04cf						DMARK "ERA" 
04cf f5				push af  
04d0 3a e4 04			ld a, (.dmark)  
04d3 32 65 ee			ld (debug_mark),a  
04d6 3a e5 04			ld a, (.dmark+1)  
04d9 32 66 ee			ld (debug_mark+1),a  
04dc 3a e6 04			ld a, (.dmark+2)  
04df 32 67 ee			ld (debug_mark+2),a  
04e2 18 03			jr .pastdmark  
04e4 ..			.dmark: db "ERA"  
04e7 f1			.pastdmark: pop af  
04e8			endm  
# End of macro DMARK
04e8						CALLMONITOR 
04e8 cd 6f ee			call debug_vector  
04eb				endm  
# End of macro CALLMONITOR
04eb					endif 
04eb cd ba 05			call storage_findnextid 
04ee cd 1e 0e			call ishlzero 
04f1 c8				ret z 
04f2			 
04f2 e5				push hl 
04f3			 
04f3				; TODO check file not found 
04f3			 
04f3 11 74 ea			ld de, store_page 
04f6 cd 87 02			call storage_read_block 
04f9			 
04f9 cd 1e 0e			call ishlzero 
04fc ca c7 04			jp z,.se_done 
04ff			 
04ff					if DEBUG_FORTH_WORDS 
04ff						DMARK "ER1" 
04ff f5				push af  
0500 3a 14 05			ld a, (.dmark)  
0503 32 65 ee			ld (debug_mark),a  
0506 3a 15 05			ld a, (.dmark+1)  
0509 32 66 ee			ld (debug_mark+1),a  
050c 3a 16 05			ld a, (.dmark+2)  
050f 32 67 ee			ld (debug_mark+2),a  
0512 18 03			jr .pastdmark  
0514 ..			.dmark: db "ER1"  
0517 f1			.pastdmark: pop af  
0518			endm  
# End of macro DMARK
0518						CALLMONITOR 
0518 cd 6f ee			call debug_vector  
051b				endm  
# End of macro CALLMONITOR
051b					endif 
051b 3a 74 ea			ld a, (store_page)	; get file id 
051e 32 68 ea			ld (store_tmpid), a 
0521			 
0521 3a 76 ea			ld a, (store_page+2)    ; get count of extends 
0524 32 67 ea			ld (store_tmpext), a 
0527			 
0527				; wipe file header 
0527			 
0527 e1				pop hl 
0528 3e 00			ld a, 0 
052a 32 74 ea			ld (store_page), a 
052d 32 75 ea			ld (store_page+1),a 
0530 11 74 ea			ld de, store_page 
0533					if DEBUG_FORTH_WORDS 
0533						DMARK "ER2" 
0533 f5				push af  
0534 3a 48 05			ld a, (.dmark)  
0537 32 65 ee			ld (debug_mark),a  
053a 3a 49 05			ld a, (.dmark+1)  
053d 32 66 ee			ld (debug_mark+1),a  
0540 3a 4a 05			ld a, (.dmark+2)  
0543 32 67 ee			ld (debug_mark+2),a  
0546 18 03			jr .pastdmark  
0548 ..			.dmark: db "ER2"  
054b f1			.pastdmark: pop af  
054c			endm  
# End of macro DMARK
054c						CALLMONITOR 
054c cd 6f ee			call debug_vector  
054f				endm  
# End of macro CALLMONITOR
054f					endif 
054f cd ec 02			call storage_write_block 
0552			 
0552			 
0552				; wipe file extents 
0552			 
0552 3a 67 ea			ld a, (store_tmpext) 
0555 47				ld b, a 
0556			 
0556			.eraext:	  
0556 c5				push bc 
0557			 
0557 21 40 00			ld hl, STORE_BLOCK_PHY 
055a 3a 68 ea			ld a,(store_tmpid) 
055d 5f				ld e, a 
055e 50				ld d, b	 
055f					if DEBUG_FORTH_WORDS 
055f						DMARK "ER3" 
055f f5				push af  
0560 3a 74 05			ld a, (.dmark)  
0563 32 65 ee			ld (debug_mark),a  
0566 3a 75 05			ld a, (.dmark+1)  
0569 32 66 ee			ld (debug_mark+1),a  
056c 3a 76 05			ld a, (.dmark+2)  
056f 32 67 ee			ld (debug_mark+2),a  
0572 18 03			jr .pastdmark  
0574 ..			.dmark: db "ER3"  
0577 f1			.pastdmark: pop af  
0578			endm  
# End of macro DMARK
0578						CALLMONITOR 
0578 cd 6f ee			call debug_vector  
057b				endm  
# End of macro CALLMONITOR
057b					endif 
057b cd ba 05			call storage_findnextid 
057e cd 1e 0e			call ishlzero 
0581 ca c7 04			jp z,.se_done 
0584			 
0584 e5				push hl 
0585 11 74 ea			ld de, store_page 
0588 cd 87 02			call storage_read_block 
058b			 
058b				; free block	 
058b			 
058b 3e 00			ld a, 0 
058d 32 74 ea			ld (store_page), a 
0590 32 75 ea			ld (store_page+1),a 
0593 11 74 ea			ld de, store_page 
0596 e1				pop hl 
0597					if DEBUG_FORTH_WORDS 
0597						DMARK "ER4" 
0597 f5				push af  
0598 3a ac 05			ld a, (.dmark)  
059b 32 65 ee			ld (debug_mark),a  
059e 3a ad 05			ld a, (.dmark+1)  
05a1 32 66 ee			ld (debug_mark+1),a  
05a4 3a ae 05			ld a, (.dmark+2)  
05a7 32 67 ee			ld (debug_mark+2),a  
05aa 18 03			jr .pastdmark  
05ac ..			.dmark: db "ER4"  
05af f1			.pastdmark: pop af  
05b0			endm  
# End of macro DMARK
05b0						CALLMONITOR 
05b0 cd 6f ee			call debug_vector  
05b3				endm  
# End of macro CALLMONITOR
05b3					endif 
05b3 cd ec 02			call storage_write_block 
05b6			 
05b6 c1				pop bc 
05b7 10 9d			djnz .eraext 
05b9			 
05b9 c9				ret 
05ba			 
05ba			 
05ba			; Find Free Block 
05ba			; --------------- 
05ba			; 
05ba			; With current bank 
05ba			;  
05ba			; From given starting logical block 
05ba			;    Read block  
05ba			;    If no file id 
05ba			;         Return block id 
05ba			 
05ba			 
05ba			; hl starting page number 
05ba			; hl contains free page number or zero if no pages free 
05ba			; e contains the file id to locate 
05ba			; d contains the block number 
05ba			 
05ba			; TODO change to find file id and use zero for free block 
05ba			 
05ba			storage_findnextid: 
05ba			 
05ba				; now locate first 0 page to mark as a free block 
05ba			 
05ba 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05bc			;	ld hl, STORE_BLOCK_PHY 
05bc			 
05bc					if DEBUG_FORTH_WORDS 
05bc					DMARK "FNI" 
05bc f5				push af  
05bd 3a d1 05			ld a, (.dmark)  
05c0 32 65 ee			ld (debug_mark),a  
05c3 3a d2 05			ld a, (.dmark+1)  
05c6 32 66 ee			ld (debug_mark+1),a  
05c9 3a d3 05			ld a, (.dmark+2)  
05cc 32 67 ee			ld (debug_mark+2),a  
05cf 18 03			jr .pastdmark  
05d1 ..			.dmark: db "FNI"  
05d4 f1			.pastdmark: pop af  
05d5			endm  
# End of macro DMARK
05d5						CALLMONITOR 
05d5 cd 6f ee			call debug_vector  
05d8				endm  
# End of macro CALLMONITOR
05d8					endif 
05d8			.ff1:   	 
05d8 e5					push hl 
05d9 c5					push bc 
05da d5					push de 
05db cd ab 01				call se_readbyte 
05de 5f					ld e,a 
05df 23					inc hl 
05e0 cd ab 01				call se_readbyte 
05e3 57					ld d, a 
05e4 e1					pop hl 
05e5 e5					push hl 
05e6 cd 13 0e				call cmp16 
05e9 28 49				jr z, .fffound 
05eb			 
05eb d1					pop de 
05ec c1					pop bc 
05ed e1					pop hl 
05ee			 
05ee					; is found? 
05ee					;cp e 
05ee					;ret z 
05ee			 
05ee 3e 40				ld a, STORE_BLOCK_PHY 
05f0 cd f5 0d				call addatohl 
05f3 10 e3				djnz .ff1 
05f5			 
05f5 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05f7			.ff2:   	 
05f7			 
05f7 e5					push hl 
05f8 c5					push bc 
05f9 d5					push de 
05fa cd ab 01				call se_readbyte 
05fd 5f					ld e,a 
05fe 23					inc hl 
05ff cd ab 01				call se_readbyte 
0602 57					ld d, a 
0603			 
0603 e1					pop hl 
0604 e5					push hl 
0605 cd 13 0e				call cmp16 
0608 28 2a				jr z, .fffound 
060a			 
060a d1					pop de 
060b c1					pop bc 
060c e1					pop hl 
060d					; is found? 
060d					;cp e 
060d					;ret z 
060d			 
060d 3e 40				ld a, STORE_BLOCK_PHY 
060f cd f5 0d				call addatohl 
0612 10 e3				djnz .ff2 
0614			 
0614			 
0614					if DEBUG_FORTH_WORDS 
0614					DMARK "FN-" 
0614 f5				push af  
0615 3a 29 06			ld a, (.dmark)  
0618 32 65 ee			ld (debug_mark),a  
061b 3a 2a 06			ld a, (.dmark+1)  
061e 32 66 ee			ld (debug_mark+1),a  
0621 3a 2b 06			ld a, (.dmark+2)  
0624 32 67 ee			ld (debug_mark+2),a  
0627 18 03			jr .pastdmark  
0629 ..			.dmark: db "FN-"  
062c f1			.pastdmark: pop af  
062d			endm  
# End of macro DMARK
062d					;	push af 
062d					;	ld a, 'n' 
062d					;	ld (debug_mark),a 
062d					;	pop af 
062d						CALLMONITOR 
062d cd 6f ee			call debug_vector  
0630				endm  
# End of macro CALLMONITOR
0630					endif 
0630				; no free marks! 
0630 21 00 00				ld hl, 0 
0633 c9				ret 
0634			.fffound: 
0634				 
0634			 
0634 d1					pop de 
0635 c1					pop bc 
0636 e1					pop hl 
0637					if DEBUG_FORTH_WORDS 
0637					DMARK "FNF" 
0637 f5				push af  
0638 3a 4c 06			ld a, (.dmark)  
063b 32 65 ee			ld (debug_mark),a  
063e 3a 4d 06			ld a, (.dmark+1)  
0641 32 66 ee			ld (debug_mark+1),a  
0644 3a 4e 06			ld a, (.dmark+2)  
0647 32 67 ee			ld (debug_mark+2),a  
064a 18 03			jr .pastdmark  
064c ..			.dmark: db "FNF"  
064f f1			.pastdmark: pop af  
0650			endm  
# End of macro DMARK
0650					;	push af 
0650					;	ld a, 'n' 
0650					;	ld (debug_mark),a 
0650					;	pop af 
0650						CALLMONITOR 
0650 cd 6f ee			call debug_vector  
0653				endm  
# End of macro CALLMONITOR
0653					endif 
0653 c9				ret 
0654			 
0654			 
0654			 
0654			; Free Space 
0654			; ---------- 
0654			; 
0654			; With current bank 
0654			; 
0654			; Set block count to zero 
0654			; Starting with first logical block 
0654			;      Find free block  
0654			;      If block id given, increment block count 
0654			; 
0654			;  
0654			 
0654			 
0654			; hl contains count of free blocks 
0654			 
0654			storage_freeblocks: 
0654			 
0654				; now locate first 0 page to mark as a free block 
0654			 
0654 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0656 21 40 00			ld hl, STORE_BLOCK_PHY 
0659 11 00 00			ld de, 0 
065c			 
065c			.fb1:   	 
065c e5					push hl 
065d c5					push bc 
065e d5					push de 
065f cd ab 01				call se_readbyte 
0662 d1					pop de 
0663 c1					pop bc 
0664 e1					pop hl 
0665			 
0665					; is free? 
0665 fe 00				cp 0 
0667 20 01				jr nz, .ff1cont 
0669 13					inc de 
066a			 
066a			.ff1cont: 
066a			 
066a			 
066a 3e 40				ld a, STORE_BLOCK_PHY 
066c cd f5 0d				call addatohl 
066f 10 eb				djnz .fb1 
0671			 
0671 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0673			.fb2:   	 
0673 e5					push hl 
0674 c5					push bc 
0675 d5					push de 
0676 cd ab 01				call se_readbyte 
0679 d1					pop de 
067a c1					pop bc 
067b e1					pop hl 
067c			 
067c					; is free? 
067c fe 00				cp 0 
067e 20 01				jr nz, .ff2cont 
0680 13					inc de 
0681			 
0681			.ff2cont: 
0681			 
0681 3e 40				ld a, STORE_BLOCK_PHY 
0683 cd f5 0d				call addatohl 
0686 10 eb				djnz .fb2 
0688			 
0688 eb				ex de, hl 
0689 c9				ret 
068a			 
068a			; Get File ID 
068a			; ----------- 
068a			; 
068a			; With current bank 
068a			;  
068a			; Load Block 0 Config 
068a			; Get max file id number 
068a			; For each logical block 
068a			;    Read block file id 
068a			;      If first block of file and dont have file id 
068a			;         if file get id and exit 
068a			 
068a			 
068a			 
068a			 
068a			; Create File 
068a			; ----------- 
068a			; 
068a			; With current bank  
068a			; Load Block 0 Config 
068a			; Get max file id number 
068a			; Increment file id number 
068a			; Save Config 
068a			; Find free block 
068a			; Set buffer with file name and file id 
068a			; Write buffer to free block  
068a			 
068a			 
068a			; hl point to file name 
068a			; hl returns file id 
068a			 
068a			; file format: 
068a			; byte 0 - file id 
068a			; byte 1 - extent number 
068a			; byte 2-> data 
068a			 
068a			; format for extent number 0: 
068a			; 
068a			; byte 0 - file id 
068a			; byte 1 - extent 0 
068a			; byte 2 - extent count 
068a			; byte 3 -> file name and meta data 
068a			 
068a			 
068a			storage_create: 
068a				if DEBUG_STORESE 
068a					DMARK "SCR" 
068a f5				push af  
068b 3a 9f 06			ld a, (.dmark)  
068e 32 65 ee			ld (debug_mark),a  
0691 3a a0 06			ld a, (.dmark+1)  
0694 32 66 ee			ld (debug_mark+1),a  
0697 3a a1 06			ld a, (.dmark+2)  
069a 32 67 ee			ld (debug_mark+2),a  
069d 18 03			jr .pastdmark  
069f ..			.dmark: db "SCR"  
06a2 f1			.pastdmark: pop af  
06a3			endm  
# End of macro DMARK
06a3					CALLMONITOR 
06a3 cd 6f ee			call debug_vector  
06a6				endm  
# End of macro CALLMONITOR
06a6				endif 
06a6			 
06a6 e5				push hl		; save file name pointer 
06a7			 
06a7 cd 38 03			call storage_get_block_0 
06aa			 
06aa 3a 74 ea			ld a,(store_page)	; get current file id 
06ad 3c				inc a 
06ae 32 74 ea			ld (store_page),a 
06b1				 
06b1 32 68 ea			ld (store_tmpid),a			; save id 
06b4			 
06b4 21 00 00			ld hl, 0 
06b7 11 74 ea			ld de, store_page 
06ba				if DEBUG_STORESE 
06ba					DMARK "SCw" 
06ba f5				push af  
06bb 3a cf 06			ld a, (.dmark)  
06be 32 65 ee			ld (debug_mark),a  
06c1 3a d0 06			ld a, (.dmark+1)  
06c4 32 66 ee			ld (debug_mark+1),a  
06c7 3a d1 06			ld a, (.dmark+2)  
06ca 32 67 ee			ld (debug_mark+2),a  
06cd 18 03			jr .pastdmark  
06cf ..			.dmark: db "SCw"  
06d2 f1			.pastdmark: pop af  
06d3			endm  
# End of macro DMARK
06d3					CALLMONITOR 
06d3 cd 6f ee			call debug_vector  
06d6				endm  
# End of macro CALLMONITOR
06d6				endif 
06d6 cd ec 02			call storage_write_block	 ; save update 
06d9			 
06d9				if DEBUG_STORESE 
06d9 11 74 ea				ld de, store_page 
06dc					DMARK "SCC" 
06dc f5				push af  
06dd 3a f1 06			ld a, (.dmark)  
06e0 32 65 ee			ld (debug_mark),a  
06e3 3a f2 06			ld a, (.dmark+1)  
06e6 32 66 ee			ld (debug_mark+1),a  
06e9 3a f3 06			ld a, (.dmark+2)  
06ec 32 67 ee			ld (debug_mark+2),a  
06ef 18 03			jr .pastdmark  
06f1 ..			.dmark: db "SCC"  
06f4 f1			.pastdmark: pop af  
06f5			endm  
# End of macro DMARK
06f5					CALLMONITOR 
06f5 cd 6f ee			call debug_vector  
06f8				endm  
# End of macro CALLMONITOR
06f8				endif 
06f8				;  
06f8				 
06f8 21 40 00			ld hl, STORE_BLOCK_PHY 
06fb 11 00 00			ld de, 0 
06fe cd ba 05			call storage_findnextid 
0701			 
0701 22 5f ea			ld (store_tmppageid), hl    ; save page to use  
0704			 
0704				; TODO detect 0 = no spare blocks 
0704			 
0704				; hl now contains the free page to use for the file header page 
0704			 
0704				if DEBUG_STORESE 
0704				DMARK "SCF" 
0704 f5				push af  
0705 3a 19 07			ld a, (.dmark)  
0708 32 65 ee			ld (debug_mark),a  
070b 3a 1a 07			ld a, (.dmark+1)  
070e 32 66 ee			ld (debug_mark+1),a  
0711 3a 1b 07			ld a, (.dmark+2)  
0714 32 67 ee			ld (debug_mark+2),a  
0717 18 03			jr .pastdmark  
0719 ..			.dmark: db "SCF"  
071c f1			.pastdmark: pop af  
071d			endm  
# End of macro DMARK
071d					CALLMONITOR 
071d cd 6f ee			call debug_vector  
0720				endm  
# End of macro CALLMONITOR
0720				endif 
0720			 
0720 22 5f ea			ld (store_tmppageid), hl 
0723				 
0723 3a 68 ea			ld a,(store_tmpid)    ; get file id 
0726			;	ld a, (store_filecache)			; save to cache 
0726			 
0726 32 74 ea			ld (store_page),a    ; set page id 
0729 3e 00			ld a, 0			 ; extent 0 is file header 
072b 32 75 ea			ld (store_page+1), a   ; set file extent 
072e			 
072e 32 76 ea			ld (store_page+2), a   ; extent count for the file 
0731			 
0731			;	inc hl 		; init block 0 of file 
0731			;	inc hl   		; skip file and extent id 
0731			 ;       ld a, 0 
0731			;	ld (hl),a 
0731			;	ld a, (store_filecache+1)  	; save to cache 
0731			 
0731			;	inc hl    ; file name 
0731				 
0731				 
0731 11 77 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0734				if DEBUG_STORESE 
0734					DMARK "SCc" 
0734 f5				push af  
0735 3a 49 07			ld a, (.dmark)  
0738 32 65 ee			ld (debug_mark),a  
073b 3a 4a 07			ld a, (.dmark+1)  
073e 32 66 ee			ld (debug_mark+1),a  
0741 3a 4b 07			ld a, (.dmark+2)  
0744 32 67 ee			ld (debug_mark+2),a  
0747 18 03			jr .pastdmark  
0749 ..			.dmark: db "SCc"  
074c f1			.pastdmark: pop af  
074d			endm  
# End of macro DMARK
074d					CALLMONITOR 
074d cd 6f ee			call debug_vector  
0750				endm  
# End of macro CALLMONITOR
0750				endif 
0750 e1				pop hl    ; get zero term string 
0751 e5				push hl 
0752 3e 00			ld a, 0 
0754 cd 66 11			call strlent 
0757 23				inc hl   ; cover zero term 
0758 06 00			ld b,0 
075a 4d				ld c,l 
075b e1				pop hl 
075c				;ex de, hl 
075c				if DEBUG_STORESE 
075c					DMARK "SCa" 
075c f5				push af  
075d 3a 71 07			ld a, (.dmark)  
0760 32 65 ee			ld (debug_mark),a  
0763 3a 72 07			ld a, (.dmark+1)  
0766 32 66 ee			ld (debug_mark+1),a  
0769 3a 73 07			ld a, (.dmark+2)  
076c 32 67 ee			ld (debug_mark+2),a  
076f 18 03			jr .pastdmark  
0771 ..			.dmark: db "SCa"  
0774 f1			.pastdmark: pop af  
0775			endm  
# End of macro DMARK
0775					;push af 
0775					;ld a, 'a' 
0775					;ld (debug_mark),a 
0775					;pop af 
0775					CALLMONITOR 
0775 cd 6f ee			call debug_vector  
0778				endm  
# End of macro CALLMONITOR
0778				endif 
0778 ed b0			ldir    ; copy zero term string 
077a				if DEBUG_STORESE 
077a					DMARK "SCA" 
077a f5				push af  
077b 3a 8f 07			ld a, (.dmark)  
077e 32 65 ee			ld (debug_mark),a  
0781 3a 90 07			ld a, (.dmark+1)  
0784 32 66 ee			ld (debug_mark+1),a  
0787 3a 91 07			ld a, (.dmark+2)  
078a 32 67 ee			ld (debug_mark+2),a  
078d 18 03			jr .pastdmark  
078f ..			.dmark: db "SCA"  
0792 f1			.pastdmark: pop af  
0793			endm  
# End of macro DMARK
0793					CALLMONITOR 
0793 cd 6f ee			call debug_vector  
0796				endm  
# End of macro CALLMONITOR
0796				endif 
0796			 
0796				; write file header page 
0796			 
0796 2a 5f ea			ld hl,(store_tmppageid) 
0799 11 74 ea			ld de, store_page 
079c				if DEBUG_STORESE 
079c					DMARK "SCb" 
079c f5				push af  
079d 3a b1 07			ld a, (.dmark)  
07a0 32 65 ee			ld (debug_mark),a  
07a3 3a b2 07			ld a, (.dmark+1)  
07a6 32 66 ee			ld (debug_mark+1),a  
07a9 3a b3 07			ld a, (.dmark+2)  
07ac 32 67 ee			ld (debug_mark+2),a  
07af 18 03			jr .pastdmark  
07b1 ..			.dmark: db "SCb"  
07b4 f1			.pastdmark: pop af  
07b5			endm  
# End of macro DMARK
07b5					;push af 
07b5					;ld a, 'b' 
07b5					;ld (debug_mark),a 
07b5					;pop af 
07b5					CALLMONITOR 
07b5 cd 6f ee			call debug_vector  
07b8				endm  
# End of macro CALLMONITOR
07b8				endif 
07b8 cd ec 02			call storage_write_block 
07bb			 
07bb 3a 68 ea			ld a, (store_tmpid) 
07be 6f				ld l, a 
07bf 26 00			ld h,0 
07c1				if DEBUG_STORESE 
07c1					DMARK "SCz" 
07c1 f5				push af  
07c2 3a d6 07			ld a, (.dmark)  
07c5 32 65 ee			ld (debug_mark),a  
07c8 3a d7 07			ld a, (.dmark+1)  
07cb 32 66 ee			ld (debug_mark+1),a  
07ce 3a d8 07			ld a, (.dmark+2)  
07d1 32 67 ee			ld (debug_mark+2),a  
07d4 18 03			jr .pastdmark  
07d6 ..			.dmark: db "SCz"  
07d9 f1			.pastdmark: pop af  
07da			endm  
# End of macro DMARK
07da					CALLMONITOR 
07da cd 6f ee			call debug_vector  
07dd				endm  
# End of macro CALLMONITOR
07dd				endif 
07dd c9				ret 
07de				 
07de			 
07de			 
07de			; 
07de			; Read File 
07de			; 
07de			; h - file id to locate 
07de			; l - extent to locate 
07de			; de - pointer to string to read into 
07de			; 
07de			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07de			 
07de			.sr_fail: 
07de d1				pop de 
07df c9				ret 
07e0			 
07e0			storage_read: 
07e0			 
07e0			 
07e0 d5				push de 
07e1			 
07e1			; TODO BUG the above push is it popped before the RET Z? 
07e1			 
07e1			; TODO how to handle multiple part blocks 
07e1			 
07e1				; locate file extent to read 
07e1			 
07e1 5c				ld e, h 
07e2 55				ld d, l 
07e3			 
07e3			.srext: 
07e3 22 72 ea			ld (store_readptr), hl     ; save the current extent to load 
07e6 ed 53 70 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07ea			 
07ea 21 40 00			ld hl, STORE_BLOCK_PHY 
07ed				if DEBUG_STORESE 
07ed					DMARK "sre" 
07ed f5				push af  
07ee 3a 02 08			ld a, (.dmark)  
07f1 32 65 ee			ld (debug_mark),a  
07f4 3a 03 08			ld a, (.dmark+1)  
07f7 32 66 ee			ld (debug_mark+1),a  
07fa 3a 04 08			ld a, (.dmark+2)  
07fd 32 67 ee			ld (debug_mark+2),a  
0800 18 03			jr .pastdmark  
0802 ..			.dmark: db "sre"  
0805 f1			.pastdmark: pop af  
0806			endm  
# End of macro DMARK
0806					CALLMONITOR 
0806 cd 6f ee			call debug_vector  
0809				endm  
# End of macro CALLMONITOR
0809				endif 
0809 cd ba 05			call storage_findnextid 
080c			 
080c				if DEBUG_STORESE 
080c					DMARK "srf" 
080c f5				push af  
080d 3a 21 08			ld a, (.dmark)  
0810 32 65 ee			ld (debug_mark),a  
0813 3a 22 08			ld a, (.dmark+1)  
0816 32 66 ee			ld (debug_mark+1),a  
0819 3a 23 08			ld a, (.dmark+2)  
081c 32 67 ee			ld (debug_mark+2),a  
081f 18 03			jr .pastdmark  
0821 ..			.dmark: db "srf"  
0824 f1			.pastdmark: pop af  
0825			endm  
# End of macro DMARK
0825					CALLMONITOR 
0825 cd 6f ee			call debug_vector  
0828				endm  
# End of macro CALLMONITOR
0828				endif 
0828 cd 1e 0e			call ishlzero 
082b			;	ld a, l 
082b			;	add h 
082b			;	cp 0 
082b 28 b1			jr z,.sr_fail			; block not found so EOF 
082d			 
082d				; save current address for use by higher level words etc 
082d			 
082d 22 65 ea			ld (store_openaddr),hl 
0830			 
0830			 
0830				; hl contains page number to load 
0830 d1				pop de   ; get storage 
0831 ed 53 70 ea		ld (store_readbuf), de     ; current buffer to load in to 
0835 d5				push de 
0836				if DEBUG_STORESE 
0836					DMARK "srg" 
0836 f5				push af  
0837 3a 4b 08			ld a, (.dmark)  
083a 32 65 ee			ld (debug_mark),a  
083d 3a 4c 08			ld a, (.dmark+1)  
0840 32 66 ee			ld (debug_mark+1),a  
0843 3a 4d 08			ld a, (.dmark+2)  
0846 32 67 ee			ld (debug_mark+2),a  
0849 18 03			jr .pastdmark  
084b ..			.dmark: db "srg"  
084e f1			.pastdmark: pop af  
084f			endm  
# End of macro DMARK
084f					CALLMONITOR 
084f cd 6f ee			call debug_vector  
0852				endm  
# End of macro CALLMONITOR
0852				endif 
0852 cd 87 02			call storage_read_block 
0855			 
0855				; if this a continuation read??? 
0855			 
0855 2a 70 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0858			 
0858 3e 3f			ld a, STORE_BLOCK_PHY-1 
085a cd f5 0d			call addatohl 
085d 7e				ld a,(hl) 
085e fe 00			cp 0 
0860 28 02			jr z, .markiscont 
0862 3e ff			ld a, 255 
0864			 
0864			.markiscont: 
0864 32 67 ea			ld (store_readcont), a 
0867			 
0867				if DEBUG_STORESE 
0867					DMARK "srC" 
0867 f5				push af  
0868 3a 7c 08			ld a, (.dmark)  
086b 32 65 ee			ld (debug_mark),a  
086e 3a 7d 08			ld a, (.dmark+1)  
0871 32 66 ee			ld (debug_mark+1),a  
0874 3a 7e 08			ld a, (.dmark+2)  
0877 32 67 ee			ld (debug_mark+2),a  
087a 18 03			jr .pastdmark  
087c ..			.dmark: db "srC"  
087f f1			.pastdmark: pop af  
0880			endm  
# End of macro DMARK
0880					CALLMONITOR 
0880 cd 6f ee			call debug_vector  
0883				endm  
# End of macro CALLMONITOR
0883				endif 
0883				; only short reads enabled 
0883			 
0883 3a 6f ea			ld a, (store_longread) 
0886 fe 00			cp 0 
0888 ca 55 09			jp z, .readdone 
088b			 
088b			; TODO if block has no zeros then need to read next block  
088b			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
088b			; check last byte of physical block. 
088b			; if not zero then the next block needs to be loaded 
088b			 
088b			 
088b 2a 70 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
088e			 
088e 3e 3f			ld a, STORE_BLOCK_PHY-1 
0890 cd f5 0d			call addatohl 
0893				;dec hl 
0893 7e				ld a,(hl) 
0894				if DEBUG_STORESE 
0894					DMARK "sr?" 
0894 f5				push af  
0895 3a a9 08			ld a, (.dmark)  
0898 32 65 ee			ld (debug_mark),a  
089b 3a aa 08			ld a, (.dmark+1)  
089e 32 66 ee			ld (debug_mark+1),a  
08a1 3a ab 08			ld a, (.dmark+2)  
08a4 32 67 ee			ld (debug_mark+2),a  
08a7 18 03			jr .pastdmark  
08a9 ..			.dmark: db "sr?"  
08ac f1			.pastdmark: pop af  
08ad			endm  
# End of macro DMARK
08ad					CALLMONITOR 
08ad cd 6f ee			call debug_vector  
08b0				endm  
# End of macro CALLMONITOR
08b0				endif 
08b0 fe 00			cp 0 
08b2 ca 55 09			jp z, .readdone 
08b5			 
08b5				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08b5			 
08b5 23				inc hl 
08b6			 
08b6 22 70 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08b9			 
08b9 ed 5b 72 ea		ld de, (store_readptr)     ; save the current extent to load 
08bd			 
08bd eb				ex de, hl 
08be			 
08be				; next ext 
08be			 
08be 23				inc hl 
08bf 22 72 ea			ld  (store_readptr), hl     ; save the current extent to load 
08c2			 
08c2				if DEBUG_STORESE 
08c2					DMARK "sF2" 
08c2 f5				push af  
08c3 3a d7 08			ld a, (.dmark)  
08c6 32 65 ee			ld (debug_mark),a  
08c9 3a d8 08			ld a, (.dmark+1)  
08cc 32 66 ee			ld (debug_mark+1),a  
08cf 3a d9 08			ld a, (.dmark+2)  
08d2 32 67 ee			ld (debug_mark+2),a  
08d5 18 03			jr .pastdmark  
08d7 ..			.dmark: db "sF2"  
08da f1			.pastdmark: pop af  
08db			endm  
# End of macro DMARK
08db					CALLMONITOR 
08db cd 6f ee			call debug_vector  
08de				endm  
# End of macro CALLMONITOR
08de				endif 
08de			 
08de				; get and load block 
08de			 
08de cd ba 05			call storage_findnextid 
08e1			 
08e1				if DEBUG_STORESE 
08e1					DMARK "sf2" 
08e1 f5				push af  
08e2 3a f6 08			ld a, (.dmark)  
08e5 32 65 ee			ld (debug_mark),a  
08e8 3a f7 08			ld a, (.dmark+1)  
08eb 32 66 ee			ld (debug_mark+1),a  
08ee 3a f8 08			ld a, (.dmark+2)  
08f1 32 67 ee			ld (debug_mark+2),a  
08f4 18 03			jr .pastdmark  
08f6 ..			.dmark: db "sf2"  
08f9 f1			.pastdmark: pop af  
08fa			endm  
# End of macro DMARK
08fa					CALLMONITOR 
08fa cd 6f ee			call debug_vector  
08fd				endm  
# End of macro CALLMONITOR
08fd				endif 
08fd cd 1e 0e			call ishlzero 
0900			;	ld a, l 
0900			;	add h 
0900			;	cp 0 
0900 ca de 07			jp z,.sr_fail			; block not found so EOF 
0903				 
0903				; save current address for use by higher level words etc 
0903			 
0903 22 65 ea			ld (store_openaddr),hl 
0906			 
0906 cd 87 02			call storage_read_block 
0909			 
0909				; on a continuation block, we now have the file id and ext in the middle of the block 
0909				; we need to pull everything back  
0909			 
0909 ed 5b 70 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
090d 2a 70 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0910 23				inc hl 
0911 23				inc hl     ; skip id and ext 
0912 01 40 00			ld bc, STORE_BLOCK_PHY 
0915				if DEBUG_STORESE 
0915					DMARK "SR<" 
0915 f5				push af  
0916 3a 2a 09			ld a, (.dmark)  
0919 32 65 ee			ld (debug_mark),a  
091c 3a 2b 09			ld a, (.dmark+1)  
091f 32 66 ee			ld (debug_mark+1),a  
0922 3a 2c 09			ld a, (.dmark+2)  
0925 32 67 ee			ld (debug_mark+2),a  
0928 18 03			jr .pastdmark  
092a ..			.dmark: db "SR<"  
092d f1			.pastdmark: pop af  
092e			endm  
# End of macro DMARK
092e					CALLMONITOR 
092e cd 6f ee			call debug_vector  
0931				endm  
# End of macro CALLMONITOR
0931				endif 
0931 ed b0			ldir     ; copy data 
0933			 
0933				; move the pointer back and pretend we have a full buffer for next recheck 
0933			 
0933 1b				dec de 
0934 1b				dec de 
0935			 
0935			; TODO do pop below now short circuit loop????? 
0935 c1				pop bc     ; get rid of spare de on stack 
0936				if DEBUG_STORESE 
0936					DMARK "SR>" 
0936 f5				push af  
0937 3a 4b 09			ld a, (.dmark)  
093a 32 65 ee			ld (debug_mark),a  
093d 3a 4c 09			ld a, (.dmark+1)  
0940 32 66 ee			ld (debug_mark+1),a  
0943 3a 4d 09			ld a, (.dmark+2)  
0946 32 67 ee			ld (debug_mark+2),a  
0949 18 03			jr .pastdmark  
094b ..			.dmark: db "SR>"  
094e f1			.pastdmark: pop af  
094f			endm  
# End of macro DMARK
094f					CALLMONITOR 
094f cd 6f ee			call debug_vector  
0952				endm  
# End of macro CALLMONITOR
0952				endif 
0952 c3 e3 07			jp .srext 
0955			 
0955			 
0955			 
0955			 
0955			 
0955			.readdone:		 
0955 e1				pop hl 		 ; return start of data to show as not EOF 
0956 23				inc hl   ; past file id 
0957 23				inc hl   ; past ext 
0958				if DEBUG_STORESE 
0958					DMARK "SRe" 
0958 f5				push af  
0959 3a 6d 09			ld a, (.dmark)  
095c 32 65 ee			ld (debug_mark),a  
095f 3a 6e 09			ld a, (.dmark+1)  
0962 32 66 ee			ld (debug_mark+1),a  
0965 3a 6f 09			ld a, (.dmark+2)  
0968 32 67 ee			ld (debug_mark+2),a  
096b 18 03			jr .pastdmark  
096d ..			.dmark: db "SRe"  
0970 f1			.pastdmark: pop af  
0971			endm  
# End of macro DMARK
0971					CALLMONITOR 
0971 cd 6f ee			call debug_vector  
0974				endm  
# End of macro CALLMONITOR
0974				endif 
0974 c9					ret 
0975			 
0975			 
0975			 
0975			; 
0975			; Append File 
0975			; 
0975			; hl - file id to locate 
0975			; de - pointer to (multi block) string to write 
0975			 
0975			.sa_notfound: 
0975 d1				pop de 
0976 c9				ret 
0977			 
0977			 
0977			storage_append: 
0977				; hl -  file id to append to 
0977				; de - string to append 
0977			 
0977 d5				push de 
0978				 
0978				if DEBUG_STORESE 
0978					DMARK "AP1" 
0978 f5				push af  
0979 3a 8d 09			ld a, (.dmark)  
097c 32 65 ee			ld (debug_mark),a  
097f 3a 8e 09			ld a, (.dmark+1)  
0982 32 66 ee			ld (debug_mark+1),a  
0985 3a 8f 09			ld a, (.dmark+2)  
0988 32 67 ee			ld (debug_mark+2),a  
098b 18 03			jr .pastdmark  
098d ..			.dmark: db "AP1"  
0990 f1			.pastdmark: pop af  
0991			endm  
# End of macro DMARK
0991					CALLMONITOR 
0991 cd 6f ee			call debug_vector  
0994				endm  
# End of macro CALLMONITOR
0994				endif 
0994			 
0994 7d				ld a, l 
0995 32 68 ea			ld (store_tmpid), a 
0998			 
0998				; get file header  
0998			 
0998 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
099a 3a 68 ea			ld a, (store_tmpid) 
099d 5f				ld e, a 
099e			 
099e 21 40 00				ld hl, STORE_BLOCK_PHY 
09a1 cd ba 05				call storage_findnextid 
09a4			 
09a4 cd 1e 0e			call ishlzero 
09a7 28 cc			jr z, .sa_notfound 
09a9			 
09a9 22 5f ea			ld (store_tmppageid), hl 
09ac			 
09ac				; TODO handle file id not found 
09ac			 
09ac				if DEBUG_STORESE 
09ac					DMARK "AP2" 
09ac f5				push af  
09ad 3a c1 09			ld a, (.dmark)  
09b0 32 65 ee			ld (debug_mark),a  
09b3 3a c2 09			ld a, (.dmark+1)  
09b6 32 66 ee			ld (debug_mark+1),a  
09b9 3a c3 09			ld a, (.dmark+2)  
09bc 32 67 ee			ld (debug_mark+2),a  
09bf 18 03			jr .pastdmark  
09c1 ..			.dmark: db "AP2"  
09c4 f1			.pastdmark: pop af  
09c5			endm  
# End of macro DMARK
09c5					CALLMONITOR 
09c5 cd 6f ee			call debug_vector  
09c8				endm  
# End of macro CALLMONITOR
09c8				endif 
09c8			 
09c8				; update file extent count 
09c8			 
09c8 11 74 ea			ld de, store_page 
09cb			 
09cb cd 87 02			call storage_read_block 
09ce			 
09ce				if DEBUG_STORESE 
09ce					DMARK "AP3" 
09ce f5				push af  
09cf 3a e3 09			ld a, (.dmark)  
09d2 32 65 ee			ld (debug_mark),a  
09d5 3a e4 09			ld a, (.dmark+1)  
09d8 32 66 ee			ld (debug_mark+1),a  
09db 3a e5 09			ld a, (.dmark+2)  
09de 32 67 ee			ld (debug_mark+2),a  
09e1 18 03			jr .pastdmark  
09e3 ..			.dmark: db "AP3"  
09e6 f1			.pastdmark: pop af  
09e7			endm  
# End of macro DMARK
09e7					CALLMONITOR 
09e7 cd 6f ee			call debug_vector  
09ea				endm  
# End of macro CALLMONITOR
09ea				endif 
09ea			;	ld (store_tmppageid), hl 
09ea			 
09ea 3a 76 ea			ld a, (store_page+2) 
09ed 3c				inc a 
09ee 32 76 ea			ld (store_page+2), a 
09f1 32 67 ea			ld (store_tmpext), a 
09f4				 
09f4				if DEBUG_STORESE 
09f4					DMARK "AP3" 
09f4 f5				push af  
09f5 3a 09 0a			ld a, (.dmark)  
09f8 32 65 ee			ld (debug_mark),a  
09fb 3a 0a 0a			ld a, (.dmark+1)  
09fe 32 66 ee			ld (debug_mark+1),a  
0a01 3a 0b 0a			ld a, (.dmark+2)  
0a04 32 67 ee			ld (debug_mark+2),a  
0a07 18 03			jr .pastdmark  
0a09 ..			.dmark: db "AP3"  
0a0c f1			.pastdmark: pop af  
0a0d			endm  
# End of macro DMARK
0a0d					CALLMONITOR 
0a0d cd 6f ee			call debug_vector  
0a10				endm  
# End of macro CALLMONITOR
0a10				endif 
0a10 2a 5f ea			ld hl, (store_tmppageid) 
0a13 11 74 ea			ld de, store_page 
0a16 cd ec 02			call storage_write_block 
0a19			 
0a19				; find free block 
0a19			 
0a19 11 00 00			ld de, 0			 ; file extent to locate 
0a1c			 
0a1c 21 40 00				ld hl, STORE_BLOCK_PHY 
0a1f cd ba 05				call storage_findnextid 
0a22 cd 1e 0e			call ishlzero 
0a25 ca 75 09			jp z, .sa_notfound 
0a28			 
0a28					; TODO handle no space left 
0a28					 
0a28 22 5f ea				ld (store_tmppageid), hl 
0a2b			 
0a2b				if DEBUG_STORESE 
0a2b					DMARK "AP4" 
0a2b f5				push af  
0a2c 3a 40 0a			ld a, (.dmark)  
0a2f 32 65 ee			ld (debug_mark),a  
0a32 3a 41 0a			ld a, (.dmark+1)  
0a35 32 66 ee			ld (debug_mark+1),a  
0a38 3a 42 0a			ld a, (.dmark+2)  
0a3b 32 67 ee			ld (debug_mark+2),a  
0a3e 18 03			jr .pastdmark  
0a40 ..			.dmark: db "AP4"  
0a43 f1			.pastdmark: pop af  
0a44			endm  
# End of macro DMARK
0a44					CALLMONITOR 
0a44 cd 6f ee			call debug_vector  
0a47				endm  
# End of macro CALLMONITOR
0a47				endif 
0a47					; init the buffer with zeros so we can id if the buffer is full or not 
0a47			 
0a47 e5					push hl 
0a48 c5					push bc 
0a49			 
0a49 21 74 ea				ld hl, store_page 
0a4c 06 40				ld b, STORE_BLOCK_PHY 
0a4e 3e 00				ld a, 0 
0a50 77			.zeroblock:	ld (hl), a 
0a51 23					inc hl 
0a52 10 fc				djnz .zeroblock 
0a54			 
0a54 c1					pop bc 
0a55 e1					pop hl 
0a56			 
0a56					; construct block 
0a56			 
0a56 3a 68 ea				ld a, (store_tmpid) 
0a59 32 74 ea				ld (store_page), a   ; file id 
0a5c 3a 67 ea				ld a, (store_tmpext)   ; extent for this block 
0a5f 32 75 ea				ld (store_page+1), a 
0a62			 
0a62 e1					pop hl    ; get string to write 
0a63 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a65 11 76 ea				ld de, store_page+2 
0a68			 
0a68				if DEBUG_STORESE 
0a68					DMARK "AP5" 
0a68 f5				push af  
0a69 3a 7d 0a			ld a, (.dmark)  
0a6c 32 65 ee			ld (debug_mark),a  
0a6f 3a 7e 0a			ld a, (.dmark+1)  
0a72 32 66 ee			ld (debug_mark+1),a  
0a75 3a 7f 0a			ld a, (.dmark+2)  
0a78 32 67 ee			ld (debug_mark+2),a  
0a7b 18 03			jr .pastdmark  
0a7d ..			.dmark: db "AP5"  
0a80 f1			.pastdmark: pop af  
0a81			endm  
# End of macro DMARK
0a81					CALLMONITOR 
0a81 cd 6f ee			call debug_vector  
0a84				endm  
# End of macro CALLMONITOR
0a84				endif 
0a84			 
0a84			 
0a84			 
0a84					; fill buffer with data until end of string or full block 
0a84			 
0a84 7e			.appd:		ld a, (hl) 
0a85 12					ld (de), a 
0a86 fe 00				cp 0 
0a88 28 04				jr z, .appdone 
0a8a 23					inc hl 
0a8b 13					inc de 
0a8c 10 f6				djnz .appd 
0a8e			 
0a8e e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a8f f5					push af   		; save last byte dumped 
0a90			 
0a90			 
0a90 2a 5f ea			ld hl, (store_tmppageid) 
0a93 11 74 ea			ld de, store_page 
0a96				if DEBUG_STORESE 
0a96					DMARK "AP6" 
0a96 f5				push af  
0a97 3a ab 0a			ld a, (.dmark)  
0a9a 32 65 ee			ld (debug_mark),a  
0a9d 3a ac 0a			ld a, (.dmark+1)  
0aa0 32 66 ee			ld (debug_mark+1),a  
0aa3 3a ad 0a			ld a, (.dmark+2)  
0aa6 32 67 ee			ld (debug_mark+2),a  
0aa9 18 03			jr .pastdmark  
0aab ..			.dmark: db "AP6"  
0aae f1			.pastdmark: pop af  
0aaf			endm  
# End of macro DMARK
0aaf					CALLMONITOR 
0aaf cd 6f ee			call debug_vector  
0ab2				endm  
# End of macro CALLMONITOR
0ab2				endif 
0ab2 cd ec 02				call storage_write_block 
0ab5			 
0ab5			 
0ab5				; was that a full block of data written? 
0ab5				; any more to write out? 
0ab5			 
0ab5				; if yes then set vars and jump to start of function again 
0ab5			 
0ab5 f1					pop af 
0ab6 d1					pop de 
0ab7			 
0ab7 fe 00				cp 0		 ; no, string was fully written 
0ab9 c8					ret z 
0aba			 
0aba					; setup vars for next cycle 
0aba			 
0aba 3a 68 ea				ld a, (store_tmpid) 
0abd 6f					ld l, a 
0abe 26 00				ld h, 0 
0ac0			 
0ac0 c3 77 09			 	jp storage_append	 ; yes, need to write out some more 
0ac3			 
0ac3			 
0ac3			 
0ac3			 
0ac3			 
0ac3			 
0ac3			 
0ac3			if DEBUG_STORECF 
0ac3			storageput:	 
0ac3					ret 
0ac3			storageread: 
0ac3					ld hl, store_page 
0ac3					ld b, 200 
0ac3					ld a,0 
0ac3			.src:		ld (hl),a 
0ac3					inc hl 
0ac3					djnz .src 
0ac3					 
0ac3			 
0ac3					ld de, 0 
0ac3					ld bc, 1 
0ac3					ld hl, store_page 
0ac3					call cfRead 
0ac3			 
0ac3				call cfGetError 
0ac3				ld hl,scratch 
0ac3				call hexout 
0ac3				ld hl, scratch+2 
0ac3				ld a, 0 
0ac3				ld (hl),a 
0ac3				ld de, scratch 
0ac3				ld a,display_row_1 
0ac3				call str_at_display 
0ac3				call update_display 
0ac3			 
0ac3					ld hl, store_page 
0ac3					ld (os_cur_ptr),hl 
0ac3			 
0ac3					ret 
0ac3			endif 
0ac3			 
0ac3			 
0ac3			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ac3			 
0ac3			storage_clear_page: 
0ac3 e5				push hl 
0ac4 d5				push de 
0ac5 c5				push bc 
0ac6 21 74 ea			ld hl, store_page 
0ac9 3e 00			ld a, 0 
0acb 77				ld (hl), a 
0acc			 
0acc 11 75 ea			ld de, store_page+1 
0acf 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ad2			 
0ad2 ed b0			ldir 
0ad4				 
0ad4 c1				pop bc 
0ad5 d1				pop de 
0ad6 e1				pop hl 
0ad7 c9				ret 
0ad8			 
0ad8			; eof 
# End of file firmware_storage.asm
0ad8			  
0ad8			; support routines for above hardware abstraction layer  
0ad8			  
0ad8			include "firmware_general.asm"        ; general support functions  
0ad8			 
0ad8			; word look up 
0ad8			 
0ad8			; in 
0ad8			; a is the index 
0ad8			; hl is pointer start of array 
0ad8			; 
0ad8			; returns 
0ad8			; hl to the word 
0ad8			; 
0ad8			 
0ad8			table_lookup:  
0ad8 d5					push de 
0ad9 eb					ex de, hl 
0ada			 
0ada 6f					ld l, a 
0adb 26 00				ld h, 0 
0add 29					add hl, hl 
0ade 19					add hl, de 
0adf 7e					ld a, (hl) 
0ae0 23					inc hl 
0ae1 66					ld h,(hl) 
0ae2 6f					ld l, a 
0ae3			 
0ae3 d1					pop de 
0ae4 c9					ret 
0ae5			 
0ae5			; Delay loops 
0ae5			 
0ae5			 
0ae5			 
0ae5			aDelayInMS: 
0ae5 c5				push bc 
0ae6 47				ld b,a 
0ae7			msdelay: 
0ae7 c5				push bc 
0ae8				 
0ae8			 
0ae8 01 41 00			ld bc,041h 
0aeb cd 03 0b			call delayloop 
0aee c1				pop bc 
0aef 05				dec b 
0af0 20 f5			jr nz,msdelay 
0af2			 
0af2			;if CPU_CLOCK_8MHZ 
0af2			;msdelay8: 
0af2			;	push bc 
0af2			;	 
0af2			; 
0af2			;	ld bc,041h 
0af2			;	call delayloop 
0af2			;	pop bc 
0af2			;	dec b 
0af2			;	jr nz,msdelay8 
0af2			;endif 
0af2			 
0af2			 
0af2 c1				pop bc 
0af3 c9				ret 
0af4			 
0af4			 
0af4			delay250ms: 
0af4				;push de 
0af4 01 00 40			ld bc, 04000h 
0af7 c3 03 0b			jp delayloop 
0afa			delay500ms: 
0afa				;push de 
0afa 01 00 80			ld bc, 08000h 
0afd c3 03 0b			jp delayloop 
0b00			delay1s: 
0b00				;push bc 
0b00			   ; Clobbers A, d and e 
0b00 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0b03			delayloop: 
0b03 c5			    push bc 
0b04			 
0b04			if BASE_CPM 
0b04 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0b07			.cpmloop: 
0b07 c5				push bc 
0b08			 
0b08			endif 
0b08			 
0b08			 
0b08			 
0b08			delayloopi: 
0b08			;	push bc 
0b08			;.dl: 
0b08 cb 47		    bit     0,a    	; 8 
0b0a cb 47		    bit     0,a    	; 8 
0b0c cb 47		    bit     0,a    	; 8 
0b0e e6 ff		    and     255  	; 7 
0b10 0b			    dec     bc      	; 6 
0b11 79			    ld      a,c     	; 4 
0b12 b0			    or      b     	; 4 
0b13 c2 08 0b		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b16			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b16				;pop de 
0b16			;pop bc 
0b16			 
0b16			if BASE_CPM 
0b16 c1				pop bc 
0b17				 
0b17 0b			    dec     bc      	; 6 
0b18 79			    ld      a,c     	; 4 
0b19 b0			    or      b     	; 4 
0b1a c2 07 0b		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b1d				 
0b1d			 
0b1d			endif 
0b1d			;if CPU_CLOCK_8MHZ 
0b1d			;    pop bc 
0b1d			;    push bc 
0b1d			;.dl8: 
0b1d			;    bit     0,a    	; 8 
0b1d			;    bit     0,a    	; 8 
0b1d			;    bit     0,a    	; 8 
0b1d			;    and     255  	; 7 
0b1d			;    dec     bc      	; 6 
0b1d			;    ld      a,c     	; 4 
0b1d			;    or      b     	; 4 
0b1d			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b1d			;endif 
0b1d			 
0b1d			;if CPU_CLOCK_10MHZ 
0b1d			;    pop bc 
0b1d			;    push bc 
0b1d			;.dl8: 
0b1d			;    bit     0,a    	; 8 
0b1d			;    bit     0,a    	; 8 
0b1d			;    bit     0,a    	; 8 
0b1d			;    and     255  	; 7 
0b1d			;    dec     bc      	; 6 
0b1d			;    ld      a,c     	; 4 
0b1d			;    or      b     	; 4 
0b1d			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b1d			;endif 
0b1d c1			    pop bc 
0b1e			 
0b1e c9				ret 
0b1f			 
0b1f			 
0b1f			 
0b1f			; eof 
# End of file firmware_general.asm
0b1f			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b1f			; display routines that use the physical hardware abstraction layer 
0b1f			 
0b1f			 
0b1f			; Display an activity indicator 
0b1f			; Each call returns the new char pointed to in hl 
0b1f			 
0b1f			active: 
0b1f 3a c0 eb			ld a, (display_active) 
0b22 fe 06			cp 6 
0b24			 
0b24 20 02			jr nz, .sne 
0b26				; gone past the last one reset sequence 
0b26 3e ff			ld a, 255 
0b28			 
0b28			.sne:   
0b28				; get the next char in seq 
0b28 3c				inc a 
0b29 32 c0 eb			ld (display_active), a 
0b2c			 
0b2c				; look up the string in the table 
0b2c 21 43 0b			ld hl, actseq 
0b2f cb 27			sla a 
0b31 cd f5 0d			call addatohl 
0b34 cd 03 1f			call loadwordinhl 
0b37			 
0b37				; forth will write the to string when pushing so move from rom to ram 
0b37			 
0b37 11 c1 eb			ld de, display_active+1 
0b3a 01 02 00			ld bc, 2 
0b3d ed b0			ldir 
0b3f			 
0b3f 21 c1 eb			ld hl, display_active+1 
0b42 c9				ret 
0b43				 
0b43				 
0b43			 
0b43			 
0b43			;db "|/-\|-\" 
0b43			 
0b43			actseq: 
0b43			 
0b43 51 0b		dw spin0 
0b45 53 0b		dw spin1 
0b47 55 0b		dw spin2 
0b49 57 0b		dw spin3 
0b4b 55 0b		dw spin2 
0b4d 53 0b		dw spin1 
0b4f 51 0b		dw spin0 
0b51			 
0b51 .. 00		spin0: db " ", 0 
0b53 .. 00		spin1: db "-", 0 
0b55 .. 00		spin2: db "+", 0 
0b57 .. 00		spin3: db "#", 0 
0b59			 
0b59			 
0b59			; information window 
0b59			 
0b59			; pass hl with 1st string to display 
0b59			; pass de with 2nd string to display 
0b59			 
0b59			info_panel: 
0b59 e5				push hl 
0b5a			 
0b5a 2a c6 eb			ld hl, (display_fb_active) 
0b5d e5				push hl    ; future de destination 
0b5e 21 ab ed				ld hl, display_fb0 
0b61 22 c6 eb				ld (display_fb_active), hl 
0b64			 
0b64			;	call clear_display 
0b64			 
0b64				if BASE_CPM 
0b64 3e 2e			ld a, '.' 
0b66				else 
0b66				ld a, 165 
0b66				endif 
0b66 cd cd 0b			call fill_display 
0b69			 
0b69			 
0b69 3e 55			ld a, display_row_3 + 5 
0b6b cd db 0b			call str_at_display 
0b6e			 
0b6e e1				pop hl 
0b6f d1				pop de 
0b70			 
0b70 e5				push hl 
0b71			 
0b71			 
0b71 3e 2d			ld a, display_row_2 + 5 
0b73 cd db 0b			call str_at_display 
0b76			 
0b76			 
0b76 cd eb 0b			call update_display 
0b79 cd 08 1b			call next_page_prompt 
0b7c cd c8 0b			call clear_display 
0b7f			 
0b7f				 
0b7f 21 0a ed				ld hl, display_fb1 
0b82 22 c6 eb				ld (display_fb_active), hl 
0b85 cd eb 0b			call update_display 
0b88			 
0b88 e1				pop hl 
0b89			 
0b89 c9				ret 
0b8a			 
0b8a			 
0b8a			 
0b8a			 
0b8a			; TODO windowing? 
0b8a			 
0b8a			; TODO scroll line up 
0b8a			 
0b8a			scroll_up: 
0b8a			 
0b8a e5				push hl 
0b8b d5				push de 
0b8c c5				push bc 
0b8d			 
0b8d				; get frame buffer  
0b8d			 
0b8d 2a c6 eb			ld hl, (display_fb_active) 
0b90 e5				push hl    ; future de destination 
0b91			 
0b91 11 28 00			ld  de, display_cols 
0b94 19				add hl, de 
0b95			 
0b95 d1				pop de 
0b96			 
0b96				;ex de, hl 
0b96 01 9f 00			ld bc, display_fb_len -1  
0b99			;if DEBUG_FORTH_WORDS 
0b99			;	DMARK "SCL" 
0b99			;	CALLMONITOR 
0b99			;endif	 
0b99 ed b0			ldir 
0b9b			 
0b9b				; wipe bottom row 
0b9b			 
0b9b			 
0b9b 2a c6 eb			ld hl, (display_fb_active) 
0b9e 11 a0 00			ld de, display_cols*display_rows 
0ba1 19				add hl, de 
0ba2 06 28			ld b, display_cols 
0ba4 3e 20			ld a, ' ' 
0ba6			.scwipe: 
0ba6 77				ld (hl), a 
0ba7 2b				dec hl 
0ba8 10 fc			djnz .scwipe 
0baa			 
0baa				;pop hl 
0baa			 
0baa c1				pop bc 
0bab d1				pop de 
0bac e1				pop hl 
0bad			 
0bad c9				ret 
0bae			 
0bae			 
0bae			;scroll_upo: 
0bae			;	ld de, display_row_1 
0bae			 ;	ld hl, display_row_2 
0bae			;	ld bc, display_cols 
0bae			;	ldir 
0bae			;	ld de, display_row_2 
0bae			 ;	ld hl, display_row_3 
0bae			;	ld bc, display_cols 
0bae			;	ldir 
0bae			;	ld de, display_row_3 
0bae			 ;	ld hl, display_row_4 
0bae			;	ld bc, display_cols 
0bae			;	ldir 
0bae			 
0bae			; TODO clear row 4 
0bae			 
0bae			;	ret 
0bae			 
0bae				 
0bae			scroll_down: 
0bae			 
0bae e5				push hl 
0baf d5				push de 
0bb0 c5				push bc 
0bb1			 
0bb1				; get frame buffer  
0bb1			 
0bb1 2a c6 eb			ld hl, (display_fb_active) 
0bb4			 
0bb4 11 9f 00			ld de, display_fb_len - 1 
0bb7 19				add hl, de 
0bb8			 
0bb8 e5			push hl    ; future de destination 
0bb9			 
0bb9 11 28 00			ld  de, display_cols 
0bbc ed 52			sbc hl, de 
0bbe			 
0bbe			 
0bbe d1				pop de 
0bbf			 
0bbf			;	ex de, hl 
0bbf 01 9f 00			ld bc, display_fb_len -1  
0bc2			 
0bc2			 
0bc2				 
0bc2			 
0bc2 ed b0			ldir 
0bc4			 
0bc4				; wipe bottom row 
0bc4			 
0bc4			 
0bc4			;	ld hl, (display_fb_active) 
0bc4			;;	ld de, display_cols*display_rows 
0bc4			;;	add hl, de 
0bc4			;	ld b, display_cols 
0bc4			;	ld a, ' ' 
0bc4			;.scwiped: 
0bc4			;	ld (hl), a 
0bc4			;	dec hl 
0bc4			;	djnz .scwiped 
0bc4			 
0bc4				;pop hl 
0bc4			 
0bc4 c1				pop bc 
0bc5 d1				pop de 
0bc6 e1				pop hl 
0bc7			 
0bc7 c9				ret 
0bc8			;scroll_down: 
0bc8			;	ld de, display_row_4 
0bc8			;	ld hl, display_row_3 
0bc8			;	ld bc, display_cols 
0bc8			;	ldir 
0bc8			;	ld de, display_row_3 
0bc8			; 	ld hl, display_row_2 
0bc8			;	ld bc, display_cols 
0bc8			;	ldir 
0bc8			;	ld de, display_row_2 
0bc8			;	ld hl, display_row_1 
0bc8			;	ld bc, display_cols 
0bc8			;	ldir 
0bc8			;;; TODO clear row 1 
0bc8			;	ret 
0bc8			 
0bc8			 
0bc8			 
0bc8			 
0bc8			 
0bc8			; clear active frame buffer 
0bc8			 
0bc8			clear_display: 
0bc8 3e 20			ld a, ' ' 
0bca c3 cd 0b			jp fill_display 
0bcd			 
0bcd			; fill active frame buffer with a char in A 
0bcd			 
0bcd			fill_display: 
0bcd 06 a0			ld b,display_fb_len 
0bcf 2a c6 eb			ld hl, (display_fb_active) 
0bd2 77			.fd1:	ld (hl),a 
0bd3 23				inc hl 
0bd4 10 fc			djnz .fd1 
0bd6 23				inc hl 
0bd7 3e 00			ld a,0 
0bd9 77				ld (hl),a 
0bda			 
0bda			 
0bda c9				ret 
0bdb			; Write string (DE) at pos (A) to active frame buffer 
0bdb			 
0bdb 2a c6 eb		str_at_display:    ld hl,(display_fb_active) 
0bde 06 00					ld b,0 
0be0 4f					ld c,a 
0be1 09					add hl,bc 
0be2 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0be3 b7			            OR   A              ;Null terminator? 
0be4 c8			            RET  Z              ;Yes, so finished 
0be5 77					ld (hl),a 
0be6 23				inc hl 
0be7 13			            INC  DE             ;Point to next character 
0be8 18 f8		            JR   .sad1     ;Repeat 
0bea c9					ret 
0beb			 
0beb			; using current frame buffer write to physical display 
0beb			 
0beb			update_display: 
0beb e5				push hl 
0bec 2a c6 eb			ld hl, (display_fb_active) 
0bef cd 3f 5e			call write_display 
0bf2 e1				pop hl 
0bf3 c9				ret 
0bf4			 
0bf4			; TODO scrolling 
0bf4			 
0bf4			 
0bf4			; move cursor right one char 
0bf4			cursor_right: 
0bf4			 
0bf4				; TODO shift right 
0bf4				; TODO if beyond max col 
0bf4				; TODO       cursor_next_line 
0bf4			 
0bf4 c9				ret 
0bf5			 
0bf5			 
0bf5			cursor_next_line: 
0bf5				; TODO first char 
0bf5				; TODO line down 
0bf5				; TODO if past last row 
0bf5				; TODO    scroll up 
0bf5			 
0bf5 c9				ret 
0bf6			 
0bf6			cursor_left: 
0bf6				; TODO shift left 
0bf6				; TODO if beyond left  
0bf6				; TODO     cursor prev line 
0bf6				 
0bf6 c9				ret 
0bf7			 
0bf7			cursor_prev_line: 
0bf7				; TODO last char 
0bf7				; TODO line up 
0bf7				; TODO if past first row 
0bf7				; TODO   scroll down 
0bf7			 
0bf7 c9				ret 
0bf8			 
0bf8			 
0bf8			cout: 
0bf8				; A - char 
0bf8 c9				ret 
0bf9			 
0bf9			 
0bf9			; Display a menu and allow item selection (optional toggle items) 
0bf9			; 
0bf9			; format: 
0bf9			; hl pointer to word array with zero term for items 
0bf9			; e.g.    db item1 
0bf9			;         db .... 
0bf9			;         db 0 
0bf9			; 
0bf9			; a = starting menu item  
0bf9			; 
0bf9			; de = pointer item toggle array   (todo) 
0bf9			; 
0bf9			; returns item selected in a 1-... 
0bf9			; returns 0 if back button pressed 
0bf9			; 
0bf9			; NOTE: Uses system frame buffer to display 
0bf9			; 
0bf9			; LEFT, Q = go back 
0bf9			; RIGHT, SPACE, CR = select 
0bf9			; UP, A - Up 
0bf9			; DOWN, Z - Down 
0bf9			 
0bf9			 
0bf9			 
0bf9			 
0bf9			 
0bf9			menu: 
0bf9			 
0bf9					; keep array pointer 
0bf9			 
0bf9 22 6d ea				ld (store_tmp1), hl 
0bfc 32 6b ea				ld (store_tmp2), a 
0bff			 
0bff					; check for key bounce 
0bff			 
0bff			if BASE_KEV 
0bff			 
0bff			.mbounce:	call cin 
0bff					cp 0 
0bff					jr nz, .mbounce 
0bff			endif 
0bff					; for ease use ex 
0bff			 
0bff					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bff 21 ab ed				ld hl, display_fb0 
0c02 22 c6 eb				ld (display_fb_active), hl 
0c05			 
0c05 cd c8 0b		.mloop:		call clear_display 
0c08 cd eb 0b				call update_display 
0c0b			 
0c0b					; draw selection id '>' at 1 
0c0b			 
0c0b					; init start of list display 
0c0b			 
0c0b 3e 05				ld a, 5 
0c0d 32 69 ea				ld (store_tmp3), a   ; display row count 
0c10 3a 6b ea				ld a,( store_tmp2) 
0c13 32 6c ea				ld (store_tmp2+1), a   ; display item count 
0c16			 
0c16					 
0c16			.mitem:	 
0c16			 
0c16			 
0c16 3a 6c ea				ld a,(store_tmp2+1) 
0c19 6f					ld l, a 
0c1a 26 00				ld h, 0 
0c1c 29					add hl, hl 
0c1d ed 5b 6d ea			ld de, (store_tmp1) 
0c21 19					add hl, de 
0c22 7e					ld a, (hl) 
0c23 23					inc hl 
0c24 66					ld h,(hl) 
0c25 6f					ld l, a 
0c26			 
0c26 cd 1e 0e				call ishlzero 
0c29 28 1a				jr z, .mdone 
0c2b			 
0c2b eb					ex de, hl 
0c2c 3a 69 ea				ld a, (store_tmp3) 
0c2f cd db 0b				call str_at_display 
0c32					 
0c32			 
0c32					; next item 
0c32 3a 6c ea				ld a, (store_tmp2+1) 
0c35 3c					inc a 
0c36 32 6c ea				ld (store_tmp2+1), a   ; display item count 
0c39			 
0c39			 		; next row 
0c39			 
0c39 3a 69 ea				ld a, (store_tmp3) 
0c3c c6 28				add display_cols 
0c3e 32 69 ea				ld (store_tmp3), a 
0c41			 
0c41					; at end of screen? 
0c41			 
0c41 fe 10				cp display_rows*4 
0c43 20 d1				jr nz, .mitem 
0c45			 
0c45			 
0c45			.mdone: 
0c45 cd 1e 0e				call ishlzero 
0c48 28 08				jr z, .nodn 
0c4a			 
0c4a 3e 78				ld a, display_row_4 
0c4c 11 cb 0c				ld de, .mdown 
0c4f cd db 0b				call str_at_display 
0c52			 
0c52					; draw options to fill the screens with active item on line 1 
0c52					; if current option is 2 or more then display ^ in top 
0c52			 
0c52 3a 6b ea		.nodn:		ld a, (store_tmp2) 
0c55 fe 00				cp 0 
0c57 28 08				jr z, .noup 
0c59			 
0c59 3e 00				ld a, 0 
0c5b 11 c9 0c				ld de, .mup 
0c5e cd db 0b				call str_at_display 
0c61			 
0c61 3e 02		.noup:		ld a, 2 
0c63 11 c7 0c				ld de, .msel 
0c66 cd db 0b				call str_at_display 
0c69			 
0c69					; if current option + 1 is not null then display V in bottom 
0c69					; get key 
0c69 cd eb 0b				call update_display 
0c6c			 
0c6c			 
0c6c					; handle key 
0c6c			 
0c6c cd f1 5e				call cin_wait 
0c6f			 
0c6f fe 05				cp KEY_UP 
0c71 28 2b				jr z, .mgoup 
0c73 fe 61				cp 'a' 
0c75 28 27				jr z, .mgoup 
0c77 fe 0a				cp KEY_DOWN 
0c79 28 32				jr z, .mgod 
0c7b fe 7a				cp 'z' 
0c7d 28 2e				jr z, .mgod 
0c7f fe 20				cp ' ' 
0c81 28 34				jr z, .goend 
0c83 fe 0c				cp KEY_RIGHT 
0c85 28 30				jr z, .goend 
0c87 fe 0d				cp KEY_CR 
0c89 28 2c				jr z, .goend 
0c8b fe 71				cp 'q' 
0c8d 28 0b				jr z, .goback 
0c8f			 
0c8f fe 0b				cp KEY_LEFT 
0c91 28 07				jr z, .goback 
0c93 fe 08				cp KEY_BS 
0c95 28 03				jr z, .goback 
0c97 c3 05 0c				jp .mloop 
0c9a			 
0c9a			.goback: 
0c9a 3e 00			ld a, 0 
0c9c 18 1d			jr .goend2 
0c9e			 
0c9e				; move up one 
0c9e			.mgoup: 
0c9e 3a 6b ea				ld a, (store_tmp2) 
0ca1 fe 00				cp 0 
0ca3 ca 05 0c				jp z, .mloop 
0ca6 3d					dec a 
0ca7 32 6b ea				ld (store_tmp2), a 
0caa c3 05 0c				jp .mloop 
0cad			 
0cad				; move down one 
0cad			.mgod: 
0cad 3a 6b ea				ld a, (store_tmp2) 
0cb0 3c					inc a 
0cb1 32 6b ea				ld (store_tmp2), a 
0cb4 c3 05 0c				jp .mloop 
0cb7			 
0cb7			 
0cb7			.goend: 
0cb7					; get selected item number 
0cb7			 
0cb7 3a 6b ea				ld a, (store_tmp2) 
0cba 3c					inc a 
0cbb			 
0cbb			.goend2: 
0cbb f5					push af 
0cbc			 
0cbc					; restore active fb 
0cbc					; TODO BUG assumes fb1 
0cbc			 
0cbc 21 0a ed				ld hl, display_fb1 
0cbf 22 c6 eb				ld (display_fb_active), hl 
0cc2			 
0cc2					; restore main regs 
0cc2			 
0cc2			 
0cc2 cd eb 0b				call update_display 
0cc5			 
0cc5 f1					pop af 
0cc6			 
0cc6 c9				ret 
0cc7			 
0cc7 .. 00		.msel:   db ">",0 
0cc9 .. 00		.mup:   db "^",0 
0ccb .. 00		.mdown:   db "v",0 
0ccd			 
0ccd			 
0ccd			; eof 
0ccd			 
# End of file firmware_display.asm
0ccd			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ccd			; random number generators 
0ccd			 
0ccd			 
0ccd			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ccd			 
0ccd			 
0ccd			;-----> Generate a random number 
0ccd			; output a=answer 0<=a<=255 
0ccd			; all registers are preserved except: af 
0ccd			random: 
0ccd e5			        push    hl 
0cce d5			        push    de 
0ccf 2a a5 eb		        ld      hl,(randData) 
0cd2 ed 5f		        ld      a,r 
0cd4 57			        ld      d,a 
0cd5 5e			        ld      e,(hl) 
0cd6 19			        add     hl,de 
0cd7 85			        add     a,l 
0cd8 ac			        xor     h 
0cd9 22 a5 eb		        ld      (randData),hl 
0cdc d1			        pop     de 
0cdd e1			        pop     hl 
0cde c9			        ret 
0cdf			 
0cdf			 
0cdf			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cdf			 
0cdf			 
0cdf			 
0cdf			;------LFSR------ 
0cdf			;James Montelongo 
0cdf			;optimized by Spencer Putt 
0cdf			;out: 
0cdf			; a = 8 bit random number 
0cdf			RandLFSR: 
0cdf 21 ab eb		        ld hl,LFSRSeed+4 
0ce2 5e			        ld e,(hl) 
0ce3 23			        inc hl 
0ce4 56			        ld d,(hl) 
0ce5 23			        inc hl 
0ce6 4e			        ld c,(hl) 
0ce7 23			        inc hl 
0ce8 7e			        ld a,(hl) 
0ce9 47			        ld b,a 
0cea cb 13		        rl e  
0cec cb 12			rl d 
0cee cb 11		        rl c  
0cf0 17				rla 
0cf1 cb 13		        rl e  
0cf3 cb 12			rl d 
0cf5 cb 11		        rl c  
0cf7 17				rla 
0cf8 cb 13		        rl e  
0cfa cb 12			rl d 
0cfc cb 11		        rl c  
0cfe 17				rla 
0cff 67			        ld h,a 
0d00 cb 13		        rl e  
0d02 cb 12			rl d 
0d04 cb 11		        rl c  
0d06 17				rla 
0d07 a8			        xor b 
0d08 cb 13		        rl e  
0d0a cb 12			rl d 
0d0c ac			        xor h 
0d0d a9			        xor c 
0d0e aa			        xor d 
0d0f 21 ad eb		        ld hl,LFSRSeed+6 
0d12 11 ae eb		        ld de,LFSRSeed+7 
0d15 01 07 00		        ld bc,7 
0d18 ed b8		        lddr 
0d1a 12			        ld (de),a 
0d1b c9			        ret 
0d1c			 
0d1c			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d1c			 
0d1c			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d1c			 
0d1c			 
0d1c			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d1c			 
0d1c			prng16: 
0d1c			;Inputs: 
0d1c			;   (seed1) contains a 16-bit seed value 
0d1c			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d1c			;Outputs: 
0d1c			;   HL is the result 
0d1c			;   BC is the result of the LCG, so not that great of quality 
0d1c			;   DE is preserved 
0d1c			;Destroys: 
0d1c			;   AF 
0d1c			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d1c			;160cc 
0d1c			;26 bytes 
0d1c 2a 9f eb		    ld hl,(seed1) 
0d1f 44			    ld b,h 
0d20 4d			    ld c,l 
0d21 29			    add hl,hl 
0d22 29			    add hl,hl 
0d23 2c			    inc l 
0d24 09			    add hl,bc 
0d25 22 9f eb		    ld (seed1),hl 
0d28 2a 9d eb		    ld hl,(seed2) 
0d2b 29			    add hl,hl 
0d2c 9f			    sbc a,a 
0d2d e6 2d		    and %00101101 
0d2f ad			    xor l 
0d30 6f			    ld l,a 
0d31 22 9d eb		    ld (seed2),hl 
0d34 09			    add hl,bc 
0d35 c9			    ret 
0d36			 
0d36			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d36			 
0d36			rand32: 
0d36			;Inputs: 
0d36			;   (seed1_0) holds the lower 16 bits of the first seed 
0d36			;   (seed1_1) holds the upper 16 bits of the first seed 
0d36			;   (seed2_0) holds the lower 16 bits of the second seed 
0d36			;   (seed2_1) holds the upper 16 bits of the second seed 
0d36			;   **NOTE: seed2 must be non-zero 
0d36			;Outputs: 
0d36			;   HL is the result 
0d36			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d36			;Destroys: 
0d36			;   AF 
0d36			;Tested and passes all CAcert tests 
0d36			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d36			;it has a period of 18,446,744,069,414,584,320 
0d36			;roughly 18.4 quintillion. 
0d36			;LFSR taps: 0,2,6,7  = 11000101 
0d36			;291cc 
0d36			;seed1_0=$+1 
0d36			;    ld hl,12345 
0d36			;seed1_1=$+1 
0d36			;    ld de,6789 
0d36			;    ld b,h 
0d36			;    ld c,l 
0d36			;    add hl,hl \ rl e \ rl d 
0d36			;    add hl,hl \ rl e \ rl d 
0d36			;    inc l 
0d36			;    add hl,bc 
0d36			;    ld (seed1_0),hl 
0d36			;    ld hl,(seed1_1) 
0d36			;    adc hl,de 
0d36			;    ld (seed1_1),hl 
0d36			;    ex de,hl 
0d36			;seed2_0=$+1 
0d36			;    ld hl,9876 
0d36			;seed2_1=$+1 
0d36			;    ld bc,54321 
0d36			;    add hl,hl \ rl c \ rl b 
0d36			;    ld (seed2_1),bc 
0d36			;    sbc a,a 
0d36			;    and %11000101 
0d36			;    xor l 
0d36			;    ld l,a 
0d36			;    ld (seed2_0),hl 
0d36			;    ex de,hl 
0d36			;    add hl,bc 
0d36			;    ret 
0d36			; 
0d36			 
0d36			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d36			; 20 bytes, 86 cycles (excluding ret) 
0d36			 
0d36			; returns   hl = pseudorandom number 
0d36			; corrupts   a 
0d36			 
0d36			; generates 16-bit pseudorandom numbers with a period of 65535 
0d36			; using the xorshift method: 
0d36			 
0d36			; hl ^= hl << 7 
0d36			; hl ^= hl >> 9 
0d36			; hl ^= hl << 8 
0d36			 
0d36			; some alternative shift triplets which also perform well are: 
0d36			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d36			 
0d36			;  org 32768 
0d36			 
0d36			xrnd: 
0d36 2a a3 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d39 3e 00		  ld a,0 
0d3b bd			  cp l 
0d3c 20 02		  jr nz, .xrnd1 
0d3e 2e 01		  ld l, 1 
0d40			.xrnd1: 
0d40			 
0d40 7c			  ld a,h 
0d41 1f			  rra 
0d42 7d			  ld a,l 
0d43 1f			  rra 
0d44 ac			  xor h 
0d45 67			  ld h,a 
0d46 7d			  ld a,l 
0d47 1f			  rra 
0d48 7c			  ld a,h 
0d49 1f			  rra 
0d4a ad			  xor l 
0d4b 6f			  ld l,a 
0d4c ac			  xor h 
0d4d 67			  ld h,a 
0d4e			 
0d4e 22 a3 eb		  ld (xrandc),hl 
0d51			 
0d51 c9			  ret 
0d52			;  
0d52			 
0d52			 
0d52			;;;; int maths 
0d52			 
0d52			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d52			; Divide 16-bit values (with 16-bit result) 
0d52			; In: Divide BC by divider DE 
0d52			; Out: BC = result, HL = rest 
0d52			; 
0d52			Div16: 
0d52 21 00 00		    ld hl,0 
0d55 78			    ld a,b 
0d56 06 08		    ld b,8 
0d58			Div16_Loop1: 
0d58 17			    rla 
0d59 ed 6a		    adc hl,hl 
0d5b ed 52		    sbc hl,de 
0d5d 30 01		    jr nc,Div16_NoAdd1 
0d5f 19			    add hl,de 
0d60			Div16_NoAdd1: 
0d60 10 f6		    djnz Div16_Loop1 
0d62 17			    rla 
0d63 2f			    cpl 
0d64 47			    ld b,a 
0d65 79			    ld a,c 
0d66 48			    ld c,b 
0d67 06 08		    ld b,8 
0d69			Div16_Loop2: 
0d69 17			    rla 
0d6a ed 6a		    adc hl,hl 
0d6c ed 52		    sbc hl,de 
0d6e 30 01		    jr nc,Div16_NoAdd2 
0d70 19			    add hl,de 
0d71			Div16_NoAdd2: 
0d71 10 f6		    djnz Div16_Loop2 
0d73 17			    rla 
0d74 2f			    cpl 
0d75 41			    ld b,c 
0d76 4f			    ld c,a 
0d77 c9			ret 
0d78			 
0d78			 
0d78			;http://z80-heaven.wikidot.com/math 
0d78			; 
0d78			;Inputs: 
0d78			;     DE and A are factors 
0d78			;Outputs: 
0d78			;     A is not changed 
0d78			;     B is 0 
0d78			;     C is not changed 
0d78			;     DE is not changed 
0d78			;     HL is the product 
0d78			;Time: 
0d78			;     342+6x 
0d78			; 
0d78			Mult16: 
0d78			 
0d78 06 08		     ld b,8          ;7           7 
0d7a 21 00 00		     ld hl,0         ;10         10 
0d7d 29			       add hl,hl     ;11*8       88 
0d7e 07			       rlca          ;4*8        32 
0d7f 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d81 19			         add hl,de   ;--         -- 
0d82 10 f9		       djnz $-5      ;13*7+8     99 
0d84 c9			ret 
0d85			 
0d85			; 
0d85			; Square root of 16-bit value 
0d85			; In:  HL = value 
0d85			; Out:  D = result (rounded down) 
0d85			; 
0d85			;Sqr16: 
0d85			;    ld de,#0040 
0d85			;    ld a,l 
0d85			;    ld l,h 
0d85			;    ld h,d 
0d85			;    or a 
0d85			;    ld b,8 
0d85			;Sqr16_Loop: 
0d85			;    sbc hl,de 
0d85			;    jr nc,Sqr16_Skip 
0d85			;    add hl,de 
0d85			;Sqr16_Skip: 
0d85			;    ccf 
0d85			;    rl d 
0d85			;    add a,a 
0d85			;    adc hl,hl 
0d85			;    add a,a 
0d85			;    adc hl,hl 
0d85			;    djnz Sqr16_Loop 
0d85			;    ret 
0d85			; 
0d85			; 
0d85			; Divide 8-bit values 
0d85			; In: Divide E by divider C 
0d85			; Out: A = result, B = rest 
0d85			; 
0d85			Div8: 
0d85 af			    xor a 
0d86 06 08		    ld b,8 
0d88			Div8_Loop: 
0d88 cb 13		    rl e 
0d8a 17			    rla 
0d8b 91			    sub c 
0d8c 30 01		    jr nc,Div8_NoAdd 
0d8e 81			    add a,c 
0d8f			Div8_NoAdd: 
0d8f 10 f7		    djnz Div8_Loop 
0d91 47			    ld b,a 
0d92 7b			    ld a,e 
0d93 17			    rla 
0d94 2f			    cpl 
0d95 c9			    ret 
0d96			 
0d96			; 
0d96			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d96			; In: Multiply A with DE 
0d96			; Out: HL = result 
0d96			; 
0d96			Mult12U: 
0d96 2e 00		    ld l,0 
0d98 87			    add a,a 
0d99 30 01		    jr nc,Mult12U_NoAdd0 
0d9b 19			    add hl,de 
0d9c			Mult12U_NoAdd0: 
0d9c 29			    add hl,hl 
0d9d 87			    add a,a 
0d9e 30 01		    jr nc,Mult12U_NoAdd1 
0da0 19			    add hl,de 
0da1			Mult12U_NoAdd1: 
0da1 29			    add hl,hl 
0da2 87			    add a,a 
0da3 30 01		    jr nc,Mult12U_NoAdd2 
0da5 19			    add hl,de 
0da6			Mult12U_NoAdd2: 
0da6 29			    add hl,hl 
0da7 87			    add a,a 
0da8 30 01		    jr nc,Mult12U_NoAdd3 
0daa 19			    add hl,de 
0dab			Mult12U_NoAdd3: 
0dab 29			    add hl,hl 
0dac 87			    add a,a 
0dad 30 01		    jr nc,Mult12U_NoAdd4 
0daf 19			    add hl,de 
0db0			Mult12U_NoAdd4: 
0db0 29			    add hl,hl 
0db1 87			    add a,a 
0db2 30 01		    jr nc,Mult12U_NoAdd5 
0db4 19			    add hl,de 
0db5			Mult12U_NoAdd5: 
0db5 29			    add hl,hl 
0db6 87			    add a,a 
0db7 30 01		    jr nc,Mult12U_NoAdd6 
0db9 19			    add hl,de 
0dba			Mult12U_NoAdd6: 
0dba 29			    add hl,hl 
0dbb 87			    add a,a 
0dbc d0			    ret nc 
0dbd 19			    add hl,de 
0dbe c9			    ret 
0dbf			 
0dbf			; 
0dbf			; Multiply 8-bit value with a 16-bit value (right rotating) 
0dbf			; In: Multiply A with DE 
0dbf			;      Put lowest value in A for most efficient calculation 
0dbf			; Out: HL = result 
0dbf			; 
0dbf			Mult12R: 
0dbf 21 00 00		    ld hl,0 
0dc2			Mult12R_Loop: 
0dc2 cb 3f		    srl a 
0dc4 30 01		    jr nc,Mult12R_NoAdd 
0dc6 19			    add hl,de 
0dc7			Mult12R_NoAdd: 
0dc7 cb 23		    sla e 
0dc9 cb 12		    rl d 
0dcb b7			    or a 
0dcc c2 c2 0d		    jp nz,Mult12R_Loop 
0dcf c9			    ret 
0dd0			 
0dd0			; 
0dd0			; Multiply 16-bit values (with 32-bit result) 
0dd0			; In: Multiply BC with DE 
0dd0			; Out: BCHL = result 
0dd0			; 
0dd0			Mult32: 
0dd0 79			    ld a,c 
0dd1 48			    ld c,b 
0dd2 21 00 00		    ld hl,0 
0dd5 06 10		    ld b,16 
0dd7			Mult32_Loop: 
0dd7 29			    add hl,hl 
0dd8 17			    rla 
0dd9 cb 11		    rl c 
0ddb 30 07		    jr nc,Mult32_NoAdd 
0ddd 19			    add hl,de 
0dde ce 00		    adc a,0 
0de0 d2 e4 0d		    jp nc,Mult32_NoAdd 
0de3 0c			    inc c 
0de4			Mult32_NoAdd: 
0de4 10 f1		    djnz Mult32_Loop 
0de6 41			    ld b,c 
0de7 4f			    ld c,a 
0de8 c9			    ret 
0de9			 
0de9			 
0de9			 
0de9			; 
0de9			; Multiply 8-bit values 
0de9			; In:  Multiply H with E 
0de9			; Out: HL = result 
0de9			; 
0de9			Mult8: 
0de9 16 00		    ld d,0 
0deb 6a			    ld l,d 
0dec 06 08		    ld b,8 
0dee			Mult8_Loop: 
0dee 29			    add hl,hl 
0def 30 01		    jr nc,Mult8_NoAdd 
0df1 19			    add hl,de 
0df2			Mult8_NoAdd: 
0df2 10 fa		    djnz Mult8_Loop 
0df4 c9			    ret 
0df5			 
0df5			 
0df5			 
0df5			 
0df5			 
0df5			 
0df5			 
0df5			 
0df5			;;http://z80-heaven.wikidot.com/math 
0df5			;;This divides DE by BC, storing the result in DE, remainder in HL 
0df5			; 
0df5			;DE_Div_BC:          ;1281-2x, x is at most 16 
0df5			;     ld a,16        ;7 
0df5			;     ld hl,0        ;10 
0df5			;     jp $+5         ;10 
0df5			;.DivLoop: 
0df5			;       add hl,bc    ;-- 
0df5			;       dec a        ;64 
0df5			;       jr z,.DivLoopEnd        ;86 
0df5			; 
0df5			;       sla e        ;128 
0df5			;       rl d         ;128 
0df5			;       adc hl,hl    ;240 
0df5			;       sbc hl,bc    ;240 
0df5			;       jr nc,.DivLoop ;23|21 
0df5			;       inc e        ;-- 
0df5			;       jp .DivLoop+1 
0df5			; 
0df5			;.DivLoopEnd: 
0df5			 
0df5			;HL_Div_C: 
0df5			;Inputs: 
0df5			;     HL is the numerator 
0df5			;     C is the denominator 
0df5			;Outputs: 
0df5			;     A is the remainder 
0df5			;     B is 0 
0df5			;     C is not changed 
0df5			;     DE is not changed 
0df5			;     HL is the quotient 
0df5			; 
0df5			;       ld b,16 
0df5			;       xor a 
0df5			;         add hl,hl 
0df5			;         rla 
0df5			;         cp c 
0df5			;         jr c,$+4 
0df5			;           inc l 
0df5			;           sub c 
0df5			;         djnz $-7 
0df5			 
0df5			; https://plutiedev.com/z80-add-8bit-to-16bit 
0df5			 
0df5			addatohl: 
0df5 85			    add   a, l    ; A = A+L 
0df6 6f			    ld    l, a    ; L = A+L 
0df7 8c			    adc   a, h    ; A = A+L+H+carry 
0df8 95			    sub   l       ; A = H+carry 
0df9 67			    ld    h, a    ; H = H+carry 
0dfa c9			ret 
0dfb			 
0dfb			addatode: 
0dfb 83			    add   a, e    ; A = A+L 
0dfc 5f			    ld    e, a    ; L = A+L 
0dfd 8a			    adc   a, d    ; A = A+L+H+carry 
0dfe 93			    sub   e       ; A = H+carry 
0dff 57			    ld    d, a    ; H = H+carry 
0e00 c9			ret 
0e01			 
0e01			 
0e01			addatobc: 
0e01 81			    add   a, c    ; A = A+L 
0e02 4f			    ld    c, a    ; L = A+L 
0e03 88			    adc   a, b    ; A = A+L+H+carry 
0e04 91			    sub   c       ; A = H+carry 
0e05 47			    ld    b, a    ; H = H+carry 
0e06 c9			ret 
0e07			 
0e07			subafromhl: 
0e07			   ; If A=0 do nothing 
0e07			    ; Otherwise flip A's sign. Since 
0e07			    ; the upper byte becomes -1, also 
0e07			    ; substract 1 from H. 
0e07 ed 44		    neg 
0e09 ca 12 0e		    jp    z, Skip 
0e0c 25			    dec   h 
0e0d			     
0e0d			    ; Now add the low byte as usual 
0e0d			    ; Two's complement takes care of 
0e0d			    ; ensuring the result is correct 
0e0d 85			    add   a, l 
0e0e 6f			    ld    l, a 
0e0f 8c			    adc   a, h 
0e10 95			    sub   l 
0e11 67			    ld    h, a 
0e12			Skip: 
0e12 c9				ret 
0e13			 
0e13			 
0e13			; compare hl and de 
0e13			; returns:  
0e13			; if hl = de, z=1, s=0, c0=0 
0e13			; if hl > de, z=0, s=0, c=0 
0e13			; if hl < de, z=0, s=1, c=1 
0e13			cmp16:	 
0e13 b7				or a 
0e14 ed 52			sbc hl,de 
0e16 e0				ret po 
0e17 7c				ld a,h 
0e18 1f				rra 
0e19 ee 40			xor 01000000B 
0e1b 37				scf 
0e1c 8f				adc a,a 
0e1d c9				ret 
0e1e			 
0e1e			 
0e1e			; test if hl contains zero   - A is destroyed 
0e1e			 
0e1e			ishlzero:    
0e1e b7				or a     ; reset flags 
0e1f 7c				ld a, h 
0e20 b5				or l        	 
0e21			 
0e21 c9				ret 
0e22			 
0e22			 
0e22			 
0e22			 
0e22			if FORTH_ENABLE_FLOATMATH 
0e22			;include "float/bbcmath.z80" 
0e22			include "float/lpfpcalc.asm" 
0e22			endif 
0e22			 
0e22			 
0e22			; eof 
0e22			 
# End of file firmware_maths.asm
0e22			include "firmware_strings.asm"   ; string handling  
0e22			 
0e22			 
0e22			; TODO string len 
0e22			; input text string, end on cr with zero term 
0e22			; a offset into frame buffer to start prompt 
0e22			; d is max length 
0e22			; e is display size TODO 
0e22			; c is current cursor position 
0e22			; hl is ptr to where string will be stored and edited directly 
0e22			 
0e22			 
0e22			; TODO check limit of buffer for new inserts 
0e22			; TODO check insert does not push beyond buffer 
0e22			; TODO scroll in a limited display area 
0e22			; TODO scroll whole screen on page wrap 
0e22			 
0e22			 
0e22			; TODO use LCD cursor? 
0e22			 
0e22			EDIT_V1: equ 0 
0e22			EDIT_V2: equ 1 
0e22			 
0e22			 
0e22			 
0e22			if EDIT_V2 
0e22			input_str: 
0e22			 
0e22 32 5e ee			    	ld (input_at_pos),a      ; save display position to start 
0e25			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0e25 22 61 ee				ld (input_start), hl     ; save ptr to buffer 
0e28			;		ld a, c 
0e28			;		call addatohl 
0e28			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
0e28 7a					ld a,d 
0e29 32 60 ee			        ld (input_size), a       ; save length of input area 
0e2c 79					ld a, c 
0e2d 32 4f ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
0e30 7b					ld a,e 
0e31 32 5f ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e34			 
0e34			 
0e34					; add a trailing space to make screen refresh nicer 
0e34			 
0e34					;ld hl, (input_start) 
0e34					;push hl 
0e34					;ld a, 0 
0e34					;call strlent 
0e34					;ld a, l 
0e34					;pop hl 
0e34					;call addatohl 
0e34					;dec hl 
0e34					;ld a, ' ' 
0e34					;ld (hl), a 
0e34					;inc hl 
0e34					;ld (hl), a 
0e34					;inc hl 
0e34					;ld a, 0 
0e34					;ld (hl), a 
0e34			 
0e34			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e34					; init cursor shape if not set by the cin routines 
0e34 21 bb eb				ld hl, cursor_shape 
0e37			if BASE_KEV 
0e37					ld a, 255 
0e37			else 
0e37 3e 23				ld a, '#' 
0e39			endif 
0e39 77					ld (hl), a 
0e3a 23					inc hl 
0e3b 3e 00				ld a, 0 
0e3d 77					ld (hl), a 
0e3e			 
0e3e 3e 09				ld a, CUR_BLINK_RATE 
0e40 32 5a ee				ld (input_cur_flash), a 
0e43 3e 01				ld a, 1 
0e45 32 59 ee				ld (input_cur_onoff),a 
0e48			.inmain:	 
0e48			 
0e48 cd 70 0f				call input_disp_ref 
0e4b			 
0e4b					; save current length of string 
0e4b			 
0e4b 2a 61 ee				ld hl, (input_start) 
0e4e 3e 00				ld a, 0 
0e50 cd 66 11				call strlent 
0e53 7d					ld a,l 
0e54 32 54 ee				ld (input_len), a 
0e57			 
0e57					;call input_disp_oncur 
0e57			 
0e57					; display current state of input buffer 
0e57			 
0e57					; clean any backspace chars 
0e57			 
0e57 3e 20				ld a, " " 
0e59 32 bb e2				ld (scratch),a 
0e5c 3e 00				ld a, 0 
0e5e 32 bc e2				ld (scratch+1),a 
0e61 3a 5e ee				ld a,(input_at_pos) 
0e64 85					add l 
0e65 11 bb e2				ld de, scratch 
0e68 cd db 0b				call str_at_display 
0e6b			 
0e6b					; pause 1ms 
0e6b			 
0e6b 3e 01				ld a, 1 
0e6d cd e5 0a				call aDelayInMS 
0e70			 
0e70			; display cursor if visible on this cycle 
0e70			 
0e70					; dec flash counter 
0e70 3a 5a ee				ld a, (input_cur_flash) 
0e73 3d					dec a 
0e74 32 5a ee				ld (input_cur_flash), a 
0e77 fe 00				cp 0 
0e79 20 0d				jr nz, .inochgstate 
0e7b			 
0e7b			 
0e7b					; reset on change of state 
0e7b 3e 09				ld a, CUR_BLINK_RATE 
0e7d 32 5a ee				ld (input_cur_flash), a 
0e80			 
0e80					; change state 
0e80 3a 59 ee				ld a,(input_cur_onoff) 
0e83 ed 44				neg 
0e85 32 59 ee				ld (input_cur_onoff),a 
0e88			 
0e88			 
0e88			 
0e88			 
0e88					; TODO is cursor visible? 
0e88					; TODO if so then over write the char at curspos pos with the cursor shape 
0e88			 
0e88								 
0e88			 
0e88			.inochgstate: 
0e88 3a 59 ee				ld a,(input_cur_onoff) 
0e8b fe ff				cp 255 
0e8d 28 0e				jr z, .skipcursor 
0e8f 3a 5e ee				ld a, (input_at_pos) 
0e92 47					ld b, a 
0e93 3a 4f ee				ld a, (input_cursor) 
0e96 80					add b 
0e97 11 bb eb				ld de, cursor_shape 
0e9a					 
0e9a cd db 0b				call str_at_display 
0e9d			 
0e9d			.skipcursor: 
0e9d				if DEBUG_INPUTV2 
0e9d			 
0e9d					ld a,(input_at_pos) 
0e9d					ld hl, LFSRSeed 
0e9d					call hexout 
0e9d					ld a, (input_cursor) 
0e9d					ld hl, LFSRSeed+2 
0e9d					call hexout 
0e9d					ld a,(input_size) 
0e9d					ld hl, LFSRSeed+4 
0e9d					call hexout 
0e9d			 
0e9d					ld a,(input_cur_onoff) 
0e9d					ld hl, LFSRSeed+6 
0e9d					call hexout 
0e9d			 
0e9d					ld a,(input_cur_flash) 
0e9d					ld hl, LFSRSeed+8 
0e9d					call hexout 
0e9d			 
0e9d					ld a,(input_len) 
0e9d					ld hl, LFSRSeed+10 
0e9d					call hexout 
0e9d					ld hl, LFSRSeed+12 
0e9d					ld a, 0 
0e9d					ld (hl),a 
0e9d					ld a, display_row_4 
0e9d					ld de, LFSRSeed 
0e9d					call str_at_display 
0e9d				endif 
0e9d cd eb 0b				call update_display 
0ea0			 
0ea0					; TODO keyboard processing 
0ea0			 
0ea0			if BASE_CPM 
0ea0 cd f1 5e				call cin_wait 
0ea3			else 
0ea3					call cin    ; _wait 
0ea3			endif 
0ea3 fe 00				cp 0 
0ea5 ca 48 0e				jp z, .inmain 
0ea8			 
0ea8 fe 0b				cp KEY_LEFT    ; cursor left 
0eaa ca 62 0f				jp z, input_left 
0ead				 
0ead fe 0c				cp KEY_RIGHT      ; cursor right 
0eaf ca 69 0f				jp z, input_right 
0eb2			 
0eb2 fe 0d				cp KEY_CR 
0eb4 c8					ret z 
0eb5			 
0eb5 fe 08				cp KEY_BS 
0eb7 ca d7 0f				jp z, input_delchar 
0eba			 
0eba fe 06				cp KEY_NEXTWORD 
0ebc ca e3 0e				jp z, input_nxtword 
0ebf			 
0ebf fe 07				cp KEY_PREVWORD 
0ec1 ca 0a 0f				jp z, input_prvword 
0ec4			 
0ec4 fe 0e				cp KEY_HOME    ; jump to start of line 
0ec6 20 08				jr nz, .ikh 
0ec8 3e 00				ld a, 0 
0eca 32 4f ee				ld (input_cursor), a 
0ecd ca 48 0e				jp z, .inmain 
0ed0			.ikh: 
0ed0			 
0ed0 fe 0f				cp KEY_END     ; jump to end of line 
0ed2 20 09				jr nz, .ike 
0ed4 3a 54 ee				ld a, (input_len) 
0ed7 32 4f ee				ld (input_cursor),a 
0eda ca 48 0e				jp z, .inmain 
0edd			.ike: 
0edd fe 05			        cp KEY_UP      ; recall last command 
0edf c8					ret z 
0ee0			;jr nz, .irec 
0ee0			; TODO next word 
0ee0			; TODO prev word 
0ee0			;  
0ee0			; 
0ee0			;	ld hl, scratch 
0ee0			;	ld de, os_last_cmd 
0ee0			;	call strcpy 
0ee0			;		jp  .inmain 
0ee0			.irec: 
0ee0			;		jr .instr1 
0ee0			 
0ee0			 
0ee0			 
0ee0					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
0ee0			 
0ee0			; TODO return if any special keys are given 
0ee0			;		ld l, a 
0ee0			;		ld a, 28 ; KEY_F12   ; 27 
0ee0			;		sub l 
0ee0			;		ret m 
0ee0			;		ld a, l 
0ee0					; if no special key then insert as a char 
0ee0			 
0ee0 c3 a9 0f				jp input_inschr 
0ee3			 
0ee3				 
0ee3			input_nxtword: 
0ee3				; jump to start next word after the cursor 
0ee3			 
0ee3			.insknwn:	 
0ee3 cd 9f 0f				call input_curptr	 
0ee6 7e					ld a,(hl)	 
0ee7 fe 00				cp 0 
0ee9 ca 48 0e				jp z, .inmain    ; end of string 
0eec			 
0eec			; if we are on a word, then move off of it 
0eec			 
0eec fe 20				cp ' ' 
0eee 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
0ef0 21 4f ee				ld hl, input_cursor 
0ef3 34					inc (hl) 
0ef4 18 ed				jr .insknwn 
0ef6			 
0ef6			.inspace: 
0ef6			 
0ef6 cd 9f 0f				call input_curptr	 
0ef9 7e					ld a,(hl)	 
0efa fe 00				cp 0 
0efc ca 48 0e				jp z, .inmain    ; end of string 
0eff			 
0eff			; if we are on a word, then move off of it 
0eff			 
0eff fe 20				cp ' ' 
0f01 c2 48 0e				jp nz, .inmain     ; we are on non space so at next word 
0f04 21 4f ee				ld hl, input_cursor 
0f07 34					inc (hl) 
0f08 18 ec				jr .inspace 
0f0a			 
0f0a			 
0f0a			 
0f0a			 
0f0a			input_prvword: 
0f0a				; jump to the start of previous word before the cursor 
0f0a			 
0f0a			; where are we to start with currently? 
0f0a			 
0f0a cd 9f 0f				call input_curptr	 
0f0d 7e					ld a, (hl) 
0f0e fe 20				cp ' ' 
0f10 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
0f12			 
0f12			 
0f12			 
0f12			.inskpwn:	 
0f12 3a 4f ee				ld a,(input_cursor) 
0f15 fe 00				cp 0 
0f17 ca 48 0e				jp z, .inmain    ; start of string 
0f1a			 
0f1a			;if we are on a word, then move off of it 
0f1a			 
0f1a cd 9f 0f				call input_curptr	 
0f1d 7e					ld a, (hl) 
0f1e fe 20				cp ' ' 
0f20 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
0f22					;jp z, .inmain    ; start of string 
0f22 21 4f ee				ld hl, input_cursor 
0f25 35					dec (hl) 
0f26 18 ea				jr .inskpwn 
0f28			.iwstart: 
0f28 21 4f ee				ld hl, input_cursor 
0f2b 34					inc (hl) 
0f2c c3 48 0e				jp .inmain 
0f2f					 
0f2f			 
0f2f			.inspacep: 
0f2f			 
0f2f					;jp .inmain    ; start of string 
0f2f			 
0f2f			 
0f2f			 
0f2f 3a 4f ee				ld a,(input_cursor) 
0f32 fe 00				cp 0 
0f34 ca 48 0e				jp z, .inmain    ; start of string 
0f37			 
0f37			; if we are on a word, then move off of it 
0f37			 
0f37 cd 9f 0f				call input_curptr	 
0f3a 7e					ld a, (hl) 
0f3b fe 20				cp ' ' 
0f3d c2 46 0f				jp nz, .incharp     ; we are on non space so at end of prev word 
0f40 21 4f ee				ld hl, input_cursor 
0f43 35					dec (hl) 
0f44 18 e9				jr .inspacep 
0f46			 
0f46			 
0f46			.incharp:	 
0f46					; eat the word to get to the start 
0f46 3a 4f ee				ld a,(input_cursor) 
0f49 fe 00				cp 0 
0f4b ca 48 0e				jp z, .inmain    ; start of string 
0f4e			 
0f4e			; if we are on a word, then move off of it 
0f4e			 
0f4e cd 9f 0f				call input_curptr	 
0f51 7e					ld a, (hl) 
0f52 fe 20				cp ' ' 
0f54 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
0f56 21 4f ee				ld hl, input_cursor 
0f59 35					dec (hl) 
0f5a 18 ea				jr .incharp 
0f5c			.ipwordst: 
0f5c					; at space before the prev word so reposition over it 
0f5c 21 4f ee				ld hl, input_cursor 
0f5f 34					inc (hl) 
0f60 18 b0				jr .inskpwn 
0f62					 
0f62			 
0f62			 
0f62			input_left: 
0f62				; move cursor left 
0f62 21 4f ee			ld hl, input_cursor 
0f65 35				dec (hl) 
0f66			;	cp 0 
0f66			;	jp z, .inmain    ; ignore left as at the start of the string 
0f66 c3 48 0e			jp .inmain 
0f69			 
0f69			input_right: 
0f69				; move cursor right 
0f69				 
0f69				;ld a, (input_size) 
0f69				;ld b, a 
0f69 21 4f ee			ld hl, input_cursor 
0f6c 34				inc (hl) 
0f6d				;dec b 
0f6d				;cp 0 
0f6d				;jp z, .inmain   ; ignore as at end of the string buffer 
0f6d				;ld a, b 
0f6d				;inc a 
0f6d				;ld (input_cursor), a 
0f6d c3 48 0e			jp .inmain 
0f70			 
0f70			 
0f70			 
0f70			input_disp_ref: 
0f70				; display the text from start of buffer (ie full refresh) 
0f70 3a 5e ee			ld a, (input_at_pos) 
0f73 2a 61 ee			ld hl,(input_start) 
0f76 eb				ex de, hl 
0f77 cd db 0b			call str_at_display  
0f7a c9				ret 
0f7b			input_disp_oncur: 
0f7b				; display the text from cursor position to end of buffer 
0f7b				; TODO position start of string at cursor position on screen 
0f7b				; TODO draw from that point on 
0f7b 3a 4f ee			ld a, (input_cursor) 
0f7e 47				ld b, a 
0f7f 3a 5e ee			ld a, (input_at_pos) 
0f82 80				add b 
0f83 48				ld c, b     ; save a 
0f84 78				ld a, b     ; inc string start for cursor 
0f85 2a 61 ee			ld hl,(input_start) 
0f88 cd f5 0d			call addatohl 
0f8b eb				ex de, hl 
0f8c 79				ld a, c 
0f8d cd db 0b			call str_at_display  
0f90 c9				ret 
0f91			 
0f91			input_nxtw: 
0f91				; Find next word 
0f91 c9				ret 
0f92			 
0f92			input_prvw: 
0f92				; Find previous word 
0f92 c9				ret 
0f93			 
0f93			input_lenrem:   
0f93				; Calculate the length of string remaining from current cursor 
0f93				; position to end of buffer (exc null term) 
0f93				 
0f93 3a 4f ee			ld a, (input_cursor) 
0f96 4f				ld c, a 
0f97 3a 60 ee			ld a, (input_size) 
0f9a 91				sub c 
0f9b 06 00			ld b, 0 
0f9d 0d				dec c 
0f9e c9				ret	 
0f9f			 
0f9f			input_curptr: 
0f9f				; calc address of the character under the cursor 
0f9f				 
0f9f 2a 61 ee			ld hl, (input_start) 
0fa2 3a 4f ee			ld a, (input_cursor) 
0fa5 cd f5 0d			call addatohl 
0fa8 c9				ret 
0fa9			 
0fa9			input_inschr: 
0fa9				; Insert char at cursor position 
0fa9 f5				push af   ; save char 
0faa				;call input_lenrem    ; get bc length of remaining string 
0faa			 
0faa				 
0faa cd 9f 0f			call input_curptr 
0fad			;	ld hl, (input_start) 
0fad			;	ld a, (input_cursor) 
0fad			;	call addatohl 
0fad				;push hl   ; save to come back to 
0fad			 
0fad				; shift everything up one to end of buffer 
0fad			 
0fad				;push hl 
0fad				;dec de 
0fad				;inc de 
0fad			;	ldir 
0fad				 
0fad				;pop hl 
0fad			 
0fad				; are we adding to the end of line? 
0fad			 
0fad 3a 4f ee			ld a, (input_cursor) 
0fb0 47				ld b, a 
0fb1 3a 54 ee			ld a, (input_len) 
0fb4 b8				cp b 
0fb5 20 09			jr nz, .insmid   ; no, insert in middle of text 
0fb7			 
0fb7				; tack on the end of the line 
0fb7 f1				pop af 
0fb8 77				ld (hl), a   ; save new char 
0fb9 23				inc hl 
0fba 3e 00			ld a, 0 
0fbc 77				ld (hl), a 
0fbd c3 69 0f			jp input_right 
0fc0				 
0fc0			.insmid: 
0fc0				; hl has insertion point so move everything up one to allow for insertion 
0fc0				;call input_shiftright 
0fc0 f1				pop af 
0fc1			 
0fc1			.shufinsmid: 
0fc1 47				ld b, a     ; b contains new char, c prev char at this position  
0fc2 7e				ld a, (hl) 
0fc3			 
0fc3 fe 00			cp 0    ; at end of string need to then dump new char and add term 
0fc5 28 07			jr z, .endinsmid 
0fc7 4f				ld c, a 
0fc8 78				ld a, b 
0fc9 77				ld (hl), a 
0fca 23				inc hl 
0fcb 79				ld a, c 
0fcc 18 f3			jr .shufinsmid 
0fce				 
0fce			 
0fce			 
0fce			 
0fce			.endinsmid: 
0fce 78				ld a, b 
0fcf 77				ld (hl), a 
0fd0 23				inc hl 
0fd1 3e 00			ld a, 0 
0fd3 77				ld (hl), a 
0fd4			 
0fd4			 
0fd4			;	ld (hl), a   ; save new char 
0fd4			 
0fd4 c3 69 0f			jp input_right 
0fd7			 
0fd7			;input_shiftright: 
0fd7			;	; shift text right at cursor, hl has shift start 
0fd7			;	push hl 
0fd7			;	push de 
0fd7			;	push bc 
0fd7			; 
0fd7			; 
0fd7			;	; move to end of string past zero term 
0fd7			;	ld hl,(input_start) 
0fd7			;	ld a, (input_len) 
0fd7			;	call addatohl 
0fd7			;	inc hl 
0fd7			;;	inc hl 
0fd7			;;	inc hl 
0fd7			;	ld a, 0 
0fd7			;	ld (hl), a 
0fd7			;;	dec hl 
0fd7			;	 
0fd7			;;	ld (hl), a 
0fd7			;;	dec hl 
0fd7			; 
0fd7			;	push hl 
0fd7			;	pop de 
0fd7			;	inc de 
0fd7			;	 
0fd7			; 
0fd7			;;	ld hl,(input_start) 
0fd7			;;	ld a, (input_cursor) 
0fd7			;;	call addatohl 
0fd7			; 
0fd7			; 
0fd7			;	; calc how many bytes from cursor pos to end of string we need to shift 
0fd7			;	call input_lenrem    ; get bc length of remaining string 
0fd7			;	;ld a, (input_cursor) 
0fd7			;	;ld c, a 
0fd7			;	ld a, (input_len) 
0fd7			;	cp 2 
0fd7			;	jr z, .iskipzero	 
0fd7			;	;sub c 
0fd7			;	;inc a 
0fd7			;	;ld c, a 
0fd7			;	;ld b, 0 
0fd7			;	inc c 
0fd7			;	inc c 
0fd7			;	; move data 
0fd7			;	lddr 
0fd7			;.iskipzero: 
0fd7			; 
0fd7			;	pop bc 
0fd7			;	pop de 
0fd7			;	pop hl 
0fd7			;	ret	 
0fd7			 
0fd7			input_delchar: 
0fd7				; Delete char at cursor position 
0fd7 cd 93 0f			call input_lenrem    ; get bc length of remaining string 
0fda 2a 61 ee			ld hl, (input_start) 
0fdd 3a 4f ee			ld a, (input_cursor) 
0fe0 cd f5 0d			call addatohl 
0fe3			 
0fe3 e5				push hl 
0fe4 d1				pop de 
0fe5 1b				dec de 
0fe6			 
0fe6			.dl:	 
0fe6 ed a0			ldi  
0fe8 7e				ld a, (hl) 
0fe9 fe 00			cp 0 
0feb 28 02			jr z, .dldone 
0fed 18 f7			jr .dl 
0fef			.dldone: 
0fef ed a0			ldi 
0ff1			 
0ff1 c3 62 0f			jp input_left 
0ff4			 
0ff4			 
0ff4			endif 
0ff4			 
0ff4			 
0ff4			 
0ff4			if EDIT_V1 
0ff4			input_str: 
0ff4			 
0ff4				    	ld (input_at_pos),a      ; save display position to start 
0ff4					add c 
0ff4					ld (input_at_cursor),a	; save draw pos of cursor 
0ff4					ld (input_start), hl     ; save ptr to buffer 
0ff4					ld a, c 
0ff4					call addatohl 
0ff4					ld (input_ptr), hl     ; save ptr to point under the cursor 
0ff4					ld a,d 
0ff4				        ld (input_size), a       ; save length of input area 
0ff4					ld a, c 
0ff4					ld (input_cursor),a      ; init cursor start position  
0ff4					ld a,e 
0ff4				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0ff4					 
0ff4					 
0ff4			 
0ff4			;		ld a,(input_ptr) 
0ff4			;		ld (input_under_cursor),a 	; save what is under the cursor 
0ff4			 
0ff4			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0ff4					; init cursor shape if not set by the cin routines 
0ff4					ld hl, cursor_shape 
0ff4			if BASE_KEV 
0ff4					ld a, 255 
0ff4			else 
0ff4					ld a, '#' 
0ff4			endif 
0ff4					ld (hl), a 
0ff4					inc hl 
0ff4					ld a, 0 
0ff4					ld (hl), a 
0ff4			 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4					ld a, 1 
0ff4					ld (input_cur_onoff),a 
0ff4			 
0ff4			;	if DEBUG_INPUT 
0ff4			;		push af 
0ff4			;		ld a, 'I' 
0ff4			;		ld (debug_mark),a 
0ff4			;		pop af 
0ff4			;		CALLMONITOR 
0ff4			;	endif 
0ff4			.is1:		; main entry loop 
0ff4			 
0ff4			 
0ff4			 
0ff4					; pause 1ms 
0ff4			 
0ff4					ld a, 1 
0ff4					call aDelayInMS 
0ff4			 
0ff4					; dec flash counter 
0ff4					ld a, (input_cur_flash) 
0ff4					dec a 
0ff4					ld (input_cur_flash), a 
0ff4					cp 0 
0ff4					jr nz, .nochgstate 
0ff4			 
0ff4			 
0ff4					; change state 
0ff4					ld a,(input_cur_onoff) 
0ff4					neg 
0ff4					ld (input_cur_onoff),a 
0ff4			 
0ff4			 
0ff4					; reset on change of state 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4			 
0ff4			.nochgstate: 
0ff4					 
0ff4					 
0ff4			 
0ff4					; display cursor  
0ff4			 
0ff4			;		ld hl, (input_start) 
0ff4			;		ld a, (input_cursor) 
0ff4			;		call addatohl 
0ff4			 
0ff4					; get char under cursor and replace with cursor 
0ff4			ld hl, (input_ptr) 
0ff4			;		ld a, (hl) 
0ff4			;		ld (input_under_cursor),a 
0ff4			;		ld a, '_' 
0ff4			;		ld (hl), a 
0ff4			 
0ff4					; display string 
0ff4			 
0ff4					ld de, (input_start) 
0ff4					ld a, (input_at_pos) 
0ff4					call str_at_display 
0ff4			;	        call update_display 
0ff4			 
0ff4					; find place to put the cursor 
0ff4			;		add h 
0ff4			;		ld l, display_row_1 
0ff4			;		sub l 
0ff4			; (input_at_pos) 
0ff4					;ld c, a 
0ff4			;		ld a, (input_cursor) 
0ff4			;		ld l, (input_at_pos) 
0ff4			;		;ld b, h 
0ff4			;		add l 
0ff4			;		ld (input_at_cursor),a 
0ff4					;ld l,h 
0ff4			 
0ff4			;		ld h, 0 
0ff4			;		ld l,(input_at_pos) 
0ff4			;		ld a, (input_cursor) 
0ff4			;		call addatohl 
0ff4			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0ff4			;		call subafromhl 
0ff4			;		ld a,l 
0ff4			;		ld (input_at_cursor), a 
0ff4			 
0ff4				if DEBUG_INPUT 
0ff4					ld a, (hardware_diag) 
0ff4					cp 0 
0ff4					jr z, .skip_input_diag 
0ff4			 
0ff4					ld a,(input_at_pos) 
0ff4					ld hl, LFSRSeed 
0ff4					call hexout 
0ff4					ld a, (input_cursor) 
0ff4					ld hl, LFSRSeed+2 
0ff4					call hexout 
0ff4					ld a,(input_at_cursor) 
0ff4					ld hl, LFSRSeed+4 
0ff4					call hexout 
0ff4			 
0ff4					ld a,(input_cur_onoff) 
0ff4					ld hl, LFSRSeed+6 
0ff4					call hexout 
0ff4			 
0ff4					ld a,(input_cur_flash) 
0ff4					ld hl, LFSRSeed+8 
0ff4					call hexout 
0ff4			 
0ff4					ld a,(input_len) 
0ff4					ld hl, LFSRSeed+10 
0ff4					call hexout 
0ff4					ld hl, LFSRSeed+12 
0ff4					ld a, 0 
0ff4					ld (hl),a 
0ff4					ld a, display_row_4 
0ff4					ld de, LFSRSeed 
0ff4					call str_at_display 
0ff4					.skip_input_diag: 
0ff4				endif 
0ff4			 
0ff4					; decide on if we are showing the cursor this time round 
0ff4			 
0ff4					ld a, (input_cur_onoff) 
0ff4					cp 255 
0ff4					jr z, .skipcur 
0ff4			 
0ff4			 
0ff4					ld a,(input_at_cursor) 
0ff4					ld de, cursor_shape 
0ff4					call str_at_display 
0ff4			 
0ff4					; save length of current input string 
0ff4					ld hl, (input_start) 
0ff4					ld a, 0 
0ff4					call strlent 
0ff4					ld a,l 
0ff4					ld (input_len),a 
0ff4			 
0ff4			.skipcur: 
0ff4			 
0ff4				        call update_display 
0ff4					 
0ff4			 
0ff4			 
0ff4					; wait 
0ff4				 
0ff4					; TODO loop without wait to flash the cursor and char under cursor	 
0ff4					call cin    ; _wait 
0ff4			 
0ff4					cp 0 
0ff4					jp z, .is1 
0ff4			 
0ff4					; get ptr to char to input into 
0ff4			 
0ff4					ld c,a 
0ff4					ld hl, (input_start) 
0ff4					ld a, (input_cursor) 
0ff4					call addatohl 
0ff4					ld (input_ptr), hl 
0ff4					ld a,c 
0ff4			 
0ff4					; replace char under cursor 
0ff4			 
0ff4			;		ld hl, (input_ptr) 
0ff4			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ff4			;		ld (hl), a 
0ff4			 
0ff4			;	if DEBUG_INPUT 
0ff4			;		push af 
0ff4			;		ld a, 'i' 
0ff4			;		ld (debug_mark),a 
0ff4			;		pop af 
0ff4			;		CALLMONITOR 
0ff4			;	endif 
0ff4					cp KEY_HOME 
0ff4					jr nz, .iske 
0ff4			 
0ff4					ld a, (input_at_pos) 
0ff4					ld (input_at_cursor),a 
0ff4					ld a, 0 
0ff4					ld (input_cursor), a 
0ff4					jp .is1 
0ff4					 
0ff4			.iske:		cp KEY_END 
0ff4					jr nz, .isknw 
0ff4					jp .is1 
0ff4			 
0ff4			.isknw:		cp KEY_NEXTWORD 
0ff4					jr nz, .iskpw 
0ff4			 
0ff4			.isknwm:	ld hl, (input_ptr) 
0ff4					ld a,(hl)	 
0ff4					cp 0 
0ff4					jp z, .is1    ; end of string 
0ff4					cp ' ' 
0ff4					jp z, .is1    ; end of word 
0ff4					inc hl 
0ff4					ld (input_ptr), hl 
0ff4					ld a, (input_at_cursor) 
0ff4					inc a 
0ff4					ld (input_at_cursor), a 
0ff4					jr .isknwm 
0ff4			 
0ff4			.iskpw:		cp KEY_PREVWORD 
0ff4					jr nz, .iskl 
0ff4			.iskpwm:	 
0ff4					ld hl, (input_ptr) 
0ff4					ld a,(hl)	 
0ff4					cp 0  
0ff4					jp z, .is1    ; end of string 
0ff4					cp ' ' 
0ff4					jp z, .is1    ; end of word 
0ff4					dec hl 
0ff4					ld (input_ptr), hl 
0ff4					ld a, (input_at_cursor) 
0ff4					dec a 
0ff4					ld (input_at_cursor), a 
0ff4					jr .iskpwm 
0ff4			 
0ff4			 
0ff4			.iskl:		cp KEY_LEFT 
0ff4					jr nz, .isk1 
0ff4			 
0ff4					ld a, (input_cursor) 
0ff4			 
0ff4					cp 0 
0ff4					jp z, .is1 		; at start of line to ignore  
0ff4			 
0ff4					dec  a 		; TODO check underflow 
0ff4					ld (input_cursor), a 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					dec hl 
0ff4					ld (input_ptr), hl 
0ff4					 
0ff4					ld a, (input_at_cursor) 
0ff4					dec a 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4					ld a, 1		; show cursor moving 
0ff4					ld (input_cur_onoff),a 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4			 
0ff4					jp .is1 
0ff4			 
0ff4			.isk1:		cp KEY_RIGHT 
0ff4					jr nz, .isk2 
0ff4			 
0ff4					ld a,(input_len)		; TODO BUG why cant i load e direct? 
0ff4					ld e,a 
0ff4					ld a, (input_cursor) 
0ff4					cp e 
0ff4					jp z, .is1		; at the end of string so dont go right 
0ff4			 
0ff4					inc  a 		; TODO check overflow 
0ff4					ld (input_cursor), a 
0ff4			 
0ff4					ld a, (input_at_cursor) 
0ff4					inc a 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					inc hl 
0ff4					ld (input_ptr), hl 
0ff4			 
0ff4					ld a, 1		; show cursor moving 
0ff4					ld (input_cur_onoff),a 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4			 
0ff4					jp .is1 
0ff4			 
0ff4			.isk2:		cp KEY_UP 
0ff4			 
0ff4					jr nz, .isk3 
0ff4			 
0ff4					; swap last command with the current on 
0ff4			 
0ff4					; move cursor to start of string 
0ff4					ld hl, (input_start) 
0ff4					ld (input_ptr), hl 
0ff4			 
0ff4					ld a, (input_at_pos) 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4					ld a, 0 
0ff4					ld (input_cursor), a 
0ff4					 
0ff4					; swap input and last command buffers 
0ff4			 
0ff4					ld hl, os_cli_cmd 
0ff4					ld de, os_last_cmd 
0ff4					ld b, 255 
0ff4			.swap1:		ld a, (hl) 
0ff4					ld c,a 
0ff4					ld a, (de) 
0ff4					ld (hl), a 
0ff4					ld a,c 
0ff4					ld (de),a 
0ff4					inc hl 
0ff4					inc de 
0ff4					djnz .swap1 
0ff4			 
0ff4			 
0ff4			 
0ff4			 
0ff4			 
0ff4					jp .is1 
0ff4			 
0ff4			.isk3:		cp KEY_BS 
0ff4					jr nz, .isk4 
0ff4			 
0ff4					ld a, (input_cursor) 
0ff4			 
0ff4					cp 0 
0ff4					jp z, .is1 		; at start of line to ignore  
0ff4			 
0ff4					dec  a 		; TODO check underflow 
0ff4					ld (input_cursor), a 
0ff4			 
0ff4					; hl is source 
0ff4					; de needs to be source - 1 
0ff4			 
0ff4			;		ld a, 0 
0ff4			;		dec hl 
0ff4			;		ld (hl), a 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					dec hl 
0ff4					ld (input_ptr), hl 
0ff4			 
0ff4					; shift all data 
0ff4			 
0ff4					push hl 
0ff4					inc hl 
0ff4					pop de 
0ff4					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0ff4					ld c,a 
0ff4					ld b,0 
0ff4					ldir  
0ff4			 
0ff4			 
0ff4			 
0ff4			 
0ff4					ld a, (input_at_cursor) 
0ff4					dec a 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4			 
0ff4					ld a, 1		; show cursor moving 
0ff4					ld (input_cur_onoff),a 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4			 
0ff4					; remove char 
0ff4					ld a, (input_at_cursor) 
0ff4					inc a 
0ff4					ld de,.iblank 
0ff4					call str_at_display 
0ff4			 
0ff4					jp .is1 
0ff4			 
0ff4			.isk4:		cp KEY_CR 
0ff4					jr z, .endinput 
0ff4			 
0ff4					; else add the key press to the end 
0ff4			 
0ff4					ld c, a			; save key pressed 
0ff4			 
0ff4					ld a,(hl)		; get what is currently under char 
0ff4			 
0ff4					cp 0			; we are at the end of the string 
0ff4					jr nz, .onchar 
0ff4					 
0ff4					; add a char to the end of the string 
0ff4				 
0ff4					ld (hl),c 
0ff4					inc hl 
0ff4			;		ld a,' ' 
0ff4			;		ld (hl),a 
0ff4			;		inc hl 
0ff4					ld a,0 
0ff4					ld (hl),a 
0ff4					dec hl 
0ff4			 
0ff4					ld a, (input_cursor) 
0ff4					inc a				; TODO check max string length and scroll  
0ff4					ld (input_cursor), a		; inc cursor pos 
0ff4							 
0ff4					ld a, (input_at_cursor) 
0ff4					inc a 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					inc hl 
0ff4					ld (input_ptr), hl 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					inc hl 
0ff4					ld (input_ptr), hl 
0ff4			;	if DEBUG_INPUT 
0ff4			;		push af 
0ff4			;		ld a, '+' 
0ff4			;		ld (debug_mark),a 
0ff4			;		pop af 
0ff4			;		CALLMONITOR 
0ff4			;	endif 
0ff4					ld a, 1		; show cursor moving 
0ff4					ld (input_cur_onoff),a 
0ff4					ld a, CUR_BLINK_RATE 
0ff4					ld (input_cur_flash), a 
0ff4					jp .is1 
0ff4					 
0ff4			 
0ff4			 
0ff4					; if on a char then insert 
0ff4			.onchar: 
0ff4			 
0ff4					; TODO over flow check: make sure insert does not blow out buffer 
0ff4			 
0ff4					; need to do some maths to use lddr 
0ff4			 
0ff4					push hl   ; save char pos 
0ff4					push bc 
0ff4			 
0ff4					ld hl, (input_start) 
0ff4					ld a, (input_len) 
0ff4					call addatohl  		; end of string 
0ff4					inc hl 
0ff4					inc hl		; past zero term 
0ff4					push hl 
0ff4					inc hl 
0ff4					push hl  
0ff4			 
0ff4								; start and end of lddr set, now how much to move? 
0ff4			 
0ff4							 
0ff4					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0ff4					ld b,a 
0ff4					ld a,(input_len) 
0ff4					ld e,a 
0ff4					sub b 
0ff4					inc a		;?? 
0ff4					inc a		;?? 
0ff4					inc a		;?? 
0ff4			 
0ff4					ld b,0 
0ff4					ld c,a 
0ff4			 
0ff4				if DEBUG_INPUT 
0ff4					push af 
0ff4					ld a, 'i' 
0ff4					ld (debug_mark),a 
0ff4					pop af 
0ff4			;		CALLMONITOR 
0ff4				endif 
0ff4					pop de 
0ff4					pop hl 
0ff4				if DEBUG_INPUT 
0ff4					push af 
0ff4					ld a, 'I' 
0ff4					ld (debug_mark),a 
0ff4					pop af 
0ff4			;		CALLMONITOR 
0ff4				endif 
0ff4					lddr 
0ff4				 
0ff4			 
0ff4			 
0ff4					; TODO have a key for insert/overwrite mode???? 
0ff4					pop bc 
0ff4					pop hl 
0ff4					ld (hl), c		; otherwise overwrite current char 
0ff4					 
0ff4			 
0ff4			 
0ff4			 
0ff4					ld a, (input_cursor) 
0ff4					inc  a 		; TODO check overflow 
0ff4					ld (input_cursor), a 
0ff4			 
0ff4					ld a, (input_at_cursor) 
0ff4					inc a 
0ff4					ld (input_at_cursor), a 
0ff4			 
0ff4					jp .is1 
0ff4			 
0ff4			.endinput:	; TODO look for end of string 
0ff4			 
0ff4					; add trailing space for end of token 
0ff4			 
0ff4					ld hl, (input_start) 
0ff4					ld a,(input_len) 
0ff4					call addatohl 
0ff4					ld a, ' ' 
0ff4					ld (hl),a 
0ff4					; TODO eof of parse marker 
0ff4			 
0ff4					inc hl 
0ff4					ld a, 0 
0ff4					ld (hl),a 
0ff4			 
0ff4			 
0ff4					ret 
0ff4			 
0ff4			.iblank: db " ",0 
0ff4			 
0ff4			 
0ff4			input_str_prev:	ld (input_at_pos), a 
0ff4					ld (input_start), hl 
0ff4					ld a,1			; add cursor 
0ff4					ld (hl),a 
0ff4					inc hl 
0ff4					ld a,0 
0ff4					ld (hl),a 
0ff4					ld (input_ptr), hl 
0ff4					ld a,d 
0ff4					ld (input_size), a 
0ff4					ld a,0 
0ff4					ld (input_cursor),a 
0ff4			.instr1:	 
0ff4			 
0ff4					; TODO do block cursor 
0ff4					; TODO switch cursor depending on the modifer key 
0ff4			 
0ff4					; update cursor shape change on key hold 
0ff4			 
0ff4					ld hl, (input_ptr) 
0ff4					dec hl 
0ff4					ld a,(cursor_shape) 
0ff4					ld (hl), a 
0ff4			 
0ff4					; display entered text 
0ff4					ld a,(input_at_pos) 
0ff4			            	CALL fLCD_Pos       ;Position cursor to location in A 
0ff4			            	LD   de, (input_start) 
0ff4			            	CALL fLCD_Str       ;Display string pointed to by DE 
0ff4			 
0ff4					call cin 
0ff4					cp 0 
0ff4					jr z, .instr1 
0ff4			 
0ff4					; proecess keyboard controls first 
0ff4			 
0ff4					ld hl,(input_ptr) 
0ff4			 
0ff4					cp KEY_CR	 ; pressing enter ends input 
0ff4					jr z, .instrcr 
0ff4			 
0ff4					cp KEY_BS 	; back space 
0ff4					jr nz, .instr2 
0ff4					; process back space 
0ff4			 
0ff4					; TODO stop back space if at start of string 
0ff4					dec hl 
0ff4					dec hl ; to over write cursor 
0ff4					ld a,(cursor_shape) 
0ff4					;ld a,0 
0ff4					ld (hl),a 
0ff4					inc hl 
0ff4					ld a," " 
0ff4					ld (hl),a 
0ff4					ld (input_ptr),hl 
0ff4					 
0ff4			 
0ff4					jr .instr1 
0ff4			 
0ff4			.instr2:	cp KEY_LEFT    ; cursor left 
0ff4					jr nz, .instr3 
0ff4					dec hl 
0ff4					ld (input_ptr),hl 
0ff4					jr .instr1 
0ff4				 
0ff4			.instr3:	cp KEY_RIGHT      ; cursor right 
0ff4					jr nz, .instr4 
0ff4					inc hl 
0ff4					ld (input_ptr),hl 
0ff4					jr .instr1 
0ff4			 
0ff4			.instr4:	cp KEY_HOME    ; jump to start of line 
0ff4					jr nz, .instr5 
0ff4					dec hl 
0ff4					ld (input_ptr),hl 
0ff4					jr .instr1 
0ff4			 
0ff4			.instr5:	cp KEY_END     ; jump to end of line 
0ff4					jr nz, .instr6 
0ff4					dec hl 
0ff4					ld (input_ptr),hl 
0ff4					jr .instr1 
0ff4			.instr6:        cp KEY_UP      ; recall last command 
0ff4					jr nz, .instrnew 
0ff4			 
0ff4				ld hl, scratch 
0ff4				ld de, os_last_cmd 
0ff4				call strcpy 
0ff4					jr .instr1 
0ff4			 
0ff4			 
0ff4			.instrnew:	; no special key pressed to see if we have room to store it 
0ff4			 
0ff4					; TODO do string size test 
0ff4			 
0ff4					dec hl ; to over write cursor 
0ff4					ld (hl),a 
0ff4					inc hl 
0ff4					ld a,(cursor_shape) 
0ff4					ld (hl),a 
0ff4					inc hl 
0ff4					ld a,0 
0ff4					ld (hl),a 
0ff4			 
0ff4					ld (input_ptr),hl 
0ff4					 
0ff4					jr .instr1 
0ff4			.instrcr:	dec hl		; remove cursor 
0ff4					ld a,' '	; TODO add a trailing space for safety 
0ff4					ld (hl),a 
0ff4					inc hl 
0ff4					ld a,0 
0ff4					ld (hl),a 
0ff4			 
0ff4			 
0ff4					; if at end of line scroll up    
0ff4					; TODO detecting only end of line 4 for scroll up  
0ff4			 
0ff4					;ld   
0ff4			 
0ff4					ret 
0ff4			 
0ff4			 
0ff4			endif 
0ff4			; strcpy hl = dest, de source 
0ff4			 
0ff4 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0ff5 b7			            OR   A              ;Null terminator? 
0ff6 c8			            RET  Z              ;Yes, so finished 
0ff7 1a					ld a,(de) 
0ff8 77					ld (hl),a 
0ff9 13			            INC  DE             ;Point to next character 
0ffa 23					inc hl 
0ffb 18 f7		            JR   strcpy       ;Repeat 
0ffd c9					ret 
0ffe			 
0ffe			 
0ffe			; TODO string_at  
0ffe			; pass string which starts with lcd offset address and then null term string 
0ffe			 
0ffe			; TODO string to dec 
0ffe			; TODO string to hex 
0ffe			; TODO byte to string hex 
0ffe			; TODO byte to string dec 
0ffe			 
0ffe			 
0ffe			 
0ffe			; from z80uartmonitor 
0ffe			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ffe			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0ffe			; pass hl for where to put the text 
0ffe			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0ffe c5			hexout:	PUSH BC 
0fff f5					PUSH AF 
1000 47					LD B, A 
1001					; Upper nybble 
1001 cb 3f				SRL A 
1003 cb 3f				SRL A 
1005 cb 3f				SRL A 
1007 cb 3f				SRL A 
1009 cd 19 10				CALL tohex 
100c 77					ld (hl),a 
100d 23					inc hl	 
100e					 
100e					; Lower nybble 
100e 78					LD A, B 
100f e6 0f				AND 0FH 
1011 cd 19 10				CALL tohex 
1014 77					ld (hl),a 
1015 23					inc hl	 
1016					 
1016 f1					POP AF 
1017 c1					POP BC 
1018 c9					RET 
1019					 
1019			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1019			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1019			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1019			tohex: 
1019 e5					PUSH HL 
101a d5					PUSH DE 
101b 16 00				LD D, 0 
101d 5f					LD E, A 
101e 21 26 10				LD HL, .DATA 
1021 19					ADD HL, DE 
1022 7e					LD A, (HL) 
1023 d1					POP DE 
1024 e1					POP HL 
1025 c9					RET 
1026			 
1026			.DATA: 
1026 30					DEFB	30h	; 0 
1027 31					DEFB	31h	; 1 
1028 32					DEFB	32h	; 2 
1029 33					DEFB	33h	; 3 
102a 34					DEFB	34h	; 4 
102b 35					DEFB	35h	; 5 
102c 36					DEFB	36h	; 6 
102d 37					DEFB	37h	; 7 
102e 38					DEFB	38h	; 8 
102f 39					DEFB	39h	; 9 
1030 41					DEFB	41h	; A 
1031 42					DEFB	42h	; B 
1032 43					DEFB	43h	; C 
1033 44					DEFB	44h	; D 
1034 45					DEFB	45h	; E 
1035 46					DEFB	46h	; F 
1036			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1036			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1036			;;    subtract $30, if result > 9 then subtract $7 more 
1036			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1036			atohex: 
1036 d6 30				SUB $30 
1038 fe 0a				CP 10 
103a f8					RET M		; If result negative it was 0-9 so we're done 
103b d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
103d c9					RET		 
103e			 
103e			 
103e			 
103e			 
103e			; Get 2 ASCII characters as hex byte from pointer in hl 
103e			 
103e			BYTERD: 
103e 16 00			LD	D,00h		;Set up 
1040 cd 48 10			CALL	HEXCON		;Get byte and convert to hex 
1043 87				ADD	A,A		;First nibble so 
1044 87				ADD	A,A		;multiply by 16 
1045 87				ADD	A,A		; 
1046 87				ADD	A,A		; 
1047 57				LD	D,A		;Save hi nibble in D 
1048			HEXCON: 
1048 7e				ld a, (hl)		;Get next chr 
1049 23				inc hl 
104a d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
104c fe 0a			CP	00Ah		;Is it 0-9 ? 
104e 38 02			JR	C,NALPHA	;If so miss next bit 
1050 d6 07			SUB	007h		;Else convert alpha 
1052			NALPHA: 
1052 b2				OR	D		;Add hi nibble back 
1053 c9				RET			; 
1054			 
1054			 
1054			; 
1054			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1054			; Since the routines get_byte and therefore get_nibble are called, only valid 
1054			; characters (0-9a-f) are accepted. 
1054			; 
1054			;get_word        push    af 
1054			;                call    get_byte        ; Get the upper byte 
1054			;                ld      h, a 
1054			;                call    get_byte        ; Get the lower byte 
1054			;                ld      l, a 
1054			;                pop     af 
1054			;                ret 
1054			; 
1054			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1054			; the routine get_nibble is used only valid characters are accepted - the  
1054			; input routine only accepts characters 0-9a-f. 
1054			; 
1054 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1055 7e					ld a,(hl) 
1056 23					inc hl 
1057 cd 7c 10		                call    nibble2val      ; Get upper nibble 
105a cb 07		                rlc     a 
105c cb 07		                rlc     a 
105e cb 07		                rlc     a 
1060 cb 07		                rlc     a 
1062 47			                ld      b, a            ; Save upper four bits 
1063 7e					ld a,(hl) 
1064 cd 7c 10		                call    nibble2val      ; Get lower nibble 
1067 b0			                or      b               ; Combine both nibbles 
1068 c1			                pop     bc              ; Restore B (and C) 
1069 c9			                ret 
106a			; 
106a			; Get a hexadecimal digit from the serial line. This routine blocks until 
106a			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
106a			; to the serial line interface. The lower 4 bits of A contain the value of  
106a			; that particular digit. 
106a			; 
106a			;get_nibble      ld a,(hl)           ; Read a character 
106a			;                call    to_upper        ; Convert to upper case 
106a			;                call    is_hex          ; Was it a hex digit? 
106a			;                jr      nc, get_nibble  ; No, get another character 
106a			 ;               call    nibble2val      ; Convert nibble to value 
106a			 ;               call    print_nibble 
106a			 ;               ret 
106a			; 
106a			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
106a			; A valid hexadecimal digit is denoted by a set C flag. 
106a			; 
106a			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
106a			;                ret     nc              ; Yes 
106a			;                cp      '0'             ; Less than '0'? 
106a			;                jr      nc, is_hex_1    ; No, continue 
106a			;                ccf                     ; Complement carry (i.e. clear it) 
106a			;                ret 
106a			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
106a			;                ret     c               ; Yes 
106a			;                cp      'A'             ; Less than 'A'? 
106a			;                jr      nc, is_hex_2    ; No, continue 
106a			;                ccf                     ; Yes - clear carry and return 
106a			;                ret 
106a			;is_hex_2        scf                     ; Set carry 
106a			;                ret 
106a			; 
106a			; Convert a single character contained in A to upper case: 
106a			; 
106a fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
106c d8			                ret     c 
106d fe 7b		                cp      'z' + 1         ; > 'z'? 
106f d0			                ret     nc              ; Nothing to do, either 
1070 e6 5f		                and     $5f             ; Convert to upper case 
1072 c9			                ret 
1073			 
1073			 
1073			to_lower: 
1073			 
1073			   ; if char is in [A-Z] make it lower case 
1073			 
1073			   ; enter : a = char 
1073			   ; exit  : a = lower case char 
1073			   ; uses  : af 
1073			 
1073 fe 41		   cp 'A' 
1075 d8			   ret c 
1076			    
1076 fe 5b		   cp 'Z'+1 
1078 d0			   ret nc 
1079			    
1079 f6 20		   or $20 
107b c9			   ret 
107c			 
107c			; 
107c			; Expects a hexadecimal digit (upper case!) in A and returns the 
107c			; corresponding value in A. 
107c			; 
107c fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
107e 38 02		                jr      c, nibble2val_1 ; Yes 
1080 d6 07		                sub     7               ; Adjust for A-F 
1082 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1084 e6 0f		                and     $f              ; Only return lower 4 bits 
1086 c9			                ret 
1087			; 
1087			; Print_nibble prints a single hex nibble which is contained in the lower  
1087			; four bits of A: 
1087			; 
1087			;print_nibble    push    af              ; We won't destroy the contents of A 
1087			;                and     $f              ; Just in case... 
1087			;                add     a, '0'             ; If we have a digit we are done here. 
1087			;                cp      '9' + 1         ; Is the result > 9? 
1087			;                jr      c, print_nibble_1 
1087			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1087			;print_nibble_1  call    putc            ; Print the nibble and 
1087			;                pop     af              ; restore the original value of A 
1087			;                ret 
1087			;; 
1087			;; Send a CR/LF pair: 
1087			; 
1087			;crlf            push    af 
1087			;                ld      a, cr 
1087			;                call    putc 
1087			;                ld      a, lf 
1087			;                call    putc 
1087			;                pop     af 
1087			;                ret 
1087			; 
1087			; Print_word prints the four hex digits of a word to the serial line. The  
1087			; word is expected to be in HL. 
1087			; 
1087			;print_word      push    hl 
1087			;                push    af 
1087			;                ld      a, h 
1087			;                call    print_byte 
1087			;                ld      a, l 
1087			;                call    print_byte 
1087			;                pop     af 
1087			;                pop     hl 
1087			;                ret 
1087			; 
1087			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1087			; The byte to be printed is expected to be in A. 
1087			; 
1087			;print_byte      push    af              ; Save the contents of the registers 
1087			;                push    bc 
1087			;                ld      b, a 
1087			;                rrca 
1087			;                rrca 
1087			;                rrca 
1087			;                rrca 
1087			;                call    print_nibble    ; Print high nibble 
1087			;                ld      a, b 
1087			;                call    print_nibble    ; Print low nibble 
1087			;                pop     bc              ; Restore original register contents 
1087			;                pop     af 
1087			;                ret 
1087			 
1087			 
1087			 
1087			 
1087			 
1087			fourehexhl:  
1087 7e				ld a,(hl) 
1088 cd 36 10			call atohex 
108b cb 3f				SRL A 
108d cb 3f				SRL A 
108f cb 3f				SRL A 
1091 cb 3f				SRL A 
1093 47				ld b, a 
1094 23				inc hl 
1095 7e				ld a,(hl) 
1096 23				inc hl 
1097 cd 36 10			call atohex 
109a 80				add b 
109b 57				ld d,a 
109c 7e				ld a,(hl) 
109d cd 36 10			call atohex 
10a0 cb 3f				SRL A 
10a2 cb 3f				SRL A 
10a4 cb 3f				SRL A 
10a6 cb 3f				SRL A 
10a8 47				ld b, a 
10a9 23				inc hl 
10aa 7e				ld a,(hl) 
10ab 23				inc hl 
10ac cd 36 10			call atohex 
10af 80				add b 
10b0 5f				ld e, a 
10b1 d5				push de 
10b2 e1				pop hl 
10b3 c9				ret 
10b4			 
10b4			; pass hl. returns z set if the byte at hl is a digit 
10b4			;isdigithl:  
10b4			;	push bc 
10b4			;	ld a,(hl) 
10b4			;	cp ':' 
10b4			;	jr nc, .isdf 		; > 
10b4			;	cp '0' 
10b4			;	jr c, .isdf		; < 
10b4			; 
10b4			;	; TODO find a better way to set z 
10b4			; 
10b4			;	ld b,a 
10b4			;	cp b 
10b4			;	pop bc 
10b4			;	ret 
10b4			; 
10b4			;.isdf:	; not digit so clear z 
10b4			; 
10b4			;	; TODO find a better way to unset z 
10b4			; 
10b4			;	ld b,a 
10b4			;	inc b 
10b4			;	cp b 
10b4			; 
10b4			;	pop bc 
10b4			;	ret 
10b4				 
10b4				 
10b4			 
10b4			 
10b4			; pass hl as the four byte address to load 
10b4			 
10b4			get_word_hl:  
10b4 e5				push hl 
10b5 cd 54 10			call get_byte 
10b8				 
10b8 47				ld b, a 
10b9			 
10b9 e1				pop hl 
10ba 23				inc hl 
10bb 23				inc hl 
10bc			 
10bc			; TODO not able to handle a-f  
10bc 7e				ld a,(hl) 
10bd			;	;cp ':' 
10bd			;	cp 'g' 
10bd			;	jr nc, .single_byte_hl 		; > 
10bd			;	cp 'G' 
10bd			;	jr nc, .single_byte_hl 		; > 
10bd			;	cp '0' 
10bd			;	jr c, .single_byte_hl		; < 
10bd			 
10bd				;call isdigithl 
10bd fe 00			cp 0 
10bf 28 06			jr z, .single_byte_hl 
10c1			 
10c1			.getwhln:   ; hex word so get next byte 
10c1			 
10c1 cd 54 10			call get_byte 
10c4 6f				ld l, a 
10c5 60				ld h,b 
10c6 c9				ret 
10c7 68			.single_byte_hl:   ld l,b 
10c8 26 00				ld h,0 
10ca c9					ret 
10cb			 
10cb			 
10cb			 
10cb			 
10cb 21 6b 18			ld hl,asc+1 
10ce			;	ld a, (hl) 
10ce			;	call nibble2val 
10ce cd 54 10			call get_byte 
10d1			 
10d1			;	call fourehexhl 
10d1 32 ef e2			ld (scratch+52),a 
10d4				 
10d4 21 ed e2			ld hl,scratch+50 
10d7 22 de e5			ld (os_cur_ptr),hl 
10da			 
10da c9				ret 
10db			 
10db			 
10db			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10db			 
10db			; Decimal Unsigned Version 
10db			 
10db			;Number in a to decimal ASCII 
10db			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10db			;Example: display a=56 as "056" 
10db			;input: a = number 
10db			;Output: a=0,value of a in the screen 
10db			;destroys af,bc (don't know about hl and de) 
10db			DispAToASCII: 
10db 0e 9c			ld	c,-100 
10dd cd e7 10			call	.Na1 
10e0 0e f6			ld	c,-10 
10e2 cd e7 10			call	.Na1 
10e5 0e ff			ld	c,-1 
10e7 06 2f		.Na1:	ld	b,'0'-1 
10e9 04			.Na2:	inc	b 
10ea 81				add	a,c 
10eb 38 fc			jr	c,.Na2 
10ed 91				sub	c		;works as add 100/10/1 
10ee f5				push af		;safer than ld c,a 
10ef 78				ld	a,b		;char is in b 
10f0			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10f0 f1				pop af		;safer than ld a,c 
10f1 c9				ret 
10f2			 
10f2			; Decimal Signed Version 
10f2			 
10f2			; DispA 
10f2			; -------------------------------------------------------------- 
10f2			; Converts a signed integer value to a zero-terminated ASCII 
10f2			; string representative of that value (using radix 10). 
10f2			; -------------------------------------------------------------- 
10f2			; INPUTS: 
10f2			;     HL     Value to convert (two's complement integer). 
10f2			;     DE     Base address of string destination. (pointer). 
10f2			; -------------------------------------------------------------- 
10f2			; OUTPUTS: 
10f2			;     None 
10f2			; -------------------------------------------------------------- 
10f2			; REGISTERS/MEMORY DESTROYED 
10f2			; AF HL 
10f2			; -------------------------------------------------------------- 
10f2			 
10f2			;DispHLToASCII: 
10f2			;   push    de 
10f2			;   push    bc 
10f2			; 
10f2			;; Detect sign of HL. 
10f2			;    bit    7, h 
10f2			;    jr     z, ._DoConvert 
10f2			; 
10f2			;; HL is negative. Output '-' to string and negate HL. 
10f2			;    ld     a, '-' 
10f2			;    ld     (de), a 
10f2			;    inc    de 
10f2			; 
10f2			;; Negate HL (using two's complement) 
10f2			;    xor    a 
10f2			;    sub    l 
10f2			;    ld     l, a 
10f2			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10f2			;    sbc    a, h 
10f2			;    ld     h, a 
10f2			; 
10f2			;; Convert HL to digit characters 
10f2			;._DoConvert: 
10f2			;    ld     b, 0     ; B will count character length of number 
10f2			;-   ld     a, 10 
10f2			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10f2			;    push   af 
10f2			;    inc    b 
10f2			;    ld     a, h 
10f2			;    or     l 
10f2			;    jr     nz, - 
10f2			; 
10f2			;; Retrieve digits from stack 
10f2			;-   pop    af 
10f2			;    or     $30 
10f2			;    ld     (de), a 
10f2			;    inc    de 
10f2			;    djnz   - 
10f2			; 
10f2			;; Terminate string with NULL 
10f2			;    xor    a 
10f2			;    ld     (de), a 
10f2			; 
10f2			;    pop    bc 
10f2			;    pop    de 
10f2			;    ret 
10f2			 
10f2			;Comments 
10f2			; 
10f2			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10f2			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10f2			;    Note that the output string will not be fixed-width. 
10f2			; 
10f2			;Example Usage 
10f2			; 
10f2			;    ld    hl, -1004 
10f2			;    ld    de, OP1 
10f2			;    call  DispA 
10f2			;    ld    hl, OP1 
10f2			;    syscall  PutS 
10f2			 
10f2			 
10f2			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10f2			 
10f2			 
10f2			;Converts an ASCII string to an unsigned 16-bit integer 
10f2			;Quits when it reaches a non-decimal digit 
10f2			 
10f2			string_to_uint16: 
10f2			atoui_16: 
10f2			;Input: 
10f2			;     DE points to the string 
10f2			;Outputs: 
10f2			;     HL is the result 
10f2			;     A is the 8-bit value of the number 
10f2			;     DE points to the byte after the number 
10f2			;Destroys: 
10f2			;     BC 
10f2			;       if the string is non-empty, BC is HL/10 
10f2			;Size:  24 bytes 
10f2			;Speed: 42+d(104+{0,9}) 
10f2			;       d is the number of digits in the number 
10f2			;       max is 640 cycles for a 5 digit number 
10f2			;Assuming no leading zeros: 
10f2			;1 digit:  146cc 
10f2			;2 digit:  250cc 
10f2			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10f2			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10f2			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10f2			;avg: 544.81158447265625cc (544+13297/16384) 
10f2			;=============================================================== 
10f2 21 00 00		  ld hl,0 
10f5			.u16a: 
10f5 1a			  ld a,(de) 
10f6 d6 30		  sub 30h 
10f8 fe 0a		  cp 10 
10fa d0			  ret nc 
10fb 13			  inc de 
10fc 44			  ld b,h 
10fd 4d			  ld c,l 
10fe 29			  add hl,hl 
10ff 29			  add hl,hl 
1100 09			  add hl,bc 
1101 29			  add hl,hl 
1102 85			  add a,l 
1103 6f			  ld l,a 
1104 30 ef		  jr nc,.u16a 
1106 24			  inc h 
1107 c3 f5 10		  jp .u16a 
110a			 
110a			 
110a			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
110a			 
110a			;written by Zeda 
110a			;Converts a 16-bit unsigned integer to an ASCII string. 
110a			 
110a			uitoa_16: 
110a			;Input: 
110a			;   DE is the number to convert 
110a			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
110a			;Output: 
110a			;   HL points to the null-terminated ASCII string 
110a			;      NOTE: This isn't necessarily the same as the input HL. 
110a d5			  push de 
110b c5			  push bc 
110c f5			  push af 
110d eb			  ex de,hl 
110e			 
110e 01 f0 d8		  ld bc,-10000 
1111 3e 2f		  ld a,'0'-1 
1113 3c			  inc a 
1114 09			  add hl,bc  
1115 38 fc		   jr c,$-2 
1117 12			  ld (de),a 
1118 13			  inc de 
1119			 
1119 01 e8 03		  ld bc,1000 
111c 3e 3a		  ld a,'9'+1 
111e 3d			  dec a  
111f 09			  add hl,bc  
1120 30 fc		   jr nc,$-2 
1122 12			  ld (de),a 
1123 13			  inc de 
1124			 
1124 01 9c ff		  ld bc,-100 
1127 3e 2f		  ld a,'0'-1 
1129 3c			  inc a  
112a 09			  add hl,bc  
112b 38 fc		   jr c,$-2 
112d 12			  ld (de),a 
112e 13			  inc de 
112f			 
112f 7d			  ld a,l 
1130 26 3a		  ld h,'9'+1 
1132 25			  dec h  
1133 c6 0a		  add a,10  
1135 30 fb		   jr nc,$-3 
1137 c6 30		  add a,'0' 
1139 eb			  ex de,hl 
113a 72			  ld (hl),d 
113b 23			  inc hl 
113c 77			  ld (hl),a 
113d 23			  inc hl 
113e 36 00		  ld (hl),0 
1140			 
1140			;Now strip the leading zeros 
1140 0e fa		  ld c,-6 
1142 09			  add hl,bc 
1143 3e 30		  ld a,'0' 
1145 23			  inc hl  
1146 be			  cp (hl)  
1147 28 fc		  jr z,$-2 
1149			 
1149			;Make sure that the string is non-empty! 
1149 7e			  ld a,(hl) 
114a b7			  or a 
114b 20 01		  jr nz,.atoub 
114d 2b			  dec hl 
114e			.atoub: 
114e			 
114e f1			  pop af 
114f c1			  pop bc 
1150 d1			  pop de 
1151 c9			  ret 
1152			 
1152			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1152			 
1152			toUpper: 
1152			;A is the char. 
1152			;If A is a lowercase letter, this sets it to the matching uppercase 
1152			;18cc or 30cc or 41cc 
1152			;avg: 26.75cc 
1152 fe 61		  cp 'a' 
1154 d8			  ret c 
1155 fe 7b		  cp 'z'+1 
1157 d0			  ret nc 
1158 d6 20		  sub 'a'-'A' 
115a c9			  ret 
115b			 
115b			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
115b			 
115b			; String Length 
115b			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
115b			 
115b			; Get the length of the null-terminated string starting at $8000 hl 
115b			;    LD     HL, $8000 
115b			 
115b			strlenz: 
115b			 
115b af			    XOR    A               ; Zero is the value we are looking for. 
115c 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
115d 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
115e			                           ; 65, 536 bytes (the entire addressable memory space). 
115e ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1160			 
1160			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1160 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1161 6f			    LD     L, A             ; number of bytes 
1162 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1164 2b			    DEC    HL              ; Compensate for null. 
1165 c9				ret 
1166			 
1166			; Get the length of the A terminated string starting at $8000 hl 
1166			;    LD     HL, $8000 
1166			 
1166			strlent: 
1166			 
1166			                  ; A is the value we are looking for. 
1166 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1168 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
116a			                           ; 65, 536 bytes (the entire addressable memory space). 
116a ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
116c			 
116c			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
116c 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
116e 2e 00		    LD     L, 0             ; number of bytes 
1170 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1172 2b			    DEC    HL              ; Compensate for null. 
1173 c9				ret 
1174			 
1174			 
1174			;Comparing Strings 
1174			 
1174			;IN    HL     Address of string1. 
1174			;      DE     Address of string2. 
1174			 
1174			; doc given but wrong??? 
1174			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1174			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1174			; tested 
1174			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1174			 
1174			strcmp_old: 
1174 e5			    PUSH   HL 
1175 d5			    PUSH   DE 
1176			 
1176 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1177 be			    CP     (HL)            ; (want to minimize work). 
1178 38 01		    JR     C, Str1IsBigger 
117a 7e			    LD     A, (HL) 
117b			 
117b			Str1IsBigger: 
117b 4f			    LD     C, A             ; Put length in BC 
117c 06 00		    LD     B, 0 
117e 13			    INC    DE              ; Increment pointers to meat of string. 
117f 23			    INC    HL 
1180			 
1180			CmpLoop: 
1180 1a			    LD     A, (DE)          ; Compare bytes. 
1181 ed a1		    CPI 
1183 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1185 13			    INC    DE              ; Update pointer. 
1186 ea 80 11		    JP     PE, CmpLoop 
1189			 
1189 d1			    POP    DE 
118a e1			    POP    HL 
118b 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
118c be			    CP     (HL) 
118d c9			    RET 
118e			 
118e			NoMatch: 
118e 2b			    DEC    HL 
118f be			    CP     (HL)            ; Compare again to affect carry. 
1190 d1			    POP    DE 
1191 e1			    POP    HL 
1192 c9			    RET 
1193			 
1193			;; test strmp 
1193			; 
1193			;ld de, .str1 
1193			;ld hl, .str2 
1193			;call strcmp 
1193			;jr z, .z1 
1193			;;this 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "NZ1" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			;.z1: 
1193			; 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "ZZ1" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			; 
1193			;ld de, .str1 
1193			;ld hl, .str1 
1193			;call strcmp 
1193			;jr z, .z2 
1193			;;this 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "NZ2" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			;.z2: 
1193			; 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "ZZ2" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			; 
1193			;ld de, .str1 
1193			;ld hl, .str2 
1193			;call strcmp 
1193			;jr c, .c1 
1193			; 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "Nc1" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			;.c1: 
1193			;;this 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "cc1" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			; 
1193			;ld de, .str1 
1193			;ld hl, .str1 
1193			;call strcmp 
1193			;jr c, .c2 
1193			;;this 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "Nc2" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			;.c2: 
1193			; 
1193			;	if DEBUG_FORTH_WORDS 
1193			;		DMARK "cc2" 
1193			;		CALLMONITOR 
1193			;	endif 
1193			;	NEXTW 
1193			;.str1:   db "string1",0 
1193			;.str2:   db "string2",0 
1193			 
1193			; only care about direct match or not 
1193			; hl and de strings 
1193			; zero set if the same 
1193			 
1193			strcmp: 
1193 1a				ld a, (de) 
1194 be				cp (hl) 
1195 28 02			jr z, .ssame 
1197 b7				or a 
1198 c9				ret 
1199			 
1199			.ssame:  
1199 fe 00			cp 0 
119b c8				ret z 
119c			 
119c 23				inc hl 
119d 13				inc de 
119e 18 f3			jr strcmp 
11a0				 
11a0				 
11a0			 
11a0			;Copyright (c) 2014, Luke Maurits 
11a0			;All rights reserved. 
11a0			; 
11a0			;Redistribution and use in source and binary forms, with or without 
11a0			;modification, are permitted provided that the following conditions are met: 
11a0			; 
11a0			;* Redistributions of source code must retain the above copyright notice, this 
11a0			;  list of conditions and the following disclaimer. 
11a0			; 
11a0			;* Redistributions in binary form must reproduce the above copyright notice, 
11a0			;  this list of conditions and the following disclaimer in the documentation 
11a0			;  and/or other materials provided with the distribution. 
11a0			; 
11a0			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
11a0			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
11a0			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
11a0			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
11a0			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
11a0			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
11a0			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
11a0			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
11a0			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
11a0			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
11a0			 
11a0			; https://github.com/lmaurits/lm512/blob/master/string.z80 
11a0			 
11a0			StrictStrCmp: 
11a0				; Load next chars of each string 
11a0 1a				ld a, (de) 
11a1 47				ld b, a 
11a2 7e				ld a, (hl) 
11a3				; Compare 
11a3 b8				cp b 
11a4				; Return non-zero if chars don't match 
11a4 c0				ret nz 
11a5				; Check for end of both strings 
11a5 fe 00			cp "\0" 
11a7				; Return if strings have ended 
11a7 c8				ret z 
11a8				; Otherwise, advance to next chars 
11a8 23				inc hl 
11a9 13				inc de 
11aa 18 f4			jr StrictStrCmp 
11ac			 
11ac			;end 
11ac			; eof 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			 
11ac			 
# End of file firmware_strings.asm
11ac			include "firmware_memory.asm"   ; malloc and free  
11ac			 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			.mallocsize: db "Wants malloc >256",0 
11ac			.mallocasize: db "MALLOC gives >256",0 
11ac			.malloczero: db "MALLOC gives zero",0 
11ac			 
11ac			malloc_guard_zerolen: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac				ld de, 0 
11ac			        call cmp16 
11ac				jr nz, .lowalloz 
11ac			 
11ac				push hl 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .malloczero 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac				call bp_on 
11ac			;	ld a, 0 
11ac			;	ld (os_view_disable), a 
11ac			 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				 
11ac			 
11ac				CALLMONITOR 
11ac			.lowalloz: 
11ac			 
11ac			 
11ac				pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			 
11ac			malloc_guard_entry: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac			 	or a      ;clear carry flag 
11ac				push hl 
11ac				ld de, 255 
11ac				sbc hl, de 
11ac				jr c, .lowalloc 
11ac			 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .mallocsize 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac			;	ld a, 0 
11ac			;	ld (os_view_disable), a 
11ac				call bp_on 
11ac			 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				 
11ac			 
11ac				CALLMONITOR 
11ac				jr .lowdone 
11ac			.lowalloc: 
11ac			 
11ac			 
11ac				pop hl 
11ac			.lowdone:	pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			 
11ac			malloc_guard_exit: 
11ac				push hl 
11ac				push de 
11ac				push af 
11ac			 
11ac			 	or a      ;clear carry flag 
11ac				push hl 
11ac				ld de, 255 
11ac				sbc hl, de 
11ac				jr c, .lowallocx 
11ac			 
11ac				push de 
11ac					ld hl, display_fb0 
11ac					ld (display_fb_active), hl 
11ac				call clear_display 
11ac				ld a, 0 
11ac				ld de, .mallocasize 
11ac				call str_at_display 
11ac				call update_display 
11ac				call delay1s 
11ac				call delay1s 
11ac			;	ld a, 0 
11ac			;	ld (os_view_disable), a 
11ac				call bp_on 
11ac				pop de 
11ac				pop hl 
11ac			 
11ac				CALLMONITOR 
11ac				jr .lowdonex 
11ac			.lowallocx: 
11ac			 
11ac				pop hl 
11ac			.lowdonex:	pop af 
11ac				pop de 
11ac				pop hl 
11ac			ret 
11ac			endif 
11ac			 
11ac			if MALLOC_2 
11ac			; Z80 Malloc and Free Functions 
11ac			 
11ac			; Malloc Function: 
11ac			; Input: 
11ac			;   HL: Size of block to allocate 
11ac			; Output: 
11ac			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11ac			 
11ac			malloc: 
11ac				 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			call malloc_guard_entry 
11ac			endif 
11ac			 
11ac			 
11ac			 
11ac			 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "mal" 
11ac						CALLMONITOR 
11ac					endif 
11ac			    push af            ; Save AF register 
11ac			    ld a, l            ; Load low byte of size into A 
11ac			    or h               ; Check if size is zero 
11ac			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
11ac			 
11ac			    ; Allocate memory 
11ac			    ld hl, (heap_start) ; Load start of heap into HL 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma1" 
11ac						CALLMONITOR 
11ac					endif 
11ac			    call malloc_internal ; Call internal malloc function 
11ac			    pop af             ; Restore AF register 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret                ; Return 
11ac			 
11ac			; Free Function: 
11ac			; Input: 
11ac			;   HL: Pointer to memory block to free 
11ac			; Output: 
11ac			;   None 
11ac			 
11ac			free: 
11ac			    push af            ; Save AF register 
11ac			    ld a, l            ; Load low byte of pointer into A 
11ac			    or h               ; Check if pointer is NULL 
11ac			    jp z, free_exit    ; If pointer is NULL, exit 
11ac			 
11ac			    ; Free memory 
11ac			    ld hl, (heap_start) ; Load start of heap into HL 
11ac			    call free_internal  ; Call internal free function 
11ac			    pop af             ; Restore AF register 
11ac			    ret                ; Return 
11ac			 
11ac			; Internal Malloc Function: 
11ac			; Input: 
11ac			;   HL: Size of block to allocate 
11ac			; Output: 
11ac			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
11ac			 
11ac			malloc_internal: 
11ac			    ld bc, 2           ; Number of bytes to allocate for management overhead 
11ac			    add hl, bc         ; Add management overhead to requested size 
11ac			    ex de, hl          ; Save total size in DE, and keep it in HL 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma2" 
11ac						CALLMONITOR 
11ac					endif 
11ac			 
11ac			    ; Search for free memory block 
11ac			    ld de, (heap_end)  ; Load end of heap into DE 
11ac			    ld bc, 0           ; Initialize counter 
11ac			 
11ac					if DEBUG_FORTH_MALLOC 
11ac						DMARK "ma2" 
11ac						CALLMONITOR 
11ac					endif 
11ac			malloc_search_loop: 
11ac			    ; Check if current block is free 
11ac			    ld a, (hl)         ; Load current block's status (free or used) 
11ac			    cp 0               ; Compare with zero (free) 
11ac			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
11ac			 
11ac			    ; Check if current block is large enough 
11ac			    ld a, (hl+1)       ; Load high byte of block size 
11ac			    cp l               ; Compare with low byte of requested size 
11ac			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
11ac			 
11ac			    ld a, (hl+2)       ; Load low byte of block size 
11ac			    cp h               ; Compare with high byte of requested size 
11ac			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
11ac			 
11ac			    ; Mark block as used 
11ac			    ld (hl), 0xFF      ; Set status byte to indicate used block 
11ac			 
11ac			    ; Calculate remaining space in block 
11ac			    ld bc, 0           ; Clear BC 
11ac			    add hl, bc         ; Increment HL to point to start of data block 
11ac			    add hl, de         ; HL = HL + DE (total size) 
11ac			    ld bc, 1           ; Number of bytes to allocate for management overhead 
11ac			    add hl, bc         ; Add management overhead to start of data block 
11ac			 
11ac			    ; Save pointer to allocated block in HL 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma5" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			 
11ac			malloc_skip_block_check: 
11ac			    ; Move to the next block 
11ac			    ld bc, 3           ; Size of management overhead 
11ac			    add hl, bc         ; Move to the next block 
11ac			    inc de             ; Increment counter 
11ac			 
11ac			    ; Check if we have reached the end of heap 
11ac			    ld a, e            ; Load low byte of heap end address 
11ac			    cp (hl)            ; Compare with low byte of current address 
11ac			    jr nz, malloc_search_loop  ; If not equal, continue searching 
11ac			    ld a, d            ; Load high byte of heap end address 
11ac			    cp 0               ; Check if it's zero (end of memory) 
11ac			    jr nz, malloc_search_loop  ; If not zero, continue searching 
11ac			 
11ac			    ; If we reached here, allocation failed 
11ac			    xor a              ; Set result to NULL 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma6" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			malloc_exit: 
11ac			if DEBUG_FORTH_MALLOC_HIGH 
11ac						DMARK "ma7" 
11ac			call malloc_guard_exit 
11ac			call malloc_guard_zerolen 
11ac			endif 
11ac			    ret 
11ac			 
11ac			; Internal Free Function: 
11ac			; Input: 
11ac			;   HL: Pointer to memory block to free 
11ac			; Output: 
11ac			;   None 
11ac			 
11ac			free_internal: 
11ac			    ld de, (heap_start) ; Load start of heap into DE 
11ac			    ld bc, 0            ; Initialize counter 
11ac			 
11ac			free_search_loop: 
11ac			    ; Check if current block contains the pointer 
11ac			    ld a, l             ; Load low byte of pointer 
11ac			    cp (hl+1)           ; Compare with high byte of current block's address 
11ac			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11ac			    ld a, h             ; Load high byte of pointer 
11ac			    cp (hl+2)           ; Compare with low byte of current block's address 
11ac			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
11ac			 
11ac			    ; Mark block as free 
11ac			    ld (hl), 0          ; Set status byte to indicate free block 
11ac			    ret                 ; Return 
11ac			 
11ac			free_skip_block_check: 
11ac			    ; Move to the next block 
11ac			    ld bc, 3            ; Size of management overhead 
11ac			    add hl, bc          ; Move to the next block 
11ac			    inc de              ; Increment counter 
11ac			 
11ac			    ; Check if we have reached the end of heap 
11ac			    ld a, e             ; Load low byte of heap end address 
11ac			    cp (hl)             ; Compare with low byte of current address 
11ac			    jr nz, free_search_loop  ; If not equal, continue searching 
11ac			    ld a, d             ; Load high byte of heap end address 
11ac			    cp 0                ; Check if it's zero (end of memory) 
11ac			    jr nz, free_search_loop  ; If not zero, continue searching 
11ac			 
11ac			    ; If we reached here, pointer is not found in heap 
11ac			    ret 
11ac			 
11ac			free_exit: 
11ac			    ret                 ; Return 
11ac			 
11ac			; Define heap start and end addresses 
11ac			;heap_start:    .dw 0xC000   ; Start of heap 
11ac			;heap_end:      .dw 0xE000   ; End of heap 
11ac			 
11ac			endif 
11ac			 
11ac			 
11ac			if MALLOC_1 
11ac			 
11ac			 
11ac			 
11ac			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
11ac			 
11ac			;moved to firmware.asm 
11ac			;heap_start        .equ  0x9000      ; Starting address of heap 
11ac			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
11ac			 
11ac			;      .org 0 
11ac			;      jp    main 
11ac			 
11ac			 
11ac			;      .org  0x100 
11ac			;main: 
11ac			;      ld    HL, 0x8100 
11ac			;      ld    SP, HL 
11ac			; 
11ac			;      call  heap_init 
11ac			; 
11ac			;      ; Make some allocations 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9004 
11ac			; 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9014 
11ac			; 
11ac			;      ld    HL, 12 
11ac			;      call  malloc            ; Allocates 0x9024 
11ac			; 
11ac			;      ; Free some allocations 
11ac			;      ld    HL, 0x9014 
11ac			;      call  free 
11ac			; 
11ac			;      ld    HL, 0x9004 
11ac			;      call  free 
11ac			; 
11ac			;      ld    HL, 0x9024 
11ac			;      call  free 
11ac			; 
11ac			; 
11ac			;      halt 
11ac			 
11ac			 
11ac			;------------------------------------------------------------------------------ 
11ac			;     heap_init                                                               : 
11ac			;                                                                             : 
11ac			; Description                                                                 : 
11ac			;     Initialise the heap and make it ready for malloc and free operations.   : 
11ac			;                                                                             : 
11ac			;     The heap is maintained as a linked list, starting with an initial       : 
11ac			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
11ac			;     the first free block in the heap. Each block then points to the next    : 
11ac			;     free block within the heap, and the free list ends at the first block   : 
11ac			;     with a null pointer to the next free block.                             : 
11ac			;                                                                             : 
11ac			; Parameters                                                                  : 
11ac			;     Inputs are compile-time only. Two defines which specify the starting    : 
11ac			;     address of the heap and its size are required, along with a memory      : 
11ac			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
11ac			;     principally stores a pointer to the first free block in the heap.       : 
11ac			;                                                                             : 
11ac			; Returns                                                                     : 
11ac			;     Nothing                                                                 : 
11ac			;------------------------------------------------------------------------------ 
11ac			heap_init: 
11ac e5			      push  HL 
11ad			 
11ad			      ; Initialise free list struct 
11ad 21 21 5f		      ld    HL, heap_start 
11b0 22 1c 5f		      ld    (free_list), HL 
11b3 21 00 00		      ld    HL, 0 
11b6 22 1e 5f		      ld    (free_list+2), HL 
11b9			 
11b9			      ; Insert first free block at bottom of heap, consumes entire heap 
11b9 21 92 e2		      ld    HL, heap_start+heap_size-4 
11bc 22 21 5f		      ld    (heap_start), HL        ; Next block (end of free list) 
11bf 21 71 83		      ld    HL, heap_size-4 
11c2 22 23 5f		      ld    (heap_start+2), HL      ; Block size 
11c5			 
11c5			      ; Insert end of free list block at top of heap - two null words will 
11c5			      ; terminate the free list 
11c5 21 00 00		      ld    HL, 0 
11c8 22 94 e2		      ld    (heap_start+heap_size-2), HL 
11cb 22 92 e2		      ld    (heap_start+heap_size-4), HL 
11ce			 
11ce e1			      pop   HL 
11cf			 
11cf c9			      ret 
11d0			 
11d0			 
11d0			;------------------------------------------------------------------------------ 
11d0			;     malloc                                                                  : 
11d0			;                                                                             : 
11d0			; Description                                                                 : 
11d0			;     Allocates the wanted space from the heap and returns the address of the : 
11d0			;     first useable byte of the allocation.                                   : 
11d0			;                                                                             : 
11d0			;     Allocations can happen in one of two ways:                              : 
11d0			;                                                                             : 
11d0			;     1. A free block may be found which is the exact size wanted. In this    : 
11d0			;        case the block is removed from the free list and retuedn to the      : 
11d0			;        caller.                                                              : 
11d0			;     2. A free block may be found which is larger than the size wanted. In   : 
11d0			;        this case, the larger block is split into two. The first portion of  : 
11d0			;        this block will become the requested space by the malloc call and    : 
11d0			;        is returned to the caller. The second portion becomes a new free     : 
11d0			;        block, and the free list is adjusted to maintain continuity via this : 
11d0			;        newly created block.                                                 : 
11d0			;                                                                             : 
11d0			;     malloc does not set any initial value in the allocated space, the       : 
11d0			;     caller is required to do this as required.                              : 
11d0			;                                                                             : 
11d0			;     This implementation of malloc uses the stack exclusively, and is        : 
11d0			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11d0			;     advisable to disable interrupts before calling malloc, and recommended  : 
11d0			;     to avoid the use of malloc inside ISRs in general.                      : 
11d0			;                                                                             : 
11d0			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11d0			;                                                                             : 
11d0			; Parameters                                                                  : 
11d0			;     HL  Number of bytes wanted                                              : 
11d0			;                                                                             : 
11d0			; Returns                                                                     : 
11d0			;     HL  Address of the first useable byte of the allocation                 : 
11d0			;                                                                             : 
11d0			; Flags                                                                       : 
11d0			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11d0			;                                                                             : 
11d0			; Stack frame                                                                 : 
11d0			;       |             |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     BC      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     DE      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |     IX      |                                                       : 
11d0			;       +-------------+                                                       : 
11d0			;       |  prev_free  |                                                       : 
11d0			;   +4  +-------------+                                                       : 
11d0			;       |  this_free  |                                                       : 
11d0			;   +2  +-------------+                                                       : 
11d0			;       |  next_free  |                                                       : 
11d0			;   +0  +-------------+                                                       : 
11d0			;       |             |                                                       : 
11d0			;                                                                             : 
11d0			;------------------------------------------------------------------------------ 
11d0			 
11d0			 
11d0			;malloc: 
11d0			; 
11d0			;	SAVESP ON 1 
11d0			; 
11d0			;	call malloc_code 
11d0			; 
11d0			;	CHECKSP ON 1 
11d0			;	ret 
11d0			 
11d0			 
11d0			malloc: 
11d0 c5			      push  BC 
11d1 d5			      push  DE 
11d2 dd e5		      push  IX 
11d4			if DEBUG_FORTH_MALLOC_HIGH 
11d4			call malloc_guard_entry 
11d4			endif 
11d4			 
11d4					if DEBUG_FORTH_MALLOC 
11d4						DMARK "mal" 
11d4						CALLMONITOR 
11d4					endif 
11d4 7c			      ld    A, H                    ; Exit if no space requested 
11d5 b5			      or    L 
11d6 ca 95 12		      jp    Z, malloc_early_exit 
11d9			 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			; 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			;inc hl 
11d9			 
11d9			 
11d9			 
11d9			 
11d9					if DEBUG_FORTH_MALLOC 
11d9						DMARK "maA" 
11d9						CALLMONITOR 
11d9					endif 
11d9			      ; Set up stack frame 
11d9 eb			      ex    DE, HL 
11da 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11dd 39			      add   HL, SP 
11de f9			      ld    SP, HL 
11df dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11e3 dd 39		      add   IX, SP 
11e5			 
11e5			      ; Setup initial state 
11e5 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11e8 19			      add   HL, DE 
11e9			 
11e9 44			      ld    B, H                    ; Move want to BC 
11ea 4d			      ld    C, L 
11eb			 
11eb 21 1c 5f		      ld    HL, free_list           ; Store prev_free ptr to stack 
11ee dd 75 04		      ld    (IX+4), L 
11f1 dd 74 05		      ld    (IX+5), H 
11f4			 
11f4 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11f5 23			      inc   HL 
11f6 56			      ld    D, (HL) 
11f7 dd 73 02		      ld    (IX+2), E 
11fa dd 72 03		      ld    (IX+3), D 
11fd eb			      ex    DE, HL                  ; this_free ptr into HL 
11fe			 
11fe					if DEBUG_FORTH_MALLOC 
11fe						DMARK "maB" 
11fe						CALLMONITOR 
11fe					endif 
11fe			      ; Loop through free block list to find some space 
11fe			malloc_find_space: 
11fe 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11ff 23			      inc   HL 
1200 56			      ld    D, (HL) 
1201			 
1201 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1202 b3			      or    E 
1203 ca 8f 12		      jp    Z, malloc_no_space 
1206			 
1206 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1209 dd 72 01		      ld    (IX+1), D 
120c			 
120c			      ; Does this block have enough space to make the allocation? 
120c 23			      inc   HL                      ; Load free block size into DE 
120d 5e			      ld    E, (HL) 
120e 23			      inc   HL 
120f 56			      ld    D, (HL) 
1210			 
1210 eb			      ex    DE, HL                  ; Check size of block against want 
1211 b7			      or    A                       ; Ensure carry flag clear 
1212 ed 42		      sbc   HL, BC 
1214 e5			      push  HL                      ; Store the result for later (new block size) 
1215			 
1215 ca 64 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1218 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
121a			 
121a			      ; this_free block is not big enough, setup ptrs to test next free block 
121a e1			      pop   HL                      ; Discard previous result 
121b			 
121b dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
121e dd 66 03		      ld    H, (IX+3) 
1221 dd 75 04		      ld    (IX+4), L 
1224 dd 74 05		      ld    (IX+5), H 
1227			 
1227 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
122a dd 66 01		      ld    H, (IX+1) 
122d dd 75 02		      ld    (IX+2), L 
1230 dd 74 03		      ld    (IX+3), H 
1233			 
1233					if DEBUG_FORTH_MALLOC 
1233						DMARK "MA>" 
1233						CALLMONITOR 
1233					endif 
1233 18 c9		      jr    malloc_find_space 
1235			 
1235			      ; split a bigger block into two - requested size and remaining size 
1235			malloc_alloc_split: 
1235					if DEBUG_FORTH_MALLOC 
1235						DMARK "MAs" 
1235						CALLMONITOR 
1235					endif 
1235 eb			      ex    DE, HL                  ; Calculate address of new free block 
1236 2b			      dec   HL 
1237 2b			      dec   HL 
1238 2b			      dec   HL 
1239 09			      add   HL, BC 
123a			 
123a			      ; Create a new block and point it at next_free 
123a dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
123d dd 56 01		      ld    D, (IX+1) 
1240			 
1240 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1241 23			      inc   HL 
1242 72			      ld    (HL), D 
1243			 
1243 d1			      pop   DE                      ; Store size of new block into new block 
1244 23			      inc   HL 
1245 73			      ld    (HL), E 
1246 23			      inc   HL 
1247 72			      ld    (HL), D 
1248			 
1248			      ; Update this_free ptr to point to new block 
1248 2b			      dec   HL 
1249 2b			      dec   HL 
124a 2b			      dec   HL 
124b			 
124b dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
124e dd 56 03		      ld    D, (IX+3) 
1251			 
1251 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1254 dd 74 03		      ld    (IX+3), H 
1257			 
1257			      ; Modify this_free block to be allocation 
1257 eb			      ex    DE, HL 
1258 af			      xor   A                       ; Null the next block ptr of allocated block 
1259 77			      ld    (HL), A 
125a 23			      inc   HL 
125b 77			      ld    (HL), A 
125c			 
125c 23			      inc   HL                      ; Store want size into allocated block 
125d 71			      ld    (HL), C 
125e 23			      inc   HL 
125f 70			      ld    (HL), B 
1260 23			      inc   HL 
1261 e5			      push  HL                      ; Address of allocation to return 
1262			 
1262 18 19		      jr    malloc_update_links 
1264			 
1264			malloc_alloc_fit: 
1264 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1265			 
1265					if DEBUG_FORTH_MALLOC 
1265						DMARK "MAf" 
1265						CALLMONITOR 
1265					endif 
1265			      ; Modify this_free block to be allocation 
1265 eb			      ex    DE, HL 
1266 2b			      dec   HL 
1267 2b			      dec   HL 
1268 2b			      dec   HL 
1269			 
1269 af			      xor   A                       ; Null the next block ptr of allocated block 
126a 77			      ld    (HL), A 
126b 23			      inc   HL 
126c 77			      ld    (HL), A 
126d			 
126d 23			      inc   HL                      ; Store address of allocation to return 
126e 23			      inc   HL 
126f 23			      inc   HL 
1270 e5			      push  HL 
1271			 
1271			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1271 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1274 dd 66 01		      ld    H, (IX+1) 
1277			 
1277 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
127a dd 74 03		      ld    (IX+3), H 
127d			 
127d			 
127d			malloc_update_links: 
127d			      ; Update prev_free ptr to point to this_free 
127d dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1280 dd 66 05		      ld    H, (IX+5) 
1283			 
1283 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1286 dd 56 03		      ld    D, (IX+3) 
1289			 
1289 73			      ld    (HL), E                 ; this_free ptr into prev_free 
128a 23			      inc   HL 
128b 72			      ld    (HL), D 
128c			 
128c					if DEBUG_FORTH_MALLOC 
128c						DMARK "Mul" 
128c						CALLMONITOR 
128c					endif 
128c			      ; Clear the Z flag to indicate successful allocation 
128c 7a			      ld    A, D 
128d b3			      or    E 
128e			 
128e d1			      pop   DE                      ; Address of allocation 
128f					if DEBUG_FORTH_MALLOC 
128f						DMARK "MAu" 
128f						CALLMONITOR 
128f					endif 
128f			 
128f			malloc_no_space: 
128f 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1292 39			      add   HL, SP 
1293 f9			      ld    SP, HL 
1294			 
1294 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "MAN" 
1295						CALLMONITOR 
1295					endif 
1295			 
1295			malloc_early_exit: 
1295					if DEBUG_FORTH_MALLOC 
1295						DMARK "MAx" 
1295						CALLMONITOR 
1295					endif 
1295 dd e1		      pop   IX 
1297 d1			      pop   DE 
1298 c1			      pop   BC 
1299			 
1299			if DEBUG_FORTH_MALLOC_HIGH 
1299			call malloc_guard_exit 
1299			call malloc_guard_zerolen 
1299			endif 
1299 c9			      ret 
129a			 
129a			 
129a			;------------------------------------------------------------------------------ 
129a			;     free                                                                    : 
129a			;                                                                             : 
129a			; Description                                                                 : 
129a			;     Return the space pointed to by HL to the heap. HL must be an address as : 
129a			;     returned by malloc, otherwise the behaviour is undefined.               : 
129a			;                                                                             : 
129a			;     Where possible, directly adjacent free blocks will be merged together   : 
129a			;     into larger blocks to help ensure that the heap does not become         : 
129a			;     excessively fragmented.                                                 : 
129a			;                                                                             : 
129a			;     free does not clear or set any other value into the freed space, and    : 
129a			;     therefore its contents may be visible through subsequent malloc's. The  : 
129a			;     caller should clear the freed space as required.                        : 
129a			;                                                                             : 
129a			;     This implementation of free uses the stack exclusively, and is          : 
129a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
129a			;     advisable to disable interrupts before calling free, and recommended    : 
129a			;     to avoid the use of free inside ISRs in general.                        : 
129a			;                                                                             : 
129a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
129a			;                                                                             : 
129a			; Parameters                                                                  : 
129a			;     HL  Pointer to address of first byte of allocation to be freed          : 
129a			;                                                                             : 
129a			; Returns                                                                     : 
129a			;     Nothing                                                                 : 
129a			;                                                                             : 
129a			; Stack frame                                                                 : 
129a			;       |             |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     BC      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     DE      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |     IX      |                                                       : 
129a			;       +-------------+                                                       : 
129a			;       |  prev_free  |                                                       : 
129a			;   +2  +-------------+                                                       : 
129a			;       |  next_free  |                                                       : 
129a			;   +0  +-------------+                                                       : 
129a			;       |             |                                                       : 
129a			;                                                                             : 
129a			;------------------------------------------------------------------------------ 
129a			free: 
129a c5			      push  BC 
129b d5			      push  DE 
129c dd e5		      push  IX 
129e			 
129e 7c			      ld    A, H                    ; Exit if ptr is null 
129f b5			      or    L 
12a0 ca 64 13		      jp    Z, free_early_exit 
12a3			 
12a3			      ; Set up stack frame 
12a3 eb			      ex    DE, HL 
12a4 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12a7 39			      add   HL, SP 
12a8 f9			      ld    SP, HL 
12a9 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12ad dd 39		      add   IX, SP 
12af			 
12af			      ; The address in HL points to the start of the useable allocated space, 
12af			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12af			      ; address of the block itself. 
12af eb			      ex    DE, HL 
12b0 11 fc ff		      ld    DE, -4 
12b3 19			      add   HL, DE 
12b4			 
12b4			      ; An allocated block must have a null next block pointer in it 
12b4 7e			      ld    A, (HL) 
12b5 23			      inc   HL 
12b6 b6			      or    (HL) 
12b7 c2 5f 13		      jp    NZ, free_done 
12ba			 
12ba 2b			      dec   HL 
12bb			 
12bb 44			      ld    B, H                    ; Copy HL to BC 
12bc 4d			      ld    C, L 
12bd			 
12bd			      ; Loop through the free list to find the first block with an address 
12bd			      ; higher than the block being freed 
12bd 21 1c 5f		      ld    HL, free_list 
12c0			 
12c0			free_find_higher_block: 
12c0 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12c1 23			      inc   HL 
12c2 56			      ld    D, (HL) 
12c3 2b			      dec   HL 
12c4			 
12c4 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12c7 dd 72 01		      ld    (IX+1), D 
12ca dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12cd dd 74 03		      ld    (IX+3), H 
12d0			 
12d0 78			      ld    A, B                    ; Check if DE is greater than BC 
12d1 ba			      cp    D                       ; Compare MSB first 
12d2 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12d4 30 04		      jr    NC, free_find_higher_block_skip 
12d6 79			      ld    A, C 
12d7 bb			      cp    E                       ; Then compare LSB 
12d8 38 08		      jr    C, free_found_higher_block 
12da			 
12da			free_find_higher_block_skip: 
12da 7a			      ld    A, D                    ; Reached the end of the free list? 
12db b3			      or    E 
12dc ca 5f 13		      jp    Z, free_done 
12df			 
12df eb			      ex    DE, HL 
12e0			 
12e0 18 de		      jr    free_find_higher_block 
12e2			 
12e2			free_found_higher_block: 
12e2			      ; Insert freed block between prev and next free blocks 
12e2 71			      ld    (HL), C                 ; Point prev free block to freed block 
12e3 23			      inc   HL 
12e4 70			      ld    (HL), B 
12e5			 
12e5 60			      ld    H, B                    ; Point freed block at next free block 
12e6 69			      ld    L, C 
12e7 73			      ld    (HL), E 
12e8 23			      inc   HL 
12e9 72			      ld    (HL), D 
12ea			 
12ea			      ; Check if the freed block is adjacent to the next free block 
12ea 23			      inc   HL                      ; Load size of freed block into HL 
12eb 5e			      ld    E, (HL) 
12ec 23			      inc   HL 
12ed 56			      ld    D, (HL) 
12ee eb			      ex    DE, HL 
12ef			 
12ef 09			      add   HL, BC                  ; Add addr of freed block and its size 
12f0			 
12f0 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12f3 dd 56 01		      ld    D, (IX+1) 
12f6			 
12f6 b7			      or    A                       ; Clear the carry flag 
12f7 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12f9 20 22		      jr    NZ, free_check_adjacent_to_prev 
12fb			 
12fb			      ; Freed block is adjacent to next, merge into one bigger block 
12fb eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12fc 5e			      ld    E, (HL) 
12fd 23			      inc   HL 
12fe 56			      ld    D, (HL) 
12ff e5			      push  HL                      ; Save ptr to next block for later 
1300			 
1300 60			      ld    H, B                    ; Store ptr from next block into freed block 
1301 69			      ld    L, C 
1302 73			      ld    (HL), E 
1303 23			      inc   HL 
1304 72			      ld    (HL), D 
1305			 
1305 e1			      pop   HL                      ; Restore ptr to next block 
1306 23			      inc   HL                      ; Load size of next block into DE 
1307 5e			      ld    E, (HL) 
1308 23			      inc   HL 
1309 56			      ld    D, (HL) 
130a d5			      push  DE                      ; Save next block size for later 
130b			 
130b 60			      ld    H, B                    ; Load size of freed block into HL 
130c 69			      ld    L, C 
130d 23			      inc   HL 
130e 23			      inc   HL 
130f 5e			      ld    E, (HL) 
1310 23			      inc   HL 
1311 56			      ld    D, (HL) 
1312 eb			      ex    DE, HL 
1313			 
1313 d1			      pop   DE                      ; Restore size of next block 
1314 19			      add   HL, DE                  ; Add sizes of both blocks 
1315 eb			      ex    DE, HL 
1316			 
1316 60			      ld    H, B                    ; Store new bigger size into freed block 
1317 69			      ld    L, C 
1318 23			      inc   HL 
1319 23			      inc   HL 
131a 73			      ld    (HL), E 
131b 23			      inc   HL 
131c 72			      ld    (HL), D 
131d			 
131d			free_check_adjacent_to_prev: 
131d			      ; Check if the freed block is adjacent to the prev free block 
131d dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1320 dd 66 03		      ld    H, (IX+3) 
1323			 
1323 23			      inc   HL                      ; Size of prev free block into DE 
1324 23			      inc   HL 
1325 5e			      ld    E, (HL) 
1326 23			      inc   HL 
1327 56			      ld    D, (HL) 
1328 2b			      dec   HL 
1329 2b			      dec   HL 
132a 2b			      dec   HL 
132b			 
132b 19			      add   HL, DE                  ; Add prev block addr and size 
132c			 
132c b7			      or    A                       ; Clear the carry flag 
132d ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
132f 20 2e		      jr    NZ, free_done 
1331			 
1331			      ; Freed block is adjacent to prev, merge into one bigger block 
1331 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1332 69			      ld    L, C 
1333 5e			      ld    E, (HL) 
1334 23			      inc   HL 
1335 56			      ld    D, (HL) 
1336 e5			      push  HL                      ; Save freed block ptr for later 
1337			 
1337 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
133a dd 66 03		      ld    H, (IX+3) 
133d 73			      ld    (HL), E 
133e 23			      inc   HL 
133f 72			      ld    (HL), D 
1340			 
1340 e1			      pop   HL                      ; Restore freed block ptr 
1341 23			      inc   HL                      ; Load size of freed block into DE 
1342 5e			      ld    E, (HL) 
1343 23			      inc   HL 
1344 56			      ld    D, (HL) 
1345 d5			      push  DE                      ; Save freed block size for later 
1346			 
1346 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1349 dd 66 03		      ld    H, (IX+3) 
134c 23			      inc   HL 
134d 23			      inc   HL 
134e 5e			      ld    E, (HL) 
134f 23			      inc   HL 
1350 56			      ld    D, (HL) 
1351			 
1351 e1			      pop   HL                      ; Add sizes of both blocks 
1352 19			      add   HL, DE 
1353 eb			      ex    DE, HL 
1354			 
1354 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1357 dd 66 03		      ld    H, (IX+3) 
135a 23			      inc   HL 
135b 23			      inc   HL 
135c 73			      ld    (HL), E 
135d 23			      inc   HL 
135e 72			      ld    (HL), D 
135f			 
135f			free_done: 
135f 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1362 39			      add   HL, SP 
1363 f9			      ld    SP, HL 
1364			 
1364			free_early_exit: 
1364 dd e1		      pop   IX 
1366 d1			      pop   DE 
1367 c1			      pop   BC 
1368			 
1368 c9			      ret 
1369			 
1369			; moved to firmware.asm 
1369			; 
1369			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1369			;                  .dw   0 
1369			 
1369			 
1369			endif 
1369			 
1369			 
1369			if MALLOC_3 
1369			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1369			;heap_start        .equ  0x9000      ; Starting address of heap 
1369			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1369			; 
1369			 ;     .org 0 
1369			  ;    jp    main 
1369			; 
1369			; 
1369			 ;     .org  0x100 
1369			;main: 
1369			 ;     ld    HL, 0x8100 
1369			  ;    ld    SP, HL 
1369			; 
1369			;      call  heap_init 
1369			 
1369			      ; Make some allocations 
1369			;      ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9004 
1369			; 
1369			 ;     ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9014 
1369			 
1369			;      ld    HL, 12 
1369			;      call  malloc            ; Allocates 0x9024 
1369			 
1369			      ; Free some allocations 
1369			;      ld    HL, 0x9014 
1369			;      call  free 
1369			 
1369			;      ld    HL, 0x9004 
1369			;      call  free 
1369			; 
1369			;      ld    HL, 0x9024 
1369			;      call  free 
1369			 
1369			 
1369			 ;     halt 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     heap_init                                                               : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Initialise the heap and make it ready for malloc and free operations.   : 
1369			;                                                                             : 
1369			;     The heap is maintained as a linked list, starting with an initial       : 
1369			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1369			;     the first free block in the heap. Each block then points to the next    : 
1369			;     free block within the heap, and the free list ends at the first block   : 
1369			;     with a null pointer to the next free block.                             : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     Inputs are compile-time only. Two defines which specify the starting    : 
1369			;     address of the heap and its size are required, along with a memory      : 
1369			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1369			;     principally stores a pointer to the first free block in the heap.       : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     Nothing                                                                 : 
1369			;------------------------------------------------------------------------------ 
1369			heap_init: 
1369			      push  HL 
1369			 
1369			      ; Initialise free list struct 
1369			      ld    HL, heap_start 
1369			      ld    (free_list), HL 
1369			      ld    HL, 0 
1369			      ld    (free_list+2), HL 
1369			 
1369			      ; Insert first free block at bottom of heap, consumes entire heap 
1369			      ld    HL, heap_start+heap_size-4 
1369			      ld    (heap_start), HL        ; Next block (end of free list) 
1369			      ld    HL, heap_size-4 
1369			      ld    (heap_start+2), HL      ; Block size 
1369			 
1369			      ; Insert end of free list block at top of heap - two null words will 
1369			      ; terminate the free list 
1369			      ld    HL, 0 
1369			      ld    (heap_start+heap_size-2), HL 
1369			      ld    (heap_start+heap_size-4), HL 
1369			 
1369			      pop   HL 
1369			 
1369			      ret 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     malloc                                                                  : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Allocates the wanted space from the heap and returns the address of the : 
1369			;     first useable byte of the allocation.                                   : 
1369			;                                                                             : 
1369			;     Allocations can happen in one of two ways:                              : 
1369			;                                                                             : 
1369			;     1. A free block may be found which is the exact size wanted. In this    : 
1369			;        case the block is removed from the free list and retuedn to the      : 
1369			;        caller.                                                              : 
1369			;     2. A free block may be found which is larger than the size wanted. In   : 
1369			;        this case, the larger block is split into two. The first portion of  : 
1369			;        this block will become the requested space by the malloc call and    : 
1369			;        is returned to the caller. The second portion becomes a new free     : 
1369			;        block, and the free list is adjusted to maintain continuity via this : 
1369			;        newly created block.                                                 : 
1369			;                                                                             : 
1369			;     malloc does not set any initial value in the allocated space, the       : 
1369			;     caller is required to do this as required.                              : 
1369			;                                                                             : 
1369			;     This implementation of malloc uses the stack exclusively, and is        : 
1369			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1369			;     advisable to disable interrupts before calling malloc, and recommended  : 
1369			;     to avoid the use of malloc inside ISRs in general.                      : 
1369			;                                                                             : 
1369			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     HL  Number of bytes wanted                                              : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     HL  Address of the first useable byte of the allocation                 : 
1369			;                                                                             : 
1369			; Flags                                                                       : 
1369			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1369			;                                                                             : 
1369			; Stack frame                                                                 : 
1369			;       |             |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     BC      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     DE      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     IX      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |  prev_free  |                                                       : 
1369			;   +4  +-------------+                                                       : 
1369			;       |  this_free  |                                                       : 
1369			;   +2  +-------------+                                                       : 
1369			;       |  next_free  |                                                       : 
1369			;   +0  +-------------+                                                       : 
1369			;       |             |                                                       : 
1369			;                                                                             : 
1369			;------------------------------------------------------------------------------ 
1369			malloc: 
1369			      push  BC 
1369			      push  DE 
1369			      push  IX 
1369			 
1369			      ld    A, H                    ; Exit if no space requested 
1369			      or    L 
1369			      jp    Z, malloc_early_exit 
1369			 
1369			      ; Set up stack frame 
1369			      ex    DE, HL 
1369			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			      ld    IX, 0                   ; Use IX as a frame pointer 
1369			      add   IX, SP 
1369			 
1369			      ; Setup initial state 
1369			      ld    HL, 4                   ; want must also include space used by block struct 
1369			      add   HL, DE 
1369			 
1369			      ld    B, H                    ; Move want to BC 
1369			      ld    C, L 
1369			 
1369			      ld    HL, free_list           ; Store prev_free ptr to stack 
1369			      ld    (IX+4), L 
1369			      ld    (IX+5), H 
1369			 
1369			      ld    E, (HL)                 ; Store this_free ptr to stack 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ld    (IX+2), E 
1369			      ld    (IX+3), D 
1369			      ex    DE, HL                  ; this_free ptr into HL 
1369			 
1369			      ; Loop through free block list to find some space 
1369			malloc_find_space: 
1369			      ld    E, (HL)                 ; Load next_free ptr into DE 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1369			      or    E 
1369			      jp    Z, malloc_no_space 
1369			 
1369			      ld    (IX+0), E               ; Store next_free ptr to stack 
1369			      ld    (IX+1), D 
1369			 
1369			      ; Does this block have enough space to make the allocation? 
1369			      inc   HL                      ; Load free block size into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      ex    DE, HL                  ; Check size of block against want 
1369			      or    A                       ; Ensure carry flag clear 
1369			      sbc   HL, BC 
1369			      push  HL                      ; Store the result for later (new block size) 
1369			 
1369			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1369			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1369			 
1369			      ; this_free block is not big enough, setup ptrs to test next free block 
1369			      pop   HL                      ; Discard previous result 
1369			 
1369			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1369			      ld    H, (IX+3) 
1369			      ld    (IX+4), L 
1369			      ld    (IX+5), H 
1369			 
1369			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1369			      ld    H, (IX+1) 
1369			      ld    (IX+2), L 
1369			      ld    (IX+3), H 
1369			 
1369			      jr    malloc_find_space 
1369			 
1369			      ; split a bigger block into two - requested size and remaining size 
1369			malloc_alloc_split: 
1369			      ex    DE, HL                  ; Calculate address of new free block 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			      add   HL, BC 
1369			 
1369			      ; Create a new block and point it at next_free 
1369			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1369			      ld    D, (IX+1) 
1369			 
1369			      ld    (HL), E                 ; Store next_free ptr into new block 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   DE                      ; Store size of new block into new block 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Update this_free ptr to point to new block 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1369			      ld    D, (IX+3) 
1369			 
1369			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1369			      ld    (IX+3), H 
1369			 
1369			      ; Modify this_free block to be allocation 
1369			      ex    DE, HL 
1369			      xor   A                       ; Null the next block ptr of allocated block 
1369			      ld    (HL), A 
1369			      inc   HL 
1369			      ld    (HL), A 
1369			 
1369			      inc   HL                      ; Store want size into allocated block 
1369			      ld    (HL), C 
1369			      inc   HL 
1369			      ld    (HL), B 
1369			      inc   HL 
1369			      push  HL                      ; Address of allocation to return 
1369			 
1369			      jr    malloc_update_links 
1369			 
1369			malloc_alloc_fit: 
1369			      pop   HL                      ; Dont need new block size, want is exact fit 
1369			 
1369			      ; Modify this_free block to be allocation 
1369			      ex    DE, HL 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      xor   A                       ; Null the next block ptr of allocated block 
1369			      ld    (HL), A 
1369			      inc   HL 
1369			      ld    (HL), A 
1369			 
1369			      inc   HL                      ; Store address of allocation to return 
1369			      inc   HL 
1369			      inc   HL 
1369			      push  HL 
1369			 
1369			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1369			      ld    L, (IX+0)               ; next_free to HL 
1369			      ld    H, (IX+1) 
1369			 
1369			      ld    (IX+2), L               ; HL to this_free 
1369			      ld    (IX+3), H 
1369			 
1369			 
1369			malloc_update_links: 
1369			      ; Update prev_free ptr to point to this_free 
1369			      ld    L, (IX+4)               ; prev_free ptr to HL 
1369			      ld    H, (IX+5) 
1369			 
1369			      ld    E, (IX+2)               ; this_free ptr to DE 
1369			      ld    D, (IX+3) 
1369			 
1369			      ld    (HL), E                 ; this_free ptr into prev_free 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Clear the Z flag to indicate successful allocation 
1369			      ld    A, D 
1369			      or    E 
1369			 
1369			      pop   DE                      ; Address of allocation 
1369			 
1369			malloc_no_space: 
1369			      ld    HL, 6                   ; Clean up stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			 
1369			      ex    DE, HL                  ; Alloc addr into HL for return 
1369			 
1369			malloc_early_exit: 
1369			      pop   IX 
1369			      pop   DE 
1369			      pop   BC 
1369			 
1369			      ret 
1369			 
1369			 
1369			;------------------------------------------------------------------------------ 
1369			;     free                                                                    : 
1369			;                                                                             : 
1369			; Description                                                                 : 
1369			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1369			;     returned by malloc, otherwise the behaviour is undefined.               : 
1369			;                                                                             : 
1369			;     Where possible, directly adjacent free blocks will be merged together   : 
1369			;     into larger blocks to help ensure that the heap does not become         : 
1369			;     excessively fragmented.                                                 : 
1369			;                                                                             : 
1369			;     free does not clear or set any other value into the freed space, and    : 
1369			;     therefore its contents may be visible through subsequent malloc's. The  : 
1369			;     caller should clear the freed space as required.                        : 
1369			;                                                                             : 
1369			;     This implementation of free uses the stack exclusively, and is          : 
1369			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1369			;     advisable to disable interrupts before calling free, and recommended    : 
1369			;     to avoid the use of free inside ISRs in general.                        : 
1369			;                                                                             : 
1369			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1369			;                                                                             : 
1369			; Parameters                                                                  : 
1369			;     HL  Pointer to address of first byte of allocation to be freed          : 
1369			;                                                                             : 
1369			; Returns                                                                     : 
1369			;     Nothing                                                                 : 
1369			;                                                                             : 
1369			; Stack frame                                                                 : 
1369			;       |             |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     BC      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     DE      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |     IX      |                                                       : 
1369			;       +-------------+                                                       : 
1369			;       |  prev_free  |                                                       : 
1369			;   +2  +-------------+                                                       : 
1369			;       |  next_free  |                                                       : 
1369			;   +0  +-------------+                                                       : 
1369			;       |             |                                                       : 
1369			;                                                                             : 
1369			;------------------------------------------------------------------------------ 
1369			free: 
1369			      push  BC 
1369			      push  DE 
1369			      push  IX 
1369			 
1369			      ld    A, H                    ; Exit if ptr is null 
1369			      or    L 
1369			      jp    Z, free_early_exit 
1369			 
1369			      ; Set up stack frame 
1369			      ex    DE, HL 
1369			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			      ld    IX, 0                   ; Use IX as a frame pointer 
1369			      add   IX, SP 
1369			 
1369			      ; The address in HL points to the start of the useable allocated space, 
1369			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1369			      ; address of the block itself. 
1369			      ex    DE, HL 
1369			      ld    DE, -4 
1369			      add   HL, DE 
1369			 
1369			      ; An allocated block must have a null next block pointer in it 
1369			      ld    A, (HL) 
1369			      inc   HL 
1369			      or    (HL) 
1369			      jp    NZ, free_done 
1369			 
1369			      dec   HL 
1369			 
1369			      ld    B, H                    ; Copy HL to BC 
1369			      ld    C, L 
1369			 
1369			      ; Loop through the free list to find the first block with an address 
1369			      ; higher than the block being freed 
1369			      ld    HL, free_list 
1369			 
1369			free_find_higher_block: 
1369			      ld    E, (HL)                 ; Load next ptr from free block 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      dec   HL 
1369			 
1369			      ld    (IX+0), E               ; Save ptr to next free block 
1369			      ld    (IX+1), D 
1369			      ld    (IX+2), L               ; Save ptr to prev free block 
1369			      ld    (IX+3), H 
1369			 
1369			      ld    A, B                    ; Check if DE is greater than BC 
1369			      cp    D                       ; Compare MSB first 
1369			      jr    Z, $+4                  ; MSB the same, compare LSB 
1369			      jr    NC, free_find_higher_block_skip 
1369			      ld    A, C 
1369			      cp    E                       ; Then compare LSB 
1369			      jr    C, free_found_higher_block 
1369			 
1369			free_find_higher_block_skip: 
1369			      ld    A, D                    ; Reached the end of the free list? 
1369			      or    E 
1369			      jp    Z, free_done 
1369			 
1369			      ex    DE, HL 
1369			 
1369			      jr    free_find_higher_block 
1369			 
1369			free_found_higher_block: 
1369			      ; Insert freed block between prev and next free blocks 
1369			      ld    (HL), C                 ; Point prev free block to freed block 
1369			      inc   HL 
1369			      ld    (HL), B 
1369			 
1369			      ld    H, B                    ; Point freed block at next free block 
1369			      ld    L, C 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      ; Check if the freed block is adjacent to the next free block 
1369			      inc   HL                      ; Load size of freed block into HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ex    DE, HL 
1369			 
1369			      add   HL, BC                  ; Add addr of freed block and its size 
1369			 
1369			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1369			      ld    D, (IX+1) 
1369			 
1369			      or    A                       ; Clear the carry flag 
1369			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1369			      jr    NZ, free_check_adjacent_to_prev 
1369			 
1369			      ; Freed block is adjacent to next, merge into one bigger block 
1369			      ex    DE, HL                  ; Load next ptr from next block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  HL                      ; Save ptr to next block for later 
1369			 
1369			      ld    H, B                    ; Store ptr from next block into freed block 
1369			      ld    L, C 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   HL                      ; Restore ptr to next block 
1369			      inc   HL                      ; Load size of next block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  DE                      ; Save next block size for later 
1369			 
1369			      ld    H, B                    ; Load size of freed block into HL 
1369			      ld    L, C 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      ex    DE, HL 
1369			 
1369			      pop   DE                      ; Restore size of next block 
1369			      add   HL, DE                  ; Add sizes of both blocks 
1369			      ex    DE, HL 
1369			 
1369			      ld    H, B                    ; Store new bigger size into freed block 
1369			      ld    L, C 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			free_check_adjacent_to_prev: 
1369			      ; Check if the freed block is adjacent to the prev free block 
1369			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1369			      ld    H, (IX+3) 
1369			 
1369			      inc   HL                      ; Size of prev free block into DE 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      dec   HL 
1369			      dec   HL 
1369			      dec   HL 
1369			 
1369			      add   HL, DE                  ; Add prev block addr and size 
1369			 
1369			      or    A                       ; Clear the carry flag 
1369			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1369			      jr    NZ, free_done 
1369			 
1369			      ; Freed block is adjacent to prev, merge into one bigger block 
1369			      ld    H, B                    ; Load next ptr from freed block into DE 
1369			      ld    L, C 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  HL                      ; Save freed block ptr for later 
1369			 
1369			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1369			      ld    H, (IX+3) 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			      pop   HL                      ; Restore freed block ptr 
1369			      inc   HL                      ; Load size of freed block into DE 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			      push  DE                      ; Save freed block size for later 
1369			 
1369			      ld    L, (IX+2)               ; Load size of prev block into DE 
1369			      ld    H, (IX+3) 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    E, (HL) 
1369			      inc   HL 
1369			      ld    D, (HL) 
1369			 
1369			      pop   HL                      ; Add sizes of both blocks 
1369			      add   HL, DE 
1369			      ex    DE, HL 
1369			 
1369			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1369			      ld    H, (IX+3) 
1369			      inc   HL 
1369			      inc   HL 
1369			      ld    (HL), E 
1369			      inc   HL 
1369			      ld    (HL), D 
1369			 
1369			free_done: 
1369			      ld    HL, 4                   ; Clean up stack frame 
1369			      add   HL, SP 
1369			      ld    SP, HL 
1369			 
1369			free_early_exit: 
1369			      pop   IX 
1369			      pop   DE 
1369			      pop   BC 
1369			 
1369			      ret 
1369			 
1369			 
1369			;      .org 0x8000 
1369			; 
1369			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1369			 ;                 .dw   0 
1369			 
1369			endif 
1369			 
1369			 
1369			if MALLOC_4 
1369			 
1369			; My memory allocation code. Very very simple.... 
1369			; allocate space under 250 chars 
1369			 
1369			heap_init: 
1369				; init start of heap as zero 
1369				;  
1369			 
1369				ld hl, heap_start 
1369				ld a, 0 
1369				ld (hl), a      ; empty block 
1369				inc hl 
1369				ld a, 0 
1369				ld (hl), a      ; length of block 
1369				; write end of list 
1369				inc hl 
1369				ld a,(hl) 
1369				inc hl 
1369				ld a,(hl) 
1369				 
1369			 
1369				; init some malloc vars 
1369			 
1369				ld hl, 0 
1369				ld (free_list), hl       ; store last malloc location 
1369			 
1369				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1369				ld a, 0 
1369				ld (hl), a 
1369			 
1369			 
1369				ld hl, heap_start 
1369				;  
1369				  
1369				ret 
1369			 
1369			 
1369			;    free block marker 
1369			;    requested size  
1369			;    pointer to next block 
1369			;    .... 
1369			;    next block marker 
1369			 
1369			 
1369			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1369			; 
1369			 
1369			 
1369			malloc:  
1369				push de 
1369				push bc 
1369				push af 
1369			 
1369				; hl space required 
1369				 
1369				ld c, l    ; hold space   (TODO only a max of 255) 
1369			 
1369			;	inc c     ; TODO BUG need to fix memory leak on push str 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			;	inc c 
1369			 
1369			 
1369			 
1369				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1369			 
1369				ld a, (free_list+3) 
1369				cp 0 
1369				jr z, .contheap 
1369			 
1369				ld hl, (free_list)     ; get last alloc 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mrs" 
1369						CALLMONITOR 
1369					endif 
1369				jr .startalloc 
1369			 
1369			.contheap: 
1369				ld hl, heap_start 
1369			 
1369			.startalloc: 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mym" 
1369						CALLMONITOR 
1369					endif 
1369			.findblock: 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mmf" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369				ld a,(hl)  
1369				; if byte is zero then clear to use 
1369			 
1369				cp 0 
1369				jr z, .foundemptyblock 
1369			 
1369				; if byte is not clear 
1369				;     then byte is offset to next block 
1369			 
1369				inc hl 
1369				ld a, (hl) ; get size 
1369			.nextblock:	inc hl 
1369					ld e, (hl) 
1369					inc hl 
1369					ld d, (hl) 
1369					ex de, hl 
1369			;	inc hl  ; move past the store space 
1369			;	inc hl  ; move past zero index  
1369			 
1369				; TODO detect no more space 
1369			 
1369				push hl 
1369				ld de, heap_end 
1369				call cmp16 
1369				pop hl 
1369				jr nc, .nospace 
1369			 
1369				jr .findblock 
1369			 
1369			.nospace: ld hl, 0 
1369				jp .exit 
1369			 
1369			 
1369			.foundemptyblock:	 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mme" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			; TODO has block enough space if reusing??? 
1369			 
1369				;  
1369			 
1369			; see if this block has been previously used 
1369				inc hl 
1369				ld a, (hl) 
1369				dec hl 
1369				cp 0 
1369				jr z, .newblock 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "meR" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			; no reusing previously allocated block 
1369			 
1369			; is it smaller than previously used? 
1369				 
1369				inc hl    ; move to size 
1369				ld a, c 
1369				sub (hl)        ; we want c < (hl) 
1369				dec hl    ; move back to marker 
1369			        jr z, .findblock 
1369			 
1369				; update with the new size which should be lower 
1369			 
1369			        ;inc  hl   ; negate next move. move back to size  
1369			 
1369			.newblock: 
1369				; need to be at marker here 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "meN" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			 
1369				ld a, c 
1369			 
1369				ld (free_list+3), a	 ; flag resume from last malloc  
1369				ld (free_list), hl    ; save out last location 
1369			 
1369			 
1369				;inc a     ; space for length byte 
1369				ld (hl), a     ; save block in use marker 
1369			 
1369				inc hl   ; move to space marker 
1369				ld (hl), a    ; save new space 
1369			 
1369				inc hl   ; move to start of allocated area 
1369				 
1369			;	push hl     ; save where we are - 1  
1369			 
1369			;	inc hl  ; move past zero index  
1369				; skip space to set down new marker 
1369			 
1369				; provide some extra space for now 
1369			 
1369				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1369				inc a 
1369				inc a 
1369			 
1369				push hl   ; save where we are in the node block 
1369			 
1369				call addatohl 
1369			 
1369				; write linked list point 
1369			 
1369				pop de     ; get our node position 
1369				ex de, hl 
1369			 
1369				ld (hl), e 
1369				inc hl 
1369				ld (hl), d 
1369			 
1369				inc hl 
1369			 
1369				; now at start of allocated data so save pointer 
1369			 
1369				push hl 
1369			 
1369				; jump to position of next node and setup empty header in DE 
1369			 
1369				ex de, hl 
1369			 
1369			;	inc hl ; move past end of block 
1369			 
1369				ld a, 0 
1369				ld (hl), a   ; empty marker 
1369				inc hl 
1369				ld (hl), a   ; size 
1369				inc hl  
1369				ld (hl), a   ; ptr 
1369				inc hl 
1369				ld (hl), a   ; ptr 
1369			 
1369			 
1369				pop hl 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "mmr" 
1369						CALLMONITOR 
1369					endif 
1369			 
1369			.exit: 
1369				pop af 
1369				pop bc 
1369				pop de  
1369				ret 
1369			 
1369			 
1369			 
1369			 
1369			free:  
1369				push hl 
1369				push af 
1369				; get address in hl 
1369			 
1369					if DEBUG_FORTH_MALLOC_INT 
1369						DMARK "fre" 
1369						CALLMONITOR 
1369					endif 
1369				; data is at hl - move to block count 
1369				dec hl 
1369				dec hl    ; get past pointer 
1369				dec hl 
1369			 
1369				ld a, (hl)    ; need this for a validation check 
1369			 
1369				dec hl    ; move to block marker 
1369			 
1369				; now check that the block count and block marker are the same  
1369			        ; this checks that we are on a malloc node and not random memory 
1369			        ; OK a faint chance this could be a problem but rare - famous last words! 
1369			 
1369				ld c, a 
1369				ld a, (hl)    
1369			 
1369				cp c 
1369				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1369			 
1369				; yes good chance we are on a malloc node 
1369			 
1369				ld a, 0      
1369				ld (hl), a   ; mark as free 
1369			 
1369				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1369			 
1369			.freeignore:  
1369			 
1369				pop af 
1369				pop hl 
1369			 
1369				ret 
1369			 
1369			 
1369			 
1369			endif 
1369			 
1369			; eof 
# End of file firmware_memory.asm
1369			  
1369			; device C  
1369			; Now handled by SPI  
1369			;if SOUND_ENABLE  
1369			;	include "firmware_sound.asm"  
1369			;endif  
1369			  
1369			include "firmware_diags.asm"  
1369			; Hardware diags menu 
1369			 
1369			 
1369			config: 
1369			 
1369 3e 00			ld a, 0 
136b 21 8f 13			ld hl, .configmn 
136e cd f9 0b			call menu 
1371			 
1371 fe 00			cp 0 
1373 c8				ret z 
1374			 
1374			;	cp 1 
1374			;	call z, .savetostore 
1374			 
1374 fe 01			cp 1 
1376			if STARTUP_V1 
1376 cc a5 13			call z, .selautoload 
1379			endif 
1379			 
1379			if STARTUP_V2 
1379				call z, .enautoload 
1379			endif 
1379 fe 02			cp 2 
137b cc 9b 13			call z, .disautoload 
137e			;	cp 3 
137e			;	call z, .selbank 
137e fe 03			cp 3 
1380 cc c3 13			call z, .debug_tog 
1383 fe 04			cp 4 
1385 cc 11 15			call z, .bpsgo 
1388 fe 05			cp 5 
138a cc ec 13			call z, hardware_diags 
138d			if STARTUP_V2 
138d				cp 6 
138d				call z, create_startup 
138d			endif 
138d 18 da			jr config 
138f			 
138f			.configmn: 
138f			;	dw prom_c3 
138f ff 16			dw prom_c2 
1391 14 17			dw prom_c2a 
1393			;	dw prom_c2b 
1393			;	dw prom_c4 
1393 33 17			dw prom_m4 
1395 4e 17			dw prom_m4b 
1397 56 17			dw prom_c1 
1399			if STARTUP_V2 
1399				dw prom_c9 
1399			endif 
1399 00 00			dw 0 
139b				 
139b			 
139b			if STARTUP_V2 
139b			.enautoload: 
139b				if STORAGE_SE 
139b				ld a, $fe      ; bit 0 clear 
139b				ld (spi_device), a 
139b			 
139b				call storage_get_block_0 
139b			 
139b				ld a, 1 
139b				ld (store_page+STORE_0_AUTOFILE), a 
139b			 
139b					ld hl, 0 
139b					ld de, store_page 
139b				call storage_write_block	 ; save update 
139b				else 
139b			 
139b				ld hl, prom_notav 
139b				ld de, prom_empty 
139b				call info_panel 
139b				endif 
139b			 
139b			 
139b				ret 
139b			endif 
139b			 
139b			.disautoload: 
139b				if STORAGE_SE 
139b				ld a, $fe      ; bit 0 clear 
139b				ld (spi_device), a 
139b			 
139b				call storage_get_block_0 
139b			 
139b				ld a, 0 
139b				ld (store_page+STORE_0_AUTOFILE), a 
139b			 
139b					ld hl, 0 
139b					ld de, store_page 
139b				call storage_write_block	 ; save update 
139b				else 
139b			 
139b 21 65 17			ld hl, prom_notav 
139e 11 7b 17			ld de, prom_empty 
13a1 cd 59 0b			call info_panel 
13a4				endif 
13a4			 
13a4			 
13a4 c9				ret 
13a5			 
13a5			if STARTUP_V1 
13a5			 
13a5			; Select auto start 
13a5			 
13a5			.selautoload: 
13a5			 
13a5				 
13a5				if STORAGE_SE 
13a5			 
13a5					call config_dir 
13a5				        ld hl, scratch 
13a5					ld a, 0 
13a5					call menu 
13a5			 
13a5					cp 0 
13a5					ret z 
13a5			 
13a5					dec a 
13a5			 
13a5			 
13a5					; locate menu option 
13a5			 
13a5					ld hl, scratch 
13a5					call table_lookup 
13a5			 
13a5					if DEBUG_FORTH_WORDS 
13a5						DMARK "ALl" 
13a5						CALLMONITOR 
13a5					endif 
13a5					; with the pointer to the menu it, the byte following the zero term is the file id 
13a5			 
13a5					ld a, 0 
13a5					ld bc, 50   ; max of bytes to look at 
13a5					cpir  
13a5			 
13a5					if DEBUG_FORTH_WORDS 
13a5						DMARK "ALb" 
13a5						CALLMONITOR 
13a5					endif 
13a5					;inc hl 
13a5			 
13a5					ld a, (hl)   ; file id 
13a5					 
13a5				        ; save bank and file ids 
13a5			 
13a5					push af 
13a5			 
13a5			; TODO need to save to block 0 on bank 1	 
13a5			 
13a5					call storage_get_block_0 
13a5			 
13a5					if DEBUG_FORTH_WORDS 
13a5						DMARK "AL0" 
13a5						CALLMONITOR 
13a5					endif 
13a5					pop af 
13a5			 
13a5					ld (store_page+STORE_0_FILERUN),a 
13a5					 
13a5					; save bank id 
13a5			 
13a5					ld a,(spi_device) 
13a5					ld (store_page+STORE_0_BANKRUN),a 
13a5			 
13a5					; enable auto run of store file 
13a5			 
13a5					ld a, 1 
13a5					ld (store_page+STORE_0_AUTOFILE),a 
13a5			 
13a5					; save buffer 
13a5			 
13a5					ld hl, 0 
13a5					ld de, store_page 
13a5					if DEBUG_FORTH_WORDS 
13a5						DMARK "ALw" 
13a5						CALLMONITOR 
13a5					endif 
13a5				call storage_write_block	 ; save update 
13a5			  
13a5			 
13a5			 
13a5			 
13a5					ld hl, scratch 
13a5					call config_fdir 
13a5			 
13a5				else 
13a5			 
13a5 21 65 17			ld hl, prom_notav 
13a8 11 7b 17			ld de, prom_empty 
13ab cd 59 0b			call info_panel 
13ae			 
13ae				endif 
13ae c9				ret 
13af			endif 
13af			 
13af			 
13af			; Select storage bank 
13af			 
13af			.selbank: 
13af			 
13af			;	if STORAGE_SE 
13af			;	else 
13af			 
13af 21 65 17			ld hl, prom_notav 
13b2 11 7b 17			ld de, prom_empty 
13b5 cd 59 0b			call info_panel 
13b8			;	endif 
13b8				 
13b8 c9				ret 
13b9			 
13b9			if STORAGE_SE 
13b9			 
13b9			.config_ldir:   
13b9				; Load storage bank labels into menu array 
13b9			 
13b9				 
13b9			 
13b9			 
13b9				ret 
13b9			 
13b9			 
13b9			endif 
13b9			 
13b9			 
13b9			; Save user words to storage 
13b9			 
13b9			.savetostore: 
13b9			 
13b9			;	if STORAGE_SE 
13b9			; 
13b9			;		call config_dir 
13b9			;	        ld hl, scratch 
13b9			;		ld a, 0 
13b9			;		call menu 
13b9			;		 
13b9			;		ld hl, scratch 
13b9			;		call config_fdir 
13b9			; 
13b9			;	else 
13b9			 
13b9 21 65 17			ld hl, prom_notav 
13bc 11 7b 17			ld de, prom_empty 
13bf cd 59 0b			call info_panel 
13c2			 
13c2			;	endif 
13c2			 
13c2 c9				ret 
13c3			 
13c3			if STARTUP_V2 
13c3			 
13c3			create_startup: 
13c3			 
13c3				ld a, 0 
13c3				ld hl, .crstart 
13c3				call menu 
13c3			 
13c3				cp 0 
13c3				ret z 
13c3			 
13c3				cp 1 
13c3				call z, .genlsword 
13c3				cp 2 
13c3				call z, .genedword 
13c3			 
13c3				cp 3 
13c3				call z, .gendemword 
13c3			 
13c3				cp 4 
13c3				call z, .genutlword 
13c3				cp 5 
13c3				call z, .genspiword 
13c3				cp 6 
13c3				call z, .genkeyword 
13c3				cp 7 
13c3				call z, .gensoundword 
13c3				cp 7 
13c3				call z, .genhwword 
13c3				jr create_startup 
13c3			 
13c3			.genhwword: 
13c3				ld hl, crs_hw 
13c3				ld de, .hwworddef 
13c3				call .genfile 
13c3				ret 
13c3			.gensoundword: 
13c3				ld hl, crs_sound 
13c3				ld de, .soundworddef 
13c3				call .genfile 
13c3				ret 
13c3			.genlsword: 
13c3				ld hl, crs_s1 
13c3				ld de, .lsworddef 
13c3				call .genfile 
13c3				ret 
13c3			 
13c3			.genedword: 
13c3				ld de, .edworddef 
13c3				ld hl, crs_s2 
13c3				call .genfile 
13c3				ret 
13c3			 
13c3			.gendemword: 
13c3				ld de, .demoworddef 
13c3				ld hl, crs_s3 
13c3				call .genfile 
13c3				ret 
13c3			 
13c3			.genutlword: 
13c3				ld hl, crs_s4 
13c3				ld de, .utilwordef 
13c3				call .genfile 
13c3				ret 
13c3			.genspiword: 
13c3				ld hl, crs_s5 
13c3				ld de, .spiworddef 
13c3				call .genfile 
13c3				ret 
13c3			.genkeyword: 
13c3				ld hl, crs_s6 
13c3				ld de, .keyworddef 
13c3				call .genfile 
13c3				ret 
13c3			 
13c3			; hl - points to file name 
13c3			; de - points to strings to add to file 
13c3			 
13c3			.genfile: 
13c3				push hl 
13c3				push de 
13c3			 
13c3				call clear_display 
13c3				ld a, display_row_1 
13c3				ld de, .genfiletxt 
13c3				call str_at_display 
13c3				call update_display 
13c3			 
13c3				pop de 
13c3				pop hl 
13c3			 
13c3			 
13c3				push de 
13c3				call storage_create 
13c3				; id in hl 
13c3				pop de   ; table of strings to add 
13c3			 
13c3			.genloop: 
13c3			 
13c3				push hl ; save id for next time around 
13c3				push de ; save de for next time around 
13c3			 
13c3				ex de, hl 
13c3				call loadwordinhl 
13c3				ex de, hl 
13c3			 
13c3				; need hl to be the id 
13c3				; need de to be the string ptr 
13c3				 
13c3				call storage_append 
13c3			 
13c3				pop de 
13c3				pop hl 
13c3			 
13c3				inc de 
13c3				inc de 
13c3			 
13c3				ld a,(de) 
13c3				cp 0 
13c3				jr nz, .genloop 
13c3				inc de 
13c3				ld a, (de) 
13c3				dec de 
13c3				cp 0 
13c3				jr nz, .genloop	 
13c3			 
13c3				ret 
13c3			 
13c3			.genfiletxt:  db "Creating file...",0 
13c3			 
13c3			.hwworddef: 
13c3				dw test5 
13c3				dw test6 
13c3				dw test7 
13c3				dw test8 
13c3				dw test9 
13c3				dw test10 
13c3				dw 0 
13c3			 
13c3			.soundworddef: 
13c3				dw sound1 
13c3				dw sound2 
13c3				dw sound3 
13c3				dw sound4 
13c3				dw sound5 
13c3				dw sound6 
13c3				dw sound7 
13c3				dw sound8 
13c3				dw sound9 
13c3				dw 0 
13c3			 
13c3			.utilwordef: 
13c3				dw strncpy 
13c3				dw type 
13c3				dw clrstack 
13c3				dw longread 
13c3				dw start1 
13c3				dw start2 
13c3			; duplicated 
13c3			;	dw start3b 
13c3			;	dw start3c 
13c3				dw list 
13c3				dw 0 
13c3			 
13c3			.lsworddef: 
13c3				dw start3b 
13c3				dw 0 
13c3			 
13c3			.edworddef: 
13c3				dw edit1 
13c3				dw edit2 
13c3				dw edit3 
13c3				dw 0 
13c3			 
13c3			.demoworddef: 
13c3				dw game1 
13c3				dw game1a 
13c3				dw game1b 
13c3				dw game1c 
13c3				dw game1d 
13c3				dw game1s 
13c3				dw game1t 
13c3				dw game1f 
13c3				dw game1z 
13c3				dw game1zz 
13c3				dw ssv2 
13c3				dw ssv3 
13c3				dw ssv4 
13c3				dw ssv5 
13c3				dw ssv1 
13c3				dw ssv1cpm	 
13c3			;	dw game2b 
13c3			;	dw game2bf 
13c3			;	dw game2mba 
13c3			;	dw game2mbas	 
13c3			;	dw game2mbht 
13c3			;	dw game2mbms 
13c3			;	dw game2mb 
13c3			;	dw game3w 
13c3			;	dw game3p 
13c3			;	dw game3sc 
13c3			;	dw game3vsi 
13c3			;	dw game3vs 
13c3				dw 0 
13c3			 
13c3			 
13c3			.spiworddef: 
13c3			 
13c3			    dw spi1 
13c3			    dw spi2 
13c3			    dw spi2b 
13c3			    dw spi3 
13c3			    dw spi4 
13c3			    dw spi5 
13c3			;    dw spi6 
13c3			;    dw spi7 
13c3			 
13c3			;    dw spi8 
13c3			;    dw spi9 
13c3			;    dw spi10 
13c3			    dw 0 
13c3			 
13c3			.keyworddef: 
13c3			 
13c3				dw keyup 
13c3				dw keydown 
13c3				dw keyleft 
13c3				dw keyright 
13c3				dw 	keyf1 
13c3				dw keyf2 
13c3				dw keyf3 
13c3				dw keyf4 
13c3				dw keyf5 
13c3				dw keyf6 
13c3				dw keyf7 
13c3				dw keyf8 
13c3				dw keyf9 
13c3				dw keyf10 
13c3				dw keyf11 
13c3				dw keyf12 
13c3				dw keytab 
13c3				dw keycr 
13c3				dw keyhome 
13c3				dw keyend 
13c3				dw keybs 
13c3				dw 0 
13c3			 
13c3			.crstart: 
13c3				dw crs_s1 
13c3				dw crs_s2 
13c3				dw crs_s3 
13c3				dw crs_s4 
13c3				dw crs_s5 
13c3				dw crs_s6 
13c3				dw crs_sound 
13c3				dw crs_hw 
13c3				dw 0 
13c3			 
13c3			endif 
13c3			 
13c3			 
13c3			if STORAGE_SE 
13c3			 
13c3			config_fdir: 
13c3				; using the scratch dir go through and release the memory allocated for each string 
13c3				 
13c3				ld hl, scratch 
13c3			.cfdir:	ld e,(hl) 
13c3				inc hl 
13c3				ld d,(hl) 
13c3				inc hl 
13c3			 
13c3				ex de, hl 
13c3				call ishlzero 
13c3				ret z     ; return on null pointer 
13c3				call free 
13c3				ex de, hl 
13c3				jr .cfdir 
13c3			 
13c3			 
13c3				ret 
13c3			 
13c3			 
13c3			config_dir: 
13c3			 
13c3				; for the config menus that need to build a directory of storage call this routine 
13c3				; it will construct a menu in scratch to pass to menu 
13c3			 
13c3				; open storage device 
13c3			 
13c3				; execute DIR to build a list of files and their ids into scratch in menu format 
13c3				; once the menu has finished then will need to call config_fdir to release the strings 
13c3				 
13c3				; c = number items 
13c3			 
13c3				 
13c3				call storage_get_block_0 
13c3			 
13c3				ld hl, store_page     ; get current id count 
13c3				ld b, (hl) 
13c3				ld c, 0    ; count of files   
13c3			 
13c3			 
13c3				ld hl, scratch 
13c3				ld (store_tmp2), hl    ; location to poke strings 
13c3			 
13c3				; check for empty drive 
13c3			 
13c3				ld a, 0 
13c3				cp b 
13c3				jp z, .dirdone 
13c3			 
13c3				 
13c3					if DEBUG_FORTH_WORDS 
13c3						DMARK "Cdc" 
13c3						CALLMONITOR 
13c3					endif 
13c3			 
13c3			 
13c3			.diritem:	 
13c3				push bc 
13c3				; for each of the current ids do a search for them and if found push to stack 
13c3			 
13c3					ld hl, STORE_BLOCK_PHY 
13c3					ld d, 0		 ; look for extent 0 of block id as this contains file name 
13c3					ld e,b 
13c3			 
13c3					call storage_findnextid 
13c3			 
13c3			 
13c3					; if found hl will be non zero 
13c3			 
13c3					call ishlzero 
13c3					jr z, .dirnotfound 
13c3			 
13c3					; increase count 
13c3			 
13c3					pop bc	 
13c3					inc c 
13c3					push bc 
13c3					 
13c3			 
13c3					; get file header and push the file name 
13c3			 
13c3					ld de, store_page 
13c3					call storage_read_block 
13c3			 
13c3					; push file id to stack 
13c3				 
13c3					ld a, (store_page) 
13c3					ld h, 0 
13c3					ld l, a 
13c3			 
13c3					;call forth_push_numhl 
13c3					; TODO store id 
13c3			 
13c3					push hl 
13c3			 
13c3					; push extent count to stack  
13c3				 
13c3					ld hl, store_page+3 
13c3			 
13c3					; get file name length 
13c3			 
13c3					call strlenz   
13c3			 
13c3					inc hl   ; cover zero term 
13c3					inc hl  ; stick the id at the end of the area 
13c3			 
13c3					push hl 
13c3					pop bc    ; move length to bc 
13c3			 
13c3					call malloc 
13c3			 
13c3					; TODO save malloc area to scratch 
13c3			 
13c3					ex de, hl 
13c3					ld hl, (store_tmp2) 
13c3					ld (hl), e 
13c3					inc hl 
13c3					ld (hl), d 
13c3					inc hl 
13c3					ld (store_tmp2), hl 
13c3			 
13c3					 
13c3			 
13c3					;pop hl   ; get source 
13c3			;		ex de, hl    ; swap aronund	 
13c3			 
13c3					ld hl, store_page+3 
13c3					if DEBUG_FORTH_WORDS 
13c3						DMARK "CFd" 
13c3						CALLMONITOR 
13c3					endif 
13c3					ldir 
13c3			 
13c3					; de is past string, move back one and store id 
13c3					 
13c3					dec de 
13c3			 
13c3					; store file id 
13c3			 
13c3					pop hl 
13c3					ex de,hl 
13c3					ld (hl), e 
13c3			 
13c3					if DEBUG_FORTH_WORDS 
13c3						DMARK "Cdi" 
13c3						CALLMONITOR 
13c3					endif 
13c3					 
13c3			.dirnotfound: 
13c3					pop bc     
13c3					djnz .diritem 
13c3				 
13c3			.dirdone:	 
13c3			 
13c3					ld a, 0 
13c3					ld hl, (store_tmp2) 
13c3					ld (hl), a 
13c3					inc hl 
13c3					ld (hl), a 
13c3					inc hl 
13c3					; push a count of the dir items found 
13c3			 
13c3			;		ld h, 0 
13c3			;		ld l, c 
13c3			 
13c3				ret 
13c3			 
13c3			endif 
13c3			 
13c3			 
13c3			; Settings 
13c3			; Run  
13c3			 
13c3			 
13c3			 
13c3			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
13c3			;;hd_menu2:   db "        2: Editor",0   
13c3			;hd_menu2:   db "        2: Editor       6: Menu",0   
13c3			;hd_menu3:   db "        3: Storage",0 
13c3			;hd_menu4:   db "0=quit  4: Debug",0 
13c3			;hd_don:     db "ON",0 
13c3			;hd_doff:     db "OFF",0 
13c3			; 
13c3			; 
13c3			; 
13c3			;hardware_diags_old:       
13c3			; 
13c3			;.diagmenu: 
13c3			;	call clear_display 
13c3			;	ld a, display_row_1 
13c3			;	ld de, hd_menu1 
13c3			;	call str_at_display 
13c3			; 
13c3			;	ld a, display_row_2 
13c3			;	ld de, hd_menu2 
13c3			;	call str_at_display 
13c3			; 
13c3			;	ld a, display_row_3 
13c3			;	ld de, hd_menu3 
13c3			;	call str_at_display 
13c3			; 
13c3			;	ld a,  display_row_4 
13c3			;	ld de, hd_menu4 
13c3			;	call str_at_display 
13c3			; 
13c3			;	; display debug state 
13c3			; 
13c3			;	ld de, hd_don 
13c3			;	ld a, (os_view_disable) 
13c3			;	cp 0 
13c3			;	jr z, .distog 
13c3			;	ld de, hd_doff 
13c3			;.distog: ld a, display_row_4+17 
13c3			;	call str_at_display 
13c3			; 
13c3			;	call update_display 
13c3			; 
13c3			;	call cin_wait 
13c3			; 
13c3			; 
13c3			; 
13c3			;	cp '4' 
13c3			;	jr nz, .diagn1 
13c3			; 
13c3			;	; debug toggle 
13c3			; 
13c3			;	ld a, (os_view_disable) 
13c3			;	ld b, '*' 
13c3			;	cp 0 
13c3			;	jr z, .debtog 
13c3			;	ld b, 0 
13c3			;.debtog:	 
13c3			;	ld a,b 
13c3			;	ld (os_view_disable),a 
13c3			; 
13c3			;.diagn1: cp '0' 
13c3			;	 ret z 
13c3			; 
13c3			;;	cp '1' 
13c3			;;       jp z, matrix	 
13c3			;;   TODO keyboard matrix test 
13c3			; 
13c3			;	cp '2' 
13c3			;	jp z, .diagedit 
13c3			; 
13c3			;;	cp '6' 
13c3			;;	jp z, .menutest 
13c3			;;if ENABLE_BASIC 
13c3			;;	cp '6' 
13c3			;;	jp z, basic 
13c3			;;endif 
13c3			 ; 
13c3			;	jp .diagmenu 
13c3			; 
13c3			; 
13c3			;	ret 
13c3			 
13c3			 
13c3			.debug_tog: 
13c3 21 0d 14			ld hl, .menudebug 
13c6				 
13c6			;	ld a, (os_view_disable) 
13c6			;	cp '*' 
13c6 3a 6f ee			ld a,(debug_vector) 
13c9 fe c9			cp $C9   ; RET 
13cb 20 04			jr nz,.tdon  
13cd 3e 01			ld a, 1 
13cf 18 02			jr .tog1 
13d1 3e 00		.tdon: ld a, 0 
13d3			 
13d3			.tog1: 
13d3 cd f9 0b			call menu 
13d6 fe 00			cp 0 
13d8 c8				ret z 
13d9 fe 01			cp 1    ; disable debug 
13db 28 04			jr z, .dtog0 
13dd 3e 2a			ld a, '*' 
13df 18 05			jr .dtogset 
13e1			.dtog0:  
13e1				;ld a, 0 
13e1 cd ff 14			call bp_on 
13e4 18 dd			jr .debug_tog 
13e6			.dtogset:  
13e6				; ld (os_view_disable), a 
13e6 cd 0b 15			call bp_off 
13e9 c3 c3 13			jp .debug_tog 
13ec			 
13ec			 
13ec			hardware_diags:       
13ec			 
13ec			.diagm: 
13ec 21 ff 13			ld hl, .menuitems 
13ef 3e 00			ld a, 0 
13f1 cd f9 0b			call menu 
13f4			 
13f4 fe 00		         cp 0 
13f6 c8				 ret z 
13f7			 
13f7 fe 02			cp 2 
13f9 ca 58 14			jp z, .diagedit 
13fc			 
13fc			;	cp '6' 
13fc			;	jp z, .menutest 
13fc			;if ENABLE_BASIC 
13fc			;	cp '6' 
13fc			;	jp z, basic 
13fc			;endif 
13fc			  
13fc c3 ec 13			jp .diagm 
13ff			 
13ff				 
13ff 13 14		.menuitems:   	dw .m1 
1401 1e 14				dw .m2 
1403 25 14				dw .m3 
1405 2d 14				dw .m5 
1407 33 14				dw .m5a 
1409 3c 14				dw .m5b 
140b 00 00				dw 0 
140d			 
140d			.menudebug: 
140d 45 14				dw .m6 
140f 4e 14				dw .m7 
1411 00 00				dw 0 
1413			 
1413 .. 00		.m1:   db "Key Matrix",0 
141e .. 00		.m2:   db "Editor",0 
1425 .. 00		.m3:   db "Storage",0 
142d .. 00		.m5:   db "Sound",0 
1433 .. 00		.m5a:  db "RAM Test",0 
143c .. 00		.m5b:  db "LCD Test",0 
1445			 
1445 .. 00		.m6:   db "Debug ON",0 
144e .. 00		.m7:   db "Debug OFF",0 
1458			 
1458			; debug editor 
1458			 
1458			.diagedit: 
1458			 
1458 21 bb e2			ld hl, scratch 
145b			;	ld bc, 250 
145b			;	ldir 
145b				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
145b 3e 00			ld a, 0 
145d 77				ld (hl), a 
145e 23				inc hl 
145f 77				ld (hl), a 
1460 23				inc hl 
1461 77				ld (hl), a 
1462			 
1462 cd c8 0b		        call clear_display 
1465 cd eb 0b			call update_display 
1468				;ld a, 1 
1468				;ld (hardware_diag), a 
1468			.diloop: 
1468 3e 00			ld a, display_row_1 
146a 0e 00			ld c, 0 
146c 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
146e 1e 28			ld e, 40 
1470			 
1470 21 bb e2			ld hl, scratch	 
1473 cd 22 0e			call input_str 
1476			 
1476 3e 28			ld a, display_row_2 
1478 11 bb e2			ld de, scratch 
147b cd db 0b			call str_at_display 
147e cd eb 0b			call update_display 
1481			 
1481 c3 68 14			jp .diloop 
1484			 
1484			 
1484			; pass word in hl 
1484			; a has display location 
1484			display_word_at: 
1484 f5				push af 
1485 e5				push hl 
1486 7c				ld a,h 
1487 21 c0 e5			ld hl, os_word_scratch 
148a cd fe 0f			call hexout 
148d e1				pop hl 
148e 7d				ld a,l 
148f 21 c2 e5			ld hl, os_word_scratch+2 
1492 cd fe 0f			call hexout 
1495 21 c4 e5			ld hl, os_word_scratch+4 
1498 3e 00			ld a,0 
149a 77				ld (hl),a 
149b 11 c0 e5			ld de,os_word_scratch 
149e f1				pop af 
149f cd db 0b				call str_at_display 
14a2 c9				ret 
14a3			 
14a3			display_ptr_state: 
14a3			 
14a3				; to restore afterwards 
14a3			 
14a3 d5				push de 
14a4 c5				push bc 
14a5 e5				push hl 
14a6 f5				push af 
14a7			 
14a7				; for use in here 
14a7			 
14a7			;	push bc 
14a7			;	push de 
14a7			;	push hl 
14a7			;	push af 
14a7			 
14a7 cd c8 0b			call clear_display 
14aa			 
14aa 11 82 16			ld de, .ptrstate 
14ad 3e 00			ld a, display_row_1 
14af cd db 0b			call str_at_display 
14b2			 
14b2				; display debug step 
14b2			 
14b2			 
14b2 11 65 ee			ld de, debug_mark 
14b5 3e 26			ld a, display_row_1+display_cols-2 
14b7 cd db 0b			call str_at_display 
14ba			 
14ba				; display a 
14ba 11 8c 16			ld de, .ptrcliptr 
14bd 3e 28			ld a, display_row_2 
14bf cd db 0b			call str_at_display 
14c2			 
14c2 f1				pop af 
14c3 2a 3a ea			ld hl,(cli_ptr) 
14c6 3e 30			ld a, display_row_2+8 
14c8 cd 84 14			call display_word_at 
14cb			 
14cb			 
14cb				; display hl 
14cb			 
14cb			 
14cb 11 94 16			ld de, .ptrclioptr 
14ce 3e 32			ld a, display_row_2+10 
14d0 cd db 0b			call str_at_display 
14d3			; 
14d3			;	pop hl 
14d3 3e 35			ld a, display_row_2+13 
14d5 2a 38 ea			ld hl,(cli_origptr) 
14d8 cd 84 14			call display_word_at 
14db			; 
14db			;	 
14db			;	; display de 
14db			 
14db			;	ld de, .regstatede 
14db			;	ld a, display_row_3 
14db			;	call str_at_display 
14db			 
14db			;	pop de 
14db			;	ld h,d 
14db			;	ld l, e 
14db			;	ld a, display_row_3+3 
14db			;	call display_word_at 
14db			 
14db			 
14db				; display bc 
14db			 
14db			;	ld de, .regstatebc 
14db			;	ld a, display_row_3+10 
14db			;	call str_at_display 
14db			 
14db			;	pop bc 
14db			;	ld h,b 
14db			;	ld l, c 
14db			;	ld a, display_row_3+13 
14db			;	call display_word_at 
14db			 
14db			 
14db				; display dsp 
14db			 
14db			;	ld de, .regstatedsp 
14db			;	ld a, display_row_4 
14db			;	call str_at_display 
14db			 
14db				 
14db			;	ld hl,(cli_data_sp) 
14db			;	ld a, display_row_4+4 
14db			;	call display_word_at 
14db			 
14db				; display rsp 
14db			 
14db 11 c3 16			ld de, .regstatersp 
14de 3e 82			ld a, display_row_4+10 
14e0 cd db 0b			call str_at_display 
14e3			 
14e3				 
14e3 2a ec e9			ld hl,(cli_ret_sp) 
14e6 3e 86			ld a, display_row_4+14 
14e8 cd 84 14			call display_word_at 
14eb			 
14eb cd eb 0b			call update_display 
14ee			 
14ee cd 00 0b			call delay1s 
14f1 cd 00 0b			call delay1s 
14f4 cd 00 0b			call delay1s 
14f7			 
14f7			 
14f7 cd 08 1b			call next_page_prompt 
14fa			 
14fa				; restore  
14fa			 
14fa f1				pop af 
14fb e1				pop hl 
14fc c1				pop bc 
14fd d1				pop de 
14fe c9				ret 
14ff			 
14ff			; Update the break point vector so that the user can hook a new routine 
14ff			 
14ff			bp_on: 
14ff 3e c3			ld a, $c3    ; JP 
1501 32 6f ee			ld (debug_vector), a 
1504 21 11 15			ld hl, break_point_state 
1507 22 70 ee			ld (debug_vector+1), hl 
150a c9				ret 
150b			 
150b			bp_off: 
150b 3e c9			ld a, $c9    ; RET 
150d 32 6f ee			ld (debug_vector), a 
1510 c9				ret 
1511			 
1511			 
1511			break_point_state: 
1511			;	push af 
1511			; 
1511			;	; see if disabled 
1511			; 
1511			;	ld a, (os_view_disable) 
1511			;	cp '*' 
1511			;	jr nz, .bpsgo 
1511			;	pop af 
1511			;	ret 
1511			 
1511			.bpsgo: 
1511			;	pop af 
1511 f5				push af 
1512 22 9d e2			ld (os_view_hl), hl 
1515 ed 53 9b e2		ld (os_view_de), de 
1519 ed 43 99 e2		ld (os_view_bc), bc 
151d e5				push hl 
151e 6f				ld l, a 
151f 26 00			ld h, 0 
1521 22 9f e2			ld (os_view_af),hl 
1524			 
1524 21 ab ed				ld hl, display_fb0 
1527 22 c6 eb				ld (display_fb_active), hl 
152a e1				pop hl	 
152b			 
152b 3e 31			ld a, '1' 
152d fe 2a		.bps1:  cp '*' 
152f cc 0b 15			call z, bp_off 
1532			;	jr nz, .bps1b 
1532			;	ld (os_view_disable),a 
1532 fe 31		.bps1b:  cp '1' 
1534 20 14			jr nz, .bps2 
1536			 
1536				; display reg 
1536			 
1536				 
1536			 
1536 3a 9f e2			ld a, (os_view_af) 
1539 2a 9d e2			ld hl, (os_view_hl) 
153c ed 5b 9b e2		ld de, (os_view_de) 
1540 ed 4b 99 e2		ld bc, (os_view_bc) 
1544 cd de 15			call display_reg_state 
1547 c3 ca 15			jp .bpschk 
154a			 
154a fe 32		.bps2:  cp '2' 
154c 20 08			jr nz, .bps3 
154e				 
154e				; display hl 
154e 2a 9d e2			ld hl, (os_view_hl) 
1551 cd c8 16			call display_dump_at_hl 
1554			 
1554 18 74			jr .bpschk 
1556			 
1556 fe 33		.bps3:  cp '3' 
1558 20 08			jr nz, .bps4 
155a			 
155a			        ; display de 
155a 2a 9b e2			ld hl, (os_view_de) 
155d cd c8 16			call display_dump_at_hl 
1560			 
1560 18 68			jr .bpschk 
1562 fe 34		.bps4:  cp '4' 
1564 20 08			jr nz, .bps5 
1566			 
1566			        ; display bc 
1566 2a 99 e2			ld hl, (os_view_bc) 
1569 cd c8 16			call display_dump_at_hl 
156c			 
156c 18 5c			jr .bpschk 
156e fe 35		.bps5:  cp '5' 
1570 20 08		        jr nz, .bps7 
1572			 
1572				; display cur ptr 
1572 2a 3a ea			ld hl, (cli_ptr) 
1575 cd c8 16			call display_dump_at_hl 
1578			 
1578 18 50			jr .bpschk 
157a fe 36		.bps7:  cp '6' 
157c 20 08			jr nz, .bps8b 
157e				 
157e				; display cur orig ptr 
157e 2a 38 ea			ld hl, (cli_origptr) 
1581 cd c8 16			call display_dump_at_hl 
1584 18 44			jr .bpschk 
1586 fe 37		.bps8b:  cp '7' 
1588 20 08			jr nz, .bps9 
158a				 
158a				; display dsp 
158a 2a e8 e9			ld hl, (cli_data_sp) 
158d cd c8 16			call display_dump_at_hl 
1590			 
1590 18 38			jr .bpschk 
1592 fe 39		.bps9:  cp '9' 
1594 20 05			jr nz, .bps8c 
1596				 
1596				; display SP 
1596			;	ld hl, sp 
1596 cd c8 16			call display_dump_at_hl 
1599			 
1599 18 2f			jr .bpschk 
159b fe 38		.bps8c:  cp '8' 
159d 20 08			jr nz, .bps8d 
159f				 
159f				; display rsp 
159f 2a ec e9			ld hl, (cli_ret_sp) 
15a2 cd c8 16			call display_dump_at_hl 
15a5			 
15a5 18 23			jr .bpschk 
15a7 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
15a9 20 05			jr nz, .bps8 
15ab cd c2 18			call monitor 
15ae			 
15ae 18 1a			jr .bpschk 
15b0 fe 30		.bps8:  cp '0' 
15b2 20 16			jr nz, .bpschk 
15b4			 
15b4 21 0a ed				ld hl, display_fb1 
15b7 22 c6 eb				ld (display_fb_active), hl 
15ba cd eb 0b				call update_display 
15bd			 
15bd				;ld a, (os_view_af) 
15bd 2a 9d e2			ld hl, (os_view_hl) 
15c0 ed 5b 9b e2		ld de, (os_view_de) 
15c4 ed 4b 99 e2		ld bc, (os_view_bc) 
15c8 f1				pop af 
15c9 c9				ret 
15ca			 
15ca			.bpschk:   
15ca cd 00 0b			call delay1s 
15cd 3e 9f		ld a,display_row_4 + display_cols - 1 
15cf 11 06 1b		        ld de, endprg 
15d2 cd db 0b			call str_at_display 
15d5 cd eb 0b			call update_display 
15d8 cd f1 5e			call cin_wait 
15db			 
15db c3 2d 15			jp .bps1 
15de			 
15de			 
15de			display_reg_state: 
15de			 
15de				; to restore afterwards 
15de			 
15de d5				push de 
15df c5				push bc 
15e0 e5				push hl 
15e1 f5				push af 
15e2			 
15e2				; for use in here 
15e2			 
15e2 c5				push bc 
15e3 d5				push de 
15e4 e5				push hl 
15e5 f5				push af 
15e6			 
15e6 cd c8 0b			call clear_display 
15e9			 
15e9 11 9e 16			ld de, .regstate 
15ec 3e 00			ld a, display_row_1 
15ee cd db 0b			call str_at_display 
15f1			 
15f1				; display debug step 
15f1			 
15f1			 
15f1 11 65 ee			ld de, debug_mark 
15f4 3e 25			ld a, display_row_1+display_cols-3 
15f6 cd db 0b			call str_at_display 
15f9			 
15f9				; display a 
15f9 11 ba 16			ld de, .regstatea 
15fc 3e 28			ld a, display_row_2 
15fe cd db 0b			call str_at_display 
1601			 
1601 e1				pop hl 
1602			;	ld h,0 
1602			;	ld l, a 
1602 3e 2b			ld a, display_row_2+3 
1604 cd 84 14			call display_word_at 
1607			 
1607			 
1607				; display hl 
1607			 
1607			 
1607 11 ae 16			ld de, .regstatehl 
160a 3e 32			ld a, display_row_2+10 
160c cd db 0b			call str_at_display 
160f			 
160f e1				pop hl 
1610 3e 35			ld a, display_row_2+13 
1612 cd 84 14			call display_word_at 
1615			 
1615				 
1615				; display de 
1615			 
1615 11 b2 16			ld de, .regstatede 
1618 3e 50			ld a, display_row_3 
161a cd db 0b			call str_at_display 
161d			 
161d e1				pop hl 
161e			;	ld h,d 
161e			;	ld l, e 
161e 3e 53			ld a, display_row_3+3 
1620 cd 84 14			call display_word_at 
1623			 
1623			 
1623				; display bc 
1623			 
1623 11 b6 16			ld de, .regstatebc 
1626 3e 5a			ld a, display_row_3+10 
1628 cd db 0b			call str_at_display 
162b			 
162b e1				pop hl 
162c			;	ld h,b 
162c			;	ld l, c 
162c 3e 5d			ld a, display_row_3+13 
162e cd 84 14			call display_word_at 
1631			 
1631			 
1631				; display dsp 
1631			 
1631 11 be 16			ld de, .regstatedsp 
1634 3e 78			ld a, display_row_4 
1636 cd db 0b			call str_at_display 
1639			 
1639				 
1639 2a e8 e9			ld hl,(cli_data_sp) 
163c 3e 7c			ld a, display_row_4+4 
163e cd 84 14			call display_word_at 
1641			 
1641				; display rsp 
1641			 
1641 11 c3 16			ld de, .regstatersp 
1644 3e 82			ld a, display_row_4+10 
1646 cd db 0b			call str_at_display 
1649			 
1649				 
1649 2a ec e9			ld hl,(cli_ret_sp) 
164c 3e 86			ld a, display_row_4+14 
164e cd 84 14			call display_word_at 
1651			 
1651 cd eb 0b			call update_display 
1654			 
1654			;	call delay1s 
1654			;	call delay1s 
1654			;	call delay1s 
1654			 
1654			 
1654			;	call next_page_prompt 
1654			 
1654				; restore  
1654			 
1654 f1				pop af 
1655 e1				pop hl 
1656 c1				pop bc 
1657 d1				pop de 
1658 c9				ret 
1659			 
1659 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
166d .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1682 .. 00		.ptrstate:	db "Ptr State",0 
168c .. 00		.ptrcliptr:     db "cli_ptr",0 
1694 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
169e .. 00		.regstate:	db "Reg State (1/0)",0 
16ae .. 00		.regstatehl:	db "HL:",0 
16b2 .. 00		.regstatede:	db "DE:",0 
16b6 .. 00		.regstatebc:	db "BC:",0 
16ba .. 00		.regstatea:	db "A :",0 
16be .. 00		.regstatedsp:	db "DSP:",0 
16c3 .. 00		.regstatersp:	db "RSP:",0 
16c8			 
16c8			display_dump_at_hl: 
16c8 e5				push hl 
16c9 d5				push de 
16ca c5				push bc 
16cb f5				push af 
16cc			 
16cc 22 de e5			ld (os_cur_ptr),hl	 
16cf cd c8 0b			call clear_display 
16d2 cd 10 1a			call dumpcont 
16d5			;	call delay1s 
16d5			;	call next_page_prompt 
16d5			 
16d5			 
16d5 f1				pop af 
16d6 c1				pop bc 
16d7 d1				pop de 
16d8 e1				pop hl 
16d9 c9				ret 
16da			 
16da			;if ENABLE_BASIC 
16da			;	include "nascombasic.asm" 
16da			;	basic: 
16da			;	include "forth/FORTH.ASM" 
16da			;endif 
16da			 
16da			; eof 
16da			 
16da			 
# End of file firmware_diags.asm
16da			  
16da			include "firmware_prompts.asm"  
16da			; Prompts  
16da			 
16da			; boot messages 
16da			 
16da .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
16ef .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
16ff			 
16ff			 
16ff			; config menus 
16ff			 
16ff			;prom_c3: db "Add Dictionary To File",0 
16ff			 
16ff			if STARTUP_V1 
16ff .. 00		prom_c2: db "Select Autoload File",0 
1714 .. 00		prom_c2a: db "Disable Autoload File", 0 
172a			endif 
172a			 
172a			if STARTUP_V2 
172a			prom_c2: db "Enable Autoload Files",0 
172a			prom_c2a: db "Disable Autoload Files", 0 
172a			 
172a			crs_s1: db "*ls-word", 0 
172a			crs_s2: db "*ed-word", 0 
172a			crs_s3: db "*Demo-Games", 0 
172a			crs_s4: db "*Utils", 0 
172a			crs_s5: db "*SPI-Util", 0 
172a			crs_s6: db "*Key-Constants", 0 
172a			crs_sound: db "*Sound-Util", 0 
172a			crs_hw: db "*Hello-World",0 
172a			 
172a			 
172a			 
172a			endif 
172a			;prom_c2b: db "Select Storage Bank",0 
172a .. 00		prom_c4: db "Settings",0 
1733 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
174e .. 00		prom_m4b:   db "Monitor",0 
1756 .. 00		prom_c1: db "Hardware Diags",0 
1765			 
1765			 
1765			if STARTUP_V2 
1765			prom_c9: db "Create Startup Files",0 
1765			endif 
1765			 
1765 .. 00		prom_notav:    db "Feature not available",0 
177b .. 00		prom_empty:    db "",0 
177c			 
177c			; eof 
177c			 
# End of file firmware_prompts.asm
177c			  
177c			  
177c			; eof  
177c			  
# End of file firmware.asm
177c			 
177c			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
177c			;if BASE_KEV  
177c			;baseram: equ 08000h 
177c			;endif 
177c			 
177c			;if BASE_SC114 
177c			;baseram:     equ    endofcode 
177c			;endif 
177c			 
177c			 
177c			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
177c			 
177c			; start system 
177c			 
177c			coldstart: 
177c				; set sp 
177c				; di/ei 
177c			 
177c f3				di 
177d 31 00 f0			ld sp, tos 
1780 cd ef 5d			call init_nmi 
1783			;	ei 
1783			 
1783				; init spinner 
1783 3e 00			ld a,0 
1785 32 c0 eb			ld (display_active), a 
1788			 
1788				; disable breakpoint by default 
1788			 
1788				;ld a,'*' 
1788			;	ld a,' ' 
1788			;	ld (os_view_disable),a 
1788			 
1788				; set break point vector as new break point on or off 
1788 cd 0b 15			call bp_off 
178b			 
178b				; init hardware 
178b			 
178b				; init keyboard and screen hardware 
178b			 
178b cd 1f 01			call hardware_init 
178e			 
178e			 
178e cd 00 0b			call delay1s 
1791 3e 58			ld a, display_row_3+8 
1793 11 03 01			ld de, buildtime 
1796 cd db 0b			call str_at_display 
1799 cd eb 0b			call update_display 
179c			 
179c cd 00 0b			call delay1s 
179f cd 00 0b			call delay1s 
17a2 cd 00 0b			call delay1s 
17a5			 
17a5				; detect if any keys are held down to enable breakpoints at start up 
17a5			 
17a5 cd f9 5e			call cin  
17a8 fe 00			cp 0 
17aa 28 03			jr z, .nokeys 
17ac			 
17ac				;call hardware_diags 
17ac cd 69 13			call config 
17af			 
17af			;	ld de, .bpen 
17af			;	ld a, display_row_4 
17af			;	call str_at_display 
17af			;	call update_display 
17af			; 
17af			;	ld a,0 
17af			;	ld (os_view_disable),a 
17af			; 
17af			;.bpwait: 
17af			;	call cin 
17af			;	cp 0 
17af			;	jr z, .bpwait 
17af			;	jr .nokeys 
17af			; 
17af			; 
17af			;.bpen:  db "Break points enabled!",0 
17af			 
17af			 
17af			 
17af			 
17af			 
17af			 
17af			.nokeys: 
17af			 
17af			 
17af				 
17af			 
17af			;jp  testkey 
17af			 
17af			;call storage_get_block_0 
17af			; 
17af			;ld hl, 0 
17af			;ld de, store_page 
17af			;call storage_read_block 
17af			 
17af				 
17af			;ld hl, 10 
17af			;ld de, store_page 
17af			;call storage_read_block 
17af			 
17af			 
17af			 
17af			 
17af			 
17af			;stop:	nop 
17af			;	jp stop 
17af			 
17af			 
17af			 
17af			main: 
17af cd c8 0b			call clear_display 
17b2 cd eb 0b			call update_display 
17b5			 
17b5			 
17b5			 
17b5			;	call testlcd 
17b5			 
17b5			 
17b5			 
17b5 cd 51 1f			call forth_init 
17b8			 
17b8			 
17b8			warmstart: 
17b8 cd 27 1f			call forth_warmstart 
17bb			 
17bb				; run startup word load 
17bb			        ; TODO prevent this running at warmstart after crash  
17bb			 
17bb				if STARTUP_ENABLE 
17bb			 
17bb					if STARTUP_V1 
17bb			 
17bb						if STORAGE_SE 
17bb							call forth_autoload 
17bb						endif 
17bb cd 3f 5d					call forth_startup 
17be					endif 
17be			 
17be					if STARTUP_V2 
17be			 
17be						if STORAGE_SE 
17be							call forth_autoload 
17be						else 
17be							call forth_startup 
17be						endif 
17be			 
17be			 
17be					endif 
17be			 
17be				endif 
17be			 
17be			warmstart_afterauto: 
17be			 
17be				; show free memory after boot 
17be 11 5d 18			ld de, freeram 
17c1 3e 00			ld a, display_row_1 
17c3 cd db 0b			call str_at_display 
17c6			 
17c6				; get current heap start after loading any uwords 
17c6			 
17c6				;ld de, (os_last_new_uword) 
17c6				;ex de, hl 
17c6			 
17c6			; Or use heap_size word???? 
17c6				;ld hl, heap_end 
17c6				;ld hl, heap_size 
17c6				;ld de, topusermem 
17c6				;ld de, heap_start 
17c6 ed 5b 1c 5f			ld de, (free_list )      
17ca 21 96 e2				ld hl, heap_end 
17cd ed 52			sbc hl, de 
17cf				;push hl 
17cf				;ld a,h	         	 
17cf				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
17cf				;call hexout 
17cf			   	;pop hl 
17cf			; 
17cf			;	ld a,l 
17cf			;	ld hl, os_word_scratch+2 
17cf			;	call hexout 
17cf			;	ld hl, os_word_scratch+4 
17cf			;	ld a, 0 
17cf			;	ld (hl),a 
17cf eb				ex de, hl 
17d0 21 c0 e5			ld hl, os_word_scratch 
17d3 cd 0a 11			call uitoa_16 
17d6			 
17d6			 
17d6 11 c0 e5			ld de, os_word_scratch 
17d9 3e 0d			ld a, display_row_1 + 13 
17db cd db 0b			call str_at_display 
17de cd eb 0b			call update_display 
17e1			 
17e1			 
17e1				;call demo 
17e1			 
17e1			 
17e1				; init scratch input area for cli commands 
17e1			 
17e1 21 e2 e5			ld hl, os_cli_cmd 
17e4 3e 00			ld a,0 
17e6 77				ld (hl),a 
17e7 23				inc hl 
17e8 77				ld (hl),a 
17e9			 
17e9 3e 00			ld a,0 
17eb 32 e1 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
17ee			 
17ee 32 de e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
17f1 32 df e5			ld (os_cur_ptr+1),a	 
17f4			 
17f4 32 c0 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
17f7 32 c1 e5			ld (os_word_scratch+1),a	 
17fa				 
17fa			 
17fa				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17fa 21 e2 e5			ld hl, os_cli_cmd 
17fd			 
17fd 3e 00			ld a, 0		 ; init cli input 
17ff 77				ld (hl), a 
1800 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1802			cli: 
1802				; show cli prompt 
1802				;push af 
1802				;ld a, 0 
1802				;ld de, prompt 
1802				;call str_at_display 
1802			 
1802				;call update_display 
1802				;pop af 
1802				;inc a 
1802				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1802			 
1802			.lastrecall: 
1802			 
1802 0e 00			ld c, 0 
1804 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1806 1e 28			ld e, 40 
1808			 
1808 21 e2 e5			ld hl, os_cli_cmd 
180b			 
180b				STACKFRAME OFF $fefe $9f9f 
180b				if DEBUG_STACK_IMB 
180b					if OFF 
180b						exx 
180b						ld de, $fefe 
180b						ld a, d 
180b						ld hl, curframe 
180b						call hexout 
180b						ld a, e 
180b						ld hl, curframe+2 
180b						call hexout 
180b						ld hl, $fefe 
180b						push hl 
180b						ld hl, $9f9f 
180b						push hl 
180b						exx 
180b					endif 
180b				endif 
180b			endm 
# End of macro STACKFRAME
180b			 
180b cd 22 0e			call input_str 
180e			 
180e				STACKFRAMECHK OFF $fefe $9f9f 
180e				if DEBUG_STACK_IMB 
180e					if OFF 
180e						exx 
180e						ld hl, $9f9f 
180e						pop de   ; $9f9f 
180e						call cmp16 
180e						jr nz, .spnosame 
180e						ld hl, $fefe 
180e						pop de   ; $fefe 
180e						call cmp16 
180e						jr z, .spfrsame 
180e						.spnosame: call showsperror 
180e						.spfrsame: nop 
180e						exx 
180e					endif 
180e				endif 
180e			endm 
# End of macro STACKFRAMECHK
180e			 
180e			 
180e				; check to see if last line recall has been requested 
180e			 
180e			if EDIT_V2 
180e fe 05			cp KEY_UP 
1810 20 0f			jr nz, .noexecline 
1812			 
1812 11 e2 e5			ld de, os_cli_cmd 
1815 21 e1 e6			ld hl, os_last_cmd 
1818 01 ff 00			ld bc, 255 
181b ed b0			ldir 
181d 3e 00			ld a, 0 
181f 18 e1			jr .lastrecall 
1821			endif 
1821			 
1821			.noexecline: 
1821				; no so exec the line		 
1821			 
1821				; copy input to last command 
1821			 
1821 21 e2 e5			ld hl, os_cli_cmd 
1824 11 e1 e6			ld de, os_last_cmd 
1827 01 ff 00			ld bc, 255 
182a ed b0			ldir 
182c			 
182c				; wipe current buffer 
182c			 
182c			;	ld a, 0 
182c			;	ld hl, os_cli_cmd 
182c			;	ld de, os_cli_cmd+1 
182c			;	ld bc, 254 
182c			;	ldir 
182c				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
182c			;	call strcpy 
182c			;	ld a, 0 
182c			;	ld (hl), a 
182c			;	inc hl 
182c			;	ld (hl), a 
182c			;	inc hl 
182c			;	ld (hl), a 
182c			 
182c				; switch frame buffer to program  
182c			 
182c 21 0a ed				ld hl, display_fb1 
182f 22 c6 eb				ld (display_fb_active), hl 
1832			 
1832			;	nop 
1832				STACKFRAME ON $fbfe $8f9f 
1832				if DEBUG_STACK_IMB 
1832					if ON 
1832						exx 
1832						ld de, $fbfe 
1832						ld a, d 
1832						ld hl, curframe 
1832						call hexout 
1832						ld a, e 
1832						ld hl, curframe+2 
1832						call hexout 
1832						ld hl, $fbfe 
1832						push hl 
1832						ld hl, $8f9f 
1832						push hl 
1832						exx 
1832					endif 
1832				endif 
1832			endm 
# End of macro STACKFRAME
1832				; first time into the parser so pass over the current scratch pad 
1832 21 e2 e5			ld hl,os_cli_cmd 
1835				; tokenise the entered statement(s) in HL 
1835 cd cf 1f			call forthparse 
1838			        ; exec forth statements in top of return stack 
1838 cd 0f 20			call forthexec 
183b				;call forthexec_cleanup 
183b			;	call parsenext 
183b			 
183b				STACKFRAMECHK ON $fbfe $8f9f 
183b				if DEBUG_STACK_IMB 
183b					if ON 
183b						exx 
183b						ld hl, $8f9f 
183b						pop de   ; $8f9f 
183b						call cmp16 
183b						jr nz, .spnosame 
183b						ld hl, $fbfe 
183b						pop de   ; $fbfe 
183b						call cmp16 
183b						jr z, .spfrsame 
183b						.spnosame: call showsperror 
183b						.spfrsame: nop 
183b						exx 
183b					endif 
183b				endif 
183b			endm 
# End of macro STACKFRAMECHK
183b				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
183b			 
183b 3e 78			ld a, display_row_4 
183d 11 6e 18			ld de, endprog 
1840			 
1840 cd eb 0b			call update_display		 
1843			 
1843 cd 08 1b			call next_page_prompt 
1846			 
1846				; switch frame buffer to cli 
1846			 
1846 21 ab ed				ld hl, display_fb0 
1849 22 c6 eb				ld (display_fb_active), hl 
184c			 
184c			 
184c cd c8 0b		        call clear_display 
184f cd eb 0b			call update_display		 
1852			 
1852 21 e2 e5			ld hl, os_cli_cmd 
1855			 
1855 3e 00			ld a, 0		 ; init cli input 
1857 77				ld (hl), a 
1858			 
1858				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1858			 
1858				; now on last line 
1858			 
1858				; TODO scroll screen up 
1858			 
1858				; TODO instead just clear screen and place at top of screen 
1858			 
1858			;	ld a, 0 
1858			;	ld (f_cursor_ptr),a 
1858			 
1858				;call clear_display 
1858				;call update_display 
1858			 
1858				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1858 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
185a c3 02 18			jp cli 
185d			 
185d .. 00		freeram: db "Free bytes: ",0 
186a ..			asc: db "1A2F" 
186e .. 00		endprog: db "End prog...",0 
187a			 
187a			testenter2:   
187a 21 ed e2			ld hl,scratch+50 
187d 22 de e5			ld (os_cur_ptr),hl 
1880 c3 02 18			jp cli 
1883			 
1883			testenter:  
1883			 
1883 21 6a 18			ld hl,asc 
1886			;	ld a,(hl) 
1886			;	call nibble2val 
1886 cd 54 10			call get_byte 
1889			 
1889			 
1889			;	ld a,(hl) 
1889			;	call atohex 
1889			 
1889			;	call fourehexhl 
1889 32 ed e2			ld (scratch+50),a 
188c			 
188c			 
188c			 
188c 21 6c 18			ld hl,asc+2 
188f			;	ld a, (hl) 
188f			;	call nibble2val 
188f cd 54 10			call get_byte 
1892			 
1892			;	call fourehexhl 
1892 32 ef e2			ld (scratch+52),a 
1895				 
1895 21 ed e2			ld hl,scratch+50 
1898 22 de e5			ld (os_cur_ptr),hl 
189b c3 02 18			jp cli 
189e			 
189e			enter:	 
189e 3a bf e2			ld a,(scratch+4) 
18a1 fe 00			cp 0 
18a3 28 0c			jr z, .entercont 
18a5				; no, not a null term line so has an address to work out.... 
18a5			 
18a5 21 bd e2			ld hl,scratch+2 
18a8 cd b4 10			call get_word_hl 
18ab			 
18ab 22 de e5			ld (os_cur_ptr),hl	 
18ae c3 02 18			jp cli 
18b1			 
18b1			 
18b1			.entercont:  
18b1			 
18b1 21 bd e2			ld hl, scratch+2 
18b4 cd 54 10			call get_byte 
18b7			 
18b7 2a de e5		   	ld hl,(os_cur_ptr) 
18ba 77					ld (hl),a 
18bb 23					inc hl 
18bc 22 de e5				ld (os_cur_ptr),hl 
18bf				 
18bf			; get byte  
18bf			 
18bf			 
18bf c3 02 18			jp cli 
18c2			 
18c2			 
18c2			; basic monitor support 
18c2			 
18c2			monitor: 
18c2				;  
18c2 cd c8 0b			call clear_display 
18c5 3e 00			ld a, 0 
18c7 11 1b 19			ld de, .monprompt 
18ca cd db 0b			call str_at_display 
18cd cd eb 0b			call update_display 
18d0			 
18d0				; get a monitor command 
18d0			 
18d0 0e 00			ld c, 0     ; entry at top left 
18d2 16 64			ld d, 100   ; max buffer size 
18d4 1e 0f			ld e, 15    ; input scroll area 
18d6 3e 00			ld a, 0     ; init string 
18d8 21 b9 e4			ld hl, os_input 
18db 77				ld (hl), a 
18dc 23				inc hl 
18dd 77				ld (hl), a 
18de 21 b9 e4			ld hl, os_input 
18e1 3e 01			ld a, 1     ; init string 
18e3 cd 22 0e			call input_str 
18e6			 
18e6 cd c8 0b		        call clear_display 
18e9 cd eb 0b			call update_display		 
18ec			 
18ec 3a b9 e4			ld a, (os_input) 
18ef cd 52 11			call toUpper 
18f2 fe 48		        cp 'H' 
18f4 ca 8f 19		        jp z, .monhelp 
18f7 fe 44			cp 'D'		; dump 
18f9 ca c2 19			jp z, .mondump	 
18fc fe 43			cp 'C'		; dump 
18fe ca dc 19			jp z, .moncdump	 
1901 fe 4d			cp 'M'		; dump 
1903 ca 1d 19			jp z, .moneditstart 
1906 fe 55			cp 'U'		; dump 
1908 ca 29 19			jp z, .monedit	 
190b fe 47			cp 'G'		; dump 
190d ca b8 19			jp z, .monjump 
1910 fe 42			cp 'B'		; forth breakpoint 
1912 cc 11 15			call z, break_point_state 
1915 fe 51			cp 'Q'		; dump 
1917 c8				ret z	 
1918			 
1918			 
1918				; TODO "S" to access symbol by name and not need the address 
1918				; TODO "F" to find a string in memory 
1918			 
1918 c3 c2 18			jp monitor 
191b			 
191b .. 00		.monprompt: db ">", 0 
191d			 
191d			.moneditstart: 
191d				; get starting address 
191d			 
191d 21 bb e4			ld hl,os_input+2 
1920 cd b4 10			call get_word_hl 
1923			 
1923 22 de e5			ld (os_cur_ptr),hl	 
1926			 
1926 c3 c2 18			jp monitor 
1929			 
1929			.monedit: 
1929				; get byte to load 
1929			 
1929 21 bb e4			ld hl,os_input+2 
192c cd 54 10			call get_byte 
192f			 
192f				; get address to update 
192f 2a de e5			ld hl, (os_cur_ptr) 
1932			 
1932				; update byte 
1932			 
1932 77				ld (hl), a 
1933			 
1933				; move to next address and save it 
1933			 
1933 23				inc hl 
1934 22 de e5			ld (os_cur_ptr),hl	 
1937			 
1937 c3 c2 18			jp monitor 
193a			 
193a			 
193a .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
194e .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
196a .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
1988 .. 00		.monhelptext4:  db "Q-Quit",0 
198f			        
198f			.monhelp: 
198f 3e 00			ld a, display_row_1 
1991 11 3a 19		        ld de, .monhelptext1 
1994			 
1994 cd db 0b			call str_at_display 
1997 3e 28			ld a, display_row_2 
1999 11 4e 19		        ld de, .monhelptext2 
199c					 
199c cd db 0b			call str_at_display 
199f 3e 50			ld a, display_row_3 
19a1 11 6a 19		        ld de, .monhelptext3 
19a4					 
19a4 cd db 0b			call str_at_display 
19a7 3e 78			ld a, display_row_4 
19a9 11 88 19		        ld de, .monhelptext4 
19ac cd db 0b			call str_at_display 
19af			 
19af cd eb 0b			call update_display		 
19b2			 
19b2 cd 08 1b			call next_page_prompt 
19b5 c3 c2 18			jp monitor 
19b8			 
19b8			.monjump:    
19b8 21 bb e4			ld hl,os_input+2 
19bb cd b4 10			call get_word_hl 
19be			 
19be e9				jp (hl) 
19bf c3 c2 18			jp monitor 
19c2			 
19c2			.mondump:    
19c2 21 bb e4			ld hl,os_input+2 
19c5 cd b4 10			call get_word_hl 
19c8			 
19c8 22 de e5			ld (os_cur_ptr),hl	 
19cb cd 10 1a			call dumpcont 
19ce 3e 78			ld a, display_row_4 
19d0 11 6e 18			ld de, endprog 
19d3			 
19d3 cd eb 0b			call update_display		 
19d6			 
19d6 cd 08 1b			call next_page_prompt 
19d9 c3 c2 18			jp monitor 
19dc			.moncdump: 
19dc cd 10 1a			call dumpcont 
19df 3e 78			ld a, display_row_4 
19e1 11 6e 18			ld de, endprog 
19e4			 
19e4 cd eb 0b			call update_display		 
19e7			 
19e7 cd 08 1b			call next_page_prompt 
19ea c3 c2 18			jp monitor 
19ed			 
19ed			 
19ed			; TODO symbol access  
19ed			 
19ed			.symbols:     ;; A list of symbols that can be called up  
19ed ab ed			dw display_fb0 
19ef .. 00			db "fb0",0  
19f3 74 ea		     	dw store_page 
19f5 .. 00			db "store_page",0 
1a00			 
1a00			 
1a00			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1a00			 
1a00 3a bc e2			ld a,(scratch+1) 
1a03 fe 00			cp 0 
1a05 28 09			jr z, dumpcont 
1a07			 
1a07				; no, not a null term line so has an address to work out.... 
1a07			 
1a07 21 bd e2			ld hl,scratch+2 
1a0a cd b4 10			call get_word_hl 
1a0d			 
1a0d 22 de e5			ld (os_cur_ptr),hl	 
1a10			 
1a10			 
1a10			 
1a10			dumpcont: 
1a10			 
1a10				; dump bytes at ptr 
1a10			 
1a10			 
1a10 3e 00			ld a, display_row_1 
1a12 2a c6 eb			ld hl, (display_fb_active) 
1a15 cd f5 0d			call addatohl 
1a18 cd 40 1a			call .dumpbyterow 
1a1b			 
1a1b 3e 28			ld a, display_row_2 
1a1d 2a c6 eb			ld hl, (display_fb_active) 
1a20 cd f5 0d			call addatohl 
1a23 cd 40 1a			call .dumpbyterow 
1a26			 
1a26			 
1a26 3e 50			ld a, display_row_3 
1a28 2a c6 eb			ld hl, (display_fb_active) 
1a2b cd f5 0d			call addatohl 
1a2e cd 40 1a			call .dumpbyterow 
1a31			 
1a31 3e 78			ld a, display_row_4 
1a33 2a c6 eb			ld hl, (display_fb_active) 
1a36 cd f5 0d			call addatohl 
1a39 cd 40 1a			call .dumpbyterow 
1a3c			 
1a3c cd eb 0b			call update_display 
1a3f			;		jp cli 
1a3f c9				ret 
1a40			 
1a40			.dumpbyterow: 
1a40			 
1a40				;push af 
1a40			 
1a40 e5				push hl 
1a41			 
1a41				; calc where to poke the ascii 
1a41			if display_cols == 20 
1a41				ld a, 16 
1a41			else 
1a41 3e 1f			ld a, 31 
1a43			endif 
1a43			 
1a43 cd f5 0d			call addatohl 
1a46 22 c0 e5			ld (os_word_scratch),hl  		; save pos for later 
1a49			 
1a49			 
1a49			; display decoding address 
1a49 2a de e5		   	ld hl,(os_cur_ptr) 
1a4c			 
1a4c 7c				ld a,h 
1a4d e1				pop hl 
1a4e e5				push hl 
1a4f			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1a4f cd fe 0f			call hexout 
1a52 2a de e5		   	ld hl,(os_cur_ptr) 
1a55			 
1a55 7d				ld a,l 
1a56 e1				pop hl 
1a57 23				inc hl 
1a58 23				inc hl 
1a59 e5				push hl 
1a5a			;	ld hl, os_word_scratch+2 
1a5a cd fe 0f			call hexout 
1a5d e1				pop hl 
1a5e 23				inc hl 
1a5f 23				inc hl 
1a60				;ld hl, os_word_scratch+4 
1a60 3e 3a			ld a, ':' 
1a62 77				ld (hl),a 
1a63 23				inc hl 
1a64				;ld a, 0 
1a64				;ld (hl),a 
1a64				;ld de, os_word_scratch 
1a64				;pop af 
1a64				;push af 
1a64			;		ld a, display_row_2 
1a64			;		call str_at_display 
1a64			;		call update_display 
1a64			 
1a64			 
1a64			;pop af 
1a64			;	add 5 
1a64			 
1a64			if display_cols == 20 
1a64				ld b, 4 
1a64			else 
1a64 06 08			ld b, 8 
1a66			endif	 
1a66			 
1a66			.dumpbyte: 
1a66 c5				push bc 
1a67 e5				push hl 
1a68			 
1a68			 
1a68 2a de e5		   	ld hl,(os_cur_ptr) 
1a6b 7e					ld a,(hl) 
1a6c			 
1a6c					; poke the ascii to display 
1a6c 2a c0 e5				ld hl,(os_word_scratch) 
1a6f 77					ld (hl),a 
1a70 23					inc hl 
1a71 22 c0 e5				ld (os_word_scratch),hl 
1a74			 
1a74					 
1a74			 
1a74			 
1a74 e1					pop hl 
1a75 e5					push hl 
1a76			 
1a76 cd fe 0f				call hexout 
1a79			 
1a79					 
1a79 2a de e5		   	ld hl,(os_cur_ptr) 
1a7c 23				inc hl 
1a7d 22 de e5		   	ld (os_cur_ptr),hl 
1a80			 
1a80 e1					pop hl 
1a81 23					inc hl 
1a82 23					inc hl 
1a83 23					inc hl 
1a84			 
1a84			 
1a84			 
1a84					;ld a,0 
1a84					;ld (os_word_scratch+2),a 
1a84					;pop af 
1a84					;push af 
1a84			 
1a84					;ld de, os_word_scratch 
1a84					;call str_at_display 
1a84			;		call update_display 
1a84			;		pop af 
1a84 c1					pop bc 
1a85 c6 03				add 3 
1a87 10 dd			djnz .dumpbyte 
1a89			 
1a89				 
1a89			 
1a89 c9				ret 
1a8a			 
1a8a			jump:	 
1a8a			 
1a8a 21 bd e2			ld hl,scratch+2 
1a8d cd b4 10			call get_word_hl 
1a90				;ld hl,(scratch+2) 
1a90				;call fourehexhl 
1a90			 
1a90 22 de e5			ld (os_cur_ptr),hl	 
1a93			 
1a93 e9				jp (hl) 
1a94			 
1a94			 
1a94			 
1a94			; TODO implement a basic monitor mode to start with 
1a94			 
1a94			 
1a94			 
1a94			 
1a94			 
1a94			 
1a94			 
1a94			 
1a94			 
1a94			; testing and demo code during development 
1a94			 
1a94			 
1a94 .. 00		str1: db "Enter some text...",0 
1aa7 .. 00		clear: db "                    ",0 
1abc			 
1abc			demo: 
1abc			 
1abc			 
1abc			 
1abc			;	call update_display 
1abc			 
1abc				; init scratch input area for testing 
1abc 21 bb e2			ld hl, scratch	 
1abf 3e 00			ld a,0 
1ac1 77				ld (hl),a 
1ac2			 
1ac2			 
1ac2 3e 28		            LD   A, display_row_2 
1ac4			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ac4 11 94 1a		            LD   DE, str1 
1ac7 cd db 0b			call str_at_display 
1aca			 
1aca			;            CALL fLCD_Str       ;Display string pointed to by DE 
1aca			cloop:	 
1aca 3e 50		            LD   A, display_row_3 
1acc			;            CALL fLCD_Pos       ;Position cursor to location in A 
1acc 11 a7 1a		            LD   DE, clear 
1acf			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1acf cd db 0b				call str_at_display 
1ad2 3e 78			ld a, display_row_4 
1ad4 11 04 1b			ld de, prompt 
1ad7			 
1ad7 cd db 0b				call str_at_display 
1ada cd eb 0b			call update_display 
1add			 
1add 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1adf 16 0a			ld d, 10 
1ae1 21 bb e2			ld hl, scratch	 
1ae4 cd 22 0e			call input_str 
1ae7			 
1ae7			;	call clear_display 
1ae7			;'	call update_display 
1ae7			 
1ae7 3e 00		            LD   A, display_row_1 
1ae9			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ae9 11 a7 1a		            LD   DE, clear 
1aec cd db 0b				call str_at_display 
1aef			;            CALL fLCD_Str       ;Display string pointed to by DE 
1aef 3e 00		            LD   A, display_row_1 
1af1			;            CALL fLCD_Pos       ;Position cursor to location in A 
1af1 11 bb e2		            LD   DE, scratch 
1af4			;            CALL fLCD_Str       ;Display string pointed to by DE 
1af4 cd db 0b				call str_at_display 
1af7 cd eb 0b			call update_display 
1afa			 
1afa 3e 00				ld a,0 
1afc 21 bb e2			ld hl, scratch 
1aff 77				ld (hl),a 
1b00			 
1b00 00				nop 
1b01 c3 ca 1a			jp cloop 
1b04			 
1b04			 
1b04			 
1b04			; OS Prompt 
1b04			 
1b04 .. 00		prompt: db ">",0 
1b06 .. 00		endprg: db "?",0 
1b08			 
1b08			 
1b08			; handy next page prompt 
1b08			next_page_prompt: 
1b08 e5				push hl 
1b09 d5				push de 
1b0a f5				push af 
1b0b c5				push bc 
1b0c			 
1b0c 3e 9f			ld a,display_row_4 + display_cols - 1 
1b0e 11 06 1b		        ld de, endprg 
1b11 cd db 0b			call str_at_display 
1b14 cd eb 0b			call update_display 
1b17 cd f1 5e			call cin_wait 
1b1a c1				pop bc 
1b1b f1				pop af 
1b1c d1				pop de 
1b1d e1				pop hl 
1b1e			 
1b1e			 
1b1e c9				ret 
1b1f			 
1b1f			 
1b1f			; forth parser 
1b1f			 
1b1f			; My forth kernel 
1b1f			include "forth_kernel.asm" 
1b1f			; 
1b1f			; kernel to the forth OS 
1b1f			 
1b1f			DS_TYPE_STR: equ 1     ; string type 
1b1f			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1b1f			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1b1f			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1b1f			 
1b1f			FORTH_PARSEV1: equ 0 
1b1f			FORTH_PARSEV2: equ 0 
1b1f			FORTH_PARSEV3: equ 0 
1b1f			FORTH_PARSEV4: equ 0 
1b1f			FORTH_PARSEV5: equ 1 
1b1f			 
1b1f			;if FORTH_PARSEV5 
1b1f			;	FORTH_END_BUFFER: equ 0 
1b1f			;else 
1b1f			FORTH_END_BUFFER: equ 127 
1b1f			;endif 
1b1f			 
1b1f			FORTH_TRUE: equ 1 
1b1f			FORTH_FALSE: equ 0 
1b1f			 
1b1f			if FORTH_PARSEV4 
1b1f			include "forth_stackops.asm" 
1b1f			endif 
1b1f			 
1b1f			if FORTH_PARSEV5 
1b1f			include "forth_stackopsv5.asm" 
1b1f			 
1b1f			; Stack operations for v5 parser on wards 
1b1f			; * DATA stack 
1b1f			; * LOOP stack 
1b1f			; * RETURN stack 
1b1f			 
1b1f			 
1b1f			 
1b1f			FORTH_CHK_DSP_UNDER: macro 
1b1f				push hl 
1b1f				push de 
1b1f				ld hl,(cli_data_sp) 
1b1f				ld de, cli_data_stack 
1b1f				call cmp16 
1b1f				jp c, fault_dsp_under 
1b1f				pop de 
1b1f				pop hl 
1b1f				endm 
1b1f			 
1b1f			 
1b1f			FORTH_CHK_RSP_UNDER: macro 
1b1f				push hl 
1b1f				push de 
1b1f				ld hl,(cli_ret_sp) 
1b1f				ld de, cli_ret_stack 
1b1f				call cmp16 
1b1f				jp c, fault_rsp_under 
1b1f				pop de 
1b1f				pop hl 
1b1f				endm 
1b1f			 
1b1f			FORTH_CHK_LOOP_UNDER: macro 
1b1f				push hl 
1b1f				push de 
1b1f				ld hl,(cli_loop_sp) 
1b1f				ld de, cli_loop_stack 
1b1f				call cmp16 
1b1f				jp c, fault_loop_under 
1b1f				pop de 
1b1f				pop hl 
1b1f				endm 
1b1f			 
1b1f			FORTH_ERR_TOS_NOTSTR: macro 
1b1f				; TOSO might need more for checks when used 
1b1f				push af 
1b1f				ld a,(hl) 
1b1f				cp DS_TYPE_STR 
1b1f				jp nz, type_faultn   
1b1f				pop af 
1b1f				endm 
1b1f			 
1b1f			FORTH_ERR_TOS_NOTNUM: macro 
1b1f				push af 
1b1f				ld a,(hl) 
1b1f				cp DS_TYPE_INUM 
1b1f				jp nz, type_faultn   
1b1f				pop af 
1b1f				endm 
1b1f			 
1b1f			 
1b1f			; increase data stack pointer and save hl to it 
1b1f				 
1b1f			FORTH_DSP_NEXT: macro 
1b1f				call macro_forth_dsp_next 
1b1f				endm 
1b1f			 
1b1f			 
1b1f			macro_forth_dsp_next: 
1b1f				if DEBUG_FORTH_STACK_GUARD 
1b1f cd 17 5b				call check_stacks 
1b22				endif 
1b22 e5				push hl 
1b23 d5				push de 
1b24 eb				ex de,hl 
1b25 2a e8 e9			ld hl,(cli_data_sp) 
1b28 23				inc hl 
1b29 23				inc hl 
1b2a			 
1b2a			; PARSEV5 
1b2a 23				inc hl 
1b2b 22 e8 e9			ld (cli_data_sp),hl 
1b2e 73				ld (hl), e 
1b2f 23				inc hl 
1b30 72				ld (hl), d 
1b31 d1				pop de 
1b32 e1				pop hl 
1b33				if DEBUG_FORTH_STACK_GUARD 
1b33 cd 17 5b				call check_stacks 
1b36				endif 
1b36 c9				ret 
1b37			 
1b37			 
1b37			; increase ret stack pointer and save hl to it 
1b37				 
1b37			FORTH_RSP_NEXT: macro 
1b37				call macro_forth_rsp_next 
1b37				endm 
1b37			 
1b37			macro_forth_rsp_next: 
1b37				if DEBUG_FORTH_STACK_GUARD 
1b37 cd 17 5b				call check_stacks 
1b3a				endif 
1b3a e5				push hl 
1b3b d5				push de 
1b3c eb				ex de,hl 
1b3d 2a ec e9			ld hl,(cli_ret_sp) 
1b40 23				inc hl 
1b41 23				inc hl 
1b42 22 ec e9			ld (cli_ret_sp),hl 
1b45 73				ld (hl), e 
1b46 23				inc hl 
1b47 72				ld (hl), d 
1b48 d1				pop de 
1b49 e1				pop hl 
1b4a				if DEBUG_FORTH_STACK_GUARD 
1b4a cd 17 5b				call check_stacks 
1b4d				endif 
1b4d c9				ret 
1b4e			 
1b4e			; get current ret stack pointer and save to hl  
1b4e				 
1b4e			FORTH_RSP_TOS: macro 
1b4e				call macro_forth_rsp_tos 
1b4e				endm 
1b4e			 
1b4e			macro_forth_rsp_tos: 
1b4e				;push de 
1b4e 2a ec e9			ld hl,(cli_ret_sp) 
1b51 cd 89 1b			call loadhlptrtohl 
1b54				;ld e, (hl) 
1b54				;inc hl 
1b54				;ld d, (hl) 
1b54				;ex de, hl 
1b54					if DEBUG_FORTH_WORDS 
1b54			;			DMARK "RST" 
1b54						CALLMONITOR 
1b54 cd 6f ee			call debug_vector  
1b57				endm  
# End of macro CALLMONITOR
1b57					endif 
1b57				;pop de 
1b57 c9				ret 
1b58			 
1b58			; pop ret stack pointer 
1b58				 
1b58			FORTH_RSP_POP: macro 
1b58				call macro_forth_rsp_pop 
1b58				endm 
1b58			 
1b58			 
1b58			macro_forth_rsp_pop: 
1b58				if DEBUG_FORTH_STACK_GUARD 
1b58			;		DMARK "RPP" 
1b58 cd 17 5b				call check_stacks 
1b5b					FORTH_CHK_RSP_UNDER 
1b5b e5				push hl 
1b5c d5				push de 
1b5d 2a ec e9			ld hl,(cli_ret_sp) 
1b60 11 a6 e9			ld de, cli_ret_stack 
1b63 cd 13 0e			call cmp16 
1b66 da 2e 5c			jp c, fault_rsp_under 
1b69 d1				pop de 
1b6a e1				pop hl 
1b6b				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b6b				endif 
1b6b e5				push hl 
1b6c 2a ec e9			ld hl,(cli_ret_sp) 
1b6f			 
1b6f			 
1b6f				if FORTH_ENABLE_FREE 
1b6f			 
1b6f					; get pointer 
1b6f			 
1b6f					push de 
1b6f					push hl 
1b6f			 
1b6f					ld e, (hl) 
1b6f					inc hl 
1b6f					ld d, (hl) 
1b6f			 
1b6f					ex de, hl 
1b6f					call free 
1b6f			 
1b6f					pop hl 
1b6f					pop de 
1b6f			 
1b6f			 
1b6f				endif 
1b6f			 
1b6f			 
1b6f 2b				dec hl 
1b70 2b				dec hl 
1b71 22 ec e9			ld (cli_ret_sp), hl 
1b74				; do stack underflow checks 
1b74 e1				pop hl 
1b75				if DEBUG_FORTH_STACK_GUARD 
1b75 cd 17 5b				call check_stacks 
1b78					FORTH_CHK_RSP_UNDER 
1b78 e5				push hl 
1b79 d5				push de 
1b7a 2a ec e9			ld hl,(cli_ret_sp) 
1b7d 11 a6 e9			ld de, cli_ret_stack 
1b80 cd 13 0e			call cmp16 
1b83 da 2e 5c			jp c, fault_rsp_under 
1b86 d1				pop de 
1b87 e1				pop hl 
1b88				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b88				endif 
1b88 c9				ret 
1b89			 
1b89			 
1b89			 
1b89			; routine to load word pointed to by hl into hl 
1b89			 
1b89			loadhlptrtohl: 
1b89			 
1b89 d5				push de 
1b8a 5e				ld e, (hl) 
1b8b 23				inc hl 
1b8c 56				ld d, (hl) 
1b8d eb				ex de, hl 
1b8e d1				pop de 
1b8f			 
1b8f c9				ret 
1b90			 
1b90			 
1b90			 
1b90			 
1b90			 
1b90			; push a number held in HL onto the data stack 
1b90			; entry point for pushing a value when already in hl used in function above 
1b90			 
1b90			forth_push_numhl: 
1b90			 
1b90 e5				push hl    ; save value to push 
1b91			 
1b91			if DEBUG_FORTH_PUSH 
1b91				; see if disabled 
1b91			 
1b91			 
1b91 f5				push af 
1b92 3a 6f ee			ld a,(debug_vector) 
1b95 fe c9			cp $c9   ; ret 
1b97			;	ld a, (os_view_disable) 
1b97			;	cp '*' 
1b97 28 34			jr z, .pskip2 
1b99 e5				push hl 
1b9a e5			push hl 
1b9b cd c8 0b			call clear_display 
1b9e e1			pop hl 
1b9f 7c				ld a,h 
1ba0 21 c0 e5			ld hl, os_word_scratch 
1ba3 cd fe 0f			call hexout 
1ba6 e1				pop hl 
1ba7 7d				ld a,l 
1ba8 21 c2 e5			ld hl, os_word_scratch+2 
1bab cd fe 0f			call hexout 
1bae			 
1bae 21 c4 e5			ld hl, os_word_scratch+4 
1bb1 3e 00			ld a,0 
1bb3 77				ld (hl),a 
1bb4 11 c0 e5			ld de,os_word_scratch 
1bb7 3e 28				ld a, display_row_2 
1bb9 cd db 0b				call str_at_display 
1bbc 11 25 4d			ld de, .push_num 
1bbf 3e 00			ld a, display_row_1 
1bc1			 
1bc1 cd db 0b				call str_at_display 
1bc4			 
1bc4			 
1bc4 cd eb 0b			call update_display 
1bc7 cd 00 0b			call delay1s 
1bca cd 00 0b			call delay1s 
1bcd			.pskip2:  
1bcd			 
1bcd f1				pop af 
1bce			endif	 
1bce			 
1bce			 
1bce				FORTH_DSP_NEXT 
1bce cd 1f 1b			call macro_forth_dsp_next 
1bd1				endm 
# End of macro FORTH_DSP_NEXT
1bd1			 
1bd1 2a e8 e9			ld hl, (cli_data_sp) 
1bd4			 
1bd4				; save item type 
1bd4 3e 02			ld a,  DS_TYPE_INUM 
1bd6 77				ld (hl), a 
1bd7 23				inc hl 
1bd8			 
1bd8				; get word off stack 
1bd8 d1				pop de 
1bd9 7b				ld a,e 
1bda 77				ld (hl), a 
1bdb 23				inc hl 
1bdc 7a				ld a,d 
1bdd 77				ld (hl), a 
1bde			 
1bde			if DEBUG_FORTH_PUSH 
1bde 2b				dec hl 
1bdf 2b				dec hl 
1be0 2b				dec hl 
1be1						DMARK "PH5" 
1be1 f5				push af  
1be2 3a f6 1b			ld a, (.dmark)  
1be5 32 65 ee			ld (debug_mark),a  
1be8 3a f7 1b			ld a, (.dmark+1)  
1beb 32 66 ee			ld (debug_mark+1),a  
1bee 3a f8 1b			ld a, (.dmark+2)  
1bf1 32 67 ee			ld (debug_mark+2),a  
1bf4 18 03			jr .pastdmark  
1bf6 ..			.dmark: db "PH5"  
1bf9 f1			.pastdmark: pop af  
1bfa			endm  
# End of macro DMARK
1bfa				CALLMONITOR 
1bfa cd 6f ee			call debug_vector  
1bfd				endm  
# End of macro CALLMONITOR
1bfd			endif	 
1bfd			 
1bfd c9				ret 
1bfe			 
1bfe			 
1bfe			; Push a string to stack pointed to by hl 
1bfe			 
1bfe			forth_push_str: 
1bfe			 
1bfe			if DEBUG_FORTH_PUSH 
1bfe						DMARK "PSQ" 
1bfe f5				push af  
1bff 3a 13 1c			ld a, (.dmark)  
1c02 32 65 ee			ld (debug_mark),a  
1c05 3a 14 1c			ld a, (.dmark+1)  
1c08 32 66 ee			ld (debug_mark+1),a  
1c0b 3a 15 1c			ld a, (.dmark+2)  
1c0e 32 67 ee			ld (debug_mark+2),a  
1c11 18 03			jr .pastdmark  
1c13 ..			.dmark: db "PSQ"  
1c16 f1			.pastdmark: pop af  
1c17			endm  
# End of macro DMARK
1c17				CALLMONITOR 
1c17 cd 6f ee			call debug_vector  
1c1a				endm  
# End of macro CALLMONITOR
1c1a			endif	 
1c1a			 
1c1a			 
1c1a			    
1c1a e5				push hl 
1c1b e5				push hl 
1c1c			 
1c1c			;	ld a, 0   ; find end of string 
1c1c cd 5b 11			call strlenz 
1c1f			if DEBUG_FORTH_PUSH 
1c1f						DMARK "PQ2" 
1c1f f5				push af  
1c20 3a 34 1c			ld a, (.dmark)  
1c23 32 65 ee			ld (debug_mark),a  
1c26 3a 35 1c			ld a, (.dmark+1)  
1c29 32 66 ee			ld (debug_mark+1),a  
1c2c 3a 36 1c			ld a, (.dmark+2)  
1c2f 32 67 ee			ld (debug_mark+2),a  
1c32 18 03			jr .pastdmark  
1c34 ..			.dmark: db "PQ2"  
1c37 f1			.pastdmark: pop af  
1c38			endm  
# End of macro DMARK
1c38				CALLMONITOR 
1c38 cd 6f ee			call debug_vector  
1c3b				endm  
# End of macro CALLMONITOR
1c3b			endif	 
1c3b eb				ex de, hl 
1c3c e1				pop hl   ; get ptr to start of string 
1c3d			if DEBUG_FORTH_PUSH 
1c3d						DMARK "PQ3" 
1c3d f5				push af  
1c3e 3a 52 1c			ld a, (.dmark)  
1c41 32 65 ee			ld (debug_mark),a  
1c44 3a 53 1c			ld a, (.dmark+1)  
1c47 32 66 ee			ld (debug_mark+1),a  
1c4a 3a 54 1c			ld a, (.dmark+2)  
1c4d 32 67 ee			ld (debug_mark+2),a  
1c50 18 03			jr .pastdmark  
1c52 ..			.dmark: db "PQ3"  
1c55 f1			.pastdmark: pop af  
1c56			endm  
# End of macro DMARK
1c56				CALLMONITOR 
1c56 cd 6f ee			call debug_vector  
1c59				endm  
# End of macro CALLMONITOR
1c59			endif	 
1c59 19				add hl,de 
1c5a			if DEBUG_FORTH_PUSH 
1c5a						DMARK "PQE" 
1c5a f5				push af  
1c5b 3a 6f 1c			ld a, (.dmark)  
1c5e 32 65 ee			ld (debug_mark),a  
1c61 3a 70 1c			ld a, (.dmark+1)  
1c64 32 66 ee			ld (debug_mark+1),a  
1c67 3a 71 1c			ld a, (.dmark+2)  
1c6a 32 67 ee			ld (debug_mark+2),a  
1c6d 18 03			jr .pastdmark  
1c6f ..			.dmark: db "PQE"  
1c72 f1			.pastdmark: pop af  
1c73			endm  
# End of macro DMARK
1c73				CALLMONITOR 
1c73 cd 6f ee			call debug_vector  
1c76				endm  
# End of macro CALLMONITOR
1c76			endif	 
1c76			 
1c76 2b				dec hl    ; see if there is an optional trailing double quote 
1c77 7e				ld a,(hl) 
1c78 fe 22			cp '"' 
1c7a 20 03			jr nz, .strnoq 
1c7c 3e 00			ld a, 0      ; get rid of double quote 
1c7e 77				ld (hl), a 
1c7f 23			.strnoq: inc hl 
1c80			 
1c80 3e 00			ld a, 0 
1c82 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1c83			 
1c83 13				inc de ; add one for the type string 
1c84 13				inc de ; add one for null term??? 
1c85			 
1c85				; tos is get string pointer again 
1c85				; de contains space to allocate 
1c85				 
1c85 d5				push de 
1c86			 
1c86 eb				ex de, hl 
1c87			 
1c87				;push af 
1c87			 
1c87			if DEBUG_FORTH_PUSH 
1c87						DMARK "PHm" 
1c87 f5				push af  
1c88 3a 9c 1c			ld a, (.dmark)  
1c8b 32 65 ee			ld (debug_mark),a  
1c8e 3a 9d 1c			ld a, (.dmark+1)  
1c91 32 66 ee			ld (debug_mark+1),a  
1c94 3a 9e 1c			ld a, (.dmark+2)  
1c97 32 67 ee			ld (debug_mark+2),a  
1c9a 18 03			jr .pastdmark  
1c9c ..			.dmark: db "PHm"  
1c9f f1			.pastdmark: pop af  
1ca0			endm  
# End of macro DMARK
1ca0				CALLMONITOR 
1ca0 cd 6f ee			call debug_vector  
1ca3				endm  
# End of macro CALLMONITOR
1ca3			endif	 
1ca3 cd d0 11			call malloc	; on ret hl now contains allocated memory 
1ca6				if DEBUG_FORTH_MALLOC_GUARD 
1ca6 cc 7d 4d				call z,malloc_error 
1ca9				endif 
1ca9			 
1ca9				 
1ca9 c1				pop bc    ; get length 
1caa d1				pop de   ;  get string start    
1cab			 
1cab				; hl has destination from malloc 
1cab			 
1cab eb				ex de, hl    ; prep for ldir 
1cac			 
1cac d5				push de   ; save malloc area for DSP later 
1cad				;push hl   ; save malloc area for DSP later 
1cad			 
1cad			if DEBUG_FORTH_PUSH 
1cad						DMARK "PHc" 
1cad f5				push af  
1cae 3a c2 1c			ld a, (.dmark)  
1cb1 32 65 ee			ld (debug_mark),a  
1cb4 3a c3 1c			ld a, (.dmark+1)  
1cb7 32 66 ee			ld (debug_mark+1),a  
1cba 3a c4 1c			ld a, (.dmark+2)  
1cbd 32 67 ee			ld (debug_mark+2),a  
1cc0 18 03			jr .pastdmark  
1cc2 ..			.dmark: db "PHc"  
1cc5 f1			.pastdmark: pop af  
1cc6			endm  
# End of macro DMARK
1cc6				CALLMONITOR 
1cc6 cd 6f ee			call debug_vector  
1cc9				endm  
# End of macro CALLMONITOR
1cc9			endif	 
1cc9			 
1cc9			 
1cc9 ed b0			ldir 
1ccb			 
1ccb			 
1ccb				; push malloc to data stack     macro?????  
1ccb			 
1ccb				FORTH_DSP_NEXT 
1ccb cd 1f 1b			call macro_forth_dsp_next 
1cce				endm 
# End of macro FORTH_DSP_NEXT
1cce			 
1cce				; save value and type 
1cce			 
1cce 2a e8 e9			ld hl, (cli_data_sp) 
1cd1			 
1cd1				; save item type 
1cd1 3e 01			ld a,  DS_TYPE_STR 
1cd3 77				ld (hl), a 
1cd4 23				inc hl 
1cd5			 
1cd5				; get malloc word off stack 
1cd5 d1				pop de 
1cd6 73				ld (hl), e 
1cd7 23				inc hl 
1cd8 72				ld (hl), d 
1cd9			 
1cd9			 
1cd9			 
1cd9			if DEBUG_FORTH_PUSH 
1cd9 2a e8 e9			ld hl, (cli_data_sp) 
1cdc						DMARK "PHS" 
1cdc f5				push af  
1cdd 3a f1 1c			ld a, (.dmark)  
1ce0 32 65 ee			ld (debug_mark),a  
1ce3 3a f2 1c			ld a, (.dmark+1)  
1ce6 32 66 ee			ld (debug_mark+1),a  
1ce9 3a f3 1c			ld a, (.dmark+2)  
1cec 32 67 ee			ld (debug_mark+2),a  
1cef 18 03			jr .pastdmark  
1cf1 ..			.dmark: db "PHS"  
1cf4 f1			.pastdmark: pop af  
1cf5			endm  
# End of macro DMARK
1cf5				CALLMONITOR 
1cf5 cd 6f ee			call debug_vector  
1cf8				endm  
# End of macro CALLMONITOR
1cf8			;	ex de,hl 
1cf8			endif	 
1cf8				; in case of spaces, skip the ptr past the copied string 
1cf8				;pop af 
1cf8				;ld (cli_origptr),hl 
1cf8			 
1cf8 c9				ret 
1cf9			 
1cf9			 
1cf9			 
1cf9			; TODO ascii push input onto stack given hl to start of input 
1cf9			 
1cf9			; identify type 
1cf9			; if starts with a " then a string 
1cf9			; otherwise it is a number 
1cf9			;  
1cf9			; if a string 
1cf9			;     scan for ending " to get length of string to malloc for + 1 
1cf9			;     malloc 
1cf9			;     put pointer to string on stack first byte flags as string 
1cf9			; 
1cf9			; else a number 
1cf9			;    look for number format identifier 
1cf9			;    $xx hex 
1cf9			;    %xxxxx bin 
1cf9			;    xxxxx decimal 
1cf9			;    convert number to 16bit word.  
1cf9			;    malloc word + 1 with flag to identiy as num 
1cf9			;    put pointer to number on stack 
1cf9			;   
1cf9			;  
1cf9			  
1cf9			forth_apush: 
1cf9				; kernel push 
1cf9			 
1cf9			if DEBUG_FORTH_PUSH 
1cf9						DMARK "PSH" 
1cf9 f5				push af  
1cfa 3a 0e 1d			ld a, (.dmark)  
1cfd 32 65 ee			ld (debug_mark),a  
1d00 3a 0f 1d			ld a, (.dmark+1)  
1d03 32 66 ee			ld (debug_mark+1),a  
1d06 3a 10 1d			ld a, (.dmark+2)  
1d09 32 67 ee			ld (debug_mark+2),a  
1d0c 18 03			jr .pastdmark  
1d0e ..			.dmark: db "PSH"  
1d11 f1			.pastdmark: pop af  
1d12			endm  
# End of macro DMARK
1d12				CALLMONITOR 
1d12 cd 6f ee			call debug_vector  
1d15				endm  
# End of macro CALLMONITOR
1d15			endif	 
1d15				; identify input type 
1d15			 
1d15 7e				ld a,(hl) 
1d16			 
1d16 fe 23			cp '#' 
1d18 ca 52 1d			jp z, .fapdec 
1d1b			 
1d1b			 
1d1b fe 22			cp '"' 
1d1d 28 0a			jr z, .fapstr 
1d1f fe 24			cp '$' 
1d21 ca 49 1d			jp z, .faphex 
1d24 fe 25			cp '%' 
1d26 ca 31 1d			jp z, .fapbin 
1d29			;	cp 'b' 
1d29			;	jp z, .fabin 
1d29				; else decimal 
1d29			 
1d29				; TODO do decimal conversion 
1d29				; decimal is stored as a 16bit word 
1d29			 
1d29				; by default everything is a string if type is not detected 
1d29			.fapstr: ; 
1d29 fe 22			cp '"' 
1d2b 20 01			jr nz, .strnoqu 
1d2d 23				inc hl 
1d2e			.strnoqu: 
1d2e c3 fe 1b			jp forth_push_str 
1d31			 
1d31			 
1d31			 
1d31			.fapbin:    ; push a binary string.  
1d31 11 00 00			ld de, 0   ; hold a 16bit value 
1d34			 
1d34 23			.fapbinshift:	inc hl  
1d35 7e				ld a,(hl) 
1d36 fe 00			cp 0     ; done scanning  
1d38 28 0b			jr z, .fapbdone  	; got it in HL so push  
1d3a			 
1d3a				; left shift de 
1d3a eb				ex de, hl	 
1d3b 29				add hl, hl 
1d3c			 
1d3c				; is 1 
1d3c fe 31			cp '1' 
1d3e 20 02			jr nz, .binzero 
1d40 cb 4d			bit 1, l 
1d42			.binzero: 
1d42 eb				ex de, hl	 ; save current de 
1d43 18 ef			jr .fapbinshift 
1d45			 
1d45			.fapbdone: 
1d45 eb				ex de, hl 
1d46 c3 90 1b			jp forth_push_numhl 
1d49			 
1d49			 
1d49			.faphex:   ; hex is always stored as a 16bit word 
1d49				; skip number prefix 
1d49 23				inc hl 
1d4a				; turn ascii into number 
1d4a cd b4 10			call get_word_hl	; ret 16bit word in hl 
1d4d			 
1d4d c3 90 1b			jp forth_push_numhl 
1d50			 
1d50 00				 nop 
1d51			 
1d51			.fabin:   ; TODO bin conversion 
1d51			 
1d51			 
1d51 c9				ret 
1d52			.fapdec:	 
1d52				; string to dec conversion 
1d52 23				inc hl 
1d53 eb				ex de, hl 
1d54 cd f2 10			call string_to_uint16 
1d57 c3 90 1b			jp forth_push_numhl 
1d5a c9				ret 
1d5b				 
1d5b			;atoui_16: 
1d5b			 
1d5b			; get either a string ptr or a 16bit word from the data stack 
1d5b			 
1d5b			FORTH_DSP: macro 
1d5b				call macro_forth_dsp 
1d5b				endm 
1d5b			 
1d5b			macro_forth_dsp: 
1d5b				; data stack pointer points to current word on tos 
1d5b			 
1d5b 2a e8 e9			ld hl,(cli_data_sp) 
1d5e			 
1d5e				if DEBUG_FORTH_PUSH 
1d5e						DMARK "DSP" 
1d5e f5				push af  
1d5f 3a 73 1d			ld a, (.dmark)  
1d62 32 65 ee			ld (debug_mark),a  
1d65 3a 74 1d			ld a, (.dmark+1)  
1d68 32 66 ee			ld (debug_mark+1),a  
1d6b 3a 75 1d			ld a, (.dmark+2)  
1d6e 32 67 ee			ld (debug_mark+2),a  
1d71 18 03			jr .pastdmark  
1d73 ..			.dmark: db "DSP"  
1d76 f1			.pastdmark: pop af  
1d77			endm  
# End of macro DMARK
1d77			 
1d77 cd b0 4d				call display_data_sp 
1d7a				;call break_point_state 
1d7a				;rst 030h 
1d7a				CALLMONITOR 
1d7a cd 6f ee			call debug_vector  
1d7d				endm  
# End of macro CALLMONITOR
1d7d				endif 
1d7d			 
1d7d c9				ret 
1d7e			 
1d7e			; return hl to start of value on stack 
1d7e			 
1d7e			FORTH_DSP_VALUE: macro 
1d7e				call macro_forth_dsp_value 
1d7e				endm 
1d7e			 
1d7e			macro_forth_dsp_value: 
1d7e			 
1d7e				FORTH_DSP 
1d7e cd 5b 1d			call macro_forth_dsp 
1d81				endm 
# End of macro FORTH_DSP
1d81			 
1d81 d5				push de 
1d82			 
1d82 23				inc hl ; skip type 
1d83			 
1d83 5e				ld e, (hl) 
1d84 23				inc hl 
1d85 56				ld d, (hl) 
1d86 eb				ex de,hl  
1d87			 
1d87 d1				pop de 
1d88			 
1d88 c9				ret 
1d89			 
1d89			; return hl to start of value to second item on stack 
1d89			 
1d89			FORTH_DSP_VALUEM1: macro 
1d89				call macro_forth_dsp_value_m1 
1d89				endm 
1d89			 
1d89			macro_forth_dsp_value_m1: 
1d89			 
1d89				FORTH_DSP 
1d89 cd 5b 1d			call macro_forth_dsp 
1d8c				endm 
# End of macro FORTH_DSP
1d8c			 
1d8c 2b				dec hl 
1d8d 2b				dec hl 
1d8e			;	dec hl 
1d8e			 
1d8e d5				push de 
1d8f			 
1d8f 5e				ld e, (hl) 
1d90 23				inc hl 
1d91 56				ld d, (hl) 
1d92 eb				ex de,hl  
1d93			 
1d93 d1				pop de 
1d94			 
1d94 c9				ret 
1d95			 
1d95				 
1d95			 
1d95			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1d95			 
1d95			FORTH_DSP_POP: macro 
1d95				call macro_forth_dsp_pop 
1d95				endm 
1d95			 
1d95			 
1d95			; get the tos data type 
1d95			 
1d95			FORTH_DSP_TYPE:   macro 
1d95			 
1d95				;FORTH_DSP_VALUE 
1d95				FORTH_DSP 
1d95				 
1d95				; hl points to value 
1d95				; check type 
1d95			 
1d95				ld a,(hl) 
1d95			 
1d95				endm 
1d95			 
1d95			; load the tos value into hl 
1d95			 
1d95			 
1d95			FORTH_DSP_VALUEHL:  macro 
1d95				call macro_dsp_valuehl 
1d95				endm 
1d95			 
1d95			 
1d95			 
1d95			macro_dsp_valuehl: 
1d95				FORTH_DSP_VALUE 
1d95 cd 7e 1d			call macro_forth_dsp_value 
1d98				endm 
# End of macro FORTH_DSP_VALUE
1d98			 
1d98				;FORTH_ERR_TOS_NOTNUM 
1d98			 
1d98				;inc hl   ; skip type id 
1d98			 
1d98			;	push de 
1d98			; 
1d98			;	ld e, (hl) 
1d98			;	inc hl 
1d98			;	ld d, (hl) 
1d98			;	ex de,hl  
1d98			 
1d98			;	pop de 
1d98			 
1d98				if DEBUG_FORTH_PUSH 
1d98						DMARK "DVL" 
1d98 f5				push af  
1d99 3a ad 1d			ld a, (.dmark)  
1d9c 32 65 ee			ld (debug_mark),a  
1d9f 3a ae 1d			ld a, (.dmark+1)  
1da2 32 66 ee			ld (debug_mark+1),a  
1da5 3a af 1d			ld a, (.dmark+2)  
1da8 32 67 ee			ld (debug_mark+2),a  
1dab 18 03			jr .pastdmark  
1dad ..			.dmark: db "DVL"  
1db0 f1			.pastdmark: pop af  
1db1			endm  
# End of macro DMARK
1db1				CALLMONITOR 
1db1 cd 6f ee			call debug_vector  
1db4				endm  
# End of macro CALLMONITOR
1db4				endif 
1db4 c9				ret 
1db5			 
1db5			forth_apushstrhl:      
1db5				; push of string requires use of cli_origptr 
1db5				; bodge use 
1db5			 
1db5				; get current cli_origptr, save, update with temp pointer  
1db5 ed 5b 38 ea		ld de, (cli_origptr) 
1db9 22 38 ea			ld (cli_origptr), hl 
1dbc d5				push de 
1dbd cd f9 1c			call forth_apush 
1dc0 d1				pop de 
1dc1 ed 53 38 ea		ld (cli_origptr), de 
1dc5 c9			        ret	 
1dc6			 
1dc6			 
1dc6			; increase loop stack pointer and save hl to it 
1dc6				 
1dc6			FORTH_LOOP_NEXT: macro 
1dc6				call macro_forth_loop_next 
1dc6				;nop 
1dc6				endm 
1dc6			 
1dc6			macro_forth_loop_next: 
1dc6				if DEBUG_FORTH_STACK_GUARD 
1dc6 cd 17 5b				call check_stacks 
1dc9				endif 
1dc9 e5				push hl 
1dca d5				push de 
1dcb eb				ex de,hl 
1dcc 2a ea e9			ld hl,(cli_loop_sp) 
1dcf 23				inc hl 
1dd0 23				inc hl 
1dd1					if DEBUG_FORTH_WORDS 
1dd1						DMARK "LNX" 
1dd1 f5				push af  
1dd2 3a e6 1d			ld a, (.dmark)  
1dd5 32 65 ee			ld (debug_mark),a  
1dd8 3a e7 1d			ld a, (.dmark+1)  
1ddb 32 66 ee			ld (debug_mark+1),a  
1dde 3a e8 1d			ld a, (.dmark+2)  
1de1 32 67 ee			ld (debug_mark+2),a  
1de4 18 03			jr .pastdmark  
1de6 ..			.dmark: db "LNX"  
1de9 f1			.pastdmark: pop af  
1dea			endm  
# End of macro DMARK
1dea						CALLMONITOR 
1dea cd 6f ee			call debug_vector  
1ded				endm  
# End of macro CALLMONITOR
1ded					endif 
1ded 22 ea e9			ld (cli_loop_sp),hl 
1df0 73				ld (hl), e 
1df1 23				inc hl 
1df2 72				ld (hl), d 
1df3 d1				pop de    ; been reversed so save a swap on restore 
1df4 e1				pop hl 
1df5				if DEBUG_FORTH_STACK_GUARD 
1df5 cd 17 5b				call check_stacks 
1df8				endif 
1df8 c9				ret 
1df9			 
1df9			; get current ret stack pointer and save to hl  
1df9				 
1df9			FORTH_LOOP_TOS: macro 
1df9				call macro_forth_loop_tos 
1df9				endm 
1df9			 
1df9			macro_forth_loop_tos: 
1df9 d5				push de 
1dfa 2a ea e9			ld hl,(cli_loop_sp) 
1dfd 5e				ld e, (hl) 
1dfe 23				inc hl 
1dff 56				ld d, (hl) 
1e00 eb				ex de, hl 
1e01 d1				pop de 
1e02 c9				ret 
1e03			 
1e03			; pop loop stack pointer 
1e03				 
1e03			FORTH_LOOP_POP: macro 
1e03				call macro_forth_loop_pop 
1e03				endm 
1e03			 
1e03			 
1e03			macro_forth_loop_pop: 
1e03				if DEBUG_FORTH_STACK_GUARD 
1e03					DMARK "LPP" 
1e03 f5				push af  
1e04 3a 18 1e			ld a, (.dmark)  
1e07 32 65 ee			ld (debug_mark),a  
1e0a 3a 19 1e			ld a, (.dmark+1)  
1e0d 32 66 ee			ld (debug_mark+1),a  
1e10 3a 1a 1e			ld a, (.dmark+2)  
1e13 32 67 ee			ld (debug_mark+2),a  
1e16 18 03			jr .pastdmark  
1e18 ..			.dmark: db "LPP"  
1e1b f1			.pastdmark: pop af  
1e1c			endm  
# End of macro DMARK
1e1c cd 17 5b				call check_stacks 
1e1f					FORTH_CHK_LOOP_UNDER 
1e1f e5				push hl 
1e20 d5				push de 
1e21 2a ea e9			ld hl,(cli_loop_sp) 
1e24 11 24 e9			ld de, cli_loop_stack 
1e27 cd 13 0e			call cmp16 
1e2a da 34 5c			jp c, fault_loop_under 
1e2d d1				pop de 
1e2e e1				pop hl 
1e2f				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e2f				endif 
1e2f e5				push hl 
1e30 2a ea e9			ld hl,(cli_loop_sp) 
1e33 2b				dec hl 
1e34 2b				dec hl 
1e35 22 ea e9			ld (cli_loop_sp), hl 
1e38				; TODO do stack underflow checks 
1e38 e1				pop hl 
1e39				if DEBUG_FORTH_STACK_GUARD 
1e39 cd 17 5b				call check_stacks 
1e3c					FORTH_CHK_LOOP_UNDER 
1e3c e5				push hl 
1e3d d5				push de 
1e3e 2a ea e9			ld hl,(cli_loop_sp) 
1e41 11 24 e9			ld de, cli_loop_stack 
1e44 cd 13 0e			call cmp16 
1e47 da 34 5c			jp c, fault_loop_under 
1e4a d1				pop de 
1e4b e1				pop hl 
1e4c				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e4c				endif 
1e4c c9				ret 
1e4d			 
1e4d			macro_forth_dsp_pop: 
1e4d			 
1e4d e5				push hl 
1e4e			 
1e4e				; release malloc data 
1e4e			 
1e4e				if DEBUG_FORTH_STACK_GUARD 
1e4e cd 17 5b				call check_stacks 
1e51					FORTH_CHK_DSP_UNDER 
1e51 e5				push hl 
1e52 d5				push de 
1e53 2a e8 e9			ld hl,(cli_data_sp) 
1e56 11 22 e8			ld de, cli_data_stack 
1e59 cd 13 0e			call cmp16 
1e5c da 28 5c			jp c, fault_dsp_under 
1e5f d1				pop de 
1e60 e1				pop hl 
1e61				endm 
# End of macro FORTH_CHK_DSP_UNDER
1e61				endif 
1e61				;ld hl,(cli_data_sp) 
1e61			if DEBUG_FORTH_DOT 
1e61				DMARK "DPP" 
1e61 f5				push af  
1e62 3a 76 1e			ld a, (.dmark)  
1e65 32 65 ee			ld (debug_mark),a  
1e68 3a 77 1e			ld a, (.dmark+1)  
1e6b 32 66 ee			ld (debug_mark+1),a  
1e6e 3a 78 1e			ld a, (.dmark+2)  
1e71 32 67 ee			ld (debug_mark+2),a  
1e74 18 03			jr .pastdmark  
1e76 ..			.dmark: db "DPP"  
1e79 f1			.pastdmark: pop af  
1e7a			endm  
# End of macro DMARK
1e7a				CALLMONITOR 
1e7a cd 6f ee			call debug_vector  
1e7d				endm  
# End of macro CALLMONITOR
1e7d			endif	 
1e7d			 
1e7d			 
1e7d			if FORTH_ENABLE_DSPPOPFREE 
1e7d			 
1e7d				FORTH_DSP 
1e7d cd 5b 1d			call macro_forth_dsp 
1e80				endm 
# End of macro FORTH_DSP
1e80			 
1e80 7e				ld a, (hl) 
1e81 fe 01			cp DS_TYPE_STR 
1e83 20 23			jr nz, .skippopfree 
1e85			 
1e85				FORTH_DSP_VALUEHL 
1e85 cd 95 1d			call macro_dsp_valuehl 
1e88				endm 
# End of macro FORTH_DSP_VALUEHL
1e88 00				nop 
1e89			if DEBUG_FORTH_DOT 
1e89				DMARK "DPf" 
1e89 f5				push af  
1e8a 3a 9e 1e			ld a, (.dmark)  
1e8d 32 65 ee			ld (debug_mark),a  
1e90 3a 9f 1e			ld a, (.dmark+1)  
1e93 32 66 ee			ld (debug_mark+1),a  
1e96 3a a0 1e			ld a, (.dmark+2)  
1e99 32 67 ee			ld (debug_mark+2),a  
1e9c 18 03			jr .pastdmark  
1e9e ..			.dmark: db "DPf"  
1ea1 f1			.pastdmark: pop af  
1ea2			endm  
# End of macro DMARK
1ea2				CALLMONITOR 
1ea2 cd 6f ee			call debug_vector  
1ea5				endm  
# End of macro CALLMONITOR
1ea5			endif	 
1ea5 cd 9a 12			call free 
1ea8			.skippopfree: 
1ea8				 
1ea8			 
1ea8			endif 
1ea8			 
1ea8			if DEBUG_FORTH_DOT_KEY 
1ea8				DMARK "DP2" 
1ea8				CALLMONITOR 
1ea8			endif	 
1ea8			 
1ea8				; move pointer down 
1ea8			 
1ea8 2a e8 e9			ld hl,(cli_data_sp) 
1eab 2b				dec hl 
1eac 2b				dec hl 
1ead			; PARSEV5 
1ead 2b				dec hl 
1eae 22 e8 e9			ld (cli_data_sp), hl 
1eb1			 
1eb1				if DEBUG_FORTH_STACK_GUARD 
1eb1 cd 17 5b				call check_stacks 
1eb4					FORTH_CHK_DSP_UNDER 
1eb4 e5				push hl 
1eb5 d5				push de 
1eb6 2a e8 e9			ld hl,(cli_data_sp) 
1eb9 11 22 e8			ld de, cli_data_stack 
1ebc cd 13 0e			call cmp16 
1ebf da 28 5c			jp c, fault_dsp_under 
1ec2 d1				pop de 
1ec3 e1				pop hl 
1ec4				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ec4				endif 
1ec4			 
1ec4 e1				pop hl 
1ec5			 
1ec5 c9				ret 
1ec6			 
1ec6			getwordathl: 
1ec6				; hl points to an address 
1ec6				; load hl with the word at that address 
1ec6			 
1ec6 d5				push de 
1ec7			 
1ec7 5e				ld e, (hl) 
1ec8 23				inc hl 
1ec9 56				ld d, (hl) 
1eca eb				ex de, hl 
1ecb			 
1ecb d1				pop de 
1ecc c9				ret 
1ecd			 
1ecd			 
1ecd			; functions to manuplite stack pointers 
1ecd			 
1ecd			; generate fragment to set hl to be pointer to a stack item 
1ecd			 
1ecd			FORTH_DSP_PTR: macro  x 
1ecd				ld hl,(cli_data_sp) 
1ecd				ld de, x * 3 
1ecd				sbc hl, de 
1ecd				endm 
1ecd			 
1ecd			 
1ecd			 
1ecd			; copy point in hl to stack tmp storage slots 1-4 
1ecd			hltostack1: 
1ecd 11 b8 e2			ld de, os_stack_1  
1ed0 c3 fb 1e			jp hltostackmv 
1ed3			 
1ed3			hltostack2:  
1ed3 11 b5 e2			ld de, os_stack_2 
1ed6 c3 fb 1e			jp hltostackmv 
1ed9			 
1ed9			hltostack3:  
1ed9 11 b2 e2			ld de, os_stack_3 
1edc c3 fb 1e			jp hltostackmv 
1edf			 
1edf			hltostack4:  
1edf 11 af e2			ld de, os_stack_4  
1ee2 c3 fb 1e			jp hltostackmv 
1ee5			 
1ee5			; copy to point in hl from stack tmp storage slots 1-4 
1ee5			hlfromstack1: 
1ee5 11 b8 e2			ld de, os_stack_1 
1ee8 c3 fa 1e			jp hlfromsttackmv 
1eeb			 
1eeb			hlfromstack2:  
1eeb 11 b5 e2			ld de, os_stack_2 
1eee c3 fa 1e			jp hlfromsttackmv 
1ef1			 
1ef1			hlfromstack3:  
1ef1 11 b2 e2			ld de, os_stack_3 
1ef4 c3 fa 1e			jp hlfromsttackmv 
1ef7			 
1ef7			hlfromstack4:  
1ef7 11 af e2			ld de, os_stack_4 
1efa			 
1efa			hlfromsttackmv: 
1efa eb				ex de, hl 
1efb			 
1efb			hltostackmv: 
1efb			 
1efb				; do stack move 
1efb c5				push bc 
1efc 01 03 00			ld bc, 3 
1eff ed b0			ldir  
1f01 c1				pop bc	 
1f02 c9				ret 
1f03			 
1f03			; eof 
1f03			 
# End of file forth_stackopsv5.asm
1f03			endif 
1f03			 
1f03			loadwordinhl:	 
1f03			 
1f03 d5				push de 
1f04			 
1f04 5e				ld e, (hl) 
1f05 23				inc hl 
1f06 56				ld d, (hl) 
1f07 eb				ex de,hl  
1f08			 
1f08 d1				pop de 
1f09			 
1f09 c9				ret 
1f0a			 
1f0a			user_word_eol:  
1f0a				; hl contains the pointer to where to create a linked list item from the end 
1f0a				; of the user dict to continue on at the system word dict 
1f0a				 
1f0a				; poke the stub of the word list linked list to repoint to rom words 
1f0a			 
1f0a				; stub format 
1f0a				; db   word id 
1f0a				; dw    link to next word 
1f0a			        ; db char length of token 
1f0a				; db string + 0 term 
1f0a				; db exec code....  
1f0a			 
1f0a 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1f0c 77				ld (hl), a		; word id 
1f0d 23				inc hl 
1f0e			 
1f0e 11 d9 20			ld de, sysdict 
1f11 73				ld (hl), e		; next word link ie system dict 
1f12 23				inc hl 
1f13 72				ld (hl), d		; next word link ie system dict 
1f14 23				inc hl	 
1f15			 
1f15			;	ld (hl), sysdict		; next word link ie system dict 
1f15			;	inc hl 
1f15			;	inc hl 
1f15			 
1f15			;	inc hl 
1f15			;	inc hl 
1f15			 
1f15 3e 02			ld a, 2			; word length is 0 
1f17 77				ld (hl), a	 
1f18 23				inc hl 
1f19			 
1f19 3e 7e			ld a, '~'			; word length is 0 
1f1b 77				ld (hl), a	 
1f1c 23				inc hl 
1f1d 3e 00			ld a, 0			; save empty word 
1f1f 77				ld (hl), a 
1f20			 
1f20 c9				ret 
1f21			 
1f21				 
1f21			 
1f21			forthexec_cleanup: 
1f21				FORTH_RSP_POP 
1f21 cd 58 1b			call macro_forth_rsp_pop 
1f24				endm 
# End of macro FORTH_RSP_POP
1f24 c9				ret 
1f25			 
1f25			forth_call_hl: 
1f25				; taking hl 
1f25 e5				push hl 
1f26 c9				ret 
1f27			 
1f27			; this is called to reset Forth system but keep existing uwords etc 
1f27			 
1f27			forth_warmstart: 
1f27				; setup stack over/under flow checks 
1f27				if DEBUG_FORTH_STACK_GUARD 
1f27 cd fd 5a				call chk_stk_init 
1f2a				endif 
1f2a			 
1f2a				; init stack pointers  - * these stacks go upwards *  
1f2a 21 a6 e9			ld hl, cli_ret_stack 
1f2d 22 ec e9			ld (cli_ret_sp), hl	 
1f30				; set bottom of stack 
1f30 3e 00			ld a,0 
1f32 77				ld (hl),a 
1f33 23				inc hl 
1f34 77				ld (hl),a 
1f35			 
1f35 21 22 e8			ld hl, cli_data_stack 
1f38 22 e8 e9			ld (cli_data_sp), hl	 
1f3b				; set bottom of stack 
1f3b 3e 00			ld a,0 
1f3d 77				ld (hl),a 
1f3e 23				inc hl 
1f3f 77				ld (hl),a 
1f40			 
1f40 21 24 e9			ld hl, cli_loop_stack 
1f43 22 ea e9			ld (cli_loop_sp), hl	 
1f46				; set bottom of stack 
1f46 3e 00			ld a,0 
1f48 77				ld (hl),a 
1f49 23				inc hl 
1f4a 77				ld (hl),a 
1f4b			 
1f4b				; init extent of current open file 
1f4b			 
1f4b 3e 00			ld a, 0 
1f4d 32 64 ea			ld (store_openext), a 
1f50			 
1f50 c9				ret 
1f51			 
1f51			 
1f51			 
1f51			; Cold Start - this is called to setup the whole Forth system 
1f51			 
1f51			forth_init: 
1f51			 
1f51				; setup stack over/under flow checks 
1f51			 
1f51			;	if DEBUG_FORTH_STACK_GUARD 
1f51			;		call chk_stk_init 
1f51			;	endif 
1f51			 
1f51				; enable auto display updates (slow.....) 
1f51			 
1f51 3e 01			ld a, 1 
1f53 32 36 ea			ld (cli_autodisplay), a 
1f56			 
1f56				; if storage is in use disable long reads for now 
1f56 3e 00			ld a, 0 
1f58 32 6f ea			ld (store_longread), a 
1f5b			 
1f5b			 
1f5b				; show start up screen 
1f5b			 
1f5b cd c8 0b			call clear_display 
1f5e			 
1f5e 3e 00			ld a,0 
1f60 32 58 ea			ld (f_cursor_ptr), a 
1f63			 
1f63				; set start of word list in start of ram - for use when creating user words 
1f63			 
1f63 21 12 5f			ld hl, baseram 
1f66 22 b8 e5			ld (os_last_new_uword), hl 
1f69 cd 0a 1f			call user_word_eol 
1f6c				 
1f6c			;		call display_data_sp 
1f6c			;		call next_page_prompt 
1f6c			 
1f6c			 
1f6c			 
1f6c			 
1f6c c9				ret 
1f6d			 
1f6d .. 00		.bootforth: db " Forth Kernel Init ",0 
1f81			 
1f81			; TODO push to stack 
1f81			 
1f81			;  
1f81			 
1f81			if FORTH_PARSEV2 
1f81			 
1f81			 
1f81				include "forth_parserv2.asm" 
1f81			 
1f81			endif 
1f81			 
1f81			 
1f81			; parse cli version 1 
1f81			 
1f81			if FORTH_PARSEV1 
1f81			 
1f81			 
1f81			 
1f81			      include "forth_parserv1.asm" 
1f81			endif 
1f81				 
1f81			if FORTH_PARSEV3 
1f81			 
1f81			 
1f81			 
1f81			      include "forth_parserv3.asm" 
1f81				include "forth_wordsv3.asm" 
1f81			endif 
1f81			 
1f81			if FORTH_PARSEV4 
1f81			 
1f81			 
1f81			 
1f81			      include "forth_parserv4.asm" 
1f81				include "forth_wordsv4.asm" 
1f81			endif 
1f81			 
1f81			if FORTH_PARSEV5 
1f81			 
1f81			 
1f81			 
1f81			      include "forth_parserv5.asm" 
1f81			 
1f81			 
1f81			; A better parser without using malloc and string copies all over the place.  
1f81			; Exec in situ should be faster 
1f81			 
1f81			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1f81			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1f81			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1f81			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1f81			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1f81			WORD_SYS_END: equ 0   ; Opcode for all user words 
1f81			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1f81			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1f81			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1f81			 
1f81			; Core word preamble macro 
1f81			 
1f81			CWHEAD:   macro nxtword opcode lit len opflags 
1f81				db WORD_SYS_CORE+opcode             
1f81				; internal op code number 
1f81				dw nxtword            
1f81				; link to next dict word block 
1f81				db len + 1 
1f81				; literal length of dict word inc zero term 
1f81				db lit,0              
1f81				; literal dict word 
1f81			        ; TODO db opflags        
1f81				endm 
1f81			 
1f81			 
1f81			NEXTW: macro  
1f81				jp macro_next 
1f81				endm 
1f81			 
1f81			macro_next: 
1f81			if DEBUG_FORTH_PARSE_KEY 
1f81				DMARK "NXT" 
1f81				CALLMONITOR 
1f81			endif	 
1f81			;	inc hl  ; skip token null term  
1f81 ed 4b 3a ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f85 ed 5b 38 ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f89 2a bc e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f8c			if DEBUG_FORTH_PARSE_KEY 
1f8c				DMARK "}AA" 
1f8c				CALLMONITOR 
1f8c			endif	 
1f8c c3 8f 20			jp execnext 
1f8f				;jp exec1 
1f8f			       
1f8f			 
1f8f			 
1f8f			; Another go at the parser to compile  
1f8f			 
1f8f			 
1f8f			; TODO rework parser to change all of the string words to byte tokens 
1f8f			; TODO do a search for  
1f8f			 
1f8f			; TODO first run normal parser to zero term sections 
1f8f			; TODO for each word do a token look up to get the op code 
1f8f			; TODO need some means to flag to the exec that this is a byte code form    
1f8f			 
1f8f			 
1f8f			forthcompile: 
1f8f			 
1f8f			; 
1f8f			; line parse: 
1f8f			;       parse raw input buffer 
1f8f			;       tokenise the words 
1f8f			;       malloc new copy (for looping etc) 
1f8f			;       copy to malloc + current pc in line to start of string and add line term 
1f8f			;       save on new rsp 
1f8f			; 
1f8f			 
1f8f			; hl to point to the line to tokenise 
1f8f			 
1f8f			;	push hl 
1f8f 22 bc e5			ld (os_tok_ptr), hl  ; save ptr to string 
1f92			 
1f92			;	ld a,0		; string term on input 
1f92			;	call strlent 
1f92			 
1f92			;	ld (os_tok_len), hl	 ; save string length 
1f92			 
1f92			;if DEBUG_FORTH_TOK 
1f92			;	ex de,hl		 
1f92			;endif 
1f92			 
1f92			;	pop hl 		; get back string pointer 
1f92			 
1f92			if DEBUG_FORTH_TOK 
1f92						DMARK "TOc" 
1f92				CALLMONITOR 
1f92			endif 
1f92 7e			.cptoken2:    ld a,(hl) 
1f93 23				inc hl 
1f94 fe 7f			cp FORTH_END_BUFFER 
1f96 28 29			jr z, .cptokendone2 
1f98 fe 00			cp 0 
1f9a 28 25			jr z, .cptokendone2 
1f9c fe 22			cp '"' 
1f9e 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1fa0 fe 20			cp ' ' 
1fa2 20 ee			jr nz,  .cptoken2 
1fa4			 
1fa4			; TODO consume comments held between ( and ) 
1fa4			 
1fa4				; we have a space so change to zero term for dict match later 
1fa4 2b				dec hl 
1fa5 3e 00			ld a,0 
1fa7 77				ld (hl), a 
1fa8 23				inc hl 
1fa9 18 e7			jr .cptoken2 
1fab				 
1fab			 
1fab			.cptokenstr2: 
1fab				; skip all white space until either eol (because forgot to term) or end double quote 
1fab			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1fab				;inc hl ; skip current double quote 
1fab 7e				ld a,(hl) 
1fac 23				inc hl 
1fad fe 22			cp '"' 
1faf 28 e1			jr z, .cptoken2 
1fb1 fe 7f			cp FORTH_END_BUFFER 
1fb3 28 0c			jr z, .cptokendone2 
1fb5 fe 00			cp 0 
1fb7 28 08			jr z, .cptokendone2 
1fb9 fe 20			cp ' ' 
1fbb 28 02			jr z, .cptmp2 
1fbd 18 ec			jr .cptokenstr2 
1fbf			 
1fbf			.cptmp2:	; we have a space so change to zero term for dict match later 
1fbf				;dec hl 
1fbf				;ld a,"-"	; TODO remove this when working 
1fbf				;ld (hl), a 
1fbf				;inc hl 
1fbf 18 ea			jr .cptokenstr2 
1fc1			 
1fc1			.cptokendone2: 
1fc1				;inc hl 
1fc1 3e 7f			ld a, FORTH_END_BUFFER 
1fc3 77				ld (hl),a 
1fc4 23				inc hl 
1fc5 3e 21			ld a, '!' 
1fc7 77				ld (hl),a 
1fc8			 
1fc8 2a bc e5			ld hl,(os_tok_ptr) 
1fcb			         
1fcb			if DEBUG_FORTH_TOK 
1fcb						DMARK "Tc1" 
1fcb				CALLMONITOR 
1fcb			endif 
1fcb			 
1fcb				; push exec string to top of return stack 
1fcb				FORTH_RSP_NEXT 
1fcb cd 37 1b			call macro_forth_rsp_next 
1fce				endm 
# End of macro FORTH_RSP_NEXT
1fce c9				ret 
1fcf			 
1fcf			; Another go at the parser need to simplify the process 
1fcf			 
1fcf			forthparse: 
1fcf			 
1fcf			; 
1fcf			; line parse: 
1fcf			;       parse raw input buffer 
1fcf			;       tokenise the words 
1fcf			;       malloc new copy (for looping etc) 
1fcf			;       copy to malloc + current pc in line to start of string and add line term 
1fcf			;       save on new rsp 
1fcf			; 
1fcf			 
1fcf			; hl to point to the line to tokenise 
1fcf			 
1fcf			;	push hl 
1fcf 22 bc e5			ld (os_tok_ptr), hl  ; save ptr to string 
1fd2			 
1fd2			;	ld a,0		; string term on input 
1fd2			;	call strlent 
1fd2			 
1fd2			;	ld (os_tok_len), hl	 ; save string length 
1fd2			 
1fd2			;if DEBUG_FORTH_TOK 
1fd2			;	ex de,hl		 
1fd2			;endif 
1fd2			 
1fd2			;	pop hl 		; get back string pointer 
1fd2			 
1fd2			if DEBUG_FORTH_TOK 
1fd2						DMARK "TOK" 
1fd2				CALLMONITOR 
1fd2			endif 
1fd2 7e			.ptoken2:    ld a,(hl) 
1fd3 23				inc hl 
1fd4 fe 7f			cp FORTH_END_BUFFER 
1fd6 28 29			jr z, .ptokendone2 
1fd8 fe 00			cp 0 
1fda 28 25			jr z, .ptokendone2 
1fdc fe 22			cp '"' 
1fde 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1fe0 fe 20			cp ' ' 
1fe2 20 ee			jr nz,  .ptoken2 
1fe4			 
1fe4			; TODO consume comments held between ( and ) 
1fe4			 
1fe4				; we have a space so change to zero term for dict match later 
1fe4 2b				dec hl 
1fe5 3e 00			ld a,0 
1fe7 77				ld (hl), a 
1fe8 23				inc hl 
1fe9 18 e7			jr .ptoken2 
1feb				 
1feb			 
1feb			.ptokenstr2: 
1feb				; skip all white space until either eol (because forgot to term) or end double quote 
1feb			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1feb				;inc hl ; skip current double quote 
1feb 7e				ld a,(hl) 
1fec 23				inc hl 
1fed fe 22			cp '"' 
1fef 28 e1			jr z, .ptoken2 
1ff1 fe 7f			cp FORTH_END_BUFFER 
1ff3 28 0c			jr z, .ptokendone2 
1ff5 fe 00			cp 0 
1ff7 28 08			jr z, .ptokendone2 
1ff9 fe 20			cp ' ' 
1ffb 28 02			jr z, .ptmp2 
1ffd 18 ec			jr .ptokenstr2 
1fff			 
1fff			.ptmp2:	; we have a space so change to zero term for dict match later 
1fff				;dec hl 
1fff				;ld a,"-"	; TODO remove this when working 
1fff				;ld (hl), a 
1fff				;inc hl 
1fff 18 ea			jr .ptokenstr2 
2001			 
2001			.ptokendone2: 
2001				;inc hl 
2001 3e 7f			ld a, FORTH_END_BUFFER 
2003 77				ld (hl),a 
2004 23				inc hl 
2005 3e 21			ld a, '!' 
2007 77				ld (hl),a 
2008			 
2008 2a bc e5			ld hl,(os_tok_ptr) 
200b			         
200b			if DEBUG_FORTH_TOK 
200b						DMARK "TK1" 
200b				CALLMONITOR 
200b			endif 
200b			 
200b				; push exec string to top of return stack 
200b				FORTH_RSP_NEXT 
200b cd 37 1b			call macro_forth_rsp_next 
200e				endm 
# End of macro FORTH_RSP_NEXT
200e c9				ret 
200f			 
200f			; 
200f			;	; malloc size + buffer pointer + if is loop flag 
200f			;	ld hl,(os_tok_len) 		 ; get string length 
200f			; 
200f			;	ld a,l 
200f			; 
200f			;	cp 0			; we dont want to use a null string 
200f			;	ret z 
200f			; 
200f			;;	add 3    ; prefix malloc with buffer for current word ptr 
200f			; 
200f			;	add 5     ; TODO when certain not over writing memory remove 
200f			; 
200f			;		 
200f			; 
200f			;if DEBUG_FORTH_TOK 
200f			;			DMARK "TKE" 
200f			;	CALLMONITOR 
200f			;endif 
200f			; 
200f			;	ld l,a 
200f			;	ld h,0 
200f			;;	push hl   ; save required space for the copy later 
200f			;	call malloc 
200f			;if DEBUG_FORTH_TOK 
200f			;			DMARK "TKM" 
200f			;	CALLMONITOR 
200f			;endif 
200f			;	if DEBUG_FORTH_MALLOC_GUARD 
200f			;		push af 
200f			;		call ishlzero 
200f			;;		ld a, l 
200f			;;		add h 
200f			;;		cp 0 
200f			;		pop af 
200f			;		 
200f			;		call z,malloc_error 
200f			;	endif 
200f			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
200f			; 
200f			; 
200f			;if DEBUG_FORTH_TOK 
200f			;			DMARK "TKR" 
200f			;	CALLMONITOR 
200f			;endif 
200f			; 
200f			;	FORTH_RSP_NEXT 
200f			; 
200f			;	;inc hl	 ; go past current buffer pointer 
200f			;	;inc hl 
200f			;	;inc hl   ; and past if loop flag 
200f			;		; TODO Need to set flag  
200f			; 
200f			;	 
200f			;	 
200f			;	ex de,hl	; malloc is dest 
200f			;	ld hl, (os_tok_len) 
200f			;;	pop bc 
200f			;	ld c, l                
200f			;	ld b,0 
200f			;	ld hl, (os_tok_ptr) 
200f			; 
200f			;if DEBUG_FORTH_TOK 
200f			;			DMARK "TKT" 
200f			;	CALLMONITOR 
200f			;endif 
200f			; 
200f			;	; do str cpy 
200f			; 
200f			;	ldir      ; copy byte in hl to de 
200f			; 
200f			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
200f			; 
200f			;if DEBUG_FORTH_TOK 
200f			; 
200f			;			DMARK "TKY" 
200f			;	CALLMONITOR 
200f			;endif 
200f			;	;ld a,0 
200f			;	;ld a,FORTH_END_BUFFER 
200f			;	ex de, hl 
200f			;	;dec hl			 ; go back over the space delim at the end of word 
200f			;	;ld (hl),a 
200f			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
200f			;	ld a,FORTH_END_BUFFER 
200f			;	ld (hl),a 
200f			;	inc hl 
200f			;	ld a,FORTH_END_BUFFER 
200f			;	ld (hl),a 
200f			; 
200f			;	; init the malloc area data 
200f			;	; set pc for in current area 
200f			;	;ld hl, (os_tok_malloc) 
200f			;	;inc hl 
200f			;	;inc hl 
200f			;	;inc hl 
200f			;	;ex de,hl 
200f			;	;ld hl, (os_tok_malloc) 
200f			;	;ld (hl),e 
200f			;	;inc hl 
200f			;	;ld (hl),d 
200f			; 
200f			; 
200f			;	ld hl,(os_tok_malloc) 
200f			;if DEBUG_FORTH_PARSE_KEY 
200f			;			DMARK "TKU" 
200f			;	CALLMONITOR 
200f			;endif 
200f			; 
200f			;	ret 
200f			 
200f			forthexec: 
200f			 
200f			; line exec: 
200f			; forth parser 
200f			 
200f			; 
200f			;       get current exec line on rsp 
200f			 
200f				FORTH_RSP_TOS 
200f cd 4e 1b			call macro_forth_rsp_tos 
2012				endm 
# End of macro FORTH_RSP_TOS
2012			 
2012			;       restore current pc - hl points to malloc of data 
2012			 
2012				;ld e, (hl) 
2012				;inc hl 
2012				;ld d, (hl) 
2012				;ex de,hl 
2012			 
2012			 
2012			exec1: 
2012 22 bc e5			ld (os_tok_ptr), hl 
2015			 
2015				; copy our PC to working vars  
2015 22 3a ea			ld (cli_ptr), hl 
2018 22 38 ea			ld (cli_origptr), hl 
201b			 
201b 7e				ld a,(hl) 
201c fe 7f			cp FORTH_END_BUFFER 
201e c8				ret z 
201f			 
201f				; skip any nulls 
201f			 
201f fe 00			cp 0 
2021 20 03			jr nz, .execword 
2023 23				inc hl 
2024 18 ec			jr exec1 
2026			 
2026			 
2026			.execword: 
2026			 
2026			 
2026			 
2026			if DEBUG_FORTH_PARSE_KEY 
2026						DMARK "KYQ" 
2026				CALLMONITOR 
2026			endif 
2026			;       while at start of word: 
2026			; get start of dict (in user area first) 
2026			 
2026 21 12 5f		ld hl, baseram 
2029			;ld hl, sysdict 
2029 22 3c ea		ld (cli_nextword),hl 
202c			;           match word at pc 
202c			;           exec word 
202c			;           or push to dsp 
202c			;           forward to next token 
202c			;           if line term pop rsp and exit 
202c			;        
202c			 
202c			if DEBUG_FORTH_PARSE_KEY 
202c						DMARK "KYq" 
202c				CALLMONITOR 
202c			endif 
202c			 
202c			; 
202c			; word comp 
202c			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
202c			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
202c			;    move to start of word  
202c			;    compare word to cli_token 
202c			 
202c			.execpnword:	; HL at start of a word in the dictionary to check 
202c			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
202c			;	ld (cli_ptr), hl 
202c			 
202c 2a 3c ea			ld hl,(cli_nextword) 
202f			 
202f cd d2 20			call forth_tok_next 
2032			; tok next start here 
2032			;	; TODO skip compiled symbol for now 
2032			;	inc hl 
2032			; 
2032			;	; save pointer to next word 
2032			; 
2032			;	; hl now points to the address of the next word pointer  
2032			;	ld e, (hl) 
2032			;	inc hl 
2032			;	ld d, (hl) 
2032			;	inc l 
2032			; 
2032			;	ex de,hl 
2032			;if DEBUG_FORTH_PARSE_NEXTWORD 
2032			;	push bc 
2032			;	ld bc, (cli_nextword) 
2032			;			DMARK "NXW" 
2032			;	CALLMONITOR 
2032			;	pop bc 
2032			;endif 
2032			; tok next end here 
2032 22 3c ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
2035 eb				ex de, hl 
2036			 
2036			 
2036				; save the pointer of the current token - 1 to check against 
2036				 
2036 22 40 ea			ld (cli_token), hl   
2039				; TODO maybe remove below save if no debug 
2039				; save token string ptr for any debug later 
2039 23				inc hl  
203a 22 42 ea			ld (cli_origtoken), hl 
203d 2b				dec hl 
203e				; save pointer to the start of the next dictionay word 
203e 7e				ld a,(hl)   ; get string length 
203f 47				ld b,a 
2040			.execpnwordinc:  
2040 23				inc hl 
2041 10 fd			djnz .execpnwordinc 
2043 22 3e ea			ld (cli_execword), hl      ; save start of this words code 
2046			 
2046				; now check the word token against the string being parsed 
2046			 
2046 2a 40 ea			ld hl,(cli_token) 
2049 23				inc hl     ; skip string length (use zero term instead to end) 
204a 22 40 ea			ld (cli_token), hl 
204d			 
204d			if DEBUG_FORTH_PARSE_KEY 
204d						DMARK "KY2" 
204d			endif 
204d			if DEBUG_FORTH_PARSE_EXEC 
204d				; see if disabled 
204d			 
204d			;	ld a, (os_view_disable) 
204d			;	cp '*' 
204d				ld a, (debug_vector) 
204d				cp $c9   ; RET  
204d				jr z, .skip 
204d			 
204d				push hl 
204d				push hl 
204d				call clear_display 
204d				ld de, .compword 
204d				ld a, display_row_1 
204d				call str_at_display 
204d				pop de 
204d				ld a, display_row_2 
204d				call str_at_display 
204d				ld hl,(cli_ptr) 
204d				ld a,(hl) 
204d			        ld hl, os_word_scratch 
204d				ld (hl),a 
204d				ld a,0 
204d				inc hl 
204d				ld (hl),a 	 
204d				ld de, os_word_scratch 
204d				ld a, display_row_2+10 
204d				call str_at_display 
204d				call update_display 
204d				ld a, 100 
204d				call aDelayInMS 
204d				if DEBUG_FORTH_PARSE_EXEC_SLOW 
204d				call delay250ms 
204d				endif 
204d				pop hl 
204d			.skip:  
204d			endif	 
204d			.execpnchar:    ; compare char between token and string to parse 
204d			 
204d			if DEBUG_FORTH_PARSE_KEY 
204d						DMARK "Ky3" 
204d			endif 
204d			if DEBUG_FORTH_PARSE_EXEC 
204d				; see if disabled 
204d			 
204d			;	ld a, (os_view_disable) 
204d			;	cp '*' 
204d				ld a, (debug_vector) 
204d				cp $C9  ; RET 
204d				jr z, .skip2 
204d			 
204d			;	call clear_display 
204d			ld hl,(cli_token) 
204d			ld a,(hl) 
204d			ld (os_word_scratch),a 
204d				ld hl,(cli_ptr) 
204d			ld a,(hl) 
204d				ld (os_word_scratch+1),a 
204d				ld a,0 
204d				ld (os_word_scratch+2),a 
204d				ld de,os_word_scratch 
204d				ld a,display_row_4 
204d				call str_at_display 
204d				call update_display 
204d			.skip2:  
204d			endif 
204d 2a 40 ea			ld hl,(cli_token) 
2050 7e				ld a, (hl)	 ; char in word token 
2051 23				inc hl 		; move to next char 
2052 22 40 ea			ld (cli_token), hl ; and save it 
2055 47				ld b,a 
2056			 
2056 2a 3a ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
2059 7e				ld a,(hl) 
205a 23				inc hl 
205b 22 3a ea			ld (cli_ptr), hl		; move to next char 
205e cd 52 11			call toUpper 		; make sure the input string matches case 
2061			 
2061			if DEBUG_FORTH_PARSE 
2061			endif 
2061			 
2061				; input stream end of token is a space so get rid of it 
2061			 
2061			;	cp ' ' 
2061			;	jr nz, .pnskipspace 
2061			; 
2061			;	ld a, 0		; make same term as word token term 
2061			; 
2061			;.pnskipspace: 
2061			 
2061			if DEBUG_FORTH_PARSE_KEY 
2061						DMARK "KY7" 
2061			endif 
2061 b8				cp b 
2062 c2 78 20			jp nz, .execpnskipword	 ; no match so move to next word 
2065				 
2065			;    if same 
2065			;       scan for string terms 0 for token and 32 for input 
2065			 
2065				 
2065			if DEBUG_FORTH_PARSE_KEY 
2065						DMARK "KY8" 
2065			endif 
2065			 
2065 80				add b			 
2066 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2068							; TODO need to make sure last word in zero term string is accounted for 
2068 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
206a			 
206a			 
206a				; at end of both strings so both are exact match 
206a			 
206a			;       skip ptr for next word 
206a			 
206a 2a 3a ea			ld hl,(cli_ptr) 	; at input string term 
206d 23				inc hl			 ; at next char 
206e 22 3a ea			ld (cli_ptr), hl     ; save for next round of the parser 
2071 22 38 ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
2074				 
2074				 
2074			if DEBUG_FORTH_PARSE_KEY 
2074						DMARK "KY3" 
2074			endif 
2074			 
2074			 
2074			 
2074			;       exec code block 
2074			if DEBUG_FORTH_JP 
2074				call clear_display 
2074				call update_display 
2074				call delay1s 
2074				ld hl, (cli_execword)     ; save for next check if no match on this word 
2074				ld a,h 
2074				ld hl, os_word_scratch 
2074				call hexout 
2074				ld hl, (cli_execword)     ; save for next check if no match on this word 
2074				ld a,l 
2074				ld hl, os_word_scratch+2 
2074				call hexout 
2074				ld hl, os_word_scratch+4 
2074				ld a,0 
2074				ld (hl),a 
2074				ld de,os_word_scratch 
2074				call str_at_display 
2074					ld a, display_row_2 
2074					call str_at_display 
2074				ld de, (cli_origtoken) 
2074				ld a, display_row_1+10 
2074					call str_at_display 
2074			 
2074				ld a,display_row_1 
2074				ld de, .foundword 
2074				ld a, display_row_3 
2074				call str_at_display 
2074				call update_display 
2074				call delay1s 
2074				call delay1s 
2074				call delay1s 
2074			endif 
2074			 
2074			if DEBUG_FORTH_PARSE_KEY 
2074						DMARK "KYj" 
2074			endif 
2074				; TODO save the word pointer in this exec 
2074			 
2074 2a 3e ea			ld hl,(cli_execword) 
2077 e9				jp (hl) 
2078			 
2078			 
2078			;    if not same 
2078			;	scan for zero term 
2078			;	get ptr for next word 
2078			;	goto word comp 
2078			 
2078			.execpnskipword:	; get pointer to next word 
2078 2a 3c ea			ld hl,(cli_nextword) 
207b			 
207b 7e				ld a,(hl) 
207c fe 00			cp WORD_SYS_END 
207e			;	cp 0 
207e 28 09			jr z, .execendofdict			 ; at end of words 
2080			 
2080			if DEBUG_FORTH_PARSE_KEY 
2080						DMARK "KY4" 
2080			endif 
2080			if DEBUG_FORTH_PARSE_EXEC 
2080			 
2080				; see if disabled 
2080			 
2080			;	ld a, (os_view_disable) 
2080			;	cp '*' 
2080				ld a,(debug_vector) 
2080				cp $c9   ; RET 
2080				jr z, .noskip 
2080			 
2080			 
2080				ld de, .nowordfound 
2080				ld a, display_row_3 
2080				call str_at_display 
2080				call update_display 
2080				ld a, 100 
2080				call aDelayInMS 
2080				 
2080				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2080					call delay250ms 
2080				endif 
2080			.noskip:  
2080			 
2080			endif	 
2080			 
2080 2a 38 ea			ld hl,(cli_origptr) 
2083 22 3a ea			ld (cli_ptr),hl 
2086			 
2086			if DEBUG_FORTH_PARSE_KEY 
2086						DMARK "KY5" 
2086			endif 
2086 c3 2c 20			jp .execpnword			; else go to next word 
2089			 
2089			.execendofdict:  
2089			 
2089			if DEBUG_FORTH_PARSE_KEY 
2089						DMARK "KYe" 
2089			endif 
2089			if DEBUG_FORTH_PARSE_EXEC 
2089				; see if disabled 
2089			 
2089			;	ld a, (os_view_disable) 
2089			;	cp '*' 
2089				ld a,(debug_vector) 
2089				cp $c9   ; ret 
2089				jr z, .ispskip 
2089			 
2089				call clear_display 
2089				call update_display 
2089				call delay1s 
2089				ld de, (cli_origptr) 
2089				ld a, display_row_1 
2089				call str_at_display 
2089				 
2089				ld de, .enddict 
2089				ld a, display_row_3 
2089				call str_at_display 
2089				call update_display 
2089				ld a, 100 
2089				call aDelayInMS 
2089				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2089				call delay1s 
2089				call delay1s 
2089				call delay1s 
2089				endif 
2089			.ispskip:  
2089				 
2089			endif	 
2089			 
2089			 
2089			 
2089				; if the word is not a keyword then must be a literal so push it to stack 
2089			 
2089			; push token to stack to end of word 
2089			 
2089				STACKFRAME ON $1efe $2f9f 
2089				if DEBUG_STACK_IMB 
2089					if ON 
2089						exx 
2089						ld de, $1efe 
2089						ld a, d 
2089						ld hl, curframe 
2089						call hexout 
2089						ld a, e 
2089						ld hl, curframe+2 
2089						call hexout 
2089						ld hl, $1efe 
2089						push hl 
2089						ld hl, $2f9f 
2089						push hl 
2089						exx 
2089					endif 
2089				endif 
2089			endm 
# End of macro STACKFRAME
2089			 
2089 2a bc e5		ld hl,(os_tok_ptr) 
208c cd f9 1c		call forth_apush 
208f			 
208f				STACKFRAMECHK ON $1efe $2f9f 
208f				if DEBUG_STACK_IMB 
208f					if ON 
208f						exx 
208f						ld hl, $2f9f 
208f						pop de   ; $2f9f 
208f						call cmp16 
208f						jr nz, .spnosame 
208f						ld hl, $1efe 
208f						pop de   ; $1efe 
208f						call cmp16 
208f						jr z, .spfrsame 
208f						.spnosame: call showsperror 
208f						.spfrsame: nop 
208f						exx 
208f					endif 
208f				endif 
208f			endm 
# End of macro STACKFRAMECHK
208f			 
208f			execnext: 
208f			 
208f			if DEBUG_FORTH_PARSE_KEY 
208f						DMARK "KY>" 
208f			endif 
208f			; move past token to next word 
208f			 
208f 2a bc e5		ld hl, (os_tok_ptr) 
2092 3e 00		ld a, 0 
2094 01 ff 00		ld bc, 255     ; input buffer size 
2097 ed b1		cpir 
2099			 
2099			if DEBUG_FORTH_PARSE_KEY 
2099						DMARK "KY!" 
2099				CALLMONITOR 
2099			endif	 
2099			; TODO this might place hl on the null, so will need to forward on??? 
2099			;inc hl   ; see if this gets onto the next item 
2099			 
2099			 
2099			; TODO pass a pointer to the buffer to push 
2099			; TODO call function to push 
2099			 
2099			; look for end of input 
2099			 
2099			;inc hl 
2099			;ld a,(hl) 
2099			;cp FORTH_END_BUFFER 
2099			;ret z 
2099			 
2099			 
2099 c3 12 20		jp exec1 
209c			 
209c			 
209c			 
209c			 
209c			 
209c			 
209c			 
209c			 
209c			 
209c			findnexttok: 
209c			 
209c				; hl is pointer to move 
209c				; de is the token to locate 
209c			 
209c					if DEBUG_FORTH 
209c						DMARK "NTK" 
209c						CALLMONITOR 
209c					endif 
209c d5				push de 
209d			 
209d			.fnt1:	 
209d				; find first char of token to locate 
209d			 
209d 1a				ld a, (de) 
209e 4f				ld c,a 
209f 7e				ld a,(hl) 
20a0 cd 52 11			call toUpper 
20a3					if DEBUG_FORTH 
20a3						DMARK "NT1" 
20a3						CALLMONITOR 
20a3					endif 
20a3 b9				cp c 
20a4			 
20a4 28 03			jr z, .fnt2cmpmorefirst	 
20a6			 
20a6				; first char not found move to next char 
20a6			 
20a6 23				inc hl 
20a7 18 f4			jr .fnt1 
20a9			 
20a9			.fnt2cmpmorefirst:	 
20a9				; first char of token found.  
20a9			 
20a9 e5				push hl     ; save start of token just in case it is the right one 
20aa d9				exx 
20ab e1				pop hl        ; save it to hl' 
20ac d9				exx 
20ad			 
20ad			 
20ad			.fnt2cmpmore:	 
20ad				; compare the rest 
20ad				 
20ad 23				inc hl 
20ae 13				inc de 
20af				 
20af 1a				ld a, (de) 
20b0 4f				ld c,a 
20b1 7e				ld a,(hl) 
20b2 cd 52 11			call toUpper 
20b5			 
20b5					if DEBUG_FORTH 
20b5						DMARK "NT2" 
20b5						CALLMONITOR 
20b5					endif 
20b5				; c has the token to find char 
20b5				; a has the mem to scan char 
20b5			 
20b5 b9				cp c 
20b6 28 04			jr z,.fntmatch1 
20b8			 
20b8				; they are not the same 
20b8			 
20b8					if DEBUG_FORTH 
20b8						DMARK "NT3" 
20b8						CALLMONITOR 
20b8					endif 
20b8 d1				pop de	; reset de token to look for 
20b9 d5				push de 
20ba 18 e1			jr .fnt1 
20bc				 
20bc			.fntmatch1: 
20bc			 
20bc				; is the same char a null which means we might have a full hit? 
20bc					if DEBUG_FORTH 
20bc						DMARK "NT4" 
20bc						CALLMONITOR 
20bc					endif 
20bc			 
20bc fe 00			cp 0 
20be 28 0b			jr z, .fntmatchyes 
20c0			 
20c0				; are we at the end of the token to find? 
20c0			 
20c0					if DEBUG_FORTH 
20c0						DMARK "NT5" 
20c0						CALLMONITOR 
20c0					endif 
20c0 3e 00			ld a, 0 
20c2 b9				cp c 
20c3			 
20c3 c2 ad 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
20c6			 
20c6					if DEBUG_FORTH 
20c6						DMARK "NT6" 
20c6						CALLMONITOR 
20c6					endif 
20c6				; token to find is exhusted but no match to stream 
20c6			 
20c6				; restore tok pointer and continue on 
20c6 d1				pop de 
20c7 d5				push de 
20c8 c3 9d 20			jp .fnt1 
20cb			 
20cb			 
20cb			.fntmatchyes: 
20cb			 
20cb				; hl now contains the end of the found token 
20cb			 
20cb				; get rid of saved token pointer to find 
20cb			 
20cb d1				pop de 
20cc			 
20cc					if DEBUG_FORTH 
20cc						DMARK "NT9" 
20cc						CALLMONITOR 
20cc					endif 
20cc			 
20cc				; hl will be on the null term so forward on 
20cc			 
20cc				; get back the saved start of the token 
20cc			 
20cc d9				exx 
20cd e5				push hl     ; save start of token just in case it is the right one 
20ce d9				exx 
20cf e1				pop hl        ; save it to hl 
20d0			 
20d0 c9				ret 
20d1			 
20d1			 
20d1			; LIST needs to find a specific token   
20d1			; FORGET needs to find a spefici token 
20d1			 
20d1			; SAVE needs to find all tokens by flag 
20d1			; WORDS just needs to scan through all  by flag 
20d1			; UWORDS needs to scan through all by flag 
20d1			 
20d1			 
20d1			; given hl as pointer to start of dict look up string 
20d1			; return hl as pointer to start of word block 
20d1			; or 0 if not found 
20d1			 
20d1			forth_find_tok: 
20d1 c9				ret 
20d2			 
20d2			; given hl as pointer to dict structure 
20d2			; move to the next dict block structure 
20d2			 
20d2			forth_tok_next: 
20d2				; hl now points to the address of the next word pointer  
20d2				; TODO skip compiled symbol for now 
20d2			;	push de 
20d2 23				inc hl 
20d3 5e				ld e, (hl) 
20d4 23				inc hl 
20d5 56				ld d, (hl) 
20d6 23				inc hl 
20d7			 
20d7 eb				ex de,hl 
20d8			if DEBUG_FORTH_PARSE_NEXTWORD 
20d8				push bc 
20d8				ld bc, (cli_nextword) 
20d8						DMARK "NXW" 
20d8				CALLMONITOR 
20d8				pop bc 
20d8			endif 
20d8			;	pop de	 
20d8 c9				ret 
20d9			 
20d9			 
20d9			 
20d9			; eof 
# End of file forth_parserv5.asm
20d9				include "forth_wordsv4.asm" 
20d9			 
20d9			; the core word dictionary v4 
20d9			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
20d9			 
20d9			; this is a linked list for each of the system words used 
20d9			; user defined words will follow the same format but will be in ram 
20d9			 
20d9			 
20d9			; 
20d9			; 
20d9			; define linked list: 
20d9			; 
20d9			; 1. compiled byte op code 
20d9			; 2. len of text word 
20d9			; 3. text word 
20d9			; 4. ptr to next dictionary word 
20d9			; 5. asm, calls etc for the word 
20d9			; 
20d9			;  if 1 == 0 then last word in dict  
20d9			;   
20d9			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
20d9			;  
20d9			;  
20d9			; create basic standard set of words 
20d9			; 
20d9			;  
20d9			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
20d9			; 2DUP 2DROP 2SWAP  
20d9			; @ C@ - get byte  
20d9			; ! C! - store byte 
20d9			; 0< true if less than zero 
20d9			; 0= true if zero 
20d9			; < >  
20d9			; = true if same 
20d9			; variables 
20d9			 
20d9			 
20d9			; Hardware specific words I may need 
20d9			; 
20d9			; IN OUT  
20d9			; calls to key util functions 
20d9			; calls to hardward abstraction stuff 
20d9			; easy control of frame buffers and lcd i/o 
20d9			; keyboard  
20d9			 
20d9			 
20d9			;DICT: macro 
20d9			; op_code, len, word, next 
20d9			;    word: 
20d9			;    db op_code 
20d9			;    ds word zero term 
20d9			;    dw next 
20d9			;    endm 
20d9			 
20d9			 
20d9			 
20d9			 
20d9			; op code 1 is a flag for user define words which are to be handled differently 
20d9			 
20d9			 
20d9			; 
20d9			; 
20d9			;    TODO on entry to a word this should be the expected environment 
20d9			;    hl - tos value if number then held, if string this is the ptr 
20d9			;    de -  
20d9			 
20d9			 
20d9			; opcode ranges 
20d9			; 0 - end of word dict 
20d9			; 255 - user define words 
20d9			 
20d9			sysdict: 
20d9			include "forth_opcodes.asm" 
20d9			; op codes for forth keywords 
20d9			; free to use code 0  
20d9				OPCODE_HEAP: equ  1 
20d9				OPCODE_EXEC: equ 2 
20d9				OPCODE_DUP: equ 3 
20d9				OPCODE_SWAP: equ 4 
20d9				OPCODE_COLN: equ 5 
20d9				OPCODE_SCOLN: equ 6 
20d9				OPCODE_DROP: equ 7 
20d9				OPCODE_DUP2: equ 8 
20d9				OPCODE_DROP2: equ 9 
20d9				OPCODE_SWAP2: equ 10 
20d9				OPCODE_AT: equ 11 
20d9				OPCODE_CAT: equ 12 
20d9				OPCODE_BANG: equ 13 
20d9				OPCODE_CBANG: equ 14 
20d9				OPCODE_SCALL: equ 15 
20d9				OPCODE_DEPTH: equ 16 
20d9				OPCODE_OVER: equ 17 
20d9				OPCODE_PAUSE: equ 18 
20d9				OPCODE_PAUSES: equ 19 
20d9				OPCODE_ROT: equ 20 
20d9			;free to reuse	OPCODE_WORDS: equ 21 
20d9			        OPCODE_NOT: equ 21 
20d9				OPCODE_UWORDS: equ 22 
20d9				OPCODE_BP: equ 23 
20d9				OPCODE_MONITOR: equ 24  
20d9				OPCODE_MALLOC: equ 25 
20d9				OPCODE_FREE: equ 26 
20d9				OPCODE_LIST: equ 27 
20d9				OPCODE_FORGET: equ 28 
20d9				OPCODE_NOP: equ 29 
20d9				OPCODE_COMO: equ 30 
20d9				OPCODE_COMC: equ 31 
20d9			;free to reuse	OPCODE_ENDCORE: equ 32 
20d9				OPCODE_AFTERSOUND: equ 33 
20d9				OPCODE_GP2: equ 34 
20d9				OPCODE_GP3: equ 35 
20d9				OPCODE_GP4: equ 36 
20d9				OPCODE_SIN: equ 37 
20d9				OPCODE_SOUT: equ 38 
20d9				OPCODE_SPIO: equ 39 
20d9				OPCODE_SPICEH: equ 40 
20d9				OPCODE_SPIOb: equ 41 
20d9				OPCODE_SPII: equ 42 
20d9				OPCODE_SESEL: equ 43 
20d9				OPCODE_CARTDEV: equ 44 
20d9			; free to reuse	OPCODE_ENDDEVICE: equ 45 
20d9				OPCODE_FB: equ 46 
20d9				OPCODE_EMIT: equ 47 
20d9				OPCODE_DOTH: equ 48 
20d9				OPCODE_DOTF: equ 49 
20d9				OPCODE_DOT: equ 50 
20d9				OPCODE_CLS: equ 51 
20d9				OPCODE_DRAW: equ 52 
20d9				OPCODE_DUMP: equ 53 
20d9				OPCODE_CDUMP: equ 54 
20d9				OPCODE_DAT: equ 55 
20d9				OPCODE_HOME: equ 56 
20d9				OPCODE_SPACE: equ 57 
20d9				OPCODE_SPACES: equ 58 
20d9				OPCODE_SCROLL: equ 59 
20d9				OPCODE_ATQ: equ 60 
20d9				OPCODE_AUTODSP: equ 61 
20d9				OPCODE_MENU: equ 62 
20d9			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
20d9				OPCODE_THEN: equ 64 
20d9				OPCODE_ELSE: equ 65 
20d9				OPCODE_DO: equ 66 
20d9				OPCODE_LOOP: equ 67 
20d9				OPCODE_I: equ 68 
20d9				OPCODE_DLOOP: equ 69  
20d9				OPCODE_REPEAT: equ 70  
20d9				OPCODE_UNTIL: equ 71 
20d9				OPCODE_ENDFLOW: equ 72 
20d9				OPCODE_WAITK: equ 73 
20d9				OPCODE_ACCEPT: equ 74 
20d9				OPCODE_EDIT: equ 75 
20d9			;free to reuse	OPCODE_ENDKEY: equ 76 
20d9				OPCODE_LZERO: equ 77 
20d9				OPCODE_TZERO: equ 78 
20d9				OPCODE_LESS: equ 79 
20d9				OPCODE_GT: equ 80 
20d9				OPCODE_EQUAL: equ 81  
20d9			;free to reuse	OPCODE_ENDLOGIC: equ 82 
20d9				OPCODE_NEG: equ 83 
20d9				OPCODE_DIV: equ 84 
20d9				OPCODE_MUL: equ 85 
20d9				OPCODE_MIN: equ 86 
20d9				OPCODE_MAX: equ 87 
20d9				OPCODE_RND16: equ 88 
20d9				OPCODE_RND8: equ 89 
20d9				OPCODE_RND: equ 90 
20d9			;free to reuse	OPCODE_ENDMATHS: equ 91  
20d9				OPCODE_BYNAME: equ 92 
20d9				OPCODE_DIR: equ 93 
20d9				OPCODE_SAVE: equ 94 
20d9				OPCODE_LOAD: equ 95 
20d9				OPCODE_BSAVE: equ 96 
20d9				OPCODE_BLOAD: equ 97 
20d9				OPCODE_SEO: equ 98  
20d9				OPCODE_SEI: equ 99 
20d9				OPCODE_SFREE: equ 100 
20d9				OPCODE_SIZE: equ 101 
20d9				OPCODE_CREATE: equ 102 
20d9				OPCODE_APPEND: equ 103 
20d9				OPCODE_SDEL: equ 104 
20d9				OPCODE_OPEN: equ 105 
20d9				OPCODE_READ: equ 106 
20d9				OPCODE_EOF: equ 106 
20d9				OPCODE_FORMAT: equ 107 
20d9				OPCODE_LABEL: equ 108 
20d9				OPCODE_LABELS: equ 109 
20d9			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
20d9				OPCODE_UPPER: equ 111 
20d9				OPCODE_LOWER: equ 112 
20d9				OPCODE_SUBSTR: equ 113 
20d9				OPCODE_LEFT: equ 114 
20d9				OPCODE_RIGHT: equ 115 
20d9				OPCODE_STR2NUM: equ 116 
20d9				OPCODE_NUM2STR: equ 117 
20d9				OPCODE_CONCAT: equ 118 
20d9				OPCODE_FIND: equ 119 
20d9				OPCODE_LEN: equ 120 
20d9				OPCODE_CHAR: equ 121 
20d9			; free to reuse	OPCODE_STRLEN: equ 122 
20d9			; free to reuse	OPCODE_ENDSTR: equ 123 
20d9				OPCODE_V0S: equ 124 
20d9				OPCODE_V0Q: equ 125 
20d9				OPCODE_V1S: equ 126 
20d9				OPCODE_V1Q: equ 127 
20d9				OPCODE_V2S: equ 128 
20d9				OPCODE_V2Q: equ 129 
20d9				OPCODE_V3S: equ 130 
20d9				OPCODE_V3Q: equ 131 
20d9			;free to reuse	OPCODE_END: equ 132 
20d9				OPCODE_ZDUP: equ 133 
20d9			 
20d9			; eof 
# End of file forth_opcodes.asm
20d9			 
20d9			include "forth_words_core.asm" 
20d9			 
20d9			; | ## Core Words 
20d9			 
20d9			;if MALLOC_4 
20d9			 
20d9			.HEAP: 
20d9			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
20d9 15				db WORD_SYS_CORE+OPCODE_HEAP             
20da 18 21			dw .EXEC            
20dc 05				db 4 + 1 
20dd .. 00			db "HEAP",0              
20e2				endm 
# End of macro CWHEAD
20e2			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
20e2			; | | u1 - Current number of bytes in the heap 
20e2			; | | u2 - Remaining bytes left on the heap 
20e2			; | |  
20e2			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
20e2			 
20e2			 
20e2				if DEBUG_FORTH_WORDS_KEY 
20e2					DMARK "HEP" 
20e2 f5				push af  
20e3 3a f7 20			ld a, (.dmark)  
20e6 32 65 ee			ld (debug_mark),a  
20e9 3a f8 20			ld a, (.dmark+1)  
20ec 32 66 ee			ld (debug_mark+1),a  
20ef 3a f9 20			ld a, (.dmark+2)  
20f2 32 67 ee			ld (debug_mark+2),a  
20f5 18 03			jr .pastdmark  
20f7 ..			.dmark: db "HEP"  
20fa f1			.pastdmark: pop af  
20fb			endm  
# End of macro DMARK
20fb					CALLMONITOR 
20fb cd 6f ee			call debug_vector  
20fe				endm  
# End of macro CALLMONITOR
20fe				endif 
20fe 2a 1c 5f			ld hl, (free_list )      
2101 11 21 5f			ld de, heap_start 
2104			 
2104 ed 52			sbc hl, de  
2106			 
2106 cd 90 1b			call forth_push_numhl 
2109			 
2109			 
2109 ed 5b 1c 5f		ld de, (free_list )      
210d 21 96 e2			ld hl, heap_end 
2110			 
2110 ed 52			sbc hl, de 
2112			 
2112 cd 90 1b			call forth_push_numhl 
2115				 
2115			 
2115				 
2115			 
2115			 
2115			 
2115				NEXTW 
2115 c3 81 1f			jp macro_next 
2118				endm 
# End of macro NEXTW
2118			;endif 
2118			 
2118			.EXEC: 
2118			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
2118			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
2118			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
2118			;; > > 
2118			;; > >   
2118			;	STACKFRAME OFF $5efe $5f9f 
2118			; 
2118			;		if DEBUG_FORTH_WORDS_KEY 
2118			;			DMARK "EXE" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			; 
2118			;	FORTH_DSP_VALUEHL 
2118			; 
2118			;	FORTH_DSP_POP 
2118			; 
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EX1" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			;;	ld e,(hl) 
2118			;;	inc hl 
2118			;;	ld d,(hl) 
2118			;;	ex de,hl 
2118			; 
2118			;;		if DEBUG_FORTH_WORDS 
2118			;;			DMARK "EX2" 
2118			;;			CALLMONITOR 
2118			;;		endif 
2118			;	push hl 
2118			; 
2118			;	;ld a, 0 
2118			;	;ld a, FORTH_END_BUFFER 
2118			;	call strlenz 
2118			;	inc hl   ; include zero term to copy 
2118			;	inc hl   ; include term 
2118			;	inc hl   ; include term 
2118			;	ld b,0 
2118			;	ld c,l 
2118			;	pop hl 
2118			;	ld de, execscratch 
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EX3" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			;	ldir 
2118			; 
2118			; 
2118			;	ld hl, execscratch 
2118			; 
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EXe" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			; 
2118			;	call forthparse 
2118			;	call forthexec 
2118			;;	call forthexec_cleanup 
2118			;;	call forthparse 
2118			;;	call forthexec 
2118			; 
2118			;	STACKFRAMECHK OFF $5efe $5f9f 
2118			; 
2118			;	; an immediate word so no need to process any more words 
2118			;	ret 
2118			;	NEXTW 
2118			 
2118			; dead code - old version  
2118			;	FORTH_RSP_NEXT 
2118			 
2118			;  
2118			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
2118			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2118			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2118			;	push hl 
2118			;	push de 
2118			;	push bc 
2118			; 
2118			; 
2118			;		if DEBUG_FORTH_WORDS_KEY 
2118			;			DMARK "EXR" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			; 
2118			; 
2118			; 
2118			;	;v5 FORTH_DSP_VALUE 
2118			;	FORTH_DSP_VALUEHL 
2118			; 
2118			;	; TODO do string type checks 
2118			; 
2118			;;v5	inc hl   ; skip type 
2118			; 
2118			;	push hl  ; source code  
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EX1" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			;	ld a, 0 
2118			;	call strlent 
2118			; 
2118			;	inc hl 
2118			;	inc hl 
2118			;	inc hl 
2118			;	inc hl 
2118			; 
2118			;	push hl    ; size 
2118			; 
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EX2" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			;	call malloc 
2118			; 
2118			;	ex de, hl    ; de now contains malloc area 
2118			;	pop bc   	; get byte count 
2118			;	pop hl      ; get string to copy 
2118			; 
2118			;	push de     ; save malloc for free later 
2118			; 
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EX3" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			;	ldir       ; duplicate string 
2118			; 
2118			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
2118			;	 
2118			;	; TODO fix the parse would be better than this...  
2118			;	ex de, hl 
2118			;	dec hl 
2118			;	ld a, 0 
2118			;	ld (hl), a 
2118			;	dec hl 
2118			;	ld a, ' ' 
2118			;	ld (hl), a 
2118			;	dec hl 
2118			;	ld (hl), a 
2118			; 
2118			;	dec hl 
2118			;	ld (hl), a 
2118			; 
2118			; 
2118			;	FORTH_DSP_POP  
2118			; 
2118			;	pop hl     
2118			;	push hl    ; save malloc area 
2118			; 
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EX4" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			; 
2118			;	call forthparse 
2118			;	call forthexec 
2118			;	 
2118			;	pop hl 
2118			;	if DEBUG_FORTH_WORDS 
2118			;		DMARK "EX5" 
2118			;		CALLMONITOR 
2118			;	endif 
2118			; 
2118			;	if FORTH_ENABLE_FREE 
2118			;	call free 
2118			;	endif 
2118			; 
2118			;	if DEBUG_FORTH_WORDS 
2118			;		DMARK "EX6" 
2118			;		CALLMONITOR 
2118			;	endif 
2118			; 
2118			;	pop bc 
2118			;	pop de 
2118			;	pop hl 
2118			;;	FORTH_RSP_POP	  
2118			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
2118			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
2118			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
2118			; 
2118			;	if DEBUG_FORTH_WORDS 
2118			;		DMARK "EX7" 
2118			;		CALLMONITOR 
2118			;	endif 
2118			;	NEXTW 
2118			 
2118			;.STKEXEC: 
2118			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
2118			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
2118			; 
2118			; 
2118			;		if DEBUG_FORTH_WORDS_KEY 
2118			;			DMARK "STX" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			; 
2118			;	FORTH_DSP_VALUEHL 
2118			; 
2118			;	ld (store_tmp1), hl    ; count 
2118			; 
2118			;	FORTH_DSP_POP 
2118			;.stkexec1: 
2118			;	ld hl, (store_tmp1)   ; count 
2118			;	ld a, 0 
2118			;	cp l 
2118			;	ret z 
2118			; 
2118			;	dec hl 
2118			;	ld (store_tmp1), hl    ; count 
2118			;	 
2118			;	FORTH_DSP_VALUEHL 
2118			;	push hl 
2118			;	 
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EXp" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			;	FORTH_DSP_POP 
2118			; 
2118			;	call strlenz 
2118			;	inc hl   ; include zero term to copy 
2118			;	inc hl   ; include zero term to copy 
2118			;	inc hl   ; include zero term to copy 
2118			;	ld b,0 
2118			;	ld c,l 
2118			;	pop hl 
2118			;	ld de, execscratch 
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EX3" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			;	ldir 
2118			; 
2118			; 
2118			;	ld hl, execscratch 
2118			; 
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EXP" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			; 
2118			;	call forthparse 
2118			;	ld hl, execscratch 
2118			;		if DEBUG_FORTH_WORDS 
2118			;			DMARK "EXx" 
2118			;			CALLMONITOR 
2118			;		endif 
2118			;	call forthexec 
2118			; 
2118			;	jp .stkexec1 
2118			; 
2118			;	ret 
2118			 
2118			 
2118			.DUP: 
2118			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
2118 17				db WORD_SYS_CORE+OPCODE_DUP             
2119 8e 21			dw .ZDUP            
211b 04				db 3 + 1 
211c .. 00			db "DUP",0              
2120				endm 
# End of macro CWHEAD
2120			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2120			 
2120				if DEBUG_FORTH_WORDS_KEY 
2120					DMARK "DUP" 
2120 f5				push af  
2121 3a 35 21			ld a, (.dmark)  
2124 32 65 ee			ld (debug_mark),a  
2127 3a 36 21			ld a, (.dmark+1)  
212a 32 66 ee			ld (debug_mark+1),a  
212d 3a 37 21			ld a, (.dmark+2)  
2130 32 67 ee			ld (debug_mark+2),a  
2133 18 03			jr .pastdmark  
2135 ..			.dmark: db "DUP"  
2138 f1			.pastdmark: pop af  
2139			endm  
# End of macro DMARK
2139					CALLMONITOR 
2139 cd 6f ee			call debug_vector  
213c				endm  
# End of macro CALLMONITOR
213c				endif 
213c			 
213c				FORTH_DSP 
213c cd 5b 1d			call macro_forth_dsp 
213f				endm 
# End of macro FORTH_DSP
213f			 
213f 7e				ld a, (HL) 
2140 fe 01			cp DS_TYPE_STR 
2142 20 25			jr nz, .dupinum 
2144			 
2144				; push another string 
2144			 
2144				FORTH_DSP_VALUEHL     		 
2144 cd 95 1d			call macro_dsp_valuehl 
2147				endm 
# End of macro FORTH_DSP_VALUEHL
2147			 
2147			if DEBUG_FORTH_WORDS 
2147				DMARK "DUs" 
2147 f5				push af  
2148 3a 5c 21			ld a, (.dmark)  
214b 32 65 ee			ld (debug_mark),a  
214e 3a 5d 21			ld a, (.dmark+1)  
2151 32 66 ee			ld (debug_mark+1),a  
2154 3a 5e 21			ld a, (.dmark+2)  
2157 32 67 ee			ld (debug_mark+2),a  
215a 18 03			jr .pastdmark  
215c ..			.dmark: db "DUs"  
215f f1			.pastdmark: pop af  
2160			endm  
# End of macro DMARK
2160				CALLMONITOR 
2160 cd 6f ee			call debug_vector  
2163				endm  
# End of macro CALLMONITOR
2163			endif 
2163 cd fe 1b			call forth_push_str 
2166			 
2166				NEXTW 
2166 c3 81 1f			jp macro_next 
2169				endm 
# End of macro NEXTW
2169			 
2169			 
2169			.dupinum: 
2169				 
2169			 
2169			 
2169				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2169 cd 95 1d			call macro_dsp_valuehl 
216c				endm 
# End of macro FORTH_DSP_VALUEHL
216c			 
216c			; TODO add floating point number detection 
216c			 
216c			if DEBUG_FORTH_WORDS 
216c				DMARK "DUi" 
216c f5				push af  
216d 3a 81 21			ld a, (.dmark)  
2170 32 65 ee			ld (debug_mark),a  
2173 3a 82 21			ld a, (.dmark+1)  
2176 32 66 ee			ld (debug_mark+1),a  
2179 3a 83 21			ld a, (.dmark+2)  
217c 32 67 ee			ld (debug_mark+2),a  
217f 18 03			jr .pastdmark  
2181 ..			.dmark: db "DUi"  
2184 f1			.pastdmark: pop af  
2185			endm  
# End of macro DMARK
2185				CALLMONITOR 
2185 cd 6f ee			call debug_vector  
2188				endm  
# End of macro CALLMONITOR
2188			endif 
2188			 
2188 cd 90 1b			call forth_push_numhl 
218b				NEXTW 
218b c3 81 1f			jp macro_next 
218e				endm 
# End of macro NEXTW
218e			.ZDUP: 
218e			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
218e 99				db WORD_SYS_CORE+OPCODE_ZDUP             
218f c6 21			dw .SWAP            
2191 05				db 4 + 1 
2192 .. 00			db "?DUP",0              
2197				endm 
# End of macro CWHEAD
2197			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
2197			 
2197				if DEBUG_FORTH_WORDS_KEY 
2197					DMARK "qDU" 
2197 f5				push af  
2198 3a ac 21			ld a, (.dmark)  
219b 32 65 ee			ld (debug_mark),a  
219e 3a ad 21			ld a, (.dmark+1)  
21a1 32 66 ee			ld (debug_mark+1),a  
21a4 3a ae 21			ld a, (.dmark+2)  
21a7 32 67 ee			ld (debug_mark+2),a  
21aa 18 03			jr .pastdmark  
21ac ..			.dmark: db "qDU"  
21af f1			.pastdmark: pop af  
21b0			endm  
# End of macro DMARK
21b0					CALLMONITOR 
21b0 cd 6f ee			call debug_vector  
21b3				endm  
# End of macro CALLMONITOR
21b3				endif 
21b3				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21b3 cd 95 1d			call macro_dsp_valuehl 
21b6				endm 
# End of macro FORTH_DSP_VALUEHL
21b6			 
21b6 e5				push hl 
21b7			 
21b7				; is it a zero? 
21b7			 
21b7 3e 00			ld a, 0 
21b9 84				add h 
21ba 85				add l 
21bb			 
21bb e1				pop hl 
21bc			 
21bc fe 00			cp 0 
21be 28 03			jr z, .dup2orig 
21c0			 
21c0			 
21c0 cd 90 1b			call forth_push_numhl 
21c3			 
21c3			 
21c3			; TODO add floating point number detection 
21c3			 
21c3			.dup2orig: 
21c3			 
21c3				NEXTW 
21c3 c3 81 1f			jp macro_next 
21c6				endm 
# End of macro NEXTW
21c6			.SWAP: 
21c6			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
21c6 18				db WORD_SYS_CORE+OPCODE_SWAP             
21c7 1a 22			dw .COLN            
21c9 05				db 4 + 1 
21ca .. 00			db "SWAP",0              
21cf				endm 
# End of macro CWHEAD
21cf			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
21cf				if DEBUG_FORTH_WORDS_KEY 
21cf					DMARK "SWP" 
21cf f5				push af  
21d0 3a e4 21			ld a, (.dmark)  
21d3 32 65 ee			ld (debug_mark),a  
21d6 3a e5 21			ld a, (.dmark+1)  
21d9 32 66 ee			ld (debug_mark+1),a  
21dc 3a e6 21			ld a, (.dmark+2)  
21df 32 67 ee			ld (debug_mark+2),a  
21e2 18 03			jr .pastdmark  
21e4 ..			.dmark: db "SWP"  
21e7 f1			.pastdmark: pop af  
21e8			endm  
# End of macro DMARK
21e8					CALLMONITOR 
21e8 cd 6f ee			call debug_vector  
21eb				endm  
# End of macro CALLMONITOR
21eb				endif 
21eb			 
21eb			; DONE Use os stack swap memory 
21eb			 
21eb				FORTH_DSP_PTR 0     ; TOS 
21eb 2a e8 e9			ld hl,(cli_data_sp) 
21ee 11 00 00			ld de, 0 * 3 
21f1 ed 52			sbc hl, de 
21f3				endm 
# End of macro FORTH_DSP_PTR
21f3 cd cd 1e			call hltostack1 
21f6			  
21f6				FORTH_DSP_PTR 1     ; TOS 
21f6 2a e8 e9			ld hl,(cli_data_sp) 
21f9 11 03 00			ld de, 1 * 3 
21fc ed 52			sbc hl, de 
21fe				endm 
# End of macro FORTH_DSP_PTR
21fe cd d3 1e			call hltostack2 
2201			 
2201				FORTH_DSP_PTR 0     ; TOS 
2201 2a e8 e9			ld hl,(cli_data_sp) 
2204 11 00 00			ld de, 0 * 3 
2207 ed 52			sbc hl, de 
2209				endm 
# End of macro FORTH_DSP_PTR
2209 cd eb 1e			call hlfromstack2 
220c			 
220c				FORTH_DSP_PTR 1     ; TOS 
220c 2a e8 e9			ld hl,(cli_data_sp) 
220f 11 03 00			ld de, 1 * 3 
2212 ed 52			sbc hl, de 
2214				endm 
# End of macro FORTH_DSP_PTR
2214 cd e5 1e			call hlfromstack1 
2217			;	FORTH_DSP_VALUEHL 
2217			;	push hl     ; w2 
2217			; 
2217			;	FORTH_DSP_POP 
2217			; 
2217			;	FORTH_DSP_VALUEHL 
2217			; 
2217			;	FORTH_DSP_POP 
2217			; 
2217			;	pop de     ; w2	, hl = w1 
2217			; 
2217			;	ex de, hl 
2217			;	push de 
2217			; 
2217			;	call forth_push_numhl 
2217			; 
2217			;	pop hl 
2217			; 
2217			;	call forth_push_numhl 
2217				 
2217			 
2217				NEXTW 
2217 c3 81 1f			jp macro_next 
221a				endm 
# End of macro NEXTW
221a			.COLN: 
221a			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
221a 19				db WORD_SYS_CORE+OPCODE_COLN             
221b a6 23			dw .SCOLN            
221d 02				db 1 + 1 
221e .. 00			db ":",0              
2220				endm 
# End of macro CWHEAD
2220			; | : ( -- )         Create new word | DONE 
2220			 
2220				if DEBUG_FORTH_WORDS_KEY 
2220					DMARK "CLN" 
2220 f5				push af  
2221 3a 35 22			ld a, (.dmark)  
2224 32 65 ee			ld (debug_mark),a  
2227 3a 36 22			ld a, (.dmark+1)  
222a 32 66 ee			ld (debug_mark+1),a  
222d 3a 37 22			ld a, (.dmark+2)  
2230 32 67 ee			ld (debug_mark+2),a  
2233 18 03			jr .pastdmark  
2235 ..			.dmark: db "CLN"  
2238 f1			.pastdmark: pop af  
2239			endm  
# End of macro DMARK
2239					CALLMONITOR 
2239 cd 6f ee			call debug_vector  
223c				endm  
# End of macro CALLMONITOR
223c				endif 
223c			STACKFRAME OFF $8efe $989f 
223c				if DEBUG_STACK_IMB 
223c					if OFF 
223c						exx 
223c						ld de, $8efe 
223c						ld a, d 
223c						ld hl, curframe 
223c						call hexout 
223c						ld a, e 
223c						ld hl, curframe+2 
223c						call hexout 
223c						ld hl, $8efe 
223c						push hl 
223c						ld hl, $989f 
223c						push hl 
223c						exx 
223c					endif 
223c				endif 
223c			endm 
# End of macro STACKFRAME
223c			; get parser buffer length  of new word 
223c			 
223c			 
223c			 
223c				; move tok past this to start of name defintition 
223c				; TODO get word to define 
223c				; TODO Move past word token 
223c				; TODO get length of string up to the ';' 
223c			 
223c 2a bc e5		ld hl, (os_tok_ptr) 
223f 23			inc hl 
2240 23			inc hl 
2241			 
2241 3e 3b		ld a, ';' 
2243 cd 66 11		call strlent 
2246			 
2246 7d			ld a,l 
2247 32 ab e2		ld (os_new_parse_len), a 
224a			 
224a			 
224a			if DEBUG_FORTH_UWORD 
224a ed 5b bc e5	ld de, (os_tok_ptr) 
224e					DMARK ":01" 
224e f5				push af  
224f 3a 63 22			ld a, (.dmark)  
2252 32 65 ee			ld (debug_mark),a  
2255 3a 64 22			ld a, (.dmark+1)  
2258 32 66 ee			ld (debug_mark+1),a  
225b 3a 65 22			ld a, (.dmark+2)  
225e 32 67 ee			ld (debug_mark+2),a  
2261 18 03			jr .pastdmark  
2263 ..			.dmark: db ":01"  
2266 f1			.pastdmark: pop af  
2267			endm  
# End of macro DMARK
2267			CALLMONITOR 
2267 cd 6f ee			call debug_vector  
226a				endm  
# End of macro CALLMONITOR
226a			endif 
226a			 
226a			; 
226a			;  new word memory layout: 
226a			;  
226a			;    : adg 6666 ;  
226a			; 
226a			;    db   1     ; user defined word  
226a 23			inc hl    
226b			;    dw   sysdict 
226b 23			inc hl 
226c 23			inc hl 
226d			;    db <word len>+1 (for null) 
226d 23			inc hl 
226e			;    db .... <word> 
226e			; 
226e			 
226e 23			inc hl    ; some extras for the word preamble before the above 
226f 23			inc hl 
2270 23			inc hl 
2271 23			inc hl 
2272 23			inc hl 
2273 23			inc hl 
2274 23			inc hl  
2275 23			inc hl 
2276 23			inc hl 
2277 23			inc hl 
2278 23			inc hl 
2279 23			inc hl 
227a 23			inc hl 
227b 23			inc hl     ; TODO how many do we really need?     maybe only 6 
227c			;       exec word buffer 
227c			;	<ptr word>   
227c 23			inc hl 
227d 23			inc hl 
227e			;       <word list><null term> 7F final term 
227e			 
227e			 
227e			if DEBUG_FORTH_UWORD 
227e					DMARK ":02" 
227e f5				push af  
227f 3a 93 22			ld a, (.dmark)  
2282 32 65 ee			ld (debug_mark),a  
2285 3a 94 22			ld a, (.dmark+1)  
2288 32 66 ee			ld (debug_mark+1),a  
228b 3a 95 22			ld a, (.dmark+2)  
228e 32 67 ee			ld (debug_mark+2),a  
2291 18 03			jr .pastdmark  
2293 ..			.dmark: db ":02"  
2296 f1			.pastdmark: pop af  
2297			endm  
# End of macro DMARK
2297			CALLMONITOR 
2297 cd 6f ee			call debug_vector  
229a				endm  
# End of macro CALLMONITOR
229a			endif 
229a			 
229a			 
229a				; malloc the size 
229a			 
229a cd d0 11			call malloc 
229d 22 ad e2			ld (os_new_malloc), hl     ; save malloc start 
22a0			 
22a0			;    db   1     ; user defined word  
22a0 3e 01			ld a, WORD_SYS_UWORD  
22a2 77				ld (hl), a 
22a3			 
22a3 23			inc hl    
22a4			;    dw   sysdict 
22a4 11 d9 20		ld de, sysdict       ; continue on with the scan to the system dict 
22a7 73			ld (hl), e 
22a8 23			inc hl 
22a9 72			ld (hl), d 
22aa 23			inc hl 
22ab			 
22ab			 
22ab			;    Setup dict word 
22ab			 
22ab 23			inc hl 
22ac 22 a7 e2		ld (os_new_work_ptr), hl     ; save start of dict word  
22af			 
22af			; 1. get length of dict word 
22af			 
22af			 
22af 2a bc e5		ld hl, (os_tok_ptr) 
22b2 23			inc hl 
22b3 23			inc hl    ; position to start of dict word 
22b4 3e 00		ld a, 0 
22b6 cd 66 11		call strlent 
22b9			 
22b9			 
22b9 23			inc hl    ; to include null??? 
22ba			 
22ba			; write length of dict word 
22ba			 
22ba ed 5b a7 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
22be 1b			dec de 
22bf eb			ex de, hl 
22c0 73			ld (hl), e 
22c1 eb			ex de, hl 
22c2			 
22c2			 
22c2			 
22c2			; copy  
22c2 4d			ld c, l 
22c3 06 00		ld b, 0 
22c5 ed 5b a7 e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
22c9 2a bc e5		ld hl, (os_tok_ptr) 
22cc 23			inc hl 
22cd 23			inc hl    ; position to start of dict word 
22ce			 
22ce			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
22ce			 
22ce			; TODO need to convert word to upper case 
22ce			 
22ce			ucasetok:	 
22ce 7e			ld a,(hl) 
22cf cd 52 11		call toUpper 
22d2 77			ld (hl),a 
22d3 ed a0		ldi 
22d5 f2 ce 22		jp p, ucasetok 
22d8			 
22d8			 
22d8			 
22d8			; de now points to start of where the word body code should be placed 
22d8 ed 53 a7 e2	ld (os_new_work_ptr), de 
22dc			; hl now points to the words to throw at forthexec which needs to be copied 
22dc 22 a5 e2		ld (os_new_src_ptr), hl 
22df			 
22df			; TODO add 'call to forthexec' 
22df			 
22df			if DEBUG_FORTH_UWORD 
22df c5			push bc 
22e0 ed 4b ad e2	ld bc, (os_new_malloc) 
22e4					DMARK ":0x" 
22e4 f5				push af  
22e5 3a f9 22			ld a, (.dmark)  
22e8 32 65 ee			ld (debug_mark),a  
22eb 3a fa 22			ld a, (.dmark+1)  
22ee 32 66 ee			ld (debug_mark+1),a  
22f1 3a fb 22			ld a, (.dmark+2)  
22f4 32 67 ee			ld (debug_mark+2),a  
22f7 18 03			jr .pastdmark  
22f9 ..			.dmark: db ":0x"  
22fc f1			.pastdmark: pop af  
22fd			endm  
# End of macro DMARK
22fd			CALLMONITOR 
22fd cd 6f ee			call debug_vector  
2300				endm  
# End of macro CALLMONITOR
2300 c1			pop bc 
2301			endif 
2301			 
2301			 
2301			; create word preamble which should be: 
2301			 
2301			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2301			 
2301			;    ld hl, <word code> 
2301			;    jp user_exec 
2301			;    <word code bytes> 
2301			 
2301			 
2301			;	inc de     ; TODO ??? or are we already past the word's null 
2301 eb			ex de, hl 
2302			 
2302 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2304			 
2304 23			inc hl 
2305 22 a1 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2308 23			inc hl 
2309			 
2309 23			inc hl 
230a 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
230c			 
230c 01 ab 4c		ld bc, user_exec 
230f 23			inc hl 
2310 71			ld (hl), c     ; poke address of user_exec 
2311 23			inc hl 
2312 70			ld (hl), b     
2313			; 
2313			;	inc hl 
2313			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2313			; 
2313			; 
2313			;	ld bc, macro_forth_rsp_next 
2313			;	inc hl 
2313			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2313			;	inc hl 
2313			;	ld (hl), b     
2313			; 
2313			;	inc hl 
2313			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2313			; 
2313			; 
2313			;	inc hl 
2313			;	ld bc, forthexec 
2313			;	ld (hl), c     ; poke address of forthexec 
2313			;	inc hl 
2313			;	ld (hl), b      
2313			; 
2313			;	inc hl 
2313			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2313			; 
2313			;	ld bc, user_dict_next 
2313			;	inc hl 
2313			;	ld (hl), c     ; poke address of forthexec 
2313			;	inc hl 
2313			;	ld (hl), b      
2313			 
2313			; hl is now where we need to copy the word byte data to save this 
2313			 
2313 23			inc hl 
2314 22 a3 e2		ld (os_new_exec), hl 
2317			 
2317			; copy definition 
2317			 
2317 eb			ex de, hl 
2318			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2318			;	inc de    ; skip the PC for this parse 
2318 3a ab e2		ld a, (os_new_parse_len) 
231b 4f			ld c, a 
231c 06 00		ld b, 0 
231e ed b0		ldir		 ; copy defintion 
2320			 
2320			 
2320			; poke the address of where the new word bytes live for forthexec 
2320			 
2320 2a a1 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2323			 
2323 ed 5b a3 e2	ld de, (os_new_exec)      
2327			 
2327 73			ld (hl), e 
2328 23			inc hl 
2329 72			ld (hl), d 
232a			 
232a				; TODO copy last user dict word next link to this word 
232a				; TODO update last user dict word to point to this word 
232a			; 
232a			; hl f923 de 812a ; bc 811a 
232a			 
232a			if DEBUG_FORTH_UWORD 
232a c5			push bc 
232b ed 4b ad e2	ld bc, (os_new_malloc) 
232f					DMARK ":0A" 
232f f5				push af  
2330 3a 44 23			ld a, (.dmark)  
2333 32 65 ee			ld (debug_mark),a  
2336 3a 45 23			ld a, (.dmark+1)  
2339 32 66 ee			ld (debug_mark+1),a  
233c 3a 46 23			ld a, (.dmark+2)  
233f 32 67 ee			ld (debug_mark+2),a  
2342 18 03			jr .pastdmark  
2344 ..			.dmark: db ":0A"  
2347 f1			.pastdmark: pop af  
2348			endm  
# End of macro DMARK
2348			CALLMONITOR 
2348 cd 6f ee			call debug_vector  
234b				endm  
# End of macro CALLMONITOR
234b c1			pop bc 
234c			endif 
234c			if DEBUG_FORTH_UWORD 
234c c5			push bc 
234d ed 4b ad e2	ld bc, (os_new_malloc) 
2351 03			inc bc 
2352 03			inc bc 
2353 03			inc bc 
2354 03			inc bc 
2355 03			inc bc 
2356 03			inc bc 
2357 03			inc bc 
2358 03			inc bc 
2359			 
2359					DMARK ":0B" 
2359 f5				push af  
235a 3a 6e 23			ld a, (.dmark)  
235d 32 65 ee			ld (debug_mark),a  
2360 3a 6f 23			ld a, (.dmark+1)  
2363 32 66 ee			ld (debug_mark+1),a  
2366 3a 70 23			ld a, (.dmark+2)  
2369 32 67 ee			ld (debug_mark+2),a  
236c 18 03			jr .pastdmark  
236e ..			.dmark: db ":0B"  
2371 f1			.pastdmark: pop af  
2372			endm  
# End of macro DMARK
2372			CALLMONITOR 
2372 cd 6f ee			call debug_vector  
2375				endm  
# End of macro CALLMONITOR
2375 c1			pop bc 
2376			endif 
2376			 
2376			; update word dict linked list for new word 
2376			 
2376			 
2376 2a b8 e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2379 23			inc hl     ; move to next work linked list ptr 
237a			 
237a ed 5b ad e2	ld de, (os_new_malloc)		 ; new next word 
237e 73			ld (hl), e 
237f 23			inc hl 
2380 72			ld (hl), d 
2381			 
2381			if DEBUG_FORTH_UWORD 
2381 ed 4b b8 e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2385			endif 
2385			 
2385 ed 53 b8 e5	ld (os_last_new_uword), de      ; update last new uword ptr 
2389			 
2389			 
2389			if DEBUG_FORTH_UWORD 
2389					DMARK ":0+" 
2389 f5				push af  
238a 3a 9e 23			ld a, (.dmark)  
238d 32 65 ee			ld (debug_mark),a  
2390 3a 9f 23			ld a, (.dmark+1)  
2393 32 66 ee			ld (debug_mark+1),a  
2396 3a a0 23			ld a, (.dmark+2)  
2399 32 67 ee			ld (debug_mark+2),a  
239c 18 03			jr .pastdmark  
239e ..			.dmark: db ":0+"  
23a1 f1			.pastdmark: pop af  
23a2			endm  
# End of macro DMARK
23a2			CALLMONITOR 
23a2 cd 6f ee			call debug_vector  
23a5				endm  
# End of macro CALLMONITOR
23a5			endif 
23a5			 
23a5			STACKFRAMECHK OFF $8efe $989f 
23a5				if DEBUG_STACK_IMB 
23a5					if OFF 
23a5						exx 
23a5						ld hl, $989f 
23a5						pop de   ; $989f 
23a5						call cmp16 
23a5						jr nz, .spnosame 
23a5						ld hl, $8efe 
23a5						pop de   ; $8efe 
23a5						call cmp16 
23a5						jr z, .spfrsame 
23a5						.spnosame: call showsperror 
23a5						.spfrsame: nop 
23a5						exx 
23a5					endif 
23a5				endif 
23a5			endm 
# End of macro STACKFRAMECHK
23a5			 
23a5 c9			ret    ; dont process any remaining parser tokens as they form new word 
23a6			 
23a6			 
23a6			 
23a6			 
23a6			;		NEXT 
23a6			.SCOLN: 
23a6			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
23a6 06			db OPCODE_SCOLN 
23a7 f2 23		dw .DROP 
23a9 02			db 2 
23aa .. 00		db ";",0           
23ac			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
23ac				if DEBUG_FORTH_WORDS_KEY 
23ac					DMARK "SCN" 
23ac f5				push af  
23ad 3a c1 23			ld a, (.dmark)  
23b0 32 65 ee			ld (debug_mark),a  
23b3 3a c2 23			ld a, (.dmark+1)  
23b6 32 66 ee			ld (debug_mark+1),a  
23b9 3a c3 23			ld a, (.dmark+2)  
23bc 32 67 ee			ld (debug_mark+2),a  
23bf 18 03			jr .pastdmark  
23c1 ..			.dmark: db "SCN"  
23c4 f1			.pastdmark: pop af  
23c5			endm  
# End of macro DMARK
23c5					CALLMONITOR 
23c5 cd 6f ee			call debug_vector  
23c8				endm  
# End of macro CALLMONITOR
23c8				endif 
23c8				FORTH_RSP_TOS 
23c8 cd 4e 1b			call macro_forth_rsp_tos 
23cb				endm 
# End of macro FORTH_RSP_TOS
23cb e5				push hl 
23cc				FORTH_RSP_POP 
23cc cd 58 1b			call macro_forth_rsp_pop 
23cf				endm 
# End of macro FORTH_RSP_POP
23cf e1				pop hl 
23d0			;		ex de,hl 
23d0 22 bc e5			ld (os_tok_ptr),hl 
23d3			 
23d3			if DEBUG_FORTH_UWORD 
23d3					DMARK "SCL" 
23d3 f5				push af  
23d4 3a e8 23			ld a, (.dmark)  
23d7 32 65 ee			ld (debug_mark),a  
23da 3a e9 23			ld a, (.dmark+1)  
23dd 32 66 ee			ld (debug_mark+1),a  
23e0 3a ea 23			ld a, (.dmark+2)  
23e3 32 67 ee			ld (debug_mark+2),a  
23e6 18 03			jr .pastdmark  
23e8 ..			.dmark: db "SCL"  
23eb f1			.pastdmark: pop af  
23ec			endm  
# End of macro DMARK
23ec			CALLMONITOR 
23ec cd 6f ee			call debug_vector  
23ef				endm  
# End of macro CALLMONITOR
23ef			endif 
23ef				NEXTW 
23ef c3 81 1f			jp macro_next 
23f2				endm 
# End of macro NEXTW
23f2			 
23f2			.DROP: 
23f2			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
23f2 1b				db WORD_SYS_CORE+OPCODE_DROP             
23f3 1d 24			dw .DUP2            
23f5 05				db 4 + 1 
23f6 .. 00			db "DROP",0              
23fb				endm 
# End of macro CWHEAD
23fb			; | DROP ( w -- )   drop the TOS item   | DONE 
23fb				if DEBUG_FORTH_WORDS_KEY 
23fb					DMARK "DRP" 
23fb f5				push af  
23fc 3a 10 24			ld a, (.dmark)  
23ff 32 65 ee			ld (debug_mark),a  
2402 3a 11 24			ld a, (.dmark+1)  
2405 32 66 ee			ld (debug_mark+1),a  
2408 3a 12 24			ld a, (.dmark+2)  
240b 32 67 ee			ld (debug_mark+2),a  
240e 18 03			jr .pastdmark  
2410 ..			.dmark: db "DRP"  
2413 f1			.pastdmark: pop af  
2414			endm  
# End of macro DMARK
2414					CALLMONITOR 
2414 cd 6f ee			call debug_vector  
2417				endm  
# End of macro CALLMONITOR
2417				endif 
2417				FORTH_DSP_POP 
2417 cd 4d 1e			call macro_forth_dsp_pop 
241a				endm 
# End of macro FORTH_DSP_POP
241a				NEXTW 
241a c3 81 1f			jp macro_next 
241d				endm 
# End of macro NEXTW
241d			.DUP2: 
241d			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
241d 1c				db WORD_SYS_CORE+OPCODE_DUP2             
241e 62 24			dw .DROP2            
2420 05				db 4 + 1 
2421 .. 00			db "2DUP",0              
2426				endm 
# End of macro CWHEAD
2426			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
2426				if DEBUG_FORTH_WORDS_KEY 
2426					DMARK "2DU" 
2426 f5				push af  
2427 3a 3b 24			ld a, (.dmark)  
242a 32 65 ee			ld (debug_mark),a  
242d 3a 3c 24			ld a, (.dmark+1)  
2430 32 66 ee			ld (debug_mark+1),a  
2433 3a 3d 24			ld a, (.dmark+2)  
2436 32 67 ee			ld (debug_mark+2),a  
2439 18 03			jr .pastdmark  
243b ..			.dmark: db "2DU"  
243e f1			.pastdmark: pop af  
243f			endm  
# End of macro DMARK
243f					CALLMONITOR 
243f cd 6f ee			call debug_vector  
2442				endm  
# End of macro CALLMONITOR
2442				endif 
2442				FORTH_DSP_VALUEHL 
2442 cd 95 1d			call macro_dsp_valuehl 
2445				endm 
# End of macro FORTH_DSP_VALUEHL
2445 e5				push hl      ; 2 
2446			 
2446				FORTH_DSP_POP 
2446 cd 4d 1e			call macro_forth_dsp_pop 
2449				endm 
# End of macro FORTH_DSP_POP
2449				 
2449				FORTH_DSP_VALUEHL 
2449 cd 95 1d			call macro_dsp_valuehl 
244c				endm 
# End of macro FORTH_DSP_VALUEHL
244c			;		push hl      ; 1 
244c			 
244c				FORTH_DSP_POP 
244c cd 4d 1e			call macro_forth_dsp_pop 
244f				endm 
# End of macro FORTH_DSP_POP
244f			 
244f			;		pop hl       ; 1 
244f d1				pop de       ; 2 
2450			 
2450 cd 90 1b			call forth_push_numhl 
2453 eb				ex de, hl 
2454 cd 90 1b			call forth_push_numhl 
2457			 
2457				 
2457 eb				ex de, hl 
2458			 
2458 cd 90 1b			call forth_push_numhl 
245b eb				ex de, hl 
245c cd 90 1b			call forth_push_numhl 
245f			 
245f			 
245f				NEXTW 
245f c3 81 1f			jp macro_next 
2462				endm 
# End of macro NEXTW
2462			.DROP2: 
2462			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2462 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2463 91 24			dw .SWAP2            
2465 06				db 5 + 1 
2466 .. 00			db "2DROP",0              
246c				endm 
# End of macro CWHEAD
246c			; | 2DROP ( w w -- )    Double drop | DONE 
246c				if DEBUG_FORTH_WORDS_KEY 
246c					DMARK "2DR" 
246c f5				push af  
246d 3a 81 24			ld a, (.dmark)  
2470 32 65 ee			ld (debug_mark),a  
2473 3a 82 24			ld a, (.dmark+1)  
2476 32 66 ee			ld (debug_mark+1),a  
2479 3a 83 24			ld a, (.dmark+2)  
247c 32 67 ee			ld (debug_mark+2),a  
247f 18 03			jr .pastdmark  
2481 ..			.dmark: db "2DR"  
2484 f1			.pastdmark: pop af  
2485			endm  
# End of macro DMARK
2485					CALLMONITOR 
2485 cd 6f ee			call debug_vector  
2488				endm  
# End of macro CALLMONITOR
2488				endif 
2488				FORTH_DSP_POP 
2488 cd 4d 1e			call macro_forth_dsp_pop 
248b				endm 
# End of macro FORTH_DSP_POP
248b				FORTH_DSP_POP 
248b cd 4d 1e			call macro_forth_dsp_pop 
248e				endm 
# End of macro FORTH_DSP_POP
248e				NEXTW 
248e c3 81 1f			jp macro_next 
2491				endm 
# End of macro NEXTW
2491			.SWAP2: 
2491			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2491 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2492 ba 24			dw .AT            
2494 06				db 5 + 1 
2495 .. 00			db "2SWAP",0              
249b				endm 
# End of macro CWHEAD
249b			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
249b				if DEBUG_FORTH_WORDS_KEY 
249b					DMARK "2SW" 
249b f5				push af  
249c 3a b0 24			ld a, (.dmark)  
249f 32 65 ee			ld (debug_mark),a  
24a2 3a b1 24			ld a, (.dmark+1)  
24a5 32 66 ee			ld (debug_mark+1),a  
24a8 3a b2 24			ld a, (.dmark+2)  
24ab 32 67 ee			ld (debug_mark+2),a  
24ae 18 03			jr .pastdmark  
24b0 ..			.dmark: db "2SW"  
24b3 f1			.pastdmark: pop af  
24b4			endm  
# End of macro DMARK
24b4					CALLMONITOR 
24b4 cd 6f ee			call debug_vector  
24b7				endm  
# End of macro CALLMONITOR
24b7				endif 
24b7			; TODO Use os stack swap memory 
24b7				NEXTW 
24b7 c3 81 1f			jp macro_next 
24ba				endm 
# End of macro NEXTW
24ba			.AT: 
24ba			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
24ba 1f				db WORD_SYS_CORE+OPCODE_AT             
24bb ec 24			dw .CAT            
24bd 02				db 1 + 1 
24be .. 00			db "@",0              
24c0				endm 
# End of macro CWHEAD
24c0			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
24c0			 
24c0				if DEBUG_FORTH_WORDS_KEY 
24c0					DMARK "AT." 
24c0 f5				push af  
24c1 3a d5 24			ld a, (.dmark)  
24c4 32 65 ee			ld (debug_mark),a  
24c7 3a d6 24			ld a, (.dmark+1)  
24ca 32 66 ee			ld (debug_mark+1),a  
24cd 3a d7 24			ld a, (.dmark+2)  
24d0 32 67 ee			ld (debug_mark+2),a  
24d3 18 03			jr .pastdmark  
24d5 ..			.dmark: db "AT."  
24d8 f1			.pastdmark: pop af  
24d9			endm  
# End of macro DMARK
24d9					CALLMONITOR 
24d9 cd 6f ee			call debug_vector  
24dc				endm  
# End of macro CALLMONITOR
24dc				endif 
24dc			.getbyteat:	 
24dc				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24dc cd 95 1d			call macro_dsp_valuehl 
24df				endm 
# End of macro FORTH_DSP_VALUEHL
24df				 
24df			;		push hl 
24df			 
24df				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24df cd 4d 1e			call macro_forth_dsp_pop 
24e2				endm 
# End of macro FORTH_DSP_POP
24e2			 
24e2			;		pop hl 
24e2			 
24e2 7e				ld a, (hl) 
24e3			 
24e3 6f				ld l, a 
24e4 26 00			ld h, 0 
24e6 cd 90 1b			call forth_push_numhl 
24e9			 
24e9				NEXTW 
24e9 c3 81 1f			jp macro_next 
24ec				endm 
# End of macro NEXTW
24ec			.CAT: 
24ec			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
24ec 20				db WORD_SYS_CORE+OPCODE_CAT             
24ed 15 25			dw .BANG            
24ef 03				db 2 + 1 
24f0 .. 00			db "C@",0              
24f3				endm 
# End of macro CWHEAD
24f3			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
24f3				if DEBUG_FORTH_WORDS_KEY 
24f3					DMARK "CAA" 
24f3 f5				push af  
24f4 3a 08 25			ld a, (.dmark)  
24f7 32 65 ee			ld (debug_mark),a  
24fa 3a 09 25			ld a, (.dmark+1)  
24fd 32 66 ee			ld (debug_mark+1),a  
2500 3a 0a 25			ld a, (.dmark+2)  
2503 32 67 ee			ld (debug_mark+2),a  
2506 18 03			jr .pastdmark  
2508 ..			.dmark: db "CAA"  
250b f1			.pastdmark: pop af  
250c			endm  
# End of macro DMARK
250c					CALLMONITOR 
250c cd 6f ee			call debug_vector  
250f				endm  
# End of macro CALLMONITOR
250f				endif 
250f c3 dc 24			jp .getbyteat 
2512				NEXTW 
2512 c3 81 1f			jp macro_next 
2515				endm 
# End of macro NEXTW
2515			.BANG: 
2515			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2515 21				db WORD_SYS_CORE+OPCODE_BANG             
2516 4b 25			dw .CBANG            
2518 02				db 1 + 1 
2519 .. 00			db "!",0              
251b				endm 
# End of macro CWHEAD
251b			; | ! ( x w -- ) Store x at address w      | DONE 
251b				if DEBUG_FORTH_WORDS_KEY 
251b					DMARK "BNG" 
251b f5				push af  
251c 3a 30 25			ld a, (.dmark)  
251f 32 65 ee			ld (debug_mark),a  
2522 3a 31 25			ld a, (.dmark+1)  
2525 32 66 ee			ld (debug_mark+1),a  
2528 3a 32 25			ld a, (.dmark+2)  
252b 32 67 ee			ld (debug_mark+2),a  
252e 18 03			jr .pastdmark  
2530 ..			.dmark: db "BNG"  
2533 f1			.pastdmark: pop af  
2534			endm  
# End of macro DMARK
2534					CALLMONITOR 
2534 cd 6f ee			call debug_vector  
2537				endm  
# End of macro CALLMONITOR
2537				endif 
2537			 
2537			.storebyteat:		 
2537				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2537 cd 95 1d			call macro_dsp_valuehl 
253a				endm 
# End of macro FORTH_DSP_VALUEHL
253a				 
253a e5				push hl 
253b			 
253b				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
253b cd 4d 1e			call macro_forth_dsp_pop 
253e				endm 
# End of macro FORTH_DSP_POP
253e			 
253e				; get byte to poke 
253e			 
253e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
253e cd 95 1d			call macro_dsp_valuehl 
2541				endm 
# End of macro FORTH_DSP_VALUEHL
2541 e5				push hl 
2542			 
2542			 
2542				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2542 cd 4d 1e			call macro_forth_dsp_pop 
2545				endm 
# End of macro FORTH_DSP_POP
2545			 
2545			 
2545 d1				pop de 
2546 e1				pop hl 
2547			 
2547 73				ld (hl),e 
2548			 
2548			 
2548				NEXTW 
2548 c3 81 1f			jp macro_next 
254b				endm 
# End of macro NEXTW
254b			.CBANG: 
254b			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
254b 22				db WORD_SYS_CORE+OPCODE_CBANG             
254c 74 25			dw .SCALL            
254e 03				db 2 + 1 
254f .. 00			db "C!",0              
2552				endm 
# End of macro CWHEAD
2552			; | C!  ( x w -- ) Store x at address w  | DONE 
2552				if DEBUG_FORTH_WORDS_KEY 
2552					DMARK "CBA" 
2552 f5				push af  
2553 3a 67 25			ld a, (.dmark)  
2556 32 65 ee			ld (debug_mark),a  
2559 3a 68 25			ld a, (.dmark+1)  
255c 32 66 ee			ld (debug_mark+1),a  
255f 3a 69 25			ld a, (.dmark+2)  
2562 32 67 ee			ld (debug_mark+2),a  
2565 18 03			jr .pastdmark  
2567 ..			.dmark: db "CBA"  
256a f1			.pastdmark: pop af  
256b			endm  
# End of macro DMARK
256b					CALLMONITOR 
256b cd 6f ee			call debug_vector  
256e				endm  
# End of macro CALLMONITOR
256e				endif 
256e c3 37 25			jp .storebyteat 
2571				NEXTW 
2571 c3 81 1f			jp macro_next 
2574				endm 
# End of macro NEXTW
2574			.SCALL: 
2574			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2574 23				db WORD_SYS_CORE+OPCODE_SCALL             
2575 a8 25			dw .DEPTH            
2577 05				db 4 + 1 
2578 .. 00			db "CALL",0              
257d				endm 
# End of macro CWHEAD
257d			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
257d				if DEBUG_FORTH_WORDS_KEY 
257d					DMARK "CLL" 
257d f5				push af  
257e 3a 92 25			ld a, (.dmark)  
2581 32 65 ee			ld (debug_mark),a  
2584 3a 93 25			ld a, (.dmark+1)  
2587 32 66 ee			ld (debug_mark+1),a  
258a 3a 94 25			ld a, (.dmark+2)  
258d 32 67 ee			ld (debug_mark+2),a  
2590 18 03			jr .pastdmark  
2592 ..			.dmark: db "CLL"  
2595 f1			.pastdmark: pop af  
2596			endm  
# End of macro DMARK
2596					CALLMONITOR 
2596 cd 6f ee			call debug_vector  
2599				endm  
# End of macro CALLMONITOR
2599				endif 
2599			 
2599				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2599 cd 95 1d			call macro_dsp_valuehl 
259c				endm 
# End of macro FORTH_DSP_VALUEHL
259c			 
259c			;		push hl 
259c			 
259c				; destroy value TOS 
259c			 
259c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
259c cd 4d 1e			call macro_forth_dsp_pop 
259f				endm 
# End of macro FORTH_DSP_POP
259f			 
259f					 
259f			;		pop hl 
259f			 
259f				; how to do a call with hl???? save SP? 
259f cd 25 1f			call forth_call_hl 
25a2			 
25a2			 
25a2				; TODO push value back onto stack for another op etc 
25a2			 
25a2 cd 90 1b			call forth_push_numhl 
25a5				NEXTW 
25a5 c3 81 1f			jp macro_next 
25a8				endm 
# End of macro NEXTW
25a8			.DEPTH: 
25a8			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
25a8 24				db WORD_SYS_CORE+OPCODE_DEPTH             
25a9 e5 25			dw .OVER            
25ab 06				db 5 + 1 
25ac .. 00			db "DEPTH",0              
25b2				endm 
# End of macro CWHEAD
25b2			; | DEPTH ( -- u ) Push count of stack | DONE 
25b2				; take current TOS and remove from base value div by two to get count 
25b2				if DEBUG_FORTH_WORDS_KEY 
25b2					DMARK "DEP" 
25b2 f5				push af  
25b3 3a c7 25			ld a, (.dmark)  
25b6 32 65 ee			ld (debug_mark),a  
25b9 3a c8 25			ld a, (.dmark+1)  
25bc 32 66 ee			ld (debug_mark+1),a  
25bf 3a c9 25			ld a, (.dmark+2)  
25c2 32 67 ee			ld (debug_mark+2),a  
25c5 18 03			jr .pastdmark  
25c7 ..			.dmark: db "DEP"  
25ca f1			.pastdmark: pop af  
25cb			endm  
# End of macro DMARK
25cb					CALLMONITOR 
25cb cd 6f ee			call debug_vector  
25ce				endm  
# End of macro CALLMONITOR
25ce				endif 
25ce			 
25ce			 
25ce 2a e8 e9		ld hl, (cli_data_sp) 
25d1 11 22 e8		ld de, cli_data_stack 
25d4 ed 52		sbc hl,de 
25d6			 
25d6			; div by size of stack item 
25d6			 
25d6 5d			ld e,l 
25d7 0e 03		ld c, 3 
25d9 cd 85 0d		call Div8 
25dc			 
25dc 6f			ld l,a 
25dd 26 00		ld h,0 
25df			 
25df			;srl h 
25df			;rr l 
25df			 
25df cd 90 1b			call forth_push_numhl 
25e2				NEXTW 
25e2 c3 81 1f			jp macro_next 
25e5				endm 
# End of macro NEXTW
25e5			.OVER: 
25e5			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
25e5 42				db WORD_SYS_CORE+46             
25e6 2c 26			dw .PAUSE            
25e8 05				db 4 + 1 
25e9 .. 00			db "OVER",0              
25ee				endm 
# End of macro CWHEAD
25ee			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | TOFIX 
25ee				if DEBUG_FORTH_WORDS_KEY 
25ee					DMARK "OVR" 
25ee f5				push af  
25ef 3a 03 26			ld a, (.dmark)  
25f2 32 65 ee			ld (debug_mark),a  
25f5 3a 04 26			ld a, (.dmark+1)  
25f8 32 66 ee			ld (debug_mark+1),a  
25fb 3a 05 26			ld a, (.dmark+2)  
25fe 32 67 ee			ld (debug_mark+2),a  
2601 18 03			jr .pastdmark  
2603 ..			.dmark: db "OVR"  
2606 f1			.pastdmark: pop af  
2607			endm  
# End of macro DMARK
2607					CALLMONITOR 
2607 cd 6f ee			call debug_vector  
260a				endm  
# End of macro CALLMONITOR
260a				endif 
260a			 
260a			; TODO Use os stack swap memory 
260a			 
260a				; work out what type we are looking at 
260a			 
260a				FORTH_DSP_PTR 1 
260a 2a e8 e9			ld hl,(cli_data_sp) 
260d 11 03 00			ld de, 1 * 3 
2610 ed 52			sbc hl, de 
2612				endm 
# End of macro FORTH_DSP_PTR
2612			 
2612 7e				ld a, (hl) 
2613				 
2613 f5				push af 
2614				; whatever the type lets get the pointer or word 
2614 23				inc hl 
2615			;; 
2615			 
2615				; type check now to decide on how to push  
2615			 
2615 cd 03 1f			call loadwordinhl 
2618 f1				pop af 
2619 fe 01			cp DS_TYPE_STR 
261b 28 06			jr z, .ovstr 
261d			 
261d				; we have a numeric so load the word and push 
261d			;	ld e, (hl) 
261d			;	inc hl 
261d			;	ld d, (hl) 
261d			;	ex de, hl 
261d cd 90 1b			call forth_push_numhl 
2620				NEXTW 
2620 c3 81 1f			jp macro_next 
2623				endm 
# End of macro NEXTW
2623			 
2623			.ovstr: 
2623				; ok, a string so get the pointer and push as a string 
2623			 
2623			;	call loadwordinhl 
2623 cd fe 1b			call forth_push_str 
2626				NEXTW 
2626 c3 81 1f			jp macro_next 
2629				endm 
# End of macro NEXTW
2629			 
2629			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2629			;	push hl    ; n2 
2629			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2629			; 
2629			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2629			;	push hl    ; n1 
2629			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2629			; 
2629			;	pop de     ; n1 
2629			;	pop hl     ; n2 
2629			; 
2629			;	push de 
2629			;	push hl 
2629			;	push de 
2629			 
2629				; push back  
2629			 
2629			;	pop hl 
2629			;	call forth_push_numhl 
2629			;	pop hl 
2629			;	call forth_push_numhl 
2629			;	pop hl 
2629			;	call forth_push_numhl 
2629				NEXTW 
2629 c3 81 1f			jp macro_next 
262c				endm 
# End of macro NEXTW
262c			 
262c			.PAUSE: 
262c			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
262c 43				db WORD_SYS_CORE+47             
262d 61 26			dw .PAUSES            
262f 08				db 7 + 1 
2630 .. 00			db "PAUSEMS",0              
2638				endm 
# End of macro CWHEAD
2638			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2638				if DEBUG_FORTH_WORDS_KEY 
2638					DMARK "PMS" 
2638 f5				push af  
2639 3a 4d 26			ld a, (.dmark)  
263c 32 65 ee			ld (debug_mark),a  
263f 3a 4e 26			ld a, (.dmark+1)  
2642 32 66 ee			ld (debug_mark+1),a  
2645 3a 4f 26			ld a, (.dmark+2)  
2648 32 67 ee			ld (debug_mark+2),a  
264b 18 03			jr .pastdmark  
264d ..			.dmark: db "PMS"  
2650 f1			.pastdmark: pop af  
2651			endm  
# End of macro DMARK
2651					CALLMONITOR 
2651 cd 6f ee			call debug_vector  
2654				endm  
# End of macro CALLMONITOR
2654				endif 
2654				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2654 cd 95 1d			call macro_dsp_valuehl 
2657				endm 
# End of macro FORTH_DSP_VALUEHL
2657			;		push hl    ; n2 
2657				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2657 cd 4d 1e			call macro_forth_dsp_pop 
265a				endm 
# End of macro FORTH_DSP_POP
265a			;		pop hl 
265a			 
265a 7d				ld a, l 
265b cd e5 0a			call aDelayInMS 
265e			       NEXTW 
265e c3 81 1f			jp macro_next 
2661				endm 
# End of macro NEXTW
2661			.PAUSES:  
2661			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2661 44				db WORD_SYS_CORE+48             
2662 d0 26			dw .ROT            
2664 06				db 5 + 1 
2665 .. 00			db "PAUSE",0              
266b				endm 
# End of macro CWHEAD
266b			; | PAUSE ( n -- )  Pause for n seconds | DONE 
266b				if DEBUG_FORTH_WORDS_KEY 
266b					DMARK "PAU" 
266b f5				push af  
266c 3a 80 26			ld a, (.dmark)  
266f 32 65 ee			ld (debug_mark),a  
2672 3a 81 26			ld a, (.dmark+1)  
2675 32 66 ee			ld (debug_mark+1),a  
2678 3a 82 26			ld a, (.dmark+2)  
267b 32 67 ee			ld (debug_mark+2),a  
267e 18 03			jr .pastdmark  
2680 ..			.dmark: db "PAU"  
2683 f1			.pastdmark: pop af  
2684			endm  
# End of macro DMARK
2684					CALLMONITOR 
2684 cd 6f ee			call debug_vector  
2687				endm  
# End of macro CALLMONITOR
2687				endif 
2687				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2687 cd 95 1d			call macro_dsp_valuehl 
268a				endm 
# End of macro FORTH_DSP_VALUEHL
268a			;		push hl    ; n2 
268a				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
268a cd 4d 1e			call macro_forth_dsp_pop 
268d				endm 
# End of macro FORTH_DSP_POP
268d			;		pop hl 
268d 45				ld b, l 
268e				if DEBUG_FORTH_WORDS 
268e					DMARK "PAU" 
268e f5				push af  
268f 3a a3 26			ld a, (.dmark)  
2692 32 65 ee			ld (debug_mark),a  
2695 3a a4 26			ld a, (.dmark+1)  
2698 32 66 ee			ld (debug_mark+1),a  
269b 3a a5 26			ld a, (.dmark+2)  
269e 32 67 ee			ld (debug_mark+2),a  
26a1 18 03			jr .pastdmark  
26a3 ..			.dmark: db "PAU"  
26a6 f1			.pastdmark: pop af  
26a7			endm  
# End of macro DMARK
26a7					CALLMONITOR 
26a7 cd 6f ee			call debug_vector  
26aa				endm  
# End of macro CALLMONITOR
26aa				endif 
26aa c5			.pauses1:	push bc 
26ab cd 00 0b			call delay1s 
26ae c1				pop bc 
26af				if DEBUG_FORTH_WORDS 
26af					DMARK "PA1" 
26af f5				push af  
26b0 3a c4 26			ld a, (.dmark)  
26b3 32 65 ee			ld (debug_mark),a  
26b6 3a c5 26			ld a, (.dmark+1)  
26b9 32 66 ee			ld (debug_mark+1),a  
26bc 3a c6 26			ld a, (.dmark+2)  
26bf 32 67 ee			ld (debug_mark+2),a  
26c2 18 03			jr .pastdmark  
26c4 ..			.dmark: db "PA1"  
26c7 f1			.pastdmark: pop af  
26c8			endm  
# End of macro DMARK
26c8					CALLMONITOR 
26c8 cd 6f ee			call debug_vector  
26cb				endm  
# End of macro CALLMONITOR
26cb				endif 
26cb 10 dd			djnz .pauses1 
26cd			 
26cd			       NEXTW 
26cd c3 81 1f			jp macro_next 
26d0				endm 
# End of macro NEXTW
26d0			.ROT: 
26d0			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
26d0 45				db WORD_SYS_CORE+49             
26d1 39 27			dw .UWORDS            
26d3 04				db 3 + 1 
26d4 .. 00			db "ROT",0              
26d8				endm 
# End of macro CWHEAD
26d8			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | TOFIX 
26d8				if DEBUG_FORTH_WORDS_KEY 
26d8					DMARK "ROT" 
26d8 f5				push af  
26d9 3a ed 26			ld a, (.dmark)  
26dc 32 65 ee			ld (debug_mark),a  
26df 3a ee 26			ld a, (.dmark+1)  
26e2 32 66 ee			ld (debug_mark+1),a  
26e5 3a ef 26			ld a, (.dmark+2)  
26e8 32 67 ee			ld (debug_mark+2),a  
26eb 18 03			jr .pastdmark  
26ed ..			.dmark: db "ROT"  
26f0 f1			.pastdmark: pop af  
26f1			endm  
# End of macro DMARK
26f1					CALLMONITOR 
26f1 cd 6f ee			call debug_vector  
26f4				endm  
# End of macro CALLMONITOR
26f4				endif 
26f4			 
26f4			; DONE Use os stack swap memory 
26f4			 
26f4				FORTH_DSP_PTR 0     ; u3 
26f4 2a e8 e9			ld hl,(cli_data_sp) 
26f7 11 00 00			ld de, 0 * 3 
26fa ed 52			sbc hl, de 
26fc				endm 
# End of macro FORTH_DSP_PTR
26fc cd cd 1e			call hltostack1     
26ff			  
26ff				FORTH_DSP_PTR 1     ; u2 
26ff 2a e8 e9			ld hl,(cli_data_sp) 
2702 11 03 00			ld de, 1 * 3 
2705 ed 52			sbc hl, de 
2707				endm 
# End of macro FORTH_DSP_PTR
2707 cd d3 1e			call hltostack2      
270a			 
270a				FORTH_DSP_PTR 2     ; u1 
270a 2a e8 e9			ld hl,(cli_data_sp) 
270d 11 06 00			ld de, 2 * 3 
2710 ed 52			sbc hl, de 
2712				endm 
# End of macro FORTH_DSP_PTR
2712 cd d9 1e			call hltostack3 
2715			 
2715			 
2715				FORTH_DSP_PTR 0     ;  
2715 2a e8 e9			ld hl,(cli_data_sp) 
2718 11 00 00			ld de, 0 * 3 
271b ed 52			sbc hl, de 
271d				endm 
# End of macro FORTH_DSP_PTR
271d cd f1 1e			call hlfromstack3 
2720			 
2720				FORTH_DSP_PTR 1     ; TOS 
2720 2a e8 e9			ld hl,(cli_data_sp) 
2723 11 03 00			ld de, 1 * 3 
2726 ed 52			sbc hl, de 
2728				endm 
# End of macro FORTH_DSP_PTR
2728 cd e5 1e			call hlfromstack1 
272b			 
272b				FORTH_DSP_PTR 2     ; TOS 
272b 2a e8 e9			ld hl,(cli_data_sp) 
272e 11 06 00			ld de, 2 * 3 
2731 ed 52			sbc hl, de 
2733				endm 
# End of macro FORTH_DSP_PTR
2733 cd eb 1e			call hlfromstack2 
2736			 
2736			 
2736			;	FORTH_DSP_VALUEHL 
2736			;	push hl    ; u3  
2736			; 
2736			;	FORTH_DSP_POP 
2736			; 
2736			;	FORTH_DSP_VALUEHL 
2736			;	push hl     ; u2 
2736			; 
2736			;	FORTH_DSP_POP 
2736			; 
2736			;	FORTH_DSP_VALUEHL 
2736			;	push hl     ; u1 
2736			; 
2736			;	FORTH_DSP_POP 
2736			; 
2736			;	pop bc      ; u1 
2736			;	pop hl      ; u2 
2736			;	pop de      ; u3 
2736			; 
2736			; 
2736			;	push bc 
2736			;	push de 
2736			;	push hl 
2736			; 
2736			; 
2736			;	pop hl 
2736			;	call forth_push_numhl 
2736			; 
2736			;	pop hl 
2736			;	call forth_push_numhl 
2736			; 
2736			;	pop hl 
2736			;	call forth_push_numhl 
2736				 
2736			 
2736			 
2736			 
2736			 
2736			 
2736			       NEXTW 
2736 c3 81 1f			jp macro_next 
2739				endm 
# End of macro NEXTW
2739			 
2739			.UWORDS: 
2739			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2739 50				db WORD_SYS_CORE+60             
273a fb 27			dw .BP            
273c 07				db 6 + 1 
273d .. 00			db "UWORDS",0              
2744				endm 
# End of macro CWHEAD
2744			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2744			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2744			; | | Following the count are the individual words. 
2744			; | | 
2744			; | | e.g. UWORDS 
2744			; | | BOX DIRLIST 2 
2744			; | |  
2744			; | | Can be used to save the words to storage via: 
2744			; | | UWORDS $01 DO $01 APPEND LOOP 
2744			if DEBUG_FORTH_WORDS_KEY 
2744				DMARK "UWR" 
2744 f5				push af  
2745 3a 59 27			ld a, (.dmark)  
2748 32 65 ee			ld (debug_mark),a  
274b 3a 5a 27			ld a, (.dmark+1)  
274e 32 66 ee			ld (debug_mark+1),a  
2751 3a 5b 27			ld a, (.dmark+2)  
2754 32 67 ee			ld (debug_mark+2),a  
2757 18 03			jr .pastdmark  
2759 ..			.dmark: db "UWR"  
275c f1			.pastdmark: pop af  
275d			endm  
# End of macro DMARK
275d				CALLMONITOR 
275d cd 6f ee			call debug_vector  
2760				endm  
# End of macro CALLMONITOR
2760			endif 
2760 21 12 5f			ld hl, baseram 
2763				;ld hl, baseusermem 
2763 01 00 00			ld bc, 0    ; start a counter 
2766			 
2766			; skip dict stub 
2766			 
2766 cd d2 20			call forth_tok_next 
2769			 
2769			 
2769			; while we have words to look for 
2769			 
2769 7e			.douscan:	ld a, (hl)      
276a			if DEBUG_FORTH_WORDS 
276a				DMARK "UWs" 
276a f5				push af  
276b 3a 7f 27			ld a, (.dmark)  
276e 32 65 ee			ld (debug_mark),a  
2771 3a 80 27			ld a, (.dmark+1)  
2774 32 66 ee			ld (debug_mark+1),a  
2777 3a 81 27			ld a, (.dmark+2)  
277a 32 67 ee			ld (debug_mark+2),a  
277d 18 03			jr .pastdmark  
277f ..			.dmark: db "UWs"  
2782 f1			.pastdmark: pop af  
2783			endm  
# End of macro DMARK
2783				CALLMONITOR 
2783 cd 6f ee			call debug_vector  
2786				endm  
# End of macro CALLMONITOR
2786			endif 
2786 fe 00			cp WORD_SYS_END 
2788 28 4d			jr z, .udone 
278a fe 01			cp WORD_SYS_UWORD 
278c 20 44			jr nz, .nuword 
278e			 
278e			if DEBUG_FORTH_WORDS 
278e				DMARK "UWu" 
278e f5				push af  
278f 3a a3 27			ld a, (.dmark)  
2792 32 65 ee			ld (debug_mark),a  
2795 3a a4 27			ld a, (.dmark+1)  
2798 32 66 ee			ld (debug_mark+1),a  
279b 3a a5 27			ld a, (.dmark+2)  
279e 32 67 ee			ld (debug_mark+2),a  
27a1 18 03			jr .pastdmark  
27a3 ..			.dmark: db "UWu"  
27a6 f1			.pastdmark: pop af  
27a7			endm  
# End of macro DMARK
27a7				CALLMONITOR 
27a7 cd 6f ee			call debug_vector  
27aa				endm  
# End of macro CALLMONITOR
27aa			endif 
27aa				; we have a uword so push its name to the stack 
27aa			 
27aa e5				push hl  ; save so we can move to next dict block 
27ab			 
27ab				; skip opcode 
27ab 23				inc hl  
27ac				; skip next ptr 
27ac 23				inc hl  
27ad 23				inc hl 
27ae				; skip len 
27ae 23				inc hl 
27af			if DEBUG_FORTH_WORDS 
27af				DMARK "UWt" 
27af f5				push af  
27b0 3a c4 27			ld a, (.dmark)  
27b3 32 65 ee			ld (debug_mark),a  
27b6 3a c5 27			ld a, (.dmark+1)  
27b9 32 66 ee			ld (debug_mark+1),a  
27bc 3a c6 27			ld a, (.dmark+2)  
27bf 32 67 ee			ld (debug_mark+2),a  
27c2 18 03			jr .pastdmark  
27c4 ..			.dmark: db "UWt"  
27c7 f1			.pastdmark: pop af  
27c8			endm  
# End of macro DMARK
27c8				CALLMONITOR 
27c8 cd 6f ee			call debug_vector  
27cb				endm  
# End of macro CALLMONITOR
27cb			endif 
27cb 03				inc bc 
27cc			 
27cc c5				push bc 
27cd cd fe 1b			call forth_push_str 
27d0 c1				pop bc 
27d1			 
27d1 e1				pop hl 	 
27d2			 
27d2 cd d2 20		.nuword:	call forth_tok_next 
27d5 18 92			jr .douscan  
27d7			 
27d7			.udone:		 ; push count of uwords found 
27d7 c5				push bc 
27d8 e1				pop hl 
27d9			 
27d9			if DEBUG_FORTH_WORDS 
27d9				DMARK "UWc" 
27d9 f5				push af  
27da 3a ee 27			ld a, (.dmark)  
27dd 32 65 ee			ld (debug_mark),a  
27e0 3a ef 27			ld a, (.dmark+1)  
27e3 32 66 ee			ld (debug_mark+1),a  
27e6 3a f0 27			ld a, (.dmark+2)  
27e9 32 67 ee			ld (debug_mark+2),a  
27ec 18 03			jr .pastdmark  
27ee ..			.dmark: db "UWc"  
27f1 f1			.pastdmark: pop af  
27f2			endm  
# End of macro DMARK
27f2				CALLMONITOR 
27f2 cd 6f ee			call debug_vector  
27f5				endm  
# End of macro CALLMONITOR
27f5			endif 
27f5 cd 90 1b			call forth_push_numhl 
27f8			 
27f8			 
27f8			       NEXTW 
27f8 c3 81 1f			jp macro_next 
27fb				endm 
# End of macro NEXTW
27fb			 
27fb			.BP: 
27fb			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
27fb 54				db WORD_SYS_CORE+64             
27fc 35 28			dw .MONITOR            
27fe 03				db 2 + 1 
27ff .. 00			db "BP",0              
2802				endm 
# End of macro CWHEAD
2802			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2802			; | | $00 Will enable the break points within specific code paths 
2802			; | | $01 Will disable break points 
2802			; | |  
2802			; | | By default break points are off. Either the above can be used to enable them 
2802			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2802			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2802			; | | can disable break points. Exiting will then continue boot process. 
2802				; get byte count 
2802				if DEBUG_FORTH_WORDS_KEY 
2802					DMARK "BP." 
2802 f5				push af  
2803 3a 17 28			ld a, (.dmark)  
2806 32 65 ee			ld (debug_mark),a  
2809 3a 18 28			ld a, (.dmark+1)  
280c 32 66 ee			ld (debug_mark+1),a  
280f 3a 19 28			ld a, (.dmark+2)  
2812 32 67 ee			ld (debug_mark+2),a  
2815 18 03			jr .pastdmark  
2817 ..			.dmark: db "BP."  
281a f1			.pastdmark: pop af  
281b			endm  
# End of macro DMARK
281b					CALLMONITOR 
281b cd 6f ee			call debug_vector  
281e				endm  
# End of macro CALLMONITOR
281e				endif 
281e			 
281e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
281e cd 95 1d			call macro_dsp_valuehl 
2821				endm 
# End of macro FORTH_DSP_VALUEHL
2821			 
2821			;		push hl 
2821			 
2821				; destroy value TOS 
2821			 
2821				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2821 cd 4d 1e			call macro_forth_dsp_pop 
2824				endm 
# End of macro FORTH_DSP_POP
2824			 
2824			;		pop hl 
2824			 
2824 3e 00			ld a,0 
2826 bd				cp l 
2827 28 06			jr z, .bpset 
2829			;		ld a, '*' 
2829 cd 0b 15			call bp_off 
282c				NEXTW 
282c c3 81 1f			jp macro_next 
282f				endm 
# End of macro NEXTW
282f			 
282f			.bpset:	 
282f				;	ld (os_view_disable), a 
282f cd ff 14			call bp_on 
2832			 
2832			 
2832				NEXTW 
2832 c3 81 1f			jp macro_next 
2835				endm 
# End of macro NEXTW
2835			 
2835			 
2835			.MONITOR: 
2835			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2835 55				db WORD_SYS_CORE+65             
2836 66 28			dw .MALLOC            
2838 08				db 7 + 1 
2839 .. 00			db "MONITOR",0              
2841				endm 
# End of macro CWHEAD
2841			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2841			; | | At start the current various registers will be displayed with contents. 
2841			; | | Top right corner will show the most recent debug marker seen. 
2841			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2841			; | | and the return stack pointer (RSP). 
2841			; | | Pressing: 
2841			; | |    1 - Initial screen 
2841			; | |    2 - Display a data dump of HL 
2841			; | |    3 - Display a data dump of DE 
2841			; | |    4 - Display a data dump of BC 
2841			; | |    5 - Display a data dump of HL 
2841			; | |    6 - Display a data dump of DSP 
2841			; | |    7 - Display a data dump of RSP 
2841			; | |    8 - Display a data dump of what is at DSP 
2841			; | |    9 - Display a data dump of what is at RSP 
2841			; | |    0 - Exit monitor and continue running. This will also enable break points 
2841			; | |    * - Disable break points 
2841			; | |    # - Enter traditional monitor mode 
2841			; | | 
2841			; | | Monitor Mode 
2841			; | | ------------ 
2841			; | | A prompt of '>' will be shown for various commands: 
2841			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2841			; | |    C - Continue display a data dump from the last set address 
2841			; | |    M xxxx - Set start of memory edit at address xx 
2841			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2841			; | |    G xxxx - Exec code at specific address 
2841			; | |    Q - Return to previous 
2841				if DEBUG_FORTH_WORDS_KEY 
2841					DMARK "MON" 
2841 f5				push af  
2842 3a 56 28			ld a, (.dmark)  
2845 32 65 ee			ld (debug_mark),a  
2848 3a 57 28			ld a, (.dmark+1)  
284b 32 66 ee			ld (debug_mark+1),a  
284e 3a 58 28			ld a, (.dmark+2)  
2851 32 67 ee			ld (debug_mark+2),a  
2854 18 03			jr .pastdmark  
2856 ..			.dmark: db "MON"  
2859 f1			.pastdmark: pop af  
285a			endm  
# End of macro DMARK
285a					CALLMONITOR 
285a cd 6f ee			call debug_vector  
285d				endm  
# End of macro CALLMONITOR
285d				endif 
285d			;		ld a, 0 
285d			;		ld (os_view_disable), a 
285d cd ff 14			call bp_on 
2860			 
2860				CALLMONITOR 
2860 cd 6f ee			call debug_vector  
2863				endm  
# End of macro CALLMONITOR
2863			 
2863			;	call monitor 
2863			 
2863				NEXTW 
2863 c3 81 1f			jp macro_next 
2866				endm 
# End of macro NEXTW
2866			 
2866			 
2866			.MALLOC: 
2866			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2866 56				db WORD_SYS_CORE+66             
2867 8f 28			dw .MALLOC2            
2869 06				db 5 + 1 
286a .. 00			db "ALLOT",0              
2870				endm 
# End of macro CWHEAD
2870			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2870				if DEBUG_FORTH_WORDS_KEY 
2870					DMARK "ALL" 
2870 f5				push af  
2871 3a 85 28			ld a, (.dmark)  
2874 32 65 ee			ld (debug_mark),a  
2877 3a 86 28			ld a, (.dmark+1)  
287a 32 66 ee			ld (debug_mark+1),a  
287d 3a 87 28			ld a, (.dmark+2)  
2880 32 67 ee			ld (debug_mark+2),a  
2883 18 03			jr .pastdmark  
2885 ..			.dmark: db "ALL"  
2888 f1			.pastdmark: pop af  
2889			endm  
# End of macro DMARK
2889					CALLMONITOR 
2889 cd 6f ee			call debug_vector  
288c				endm  
# End of macro CALLMONITOR
288c				endif 
288c c3 b6 28			jp .mallocc 
288f			.MALLOC2: 
288f			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
288f 56				db WORD_SYS_CORE+66             
2890 cd 28			dw .FREE            
2892 07				db 6 + 1 
2893 .. 00			db "MALLOC",0              
289a				endm 
# End of macro CWHEAD
289a			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
289a				; get byte count 
289a				if DEBUG_FORTH_WORDS_KEY 
289a					DMARK "MAL" 
289a f5				push af  
289b 3a af 28			ld a, (.dmark)  
289e 32 65 ee			ld (debug_mark),a  
28a1 3a b0 28			ld a, (.dmark+1)  
28a4 32 66 ee			ld (debug_mark+1),a  
28a7 3a b1 28			ld a, (.dmark+2)  
28aa 32 67 ee			ld (debug_mark+2),a  
28ad 18 03			jr .pastdmark  
28af ..			.dmark: db "MAL"  
28b2 f1			.pastdmark: pop af  
28b3			endm  
# End of macro DMARK
28b3					CALLMONITOR 
28b3 cd 6f ee			call debug_vector  
28b6				endm  
# End of macro CALLMONITOR
28b6				endif 
28b6			.mallocc: 
28b6				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28b6 cd 95 1d			call macro_dsp_valuehl 
28b9				endm 
# End of macro FORTH_DSP_VALUEHL
28b9			 
28b9			;		push hl 
28b9			 
28b9				; destroy value TOS 
28b9			 
28b9				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28b9 cd 4d 1e			call macro_forth_dsp_pop 
28bc				endm 
# End of macro FORTH_DSP_POP
28bc			 
28bc			;		pop hl 
28bc cd d0 11			call malloc 
28bf			if DEBUG_FORTH_MALLOC_GUARD 
28bf f5				push af 
28c0 cd 1e 0e			call ishlzero 
28c3			;		ld a, l 
28c3			;		add h 
28c3			;		cp 0 
28c3 f1				pop af 
28c4				 
28c4 cc 7d 4d			call z,malloc_error 
28c7			endif 
28c7			 
28c7 cd 90 1b			call forth_push_numhl 
28ca				NEXTW 
28ca c3 81 1f			jp macro_next 
28cd				endm 
# End of macro NEXTW
28cd			 
28cd			.FREE: 
28cd			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
28cd 57				db WORD_SYS_CORE+67             
28ce fe 28			dw .LIST            
28d0 05				db 4 + 1 
28d1 .. 00			db "FREE",0              
28d6				endm 
# End of macro CWHEAD
28d6			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
28d6				if DEBUG_FORTH_WORDS_KEY 
28d6					DMARK "FRE" 
28d6 f5				push af  
28d7 3a eb 28			ld a, (.dmark)  
28da 32 65 ee			ld (debug_mark),a  
28dd 3a ec 28			ld a, (.dmark+1)  
28e0 32 66 ee			ld (debug_mark+1),a  
28e3 3a ed 28			ld a, (.dmark+2)  
28e6 32 67 ee			ld (debug_mark+2),a  
28e9 18 03			jr .pastdmark  
28eb ..			.dmark: db "FRE"  
28ee f1			.pastdmark: pop af  
28ef			endm  
# End of macro DMARK
28ef					CALLMONITOR 
28ef cd 6f ee			call debug_vector  
28f2				endm  
# End of macro CALLMONITOR
28f2				endif 
28f2				; get address 
28f2			 
28f2				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28f2 cd 95 1d			call macro_dsp_valuehl 
28f5				endm 
# End of macro FORTH_DSP_VALUEHL
28f5			 
28f5			;		push hl 
28f5			 
28f5				; destroy value TOS 
28f5			 
28f5				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28f5 cd 4d 1e			call macro_forth_dsp_pop 
28f8				endm 
# End of macro FORTH_DSP_POP
28f8			 
28f8			;		pop hl 
28f8			if FORTH_ENABLE_MALLOCFREE 
28f8 cd 9a 12			call free 
28fb			endif 
28fb				NEXTW 
28fb c3 81 1f			jp macro_next 
28fe				endm 
# End of macro NEXTW
28fe			.LIST: 
28fe			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
28fe 5c				db WORD_SYS_CORE+72             
28ff fa 2a			dw .FORGET            
2901 05				db 4 + 1 
2902 .. 00			db "LIST",0              
2907				endm 
# End of macro CWHEAD
2907			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2907			; | | The quoted word must be in upper case. 
2907			if DEBUG_FORTH_WORDS_KEY 
2907				DMARK "LST" 
2907 f5				push af  
2908 3a 1c 29			ld a, (.dmark)  
290b 32 65 ee			ld (debug_mark),a  
290e 3a 1d 29			ld a, (.dmark+1)  
2911 32 66 ee			ld (debug_mark+1),a  
2914 3a 1e 29			ld a, (.dmark+2)  
2917 32 67 ee			ld (debug_mark+2),a  
291a 18 03			jr .pastdmark  
291c ..			.dmark: db "LST"  
291f f1			.pastdmark: pop af  
2920			endm  
# End of macro DMARK
2920				CALLMONITOR 
2920 cd 6f ee			call debug_vector  
2923				endm  
# End of macro CALLMONITOR
2923			endif 
2923			 
2923				FORTH_DSP_VALUEHL 
2923 cd 95 1d			call macro_dsp_valuehl 
2926				endm 
# End of macro FORTH_DSP_VALUEHL
2926			 
2926 e5				push hl 
2927				FORTH_DSP_POP 
2927 cd 4d 1e			call macro_forth_dsp_pop 
292a				endm 
# End of macro FORTH_DSP_POP
292a c1				pop bc 
292b			 
292b			; Start format of scratch string 
292b			 
292b 21 bb e2			ld hl, scratch 
292e			 
292e 3e 3a			ld a, ':' 
2930 77				ld (hl),a 
2931 23				inc hl 
2932 3e 20			ld a, ' ' 
2934 77				ld (hl), a 
2935			 
2935				; Get ptr to the word we need to look up 
2935			 
2935			;		FORTH_DSP_VALUEHL 
2935				;v5 FORTH_DSP_VALUE 
2935			; TODO type check 
2935			;		inc hl    ; Skip type check  
2935			;		push hl 
2935			;		ex de, hl    ; put into DE 
2935			 
2935			 
2935 21 12 5f			ld hl, baseram 
2938				;ld hl, baseusermem 
2938			 
2938 e5			push hl   ; sacreifical push 
2939			 
2939			.ldouscanm: 
2939 e1			pop hl 
293a			.ldouscan: 
293a			if DEBUG_FORTH_WORDS 
293a				DMARK "LSs" 
293a f5				push af  
293b 3a 4f 29			ld a, (.dmark)  
293e 32 65 ee			ld (debug_mark),a  
2941 3a 50 29			ld a, (.dmark+1)  
2944 32 66 ee			ld (debug_mark+1),a  
2947 3a 51 29			ld a, (.dmark+2)  
294a 32 67 ee			ld (debug_mark+2),a  
294d 18 03			jr .pastdmark  
294f ..			.dmark: db "LSs"  
2952 f1			.pastdmark: pop af  
2953			endm  
# End of macro DMARK
2953				CALLMONITOR 
2953 cd 6f ee			call debug_vector  
2956				endm  
# End of macro CALLMONITOR
2956			endif 
2956			; skip dict stub 
2956 cd d2 20			call forth_tok_next 
2959			 
2959			 
2959			; while we have words to look for 
2959			 
2959 7e			ld a, (hl)      
295a			if DEBUG_FORTH_WORDS 
295a				DMARK "LSk" 
295a f5				push af  
295b 3a 6f 29			ld a, (.dmark)  
295e 32 65 ee			ld (debug_mark),a  
2961 3a 70 29			ld a, (.dmark+1)  
2964 32 66 ee			ld (debug_mark+1),a  
2967 3a 71 29			ld a, (.dmark+2)  
296a 32 67 ee			ld (debug_mark+2),a  
296d 18 03			jr .pastdmark  
296f ..			.dmark: db "LSk"  
2972 f1			.pastdmark: pop af  
2973			endm  
# End of macro DMARK
2973				CALLMONITOR 
2973 cd 6f ee			call debug_vector  
2976				endm  
# End of macro CALLMONITOR
2976			endif 
2976				;cp WORD_SYS_END 
2976				;jp z, .lunotfound 
2976			 
2976					; if we hit non uwords then gone too far 
2976 fe 01				cp WORD_SYS_UWORD 
2978 c2 b6 2a				jp nz, .lunotfound 
297b			 
297b				if DEBUG_FORTH_WORDS 
297b					DMARK "LSu" 
297b f5				push af  
297c 3a 90 29			ld a, (.dmark)  
297f 32 65 ee			ld (debug_mark),a  
2982 3a 91 29			ld a, (.dmark+1)  
2985 32 66 ee			ld (debug_mark+1),a  
2988 3a 92 29			ld a, (.dmark+2)  
298b 32 67 ee			ld (debug_mark+2),a  
298e 18 03			jr .pastdmark  
2990 ..			.dmark: db "LSu"  
2993 f1			.pastdmark: pop af  
2994			endm  
# End of macro DMARK
2994					CALLMONITOR 
2994 cd 6f ee			call debug_vector  
2997				endm  
# End of macro CALLMONITOR
2997				endif 
2997			 
2997					; found a uword but is it the one we want... 
2997			 
2997 c5					push bc     ; uword to find is on bc 
2998 d1					pop de 
2999			 
2999 e5					push hl  ; to save the ptr 
299a			 
299a					; skip opcode 
299a 23					inc hl  
299b					; skip next ptr 
299b 23					inc hl  
299c 23					inc hl 
299d					; skip len 
299d 23					inc hl 
299e			 
299e				if DEBUG_FORTH_WORDS 
299e					DMARK "LSc" 
299e f5				push af  
299f 3a b3 29			ld a, (.dmark)  
29a2 32 65 ee			ld (debug_mark),a  
29a5 3a b4 29			ld a, (.dmark+1)  
29a8 32 66 ee			ld (debug_mark+1),a  
29ab 3a b5 29			ld a, (.dmark+2)  
29ae 32 67 ee			ld (debug_mark+2),a  
29b1 18 03			jr .pastdmark  
29b3 ..			.dmark: db "LSc"  
29b6 f1			.pastdmark: pop af  
29b7			endm  
# End of macro DMARK
29b7					CALLMONITOR 
29b7 cd 6f ee			call debug_vector  
29ba				endm  
# End of macro CALLMONITOR
29ba				endif 
29ba			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
29ba			; ie. If WOO is defined first and then WO. Couldnt list WO. 
29ba			; Nope that has gone the other way. It needs to be exact not on first zero 
29ba			;		call strcmp 
29ba c5					push bc 
29bb cd a0 11				call StrictStrCmp 
29be c1					pop bc 
29bf c2 39 29				jp nz, .ldouscanm 
29c2				 
29c2			 
29c2			 
29c2					; we have a uword so push its name to the stack 
29c2			 
29c2			;	   	push hl  ; save so we can move to next dict block 
29c2 e1			pop hl 
29c3			 
29c3				if DEBUG_FORTH_WORDS 
29c3					DMARK "LSm" 
29c3 f5				push af  
29c4 3a d8 29			ld a, (.dmark)  
29c7 32 65 ee			ld (debug_mark),a  
29ca 3a d9 29			ld a, (.dmark+1)  
29cd 32 66 ee			ld (debug_mark+1),a  
29d0 3a da 29			ld a, (.dmark+2)  
29d3 32 67 ee			ld (debug_mark+2),a  
29d6 18 03			jr .pastdmark  
29d8 ..			.dmark: db "LSm"  
29db f1			.pastdmark: pop af  
29dc			endm  
# End of macro DMARK
29dc					CALLMONITOR 
29dc cd 6f ee			call debug_vector  
29df				endm  
# End of macro CALLMONITOR
29df				endif 
29df			 
29df					; skip opcode 
29df 23					inc hl  
29e0					; skip next ptr 
29e0 23					inc hl  
29e1 23					inc hl 
29e2					; skip len 
29e2 7e					ld a, (hl)   ; save length to add 
29e3				if DEBUG_FORTH_WORDS 
29e3					DMARK "LS2" 
29e3 f5				push af  
29e4 3a f8 29			ld a, (.dmark)  
29e7 32 65 ee			ld (debug_mark),a  
29ea 3a f9 29			ld a, (.dmark+1)  
29ed 32 66 ee			ld (debug_mark+1),a  
29f0 3a fa 29			ld a, (.dmark+2)  
29f3 32 67 ee			ld (debug_mark+2),a  
29f6 18 03			jr .pastdmark  
29f8 ..			.dmark: db "LS2"  
29fb f1			.pastdmark: pop af  
29fc			endm  
# End of macro DMARK
29fc					CALLMONITOR 
29fc cd 6f ee			call debug_vector  
29ff				endm  
# End of macro CALLMONITOR
29ff				endif 
29ff			 
29ff					; save this location 
29ff				 
29ff e5					push hl 
2a00			 
2a00 23					inc hl 
2a01 11 bd e2				ld de, scratch+2 
2a04 4f					ld c, a 
2a05 06 00				ld b, 0 
2a07			 
2a07				if DEBUG_FORTH_WORDS 
2a07					DMARK "LSn" 
2a07 f5				push af  
2a08 3a 1c 2a			ld a, (.dmark)  
2a0b 32 65 ee			ld (debug_mark),a  
2a0e 3a 1d 2a			ld a, (.dmark+1)  
2a11 32 66 ee			ld (debug_mark+1),a  
2a14 3a 1e 2a			ld a, (.dmark+2)  
2a17 32 67 ee			ld (debug_mark+2),a  
2a1a 18 03			jr .pastdmark  
2a1c ..			.dmark: db "LSn"  
2a1f f1			.pastdmark: pop af  
2a20			endm  
# End of macro DMARK
2a20					CALLMONITOR 
2a20 cd 6f ee			call debug_vector  
2a23				endm  
# End of macro CALLMONITOR
2a23				endif 
2a23			 
2a23					; copy uword name to scratch 
2a23			 
2a23			;		ldir 
2a23			.licplw:	; copy uword name to scratch converting to lower case as we go 
2a23 ed a0				ldi 
2a25 1b					dec de 
2a26 1a					ld a, (de) 
2a27 cd 73 10				call to_lower 
2a2a 12					ld (de),a 
2a2b 13					inc de 
2a2c 3e 00				ld a, 0 
2a2e b9					cp c 
2a2f 20 f2				jr nz, .licplw 
2a31			 
2a31			 
2a31			 
2a31 1b					dec de 
2a32 3e 20				ld a, ' '    ; change null to space 
2a34 12					ld (de), a 
2a35			 
2a35 13					inc de 
2a36			 
2a36 d5					push de 
2a37 c1					pop bc     ; move scratch pointer to end of word name and save it 
2a38			 
2a38 e1					pop hl 
2a39 7e					ld a, (hl) 
2a3a					;inc hl 
2a3a					; skip word string 
2a3a cd f5 0d				call addatohl 
2a3d			 
2a3d 23					inc hl 
2a3e			 
2a3e				if DEBUG_FORTH_WORDS 
2a3e					DMARK "LS3" 
2a3e f5				push af  
2a3f 3a 53 2a			ld a, (.dmark)  
2a42 32 65 ee			ld (debug_mark),a  
2a45 3a 54 2a			ld a, (.dmark+1)  
2a48 32 66 ee			ld (debug_mark+1),a  
2a4b 3a 55 2a			ld a, (.dmark+2)  
2a4e 32 67 ee			ld (debug_mark+2),a  
2a51 18 03			jr .pastdmark  
2a53 ..			.dmark: db "LS3"  
2a56 f1			.pastdmark: pop af  
2a57			endm  
# End of macro DMARK
2a57					CALLMONITOR 
2a57 cd 6f ee			call debug_vector  
2a5a				endm  
# End of macro CALLMONITOR
2a5a				endif 
2a5a					; should now be at the start of the machine code to setup the eval of the uword 
2a5a					; now locate the ptr to the string defintion 
2a5a			 
2a5a					; skip ld hl, 
2a5a					; then load the ptr 
2a5a			; TODO use get from hl ptr 
2a5a 23					inc hl 
2a5b 5e					ld e, (hl) 
2a5c 23					inc hl 
2a5d 56					ld d, (hl) 
2a5e eb					ex de, hl 
2a5f			 
2a5f			 
2a5f				if DEBUG_FORTH_WORDS 
2a5f					DMARK "LSt" 
2a5f f5				push af  
2a60 3a 74 2a			ld a, (.dmark)  
2a63 32 65 ee			ld (debug_mark),a  
2a66 3a 75 2a			ld a, (.dmark+1)  
2a69 32 66 ee			ld (debug_mark+1),a  
2a6c 3a 76 2a			ld a, (.dmark+2)  
2a6f 32 67 ee			ld (debug_mark+2),a  
2a72 18 03			jr .pastdmark  
2a74 ..			.dmark: db "LSt"  
2a77 f1			.pastdmark: pop af  
2a78			endm  
# End of macro DMARK
2a78					CALLMONITOR 
2a78 cd 6f ee			call debug_vector  
2a7b				endm  
# End of macro CALLMONITOR
2a7b				endif 
2a7b			 
2a7b			; cant push right now due to tokenised strings  
2a7b			 
2a7b			; get the destination of where to copy this definition to. 
2a7b			 
2a7b c5					push bc 
2a7c d1					pop de 
2a7d			 
2a7d 7e			.listl:         ld a,(hl) 
2a7e fe 00				cp 0 
2a80 28 09				jr z, .lreplsp     ; replace zero with space 
2a82					;cp FORTH_END_BUFFER 
2a82 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2a84 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2a86				 
2a86					; just copy this char as is then 
2a86			 
2a86 12					ld (de), a 
2a87			 
2a87 23			.listnxt:	inc hl 
2a88 13					inc de 
2a89 18 f2				jr .listl 
2a8b			 
2a8b 3e 20		.lreplsp:	ld a,' ' 
2a8d 12					ld (de), a 
2a8e 18 f7				jr .listnxt 
2a90			 
2a90			; close up uword def 
2a90			 
2a90			.listdone: 
2a90 12					ld (de), a 
2a91 13					inc de 
2a92 3e 00				ld a, 0 
2a94 12					ld (de), a 
2a95			 
2a95			; now have def so clean up and push to stack 
2a95			 
2a95 21 bb e2				ld hl, scratch 
2a98				if DEBUG_FORTH_WORDS 
2a98					DMARK "Ltp" 
2a98 f5				push af  
2a99 3a ad 2a			ld a, (.dmark)  
2a9c 32 65 ee			ld (debug_mark),a  
2a9f 3a ae 2a			ld a, (.dmark+1)  
2aa2 32 66 ee			ld (debug_mark+1),a  
2aa5 3a af 2a			ld a, (.dmark+2)  
2aa8 32 67 ee			ld (debug_mark+2),a  
2aab 18 03			jr .pastdmark  
2aad ..			.dmark: db "Ltp"  
2ab0 f1			.pastdmark: pop af  
2ab1			endm  
# End of macro DMARK
2ab1					CALLMONITOR 
2ab1 cd 6f ee			call debug_vector  
2ab4				endm  
# End of macro CALLMONITOR
2ab4				endif 
2ab4			 
2ab4 18 1f			jr .listpush 
2ab6			 
2ab6			;.lnuword:	pop hl 
2ab6			;		call forth_tok_next 
2ab6			;		jp .ldouscan  
2ab6			 
2ab6			.lunotfound:		  
2ab6			 
2ab6				if DEBUG_FORTH_WORDS 
2ab6					DMARK "LSn" 
2ab6 f5				push af  
2ab7 3a cb 2a			ld a, (.dmark)  
2aba 32 65 ee			ld (debug_mark),a  
2abd 3a cc 2a			ld a, (.dmark+1)  
2ac0 32 66 ee			ld (debug_mark+1),a  
2ac3 3a cd 2a			ld a, (.dmark+2)  
2ac6 32 67 ee			ld (debug_mark+2),a  
2ac9 18 03			jr .pastdmark  
2acb ..			.dmark: db "LSn"  
2ace f1			.pastdmark: pop af  
2acf			endm  
# End of macro DMARK
2acf					CALLMONITOR 
2acf cd 6f ee			call debug_vector  
2ad2				endm  
# End of macro CALLMONITOR
2ad2				endif 
2ad2			 
2ad2					 
2ad2			;		FORTH_DSP_POP 
2ad2			;		ld hl, .luno 
2ad2			 
2ad2					NEXTW			 
2ad2 c3 81 1f			jp macro_next 
2ad5				endm 
# End of macro NEXTW
2ad5			 
2ad5			.listpush: 
2ad5				if DEBUG_FORTH_WORDS 
2ad5					DMARK "LS>" 
2ad5 f5				push af  
2ad6 3a ea 2a			ld a, (.dmark)  
2ad9 32 65 ee			ld (debug_mark),a  
2adc 3a eb 2a			ld a, (.dmark+1)  
2adf 32 66 ee			ld (debug_mark+1),a  
2ae2 3a ec 2a			ld a, (.dmark+2)  
2ae5 32 67 ee			ld (debug_mark+2),a  
2ae8 18 03			jr .pastdmark  
2aea ..			.dmark: db "LS>"  
2aed f1			.pastdmark: pop af  
2aee			endm  
# End of macro DMARK
2aee					CALLMONITOR 
2aee cd 6f ee			call debug_vector  
2af1				endm  
# End of macro CALLMONITOR
2af1				endif 
2af1 cd fe 1b				call forth_push_str 
2af4			 
2af4			 
2af4			 
2af4					NEXTW 
2af4 c3 81 1f			jp macro_next 
2af7				endm 
# End of macro NEXTW
2af7			 
2af7			;.luno:    db "Word not found",0 
2af7			 
2af7			 
2af7			 
2af7			 
2af7			 
2af7			;		push hl   ; save pointer to start of uword def string 
2af7			; 
2af7			;; look for FORTH_EOL_LINE 
2af7			;		ld a, FORTH_END_BUFFER 
2af7			;		call strlent 
2af7			; 
2af7			;		inc hl		 ; space for coln def 
2af7			;		inc hl 
2af7			;		inc hl          ; space for terms 
2af7			;		inc hl 
2af7			; 
2af7			;		ld a, 20   ; TODO get actual length 
2af7			;		call addatohl    ; include a random amount of room for the uword name 
2af7			; 
2af7			;		 
2af7			;	if DEBUG_FORTH_WORDS 
2af7			;		DMARK "Lt1" 
2af7			;		CALLMONITOR 
2af7			;	endif 
2af7			;		 
2af7			; 
2af7			;; malloc space for the string because we cant change it 
2af7			; 
2af7			;		call malloc 
2af7			;	if DEBUG_FORTH_MALLOC_GUARD 
2af7			;		push af 
2af7			;		call ishlzero 
2af7			;		pop af 
2af7			;		 
2af7			;		call z,malloc_error 
2af7			;	endif 
2af7			; 
2af7			;	if DEBUG_FORTH_WORDS 
2af7			;		DMARK "Lt2" 
2af7			;		CALLMONITOR 
2af7			;	endif 
2af7			;		pop de 
2af7			;		push hl    ; push the malloc to release later 
2af7			;		push hl   ;  push back a copy for the later stack push 
2af7			;		 
2af7			;; copy the string swapping out the zero terms for spaces 
2af7			; 
2af7			;		; de has our source 
2af7			;		; hl has our dest 
2af7			; 
2af7			;; add the coln def 
2af7			; 
2af7			;		ld a, ':' 
2af7			;		ld (hl), a 
2af7			;		inc hl 
2af7			;		ld a, ' ' 
2af7			;		ld (hl), a 
2af7			;		inc hl 
2af7			; 
2af7			;; add the uname word 
2af7			;		push de   ; save our string for now 
2af7			;		ex de, hl 
2af7			; 
2af7			;		FORTH_DSP_VALUE 
2af7			;		;v5 FORTH_DSP_VALUE 
2af7			; 
2af7			;		inc hl   ; skip type but we know by now this is OK 
2af7			; 
2af7			;.luword:	ld a,(hl) 
2af7			;		cp 0 
2af7			;		jr z, .luword2 
2af7			;		ld (de), a 
2af7			;		inc de 
2af7			;		inc hl 
2af7			;		jr .luword 
2af7			; 
2af7			;.luword2:	ld a, ' ' 
2af7			;		ld (de), a 
2af7			;;		inc hl 
2af7			;;		inc de 
2af7			;;		ld (de), a 
2af7			;;		inc hl 
2af7			;		inc de 
2af7			; 
2af7			;		ex de, hl 
2af7			;		pop de 
2af7			;		 
2af7			;		 
2af7			; 
2af7			;; detoken that string and copy it 
2af7			; 
2af7			;	if DEBUG_FORTH_WORDS 
2af7			;		DMARK "Lt2" 
2af7			;		CALLMONITOR 
2af7			;	endif 
2af7			;.ldetok:	ld a, (de) 
2af7			;		cp FORTH_END_BUFFER 
2af7			;		jr z, .ldetokend 
2af7			;		; swap out any zero term for space 
2af7			;		cp 0 
2af7			;		jr nz, .ldetoknext 
2af7			;		ld a, ' ' 
2af7			; 
2af7			;	if DEBUG_FORTH_WORDS 
2af7			;		DMARK "LtS" 
2af7			;		CALLMONITOR 
2af7			;	endif 
2af7			;.ldetoknext:	ld (hl), a 
2af7			;		inc de 
2af7			;		inc hl 
2af7			;		jr .ldetok 
2af7			; 
2af7			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2af7			;		ld (hl), a  
2af7			; 
2af7			;; free that temp malloc 
2af7			; 
2af7			;		pop hl    
2af7			; 
2af7			;	if DEBUG_FORTH_WORDS 
2af7			;		DMARK "Lt4" 
2af7			;		CALLMONITOR 
2af7			;	endif 
2af7			;		call forth_apushstrhl 
2af7			; 
2af7			;		; get rid of temp malloc area 
2af7			; 
2af7			;		pop hl 
2af7			;		call free 
2af7			; 
2af7			;		jr .ludone 
2af7			; 
2af7			;.lnuword:	pop hl 
2af7			;		call forth_tok_next 
2af7			;		jp .ldouscan  
2af7			; 
2af7			;.ludone:		 pop hl 
2af7			; 
2af7					NEXTW 
2af7 c3 81 1f			jp macro_next 
2afa				endm 
# End of macro NEXTW
2afa			 
2afa			.FORGET: 
2afa				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2afa 5d				db WORD_SYS_CORE+73             
2afb 73 2b			dw .NOP            
2afd 07				db 6 + 1 
2afe .. 00			db "FORGET",0              
2b05				endm 
# End of macro CWHEAD
2b05			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b05			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2b05			; | |  
2b05			; | | e.g. "MORE" forget 
2b05					if DEBUG_FORTH_WORDS_KEY 
2b05						DMARK "FRG" 
2b05 f5				push af  
2b06 3a 1a 2b			ld a, (.dmark)  
2b09 32 65 ee			ld (debug_mark),a  
2b0c 3a 1b 2b			ld a, (.dmark+1)  
2b0f 32 66 ee			ld (debug_mark+1),a  
2b12 3a 1c 2b			ld a, (.dmark+2)  
2b15 32 67 ee			ld (debug_mark+2),a  
2b18 18 03			jr .pastdmark  
2b1a ..			.dmark: db "FRG"  
2b1d f1			.pastdmark: pop af  
2b1e			endm  
# End of macro DMARK
2b1e						CALLMONITOR 
2b1e cd 6f ee			call debug_vector  
2b21				endm  
# End of macro CALLMONITOR
2b21					endif 
2b21			 
2b21				; find uword 
2b21			        ; update start of word with "_" 
2b21				; replace uword with deleted flag 
2b21			 
2b21			 
2b21			;	if DEBUG_FORTH_WORDS 
2b21			;		DMARK "FOG" 
2b21			;		CALLMONITOR 
2b21			;	endif 
2b21			 
2b21			 
2b21					; Get ptr to the word we need to look up 
2b21			 
2b21					FORTH_DSP_VALUEHL 
2b21 cd 95 1d			call macro_dsp_valuehl 
2b24				endm 
# End of macro FORTH_DSP_VALUEHL
2b24					;v5 FORTH_DSP_VALUE 
2b24				; TODO type check 
2b24			;		inc hl    ; Skip type check  
2b24 e5					push hl 
2b25 c1					pop bc 
2b26			;		ex de, hl    ; put into DE 
2b26			 
2b26			 
2b26 21 12 5f				ld hl, baseram 
2b29					;ld hl, baseusermem 
2b29			 
2b29				; skip dict stub 
2b29			;	call forth_tok_next 
2b29 e5			push hl   ; sacreifical push 
2b2a			 
2b2a			.fldouscanm: 
2b2a e1				pop hl 
2b2b			.fldouscan: 
2b2b			;	if DEBUG_FORTH_WORDS 
2b2b			;		DMARK "LSs" 
2b2b			;		CALLMONITOR 
2b2b			;	endif 
2b2b				; skip dict stub 
2b2b cd d2 20				call forth_tok_next 
2b2e			 
2b2e			 
2b2e			; while we have words to look for 
2b2e			 
2b2e 7e				ld a, (hl)      
2b2f			;	if DEBUG_FORTH_WORDS 
2b2f			;		DMARK "LSk" 
2b2f			;		CALLMONITOR 
2b2f			;	endif 
2b2f fe 00				cp WORD_SYS_END 
2b31 ca 6d 2b				jp z, .flunotfound 
2b34 fe 01				cp WORD_SYS_UWORD 
2b36 c2 2b 2b				jp nz, .fldouscan 
2b39			 
2b39			;	if DEBUG_FORTH_WORDS 
2b39			;		DMARK "LSu" 
2b39			;		CALLMONITOR 
2b39			;	endif 
2b39			 
2b39					; found a uword but is it the one we want... 
2b39			 
2b39 c5					push bc     ; uword to find is on bc 
2b3a d1					pop de 
2b3b			 
2b3b e5					push hl  ; to save the ptr 
2b3c			 
2b3c					; skip opcode 
2b3c 23					inc hl  
2b3d					; skip next ptr 
2b3d 23					inc hl  
2b3e 23					inc hl 
2b3f					; skip len 
2b3f 23					inc hl 
2b40			 
2b40			;	if DEBUG_FORTH_WORDS 
2b40			;		DMARK "LSc" 
2b40			;		CALLMONITOR 
2b40			;	endif 
2b40 cd 93 11				call strcmp 
2b43 c2 2a 2b				jp nz, .fldouscanm 
2b46			; 
2b46			; 
2b46			;; while we have words to look for 
2b46			; 
2b46			;.fdouscan:	ld a, (hl)      
2b46			;	if DEBUG_FORTH_WORDS 
2b46			;		DMARK "LSs" 
2b46			;		CALLMONITOR 
2b46			;	endif 
2b46			;		cp WORD_SYS_END 
2b46			;		jp z, .fudone 
2b46			;		cp WORD_SYS_UWORD 
2b46			;		jp nz, .fnuword 
2b46			; 
2b46			;	if DEBUG_FORTH_WORDS 
2b46			;		DMARK "FGu" 
2b46			;		CALLMONITOR 
2b46			;	endif 
2b46			; 
2b46			;		; found a uword but is it the one we want... 
2b46			; 
2b46			; 
2b46			;	        pop de   ; get back the dsp name 
2b46			;		push de 
2b46			; 
2b46			;		push hl  ; to save the ptr 
2b46			; 
2b46			;		; skip opcode 
2b46			;		inc hl  
2b46			;		; skip next ptr 
2b46			;		inc hl  
2b46			;		inc hl 
2b46			;		; skip len 
2b46			;		inc hl 
2b46			; 
2b46			;	if DEBUG_FORTH_WORDS 
2b46			;		DMARK "FGc" 
2b46			;		CALLMONITOR 
2b46			;	endif 
2b46			;		call strcmp 
2b46			;		jp nz, .fnuword 
2b46			 
2b46			 
2b46 e1			pop hl 
2b47			 
2b47				 
2b47				if DEBUG_FORTH_WORDS 
2b47					DMARK "FGm" 
2b47 f5				push af  
2b48 3a 5c 2b			ld a, (.dmark)  
2b4b 32 65 ee			ld (debug_mark),a  
2b4e 3a 5d 2b			ld a, (.dmark+1)  
2b51 32 66 ee			ld (debug_mark+1),a  
2b54 3a 5e 2b			ld a, (.dmark+2)  
2b57 32 67 ee			ld (debug_mark+2),a  
2b5a 18 03			jr .pastdmark  
2b5c ..			.dmark: db "FGm"  
2b5f f1			.pastdmark: pop af  
2b60			endm  
# End of macro DMARK
2b60					CALLMONITOR 
2b60 cd 6f ee			call debug_vector  
2b63				endm  
# End of macro CALLMONITOR
2b63				endif 
2b63			 
2b63			 
2b63			 
2b63					; we have a uword so push its name to the stack 
2b63			 
2b63			;	   	push hl  ; save so we can move to next dict block 
2b63			;pop hl 
2b63			 
2b63					; update opcode to deleted 
2b63 3e 03				ld a, WORD_SYS_DELETED 
2b65 77					ld (hl), a 
2b66			 
2b66 23					inc hl  
2b67					; skip next ptr 
2b67 23					inc hl  
2b68 23					inc hl 
2b69					; skip len 
2b69 23					inc hl 
2b6a			 
2b6a					; TODO change parser to skip deleted words but for now mark it out 
2b6a 3e 5f				ld a, "_" 
2b6c 77					ld  (hl),a 
2b6d			 
2b6d			;		jr .fudone 
2b6d			; 
2b6d			;.fnuword:	pop hl 
2b6d			;		call forth_tok_next 
2b6d			;		jp .fdouscan  
2b6d			 
2b6d			.flunotfound:		  
2b6d			 
2b6d			 
2b6d					 
2b6d					FORTH_DSP_POP 
2b6d cd 4d 1e			call macro_forth_dsp_pop 
2b70				endm 
# End of macro FORTH_DSP_POP
2b70			;		ld hl, .luno 
2b70			;.fudone:		 pop hl 
2b70					NEXTW 
2b70 c3 81 1f			jp macro_next 
2b73				endm 
# End of macro NEXTW
2b73			.NOP: 
2b73				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2b73 61				db WORD_SYS_CORE+77             
2b74 9a 2b			dw .COMO            
2b76 04				db 3 + 1 
2b77 .. 00			db "NOP",0              
2b7b				endm 
# End of macro CWHEAD
2b7b			; | NOP (  --  ) Do nothing | DONE 
2b7b					if DEBUG_FORTH_WORDS_KEY 
2b7b						DMARK "NOP" 
2b7b f5				push af  
2b7c 3a 90 2b			ld a, (.dmark)  
2b7f 32 65 ee			ld (debug_mark),a  
2b82 3a 91 2b			ld a, (.dmark+1)  
2b85 32 66 ee			ld (debug_mark+1),a  
2b88 3a 92 2b			ld a, (.dmark+2)  
2b8b 32 67 ee			ld (debug_mark+2),a  
2b8e 18 03			jr .pastdmark  
2b90 ..			.dmark: db "NOP"  
2b93 f1			.pastdmark: pop af  
2b94			endm  
# End of macro DMARK
2b94						CALLMONITOR 
2b94 cd 6f ee			call debug_vector  
2b97				endm  
# End of macro CALLMONITOR
2b97					endif 
2b97				       NEXTW 
2b97 c3 81 1f			jp macro_next 
2b9a				endm 
# End of macro NEXTW
2b9a			.COMO: 
2b9a				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2b9a 6e				db WORD_SYS_CORE+90             
2b9b ec 2b			dw .COMC            
2b9d 02				db 1 + 1 
2b9e .. 00			db "(",0              
2ba0				endm 
# End of macro CWHEAD
2ba0			; | ( ( -- )  Start of comment | DONE 
2ba0			 
2ba0			 
2ba0 2a bc e5				ld hl, ( os_tok_ptr) 
2ba3 11 e7 2b			ld de, .closepar 
2ba6					 
2ba6					if DEBUG_FORTH_WORDS 
2ba6						DMARK ").." 
2ba6 f5				push af  
2ba7 3a bb 2b			ld a, (.dmark)  
2baa 32 65 ee			ld (debug_mark),a  
2bad 3a bc 2b			ld a, (.dmark+1)  
2bb0 32 66 ee			ld (debug_mark+1),a  
2bb3 3a bd 2b			ld a, (.dmark+2)  
2bb6 32 67 ee			ld (debug_mark+2),a  
2bb9 18 03			jr .pastdmark  
2bbb ..			.dmark: db ").."  
2bbe f1			.pastdmark: pop af  
2bbf			endm  
# End of macro DMARK
2bbf						CALLMONITOR 
2bbf cd 6f ee			call debug_vector  
2bc2				endm  
# End of macro CALLMONITOR
2bc2					endif 
2bc2 cd 9c 20			call findnexttok  
2bc5			 
2bc5					if DEBUG_FORTH_WORDS 
2bc5						DMARK "IF5" 
2bc5 f5				push af  
2bc6 3a da 2b			ld a, (.dmark)  
2bc9 32 65 ee			ld (debug_mark),a  
2bcc 3a db 2b			ld a, (.dmark+1)  
2bcf 32 66 ee			ld (debug_mark+1),a  
2bd2 3a dc 2b			ld a, (.dmark+2)  
2bd5 32 67 ee			ld (debug_mark+2),a  
2bd8 18 03			jr .pastdmark  
2bda ..			.dmark: db "IF5"  
2bdd f1			.pastdmark: pop af  
2bde			endm  
# End of macro DMARK
2bde						CALLMONITOR 
2bde cd 6f ee			call debug_vector  
2be1				endm  
# End of macro CALLMONITOR
2be1					endif 
2be1				; replace below with ) exec using tok_ptr 
2be1 22 bc e5			ld (os_tok_ptr), hl 
2be4 c3 12 20			jp exec1 
2be7			 
2be7 .. 00			.closepar:   db ")",0 
2be9			 
2be9				       NEXTW 
2be9 c3 81 1f			jp macro_next 
2bec				endm 
# End of macro NEXTW
2bec			.COMC: 
2bec				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2bec 6f				db WORD_SYS_CORE+91             
2bed f5 2b			dw .SCRATCH            
2bef 02				db 1 + 1 
2bf0 .. 00			db ")",0              
2bf2				endm 
# End of macro CWHEAD
2bf2			; | ) ( -- )  End of comment |  DONE  
2bf2				       NEXTW 
2bf2 c3 81 1f			jp macro_next 
2bf5				endm 
# End of macro NEXTW
2bf5			 
2bf5			.SCRATCH: 
2bf5				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2bf5 6f				db WORD_SYS_CORE+91             
2bf6 30 2c			dw .INC            
2bf8 08				db 7 + 1 
2bf9 .. 00			db "SCRATCH",0              
2c01				endm 
# End of macro CWHEAD
2c01			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c01			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c01			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c01			; | |  
2c01			; | | e.g.    : score $00 scratch ; 
2c01			; | |  
2c01			; | | $00 score ! 
2c01			; | | $01 score +! 
2c01			; | |  
2c01			; | | e.g.   : varword $0a scratch ;  
2c01			; | | 
2c01			; | | $8000 varword ! 
2c01					if DEBUG_FORTH_WORDS_KEY 
2c01						DMARK "SCR" 
2c01 f5				push af  
2c02 3a 16 2c			ld a, (.dmark)  
2c05 32 65 ee			ld (debug_mark),a  
2c08 3a 17 2c			ld a, (.dmark+1)  
2c0b 32 66 ee			ld (debug_mark+1),a  
2c0e 3a 18 2c			ld a, (.dmark+2)  
2c11 32 67 ee			ld (debug_mark+2),a  
2c14 18 03			jr .pastdmark  
2c16 ..			.dmark: db "SCR"  
2c19 f1			.pastdmark: pop af  
2c1a			endm  
# End of macro DMARK
2c1a						CALLMONITOR 
2c1a cd 6f ee			call debug_vector  
2c1d				endm  
# End of macro CALLMONITOR
2c1d					endif 
2c1d			 
2c1d					FORTH_DSP_VALUEHL 
2c1d cd 95 1d			call macro_dsp_valuehl 
2c20				endm 
# End of macro FORTH_DSP_VALUEHL
2c20				 
2c20					FORTH_DSP_POP 
2c20 cd 4d 1e			call macro_forth_dsp_pop 
2c23				endm 
# End of macro FORTH_DSP_POP
2c23			 
2c23 7d					ld a, l 
2c24 21 e0 e7				ld hl, os_var_array 
2c27 cd f5 0d				call addatohl 
2c2a			 
2c2a cd 90 1b				call forth_push_numhl 
2c2d			 
2c2d				       NEXTW 
2c2d c3 81 1f			jp macro_next 
2c30				endm 
# End of macro NEXTW
2c30			 
2c30			.INC: 
2c30				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2c30 6f				db WORD_SYS_CORE+91             
2c31 86 2c			dw .DEC            
2c33 03				db 2 + 1 
2c34 .. 00			db "+!",0              
2c37				endm 
# End of macro CWHEAD
2c37			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2c37					if DEBUG_FORTH_WORDS_KEY 
2c37						DMARK "+s_" 
2c37 f5				push af  
2c38 3a 4c 2c			ld a, (.dmark)  
2c3b 32 65 ee			ld (debug_mark),a  
2c3e 3a 4d 2c			ld a, (.dmark+1)  
2c41 32 66 ee			ld (debug_mark+1),a  
2c44 3a 4e 2c			ld a, (.dmark+2)  
2c47 32 67 ee			ld (debug_mark+2),a  
2c4a 18 03			jr .pastdmark  
2c4c ..			.dmark: db "+s_"  
2c4f f1			.pastdmark: pop af  
2c50			endm  
# End of macro DMARK
2c50						CALLMONITOR 
2c50 cd 6f ee			call debug_vector  
2c53				endm  
# End of macro CALLMONITOR
2c53					endif 
2c53			 
2c53					FORTH_DSP_VALUEHL 
2c53 cd 95 1d			call macro_dsp_valuehl 
2c56				endm 
# End of macro FORTH_DSP_VALUEHL
2c56			 
2c56 e5					push hl   ; save address 
2c57			 
2c57					FORTH_DSP_POP 
2c57 cd 4d 1e			call macro_forth_dsp_pop 
2c5a				endm 
# End of macro FORTH_DSP_POP
2c5a			 
2c5a					FORTH_DSP_VALUEHL 
2c5a cd 95 1d			call macro_dsp_valuehl 
2c5d				endm 
# End of macro FORTH_DSP_VALUEHL
2c5d			 
2c5d e5					push hl 
2c5e					FORTH_DSP_POP 
2c5e cd 4d 1e			call macro_forth_dsp_pop 
2c61				endm 
# End of macro FORTH_DSP_POP
2c61 e1					pop hl 
2c62			 
2c62					; hl contains value to add to byte at a 
2c62				 
2c62 eb					ex de, hl 
2c63			 
2c63 e1					pop hl 
2c64			 
2c64					if DEBUG_FORTH_WORDS 
2c64						DMARK "INC" 
2c64 f5				push af  
2c65 3a 79 2c			ld a, (.dmark)  
2c68 32 65 ee			ld (debug_mark),a  
2c6b 3a 7a 2c			ld a, (.dmark+1)  
2c6e 32 66 ee			ld (debug_mark+1),a  
2c71 3a 7b 2c			ld a, (.dmark+2)  
2c74 32 67 ee			ld (debug_mark+2),a  
2c77 18 03			jr .pastdmark  
2c79 ..			.dmark: db "INC"  
2c7c f1			.pastdmark: pop af  
2c7d			endm  
# End of macro DMARK
2c7d						CALLMONITOR 
2c7d cd 6f ee			call debug_vector  
2c80				endm  
# End of macro CALLMONITOR
2c80					endif 
2c80			 
2c80 7e					ld a,(hl) 
2c81 83					add e 
2c82 77					ld (hl),a 
2c83			 
2c83			 
2c83			 
2c83				       NEXTW 
2c83 c3 81 1f			jp macro_next 
2c86				endm 
# End of macro NEXTW
2c86			 
2c86			.DEC: 
2c86				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2c86 6f				db WORD_SYS_CORE+91             
2c87 da 2c			dw .INC2            
2c89 03				db 2 + 1 
2c8a .. 00			db "-!",0              
2c8d				endm 
# End of macro CWHEAD
2c8d			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2c8d					if DEBUG_FORTH_WORDS_KEY 
2c8d						DMARK "-s_" 
2c8d f5				push af  
2c8e 3a a2 2c			ld a, (.dmark)  
2c91 32 65 ee			ld (debug_mark),a  
2c94 3a a3 2c			ld a, (.dmark+1)  
2c97 32 66 ee			ld (debug_mark+1),a  
2c9a 3a a4 2c			ld a, (.dmark+2)  
2c9d 32 67 ee			ld (debug_mark+2),a  
2ca0 18 03			jr .pastdmark  
2ca2 ..			.dmark: db "-s_"  
2ca5 f1			.pastdmark: pop af  
2ca6			endm  
# End of macro DMARK
2ca6						CALLMONITOR 
2ca6 cd 6f ee			call debug_vector  
2ca9				endm  
# End of macro CALLMONITOR
2ca9					endif 
2ca9			 
2ca9					FORTH_DSP_VALUEHL 
2ca9 cd 95 1d			call macro_dsp_valuehl 
2cac				endm 
# End of macro FORTH_DSP_VALUEHL
2cac			 
2cac e5					push hl   ; save address 
2cad			 
2cad					FORTH_DSP_POP 
2cad cd 4d 1e			call macro_forth_dsp_pop 
2cb0				endm 
# End of macro FORTH_DSP_POP
2cb0			 
2cb0					FORTH_DSP_VALUEHL 
2cb0 cd 95 1d			call macro_dsp_valuehl 
2cb3				endm 
# End of macro FORTH_DSP_VALUEHL
2cb3			 
2cb3					; hl contains value to add to byte at a 
2cb3				 
2cb3 eb					ex de, hl 
2cb4			 
2cb4 e1					pop hl 
2cb5			 
2cb5					if DEBUG_FORTH_WORDS 
2cb5						DMARK "DEC" 
2cb5 f5				push af  
2cb6 3a ca 2c			ld a, (.dmark)  
2cb9 32 65 ee			ld (debug_mark),a  
2cbc 3a cb 2c			ld a, (.dmark+1)  
2cbf 32 66 ee			ld (debug_mark+1),a  
2cc2 3a cc 2c			ld a, (.dmark+2)  
2cc5 32 67 ee			ld (debug_mark+2),a  
2cc8 18 03			jr .pastdmark  
2cca ..			.dmark: db "DEC"  
2ccd f1			.pastdmark: pop af  
2cce			endm  
# End of macro DMARK
2cce						CALLMONITOR 
2cce cd 6f ee			call debug_vector  
2cd1				endm  
# End of macro CALLMONITOR
2cd1					endif 
2cd1			 
2cd1 7e					ld a,(hl) 
2cd2 93					sub e 
2cd3 77					ld (hl),a 
2cd4			 
2cd4			 
2cd4					FORTH_DSP_POP 
2cd4 cd 4d 1e			call macro_forth_dsp_pop 
2cd7				endm 
# End of macro FORTH_DSP_POP
2cd7			 
2cd7				       NEXTW 
2cd7 c3 81 1f			jp macro_next 
2cda				endm 
# End of macro NEXTW
2cda			 
2cda			.INC2: 
2cda				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2cda 6f				db WORD_SYS_CORE+91             
2cdb 87 2d			dw .DEC2            
2cdd 04				db 3 + 1 
2cde .. 00			db "+2!",0              
2ce2				endm 
# End of macro CWHEAD
2ce2			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2ce2			 
2ce2					if DEBUG_FORTH_WORDS_KEY 
2ce2						DMARK "+2s" 
2ce2 f5				push af  
2ce3 3a f7 2c			ld a, (.dmark)  
2ce6 32 65 ee			ld (debug_mark),a  
2ce9 3a f8 2c			ld a, (.dmark+1)  
2cec 32 66 ee			ld (debug_mark+1),a  
2cef 3a f9 2c			ld a, (.dmark+2)  
2cf2 32 67 ee			ld (debug_mark+2),a  
2cf5 18 03			jr .pastdmark  
2cf7 ..			.dmark: db "+2s"  
2cfa f1			.pastdmark: pop af  
2cfb			endm  
# End of macro DMARK
2cfb						CALLMONITOR 
2cfb cd 6f ee			call debug_vector  
2cfe				endm  
# End of macro CALLMONITOR
2cfe					endif 
2cfe			 
2cfe					; Address 
2cfe			 
2cfe					FORTH_DSP_VALUEHL 
2cfe cd 95 1d			call macro_dsp_valuehl 
2d01				endm 
# End of macro FORTH_DSP_VALUEHL
2d01			 
2d01 e5					push hl    ; save address 
2d02			 
2d02					; load content into de 
2d02			 
2d02 5e					ld e,(hl) 
2d03 23					inc hl 
2d04 56					ld d, (hl) 
2d05			 
2d05					if DEBUG_FORTH_WORDS 
2d05						DMARK "+2a" 
2d05 f5				push af  
2d06 3a 1a 2d			ld a, (.dmark)  
2d09 32 65 ee			ld (debug_mark),a  
2d0c 3a 1b 2d			ld a, (.dmark+1)  
2d0f 32 66 ee			ld (debug_mark+1),a  
2d12 3a 1c 2d			ld a, (.dmark+2)  
2d15 32 67 ee			ld (debug_mark+2),a  
2d18 18 03			jr .pastdmark  
2d1a ..			.dmark: db "+2a"  
2d1d f1			.pastdmark: pop af  
2d1e			endm  
# End of macro DMARK
2d1e						CALLMONITOR 
2d1e cd 6f ee			call debug_vector  
2d21				endm  
# End of macro CALLMONITOR
2d21					endif 
2d21			 
2d21					FORTH_DSP_POP 
2d21 cd 4d 1e			call macro_forth_dsp_pop 
2d24				endm 
# End of macro FORTH_DSP_POP
2d24			 
2d24					; Get value to add 
2d24			 
2d24					FORTH_DSP_VALUE 
2d24 cd 7e 1d			call macro_forth_dsp_value 
2d27				endm 
# End of macro FORTH_DSP_VALUE
2d27			 
2d27					if DEBUG_FORTH_WORDS 
2d27						DMARK "+2v" 
2d27 f5				push af  
2d28 3a 3c 2d			ld a, (.dmark)  
2d2b 32 65 ee			ld (debug_mark),a  
2d2e 3a 3d 2d			ld a, (.dmark+1)  
2d31 32 66 ee			ld (debug_mark+1),a  
2d34 3a 3e 2d			ld a, (.dmark+2)  
2d37 32 67 ee			ld (debug_mark+2),a  
2d3a 18 03			jr .pastdmark  
2d3c ..			.dmark: db "+2v"  
2d3f f1			.pastdmark: pop af  
2d40			endm  
# End of macro DMARK
2d40						CALLMONITOR 
2d40 cd 6f ee			call debug_vector  
2d43				endm  
# End of macro CALLMONITOR
2d43					endif 
2d43			 
2d43 19					add hl, de 
2d44			 
2d44					if DEBUG_FORTH_WORDS 
2d44						DMARK "+2+" 
2d44 f5				push af  
2d45 3a 59 2d			ld a, (.dmark)  
2d48 32 65 ee			ld (debug_mark),a  
2d4b 3a 5a 2d			ld a, (.dmark+1)  
2d4e 32 66 ee			ld (debug_mark+1),a  
2d51 3a 5b 2d			ld a, (.dmark+2)  
2d54 32 67 ee			ld (debug_mark+2),a  
2d57 18 03			jr .pastdmark  
2d59 ..			.dmark: db "+2+"  
2d5c f1			.pastdmark: pop af  
2d5d			endm  
# End of macro DMARK
2d5d						CALLMONITOR 
2d5d cd 6f ee			call debug_vector  
2d60				endm  
# End of macro CALLMONITOR
2d60					endif 
2d60			 
2d60					; move result to de 
2d60			 
2d60 eb					ex de, hl 
2d61			 
2d61					; Address 
2d61			 
2d61 e1					pop hl 
2d62			 
2d62					; save it back 
2d62			 
2d62 73					ld (hl), e 
2d63 23					inc hl 
2d64 72					ld (hl), d 
2d65			 
2d65					if DEBUG_FORTH_WORDS 
2d65						DMARK "+2e" 
2d65 f5				push af  
2d66 3a 7a 2d			ld a, (.dmark)  
2d69 32 65 ee			ld (debug_mark),a  
2d6c 3a 7b 2d			ld a, (.dmark+1)  
2d6f 32 66 ee			ld (debug_mark+1),a  
2d72 3a 7c 2d			ld a, (.dmark+2)  
2d75 32 67 ee			ld (debug_mark+2),a  
2d78 18 03			jr .pastdmark  
2d7a ..			.dmark: db "+2e"  
2d7d f1			.pastdmark: pop af  
2d7e			endm  
# End of macro DMARK
2d7e						CALLMONITOR 
2d7e cd 6f ee			call debug_vector  
2d81				endm  
# End of macro CALLMONITOR
2d81					endif 
2d81			 
2d81			 
2d81			 
2d81					FORTH_DSP_POP 
2d81 cd 4d 1e			call macro_forth_dsp_pop 
2d84				endm 
# End of macro FORTH_DSP_POP
2d84			 
2d84			 
2d84				       NEXTW 
2d84 c3 81 1f			jp macro_next 
2d87				endm 
# End of macro NEXTW
2d87			 
2d87			.DEC2: 
2d87				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2d87 6f				db WORD_SYS_CORE+91             
2d88 36 2e			dw .GET2            
2d8a 04				db 3 + 1 
2d8b .. 00			db "-2!",0              
2d8f				endm 
# End of macro CWHEAD
2d8f			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2d8f			 
2d8f			 
2d8f					if DEBUG_FORTH_WORDS_KEY 
2d8f						DMARK "-2s" 
2d8f f5				push af  
2d90 3a a4 2d			ld a, (.dmark)  
2d93 32 65 ee			ld (debug_mark),a  
2d96 3a a5 2d			ld a, (.dmark+1)  
2d99 32 66 ee			ld (debug_mark+1),a  
2d9c 3a a6 2d			ld a, (.dmark+2)  
2d9f 32 67 ee			ld (debug_mark+2),a  
2da2 18 03			jr .pastdmark  
2da4 ..			.dmark: db "-2s"  
2da7 f1			.pastdmark: pop af  
2da8			endm  
# End of macro DMARK
2da8						CALLMONITOR 
2da8 cd 6f ee			call debug_vector  
2dab				endm  
# End of macro CALLMONITOR
2dab					endif 
2dab			 
2dab					; Address 
2dab			 
2dab					FORTH_DSP_VALUEHL 
2dab cd 95 1d			call macro_dsp_valuehl 
2dae				endm 
# End of macro FORTH_DSP_VALUEHL
2dae			 
2dae e5					push hl    ; save address 
2daf			 
2daf					; load content into de 
2daf			 
2daf 5e					ld e,(hl) 
2db0 23					inc hl 
2db1 56					ld d, (hl) 
2db2			 
2db2					if DEBUG_FORTH_WORDS 
2db2						DMARK "-2a" 
2db2 f5				push af  
2db3 3a c7 2d			ld a, (.dmark)  
2db6 32 65 ee			ld (debug_mark),a  
2db9 3a c8 2d			ld a, (.dmark+1)  
2dbc 32 66 ee			ld (debug_mark+1),a  
2dbf 3a c9 2d			ld a, (.dmark+2)  
2dc2 32 67 ee			ld (debug_mark+2),a  
2dc5 18 03			jr .pastdmark  
2dc7 ..			.dmark: db "-2a"  
2dca f1			.pastdmark: pop af  
2dcb			endm  
# End of macro DMARK
2dcb						CALLMONITOR 
2dcb cd 6f ee			call debug_vector  
2dce				endm  
# End of macro CALLMONITOR
2dce					endif 
2dce			 
2dce					FORTH_DSP_POP 
2dce cd 4d 1e			call macro_forth_dsp_pop 
2dd1				endm 
# End of macro FORTH_DSP_POP
2dd1			 
2dd1					; Get value to remove 
2dd1			 
2dd1					FORTH_DSP_VALUE 
2dd1 cd 7e 1d			call macro_forth_dsp_value 
2dd4				endm 
# End of macro FORTH_DSP_VALUE
2dd4			 
2dd4					if DEBUG_FORTH_WORDS 
2dd4						DMARK "-2v" 
2dd4 f5				push af  
2dd5 3a e9 2d			ld a, (.dmark)  
2dd8 32 65 ee			ld (debug_mark),a  
2ddb 3a ea 2d			ld a, (.dmark+1)  
2dde 32 66 ee			ld (debug_mark+1),a  
2de1 3a eb 2d			ld a, (.dmark+2)  
2de4 32 67 ee			ld (debug_mark+2),a  
2de7 18 03			jr .pastdmark  
2de9 ..			.dmark: db "-2v"  
2dec f1			.pastdmark: pop af  
2ded			endm  
# End of macro DMARK
2ded						CALLMONITOR 
2ded cd 6f ee			call debug_vector  
2df0				endm  
# End of macro CALLMONITOR
2df0					endif 
2df0			 
2df0 eb					ex de, hl 
2df1 ed 52				sbc hl, de 
2df3			 
2df3					if DEBUG_FORTH_WORDS 
2df3						DMARK "-2d" 
2df3 f5				push af  
2df4 3a 08 2e			ld a, (.dmark)  
2df7 32 65 ee			ld (debug_mark),a  
2dfa 3a 09 2e			ld a, (.dmark+1)  
2dfd 32 66 ee			ld (debug_mark+1),a  
2e00 3a 0a 2e			ld a, (.dmark+2)  
2e03 32 67 ee			ld (debug_mark+2),a  
2e06 18 03			jr .pastdmark  
2e08 ..			.dmark: db "-2d"  
2e0b f1			.pastdmark: pop af  
2e0c			endm  
# End of macro DMARK
2e0c						CALLMONITOR 
2e0c cd 6f ee			call debug_vector  
2e0f				endm  
# End of macro CALLMONITOR
2e0f					endif 
2e0f			 
2e0f					; move result to de 
2e0f			 
2e0f eb					ex de, hl 
2e10			 
2e10					; Address 
2e10			 
2e10 e1					pop hl 
2e11			 
2e11					; save it back 
2e11			 
2e11 73					ld (hl), e 
2e12 23					inc hl 
2e13 72					ld (hl), d 
2e14			 
2e14					if DEBUG_FORTH_WORDS 
2e14						DMARK "-2e" 
2e14 f5				push af  
2e15 3a 29 2e			ld a, (.dmark)  
2e18 32 65 ee			ld (debug_mark),a  
2e1b 3a 2a 2e			ld a, (.dmark+1)  
2e1e 32 66 ee			ld (debug_mark+1),a  
2e21 3a 2b 2e			ld a, (.dmark+2)  
2e24 32 67 ee			ld (debug_mark+2),a  
2e27 18 03			jr .pastdmark  
2e29 ..			.dmark: db "-2e"  
2e2c f1			.pastdmark: pop af  
2e2d			endm  
# End of macro DMARK
2e2d						CALLMONITOR 
2e2d cd 6f ee			call debug_vector  
2e30				endm  
# End of macro CALLMONITOR
2e30					endif 
2e30			 
2e30			 
2e30					FORTH_DSP_POP 
2e30 cd 4d 1e			call macro_forth_dsp_pop 
2e33				endm 
# End of macro FORTH_DSP_POP
2e33			 
2e33			 
2e33			 
2e33				       NEXTW 
2e33 c3 81 1f			jp macro_next 
2e36				endm 
# End of macro NEXTW
2e36			.GET2: 
2e36				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2e36 6f				db WORD_SYS_CORE+91             
2e37 6b 2e			dw .BANG2            
2e39 03				db 2 + 1 
2e3a .. 00			db "2@",0              
2e3d				endm 
# End of macro CWHEAD
2e3d			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2e3d					if DEBUG_FORTH_WORDS_KEY 
2e3d						DMARK "2A_" 
2e3d f5				push af  
2e3e 3a 52 2e			ld a, (.dmark)  
2e41 32 65 ee			ld (debug_mark),a  
2e44 3a 53 2e			ld a, (.dmark+1)  
2e47 32 66 ee			ld (debug_mark+1),a  
2e4a 3a 54 2e			ld a, (.dmark+2)  
2e4d 32 67 ee			ld (debug_mark+2),a  
2e50 18 03			jr .pastdmark  
2e52 ..			.dmark: db "2A_"  
2e55 f1			.pastdmark: pop af  
2e56			endm  
# End of macro DMARK
2e56						CALLMONITOR 
2e56 cd 6f ee			call debug_vector  
2e59				endm  
# End of macro CALLMONITOR
2e59					endif 
2e59			 
2e59					FORTH_DSP_VALUEHL 
2e59 cd 95 1d			call macro_dsp_valuehl 
2e5c				endm 
# End of macro FORTH_DSP_VALUEHL
2e5c			 
2e5c e5					push hl   ; save address 
2e5d			 
2e5d					FORTH_DSP_POP 
2e5d cd 4d 1e			call macro_forth_dsp_pop 
2e60				endm 
# End of macro FORTH_DSP_POP
2e60			 
2e60 e1					pop hl 
2e61			 
2e61 5e					ld e, (hl) 
2e62 23					inc hl 
2e63 56					ld d, (hl) 
2e64			 
2e64 eb					ex de, hl 
2e65			 
2e65 cd 90 1b				call forth_push_numhl 
2e68			 
2e68				       NEXTW 
2e68 c3 81 1f			jp macro_next 
2e6b				endm 
# End of macro NEXTW
2e6b			.BANG2: 
2e6b				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2e6b 6f				db WORD_SYS_CORE+91             
2e6c a3 2e			dw .CONFIG            
2e6e 03				db 2 + 1 
2e6f .. 00			db "2!",0              
2e72				endm 
# End of macro CWHEAD
2e72			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2e72					if DEBUG_FORTH_WORDS_KEY 
2e72						DMARK "2S_" 
2e72 f5				push af  
2e73 3a 87 2e			ld a, (.dmark)  
2e76 32 65 ee			ld (debug_mark),a  
2e79 3a 88 2e			ld a, (.dmark+1)  
2e7c 32 66 ee			ld (debug_mark+1),a  
2e7f 3a 89 2e			ld a, (.dmark+2)  
2e82 32 67 ee			ld (debug_mark+2),a  
2e85 18 03			jr .pastdmark  
2e87 ..			.dmark: db "2S_"  
2e8a f1			.pastdmark: pop af  
2e8b			endm  
# End of macro DMARK
2e8b						CALLMONITOR 
2e8b cd 6f ee			call debug_vector  
2e8e				endm  
# End of macro CALLMONITOR
2e8e					endif 
2e8e			 
2e8e					FORTH_DSP_VALUEHL 
2e8e cd 95 1d			call macro_dsp_valuehl 
2e91				endm 
# End of macro FORTH_DSP_VALUEHL
2e91			 
2e91 e5					push hl   ; save address 
2e92			 
2e92			 
2e92					FORTH_DSP_POP 
2e92 cd 4d 1e			call macro_forth_dsp_pop 
2e95				endm 
# End of macro FORTH_DSP_POP
2e95			 
2e95					 
2e95					FORTH_DSP_VALUEHL 
2e95 cd 95 1d			call macro_dsp_valuehl 
2e98				endm 
# End of macro FORTH_DSP_VALUEHL
2e98			 
2e98					FORTH_DSP_POP 
2e98 cd 4d 1e			call macro_forth_dsp_pop 
2e9b				endm 
# End of macro FORTH_DSP_POP
2e9b			 
2e9b eb					ex de, hl    ; value now in de 
2e9c			 
2e9c e1					pop hl 
2e9d			 
2e9d 73					ld (hl), e 
2e9e			 
2e9e 23					inc hl 
2e9f			 
2e9f 72					ld (hl), d 
2ea0			 
2ea0			 
2ea0				       NEXTW 
2ea0 c3 81 1f			jp macro_next 
2ea3				endm 
# End of macro NEXTW
2ea3			.CONFIG: 
2ea3				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
2ea3 6f				db WORD_SYS_CORE+91             
2ea4 b4 2e			dw .ADTOS            
2ea6 07				db 6 + 1 
2ea7 .. 00			db "CONFIG",0              
2eae				endm 
# End of macro CWHEAD
2eae			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2eae			 
2eae cd 69 13				call config 
2eb1					NEXTW 
2eb1 c3 81 1f			jp macro_next 
2eb4				endm 
# End of macro NEXTW
2eb4			 
2eb4			.ADTOS: 
2eb4				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
2eb4 6f				db WORD_SYS_CORE+91             
2eb5 ca 2e			dw .SBTOS            
2eb7 03				db 2 + 1 
2eb8 .. 00			db "1+",0              
2ebb				endm 
# End of macro CWHEAD
2ebb			; | 1+ ( u -- u )  Increment value on TOS | DONE 
2ebb			 
2ebb					FORTH_DSP_VALUEHL 
2ebb cd 95 1d			call macro_dsp_valuehl 
2ebe				endm 
# End of macro FORTH_DSP_VALUEHL
2ebe e5					push hl 
2ebf			 
2ebf					FORTH_DSP_POP 
2ebf cd 4d 1e			call macro_forth_dsp_pop 
2ec2				endm 
# End of macro FORTH_DSP_POP
2ec2 e1					pop hl 
2ec3			 
2ec3 23					inc hl 
2ec4 cd 90 1b				call forth_push_numhl 
2ec7					 
2ec7					NEXTW 
2ec7 c3 81 1f			jp macro_next 
2eca				endm 
# End of macro NEXTW
2eca			.SBTOS: 
2eca				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
2eca 6f				db WORD_SYS_CORE+91             
2ecb e0 2e			dw .ADSTORE            
2ecd 03				db 2 + 1 
2ece .. 00			db "1-",0              
2ed1				endm 
# End of macro CWHEAD
2ed1			; | 1- ( u -- u )  Decrement value on TOS | DONE 
2ed1			 
2ed1					FORTH_DSP_VALUEHL 
2ed1 cd 95 1d			call macro_dsp_valuehl 
2ed4				endm 
# End of macro FORTH_DSP_VALUEHL
2ed4 e5					push hl 
2ed5			 
2ed5					FORTH_DSP_POP 
2ed5 cd 4d 1e			call macro_forth_dsp_pop 
2ed8				endm 
# End of macro FORTH_DSP_POP
2ed8 e1					pop hl 
2ed9			 
2ed9 2b					dec hl 
2eda cd 90 1b				call forth_push_numhl 
2edd					 
2edd					NEXTW 
2edd c3 81 1f			jp macro_next 
2ee0				endm 
# End of macro NEXTW
2ee0			.ADSTORE: 
2ee0				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
2ee0 6f				db WORD_SYS_CORE+91             
2ee1 f6 2e			dw .ADWSTORE            
2ee3 04				db 3 + 1 
2ee4 .. 00			db "1+!",0              
2ee8				endm 
# End of macro CWHEAD
2ee8			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
2ee8			 
2ee8					FORTH_DSP_VALUEHL 
2ee8 cd 95 1d			call macro_dsp_valuehl 
2eeb				endm 
# End of macro FORTH_DSP_VALUEHL
2eeb e5					push hl 
2eec			 
2eec					FORTH_DSP_POP 
2eec cd 4d 1e			call macro_forth_dsp_pop 
2eef				endm 
# End of macro FORTH_DSP_POP
2eef e1					pop hl 
2ef0			 
2ef0 7e					ld a, (hl) 
2ef1 3c					inc a 
2ef2 77					ld (hl), a 
2ef3					 
2ef3					NEXTW 
2ef3 c3 81 1f			jp macro_next 
2ef6				endm 
# End of macro NEXTW
2ef6			.ADWSTORE: 
2ef6				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
2ef6 6f				db WORD_SYS_CORE+91             
2ef7 14 2f			dw .SBSTORE            
2ef9 05				db 4 + 1 
2efa .. 00			db "1+2!",0              
2eff				endm 
# End of macro CWHEAD
2eff			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
2eff			 
2eff					FORTH_DSP_VALUEHL 
2eff cd 95 1d			call macro_dsp_valuehl 
2f02				endm 
# End of macro FORTH_DSP_VALUEHL
2f02 e5					push hl 
2f03			 
2f03					FORTH_DSP_POP 
2f03 cd 4d 1e			call macro_forth_dsp_pop 
2f06				endm 
# End of macro FORTH_DSP_POP
2f06 e1					pop hl 
2f07			 
2f07 e5					push hl 
2f08			 
2f08 cd 03 1f				call loadwordinhl 
2f0b 23					inc hl 
2f0c			 
2f0c d1					pop de 
2f0d eb					ex de, hl 
2f0e 73					ld (hl), e 
2f0f 23					inc hl 
2f10 72					ld (hl), d 
2f11					 
2f11					NEXTW 
2f11 c3 81 1f			jp macro_next 
2f14				endm 
# End of macro NEXTW
2f14			.SBSTORE: 
2f14				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
2f14 6f				db WORD_SYS_CORE+91             
2f15 2a 2f			dw .SBWSTORE            
2f17 04				db 3 + 1 
2f18 .. 00			db "1-!",0              
2f1c				endm 
# End of macro CWHEAD
2f1c			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
2f1c			 
2f1c					FORTH_DSP_VALUEHL 
2f1c cd 95 1d			call macro_dsp_valuehl 
2f1f				endm 
# End of macro FORTH_DSP_VALUEHL
2f1f e5					push hl 
2f20			 
2f20					FORTH_DSP_POP 
2f20 cd 4d 1e			call macro_forth_dsp_pop 
2f23				endm 
# End of macro FORTH_DSP_POP
2f23 e1					pop hl 
2f24			 
2f24 7e					ld a, (hl) 
2f25 3d					dec a 
2f26 77					ld (hl), a 
2f27					 
2f27					NEXTW 
2f27 c3 81 1f			jp macro_next 
2f2a				endm 
# End of macro NEXTW
2f2a			.SBWSTORE: 
2f2a				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
2f2a 6f				db WORD_SYS_CORE+91             
2f2b 48 2f			dw .ENDCORE            
2f2d 05				db 4 + 1 
2f2e .. 00			db "1-2!",0              
2f33				endm 
# End of macro CWHEAD
2f33			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
2f33			 
2f33					FORTH_DSP_VALUEHL 
2f33 cd 95 1d			call macro_dsp_valuehl 
2f36				endm 
# End of macro FORTH_DSP_VALUEHL
2f36 e5					push hl 
2f37			 
2f37					FORTH_DSP_POP 
2f37 cd 4d 1e			call macro_forth_dsp_pop 
2f3a				endm 
# End of macro FORTH_DSP_POP
2f3a e1					pop hl 
2f3b			 
2f3b e5					push hl 
2f3c			 
2f3c cd 03 1f				call loadwordinhl 
2f3f 2b					dec hl 
2f40			 
2f40 d1					pop de 
2f41 eb					ex de, hl 
2f42 73					ld (hl), e 
2f43 23					inc hl 
2f44 72					ld (hl), d 
2f45					 
2f45					NEXTW 
2f45 c3 81 1f			jp macro_next 
2f48				endm 
# End of macro NEXTW
2f48			.ENDCORE: 
2f48			 
2f48			; eof 
2f48			 
2f48			 
# End of file forth_words_core.asm
2f48			include "forth_words_flow.asm" 
2f48			 
2f48			; | ## Program Flow Words 
2f48			 
2f48			.IF: 
2f48				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f48 1e				db WORD_SYS_CORE+10             
2f49 3d 30			dw .THEN            
2f4b 03				db 2 + 1 
2f4c .. 00			db "IF",0              
2f4f				endm 
# End of macro CWHEAD
2f4f			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f4f			; 
2f4f					if DEBUG_FORTH_WORDS_KEY 
2f4f						DMARK "IF." 
2f4f f5				push af  
2f50 3a 64 2f			ld a, (.dmark)  
2f53 32 65 ee			ld (debug_mark),a  
2f56 3a 65 2f			ld a, (.dmark+1)  
2f59 32 66 ee			ld (debug_mark+1),a  
2f5c 3a 66 2f			ld a, (.dmark+2)  
2f5f 32 67 ee			ld (debug_mark+2),a  
2f62 18 03			jr .pastdmark  
2f64 ..			.dmark: db "IF."  
2f67 f1			.pastdmark: pop af  
2f68			endm  
# End of macro DMARK
2f68						CALLMONITOR 
2f68 cd 6f ee			call debug_vector  
2f6b				endm  
# End of macro CALLMONITOR
2f6b					endif 
2f6b			; eval TOS 
2f6b			 
2f6b				FORTH_DSP_VALUEHL 
2f6b cd 95 1d			call macro_dsp_valuehl 
2f6e				endm 
# End of macro FORTH_DSP_VALUEHL
2f6e			 
2f6e			;	push hl 
2f6e				FORTH_DSP_POP 
2f6e cd 4d 1e			call macro_forth_dsp_pop 
2f71				endm 
# End of macro FORTH_DSP_POP
2f71			;	pop hl 
2f71			 
2f71					if DEBUG_FORTH_WORDS 
2f71						DMARK "IF1" 
2f71 f5				push af  
2f72 3a 86 2f			ld a, (.dmark)  
2f75 32 65 ee			ld (debug_mark),a  
2f78 3a 87 2f			ld a, (.dmark+1)  
2f7b 32 66 ee			ld (debug_mark+1),a  
2f7e 3a 88 2f			ld a, (.dmark+2)  
2f81 32 67 ee			ld (debug_mark+2),a  
2f84 18 03			jr .pastdmark  
2f86 ..			.dmark: db "IF1"  
2f89 f1			.pastdmark: pop af  
2f8a			endm  
# End of macro DMARK
2f8a						CALLMONITOR 
2f8a cd 6f ee			call debug_vector  
2f8d				endm  
# End of macro CALLMONITOR
2f8d					endif 
2f8d b7				or a        ; clear carry flag 
2f8e 11 00 00			ld de, 0 
2f91 eb				ex de,hl 
2f92 ed 52			sbc hl, de 
2f94 c2 1e 30			jp nz, .iftrue 
2f97			 
2f97					if DEBUG_FORTH_WORDS 
2f97						DMARK "IF2" 
2f97 f5				push af  
2f98 3a ac 2f			ld a, (.dmark)  
2f9b 32 65 ee			ld (debug_mark),a  
2f9e 3a ad 2f			ld a, (.dmark+1)  
2fa1 32 66 ee			ld (debug_mark+1),a  
2fa4 3a ae 2f			ld a, (.dmark+2)  
2fa7 32 67 ee			ld (debug_mark+2),a  
2faa 18 03			jr .pastdmark  
2fac ..			.dmark: db "IF2"  
2faf f1			.pastdmark: pop af  
2fb0			endm  
# End of macro DMARK
2fb0						CALLMONITOR 
2fb0 cd 6f ee			call debug_vector  
2fb3				endm  
# End of macro CALLMONITOR
2fb3					endif 
2fb3			 
2fb3			; if not true then skip to THEN 
2fb3			 
2fb3				; TODO get tok_ptr 
2fb3				; TODO consume toks until we get to THEN 
2fb3			 
2fb3 2a bc e5			ld hl, (os_tok_ptr) 
2fb6					if DEBUG_FORTH_WORDS 
2fb6						DMARK "IF3" 
2fb6 f5				push af  
2fb7 3a cb 2f			ld a, (.dmark)  
2fba 32 65 ee			ld (debug_mark),a  
2fbd 3a cc 2f			ld a, (.dmark+1)  
2fc0 32 66 ee			ld (debug_mark+1),a  
2fc3 3a cd 2f			ld a, (.dmark+2)  
2fc6 32 67 ee			ld (debug_mark+2),a  
2fc9 18 03			jr .pastdmark  
2fcb ..			.dmark: db "IF3"  
2fce f1			.pastdmark: pop af  
2fcf			endm  
# End of macro DMARK
2fcf						CALLMONITOR 
2fcf cd 6f ee			call debug_vector  
2fd2				endm  
# End of macro CALLMONITOR
2fd2						 
2fd2					endif 
2fd2 11 19 30			ld de, .ifthen 
2fd5					if DEBUG_FORTH_WORDS 
2fd5						DMARK "IF4" 
2fd5 f5				push af  
2fd6 3a ea 2f			ld a, (.dmark)  
2fd9 32 65 ee			ld (debug_mark),a  
2fdc 3a eb 2f			ld a, (.dmark+1)  
2fdf 32 66 ee			ld (debug_mark+1),a  
2fe2 3a ec 2f			ld a, (.dmark+2)  
2fe5 32 67 ee			ld (debug_mark+2),a  
2fe8 18 03			jr .pastdmark  
2fea ..			.dmark: db "IF4"  
2fed f1			.pastdmark: pop af  
2fee			endm  
# End of macro DMARK
2fee						CALLMONITOR 
2fee cd 6f ee			call debug_vector  
2ff1				endm  
# End of macro CALLMONITOR
2ff1					endif 
2ff1 cd 9c 20			call findnexttok  
2ff4			 
2ff4					if DEBUG_FORTH_WORDS 
2ff4						DMARK "IF5" 
2ff4 f5				push af  
2ff5 3a 09 30			ld a, (.dmark)  
2ff8 32 65 ee			ld (debug_mark),a  
2ffb 3a 0a 30			ld a, (.dmark+1)  
2ffe 32 66 ee			ld (debug_mark+1),a  
3001 3a 0b 30			ld a, (.dmark+2)  
3004 32 67 ee			ld (debug_mark+2),a  
3007 18 03			jr .pastdmark  
3009 ..			.dmark: db "IF5"  
300c f1			.pastdmark: pop af  
300d			endm  
# End of macro DMARK
300d						CALLMONITOR 
300d cd 6f ee			call debug_vector  
3010				endm  
# End of macro CALLMONITOR
3010					endif 
3010				; TODO replace below with ; exec using tok_ptr 
3010 22 bc e5			ld (os_tok_ptr), hl 
3013 c3 12 20			jp exec1 
3016				NEXTW 
3016 c3 81 1f			jp macro_next 
3019				endm 
# End of macro NEXTW
3019			 
3019 .. 00		.ifthen:  db "THEN",0 
301e			 
301e			.iftrue:		 
301e				; Exec next words normally 
301e			 
301e				; if true then exec following IF as normal 
301e					if DEBUG_FORTH_WORDS 
301e						DMARK "IFT" 
301e f5				push af  
301f 3a 33 30			ld a, (.dmark)  
3022 32 65 ee			ld (debug_mark),a  
3025 3a 34 30			ld a, (.dmark+1)  
3028 32 66 ee			ld (debug_mark+1),a  
302b 3a 35 30			ld a, (.dmark+2)  
302e 32 67 ee			ld (debug_mark+2),a  
3031 18 03			jr .pastdmark  
3033 ..			.dmark: db "IFT"  
3036 f1			.pastdmark: pop af  
3037			endm  
# End of macro DMARK
3037						CALLMONITOR 
3037 cd 6f ee			call debug_vector  
303a				endm  
# End of macro CALLMONITOR
303a					endif 
303a			 
303a					NEXTW 
303a c3 81 1f			jp macro_next 
303d				endm 
# End of macro NEXTW
303d			.THEN: 
303d				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
303d 1f				db WORD_SYS_CORE+11             
303e 65 30			dw .ELSE            
3040 05				db 4 + 1 
3041 .. 00			db "THEN",0              
3046				endm 
# End of macro CWHEAD
3046			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
3046					if DEBUG_FORTH_WORDS_KEY 
3046						DMARK "THN" 
3046 f5				push af  
3047 3a 5b 30			ld a, (.dmark)  
304a 32 65 ee			ld (debug_mark),a  
304d 3a 5c 30			ld a, (.dmark+1)  
3050 32 66 ee			ld (debug_mark+1),a  
3053 3a 5d 30			ld a, (.dmark+2)  
3056 32 67 ee			ld (debug_mark+2),a  
3059 18 03			jr .pastdmark  
305b ..			.dmark: db "THN"  
305e f1			.pastdmark: pop af  
305f			endm  
# End of macro DMARK
305f						CALLMONITOR 
305f cd 6f ee			call debug_vector  
3062				endm  
# End of macro CALLMONITOR
3062					endif 
3062					NEXTW 
3062 c3 81 1f			jp macro_next 
3065				endm 
# End of macro NEXTW
3065			.ELSE: 
3065				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3065 20				db WORD_SYS_CORE+12             
3066 8d 30			dw .DO            
3068 03				db 2 + 1 
3069 .. 00			db "ELSE",0              
306e				endm 
# End of macro CWHEAD
306e			; | ELSE ( -- ) Not supported - does nothing | TODO 
306e			 
306e					if DEBUG_FORTH_WORDS_KEY 
306e						DMARK "ELS" 
306e f5				push af  
306f 3a 83 30			ld a, (.dmark)  
3072 32 65 ee			ld (debug_mark),a  
3075 3a 84 30			ld a, (.dmark+1)  
3078 32 66 ee			ld (debug_mark+1),a  
307b 3a 85 30			ld a, (.dmark+2)  
307e 32 67 ee			ld (debug_mark+2),a  
3081 18 03			jr .pastdmark  
3083 ..			.dmark: db "ELS"  
3086 f1			.pastdmark: pop af  
3087			endm  
# End of macro DMARK
3087						CALLMONITOR 
3087 cd 6f ee			call debug_vector  
308a				endm  
# End of macro CALLMONITOR
308a					endif 
308a			 
308a			 
308a					NEXTW 
308a c3 81 1f			jp macro_next 
308d				endm 
# End of macro NEXTW
308d			.DO: 
308d				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
308d 21				db WORD_SYS_CORE+13             
308e b4 31			dw .LOOP            
3090 03				db 2 + 1 
3091 .. 00			db "DO",0              
3094				endm 
# End of macro CWHEAD
3094			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
3094			 
3094					if DEBUG_FORTH_WORDS_KEY 
3094						DMARK "DO." 
3094 f5				push af  
3095 3a a9 30			ld a, (.dmark)  
3098 32 65 ee			ld (debug_mark),a  
309b 3a aa 30			ld a, (.dmark+1)  
309e 32 66 ee			ld (debug_mark+1),a  
30a1 3a ab 30			ld a, (.dmark+2)  
30a4 32 67 ee			ld (debug_mark+2),a  
30a7 18 03			jr .pastdmark  
30a9 ..			.dmark: db "DO."  
30ac f1			.pastdmark: pop af  
30ad			endm  
# End of macro DMARK
30ad						CALLMONITOR 
30ad cd 6f ee			call debug_vector  
30b0				endm  
# End of macro CALLMONITOR
30b0					endif 
30b0			;  push pc to rsp stack past the DO 
30b0			 
30b0 2a bc e5				ld hl, (os_tok_ptr) 
30b3 23					inc hl   ; D 
30b4 23					inc hl  ; O 
30b5 23					inc hl   ; null 
30b6					if DEBUG_FORTH_WORDS 
30b6						DMARK "DO2" 
30b6 f5				push af  
30b7 3a cb 30			ld a, (.dmark)  
30ba 32 65 ee			ld (debug_mark),a  
30bd 3a cc 30			ld a, (.dmark+1)  
30c0 32 66 ee			ld (debug_mark+1),a  
30c3 3a cd 30			ld a, (.dmark+2)  
30c6 32 67 ee			ld (debug_mark+2),a  
30c9 18 03			jr .pastdmark  
30cb ..			.dmark: db "DO2"  
30ce f1			.pastdmark: pop af  
30cf			endm  
# End of macro DMARK
30cf						CALLMONITOR 
30cf cd 6f ee			call debug_vector  
30d2				endm  
# End of macro CALLMONITOR
30d2					endif 
30d2					FORTH_RSP_NEXT 
30d2 cd 37 1b			call macro_forth_rsp_next 
30d5				endm 
# End of macro FORTH_RSP_NEXT
30d5					if DEBUG_FORTH_WORDS 
30d5						DMARK "DO3" 
30d5 f5				push af  
30d6 3a ea 30			ld a, (.dmark)  
30d9 32 65 ee			ld (debug_mark),a  
30dc 3a eb 30			ld a, (.dmark+1)  
30df 32 66 ee			ld (debug_mark+1),a  
30e2 3a ec 30			ld a, (.dmark+2)  
30e5 32 67 ee			ld (debug_mark+2),a  
30e8 18 03			jr .pastdmark  
30ea ..			.dmark: db "DO3"  
30ed f1			.pastdmark: pop af  
30ee			endm  
# End of macro DMARK
30ee						CALLMONITOR 
30ee cd 6f ee			call debug_vector  
30f1				endm  
# End of macro CALLMONITOR
30f1					endif 
30f1			 
30f1					;if DEBUG_FORTH_WORDS 
30f1				;		push hl 
30f1			;		endif  
30f1			 
30f1			; get counters from data stack 
30f1			 
30f1			 
30f1					FORTH_DSP_VALUEHL 
30f1 cd 95 1d			call macro_dsp_valuehl 
30f4				endm 
# End of macro FORTH_DSP_VALUEHL
30f4 e5					push hl		 ; hl now has starting counter which needs to be tos 
30f5			 
30f5					if DEBUG_FORTH_WORDS 
30f5						DMARK "DO4" 
30f5 f5				push af  
30f6 3a 0a 31			ld a, (.dmark)  
30f9 32 65 ee			ld (debug_mark),a  
30fc 3a 0b 31			ld a, (.dmark+1)  
30ff 32 66 ee			ld (debug_mark+1),a  
3102 3a 0c 31			ld a, (.dmark+2)  
3105 32 67 ee			ld (debug_mark+2),a  
3108 18 03			jr .pastdmark  
310a ..			.dmark: db "DO4"  
310d f1			.pastdmark: pop af  
310e			endm  
# End of macro DMARK
310e						CALLMONITOR 
310e cd 6f ee			call debug_vector  
3111				endm  
# End of macro CALLMONITOR
3111					endif 
3111					FORTH_DSP_POP 
3111 cd 4d 1e			call macro_forth_dsp_pop 
3114				endm 
# End of macro FORTH_DSP_POP
3114			 
3114					if DEBUG_FORTH_WORDS 
3114						DMARK "DO5" 
3114 f5				push af  
3115 3a 29 31			ld a, (.dmark)  
3118 32 65 ee			ld (debug_mark),a  
311b 3a 2a 31			ld a, (.dmark+1)  
311e 32 66 ee			ld (debug_mark+1),a  
3121 3a 2b 31			ld a, (.dmark+2)  
3124 32 67 ee			ld (debug_mark+2),a  
3127 18 03			jr .pastdmark  
3129 ..			.dmark: db "DO5"  
312c f1			.pastdmark: pop af  
312d			endm  
# End of macro DMARK
312d						CALLMONITOR 
312d cd 6f ee			call debug_vector  
3130				endm  
# End of macro CALLMONITOR
3130					endif 
3130			 
3130					FORTH_DSP_VALUEHL 
3130 cd 95 1d			call macro_dsp_valuehl 
3133				endm 
# End of macro FORTH_DSP_VALUEHL
3133			;		push hl		 ; hl now has starting limit counter 
3133			 
3133					if DEBUG_FORTH_WORDS 
3133						DMARK "DO6" 
3133 f5				push af  
3134 3a 48 31			ld a, (.dmark)  
3137 32 65 ee			ld (debug_mark),a  
313a 3a 49 31			ld a, (.dmark+1)  
313d 32 66 ee			ld (debug_mark+1),a  
3140 3a 4a 31			ld a, (.dmark+2)  
3143 32 67 ee			ld (debug_mark+2),a  
3146 18 03			jr .pastdmark  
3148 ..			.dmark: db "DO6"  
314b f1			.pastdmark: pop af  
314c			endm  
# End of macro DMARK
314c						CALLMONITOR 
314c cd 6f ee			call debug_vector  
314f				endm  
# End of macro CALLMONITOR
314f					endif 
314f					FORTH_DSP_POP 
314f cd 4d 1e			call macro_forth_dsp_pop 
3152				endm 
# End of macro FORTH_DSP_POP
3152			 
3152			; put counters on the loop stack 
3152			 
3152			;		pop hl			 ; limit counter 
3152 d1					pop de			; start counter 
3153			 
3153					; push limit counter 
3153			 
3153					if DEBUG_FORTH_WORDS 
3153						DMARK "DO7" 
3153 f5				push af  
3154 3a 68 31			ld a, (.dmark)  
3157 32 65 ee			ld (debug_mark),a  
315a 3a 69 31			ld a, (.dmark+1)  
315d 32 66 ee			ld (debug_mark+1),a  
3160 3a 6a 31			ld a, (.dmark+2)  
3163 32 67 ee			ld (debug_mark+2),a  
3166 18 03			jr .pastdmark  
3168 ..			.dmark: db "DO7"  
316b f1			.pastdmark: pop af  
316c			endm  
# End of macro DMARK
316c						CALLMONITOR 
316c cd 6f ee			call debug_vector  
316f				endm  
# End of macro CALLMONITOR
316f					endif 
316f					FORTH_LOOP_NEXT 
316f cd c6 1d			call macro_forth_loop_next 
3172				endm 
# End of macro FORTH_LOOP_NEXT
3172			 
3172					; push start counter 
3172			 
3172 eb					ex de, hl 
3173					if DEBUG_FORTH_WORDS 
3173						DMARK "DO7" 
3173 f5				push af  
3174 3a 88 31			ld a, (.dmark)  
3177 32 65 ee			ld (debug_mark),a  
317a 3a 89 31			ld a, (.dmark+1)  
317d 32 66 ee			ld (debug_mark+1),a  
3180 3a 8a 31			ld a, (.dmark+2)  
3183 32 67 ee			ld (debug_mark+2),a  
3186 18 03			jr .pastdmark  
3188 ..			.dmark: db "DO7"  
318b f1			.pastdmark: pop af  
318c			endm  
# End of macro DMARK
318c						CALLMONITOR 
318c cd 6f ee			call debug_vector  
318f				endm  
# End of macro CALLMONITOR
318f					endif 
318f					FORTH_LOOP_NEXT 
318f cd c6 1d			call macro_forth_loop_next 
3192				endm 
# End of macro FORTH_LOOP_NEXT
3192			 
3192			 
3192					; init first round of I counter 
3192			 
3192 22 e0 e5				ld (os_current_i), hl 
3195			 
3195					if DEBUG_FORTH_WORDS 
3195						DMARK "DO8" 
3195 f5				push af  
3196 3a aa 31			ld a, (.dmark)  
3199 32 65 ee			ld (debug_mark),a  
319c 3a ab 31			ld a, (.dmark+1)  
319f 32 66 ee			ld (debug_mark+1),a  
31a2 3a ac 31			ld a, (.dmark+2)  
31a5 32 67 ee			ld (debug_mark+2),a  
31a8 18 03			jr .pastdmark  
31aa ..			.dmark: db "DO8"  
31ad f1			.pastdmark: pop af  
31ae			endm  
# End of macro DMARK
31ae						CALLMONITOR 
31ae cd 6f ee			call debug_vector  
31b1				endm  
# End of macro CALLMONITOR
31b1					endif 
31b1			 
31b1					NEXTW 
31b1 c3 81 1f			jp macro_next 
31b4				endm 
# End of macro NEXTW
31b4			.LOOP: 
31b4				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
31b4 22				db WORD_SYS_CORE+14             
31b5 cc 32			dw .I            
31b7 05				db 4 + 1 
31b8 .. 00			db "LOOP",0              
31bd				endm 
# End of macro CWHEAD
31bd			; | LOOP ( -- ) Increment and test loop counter  | DONE 
31bd			 
31bd				; pop tos as current loop count to hl 
31bd			 
31bd				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
31bd			 
31bd				FORTH_LOOP_TOS 
31bd cd f9 1d			call macro_forth_loop_tos 
31c0				endm 
# End of macro FORTH_LOOP_TOS
31c0 e5				push hl 
31c1			 
31c1					if DEBUG_FORTH_WORDS_KEY 
31c1						DMARK "LOP" 
31c1 f5				push af  
31c2 3a d6 31			ld a, (.dmark)  
31c5 32 65 ee			ld (debug_mark),a  
31c8 3a d7 31			ld a, (.dmark+1)  
31cb 32 66 ee			ld (debug_mark+1),a  
31ce 3a d8 31			ld a, (.dmark+2)  
31d1 32 67 ee			ld (debug_mark+2),a  
31d4 18 03			jr .pastdmark  
31d6 ..			.dmark: db "LOP"  
31d9 f1			.pastdmark: pop af  
31da			endm  
# End of macro DMARK
31da						CALLMONITOR 
31da cd 6f ee			call debug_vector  
31dd				endm  
# End of macro CALLMONITOR
31dd					endif 
31dd				; next item on the stack is the limit. get it 
31dd			 
31dd			 
31dd				FORTH_LOOP_POP 
31dd cd 03 1e			call macro_forth_loop_pop 
31e0				endm 
# End of macro FORTH_LOOP_POP
31e0			 
31e0				FORTH_LOOP_TOS 
31e0 cd f9 1d			call macro_forth_loop_tos 
31e3				endm 
# End of macro FORTH_LOOP_TOS
31e3			 
31e3 d1				pop de		 ; de = i, hl = limit 
31e4			 
31e4					if DEBUG_FORTH_WORDS 
31e4						DMARK "LP1" 
31e4 f5				push af  
31e5 3a f9 31			ld a, (.dmark)  
31e8 32 65 ee			ld (debug_mark),a  
31eb 3a fa 31			ld a, (.dmark+1)  
31ee 32 66 ee			ld (debug_mark+1),a  
31f1 3a fb 31			ld a, (.dmark+2)  
31f4 32 67 ee			ld (debug_mark+2),a  
31f7 18 03			jr .pastdmark  
31f9 ..			.dmark: db "LP1"  
31fc f1			.pastdmark: pop af  
31fd			endm  
# End of macro DMARK
31fd						CALLMONITOR 
31fd cd 6f ee			call debug_vector  
3200				endm  
# End of macro CALLMONITOR
3200					endif 
3200			 
3200				; go back to previous word 
3200			 
3200 d5				push de    ; save I for inc later 
3201			 
3201			 
3201				; get limit 
3201				;  is I at limit? 
3201			 
3201			 
3201					if DEBUG_FORTH_WORDS 
3201						DMARK "LP1" 
3201 f5				push af  
3202 3a 16 32			ld a, (.dmark)  
3205 32 65 ee			ld (debug_mark),a  
3208 3a 17 32			ld a, (.dmark+1)  
320b 32 66 ee			ld (debug_mark+1),a  
320e 3a 18 32			ld a, (.dmark+2)  
3211 32 67 ee			ld (debug_mark+2),a  
3214 18 03			jr .pastdmark  
3216 ..			.dmark: db "LP1"  
3219 f1			.pastdmark: pop af  
321a			endm  
# End of macro DMARK
321a						CALLMONITOR 
321a cd 6f ee			call debug_vector  
321d				endm  
# End of macro CALLMONITOR
321d					endif 
321d			 
321d ed 52			sbc hl, de 
321f			 
321f			 
321f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
321f			 
321f 20 26				jr nz, .loopnotdone 
3221			 
3221 e1				pop hl   ; get rid of saved I 
3222				FORTH_LOOP_POP     ; get rid of limit 
3222 cd 03 1e			call macro_forth_loop_pop 
3225				endm 
# End of macro FORTH_LOOP_POP
3225			 
3225				FORTH_RSP_POP     ; get rid of DO ptr 
3225 cd 58 1b			call macro_forth_rsp_pop 
3228				endm 
# End of macro FORTH_RSP_POP
3228			 
3228			if DEBUG_FORTH_WORDS 
3228						DMARK "LP>" 
3228 f5				push af  
3229 3a 3d 32			ld a, (.dmark)  
322c 32 65 ee			ld (debug_mark),a  
322f 3a 3e 32			ld a, (.dmark+1)  
3232 32 66 ee			ld (debug_mark+1),a  
3235 3a 3f 32			ld a, (.dmark+2)  
3238 32 67 ee			ld (debug_mark+2),a  
323b 18 03			jr .pastdmark  
323d ..			.dmark: db "LP>"  
3240 f1			.pastdmark: pop af  
3241			endm  
# End of macro DMARK
3241				CALLMONITOR 
3241 cd 6f ee			call debug_vector  
3244				endm  
# End of macro CALLMONITOR
3244			endif 
3244			 
3244					NEXTW 
3244 c3 81 1f			jp macro_next 
3247				endm 
# End of macro NEXTW
3247				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3247			 
3247			.loopnotdone: 
3247			 
3247 e1				pop hl    ; get I 
3248 23				inc hl 
3249			 
3249			   	; save new I 
3249			 
3249			 
3249					; set I counter 
3249			 
3249 22 e0 e5				ld (os_current_i), hl 
324c			 
324c					if DEBUG_FORTH_WORDS 
324c						DMARK "LPN" 
324c f5				push af  
324d 3a 61 32			ld a, (.dmark)  
3250 32 65 ee			ld (debug_mark),a  
3253 3a 62 32			ld a, (.dmark+1)  
3256 32 66 ee			ld (debug_mark+1),a  
3259 3a 63 32			ld a, (.dmark+2)  
325c 32 67 ee			ld (debug_mark+2),a  
325f 18 03			jr .pastdmark  
3261 ..			.dmark: db "LPN"  
3264 f1			.pastdmark: pop af  
3265			endm  
# End of macro DMARK
3265					CALLMONITOR 
3265 cd 6f ee			call debug_vector  
3268				endm  
# End of macro CALLMONITOR
3268					endif 
3268					 
3268				FORTH_LOOP_NEXT 
3268 cd c6 1d			call macro_forth_loop_next 
326b				endm 
# End of macro FORTH_LOOP_NEXT
326b			 
326b			 
326b					if DEBUG_FORTH_WORDS 
326b eb						ex de,hl 
326c					endif 
326c			 
326c			;	; get DO ptr 
326c			; 
326c					if DEBUG_FORTH_WORDS 
326c						DMARK "LP7" 
326c f5				push af  
326d 3a 81 32			ld a, (.dmark)  
3270 32 65 ee			ld (debug_mark),a  
3273 3a 82 32			ld a, (.dmark+1)  
3276 32 66 ee			ld (debug_mark+1),a  
3279 3a 83 32			ld a, (.dmark+2)  
327c 32 67 ee			ld (debug_mark+2),a  
327f 18 03			jr .pastdmark  
3281 ..			.dmark: db "LP7"  
3284 f1			.pastdmark: pop af  
3285			endm  
# End of macro DMARK
3285					CALLMONITOR 
3285 cd 6f ee			call debug_vector  
3288				endm  
# End of macro CALLMONITOR
3288					endif 
3288				FORTH_RSP_TOS 
3288 cd 4e 1b			call macro_forth_rsp_tos 
328b				endm 
# End of macro FORTH_RSP_TOS
328b			 
328b					if DEBUG_FORTH_WORDS 
328b						DMARK "LP8" 
328b f5				push af  
328c 3a a0 32			ld a, (.dmark)  
328f 32 65 ee			ld (debug_mark),a  
3292 3a a1 32			ld a, (.dmark+1)  
3295 32 66 ee			ld (debug_mark+1),a  
3298 3a a2 32			ld a, (.dmark+2)  
329b 32 67 ee			ld (debug_mark+2),a  
329e 18 03			jr .pastdmark  
32a0 ..			.dmark: db "LP8"  
32a3 f1			.pastdmark: pop af  
32a4			endm  
# End of macro DMARK
32a4					CALLMONITOR 
32a4 cd 6f ee			call debug_vector  
32a7				endm  
# End of macro CALLMONITOR
32a7					endif 
32a7				;push hl 
32a7			 
32a7				; not going to DO any more 
32a7				; get rid of the RSP pointer as DO will add it back in 
32a7				;FORTH_RSP_POP 
32a7				;pop hl 
32a7			 
32a7				;ld hl,(cli_ret_sp) 
32a7				;ld e, (hl) 
32a7				;inc hl 
32a7				;ld d, (hl) 
32a7				;ex de,hl 
32a7 22 bc e5			ld (os_tok_ptr), hl 
32aa					if DEBUG_FORTH_WORDS 
32aa						DMARK "LP<" 
32aa f5				push af  
32ab 3a bf 32			ld a, (.dmark)  
32ae 32 65 ee			ld (debug_mark),a  
32b1 3a c0 32			ld a, (.dmark+1)  
32b4 32 66 ee			ld (debug_mark+1),a  
32b7 3a c1 32			ld a, (.dmark+2)  
32ba 32 67 ee			ld (debug_mark+2),a  
32bd 18 03			jr .pastdmark  
32bf ..			.dmark: db "LP<"  
32c2 f1			.pastdmark: pop af  
32c3			endm  
# End of macro DMARK
32c3					CALLMONITOR 
32c3 cd 6f ee			call debug_vector  
32c6				endm  
# End of macro CALLMONITOR
32c6				endif 
32c6 c3 12 20			jp exec1 
32c9			 
32c9					 
32c9			 
32c9			 
32c9					NEXTW 
32c9 c3 81 1f			jp macro_next 
32cc				endm 
# End of macro NEXTW
32cc			.I:  
32cc			 
32cc				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
32cc 5e				db WORD_SYS_CORE+74             
32cd f7 32			dw .DLOOP            
32cf 02				db 1 + 1 
32d0 .. 00			db "I",0              
32d2				endm 
# End of macro CWHEAD
32d2			; | I ( -- ) Current loop counter | DONE 
32d2					if DEBUG_FORTH_WORDS_KEY 
32d2						DMARK "I.." 
32d2 f5				push af  
32d3 3a e7 32			ld a, (.dmark)  
32d6 32 65 ee			ld (debug_mark),a  
32d9 3a e8 32			ld a, (.dmark+1)  
32dc 32 66 ee			ld (debug_mark+1),a  
32df 3a e9 32			ld a, (.dmark+2)  
32e2 32 67 ee			ld (debug_mark+2),a  
32e5 18 03			jr .pastdmark  
32e7 ..			.dmark: db "I.."  
32ea f1			.pastdmark: pop af  
32eb			endm  
# End of macro DMARK
32eb						CALLMONITOR 
32eb cd 6f ee			call debug_vector  
32ee				endm  
# End of macro CALLMONITOR
32ee					endif 
32ee			 
32ee 2a e0 e5				ld hl,(os_current_i) 
32f1 cd 90 1b				call forth_push_numhl 
32f4			 
32f4					NEXTW 
32f4 c3 81 1f			jp macro_next 
32f7				endm 
# End of macro NEXTW
32f7			.DLOOP: 
32f7				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
32f7 5f				db WORD_SYS_CORE+75             
32f8 d8 33			dw .REPEAT            
32fa 06				db 5 + 1 
32fb .. 00			db "-LOOP",0              
3301				endm 
# End of macro CWHEAD
3301			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3301				; pop tos as current loop count to hl 
3301					if DEBUG_FORTH_WORDS_KEY 
3301						DMARK "-LP" 
3301 f5				push af  
3302 3a 16 33			ld a, (.dmark)  
3305 32 65 ee			ld (debug_mark),a  
3308 3a 17 33			ld a, (.dmark+1)  
330b 32 66 ee			ld (debug_mark+1),a  
330e 3a 18 33			ld a, (.dmark+2)  
3311 32 67 ee			ld (debug_mark+2),a  
3314 18 03			jr .pastdmark  
3316 ..			.dmark: db "-LP"  
3319 f1			.pastdmark: pop af  
331a			endm  
# End of macro DMARK
331a						CALLMONITOR 
331a cd 6f ee			call debug_vector  
331d				endm  
# End of macro CALLMONITOR
331d					endif 
331d			 
331d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
331d			 
331d				FORTH_LOOP_TOS 
331d cd f9 1d			call macro_forth_loop_tos 
3320				endm 
# End of macro FORTH_LOOP_TOS
3320 e5				push hl 
3321			 
3321					if DEBUG_FORTH_WORDS 
3321						DMARK "-LP" 
3321 f5				push af  
3322 3a 36 33			ld a, (.dmark)  
3325 32 65 ee			ld (debug_mark),a  
3328 3a 37 33			ld a, (.dmark+1)  
332b 32 66 ee			ld (debug_mark+1),a  
332e 3a 38 33			ld a, (.dmark+2)  
3331 32 67 ee			ld (debug_mark+2),a  
3334 18 03			jr .pastdmark  
3336 ..			.dmark: db "-LP"  
3339 f1			.pastdmark: pop af  
333a			endm  
# End of macro DMARK
333a						CALLMONITOR 
333a cd 6f ee			call debug_vector  
333d				endm  
# End of macro CALLMONITOR
333d					endif 
333d				; next item on the stack is the limit. get it 
333d			 
333d			 
333d				FORTH_LOOP_POP 
333d cd 03 1e			call macro_forth_loop_pop 
3340				endm 
# End of macro FORTH_LOOP_POP
3340			 
3340				FORTH_LOOP_TOS 
3340 cd f9 1d			call macro_forth_loop_tos 
3343				endm 
# End of macro FORTH_LOOP_TOS
3343			 
3343 d1				pop de		 ; de = i, hl = limit 
3344			 
3344					if DEBUG_FORTH_WORDS 
3344						DMARK "-L1" 
3344 f5				push af  
3345 3a 59 33			ld a, (.dmark)  
3348 32 65 ee			ld (debug_mark),a  
334b 3a 5a 33			ld a, (.dmark+1)  
334e 32 66 ee			ld (debug_mark+1),a  
3351 3a 5b 33			ld a, (.dmark+2)  
3354 32 67 ee			ld (debug_mark+2),a  
3357 18 03			jr .pastdmark  
3359 ..			.dmark: db "-L1"  
335c f1			.pastdmark: pop af  
335d			endm  
# End of macro DMARK
335d						CALLMONITOR 
335d cd 6f ee			call debug_vector  
3360				endm  
# End of macro CALLMONITOR
3360					endif 
3360			 
3360				; go back to previous word 
3360			 
3360 d5				push de    ; save I for inc later 
3361			 
3361			 
3361				; get limit 
3361				;  is I at limit? 
3361			 
3361			 
3361					if DEBUG_FORTH_WORDS 
3361						DMARK "-L1" 
3361 f5				push af  
3362 3a 76 33			ld a, (.dmark)  
3365 32 65 ee			ld (debug_mark),a  
3368 3a 77 33			ld a, (.dmark+1)  
336b 32 66 ee			ld (debug_mark+1),a  
336e 3a 78 33			ld a, (.dmark+2)  
3371 32 67 ee			ld (debug_mark+2),a  
3374 18 03			jr .pastdmark  
3376 ..			.dmark: db "-L1"  
3379 f1			.pastdmark: pop af  
337a			endm  
# End of macro DMARK
337a						CALLMONITOR 
337a cd 6f ee			call debug_vector  
337d				endm  
# End of macro CALLMONITOR
337d					endif 
337d			 
337d ed 52			sbc hl, de 
337f			 
337f			 
337f				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
337f			 
337f 20 26				jr nz, .mloopnotdone 
3381			 
3381 e1				pop hl   ; get rid of saved I 
3382				FORTH_LOOP_POP     ; get rid of limit 
3382 cd 03 1e			call macro_forth_loop_pop 
3385				endm 
# End of macro FORTH_LOOP_POP
3385			 
3385				FORTH_RSP_POP     ; get rid of DO ptr 
3385 cd 58 1b			call macro_forth_rsp_pop 
3388				endm 
# End of macro FORTH_RSP_POP
3388			 
3388			if DEBUG_FORTH_WORDS 
3388						DMARK "-L>" 
3388 f5				push af  
3389 3a 9d 33			ld a, (.dmark)  
338c 32 65 ee			ld (debug_mark),a  
338f 3a 9e 33			ld a, (.dmark+1)  
3392 32 66 ee			ld (debug_mark+1),a  
3395 3a 9f 33			ld a, (.dmark+2)  
3398 32 67 ee			ld (debug_mark+2),a  
339b 18 03			jr .pastdmark  
339d ..			.dmark: db "-L>"  
33a0 f1			.pastdmark: pop af  
33a1			endm  
# End of macro DMARK
33a1				CALLMONITOR 
33a1 cd 6f ee			call debug_vector  
33a4				endm  
# End of macro CALLMONITOR
33a4			endif 
33a4			 
33a4					NEXTW 
33a4 c3 81 1f			jp macro_next 
33a7				endm 
# End of macro NEXTW
33a7				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
33a7			 
33a7			.mloopnotdone: 
33a7			 
33a7 e1				pop hl    ; get I 
33a8 2b				dec hl 
33a9			 
33a9			   	; save new I 
33a9			 
33a9			 
33a9					; set I counter 
33a9			 
33a9 22 e0 e5				ld (os_current_i), hl 
33ac			 
33ac					 
33ac				FORTH_LOOP_NEXT 
33ac cd c6 1d			call macro_forth_loop_next 
33af				endm 
# End of macro FORTH_LOOP_NEXT
33af			 
33af			 
33af					if DEBUG_FORTH_WORDS 
33af eb						ex de,hl 
33b0					endif 
33b0			 
33b0			;	; get DO ptr 
33b0			; 
33b0				FORTH_RSP_TOS 
33b0 cd 4e 1b			call macro_forth_rsp_tos 
33b3				endm 
# End of macro FORTH_RSP_TOS
33b3			 
33b3				;push hl 
33b3			 
33b3				; not going to DO any more 
33b3				; get rid of the RSP pointer as DO will add it back in 
33b3				;FORTH_RSP_POP 
33b3				;pop hl 
33b3			 
33b3			 
33b3 22 bc e5			ld (os_tok_ptr), hl 
33b6					if DEBUG_FORTH_WORDS 
33b6						DMARK "-L<" 
33b6 f5				push af  
33b7 3a cb 33			ld a, (.dmark)  
33ba 32 65 ee			ld (debug_mark),a  
33bd 3a cc 33			ld a, (.dmark+1)  
33c0 32 66 ee			ld (debug_mark+1),a  
33c3 3a cd 33			ld a, (.dmark+2)  
33c6 32 67 ee			ld (debug_mark+2),a  
33c9 18 03			jr .pastdmark  
33cb ..			.dmark: db "-L<"  
33ce f1			.pastdmark: pop af  
33cf			endm  
# End of macro DMARK
33cf					CALLMONITOR 
33cf cd 6f ee			call debug_vector  
33d2				endm  
# End of macro CALLMONITOR
33d2				endif 
33d2 c3 12 20			jp exec1 
33d5			 
33d5					 
33d5			 
33d5			 
33d5			 
33d5				NEXTW 
33d5 c3 81 1f			jp macro_next 
33d8				endm 
# End of macro NEXTW
33d8			 
33d8			 
33d8			 
33d8			 
33d8			.REPEAT: 
33d8				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
33d8 71				db WORD_SYS_CORE+93             
33d9 2b 34			dw .UNTIL            
33db 06				db 5 + 1 
33dc .. 00			db "REPEAT",0              
33e3				endm 
# End of macro CWHEAD
33e3			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
33e3			;  push pc to rsp stack past the REPEAT 
33e3					if DEBUG_FORTH_WORDS_KEY 
33e3						DMARK "REP" 
33e3 f5				push af  
33e4 3a f8 33			ld a, (.dmark)  
33e7 32 65 ee			ld (debug_mark),a  
33ea 3a f9 33			ld a, (.dmark+1)  
33ed 32 66 ee			ld (debug_mark+1),a  
33f0 3a fa 33			ld a, (.dmark+2)  
33f3 32 67 ee			ld (debug_mark+2),a  
33f6 18 03			jr .pastdmark  
33f8 ..			.dmark: db "REP"  
33fb f1			.pastdmark: pop af  
33fc			endm  
# End of macro DMARK
33fc						CALLMONITOR 
33fc cd 6f ee			call debug_vector  
33ff				endm  
# End of macro CALLMONITOR
33ff					endif 
33ff			 
33ff 2a bc e5				ld hl, (os_tok_ptr) 
3402 23					inc hl   ; R 
3403 23					inc hl  ; E 
3404 23					inc hl   ; P 
3405 23					inc hl   ; E 
3406 23					inc hl   ; A 
3407 23					inc hl   ; T 
3408 23					inc hl   ; zero 
3409					FORTH_RSP_NEXT 
3409 cd 37 1b			call macro_forth_rsp_next 
340c				endm 
# End of macro FORTH_RSP_NEXT
340c			 
340c			 
340c					if DEBUG_FORTH_WORDS 
340c						DMARK "REP" 
340c f5				push af  
340d 3a 21 34			ld a, (.dmark)  
3410 32 65 ee			ld (debug_mark),a  
3413 3a 22 34			ld a, (.dmark+1)  
3416 32 66 ee			ld (debug_mark+1),a  
3419 3a 23 34			ld a, (.dmark+2)  
341c 32 67 ee			ld (debug_mark+2),a  
341f 18 03			jr .pastdmark  
3421 ..			.dmark: db "REP"  
3424 f1			.pastdmark: pop af  
3425			endm  
# End of macro DMARK
3425						;pop bc    ; TODO BUG ?????? what is this for???? 
3425						CALLMONITOR 
3425 cd 6f ee			call debug_vector  
3428				endm  
# End of macro CALLMONITOR
3428					endif 
3428			 
3428					NEXTW 
3428 c3 81 1f			jp macro_next 
342b				endm 
# End of macro NEXTW
342b			;	       NEXTW 
342b			 
342b			.UNTIL: 
342b				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
342b 72				db WORD_SYS_CORE+94             
342c c2 34			dw .ENDFLOW            
342e 06				db 5 + 1 
342f .. 00			db "UNTIL",0              
3435				endm 
# End of macro CWHEAD
3435			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3435			 
3435				; pop tos as check 
3435			 
3435				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3435			 
3435				FORTH_DSP_VALUEHL 
3435 cd 95 1d			call macro_dsp_valuehl 
3438				endm 
# End of macro FORTH_DSP_VALUEHL
3438			 
3438					if DEBUG_FORTH_WORDS_KEY 
3438						DMARK "UNT" 
3438 f5				push af  
3439 3a 4d 34			ld a, (.dmark)  
343c 32 65 ee			ld (debug_mark),a  
343f 3a 4e 34			ld a, (.dmark+1)  
3442 32 66 ee			ld (debug_mark+1),a  
3445 3a 4f 34			ld a, (.dmark+2)  
3448 32 67 ee			ld (debug_mark+2),a  
344b 18 03			jr .pastdmark  
344d ..			.dmark: db "UNT"  
3450 f1			.pastdmark: pop af  
3451			endm  
# End of macro DMARK
3451						CALLMONITOR 
3451 cd 6f ee			call debug_vector  
3454				endm  
# End of macro CALLMONITOR
3454					endif 
3454			 
3454			;	push hl 
3454				FORTH_DSP_POP 
3454 cd 4d 1e			call macro_forth_dsp_pop 
3457				endm 
# End of macro FORTH_DSP_POP
3457			 
3457			;	pop hl 
3457			 
3457				; test if true 
3457			 
3457 cd 1e 0e			call ishlzero 
345a			;	ld a,l 
345a			;	add h 
345a			; 
345a			;	cp 0 
345a			 
345a 20 3e			jr nz, .untilnotdone 
345c			 
345c					if DEBUG_FORTH_WORDS 
345c						DMARK "UNf" 
345c f5				push af  
345d 3a 71 34			ld a, (.dmark)  
3460 32 65 ee			ld (debug_mark),a  
3463 3a 72 34			ld a, (.dmark+1)  
3466 32 66 ee			ld (debug_mark+1),a  
3469 3a 73 34			ld a, (.dmark+2)  
346c 32 67 ee			ld (debug_mark+2),a  
346f 18 03			jr .pastdmark  
3471 ..			.dmark: db "UNf"  
3474 f1			.pastdmark: pop af  
3475			endm  
# End of macro DMARK
3475						CALLMONITOR 
3475 cd 6f ee			call debug_vector  
3478				endm  
# End of macro CALLMONITOR
3478					endif 
3478			 
3478			 
3478			 
3478				FORTH_RSP_POP     ; get rid of DO ptr 
3478 cd 58 1b			call macro_forth_rsp_pop 
347b				endm 
# End of macro FORTH_RSP_POP
347b			 
347b			if DEBUG_FORTH_WORDS 
347b						DMARK "UN>" 
347b f5				push af  
347c 3a 90 34			ld a, (.dmark)  
347f 32 65 ee			ld (debug_mark),a  
3482 3a 91 34			ld a, (.dmark+1)  
3485 32 66 ee			ld (debug_mark+1),a  
3488 3a 92 34			ld a, (.dmark+2)  
348b 32 67 ee			ld (debug_mark+2),a  
348e 18 03			jr .pastdmark  
3490 ..			.dmark: db "UN>"  
3493 f1			.pastdmark: pop af  
3494			endm  
# End of macro DMARK
3494				CALLMONITOR 
3494 cd 6f ee			call debug_vector  
3497				endm  
# End of macro CALLMONITOR
3497			endif 
3497			 
3497					NEXTW 
3497 c3 81 1f			jp macro_next 
349a				endm 
# End of macro NEXTW
349a				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
349a			 
349a			.untilnotdone: 
349a			 
349a			 
349a			;	; get DO ptr 
349a			; 
349a				FORTH_RSP_TOS 
349a cd 4e 1b			call macro_forth_rsp_tos 
349d				endm 
# End of macro FORTH_RSP_TOS
349d			 
349d				;push hl 
349d			 
349d				; not going to DO any more 
349d				; get rid of the RSP pointer as DO will add it back in 
349d				;FORTH_RSP_POP 
349d				;pop hl 
349d			 
349d			 
349d 22 bc e5			ld (os_tok_ptr), hl 
34a0					if DEBUG_FORTH_WORDS 
34a0						DMARK "UN<" 
34a0 f5				push af  
34a1 3a b5 34			ld a, (.dmark)  
34a4 32 65 ee			ld (debug_mark),a  
34a7 3a b6 34			ld a, (.dmark+1)  
34aa 32 66 ee			ld (debug_mark+1),a  
34ad 3a b7 34			ld a, (.dmark+2)  
34b0 32 67 ee			ld (debug_mark+2),a  
34b3 18 03			jr .pastdmark  
34b5 ..			.dmark: db "UN<"  
34b8 f1			.pastdmark: pop af  
34b9			endm  
# End of macro DMARK
34b9					CALLMONITOR 
34b9 cd 6f ee			call debug_vector  
34bc				endm  
# End of macro CALLMONITOR
34bc				endif 
34bc c3 12 20			jp exec1 
34bf			 
34bf					 
34bf			 
34bf			 
34bf					NEXTW 
34bf c3 81 1f			jp macro_next 
34c2				endm 
# End of macro NEXTW
34c2			 
34c2			 
34c2			.ENDFLOW: 
34c2			 
34c2			; eof 
34c2			 
# End of file forth_words_flow.asm
34c2			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
34c2			include "forth_words_logic.asm" 
34c2			 
34c2			; | ## Logic Words 
34c2			 
34c2			.NOT: 
34c2				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
34c2 2d				db WORD_SYS_CORE+25             
34c3 0a 35			dw .IS            
34c5 04				db 3 + 1 
34c6 .. 00			db "NOT",0              
34ca				endm 
# End of macro CWHEAD
34ca			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
34ca					if DEBUG_FORTH_WORDS_KEY 
34ca						DMARK "NOT" 
34ca f5				push af  
34cb 3a df 34			ld a, (.dmark)  
34ce 32 65 ee			ld (debug_mark),a  
34d1 3a e0 34			ld a, (.dmark+1)  
34d4 32 66 ee			ld (debug_mark+1),a  
34d7 3a e1 34			ld a, (.dmark+2)  
34da 32 67 ee			ld (debug_mark+2),a  
34dd 18 03			jr .pastdmark  
34df ..			.dmark: db "NOT"  
34e2 f1			.pastdmark: pop af  
34e3			endm  
# End of macro DMARK
34e3						CALLMONITOR 
34e3 cd 6f ee			call debug_vector  
34e6				endm  
# End of macro CALLMONITOR
34e6					endif 
34e6					FORTH_DSP 
34e6 cd 5b 1d			call macro_forth_dsp 
34e9				endm 
# End of macro FORTH_DSP
34e9 7e					ld a,(hl)	; get type of value on TOS 
34ea fe 02				cp DS_TYPE_INUM  
34ec 28 03				jr z, .noti 
34ee					NEXTW 
34ee c3 81 1f			jp macro_next 
34f1				endm 
# End of macro NEXTW
34f1			.noti:          FORTH_DSP_VALUEHL 
34f1 cd 95 1d			call macro_dsp_valuehl 
34f4				endm 
# End of macro FORTH_DSP_VALUEHL
34f4			;		push hl 
34f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34f4 cd 4d 1e			call macro_forth_dsp_pop 
34f7				endm 
# End of macro FORTH_DSP_POP
34f7			;		pop hl 
34f7 3e 00				ld a,0 
34f9 bd					cp l 
34fa 28 04				jr z, .not2t 
34fc 2e 00				ld l, 0 
34fe 18 02				jr .notip 
3500			 
3500 2e ff		.not2t:		ld l, 255 
3502			 
3502 26 00		.notip:		ld h, 0	 
3504			 
3504 cd 90 1b				call forth_push_numhl 
3507					NEXTW 
3507 c3 81 1f			jp macro_next 
350a				endm 
# End of macro NEXTW
350a			 
350a			.IS: 
350a				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
350a 2d				db WORD_SYS_CORE+25             
350b 30 35			dw .LZERO            
350d 03				db 2 + 1 
350e .. 00			db "IS",0              
3511				endm 
# End of macro CWHEAD
3511			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3511					if DEBUG_FORTH_WORDS_KEY 
3511						DMARK "IS." 
3511 f5				push af  
3512 3a 26 35			ld a, (.dmark)  
3515 32 65 ee			ld (debug_mark),a  
3518 3a 27 35			ld a, (.dmark+1)  
351b 32 66 ee			ld (debug_mark+1),a  
351e 3a 28 35			ld a, (.dmark+2)  
3521 32 67 ee			ld (debug_mark+2),a  
3524 18 03			jr .pastdmark  
3526 ..			.dmark: db "IS."  
3529 f1			.pastdmark: pop af  
352a			endm  
# End of macro DMARK
352a						CALLMONITOR 
352a cd 6f ee			call debug_vector  
352d				endm  
# End of macro CALLMONITOR
352d					endif 
352d					NEXTW 
352d c3 81 1f			jp macro_next 
3530				endm 
# End of macro NEXTW
3530			.LZERO: 
3530				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3530 2d				db WORD_SYS_CORE+25             
3531 3a 35			dw .TZERO            
3533 03				db 2 + 1 
3534 .. 00			db "0<",0              
3537				endm 
# End of macro CWHEAD
3537			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3537					NEXTW 
3537 c3 81 1f			jp macro_next 
353a				endm 
# End of macro NEXTW
353a			.TZERO: 
353a				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
353a 2e				db WORD_SYS_CORE+26             
353b 81 35			dw .LESS            
353d 03				db 2 + 1 
353e .. 00			db "0=",0              
3541				endm 
# End of macro CWHEAD
3541			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3541				; TODO add floating point number detection 
3541					;v5 FORTH_DSP_VALUE 
3541					if DEBUG_FORTH_WORDS_KEY 
3541						DMARK "0=." 
3541 f5				push af  
3542 3a 56 35			ld a, (.dmark)  
3545 32 65 ee			ld (debug_mark),a  
3548 3a 57 35			ld a, (.dmark+1)  
354b 32 66 ee			ld (debug_mark+1),a  
354e 3a 58 35			ld a, (.dmark+2)  
3551 32 67 ee			ld (debug_mark+2),a  
3554 18 03			jr .pastdmark  
3556 ..			.dmark: db "0=."  
3559 f1			.pastdmark: pop af  
355a			endm  
# End of macro DMARK
355a						CALLMONITOR 
355a cd 6f ee			call debug_vector  
355d				endm  
# End of macro CALLMONITOR
355d					endif 
355d					FORTH_DSP 
355d cd 5b 1d			call macro_forth_dsp 
3560				endm 
# End of macro FORTH_DSP
3560 7e					ld a,(hl)	; get type of value on TOS 
3561 fe 02				cp DS_TYPE_INUM  
3563 28 00				jr z, .tz_inum 
3565			 
3565				if FORTH_ENABLE_FLOATMATH 
3565					jr .tz_done 
3565			 
3565				endif 
3565					 
3565			 
3565			.tz_inum: 
3565					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3565 cd 95 1d			call macro_dsp_valuehl 
3568				endm 
# End of macro FORTH_DSP_VALUEHL
3568			 
3568			;		push hl 
3568			 
3568					; destroy value TOS 
3568			 
3568					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3568 cd 4d 1e			call macro_forth_dsp_pop 
356b				endm 
# End of macro FORTH_DSP_POP
356b			 
356b			;		pop hl 
356b			 
356b 3e 00				ld a,0 
356d			 
356d bd					cp l 
356e 20 08				jr nz, .tz_notzero 
3570			 
3570 bc					cp h 
3571			 
3571 20 05				jr nz, .tz_notzero 
3573			 
3573			 
3573 21 01 00				ld hl, FORTH_TRUE 
3576 18 03				jr .tz_done 
3578			 
3578 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
357b			 
357b					; push value back onto stack for another op etc 
357b			 
357b			.tz_done: 
357b cd 90 1b				call forth_push_numhl 
357e			 
357e					NEXTW 
357e c3 81 1f			jp macro_next 
3581				endm 
# End of macro NEXTW
3581			.LESS: 
3581				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3581 2f				db WORD_SYS_CORE+27             
3582 ea 35			dw .GT            
3584 02				db 1 + 1 
3585 .. 00			db "<",0              
3587				endm 
# End of macro CWHEAD
3587			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3587				; TODO add floating point number detection 
3587					if DEBUG_FORTH_WORDS_KEY 
3587						DMARK "LES" 
3587 f5				push af  
3588 3a 9c 35			ld a, (.dmark)  
358b 32 65 ee			ld (debug_mark),a  
358e 3a 9d 35			ld a, (.dmark+1)  
3591 32 66 ee			ld (debug_mark+1),a  
3594 3a 9e 35			ld a, (.dmark+2)  
3597 32 67 ee			ld (debug_mark+2),a  
359a 18 03			jr .pastdmark  
359c ..			.dmark: db "LES"  
359f f1			.pastdmark: pop af  
35a0			endm  
# End of macro DMARK
35a0						CALLMONITOR 
35a0 cd 6f ee			call debug_vector  
35a3				endm  
# End of macro CALLMONITOR
35a3					endif 
35a3					FORTH_DSP 
35a3 cd 5b 1d			call macro_forth_dsp 
35a6				endm 
# End of macro FORTH_DSP
35a6					;v5 FORTH_DSP_VALUE 
35a6 7e					ld a,(hl)	; get type of value on TOS 
35a7 fe 02				cp DS_TYPE_INUM  
35a9 28 00				jr z, .less_inum 
35ab			 
35ab				if FORTH_ENABLE_FLOATMATH 
35ab					jr .less_done 
35ab			 
35ab				endif 
35ab					 
35ab			 
35ab			.less_inum: 
35ab					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35ab cd 95 1d			call macro_dsp_valuehl 
35ae				endm 
# End of macro FORTH_DSP_VALUEHL
35ae			 
35ae e5					push hl  ; u2 
35af			 
35af					; destroy value TOS 
35af			 
35af					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35af cd 4d 1e			call macro_forth_dsp_pop 
35b2				endm 
# End of macro FORTH_DSP_POP
35b2			 
35b2			 
35b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35b2 cd 95 1d			call macro_dsp_valuehl 
35b5				endm 
# End of macro FORTH_DSP_VALUEHL
35b5			 
35b5 e5					push hl    ; u1 
35b6			 
35b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35b6 cd 4d 1e			call macro_forth_dsp_pop 
35b9				endm 
# End of macro FORTH_DSP_POP
35b9			 
35b9			 
35b9 b7			 or a      ;clear carry flag 
35ba 01 00 00		 ld bc, FORTH_FALSE 
35bd e1			  pop hl    ; u1 
35be d1			  pop de    ; u2 
35bf ed 52		  sbc hl,de 
35c1 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
35c3			 
35c3 01 01 00		 ld bc, FORTH_TRUE 
35c6			.lscont:  
35c6 c5					push bc 
35c7 e1					pop hl 
35c8			 
35c8					if DEBUG_FORTH_WORDS 
35c8						DMARK "LT1" 
35c8 f5				push af  
35c9 3a dd 35			ld a, (.dmark)  
35cc 32 65 ee			ld (debug_mark),a  
35cf 3a de 35			ld a, (.dmark+1)  
35d2 32 66 ee			ld (debug_mark+1),a  
35d5 3a df 35			ld a, (.dmark+2)  
35d8 32 67 ee			ld (debug_mark+2),a  
35db 18 03			jr .pastdmark  
35dd ..			.dmark: db "LT1"  
35e0 f1			.pastdmark: pop af  
35e1			endm  
# End of macro DMARK
35e1						CALLMONITOR 
35e1 cd 6f ee			call debug_vector  
35e4				endm  
# End of macro CALLMONITOR
35e4					endif 
35e4 cd 90 1b				call forth_push_numhl 
35e7			 
35e7					NEXTW 
35e7 c3 81 1f			jp macro_next 
35ea				endm 
# End of macro NEXTW
35ea			.GT: 
35ea				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
35ea 30				db WORD_SYS_CORE+28             
35eb 53 36			dw .EQUAL            
35ed 02				db 1 + 1 
35ee .. 00			db ">",0              
35f0				endm 
# End of macro CWHEAD
35f0			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
35f0				; TODO add floating point number detection 
35f0					if DEBUG_FORTH_WORDS_KEY 
35f0						DMARK "GRT" 
35f0 f5				push af  
35f1 3a 05 36			ld a, (.dmark)  
35f4 32 65 ee			ld (debug_mark),a  
35f7 3a 06 36			ld a, (.dmark+1)  
35fa 32 66 ee			ld (debug_mark+1),a  
35fd 3a 07 36			ld a, (.dmark+2)  
3600 32 67 ee			ld (debug_mark+2),a  
3603 18 03			jr .pastdmark  
3605 ..			.dmark: db "GRT"  
3608 f1			.pastdmark: pop af  
3609			endm  
# End of macro DMARK
3609						CALLMONITOR 
3609 cd 6f ee			call debug_vector  
360c				endm  
# End of macro CALLMONITOR
360c					endif 
360c					FORTH_DSP 
360c cd 5b 1d			call macro_forth_dsp 
360f				endm 
# End of macro FORTH_DSP
360f					;FORTH_DSP_VALUE 
360f 7e					ld a,(hl)	; get type of value on TOS 
3610 fe 02				cp DS_TYPE_INUM  
3612 28 00				jr z, .gt_inum 
3614			 
3614				if FORTH_ENABLE_FLOATMATH 
3614					jr .gt_done 
3614			 
3614				endif 
3614					 
3614			 
3614			.gt_inum: 
3614					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3614 cd 95 1d			call macro_dsp_valuehl 
3617				endm 
# End of macro FORTH_DSP_VALUEHL
3617			 
3617 e5					push hl  ; u2 
3618			 
3618					; destroy value TOS 
3618			 
3618					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3618 cd 4d 1e			call macro_forth_dsp_pop 
361b				endm 
# End of macro FORTH_DSP_POP
361b			 
361b			 
361b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
361b cd 95 1d			call macro_dsp_valuehl 
361e				endm 
# End of macro FORTH_DSP_VALUEHL
361e			 
361e e5					push hl    ; u1 
361f			 
361f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
361f cd 4d 1e			call macro_forth_dsp_pop 
3622				endm 
# End of macro FORTH_DSP_POP
3622			 
3622			 
3622 b7			 or a      ;clear carry flag 
3623 01 00 00		 ld bc, FORTH_FALSE 
3626 e1			  pop hl    ; u1 
3627 d1			  pop de    ; u2 
3628 ed 52		  sbc hl,de 
362a 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
362c			 
362c 01 01 00		 ld bc, FORTH_TRUE 
362f			.gtcont:  
362f c5					push bc 
3630 e1					pop hl 
3631			 
3631					if DEBUG_FORTH_WORDS 
3631						DMARK "GT1" 
3631 f5				push af  
3632 3a 46 36			ld a, (.dmark)  
3635 32 65 ee			ld (debug_mark),a  
3638 3a 47 36			ld a, (.dmark+1)  
363b 32 66 ee			ld (debug_mark+1),a  
363e 3a 48 36			ld a, (.dmark+2)  
3641 32 67 ee			ld (debug_mark+2),a  
3644 18 03			jr .pastdmark  
3646 ..			.dmark: db "GT1"  
3649 f1			.pastdmark: pop af  
364a			endm  
# End of macro DMARK
364a						CALLMONITOR 
364a cd 6f ee			call debug_vector  
364d				endm  
# End of macro CALLMONITOR
364d					endif 
364d cd 90 1b				call forth_push_numhl 
3650			 
3650					NEXTW 
3650 c3 81 1f			jp macro_next 
3653				endm 
# End of macro NEXTW
3653			.EQUAL: 
3653				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3653 31				db WORD_SYS_CORE+29             
3654 be 36			dw .ENDLOGIC            
3656 02				db 1 + 1 
3657 .. 00			db "=",0              
3659				endm 
# End of macro CWHEAD
3659			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3659				; TODO add floating point number detection 
3659					if DEBUG_FORTH_WORDS_KEY 
3659						DMARK "EQ." 
3659 f5				push af  
365a 3a 6e 36			ld a, (.dmark)  
365d 32 65 ee			ld (debug_mark),a  
3660 3a 6f 36			ld a, (.dmark+1)  
3663 32 66 ee			ld (debug_mark+1),a  
3666 3a 70 36			ld a, (.dmark+2)  
3669 32 67 ee			ld (debug_mark+2),a  
366c 18 03			jr .pastdmark  
366e ..			.dmark: db "EQ."  
3671 f1			.pastdmark: pop af  
3672			endm  
# End of macro DMARK
3672						CALLMONITOR 
3672 cd 6f ee			call debug_vector  
3675				endm  
# End of macro CALLMONITOR
3675					endif 
3675					FORTH_DSP 
3675 cd 5b 1d			call macro_forth_dsp 
3678				endm 
# End of macro FORTH_DSP
3678					;v5 FORTH_DSP_VALUE 
3678 7e					ld a,(hl)	; get type of value on TOS 
3679 fe 02				cp DS_TYPE_INUM  
367b 28 00				jr z, .eq_inum 
367d			 
367d				if FORTH_ENABLE_FLOATMATH 
367d					jr .eq_done 
367d			 
367d				endif 
367d					 
367d			 
367d			.eq_inum: 
367d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
367d cd 95 1d			call macro_dsp_valuehl 
3680				endm 
# End of macro FORTH_DSP_VALUEHL
3680			 
3680 e5					push hl 
3681			 
3681					; destroy value TOS 
3681			 
3681					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3681 cd 4d 1e			call macro_forth_dsp_pop 
3684				endm 
# End of macro FORTH_DSP_POP
3684			 
3684			 
3684					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3684 cd 95 1d			call macro_dsp_valuehl 
3687				endm 
# End of macro FORTH_DSP_VALUEHL
3687			 
3687					; one value on hl get other one back 
3687			 
3687 e5					push hl 
3688			 
3688					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3688 cd 4d 1e			call macro_forth_dsp_pop 
368b				endm 
# End of macro FORTH_DSP_POP
368b			 
368b 0e 00				ld c, FORTH_FALSE 
368d			 
368d e1					pop hl 
368e d1					pop de 
368f			 
368f 7b					ld a, e 
3690 bd					cp l 
3691			 
3691 20 06				jr nz, .eq_done 
3693			 
3693 7a					ld a, d 
3694 bc					cp h 
3695			 
3695 20 02				jr nz, .eq_done 
3697			 
3697 0e 01				ld c, FORTH_TRUE 
3699					 
3699			 
3699			 
3699			.eq_done: 
3699			 
3699					; TODO push value back onto stack for another op etc 
3699			 
3699 26 00				ld h, 0 
369b 69					ld l, c 
369c					if DEBUG_FORTH_WORDS 
369c						DMARK "EQ1" 
369c f5				push af  
369d 3a b1 36			ld a, (.dmark)  
36a0 32 65 ee			ld (debug_mark),a  
36a3 3a b2 36			ld a, (.dmark+1)  
36a6 32 66 ee			ld (debug_mark+1),a  
36a9 3a b3 36			ld a, (.dmark+2)  
36ac 32 67 ee			ld (debug_mark+2),a  
36af 18 03			jr .pastdmark  
36b1 ..			.dmark: db "EQ1"  
36b4 f1			.pastdmark: pop af  
36b5			endm  
# End of macro DMARK
36b5						CALLMONITOR 
36b5 cd 6f ee			call debug_vector  
36b8				endm  
# End of macro CALLMONITOR
36b8					endif 
36b8 cd 90 1b				call forth_push_numhl 
36bb			 
36bb					NEXTW 
36bb c3 81 1f			jp macro_next 
36be				endm 
# End of macro NEXTW
36be			 
36be			 
36be			.ENDLOGIC: 
36be			; eof 
36be			 
36be			 
# End of file forth_words_logic.asm
36be			include "forth_words_maths.asm" 
36be			 
36be			; | ## Maths Words 
36be			 
36be			.PLUS:	 
36be				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
36be 15				db WORD_SYS_CORE+1             
36bf 1c 37			dw .NEG            
36c1 02				db 1 + 1 
36c2 .. 00			db "+",0              
36c4				endm 
# End of macro CWHEAD
36c4			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
36c4					if DEBUG_FORTH_WORDS_KEY 
36c4						DMARK "PLU" 
36c4 f5				push af  
36c5 3a d9 36			ld a, (.dmark)  
36c8 32 65 ee			ld (debug_mark),a  
36cb 3a da 36			ld a, (.dmark+1)  
36ce 32 66 ee			ld (debug_mark+1),a  
36d1 3a db 36			ld a, (.dmark+2)  
36d4 32 67 ee			ld (debug_mark+2),a  
36d7 18 03			jr .pastdmark  
36d9 ..			.dmark: db "PLU"  
36dc f1			.pastdmark: pop af  
36dd			endm  
# End of macro DMARK
36dd						CALLMONITOR 
36dd cd 6f ee			call debug_vector  
36e0				endm  
# End of macro CALLMONITOR
36e0					endif 
36e0					; add top two values and push back result 
36e0			 
36e0					;for v5 FORTH_DSP_VALUE 
36e0					FORTH_DSP 
36e0 cd 5b 1d			call macro_forth_dsp 
36e3				endm 
# End of macro FORTH_DSP
36e3 7e					ld a,(hl)	; get type of value on TOS 
36e4 fe 02				cp DS_TYPE_INUM  
36e6 28 03				jr z, .dot_inum 
36e8			 
36e8					NEXTW 
36e8 c3 81 1f			jp macro_next 
36eb				endm 
# End of macro NEXTW
36eb			 
36eb			; float maths 
36eb			 
36eb				if FORTH_ENABLE_FLOATMATH 
36eb						inc hl      ; now at start of numeric as string 
36eb			 
36eb					if DEBUG_FORTH_MATHS 
36eb						DMARK "ADD" 
36eb				CALLMONITOR 
36eb					endif 
36eb			 
36eb					;ld ix, hl 
36eb					call CON 
36eb			 
36eb			 
36eb					push hl 
36eb					 
36eb					 
36eb			 
36eb						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
36eb			 
36eb					; get next number 
36eb			 
36eb						FORTH_DSP_VALUE 
36eb			 
36eb						inc hl      ; now at start of numeric as string 
36eb			 
36eb					;ld ix, hl 
36eb					call CON 
36eb			 
36eb					push hl 
36eb			 
36eb			 
36eb						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36eb			 
36eb						; TODO do add 
36eb			 
36eb						call IADD 
36eb			 
36eb						; TODO get result back as ascii 
36eb			 
36eb						; TODO push result  
36eb			 
36eb			 
36eb			 
36eb						jr .dot_done 
36eb				endif 
36eb			 
36eb			.dot_inum: 
36eb			 
36eb			 
36eb					if DEBUG_FORTH_DOT 
36eb						DMARK "+IT" 
36eb f5				push af  
36ec 3a 00 37			ld a, (.dmark)  
36ef 32 65 ee			ld (debug_mark),a  
36f2 3a 01 37			ld a, (.dmark+1)  
36f5 32 66 ee			ld (debug_mark+1),a  
36f8 3a 02 37			ld a, (.dmark+2)  
36fb 32 67 ee			ld (debug_mark+2),a  
36fe 18 03			jr .pastdmark  
3700 ..			.dmark: db "+IT"  
3703 f1			.pastdmark: pop af  
3704			endm  
# End of macro DMARK
3704				CALLMONITOR 
3704 cd 6f ee			call debug_vector  
3707				endm  
# End of macro CALLMONITOR
3707					endif 
3707			 
3707					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3707 cd 95 1d			call macro_dsp_valuehl 
370a				endm 
# End of macro FORTH_DSP_VALUEHL
370a			 
370a				; TODO add floating point number detection 
370a			 
370a e5					push hl 
370b			 
370b					; destroy value TOS 
370b			 
370b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
370b cd 4d 1e			call macro_forth_dsp_pop 
370e				endm 
# End of macro FORTH_DSP_POP
370e			 
370e			 
370e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
370e cd 95 1d			call macro_dsp_valuehl 
3711				endm 
# End of macro FORTH_DSP_VALUEHL
3711			 
3711					; one value on hl get other one back 
3711			 
3711 d1					pop de 
3712			 
3712					; do the add 
3712			 
3712 19					add hl,de 
3713			 
3713					; save it 
3713			 
3713			;		push hl	 
3713			 
3713					; 
3713			 
3713					; destroy value TOS 
3713			 
3713					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3713 cd 4d 1e			call macro_forth_dsp_pop 
3716				endm 
# End of macro FORTH_DSP_POP
3716			 
3716					; TODO push value back onto stack for another op etc 
3716			 
3716			;		pop hl 
3716			 
3716			.dot_done: 
3716 cd 90 1b				call forth_push_numhl 
3719			 
3719					NEXTW 
3719 c3 81 1f			jp macro_next 
371c				endm 
# End of macro NEXTW
371c			.NEG: 
371c			 
371c				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
371c 17				db WORD_SYS_CORE+3             
371d 5f 37			dw .DIV            
371f 02				db 1 + 1 
3720 .. 00			db "-",0              
3722				endm 
# End of macro CWHEAD
3722			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3722					if DEBUG_FORTH_WORDS_KEY 
3722						DMARK "SUB" 
3722 f5				push af  
3723 3a 37 37			ld a, (.dmark)  
3726 32 65 ee			ld (debug_mark),a  
3729 3a 38 37			ld a, (.dmark+1)  
372c 32 66 ee			ld (debug_mark+1),a  
372f 3a 39 37			ld a, (.dmark+2)  
3732 32 67 ee			ld (debug_mark+2),a  
3735 18 03			jr .pastdmark  
3737 ..			.dmark: db "SUB"  
373a f1			.pastdmark: pop af  
373b			endm  
# End of macro DMARK
373b						CALLMONITOR 
373b cd 6f ee			call debug_vector  
373e				endm  
# End of macro CALLMONITOR
373e					endif 
373e			 
373e			 
373e				; TODO add floating point number detection 
373e					; v5 FORTH_DSP_VALUE 
373e					FORTH_DSP 
373e cd 5b 1d			call macro_forth_dsp 
3741				endm 
# End of macro FORTH_DSP
3741 7e					ld a,(hl)	; get type of value on TOS 
3742 fe 02				cp DS_TYPE_INUM  
3744 28 03				jr z, .neg_inum 
3746			 
3746					NEXTW 
3746 c3 81 1f			jp macro_next 
3749				endm 
# End of macro NEXTW
3749			 
3749			; float maths 
3749			 
3749				if FORTH_ENABLE_FLOATMATH 
3749					jr .neg_done 
3749			 
3749				endif 
3749					 
3749			 
3749			.neg_inum: 
3749					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3749 cd 95 1d			call macro_dsp_valuehl 
374c				endm 
# End of macro FORTH_DSP_VALUEHL
374c			 
374c e5					push hl 
374d			 
374d					; destroy value TOS 
374d			 
374d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
374d cd 4d 1e			call macro_forth_dsp_pop 
3750				endm 
# End of macro FORTH_DSP_POP
3750			 
3750			 
3750					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3750 cd 95 1d			call macro_dsp_valuehl 
3753				endm 
# End of macro FORTH_DSP_VALUEHL
3753			 
3753					; one value on hl get other one back 
3753			 
3753 d1					pop de 
3754			 
3754					; do the sub 
3754			;		ex de, hl 
3754			 
3754 ed 52				sbc hl,de 
3756			 
3756					; save it 
3756			 
3756			;		push hl	 
3756			 
3756					; 
3756			 
3756					; destroy value TOS 
3756			 
3756					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3756 cd 4d 1e			call macro_forth_dsp_pop 
3759				endm 
# End of macro FORTH_DSP_POP
3759			 
3759					; TODO push value back onto stack for another op etc 
3759			 
3759			;		pop hl 
3759			 
3759 cd 90 1b				call forth_push_numhl 
375c			.neg_done: 
375c			 
375c					NEXTW 
375c c3 81 1f			jp macro_next 
375f				endm 
# End of macro NEXTW
375f			.DIV: 
375f				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
375f 18				db WORD_SYS_CORE+4             
3760 ac 37			dw .MUL            
3762 02				db 1 + 1 
3763 .. 00			db "/",0              
3765				endm 
# End of macro CWHEAD
3765			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3765					if DEBUG_FORTH_WORDS_KEY 
3765						DMARK "DIV" 
3765 f5				push af  
3766 3a 7a 37			ld a, (.dmark)  
3769 32 65 ee			ld (debug_mark),a  
376c 3a 7b 37			ld a, (.dmark+1)  
376f 32 66 ee			ld (debug_mark+1),a  
3772 3a 7c 37			ld a, (.dmark+2)  
3775 32 67 ee			ld (debug_mark+2),a  
3778 18 03			jr .pastdmark  
377a ..			.dmark: db "DIV"  
377d f1			.pastdmark: pop af  
377e			endm  
# End of macro DMARK
377e						CALLMONITOR 
377e cd 6f ee			call debug_vector  
3781				endm  
# End of macro CALLMONITOR
3781					endif 
3781				; TODO add floating point number detection 
3781					; v5 FORTH_DSP_VALUE 
3781					FORTH_DSP 
3781 cd 5b 1d			call macro_forth_dsp 
3784				endm 
# End of macro FORTH_DSP
3784 7e					ld a,(hl)	; get type of value on TOS 
3785 fe 02				cp DS_TYPE_INUM  
3787 28 03				jr z, .div_inum 
3789			 
3789				if FORTH_ENABLE_FLOATMATH 
3789					jr .div_done 
3789			 
3789				endif 
3789					NEXTW 
3789 c3 81 1f			jp macro_next 
378c				endm 
# End of macro NEXTW
378c			.div_inum: 
378c			 
378c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
378c cd 95 1d			call macro_dsp_valuehl 
378f				endm 
# End of macro FORTH_DSP_VALUEHL
378f			 
378f e5					push hl    ; to go to bc 
3790			 
3790					; destroy value TOS 
3790			 
3790					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3790 cd 4d 1e			call macro_forth_dsp_pop 
3793				endm 
# End of macro FORTH_DSP_POP
3793			 
3793			 
3793					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3793 cd 95 1d			call macro_dsp_valuehl 
3796				endm 
# End of macro FORTH_DSP_VALUEHL
3796			 
3796					; hl to go to de 
3796			 
3796 e5					push hl 
3797			 
3797 c1					pop bc 
3798 d1					pop de		 
3799			 
3799			 
3799					if DEBUG_FORTH_MATHS 
3799						DMARK "DIV" 
3799				CALLMONITOR 
3799					endif 
3799					; one value on hl but move to a get other one back 
3799			 
3799			        
3799 cd 52 0d			call Div16 
379c			 
379c			;	push af	 
379c e5				push hl 
379d c5				push bc 
379e			 
379e					if DEBUG_FORTH_MATHS 
379e						DMARK "DI1" 
379e				CALLMONITOR 
379e					endif 
379e			 
379e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
379e cd 4d 1e			call macro_forth_dsp_pop 
37a1				endm 
# End of macro FORTH_DSP_POP
37a1			 
37a1			 
37a1			 
37a1 e1					pop hl    ; result 
37a2			 
37a2 cd 90 1b				call forth_push_numhl 
37a5			 
37a5 e1					pop hl    ; reminder 
37a6			;		ld h,0 
37a6			;		ld l,d 
37a6			 
37a6 cd 90 1b				call forth_push_numhl 
37a9			.div_done: 
37a9					NEXTW 
37a9 c3 81 1f			jp macro_next 
37ac				endm 
# End of macro NEXTW
37ac			.MUL: 
37ac				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
37ac 19				db WORD_SYS_CORE+5             
37ad f1 37			dw .MIN            
37af 02				db 1 + 1 
37b0 .. 00			db "*",0              
37b2				endm 
# End of macro CWHEAD
37b2			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
37b2				; TODO add floating point number detection 
37b2					if DEBUG_FORTH_WORDS_KEY 
37b2						DMARK "MUL" 
37b2 f5				push af  
37b3 3a c7 37			ld a, (.dmark)  
37b6 32 65 ee			ld (debug_mark),a  
37b9 3a c8 37			ld a, (.dmark+1)  
37bc 32 66 ee			ld (debug_mark+1),a  
37bf 3a c9 37			ld a, (.dmark+2)  
37c2 32 67 ee			ld (debug_mark+2),a  
37c5 18 03			jr .pastdmark  
37c7 ..			.dmark: db "MUL"  
37ca f1			.pastdmark: pop af  
37cb			endm  
# End of macro DMARK
37cb						CALLMONITOR 
37cb cd 6f ee			call debug_vector  
37ce				endm  
# End of macro CALLMONITOR
37ce					endif 
37ce					FORTH_DSP 
37ce cd 5b 1d			call macro_forth_dsp 
37d1				endm 
# End of macro FORTH_DSP
37d1					; v5 FORTH_DSP_VALUE 
37d1 7e					ld a,(hl)	; get type of value on TOS 
37d2 fe 02				cp DS_TYPE_INUM  
37d4 28 03				jr z, .mul_inum 
37d6			 
37d6				if FORTH_ENABLE_FLOATMATH 
37d6					jr .mul_done 
37d6			 
37d6				endif 
37d6			 
37d6					NEXTW 
37d6 c3 81 1f			jp macro_next 
37d9				endm 
# End of macro NEXTW
37d9			.mul_inum:	 
37d9			 
37d9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37d9 cd 95 1d			call macro_dsp_valuehl 
37dc				endm 
# End of macro FORTH_DSP_VALUEHL
37dc			 
37dc e5					push hl 
37dd			 
37dd					; destroy value TOS 
37dd			 
37dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37dd cd 4d 1e			call macro_forth_dsp_pop 
37e0				endm 
# End of macro FORTH_DSP_POP
37e0			 
37e0			 
37e0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37e0 cd 95 1d			call macro_dsp_valuehl 
37e3				endm 
# End of macro FORTH_DSP_VALUEHL
37e3			 
37e3					; one value on hl but move to a get other one back 
37e3			 
37e3 7d					ld a, l 
37e4			 
37e4 d1					pop de 
37e5			 
37e5					; do the mull 
37e5			;		ex de, hl 
37e5			 
37e5 cd 78 0d				call Mult16 
37e8					; save it 
37e8			 
37e8			;		push hl	 
37e8			 
37e8					; 
37e8			 
37e8					; destroy value TOS 
37e8			 
37e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37e8 cd 4d 1e			call macro_forth_dsp_pop 
37eb				endm 
# End of macro FORTH_DSP_POP
37eb			 
37eb					; TODO push value back onto stack for another op etc 
37eb			 
37eb			;		pop hl 
37eb			 
37eb cd 90 1b				call forth_push_numhl 
37ee			 
37ee			.mul_done: 
37ee					NEXTW 
37ee c3 81 1f			jp macro_next 
37f1				endm 
# End of macro NEXTW
37f1			 
37f1			 
37f1			 
37f1			 
37f1			.MIN: 
37f1				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
37f1 49				db WORD_SYS_CORE+53             
37f2 72 38			dw .MAX            
37f4 04				db 3 + 1 
37f5 .. 00			db "MIN",0              
37f9				endm 
# End of macro CWHEAD
37f9			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
37f9					if DEBUG_FORTH_WORDS_KEY 
37f9						DMARK "MIN" 
37f9 f5				push af  
37fa 3a 0e 38			ld a, (.dmark)  
37fd 32 65 ee			ld (debug_mark),a  
3800 3a 0f 38			ld a, (.dmark+1)  
3803 32 66 ee			ld (debug_mark+1),a  
3806 3a 10 38			ld a, (.dmark+2)  
3809 32 67 ee			ld (debug_mark+2),a  
380c 18 03			jr .pastdmark  
380e ..			.dmark: db "MIN"  
3811 f1			.pastdmark: pop af  
3812			endm  
# End of macro DMARK
3812						CALLMONITOR 
3812 cd 6f ee			call debug_vector  
3815				endm  
# End of macro CALLMONITOR
3815					endif 
3815					; get u2 
3815			 
3815					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3815 cd 95 1d			call macro_dsp_valuehl 
3818				endm 
# End of macro FORTH_DSP_VALUEHL
3818			 
3818 e5					push hl   ; u2 
3819			 
3819					; destroy value TOS 
3819			 
3819					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3819 cd 4d 1e			call macro_forth_dsp_pop 
381c				endm 
# End of macro FORTH_DSP_POP
381c			 
381c					; get u1 
381c			 
381c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
381c cd 95 1d			call macro_dsp_valuehl 
381f				endm 
# End of macro FORTH_DSP_VALUEHL
381f			 
381f e5					push hl  ; u1 
3820			 
3820					; destroy value TOS 
3820			 
3820					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3820 cd 4d 1e			call macro_forth_dsp_pop 
3823				endm 
# End of macro FORTH_DSP_POP
3823			 
3823 b7			 or a      ;clear carry flag 
3824 e1			  pop hl    ; u1 
3825 d1			  pop de    ; u2 
3826 e5				push hl   ; saved in case hl is lowest 
3827 ed 52		  sbc hl,de 
3829 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
382b			 
382b e1				pop hl 
382c					if DEBUG_FORTH_WORDS 
382c						DMARK "MIN" 
382c f5				push af  
382d 3a 41 38			ld a, (.dmark)  
3830 32 65 ee			ld (debug_mark),a  
3833 3a 42 38			ld a, (.dmark+1)  
3836 32 66 ee			ld (debug_mark+1),a  
3839 3a 43 38			ld a, (.dmark+2)  
383c 32 67 ee			ld (debug_mark+2),a  
383f 18 03			jr .pastdmark  
3841 ..			.dmark: db "MIN"  
3844 f1			.pastdmark: pop af  
3845			endm  
# End of macro DMARK
3845						CALLMONITOR 
3845 cd 6f ee			call debug_vector  
3848				endm  
# End of macro CALLMONITOR
3848					endif 
3848 cd 90 1b				call forth_push_numhl 
384b			 
384b				       NEXTW 
384b c3 81 1f			jp macro_next 
384e				endm 
# End of macro NEXTW
384e			 
384e			.mincont:  
384e c1				pop bc   ; tidy up 
384f eb				ex de , hl  
3850					if DEBUG_FORTH_WORDS 
3850						DMARK "MI1" 
3850 f5				push af  
3851 3a 65 38			ld a, (.dmark)  
3854 32 65 ee			ld (debug_mark),a  
3857 3a 66 38			ld a, (.dmark+1)  
385a 32 66 ee			ld (debug_mark+1),a  
385d 3a 67 38			ld a, (.dmark+2)  
3860 32 67 ee			ld (debug_mark+2),a  
3863 18 03			jr .pastdmark  
3865 ..			.dmark: db "MI1"  
3868 f1			.pastdmark: pop af  
3869			endm  
# End of macro DMARK
3869						CALLMONITOR 
3869 cd 6f ee			call debug_vector  
386c				endm  
# End of macro CALLMONITOR
386c					endif 
386c cd 90 1b				call forth_push_numhl 
386f			 
386f				       NEXTW 
386f c3 81 1f			jp macro_next 
3872				endm 
# End of macro NEXTW
3872			.MAX: 
3872				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3872 4a				db WORD_SYS_CORE+54             
3873 f3 38			dw .RND16            
3875 04				db 3 + 1 
3876 .. 00			db "MAX",0              
387a				endm 
# End of macro CWHEAD
387a			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
387a					if DEBUG_FORTH_WORDS_KEY 
387a						DMARK "MAX" 
387a f5				push af  
387b 3a 8f 38			ld a, (.dmark)  
387e 32 65 ee			ld (debug_mark),a  
3881 3a 90 38			ld a, (.dmark+1)  
3884 32 66 ee			ld (debug_mark+1),a  
3887 3a 91 38			ld a, (.dmark+2)  
388a 32 67 ee			ld (debug_mark+2),a  
388d 18 03			jr .pastdmark  
388f ..			.dmark: db "MAX"  
3892 f1			.pastdmark: pop af  
3893			endm  
# End of macro DMARK
3893						CALLMONITOR 
3893 cd 6f ee			call debug_vector  
3896				endm  
# End of macro CALLMONITOR
3896					endif 
3896					; get u2 
3896			 
3896					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3896 cd 95 1d			call macro_dsp_valuehl 
3899				endm 
# End of macro FORTH_DSP_VALUEHL
3899			 
3899 e5					push hl   ; u2 
389a			 
389a					; destroy value TOS 
389a			 
389a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
389a cd 4d 1e			call macro_forth_dsp_pop 
389d				endm 
# End of macro FORTH_DSP_POP
389d			 
389d					; get u1 
389d			 
389d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
389d cd 95 1d			call macro_dsp_valuehl 
38a0				endm 
# End of macro FORTH_DSP_VALUEHL
38a0			 
38a0 e5					push hl  ; u1 
38a1			 
38a1					; destroy value TOS 
38a1			 
38a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38a1 cd 4d 1e			call macro_forth_dsp_pop 
38a4				endm 
# End of macro FORTH_DSP_POP
38a4			 
38a4 b7			 or a      ;clear carry flag 
38a5 e1			  pop hl    ; u1 
38a6 d1			  pop de    ; u2 
38a7 e5				push hl   ; saved in case hl is lowest 
38a8 ed 52		  sbc hl,de 
38aa 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
38ac			 
38ac e1				pop hl 
38ad					if DEBUG_FORTH_WORDS 
38ad						DMARK "MAX" 
38ad f5				push af  
38ae 3a c2 38			ld a, (.dmark)  
38b1 32 65 ee			ld (debug_mark),a  
38b4 3a c3 38			ld a, (.dmark+1)  
38b7 32 66 ee			ld (debug_mark+1),a  
38ba 3a c4 38			ld a, (.dmark+2)  
38bd 32 67 ee			ld (debug_mark+2),a  
38c0 18 03			jr .pastdmark  
38c2 ..			.dmark: db "MAX"  
38c5 f1			.pastdmark: pop af  
38c6			endm  
# End of macro DMARK
38c6						CALLMONITOR 
38c6 cd 6f ee			call debug_vector  
38c9				endm  
# End of macro CALLMONITOR
38c9					endif 
38c9 cd 90 1b				call forth_push_numhl 
38cc			 
38cc				       NEXTW 
38cc c3 81 1f			jp macro_next 
38cf				endm 
# End of macro NEXTW
38cf			 
38cf			.maxcont:  
38cf c1				pop bc   ; tidy up 
38d0 eb				ex de , hl  
38d1					if DEBUG_FORTH_WORDS 
38d1						DMARK "MA1" 
38d1 f5				push af  
38d2 3a e6 38			ld a, (.dmark)  
38d5 32 65 ee			ld (debug_mark),a  
38d8 3a e7 38			ld a, (.dmark+1)  
38db 32 66 ee			ld (debug_mark+1),a  
38de 3a e8 38			ld a, (.dmark+2)  
38e1 32 67 ee			ld (debug_mark+2),a  
38e4 18 03			jr .pastdmark  
38e6 ..			.dmark: db "MA1"  
38e9 f1			.pastdmark: pop af  
38ea			endm  
# End of macro DMARK
38ea						CALLMONITOR 
38ea cd 6f ee			call debug_vector  
38ed				endm  
# End of macro CALLMONITOR
38ed					endif 
38ed cd 90 1b				call forth_push_numhl 
38f0				       NEXTW 
38f0 c3 81 1f			jp macro_next 
38f3				endm 
# End of macro NEXTW
38f3			 
38f3			.RND16: 
38f3				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
38f3 4e				db WORD_SYS_CORE+58             
38f4 22 39			dw .RND8            
38f6 06				db 5 + 1 
38f7 .. 00			db "RND16",0              
38fd				endm 
# End of macro CWHEAD
38fd			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
38fd					if DEBUG_FORTH_WORDS_KEY 
38fd						DMARK "R16" 
38fd f5				push af  
38fe 3a 12 39			ld a, (.dmark)  
3901 32 65 ee			ld (debug_mark),a  
3904 3a 13 39			ld a, (.dmark+1)  
3907 32 66 ee			ld (debug_mark+1),a  
390a 3a 14 39			ld a, (.dmark+2)  
390d 32 67 ee			ld (debug_mark+2),a  
3910 18 03			jr .pastdmark  
3912 ..			.dmark: db "R16"  
3915 f1			.pastdmark: pop af  
3916			endm  
# End of macro DMARK
3916						CALLMONITOR 
3916 cd 6f ee			call debug_vector  
3919				endm  
# End of macro CALLMONITOR
3919					endif 
3919 cd 1c 0d				call prng16  
391c cd 90 1b				call forth_push_numhl 
391f				       NEXTW 
391f c3 81 1f			jp macro_next 
3922				endm 
# End of macro NEXTW
3922			.RND8: 
3922				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3922 60				db WORD_SYS_CORE+76             
3923 57 39			dw .RND            
3925 05				db 4 + 1 
3926 .. 00			db "RND8",0              
392b				endm 
# End of macro CWHEAD
392b			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
392b					if DEBUG_FORTH_WORDS_KEY 
392b						DMARK "RN8" 
392b f5				push af  
392c 3a 40 39			ld a, (.dmark)  
392f 32 65 ee			ld (debug_mark),a  
3932 3a 41 39			ld a, (.dmark+1)  
3935 32 66 ee			ld (debug_mark+1),a  
3938 3a 42 39			ld a, (.dmark+2)  
393b 32 67 ee			ld (debug_mark+2),a  
393e 18 03			jr .pastdmark  
3940 ..			.dmark: db "RN8"  
3943 f1			.pastdmark: pop af  
3944			endm  
# End of macro DMARK
3944						CALLMONITOR 
3944 cd 6f ee			call debug_vector  
3947				endm  
# End of macro CALLMONITOR
3947					endif 
3947 2a a3 eb				ld hl,(xrandc) 
394a 23					inc hl 
394b cd 36 0d				call xrnd 
394e 6f					ld l,a	 
394f 26 00				ld h,0 
3951 cd 90 1b				call forth_push_numhl 
3954				       NEXTW 
3954 c3 81 1f			jp macro_next 
3957				endm 
# End of macro NEXTW
3957			.RND: 
3957				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3957 60				db WORD_SYS_CORE+76             
3958 5d 3a			dw .ENDMATHS            
395a 04				db 3 + 1 
395b .. 00			db "RND",0              
395f				endm 
# End of macro CWHEAD
395f			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
395f			 
395f					if DEBUG_FORTH_WORDS_KEY 
395f						DMARK "RND" 
395f f5				push af  
3960 3a 74 39			ld a, (.dmark)  
3963 32 65 ee			ld (debug_mark),a  
3966 3a 75 39			ld a, (.dmark+1)  
3969 32 66 ee			ld (debug_mark+1),a  
396c 3a 76 39			ld a, (.dmark+2)  
396f 32 67 ee			ld (debug_mark+2),a  
3972 18 03			jr .pastdmark  
3974 ..			.dmark: db "RND"  
3977 f1			.pastdmark: pop af  
3978			endm  
# End of macro DMARK
3978						CALLMONITOR 
3978 cd 6f ee			call debug_vector  
397b				endm  
# End of macro CALLMONITOR
397b					endif 
397b					 
397b					FORTH_DSP_VALUEHL    ; upper range 
397b cd 95 1d			call macro_dsp_valuehl 
397e				endm 
# End of macro FORTH_DSP_VALUEHL
397e			 
397e 22 a7 eb				ld (LFSRSeed), hl	 
3981			 
3981					if DEBUG_FORTH_WORDS 
3981						DMARK "RN1" 
3981 f5				push af  
3982 3a 96 39			ld a, (.dmark)  
3985 32 65 ee			ld (debug_mark),a  
3988 3a 97 39			ld a, (.dmark+1)  
398b 32 66 ee			ld (debug_mark+1),a  
398e 3a 98 39			ld a, (.dmark+2)  
3991 32 67 ee			ld (debug_mark+2),a  
3994 18 03			jr .pastdmark  
3996 ..			.dmark: db "RN1"  
3999 f1			.pastdmark: pop af  
399a			endm  
# End of macro DMARK
399a						CALLMONITOR 
399a cd 6f ee			call debug_vector  
399d				endm  
# End of macro CALLMONITOR
399d					endif 
399d					FORTH_DSP_POP 
399d cd 4d 1e			call macro_forth_dsp_pop 
39a0				endm 
# End of macro FORTH_DSP_POP
39a0			 
39a0					FORTH_DSP_VALUEHL    ; low range 
39a0 cd 95 1d			call macro_dsp_valuehl 
39a3				endm 
# End of macro FORTH_DSP_VALUEHL
39a3			 
39a3					if DEBUG_FORTH_WORDS 
39a3						DMARK "RN2" 
39a3 f5				push af  
39a4 3a b8 39			ld a, (.dmark)  
39a7 32 65 ee			ld (debug_mark),a  
39aa 3a b9 39			ld a, (.dmark+1)  
39ad 32 66 ee			ld (debug_mark+1),a  
39b0 3a ba 39			ld a, (.dmark+2)  
39b3 32 67 ee			ld (debug_mark+2),a  
39b6 18 03			jr .pastdmark  
39b8 ..			.dmark: db "RN2"  
39bb f1			.pastdmark: pop af  
39bc			endm  
# End of macro DMARK
39bc						CALLMONITOR 
39bc cd 6f ee			call debug_vector  
39bf				endm  
# End of macro CALLMONITOR
39bf					endif 
39bf 22 a9 eb				ld (LFSRSeed+2), hl 
39c2			 
39c2					FORTH_DSP_POP 
39c2 cd 4d 1e			call macro_forth_dsp_pop 
39c5				endm 
# End of macro FORTH_DSP_POP
39c5			 
39c5 e5					push hl 
39c6			 
39c6 e1			.inrange:	pop hl 
39c7 cd 1c 0d				call prng16  
39ca					if DEBUG_FORTH_WORDS 
39ca						DMARK "RN3" 
39ca f5				push af  
39cb 3a df 39			ld a, (.dmark)  
39ce 32 65 ee			ld (debug_mark),a  
39d1 3a e0 39			ld a, (.dmark+1)  
39d4 32 66 ee			ld (debug_mark+1),a  
39d7 3a e1 39			ld a, (.dmark+2)  
39da 32 67 ee			ld (debug_mark+2),a  
39dd 18 03			jr .pastdmark  
39df ..			.dmark: db "RN3"  
39e2 f1			.pastdmark: pop af  
39e3			endm  
# End of macro DMARK
39e3						CALLMONITOR 
39e3 cd 6f ee			call debug_vector  
39e6				endm  
# End of macro CALLMONITOR
39e6					endif 
39e6					 
39e6					; if the range is 8bit knock out the high byte 
39e6			 
39e6 ed 5b a7 eb			ld de, (LFSRSeed)     ; check high level 
39ea			 
39ea 3e 00				ld a, 0 
39ec ba					cp d  
39ed 20 1e				jr nz, .hirange 
39ef 26 00				ld h, 0   ; knock it down to 8bit 
39f1			 
39f1					if DEBUG_FORTH_WORDS 
39f1						DMARK "RNk" 
39f1 f5				push af  
39f2 3a 06 3a			ld a, (.dmark)  
39f5 32 65 ee			ld (debug_mark),a  
39f8 3a 07 3a			ld a, (.dmark+1)  
39fb 32 66 ee			ld (debug_mark+1),a  
39fe 3a 08 3a			ld a, (.dmark+2)  
3a01 32 67 ee			ld (debug_mark+2),a  
3a04 18 03			jr .pastdmark  
3a06 ..			.dmark: db "RNk"  
3a09 f1			.pastdmark: pop af  
3a0a			endm  
# End of macro DMARK
3a0a						CALLMONITOR 
3a0a cd 6f ee			call debug_vector  
3a0d				endm  
# End of macro CALLMONITOR
3a0d					endif 
3a0d			.hirange:   
3a0d e5					push hl  
3a0e b7					or a  
3a0f ed 52		                sbc hl, de 
3a11			 
3a11					;call cmp16 
3a11			 
3a11 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3a13 e1					pop hl 
3a14 e5					push hl 
3a15			 
3a15					if DEBUG_FORTH_WORDS 
3a15						DMARK "RN4" 
3a15 f5				push af  
3a16 3a 2a 3a			ld a, (.dmark)  
3a19 32 65 ee			ld (debug_mark),a  
3a1c 3a 2b 3a			ld a, (.dmark+1)  
3a1f 32 66 ee			ld (debug_mark+1),a  
3a22 3a 2c 3a			ld a, (.dmark+2)  
3a25 32 67 ee			ld (debug_mark+2),a  
3a28 18 03			jr .pastdmark  
3a2a ..			.dmark: db "RN4"  
3a2d f1			.pastdmark: pop af  
3a2e			endm  
# End of macro DMARK
3a2e						CALLMONITOR 
3a2e cd 6f ee			call debug_vector  
3a31				endm  
# End of macro CALLMONITOR
3a31					endif 
3a31 ed 5b a9 eb			ld de, (LFSRSeed+2)   ; check low range 
3a35					;call cmp16 
3a35				 
3a35 b7					or a  
3a36 ed 52		                sbc hl, de 
3a38 38 8c				jr c, .inrange 
3a3a			 
3a3a e1					pop hl 
3a3b					 
3a3b					if DEBUG_FORTH_WORDS 
3a3b						DMARK "RNd" 
3a3b f5				push af  
3a3c 3a 50 3a			ld a, (.dmark)  
3a3f 32 65 ee			ld (debug_mark),a  
3a42 3a 51 3a			ld a, (.dmark+1)  
3a45 32 66 ee			ld (debug_mark+1),a  
3a48 3a 52 3a			ld a, (.dmark+2)  
3a4b 32 67 ee			ld (debug_mark+2),a  
3a4e 18 03			jr .pastdmark  
3a50 ..			.dmark: db "RNd"  
3a53 f1			.pastdmark: pop af  
3a54			endm  
# End of macro DMARK
3a54						CALLMONITOR 
3a54 cd 6f ee			call debug_vector  
3a57				endm  
# End of macro CALLMONITOR
3a57					endif 
3a57			 
3a57			 
3a57 cd 90 1b				call forth_push_numhl 
3a5a				       NEXTW 
3a5a c3 81 1f			jp macro_next 
3a5d				endm 
# End of macro NEXTW
3a5d			 
3a5d			.ENDMATHS: 
3a5d			 
3a5d			; eof 
3a5d			 
# End of file forth_words_maths.asm
3a5d			include "forth_words_display.asm" 
3a5d			 
3a5d			; | ## Display Words 
3a5d			 
3a5d			.ACT: 
3a5d			 
3a5d				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3a5d 62				db WORD_SYS_CORE+78             
3a5e a9 3a			dw .INFO            
3a60 07				db 6 + 1 
3a61 .. 00			db "ACTIVE",0              
3a68				endm 
# End of macro CWHEAD
3a68			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3a68			;  
3a68			; | | To display a pulsing activity indicator in a processing loop do this... 
3a68			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
3a68			 
3a68					if DEBUG_FORTH_WORDS_KEY 
3a68						DMARK "ACT" 
3a68 f5				push af  
3a69 3a 7d 3a			ld a, (.dmark)  
3a6c 32 65 ee			ld (debug_mark),a  
3a6f 3a 7e 3a			ld a, (.dmark+1)  
3a72 32 66 ee			ld (debug_mark+1),a  
3a75 3a 7f 3a			ld a, (.dmark+2)  
3a78 32 67 ee			ld (debug_mark+2),a  
3a7b 18 03			jr .pastdmark  
3a7d ..			.dmark: db "ACT"  
3a80 f1			.pastdmark: pop af  
3a81			endm  
# End of macro DMARK
3a81						CALLMONITOR 
3a81 cd 6f ee			call debug_vector  
3a84				endm  
# End of macro CALLMONITOR
3a84					endif 
3a84 cd 1f 0b				call active 
3a87					if DEBUG_FORTH_WORDS 
3a87						DMARK "ACp" 
3a87 f5				push af  
3a88 3a 9c 3a			ld a, (.dmark)  
3a8b 32 65 ee			ld (debug_mark),a  
3a8e 3a 9d 3a			ld a, (.dmark+1)  
3a91 32 66 ee			ld (debug_mark+1),a  
3a94 3a 9e 3a			ld a, (.dmark+2)  
3a97 32 67 ee			ld (debug_mark+2),a  
3a9a 18 03			jr .pastdmark  
3a9c ..			.dmark: db "ACp"  
3a9f f1			.pastdmark: pop af  
3aa0			endm  
# End of macro DMARK
3aa0						CALLMONITOR 
3aa0 cd 6f ee			call debug_vector  
3aa3				endm  
# End of macro CALLMONITOR
3aa3					endif 
3aa3 cd fe 1b				call forth_push_str 
3aa6			 
3aa6					NEXTW 
3aa6 c3 81 1f			jp macro_next 
3aa9				endm 
# End of macro NEXTW
3aa9			.INFO: 
3aa9			 
3aa9				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3aa9 62				db WORD_SYS_CORE+78             
3aaa c6 3a			dw .ATP            
3aac 05				db 4 + 1 
3aad .. 00			db "INFO",0              
3ab2				endm 
# End of macro CWHEAD
3ab2			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3ab2					FORTH_DSP_VALUEHL 
3ab2 cd 95 1d			call macro_dsp_valuehl 
3ab5				endm 
# End of macro FORTH_DSP_VALUEHL
3ab5			 
3ab5					FORTH_DSP_POP 
3ab5 cd 4d 1e			call macro_forth_dsp_pop 
3ab8				endm 
# End of macro FORTH_DSP_POP
3ab8			 
3ab8 e5					push hl 
3ab9			 
3ab9					FORTH_DSP_VALUEHL 
3ab9 cd 95 1d			call macro_dsp_valuehl 
3abc				endm 
# End of macro FORTH_DSP_VALUEHL
3abc			 
3abc					FORTH_DSP_POP 
3abc cd 4d 1e			call macro_forth_dsp_pop 
3abf				endm 
# End of macro FORTH_DSP_POP
3abf			 
3abf d1					pop de 
3ac0			 
3ac0 cd 59 0b				call info_panel 
3ac3			 
3ac3			 
3ac3					NEXTW 
3ac3 c3 81 1f			jp macro_next 
3ac6				endm 
# End of macro NEXTW
3ac6			.ATP: 
3ac6				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3ac6 62				db WORD_SYS_CORE+78             
3ac7 3d 3b			dw .FB            
3ac9 04				db 3 + 1 
3aca .. 00			db "AT?",0              
3ace				endm 
# End of macro CWHEAD
3ace			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3ace					if DEBUG_FORTH_WORDS_KEY 
3ace						DMARK "AT?" 
3ace f5				push af  
3acf 3a e3 3a			ld a, (.dmark)  
3ad2 32 65 ee			ld (debug_mark),a  
3ad5 3a e4 3a			ld a, (.dmark+1)  
3ad8 32 66 ee			ld (debug_mark+1),a  
3adb 3a e5 3a			ld a, (.dmark+2)  
3ade 32 67 ee			ld (debug_mark+2),a  
3ae1 18 03			jr .pastdmark  
3ae3 ..			.dmark: db "AT?"  
3ae6 f1			.pastdmark: pop af  
3ae7			endm  
# End of macro DMARK
3ae7						CALLMONITOR 
3ae7 cd 6f ee			call debug_vector  
3aea				endm  
# End of macro CALLMONITOR
3aea					endif 
3aea 3a 58 ea				ld a, (f_cursor_ptr) 
3aed			 
3aed			if DEBUG_FORTH_WORDS 
3aed				DMARK "AT?" 
3aed f5				push af  
3aee 3a 02 3b			ld a, (.dmark)  
3af1 32 65 ee			ld (debug_mark),a  
3af4 3a 03 3b			ld a, (.dmark+1)  
3af7 32 66 ee			ld (debug_mark+1),a  
3afa 3a 04 3b			ld a, (.dmark+2)  
3afd 32 67 ee			ld (debug_mark+2),a  
3b00 18 03			jr .pastdmark  
3b02 ..			.dmark: db "AT?"  
3b05 f1			.pastdmark: pop af  
3b06			endm  
# End of macro DMARK
3b06				CALLMONITOR 
3b06 cd 6f ee			call debug_vector  
3b09				endm  
# End of macro CALLMONITOR
3b09			endif	 
3b09					; count the number of rows 
3b09			 
3b09 06 00				ld b, 0 
3b0b 4f			.atpr:		ld c, a    ; save in case we go below zero 
3b0c d6 28				sub display_cols 
3b0e f2 14 3b				jp p, .atprunder 
3b11 04					inc b 
3b12 18 f7				jr .atpr 
3b14			.atprunder:	 
3b14			if DEBUG_FORTH_WORDS 
3b14				DMARK "A?2" 
3b14 f5				push af  
3b15 3a 29 3b			ld a, (.dmark)  
3b18 32 65 ee			ld (debug_mark),a  
3b1b 3a 2a 3b			ld a, (.dmark+1)  
3b1e 32 66 ee			ld (debug_mark+1),a  
3b21 3a 2b 3b			ld a, (.dmark+2)  
3b24 32 67 ee			ld (debug_mark+2),a  
3b27 18 03			jr .pastdmark  
3b29 ..			.dmark: db "A?2"  
3b2c f1			.pastdmark: pop af  
3b2d			endm  
# End of macro DMARK
3b2d				CALLMONITOR 
3b2d cd 6f ee			call debug_vector  
3b30				endm  
# End of macro CALLMONITOR
3b30			endif	 
3b30 26 00				ld h, 0 
3b32 69					ld l, c 
3b33 cd 90 1b				call forth_push_numhl 
3b36 68					ld l, b  
3b37 cd 90 1b				call forth_push_numhl 
3b3a			 
3b3a			 
3b3a				NEXTW 
3b3a c3 81 1f			jp macro_next 
3b3d				endm 
# End of macro NEXTW
3b3d			 
3b3d			.FB: 
3b3d				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3b3d 1b				db WORD_SYS_CORE+7             
3b3e 8b 3b			dw .EMIT            
3b40 03				db 2 + 1 
3b41 .. 00			db "FB",0              
3b44				endm 
# End of macro CWHEAD
3b44			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3b44			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3b44			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3b44			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3b44					if DEBUG_FORTH_WORDS_KEY 
3b44						DMARK "FB." 
3b44 f5				push af  
3b45 3a 59 3b			ld a, (.dmark)  
3b48 32 65 ee			ld (debug_mark),a  
3b4b 3a 5a 3b			ld a, (.dmark+1)  
3b4e 32 66 ee			ld (debug_mark+1),a  
3b51 3a 5b 3b			ld a, (.dmark+2)  
3b54 32 67 ee			ld (debug_mark+2),a  
3b57 18 03			jr .pastdmark  
3b59 ..			.dmark: db "FB."  
3b5c f1			.pastdmark: pop af  
3b5d			endm  
# End of macro DMARK
3b5d						CALLMONITOR 
3b5d cd 6f ee			call debug_vector  
3b60				endm  
# End of macro CALLMONITOR
3b60					endif 
3b60			 
3b60					FORTH_DSP_VALUEHL 
3b60 cd 95 1d			call macro_dsp_valuehl 
3b63				endm 
# End of macro FORTH_DSP_VALUEHL
3b63			 
3b63 7d					ld a, l 
3b64 fe 01				cp 1 
3b66 20 05				jr nz, .fbn1 
3b68 21 0a ed				ld hl, display_fb1 
3b6b 18 15				jr .fbset 
3b6d fe 02		.fbn1:		cp 2 
3b6f 20 05				jr nz, .fbn2 
3b71 21 c8 eb				ld hl, display_fb2 
3b74 18 0c				jr .fbset 
3b76 fe 03		.fbn2:		cp 3 
3b78 20 05				jr nz, .fbn3 
3b7a 21 69 ec				ld hl, display_fb3 
3b7d 18 03				jr .fbset 
3b7f			.fbn3:		 ; if invalid number select first 
3b7f 21 0a ed				ld hl, display_fb1 
3b82 22 c6 eb		.fbset:		ld (display_fb_active), hl 
3b85			 
3b85					FORTH_DSP_POP 
3b85 cd 4d 1e			call macro_forth_dsp_pop 
3b88				endm 
# End of macro FORTH_DSP_POP
3b88			 
3b88					NEXTW 
3b88 c3 81 1f			jp macro_next 
3b8b				endm 
# End of macro NEXTW
3b8b			 
3b8b			 
3b8b			.EMIT: 
3b8b				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3b8b 1b				db WORD_SYS_CORE+7             
3b8c dc 3b			dw .DOTH            
3b8e 05				db 4 + 1 
3b8f .. 00			db "EMIT",0              
3b94				endm 
# End of macro CWHEAD
3b94			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3b94					; get value off TOS and display it 
3b94			 
3b94					if DEBUG_FORTH_WORDS_KEY 
3b94						DMARK "EMT" 
3b94 f5				push af  
3b95 3a a9 3b			ld a, (.dmark)  
3b98 32 65 ee			ld (debug_mark),a  
3b9b 3a aa 3b			ld a, (.dmark+1)  
3b9e 32 66 ee			ld (debug_mark+1),a  
3ba1 3a ab 3b			ld a, (.dmark+2)  
3ba4 32 67 ee			ld (debug_mark+2),a  
3ba7 18 03			jr .pastdmark  
3ba9 ..			.dmark: db "EMT"  
3bac f1			.pastdmark: pop af  
3bad			endm  
# End of macro DMARK
3bad						CALLMONITOR 
3bad cd 6f ee			call debug_vector  
3bb0				endm  
# End of macro CALLMONITOR
3bb0					endif 
3bb0			 
3bb0					FORTH_DSP_VALUEHL 
3bb0 cd 95 1d			call macro_dsp_valuehl 
3bb3				endm 
# End of macro FORTH_DSP_VALUEHL
3bb3			 
3bb3 7d					ld a,l 
3bb4			 
3bb4					; TODO write to display 
3bb4			 
3bb4 32 b9 e4				ld (os_input), a 
3bb7 3e 00				ld a, 0 
3bb9 32 ba e4				ld (os_input+1), a 
3bbc					 
3bbc 3a 58 ea				ld a, (f_cursor_ptr) 
3bbf 11 b9 e4				ld de, os_input 
3bc2 cd db 0b				call str_at_display 
3bc5			 
3bc5			 
3bc5 3a 36 ea				ld a,(cli_autodisplay) 
3bc8 fe 00				cp 0 
3bca 28 03				jr z, .enoupdate 
3bcc cd eb 0b						call update_display 
3bcf					.enoupdate: 
3bcf			 
3bcf 3a 58 ea				ld a, (f_cursor_ptr) 
3bd2 3c					inc a 
3bd3 32 58 ea				ld (f_cursor_ptr), a   ; save new pos 
3bd6			 
3bd6			 
3bd6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bd6 cd 4d 1e			call macro_forth_dsp_pop 
3bd9				endm 
# End of macro FORTH_DSP_POP
3bd9			  
3bd9			 
3bd9					NEXTW 
3bd9 c3 81 1f			jp macro_next 
3bdc				endm 
# End of macro NEXTW
3bdc			.DOTH: 
3bdc				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3bdc 1c				db WORD_SYS_CORE+8             
3bdd 0c 3c			dw .DOTF            
3bdf 03				db 2 + 1 
3be0 .. 00			db ".-",0              
3be3				endm 
# End of macro CWHEAD
3be3			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3be3					; get value off TOS and display it 
3be3					if DEBUG_FORTH_WORDS_KEY 
3be3						DMARK "DTD" 
3be3 f5				push af  
3be4 3a f8 3b			ld a, (.dmark)  
3be7 32 65 ee			ld (debug_mark),a  
3bea 3a f9 3b			ld a, (.dmark+1)  
3bed 32 66 ee			ld (debug_mark+1),a  
3bf0 3a fa 3b			ld a, (.dmark+2)  
3bf3 32 67 ee			ld (debug_mark+2),a  
3bf6 18 03			jr .pastdmark  
3bf8 ..			.dmark: db "DTD"  
3bfb f1			.pastdmark: pop af  
3bfc			endm  
# End of macro DMARK
3bfc						CALLMONITOR 
3bfc cd 6f ee			call debug_vector  
3bff				endm  
# End of macro CALLMONITOR
3bff					endif 
3bff 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3c01 3e 00			ld a, 0 
3c03 32 37 ea			ld (cli_mvdot), a 
3c06 c3 63 3c			jp .dotgo 
3c09				NEXTW 
3c09 c3 81 1f			jp macro_next 
3c0c				endm 
# End of macro NEXTW
3c0c			.DOTF: 
3c0c				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3c0c 1c				db WORD_SYS_CORE+8             
3c0d 3a 3c			dw .DOT            
3c0f 03				db 2 + 1 
3c10 .. 00			db ".>",0              
3c13				endm 
# End of macro CWHEAD
3c13			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
3c13					; get value off TOS and display it 
3c13			        ; TODO BUG adds extra spaces 
3c13			        ; TODO BUG handle numerics? 
3c13					if DEBUG_FORTH_WORDS_KEY 
3c13						DMARK "DTC" 
3c13 f5				push af  
3c14 3a 28 3c			ld a, (.dmark)  
3c17 32 65 ee			ld (debug_mark),a  
3c1a 3a 29 3c			ld a, (.dmark+1)  
3c1d 32 66 ee			ld (debug_mark+1),a  
3c20 3a 2a 3c			ld a, (.dmark+2)  
3c23 32 67 ee			ld (debug_mark+2),a  
3c26 18 03			jr .pastdmark  
3c28 ..			.dmark: db "DTC"  
3c2b f1			.pastdmark: pop af  
3c2c			endm  
# End of macro DMARK
3c2c						CALLMONITOR 
3c2c cd 6f ee			call debug_vector  
3c2f				endm  
# End of macro CALLMONITOR
3c2f					endif 
3c2f 3e 01			ld a, 1 
3c31 32 37 ea			ld (cli_mvdot), a 
3c34 c3 63 3c			jp .dotgo 
3c37				NEXTW 
3c37 c3 81 1f			jp macro_next 
3c3a				endm 
# End of macro NEXTW
3c3a			 
3c3a			.DOT: 
3c3a				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3c3a 1c				db WORD_SYS_CORE+8             
3c3b 16 3e			dw .CLS            
3c3d 02				db 1 + 1 
3c3e .. 00			db ".",0              
3c40				endm 
# End of macro CWHEAD
3c40			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
3c40					; get value off TOS and display it 
3c40			 
3c40					if DEBUG_FORTH_WORDS_KEY 
3c40						DMARK "DOT" 
3c40 f5				push af  
3c41 3a 55 3c			ld a, (.dmark)  
3c44 32 65 ee			ld (debug_mark),a  
3c47 3a 56 3c			ld a, (.dmark+1)  
3c4a 32 66 ee			ld (debug_mark+1),a  
3c4d 3a 57 3c			ld a, (.dmark+2)  
3c50 32 67 ee			ld (debug_mark+2),a  
3c53 18 03			jr .pastdmark  
3c55 ..			.dmark: db "DOT"  
3c58 f1			.pastdmark: pop af  
3c59			endm  
# End of macro DMARK
3c59						CALLMONITOR 
3c59 cd 6f ee			call debug_vector  
3c5c				endm  
# End of macro CALLMONITOR
3c5c					endif 
3c5c 3e 00			ld a, 0 
3c5e 32 37 ea			ld (cli_mvdot), a 
3c61 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3c63				 
3c63			 
3c63			.dotgo: 
3c63			 
3c63			; move up type to on stack for parserv5 
3c63					FORTH_DSP 
3c63 cd 5b 1d			call macro_forth_dsp 
3c66				endm 
# End of macro FORTH_DSP
3c66				;FORTH_DSP_VALUE  
3c66			 
3c66			if DEBUG_FORTH_DOT 
3c66				DMARK "DOT" 
3c66 f5				push af  
3c67 3a 7b 3c			ld a, (.dmark)  
3c6a 32 65 ee			ld (debug_mark),a  
3c6d 3a 7c 3c			ld a, (.dmark+1)  
3c70 32 66 ee			ld (debug_mark+1),a  
3c73 3a 7d 3c			ld a, (.dmark+2)  
3c76 32 67 ee			ld (debug_mark+2),a  
3c79 18 03			jr .pastdmark  
3c7b ..			.dmark: db "DOT"  
3c7e f1			.pastdmark: pop af  
3c7f			endm  
# End of macro DMARK
3c7f				CALLMONITOR 
3c7f cd 6f ee			call debug_vector  
3c82				endm  
# End of macro CALLMONITOR
3c82			endif	 
3c82			;		.print: 
3c82			 
3c82 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3c83 23				inc hl   ; position to the actual value 
3c84 fe 01			cp DS_TYPE_STR 
3c86 20 06			jr nz, .dotnum1  
3c88			 
3c88			; display string 
3c88				FORTH_DSP_VALUE  
3c88 cd 7e 1d			call macro_forth_dsp_value 
3c8b				endm 
# End of macro FORTH_DSP_VALUE
3c8b eb				ex de,hl 
3c8c 18 49			jr .dotwrite 
3c8e			 
3c8e			.dotnum1: 
3c8e fe 02			cp DS_TYPE_INUM 
3c90 20 44			jr nz, .dotflot 
3c92			 
3c92			 
3c92			; display number 
3c92			 
3c92			;	push hl 
3c92			;	call clear_display 
3c92			;	pop hl 
3c92			 
3c92 5e				ld e, (hl) 
3c93 23				inc hl 
3c94 56				ld d, (hl) 
3c95 21 bb e2			ld hl, scratch 
3c98			if DEBUG_FORTH_DOT 
3c98				DMARK "DT1" 
3c98 f5				push af  
3c99 3a ad 3c			ld a, (.dmark)  
3c9c 32 65 ee			ld (debug_mark),a  
3c9f 3a ae 3c			ld a, (.dmark+1)  
3ca2 32 66 ee			ld (debug_mark+1),a  
3ca5 3a af 3c			ld a, (.dmark+2)  
3ca8 32 67 ee			ld (debug_mark+2),a  
3cab 18 03			jr .pastdmark  
3cad ..			.dmark: db "DT1"  
3cb0 f1			.pastdmark: pop af  
3cb1			endm  
# End of macro DMARK
3cb1				CALLMONITOR 
3cb1 cd 6f ee			call debug_vector  
3cb4				endm  
# End of macro CALLMONITOR
3cb4			endif	 
3cb4			 
3cb4 cd 0a 11			call uitoa_16 
3cb7 eb				ex de,hl 
3cb8			 
3cb8			if DEBUG_FORTH_DOT 
3cb8				DMARK "DT2" 
3cb8 f5				push af  
3cb9 3a cd 3c			ld a, (.dmark)  
3cbc 32 65 ee			ld (debug_mark),a  
3cbf 3a ce 3c			ld a, (.dmark+1)  
3cc2 32 66 ee			ld (debug_mark+1),a  
3cc5 3a cf 3c			ld a, (.dmark+2)  
3cc8 32 67 ee			ld (debug_mark+2),a  
3ccb 18 03			jr .pastdmark  
3ccd ..			.dmark: db "DT2"  
3cd0 f1			.pastdmark: pop af  
3cd1			endm  
# End of macro DMARK
3cd1				CALLMONITOR 
3cd1 cd 6f ee			call debug_vector  
3cd4				endm  
# End of macro CALLMONITOR
3cd4			endif	 
3cd4			 
3cd4			;	ld de, os_word_scratch 
3cd4 18 01			jr .dotwrite 
3cd6			 
3cd6 00			.dotflot:   nop 
3cd7			; TODO print floating point number 
3cd7			 
3cd7			.dotwrite:		 
3cd7			 
3cd7					; if c is set then set all '-' to spaces 
3cd7					; need to also take into account .>  
3cd7			 
3cd7 3e 01				ld a, 1 
3cd9 b9					cp c 
3cda 20 67				jr nz, .nodashswap 
3cdc			 
3cdc					; DE has the string to write, working with HL 
3cdc			 
3cdc 06 ff				ld b, 255 
3cde d5					push de 
3cdf e1					pop hl 
3ce0			 
3ce0			if DEBUG_FORTH_DOT 
3ce0				DMARK "DT-" 
3ce0 f5				push af  
3ce1 3a f5 3c			ld a, (.dmark)  
3ce4 32 65 ee			ld (debug_mark),a  
3ce7 3a f6 3c			ld a, (.dmark+1)  
3cea 32 66 ee			ld (debug_mark+1),a  
3ced 3a f7 3c			ld a, (.dmark+2)  
3cf0 32 67 ee			ld (debug_mark+2),a  
3cf3 18 03			jr .pastdmark  
3cf5 ..			.dmark: db "DT-"  
3cf8 f1			.pastdmark: pop af  
3cf9			endm  
# End of macro DMARK
3cf9				CALLMONITOR 
3cf9 cd 6f ee			call debug_vector  
3cfc				endm  
# End of macro CALLMONITOR
3cfc			endif	 
3cfc 7e			.dashscan:	ld a, (hl) 
3cfd fe 00				cp 0 
3cff 28 42				jr z, .nodashswap 
3d01 fe 2d				cp '-' 
3d03 20 03				jr nz, .dashskip 
3d05 3e 20				ld a, ' ' 
3d07 77					ld (hl), a 
3d08 23			.dashskip:	inc hl 
3d09			if DEBUG_FORTH_DOT 
3d09				DMARK "D-2" 
3d09 f5				push af  
3d0a 3a 1e 3d			ld a, (.dmark)  
3d0d 32 65 ee			ld (debug_mark),a  
3d10 3a 1f 3d			ld a, (.dmark+1)  
3d13 32 66 ee			ld (debug_mark+1),a  
3d16 3a 20 3d			ld a, (.dmark+2)  
3d19 32 67 ee			ld (debug_mark+2),a  
3d1c 18 03			jr .pastdmark  
3d1e ..			.dmark: db "D-2"  
3d21 f1			.pastdmark: pop af  
3d22			endm  
# End of macro DMARK
3d22				CALLMONITOR 
3d22 cd 6f ee			call debug_vector  
3d25				endm  
# End of macro CALLMONITOR
3d25			endif	 
3d25 10 d5				djnz .dashscan 
3d27			 
3d27			if DEBUG_FORTH_DOT 
3d27				DMARK "D-1" 
3d27 f5				push af  
3d28 3a 3c 3d			ld a, (.dmark)  
3d2b 32 65 ee			ld (debug_mark),a  
3d2e 3a 3d 3d			ld a, (.dmark+1)  
3d31 32 66 ee			ld (debug_mark+1),a  
3d34 3a 3e 3d			ld a, (.dmark+2)  
3d37 32 67 ee			ld (debug_mark+2),a  
3d3a 18 03			jr .pastdmark  
3d3c ..			.dmark: db "D-1"  
3d3f f1			.pastdmark: pop af  
3d40			endm  
# End of macro DMARK
3d40				CALLMONITOR 
3d40 cd 6f ee			call debug_vector  
3d43				endm  
# End of macro CALLMONITOR
3d43			endif	 
3d43			 
3d43			.nodashswap: 
3d43			 
3d43			if DEBUG_FORTH_DOT 
3d43				DMARK "D-o" 
3d43 f5				push af  
3d44 3a 58 3d			ld a, (.dmark)  
3d47 32 65 ee			ld (debug_mark),a  
3d4a 3a 59 3d			ld a, (.dmark+1)  
3d4d 32 66 ee			ld (debug_mark+1),a  
3d50 3a 5a 3d			ld a, (.dmark+2)  
3d53 32 67 ee			ld (debug_mark+2),a  
3d56 18 03			jr .pastdmark  
3d58 ..			.dmark: db "D-o"  
3d5b f1			.pastdmark: pop af  
3d5c			endm  
# End of macro DMARK
3d5c				CALLMONITOR 
3d5c cd 6f ee			call debug_vector  
3d5f				endm  
# End of macro CALLMONITOR
3d5f			endif	 
3d5f			 
3d5f d5					push de   ; save string start in case we need to advance print 
3d60			 
3d60 3a 58 ea				ld a, (f_cursor_ptr) 
3d63 cd db 0b				call str_at_display 
3d66 3a 36 ea				ld a,(cli_autodisplay) 
3d69 fe 00				cp 0 
3d6b 28 03				jr z, .noupdate 
3d6d cd eb 0b						call update_display 
3d70					.noupdate: 
3d70			 
3d70			 
3d70					; see if we need to advance the print position 
3d70			 
3d70 e1					pop hl   ; get back string 
3d71			;		ex de,hl 
3d71			 
3d71 3a 37 ea				ld a, (cli_mvdot) 
3d74			if DEBUG_FORTH_DOT 
3d74			;		ld e,a 
3d74				DMARK "D>1" 
3d74 f5				push af  
3d75 3a 89 3d			ld a, (.dmark)  
3d78 32 65 ee			ld (debug_mark),a  
3d7b 3a 8a 3d			ld a, (.dmark+1)  
3d7e 32 66 ee			ld (debug_mark+1),a  
3d81 3a 8b 3d			ld a, (.dmark+2)  
3d84 32 67 ee			ld (debug_mark+2),a  
3d87 18 03			jr .pastdmark  
3d89 ..			.dmark: db "D>1"  
3d8c f1			.pastdmark: pop af  
3d8d			endm  
# End of macro DMARK
3d8d				CALLMONITOR 
3d8d cd 6f ee			call debug_vector  
3d90				endm  
# End of macro CALLMONITOR
3d90			endif	 
3d90 fe 00				cp 0 
3d92 28 44				jr z, .noadv 
3d94					; yes, lets advance the print position 
3d94 3e 00				ld a, 0 
3d96 cd 66 11				call strlent 
3d99			if DEBUG_FORTH_DOT 
3d99				DMARK "D-?" 
3d99 f5				push af  
3d9a 3a ae 3d			ld a, (.dmark)  
3d9d 32 65 ee			ld (debug_mark),a  
3da0 3a af 3d			ld a, (.dmark+1)  
3da3 32 66 ee			ld (debug_mark+1),a  
3da6 3a b0 3d			ld a, (.dmark+2)  
3da9 32 67 ee			ld (debug_mark+2),a  
3dac 18 03			jr .pastdmark  
3dae ..			.dmark: db "D-?"  
3db1 f1			.pastdmark: pop af  
3db2			endm  
# End of macro DMARK
3db2				CALLMONITOR 
3db2 cd 6f ee			call debug_vector  
3db5				endm  
# End of macro CALLMONITOR
3db5			endif	 
3db5 3a 58 ea				ld a, (f_cursor_ptr) 
3db8 85					add a,l 
3db9					;call addatohl 
3db9					;ld a, l 
3db9 32 58 ea				ld (f_cursor_ptr), a   ; save new pos 
3dbc			 
3dbc			if DEBUG_FORTH_DOT 
3dbc				DMARK "D->" 
3dbc f5				push af  
3dbd 3a d1 3d			ld a, (.dmark)  
3dc0 32 65 ee			ld (debug_mark),a  
3dc3 3a d2 3d			ld a, (.dmark+1)  
3dc6 32 66 ee			ld (debug_mark+1),a  
3dc9 3a d3 3d			ld a, (.dmark+2)  
3dcc 32 67 ee			ld (debug_mark+2),a  
3dcf 18 03			jr .pastdmark  
3dd1 ..			.dmark: db "D->"  
3dd4 f1			.pastdmark: pop af  
3dd5			endm  
# End of macro DMARK
3dd5				CALLMONITOR 
3dd5 cd 6f ee			call debug_vector  
3dd8				endm  
# End of macro CALLMONITOR
3dd8			endif	 
3dd8			 
3dd8			.noadv:	 
3dd8			 
3dd8					if DEBUG_FORTH_DOT_WAIT 
3dd8							call next_page_prompt 
3dd8					endif	 
3dd8			; TODO this pop off the stack causes a crash. i dont know why 
3dd8			 
3dd8			 
3dd8			if DEBUG_FORTH_DOT 
3dd8				DMARK "DTh" 
3dd8 f5				push af  
3dd9 3a ed 3d			ld a, (.dmark)  
3ddc 32 65 ee			ld (debug_mark),a  
3ddf 3a ee 3d			ld a, (.dmark+1)  
3de2 32 66 ee			ld (debug_mark+1),a  
3de5 3a ef 3d			ld a, (.dmark+2)  
3de8 32 67 ee			ld (debug_mark+2),a  
3deb 18 03			jr .pastdmark  
3ded ..			.dmark: db "DTh"  
3df0 f1			.pastdmark: pop af  
3df1			endm  
# End of macro DMARK
3df1				CALLMONITOR 
3df1 cd 6f ee			call debug_vector  
3df4				endm  
# End of macro CALLMONITOR
3df4			endif	 
3df4			 
3df4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3df4 cd 4d 1e			call macro_forth_dsp_pop 
3df7				endm 
# End of macro FORTH_DSP_POP
3df7			 
3df7			if DEBUG_FORTH_DOT 
3df7				DMARK "DTi" 
3df7 f5				push af  
3df8 3a 0c 3e			ld a, (.dmark)  
3dfb 32 65 ee			ld (debug_mark),a  
3dfe 3a 0d 3e			ld a, (.dmark+1)  
3e01 32 66 ee			ld (debug_mark+1),a  
3e04 3a 0e 3e			ld a, (.dmark+2)  
3e07 32 67 ee			ld (debug_mark+2),a  
3e0a 18 03			jr .pastdmark  
3e0c ..			.dmark: db "DTi"  
3e0f f1			.pastdmark: pop af  
3e10			endm  
# End of macro DMARK
3e10				CALLMONITOR 
3e10 cd 6f ee			call debug_vector  
3e13				endm  
# End of macro CALLMONITOR
3e13			endif	 
3e13			 
3e13			 
3e13					NEXTW 
3e13 c3 81 1f			jp macro_next 
3e16				endm 
# End of macro NEXTW
3e16			 
3e16			.CLS: 
3e16				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3e16 35				db WORD_SYS_CORE+33             
3e17 43 3e			dw .DRAW            
3e19 04				db 3 + 1 
3e1a .. 00			db "CLS",0              
3e1e				endm 
# End of macro CWHEAD
3e1e			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3e1e					if DEBUG_FORTH_WORDS_KEY 
3e1e						DMARK "CLS" 
3e1e f5				push af  
3e1f 3a 33 3e			ld a, (.dmark)  
3e22 32 65 ee			ld (debug_mark),a  
3e25 3a 34 3e			ld a, (.dmark+1)  
3e28 32 66 ee			ld (debug_mark+1),a  
3e2b 3a 35 3e			ld a, (.dmark+2)  
3e2e 32 67 ee			ld (debug_mark+2),a  
3e31 18 03			jr .pastdmark  
3e33 ..			.dmark: db "CLS"  
3e36 f1			.pastdmark: pop af  
3e37			endm  
# End of macro DMARK
3e37						CALLMONITOR 
3e37 cd 6f ee			call debug_vector  
3e3a				endm  
# End of macro CALLMONITOR
3e3a					endif 
3e3a cd c8 0b				call clear_display 
3e3d c3 51 3f				jp .home		; and home cursor 
3e40					NEXTW 
3e40 c3 81 1f			jp macro_next 
3e43				endm 
# End of macro NEXTW
3e43			 
3e43			.DRAW: 
3e43				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3e43 36				db WORD_SYS_CORE+34             
3e44 6e 3e			dw .DUMP            
3e46 05				db 4 + 1 
3e47 .. 00			db "DRAW",0              
3e4c				endm 
# End of macro CWHEAD
3e4c			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3e4c					if DEBUG_FORTH_WORDS_KEY 
3e4c						DMARK "DRW" 
3e4c f5				push af  
3e4d 3a 61 3e			ld a, (.dmark)  
3e50 32 65 ee			ld (debug_mark),a  
3e53 3a 62 3e			ld a, (.dmark+1)  
3e56 32 66 ee			ld (debug_mark+1),a  
3e59 3a 63 3e			ld a, (.dmark+2)  
3e5c 32 67 ee			ld (debug_mark+2),a  
3e5f 18 03			jr .pastdmark  
3e61 ..			.dmark: db "DRW"  
3e64 f1			.pastdmark: pop af  
3e65			endm  
# End of macro DMARK
3e65						CALLMONITOR 
3e65 cd 6f ee			call debug_vector  
3e68				endm  
# End of macro CALLMONITOR
3e68					endif 
3e68 cd eb 0b				call update_display 
3e6b					NEXTW 
3e6b c3 81 1f			jp macro_next 
3e6e				endm 
# End of macro NEXTW
3e6e			 
3e6e			.DUMP: 
3e6e				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3e6e 37				db WORD_SYS_CORE+35             
3e6f a6 3e			dw .CDUMP            
3e71 05				db 4 + 1 
3e72 .. 00			db "DUMP",0              
3e77				endm 
# End of macro CWHEAD
3e77			; | DUMP ( x -- ) With address x display dump   | DONE 
3e77			; TODO pop address to use off of the stack 
3e77					if DEBUG_FORTH_WORDS_KEY 
3e77						DMARK "DUM" 
3e77 f5				push af  
3e78 3a 8c 3e			ld a, (.dmark)  
3e7b 32 65 ee			ld (debug_mark),a  
3e7e 3a 8d 3e			ld a, (.dmark+1)  
3e81 32 66 ee			ld (debug_mark+1),a  
3e84 3a 8e 3e			ld a, (.dmark+2)  
3e87 32 67 ee			ld (debug_mark+2),a  
3e8a 18 03			jr .pastdmark  
3e8c ..			.dmark: db "DUM"  
3e8f f1			.pastdmark: pop af  
3e90			endm  
# End of macro DMARK
3e90						CALLMONITOR 
3e90 cd 6f ee			call debug_vector  
3e93				endm  
# End of macro CALLMONITOR
3e93					endif 
3e93 cd c8 0b				call clear_display 
3e96			 
3e96					; get address 
3e96			 
3e96					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e96 cd 95 1d			call macro_dsp_valuehl 
3e99				endm 
# End of macro FORTH_DSP_VALUEHL
3e99				 
3e99					; save it for cdump 
3e99			 
3e99 22 de e5				ld (os_cur_ptr),hl 
3e9c			 
3e9c					; destroy value TOS 
3e9c			 
3e9c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e9c cd 4d 1e			call macro_forth_dsp_pop 
3e9f				endm 
# End of macro FORTH_DSP_POP
3e9f			 
3e9f cd 10 1a				call dumpcont	; skip old style of param parsing	 
3ea2 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3ea3					NEXTW 
3ea3 c3 81 1f			jp macro_next 
3ea6				endm 
# End of macro NEXTW
3ea6			.CDUMP: 
3ea6				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3ea6 38				db WORD_SYS_CORE+36             
3ea7 d6 3e			dw .DAT            
3ea9 06				db 5 + 1 
3eaa .. 00			db "CDUMP",0              
3eb0				endm 
# End of macro CWHEAD
3eb0			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3eb0					if DEBUG_FORTH_WORDS_KEY 
3eb0						DMARK "CDP" 
3eb0 f5				push af  
3eb1 3a c5 3e			ld a, (.dmark)  
3eb4 32 65 ee			ld (debug_mark),a  
3eb7 3a c6 3e			ld a, (.dmark+1)  
3eba 32 66 ee			ld (debug_mark+1),a  
3ebd 3a c7 3e			ld a, (.dmark+2)  
3ec0 32 67 ee			ld (debug_mark+2),a  
3ec3 18 03			jr .pastdmark  
3ec5 ..			.dmark: db "CDP"  
3ec8 f1			.pastdmark: pop af  
3ec9			endm  
# End of macro DMARK
3ec9						CALLMONITOR 
3ec9 cd 6f ee			call debug_vector  
3ecc				endm  
# End of macro CALLMONITOR
3ecc					endif 
3ecc cd c8 0b				call clear_display 
3ecf cd 10 1a				call dumpcont	 
3ed2 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3ed3					NEXTW 
3ed3 c3 81 1f			jp macro_next 
3ed6				endm 
# End of macro NEXTW
3ed6			 
3ed6			 
3ed6			 
3ed6			 
3ed6			.DAT: 
3ed6				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3ed6 3d				db WORD_SYS_CORE+41             
3ed7 2c 3f			dw .HOME            
3ed9 03				db 2 + 1 
3eda .. 00			db "AT",0              
3edd				endm 
# End of macro CWHEAD
3edd			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3edd					if DEBUG_FORTH_WORDS_KEY 
3edd						DMARK "AT." 
3edd f5				push af  
3ede 3a f2 3e			ld a, (.dmark)  
3ee1 32 65 ee			ld (debug_mark),a  
3ee4 3a f3 3e			ld a, (.dmark+1)  
3ee7 32 66 ee			ld (debug_mark+1),a  
3eea 3a f4 3e			ld a, (.dmark+2)  
3eed 32 67 ee			ld (debug_mark+2),a  
3ef0 18 03			jr .pastdmark  
3ef2 ..			.dmark: db "AT."  
3ef5 f1			.pastdmark: pop af  
3ef6			endm  
# End of macro DMARK
3ef6						CALLMONITOR 
3ef6 cd 6f ee			call debug_vector  
3ef9				endm  
# End of macro CALLMONITOR
3ef9					endif 
3ef9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ef9 cd 95 1d			call macro_dsp_valuehl 
3efc				endm 
# End of macro FORTH_DSP_VALUEHL
3efc			 
3efc			 
3efc					; TODO save cursor row 
3efc 7d					ld a,l 
3efd fe 02				cp 2 
3eff 20 04				jr nz, .crow3 
3f01 3e 28				ld a, display_row_2 
3f03 18 12				jr .ccol1 
3f05 fe 03		.crow3:		cp 3 
3f07 20 04				jr nz, .crow4 
3f09 3e 50				ld a, display_row_3 
3f0b 18 0a				jr .ccol1 
3f0d fe 04		.crow4:		cp 4 
3f0f 20 04				jr nz, .crow1 
3f11 3e 78				ld a, display_row_4 
3f13 18 02				jr .ccol1 
3f15 3e 00		.crow1:		ld a,display_row_1 
3f17 f5			.ccol1:		push af			; got row offset 
3f18 6f					ld l,a 
3f19 26 00				ld h,0 
3f1b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f1b cd 4d 1e			call macro_forth_dsp_pop 
3f1e				endm 
# End of macro FORTH_DSP_POP
3f1e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f1e cd 95 1d			call macro_dsp_valuehl 
3f21				endm 
# End of macro FORTH_DSP_VALUEHL
3f21					; TODO save cursor col 
3f21 f1					pop af 
3f22 85					add l		; add col offset 
3f23 32 58 ea				ld (f_cursor_ptr), a 
3f26					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f26 cd 4d 1e			call macro_forth_dsp_pop 
3f29				endm 
# End of macro FORTH_DSP_POP
3f29			 
3f29					; calculate  
3f29			 
3f29					NEXTW 
3f29 c3 81 1f			jp macro_next 
3f2c				endm 
# End of macro NEXTW
3f2c			 
3f2c			 
3f2c			.HOME: 
3f2c				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
3f2c 41				db WORD_SYS_CORE+45             
3f2d 59 3f			dw .CR            
3f2f 05				db 4 + 1 
3f30 .. 00			db "HOME",0              
3f35				endm 
# End of macro CWHEAD
3f35			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3f35					if DEBUG_FORTH_WORDS_KEY 
3f35						DMARK "HOM" 
3f35 f5				push af  
3f36 3a 4a 3f			ld a, (.dmark)  
3f39 32 65 ee			ld (debug_mark),a  
3f3c 3a 4b 3f			ld a, (.dmark+1)  
3f3f 32 66 ee			ld (debug_mark+1),a  
3f42 3a 4c 3f			ld a, (.dmark+2)  
3f45 32 67 ee			ld (debug_mark+2),a  
3f48 18 03			jr .pastdmark  
3f4a ..			.dmark: db "HOM"  
3f4d f1			.pastdmark: pop af  
3f4e			endm  
# End of macro DMARK
3f4e						CALLMONITOR 
3f4e cd 6f ee			call debug_vector  
3f51				endm  
# End of macro CALLMONITOR
3f51					endif 
3f51 3e 00		.home:		ld a, 0		; and home cursor 
3f53 32 58 ea				ld (f_cursor_ptr), a 
3f56					NEXTW 
3f56 c3 81 1f			jp macro_next 
3f59				endm 
# End of macro NEXTW
3f59			 
3f59			 
3f59			.CR: 
3f59				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
3f59 46				db WORD_SYS_CORE+50             
3f5a 94 3f			dw .SPACE            
3f5c 03				db 2 + 1 
3f5d .. 00			db "CR",0              
3f60				endm 
# End of macro CWHEAD
3f60			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
3f60					if DEBUG_FORTH_WORDS_KEY 
3f60						DMARK "CR." 
3f60 f5				push af  
3f61 3a 75 3f			ld a, (.dmark)  
3f64 32 65 ee			ld (debug_mark),a  
3f67 3a 76 3f			ld a, (.dmark+1)  
3f6a 32 66 ee			ld (debug_mark+1),a  
3f6d 3a 77 3f			ld a, (.dmark+2)  
3f70 32 67 ee			ld (debug_mark+2),a  
3f73 18 03			jr .pastdmark  
3f75 ..			.dmark: db "CR."  
3f78 f1			.pastdmark: pop af  
3f79			endm  
# End of macro DMARK
3f79						CALLMONITOR 
3f79 cd 6f ee			call debug_vector  
3f7c				endm  
# End of macro CALLMONITOR
3f7c					endif 
3f7c 3e 0d				ld a, 13 
3f7e 32 bb e2				ld (scratch),a 
3f81 3e 0a				ld a, 10 
3f83 32 bc e2				ld (scratch+1),a 
3f86 3e 00				ld a, 0 
3f88 32 bd e2				ld (scratch+2),a 
3f8b 21 bb e2				ld hl, scratch 
3f8e cd fe 1b				call forth_push_str 
3f91					 
3f91				       NEXTW 
3f91 c3 81 1f			jp macro_next 
3f94				endm 
# End of macro NEXTW
3f94			.SPACE: 
3f94				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3f94 46				db WORD_SYS_CORE+50             
3f95 ca 3f			dw .SPACES            
3f97 03				db 2 + 1 
3f98 .. 00			db "BL",0              
3f9b				endm 
# End of macro CWHEAD
3f9b			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3f9b					if DEBUG_FORTH_WORDS_KEY 
3f9b						DMARK "BL." 
3f9b f5				push af  
3f9c 3a b0 3f			ld a, (.dmark)  
3f9f 32 65 ee			ld (debug_mark),a  
3fa2 3a b1 3f			ld a, (.dmark+1)  
3fa5 32 66 ee			ld (debug_mark+1),a  
3fa8 3a b2 3f			ld a, (.dmark+2)  
3fab 32 67 ee			ld (debug_mark+2),a  
3fae 18 03			jr .pastdmark  
3fb0 ..			.dmark: db "BL."  
3fb3 f1			.pastdmark: pop af  
3fb4			endm  
# End of macro DMARK
3fb4						CALLMONITOR 
3fb4 cd 6f ee			call debug_vector  
3fb7				endm  
# End of macro CALLMONITOR
3fb7					endif 
3fb7 3e 20				ld a, " " 
3fb9 32 bb e2				ld (scratch),a 
3fbc 3e 00				ld a, 0 
3fbe 32 bc e2				ld (scratch+1),a 
3fc1 21 bb e2				ld hl, scratch 
3fc4 cd fe 1b				call forth_push_str 
3fc7					 
3fc7				       NEXTW 
3fc7 c3 81 1f			jp macro_next 
3fca				endm 
# End of macro NEXTW
3fca			 
3fca			;.blstr: db " ", 0 
3fca			 
3fca			.SPACES: 
3fca				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3fca 47				db WORD_SYS_CORE+51             
3fcb 65 40			dw .SCROLL            
3fcd 07				db 6 + 1 
3fce .. 00			db "SPACES",0              
3fd5				endm 
# End of macro CWHEAD
3fd5			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
3fd5					if DEBUG_FORTH_WORDS_KEY 
3fd5						DMARK "SPS" 
3fd5 f5				push af  
3fd6 3a ea 3f			ld a, (.dmark)  
3fd9 32 65 ee			ld (debug_mark),a  
3fdc 3a eb 3f			ld a, (.dmark+1)  
3fdf 32 66 ee			ld (debug_mark+1),a  
3fe2 3a ec 3f			ld a, (.dmark+2)  
3fe5 32 67 ee			ld (debug_mark+2),a  
3fe8 18 03			jr .pastdmark  
3fea ..			.dmark: db "SPS"  
3fed f1			.pastdmark: pop af  
3fee			endm  
# End of macro DMARK
3fee						CALLMONITOR 
3fee cd 6f ee			call debug_vector  
3ff1				endm  
# End of macro CALLMONITOR
3ff1					endif 
3ff1			 
3ff1			 
3ff1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ff1 cd 95 1d			call macro_dsp_valuehl 
3ff4				endm 
# End of macro FORTH_DSP_VALUEHL
3ff4			 
3ff4 e5					push hl    ; u 
3ff5					if DEBUG_FORTH_WORDS 
3ff5						DMARK "SPA" 
3ff5 f5				push af  
3ff6 3a 0a 40			ld a, (.dmark)  
3ff9 32 65 ee			ld (debug_mark),a  
3ffc 3a 0b 40			ld a, (.dmark+1)  
3fff 32 66 ee			ld (debug_mark+1),a  
4002 3a 0c 40			ld a, (.dmark+2)  
4005 32 67 ee			ld (debug_mark+2),a  
4008 18 03			jr .pastdmark  
400a ..			.dmark: db "SPA"  
400d f1			.pastdmark: pop af  
400e			endm  
# End of macro DMARK
400e						CALLMONITOR 
400e cd 6f ee			call debug_vector  
4011				endm  
# End of macro CALLMONITOR
4011					endif 
4011			 
4011					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4011 cd 4d 1e			call macro_forth_dsp_pop 
4014				endm 
# End of macro FORTH_DSP_POP
4014 e1					pop hl 
4015 0e 00				ld c, 0 
4017 45					ld b, l 
4018 21 bb e2				ld hl, scratch  
401b			 
401b					if DEBUG_FORTH_WORDS 
401b						DMARK "SP2" 
401b f5				push af  
401c 3a 30 40			ld a, (.dmark)  
401f 32 65 ee			ld (debug_mark),a  
4022 3a 31 40			ld a, (.dmark+1)  
4025 32 66 ee			ld (debug_mark+1),a  
4028 3a 32 40			ld a, (.dmark+2)  
402b 32 67 ee			ld (debug_mark+2),a  
402e 18 03			jr .pastdmark  
4030 ..			.dmark: db "SP2"  
4033 f1			.pastdmark: pop af  
4034			endm  
# End of macro DMARK
4034						CALLMONITOR 
4034 cd 6f ee			call debug_vector  
4037				endm  
# End of macro CALLMONITOR
4037					endif 
4037 3e 20				ld a, ' ' 
4039			.spaces1:	 
4039 77					ld (hl),a 
403a 23					inc hl 
403b					 
403b 10 fc				djnz .spaces1 
403d 3e 00				ld a,0 
403f 77					ld (hl),a 
4040 21 bb e2				ld hl, scratch 
4043					if DEBUG_FORTH_WORDS 
4043						DMARK "SP3" 
4043 f5				push af  
4044 3a 58 40			ld a, (.dmark)  
4047 32 65 ee			ld (debug_mark),a  
404a 3a 59 40			ld a, (.dmark+1)  
404d 32 66 ee			ld (debug_mark+1),a  
4050 3a 5a 40			ld a, (.dmark+2)  
4053 32 67 ee			ld (debug_mark+2),a  
4056 18 03			jr .pastdmark  
4058 ..			.dmark: db "SP3"  
405b f1			.pastdmark: pop af  
405c			endm  
# End of macro DMARK
405c						CALLMONITOR 
405c cd 6f ee			call debug_vector  
405f				endm  
# End of macro CALLMONITOR
405f					endif 
405f cd fe 1b				call forth_push_str 
4062			 
4062				       NEXTW 
4062 c3 81 1f			jp macro_next 
4065				endm 
# End of macro NEXTW
4065			 
4065			 
4065			 
4065			.SCROLL: 
4065				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4065 53				db WORD_SYS_CORE+63             
4066 92 40			dw .SCROLLD            
4068 07				db 6 + 1 
4069 .. 00			db "SCROLL",0              
4070				endm 
# End of macro CWHEAD
4070			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4070					if DEBUG_FORTH_WORDS_KEY 
4070						DMARK "SCR" 
4070 f5				push af  
4071 3a 85 40			ld a, (.dmark)  
4074 32 65 ee			ld (debug_mark),a  
4077 3a 86 40			ld a, (.dmark+1)  
407a 32 66 ee			ld (debug_mark+1),a  
407d 3a 87 40			ld a, (.dmark+2)  
4080 32 67 ee			ld (debug_mark+2),a  
4083 18 03			jr .pastdmark  
4085 ..			.dmark: db "SCR"  
4088 f1			.pastdmark: pop af  
4089			endm  
# End of macro DMARK
4089						CALLMONITOR 
4089 cd 6f ee			call debug_vector  
408c				endm  
# End of macro CALLMONITOR
408c					endif 
408c			 
408c cd 8a 0b			call scroll_up 
408f			;	call update_display 
408f			 
408f					NEXTW 
408f c3 81 1f			jp macro_next 
4092				endm 
# End of macro NEXTW
4092			 
4092			 
4092			 
4092			;		; get dir 
4092			; 
4092			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4092			; 
4092			;		push hl 
4092			; 
4092			;		; destroy value TOS 
4092			; 
4092			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4092			; 
4092			;		; get count 
4092			; 
4092			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4092			; 
4092			;		push hl 
4092			; 
4092			;		; destroy value TOS 
4092			; 
4092			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4092			; 
4092			;		; one value on hl get other one back 
4092			; 
4092			;		pop bc    ; count 
4092			; 
4092			;		pop de   ; dir 
4092			; 
4092			; 
4092			;		ld b, c 
4092			; 
4092			;.scrolldir:     push bc 
4092			;		push de 
4092			; 
4092			;		ld a, 0 
4092			;		cp e 
4092			;		jr z, .scrollup  
4092			;		call scroll_down 
4092			;		jr .scrollnext 
4092			;.scrollup:	call scroll_up 
4092			; 
4092			;		 
4092			;.scrollnext: 
4092			;		pop de 
4092			;		pop bc 
4092			;		djnz .scrolldir 
4092			; 
4092			; 
4092			; 
4092			; 
4092			; 
4092			;		NEXTW 
4092			 
4092			.SCROLLD: 
4092				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4092 53				db WORD_SYS_CORE+63             
4093 c0 40			dw .ATQ            
4095 08				db 7 + 1 
4096 .. 00			db "SCROLLD",0              
409e				endm 
# End of macro CWHEAD
409e			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
409e					if DEBUG_FORTH_WORDS_KEY 
409e						DMARK "SCD" 
409e f5				push af  
409f 3a b3 40			ld a, (.dmark)  
40a2 32 65 ee			ld (debug_mark),a  
40a5 3a b4 40			ld a, (.dmark+1)  
40a8 32 66 ee			ld (debug_mark+1),a  
40ab 3a b5 40			ld a, (.dmark+2)  
40ae 32 67 ee			ld (debug_mark+2),a  
40b1 18 03			jr .pastdmark  
40b3 ..			.dmark: db "SCD"  
40b6 f1			.pastdmark: pop af  
40b7			endm  
# End of macro DMARK
40b7						CALLMONITOR 
40b7 cd 6f ee			call debug_vector  
40ba				endm  
# End of macro CALLMONITOR
40ba					endif 
40ba			 
40ba cd ae 0b			call scroll_down 
40bd			;	call update_display 
40bd			 
40bd					NEXTW 
40bd c3 81 1f			jp macro_next 
40c0				endm 
# End of macro NEXTW
40c0			 
40c0			 
40c0			.ATQ: 
40c0				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
40c0 62				db WORD_SYS_CORE+78             
40c1 1e 41			dw .AUTODSP            
40c3 04				db 3 + 1 
40c4 .. 00			db "AT@",0              
40c8				endm 
# End of macro CWHEAD
40c8			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
40c8					if DEBUG_FORTH_WORDS_KEY 
40c8						DMARK "ATA" 
40c8 f5				push af  
40c9 3a dd 40			ld a, (.dmark)  
40cc 32 65 ee			ld (debug_mark),a  
40cf 3a de 40			ld a, (.dmark+1)  
40d2 32 66 ee			ld (debug_mark+1),a  
40d5 3a df 40			ld a, (.dmark+2)  
40d8 32 67 ee			ld (debug_mark+2),a  
40db 18 03			jr .pastdmark  
40dd ..			.dmark: db "ATA"  
40e0 f1			.pastdmark: pop af  
40e1			endm  
# End of macro DMARK
40e1						CALLMONITOR 
40e1 cd 6f ee			call debug_vector  
40e4				endm  
# End of macro CALLMONITOR
40e4					endif 
40e4			 
40e4			 
40e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40e4 cd 95 1d			call macro_dsp_valuehl 
40e7				endm 
# End of macro FORTH_DSP_VALUEHL
40e7			 
40e7					; TODO save cursor row 
40e7 7d					ld a,l 
40e8 fe 02				cp 2 
40ea 20 04				jr nz, .crow3aq 
40ec 3e 28				ld a, display_row_2 
40ee 18 12				jr .ccol1aq 
40f0 fe 03		.crow3aq:		cp 3 
40f2 20 04				jr nz, .crow4aq 
40f4 3e 50				ld a, display_row_3 
40f6 18 0a				jr .ccol1aq 
40f8 fe 04		.crow4aq:		cp 4 
40fa 20 04				jr nz, .crow1aq 
40fc 3e 78				ld a, display_row_4 
40fe 18 02				jr .ccol1aq 
4100 3e 00		.crow1aq:		ld a,display_row_1 
4102 f5			.ccol1aq:		push af			; got row offset 
4103 6f					ld l,a 
4104 26 00				ld h,0 
4106					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4106 cd 4d 1e			call macro_forth_dsp_pop 
4109				endm 
# End of macro FORTH_DSP_POP
4109					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4109 cd 95 1d			call macro_dsp_valuehl 
410c				endm 
# End of macro FORTH_DSP_VALUEHL
410c					; TODO save cursor col 
410c f1					pop af 
410d 85					add l		; add col offset 
410e			 
410e					; add current frame buffer address 
410e 2a c6 eb				ld hl, (display_fb_active) 
4111 cd f5 0d				call addatohl 
4114			 
4114			 
4114			 
4114			 
4114					; get char frame buffer location offset in hl 
4114			 
4114 7e					ld a,(hl) 
4115 26 00				ld h, 0 
4117 6f					ld l, a 
4118			 
4118 cd 90 1b				call forth_push_numhl 
411b			 
411b			 
411b					NEXTW 
411b c3 81 1f			jp macro_next 
411e				endm 
# End of macro NEXTW
411e			 
411e			.AUTODSP: 
411e				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
411e 63				db WORD_SYS_CORE+79             
411f 34 41			dw .MENU            
4121 05				db 4 + 1 
4122 .. 00			db "ADSP",0              
4127				endm 
# End of macro CWHEAD
4127			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4127			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4127			 
4127					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4127 cd 95 1d			call macro_dsp_valuehl 
412a				endm 
# End of macro FORTH_DSP_VALUEHL
412a			 
412a			;		push hl 
412a			 
412a					; destroy value TOS 
412a			 
412a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
412a cd 4d 1e			call macro_forth_dsp_pop 
412d				endm 
# End of macro FORTH_DSP_POP
412d			 
412d			;		pop hl 
412d			 
412d 7d					ld a,l 
412e 32 36 ea				ld (cli_autodisplay), a 
4131				       NEXTW 
4131 c3 81 1f			jp macro_next 
4134				endm 
# End of macro NEXTW
4134			 
4134			.MENU: 
4134				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
4134 70				db WORD_SYS_CORE+92             
4135 dd 41			dw .ENDDISPLAY            
4137 05				db 4 + 1 
4138 .. 00			db "MENU",0              
413d				endm 
# End of macro CWHEAD
413d			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
413d			 
413d			;		; get number of items on the stack 
413d			; 
413d				 
413d					FORTH_DSP_VALUEHL 
413d cd 95 1d			call macro_dsp_valuehl 
4140				endm 
# End of macro FORTH_DSP_VALUEHL
4140				 
4140					if DEBUG_FORTH_WORDS_KEY 
4140						DMARK "MNU" 
4140 f5				push af  
4141 3a 55 41			ld a, (.dmark)  
4144 32 65 ee			ld (debug_mark),a  
4147 3a 56 41			ld a, (.dmark+1)  
414a 32 66 ee			ld (debug_mark+1),a  
414d 3a 57 41			ld a, (.dmark+2)  
4150 32 67 ee			ld (debug_mark+2),a  
4153 18 03			jr .pastdmark  
4155 ..			.dmark: db "MNU"  
4158 f1			.pastdmark: pop af  
4159			endm  
# End of macro DMARK
4159						CALLMONITOR 
4159 cd 6f ee			call debug_vector  
415c				endm  
# End of macro CALLMONITOR
415c					endif 
415c			 
415c 45					ld b, l	 
415d 05					dec b 
415e			 
415e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
415e cd 4d 1e			call macro_forth_dsp_pop 
4161				endm 
# End of macro FORTH_DSP_POP
4161			 
4161			 
4161					; go directly through the stack to pluck out the string pointers and build an array 
4161			 
4161			;		FORTH_DSP 
4161			 
4161					; hl contains top most stack item 
4161				 
4161 11 bb e2				ld de, scratch 
4164			 
4164			.mbuild: 
4164			 
4164					FORTH_DSP_VALUEHL 
4164 cd 95 1d			call macro_dsp_valuehl 
4167				endm 
# End of macro FORTH_DSP_VALUEHL
4167			 
4167					if DEBUG_FORTH_WORDS 
4167						DMARK "MN3" 
4167 f5				push af  
4168 3a 7c 41			ld a, (.dmark)  
416b 32 65 ee			ld (debug_mark),a  
416e 3a 7d 41			ld a, (.dmark+1)  
4171 32 66 ee			ld (debug_mark+1),a  
4174 3a 7e 41			ld a, (.dmark+2)  
4177 32 67 ee			ld (debug_mark+2),a  
417a 18 03			jr .pastdmark  
417c ..			.dmark: db "MN3"  
417f f1			.pastdmark: pop af  
4180			endm  
# End of macro DMARK
4180						CALLMONITOR 
4180 cd 6f ee			call debug_vector  
4183				endm  
# End of macro CALLMONITOR
4183					endif 
4183 eb					ex de, hl 
4184 73					ld (hl), e 
4185 23					inc hl 
4186 72					ld (hl), d 
4187 23					inc hl 
4188 eb					ex de, hl 
4189			 
4189					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4189 cd 4d 1e			call macro_forth_dsp_pop 
418c				endm 
# End of macro FORTH_DSP_POP
418c			 
418c 10 d6				djnz .mbuild 
418e			 
418e					; done add term 
418e			 
418e eb					ex de, hl 
418f 36 00				ld (hl), 0 
4191 23					inc hl 
4192 36 00				ld (hl), 0 
4194			 
4194				 
4194					 
4194 21 bb e2				ld hl, scratch 
4197			 
4197					if DEBUG_FORTH_WORDS 
4197						DMARK "MNx" 
4197 f5				push af  
4198 3a ac 41			ld a, (.dmark)  
419b 32 65 ee			ld (debug_mark),a  
419e 3a ad 41			ld a, (.dmark+1)  
41a1 32 66 ee			ld (debug_mark+1),a  
41a4 3a ae 41			ld a, (.dmark+2)  
41a7 32 67 ee			ld (debug_mark+2),a  
41aa 18 03			jr .pastdmark  
41ac ..			.dmark: db "MNx"  
41af f1			.pastdmark: pop af  
41b0			endm  
# End of macro DMARK
41b0						CALLMONITOR 
41b0 cd 6f ee			call debug_vector  
41b3				endm  
# End of macro CALLMONITOR
41b3					endif 
41b3			 
41b3			 
41b3			 
41b3 3e 00				ld a, 0 
41b5 cd f9 0b				call menu 
41b8			 
41b8			 
41b8 6f					ld l, a 
41b9 26 00				ld h, 0 
41bb			 
41bb					if DEBUG_FORTH_WORDS 
41bb						DMARK "MNr" 
41bb f5				push af  
41bc 3a d0 41			ld a, (.dmark)  
41bf 32 65 ee			ld (debug_mark),a  
41c2 3a d1 41			ld a, (.dmark+1)  
41c5 32 66 ee			ld (debug_mark+1),a  
41c8 3a d2 41			ld a, (.dmark+2)  
41cb 32 67 ee			ld (debug_mark+2),a  
41ce 18 03			jr .pastdmark  
41d0 ..			.dmark: db "MNr"  
41d3 f1			.pastdmark: pop af  
41d4			endm  
# End of macro DMARK
41d4						CALLMONITOR 
41d4 cd 6f ee			call debug_vector  
41d7				endm  
# End of macro CALLMONITOR
41d7					endif 
41d7			 
41d7 cd 90 1b				call forth_push_numhl 
41da			 
41da			 
41da			 
41da			 
41da				       NEXTW 
41da c3 81 1f			jp macro_next 
41dd				endm 
# End of macro NEXTW
41dd			 
41dd			 
41dd			.ENDDISPLAY: 
41dd			 
41dd			; eof 
# End of file forth_words_display.asm
41dd			include "forth_words_str.asm" 
41dd			 
41dd			; | ## String Words 
41dd			 
41dd			.PTR:   
41dd			 
41dd				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
41dd 48				db WORD_SYS_CORE+52             
41de 0a 42			dw .STYPE            
41e0 04				db 3 + 1 
41e1 .. 00			db "PTR",0              
41e5				endm 
# End of macro CWHEAD
41e5			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
41e5			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
41e5			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
41e5			 
41e5					if DEBUG_FORTH_WORDS_KEY 
41e5						DMARK "PTR" 
41e5 f5				push af  
41e6 3a fa 41			ld a, (.dmark)  
41e9 32 65 ee			ld (debug_mark),a  
41ec 3a fb 41			ld a, (.dmark+1)  
41ef 32 66 ee			ld (debug_mark+1),a  
41f2 3a fc 41			ld a, (.dmark+2)  
41f5 32 67 ee			ld (debug_mark+2),a  
41f8 18 03			jr .pastdmark  
41fa ..			.dmark: db "PTR"  
41fd f1			.pastdmark: pop af  
41fe			endm  
# End of macro DMARK
41fe						CALLMONITOR 
41fe cd 6f ee			call debug_vector  
4201				endm  
# End of macro CALLMONITOR
4201					endif 
4201					FORTH_DSP_VALUEHL 
4201 cd 95 1d			call macro_dsp_valuehl 
4204				endm 
# End of macro FORTH_DSP_VALUEHL
4204 cd 90 1b				call forth_push_numhl 
4207			 
4207			 
4207					NEXTW 
4207 c3 81 1f			jp macro_next 
420a				endm 
# End of macro NEXTW
420a			.STYPE: 
420a				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
420a 48				db WORD_SYS_CORE+52             
420b 59 42			dw .UPPER            
420d 06				db 5 + 1 
420e .. 00			db "STYPE",0              
4214				endm 
# End of macro CWHEAD
4214			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
4214					if DEBUG_FORTH_WORDS_KEY 
4214						DMARK "STY" 
4214 f5				push af  
4215 3a 29 42			ld a, (.dmark)  
4218 32 65 ee			ld (debug_mark),a  
421b 3a 2a 42			ld a, (.dmark+1)  
421e 32 66 ee			ld (debug_mark+1),a  
4221 3a 2b 42			ld a, (.dmark+2)  
4224 32 67 ee			ld (debug_mark+2),a  
4227 18 03			jr .pastdmark  
4229 ..			.dmark: db "STY"  
422c f1			.pastdmark: pop af  
422d			endm  
# End of macro DMARK
422d						CALLMONITOR 
422d cd 6f ee			call debug_vector  
4230				endm  
# End of macro CALLMONITOR
4230					endif 
4230					FORTH_DSP 
4230 cd 5b 1d			call macro_forth_dsp 
4233				endm 
# End of macro FORTH_DSP
4233					;v5 FORTH_DSP_VALUE 
4233			 
4233 7e					ld a, (hl) 
4234			 
4234 f5					push af 
4235			 
4235			; Dont destroy TOS		FORTH_DSP_POP 
4235			 
4235 f1					pop af 
4236			 
4236 fe 01				cp DS_TYPE_STR 
4238 28 09				jr z, .typestr 
423a			 
423a fe 02				cp DS_TYPE_INUM 
423c 28 0a				jr z, .typeinum 
423e			 
423e 21 57 42				ld hl, .tna 
4241 18 0a				jr .tpush 
4243			 
4243 21 53 42		.typestr:	ld hl, .tstr 
4246 18 05				jr .tpush 
4248 21 55 42		.typeinum:	ld hl, .tinum 
424b 18 00				jr .tpush 
424d			 
424d			.tpush: 
424d			 
424d cd fe 1b				call forth_push_str 
4250			 
4250					NEXTW 
4250 c3 81 1f			jp macro_next 
4253				endm 
# End of macro NEXTW
4253 .. 00		.tstr:	db "s",0 
4255 .. 00		.tinum:  db "i",0 
4257 .. 00		.tna:   db "?", 0 
4259			 
4259			 
4259			.UPPER: 
4259				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4259 48				db WORD_SYS_CORE+52             
425a 94 42			dw .LOWER            
425c 06				db 5 + 1 
425d .. 00			db "UPPER",0              
4263				endm 
# End of macro CWHEAD
4263			; | UPPER ( s -- s ) Upper case string s  | DONE 
4263					if DEBUG_FORTH_WORDS_KEY 
4263						DMARK "UPR" 
4263 f5				push af  
4264 3a 78 42			ld a, (.dmark)  
4267 32 65 ee			ld (debug_mark),a  
426a 3a 79 42			ld a, (.dmark+1)  
426d 32 66 ee			ld (debug_mark+1),a  
4270 3a 7a 42			ld a, (.dmark+2)  
4273 32 67 ee			ld (debug_mark+2),a  
4276 18 03			jr .pastdmark  
4278 ..			.dmark: db "UPR"  
427b f1			.pastdmark: pop af  
427c			endm  
# End of macro DMARK
427c						CALLMONITOR 
427c cd 6f ee			call debug_vector  
427f				endm  
# End of macro CALLMONITOR
427f					endif 
427f			 
427f					FORTH_DSP 
427f cd 5b 1d			call macro_forth_dsp 
4282				endm 
# End of macro FORTH_DSP
4282					 
4282			; TODO check is string type 
4282			 
4282					FORTH_DSP_VALUEHL 
4282 cd 95 1d			call macro_dsp_valuehl 
4285				endm 
# End of macro FORTH_DSP_VALUEHL
4285			; get pointer to string in hl 
4285			 
4285 7e			.toup:		ld a, (hl) 
4286 fe 00				cp 0 
4288 28 07				jr z, .toupdone 
428a			 
428a cd 6a 10				call to_upper 
428d			 
428d 77					ld (hl), a 
428e 23					inc hl 
428f 18 f4				jr .toup 
4291			 
4291					 
4291			 
4291			 
4291			; for each char convert to upper 
4291					 
4291			.toupdone: 
4291			 
4291			 
4291					NEXTW 
4291 c3 81 1f			jp macro_next 
4294				endm 
# End of macro NEXTW
4294			.LOWER: 
4294				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4294 48				db WORD_SYS_CORE+52             
4295 cf 42			dw .TCASE            
4297 06				db 5 + 1 
4298 .. 00			db "LOWER",0              
429e				endm 
# End of macro CWHEAD
429e			; | LOWER ( s -- s ) Lower case string s  | DONE 
429e					if DEBUG_FORTH_WORDS_KEY 
429e						DMARK "LWR" 
429e f5				push af  
429f 3a b3 42			ld a, (.dmark)  
42a2 32 65 ee			ld (debug_mark),a  
42a5 3a b4 42			ld a, (.dmark+1)  
42a8 32 66 ee			ld (debug_mark+1),a  
42ab 3a b5 42			ld a, (.dmark+2)  
42ae 32 67 ee			ld (debug_mark+2),a  
42b1 18 03			jr .pastdmark  
42b3 ..			.dmark: db "LWR"  
42b6 f1			.pastdmark: pop af  
42b7			endm  
# End of macro DMARK
42b7						CALLMONITOR 
42b7 cd 6f ee			call debug_vector  
42ba				endm  
# End of macro CALLMONITOR
42ba					endif 
42ba			 
42ba					FORTH_DSP 
42ba cd 5b 1d			call macro_forth_dsp 
42bd				endm 
# End of macro FORTH_DSP
42bd					 
42bd			; TODO check is string type 
42bd			 
42bd					FORTH_DSP_VALUEHL 
42bd cd 95 1d			call macro_dsp_valuehl 
42c0				endm 
# End of macro FORTH_DSP_VALUEHL
42c0			; get pointer to string in hl 
42c0			 
42c0 7e			.tolow:		ld a, (hl) 
42c1 fe 00				cp 0 
42c3 28 07				jr z, .tolowdone 
42c5			 
42c5 cd 73 10				call to_lower 
42c8			 
42c8 77					ld (hl), a 
42c9 23					inc hl 
42ca 18 f4				jr .tolow 
42cc			 
42cc					 
42cc			 
42cc			 
42cc			; for each char convert to low 
42cc					 
42cc			.tolowdone: 
42cc					NEXTW 
42cc c3 81 1f			jp macro_next 
42cf				endm 
# End of macro NEXTW
42cf			.TCASE: 
42cf				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
42cf 48				db WORD_SYS_CORE+52             
42d0 05 44			dw .SUBSTR            
42d2 06				db 5 + 1 
42d3 .. 00			db "TCASE",0              
42d9				endm 
# End of macro CWHEAD
42d9			; | TCASE ( s -- s ) Title case string s  | DONE 
42d9					if DEBUG_FORTH_WORDS_KEY 
42d9						DMARK "TCS" 
42d9 f5				push af  
42da 3a ee 42			ld a, (.dmark)  
42dd 32 65 ee			ld (debug_mark),a  
42e0 3a ef 42			ld a, (.dmark+1)  
42e3 32 66 ee			ld (debug_mark+1),a  
42e6 3a f0 42			ld a, (.dmark+2)  
42e9 32 67 ee			ld (debug_mark+2),a  
42ec 18 03			jr .pastdmark  
42ee ..			.dmark: db "TCS"  
42f1 f1			.pastdmark: pop af  
42f2			endm  
# End of macro DMARK
42f2						CALLMONITOR 
42f2 cd 6f ee			call debug_vector  
42f5				endm  
# End of macro CALLMONITOR
42f5					endif 
42f5			 
42f5					FORTH_DSP 
42f5 cd 5b 1d			call macro_forth_dsp 
42f8				endm 
# End of macro FORTH_DSP
42f8					 
42f8			; TODO check is string type 
42f8			 
42f8					FORTH_DSP_VALUEHL 
42f8 cd 95 1d			call macro_dsp_valuehl 
42fb				endm 
# End of macro FORTH_DSP_VALUEHL
42fb			; get pointer to string in hl 
42fb			 
42fb					if DEBUG_FORTH_WORDS 
42fb						DMARK "TC1" 
42fb f5				push af  
42fc 3a 10 43			ld a, (.dmark)  
42ff 32 65 ee			ld (debug_mark),a  
4302 3a 11 43			ld a, (.dmark+1)  
4305 32 66 ee			ld (debug_mark+1),a  
4308 3a 12 43			ld a, (.dmark+2)  
430b 32 67 ee			ld (debug_mark+2),a  
430e 18 03			jr .pastdmark  
4310 ..			.dmark: db "TC1"  
4313 f1			.pastdmark: pop af  
4314			endm  
# End of macro DMARK
4314						CALLMONITOR 
4314 cd 6f ee			call debug_vector  
4317				endm  
# End of macro CALLMONITOR
4317					endif 
4317			 
4317					; first time in turn to upper case first char 
4317			 
4317 7e					ld a, (hl) 
4318 c3 a2 43				jp .totsiptou 
431b			 
431b			 
431b 7e			.tot:		ld a, (hl) 
431c fe 00				cp 0 
431e ca e6 43				jp z, .totdone 
4321			 
4321					if DEBUG_FORTH_WORDS 
4321						DMARK "TC2" 
4321 f5				push af  
4322 3a 36 43			ld a, (.dmark)  
4325 32 65 ee			ld (debug_mark),a  
4328 3a 37 43			ld a, (.dmark+1)  
432b 32 66 ee			ld (debug_mark+1),a  
432e 3a 38 43			ld a, (.dmark+2)  
4331 32 67 ee			ld (debug_mark+2),a  
4334 18 03			jr .pastdmark  
4336 ..			.dmark: db "TC2"  
4339 f1			.pastdmark: pop af  
433a			endm  
# End of macro DMARK
433a						CALLMONITOR 
433a cd 6f ee			call debug_vector  
433d				endm  
# End of macro CALLMONITOR
433d					endif 
433d					; check to see if current char is a space 
433d			 
433d fe 20				cp ' ' 
433f 28 21				jr z, .totsp 
4341 cd 73 10				call to_lower 
4344					if DEBUG_FORTH_WORDS 
4344						DMARK "TC3" 
4344 f5				push af  
4345 3a 59 43			ld a, (.dmark)  
4348 32 65 ee			ld (debug_mark),a  
434b 3a 5a 43			ld a, (.dmark+1)  
434e 32 66 ee			ld (debug_mark+1),a  
4351 3a 5b 43			ld a, (.dmark+2)  
4354 32 67 ee			ld (debug_mark+2),a  
4357 18 03			jr .pastdmark  
4359 ..			.dmark: db "TC3"  
435c f1			.pastdmark: pop af  
435d			endm  
# End of macro DMARK
435d						CALLMONITOR 
435d cd 6f ee			call debug_vector  
4360				endm  
# End of macro CALLMONITOR
4360					endif 
4360 18 63				jr .totnxt 
4362			 
4362			.totsp:         ; on a space, find next char which should be upper 
4362			 
4362					if DEBUG_FORTH_WORDS 
4362						DMARK "TC4" 
4362 f5				push af  
4363 3a 77 43			ld a, (.dmark)  
4366 32 65 ee			ld (debug_mark),a  
4369 3a 78 43			ld a, (.dmark+1)  
436c 32 66 ee			ld (debug_mark+1),a  
436f 3a 79 43			ld a, (.dmark+2)  
4372 32 67 ee			ld (debug_mark+2),a  
4375 18 03			jr .pastdmark  
4377 ..			.dmark: db "TC4"  
437a f1			.pastdmark: pop af  
437b			endm  
# End of macro DMARK
437b						CALLMONITOR 
437b cd 6f ee			call debug_vector  
437e				endm  
# End of macro CALLMONITOR
437e					endif 
437e					;; 
437e			 
437e fe 20				cp ' ' 
4380 20 20				jr nz, .totsiptou 
4382 23					inc hl 
4383 7e					ld a, (hl) 
4384					if DEBUG_FORTH_WORDS 
4384						DMARK "TC5" 
4384 f5				push af  
4385 3a 99 43			ld a, (.dmark)  
4388 32 65 ee			ld (debug_mark),a  
438b 3a 9a 43			ld a, (.dmark+1)  
438e 32 66 ee			ld (debug_mark+1),a  
4391 3a 9b 43			ld a, (.dmark+2)  
4394 32 67 ee			ld (debug_mark+2),a  
4397 18 03			jr .pastdmark  
4399 ..			.dmark: db "TC5"  
439c f1			.pastdmark: pop af  
439d			endm  
# End of macro DMARK
439d						CALLMONITOR 
439d cd 6f ee			call debug_vector  
43a0				endm  
# End of macro CALLMONITOR
43a0					endif 
43a0 18 c0				jr .totsp 
43a2 fe 00		.totsiptou:    cp 0 
43a4 28 40				jr z, .totdone 
43a6					; not space and not zero term so upper case it 
43a6 cd 6a 10				call to_upper 
43a9			 
43a9					if DEBUG_FORTH_WORDS 
43a9						DMARK "TC6" 
43a9 f5				push af  
43aa 3a be 43			ld a, (.dmark)  
43ad 32 65 ee			ld (debug_mark),a  
43b0 3a bf 43			ld a, (.dmark+1)  
43b3 32 66 ee			ld (debug_mark+1),a  
43b6 3a c0 43			ld a, (.dmark+2)  
43b9 32 67 ee			ld (debug_mark+2),a  
43bc 18 03			jr .pastdmark  
43be ..			.dmark: db "TC6"  
43c1 f1			.pastdmark: pop af  
43c2			endm  
# End of macro DMARK
43c2						CALLMONITOR 
43c2 cd 6f ee			call debug_vector  
43c5				endm  
# End of macro CALLMONITOR
43c5					endif 
43c5			 
43c5			 
43c5			.totnxt: 
43c5			 
43c5 77					ld (hl), a 
43c6 23					inc hl 
43c7					if DEBUG_FORTH_WORDS 
43c7						DMARK "TC7" 
43c7 f5				push af  
43c8 3a dc 43			ld a, (.dmark)  
43cb 32 65 ee			ld (debug_mark),a  
43ce 3a dd 43			ld a, (.dmark+1)  
43d1 32 66 ee			ld (debug_mark+1),a  
43d4 3a de 43			ld a, (.dmark+2)  
43d7 32 67 ee			ld (debug_mark+2),a  
43da 18 03			jr .pastdmark  
43dc ..			.dmark: db "TC7"  
43df f1			.pastdmark: pop af  
43e0			endm  
# End of macro DMARK
43e0						CALLMONITOR 
43e0 cd 6f ee			call debug_vector  
43e3				endm  
# End of macro CALLMONITOR
43e3					endif 
43e3 c3 1b 43				jp .tot 
43e6			 
43e6					 
43e6			 
43e6			 
43e6			; for each char convert to low 
43e6					 
43e6			.totdone: 
43e6					if DEBUG_FORTH_WORDS 
43e6						DMARK "TCd" 
43e6 f5				push af  
43e7 3a fb 43			ld a, (.dmark)  
43ea 32 65 ee			ld (debug_mark),a  
43ed 3a fc 43			ld a, (.dmark+1)  
43f0 32 66 ee			ld (debug_mark+1),a  
43f3 3a fd 43			ld a, (.dmark+2)  
43f6 32 67 ee			ld (debug_mark+2),a  
43f9 18 03			jr .pastdmark  
43fb ..			.dmark: db "TCd"  
43fe f1			.pastdmark: pop af  
43ff			endm  
# End of macro DMARK
43ff						CALLMONITOR 
43ff cd 6f ee			call debug_vector  
4402				endm  
# End of macro CALLMONITOR
4402					endif 
4402					NEXTW 
4402 c3 81 1f			jp macro_next 
4405				endm 
# End of macro NEXTW
4405			 
4405			.SUBSTR: 
4405				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4405 48				db WORD_SYS_CORE+52             
4406 63 44			dw .LEFT            
4408 07				db 6 + 1 
4409 .. 00			db "SUBSTR",0              
4410				endm 
# End of macro CWHEAD
4410			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4410			 
4410					if DEBUG_FORTH_WORDS_KEY 
4410						DMARK "SST" 
4410 f5				push af  
4411 3a 25 44			ld a, (.dmark)  
4414 32 65 ee			ld (debug_mark),a  
4417 3a 26 44			ld a, (.dmark+1)  
441a 32 66 ee			ld (debug_mark+1),a  
441d 3a 27 44			ld a, (.dmark+2)  
4420 32 67 ee			ld (debug_mark+2),a  
4423 18 03			jr .pastdmark  
4425 ..			.dmark: db "SST"  
4428 f1			.pastdmark: pop af  
4429			endm  
# End of macro DMARK
4429						CALLMONITOR 
4429 cd 6f ee			call debug_vector  
442c				endm  
# End of macro CALLMONITOR
442c					endif 
442c			; TODO check string type 
442c					FORTH_DSP_VALUEHL 
442c cd 95 1d			call macro_dsp_valuehl 
442f				endm 
# End of macro FORTH_DSP_VALUEHL
442f			 
442f e5					push hl      ; string length 
4430			 
4430					FORTH_DSP_POP 
4430 cd 4d 1e			call macro_forth_dsp_pop 
4433				endm 
# End of macro FORTH_DSP_POP
4433			 
4433					FORTH_DSP_VALUEHL 
4433 cd 95 1d			call macro_dsp_valuehl 
4436				endm 
# End of macro FORTH_DSP_VALUEHL
4436			 
4436 e5					push hl     ; start char 
4437			 
4437					FORTH_DSP_POP 
4437 cd 4d 1e			call macro_forth_dsp_pop 
443a				endm 
# End of macro FORTH_DSP_POP
443a			 
443a			 
443a					FORTH_DSP_VALUE 
443a cd 7e 1d			call macro_forth_dsp_value 
443d				endm 
# End of macro FORTH_DSP_VALUE
443d			 
443d d1					pop de    ; get start post offset 
443e			 
443e 19					add hl, de    ; starting offset 
443f			 
443f c1					pop bc 
4440 c5					push bc      ; grab size of string 
4441			 
4441 e5					push hl    ; save string start  
4442			 
4442 26 00				ld h, 0 
4444 69					ld l, c 
4445 23					inc hl 
4446 23					inc hl 
4447			 
4447 cd d0 11				call malloc 
444a				if DEBUG_FORTH_MALLOC_GUARD 
444a cc 7d 4d				call z,malloc_error 
444d				endif 
444d			 
444d eb					ex de, hl      ; save malloc area for string copy 
444e e1					pop hl    ; get back source 
444f c1					pop bc    ; get length of string back 
4450			 
4450 d5					push de    ; save malloc area for after we push 
4451 ed b0				ldir     ; copy substr 
4453			 
4453			 
4453 eb					ex de, hl 
4454 3e 00				ld a, 0 
4456 77					ld (hl), a   ; term substr 
4457			 
4457					 
4457 e1					pop hl    ; get malloc so we can push it 
4458 e5					push hl   ; save so we can free it afterwards 
4459			 
4459 cd fe 1b				call forth_push_str 
445c			 
445c e1					pop hl 
445d cd 9a 12				call free 
4460			 
4460					 
4460					 
4460			 
4460			 
4460					NEXTW 
4460 c3 81 1f			jp macro_next 
4463				endm 
# End of macro NEXTW
4463			 
4463			.LEFT: 
4463				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4463 48				db WORD_SYS_CORE+52             
4464 8b 44			dw .RIGHT            
4466 05				db 4 + 1 
4467 .. 00			db "LEFT",0              
446c				endm 
# End of macro CWHEAD
446c			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
446c					if DEBUG_FORTH_WORDS_KEY 
446c						DMARK "LEF" 
446c f5				push af  
446d 3a 81 44			ld a, (.dmark)  
4470 32 65 ee			ld (debug_mark),a  
4473 3a 82 44			ld a, (.dmark+1)  
4476 32 66 ee			ld (debug_mark+1),a  
4479 3a 83 44			ld a, (.dmark+2)  
447c 32 67 ee			ld (debug_mark+2),a  
447f 18 03			jr .pastdmark  
4481 ..			.dmark: db "LEF"  
4484 f1			.pastdmark: pop af  
4485			endm  
# End of macro DMARK
4485						CALLMONITOR 
4485 cd 6f ee			call debug_vector  
4488				endm  
# End of macro CALLMONITOR
4488					endif 
4488			 
4488					NEXTW 
4488 c3 81 1f			jp macro_next 
448b				endm 
# End of macro NEXTW
448b			.RIGHT: 
448b				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
448b 48				db WORD_SYS_CORE+52             
448c b4 44			dw .STR2NUM            
448e 06				db 5 + 1 
448f .. 00			db "RIGHT",0              
4495				endm 
# End of macro CWHEAD
4495			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4495					if DEBUG_FORTH_WORDS_KEY 
4495						DMARK "RIG" 
4495 f5				push af  
4496 3a aa 44			ld a, (.dmark)  
4499 32 65 ee			ld (debug_mark),a  
449c 3a ab 44			ld a, (.dmark+1)  
449f 32 66 ee			ld (debug_mark+1),a  
44a2 3a ac 44			ld a, (.dmark+2)  
44a5 32 67 ee			ld (debug_mark+2),a  
44a8 18 03			jr .pastdmark  
44aa ..			.dmark: db "RIG"  
44ad f1			.pastdmark: pop af  
44ae			endm  
# End of macro DMARK
44ae						CALLMONITOR 
44ae cd 6f ee			call debug_vector  
44b1				endm  
# End of macro CALLMONITOR
44b1					endif 
44b1			 
44b1					NEXTW 
44b1 c3 81 1f			jp macro_next 
44b4				endm 
# End of macro NEXTW
44b4			 
44b4			 
44b4			.STR2NUM: 
44b4				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
44b4 48				db WORD_SYS_CORE+52             
44b5 40 45			dw .NUM2STR            
44b7 08				db 7 + 1 
44b8 .. 00			db "STR2NUM",0              
44c0				endm 
# End of macro CWHEAD
44c0			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
44c0			 
44c0			 
44c0			; TODO STR type check to do 
44c0					if DEBUG_FORTH_WORDS_KEY 
44c0						DMARK "S2N" 
44c0 f5				push af  
44c1 3a d5 44			ld a, (.dmark)  
44c4 32 65 ee			ld (debug_mark),a  
44c7 3a d6 44			ld a, (.dmark+1)  
44ca 32 66 ee			ld (debug_mark+1),a  
44cd 3a d7 44			ld a, (.dmark+2)  
44d0 32 67 ee			ld (debug_mark+2),a  
44d3 18 03			jr .pastdmark  
44d5 ..			.dmark: db "S2N"  
44d8 f1			.pastdmark: pop af  
44d9			endm  
# End of macro DMARK
44d9						CALLMONITOR 
44d9 cd 6f ee			call debug_vector  
44dc				endm  
# End of macro CALLMONITOR
44dc					endif 
44dc			 
44dc					;FORTH_DSP 
44dc					FORTH_DSP_VALUE 
44dc cd 7e 1d			call macro_forth_dsp_value 
44df				endm 
# End of macro FORTH_DSP_VALUE
44df					;inc hl 
44df			 
44df eb					ex de, hl 
44e0					if DEBUG_FORTH_WORDS 
44e0						DMARK "S2a" 
44e0 f5				push af  
44e1 3a f5 44			ld a, (.dmark)  
44e4 32 65 ee			ld (debug_mark),a  
44e7 3a f6 44			ld a, (.dmark+1)  
44ea 32 66 ee			ld (debug_mark+1),a  
44ed 3a f7 44			ld a, (.dmark+2)  
44f0 32 67 ee			ld (debug_mark+2),a  
44f3 18 03			jr .pastdmark  
44f5 ..			.dmark: db "S2a"  
44f8 f1			.pastdmark: pop af  
44f9			endm  
# End of macro DMARK
44f9						CALLMONITOR 
44f9 cd 6f ee			call debug_vector  
44fc				endm  
# End of macro CALLMONITOR
44fc					endif 
44fc cd f2 10				call string_to_uint16 
44ff			 
44ff					if DEBUG_FORTH_WORDS 
44ff						DMARK "S2b" 
44ff f5				push af  
4500 3a 14 45			ld a, (.dmark)  
4503 32 65 ee			ld (debug_mark),a  
4506 3a 15 45			ld a, (.dmark+1)  
4509 32 66 ee			ld (debug_mark+1),a  
450c 3a 16 45			ld a, (.dmark+2)  
450f 32 67 ee			ld (debug_mark+2),a  
4512 18 03			jr .pastdmark  
4514 ..			.dmark: db "S2b"  
4517 f1			.pastdmark: pop af  
4518			endm  
# End of macro DMARK
4518						CALLMONITOR 
4518 cd 6f ee			call debug_vector  
451b				endm  
# End of macro CALLMONITOR
451b					endif 
451b			;		push hl 
451b					FORTH_DSP_POP 
451b cd 4d 1e			call macro_forth_dsp_pop 
451e				endm 
# End of macro FORTH_DSP_POP
451e			;		pop hl 
451e					 
451e					if DEBUG_FORTH_WORDS 
451e						DMARK "S2b" 
451e f5				push af  
451f 3a 33 45			ld a, (.dmark)  
4522 32 65 ee			ld (debug_mark),a  
4525 3a 34 45			ld a, (.dmark+1)  
4528 32 66 ee			ld (debug_mark+1),a  
452b 3a 35 45			ld a, (.dmark+2)  
452e 32 67 ee			ld (debug_mark+2),a  
4531 18 03			jr .pastdmark  
4533 ..			.dmark: db "S2b"  
4536 f1			.pastdmark: pop af  
4537			endm  
# End of macro DMARK
4537						CALLMONITOR 
4537 cd 6f ee			call debug_vector  
453a				endm  
# End of macro CALLMONITOR
453a					endif 
453a cd 90 1b				call forth_push_numhl	 
453d			 
453d				 
453d				       NEXTW 
453d c3 81 1f			jp macro_next 
4540				endm 
# End of macro NEXTW
4540			.NUM2STR: 
4540				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4540 48				db WORD_SYS_CORE+52             
4541 4f 45			dw .CONCAT            
4543 08				db 7 + 1 
4544 .. 00			db "NUM2STR",0              
454c				endm 
# End of macro CWHEAD
454c			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
454c			 
454c			;		; malloc a string to target 
454c			;		ld hl, 10     ; TODO max string size should be fine 
454c			;		call malloc 
454c			;		push hl    ; save malloc location 
454c			; 
454c			; 
454c			;; TODO check int type 
454c			;		FORTH_DSP_VALUEHL 
454c			;		ld a, l 
454c			;		call DispAToASCII   
454c			;;TODO need to chage above call to dump into string 
454c			; 
454c			; 
454c			 
454c				       NEXTW 
454c c3 81 1f			jp macro_next 
454f				endm 
# End of macro NEXTW
454f			 
454f			.CONCAT: 
454f				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
454f 48				db WORD_SYS_CORE+52             
4550 02 46			dw .FIND            
4552 07				db 6 + 1 
4553 .. 00			db "CONCAT",0              
455a				endm 
# End of macro CWHEAD
455a			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
455a			 
455a			; TODO check string type 
455a			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
455a			 
455a					if DEBUG_FORTH_WORDS_KEY 
455a						DMARK "CON" 
455a f5				push af  
455b 3a 6f 45			ld a, (.dmark)  
455e 32 65 ee			ld (debug_mark),a  
4561 3a 70 45			ld a, (.dmark+1)  
4564 32 66 ee			ld (debug_mark+1),a  
4567 3a 71 45			ld a, (.dmark+2)  
456a 32 67 ee			ld (debug_mark+2),a  
456d 18 03			jr .pastdmark  
456f ..			.dmark: db "CON"  
4572 f1			.pastdmark: pop af  
4573			endm  
# End of macro DMARK
4573						CALLMONITOR 
4573 cd 6f ee			call debug_vector  
4576				endm  
# End of macro CALLMONITOR
4576					endif 
4576			 
4576			 
4576					FORTH_DSP_VALUE 
4576 cd 7e 1d			call macro_forth_dsp_value 
4579				endm 
# End of macro FORTH_DSP_VALUE
4579 e5					push hl   ; s2 
457a			 
457a					FORTH_DSP_POP 
457a cd 4d 1e			call macro_forth_dsp_pop 
457d				endm 
# End of macro FORTH_DSP_POP
457d			 
457d					FORTH_DSP_VALUE 
457d cd 7e 1d			call macro_forth_dsp_value 
4580				endm 
# End of macro FORTH_DSP_VALUE
4580			 
4580 e5					push hl   ; s1 
4581			 
4581					FORTH_DSP_POP 
4581 cd 4d 1e			call macro_forth_dsp_pop 
4584				endm 
# End of macro FORTH_DSP_POP
4584					 
4584			 
4584					; copy s1 
4584			 
4584				 
4584					; save ptr 
4584 e1					pop hl  
4585 e5					push hl 
4586 3e 00				ld a, 0 
4588 cd 66 11				call strlent 
458b					;inc hl    ; zer0 
458b 06 00				ld b, 0 
458d 4d					ld c, l 
458e e1					pop hl		 
458f 11 bb e2				ld de, scratch	 
4592					if DEBUG_FORTH_WORDS 
4592						DMARK "CO1" 
4592 f5				push af  
4593 3a a7 45			ld a, (.dmark)  
4596 32 65 ee			ld (debug_mark),a  
4599 3a a8 45			ld a, (.dmark+1)  
459c 32 66 ee			ld (debug_mark+1),a  
459f 3a a9 45			ld a, (.dmark+2)  
45a2 32 67 ee			ld (debug_mark+2),a  
45a5 18 03			jr .pastdmark  
45a7 ..			.dmark: db "CO1"  
45aa f1			.pastdmark: pop af  
45ab			endm  
# End of macro DMARK
45ab						CALLMONITOR 
45ab cd 6f ee			call debug_vector  
45ae				endm  
# End of macro CALLMONITOR
45ae					endif 
45ae ed b0				ldir 
45b0			 
45b0 e1					pop hl 
45b1 e5					push hl 
45b2 d5					push de 
45b3			 
45b3			 
45b3 3e 00				ld a, 0 
45b5 cd 66 11				call strlent 
45b8 23					inc hl    ; zer0 
45b9 23					inc hl 
45ba 06 00				ld b, 0 
45bc 4d					ld c, l 
45bd d1					pop de 
45be e1					pop hl		 
45bf					if DEBUG_FORTH_WORDS 
45bf						DMARK "CO2" 
45bf f5				push af  
45c0 3a d4 45			ld a, (.dmark)  
45c3 32 65 ee			ld (debug_mark),a  
45c6 3a d5 45			ld a, (.dmark+1)  
45c9 32 66 ee			ld (debug_mark+1),a  
45cc 3a d6 45			ld a, (.dmark+2)  
45cf 32 67 ee			ld (debug_mark+2),a  
45d2 18 03			jr .pastdmark  
45d4 ..			.dmark: db "CO2"  
45d7 f1			.pastdmark: pop af  
45d8			endm  
# End of macro DMARK
45d8						CALLMONITOR 
45d8 cd 6f ee			call debug_vector  
45db				endm  
# End of macro CALLMONITOR
45db					endif 
45db ed b0				ldir 
45dd			 
45dd			 
45dd			 
45dd 21 bb e2				ld hl, scratch 
45e0					if DEBUG_FORTH_WORDS 
45e0						DMARK "CO5" 
45e0 f5				push af  
45e1 3a f5 45			ld a, (.dmark)  
45e4 32 65 ee			ld (debug_mark),a  
45e7 3a f6 45			ld a, (.dmark+1)  
45ea 32 66 ee			ld (debug_mark+1),a  
45ed 3a f7 45			ld a, (.dmark+2)  
45f0 32 67 ee			ld (debug_mark+2),a  
45f3 18 03			jr .pastdmark  
45f5 ..			.dmark: db "CO5"  
45f8 f1			.pastdmark: pop af  
45f9			endm  
# End of macro DMARK
45f9						CALLMONITOR 
45f9 cd 6f ee			call debug_vector  
45fc				endm  
# End of macro CALLMONITOR
45fc					endif 
45fc			 
45fc cd fe 1b				call forth_push_str 
45ff			 
45ff			 
45ff			 
45ff			 
45ff				       NEXTW 
45ff c3 81 1f			jp macro_next 
4602				endm 
# End of macro NEXTW
4602			 
4602			 
4602			.FIND: 
4602				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4602 4b				db WORD_SYS_CORE+55             
4603 c0 46			dw .LEN            
4605 05				db 4 + 1 
4606 .. 00			db "FIND",0              
460b				endm 
# End of macro CWHEAD
460b			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
460b			 
460b					if DEBUG_FORTH_WORDS_KEY 
460b						DMARK "FND" 
460b f5				push af  
460c 3a 20 46			ld a, (.dmark)  
460f 32 65 ee			ld (debug_mark),a  
4612 3a 21 46			ld a, (.dmark+1)  
4615 32 66 ee			ld (debug_mark+1),a  
4618 3a 22 46			ld a, (.dmark+2)  
461b 32 67 ee			ld (debug_mark+2),a  
461e 18 03			jr .pastdmark  
4620 ..			.dmark: db "FND"  
4623 f1			.pastdmark: pop af  
4624			endm  
# End of macro DMARK
4624						CALLMONITOR 
4624 cd 6f ee			call debug_vector  
4627				endm  
# End of macro CALLMONITOR
4627					endif 
4627			 
4627			; TODO check string type 
4627					FORTH_DSP_VALUE 
4627 cd 7e 1d			call macro_forth_dsp_value 
462a				endm 
# End of macro FORTH_DSP_VALUE
462a			 
462a e5					push hl    
462b 7e					ld a,(hl)    ; char to find   
462c			; TODO change char to substr 
462c			 
462c f5					push af 
462d					 
462d			 
462d			 
462d					if DEBUG_FORTH_WORDS 
462d						DMARK "FN1" 
462d f5				push af  
462e 3a 42 46			ld a, (.dmark)  
4631 32 65 ee			ld (debug_mark),a  
4634 3a 43 46			ld a, (.dmark+1)  
4637 32 66 ee			ld (debug_mark+1),a  
463a 3a 44 46			ld a, (.dmark+2)  
463d 32 67 ee			ld (debug_mark+2),a  
4640 18 03			jr .pastdmark  
4642 ..			.dmark: db "FN1"  
4645 f1			.pastdmark: pop af  
4646			endm  
# End of macro DMARK
4646						CALLMONITOR 
4646 cd 6f ee			call debug_vector  
4649				endm  
# End of macro CALLMONITOR
4649					endif 
4649			 
4649					FORTH_DSP_POP 
4649 cd 4d 1e			call macro_forth_dsp_pop 
464c				endm 
# End of macro FORTH_DSP_POP
464c			 
464c					; string to search 
464c			 
464c					FORTH_DSP_VALUE 
464c cd 7e 1d			call macro_forth_dsp_value 
464f				endm 
# End of macro FORTH_DSP_VALUE
464f			 
464f d1					pop de  ; d is char to find  
4650			 
4650					if DEBUG_FORTH_WORDS 
4650						DMARK "FN2" 
4650 f5				push af  
4651 3a 65 46			ld a, (.dmark)  
4654 32 65 ee			ld (debug_mark),a  
4657 3a 66 46			ld a, (.dmark+1)  
465a 32 66 ee			ld (debug_mark+1),a  
465d 3a 67 46			ld a, (.dmark+2)  
4660 32 67 ee			ld (debug_mark+2),a  
4663 18 03			jr .pastdmark  
4665 ..			.dmark: db "FN2"  
4668 f1			.pastdmark: pop af  
4669			endm  
# End of macro DMARK
4669						CALLMONITOR 
4669 cd 6f ee			call debug_vector  
466c				endm  
# End of macro CALLMONITOR
466c					endif 
466c					 
466c 01 00 00				ld bc, 0 
466f 7e			.findchar:      ld a,(hl) 
4670 fe 00				cp 0   		 
4672 28 27				jr z, .finddone     
4674 ba					cp d 
4675 28 20				jr z, .foundchar 
4677 03					inc bc 
4678 23					inc hl 
4679					if DEBUG_FORTH_WORDS 
4679						DMARK "FN3" 
4679 f5				push af  
467a 3a 8e 46			ld a, (.dmark)  
467d 32 65 ee			ld (debug_mark),a  
4680 3a 8f 46			ld a, (.dmark+1)  
4683 32 66 ee			ld (debug_mark+1),a  
4686 3a 90 46			ld a, (.dmark+2)  
4689 32 67 ee			ld (debug_mark+2),a  
468c 18 03			jr .pastdmark  
468e ..			.dmark: db "FN3"  
4691 f1			.pastdmark: pop af  
4692			endm  
# End of macro DMARK
4692						CALLMONITOR 
4692 cd 6f ee			call debug_vector  
4695				endm  
# End of macro CALLMONITOR
4695					endif 
4695 18 d8				jr .findchar 
4697			 
4697			 
4697 c5			.foundchar:	push bc 
4698 e1					pop hl 
4699 18 03				jr .findexit 
469b			 
469b			 
469b							 
469b			 
469b			.finddone:     ; got to end of string with no find 
469b 21 00 00				ld hl, 0 
469e			.findexit: 
469e			 
469e					if DEBUG_FORTH_WORDS 
469e						DMARK "FNd" 
469e f5				push af  
469f 3a b3 46			ld a, (.dmark)  
46a2 32 65 ee			ld (debug_mark),a  
46a5 3a b4 46			ld a, (.dmark+1)  
46a8 32 66 ee			ld (debug_mark+1),a  
46ab 3a b5 46			ld a, (.dmark+2)  
46ae 32 67 ee			ld (debug_mark+2),a  
46b1 18 03			jr .pastdmark  
46b3 ..			.dmark: db "FNd"  
46b6 f1			.pastdmark: pop af  
46b7			endm  
# End of macro DMARK
46b7						CALLMONITOR 
46b7 cd 6f ee			call debug_vector  
46ba				endm  
# End of macro CALLMONITOR
46ba					endif 
46ba cd 90 1b			call forth_push_numhl 
46bd			 
46bd				       NEXTW 
46bd c3 81 1f			jp macro_next 
46c0				endm 
# End of macro NEXTW
46c0			 
46c0			.LEN: 
46c0				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
46c0 4c				db WORD_SYS_CORE+56             
46c1 2a 47			dw .ASC            
46c3 06				db 5 + 1 
46c4 .. 00			db "COUNT",0              
46ca				endm 
# End of macro CWHEAD
46ca			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
46ca			 
46ca					if DEBUG_FORTH_WORDS_KEY 
46ca						DMARK "CNT" 
46ca f5				push af  
46cb 3a df 46			ld a, (.dmark)  
46ce 32 65 ee			ld (debug_mark),a  
46d1 3a e0 46			ld a, (.dmark+1)  
46d4 32 66 ee			ld (debug_mark+1),a  
46d7 3a e1 46			ld a, (.dmark+2)  
46da 32 67 ee			ld (debug_mark+2),a  
46dd 18 03			jr .pastdmark  
46df ..			.dmark: db "CNT"  
46e2 f1			.pastdmark: pop af  
46e3			endm  
# End of macro DMARK
46e3						CALLMONITOR 
46e3 cd 6f ee			call debug_vector  
46e6				endm  
# End of macro CALLMONITOR
46e6					endif 
46e6			; TODO check string type 
46e6					FORTH_DSP_VALUE 
46e6 cd 7e 1d			call macro_forth_dsp_value 
46e9				endm 
# End of macro FORTH_DSP_VALUE
46e9			 
46e9			 
46e9					if DEBUG_FORTH_WORDS 
46e9						DMARK "CN?" 
46e9 f5				push af  
46ea 3a fe 46			ld a, (.dmark)  
46ed 32 65 ee			ld (debug_mark),a  
46f0 3a ff 46			ld a, (.dmark+1)  
46f3 32 66 ee			ld (debug_mark+1),a  
46f6 3a 00 47			ld a, (.dmark+2)  
46f9 32 67 ee			ld (debug_mark+2),a  
46fc 18 03			jr .pastdmark  
46fe ..			.dmark: db "CN?"  
4701 f1			.pastdmark: pop af  
4702			endm  
# End of macro DMARK
4702						CALLMONITOR 
4702 cd 6f ee			call debug_vector  
4705				endm  
# End of macro CALLMONITOR
4705					endif 
4705 cd 5b 11				call strlenz 
4708					if DEBUG_FORTH_WORDS 
4708						DMARK "CNl" 
4708 f5				push af  
4709 3a 1d 47			ld a, (.dmark)  
470c 32 65 ee			ld (debug_mark),a  
470f 3a 1e 47			ld a, (.dmark+1)  
4712 32 66 ee			ld (debug_mark+1),a  
4715 3a 1f 47			ld a, (.dmark+2)  
4718 32 67 ee			ld (debug_mark+2),a  
471b 18 03			jr .pastdmark  
471d ..			.dmark: db "CNl"  
4720 f1			.pastdmark: pop af  
4721			endm  
# End of macro DMARK
4721						CALLMONITOR 
4721 cd 6f ee			call debug_vector  
4724				endm  
# End of macro CALLMONITOR
4724					endif 
4724			 
4724 cd 90 1b				call forth_push_numhl 
4727			 
4727			 
4727			 
4727				       NEXTW 
4727 c3 81 1f			jp macro_next 
472a				endm 
# End of macro NEXTW
472a			.ASC: 
472a				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
472a 4d				db WORD_SYS_CORE+57             
472b 98 47			dw .CHR            
472d 04				db 3 + 1 
472e .. 00			db "ASC",0              
4732				endm 
# End of macro CWHEAD
4732			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4732					if DEBUG_FORTH_WORDS_KEY 
4732						DMARK "ASC" 
4732 f5				push af  
4733 3a 47 47			ld a, (.dmark)  
4736 32 65 ee			ld (debug_mark),a  
4739 3a 48 47			ld a, (.dmark+1)  
473c 32 66 ee			ld (debug_mark+1),a  
473f 3a 49 47			ld a, (.dmark+2)  
4742 32 67 ee			ld (debug_mark+2),a  
4745 18 03			jr .pastdmark  
4747 ..			.dmark: db "ASC"  
474a f1			.pastdmark: pop af  
474b			endm  
# End of macro DMARK
474b						CALLMONITOR 
474b cd 6f ee			call debug_vector  
474e				endm  
# End of macro CALLMONITOR
474e					endif 
474e					FORTH_DSP_VALUE 
474e cd 7e 1d			call macro_forth_dsp_value 
4751				endm 
# End of macro FORTH_DSP_VALUE
4751					;v5 FORTH_DSP_VALUE 
4751			;		inc hl      ; now at start of numeric as string 
4751			 
4751 e5					push hl 
4752			 
4752					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4752 cd 4d 1e			call macro_forth_dsp_pop 
4755				endm 
# End of macro FORTH_DSP_POP
4755			 
4755 e1					pop hl 
4756			 
4756					if DEBUG_FORTH_WORDS 
4756						DMARK "AS1" 
4756 f5				push af  
4757 3a 6b 47			ld a, (.dmark)  
475a 32 65 ee			ld (debug_mark),a  
475d 3a 6c 47			ld a, (.dmark+1)  
4760 32 66 ee			ld (debug_mark+1),a  
4763 3a 6d 47			ld a, (.dmark+2)  
4766 32 67 ee			ld (debug_mark+2),a  
4769 18 03			jr .pastdmark  
476b ..			.dmark: db "AS1"  
476e f1			.pastdmark: pop af  
476f			endm  
# End of macro DMARK
476f						CALLMONITOR 
476f cd 6f ee			call debug_vector  
4772				endm  
# End of macro CALLMONITOR
4772					endif 
4772					; push the content of a onto the stack as a value 
4772			 
4772 7e					ld a,(hl)   ; get char 
4773 26 00				ld h,0 
4775 6f					ld l,a 
4776					if DEBUG_FORTH_WORDS 
4776						DMARK "AS2" 
4776 f5				push af  
4777 3a 8b 47			ld a, (.dmark)  
477a 32 65 ee			ld (debug_mark),a  
477d 3a 8c 47			ld a, (.dmark+1)  
4780 32 66 ee			ld (debug_mark+1),a  
4783 3a 8d 47			ld a, (.dmark+2)  
4786 32 67 ee			ld (debug_mark+2),a  
4789 18 03			jr .pastdmark  
478b ..			.dmark: db "AS2"  
478e f1			.pastdmark: pop af  
478f			endm  
# End of macro DMARK
478f						CALLMONITOR 
478f cd 6f ee			call debug_vector  
4792				endm  
# End of macro CALLMONITOR
4792					endif 
4792 cd 90 1b				call forth_push_numhl 
4795			 
4795				       NEXTW 
4795 c3 81 1f			jp macro_next 
4798				endm 
# End of macro NEXTW
4798			 
4798			.CHR: 
4798				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4798 4d				db WORD_SYS_CORE+57             
4799 d4 47			dw .ENDSTR            
479b 04				db 3 + 1 
479c .. 00			db "CHR",0              
47a0				endm 
# End of macro CWHEAD
47a0			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
47a0					if DEBUG_FORTH_WORDS_KEY 
47a0						DMARK "CHR" 
47a0 f5				push af  
47a1 3a b5 47			ld a, (.dmark)  
47a4 32 65 ee			ld (debug_mark),a  
47a7 3a b6 47			ld a, (.dmark+1)  
47aa 32 66 ee			ld (debug_mark+1),a  
47ad 3a b7 47			ld a, (.dmark+2)  
47b0 32 67 ee			ld (debug_mark+2),a  
47b3 18 03			jr .pastdmark  
47b5 ..			.dmark: db "CHR"  
47b8 f1			.pastdmark: pop af  
47b9			endm  
# End of macro DMARK
47b9						CALLMONITOR 
47b9 cd 6f ee			call debug_vector  
47bc				endm  
# End of macro CALLMONITOR
47bc					endif 
47bc					FORTH_DSP_VALUEHL 
47bc cd 95 1d			call macro_dsp_valuehl 
47bf				endm 
# End of macro FORTH_DSP_VALUEHL
47bf			 
47bf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
47bf cd 4d 1e			call macro_forth_dsp_pop 
47c2				endm 
# End of macro FORTH_DSP_POP
47c2			 
47c2					; save asci byte as a zero term string and push string 
47c2			 
47c2 7d					ld a,l 
47c3 32 bb e2				ld (scratch), a 
47c6			 
47c6 3e 00				ld a, 0 
47c8 32 bc e2				ld (scratch+1), a 
47cb			 
47cb 21 bb e2				ld hl, scratch 
47ce cd fe 1b				call forth_push_str 
47d1			 
47d1			 
47d1				       NEXTW 
47d1 c3 81 1f			jp macro_next 
47d4				endm 
# End of macro NEXTW
47d4			 
47d4			 
47d4			 
47d4			 
47d4			.ENDSTR: 
47d4			; eof 
47d4			 
# End of file forth_words_str.asm
47d4			include "forth_words_key.asm" 
47d4			 
47d4			; | ## Keyboard Words 
47d4			 
47d4			.KEY: 
47d4				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
47d4 3e				db WORD_SYS_CORE+42             
47d5 04 48			dw .WAITK            
47d7 04				db 3 + 1 
47d8 .. 00			db "KEY",0              
47dc				endm 
# End of macro CWHEAD
47dc			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
47dc			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
47dc			; | | Can use something like this to process: 
47dc			; | | > repeat active . key ?dup if emit then #1 until  
47dc			 
47dc					if DEBUG_FORTH_WORDS_KEY 
47dc						DMARK "KEY" 
47dc f5				push af  
47dd 3a f1 47			ld a, (.dmark)  
47e0 32 65 ee			ld (debug_mark),a  
47e3 3a f2 47			ld a, (.dmark+1)  
47e6 32 66 ee			ld (debug_mark+1),a  
47e9 3a f3 47			ld a, (.dmark+2)  
47ec 32 67 ee			ld (debug_mark+2),a  
47ef 18 03			jr .pastdmark  
47f1 ..			.dmark: db "KEY"  
47f4 f1			.pastdmark: pop af  
47f5			endm  
# End of macro DMARK
47f5						CALLMONITOR 
47f5 cd 6f ee			call debug_vector  
47f8				endm  
# End of macro CALLMONITOR
47f8					endif 
47f8			; TODO currently waits 
47f8 cd f9 5e				call cin 
47fb					;call cin_wait 
47fb 6f					ld l, a 
47fc 26 00				ld h, 0 
47fe cd 90 1b				call forth_push_numhl 
4801					NEXTW 
4801 c3 81 1f			jp macro_next 
4804				endm 
# End of macro NEXTW
4804			.WAITK: 
4804				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4804 3f				db WORD_SYS_CORE+43             
4805 36 48			dw .ACCEPT            
4807 06				db 5 + 1 
4808 .. 00			db "WAITK",0              
480e				endm 
# End of macro CWHEAD
480e			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
480e					if DEBUG_FORTH_WORDS_KEY 
480e						DMARK "WAI" 
480e f5				push af  
480f 3a 23 48			ld a, (.dmark)  
4812 32 65 ee			ld (debug_mark),a  
4815 3a 24 48			ld a, (.dmark+1)  
4818 32 66 ee			ld (debug_mark+1),a  
481b 3a 25 48			ld a, (.dmark+2)  
481e 32 67 ee			ld (debug_mark+2),a  
4821 18 03			jr .pastdmark  
4823 ..			.dmark: db "WAI"  
4826 f1			.pastdmark: pop af  
4827			endm  
# End of macro DMARK
4827						CALLMONITOR 
4827 cd 6f ee			call debug_vector  
482a				endm  
# End of macro CALLMONITOR
482a					endif 
482a cd f1 5e				call cin_wait 
482d 6f					ld l, a 
482e 26 00				ld h, 0 
4830 cd 90 1b				call forth_push_numhl 
4833					NEXTW 
4833 c3 81 1f			jp macro_next 
4836				endm 
# End of macro NEXTW
4836			.ACCEPT: 
4836				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4836 40				db WORD_SYS_CORE+44             
4837 94 48			dw .EDIT            
4839 07				db 6 + 1 
483a .. 00			db "ACCEPT",0              
4841				endm 
# End of macro CWHEAD
4841			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4841					; TODO crashes on push 
4841					if DEBUG_FORTH_WORDS_KEY 
4841						DMARK "ACC" 
4841 f5				push af  
4842 3a 56 48			ld a, (.dmark)  
4845 32 65 ee			ld (debug_mark),a  
4848 3a 57 48			ld a, (.dmark+1)  
484b 32 66 ee			ld (debug_mark+1),a  
484e 3a 58 48			ld a, (.dmark+2)  
4851 32 67 ee			ld (debug_mark+2),a  
4854 18 03			jr .pastdmark  
4856 ..			.dmark: db "ACC"  
4859 f1			.pastdmark: pop af  
485a			endm  
# End of macro DMARK
485a						CALLMONITOR 
485a cd 6f ee			call debug_vector  
485d				endm  
# End of macro CALLMONITOR
485d					endif 
485d 21 b9 e4				ld hl, os_input 
4860 3e 00				ld a, 0 
4862 77					ld (hl),a 
4863 3a 58 ea				ld a,(f_cursor_ptr) 
4866 16 64				ld d, 100 
4868 0e 00				ld c, 0 
486a 1e 28				ld e, 40 
486c cd 22 0e				call input_str 
486f					; TODO perhaps do a type check and wrap in quotes if not a number 
486f 21 b9 e4				ld hl, os_input 
4872					if DEBUG_FORTH_WORDS 
4872						DMARK "AC1" 
4872 f5				push af  
4873 3a 87 48			ld a, (.dmark)  
4876 32 65 ee			ld (debug_mark),a  
4879 3a 88 48			ld a, (.dmark+1)  
487c 32 66 ee			ld (debug_mark+1),a  
487f 3a 89 48			ld a, (.dmark+2)  
4882 32 67 ee			ld (debug_mark+2),a  
4885 18 03			jr .pastdmark  
4887 ..			.dmark: db "AC1"  
488a f1			.pastdmark: pop af  
488b			endm  
# End of macro DMARK
488b						CALLMONITOR 
488b cd 6f ee			call debug_vector  
488e				endm  
# End of macro CALLMONITOR
488e					endif 
488e cd fe 1b				call forth_push_str 
4891					NEXTW 
4891 c3 81 1f			jp macro_next 
4894				endm 
# End of macro NEXTW
4894			 
4894			.EDIT: 
4894				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4894 40				db WORD_SYS_CORE+44             
4895 36 49			dw .DEDIT            
4897 05				db 4 + 1 
4898 .. 00			db "EDIT",0              
489d				endm 
# End of macro CWHEAD
489d			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
489d			 
489d					; TODO does not copy from stack 
489d					if DEBUG_FORTH_WORDS_KEY 
489d						DMARK "EDT" 
489d f5				push af  
489e 3a b2 48			ld a, (.dmark)  
48a1 32 65 ee			ld (debug_mark),a  
48a4 3a b3 48			ld a, (.dmark+1)  
48a7 32 66 ee			ld (debug_mark+1),a  
48aa 3a b4 48			ld a, (.dmark+2)  
48ad 32 67 ee			ld (debug_mark+2),a  
48b0 18 03			jr .pastdmark  
48b2 ..			.dmark: db "EDT"  
48b5 f1			.pastdmark: pop af  
48b6			endm  
# End of macro DMARK
48b6						CALLMONITOR 
48b6 cd 6f ee			call debug_vector  
48b9				endm  
# End of macro CALLMONITOR
48b9					endif 
48b9			 
48b9					;FORTH_DSP 
48b9					FORTH_DSP_VALUEHL 
48b9 cd 95 1d			call macro_dsp_valuehl 
48bc				endm 
# End of macro FORTH_DSP_VALUEHL
48bc			;		inc hl    ; TODO do type check 
48bc			 
48bc			;		call get_word_hl 
48bc e5					push hl 
48bd					if DEBUG_FORTH_WORDS 
48bd						DMARK "EDp" 
48bd f5				push af  
48be 3a d2 48			ld a, (.dmark)  
48c1 32 65 ee			ld (debug_mark),a  
48c4 3a d3 48			ld a, (.dmark+1)  
48c7 32 66 ee			ld (debug_mark+1),a  
48ca 3a d4 48			ld a, (.dmark+2)  
48cd 32 67 ee			ld (debug_mark+2),a  
48d0 18 03			jr .pastdmark  
48d2 ..			.dmark: db "EDp"  
48d5 f1			.pastdmark: pop af  
48d6			endm  
# End of macro DMARK
48d6						CALLMONITOR 
48d6 cd 6f ee			call debug_vector  
48d9				endm  
# End of macro CALLMONITOR
48d9					endif 
48d9				;	ld a, 0 
48d9 cd 5b 11				call strlenz 
48dc 23					inc hl 
48dd			 
48dd 06 00				ld b, 0 
48df 4d					ld c, l 
48e0			 
48e0 e1					pop hl 
48e1 11 b9 e4				ld de, os_input 
48e4					if DEBUG_FORTH_WORDS_KEY 
48e4						DMARK "EDc" 
48e4 f5				push af  
48e5 3a f9 48			ld a, (.dmark)  
48e8 32 65 ee			ld (debug_mark),a  
48eb 3a fa 48			ld a, (.dmark+1)  
48ee 32 66 ee			ld (debug_mark+1),a  
48f1 3a fb 48			ld a, (.dmark+2)  
48f4 32 67 ee			ld (debug_mark+2),a  
48f7 18 03			jr .pastdmark  
48f9 ..			.dmark: db "EDc"  
48fc f1			.pastdmark: pop af  
48fd			endm  
# End of macro DMARK
48fd						CALLMONITOR 
48fd cd 6f ee			call debug_vector  
4900				endm  
# End of macro CALLMONITOR
4900					endif 
4900 ed b0				ldir 
4902			 
4902			 
4902 21 b9 e4				ld hl, os_input 
4905					;ld a, 0 
4905					;ld (hl),a 
4905 3a 58 ea				ld a,(f_cursor_ptr) 
4908 16 64				ld d, 100 
490a 0e 00				ld c, 0 
490c 1e 28				ld e, 40 
490e cd 22 0e				call input_str 
4911					; TODO perhaps do a type check and wrap in quotes if not a number 
4911 21 b9 e4				ld hl, os_input 
4914					if DEBUG_FORTH_WORDS 
4914						DMARK "ED1" 
4914 f5				push af  
4915 3a 29 49			ld a, (.dmark)  
4918 32 65 ee			ld (debug_mark),a  
491b 3a 2a 49			ld a, (.dmark+1)  
491e 32 66 ee			ld (debug_mark+1),a  
4921 3a 2b 49			ld a, (.dmark+2)  
4924 32 67 ee			ld (debug_mark+2),a  
4927 18 03			jr .pastdmark  
4929 ..			.dmark: db "ED1"  
492c f1			.pastdmark: pop af  
492d			endm  
# End of macro DMARK
492d						CALLMONITOR 
492d cd 6f ee			call debug_vector  
4930				endm  
# End of macro CALLMONITOR
4930					endif 
4930 cd fe 1b				call forth_push_str 
4933					NEXTW 
4933 c3 81 1f			jp macro_next 
4936				endm 
# End of macro NEXTW
4936			 
4936			.DEDIT: 
4936				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4936 40				db WORD_SYS_CORE+44             
4937 98 49			dw .ENDKEY            
4939 06				db 5 + 1 
493a .. 00			db "DEDIT",0              
4940				endm 
# End of macro CWHEAD
4940			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4940			 
4940					; TODO does not copy from stack 
4940					if DEBUG_FORTH_WORDS_KEY 
4940						DMARK "DED" 
4940 f5				push af  
4941 3a 55 49			ld a, (.dmark)  
4944 32 65 ee			ld (debug_mark),a  
4947 3a 56 49			ld a, (.dmark+1)  
494a 32 66 ee			ld (debug_mark+1),a  
494d 3a 57 49			ld a, (.dmark+2)  
4950 32 67 ee			ld (debug_mark+2),a  
4953 18 03			jr .pastdmark  
4955 ..			.dmark: db "DED"  
4958 f1			.pastdmark: pop af  
4959			endm  
# End of macro DMARK
4959						CALLMONITOR 
4959 cd 6f ee			call debug_vector  
495c				endm  
# End of macro CALLMONITOR
495c					endif 
495c			 
495c					;FORTH_DSP 
495c					FORTH_DSP_VALUEHL 
495c cd 95 1d			call macro_dsp_valuehl 
495f				endm 
# End of macro FORTH_DSP_VALUEHL
495f			;		inc hl    ; TODO do type check 
495f			 
495f			;		call get_word_hl 
495f e5					push hl 
4960 e5					push hl 
4961					FORTH_DSP_POP 
4961 cd 4d 1e			call macro_forth_dsp_pop 
4964				endm 
# End of macro FORTH_DSP_POP
4964 e1					pop hl 
4965					if DEBUG_FORTH_WORDS 
4965						DMARK "EDp" 
4965 f5				push af  
4966 3a 7a 49			ld a, (.dmark)  
4969 32 65 ee			ld (debug_mark),a  
496c 3a 7b 49			ld a, (.dmark+1)  
496f 32 66 ee			ld (debug_mark+1),a  
4972 3a 7c 49			ld a, (.dmark+2)  
4975 32 67 ee			ld (debug_mark+2),a  
4978 18 03			jr .pastdmark  
497a ..			.dmark: db "EDp"  
497d f1			.pastdmark: pop af  
497e			endm  
# End of macro DMARK
497e						CALLMONITOR 
497e cd 6f ee			call debug_vector  
4981				endm  
# End of macro CALLMONITOR
4981					endif 
4981				;	ld a, 0 
4981 cd 5b 11				call strlenz 
4984 23					inc hl 
4985			 
4985 06 00				ld b, 0 
4987 4d					ld c, l 
4988			 
4988 e1					pop hl 
4989			 
4989					;ld a, 0 
4989					;ld (hl),a 
4989 3a 58 ea				ld a,(f_cursor_ptr) 
498c 16 64				ld d, 100 
498e 0e 00				ld c, 0 
4990 1e 28				ld e, 40 
4992 cd 22 0e				call input_str 
4995					; TODO perhaps do a type check and wrap in quotes if not a number 
4995					NEXTW 
4995 c3 81 1f			jp macro_next 
4998				endm 
# End of macro NEXTW
4998			 
4998			 
4998			.ENDKEY: 
4998			; eof 
4998			 
# End of file forth_words_key.asm
4998			include "forth_words_const.asm" 
4998			 
4998			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4998			 
4998			 
4998			.SPITIME: 
4998				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4998 77				db WORD_SYS_CORE+99             
4999 ad 49			dw .VA            
499b 08				db 7 + 1 
499c .. 00			db "SPITIME",0              
49a4				endm 
# End of macro CWHEAD
49a4			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
49a4			; 
49a4			; | | If using BANK devices then leave as is. 
49a4			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
49a4			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
49a4			 
49a4 21 5e ea				ld hl, spi_clktime  
49a7 cd 90 1b				call forth_push_numhl 
49aa			 
49aa					NEXTW 
49aa c3 81 1f			jp macro_next 
49ad				endm 
# End of macro NEXTW
49ad			 
49ad			 
49ad			.VA: 
49ad				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
49ad 77				db WORD_SYS_CORE+99             
49ae bd 49			dw .SYMBOL            
49b0 03				db 2 + 1 
49b1 .. 00			db "VA",0              
49b4				endm 
# End of macro CWHEAD
49b4			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
49b4 21 22 ea				ld hl, cli_var_array 
49b7 cd 90 1b				call forth_push_numhl 
49ba			 
49ba					NEXTW 
49ba c3 81 1f			jp macro_next 
49bd				endm 
# End of macro NEXTW
49bd			 
49bd			.SYMBOL: 
49bd				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
49bd 77				db WORD_SYS_CORE+99             
49be c7 4a			dw .ENDCONST            
49c0 07				db 6 + 1 
49c1 .. 00			db "SYMBOL",0              
49c8				endm 
# End of macro CWHEAD
49c8			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
49c8			; | 
49c8			; | | The value is the number reference and the final address is pushed to stack 
49c8			 
49c8			; | | ``` 
49c8			; | | dw sym_table 
49c8			; | | dw nmi_vector 
49c8			; | | dw cli_autodisplay 
49c8			; | | dw cli_data_sp 
49c8			; | | dw cli_data_stack 
49c8			; | | dw cli_loop_sp 
49c8			; | | dw cli_loop_stack 
49c8			; | | dw cli_var_array 
49c8			; | | dw cursor_col 
49c8			; | | dw cursor_ptr 
49c8			; | | ; 10 
49c8			; | | dw cursor_row 
49c8			; | | dw debug_mark 
49c8			; | | dw display_fb0 
49c8			; | | dw display_fb1 
49c8			; | | dw display_fb2 
49c8			; | | dw display_fb3 
49c8			; | | dw display_fb_active 
49c8			; | | dw execscratch 
49c8			; | | dw f_cursor_ptr 
49c8			; | | dw hardware_word 
49c8			; | | ;20 
49c8			; | | dw input_at_cursor 
49c8			; | | dw input_at_pos 
49c8			; | | dw input_cur_flash 
49c8			; | | dw input_cur_onoff 
49c8			; | | dw input_cursor 
49c8			; | | dw input_display_size 
49c8			; | | dw input_len 
49c8			; | | dw input_ptr 
49c8			; | | dw input_size 
49c8			; | | dw input_start 
49c8			; | | ; 30 
49c8			; | | dw input_str 
49c8			; | | dw input_under_cursor 
49c8			; | | dw os_cli_cmd 
49c8			; | | dw os_cur_ptr 
49c8			; | | dw os_current_i 
49c8			; | | dw os_input 
49c8			; | | dw os_last_cmd 
49c8			; | | dw os_last_new_uword 
49c8			; | | dw debug_vector 
49c8			; | | dw os_view_hl 
49c8			; | | ;40 
49c8			; | | dw os_word_scratch 
49c8			; | | dw portbctl 
49c8			; | | dw portbdata 
49c8			; | | dw spi_cartdev 
49c8			; | | dw spi_cartdev2 
49c8			; | | dw spi_clktime 
49c8			; | | dw spi_device 
49c8			; | | dw spi_device_id 
49c8			; | | dw spi_portbyte 
49c8			; | | dw stackstore 
49c8			; | | ; 50 
49c8			; | | if STORAGE_SE 
49c8			; | | dw storage_actl 
49c8			; | | dw storage_adata 
49c8			; | | else 
49c8			; | | dw 0 
49c8			; | | dw 0 
49c8			; | | endif 
49c8			; | | dw storage_append 
49c8			; | | if STORAGE_SE 
49c8			; | | dw storage_bctl 
49c8			; | | else 
49c8			; | | dw 0 
49c8			; | | endif 
49c8			; | | dw store_bank_active 
49c8			; | | dw store_filecache 
49c8			; | | dw store_longread 
49c8			; | | dw store_openaddr 
49c8			; | | dw store_openext 
49c8			; | | dw store_openmaxext 
49c8			; | | ; 60 
49c8			; | | dw store_page 
49c8			; | | dw store_readbuf 
49c8			; | | dw store_readcont 
49c8			; | | dw store_readptr 
49c8			; | | dw store_tmpext 
49c8			; | | dw store_tmpid 
49c8			; | | dw store_tmppageid 
49c8			; | | dw malloc 
49c8			; | | dw free 
49c8			; | | dw cin 
49c8			; | | ; 70 
49c8			; | | dw cin_wait 
49c8			; | | dw forth_push_numhl 
49c8			; | | dw forth_push_str 
49c8			; | | ``` 
49c8			 
49c8					if DEBUG_FORTH_WORDS_KEY 
49c8						DMARK "SYM" 
49c8 f5				push af  
49c9 3a dd 49			ld a, (.dmark)  
49cc 32 65 ee			ld (debug_mark),a  
49cf 3a de 49			ld a, (.dmark+1)  
49d2 32 66 ee			ld (debug_mark+1),a  
49d5 3a df 49			ld a, (.dmark+2)  
49d8 32 67 ee			ld (debug_mark+2),a  
49db 18 03			jr .pastdmark  
49dd ..			.dmark: db "SYM"  
49e0 f1			.pastdmark: pop af  
49e1			endm  
# End of macro DMARK
49e1						CALLMONITOR 
49e1 cd 6f ee			call debug_vector  
49e4				endm  
# End of macro CALLMONITOR
49e4					endif 
49e4			 
49e4					FORTH_DSP_VALUEHL 
49e4 cd 95 1d			call macro_dsp_valuehl 
49e7				endm 
# End of macro FORTH_DSP_VALUEHL
49e7			 
49e7 7d					ld a, l     
49e8			 
49e8			 
49e8					if DEBUG_FORTH_WORDS 
49e8						DMARK "SY1" 
49e8 f5				push af  
49e9 3a fd 49			ld a, (.dmark)  
49ec 32 65 ee			ld (debug_mark),a  
49ef 3a fe 49			ld a, (.dmark+1)  
49f2 32 66 ee			ld (debug_mark+1),a  
49f5 3a ff 49			ld a, (.dmark+2)  
49f8 32 67 ee			ld (debug_mark+2),a  
49fb 18 03			jr .pastdmark  
49fd ..			.dmark: db "SY1"  
4a00 f1			.pastdmark: pop af  
4a01			endm  
# End of macro DMARK
4a01						CALLMONITOR 
4a01 cd 6f ee			call debug_vector  
4a04				endm  
# End of macro CALLMONITOR
4a04					endif 
4a04					 
4a04 f5					push af	 
4a05					FORTH_DSP_POP 
4a05 cd 4d 1e			call macro_forth_dsp_pop 
4a08				endm 
# End of macro FORTH_DSP_POP
4a08 f1					pop af 
4a09			 
4a09 cb 27				sla a  
4a0b				 
4a0b					 
4a0b					if DEBUG_FORTH_WORDS 
4a0b						DMARK "SY" 
4a0b f5				push af  
4a0c 3a 20 4a			ld a, (.dmark)  
4a0f 32 65 ee			ld (debug_mark),a  
4a12 3a 21 4a			ld a, (.dmark+1)  
4a15 32 66 ee			ld (debug_mark+1),a  
4a18 3a 22 4a			ld a, (.dmark+2)  
4a1b 32 67 ee			ld (debug_mark+2),a  
4a1e 18 02			jr .pastdmark  
4a20 ..			.dmark: db "SY"  
4a22 f1			.pastdmark: pop af  
4a23			endm  
# End of macro DMARK
4a23						CALLMONITOR 
4a23 cd 6f ee			call debug_vector  
4a26				endm  
# End of macro CALLMONITOR
4a26					endif 
4a26			 
4a26 21 35 4a				ld hl, sym_table 
4a29 cd f5 0d				call addatohl 
4a2c cd 03 1f				call loadwordinhl 
4a2f cd 90 1b				call forth_push_numhl 
4a32			 
4a32			 
4a32				       NEXTW 
4a32 c3 81 1f			jp macro_next 
4a35				endm 
# End of macro NEXTW
4a35			 
4a35			sym_table: 
4a35			 
4a35			; 0 
4a35 35 4a		dw sym_table 
4a37 72 ee		dw nmi_vector 
4a39 36 ea		dw cli_autodisplay 
4a3b e8 e9		dw cli_data_sp 
4a3d 22 e8		dw cli_data_stack 
4a3f ea e9		dw cli_loop_sp 
4a41 24 e9		dw cli_loop_stack 
4a43 22 ea		dw cli_var_array 
4a45 bf eb		dw cursor_col 
4a47 bd eb		dw cursor_ptr 
4a49			; 10 
4a49 be eb		dw cursor_row 
4a4b 65 ee		dw debug_mark 
4a4d ab ed		dw display_fb0 
4a4f 0a ed		dw display_fb1 
4a51 c8 eb		dw display_fb2 
4a53 69 ec		dw display_fb3 
4a55 c6 eb		dw display_fb_active 
4a57 ba e3		dw execscratch 
4a59 58 ea		dw f_cursor_ptr 
4a5b 75 ee		dw hardware_word 
4a5d			;20 
4a5d 5c ee		dw input_at_cursor 
4a5f 5e ee		dw input_at_pos 
4a61 5a ee		dw input_cur_flash 
4a63 59 ee		dw input_cur_onoff 
4a65 4f ee		dw input_cursor 
4a67 5f ee		dw input_display_size 
4a69 54 ee		dw input_len 
4a6b 63 ee		dw input_ptr 
4a6d 60 ee		dw input_size 
4a6f 61 ee		dw input_start 
4a71			; 30 
4a71 22 0e		dw input_str 
4a73 5d ee		dw input_under_cursor 
4a75 e2 e5		dw os_cli_cmd 
4a77 de e5		dw os_cur_ptr 
4a79 e0 e5		dw os_current_i 
4a7b b9 e4		dw os_input 
4a7d e1 e6		dw os_last_cmd 
4a7f b8 e5		dw os_last_new_uword 
4a81 6f ee		dw debug_vector 
4a83 9d e2		dw os_view_hl 
4a85			;40 
4a85 c0 e5		dw os_word_scratch 
4a87 c3 00		dw portbctl 
4a89 c1 00		dw portbdata 
4a8b 5d ea		dw spi_cartdev 
4a8d 5c ea		dw spi_cartdev2 
4a8f 5e ea		dw spi_clktime 
4a91 5a ea		dw spi_device 
4a93 59 ea		dw spi_device_id 
4a95 5b ea		dw spi_portbyte 
4a97 a1 eb		dw stackstore 
4a99			; 50 
4a99			if STORAGE_SE 
4a99			dw storage_actl 
4a99			dw storage_adata 
4a99			else 
4a99 00 00		dw 0 
4a9b 00 00		dw 0 
4a9d			endif 
4a9d 77 09		dw storage_append 
4a9f			if STORAGE_SE 
4a9f			dw storage_bctl 
4a9f			else 
4a9f 00 00		dw 0 
4aa1			endif 
4aa1 8d eb		dw store_bank_active 
4aa3 61 ea		dw store_filecache 
4aa5 6f ea		dw store_longread 
4aa7 65 ea		dw store_openaddr 
4aa9 64 ea		dw store_openext 
4aab 63 ea		dw store_openmaxext 
4aad			; 60 
4aad 74 ea		dw store_page 
4aaf 70 ea		dw store_readbuf 
4ab1 67 ea		dw store_readcont 
4ab3 72 ea		dw store_readptr 
4ab5 67 ea		dw store_tmpext 
4ab7 68 ea		dw store_tmpid 
4ab9 5f ea		dw store_tmppageid 
4abb d0 11		dw malloc 
4abd 9a 12		dw free 
4abf f9 5e		dw cin 
4ac1			; 70 
4ac1 f1 5e		dw cin_wait 
4ac3 90 1b		dw forth_push_numhl 
4ac5 fe 1b		dw forth_push_str 
4ac7			 
4ac7			 
4ac7			.ENDCONST: 
4ac7			 
4ac7			; eof 
4ac7			 
4ac7			 
# End of file forth_words_const.asm
4ac7			 
4ac7			if STORAGE_SE 
4ac7			   	include "forth_words_storage.asm" 
4ac7			endif 
4ac7				include "forth_words_device.asm" 
4ac7			; Device related words 
4ac7			 
4ac7			; | ## Device Words 
4ac7			 
4ac7			;if SOUND_ENABLE 
4ac7			;.NOTE: 
4ac7			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4ac7			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
4ac7			;		if DEBUG_FORTH_WORDS_KEY 
4ac7			;			DMARK "NTE" 
4ac7			;			CALLMONITOR 
4ac7			;		endif 
4ac7			; 
4ac7			;	 
4ac7			; 
4ac7			;		NEXTW 
4ac7			;.AFTERSOUND: 
4ac7			;endif 
4ac7			 
4ac7			 
4ac7			USE_GPIO: equ 0 
4ac7			 
4ac7			if USE_GPIO 
4ac7			.GP1: 
4ac7				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4ac7			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
4ac7					NEXTW 
4ac7			.GP2: 
4ac7				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4ac7			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
4ac7			 
4ac7					NEXTW 
4ac7			 
4ac7			.GP3: 
4ac7				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4ac7			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
4ac7			 
4ac7					NEXTW 
4ac7			 
4ac7			.GP4: 
4ac7				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4ac7			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
4ac7			 
4ac7					NEXTW 
4ac7			.SIN: 
4ac7			 
4ac7			 
4ac7			endif 
4ac7			 
4ac7			 
4ac7				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4ac7 33				db WORD_SYS_CORE+31             
4ac8 fc 4a			dw .SOUT            
4aca 03				db 2 + 1 
4acb .. 00			db "IN",0              
4ace				endm 
# End of macro CWHEAD
4ace			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4ace					if DEBUG_FORTH_WORDS_KEY 
4ace						DMARK "IN." 
4ace f5				push af  
4acf 3a e3 4a			ld a, (.dmark)  
4ad2 32 65 ee			ld (debug_mark),a  
4ad5 3a e4 4a			ld a, (.dmark+1)  
4ad8 32 66 ee			ld (debug_mark+1),a  
4adb 3a e5 4a			ld a, (.dmark+2)  
4ade 32 67 ee			ld (debug_mark+2),a  
4ae1 18 03			jr .pastdmark  
4ae3 ..			.dmark: db "IN."  
4ae6 f1			.pastdmark: pop af  
4ae7			endm  
# End of macro DMARK
4ae7						CALLMONITOR 
4ae7 cd 6f ee			call debug_vector  
4aea				endm  
# End of macro CALLMONITOR
4aea					endif 
4aea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aea cd 95 1d			call macro_dsp_valuehl 
4aed				endm 
# End of macro FORTH_DSP_VALUEHL
4aed			 
4aed e5					push hl 
4aee			 
4aee					; destroy value TOS 
4aee			 
4aee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aee cd 4d 1e			call macro_forth_dsp_pop 
4af1				endm 
# End of macro FORTH_DSP_POP
4af1			 
4af1					; one value on hl get other one back 
4af1			 
4af1 c1					pop bc 
4af2			 
4af2					; do the sub 
4af2			;		ex de, hl 
4af2			 
4af2 ed 68				in l,(c) 
4af4			 
4af4					; save it 
4af4			 
4af4 26 00				ld h,0 
4af6			 
4af6					; TODO push value back onto stack for another op etc 
4af6			 
4af6 cd 90 1b				call forth_push_numhl 
4af9					NEXTW 
4af9 c3 81 1f			jp macro_next 
4afc				endm 
# End of macro NEXTW
4afc			.SOUT: 
4afc				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4afc 34				db WORD_SYS_CORE+32             
4afd 4f 4b			dw .SPIO            
4aff 04				db 3 + 1 
4b00 .. 00			db "OUT",0              
4b04				endm 
# End of macro CWHEAD
4b04			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4b04					if DEBUG_FORTH_WORDS_KEY 
4b04						DMARK "OUT" 
4b04 f5				push af  
4b05 3a 19 4b			ld a, (.dmark)  
4b08 32 65 ee			ld (debug_mark),a  
4b0b 3a 1a 4b			ld a, (.dmark+1)  
4b0e 32 66 ee			ld (debug_mark+1),a  
4b11 3a 1b 4b			ld a, (.dmark+2)  
4b14 32 67 ee			ld (debug_mark+2),a  
4b17 18 03			jr .pastdmark  
4b19 ..			.dmark: db "OUT"  
4b1c f1			.pastdmark: pop af  
4b1d			endm  
# End of macro DMARK
4b1d						CALLMONITOR 
4b1d cd 6f ee			call debug_vector  
4b20				endm  
# End of macro CALLMONITOR
4b20					endif 
4b20			 
4b20					; get port 
4b20			 
4b20					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b20 cd 95 1d			call macro_dsp_valuehl 
4b23				endm 
# End of macro FORTH_DSP_VALUEHL
4b23			 
4b23 e5					push hl 
4b24			 
4b24					; destroy value TOS 
4b24			 
4b24					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b24 cd 4d 1e			call macro_forth_dsp_pop 
4b27				endm 
# End of macro FORTH_DSP_POP
4b27			 
4b27					; get byte to send 
4b27			 
4b27					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b27 cd 95 1d			call macro_dsp_valuehl 
4b2a				endm 
# End of macro FORTH_DSP_VALUEHL
4b2a			 
4b2a			;		push hl 
4b2a			 
4b2a					; destroy value TOS 
4b2a			 
4b2a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b2a cd 4d 1e			call macro_forth_dsp_pop 
4b2d				endm 
# End of macro FORTH_DSP_POP
4b2d			 
4b2d					; one value on hl get other one back 
4b2d			 
4b2d			;		pop hl 
4b2d			 
4b2d c1					pop bc 
4b2e			 
4b2e					if DEBUG_FORTH_WORDS 
4b2e						DMARK "OUT" 
4b2e f5				push af  
4b2f 3a 43 4b			ld a, (.dmark)  
4b32 32 65 ee			ld (debug_mark),a  
4b35 3a 44 4b			ld a, (.dmark+1)  
4b38 32 66 ee			ld (debug_mark+1),a  
4b3b 3a 45 4b			ld a, (.dmark+2)  
4b3e 32 67 ee			ld (debug_mark+2),a  
4b41 18 03			jr .pastdmark  
4b43 ..			.dmark: db "OUT"  
4b46 f1			.pastdmark: pop af  
4b47			endm  
# End of macro DMARK
4b47						CALLMONITOR 
4b47 cd 6f ee			call debug_vector  
4b4a				endm  
# End of macro CALLMONITOR
4b4a					endif 
4b4a			 
4b4a ed 69				out (c), l 
4b4c			 
4b4c					NEXTW 
4b4c c3 81 1f			jp macro_next 
4b4f				endm 
# End of macro NEXTW
4b4f			 
4b4f			 
4b4f			.SPIO: 
4b4f			 
4b4f			if STORAGE_SE 
4b4f				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4b4f			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4b4f			 
4b4f					call spi_ce_low 
4b4f			    NEXTW 
4b4f			 
4b4f			.SPICEH: 
4b4f				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4b4f			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4b4f			 
4b4f					call spi_ce_high 
4b4f			    NEXTW 
4b4f			 
4b4f			 
4b4f			.SPIOb: 
4b4f			 
4b4f				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4b4f			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4b4f			 
4b4f					if DEBUG_FORTH_WORDS_KEY 
4b4f						DMARK "SPo" 
4b4f						CALLMONITOR 
4b4f					endif 
4b4f					; get port 
4b4f			 
4b4f			 
4b4f					; get byte to send 
4b4f			 
4b4f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b4f			 
4b4f			;		push hl    ; u1  
4b4f			 
4b4f					; destroy value TOS 
4b4f			 
4b4f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b4f			 
4b4f					; one value on hl get other one back 
4b4f			 
4b4f			;		pop hl   ; u2 - addr 
4b4f			 
4b4f					; TODO Send SPI byte 
4b4f			 
4b4f			;		push hl 
4b4f			;		call spi_ce_low 
4b4f			;		pop hl 
4b4f					ld a, l 
4b4f					call spi_send_byte 
4b4f			;		call spi_ce_high 
4b4f			 
4b4f					NEXTW 
4b4f			 
4b4f			.SPII: 
4b4f				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4b4f			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4b4f					if DEBUG_FORTH_WORDS_KEY 
4b4f						DMARK "SPi" 
4b4f						CALLMONITOR 
4b4f					endif 
4b4f			 
4b4f					; TODO Get SPI byte 
4b4f			 
4b4f					call spi_read_byte 
4b4f			 
4b4f					if DEBUG_FORTH_WORDS 
4b4f						DMARK "Si2" 
4b4f						CALLMONITOR 
4b4f					endif 
4b4f					ld h, 0 
4b4f					ld l, a 
4b4f					if DEBUG_FORTH_WORDS 
4b4f						DMARK "Si3" 
4b4f						CALLMONITOR 
4b4f					endif 
4b4f					call forth_push_numhl 
4b4f			 
4b4f					NEXTW 
4b4f			 
4b4f			 
4b4f			 
4b4f			.SESEL: 
4b4f				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4b4f			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4b4f					if DEBUG_FORTH_WORDS_KEY 
4b4f						DMARK "BNK" 
4b4f						CALLMONITOR 
4b4f					endif 
4b4f			 
4b4f					ld a, 255 
4b4f					ld (spi_cartdev), a 
4b4f			 
4b4f					; get bank 
4b4f			 
4b4f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b4f			 
4b4f			;		push hl 
4b4f			 
4b4f					; destroy value TOS 
4b4f			 
4b4f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b4f			 
4b4f					; one value on hl get other one back 
4b4f			 
4b4f			;		pop hl 
4b4f			 
4b4f			 
4b4f					ld c, SPI_CE_HIGH 
4b4f					ld b, '0'    ; human readable bank number 
4b4f			 
4b4f					ld a, l 
4b4f			 
4b4f					if DEBUG_FORTH_WORDS 
4b4f						DMARK "BNK" 
4b4f						CALLMONITOR 
4b4f					endif 
4b4f			 
4b4f					; active low 
4b4f			 
4b4f					cp 0 
4b4f					jr z, .bset 
4b4f					cp 1 
4b4f					jr nz, .b2 
4b4f					res 0, c 
4b4f					ld b, '1'    ; human readable bank number 
4b4f			.b2:		cp 2 
4b4f					jr nz, .b3 
4b4f					res 1, c 
4b4f					ld b, '2'    ; human readable bank number 
4b4f			.b3:		cp 3 
4b4f					jr nz, .b4 
4b4f					res 2, c 
4b4f					ld b, '3'    ; human readable bank number 
4b4f			.b4:		cp 4 
4b4f					jr nz, .b5 
4b4f					res 3, c 
4b4f					ld b, '4'    ; human readable bank number 
4b4f			.b5:		cp 5 
4b4f					jr nz, .bset 
4b4f					res 4, c 
4b4f					ld b, '5'    ; human readable bank number 
4b4f			 
4b4f			.bset: 
4b4f					ld a, c 
4b4f					ld (spi_device),a 
4b4f					ld a, b 
4b4f					ld (spi_device_id),a 
4b4f					if DEBUG_FORTH_WORDS 
4b4f						DMARK "BN2" 
4b4f						CALLMONITOR 
4b4f					endif 
4b4f			 
4b4f					; set default SPI clk pulse time as disabled for BANK use 
4b4f			 
4b4f					ld a, 0 
4b4f					ld (spi_clktime), a 
4b4f			 
4b4f					NEXTW 
4b4f			 
4b4f			.CARTDEV: 
4b4f				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4b4f			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4b4f					if DEBUG_FORTH_WORDS_KEY 
4b4f						DMARK "CDV" 
4b4f						CALLMONITOR 
4b4f					endif 
4b4f			 
4b4f					; disable se storage bank selection 
4b4f			 
4b4f					ld a, SPI_CE_HIGH		; ce high 
4b4f					ld (spi_device), a 
4b4f			 
4b4f					; get bank 
4b4f			 
4b4f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b4f			 
4b4f			;		push hl 
4b4f			 
4b4f					; destroy value TOS 
4b4f			 
4b4f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b4f			 
4b4f					; one value on hl get other one back 
4b4f			 
4b4f			;		pop hl 
4b4f			 
4b4f					; active low 
4b4f			 
4b4f					ld c, 255 
4b4f			 
4b4f					ld a, l 
4b4f					if DEBUG_FORTH_WORDS 
4b4f						DMARK "CDV" 
4b4f						CALLMONITOR 
4b4f					endif 
4b4f					cp 0 
4b4f					jr z, .cset 
4b4f					cp 1 
4b4f					jr nz, .c2 
4b4f					res 0, c 
4b4f			.c2:		cp 2 
4b4f					jr nz, .c3 
4b4f					res 1, c 
4b4f			.c3:		cp 3 
4b4f					jr nz, .c4 
4b4f					res 2, c 
4b4f			.c4:		cp 4 
4b4f					jr nz, .c5 
4b4f					res 3, c 
4b4f			.c5:		cp 5 
4b4f					jr nz, .c6 
4b4f					res 4, c 
4b4f			.c6:		cp 6 
4b4f					jr nz, .c7 
4b4f					res 5, c 
4b4f			.c7:		cp 7 
4b4f					jr nz, .c8 
4b4f					res 6, c 
4b4f			.c8:		cp 8 
4b4f					jr nz, .cset 
4b4f					res 7, c 
4b4f			.cset:		ld a, c 
4b4f					ld (spi_cartdev),a 
4b4f			 
4b4f					if DEBUG_FORTH_WORDS 
4b4f						DMARK "CD2" 
4b4f						CALLMONITOR 
4b4f					endif 
4b4f			 
4b4f					; set default SPI clk pulse time as 10ms for CARTDEV use 
4b4f			 
4b4f					ld a, $0a 
4b4f					ld (spi_clktime), a 
4b4f					NEXTW 
4b4f			endif 
4b4f			 
4b4f			.ENDDEVICE: 
4b4f			; eof 
4b4f			 
# End of file forth_words_device.asm
4b4f			 
4b4f			; var handler 
4b4f			 
4b4f			 
4b4f			.VARS: 
4b4f				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4b4f 77				db WORD_SYS_CORE+99             
4b50 00 4c			dw .V0            
4b52 04				db 3 + 1 
4b53 .. 00			db "VAR",0              
4b57				endm 
# End of macro CWHEAD
4b57			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4b57			;| 
4b57			;| The variable name should consist of a single letter. e.g. "a" 
4b57			;! If a full string is passed then only the first char is looked at 
4b57			;| Any other char could exceed bounds checks!  
4b57			 
4b57					if DEBUG_FORTH_WORDS_KEY 
4b57						DMARK "VAR" 
4b57 f5				push af  
4b58 3a 6c 4b			ld a, (.dmark)  
4b5b 32 65 ee			ld (debug_mark),a  
4b5e 3a 6d 4b			ld a, (.dmark+1)  
4b61 32 66 ee			ld (debug_mark+1),a  
4b64 3a 6e 4b			ld a, (.dmark+2)  
4b67 32 67 ee			ld (debug_mark+2),a  
4b6a 18 03			jr .pastdmark  
4b6c ..			.dmark: db "VAR"  
4b6f f1			.pastdmark: pop af  
4b70			endm  
# End of macro DMARK
4b70						CALLMONITOR 
4b70 cd 6f ee			call debug_vector  
4b73				endm  
# End of macro CALLMONITOR
4b73					endif 
4b73			 
4b73					FORTH_DSP_VALUEHL 
4b73 cd 95 1d			call macro_dsp_valuehl 
4b76				endm 
# End of macro FORTH_DSP_VALUEHL
4b76			 
4b76 7e					ld a, (hl)    ; get first char on of the string 
4b77			 
4b77			 
4b77					if DEBUG_FORTH_WORDS 
4b77						DMARK "VR1" 
4b77 f5				push af  
4b78 3a 8c 4b			ld a, (.dmark)  
4b7b 32 65 ee			ld (debug_mark),a  
4b7e 3a 8d 4b			ld a, (.dmark+1)  
4b81 32 66 ee			ld (debug_mark+1),a  
4b84 3a 8e 4b			ld a, (.dmark+2)  
4b87 32 67 ee			ld (debug_mark+2),a  
4b8a 18 03			jr .pastdmark  
4b8c ..			.dmark: db "VR1"  
4b8f f1			.pastdmark: pop af  
4b90			endm  
# End of macro DMARK
4b90						CALLMONITOR 
4b90 cd 6f ee			call debug_vector  
4b93				endm  
# End of macro CALLMONITOR
4b93					endif 
4b93					 
4b93 f5					push af	 
4b94					FORTH_DSP_POP 
4b94 cd 4d 1e			call macro_forth_dsp_pop 
4b97				endm 
# End of macro FORTH_DSP_POP
4b97 f1					pop af 
4b98			 
4b98					; convert to upper 
4b98			 
4b98 cd 6a 10				call to_upper 
4b9b					if DEBUG_FORTH_WORDS 
4b9b						DMARK "Vaa" 
4b9b f5				push af  
4b9c 3a b0 4b			ld a, (.dmark)  
4b9f 32 65 ee			ld (debug_mark),a  
4ba2 3a b1 4b			ld a, (.dmark+1)  
4ba5 32 66 ee			ld (debug_mark+1),a  
4ba8 3a b2 4b			ld a, (.dmark+2)  
4bab 32 67 ee			ld (debug_mark+2),a  
4bae 18 03			jr .pastdmark  
4bb0 ..			.dmark: db "Vaa"  
4bb3 f1			.pastdmark: pop af  
4bb4			endm  
# End of macro DMARK
4bb4						CALLMONITOR 
4bb4 cd 6f ee			call debug_vector  
4bb7				endm  
# End of macro CALLMONITOR
4bb7					endif 
4bb7 06 41				ld b, 'A' 
4bb9 90					sub b			; set offset 
4bba					if DEBUG_FORTH_WORDS 
4bba						DMARK "Vbb" 
4bba f5				push af  
4bbb 3a cf 4b			ld a, (.dmark)  
4bbe 32 65 ee			ld (debug_mark),a  
4bc1 3a d0 4b			ld a, (.dmark+1)  
4bc4 32 66 ee			ld (debug_mark+1),a  
4bc7 3a d1 4b			ld a, (.dmark+2)  
4bca 32 67 ee			ld (debug_mark+2),a  
4bcd 18 03			jr .pastdmark  
4bcf ..			.dmark: db "Vbb"  
4bd2 f1			.pastdmark: pop af  
4bd3			endm  
# End of macro DMARK
4bd3						CALLMONITOR 
4bd3 cd 6f ee			call debug_vector  
4bd6				endm  
# End of macro CALLMONITOR
4bd6					endif 
4bd6 cb 27				sla a  
4bd8				 
4bd8					 
4bd8					if DEBUG_FORTH_WORDS 
4bd8						DMARK "VR2" 
4bd8 f5				push af  
4bd9 3a ed 4b			ld a, (.dmark)  
4bdc 32 65 ee			ld (debug_mark),a  
4bdf 3a ee 4b			ld a, (.dmark+1)  
4be2 32 66 ee			ld (debug_mark+1),a  
4be5 3a ef 4b			ld a, (.dmark+2)  
4be8 32 67 ee			ld (debug_mark+2),a  
4beb 18 03			jr .pastdmark  
4bed ..			.dmark: db "VR2"  
4bf0 f1			.pastdmark: pop af  
4bf1			endm  
# End of macro DMARK
4bf1						CALLMONITOR 
4bf1 cd 6f ee			call debug_vector  
4bf4				endm  
# End of macro CALLMONITOR
4bf4					endif 
4bf4			 
4bf4 21 ee e9				ld hl, cli_var_array2 
4bf7 cd f5 0d				call addatohl 
4bfa cd 90 1b				call forth_push_numhl 
4bfd			 
4bfd			 
4bfd				       NEXTW 
4bfd c3 81 1f			jp macro_next 
4c00				endm 
# End of macro NEXTW
4c00			.V0: 
4c00				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4c00 78				db WORD_SYS_CORE+100             
4c01 18 4c			dw .V0Q            
4c03 04				db 3 + 1 
4c04 .. 00			db "V0!",0              
4c08				endm 
# End of macro CWHEAD
4c08			;| V0! ( u1 -- )  Store value to v0  | DONE 
4c08			 
4c08					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c08 cd 95 1d			call macro_dsp_valuehl 
4c0b				endm 
# End of macro FORTH_DSP_VALUEHL
4c0b			 
4c0b 11 22 ea				ld de, cli_var_array 
4c0e			 
4c0e eb					ex de, hl 
4c0f 73					ld (hl), e 
4c10 23					inc hl 
4c11 72					ld (hl), d 
4c12			 
4c12					; destroy value TOS 
4c12			 
4c12					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c12 cd 4d 1e			call macro_forth_dsp_pop 
4c15				endm 
# End of macro FORTH_DSP_POP
4c15			 
4c15				       NEXTW 
4c15 c3 81 1f			jp macro_next 
4c18				endm 
# End of macro NEXTW
4c18			.V0Q: 
4c18				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4c18 79				db WORD_SYS_CORE+101             
4c19 29 4c			dw .V1S            
4c1b 04				db 3 + 1 
4c1c .. 00			db "V0@",0              
4c20				endm 
# End of macro CWHEAD
4c20			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4c20 2a 22 ea				ld hl, (cli_var_array) 
4c23 cd 90 1b				call forth_push_numhl 
4c26			 
4c26				       NEXTW 
4c26 c3 81 1f			jp macro_next 
4c29				endm 
# End of macro NEXTW
4c29			.V1S: 
4c29				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4c29 7a				db WORD_SYS_CORE+102             
4c2a 41 4c			dw .V1Q            
4c2c 04				db 3 + 1 
4c2d .. 00			db "V1!",0              
4c31				endm 
# End of macro CWHEAD
4c31			;| V1! ( u1 -- )  Store value to v1 | DONE 
4c31					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c31 cd 95 1d			call macro_dsp_valuehl 
4c34				endm 
# End of macro FORTH_DSP_VALUEHL
4c34			 
4c34 11 24 ea				ld de, cli_var_array+2 
4c37				 
4c37 eb					ex de, hl 
4c38 73					ld (hl), e 
4c39 23					inc hl 
4c3a 72					ld (hl), d 
4c3b			 
4c3b					; destroy value TOS 
4c3b			 
4c3b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c3b cd 4d 1e			call macro_forth_dsp_pop 
4c3e				endm 
# End of macro FORTH_DSP_POP
4c3e				       NEXTW 
4c3e c3 81 1f			jp macro_next 
4c41				endm 
# End of macro NEXTW
4c41			.V1Q: 
4c41				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4c41 7b				db WORD_SYS_CORE+103             
4c42 52 4c			dw .V2S            
4c44 04				db 3 + 1 
4c45 .. 00			db "V1@",0              
4c49				endm 
# End of macro CWHEAD
4c49			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4c49 2a 24 ea				ld hl, (cli_var_array+2) 
4c4c cd 90 1b				call forth_push_numhl 
4c4f				       NEXTW 
4c4f c3 81 1f			jp macro_next 
4c52				endm 
# End of macro NEXTW
4c52			.V2S: 
4c52				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4c52 7c				db WORD_SYS_CORE+104             
4c53 6a 4c			dw .V2Q            
4c55 04				db 3 + 1 
4c56 .. 00			db "V2!",0              
4c5a				endm 
# End of macro CWHEAD
4c5a			;| V2! ( u1 -- )  Store value to v2 | DONE 
4c5a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c5a cd 95 1d			call macro_dsp_valuehl 
4c5d				endm 
# End of macro FORTH_DSP_VALUEHL
4c5d			 
4c5d 11 26 ea				ld de, cli_var_array+4 
4c60				 
4c60 eb					ex de, hl 
4c61 73					ld (hl), e 
4c62 23					inc hl 
4c63 72					ld (hl), d 
4c64			 
4c64					; destroy value TOS 
4c64			 
4c64					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c64 cd 4d 1e			call macro_forth_dsp_pop 
4c67				endm 
# End of macro FORTH_DSP_POP
4c67				       NEXTW 
4c67 c3 81 1f			jp macro_next 
4c6a				endm 
# End of macro NEXTW
4c6a			.V2Q: 
4c6a				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4c6a 7d				db WORD_SYS_CORE+105             
4c6b 7b 4c			dw .V3S            
4c6d 04				db 3 + 1 
4c6e .. 00			db "V2@",0              
4c72				endm 
# End of macro CWHEAD
4c72			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4c72 2a 26 ea				ld hl, (cli_var_array+4) 
4c75 cd 90 1b				call forth_push_numhl 
4c78				       NEXTW 
4c78 c3 81 1f			jp macro_next 
4c7b				endm 
# End of macro NEXTW
4c7b			.V3S: 
4c7b				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4c7b 7c				db WORD_SYS_CORE+104             
4c7c 93 4c			dw .V3Q            
4c7e 04				db 3 + 1 
4c7f .. 00			db "V3!",0              
4c83				endm 
# End of macro CWHEAD
4c83			;| V3! ( u1 -- )  Store value to v3 | DONE 
4c83					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c83 cd 95 1d			call macro_dsp_valuehl 
4c86				endm 
# End of macro FORTH_DSP_VALUEHL
4c86			 
4c86 11 28 ea				ld de, cli_var_array+6 
4c89				 
4c89 eb					ex de, hl 
4c8a 73					ld (hl), e 
4c8b 23					inc hl 
4c8c 72					ld (hl), d 
4c8d			 
4c8d					; destroy value TOS 
4c8d			 
4c8d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c8d cd 4d 1e			call macro_forth_dsp_pop 
4c90				endm 
# End of macro FORTH_DSP_POP
4c90				       NEXTW 
4c90 c3 81 1f			jp macro_next 
4c93				endm 
# End of macro NEXTW
4c93			.V3Q: 
4c93				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4c93 7d				db WORD_SYS_CORE+105             
4c94 a4 4c			dw .END            
4c96 04				db 3 + 1 
4c97 .. 00			db "V3@",0              
4c9b				endm 
# End of macro CWHEAD
4c9b			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4c9b 2a 28 ea				ld hl, (cli_var_array+6) 
4c9e cd 90 1b				call forth_push_numhl 
4ca1				       NEXTW 
4ca1 c3 81 1f			jp macro_next 
4ca4				endm 
# End of macro NEXTW
4ca4			 
4ca4			 
4ca4			 
4ca4			 
4ca4			 
4ca4			; end of dict marker 
4ca4			 
4ca4 00			.END:    db WORD_SYS_END 
4ca5 00 00			dw 0 
4ca7 00				db 0 
4ca8			 
4ca8			; use to jp here for user dict words to save on macro expansion  
4ca8			 
4ca8			user_dict_next: 
4ca8				NEXTW 
4ca8 c3 81 1f			jp macro_next 
4cab				endm 
# End of macro NEXTW
4cab			 
4cab			 
4cab			user_exec: 
4cab				;    ld hl, <word code> 
4cab				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4cab				;    call forthexec 
4cab				;    jp user_dict_next   (NEXT) 
4cab			        ;    <word code bytes> 
4cab eb				ex de, hl 
4cac 2a bc e5			ld hl,(os_tok_ptr) 
4caf				 
4caf				FORTH_RSP_NEXT 
4caf cd 37 1b			call macro_forth_rsp_next 
4cb2				endm 
# End of macro FORTH_RSP_NEXT
4cb2			 
4cb2			if DEBUG_FORTH_UWORD 
4cb2						DMARK "UEX" 
4cb2 f5				push af  
4cb3 3a c7 4c			ld a, (.dmark)  
4cb6 32 65 ee			ld (debug_mark),a  
4cb9 3a c8 4c			ld a, (.dmark+1)  
4cbc 32 66 ee			ld (debug_mark+1),a  
4cbf 3a c9 4c			ld a, (.dmark+2)  
4cc2 32 67 ee			ld (debug_mark+2),a  
4cc5 18 03			jr .pastdmark  
4cc7 ..			.dmark: db "UEX"  
4cca f1			.pastdmark: pop af  
4ccb			endm  
# End of macro DMARK
4ccb				CALLMONITOR 
4ccb cd 6f ee			call debug_vector  
4cce				endm  
# End of macro CALLMONITOR
4cce			endif 
4cce			 
4cce			 
4cce			 
4cce eb				ex de, hl 
4ccf 22 bc e5			ld (os_tok_ptr), hl 
4cd2				 
4cd2				; Don't use next - Skips the first word in uword. 
4cd2			 
4cd2 c3 12 20			jp exec1 
4cd5			;	NEXT 
4cd5			 
4cd5			 
4cd5			; eof 
# End of file forth_wordsv4.asm
4cd5			endif 
4cd5			;;;;;;;;;;;;;; Debug code 
4cd5			 
4cd5			 
4cd5			;if DEBUG_FORTH_PARSE 
4cd5 .. 00		.nowordfound: db "No match",0 
4cde .. 00		.compword:	db "Comparing word ",0 
4cee .. 00		.nextwordat:	db "Next word at",0 
4cfb .. 00		.charmatch:	db "Char match",0 
4d06			;endif 
4d06			if DEBUG_FORTH_JP 
4d06			.foundword:	db "Word match. Exec..",0 
4d06			endif 
4d06			;if DEBUG_FORTH_PUSH 
4d06 .. 00		.enddict:	db "Dict end. Push.",0 
4d16 .. 00		.push_str:	db "Pushing string",0 
4d25 .. 00		.push_num:	db "Pushing number",0 
4d34 .. 00		.data_sp:	db "SP:",0 
4d38 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4d4a .. 00		.wordinde:	db "Word in DE (3/0):",0 
4d5c .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4d6e			;endif 
4d6e			;if DEBUG_FORTH_MALLOC 
4d6e .. 00		.push_malloc:	db "Malloc address",0 
4d7d			;endif 
4d7d			 
4d7d			 
4d7d			 
4d7d			; display malloc address and current data stack pointer  
4d7d			 
4d7d			malloc_error: 
4d7d d5				push de 
4d7e f5				push af 
4d7f e5				push hl 
4d80 cd c8 0b			call clear_display 
4d83 11 a3 4d			ld de, .mallocerr 
4d86 3e 00			ld a,0 
4d88			;	ld de,os_word_scratch 
4d88 cd db 0b			call str_at_display 
4d8b 3e 11			ld a, display_row_1+17 
4d8d 11 65 ee			ld de, debug_mark 
4d90 cd db 0b			call str_at_display 
4d93 cd eb 0b			call update_display 
4d96				;call break_point_state 
4d96 cd f1 5e			call cin_wait 
4d99			 
4d99			;	ld a, ' ' 
4d99			;	ld (os_view_disable), a 
4d99 cd ff 14			call bp_on 
4d9c e1				pop hl 
4d9d f1				pop af 
4d9e d1				pop de	 
4d9f				CALLMONITOR 
4d9f cd 6f ee			call debug_vector  
4da2				endm  
# End of macro CALLMONITOR
4da2 c9				ret 
4da3			 
4da3 .. 00		.mallocerr: 	db "Malloc Error",0 
4db0			;if DEBUG_FORTH_PUSH 
4db0			display_data_sp: 
4db0 f5				push af 
4db1			 
4db1				; see if disabled 
4db1			 
4db1			 
4db1 3a 6f ee			ld a, (debug_vector) 
4db4 fe c9			cp $C9  ; RET 
4db6				;ld a, (os_view_disable) 
4db6				;cp '*' 
4db6 28 67			jr z, .skipdsp 
4db8			 
4db8 e5				push hl 
4db9 e5				push hl 
4dba e5			push hl 
4dbb cd c8 0b			call clear_display 
4dbe e1			pop hl 
4dbf 7c				ld a,h 
4dc0 21 c0 e5			ld hl, os_word_scratch 
4dc3 cd fe 0f			call hexout 
4dc6 e1				pop hl 
4dc7 7d				ld a,l 
4dc8 21 c2 e5			ld hl, os_word_scratch+2 
4dcb cd fe 0f			call hexout 
4dce 21 c4 e5			ld hl, os_word_scratch+4 
4dd1 3e 00			ld a,0 
4dd3 77				ld (hl),a 
4dd4 11 c0 e5			ld de,os_word_scratch 
4dd7 3e 28				ld a, display_row_2 
4dd9 cd db 0b				call str_at_display 
4ddc 11 38 4d			ld de, .wordinhl 
4ddf 3e 00			ld a, display_row_1 
4de1			 
4de1 cd db 0b				call str_at_display 
4de4 11 65 ee			ld de, debug_mark 
4de7 3e 11			ld a, display_row_1+17 
4de9			 
4de9 cd db 0b				call str_at_display 
4dec			 
4dec				; display current data stack pointer 
4dec 11 34 4d			ld de,.data_sp 
4def 3e 30				ld a, display_row_2 + 8 
4df1 cd db 0b				call str_at_display 
4df4			 
4df4 2a e8 e9			ld hl,(cli_data_sp) 
4df7 e5				push hl 
4df8 7c				ld a,h 
4df9 21 c0 e5			ld hl, os_word_scratch 
4dfc cd fe 0f			call hexout 
4dff e1				pop hl 
4e00 7d				ld a,l 
4e01 21 c2 e5			ld hl, os_word_scratch+2 
4e04 cd fe 0f			call hexout 
4e07 21 c4 e5			ld hl, os_word_scratch+4 
4e0a 3e 00			ld a,0 
4e0c 77				ld (hl),a 
4e0d 11 c0 e5			ld de,os_word_scratch 
4e10 3e 33				ld a, display_row_2 + 11 
4e12 cd db 0b				call str_at_display 
4e15			 
4e15			 
4e15 cd eb 0b			call update_display 
4e18 cd 00 0b			call delay1s 
4e1b cd 00 0b			call delay1s 
4e1e e1				pop hl 
4e1f			.skipdsp: 
4e1f f1				pop af 
4e20 c9				ret 
4e21			 
4e21			display_data_malloc: 
4e21			 
4e21 f5				push af 
4e22 e5				push hl 
4e23 e5				push hl 
4e24 e5			push hl 
4e25 cd c8 0b			call clear_display 
4e28 e1			pop hl 
4e29 7c				ld a,h 
4e2a 21 c0 e5			ld hl, os_word_scratch 
4e2d cd fe 0f			call hexout 
4e30 e1				pop hl 
4e31 7d				ld a,l 
4e32 21 c2 e5			ld hl, os_word_scratch+2 
4e35 cd fe 0f			call hexout 
4e38 21 c4 e5			ld hl, os_word_scratch+4 
4e3b 3e 00			ld a,0 
4e3d 77				ld (hl),a 
4e3e 11 c0 e5			ld de,os_word_scratch 
4e41 3e 28				ld a, display_row_2 
4e43 cd db 0b				call str_at_display 
4e46 11 6e 4d			ld de, .push_malloc 
4e49 3e 00			ld a, display_row_1 
4e4b			 
4e4b cd db 0b				call str_at_display 
4e4e			 
4e4e				; display current data stack pointer 
4e4e 11 34 4d			ld de,.data_sp 
4e51 3e 30				ld a, display_row_2 + 8 
4e53 cd db 0b				call str_at_display 
4e56			 
4e56 2a e8 e9			ld hl,(cli_data_sp) 
4e59 e5				push hl 
4e5a 7c				ld a,h 
4e5b 21 c0 e5			ld hl, os_word_scratch 
4e5e cd fe 0f			call hexout 
4e61 e1				pop hl 
4e62 7d				ld a,l 
4e63 21 c2 e5			ld hl, os_word_scratch+2 
4e66 cd fe 0f			call hexout 
4e69 21 c4 e5			ld hl, os_word_scratch+4 
4e6c 3e 00			ld a,0 
4e6e 77				ld (hl),a 
4e6f 11 c0 e5			ld de,os_word_scratch 
4e72 3e 33				ld a, display_row_2 + 11 
4e74 cd db 0b				call str_at_display 
4e77			 
4e77 cd eb 0b			call update_display 
4e7a cd 00 0b			call delay1s 
4e7d cd 00 0b			call delay1s 
4e80 e1				pop hl 
4e81 f1				pop af 
4e82 c9				ret 
4e83			;endif 
4e83			 
4e83			include "forth_autostart.asm" 
4e83			; list of commands to perform at system start up 
4e83			 
4e83			startcmds: 
4e83			;	dw test11 
4e83			;	dw test12 
4e83			;	dw test13 
4e83			;	dw test14 
4e83			;	dw test15 
4e83			;	dw test16 
4e83			;	dw test17 
4e83			;	dw ifthtest1 
4e83			;	dw ifthtest2 
4e83			;	dw ifthtest3 
4e83			;	dw mmtest1 
4e83			;	dw mmtest2 
4e83			;	dw mmtest3 
4e83			;	dw mmtest4 
4e83			;	dw mmtest5 
4e83			;	dw mmtest6 
4e83			;	dw iftest1 
4e83			;	dw iftest2 
4e83			;	dw iftest3 
4e83			;	dw looptest1 
4e83			;	dw looptest2 
4e83			;	dw test1 
4e83			;	dw test2 
4e83			;	dw test3 
4e83			;	dw test4 
4e83			;	dw game2r 
4e83			;	dw game2b1 
4e83			;	dw game2b2 
4e83			 
4e83				; start up words that are actually useful 
4e83			 
4e83			;    dw spi1 
4e83			;    dw spi2 
4e83			;    dw spi3 
4e83			;    dw spi4 
4e83			;    dw spi5 
4e83			;    dw spi6 
4e83			;    dw spi7 
4e83			; 
4e83			;    dw spi8 
4e83			;    dw spi9 
4e83			;    dw spi10 
4e83			 
4e83			; file editor 
4e83			;	dw edit1 
4e83			;	dw edit2 
4e83			;	dw edit3 
4e83			 
4e83			;	dw longread 
4e83 a3 52			dw clrstack 
4e85 d7 52			dw type 
4e87			;	dw stest 
4e87 fc 52			dw strncpy 
4e89			;	dw list 
4e89 5d 53			dw start1 
4e8b 6d 53			dw start2 
4e8d			;	dw start3 
4e8d			;	dw start3b 
4e8d			;	dw start3c 
4e8d			 
4e8d				; (unit) testing words 
4e8d			 
4e8d			;	dw mtesta 
4e8d			;	dw mtestb 
4e8d			;	dw mtestc 
4e8d			;	dw mtestd 
4e8d			;	dw mteste 
4e8d			 
4e8d				; demo/game words 
4e8d			 
4e8d			;        dw game3w 
4e8d			;        dw game3p 
4e8d			;        dw game3sc 
4e8d			;        dw game3vsi 
4e8d			;        dw game3vs 
4e8d				 
4e8d			;	dw game2b 
4e8d			;	dw game2bf 
4e8d			;	dw game2mba 
4e8d			;	dw game2mbas 
4e8d			;	dw game2mb 
4e8d			 
4e8d 8a 56			dw game1 
4e8f 9b 56			dw game1a 
4e91 fd 56			dw game1b 
4e93 32 57			dw game1c 
4e95 68 57			dw game1d 
4e97 99 57			dw game1s 
4e99 ad 57			dw game1t 
4e9b c2 57			dw game1f 
4e9d f6 57			dw game1z 
4e9f 3a 58			dw game1zz 
4ea1			 
4ea1 c3 54			dw test5 
4ea3 fb 54			dw test6 
4ea5 33 55			dw test7 
4ea7 47 55			dw test8 
4ea9 73 55			dw test9 
4eab 89 55			dw test10 
4ead				 
4ead 11 59		        dw ssv5 
4eaf f5 58		        dw ssv4 
4eb1 d9 58		        dw ssv3 
4eb3 a3 58		        dw ssv2 
4eb5 2a 59		        dw ssv1 
4eb7 72 59		        dw ssv1cpm 
4eb9			;	dw keyup 
4eb9			;	dw keydown 
4eb9			;	dw keyleft 
4eb9			;	dw keyright 
4eb9			;	dw 	keyf1 
4eb9			;	dw keyf2 
4eb9			;	dw keyf3 
4eb9			;	dw keyf4 
4eb9			;	dw keyf5 
4eb9			;	dw keyf6 
4eb9			;	dw keyf7 
4eb9			;	dw keyf8 
4eb9			;	dw keyf9 
4eb9			;	dw keyf10 
4eb9			;	dw keyf11 
4eb9			;	dw keyf12 
4eb9			;	dw keytab 
4eb9			;	dw keycr 
4eb9			;	dw keyhome 
4eb9			;	dw keyend 
4eb9			;	dw keybs 
4eb9 00 00			db 0, 0	 
4ebb			 
4ebb			 
4ebb			; File Editor 
4ebb			 
4ebb			; ( id - ) use 'e' to edit the displayed line 
4ebb .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
4edc .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4f11			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4f11 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
4f49			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
4f49			 
4f49			; SPI Net support words 
4f49			 
4f49			; v0! = node to send to 
4f49			; ( str count - ) 
4f49 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
4fa2			 
4fa2			; spiputc ( char node - ) 
4fa2 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
4fd6			; spiputc ( u node - ) 
4fd6 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
5004			 
5004			; spigetc ( - n ) 
5004 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
502d			 
502d			; getnode ( - n ) 
502d .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
505a			 
505a			; ( str node - )  
505a .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
50c0			; store string ( str i - ) 
50c0			 
50c0			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
50c0 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
5115			 
5115			; get string ( addr i -  )    TO FIX 
5115			 
5115 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
516d			 
516d			 
516d			; NETCHAT (TODO) 
516d			; Program to allow two nodes to chat with eachother 
516d			; 
516d			; v0 - target node 
516d			;  
516d			; accept input at 0,0 
516d			; if input is string send spitype to target node 
516d			; starting at row 2,0 , while spigetchr is not zero ->  
516d			; 
516d			; 
516d			; TODO add paging of get request 
516d			 
516d			; ( node - ) 
516d .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
518c .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
51e4 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
525c			 
525c			 
525c			; Long read of currently open file 
525c .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
52a3			 
52a3			; clear stack  
52a3			 
52a3 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
52d7			 
52d7			; type ( addr count - ) 
52d7 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
52fc			 
52fc			; some direct memory words 
52fc			; strncpy ( len t f -- t ) 
52fc			 
52fc .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
535d			 
535d .. 00		start1:     	db ": bpon $00 bp ;",0 
536d .. 00		start2:     	db ": bpoff $01 bp ;",0 
537e .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
53f9 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5459			 
5459			 
5459			; a handy word to list items on the stack 
5459			 
5459 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
54c3			 
54c3			 
54c3			; test stack  
54c3			; rnd8 stest 
54c3			 
54c3			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
54c3			 
54c3			; random malloc and free cycles 
54c3			 
54c3			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
54c3			 
54c3			; fixed malloc and free cycles 
54c3			 
54c3			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
54c3			 
54c3			; fixed double string push and drop cycle  
54c3			 
54c3			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
54c3			 
54c3			; consistent fixed string push and drop cycle  
54c3			 
54c3			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
54c3			 
54c3			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
54c3			 
54c3			;test1:		db ": aa 1 2 3 ;", 0 
54c3			;test2:     	db "111 aa 888 999",0 
54c3			;test3:     	db ": bb 77 ;",0 
54c3			;test4:     	db "$02 $01 do i . loop bb",0 
54c3			 
54c3 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
54fb .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
5533 .. 00		test7:     	db ": box hline vline ;",0 
5547 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
5573 .. 00		test9:     	db ": sw $01 adsp world ;",0 
5589 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
55ae			;test11:     	db "hello create .",0 
55ae			;test12:     	db "hello2 create .",0 
55ae			 
55ae			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
55ae			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
55ae			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
55ae			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
55ae			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
55ae			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
55ae			 
55ae			;iftest1:     	db "$0001 IF cls .",0 
55ae			;iftest2:     	db "$0000 IF cls .",0 
55ae			;iftest3:     	db "$0002 $0003 - IF cls .",0 
55ae			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
55ae			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
55ae			 
55ae			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
55ae			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
55ae			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
55ae			 
55ae			 
55ae .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
55d2 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
5602 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
5627 .. 00		sound4: db ": cha $00 ; ",0 
5634 .. 00		sound5: db ": chb $20 ; ",0 
5641 .. 00		sound6: db ": chc $40 ; ",0 
564e .. 00		sound7: db ": chd $60 ; ",0 
565b .. 00		sound8: db ": cnote $80 + + note ; ", 0 
5673 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
568a			 
568a			 
568a			 
568a			 
568a			; a small guess the number game 
568a			 
568a .. 00		game1:          db ": gsn rnd8 v1! ;",0 
569b .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
56fd			 
56fd .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5732 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5768 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5799 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
57ad .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
57c2 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
57f6 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
583a			 
583a			; Using 'ga' save a high score across multiple runs using external storage 
583a			 
583a .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
58a3			 
58a3			 
58a3			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
58a3			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
58a3			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
58a3			 
58a3			; simple screen saver to test code memory reuse to destruction 
58a3			 
58a3 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
58d9 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
58f5 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5911 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
592a .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5972 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
59c9			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
59c9			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
59c9			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
59c9			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
59c9			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
59c9			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
59c9			 
59c9			 
59c9			 
59c9			; minesweeper/battleship finding game 
59c9			; draws a game board of random ship/mine positions 
59c9			; user enters coords to see if it hits on 
59c9			; game ends when all are hit 
59c9			; when hit or miss says how many may be in the area 
59c9			 
59c9			; setup the game board and then hide it 
59c9			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
59c9			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
59c9			;; prompt for where to target 
59c9			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
59c9			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
59c9			;; TODO see if the entered coords hits or misses pushes char hit of miss 
59c9			;game2mbht:      db ": mbckht nop ;",0 
59c9			;game2mbms:      db ": mbcms nop ;",0 
59c9			; TODO how many might be near by 
59c9			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
59c9			 
59c9			; Game 3 
59c9			 
59c9			; Vert scroller ski game - avoid the trees! 
59c9			 
59c9			; v0 score (ie turns) 
59c9			; v1 player pos 
59c9			; v2 left wall 
59c9			; v3 right wall 
59c9			 
59c9			; Draw side walls randomly 
59c9			 
59c9			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
59c9			 
59c9			; Draw player 
59c9			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
59c9			 
59c9			; TODO Get Key 
59c9			 
59c9			; TODO Move left right 
59c9			 
59c9			; scroll and move walls a bit 
59c9			 
59c9			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
59c9			 
59c9			; main game loop 
59c9			 
59c9			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
59c9			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
59c9			 
59c9			; key board defs 
59c9			 
59c9 .. 00		keyup:       db ": keyup $05 ;",0 
59d7 .. 00		keydown:       db ": keydown $0a ;",0 
59e7 .. 00		keyleft:       db ": keyleft $0b ;",0 
59f7 .. 00		keyright:       db ": keyright $0c ;",0 
5a08 .. 00		keyf1:       db ": keyf1 $10 ;",0 
5a16 .. 00		keyf2:       db ": keyf2 $11 ;",0 
5a24 .. 00		keyf3:       db ": keyf3 $12 ;",0 
5a32 .. 00		keyf4:       db ": keyf4 $13 ;",0 
5a40 .. 00		keyf5:       db ": keyf5 $14 ;",0 
5a4e .. 00		keyf6:       db ": keyf6 $15 ;",0 
5a5c .. 00		keyf7:       db ": keyf7 $16 ;",0 
5a6a .. 00		keyf8:       db ": keyf8 $17 ;",0 
5a78 .. 00		keyf9:       db ": keyf9 $18 ;",0 
5a86 .. 00		keyf10:       db ": keyf10 $19 ;",0 
5a95 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5aa4 .. 00		keyf12:       db ": keyf12 $1b ;",0 
5ab3			 
5ab3 .. 00		keytab:       db ": keytab $09 ;",0 
5ac2 .. 00		keycr:       db ": keycr $0d ;",0 
5ad0 .. 00		keyhome:       db ": keyhome $0e ;",0 
5ae0 .. 00		keyend:       db ": keyend $0f ;",0 
5aef .. 00		keybs:       db ": keybs $08 ;",0 
5afd			 
5afd			   
5afd			 
5afd			 
5afd			 
5afd			; eof 
# End of file forth_autostart.asm
5afd			 
5afd			 
5afd			 
5afd			; stack over and underflow checks 
5afd			 
5afd			; init the words to detect the under/overflow 
5afd			 
5afd			chk_stk_init: 
5afd				; a vague random number to check so we dont get any "lucky" hits 
5afd 3e 2d			ld a, 45 
5aff 6f				ld l, a 
5b00 00				nop 
5b01 3e 17			ld a, 23 
5b03 67				ld h, a 
5b04			 
5b04 22 97 e2			ld (chk_word), hl     ; the word we need to check against 
5b07			 
5b07			;	ld (chk_stund), hl	; stack points.... 
5b07 22 00 ef			ld (chk_stovr), hl 
5b0a 22 e6 e9			ld (chk_ret_und), hl 
5b0d 22 a4 e9			ld (chk_ret_ovr), hl 
5b10 22 22 e9			ld (chk_loop_ovr), hl 
5b13 22 20 e8			ld (chk_data_ovr), hl 
5b16 c9				ret 
5b17				 
5b17			check_stacks: 
5b17				; check all stack words 
5b17			 
5b17 e5				push hl 
5b18 d5				push de 
5b19			 
5b19			;	ld de,(chk_word) 
5b19			;	ld hl, (chk_stund)	; stack points.... 
5b19			;	if DEBUG_STK_FAULT 
5b19			;		DMARK "FAa" 
5b19			;		CALLMONITOR 
5b19			;	endif 
5b19			;	call cmp16 
5b19			;	jp z, .chk_faulta 
5b19			; 
5b19			;	ld de, sfaultsu 
5b19			;	jp .chk_fault 
5b19			 
5b19 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
5b1c ed 5b 97 e2		ld de,(chk_word) 
5b20				if DEBUG_STK_FAULT 
5b20					DMARK "FAb" 
5b20					CALLMONITOR 
5b20				endif 
5b20 cd 13 0e			call cmp16 
5b23 28 06			jr z, .chk_fault1 
5b25 11 c9 5b			ld de, sfaultso 
5b28 c3 7a 5b			jp .chk_fault 
5b2b			.chk_fault1:  
5b2b 2a e6 e9			ld hl, (chk_ret_und) 
5b2e ed 5b 97 e2		ld de,(chk_word) 
5b32				if DEBUG_STK_FAULT 
5b32					DMARK "FAU" 
5b32					CALLMONITOR 
5b32				endif 
5b32 cd 13 0e			call cmp16 
5b35 ca 3e 5b			jp z, .chk_fault2 
5b38 11 d9 5b			ld de, sfaultru 
5b3b c3 7a 5b			jp .chk_fault 
5b3e			.chk_fault2:  
5b3e 2a a4 e9			ld hl, (chk_ret_ovr) 
5b41 ed 5b 97 e2		ld de,(chk_word) 
5b45				if DEBUG_STK_FAULT 
5b45					DMARK "FA1" 
5b45					CALLMONITOR 
5b45				endif 
5b45 cd 13 0e			call cmp16 
5b48 ca 51 5b			jp z, .chk_fault3 
5b4b 11 e7 5b			ld de, sfaultro 
5b4e c3 7a 5b			jp .chk_fault 
5b51			.chk_fault3:  
5b51 2a 22 e9			ld hl, (chk_loop_ovr) 
5b54 ed 5b 97 e2		ld de,(chk_word) 
5b58				if DEBUG_STK_FAULT 
5b58					DMARK "FA2" 
5b58					CALLMONITOR 
5b58				endif 
5b58 cd 13 0e			call cmp16 
5b5b ca 64 5b			jp z, .chk_fault4 
5b5e 11 01 5c			ld de, sfaultlo 
5b61 c3 7a 5b			jp .chk_fault 
5b64			.chk_fault4:  
5b64 2a 20 e8			ld hl, (chk_data_ovr) 
5b67 ed 5b 97 e2		ld de,(chk_word) 
5b6b				if DEBUG_STK_FAULT 
5b6b					DMARK "FA3" 
5b6b					CALLMONITOR 
5b6b				endif 
5b6b cd 13 0e			call cmp16 
5b6e ca 77 5b			jp z, .chk_fault5 
5b71 11 1b 5c			ld de, sfaultdo 
5b74 c3 7a 5b			jp .chk_fault 
5b77			 
5b77			 
5b77			.chk_fault5:  
5b77 d1				pop de 
5b78 e1				pop hl 
5b79			 
5b79 c9				ret 
5b7a			 
5b7a cd c8 0b		.chk_fault: 	call clear_display 
5b7d 3e 28				ld a, display_row_2 
5b7f cd db 0b				call str_at_display 
5b82 11 ab 5b				   ld de, .stackfault 
5b85 3e 00				ld a, display_row_1 
5b87 cd db 0b				call str_at_display 
5b8a 11 65 ee				    ld de, debug_mark 
5b8d 3e 11				ld a, display_row_1+17 
5b8f cd db 0b				call str_at_display 
5b92 cd eb 0b				call update_display 
5b95			 
5b95				; prompt before entering montior for investigating issue 
5b95			 
5b95 3e 78			ld a, display_row_4 
5b97 11 6e 18			ld de, endprog 
5b9a			 
5b9a cd eb 0b			call update_display		 
5b9d			 
5b9d cd 08 1b			call next_page_prompt 
5ba0			 
5ba0 d1				pop de 
5ba1 e1				pop hl 
5ba2 cd c2 18				call monitor 
5ba5 cd 27 1f				call forth_warmstart 
5ba8 c3 be 17				jp warmstart_afterauto 
5bab					;jp 0 
5bab					;halt 
5bab			 
5bab			 
5bab			 
5bab .. 00		.stackfault: 	db "Stack fault:",0 
5bb8			 
5bb8 .. 00		sfaultsu: 	db	"Stack under flow",0 
5bc9 .. 00		sfaultso: 	db	"Stack over flow",0 
5bd9 .. 00		sfaultru:	db "RTS underflow",0 
5be7 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
5c01 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
5c1b .. 00		sfaultdo:	db "DTS overflow", 0 
5c28			 
5c28			 
5c28			fault_dsp_under: 
5c28 11 3a 5c			ld de, .dsp_under 
5c2b c3 f0 5c			jp .show_fault 
5c2e			 
5c2e			fault_rsp_under: 
5c2e 11 48 5c			ld de, .rsp_under 
5c31 c3 f0 5c			jp .show_fault 
5c34			fault_loop_under: 
5c34 11 56 5c			ld de, .loop_under 
5c37 c3 f0 5c			jp .show_fault 
5c3a			 
5c3a .. 00		.dsp_under: db "DSP Underflow",0 
5c48 .. 00		.rsp_under: db "RSP Underflow",0 
5c56 .. 00		.loop_under: db "LOOP Underflow",0 
5c65			 
5c65			 
5c65 d5			type_faultn: 	push de 
5c66 e5					push hl 
5c67 cd c8 0b				call clear_display 
5c6a 11 94 5c				   ld de, .typefaultn 
5c6d 3e 00				ld a, display_row_1 
5c6f cd db 0b				call str_at_display 
5c72 11 65 ee				    ld de, debug_mark 
5c75 3e 11				ld a, display_row_1+17 
5c77 cd db 0b				call str_at_display 
5c7a cd eb 0b				call update_display 
5c7d			 
5c7d				; prompt before entering montior for investigating issue 
5c7d			 
5c7d 3e 78			ld a, display_row_4 
5c7f 11 6e 18			ld de, endprog 
5c82			 
5c82 cd eb 0b			call update_display		 
5c85			 
5c85 cd 08 1b			call next_page_prompt 
5c88			 
5c88 e5					push hl 
5c89 d5					push de 
5c8a cd c2 18				call monitor 
5c8d cd 27 1f				call forth_warmstart 
5c90 c3 be 17				jp warmstart_afterauto 
5c93 76					halt 
5c94			 
5c94			 
5c94 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
5cab			 
5cab d5			type_faults: 	push de 
5cac e5					push hl 
5cad cd c8 0b				call clear_display 
5cb0 11 d9 5c				   ld de, .typefaults 
5cb3 3e 00				ld a, display_row_1 
5cb5 cd db 0b				call str_at_display 
5cb8 11 65 ee				    ld de, debug_mark 
5cbb 3e 11				ld a, display_row_1+17 
5cbd cd db 0b				call str_at_display 
5cc0 cd eb 0b				call update_display 
5cc3			 
5cc3				; prompt before entering montior for investigating issue 
5cc3			 
5cc3 3e 78			ld a, display_row_4 
5cc5 11 6e 18			ld de, endprog 
5cc8			 
5cc8 cd eb 0b			call update_display		 
5ccb			 
5ccb cd 08 1b			call next_page_prompt 
5cce			 
5cce e1					pop hl 
5ccf d1					pop de 
5cd0 cd c2 18				call monitor 
5cd3 cd 27 1f				call forth_warmstart 
5cd6 c3 be 17				jp warmstart_afterauto 
5cd9			 
5cd9			 
5cd9 .. 00		.typefaults: db "STR Type Expected TOS!",0 
5cf0			 
5cf0			.show_fault: 	 
5cf0 d5					push de 
5cf1 cd c8 0b				call clear_display 
5cf4 d1					pop de 
5cf5 3e 00				ld a, display_row_1 
5cf7 cd db 0b				call str_at_display 
5cfa 11 65 ee				    ld de, debug_mark 
5cfd 3e 11				ld a, display_row_1+17 
5cff cd db 0b				call str_at_display 
5d02 cd eb 0b				call update_display 
5d05			 
5d05				; prompt before entering montior for investigating issue 
5d05			 
5d05 3e 78			ld a, display_row_4 
5d07 11 6e 18			ld de, endprog 
5d0a			 
5d0a cd eb 0b			call update_display		 
5d0d			 
5d0d cd 08 1b			call next_page_prompt 
5d10			 
5d10 e1					pop hl 
5d11 d1					pop de 
5d12 cd c2 18				call monitor 
5d15			; do a dump to cli and not warmstart so we preserve all of the uwords.  
5d15			; TODO Make optional fault restart to cli or warm boot? 
5d15					;jp warmstart 
5d15 c3 02 18				jp cli 
5d18 76					halt 
5d19			 
5d19			 
5d19			; handle the auto run of code from files in storage 
5d19			 
5d19			 
5d19			include "forth_startup.asm" 
5d19			; Which startup method to use? 
5d19			; 
5d19			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
5d19			; followed by loading of a list of scripts in eeprom 
5d19			 
5d19			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
5d19			; from eeprom 
5d19			 
5d19			; Select with define in main stubs 
5d19			 
5d19			if STARTUP_V1 
5d19				include "forth_startupv1.asm" 
5d19			; Startup script loading version 1 
5d19			 
5d19			; If SE storage is available first stage is to use the selected file 
5d19			; then go through the eeprom list 
5d19			 
5d19 .. 00		sprompt1: db "Startup load...",0 
5d29 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5d3f			 
5d3f			 
5d3f			 
5d3f			 
5d3f			forth_startup: 
5d3f 21 83 4e			ld hl, startcmds 
5d42 3e 00			ld a, 0 
5d44 32 e1 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
5d47			 
5d47 e5			.start1:	push hl 
5d48 cd c8 0b			call clear_display 
5d4b 11 19 5d			ld de, sprompt1 
5d4e 3e 00		        ld a, display_row_1 
5d50 cd db 0b			call str_at_display 
5d53 11 29 5d			ld de, sprompt2 
5d56 3e 28		        ld a, display_row_2 
5d58 cd db 0b			call str_at_display 
5d5b e1				pop hl 
5d5c e5				push hl 
5d5d 5e				ld e,(hl) 
5d5e 23				inc hl 
5d5f 56				ld d,(hl) 
5d60 3e 50		        ld a, display_row_3 
5d62 cd db 0b			call str_at_display 
5d65 cd eb 0b			call update_display 
5d68			 
5d68			 
5d68 3a e1 e6			ld a, (os_last_cmd) 
5d6b fe 00			cp 0 
5d6d 28 05			jr z, .startprompt 
5d6f cd f4 0a			call delay250ms 
5d72 18 24			jr .startdo 
5d74				 
5d74				 
5d74			 
5d74			.startprompt: 
5d74			 
5d74 3e 9f			ld a,display_row_4 + display_cols - 1 
5d76 11 06 1b		        ld de, endprg 
5d79 cd db 0b			call str_at_display 
5d7c cd eb 0b			call update_display 
5d7f cd 00 0b			call delay1s 
5d82 cd f1 5e			call cin_wait 
5d85						 
5d85 fe 2a			cp '*' 
5d87 28 5e			jr z, .startupend1 
5d89 fe 23			cp '#' 
5d8b 20 07			jr nz, .startno 
5d8d 3e 01			ld a, 1 
5d8f 32 e1 e6			ld (os_last_cmd),a 
5d92 18 04			jr .startdo 
5d94 fe 31		.startno:	cp '1' 
5d96 28 3a			jr z,.startnxt  
5d98			 
5d98				; exec startup line 
5d98			.startdo:	 
5d98 e1				pop hl 
5d99 e5				push hl 
5d9a				 
5d9a 5e				ld e,(hl) 
5d9b 23				inc hl 
5d9c 56				ld d,(hl) 
5d9d eb				ex de,hl 
5d9e			 
5d9e e5				push hl 
5d9f			 
5d9f 3e 00			ld a, 0 
5da1				;ld a, FORTH_END_BUFFER 
5da1 cd 66 11			call strlent 
5da4 23				inc hl   ; include zero term to copy 
5da5 06 00			ld b,0 
5da7 4d				ld c,l 
5da8 e1				pop hl 
5da9 11 bb e2			ld de, scratch 
5dac ed b0			ldir 
5dae			 
5dae			 
5dae 21 bb e2			ld hl, scratch 
5db1 cd cf 1f			call forthparse 
5db4 cd 0f 20			call forthexec 
5db7 cd 21 1f			call forthexec_cleanup 
5dba			 
5dba 3e 78			ld a, display_row_4 
5dbc 11 6e 18			ld de, endprog 
5dbf			 
5dbf cd eb 0b			call update_display		 
5dc2			 
5dc2 3a e1 e6			ld a, (os_last_cmd) 
5dc5 fe 00			cp 0 
5dc7 20 09			jr nz, .startnxt 
5dc9 cd 08 1b			call next_page_prompt 
5dcc cd c8 0b		        call clear_display 
5dcf cd eb 0b			call update_display		 
5dd2			 
5dd2				; move onto next startup line? 
5dd2			.startnxt: 
5dd2			 
5dd2 cd f4 0a			call delay250ms 
5dd5 e1				pop hl 
5dd6			 
5dd6 23				inc hl 
5dd7 23				inc hl 
5dd8			 
5dd8 e5				push hl 
5dd9 5e				ld e, (hl) 
5dda 23				inc hl 
5ddb 56				ld d, (hl) 
5ddc e1				pop hl 
5ddd				; TODO replace 0 test 
5ddd			 
5ddd eb				ex de, hl 
5dde cd 1e 0e			call ishlzero 
5de1			;	ld a,e 
5de1			;	add d 
5de1			;	cp 0    ; any left to do? 
5de1 eb				ex de, hl 
5de2 c2 47 5d			jp nz, .start1 
5de5 18 01			jr .startupend 
5de7			 
5de7 e1			.startupend1: pop hl 
5de8			.startupend: 
5de8			 
5de8 cd c8 0b			call clear_display 
5deb cd eb 0b			call update_display 
5dee c9				ret 
5def			if STORAGE_SE 
5def			 
5def			sprompt3: db "Loading from start-up file?:",0 
5def			sprompt4: db "(Y=Any key/N=No)",0 
5def			 
5def			 
5def			forth_autoload: 
5def			 
5def				; load block 0 of store 1 
5def				 
5def				ld a, $fe      ; bit 0 clear 
5def				ld (spi_device), a 
5def			 
5def				call storage_get_block_0 
5def			 
5def				ld a, (store_page+STORE_0_AUTOFILE) 
5def			 
5def				cp 0 
5def				ret z     ; auto start not enabled 
5def			 
5def				call clear_display 
5def			 
5def				; set bank 
5def			 
5def					ld a, (store_page+STORE_0_BANKRUN) 
5def					ld (spi_device), a 
5def			 
5def				; get file id to load from and get the file name to display 
5def			 
5def					ld a, (store_page+STORE_0_FILERUN) 
5def			 
5def					ld l, 0 
5def					ld h, a 
5def					ld de, store_page 
5def			 
5def					if DEBUG_FORTH_WORDS 
5def						DMARK "ASp" 
5def						CALLMONITOR 
5def					endif 
5def					call storage_read 
5def			 
5def					if DEBUG_FORTH_WORDS 
5def						DMARK "ASr" 
5def						CALLMONITOR 
5def					endif 
5def			 
5def					call ishlzero 
5def					ret z             ; file not found 
5def			 
5def					ld a, display_row_2 + 10 
5def					ld de, store_page+3 
5def					call str_at_display 
5def				 
5def			; 
5def			 
5def				ld a, display_row_1+5 
5def				ld de, sprompt3 
5def				call str_at_display 
5def				ld a, display_row_3+15 
5def				ld de, sprompt4 
5def				call str_at_display 
5def			 
5def				call update_display 
5def			 
5def				call cin_wait 
5def				cp 'n' 
5def				ret z 
5def				cp 'N' 
5def				ret z 
5def			 
5def				call delay1s 
5def			 
5def				ld a, (store_page+2) 
5def				ld (store_openmaxext), a    ; save count of ext 
5def				ld a, 1  
5def				ld (store_openext), a    ; save count of ext 
5def			 
5def			.autof:  
5def				ld l , a 
5def				 
5def				ld a, (store_page) 
5def				ld h, a	 
5def				ld de, store_page 
5def					if DEBUG_FORTH_WORDS 
5def						DMARK "ASl" 
5def						CALLMONITOR 
5def					endif 
5def					call storage_read 
5def				call ishlzero 
5def				ret z 
5def			;	jr z, .autoend 
5def			 
5def					if DEBUG_FORTH_WORDS 
5def						DMARK "ASc" 
5def						CALLMONITOR 
5def					endif 
5def				ld de, store_page+2 
5def				ld a, display_row_4 
5def				call str_at_display 
5def			 
5def				call update_display 
5def				call delay250ms 
5def			 
5def			 
5def			 
5def				ld hl, store_page+2 
5def				call forthparse 
5def				call forthexec 
5def				call forthexec_cleanup 
5def			 
5def				 
5def				ld a, (store_openext) 
5def				inc a 
5def				ld (store_openext), a    ; save count of ext 
5def			 
5def				jr .autof 
5def			;.autofdone: 
5def			; 
5def			;		if DEBUG_FORTH_WORDS 
5def			;			DMARK "ASx" 
5def			;			CALLMONITOR 
5def			;		endif 
5def			;;	call clear_display 
5def			;	ret 
5def			 
5def			 
5def			 
5def			endif 
# End of file forth_startupv1.asm
5def			endif 
5def			if STARTUP_V2 
5def				include "forth_startupv2.asm" 
5def			endif 
5def			 
# End of file forth_startup.asm
5def			 
5def			; eof 
# End of file forth_kernel.asm
5def			;include "nascombasic.asm" 
5def			 
5def			 
5def			; find out where the code ends if loaded into RAM (for SC114) 
5def			;endofcode:  
5def			;	nop 
5def			 
5def			 
5def			; jump to nmi vector 
5def			 
5def			init_nmi: 
5def 3e c9			ld a, $c9   ; RET 
5df1 32 72 ee			ld (nmi_vector), a 
5df4 c9				ret 
5df5			nmi: 
5df5 e5				push hl 
5df6 d5				push de 
5df7 c5				push bc 
5df8 f5				push af 
5df9 cd 72 ee			call nmi_vector 
5dfc f5				push af 
5dfd c5				push bc 
5dfe d5				push de 
5dff e5				push hl 
5e00 ed 4d			reti 
5e02			 
5e02			 
5e02			; eof 
5e02			 
# End of file main.asm
5e02			;include "firmware_lcd_4x40.asm" 
5e02			;;include "firmware_lcd_4x20.asm" 
5e02			include "firmware_cpm_display.asm" 
5e02			 
5e02			; Serial display interface for SC114 
5e02			 
5e02			 
5e02			display_row_1: equ 0 
5e02			display_row_2: equ display_row_1+display_cols 
5e02			display_row_3: equ display_row_2 + display_cols 
5e02			display_row_4: equ display_row_3 + display_cols 
5e02			 
5e02			kLCDWidth:  EQU display_cols             ;Width in characters 
5e02			kLCD_Line1: EQU 0x00  
5e02			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
5e02			; E1 
5e02			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
5e02			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
5e02			 
5e02			lcd_init: 
5e02				; no init as handled by the SCM bios 
5e02 c9				ret 
5e03			 
5e03			 
5e03			; low level functions for direct screen writes 
5e03			 
5e03			; output char at pos? 
5e03			fLCD_Str: 
5e03			        ;out (SC114_SIO_1_OUT),a 
5e03 c5				push bc 
5e04 d5				push de 
5e05 5f				ld e, a 
5e06			; TODO Replace with CP/M BIOS call 
5e06 0e 02			ld c, $02 
5e08 cd 05 00			call 5 
5e0b d1				pop de 
5e0c c1				pop bc 
5e0d c9				ret 
5e0e			 
5e0e			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
5e0e			fLCD_Pos: 
5e0e				; use ASCII escape to position 
5e0e			        ;out (SC114_SIO_1_OUT),a 
5e0e c5				push bc 
5e0f d5				push de 
5e10 5f				ld e, a 
5e11 0e 02			ld c, $02 
5e13			; TODO Replace with CP/M BIOS call 
5e13 cd 05 00			call 5 
5e16 d1				pop de 
5e17 c1				pop bc 
5e18			 
5e18 c9				ret 
5e19			 
5e19			; output char at pos 
5e19			fLCD_Data: 
5e19			      ;  out (SC114_SIO_1_OUT),a 
5e19 c5				push bc 
5e1a d5				push de 
5e1b 0e 02			ld c, $02 
5e1d 5f				ld e, a 
5e1e			; TODO Replace with CP/M BIOS call 
5e1e cd 05 00			call 5 
5e21 d1				pop de 
5e22 c1				pop bc 
5e23			 
5e23 c9				ret 
5e24			 
5e24			; ascii cls  
5e24			 
5e24 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
5e28			 
5e28 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
5e3f			;.clscpm: db 3, $3c,"$" 
5e3f			 
5e3f			; write the frame buffer given in hl to hardware  
5e3f			write_display: 
5e3f			 
5e3f			API: equ 0 
5e3f			 
5e3f			if API 
5e3f				push bc 
5e3f				ld b, 4 
5e3f			 
5e3f			        ld (display_write_tmp), hl 	  
5e3f			 
5e3f				; clear and home cursor 
5e3f			 
5e3f				ld c, 9 
5e3f				ld de, .cls 
5e3f			; TODO Replace with CP/M BIOS call 
5e3f				call 5 
5e3f			 
5e3f			 
5e3f			.writeln: 
5e3f			 
5e3f				ld de, (display_write_tmp) 
5e3f				ld c, 6 
5e3f			; TODO Replace with CP/M BIOS call 
5e3f				rst $30 
5e3f				ld c, 7 
5e3f				rst $30 
5e3f			 
5e3f				ld hl, (display_write_tmp) 
5e3f				ld de, display_cols 
5e3f				add hl,de 
5e3f				ld (display_write_tmp),hl 
5e3f			 
5e3f				djnz  .writeln 
5e3f			 
5e3f				pop bc 
5e3f			 
5e3f			 
5e3f				ret 
5e3f			endif 
5e3f e5				push hl 
5e40 c5				push bc 
5e41 d5				push de 
5e42			 
5e42			;	ld c, 2 
5e42			;	;ld de, .cls 
5e42			;	ld a, 27 
5e42			;	rst $30 
5e42			;	ld c, 2 
5e42			;	;ld de, .cls 
5e42			;	ld a, '[' 
5e42			;	rst $30 
5e42			; 
5e42			;	ld c, 2 
5e42			;	;ld de, .cls 
5e42			;	ld a, 'H' 
5e42			;	rst $30 
5e42			; 
5e42			 
5e42			 
5e42			; lots of CR/LF 
5e42			;	ld c, 9 
5e42			;	ld de, .clscpm 
5e42			;	call 5 
5e42			 
5e42			; xterm cls 
5e42 0e 02			ld c, 2 
5e44 1e 1b			ld e, 27 
5e46 cd 05 00			call 5 
5e49			; cls causes too much flicker 
5e49			;	ld c, 2 
5e49			;	ld e, 'c' 
5e49			;	call 5 
5e49			 
5e49			; use xterm home instead 
5e49 0e 02			ld c, 2 
5e4b 1e 5b			ld e, '[' 
5e4d cd 05 00			call 5 
5e50 0e 02			ld c, 2 
5e52 1e 48			ld e, 'H' 
5e54 cd 05 00			call 5 
5e57			LLL: equ 0 
5e57			 
5e57			if LLL 
5e57			 
5e57				ld c, 2 
5e57				;ld de, .cls 
5e57				ld e, 27 
5e57			; TODO Replace with CP/M BIOS call 
5e57				call 5 
5e57			 
5e57			 
5e57				ld c, 2 
5e57				;ld de, .cls 
5e57				ld e, '[' 
5e57			; TODO Replace with CP/M BIOS call 
5e57				call 5 
5e57				ld c, 2 
5e57				;ld de, .cls 
5e57				ld e, '2' 
5e57			; TODO Replace with CP/M BIOS call 
5e57				call 5 
5e57				ld c, 2 
5e57				;ld de, .cls 
5e57				ld e, 'J' 
5e57			; TODO Replace with CP/M BIOS call 
5e57				call 5 
5e57			 
5e57			endif 
5e57			 
5e57 d1				pop de 
5e58 c1				pop bc 
5e59 e1				pop hl 
5e5a			 
5e5a			 
5e5a 22 c3 eb		        ld (display_write_tmp), hl 	  
5e5d 3e 00			ld a, kLCD_Line1 
5e5f			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5e5f 06 28			ld b, display_cols 
5e61 ed 5b c3 eb		ld de, (display_write_tmp) 
5e65 cd e8 5e			call write_len_string 
5e68				 
5e68			 
5e68 e5			push hl 
5e69 d5			push de 
5e6a c5			push bc 
5e6b 0e 02			ld c, 2 
5e6d 1e 0a			ld e, 10 
5e6f cd 05 00			call 5 
5e72 0e 02			ld c, 2 
5e74 1e 0d			ld e, 13 
5e76 cd 05 00			call 5 
5e79			; TODO Replace with CP/M BIOS call 
5e79				;rst $30 
5e79 c1			pop bc 
5e7a d1			pop de 
5e7b e1			pop hl 
5e7c			 
5e7c				 
5e7c 2a c3 eb			ld hl, (display_write_tmp) 
5e7f 11 28 00			ld de, display_cols 
5e82 19				add hl,de 
5e83 22 c3 eb			ld (display_write_tmp),hl 
5e86			 
5e86				 
5e86 3e 28			ld a, kLCD_Line2 
5e88			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5e88 06 28			ld b, display_cols 
5e8a ed 5b c3 eb		ld de, (display_write_tmp) 
5e8e cd e8 5e			call write_len_string 
5e91				 
5e91 2a c3 eb			ld hl, (display_write_tmp) 
5e94 11 28 00			ld de, display_cols 
5e97 19				add hl,de 
5e98 22 c3 eb			ld (display_write_tmp),hl 
5e9b			 
5e9b e5			push hl 
5e9c d5			push de 
5e9d c5			push bc 
5e9e 0e 07			ld c, 7 
5ea0			; TODO Replace with CP/M BIOS call 
5ea0				;rst $30 
5ea0 0e 02			ld c, 2 
5ea2 1e 0a			ld e, 10 
5ea4 cd 05 00			call 5 
5ea7 0e 02			ld c, 2 
5ea9 1e 0d			ld e, 13 
5eab cd 05 00			call 5 
5eae c1			pop bc 
5eaf d1			pop de 
5eb0 e1			pop hl 
5eb1			 
5eb1				 
5eb1 3e 50			ld a, kLCD_Line3 
5eb3			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
5eb3 06 28			ld b, display_cols 
5eb5 ed 5b c3 eb		ld de, (display_write_tmp) 
5eb9 cd e8 5e			call write_len_string 
5ebc				 
5ebc 2a c3 eb			ld hl, (display_write_tmp) 
5ebf 11 28 00			ld de, display_cols 
5ec2 19				add hl,de 
5ec3 22 c3 eb			ld (display_write_tmp),hl 
5ec6			 
5ec6 e5			push hl 
5ec7 d5			push de 
5ec8 c5			push bc 
5ec9 0e 07			ld c, 7 
5ecb			; TODO Replace with CP/M BIOS call 
5ecb				;rst $30 
5ecb 0e 02			ld c, 2 
5ecd 1e 0a			ld e, 10 
5ecf cd 05 00			call 5 
5ed2 0e 02			ld c, 2 
5ed4 1e 0d			ld e, 13 
5ed6 cd 05 00			call 5 
5ed9 c1			pop bc 
5eda d1			pop de 
5edb e1			pop hl 
5edc			 
5edc				 
5edc 3e 78			ld a, kLCD_Line4 
5ede			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
5ede 06 28			ld b, display_cols 
5ee0 ed 5b c3 eb		ld de, (display_write_tmp) 
5ee4 cd e8 5e			call write_len_string 
5ee7 c9					ret 
5ee8			 
5ee8			 
5ee8				; write out a fixed length string given in b from de 
5ee8			 
5ee8 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
5ee9 cd 19 5e		            CALL fLCD_Data      ;Write character to display 
5eec 13				inc de 
5eed 10 f9			djnz write_len_string 
5eef c9				ret 
5ef0			 
5ef0			 
5ef0			; eof 
# End of file firmware_cpm_display.asm
5ef0			;include "firmware_key_5x10.asm" 
5ef0			;;include "firmware_key_4x10.asm" 
5ef0			include "firmware_key_cpm.asm" 
5ef0			; Serial keyboard interface for SC114 
5ef0			 
5ef0			 
5ef0			key_init: 
5ef0				; no init as handled by the SCM bios 
5ef0 c9				ret 
5ef1			 
5ef1			 
5ef1			cin_wait: 
5ef1			;	ld a, 0 
5ef1			;	ret 
5ef1			 
5ef1				;in a,(SC114_SIO_1_IN) 
5ef1			        ; Use SCM API to get from whatever console device we are using 
5ef1			 
5ef1			; TODO Replace with CP/M BIOS call 
5ef1 c5				push bc 
5ef2 0e 01			ld c, $01 
5ef4 cd 05 00			call 5 
5ef7 c1				pop bc 
5ef8 c9				ret 
5ef9			 
5ef9			cin: 
5ef9			 
5ef9			 
5ef9 c5				push bc 
5efa			 
5efa				; any key waiting to process? 
5efa			; TODO Replace with CP/M BIOS call 
5efa 0e 06			ld c, $06 
5efc cd 05 00			call 5 
5eff 28 0d			jr z, .cin_skip 
5f01			 
5f01				; yep, get it 
5f01			 
5f01 0e 01			ld c, $01 
5f03			; TODO Replace with CP/M BIOS call 
5f03 cd 05 00			call 5 
5f06			 
5f06 fe 7f			cp $7f     ; back space 
5f08 20 02			jr nz, .skipbs 
5f0a 3e 08			ld a, KEY_BS 
5f0c			.skipbs: 
5f0c			 
5f0c c1				pop bc 
5f0d c9				ret 
5f0e			.cin_skip: 
5f0e 3e 00			ld a, 0 
5f10 c1				pop bc 
5f11 c9				ret 
5f12			 
5f12			 
5f12			 
5f12			 
# End of file firmware_key_cpm.asm
5f12			endofcode:  
5f12			baseram:  
5f12 00				nop 
5f13			 
5f13			heap_start: equ baseram+15  ; Starting address of heap 
5f13			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
5f13			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
5f13			;VDU:  EQU     endofcode           ; BASIC Work space 
5f13			; eof 
5f13			 
# End of file os_mega_cpm.asm
5f13
