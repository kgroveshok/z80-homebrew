# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 59 18			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 ..			buildtime: db   "Build: " 
010a					include "romtimestamp.asm" 
010a ..			db '2025-08-06 12:30' 
# End of file romtimestamp.asm
011a 00				   db 0 
011b			 
011b			 
011b			 
011b			;        nop  
011b			;        nop 
011b			;;	org 05h		; null out bdos call 
011b			; 
011b			;        nop  
011b			;        nop  
011b			;        nop 
011b			;;	org 08h 
011b			;;; 
011b			;;	jp cin		; rst 8 - char in 
011b			;;; 
011b			; 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;	org 010h 
011b			;; 
011b			;	jp cout		; rest 010h  - char out 
011b			;; 
011b			;	org 01bh   
011b			; 
011b			;	;jp  		; rst 01bh   - write string to display 
011b			;	jp str_at_display 
011b			; 
011b			; 
011b			;	org 020h 
011b			; 
011b			;	; jp		 ; rst 020h - read char at screen location 
011b			; 
011b			;	org 028h 
011b			 
011b				; jp		 ; rst 028h  - storage i/o 
011b			 
011b			; 	org 030h 
011b			;	jp break_point_state 
011b			  
011b			; $30  
011b			; org 038h 
011b			; $38 
011b			 
011b			; TODO any more important entry points to add to jump table for easier coding use? 
011b			 
011b			if BASE_KEV = 1  
011b			 
011b				; need to be at $66 for nmi support 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255 
011b				jp nmi 
011b			endif 
011b			 
011b			include "firmware.asm" 
011b			  
011b			; main constants (used here and in firmware)  
011b			  
011b			; TODO have page 0 of storage as bios  
011b			  
011b			Device_A: equ 0h  
011b			Device_B: equ 040h          ; Sound  
011b			  
011b			if BASE_KEV  
011b			Device_C: equ 080h          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			if BASE_SC114  
011b			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			if BASE_CPM  
011b			; TODO fixup for CPM  
011b			Device_C: equ 080h          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			Device_D: equ 0c0h             ; Keyboard and LCD  
011b			  
011b			; Odd specific debug points for testing hardware dev  
011b			  
011b			DEBUG_SOUND: equ 0       
011b			DEBUG_STK_FAULT: equ 0  
011b			DEBUG_INPUT: equ 0     ; Debug input entry code  
011b			DEBUG_KEYCINWAIT: equ 0  
011b			DEBUG_KEYCIN: equ 0  
011b			DEBUG_KEY: equ 0  
011b			DEBUG_KEY_MATRIX: equ 0  
011b			DEBUG_STORECF: equ 0  
011b			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011b			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011b			DEBUG_SPI: equ 0    ; low level spi tests  
011b			  
011b			; Enable many break points  
011b			  
011b			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011b			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011b			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011b			DEBUG_FORTH_JP: equ 0    ; 4  
011b			DEBUG_FORTH_MALLOC: equ 0  
011b			DEBUG_FORTH_MALLOC_INT: equ 0  
011b			DEBUG_FORTH_DOT: equ 1  
011b			DEBUG_FORTH_DOT_WAIT: equ 0  
011b			DEBUG_FORTH_MATHS: equ 0  
011b			DEBUG_FORTH_TOK: equ 0    ; 4  
011b			DEBUG_FORTH_PARSE: equ 0    ; 3  
011b			DEBUG_FORTH: equ 0  ;2  
011b			DEBUG_FORTH_WORDS: equ 1   ; 1  
011b			DEBUG_FORTH_PUSH: equ 1   ; 1  
011b			DEBUG_FORTH_UWORD: equ 1   ; 1  
011b			  
011b			; Enable key point breakpoints  
011b			  
011b			DEBUG_FORTH_DOT_KEY: equ 0  
011b			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011b			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011b			  
011b			; Debug stack imbalances  
011b			  
011b			ON: equ 1  
011b			OFF: equ 0  
011b			  
011b			DEBUG_STACK_IMB: equ 0  
011b			STACK_IMB_STORE: equ 20  
011b			  
011b			; House keeping and protections  
011b			  
011b			DEBUG_FORTH_STACK_GUARD: equ 1  
011b			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011b			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011b			FORTH_ENABLE_FREE: equ 0  
011b			FORTH_ENABLE_MALLOCFREE: equ 1  
011b			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011b			FORTH_ENABLE_FLOATMATH: equ 0  
011b			  
011b			  
011b			CALLMONITOR: macro  
011b			;	call break_point_state  
011b			; now use the break point debug vector  
011b				call debug_vector  
011b				endm  
011b			  
011b			MALLOC_1: equ 1        ; from dk88   
011b			MALLOC_2: equ 0           ; broke  
011b			MALLOC_3: equ 0           ; really broke  
011b			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011b			  
011b			if BASE_KEV   
011b			stacksize: equ 256  
011b			  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 512  
011b			endif  
011b			if BASE_SC114  
011b			;tos:	equ 0f000h  
011b			stacksize: equ 256  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 256  
011b			endif  
011b			  
011b			if BASE_CPM  
011b			;tos:	equ 0f000h  
011b			stacksize: equ 256  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 256  
011b			endif  
011b			  
011b			;if STORAGE_SE == 0  
011b			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011b			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011b			;endif  
011b			  
011b			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011b			  
011b			STORE_0_AUTORUN: equ $20  
011b			  
011b			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011b			  
011b			STORE_0_AUTOFILE: equ $21  
011b			STORE_0_BANKRUN: equ $23  
011b			STORE_0_FILERUN: equ $24  
011b			  
011b			; Block 0 offsets for settings  
011b			  
011b			; if set then skip prompt for start up and accept all  
011b			  
011b			STORE_0_QUICKSTART: equ $25  
011b			  
011b			; Blocks where directory table is held  
011b			  
011b			; Reducing the number of entries increases the max file size  
011b			  
011b			;STORE_DIR_START: equ 1  
011b			;STORE_DIR_END: equ 33  
011b			  
011b			; Blocks from where file data is stored  
011b			  
011b			;STORE_DATA_START: equ STORE_DIR_END + 1  
011b			  
011b			; Block indicators (<32 are data files)  
011b			  
011b			;STORE_BLOCK_CFG: equ $8f       ; config block  
011b			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011b			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011b			;STORE_BLOCK_FREE: equ $85       ; data block free  
011b			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011b			  
011b			  
011b			  
011b			; Directory entry flags  
011b			  
011b			;STORE_DIR_FREE: equ 0  
011b			;STORE_DIR_FILE:  equ 1  
011b			  
011b			; Structure offsets to directory entries  
011b			;STORE_DE_FLAG: equ 0  
011b			;STORE_DE_MAXEXT: equ 1  
011b			;STORE_DE_FILENAME: equ 2  
011b			  
011b			; Structure offsets to block 0  
011b			  
011b			;STORE_BK0_ISFOR: equ 1  
011b			;STORE_BK0_LABEL: equ 3  
011b			  
011b			; memory allocation   
011b			  
011b			chk_stund: equ tos+2           ; underflow check word  
011b			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011b			  
011b			; keyscan table needs rows x cols buffer  
011b			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011b			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011b			  
011b			keyscan_table_row1: equ chk_stovr -key_cols-1  
011b			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011b			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011b			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011b			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011b			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011b			keyscan_scancol: equ keyscan_table-key_cols  
011b			;keyscan_table_len: equ key_rows*key_cols  
011b			;keybufptr: equ keyscan_table - 2  
011b			;keysymbol: equ keybufptr - 1  
011b			key_held: equ keyscan_scancol-1	; currently held  
011b			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011b			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011b			key_fa: equ key_repeat_ct -1 ;  
011b			key_fb: equ key_fa -1 ;  
011b			key_fc: equ key_fb -1 ;  
011b			key_fd: equ key_fc -1 ;  
011b			key_face_held: equ key_fd - 1   
011b			  
011b			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011b			  
011b			hardware_config: equ key_face_held - 10  
011b			  
011b			; hardware config switches  
011b			; TODO add bitmasks on includes for hardware  
011b			; high byte for expansion ids  
011b			;     0000 0000  no card inserted  
011b			;     0000 0001  storage card inserted  
011b			;     0000 0010  spi sd card active  
011b			  
011b			;       
011b			; low byte:  
011b			;     0000 0001   4x4 keypad  
011b			;     0000 0010   full keyboard  
011b			;     0000 0011   spi/ext keyboard  
011b			;     0000 0100   20x4 lcd  
011b			;     0000 1000   40x4 lcd  
011b			;     0000 1100   spi/ext display  
011b			;     0001 0000   ide interface available  
011b			  
011b			hardware_word: equ hardware_config - 2  
011b			  
011b			; debug marker - optional display of debug point on the debug screens  
011b			  
011b			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011b			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011b			  
011b			debug_mark: equ debug_vector - 4  
011b			  
011b			; input_str vars  
011b			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011b			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011b			input_size: equ input_start -1  ; number of chars  
011b			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011b			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011b			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011b			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011b			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011b			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011b			input_len: equ input_cur_onoff - 5 ; length of current input  
011b			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011b			  
011b			CUR_BLINK_RATE: equ 15  
011b			  
011b			key_actual_pressed: equ input_cursor - 1   
011b			key_symbol: equ key_actual_pressed - 1   
011b			key_shift: equ key_symbol - 1   
011b			  
011b			; Display allocation  
011b			  
011b			;display_rows: equ 4     ; move out to mini and mega files  
011b			;display_cols: equ 20  
011b			  
011b			display_fb_len: equ display_rows*display_cols  
011b			  
011b			; primary frame buffer     
011b			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011b			; working frame buffers  
011b			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011b			display_fb3: equ  display_fb1-display_fb_len - 1  
011b			display_fb2: equ  display_fb3-display_fb_len - 1  
011b			;  
011b			; pointer to active frame buffer  
011b			display_fb_active: equ display_fb2 - 2  
011b			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011b			display_write_tmp: equ display_lcde1e2 - 2  
011b			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011b			  
011b			;  
011b			  
011b			;; can load into de directory  
011b			cursor_col: equ display_active-1  
011b			cursor_row: equ cursor_col-1  
011b			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011b			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011b			  
011b			; maths vars  
011b			  
011b			LFSRSeed: equ cursor_shape -20   
011b			randData: equ LFSRSeed - 2  
011b			xrandc: equ randData - 2  
011b			stackstore: equ xrandc - 2  
011b			seed1: equ  stackstore -2   
011b			seed2: equ seed1 - 2  
011b			  
011b			; cf storage vars  
011b			  
011b			iErrorNum:  equ seed2-1         ;Error number  
011b			iErrorReg:  equ iErrorNum -1              ;Error register  
011b			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011b			  
011b			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011b			  
011b			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011b			  
011b			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011b			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011b			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011b			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011b			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011b			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011b			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011b			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011b			store_tmpid: equ store_tmp3 - 1		; page temp id  
011b			store_tmpext: equ store_tmpid - 1		; file extent temp  
011b			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011b			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011b			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011b			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011b			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011b			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011b			;  
011b			; spi vars  
011b			  
011b			  
011b			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011b			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011b			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011b			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011b			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011b			spi_device_id: equ spi_device - 1    ; human readable bank number  
011b			  
011b			;;;;; forth cli params  
011b			  
011b			; TODO use a different frame buffer for forth???  
011b			  
011b			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011b			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011b			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011b			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011b			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011b			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011b			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011b			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011b			  
011b			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011b			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011b			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011b			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011b			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011b			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011b			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011b			  
011b			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011b			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011b			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011b			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011b			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011b			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011b			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011b			  
011b			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011b			  
011b			; os/forth token vars  
011b			  
011b			os_last_cmd: equ os_var_array-255  
011b			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011b			os_current_i: equ os_cli_cmd-2  
011b			os_cur_ptr: equ os_current_i-2  
011b			os_word_scratch: equ os_cur_ptr-30  
011b			os_tok_len: equ os_word_scratch - 2  
011b			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011b			os_tok_malloc: equ os_tok_ptr - 2  
011b			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011b			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011b			execscratch: equ os_input-255        ; exec cmd eval buffer  
011b			scratch: equ execscratch-255  
011b			  
011b			os_stack_1: equ scratch - 3       ; stack holding area 1  
011b			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
011b			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
011b			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
011b			  
011b			  
011b			; temp locations for new word processing to save on adding more   
011b			  
011b			os_new_malloc: equ os_stack_4-2  
011b			os_new_parse_len: equ os_new_malloc - 2  
011b			os_new_word_len: equ os_new_parse_len - 2  
011b			os_new_work_ptr: equ os_new_word_len - 2  
011b			os_new_src_ptr: equ os_new_work_ptr - 2  
011b			os_new_exec: equ os_new_src_ptr - 2  
011b			os_new_exec_ptr: equ os_new_exec - 2  
011b			  
011b			; resume memory alloocations....  
011b			  
011b			;os_view_disable: equ os_new_exec_ptr - 1  
011b			os_view_af: equ os_new_exec_ptr - 2  
011b			os_view_hl: equ os_view_af -2  
011b			os_view_de: equ os_view_hl - 2  
011b			os_view_bc: equ os_view_de - 2  
011b			  
011b			; stack checksum word  
011b			if DEBUG_STACK_IMB  
011b				curframe: equ  os_view_de - 5  
011b				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011b				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011b			else  
011b				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011b			endif  
011b			  
011b			; with data stack could see memory filled with junk. need some memory management   
011b			; malloc and free entry points added  
011b			  
011b			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011b			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011b			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			;heap_end: equ free_list-1  ; Starting address of heap  
011b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			  
011b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			heap_end: equ chk_word-1  ; Starting address of heap  
011b			  
011b			  
011b			;if BASE_KEV   
011b			;heap_start: equ 0800eh  ; Starting address of heap  
011b			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011b			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011b			;endif  
011b			  
011b			;if BASE_SC114  
011b			;heap_start: equ baseram+15  ; Starting address of heap  
011b			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011b			;endif  
011b			  
011b			  
011b			;;;;  
011b			  
011b			  
011b			; change below to point to last memory alloc above  
011b			topusermem:  equ   heap_start  
011b			  
011b			;if BASE_KEV   
011b			;baseusermem: equ 08000h  
011b			;endif  
011b			  
011b			;if BASE_SC114  
011b			;;aseusermem:     equ    12  
011b			;baseusermem:     equ    prompt  
011b			;;baseusermem:     equ    endofcode  
011b			;endif  
011b			  
011b			  
011b			; **********************************************************************  
011b			; **  Constants  
011b			; **********************************************************************  
011b			  
011b			; Constants used by this code module  
011b			kDataReg:   EQU Device_D           ;PIO port A data register  
011b			kContReg:   EQU Device_D+2           ;PIO port A control register  
011b			  
011b			  
011b			portbdata:  equ Device_D+1    ; port b data  
011b			portbctl:   equ Device_D+3    ; port b control  
011b			  
011b			  
011b			;KEY_SHIFT:   equ 5  
011b			;KEY_SYMBOLSHIFT:  equ 6  
011b			  
011b			KEY_SHIFTLOCK: equ 4  
011b			  
011b			  
011b			KEY_UP: equ 5  
011b			KEY_NEXTWORD: equ 6  
011b			KEY_PREVWORD: equ 7  
011b			KEY_BS: equ 8  
011b			KEY_TAB:  equ 9  
011b			KEY_DOWN: equ 10  
011b			KEY_LEFT: equ 11  
011b			KEY_RIGHT: equ 12  
011b			KEY_CR:   equ 13  
011b			KEY_HOME: equ 14  
011b			KEY_END: equ 15  
011b			  
011b			KEY_F1: equ 16  
011b			KEY_F2: equ 17  
011b			KEY_F3: equ 18  
011b			KEY_F4: equ 19  
011b			  
011b			KEY_F5: equ 20  
011b			KEY_F6: equ 21  
011b			KEY_F7: equ 22  
011b			KEY_F8: equ 23  
011b			  
011b			KEY_F9: equ 24  
011b			KEY_F10: equ 25  
011b			KEY_F11: equ 26  
011b			KEY_F12: equ 27  
011b			  
011b			;if DEBUG_KEY  
011b			;	KEY_MATRIX_NO_PRESS: equ '.'  
011b			;	KEY_SHIFT:   equ '.'  
011b			;	KEY_SYMBOLSHIFT:  equ '.'  
011b			;else  
011b				KEY_SHIFT:   equ '~'  
011b				KEY_SYMBOLSHIFT:  equ '~'  
011b				KEY_MATRIX_NO_PRESS: equ '~'  
011b			;endi  
011b			  
011b			  
011b			  
011b			  
011b			; Macro to make adding debug marks easier  
011b			  
011b			DMARK: macro str  
011b				push af  
011b				ld a, (.dmark)  
011b				ld (debug_mark),a  
011b				ld a, (.dmark+1)  
011b				ld (debug_mark+1),a  
011b				ld a, (.dmark+2)  
011b				ld (debug_mark+2),a  
011b				jr .pastdmark  
011b			.dmark: db str  
011b			.pastdmark: pop af  
011b			  
011b			endm  
011b			  
011b			  
011b			; macro to detect for stack imbalances  
011b			  
011b			include "stackimbal.asm"  
011b			; Macro and code to detect stock imbalances 
011b			 
011b			SPPUSH: equ 0 
011b			 
011b			; Add a stack frame which can be checked before return 
011b			 
011b			STACKFRAME: macro onoff frame1 frame2 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						; save current SP 
011b						exx 
011b			 
011b						ld de, frame1 
011b						ld a, d 
011b						ld hl, curframe 
011b						call hexout 
011b						ld a, e 
011b						ld hl, curframe+2 
011b						call hexout 
011b			  
011b						ld hl, frame1 
011b						push hl 
011b						ld hl, frame2 
011b						push hl 
011b						exx 
011b					endif 
011b					 
011b				endif 
011b			endm 
011b			 
011b			STACKFRAMECHK: macro onoff frame1 frame2 
011b			 
011b					 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						exx 
011b						; check stack frame SP 
011b			 
011b						ld hl, frame2 
011b						pop de   ; frame2 
011b			 
011b						call cmp16 
011b						jr nz, .spnosame 
011b						 
011b			 
011b						ld hl, frame1 
011b						pop de   ; frame1 
011b			 
011b						call cmp16 
011b						jr z, .spfrsame 
011b			 
011b						.spnosame: call showsperror 
011b			 
011b						.spfrsame: nop 
011b			 
011b						exx 
011b					endif 
011b					 
011b				endif 
011b			 
011b			 
011b			endm 
011b			 
011b			 
011b			; for a sub routine, wrap SP collection and comparisons 
011b			 
011b			; Usage: 
011b			; 
011b			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011b			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011b			 
011b			SAVESP: macro onoff storeword 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						; save current SP 
011b			 
011b						ld (store_sp+(storeword*4)), sp 
011b			 
011b					endif 
011b					 
011b				endif 
011b			 
011b			endm 
011b			 
011b			CHECKSP: macro onoff storeword 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b			 
011b						; save SP after last save 
011b				 
011b						ld (store_sp+(storeword*4)+2), sp 
011b			 
011b						push hl 
011b						ld hl, store_sp+(storeword*4) 
011b						call check_stack_sp  
011b						pop hl 
011b			 
011b			 
011b					endif 
011b					 
011b				endif 
011b			 
011b			endm 
011b			 
011b			if DEBUG_STACK_IMB 
011b			 
011b			check_stack_sp: 
011b					push de 
011b			 
011b					ld e, (hl) 
011b					inc hl 
011b					ld d, (hl) 
011b					inc hl 
011b			 
011b					push de 
011b			 
011b			 
011b					ld e, (hl) 
011b					inc hl 
011b					ld d, (hl) 
011b					inc hl 
011b			 
011b					pop hl 
011b			 
011b			 
011b					; check to see if the same 
011b			 
011b					call cmp16 
011b					jr z, .spsame 
011b			 
011b					; not same 
011b			 
011b					call showsperror 
011b			.spsame: 
011b			 
011b					pop de 
011b			 
011b					ret 
011b			 
011b			.sperr:  db "Stack imbalance",0 
011b			 
011b			 
011b			showsperror: 
011b			 
011b			 
011b				push hl 
011b				push af 
011b				push de 
011b				call clear_display 
011b				ld de, .sperr 
011b				ld a,0 
011b			;	ld de,os_word_scratch 
011b				call str_at_display 
011b				ld a, display_row_1+17 
011b				ld de, debug_mark 
011b				call str_at_display 
011b				ld a, 0 
011b				ld (curframe+4),a 
011b				ld hl, curframe 
011b				ld de, os_word_scratch 
011b				ld a, display_row_4 
011b				call str_at_display 
011b				call update_display 
011b				;call break_point_state 
011b				call cin_wait 
011b			 
011b			;	ld a, ' ' 
011b			;	ld (os_view_disable), a 
011b				call bp_on 
011b				pop de	 
011b				pop af 
011b				pop hl 
011b				CALLMONITOR 
011b				ret 
011b			 
011b			endif 
011b			 
011b			 
011b			 
011b			; eof 
# End of file stackimbal.asm
011b			  
011b			;TODO macro to calc col and row offset into screen  
011b			  
011b			  
011b			  
011b			hardware_init:  
011b			  
011b				  
011b			  
011b					;ld a, 0  
011b					;ld (hardware_diag), a  
011b			  
011b					; clear all the buffers  
011b			  
011b 21 10 ed				ld hl, display_fb1  
011e 22 cc eb				ld (display_fb_active), hl  
0121			  
0121 cd b9 0b				call clear_display  
0124			  
0124 21 ce eb				ld hl, display_fb2  
0127 22 cc eb				ld (display_fb_active), hl  
012a			  
012a cd b9 0b				call clear_display  
012d			  
012d					; init primary frame buffer area  
012d 21 b1 ed				ld hl, display_fb0  
0130 22 cc eb				ld (display_fb_active), hl  
0133			  
0133 cd b9 0b				call clear_display  
0136			  
0136			  
0136 cd c4 64				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0139			  
0139 cd b2 65			call key_init  
013c cd 9e 01			call storage_init  
013f			  
013f				; setup malloc functions  
013f			  
013f				if MALLOC_1  
013f cd 89 12				call  heap_init  
0142				endif  
0142				if MALLOC_4  
0142					call  heap_init  
0142				endif  
0142			  
0142				; init sound hardware if present  
0142			  
0142				if SOUND_ENABLE  
0142					call sound_init  
0142				endif  
0142			  
0142				; lcd test sequence  
0142					  
0142 cd dc 0b			call update_display  
0145 cd f1 0a			call delay1s  
0148 3e 2b			ld a,'+'  
014a cd be 0b			call fill_display  
014d cd dc 0b			call update_display  
0150 cd f1 0a			call delay1s  
0153 3e 2a			ld a,'*'  
0155 cd be 0b			call fill_display  
0158 cd dc 0b			call update_display  
015b cd f1 0a			call delay1s  
015e 3e 2d			ld a,'-'  
0160 cd be 0b			call fill_display  
0163 cd dc 0b			call update_display  
0166 cd f1 0a			call delay1s  
0169			  
0169			; boot splash screen  
0169			if display_cols == 20	  
0169			        ld a, display_row_1    
0169			else  
0169 3e 0a		        ld a, display_row_1 +10   
016b			endif  
016b 11 b7 17			ld de, prom_bootmsg  
016e cd cc 0b			call str_at_display  
0171 cd dc 0b			call update_display  
0174			  
0174			  
0174 cd f1 0a			call delay1s  
0177 cd f1 0a			call delay1s  
017a			if display_cols == 20	  
017a			            LD   A, display_row_3+2  
017a			else  
017a 3e 5c		            LD   A, display_row_3+12  
017c			endif  
017c 11 cc 17			ld de, prom_bootmsg1  
017f cd cc 0b			call str_at_display  
0182 cd dc 0b			call update_display  
0185 cd f1 0a			call delay1s  
0188 cd f1 0a			call delay1s  
018b			  
018b			;	ld a, display_row_4+3  
018b			;	ld de, bootmsg2  
018b			;	call str_at_display  
018b			;	call update_display  
018b			;	call delay1s  
018b			;	call delay1s  
018b			  
018b			; debug mark setup  
018b			  
018b 3e 5f		ld a, '_'  
018d 32 6b ee		ld (debug_mark),a  
0190 32 6c ee		ld (debug_mark+1),a  
0193 32 6d ee		ld (debug_mark+2),a  
0196 3e 00		ld a,0  
0198 32 6e ee		ld (debug_mark+3),a  
019b			  
019b c9					ret  
019c			  
019c			  
019c			;bootmsg2:	db "Firmware v0.1",0  
019c			  
019c			; a 4x20 lcd  
019c			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019c			  
019c			;if display_cols == 20  
019c			;	include "firmware_lcd_4x20.asm"  
019c			;endif  
019c			  
019c			;if display_cols == 40  
019c			;	include "firmware_lcd_4x40.asm"  
019c			;endif  
019c			  
019c			;  
019c			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019c			; TODO abstract the bit bang video out interface for dual display  
019c			; TODO wire video out to tx pin on rc2014 bus  
019c			  
019c			; must supply cin, and cin_wait for low level hardware abstraction   
019c			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019c			; test scancode  
019c			  
019c			;;;;;  
019c			;;;  
019c			; Moved out to mini and maxi versions  
019c			;  
019c			; include "firmware_key_4x4.asm"  
019c			; using existing 4 wire x 4 resistor array for input  
019c			;include "firmware_key_4x10.asm"  
019c			; need to mod the board for 5 rows due to resistor array  
019c			;include "firmware_key_5x10.asm"  
019c			  
019c			; storage hardware interface  
019c			  
019c			; use microchip serial eeprom for storage  
019c			  
019c			  
019c			if STORAGE_SE  
019c				include "firmware_spi.asm"  
019c				include "firmware_seeprom.asm"  
019c			else  
019c			   ; create some stubs for the labels  
019c c9			se_readbyte: ret  
019d c9			se_writebyte: ret  
019e c9			storage_init: ret  
019f			  
019f			endif  
019f			  
019f			; use cf card for storage - throwing timeout errors. Hardware or software?????  
019f			;include "firmware_cf.asm"  
019f			  
019f			; load up high level storage hardward abstractions  
019f			include "firmware_storage.asm"  
019f			 
019f			; persisent storage hardware abstraction layer  
019f			 
019f			 
019f			 
019f			; Block 0 on storage is a config state 
019f			 
019f			 
019f			 
019f			; TODO add read phy block and write phy block functions 
019f			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
019f			 
019f			; Abstraction layer  
019f			 
019f			; Logocial block size is same size as physical size - using tape concept 
019f			 
019f			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
019f			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
019f			 
019f			 
019f			 
019f			; Filesystem layout (Logical layout) 
019f			; 
019f			; Block 0 - Bank config  
019f			; 
019f			;      Byte - 0 file id counter 
019f			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
019f			;      Byte - 3-20 zero terminated bank label 
019f			; 
019f			; Block 1 > File storage 
019f			; 
019f			;      Byte 0 file id    - block 0 file details 
019f			;      Byte 1 block id - block 0 is file  
019f			;            Byte 2-15 - File name 
019f			; 
019f			;       - to end of block data 
019f			; 
019f			 
019f			; Get ID for the file named in pointer held HL 
019f			; Returns ID in HL = 255 if no file found 
019f			 
019f			storage_getid: 
019f			 
019f 22 73 ea			ld (store_tmp1), hl 
01a2			 
01a2				if DEBUG_STORESE 
01a2					DMARK "SGI" 
01a2 f5				push af  
01a3 3a b7 01			ld a, (.dmark)  
01a6 32 6b ee			ld (debug_mark),a  
01a9 3a b8 01			ld a, (.dmark+1)  
01ac 32 6c ee			ld (debug_mark+1),a  
01af 3a b9 01			ld a, (.dmark+2)  
01b2 32 6d ee			ld (debug_mark+2),a  
01b5 18 03			jr .pastdmark  
01b7 ..			.dmark: db "SGI"  
01ba f1			.pastdmark: pop af  
01bb			endm  
# End of macro DMARK
01bb					CALLMONITOR 
01bb cd 6f ee			call debug_vector  
01be				endm  
# End of macro CALLMONITOR
01be				endif 
01be				; get block 0 and set counter for number of files to scan 
01be			 
01be cd 29 03			call storage_get_block_0 
01c1			 
01c1 3a 7a ea			ld a, (store_page) 
01c4 47				ld b, a 
01c5			 
01c5				; get extent 0 of each file id 
01c5			 
01c5				if DEBUG_STORESE 
01c5					DMARK "SGc" 
01c5 f5				push af  
01c6 3a da 01			ld a, (.dmark)  
01c9 32 6b ee			ld (debug_mark),a  
01cc 3a db 01			ld a, (.dmark+1)  
01cf 32 6c ee			ld (debug_mark+1),a  
01d2 3a dc 01			ld a, (.dmark+2)  
01d5 32 6d ee			ld (debug_mark+2),a  
01d8 18 03			jr .pastdmark  
01da ..			.dmark: db "SGc"  
01dd f1			.pastdmark: pop af  
01de			endm  
# End of macro DMARK
01de					CALLMONITOR 
01de cd 6f ee			call debug_vector  
01e1				endm  
# End of macro CALLMONITOR
01e1				endif 
01e1 60			.getloop:	ld h, b 
01e2 2e 00				ld l, 0 
01e4 c5					push bc 
01e5			 
01e5 11 7a ea				ld de, store_page 
01e8				if DEBUG_STORESE 
01e8					DMARK "SGr" 
01e8 f5				push af  
01e9 3a fd 01			ld a, (.dmark)  
01ec 32 6b ee			ld (debug_mark),a  
01ef 3a fe 01			ld a, (.dmark+1)  
01f2 32 6c ee			ld (debug_mark+1),a  
01f5 3a ff 01			ld a, (.dmark+2)  
01f8 32 6d ee			ld (debug_mark+2),a  
01fb 18 03			jr .pastdmark  
01fd ..			.dmark: db "SGr"  
0200 f1			.pastdmark: pop af  
0201			endm  
# End of macro DMARK
0201					CALLMONITOR 
0201 cd 6f ee			call debug_vector  
0204				endm  
# End of macro CALLMONITOR
0204				endif 
0204 cd d1 07				call storage_read 
0207 cd 0f 0e				call ishlzero 
020a 28 2d				jr z, .gap 
020c					 
020c					; have a file name read. Is it one we want. 
020c			 
020c 2a 73 ea				ld hl, (store_tmp1) 
020f 11 7d ea				ld de, store_page+3   ; file name 
0212			 
0212				if DEBUG_STORESE 
0212					DMARK "SGc" 
0212 f5				push af  
0213 3a 27 02			ld a, (.dmark)  
0216 32 6b ee			ld (debug_mark),a  
0219 3a 28 02			ld a, (.dmark+1)  
021c 32 6c ee			ld (debug_mark+1),a  
021f 3a 29 02			ld a, (.dmark+2)  
0222 32 6d ee			ld (debug_mark+2),a  
0225 18 03			jr .pastdmark  
0227 ..			.dmark: db "SGc"  
022a f1			.pastdmark: pop af  
022b			endm  
# End of macro DMARK
022b					CALLMONITOR 
022b cd 6f ee			call debug_vector  
022e				endm  
# End of macro CALLMONITOR
022e				endif 
022e cd 7c 12				call strcmp 
0231 20 06				jr nz, .gap   ; not this one 
0233			 
0233 c1				        pop bc 
0234			 
0234 26 00				ld h, 0 
0236 68					ld l, b 
0237 18 22				jr .getdone 
0239						 
0239			 
0239			 
0239			 
0239			.gap: 
0239				if DEBUG_STORESE 
0239					DMARK "SGg" 
0239 f5				push af  
023a 3a 4e 02			ld a, (.dmark)  
023d 32 6b ee			ld (debug_mark),a  
0240 3a 4f 02			ld a, (.dmark+1)  
0243 32 6c ee			ld (debug_mark+1),a  
0246 3a 50 02			ld a, (.dmark+2)  
0249 32 6d ee			ld (debug_mark+2),a  
024c 18 03			jr .pastdmark  
024e ..			.dmark: db "SGg"  
0251 f1			.pastdmark: pop af  
0252			endm  
# End of macro DMARK
0252					CALLMONITOR 
0252 cd 6f ee			call debug_vector  
0255				endm  
# End of macro CALLMONITOR
0255				endif 
0255			 
0255 c1					pop bc 
0256 10 89				djnz .getloop 
0258 21 ff 00				ld hl, 255 
025b			.getdone: 
025b			 
025b				if DEBUG_STORESE 
025b					DMARK "SGe" 
025b f5				push af  
025c 3a 70 02			ld a, (.dmark)  
025f 32 6b ee			ld (debug_mark),a  
0262 3a 71 02			ld a, (.dmark+1)  
0265 32 6c ee			ld (debug_mark+1),a  
0268 3a 72 02			ld a, (.dmark+2)  
026b 32 6d ee			ld (debug_mark+2),a  
026e 18 03			jr .pastdmark  
0270 ..			.dmark: db "SGe"  
0273 f1			.pastdmark: pop af  
0274			endm  
# End of macro DMARK
0274					CALLMONITOR 
0274 cd 6f ee			call debug_vector  
0277				endm  
# End of macro CALLMONITOR
0277				endif 
0277			 
0277 c9				ret 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			; Read Block 
0278			; ---------- 
0278			; 
0278			; With current bank 
0278			;  
0278			; Get block number to read 
0278			; Load physical blocks starting at start block into buffer 
0278			 
0278			; de points to buffer to use 
0278			; hl holds logical block number  
0278			 
0278			storage_read_block: 
0278			 
0278				; TODO bank selection 
0278			 
0278				; for each of the physical blocks read it into the buffer 
0278 06 40			ld b, STORE_BLOCK_PHY 
027a			 
027a				if DEBUG_STORESE 
027a d5					push de 
027b				endif 
027b				 
027b			.rl1:    
027b			 
027b				; read physical block at hl into de 
027b			        ; increment hl and de to next read position on exit 
027b			 
027b e5				push hl 
027c d5				push de	 
027d c5				push bc 
027e			;	if DEBUG_STORESE 
027e			;		push af 
027e			;		ld a, 'R' 
027e			;		ld (debug_mark),a 
027e			;		pop af 
027e			;		CALLMONITOR 
027e			;	endif 
027e cd 9c 01			call se_readbyte 
0281			;	if DEBUG_STORESE 
0281			;		ld a,(spi_portbyte) 
0281			;		ld l, a 
0281			;		push af 
0281			;		ld a, '1' 
0281			;		ld (debug_mark),a 
0281			;		pop af 
0281			;		CALLMONITOR 
0281			;	endif 
0281 c1				pop bc 
0282 d1				pop de 
0283 e1				pop hl 
0284 12				ld (de),a 
0285 23				inc hl 
0286 13				inc de 
0287			 
0287			;	if DEBUG_STORESE 
0287			;		push af 
0287			;		ld a, 'r' 
0287			;		ld (debug_mark),a 
0287			;		pop af 
0287			;		CALLMONITOR 
0287			;	endif 
0287			 
0287 10 f2			djnz .rl1 
0289			 
0289				if DEBUG_STORESE 
0289					DMARK "SRB" 
0289 f5				push af  
028a 3a 9e 02			ld a, (.dmark)  
028d 32 6b ee			ld (debug_mark),a  
0290 3a 9f 02			ld a, (.dmark+1)  
0293 32 6c ee			ld (debug_mark+1),a  
0296 3a a0 02			ld a, (.dmark+2)  
0299 32 6d ee			ld (debug_mark+2),a  
029c 18 03			jr .pastdmark  
029e ..			.dmark: db "SRB"  
02a1 f1			.pastdmark: pop af  
02a2			endm  
# End of macro DMARK
02a2 d1					pop de 
02a3			; 
02a3			;		push af 
02a3			;		ld a, 'R' 
02a3			;		ld (debug_mark),a 
02a3			;		pop af 
02a3					CALLMONITOR 
02a3 cd 6f ee			call debug_vector  
02a6				endm  
# End of macro CALLMONITOR
02a6				endif 
02a6 c9				ret	 
02a7				 
02a7			 
02a7			; File Size 
02a7			; --------- 
02a7			; 
02a7			;   hl file id 
02a7			; 
02a7			;  returns in hl the number of blocks 
02a7			 
02a7			storage_file_size: 
02a7 5d				ld e, l 
02a8 16 00			ld d, 0 
02aa 21 40 00			ld hl, STORE_BLOCK_PHY 
02ad					if DEBUG_FORTH_WORDS 
02ad						DMARK "SIZ" 
02ad f5				push af  
02ae 3a c2 02			ld a, (.dmark)  
02b1 32 6b ee			ld (debug_mark),a  
02b4 3a c3 02			ld a, (.dmark+1)  
02b7 32 6c ee			ld (debug_mark+1),a  
02ba 3a c4 02			ld a, (.dmark+2)  
02bd 32 6d ee			ld (debug_mark+2),a  
02c0 18 03			jr .pastdmark  
02c2 ..			.dmark: db "SIZ"  
02c5 f1			.pastdmark: pop af  
02c6			endm  
# End of macro DMARK
02c6						CALLMONITOR 
02c6 cd 6f ee			call debug_vector  
02c9				endm  
# End of macro CALLMONITOR
02c9					endif 
02c9 cd ab 05			call storage_findnextid 
02cc			 
02cc cd 0f 0e			call ishlzero 
02cf			;	ld a, l 
02cf			;	add h 
02cf			;	cp 0 
02cf c8				ret z			; block not found so EOF 
02d0			 
02d0 11 7a ea			ld de, store_page 
02d3 cd 78 02			call storage_read_block 
02d6			 
02d6 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
02d9 6f				ld l, a 
02da 26 00			ld h, 0 
02dc c9			 	ret 
02dd			 
02dd			 
02dd			; Write Block 
02dd			; ----------- 
02dd			; 
02dd			; With current bank 
02dd			;  
02dd			; Get block number to write 
02dd			; Write physical blocks starting at start block from buffer 
02dd			  
02dd			storage_write_block: 
02dd				; TODO bank selection 
02dd			 
02dd				; for each of the physical blocks read it into the buffer 
02dd 06 40			ld b, STORE_BLOCK_PHY 
02df			 
02df				if DEBUG_STORESE 
02df					DMARK "SWB" 
02df f5				push af  
02e0 3a f4 02			ld a, (.dmark)  
02e3 32 6b ee			ld (debug_mark),a  
02e6 3a f5 02			ld a, (.dmark+1)  
02e9 32 6c ee			ld (debug_mark+1),a  
02ec 3a f6 02			ld a, (.dmark+2)  
02ef 32 6d ee			ld (debug_mark+2),a  
02f2 18 03			jr .pastdmark  
02f4 ..			.dmark: db "SWB"  
02f7 f1			.pastdmark: pop af  
02f8			endm  
# End of macro DMARK
02f8			 
02f8					;push af 
02f8					;ld a, 'W' 
02f8					;ld (debug_mark),a 
02f8					;pop af 
02f8					CALLMONITOR 
02f8 cd 6f ee			call debug_vector  
02fb				endm  
# End of macro CALLMONITOR
02fb				endif 
02fb			 
02fb			; might not be working 
02fb			;	call se_writepage 
02fb			 
02fb			;	ret 
02fb			; 
02fb			 
02fb			 
02fb			 
02fb			.wl1:    
02fb			 
02fb				; read physical block at hl into de 
02fb			        ; increment hl and de to next read position on exit 
02fb			 
02fb e5				push hl 
02fc d5				push de	 
02fd c5				push bc 
02fe 1a				ld a,(de) 
02ff				;if DEBUG_STORESE 
02ff			;		push af 
02ff			;		ld a, 'W' 
02ff			;		ld (debug_mark),a 
02ff			;		pop af 
02ff			;		CALLMONITOR 
02ff			;	endif 
02ff cd 9d 01			call se_writebyte 
0302			;	call delay250ms 
0302 00				nop 
0303 00				nop 
0304 00				nop 
0305			;	if DEBUG_STORESE 
0305			;		push af 
0305			;		ld a, 'w' 
0305			;		ld (debug_mark),a 
0305			;		pop af 
0305			;		CALLMONITOR 
0305			;	endif 
0305 c1				pop bc 
0306 d1				pop de 
0307 e1				pop hl 
0308 23				inc hl 
0309 13				inc de 
030a			 
030a			 
030a 10 ef			djnz .wl1 
030c			 
030c				if DEBUG_STORESE 
030c					DMARK "SW2" 
030c f5				push af  
030d 3a 21 03			ld a, (.dmark)  
0310 32 6b ee			ld (debug_mark),a  
0313 3a 22 03			ld a, (.dmark+1)  
0316 32 6c ee			ld (debug_mark+1),a  
0319 3a 23 03			ld a, (.dmark+2)  
031c 32 6d ee			ld (debug_mark+2),a  
031f 18 03			jr .pastdmark  
0321 ..			.dmark: db "SW2"  
0324 f1			.pastdmark: pop af  
0325			endm  
# End of macro DMARK
0325			 
0325					;push af 
0325					;ld a, 'W' 
0325					;ld (debug_mark),a 
0325					;pop af 
0325					CALLMONITOR 
0325 cd 6f ee			call debug_vector  
0328				endm  
# End of macro CALLMONITOR
0328				endif 
0328 c9				ret	 
0329			 
0329			; Init bank 
0329			; --------- 
0329			; 
0329			; With current bank 
0329			; 
0329			; Setup block 0 config 
0329			;     Set 0 file id counter 
0329			;     Set formatted byte pattern 
0329			;     Zero out bank label 
0329			;      
0329			; For every logical block write 0-1 byte as null 
0329			 
0329			storage_get_block_0: 
0329			 
0329				; TODO check presence 
0329			 
0329				; get block 0 config 
0329			 
0329 21 00 00			ld hl, 0 
032c 11 7a ea			ld de, store_page 
032f cd 78 02			call storage_read_block 
0332			 
0332				if DEBUG_STORESE 
0332					DMARK "SB0" 
0332 f5				push af  
0333 3a 47 03			ld a, (.dmark)  
0336 32 6b ee			ld (debug_mark),a  
0339 3a 48 03			ld a, (.dmark+1)  
033c 32 6c ee			ld (debug_mark+1),a  
033f 3a 49 03			ld a, (.dmark+2)  
0342 32 6d ee			ld (debug_mark+2),a  
0345 18 03			jr .pastdmark  
0347 ..			.dmark: db "SB0"  
034a f1			.pastdmark: pop af  
034b			endm  
# End of macro DMARK
034b 11 7a ea				ld de, store_page 
034e			;		push af 
034e			;		ld a, 'i' 
034e			;		ld (debug_mark),a 
034e			;		pop af 
034e					CALLMONITOR 
034e cd 6f ee			call debug_vector  
0351				endm  
# End of macro CALLMONITOR
0351				endif 
0351			 
0351				; is this area formatted? 
0351			 
0351			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0351 2a 7b ea			ld hl, (store_page+1) 
0354 3e 80			ld a,0x80 
0356 bd				cp l 
0357 20 22			jr nz, .ininotformatted 
0359				; do a double check 
0359 3e 27			ld a, 0x27 
035b bc				cp h 
035c 20 1d			jr nz, .ininotformatted 
035e			 
035e				; formatted then 
035e			 
035e				if DEBUG_STORESE 
035e					DMARK "SB1" 
035e f5				push af  
035f 3a 73 03			ld a, (.dmark)  
0362 32 6b ee			ld (debug_mark),a  
0365 3a 74 03			ld a, (.dmark+1)  
0368 32 6c ee			ld (debug_mark+1),a  
036b 3a 75 03			ld a, (.dmark+2)  
036e 32 6d ee			ld (debug_mark+2),a  
0371 18 03			jr .pastdmark  
0373 ..			.dmark: db "SB1"  
0376 f1			.pastdmark: pop af  
0377			endm  
# End of macro DMARK
0377					;push af 
0377					;ld a, 'I' 
0377					;ld (debug_mark),a 
0377					;pop af 
0377					CALLMONITOR 
0377 cd 6f ee			call debug_vector  
037a				endm  
# End of macro CALLMONITOR
037a				endif 
037a c9				ret 
037b			 
037b			.ininotformatted: 
037b				; bank not formatted so poke various bits to make sure 
037b			 
037b				if DEBUG_STORESE 
037b					DMARK "SB2" 
037b f5				push af  
037c 3a 90 03			ld a, (.dmark)  
037f 32 6b ee			ld (debug_mark),a  
0382 3a 91 03			ld a, (.dmark+1)  
0385 32 6c ee			ld (debug_mark+1),a  
0388 3a 92 03			ld a, (.dmark+2)  
038b 32 6d ee			ld (debug_mark+2),a  
038e 18 03			jr .pastdmark  
0390 ..			.dmark: db "SB2"  
0393 f1			.pastdmark: pop af  
0394			endm  
# End of macro DMARK
0394					;push af 
0394					;ld a, 'f' 
0394					;ld (debug_mark),a 
0394					;pop af 
0394					CALLMONITOR 
0394 cd 6f ee			call debug_vector  
0397				endm  
# End of macro CALLMONITOR
0397				endif 
0397			 
0397 cd b4 0a			call storage_clear_page 
039a			 
039a 21 7a ea			ld hl, store_page 
039d 3e 00			ld a, 0 
039f				 
039f 77				ld (hl),a   ; reset file counter 
03a0			 
03a0 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a3 22 7b ea		 	ld (store_page+1), hl	 
03a6			 
03a6				; set default label 
03a6			 
03a6 21 42 04			ld hl, .defaultbanklabl 
03a9 11 7d ea		 	ld de, store_page+3 
03ac 01 0f 00			ld bc, 15 
03af ed b0			ldir 
03b1			 
03b1				; Append the current bank id 
03b1 21 86 ea			ld hl, store_page+3+9 
03b4 3a 5f ea			ld a, (spi_device_id) 
03b7 77				ld (hl), a 
03b8			 
03b8				; save default page 0 
03b8			 
03b8 21 00 00			ld hl, 0 
03bb 11 7a ea			ld de, store_page 
03be				if DEBUG_STORESE 
03be					DMARK "SB3" 
03be f5				push af  
03bf 3a d3 03			ld a, (.dmark)  
03c2 32 6b ee			ld (debug_mark),a  
03c5 3a d4 03			ld a, (.dmark+1)  
03c8 32 6c ee			ld (debug_mark+1),a  
03cb 3a d5 03			ld a, (.dmark+2)  
03ce 32 6d ee			ld (debug_mark+2),a  
03d1 18 03			jr .pastdmark  
03d3 ..			.dmark: db "SB3"  
03d6 f1			.pastdmark: pop af  
03d7			endm  
# End of macro DMARK
03d7			;		push af 
03d7			;		ld a, 'F' 
03d7			;		ld (debug_mark),a 
03d7			;		pop af 
03d7					CALLMONITOR 
03d7 cd 6f ee			call debug_vector  
03da				endm  
# End of macro CALLMONITOR
03da				endif 
03da cd dd 02			call storage_write_block 
03dd				if DEBUG_STORESE 
03dd					DMARK "SB4" 
03dd f5				push af  
03de 3a f2 03			ld a, (.dmark)  
03e1 32 6b ee			ld (debug_mark),a  
03e4 3a f3 03			ld a, (.dmark+1)  
03e7 32 6c ee			ld (debug_mark+1),a  
03ea 3a f4 03			ld a, (.dmark+2)  
03ed 32 6d ee			ld (debug_mark+2),a  
03f0 18 03			jr .pastdmark  
03f2 ..			.dmark: db "SB4"  
03f5 f1			.pastdmark: pop af  
03f6			endm  
# End of macro DMARK
03f6			;		push af 
03f6			;		ld a, '>' 
03f6			;		ld (debug_mark),a 
03f6			;		pop af 
03f6					CALLMONITOR 
03f6 cd 6f ee			call debug_vector  
03f9				endm  
# End of macro CALLMONITOR
03f9				endif 
03f9			 
03f9 00				nop 
03fa 00				nop 
03fb 00				nop 
03fc			 
03fc				; now set 0 in every page to mark as a free block 
03fc			 
03fc 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03fe 21 40 00			ld hl, STORE_BLOCK_PHY 
0401			 
0401 3e 00		.setmark1:   	ld a,0 
0403 e5					push hl 
0404 c5					push bc 
0405 cd 9d 01				call se_writebyte 
0408 3e 0a			ld a, 10 
040a cd d6 0a			call aDelayInMS 
040d 23				inc hl 
040e cd 9d 01				call se_writebyte 
0411 3e 0a			ld a, 10 
0413 cd d6 0a			call aDelayInMS 
0416 2b				dec hl 
0417 c1					pop bc 
0418 e1					pop hl 
0419 3e 40				ld a, STORE_BLOCK_PHY 
041b cd e6 0d				call addatohl 
041e 10 e1				djnz .setmark1 
0420			 
0420 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0422 3e 00		.setmark2:   	ld a,0 
0424 e5					push hl 
0425 c5					push bc 
0426 cd 9d 01				call se_writebyte 
0429 3e 0a			ld a, 10 
042b cd d6 0a			call aDelayInMS 
042e 23				inc hl 
042f cd 9d 01				call se_writebyte 
0432 3e 0a			ld a, 10 
0434 cd d6 0a			call aDelayInMS 
0437 2b				dec hl 
0438 c1					pop bc 
0439 e1					pop hl 
043a 3e 40				ld a, STORE_BLOCK_PHY 
043c cd e6 0d				call addatohl 
043f 10 e1				djnz .setmark2 
0441			 
0441					 
0441			 
0441			 
0441 c9				ret 
0442			 
0442			 
0442			 
0442			 
0442 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044d			 
044d			 
044d			 
044d			; Label Bank 
044d			; ---------- 
044d			; 
044d			; With current bank 
044d			; Read block 0 
044d			; Set label 
044d			; Write block 0 
044d			 
044d			; label str pointer in hl 
044d			 
044d			storage_label:     
044d			 
044d				if DEBUG_STORESE 
044d					DMARK "LBL" 
044d f5				push af  
044e 3a 62 04			ld a, (.dmark)  
0451 32 6b ee			ld (debug_mark),a  
0454 3a 63 04			ld a, (.dmark+1)  
0457 32 6c ee			ld (debug_mark+1),a  
045a 3a 64 04			ld a, (.dmark+2)  
045d 32 6d ee			ld (debug_mark+2),a  
0460 18 03			jr .pastdmark  
0462 ..			.dmark: db "LBL"  
0465 f1			.pastdmark: pop af  
0466			endm  
# End of macro DMARK
0466					CALLMONITOR 
0466 cd 6f ee			call debug_vector  
0469				endm  
# End of macro CALLMONITOR
0469				endif 
0469			 
0469 e5				push hl 
046a			 
046a cd 29 03			call storage_get_block_0 
046d			 
046d				; set default label 
046d			 
046d e1				pop hl 
046e			 
046e 11 7d ea		 	ld de, store_page+3 
0471 01 0f 00			ld bc, 15 
0474				if DEBUG_STORESE 
0474					DMARK "LB3" 
0474 f5				push af  
0475 3a 89 04			ld a, (.dmark)  
0478 32 6b ee			ld (debug_mark),a  
047b 3a 8a 04			ld a, (.dmark+1)  
047e 32 6c ee			ld (debug_mark+1),a  
0481 3a 8b 04			ld a, (.dmark+2)  
0484 32 6d ee			ld (debug_mark+2),a  
0487 18 03			jr .pastdmark  
0489 ..			.dmark: db "LB3"  
048c f1			.pastdmark: pop af  
048d			endm  
# End of macro DMARK
048d					CALLMONITOR 
048d cd 6f ee			call debug_vector  
0490				endm  
# End of macro CALLMONITOR
0490				endif 
0490 ed b0			ldir 
0492				; save default page 0 
0492			 
0492 21 00 00			ld hl, 0 
0495 11 7a ea			ld de, store_page 
0498				if DEBUG_STORESE 
0498					DMARK "LBW" 
0498 f5				push af  
0499 3a ad 04			ld a, (.dmark)  
049c 32 6b ee			ld (debug_mark),a  
049f 3a ae 04			ld a, (.dmark+1)  
04a2 32 6c ee			ld (debug_mark+1),a  
04a5 3a af 04			ld a, (.dmark+2)  
04a8 32 6d ee			ld (debug_mark+2),a  
04ab 18 03			jr .pastdmark  
04ad ..			.dmark: db "LBW"  
04b0 f1			.pastdmark: pop af  
04b1			endm  
# End of macro DMARK
04b1					CALLMONITOR 
04b1 cd 6f ee			call debug_vector  
04b4				endm  
# End of macro CALLMONITOR
04b4				endif 
04b4 cd dd 02			call storage_write_block 
04b7			 
04b7 c9				ret 
04b8			 
04b8			 
04b8			 
04b8			; Read Block 0 - Config 
04b8			; --------------------- 
04b8			; 
04b8			; With current bank 
04b8			; Call presence test 
04b8			;    If not present format/init bank  
04b8			; Read block 0  
04b8			;  
04b8			 
04b8			 
04b8			; Dir 
04b8			; --- 
04b8			; 
04b8			; With current bank 
04b8			; Load Block 0 Config 
04b8			; Get max file id number 
04b8			; For each logical block 
04b8			;    Read block read byte 2 
04b8			;      if first block of file 
04b8			;         Display file name 
04b8			;         Display type flags for file 
04b8			;        
04b8			 
04b8			; moving to words as this requires stack control 
04b8			 
04b8			 
04b8			; Delete File 
04b8			; ----------- 
04b8			; 
04b8			; With current bank 
04b8			; 
04b8			; Load Block 0 Config 
04b8			; Get max file id number 
04b8			; For each logical block 
04b8			;    Read block file id 
04b8			;      If first block of file and dont have file id 
04b8			;         if file to delete 
04b8			;         Save file id 
04b8			;         Null file id 
04b8			;         Write this block back 
04b8			;      If file id is one saved 
04b8			;         Null file id 
04b8			;         Write this block back 
04b8			 
04b8			 
04b8			.se_done: 
04b8 e1				pop hl 
04b9 c9				ret 
04ba			 
04ba			storage_erase: 
04ba			 
04ba				; hl contains the file id 
04ba			 
04ba 5d				ld e, l 
04bb 16 00			ld d, 0 
04bd 21 40 00			ld hl, STORE_BLOCK_PHY 
04c0					if DEBUG_FORTH_WORDS 
04c0						DMARK "ERA" 
04c0 f5				push af  
04c1 3a d5 04			ld a, (.dmark)  
04c4 32 6b ee			ld (debug_mark),a  
04c7 3a d6 04			ld a, (.dmark+1)  
04ca 32 6c ee			ld (debug_mark+1),a  
04cd 3a d7 04			ld a, (.dmark+2)  
04d0 32 6d ee			ld (debug_mark+2),a  
04d3 18 03			jr .pastdmark  
04d5 ..			.dmark: db "ERA"  
04d8 f1			.pastdmark: pop af  
04d9			endm  
# End of macro DMARK
04d9						CALLMONITOR 
04d9 cd 6f ee			call debug_vector  
04dc				endm  
# End of macro CALLMONITOR
04dc					endif 
04dc cd ab 05			call storage_findnextid 
04df cd 0f 0e			call ishlzero 
04e2 c8				ret z 
04e3			 
04e3 e5				push hl 
04e4			 
04e4				; TODO check file not found 
04e4			 
04e4 11 7a ea			ld de, store_page 
04e7 cd 78 02			call storage_read_block 
04ea			 
04ea cd 0f 0e			call ishlzero 
04ed ca b8 04			jp z,.se_done 
04f0			 
04f0					if DEBUG_FORTH_WORDS 
04f0						DMARK "ER1" 
04f0 f5				push af  
04f1 3a 05 05			ld a, (.dmark)  
04f4 32 6b ee			ld (debug_mark),a  
04f7 3a 06 05			ld a, (.dmark+1)  
04fa 32 6c ee			ld (debug_mark+1),a  
04fd 3a 07 05			ld a, (.dmark+2)  
0500 32 6d ee			ld (debug_mark+2),a  
0503 18 03			jr .pastdmark  
0505 ..			.dmark: db "ER1"  
0508 f1			.pastdmark: pop af  
0509			endm  
# End of macro DMARK
0509						CALLMONITOR 
0509 cd 6f ee			call debug_vector  
050c				endm  
# End of macro CALLMONITOR
050c					endif 
050c 3a 7a ea			ld a, (store_page)	; get file id 
050f 32 6e ea			ld (store_tmpid), a 
0512			 
0512 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
0515 32 6d ea			ld (store_tmpext), a 
0518			 
0518				; wipe file header 
0518			 
0518 e1				pop hl 
0519 3e 00			ld a, 0 
051b 32 7a ea			ld (store_page), a 
051e 32 7b ea			ld (store_page+1),a 
0521 11 7a ea			ld de, store_page 
0524					if DEBUG_FORTH_WORDS 
0524						DMARK "ER2" 
0524 f5				push af  
0525 3a 39 05			ld a, (.dmark)  
0528 32 6b ee			ld (debug_mark),a  
052b 3a 3a 05			ld a, (.dmark+1)  
052e 32 6c ee			ld (debug_mark+1),a  
0531 3a 3b 05			ld a, (.dmark+2)  
0534 32 6d ee			ld (debug_mark+2),a  
0537 18 03			jr .pastdmark  
0539 ..			.dmark: db "ER2"  
053c f1			.pastdmark: pop af  
053d			endm  
# End of macro DMARK
053d						CALLMONITOR 
053d cd 6f ee			call debug_vector  
0540				endm  
# End of macro CALLMONITOR
0540					endif 
0540 cd dd 02			call storage_write_block 
0543			 
0543			 
0543				; wipe file extents 
0543			 
0543 3a 6d ea			ld a, (store_tmpext) 
0546 47				ld b, a 
0547			 
0547			.eraext:	  
0547 c5				push bc 
0548			 
0548 21 40 00			ld hl, STORE_BLOCK_PHY 
054b 3a 6e ea			ld a,(store_tmpid) 
054e 5f				ld e, a 
054f 50				ld d, b	 
0550					if DEBUG_FORTH_WORDS 
0550						DMARK "ER3" 
0550 f5				push af  
0551 3a 65 05			ld a, (.dmark)  
0554 32 6b ee			ld (debug_mark),a  
0557 3a 66 05			ld a, (.dmark+1)  
055a 32 6c ee			ld (debug_mark+1),a  
055d 3a 67 05			ld a, (.dmark+2)  
0560 32 6d ee			ld (debug_mark+2),a  
0563 18 03			jr .pastdmark  
0565 ..			.dmark: db "ER3"  
0568 f1			.pastdmark: pop af  
0569			endm  
# End of macro DMARK
0569						CALLMONITOR 
0569 cd 6f ee			call debug_vector  
056c				endm  
# End of macro CALLMONITOR
056c					endif 
056c cd ab 05			call storage_findnextid 
056f cd 0f 0e			call ishlzero 
0572 ca b8 04			jp z,.se_done 
0575			 
0575 e5				push hl 
0576 11 7a ea			ld de, store_page 
0579 cd 78 02			call storage_read_block 
057c			 
057c				; free block	 
057c			 
057c 3e 00			ld a, 0 
057e 32 7a ea			ld (store_page), a 
0581 32 7b ea			ld (store_page+1),a 
0584 11 7a ea			ld de, store_page 
0587 e1				pop hl 
0588					if DEBUG_FORTH_WORDS 
0588						DMARK "ER4" 
0588 f5				push af  
0589 3a 9d 05			ld a, (.dmark)  
058c 32 6b ee			ld (debug_mark),a  
058f 3a 9e 05			ld a, (.dmark+1)  
0592 32 6c ee			ld (debug_mark+1),a  
0595 3a 9f 05			ld a, (.dmark+2)  
0598 32 6d ee			ld (debug_mark+2),a  
059b 18 03			jr .pastdmark  
059d ..			.dmark: db "ER4"  
05a0 f1			.pastdmark: pop af  
05a1			endm  
# End of macro DMARK
05a1						CALLMONITOR 
05a1 cd 6f ee			call debug_vector  
05a4				endm  
# End of macro CALLMONITOR
05a4					endif 
05a4 cd dd 02			call storage_write_block 
05a7			 
05a7 c1				pop bc 
05a8 10 9d			djnz .eraext 
05aa			 
05aa c9				ret 
05ab			 
05ab			 
05ab			; Find Free Block 
05ab			; --------------- 
05ab			; 
05ab			; With current bank 
05ab			;  
05ab			; From given starting logical block 
05ab			;    Read block  
05ab			;    If no file id 
05ab			;         Return block id 
05ab			 
05ab			 
05ab			; hl starting page number 
05ab			; hl contains free page number or zero if no pages free 
05ab			; e contains the file id to locate 
05ab			; d contains the block number 
05ab			 
05ab			; TODO change to find file id and use zero for free block 
05ab			 
05ab			storage_findnextid: 
05ab			 
05ab				; now locate first 0 page to mark as a free block 
05ab			 
05ab 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ad			;	ld hl, STORE_BLOCK_PHY 
05ad			 
05ad					if DEBUG_FORTH_WORDS 
05ad					DMARK "FNI" 
05ad f5				push af  
05ae 3a c2 05			ld a, (.dmark)  
05b1 32 6b ee			ld (debug_mark),a  
05b4 3a c3 05			ld a, (.dmark+1)  
05b7 32 6c ee			ld (debug_mark+1),a  
05ba 3a c4 05			ld a, (.dmark+2)  
05bd 32 6d ee			ld (debug_mark+2),a  
05c0 18 03			jr .pastdmark  
05c2 ..			.dmark: db "FNI"  
05c5 f1			.pastdmark: pop af  
05c6			endm  
# End of macro DMARK
05c6						CALLMONITOR 
05c6 cd 6f ee			call debug_vector  
05c9				endm  
# End of macro CALLMONITOR
05c9					endif 
05c9			.ff1:   	 
05c9 e5					push hl 
05ca c5					push bc 
05cb d5					push de 
05cc cd 9c 01				call se_readbyte 
05cf 5f					ld e,a 
05d0 23					inc hl 
05d1 cd 9c 01				call se_readbyte 
05d4 57					ld d, a 
05d5 e1					pop hl 
05d6 e5					push hl 
05d7 cd 04 0e				call cmp16 
05da 28 49				jr z, .fffound 
05dc			 
05dc d1					pop de 
05dd c1					pop bc 
05de e1					pop hl 
05df			 
05df					; is found? 
05df					;cp e 
05df					;ret z 
05df			 
05df 3e 40				ld a, STORE_BLOCK_PHY 
05e1 cd e6 0d				call addatohl 
05e4 10 e3				djnz .ff1 
05e6			 
05e6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e8			.ff2:   	 
05e8			 
05e8 e5					push hl 
05e9 c5					push bc 
05ea d5					push de 
05eb cd 9c 01				call se_readbyte 
05ee 5f					ld e,a 
05ef 23					inc hl 
05f0 cd 9c 01				call se_readbyte 
05f3 57					ld d, a 
05f4			 
05f4 e1					pop hl 
05f5 e5					push hl 
05f6 cd 04 0e				call cmp16 
05f9 28 2a				jr z, .fffound 
05fb			 
05fb d1					pop de 
05fc c1					pop bc 
05fd e1					pop hl 
05fe					; is found? 
05fe					;cp e 
05fe					;ret z 
05fe			 
05fe 3e 40				ld a, STORE_BLOCK_PHY 
0600 cd e6 0d				call addatohl 
0603 10 e3				djnz .ff2 
0605			 
0605			 
0605					if DEBUG_FORTH_WORDS 
0605					DMARK "FN-" 
0605 f5				push af  
0606 3a 1a 06			ld a, (.dmark)  
0609 32 6b ee			ld (debug_mark),a  
060c 3a 1b 06			ld a, (.dmark+1)  
060f 32 6c ee			ld (debug_mark+1),a  
0612 3a 1c 06			ld a, (.dmark+2)  
0615 32 6d ee			ld (debug_mark+2),a  
0618 18 03			jr .pastdmark  
061a ..			.dmark: db "FN-"  
061d f1			.pastdmark: pop af  
061e			endm  
# End of macro DMARK
061e					;	push af 
061e					;	ld a, 'n' 
061e					;	ld (debug_mark),a 
061e					;	pop af 
061e						CALLMONITOR 
061e cd 6f ee			call debug_vector  
0621				endm  
# End of macro CALLMONITOR
0621					endif 
0621				; no free marks! 
0621 21 00 00				ld hl, 0 
0624 c9				ret 
0625			.fffound: 
0625				 
0625			 
0625 d1					pop de 
0626 c1					pop bc 
0627 e1					pop hl 
0628					if DEBUG_FORTH_WORDS 
0628					DMARK "FNF" 
0628 f5				push af  
0629 3a 3d 06			ld a, (.dmark)  
062c 32 6b ee			ld (debug_mark),a  
062f 3a 3e 06			ld a, (.dmark+1)  
0632 32 6c ee			ld (debug_mark+1),a  
0635 3a 3f 06			ld a, (.dmark+2)  
0638 32 6d ee			ld (debug_mark+2),a  
063b 18 03			jr .pastdmark  
063d ..			.dmark: db "FNF"  
0640 f1			.pastdmark: pop af  
0641			endm  
# End of macro DMARK
0641					;	push af 
0641					;	ld a, 'n' 
0641					;	ld (debug_mark),a 
0641					;	pop af 
0641						CALLMONITOR 
0641 cd 6f ee			call debug_vector  
0644				endm  
# End of macro CALLMONITOR
0644					endif 
0644 c9				ret 
0645			 
0645			 
0645			 
0645			; Free Space 
0645			; ---------- 
0645			; 
0645			; With current bank 
0645			; 
0645			; Set block count to zero 
0645			; Starting with first logical block 
0645			;      Find free block  
0645			;      If block id given, increment block count 
0645			; 
0645			;  
0645			 
0645			 
0645			; hl contains count of free blocks 
0645			 
0645			storage_freeblocks: 
0645			 
0645				; now locate first 0 page to mark as a free block 
0645			 
0645 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0647 21 40 00			ld hl, STORE_BLOCK_PHY 
064a 11 00 00			ld de, 0 
064d			 
064d			.fb1:   	 
064d e5					push hl 
064e c5					push bc 
064f d5					push de 
0650 cd 9c 01				call se_readbyte 
0653 d1					pop de 
0654 c1					pop bc 
0655 e1					pop hl 
0656			 
0656					; is free? 
0656 fe 00				cp 0 
0658 20 01				jr nz, .ff1cont 
065a 13					inc de 
065b			 
065b			.ff1cont: 
065b			 
065b			 
065b 3e 40				ld a, STORE_BLOCK_PHY 
065d cd e6 0d				call addatohl 
0660 10 eb				djnz .fb1 
0662			 
0662 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0664			.fb2:   	 
0664 e5					push hl 
0665 c5					push bc 
0666 d5					push de 
0667 cd 9c 01				call se_readbyte 
066a d1					pop de 
066b c1					pop bc 
066c e1					pop hl 
066d			 
066d					; is free? 
066d fe 00				cp 0 
066f 20 01				jr nz, .ff2cont 
0671 13					inc de 
0672			 
0672			.ff2cont: 
0672			 
0672 3e 40				ld a, STORE_BLOCK_PHY 
0674 cd e6 0d				call addatohl 
0677 10 eb				djnz .fb2 
0679			 
0679 eb				ex de, hl 
067a c9				ret 
067b			 
067b			; Get File ID 
067b			; ----------- 
067b			; 
067b			; With current bank 
067b			;  
067b			; Load Block 0 Config 
067b			; Get max file id number 
067b			; For each logical block 
067b			;    Read block file id 
067b			;      If first block of file and dont have file id 
067b			;         if file get id and exit 
067b			 
067b			 
067b			 
067b			 
067b			; Create File 
067b			; ----------- 
067b			; 
067b			; With current bank  
067b			; Load Block 0 Config 
067b			; Get max file id number 
067b			; Increment file id number 
067b			; Save Config 
067b			; Find free block 
067b			; Set buffer with file name and file id 
067b			; Write buffer to free block  
067b			 
067b			 
067b			; hl point to file name 
067b			; hl returns file id 
067b			 
067b			; file format: 
067b			; byte 0 - file id 
067b			; byte 1 - extent number 
067b			; byte 2-> data 
067b			 
067b			; format for extent number 0: 
067b			; 
067b			; byte 0 - file id 
067b			; byte 1 - extent 0 
067b			; byte 2 - extent count 
067b			; byte 3 -> file name and meta data 
067b			 
067b			 
067b			storage_create: 
067b				if DEBUG_STORESE 
067b					DMARK "SCR" 
067b f5				push af  
067c 3a 90 06			ld a, (.dmark)  
067f 32 6b ee			ld (debug_mark),a  
0682 3a 91 06			ld a, (.dmark+1)  
0685 32 6c ee			ld (debug_mark+1),a  
0688 3a 92 06			ld a, (.dmark+2)  
068b 32 6d ee			ld (debug_mark+2),a  
068e 18 03			jr .pastdmark  
0690 ..			.dmark: db "SCR"  
0693 f1			.pastdmark: pop af  
0694			endm  
# End of macro DMARK
0694					CALLMONITOR 
0694 cd 6f ee			call debug_vector  
0697				endm  
# End of macro CALLMONITOR
0697				endif 
0697			 
0697 e5				push hl		; save file name pointer 
0698			 
0698 cd 29 03			call storage_get_block_0 
069b			 
069b 3a 7a ea			ld a,(store_page)	; get current file id 
069e 3c				inc a 
069f 32 7a ea			ld (store_page),a 
06a2				 
06a2 32 6e ea			ld (store_tmpid),a			; save id 
06a5			 
06a5 21 00 00			ld hl, 0 
06a8 11 7a ea			ld de, store_page 
06ab				if DEBUG_STORESE 
06ab					DMARK "SCw" 
06ab f5				push af  
06ac 3a c0 06			ld a, (.dmark)  
06af 32 6b ee			ld (debug_mark),a  
06b2 3a c1 06			ld a, (.dmark+1)  
06b5 32 6c ee			ld (debug_mark+1),a  
06b8 3a c2 06			ld a, (.dmark+2)  
06bb 32 6d ee			ld (debug_mark+2),a  
06be 18 03			jr .pastdmark  
06c0 ..			.dmark: db "SCw"  
06c3 f1			.pastdmark: pop af  
06c4			endm  
# End of macro DMARK
06c4					CALLMONITOR 
06c4 cd 6f ee			call debug_vector  
06c7				endm  
# End of macro CALLMONITOR
06c7				endif 
06c7 cd dd 02			call storage_write_block	 ; save update 
06ca			 
06ca				if DEBUG_STORESE 
06ca 11 7a ea				ld de, store_page 
06cd					DMARK "SCC" 
06cd f5				push af  
06ce 3a e2 06			ld a, (.dmark)  
06d1 32 6b ee			ld (debug_mark),a  
06d4 3a e3 06			ld a, (.dmark+1)  
06d7 32 6c ee			ld (debug_mark+1),a  
06da 3a e4 06			ld a, (.dmark+2)  
06dd 32 6d ee			ld (debug_mark+2),a  
06e0 18 03			jr .pastdmark  
06e2 ..			.dmark: db "SCC"  
06e5 f1			.pastdmark: pop af  
06e6			endm  
# End of macro DMARK
06e6					CALLMONITOR 
06e6 cd 6f ee			call debug_vector  
06e9				endm  
# End of macro CALLMONITOR
06e9				endif 
06e9				;  
06e9				 
06e9 21 40 00			ld hl, STORE_BLOCK_PHY 
06ec 11 00 00			ld de, 0 
06ef cd ab 05			call storage_findnextid 
06f2			 
06f2 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
06f5			 
06f5				; TODO detect 0 = no spare blocks 
06f5			 
06f5				; hl now contains the free page to use for the file header page 
06f5			 
06f5				if DEBUG_STORESE 
06f5				DMARK "SCF" 
06f5 f5				push af  
06f6 3a 0a 07			ld a, (.dmark)  
06f9 32 6b ee			ld (debug_mark),a  
06fc 3a 0b 07			ld a, (.dmark+1)  
06ff 32 6c ee			ld (debug_mark+1),a  
0702 3a 0c 07			ld a, (.dmark+2)  
0705 32 6d ee			ld (debug_mark+2),a  
0708 18 03			jr .pastdmark  
070a ..			.dmark: db "SCF"  
070d f1			.pastdmark: pop af  
070e			endm  
# End of macro DMARK
070e					CALLMONITOR 
070e cd 6f ee			call debug_vector  
0711				endm  
# End of macro CALLMONITOR
0711				endif 
0711			 
0711 22 65 ea			ld (store_tmppageid), hl 
0714				 
0714 3a 6e ea			ld a,(store_tmpid)    ; get file id 
0717			;	ld a, (store_filecache)			; save to cache 
0717			 
0717 32 7a ea			ld (store_page),a    ; set page id 
071a 3e 00			ld a, 0			 ; extent 0 is file header 
071c 32 7b ea			ld (store_page+1), a   ; set file extent 
071f			 
071f 32 7c ea			ld (store_page+2), a   ; extent count for the file 
0722			 
0722			;	inc hl 		; init block 0 of file 
0722			;	inc hl   		; skip file and extent id 
0722			 ;       ld a, 0 
0722			;	ld (hl),a 
0722			;	ld a, (store_filecache+1)  	; save to cache 
0722			 
0722			;	inc hl    ; file name 
0722				 
0722				 
0722 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0725				if DEBUG_STORESE 
0725					DMARK "SCc" 
0725 f5				push af  
0726 3a 3a 07			ld a, (.dmark)  
0729 32 6b ee			ld (debug_mark),a  
072c 3a 3b 07			ld a, (.dmark+1)  
072f 32 6c ee			ld (debug_mark+1),a  
0732 3a 3c 07			ld a, (.dmark+2)  
0735 32 6d ee			ld (debug_mark+2),a  
0738 18 03			jr .pastdmark  
073a ..			.dmark: db "SCc"  
073d f1			.pastdmark: pop af  
073e			endm  
# End of macro DMARK
073e					CALLMONITOR 
073e cd 6f ee			call debug_vector  
0741				endm  
# End of macro CALLMONITOR
0741				endif 
0741 e1				pop hl    ; get zero term string 
0742 e5				push hl 
0743 3e 00			ld a, 0 
0745 cd 4f 12			call strlent 
0748 23				inc hl   ; cover zero term 
0749 06 00			ld b,0 
074b 4d				ld c,l 
074c e1				pop hl 
074d				;ex de, hl 
074d				if DEBUG_STORESE 
074d					DMARK "SCa" 
074d f5				push af  
074e 3a 62 07			ld a, (.dmark)  
0751 32 6b ee			ld (debug_mark),a  
0754 3a 63 07			ld a, (.dmark+1)  
0757 32 6c ee			ld (debug_mark+1),a  
075a 3a 64 07			ld a, (.dmark+2)  
075d 32 6d ee			ld (debug_mark+2),a  
0760 18 03			jr .pastdmark  
0762 ..			.dmark: db "SCa"  
0765 f1			.pastdmark: pop af  
0766			endm  
# End of macro DMARK
0766					;push af 
0766					;ld a, 'a' 
0766					;ld (debug_mark),a 
0766					;pop af 
0766					CALLMONITOR 
0766 cd 6f ee			call debug_vector  
0769				endm  
# End of macro CALLMONITOR
0769				endif 
0769 ed b0			ldir    ; copy zero term string 
076b				if DEBUG_STORESE 
076b					DMARK "SCA" 
076b f5				push af  
076c 3a 80 07			ld a, (.dmark)  
076f 32 6b ee			ld (debug_mark),a  
0772 3a 81 07			ld a, (.dmark+1)  
0775 32 6c ee			ld (debug_mark+1),a  
0778 3a 82 07			ld a, (.dmark+2)  
077b 32 6d ee			ld (debug_mark+2),a  
077e 18 03			jr .pastdmark  
0780 ..			.dmark: db "SCA"  
0783 f1			.pastdmark: pop af  
0784			endm  
# End of macro DMARK
0784					CALLMONITOR 
0784 cd 6f ee			call debug_vector  
0787				endm  
# End of macro CALLMONITOR
0787				endif 
0787			 
0787				; write file header page 
0787			 
0787 2a 65 ea			ld hl,(store_tmppageid) 
078a 11 7a ea			ld de, store_page 
078d				if DEBUG_STORESE 
078d					DMARK "SCb" 
078d f5				push af  
078e 3a a2 07			ld a, (.dmark)  
0791 32 6b ee			ld (debug_mark),a  
0794 3a a3 07			ld a, (.dmark+1)  
0797 32 6c ee			ld (debug_mark+1),a  
079a 3a a4 07			ld a, (.dmark+2)  
079d 32 6d ee			ld (debug_mark+2),a  
07a0 18 03			jr .pastdmark  
07a2 ..			.dmark: db "SCb"  
07a5 f1			.pastdmark: pop af  
07a6			endm  
# End of macro DMARK
07a6					;push af 
07a6					;ld a, 'b' 
07a6					;ld (debug_mark),a 
07a6					;pop af 
07a6					CALLMONITOR 
07a6 cd 6f ee			call debug_vector  
07a9				endm  
# End of macro CALLMONITOR
07a9				endif 
07a9 cd dd 02			call storage_write_block 
07ac			 
07ac 3a 6e ea			ld a, (store_tmpid) 
07af 6f				ld l, a 
07b0 26 00			ld h,0 
07b2				if DEBUG_STORESE 
07b2					DMARK "SCz" 
07b2 f5				push af  
07b3 3a c7 07			ld a, (.dmark)  
07b6 32 6b ee			ld (debug_mark),a  
07b9 3a c8 07			ld a, (.dmark+1)  
07bc 32 6c ee			ld (debug_mark+1),a  
07bf 3a c9 07			ld a, (.dmark+2)  
07c2 32 6d ee			ld (debug_mark+2),a  
07c5 18 03			jr .pastdmark  
07c7 ..			.dmark: db "SCz"  
07ca f1			.pastdmark: pop af  
07cb			endm  
# End of macro DMARK
07cb					CALLMONITOR 
07cb cd 6f ee			call debug_vector  
07ce				endm  
# End of macro CALLMONITOR
07ce				endif 
07ce c9				ret 
07cf				 
07cf			 
07cf			 
07cf			; 
07cf			; Read File 
07cf			; 
07cf			; h - file id to locate 
07cf			; l - extent to locate 
07cf			; de - pointer to string to read into 
07cf			; 
07cf			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07cf			 
07cf			.sr_fail: 
07cf d1				pop de 
07d0 c9				ret 
07d1			 
07d1			storage_read: 
07d1			 
07d1			 
07d1 d5				push de 
07d2			 
07d2			; TODO BUG the above push is it popped before the RET Z? 
07d2			 
07d2			; TODO how to handle multiple part blocks 
07d2			 
07d2				; locate file extent to read 
07d2			 
07d2 5c				ld e, h 
07d3 55				ld d, l 
07d4			 
07d4			.srext: 
07d4 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
07d7 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07db			 
07db 21 40 00			ld hl, STORE_BLOCK_PHY 
07de				if DEBUG_STORESE 
07de					DMARK "sre" 
07de f5				push af  
07df 3a f3 07			ld a, (.dmark)  
07e2 32 6b ee			ld (debug_mark),a  
07e5 3a f4 07			ld a, (.dmark+1)  
07e8 32 6c ee			ld (debug_mark+1),a  
07eb 3a f5 07			ld a, (.dmark+2)  
07ee 32 6d ee			ld (debug_mark+2),a  
07f1 18 03			jr .pastdmark  
07f3 ..			.dmark: db "sre"  
07f6 f1			.pastdmark: pop af  
07f7			endm  
# End of macro DMARK
07f7					CALLMONITOR 
07f7 cd 6f ee			call debug_vector  
07fa				endm  
# End of macro CALLMONITOR
07fa				endif 
07fa cd ab 05			call storage_findnextid 
07fd			 
07fd				if DEBUG_STORESE 
07fd					DMARK "srf" 
07fd f5				push af  
07fe 3a 12 08			ld a, (.dmark)  
0801 32 6b ee			ld (debug_mark),a  
0804 3a 13 08			ld a, (.dmark+1)  
0807 32 6c ee			ld (debug_mark+1),a  
080a 3a 14 08			ld a, (.dmark+2)  
080d 32 6d ee			ld (debug_mark+2),a  
0810 18 03			jr .pastdmark  
0812 ..			.dmark: db "srf"  
0815 f1			.pastdmark: pop af  
0816			endm  
# End of macro DMARK
0816					CALLMONITOR 
0816 cd 6f ee			call debug_vector  
0819				endm  
# End of macro CALLMONITOR
0819				endif 
0819 cd 0f 0e			call ishlzero 
081c			;	ld a, l 
081c			;	add h 
081c			;	cp 0 
081c 28 b1			jr z,.sr_fail			; block not found so EOF 
081e			 
081e				; save current address for use by higher level words etc 
081e			 
081e 22 6b ea			ld (store_openaddr),hl 
0821			 
0821			 
0821				; hl contains page number to load 
0821 d1				pop de   ; get storage 
0822 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
0826 d5				push de 
0827				if DEBUG_STORESE 
0827					DMARK "srg" 
0827 f5				push af  
0828 3a 3c 08			ld a, (.dmark)  
082b 32 6b ee			ld (debug_mark),a  
082e 3a 3d 08			ld a, (.dmark+1)  
0831 32 6c ee			ld (debug_mark+1),a  
0834 3a 3e 08			ld a, (.dmark+2)  
0837 32 6d ee			ld (debug_mark+2),a  
083a 18 03			jr .pastdmark  
083c ..			.dmark: db "srg"  
083f f1			.pastdmark: pop af  
0840			endm  
# End of macro DMARK
0840					CALLMONITOR 
0840 cd 6f ee			call debug_vector  
0843				endm  
# End of macro CALLMONITOR
0843				endif 
0843 cd 78 02			call storage_read_block 
0846			 
0846				; if this a continuation read??? 
0846			 
0846 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0849			 
0849 3e 3f			ld a, STORE_BLOCK_PHY-1 
084b cd e6 0d			call addatohl 
084e 7e				ld a,(hl) 
084f fe 00			cp 0 
0851 28 02			jr z, .markiscont 
0853 3e ff			ld a, 255 
0855			 
0855			.markiscont: 
0855 32 6d ea			ld (store_readcont), a 
0858			 
0858				if DEBUG_STORESE 
0858					DMARK "srC" 
0858 f5				push af  
0859 3a 6d 08			ld a, (.dmark)  
085c 32 6b ee			ld (debug_mark),a  
085f 3a 6e 08			ld a, (.dmark+1)  
0862 32 6c ee			ld (debug_mark+1),a  
0865 3a 6f 08			ld a, (.dmark+2)  
0868 32 6d ee			ld (debug_mark+2),a  
086b 18 03			jr .pastdmark  
086d ..			.dmark: db "srC"  
0870 f1			.pastdmark: pop af  
0871			endm  
# End of macro DMARK
0871					CALLMONITOR 
0871 cd 6f ee			call debug_vector  
0874				endm  
# End of macro CALLMONITOR
0874				endif 
0874				; only short reads enabled 
0874			 
0874 3a 75 ea			ld a, (store_longread) 
0877 fe 00			cp 0 
0879 ca 46 09			jp z, .readdone 
087c			 
087c			; TODO if block has no zeros then need to read next block  
087c			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
087c			; check last byte of physical block. 
087c			; if not zero then the next block needs to be loaded 
087c			 
087c			 
087c 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
087f			 
087f 3e 3f			ld a, STORE_BLOCK_PHY-1 
0881 cd e6 0d			call addatohl 
0884				;dec hl 
0884 7e				ld a,(hl) 
0885				if DEBUG_STORESE 
0885					DMARK "sr?" 
0885 f5				push af  
0886 3a 9a 08			ld a, (.dmark)  
0889 32 6b ee			ld (debug_mark),a  
088c 3a 9b 08			ld a, (.dmark+1)  
088f 32 6c ee			ld (debug_mark+1),a  
0892 3a 9c 08			ld a, (.dmark+2)  
0895 32 6d ee			ld (debug_mark+2),a  
0898 18 03			jr .pastdmark  
089a ..			.dmark: db "sr?"  
089d f1			.pastdmark: pop af  
089e			endm  
# End of macro DMARK
089e					CALLMONITOR 
089e cd 6f ee			call debug_vector  
08a1				endm  
# End of macro CALLMONITOR
08a1				endif 
08a1 fe 00			cp 0 
08a3 ca 46 09			jp z, .readdone 
08a6			 
08a6				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a6			 
08a6 23				inc hl 
08a7			 
08a7 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08aa			 
08aa ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
08ae			 
08ae eb				ex de, hl 
08af			 
08af				; next ext 
08af			 
08af 23				inc hl 
08b0 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
08b3			 
08b3				if DEBUG_STORESE 
08b3					DMARK "sF2" 
08b3 f5				push af  
08b4 3a c8 08			ld a, (.dmark)  
08b7 32 6b ee			ld (debug_mark),a  
08ba 3a c9 08			ld a, (.dmark+1)  
08bd 32 6c ee			ld (debug_mark+1),a  
08c0 3a ca 08			ld a, (.dmark+2)  
08c3 32 6d ee			ld (debug_mark+2),a  
08c6 18 03			jr .pastdmark  
08c8 ..			.dmark: db "sF2"  
08cb f1			.pastdmark: pop af  
08cc			endm  
# End of macro DMARK
08cc					CALLMONITOR 
08cc cd 6f ee			call debug_vector  
08cf				endm  
# End of macro CALLMONITOR
08cf				endif 
08cf			 
08cf				; get and load block 
08cf			 
08cf cd ab 05			call storage_findnextid 
08d2			 
08d2				if DEBUG_STORESE 
08d2					DMARK "sf2" 
08d2 f5				push af  
08d3 3a e7 08			ld a, (.dmark)  
08d6 32 6b ee			ld (debug_mark),a  
08d9 3a e8 08			ld a, (.dmark+1)  
08dc 32 6c ee			ld (debug_mark+1),a  
08df 3a e9 08			ld a, (.dmark+2)  
08e2 32 6d ee			ld (debug_mark+2),a  
08e5 18 03			jr .pastdmark  
08e7 ..			.dmark: db "sf2"  
08ea f1			.pastdmark: pop af  
08eb			endm  
# End of macro DMARK
08eb					CALLMONITOR 
08eb cd 6f ee			call debug_vector  
08ee				endm  
# End of macro CALLMONITOR
08ee				endif 
08ee cd 0f 0e			call ishlzero 
08f1			;	ld a, l 
08f1			;	add h 
08f1			;	cp 0 
08f1 ca cf 07			jp z,.sr_fail			; block not found so EOF 
08f4				 
08f4				; save current address for use by higher level words etc 
08f4			 
08f4 22 6b ea			ld (store_openaddr),hl 
08f7			 
08f7 cd 78 02			call storage_read_block 
08fa			 
08fa				; on a continuation block, we now have the file id and ext in the middle of the block 
08fa				; we need to pull everything back  
08fa			 
08fa ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08fe 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0901 23				inc hl 
0902 23				inc hl     ; skip id and ext 
0903 01 40 00			ld bc, STORE_BLOCK_PHY 
0906				if DEBUG_STORESE 
0906					DMARK "SR<" 
0906 f5				push af  
0907 3a 1b 09			ld a, (.dmark)  
090a 32 6b ee			ld (debug_mark),a  
090d 3a 1c 09			ld a, (.dmark+1)  
0910 32 6c ee			ld (debug_mark+1),a  
0913 3a 1d 09			ld a, (.dmark+2)  
0916 32 6d ee			ld (debug_mark+2),a  
0919 18 03			jr .pastdmark  
091b ..			.dmark: db "SR<"  
091e f1			.pastdmark: pop af  
091f			endm  
# End of macro DMARK
091f					CALLMONITOR 
091f cd 6f ee			call debug_vector  
0922				endm  
# End of macro CALLMONITOR
0922				endif 
0922 ed b0			ldir     ; copy data 
0924			 
0924				; move the pointer back and pretend we have a full buffer for next recheck 
0924			 
0924 1b				dec de 
0925 1b				dec de 
0926			 
0926			; TODO do pop below now short circuit loop????? 
0926 c1				pop bc     ; get rid of spare de on stack 
0927				if DEBUG_STORESE 
0927					DMARK "SR>" 
0927 f5				push af  
0928 3a 3c 09			ld a, (.dmark)  
092b 32 6b ee			ld (debug_mark),a  
092e 3a 3d 09			ld a, (.dmark+1)  
0931 32 6c ee			ld (debug_mark+1),a  
0934 3a 3e 09			ld a, (.dmark+2)  
0937 32 6d ee			ld (debug_mark+2),a  
093a 18 03			jr .pastdmark  
093c ..			.dmark: db "SR>"  
093f f1			.pastdmark: pop af  
0940			endm  
# End of macro DMARK
0940					CALLMONITOR 
0940 cd 6f ee			call debug_vector  
0943				endm  
# End of macro CALLMONITOR
0943				endif 
0943 c3 d4 07			jp .srext 
0946			 
0946			 
0946			 
0946			 
0946			 
0946			.readdone:		 
0946 e1				pop hl 		 ; return start of data to show as not EOF 
0947 23				inc hl   ; past file id 
0948 23				inc hl   ; past ext 
0949				if DEBUG_STORESE 
0949					DMARK "SRe" 
0949 f5				push af  
094a 3a 5e 09			ld a, (.dmark)  
094d 32 6b ee			ld (debug_mark),a  
0950 3a 5f 09			ld a, (.dmark+1)  
0953 32 6c ee			ld (debug_mark+1),a  
0956 3a 60 09			ld a, (.dmark+2)  
0959 32 6d ee			ld (debug_mark+2),a  
095c 18 03			jr .pastdmark  
095e ..			.dmark: db "SRe"  
0961 f1			.pastdmark: pop af  
0962			endm  
# End of macro DMARK
0962					CALLMONITOR 
0962 cd 6f ee			call debug_vector  
0965				endm  
# End of macro CALLMONITOR
0965				endif 
0965 c9					ret 
0966			 
0966			 
0966			 
0966			; 
0966			; Append File 
0966			; 
0966			; hl - file id to locate 
0966			; de - pointer to (multi block) string to write 
0966			 
0966			.sa_notfound: 
0966 d1				pop de 
0967 c9				ret 
0968			 
0968			 
0968			storage_append: 
0968				; hl -  file id to append to 
0968				; de - string to append 
0968			 
0968 d5				push de 
0969				 
0969				if DEBUG_STORESE 
0969					DMARK "AP1" 
0969 f5				push af  
096a 3a 7e 09			ld a, (.dmark)  
096d 32 6b ee			ld (debug_mark),a  
0970 3a 7f 09			ld a, (.dmark+1)  
0973 32 6c ee			ld (debug_mark+1),a  
0976 3a 80 09			ld a, (.dmark+2)  
0979 32 6d ee			ld (debug_mark+2),a  
097c 18 03			jr .pastdmark  
097e ..			.dmark: db "AP1"  
0981 f1			.pastdmark: pop af  
0982			endm  
# End of macro DMARK
0982					CALLMONITOR 
0982 cd 6f ee			call debug_vector  
0985				endm  
# End of macro CALLMONITOR
0985				endif 
0985			 
0985 7d				ld a, l 
0986 32 6e ea			ld (store_tmpid), a 
0989			 
0989				; get file header  
0989			 
0989 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098b 3a 6e ea			ld a, (store_tmpid) 
098e 5f				ld e, a 
098f			 
098f 21 40 00				ld hl, STORE_BLOCK_PHY 
0992 cd ab 05				call storage_findnextid 
0995			 
0995 cd 0f 0e			call ishlzero 
0998 28 cc			jr z, .sa_notfound 
099a			 
099a 22 65 ea			ld (store_tmppageid), hl 
099d			 
099d				; TODO handle file id not found 
099d			 
099d				if DEBUG_STORESE 
099d					DMARK "AP2" 
099d f5				push af  
099e 3a b2 09			ld a, (.dmark)  
09a1 32 6b ee			ld (debug_mark),a  
09a4 3a b3 09			ld a, (.dmark+1)  
09a7 32 6c ee			ld (debug_mark+1),a  
09aa 3a b4 09			ld a, (.dmark+2)  
09ad 32 6d ee			ld (debug_mark+2),a  
09b0 18 03			jr .pastdmark  
09b2 ..			.dmark: db "AP2"  
09b5 f1			.pastdmark: pop af  
09b6			endm  
# End of macro DMARK
09b6					CALLMONITOR 
09b6 cd 6f ee			call debug_vector  
09b9				endm  
# End of macro CALLMONITOR
09b9				endif 
09b9			 
09b9				; update file extent count 
09b9			 
09b9 11 7a ea			ld de, store_page 
09bc			 
09bc cd 78 02			call storage_read_block 
09bf			 
09bf				if DEBUG_STORESE 
09bf					DMARK "AP3" 
09bf f5				push af  
09c0 3a d4 09			ld a, (.dmark)  
09c3 32 6b ee			ld (debug_mark),a  
09c6 3a d5 09			ld a, (.dmark+1)  
09c9 32 6c ee			ld (debug_mark+1),a  
09cc 3a d6 09			ld a, (.dmark+2)  
09cf 32 6d ee			ld (debug_mark+2),a  
09d2 18 03			jr .pastdmark  
09d4 ..			.dmark: db "AP3"  
09d7 f1			.pastdmark: pop af  
09d8			endm  
# End of macro DMARK
09d8					CALLMONITOR 
09d8 cd 6f ee			call debug_vector  
09db				endm  
# End of macro CALLMONITOR
09db				endif 
09db			;	ld (store_tmppageid), hl 
09db			 
09db 3a 7c ea			ld a, (store_page+2) 
09de 3c				inc a 
09df 32 7c ea			ld (store_page+2), a 
09e2 32 6d ea			ld (store_tmpext), a 
09e5				 
09e5				if DEBUG_STORESE 
09e5					DMARK "AP3" 
09e5 f5				push af  
09e6 3a fa 09			ld a, (.dmark)  
09e9 32 6b ee			ld (debug_mark),a  
09ec 3a fb 09			ld a, (.dmark+1)  
09ef 32 6c ee			ld (debug_mark+1),a  
09f2 3a fc 09			ld a, (.dmark+2)  
09f5 32 6d ee			ld (debug_mark+2),a  
09f8 18 03			jr .pastdmark  
09fa ..			.dmark: db "AP3"  
09fd f1			.pastdmark: pop af  
09fe			endm  
# End of macro DMARK
09fe					CALLMONITOR 
09fe cd 6f ee			call debug_vector  
0a01				endm  
# End of macro CALLMONITOR
0a01				endif 
0a01 2a 65 ea			ld hl, (store_tmppageid) 
0a04 11 7a ea			ld de, store_page 
0a07 cd dd 02			call storage_write_block 
0a0a			 
0a0a				; find free block 
0a0a			 
0a0a 11 00 00			ld de, 0			 ; file extent to locate 
0a0d			 
0a0d 21 40 00				ld hl, STORE_BLOCK_PHY 
0a10 cd ab 05				call storage_findnextid 
0a13 cd 0f 0e			call ishlzero 
0a16 ca 66 09			jp z, .sa_notfound 
0a19			 
0a19					; TODO handle no space left 
0a19					 
0a19 22 65 ea				ld (store_tmppageid), hl 
0a1c			 
0a1c				if DEBUG_STORESE 
0a1c					DMARK "AP4" 
0a1c f5				push af  
0a1d 3a 31 0a			ld a, (.dmark)  
0a20 32 6b ee			ld (debug_mark),a  
0a23 3a 32 0a			ld a, (.dmark+1)  
0a26 32 6c ee			ld (debug_mark+1),a  
0a29 3a 33 0a			ld a, (.dmark+2)  
0a2c 32 6d ee			ld (debug_mark+2),a  
0a2f 18 03			jr .pastdmark  
0a31 ..			.dmark: db "AP4"  
0a34 f1			.pastdmark: pop af  
0a35			endm  
# End of macro DMARK
0a35					CALLMONITOR 
0a35 cd 6f ee			call debug_vector  
0a38				endm  
# End of macro CALLMONITOR
0a38				endif 
0a38					; init the buffer with zeros so we can id if the buffer is full or not 
0a38			 
0a38 e5					push hl 
0a39 c5					push bc 
0a3a			 
0a3a 21 7a ea				ld hl, store_page 
0a3d 06 40				ld b, STORE_BLOCK_PHY 
0a3f 3e 00				ld a, 0 
0a41 77			.zeroblock:	ld (hl), a 
0a42 23					inc hl 
0a43 10 fc				djnz .zeroblock 
0a45			 
0a45 c1					pop bc 
0a46 e1					pop hl 
0a47			 
0a47					; construct block 
0a47			 
0a47 3a 6e ea				ld a, (store_tmpid) 
0a4a 32 7a ea				ld (store_page), a   ; file id 
0a4d 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
0a50 32 7b ea				ld (store_page+1), a 
0a53			 
0a53 e1					pop hl    ; get string to write 
0a54 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a56 11 7c ea				ld de, store_page+2 
0a59			 
0a59				if DEBUG_STORESE 
0a59					DMARK "AP5" 
0a59 f5				push af  
0a5a 3a 6e 0a			ld a, (.dmark)  
0a5d 32 6b ee			ld (debug_mark),a  
0a60 3a 6f 0a			ld a, (.dmark+1)  
0a63 32 6c ee			ld (debug_mark+1),a  
0a66 3a 70 0a			ld a, (.dmark+2)  
0a69 32 6d ee			ld (debug_mark+2),a  
0a6c 18 03			jr .pastdmark  
0a6e ..			.dmark: db "AP5"  
0a71 f1			.pastdmark: pop af  
0a72			endm  
# End of macro DMARK
0a72					CALLMONITOR 
0a72 cd 6f ee			call debug_vector  
0a75				endm  
# End of macro CALLMONITOR
0a75				endif 
0a75			 
0a75			 
0a75			 
0a75					; fill buffer with data until end of string or full block 
0a75			 
0a75 7e			.appd:		ld a, (hl) 
0a76 12					ld (de), a 
0a77 fe 00				cp 0 
0a79 28 04				jr z, .appdone 
0a7b 23					inc hl 
0a7c 13					inc de 
0a7d 10 f6				djnz .appd 
0a7f			 
0a7f e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a80 f5					push af   		; save last byte dumped 
0a81			 
0a81			 
0a81 2a 65 ea			ld hl, (store_tmppageid) 
0a84 11 7a ea			ld de, store_page 
0a87				if DEBUG_STORESE 
0a87					DMARK "AP6" 
0a87 f5				push af  
0a88 3a 9c 0a			ld a, (.dmark)  
0a8b 32 6b ee			ld (debug_mark),a  
0a8e 3a 9d 0a			ld a, (.dmark+1)  
0a91 32 6c ee			ld (debug_mark+1),a  
0a94 3a 9e 0a			ld a, (.dmark+2)  
0a97 32 6d ee			ld (debug_mark+2),a  
0a9a 18 03			jr .pastdmark  
0a9c ..			.dmark: db "AP6"  
0a9f f1			.pastdmark: pop af  
0aa0			endm  
# End of macro DMARK
0aa0					CALLMONITOR 
0aa0 cd 6f ee			call debug_vector  
0aa3				endm  
# End of macro CALLMONITOR
0aa3				endif 
0aa3 cd dd 02				call storage_write_block 
0aa6			 
0aa6			 
0aa6				; was that a full block of data written? 
0aa6				; any more to write out? 
0aa6			 
0aa6				; if yes then set vars and jump to start of function again 
0aa6			 
0aa6 f1					pop af 
0aa7 d1					pop de 
0aa8			 
0aa8 fe 00				cp 0		 ; no, string was fully written 
0aaa c8					ret z 
0aab			 
0aab					; setup vars for next cycle 
0aab			 
0aab 3a 6e ea				ld a, (store_tmpid) 
0aae 6f					ld l, a 
0aaf 26 00				ld h, 0 
0ab1			 
0ab1 c3 68 09			 	jp storage_append	 ; yes, need to write out some more 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			if DEBUG_STORECF 
0ab4			storageput:	 
0ab4					ret 
0ab4			storageread: 
0ab4					ld hl, store_page 
0ab4					ld b, 200 
0ab4					ld a,0 
0ab4			.src:		ld (hl),a 
0ab4					inc hl 
0ab4					djnz .src 
0ab4					 
0ab4			 
0ab4					ld de, 0 
0ab4					ld bc, 1 
0ab4					ld hl, store_page 
0ab4					call cfRead 
0ab4			 
0ab4				call cfGetError 
0ab4				ld hl,scratch 
0ab4				call hexout 
0ab4				ld hl, scratch+2 
0ab4				ld a, 0 
0ab4				ld (hl),a 
0ab4				ld de, scratch 
0ab4				ld a,display_row_1 
0ab4				call str_at_display 
0ab4				call update_display 
0ab4			 
0ab4					ld hl, store_page 
0ab4					ld (os_cur_ptr),hl 
0ab4			 
0ab4					ret 
0ab4			endif 
0ab4			 
0ab4			 
0ab4			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab4			 
0ab4			storage_clear_page: 
0ab4 e5				push hl 
0ab5 d5				push de 
0ab6 c5				push bc 
0ab7 21 7a ea			ld hl, store_page 
0aba 3e 00			ld a, 0 
0abc 77				ld (hl), a 
0abd			 
0abd 11 7b ea			ld de, store_page+1 
0ac0 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ac3			 
0ac3 ed b0			ldir 
0ac5				 
0ac5 c1				pop bc 
0ac6 d1				pop de 
0ac7 e1				pop hl 
0ac8 c9				ret 
0ac9			 
0ac9			; eof 
# End of file firmware_storage.asm
0ac9			  
0ac9			; support routines for above hardware abstraction layer  
0ac9			  
0ac9			include "firmware_general.asm"        ; general support functions  
0ac9			 
0ac9			; word look up 
0ac9			 
0ac9			; in 
0ac9			; a is the index 
0ac9			; hl is pointer start of array 
0ac9			; 
0ac9			; returns 
0ac9			; hl to the word 
0ac9			; 
0ac9			 
0ac9			table_lookup:  
0ac9 d5					push de 
0aca eb					ex de, hl 
0acb			 
0acb 6f					ld l, a 
0acc 26 00				ld h, 0 
0ace 29					add hl, hl 
0acf 19					add hl, de 
0ad0 7e					ld a, (hl) 
0ad1 23					inc hl 
0ad2 66					ld h,(hl) 
0ad3 6f					ld l, a 
0ad4			 
0ad4 d1					pop de 
0ad5 c9					ret 
0ad6			 
0ad6			; Delay loops 
0ad6			 
0ad6			 
0ad6			 
0ad6			aDelayInMS: 
0ad6 c5				push bc 
0ad7 47				ld b,a 
0ad8			msdelay: 
0ad8 c5				push bc 
0ad9				 
0ad9			 
0ad9 01 41 00			ld bc,041h 
0adc cd f4 0a			call delayloop 
0adf c1				pop bc 
0ae0 05				dec b 
0ae1 20 f5			jr nz,msdelay 
0ae3			 
0ae3			;if CPU_CLOCK_8MHZ 
0ae3			;msdelay8: 
0ae3			;	push bc 
0ae3			;	 
0ae3			; 
0ae3			;	ld bc,041h 
0ae3			;	call delayloop 
0ae3			;	pop bc 
0ae3			;	dec b 
0ae3			;	jr nz,msdelay8 
0ae3			;endif 
0ae3			 
0ae3			 
0ae3 c1				pop bc 
0ae4 c9				ret 
0ae5			 
0ae5			 
0ae5			delay250ms: 
0ae5				;push de 
0ae5 01 00 40			ld bc, 04000h 
0ae8 c3 f4 0a			jp delayloop 
0aeb			delay500ms: 
0aeb				;push de 
0aeb 01 00 80			ld bc, 08000h 
0aee c3 f4 0a			jp delayloop 
0af1			delay1s: 
0af1				;push bc 
0af1			   ; Clobbers A, d and e 
0af1 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af4			delayloop: 
0af4 c5			    push bc 
0af5			 
0af5			if BASE_CPM 
0af5 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af8			.cpmloop: 
0af8 c5				push bc 
0af9			 
0af9			endif 
0af9			 
0af9			 
0af9			 
0af9			delayloopi: 
0af9			;	push bc 
0af9			;.dl: 
0af9 cb 47		    bit     0,a    	; 8 
0afb cb 47		    bit     0,a    	; 8 
0afd cb 47		    bit     0,a    	; 8 
0aff e6 ff		    and     255  	; 7 
0b01 0b			    dec     bc      	; 6 
0b02 79			    ld      a,c     	; 4 
0b03 b0			    or      b     	; 4 
0b04 c2 f9 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b07			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b07				;pop de 
0b07			;pop bc 
0b07			 
0b07			if BASE_CPM 
0b07 c1				pop bc 
0b08				 
0b08 0b			    dec     bc      	; 6 
0b09 79			    ld      a,c     	; 4 
0b0a b0			    or      b     	; 4 
0b0b c2 f8 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0e				 
0b0e			 
0b0e			endif 
0b0e			;if CPU_CLOCK_8MHZ 
0b0e			;    pop bc 
0b0e			;    push bc 
0b0e			;.dl8: 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    and     255  	; 7 
0b0e			;    dec     bc      	; 6 
0b0e			;    ld      a,c     	; 4 
0b0e			;    or      b     	; 4 
0b0e			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0e			;endif 
0b0e			 
0b0e			;if CPU_CLOCK_10MHZ 
0b0e			;    pop bc 
0b0e			;    push bc 
0b0e			;.dl8: 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    and     255  	; 7 
0b0e			;    dec     bc      	; 6 
0b0e			;    ld      a,c     	; 4 
0b0e			;    or      b     	; 4 
0b0e			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0e			;endif 
0b0e c1			    pop bc 
0b0f			 
0b0f c9				ret 
0b10			 
0b10			 
0b10			 
0b10			; eof 
# End of file firmware_general.asm
0b10			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b10			; display routines that use the physical hardware abstraction layer 
0b10			 
0b10			 
0b10			; Display an activity indicator 
0b10			; Each call returns the new char pointed to in hl 
0b10			 
0b10			active: 
0b10 3a c6 eb			ld a, (display_active) 
0b13 fe 06			cp 6 
0b15			 
0b15 20 02			jr nz, .sne 
0b17				; gone past the last one reset sequence 
0b17 3e ff			ld a, 255 
0b19			 
0b19			.sne:   
0b19				; get the next char in seq 
0b19 3c				inc a 
0b1a 32 c6 eb			ld (display_active), a 
0b1d			 
0b1d				; look up the string in the table 
0b1d 21 34 0b			ld hl, actseq 
0b20 cb 27			sla a 
0b22 cd e6 0d			call addatohl 
0b25 cd 75 1f			call loadwordinhl 
0b28			 
0b28				; forth will write the to string when pushing so move from rom to ram 
0b28			 
0b28 11 c7 eb			ld de, display_active+1 
0b2b 01 02 00			ld bc, 2 
0b2e ed b0			ldir 
0b30			 
0b30 21 c7 eb			ld hl, display_active+1 
0b33 c9				ret 
0b34				 
0b34				 
0b34			 
0b34			 
0b34			;db "|/-\|-\" 
0b34			 
0b34			actseq: 
0b34			 
0b34 42 0b		dw spin0 
0b36 44 0b		dw spin1 
0b38 46 0b		dw spin2 
0b3a 48 0b		dw spin3 
0b3c 46 0b		dw spin2 
0b3e 44 0b		dw spin1 
0b40 42 0b		dw spin0 
0b42			 
0b42 .. 00		spin0: db " ", 0 
0b44 .. 00		spin1: db "-", 0 
0b46 .. 00		spin2: db "+", 0 
0b48 .. 00		spin3: db "#", 0 
0b4a			 
0b4a			 
0b4a			; information window 
0b4a			 
0b4a			; pass hl with 1st string to display 
0b4a			; pass de with 2nd string to display 
0b4a			 
0b4a			info_panel: 
0b4a e5				push hl 
0b4b			 
0b4b 2a cc eb			ld hl, (display_fb_active) 
0b4e e5				push hl    ; future de destination 
0b4f 21 b1 ed				ld hl, display_fb0 
0b52 22 cc eb				ld (display_fb_active), hl 
0b55			 
0b55			;	call clear_display 
0b55			 
0b55				if BASE_CPM 
0b55 3e 2e			ld a, '.' 
0b57				else 
0b57				ld a, 165 
0b57				endif 
0b57 cd be 0b			call fill_display 
0b5a			 
0b5a			 
0b5a 3e 55			ld a, display_row_3 + 5 
0b5c cd cc 0b			call str_at_display 
0b5f			 
0b5f e1				pop hl 
0b60 d1				pop de 
0b61			 
0b61 e5				push hl 
0b62			 
0b62			 
0b62 3e 2d			ld a, display_row_2 + 5 
0b64 cd cc 0b			call str_at_display 
0b67			 
0b67			 
0b67 cd dc 0b			call update_display 
0b6a cd be 1b			call next_page_prompt 
0b6d cd b9 0b			call clear_display 
0b70			 
0b70				 
0b70 21 10 ed				ld hl, display_fb1 
0b73 22 cc eb				ld (display_fb_active), hl 
0b76 cd dc 0b			call update_display 
0b79			 
0b79 e1				pop hl 
0b7a			 
0b7a c9				ret 
0b7b			 
0b7b			 
0b7b			 
0b7b			 
0b7b			; TODO windowing? 
0b7b			 
0b7b			; TODO scroll line up 
0b7b			 
0b7b			scroll_up: 
0b7b			 
0b7b e5				push hl 
0b7c d5				push de 
0b7d c5				push bc 
0b7e			 
0b7e				; get frame buffer  
0b7e			 
0b7e 2a cc eb			ld hl, (display_fb_active) 
0b81 e5				push hl    ; future de destination 
0b82			 
0b82 11 28 00			ld  de, display_cols 
0b85 19				add hl, de 
0b86			 
0b86 d1				pop de 
0b87			 
0b87				;ex de, hl 
0b87 01 9f 00			ld bc, display_fb_len -1  
0b8a			;if DEBUG_FORTH_WORDS 
0b8a			;	DMARK "SCL" 
0b8a			;	CALLMONITOR 
0b8a			;endif	 
0b8a ed b0			ldir 
0b8c			 
0b8c				; wipe bottom row 
0b8c			 
0b8c			 
0b8c 2a cc eb			ld hl, (display_fb_active) 
0b8f 11 a0 00			ld de, display_cols*display_rows 
0b92 19				add hl, de 
0b93 06 28			ld b, display_cols 
0b95 3e 20			ld a, ' ' 
0b97			.scwipe: 
0b97 77				ld (hl), a 
0b98 2b				dec hl 
0b99 10 fc			djnz .scwipe 
0b9b			 
0b9b				;pop hl 
0b9b			 
0b9b c1				pop bc 
0b9c d1				pop de 
0b9d e1				pop hl 
0b9e			 
0b9e c9				ret 
0b9f			 
0b9f			 
0b9f			;scroll_upo: 
0b9f			;	ld de, display_row_1 
0b9f			 ;	ld hl, display_row_2 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			;	ld de, display_row_2 
0b9f			 ;	ld hl, display_row_3 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			;	ld de, display_row_3 
0b9f			 ;	ld hl, display_row_4 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			 
0b9f			; TODO clear row 4 
0b9f			 
0b9f			;	ret 
0b9f			 
0b9f				 
0b9f			scroll_down: 
0b9f			 
0b9f e5				push hl 
0ba0 d5				push de 
0ba1 c5				push bc 
0ba2			 
0ba2				; get frame buffer  
0ba2			 
0ba2 2a cc eb			ld hl, (display_fb_active) 
0ba5			 
0ba5 11 9f 00			ld de, display_fb_len - 1 
0ba8 19				add hl, de 
0ba9			 
0ba9 e5			push hl    ; future de destination 
0baa			 
0baa 11 28 00			ld  de, display_cols 
0bad ed 52			sbc hl, de 
0baf			 
0baf			 
0baf d1				pop de 
0bb0			 
0bb0			;	ex de, hl 
0bb0 01 9f 00			ld bc, display_fb_len -1  
0bb3			 
0bb3			 
0bb3				 
0bb3			 
0bb3 ed b0			ldir 
0bb5			 
0bb5				; wipe bottom row 
0bb5			 
0bb5			 
0bb5			;	ld hl, (display_fb_active) 
0bb5			;;	ld de, display_cols*display_rows 
0bb5			;;	add hl, de 
0bb5			;	ld b, display_cols 
0bb5			;	ld a, ' ' 
0bb5			;.scwiped: 
0bb5			;	ld (hl), a 
0bb5			;	dec hl 
0bb5			;	djnz .scwiped 
0bb5			 
0bb5				;pop hl 
0bb5			 
0bb5 c1				pop bc 
0bb6 d1				pop de 
0bb7 e1				pop hl 
0bb8			 
0bb8 c9				ret 
0bb9			;scroll_down: 
0bb9			;	ld de, display_row_4 
0bb9			;	ld hl, display_row_3 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;	ld de, display_row_3 
0bb9			; 	ld hl, display_row_2 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;	ld de, display_row_2 
0bb9			;	ld hl, display_row_1 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;;; TODO clear row 1 
0bb9			;	ret 
0bb9			 
0bb9			 
0bb9			 
0bb9			 
0bb9			 
0bb9			; clear active frame buffer 
0bb9			 
0bb9			clear_display: 
0bb9 3e 20			ld a, ' ' 
0bbb c3 be 0b			jp fill_display 
0bbe			 
0bbe			; fill active frame buffer with a char in A 
0bbe			 
0bbe			fill_display: 
0bbe 06 a0			ld b,display_fb_len 
0bc0 2a cc eb			ld hl, (display_fb_active) 
0bc3 77			.fd1:	ld (hl),a 
0bc4 23				inc hl 
0bc5 10 fc			djnz .fd1 
0bc7 23				inc hl 
0bc8 3e 00			ld a,0 
0bca 77				ld (hl),a 
0bcb			 
0bcb			 
0bcb c9				ret 
0bcc			; Write string (DE) at pos (A) to active frame buffer 
0bcc			 
0bcc 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
0bcf 06 00					ld b,0 
0bd1 4f					ld c,a 
0bd2 09					add hl,bc 
0bd3 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bd4 b7			            OR   A              ;Null terminator? 
0bd5 c8			            RET  Z              ;Yes, so finished 
0bd6 77					ld (hl),a 
0bd7 23				inc hl 
0bd8 13			            INC  DE             ;Point to next character 
0bd9 18 f8		            JR   .sad1     ;Repeat 
0bdb c9					ret 
0bdc			 
0bdc			; using current frame buffer write to physical display 
0bdc			 
0bdc			update_display: 
0bdc e5				push hl 
0bdd 2a cc eb			ld hl, (display_fb_active) 
0be0 cd 01 65			call write_display 
0be3 e1				pop hl 
0be4 c9				ret 
0be5			 
0be5			; TODO scrolling 
0be5			 
0be5			 
0be5			; move cursor right one char 
0be5			cursor_right: 
0be5			 
0be5				; TODO shift right 
0be5				; TODO if beyond max col 
0be5				; TODO       cursor_next_line 
0be5			 
0be5 c9				ret 
0be6			 
0be6			 
0be6			cursor_next_line: 
0be6				; TODO first char 
0be6				; TODO line down 
0be6				; TODO if past last row 
0be6				; TODO    scroll up 
0be6			 
0be6 c9				ret 
0be7			 
0be7			cursor_left: 
0be7				; TODO shift left 
0be7				; TODO if beyond left  
0be7				; TODO     cursor prev line 
0be7				 
0be7 c9				ret 
0be8			 
0be8			cursor_prev_line: 
0be8				; TODO last char 
0be8				; TODO line up 
0be8				; TODO if past first row 
0be8				; TODO   scroll down 
0be8			 
0be8 c9				ret 
0be9			 
0be9			 
0be9			cout: 
0be9				; A - char 
0be9 c9				ret 
0bea			 
0bea			 
0bea			; Display a menu and allow item selection (optional toggle items) 
0bea			; 
0bea			; format: 
0bea			; hl pointer to word array with zero term for items 
0bea			; e.g.    db item1 
0bea			;         db .... 
0bea			;         db 0 
0bea			; 
0bea			; a = starting menu item  
0bea			; 
0bea			; de = pointer item toggle array   (todo) 
0bea			; 
0bea			; returns item selected in a 1-... 
0bea			; returns 0 if back button pressed 
0bea			; 
0bea			; NOTE: Uses system frame buffer to display 
0bea			; 
0bea			; LEFT, Q = go back 
0bea			; RIGHT, SPACE, CR = select 
0bea			; UP, A - Up 
0bea			; DOWN, Z - Down 
0bea			 
0bea			 
0bea			 
0bea			 
0bea			 
0bea			menu: 
0bea			 
0bea					; keep array pointer 
0bea			 
0bea 22 73 ea				ld (store_tmp1), hl 
0bed 32 71 ea				ld (store_tmp2), a 
0bf0			 
0bf0					; check for key bounce 
0bf0			 
0bf0			if BASE_KEV 
0bf0			 
0bf0			.mbounce:	call cin 
0bf0					cp 0 
0bf0					jr nz, .mbounce 
0bf0			endif 
0bf0					; for ease use ex 
0bf0			 
0bf0					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bf0 21 b1 ed				ld hl, display_fb0 
0bf3 22 cc eb				ld (display_fb_active), hl 
0bf6			 
0bf6 cd b9 0b		.mloop:		call clear_display 
0bf9 cd dc 0b				call update_display 
0bfc			 
0bfc					; draw selection id '>' at 1 
0bfc			 
0bfc					; init start of list display 
0bfc			 
0bfc 3e 05				ld a, 5 
0bfe 32 6f ea				ld (store_tmp3), a   ; display row count 
0c01 3a 71 ea				ld a,( store_tmp2) 
0c04 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c07			 
0c07					 
0c07			.mitem:	 
0c07			 
0c07			 
0c07 3a 72 ea				ld a,(store_tmp2+1) 
0c0a 6f					ld l, a 
0c0b 26 00				ld h, 0 
0c0d 29					add hl, hl 
0c0e ed 5b 73 ea			ld de, (store_tmp1) 
0c12 19					add hl, de 
0c13 7e					ld a, (hl) 
0c14 23					inc hl 
0c15 66					ld h,(hl) 
0c16 6f					ld l, a 
0c17			 
0c17 cd 0f 0e				call ishlzero 
0c1a 28 1a				jr z, .mdone 
0c1c			 
0c1c eb					ex de, hl 
0c1d 3a 6f ea				ld a, (store_tmp3) 
0c20 cd cc 0b				call str_at_display 
0c23					 
0c23			 
0c23					; next item 
0c23 3a 72 ea				ld a, (store_tmp2+1) 
0c26 3c					inc a 
0c27 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c2a			 
0c2a			 		; next row 
0c2a			 
0c2a 3a 6f ea				ld a, (store_tmp3) 
0c2d c6 28				add display_cols 
0c2f 32 6f ea				ld (store_tmp3), a 
0c32			 
0c32					; at end of screen? 
0c32			 
0c32 fe 10				cp display_rows*4 
0c34 20 d1				jr nz, .mitem 
0c36			 
0c36			 
0c36			.mdone: 
0c36 cd 0f 0e				call ishlzero 
0c39 28 08				jr z, .nodn 
0c3b			 
0c3b 3e 78				ld a, display_row_4 
0c3d 11 bc 0c				ld de, .mdown 
0c40 cd cc 0b				call str_at_display 
0c43			 
0c43					; draw options to fill the screens with active item on line 1 
0c43					; if current option is 2 or more then display ^ in top 
0c43			 
0c43 3a 71 ea		.nodn:		ld a, (store_tmp2) 
0c46 fe 00				cp 0 
0c48 28 08				jr z, .noup 
0c4a			 
0c4a 3e 00				ld a, 0 
0c4c 11 ba 0c				ld de, .mup 
0c4f cd cc 0b				call str_at_display 
0c52			 
0c52 3e 02		.noup:		ld a, 2 
0c54 11 b8 0c				ld de, .msel 
0c57 cd cc 0b				call str_at_display 
0c5a			 
0c5a					; if current option + 1 is not null then display V in bottom 
0c5a					; get key 
0c5a cd dc 0b				call update_display 
0c5d			 
0c5d			 
0c5d					; handle key 
0c5d			 
0c5d cd b3 65				call cin_wait 
0c60			 
0c60 fe 05				cp KEY_UP 
0c62 28 2b				jr z, .mgoup 
0c64 fe 61				cp 'a' 
0c66 28 27				jr z, .mgoup 
0c68 fe 0a				cp KEY_DOWN 
0c6a 28 32				jr z, .mgod 
0c6c fe 7a				cp 'z' 
0c6e 28 2e				jr z, .mgod 
0c70 fe 20				cp ' ' 
0c72 28 34				jr z, .goend 
0c74 fe 0c				cp KEY_RIGHT 
0c76 28 30				jr z, .goend 
0c78 fe 0d				cp KEY_CR 
0c7a 28 2c				jr z, .goend 
0c7c fe 71				cp 'q' 
0c7e 28 0b				jr z, .goback 
0c80			 
0c80 fe 0b				cp KEY_LEFT 
0c82 28 07				jr z, .goback 
0c84 fe 08				cp KEY_BS 
0c86 28 03				jr z, .goback 
0c88 c3 f6 0b				jp .mloop 
0c8b			 
0c8b			.goback: 
0c8b 3e 00			ld a, 0 
0c8d 18 1d			jr .goend2 
0c8f			 
0c8f				; move up one 
0c8f			.mgoup: 
0c8f 3a 71 ea				ld a, (store_tmp2) 
0c92 fe 00				cp 0 
0c94 ca f6 0b				jp z, .mloop 
0c97 3d					dec a 
0c98 32 71 ea				ld (store_tmp2), a 
0c9b c3 f6 0b				jp .mloop 
0c9e			 
0c9e				; move down one 
0c9e			.mgod: 
0c9e 3a 71 ea				ld a, (store_tmp2) 
0ca1 3c					inc a 
0ca2 32 71 ea				ld (store_tmp2), a 
0ca5 c3 f6 0b				jp .mloop 
0ca8			 
0ca8			 
0ca8			.goend: 
0ca8					; get selected item number 
0ca8			 
0ca8 3a 71 ea				ld a, (store_tmp2) 
0cab 3c					inc a 
0cac			 
0cac			.goend2: 
0cac f5					push af 
0cad			 
0cad					; restore active fb 
0cad					; TODO BUG assumes fb1 
0cad			 
0cad 21 10 ed				ld hl, display_fb1 
0cb0 22 cc eb				ld (display_fb_active), hl 
0cb3			 
0cb3					; restore main regs 
0cb3			 
0cb3			 
0cb3 cd dc 0b				call update_display 
0cb6			 
0cb6 f1					pop af 
0cb7			 
0cb7 c9				ret 
0cb8			 
0cb8 .. 00		.msel:   db ">",0 
0cba .. 00		.mup:   db "^",0 
0cbc .. 00		.mdown:   db "v",0 
0cbe			 
0cbe			 
0cbe			; eof 
0cbe			 
# End of file firmware_display.asm
0cbe			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cbe			; random number generators 
0cbe			 
0cbe			 
0cbe			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cbe			 
0cbe			 
0cbe			;-----> Generate a random number 
0cbe			; output a=answer 0<=a<=255 
0cbe			; all registers are preserved except: af 
0cbe			random: 
0cbe e5			        push    hl 
0cbf d5			        push    de 
0cc0 2a ab eb		        ld      hl,(randData) 
0cc3 ed 5f		        ld      a,r 
0cc5 57			        ld      d,a 
0cc6 5e			        ld      e,(hl) 
0cc7 19			        add     hl,de 
0cc8 85			        add     a,l 
0cc9 ac			        xor     h 
0cca 22 ab eb		        ld      (randData),hl 
0ccd d1			        pop     de 
0cce e1			        pop     hl 
0ccf c9			        ret 
0cd0			 
0cd0			 
0cd0			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cd0			 
0cd0			 
0cd0			 
0cd0			;------LFSR------ 
0cd0			;James Montelongo 
0cd0			;optimized by Spencer Putt 
0cd0			;out: 
0cd0			; a = 8 bit random number 
0cd0			RandLFSR: 
0cd0 21 b1 eb		        ld hl,LFSRSeed+4 
0cd3 5e			        ld e,(hl) 
0cd4 23			        inc hl 
0cd5 56			        ld d,(hl) 
0cd6 23			        inc hl 
0cd7 4e			        ld c,(hl) 
0cd8 23			        inc hl 
0cd9 7e			        ld a,(hl) 
0cda 47			        ld b,a 
0cdb cb 13		        rl e  
0cdd cb 12			rl d 
0cdf cb 11		        rl c  
0ce1 17				rla 
0ce2 cb 13		        rl e  
0ce4 cb 12			rl d 
0ce6 cb 11		        rl c  
0ce8 17				rla 
0ce9 cb 13		        rl e  
0ceb cb 12			rl d 
0ced cb 11		        rl c  
0cef 17				rla 
0cf0 67			        ld h,a 
0cf1 cb 13		        rl e  
0cf3 cb 12			rl d 
0cf5 cb 11		        rl c  
0cf7 17				rla 
0cf8 a8			        xor b 
0cf9 cb 13		        rl e  
0cfb cb 12			rl d 
0cfd ac			        xor h 
0cfe a9			        xor c 
0cff aa			        xor d 
0d00 21 b3 eb		        ld hl,LFSRSeed+6 
0d03 11 b4 eb		        ld de,LFSRSeed+7 
0d06 01 07 00		        ld bc,7 
0d09 ed b8		        lddr 
0d0b 12			        ld (de),a 
0d0c c9			        ret 
0d0d			 
0d0d			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d0d			 
0d0d			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d0d			 
0d0d			 
0d0d			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d0d			 
0d0d			prng16: 
0d0d			;Inputs: 
0d0d			;   (seed1) contains a 16-bit seed value 
0d0d			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d0d			;Outputs: 
0d0d			;   HL is the result 
0d0d			;   BC is the result of the LCG, so not that great of quality 
0d0d			;   DE is preserved 
0d0d			;Destroys: 
0d0d			;   AF 
0d0d			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d0d			;160cc 
0d0d			;26 bytes 
0d0d 2a a5 eb		    ld hl,(seed1) 
0d10 44			    ld b,h 
0d11 4d			    ld c,l 
0d12 29			    add hl,hl 
0d13 29			    add hl,hl 
0d14 2c			    inc l 
0d15 09			    add hl,bc 
0d16 22 a5 eb		    ld (seed1),hl 
0d19 2a a3 eb		    ld hl,(seed2) 
0d1c 29			    add hl,hl 
0d1d 9f			    sbc a,a 
0d1e e6 2d		    and %00101101 
0d20 ad			    xor l 
0d21 6f			    ld l,a 
0d22 22 a3 eb		    ld (seed2),hl 
0d25 09			    add hl,bc 
0d26 c9			    ret 
0d27			 
0d27			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d27			 
0d27			rand32: 
0d27			;Inputs: 
0d27			;   (seed1_0) holds the lower 16 bits of the first seed 
0d27			;   (seed1_1) holds the upper 16 bits of the first seed 
0d27			;   (seed2_0) holds the lower 16 bits of the second seed 
0d27			;   (seed2_1) holds the upper 16 bits of the second seed 
0d27			;   **NOTE: seed2 must be non-zero 
0d27			;Outputs: 
0d27			;   HL is the result 
0d27			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d27			;Destroys: 
0d27			;   AF 
0d27			;Tested and passes all CAcert tests 
0d27			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d27			;it has a period of 18,446,744,069,414,584,320 
0d27			;roughly 18.4 quintillion. 
0d27			;LFSR taps: 0,2,6,7  = 11000101 
0d27			;291cc 
0d27			;seed1_0=$+1 
0d27			;    ld hl,12345 
0d27			;seed1_1=$+1 
0d27			;    ld de,6789 
0d27			;    ld b,h 
0d27			;    ld c,l 
0d27			;    add hl,hl \ rl e \ rl d 
0d27			;    add hl,hl \ rl e \ rl d 
0d27			;    inc l 
0d27			;    add hl,bc 
0d27			;    ld (seed1_0),hl 
0d27			;    ld hl,(seed1_1) 
0d27			;    adc hl,de 
0d27			;    ld (seed1_1),hl 
0d27			;    ex de,hl 
0d27			;seed2_0=$+1 
0d27			;    ld hl,9876 
0d27			;seed2_1=$+1 
0d27			;    ld bc,54321 
0d27			;    add hl,hl \ rl c \ rl b 
0d27			;    ld (seed2_1),bc 
0d27			;    sbc a,a 
0d27			;    and %11000101 
0d27			;    xor l 
0d27			;    ld l,a 
0d27			;    ld (seed2_0),hl 
0d27			;    ex de,hl 
0d27			;    add hl,bc 
0d27			;    ret 
0d27			; 
0d27			 
0d27			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d27			; 20 bytes, 86 cycles (excluding ret) 
0d27			 
0d27			; returns   hl = pseudorandom number 
0d27			; corrupts   a 
0d27			 
0d27			; generates 16-bit pseudorandom numbers with a period of 65535 
0d27			; using the xorshift method: 
0d27			 
0d27			; hl ^= hl << 7 
0d27			; hl ^= hl >> 9 
0d27			; hl ^= hl << 8 
0d27			 
0d27			; some alternative shift triplets which also perform well are: 
0d27			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d27			 
0d27			;  org 32768 
0d27			 
0d27			xrnd: 
0d27 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d2a 3e 00		  ld a,0 
0d2c bd			  cp l 
0d2d 20 02		  jr nz, .xrnd1 
0d2f 2e 01		  ld l, 1 
0d31			.xrnd1: 
0d31			 
0d31 7c			  ld a,h 
0d32 1f			  rra 
0d33 7d			  ld a,l 
0d34 1f			  rra 
0d35 ac			  xor h 
0d36 67			  ld h,a 
0d37 7d			  ld a,l 
0d38 1f			  rra 
0d39 7c			  ld a,h 
0d3a 1f			  rra 
0d3b ad			  xor l 
0d3c 6f			  ld l,a 
0d3d ac			  xor h 
0d3e 67			  ld h,a 
0d3f			 
0d3f 22 a9 eb		  ld (xrandc),hl 
0d42			 
0d42 c9			  ret 
0d43			;  
0d43			 
0d43			 
0d43			;;;; int maths 
0d43			 
0d43			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d43			; Divide 16-bit values (with 16-bit result) 
0d43			; In: Divide BC by divider DE 
0d43			; Out: BC = result, HL = rest 
0d43			; 
0d43			Div16: 
0d43 21 00 00		    ld hl,0 
0d46 78			    ld a,b 
0d47 06 08		    ld b,8 
0d49			Div16_Loop1: 
0d49 17			    rla 
0d4a ed 6a		    adc hl,hl 
0d4c ed 52		    sbc hl,de 
0d4e 30 01		    jr nc,Div16_NoAdd1 
0d50 19			    add hl,de 
0d51			Div16_NoAdd1: 
0d51 10 f6		    djnz Div16_Loop1 
0d53 17			    rla 
0d54 2f			    cpl 
0d55 47			    ld b,a 
0d56 79			    ld a,c 
0d57 48			    ld c,b 
0d58 06 08		    ld b,8 
0d5a			Div16_Loop2: 
0d5a 17			    rla 
0d5b ed 6a		    adc hl,hl 
0d5d ed 52		    sbc hl,de 
0d5f 30 01		    jr nc,Div16_NoAdd2 
0d61 19			    add hl,de 
0d62			Div16_NoAdd2: 
0d62 10 f6		    djnz Div16_Loop2 
0d64 17			    rla 
0d65 2f			    cpl 
0d66 41			    ld b,c 
0d67 4f			    ld c,a 
0d68 c9			ret 
0d69			 
0d69			 
0d69			;http://z80-heaven.wikidot.com/math 
0d69			; 
0d69			;Inputs: 
0d69			;     DE and A are factors 
0d69			;Outputs: 
0d69			;     A is not changed 
0d69			;     B is 0 
0d69			;     C is not changed 
0d69			;     DE is not changed 
0d69			;     HL is the product 
0d69			;Time: 
0d69			;     342+6x 
0d69			; 
0d69			Mult16: 
0d69			 
0d69 06 08		     ld b,8          ;7           7 
0d6b 21 00 00		     ld hl,0         ;10         10 
0d6e 29			       add hl,hl     ;11*8       88 
0d6f 07			       rlca          ;4*8        32 
0d70 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d72 19			         add hl,de   ;--         -- 
0d73 10 f9		       djnz $-5      ;13*7+8     99 
0d75 c9			ret 
0d76			 
0d76			; 
0d76			; Square root of 16-bit value 
0d76			; In:  HL = value 
0d76			; Out:  D = result (rounded down) 
0d76			; 
0d76			;Sqr16: 
0d76			;    ld de,#0040 
0d76			;    ld a,l 
0d76			;    ld l,h 
0d76			;    ld h,d 
0d76			;    or a 
0d76			;    ld b,8 
0d76			;Sqr16_Loop: 
0d76			;    sbc hl,de 
0d76			;    jr nc,Sqr16_Skip 
0d76			;    add hl,de 
0d76			;Sqr16_Skip: 
0d76			;    ccf 
0d76			;    rl d 
0d76			;    add a,a 
0d76			;    adc hl,hl 
0d76			;    add a,a 
0d76			;    adc hl,hl 
0d76			;    djnz Sqr16_Loop 
0d76			;    ret 
0d76			; 
0d76			; 
0d76			; Divide 8-bit values 
0d76			; In: Divide E by divider C 
0d76			; Out: A = result, B = rest 
0d76			; 
0d76			Div8: 
0d76 af			    xor a 
0d77 06 08		    ld b,8 
0d79			Div8_Loop: 
0d79 cb 13		    rl e 
0d7b 17			    rla 
0d7c 91			    sub c 
0d7d 30 01		    jr nc,Div8_NoAdd 
0d7f 81			    add a,c 
0d80			Div8_NoAdd: 
0d80 10 f7		    djnz Div8_Loop 
0d82 47			    ld b,a 
0d83 7b			    ld a,e 
0d84 17			    rla 
0d85 2f			    cpl 
0d86 c9			    ret 
0d87			 
0d87			; 
0d87			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d87			; In: Multiply A with DE 
0d87			; Out: HL = result 
0d87			; 
0d87			Mult12U: 
0d87 2e 00		    ld l,0 
0d89 87			    add a,a 
0d8a 30 01		    jr nc,Mult12U_NoAdd0 
0d8c 19			    add hl,de 
0d8d			Mult12U_NoAdd0: 
0d8d 29			    add hl,hl 
0d8e 87			    add a,a 
0d8f 30 01		    jr nc,Mult12U_NoAdd1 
0d91 19			    add hl,de 
0d92			Mult12U_NoAdd1: 
0d92 29			    add hl,hl 
0d93 87			    add a,a 
0d94 30 01		    jr nc,Mult12U_NoAdd2 
0d96 19			    add hl,de 
0d97			Mult12U_NoAdd2: 
0d97 29			    add hl,hl 
0d98 87			    add a,a 
0d99 30 01		    jr nc,Mult12U_NoAdd3 
0d9b 19			    add hl,de 
0d9c			Mult12U_NoAdd3: 
0d9c 29			    add hl,hl 
0d9d 87			    add a,a 
0d9e 30 01		    jr nc,Mult12U_NoAdd4 
0da0 19			    add hl,de 
0da1			Mult12U_NoAdd4: 
0da1 29			    add hl,hl 
0da2 87			    add a,a 
0da3 30 01		    jr nc,Mult12U_NoAdd5 
0da5 19			    add hl,de 
0da6			Mult12U_NoAdd5: 
0da6 29			    add hl,hl 
0da7 87			    add a,a 
0da8 30 01		    jr nc,Mult12U_NoAdd6 
0daa 19			    add hl,de 
0dab			Mult12U_NoAdd6: 
0dab 29			    add hl,hl 
0dac 87			    add a,a 
0dad d0			    ret nc 
0dae 19			    add hl,de 
0daf c9			    ret 
0db0			 
0db0			; 
0db0			; Multiply 8-bit value with a 16-bit value (right rotating) 
0db0			; In: Multiply A with DE 
0db0			;      Put lowest value in A for most efficient calculation 
0db0			; Out: HL = result 
0db0			; 
0db0			Mult12R: 
0db0 21 00 00		    ld hl,0 
0db3			Mult12R_Loop: 
0db3 cb 3f		    srl a 
0db5 30 01		    jr nc,Mult12R_NoAdd 
0db7 19			    add hl,de 
0db8			Mult12R_NoAdd: 
0db8 cb 23		    sla e 
0dba cb 12		    rl d 
0dbc b7			    or a 
0dbd c2 b3 0d		    jp nz,Mult12R_Loop 
0dc0 c9			    ret 
0dc1			 
0dc1			; 
0dc1			; Multiply 16-bit values (with 32-bit result) 
0dc1			; In: Multiply BC with DE 
0dc1			; Out: BCHL = result 
0dc1			; 
0dc1			Mult32: 
0dc1 79			    ld a,c 
0dc2 48			    ld c,b 
0dc3 21 00 00		    ld hl,0 
0dc6 06 10		    ld b,16 
0dc8			Mult32_Loop: 
0dc8 29			    add hl,hl 
0dc9 17			    rla 
0dca cb 11		    rl c 
0dcc 30 07		    jr nc,Mult32_NoAdd 
0dce 19			    add hl,de 
0dcf ce 00		    adc a,0 
0dd1 d2 d5 0d		    jp nc,Mult32_NoAdd 
0dd4 0c			    inc c 
0dd5			Mult32_NoAdd: 
0dd5 10 f1		    djnz Mult32_Loop 
0dd7 41			    ld b,c 
0dd8 4f			    ld c,a 
0dd9 c9			    ret 
0dda			 
0dda			 
0dda			 
0dda			; 
0dda			; Multiply 8-bit values 
0dda			; In:  Multiply H with E 
0dda			; Out: HL = result 
0dda			; 
0dda			Mult8: 
0dda 16 00		    ld d,0 
0ddc 6a			    ld l,d 
0ddd 06 08		    ld b,8 
0ddf			Mult8_Loop: 
0ddf 29			    add hl,hl 
0de0 30 01		    jr nc,Mult8_NoAdd 
0de2 19			    add hl,de 
0de3			Mult8_NoAdd: 
0de3 10 fa		    djnz Mult8_Loop 
0de5 c9			    ret 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			;;http://z80-heaven.wikidot.com/math 
0de6			;;This divides DE by BC, storing the result in DE, remainder in HL 
0de6			; 
0de6			;DE_Div_BC:          ;1281-2x, x is at most 16 
0de6			;     ld a,16        ;7 
0de6			;     ld hl,0        ;10 
0de6			;     jp $+5         ;10 
0de6			;.DivLoop: 
0de6			;       add hl,bc    ;-- 
0de6			;       dec a        ;64 
0de6			;       jr z,.DivLoopEnd        ;86 
0de6			; 
0de6			;       sla e        ;128 
0de6			;       rl d         ;128 
0de6			;       adc hl,hl    ;240 
0de6			;       sbc hl,bc    ;240 
0de6			;       jr nc,.DivLoop ;23|21 
0de6			;       inc e        ;-- 
0de6			;       jp .DivLoop+1 
0de6			; 
0de6			;.DivLoopEnd: 
0de6			 
0de6			;HL_Div_C: 
0de6			;Inputs: 
0de6			;     HL is the numerator 
0de6			;     C is the denominator 
0de6			;Outputs: 
0de6			;     A is the remainder 
0de6			;     B is 0 
0de6			;     C is not changed 
0de6			;     DE is not changed 
0de6			;     HL is the quotient 
0de6			; 
0de6			;       ld b,16 
0de6			;       xor a 
0de6			;         add hl,hl 
0de6			;         rla 
0de6			;         cp c 
0de6			;         jr c,$+4 
0de6			;           inc l 
0de6			;           sub c 
0de6			;         djnz $-7 
0de6			 
0de6			; https://plutiedev.com/z80-add-8bit-to-16bit 
0de6			 
0de6			addatohl: 
0de6 85			    add   a, l    ; A = A+L 
0de7 6f			    ld    l, a    ; L = A+L 
0de8 8c			    adc   a, h    ; A = A+L+H+carry 
0de9 95			    sub   l       ; A = H+carry 
0dea 67			    ld    h, a    ; H = H+carry 
0deb c9			ret 
0dec			 
0dec			addatode: 
0dec 83			    add   a, e    ; A = A+L 
0ded 5f			    ld    e, a    ; L = A+L 
0dee 8a			    adc   a, d    ; A = A+L+H+carry 
0def 93			    sub   e       ; A = H+carry 
0df0 57			    ld    d, a    ; H = H+carry 
0df1 c9			ret 
0df2			 
0df2			 
0df2			addatobc: 
0df2 81			    add   a, c    ; A = A+L 
0df3 4f			    ld    c, a    ; L = A+L 
0df4 88			    adc   a, b    ; A = A+L+H+carry 
0df5 91			    sub   c       ; A = H+carry 
0df6 47			    ld    b, a    ; H = H+carry 
0df7 c9			ret 
0df8			 
0df8			subafromhl: 
0df8			   ; If A=0 do nothing 
0df8			    ; Otherwise flip A's sign. Since 
0df8			    ; the upper byte becomes -1, also 
0df8			    ; substract 1 from H. 
0df8 ed 44		    neg 
0dfa ca 03 0e		    jp    z, Skip 
0dfd 25			    dec   h 
0dfe			     
0dfe			    ; Now add the low byte as usual 
0dfe			    ; Two's complement takes care of 
0dfe			    ; ensuring the result is correct 
0dfe 85			    add   a, l 
0dff 6f			    ld    l, a 
0e00 8c			    adc   a, h 
0e01 95			    sub   l 
0e02 67			    ld    h, a 
0e03			Skip: 
0e03 c9				ret 
0e04			 
0e04			 
0e04			; compare hl and de 
0e04			; returns:  
0e04			; if hl = de, z=1, s=0, c0=0 
0e04			; if hl > de, z=0, s=0, c=0 
0e04			; if hl < de, z=0, s=1, c=1 
0e04			cmp16:	 
0e04 b7				or a 
0e05 ed 52			sbc hl,de 
0e07 e0				ret po 
0e08 7c				ld a,h 
0e09 1f				rra 
0e0a ee 40			xor 01000000B 
0e0c 37				scf 
0e0d 8f				adc a,a 
0e0e c9				ret 
0e0f			 
0e0f			 
0e0f			; test if hl contains zero   - A is destroyed 
0e0f			 
0e0f			ishlzero:    
0e0f b7				or a     ; reset flags 
0e10 7c				ld a, h 
0e11 b5				or l        	 
0e12			 
0e12 c9				ret 
0e13			 
0e13			 
0e13			 
0e13			 
0e13			if FORTH_ENABLE_FLOATMATH 
0e13			;include "float/bbcmath.z80" 
0e13			include "float/lpfpcalc.asm" 
0e13			endif 
0e13			 
0e13			 
0e13			; eof 
0e13			 
# End of file firmware_maths.asm
0e13			include "firmware_strings.asm"   ; string handling  
0e13			 
0e13			 
0e13			; TODO string len 
0e13			; input text string, end on cr with zero term 
0e13			; a offset into frame buffer to start prompt 
0e13			; d is max length 
0e13			; e is display size TODO 
0e13			; c is current cursor position 
0e13			; hl is ptr to where string will be stored 
0e13			 
0e13			 
0e13			; TODO check limit of buffer for new inserts 
0e13			; TODO check insert does not push beyond buffer 
0e13			; TODO scroll in a limited display area 
0e13			; TODO scroll whole screen on page wrap 
0e13			 
0e13			 
0e13			; TODO handle KEY_PREVWORD 
0e13			; TODO handle KEY_NEXTWORD 
0e13			; TODO handle KEY_HOME 
0e13			; TODO handle KEY_END 
0e13			; TODO use LCD cursor? 
0e13			 
0e13 32 64 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0e16 81					add c 
0e17 32 62 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0e1a 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
0e1d 79					ld a, c 
0e1e cd e6 0d				call addatohl 
0e21 22 69 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0e24 7a					ld a,d 
0e25 32 66 ee			        ld (input_size), a       ; save length of input area 
0e28 79					ld a, c 
0e29 32 55 ee				ld (input_cursor),a      ; init cursor start position  
0e2c 7b					ld a,e 
0e2d 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e30					 
0e30					 
0e30			 
0e30			;		ld a,(input_ptr) 
0e30			;		ld (input_under_cursor),a 	; save what is under the cursor 
0e30			 
0e30			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e30					; init cursor shape if not set by the cin routines 
0e30 21 c1 eb				ld hl, cursor_shape 
0e33 3e ff				ld a, 255 
0e35 77					ld (hl), a 
0e36 23					inc hl 
0e37 3e 00				ld a, 0 
0e39 77					ld (hl), a 
0e3a			 
0e3a 3e 0f				ld a, CUR_BLINK_RATE 
0e3c 32 60 ee				ld (input_cur_flash), a 
0e3f 3e 01				ld a, 1 
0e41 32 5f ee				ld (input_cur_onoff),a 
0e44			 
0e44			;	if DEBUG_INPUT 
0e44			;		push af 
0e44			;		ld a, 'I' 
0e44			;		ld (debug_mark),a 
0e44			;		pop af 
0e44			;		CALLMONITOR 
0e44			;	endif 
0e44			.is1:		; main entry loop 
0e44			 
0e44			 
0e44			 
0e44					; pause 1ms 
0e44			 
0e44 3e 01				ld a, 1 
0e46 cd d6 0a				call aDelayInMS 
0e49			 
0e49					; dec flash counter 
0e49 3a 60 ee				ld a, (input_cur_flash) 
0e4c 3d					dec a 
0e4d 32 60 ee				ld (input_cur_flash), a 
0e50 fe 00				cp 0 
0e52 20 0d				jr nz, .nochgstate 
0e54			 
0e54			 
0e54					; change state 
0e54 3a 5f ee				ld a,(input_cur_onoff) 
0e57 ed 44				neg 
0e59 32 5f ee				ld (input_cur_onoff),a 
0e5c			 
0e5c			 
0e5c					; reset on change of state 
0e5c 3e 0f				ld a, CUR_BLINK_RATE 
0e5e 32 60 ee				ld (input_cur_flash), a 
0e61			 
0e61			.nochgstate: 
0e61					 
0e61					 
0e61			 
0e61					; display cursor  
0e61			 
0e61			;		ld hl, (input_start) 
0e61			;		ld a, (input_cursor) 
0e61			;		call addatohl 
0e61			 
0e61					; get char under cursor and replace with cursor 
0e61 2a 69 ee		ld hl, (input_ptr) 
0e64			;		ld a, (hl) 
0e64			;		ld (input_under_cursor),a 
0e64			;		ld a, '_' 
0e64			;		ld (hl), a 
0e64			 
0e64					; display string 
0e64			 
0e64 ed 5b 67 ee			ld de, (input_start) 
0e68 3a 64 ee				ld a, (input_at_pos) 
0e6b cd cc 0b				call str_at_display 
0e6e			;	        call update_display 
0e6e			 
0e6e					; find place to put the cursor 
0e6e			;		add h 
0e6e			;		ld l, display_row_1 
0e6e			;		sub l 
0e6e			; (input_at_pos) 
0e6e					;ld c, a 
0e6e			;		ld a, (input_cursor) 
0e6e			;		ld l, (input_at_pos) 
0e6e			;		;ld b, h 
0e6e			;		add l 
0e6e			;		ld (input_at_cursor),a 
0e6e					;ld l,h 
0e6e			 
0e6e			;		ld h, 0 
0e6e			;		ld l,(input_at_pos) 
0e6e			;		ld a, (input_cursor) 
0e6e			;		call addatohl 
0e6e			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0e6e			;		call subafromhl 
0e6e			;		ld a,l 
0e6e			;		ld (input_at_cursor), a 
0e6e			 
0e6e				if DEBUG_INPUT 
0e6e					ld a, (hardware_diag) 
0e6e					cp 0 
0e6e					jr z, .skip_input_diag 
0e6e			 
0e6e					ld a,(input_at_pos) 
0e6e					ld hl, LFSRSeed 
0e6e					call hexout 
0e6e					ld a, (input_cursor) 
0e6e					ld hl, LFSRSeed+2 
0e6e					call hexout 
0e6e					ld a,(input_at_cursor) 
0e6e					ld hl, LFSRSeed+4 
0e6e					call hexout 
0e6e			 
0e6e					ld a,(input_cur_onoff) 
0e6e					ld hl, LFSRSeed+6 
0e6e					call hexout 
0e6e			 
0e6e					ld a,(input_cur_flash) 
0e6e					ld hl, LFSRSeed+8 
0e6e					call hexout 
0e6e			 
0e6e					ld a,(input_len) 
0e6e					ld hl, LFSRSeed+10 
0e6e					call hexout 
0e6e					ld hl, LFSRSeed+12 
0e6e					ld a, 0 
0e6e					ld (hl),a 
0e6e					ld a, display_row_4 
0e6e					ld de, LFSRSeed 
0e6e					call str_at_display 
0e6e					.skip_input_diag: 
0e6e				endif 
0e6e			 
0e6e					; decide on if we are showing the cursor this time round 
0e6e			 
0e6e 3a 5f ee				ld a, (input_cur_onoff) 
0e71 fe ff				cp 255 
0e73 28 13				jr z, .skipcur 
0e75			 
0e75			 
0e75 3a 62 ee				ld a,(input_at_cursor) 
0e78 11 c1 eb				ld de, cursor_shape 
0e7b cd cc 0b				call str_at_display 
0e7e			 
0e7e					; save length of current input string 
0e7e 2a 67 ee				ld hl, (input_start) 
0e81 cd 44 12				call strlenz 
0e84 7d					ld a,l 
0e85 32 5a ee				ld (input_len),a 
0e88			 
0e88			.skipcur: 
0e88			 
0e88 cd dc 0b			        call update_display 
0e8b					 
0e8b			 
0e8b			 
0e8b					; wait 
0e8b				 
0e8b					; TODO loop without wait to flash the cursor and char under cursor	 
0e8b cd bb 65				call cin    ; _wait 
0e8e			 
0e8e fe 00				cp 0 
0e90 ca 44 0e				jp z, .is1 
0e93			 
0e93					; get ptr to char to input into 
0e93			 
0e93 4f					ld c,a 
0e94 2a 67 ee				ld hl, (input_start) 
0e97 3a 55 ee				ld a, (input_cursor) 
0e9a cd e6 0d				call addatohl 
0e9d 22 69 ee				ld (input_ptr), hl 
0ea0 79					ld a,c 
0ea1			 
0ea1					; replace char under cursor 
0ea1			 
0ea1			;		ld hl, (input_ptr) 
0ea1			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ea1			;		ld (hl), a 
0ea1			 
0ea1			;	if DEBUG_INPUT 
0ea1			;		push af 
0ea1			;		ld a, 'i' 
0ea1			;		ld (debug_mark),a 
0ea1			;		pop af 
0ea1			;		CALLMONITOR 
0ea1			;	endif 
0ea1 fe 0e				cp KEY_HOME 
0ea3 20 0e				jr nz, .iske 
0ea5			 
0ea5 3a 64 ee				ld a, (input_at_pos) 
0ea8 32 62 ee				ld (input_at_cursor),a 
0eab 3e 00				ld a, 0 
0ead 32 55 ee				ld (input_cursor), a 
0eb0 c3 44 0e				jp .is1 
0eb3					 
0eb3 fe 0f		.iske:		cp KEY_END 
0eb5 20 03				jr nz, .isknw 
0eb7 c3 44 0e				jp .is1 
0eba			 
0eba fe 06		.isknw:		cp KEY_NEXTWORD 
0ebc 20 1b				jr nz, .iskpw 
0ebe			 
0ebe 2a 69 ee		.isknwm:	ld hl, (input_ptr) 
0ec1 7e					ld a,(hl)	 
0ec2 fe 00				cp 0 
0ec4 ca 44 0e				jp z, .is1    ; end of string 
0ec7 fe 20				cp ' ' 
0ec9 ca 44 0e				jp z, .is1    ; end of word 
0ecc 23					inc hl 
0ecd 22 69 ee				ld (input_ptr), hl 
0ed0 3a 62 ee				ld a, (input_at_cursor) 
0ed3 3c					inc a 
0ed4 32 62 ee				ld (input_at_cursor), a 
0ed7 18 e5				jr .isknwm 
0ed9			 
0ed9 fe 07		.iskpw:		cp KEY_PREVWORD 
0edb 20 1b				jr nz, .iskl 
0edd			.iskpwm:	 
0edd 2a 69 ee				ld hl, (input_ptr) 
0ee0 7e					ld a,(hl)	 
0ee1 fe 00				cp 0  
0ee3 ca 44 0e				jp z, .is1    ; end of string 
0ee6 fe 20				cp ' ' 
0ee8 ca 44 0e				jp z, .is1    ; end of word 
0eeb 2b					dec hl 
0eec 22 69 ee				ld (input_ptr), hl 
0eef 3a 62 ee				ld a, (input_at_cursor) 
0ef2 3d					dec a 
0ef3 32 62 ee				ld (input_at_cursor), a 
0ef6 18 e5				jr .iskpwm 
0ef8			 
0ef8			 
0ef8 fe 0b		.iskl:		cp KEY_LEFT 
0efa 20 27				jr nz, .isk1 
0efc			 
0efc 3a 55 ee				ld a, (input_cursor) 
0eff			 
0eff fe 00				cp 0 
0f01 ca 44 0e				jp z, .is1 		; at start of line to ignore  
0f04			 
0f04 3d					dec  a 		; TODO check underflow 
0f05 32 55 ee				ld (input_cursor), a 
0f08			 
0f08 2a 69 ee				ld hl, (input_ptr) 
0f0b 2b					dec hl 
0f0c 22 69 ee				ld (input_ptr), hl 
0f0f					 
0f0f 3a 62 ee				ld a, (input_at_cursor) 
0f12 3d					dec a 
0f13 32 62 ee				ld (input_at_cursor), a 
0f16			 
0f16 3e 01				ld a, 1		; show cursor moving 
0f18 32 5f ee				ld (input_cur_onoff),a 
0f1b 3e 0f				ld a, CUR_BLINK_RATE 
0f1d 32 60 ee				ld (input_cur_flash), a 
0f20			 
0f20 c3 44 0e				jp .is1 
0f23			 
0f23 fe 0c		.isk1:		cp KEY_RIGHT 
0f25 20 2a				jr nz, .isk2 
0f27			 
0f27 3a 5a ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0f2a 5f					ld e,a 
0f2b 3a 55 ee				ld a, (input_cursor) 
0f2e bb					cp e 
0f2f ca 44 0e				jp z, .is1		; at the end of string so dont go right 
0f32			 
0f32 3c					inc  a 		; TODO check overflow 
0f33 32 55 ee				ld (input_cursor), a 
0f36			 
0f36 3a 62 ee				ld a, (input_at_cursor) 
0f39 3c					inc a 
0f3a 32 62 ee				ld (input_at_cursor), a 
0f3d			 
0f3d 2a 69 ee				ld hl, (input_ptr) 
0f40 23					inc hl 
0f41 22 69 ee				ld (input_ptr), hl 
0f44			 
0f44 3e 01				ld a, 1		; show cursor moving 
0f46 32 5f ee				ld (input_cur_onoff),a 
0f49 3e 0f				ld a, CUR_BLINK_RATE 
0f4b 32 60 ee				ld (input_cur_flash), a 
0f4e			 
0f4e c3 44 0e				jp .is1 
0f51			 
0f51 fe 05		.isk2:		cp KEY_UP 
0f53			 
0f53 20 26				jr nz, .isk3 
0f55			 
0f55					; swap last command with the current on 
0f55			 
0f55					; move cursor to start of string 
0f55 2a 67 ee				ld hl, (input_start) 
0f58 22 69 ee				ld (input_ptr), hl 
0f5b			 
0f5b 3a 64 ee				ld a, (input_at_pos) 
0f5e 32 62 ee				ld (input_at_cursor), a 
0f61			 
0f61 3e 00				ld a, 0 
0f63 32 55 ee				ld (input_cursor), a 
0f66					 
0f66					; swap input and last command buffers 
0f66			 
0f66 21 e8 e5				ld hl, os_cli_cmd 
0f69 11 e7 e6				ld de, os_last_cmd 
0f6c 06 ff				ld b, 255 
0f6e 7e			.swap1:		ld a, (hl) 
0f6f 4f					ld c,a 
0f70 1a					ld a, (de) 
0f71 77					ld (hl), a 
0f72 79					ld a,c 
0f73 12					ld (de),a 
0f74 23					inc hl 
0f75 13					inc de 
0f76 10 f6				djnz .swap1 
0f78			 
0f78			 
0f78			 
0f78			 
0f78			 
0f78 c3 44 0e				jp .is1 
0f7b			 
0f7b fe 08		.isk3:		cp KEY_BS 
0f7d 20 3c				jr nz, .isk4 
0f7f			 
0f7f 3a 55 ee				ld a, (input_cursor) 
0f82			 
0f82 fe 00				cp 0 
0f84 ca 44 0e				jp z, .is1 		; at start of line to ignore  
0f87			 
0f87 3d					dec  a 		; TODO check underflow 
0f88 32 55 ee				ld (input_cursor), a 
0f8b			 
0f8b					; hl is source 
0f8b					; de needs to be source - 1 
0f8b			 
0f8b			;		ld a, 0 
0f8b			;		dec hl 
0f8b			;		ld (hl), a 
0f8b			 
0f8b 2a 69 ee				ld hl, (input_ptr) 
0f8e 2b					dec hl 
0f8f 22 69 ee				ld (input_ptr), hl 
0f92			 
0f92					; shift all data 
0f92			 
0f92 e5					push hl 
0f93 23					inc hl 
0f94 d1					pop de 
0f95 3a 5a ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0f98 4f					ld c,a 
0f99 06 00				ld b,0 
0f9b ed b0				ldir  
0f9d			 
0f9d			 
0f9d			 
0f9d			 
0f9d 3a 62 ee				ld a, (input_at_cursor) 
0fa0 3d					dec a 
0fa1 32 62 ee				ld (input_at_cursor), a 
0fa4			 
0fa4			 
0fa4 3e 01				ld a, 1		; show cursor moving 
0fa6 32 5f ee				ld (input_cur_onoff),a 
0fa9 3e 0f				ld a, CUR_BLINK_RATE 
0fab 32 60 ee				ld (input_cur_flash), a 
0fae			 
0fae					; remove char 
0fae 3a 62 ee				ld a, (input_at_cursor) 
0fb1 3c					inc a 
0fb2 11 3c 10				ld de,.iblank 
0fb5 cd cc 0b				call str_at_display 
0fb8			 
0fb8 c3 44 0e				jp .is1 
0fbb			 
0fbb fe 0d		.isk4:		cp KEY_CR 
0fbd 28 6c				jr z, .endinput 
0fbf			 
0fbf					; else add the key press to the end 
0fbf			 
0fbf 4f					ld c, a			; save key pressed 
0fc0			 
0fc0 7e					ld a,(hl)		; get what is currently under char 
0fc1			 
0fc1 fe 00				cp 0			; we are at the end of the string 
0fc3 20 2f				jr nz, .onchar 
0fc5					 
0fc5					; add a char to the end of the string 
0fc5				 
0fc5 71					ld (hl),c 
0fc6 23					inc hl 
0fc7			;		ld a,' ' 
0fc7			;		ld (hl),a 
0fc7			;		inc hl 
0fc7 3e 00				ld a,0 
0fc9 77					ld (hl),a 
0fca 2b					dec hl 
0fcb			 
0fcb 3a 55 ee				ld a, (input_cursor) 
0fce 3c					inc a				; TODO check max string length and scroll  
0fcf 32 55 ee				ld (input_cursor), a		; inc cursor pos 
0fd2							 
0fd2 3a 62 ee				ld a, (input_at_cursor) 
0fd5 3c					inc a 
0fd6 32 62 ee				ld (input_at_cursor), a 
0fd9			 
0fd9 2a 69 ee				ld hl, (input_ptr) 
0fdc 23					inc hl 
0fdd 22 69 ee				ld (input_ptr), hl 
0fe0			 
0fe0 2a 69 ee				ld hl, (input_ptr) 
0fe3 23					inc hl 
0fe4 22 69 ee				ld (input_ptr), hl 
0fe7			;	if DEBUG_INPUT 
0fe7			;		push af 
0fe7			;		ld a, '+' 
0fe7			;		ld (debug_mark),a 
0fe7			;		pop af 
0fe7			;		CALLMONITOR 
0fe7			;	endif 
0fe7 3e 01				ld a, 1		; show cursor moving 
0fe9 32 5f ee				ld (input_cur_onoff),a 
0fec 3e 0f				ld a, CUR_BLINK_RATE 
0fee 32 60 ee				ld (input_cur_flash), a 
0ff1 c3 44 0e				jp .is1 
0ff4					 
0ff4			 
0ff4			 
0ff4					; if on a char then insert 
0ff4			.onchar: 
0ff4			 
0ff4					; TODO over flow check: make sure insert does not blow out buffer 
0ff4			 
0ff4					; need to do some maths to use lddr 
0ff4			 
0ff4 e5					push hl   ; save char pos 
0ff5 c5					push bc 
0ff6			 
0ff6 2a 67 ee				ld hl, (input_start) 
0ff9 3a 5a ee				ld a, (input_len) 
0ffc cd e6 0d				call addatohl  		; end of string 
0fff 23					inc hl 
1000 23					inc hl		; past zero term 
1001 e5					push hl 
1002 23					inc hl 
1003 e5					push hl  
1004			 
1004								; start and end of lddr set, now how much to move? 
1004			 
1004							 
1004 3a 55 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
1007 47					ld b,a 
1008 3a 5a ee				ld a,(input_len) 
100b 5f					ld e,a 
100c 90					sub b 
100d 3c					inc a		;?? 
100e 3c					inc a		;?? 
100f 3c					inc a		;?? 
1010			 
1010 06 00				ld b,0 
1012 4f					ld c,a 
1013			 
1013				if DEBUG_INPUT 
1013					push af 
1013					ld a, 'i' 
1013					ld (debug_mark),a 
1013					pop af 
1013			;		CALLMONITOR 
1013				endif 
1013 d1					pop de 
1014 e1					pop hl 
1015				if DEBUG_INPUT 
1015					push af 
1015					ld a, 'I' 
1015					ld (debug_mark),a 
1015					pop af 
1015			;		CALLMONITOR 
1015				endif 
1015 ed b8				lddr 
1017				 
1017			 
1017			 
1017					; TODO have a key for insert/overwrite mode???? 
1017 c1					pop bc 
1018 e1					pop hl 
1019 71					ld (hl), c		; otherwise overwrite current char 
101a					 
101a			 
101a			 
101a			 
101a 3a 55 ee				ld a, (input_cursor) 
101d 3c					inc  a 		; TODO check overflow 
101e 32 55 ee				ld (input_cursor), a 
1021			 
1021 3a 62 ee				ld a, (input_at_cursor) 
1024 3c					inc a 
1025 32 62 ee				ld (input_at_cursor), a 
1028			 
1028 c3 44 0e				jp .is1 
102b			 
102b			.endinput:	; TODO look for end of string 
102b			 
102b					; add trailing space for end of token 
102b			 
102b 2a 67 ee				ld hl, (input_start) 
102e 3a 5a ee				ld a,(input_len) 
1031 cd e6 0d				call addatohl 
1034 3e 20				ld a, ' ' 
1036 77					ld (hl),a 
1037					; TODO eof of parse marker 
1037			 
1037 23					inc hl 
1038 3e 00				ld a, 0 
103a 77					ld (hl),a 
103b			 
103b			 
103b c9					ret 
103c			 
103c .. 00		.iblank: db " ",0 
103e			 
103e			 
103e 32 64 ee		input_str_prev:	ld (input_at_pos), a 
1041 22 67 ee				ld (input_start), hl 
1044 3e 01				ld a,1			; add cursor 
1046 77					ld (hl),a 
1047 23					inc hl 
1048 3e 00				ld a,0 
104a 77					ld (hl),a 
104b 22 69 ee				ld (input_ptr), hl 
104e 7a					ld a,d 
104f 32 66 ee				ld (input_size), a 
1052 3e 00				ld a,0 
1054 32 55 ee				ld (input_cursor),a 
1057			.instr1:	 
1057			 
1057					; TODO do block cursor 
1057					; TODO switch cursor depending on the modifer key 
1057			 
1057					; update cursor shape change on key hold 
1057			 
1057 2a 69 ee				ld hl, (input_ptr) 
105a 2b					dec hl 
105b 3a c1 eb				ld a,(cursor_shape) 
105e 77					ld (hl), a 
105f			 
105f					; display entered text 
105f 3a 64 ee				ld a,(input_at_pos) 
1062 cd d0 64		            	CALL fLCD_Pos       ;Position cursor to location in A 
1065 ed 5b 67 ee	            	LD   de, (input_start) 
1069 cd c5 64		            	CALL fLCD_Str       ;Display string pointed to by DE 
106c			 
106c cd bb 65				call cin 
106f fe 00				cp 0 
1071 28 e4				jr z, .instr1 
1073			 
1073					; proecess keyboard controls first 
1073			 
1073 2a 69 ee				ld hl,(input_ptr) 
1076			 
1076 fe 0d				cp KEY_CR	 ; pressing enter ends input 
1078 28 5a				jr z, .instrcr 
107a			 
107a fe 08				cp KEY_BS 	; back space 
107c 20 0f				jr nz, .instr2 
107e					; process back space 
107e			 
107e					; TODO stop back space if at start of string 
107e 2b					dec hl 
107f 2b					dec hl ; to over write cursor 
1080 3a c1 eb				ld a,(cursor_shape) 
1083					;ld a,0 
1083 77					ld (hl),a 
1084 23					inc hl 
1085 3e 20				ld a," " 
1087 77					ld (hl),a 
1088 22 69 ee				ld (input_ptr),hl 
108b					 
108b			 
108b 18 ca				jr .instr1 
108d			 
108d fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
108f 20 06				jr nz, .instr3 
1091 2b					dec hl 
1092 22 69 ee				ld (input_ptr),hl 
1095 18 c0				jr .instr1 
1097				 
1097 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
1099 20 06				jr nz, .instr4 
109b 23					inc hl 
109c 22 69 ee				ld (input_ptr),hl 
109f 18 b6				jr .instr1 
10a1			 
10a1 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
10a3 20 06				jr nz, .instr5 
10a5 2b					dec hl 
10a6 22 69 ee				ld (input_ptr),hl 
10a9 18 ac				jr .instr1 
10ab			 
10ab fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
10ad 20 06				jr nz, .instr6 
10af 2b					dec hl 
10b0 22 69 ee				ld (input_ptr),hl 
10b3 18 a2				jr .instr1 
10b5 fe 05		.instr6:        cp KEY_UP      ; recall last command 
10b7 20 0b				jr nz, .instrnew 
10b9			 
10b9 21 c1 e2			ld hl, scratch 
10bc 11 e7 e6			ld de, os_last_cmd 
10bf cd dd 10			call strcpy 
10c2 18 93				jr .instr1 
10c4			 
10c4			 
10c4			.instrnew:	; no special key pressed to see if we have room to store it 
10c4			 
10c4					; TODO do string size test 
10c4			 
10c4 2b					dec hl ; to over write cursor 
10c5 77					ld (hl),a 
10c6 23					inc hl 
10c7 3a c1 eb				ld a,(cursor_shape) 
10ca 77					ld (hl),a 
10cb 23					inc hl 
10cc 3e 00				ld a,0 
10ce 77					ld (hl),a 
10cf			 
10cf 22 69 ee				ld (input_ptr),hl 
10d2					 
10d2 18 83				jr .instr1 
10d4 2b			.instrcr:	dec hl		; remove cursor 
10d5 3e 20				ld a,' '	; TODO add a trailing space for safety 
10d7 77					ld (hl),a 
10d8 23					inc hl 
10d9 3e 00				ld a,0 
10db 77					ld (hl),a 
10dc			 
10dc			 
10dc					; if at end of line scroll up    
10dc					; TODO detecting only end of line 4 for scroll up  
10dc			 
10dc					;ld   
10dc			 
10dc c9					ret 
10dd			 
10dd			 
10dd			; strcpy hl = dest, de source 
10dd			 
10dd 1a			strcpy:   LD   A, (DE)        ;Get character from string 
10de b7			            OR   A              ;Null terminator? 
10df c8			            RET  Z              ;Yes, so finished 
10e0 1a					ld a,(de) 
10e1 77					ld (hl),a 
10e2 13			            INC  DE             ;Point to next character 
10e3 23					inc hl 
10e4 18 f7		            JR   strcpy       ;Repeat 
10e6 c9					ret 
10e7			 
10e7			 
10e7			; TODO string_at  
10e7			; pass string which starts with lcd offset address and then null term string 
10e7			 
10e7			; TODO string to dec 
10e7			; TODO string to hex 
10e7			; TODO byte to string hex 
10e7			; TODO byte to string dec 
10e7			 
10e7			 
10e7			 
10e7			; from z80uartmonitor 
10e7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10e7			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
10e7			; pass hl for where to put the text 
10e7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
10e7 c5			hexout:	PUSH BC 
10e8 f5					PUSH AF 
10e9 47					LD B, A 
10ea					; Upper nybble 
10ea cb 3f				SRL A 
10ec cb 3f				SRL A 
10ee cb 3f				SRL A 
10f0 cb 3f				SRL A 
10f2 cd 02 11				CALL tohex 
10f5 77					ld (hl),a 
10f6 23					inc hl	 
10f7					 
10f7					; Lower nybble 
10f7 78					LD A, B 
10f8 e6 0f				AND 0FH 
10fa cd 02 11				CALL tohex 
10fd 77					ld (hl),a 
10fe 23					inc hl	 
10ff					 
10ff f1					POP AF 
1100 c1					POP BC 
1101 c9					RET 
1102					 
1102			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1102			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1102			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1102			tohex: 
1102 e5					PUSH HL 
1103 d5					PUSH DE 
1104 16 00				LD D, 0 
1106 5f					LD E, A 
1107 21 0f 11				LD HL, .DATA 
110a 19					ADD HL, DE 
110b 7e					LD A, (HL) 
110c d1					POP DE 
110d e1					POP HL 
110e c9					RET 
110f			 
110f			.DATA: 
110f 30					DEFB	30h	; 0 
1110 31					DEFB	31h	; 1 
1111 32					DEFB	32h	; 2 
1112 33					DEFB	33h	; 3 
1113 34					DEFB	34h	; 4 
1114 35					DEFB	35h	; 5 
1115 36					DEFB	36h	; 6 
1116 37					DEFB	37h	; 7 
1117 38					DEFB	38h	; 8 
1118 39					DEFB	39h	; 9 
1119 41					DEFB	41h	; A 
111a 42					DEFB	42h	; B 
111b 43					DEFB	43h	; C 
111c 44					DEFB	44h	; D 
111d 45					DEFB	45h	; E 
111e 46					DEFB	46h	; F 
111f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
111f			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
111f			;;    subtract $30, if result > 9 then subtract $7 more 
111f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
111f			atohex: 
111f d6 30				SUB $30 
1121 fe 0a				CP 10 
1123 f8					RET M		; If result negative it was 0-9 so we're done 
1124 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1126 c9					RET		 
1127			 
1127			 
1127			 
1127			 
1127			; Get 2 ASCII characters as hex byte from pointer in hl 
1127			 
1127			BYTERD: 
1127 16 00			LD	D,00h		;Set up 
1129 cd 31 11			CALL	HEXCON		;Get byte and convert to hex 
112c 87				ADD	A,A		;First nibble so 
112d 87				ADD	A,A		;multiply by 16 
112e 87				ADD	A,A		; 
112f 87				ADD	A,A		; 
1130 57				LD	D,A		;Save hi nibble in D 
1131			HEXCON: 
1131 7e				ld a, (hl)		;Get next chr 
1132 23				inc hl 
1133 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1135 fe 0a			CP	00Ah		;Is it 0-9 ? 
1137 38 02			JR	C,NALPHA	;If so miss next bit 
1139 d6 07			SUB	007h		;Else convert alpha 
113b			NALPHA: 
113b b2				OR	D		;Add hi nibble back 
113c c9				RET			; 
113d			 
113d			 
113d			; 
113d			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
113d			; Since the routines get_byte and therefore get_nibble are called, only valid 
113d			; characters (0-9a-f) are accepted. 
113d			; 
113d			;get_word        push    af 
113d			;                call    get_byte        ; Get the upper byte 
113d			;                ld      h, a 
113d			;                call    get_byte        ; Get the lower byte 
113d			;                ld      l, a 
113d			;                pop     af 
113d			;                ret 
113d			; 
113d			; Get a byte in hexadecimal notation. The result is returned in A. Since 
113d			; the routine get_nibble is used only valid characters are accepted - the  
113d			; input routine only accepts characters 0-9a-f. 
113d			; 
113d c5			get_byte:        push    bc              ; Save contents of B (and C) 
113e 7e					ld a,(hl) 
113f 23					inc hl 
1140 cd 65 11		                call    nibble2val      ; Get upper nibble 
1143 cb 07		                rlc     a 
1145 cb 07		                rlc     a 
1147 cb 07		                rlc     a 
1149 cb 07		                rlc     a 
114b 47			                ld      b, a            ; Save upper four bits 
114c 7e					ld a,(hl) 
114d cd 65 11		                call    nibble2val      ; Get lower nibble 
1150 b0			                or      b               ; Combine both nibbles 
1151 c1			                pop     bc              ; Restore B (and C) 
1152 c9			                ret 
1153			; 
1153			; Get a hexadecimal digit from the serial line. This routine blocks until 
1153			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1153			; to the serial line interface. The lower 4 bits of A contain the value of  
1153			; that particular digit. 
1153			; 
1153			;get_nibble      ld a,(hl)           ; Read a character 
1153			;                call    to_upper        ; Convert to upper case 
1153			;                call    is_hex          ; Was it a hex digit? 
1153			;                jr      nc, get_nibble  ; No, get another character 
1153			 ;               call    nibble2val      ; Convert nibble to value 
1153			 ;               call    print_nibble 
1153			 ;               ret 
1153			; 
1153			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1153			; A valid hexadecimal digit is denoted by a set C flag. 
1153			; 
1153			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1153			;                ret     nc              ; Yes 
1153			;                cp      '0'             ; Less than '0'? 
1153			;                jr      nc, is_hex_1    ; No, continue 
1153			;                ccf                     ; Complement carry (i.e. clear it) 
1153			;                ret 
1153			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1153			;                ret     c               ; Yes 
1153			;                cp      'A'             ; Less than 'A'? 
1153			;                jr      nc, is_hex_2    ; No, continue 
1153			;                ccf                     ; Yes - clear carry and return 
1153			;                ret 
1153			;is_hex_2        scf                     ; Set carry 
1153			;                ret 
1153			; 
1153			; Convert a single character contained in A to upper case: 
1153			; 
1153 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1155 d8			                ret     c 
1156 fe 7b		                cp      'z' + 1         ; > 'z'? 
1158 d0			                ret     nc              ; Nothing to do, either 
1159 e6 5f		                and     $5f             ; Convert to upper case 
115b c9			                ret 
115c			 
115c			 
115c			to_lower: 
115c			 
115c			   ; if char is in [A-Z] make it lower case 
115c			 
115c			   ; enter : a = char 
115c			   ; exit  : a = lower case char 
115c			   ; uses  : af 
115c			 
115c fe 41		   cp 'A' 
115e d8			   ret c 
115f			    
115f fe 5b		   cp 'Z'+1 
1161 d0			   ret nc 
1162			    
1162 f6 20		   or $20 
1164 c9			   ret 
1165			 
1165			; 
1165			; Expects a hexadecimal digit (upper case!) in A and returns the 
1165			; corresponding value in A. 
1165			; 
1165 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1167 38 02		                jr      c, nibble2val_1 ; Yes 
1169 d6 07		                sub     7               ; Adjust for A-F 
116b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
116d e6 0f		                and     $f              ; Only return lower 4 bits 
116f c9			                ret 
1170			; 
1170			; Print_nibble prints a single hex nibble which is contained in the lower  
1170			; four bits of A: 
1170			; 
1170			;print_nibble    push    af              ; We won't destroy the contents of A 
1170			;                and     $f              ; Just in case... 
1170			;                add     a, '0'             ; If we have a digit we are done here. 
1170			;                cp      '9' + 1         ; Is the result > 9? 
1170			;                jr      c, print_nibble_1 
1170			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1170			;print_nibble_1  call    putc            ; Print the nibble and 
1170			;                pop     af              ; restore the original value of A 
1170			;                ret 
1170			;; 
1170			;; Send a CR/LF pair: 
1170			; 
1170			;crlf            push    af 
1170			;                ld      a, cr 
1170			;                call    putc 
1170			;                ld      a, lf 
1170			;                call    putc 
1170			;                pop     af 
1170			;                ret 
1170			; 
1170			; Print_word prints the four hex digits of a word to the serial line. The  
1170			; word is expected to be in HL. 
1170			; 
1170			;print_word      push    hl 
1170			;                push    af 
1170			;                ld      a, h 
1170			;                call    print_byte 
1170			;                ld      a, l 
1170			;                call    print_byte 
1170			;                pop     af 
1170			;                pop     hl 
1170			;                ret 
1170			; 
1170			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1170			; The byte to be printed is expected to be in A. 
1170			; 
1170			;print_byte      push    af              ; Save the contents of the registers 
1170			;                push    bc 
1170			;                ld      b, a 
1170			;                rrca 
1170			;                rrca 
1170			;                rrca 
1170			;                rrca 
1170			;                call    print_nibble    ; Print high nibble 
1170			;                ld      a, b 
1170			;                call    print_nibble    ; Print low nibble 
1170			;                pop     bc              ; Restore original register contents 
1170			;                pop     af 
1170			;                ret 
1170			 
1170			 
1170			 
1170			 
1170			 
1170			fourehexhl:  
1170 7e				ld a,(hl) 
1171 cd 1f 11			call atohex 
1174 cb 3f				SRL A 
1176 cb 3f				SRL A 
1178 cb 3f				SRL A 
117a cb 3f				SRL A 
117c 47				ld b, a 
117d 23				inc hl 
117e 7e				ld a,(hl) 
117f 23				inc hl 
1180 cd 1f 11			call atohex 
1183 80				add b 
1184 57				ld d,a 
1185 7e				ld a,(hl) 
1186 cd 1f 11			call atohex 
1189 cb 3f				SRL A 
118b cb 3f				SRL A 
118d cb 3f				SRL A 
118f cb 3f				SRL A 
1191 47				ld b, a 
1192 23				inc hl 
1193 7e				ld a,(hl) 
1194 23				inc hl 
1195 cd 1f 11			call atohex 
1198 80				add b 
1199 5f				ld e, a 
119a d5				push de 
119b e1				pop hl 
119c c9				ret 
119d			 
119d			; pass hl. returns z set if the byte at hl is a digit 
119d			;isdigithl:  
119d			;	push bc 
119d			;	ld a,(hl) 
119d			;	cp ':' 
119d			;	jr nc, .isdf 		; > 
119d			;	cp '0' 
119d			;	jr c, .isdf		; < 
119d			; 
119d			;	; TODO find a better way to set z 
119d			; 
119d			;	ld b,a 
119d			;	cp b 
119d			;	pop bc 
119d			;	ret 
119d			; 
119d			;.isdf:	; not digit so clear z 
119d			; 
119d			;	; TODO find a better way to unset z 
119d			; 
119d			;	ld b,a 
119d			;	inc b 
119d			;	cp b 
119d			; 
119d			;	pop bc 
119d			;	ret 
119d				 
119d				 
119d			 
119d			 
119d			; pass hl as the four byte address to load 
119d			 
119d			get_word_hl:  
119d e5				push hl 
119e cd 3d 11			call get_byte 
11a1				 
11a1 47				ld b, a 
11a2			 
11a2 e1				pop hl 
11a3 23				inc hl 
11a4 23				inc hl 
11a5			 
11a5			; TODO not able to handle a-f  
11a5 7e				ld a,(hl) 
11a6			;	;cp ':' 
11a6			;	cp 'g' 
11a6			;	jr nc, .single_byte_hl 		; > 
11a6			;	cp 'G' 
11a6			;	jr nc, .single_byte_hl 		; > 
11a6			;	cp '0' 
11a6			;	jr c, .single_byte_hl		; < 
11a6			 
11a6				;call isdigithl 
11a6 fe 00			cp 0 
11a8 28 06			jr z, .single_byte_hl 
11aa			 
11aa			.getwhln:   ; hex word so get next byte 
11aa			 
11aa cd 3d 11			call get_byte 
11ad 6f				ld l, a 
11ae 60				ld h,b 
11af c9				ret 
11b0 68			.single_byte_hl:   ld l,b 
11b1 26 00				ld h,0 
11b3 c9					ret 
11b4			 
11b4			 
11b4			 
11b4			 
11b4 21 35 19			ld hl,asc+1 
11b7			;	ld a, (hl) 
11b7			;	call nibble2val 
11b7 cd 3d 11			call get_byte 
11ba			 
11ba			;	call fourehexhl 
11ba 32 f5 e2			ld (scratch+52),a 
11bd				 
11bd 21 f3 e2			ld hl,scratch+50 
11c0 22 e4 e5			ld (os_cur_ptr),hl 
11c3			 
11c3 c9				ret 
11c4			 
11c4			 
11c4			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
11c4			 
11c4			; Decimal Unsigned Version 
11c4			 
11c4			;Number in a to decimal ASCII 
11c4			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
11c4			;Example: display a=56 as "056" 
11c4			;input: a = number 
11c4			;Output: a=0,value of a in the screen 
11c4			;destroys af,bc (don't know about hl and de) 
11c4			DispAToASCII: 
11c4 0e 9c			ld	c,-100 
11c6 cd d0 11			call	.Na1 
11c9 0e f6			ld	c,-10 
11cb cd d0 11			call	.Na1 
11ce 0e ff			ld	c,-1 
11d0 06 2f		.Na1:	ld	b,'0'-1 
11d2 04			.Na2:	inc	b 
11d3 81				add	a,c 
11d4 38 fc			jr	c,.Na2 
11d6 91				sub	c		;works as add 100/10/1 
11d7 f5				push af		;safer than ld c,a 
11d8 78				ld	a,b		;char is in b 
11d9			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
11d9 f1				pop af		;safer than ld a,c 
11da c9				ret 
11db			 
11db			; Decimal Signed Version 
11db			 
11db			; DispA 
11db			; -------------------------------------------------------------- 
11db			; Converts a signed integer value to a zero-terminated ASCII 
11db			; string representative of that value (using radix 10). 
11db			; -------------------------------------------------------------- 
11db			; INPUTS: 
11db			;     HL     Value to convert (two's complement integer). 
11db			;     DE     Base address of string destination. (pointer). 
11db			; -------------------------------------------------------------- 
11db			; OUTPUTS: 
11db			;     None 
11db			; -------------------------------------------------------------- 
11db			; REGISTERS/MEMORY DESTROYED 
11db			; AF HL 
11db			; -------------------------------------------------------------- 
11db			 
11db			;DispHLToASCII: 
11db			;   push    de 
11db			;   push    bc 
11db			; 
11db			;; Detect sign of HL. 
11db			;    bit    7, h 
11db			;    jr     z, ._DoConvert 
11db			; 
11db			;; HL is negative. Output '-' to string and negate HL. 
11db			;    ld     a, '-' 
11db			;    ld     (de), a 
11db			;    inc    de 
11db			; 
11db			;; Negate HL (using two's complement) 
11db			;    xor    a 
11db			;    sub    l 
11db			;    ld     l, a 
11db			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
11db			;    sbc    a, h 
11db			;    ld     h, a 
11db			; 
11db			;; Convert HL to digit characters 
11db			;._DoConvert: 
11db			;    ld     b, 0     ; B will count character length of number 
11db			;-   ld     a, 10 
11db			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
11db			;    push   af 
11db			;    inc    b 
11db			;    ld     a, h 
11db			;    or     l 
11db			;    jr     nz, - 
11db			; 
11db			;; Retrieve digits from stack 
11db			;-   pop    af 
11db			;    or     $30 
11db			;    ld     (de), a 
11db			;    inc    de 
11db			;    djnz   - 
11db			; 
11db			;; Terminate string with NULL 
11db			;    xor    a 
11db			;    ld     (de), a 
11db			; 
11db			;    pop    bc 
11db			;    pop    de 
11db			;    ret 
11db			 
11db			;Comments 
11db			; 
11db			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
11db			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
11db			;    Note that the output string will not be fixed-width. 
11db			; 
11db			;Example Usage 
11db			; 
11db			;    ld    hl, -1004 
11db			;    ld    de, OP1 
11db			;    call  DispA 
11db			;    ld    hl, OP1 
11db			;    syscall  PutS 
11db			 
11db			 
11db			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11db			 
11db			 
11db			;Converts an ASCII string to an unsigned 16-bit integer 
11db			;Quits when it reaches a non-decimal digit 
11db			 
11db			string_to_uint16: 
11db			atoui_16: 
11db			;Input: 
11db			;     DE points to the string 
11db			;Outputs: 
11db			;     HL is the result 
11db			;     A is the 8-bit value of the number 
11db			;     DE points to the byte after the number 
11db			;Destroys: 
11db			;     BC 
11db			;       if the string is non-empty, BC is HL/10 
11db			;Size:  24 bytes 
11db			;Speed: 42+d(104+{0,9}) 
11db			;       d is the number of digits in the number 
11db			;       max is 640 cycles for a 5 digit number 
11db			;Assuming no leading zeros: 
11db			;1 digit:  146cc 
11db			;2 digit:  250cc 
11db			;3 digit:  354cc or 363cc (avg: 354.126cc) 
11db			;4 digit:  458cc or 467cc (avg: 458.27cc) 
11db			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
11db			;avg: 544.81158447265625cc (544+13297/16384) 
11db			;=============================================================== 
11db 21 00 00		  ld hl,0 
11de			.u16a: 
11de 1a			  ld a,(de) 
11df d6 30		  sub 30h 
11e1 fe 0a		  cp 10 
11e3 d0			  ret nc 
11e4 13			  inc de 
11e5 44			  ld b,h 
11e6 4d			  ld c,l 
11e7 29			  add hl,hl 
11e8 29			  add hl,hl 
11e9 09			  add hl,bc 
11ea 29			  add hl,hl 
11eb 85			  add a,l 
11ec 6f			  ld l,a 
11ed 30 ef		  jr nc,.u16a 
11ef 24			  inc h 
11f0 c3 de 11		  jp .u16a 
11f3			 
11f3			 
11f3			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
11f3			 
11f3			;written by Zeda 
11f3			;Converts a 16-bit unsigned integer to an ASCII string. 
11f3			 
11f3			uitoa_16: 
11f3			;Input: 
11f3			;   DE is the number to convert 
11f3			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
11f3			;Output: 
11f3			;   HL points to the null-terminated ASCII string 
11f3			;      NOTE: This isn't necessarily the same as the input HL. 
11f3 d5			  push de 
11f4 c5			  push bc 
11f5 f5			  push af 
11f6 eb			  ex de,hl 
11f7			 
11f7 01 f0 d8		  ld bc,-10000 
11fa 3e 2f		  ld a,'0'-1 
11fc 3c			  inc a 
11fd 09			  add hl,bc  
11fe 38 fc		   jr c,$-2 
1200 12			  ld (de),a 
1201 13			  inc de 
1202			 
1202 01 e8 03		  ld bc,1000 
1205 3e 3a		  ld a,'9'+1 
1207 3d			  dec a  
1208 09			  add hl,bc  
1209 30 fc		   jr nc,$-2 
120b 12			  ld (de),a 
120c 13			  inc de 
120d			 
120d 01 9c ff		  ld bc,-100 
1210 3e 2f		  ld a,'0'-1 
1212 3c			  inc a  
1213 09			  add hl,bc  
1214 38 fc		   jr c,$-2 
1216 12			  ld (de),a 
1217 13			  inc de 
1218			 
1218 7d			  ld a,l 
1219 26 3a		  ld h,'9'+1 
121b 25			  dec h  
121c c6 0a		  add a,10  
121e 30 fb		   jr nc,$-3 
1220 c6 30		  add a,'0' 
1222 eb			  ex de,hl 
1223 72			  ld (hl),d 
1224 23			  inc hl 
1225 77			  ld (hl),a 
1226 23			  inc hl 
1227 36 00		  ld (hl),0 
1229			 
1229			;Now strip the leading zeros 
1229 0e fa		  ld c,-6 
122b 09			  add hl,bc 
122c 3e 30		  ld a,'0' 
122e 23			  inc hl  
122f be			  cp (hl)  
1230 28 fc		  jr z,$-2 
1232			 
1232			;Make sure that the string is non-empty! 
1232 7e			  ld a,(hl) 
1233 b7			  or a 
1234 20 01		  jr nz,.atoub 
1236 2b			  dec hl 
1237			.atoub: 
1237			 
1237 f1			  pop af 
1238 c1			  pop bc 
1239 d1			  pop de 
123a c9			  ret 
123b			 
123b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
123b			 
123b			toUpper: 
123b			;A is the char. 
123b			;If A is a lowercase letter, this sets it to the matching uppercase 
123b			;18cc or 30cc or 41cc 
123b			;avg: 26.75cc 
123b fe 61		  cp 'a' 
123d d8			  ret c 
123e fe 7b		  cp 'z'+1 
1240 d0			  ret nc 
1241 d6 20		  sub 'a'-'A' 
1243 c9			  ret 
1244			 
1244			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1244			 
1244			; String Length 
1244			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1244			 
1244			; Get the length of the null-terminated string starting at $8000 hl 
1244			;    LD     HL, $8000 
1244			 
1244			strlenz: 
1244			 
1244 af			    XOR    A               ; Zero is the value we are looking for. 
1245 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1246 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1247			                           ; 65, 536 bytes (the entire addressable memory space). 
1247 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1249			 
1249			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1249 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
124a 6f			    LD     L, A             ; number of bytes 
124b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
124d 2b			    DEC    HL              ; Compensate for null. 
124e c9				ret 
124f			 
124f			; Get the length of the A terminated string starting at $8000 hl 
124f			;    LD     HL, $8000 
124f			 
124f			strlent: 
124f			 
124f			                  ; A is the value we are looking for. 
124f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1251 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1253			                           ; 65, 536 bytes (the entire addressable memory space). 
1253 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1255			 
1255			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1255 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1257 2e 00		    LD     L, 0             ; number of bytes 
1259 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
125b 2b			    DEC    HL              ; Compensate for null. 
125c c9				ret 
125d			 
125d			 
125d			;Comparing Strings 
125d			 
125d			;IN    HL     Address of string1. 
125d			;      DE     Address of string2. 
125d			 
125d			; doc given but wrong??? 
125d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
125d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
125d			; tested 
125d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
125d			 
125d			strcmp_old: 
125d e5			    PUSH   HL 
125e d5			    PUSH   DE 
125f			 
125f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1260 be			    CP     (HL)            ; (want to minimize work). 
1261 38 01		    JR     C, Str1IsBigger 
1263 7e			    LD     A, (HL) 
1264			 
1264			Str1IsBigger: 
1264 4f			    LD     C, A             ; Put length in BC 
1265 06 00		    LD     B, 0 
1267 13			    INC    DE              ; Increment pointers to meat of string. 
1268 23			    INC    HL 
1269			 
1269			CmpLoop: 
1269 1a			    LD     A, (DE)          ; Compare bytes. 
126a ed a1		    CPI 
126c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
126e 13			    INC    DE              ; Update pointer. 
126f ea 69 12		    JP     PE, CmpLoop 
1272			 
1272 d1			    POP    DE 
1273 e1			    POP    HL 
1274 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1275 be			    CP     (HL) 
1276 c9			    RET 
1277			 
1277			NoMatch: 
1277 2b			    DEC    HL 
1278 be			    CP     (HL)            ; Compare again to affect carry. 
1279 d1			    POP    DE 
127a e1			    POP    HL 
127b c9			    RET 
127c			 
127c			;; test strmp 
127c			; 
127c			;ld de, .str1 
127c			;ld hl, .str2 
127c			;call strcmp 
127c			;jr z, .z1 
127c			;;this 
127c			;	if DEBUG_FORTH_WORDS 
127c			;		DMARK "NZ1" 
127c			;		CALLMONITOR 
127c			;	endif 
127c			;.z1: 
127c			; 
127c			;	if DEBUG_FORTH_WORDS 
127c			;		DMARK "ZZ1" 
127c			;		CALLMONITOR 
127c			;	endif 
127c			; 
127c			;ld de, .str1 
127c			;ld hl, .str1 
127c			;call strcmp 
127c			;jr z, .z2 
127c			;;this 
127c			;	if DEBUG_FORTH_WORDS 
127c			;		DMARK "NZ2" 
127c			;		CALLMONITOR 
127c			;	endif 
127c			;.z2: 
127c			; 
127c			;	if DEBUG_FORTH_WORDS 
127c			;		DMARK "ZZ2" 
127c			;		CALLMONITOR 
127c			;	endif 
127c			; 
127c			;ld de, .str1 
127c			;ld hl, .str2 
127c			;call strcmp 
127c			;jr c, .c1 
127c			; 
127c			;	if DEBUG_FORTH_WORDS 
127c			;		DMARK "Nc1" 
127c			;		CALLMONITOR 
127c			;	endif 
127c			;.c1: 
127c			;;this 
127c			;	if DEBUG_FORTH_WORDS 
127c			;		DMARK "cc1" 
127c			;		CALLMONITOR 
127c			;	endif 
127c			; 
127c			;ld de, .str1 
127c			;ld hl, .str1 
127c			;call strcmp 
127c			;jr c, .c2 
127c			;;this 
127c			;	if DEBUG_FORTH_WORDS 
127c			;		DMARK "Nc2" 
127c			;		CALLMONITOR 
127c			;	endif 
127c			;.c2: 
127c			; 
127c			;	if DEBUG_FORTH_WORDS 
127c			;		DMARK "cc2" 
127c			;		CALLMONITOR 
127c			;	endif 
127c			;	NEXTW 
127c			;.str1:   db "string1",0 
127c			;.str2:   db "string2",0 
127c			 
127c			; only care about direct match or not 
127c			; hl and de strings 
127c			; zero set if the same 
127c			 
127c			strcmp: 
127c 1a				ld a, (de) 
127d be				cp (hl) 
127e 28 02			jr z, .ssame 
1280 b7				or a 
1281 c9				ret 
1282			 
1282			.ssame:  
1282 fe 00			cp 0 
1284 c8				ret z 
1285			 
1285 23				inc hl 
1286 13				inc de 
1287 18 f3			jr strcmp 
1289				 
1289				 
1289			 
1289			 
1289			 
1289			 
1289			; eof 
1289			 
1289			 
1289			 
1289			 
1289			 
1289			 
# End of file firmware_strings.asm
1289			include "firmware_memory.asm"   ; malloc and free  
1289			 
1289			if DEBUG_FORTH_MALLOC_HIGH 
1289			.mallocsize: db "Wants malloc >256",0 
1289			.mallocasize: db "MALLOC gives >256",0 
1289			.malloczero: db "MALLOC gives zero",0 
1289			 
1289			malloc_guard_zerolen: 
1289				push hl 
1289				push de 
1289				push af 
1289			 
1289				ld de, 0 
1289			        call cmp16 
1289				jr nz, .lowalloz 
1289			 
1289				push hl 
1289				push de 
1289					ld hl, display_fb0 
1289					ld (display_fb_active), hl 
1289				call clear_display 
1289				ld a, 0 
1289				ld de, .malloczero 
1289				call str_at_display 
1289				call update_display 
1289				call delay1s 
1289				call delay1s 
1289				call bp_on 
1289			;	ld a, 0 
1289			;	ld (os_view_disable), a 
1289			 
1289				pop de 
1289				pop hl 
1289			 
1289				 
1289			 
1289				CALLMONITOR 
1289			.lowalloz: 
1289			 
1289			 
1289				pop af 
1289				pop de 
1289				pop hl 
1289			ret 
1289			 
1289			malloc_guard_entry: 
1289				push hl 
1289				push de 
1289				push af 
1289			 
1289			 	or a      ;clear carry flag 
1289				push hl 
1289				ld de, 255 
1289				sbc hl, de 
1289				jr c, .lowalloc 
1289			 
1289				push de 
1289					ld hl, display_fb0 
1289					ld (display_fb_active), hl 
1289				call clear_display 
1289				ld a, 0 
1289				ld de, .mallocsize 
1289				call str_at_display 
1289				call update_display 
1289				call delay1s 
1289				call delay1s 
1289			;	ld a, 0 
1289			;	ld (os_view_disable), a 
1289				call bp_on 
1289			 
1289				pop de 
1289				pop hl 
1289			 
1289				 
1289			 
1289				CALLMONITOR 
1289				jr .lowdone 
1289			.lowalloc: 
1289			 
1289			 
1289				pop hl 
1289			.lowdone:	pop af 
1289				pop de 
1289				pop hl 
1289			ret 
1289			 
1289			malloc_guard_exit: 
1289				push hl 
1289				push de 
1289				push af 
1289			 
1289			 	or a      ;clear carry flag 
1289				push hl 
1289				ld de, 255 
1289				sbc hl, de 
1289				jr c, .lowallocx 
1289			 
1289				push de 
1289					ld hl, display_fb0 
1289					ld (display_fb_active), hl 
1289				call clear_display 
1289				ld a, 0 
1289				ld de, .mallocasize 
1289				call str_at_display 
1289				call update_display 
1289				call delay1s 
1289				call delay1s 
1289			;	ld a, 0 
1289			;	ld (os_view_disable), a 
1289				call bp_on 
1289				pop de 
1289				pop hl 
1289			 
1289				CALLMONITOR 
1289				jr .lowdonex 
1289			.lowallocx: 
1289			 
1289				pop hl 
1289			.lowdonex:	pop af 
1289				pop de 
1289				pop hl 
1289			ret 
1289			endif 
1289			 
1289			if MALLOC_2 
1289			; Z80 Malloc and Free Functions 
1289			 
1289			; Malloc Function: 
1289			; Input: 
1289			;   HL: Size of block to allocate 
1289			; Output: 
1289			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1289			 
1289			malloc: 
1289				 
1289			if DEBUG_FORTH_MALLOC_HIGH 
1289			call malloc_guard_entry 
1289			endif 
1289			 
1289			 
1289			 
1289			 
1289					if DEBUG_FORTH_MALLOC 
1289						DMARK "mal" 
1289						CALLMONITOR 
1289					endif 
1289			    push af            ; Save AF register 
1289			    ld a, l            ; Load low byte of size into A 
1289			    or h               ; Check if size is zero 
1289			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1289			 
1289			    ; Allocate memory 
1289			    ld hl, (heap_start) ; Load start of heap into HL 
1289					if DEBUG_FORTH_MALLOC 
1289						DMARK "ma1" 
1289						CALLMONITOR 
1289					endif 
1289			    call malloc_internal ; Call internal malloc function 
1289			    pop af             ; Restore AF register 
1289			if DEBUG_FORTH_MALLOC_HIGH 
1289			call malloc_guard_exit 
1289			call malloc_guard_zerolen 
1289			endif 
1289			    ret                ; Return 
1289			 
1289			; Free Function: 
1289			; Input: 
1289			;   HL: Pointer to memory block to free 
1289			; Output: 
1289			;   None 
1289			 
1289			free: 
1289			    push af            ; Save AF register 
1289			    ld a, l            ; Load low byte of pointer into A 
1289			    or h               ; Check if pointer is NULL 
1289			    jp z, free_exit    ; If pointer is NULL, exit 
1289			 
1289			    ; Free memory 
1289			    ld hl, (heap_start) ; Load start of heap into HL 
1289			    call free_internal  ; Call internal free function 
1289			    pop af             ; Restore AF register 
1289			    ret                ; Return 
1289			 
1289			; Internal Malloc Function: 
1289			; Input: 
1289			;   HL: Size of block to allocate 
1289			; Output: 
1289			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1289			 
1289			malloc_internal: 
1289			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1289			    add hl, bc         ; Add management overhead to requested size 
1289			    ex de, hl          ; Save total size in DE, and keep it in HL 
1289					if DEBUG_FORTH_MALLOC 
1289						DMARK "ma2" 
1289						CALLMONITOR 
1289					endif 
1289			 
1289			    ; Search for free memory block 
1289			    ld de, (heap_end)  ; Load end of heap into DE 
1289			    ld bc, 0           ; Initialize counter 
1289			 
1289					if DEBUG_FORTH_MALLOC 
1289						DMARK "ma2" 
1289						CALLMONITOR 
1289					endif 
1289			malloc_search_loop: 
1289			    ; Check if current block is free 
1289			    ld a, (hl)         ; Load current block's status (free or used) 
1289			    cp 0               ; Compare with zero (free) 
1289			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1289			 
1289			    ; Check if current block is large enough 
1289			    ld a, (hl+1)       ; Load high byte of block size 
1289			    cp l               ; Compare with low byte of requested size 
1289			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1289			 
1289			    ld a, (hl+2)       ; Load low byte of block size 
1289			    cp h               ; Compare with high byte of requested size 
1289			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1289			 
1289			    ; Mark block as used 
1289			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1289			 
1289			    ; Calculate remaining space in block 
1289			    ld bc, 0           ; Clear BC 
1289			    add hl, bc         ; Increment HL to point to start of data block 
1289			    add hl, de         ; HL = HL + DE (total size) 
1289			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1289			    add hl, bc         ; Add management overhead to start of data block 
1289			 
1289			    ; Save pointer to allocated block in HL 
1289			if DEBUG_FORTH_MALLOC_HIGH 
1289						DMARK "ma5" 
1289			call malloc_guard_exit 
1289			call malloc_guard_zerolen 
1289			endif 
1289			    ret 
1289			 
1289			malloc_skip_block_check: 
1289			    ; Move to the next block 
1289			    ld bc, 3           ; Size of management overhead 
1289			    add hl, bc         ; Move to the next block 
1289			    inc de             ; Increment counter 
1289			 
1289			    ; Check if we have reached the end of heap 
1289			    ld a, e            ; Load low byte of heap end address 
1289			    cp (hl)            ; Compare with low byte of current address 
1289			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1289			    ld a, d            ; Load high byte of heap end address 
1289			    cp 0               ; Check if it's zero (end of memory) 
1289			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1289			 
1289			    ; If we reached here, allocation failed 
1289			    xor a              ; Set result to NULL 
1289			if DEBUG_FORTH_MALLOC_HIGH 
1289						DMARK "ma6" 
1289			call malloc_guard_exit 
1289			call malloc_guard_zerolen 
1289			endif 
1289			    ret 
1289			malloc_exit: 
1289			if DEBUG_FORTH_MALLOC_HIGH 
1289						DMARK "ma7" 
1289			call malloc_guard_exit 
1289			call malloc_guard_zerolen 
1289			endif 
1289			    ret 
1289			 
1289			; Internal Free Function: 
1289			; Input: 
1289			;   HL: Pointer to memory block to free 
1289			; Output: 
1289			;   None 
1289			 
1289			free_internal: 
1289			    ld de, (heap_start) ; Load start of heap into DE 
1289			    ld bc, 0            ; Initialize counter 
1289			 
1289			free_search_loop: 
1289			    ; Check if current block contains the pointer 
1289			    ld a, l             ; Load low byte of pointer 
1289			    cp (hl+1)           ; Compare with high byte of current block's address 
1289			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1289			    ld a, h             ; Load high byte of pointer 
1289			    cp (hl+2)           ; Compare with low byte of current block's address 
1289			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1289			 
1289			    ; Mark block as free 
1289			    ld (hl), 0          ; Set status byte to indicate free block 
1289			    ret                 ; Return 
1289			 
1289			free_skip_block_check: 
1289			    ; Move to the next block 
1289			    ld bc, 3            ; Size of management overhead 
1289			    add hl, bc          ; Move to the next block 
1289			    inc de              ; Increment counter 
1289			 
1289			    ; Check if we have reached the end of heap 
1289			    ld a, e             ; Load low byte of heap end address 
1289			    cp (hl)             ; Compare with low byte of current address 
1289			    jr nz, free_search_loop  ; If not equal, continue searching 
1289			    ld a, d             ; Load high byte of heap end address 
1289			    cp 0                ; Check if it's zero (end of memory) 
1289			    jr nz, free_search_loop  ; If not zero, continue searching 
1289			 
1289			    ; If we reached here, pointer is not found in heap 
1289			    ret 
1289			 
1289			free_exit: 
1289			    ret                 ; Return 
1289			 
1289			; Define heap start and end addresses 
1289			;heap_start:    .dw 0xC000   ; Start of heap 
1289			;heap_end:      .dw 0xE000   ; End of heap 
1289			 
1289			endif 
1289			 
1289			 
1289			if MALLOC_1 
1289			 
1289			 
1289			 
1289			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1289			 
1289			;moved to firmware.asm 
1289			;heap_start        .equ  0x9000      ; Starting address of heap 
1289			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1289			 
1289			;      .org 0 
1289			;      jp    main 
1289			 
1289			 
1289			;      .org  0x100 
1289			;main: 
1289			;      ld    HL, 0x8100 
1289			;      ld    SP, HL 
1289			; 
1289			;      call  heap_init 
1289			; 
1289			;      ; Make some allocations 
1289			;      ld    HL, 12 
1289			;      call  malloc            ; Allocates 0x9004 
1289			; 
1289			;      ld    HL, 12 
1289			;      call  malloc            ; Allocates 0x9014 
1289			; 
1289			;      ld    HL, 12 
1289			;      call  malloc            ; Allocates 0x9024 
1289			; 
1289			;      ; Free some allocations 
1289			;      ld    HL, 0x9014 
1289			;      call  free 
1289			; 
1289			;      ld    HL, 0x9004 
1289			;      call  free 
1289			; 
1289			;      ld    HL, 0x9024 
1289			;      call  free 
1289			; 
1289			; 
1289			;      halt 
1289			 
1289			 
1289			;------------------------------------------------------------------------------ 
1289			;     heap_init                                                               : 
1289			;                                                                             : 
1289			; Description                                                                 : 
1289			;     Initialise the heap and make it ready for malloc and free operations.   : 
1289			;                                                                             : 
1289			;     The heap is maintained as a linked list, starting with an initial       : 
1289			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1289			;     the first free block in the heap. Each block then points to the next    : 
1289			;     free block within the heap, and the free list ends at the first block   : 
1289			;     with a null pointer to the next free block.                             : 
1289			;                                                                             : 
1289			; Parameters                                                                  : 
1289			;     Inputs are compile-time only. Two defines which specify the starting    : 
1289			;     address of the heap and its size are required, along with a memory      : 
1289			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1289			;     principally stores a pointer to the first free block in the heap.       : 
1289			;                                                                             : 
1289			; Returns                                                                     : 
1289			;     Nothing                                                                 : 
1289			;------------------------------------------------------------------------------ 
1289			heap_init: 
1289 e5			      push  HL 
128a			 
128a			      ; Initialise free list struct 
128a 21 e3 65		      ld    HL, heap_start 
128d 22 de 65		      ld    (free_list), HL 
1290 21 00 00		      ld    HL, 0 
1293 22 e0 65		      ld    (free_list+2), HL 
1296			 
1296			      ; Insert first free block at bottom of heap, consumes entire heap 
1296 21 98 e2		      ld    HL, heap_start+heap_size-4 
1299 22 e3 65		      ld    (heap_start), HL        ; Next block (end of free list) 
129c 21 b5 7c		      ld    HL, heap_size-4 
129f 22 e5 65		      ld    (heap_start+2), HL      ; Block size 
12a2			 
12a2			      ; Insert end of free list block at top of heap - two null words will 
12a2			      ; terminate the free list 
12a2 21 00 00		      ld    HL, 0 
12a5 22 9a e2		      ld    (heap_start+heap_size-2), HL 
12a8 22 98 e2		      ld    (heap_start+heap_size-4), HL 
12ab			 
12ab e1			      pop   HL 
12ac			 
12ac c9			      ret 
12ad			 
12ad			 
12ad			;------------------------------------------------------------------------------ 
12ad			;     malloc                                                                  : 
12ad			;                                                                             : 
12ad			; Description                                                                 : 
12ad			;     Allocates the wanted space from the heap and returns the address of the : 
12ad			;     first useable byte of the allocation.                                   : 
12ad			;                                                                             : 
12ad			;     Allocations can happen in one of two ways:                              : 
12ad			;                                                                             : 
12ad			;     1. A free block may be found which is the exact size wanted. In this    : 
12ad			;        case the block is removed from the free list and retuedn to the      : 
12ad			;        caller.                                                              : 
12ad			;     2. A free block may be found which is larger than the size wanted. In   : 
12ad			;        this case, the larger block is split into two. The first portion of  : 
12ad			;        this block will become the requested space by the malloc call and    : 
12ad			;        is returned to the caller. The second portion becomes a new free     : 
12ad			;        block, and the free list is adjusted to maintain continuity via this : 
12ad			;        newly created block.                                                 : 
12ad			;                                                                             : 
12ad			;     malloc does not set any initial value in the allocated space, the       : 
12ad			;     caller is required to do this as required.                              : 
12ad			;                                                                             : 
12ad			;     This implementation of malloc uses the stack exclusively, and is        : 
12ad			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12ad			;     advisable to disable interrupts before calling malloc, and recommended  : 
12ad			;     to avoid the use of malloc inside ISRs in general.                      : 
12ad			;                                                                             : 
12ad			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12ad			;                                                                             : 
12ad			; Parameters                                                                  : 
12ad			;     HL  Number of bytes wanted                                              : 
12ad			;                                                                             : 
12ad			; Returns                                                                     : 
12ad			;     HL  Address of the first useable byte of the allocation                 : 
12ad			;                                                                             : 
12ad			; Flags                                                                       : 
12ad			;     Z   Set if the allocation did not succeed, clear otherwise              : 
12ad			;                                                                             : 
12ad			; Stack frame                                                                 : 
12ad			;       |             |                                                       : 
12ad			;       +-------------+                                                       : 
12ad			;       |     BC      |                                                       : 
12ad			;       +-------------+                                                       : 
12ad			;       |     DE      |                                                       : 
12ad			;       +-------------+                                                       : 
12ad			;       |     IX      |                                                       : 
12ad			;       +-------------+                                                       : 
12ad			;       |  prev_free  |                                                       : 
12ad			;   +4  +-------------+                                                       : 
12ad			;       |  this_free  |                                                       : 
12ad			;   +2  +-------------+                                                       : 
12ad			;       |  next_free  |                                                       : 
12ad			;   +0  +-------------+                                                       : 
12ad			;       |             |                                                       : 
12ad			;                                                                             : 
12ad			;------------------------------------------------------------------------------ 
12ad			 
12ad			 
12ad			;malloc: 
12ad			; 
12ad			;	SAVESP ON 1 
12ad			; 
12ad			;	call malloc_code 
12ad			; 
12ad			;	CHECKSP ON 1 
12ad			;	ret 
12ad			 
12ad			 
12ad			malloc: 
12ad c5			      push  BC 
12ae d5			      push  DE 
12af dd e5		      push  IX 
12b1			if DEBUG_FORTH_MALLOC_HIGH 
12b1			call malloc_guard_entry 
12b1			endif 
12b1			 
12b1					if DEBUG_FORTH_MALLOC 
12b1						DMARK "mal" 
12b1						CALLMONITOR 
12b1					endif 
12b1 7c			      ld    A, H                    ; Exit if no space requested 
12b2 b5			      or    L 
12b3 ca 72 13		      jp    Z, malloc_early_exit 
12b6			 
12b6			;inc hl 
12b6			;inc hl 
12b6			;inc hl 
12b6			; 
12b6			;inc hl 
12b6			;inc hl 
12b6			;inc hl 
12b6			;inc hl 
12b6			;inc hl 
12b6			;inc hl 
12b6			;inc hl 
12b6			;inc hl 
12b6			;inc hl 
12b6			 
12b6			 
12b6			 
12b6			 
12b6					if DEBUG_FORTH_MALLOC 
12b6						DMARK "maA" 
12b6						CALLMONITOR 
12b6					endif 
12b6			      ; Set up stack frame 
12b6 eb			      ex    DE, HL 
12b7 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
12ba 39			      add   HL, SP 
12bb f9			      ld    SP, HL 
12bc dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
12c0 dd 39		      add   IX, SP 
12c2			 
12c2			      ; Setup initial state 
12c2 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
12c5 19			      add   HL, DE 
12c6			 
12c6 44			      ld    B, H                    ; Move want to BC 
12c7 4d			      ld    C, L 
12c8			 
12c8 21 de 65		      ld    HL, free_list           ; Store prev_free ptr to stack 
12cb dd 75 04		      ld    (IX+4), L 
12ce dd 74 05		      ld    (IX+5), H 
12d1			 
12d1 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
12d2 23			      inc   HL 
12d3 56			      ld    D, (HL) 
12d4 dd 73 02		      ld    (IX+2), E 
12d7 dd 72 03		      ld    (IX+3), D 
12da eb			      ex    DE, HL                  ; this_free ptr into HL 
12db			 
12db					if DEBUG_FORTH_MALLOC 
12db						DMARK "maB" 
12db						CALLMONITOR 
12db					endif 
12db			      ; Loop through free block list to find some space 
12db			malloc_find_space: 
12db 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
12dc 23			      inc   HL 
12dd 56			      ld    D, (HL) 
12de			 
12de 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
12df b3			      or    E 
12e0 ca 6c 13		      jp    Z, malloc_no_space 
12e3			 
12e3 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
12e6 dd 72 01		      ld    (IX+1), D 
12e9			 
12e9			      ; Does this block have enough space to make the allocation? 
12e9 23			      inc   HL                      ; Load free block size into DE 
12ea 5e			      ld    E, (HL) 
12eb 23			      inc   HL 
12ec 56			      ld    D, (HL) 
12ed			 
12ed eb			      ex    DE, HL                  ; Check size of block against want 
12ee b7			      or    A                       ; Ensure carry flag clear 
12ef ed 42		      sbc   HL, BC 
12f1 e5			      push  HL                      ; Store the result for later (new block size) 
12f2			 
12f2 ca 41 13		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
12f5 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
12f7			 
12f7			      ; this_free block is not big enough, setup ptrs to test next free block 
12f7 e1			      pop   HL                      ; Discard previous result 
12f8			 
12f8 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
12fb dd 66 03		      ld    H, (IX+3) 
12fe dd 75 04		      ld    (IX+4), L 
1301 dd 74 05		      ld    (IX+5), H 
1304			 
1304 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1307 dd 66 01		      ld    H, (IX+1) 
130a dd 75 02		      ld    (IX+2), L 
130d dd 74 03		      ld    (IX+3), H 
1310			 
1310					if DEBUG_FORTH_MALLOC 
1310						DMARK "MA>" 
1310						CALLMONITOR 
1310					endif 
1310 18 c9		      jr    malloc_find_space 
1312			 
1312			      ; split a bigger block into two - requested size and remaining size 
1312			malloc_alloc_split: 
1312					if DEBUG_FORTH_MALLOC 
1312						DMARK "MAs" 
1312						CALLMONITOR 
1312					endif 
1312 eb			      ex    DE, HL                  ; Calculate address of new free block 
1313 2b			      dec   HL 
1314 2b			      dec   HL 
1315 2b			      dec   HL 
1316 09			      add   HL, BC 
1317			 
1317			      ; Create a new block and point it at next_free 
1317 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
131a dd 56 01		      ld    D, (IX+1) 
131d			 
131d 73			      ld    (HL), E                 ; Store next_free ptr into new block 
131e 23			      inc   HL 
131f 72			      ld    (HL), D 
1320			 
1320 d1			      pop   DE                      ; Store size of new block into new block 
1321 23			      inc   HL 
1322 73			      ld    (HL), E 
1323 23			      inc   HL 
1324 72			      ld    (HL), D 
1325			 
1325			      ; Update this_free ptr to point to new block 
1325 2b			      dec   HL 
1326 2b			      dec   HL 
1327 2b			      dec   HL 
1328			 
1328 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
132b dd 56 03		      ld    D, (IX+3) 
132e			 
132e dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1331 dd 74 03		      ld    (IX+3), H 
1334			 
1334			      ; Modify this_free block to be allocation 
1334 eb			      ex    DE, HL 
1335 af			      xor   A                       ; Null the next block ptr of allocated block 
1336 77			      ld    (HL), A 
1337 23			      inc   HL 
1338 77			      ld    (HL), A 
1339			 
1339 23			      inc   HL                      ; Store want size into allocated block 
133a 71			      ld    (HL), C 
133b 23			      inc   HL 
133c 70			      ld    (HL), B 
133d 23			      inc   HL 
133e e5			      push  HL                      ; Address of allocation to return 
133f			 
133f 18 19		      jr    malloc_update_links 
1341			 
1341			malloc_alloc_fit: 
1341 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1342			 
1342					if DEBUG_FORTH_MALLOC 
1342						DMARK "MAf" 
1342						CALLMONITOR 
1342					endif 
1342			      ; Modify this_free block to be allocation 
1342 eb			      ex    DE, HL 
1343 2b			      dec   HL 
1344 2b			      dec   HL 
1345 2b			      dec   HL 
1346			 
1346 af			      xor   A                       ; Null the next block ptr of allocated block 
1347 77			      ld    (HL), A 
1348 23			      inc   HL 
1349 77			      ld    (HL), A 
134a			 
134a 23			      inc   HL                      ; Store address of allocation to return 
134b 23			      inc   HL 
134c 23			      inc   HL 
134d e5			      push  HL 
134e			 
134e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
134e dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1351 dd 66 01		      ld    H, (IX+1) 
1354			 
1354 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1357 dd 74 03		      ld    (IX+3), H 
135a			 
135a			 
135a			malloc_update_links: 
135a			      ; Update prev_free ptr to point to this_free 
135a dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
135d dd 66 05		      ld    H, (IX+5) 
1360			 
1360 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1363 dd 56 03		      ld    D, (IX+3) 
1366			 
1366 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1367 23			      inc   HL 
1368 72			      ld    (HL), D 
1369			 
1369					if DEBUG_FORTH_MALLOC 
1369						DMARK "Mul" 
1369						CALLMONITOR 
1369					endif 
1369			      ; Clear the Z flag to indicate successful allocation 
1369 7a			      ld    A, D 
136a b3			      or    E 
136b			 
136b d1			      pop   DE                      ; Address of allocation 
136c					if DEBUG_FORTH_MALLOC 
136c						DMARK "MAu" 
136c						CALLMONITOR 
136c					endif 
136c			 
136c			malloc_no_space: 
136c 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
136f 39			      add   HL, SP 
1370 f9			      ld    SP, HL 
1371			 
1371 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1372					if DEBUG_FORTH_MALLOC 
1372						DMARK "MAN" 
1372						CALLMONITOR 
1372					endif 
1372			 
1372			malloc_early_exit: 
1372					if DEBUG_FORTH_MALLOC 
1372						DMARK "MAx" 
1372						CALLMONITOR 
1372					endif 
1372 dd e1		      pop   IX 
1374 d1			      pop   DE 
1375 c1			      pop   BC 
1376			 
1376			if DEBUG_FORTH_MALLOC_HIGH 
1376			call malloc_guard_exit 
1376			call malloc_guard_zerolen 
1376			endif 
1376 c9			      ret 
1377			 
1377			 
1377			;------------------------------------------------------------------------------ 
1377			;     free                                                                    : 
1377			;                                                                             : 
1377			; Description                                                                 : 
1377			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1377			;     returned by malloc, otherwise the behaviour is undefined.               : 
1377			;                                                                             : 
1377			;     Where possible, directly adjacent free blocks will be merged together   : 
1377			;     into larger blocks to help ensure that the heap does not become         : 
1377			;     excessively fragmented.                                                 : 
1377			;                                                                             : 
1377			;     free does not clear or set any other value into the freed space, and    : 
1377			;     therefore its contents may be visible through subsequent malloc's. The  : 
1377			;     caller should clear the freed space as required.                        : 
1377			;                                                                             : 
1377			;     This implementation of free uses the stack exclusively, and is          : 
1377			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1377			;     advisable to disable interrupts before calling free, and recommended    : 
1377			;     to avoid the use of free inside ISRs in general.                        : 
1377			;                                                                             : 
1377			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1377			;                                                                             : 
1377			; Parameters                                                                  : 
1377			;     HL  Pointer to address of first byte of allocation to be freed          : 
1377			;                                                                             : 
1377			; Returns                                                                     : 
1377			;     Nothing                                                                 : 
1377			;                                                                             : 
1377			; Stack frame                                                                 : 
1377			;       |             |                                                       : 
1377			;       +-------------+                                                       : 
1377			;       |     BC      |                                                       : 
1377			;       +-------------+                                                       : 
1377			;       |     DE      |                                                       : 
1377			;       +-------------+                                                       : 
1377			;       |     IX      |                                                       : 
1377			;       +-------------+                                                       : 
1377			;       |  prev_free  |                                                       : 
1377			;   +2  +-------------+                                                       : 
1377			;       |  next_free  |                                                       : 
1377			;   +0  +-------------+                                                       : 
1377			;       |             |                                                       : 
1377			;                                                                             : 
1377			;------------------------------------------------------------------------------ 
1377			free: 
1377 c5			      push  BC 
1378 d5			      push  DE 
1379 dd e5		      push  IX 
137b			 
137b 7c			      ld    A, H                    ; Exit if ptr is null 
137c b5			      or    L 
137d ca 41 14		      jp    Z, free_early_exit 
1380			 
1380			      ; Set up stack frame 
1380 eb			      ex    DE, HL 
1381 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1384 39			      add   HL, SP 
1385 f9			      ld    SP, HL 
1386 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
138a dd 39		      add   IX, SP 
138c			 
138c			      ; The address in HL points to the start of the useable allocated space, 
138c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
138c			      ; address of the block itself. 
138c eb			      ex    DE, HL 
138d 11 fc ff		      ld    DE, -4 
1390 19			      add   HL, DE 
1391			 
1391			      ; An allocated block must have a null next block pointer in it 
1391 7e			      ld    A, (HL) 
1392 23			      inc   HL 
1393 b6			      or    (HL) 
1394 c2 3c 14		      jp    NZ, free_done 
1397			 
1397 2b			      dec   HL 
1398			 
1398 44			      ld    B, H                    ; Copy HL to BC 
1399 4d			      ld    C, L 
139a			 
139a			      ; Loop through the free list to find the first block with an address 
139a			      ; higher than the block being freed 
139a 21 de 65		      ld    HL, free_list 
139d			 
139d			free_find_higher_block: 
139d 5e			      ld    E, (HL)                 ; Load next ptr from free block 
139e 23			      inc   HL 
139f 56			      ld    D, (HL) 
13a0 2b			      dec   HL 
13a1			 
13a1 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
13a4 dd 72 01		      ld    (IX+1), D 
13a7 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
13aa dd 74 03		      ld    (IX+3), H 
13ad			 
13ad 78			      ld    A, B                    ; Check if DE is greater than BC 
13ae ba			      cp    D                       ; Compare MSB first 
13af 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
13b1 30 04		      jr    NC, free_find_higher_block_skip 
13b3 79			      ld    A, C 
13b4 bb			      cp    E                       ; Then compare LSB 
13b5 38 08		      jr    C, free_found_higher_block 
13b7			 
13b7			free_find_higher_block_skip: 
13b7 7a			      ld    A, D                    ; Reached the end of the free list? 
13b8 b3			      or    E 
13b9 ca 3c 14		      jp    Z, free_done 
13bc			 
13bc eb			      ex    DE, HL 
13bd			 
13bd 18 de		      jr    free_find_higher_block 
13bf			 
13bf			free_found_higher_block: 
13bf			      ; Insert freed block between prev and next free blocks 
13bf 71			      ld    (HL), C                 ; Point prev free block to freed block 
13c0 23			      inc   HL 
13c1 70			      ld    (HL), B 
13c2			 
13c2 60			      ld    H, B                    ; Point freed block at next free block 
13c3 69			      ld    L, C 
13c4 73			      ld    (HL), E 
13c5 23			      inc   HL 
13c6 72			      ld    (HL), D 
13c7			 
13c7			      ; Check if the freed block is adjacent to the next free block 
13c7 23			      inc   HL                      ; Load size of freed block into HL 
13c8 5e			      ld    E, (HL) 
13c9 23			      inc   HL 
13ca 56			      ld    D, (HL) 
13cb eb			      ex    DE, HL 
13cc			 
13cc 09			      add   HL, BC                  ; Add addr of freed block and its size 
13cd			 
13cd dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
13d0 dd 56 01		      ld    D, (IX+1) 
13d3			 
13d3 b7			      or    A                       ; Clear the carry flag 
13d4 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
13d6 20 22		      jr    NZ, free_check_adjacent_to_prev 
13d8			 
13d8			      ; Freed block is adjacent to next, merge into one bigger block 
13d8 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
13d9 5e			      ld    E, (HL) 
13da 23			      inc   HL 
13db 56			      ld    D, (HL) 
13dc e5			      push  HL                      ; Save ptr to next block for later 
13dd			 
13dd 60			      ld    H, B                    ; Store ptr from next block into freed block 
13de 69			      ld    L, C 
13df 73			      ld    (HL), E 
13e0 23			      inc   HL 
13e1 72			      ld    (HL), D 
13e2			 
13e2 e1			      pop   HL                      ; Restore ptr to next block 
13e3 23			      inc   HL                      ; Load size of next block into DE 
13e4 5e			      ld    E, (HL) 
13e5 23			      inc   HL 
13e6 56			      ld    D, (HL) 
13e7 d5			      push  DE                      ; Save next block size for later 
13e8			 
13e8 60			      ld    H, B                    ; Load size of freed block into HL 
13e9 69			      ld    L, C 
13ea 23			      inc   HL 
13eb 23			      inc   HL 
13ec 5e			      ld    E, (HL) 
13ed 23			      inc   HL 
13ee 56			      ld    D, (HL) 
13ef eb			      ex    DE, HL 
13f0			 
13f0 d1			      pop   DE                      ; Restore size of next block 
13f1 19			      add   HL, DE                  ; Add sizes of both blocks 
13f2 eb			      ex    DE, HL 
13f3			 
13f3 60			      ld    H, B                    ; Store new bigger size into freed block 
13f4 69			      ld    L, C 
13f5 23			      inc   HL 
13f6 23			      inc   HL 
13f7 73			      ld    (HL), E 
13f8 23			      inc   HL 
13f9 72			      ld    (HL), D 
13fa			 
13fa			free_check_adjacent_to_prev: 
13fa			      ; Check if the freed block is adjacent to the prev free block 
13fa dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
13fd dd 66 03		      ld    H, (IX+3) 
1400			 
1400 23			      inc   HL                      ; Size of prev free block into DE 
1401 23			      inc   HL 
1402 5e			      ld    E, (HL) 
1403 23			      inc   HL 
1404 56			      ld    D, (HL) 
1405 2b			      dec   HL 
1406 2b			      dec   HL 
1407 2b			      dec   HL 
1408			 
1408 19			      add   HL, DE                  ; Add prev block addr and size 
1409			 
1409 b7			      or    A                       ; Clear the carry flag 
140a ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
140c 20 2e		      jr    NZ, free_done 
140e			 
140e			      ; Freed block is adjacent to prev, merge into one bigger block 
140e 60			      ld    H, B                    ; Load next ptr from freed block into DE 
140f 69			      ld    L, C 
1410 5e			      ld    E, (HL) 
1411 23			      inc   HL 
1412 56			      ld    D, (HL) 
1413 e5			      push  HL                      ; Save freed block ptr for later 
1414			 
1414 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1417 dd 66 03		      ld    H, (IX+3) 
141a 73			      ld    (HL), E 
141b 23			      inc   HL 
141c 72			      ld    (HL), D 
141d			 
141d e1			      pop   HL                      ; Restore freed block ptr 
141e 23			      inc   HL                      ; Load size of freed block into DE 
141f 5e			      ld    E, (HL) 
1420 23			      inc   HL 
1421 56			      ld    D, (HL) 
1422 d5			      push  DE                      ; Save freed block size for later 
1423			 
1423 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1426 dd 66 03		      ld    H, (IX+3) 
1429 23			      inc   HL 
142a 23			      inc   HL 
142b 5e			      ld    E, (HL) 
142c 23			      inc   HL 
142d 56			      ld    D, (HL) 
142e			 
142e e1			      pop   HL                      ; Add sizes of both blocks 
142f 19			      add   HL, DE 
1430 eb			      ex    DE, HL 
1431			 
1431 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1434 dd 66 03		      ld    H, (IX+3) 
1437 23			      inc   HL 
1438 23			      inc   HL 
1439 73			      ld    (HL), E 
143a 23			      inc   HL 
143b 72			      ld    (HL), D 
143c			 
143c			free_done: 
143c 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
143f 39			      add   HL, SP 
1440 f9			      ld    SP, HL 
1441			 
1441			free_early_exit: 
1441 dd e1		      pop   IX 
1443 d1			      pop   DE 
1444 c1			      pop   BC 
1445			 
1445 c9			      ret 
1446			 
1446			; moved to firmware.asm 
1446			; 
1446			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1446			;                  .dw   0 
1446			 
1446			 
1446			endif 
1446			 
1446			 
1446			if MALLOC_3 
1446			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1446			;heap_start        .equ  0x9000      ; Starting address of heap 
1446			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1446			; 
1446			 ;     .org 0 
1446			  ;    jp    main 
1446			; 
1446			; 
1446			 ;     .org  0x100 
1446			;main: 
1446			 ;     ld    HL, 0x8100 
1446			  ;    ld    SP, HL 
1446			; 
1446			;      call  heap_init 
1446			 
1446			      ; Make some allocations 
1446			;      ld    HL, 12 
1446			;      call  malloc            ; Allocates 0x9004 
1446			; 
1446			 ;     ld    HL, 12 
1446			;      call  malloc            ; Allocates 0x9014 
1446			 
1446			;      ld    HL, 12 
1446			;      call  malloc            ; Allocates 0x9024 
1446			 
1446			      ; Free some allocations 
1446			;      ld    HL, 0x9014 
1446			;      call  free 
1446			 
1446			;      ld    HL, 0x9004 
1446			;      call  free 
1446			; 
1446			;      ld    HL, 0x9024 
1446			;      call  free 
1446			 
1446			 
1446			 ;     halt 
1446			 
1446			 
1446			;------------------------------------------------------------------------------ 
1446			;     heap_init                                                               : 
1446			;                                                                             : 
1446			; Description                                                                 : 
1446			;     Initialise the heap and make it ready for malloc and free operations.   : 
1446			;                                                                             : 
1446			;     The heap is maintained as a linked list, starting with an initial       : 
1446			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1446			;     the first free block in the heap. Each block then points to the next    : 
1446			;     free block within the heap, and the free list ends at the first block   : 
1446			;     with a null pointer to the next free block.                             : 
1446			;                                                                             : 
1446			; Parameters                                                                  : 
1446			;     Inputs are compile-time only. Two defines which specify the starting    : 
1446			;     address of the heap and its size are required, along with a memory      : 
1446			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1446			;     principally stores a pointer to the first free block in the heap.       : 
1446			;                                                                             : 
1446			; Returns                                                                     : 
1446			;     Nothing                                                                 : 
1446			;------------------------------------------------------------------------------ 
1446			heap_init: 
1446			      push  HL 
1446			 
1446			      ; Initialise free list struct 
1446			      ld    HL, heap_start 
1446			      ld    (free_list), HL 
1446			      ld    HL, 0 
1446			      ld    (free_list+2), HL 
1446			 
1446			      ; Insert first free block at bottom of heap, consumes entire heap 
1446			      ld    HL, heap_start+heap_size-4 
1446			      ld    (heap_start), HL        ; Next block (end of free list) 
1446			      ld    HL, heap_size-4 
1446			      ld    (heap_start+2), HL      ; Block size 
1446			 
1446			      ; Insert end of free list block at top of heap - two null words will 
1446			      ; terminate the free list 
1446			      ld    HL, 0 
1446			      ld    (heap_start+heap_size-2), HL 
1446			      ld    (heap_start+heap_size-4), HL 
1446			 
1446			      pop   HL 
1446			 
1446			      ret 
1446			 
1446			 
1446			;------------------------------------------------------------------------------ 
1446			;     malloc                                                                  : 
1446			;                                                                             : 
1446			; Description                                                                 : 
1446			;     Allocates the wanted space from the heap and returns the address of the : 
1446			;     first useable byte of the allocation.                                   : 
1446			;                                                                             : 
1446			;     Allocations can happen in one of two ways:                              : 
1446			;                                                                             : 
1446			;     1. A free block may be found which is the exact size wanted. In this    : 
1446			;        case the block is removed from the free list and retuedn to the      : 
1446			;        caller.                                                              : 
1446			;     2. A free block may be found which is larger than the size wanted. In   : 
1446			;        this case, the larger block is split into two. The first portion of  : 
1446			;        this block will become the requested space by the malloc call and    : 
1446			;        is returned to the caller. The second portion becomes a new free     : 
1446			;        block, and the free list is adjusted to maintain continuity via this : 
1446			;        newly created block.                                                 : 
1446			;                                                                             : 
1446			;     malloc does not set any initial value in the allocated space, the       : 
1446			;     caller is required to do this as required.                              : 
1446			;                                                                             : 
1446			;     This implementation of malloc uses the stack exclusively, and is        : 
1446			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1446			;     advisable to disable interrupts before calling malloc, and recommended  : 
1446			;     to avoid the use of malloc inside ISRs in general.                      : 
1446			;                                                                             : 
1446			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1446			;                                                                             : 
1446			; Parameters                                                                  : 
1446			;     HL  Number of bytes wanted                                              : 
1446			;                                                                             : 
1446			; Returns                                                                     : 
1446			;     HL  Address of the first useable byte of the allocation                 : 
1446			;                                                                             : 
1446			; Flags                                                                       : 
1446			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1446			;                                                                             : 
1446			; Stack frame                                                                 : 
1446			;       |             |                                                       : 
1446			;       +-------------+                                                       : 
1446			;       |     BC      |                                                       : 
1446			;       +-------------+                                                       : 
1446			;       |     DE      |                                                       : 
1446			;       +-------------+                                                       : 
1446			;       |     IX      |                                                       : 
1446			;       +-------------+                                                       : 
1446			;       |  prev_free  |                                                       : 
1446			;   +4  +-------------+                                                       : 
1446			;       |  this_free  |                                                       : 
1446			;   +2  +-------------+                                                       : 
1446			;       |  next_free  |                                                       : 
1446			;   +0  +-------------+                                                       : 
1446			;       |             |                                                       : 
1446			;                                                                             : 
1446			;------------------------------------------------------------------------------ 
1446			malloc: 
1446			      push  BC 
1446			      push  DE 
1446			      push  IX 
1446			 
1446			      ld    A, H                    ; Exit if no space requested 
1446			      or    L 
1446			      jp    Z, malloc_early_exit 
1446			 
1446			      ; Set up stack frame 
1446			      ex    DE, HL 
1446			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1446			      add   HL, SP 
1446			      ld    SP, HL 
1446			      ld    IX, 0                   ; Use IX as a frame pointer 
1446			      add   IX, SP 
1446			 
1446			      ; Setup initial state 
1446			      ld    HL, 4                   ; want must also include space used by block struct 
1446			      add   HL, DE 
1446			 
1446			      ld    B, H                    ; Move want to BC 
1446			      ld    C, L 
1446			 
1446			      ld    HL, free_list           ; Store prev_free ptr to stack 
1446			      ld    (IX+4), L 
1446			      ld    (IX+5), H 
1446			 
1446			      ld    E, (HL)                 ; Store this_free ptr to stack 
1446			      inc   HL 
1446			      ld    D, (HL) 
1446			      ld    (IX+2), E 
1446			      ld    (IX+3), D 
1446			      ex    DE, HL                  ; this_free ptr into HL 
1446			 
1446			      ; Loop through free block list to find some space 
1446			malloc_find_space: 
1446			      ld    E, (HL)                 ; Load next_free ptr into DE 
1446			      inc   HL 
1446			      ld    D, (HL) 
1446			 
1446			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1446			      or    E 
1446			      jp    Z, malloc_no_space 
1446			 
1446			      ld    (IX+0), E               ; Store next_free ptr to stack 
1446			      ld    (IX+1), D 
1446			 
1446			      ; Does this block have enough space to make the allocation? 
1446			      inc   HL                      ; Load free block size into DE 
1446			      ld    E, (HL) 
1446			      inc   HL 
1446			      ld    D, (HL) 
1446			 
1446			      ex    DE, HL                  ; Check size of block against want 
1446			      or    A                       ; Ensure carry flag clear 
1446			      sbc   HL, BC 
1446			      push  HL                      ; Store the result for later (new block size) 
1446			 
1446			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1446			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1446			 
1446			      ; this_free block is not big enough, setup ptrs to test next free block 
1446			      pop   HL                      ; Discard previous result 
1446			 
1446			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1446			      ld    H, (IX+3) 
1446			      ld    (IX+4), L 
1446			      ld    (IX+5), H 
1446			 
1446			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1446			      ld    H, (IX+1) 
1446			      ld    (IX+2), L 
1446			      ld    (IX+3), H 
1446			 
1446			      jr    malloc_find_space 
1446			 
1446			      ; split a bigger block into two - requested size and remaining size 
1446			malloc_alloc_split: 
1446			      ex    DE, HL                  ; Calculate address of new free block 
1446			      dec   HL 
1446			      dec   HL 
1446			      dec   HL 
1446			      add   HL, BC 
1446			 
1446			      ; Create a new block and point it at next_free 
1446			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1446			      ld    D, (IX+1) 
1446			 
1446			      ld    (HL), E                 ; Store next_free ptr into new block 
1446			      inc   HL 
1446			      ld    (HL), D 
1446			 
1446			      pop   DE                      ; Store size of new block into new block 
1446			      inc   HL 
1446			      ld    (HL), E 
1446			      inc   HL 
1446			      ld    (HL), D 
1446			 
1446			      ; Update this_free ptr to point to new block 
1446			      dec   HL 
1446			      dec   HL 
1446			      dec   HL 
1446			 
1446			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1446			      ld    D, (IX+3) 
1446			 
1446			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1446			      ld    (IX+3), H 
1446			 
1446			      ; Modify this_free block to be allocation 
1446			      ex    DE, HL 
1446			      xor   A                       ; Null the next block ptr of allocated block 
1446			      ld    (HL), A 
1446			      inc   HL 
1446			      ld    (HL), A 
1446			 
1446			      inc   HL                      ; Store want size into allocated block 
1446			      ld    (HL), C 
1446			      inc   HL 
1446			      ld    (HL), B 
1446			      inc   HL 
1446			      push  HL                      ; Address of allocation to return 
1446			 
1446			      jr    malloc_update_links 
1446			 
1446			malloc_alloc_fit: 
1446			      pop   HL                      ; Dont need new block size, want is exact fit 
1446			 
1446			      ; Modify this_free block to be allocation 
1446			      ex    DE, HL 
1446			      dec   HL 
1446			      dec   HL 
1446			      dec   HL 
1446			 
1446			      xor   A                       ; Null the next block ptr of allocated block 
1446			      ld    (HL), A 
1446			      inc   HL 
1446			      ld    (HL), A 
1446			 
1446			      inc   HL                      ; Store address of allocation to return 
1446			      inc   HL 
1446			      inc   HL 
1446			      push  HL 
1446			 
1446			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1446			      ld    L, (IX+0)               ; next_free to HL 
1446			      ld    H, (IX+1) 
1446			 
1446			      ld    (IX+2), L               ; HL to this_free 
1446			      ld    (IX+3), H 
1446			 
1446			 
1446			malloc_update_links: 
1446			      ; Update prev_free ptr to point to this_free 
1446			      ld    L, (IX+4)               ; prev_free ptr to HL 
1446			      ld    H, (IX+5) 
1446			 
1446			      ld    E, (IX+2)               ; this_free ptr to DE 
1446			      ld    D, (IX+3) 
1446			 
1446			      ld    (HL), E                 ; this_free ptr into prev_free 
1446			      inc   HL 
1446			      ld    (HL), D 
1446			 
1446			      ; Clear the Z flag to indicate successful allocation 
1446			      ld    A, D 
1446			      or    E 
1446			 
1446			      pop   DE                      ; Address of allocation 
1446			 
1446			malloc_no_space: 
1446			      ld    HL, 6                   ; Clean up stack frame 
1446			      add   HL, SP 
1446			      ld    SP, HL 
1446			 
1446			      ex    DE, HL                  ; Alloc addr into HL for return 
1446			 
1446			malloc_early_exit: 
1446			      pop   IX 
1446			      pop   DE 
1446			      pop   BC 
1446			 
1446			      ret 
1446			 
1446			 
1446			;------------------------------------------------------------------------------ 
1446			;     free                                                                    : 
1446			;                                                                             : 
1446			; Description                                                                 : 
1446			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1446			;     returned by malloc, otherwise the behaviour is undefined.               : 
1446			;                                                                             : 
1446			;     Where possible, directly adjacent free blocks will be merged together   : 
1446			;     into larger blocks to help ensure that the heap does not become         : 
1446			;     excessively fragmented.                                                 : 
1446			;                                                                             : 
1446			;     free does not clear or set any other value into the freed space, and    : 
1446			;     therefore its contents may be visible through subsequent malloc's. The  : 
1446			;     caller should clear the freed space as required.                        : 
1446			;                                                                             : 
1446			;     This implementation of free uses the stack exclusively, and is          : 
1446			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1446			;     advisable to disable interrupts before calling free, and recommended    : 
1446			;     to avoid the use of free inside ISRs in general.                        : 
1446			;                                                                             : 
1446			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1446			;                                                                             : 
1446			; Parameters                                                                  : 
1446			;     HL  Pointer to address of first byte of allocation to be freed          : 
1446			;                                                                             : 
1446			; Returns                                                                     : 
1446			;     Nothing                                                                 : 
1446			;                                                                             : 
1446			; Stack frame                                                                 : 
1446			;       |             |                                                       : 
1446			;       +-------------+                                                       : 
1446			;       |     BC      |                                                       : 
1446			;       +-------------+                                                       : 
1446			;       |     DE      |                                                       : 
1446			;       +-------------+                                                       : 
1446			;       |     IX      |                                                       : 
1446			;       +-------------+                                                       : 
1446			;       |  prev_free  |                                                       : 
1446			;   +2  +-------------+                                                       : 
1446			;       |  next_free  |                                                       : 
1446			;   +0  +-------------+                                                       : 
1446			;       |             |                                                       : 
1446			;                                                                             : 
1446			;------------------------------------------------------------------------------ 
1446			free: 
1446			      push  BC 
1446			      push  DE 
1446			      push  IX 
1446			 
1446			      ld    A, H                    ; Exit if ptr is null 
1446			      or    L 
1446			      jp    Z, free_early_exit 
1446			 
1446			      ; Set up stack frame 
1446			      ex    DE, HL 
1446			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1446			      add   HL, SP 
1446			      ld    SP, HL 
1446			      ld    IX, 0                   ; Use IX as a frame pointer 
1446			      add   IX, SP 
1446			 
1446			      ; The address in HL points to the start of the useable allocated space, 
1446			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1446			      ; address of the block itself. 
1446			      ex    DE, HL 
1446			      ld    DE, -4 
1446			      add   HL, DE 
1446			 
1446			      ; An allocated block must have a null next block pointer in it 
1446			      ld    A, (HL) 
1446			      inc   HL 
1446			      or    (HL) 
1446			      jp    NZ, free_done 
1446			 
1446			      dec   HL 
1446			 
1446			      ld    B, H                    ; Copy HL to BC 
1446			      ld    C, L 
1446			 
1446			      ; Loop through the free list to find the first block with an address 
1446			      ; higher than the block being freed 
1446			      ld    HL, free_list 
1446			 
1446			free_find_higher_block: 
1446			      ld    E, (HL)                 ; Load next ptr from free block 
1446			      inc   HL 
1446			      ld    D, (HL) 
1446			      dec   HL 
1446			 
1446			      ld    (IX+0), E               ; Save ptr to next free block 
1446			      ld    (IX+1), D 
1446			      ld    (IX+2), L               ; Save ptr to prev free block 
1446			      ld    (IX+3), H 
1446			 
1446			      ld    A, B                    ; Check if DE is greater than BC 
1446			      cp    D                       ; Compare MSB first 
1446			      jr    Z, $+4                  ; MSB the same, compare LSB 
1446			      jr    NC, free_find_higher_block_skip 
1446			      ld    A, C 
1446			      cp    E                       ; Then compare LSB 
1446			      jr    C, free_found_higher_block 
1446			 
1446			free_find_higher_block_skip: 
1446			      ld    A, D                    ; Reached the end of the free list? 
1446			      or    E 
1446			      jp    Z, free_done 
1446			 
1446			      ex    DE, HL 
1446			 
1446			      jr    free_find_higher_block 
1446			 
1446			free_found_higher_block: 
1446			      ; Insert freed block between prev and next free blocks 
1446			      ld    (HL), C                 ; Point prev free block to freed block 
1446			      inc   HL 
1446			      ld    (HL), B 
1446			 
1446			      ld    H, B                    ; Point freed block at next free block 
1446			      ld    L, C 
1446			      ld    (HL), E 
1446			      inc   HL 
1446			      ld    (HL), D 
1446			 
1446			      ; Check if the freed block is adjacent to the next free block 
1446			      inc   HL                      ; Load size of freed block into HL 
1446			      ld    E, (HL) 
1446			      inc   HL 
1446			      ld    D, (HL) 
1446			      ex    DE, HL 
1446			 
1446			      add   HL, BC                  ; Add addr of freed block and its size 
1446			 
1446			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1446			      ld    D, (IX+1) 
1446			 
1446			      or    A                       ; Clear the carry flag 
1446			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1446			      jr    NZ, free_check_adjacent_to_prev 
1446			 
1446			      ; Freed block is adjacent to next, merge into one bigger block 
1446			      ex    DE, HL                  ; Load next ptr from next block into DE 
1446			      ld    E, (HL) 
1446			      inc   HL 
1446			      ld    D, (HL) 
1446			      push  HL                      ; Save ptr to next block for later 
1446			 
1446			      ld    H, B                    ; Store ptr from next block into freed block 
1446			      ld    L, C 
1446			      ld    (HL), E 
1446			      inc   HL 
1446			      ld    (HL), D 
1446			 
1446			      pop   HL                      ; Restore ptr to next block 
1446			      inc   HL                      ; Load size of next block into DE 
1446			      ld    E, (HL) 
1446			      inc   HL 
1446			      ld    D, (HL) 
1446			      push  DE                      ; Save next block size for later 
1446			 
1446			      ld    H, B                    ; Load size of freed block into HL 
1446			      ld    L, C 
1446			      inc   HL 
1446			      inc   HL 
1446			      ld    E, (HL) 
1446			      inc   HL 
1446			      ld    D, (HL) 
1446			      ex    DE, HL 
1446			 
1446			      pop   DE                      ; Restore size of next block 
1446			      add   HL, DE                  ; Add sizes of both blocks 
1446			      ex    DE, HL 
1446			 
1446			      ld    H, B                    ; Store new bigger size into freed block 
1446			      ld    L, C 
1446			      inc   HL 
1446			      inc   HL 
1446			      ld    (HL), E 
1446			      inc   HL 
1446			      ld    (HL), D 
1446			 
1446			free_check_adjacent_to_prev: 
1446			      ; Check if the freed block is adjacent to the prev free block 
1446			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1446			      ld    H, (IX+3) 
1446			 
1446			      inc   HL                      ; Size of prev free block into DE 
1446			      inc   HL 
1446			      ld    E, (HL) 
1446			      inc   HL 
1446			      ld    D, (HL) 
1446			      dec   HL 
1446			      dec   HL 
1446			      dec   HL 
1446			 
1446			      add   HL, DE                  ; Add prev block addr and size 
1446			 
1446			      or    A                       ; Clear the carry flag 
1446			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1446			      jr    NZ, free_done 
1446			 
1446			      ; Freed block is adjacent to prev, merge into one bigger block 
1446			      ld    H, B                    ; Load next ptr from freed block into DE 
1446			      ld    L, C 
1446			      ld    E, (HL) 
1446			      inc   HL 
1446			      ld    D, (HL) 
1446			      push  HL                      ; Save freed block ptr for later 
1446			 
1446			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1446			      ld    H, (IX+3) 
1446			      ld    (HL), E 
1446			      inc   HL 
1446			      ld    (HL), D 
1446			 
1446			      pop   HL                      ; Restore freed block ptr 
1446			      inc   HL                      ; Load size of freed block into DE 
1446			      ld    E, (HL) 
1446			      inc   HL 
1446			      ld    D, (HL) 
1446			      push  DE                      ; Save freed block size for later 
1446			 
1446			      ld    L, (IX+2)               ; Load size of prev block into DE 
1446			      ld    H, (IX+3) 
1446			      inc   HL 
1446			      inc   HL 
1446			      ld    E, (HL) 
1446			      inc   HL 
1446			      ld    D, (HL) 
1446			 
1446			      pop   HL                      ; Add sizes of both blocks 
1446			      add   HL, DE 
1446			      ex    DE, HL 
1446			 
1446			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1446			      ld    H, (IX+3) 
1446			      inc   HL 
1446			      inc   HL 
1446			      ld    (HL), E 
1446			      inc   HL 
1446			      ld    (HL), D 
1446			 
1446			free_done: 
1446			      ld    HL, 4                   ; Clean up stack frame 
1446			      add   HL, SP 
1446			      ld    SP, HL 
1446			 
1446			free_early_exit: 
1446			      pop   IX 
1446			      pop   DE 
1446			      pop   BC 
1446			 
1446			      ret 
1446			 
1446			 
1446			;      .org 0x8000 
1446			; 
1446			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1446			 ;                 .dw   0 
1446			 
1446			endif 
1446			 
1446			 
1446			if MALLOC_4 
1446			 
1446			; My memory allocation code. Very very simple.... 
1446			; allocate space under 250 chars 
1446			 
1446			heap_init: 
1446				; init start of heap as zero 
1446				;  
1446			 
1446				ld hl, heap_start 
1446				ld a, 0 
1446				ld (hl), a      ; empty block 
1446				inc hl 
1446				ld a, 0 
1446				ld (hl), a      ; length of block 
1446				; write end of list 
1446				inc hl 
1446				ld a,(hl) 
1446				inc hl 
1446				ld a,(hl) 
1446				 
1446			 
1446				; init some malloc vars 
1446			 
1446				ld hl, 0 
1446				ld (free_list), hl       ; store last malloc location 
1446			 
1446				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1446				ld a, 0 
1446				ld (hl), a 
1446			 
1446			 
1446				ld hl, heap_start 
1446				;  
1446				  
1446				ret 
1446			 
1446			 
1446			;    free block marker 
1446			;    requested size  
1446			;    pointer to next block 
1446			;    .... 
1446			;    next block marker 
1446			 
1446			 
1446			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1446			; 
1446			 
1446			 
1446			malloc:  
1446				push de 
1446				push bc 
1446				push af 
1446			 
1446				; hl space required 
1446				 
1446				ld c, l    ; hold space   (TODO only a max of 255) 
1446			 
1446			;	inc c     ; TODO BUG need to fix memory leak on push str 
1446			;	inc c 
1446			;	inc c 
1446			;	inc c 
1446			;	inc c 
1446			;	inc c 
1446			;	inc c 
1446			 
1446			 
1446			 
1446				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1446			 
1446				ld a, (free_list+3) 
1446				cp 0 
1446				jr z, .contheap 
1446			 
1446				ld hl, (free_list)     ; get last alloc 
1446					if DEBUG_FORTH_MALLOC_INT 
1446						DMARK "mrs" 
1446						CALLMONITOR 
1446					endif 
1446				jr .startalloc 
1446			 
1446			.contheap: 
1446				ld hl, heap_start 
1446			 
1446			.startalloc: 
1446			 
1446					if DEBUG_FORTH_MALLOC_INT 
1446						DMARK "mym" 
1446						CALLMONITOR 
1446					endif 
1446			.findblock: 
1446					if DEBUG_FORTH_MALLOC_INT 
1446						DMARK "mmf" 
1446						CALLMONITOR 
1446					endif 
1446			 
1446				ld a,(hl)  
1446				; if byte is zero then clear to use 
1446			 
1446				cp 0 
1446				jr z, .foundemptyblock 
1446			 
1446				; if byte is not clear 
1446				;     then byte is offset to next block 
1446			 
1446				inc hl 
1446				ld a, (hl) ; get size 
1446			.nextblock:	inc hl 
1446					ld e, (hl) 
1446					inc hl 
1446					ld d, (hl) 
1446					ex de, hl 
1446			;	inc hl  ; move past the store space 
1446			;	inc hl  ; move past zero index  
1446			 
1446				; TODO detect no more space 
1446			 
1446				push hl 
1446				ld de, heap_end 
1446				call cmp16 
1446				pop hl 
1446				jr nc, .nospace 
1446			 
1446				jr .findblock 
1446			 
1446			.nospace: ld hl, 0 
1446				jp .exit 
1446			 
1446			 
1446			.foundemptyblock:	 
1446					if DEBUG_FORTH_MALLOC_INT 
1446						DMARK "mme" 
1446						CALLMONITOR 
1446					endif 
1446			 
1446			; TODO has block enough space if reusing??? 
1446			 
1446				;  
1446			 
1446			; see if this block has been previously used 
1446				inc hl 
1446				ld a, (hl) 
1446				dec hl 
1446				cp 0 
1446				jr z, .newblock 
1446			 
1446					if DEBUG_FORTH_MALLOC_INT 
1446						DMARK "meR" 
1446						CALLMONITOR 
1446					endif 
1446			 
1446			; no reusing previously allocated block 
1446			 
1446			; is it smaller than previously used? 
1446				 
1446				inc hl    ; move to size 
1446				ld a, c 
1446				sub (hl)        ; we want c < (hl) 
1446				dec hl    ; move back to marker 
1446			        jr z, .findblock 
1446			 
1446				; update with the new size which should be lower 
1446			 
1446			        ;inc  hl   ; negate next move. move back to size  
1446			 
1446			.newblock: 
1446				; need to be at marker here 
1446			 
1446					if DEBUG_FORTH_MALLOC_INT 
1446						DMARK "meN" 
1446						CALLMONITOR 
1446					endif 
1446			 
1446			 
1446				ld a, c 
1446			 
1446				ld (free_list+3), a	 ; flag resume from last malloc  
1446				ld (free_list), hl    ; save out last location 
1446			 
1446			 
1446				;inc a     ; space for length byte 
1446				ld (hl), a     ; save block in use marker 
1446			 
1446				inc hl   ; move to space marker 
1446				ld (hl), a    ; save new space 
1446			 
1446				inc hl   ; move to start of allocated area 
1446				 
1446			;	push hl     ; save where we are - 1  
1446			 
1446			;	inc hl  ; move past zero index  
1446				; skip space to set down new marker 
1446			 
1446				; provide some extra space for now 
1446			 
1446				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1446				inc a 
1446				inc a 
1446			 
1446				push hl   ; save where we are in the node block 
1446			 
1446				call addatohl 
1446			 
1446				; write linked list point 
1446			 
1446				pop de     ; get our node position 
1446				ex de, hl 
1446			 
1446				ld (hl), e 
1446				inc hl 
1446				ld (hl), d 
1446			 
1446				inc hl 
1446			 
1446				; now at start of allocated data so save pointer 
1446			 
1446				push hl 
1446			 
1446				; jump to position of next node and setup empty header in DE 
1446			 
1446				ex de, hl 
1446			 
1446			;	inc hl ; move past end of block 
1446			 
1446				ld a, 0 
1446				ld (hl), a   ; empty marker 
1446				inc hl 
1446				ld (hl), a   ; size 
1446				inc hl  
1446				ld (hl), a   ; ptr 
1446				inc hl 
1446				ld (hl), a   ; ptr 
1446			 
1446			 
1446				pop hl 
1446			 
1446					if DEBUG_FORTH_MALLOC_INT 
1446						DMARK "mmr" 
1446						CALLMONITOR 
1446					endif 
1446			 
1446			.exit: 
1446				pop af 
1446				pop bc 
1446				pop de  
1446				ret 
1446			 
1446			 
1446			 
1446			 
1446			free:  
1446				push hl 
1446				push af 
1446				; get address in hl 
1446			 
1446					if DEBUG_FORTH_MALLOC_INT 
1446						DMARK "fre" 
1446						CALLMONITOR 
1446					endif 
1446				; data is at hl - move to block count 
1446				dec hl 
1446				dec hl    ; get past pointer 
1446				dec hl 
1446			 
1446				ld a, (hl)    ; need this for a validation check 
1446			 
1446				dec hl    ; move to block marker 
1446			 
1446				; now check that the block count and block marker are the same  
1446			        ; this checks that we are on a malloc node and not random memory 
1446			        ; OK a faint chance this could be a problem but rare - famous last words! 
1446			 
1446				ld c, a 
1446				ld a, (hl)    
1446			 
1446				cp c 
1446				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1446			 
1446				; yes good chance we are on a malloc node 
1446			 
1446				ld a, 0      
1446				ld (hl), a   ; mark as free 
1446			 
1446				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1446			 
1446			.freeignore:  
1446			 
1446				pop af 
1446				pop hl 
1446			 
1446				ret 
1446			 
1446			 
1446			 
1446			endif 
1446			 
1446			; eof 
# End of file firmware_memory.asm
1446			  
1446			; device C  
1446			; Now handled by SPI  
1446			;if SOUND_ENABLE  
1446			;	include "firmware_sound.asm"  
1446			;endif  
1446			  
1446			include "firmware_diags.asm"  
1446			; Hardware diags menu 
1446			 
1446			 
1446			config: 
1446			 
1446 3e 00			ld a, 0 
1448 21 6c 14			ld hl, .configmn 
144b cd ea 0b			call menu 
144e			 
144e fe 00			cp 0 
1450 c8				ret z 
1451			 
1451			;	cp 1 
1451			;	call z, .savetostore 
1451			 
1451 fe 01			cp 1 
1453			if STARTUP_V1 
1453 cc 82 14			call z, .selautoload 
1456			endif 
1456			 
1456			if STARTUP_V2 
1456				call z, .enautoload 
1456			endif 
1456 fe 02			cp 2 
1458 cc 78 14			call z, .disautoload 
145b			;	cp 3 
145b			;	call z, .selbank 
145b fe 03			cp 3 
145d cc a0 14			call z, .debug_tog 
1460 fe 04			cp 4 
1462 cc ee 15			call z, .bpsgo 
1465 fe 05			cp 5 
1467 cc c9 14			call z, hardware_diags 
146a			if STARTUP_V2 
146a				cp 6 
146a				call z, create_startup 
146a			endif 
146a 18 da			jr config 
146c			 
146c			.configmn: 
146c			;	dw prom_c3 
146c dc 17			dw prom_c2 
146e f1 17			dw prom_c2a 
1470			;	dw prom_c2b 
1470			;	dw prom_c4 
1470 10 18			dw prom_m4 
1472 2b 18			dw prom_m4b 
1474 33 18			dw prom_c1 
1476			if STARTUP_V2 
1476				dw prom_c9 
1476			endif 
1476 00 00			dw 0 
1478				 
1478			 
1478			if STARTUP_V2 
1478			.enautoload: 
1478				if STORAGE_SE 
1478				ld a, $fe      ; bit 0 clear 
1478				ld (spi_device), a 
1478			 
1478				call storage_get_block_0 
1478			 
1478				ld a, 1 
1478				ld (store_page+STORE_0_AUTOFILE), a 
1478			 
1478					ld hl, 0 
1478					ld de, store_page 
1478				call storage_write_block	 ; save update 
1478				else 
1478			 
1478				ld hl, prom_notav 
1478				ld de, prom_empty 
1478				call info_panel 
1478				endif 
1478			 
1478			 
1478				ret 
1478			endif 
1478			 
1478			.disautoload: 
1478				if STORAGE_SE 
1478				ld a, $fe      ; bit 0 clear 
1478				ld (spi_device), a 
1478			 
1478				call storage_get_block_0 
1478			 
1478				ld a, 0 
1478				ld (store_page+STORE_0_AUTOFILE), a 
1478			 
1478					ld hl, 0 
1478					ld de, store_page 
1478				call storage_write_block	 ; save update 
1478				else 
1478			 
1478 21 42 18			ld hl, prom_notav 
147b 11 58 18			ld de, prom_empty 
147e cd 4a 0b			call info_panel 
1481				endif 
1481			 
1481			 
1481 c9				ret 
1482			 
1482			if STARTUP_V1 
1482			 
1482			; Select auto start 
1482			 
1482			.selautoload: 
1482			 
1482				 
1482				if STORAGE_SE 
1482			 
1482					call config_dir 
1482				        ld hl, scratch 
1482					ld a, 0 
1482					call menu 
1482			 
1482					cp 0 
1482					ret z 
1482			 
1482					dec a 
1482			 
1482			 
1482					; locate menu option 
1482			 
1482					ld hl, scratch 
1482					call table_lookup 
1482			 
1482					if DEBUG_FORTH_WORDS 
1482						DMARK "ALl" 
1482						CALLMONITOR 
1482					endif 
1482					; with the pointer to the menu it, the byte following the zero term is the file id 
1482			 
1482					ld a, 0 
1482					ld bc, 50   ; max of bytes to look at 
1482					cpir  
1482			 
1482					if DEBUG_FORTH_WORDS 
1482						DMARK "ALb" 
1482						CALLMONITOR 
1482					endif 
1482					;inc hl 
1482			 
1482					ld a, (hl)   ; file id 
1482					 
1482				        ; save bank and file ids 
1482			 
1482					push af 
1482			 
1482			; TODO need to save to block 0 on bank 1	 
1482			 
1482					call storage_get_block_0 
1482			 
1482					if DEBUG_FORTH_WORDS 
1482						DMARK "AL0" 
1482						CALLMONITOR 
1482					endif 
1482					pop af 
1482			 
1482					ld (store_page+STORE_0_FILERUN),a 
1482					 
1482					; save bank id 
1482			 
1482					ld a,(spi_device) 
1482					ld (store_page+STORE_0_BANKRUN),a 
1482			 
1482					; enable auto run of store file 
1482			 
1482					ld a, 1 
1482					ld (store_page+STORE_0_AUTOFILE),a 
1482			 
1482					; save buffer 
1482			 
1482					ld hl, 0 
1482					ld de, store_page 
1482					if DEBUG_FORTH_WORDS 
1482						DMARK "ALw" 
1482						CALLMONITOR 
1482					endif 
1482				call storage_write_block	 ; save update 
1482			  
1482			 
1482			 
1482			 
1482					ld hl, scratch 
1482					call config_fdir 
1482			 
1482				else 
1482			 
1482 21 42 18			ld hl, prom_notav 
1485 11 58 18			ld de, prom_empty 
1488 cd 4a 0b			call info_panel 
148b			 
148b				endif 
148b c9				ret 
148c			endif 
148c			 
148c			 
148c			; Select storage bank 
148c			 
148c			.selbank: 
148c			 
148c			;	if STORAGE_SE 
148c			;	else 
148c			 
148c 21 42 18			ld hl, prom_notav 
148f 11 58 18			ld de, prom_empty 
1492 cd 4a 0b			call info_panel 
1495			;	endif 
1495				 
1495 c9				ret 
1496			 
1496			if STORAGE_SE 
1496			 
1496			.config_ldir:   
1496				; Load storage bank labels into menu array 
1496			 
1496				 
1496			 
1496			 
1496				ret 
1496			 
1496			 
1496			endif 
1496			 
1496			 
1496			; Save user words to storage 
1496			 
1496			.savetostore: 
1496			 
1496			;	if STORAGE_SE 
1496			; 
1496			;		call config_dir 
1496			;	        ld hl, scratch 
1496			;		ld a, 0 
1496			;		call menu 
1496			;		 
1496			;		ld hl, scratch 
1496			;		call config_fdir 
1496			; 
1496			;	else 
1496			 
1496 21 42 18			ld hl, prom_notav 
1499 11 58 18			ld de, prom_empty 
149c cd 4a 0b			call info_panel 
149f			 
149f			;	endif 
149f			 
149f c9				ret 
14a0			 
14a0			if STARTUP_V2 
14a0			 
14a0			create_startup: 
14a0			 
14a0				ld a, 0 
14a0				ld hl, .crstart 
14a0				call menu 
14a0			 
14a0				cp 0 
14a0				ret z 
14a0			 
14a0				cp 1 
14a0				call z, .genlsword 
14a0				cp 2 
14a0				call z, .genedword 
14a0			 
14a0				cp 3 
14a0				call z, .gendemword 
14a0			 
14a0				cp 4 
14a0				call z, .genutlword 
14a0				cp 5 
14a0				call z, .genspiword 
14a0				cp 6 
14a0				call z, .genkeyword 
14a0				cp 7 
14a0				call z, .gensoundword 
14a0				jr create_startup 
14a0			 
14a0			.gensoundword: 
14a0				ld hl, crs_sound 
14a0				ld de, .soundworddef 
14a0				call .genfile 
14a0				ret 
14a0			.genlsword: 
14a0				ld hl, crs_s1 
14a0				ld de, .lsworddef 
14a0				call .genfile 
14a0				ret 
14a0			 
14a0			.genedword: 
14a0				ld de, .edworddef 
14a0				ld hl, crs_s2 
14a0				call .genfile 
14a0				ret 
14a0			 
14a0			.gendemword: 
14a0				ld de, .demoworddef 
14a0				ld hl, crs_s3 
14a0				call .genfile 
14a0				ret 
14a0			 
14a0			.genutlword: 
14a0				ld hl, crs_s4 
14a0				ld de, .utilwordef 
14a0				call .genfile 
14a0				ret 
14a0			.genspiword: 
14a0				ld hl, crs_s5 
14a0				ld de, .spiworddef 
14a0				call .genfile 
14a0				ret 
14a0			.genkeyword: 
14a0				ld hl, crs_s6 
14a0				ld de, .keyworddef 
14a0				call .genfile 
14a0				ret 
14a0			 
14a0			; hl - points to file name 
14a0			; de - points to strings to add to file 
14a0			 
14a0			.genfile: 
14a0				push hl 
14a0				push de 
14a0			 
14a0				call clear_display 
14a0				ld a, display_row_1 
14a0				ld de, .genfiletxt 
14a0				call str_at_display 
14a0				call update_display 
14a0			 
14a0				pop de 
14a0				pop hl 
14a0			 
14a0			 
14a0				push de 
14a0				call storage_create 
14a0				; id in hl 
14a0				pop de   ; table of strings to add 
14a0			 
14a0			.genloop: 
14a0			 
14a0				push hl ; save id for next time around 
14a0				push de ; save de for next time around 
14a0			 
14a0				ex de, hl 
14a0				call loadwordinhl 
14a0				ex de, hl 
14a0			 
14a0				; need hl to be the id 
14a0				; need de to be the string ptr 
14a0				 
14a0				call storage_append 
14a0			 
14a0				pop de 
14a0				pop hl 
14a0			 
14a0				inc de 
14a0				inc de 
14a0			 
14a0				ld a,(de) 
14a0				cp 0 
14a0				jr nz, .genloop 
14a0				inc de 
14a0				ld a, (de) 
14a0				dec de 
14a0				cp 0 
14a0				jr nz, .genloop	 
14a0			 
14a0				ret 
14a0			 
14a0			.genfiletxt:  db "Creating file...",0 
14a0			 
14a0			.soundworddef: 
14a0				dw sound1 
14a0				dw sound2 
14a0				dw sound3 
14a0				dw sound4 
14a0				dw sound5 
14a0				dw sound6 
14a0				dw sound7 
14a0				dw sound8 
14a0				dw sound9 
14a0				dw 0 
14a0			 
14a0			.utilwordef: 
14a0				dw strncpy 
14a0				dw type 
14a0				dw clrstack 
14a0				dw longread 
14a0				dw start1 
14a0				dw start2 
14a0				dw start3b 
14a0				dw start3c 
14a0				dw list 
14a0				dw 0 
14a0			 
14a0			.lsworddef: 
14a0				dw start3b 
14a0				dw 0 
14a0			 
14a0			.edworddef: 
14a0				dw edit1 
14a0				dw edit2 
14a0				dw edit3 
14a0				dw 0 
14a0			 
14a0			.demoworddef: 
14a0				dw test5 
14a0				dw test6 
14a0				dw test7 
14a0				dw test8 
14a0				dw test9 
14a0				dw test10 
14a0				dw game1 
14a0				dw game1a 
14a0				dw game1b 
14a0				dw game1c 
14a0				dw game1d 
14a0				dw game1s 
14a0				dw game1t 
14a0				dw game1f 
14a0				dw game1z 
14a0				dw game1zz 
14a0				dw ssv2 
14a0				dw ssv3 
14a0				dw ssv4 
14a0				dw ssv5 
14a0				dw ssv1 
14a0				dw ssv1cpm	 
14a0				dw game2b 
14a0				dw game2bf 
14a0				dw game2mba 
14a0				dw game2mbas	 
14a0				dw game2mbht 
14a0				dw game2mbms 
14a0				dw game2mb 
14a0				dw game3w 
14a0				dw game3p 
14a0				dw game3sc 
14a0				dw game3vsi 
14a0				dw game3vs 
14a0				dw 0 
14a0			 
14a0			 
14a0			.spiworddef: 
14a0			 
14a0			    dw spi1 
14a0			    dw spi2 
14a0			    dw spi3 
14a0			    dw spi4 
14a0			    dw spi5 
14a0			    dw spi6 
14a0			    dw spi7 
14a0			 
14a0			    dw spi8 
14a0			    dw spi9 
14a0			    dw spi10 
14a0			    dw 0 
14a0			 
14a0			.keyworddef: 
14a0			 
14a0				dw keyup 
14a0				dw keydown 
14a0				dw keyleft 
14a0				dw keyright 
14a0				dw 	keyf1 
14a0				dw keyf2 
14a0				dw keyf3 
14a0				dw keyf4 
14a0				dw keyf5 
14a0				dw keyf6 
14a0				dw keyf7 
14a0				dw keyf8 
14a0				dw keyf9 
14a0				dw keyf10 
14a0				dw keyf11 
14a0				dw keyf12 
14a0				dw keytab 
14a0				dw keycr 
14a0				dw keyhome 
14a0				dw keyend 
14a0				dw keybs 
14a0				dw 0 
14a0			 
14a0			.crstart: 
14a0				dw crs_s1 
14a0				dw crs_s2 
14a0				dw crs_s3 
14a0				dw crs_s4 
14a0				dw crs_s5 
14a0				dw crs_s6 
14a0				dw crs_sound 
14a0				dw 0 
14a0			 
14a0			endif 
14a0			 
14a0			 
14a0			if STORAGE_SE 
14a0			 
14a0			config_fdir: 
14a0				; using the scratch dir go through and release the memory allocated for each string 
14a0				 
14a0				ld hl, scratch 
14a0			.cfdir:	ld e,(hl) 
14a0				inc hl 
14a0				ld d,(hl) 
14a0				inc hl 
14a0			 
14a0				ex de, hl 
14a0				call ishlzero 
14a0				ret z     ; return on null pointer 
14a0				call free 
14a0				ex de, hl 
14a0				jr .cfdir 
14a0			 
14a0			 
14a0				ret 
14a0			 
14a0			 
14a0			config_dir: 
14a0			 
14a0				; for the config menus that need to build a directory of storage call this routine 
14a0				; it will construct a menu in scratch to pass to menu 
14a0			 
14a0				; open storage device 
14a0			 
14a0				; execute DIR to build a list of files and their ids into scratch in menu format 
14a0				; once the menu has finished then will need to call config_fdir to release the strings 
14a0				 
14a0				; c = number items 
14a0			 
14a0				 
14a0				call storage_get_block_0 
14a0			 
14a0				ld hl, store_page     ; get current id count 
14a0				ld b, (hl) 
14a0				ld c, 0    ; count of files   
14a0			 
14a0			 
14a0				ld hl, scratch 
14a0				ld (store_tmp2), hl    ; location to poke strings 
14a0			 
14a0				; check for empty drive 
14a0			 
14a0				ld a, 0 
14a0				cp b 
14a0				jp z, .dirdone 
14a0			 
14a0				 
14a0					if DEBUG_FORTH_WORDS 
14a0						DMARK "Cdc" 
14a0						CALLMONITOR 
14a0					endif 
14a0			 
14a0			 
14a0			.diritem:	 
14a0				push bc 
14a0				; for each of the current ids do a search for them and if found push to stack 
14a0			 
14a0					ld hl, STORE_BLOCK_PHY 
14a0					ld d, 0		 ; look for extent 0 of block id as this contains file name 
14a0					ld e,b 
14a0			 
14a0					call storage_findnextid 
14a0			 
14a0			 
14a0					; if found hl will be non zero 
14a0			 
14a0					call ishlzero 
14a0					jr z, .dirnotfound 
14a0			 
14a0					; increase count 
14a0			 
14a0					pop bc	 
14a0					inc c 
14a0					push bc 
14a0					 
14a0			 
14a0					; get file header and push the file name 
14a0			 
14a0					ld de, store_page 
14a0					call storage_read_block 
14a0			 
14a0					; push file id to stack 
14a0				 
14a0					ld a, (store_page) 
14a0					ld h, 0 
14a0					ld l, a 
14a0			 
14a0					;call forth_push_numhl 
14a0					; TODO store id 
14a0			 
14a0					push hl 
14a0			 
14a0					; push extent count to stack  
14a0				 
14a0					ld hl, store_page+3 
14a0			 
14a0					; get file name length 
14a0			 
14a0					call strlenz   
14a0			 
14a0					inc hl   ; cover zero term 
14a0					inc hl  ; stick the id at the end of the area 
14a0			 
14a0					push hl 
14a0					pop bc    ; move length to bc 
14a0			 
14a0					call malloc 
14a0			 
14a0					; TODO save malloc area to scratch 
14a0			 
14a0					ex de, hl 
14a0					ld hl, (store_tmp2) 
14a0					ld (hl), e 
14a0					inc hl 
14a0					ld (hl), d 
14a0					inc hl 
14a0					ld (store_tmp2), hl 
14a0			 
14a0					 
14a0			 
14a0					;pop hl   ; get source 
14a0			;		ex de, hl    ; swap aronund	 
14a0			 
14a0					ld hl, store_page+3 
14a0					if DEBUG_FORTH_WORDS 
14a0						DMARK "CFd" 
14a0						CALLMONITOR 
14a0					endif 
14a0					ldir 
14a0			 
14a0					; de is past string, move back one and store id 
14a0					 
14a0					dec de 
14a0			 
14a0					; store file id 
14a0			 
14a0					pop hl 
14a0					ex de,hl 
14a0					ld (hl), e 
14a0			 
14a0					if DEBUG_FORTH_WORDS 
14a0						DMARK "Cdi" 
14a0						CALLMONITOR 
14a0					endif 
14a0					 
14a0			.dirnotfound: 
14a0					pop bc     
14a0					djnz .diritem 
14a0				 
14a0			.dirdone:	 
14a0			 
14a0					ld a, 0 
14a0					ld hl, (store_tmp2) 
14a0					ld (hl), a 
14a0					inc hl 
14a0					ld (hl), a 
14a0					inc hl 
14a0					; push a count of the dir items found 
14a0			 
14a0			;		ld h, 0 
14a0			;		ld l, c 
14a0			 
14a0				ret 
14a0			 
14a0			endif 
14a0			 
14a0			 
14a0			; Settings 
14a0			; Run  
14a0			 
14a0			 
14a0			 
14a0			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
14a0			;;hd_menu2:   db "        2: Editor",0   
14a0			;hd_menu2:   db "        2: Editor       6: Menu",0   
14a0			;hd_menu3:   db "        3: Storage",0 
14a0			;hd_menu4:   db "0=quit  4: Debug",0 
14a0			;hd_don:     db "ON",0 
14a0			;hd_doff:     db "OFF",0 
14a0			; 
14a0			; 
14a0			; 
14a0			;hardware_diags_old:       
14a0			; 
14a0			;.diagmenu: 
14a0			;	call clear_display 
14a0			;	ld a, display_row_1 
14a0			;	ld de, hd_menu1 
14a0			;	call str_at_display 
14a0			; 
14a0			;	ld a, display_row_2 
14a0			;	ld de, hd_menu2 
14a0			;	call str_at_display 
14a0			; 
14a0			;	ld a, display_row_3 
14a0			;	ld de, hd_menu3 
14a0			;	call str_at_display 
14a0			; 
14a0			;	ld a,  display_row_4 
14a0			;	ld de, hd_menu4 
14a0			;	call str_at_display 
14a0			; 
14a0			;	; display debug state 
14a0			; 
14a0			;	ld de, hd_don 
14a0			;	ld a, (os_view_disable) 
14a0			;	cp 0 
14a0			;	jr z, .distog 
14a0			;	ld de, hd_doff 
14a0			;.distog: ld a, display_row_4+17 
14a0			;	call str_at_display 
14a0			; 
14a0			;	call update_display 
14a0			; 
14a0			;	call cin_wait 
14a0			; 
14a0			; 
14a0			; 
14a0			;	cp '4' 
14a0			;	jr nz, .diagn1 
14a0			; 
14a0			;	; debug toggle 
14a0			; 
14a0			;	ld a, (os_view_disable) 
14a0			;	ld b, '*' 
14a0			;	cp 0 
14a0			;	jr z, .debtog 
14a0			;	ld b, 0 
14a0			;.debtog:	 
14a0			;	ld a,b 
14a0			;	ld (os_view_disable),a 
14a0			; 
14a0			;.diagn1: cp '0' 
14a0			;	 ret z 
14a0			; 
14a0			;;	cp '1' 
14a0			;;       jp z, matrix	 
14a0			;;   TODO keyboard matrix test 
14a0			; 
14a0			;	cp '2' 
14a0			;	jp z, .diagedit 
14a0			; 
14a0			;;	cp '6' 
14a0			;;	jp z, .menutest 
14a0			;;if ENABLE_BASIC 
14a0			;;	cp '6' 
14a0			;;	jp z, basic 
14a0			;;endif 
14a0			 ; 
14a0			;	jp .diagmenu 
14a0			; 
14a0			; 
14a0			;	ret 
14a0			 
14a0			 
14a0			.debug_tog: 
14a0 21 ea 14			ld hl, .menudebug 
14a3				 
14a3			;	ld a, (os_view_disable) 
14a3			;	cp '*' 
14a3 3a 6f ee			ld a,(debug_vector) 
14a6 fe c9			cp $C9   ; RET 
14a8 20 04			jr nz,.tdon  
14aa 3e 01			ld a, 1 
14ac 18 02			jr .tog1 
14ae 3e 00		.tdon: ld a, 0 
14b0			 
14b0			.tog1: 
14b0 cd ea 0b			call menu 
14b3 fe 00			cp 0 
14b5 c8				ret z 
14b6 fe 01			cp 1    ; disable debug 
14b8 28 04			jr z, .dtog0 
14ba 3e 2a			ld a, '*' 
14bc 18 05			jr .dtogset 
14be			.dtog0:  
14be				;ld a, 0 
14be cd dc 15			call bp_on 
14c1 18 dd			jr .debug_tog 
14c3			.dtogset:  
14c3				; ld (os_view_disable), a 
14c3 cd e8 15			call bp_off 
14c6 c3 a0 14			jp .debug_tog 
14c9			 
14c9			 
14c9			hardware_diags:       
14c9			 
14c9			.diagm: 
14c9 21 dc 14			ld hl, .menuitems 
14cc 3e 00			ld a, 0 
14ce cd ea 0b			call menu 
14d1			 
14d1 fe 00		         cp 0 
14d3 c8				 ret z 
14d4			 
14d4 fe 02			cp 2 
14d6 ca 35 15			jp z, .diagedit 
14d9			 
14d9			;	cp '6' 
14d9			;	jp z, .menutest 
14d9			;if ENABLE_BASIC 
14d9			;	cp '6' 
14d9			;	jp z, basic 
14d9			;endif 
14d9			  
14d9 c3 c9 14			jp .diagm 
14dc			 
14dc				 
14dc f0 14		.menuitems:   	dw .m1 
14de fb 14				dw .m2 
14e0 02 15				dw .m3 
14e2 0a 15				dw .m5 
14e4 10 15				dw .m5a 
14e6 19 15				dw .m5b 
14e8 00 00				dw 0 
14ea			 
14ea			.menudebug: 
14ea 22 15				dw .m6 
14ec 2b 15				dw .m7 
14ee 00 00				dw 0 
14f0			 
14f0 .. 00		.m1:   db "Key Matrix",0 
14fb .. 00		.m2:   db "Editor",0 
1502 .. 00		.m3:   db "Storage",0 
150a .. 00		.m5:   db "Sound",0 
1510 .. 00		.m5a:  db "RAM Test",0 
1519 .. 00		.m5b:  db "LCD Test",0 
1522			 
1522 .. 00		.m6:   db "Debug ON",0 
152b .. 00		.m7:   db "Debug OFF",0 
1535			 
1535			; debug editor 
1535			 
1535			.diagedit: 
1535			 
1535 21 c1 e2			ld hl, scratch 
1538			;	ld bc, 250 
1538			;	ldir 
1538				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1538 3e 00			ld a, 0 
153a 77				ld (hl), a 
153b 23				inc hl 
153c 77				ld (hl), a 
153d 23				inc hl 
153e 77				ld (hl), a 
153f			 
153f cd b9 0b		        call clear_display 
1542 cd dc 0b			call update_display 
1545				;ld a, 1 
1545				;ld (hardware_diag), a 
1545			.diloop: 
1545 3e 00			ld a, display_row_1 
1547 0e 00			ld c, 0 
1549 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
154b 1e 28			ld e, 40 
154d			 
154d 21 c1 e2			ld hl, scratch	 
1550 cd 13 0e			call input_str 
1553			 
1553 3e 28			ld a, display_row_2 
1555 11 c1 e2			ld de, scratch 
1558 cd cc 0b			call str_at_display 
155b cd dc 0b			call update_display 
155e			 
155e c3 45 15			jp .diloop 
1561			 
1561			 
1561			; pass word in hl 
1561			; a has display location 
1561			display_word_at: 
1561 f5				push af 
1562 e5				push hl 
1563 7c				ld a,h 
1564 21 c6 e5			ld hl, os_word_scratch 
1567 cd e7 10			call hexout 
156a e1				pop hl 
156b 7d				ld a,l 
156c 21 c8 e5			ld hl, os_word_scratch+2 
156f cd e7 10			call hexout 
1572 21 ca e5			ld hl, os_word_scratch+4 
1575 3e 00			ld a,0 
1577 77				ld (hl),a 
1578 11 c6 e5			ld de,os_word_scratch 
157b f1				pop af 
157c cd cc 0b				call str_at_display 
157f c9				ret 
1580			 
1580			display_ptr_state: 
1580			 
1580				; to restore afterwards 
1580			 
1580 d5				push de 
1581 c5				push bc 
1582 e5				push hl 
1583 f5				push af 
1584			 
1584				; for use in here 
1584			 
1584			;	push bc 
1584			;	push de 
1584			;	push hl 
1584			;	push af 
1584			 
1584 cd b9 0b			call clear_display 
1587			 
1587 11 5f 17			ld de, .ptrstate 
158a 3e 00			ld a, display_row_1 
158c cd cc 0b			call str_at_display 
158f			 
158f				; display debug step 
158f			 
158f			 
158f 11 6b ee			ld de, debug_mark 
1592 3e 26			ld a, display_row_1+display_cols-2 
1594 cd cc 0b			call str_at_display 
1597			 
1597				; display a 
1597 11 69 17			ld de, .ptrcliptr 
159a 3e 28			ld a, display_row_2 
159c cd cc 0b			call str_at_display 
159f			 
159f f1				pop af 
15a0 2a 40 ea			ld hl,(cli_ptr) 
15a3 3e 30			ld a, display_row_2+8 
15a5 cd 61 15			call display_word_at 
15a8			 
15a8			 
15a8				; display hl 
15a8			 
15a8			 
15a8 11 71 17			ld de, .ptrclioptr 
15ab 3e 32			ld a, display_row_2+10 
15ad cd cc 0b			call str_at_display 
15b0			; 
15b0			;	pop hl 
15b0 3e 35			ld a, display_row_2+13 
15b2 2a 3e ea			ld hl,(cli_origptr) 
15b5 cd 61 15			call display_word_at 
15b8			; 
15b8			;	 
15b8			;	; display de 
15b8			 
15b8			;	ld de, .regstatede 
15b8			;	ld a, display_row_3 
15b8			;	call str_at_display 
15b8			 
15b8			;	pop de 
15b8			;	ld h,d 
15b8			;	ld l, e 
15b8			;	ld a, display_row_3+3 
15b8			;	call display_word_at 
15b8			 
15b8			 
15b8				; display bc 
15b8			 
15b8			;	ld de, .regstatebc 
15b8			;	ld a, display_row_3+10 
15b8			;	call str_at_display 
15b8			 
15b8			;	pop bc 
15b8			;	ld h,b 
15b8			;	ld l, c 
15b8			;	ld a, display_row_3+13 
15b8			;	call display_word_at 
15b8			 
15b8			 
15b8				; display dsp 
15b8			 
15b8			;	ld de, .regstatedsp 
15b8			;	ld a, display_row_4 
15b8			;	call str_at_display 
15b8			 
15b8				 
15b8			;	ld hl,(cli_data_sp) 
15b8			;	ld a, display_row_4+4 
15b8			;	call display_word_at 
15b8			 
15b8				; display rsp 
15b8			 
15b8 11 a0 17			ld de, .regstatersp 
15bb 3e 82			ld a, display_row_4+10 
15bd cd cc 0b			call str_at_display 
15c0			 
15c0				 
15c0 2a f2 e9			ld hl,(cli_ret_sp) 
15c3 3e 86			ld a, display_row_4+14 
15c5 cd 61 15			call display_word_at 
15c8			 
15c8 cd dc 0b			call update_display 
15cb			 
15cb cd f1 0a			call delay1s 
15ce cd f1 0a			call delay1s 
15d1 cd f1 0a			call delay1s 
15d4			 
15d4			 
15d4 cd be 1b			call next_page_prompt 
15d7			 
15d7				; restore  
15d7			 
15d7 f1				pop af 
15d8 e1				pop hl 
15d9 c1				pop bc 
15da d1				pop de 
15db c9				ret 
15dc			 
15dc			; Update the break point vector so that the user can hook a new routine 
15dc			 
15dc			bp_on: 
15dc 3e c3			ld a, $c3    ; JP 
15de 32 6f ee			ld (debug_vector), a 
15e1 21 ee 15			ld hl, break_point_state 
15e4 22 70 ee			ld (debug_vector+1), hl 
15e7 c9				ret 
15e8			 
15e8			bp_off: 
15e8 3e c9			ld a, $c9    ; RET 
15ea 32 6f ee			ld (debug_vector), a 
15ed c9				ret 
15ee			 
15ee			 
15ee			break_point_state: 
15ee			;	push af 
15ee			; 
15ee			;	; see if disabled 
15ee			; 
15ee			;	ld a, (os_view_disable) 
15ee			;	cp '*' 
15ee			;	jr nz, .bpsgo 
15ee			;	pop af 
15ee			;	ret 
15ee			 
15ee			.bpsgo: 
15ee			;	pop af 
15ee f5				push af 
15ef 22 a3 e2			ld (os_view_hl), hl 
15f2 ed 53 a1 e2		ld (os_view_de), de 
15f6 ed 43 9f e2		ld (os_view_bc), bc 
15fa e5				push hl 
15fb 6f				ld l, a 
15fc 26 00			ld h, 0 
15fe 22 a5 e2			ld (os_view_af),hl 
1601			 
1601 21 b1 ed				ld hl, display_fb0 
1604 22 cc eb				ld (display_fb_active), hl 
1607 e1				pop hl	 
1608			 
1608 3e 31			ld a, '1' 
160a fe 2a		.bps1:  cp '*' 
160c cc e8 15			call z, bp_off 
160f			;	jr nz, .bps1b 
160f			;	ld (os_view_disable),a 
160f fe 31		.bps1b:  cp '1' 
1611 20 14			jr nz, .bps2 
1613			 
1613				; display reg 
1613			 
1613				 
1613			 
1613 3a a5 e2			ld a, (os_view_af) 
1616 2a a3 e2			ld hl, (os_view_hl) 
1619 ed 5b a1 e2		ld de, (os_view_de) 
161d ed 4b 9f e2		ld bc, (os_view_bc) 
1621 cd bb 16			call display_reg_state 
1624 c3 a7 16			jp .bpschk 
1627			 
1627 fe 32		.bps2:  cp '2' 
1629 20 08			jr nz, .bps3 
162b				 
162b				; display hl 
162b 2a a3 e2			ld hl, (os_view_hl) 
162e cd a5 17			call display_dump_at_hl 
1631			 
1631 18 74			jr .bpschk 
1633			 
1633 fe 33		.bps3:  cp '3' 
1635 20 08			jr nz, .bps4 
1637			 
1637			        ; display de 
1637 2a a1 e2			ld hl, (os_view_de) 
163a cd a5 17			call display_dump_at_hl 
163d			 
163d 18 68			jr .bpschk 
163f fe 34		.bps4:  cp '4' 
1641 20 08			jr nz, .bps5 
1643			 
1643			        ; display bc 
1643 2a 9f e2			ld hl, (os_view_bc) 
1646 cd a5 17			call display_dump_at_hl 
1649			 
1649 18 5c			jr .bpschk 
164b fe 35		.bps5:  cp '5' 
164d 20 08		        jr nz, .bps7 
164f			 
164f				; display cur ptr 
164f 2a 40 ea			ld hl, (cli_ptr) 
1652 cd a5 17			call display_dump_at_hl 
1655			 
1655 18 50			jr .bpschk 
1657 fe 36		.bps7:  cp '6' 
1659 20 08			jr nz, .bps8b 
165b				 
165b				; display cur orig ptr 
165b 2a 3e ea			ld hl, (cli_origptr) 
165e cd a5 17			call display_dump_at_hl 
1661 18 44			jr .bpschk 
1663 fe 37		.bps8b:  cp '7' 
1665 20 08			jr nz, .bps9 
1667				 
1667				; display dsp 
1667 2a ee e9			ld hl, (cli_data_sp) 
166a cd a5 17			call display_dump_at_hl 
166d			 
166d 18 38			jr .bpschk 
166f fe 39		.bps9:  cp '9' 
1671 20 05			jr nz, .bps8c 
1673				 
1673				; display SP 
1673			;	ld hl, sp 
1673 cd a5 17			call display_dump_at_hl 
1676			 
1676 18 2f			jr .bpschk 
1678 fe 38		.bps8c:  cp '8' 
167a 20 08			jr nz, .bps8d 
167c				 
167c				; display rsp 
167c 2a f2 e9			ld hl, (cli_ret_sp) 
167f cd a5 17			call display_dump_at_hl 
1682			 
1682 18 23			jr .bpschk 
1684 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1686 20 05			jr nz, .bps8 
1688 cd 8c 19			call monitor 
168b			 
168b 18 1a			jr .bpschk 
168d fe 30		.bps8:  cp '0' 
168f 20 16			jr nz, .bpschk 
1691			 
1691 21 10 ed				ld hl, display_fb1 
1694 22 cc eb				ld (display_fb_active), hl 
1697 cd dc 0b				call update_display 
169a			 
169a				;ld a, (os_view_af) 
169a 2a a3 e2			ld hl, (os_view_hl) 
169d ed 5b a1 e2		ld de, (os_view_de) 
16a1 ed 4b 9f e2		ld bc, (os_view_bc) 
16a5 f1				pop af 
16a6 c9				ret 
16a7			 
16a7			.bpschk:   
16a7 cd f1 0a			call delay1s 
16aa 3e 9f		ld a,display_row_4 + display_cols - 1 
16ac 11 bc 1b		        ld de, endprg 
16af cd cc 0b			call str_at_display 
16b2 cd dc 0b			call update_display 
16b5 cd b3 65			call cin_wait 
16b8			 
16b8 c3 0a 16			jp .bps1 
16bb			 
16bb			 
16bb			display_reg_state: 
16bb			 
16bb				; to restore afterwards 
16bb			 
16bb d5				push de 
16bc c5				push bc 
16bd e5				push hl 
16be f5				push af 
16bf			 
16bf				; for use in here 
16bf			 
16bf c5				push bc 
16c0 d5				push de 
16c1 e5				push hl 
16c2 f5				push af 
16c3			 
16c3 cd b9 0b			call clear_display 
16c6			 
16c6 11 7b 17			ld de, .regstate 
16c9 3e 00			ld a, display_row_1 
16cb cd cc 0b			call str_at_display 
16ce			 
16ce				; display debug step 
16ce			 
16ce			 
16ce 11 6b ee			ld de, debug_mark 
16d1 3e 25			ld a, display_row_1+display_cols-3 
16d3 cd cc 0b			call str_at_display 
16d6			 
16d6				; display a 
16d6 11 97 17			ld de, .regstatea 
16d9 3e 28			ld a, display_row_2 
16db cd cc 0b			call str_at_display 
16de			 
16de e1				pop hl 
16df			;	ld h,0 
16df			;	ld l, a 
16df 3e 2b			ld a, display_row_2+3 
16e1 cd 61 15			call display_word_at 
16e4			 
16e4			 
16e4				; display hl 
16e4			 
16e4			 
16e4 11 8b 17			ld de, .regstatehl 
16e7 3e 32			ld a, display_row_2+10 
16e9 cd cc 0b			call str_at_display 
16ec			 
16ec e1				pop hl 
16ed 3e 35			ld a, display_row_2+13 
16ef cd 61 15			call display_word_at 
16f2			 
16f2				 
16f2				; display de 
16f2			 
16f2 11 8f 17			ld de, .regstatede 
16f5 3e 50			ld a, display_row_3 
16f7 cd cc 0b			call str_at_display 
16fa			 
16fa e1				pop hl 
16fb			;	ld h,d 
16fb			;	ld l, e 
16fb 3e 53			ld a, display_row_3+3 
16fd cd 61 15			call display_word_at 
1700			 
1700			 
1700				; display bc 
1700			 
1700 11 93 17			ld de, .regstatebc 
1703 3e 5a			ld a, display_row_3+10 
1705 cd cc 0b			call str_at_display 
1708			 
1708 e1				pop hl 
1709			;	ld h,b 
1709			;	ld l, c 
1709 3e 5d			ld a, display_row_3+13 
170b cd 61 15			call display_word_at 
170e			 
170e			 
170e				; display dsp 
170e			 
170e 11 9b 17			ld de, .regstatedsp 
1711 3e 78			ld a, display_row_4 
1713 cd cc 0b			call str_at_display 
1716			 
1716				 
1716 2a ee e9			ld hl,(cli_data_sp) 
1719 3e 7c			ld a, display_row_4+4 
171b cd 61 15			call display_word_at 
171e			 
171e				; display rsp 
171e			 
171e 11 a0 17			ld de, .regstatersp 
1721 3e 82			ld a, display_row_4+10 
1723 cd cc 0b			call str_at_display 
1726			 
1726				 
1726 2a f2 e9			ld hl,(cli_ret_sp) 
1729 3e 86			ld a, display_row_4+14 
172b cd 61 15			call display_word_at 
172e			 
172e cd dc 0b			call update_display 
1731			 
1731			;	call delay1s 
1731			;	call delay1s 
1731			;	call delay1s 
1731			 
1731			 
1731			;	call next_page_prompt 
1731			 
1731				; restore  
1731			 
1731 f1				pop af 
1732 e1				pop hl 
1733 c1				pop bc 
1734 d1				pop de 
1735 c9				ret 
1736			 
1736 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
174a .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
175f .. 00		.ptrstate:	db "Ptr State",0 
1769 .. 00		.ptrcliptr:     db "cli_ptr",0 
1771 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
177b .. 00		.regstate:	db "Reg State (1/0)",0 
178b .. 00		.regstatehl:	db "HL:",0 
178f .. 00		.regstatede:	db "DE:",0 
1793 .. 00		.regstatebc:	db "BC:",0 
1797 .. 00		.regstatea:	db "A :",0 
179b .. 00		.regstatedsp:	db "DSP:",0 
17a0 .. 00		.regstatersp:	db "RSP:",0 
17a5			 
17a5			display_dump_at_hl: 
17a5 e5				push hl 
17a6 d5				push de 
17a7 c5				push bc 
17a8 f5				push af 
17a9			 
17a9 22 e4 e5			ld (os_cur_ptr),hl	 
17ac cd b9 0b			call clear_display 
17af cd c6 1a			call dumpcont 
17b2			;	call delay1s 
17b2			;	call next_page_prompt 
17b2			 
17b2			 
17b2 f1				pop af 
17b3 c1				pop bc 
17b4 d1				pop de 
17b5 e1				pop hl 
17b6 c9				ret 
17b7			 
17b7			;if ENABLE_BASIC 
17b7			;	include "nascombasic.asm" 
17b7			;	basic: 
17b7			;	include "forth/FORTH.ASM" 
17b7			;endif 
17b7			 
17b7			; eof 
17b7			 
17b7			 
# End of file firmware_diags.asm
17b7			  
17b7			include "firmware_prompts.asm"  
17b7			; Prompts  
17b7			 
17b7			; boot messages 
17b7			 
17b7 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
17cc .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
17dc			 
17dc			 
17dc			; config menus 
17dc			 
17dc			;prom_c3: db "Add Dictionary To File",0 
17dc			 
17dc			if STARTUP_V1 
17dc .. 00		prom_c2: db "Select Autoload File",0 
17f1 .. 00		prom_c2a: db "Disable Autoload File", 0 
1807			endif 
1807			 
1807			if STARTUP_V2 
1807			prom_c2: db "Enable Autoload Files",0 
1807			prom_c2a: db "Disable Autoload Files", 0 
1807			 
1807			crs_s1: db "*ls-word", 0 
1807			crs_s2: db "*ed-word", 0 
1807			crs_s3: db "*Demo-Programs", 0 
1807			crs_s4: db "*Utils", 0 
1807			crs_s5: db "*SPI-Addons", 0 
1807			crs_s6: db "*Key-constants", 0 
1807			crs_sound: db "*Sound-Util", 0 
1807			 
1807			 
1807			 
1807			endif 
1807			;prom_c2b: db "Select Storage Bank",0 
1807 .. 00		prom_c4: db "Settings",0 
1810 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
182b .. 00		prom_m4b:   db "Monitor",0 
1833 .. 00		prom_c1: db "Hardware Diags",0 
1842			 
1842			 
1842			if STARTUP_V2 
1842			prom_c9: db "Create Startup Files",0 
1842			endif 
1842			 
1842 .. 00		prom_notav:    db "Feature not available",0 
1858 .. 00		prom_empty:    db "",0 
1859			 
1859			; eof 
1859			 
# End of file firmware_prompts.asm
1859			  
1859			  
1859			; eof  
1859			  
# End of file firmware.asm
1859			 
1859			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1859			;if BASE_KEV  
1859			;baseram: equ 08000h 
1859			;endif 
1859			 
1859			;if BASE_SC114 
1859			;baseram:     equ    endofcode 
1859			;endif 
1859			 
1859			 
1859			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1859			 
1859			; start system 
1859			 
1859			coldstart: 
1859				; set sp 
1859				; di/ei 
1859			 
1859 f3				di 
185a 31 00 f0			ld sp, tos 
185d cd b1 64			call init_nmi 
1860			;	ei 
1860			 
1860				; init spinner 
1860 3e 00			ld a,0 
1862 32 c6 eb			ld (display_active), a 
1865			 
1865				; disable breakpoint by default 
1865			 
1865				;ld a,'*' 
1865			;	ld a,' ' 
1865			;	ld (os_view_disable),a 
1865			 
1865				; set break point vector as new break point on or off 
1865 cd e8 15			call bp_off 
1868			 
1868				; init hardware 
1868			 
1868				; init keyboard and screen hardware 
1868			 
1868 cd 1b 01			call hardware_init 
186b			 
186b			 
186b cd f1 0a			call delay1s 
186e 3e 58			ld a, display_row_3+8 
1870 11 03 01			ld de, buildtime 
1873 cd cc 0b			call str_at_display 
1876 cd dc 0b			call update_display 
1879			 
1879 cd f1 0a			call delay1s 
187c cd f1 0a			call delay1s 
187f cd f1 0a			call delay1s 
1882			 
1882				; detect if any keys are held down to enable breakpoints at start up 
1882			 
1882 cd bb 65			call cin  
1885 fe 00			cp 0 
1887 28 03			jr z, .nokeys 
1889			 
1889				;call hardware_diags 
1889 cd 46 14			call config 
188c			 
188c			;	ld de, .bpen 
188c			;	ld a, display_row_4 
188c			;	call str_at_display 
188c			;	call update_display 
188c			; 
188c			;	ld a,0 
188c			;	ld (os_view_disable),a 
188c			; 
188c			;.bpwait: 
188c			;	call cin 
188c			;	cp 0 
188c			;	jr z, .bpwait 
188c			;	jr .nokeys 
188c			; 
188c			; 
188c			;.bpen:  db "Break points enabled!",0 
188c			 
188c			 
188c			 
188c			 
188c			 
188c			 
188c			.nokeys: 
188c			 
188c			 
188c				 
188c			 
188c			;jp  testkey 
188c			 
188c			;call storage_get_block_0 
188c			; 
188c			;ld hl, 0 
188c			;ld de, store_page 
188c			;call storage_read_block 
188c			 
188c				 
188c			;ld hl, 10 
188c			;ld de, store_page 
188c			;call storage_read_block 
188c			 
188c			 
188c			 
188c			 
188c			 
188c			;stop:	nop 
188c			;	jp stop 
188c			 
188c			 
188c			 
188c			main: 
188c cd b9 0b			call clear_display 
188f cd dc 0b			call update_display 
1892			 
1892			 
1892			 
1892			;	call testlcd 
1892			 
1892			 
1892			 
1892 cd c3 1f			call forth_init 
1895			 
1895			 
1895			warmstart: 
1895 cd 99 1f			call forth_warmstart 
1898			 
1898				; run startup word load 
1898			        ; TODO prevent this running at warmstart after crash  
1898			 
1898				if STARTUP_ENABLE 
1898			 
1898					if STARTUP_V1 
1898			 
1898						if STORAGE_SE 
1898							call forth_autoload 
1898						endif 
1898 cd 01 64					call forth_startup 
189b					endif 
189b			 
189b					if STARTUP_V2 
189b			 
189b						if STORAGE_SE 
189b							call forth_autoload 
189b						else 
189b							call forth_startup 
189b						endif 
189b			 
189b			 
189b					endif 
189b			 
189b				endif 
189b			 
189b				; show free memory after boot 
189b 11 27 19			ld de, freeram 
189e 3e 00			ld a, display_row_1 
18a0 cd cc 0b			call str_at_display 
18a3			 
18a3				; get current heap start after loading any uwords 
18a3			 
18a3				;ld de, (os_last_new_uword) 
18a3				;ex de, hl 
18a3			 
18a3			; Or use heap_size word???? 
18a3				;ld hl, heap_end 
18a3				;ld hl, heap_size 
18a3				;ld de, topusermem 
18a3				;ld de, heap_start 
18a3 ed 5b de 65			ld de, (free_list )      
18a7 21 9c e2				ld hl, heap_end 
18aa ed 52			sbc hl, de 
18ac				;push hl 
18ac				;ld a,h	         	 
18ac				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
18ac				;call hexout 
18ac			   	;pop hl 
18ac			; 
18ac			;	ld a,l 
18ac			;	ld hl, os_word_scratch+2 
18ac			;	call hexout 
18ac			;	ld hl, os_word_scratch+4 
18ac			;	ld a, 0 
18ac			;	ld (hl),a 
18ac eb				ex de, hl 
18ad 21 c6 e5			ld hl, os_word_scratch 
18b0 cd f3 11			call uitoa_16 
18b3			 
18b3			 
18b3 11 c6 e5			ld de, os_word_scratch 
18b6 3e 0d			ld a, display_row_1 + 13 
18b8 cd cc 0b			call str_at_display 
18bb cd dc 0b			call update_display 
18be			 
18be			 
18be				;call demo 
18be			 
18be			 
18be				; init scratch input area for cli commands 
18be			 
18be 21 e8 e5			ld hl, os_cli_cmd 
18c1 3e 00			ld a,0 
18c3 77				ld (hl),a 
18c4 23				inc hl 
18c5 77				ld (hl),a 
18c6			 
18c6 3e 00			ld a,0 
18c8 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
18cb			 
18cb 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
18ce 32 e5 e5			ld (os_cur_ptr+1),a	 
18d1			 
18d1 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
18d4 32 c7 e5			ld (os_word_scratch+1),a	 
18d7				 
18d7			 
18d7				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18d7 21 e8 e5			ld hl, os_cli_cmd 
18da			 
18da 3e 00			ld a, 0		 ; init cli input 
18dc 77				ld (hl), a 
18dd 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
18df			cli: 
18df				; show cli prompt 
18df				;push af 
18df				;ld a, 0 
18df				;ld de, prompt 
18df				;call str_at_display 
18df			 
18df				;call update_display 
18df				;pop af 
18df				;inc a 
18df				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18df 0e 00			ld c, 0 
18e1 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18e3 1e 28			ld e, 40 
18e5			 
18e5 21 e8 e5			ld hl, os_cli_cmd 
18e8			 
18e8				STACKFRAME OFF $fefe $9f9f 
18e8				if DEBUG_STACK_IMB 
18e8					if OFF 
18e8						exx 
18e8						ld de, $fefe 
18e8						ld a, d 
18e8						ld hl, curframe 
18e8						call hexout 
18e8						ld a, e 
18e8						ld hl, curframe+2 
18e8						call hexout 
18e8						ld hl, $fefe 
18e8						push hl 
18e8						ld hl, $9f9f 
18e8						push hl 
18e8						exx 
18e8					endif 
18e8				endif 
18e8			endm 
# End of macro STACKFRAME
18e8			 
18e8 cd 13 0e			call input_str 
18eb			 
18eb				STACKFRAMECHK OFF $fefe $9f9f 
18eb				if DEBUG_STACK_IMB 
18eb					if OFF 
18eb						exx 
18eb						ld hl, $9f9f 
18eb						pop de   ; $9f9f 
18eb						call cmp16 
18eb						jr nz, .spnosame 
18eb						ld hl, $fefe 
18eb						pop de   ; $fefe 
18eb						call cmp16 
18eb						jr z, .spfrsame 
18eb						.spnosame: call showsperror 
18eb						.spfrsame: nop 
18eb						exx 
18eb					endif 
18eb				endif 
18eb			endm 
# End of macro STACKFRAMECHK
18eb			 
18eb				; copy input to last command 
18eb			 
18eb 21 e8 e5			ld hl, os_cli_cmd 
18ee 11 e7 e6			ld de, os_last_cmd 
18f1 01 ff 00			ld bc, 255 
18f4 ed b0			ldir 
18f6			 
18f6				; wipe current buffer 
18f6			 
18f6			;	ld a, 0 
18f6			;	ld hl, os_cli_cmd 
18f6			;	ld de, os_cli_cmd+1 
18f6			;	ld bc, 254 
18f6			;	ldir 
18f6				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18f6			;	call strcpy 
18f6			;	ld a, 0 
18f6			;	ld (hl), a 
18f6			;	inc hl 
18f6			;	ld (hl), a 
18f6			;	inc hl 
18f6			;	ld (hl), a 
18f6			 
18f6				; switch frame buffer to program  
18f6			 
18f6 21 10 ed				ld hl, display_fb1 
18f9 22 cc eb				ld (display_fb_active), hl 
18fc			 
18fc			;	nop 
18fc				STACKFRAME ON $fbfe $8f9f 
18fc				if DEBUG_STACK_IMB 
18fc					if ON 
18fc						exx 
18fc						ld de, $fbfe 
18fc						ld a, d 
18fc						ld hl, curframe 
18fc						call hexout 
18fc						ld a, e 
18fc						ld hl, curframe+2 
18fc						call hexout 
18fc						ld hl, $fbfe 
18fc						push hl 
18fc						ld hl, $8f9f 
18fc						push hl 
18fc						exx 
18fc					endif 
18fc				endif 
18fc			endm 
# End of macro STACKFRAME
18fc				; first time into the parser so pass over the current scratch pad 
18fc 21 e8 e5			ld hl,os_cli_cmd 
18ff				; tokenise the entered statement(s) in HL 
18ff cd 41 20			call forthparse 
1902			        ; exec forth statements in top of return stack 
1902 cd 81 20			call forthexec 
1905				;call forthexec_cleanup 
1905			;	call parsenext 
1905			 
1905				STACKFRAMECHK ON $fbfe $8f9f 
1905				if DEBUG_STACK_IMB 
1905					if ON 
1905						exx 
1905						ld hl, $8f9f 
1905						pop de   ; $8f9f 
1905						call cmp16 
1905						jr nz, .spnosame 
1905						ld hl, $fbfe 
1905						pop de   ; $fbfe 
1905						call cmp16 
1905						jr z, .spfrsame 
1905						.spnosame: call showsperror 
1905						.spfrsame: nop 
1905						exx 
1905					endif 
1905				endif 
1905			endm 
# End of macro STACKFRAMECHK
1905				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1905			 
1905 3e 78			ld a, display_row_4 
1907 11 38 19			ld de, endprog 
190a			 
190a cd dc 0b			call update_display		 
190d			 
190d cd be 1b			call next_page_prompt 
1910			 
1910				; switch frame buffer to cli 
1910			 
1910 21 b1 ed				ld hl, display_fb0 
1913 22 cc eb				ld (display_fb_active), hl 
1916			 
1916			 
1916 cd b9 0b		        call clear_display 
1919 cd dc 0b			call update_display		 
191c			 
191c 21 e8 e5			ld hl, os_cli_cmd 
191f			 
191f 3e 00			ld a, 0		 ; init cli input 
1921 77				ld (hl), a 
1922			 
1922				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1922			 
1922				; now on last line 
1922			 
1922				; TODO scroll screen up 
1922			 
1922				; TODO instead just clear screen and place at top of screen 
1922			 
1922			;	ld a, 0 
1922			;	ld (f_cursor_ptr),a 
1922			 
1922				;call clear_display 
1922				;call update_display 
1922			 
1922				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1922 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1924 c3 df 18			jp cli 
1927			 
1927 .. 00		freeram: db "Free bytes: ",0 
1934 ..			asc: db "1A2F" 
1938 .. 00		endprog: db "End prog...",0 
1944			 
1944			testenter2:   
1944 21 f3 e2			ld hl,scratch+50 
1947 22 e4 e5			ld (os_cur_ptr),hl 
194a c3 df 18			jp cli 
194d			 
194d			testenter:  
194d			 
194d 21 34 19			ld hl,asc 
1950			;	ld a,(hl) 
1950			;	call nibble2val 
1950 cd 3d 11			call get_byte 
1953			 
1953			 
1953			;	ld a,(hl) 
1953			;	call atohex 
1953			 
1953			;	call fourehexhl 
1953 32 f3 e2			ld (scratch+50),a 
1956			 
1956			 
1956			 
1956 21 36 19			ld hl,asc+2 
1959			;	ld a, (hl) 
1959			;	call nibble2val 
1959 cd 3d 11			call get_byte 
195c			 
195c			;	call fourehexhl 
195c 32 f5 e2			ld (scratch+52),a 
195f				 
195f 21 f3 e2			ld hl,scratch+50 
1962 22 e4 e5			ld (os_cur_ptr),hl 
1965 c3 df 18			jp cli 
1968			 
1968			enter:	 
1968 3a c5 e2			ld a,(scratch+4) 
196b fe 00			cp 0 
196d 28 0c			jr z, .entercont 
196f				; no, not a null term line so has an address to work out.... 
196f			 
196f 21 c3 e2			ld hl,scratch+2 
1972 cd 9d 11			call get_word_hl 
1975			 
1975 22 e4 e5			ld (os_cur_ptr),hl	 
1978 c3 df 18			jp cli 
197b			 
197b			 
197b			.entercont:  
197b			 
197b 21 c3 e2			ld hl, scratch+2 
197e cd 3d 11			call get_byte 
1981			 
1981 2a e4 e5		   	ld hl,(os_cur_ptr) 
1984 77					ld (hl),a 
1985 23					inc hl 
1986 22 e4 e5				ld (os_cur_ptr),hl 
1989				 
1989			; get byte  
1989			 
1989			 
1989 c3 df 18			jp cli 
198c			 
198c			 
198c			; basic monitor support 
198c			 
198c			monitor: 
198c				;  
198c cd b9 0b			call clear_display 
198f 3e 00			ld a, 0 
1991 11 e0 19			ld de, .monprompt 
1994 cd cc 0b			call str_at_display 
1997 cd dc 0b			call update_display 
199a			 
199a				; get a monitor command 
199a			 
199a 0e 00			ld c, 0     ; entry at top left 
199c 16 64			ld d, 100   ; max buffer size 
199e 1e 0f			ld e, 15    ; input scroll area 
19a0 3e 00			ld a, 0     ; init string 
19a2 21 bf e4			ld hl, os_input 
19a5 77				ld (hl), a 
19a6 23				inc hl 
19a7 77				ld (hl), a 
19a8 21 bf e4			ld hl, os_input 
19ab 3e 01			ld a, 1     ; init string 
19ad cd 13 0e			call input_str 
19b0			 
19b0 cd b9 0b		        call clear_display 
19b3 cd dc 0b			call update_display		 
19b6			 
19b6 3a bf e4			ld a, (os_input) 
19b9 cd 3b 12			call toUpper 
19bc fe 48		        cp 'H' 
19be ca 45 1a		        jp z, .monhelp 
19c1 fe 44			cp 'D'		; dump 
19c3 ca 78 1a			jp z, .mondump	 
19c6 fe 43			cp 'C'		; dump 
19c8 ca 92 1a			jp z, .moncdump	 
19cb fe 4d			cp 'M'		; dump 
19cd ca e2 19			jp z, .moneditstart 
19d0 fe 55			cp 'U'		; dump 
19d2 ca ee 19			jp z, .monedit	 
19d5 fe 47			cp 'G'		; dump 
19d7 ca 6e 1a			jp z, .monjump 
19da fe 51			cp 'Q'		; dump 
19dc c8				ret z	 
19dd			 
19dd			 
19dd				; TODO "S" to access symbol by name and not need the address 
19dd				; TODO "F" to find a string in memory 
19dd			 
19dd c3 8c 19			jp monitor 
19e0			 
19e0 .. 00		.monprompt: db ">", 0 
19e2			 
19e2			.moneditstart: 
19e2				; get starting address 
19e2			 
19e2 21 c1 e4			ld hl,os_input+2 
19e5 cd 9d 11			call get_word_hl 
19e8			 
19e8 22 e4 e5			ld (os_cur_ptr),hl	 
19eb			 
19eb c3 8c 19			jp monitor 
19ee			 
19ee			.monedit: 
19ee				; get byte to load 
19ee			 
19ee 21 c1 e4			ld hl,os_input+2 
19f1 cd 3d 11			call get_byte 
19f4			 
19f4				; get address to update 
19f4 2a e4 e5			ld hl, (os_cur_ptr) 
19f7			 
19f7				; update byte 
19f7			 
19f7 77				ld (hl), a 
19f8			 
19f8				; move to next address and save it 
19f8			 
19f8 23				inc hl 
19f9 22 e4 e5			ld (os_cur_ptr),hl	 
19fc			 
19fc c3 8c 19			jp monitor 
19ff			 
19ff			 
19ff .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1a13 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1a2f .. 00		.monhelptext3:  db "G-Call address",0 
1a3e .. 00		.monhelptext4:  db "Q-Quit",0 
1a45			        
1a45			.monhelp: 
1a45 3e 00			ld a, display_row_1 
1a47 11 ff 19		        ld de, .monhelptext1 
1a4a			 
1a4a cd cc 0b			call str_at_display 
1a4d 3e 28			ld a, display_row_2 
1a4f 11 13 1a		        ld de, .monhelptext2 
1a52					 
1a52 cd cc 0b			call str_at_display 
1a55 3e 50			ld a, display_row_3 
1a57 11 2f 1a		        ld de, .monhelptext3 
1a5a					 
1a5a cd cc 0b			call str_at_display 
1a5d 3e 78			ld a, display_row_4 
1a5f 11 3e 1a		        ld de, .monhelptext4 
1a62 cd cc 0b			call str_at_display 
1a65			 
1a65 cd dc 0b			call update_display		 
1a68			 
1a68 cd be 1b			call next_page_prompt 
1a6b c3 8c 19			jp monitor 
1a6e			 
1a6e			.monjump:    
1a6e 21 c1 e4			ld hl,os_input+2 
1a71 cd 9d 11			call get_word_hl 
1a74			 
1a74 e9				jp (hl) 
1a75 c3 8c 19			jp monitor 
1a78			 
1a78			.mondump:    
1a78 21 c1 e4			ld hl,os_input+2 
1a7b cd 9d 11			call get_word_hl 
1a7e			 
1a7e 22 e4 e5			ld (os_cur_ptr),hl	 
1a81 cd c6 1a			call dumpcont 
1a84 3e 78			ld a, display_row_4 
1a86 11 38 19			ld de, endprog 
1a89			 
1a89 cd dc 0b			call update_display		 
1a8c			 
1a8c cd be 1b			call next_page_prompt 
1a8f c3 8c 19			jp monitor 
1a92			.moncdump: 
1a92 cd c6 1a			call dumpcont 
1a95 3e 78			ld a, display_row_4 
1a97 11 38 19			ld de, endprog 
1a9a			 
1a9a cd dc 0b			call update_display		 
1a9d			 
1a9d cd be 1b			call next_page_prompt 
1aa0 c3 8c 19			jp monitor 
1aa3			 
1aa3			 
1aa3			; TODO symbol access  
1aa3			 
1aa3			.symbols:     ;; A list of symbols that can be called up  
1aa3 b1 ed			dw display_fb0 
1aa5 .. 00			db "fb0",0  
1aa9 7a ea		     	dw store_page 
1aab .. 00			db "store_page",0 
1ab6			 
1ab6			 
1ab6			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1ab6			 
1ab6 3a c2 e2			ld a,(scratch+1) 
1ab9 fe 00			cp 0 
1abb 28 09			jr z, dumpcont 
1abd			 
1abd				; no, not a null term line so has an address to work out.... 
1abd			 
1abd 21 c3 e2			ld hl,scratch+2 
1ac0 cd 9d 11			call get_word_hl 
1ac3			 
1ac3 22 e4 e5			ld (os_cur_ptr),hl	 
1ac6			 
1ac6			 
1ac6			 
1ac6			dumpcont: 
1ac6			 
1ac6				; dump bytes at ptr 
1ac6			 
1ac6			 
1ac6 3e 00			ld a, display_row_1 
1ac8 2a cc eb			ld hl, (display_fb_active) 
1acb cd e6 0d			call addatohl 
1ace cd f6 1a			call .dumpbyterow 
1ad1			 
1ad1 3e 28			ld a, display_row_2 
1ad3 2a cc eb			ld hl, (display_fb_active) 
1ad6 cd e6 0d			call addatohl 
1ad9 cd f6 1a			call .dumpbyterow 
1adc			 
1adc			 
1adc 3e 50			ld a, display_row_3 
1ade 2a cc eb			ld hl, (display_fb_active) 
1ae1 cd e6 0d			call addatohl 
1ae4 cd f6 1a			call .dumpbyterow 
1ae7			 
1ae7 3e 78			ld a, display_row_4 
1ae9 2a cc eb			ld hl, (display_fb_active) 
1aec cd e6 0d			call addatohl 
1aef cd f6 1a			call .dumpbyterow 
1af2			 
1af2 cd dc 0b			call update_display 
1af5			;		jp cli 
1af5 c9				ret 
1af6			 
1af6			.dumpbyterow: 
1af6			 
1af6				;push af 
1af6			 
1af6 e5				push hl 
1af7			 
1af7				; calc where to poke the ascii 
1af7			if display_cols == 20 
1af7				ld a, 16 
1af7			else 
1af7 3e 1f			ld a, 31 
1af9			endif 
1af9			 
1af9 cd e6 0d			call addatohl 
1afc 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
1aff			 
1aff			 
1aff			; display decoding address 
1aff 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b02			 
1b02 7c				ld a,h 
1b03 e1				pop hl 
1b04 e5				push hl 
1b05			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1b05 cd e7 10			call hexout 
1b08 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b0b			 
1b0b 7d				ld a,l 
1b0c e1				pop hl 
1b0d 23				inc hl 
1b0e 23				inc hl 
1b0f e5				push hl 
1b10			;	ld hl, os_word_scratch+2 
1b10 cd e7 10			call hexout 
1b13 e1				pop hl 
1b14 23				inc hl 
1b15 23				inc hl 
1b16				;ld hl, os_word_scratch+4 
1b16 3e 3a			ld a, ':' 
1b18 77				ld (hl),a 
1b19 23				inc hl 
1b1a				;ld a, 0 
1b1a				;ld (hl),a 
1b1a				;ld de, os_word_scratch 
1b1a				;pop af 
1b1a				;push af 
1b1a			;		ld a, display_row_2 
1b1a			;		call str_at_display 
1b1a			;		call update_display 
1b1a			 
1b1a			 
1b1a			;pop af 
1b1a			;	add 5 
1b1a			 
1b1a			if display_cols == 20 
1b1a				ld b, 4 
1b1a			else 
1b1a 06 08			ld b, 8 
1b1c			endif	 
1b1c			 
1b1c			.dumpbyte: 
1b1c c5				push bc 
1b1d e5				push hl 
1b1e			 
1b1e			 
1b1e 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b21 7e					ld a,(hl) 
1b22			 
1b22					; poke the ascii to display 
1b22 2a c6 e5				ld hl,(os_word_scratch) 
1b25 77					ld (hl),a 
1b26 23					inc hl 
1b27 22 c6 e5				ld (os_word_scratch),hl 
1b2a			 
1b2a					 
1b2a			 
1b2a			 
1b2a e1					pop hl 
1b2b e5					push hl 
1b2c			 
1b2c cd e7 10				call hexout 
1b2f			 
1b2f					 
1b2f 2a e4 e5		   	ld hl,(os_cur_ptr) 
1b32 23				inc hl 
1b33 22 e4 e5		   	ld (os_cur_ptr),hl 
1b36			 
1b36 e1					pop hl 
1b37 23					inc hl 
1b38 23					inc hl 
1b39 23					inc hl 
1b3a			 
1b3a			 
1b3a			 
1b3a					;ld a,0 
1b3a					;ld (os_word_scratch+2),a 
1b3a					;pop af 
1b3a					;push af 
1b3a			 
1b3a					;ld de, os_word_scratch 
1b3a					;call str_at_display 
1b3a			;		call update_display 
1b3a			;		pop af 
1b3a c1					pop bc 
1b3b c6 03				add 3 
1b3d 10 dd			djnz .dumpbyte 
1b3f			 
1b3f				 
1b3f			 
1b3f c9				ret 
1b40			 
1b40			jump:	 
1b40			 
1b40 21 c3 e2			ld hl,scratch+2 
1b43 cd 9d 11			call get_word_hl 
1b46				;ld hl,(scratch+2) 
1b46				;call fourehexhl 
1b46			 
1b46 22 e4 e5			ld (os_cur_ptr),hl	 
1b49			 
1b49 e9				jp (hl) 
1b4a			 
1b4a			 
1b4a			 
1b4a			; TODO implement a basic monitor mode to start with 
1b4a			 
1b4a			 
1b4a			 
1b4a			 
1b4a			 
1b4a			 
1b4a			 
1b4a			 
1b4a			 
1b4a			; testing and demo code during development 
1b4a			 
1b4a			 
1b4a .. 00		str1: db "Enter some text...",0 
1b5d .. 00		clear: db "                    ",0 
1b72			 
1b72			demo: 
1b72			 
1b72			 
1b72			 
1b72			;	call update_display 
1b72			 
1b72				; init scratch input area for testing 
1b72 21 c1 e2			ld hl, scratch	 
1b75 3e 00			ld a,0 
1b77 77				ld (hl),a 
1b78			 
1b78			 
1b78 3e 28		            LD   A, display_row_2 
1b7a			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b7a 11 4a 1b		            LD   DE, str1 
1b7d cd cc 0b			call str_at_display 
1b80			 
1b80			;            CALL fLCD_Str       ;Display string pointed to by DE 
1b80			cloop:	 
1b80 3e 50		            LD   A, display_row_3 
1b82			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b82 11 5d 1b		            LD   DE, clear 
1b85			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1b85 cd cc 0b				call str_at_display 
1b88 3e 78			ld a, display_row_4 
1b8a 11 ba 1b			ld de, prompt 
1b8d			 
1b8d cd cc 0b				call str_at_display 
1b90 cd dc 0b			call update_display 
1b93			 
1b93 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1b95 16 0a			ld d, 10 
1b97 21 c1 e2			ld hl, scratch	 
1b9a cd 13 0e			call input_str 
1b9d			 
1b9d			;	call clear_display 
1b9d			;'	call update_display 
1b9d			 
1b9d 3e 00		            LD   A, display_row_1 
1b9f			;            CALL fLCD_Pos       ;Position cursor to location in A 
1b9f 11 5d 1b		            LD   DE, clear 
1ba2 cd cc 0b				call str_at_display 
1ba5			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ba5 3e 00		            LD   A, display_row_1 
1ba7			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ba7 11 c1 e2		            LD   DE, scratch 
1baa			;            CALL fLCD_Str       ;Display string pointed to by DE 
1baa cd cc 0b				call str_at_display 
1bad cd dc 0b			call update_display 
1bb0			 
1bb0 3e 00				ld a,0 
1bb2 21 c1 e2			ld hl, scratch 
1bb5 77				ld (hl),a 
1bb6			 
1bb6 00				nop 
1bb7 c3 80 1b			jp cloop 
1bba			 
1bba			 
1bba			 
1bba			; OS Prompt 
1bba			 
1bba .. 00		prompt: db ">",0 
1bbc .. 00		endprg: db "?",0 
1bbe			 
1bbe			 
1bbe			; handy next page prompt 
1bbe			next_page_prompt: 
1bbe e5				push hl 
1bbf d5				push de 
1bc0 f5				push af 
1bc1 c5				push bc 
1bc2			 
1bc2 3e 9f			ld a,display_row_4 + display_cols - 1 
1bc4 11 bc 1b		        ld de, endprg 
1bc7 cd cc 0b			call str_at_display 
1bca cd dc 0b			call update_display 
1bcd cd b3 65			call cin_wait 
1bd0 c1				pop bc 
1bd1 f1				pop af 
1bd2 d1				pop de 
1bd3 e1				pop hl 
1bd4			 
1bd4			 
1bd4 c9				ret 
1bd5			 
1bd5			 
1bd5			; forth parser 
1bd5			 
1bd5			; My forth kernel 
1bd5			include "forth_kernel.asm" 
1bd5			; 
1bd5			; kernel to the forth OS 
1bd5			 
1bd5			DS_TYPE_STR: equ 1     ; string type 
1bd5			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1bd5			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1bd5			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1bd5			 
1bd5			FORTH_PARSEV1: equ 0 
1bd5			FORTH_PARSEV2: equ 0 
1bd5			FORTH_PARSEV3: equ 0 
1bd5			FORTH_PARSEV4: equ 0 
1bd5			FORTH_PARSEV5: equ 1 
1bd5			 
1bd5			;if FORTH_PARSEV5 
1bd5			;	FORTH_END_BUFFER: equ 0 
1bd5			;else 
1bd5			FORTH_END_BUFFER: equ 127 
1bd5			;endif 
1bd5			 
1bd5			FORTH_TRUE: equ 1 
1bd5			FORTH_FALSE: equ 0 
1bd5			 
1bd5			if FORTH_PARSEV4 
1bd5			include "forth_stackops.asm" 
1bd5			endif 
1bd5			 
1bd5			if FORTH_PARSEV5 
1bd5			include "forth_stackopsv5.asm" 
1bd5			 
1bd5			; Stack operations for v5 parser on wards 
1bd5			; * DATA stack 
1bd5			; * LOOP stack 
1bd5			; * RETURN stack 
1bd5			 
1bd5			 
1bd5			 
1bd5			FORTH_CHK_DSP_UNDER: macro 
1bd5				push hl 
1bd5				push de 
1bd5				ld hl,(cli_data_sp) 
1bd5				ld de, cli_data_stack 
1bd5				call cmp16 
1bd5				jp c, fault_dsp_under 
1bd5				pop de 
1bd5				pop hl 
1bd5				endm 
1bd5			 
1bd5			 
1bd5			FORTH_CHK_RSP_UNDER: macro 
1bd5				push hl 
1bd5				push de 
1bd5				ld hl,(cli_ret_sp) 
1bd5				ld de, cli_ret_stack 
1bd5				call cmp16 
1bd5				jp c, fault_rsp_under 
1bd5				pop de 
1bd5				pop hl 
1bd5				endm 
1bd5			 
1bd5			FORTH_CHK_LOOP_UNDER: macro 
1bd5				push hl 
1bd5				push de 
1bd5				ld hl,(cli_loop_sp) 
1bd5				ld de, cli_loop_stack 
1bd5				call cmp16 
1bd5				jp c, fault_loop_under 
1bd5				pop de 
1bd5				pop hl 
1bd5				endm 
1bd5			 
1bd5			FORTH_ERR_TOS_NOTSTR: macro 
1bd5				; TOSO might need more for checks when used 
1bd5				push af 
1bd5				ld a,(hl) 
1bd5				cp DS_TYPE_STR 
1bd5				jp nz, type_faultn   
1bd5				pop af 
1bd5				endm 
1bd5			 
1bd5			FORTH_ERR_TOS_NOTNUM: macro 
1bd5				push af 
1bd5				ld a,(hl) 
1bd5				cp DS_TYPE_INUM 
1bd5				jp nz, type_faultn   
1bd5				pop af 
1bd5				endm 
1bd5			 
1bd5			 
1bd5			; increase data stack pointer and save hl to it 
1bd5				 
1bd5			FORTH_DSP_NEXT: macro 
1bd5				call macro_forth_dsp_next 
1bd5				endm 
1bd5			 
1bd5			 
1bd5			macro_forth_dsp_next: 
1bd5				if DEBUG_FORTH_STACK_GUARD 
1bd5 cd e2 61				call check_stacks 
1bd8				endif 
1bd8 e5				push hl 
1bd9 d5				push de 
1bda eb				ex de,hl 
1bdb 2a ee e9			ld hl,(cli_data_sp) 
1bde 23				inc hl 
1bdf 23				inc hl 
1be0			 
1be0			; PARSEV5 
1be0 23				inc hl 
1be1 22 ee e9			ld (cli_data_sp),hl 
1be4 73				ld (hl), e 
1be5 23				inc hl 
1be6 72				ld (hl), d 
1be7 d1				pop de 
1be8 e1				pop hl 
1be9				if DEBUG_FORTH_STACK_GUARD 
1be9 cd e2 61				call check_stacks 
1bec				endif 
1bec c9				ret 
1bed			 
1bed			 
1bed			; increase ret stack pointer and save hl to it 
1bed				 
1bed			FORTH_RSP_NEXT: macro 
1bed				call macro_forth_rsp_next 
1bed				endm 
1bed			 
1bed			macro_forth_rsp_next: 
1bed				if DEBUG_FORTH_STACK_GUARD 
1bed cd e2 61				call check_stacks 
1bf0				endif 
1bf0 e5				push hl 
1bf1 d5				push de 
1bf2 eb				ex de,hl 
1bf3 2a f2 e9			ld hl,(cli_ret_sp) 
1bf6 23				inc hl 
1bf7 23				inc hl 
1bf8 22 f2 e9			ld (cli_ret_sp),hl 
1bfb 73				ld (hl), e 
1bfc 23				inc hl 
1bfd 72				ld (hl), d 
1bfe d1				pop de 
1bff e1				pop hl 
1c00				if DEBUG_FORTH_STACK_GUARD 
1c00 cd e2 61				call check_stacks 
1c03				endif 
1c03 c9				ret 
1c04			 
1c04			; get current ret stack pointer and save to hl  
1c04				 
1c04			FORTH_RSP_TOS: macro 
1c04				call macro_forth_rsp_tos 
1c04				endm 
1c04			 
1c04			macro_forth_rsp_tos: 
1c04				;push de 
1c04 2a f2 e9			ld hl,(cli_ret_sp) 
1c07 cd 3f 1c			call loadhlptrtohl 
1c0a				;ld e, (hl) 
1c0a				;inc hl 
1c0a				;ld d, (hl) 
1c0a				;ex de, hl 
1c0a					if DEBUG_FORTH_WORDS 
1c0a			;			DMARK "RST" 
1c0a						CALLMONITOR 
1c0a cd 6f ee			call debug_vector  
1c0d				endm  
# End of macro CALLMONITOR
1c0d					endif 
1c0d				;pop de 
1c0d c9				ret 
1c0e			 
1c0e			; pop ret stack pointer 
1c0e				 
1c0e			FORTH_RSP_POP: macro 
1c0e				call macro_forth_rsp_pop 
1c0e				endm 
1c0e			 
1c0e			 
1c0e			macro_forth_rsp_pop: 
1c0e				if DEBUG_FORTH_STACK_GUARD 
1c0e			;		DMARK "RPP" 
1c0e cd e2 61				call check_stacks 
1c11					FORTH_CHK_RSP_UNDER 
1c11 e5				push hl 
1c12 d5				push de 
1c13 2a f2 e9			ld hl,(cli_ret_sp) 
1c16 11 ac e9			ld de, cli_ret_stack 
1c19 cd 04 0e			call cmp16 
1c1c da f6 62			jp c, fault_rsp_under 
1c1f d1				pop de 
1c20 e1				pop hl 
1c21				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c21				endif 
1c21 e5				push hl 
1c22 2a f2 e9			ld hl,(cli_ret_sp) 
1c25			 
1c25			 
1c25				if FORTH_ENABLE_FREE 
1c25			 
1c25					; get pointer 
1c25			 
1c25					push de 
1c25					push hl 
1c25			 
1c25					ld e, (hl) 
1c25					inc hl 
1c25					ld d, (hl) 
1c25			 
1c25					ex de, hl 
1c25					call free 
1c25			 
1c25					pop hl 
1c25					pop de 
1c25			 
1c25			 
1c25				endif 
1c25			 
1c25			 
1c25 2b				dec hl 
1c26 2b				dec hl 
1c27 22 f2 e9			ld (cli_ret_sp), hl 
1c2a				; do stack underflow checks 
1c2a e1				pop hl 
1c2b				if DEBUG_FORTH_STACK_GUARD 
1c2b cd e2 61				call check_stacks 
1c2e					FORTH_CHK_RSP_UNDER 
1c2e e5				push hl 
1c2f d5				push de 
1c30 2a f2 e9			ld hl,(cli_ret_sp) 
1c33 11 ac e9			ld de, cli_ret_stack 
1c36 cd 04 0e			call cmp16 
1c39 da f6 62			jp c, fault_rsp_under 
1c3c d1				pop de 
1c3d e1				pop hl 
1c3e				endm 
# End of macro FORTH_CHK_RSP_UNDER
1c3e				endif 
1c3e c9				ret 
1c3f			 
1c3f			 
1c3f			 
1c3f			; routine to load word pointed to by hl into hl 
1c3f			 
1c3f			loadhlptrtohl: 
1c3f			 
1c3f d5				push de 
1c40 5e				ld e, (hl) 
1c41 23				inc hl 
1c42 56				ld d, (hl) 
1c43 eb				ex de, hl 
1c44 d1				pop de 
1c45			 
1c45 c9				ret 
1c46			 
1c46			 
1c46			 
1c46			 
1c46			 
1c46			; push a number held in HL onto the data stack 
1c46			; entry point for pushing a value when already in hl used in function above 
1c46			 
1c46			forth_push_numhl: 
1c46			 
1c46 e5				push hl    ; save value to push 
1c47			 
1c47			if DEBUG_FORTH_PUSH 
1c47				; see if disabled 
1c47			 
1c47			 
1c47 f5				push af 
1c48 3a 6f ee			ld a,(debug_vector) 
1c4b fe c9			cp $c9   ; ret 
1c4d			;	ld a, (os_view_disable) 
1c4d			;	cp '*' 
1c4d 28 34			jr z, .pskip2 
1c4f e5				push hl 
1c50 e5			push hl 
1c51 cd b9 0b			call clear_display 
1c54 e1			pop hl 
1c55 7c				ld a,h 
1c56 21 c6 e5			ld hl, os_word_scratch 
1c59 cd e7 10			call hexout 
1c5c e1				pop hl 
1c5d 7d				ld a,l 
1c5e 21 c8 e5			ld hl, os_word_scratch+2 
1c61 cd e7 10			call hexout 
1c64			 
1c64 21 ca e5			ld hl, os_word_scratch+4 
1c67 3e 00			ld a,0 
1c69 77				ld (hl),a 
1c6a 11 c6 e5			ld de,os_word_scratch 
1c6d 3e 28				ld a, display_row_2 
1c6f cd cc 0b				call str_at_display 
1c72 11 1e 4d			ld de, .push_num 
1c75 3e 00			ld a, display_row_1 
1c77			 
1c77 cd cc 0b				call str_at_display 
1c7a			 
1c7a			 
1c7a cd dc 0b			call update_display 
1c7d cd f1 0a			call delay1s 
1c80 cd f1 0a			call delay1s 
1c83			.pskip2:  
1c83			 
1c83 f1				pop af 
1c84			endif	 
1c84			 
1c84			 
1c84				FORTH_DSP_NEXT 
1c84 cd d5 1b			call macro_forth_dsp_next 
1c87				endm 
# End of macro FORTH_DSP_NEXT
1c87			 
1c87 2a ee e9			ld hl, (cli_data_sp) 
1c8a			 
1c8a				; save item type 
1c8a 3e 02			ld a,  DS_TYPE_INUM 
1c8c 77				ld (hl), a 
1c8d 23				inc hl 
1c8e			 
1c8e				; get word off stack 
1c8e d1				pop de 
1c8f 7b				ld a,e 
1c90 77				ld (hl), a 
1c91 23				inc hl 
1c92 7a				ld a,d 
1c93 77				ld (hl), a 
1c94			 
1c94			if DEBUG_FORTH_PUSH 
1c94 2b				dec hl 
1c95 2b				dec hl 
1c96 2b				dec hl 
1c97						DMARK "PH5" 
1c97 f5				push af  
1c98 3a ac 1c			ld a, (.dmark)  
1c9b 32 6b ee			ld (debug_mark),a  
1c9e 3a ad 1c			ld a, (.dmark+1)  
1ca1 32 6c ee			ld (debug_mark+1),a  
1ca4 3a ae 1c			ld a, (.dmark+2)  
1ca7 32 6d ee			ld (debug_mark+2),a  
1caa 18 03			jr .pastdmark  
1cac ..			.dmark: db "PH5"  
1caf f1			.pastdmark: pop af  
1cb0			endm  
# End of macro DMARK
1cb0				CALLMONITOR 
1cb0 cd 6f ee			call debug_vector  
1cb3				endm  
# End of macro CALLMONITOR
1cb3			endif	 
1cb3			 
1cb3 c9				ret 
1cb4			 
1cb4			 
1cb4			; Push a string to stack pointed to by hl 
1cb4			 
1cb4			forth_push_str: 
1cb4			 
1cb4			if DEBUG_FORTH_PUSH 
1cb4						DMARK "PSQ" 
1cb4 f5				push af  
1cb5 3a c9 1c			ld a, (.dmark)  
1cb8 32 6b ee			ld (debug_mark),a  
1cbb 3a ca 1c			ld a, (.dmark+1)  
1cbe 32 6c ee			ld (debug_mark+1),a  
1cc1 3a cb 1c			ld a, (.dmark+2)  
1cc4 32 6d ee			ld (debug_mark+2),a  
1cc7 18 03			jr .pastdmark  
1cc9 ..			.dmark: db "PSQ"  
1ccc f1			.pastdmark: pop af  
1ccd			endm  
# End of macro DMARK
1ccd				CALLMONITOR 
1ccd cd 6f ee			call debug_vector  
1cd0				endm  
# End of macro CALLMONITOR
1cd0			endif	 
1cd0			    
1cd0 e5				push hl 
1cd1 e5				push hl 
1cd2			 
1cd2			;	ld a, 0   ; find end of string 
1cd2 cd 44 12			call strlenz 
1cd5			if DEBUG_FORTH_PUSH 
1cd5						DMARK "PQ2" 
1cd5 f5				push af  
1cd6 3a ea 1c			ld a, (.dmark)  
1cd9 32 6b ee			ld (debug_mark),a  
1cdc 3a eb 1c			ld a, (.dmark+1)  
1cdf 32 6c ee			ld (debug_mark+1),a  
1ce2 3a ec 1c			ld a, (.dmark+2)  
1ce5 32 6d ee			ld (debug_mark+2),a  
1ce8 18 03			jr .pastdmark  
1cea ..			.dmark: db "PQ2"  
1ced f1			.pastdmark: pop af  
1cee			endm  
# End of macro DMARK
1cee				CALLMONITOR 
1cee cd 6f ee			call debug_vector  
1cf1				endm  
# End of macro CALLMONITOR
1cf1			endif	 
1cf1 eb				ex de, hl 
1cf2 e1				pop hl   ; get ptr to start of string 
1cf3			if DEBUG_FORTH_PUSH 
1cf3						DMARK "PQ3" 
1cf3 f5				push af  
1cf4 3a 08 1d			ld a, (.dmark)  
1cf7 32 6b ee			ld (debug_mark),a  
1cfa 3a 09 1d			ld a, (.dmark+1)  
1cfd 32 6c ee			ld (debug_mark+1),a  
1d00 3a 0a 1d			ld a, (.dmark+2)  
1d03 32 6d ee			ld (debug_mark+2),a  
1d06 18 03			jr .pastdmark  
1d08 ..			.dmark: db "PQ3"  
1d0b f1			.pastdmark: pop af  
1d0c			endm  
# End of macro DMARK
1d0c				CALLMONITOR 
1d0c cd 6f ee			call debug_vector  
1d0f				endm  
# End of macro CALLMONITOR
1d0f			endif	 
1d0f 19				add hl,de 
1d10			if DEBUG_FORTH_PUSH 
1d10						DMARK "PQE" 
1d10 f5				push af  
1d11 3a 25 1d			ld a, (.dmark)  
1d14 32 6b ee			ld (debug_mark),a  
1d17 3a 26 1d			ld a, (.dmark+1)  
1d1a 32 6c ee			ld (debug_mark+1),a  
1d1d 3a 27 1d			ld a, (.dmark+2)  
1d20 32 6d ee			ld (debug_mark+2),a  
1d23 18 03			jr .pastdmark  
1d25 ..			.dmark: db "PQE"  
1d28 f1			.pastdmark: pop af  
1d29			endm  
# End of macro DMARK
1d29				CALLMONITOR 
1d29 cd 6f ee			call debug_vector  
1d2c				endm  
# End of macro CALLMONITOR
1d2c			endif	 
1d2c			 
1d2c 2b				dec hl    ; see if there is an optional trailing double quote 
1d2d 7e				ld a,(hl) 
1d2e fe 22			cp '"' 
1d30 20 03			jr nz, .strnoq 
1d32 3e 00			ld a, 0      ; get rid of double quote 
1d34 77				ld (hl), a 
1d35 23			.strnoq: inc hl 
1d36			 
1d36 3e 00			ld a, 0 
1d38 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1d39			 
1d39 13				inc de ; add one for the type string 
1d3a 13				inc de ; add one for null term??? 
1d3b			 
1d3b				; tos is get string pointer again 
1d3b				; de contains space to allocate 
1d3b				 
1d3b d5				push de 
1d3c			 
1d3c eb				ex de, hl 
1d3d			 
1d3d				;push af 
1d3d			 
1d3d			if DEBUG_FORTH_PUSH 
1d3d						DMARK "PHm" 
1d3d f5				push af  
1d3e 3a 52 1d			ld a, (.dmark)  
1d41 32 6b ee			ld (debug_mark),a  
1d44 3a 53 1d			ld a, (.dmark+1)  
1d47 32 6c ee			ld (debug_mark+1),a  
1d4a 3a 54 1d			ld a, (.dmark+2)  
1d4d 32 6d ee			ld (debug_mark+2),a  
1d50 18 03			jr .pastdmark  
1d52 ..			.dmark: db "PHm"  
1d55 f1			.pastdmark: pop af  
1d56			endm  
# End of macro DMARK
1d56				CALLMONITOR 
1d56 cd 6f ee			call debug_vector  
1d59				endm  
# End of macro CALLMONITOR
1d59			endif	 
1d59 cd ad 12			call malloc	; on ret hl now contains allocated memory 
1d5c				if DEBUG_FORTH_MALLOC_GUARD 
1d5c cc 76 4d				call z,malloc_error 
1d5f				endif 
1d5f			 
1d5f				 
1d5f c1				pop bc    ; get length 
1d60 d1				pop de   ;  get string start    
1d61			 
1d61				; hl has destination from malloc 
1d61			 
1d61 eb				ex de, hl    ; prep for ldir 
1d62			 
1d62 d5				push de   ; save malloc area for DSP later 
1d63				;push hl   ; save malloc area for DSP later 
1d63			 
1d63			if DEBUG_FORTH_PUSH 
1d63						DMARK "PHc" 
1d63 f5				push af  
1d64 3a 78 1d			ld a, (.dmark)  
1d67 32 6b ee			ld (debug_mark),a  
1d6a 3a 79 1d			ld a, (.dmark+1)  
1d6d 32 6c ee			ld (debug_mark+1),a  
1d70 3a 7a 1d			ld a, (.dmark+2)  
1d73 32 6d ee			ld (debug_mark+2),a  
1d76 18 03			jr .pastdmark  
1d78 ..			.dmark: db "PHc"  
1d7b f1			.pastdmark: pop af  
1d7c			endm  
# End of macro DMARK
1d7c				CALLMONITOR 
1d7c cd 6f ee			call debug_vector  
1d7f				endm  
# End of macro CALLMONITOR
1d7f			endif	 
1d7f			 
1d7f			 
1d7f ed b0			ldir 
1d81			 
1d81			 
1d81				; push malloc to data stack     macro?????  
1d81			 
1d81				FORTH_DSP_NEXT 
1d81 cd d5 1b			call macro_forth_dsp_next 
1d84				endm 
# End of macro FORTH_DSP_NEXT
1d84			 
1d84				; save value and type 
1d84			 
1d84 2a ee e9			ld hl, (cli_data_sp) 
1d87			 
1d87				; save item type 
1d87 3e 01			ld a,  DS_TYPE_STR 
1d89 77				ld (hl), a 
1d8a 23				inc hl 
1d8b			 
1d8b				; get malloc word off stack 
1d8b d1				pop de 
1d8c 73				ld (hl), e 
1d8d 23				inc hl 
1d8e 72				ld (hl), d 
1d8f			 
1d8f			 
1d8f			 
1d8f			if DEBUG_FORTH_PUSH 
1d8f 2a ee e9			ld hl, (cli_data_sp) 
1d92						DMARK "PHS" 
1d92 f5				push af  
1d93 3a a7 1d			ld a, (.dmark)  
1d96 32 6b ee			ld (debug_mark),a  
1d99 3a a8 1d			ld a, (.dmark+1)  
1d9c 32 6c ee			ld (debug_mark+1),a  
1d9f 3a a9 1d			ld a, (.dmark+2)  
1da2 32 6d ee			ld (debug_mark+2),a  
1da5 18 03			jr .pastdmark  
1da7 ..			.dmark: db "PHS"  
1daa f1			.pastdmark: pop af  
1dab			endm  
# End of macro DMARK
1dab				CALLMONITOR 
1dab cd 6f ee			call debug_vector  
1dae				endm  
# End of macro CALLMONITOR
1dae			;	ex de,hl 
1dae			endif	 
1dae				; in case of spaces, skip the ptr past the copied string 
1dae				;pop af 
1dae				;ld (cli_origptr),hl 
1dae			 
1dae c9				ret 
1daf			 
1daf			 
1daf			 
1daf			; TODO ascii push input onto stack given hl to start of input 
1daf			 
1daf			; identify type 
1daf			; if starts with a " then a string 
1daf			; otherwise it is a number 
1daf			;  
1daf			; if a string 
1daf			;     scan for ending " to get length of string to malloc for + 1 
1daf			;     malloc 
1daf			;     put pointer to string on stack first byte flags as string 
1daf			; 
1daf			; else a number 
1daf			;    look for number format identifier 
1daf			;    $xx hex 
1daf			;    %xxxxx bin 
1daf			;    xxxxx decimal 
1daf			;    convert number to 16bit word.  
1daf			;    malloc word + 1 with flag to identiy as num 
1daf			;    put pointer to number on stack 
1daf			;   
1daf			;  
1daf			  
1daf			forth_apush: 
1daf				; kernel push 
1daf			 
1daf			if DEBUG_FORTH_PUSH 
1daf						DMARK "PSH" 
1daf f5				push af  
1db0 3a c4 1d			ld a, (.dmark)  
1db3 32 6b ee			ld (debug_mark),a  
1db6 3a c5 1d			ld a, (.dmark+1)  
1db9 32 6c ee			ld (debug_mark+1),a  
1dbc 3a c6 1d			ld a, (.dmark+2)  
1dbf 32 6d ee			ld (debug_mark+2),a  
1dc2 18 03			jr .pastdmark  
1dc4 ..			.dmark: db "PSH"  
1dc7 f1			.pastdmark: pop af  
1dc8			endm  
# End of macro DMARK
1dc8				CALLMONITOR 
1dc8 cd 6f ee			call debug_vector  
1dcb				endm  
# End of macro CALLMONITOR
1dcb			endif	 
1dcb				; identify input type 
1dcb			 
1dcb 7e				ld a,(hl) 
1dcc fe 22			cp '"' 
1dce 28 0a			jr z, .fapstr 
1dd0 fe 24			cp '$' 
1dd2 ca fa 1d			jp z, .faphex 
1dd5 fe 25			cp '%' 
1dd7 ca e2 1d			jp z, .fapbin 
1dda			;	cp 'b' 
1dda			;	jp z, .fabin 
1dda				; else decimal 
1dda			 
1dda				; TODO do decimal conversion 
1dda				; decimal is stored as a 16bit word 
1dda			 
1dda				; by default everything is a string if type is not detected 
1dda			.fapstr: ; 
1dda fe 22			cp '"' 
1ddc 20 01			jr nz, .strnoqu 
1dde 23				inc hl 
1ddf			.strnoqu: 
1ddf c3 b4 1c			jp forth_push_str 
1de2			 
1de2			 
1de2			 
1de2			.fapbin:    ; push a binary string.  
1de2 11 00 00			ld de, 0   ; hold a 16bit value 
1de5			 
1de5 23			.fapbinshift:	inc hl  
1de6 7e				ld a,(hl) 
1de7 fe 00			cp 0     ; done scanning  
1de9 28 0b			jr z, .fapbdone  	; got it in HL so push  
1deb			 
1deb				; left shift de 
1deb eb				ex de, hl	 
1dec 29				add hl, hl 
1ded			 
1ded				; is 1 
1ded fe 31			cp '1' 
1def 20 02			jr nz, .binzero 
1df1 cb 4d			bit 1, l 
1df3			.binzero: 
1df3 eb				ex de, hl	 ; save current de 
1df4 18 ef			jr .fapbinshift 
1df6			 
1df6			.fapbdone: 
1df6 eb				ex de, hl 
1df7 c3 46 1c			jp forth_push_numhl 
1dfa			 
1dfa			 
1dfa			.faphex:   ; hex is always stored as a 16bit word 
1dfa				; skip number prefix 
1dfa 23				inc hl 
1dfb				; turn ascii into number 
1dfb cd 9d 11			call get_word_hl	; ret 16bit word in hl 
1dfe			 
1dfe c3 46 1c			jp forth_push_numhl 
1e01			 
1e01 00				 nop 
1e02			 
1e02			.fabin:   ; TODO bin conversion 
1e02			 
1e02			 
1e02 c9				ret 
1e03			 
1e03			 
1e03			; get either a string ptr or a 16bit word from the data stack 
1e03			 
1e03			FORTH_DSP: macro 
1e03				call macro_forth_dsp 
1e03				endm 
1e03			 
1e03			macro_forth_dsp: 
1e03				; data stack pointer points to current word on tos 
1e03			 
1e03 2a ee e9			ld hl,(cli_data_sp) 
1e06			 
1e06				if DEBUG_FORTH_PUSH 
1e06						DMARK "DSP" 
1e06 f5				push af  
1e07 3a 1b 1e			ld a, (.dmark)  
1e0a 32 6b ee			ld (debug_mark),a  
1e0d 3a 1c 1e			ld a, (.dmark+1)  
1e10 32 6c ee			ld (debug_mark+1),a  
1e13 3a 1d 1e			ld a, (.dmark+2)  
1e16 32 6d ee			ld (debug_mark+2),a  
1e19 18 03			jr .pastdmark  
1e1b ..			.dmark: db "DSP"  
1e1e f1			.pastdmark: pop af  
1e1f			endm  
# End of macro DMARK
1e1f			 
1e1f cd a9 4d				call display_data_sp 
1e22				;call break_point_state 
1e22				;rst 030h 
1e22				CALLMONITOR 
1e22 cd 6f ee			call debug_vector  
1e25				endm  
# End of macro CALLMONITOR
1e25				endif 
1e25			 
1e25 c9				ret 
1e26			 
1e26			; return hl to start of value on stack 
1e26			 
1e26			FORTH_DSP_VALUE: macro 
1e26				call macro_forth_dsp_value 
1e26				endm 
1e26			 
1e26			macro_forth_dsp_value: 
1e26			 
1e26				FORTH_DSP 
1e26 cd 03 1e			call macro_forth_dsp 
1e29				endm 
# End of macro FORTH_DSP
1e29			 
1e29 d5				push de 
1e2a			 
1e2a 23				inc hl ; skip type 
1e2b			 
1e2b 5e				ld e, (hl) 
1e2c 23				inc hl 
1e2d 56				ld d, (hl) 
1e2e eb				ex de,hl  
1e2f			 
1e2f d1				pop de 
1e30			 
1e30 c9				ret 
1e31			 
1e31			; return hl to start of value to second item on stack 
1e31			 
1e31			FORTH_DSP_VALUEM1: macro 
1e31				call macro_forth_dsp_value_m1 
1e31				endm 
1e31			 
1e31			macro_forth_dsp_value_m1: 
1e31			 
1e31				FORTH_DSP 
1e31 cd 03 1e			call macro_forth_dsp 
1e34				endm 
# End of macro FORTH_DSP
1e34			 
1e34 2b				dec hl 
1e35 2b				dec hl 
1e36			;	dec hl 
1e36			 
1e36 d5				push de 
1e37			 
1e37 5e				ld e, (hl) 
1e38 23				inc hl 
1e39 56				ld d, (hl) 
1e3a eb				ex de,hl  
1e3b			 
1e3b d1				pop de 
1e3c			 
1e3c c9				ret 
1e3d			 
1e3d				 
1e3d			 
1e3d			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1e3d			 
1e3d			FORTH_DSP_POP: macro 
1e3d				call macro_forth_dsp_pop 
1e3d				endm 
1e3d			 
1e3d			 
1e3d			; get the tos data type 
1e3d			 
1e3d			FORTH_DSP_TYPE:   macro 
1e3d			 
1e3d				;FORTH_DSP_VALUE 
1e3d				FORTH_DSP 
1e3d				 
1e3d				; hl points to value 
1e3d				; check type 
1e3d			 
1e3d				ld a,(hl) 
1e3d			 
1e3d				endm 
1e3d			 
1e3d			; load the tos value into hl 
1e3d			 
1e3d			 
1e3d			FORTH_DSP_VALUEHL:  macro 
1e3d				call macro_dsp_valuehl 
1e3d				endm 
1e3d			 
1e3d			 
1e3d			 
1e3d			macro_dsp_valuehl: 
1e3d				FORTH_DSP_VALUE 
1e3d cd 26 1e			call macro_forth_dsp_value 
1e40				endm 
# End of macro FORTH_DSP_VALUE
1e40			 
1e40				;FORTH_ERR_TOS_NOTNUM 
1e40			 
1e40				;inc hl   ; skip type id 
1e40			 
1e40			;	push de 
1e40			; 
1e40			;	ld e, (hl) 
1e40			;	inc hl 
1e40			;	ld d, (hl) 
1e40			;	ex de,hl  
1e40			 
1e40			;	pop de 
1e40			 
1e40				if DEBUG_FORTH_PUSH 
1e40						DMARK "DVL" 
1e40 f5				push af  
1e41 3a 55 1e			ld a, (.dmark)  
1e44 32 6b ee			ld (debug_mark),a  
1e47 3a 56 1e			ld a, (.dmark+1)  
1e4a 32 6c ee			ld (debug_mark+1),a  
1e4d 3a 57 1e			ld a, (.dmark+2)  
1e50 32 6d ee			ld (debug_mark+2),a  
1e53 18 03			jr .pastdmark  
1e55 ..			.dmark: db "DVL"  
1e58 f1			.pastdmark: pop af  
1e59			endm  
# End of macro DMARK
1e59				CALLMONITOR 
1e59 cd 6f ee			call debug_vector  
1e5c				endm  
# End of macro CALLMONITOR
1e5c				endif 
1e5c c9				ret 
1e5d			 
1e5d			forth_apushstrhl:      
1e5d				; push of string requires use of cli_origptr 
1e5d				; bodge use 
1e5d			 
1e5d				; get current cli_origptr, save, update with temp pointer  
1e5d ed 5b 3e ea		ld de, (cli_origptr) 
1e61 22 3e ea			ld (cli_origptr), hl 
1e64 d5				push de 
1e65 cd af 1d			call forth_apush 
1e68 d1				pop de 
1e69 ed 53 3e ea		ld (cli_origptr), de 
1e6d c9			        ret	 
1e6e			 
1e6e			 
1e6e			; increase loop stack pointer and save hl to it 
1e6e				 
1e6e			FORTH_LOOP_NEXT: macro 
1e6e				call macro_forth_loop_next 
1e6e				;nop 
1e6e				endm 
1e6e			 
1e6e			macro_forth_loop_next: 
1e6e				if DEBUG_FORTH_STACK_GUARD 
1e6e cd e2 61				call check_stacks 
1e71				endif 
1e71 e5				push hl 
1e72 d5				push de 
1e73 eb				ex de,hl 
1e74 2a f0 e9			ld hl,(cli_loop_sp) 
1e77 23				inc hl 
1e78 23				inc hl 
1e79					if DEBUG_FORTH_WORDS 
1e79						DMARK "LNX" 
1e79 f5				push af  
1e7a 3a 8e 1e			ld a, (.dmark)  
1e7d 32 6b ee			ld (debug_mark),a  
1e80 3a 8f 1e			ld a, (.dmark+1)  
1e83 32 6c ee			ld (debug_mark+1),a  
1e86 3a 90 1e			ld a, (.dmark+2)  
1e89 32 6d ee			ld (debug_mark+2),a  
1e8c 18 03			jr .pastdmark  
1e8e ..			.dmark: db "LNX"  
1e91 f1			.pastdmark: pop af  
1e92			endm  
# End of macro DMARK
1e92						CALLMONITOR 
1e92 cd 6f ee			call debug_vector  
1e95				endm  
# End of macro CALLMONITOR
1e95					endif 
1e95 22 f0 e9			ld (cli_loop_sp),hl 
1e98 73				ld (hl), e 
1e99 23				inc hl 
1e9a 72				ld (hl), d 
1e9b d1				pop de    ; been reversed so save a swap on restore 
1e9c e1				pop hl 
1e9d				if DEBUG_FORTH_STACK_GUARD 
1e9d cd e2 61				call check_stacks 
1ea0				endif 
1ea0 c9				ret 
1ea1			 
1ea1			; get current ret stack pointer and save to hl  
1ea1				 
1ea1			FORTH_LOOP_TOS: macro 
1ea1				call macro_forth_loop_tos 
1ea1				endm 
1ea1			 
1ea1			macro_forth_loop_tos: 
1ea1 d5				push de 
1ea2 2a f0 e9			ld hl,(cli_loop_sp) 
1ea5 5e				ld e, (hl) 
1ea6 23				inc hl 
1ea7 56				ld d, (hl) 
1ea8 eb				ex de, hl 
1ea9 d1				pop de 
1eaa c9				ret 
1eab			 
1eab			; pop loop stack pointer 
1eab				 
1eab			FORTH_LOOP_POP: macro 
1eab				call macro_forth_loop_pop 
1eab				endm 
1eab			 
1eab			 
1eab			macro_forth_loop_pop: 
1eab				if DEBUG_FORTH_STACK_GUARD 
1eab					DMARK "LPP" 
1eab f5				push af  
1eac 3a c0 1e			ld a, (.dmark)  
1eaf 32 6b ee			ld (debug_mark),a  
1eb2 3a c1 1e			ld a, (.dmark+1)  
1eb5 32 6c ee			ld (debug_mark+1),a  
1eb8 3a c2 1e			ld a, (.dmark+2)  
1ebb 32 6d ee			ld (debug_mark+2),a  
1ebe 18 03			jr .pastdmark  
1ec0 ..			.dmark: db "LPP"  
1ec3 f1			.pastdmark: pop af  
1ec4			endm  
# End of macro DMARK
1ec4 cd e2 61				call check_stacks 
1ec7					FORTH_CHK_LOOP_UNDER 
1ec7 e5				push hl 
1ec8 d5				push de 
1ec9 2a f0 e9			ld hl,(cli_loop_sp) 
1ecc 11 2a e9			ld de, cli_loop_stack 
1ecf cd 04 0e			call cmp16 
1ed2 da fc 62			jp c, fault_loop_under 
1ed5 d1				pop de 
1ed6 e1				pop hl 
1ed7				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ed7				endif 
1ed7 e5				push hl 
1ed8 2a f0 e9			ld hl,(cli_loop_sp) 
1edb 2b				dec hl 
1edc 2b				dec hl 
1edd 22 f0 e9			ld (cli_loop_sp), hl 
1ee0				; TODO do stack underflow checks 
1ee0 e1				pop hl 
1ee1				if DEBUG_FORTH_STACK_GUARD 
1ee1 cd e2 61				call check_stacks 
1ee4					FORTH_CHK_LOOP_UNDER 
1ee4 e5				push hl 
1ee5 d5				push de 
1ee6 2a f0 e9			ld hl,(cli_loop_sp) 
1ee9 11 2a e9			ld de, cli_loop_stack 
1eec cd 04 0e			call cmp16 
1eef da fc 62			jp c, fault_loop_under 
1ef2 d1				pop de 
1ef3 e1				pop hl 
1ef4				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ef4				endif 
1ef4 c9				ret 
1ef5			 
1ef5			macro_forth_dsp_pop: 
1ef5			 
1ef5 e5				push hl 
1ef6			 
1ef6				; release malloc data 
1ef6			 
1ef6				if DEBUG_FORTH_STACK_GUARD 
1ef6 cd e2 61				call check_stacks 
1ef9					FORTH_CHK_DSP_UNDER 
1ef9 e5				push hl 
1efa d5				push de 
1efb 2a ee e9			ld hl,(cli_data_sp) 
1efe 11 28 e8			ld de, cli_data_stack 
1f01 cd 04 0e			call cmp16 
1f04 da f0 62			jp c, fault_dsp_under 
1f07 d1				pop de 
1f08 e1				pop hl 
1f09				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f09				endif 
1f09				;ld hl,(cli_data_sp) 
1f09			if DEBUG_FORTH_DOT 
1f09				DMARK "DPP" 
1f09 f5				push af  
1f0a 3a 1e 1f			ld a, (.dmark)  
1f0d 32 6b ee			ld (debug_mark),a  
1f10 3a 1f 1f			ld a, (.dmark+1)  
1f13 32 6c ee			ld (debug_mark+1),a  
1f16 3a 20 1f			ld a, (.dmark+2)  
1f19 32 6d ee			ld (debug_mark+2),a  
1f1c 18 03			jr .pastdmark  
1f1e ..			.dmark: db "DPP"  
1f21 f1			.pastdmark: pop af  
1f22			endm  
# End of macro DMARK
1f22				CALLMONITOR 
1f22 cd 6f ee			call debug_vector  
1f25				endm  
# End of macro CALLMONITOR
1f25			endif	 
1f25			 
1f25			 
1f25			if FORTH_ENABLE_DSPPOPFREE 
1f25			 
1f25				FORTH_DSP 
1f25 cd 03 1e			call macro_forth_dsp 
1f28				endm 
# End of macro FORTH_DSP
1f28			 
1f28 7e				ld a, (hl) 
1f29 fe 01			cp DS_TYPE_STR 
1f2b 20 23			jr nz, .skippopfree 
1f2d			 
1f2d				FORTH_DSP_VALUEHL 
1f2d cd 3d 1e			call macro_dsp_valuehl 
1f30				endm 
# End of macro FORTH_DSP_VALUEHL
1f30 00				nop 
1f31			if DEBUG_FORTH_DOT 
1f31				DMARK "DPf" 
1f31 f5				push af  
1f32 3a 46 1f			ld a, (.dmark)  
1f35 32 6b ee			ld (debug_mark),a  
1f38 3a 47 1f			ld a, (.dmark+1)  
1f3b 32 6c ee			ld (debug_mark+1),a  
1f3e 3a 48 1f			ld a, (.dmark+2)  
1f41 32 6d ee			ld (debug_mark+2),a  
1f44 18 03			jr .pastdmark  
1f46 ..			.dmark: db "DPf"  
1f49 f1			.pastdmark: pop af  
1f4a			endm  
# End of macro DMARK
1f4a				CALLMONITOR 
1f4a cd 6f ee			call debug_vector  
1f4d				endm  
# End of macro CALLMONITOR
1f4d			endif	 
1f4d cd 77 13			call free 
1f50			.skippopfree: 
1f50				 
1f50			 
1f50			endif 
1f50			 
1f50			if DEBUG_FORTH_DOT_KEY 
1f50				DMARK "DP2" 
1f50				CALLMONITOR 
1f50			endif	 
1f50			 
1f50				; move pointer down 
1f50			 
1f50 2a ee e9			ld hl,(cli_data_sp) 
1f53 2b				dec hl 
1f54 2b				dec hl 
1f55			; PARSEV5 
1f55 2b				dec hl 
1f56 22 ee e9			ld (cli_data_sp), hl 
1f59			 
1f59				if DEBUG_FORTH_STACK_GUARD 
1f59 cd e2 61				call check_stacks 
1f5c					FORTH_CHK_DSP_UNDER 
1f5c e5				push hl 
1f5d d5				push de 
1f5e 2a ee e9			ld hl,(cli_data_sp) 
1f61 11 28 e8			ld de, cli_data_stack 
1f64 cd 04 0e			call cmp16 
1f67 da f0 62			jp c, fault_dsp_under 
1f6a d1				pop de 
1f6b e1				pop hl 
1f6c				endm 
# End of macro FORTH_CHK_DSP_UNDER
1f6c				endif 
1f6c			 
1f6c e1				pop hl 
1f6d			 
1f6d c9				ret 
1f6e			 
1f6e			getwordathl: 
1f6e				; hl points to an address 
1f6e				; load hl with the word at that address 
1f6e			 
1f6e d5				push de 
1f6f			 
1f6f 5e				ld e, (hl) 
1f70 23				inc hl 
1f71 56				ld d, (hl) 
1f72 eb				ex de, hl 
1f73			 
1f73 d1				pop de 
1f74 c9				ret 
1f75			 
1f75			 
1f75			 
1f75			 
1f75			 
1f75			; eof 
1f75			 
# End of file forth_stackopsv5.asm
1f75			endif 
1f75			 
1f75			loadwordinhl:	 
1f75			 
1f75 d5				push de 
1f76			 
1f76 5e				ld e, (hl) 
1f77 23				inc hl 
1f78 56				ld d, (hl) 
1f79 eb				ex de,hl  
1f7a			 
1f7a d1				pop de 
1f7b			 
1f7b c9				ret 
1f7c			 
1f7c			user_word_eol:  
1f7c				; hl contains the pointer to where to create a linked list item from the end 
1f7c				; of the user dict to continue on at the system word dict 
1f7c				 
1f7c				; poke the stub of the word list linked list to repoint to rom words 
1f7c			 
1f7c				; stub format 
1f7c				; db   word id 
1f7c				; dw    link to next word 
1f7c			        ; db char length of token 
1f7c				; db string + 0 term 
1f7c				; db exec code....  
1f7c			 
1f7c 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1f7e 77				ld (hl), a		; word id 
1f7f 23				inc hl 
1f80			 
1f80 11 4b 21			ld de, sysdict 
1f83 73				ld (hl), e		; next word link ie system dict 
1f84 23				inc hl 
1f85 72				ld (hl), d		; next word link ie system dict 
1f86 23				inc hl	 
1f87			 
1f87			;	ld (hl), sysdict		; next word link ie system dict 
1f87			;	inc hl 
1f87			;	inc hl 
1f87			 
1f87			;	inc hl 
1f87			;	inc hl 
1f87			 
1f87 3e 02			ld a, 2			; word length is 0 
1f89 77				ld (hl), a	 
1f8a 23				inc hl 
1f8b			 
1f8b 3e 7e			ld a, '~'			; word length is 0 
1f8d 77				ld (hl), a	 
1f8e 23				inc hl 
1f8f 3e 00			ld a, 0			; save empty word 
1f91 77				ld (hl), a 
1f92			 
1f92 c9				ret 
1f93			 
1f93				 
1f93			 
1f93			forthexec_cleanup: 
1f93				FORTH_RSP_POP 
1f93 cd 0e 1c			call macro_forth_rsp_pop 
1f96				endm 
# End of macro FORTH_RSP_POP
1f96 c9				ret 
1f97			 
1f97			forth_call_hl: 
1f97				; taking hl 
1f97 e5				push hl 
1f98 c9				ret 
1f99			 
1f99			; this is called to reset Forth system but keep existing uwords etc 
1f99			 
1f99			forth_warmstart: 
1f99				; setup stack over/under flow checks 
1f99				if DEBUG_FORTH_STACK_GUARD 
1f99 cd c8 61				call chk_stk_init 
1f9c				endif 
1f9c			 
1f9c				; init stack pointers  - * these stacks go upwards *  
1f9c 21 ac e9			ld hl, cli_ret_stack 
1f9f 22 f2 e9			ld (cli_ret_sp), hl	 
1fa2				; set bottom of stack 
1fa2 3e 00			ld a,0 
1fa4 77				ld (hl),a 
1fa5 23				inc hl 
1fa6 77				ld (hl),a 
1fa7			 
1fa7 21 28 e8			ld hl, cli_data_stack 
1faa 22 ee e9			ld (cli_data_sp), hl	 
1fad				; set bottom of stack 
1fad 3e 00			ld a,0 
1faf 77				ld (hl),a 
1fb0 23				inc hl 
1fb1 77				ld (hl),a 
1fb2			 
1fb2 21 2a e9			ld hl, cli_loop_stack 
1fb5 22 f0 e9			ld (cli_loop_sp), hl	 
1fb8				; set bottom of stack 
1fb8 3e 00			ld a,0 
1fba 77				ld (hl),a 
1fbb 23				inc hl 
1fbc 77				ld (hl),a 
1fbd			 
1fbd				; init extent of current open file 
1fbd			 
1fbd 3e 00			ld a, 0 
1fbf 32 6a ea			ld (store_openext), a 
1fc2			 
1fc2 c9				ret 
1fc3			 
1fc3			 
1fc3			 
1fc3			; Cold Start - this is called to setup the whole Forth system 
1fc3			 
1fc3			forth_init: 
1fc3			 
1fc3				; setup stack over/under flow checks 
1fc3			 
1fc3			;	if DEBUG_FORTH_STACK_GUARD 
1fc3			;		call chk_stk_init 
1fc3			;	endif 
1fc3			 
1fc3				; enable auto display updates (slow.....) 
1fc3			 
1fc3 3e 01			ld a, 1 
1fc5 32 3c ea			ld (cli_autodisplay), a 
1fc8			 
1fc8				; if storage is in use disable long reads for now 
1fc8 3e 00			ld a, 0 
1fca 32 75 ea			ld (store_longread), a 
1fcd			 
1fcd			 
1fcd				; show start up screen 
1fcd			 
1fcd cd b9 0b			call clear_display 
1fd0			 
1fd0 3e 00			ld a,0 
1fd2 32 5e ea			ld (f_cursor_ptr), a 
1fd5			 
1fd5				; set start of word list in start of ram - for use when creating user words 
1fd5			 
1fd5 21 d4 65			ld hl, baseram 
1fd8 22 be e5			ld (os_last_new_uword), hl 
1fdb cd 7c 1f			call user_word_eol 
1fde				 
1fde			;		call display_data_sp 
1fde			;		call next_page_prompt 
1fde			 
1fde			 
1fde			 
1fde			 
1fde c9				ret 
1fdf			 
1fdf .. 00		.bootforth: db " Forth Kernel Init ",0 
1ff3			 
1ff3			; TODO push to stack 
1ff3			 
1ff3			;  
1ff3			 
1ff3			if FORTH_PARSEV2 
1ff3			 
1ff3			 
1ff3				include "forth_parserv2.asm" 
1ff3			 
1ff3			endif 
1ff3			 
1ff3			 
1ff3			; parse cli version 1 
1ff3			 
1ff3			if FORTH_PARSEV1 
1ff3			 
1ff3			 
1ff3			 
1ff3			      include "forth_parserv1.asm" 
1ff3			endif 
1ff3				 
1ff3			if FORTH_PARSEV3 
1ff3			 
1ff3			 
1ff3			 
1ff3			      include "forth_parserv3.asm" 
1ff3				include "forth_wordsv3.asm" 
1ff3			endif 
1ff3			 
1ff3			if FORTH_PARSEV4 
1ff3			 
1ff3			 
1ff3			 
1ff3			      include "forth_parserv4.asm" 
1ff3				include "forth_wordsv4.asm" 
1ff3			endif 
1ff3			 
1ff3			if FORTH_PARSEV5 
1ff3			 
1ff3			 
1ff3			 
1ff3			      include "forth_parserv5.asm" 
1ff3			 
1ff3			 
1ff3			; A better parser without using malloc and string copies all over the place.  
1ff3			; Exec in situ should be faster 
1ff3			 
1ff3			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1ff3			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1ff3			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1ff3			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1ff3			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1ff3			WORD_SYS_END: equ 0   ; Opcode for all user words 
1ff3			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1ff3			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1ff3			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1ff3			 
1ff3			; Core word preamble macro 
1ff3			 
1ff3			CWHEAD:   macro nxtword opcode lit len opflags 
1ff3				db WORD_SYS_CORE+opcode             
1ff3				; internal op code number 
1ff3				dw nxtword            
1ff3				; link to next dict word block 
1ff3				db len + 1 
1ff3				; literal length of dict word inc zero term 
1ff3				db lit,0              
1ff3				; literal dict word 
1ff3			        ; TODO db opflags        
1ff3				endm 
1ff3			 
1ff3			 
1ff3			NEXTW: macro  
1ff3				jp macro_next 
1ff3				endm 
1ff3			 
1ff3			macro_next: 
1ff3			if DEBUG_FORTH_PARSE_KEY 
1ff3				DMARK "NXT" 
1ff3				CALLMONITOR 
1ff3			endif	 
1ff3			;	inc hl  ; skip token null term  
1ff3 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1ff7 ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1ffb 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1ffe			if DEBUG_FORTH_PARSE_KEY 
1ffe				DMARK "}AA" 
1ffe				CALLMONITOR 
1ffe			endif	 
1ffe c3 01 21			jp execnext 
2001				;jp exec1 
2001			       
2001			 
2001			 
2001			; Another go at the parser to compile  
2001			 
2001			 
2001			; TODO rework parser to change all of the string words to byte tokens 
2001			; TODO do a search for  
2001			 
2001			; TODO first run normal parser to zero term sections 
2001			; TODO for each word do a token look up to get the op code 
2001			; TODO need some means to flag to the exec that this is a byte code form    
2001			 
2001			 
2001			forthcompile: 
2001			 
2001			; 
2001			; line parse: 
2001			;       parse raw input buffer 
2001			;       tokenise the words 
2001			;       malloc new copy (for looping etc) 
2001			;       copy to malloc + current pc in line to start of string and add line term 
2001			;       save on new rsp 
2001			; 
2001			 
2001			; hl to point to the line to tokenise 
2001			 
2001			;	push hl 
2001 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
2004			 
2004			;	ld a,0		; string term on input 
2004			;	call strlent 
2004			 
2004			;	ld (os_tok_len), hl	 ; save string length 
2004			 
2004			;if DEBUG_FORTH_TOK 
2004			;	ex de,hl		 
2004			;endif 
2004			 
2004			;	pop hl 		; get back string pointer 
2004			 
2004			if DEBUG_FORTH_TOK 
2004						DMARK "TOc" 
2004				CALLMONITOR 
2004			endif 
2004 7e			.cptoken2:    ld a,(hl) 
2005 23				inc hl 
2006 fe 7f			cp FORTH_END_BUFFER 
2008 28 29			jr z, .cptokendone2 
200a fe 00			cp 0 
200c 28 25			jr z, .cptokendone2 
200e fe 22			cp '"' 
2010 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2012 fe 20			cp ' ' 
2014 20 ee			jr nz,  .cptoken2 
2016			 
2016			; TODO consume comments held between ( and ) 
2016			 
2016				; we have a space so change to zero term for dict match later 
2016 2b				dec hl 
2017 3e 00			ld a,0 
2019 77				ld (hl), a 
201a 23				inc hl 
201b 18 e7			jr .cptoken2 
201d				 
201d			 
201d			.cptokenstr2: 
201d				; skip all white space until either eol (because forgot to term) or end double quote 
201d			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
201d				;inc hl ; skip current double quote 
201d 7e				ld a,(hl) 
201e 23				inc hl 
201f fe 22			cp '"' 
2021 28 e1			jr z, .cptoken2 
2023 fe 7f			cp FORTH_END_BUFFER 
2025 28 0c			jr z, .cptokendone2 
2027 fe 00			cp 0 
2029 28 08			jr z, .cptokendone2 
202b fe 20			cp ' ' 
202d 28 02			jr z, .cptmp2 
202f 18 ec			jr .cptokenstr2 
2031			 
2031			.cptmp2:	; we have a space so change to zero term for dict match later 
2031				;dec hl 
2031				;ld a,"-"	; TODO remove this when working 
2031				;ld (hl), a 
2031				;inc hl 
2031 18 ea			jr .cptokenstr2 
2033			 
2033			.cptokendone2: 
2033				;inc hl 
2033 3e 7f			ld a, FORTH_END_BUFFER 
2035 77				ld (hl),a 
2036 23				inc hl 
2037 3e 21			ld a, '!' 
2039 77				ld (hl),a 
203a			 
203a 2a c2 e5			ld hl,(os_tok_ptr) 
203d			         
203d			if DEBUG_FORTH_TOK 
203d						DMARK "Tc1" 
203d				CALLMONITOR 
203d			endif 
203d			 
203d				; push exec string to top of return stack 
203d				FORTH_RSP_NEXT 
203d cd ed 1b			call macro_forth_rsp_next 
2040				endm 
# End of macro FORTH_RSP_NEXT
2040 c9				ret 
2041			 
2041			; Another go at the parser need to simplify the process 
2041			 
2041			forthparse: 
2041			 
2041			; 
2041			; line parse: 
2041			;       parse raw input buffer 
2041			;       tokenise the words 
2041			;       malloc new copy (for looping etc) 
2041			;       copy to malloc + current pc in line to start of string and add line term 
2041			;       save on new rsp 
2041			; 
2041			 
2041			; hl to point to the line to tokenise 
2041			 
2041			;	push hl 
2041 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
2044			 
2044			;	ld a,0		; string term on input 
2044			;	call strlent 
2044			 
2044			;	ld (os_tok_len), hl	 ; save string length 
2044			 
2044			;if DEBUG_FORTH_TOK 
2044			;	ex de,hl		 
2044			;endif 
2044			 
2044			;	pop hl 		; get back string pointer 
2044			 
2044			if DEBUG_FORTH_TOK 
2044						DMARK "TOK" 
2044				CALLMONITOR 
2044			endif 
2044 7e			.ptoken2:    ld a,(hl) 
2045 23				inc hl 
2046 fe 7f			cp FORTH_END_BUFFER 
2048 28 29			jr z, .ptokendone2 
204a fe 00			cp 0 
204c 28 25			jr z, .ptokendone2 
204e fe 22			cp '"' 
2050 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2052 fe 20			cp ' ' 
2054 20 ee			jr nz,  .ptoken2 
2056			 
2056			; TODO consume comments held between ( and ) 
2056			 
2056				; we have a space so change to zero term for dict match later 
2056 2b				dec hl 
2057 3e 00			ld a,0 
2059 77				ld (hl), a 
205a 23				inc hl 
205b 18 e7			jr .ptoken2 
205d				 
205d			 
205d			.ptokenstr2: 
205d				; skip all white space until either eol (because forgot to term) or end double quote 
205d			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
205d				;inc hl ; skip current double quote 
205d 7e				ld a,(hl) 
205e 23				inc hl 
205f fe 22			cp '"' 
2061 28 e1			jr z, .ptoken2 
2063 fe 7f			cp FORTH_END_BUFFER 
2065 28 0c			jr z, .ptokendone2 
2067 fe 00			cp 0 
2069 28 08			jr z, .ptokendone2 
206b fe 20			cp ' ' 
206d 28 02			jr z, .ptmp2 
206f 18 ec			jr .ptokenstr2 
2071			 
2071			.ptmp2:	; we have a space so change to zero term for dict match later 
2071				;dec hl 
2071				;ld a,"-"	; TODO remove this when working 
2071				;ld (hl), a 
2071				;inc hl 
2071 18 ea			jr .ptokenstr2 
2073			 
2073			.ptokendone2: 
2073				;inc hl 
2073 3e 7f			ld a, FORTH_END_BUFFER 
2075 77				ld (hl),a 
2076 23				inc hl 
2077 3e 21			ld a, '!' 
2079 77				ld (hl),a 
207a			 
207a 2a c2 e5			ld hl,(os_tok_ptr) 
207d			         
207d			if DEBUG_FORTH_TOK 
207d						DMARK "TK1" 
207d				CALLMONITOR 
207d			endif 
207d			 
207d				; push exec string to top of return stack 
207d				FORTH_RSP_NEXT 
207d cd ed 1b			call macro_forth_rsp_next 
2080				endm 
# End of macro FORTH_RSP_NEXT
2080 c9				ret 
2081			 
2081			; 
2081			;	; malloc size + buffer pointer + if is loop flag 
2081			;	ld hl,(os_tok_len) 		 ; get string length 
2081			; 
2081			;	ld a,l 
2081			; 
2081			;	cp 0			; we dont want to use a null string 
2081			;	ret z 
2081			; 
2081			;;	add 3    ; prefix malloc with buffer for current word ptr 
2081			; 
2081			;	add 5     ; TODO when certain not over writing memory remove 
2081			; 
2081			;		 
2081			; 
2081			;if DEBUG_FORTH_TOK 
2081			;			DMARK "TKE" 
2081			;	CALLMONITOR 
2081			;endif 
2081			; 
2081			;	ld l,a 
2081			;	ld h,0 
2081			;;	push hl   ; save required space for the copy later 
2081			;	call malloc 
2081			;if DEBUG_FORTH_TOK 
2081			;			DMARK "TKM" 
2081			;	CALLMONITOR 
2081			;endif 
2081			;	if DEBUG_FORTH_MALLOC_GUARD 
2081			;		push af 
2081			;		call ishlzero 
2081			;;		ld a, l 
2081			;;		add h 
2081			;;		cp 0 
2081			;		pop af 
2081			;		 
2081			;		call z,malloc_error 
2081			;	endif 
2081			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2081			; 
2081			; 
2081			;if DEBUG_FORTH_TOK 
2081			;			DMARK "TKR" 
2081			;	CALLMONITOR 
2081			;endif 
2081			; 
2081			;	FORTH_RSP_NEXT 
2081			; 
2081			;	;inc hl	 ; go past current buffer pointer 
2081			;	;inc hl 
2081			;	;inc hl   ; and past if loop flag 
2081			;		; TODO Need to set flag  
2081			; 
2081			;	 
2081			;	 
2081			;	ex de,hl	; malloc is dest 
2081			;	ld hl, (os_tok_len) 
2081			;;	pop bc 
2081			;	ld c, l                
2081			;	ld b,0 
2081			;	ld hl, (os_tok_ptr) 
2081			; 
2081			;if DEBUG_FORTH_TOK 
2081			;			DMARK "TKT" 
2081			;	CALLMONITOR 
2081			;endif 
2081			; 
2081			;	; do str cpy 
2081			; 
2081			;	ldir      ; copy byte in hl to de 
2081			; 
2081			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2081			; 
2081			;if DEBUG_FORTH_TOK 
2081			; 
2081			;			DMARK "TKY" 
2081			;	CALLMONITOR 
2081			;endif 
2081			;	;ld a,0 
2081			;	;ld a,FORTH_END_BUFFER 
2081			;	ex de, hl 
2081			;	;dec hl			 ; go back over the space delim at the end of word 
2081			;	;ld (hl),a 
2081			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2081			;	ld a,FORTH_END_BUFFER 
2081			;	ld (hl),a 
2081			;	inc hl 
2081			;	ld a,FORTH_END_BUFFER 
2081			;	ld (hl),a 
2081			; 
2081			;	; init the malloc area data 
2081			;	; set pc for in current area 
2081			;	;ld hl, (os_tok_malloc) 
2081			;	;inc hl 
2081			;	;inc hl 
2081			;	;inc hl 
2081			;	;ex de,hl 
2081			;	;ld hl, (os_tok_malloc) 
2081			;	;ld (hl),e 
2081			;	;inc hl 
2081			;	;ld (hl),d 
2081			; 
2081			; 
2081			;	ld hl,(os_tok_malloc) 
2081			;if DEBUG_FORTH_PARSE_KEY 
2081			;			DMARK "TKU" 
2081			;	CALLMONITOR 
2081			;endif 
2081			; 
2081			;	ret 
2081			 
2081			forthexec: 
2081			 
2081			; line exec: 
2081			; forth parser 
2081			 
2081			; 
2081			;       get current exec line on rsp 
2081			 
2081				FORTH_RSP_TOS 
2081 cd 04 1c			call macro_forth_rsp_tos 
2084				endm 
# End of macro FORTH_RSP_TOS
2084			 
2084			;       restore current pc - hl points to malloc of data 
2084			 
2084				;ld e, (hl) 
2084				;inc hl 
2084				;ld d, (hl) 
2084				;ex de,hl 
2084			 
2084			 
2084			exec1: 
2084 22 c2 e5			ld (os_tok_ptr), hl 
2087			 
2087				; copy our PC to working vars  
2087 22 40 ea			ld (cli_ptr), hl 
208a 22 3e ea			ld (cli_origptr), hl 
208d			 
208d 7e				ld a,(hl) 
208e fe 7f			cp FORTH_END_BUFFER 
2090 c8				ret z 
2091			 
2091				; skip any nulls 
2091			 
2091 fe 00			cp 0 
2093 20 03			jr nz, .execword 
2095 23				inc hl 
2096 18 ec			jr exec1 
2098			 
2098			 
2098			.execword: 
2098			 
2098			 
2098			 
2098			if DEBUG_FORTH_PARSE_KEY 
2098						DMARK "KYQ" 
2098				CALLMONITOR 
2098			endif 
2098			;       while at start of word: 
2098			; get start of dict (in user area first) 
2098			 
2098 21 d4 65		ld hl, baseram 
209b			;ld hl, sysdict 
209b 22 42 ea		ld (cli_nextword),hl 
209e			;           match word at pc 
209e			;           exec word 
209e			;           or push to dsp 
209e			;           forward to next token 
209e			;           if line term pop rsp and exit 
209e			;        
209e			 
209e			if DEBUG_FORTH_PARSE_KEY 
209e						DMARK "KYq" 
209e				CALLMONITOR 
209e			endif 
209e			 
209e			; 
209e			; word comp 
209e			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
209e			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
209e			;    move to start of word  
209e			;    compare word to cli_token 
209e			 
209e			.execpnword:	; HL at start of a word in the dictionary to check 
209e			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
209e			;	ld (cli_ptr), hl 
209e			 
209e 2a 42 ea			ld hl,(cli_nextword) 
20a1			 
20a1 cd 44 21			call forth_tok_next 
20a4			; tok next start here 
20a4			;	; TODO skip compiled symbol for now 
20a4			;	inc hl 
20a4			; 
20a4			;	; save pointer to next word 
20a4			; 
20a4			;	; hl now points to the address of the next word pointer  
20a4			;	ld e, (hl) 
20a4			;	inc hl 
20a4			;	ld d, (hl) 
20a4			;	inc l 
20a4			; 
20a4			;	ex de,hl 
20a4			;if DEBUG_FORTH_PARSE_NEXTWORD 
20a4			;	push bc 
20a4			;	ld bc, (cli_nextword) 
20a4			;			DMARK "NXW" 
20a4			;	CALLMONITOR 
20a4			;	pop bc 
20a4			;endif 
20a4			; tok next end here 
20a4 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
20a7 eb				ex de, hl 
20a8			 
20a8			 
20a8				; save the pointer of the current token - 1 to check against 
20a8				 
20a8 22 46 ea			ld (cli_token), hl   
20ab				; TODO maybe remove below save if no debug 
20ab				; save token string ptr for any debug later 
20ab 23				inc hl  
20ac 22 48 ea			ld (cli_origtoken), hl 
20af 2b				dec hl 
20b0				; save pointer to the start of the next dictionay word 
20b0 7e				ld a,(hl)   ; get string length 
20b1 47				ld b,a 
20b2			.execpnwordinc:  
20b2 23				inc hl 
20b3 10 fd			djnz .execpnwordinc 
20b5 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
20b8			 
20b8				; now check the word token against the string being parsed 
20b8			 
20b8 2a 46 ea			ld hl,(cli_token) 
20bb 23				inc hl     ; skip string length (use zero term instead to end) 
20bc 22 46 ea			ld (cli_token), hl 
20bf			 
20bf			if DEBUG_FORTH_PARSE_KEY 
20bf						DMARK "KY2" 
20bf			endif 
20bf			if DEBUG_FORTH_PARSE_EXEC 
20bf				; see if disabled 
20bf			 
20bf			;	ld a, (os_view_disable) 
20bf			;	cp '*' 
20bf				ld a, (debug_vector) 
20bf				cp $c9   ; RET  
20bf				jr z, .skip 
20bf			 
20bf				push hl 
20bf				push hl 
20bf				call clear_display 
20bf				ld de, .compword 
20bf				ld a, display_row_1 
20bf				call str_at_display 
20bf				pop de 
20bf				ld a, display_row_2 
20bf				call str_at_display 
20bf				ld hl,(cli_ptr) 
20bf				ld a,(hl) 
20bf			        ld hl, os_word_scratch 
20bf				ld (hl),a 
20bf				ld a,0 
20bf				inc hl 
20bf				ld (hl),a 	 
20bf				ld de, os_word_scratch 
20bf				ld a, display_row_2+10 
20bf				call str_at_display 
20bf				call update_display 
20bf				ld a, 100 
20bf				call aDelayInMS 
20bf				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20bf				call delay250ms 
20bf				endif 
20bf				pop hl 
20bf			.skip:  
20bf			endif	 
20bf			.execpnchar:    ; compare char between token and string to parse 
20bf			 
20bf			if DEBUG_FORTH_PARSE_KEY 
20bf						DMARK "Ky3" 
20bf			endif 
20bf			if DEBUG_FORTH_PARSE_EXEC 
20bf				; see if disabled 
20bf			 
20bf			;	ld a, (os_view_disable) 
20bf			;	cp '*' 
20bf				ld a, (debug_vector) 
20bf				cp $C9  ; RET 
20bf				jr z, .skip2 
20bf			 
20bf			;	call clear_display 
20bf			ld hl,(cli_token) 
20bf			ld a,(hl) 
20bf			ld (os_word_scratch),a 
20bf				ld hl,(cli_ptr) 
20bf			ld a,(hl) 
20bf				ld (os_word_scratch+1),a 
20bf				ld a,0 
20bf				ld (os_word_scratch+2),a 
20bf				ld de,os_word_scratch 
20bf				ld a,display_row_4 
20bf				call str_at_display 
20bf				call update_display 
20bf			.skip2:  
20bf			endif 
20bf 2a 46 ea			ld hl,(cli_token) 
20c2 7e				ld a, (hl)	 ; char in word token 
20c3 23				inc hl 		; move to next char 
20c4 22 46 ea			ld (cli_token), hl ; and save it 
20c7 47				ld b,a 
20c8			 
20c8 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
20cb 7e				ld a,(hl) 
20cc 23				inc hl 
20cd 22 40 ea			ld (cli_ptr), hl		; move to next char 
20d0 cd 3b 12			call toUpper 		; make sure the input string matches case 
20d3			 
20d3			if DEBUG_FORTH_PARSE 
20d3			endif 
20d3			 
20d3				; input stream end of token is a space so get rid of it 
20d3			 
20d3			;	cp ' ' 
20d3			;	jr nz, .pnskipspace 
20d3			; 
20d3			;	ld a, 0		; make same term as word token term 
20d3			; 
20d3			;.pnskipspace: 
20d3			 
20d3			if DEBUG_FORTH_PARSE_KEY 
20d3						DMARK "KY7" 
20d3			endif 
20d3 b8				cp b 
20d4 c2 ea 20			jp nz, .execpnskipword	 ; no match so move to next word 
20d7				 
20d7			;    if same 
20d7			;       scan for string terms 0 for token and 32 for input 
20d7			 
20d7				 
20d7			if DEBUG_FORTH_PARSE_KEY 
20d7						DMARK "KY8" 
20d7			endif 
20d7			 
20d7 80				add b			 
20d8 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
20da							; TODO need to make sure last word in zero term string is accounted for 
20da 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
20dc			 
20dc			 
20dc				; at end of both strings so both are exact match 
20dc			 
20dc			;       skip ptr for next word 
20dc			 
20dc 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
20df 23				inc hl			 ; at next char 
20e0 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
20e3 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
20e6				 
20e6				 
20e6			if DEBUG_FORTH_PARSE_KEY 
20e6						DMARK "KY3" 
20e6			endif 
20e6			 
20e6			 
20e6			 
20e6			;       exec code block 
20e6			if DEBUG_FORTH_JP 
20e6				call clear_display 
20e6				call update_display 
20e6				call delay1s 
20e6				ld hl, (cli_execword)     ; save for next check if no match on this word 
20e6				ld a,h 
20e6				ld hl, os_word_scratch 
20e6				call hexout 
20e6				ld hl, (cli_execword)     ; save for next check if no match on this word 
20e6				ld a,l 
20e6				ld hl, os_word_scratch+2 
20e6				call hexout 
20e6				ld hl, os_word_scratch+4 
20e6				ld a,0 
20e6				ld (hl),a 
20e6				ld de,os_word_scratch 
20e6				call str_at_display 
20e6					ld a, display_row_2 
20e6					call str_at_display 
20e6				ld de, (cli_origtoken) 
20e6				ld a, display_row_1+10 
20e6					call str_at_display 
20e6			 
20e6				ld a,display_row_1 
20e6				ld de, .foundword 
20e6				ld a, display_row_3 
20e6				call str_at_display 
20e6				call update_display 
20e6				call delay1s 
20e6				call delay1s 
20e6				call delay1s 
20e6			endif 
20e6			 
20e6			if DEBUG_FORTH_PARSE_KEY 
20e6						DMARK "KYj" 
20e6			endif 
20e6				; TODO save the word pointer in this exec 
20e6			 
20e6 2a 44 ea			ld hl,(cli_execword) 
20e9 e9				jp (hl) 
20ea			 
20ea			 
20ea			;    if not same 
20ea			;	scan for zero term 
20ea			;	get ptr for next word 
20ea			;	goto word comp 
20ea			 
20ea			.execpnskipword:	; get pointer to next word 
20ea 2a 42 ea			ld hl,(cli_nextword) 
20ed			 
20ed 7e				ld a,(hl) 
20ee fe 00			cp WORD_SYS_END 
20f0			;	cp 0 
20f0 28 09			jr z, .execendofdict			 ; at end of words 
20f2			 
20f2			if DEBUG_FORTH_PARSE_KEY 
20f2						DMARK "KY4" 
20f2			endif 
20f2			if DEBUG_FORTH_PARSE_EXEC 
20f2			 
20f2				; see if disabled 
20f2			 
20f2			;	ld a, (os_view_disable) 
20f2			;	cp '*' 
20f2				ld a,(debug_vector) 
20f2				cp $c9   ; RET 
20f2				jr z, .noskip 
20f2			 
20f2			 
20f2				ld de, .nowordfound 
20f2				ld a, display_row_3 
20f2				call str_at_display 
20f2				call update_display 
20f2				ld a, 100 
20f2				call aDelayInMS 
20f2				 
20f2				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20f2					call delay250ms 
20f2				endif 
20f2			.noskip:  
20f2			 
20f2			endif	 
20f2			 
20f2 2a 3e ea			ld hl,(cli_origptr) 
20f5 22 40 ea			ld (cli_ptr),hl 
20f8			 
20f8			if DEBUG_FORTH_PARSE_KEY 
20f8						DMARK "KY5" 
20f8			endif 
20f8 c3 9e 20			jp .execpnword			; else go to next word 
20fb			 
20fb			.execendofdict:  
20fb			 
20fb			if DEBUG_FORTH_PARSE_KEY 
20fb						DMARK "KYe" 
20fb			endif 
20fb			if DEBUG_FORTH_PARSE_EXEC 
20fb				; see if disabled 
20fb			 
20fb			;	ld a, (os_view_disable) 
20fb			;	cp '*' 
20fb				ld a,(debug_vector) 
20fb				cp $c9   ; ret 
20fb				jr z, .ispskip 
20fb			 
20fb				call clear_display 
20fb				call update_display 
20fb				call delay1s 
20fb				ld de, (cli_origptr) 
20fb				ld a, display_row_1 
20fb				call str_at_display 
20fb				 
20fb				ld de, .enddict 
20fb				ld a, display_row_3 
20fb				call str_at_display 
20fb				call update_display 
20fb				ld a, 100 
20fb				call aDelayInMS 
20fb				if DEBUG_FORTH_PARSE_EXEC_SLOW 
20fb				call delay1s 
20fb				call delay1s 
20fb				call delay1s 
20fb				endif 
20fb			.ispskip:  
20fb				 
20fb			endif	 
20fb			 
20fb			 
20fb			 
20fb				; if the word is not a keyword then must be a literal so push it to stack 
20fb			 
20fb			; push token to stack to end of word 
20fb			 
20fb				STACKFRAME ON $1efe $2f9f 
20fb				if DEBUG_STACK_IMB 
20fb					if ON 
20fb						exx 
20fb						ld de, $1efe 
20fb						ld a, d 
20fb						ld hl, curframe 
20fb						call hexout 
20fb						ld a, e 
20fb						ld hl, curframe+2 
20fb						call hexout 
20fb						ld hl, $1efe 
20fb						push hl 
20fb						ld hl, $2f9f 
20fb						push hl 
20fb						exx 
20fb					endif 
20fb				endif 
20fb			endm 
# End of macro STACKFRAME
20fb			 
20fb 2a c2 e5		ld hl,(os_tok_ptr) 
20fe cd af 1d		call forth_apush 
2101			 
2101				STACKFRAMECHK ON $1efe $2f9f 
2101				if DEBUG_STACK_IMB 
2101					if ON 
2101						exx 
2101						ld hl, $2f9f 
2101						pop de   ; $2f9f 
2101						call cmp16 
2101						jr nz, .spnosame 
2101						ld hl, $1efe 
2101						pop de   ; $1efe 
2101						call cmp16 
2101						jr z, .spfrsame 
2101						.spnosame: call showsperror 
2101						.spfrsame: nop 
2101						exx 
2101					endif 
2101				endif 
2101			endm 
# End of macro STACKFRAMECHK
2101			 
2101			execnext: 
2101			 
2101			if DEBUG_FORTH_PARSE_KEY 
2101						DMARK "KY>" 
2101			endif 
2101			; move past token to next word 
2101			 
2101 2a c2 e5		ld hl, (os_tok_ptr) 
2104 3e 00		ld a, 0 
2106 01 ff 00		ld bc, 255     ; input buffer size 
2109 ed b1		cpir 
210b			 
210b			if DEBUG_FORTH_PARSE_KEY 
210b						DMARK "KY!" 
210b				CALLMONITOR 
210b			endif	 
210b			; TODO this might place hl on the null, so will need to forward on??? 
210b			;inc hl   ; see if this gets onto the next item 
210b			 
210b			 
210b			; TODO pass a pointer to the buffer to push 
210b			; TODO call function to push 
210b			 
210b			; look for end of input 
210b			 
210b			;inc hl 
210b			;ld a,(hl) 
210b			;cp FORTH_END_BUFFER 
210b			;ret z 
210b			 
210b			 
210b c3 84 20		jp exec1 
210e			 
210e			 
210e			 
210e			 
210e			 
210e			 
210e			 
210e			 
210e			 
210e			findnexttok: 
210e			 
210e				; hl is pointer to move 
210e				; de is the token to locate 
210e			 
210e					if DEBUG_FORTH 
210e						DMARK "NTK" 
210e						CALLMONITOR 
210e					endif 
210e d5				push de 
210f			 
210f			.fnt1:	 
210f				; find first char of token to locate 
210f			 
210f 1a				ld a, (de) 
2110 4f				ld c,a 
2111 7e				ld a,(hl) 
2112 cd 3b 12			call toUpper 
2115					if DEBUG_FORTH 
2115						DMARK "NT1" 
2115						CALLMONITOR 
2115					endif 
2115 b9				cp c 
2116			 
2116 28 03			jr z, .fnt2cmpmorefirst	 
2118			 
2118				; first char not found move to next char 
2118			 
2118 23				inc hl 
2119 18 f4			jr .fnt1 
211b			 
211b			.fnt2cmpmorefirst:	 
211b				; first char of token found.  
211b			 
211b e5				push hl     ; save start of token just in case it is the right one 
211c d9				exx 
211d e1				pop hl        ; save it to hl' 
211e d9				exx 
211f			 
211f			 
211f			.fnt2cmpmore:	 
211f				; compare the rest 
211f				 
211f 23				inc hl 
2120 13				inc de 
2121				 
2121 1a				ld a, (de) 
2122 4f				ld c,a 
2123 7e				ld a,(hl) 
2124 cd 3b 12			call toUpper 
2127			 
2127					if DEBUG_FORTH 
2127						DMARK "NT2" 
2127						CALLMONITOR 
2127					endif 
2127				; c has the token to find char 
2127				; a has the mem to scan char 
2127			 
2127 b9				cp c 
2128 28 04			jr z,.fntmatch1 
212a			 
212a				; they are not the same 
212a			 
212a					if DEBUG_FORTH 
212a						DMARK "NT3" 
212a						CALLMONITOR 
212a					endif 
212a d1				pop de	; reset de token to look for 
212b d5				push de 
212c 18 e1			jr .fnt1 
212e				 
212e			.fntmatch1: 
212e			 
212e				; is the same char a null which means we might have a full hit? 
212e					if DEBUG_FORTH 
212e						DMARK "NT4" 
212e						CALLMONITOR 
212e					endif 
212e			 
212e fe 00			cp 0 
2130 28 0b			jr z, .fntmatchyes 
2132			 
2132				; are we at the end of the token to find? 
2132			 
2132					if DEBUG_FORTH 
2132						DMARK "NT5" 
2132						CALLMONITOR 
2132					endif 
2132 3e 00			ld a, 0 
2134 b9				cp c 
2135			 
2135 c2 1f 21			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2138			 
2138					if DEBUG_FORTH 
2138						DMARK "NT6" 
2138						CALLMONITOR 
2138					endif 
2138				; token to find is exhusted but no match to stream 
2138			 
2138				; restore tok pointer and continue on 
2138 d1				pop de 
2139 d5				push de 
213a c3 0f 21			jp .fnt1 
213d			 
213d			 
213d			.fntmatchyes: 
213d			 
213d				; hl now contains the end of the found token 
213d			 
213d				; get rid of saved token pointer to find 
213d			 
213d d1				pop de 
213e			 
213e					if DEBUG_FORTH 
213e						DMARK "NT9" 
213e						CALLMONITOR 
213e					endif 
213e			 
213e				; hl will be on the null term so forward on 
213e			 
213e				; get back the saved start of the token 
213e			 
213e d9				exx 
213f e5				push hl     ; save start of token just in case it is the right one 
2140 d9				exx 
2141 e1				pop hl        ; save it to hl 
2142			 
2142 c9				ret 
2143			 
2143			 
2143			; LIST needs to find a specific token   
2143			; FORGET needs to find a spefici token 
2143			 
2143			; SAVE needs to find all tokens by flag 
2143			; WORDS just needs to scan through all  by flag 
2143			; UWORDS needs to scan through all by flag 
2143			 
2143			 
2143			; given hl as pointer to start of dict look up string 
2143			; return hl as pointer to start of word block 
2143			; or 0 if not found 
2143			 
2143			forth_find_tok: 
2143 c9				ret 
2144			 
2144			; given hl as pointer to dict structure 
2144			; move to the next dict block structure 
2144			 
2144			forth_tok_next: 
2144				; hl now points to the address of the next word pointer  
2144				; TODO skip compiled symbol for now 
2144			;	push de 
2144 23				inc hl 
2145 5e				ld e, (hl) 
2146 23				inc hl 
2147 56				ld d, (hl) 
2148 23				inc hl 
2149			 
2149 eb				ex de,hl 
214a			if DEBUG_FORTH_PARSE_NEXTWORD 
214a				push bc 
214a				ld bc, (cli_nextword) 
214a						DMARK "NXW" 
214a				CALLMONITOR 
214a				pop bc 
214a			endif 
214a			;	pop de	 
214a c9				ret 
214b			 
214b			 
214b			 
214b			; eof 
# End of file forth_parserv5.asm
214b				include "forth_wordsv4.asm" 
214b			 
214b			; the core word dictionary v4 
214b			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
214b			 
214b			; this is a linked list for each of the system words used 
214b			; user defined words will follow the same format but will be in ram 
214b			 
214b			 
214b			; 
214b			; 
214b			; define linked list: 
214b			; 
214b			; 1. compiled byte op code 
214b			; 2. len of text word 
214b			; 3. text word 
214b			; 4. ptr to next dictionary word 
214b			; 5. asm, calls etc for the word 
214b			; 
214b			;  if 1 == 0 then last word in dict  
214b			;   
214b			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
214b			;  
214b			;  
214b			; create basic standard set of words 
214b			; 
214b			;  
214b			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
214b			; 2DUP 2DROP 2SWAP  
214b			; @ C@ - get byte  
214b			; ! C! - store byte 
214b			; 0< true if less than zero 
214b			; 0= true if zero 
214b			; < >  
214b			; = true if same 
214b			; variables 
214b			 
214b			 
214b			; Hardware specific words I may need 
214b			; 
214b			; IN OUT  
214b			; calls to key util functions 
214b			; calls to hardward abstraction stuff 
214b			; easy control of frame buffers and lcd i/o 
214b			; keyboard  
214b			 
214b			 
214b			;DICT: macro 
214b			; op_code, len, word, next 
214b			;    word: 
214b			;    db op_code 
214b			;    ds word zero term 
214b			;    dw next 
214b			;    endm 
214b			 
214b			 
214b			 
214b			 
214b			; op code 1 is a flag for user define words which are to be handled differently 
214b			 
214b			 
214b			; 
214b			; 
214b			;    TODO on entry to a word this should be the expected environment 
214b			;    hl - tos value if number then held, if string this is the ptr 
214b			;    de -  
214b			 
214b			 
214b			; opcode ranges 
214b			; 0 - end of word dict 
214b			; 255 - user define words 
214b			 
214b			sysdict: 
214b			include "forth_opcodes.asm" 
214b			; op codes for forth keywords 
214b			; free to use code 0  
214b				OPCODE_HEAP: equ  1 
214b				OPCODE_EXEC: equ 2 
214b				OPCODE_DUP: equ 3 
214b				OPCODE_SWAP: equ 4 
214b				OPCODE_COLN: equ 5 
214b				OPCODE_SCOLN: equ 6 
214b				OPCODE_DROP: equ 7 
214b				OPCODE_DUP2: equ 8 
214b				OPCODE_DROP2: equ 9 
214b				OPCODE_SWAP2: equ 10 
214b				OPCODE_AT: equ 11 
214b				OPCODE_CAT: equ 12 
214b				OPCODE_BANG: equ 13 
214b				OPCODE_CBANG: equ 14 
214b				OPCODE_SCALL: equ 15 
214b				OPCODE_DEPTH: equ 16 
214b				OPCODE_OVER: equ 17 
214b				OPCODE_PAUSE: equ 18 
214b				OPCODE_PAUSES: equ 19 
214b				OPCODE_ROT: equ 20 
214b			;free to reuse	OPCODE_WORDS: equ 21 
214b			        OPCODE_NOT: equ 21 
214b				OPCODE_UWORDS: equ 22 
214b				OPCODE_BP: equ 23 
214b				OPCODE_MONITOR: equ 24  
214b				OPCODE_MALLOC: equ 25 
214b				OPCODE_FREE: equ 26 
214b				OPCODE_LIST: equ 27 
214b				OPCODE_FORGET: equ 28 
214b				OPCODE_NOP: equ 29 
214b				OPCODE_COMO: equ 30 
214b				OPCODE_COMC: equ 31 
214b			;free to reuse	OPCODE_ENDCORE: equ 32 
214b				OPCODE_AFTERSOUND: equ 33 
214b				OPCODE_GP2: equ 34 
214b				OPCODE_GP3: equ 35 
214b				OPCODE_GP4: equ 36 
214b				OPCODE_SIN: equ 37 
214b				OPCODE_SOUT: equ 38 
214b				OPCODE_SPIO: equ 39 
214b				OPCODE_SPICEH: equ 40 
214b				OPCODE_SPIOb: equ 41 
214b				OPCODE_SPII: equ 42 
214b				OPCODE_SESEL: equ 43 
214b				OPCODE_CARTDEV: equ 44 
214b			; free to reuse	OPCODE_ENDDEVICE: equ 45 
214b				OPCODE_FB: equ 46 
214b				OPCODE_EMIT: equ 47 
214b				OPCODE_DOTH: equ 48 
214b				OPCODE_DOTF: equ 49 
214b				OPCODE_DOT: equ 50 
214b				OPCODE_CLS: equ 51 
214b				OPCODE_DRAW: equ 52 
214b				OPCODE_DUMP: equ 53 
214b				OPCODE_CDUMP: equ 54 
214b				OPCODE_DAT: equ 55 
214b				OPCODE_HOME: equ 56 
214b				OPCODE_SPACE: equ 57 
214b				OPCODE_SPACES: equ 58 
214b				OPCODE_SCROLL: equ 59 
214b				OPCODE_ATQ: equ 60 
214b				OPCODE_AUTODSP: equ 61 
214b				OPCODE_MENU: equ 62 
214b			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
214b				OPCODE_THEN: equ 64 
214b				OPCODE_ELSE: equ 65 
214b				OPCODE_DO: equ 66 
214b				OPCODE_LOOP: equ 67 
214b				OPCODE_I: equ 68 
214b				OPCODE_DLOOP: equ 69  
214b				OPCODE_REPEAT: equ 70  
214b				OPCODE_UNTIL: equ 71 
214b				OPCODE_ENDFLOW: equ 72 
214b				OPCODE_WAITK: equ 73 
214b				OPCODE_ACCEPT: equ 74 
214b				OPCODE_EDIT: equ 75 
214b			;free to reuse	OPCODE_ENDKEY: equ 76 
214b				OPCODE_LZERO: equ 77 
214b				OPCODE_TZERO: equ 78 
214b				OPCODE_LESS: equ 79 
214b				OPCODE_GT: equ 80 
214b				OPCODE_EQUAL: equ 81  
214b			;free to reuse	OPCODE_ENDLOGIC: equ 82 
214b				OPCODE_NEG: equ 83 
214b				OPCODE_DIV: equ 84 
214b				OPCODE_MUL: equ 85 
214b				OPCODE_MIN: equ 86 
214b				OPCODE_MAX: equ 87 
214b				OPCODE_RND16: equ 88 
214b				OPCODE_RND8: equ 89 
214b				OPCODE_RND: equ 90 
214b			;free to reuse	OPCODE_ENDMATHS: equ 91  
214b				OPCODE_BYNAME: equ 92 
214b				OPCODE_DIR: equ 93 
214b				OPCODE_SAVE: equ 94 
214b				OPCODE_LOAD: equ 95 
214b				OPCODE_BSAVE: equ 96 
214b				OPCODE_BLOAD: equ 97 
214b				OPCODE_SEO: equ 98  
214b				OPCODE_SEI: equ 99 
214b				OPCODE_SFREE: equ 100 
214b				OPCODE_SIZE: equ 101 
214b				OPCODE_CREATE: equ 102 
214b				OPCODE_APPEND: equ 103 
214b				OPCODE_SDEL: equ 104 
214b				OPCODE_OPEN: equ 105 
214b				OPCODE_READ: equ 106 
214b				OPCODE_EOF: equ 106 
214b				OPCODE_FORMAT: equ 107 
214b				OPCODE_LABEL: equ 108 
214b				OPCODE_LABELS: equ 109 
214b			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
214b				OPCODE_UPPER: equ 111 
214b				OPCODE_LOWER: equ 112 
214b				OPCODE_SUBSTR: equ 113 
214b				OPCODE_LEFT: equ 114 
214b				OPCODE_RIGHT: equ 115 
214b				OPCODE_STR2NUM: equ 116 
214b				OPCODE_NUM2STR: equ 117 
214b				OPCODE_CONCAT: equ 118 
214b				OPCODE_FIND: equ 119 
214b				OPCODE_LEN: equ 120 
214b				OPCODE_CHAR: equ 121 
214b			; free to reuse	OPCODE_STRLEN: equ 122 
214b			; free to reuse	OPCODE_ENDSTR: equ 123 
214b				OPCODE_V0S: equ 124 
214b				OPCODE_V0Q: equ 125 
214b				OPCODE_V1S: equ 126 
214b				OPCODE_V1Q: equ 127 
214b				OPCODE_V2S: equ 128 
214b				OPCODE_V2Q: equ 129 
214b				OPCODE_V3S: equ 130 
214b				OPCODE_V3Q: equ 131 
214b			;free to reuse	OPCODE_END: equ 132 
214b				OPCODE_ZDUP: equ 133 
214b			 
214b			; eof 
# End of file forth_opcodes.asm
214b			 
214b			include "forth_words_core.asm" 
214b			 
214b			; | ## Core Words 
214b			 
214b			;if MALLOC_4 
214b			 
214b			.HEAP: 
214b			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
214b 15				db WORD_SYS_CORE+OPCODE_HEAP             
214c 8a 21			dw .EXEC            
214e 05				db 4 + 1 
214f .. 00			db "HEAP",0              
2154				endm 
# End of macro CWHEAD
2154			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2154			; | | u1 - Current number of bytes in the heap 
2154			; | | u2 - Remaining bytes left on the heap 
2154			; | |  
2154			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2154			 
2154			 
2154				if DEBUG_FORTH_WORDS_KEY 
2154					DMARK "HEP" 
2154 f5				push af  
2155 3a 69 21			ld a, (.dmark)  
2158 32 6b ee			ld (debug_mark),a  
215b 3a 6a 21			ld a, (.dmark+1)  
215e 32 6c ee			ld (debug_mark+1),a  
2161 3a 6b 21			ld a, (.dmark+2)  
2164 32 6d ee			ld (debug_mark+2),a  
2167 18 03			jr .pastdmark  
2169 ..			.dmark: db "HEP"  
216c f1			.pastdmark: pop af  
216d			endm  
# End of macro DMARK
216d					CALLMONITOR 
216d cd 6f ee			call debug_vector  
2170				endm  
# End of macro CALLMONITOR
2170				endif 
2170 2a de 65			ld hl, (free_list )      
2173 11 e3 65			ld de, heap_start 
2176			 
2176 ed 52			sbc hl, de  
2178			 
2178 cd 46 1c			call forth_push_numhl 
217b			 
217b			 
217b ed 5b de 65		ld de, (free_list )      
217f 21 9c e2			ld hl, heap_end 
2182			 
2182 ed 52			sbc hl, de 
2184			 
2184 cd 46 1c			call forth_push_numhl 
2187				 
2187			 
2187				 
2187			 
2187			 
2187			 
2187				NEXTW 
2187 c3 f3 1f			jp macro_next 
218a				endm 
# End of macro NEXTW
218a			;endif 
218a			 
218a			.EXEC: 
218a			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
218a			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
218a			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
218a			;; > > 
218a			;; > >   
218a			;	STACKFRAME OFF $5efe $5f9f 
218a			; 
218a			;		if DEBUG_FORTH_WORDS_KEY 
218a			;			DMARK "EXE" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			; 
218a			;	FORTH_DSP_VALUEHL 
218a			; 
218a			;	FORTH_DSP_POP 
218a			; 
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EX1" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			;;	ld e,(hl) 
218a			;;	inc hl 
218a			;;	ld d,(hl) 
218a			;;	ex de,hl 
218a			; 
218a			;;		if DEBUG_FORTH_WORDS 
218a			;;			DMARK "EX2" 
218a			;;			CALLMONITOR 
218a			;;		endif 
218a			;	push hl 
218a			; 
218a			;	;ld a, 0 
218a			;	;ld a, FORTH_END_BUFFER 
218a			;	call strlenz 
218a			;	inc hl   ; include zero term to copy 
218a			;	inc hl   ; include term 
218a			;	inc hl   ; include term 
218a			;	ld b,0 
218a			;	ld c,l 
218a			;	pop hl 
218a			;	ld de, execscratch 
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EX3" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			;	ldir 
218a			; 
218a			; 
218a			;	ld hl, execscratch 
218a			; 
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EXe" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			; 
218a			;	call forthparse 
218a			;	call forthexec 
218a			;;	call forthexec_cleanup 
218a			;;	call forthparse 
218a			;;	call forthexec 
218a			; 
218a			;	STACKFRAMECHK OFF $5efe $5f9f 
218a			; 
218a			;	; an immediate word so no need to process any more words 
218a			;	ret 
218a			;	NEXTW 
218a			 
218a			; dead code - old version  
218a			;	FORTH_RSP_NEXT 
218a			 
218a			;  
218a			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
218a			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
218a			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
218a			;	push hl 
218a			;	push de 
218a			;	push bc 
218a			; 
218a			; 
218a			;		if DEBUG_FORTH_WORDS_KEY 
218a			;			DMARK "EXR" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			; 
218a			; 
218a			; 
218a			;	;v5 FORTH_DSP_VALUE 
218a			;	FORTH_DSP_VALUEHL 
218a			; 
218a			;	; TODO do string type checks 
218a			; 
218a			;;v5	inc hl   ; skip type 
218a			; 
218a			;	push hl  ; source code  
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EX1" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			;	ld a, 0 
218a			;	call strlent 
218a			; 
218a			;	inc hl 
218a			;	inc hl 
218a			;	inc hl 
218a			;	inc hl 
218a			; 
218a			;	push hl    ; size 
218a			; 
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EX2" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			;	call malloc 
218a			; 
218a			;	ex de, hl    ; de now contains malloc area 
218a			;	pop bc   	; get byte count 
218a			;	pop hl      ; get string to copy 
218a			; 
218a			;	push de     ; save malloc for free later 
218a			; 
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EX3" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			;	ldir       ; duplicate string 
218a			; 
218a			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
218a			;	 
218a			;	; TODO fix the parse would be better than this...  
218a			;	ex de, hl 
218a			;	dec hl 
218a			;	ld a, 0 
218a			;	ld (hl), a 
218a			;	dec hl 
218a			;	ld a, ' ' 
218a			;	ld (hl), a 
218a			;	dec hl 
218a			;	ld (hl), a 
218a			; 
218a			;	dec hl 
218a			;	ld (hl), a 
218a			; 
218a			; 
218a			;	FORTH_DSP_POP  
218a			; 
218a			;	pop hl     
218a			;	push hl    ; save malloc area 
218a			; 
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EX4" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			; 
218a			;	call forthparse 
218a			;	call forthexec 
218a			;	 
218a			;	pop hl 
218a			;	if DEBUG_FORTH_WORDS 
218a			;		DMARK "EX5" 
218a			;		CALLMONITOR 
218a			;	endif 
218a			; 
218a			;	if FORTH_ENABLE_FREE 
218a			;	call free 
218a			;	endif 
218a			; 
218a			;	if DEBUG_FORTH_WORDS 
218a			;		DMARK "EX6" 
218a			;		CALLMONITOR 
218a			;	endif 
218a			; 
218a			;	pop bc 
218a			;	pop de 
218a			;	pop hl 
218a			;;	FORTH_RSP_POP	  
218a			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
218a			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
218a			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
218a			; 
218a			;	if DEBUG_FORTH_WORDS 
218a			;		DMARK "EX7" 
218a			;		CALLMONITOR 
218a			;	endif 
218a			;	NEXTW 
218a			 
218a			;.STKEXEC: 
218a			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
218a			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
218a			; 
218a			; 
218a			;		if DEBUG_FORTH_WORDS_KEY 
218a			;			DMARK "STX" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			; 
218a			;	FORTH_DSP_VALUEHL 
218a			; 
218a			;	ld (store_tmp1), hl    ; count 
218a			; 
218a			;	FORTH_DSP_POP 
218a			;.stkexec1: 
218a			;	ld hl, (store_tmp1)   ; count 
218a			;	ld a, 0 
218a			;	cp l 
218a			;	ret z 
218a			; 
218a			;	dec hl 
218a			;	ld (store_tmp1), hl    ; count 
218a			;	 
218a			;	FORTH_DSP_VALUEHL 
218a			;	push hl 
218a			;	 
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EXp" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			;	FORTH_DSP_POP 
218a			; 
218a			;	call strlenz 
218a			;	inc hl   ; include zero term to copy 
218a			;	inc hl   ; include zero term to copy 
218a			;	inc hl   ; include zero term to copy 
218a			;	ld b,0 
218a			;	ld c,l 
218a			;	pop hl 
218a			;	ld de, execscratch 
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EX3" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			;	ldir 
218a			; 
218a			; 
218a			;	ld hl, execscratch 
218a			; 
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EXP" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			; 
218a			;	call forthparse 
218a			;	ld hl, execscratch 
218a			;		if DEBUG_FORTH_WORDS 
218a			;			DMARK "EXx" 
218a			;			CALLMONITOR 
218a			;		endif 
218a			;	call forthexec 
218a			; 
218a			;	jp .stkexec1 
218a			; 
218a			;	ret 
218a			 
218a			 
218a			.DUP: 
218a			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
218a 17				db WORD_SYS_CORE+OPCODE_DUP             
218b 00 22			dw .ZDUP            
218d 04				db 3 + 1 
218e .. 00			db "DUP",0              
2192				endm 
# End of macro CWHEAD
2192			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2192			 
2192				if DEBUG_FORTH_WORDS_KEY 
2192					DMARK "DUP" 
2192 f5				push af  
2193 3a a7 21			ld a, (.dmark)  
2196 32 6b ee			ld (debug_mark),a  
2199 3a a8 21			ld a, (.dmark+1)  
219c 32 6c ee			ld (debug_mark+1),a  
219f 3a a9 21			ld a, (.dmark+2)  
21a2 32 6d ee			ld (debug_mark+2),a  
21a5 18 03			jr .pastdmark  
21a7 ..			.dmark: db "DUP"  
21aa f1			.pastdmark: pop af  
21ab			endm  
# End of macro DMARK
21ab					CALLMONITOR 
21ab cd 6f ee			call debug_vector  
21ae				endm  
# End of macro CALLMONITOR
21ae				endif 
21ae			 
21ae				FORTH_DSP 
21ae cd 03 1e			call macro_forth_dsp 
21b1				endm 
# End of macro FORTH_DSP
21b1			 
21b1 7e				ld a, (HL) 
21b2 fe 01			cp DS_TYPE_STR 
21b4 20 25			jr nz, .dupinum 
21b6			 
21b6				; push another string 
21b6			 
21b6				FORTH_DSP_VALUEHL     		 
21b6 cd 3d 1e			call macro_dsp_valuehl 
21b9				endm 
# End of macro FORTH_DSP_VALUEHL
21b9			 
21b9			if DEBUG_FORTH_WORDS 
21b9				DMARK "DUs" 
21b9 f5				push af  
21ba 3a ce 21			ld a, (.dmark)  
21bd 32 6b ee			ld (debug_mark),a  
21c0 3a cf 21			ld a, (.dmark+1)  
21c3 32 6c ee			ld (debug_mark+1),a  
21c6 3a d0 21			ld a, (.dmark+2)  
21c9 32 6d ee			ld (debug_mark+2),a  
21cc 18 03			jr .pastdmark  
21ce ..			.dmark: db "DUs"  
21d1 f1			.pastdmark: pop af  
21d2			endm  
# End of macro DMARK
21d2				CALLMONITOR 
21d2 cd 6f ee			call debug_vector  
21d5				endm  
# End of macro CALLMONITOR
21d5			endif 
21d5 cd b4 1c			call forth_push_str 
21d8			 
21d8				NEXTW 
21d8 c3 f3 1f			jp macro_next 
21db				endm 
# End of macro NEXTW
21db			 
21db			 
21db			.dupinum: 
21db				 
21db			 
21db			 
21db				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
21db cd 3d 1e			call macro_dsp_valuehl 
21de				endm 
# End of macro FORTH_DSP_VALUEHL
21de			 
21de			; TODO add floating point number detection 
21de			 
21de			if DEBUG_FORTH_WORDS 
21de				DMARK "DUi" 
21de f5				push af  
21df 3a f3 21			ld a, (.dmark)  
21e2 32 6b ee			ld (debug_mark),a  
21e5 3a f4 21			ld a, (.dmark+1)  
21e8 32 6c ee			ld (debug_mark+1),a  
21eb 3a f5 21			ld a, (.dmark+2)  
21ee 32 6d ee			ld (debug_mark+2),a  
21f1 18 03			jr .pastdmark  
21f3 ..			.dmark: db "DUi"  
21f6 f1			.pastdmark: pop af  
21f7			endm  
# End of macro DMARK
21f7				CALLMONITOR 
21f7 cd 6f ee			call debug_vector  
21fa				endm  
# End of macro CALLMONITOR
21fa			endif 
21fa			 
21fa cd 46 1c			call forth_push_numhl 
21fd				NEXTW 
21fd c3 f3 1f			jp macro_next 
2200				endm 
# End of macro NEXTW
2200			.ZDUP: 
2200			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2200 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2201 38 22			dw .SWAP            
2203 05				db 4 + 1 
2204 .. 00			db "?DUP",0              
2209				endm 
# End of macro CWHEAD
2209			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2209			 
2209				if DEBUG_FORTH_WORDS_KEY 
2209					DMARK "qDU" 
2209 f5				push af  
220a 3a 1e 22			ld a, (.dmark)  
220d 32 6b ee			ld (debug_mark),a  
2210 3a 1f 22			ld a, (.dmark+1)  
2213 32 6c ee			ld (debug_mark+1),a  
2216 3a 20 22			ld a, (.dmark+2)  
2219 32 6d ee			ld (debug_mark+2),a  
221c 18 03			jr .pastdmark  
221e ..			.dmark: db "qDU"  
2221 f1			.pastdmark: pop af  
2222			endm  
# End of macro DMARK
2222					CALLMONITOR 
2222 cd 6f ee			call debug_vector  
2225				endm  
# End of macro CALLMONITOR
2225				endif 
2225				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2225 cd 3d 1e			call macro_dsp_valuehl 
2228				endm 
# End of macro FORTH_DSP_VALUEHL
2228			 
2228 e5				push hl 
2229			 
2229				; is it a zero? 
2229			 
2229 3e 00			ld a, 0 
222b 84				add h 
222c 85				add l 
222d			 
222d e1				pop hl 
222e			 
222e fe 00			cp 0 
2230 28 03			jr z, .dup2orig 
2232			 
2232			 
2232 cd 46 1c			call forth_push_numhl 
2235			 
2235			 
2235			; TODO add floating point number detection 
2235			 
2235			.dup2orig: 
2235			 
2235				NEXTW 
2235 c3 f3 1f			jp macro_next 
2238				endm 
# End of macro NEXTW
2238			.SWAP: 
2238			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
2238 18				db WORD_SYS_CORE+OPCODE_SWAP             
2239 77 22			dw .COLN            
223b 05				db 4 + 1 
223c .. 00			db "SWAP",0              
2241				endm 
# End of macro CWHEAD
2241			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2241				if DEBUG_FORTH_WORDS_KEY 
2241					DMARK "SWP" 
2241 f5				push af  
2242 3a 56 22			ld a, (.dmark)  
2245 32 6b ee			ld (debug_mark),a  
2248 3a 57 22			ld a, (.dmark+1)  
224b 32 6c ee			ld (debug_mark+1),a  
224e 3a 58 22			ld a, (.dmark+2)  
2251 32 6d ee			ld (debug_mark+2),a  
2254 18 03			jr .pastdmark  
2256 ..			.dmark: db "SWP"  
2259 f1			.pastdmark: pop af  
225a			endm  
# End of macro DMARK
225a					CALLMONITOR 
225a cd 6f ee			call debug_vector  
225d				endm  
# End of macro CALLMONITOR
225d				endif 
225d			 
225d			; TODO Use os stack swap memory 
225d				FORTH_DSP_VALUEHL 
225d cd 3d 1e			call macro_dsp_valuehl 
2260				endm 
# End of macro FORTH_DSP_VALUEHL
2260 e5				push hl     ; w2 
2261			 
2261				FORTH_DSP_POP 
2261 cd f5 1e			call macro_forth_dsp_pop 
2264				endm 
# End of macro FORTH_DSP_POP
2264			 
2264				FORTH_DSP_VALUEHL 
2264 cd 3d 1e			call macro_dsp_valuehl 
2267				endm 
# End of macro FORTH_DSP_VALUEHL
2267			 
2267				FORTH_DSP_POP 
2267 cd f5 1e			call macro_forth_dsp_pop 
226a				endm 
# End of macro FORTH_DSP_POP
226a			 
226a d1				pop de     ; w2	, hl = w1 
226b			 
226b eb				ex de, hl 
226c d5				push de 
226d			 
226d cd 46 1c			call forth_push_numhl 
2270			 
2270 e1				pop hl 
2271			 
2271 cd 46 1c			call forth_push_numhl 
2274				 
2274			 
2274				NEXTW 
2274 c3 f3 1f			jp macro_next 
2277				endm 
# End of macro NEXTW
2277			.COLN: 
2277			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2277 19				db WORD_SYS_CORE+OPCODE_COLN             
2278 03 24			dw .SCOLN            
227a 02				db 1 + 1 
227b .. 00			db ":",0              
227d				endm 
# End of macro CWHEAD
227d			; | : ( -- )         Create new word | DONE 
227d			 
227d				if DEBUG_FORTH_WORDS_KEY 
227d					DMARK "CLN" 
227d f5				push af  
227e 3a 92 22			ld a, (.dmark)  
2281 32 6b ee			ld (debug_mark),a  
2284 3a 93 22			ld a, (.dmark+1)  
2287 32 6c ee			ld (debug_mark+1),a  
228a 3a 94 22			ld a, (.dmark+2)  
228d 32 6d ee			ld (debug_mark+2),a  
2290 18 03			jr .pastdmark  
2292 ..			.dmark: db "CLN"  
2295 f1			.pastdmark: pop af  
2296			endm  
# End of macro DMARK
2296					CALLMONITOR 
2296 cd 6f ee			call debug_vector  
2299				endm  
# End of macro CALLMONITOR
2299				endif 
2299			STACKFRAME OFF $8efe $989f 
2299				if DEBUG_STACK_IMB 
2299					if OFF 
2299						exx 
2299						ld de, $8efe 
2299						ld a, d 
2299						ld hl, curframe 
2299						call hexout 
2299						ld a, e 
2299						ld hl, curframe+2 
2299						call hexout 
2299						ld hl, $8efe 
2299						push hl 
2299						ld hl, $989f 
2299						push hl 
2299						exx 
2299					endif 
2299				endif 
2299			endm 
# End of macro STACKFRAME
2299			; get parser buffer length  of new word 
2299			 
2299			 
2299			 
2299				; move tok past this to start of name defintition 
2299				; TODO get word to define 
2299				; TODO Move past word token 
2299				; TODO get length of string up to the ';' 
2299			 
2299 2a c2 e5		ld hl, (os_tok_ptr) 
229c 23			inc hl 
229d 23			inc hl 
229e			 
229e 3e 3b		ld a, ';' 
22a0 cd 4f 12		call strlent 
22a3			 
22a3 7d			ld a,l 
22a4 32 b1 e2		ld (os_new_parse_len), a 
22a7			 
22a7			 
22a7			if DEBUG_FORTH_UWORD 
22a7 ed 5b c2 e5	ld de, (os_tok_ptr) 
22ab					DMARK ":01" 
22ab f5				push af  
22ac 3a c0 22			ld a, (.dmark)  
22af 32 6b ee			ld (debug_mark),a  
22b2 3a c1 22			ld a, (.dmark+1)  
22b5 32 6c ee			ld (debug_mark+1),a  
22b8 3a c2 22			ld a, (.dmark+2)  
22bb 32 6d ee			ld (debug_mark+2),a  
22be 18 03			jr .pastdmark  
22c0 ..			.dmark: db ":01"  
22c3 f1			.pastdmark: pop af  
22c4			endm  
# End of macro DMARK
22c4			CALLMONITOR 
22c4 cd 6f ee			call debug_vector  
22c7				endm  
# End of macro CALLMONITOR
22c7			endif 
22c7			 
22c7			; 
22c7			;  new word memory layout: 
22c7			;  
22c7			;    : adg 6666 ;  
22c7			; 
22c7			;    db   1     ; user defined word  
22c7 23			inc hl    
22c8			;    dw   sysdict 
22c8 23			inc hl 
22c9 23			inc hl 
22ca			;    db <word len>+1 (for null) 
22ca 23			inc hl 
22cb			;    db .... <word> 
22cb			; 
22cb			 
22cb 23			inc hl    ; some extras for the word preamble before the above 
22cc 23			inc hl 
22cd 23			inc hl 
22ce 23			inc hl 
22cf 23			inc hl 
22d0 23			inc hl 
22d1 23			inc hl  
22d2 23			inc hl 
22d3 23			inc hl 
22d4 23			inc hl 
22d5 23			inc hl 
22d6 23			inc hl 
22d7 23			inc hl 
22d8 23			inc hl     ; TODO how many do we really need?     maybe only 6 
22d9			;       exec word buffer 
22d9			;	<ptr word>   
22d9 23			inc hl 
22da 23			inc hl 
22db			;       <word list><null term> 7F final term 
22db			 
22db			 
22db			if DEBUG_FORTH_UWORD 
22db					DMARK ":02" 
22db f5				push af  
22dc 3a f0 22			ld a, (.dmark)  
22df 32 6b ee			ld (debug_mark),a  
22e2 3a f1 22			ld a, (.dmark+1)  
22e5 32 6c ee			ld (debug_mark+1),a  
22e8 3a f2 22			ld a, (.dmark+2)  
22eb 32 6d ee			ld (debug_mark+2),a  
22ee 18 03			jr .pastdmark  
22f0 ..			.dmark: db ":02"  
22f3 f1			.pastdmark: pop af  
22f4			endm  
# End of macro DMARK
22f4			CALLMONITOR 
22f4 cd 6f ee			call debug_vector  
22f7				endm  
# End of macro CALLMONITOR
22f7			endif 
22f7			 
22f7			 
22f7				; malloc the size 
22f7			 
22f7 cd ad 12			call malloc 
22fa 22 b3 e2			ld (os_new_malloc), hl     ; save malloc start 
22fd			 
22fd			;    db   1     ; user defined word  
22fd 3e 01			ld a, WORD_SYS_UWORD  
22ff 77				ld (hl), a 
2300			 
2300 23			inc hl    
2301			;    dw   sysdict 
2301 11 4b 21		ld de, sysdict       ; continue on with the scan to the system dict 
2304 73			ld (hl), e 
2305 23			inc hl 
2306 72			ld (hl), d 
2307 23			inc hl 
2308			 
2308			 
2308			;    Setup dict word 
2308			 
2308 23			inc hl 
2309 22 ad e2		ld (os_new_work_ptr), hl     ; save start of dict word  
230c			 
230c			; 1. get length of dict word 
230c			 
230c			 
230c 2a c2 e5		ld hl, (os_tok_ptr) 
230f 23			inc hl 
2310 23			inc hl    ; position to start of dict word 
2311 3e 00		ld a, 0 
2313 cd 4f 12		call strlent 
2316			 
2316			 
2316 23			inc hl    ; to include null??? 
2317			 
2317			; write length of dict word 
2317			 
2317 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
231b 1b			dec de 
231c eb			ex de, hl 
231d 73			ld (hl), e 
231e eb			ex de, hl 
231f			 
231f			 
231f			 
231f			; copy  
231f 4d			ld c, l 
2320 06 00		ld b, 0 
2322 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2326 2a c2 e5		ld hl, (os_tok_ptr) 
2329 23			inc hl 
232a 23			inc hl    ; position to start of dict word 
232b			 
232b			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
232b			 
232b			; TODO need to convert word to upper case 
232b			 
232b			ucasetok:	 
232b 7e			ld a,(hl) 
232c cd 3b 12		call toUpper 
232f 77			ld (hl),a 
2330 ed a0		ldi 
2332 f2 2b 23		jp p, ucasetok 
2335			 
2335			 
2335			 
2335			; de now points to start of where the word body code should be placed 
2335 ed 53 ad e2	ld (os_new_work_ptr), de 
2339			; hl now points to the words to throw at forthexec which needs to be copied 
2339 22 ab e2		ld (os_new_src_ptr), hl 
233c			 
233c			; TODO add 'call to forthexec' 
233c			 
233c			if DEBUG_FORTH_UWORD 
233c c5			push bc 
233d ed 4b b3 e2	ld bc, (os_new_malloc) 
2341					DMARK ":0x" 
2341 f5				push af  
2342 3a 56 23			ld a, (.dmark)  
2345 32 6b ee			ld (debug_mark),a  
2348 3a 57 23			ld a, (.dmark+1)  
234b 32 6c ee			ld (debug_mark+1),a  
234e 3a 58 23			ld a, (.dmark+2)  
2351 32 6d ee			ld (debug_mark+2),a  
2354 18 03			jr .pastdmark  
2356 ..			.dmark: db ":0x"  
2359 f1			.pastdmark: pop af  
235a			endm  
# End of macro DMARK
235a			CALLMONITOR 
235a cd 6f ee			call debug_vector  
235d				endm  
# End of macro CALLMONITOR
235d c1			pop bc 
235e			endif 
235e			 
235e			 
235e			; create word preamble which should be: 
235e			 
235e			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
235e			 
235e			;    ld hl, <word code> 
235e			;    jp user_exec 
235e			;    <word code bytes> 
235e			 
235e			 
235e			;	inc de     ; TODO ??? or are we already past the word's null 
235e eb			ex de, hl 
235f			 
235f 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2361			 
2361 23			inc hl 
2362 22 a7 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2365 23			inc hl 
2366			 
2366 23			inc hl 
2367 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
2369			 
2369 01 a4 4c		ld bc, user_exec 
236c 23			inc hl 
236d 71			ld (hl), c     ; poke address of user_exec 
236e 23			inc hl 
236f 70			ld (hl), b     
2370			; 
2370			;	inc hl 
2370			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2370			; 
2370			; 
2370			;	ld bc, macro_forth_rsp_next 
2370			;	inc hl 
2370			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2370			;	inc hl 
2370			;	ld (hl), b     
2370			; 
2370			;	inc hl 
2370			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2370			; 
2370			; 
2370			;	inc hl 
2370			;	ld bc, forthexec 
2370			;	ld (hl), c     ; poke address of forthexec 
2370			;	inc hl 
2370			;	ld (hl), b      
2370			; 
2370			;	inc hl 
2370			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2370			; 
2370			;	ld bc, user_dict_next 
2370			;	inc hl 
2370			;	ld (hl), c     ; poke address of forthexec 
2370			;	inc hl 
2370			;	ld (hl), b      
2370			 
2370			; hl is now where we need to copy the word byte data to save this 
2370			 
2370 23			inc hl 
2371 22 a9 e2		ld (os_new_exec), hl 
2374			 
2374			; copy definition 
2374			 
2374 eb			ex de, hl 
2375			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2375			;	inc de    ; skip the PC for this parse 
2375 3a b1 e2		ld a, (os_new_parse_len) 
2378 4f			ld c, a 
2379 06 00		ld b, 0 
237b ed b0		ldir		 ; copy defintion 
237d			 
237d			 
237d			; poke the address of where the new word bytes live for forthexec 
237d			 
237d 2a a7 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2380			 
2380 ed 5b a9 e2	ld de, (os_new_exec)      
2384			 
2384 73			ld (hl), e 
2385 23			inc hl 
2386 72			ld (hl), d 
2387			 
2387				; TODO copy last user dict word next link to this word 
2387				; TODO update last user dict word to point to this word 
2387			; 
2387			; hl f923 de 812a ; bc 811a 
2387			 
2387			if DEBUG_FORTH_UWORD 
2387 c5			push bc 
2388 ed 4b b3 e2	ld bc, (os_new_malloc) 
238c					DMARK ":0A" 
238c f5				push af  
238d 3a a1 23			ld a, (.dmark)  
2390 32 6b ee			ld (debug_mark),a  
2393 3a a2 23			ld a, (.dmark+1)  
2396 32 6c ee			ld (debug_mark+1),a  
2399 3a a3 23			ld a, (.dmark+2)  
239c 32 6d ee			ld (debug_mark+2),a  
239f 18 03			jr .pastdmark  
23a1 ..			.dmark: db ":0A"  
23a4 f1			.pastdmark: pop af  
23a5			endm  
# End of macro DMARK
23a5			CALLMONITOR 
23a5 cd 6f ee			call debug_vector  
23a8				endm  
# End of macro CALLMONITOR
23a8 c1			pop bc 
23a9			endif 
23a9			if DEBUG_FORTH_UWORD 
23a9 c5			push bc 
23aa ed 4b b3 e2	ld bc, (os_new_malloc) 
23ae 03			inc bc 
23af 03			inc bc 
23b0 03			inc bc 
23b1 03			inc bc 
23b2 03			inc bc 
23b3 03			inc bc 
23b4 03			inc bc 
23b5 03			inc bc 
23b6			 
23b6					DMARK ":0B" 
23b6 f5				push af  
23b7 3a cb 23			ld a, (.dmark)  
23ba 32 6b ee			ld (debug_mark),a  
23bd 3a cc 23			ld a, (.dmark+1)  
23c0 32 6c ee			ld (debug_mark+1),a  
23c3 3a cd 23			ld a, (.dmark+2)  
23c6 32 6d ee			ld (debug_mark+2),a  
23c9 18 03			jr .pastdmark  
23cb ..			.dmark: db ":0B"  
23ce f1			.pastdmark: pop af  
23cf			endm  
# End of macro DMARK
23cf			CALLMONITOR 
23cf cd 6f ee			call debug_vector  
23d2				endm  
# End of macro CALLMONITOR
23d2 c1			pop bc 
23d3			endif 
23d3			 
23d3			; update word dict linked list for new word 
23d3			 
23d3			 
23d3 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
23d6 23			inc hl     ; move to next work linked list ptr 
23d7			 
23d7 ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
23db 73			ld (hl), e 
23dc 23			inc hl 
23dd 72			ld (hl), d 
23de			 
23de			if DEBUG_FORTH_UWORD 
23de ed 4b be e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
23e2			endif 
23e2			 
23e2 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
23e6			 
23e6			 
23e6			if DEBUG_FORTH_UWORD 
23e6					DMARK ":0+" 
23e6 f5				push af  
23e7 3a fb 23			ld a, (.dmark)  
23ea 32 6b ee			ld (debug_mark),a  
23ed 3a fc 23			ld a, (.dmark+1)  
23f0 32 6c ee			ld (debug_mark+1),a  
23f3 3a fd 23			ld a, (.dmark+2)  
23f6 32 6d ee			ld (debug_mark+2),a  
23f9 18 03			jr .pastdmark  
23fb ..			.dmark: db ":0+"  
23fe f1			.pastdmark: pop af  
23ff			endm  
# End of macro DMARK
23ff			CALLMONITOR 
23ff cd 6f ee			call debug_vector  
2402				endm  
# End of macro CALLMONITOR
2402			endif 
2402			 
2402			STACKFRAMECHK OFF $8efe $989f 
2402				if DEBUG_STACK_IMB 
2402					if OFF 
2402						exx 
2402						ld hl, $989f 
2402						pop de   ; $989f 
2402						call cmp16 
2402						jr nz, .spnosame 
2402						ld hl, $8efe 
2402						pop de   ; $8efe 
2402						call cmp16 
2402						jr z, .spfrsame 
2402						.spnosame: call showsperror 
2402						.spfrsame: nop 
2402						exx 
2402					endif 
2402				endif 
2402			endm 
# End of macro STACKFRAMECHK
2402			 
2402 c9			ret    ; dont process any remaining parser tokens as they form new word 
2403			 
2403			 
2403			 
2403			 
2403			;		NEXT 
2403			.SCOLN: 
2403			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2403 06			db OPCODE_SCOLN 
2404 4f 24		dw .DROP 
2406 02			db 2 
2407 .. 00		db ";",0           
2409			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2409				if DEBUG_FORTH_WORDS_KEY 
2409					DMARK "SCN" 
2409 f5				push af  
240a 3a 1e 24			ld a, (.dmark)  
240d 32 6b ee			ld (debug_mark),a  
2410 3a 1f 24			ld a, (.dmark+1)  
2413 32 6c ee			ld (debug_mark+1),a  
2416 3a 20 24			ld a, (.dmark+2)  
2419 32 6d ee			ld (debug_mark+2),a  
241c 18 03			jr .pastdmark  
241e ..			.dmark: db "SCN"  
2421 f1			.pastdmark: pop af  
2422			endm  
# End of macro DMARK
2422					CALLMONITOR 
2422 cd 6f ee			call debug_vector  
2425				endm  
# End of macro CALLMONITOR
2425				endif 
2425				FORTH_RSP_TOS 
2425 cd 04 1c			call macro_forth_rsp_tos 
2428				endm 
# End of macro FORTH_RSP_TOS
2428 e5				push hl 
2429				FORTH_RSP_POP 
2429 cd 0e 1c			call macro_forth_rsp_pop 
242c				endm 
# End of macro FORTH_RSP_POP
242c e1				pop hl 
242d			;		ex de,hl 
242d 22 c2 e5			ld (os_tok_ptr),hl 
2430			 
2430			if DEBUG_FORTH_UWORD 
2430					DMARK "SCL" 
2430 f5				push af  
2431 3a 45 24			ld a, (.dmark)  
2434 32 6b ee			ld (debug_mark),a  
2437 3a 46 24			ld a, (.dmark+1)  
243a 32 6c ee			ld (debug_mark+1),a  
243d 3a 47 24			ld a, (.dmark+2)  
2440 32 6d ee			ld (debug_mark+2),a  
2443 18 03			jr .pastdmark  
2445 ..			.dmark: db "SCL"  
2448 f1			.pastdmark: pop af  
2449			endm  
# End of macro DMARK
2449			CALLMONITOR 
2449 cd 6f ee			call debug_vector  
244c				endm  
# End of macro CALLMONITOR
244c			endif 
244c				NEXTW 
244c c3 f3 1f			jp macro_next 
244f				endm 
# End of macro NEXTW
244f			 
244f			.DROP: 
244f			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
244f 1b				db WORD_SYS_CORE+OPCODE_DROP             
2450 7a 24			dw .DUP2            
2452 05				db 4 + 1 
2453 .. 00			db "DROP",0              
2458				endm 
# End of macro CWHEAD
2458			; | DROP ( w -- )   drop the TOS item   | DONE 
2458				if DEBUG_FORTH_WORDS_KEY 
2458					DMARK "DRP" 
2458 f5				push af  
2459 3a 6d 24			ld a, (.dmark)  
245c 32 6b ee			ld (debug_mark),a  
245f 3a 6e 24			ld a, (.dmark+1)  
2462 32 6c ee			ld (debug_mark+1),a  
2465 3a 6f 24			ld a, (.dmark+2)  
2468 32 6d ee			ld (debug_mark+2),a  
246b 18 03			jr .pastdmark  
246d ..			.dmark: db "DRP"  
2470 f1			.pastdmark: pop af  
2471			endm  
# End of macro DMARK
2471					CALLMONITOR 
2471 cd 6f ee			call debug_vector  
2474				endm  
# End of macro CALLMONITOR
2474				endif 
2474				FORTH_DSP_POP 
2474 cd f5 1e			call macro_forth_dsp_pop 
2477				endm 
# End of macro FORTH_DSP_POP
2477				NEXTW 
2477 c3 f3 1f			jp macro_next 
247a				endm 
# End of macro NEXTW
247a			.DUP2: 
247a			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
247a 1c				db WORD_SYS_CORE+OPCODE_DUP2             
247b bf 24			dw .DROP2            
247d 05				db 4 + 1 
247e .. 00			db "2DUP",0              
2483				endm 
# End of macro CWHEAD
2483			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2483				if DEBUG_FORTH_WORDS_KEY 
2483					DMARK "2DU" 
2483 f5				push af  
2484 3a 98 24			ld a, (.dmark)  
2487 32 6b ee			ld (debug_mark),a  
248a 3a 99 24			ld a, (.dmark+1)  
248d 32 6c ee			ld (debug_mark+1),a  
2490 3a 9a 24			ld a, (.dmark+2)  
2493 32 6d ee			ld (debug_mark+2),a  
2496 18 03			jr .pastdmark  
2498 ..			.dmark: db "2DU"  
249b f1			.pastdmark: pop af  
249c			endm  
# End of macro DMARK
249c					CALLMONITOR 
249c cd 6f ee			call debug_vector  
249f				endm  
# End of macro CALLMONITOR
249f				endif 
249f				FORTH_DSP_VALUEHL 
249f cd 3d 1e			call macro_dsp_valuehl 
24a2				endm 
# End of macro FORTH_DSP_VALUEHL
24a2 e5				push hl      ; 2 
24a3			 
24a3				FORTH_DSP_POP 
24a3 cd f5 1e			call macro_forth_dsp_pop 
24a6				endm 
# End of macro FORTH_DSP_POP
24a6				 
24a6				FORTH_DSP_VALUEHL 
24a6 cd 3d 1e			call macro_dsp_valuehl 
24a9				endm 
# End of macro FORTH_DSP_VALUEHL
24a9			;		push hl      ; 1 
24a9			 
24a9				FORTH_DSP_POP 
24a9 cd f5 1e			call macro_forth_dsp_pop 
24ac				endm 
# End of macro FORTH_DSP_POP
24ac			 
24ac			;		pop hl       ; 1 
24ac d1				pop de       ; 2 
24ad			 
24ad cd 46 1c			call forth_push_numhl 
24b0 eb				ex de, hl 
24b1 cd 46 1c			call forth_push_numhl 
24b4			 
24b4				 
24b4 eb				ex de, hl 
24b5			 
24b5 cd 46 1c			call forth_push_numhl 
24b8 eb				ex de, hl 
24b9 cd 46 1c			call forth_push_numhl 
24bc			 
24bc			 
24bc				NEXTW 
24bc c3 f3 1f			jp macro_next 
24bf				endm 
# End of macro NEXTW
24bf			.DROP2: 
24bf			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
24bf 1d				db WORD_SYS_CORE+OPCODE_DROP2             
24c0 ee 24			dw .SWAP2            
24c2 06				db 5 + 1 
24c3 .. 00			db "2DROP",0              
24c9				endm 
# End of macro CWHEAD
24c9			; | 2DROP ( w w -- )    Double drop | DONE 
24c9				if DEBUG_FORTH_WORDS_KEY 
24c9					DMARK "2DR" 
24c9 f5				push af  
24ca 3a de 24			ld a, (.dmark)  
24cd 32 6b ee			ld (debug_mark),a  
24d0 3a df 24			ld a, (.dmark+1)  
24d3 32 6c ee			ld (debug_mark+1),a  
24d6 3a e0 24			ld a, (.dmark+2)  
24d9 32 6d ee			ld (debug_mark+2),a  
24dc 18 03			jr .pastdmark  
24de ..			.dmark: db "2DR"  
24e1 f1			.pastdmark: pop af  
24e2			endm  
# End of macro DMARK
24e2					CALLMONITOR 
24e2 cd 6f ee			call debug_vector  
24e5				endm  
# End of macro CALLMONITOR
24e5				endif 
24e5				FORTH_DSP_POP 
24e5 cd f5 1e			call macro_forth_dsp_pop 
24e8				endm 
# End of macro FORTH_DSP_POP
24e8				FORTH_DSP_POP 
24e8 cd f5 1e			call macro_forth_dsp_pop 
24eb				endm 
# End of macro FORTH_DSP_POP
24eb				NEXTW 
24eb c3 f3 1f			jp macro_next 
24ee				endm 
# End of macro NEXTW
24ee			.SWAP2: 
24ee			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
24ee 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
24ef 17 25			dw .AT            
24f1 06				db 5 + 1 
24f2 .. 00			db "2SWAP",0              
24f8				endm 
# End of macro CWHEAD
24f8			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
24f8				if DEBUG_FORTH_WORDS_KEY 
24f8					DMARK "2SW" 
24f8 f5				push af  
24f9 3a 0d 25			ld a, (.dmark)  
24fc 32 6b ee			ld (debug_mark),a  
24ff 3a 0e 25			ld a, (.dmark+1)  
2502 32 6c ee			ld (debug_mark+1),a  
2505 3a 0f 25			ld a, (.dmark+2)  
2508 32 6d ee			ld (debug_mark+2),a  
250b 18 03			jr .pastdmark  
250d ..			.dmark: db "2SW"  
2510 f1			.pastdmark: pop af  
2511			endm  
# End of macro DMARK
2511					CALLMONITOR 
2511 cd 6f ee			call debug_vector  
2514				endm  
# End of macro CALLMONITOR
2514				endif 
2514			; TODO Use os stack swap memory 
2514				NEXTW 
2514 c3 f3 1f			jp macro_next 
2517				endm 
# End of macro NEXTW
2517			.AT: 
2517			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2517 1f				db WORD_SYS_CORE+OPCODE_AT             
2518 49 25			dw .CAT            
251a 02				db 1 + 1 
251b .. 00			db "@",0              
251d				endm 
# End of macro CWHEAD
251d			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
251d			 
251d				if DEBUG_FORTH_WORDS_KEY 
251d					DMARK "AT." 
251d f5				push af  
251e 3a 32 25			ld a, (.dmark)  
2521 32 6b ee			ld (debug_mark),a  
2524 3a 33 25			ld a, (.dmark+1)  
2527 32 6c ee			ld (debug_mark+1),a  
252a 3a 34 25			ld a, (.dmark+2)  
252d 32 6d ee			ld (debug_mark+2),a  
2530 18 03			jr .pastdmark  
2532 ..			.dmark: db "AT."  
2535 f1			.pastdmark: pop af  
2536			endm  
# End of macro DMARK
2536					CALLMONITOR 
2536 cd 6f ee			call debug_vector  
2539				endm  
# End of macro CALLMONITOR
2539				endif 
2539			.getbyteat:	 
2539				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2539 cd 3d 1e			call macro_dsp_valuehl 
253c				endm 
# End of macro FORTH_DSP_VALUEHL
253c				 
253c			;		push hl 
253c			 
253c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
253c cd f5 1e			call macro_forth_dsp_pop 
253f				endm 
# End of macro FORTH_DSP_POP
253f			 
253f			;		pop hl 
253f			 
253f 7e				ld a, (hl) 
2540			 
2540 6f				ld l, a 
2541 26 00			ld h, 0 
2543 cd 46 1c			call forth_push_numhl 
2546			 
2546				NEXTW 
2546 c3 f3 1f			jp macro_next 
2549				endm 
# End of macro NEXTW
2549			.CAT: 
2549			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2549 20				db WORD_SYS_CORE+OPCODE_CAT             
254a 72 25			dw .BANG            
254c 03				db 2 + 1 
254d .. 00			db "C@",0              
2550				endm 
# End of macro CWHEAD
2550			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2550				if DEBUG_FORTH_WORDS_KEY 
2550					DMARK "CAA" 
2550 f5				push af  
2551 3a 65 25			ld a, (.dmark)  
2554 32 6b ee			ld (debug_mark),a  
2557 3a 66 25			ld a, (.dmark+1)  
255a 32 6c ee			ld (debug_mark+1),a  
255d 3a 67 25			ld a, (.dmark+2)  
2560 32 6d ee			ld (debug_mark+2),a  
2563 18 03			jr .pastdmark  
2565 ..			.dmark: db "CAA"  
2568 f1			.pastdmark: pop af  
2569			endm  
# End of macro DMARK
2569					CALLMONITOR 
2569 cd 6f ee			call debug_vector  
256c				endm  
# End of macro CALLMONITOR
256c				endif 
256c c3 39 25			jp .getbyteat 
256f				NEXTW 
256f c3 f3 1f			jp macro_next 
2572				endm 
# End of macro NEXTW
2572			.BANG: 
2572			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2572 21				db WORD_SYS_CORE+OPCODE_BANG             
2573 a8 25			dw .CBANG            
2575 02				db 1 + 1 
2576 .. 00			db "!",0              
2578				endm 
# End of macro CWHEAD
2578			; | ! ( x w -- ) Store x at address w      | DONE 
2578				if DEBUG_FORTH_WORDS_KEY 
2578					DMARK "BNG" 
2578 f5				push af  
2579 3a 8d 25			ld a, (.dmark)  
257c 32 6b ee			ld (debug_mark),a  
257f 3a 8e 25			ld a, (.dmark+1)  
2582 32 6c ee			ld (debug_mark+1),a  
2585 3a 8f 25			ld a, (.dmark+2)  
2588 32 6d ee			ld (debug_mark+2),a  
258b 18 03			jr .pastdmark  
258d ..			.dmark: db "BNG"  
2590 f1			.pastdmark: pop af  
2591			endm  
# End of macro DMARK
2591					CALLMONITOR 
2591 cd 6f ee			call debug_vector  
2594				endm  
# End of macro CALLMONITOR
2594				endif 
2594			 
2594			.storebyteat:		 
2594				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2594 cd 3d 1e			call macro_dsp_valuehl 
2597				endm 
# End of macro FORTH_DSP_VALUEHL
2597				 
2597 e5				push hl 
2598			 
2598				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2598 cd f5 1e			call macro_forth_dsp_pop 
259b				endm 
# End of macro FORTH_DSP_POP
259b			 
259b				; get byte to poke 
259b			 
259b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
259b cd 3d 1e			call macro_dsp_valuehl 
259e				endm 
# End of macro FORTH_DSP_VALUEHL
259e e5				push hl 
259f			 
259f			 
259f				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
259f cd f5 1e			call macro_forth_dsp_pop 
25a2				endm 
# End of macro FORTH_DSP_POP
25a2			 
25a2			 
25a2 d1				pop de 
25a3 e1				pop hl 
25a4			 
25a4 73				ld (hl),e 
25a5			 
25a5			 
25a5				NEXTW 
25a5 c3 f3 1f			jp macro_next 
25a8				endm 
# End of macro NEXTW
25a8			.CBANG: 
25a8			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
25a8 22				db WORD_SYS_CORE+OPCODE_CBANG             
25a9 d1 25			dw .SCALL            
25ab 03				db 2 + 1 
25ac .. 00			db "C!",0              
25af				endm 
# End of macro CWHEAD
25af			; | C!  ( x w -- ) Store x at address w  | DONE 
25af				if DEBUG_FORTH_WORDS_KEY 
25af					DMARK "CBA" 
25af f5				push af  
25b0 3a c4 25			ld a, (.dmark)  
25b3 32 6b ee			ld (debug_mark),a  
25b6 3a c5 25			ld a, (.dmark+1)  
25b9 32 6c ee			ld (debug_mark+1),a  
25bc 3a c6 25			ld a, (.dmark+2)  
25bf 32 6d ee			ld (debug_mark+2),a  
25c2 18 03			jr .pastdmark  
25c4 ..			.dmark: db "CBA"  
25c7 f1			.pastdmark: pop af  
25c8			endm  
# End of macro DMARK
25c8					CALLMONITOR 
25c8 cd 6f ee			call debug_vector  
25cb				endm  
# End of macro CALLMONITOR
25cb				endif 
25cb c3 94 25			jp .storebyteat 
25ce				NEXTW 
25ce c3 f3 1f			jp macro_next 
25d1				endm 
# End of macro NEXTW
25d1			.SCALL: 
25d1			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
25d1 23				db WORD_SYS_CORE+OPCODE_SCALL             
25d2 05 26			dw .DEPTH            
25d4 05				db 4 + 1 
25d5 .. 00			db "CALL",0              
25da				endm 
# End of macro CWHEAD
25da			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
25da				if DEBUG_FORTH_WORDS_KEY 
25da					DMARK "CLL" 
25da f5				push af  
25db 3a ef 25			ld a, (.dmark)  
25de 32 6b ee			ld (debug_mark),a  
25e1 3a f0 25			ld a, (.dmark+1)  
25e4 32 6c ee			ld (debug_mark+1),a  
25e7 3a f1 25			ld a, (.dmark+2)  
25ea 32 6d ee			ld (debug_mark+2),a  
25ed 18 03			jr .pastdmark  
25ef ..			.dmark: db "CLL"  
25f2 f1			.pastdmark: pop af  
25f3			endm  
# End of macro DMARK
25f3					CALLMONITOR 
25f3 cd 6f ee			call debug_vector  
25f6				endm  
# End of macro CALLMONITOR
25f6				endif 
25f6			 
25f6				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25f6 cd 3d 1e			call macro_dsp_valuehl 
25f9				endm 
# End of macro FORTH_DSP_VALUEHL
25f9			 
25f9			;		push hl 
25f9			 
25f9				; destroy value TOS 
25f9			 
25f9				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25f9 cd f5 1e			call macro_forth_dsp_pop 
25fc				endm 
# End of macro FORTH_DSP_POP
25fc			 
25fc					 
25fc			;		pop hl 
25fc			 
25fc				; how to do a call with hl???? save SP? 
25fc cd 97 1f			call forth_call_hl 
25ff			 
25ff			 
25ff				; TODO push value back onto stack for another op etc 
25ff			 
25ff cd 46 1c			call forth_push_numhl 
2602				NEXTW 
2602 c3 f3 1f			jp macro_next 
2605				endm 
# End of macro NEXTW
2605			.DEPTH: 
2605			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2605 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2606 42 26			dw .OVER            
2608 06				db 5 + 1 
2609 .. 00			db "DEPTH",0              
260f				endm 
# End of macro CWHEAD
260f			; | DEPTH ( -- u ) Push count of stack | DONE 
260f				; take current TOS and remove from base value div by two to get count 
260f				if DEBUG_FORTH_WORDS_KEY 
260f					DMARK "DEP" 
260f f5				push af  
2610 3a 24 26			ld a, (.dmark)  
2613 32 6b ee			ld (debug_mark),a  
2616 3a 25 26			ld a, (.dmark+1)  
2619 32 6c ee			ld (debug_mark+1),a  
261c 3a 26 26			ld a, (.dmark+2)  
261f 32 6d ee			ld (debug_mark+2),a  
2622 18 03			jr .pastdmark  
2624 ..			.dmark: db "DEP"  
2627 f1			.pastdmark: pop af  
2628			endm  
# End of macro DMARK
2628					CALLMONITOR 
2628 cd 6f ee			call debug_vector  
262b				endm  
# End of macro CALLMONITOR
262b				endif 
262b			 
262b			 
262b 2a ee e9		ld hl, (cli_data_sp) 
262e 11 28 e8		ld de, cli_data_stack 
2631 ed 52		sbc hl,de 
2633			 
2633			; div by size of stack item 
2633			 
2633 5d			ld e,l 
2634 0e 03		ld c, 3 
2636 cd 76 0d		call Div8 
2639			 
2639 6f			ld l,a 
263a 26 00		ld h,0 
263c			 
263c			;srl h 
263c			;rr l 
263c			 
263c cd 46 1c			call forth_push_numhl 
263f				NEXTW 
263f c3 f3 1f			jp macro_next 
2642				endm 
# End of macro NEXTW
2642			.OVER: 
2642			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2642 42				db WORD_SYS_CORE+46             
2643 89 26			dw .PAUSE            
2645 05				db 4 + 1 
2646 .. 00			db "OVER",0              
264b				endm 
# End of macro CWHEAD
264b			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
264b				if DEBUG_FORTH_WORDS_KEY 
264b					DMARK "OVR" 
264b f5				push af  
264c 3a 60 26			ld a, (.dmark)  
264f 32 6b ee			ld (debug_mark),a  
2652 3a 61 26			ld a, (.dmark+1)  
2655 32 6c ee			ld (debug_mark+1),a  
2658 3a 62 26			ld a, (.dmark+2)  
265b 32 6d ee			ld (debug_mark+2),a  
265e 18 03			jr .pastdmark  
2660 ..			.dmark: db "OVR"  
2663 f1			.pastdmark: pop af  
2664			endm  
# End of macro DMARK
2664					CALLMONITOR 
2664 cd 6f ee			call debug_vector  
2667				endm  
# End of macro CALLMONITOR
2667				endif 
2667			 
2667			; TODO Use os stack swap memory 
2667				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2667 cd 3d 1e			call macro_dsp_valuehl 
266a				endm 
# End of macro FORTH_DSP_VALUEHL
266a e5				push hl    ; n2 
266b				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
266b cd f5 1e			call macro_forth_dsp_pop 
266e				endm 
# End of macro FORTH_DSP_POP
266e			 
266e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
266e cd 3d 1e			call macro_dsp_valuehl 
2671				endm 
# End of macro FORTH_DSP_VALUEHL
2671 e5				push hl    ; n1 
2672				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2672 cd f5 1e			call macro_forth_dsp_pop 
2675				endm 
# End of macro FORTH_DSP_POP
2675			 
2675 d1				pop de     ; n1 
2676 e1				pop hl     ; n2 
2677			 
2677 d5				push de 
2678 e5				push hl 
2679 d5				push de 
267a			 
267a				; push back  
267a			 
267a e1				pop hl 
267b cd 46 1c			call forth_push_numhl 
267e e1				pop hl 
267f cd 46 1c			call forth_push_numhl 
2682 e1				pop hl 
2683 cd 46 1c			call forth_push_numhl 
2686				NEXTW 
2686 c3 f3 1f			jp macro_next 
2689				endm 
# End of macro NEXTW
2689			 
2689			.PAUSE: 
2689			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2689 43				db WORD_SYS_CORE+47             
268a be 26			dw .PAUSES            
268c 08				db 7 + 1 
268d .. 00			db "PAUSEMS",0              
2695				endm 
# End of macro CWHEAD
2695			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2695				if DEBUG_FORTH_WORDS_KEY 
2695					DMARK "PMS" 
2695 f5				push af  
2696 3a aa 26			ld a, (.dmark)  
2699 32 6b ee			ld (debug_mark),a  
269c 3a ab 26			ld a, (.dmark+1)  
269f 32 6c ee			ld (debug_mark+1),a  
26a2 3a ac 26			ld a, (.dmark+2)  
26a5 32 6d ee			ld (debug_mark+2),a  
26a8 18 03			jr .pastdmark  
26aa ..			.dmark: db "PMS"  
26ad f1			.pastdmark: pop af  
26ae			endm  
# End of macro DMARK
26ae					CALLMONITOR 
26ae cd 6f ee			call debug_vector  
26b1				endm  
# End of macro CALLMONITOR
26b1				endif 
26b1				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26b1 cd 3d 1e			call macro_dsp_valuehl 
26b4				endm 
# End of macro FORTH_DSP_VALUEHL
26b4			;		push hl    ; n2 
26b4				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26b4 cd f5 1e			call macro_forth_dsp_pop 
26b7				endm 
# End of macro FORTH_DSP_POP
26b7			;		pop hl 
26b7			 
26b7 7d				ld a, l 
26b8 cd d6 0a			call aDelayInMS 
26bb			       NEXTW 
26bb c3 f3 1f			jp macro_next 
26be				endm 
# End of macro NEXTW
26be			.PAUSES:  
26be			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
26be 44				db WORD_SYS_CORE+48             
26bf 2d 27			dw .ROT            
26c1 06				db 5 + 1 
26c2 .. 00			db "PAUSE",0              
26c8				endm 
# End of macro CWHEAD
26c8			; | PAUSE ( n -- )  Pause for n seconds | DONE 
26c8				if DEBUG_FORTH_WORDS_KEY 
26c8					DMARK "PAU" 
26c8 f5				push af  
26c9 3a dd 26			ld a, (.dmark)  
26cc 32 6b ee			ld (debug_mark),a  
26cf 3a de 26			ld a, (.dmark+1)  
26d2 32 6c ee			ld (debug_mark+1),a  
26d5 3a df 26			ld a, (.dmark+2)  
26d8 32 6d ee			ld (debug_mark+2),a  
26db 18 03			jr .pastdmark  
26dd ..			.dmark: db "PAU"  
26e0 f1			.pastdmark: pop af  
26e1			endm  
# End of macro DMARK
26e1					CALLMONITOR 
26e1 cd 6f ee			call debug_vector  
26e4				endm  
# End of macro CALLMONITOR
26e4				endif 
26e4				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26e4 cd 3d 1e			call macro_dsp_valuehl 
26e7				endm 
# End of macro FORTH_DSP_VALUEHL
26e7			;		push hl    ; n2 
26e7				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26e7 cd f5 1e			call macro_forth_dsp_pop 
26ea				endm 
# End of macro FORTH_DSP_POP
26ea			;		pop hl 
26ea 45				ld b, l 
26eb				if DEBUG_FORTH_WORDS 
26eb					DMARK "PAU" 
26eb f5				push af  
26ec 3a 00 27			ld a, (.dmark)  
26ef 32 6b ee			ld (debug_mark),a  
26f2 3a 01 27			ld a, (.dmark+1)  
26f5 32 6c ee			ld (debug_mark+1),a  
26f8 3a 02 27			ld a, (.dmark+2)  
26fb 32 6d ee			ld (debug_mark+2),a  
26fe 18 03			jr .pastdmark  
2700 ..			.dmark: db "PAU"  
2703 f1			.pastdmark: pop af  
2704			endm  
# End of macro DMARK
2704					CALLMONITOR 
2704 cd 6f ee			call debug_vector  
2707				endm  
# End of macro CALLMONITOR
2707				endif 
2707 c5			.pauses1:	push bc 
2708 cd f1 0a			call delay1s 
270b c1				pop bc 
270c				if DEBUG_FORTH_WORDS 
270c					DMARK "PA1" 
270c f5				push af  
270d 3a 21 27			ld a, (.dmark)  
2710 32 6b ee			ld (debug_mark),a  
2713 3a 22 27			ld a, (.dmark+1)  
2716 32 6c ee			ld (debug_mark+1),a  
2719 3a 23 27			ld a, (.dmark+2)  
271c 32 6d ee			ld (debug_mark+2),a  
271f 18 03			jr .pastdmark  
2721 ..			.dmark: db "PA1"  
2724 f1			.pastdmark: pop af  
2725			endm  
# End of macro DMARK
2725					CALLMONITOR 
2725 cd 6f ee			call debug_vector  
2728				endm  
# End of macro CALLMONITOR
2728				endif 
2728 10 dd			djnz .pauses1 
272a			 
272a			       NEXTW 
272a c3 f3 1f			jp macro_next 
272d				endm 
# End of macro NEXTW
272d			.ROT: 
272d			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
272d 45				db WORD_SYS_CORE+49             
272e 7b 27			dw .UWORDS            
2730 04				db 3 + 1 
2731 .. 00			db "ROT",0              
2735				endm 
# End of macro CWHEAD
2735			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2735				if DEBUG_FORTH_WORDS_KEY 
2735					DMARK "ROT" 
2735 f5				push af  
2736 3a 4a 27			ld a, (.dmark)  
2739 32 6b ee			ld (debug_mark),a  
273c 3a 4b 27			ld a, (.dmark+1)  
273f 32 6c ee			ld (debug_mark+1),a  
2742 3a 4c 27			ld a, (.dmark+2)  
2745 32 6d ee			ld (debug_mark+2),a  
2748 18 03			jr .pastdmark  
274a ..			.dmark: db "ROT"  
274d f1			.pastdmark: pop af  
274e			endm  
# End of macro DMARK
274e					CALLMONITOR 
274e cd 6f ee			call debug_vector  
2751				endm  
# End of macro CALLMONITOR
2751				endif 
2751			 
2751			; TODO Use os stack swap memory 
2751				FORTH_DSP_VALUEHL 
2751 cd 3d 1e			call macro_dsp_valuehl 
2754				endm 
# End of macro FORTH_DSP_VALUEHL
2754 e5				push hl    ; u3  
2755			 
2755				FORTH_DSP_POP 
2755 cd f5 1e			call macro_forth_dsp_pop 
2758				endm 
# End of macro FORTH_DSP_POP
2758			 
2758				FORTH_DSP_VALUEHL 
2758 cd 3d 1e			call macro_dsp_valuehl 
275b				endm 
# End of macro FORTH_DSP_VALUEHL
275b e5				push hl     ; u2 
275c			 
275c				FORTH_DSP_POP 
275c cd f5 1e			call macro_forth_dsp_pop 
275f				endm 
# End of macro FORTH_DSP_POP
275f			 
275f				FORTH_DSP_VALUEHL 
275f cd 3d 1e			call macro_dsp_valuehl 
2762				endm 
# End of macro FORTH_DSP_VALUEHL
2762 e5				push hl     ; u1 
2763			 
2763				FORTH_DSP_POP 
2763 cd f5 1e			call macro_forth_dsp_pop 
2766				endm 
# End of macro FORTH_DSP_POP
2766			 
2766 c1				pop bc      ; u1 
2767 e1				pop hl      ; u2 
2768 d1				pop de      ; u3 
2769			 
2769			 
2769 c5				push bc 
276a d5				push de 
276b e5				push hl 
276c			 
276c			 
276c e1				pop hl 
276d cd 46 1c			call forth_push_numhl 
2770			 
2770 e1				pop hl 
2771 cd 46 1c			call forth_push_numhl 
2774			 
2774 e1				pop hl 
2775 cd 46 1c			call forth_push_numhl 
2778				 
2778			 
2778			 
2778			 
2778			 
2778			 
2778			       NEXTW 
2778 c3 f3 1f			jp macro_next 
277b				endm 
# End of macro NEXTW
277b			 
277b			.UWORDS: 
277b			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
277b 50				db WORD_SYS_CORE+60             
277c 3d 28			dw .BP            
277e 07				db 6 + 1 
277f .. 00			db "UWORDS",0              
2786				endm 
# End of macro CWHEAD
2786			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2786			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2786			; | | Following the count are the individual words. 
2786			; | | 
2786			; | | e.g. UWORDS 
2786			; | | BOX DIRLIST 2 
2786			; | |  
2786			; | | Can be used to save the words to storage via: 
2786			; | | UWORDS $01 DO $01 APPEND LOOP 
2786			if DEBUG_FORTH_WORDS_KEY 
2786				DMARK "UWR" 
2786 f5				push af  
2787 3a 9b 27			ld a, (.dmark)  
278a 32 6b ee			ld (debug_mark),a  
278d 3a 9c 27			ld a, (.dmark+1)  
2790 32 6c ee			ld (debug_mark+1),a  
2793 3a 9d 27			ld a, (.dmark+2)  
2796 32 6d ee			ld (debug_mark+2),a  
2799 18 03			jr .pastdmark  
279b ..			.dmark: db "UWR"  
279e f1			.pastdmark: pop af  
279f			endm  
# End of macro DMARK
279f				CALLMONITOR 
279f cd 6f ee			call debug_vector  
27a2				endm  
# End of macro CALLMONITOR
27a2			endif 
27a2 21 d4 65			ld hl, baseram 
27a5				;ld hl, baseusermem 
27a5 01 00 00			ld bc, 0    ; start a counter 
27a8			 
27a8			; skip dict stub 
27a8			 
27a8 cd 44 21			call forth_tok_next 
27ab			 
27ab			 
27ab			; while we have words to look for 
27ab			 
27ab 7e			.douscan:	ld a, (hl)      
27ac			if DEBUG_FORTH_WORDS 
27ac				DMARK "UWs" 
27ac f5				push af  
27ad 3a c1 27			ld a, (.dmark)  
27b0 32 6b ee			ld (debug_mark),a  
27b3 3a c2 27			ld a, (.dmark+1)  
27b6 32 6c ee			ld (debug_mark+1),a  
27b9 3a c3 27			ld a, (.dmark+2)  
27bc 32 6d ee			ld (debug_mark+2),a  
27bf 18 03			jr .pastdmark  
27c1 ..			.dmark: db "UWs"  
27c4 f1			.pastdmark: pop af  
27c5			endm  
# End of macro DMARK
27c5				CALLMONITOR 
27c5 cd 6f ee			call debug_vector  
27c8				endm  
# End of macro CALLMONITOR
27c8			endif 
27c8 fe 00			cp WORD_SYS_END 
27ca 28 4d			jr z, .udone 
27cc fe 01			cp WORD_SYS_UWORD 
27ce 20 44			jr nz, .nuword 
27d0			 
27d0			if DEBUG_FORTH_WORDS 
27d0				DMARK "UWu" 
27d0 f5				push af  
27d1 3a e5 27			ld a, (.dmark)  
27d4 32 6b ee			ld (debug_mark),a  
27d7 3a e6 27			ld a, (.dmark+1)  
27da 32 6c ee			ld (debug_mark+1),a  
27dd 3a e7 27			ld a, (.dmark+2)  
27e0 32 6d ee			ld (debug_mark+2),a  
27e3 18 03			jr .pastdmark  
27e5 ..			.dmark: db "UWu"  
27e8 f1			.pastdmark: pop af  
27e9			endm  
# End of macro DMARK
27e9				CALLMONITOR 
27e9 cd 6f ee			call debug_vector  
27ec				endm  
# End of macro CALLMONITOR
27ec			endif 
27ec				; we have a uword so push its name to the stack 
27ec			 
27ec e5				push hl  ; save so we can move to next dict block 
27ed			 
27ed				; skip opcode 
27ed 23				inc hl  
27ee				; skip next ptr 
27ee 23				inc hl  
27ef 23				inc hl 
27f0				; skip len 
27f0 23				inc hl 
27f1			if DEBUG_FORTH_WORDS 
27f1				DMARK "UWt" 
27f1 f5				push af  
27f2 3a 06 28			ld a, (.dmark)  
27f5 32 6b ee			ld (debug_mark),a  
27f8 3a 07 28			ld a, (.dmark+1)  
27fb 32 6c ee			ld (debug_mark+1),a  
27fe 3a 08 28			ld a, (.dmark+2)  
2801 32 6d ee			ld (debug_mark+2),a  
2804 18 03			jr .pastdmark  
2806 ..			.dmark: db "UWt"  
2809 f1			.pastdmark: pop af  
280a			endm  
# End of macro DMARK
280a				CALLMONITOR 
280a cd 6f ee			call debug_vector  
280d				endm  
# End of macro CALLMONITOR
280d			endif 
280d 03				inc bc 
280e			 
280e c5				push bc 
280f cd b4 1c			call forth_push_str 
2812 c1				pop bc 
2813			 
2813 e1				pop hl 	 
2814			 
2814 cd 44 21		.nuword:	call forth_tok_next 
2817 18 92			jr .douscan  
2819			 
2819			.udone:		 ; push count of uwords found 
2819 c5				push bc 
281a e1				pop hl 
281b			 
281b			if DEBUG_FORTH_WORDS 
281b				DMARK "UWc" 
281b f5				push af  
281c 3a 30 28			ld a, (.dmark)  
281f 32 6b ee			ld (debug_mark),a  
2822 3a 31 28			ld a, (.dmark+1)  
2825 32 6c ee			ld (debug_mark+1),a  
2828 3a 32 28			ld a, (.dmark+2)  
282b 32 6d ee			ld (debug_mark+2),a  
282e 18 03			jr .pastdmark  
2830 ..			.dmark: db "UWc"  
2833 f1			.pastdmark: pop af  
2834			endm  
# End of macro DMARK
2834				CALLMONITOR 
2834 cd 6f ee			call debug_vector  
2837				endm  
# End of macro CALLMONITOR
2837			endif 
2837 cd 46 1c			call forth_push_numhl 
283a			 
283a			 
283a			       NEXTW 
283a c3 f3 1f			jp macro_next 
283d				endm 
# End of macro NEXTW
283d			 
283d			.BP: 
283d			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
283d 54				db WORD_SYS_CORE+64             
283e 77 28			dw .MONITOR            
2840 03				db 2 + 1 
2841 .. 00			db "BP",0              
2844				endm 
# End of macro CWHEAD
2844			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2844			; | | $00 Will enable the break points within specific code paths 
2844			; | | $01 Will disable break points 
2844			; | |  
2844			; | | By default break points are off. Either the above can be used to enable them 
2844			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2844			; | | and on release of the pressed key a message will be disaplayed to notify 
2844			; | | that break points are enabled. Pressing any key will then continue boot process. 
2844				; get byte count 
2844				if DEBUG_FORTH_WORDS_KEY 
2844					DMARK "BP." 
2844 f5				push af  
2845 3a 59 28			ld a, (.dmark)  
2848 32 6b ee			ld (debug_mark),a  
284b 3a 5a 28			ld a, (.dmark+1)  
284e 32 6c ee			ld (debug_mark+1),a  
2851 3a 5b 28			ld a, (.dmark+2)  
2854 32 6d ee			ld (debug_mark+2),a  
2857 18 03			jr .pastdmark  
2859 ..			.dmark: db "BP."  
285c f1			.pastdmark: pop af  
285d			endm  
# End of macro DMARK
285d					CALLMONITOR 
285d cd 6f ee			call debug_vector  
2860				endm  
# End of macro CALLMONITOR
2860				endif 
2860			 
2860				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2860 cd 3d 1e			call macro_dsp_valuehl 
2863				endm 
# End of macro FORTH_DSP_VALUEHL
2863			 
2863			;		push hl 
2863			 
2863				; destroy value TOS 
2863			 
2863				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2863 cd f5 1e			call macro_forth_dsp_pop 
2866				endm 
# End of macro FORTH_DSP_POP
2866			 
2866			;		pop hl 
2866			 
2866 3e 00			ld a,0 
2868 bd				cp l 
2869 28 06			jr z, .bpset 
286b			;		ld a, '*' 
286b cd e8 15			call bp_off 
286e				NEXTW 
286e c3 f3 1f			jp macro_next 
2871				endm 
# End of macro NEXTW
2871			 
2871			.bpset:	 
2871				;	ld (os_view_disable), a 
2871 cd dc 15			call bp_on 
2874			 
2874			 
2874				NEXTW 
2874 c3 f3 1f			jp macro_next 
2877				endm 
# End of macro NEXTW
2877			 
2877			 
2877			.MONITOR: 
2877			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2877 55				db WORD_SYS_CORE+65             
2878 a8 28			dw .MALLOC            
287a 08				db 7 + 1 
287b .. 00			db "MONITOR",0              
2883				endm 
# End of macro CWHEAD
2883			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2883			; | | At start the current various registers will be displayed with contents. 
2883			; | | Top right corner will show the most recent debug marker seen. 
2883			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2883			; | | and the return stack pointer (RSP). 
2883			; | | Pressing: 
2883			; | |    1 - Initial screen 
2883			; | |    2 - Display a data dump of HL 
2883			; | |    3 - Display a data dump of DE 
2883			; | |    4 - Display a data dump of BC 
2883			; | |    5 - Display a data dump of HL 
2883			; | |    6 - Display a data dump of DSP 
2883			; | |    7 - Display a data dump of RSP 
2883			; | |    8 - Display a data dump of what is at DSP 
2883			; | |    9 - Display a data dump of what is at RSP 
2883			; | |    0 - Exit monitor and continue running. This will also enable break points 
2883			; | |    * - Disable break points 
2883			; | |    # - Enter traditional monitor mode 
2883			; | | 
2883			; | | Monitor Mode 
2883			; | | ------------ 
2883			; | | A prompt of '>' will be shown for various commands: 
2883			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2883			; | |    C - Continue display a data dump from the last set address 
2883			; | |    M xxxx - Set start of memory edit at address xx 
2883			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2883			; | |    Q - Return to previous 
2883				if DEBUG_FORTH_WORDS_KEY 
2883					DMARK "MON" 
2883 f5				push af  
2884 3a 98 28			ld a, (.dmark)  
2887 32 6b ee			ld (debug_mark),a  
288a 3a 99 28			ld a, (.dmark+1)  
288d 32 6c ee			ld (debug_mark+1),a  
2890 3a 9a 28			ld a, (.dmark+2)  
2893 32 6d ee			ld (debug_mark+2),a  
2896 18 03			jr .pastdmark  
2898 ..			.dmark: db "MON"  
289b f1			.pastdmark: pop af  
289c			endm  
# End of macro DMARK
289c					CALLMONITOR 
289c cd 6f ee			call debug_vector  
289f				endm  
# End of macro CALLMONITOR
289f				endif 
289f			;		ld a, 0 
289f			;		ld (os_view_disable), a 
289f cd dc 15			call bp_on 
28a2			 
28a2				CALLMONITOR 
28a2 cd 6f ee			call debug_vector  
28a5				endm  
# End of macro CALLMONITOR
28a5			 
28a5			;	call monitor 
28a5			 
28a5				NEXTW 
28a5 c3 f3 1f			jp macro_next 
28a8				endm 
# End of macro NEXTW
28a8			 
28a8			 
28a8			.MALLOC: 
28a8			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
28a8 56				db WORD_SYS_CORE+66             
28a9 d1 28			dw .MALLOC2            
28ab 06				db 5 + 1 
28ac .. 00			db "ALLOT",0              
28b2				endm 
# End of macro CWHEAD
28b2			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28b2				if DEBUG_FORTH_WORDS_KEY 
28b2					DMARK "ALL" 
28b2 f5				push af  
28b3 3a c7 28			ld a, (.dmark)  
28b6 32 6b ee			ld (debug_mark),a  
28b9 3a c8 28			ld a, (.dmark+1)  
28bc 32 6c ee			ld (debug_mark+1),a  
28bf 3a c9 28			ld a, (.dmark+2)  
28c2 32 6d ee			ld (debug_mark+2),a  
28c5 18 03			jr .pastdmark  
28c7 ..			.dmark: db "ALL"  
28ca f1			.pastdmark: pop af  
28cb			endm  
# End of macro DMARK
28cb					CALLMONITOR 
28cb cd 6f ee			call debug_vector  
28ce				endm  
# End of macro CALLMONITOR
28ce				endif 
28ce c3 f8 28			jp .mallocc 
28d1			.MALLOC2: 
28d1			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
28d1 56				db WORD_SYS_CORE+66             
28d2 0f 29			dw .FREE            
28d4 07				db 6 + 1 
28d5 .. 00			db "MALLOC",0              
28dc				endm 
# End of macro CWHEAD
28dc			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
28dc				; get byte count 
28dc				if DEBUG_FORTH_WORDS_KEY 
28dc					DMARK "MAL" 
28dc f5				push af  
28dd 3a f1 28			ld a, (.dmark)  
28e0 32 6b ee			ld (debug_mark),a  
28e3 3a f2 28			ld a, (.dmark+1)  
28e6 32 6c ee			ld (debug_mark+1),a  
28e9 3a f3 28			ld a, (.dmark+2)  
28ec 32 6d ee			ld (debug_mark+2),a  
28ef 18 03			jr .pastdmark  
28f1 ..			.dmark: db "MAL"  
28f4 f1			.pastdmark: pop af  
28f5			endm  
# End of macro DMARK
28f5					CALLMONITOR 
28f5 cd 6f ee			call debug_vector  
28f8				endm  
# End of macro CALLMONITOR
28f8				endif 
28f8			.mallocc: 
28f8				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
28f8 cd 3d 1e			call macro_dsp_valuehl 
28fb				endm 
# End of macro FORTH_DSP_VALUEHL
28fb			 
28fb			;		push hl 
28fb			 
28fb				; destroy value TOS 
28fb			 
28fb				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
28fb cd f5 1e			call macro_forth_dsp_pop 
28fe				endm 
# End of macro FORTH_DSP_POP
28fe			 
28fe			;		pop hl 
28fe cd ad 12			call malloc 
2901			if DEBUG_FORTH_MALLOC_GUARD 
2901 f5				push af 
2902 cd 0f 0e			call ishlzero 
2905			;		ld a, l 
2905			;		add h 
2905			;		cp 0 
2905 f1				pop af 
2906				 
2906 cc 76 4d			call z,malloc_error 
2909			endif 
2909			 
2909 cd 46 1c			call forth_push_numhl 
290c				NEXTW 
290c c3 f3 1f			jp macro_next 
290f				endm 
# End of macro NEXTW
290f			 
290f			.FREE: 
290f			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
290f 57				db WORD_SYS_CORE+67             
2910 40 29			dw .LIST            
2912 05				db 4 + 1 
2913 .. 00			db "FREE",0              
2918				endm 
# End of macro CWHEAD
2918			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2918				if DEBUG_FORTH_WORDS_KEY 
2918					DMARK "FRE" 
2918 f5				push af  
2919 3a 2d 29			ld a, (.dmark)  
291c 32 6b ee			ld (debug_mark),a  
291f 3a 2e 29			ld a, (.dmark+1)  
2922 32 6c ee			ld (debug_mark+1),a  
2925 3a 2f 29			ld a, (.dmark+2)  
2928 32 6d ee			ld (debug_mark+2),a  
292b 18 03			jr .pastdmark  
292d ..			.dmark: db "FRE"  
2930 f1			.pastdmark: pop af  
2931			endm  
# End of macro DMARK
2931					CALLMONITOR 
2931 cd 6f ee			call debug_vector  
2934				endm  
# End of macro CALLMONITOR
2934				endif 
2934				; get address 
2934			 
2934				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2934 cd 3d 1e			call macro_dsp_valuehl 
2937				endm 
# End of macro FORTH_DSP_VALUEHL
2937			 
2937			;		push hl 
2937			 
2937				; destroy value TOS 
2937			 
2937				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2937 cd f5 1e			call macro_forth_dsp_pop 
293a				endm 
# End of macro FORTH_DSP_POP
293a			 
293a			;		pop hl 
293a			if FORTH_ENABLE_MALLOCFREE 
293a cd 77 13			call free 
293d			endif 
293d				NEXTW 
293d c3 f3 1f			jp macro_next 
2940				endm 
# End of macro NEXTW
2940			.LIST: 
2940			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2940 5c				db WORD_SYS_CORE+72             
2941 2e 2b			dw .FORGET            
2943 05				db 4 + 1 
2944 .. 00			db "LIST",0              
2949				endm 
# End of macro CWHEAD
2949			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2949			; | | The quoted word must be in upper case. 
2949			if DEBUG_FORTH_WORDS_KEY 
2949				DMARK "LST" 
2949 f5				push af  
294a 3a 5e 29			ld a, (.dmark)  
294d 32 6b ee			ld (debug_mark),a  
2950 3a 5f 29			ld a, (.dmark+1)  
2953 32 6c ee			ld (debug_mark+1),a  
2956 3a 60 29			ld a, (.dmark+2)  
2959 32 6d ee			ld (debug_mark+2),a  
295c 18 03			jr .pastdmark  
295e ..			.dmark: db "LST"  
2961 f1			.pastdmark: pop af  
2962			endm  
# End of macro DMARK
2962				CALLMONITOR 
2962 cd 6f ee			call debug_vector  
2965				endm  
# End of macro CALLMONITOR
2965			endif 
2965			 
2965				FORTH_DSP_VALUEHL 
2965 cd 3d 1e			call macro_dsp_valuehl 
2968				endm 
# End of macro FORTH_DSP_VALUEHL
2968			 
2968 e5				push hl 
2969				FORTH_DSP_POP 
2969 cd f5 1e			call macro_forth_dsp_pop 
296c				endm 
# End of macro FORTH_DSP_POP
296c c1				pop bc 
296d			 
296d			; Start format of scratch string 
296d			 
296d 21 c1 e2			ld hl, scratch 
2970			 
2970 3e 3a			ld a, ':' 
2972 77				ld (hl),a 
2973 23				inc hl 
2974 3e 20			ld a, ' ' 
2976 77				ld (hl), a 
2977			 
2977				; Get ptr to the word we need to look up 
2977			 
2977			;		FORTH_DSP_VALUEHL 
2977				;v5 FORTH_DSP_VALUE 
2977			; TODO type check 
2977			;		inc hl    ; Skip type check  
2977			;		push hl 
2977			;		ex de, hl    ; put into DE 
2977			 
2977			 
2977 21 d4 65			ld hl, baseram 
297a				;ld hl, baseusermem 
297a			 
297a e5			push hl   ; sacreifical push 
297b			 
297b			.ldouscanm: 
297b e1			pop hl 
297c			.ldouscan: 
297c			if DEBUG_FORTH_WORDS 
297c				DMARK "LSs" 
297c f5				push af  
297d 3a 91 29			ld a, (.dmark)  
2980 32 6b ee			ld (debug_mark),a  
2983 3a 92 29			ld a, (.dmark+1)  
2986 32 6c ee			ld (debug_mark+1),a  
2989 3a 93 29			ld a, (.dmark+2)  
298c 32 6d ee			ld (debug_mark+2),a  
298f 18 03			jr .pastdmark  
2991 ..			.dmark: db "LSs"  
2994 f1			.pastdmark: pop af  
2995			endm  
# End of macro DMARK
2995				CALLMONITOR 
2995 cd 6f ee			call debug_vector  
2998				endm  
# End of macro CALLMONITOR
2998			endif 
2998			; skip dict stub 
2998 cd 44 21			call forth_tok_next 
299b			 
299b			 
299b			; while we have words to look for 
299b			 
299b 7e			ld a, (hl)      
299c			if DEBUG_FORTH_WORDS 
299c				DMARK "LSk" 
299c f5				push af  
299d 3a b1 29			ld a, (.dmark)  
29a0 32 6b ee			ld (debug_mark),a  
29a3 3a b2 29			ld a, (.dmark+1)  
29a6 32 6c ee			ld (debug_mark+1),a  
29a9 3a b3 29			ld a, (.dmark+2)  
29ac 32 6d ee			ld (debug_mark+2),a  
29af 18 03			jr .pastdmark  
29b1 ..			.dmark: db "LSk"  
29b4 f1			.pastdmark: pop af  
29b5			endm  
# End of macro DMARK
29b5				CALLMONITOR 
29b5 cd 6f ee			call debug_vector  
29b8				endm  
# End of macro CALLMONITOR
29b8			endif 
29b8				;cp WORD_SYS_END 
29b8				;jp z, .lunotfound 
29b8			 
29b8					; if we hit non uwords then gone too far 
29b8 fe 01				cp WORD_SYS_UWORD 
29ba c2 ea 2a				jp nz, .lunotfound 
29bd			 
29bd				if DEBUG_FORTH_WORDS 
29bd					DMARK "LSu" 
29bd f5				push af  
29be 3a d2 29			ld a, (.dmark)  
29c1 32 6b ee			ld (debug_mark),a  
29c4 3a d3 29			ld a, (.dmark+1)  
29c7 32 6c ee			ld (debug_mark+1),a  
29ca 3a d4 29			ld a, (.dmark+2)  
29cd 32 6d ee			ld (debug_mark+2),a  
29d0 18 03			jr .pastdmark  
29d2 ..			.dmark: db "LSu"  
29d5 f1			.pastdmark: pop af  
29d6			endm  
# End of macro DMARK
29d6					CALLMONITOR 
29d6 cd 6f ee			call debug_vector  
29d9				endm  
# End of macro CALLMONITOR
29d9				endif 
29d9			 
29d9					; found a uword but is it the one we want... 
29d9			 
29d9 c5					push bc     ; uword to find is on bc 
29da d1					pop de 
29db			 
29db e5					push hl  ; to save the ptr 
29dc			 
29dc					; skip opcode 
29dc 23					inc hl  
29dd					; skip next ptr 
29dd 23					inc hl  
29de 23					inc hl 
29df					; skip len 
29df 23					inc hl 
29e0			 
29e0				if DEBUG_FORTH_WORDS 
29e0					DMARK "LSc" 
29e0 f5				push af  
29e1 3a f5 29			ld a, (.dmark)  
29e4 32 6b ee			ld (debug_mark),a  
29e7 3a f6 29			ld a, (.dmark+1)  
29ea 32 6c ee			ld (debug_mark+1),a  
29ed 3a f7 29			ld a, (.dmark+2)  
29f0 32 6d ee			ld (debug_mark+2),a  
29f3 18 03			jr .pastdmark  
29f5 ..			.dmark: db "LSc"  
29f8 f1			.pastdmark: pop af  
29f9			endm  
# End of macro DMARK
29f9					CALLMONITOR 
29f9 cd 6f ee			call debug_vector  
29fc				endm  
# End of macro CALLMONITOR
29fc				endif 
29fc cd 7c 12				call strcmp 
29ff c2 7b 29				jp nz, .ldouscanm 
2a02				 
2a02			 
2a02			 
2a02					; we have a uword so push its name to the stack 
2a02			 
2a02			;	   	push hl  ; save so we can move to next dict block 
2a02 e1			pop hl 
2a03			 
2a03				if DEBUG_FORTH_WORDS 
2a03					DMARK "LSm" 
2a03 f5				push af  
2a04 3a 18 2a			ld a, (.dmark)  
2a07 32 6b ee			ld (debug_mark),a  
2a0a 3a 19 2a			ld a, (.dmark+1)  
2a0d 32 6c ee			ld (debug_mark+1),a  
2a10 3a 1a 2a			ld a, (.dmark+2)  
2a13 32 6d ee			ld (debug_mark+2),a  
2a16 18 03			jr .pastdmark  
2a18 ..			.dmark: db "LSm"  
2a1b f1			.pastdmark: pop af  
2a1c			endm  
# End of macro DMARK
2a1c					CALLMONITOR 
2a1c cd 6f ee			call debug_vector  
2a1f				endm  
# End of macro CALLMONITOR
2a1f				endif 
2a1f			 
2a1f					; skip opcode 
2a1f 23					inc hl  
2a20					; skip next ptr 
2a20 23					inc hl  
2a21 23					inc hl 
2a22					; skip len 
2a22 7e					ld a, (hl)   ; save length to add 
2a23				if DEBUG_FORTH_WORDS 
2a23					DMARK "LS2" 
2a23 f5				push af  
2a24 3a 38 2a			ld a, (.dmark)  
2a27 32 6b ee			ld (debug_mark),a  
2a2a 3a 39 2a			ld a, (.dmark+1)  
2a2d 32 6c ee			ld (debug_mark+1),a  
2a30 3a 3a 2a			ld a, (.dmark+2)  
2a33 32 6d ee			ld (debug_mark+2),a  
2a36 18 03			jr .pastdmark  
2a38 ..			.dmark: db "LS2"  
2a3b f1			.pastdmark: pop af  
2a3c			endm  
# End of macro DMARK
2a3c					CALLMONITOR 
2a3c cd 6f ee			call debug_vector  
2a3f				endm  
# End of macro CALLMONITOR
2a3f				endif 
2a3f			 
2a3f					; save this location 
2a3f				 
2a3f e5					push hl 
2a40			 
2a40 23					inc hl 
2a41 11 c3 e2				ld de, scratch+2 
2a44 4f					ld c, a 
2a45 06 00				ld b, 0 
2a47			 
2a47				if DEBUG_FORTH_WORDS 
2a47					DMARK "LSn" 
2a47 f5				push af  
2a48 3a 5c 2a			ld a, (.dmark)  
2a4b 32 6b ee			ld (debug_mark),a  
2a4e 3a 5d 2a			ld a, (.dmark+1)  
2a51 32 6c ee			ld (debug_mark+1),a  
2a54 3a 5e 2a			ld a, (.dmark+2)  
2a57 32 6d ee			ld (debug_mark+2),a  
2a5a 18 03			jr .pastdmark  
2a5c ..			.dmark: db "LSn"  
2a5f f1			.pastdmark: pop af  
2a60			endm  
# End of macro DMARK
2a60					CALLMONITOR 
2a60 cd 6f ee			call debug_vector  
2a63				endm  
# End of macro CALLMONITOR
2a63				endif 
2a63			 
2a63					; copy uword name to scratch 
2a63			 
2a63 ed b0				ldir 
2a65			 
2a65 1b					dec de 
2a66 3e 20				ld a, ' '    ; change null to space 
2a68 12					ld (de), a 
2a69			 
2a69 13					inc de 
2a6a			 
2a6a d5					push de 
2a6b c1					pop bc     ; move scratch pointer to end of word name and save it 
2a6c			 
2a6c e1					pop hl 
2a6d 7e					ld a, (hl) 
2a6e					;inc hl 
2a6e					; skip word string 
2a6e cd e6 0d				call addatohl 
2a71			 
2a71 23					inc hl 
2a72			 
2a72				if DEBUG_FORTH_WORDS 
2a72					DMARK "LS3" 
2a72 f5				push af  
2a73 3a 87 2a			ld a, (.dmark)  
2a76 32 6b ee			ld (debug_mark),a  
2a79 3a 88 2a			ld a, (.dmark+1)  
2a7c 32 6c ee			ld (debug_mark+1),a  
2a7f 3a 89 2a			ld a, (.dmark+2)  
2a82 32 6d ee			ld (debug_mark+2),a  
2a85 18 03			jr .pastdmark  
2a87 ..			.dmark: db "LS3"  
2a8a f1			.pastdmark: pop af  
2a8b			endm  
# End of macro DMARK
2a8b					CALLMONITOR 
2a8b cd 6f ee			call debug_vector  
2a8e				endm  
# End of macro CALLMONITOR
2a8e				endif 
2a8e					; should now be at the start of the machine code to setup the eval of the uword 
2a8e					; now locate the ptr to the string defintion 
2a8e			 
2a8e					; skip ld hl, 
2a8e					; then load the ptr 
2a8e			; TODO use get from hl ptr 
2a8e 23					inc hl 
2a8f 5e					ld e, (hl) 
2a90 23					inc hl 
2a91 56					ld d, (hl) 
2a92 eb					ex de, hl 
2a93			 
2a93			 
2a93				if DEBUG_FORTH_WORDS 
2a93					DMARK "LSt" 
2a93 f5				push af  
2a94 3a a8 2a			ld a, (.dmark)  
2a97 32 6b ee			ld (debug_mark),a  
2a9a 3a a9 2a			ld a, (.dmark+1)  
2a9d 32 6c ee			ld (debug_mark+1),a  
2aa0 3a aa 2a			ld a, (.dmark+2)  
2aa3 32 6d ee			ld (debug_mark+2),a  
2aa6 18 03			jr .pastdmark  
2aa8 ..			.dmark: db "LSt"  
2aab f1			.pastdmark: pop af  
2aac			endm  
# End of macro DMARK
2aac					CALLMONITOR 
2aac cd 6f ee			call debug_vector  
2aaf				endm  
# End of macro CALLMONITOR
2aaf				endif 
2aaf			 
2aaf			; cant push right now due to tokenised strings  
2aaf			 
2aaf			; get the destination of where to copy this definition to. 
2aaf			 
2aaf c5					push bc 
2ab0 d1					pop de 
2ab1			 
2ab1 7e			.listl:         ld a,(hl) 
2ab2 fe 00				cp 0 
2ab4 28 09				jr z, .lreplsp     ; replace zero with space 
2ab6					;cp FORTH_END_BUFFER 
2ab6 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2ab8 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2aba				 
2aba					; just copy this char as is then 
2aba			 
2aba 12					ld (de), a 
2abb			 
2abb 23			.listnxt:	inc hl 
2abc 13					inc de 
2abd 18 f2				jr .listl 
2abf			 
2abf 3e 20		.lreplsp:	ld a,' ' 
2ac1 12					ld (de), a 
2ac2 18 f7				jr .listnxt 
2ac4			 
2ac4			; close up uword def 
2ac4			 
2ac4			.listdone: 
2ac4 12					ld (de), a 
2ac5 13					inc de 
2ac6 3e 00				ld a, 0 
2ac8 12					ld (de), a 
2ac9			 
2ac9			; now have def so clean up and push to stack 
2ac9			 
2ac9 21 c1 e2				ld hl, scratch 
2acc				if DEBUG_FORTH_WORDS 
2acc					DMARK "Ltp" 
2acc f5				push af  
2acd 3a e1 2a			ld a, (.dmark)  
2ad0 32 6b ee			ld (debug_mark),a  
2ad3 3a e2 2a			ld a, (.dmark+1)  
2ad6 32 6c ee			ld (debug_mark+1),a  
2ad9 3a e3 2a			ld a, (.dmark+2)  
2adc 32 6d ee			ld (debug_mark+2),a  
2adf 18 03			jr .pastdmark  
2ae1 ..			.dmark: db "Ltp"  
2ae4 f1			.pastdmark: pop af  
2ae5			endm  
# End of macro DMARK
2ae5					CALLMONITOR 
2ae5 cd 6f ee			call debug_vector  
2ae8				endm  
# End of macro CALLMONITOR
2ae8				endif 
2ae8			 
2ae8 18 1f			jr .listpush 
2aea			 
2aea			;.lnuword:	pop hl 
2aea			;		call forth_tok_next 
2aea			;		jp .ldouscan  
2aea			 
2aea			.lunotfound:		  
2aea			 
2aea				if DEBUG_FORTH_WORDS 
2aea					DMARK "LSn" 
2aea f5				push af  
2aeb 3a ff 2a			ld a, (.dmark)  
2aee 32 6b ee			ld (debug_mark),a  
2af1 3a 00 2b			ld a, (.dmark+1)  
2af4 32 6c ee			ld (debug_mark+1),a  
2af7 3a 01 2b			ld a, (.dmark+2)  
2afa 32 6d ee			ld (debug_mark+2),a  
2afd 18 03			jr .pastdmark  
2aff ..			.dmark: db "LSn"  
2b02 f1			.pastdmark: pop af  
2b03			endm  
# End of macro DMARK
2b03					CALLMONITOR 
2b03 cd 6f ee			call debug_vector  
2b06				endm  
# End of macro CALLMONITOR
2b06				endif 
2b06			 
2b06					 
2b06			;		FORTH_DSP_POP 
2b06			;		ld hl, .luno 
2b06			 
2b06					NEXTW			 
2b06 c3 f3 1f			jp macro_next 
2b09				endm 
# End of macro NEXTW
2b09			 
2b09			.listpush: 
2b09				if DEBUG_FORTH_WORDS 
2b09					DMARK "LS>" 
2b09 f5				push af  
2b0a 3a 1e 2b			ld a, (.dmark)  
2b0d 32 6b ee			ld (debug_mark),a  
2b10 3a 1f 2b			ld a, (.dmark+1)  
2b13 32 6c ee			ld (debug_mark+1),a  
2b16 3a 20 2b			ld a, (.dmark+2)  
2b19 32 6d ee			ld (debug_mark+2),a  
2b1c 18 03			jr .pastdmark  
2b1e ..			.dmark: db "LS>"  
2b21 f1			.pastdmark: pop af  
2b22			endm  
# End of macro DMARK
2b22					CALLMONITOR 
2b22 cd 6f ee			call debug_vector  
2b25				endm  
# End of macro CALLMONITOR
2b25				endif 
2b25 cd b4 1c				call forth_push_str 
2b28			 
2b28			 
2b28			 
2b28					NEXTW 
2b28 c3 f3 1f			jp macro_next 
2b2b				endm 
# End of macro NEXTW
2b2b			 
2b2b			;.luno:    db "Word not found",0 
2b2b			 
2b2b			 
2b2b			 
2b2b			 
2b2b			 
2b2b			;		push hl   ; save pointer to start of uword def string 
2b2b			; 
2b2b			;; look for FORTH_EOL_LINE 
2b2b			;		ld a, FORTH_END_BUFFER 
2b2b			;		call strlent 
2b2b			; 
2b2b			;		inc hl		 ; space for coln def 
2b2b			;		inc hl 
2b2b			;		inc hl          ; space for terms 
2b2b			;		inc hl 
2b2b			; 
2b2b			;		ld a, 20   ; TODO get actual length 
2b2b			;		call addatohl    ; include a random amount of room for the uword name 
2b2b			; 
2b2b			;		 
2b2b			;	if DEBUG_FORTH_WORDS 
2b2b			;		DMARK "Lt1" 
2b2b			;		CALLMONITOR 
2b2b			;	endif 
2b2b			;		 
2b2b			; 
2b2b			;; malloc space for the string because we cant change it 
2b2b			; 
2b2b			;		call malloc 
2b2b			;	if DEBUG_FORTH_MALLOC_GUARD 
2b2b			;		push af 
2b2b			;		call ishlzero 
2b2b			;		pop af 
2b2b			;		 
2b2b			;		call z,malloc_error 
2b2b			;	endif 
2b2b			; 
2b2b			;	if DEBUG_FORTH_WORDS 
2b2b			;		DMARK "Lt2" 
2b2b			;		CALLMONITOR 
2b2b			;	endif 
2b2b			;		pop de 
2b2b			;		push hl    ; push the malloc to release later 
2b2b			;		push hl   ;  push back a copy for the later stack push 
2b2b			;		 
2b2b			;; copy the string swapping out the zero terms for spaces 
2b2b			; 
2b2b			;		; de has our source 
2b2b			;		; hl has our dest 
2b2b			; 
2b2b			;; add the coln def 
2b2b			; 
2b2b			;		ld a, ':' 
2b2b			;		ld (hl), a 
2b2b			;		inc hl 
2b2b			;		ld a, ' ' 
2b2b			;		ld (hl), a 
2b2b			;		inc hl 
2b2b			; 
2b2b			;; add the uname word 
2b2b			;		push de   ; save our string for now 
2b2b			;		ex de, hl 
2b2b			; 
2b2b			;		FORTH_DSP_VALUE 
2b2b			;		;v5 FORTH_DSP_VALUE 
2b2b			; 
2b2b			;		inc hl   ; skip type but we know by now this is OK 
2b2b			; 
2b2b			;.luword:	ld a,(hl) 
2b2b			;		cp 0 
2b2b			;		jr z, .luword2 
2b2b			;		ld (de), a 
2b2b			;		inc de 
2b2b			;		inc hl 
2b2b			;		jr .luword 
2b2b			; 
2b2b			;.luword2:	ld a, ' ' 
2b2b			;		ld (de), a 
2b2b			;;		inc hl 
2b2b			;;		inc de 
2b2b			;;		ld (de), a 
2b2b			;;		inc hl 
2b2b			;		inc de 
2b2b			; 
2b2b			;		ex de, hl 
2b2b			;		pop de 
2b2b			;		 
2b2b			;		 
2b2b			; 
2b2b			;; detoken that string and copy it 
2b2b			; 
2b2b			;	if DEBUG_FORTH_WORDS 
2b2b			;		DMARK "Lt2" 
2b2b			;		CALLMONITOR 
2b2b			;	endif 
2b2b			;.ldetok:	ld a, (de) 
2b2b			;		cp FORTH_END_BUFFER 
2b2b			;		jr z, .ldetokend 
2b2b			;		; swap out any zero term for space 
2b2b			;		cp 0 
2b2b			;		jr nz, .ldetoknext 
2b2b			;		ld a, ' ' 
2b2b			; 
2b2b			;	if DEBUG_FORTH_WORDS 
2b2b			;		DMARK "LtS" 
2b2b			;		CALLMONITOR 
2b2b			;	endif 
2b2b			;.ldetoknext:	ld (hl), a 
2b2b			;		inc de 
2b2b			;		inc hl 
2b2b			;		jr .ldetok 
2b2b			; 
2b2b			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2b2b			;		ld (hl), a  
2b2b			; 
2b2b			;; free that temp malloc 
2b2b			; 
2b2b			;		pop hl    
2b2b			; 
2b2b			;	if DEBUG_FORTH_WORDS 
2b2b			;		DMARK "Lt4" 
2b2b			;		CALLMONITOR 
2b2b			;	endif 
2b2b			;		call forth_apushstrhl 
2b2b			; 
2b2b			;		; get rid of temp malloc area 
2b2b			; 
2b2b			;		pop hl 
2b2b			;		call free 
2b2b			; 
2b2b			;		jr .ludone 
2b2b			; 
2b2b			;.lnuword:	pop hl 
2b2b			;		call forth_tok_next 
2b2b			;		jp .ldouscan  
2b2b			; 
2b2b			;.ludone:		 pop hl 
2b2b			; 
2b2b					NEXTW 
2b2b c3 f3 1f			jp macro_next 
2b2e				endm 
# End of macro NEXTW
2b2e			 
2b2e			.FORGET: 
2b2e				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2b2e 5d				db WORD_SYS_CORE+73             
2b2f a7 2b			dw .NOP            
2b31 07				db 6 + 1 
2b32 .. 00			db "FORGET",0              
2b39				endm 
# End of macro CWHEAD
2b39			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2b39			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2b39			; | |  
2b39			; | | e.g. "MORE" forget 
2b39					if DEBUG_FORTH_WORDS_KEY 
2b39						DMARK "FRG" 
2b39 f5				push af  
2b3a 3a 4e 2b			ld a, (.dmark)  
2b3d 32 6b ee			ld (debug_mark),a  
2b40 3a 4f 2b			ld a, (.dmark+1)  
2b43 32 6c ee			ld (debug_mark+1),a  
2b46 3a 50 2b			ld a, (.dmark+2)  
2b49 32 6d ee			ld (debug_mark+2),a  
2b4c 18 03			jr .pastdmark  
2b4e ..			.dmark: db "FRG"  
2b51 f1			.pastdmark: pop af  
2b52			endm  
# End of macro DMARK
2b52						CALLMONITOR 
2b52 cd 6f ee			call debug_vector  
2b55				endm  
# End of macro CALLMONITOR
2b55					endif 
2b55			 
2b55				; find uword 
2b55			        ; update start of word with "_" 
2b55				; replace uword with deleted flag 
2b55			 
2b55			 
2b55			;	if DEBUG_FORTH_WORDS 
2b55			;		DMARK "FOG" 
2b55			;		CALLMONITOR 
2b55			;	endif 
2b55			 
2b55			 
2b55					; Get ptr to the word we need to look up 
2b55			 
2b55					FORTH_DSP_VALUEHL 
2b55 cd 3d 1e			call macro_dsp_valuehl 
2b58				endm 
# End of macro FORTH_DSP_VALUEHL
2b58					;v5 FORTH_DSP_VALUE 
2b58				; TODO type check 
2b58			;		inc hl    ; Skip type check  
2b58 e5					push hl 
2b59 c1					pop bc 
2b5a			;		ex de, hl    ; put into DE 
2b5a			 
2b5a			 
2b5a 21 d4 65				ld hl, baseram 
2b5d					;ld hl, baseusermem 
2b5d			 
2b5d				; skip dict stub 
2b5d			;	call forth_tok_next 
2b5d e5			push hl   ; sacreifical push 
2b5e			 
2b5e			.fldouscanm: 
2b5e e1				pop hl 
2b5f			.fldouscan: 
2b5f			;	if DEBUG_FORTH_WORDS 
2b5f			;		DMARK "LSs" 
2b5f			;		CALLMONITOR 
2b5f			;	endif 
2b5f				; skip dict stub 
2b5f cd 44 21				call forth_tok_next 
2b62			 
2b62			 
2b62			; while we have words to look for 
2b62			 
2b62 7e				ld a, (hl)      
2b63			;	if DEBUG_FORTH_WORDS 
2b63			;		DMARK "LSk" 
2b63			;		CALLMONITOR 
2b63			;	endif 
2b63 fe 00				cp WORD_SYS_END 
2b65 ca a1 2b				jp z, .flunotfound 
2b68 fe 01				cp WORD_SYS_UWORD 
2b6a c2 5f 2b				jp nz, .fldouscan 
2b6d			 
2b6d			;	if DEBUG_FORTH_WORDS 
2b6d			;		DMARK "LSu" 
2b6d			;		CALLMONITOR 
2b6d			;	endif 
2b6d			 
2b6d					; found a uword but is it the one we want... 
2b6d			 
2b6d c5					push bc     ; uword to find is on bc 
2b6e d1					pop de 
2b6f			 
2b6f e5					push hl  ; to save the ptr 
2b70			 
2b70					; skip opcode 
2b70 23					inc hl  
2b71					; skip next ptr 
2b71 23					inc hl  
2b72 23					inc hl 
2b73					; skip len 
2b73 23					inc hl 
2b74			 
2b74			;	if DEBUG_FORTH_WORDS 
2b74			;		DMARK "LSc" 
2b74			;		CALLMONITOR 
2b74			;	endif 
2b74 cd 7c 12				call strcmp 
2b77 c2 5e 2b				jp nz, .fldouscanm 
2b7a			; 
2b7a			; 
2b7a			;; while we have words to look for 
2b7a			; 
2b7a			;.fdouscan:	ld a, (hl)      
2b7a			;	if DEBUG_FORTH_WORDS 
2b7a			;		DMARK "LSs" 
2b7a			;		CALLMONITOR 
2b7a			;	endif 
2b7a			;		cp WORD_SYS_END 
2b7a			;		jp z, .fudone 
2b7a			;		cp WORD_SYS_UWORD 
2b7a			;		jp nz, .fnuword 
2b7a			; 
2b7a			;	if DEBUG_FORTH_WORDS 
2b7a			;		DMARK "FGu" 
2b7a			;		CALLMONITOR 
2b7a			;	endif 
2b7a			; 
2b7a			;		; found a uword but is it the one we want... 
2b7a			; 
2b7a			; 
2b7a			;	        pop de   ; get back the dsp name 
2b7a			;		push de 
2b7a			; 
2b7a			;		push hl  ; to save the ptr 
2b7a			; 
2b7a			;		; skip opcode 
2b7a			;		inc hl  
2b7a			;		; skip next ptr 
2b7a			;		inc hl  
2b7a			;		inc hl 
2b7a			;		; skip len 
2b7a			;		inc hl 
2b7a			; 
2b7a			;	if DEBUG_FORTH_WORDS 
2b7a			;		DMARK "FGc" 
2b7a			;		CALLMONITOR 
2b7a			;	endif 
2b7a			;		call strcmp 
2b7a			;		jp nz, .fnuword 
2b7a			 
2b7a			 
2b7a e1			pop hl 
2b7b			 
2b7b				 
2b7b				if DEBUG_FORTH_WORDS 
2b7b					DMARK "FGm" 
2b7b f5				push af  
2b7c 3a 90 2b			ld a, (.dmark)  
2b7f 32 6b ee			ld (debug_mark),a  
2b82 3a 91 2b			ld a, (.dmark+1)  
2b85 32 6c ee			ld (debug_mark+1),a  
2b88 3a 92 2b			ld a, (.dmark+2)  
2b8b 32 6d ee			ld (debug_mark+2),a  
2b8e 18 03			jr .pastdmark  
2b90 ..			.dmark: db "FGm"  
2b93 f1			.pastdmark: pop af  
2b94			endm  
# End of macro DMARK
2b94					CALLMONITOR 
2b94 cd 6f ee			call debug_vector  
2b97				endm  
# End of macro CALLMONITOR
2b97				endif 
2b97			 
2b97			 
2b97			 
2b97					; we have a uword so push its name to the stack 
2b97			 
2b97			;	   	push hl  ; save so we can move to next dict block 
2b97			;pop hl 
2b97			 
2b97					; update opcode to deleted 
2b97 3e 03				ld a, WORD_SYS_DELETED 
2b99 77					ld (hl), a 
2b9a			 
2b9a 23					inc hl  
2b9b					; skip next ptr 
2b9b 23					inc hl  
2b9c 23					inc hl 
2b9d					; skip len 
2b9d 23					inc hl 
2b9e			 
2b9e					; TODO change parser to skip deleted words but for now mark it out 
2b9e 3e 5f				ld a, "_" 
2ba0 77					ld  (hl),a 
2ba1			 
2ba1			;		jr .fudone 
2ba1			; 
2ba1			;.fnuword:	pop hl 
2ba1			;		call forth_tok_next 
2ba1			;		jp .fdouscan  
2ba1			 
2ba1			.flunotfound:		  
2ba1			 
2ba1			 
2ba1					 
2ba1					FORTH_DSP_POP 
2ba1 cd f5 1e			call macro_forth_dsp_pop 
2ba4				endm 
# End of macro FORTH_DSP_POP
2ba4			;		ld hl, .luno 
2ba4			;.fudone:		 pop hl 
2ba4					NEXTW 
2ba4 c3 f3 1f			jp macro_next 
2ba7				endm 
# End of macro NEXTW
2ba7			.NOP: 
2ba7				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2ba7 61				db WORD_SYS_CORE+77             
2ba8 ce 2b			dw .COMO            
2baa 04				db 3 + 1 
2bab .. 00			db "NOP",0              
2baf				endm 
# End of macro CWHEAD
2baf			; | NOP (  --  ) Do nothing | DONE 
2baf					if DEBUG_FORTH_WORDS_KEY 
2baf						DMARK "NOP" 
2baf f5				push af  
2bb0 3a c4 2b			ld a, (.dmark)  
2bb3 32 6b ee			ld (debug_mark),a  
2bb6 3a c5 2b			ld a, (.dmark+1)  
2bb9 32 6c ee			ld (debug_mark+1),a  
2bbc 3a c6 2b			ld a, (.dmark+2)  
2bbf 32 6d ee			ld (debug_mark+2),a  
2bc2 18 03			jr .pastdmark  
2bc4 ..			.dmark: db "NOP"  
2bc7 f1			.pastdmark: pop af  
2bc8			endm  
# End of macro DMARK
2bc8						CALLMONITOR 
2bc8 cd 6f ee			call debug_vector  
2bcb				endm  
# End of macro CALLMONITOR
2bcb					endif 
2bcb				       NEXTW 
2bcb c3 f3 1f			jp macro_next 
2bce				endm 
# End of macro NEXTW
2bce			.COMO: 
2bce				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2bce 6e				db WORD_SYS_CORE+90             
2bcf 20 2c			dw .COMC            
2bd1 02				db 1 + 1 
2bd2 .. 00			db "(",0              
2bd4				endm 
# End of macro CWHEAD
2bd4			; | ( ( -- )  Start of comment | DONE 
2bd4			 
2bd4			 
2bd4 2a c2 e5				ld hl, ( os_tok_ptr) 
2bd7 11 1b 2c			ld de, .closepar 
2bda					 
2bda					if DEBUG_FORTH_WORDS 
2bda						DMARK ").." 
2bda f5				push af  
2bdb 3a ef 2b			ld a, (.dmark)  
2bde 32 6b ee			ld (debug_mark),a  
2be1 3a f0 2b			ld a, (.dmark+1)  
2be4 32 6c ee			ld (debug_mark+1),a  
2be7 3a f1 2b			ld a, (.dmark+2)  
2bea 32 6d ee			ld (debug_mark+2),a  
2bed 18 03			jr .pastdmark  
2bef ..			.dmark: db ").."  
2bf2 f1			.pastdmark: pop af  
2bf3			endm  
# End of macro DMARK
2bf3						CALLMONITOR 
2bf3 cd 6f ee			call debug_vector  
2bf6				endm  
# End of macro CALLMONITOR
2bf6					endif 
2bf6 cd 0e 21			call findnexttok  
2bf9			 
2bf9					if DEBUG_FORTH_WORDS 
2bf9						DMARK "IF5" 
2bf9 f5				push af  
2bfa 3a 0e 2c			ld a, (.dmark)  
2bfd 32 6b ee			ld (debug_mark),a  
2c00 3a 0f 2c			ld a, (.dmark+1)  
2c03 32 6c ee			ld (debug_mark+1),a  
2c06 3a 10 2c			ld a, (.dmark+2)  
2c09 32 6d ee			ld (debug_mark+2),a  
2c0c 18 03			jr .pastdmark  
2c0e ..			.dmark: db "IF5"  
2c11 f1			.pastdmark: pop af  
2c12			endm  
# End of macro DMARK
2c12						CALLMONITOR 
2c12 cd 6f ee			call debug_vector  
2c15				endm  
# End of macro CALLMONITOR
2c15					endif 
2c15				; replace below with ) exec using tok_ptr 
2c15 22 c2 e5			ld (os_tok_ptr), hl 
2c18 c3 84 20			jp exec1 
2c1b			 
2c1b .. 00			.closepar:   db ")",0 
2c1d			 
2c1d				       NEXTW 
2c1d c3 f3 1f			jp macro_next 
2c20				endm 
# End of macro NEXTW
2c20			.COMC: 
2c20				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2c20 6f				db WORD_SYS_CORE+91             
2c21 29 2c			dw .SCRATCH            
2c23 02				db 1 + 1 
2c24 .. 00			db ")",0              
2c26				endm 
# End of macro CWHEAD
2c26			; | ) ( -- )  End of comment |  DONE  
2c26				       NEXTW 
2c26 c3 f3 1f			jp macro_next 
2c29				endm 
# End of macro NEXTW
2c29			 
2c29			.SCRATCH: 
2c29				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2c29 6f				db WORD_SYS_CORE+91             
2c2a 64 2c			dw .INC            
2c2c 08				db 7 + 1 
2c2d .. 00			db "SCRATCH",0              
2c35				endm 
# End of macro CWHEAD
2c35			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2c35			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2c35			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2c35			; | |  
2c35			; | | e.g.    : score $00 scratch ; 
2c35			; | |  
2c35			; | | $00 score ! 
2c35			; | | $01 score +! 
2c35			; | |  
2c35			; | | e.g.   : varword $0a scratch ;  
2c35			; | | 
2c35			; | | $8000 varword ! 
2c35					if DEBUG_FORTH_WORDS_KEY 
2c35						DMARK "SCR" 
2c35 f5				push af  
2c36 3a 4a 2c			ld a, (.dmark)  
2c39 32 6b ee			ld (debug_mark),a  
2c3c 3a 4b 2c			ld a, (.dmark+1)  
2c3f 32 6c ee			ld (debug_mark+1),a  
2c42 3a 4c 2c			ld a, (.dmark+2)  
2c45 32 6d ee			ld (debug_mark+2),a  
2c48 18 03			jr .pastdmark  
2c4a ..			.dmark: db "SCR"  
2c4d f1			.pastdmark: pop af  
2c4e			endm  
# End of macro DMARK
2c4e						CALLMONITOR 
2c4e cd 6f ee			call debug_vector  
2c51				endm  
# End of macro CALLMONITOR
2c51					endif 
2c51			 
2c51					FORTH_DSP_VALUEHL 
2c51 cd 3d 1e			call macro_dsp_valuehl 
2c54				endm 
# End of macro FORTH_DSP_VALUEHL
2c54				 
2c54					FORTH_DSP_POP 
2c54 cd f5 1e			call macro_forth_dsp_pop 
2c57				endm 
# End of macro FORTH_DSP_POP
2c57			 
2c57 7d					ld a, l 
2c58 21 e6 e7				ld hl, os_var_array 
2c5b cd e6 0d				call addatohl 
2c5e			 
2c5e cd 46 1c				call forth_push_numhl 
2c61			 
2c61				       NEXTW 
2c61 c3 f3 1f			jp macro_next 
2c64				endm 
# End of macro NEXTW
2c64			 
2c64			.INC: 
2c64				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2c64 6f				db WORD_SYS_CORE+91             
2c65 ba 2c			dw .DEC            
2c67 03				db 2 + 1 
2c68 .. 00			db "+!",0              
2c6b				endm 
# End of macro CWHEAD
2c6b			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2c6b					if DEBUG_FORTH_WORDS_KEY 
2c6b						DMARK "+s_" 
2c6b f5				push af  
2c6c 3a 80 2c			ld a, (.dmark)  
2c6f 32 6b ee			ld (debug_mark),a  
2c72 3a 81 2c			ld a, (.dmark+1)  
2c75 32 6c ee			ld (debug_mark+1),a  
2c78 3a 82 2c			ld a, (.dmark+2)  
2c7b 32 6d ee			ld (debug_mark+2),a  
2c7e 18 03			jr .pastdmark  
2c80 ..			.dmark: db "+s_"  
2c83 f1			.pastdmark: pop af  
2c84			endm  
# End of macro DMARK
2c84						CALLMONITOR 
2c84 cd 6f ee			call debug_vector  
2c87				endm  
# End of macro CALLMONITOR
2c87					endif 
2c87			 
2c87					FORTH_DSP_VALUEHL 
2c87 cd 3d 1e			call macro_dsp_valuehl 
2c8a				endm 
# End of macro FORTH_DSP_VALUEHL
2c8a			 
2c8a e5					push hl   ; save address 
2c8b			 
2c8b					FORTH_DSP_POP 
2c8b cd f5 1e			call macro_forth_dsp_pop 
2c8e				endm 
# End of macro FORTH_DSP_POP
2c8e			 
2c8e					FORTH_DSP_VALUEHL 
2c8e cd 3d 1e			call macro_dsp_valuehl 
2c91				endm 
# End of macro FORTH_DSP_VALUEHL
2c91			 
2c91 e5					push hl 
2c92					FORTH_DSP_POP 
2c92 cd f5 1e			call macro_forth_dsp_pop 
2c95				endm 
# End of macro FORTH_DSP_POP
2c95 e1					pop hl 
2c96			 
2c96					; hl contains value to add to byte at a 
2c96				 
2c96 eb					ex de, hl 
2c97			 
2c97 e1					pop hl 
2c98			 
2c98					if DEBUG_FORTH_WORDS 
2c98						DMARK "INC" 
2c98 f5				push af  
2c99 3a ad 2c			ld a, (.dmark)  
2c9c 32 6b ee			ld (debug_mark),a  
2c9f 3a ae 2c			ld a, (.dmark+1)  
2ca2 32 6c ee			ld (debug_mark+1),a  
2ca5 3a af 2c			ld a, (.dmark+2)  
2ca8 32 6d ee			ld (debug_mark+2),a  
2cab 18 03			jr .pastdmark  
2cad ..			.dmark: db "INC"  
2cb0 f1			.pastdmark: pop af  
2cb1			endm  
# End of macro DMARK
2cb1						CALLMONITOR 
2cb1 cd 6f ee			call debug_vector  
2cb4				endm  
# End of macro CALLMONITOR
2cb4					endif 
2cb4			 
2cb4 7e					ld a,(hl) 
2cb5 83					add e 
2cb6 77					ld (hl),a 
2cb7			 
2cb7			 
2cb7			 
2cb7				       NEXTW 
2cb7 c3 f3 1f			jp macro_next 
2cba				endm 
# End of macro NEXTW
2cba			 
2cba			.DEC: 
2cba				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2cba 6f				db WORD_SYS_CORE+91             
2cbb 0e 2d			dw .INC2            
2cbd 03				db 2 + 1 
2cbe .. 00			db "-!",0              
2cc1				endm 
# End of macro CWHEAD
2cc1			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2cc1					if DEBUG_FORTH_WORDS_KEY 
2cc1						DMARK "-s_" 
2cc1 f5				push af  
2cc2 3a d6 2c			ld a, (.dmark)  
2cc5 32 6b ee			ld (debug_mark),a  
2cc8 3a d7 2c			ld a, (.dmark+1)  
2ccb 32 6c ee			ld (debug_mark+1),a  
2cce 3a d8 2c			ld a, (.dmark+2)  
2cd1 32 6d ee			ld (debug_mark+2),a  
2cd4 18 03			jr .pastdmark  
2cd6 ..			.dmark: db "-s_"  
2cd9 f1			.pastdmark: pop af  
2cda			endm  
# End of macro DMARK
2cda						CALLMONITOR 
2cda cd 6f ee			call debug_vector  
2cdd				endm  
# End of macro CALLMONITOR
2cdd					endif 
2cdd			 
2cdd					FORTH_DSP_VALUEHL 
2cdd cd 3d 1e			call macro_dsp_valuehl 
2ce0				endm 
# End of macro FORTH_DSP_VALUEHL
2ce0			 
2ce0 e5					push hl   ; save address 
2ce1			 
2ce1					FORTH_DSP_POP 
2ce1 cd f5 1e			call macro_forth_dsp_pop 
2ce4				endm 
# End of macro FORTH_DSP_POP
2ce4			 
2ce4					FORTH_DSP_VALUEHL 
2ce4 cd 3d 1e			call macro_dsp_valuehl 
2ce7				endm 
# End of macro FORTH_DSP_VALUEHL
2ce7			 
2ce7					; hl contains value to add to byte at a 
2ce7				 
2ce7 eb					ex de, hl 
2ce8			 
2ce8 e1					pop hl 
2ce9			 
2ce9					if DEBUG_FORTH_WORDS 
2ce9						DMARK "DEC" 
2ce9 f5				push af  
2cea 3a fe 2c			ld a, (.dmark)  
2ced 32 6b ee			ld (debug_mark),a  
2cf0 3a ff 2c			ld a, (.dmark+1)  
2cf3 32 6c ee			ld (debug_mark+1),a  
2cf6 3a 00 2d			ld a, (.dmark+2)  
2cf9 32 6d ee			ld (debug_mark+2),a  
2cfc 18 03			jr .pastdmark  
2cfe ..			.dmark: db "DEC"  
2d01 f1			.pastdmark: pop af  
2d02			endm  
# End of macro DMARK
2d02						CALLMONITOR 
2d02 cd 6f ee			call debug_vector  
2d05				endm  
# End of macro CALLMONITOR
2d05					endif 
2d05			 
2d05 7e					ld a,(hl) 
2d06 93					sub e 
2d07 77					ld (hl),a 
2d08			 
2d08			 
2d08					FORTH_DSP_POP 
2d08 cd f5 1e			call macro_forth_dsp_pop 
2d0b				endm 
# End of macro FORTH_DSP_POP
2d0b			 
2d0b				       NEXTW 
2d0b c3 f3 1f			jp macro_next 
2d0e				endm 
# End of macro NEXTW
2d0e			 
2d0e			.INC2: 
2d0e				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2d0e 6f				db WORD_SYS_CORE+91             
2d0f bb 2d			dw .DEC2            
2d11 04				db 3 + 1 
2d12 .. 00			db "+2!",0              
2d16				endm 
# End of macro CWHEAD
2d16			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2d16			 
2d16					if DEBUG_FORTH_WORDS_KEY 
2d16						DMARK "+2s" 
2d16 f5				push af  
2d17 3a 2b 2d			ld a, (.dmark)  
2d1a 32 6b ee			ld (debug_mark),a  
2d1d 3a 2c 2d			ld a, (.dmark+1)  
2d20 32 6c ee			ld (debug_mark+1),a  
2d23 3a 2d 2d			ld a, (.dmark+2)  
2d26 32 6d ee			ld (debug_mark+2),a  
2d29 18 03			jr .pastdmark  
2d2b ..			.dmark: db "+2s"  
2d2e f1			.pastdmark: pop af  
2d2f			endm  
# End of macro DMARK
2d2f						CALLMONITOR 
2d2f cd 6f ee			call debug_vector  
2d32				endm  
# End of macro CALLMONITOR
2d32					endif 
2d32			 
2d32					; Address 
2d32			 
2d32					FORTH_DSP_VALUEHL 
2d32 cd 3d 1e			call macro_dsp_valuehl 
2d35				endm 
# End of macro FORTH_DSP_VALUEHL
2d35			 
2d35 e5					push hl    ; save address 
2d36			 
2d36					; load content into de 
2d36			 
2d36 5e					ld e,(hl) 
2d37 23					inc hl 
2d38 56					ld d, (hl) 
2d39			 
2d39					if DEBUG_FORTH_WORDS 
2d39						DMARK "+2a" 
2d39 f5				push af  
2d3a 3a 4e 2d			ld a, (.dmark)  
2d3d 32 6b ee			ld (debug_mark),a  
2d40 3a 4f 2d			ld a, (.dmark+1)  
2d43 32 6c ee			ld (debug_mark+1),a  
2d46 3a 50 2d			ld a, (.dmark+2)  
2d49 32 6d ee			ld (debug_mark+2),a  
2d4c 18 03			jr .pastdmark  
2d4e ..			.dmark: db "+2a"  
2d51 f1			.pastdmark: pop af  
2d52			endm  
# End of macro DMARK
2d52						CALLMONITOR 
2d52 cd 6f ee			call debug_vector  
2d55				endm  
# End of macro CALLMONITOR
2d55					endif 
2d55			 
2d55					FORTH_DSP_POP 
2d55 cd f5 1e			call macro_forth_dsp_pop 
2d58				endm 
# End of macro FORTH_DSP_POP
2d58			 
2d58					; Get value to add 
2d58			 
2d58					FORTH_DSP_VALUE 
2d58 cd 26 1e			call macro_forth_dsp_value 
2d5b				endm 
# End of macro FORTH_DSP_VALUE
2d5b			 
2d5b					if DEBUG_FORTH_WORDS 
2d5b						DMARK "+2v" 
2d5b f5				push af  
2d5c 3a 70 2d			ld a, (.dmark)  
2d5f 32 6b ee			ld (debug_mark),a  
2d62 3a 71 2d			ld a, (.dmark+1)  
2d65 32 6c ee			ld (debug_mark+1),a  
2d68 3a 72 2d			ld a, (.dmark+2)  
2d6b 32 6d ee			ld (debug_mark+2),a  
2d6e 18 03			jr .pastdmark  
2d70 ..			.dmark: db "+2v"  
2d73 f1			.pastdmark: pop af  
2d74			endm  
# End of macro DMARK
2d74						CALLMONITOR 
2d74 cd 6f ee			call debug_vector  
2d77				endm  
# End of macro CALLMONITOR
2d77					endif 
2d77			 
2d77 19					add hl, de 
2d78			 
2d78					if DEBUG_FORTH_WORDS 
2d78						DMARK "+2+" 
2d78 f5				push af  
2d79 3a 8d 2d			ld a, (.dmark)  
2d7c 32 6b ee			ld (debug_mark),a  
2d7f 3a 8e 2d			ld a, (.dmark+1)  
2d82 32 6c ee			ld (debug_mark+1),a  
2d85 3a 8f 2d			ld a, (.dmark+2)  
2d88 32 6d ee			ld (debug_mark+2),a  
2d8b 18 03			jr .pastdmark  
2d8d ..			.dmark: db "+2+"  
2d90 f1			.pastdmark: pop af  
2d91			endm  
# End of macro DMARK
2d91						CALLMONITOR 
2d91 cd 6f ee			call debug_vector  
2d94				endm  
# End of macro CALLMONITOR
2d94					endif 
2d94			 
2d94					; move result to de 
2d94			 
2d94 eb					ex de, hl 
2d95			 
2d95					; Address 
2d95			 
2d95 e1					pop hl 
2d96			 
2d96					; save it back 
2d96			 
2d96 73					ld (hl), e 
2d97 23					inc hl 
2d98 72					ld (hl), d 
2d99			 
2d99					if DEBUG_FORTH_WORDS 
2d99						DMARK "+2e" 
2d99 f5				push af  
2d9a 3a ae 2d			ld a, (.dmark)  
2d9d 32 6b ee			ld (debug_mark),a  
2da0 3a af 2d			ld a, (.dmark+1)  
2da3 32 6c ee			ld (debug_mark+1),a  
2da6 3a b0 2d			ld a, (.dmark+2)  
2da9 32 6d ee			ld (debug_mark+2),a  
2dac 18 03			jr .pastdmark  
2dae ..			.dmark: db "+2e"  
2db1 f1			.pastdmark: pop af  
2db2			endm  
# End of macro DMARK
2db2						CALLMONITOR 
2db2 cd 6f ee			call debug_vector  
2db5				endm  
# End of macro CALLMONITOR
2db5					endif 
2db5			 
2db5			 
2db5			 
2db5					FORTH_DSP_POP 
2db5 cd f5 1e			call macro_forth_dsp_pop 
2db8				endm 
# End of macro FORTH_DSP_POP
2db8			 
2db8			 
2db8				       NEXTW 
2db8 c3 f3 1f			jp macro_next 
2dbb				endm 
# End of macro NEXTW
2dbb			 
2dbb			.DEC2: 
2dbb				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2dbb 6f				db WORD_SYS_CORE+91             
2dbc 6a 2e			dw .GET2            
2dbe 04				db 3 + 1 
2dbf .. 00			db "-2!",0              
2dc3				endm 
# End of macro CWHEAD
2dc3			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2dc3			 
2dc3			 
2dc3					if DEBUG_FORTH_WORDS_KEY 
2dc3						DMARK "-2s" 
2dc3 f5				push af  
2dc4 3a d8 2d			ld a, (.dmark)  
2dc7 32 6b ee			ld (debug_mark),a  
2dca 3a d9 2d			ld a, (.dmark+1)  
2dcd 32 6c ee			ld (debug_mark+1),a  
2dd0 3a da 2d			ld a, (.dmark+2)  
2dd3 32 6d ee			ld (debug_mark+2),a  
2dd6 18 03			jr .pastdmark  
2dd8 ..			.dmark: db "-2s"  
2ddb f1			.pastdmark: pop af  
2ddc			endm  
# End of macro DMARK
2ddc						CALLMONITOR 
2ddc cd 6f ee			call debug_vector  
2ddf				endm  
# End of macro CALLMONITOR
2ddf					endif 
2ddf			 
2ddf					; Address 
2ddf			 
2ddf					FORTH_DSP_VALUEHL 
2ddf cd 3d 1e			call macro_dsp_valuehl 
2de2				endm 
# End of macro FORTH_DSP_VALUEHL
2de2			 
2de2 e5					push hl    ; save address 
2de3			 
2de3					; load content into de 
2de3			 
2de3 5e					ld e,(hl) 
2de4 23					inc hl 
2de5 56					ld d, (hl) 
2de6			 
2de6					if DEBUG_FORTH_WORDS 
2de6						DMARK "-2a" 
2de6 f5				push af  
2de7 3a fb 2d			ld a, (.dmark)  
2dea 32 6b ee			ld (debug_mark),a  
2ded 3a fc 2d			ld a, (.dmark+1)  
2df0 32 6c ee			ld (debug_mark+1),a  
2df3 3a fd 2d			ld a, (.dmark+2)  
2df6 32 6d ee			ld (debug_mark+2),a  
2df9 18 03			jr .pastdmark  
2dfb ..			.dmark: db "-2a"  
2dfe f1			.pastdmark: pop af  
2dff			endm  
# End of macro DMARK
2dff						CALLMONITOR 
2dff cd 6f ee			call debug_vector  
2e02				endm  
# End of macro CALLMONITOR
2e02					endif 
2e02			 
2e02					FORTH_DSP_POP 
2e02 cd f5 1e			call macro_forth_dsp_pop 
2e05				endm 
# End of macro FORTH_DSP_POP
2e05			 
2e05					; Get value to remove 
2e05			 
2e05					FORTH_DSP_VALUE 
2e05 cd 26 1e			call macro_forth_dsp_value 
2e08				endm 
# End of macro FORTH_DSP_VALUE
2e08			 
2e08					if DEBUG_FORTH_WORDS 
2e08						DMARK "-2v" 
2e08 f5				push af  
2e09 3a 1d 2e			ld a, (.dmark)  
2e0c 32 6b ee			ld (debug_mark),a  
2e0f 3a 1e 2e			ld a, (.dmark+1)  
2e12 32 6c ee			ld (debug_mark+1),a  
2e15 3a 1f 2e			ld a, (.dmark+2)  
2e18 32 6d ee			ld (debug_mark+2),a  
2e1b 18 03			jr .pastdmark  
2e1d ..			.dmark: db "-2v"  
2e20 f1			.pastdmark: pop af  
2e21			endm  
# End of macro DMARK
2e21						CALLMONITOR 
2e21 cd 6f ee			call debug_vector  
2e24				endm  
# End of macro CALLMONITOR
2e24					endif 
2e24			 
2e24 eb					ex de, hl 
2e25 ed 52				sbc hl, de 
2e27			 
2e27					if DEBUG_FORTH_WORDS 
2e27						DMARK "-2d" 
2e27 f5				push af  
2e28 3a 3c 2e			ld a, (.dmark)  
2e2b 32 6b ee			ld (debug_mark),a  
2e2e 3a 3d 2e			ld a, (.dmark+1)  
2e31 32 6c ee			ld (debug_mark+1),a  
2e34 3a 3e 2e			ld a, (.dmark+2)  
2e37 32 6d ee			ld (debug_mark+2),a  
2e3a 18 03			jr .pastdmark  
2e3c ..			.dmark: db "-2d"  
2e3f f1			.pastdmark: pop af  
2e40			endm  
# End of macro DMARK
2e40						CALLMONITOR 
2e40 cd 6f ee			call debug_vector  
2e43				endm  
# End of macro CALLMONITOR
2e43					endif 
2e43			 
2e43					; move result to de 
2e43			 
2e43 eb					ex de, hl 
2e44			 
2e44					; Address 
2e44			 
2e44 e1					pop hl 
2e45			 
2e45					; save it back 
2e45			 
2e45 73					ld (hl), e 
2e46 23					inc hl 
2e47 72					ld (hl), d 
2e48			 
2e48					if DEBUG_FORTH_WORDS 
2e48						DMARK "-2e" 
2e48 f5				push af  
2e49 3a 5d 2e			ld a, (.dmark)  
2e4c 32 6b ee			ld (debug_mark),a  
2e4f 3a 5e 2e			ld a, (.dmark+1)  
2e52 32 6c ee			ld (debug_mark+1),a  
2e55 3a 5f 2e			ld a, (.dmark+2)  
2e58 32 6d ee			ld (debug_mark+2),a  
2e5b 18 03			jr .pastdmark  
2e5d ..			.dmark: db "-2e"  
2e60 f1			.pastdmark: pop af  
2e61			endm  
# End of macro DMARK
2e61						CALLMONITOR 
2e61 cd 6f ee			call debug_vector  
2e64				endm  
# End of macro CALLMONITOR
2e64					endif 
2e64			 
2e64			 
2e64					FORTH_DSP_POP 
2e64 cd f5 1e			call macro_forth_dsp_pop 
2e67				endm 
# End of macro FORTH_DSP_POP
2e67			 
2e67			 
2e67			 
2e67				       NEXTW 
2e67 c3 f3 1f			jp macro_next 
2e6a				endm 
# End of macro NEXTW
2e6a			.GET2: 
2e6a				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2e6a 6f				db WORD_SYS_CORE+91             
2e6b 9f 2e			dw .BANG2            
2e6d 03				db 2 + 1 
2e6e .. 00			db "2@",0              
2e71				endm 
# End of macro CWHEAD
2e71			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2e71					if DEBUG_FORTH_WORDS_KEY 
2e71						DMARK "2A_" 
2e71 f5				push af  
2e72 3a 86 2e			ld a, (.dmark)  
2e75 32 6b ee			ld (debug_mark),a  
2e78 3a 87 2e			ld a, (.dmark+1)  
2e7b 32 6c ee			ld (debug_mark+1),a  
2e7e 3a 88 2e			ld a, (.dmark+2)  
2e81 32 6d ee			ld (debug_mark+2),a  
2e84 18 03			jr .pastdmark  
2e86 ..			.dmark: db "2A_"  
2e89 f1			.pastdmark: pop af  
2e8a			endm  
# End of macro DMARK
2e8a						CALLMONITOR 
2e8a cd 6f ee			call debug_vector  
2e8d				endm  
# End of macro CALLMONITOR
2e8d					endif 
2e8d			 
2e8d					FORTH_DSP_VALUEHL 
2e8d cd 3d 1e			call macro_dsp_valuehl 
2e90				endm 
# End of macro FORTH_DSP_VALUEHL
2e90			 
2e90 e5					push hl   ; save address 
2e91			 
2e91					FORTH_DSP_POP 
2e91 cd f5 1e			call macro_forth_dsp_pop 
2e94				endm 
# End of macro FORTH_DSP_POP
2e94			 
2e94 e1					pop hl 
2e95			 
2e95 5e					ld e, (hl) 
2e96 23					inc hl 
2e97 56					ld d, (hl) 
2e98			 
2e98 eb					ex de, hl 
2e99			 
2e99 cd 46 1c				call forth_push_numhl 
2e9c			 
2e9c				       NEXTW 
2e9c c3 f3 1f			jp macro_next 
2e9f				endm 
# End of macro NEXTW
2e9f			.BANG2: 
2e9f				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2e9f 6f				db WORD_SYS_CORE+91             
2ea0 d7 2e			dw .CONFIG            
2ea2 03				db 2 + 1 
2ea3 .. 00			db "2!",0              
2ea6				endm 
# End of macro CWHEAD
2ea6			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2ea6					if DEBUG_FORTH_WORDS_KEY 
2ea6						DMARK "2S_" 
2ea6 f5				push af  
2ea7 3a bb 2e			ld a, (.dmark)  
2eaa 32 6b ee			ld (debug_mark),a  
2ead 3a bc 2e			ld a, (.dmark+1)  
2eb0 32 6c ee			ld (debug_mark+1),a  
2eb3 3a bd 2e			ld a, (.dmark+2)  
2eb6 32 6d ee			ld (debug_mark+2),a  
2eb9 18 03			jr .pastdmark  
2ebb ..			.dmark: db "2S_"  
2ebe f1			.pastdmark: pop af  
2ebf			endm  
# End of macro DMARK
2ebf						CALLMONITOR 
2ebf cd 6f ee			call debug_vector  
2ec2				endm  
# End of macro CALLMONITOR
2ec2					endif 
2ec2			 
2ec2					FORTH_DSP_VALUEHL 
2ec2 cd 3d 1e			call macro_dsp_valuehl 
2ec5				endm 
# End of macro FORTH_DSP_VALUEHL
2ec5			 
2ec5 e5					push hl   ; save address 
2ec6			 
2ec6			 
2ec6					FORTH_DSP_POP 
2ec6 cd f5 1e			call macro_forth_dsp_pop 
2ec9				endm 
# End of macro FORTH_DSP_POP
2ec9			 
2ec9					 
2ec9					FORTH_DSP_VALUEHL 
2ec9 cd 3d 1e			call macro_dsp_valuehl 
2ecc				endm 
# End of macro FORTH_DSP_VALUEHL
2ecc			 
2ecc					FORTH_DSP_POP 
2ecc cd f5 1e			call macro_forth_dsp_pop 
2ecf				endm 
# End of macro FORTH_DSP_POP
2ecf			 
2ecf eb					ex de, hl    ; value now in de 
2ed0			 
2ed0 e1					pop hl 
2ed1			 
2ed1 73					ld (hl), e 
2ed2			 
2ed2 23					inc hl 
2ed3			 
2ed3 72					ld (hl), d 
2ed4			 
2ed4			 
2ed4				       NEXTW 
2ed4 c3 f3 1f			jp macro_next 
2ed7				endm 
# End of macro NEXTW
2ed7			.CONFIG: 
2ed7				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
2ed7 6f				db WORD_SYS_CORE+91             
2ed8 e8 2e			dw .ADTOS            
2eda 07				db 6 + 1 
2edb .. 00			db "CONFIG",0              
2ee2				endm 
# End of macro CWHEAD
2ee2			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2ee2			 
2ee2 cd 46 14				call config 
2ee5					NEXTW 
2ee5 c3 f3 1f			jp macro_next 
2ee8				endm 
# End of macro NEXTW
2ee8			 
2ee8			.ADTOS: 
2ee8				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
2ee8 6f				db WORD_SYS_CORE+91             
2ee9 fe 2e			dw .SBTOS            
2eeb 03				db 2 + 1 
2eec .. 00			db "1+",0              
2eef				endm 
# End of macro CWHEAD
2eef			; | 1+ ( u -- u )  Increment value on TOS | DONE 
2eef			 
2eef					FORTH_DSP_VALUEHL 
2eef cd 3d 1e			call macro_dsp_valuehl 
2ef2				endm 
# End of macro FORTH_DSP_VALUEHL
2ef2 e5					push hl 
2ef3			 
2ef3					FORTH_DSP_POP 
2ef3 cd f5 1e			call macro_forth_dsp_pop 
2ef6				endm 
# End of macro FORTH_DSP_POP
2ef6 e1					pop hl 
2ef7			 
2ef7 23					inc hl 
2ef8 cd 46 1c				call forth_push_numhl 
2efb					 
2efb					NEXTW 
2efb c3 f3 1f			jp macro_next 
2efe				endm 
# End of macro NEXTW
2efe			.SBTOS: 
2efe				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
2efe 6f				db WORD_SYS_CORE+91             
2eff 14 2f			dw .ADSTORE            
2f01 03				db 2 + 1 
2f02 .. 00			db "1-",0              
2f05				endm 
# End of macro CWHEAD
2f05			; | 1- ( u -- u )  Decrement value on TOS | DONE 
2f05			 
2f05					FORTH_DSP_VALUEHL 
2f05 cd 3d 1e			call macro_dsp_valuehl 
2f08				endm 
# End of macro FORTH_DSP_VALUEHL
2f08 e5					push hl 
2f09			 
2f09					FORTH_DSP_POP 
2f09 cd f5 1e			call macro_forth_dsp_pop 
2f0c				endm 
# End of macro FORTH_DSP_POP
2f0c e1					pop hl 
2f0d			 
2f0d 2b					dec hl 
2f0e cd 46 1c				call forth_push_numhl 
2f11					 
2f11					NEXTW 
2f11 c3 f3 1f			jp macro_next 
2f14				endm 
# End of macro NEXTW
2f14			.ADSTORE: 
2f14				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
2f14 6f				db WORD_SYS_CORE+91             
2f15 2a 2f			dw .ADWSTORE            
2f17 04				db 3 + 1 
2f18 .. 00			db "1+!",0              
2f1c				endm 
# End of macro CWHEAD
2f1c			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
2f1c			 
2f1c					FORTH_DSP_VALUEHL 
2f1c cd 3d 1e			call macro_dsp_valuehl 
2f1f				endm 
# End of macro FORTH_DSP_VALUEHL
2f1f e5					push hl 
2f20			 
2f20					FORTH_DSP_POP 
2f20 cd f5 1e			call macro_forth_dsp_pop 
2f23				endm 
# End of macro FORTH_DSP_POP
2f23 e1					pop hl 
2f24			 
2f24 7e					ld a, (hl) 
2f25 3c					inc a 
2f26 77					ld (hl), a 
2f27					 
2f27					NEXTW 
2f27 c3 f3 1f			jp macro_next 
2f2a				endm 
# End of macro NEXTW
2f2a			.ADWSTORE: 
2f2a				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
2f2a 6f				db WORD_SYS_CORE+91             
2f2b 48 2f			dw .SBSTORE            
2f2d 05				db 4 + 1 
2f2e .. 00			db "1+2!",0              
2f33				endm 
# End of macro CWHEAD
2f33			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
2f33			 
2f33					FORTH_DSP_VALUEHL 
2f33 cd 3d 1e			call macro_dsp_valuehl 
2f36				endm 
# End of macro FORTH_DSP_VALUEHL
2f36 e5					push hl 
2f37			 
2f37					FORTH_DSP_POP 
2f37 cd f5 1e			call macro_forth_dsp_pop 
2f3a				endm 
# End of macro FORTH_DSP_POP
2f3a e1					pop hl 
2f3b			 
2f3b e5					push hl 
2f3c			 
2f3c cd 75 1f				call loadwordinhl 
2f3f 23					inc hl 
2f40			 
2f40 d1					pop de 
2f41 eb					ex de, hl 
2f42 73					ld (hl), e 
2f43 23					inc hl 
2f44 72					ld (hl), d 
2f45					 
2f45					NEXTW 
2f45 c3 f3 1f			jp macro_next 
2f48				endm 
# End of macro NEXTW
2f48			.SBSTORE: 
2f48				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
2f48 6f				db WORD_SYS_CORE+91             
2f49 5e 2f			dw .SBWSTORE            
2f4b 04				db 3 + 1 
2f4c .. 00			db "1-!",0              
2f50				endm 
# End of macro CWHEAD
2f50			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
2f50			 
2f50					FORTH_DSP_VALUEHL 
2f50 cd 3d 1e			call macro_dsp_valuehl 
2f53				endm 
# End of macro FORTH_DSP_VALUEHL
2f53 e5					push hl 
2f54			 
2f54					FORTH_DSP_POP 
2f54 cd f5 1e			call macro_forth_dsp_pop 
2f57				endm 
# End of macro FORTH_DSP_POP
2f57 e1					pop hl 
2f58			 
2f58 7e					ld a, (hl) 
2f59 3d					dec a 
2f5a 77					ld (hl), a 
2f5b					 
2f5b					NEXTW 
2f5b c3 f3 1f			jp macro_next 
2f5e				endm 
# End of macro NEXTW
2f5e			.SBWSTORE: 
2f5e				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
2f5e 6f				db WORD_SYS_CORE+91             
2f5f 7c 2f			dw .ENDCORE            
2f61 05				db 4 + 1 
2f62 .. 00			db "1-2!",0              
2f67				endm 
# End of macro CWHEAD
2f67			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
2f67			 
2f67					FORTH_DSP_VALUEHL 
2f67 cd 3d 1e			call macro_dsp_valuehl 
2f6a				endm 
# End of macro FORTH_DSP_VALUEHL
2f6a e5					push hl 
2f6b			 
2f6b					FORTH_DSP_POP 
2f6b cd f5 1e			call macro_forth_dsp_pop 
2f6e				endm 
# End of macro FORTH_DSP_POP
2f6e e1					pop hl 
2f6f			 
2f6f e5					push hl 
2f70			 
2f70 cd 75 1f				call loadwordinhl 
2f73 2b					dec hl 
2f74			 
2f74 d1					pop de 
2f75 eb					ex de, hl 
2f76 73					ld (hl), e 
2f77 23					inc hl 
2f78 72					ld (hl), d 
2f79					 
2f79					NEXTW 
2f79 c3 f3 1f			jp macro_next 
2f7c				endm 
# End of macro NEXTW
2f7c			.ENDCORE: 
2f7c			 
2f7c			; eof 
2f7c			 
2f7c			 
# End of file forth_words_core.asm
2f7c			include "forth_words_flow.asm" 
2f7c			 
2f7c			; | ## Program Flow Words 
2f7c			 
2f7c			.IF: 
2f7c				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2f7c 1e				db WORD_SYS_CORE+10             
2f7d 71 30			dw .THEN            
2f7f 03				db 2 + 1 
2f80 .. 00			db "IF",0              
2f83				endm 
# End of macro CWHEAD
2f83			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2f83			; 
2f83					if DEBUG_FORTH_WORDS_KEY 
2f83						DMARK "IF." 
2f83 f5				push af  
2f84 3a 98 2f			ld a, (.dmark)  
2f87 32 6b ee			ld (debug_mark),a  
2f8a 3a 99 2f			ld a, (.dmark+1)  
2f8d 32 6c ee			ld (debug_mark+1),a  
2f90 3a 9a 2f			ld a, (.dmark+2)  
2f93 32 6d ee			ld (debug_mark+2),a  
2f96 18 03			jr .pastdmark  
2f98 ..			.dmark: db "IF."  
2f9b f1			.pastdmark: pop af  
2f9c			endm  
# End of macro DMARK
2f9c						CALLMONITOR 
2f9c cd 6f ee			call debug_vector  
2f9f				endm  
# End of macro CALLMONITOR
2f9f					endif 
2f9f			; eval TOS 
2f9f			 
2f9f				FORTH_DSP_VALUEHL 
2f9f cd 3d 1e			call macro_dsp_valuehl 
2fa2				endm 
# End of macro FORTH_DSP_VALUEHL
2fa2			 
2fa2			;	push hl 
2fa2				FORTH_DSP_POP 
2fa2 cd f5 1e			call macro_forth_dsp_pop 
2fa5				endm 
# End of macro FORTH_DSP_POP
2fa5			;	pop hl 
2fa5			 
2fa5					if DEBUG_FORTH_WORDS 
2fa5						DMARK "IF1" 
2fa5 f5				push af  
2fa6 3a ba 2f			ld a, (.dmark)  
2fa9 32 6b ee			ld (debug_mark),a  
2fac 3a bb 2f			ld a, (.dmark+1)  
2faf 32 6c ee			ld (debug_mark+1),a  
2fb2 3a bc 2f			ld a, (.dmark+2)  
2fb5 32 6d ee			ld (debug_mark+2),a  
2fb8 18 03			jr .pastdmark  
2fba ..			.dmark: db "IF1"  
2fbd f1			.pastdmark: pop af  
2fbe			endm  
# End of macro DMARK
2fbe						CALLMONITOR 
2fbe cd 6f ee			call debug_vector  
2fc1				endm  
# End of macro CALLMONITOR
2fc1					endif 
2fc1 b7				or a        ; clear carry flag 
2fc2 11 00 00			ld de, 0 
2fc5 eb				ex de,hl 
2fc6 ed 52			sbc hl, de 
2fc8 c2 52 30			jp nz, .iftrue 
2fcb			 
2fcb					if DEBUG_FORTH_WORDS 
2fcb						DMARK "IF2" 
2fcb f5				push af  
2fcc 3a e0 2f			ld a, (.dmark)  
2fcf 32 6b ee			ld (debug_mark),a  
2fd2 3a e1 2f			ld a, (.dmark+1)  
2fd5 32 6c ee			ld (debug_mark+1),a  
2fd8 3a e2 2f			ld a, (.dmark+2)  
2fdb 32 6d ee			ld (debug_mark+2),a  
2fde 18 03			jr .pastdmark  
2fe0 ..			.dmark: db "IF2"  
2fe3 f1			.pastdmark: pop af  
2fe4			endm  
# End of macro DMARK
2fe4						CALLMONITOR 
2fe4 cd 6f ee			call debug_vector  
2fe7				endm  
# End of macro CALLMONITOR
2fe7					endif 
2fe7			 
2fe7			; if not true then skip to THEN 
2fe7			 
2fe7				; TODO get tok_ptr 
2fe7				; TODO consume toks until we get to THEN 
2fe7			 
2fe7 2a c2 e5			ld hl, (os_tok_ptr) 
2fea					if DEBUG_FORTH_WORDS 
2fea						DMARK "IF3" 
2fea f5				push af  
2feb 3a ff 2f			ld a, (.dmark)  
2fee 32 6b ee			ld (debug_mark),a  
2ff1 3a 00 30			ld a, (.dmark+1)  
2ff4 32 6c ee			ld (debug_mark+1),a  
2ff7 3a 01 30			ld a, (.dmark+2)  
2ffa 32 6d ee			ld (debug_mark+2),a  
2ffd 18 03			jr .pastdmark  
2fff ..			.dmark: db "IF3"  
3002 f1			.pastdmark: pop af  
3003			endm  
# End of macro DMARK
3003						CALLMONITOR 
3003 cd 6f ee			call debug_vector  
3006				endm  
# End of macro CALLMONITOR
3006						 
3006					endif 
3006 11 4d 30			ld de, .ifthen 
3009					if DEBUG_FORTH_WORDS 
3009						DMARK "IF4" 
3009 f5				push af  
300a 3a 1e 30			ld a, (.dmark)  
300d 32 6b ee			ld (debug_mark),a  
3010 3a 1f 30			ld a, (.dmark+1)  
3013 32 6c ee			ld (debug_mark+1),a  
3016 3a 20 30			ld a, (.dmark+2)  
3019 32 6d ee			ld (debug_mark+2),a  
301c 18 03			jr .pastdmark  
301e ..			.dmark: db "IF4"  
3021 f1			.pastdmark: pop af  
3022			endm  
# End of macro DMARK
3022						CALLMONITOR 
3022 cd 6f ee			call debug_vector  
3025				endm  
# End of macro CALLMONITOR
3025					endif 
3025 cd 0e 21			call findnexttok  
3028			 
3028					if DEBUG_FORTH_WORDS 
3028						DMARK "IF5" 
3028 f5				push af  
3029 3a 3d 30			ld a, (.dmark)  
302c 32 6b ee			ld (debug_mark),a  
302f 3a 3e 30			ld a, (.dmark+1)  
3032 32 6c ee			ld (debug_mark+1),a  
3035 3a 3f 30			ld a, (.dmark+2)  
3038 32 6d ee			ld (debug_mark+2),a  
303b 18 03			jr .pastdmark  
303d ..			.dmark: db "IF5"  
3040 f1			.pastdmark: pop af  
3041			endm  
# End of macro DMARK
3041						CALLMONITOR 
3041 cd 6f ee			call debug_vector  
3044				endm  
# End of macro CALLMONITOR
3044					endif 
3044				; TODO replace below with ; exec using tok_ptr 
3044 22 c2 e5			ld (os_tok_ptr), hl 
3047 c3 84 20			jp exec1 
304a				NEXTW 
304a c3 f3 1f			jp macro_next 
304d				endm 
# End of macro NEXTW
304d			 
304d .. 00		.ifthen:  db "THEN",0 
3052			 
3052			.iftrue:		 
3052				; Exec next words normally 
3052			 
3052				; if true then exec following IF as normal 
3052					if DEBUG_FORTH_WORDS 
3052						DMARK "IFT" 
3052 f5				push af  
3053 3a 67 30			ld a, (.dmark)  
3056 32 6b ee			ld (debug_mark),a  
3059 3a 68 30			ld a, (.dmark+1)  
305c 32 6c ee			ld (debug_mark+1),a  
305f 3a 69 30			ld a, (.dmark+2)  
3062 32 6d ee			ld (debug_mark+2),a  
3065 18 03			jr .pastdmark  
3067 ..			.dmark: db "IFT"  
306a f1			.pastdmark: pop af  
306b			endm  
# End of macro DMARK
306b						CALLMONITOR 
306b cd 6f ee			call debug_vector  
306e				endm  
# End of macro CALLMONITOR
306e					endif 
306e			 
306e					NEXTW 
306e c3 f3 1f			jp macro_next 
3071				endm 
# End of macro NEXTW
3071			.THEN: 
3071				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3071 1f				db WORD_SYS_CORE+11             
3072 99 30			dw .ELSE            
3074 05				db 4 + 1 
3075 .. 00			db "THEN",0              
307a				endm 
# End of macro CWHEAD
307a			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
307a					if DEBUG_FORTH_WORDS_KEY 
307a						DMARK "THN" 
307a f5				push af  
307b 3a 8f 30			ld a, (.dmark)  
307e 32 6b ee			ld (debug_mark),a  
3081 3a 90 30			ld a, (.dmark+1)  
3084 32 6c ee			ld (debug_mark+1),a  
3087 3a 91 30			ld a, (.dmark+2)  
308a 32 6d ee			ld (debug_mark+2),a  
308d 18 03			jr .pastdmark  
308f ..			.dmark: db "THN"  
3092 f1			.pastdmark: pop af  
3093			endm  
# End of macro DMARK
3093						CALLMONITOR 
3093 cd 6f ee			call debug_vector  
3096				endm  
# End of macro CALLMONITOR
3096					endif 
3096					NEXTW 
3096 c3 f3 1f			jp macro_next 
3099				endm 
# End of macro NEXTW
3099			.ELSE: 
3099				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
3099 20				db WORD_SYS_CORE+12             
309a c1 30			dw .DO            
309c 03				db 2 + 1 
309d .. 00			db "ELSE",0              
30a2				endm 
# End of macro CWHEAD
30a2			; | ELSE ( -- ) Not supported - does nothing | TODO 
30a2			 
30a2					if DEBUG_FORTH_WORDS_KEY 
30a2						DMARK "ELS" 
30a2 f5				push af  
30a3 3a b7 30			ld a, (.dmark)  
30a6 32 6b ee			ld (debug_mark),a  
30a9 3a b8 30			ld a, (.dmark+1)  
30ac 32 6c ee			ld (debug_mark+1),a  
30af 3a b9 30			ld a, (.dmark+2)  
30b2 32 6d ee			ld (debug_mark+2),a  
30b5 18 03			jr .pastdmark  
30b7 ..			.dmark: db "ELS"  
30ba f1			.pastdmark: pop af  
30bb			endm  
# End of macro DMARK
30bb						CALLMONITOR 
30bb cd 6f ee			call debug_vector  
30be				endm  
# End of macro CALLMONITOR
30be					endif 
30be			 
30be			 
30be					NEXTW 
30be c3 f3 1f			jp macro_next 
30c1				endm 
# End of macro NEXTW
30c1			.DO: 
30c1				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
30c1 21				db WORD_SYS_CORE+13             
30c2 e8 31			dw .LOOP            
30c4 03				db 2 + 1 
30c5 .. 00			db "DO",0              
30c8				endm 
# End of macro CWHEAD
30c8			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
30c8			 
30c8					if DEBUG_FORTH_WORDS_KEY 
30c8						DMARK "DO." 
30c8 f5				push af  
30c9 3a dd 30			ld a, (.dmark)  
30cc 32 6b ee			ld (debug_mark),a  
30cf 3a de 30			ld a, (.dmark+1)  
30d2 32 6c ee			ld (debug_mark+1),a  
30d5 3a df 30			ld a, (.dmark+2)  
30d8 32 6d ee			ld (debug_mark+2),a  
30db 18 03			jr .pastdmark  
30dd ..			.dmark: db "DO."  
30e0 f1			.pastdmark: pop af  
30e1			endm  
# End of macro DMARK
30e1						CALLMONITOR 
30e1 cd 6f ee			call debug_vector  
30e4				endm  
# End of macro CALLMONITOR
30e4					endif 
30e4			;  push pc to rsp stack past the DO 
30e4			 
30e4 2a c2 e5				ld hl, (os_tok_ptr) 
30e7 23					inc hl   ; D 
30e8 23					inc hl  ; O 
30e9 23					inc hl   ; null 
30ea					if DEBUG_FORTH_WORDS 
30ea						DMARK "DO2" 
30ea f5				push af  
30eb 3a ff 30			ld a, (.dmark)  
30ee 32 6b ee			ld (debug_mark),a  
30f1 3a 00 31			ld a, (.dmark+1)  
30f4 32 6c ee			ld (debug_mark+1),a  
30f7 3a 01 31			ld a, (.dmark+2)  
30fa 32 6d ee			ld (debug_mark+2),a  
30fd 18 03			jr .pastdmark  
30ff ..			.dmark: db "DO2"  
3102 f1			.pastdmark: pop af  
3103			endm  
# End of macro DMARK
3103						CALLMONITOR 
3103 cd 6f ee			call debug_vector  
3106				endm  
# End of macro CALLMONITOR
3106					endif 
3106					FORTH_RSP_NEXT 
3106 cd ed 1b			call macro_forth_rsp_next 
3109				endm 
# End of macro FORTH_RSP_NEXT
3109					if DEBUG_FORTH_WORDS 
3109						DMARK "DO3" 
3109 f5				push af  
310a 3a 1e 31			ld a, (.dmark)  
310d 32 6b ee			ld (debug_mark),a  
3110 3a 1f 31			ld a, (.dmark+1)  
3113 32 6c ee			ld (debug_mark+1),a  
3116 3a 20 31			ld a, (.dmark+2)  
3119 32 6d ee			ld (debug_mark+2),a  
311c 18 03			jr .pastdmark  
311e ..			.dmark: db "DO3"  
3121 f1			.pastdmark: pop af  
3122			endm  
# End of macro DMARK
3122						CALLMONITOR 
3122 cd 6f ee			call debug_vector  
3125				endm  
# End of macro CALLMONITOR
3125					endif 
3125			 
3125					;if DEBUG_FORTH_WORDS 
3125				;		push hl 
3125			;		endif  
3125			 
3125			; get counters from data stack 
3125			 
3125			 
3125					FORTH_DSP_VALUEHL 
3125 cd 3d 1e			call macro_dsp_valuehl 
3128				endm 
# End of macro FORTH_DSP_VALUEHL
3128 e5					push hl		 ; hl now has starting counter which needs to be tos 
3129			 
3129					if DEBUG_FORTH_WORDS 
3129						DMARK "DO4" 
3129 f5				push af  
312a 3a 3e 31			ld a, (.dmark)  
312d 32 6b ee			ld (debug_mark),a  
3130 3a 3f 31			ld a, (.dmark+1)  
3133 32 6c ee			ld (debug_mark+1),a  
3136 3a 40 31			ld a, (.dmark+2)  
3139 32 6d ee			ld (debug_mark+2),a  
313c 18 03			jr .pastdmark  
313e ..			.dmark: db "DO4"  
3141 f1			.pastdmark: pop af  
3142			endm  
# End of macro DMARK
3142						CALLMONITOR 
3142 cd 6f ee			call debug_vector  
3145				endm  
# End of macro CALLMONITOR
3145					endif 
3145					FORTH_DSP_POP 
3145 cd f5 1e			call macro_forth_dsp_pop 
3148				endm 
# End of macro FORTH_DSP_POP
3148			 
3148					if DEBUG_FORTH_WORDS 
3148						DMARK "DO5" 
3148 f5				push af  
3149 3a 5d 31			ld a, (.dmark)  
314c 32 6b ee			ld (debug_mark),a  
314f 3a 5e 31			ld a, (.dmark+1)  
3152 32 6c ee			ld (debug_mark+1),a  
3155 3a 5f 31			ld a, (.dmark+2)  
3158 32 6d ee			ld (debug_mark+2),a  
315b 18 03			jr .pastdmark  
315d ..			.dmark: db "DO5"  
3160 f1			.pastdmark: pop af  
3161			endm  
# End of macro DMARK
3161						CALLMONITOR 
3161 cd 6f ee			call debug_vector  
3164				endm  
# End of macro CALLMONITOR
3164					endif 
3164			 
3164					FORTH_DSP_VALUEHL 
3164 cd 3d 1e			call macro_dsp_valuehl 
3167				endm 
# End of macro FORTH_DSP_VALUEHL
3167			;		push hl		 ; hl now has starting limit counter 
3167			 
3167					if DEBUG_FORTH_WORDS 
3167						DMARK "DO6" 
3167 f5				push af  
3168 3a 7c 31			ld a, (.dmark)  
316b 32 6b ee			ld (debug_mark),a  
316e 3a 7d 31			ld a, (.dmark+1)  
3171 32 6c ee			ld (debug_mark+1),a  
3174 3a 7e 31			ld a, (.dmark+2)  
3177 32 6d ee			ld (debug_mark+2),a  
317a 18 03			jr .pastdmark  
317c ..			.dmark: db "DO6"  
317f f1			.pastdmark: pop af  
3180			endm  
# End of macro DMARK
3180						CALLMONITOR 
3180 cd 6f ee			call debug_vector  
3183				endm  
# End of macro CALLMONITOR
3183					endif 
3183					FORTH_DSP_POP 
3183 cd f5 1e			call macro_forth_dsp_pop 
3186				endm 
# End of macro FORTH_DSP_POP
3186			 
3186			; put counters on the loop stack 
3186			 
3186			;		pop hl			 ; limit counter 
3186 d1					pop de			; start counter 
3187			 
3187					; push limit counter 
3187			 
3187					if DEBUG_FORTH_WORDS 
3187						DMARK "DO7" 
3187 f5				push af  
3188 3a 9c 31			ld a, (.dmark)  
318b 32 6b ee			ld (debug_mark),a  
318e 3a 9d 31			ld a, (.dmark+1)  
3191 32 6c ee			ld (debug_mark+1),a  
3194 3a 9e 31			ld a, (.dmark+2)  
3197 32 6d ee			ld (debug_mark+2),a  
319a 18 03			jr .pastdmark  
319c ..			.dmark: db "DO7"  
319f f1			.pastdmark: pop af  
31a0			endm  
# End of macro DMARK
31a0						CALLMONITOR 
31a0 cd 6f ee			call debug_vector  
31a3				endm  
# End of macro CALLMONITOR
31a3					endif 
31a3					FORTH_LOOP_NEXT 
31a3 cd 6e 1e			call macro_forth_loop_next 
31a6				endm 
# End of macro FORTH_LOOP_NEXT
31a6			 
31a6					; push start counter 
31a6			 
31a6 eb					ex de, hl 
31a7					if DEBUG_FORTH_WORDS 
31a7						DMARK "DO7" 
31a7 f5				push af  
31a8 3a bc 31			ld a, (.dmark)  
31ab 32 6b ee			ld (debug_mark),a  
31ae 3a bd 31			ld a, (.dmark+1)  
31b1 32 6c ee			ld (debug_mark+1),a  
31b4 3a be 31			ld a, (.dmark+2)  
31b7 32 6d ee			ld (debug_mark+2),a  
31ba 18 03			jr .pastdmark  
31bc ..			.dmark: db "DO7"  
31bf f1			.pastdmark: pop af  
31c0			endm  
# End of macro DMARK
31c0						CALLMONITOR 
31c0 cd 6f ee			call debug_vector  
31c3				endm  
# End of macro CALLMONITOR
31c3					endif 
31c3					FORTH_LOOP_NEXT 
31c3 cd 6e 1e			call macro_forth_loop_next 
31c6				endm 
# End of macro FORTH_LOOP_NEXT
31c6			 
31c6			 
31c6					; init first round of I counter 
31c6			 
31c6 22 e6 e5				ld (os_current_i), hl 
31c9			 
31c9					if DEBUG_FORTH_WORDS 
31c9						DMARK "DO8" 
31c9 f5				push af  
31ca 3a de 31			ld a, (.dmark)  
31cd 32 6b ee			ld (debug_mark),a  
31d0 3a df 31			ld a, (.dmark+1)  
31d3 32 6c ee			ld (debug_mark+1),a  
31d6 3a e0 31			ld a, (.dmark+2)  
31d9 32 6d ee			ld (debug_mark+2),a  
31dc 18 03			jr .pastdmark  
31de ..			.dmark: db "DO8"  
31e1 f1			.pastdmark: pop af  
31e2			endm  
# End of macro DMARK
31e2						CALLMONITOR 
31e2 cd 6f ee			call debug_vector  
31e5				endm  
# End of macro CALLMONITOR
31e5					endif 
31e5			 
31e5					NEXTW 
31e5 c3 f3 1f			jp macro_next 
31e8				endm 
# End of macro NEXTW
31e8			.LOOP: 
31e8				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
31e8 22				db WORD_SYS_CORE+14             
31e9 00 33			dw .I            
31eb 05				db 4 + 1 
31ec .. 00			db "LOOP",0              
31f1				endm 
# End of macro CWHEAD
31f1			; | LOOP ( -- ) Increment and test loop counter  | DONE 
31f1			 
31f1				; pop tos as current loop count to hl 
31f1			 
31f1				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
31f1			 
31f1				FORTH_LOOP_TOS 
31f1 cd a1 1e			call macro_forth_loop_tos 
31f4				endm 
# End of macro FORTH_LOOP_TOS
31f4 e5				push hl 
31f5			 
31f5					if DEBUG_FORTH_WORDS_KEY 
31f5						DMARK "LOP" 
31f5 f5				push af  
31f6 3a 0a 32			ld a, (.dmark)  
31f9 32 6b ee			ld (debug_mark),a  
31fc 3a 0b 32			ld a, (.dmark+1)  
31ff 32 6c ee			ld (debug_mark+1),a  
3202 3a 0c 32			ld a, (.dmark+2)  
3205 32 6d ee			ld (debug_mark+2),a  
3208 18 03			jr .pastdmark  
320a ..			.dmark: db "LOP"  
320d f1			.pastdmark: pop af  
320e			endm  
# End of macro DMARK
320e						CALLMONITOR 
320e cd 6f ee			call debug_vector  
3211				endm  
# End of macro CALLMONITOR
3211					endif 
3211				; next item on the stack is the limit. get it 
3211			 
3211			 
3211				FORTH_LOOP_POP 
3211 cd ab 1e			call macro_forth_loop_pop 
3214				endm 
# End of macro FORTH_LOOP_POP
3214			 
3214				FORTH_LOOP_TOS 
3214 cd a1 1e			call macro_forth_loop_tos 
3217				endm 
# End of macro FORTH_LOOP_TOS
3217			 
3217 d1				pop de		 ; de = i, hl = limit 
3218			 
3218					if DEBUG_FORTH_WORDS 
3218						DMARK "LP1" 
3218 f5				push af  
3219 3a 2d 32			ld a, (.dmark)  
321c 32 6b ee			ld (debug_mark),a  
321f 3a 2e 32			ld a, (.dmark+1)  
3222 32 6c ee			ld (debug_mark+1),a  
3225 3a 2f 32			ld a, (.dmark+2)  
3228 32 6d ee			ld (debug_mark+2),a  
322b 18 03			jr .pastdmark  
322d ..			.dmark: db "LP1"  
3230 f1			.pastdmark: pop af  
3231			endm  
# End of macro DMARK
3231						CALLMONITOR 
3231 cd 6f ee			call debug_vector  
3234				endm  
# End of macro CALLMONITOR
3234					endif 
3234			 
3234				; go back to previous word 
3234			 
3234 d5				push de    ; save I for inc later 
3235			 
3235			 
3235				; get limit 
3235				;  is I at limit? 
3235			 
3235			 
3235					if DEBUG_FORTH_WORDS 
3235						DMARK "LP1" 
3235 f5				push af  
3236 3a 4a 32			ld a, (.dmark)  
3239 32 6b ee			ld (debug_mark),a  
323c 3a 4b 32			ld a, (.dmark+1)  
323f 32 6c ee			ld (debug_mark+1),a  
3242 3a 4c 32			ld a, (.dmark+2)  
3245 32 6d ee			ld (debug_mark+2),a  
3248 18 03			jr .pastdmark  
324a ..			.dmark: db "LP1"  
324d f1			.pastdmark: pop af  
324e			endm  
# End of macro DMARK
324e						CALLMONITOR 
324e cd 6f ee			call debug_vector  
3251				endm  
# End of macro CALLMONITOR
3251					endif 
3251			 
3251 ed 52			sbc hl, de 
3253			 
3253			 
3253				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3253			 
3253 20 26				jr nz, .loopnotdone 
3255			 
3255 e1				pop hl   ; get rid of saved I 
3256				FORTH_LOOP_POP     ; get rid of limit 
3256 cd ab 1e			call macro_forth_loop_pop 
3259				endm 
# End of macro FORTH_LOOP_POP
3259			 
3259				FORTH_RSP_POP     ; get rid of DO ptr 
3259 cd 0e 1c			call macro_forth_rsp_pop 
325c				endm 
# End of macro FORTH_RSP_POP
325c			 
325c			if DEBUG_FORTH_WORDS 
325c						DMARK "LP>" 
325c f5				push af  
325d 3a 71 32			ld a, (.dmark)  
3260 32 6b ee			ld (debug_mark),a  
3263 3a 72 32			ld a, (.dmark+1)  
3266 32 6c ee			ld (debug_mark+1),a  
3269 3a 73 32			ld a, (.dmark+2)  
326c 32 6d ee			ld (debug_mark+2),a  
326f 18 03			jr .pastdmark  
3271 ..			.dmark: db "LP>"  
3274 f1			.pastdmark: pop af  
3275			endm  
# End of macro DMARK
3275				CALLMONITOR 
3275 cd 6f ee			call debug_vector  
3278				endm  
# End of macro CALLMONITOR
3278			endif 
3278			 
3278					NEXTW 
3278 c3 f3 1f			jp macro_next 
327b				endm 
# End of macro NEXTW
327b				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
327b			 
327b			.loopnotdone: 
327b			 
327b e1				pop hl    ; get I 
327c 23				inc hl 
327d			 
327d			   	; save new I 
327d			 
327d			 
327d					; set I counter 
327d			 
327d 22 e6 e5				ld (os_current_i), hl 
3280			 
3280					if DEBUG_FORTH_WORDS 
3280						DMARK "LPN" 
3280 f5				push af  
3281 3a 95 32			ld a, (.dmark)  
3284 32 6b ee			ld (debug_mark),a  
3287 3a 96 32			ld a, (.dmark+1)  
328a 32 6c ee			ld (debug_mark+1),a  
328d 3a 97 32			ld a, (.dmark+2)  
3290 32 6d ee			ld (debug_mark+2),a  
3293 18 03			jr .pastdmark  
3295 ..			.dmark: db "LPN"  
3298 f1			.pastdmark: pop af  
3299			endm  
# End of macro DMARK
3299					CALLMONITOR 
3299 cd 6f ee			call debug_vector  
329c				endm  
# End of macro CALLMONITOR
329c					endif 
329c					 
329c				FORTH_LOOP_NEXT 
329c cd 6e 1e			call macro_forth_loop_next 
329f				endm 
# End of macro FORTH_LOOP_NEXT
329f			 
329f			 
329f					if DEBUG_FORTH_WORDS 
329f eb						ex de,hl 
32a0					endif 
32a0			 
32a0			;	; get DO ptr 
32a0			; 
32a0					if DEBUG_FORTH_WORDS 
32a0						DMARK "LP7" 
32a0 f5				push af  
32a1 3a b5 32			ld a, (.dmark)  
32a4 32 6b ee			ld (debug_mark),a  
32a7 3a b6 32			ld a, (.dmark+1)  
32aa 32 6c ee			ld (debug_mark+1),a  
32ad 3a b7 32			ld a, (.dmark+2)  
32b0 32 6d ee			ld (debug_mark+2),a  
32b3 18 03			jr .pastdmark  
32b5 ..			.dmark: db "LP7"  
32b8 f1			.pastdmark: pop af  
32b9			endm  
# End of macro DMARK
32b9					CALLMONITOR 
32b9 cd 6f ee			call debug_vector  
32bc				endm  
# End of macro CALLMONITOR
32bc					endif 
32bc				FORTH_RSP_TOS 
32bc cd 04 1c			call macro_forth_rsp_tos 
32bf				endm 
# End of macro FORTH_RSP_TOS
32bf			 
32bf					if DEBUG_FORTH_WORDS 
32bf						DMARK "LP8" 
32bf f5				push af  
32c0 3a d4 32			ld a, (.dmark)  
32c3 32 6b ee			ld (debug_mark),a  
32c6 3a d5 32			ld a, (.dmark+1)  
32c9 32 6c ee			ld (debug_mark+1),a  
32cc 3a d6 32			ld a, (.dmark+2)  
32cf 32 6d ee			ld (debug_mark+2),a  
32d2 18 03			jr .pastdmark  
32d4 ..			.dmark: db "LP8"  
32d7 f1			.pastdmark: pop af  
32d8			endm  
# End of macro DMARK
32d8					CALLMONITOR 
32d8 cd 6f ee			call debug_vector  
32db				endm  
# End of macro CALLMONITOR
32db					endif 
32db				;push hl 
32db			 
32db				; not going to DO any more 
32db				; get rid of the RSP pointer as DO will add it back in 
32db				;FORTH_RSP_POP 
32db				;pop hl 
32db			 
32db				;ld hl,(cli_ret_sp) 
32db				;ld e, (hl) 
32db				;inc hl 
32db				;ld d, (hl) 
32db				;ex de,hl 
32db 22 c2 e5			ld (os_tok_ptr), hl 
32de					if DEBUG_FORTH_WORDS 
32de						DMARK "LP<" 
32de f5				push af  
32df 3a f3 32			ld a, (.dmark)  
32e2 32 6b ee			ld (debug_mark),a  
32e5 3a f4 32			ld a, (.dmark+1)  
32e8 32 6c ee			ld (debug_mark+1),a  
32eb 3a f5 32			ld a, (.dmark+2)  
32ee 32 6d ee			ld (debug_mark+2),a  
32f1 18 03			jr .pastdmark  
32f3 ..			.dmark: db "LP<"  
32f6 f1			.pastdmark: pop af  
32f7			endm  
# End of macro DMARK
32f7					CALLMONITOR 
32f7 cd 6f ee			call debug_vector  
32fa				endm  
# End of macro CALLMONITOR
32fa				endif 
32fa c3 84 20			jp exec1 
32fd			 
32fd					 
32fd			 
32fd			 
32fd					NEXTW 
32fd c3 f3 1f			jp macro_next 
3300				endm 
# End of macro NEXTW
3300			.I:  
3300			 
3300				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3300 5e				db WORD_SYS_CORE+74             
3301 2b 33			dw .DLOOP            
3303 02				db 1 + 1 
3304 .. 00			db "I",0              
3306				endm 
# End of macro CWHEAD
3306			; | I ( -- ) Current loop counter | DONE 
3306					if DEBUG_FORTH_WORDS_KEY 
3306						DMARK "I.." 
3306 f5				push af  
3307 3a 1b 33			ld a, (.dmark)  
330a 32 6b ee			ld (debug_mark),a  
330d 3a 1c 33			ld a, (.dmark+1)  
3310 32 6c ee			ld (debug_mark+1),a  
3313 3a 1d 33			ld a, (.dmark+2)  
3316 32 6d ee			ld (debug_mark+2),a  
3319 18 03			jr .pastdmark  
331b ..			.dmark: db "I.."  
331e f1			.pastdmark: pop af  
331f			endm  
# End of macro DMARK
331f						CALLMONITOR 
331f cd 6f ee			call debug_vector  
3322				endm  
# End of macro CALLMONITOR
3322					endif 
3322			 
3322 2a e6 e5				ld hl,(os_current_i) 
3325 cd 46 1c				call forth_push_numhl 
3328			 
3328					NEXTW 
3328 c3 f3 1f			jp macro_next 
332b				endm 
# End of macro NEXTW
332b			.DLOOP: 
332b				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
332b 5f				db WORD_SYS_CORE+75             
332c 0c 34			dw .REPEAT            
332e 06				db 5 + 1 
332f .. 00			db "-LOOP",0              
3335				endm 
# End of macro CWHEAD
3335			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3335				; pop tos as current loop count to hl 
3335					if DEBUG_FORTH_WORDS_KEY 
3335						DMARK "-LP" 
3335 f5				push af  
3336 3a 4a 33			ld a, (.dmark)  
3339 32 6b ee			ld (debug_mark),a  
333c 3a 4b 33			ld a, (.dmark+1)  
333f 32 6c ee			ld (debug_mark+1),a  
3342 3a 4c 33			ld a, (.dmark+2)  
3345 32 6d ee			ld (debug_mark+2),a  
3348 18 03			jr .pastdmark  
334a ..			.dmark: db "-LP"  
334d f1			.pastdmark: pop af  
334e			endm  
# End of macro DMARK
334e						CALLMONITOR 
334e cd 6f ee			call debug_vector  
3351				endm  
# End of macro CALLMONITOR
3351					endif 
3351			 
3351				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3351			 
3351				FORTH_LOOP_TOS 
3351 cd a1 1e			call macro_forth_loop_tos 
3354				endm 
# End of macro FORTH_LOOP_TOS
3354 e5				push hl 
3355			 
3355					if DEBUG_FORTH_WORDS 
3355						DMARK "-LP" 
3355 f5				push af  
3356 3a 6a 33			ld a, (.dmark)  
3359 32 6b ee			ld (debug_mark),a  
335c 3a 6b 33			ld a, (.dmark+1)  
335f 32 6c ee			ld (debug_mark+1),a  
3362 3a 6c 33			ld a, (.dmark+2)  
3365 32 6d ee			ld (debug_mark+2),a  
3368 18 03			jr .pastdmark  
336a ..			.dmark: db "-LP"  
336d f1			.pastdmark: pop af  
336e			endm  
# End of macro DMARK
336e						CALLMONITOR 
336e cd 6f ee			call debug_vector  
3371				endm  
# End of macro CALLMONITOR
3371					endif 
3371				; next item on the stack is the limit. get it 
3371			 
3371			 
3371				FORTH_LOOP_POP 
3371 cd ab 1e			call macro_forth_loop_pop 
3374				endm 
# End of macro FORTH_LOOP_POP
3374			 
3374				FORTH_LOOP_TOS 
3374 cd a1 1e			call macro_forth_loop_tos 
3377				endm 
# End of macro FORTH_LOOP_TOS
3377			 
3377 d1				pop de		 ; de = i, hl = limit 
3378			 
3378					if DEBUG_FORTH_WORDS 
3378						DMARK "-L1" 
3378 f5				push af  
3379 3a 8d 33			ld a, (.dmark)  
337c 32 6b ee			ld (debug_mark),a  
337f 3a 8e 33			ld a, (.dmark+1)  
3382 32 6c ee			ld (debug_mark+1),a  
3385 3a 8f 33			ld a, (.dmark+2)  
3388 32 6d ee			ld (debug_mark+2),a  
338b 18 03			jr .pastdmark  
338d ..			.dmark: db "-L1"  
3390 f1			.pastdmark: pop af  
3391			endm  
# End of macro DMARK
3391						CALLMONITOR 
3391 cd 6f ee			call debug_vector  
3394				endm  
# End of macro CALLMONITOR
3394					endif 
3394			 
3394				; go back to previous word 
3394			 
3394 d5				push de    ; save I for inc later 
3395			 
3395			 
3395				; get limit 
3395				;  is I at limit? 
3395			 
3395			 
3395					if DEBUG_FORTH_WORDS 
3395						DMARK "-L1" 
3395 f5				push af  
3396 3a aa 33			ld a, (.dmark)  
3399 32 6b ee			ld (debug_mark),a  
339c 3a ab 33			ld a, (.dmark+1)  
339f 32 6c ee			ld (debug_mark+1),a  
33a2 3a ac 33			ld a, (.dmark+2)  
33a5 32 6d ee			ld (debug_mark+2),a  
33a8 18 03			jr .pastdmark  
33aa ..			.dmark: db "-L1"  
33ad f1			.pastdmark: pop af  
33ae			endm  
# End of macro DMARK
33ae						CALLMONITOR 
33ae cd 6f ee			call debug_vector  
33b1				endm  
# End of macro CALLMONITOR
33b1					endif 
33b1			 
33b1 ed 52			sbc hl, de 
33b3			 
33b3			 
33b3				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
33b3			 
33b3 20 26				jr nz, .mloopnotdone 
33b5			 
33b5 e1				pop hl   ; get rid of saved I 
33b6				FORTH_LOOP_POP     ; get rid of limit 
33b6 cd ab 1e			call macro_forth_loop_pop 
33b9				endm 
# End of macro FORTH_LOOP_POP
33b9			 
33b9				FORTH_RSP_POP     ; get rid of DO ptr 
33b9 cd 0e 1c			call macro_forth_rsp_pop 
33bc				endm 
# End of macro FORTH_RSP_POP
33bc			 
33bc			if DEBUG_FORTH_WORDS 
33bc						DMARK "-L>" 
33bc f5				push af  
33bd 3a d1 33			ld a, (.dmark)  
33c0 32 6b ee			ld (debug_mark),a  
33c3 3a d2 33			ld a, (.dmark+1)  
33c6 32 6c ee			ld (debug_mark+1),a  
33c9 3a d3 33			ld a, (.dmark+2)  
33cc 32 6d ee			ld (debug_mark+2),a  
33cf 18 03			jr .pastdmark  
33d1 ..			.dmark: db "-L>"  
33d4 f1			.pastdmark: pop af  
33d5			endm  
# End of macro DMARK
33d5				CALLMONITOR 
33d5 cd 6f ee			call debug_vector  
33d8				endm  
# End of macro CALLMONITOR
33d8			endif 
33d8			 
33d8					NEXTW 
33d8 c3 f3 1f			jp macro_next 
33db				endm 
# End of macro NEXTW
33db				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
33db			 
33db			.mloopnotdone: 
33db			 
33db e1				pop hl    ; get I 
33dc 2b				dec hl 
33dd			 
33dd			   	; save new I 
33dd			 
33dd			 
33dd					; set I counter 
33dd			 
33dd 22 e6 e5				ld (os_current_i), hl 
33e0			 
33e0					 
33e0				FORTH_LOOP_NEXT 
33e0 cd 6e 1e			call macro_forth_loop_next 
33e3				endm 
# End of macro FORTH_LOOP_NEXT
33e3			 
33e3			 
33e3					if DEBUG_FORTH_WORDS 
33e3 eb						ex de,hl 
33e4					endif 
33e4			 
33e4			;	; get DO ptr 
33e4			; 
33e4				FORTH_RSP_TOS 
33e4 cd 04 1c			call macro_forth_rsp_tos 
33e7				endm 
# End of macro FORTH_RSP_TOS
33e7			 
33e7				;push hl 
33e7			 
33e7				; not going to DO any more 
33e7				; get rid of the RSP pointer as DO will add it back in 
33e7				;FORTH_RSP_POP 
33e7				;pop hl 
33e7			 
33e7			 
33e7 22 c2 e5			ld (os_tok_ptr), hl 
33ea					if DEBUG_FORTH_WORDS 
33ea						DMARK "-L<" 
33ea f5				push af  
33eb 3a ff 33			ld a, (.dmark)  
33ee 32 6b ee			ld (debug_mark),a  
33f1 3a 00 34			ld a, (.dmark+1)  
33f4 32 6c ee			ld (debug_mark+1),a  
33f7 3a 01 34			ld a, (.dmark+2)  
33fa 32 6d ee			ld (debug_mark+2),a  
33fd 18 03			jr .pastdmark  
33ff ..			.dmark: db "-L<"  
3402 f1			.pastdmark: pop af  
3403			endm  
# End of macro DMARK
3403					CALLMONITOR 
3403 cd 6f ee			call debug_vector  
3406				endm  
# End of macro CALLMONITOR
3406				endif 
3406 c3 84 20			jp exec1 
3409			 
3409					 
3409			 
3409			 
3409			 
3409				NEXTW 
3409 c3 f3 1f			jp macro_next 
340c				endm 
# End of macro NEXTW
340c			 
340c			 
340c			 
340c			 
340c			.REPEAT: 
340c				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
340c 71				db WORD_SYS_CORE+93             
340d 5f 34			dw .UNTIL            
340f 06				db 5 + 1 
3410 .. 00			db "REPEAT",0              
3417				endm 
# End of macro CWHEAD
3417			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3417			;  push pc to rsp stack past the REPEAT 
3417					if DEBUG_FORTH_WORDS_KEY 
3417						DMARK "REP" 
3417 f5				push af  
3418 3a 2c 34			ld a, (.dmark)  
341b 32 6b ee			ld (debug_mark),a  
341e 3a 2d 34			ld a, (.dmark+1)  
3421 32 6c ee			ld (debug_mark+1),a  
3424 3a 2e 34			ld a, (.dmark+2)  
3427 32 6d ee			ld (debug_mark+2),a  
342a 18 03			jr .pastdmark  
342c ..			.dmark: db "REP"  
342f f1			.pastdmark: pop af  
3430			endm  
# End of macro DMARK
3430						CALLMONITOR 
3430 cd 6f ee			call debug_vector  
3433				endm  
# End of macro CALLMONITOR
3433					endif 
3433			 
3433 2a c2 e5				ld hl, (os_tok_ptr) 
3436 23					inc hl   ; R 
3437 23					inc hl  ; E 
3438 23					inc hl   ; P 
3439 23					inc hl   ; E 
343a 23					inc hl   ; A 
343b 23					inc hl   ; T 
343c 23					inc hl   ; zero 
343d					FORTH_RSP_NEXT 
343d cd ed 1b			call macro_forth_rsp_next 
3440				endm 
# End of macro FORTH_RSP_NEXT
3440			 
3440			 
3440					if DEBUG_FORTH_WORDS 
3440						DMARK "REP" 
3440 f5				push af  
3441 3a 55 34			ld a, (.dmark)  
3444 32 6b ee			ld (debug_mark),a  
3447 3a 56 34			ld a, (.dmark+1)  
344a 32 6c ee			ld (debug_mark+1),a  
344d 3a 57 34			ld a, (.dmark+2)  
3450 32 6d ee			ld (debug_mark+2),a  
3453 18 03			jr .pastdmark  
3455 ..			.dmark: db "REP"  
3458 f1			.pastdmark: pop af  
3459			endm  
# End of macro DMARK
3459						;pop bc    ; TODO BUG ?????? what is this for???? 
3459						CALLMONITOR 
3459 cd 6f ee			call debug_vector  
345c				endm  
# End of macro CALLMONITOR
345c					endif 
345c			 
345c					NEXTW 
345c c3 f3 1f			jp macro_next 
345f				endm 
# End of macro NEXTW
345f			;	       NEXTW 
345f			 
345f			.UNTIL: 
345f				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
345f 72				db WORD_SYS_CORE+94             
3460 f6 34			dw .ENDFLOW            
3462 06				db 5 + 1 
3463 .. 00			db "UNTIL",0              
3469				endm 
# End of macro CWHEAD
3469			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3469			 
3469				; pop tos as check 
3469			 
3469				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3469			 
3469				FORTH_DSP_VALUEHL 
3469 cd 3d 1e			call macro_dsp_valuehl 
346c				endm 
# End of macro FORTH_DSP_VALUEHL
346c			 
346c					if DEBUG_FORTH_WORDS_KEY 
346c						DMARK "UNT" 
346c f5				push af  
346d 3a 81 34			ld a, (.dmark)  
3470 32 6b ee			ld (debug_mark),a  
3473 3a 82 34			ld a, (.dmark+1)  
3476 32 6c ee			ld (debug_mark+1),a  
3479 3a 83 34			ld a, (.dmark+2)  
347c 32 6d ee			ld (debug_mark+2),a  
347f 18 03			jr .pastdmark  
3481 ..			.dmark: db "UNT"  
3484 f1			.pastdmark: pop af  
3485			endm  
# End of macro DMARK
3485						CALLMONITOR 
3485 cd 6f ee			call debug_vector  
3488				endm  
# End of macro CALLMONITOR
3488					endif 
3488			 
3488			;	push hl 
3488				FORTH_DSP_POP 
3488 cd f5 1e			call macro_forth_dsp_pop 
348b				endm 
# End of macro FORTH_DSP_POP
348b			 
348b			;	pop hl 
348b			 
348b				; test if true 
348b			 
348b cd 0f 0e			call ishlzero 
348e			;	ld a,l 
348e			;	add h 
348e			; 
348e			;	cp 0 
348e			 
348e 20 3e			jr nz, .untilnotdone 
3490			 
3490					if DEBUG_FORTH_WORDS 
3490						DMARK "UNf" 
3490 f5				push af  
3491 3a a5 34			ld a, (.dmark)  
3494 32 6b ee			ld (debug_mark),a  
3497 3a a6 34			ld a, (.dmark+1)  
349a 32 6c ee			ld (debug_mark+1),a  
349d 3a a7 34			ld a, (.dmark+2)  
34a0 32 6d ee			ld (debug_mark+2),a  
34a3 18 03			jr .pastdmark  
34a5 ..			.dmark: db "UNf"  
34a8 f1			.pastdmark: pop af  
34a9			endm  
# End of macro DMARK
34a9						CALLMONITOR 
34a9 cd 6f ee			call debug_vector  
34ac				endm  
# End of macro CALLMONITOR
34ac					endif 
34ac			 
34ac			 
34ac			 
34ac				FORTH_RSP_POP     ; get rid of DO ptr 
34ac cd 0e 1c			call macro_forth_rsp_pop 
34af				endm 
# End of macro FORTH_RSP_POP
34af			 
34af			if DEBUG_FORTH_WORDS 
34af						DMARK "UN>" 
34af f5				push af  
34b0 3a c4 34			ld a, (.dmark)  
34b3 32 6b ee			ld (debug_mark),a  
34b6 3a c5 34			ld a, (.dmark+1)  
34b9 32 6c ee			ld (debug_mark+1),a  
34bc 3a c6 34			ld a, (.dmark+2)  
34bf 32 6d ee			ld (debug_mark+2),a  
34c2 18 03			jr .pastdmark  
34c4 ..			.dmark: db "UN>"  
34c7 f1			.pastdmark: pop af  
34c8			endm  
# End of macro DMARK
34c8				CALLMONITOR 
34c8 cd 6f ee			call debug_vector  
34cb				endm  
# End of macro CALLMONITOR
34cb			endif 
34cb			 
34cb					NEXTW 
34cb c3 f3 1f			jp macro_next 
34ce				endm 
# End of macro NEXTW
34ce				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
34ce			 
34ce			.untilnotdone: 
34ce			 
34ce			 
34ce			;	; get DO ptr 
34ce			; 
34ce				FORTH_RSP_TOS 
34ce cd 04 1c			call macro_forth_rsp_tos 
34d1				endm 
# End of macro FORTH_RSP_TOS
34d1			 
34d1				;push hl 
34d1			 
34d1				; not going to DO any more 
34d1				; get rid of the RSP pointer as DO will add it back in 
34d1				;FORTH_RSP_POP 
34d1				;pop hl 
34d1			 
34d1			 
34d1 22 c2 e5			ld (os_tok_ptr), hl 
34d4					if DEBUG_FORTH_WORDS 
34d4						DMARK "UN<" 
34d4 f5				push af  
34d5 3a e9 34			ld a, (.dmark)  
34d8 32 6b ee			ld (debug_mark),a  
34db 3a ea 34			ld a, (.dmark+1)  
34de 32 6c ee			ld (debug_mark+1),a  
34e1 3a eb 34			ld a, (.dmark+2)  
34e4 32 6d ee			ld (debug_mark+2),a  
34e7 18 03			jr .pastdmark  
34e9 ..			.dmark: db "UN<"  
34ec f1			.pastdmark: pop af  
34ed			endm  
# End of macro DMARK
34ed					CALLMONITOR 
34ed cd 6f ee			call debug_vector  
34f0				endm  
# End of macro CALLMONITOR
34f0				endif 
34f0 c3 84 20			jp exec1 
34f3			 
34f3					 
34f3			 
34f3			 
34f3					NEXTW 
34f3 c3 f3 1f			jp macro_next 
34f6				endm 
# End of macro NEXTW
34f6			 
34f6			 
34f6			.ENDFLOW: 
34f6			 
34f6			; eof 
34f6			 
# End of file forth_words_flow.asm
34f6			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
34f6			include "forth_words_logic.asm" 
34f6			 
34f6			; | ## Logic Words 
34f6			 
34f6			.NOT: 
34f6				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
34f6 2d				db WORD_SYS_CORE+25             
34f7 3e 35			dw .IS            
34f9 04				db 3 + 1 
34fa .. 00			db "NOT",0              
34fe				endm 
# End of macro CWHEAD
34fe			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
34fe					if DEBUG_FORTH_WORDS_KEY 
34fe						DMARK "NOT" 
34fe f5				push af  
34ff 3a 13 35			ld a, (.dmark)  
3502 32 6b ee			ld (debug_mark),a  
3505 3a 14 35			ld a, (.dmark+1)  
3508 32 6c ee			ld (debug_mark+1),a  
350b 3a 15 35			ld a, (.dmark+2)  
350e 32 6d ee			ld (debug_mark+2),a  
3511 18 03			jr .pastdmark  
3513 ..			.dmark: db "NOT"  
3516 f1			.pastdmark: pop af  
3517			endm  
# End of macro DMARK
3517						CALLMONITOR 
3517 cd 6f ee			call debug_vector  
351a				endm  
# End of macro CALLMONITOR
351a					endif 
351a					FORTH_DSP 
351a cd 03 1e			call macro_forth_dsp 
351d				endm 
# End of macro FORTH_DSP
351d 7e					ld a,(hl)	; get type of value on TOS 
351e fe 02				cp DS_TYPE_INUM  
3520 28 03				jr z, .noti 
3522					NEXTW 
3522 c3 f3 1f			jp macro_next 
3525				endm 
# End of macro NEXTW
3525			.noti:          FORTH_DSP_VALUEHL 
3525 cd 3d 1e			call macro_dsp_valuehl 
3528				endm 
# End of macro FORTH_DSP_VALUEHL
3528			;		push hl 
3528					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3528 cd f5 1e			call macro_forth_dsp_pop 
352b				endm 
# End of macro FORTH_DSP_POP
352b			;		pop hl 
352b 3e 00				ld a,0 
352d bd					cp l 
352e 28 04				jr z, .not2t 
3530 2e 00				ld l, 0 
3532 18 02				jr .notip 
3534			 
3534 2e ff		.not2t:		ld l, 255 
3536			 
3536 26 00		.notip:		ld h, 0	 
3538			 
3538 cd 46 1c				call forth_push_numhl 
353b					NEXTW 
353b c3 f3 1f			jp macro_next 
353e				endm 
# End of macro NEXTW
353e			 
353e			.IS: 
353e				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
353e 2d				db WORD_SYS_CORE+25             
353f 64 35			dw .LZERO            
3541 03				db 2 + 1 
3542 .. 00			db "IS",0              
3545				endm 
# End of macro CWHEAD
3545			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3545					if DEBUG_FORTH_WORDS_KEY 
3545						DMARK "IS." 
3545 f5				push af  
3546 3a 5a 35			ld a, (.dmark)  
3549 32 6b ee			ld (debug_mark),a  
354c 3a 5b 35			ld a, (.dmark+1)  
354f 32 6c ee			ld (debug_mark+1),a  
3552 3a 5c 35			ld a, (.dmark+2)  
3555 32 6d ee			ld (debug_mark+2),a  
3558 18 03			jr .pastdmark  
355a ..			.dmark: db "IS."  
355d f1			.pastdmark: pop af  
355e			endm  
# End of macro DMARK
355e						CALLMONITOR 
355e cd 6f ee			call debug_vector  
3561				endm  
# End of macro CALLMONITOR
3561					endif 
3561					NEXTW 
3561 c3 f3 1f			jp macro_next 
3564				endm 
# End of macro NEXTW
3564			.LZERO: 
3564				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3564 2d				db WORD_SYS_CORE+25             
3565 6e 35			dw .TZERO            
3567 03				db 2 + 1 
3568 .. 00			db "0<",0              
356b				endm 
# End of macro CWHEAD
356b			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
356b					NEXTW 
356b c3 f3 1f			jp macro_next 
356e				endm 
# End of macro NEXTW
356e			.TZERO: 
356e				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
356e 2e				db WORD_SYS_CORE+26             
356f b5 35			dw .LESS            
3571 03				db 2 + 1 
3572 .. 00			db "0=",0              
3575				endm 
# End of macro CWHEAD
3575			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3575				; TODO add floating point number detection 
3575					;v5 FORTH_DSP_VALUE 
3575					if DEBUG_FORTH_WORDS_KEY 
3575						DMARK "0=." 
3575 f5				push af  
3576 3a 8a 35			ld a, (.dmark)  
3579 32 6b ee			ld (debug_mark),a  
357c 3a 8b 35			ld a, (.dmark+1)  
357f 32 6c ee			ld (debug_mark+1),a  
3582 3a 8c 35			ld a, (.dmark+2)  
3585 32 6d ee			ld (debug_mark+2),a  
3588 18 03			jr .pastdmark  
358a ..			.dmark: db "0=."  
358d f1			.pastdmark: pop af  
358e			endm  
# End of macro DMARK
358e						CALLMONITOR 
358e cd 6f ee			call debug_vector  
3591				endm  
# End of macro CALLMONITOR
3591					endif 
3591					FORTH_DSP 
3591 cd 03 1e			call macro_forth_dsp 
3594				endm 
# End of macro FORTH_DSP
3594 7e					ld a,(hl)	; get type of value on TOS 
3595 fe 02				cp DS_TYPE_INUM  
3597 28 00				jr z, .tz_inum 
3599			 
3599				if FORTH_ENABLE_FLOATMATH 
3599					jr .tz_done 
3599			 
3599				endif 
3599					 
3599			 
3599			.tz_inum: 
3599					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3599 cd 3d 1e			call macro_dsp_valuehl 
359c				endm 
# End of macro FORTH_DSP_VALUEHL
359c			 
359c			;		push hl 
359c			 
359c					; destroy value TOS 
359c			 
359c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
359c cd f5 1e			call macro_forth_dsp_pop 
359f				endm 
# End of macro FORTH_DSP_POP
359f			 
359f			;		pop hl 
359f			 
359f 3e 00				ld a,0 
35a1			 
35a1 bd					cp l 
35a2 20 08				jr nz, .tz_notzero 
35a4			 
35a4 bc					cp h 
35a5			 
35a5 20 05				jr nz, .tz_notzero 
35a7			 
35a7			 
35a7 21 01 00				ld hl, FORTH_TRUE 
35aa 18 03				jr .tz_done 
35ac			 
35ac 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
35af			 
35af					; push value back onto stack for another op etc 
35af			 
35af			.tz_done: 
35af cd 46 1c				call forth_push_numhl 
35b2			 
35b2					NEXTW 
35b2 c3 f3 1f			jp macro_next 
35b5				endm 
# End of macro NEXTW
35b5			.LESS: 
35b5				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
35b5 2f				db WORD_SYS_CORE+27             
35b6 1e 36			dw .GT            
35b8 02				db 1 + 1 
35b9 .. 00			db "<",0              
35bb				endm 
# End of macro CWHEAD
35bb			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
35bb				; TODO add floating point number detection 
35bb					if DEBUG_FORTH_WORDS_KEY 
35bb						DMARK "LES" 
35bb f5				push af  
35bc 3a d0 35			ld a, (.dmark)  
35bf 32 6b ee			ld (debug_mark),a  
35c2 3a d1 35			ld a, (.dmark+1)  
35c5 32 6c ee			ld (debug_mark+1),a  
35c8 3a d2 35			ld a, (.dmark+2)  
35cb 32 6d ee			ld (debug_mark+2),a  
35ce 18 03			jr .pastdmark  
35d0 ..			.dmark: db "LES"  
35d3 f1			.pastdmark: pop af  
35d4			endm  
# End of macro DMARK
35d4						CALLMONITOR 
35d4 cd 6f ee			call debug_vector  
35d7				endm  
# End of macro CALLMONITOR
35d7					endif 
35d7					FORTH_DSP 
35d7 cd 03 1e			call macro_forth_dsp 
35da				endm 
# End of macro FORTH_DSP
35da					;v5 FORTH_DSP_VALUE 
35da 7e					ld a,(hl)	; get type of value on TOS 
35db fe 02				cp DS_TYPE_INUM  
35dd 28 00				jr z, .less_inum 
35df			 
35df				if FORTH_ENABLE_FLOATMATH 
35df					jr .less_done 
35df			 
35df				endif 
35df					 
35df			 
35df			.less_inum: 
35df					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35df cd 3d 1e			call macro_dsp_valuehl 
35e2				endm 
# End of macro FORTH_DSP_VALUEHL
35e2			 
35e2 e5					push hl  ; u2 
35e3			 
35e3					; destroy value TOS 
35e3			 
35e3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35e3 cd f5 1e			call macro_forth_dsp_pop 
35e6				endm 
# End of macro FORTH_DSP_POP
35e6			 
35e6			 
35e6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35e6 cd 3d 1e			call macro_dsp_valuehl 
35e9				endm 
# End of macro FORTH_DSP_VALUEHL
35e9			 
35e9 e5					push hl    ; u1 
35ea			 
35ea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35ea cd f5 1e			call macro_forth_dsp_pop 
35ed				endm 
# End of macro FORTH_DSP_POP
35ed			 
35ed			 
35ed b7			 or a      ;clear carry flag 
35ee 01 00 00		 ld bc, FORTH_FALSE 
35f1 e1			  pop hl    ; u1 
35f2 d1			  pop de    ; u2 
35f3 ed 52		  sbc hl,de 
35f5 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
35f7			 
35f7 01 01 00		 ld bc, FORTH_TRUE 
35fa			.lscont:  
35fa c5					push bc 
35fb e1					pop hl 
35fc			 
35fc					if DEBUG_FORTH_WORDS 
35fc						DMARK "LT1" 
35fc f5				push af  
35fd 3a 11 36			ld a, (.dmark)  
3600 32 6b ee			ld (debug_mark),a  
3603 3a 12 36			ld a, (.dmark+1)  
3606 32 6c ee			ld (debug_mark+1),a  
3609 3a 13 36			ld a, (.dmark+2)  
360c 32 6d ee			ld (debug_mark+2),a  
360f 18 03			jr .pastdmark  
3611 ..			.dmark: db "LT1"  
3614 f1			.pastdmark: pop af  
3615			endm  
# End of macro DMARK
3615						CALLMONITOR 
3615 cd 6f ee			call debug_vector  
3618				endm  
# End of macro CALLMONITOR
3618					endif 
3618 cd 46 1c				call forth_push_numhl 
361b			 
361b					NEXTW 
361b c3 f3 1f			jp macro_next 
361e				endm 
# End of macro NEXTW
361e			.GT: 
361e				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
361e 30				db WORD_SYS_CORE+28             
361f 87 36			dw .EQUAL            
3621 02				db 1 + 1 
3622 .. 00			db ">",0              
3624				endm 
# End of macro CWHEAD
3624			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3624				; TODO add floating point number detection 
3624					if DEBUG_FORTH_WORDS_KEY 
3624						DMARK "GRT" 
3624 f5				push af  
3625 3a 39 36			ld a, (.dmark)  
3628 32 6b ee			ld (debug_mark),a  
362b 3a 3a 36			ld a, (.dmark+1)  
362e 32 6c ee			ld (debug_mark+1),a  
3631 3a 3b 36			ld a, (.dmark+2)  
3634 32 6d ee			ld (debug_mark+2),a  
3637 18 03			jr .pastdmark  
3639 ..			.dmark: db "GRT"  
363c f1			.pastdmark: pop af  
363d			endm  
# End of macro DMARK
363d						CALLMONITOR 
363d cd 6f ee			call debug_vector  
3640				endm  
# End of macro CALLMONITOR
3640					endif 
3640					FORTH_DSP 
3640 cd 03 1e			call macro_forth_dsp 
3643				endm 
# End of macro FORTH_DSP
3643					;FORTH_DSP_VALUE 
3643 7e					ld a,(hl)	; get type of value on TOS 
3644 fe 02				cp DS_TYPE_INUM  
3646 28 00				jr z, .gt_inum 
3648			 
3648				if FORTH_ENABLE_FLOATMATH 
3648					jr .gt_done 
3648			 
3648				endif 
3648					 
3648			 
3648			.gt_inum: 
3648					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3648 cd 3d 1e			call macro_dsp_valuehl 
364b				endm 
# End of macro FORTH_DSP_VALUEHL
364b			 
364b e5					push hl  ; u2 
364c			 
364c					; destroy value TOS 
364c			 
364c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
364c cd f5 1e			call macro_forth_dsp_pop 
364f				endm 
# End of macro FORTH_DSP_POP
364f			 
364f			 
364f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
364f cd 3d 1e			call macro_dsp_valuehl 
3652				endm 
# End of macro FORTH_DSP_VALUEHL
3652			 
3652 e5					push hl    ; u1 
3653			 
3653					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3653 cd f5 1e			call macro_forth_dsp_pop 
3656				endm 
# End of macro FORTH_DSP_POP
3656			 
3656			 
3656 b7			 or a      ;clear carry flag 
3657 01 00 00		 ld bc, FORTH_FALSE 
365a e1			  pop hl    ; u1 
365b d1			  pop de    ; u2 
365c ed 52		  sbc hl,de 
365e 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3660			 
3660 01 01 00		 ld bc, FORTH_TRUE 
3663			.gtcont:  
3663 c5					push bc 
3664 e1					pop hl 
3665			 
3665					if DEBUG_FORTH_WORDS 
3665						DMARK "GT1" 
3665 f5				push af  
3666 3a 7a 36			ld a, (.dmark)  
3669 32 6b ee			ld (debug_mark),a  
366c 3a 7b 36			ld a, (.dmark+1)  
366f 32 6c ee			ld (debug_mark+1),a  
3672 3a 7c 36			ld a, (.dmark+2)  
3675 32 6d ee			ld (debug_mark+2),a  
3678 18 03			jr .pastdmark  
367a ..			.dmark: db "GT1"  
367d f1			.pastdmark: pop af  
367e			endm  
# End of macro DMARK
367e						CALLMONITOR 
367e cd 6f ee			call debug_vector  
3681				endm  
# End of macro CALLMONITOR
3681					endif 
3681 cd 46 1c				call forth_push_numhl 
3684			 
3684					NEXTW 
3684 c3 f3 1f			jp macro_next 
3687				endm 
# End of macro NEXTW
3687			.EQUAL: 
3687				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3687 31				db WORD_SYS_CORE+29             
3688 f2 36			dw .ENDLOGIC            
368a 02				db 1 + 1 
368b .. 00			db "=",0              
368d				endm 
# End of macro CWHEAD
368d			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
368d				; TODO add floating point number detection 
368d					if DEBUG_FORTH_WORDS_KEY 
368d						DMARK "EQ." 
368d f5				push af  
368e 3a a2 36			ld a, (.dmark)  
3691 32 6b ee			ld (debug_mark),a  
3694 3a a3 36			ld a, (.dmark+1)  
3697 32 6c ee			ld (debug_mark+1),a  
369a 3a a4 36			ld a, (.dmark+2)  
369d 32 6d ee			ld (debug_mark+2),a  
36a0 18 03			jr .pastdmark  
36a2 ..			.dmark: db "EQ."  
36a5 f1			.pastdmark: pop af  
36a6			endm  
# End of macro DMARK
36a6						CALLMONITOR 
36a6 cd 6f ee			call debug_vector  
36a9				endm  
# End of macro CALLMONITOR
36a9					endif 
36a9					FORTH_DSP 
36a9 cd 03 1e			call macro_forth_dsp 
36ac				endm 
# End of macro FORTH_DSP
36ac					;v5 FORTH_DSP_VALUE 
36ac 7e					ld a,(hl)	; get type of value on TOS 
36ad fe 02				cp DS_TYPE_INUM  
36af 28 00				jr z, .eq_inum 
36b1			 
36b1				if FORTH_ENABLE_FLOATMATH 
36b1					jr .eq_done 
36b1			 
36b1				endif 
36b1					 
36b1			 
36b1			.eq_inum: 
36b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36b1 cd 3d 1e			call macro_dsp_valuehl 
36b4				endm 
# End of macro FORTH_DSP_VALUEHL
36b4			 
36b4 e5					push hl 
36b5			 
36b5					; destroy value TOS 
36b5			 
36b5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36b5 cd f5 1e			call macro_forth_dsp_pop 
36b8				endm 
# End of macro FORTH_DSP_POP
36b8			 
36b8			 
36b8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36b8 cd 3d 1e			call macro_dsp_valuehl 
36bb				endm 
# End of macro FORTH_DSP_VALUEHL
36bb			 
36bb					; one value on hl get other one back 
36bb			 
36bb e5					push hl 
36bc			 
36bc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36bc cd f5 1e			call macro_forth_dsp_pop 
36bf				endm 
# End of macro FORTH_DSP_POP
36bf			 
36bf 0e 00				ld c, FORTH_FALSE 
36c1			 
36c1 e1					pop hl 
36c2 d1					pop de 
36c3			 
36c3 7b					ld a, e 
36c4 bd					cp l 
36c5			 
36c5 20 06				jr nz, .eq_done 
36c7			 
36c7 7a					ld a, d 
36c8 bc					cp h 
36c9			 
36c9 20 02				jr nz, .eq_done 
36cb			 
36cb 0e 01				ld c, FORTH_TRUE 
36cd					 
36cd			 
36cd			 
36cd			.eq_done: 
36cd			 
36cd					; TODO push value back onto stack for another op etc 
36cd			 
36cd 26 00				ld h, 0 
36cf 69					ld l, c 
36d0					if DEBUG_FORTH_WORDS 
36d0						DMARK "EQ1" 
36d0 f5				push af  
36d1 3a e5 36			ld a, (.dmark)  
36d4 32 6b ee			ld (debug_mark),a  
36d7 3a e6 36			ld a, (.dmark+1)  
36da 32 6c ee			ld (debug_mark+1),a  
36dd 3a e7 36			ld a, (.dmark+2)  
36e0 32 6d ee			ld (debug_mark+2),a  
36e3 18 03			jr .pastdmark  
36e5 ..			.dmark: db "EQ1"  
36e8 f1			.pastdmark: pop af  
36e9			endm  
# End of macro DMARK
36e9						CALLMONITOR 
36e9 cd 6f ee			call debug_vector  
36ec				endm  
# End of macro CALLMONITOR
36ec					endif 
36ec cd 46 1c				call forth_push_numhl 
36ef			 
36ef					NEXTW 
36ef c3 f3 1f			jp macro_next 
36f2				endm 
# End of macro NEXTW
36f2			 
36f2			 
36f2			.ENDLOGIC: 
36f2			; eof 
36f2			 
36f2			 
# End of file forth_words_logic.asm
36f2			include "forth_words_maths.asm" 
36f2			 
36f2			; | ## Maths Words 
36f2			 
36f2			.PLUS:	 
36f2				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
36f2 15				db WORD_SYS_CORE+1             
36f3 50 37			dw .NEG            
36f5 02				db 1 + 1 
36f6 .. 00			db "+",0              
36f8				endm 
# End of macro CWHEAD
36f8			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
36f8					if DEBUG_FORTH_WORDS_KEY 
36f8						DMARK "PLU" 
36f8 f5				push af  
36f9 3a 0d 37			ld a, (.dmark)  
36fc 32 6b ee			ld (debug_mark),a  
36ff 3a 0e 37			ld a, (.dmark+1)  
3702 32 6c ee			ld (debug_mark+1),a  
3705 3a 0f 37			ld a, (.dmark+2)  
3708 32 6d ee			ld (debug_mark+2),a  
370b 18 03			jr .pastdmark  
370d ..			.dmark: db "PLU"  
3710 f1			.pastdmark: pop af  
3711			endm  
# End of macro DMARK
3711						CALLMONITOR 
3711 cd 6f ee			call debug_vector  
3714				endm  
# End of macro CALLMONITOR
3714					endif 
3714					; add top two values and push back result 
3714			 
3714					;for v5 FORTH_DSP_VALUE 
3714					FORTH_DSP 
3714 cd 03 1e			call macro_forth_dsp 
3717				endm 
# End of macro FORTH_DSP
3717 7e					ld a,(hl)	; get type of value on TOS 
3718 fe 02				cp DS_TYPE_INUM  
371a 28 03				jr z, .dot_inum 
371c			 
371c					NEXTW 
371c c3 f3 1f			jp macro_next 
371f				endm 
# End of macro NEXTW
371f			 
371f			; float maths 
371f			 
371f				if FORTH_ENABLE_FLOATMATH 
371f						inc hl      ; now at start of numeric as string 
371f			 
371f					if DEBUG_FORTH_MATHS 
371f						DMARK "ADD" 
371f				CALLMONITOR 
371f					endif 
371f			 
371f					;ld ix, hl 
371f					call CON 
371f			 
371f			 
371f					push hl 
371f					 
371f					 
371f			 
371f						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
371f			 
371f					; get next number 
371f			 
371f						FORTH_DSP_VALUE 
371f			 
371f						inc hl      ; now at start of numeric as string 
371f			 
371f					;ld ix, hl 
371f					call CON 
371f			 
371f					push hl 
371f			 
371f			 
371f						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
371f			 
371f						; TODO do add 
371f			 
371f						call IADD 
371f			 
371f						; TODO get result back as ascii 
371f			 
371f						; TODO push result  
371f			 
371f			 
371f			 
371f						jr .dot_done 
371f				endif 
371f			 
371f			.dot_inum: 
371f			 
371f			 
371f					if DEBUG_FORTH_DOT 
371f						DMARK "+IT" 
371f f5				push af  
3720 3a 34 37			ld a, (.dmark)  
3723 32 6b ee			ld (debug_mark),a  
3726 3a 35 37			ld a, (.dmark+1)  
3729 32 6c ee			ld (debug_mark+1),a  
372c 3a 36 37			ld a, (.dmark+2)  
372f 32 6d ee			ld (debug_mark+2),a  
3732 18 03			jr .pastdmark  
3734 ..			.dmark: db "+IT"  
3737 f1			.pastdmark: pop af  
3738			endm  
# End of macro DMARK
3738				CALLMONITOR 
3738 cd 6f ee			call debug_vector  
373b				endm  
# End of macro CALLMONITOR
373b					endif 
373b			 
373b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
373b cd 3d 1e			call macro_dsp_valuehl 
373e				endm 
# End of macro FORTH_DSP_VALUEHL
373e			 
373e				; TODO add floating point number detection 
373e			 
373e e5					push hl 
373f			 
373f					; destroy value TOS 
373f			 
373f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
373f cd f5 1e			call macro_forth_dsp_pop 
3742				endm 
# End of macro FORTH_DSP_POP
3742			 
3742			 
3742					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3742 cd 3d 1e			call macro_dsp_valuehl 
3745				endm 
# End of macro FORTH_DSP_VALUEHL
3745			 
3745					; one value on hl get other one back 
3745			 
3745 d1					pop de 
3746			 
3746					; do the add 
3746			 
3746 19					add hl,de 
3747			 
3747					; save it 
3747			 
3747			;		push hl	 
3747			 
3747					; 
3747			 
3747					; destroy value TOS 
3747			 
3747					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3747 cd f5 1e			call macro_forth_dsp_pop 
374a				endm 
# End of macro FORTH_DSP_POP
374a			 
374a					; TODO push value back onto stack for another op etc 
374a			 
374a			;		pop hl 
374a			 
374a			.dot_done: 
374a cd 46 1c				call forth_push_numhl 
374d			 
374d					NEXTW 
374d c3 f3 1f			jp macro_next 
3750				endm 
# End of macro NEXTW
3750			.NEG: 
3750			 
3750				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3750 17				db WORD_SYS_CORE+3             
3751 93 37			dw .DIV            
3753 02				db 1 + 1 
3754 .. 00			db "-",0              
3756				endm 
# End of macro CWHEAD
3756			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3756					if DEBUG_FORTH_WORDS_KEY 
3756						DMARK "SUB" 
3756 f5				push af  
3757 3a 6b 37			ld a, (.dmark)  
375a 32 6b ee			ld (debug_mark),a  
375d 3a 6c 37			ld a, (.dmark+1)  
3760 32 6c ee			ld (debug_mark+1),a  
3763 3a 6d 37			ld a, (.dmark+2)  
3766 32 6d ee			ld (debug_mark+2),a  
3769 18 03			jr .pastdmark  
376b ..			.dmark: db "SUB"  
376e f1			.pastdmark: pop af  
376f			endm  
# End of macro DMARK
376f						CALLMONITOR 
376f cd 6f ee			call debug_vector  
3772				endm  
# End of macro CALLMONITOR
3772					endif 
3772			 
3772			 
3772				; TODO add floating point number detection 
3772					; v5 FORTH_DSP_VALUE 
3772					FORTH_DSP 
3772 cd 03 1e			call macro_forth_dsp 
3775				endm 
# End of macro FORTH_DSP
3775 7e					ld a,(hl)	; get type of value on TOS 
3776 fe 02				cp DS_TYPE_INUM  
3778 28 03				jr z, .neg_inum 
377a			 
377a					NEXTW 
377a c3 f3 1f			jp macro_next 
377d				endm 
# End of macro NEXTW
377d			 
377d			; float maths 
377d			 
377d				if FORTH_ENABLE_FLOATMATH 
377d					jr .neg_done 
377d			 
377d				endif 
377d					 
377d			 
377d			.neg_inum: 
377d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
377d cd 3d 1e			call macro_dsp_valuehl 
3780				endm 
# End of macro FORTH_DSP_VALUEHL
3780			 
3780 e5					push hl 
3781			 
3781					; destroy value TOS 
3781			 
3781					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3781 cd f5 1e			call macro_forth_dsp_pop 
3784				endm 
# End of macro FORTH_DSP_POP
3784			 
3784			 
3784					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3784 cd 3d 1e			call macro_dsp_valuehl 
3787				endm 
# End of macro FORTH_DSP_VALUEHL
3787			 
3787					; one value on hl get other one back 
3787			 
3787 d1					pop de 
3788			 
3788					; do the sub 
3788			;		ex de, hl 
3788			 
3788 ed 52				sbc hl,de 
378a			 
378a					; save it 
378a			 
378a			;		push hl	 
378a			 
378a					; 
378a			 
378a					; destroy value TOS 
378a			 
378a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
378a cd f5 1e			call macro_forth_dsp_pop 
378d				endm 
# End of macro FORTH_DSP_POP
378d			 
378d					; TODO push value back onto stack for another op etc 
378d			 
378d			;		pop hl 
378d			 
378d cd 46 1c				call forth_push_numhl 
3790			.neg_done: 
3790			 
3790					NEXTW 
3790 c3 f3 1f			jp macro_next 
3793				endm 
# End of macro NEXTW
3793			.DIV: 
3793				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3793 18				db WORD_SYS_CORE+4             
3794 e0 37			dw .MUL            
3796 02				db 1 + 1 
3797 .. 00			db "/",0              
3799				endm 
# End of macro CWHEAD
3799			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3799					if DEBUG_FORTH_WORDS_KEY 
3799						DMARK "DIV" 
3799 f5				push af  
379a 3a ae 37			ld a, (.dmark)  
379d 32 6b ee			ld (debug_mark),a  
37a0 3a af 37			ld a, (.dmark+1)  
37a3 32 6c ee			ld (debug_mark+1),a  
37a6 3a b0 37			ld a, (.dmark+2)  
37a9 32 6d ee			ld (debug_mark+2),a  
37ac 18 03			jr .pastdmark  
37ae ..			.dmark: db "DIV"  
37b1 f1			.pastdmark: pop af  
37b2			endm  
# End of macro DMARK
37b2						CALLMONITOR 
37b2 cd 6f ee			call debug_vector  
37b5				endm  
# End of macro CALLMONITOR
37b5					endif 
37b5				; TODO add floating point number detection 
37b5					; v5 FORTH_DSP_VALUE 
37b5					FORTH_DSP 
37b5 cd 03 1e			call macro_forth_dsp 
37b8				endm 
# End of macro FORTH_DSP
37b8 7e					ld a,(hl)	; get type of value on TOS 
37b9 fe 02				cp DS_TYPE_INUM  
37bb 28 03				jr z, .div_inum 
37bd			 
37bd				if FORTH_ENABLE_FLOATMATH 
37bd					jr .div_done 
37bd			 
37bd				endif 
37bd					NEXTW 
37bd c3 f3 1f			jp macro_next 
37c0				endm 
# End of macro NEXTW
37c0			.div_inum: 
37c0			 
37c0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37c0 cd 3d 1e			call macro_dsp_valuehl 
37c3				endm 
# End of macro FORTH_DSP_VALUEHL
37c3			 
37c3 e5					push hl    ; to go to bc 
37c4			 
37c4					; destroy value TOS 
37c4			 
37c4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37c4 cd f5 1e			call macro_forth_dsp_pop 
37c7				endm 
# End of macro FORTH_DSP_POP
37c7			 
37c7			 
37c7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
37c7 cd 3d 1e			call macro_dsp_valuehl 
37ca				endm 
# End of macro FORTH_DSP_VALUEHL
37ca			 
37ca					; hl to go to de 
37ca			 
37ca e5					push hl 
37cb			 
37cb c1					pop bc 
37cc d1					pop de		 
37cd			 
37cd			 
37cd					if DEBUG_FORTH_MATHS 
37cd						DMARK "DIV" 
37cd				CALLMONITOR 
37cd					endif 
37cd					; one value on hl but move to a get other one back 
37cd			 
37cd			        
37cd cd 43 0d			call Div16 
37d0			 
37d0			;	push af	 
37d0 e5				push hl 
37d1 c5				push bc 
37d2			 
37d2					if DEBUG_FORTH_MATHS 
37d2						DMARK "DI1" 
37d2				CALLMONITOR 
37d2					endif 
37d2			 
37d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37d2 cd f5 1e			call macro_forth_dsp_pop 
37d5				endm 
# End of macro FORTH_DSP_POP
37d5			 
37d5			 
37d5			 
37d5 e1					pop hl    ; result 
37d6			 
37d6 cd 46 1c				call forth_push_numhl 
37d9			 
37d9 e1					pop hl    ; reminder 
37da			;		ld h,0 
37da			;		ld l,d 
37da			 
37da cd 46 1c				call forth_push_numhl 
37dd			.div_done: 
37dd					NEXTW 
37dd c3 f3 1f			jp macro_next 
37e0				endm 
# End of macro NEXTW
37e0			.MUL: 
37e0				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
37e0 19				db WORD_SYS_CORE+5             
37e1 25 38			dw .MIN            
37e3 02				db 1 + 1 
37e4 .. 00			db "*",0              
37e6				endm 
# End of macro CWHEAD
37e6			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
37e6				; TODO add floating point number detection 
37e6					if DEBUG_FORTH_WORDS_KEY 
37e6						DMARK "MUL" 
37e6 f5				push af  
37e7 3a fb 37			ld a, (.dmark)  
37ea 32 6b ee			ld (debug_mark),a  
37ed 3a fc 37			ld a, (.dmark+1)  
37f0 32 6c ee			ld (debug_mark+1),a  
37f3 3a fd 37			ld a, (.dmark+2)  
37f6 32 6d ee			ld (debug_mark+2),a  
37f9 18 03			jr .pastdmark  
37fb ..			.dmark: db "MUL"  
37fe f1			.pastdmark: pop af  
37ff			endm  
# End of macro DMARK
37ff						CALLMONITOR 
37ff cd 6f ee			call debug_vector  
3802				endm  
# End of macro CALLMONITOR
3802					endif 
3802					FORTH_DSP 
3802 cd 03 1e			call macro_forth_dsp 
3805				endm 
# End of macro FORTH_DSP
3805					; v5 FORTH_DSP_VALUE 
3805 7e					ld a,(hl)	; get type of value on TOS 
3806 fe 02				cp DS_TYPE_INUM  
3808 28 03				jr z, .mul_inum 
380a			 
380a				if FORTH_ENABLE_FLOATMATH 
380a					jr .mul_done 
380a			 
380a				endif 
380a			 
380a					NEXTW 
380a c3 f3 1f			jp macro_next 
380d				endm 
# End of macro NEXTW
380d			.mul_inum:	 
380d			 
380d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
380d cd 3d 1e			call macro_dsp_valuehl 
3810				endm 
# End of macro FORTH_DSP_VALUEHL
3810			 
3810 e5					push hl 
3811			 
3811					; destroy value TOS 
3811			 
3811					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3811 cd f5 1e			call macro_forth_dsp_pop 
3814				endm 
# End of macro FORTH_DSP_POP
3814			 
3814			 
3814					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3814 cd 3d 1e			call macro_dsp_valuehl 
3817				endm 
# End of macro FORTH_DSP_VALUEHL
3817			 
3817					; one value on hl but move to a get other one back 
3817			 
3817 7d					ld a, l 
3818			 
3818 d1					pop de 
3819			 
3819					; do the mull 
3819			;		ex de, hl 
3819			 
3819 cd 69 0d				call Mult16 
381c					; save it 
381c			 
381c			;		push hl	 
381c			 
381c					; 
381c			 
381c					; destroy value TOS 
381c			 
381c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
381c cd f5 1e			call macro_forth_dsp_pop 
381f				endm 
# End of macro FORTH_DSP_POP
381f			 
381f					; TODO push value back onto stack for another op etc 
381f			 
381f			;		pop hl 
381f			 
381f cd 46 1c				call forth_push_numhl 
3822			 
3822			.mul_done: 
3822					NEXTW 
3822 c3 f3 1f			jp macro_next 
3825				endm 
# End of macro NEXTW
3825			 
3825			 
3825			 
3825			 
3825			.MIN: 
3825				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3825 49				db WORD_SYS_CORE+53             
3826 a6 38			dw .MAX            
3828 04				db 3 + 1 
3829 .. 00			db "MIN",0              
382d				endm 
# End of macro CWHEAD
382d			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
382d					if DEBUG_FORTH_WORDS_KEY 
382d						DMARK "MIN" 
382d f5				push af  
382e 3a 42 38			ld a, (.dmark)  
3831 32 6b ee			ld (debug_mark),a  
3834 3a 43 38			ld a, (.dmark+1)  
3837 32 6c ee			ld (debug_mark+1),a  
383a 3a 44 38			ld a, (.dmark+2)  
383d 32 6d ee			ld (debug_mark+2),a  
3840 18 03			jr .pastdmark  
3842 ..			.dmark: db "MIN"  
3845 f1			.pastdmark: pop af  
3846			endm  
# End of macro DMARK
3846						CALLMONITOR 
3846 cd 6f ee			call debug_vector  
3849				endm  
# End of macro CALLMONITOR
3849					endif 
3849					; get u2 
3849			 
3849					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3849 cd 3d 1e			call macro_dsp_valuehl 
384c				endm 
# End of macro FORTH_DSP_VALUEHL
384c			 
384c e5					push hl   ; u2 
384d			 
384d					; destroy value TOS 
384d			 
384d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
384d cd f5 1e			call macro_forth_dsp_pop 
3850				endm 
# End of macro FORTH_DSP_POP
3850			 
3850					; get u1 
3850			 
3850					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3850 cd 3d 1e			call macro_dsp_valuehl 
3853				endm 
# End of macro FORTH_DSP_VALUEHL
3853			 
3853 e5					push hl  ; u1 
3854			 
3854					; destroy value TOS 
3854			 
3854					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3854 cd f5 1e			call macro_forth_dsp_pop 
3857				endm 
# End of macro FORTH_DSP_POP
3857			 
3857 b7			 or a      ;clear carry flag 
3858 e1			  pop hl    ; u1 
3859 d1			  pop de    ; u2 
385a e5				push hl   ; saved in case hl is lowest 
385b ed 52		  sbc hl,de 
385d 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
385f			 
385f e1				pop hl 
3860					if DEBUG_FORTH_WORDS 
3860						DMARK "MIN" 
3860 f5				push af  
3861 3a 75 38			ld a, (.dmark)  
3864 32 6b ee			ld (debug_mark),a  
3867 3a 76 38			ld a, (.dmark+1)  
386a 32 6c ee			ld (debug_mark+1),a  
386d 3a 77 38			ld a, (.dmark+2)  
3870 32 6d ee			ld (debug_mark+2),a  
3873 18 03			jr .pastdmark  
3875 ..			.dmark: db "MIN"  
3878 f1			.pastdmark: pop af  
3879			endm  
# End of macro DMARK
3879						CALLMONITOR 
3879 cd 6f ee			call debug_vector  
387c				endm  
# End of macro CALLMONITOR
387c					endif 
387c cd 46 1c				call forth_push_numhl 
387f			 
387f				       NEXTW 
387f c3 f3 1f			jp macro_next 
3882				endm 
# End of macro NEXTW
3882			 
3882			.mincont:  
3882 c1				pop bc   ; tidy up 
3883 eb				ex de , hl  
3884					if DEBUG_FORTH_WORDS 
3884						DMARK "MI1" 
3884 f5				push af  
3885 3a 99 38			ld a, (.dmark)  
3888 32 6b ee			ld (debug_mark),a  
388b 3a 9a 38			ld a, (.dmark+1)  
388e 32 6c ee			ld (debug_mark+1),a  
3891 3a 9b 38			ld a, (.dmark+2)  
3894 32 6d ee			ld (debug_mark+2),a  
3897 18 03			jr .pastdmark  
3899 ..			.dmark: db "MI1"  
389c f1			.pastdmark: pop af  
389d			endm  
# End of macro DMARK
389d						CALLMONITOR 
389d cd 6f ee			call debug_vector  
38a0				endm  
# End of macro CALLMONITOR
38a0					endif 
38a0 cd 46 1c				call forth_push_numhl 
38a3			 
38a3				       NEXTW 
38a3 c3 f3 1f			jp macro_next 
38a6				endm 
# End of macro NEXTW
38a6			.MAX: 
38a6				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
38a6 4a				db WORD_SYS_CORE+54             
38a7 27 39			dw .RND16            
38a9 04				db 3 + 1 
38aa .. 00			db "MAX",0              
38ae				endm 
# End of macro CWHEAD
38ae			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
38ae					if DEBUG_FORTH_WORDS_KEY 
38ae						DMARK "MAX" 
38ae f5				push af  
38af 3a c3 38			ld a, (.dmark)  
38b2 32 6b ee			ld (debug_mark),a  
38b5 3a c4 38			ld a, (.dmark+1)  
38b8 32 6c ee			ld (debug_mark+1),a  
38bb 3a c5 38			ld a, (.dmark+2)  
38be 32 6d ee			ld (debug_mark+2),a  
38c1 18 03			jr .pastdmark  
38c3 ..			.dmark: db "MAX"  
38c6 f1			.pastdmark: pop af  
38c7			endm  
# End of macro DMARK
38c7						CALLMONITOR 
38c7 cd 6f ee			call debug_vector  
38ca				endm  
# End of macro CALLMONITOR
38ca					endif 
38ca					; get u2 
38ca			 
38ca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38ca cd 3d 1e			call macro_dsp_valuehl 
38cd				endm 
# End of macro FORTH_DSP_VALUEHL
38cd			 
38cd e5					push hl   ; u2 
38ce			 
38ce					; destroy value TOS 
38ce			 
38ce					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38ce cd f5 1e			call macro_forth_dsp_pop 
38d1				endm 
# End of macro FORTH_DSP_POP
38d1			 
38d1					; get u1 
38d1			 
38d1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
38d1 cd 3d 1e			call macro_dsp_valuehl 
38d4				endm 
# End of macro FORTH_DSP_VALUEHL
38d4			 
38d4 e5					push hl  ; u1 
38d5			 
38d5					; destroy value TOS 
38d5			 
38d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38d5 cd f5 1e			call macro_forth_dsp_pop 
38d8				endm 
# End of macro FORTH_DSP_POP
38d8			 
38d8 b7			 or a      ;clear carry flag 
38d9 e1			  pop hl    ; u1 
38da d1			  pop de    ; u2 
38db e5				push hl   ; saved in case hl is lowest 
38dc ed 52		  sbc hl,de 
38de 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
38e0			 
38e0 e1				pop hl 
38e1					if DEBUG_FORTH_WORDS 
38e1						DMARK "MAX" 
38e1 f5				push af  
38e2 3a f6 38			ld a, (.dmark)  
38e5 32 6b ee			ld (debug_mark),a  
38e8 3a f7 38			ld a, (.dmark+1)  
38eb 32 6c ee			ld (debug_mark+1),a  
38ee 3a f8 38			ld a, (.dmark+2)  
38f1 32 6d ee			ld (debug_mark+2),a  
38f4 18 03			jr .pastdmark  
38f6 ..			.dmark: db "MAX"  
38f9 f1			.pastdmark: pop af  
38fa			endm  
# End of macro DMARK
38fa						CALLMONITOR 
38fa cd 6f ee			call debug_vector  
38fd				endm  
# End of macro CALLMONITOR
38fd					endif 
38fd cd 46 1c				call forth_push_numhl 
3900			 
3900				       NEXTW 
3900 c3 f3 1f			jp macro_next 
3903				endm 
# End of macro NEXTW
3903			 
3903			.maxcont:  
3903 c1				pop bc   ; tidy up 
3904 eb				ex de , hl  
3905					if DEBUG_FORTH_WORDS 
3905						DMARK "MA1" 
3905 f5				push af  
3906 3a 1a 39			ld a, (.dmark)  
3909 32 6b ee			ld (debug_mark),a  
390c 3a 1b 39			ld a, (.dmark+1)  
390f 32 6c ee			ld (debug_mark+1),a  
3912 3a 1c 39			ld a, (.dmark+2)  
3915 32 6d ee			ld (debug_mark+2),a  
3918 18 03			jr .pastdmark  
391a ..			.dmark: db "MA1"  
391d f1			.pastdmark: pop af  
391e			endm  
# End of macro DMARK
391e						CALLMONITOR 
391e cd 6f ee			call debug_vector  
3921				endm  
# End of macro CALLMONITOR
3921					endif 
3921 cd 46 1c				call forth_push_numhl 
3924				       NEXTW 
3924 c3 f3 1f			jp macro_next 
3927				endm 
# End of macro NEXTW
3927			 
3927			.RND16: 
3927				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3927 4e				db WORD_SYS_CORE+58             
3928 56 39			dw .RND8            
392a 06				db 5 + 1 
392b .. 00			db "RND16",0              
3931				endm 
# End of macro CWHEAD
3931			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3931					if DEBUG_FORTH_WORDS_KEY 
3931						DMARK "R16" 
3931 f5				push af  
3932 3a 46 39			ld a, (.dmark)  
3935 32 6b ee			ld (debug_mark),a  
3938 3a 47 39			ld a, (.dmark+1)  
393b 32 6c ee			ld (debug_mark+1),a  
393e 3a 48 39			ld a, (.dmark+2)  
3941 32 6d ee			ld (debug_mark+2),a  
3944 18 03			jr .pastdmark  
3946 ..			.dmark: db "R16"  
3949 f1			.pastdmark: pop af  
394a			endm  
# End of macro DMARK
394a						CALLMONITOR 
394a cd 6f ee			call debug_vector  
394d				endm  
# End of macro CALLMONITOR
394d					endif 
394d cd 0d 0d				call prng16  
3950 cd 46 1c				call forth_push_numhl 
3953				       NEXTW 
3953 c3 f3 1f			jp macro_next 
3956				endm 
# End of macro NEXTW
3956			.RND8: 
3956				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3956 60				db WORD_SYS_CORE+76             
3957 8b 39			dw .RND            
3959 05				db 4 + 1 
395a .. 00			db "RND8",0              
395f				endm 
# End of macro CWHEAD
395f			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
395f					if DEBUG_FORTH_WORDS_KEY 
395f						DMARK "RN8" 
395f f5				push af  
3960 3a 74 39			ld a, (.dmark)  
3963 32 6b ee			ld (debug_mark),a  
3966 3a 75 39			ld a, (.dmark+1)  
3969 32 6c ee			ld (debug_mark+1),a  
396c 3a 76 39			ld a, (.dmark+2)  
396f 32 6d ee			ld (debug_mark+2),a  
3972 18 03			jr .pastdmark  
3974 ..			.dmark: db "RN8"  
3977 f1			.pastdmark: pop af  
3978			endm  
# End of macro DMARK
3978						CALLMONITOR 
3978 cd 6f ee			call debug_vector  
397b				endm  
# End of macro CALLMONITOR
397b					endif 
397b 2a a9 eb				ld hl,(xrandc) 
397e 23					inc hl 
397f cd 27 0d				call xrnd 
3982 6f					ld l,a	 
3983 26 00				ld h,0 
3985 cd 46 1c				call forth_push_numhl 
3988				       NEXTW 
3988 c3 f3 1f			jp macro_next 
398b				endm 
# End of macro NEXTW
398b			.RND: 
398b				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
398b 60				db WORD_SYS_CORE+76             
398c 91 3a			dw .ENDMATHS            
398e 04				db 3 + 1 
398f .. 00			db "RND",0              
3993				endm 
# End of macro CWHEAD
3993			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3993			 
3993					if DEBUG_FORTH_WORDS_KEY 
3993						DMARK "RND" 
3993 f5				push af  
3994 3a a8 39			ld a, (.dmark)  
3997 32 6b ee			ld (debug_mark),a  
399a 3a a9 39			ld a, (.dmark+1)  
399d 32 6c ee			ld (debug_mark+1),a  
39a0 3a aa 39			ld a, (.dmark+2)  
39a3 32 6d ee			ld (debug_mark+2),a  
39a6 18 03			jr .pastdmark  
39a8 ..			.dmark: db "RND"  
39ab f1			.pastdmark: pop af  
39ac			endm  
# End of macro DMARK
39ac						CALLMONITOR 
39ac cd 6f ee			call debug_vector  
39af				endm  
# End of macro CALLMONITOR
39af					endif 
39af					 
39af					FORTH_DSP_VALUEHL    ; upper range 
39af cd 3d 1e			call macro_dsp_valuehl 
39b2				endm 
# End of macro FORTH_DSP_VALUEHL
39b2			 
39b2 22 ad eb				ld (LFSRSeed), hl	 
39b5			 
39b5					if DEBUG_FORTH_WORDS 
39b5						DMARK "RN1" 
39b5 f5				push af  
39b6 3a ca 39			ld a, (.dmark)  
39b9 32 6b ee			ld (debug_mark),a  
39bc 3a cb 39			ld a, (.dmark+1)  
39bf 32 6c ee			ld (debug_mark+1),a  
39c2 3a cc 39			ld a, (.dmark+2)  
39c5 32 6d ee			ld (debug_mark+2),a  
39c8 18 03			jr .pastdmark  
39ca ..			.dmark: db "RN1"  
39cd f1			.pastdmark: pop af  
39ce			endm  
# End of macro DMARK
39ce						CALLMONITOR 
39ce cd 6f ee			call debug_vector  
39d1				endm  
# End of macro CALLMONITOR
39d1					endif 
39d1					FORTH_DSP_POP 
39d1 cd f5 1e			call macro_forth_dsp_pop 
39d4				endm 
# End of macro FORTH_DSP_POP
39d4			 
39d4					FORTH_DSP_VALUEHL    ; low range 
39d4 cd 3d 1e			call macro_dsp_valuehl 
39d7				endm 
# End of macro FORTH_DSP_VALUEHL
39d7			 
39d7					if DEBUG_FORTH_WORDS 
39d7						DMARK "RN2" 
39d7 f5				push af  
39d8 3a ec 39			ld a, (.dmark)  
39db 32 6b ee			ld (debug_mark),a  
39de 3a ed 39			ld a, (.dmark+1)  
39e1 32 6c ee			ld (debug_mark+1),a  
39e4 3a ee 39			ld a, (.dmark+2)  
39e7 32 6d ee			ld (debug_mark+2),a  
39ea 18 03			jr .pastdmark  
39ec ..			.dmark: db "RN2"  
39ef f1			.pastdmark: pop af  
39f0			endm  
# End of macro DMARK
39f0						CALLMONITOR 
39f0 cd 6f ee			call debug_vector  
39f3				endm  
# End of macro CALLMONITOR
39f3					endif 
39f3 22 af eb				ld (LFSRSeed+2), hl 
39f6			 
39f6					FORTH_DSP_POP 
39f6 cd f5 1e			call macro_forth_dsp_pop 
39f9				endm 
# End of macro FORTH_DSP_POP
39f9			 
39f9 e5					push hl 
39fa			 
39fa e1			.inrange:	pop hl 
39fb cd 0d 0d				call prng16  
39fe					if DEBUG_FORTH_WORDS 
39fe						DMARK "RN3" 
39fe f5				push af  
39ff 3a 13 3a			ld a, (.dmark)  
3a02 32 6b ee			ld (debug_mark),a  
3a05 3a 14 3a			ld a, (.dmark+1)  
3a08 32 6c ee			ld (debug_mark+1),a  
3a0b 3a 15 3a			ld a, (.dmark+2)  
3a0e 32 6d ee			ld (debug_mark+2),a  
3a11 18 03			jr .pastdmark  
3a13 ..			.dmark: db "RN3"  
3a16 f1			.pastdmark: pop af  
3a17			endm  
# End of macro DMARK
3a17						CALLMONITOR 
3a17 cd 6f ee			call debug_vector  
3a1a				endm  
# End of macro CALLMONITOR
3a1a					endif 
3a1a					 
3a1a					; if the range is 8bit knock out the high byte 
3a1a			 
3a1a ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
3a1e			 
3a1e 3e 00				ld a, 0 
3a20 ba					cp d  
3a21 20 1e				jr nz, .hirange 
3a23 26 00				ld h, 0   ; knock it down to 8bit 
3a25			 
3a25					if DEBUG_FORTH_WORDS 
3a25						DMARK "RNk" 
3a25 f5				push af  
3a26 3a 3a 3a			ld a, (.dmark)  
3a29 32 6b ee			ld (debug_mark),a  
3a2c 3a 3b 3a			ld a, (.dmark+1)  
3a2f 32 6c ee			ld (debug_mark+1),a  
3a32 3a 3c 3a			ld a, (.dmark+2)  
3a35 32 6d ee			ld (debug_mark+2),a  
3a38 18 03			jr .pastdmark  
3a3a ..			.dmark: db "RNk"  
3a3d f1			.pastdmark: pop af  
3a3e			endm  
# End of macro DMARK
3a3e						CALLMONITOR 
3a3e cd 6f ee			call debug_vector  
3a41				endm  
# End of macro CALLMONITOR
3a41					endif 
3a41			.hirange:   
3a41 e5					push hl  
3a42 b7					or a  
3a43 ed 52		                sbc hl, de 
3a45			 
3a45					;call cmp16 
3a45			 
3a45 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3a47 e1					pop hl 
3a48 e5					push hl 
3a49			 
3a49					if DEBUG_FORTH_WORDS 
3a49						DMARK "RN4" 
3a49 f5				push af  
3a4a 3a 5e 3a			ld a, (.dmark)  
3a4d 32 6b ee			ld (debug_mark),a  
3a50 3a 5f 3a			ld a, (.dmark+1)  
3a53 32 6c ee			ld (debug_mark+1),a  
3a56 3a 60 3a			ld a, (.dmark+2)  
3a59 32 6d ee			ld (debug_mark+2),a  
3a5c 18 03			jr .pastdmark  
3a5e ..			.dmark: db "RN4"  
3a61 f1			.pastdmark: pop af  
3a62			endm  
# End of macro DMARK
3a62						CALLMONITOR 
3a62 cd 6f ee			call debug_vector  
3a65				endm  
# End of macro CALLMONITOR
3a65					endif 
3a65 ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
3a69					;call cmp16 
3a69				 
3a69 b7					or a  
3a6a ed 52		                sbc hl, de 
3a6c 38 8c				jr c, .inrange 
3a6e			 
3a6e e1					pop hl 
3a6f					 
3a6f					if DEBUG_FORTH_WORDS 
3a6f						DMARK "RNd" 
3a6f f5				push af  
3a70 3a 84 3a			ld a, (.dmark)  
3a73 32 6b ee			ld (debug_mark),a  
3a76 3a 85 3a			ld a, (.dmark+1)  
3a79 32 6c ee			ld (debug_mark+1),a  
3a7c 3a 86 3a			ld a, (.dmark+2)  
3a7f 32 6d ee			ld (debug_mark+2),a  
3a82 18 03			jr .pastdmark  
3a84 ..			.dmark: db "RNd"  
3a87 f1			.pastdmark: pop af  
3a88			endm  
# End of macro DMARK
3a88						CALLMONITOR 
3a88 cd 6f ee			call debug_vector  
3a8b				endm  
# End of macro CALLMONITOR
3a8b					endif 
3a8b			 
3a8b			 
3a8b cd 46 1c				call forth_push_numhl 
3a8e				       NEXTW 
3a8e c3 f3 1f			jp macro_next 
3a91				endm 
# End of macro NEXTW
3a91			 
3a91			.ENDMATHS: 
3a91			 
3a91			; eof 
3a91			 
# End of file forth_words_maths.asm
3a91			include "forth_words_display.asm" 
3a91			 
3a91			; | ## Display Words 
3a91			 
3a91			.ACT: 
3a91			 
3a91				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3a91 62				db WORD_SYS_CORE+78             
3a92 dd 3a			dw .INFO            
3a94 07				db 6 + 1 
3a95 .. 00			db "ACTIVE",0              
3a9c				endm 
# End of macro CWHEAD
3a9c			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3a9c			;  
3a9c			; | | e.g. $ff $00 do active . $01 pause loop 
3a9c			 
3a9c					if DEBUG_FORTH_WORDS_KEY 
3a9c						DMARK "ACT" 
3a9c f5				push af  
3a9d 3a b1 3a			ld a, (.dmark)  
3aa0 32 6b ee			ld (debug_mark),a  
3aa3 3a b2 3a			ld a, (.dmark+1)  
3aa6 32 6c ee			ld (debug_mark+1),a  
3aa9 3a b3 3a			ld a, (.dmark+2)  
3aac 32 6d ee			ld (debug_mark+2),a  
3aaf 18 03			jr .pastdmark  
3ab1 ..			.dmark: db "ACT"  
3ab4 f1			.pastdmark: pop af  
3ab5			endm  
# End of macro DMARK
3ab5						CALLMONITOR 
3ab5 cd 6f ee			call debug_vector  
3ab8				endm  
# End of macro CALLMONITOR
3ab8					endif 
3ab8 cd 10 0b				call active 
3abb					if DEBUG_FORTH_WORDS 
3abb						DMARK "ACp" 
3abb f5				push af  
3abc 3a d0 3a			ld a, (.dmark)  
3abf 32 6b ee			ld (debug_mark),a  
3ac2 3a d1 3a			ld a, (.dmark+1)  
3ac5 32 6c ee			ld (debug_mark+1),a  
3ac8 3a d2 3a			ld a, (.dmark+2)  
3acb 32 6d ee			ld (debug_mark+2),a  
3ace 18 03			jr .pastdmark  
3ad0 ..			.dmark: db "ACp"  
3ad3 f1			.pastdmark: pop af  
3ad4			endm  
# End of macro DMARK
3ad4						CALLMONITOR 
3ad4 cd 6f ee			call debug_vector  
3ad7				endm  
# End of macro CALLMONITOR
3ad7					endif 
3ad7 cd b4 1c				call forth_push_str 
3ada			 
3ada					NEXTW 
3ada c3 f3 1f			jp macro_next 
3add				endm 
# End of macro NEXTW
3add			.INFO: 
3add			 
3add				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3add 62				db WORD_SYS_CORE+78             
3ade fa 3a			dw .ATP            
3ae0 05				db 4 + 1 
3ae1 .. 00			db "INFO",0              
3ae6				endm 
# End of macro CWHEAD
3ae6			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3ae6					FORTH_DSP_VALUEHL 
3ae6 cd 3d 1e			call macro_dsp_valuehl 
3ae9				endm 
# End of macro FORTH_DSP_VALUEHL
3ae9			 
3ae9					FORTH_DSP_POP 
3ae9 cd f5 1e			call macro_forth_dsp_pop 
3aec				endm 
# End of macro FORTH_DSP_POP
3aec			 
3aec e5					push hl 
3aed			 
3aed					FORTH_DSP_VALUEHL 
3aed cd 3d 1e			call macro_dsp_valuehl 
3af0				endm 
# End of macro FORTH_DSP_VALUEHL
3af0			 
3af0					FORTH_DSP_POP 
3af0 cd f5 1e			call macro_forth_dsp_pop 
3af3				endm 
# End of macro FORTH_DSP_POP
3af3			 
3af3 d1					pop de 
3af4			 
3af4 cd 4a 0b				call info_panel 
3af7			 
3af7			 
3af7					NEXTW 
3af7 c3 f3 1f			jp macro_next 
3afa				endm 
# End of macro NEXTW
3afa			.ATP: 
3afa				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3afa 62				db WORD_SYS_CORE+78             
3afb 71 3b			dw .FB            
3afd 04				db 3 + 1 
3afe .. 00			db "AT?",0              
3b02				endm 
# End of macro CWHEAD
3b02			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3b02					if DEBUG_FORTH_WORDS_KEY 
3b02						DMARK "AT?" 
3b02 f5				push af  
3b03 3a 17 3b			ld a, (.dmark)  
3b06 32 6b ee			ld (debug_mark),a  
3b09 3a 18 3b			ld a, (.dmark+1)  
3b0c 32 6c ee			ld (debug_mark+1),a  
3b0f 3a 19 3b			ld a, (.dmark+2)  
3b12 32 6d ee			ld (debug_mark+2),a  
3b15 18 03			jr .pastdmark  
3b17 ..			.dmark: db "AT?"  
3b1a f1			.pastdmark: pop af  
3b1b			endm  
# End of macro DMARK
3b1b						CALLMONITOR 
3b1b cd 6f ee			call debug_vector  
3b1e				endm  
# End of macro CALLMONITOR
3b1e					endif 
3b1e 3a 5e ea				ld a, (f_cursor_ptr) 
3b21			 
3b21			if DEBUG_FORTH_WORDS 
3b21				DMARK "AT?" 
3b21 f5				push af  
3b22 3a 36 3b			ld a, (.dmark)  
3b25 32 6b ee			ld (debug_mark),a  
3b28 3a 37 3b			ld a, (.dmark+1)  
3b2b 32 6c ee			ld (debug_mark+1),a  
3b2e 3a 38 3b			ld a, (.dmark+2)  
3b31 32 6d ee			ld (debug_mark+2),a  
3b34 18 03			jr .pastdmark  
3b36 ..			.dmark: db "AT?"  
3b39 f1			.pastdmark: pop af  
3b3a			endm  
# End of macro DMARK
3b3a				CALLMONITOR 
3b3a cd 6f ee			call debug_vector  
3b3d				endm  
# End of macro CALLMONITOR
3b3d			endif	 
3b3d					; count the number of rows 
3b3d			 
3b3d 06 00				ld b, 0 
3b3f 4f			.atpr:		ld c, a    ; save in case we go below zero 
3b40 d6 28				sub display_cols 
3b42 f2 48 3b				jp p, .atprunder 
3b45 04					inc b 
3b46 18 f7				jr .atpr 
3b48			.atprunder:	 
3b48			if DEBUG_FORTH_WORDS 
3b48				DMARK "A?2" 
3b48 f5				push af  
3b49 3a 5d 3b			ld a, (.dmark)  
3b4c 32 6b ee			ld (debug_mark),a  
3b4f 3a 5e 3b			ld a, (.dmark+1)  
3b52 32 6c ee			ld (debug_mark+1),a  
3b55 3a 5f 3b			ld a, (.dmark+2)  
3b58 32 6d ee			ld (debug_mark+2),a  
3b5b 18 03			jr .pastdmark  
3b5d ..			.dmark: db "A?2"  
3b60 f1			.pastdmark: pop af  
3b61			endm  
# End of macro DMARK
3b61				CALLMONITOR 
3b61 cd 6f ee			call debug_vector  
3b64				endm  
# End of macro CALLMONITOR
3b64			endif	 
3b64 26 00				ld h, 0 
3b66 69					ld l, c 
3b67 cd 46 1c				call forth_push_numhl 
3b6a 68					ld l, b  
3b6b cd 46 1c				call forth_push_numhl 
3b6e			 
3b6e			 
3b6e				NEXTW 
3b6e c3 f3 1f			jp macro_next 
3b71				endm 
# End of macro NEXTW
3b71			 
3b71			.FB: 
3b71				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3b71 1b				db WORD_SYS_CORE+7             
3b72 bf 3b			dw .EMIT            
3b74 03				db 2 + 1 
3b75 .. 00			db "FB",0              
3b78				endm 
# End of macro CWHEAD
3b78			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3b78			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3b78			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3b78			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3b78					if DEBUG_FORTH_WORDS_KEY 
3b78						DMARK "FB." 
3b78 f5				push af  
3b79 3a 8d 3b			ld a, (.dmark)  
3b7c 32 6b ee			ld (debug_mark),a  
3b7f 3a 8e 3b			ld a, (.dmark+1)  
3b82 32 6c ee			ld (debug_mark+1),a  
3b85 3a 8f 3b			ld a, (.dmark+2)  
3b88 32 6d ee			ld (debug_mark+2),a  
3b8b 18 03			jr .pastdmark  
3b8d ..			.dmark: db "FB."  
3b90 f1			.pastdmark: pop af  
3b91			endm  
# End of macro DMARK
3b91						CALLMONITOR 
3b91 cd 6f ee			call debug_vector  
3b94				endm  
# End of macro CALLMONITOR
3b94					endif 
3b94			 
3b94					FORTH_DSP_VALUEHL 
3b94 cd 3d 1e			call macro_dsp_valuehl 
3b97				endm 
# End of macro FORTH_DSP_VALUEHL
3b97			 
3b97 7d					ld a, l 
3b98 fe 01				cp 1 
3b9a 20 05				jr nz, .fbn1 
3b9c 21 10 ed				ld hl, display_fb1 
3b9f 18 15				jr .fbset 
3ba1 fe 02		.fbn1:		cp 2 
3ba3 20 05				jr nz, .fbn2 
3ba5 21 ce eb				ld hl, display_fb2 
3ba8 18 0c				jr .fbset 
3baa fe 03		.fbn2:		cp 3 
3bac 20 05				jr nz, .fbn3 
3bae 21 6f ec				ld hl, display_fb3 
3bb1 18 03				jr .fbset 
3bb3			.fbn3:		 ; if invalid number select first 
3bb3 21 10 ed				ld hl, display_fb1 
3bb6 22 cc eb		.fbset:		ld (display_fb_active), hl 
3bb9			 
3bb9					FORTH_DSP_POP 
3bb9 cd f5 1e			call macro_forth_dsp_pop 
3bbc				endm 
# End of macro FORTH_DSP_POP
3bbc			 
3bbc					NEXTW 
3bbc c3 f3 1f			jp macro_next 
3bbf				endm 
# End of macro NEXTW
3bbf			 
3bbf			 
3bbf			.EMIT: 
3bbf				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3bbf 1b				db WORD_SYS_CORE+7             
3bc0 10 3c			dw .DOTH            
3bc2 05				db 4 + 1 
3bc3 .. 00			db "EMIT",0              
3bc8				endm 
# End of macro CWHEAD
3bc8			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3bc8					; get value off TOS and display it 
3bc8			 
3bc8					if DEBUG_FORTH_WORDS_KEY 
3bc8						DMARK "EMT" 
3bc8 f5				push af  
3bc9 3a dd 3b			ld a, (.dmark)  
3bcc 32 6b ee			ld (debug_mark),a  
3bcf 3a de 3b			ld a, (.dmark+1)  
3bd2 32 6c ee			ld (debug_mark+1),a  
3bd5 3a df 3b			ld a, (.dmark+2)  
3bd8 32 6d ee			ld (debug_mark+2),a  
3bdb 18 03			jr .pastdmark  
3bdd ..			.dmark: db "EMT"  
3be0 f1			.pastdmark: pop af  
3be1			endm  
# End of macro DMARK
3be1						CALLMONITOR 
3be1 cd 6f ee			call debug_vector  
3be4				endm  
# End of macro CALLMONITOR
3be4					endif 
3be4			 
3be4					FORTH_DSP_VALUEHL 
3be4 cd 3d 1e			call macro_dsp_valuehl 
3be7				endm 
# End of macro FORTH_DSP_VALUEHL
3be7			 
3be7 7d					ld a,l 
3be8			 
3be8					; TODO write to display 
3be8			 
3be8 32 bf e4				ld (os_input), a 
3beb 3e 00				ld a, 0 
3bed 32 c0 e4				ld (os_input+1), a 
3bf0					 
3bf0 3a 5e ea				ld a, (f_cursor_ptr) 
3bf3 11 bf e4				ld de, os_input 
3bf6 cd cc 0b				call str_at_display 
3bf9			 
3bf9			 
3bf9 3a 3c ea				ld a,(cli_autodisplay) 
3bfc fe 00				cp 0 
3bfe 28 03				jr z, .enoupdate 
3c00 cd dc 0b						call update_display 
3c03					.enoupdate: 
3c03			 
3c03 3a 5e ea				ld a, (f_cursor_ptr) 
3c06 3c					inc a 
3c07 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3c0a			 
3c0a			 
3c0a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c0a cd f5 1e			call macro_forth_dsp_pop 
3c0d				endm 
# End of macro FORTH_DSP_POP
3c0d			  
3c0d			 
3c0d					NEXTW 
3c0d c3 f3 1f			jp macro_next 
3c10				endm 
# End of macro NEXTW
3c10			.DOTH: 
3c10				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3c10 1c				db WORD_SYS_CORE+8             
3c11 40 3c			dw .DOTF            
3c13 03				db 2 + 1 
3c14 .. 00			db ".-",0              
3c17				endm 
# End of macro CWHEAD
3c17			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3c17					; get value off TOS and display it 
3c17					if DEBUG_FORTH_WORDS_KEY 
3c17						DMARK "DTD" 
3c17 f5				push af  
3c18 3a 2c 3c			ld a, (.dmark)  
3c1b 32 6b ee			ld (debug_mark),a  
3c1e 3a 2d 3c			ld a, (.dmark+1)  
3c21 32 6c ee			ld (debug_mark+1),a  
3c24 3a 2e 3c			ld a, (.dmark+2)  
3c27 32 6d ee			ld (debug_mark+2),a  
3c2a 18 03			jr .pastdmark  
3c2c ..			.dmark: db "DTD"  
3c2f f1			.pastdmark: pop af  
3c30			endm  
# End of macro DMARK
3c30						CALLMONITOR 
3c30 cd 6f ee			call debug_vector  
3c33				endm  
# End of macro CALLMONITOR
3c33					endif 
3c33 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3c35 3e 00			ld a, 0 
3c37 32 3d ea			ld (cli_mvdot), a 
3c3a c3 97 3c			jp .dotgo 
3c3d				NEXTW 
3c3d c3 f3 1f			jp macro_next 
3c40				endm 
# End of macro NEXTW
3c40			.DOTF: 
3c40				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3c40 1c				db WORD_SYS_CORE+8             
3c41 6e 3c			dw .DOT            
3c43 03				db 2 + 1 
3c44 .. 00			db ".>",0              
3c47				endm 
# End of macro CWHEAD
3c47			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3c47					; get value off TOS and display it 
3c47			        ; TODO BUG adds extra spaces 
3c47			        ; TODO BUG handle numerics? 
3c47					if DEBUG_FORTH_WORDS_KEY 
3c47						DMARK "DTC" 
3c47 f5				push af  
3c48 3a 5c 3c			ld a, (.dmark)  
3c4b 32 6b ee			ld (debug_mark),a  
3c4e 3a 5d 3c			ld a, (.dmark+1)  
3c51 32 6c ee			ld (debug_mark+1),a  
3c54 3a 5e 3c			ld a, (.dmark+2)  
3c57 32 6d ee			ld (debug_mark+2),a  
3c5a 18 03			jr .pastdmark  
3c5c ..			.dmark: db "DTC"  
3c5f f1			.pastdmark: pop af  
3c60			endm  
# End of macro DMARK
3c60						CALLMONITOR 
3c60 cd 6f ee			call debug_vector  
3c63				endm  
# End of macro CALLMONITOR
3c63					endif 
3c63 3e 01			ld a, 1 
3c65 32 3d ea			ld (cli_mvdot), a 
3c68 c3 97 3c			jp .dotgo 
3c6b				NEXTW 
3c6b c3 f3 1f			jp macro_next 
3c6e				endm 
# End of macro NEXTW
3c6e			 
3c6e			.DOT: 
3c6e				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3c6e 1c				db WORD_SYS_CORE+8             
3c6f 4a 3e			dw .CLS            
3c71 02				db 1 + 1 
3c72 .. 00			db ".",0              
3c74				endm 
# End of macro CWHEAD
3c74			        ; | . ( u -- ) Display TOS | DONE 
3c74					; get value off TOS and display it 
3c74			 
3c74					if DEBUG_FORTH_WORDS_KEY 
3c74						DMARK "DOT" 
3c74 f5				push af  
3c75 3a 89 3c			ld a, (.dmark)  
3c78 32 6b ee			ld (debug_mark),a  
3c7b 3a 8a 3c			ld a, (.dmark+1)  
3c7e 32 6c ee			ld (debug_mark+1),a  
3c81 3a 8b 3c			ld a, (.dmark+2)  
3c84 32 6d ee			ld (debug_mark+2),a  
3c87 18 03			jr .pastdmark  
3c89 ..			.dmark: db "DOT"  
3c8c f1			.pastdmark: pop af  
3c8d			endm  
# End of macro DMARK
3c8d						CALLMONITOR 
3c8d cd 6f ee			call debug_vector  
3c90				endm  
# End of macro CALLMONITOR
3c90					endif 
3c90 3e 00			ld a, 0 
3c92 32 3d ea			ld (cli_mvdot), a 
3c95 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3c97				 
3c97			 
3c97			.dotgo: 
3c97			 
3c97			; move up type to on stack for parserv5 
3c97					FORTH_DSP 
3c97 cd 03 1e			call macro_forth_dsp 
3c9a				endm 
# End of macro FORTH_DSP
3c9a				;FORTH_DSP_VALUE  
3c9a			 
3c9a			if DEBUG_FORTH_DOT 
3c9a				DMARK "DOT" 
3c9a f5				push af  
3c9b 3a af 3c			ld a, (.dmark)  
3c9e 32 6b ee			ld (debug_mark),a  
3ca1 3a b0 3c			ld a, (.dmark+1)  
3ca4 32 6c ee			ld (debug_mark+1),a  
3ca7 3a b1 3c			ld a, (.dmark+2)  
3caa 32 6d ee			ld (debug_mark+2),a  
3cad 18 03			jr .pastdmark  
3caf ..			.dmark: db "DOT"  
3cb2 f1			.pastdmark: pop af  
3cb3			endm  
# End of macro DMARK
3cb3				CALLMONITOR 
3cb3 cd 6f ee			call debug_vector  
3cb6				endm  
# End of macro CALLMONITOR
3cb6			endif	 
3cb6			;		.print: 
3cb6			 
3cb6 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3cb7 23				inc hl   ; position to the actual value 
3cb8 fe 01			cp DS_TYPE_STR 
3cba 20 06			jr nz, .dotnum1  
3cbc			 
3cbc			; display string 
3cbc				FORTH_DSP_VALUE  
3cbc cd 26 1e			call macro_forth_dsp_value 
3cbf				endm 
# End of macro FORTH_DSP_VALUE
3cbf eb				ex de,hl 
3cc0 18 49			jr .dotwrite 
3cc2			 
3cc2			.dotnum1: 
3cc2 fe 02			cp DS_TYPE_INUM 
3cc4 20 44			jr nz, .dotflot 
3cc6			 
3cc6			 
3cc6			; display number 
3cc6			 
3cc6			;	push hl 
3cc6			;	call clear_display 
3cc6			;	pop hl 
3cc6			 
3cc6 5e				ld e, (hl) 
3cc7 23				inc hl 
3cc8 56				ld d, (hl) 
3cc9 21 c1 e2			ld hl, scratch 
3ccc			if DEBUG_FORTH_DOT 
3ccc				DMARK "DT1" 
3ccc f5				push af  
3ccd 3a e1 3c			ld a, (.dmark)  
3cd0 32 6b ee			ld (debug_mark),a  
3cd3 3a e2 3c			ld a, (.dmark+1)  
3cd6 32 6c ee			ld (debug_mark+1),a  
3cd9 3a e3 3c			ld a, (.dmark+2)  
3cdc 32 6d ee			ld (debug_mark+2),a  
3cdf 18 03			jr .pastdmark  
3ce1 ..			.dmark: db "DT1"  
3ce4 f1			.pastdmark: pop af  
3ce5			endm  
# End of macro DMARK
3ce5				CALLMONITOR 
3ce5 cd 6f ee			call debug_vector  
3ce8				endm  
# End of macro CALLMONITOR
3ce8			endif	 
3ce8			 
3ce8 cd f3 11			call uitoa_16 
3ceb eb				ex de,hl 
3cec			 
3cec			if DEBUG_FORTH_DOT 
3cec				DMARK "DT2" 
3cec f5				push af  
3ced 3a 01 3d			ld a, (.dmark)  
3cf0 32 6b ee			ld (debug_mark),a  
3cf3 3a 02 3d			ld a, (.dmark+1)  
3cf6 32 6c ee			ld (debug_mark+1),a  
3cf9 3a 03 3d			ld a, (.dmark+2)  
3cfc 32 6d ee			ld (debug_mark+2),a  
3cff 18 03			jr .pastdmark  
3d01 ..			.dmark: db "DT2"  
3d04 f1			.pastdmark: pop af  
3d05			endm  
# End of macro DMARK
3d05				CALLMONITOR 
3d05 cd 6f ee			call debug_vector  
3d08				endm  
# End of macro CALLMONITOR
3d08			endif	 
3d08			 
3d08			;	ld de, os_word_scratch 
3d08 18 01			jr .dotwrite 
3d0a			 
3d0a 00			.dotflot:   nop 
3d0b			; TODO print floating point number 
3d0b			 
3d0b			.dotwrite:		 
3d0b			 
3d0b					; if c is set then set all '-' to spaces 
3d0b					; need to also take into account .>  
3d0b			 
3d0b 3e 01				ld a, 1 
3d0d b9					cp c 
3d0e 20 67				jr nz, .nodashswap 
3d10			 
3d10					; DE has the string to write, working with HL 
3d10			 
3d10 06 ff				ld b, 255 
3d12 d5					push de 
3d13 e1					pop hl 
3d14			 
3d14			if DEBUG_FORTH_DOT 
3d14				DMARK "DT-" 
3d14 f5				push af  
3d15 3a 29 3d			ld a, (.dmark)  
3d18 32 6b ee			ld (debug_mark),a  
3d1b 3a 2a 3d			ld a, (.dmark+1)  
3d1e 32 6c ee			ld (debug_mark+1),a  
3d21 3a 2b 3d			ld a, (.dmark+2)  
3d24 32 6d ee			ld (debug_mark+2),a  
3d27 18 03			jr .pastdmark  
3d29 ..			.dmark: db "DT-"  
3d2c f1			.pastdmark: pop af  
3d2d			endm  
# End of macro DMARK
3d2d				CALLMONITOR 
3d2d cd 6f ee			call debug_vector  
3d30				endm  
# End of macro CALLMONITOR
3d30			endif	 
3d30 7e			.dashscan:	ld a, (hl) 
3d31 fe 00				cp 0 
3d33 28 42				jr z, .nodashswap 
3d35 fe 2d				cp '-' 
3d37 20 03				jr nz, .dashskip 
3d39 3e 20				ld a, ' ' 
3d3b 77					ld (hl), a 
3d3c 23			.dashskip:	inc hl 
3d3d			if DEBUG_FORTH_DOT 
3d3d				DMARK "D-2" 
3d3d f5				push af  
3d3e 3a 52 3d			ld a, (.dmark)  
3d41 32 6b ee			ld (debug_mark),a  
3d44 3a 53 3d			ld a, (.dmark+1)  
3d47 32 6c ee			ld (debug_mark+1),a  
3d4a 3a 54 3d			ld a, (.dmark+2)  
3d4d 32 6d ee			ld (debug_mark+2),a  
3d50 18 03			jr .pastdmark  
3d52 ..			.dmark: db "D-2"  
3d55 f1			.pastdmark: pop af  
3d56			endm  
# End of macro DMARK
3d56				CALLMONITOR 
3d56 cd 6f ee			call debug_vector  
3d59				endm  
# End of macro CALLMONITOR
3d59			endif	 
3d59 10 d5				djnz .dashscan 
3d5b			 
3d5b			if DEBUG_FORTH_DOT 
3d5b				DMARK "D-1" 
3d5b f5				push af  
3d5c 3a 70 3d			ld a, (.dmark)  
3d5f 32 6b ee			ld (debug_mark),a  
3d62 3a 71 3d			ld a, (.dmark+1)  
3d65 32 6c ee			ld (debug_mark+1),a  
3d68 3a 72 3d			ld a, (.dmark+2)  
3d6b 32 6d ee			ld (debug_mark+2),a  
3d6e 18 03			jr .pastdmark  
3d70 ..			.dmark: db "D-1"  
3d73 f1			.pastdmark: pop af  
3d74			endm  
# End of macro DMARK
3d74				CALLMONITOR 
3d74 cd 6f ee			call debug_vector  
3d77				endm  
# End of macro CALLMONITOR
3d77			endif	 
3d77			 
3d77			.nodashswap: 
3d77			 
3d77			if DEBUG_FORTH_DOT 
3d77				DMARK "D-o" 
3d77 f5				push af  
3d78 3a 8c 3d			ld a, (.dmark)  
3d7b 32 6b ee			ld (debug_mark),a  
3d7e 3a 8d 3d			ld a, (.dmark+1)  
3d81 32 6c ee			ld (debug_mark+1),a  
3d84 3a 8e 3d			ld a, (.dmark+2)  
3d87 32 6d ee			ld (debug_mark+2),a  
3d8a 18 03			jr .pastdmark  
3d8c ..			.dmark: db "D-o"  
3d8f f1			.pastdmark: pop af  
3d90			endm  
# End of macro DMARK
3d90				CALLMONITOR 
3d90 cd 6f ee			call debug_vector  
3d93				endm  
# End of macro CALLMONITOR
3d93			endif	 
3d93			 
3d93 d5					push de   ; save string start in case we need to advance print 
3d94			 
3d94 3a 5e ea				ld a, (f_cursor_ptr) 
3d97 cd cc 0b				call str_at_display 
3d9a 3a 3c ea				ld a,(cli_autodisplay) 
3d9d fe 00				cp 0 
3d9f 28 03				jr z, .noupdate 
3da1 cd dc 0b						call update_display 
3da4					.noupdate: 
3da4			 
3da4			 
3da4					; see if we need to advance the print position 
3da4			 
3da4 e1					pop hl   ; get back string 
3da5			;		ex de,hl 
3da5			 
3da5 3a 3d ea				ld a, (cli_mvdot) 
3da8			if DEBUG_FORTH_DOT 
3da8			;		ld e,a 
3da8				DMARK "D>1" 
3da8 f5				push af  
3da9 3a bd 3d			ld a, (.dmark)  
3dac 32 6b ee			ld (debug_mark),a  
3daf 3a be 3d			ld a, (.dmark+1)  
3db2 32 6c ee			ld (debug_mark+1),a  
3db5 3a bf 3d			ld a, (.dmark+2)  
3db8 32 6d ee			ld (debug_mark+2),a  
3dbb 18 03			jr .pastdmark  
3dbd ..			.dmark: db "D>1"  
3dc0 f1			.pastdmark: pop af  
3dc1			endm  
# End of macro DMARK
3dc1				CALLMONITOR 
3dc1 cd 6f ee			call debug_vector  
3dc4				endm  
# End of macro CALLMONITOR
3dc4			endif	 
3dc4 fe 00				cp 0 
3dc6 28 44				jr z, .noadv 
3dc8					; yes, lets advance the print position 
3dc8 3e 00				ld a, 0 
3dca cd 4f 12				call strlent 
3dcd			if DEBUG_FORTH_DOT 
3dcd				DMARK "D-?" 
3dcd f5				push af  
3dce 3a e2 3d			ld a, (.dmark)  
3dd1 32 6b ee			ld (debug_mark),a  
3dd4 3a e3 3d			ld a, (.dmark+1)  
3dd7 32 6c ee			ld (debug_mark+1),a  
3dda 3a e4 3d			ld a, (.dmark+2)  
3ddd 32 6d ee			ld (debug_mark+2),a  
3de0 18 03			jr .pastdmark  
3de2 ..			.dmark: db "D-?"  
3de5 f1			.pastdmark: pop af  
3de6			endm  
# End of macro DMARK
3de6				CALLMONITOR 
3de6 cd 6f ee			call debug_vector  
3de9				endm  
# End of macro CALLMONITOR
3de9			endif	 
3de9 3a 5e ea				ld a, (f_cursor_ptr) 
3dec 85					add a,l 
3ded					;call addatohl 
3ded					;ld a, l 
3ded 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3df0			 
3df0			if DEBUG_FORTH_DOT 
3df0				DMARK "D->" 
3df0 f5				push af  
3df1 3a 05 3e			ld a, (.dmark)  
3df4 32 6b ee			ld (debug_mark),a  
3df7 3a 06 3e			ld a, (.dmark+1)  
3dfa 32 6c ee			ld (debug_mark+1),a  
3dfd 3a 07 3e			ld a, (.dmark+2)  
3e00 32 6d ee			ld (debug_mark+2),a  
3e03 18 03			jr .pastdmark  
3e05 ..			.dmark: db "D->"  
3e08 f1			.pastdmark: pop af  
3e09			endm  
# End of macro DMARK
3e09				CALLMONITOR 
3e09 cd 6f ee			call debug_vector  
3e0c				endm  
# End of macro CALLMONITOR
3e0c			endif	 
3e0c			 
3e0c			.noadv:	 
3e0c			 
3e0c					if DEBUG_FORTH_DOT_WAIT 
3e0c							call next_page_prompt 
3e0c					endif	 
3e0c			; TODO this pop off the stack causes a crash. i dont know why 
3e0c			 
3e0c			 
3e0c			if DEBUG_FORTH_DOT 
3e0c				DMARK "DTh" 
3e0c f5				push af  
3e0d 3a 21 3e			ld a, (.dmark)  
3e10 32 6b ee			ld (debug_mark),a  
3e13 3a 22 3e			ld a, (.dmark+1)  
3e16 32 6c ee			ld (debug_mark+1),a  
3e19 3a 23 3e			ld a, (.dmark+2)  
3e1c 32 6d ee			ld (debug_mark+2),a  
3e1f 18 03			jr .pastdmark  
3e21 ..			.dmark: db "DTh"  
3e24 f1			.pastdmark: pop af  
3e25			endm  
# End of macro DMARK
3e25				CALLMONITOR 
3e25 cd 6f ee			call debug_vector  
3e28				endm  
# End of macro CALLMONITOR
3e28			endif	 
3e28			 
3e28					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e28 cd f5 1e			call macro_forth_dsp_pop 
3e2b				endm 
# End of macro FORTH_DSP_POP
3e2b			 
3e2b			if DEBUG_FORTH_DOT 
3e2b				DMARK "DTi" 
3e2b f5				push af  
3e2c 3a 40 3e			ld a, (.dmark)  
3e2f 32 6b ee			ld (debug_mark),a  
3e32 3a 41 3e			ld a, (.dmark+1)  
3e35 32 6c ee			ld (debug_mark+1),a  
3e38 3a 42 3e			ld a, (.dmark+2)  
3e3b 32 6d ee			ld (debug_mark+2),a  
3e3e 18 03			jr .pastdmark  
3e40 ..			.dmark: db "DTi"  
3e43 f1			.pastdmark: pop af  
3e44			endm  
# End of macro DMARK
3e44				CALLMONITOR 
3e44 cd 6f ee			call debug_vector  
3e47				endm  
# End of macro CALLMONITOR
3e47			endif	 
3e47			 
3e47			 
3e47					NEXTW 
3e47 c3 f3 1f			jp macro_next 
3e4a				endm 
# End of macro NEXTW
3e4a			 
3e4a			.CLS: 
3e4a				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3e4a 35				db WORD_SYS_CORE+33             
3e4b 77 3e			dw .DRAW            
3e4d 04				db 3 + 1 
3e4e .. 00			db "CLS",0              
3e52				endm 
# End of macro CWHEAD
3e52			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3e52					if DEBUG_FORTH_WORDS_KEY 
3e52						DMARK "CLS" 
3e52 f5				push af  
3e53 3a 67 3e			ld a, (.dmark)  
3e56 32 6b ee			ld (debug_mark),a  
3e59 3a 68 3e			ld a, (.dmark+1)  
3e5c 32 6c ee			ld (debug_mark+1),a  
3e5f 3a 69 3e			ld a, (.dmark+2)  
3e62 32 6d ee			ld (debug_mark+2),a  
3e65 18 03			jr .pastdmark  
3e67 ..			.dmark: db "CLS"  
3e6a f1			.pastdmark: pop af  
3e6b			endm  
# End of macro DMARK
3e6b						CALLMONITOR 
3e6b cd 6f ee			call debug_vector  
3e6e				endm  
# End of macro CALLMONITOR
3e6e					endif 
3e6e cd b9 0b				call clear_display 
3e71 c3 85 3f				jp .home		; and home cursor 
3e74					NEXTW 
3e74 c3 f3 1f			jp macro_next 
3e77				endm 
# End of macro NEXTW
3e77			 
3e77			.DRAW: 
3e77				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3e77 36				db WORD_SYS_CORE+34             
3e78 a2 3e			dw .DUMP            
3e7a 05				db 4 + 1 
3e7b .. 00			db "DRAW",0              
3e80				endm 
# End of macro CWHEAD
3e80			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3e80					if DEBUG_FORTH_WORDS_KEY 
3e80						DMARK "DRW" 
3e80 f5				push af  
3e81 3a 95 3e			ld a, (.dmark)  
3e84 32 6b ee			ld (debug_mark),a  
3e87 3a 96 3e			ld a, (.dmark+1)  
3e8a 32 6c ee			ld (debug_mark+1),a  
3e8d 3a 97 3e			ld a, (.dmark+2)  
3e90 32 6d ee			ld (debug_mark+2),a  
3e93 18 03			jr .pastdmark  
3e95 ..			.dmark: db "DRW"  
3e98 f1			.pastdmark: pop af  
3e99			endm  
# End of macro DMARK
3e99						CALLMONITOR 
3e99 cd 6f ee			call debug_vector  
3e9c				endm  
# End of macro CALLMONITOR
3e9c					endif 
3e9c cd dc 0b				call update_display 
3e9f					NEXTW 
3e9f c3 f3 1f			jp macro_next 
3ea2				endm 
# End of macro NEXTW
3ea2			 
3ea2			.DUMP: 
3ea2				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3ea2 37				db WORD_SYS_CORE+35             
3ea3 da 3e			dw .CDUMP            
3ea5 05				db 4 + 1 
3ea6 .. 00			db "DUMP",0              
3eab				endm 
# End of macro CWHEAD
3eab			; | DUMP ( x -- ) With address x display dump   | DONE 
3eab			; TODO pop address to use off of the stack 
3eab					if DEBUG_FORTH_WORDS_KEY 
3eab						DMARK "DUM" 
3eab f5				push af  
3eac 3a c0 3e			ld a, (.dmark)  
3eaf 32 6b ee			ld (debug_mark),a  
3eb2 3a c1 3e			ld a, (.dmark+1)  
3eb5 32 6c ee			ld (debug_mark+1),a  
3eb8 3a c2 3e			ld a, (.dmark+2)  
3ebb 32 6d ee			ld (debug_mark+2),a  
3ebe 18 03			jr .pastdmark  
3ec0 ..			.dmark: db "DUM"  
3ec3 f1			.pastdmark: pop af  
3ec4			endm  
# End of macro DMARK
3ec4						CALLMONITOR 
3ec4 cd 6f ee			call debug_vector  
3ec7				endm  
# End of macro CALLMONITOR
3ec7					endif 
3ec7 cd b9 0b				call clear_display 
3eca			 
3eca					; get address 
3eca			 
3eca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3eca cd 3d 1e			call macro_dsp_valuehl 
3ecd				endm 
# End of macro FORTH_DSP_VALUEHL
3ecd				 
3ecd					; save it for cdump 
3ecd			 
3ecd 22 e4 e5				ld (os_cur_ptr),hl 
3ed0			 
3ed0					; destroy value TOS 
3ed0			 
3ed0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ed0 cd f5 1e			call macro_forth_dsp_pop 
3ed3				endm 
# End of macro FORTH_DSP_POP
3ed3			 
3ed3 cd c6 1a				call dumpcont	; skip old style of param parsing	 
3ed6 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3ed7					NEXTW 
3ed7 c3 f3 1f			jp macro_next 
3eda				endm 
# End of macro NEXTW
3eda			.CDUMP: 
3eda				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3eda 38				db WORD_SYS_CORE+36             
3edb 0a 3f			dw .DAT            
3edd 06				db 5 + 1 
3ede .. 00			db "CDUMP",0              
3ee4				endm 
# End of macro CWHEAD
3ee4			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3ee4					if DEBUG_FORTH_WORDS_KEY 
3ee4						DMARK "CDP" 
3ee4 f5				push af  
3ee5 3a f9 3e			ld a, (.dmark)  
3ee8 32 6b ee			ld (debug_mark),a  
3eeb 3a fa 3e			ld a, (.dmark+1)  
3eee 32 6c ee			ld (debug_mark+1),a  
3ef1 3a fb 3e			ld a, (.dmark+2)  
3ef4 32 6d ee			ld (debug_mark+2),a  
3ef7 18 03			jr .pastdmark  
3ef9 ..			.dmark: db "CDP"  
3efc f1			.pastdmark: pop af  
3efd			endm  
# End of macro DMARK
3efd						CALLMONITOR 
3efd cd 6f ee			call debug_vector  
3f00				endm  
# End of macro CALLMONITOR
3f00					endif 
3f00 cd b9 0b				call clear_display 
3f03 cd c6 1a				call dumpcont	 
3f06 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3f07					NEXTW 
3f07 c3 f3 1f			jp macro_next 
3f0a				endm 
# End of macro NEXTW
3f0a			 
3f0a			 
3f0a			 
3f0a			 
3f0a			.DAT: 
3f0a				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3f0a 3d				db WORD_SYS_CORE+41             
3f0b 60 3f			dw .HOME            
3f0d 03				db 2 + 1 
3f0e .. 00			db "AT",0              
3f11				endm 
# End of macro CWHEAD
3f11			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3f11					if DEBUG_FORTH_WORDS_KEY 
3f11						DMARK "AT." 
3f11 f5				push af  
3f12 3a 26 3f			ld a, (.dmark)  
3f15 32 6b ee			ld (debug_mark),a  
3f18 3a 27 3f			ld a, (.dmark+1)  
3f1b 32 6c ee			ld (debug_mark+1),a  
3f1e 3a 28 3f			ld a, (.dmark+2)  
3f21 32 6d ee			ld (debug_mark+2),a  
3f24 18 03			jr .pastdmark  
3f26 ..			.dmark: db "AT."  
3f29 f1			.pastdmark: pop af  
3f2a			endm  
# End of macro DMARK
3f2a						CALLMONITOR 
3f2a cd 6f ee			call debug_vector  
3f2d				endm  
# End of macro CALLMONITOR
3f2d					endif 
3f2d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f2d cd 3d 1e			call macro_dsp_valuehl 
3f30				endm 
# End of macro FORTH_DSP_VALUEHL
3f30			 
3f30			 
3f30					; TODO save cursor row 
3f30 7d					ld a,l 
3f31 fe 02				cp 2 
3f33 20 04				jr nz, .crow3 
3f35 3e 28				ld a, display_row_2 
3f37 18 12				jr .ccol1 
3f39 fe 03		.crow3:		cp 3 
3f3b 20 04				jr nz, .crow4 
3f3d 3e 50				ld a, display_row_3 
3f3f 18 0a				jr .ccol1 
3f41 fe 04		.crow4:		cp 4 
3f43 20 04				jr nz, .crow1 
3f45 3e 78				ld a, display_row_4 
3f47 18 02				jr .ccol1 
3f49 3e 00		.crow1:		ld a,display_row_1 
3f4b f5			.ccol1:		push af			; got row offset 
3f4c 6f					ld l,a 
3f4d 26 00				ld h,0 
3f4f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f4f cd f5 1e			call macro_forth_dsp_pop 
3f52				endm 
# End of macro FORTH_DSP_POP
3f52					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f52 cd 3d 1e			call macro_dsp_valuehl 
3f55				endm 
# End of macro FORTH_DSP_VALUEHL
3f55					; TODO save cursor col 
3f55 f1					pop af 
3f56 85					add l		; add col offset 
3f57 32 5e ea				ld (f_cursor_ptr), a 
3f5a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f5a cd f5 1e			call macro_forth_dsp_pop 
3f5d				endm 
# End of macro FORTH_DSP_POP
3f5d			 
3f5d					; calculate  
3f5d			 
3f5d					NEXTW 
3f5d c3 f3 1f			jp macro_next 
3f60				endm 
# End of macro NEXTW
3f60			 
3f60			 
3f60			.HOME: 
3f60				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3f60 41				db WORD_SYS_CORE+45             
3f61 8d 3f			dw .SPACE            
3f63 05				db 4 + 1 
3f64 .. 00			db "HOME",0              
3f69				endm 
# End of macro CWHEAD
3f69			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3f69					if DEBUG_FORTH_WORDS_KEY 
3f69						DMARK "HOM" 
3f69 f5				push af  
3f6a 3a 7e 3f			ld a, (.dmark)  
3f6d 32 6b ee			ld (debug_mark),a  
3f70 3a 7f 3f			ld a, (.dmark+1)  
3f73 32 6c ee			ld (debug_mark+1),a  
3f76 3a 80 3f			ld a, (.dmark+2)  
3f79 32 6d ee			ld (debug_mark+2),a  
3f7c 18 03			jr .pastdmark  
3f7e ..			.dmark: db "HOM"  
3f81 f1			.pastdmark: pop af  
3f82			endm  
# End of macro DMARK
3f82						CALLMONITOR 
3f82 cd 6f ee			call debug_vector  
3f85				endm  
# End of macro CALLMONITOR
3f85					endif 
3f85 3e 00		.home:		ld a, 0		; and home cursor 
3f87 32 5e ea				ld (f_cursor_ptr), a 
3f8a					NEXTW 
3f8a c3 f3 1f			jp macro_next 
3f8d				endm 
# End of macro NEXTW
3f8d			 
3f8d			 
3f8d			.SPACE: 
3f8d				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3f8d 46				db WORD_SYS_CORE+50             
3f8e c3 3f			dw .SPACES            
3f90 03				db 2 + 1 
3f91 .. 00			db "BL",0              
3f94				endm 
# End of macro CWHEAD
3f94			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3f94					if DEBUG_FORTH_WORDS_KEY 
3f94						DMARK "BL." 
3f94 f5				push af  
3f95 3a a9 3f			ld a, (.dmark)  
3f98 32 6b ee			ld (debug_mark),a  
3f9b 3a aa 3f			ld a, (.dmark+1)  
3f9e 32 6c ee			ld (debug_mark+1),a  
3fa1 3a ab 3f			ld a, (.dmark+2)  
3fa4 32 6d ee			ld (debug_mark+2),a  
3fa7 18 03			jr .pastdmark  
3fa9 ..			.dmark: db "BL."  
3fac f1			.pastdmark: pop af  
3fad			endm  
# End of macro DMARK
3fad						CALLMONITOR 
3fad cd 6f ee			call debug_vector  
3fb0				endm  
# End of macro CALLMONITOR
3fb0					endif 
3fb0 3e 20				ld a, " " 
3fb2 32 c1 e2				ld (scratch),a 
3fb5 3e 00				ld a, 0 
3fb7 32 c2 e2				ld (scratch+1),a 
3fba 21 c1 e2				ld hl, scratch 
3fbd cd b4 1c				call forth_push_str 
3fc0					 
3fc0				       NEXTW 
3fc0 c3 f3 1f			jp macro_next 
3fc3				endm 
# End of macro NEXTW
3fc3			 
3fc3			;.blstr: db " ", 0 
3fc3			 
3fc3			.SPACES: 
3fc3				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3fc3 47				db WORD_SYS_CORE+51             
3fc4 5e 40			dw .SCROLL            
3fc6 07				db 6 + 1 
3fc7 .. 00			db "SPACES",0              
3fce				endm 
# End of macro CWHEAD
3fce			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
3fce					if DEBUG_FORTH_WORDS_KEY 
3fce						DMARK "SPS" 
3fce f5				push af  
3fcf 3a e3 3f			ld a, (.dmark)  
3fd2 32 6b ee			ld (debug_mark),a  
3fd5 3a e4 3f			ld a, (.dmark+1)  
3fd8 32 6c ee			ld (debug_mark+1),a  
3fdb 3a e5 3f			ld a, (.dmark+2)  
3fde 32 6d ee			ld (debug_mark+2),a  
3fe1 18 03			jr .pastdmark  
3fe3 ..			.dmark: db "SPS"  
3fe6 f1			.pastdmark: pop af  
3fe7			endm  
# End of macro DMARK
3fe7						CALLMONITOR 
3fe7 cd 6f ee			call debug_vector  
3fea				endm  
# End of macro CALLMONITOR
3fea					endif 
3fea			 
3fea			 
3fea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fea cd 3d 1e			call macro_dsp_valuehl 
3fed				endm 
# End of macro FORTH_DSP_VALUEHL
3fed			 
3fed e5					push hl    ; u 
3fee					if DEBUG_FORTH_WORDS 
3fee						DMARK "SPA" 
3fee f5				push af  
3fef 3a 03 40			ld a, (.dmark)  
3ff2 32 6b ee			ld (debug_mark),a  
3ff5 3a 04 40			ld a, (.dmark+1)  
3ff8 32 6c ee			ld (debug_mark+1),a  
3ffb 3a 05 40			ld a, (.dmark+2)  
3ffe 32 6d ee			ld (debug_mark+2),a  
4001 18 03			jr .pastdmark  
4003 ..			.dmark: db "SPA"  
4006 f1			.pastdmark: pop af  
4007			endm  
# End of macro DMARK
4007						CALLMONITOR 
4007 cd 6f ee			call debug_vector  
400a				endm  
# End of macro CALLMONITOR
400a					endif 
400a			 
400a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
400a cd f5 1e			call macro_forth_dsp_pop 
400d				endm 
# End of macro FORTH_DSP_POP
400d e1					pop hl 
400e 0e 00				ld c, 0 
4010 45					ld b, l 
4011 21 c1 e2				ld hl, scratch  
4014			 
4014					if DEBUG_FORTH_WORDS 
4014						DMARK "SP2" 
4014 f5				push af  
4015 3a 29 40			ld a, (.dmark)  
4018 32 6b ee			ld (debug_mark),a  
401b 3a 2a 40			ld a, (.dmark+1)  
401e 32 6c ee			ld (debug_mark+1),a  
4021 3a 2b 40			ld a, (.dmark+2)  
4024 32 6d ee			ld (debug_mark+2),a  
4027 18 03			jr .pastdmark  
4029 ..			.dmark: db "SP2"  
402c f1			.pastdmark: pop af  
402d			endm  
# End of macro DMARK
402d						CALLMONITOR 
402d cd 6f ee			call debug_vector  
4030				endm  
# End of macro CALLMONITOR
4030					endif 
4030 3e 20				ld a, ' ' 
4032			.spaces1:	 
4032 77					ld (hl),a 
4033 23					inc hl 
4034					 
4034 10 fc				djnz .spaces1 
4036 3e 00				ld a,0 
4038 77					ld (hl),a 
4039 21 c1 e2				ld hl, scratch 
403c					if DEBUG_FORTH_WORDS 
403c						DMARK "SP3" 
403c f5				push af  
403d 3a 51 40			ld a, (.dmark)  
4040 32 6b ee			ld (debug_mark),a  
4043 3a 52 40			ld a, (.dmark+1)  
4046 32 6c ee			ld (debug_mark+1),a  
4049 3a 53 40			ld a, (.dmark+2)  
404c 32 6d ee			ld (debug_mark+2),a  
404f 18 03			jr .pastdmark  
4051 ..			.dmark: db "SP3"  
4054 f1			.pastdmark: pop af  
4055			endm  
# End of macro DMARK
4055						CALLMONITOR 
4055 cd 6f ee			call debug_vector  
4058				endm  
# End of macro CALLMONITOR
4058					endif 
4058 cd b4 1c				call forth_push_str 
405b			 
405b				       NEXTW 
405b c3 f3 1f			jp macro_next 
405e				endm 
# End of macro NEXTW
405e			 
405e			 
405e			 
405e			.SCROLL: 
405e				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
405e 53				db WORD_SYS_CORE+63             
405f 8b 40			dw .SCROLLD            
4061 07				db 6 + 1 
4062 .. 00			db "SCROLL",0              
4069				endm 
# End of macro CWHEAD
4069			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4069					if DEBUG_FORTH_WORDS_KEY 
4069						DMARK "SCR" 
4069 f5				push af  
406a 3a 7e 40			ld a, (.dmark)  
406d 32 6b ee			ld (debug_mark),a  
4070 3a 7f 40			ld a, (.dmark+1)  
4073 32 6c ee			ld (debug_mark+1),a  
4076 3a 80 40			ld a, (.dmark+2)  
4079 32 6d ee			ld (debug_mark+2),a  
407c 18 03			jr .pastdmark  
407e ..			.dmark: db "SCR"  
4081 f1			.pastdmark: pop af  
4082			endm  
# End of macro DMARK
4082						CALLMONITOR 
4082 cd 6f ee			call debug_vector  
4085				endm  
# End of macro CALLMONITOR
4085					endif 
4085			 
4085 cd 7b 0b			call scroll_up 
4088			;	call update_display 
4088			 
4088					NEXTW 
4088 c3 f3 1f			jp macro_next 
408b				endm 
# End of macro NEXTW
408b			 
408b			 
408b			 
408b			;		; get dir 
408b			; 
408b			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
408b			; 
408b			;		push hl 
408b			; 
408b			;		; destroy value TOS 
408b			; 
408b			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
408b			; 
408b			;		; get count 
408b			; 
408b			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
408b			; 
408b			;		push hl 
408b			; 
408b			;		; destroy value TOS 
408b			; 
408b			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
408b			; 
408b			;		; one value on hl get other one back 
408b			; 
408b			;		pop bc    ; count 
408b			; 
408b			;		pop de   ; dir 
408b			; 
408b			; 
408b			;		ld b, c 
408b			; 
408b			;.scrolldir:     push bc 
408b			;		push de 
408b			; 
408b			;		ld a, 0 
408b			;		cp e 
408b			;		jr z, .scrollup  
408b			;		call scroll_down 
408b			;		jr .scrollnext 
408b			;.scrollup:	call scroll_up 
408b			; 
408b			;		 
408b			;.scrollnext: 
408b			;		pop de 
408b			;		pop bc 
408b			;		djnz .scrolldir 
408b			; 
408b			; 
408b			; 
408b			; 
408b			; 
408b			;		NEXTW 
408b			 
408b			.SCROLLD: 
408b				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
408b 53				db WORD_SYS_CORE+63             
408c b9 40			dw .ATQ            
408e 08				db 7 + 1 
408f .. 00			db "SCROLLD",0              
4097				endm 
# End of macro CWHEAD
4097			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4097					if DEBUG_FORTH_WORDS_KEY 
4097						DMARK "SCD" 
4097 f5				push af  
4098 3a ac 40			ld a, (.dmark)  
409b 32 6b ee			ld (debug_mark),a  
409e 3a ad 40			ld a, (.dmark+1)  
40a1 32 6c ee			ld (debug_mark+1),a  
40a4 3a ae 40			ld a, (.dmark+2)  
40a7 32 6d ee			ld (debug_mark+2),a  
40aa 18 03			jr .pastdmark  
40ac ..			.dmark: db "SCD"  
40af f1			.pastdmark: pop af  
40b0			endm  
# End of macro DMARK
40b0						CALLMONITOR 
40b0 cd 6f ee			call debug_vector  
40b3				endm  
# End of macro CALLMONITOR
40b3					endif 
40b3			 
40b3 cd 9f 0b			call scroll_down 
40b6			;	call update_display 
40b6			 
40b6					NEXTW 
40b6 c3 f3 1f			jp macro_next 
40b9				endm 
# End of macro NEXTW
40b9			 
40b9			 
40b9			.ATQ: 
40b9				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
40b9 62				db WORD_SYS_CORE+78             
40ba 17 41			dw .AUTODSP            
40bc 04				db 3 + 1 
40bd .. 00			db "AT@",0              
40c1				endm 
# End of macro CWHEAD
40c1			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
40c1					if DEBUG_FORTH_WORDS_KEY 
40c1						DMARK "ATA" 
40c1 f5				push af  
40c2 3a d6 40			ld a, (.dmark)  
40c5 32 6b ee			ld (debug_mark),a  
40c8 3a d7 40			ld a, (.dmark+1)  
40cb 32 6c ee			ld (debug_mark+1),a  
40ce 3a d8 40			ld a, (.dmark+2)  
40d1 32 6d ee			ld (debug_mark+2),a  
40d4 18 03			jr .pastdmark  
40d6 ..			.dmark: db "ATA"  
40d9 f1			.pastdmark: pop af  
40da			endm  
# End of macro DMARK
40da						CALLMONITOR 
40da cd 6f ee			call debug_vector  
40dd				endm  
# End of macro CALLMONITOR
40dd					endif 
40dd			 
40dd			 
40dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
40dd cd 3d 1e			call macro_dsp_valuehl 
40e0				endm 
# End of macro FORTH_DSP_VALUEHL
40e0			 
40e0					; TODO save cursor row 
40e0 7d					ld a,l 
40e1 fe 02				cp 2 
40e3 20 04				jr nz, .crow3aq 
40e5 3e 28				ld a, display_row_2 
40e7 18 12				jr .ccol1aq 
40e9 fe 03		.crow3aq:		cp 3 
40eb 20 04				jr nz, .crow4aq 
40ed 3e 50				ld a, display_row_3 
40ef 18 0a				jr .ccol1aq 
40f1 fe 04		.crow4aq:		cp 4 
40f3 20 04				jr nz, .crow1aq 
40f5 3e 78				ld a, display_row_4 
40f7 18 02				jr .ccol1aq 
40f9 3e 00		.crow1aq:		ld a,display_row_1 
40fb f5			.ccol1aq:		push af			; got row offset 
40fc 6f					ld l,a 
40fd 26 00				ld h,0 
40ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40ff cd f5 1e			call macro_forth_dsp_pop 
4102				endm 
# End of macro FORTH_DSP_POP
4102					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4102 cd 3d 1e			call macro_dsp_valuehl 
4105				endm 
# End of macro FORTH_DSP_VALUEHL
4105					; TODO save cursor col 
4105 f1					pop af 
4106 85					add l		; add col offset 
4107			 
4107					; add current frame buffer address 
4107 2a cc eb				ld hl, (display_fb_active) 
410a cd e6 0d				call addatohl 
410d			 
410d			 
410d			 
410d			 
410d					; get char frame buffer location offset in hl 
410d			 
410d 7e					ld a,(hl) 
410e 26 00				ld h, 0 
4110 6f					ld l, a 
4111			 
4111 cd 46 1c				call forth_push_numhl 
4114			 
4114			 
4114					NEXTW 
4114 c3 f3 1f			jp macro_next 
4117				endm 
# End of macro NEXTW
4117			 
4117			.AUTODSP: 
4117				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4117 63				db WORD_SYS_CORE+79             
4118 2d 41			dw .MENU            
411a 05				db 4 + 1 
411b .. 00			db "ADSP",0              
4120				endm 
# End of macro CWHEAD
4120			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4120			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4120			 
4120					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4120 cd 3d 1e			call macro_dsp_valuehl 
4123				endm 
# End of macro FORTH_DSP_VALUEHL
4123			 
4123			;		push hl 
4123			 
4123					; destroy value TOS 
4123			 
4123					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4123 cd f5 1e			call macro_forth_dsp_pop 
4126				endm 
# End of macro FORTH_DSP_POP
4126			 
4126			;		pop hl 
4126			 
4126 7d					ld a,l 
4127 32 3c ea				ld (cli_autodisplay), a 
412a				       NEXTW 
412a c3 f3 1f			jp macro_next 
412d				endm 
# End of macro NEXTW
412d			 
412d			.MENU: 
412d				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
412d 70				db WORD_SYS_CORE+92             
412e d6 41			dw .ENDDISPLAY            
4130 05				db 4 + 1 
4131 .. 00			db "MENU",0              
4136				endm 
# End of macro CWHEAD
4136			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
4136			 
4136			;		; get number of items on the stack 
4136			; 
4136				 
4136					FORTH_DSP_VALUEHL 
4136 cd 3d 1e			call macro_dsp_valuehl 
4139				endm 
# End of macro FORTH_DSP_VALUEHL
4139				 
4139					if DEBUG_FORTH_WORDS_KEY 
4139						DMARK "MNU" 
4139 f5				push af  
413a 3a 4e 41			ld a, (.dmark)  
413d 32 6b ee			ld (debug_mark),a  
4140 3a 4f 41			ld a, (.dmark+1)  
4143 32 6c ee			ld (debug_mark+1),a  
4146 3a 50 41			ld a, (.dmark+2)  
4149 32 6d ee			ld (debug_mark+2),a  
414c 18 03			jr .pastdmark  
414e ..			.dmark: db "MNU"  
4151 f1			.pastdmark: pop af  
4152			endm  
# End of macro DMARK
4152						CALLMONITOR 
4152 cd 6f ee			call debug_vector  
4155				endm  
# End of macro CALLMONITOR
4155					endif 
4155			 
4155 45					ld b, l	 
4156 05					dec b 
4157			 
4157					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4157 cd f5 1e			call macro_forth_dsp_pop 
415a				endm 
# End of macro FORTH_DSP_POP
415a			 
415a			 
415a					; go directly through the stack to pluck out the string pointers and build an array 
415a			 
415a			;		FORTH_DSP 
415a			 
415a					; hl contains top most stack item 
415a				 
415a 11 c1 e2				ld de, scratch 
415d			 
415d			.mbuild: 
415d			 
415d					FORTH_DSP_VALUEHL 
415d cd 3d 1e			call macro_dsp_valuehl 
4160				endm 
# End of macro FORTH_DSP_VALUEHL
4160			 
4160					if DEBUG_FORTH_WORDS 
4160						DMARK "MN3" 
4160 f5				push af  
4161 3a 75 41			ld a, (.dmark)  
4164 32 6b ee			ld (debug_mark),a  
4167 3a 76 41			ld a, (.dmark+1)  
416a 32 6c ee			ld (debug_mark+1),a  
416d 3a 77 41			ld a, (.dmark+2)  
4170 32 6d ee			ld (debug_mark+2),a  
4173 18 03			jr .pastdmark  
4175 ..			.dmark: db "MN3"  
4178 f1			.pastdmark: pop af  
4179			endm  
# End of macro DMARK
4179						CALLMONITOR 
4179 cd 6f ee			call debug_vector  
417c				endm  
# End of macro CALLMONITOR
417c					endif 
417c eb					ex de, hl 
417d 73					ld (hl), e 
417e 23					inc hl 
417f 72					ld (hl), d 
4180 23					inc hl 
4181 eb					ex de, hl 
4182			 
4182					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4182 cd f5 1e			call macro_forth_dsp_pop 
4185				endm 
# End of macro FORTH_DSP_POP
4185			 
4185 10 d6				djnz .mbuild 
4187			 
4187					; done add term 
4187			 
4187 eb					ex de, hl 
4188 36 00				ld (hl), 0 
418a 23					inc hl 
418b 36 00				ld (hl), 0 
418d			 
418d				 
418d					 
418d 21 c1 e2				ld hl, scratch 
4190			 
4190					if DEBUG_FORTH_WORDS 
4190						DMARK "MNx" 
4190 f5				push af  
4191 3a a5 41			ld a, (.dmark)  
4194 32 6b ee			ld (debug_mark),a  
4197 3a a6 41			ld a, (.dmark+1)  
419a 32 6c ee			ld (debug_mark+1),a  
419d 3a a7 41			ld a, (.dmark+2)  
41a0 32 6d ee			ld (debug_mark+2),a  
41a3 18 03			jr .pastdmark  
41a5 ..			.dmark: db "MNx"  
41a8 f1			.pastdmark: pop af  
41a9			endm  
# End of macro DMARK
41a9						CALLMONITOR 
41a9 cd 6f ee			call debug_vector  
41ac				endm  
# End of macro CALLMONITOR
41ac					endif 
41ac			 
41ac			 
41ac			 
41ac 3e 00				ld a, 0 
41ae cd ea 0b				call menu 
41b1			 
41b1			 
41b1 6f					ld l, a 
41b2 26 00				ld h, 0 
41b4			 
41b4					if DEBUG_FORTH_WORDS 
41b4						DMARK "MNr" 
41b4 f5				push af  
41b5 3a c9 41			ld a, (.dmark)  
41b8 32 6b ee			ld (debug_mark),a  
41bb 3a ca 41			ld a, (.dmark+1)  
41be 32 6c ee			ld (debug_mark+1),a  
41c1 3a cb 41			ld a, (.dmark+2)  
41c4 32 6d ee			ld (debug_mark+2),a  
41c7 18 03			jr .pastdmark  
41c9 ..			.dmark: db "MNr"  
41cc f1			.pastdmark: pop af  
41cd			endm  
# End of macro DMARK
41cd						CALLMONITOR 
41cd cd 6f ee			call debug_vector  
41d0				endm  
# End of macro CALLMONITOR
41d0					endif 
41d0			 
41d0 cd 46 1c				call forth_push_numhl 
41d3			 
41d3			 
41d3			 
41d3			 
41d3				       NEXTW 
41d3 c3 f3 1f			jp macro_next 
41d6				endm 
# End of macro NEXTW
41d6			 
41d6			 
41d6			.ENDDISPLAY: 
41d6			 
41d6			; eof 
# End of file forth_words_display.asm
41d6			include "forth_words_str.asm" 
41d6			 
41d6			; | ## String Words 
41d6			 
41d6			.PTR:   
41d6			 
41d6				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
41d6 48				db WORD_SYS_CORE+52             
41d7 03 42			dw .STYPE            
41d9 04				db 3 + 1 
41da .. 00			db "PTR",0              
41de				endm 
# End of macro CWHEAD
41de			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
41de			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
41de			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
41de			 
41de					if DEBUG_FORTH_WORDS_KEY 
41de						DMARK "PTR" 
41de f5				push af  
41df 3a f3 41			ld a, (.dmark)  
41e2 32 6b ee			ld (debug_mark),a  
41e5 3a f4 41			ld a, (.dmark+1)  
41e8 32 6c ee			ld (debug_mark+1),a  
41eb 3a f5 41			ld a, (.dmark+2)  
41ee 32 6d ee			ld (debug_mark+2),a  
41f1 18 03			jr .pastdmark  
41f3 ..			.dmark: db "PTR"  
41f6 f1			.pastdmark: pop af  
41f7			endm  
# End of macro DMARK
41f7						CALLMONITOR 
41f7 cd 6f ee			call debug_vector  
41fa				endm  
# End of macro CALLMONITOR
41fa					endif 
41fa					FORTH_DSP_VALUEHL 
41fa cd 3d 1e			call macro_dsp_valuehl 
41fd				endm 
# End of macro FORTH_DSP_VALUEHL
41fd cd 46 1c				call forth_push_numhl 
4200			 
4200			 
4200					NEXTW 
4200 c3 f3 1f			jp macro_next 
4203				endm 
# End of macro NEXTW
4203			.STYPE: 
4203				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4203 48				db WORD_SYS_CORE+52             
4204 52 42			dw .UPPER            
4206 06				db 5 + 1 
4207 .. 00			db "STYPE",0              
420d				endm 
# End of macro CWHEAD
420d			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
420d					if DEBUG_FORTH_WORDS_KEY 
420d						DMARK "STY" 
420d f5				push af  
420e 3a 22 42			ld a, (.dmark)  
4211 32 6b ee			ld (debug_mark),a  
4214 3a 23 42			ld a, (.dmark+1)  
4217 32 6c ee			ld (debug_mark+1),a  
421a 3a 24 42			ld a, (.dmark+2)  
421d 32 6d ee			ld (debug_mark+2),a  
4220 18 03			jr .pastdmark  
4222 ..			.dmark: db "STY"  
4225 f1			.pastdmark: pop af  
4226			endm  
# End of macro DMARK
4226						CALLMONITOR 
4226 cd 6f ee			call debug_vector  
4229				endm  
# End of macro CALLMONITOR
4229					endif 
4229					FORTH_DSP 
4229 cd 03 1e			call macro_forth_dsp 
422c				endm 
# End of macro FORTH_DSP
422c					;v5 FORTH_DSP_VALUE 
422c			 
422c 7e					ld a, (hl) 
422d			 
422d f5					push af 
422e			 
422e			; Dont destroy TOS		FORTH_DSP_POP 
422e			 
422e f1					pop af 
422f			 
422f fe 01				cp DS_TYPE_STR 
4231 28 09				jr z, .typestr 
4233			 
4233 fe 02				cp DS_TYPE_INUM 
4235 28 0a				jr z, .typeinum 
4237			 
4237 21 50 42				ld hl, .tna 
423a 18 0a				jr .tpush 
423c			 
423c 21 4c 42		.typestr:	ld hl, .tstr 
423f 18 05				jr .tpush 
4241 21 4e 42		.typeinum:	ld hl, .tinum 
4244 18 00				jr .tpush 
4246			 
4246			.tpush: 
4246			 
4246 cd b4 1c				call forth_push_str 
4249			 
4249					NEXTW 
4249 c3 f3 1f			jp macro_next 
424c				endm 
# End of macro NEXTW
424c .. 00		.tstr:	db "s",0 
424e .. 00		.tinum:  db "i",0 
4250 .. 00		.tna:   db "?", 0 
4252			 
4252			 
4252			.UPPER: 
4252				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4252 48				db WORD_SYS_CORE+52             
4253 8d 42			dw .LOWER            
4255 06				db 5 + 1 
4256 .. 00			db "UPPER",0              
425c				endm 
# End of macro CWHEAD
425c			; | UPPER ( s -- s ) Upper case string s  | DONE 
425c					if DEBUG_FORTH_WORDS_KEY 
425c						DMARK "UPR" 
425c f5				push af  
425d 3a 71 42			ld a, (.dmark)  
4260 32 6b ee			ld (debug_mark),a  
4263 3a 72 42			ld a, (.dmark+1)  
4266 32 6c ee			ld (debug_mark+1),a  
4269 3a 73 42			ld a, (.dmark+2)  
426c 32 6d ee			ld (debug_mark+2),a  
426f 18 03			jr .pastdmark  
4271 ..			.dmark: db "UPR"  
4274 f1			.pastdmark: pop af  
4275			endm  
# End of macro DMARK
4275						CALLMONITOR 
4275 cd 6f ee			call debug_vector  
4278				endm  
# End of macro CALLMONITOR
4278					endif 
4278			 
4278					FORTH_DSP 
4278 cd 03 1e			call macro_forth_dsp 
427b				endm 
# End of macro FORTH_DSP
427b					 
427b			; TODO check is string type 
427b			 
427b					FORTH_DSP_VALUEHL 
427b cd 3d 1e			call macro_dsp_valuehl 
427e				endm 
# End of macro FORTH_DSP_VALUEHL
427e			; get pointer to string in hl 
427e			 
427e 7e			.toup:		ld a, (hl) 
427f fe 00				cp 0 
4281 28 07				jr z, .toupdone 
4283			 
4283 cd 53 11				call to_upper 
4286			 
4286 77					ld (hl), a 
4287 23					inc hl 
4288 18 f4				jr .toup 
428a			 
428a					 
428a			 
428a			 
428a			; for each char convert to upper 
428a					 
428a			.toupdone: 
428a			 
428a			 
428a					NEXTW 
428a c3 f3 1f			jp macro_next 
428d				endm 
# End of macro NEXTW
428d			.LOWER: 
428d				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
428d 48				db WORD_SYS_CORE+52             
428e c8 42			dw .TCASE            
4290 06				db 5 + 1 
4291 .. 00			db "LOWER",0              
4297				endm 
# End of macro CWHEAD
4297			; | LOWER ( s -- s ) Lower case string s  | DONE 
4297					if DEBUG_FORTH_WORDS_KEY 
4297						DMARK "LWR" 
4297 f5				push af  
4298 3a ac 42			ld a, (.dmark)  
429b 32 6b ee			ld (debug_mark),a  
429e 3a ad 42			ld a, (.dmark+1)  
42a1 32 6c ee			ld (debug_mark+1),a  
42a4 3a ae 42			ld a, (.dmark+2)  
42a7 32 6d ee			ld (debug_mark+2),a  
42aa 18 03			jr .pastdmark  
42ac ..			.dmark: db "LWR"  
42af f1			.pastdmark: pop af  
42b0			endm  
# End of macro DMARK
42b0						CALLMONITOR 
42b0 cd 6f ee			call debug_vector  
42b3				endm  
# End of macro CALLMONITOR
42b3					endif 
42b3			 
42b3					FORTH_DSP 
42b3 cd 03 1e			call macro_forth_dsp 
42b6				endm 
# End of macro FORTH_DSP
42b6					 
42b6			; TODO check is string type 
42b6			 
42b6					FORTH_DSP_VALUEHL 
42b6 cd 3d 1e			call macro_dsp_valuehl 
42b9				endm 
# End of macro FORTH_DSP_VALUEHL
42b9			; get pointer to string in hl 
42b9			 
42b9 7e			.tolow:		ld a, (hl) 
42ba fe 00				cp 0 
42bc 28 07				jr z, .tolowdone 
42be			 
42be cd 5c 11				call to_lower 
42c1			 
42c1 77					ld (hl), a 
42c2 23					inc hl 
42c3 18 f4				jr .tolow 
42c5			 
42c5					 
42c5			 
42c5			 
42c5			; for each char convert to low 
42c5					 
42c5			.tolowdone: 
42c5					NEXTW 
42c5 c3 f3 1f			jp macro_next 
42c8				endm 
# End of macro NEXTW
42c8			.TCASE: 
42c8				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
42c8 48				db WORD_SYS_CORE+52             
42c9 fe 43			dw .SUBSTR            
42cb 06				db 5 + 1 
42cc .. 00			db "TCASE",0              
42d2				endm 
# End of macro CWHEAD
42d2			; | TCASE ( s -- s ) Title case string s  | DONE 
42d2					if DEBUG_FORTH_WORDS_KEY 
42d2						DMARK "TCS" 
42d2 f5				push af  
42d3 3a e7 42			ld a, (.dmark)  
42d6 32 6b ee			ld (debug_mark),a  
42d9 3a e8 42			ld a, (.dmark+1)  
42dc 32 6c ee			ld (debug_mark+1),a  
42df 3a e9 42			ld a, (.dmark+2)  
42e2 32 6d ee			ld (debug_mark+2),a  
42e5 18 03			jr .pastdmark  
42e7 ..			.dmark: db "TCS"  
42ea f1			.pastdmark: pop af  
42eb			endm  
# End of macro DMARK
42eb						CALLMONITOR 
42eb cd 6f ee			call debug_vector  
42ee				endm  
# End of macro CALLMONITOR
42ee					endif 
42ee			 
42ee					FORTH_DSP 
42ee cd 03 1e			call macro_forth_dsp 
42f1				endm 
# End of macro FORTH_DSP
42f1					 
42f1			; TODO check is string type 
42f1			 
42f1					FORTH_DSP_VALUEHL 
42f1 cd 3d 1e			call macro_dsp_valuehl 
42f4				endm 
# End of macro FORTH_DSP_VALUEHL
42f4			; get pointer to string in hl 
42f4			 
42f4					if DEBUG_FORTH_WORDS 
42f4						DMARK "TC1" 
42f4 f5				push af  
42f5 3a 09 43			ld a, (.dmark)  
42f8 32 6b ee			ld (debug_mark),a  
42fb 3a 0a 43			ld a, (.dmark+1)  
42fe 32 6c ee			ld (debug_mark+1),a  
4301 3a 0b 43			ld a, (.dmark+2)  
4304 32 6d ee			ld (debug_mark+2),a  
4307 18 03			jr .pastdmark  
4309 ..			.dmark: db "TC1"  
430c f1			.pastdmark: pop af  
430d			endm  
# End of macro DMARK
430d						CALLMONITOR 
430d cd 6f ee			call debug_vector  
4310				endm  
# End of macro CALLMONITOR
4310					endif 
4310			 
4310					; first time in turn to upper case first char 
4310			 
4310 7e					ld a, (hl) 
4311 c3 9b 43				jp .totsiptou 
4314			 
4314			 
4314 7e			.tot:		ld a, (hl) 
4315 fe 00				cp 0 
4317 ca df 43				jp z, .totdone 
431a			 
431a					if DEBUG_FORTH_WORDS 
431a						DMARK "TC2" 
431a f5				push af  
431b 3a 2f 43			ld a, (.dmark)  
431e 32 6b ee			ld (debug_mark),a  
4321 3a 30 43			ld a, (.dmark+1)  
4324 32 6c ee			ld (debug_mark+1),a  
4327 3a 31 43			ld a, (.dmark+2)  
432a 32 6d ee			ld (debug_mark+2),a  
432d 18 03			jr .pastdmark  
432f ..			.dmark: db "TC2"  
4332 f1			.pastdmark: pop af  
4333			endm  
# End of macro DMARK
4333						CALLMONITOR 
4333 cd 6f ee			call debug_vector  
4336				endm  
# End of macro CALLMONITOR
4336					endif 
4336					; check to see if current char is a space 
4336			 
4336 fe 20				cp ' ' 
4338 28 21				jr z, .totsp 
433a cd 5c 11				call to_lower 
433d					if DEBUG_FORTH_WORDS 
433d						DMARK "TC3" 
433d f5				push af  
433e 3a 52 43			ld a, (.dmark)  
4341 32 6b ee			ld (debug_mark),a  
4344 3a 53 43			ld a, (.dmark+1)  
4347 32 6c ee			ld (debug_mark+1),a  
434a 3a 54 43			ld a, (.dmark+2)  
434d 32 6d ee			ld (debug_mark+2),a  
4350 18 03			jr .pastdmark  
4352 ..			.dmark: db "TC3"  
4355 f1			.pastdmark: pop af  
4356			endm  
# End of macro DMARK
4356						CALLMONITOR 
4356 cd 6f ee			call debug_vector  
4359				endm  
# End of macro CALLMONITOR
4359					endif 
4359 18 63				jr .totnxt 
435b			 
435b			.totsp:         ; on a space, find next char which should be upper 
435b			 
435b					if DEBUG_FORTH_WORDS 
435b						DMARK "TC4" 
435b f5				push af  
435c 3a 70 43			ld a, (.dmark)  
435f 32 6b ee			ld (debug_mark),a  
4362 3a 71 43			ld a, (.dmark+1)  
4365 32 6c ee			ld (debug_mark+1),a  
4368 3a 72 43			ld a, (.dmark+2)  
436b 32 6d ee			ld (debug_mark+2),a  
436e 18 03			jr .pastdmark  
4370 ..			.dmark: db "TC4"  
4373 f1			.pastdmark: pop af  
4374			endm  
# End of macro DMARK
4374						CALLMONITOR 
4374 cd 6f ee			call debug_vector  
4377				endm  
# End of macro CALLMONITOR
4377					endif 
4377					;; 
4377			 
4377 fe 20				cp ' ' 
4379 20 20				jr nz, .totsiptou 
437b 23					inc hl 
437c 7e					ld a, (hl) 
437d					if DEBUG_FORTH_WORDS 
437d						DMARK "TC5" 
437d f5				push af  
437e 3a 92 43			ld a, (.dmark)  
4381 32 6b ee			ld (debug_mark),a  
4384 3a 93 43			ld a, (.dmark+1)  
4387 32 6c ee			ld (debug_mark+1),a  
438a 3a 94 43			ld a, (.dmark+2)  
438d 32 6d ee			ld (debug_mark+2),a  
4390 18 03			jr .pastdmark  
4392 ..			.dmark: db "TC5"  
4395 f1			.pastdmark: pop af  
4396			endm  
# End of macro DMARK
4396						CALLMONITOR 
4396 cd 6f ee			call debug_vector  
4399				endm  
# End of macro CALLMONITOR
4399					endif 
4399 18 c0				jr .totsp 
439b fe 00		.totsiptou:    cp 0 
439d 28 40				jr z, .totdone 
439f					; not space and not zero term so upper case it 
439f cd 53 11				call to_upper 
43a2			 
43a2					if DEBUG_FORTH_WORDS 
43a2						DMARK "TC6" 
43a2 f5				push af  
43a3 3a b7 43			ld a, (.dmark)  
43a6 32 6b ee			ld (debug_mark),a  
43a9 3a b8 43			ld a, (.dmark+1)  
43ac 32 6c ee			ld (debug_mark+1),a  
43af 3a b9 43			ld a, (.dmark+2)  
43b2 32 6d ee			ld (debug_mark+2),a  
43b5 18 03			jr .pastdmark  
43b7 ..			.dmark: db "TC6"  
43ba f1			.pastdmark: pop af  
43bb			endm  
# End of macro DMARK
43bb						CALLMONITOR 
43bb cd 6f ee			call debug_vector  
43be				endm  
# End of macro CALLMONITOR
43be					endif 
43be			 
43be			 
43be			.totnxt: 
43be			 
43be 77					ld (hl), a 
43bf 23					inc hl 
43c0					if DEBUG_FORTH_WORDS 
43c0						DMARK "TC7" 
43c0 f5				push af  
43c1 3a d5 43			ld a, (.dmark)  
43c4 32 6b ee			ld (debug_mark),a  
43c7 3a d6 43			ld a, (.dmark+1)  
43ca 32 6c ee			ld (debug_mark+1),a  
43cd 3a d7 43			ld a, (.dmark+2)  
43d0 32 6d ee			ld (debug_mark+2),a  
43d3 18 03			jr .pastdmark  
43d5 ..			.dmark: db "TC7"  
43d8 f1			.pastdmark: pop af  
43d9			endm  
# End of macro DMARK
43d9						CALLMONITOR 
43d9 cd 6f ee			call debug_vector  
43dc				endm  
# End of macro CALLMONITOR
43dc					endif 
43dc c3 14 43				jp .tot 
43df			 
43df					 
43df			 
43df			 
43df			; for each char convert to low 
43df					 
43df			.totdone: 
43df					if DEBUG_FORTH_WORDS 
43df						DMARK "TCd" 
43df f5				push af  
43e0 3a f4 43			ld a, (.dmark)  
43e3 32 6b ee			ld (debug_mark),a  
43e6 3a f5 43			ld a, (.dmark+1)  
43e9 32 6c ee			ld (debug_mark+1),a  
43ec 3a f6 43			ld a, (.dmark+2)  
43ef 32 6d ee			ld (debug_mark+2),a  
43f2 18 03			jr .pastdmark  
43f4 ..			.dmark: db "TCd"  
43f7 f1			.pastdmark: pop af  
43f8			endm  
# End of macro DMARK
43f8						CALLMONITOR 
43f8 cd 6f ee			call debug_vector  
43fb				endm  
# End of macro CALLMONITOR
43fb					endif 
43fb					NEXTW 
43fb c3 f3 1f			jp macro_next 
43fe				endm 
# End of macro NEXTW
43fe			 
43fe			.SUBSTR: 
43fe				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
43fe 48				db WORD_SYS_CORE+52             
43ff 5c 44			dw .LEFT            
4401 07				db 6 + 1 
4402 .. 00			db "SUBSTR",0              
4409				endm 
# End of macro CWHEAD
4409			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4409			 
4409					if DEBUG_FORTH_WORDS_KEY 
4409						DMARK "SST" 
4409 f5				push af  
440a 3a 1e 44			ld a, (.dmark)  
440d 32 6b ee			ld (debug_mark),a  
4410 3a 1f 44			ld a, (.dmark+1)  
4413 32 6c ee			ld (debug_mark+1),a  
4416 3a 20 44			ld a, (.dmark+2)  
4419 32 6d ee			ld (debug_mark+2),a  
441c 18 03			jr .pastdmark  
441e ..			.dmark: db "SST"  
4421 f1			.pastdmark: pop af  
4422			endm  
# End of macro DMARK
4422						CALLMONITOR 
4422 cd 6f ee			call debug_vector  
4425				endm  
# End of macro CALLMONITOR
4425					endif 
4425			; TODO check string type 
4425					FORTH_DSP_VALUEHL 
4425 cd 3d 1e			call macro_dsp_valuehl 
4428				endm 
# End of macro FORTH_DSP_VALUEHL
4428			 
4428 e5					push hl      ; string length 
4429			 
4429					FORTH_DSP_POP 
4429 cd f5 1e			call macro_forth_dsp_pop 
442c				endm 
# End of macro FORTH_DSP_POP
442c			 
442c					FORTH_DSP_VALUEHL 
442c cd 3d 1e			call macro_dsp_valuehl 
442f				endm 
# End of macro FORTH_DSP_VALUEHL
442f			 
442f e5					push hl     ; start char 
4430			 
4430					FORTH_DSP_POP 
4430 cd f5 1e			call macro_forth_dsp_pop 
4433				endm 
# End of macro FORTH_DSP_POP
4433			 
4433			 
4433					FORTH_DSP_VALUE 
4433 cd 26 1e			call macro_forth_dsp_value 
4436				endm 
# End of macro FORTH_DSP_VALUE
4436			 
4436 d1					pop de    ; get start post offset 
4437			 
4437 19					add hl, de    ; starting offset 
4438			 
4438 c1					pop bc 
4439 c5					push bc      ; grab size of string 
443a			 
443a e5					push hl    ; save string start  
443b			 
443b 26 00				ld h, 0 
443d 69					ld l, c 
443e 23					inc hl 
443f 23					inc hl 
4440			 
4440 cd ad 12				call malloc 
4443				if DEBUG_FORTH_MALLOC_GUARD 
4443 cc 76 4d				call z,malloc_error 
4446				endif 
4446			 
4446 eb					ex de, hl      ; save malloc area for string copy 
4447 e1					pop hl    ; get back source 
4448 c1					pop bc    ; get length of string back 
4449			 
4449 d5					push de    ; save malloc area for after we push 
444a ed b0				ldir     ; copy substr 
444c			 
444c			 
444c eb					ex de, hl 
444d 3e 00				ld a, 0 
444f 77					ld (hl), a   ; term substr 
4450			 
4450					 
4450 e1					pop hl    ; get malloc so we can push it 
4451 e5					push hl   ; save so we can free it afterwards 
4452			 
4452 cd b4 1c				call forth_push_str 
4455			 
4455 e1					pop hl 
4456 cd 77 13				call free 
4459			 
4459					 
4459					 
4459			 
4459			 
4459					NEXTW 
4459 c3 f3 1f			jp macro_next 
445c				endm 
# End of macro NEXTW
445c			 
445c			.LEFT: 
445c				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
445c 48				db WORD_SYS_CORE+52             
445d 84 44			dw .RIGHT            
445f 05				db 4 + 1 
4460 .. 00			db "LEFT",0              
4465				endm 
# End of macro CWHEAD
4465			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4465					if DEBUG_FORTH_WORDS_KEY 
4465						DMARK "LEF" 
4465 f5				push af  
4466 3a 7a 44			ld a, (.dmark)  
4469 32 6b ee			ld (debug_mark),a  
446c 3a 7b 44			ld a, (.dmark+1)  
446f 32 6c ee			ld (debug_mark+1),a  
4472 3a 7c 44			ld a, (.dmark+2)  
4475 32 6d ee			ld (debug_mark+2),a  
4478 18 03			jr .pastdmark  
447a ..			.dmark: db "LEF"  
447d f1			.pastdmark: pop af  
447e			endm  
# End of macro DMARK
447e						CALLMONITOR 
447e cd 6f ee			call debug_vector  
4481				endm  
# End of macro CALLMONITOR
4481					endif 
4481			 
4481					NEXTW 
4481 c3 f3 1f			jp macro_next 
4484				endm 
# End of macro NEXTW
4484			.RIGHT: 
4484				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4484 48				db WORD_SYS_CORE+52             
4485 ad 44			dw .STR2NUM            
4487 06				db 5 + 1 
4488 .. 00			db "RIGHT",0              
448e				endm 
# End of macro CWHEAD
448e			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
448e					if DEBUG_FORTH_WORDS_KEY 
448e						DMARK "RIG" 
448e f5				push af  
448f 3a a3 44			ld a, (.dmark)  
4492 32 6b ee			ld (debug_mark),a  
4495 3a a4 44			ld a, (.dmark+1)  
4498 32 6c ee			ld (debug_mark+1),a  
449b 3a a5 44			ld a, (.dmark+2)  
449e 32 6d ee			ld (debug_mark+2),a  
44a1 18 03			jr .pastdmark  
44a3 ..			.dmark: db "RIG"  
44a6 f1			.pastdmark: pop af  
44a7			endm  
# End of macro DMARK
44a7						CALLMONITOR 
44a7 cd 6f ee			call debug_vector  
44aa				endm  
# End of macro CALLMONITOR
44aa					endif 
44aa			 
44aa					NEXTW 
44aa c3 f3 1f			jp macro_next 
44ad				endm 
# End of macro NEXTW
44ad			 
44ad			 
44ad			.STR2NUM: 
44ad				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
44ad 48				db WORD_SYS_CORE+52             
44ae 39 45			dw .NUM2STR            
44b0 08				db 7 + 1 
44b1 .. 00			db "STR2NUM",0              
44b9				endm 
# End of macro CWHEAD
44b9			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
44b9			 
44b9			 
44b9			; TODO STR type check to do 
44b9					if DEBUG_FORTH_WORDS_KEY 
44b9						DMARK "S2N" 
44b9 f5				push af  
44ba 3a ce 44			ld a, (.dmark)  
44bd 32 6b ee			ld (debug_mark),a  
44c0 3a cf 44			ld a, (.dmark+1)  
44c3 32 6c ee			ld (debug_mark+1),a  
44c6 3a d0 44			ld a, (.dmark+2)  
44c9 32 6d ee			ld (debug_mark+2),a  
44cc 18 03			jr .pastdmark  
44ce ..			.dmark: db "S2N"  
44d1 f1			.pastdmark: pop af  
44d2			endm  
# End of macro DMARK
44d2						CALLMONITOR 
44d2 cd 6f ee			call debug_vector  
44d5				endm  
# End of macro CALLMONITOR
44d5					endif 
44d5			 
44d5					;FORTH_DSP 
44d5					FORTH_DSP_VALUE 
44d5 cd 26 1e			call macro_forth_dsp_value 
44d8				endm 
# End of macro FORTH_DSP_VALUE
44d8					;inc hl 
44d8			 
44d8 eb					ex de, hl 
44d9					if DEBUG_FORTH_WORDS 
44d9						DMARK "S2a" 
44d9 f5				push af  
44da 3a ee 44			ld a, (.dmark)  
44dd 32 6b ee			ld (debug_mark),a  
44e0 3a ef 44			ld a, (.dmark+1)  
44e3 32 6c ee			ld (debug_mark+1),a  
44e6 3a f0 44			ld a, (.dmark+2)  
44e9 32 6d ee			ld (debug_mark+2),a  
44ec 18 03			jr .pastdmark  
44ee ..			.dmark: db "S2a"  
44f1 f1			.pastdmark: pop af  
44f2			endm  
# End of macro DMARK
44f2						CALLMONITOR 
44f2 cd 6f ee			call debug_vector  
44f5				endm  
# End of macro CALLMONITOR
44f5					endif 
44f5 cd db 11				call string_to_uint16 
44f8			 
44f8					if DEBUG_FORTH_WORDS 
44f8						DMARK "S2b" 
44f8 f5				push af  
44f9 3a 0d 45			ld a, (.dmark)  
44fc 32 6b ee			ld (debug_mark),a  
44ff 3a 0e 45			ld a, (.dmark+1)  
4502 32 6c ee			ld (debug_mark+1),a  
4505 3a 0f 45			ld a, (.dmark+2)  
4508 32 6d ee			ld (debug_mark+2),a  
450b 18 03			jr .pastdmark  
450d ..			.dmark: db "S2b"  
4510 f1			.pastdmark: pop af  
4511			endm  
# End of macro DMARK
4511						CALLMONITOR 
4511 cd 6f ee			call debug_vector  
4514				endm  
# End of macro CALLMONITOR
4514					endif 
4514			;		push hl 
4514					FORTH_DSP_POP 
4514 cd f5 1e			call macro_forth_dsp_pop 
4517				endm 
# End of macro FORTH_DSP_POP
4517			;		pop hl 
4517					 
4517					if DEBUG_FORTH_WORDS 
4517						DMARK "S2b" 
4517 f5				push af  
4518 3a 2c 45			ld a, (.dmark)  
451b 32 6b ee			ld (debug_mark),a  
451e 3a 2d 45			ld a, (.dmark+1)  
4521 32 6c ee			ld (debug_mark+1),a  
4524 3a 2e 45			ld a, (.dmark+2)  
4527 32 6d ee			ld (debug_mark+2),a  
452a 18 03			jr .pastdmark  
452c ..			.dmark: db "S2b"  
452f f1			.pastdmark: pop af  
4530			endm  
# End of macro DMARK
4530						CALLMONITOR 
4530 cd 6f ee			call debug_vector  
4533				endm  
# End of macro CALLMONITOR
4533					endif 
4533 cd 46 1c				call forth_push_numhl	 
4536			 
4536				 
4536				       NEXTW 
4536 c3 f3 1f			jp macro_next 
4539				endm 
# End of macro NEXTW
4539			.NUM2STR: 
4539				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4539 48				db WORD_SYS_CORE+52             
453a 48 45			dw .CONCAT            
453c 08				db 7 + 1 
453d .. 00			db "NUM2STR",0              
4545				endm 
# End of macro CWHEAD
4545			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4545			 
4545			;		; malloc a string to target 
4545			;		ld hl, 10     ; TODO max string size should be fine 
4545			;		call malloc 
4545			;		push hl    ; save malloc location 
4545			; 
4545			; 
4545			;; TODO check int type 
4545			;		FORTH_DSP_VALUEHL 
4545			;		ld a, l 
4545			;		call DispAToASCII   
4545			;;TODO need to chage above call to dump into string 
4545			; 
4545			; 
4545			 
4545				       NEXTW 
4545 c3 f3 1f			jp macro_next 
4548				endm 
# End of macro NEXTW
4548			 
4548			.CONCAT: 
4548				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4548 48				db WORD_SYS_CORE+52             
4549 fb 45			dw .FIND            
454b 07				db 6 + 1 
454c .. 00			db "CONCAT",0              
4553				endm 
# End of macro CWHEAD
4553			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4553			 
4553			; TODO check string type 
4553			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4553			 
4553					if DEBUG_FORTH_WORDS_KEY 
4553						DMARK "CON" 
4553 f5				push af  
4554 3a 68 45			ld a, (.dmark)  
4557 32 6b ee			ld (debug_mark),a  
455a 3a 69 45			ld a, (.dmark+1)  
455d 32 6c ee			ld (debug_mark+1),a  
4560 3a 6a 45			ld a, (.dmark+2)  
4563 32 6d ee			ld (debug_mark+2),a  
4566 18 03			jr .pastdmark  
4568 ..			.dmark: db "CON"  
456b f1			.pastdmark: pop af  
456c			endm  
# End of macro DMARK
456c						CALLMONITOR 
456c cd 6f ee			call debug_vector  
456f				endm  
# End of macro CALLMONITOR
456f					endif 
456f			 
456f			 
456f					FORTH_DSP_VALUE 
456f cd 26 1e			call macro_forth_dsp_value 
4572				endm 
# End of macro FORTH_DSP_VALUE
4572 e5					push hl   ; s2 
4573			 
4573					FORTH_DSP_POP 
4573 cd f5 1e			call macro_forth_dsp_pop 
4576				endm 
# End of macro FORTH_DSP_POP
4576			 
4576					FORTH_DSP_VALUE 
4576 cd 26 1e			call macro_forth_dsp_value 
4579				endm 
# End of macro FORTH_DSP_VALUE
4579			 
4579 e5					push hl   ; s1 
457a			 
457a					FORTH_DSP_POP 
457a cd f5 1e			call macro_forth_dsp_pop 
457d				endm 
# End of macro FORTH_DSP_POP
457d					 
457d			 
457d					; copy s1 
457d			 
457d				 
457d					; save ptr 
457d e1					pop hl  
457e e5					push hl 
457f 3e 00				ld a, 0 
4581 cd 4f 12				call strlent 
4584					;inc hl    ; zer0 
4584 06 00				ld b, 0 
4586 4d					ld c, l 
4587 e1					pop hl		 
4588 11 c1 e2				ld de, scratch	 
458b					if DEBUG_FORTH_WORDS 
458b						DMARK "CO1" 
458b f5				push af  
458c 3a a0 45			ld a, (.dmark)  
458f 32 6b ee			ld (debug_mark),a  
4592 3a a1 45			ld a, (.dmark+1)  
4595 32 6c ee			ld (debug_mark+1),a  
4598 3a a2 45			ld a, (.dmark+2)  
459b 32 6d ee			ld (debug_mark+2),a  
459e 18 03			jr .pastdmark  
45a0 ..			.dmark: db "CO1"  
45a3 f1			.pastdmark: pop af  
45a4			endm  
# End of macro DMARK
45a4						CALLMONITOR 
45a4 cd 6f ee			call debug_vector  
45a7				endm  
# End of macro CALLMONITOR
45a7					endif 
45a7 ed b0				ldir 
45a9			 
45a9 e1					pop hl 
45aa e5					push hl 
45ab d5					push de 
45ac			 
45ac			 
45ac 3e 00				ld a, 0 
45ae cd 4f 12				call strlent 
45b1 23					inc hl    ; zer0 
45b2 23					inc hl 
45b3 06 00				ld b, 0 
45b5 4d					ld c, l 
45b6 d1					pop de 
45b7 e1					pop hl		 
45b8					if DEBUG_FORTH_WORDS 
45b8						DMARK "CO2" 
45b8 f5				push af  
45b9 3a cd 45			ld a, (.dmark)  
45bc 32 6b ee			ld (debug_mark),a  
45bf 3a ce 45			ld a, (.dmark+1)  
45c2 32 6c ee			ld (debug_mark+1),a  
45c5 3a cf 45			ld a, (.dmark+2)  
45c8 32 6d ee			ld (debug_mark+2),a  
45cb 18 03			jr .pastdmark  
45cd ..			.dmark: db "CO2"  
45d0 f1			.pastdmark: pop af  
45d1			endm  
# End of macro DMARK
45d1						CALLMONITOR 
45d1 cd 6f ee			call debug_vector  
45d4				endm  
# End of macro CALLMONITOR
45d4					endif 
45d4 ed b0				ldir 
45d6			 
45d6			 
45d6			 
45d6 21 c1 e2				ld hl, scratch 
45d9					if DEBUG_FORTH_WORDS 
45d9						DMARK "CO5" 
45d9 f5				push af  
45da 3a ee 45			ld a, (.dmark)  
45dd 32 6b ee			ld (debug_mark),a  
45e0 3a ef 45			ld a, (.dmark+1)  
45e3 32 6c ee			ld (debug_mark+1),a  
45e6 3a f0 45			ld a, (.dmark+2)  
45e9 32 6d ee			ld (debug_mark+2),a  
45ec 18 03			jr .pastdmark  
45ee ..			.dmark: db "CO5"  
45f1 f1			.pastdmark: pop af  
45f2			endm  
# End of macro DMARK
45f2						CALLMONITOR 
45f2 cd 6f ee			call debug_vector  
45f5				endm  
# End of macro CALLMONITOR
45f5					endif 
45f5			 
45f5 cd b4 1c				call forth_push_str 
45f8			 
45f8			 
45f8			 
45f8			 
45f8				       NEXTW 
45f8 c3 f3 1f			jp macro_next 
45fb				endm 
# End of macro NEXTW
45fb			 
45fb			 
45fb			.FIND: 
45fb				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
45fb 4b				db WORD_SYS_CORE+55             
45fc b9 46			dw .LEN            
45fe 05				db 4 + 1 
45ff .. 00			db "FIND",0              
4604				endm 
# End of macro CWHEAD
4604			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4604			 
4604					if DEBUG_FORTH_WORDS_KEY 
4604						DMARK "FND" 
4604 f5				push af  
4605 3a 19 46			ld a, (.dmark)  
4608 32 6b ee			ld (debug_mark),a  
460b 3a 1a 46			ld a, (.dmark+1)  
460e 32 6c ee			ld (debug_mark+1),a  
4611 3a 1b 46			ld a, (.dmark+2)  
4614 32 6d ee			ld (debug_mark+2),a  
4617 18 03			jr .pastdmark  
4619 ..			.dmark: db "FND"  
461c f1			.pastdmark: pop af  
461d			endm  
# End of macro DMARK
461d						CALLMONITOR 
461d cd 6f ee			call debug_vector  
4620				endm  
# End of macro CALLMONITOR
4620					endif 
4620			 
4620			; TODO check string type 
4620					FORTH_DSP_VALUE 
4620 cd 26 1e			call macro_forth_dsp_value 
4623				endm 
# End of macro FORTH_DSP_VALUE
4623			 
4623 e5					push hl    
4624 7e					ld a,(hl)    ; char to find   
4625			; TODO change char to substr 
4625			 
4625 f5					push af 
4626					 
4626			 
4626			 
4626					if DEBUG_FORTH_WORDS 
4626						DMARK "FN1" 
4626 f5				push af  
4627 3a 3b 46			ld a, (.dmark)  
462a 32 6b ee			ld (debug_mark),a  
462d 3a 3c 46			ld a, (.dmark+1)  
4630 32 6c ee			ld (debug_mark+1),a  
4633 3a 3d 46			ld a, (.dmark+2)  
4636 32 6d ee			ld (debug_mark+2),a  
4639 18 03			jr .pastdmark  
463b ..			.dmark: db "FN1"  
463e f1			.pastdmark: pop af  
463f			endm  
# End of macro DMARK
463f						CALLMONITOR 
463f cd 6f ee			call debug_vector  
4642				endm  
# End of macro CALLMONITOR
4642					endif 
4642			 
4642					FORTH_DSP_POP 
4642 cd f5 1e			call macro_forth_dsp_pop 
4645				endm 
# End of macro FORTH_DSP_POP
4645			 
4645					; string to search 
4645			 
4645					FORTH_DSP_VALUE 
4645 cd 26 1e			call macro_forth_dsp_value 
4648				endm 
# End of macro FORTH_DSP_VALUE
4648			 
4648 d1					pop de  ; d is char to find  
4649			 
4649					if DEBUG_FORTH_WORDS 
4649						DMARK "FN2" 
4649 f5				push af  
464a 3a 5e 46			ld a, (.dmark)  
464d 32 6b ee			ld (debug_mark),a  
4650 3a 5f 46			ld a, (.dmark+1)  
4653 32 6c ee			ld (debug_mark+1),a  
4656 3a 60 46			ld a, (.dmark+2)  
4659 32 6d ee			ld (debug_mark+2),a  
465c 18 03			jr .pastdmark  
465e ..			.dmark: db "FN2"  
4661 f1			.pastdmark: pop af  
4662			endm  
# End of macro DMARK
4662						CALLMONITOR 
4662 cd 6f ee			call debug_vector  
4665				endm  
# End of macro CALLMONITOR
4665					endif 
4665					 
4665 01 00 00				ld bc, 0 
4668 7e			.findchar:      ld a,(hl) 
4669 fe 00				cp 0   		 
466b 28 27				jr z, .finddone     
466d ba					cp d 
466e 28 20				jr z, .foundchar 
4670 03					inc bc 
4671 23					inc hl 
4672					if DEBUG_FORTH_WORDS 
4672						DMARK "FN3" 
4672 f5				push af  
4673 3a 87 46			ld a, (.dmark)  
4676 32 6b ee			ld (debug_mark),a  
4679 3a 88 46			ld a, (.dmark+1)  
467c 32 6c ee			ld (debug_mark+1),a  
467f 3a 89 46			ld a, (.dmark+2)  
4682 32 6d ee			ld (debug_mark+2),a  
4685 18 03			jr .pastdmark  
4687 ..			.dmark: db "FN3"  
468a f1			.pastdmark: pop af  
468b			endm  
# End of macro DMARK
468b						CALLMONITOR 
468b cd 6f ee			call debug_vector  
468e				endm  
# End of macro CALLMONITOR
468e					endif 
468e 18 d8				jr .findchar 
4690			 
4690			 
4690 c5			.foundchar:	push bc 
4691 e1					pop hl 
4692 18 03				jr .findexit 
4694			 
4694			 
4694							 
4694			 
4694			.finddone:     ; got to end of string with no find 
4694 21 00 00				ld hl, 0 
4697			.findexit: 
4697			 
4697					if DEBUG_FORTH_WORDS 
4697						DMARK "FNd" 
4697 f5				push af  
4698 3a ac 46			ld a, (.dmark)  
469b 32 6b ee			ld (debug_mark),a  
469e 3a ad 46			ld a, (.dmark+1)  
46a1 32 6c ee			ld (debug_mark+1),a  
46a4 3a ae 46			ld a, (.dmark+2)  
46a7 32 6d ee			ld (debug_mark+2),a  
46aa 18 03			jr .pastdmark  
46ac ..			.dmark: db "FNd"  
46af f1			.pastdmark: pop af  
46b0			endm  
# End of macro DMARK
46b0						CALLMONITOR 
46b0 cd 6f ee			call debug_vector  
46b3				endm  
# End of macro CALLMONITOR
46b3					endif 
46b3 cd 46 1c			call forth_push_numhl 
46b6			 
46b6				       NEXTW 
46b6 c3 f3 1f			jp macro_next 
46b9				endm 
# End of macro NEXTW
46b9			 
46b9			.LEN: 
46b9				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
46b9 4c				db WORD_SYS_CORE+56             
46ba 23 47			dw .ASC            
46bc 06				db 5 + 1 
46bd .. 00			db "COUNT",0              
46c3				endm 
# End of macro CWHEAD
46c3			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
46c3			 
46c3					if DEBUG_FORTH_WORDS_KEY 
46c3						DMARK "CNT" 
46c3 f5				push af  
46c4 3a d8 46			ld a, (.dmark)  
46c7 32 6b ee			ld (debug_mark),a  
46ca 3a d9 46			ld a, (.dmark+1)  
46cd 32 6c ee			ld (debug_mark+1),a  
46d0 3a da 46			ld a, (.dmark+2)  
46d3 32 6d ee			ld (debug_mark+2),a  
46d6 18 03			jr .pastdmark  
46d8 ..			.dmark: db "CNT"  
46db f1			.pastdmark: pop af  
46dc			endm  
# End of macro DMARK
46dc						CALLMONITOR 
46dc cd 6f ee			call debug_vector  
46df				endm  
# End of macro CALLMONITOR
46df					endif 
46df			; TODO check string type 
46df					FORTH_DSP_VALUE 
46df cd 26 1e			call macro_forth_dsp_value 
46e2				endm 
# End of macro FORTH_DSP_VALUE
46e2			 
46e2			 
46e2					if DEBUG_FORTH_WORDS 
46e2						DMARK "CN?" 
46e2 f5				push af  
46e3 3a f7 46			ld a, (.dmark)  
46e6 32 6b ee			ld (debug_mark),a  
46e9 3a f8 46			ld a, (.dmark+1)  
46ec 32 6c ee			ld (debug_mark+1),a  
46ef 3a f9 46			ld a, (.dmark+2)  
46f2 32 6d ee			ld (debug_mark+2),a  
46f5 18 03			jr .pastdmark  
46f7 ..			.dmark: db "CN?"  
46fa f1			.pastdmark: pop af  
46fb			endm  
# End of macro DMARK
46fb						CALLMONITOR 
46fb cd 6f ee			call debug_vector  
46fe				endm  
# End of macro CALLMONITOR
46fe					endif 
46fe cd 44 12				call strlenz 
4701					if DEBUG_FORTH_WORDS 
4701						DMARK "CNl" 
4701 f5				push af  
4702 3a 16 47			ld a, (.dmark)  
4705 32 6b ee			ld (debug_mark),a  
4708 3a 17 47			ld a, (.dmark+1)  
470b 32 6c ee			ld (debug_mark+1),a  
470e 3a 18 47			ld a, (.dmark+2)  
4711 32 6d ee			ld (debug_mark+2),a  
4714 18 03			jr .pastdmark  
4716 ..			.dmark: db "CNl"  
4719 f1			.pastdmark: pop af  
471a			endm  
# End of macro DMARK
471a						CALLMONITOR 
471a cd 6f ee			call debug_vector  
471d				endm  
# End of macro CALLMONITOR
471d					endif 
471d			 
471d cd 46 1c				call forth_push_numhl 
4720			 
4720			 
4720			 
4720				       NEXTW 
4720 c3 f3 1f			jp macro_next 
4723				endm 
# End of macro NEXTW
4723			.ASC: 
4723				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4723 4d				db WORD_SYS_CORE+57             
4724 91 47			dw .CHR            
4726 04				db 3 + 1 
4727 .. 00			db "ASC",0              
472b				endm 
# End of macro CWHEAD
472b			; | ASC ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
472b					if DEBUG_FORTH_WORDS_KEY 
472b						DMARK "ASC" 
472b f5				push af  
472c 3a 40 47			ld a, (.dmark)  
472f 32 6b ee			ld (debug_mark),a  
4732 3a 41 47			ld a, (.dmark+1)  
4735 32 6c ee			ld (debug_mark+1),a  
4738 3a 42 47			ld a, (.dmark+2)  
473b 32 6d ee			ld (debug_mark+2),a  
473e 18 03			jr .pastdmark  
4740 ..			.dmark: db "ASC"  
4743 f1			.pastdmark: pop af  
4744			endm  
# End of macro DMARK
4744						CALLMONITOR 
4744 cd 6f ee			call debug_vector  
4747				endm  
# End of macro CALLMONITOR
4747					endif 
4747					FORTH_DSP_VALUE 
4747 cd 26 1e			call macro_forth_dsp_value 
474a				endm 
# End of macro FORTH_DSP_VALUE
474a					;v5 FORTH_DSP_VALUE 
474a			;		inc hl      ; now at start of numeric as string 
474a			 
474a e5					push hl 
474b			 
474b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
474b cd f5 1e			call macro_forth_dsp_pop 
474e				endm 
# End of macro FORTH_DSP_POP
474e			 
474e e1					pop hl 
474f			 
474f					if DEBUG_FORTH_WORDS 
474f						DMARK "AS1" 
474f f5				push af  
4750 3a 64 47			ld a, (.dmark)  
4753 32 6b ee			ld (debug_mark),a  
4756 3a 65 47			ld a, (.dmark+1)  
4759 32 6c ee			ld (debug_mark+1),a  
475c 3a 66 47			ld a, (.dmark+2)  
475f 32 6d ee			ld (debug_mark+2),a  
4762 18 03			jr .pastdmark  
4764 ..			.dmark: db "AS1"  
4767 f1			.pastdmark: pop af  
4768			endm  
# End of macro DMARK
4768						CALLMONITOR 
4768 cd 6f ee			call debug_vector  
476b				endm  
# End of macro CALLMONITOR
476b					endif 
476b					; push the content of a onto the stack as a value 
476b			 
476b 7e					ld a,(hl)   ; get char 
476c 26 00				ld h,0 
476e 6f					ld l,a 
476f					if DEBUG_FORTH_WORDS 
476f						DMARK "AS2" 
476f f5				push af  
4770 3a 84 47			ld a, (.dmark)  
4773 32 6b ee			ld (debug_mark),a  
4776 3a 85 47			ld a, (.dmark+1)  
4779 32 6c ee			ld (debug_mark+1),a  
477c 3a 86 47			ld a, (.dmark+2)  
477f 32 6d ee			ld (debug_mark+2),a  
4782 18 03			jr .pastdmark  
4784 ..			.dmark: db "AS2"  
4787 f1			.pastdmark: pop af  
4788			endm  
# End of macro DMARK
4788						CALLMONITOR 
4788 cd 6f ee			call debug_vector  
478b				endm  
# End of macro CALLMONITOR
478b					endif 
478b cd 46 1c				call forth_push_numhl 
478e			 
478e				       NEXTW 
478e c3 f3 1f			jp macro_next 
4791				endm 
# End of macro NEXTW
4791			 
4791			.CHR: 
4791				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4791 4d				db WORD_SYS_CORE+57             
4792 cd 47			dw .ENDSTR            
4794 04				db 3 + 1 
4795 .. 00			db "CHR",0              
4799				endm 
# End of macro CWHEAD
4799			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4799					if DEBUG_FORTH_WORDS_KEY 
4799						DMARK "CHR" 
4799 f5				push af  
479a 3a ae 47			ld a, (.dmark)  
479d 32 6b ee			ld (debug_mark),a  
47a0 3a af 47			ld a, (.dmark+1)  
47a3 32 6c ee			ld (debug_mark+1),a  
47a6 3a b0 47			ld a, (.dmark+2)  
47a9 32 6d ee			ld (debug_mark+2),a  
47ac 18 03			jr .pastdmark  
47ae ..			.dmark: db "CHR"  
47b1 f1			.pastdmark: pop af  
47b2			endm  
# End of macro DMARK
47b2						CALLMONITOR 
47b2 cd 6f ee			call debug_vector  
47b5				endm  
# End of macro CALLMONITOR
47b5					endif 
47b5					FORTH_DSP_VALUEHL 
47b5 cd 3d 1e			call macro_dsp_valuehl 
47b8				endm 
# End of macro FORTH_DSP_VALUEHL
47b8			 
47b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
47b8 cd f5 1e			call macro_forth_dsp_pop 
47bb				endm 
# End of macro FORTH_DSP_POP
47bb			 
47bb					; save asci byte as a zero term string and push string 
47bb			 
47bb 7d					ld a,l 
47bc 32 c1 e2				ld (scratch), a 
47bf			 
47bf 3e 00				ld a, 0 
47c1 32 c2 e2				ld (scratch+1), a 
47c4			 
47c4 21 c1 e2				ld hl, scratch 
47c7 cd b4 1c				call forth_push_str 
47ca			 
47ca			 
47ca				       NEXTW 
47ca c3 f3 1f			jp macro_next 
47cd				endm 
# End of macro NEXTW
47cd			 
47cd			 
47cd			 
47cd			 
47cd			.ENDSTR: 
47cd			; eof 
47cd			 
# End of file forth_words_str.asm
47cd			include "forth_words_key.asm" 
47cd			 
47cd			; | ## Keyboard Words 
47cd			 
47cd			.KEY: 
47cd				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
47cd 3e				db WORD_SYS_CORE+42             
47ce fd 47			dw .WAITK            
47d0 04				db 3 + 1 
47d1 .. 00			db "KEY",0              
47d5				endm 
# End of macro CWHEAD
47d5			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
47d5			 
47d5					if DEBUG_FORTH_WORDS_KEY 
47d5						DMARK "KEY" 
47d5 f5				push af  
47d6 3a ea 47			ld a, (.dmark)  
47d9 32 6b ee			ld (debug_mark),a  
47dc 3a eb 47			ld a, (.dmark+1)  
47df 32 6c ee			ld (debug_mark+1),a  
47e2 3a ec 47			ld a, (.dmark+2)  
47e5 32 6d ee			ld (debug_mark+2),a  
47e8 18 03			jr .pastdmark  
47ea ..			.dmark: db "KEY"  
47ed f1			.pastdmark: pop af  
47ee			endm  
# End of macro DMARK
47ee						CALLMONITOR 
47ee cd 6f ee			call debug_vector  
47f1				endm  
# End of macro CALLMONITOR
47f1					endif 
47f1			; TODO currently waits 
47f1 cd bb 65				call cin 
47f4					;call cin_wait 
47f4 6f					ld l, a 
47f5 26 00				ld h, 0 
47f7 cd 46 1c				call forth_push_numhl 
47fa					NEXTW 
47fa c3 f3 1f			jp macro_next 
47fd				endm 
# End of macro NEXTW
47fd			.WAITK: 
47fd				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
47fd 3f				db WORD_SYS_CORE+43             
47fe 2f 48			dw .ACCEPT            
4800 06				db 5 + 1 
4801 .. 00			db "WAITK",0              
4807				endm 
# End of macro CWHEAD
4807			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4807					if DEBUG_FORTH_WORDS_KEY 
4807						DMARK "WAI" 
4807 f5				push af  
4808 3a 1c 48			ld a, (.dmark)  
480b 32 6b ee			ld (debug_mark),a  
480e 3a 1d 48			ld a, (.dmark+1)  
4811 32 6c ee			ld (debug_mark+1),a  
4814 3a 1e 48			ld a, (.dmark+2)  
4817 32 6d ee			ld (debug_mark+2),a  
481a 18 03			jr .pastdmark  
481c ..			.dmark: db "WAI"  
481f f1			.pastdmark: pop af  
4820			endm  
# End of macro DMARK
4820						CALLMONITOR 
4820 cd 6f ee			call debug_vector  
4823				endm  
# End of macro CALLMONITOR
4823					endif 
4823 cd b3 65				call cin_wait 
4826 6f					ld l, a 
4827 26 00				ld h, 0 
4829 cd 46 1c				call forth_push_numhl 
482c					NEXTW 
482c c3 f3 1f			jp macro_next 
482f				endm 
# End of macro NEXTW
482f			.ACCEPT: 
482f				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
482f 40				db WORD_SYS_CORE+44             
4830 8d 48			dw .EDIT            
4832 07				db 6 + 1 
4833 .. 00			db "ACCEPT",0              
483a				endm 
# End of macro CWHEAD
483a			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
483a					; TODO crashes on push 
483a					if DEBUG_FORTH_WORDS_KEY 
483a						DMARK "ACC" 
483a f5				push af  
483b 3a 4f 48			ld a, (.dmark)  
483e 32 6b ee			ld (debug_mark),a  
4841 3a 50 48			ld a, (.dmark+1)  
4844 32 6c ee			ld (debug_mark+1),a  
4847 3a 51 48			ld a, (.dmark+2)  
484a 32 6d ee			ld (debug_mark+2),a  
484d 18 03			jr .pastdmark  
484f ..			.dmark: db "ACC"  
4852 f1			.pastdmark: pop af  
4853			endm  
# End of macro DMARK
4853						CALLMONITOR 
4853 cd 6f ee			call debug_vector  
4856				endm  
# End of macro CALLMONITOR
4856					endif 
4856 21 bf e4				ld hl, os_input 
4859 3e 00				ld a, 0 
485b 77					ld (hl),a 
485c 3a 5e ea				ld a,(f_cursor_ptr) 
485f 16 64				ld d, 100 
4861 0e 00				ld c, 0 
4863 1e 28				ld e, 40 
4865 cd 13 0e				call input_str 
4868					; TODO perhaps do a type check and wrap in quotes if not a number 
4868 21 bf e4				ld hl, os_input 
486b					if DEBUG_FORTH_WORDS 
486b						DMARK "AC1" 
486b f5				push af  
486c 3a 80 48			ld a, (.dmark)  
486f 32 6b ee			ld (debug_mark),a  
4872 3a 81 48			ld a, (.dmark+1)  
4875 32 6c ee			ld (debug_mark+1),a  
4878 3a 82 48			ld a, (.dmark+2)  
487b 32 6d ee			ld (debug_mark+2),a  
487e 18 03			jr .pastdmark  
4880 ..			.dmark: db "AC1"  
4883 f1			.pastdmark: pop af  
4884			endm  
# End of macro DMARK
4884						CALLMONITOR 
4884 cd 6f ee			call debug_vector  
4887				endm  
# End of macro CALLMONITOR
4887					endif 
4887 cd b4 1c				call forth_push_str 
488a					NEXTW 
488a c3 f3 1f			jp macro_next 
488d				endm 
# End of macro NEXTW
488d			 
488d			.EDIT: 
488d				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
488d 40				db WORD_SYS_CORE+44             
488e 2f 49			dw .DEDIT            
4890 05				db 4 + 1 
4891 .. 00			db "EDIT",0              
4896				endm 
# End of macro CWHEAD
4896			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4896			 
4896					; TODO does not copy from stack 
4896					if DEBUG_FORTH_WORDS_KEY 
4896						DMARK "EDT" 
4896 f5				push af  
4897 3a ab 48			ld a, (.dmark)  
489a 32 6b ee			ld (debug_mark),a  
489d 3a ac 48			ld a, (.dmark+1)  
48a0 32 6c ee			ld (debug_mark+1),a  
48a3 3a ad 48			ld a, (.dmark+2)  
48a6 32 6d ee			ld (debug_mark+2),a  
48a9 18 03			jr .pastdmark  
48ab ..			.dmark: db "EDT"  
48ae f1			.pastdmark: pop af  
48af			endm  
# End of macro DMARK
48af						CALLMONITOR 
48af cd 6f ee			call debug_vector  
48b2				endm  
# End of macro CALLMONITOR
48b2					endif 
48b2			 
48b2					;FORTH_DSP 
48b2					FORTH_DSP_VALUEHL 
48b2 cd 3d 1e			call macro_dsp_valuehl 
48b5				endm 
# End of macro FORTH_DSP_VALUEHL
48b5			;		inc hl    ; TODO do type check 
48b5			 
48b5			;		call get_word_hl 
48b5 e5					push hl 
48b6					if DEBUG_FORTH_WORDS 
48b6						DMARK "EDp" 
48b6 f5				push af  
48b7 3a cb 48			ld a, (.dmark)  
48ba 32 6b ee			ld (debug_mark),a  
48bd 3a cc 48			ld a, (.dmark+1)  
48c0 32 6c ee			ld (debug_mark+1),a  
48c3 3a cd 48			ld a, (.dmark+2)  
48c6 32 6d ee			ld (debug_mark+2),a  
48c9 18 03			jr .pastdmark  
48cb ..			.dmark: db "EDp"  
48ce f1			.pastdmark: pop af  
48cf			endm  
# End of macro DMARK
48cf						CALLMONITOR 
48cf cd 6f ee			call debug_vector  
48d2				endm  
# End of macro CALLMONITOR
48d2					endif 
48d2				;	ld a, 0 
48d2 cd 44 12				call strlenz 
48d5 23					inc hl 
48d6			 
48d6 06 00				ld b, 0 
48d8 4d					ld c, l 
48d9			 
48d9 e1					pop hl 
48da 11 bf e4				ld de, os_input 
48dd					if DEBUG_FORTH_WORDS_KEY 
48dd						DMARK "EDc" 
48dd f5				push af  
48de 3a f2 48			ld a, (.dmark)  
48e1 32 6b ee			ld (debug_mark),a  
48e4 3a f3 48			ld a, (.dmark+1)  
48e7 32 6c ee			ld (debug_mark+1),a  
48ea 3a f4 48			ld a, (.dmark+2)  
48ed 32 6d ee			ld (debug_mark+2),a  
48f0 18 03			jr .pastdmark  
48f2 ..			.dmark: db "EDc"  
48f5 f1			.pastdmark: pop af  
48f6			endm  
# End of macro DMARK
48f6						CALLMONITOR 
48f6 cd 6f ee			call debug_vector  
48f9				endm  
# End of macro CALLMONITOR
48f9					endif 
48f9 ed b0				ldir 
48fb			 
48fb			 
48fb 21 bf e4				ld hl, os_input 
48fe					;ld a, 0 
48fe					;ld (hl),a 
48fe 3a 5e ea				ld a,(f_cursor_ptr) 
4901 16 64				ld d, 100 
4903 0e 00				ld c, 0 
4905 1e 28				ld e, 40 
4907 cd 13 0e				call input_str 
490a					; TODO perhaps do a type check and wrap in quotes if not a number 
490a 21 bf e4				ld hl, os_input 
490d					if DEBUG_FORTH_WORDS 
490d						DMARK "ED1" 
490d f5				push af  
490e 3a 22 49			ld a, (.dmark)  
4911 32 6b ee			ld (debug_mark),a  
4914 3a 23 49			ld a, (.dmark+1)  
4917 32 6c ee			ld (debug_mark+1),a  
491a 3a 24 49			ld a, (.dmark+2)  
491d 32 6d ee			ld (debug_mark+2),a  
4920 18 03			jr .pastdmark  
4922 ..			.dmark: db "ED1"  
4925 f1			.pastdmark: pop af  
4926			endm  
# End of macro DMARK
4926						CALLMONITOR 
4926 cd 6f ee			call debug_vector  
4929				endm  
# End of macro CALLMONITOR
4929					endif 
4929 cd b4 1c				call forth_push_str 
492c					NEXTW 
492c c3 f3 1f			jp macro_next 
492f				endm 
# End of macro NEXTW
492f			 
492f			.DEDIT: 
492f				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
492f 40				db WORD_SYS_CORE+44             
4930 91 49			dw .ENDKEY            
4932 06				db 5 + 1 
4933 .. 00			db "DEDIT",0              
4939				endm 
# End of macro CWHEAD
4939			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4939			 
4939					; TODO does not copy from stack 
4939					if DEBUG_FORTH_WORDS_KEY 
4939						DMARK "DED" 
4939 f5				push af  
493a 3a 4e 49			ld a, (.dmark)  
493d 32 6b ee			ld (debug_mark),a  
4940 3a 4f 49			ld a, (.dmark+1)  
4943 32 6c ee			ld (debug_mark+1),a  
4946 3a 50 49			ld a, (.dmark+2)  
4949 32 6d ee			ld (debug_mark+2),a  
494c 18 03			jr .pastdmark  
494e ..			.dmark: db "DED"  
4951 f1			.pastdmark: pop af  
4952			endm  
# End of macro DMARK
4952						CALLMONITOR 
4952 cd 6f ee			call debug_vector  
4955				endm  
# End of macro CALLMONITOR
4955					endif 
4955			 
4955					;FORTH_DSP 
4955					FORTH_DSP_VALUEHL 
4955 cd 3d 1e			call macro_dsp_valuehl 
4958				endm 
# End of macro FORTH_DSP_VALUEHL
4958			;		inc hl    ; TODO do type check 
4958			 
4958			;		call get_word_hl 
4958 e5					push hl 
4959 e5					push hl 
495a					FORTH_DSP_POP 
495a cd f5 1e			call macro_forth_dsp_pop 
495d				endm 
# End of macro FORTH_DSP_POP
495d e1					pop hl 
495e					if DEBUG_FORTH_WORDS 
495e						DMARK "EDp" 
495e f5				push af  
495f 3a 73 49			ld a, (.dmark)  
4962 32 6b ee			ld (debug_mark),a  
4965 3a 74 49			ld a, (.dmark+1)  
4968 32 6c ee			ld (debug_mark+1),a  
496b 3a 75 49			ld a, (.dmark+2)  
496e 32 6d ee			ld (debug_mark+2),a  
4971 18 03			jr .pastdmark  
4973 ..			.dmark: db "EDp"  
4976 f1			.pastdmark: pop af  
4977			endm  
# End of macro DMARK
4977						CALLMONITOR 
4977 cd 6f ee			call debug_vector  
497a				endm  
# End of macro CALLMONITOR
497a					endif 
497a				;	ld a, 0 
497a cd 44 12				call strlenz 
497d 23					inc hl 
497e			 
497e 06 00				ld b, 0 
4980 4d					ld c, l 
4981			 
4981 e1					pop hl 
4982			 
4982					;ld a, 0 
4982					;ld (hl),a 
4982 3a 5e ea				ld a,(f_cursor_ptr) 
4985 16 64				ld d, 100 
4987 0e 00				ld c, 0 
4989 1e 28				ld e, 40 
498b cd 13 0e				call input_str 
498e					; TODO perhaps do a type check and wrap in quotes if not a number 
498e					NEXTW 
498e c3 f3 1f			jp macro_next 
4991				endm 
# End of macro NEXTW
4991			 
4991			 
4991			.ENDKEY: 
4991			; eof 
4991			 
# End of file forth_words_key.asm
4991			include "forth_words_const.asm" 
4991			 
4991			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4991			 
4991			 
4991			.SPITIME: 
4991				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4991 77				db WORD_SYS_CORE+99             
4992 a6 49			dw .VA            
4994 08				db 7 + 1 
4995 .. 00			db "SPITIME",0              
499d				endm 
# End of macro CWHEAD
499d			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack 
499d			; 
499d			; | If using BANK devices then leave as is. 
499d			; | Only really useful for the CARTDEV where other devices may be too far or slow. In particular 
499d			; | the multiplexing of the PicoSPINet device which might not be running fast enough for all of the nodes 
499d			 
499d 21 64 ea				ld hl, spi_clktime  
49a0 cd 46 1c				call forth_push_numhl 
49a3			 
49a3					NEXTW 
49a3 c3 f3 1f			jp macro_next 
49a6				endm 
# End of macro NEXTW
49a6			 
49a6			 
49a6			.VA: 
49a6				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
49a6 77				db WORD_SYS_CORE+99             
49a7 b6 49			dw .SYMBOL            
49a9 03				db 2 + 1 
49aa .. 00			db "VA",0              
49ad				endm 
# End of macro CWHEAD
49ad			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 
49ad 21 28 ea				ld hl, cli_var_array 
49b0 cd 46 1c				call forth_push_numhl 
49b3			 
49b3					NEXTW 
49b3 c3 f3 1f			jp macro_next 
49b6				endm 
# End of macro NEXTW
49b6			 
49b6			.SYMBOL: 
49b6				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
49b6 77				db WORD_SYS_CORE+99             
49b7 c0 4a			dw .ENDCONST            
49b9 07				db 6 + 1 
49ba .. 00			db "SYMBOL",0              
49c1				endm 
# End of macro CWHEAD
49c1			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
49c1			; | 
49c1			; | The value is the number reference and the final address is pushed to stack 
49c1			 
49c1			; | dw sym_table 
49c1			; | dw nmi_vector 
49c1			; | dw cli_autodisplay 
49c1			; | dw cli_data_sp 
49c1			; | dw cli_data_stack 
49c1			; | dw cli_loop_sp 
49c1			; | dw cli_loop_stack 
49c1			; | dw cli_var_array 
49c1			; | dw cursor_col 
49c1			; | dw cursor_ptr 
49c1			; | ; 10 
49c1			; | dw cursor_row 
49c1			; | dw debug_mark 
49c1			; | dw display_fb0 
49c1			; | dw display_fb1 
49c1			; | dw display_fb2 
49c1			; | dw display_fb3 
49c1			; | dw display_fb_active 
49c1			; | dw execscratch 
49c1			; | dw f_cursor_ptr 
49c1			; | dw hardware_word 
49c1			; | ;20 
49c1			; | dw input_at_cursor 
49c1			; | dw input_at_pos 
49c1			; | dw input_cur_flash 
49c1			; | dw input_cur_onoff 
49c1			; | dw input_cursor 
49c1			; | dw input_display_size 
49c1			; | dw input_len 
49c1			; | dw input_ptr 
49c1			; | dw input_size 
49c1			; | dw input_start 
49c1			; | ; 30 
49c1			; | dw input_str 
49c1			; | dw input_under_cursor 
49c1			; | dw os_cli_cmd 
49c1			; | dw os_cur_ptr 
49c1			; | dw os_current_i 
49c1			; | dw os_input 
49c1			; | dw os_last_cmd 
49c1			; | dw os_last_new_uword 
49c1			; | dw debug_vector 
49c1			; | dw os_view_hl 
49c1			; | ;40 
49c1			; | dw os_word_scratch 
49c1			; | dw portbctl 
49c1			; | dw portbdata 
49c1			; | dw spi_cartdev 
49c1			; | dw spi_cartdev2 
49c1			; | dw spi_clktime 
49c1			; | dw spi_device 
49c1			; | dw spi_device_id 
49c1			; | dw spi_portbyte 
49c1			; | dw stackstore 
49c1			; | ; 50 
49c1			; | if STORAGE_SE 
49c1			; | dw storage_actl 
49c1			; | dw storage_adata 
49c1			; | else 
49c1			; | dw 0 
49c1			; | dw 0 
49c1			; | endif 
49c1			; | dw storage_append 
49c1			; | if STORAGE_SE 
49c1			; | dw storage_bctl 
49c1			; | else 
49c1			; | dw 0 
49c1			; | endif 
49c1			; | dw store_bank_active 
49c1			; | dw store_filecache 
49c1			; | dw store_longread 
49c1			; | dw store_openaddr 
49c1			; | dw store_openext 
49c1			; | dw store_openmaxext 
49c1			; | ; 60 
49c1			; | dw store_page 
49c1			; | dw store_readbuf 
49c1			; | dw store_readcont 
49c1			; | dw store_readptr 
49c1			; | dw store_tmpext 
49c1			; | dw store_tmpid 
49c1			; | dw store_tmppageid 
49c1			; | dw malloc 
49c1			; | dw free 
49c1			; | dw cin 
49c1			; | ; 70 
49c1			; | dw cin_wait 
49c1			; | dw forth_push_numhl 
49c1			; | dw forth_push_str 
49c1			 
49c1					if DEBUG_FORTH_WORDS_KEY 
49c1						DMARK "SYM" 
49c1 f5				push af  
49c2 3a d6 49			ld a, (.dmark)  
49c5 32 6b ee			ld (debug_mark),a  
49c8 3a d7 49			ld a, (.dmark+1)  
49cb 32 6c ee			ld (debug_mark+1),a  
49ce 3a d8 49			ld a, (.dmark+2)  
49d1 32 6d ee			ld (debug_mark+2),a  
49d4 18 03			jr .pastdmark  
49d6 ..			.dmark: db "SYM"  
49d9 f1			.pastdmark: pop af  
49da			endm  
# End of macro DMARK
49da						CALLMONITOR 
49da cd 6f ee			call debug_vector  
49dd				endm  
# End of macro CALLMONITOR
49dd					endif 
49dd			 
49dd					FORTH_DSP_VALUEHL 
49dd cd 3d 1e			call macro_dsp_valuehl 
49e0				endm 
# End of macro FORTH_DSP_VALUEHL
49e0			 
49e0 7d					ld a, l     
49e1			 
49e1			 
49e1					if DEBUG_FORTH_WORDS 
49e1						DMARK "SY1" 
49e1 f5				push af  
49e2 3a f6 49			ld a, (.dmark)  
49e5 32 6b ee			ld (debug_mark),a  
49e8 3a f7 49			ld a, (.dmark+1)  
49eb 32 6c ee			ld (debug_mark+1),a  
49ee 3a f8 49			ld a, (.dmark+2)  
49f1 32 6d ee			ld (debug_mark+2),a  
49f4 18 03			jr .pastdmark  
49f6 ..			.dmark: db "SY1"  
49f9 f1			.pastdmark: pop af  
49fa			endm  
# End of macro DMARK
49fa						CALLMONITOR 
49fa cd 6f ee			call debug_vector  
49fd				endm  
# End of macro CALLMONITOR
49fd					endif 
49fd					 
49fd f5					push af	 
49fe					FORTH_DSP_POP 
49fe cd f5 1e			call macro_forth_dsp_pop 
4a01				endm 
# End of macro FORTH_DSP_POP
4a01 f1					pop af 
4a02			 
4a02 cb 27				sla a  
4a04				 
4a04					 
4a04					if DEBUG_FORTH_WORDS 
4a04						DMARK "SY" 
4a04 f5				push af  
4a05 3a 19 4a			ld a, (.dmark)  
4a08 32 6b ee			ld (debug_mark),a  
4a0b 3a 1a 4a			ld a, (.dmark+1)  
4a0e 32 6c ee			ld (debug_mark+1),a  
4a11 3a 1b 4a			ld a, (.dmark+2)  
4a14 32 6d ee			ld (debug_mark+2),a  
4a17 18 02			jr .pastdmark  
4a19 ..			.dmark: db "SY"  
4a1b f1			.pastdmark: pop af  
4a1c			endm  
# End of macro DMARK
4a1c						CALLMONITOR 
4a1c cd 6f ee			call debug_vector  
4a1f				endm  
# End of macro CALLMONITOR
4a1f					endif 
4a1f			 
4a1f 21 2e 4a				ld hl, sym_table 
4a22 cd e6 0d				call addatohl 
4a25 cd 75 1f				call loadwordinhl 
4a28 cd 46 1c				call forth_push_numhl 
4a2b			 
4a2b			 
4a2b				       NEXTW 
4a2b c3 f3 1f			jp macro_next 
4a2e				endm 
# End of macro NEXTW
4a2e			 
4a2e			sym_table: 
4a2e			 
4a2e			; 0 
4a2e 2e 4a		dw sym_table 
4a30 72 ee		dw nmi_vector 
4a32 3c ea		dw cli_autodisplay 
4a34 ee e9		dw cli_data_sp 
4a36 28 e8		dw cli_data_stack 
4a38 f0 e9		dw cli_loop_sp 
4a3a 2a e9		dw cli_loop_stack 
4a3c 28 ea		dw cli_var_array 
4a3e c5 eb		dw cursor_col 
4a40 c3 eb		dw cursor_ptr 
4a42			; 10 
4a42 c4 eb		dw cursor_row 
4a44 6b ee		dw debug_mark 
4a46 b1 ed		dw display_fb0 
4a48 10 ed		dw display_fb1 
4a4a ce eb		dw display_fb2 
4a4c 6f ec		dw display_fb3 
4a4e cc eb		dw display_fb_active 
4a50 c0 e3		dw execscratch 
4a52 5e ea		dw f_cursor_ptr 
4a54 75 ee		dw hardware_word 
4a56			;20 
4a56 62 ee		dw input_at_cursor 
4a58 64 ee		dw input_at_pos 
4a5a 60 ee		dw input_cur_flash 
4a5c 5f ee		dw input_cur_onoff 
4a5e 55 ee		dw input_cursor 
4a60 65 ee		dw input_display_size 
4a62 5a ee		dw input_len 
4a64 69 ee		dw input_ptr 
4a66 66 ee		dw input_size 
4a68 67 ee		dw input_start 
4a6a			; 30 
4a6a 13 0e		dw input_str 
4a6c 63 ee		dw input_under_cursor 
4a6e e8 e5		dw os_cli_cmd 
4a70 e4 e5		dw os_cur_ptr 
4a72 e6 e5		dw os_current_i 
4a74 bf e4		dw os_input 
4a76 e7 e6		dw os_last_cmd 
4a78 be e5		dw os_last_new_uword 
4a7a 6f ee		dw debug_vector 
4a7c a3 e2		dw os_view_hl 
4a7e			;40 
4a7e c6 e5		dw os_word_scratch 
4a80 c3 00		dw portbctl 
4a82 c1 00		dw portbdata 
4a84 63 ea		dw spi_cartdev 
4a86 62 ea		dw spi_cartdev2 
4a88 64 ea		dw spi_clktime 
4a8a 60 ea		dw spi_device 
4a8c 5f ea		dw spi_device_id 
4a8e 61 ea		dw spi_portbyte 
4a90 a7 eb		dw stackstore 
4a92			; 50 
4a92			if STORAGE_SE 
4a92			dw storage_actl 
4a92			dw storage_adata 
4a92			else 
4a92 00 00		dw 0 
4a94 00 00		dw 0 
4a96			endif 
4a96 68 09		dw storage_append 
4a98			if STORAGE_SE 
4a98			dw storage_bctl 
4a98			else 
4a98 00 00		dw 0 
4a9a			endif 
4a9a 93 eb		dw store_bank_active 
4a9c 67 ea		dw store_filecache 
4a9e 75 ea		dw store_longread 
4aa0 6b ea		dw store_openaddr 
4aa2 6a ea		dw store_openext 
4aa4 69 ea		dw store_openmaxext 
4aa6			; 60 
4aa6 7a ea		dw store_page 
4aa8 76 ea		dw store_readbuf 
4aaa 6d ea		dw store_readcont 
4aac 78 ea		dw store_readptr 
4aae 6d ea		dw store_tmpext 
4ab0 6e ea		dw store_tmpid 
4ab2 65 ea		dw store_tmppageid 
4ab4 ad 12		dw malloc 
4ab6 77 13		dw free 
4ab8 bb 65		dw cin 
4aba			; 70 
4aba b3 65		dw cin_wait 
4abc 46 1c		dw forth_push_numhl 
4abe b4 1c		dw forth_push_str 
4ac0			 
4ac0			 
4ac0			.ENDCONST: 
4ac0			 
4ac0			; eof 
4ac0			 
4ac0			 
# End of file forth_words_const.asm
4ac0			 
4ac0			if STORAGE_SE 
4ac0			   	include "forth_words_storage.asm" 
4ac0			endif 
4ac0				include "forth_words_device.asm" 
4ac0			; Device related words 
4ac0			 
4ac0			; | ## Device Words 
4ac0			 
4ac0			;if SOUND_ENABLE 
4ac0			;.NOTE: 
4ac0			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4ac0			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4ac0			;		if DEBUG_FORTH_WORDS_KEY 
4ac0			;			DMARK "NTE" 
4ac0			;			CALLMONITOR 
4ac0			;		endif 
4ac0			; 
4ac0			;	 
4ac0			; 
4ac0			;		NEXTW 
4ac0			;.AFTERSOUND: 
4ac0			;endif 
4ac0			 
4ac0			 
4ac0			USE_GPIO: equ 0 
4ac0			 
4ac0			if USE_GPIO 
4ac0			.GP1: 
4ac0				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4ac0			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4ac0					NEXTW 
4ac0			.GP2: 
4ac0				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4ac0			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4ac0			 
4ac0					NEXTW 
4ac0			 
4ac0			.GP3: 
4ac0				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4ac0			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4ac0			 
4ac0					NEXTW 
4ac0			 
4ac0			.GP4: 
4ac0				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4ac0			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4ac0			 
4ac0					NEXTW 
4ac0			.SIN: 
4ac0			 
4ac0			 
4ac0			endif 
4ac0			 
4ac0			 
4ac0				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4ac0 33				db WORD_SYS_CORE+31             
4ac1 f5 4a			dw .SOUT            
4ac3 03				db 2 + 1 
4ac4 .. 00			db "IN",0              
4ac7				endm 
# End of macro CWHEAD
4ac7			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4ac7					if DEBUG_FORTH_WORDS_KEY 
4ac7						DMARK "IN." 
4ac7 f5				push af  
4ac8 3a dc 4a			ld a, (.dmark)  
4acb 32 6b ee			ld (debug_mark),a  
4ace 3a dd 4a			ld a, (.dmark+1)  
4ad1 32 6c ee			ld (debug_mark+1),a  
4ad4 3a de 4a			ld a, (.dmark+2)  
4ad7 32 6d ee			ld (debug_mark+2),a  
4ada 18 03			jr .pastdmark  
4adc ..			.dmark: db "IN."  
4adf f1			.pastdmark: pop af  
4ae0			endm  
# End of macro DMARK
4ae0						CALLMONITOR 
4ae0 cd 6f ee			call debug_vector  
4ae3				endm  
# End of macro CALLMONITOR
4ae3					endif 
4ae3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4ae3 cd 3d 1e			call macro_dsp_valuehl 
4ae6				endm 
# End of macro FORTH_DSP_VALUEHL
4ae6			 
4ae6 e5					push hl 
4ae7			 
4ae7					; destroy value TOS 
4ae7			 
4ae7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ae7 cd f5 1e			call macro_forth_dsp_pop 
4aea				endm 
# End of macro FORTH_DSP_POP
4aea			 
4aea					; one value on hl get other one back 
4aea			 
4aea c1					pop bc 
4aeb			 
4aeb					; do the sub 
4aeb			;		ex de, hl 
4aeb			 
4aeb ed 68				in l,(c) 
4aed			 
4aed					; save it 
4aed			 
4aed 26 00				ld h,0 
4aef			 
4aef					; TODO push value back onto stack for another op etc 
4aef			 
4aef cd 46 1c				call forth_push_numhl 
4af2					NEXTW 
4af2 c3 f3 1f			jp macro_next 
4af5				endm 
# End of macro NEXTW
4af5			.SOUT: 
4af5				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4af5 34				db WORD_SYS_CORE+32             
4af6 48 4b			dw .SPIO            
4af8 04				db 3 + 1 
4af9 .. 00			db "OUT",0              
4afd				endm 
# End of macro CWHEAD
4afd			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4afd					if DEBUG_FORTH_WORDS_KEY 
4afd						DMARK "OUT" 
4afd f5				push af  
4afe 3a 12 4b			ld a, (.dmark)  
4b01 32 6b ee			ld (debug_mark),a  
4b04 3a 13 4b			ld a, (.dmark+1)  
4b07 32 6c ee			ld (debug_mark+1),a  
4b0a 3a 14 4b			ld a, (.dmark+2)  
4b0d 32 6d ee			ld (debug_mark+2),a  
4b10 18 03			jr .pastdmark  
4b12 ..			.dmark: db "OUT"  
4b15 f1			.pastdmark: pop af  
4b16			endm  
# End of macro DMARK
4b16						CALLMONITOR 
4b16 cd 6f ee			call debug_vector  
4b19				endm  
# End of macro CALLMONITOR
4b19					endif 
4b19			 
4b19					; get port 
4b19			 
4b19					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b19 cd 3d 1e			call macro_dsp_valuehl 
4b1c				endm 
# End of macro FORTH_DSP_VALUEHL
4b1c			 
4b1c e5					push hl 
4b1d			 
4b1d					; destroy value TOS 
4b1d			 
4b1d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b1d cd f5 1e			call macro_forth_dsp_pop 
4b20				endm 
# End of macro FORTH_DSP_POP
4b20			 
4b20					; get byte to send 
4b20			 
4b20					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b20 cd 3d 1e			call macro_dsp_valuehl 
4b23				endm 
# End of macro FORTH_DSP_VALUEHL
4b23			 
4b23			;		push hl 
4b23			 
4b23					; destroy value TOS 
4b23			 
4b23					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b23 cd f5 1e			call macro_forth_dsp_pop 
4b26				endm 
# End of macro FORTH_DSP_POP
4b26			 
4b26					; one value on hl get other one back 
4b26			 
4b26			;		pop hl 
4b26			 
4b26 c1					pop bc 
4b27			 
4b27					if DEBUG_FORTH_WORDS 
4b27						DMARK "OUT" 
4b27 f5				push af  
4b28 3a 3c 4b			ld a, (.dmark)  
4b2b 32 6b ee			ld (debug_mark),a  
4b2e 3a 3d 4b			ld a, (.dmark+1)  
4b31 32 6c ee			ld (debug_mark+1),a  
4b34 3a 3e 4b			ld a, (.dmark+2)  
4b37 32 6d ee			ld (debug_mark+2),a  
4b3a 18 03			jr .pastdmark  
4b3c ..			.dmark: db "OUT"  
4b3f f1			.pastdmark: pop af  
4b40			endm  
# End of macro DMARK
4b40						CALLMONITOR 
4b40 cd 6f ee			call debug_vector  
4b43				endm  
# End of macro CALLMONITOR
4b43					endif 
4b43			 
4b43 ed 69				out (c), l 
4b45			 
4b45					NEXTW 
4b45 c3 f3 1f			jp macro_next 
4b48				endm 
# End of macro NEXTW
4b48			 
4b48			 
4b48			.SPIO: 
4b48			 
4b48			if STORAGE_SE 
4b48				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4b48			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4b48			 
4b48					call spi_ce_low 
4b48			    NEXTW 
4b48			 
4b48			.SPICEH: 
4b48				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4b48			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4b48			 
4b48					call spi_ce_high 
4b48			    NEXTW 
4b48			 
4b48			 
4b48			.SPIOb: 
4b48			 
4b48				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4b48			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4b48			 
4b48					if DEBUG_FORTH_WORDS_KEY 
4b48						DMARK "SPo" 
4b48						CALLMONITOR 
4b48					endif 
4b48					; get port 
4b48			 
4b48			 
4b48					; get byte to send 
4b48			 
4b48					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b48			 
4b48			;		push hl    ; u1  
4b48			 
4b48					; destroy value TOS 
4b48			 
4b48					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b48			 
4b48					; one value on hl get other one back 
4b48			 
4b48			;		pop hl   ; u2 - addr 
4b48			 
4b48					; TODO Send SPI byte 
4b48			 
4b48			;		push hl 
4b48			;		call spi_ce_low 
4b48			;		pop hl 
4b48					ld a, l 
4b48					call spi_send_byte 
4b48			;		call spi_ce_high 
4b48			 
4b48					NEXTW 
4b48			 
4b48			.SPII: 
4b48				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4b48			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4b48					if DEBUG_FORTH_WORDS_KEY 
4b48						DMARK "SPi" 
4b48						CALLMONITOR 
4b48					endif 
4b48			 
4b48					; TODO Get SPI byte 
4b48			 
4b48					call spi_read_byte 
4b48			 
4b48					if DEBUG_FORTH_WORDS 
4b48						DMARK "Si2" 
4b48						CALLMONITOR 
4b48					endif 
4b48					ld h, 0 
4b48					ld l, a 
4b48					if DEBUG_FORTH_WORDS 
4b48						DMARK "Si3" 
4b48						CALLMONITOR 
4b48					endif 
4b48					call forth_push_numhl 
4b48			 
4b48					NEXTW 
4b48			 
4b48			 
4b48			 
4b48			.SESEL: 
4b48				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4b48			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4b48					if DEBUG_FORTH_WORDS_KEY 
4b48						DMARK "BNK" 
4b48						CALLMONITOR 
4b48					endif 
4b48			 
4b48					ld a, 255 
4b48					ld (spi_cartdev), a 
4b48			 
4b48					; get bank 
4b48			 
4b48					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b48			 
4b48			;		push hl 
4b48			 
4b48					; destroy value TOS 
4b48			 
4b48					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b48			 
4b48					; one value on hl get other one back 
4b48			 
4b48			;		pop hl 
4b48			 
4b48			 
4b48					ld c, SPI_CE_HIGH 
4b48					ld b, '0'    ; human readable bank number 
4b48			 
4b48					ld a, l 
4b48			 
4b48					if DEBUG_FORTH_WORDS 
4b48						DMARK "BNK" 
4b48						CALLMONITOR 
4b48					endif 
4b48			 
4b48					; active low 
4b48			 
4b48					cp 0 
4b48					jr z, .bset 
4b48					cp 1 
4b48					jr nz, .b2 
4b48					res 0, c 
4b48					ld b, '1'    ; human readable bank number 
4b48			.b2:		cp 2 
4b48					jr nz, .b3 
4b48					res 1, c 
4b48					ld b, '2'    ; human readable bank number 
4b48			.b3:		cp 3 
4b48					jr nz, .b4 
4b48					res 2, c 
4b48					ld b, '3'    ; human readable bank number 
4b48			.b4:		cp 4 
4b48					jr nz, .b5 
4b48					res 3, c 
4b48					ld b, '4'    ; human readable bank number 
4b48			.b5:		cp 5 
4b48					jr nz, .bset 
4b48					res 4, c 
4b48					ld b, '5'    ; human readable bank number 
4b48			 
4b48			.bset: 
4b48					ld a, c 
4b48					ld (spi_device),a 
4b48					ld a, b 
4b48					ld (spi_device_id),a 
4b48					if DEBUG_FORTH_WORDS 
4b48						DMARK "BN2" 
4b48						CALLMONITOR 
4b48					endif 
4b48			 
4b48					; set default SPI clk pulse time as disabled for BANK use 
4b48			 
4b48					ld a, 0 
4b48					ld (spi_clktime), a 
4b48			 
4b48					NEXTW 
4b48			 
4b48			.CARTDEV: 
4b48				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4b48			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4b48					if DEBUG_FORTH_WORDS_KEY 
4b48						DMARK "CDV" 
4b48						CALLMONITOR 
4b48					endif 
4b48			 
4b48					; disable se storage bank selection 
4b48			 
4b48					ld a, SPI_CE_HIGH		; ce high 
4b48					ld (spi_device), a 
4b48			 
4b48					; get bank 
4b48			 
4b48					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b48			 
4b48			;		push hl 
4b48			 
4b48					; destroy value TOS 
4b48			 
4b48					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b48			 
4b48					; one value on hl get other one back 
4b48			 
4b48			;		pop hl 
4b48			 
4b48					; active low 
4b48			 
4b48					ld c, 255 
4b48			 
4b48					ld a, l 
4b48					if DEBUG_FORTH_WORDS 
4b48						DMARK "CDV" 
4b48						CALLMONITOR 
4b48					endif 
4b48					cp 0 
4b48					jr z, .cset 
4b48					cp 1 
4b48					jr nz, .c2 
4b48					res 0, c 
4b48			.c2:		cp 2 
4b48					jr nz, .c3 
4b48					res 1, c 
4b48			.c3:		cp 3 
4b48					jr nz, .c4 
4b48					res 2, c 
4b48			.c4:		cp 4 
4b48					jr nz, .c5 
4b48					res 3, c 
4b48			.c5:		cp 5 
4b48					jr nz, .c6 
4b48					res 4, c 
4b48			.c6:		cp 6 
4b48					jr nz, .c7 
4b48					res 5, c 
4b48			.c7:		cp 7 
4b48					jr nz, .c8 
4b48					res 6, c 
4b48			.c8:		cp 8 
4b48					jr nz, .cset 
4b48					res 7, c 
4b48			.cset:		ld a, c 
4b48					ld (spi_cartdev),a 
4b48			 
4b48					if DEBUG_FORTH_WORDS 
4b48						DMARK "CD2" 
4b48						CALLMONITOR 
4b48					endif 
4b48			 
4b48					; set default SPI clk pulse time as 10ms for CARTDEV use 
4b48			 
4b48					ld a, $0a 
4b48					ld (spi_clktime), a 
4b48					NEXTW 
4b48			endif 
4b48			 
4b48			.ENDDEVICE: 
4b48			; eof 
4b48			 
# End of file forth_words_device.asm
4b48			 
4b48			; var handler 
4b48			 
4b48			 
4b48			.VARS: 
4b48				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4b48 77				db WORD_SYS_CORE+99             
4b49 f9 4b			dw .V0            
4b4b 04				db 3 + 1 
4b4c .. 00			db "VAR",0              
4b50				endm 
# End of macro CWHEAD
4b50			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4b50			;| 
4b50			;| The variable name should consist of a single letter. e.g. "a" 
4b50			;! If a full string is passed then only the first char is looked at 
4b50			;| Any other char could exceed bounds checks!  
4b50			 
4b50					if DEBUG_FORTH_WORDS_KEY 
4b50						DMARK "VAR" 
4b50 f5				push af  
4b51 3a 65 4b			ld a, (.dmark)  
4b54 32 6b ee			ld (debug_mark),a  
4b57 3a 66 4b			ld a, (.dmark+1)  
4b5a 32 6c ee			ld (debug_mark+1),a  
4b5d 3a 67 4b			ld a, (.dmark+2)  
4b60 32 6d ee			ld (debug_mark+2),a  
4b63 18 03			jr .pastdmark  
4b65 ..			.dmark: db "VAR"  
4b68 f1			.pastdmark: pop af  
4b69			endm  
# End of macro DMARK
4b69						CALLMONITOR 
4b69 cd 6f ee			call debug_vector  
4b6c				endm  
# End of macro CALLMONITOR
4b6c					endif 
4b6c			 
4b6c					FORTH_DSP_VALUEHL 
4b6c cd 3d 1e			call macro_dsp_valuehl 
4b6f				endm 
# End of macro FORTH_DSP_VALUEHL
4b6f			 
4b6f 7e					ld a, (hl)    ; get first char on of the string 
4b70			 
4b70			 
4b70					if DEBUG_FORTH_WORDS 
4b70						DMARK "VR1" 
4b70 f5				push af  
4b71 3a 85 4b			ld a, (.dmark)  
4b74 32 6b ee			ld (debug_mark),a  
4b77 3a 86 4b			ld a, (.dmark+1)  
4b7a 32 6c ee			ld (debug_mark+1),a  
4b7d 3a 87 4b			ld a, (.dmark+2)  
4b80 32 6d ee			ld (debug_mark+2),a  
4b83 18 03			jr .pastdmark  
4b85 ..			.dmark: db "VR1"  
4b88 f1			.pastdmark: pop af  
4b89			endm  
# End of macro DMARK
4b89						CALLMONITOR 
4b89 cd 6f ee			call debug_vector  
4b8c				endm  
# End of macro CALLMONITOR
4b8c					endif 
4b8c					 
4b8c f5					push af	 
4b8d					FORTH_DSP_POP 
4b8d cd f5 1e			call macro_forth_dsp_pop 
4b90				endm 
# End of macro FORTH_DSP_POP
4b90 f1					pop af 
4b91			 
4b91					; convert to upper 
4b91			 
4b91 cd 53 11				call to_upper 
4b94					if DEBUG_FORTH_WORDS 
4b94						DMARK "Vaa" 
4b94 f5				push af  
4b95 3a a9 4b			ld a, (.dmark)  
4b98 32 6b ee			ld (debug_mark),a  
4b9b 3a aa 4b			ld a, (.dmark+1)  
4b9e 32 6c ee			ld (debug_mark+1),a  
4ba1 3a ab 4b			ld a, (.dmark+2)  
4ba4 32 6d ee			ld (debug_mark+2),a  
4ba7 18 03			jr .pastdmark  
4ba9 ..			.dmark: db "Vaa"  
4bac f1			.pastdmark: pop af  
4bad			endm  
# End of macro DMARK
4bad						CALLMONITOR 
4bad cd 6f ee			call debug_vector  
4bb0				endm  
# End of macro CALLMONITOR
4bb0					endif 
4bb0 06 41				ld b, 'A' 
4bb2 90					sub b			; set offset 
4bb3					if DEBUG_FORTH_WORDS 
4bb3						DMARK "Vbb" 
4bb3 f5				push af  
4bb4 3a c8 4b			ld a, (.dmark)  
4bb7 32 6b ee			ld (debug_mark),a  
4bba 3a c9 4b			ld a, (.dmark+1)  
4bbd 32 6c ee			ld (debug_mark+1),a  
4bc0 3a ca 4b			ld a, (.dmark+2)  
4bc3 32 6d ee			ld (debug_mark+2),a  
4bc6 18 03			jr .pastdmark  
4bc8 ..			.dmark: db "Vbb"  
4bcb f1			.pastdmark: pop af  
4bcc			endm  
# End of macro DMARK
4bcc						CALLMONITOR 
4bcc cd 6f ee			call debug_vector  
4bcf				endm  
# End of macro CALLMONITOR
4bcf					endif 
4bcf cb 27				sla a  
4bd1				 
4bd1					 
4bd1					if DEBUG_FORTH_WORDS 
4bd1						DMARK "VR2" 
4bd1 f5				push af  
4bd2 3a e6 4b			ld a, (.dmark)  
4bd5 32 6b ee			ld (debug_mark),a  
4bd8 3a e7 4b			ld a, (.dmark+1)  
4bdb 32 6c ee			ld (debug_mark+1),a  
4bde 3a e8 4b			ld a, (.dmark+2)  
4be1 32 6d ee			ld (debug_mark+2),a  
4be4 18 03			jr .pastdmark  
4be6 ..			.dmark: db "VR2"  
4be9 f1			.pastdmark: pop af  
4bea			endm  
# End of macro DMARK
4bea						CALLMONITOR 
4bea cd 6f ee			call debug_vector  
4bed				endm  
# End of macro CALLMONITOR
4bed					endif 
4bed			 
4bed 21 f4 e9				ld hl, cli_var_array2 
4bf0 cd e6 0d				call addatohl 
4bf3 cd 46 1c				call forth_push_numhl 
4bf6			 
4bf6			 
4bf6				       NEXTW 
4bf6 c3 f3 1f			jp macro_next 
4bf9				endm 
# End of macro NEXTW
4bf9			.V0: 
4bf9				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4bf9 78				db WORD_SYS_CORE+100             
4bfa 11 4c			dw .V0Q            
4bfc 04				db 3 + 1 
4bfd .. 00			db "V0!",0              
4c01				endm 
# End of macro CWHEAD
4c01			;| V0! ( u1 -- )  Store value to v0  | DONE 
4c01			 
4c01					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c01 cd 3d 1e			call macro_dsp_valuehl 
4c04				endm 
# End of macro FORTH_DSP_VALUEHL
4c04			 
4c04 11 28 ea				ld de, cli_var_array 
4c07			 
4c07 eb					ex de, hl 
4c08 73					ld (hl), e 
4c09 23					inc hl 
4c0a 72					ld (hl), d 
4c0b			 
4c0b					; destroy value TOS 
4c0b			 
4c0b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c0b cd f5 1e			call macro_forth_dsp_pop 
4c0e				endm 
# End of macro FORTH_DSP_POP
4c0e			 
4c0e				       NEXTW 
4c0e c3 f3 1f			jp macro_next 
4c11				endm 
# End of macro NEXTW
4c11			.V0Q: 
4c11				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4c11 79				db WORD_SYS_CORE+101             
4c12 22 4c			dw .V1S            
4c14 04				db 3 + 1 
4c15 .. 00			db "V0@",0              
4c19				endm 
# End of macro CWHEAD
4c19			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4c19 2a 28 ea				ld hl, (cli_var_array) 
4c1c cd 46 1c				call forth_push_numhl 
4c1f			 
4c1f				       NEXTW 
4c1f c3 f3 1f			jp macro_next 
4c22				endm 
# End of macro NEXTW
4c22			.V1S: 
4c22				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4c22 7a				db WORD_SYS_CORE+102             
4c23 3a 4c			dw .V1Q            
4c25 04				db 3 + 1 
4c26 .. 00			db "V1!",0              
4c2a				endm 
# End of macro CWHEAD
4c2a			;| V1! ( u1 -- )  Store value to v1 | DONE 
4c2a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c2a cd 3d 1e			call macro_dsp_valuehl 
4c2d				endm 
# End of macro FORTH_DSP_VALUEHL
4c2d			 
4c2d 11 2a ea				ld de, cli_var_array+2 
4c30				 
4c30 eb					ex de, hl 
4c31 73					ld (hl), e 
4c32 23					inc hl 
4c33 72					ld (hl), d 
4c34			 
4c34					; destroy value TOS 
4c34			 
4c34					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c34 cd f5 1e			call macro_forth_dsp_pop 
4c37				endm 
# End of macro FORTH_DSP_POP
4c37				       NEXTW 
4c37 c3 f3 1f			jp macro_next 
4c3a				endm 
# End of macro NEXTW
4c3a			.V1Q: 
4c3a				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4c3a 7b				db WORD_SYS_CORE+103             
4c3b 4b 4c			dw .V2S            
4c3d 04				db 3 + 1 
4c3e .. 00			db "V1@",0              
4c42				endm 
# End of macro CWHEAD
4c42			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4c42 2a 2a ea				ld hl, (cli_var_array+2) 
4c45 cd 46 1c				call forth_push_numhl 
4c48				       NEXTW 
4c48 c3 f3 1f			jp macro_next 
4c4b				endm 
# End of macro NEXTW
4c4b			.V2S: 
4c4b				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4c4b 7c				db WORD_SYS_CORE+104             
4c4c 63 4c			dw .V2Q            
4c4e 04				db 3 + 1 
4c4f .. 00			db "V2!",0              
4c53				endm 
# End of macro CWHEAD
4c53			;| V2! ( u1 -- )  Store value to v2 | DONE 
4c53					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c53 cd 3d 1e			call macro_dsp_valuehl 
4c56				endm 
# End of macro FORTH_DSP_VALUEHL
4c56			 
4c56 11 2c ea				ld de, cli_var_array+4 
4c59				 
4c59 eb					ex de, hl 
4c5a 73					ld (hl), e 
4c5b 23					inc hl 
4c5c 72					ld (hl), d 
4c5d			 
4c5d					; destroy value TOS 
4c5d			 
4c5d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c5d cd f5 1e			call macro_forth_dsp_pop 
4c60				endm 
# End of macro FORTH_DSP_POP
4c60				       NEXTW 
4c60 c3 f3 1f			jp macro_next 
4c63				endm 
# End of macro NEXTW
4c63			.V2Q: 
4c63				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4c63 7d				db WORD_SYS_CORE+105             
4c64 74 4c			dw .V3S            
4c66 04				db 3 + 1 
4c67 .. 00			db "V2@",0              
4c6b				endm 
# End of macro CWHEAD
4c6b			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4c6b 2a 2c ea				ld hl, (cli_var_array+4) 
4c6e cd 46 1c				call forth_push_numhl 
4c71				       NEXTW 
4c71 c3 f3 1f			jp macro_next 
4c74				endm 
# End of macro NEXTW
4c74			.V3S: 
4c74				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4c74 7c				db WORD_SYS_CORE+104             
4c75 8c 4c			dw .V3Q            
4c77 04				db 3 + 1 
4c78 .. 00			db "V3!",0              
4c7c				endm 
# End of macro CWHEAD
4c7c			;| V3! ( u1 -- )  Store value to v3 | DONE 
4c7c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c7c cd 3d 1e			call macro_dsp_valuehl 
4c7f				endm 
# End of macro FORTH_DSP_VALUEHL
4c7f			 
4c7f 11 2e ea				ld de, cli_var_array+6 
4c82				 
4c82 eb					ex de, hl 
4c83 73					ld (hl), e 
4c84 23					inc hl 
4c85 72					ld (hl), d 
4c86			 
4c86					; destroy value TOS 
4c86			 
4c86					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c86 cd f5 1e			call macro_forth_dsp_pop 
4c89				endm 
# End of macro FORTH_DSP_POP
4c89				       NEXTW 
4c89 c3 f3 1f			jp macro_next 
4c8c				endm 
# End of macro NEXTW
4c8c			.V3Q: 
4c8c				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4c8c 7d				db WORD_SYS_CORE+105             
4c8d 9d 4c			dw .END            
4c8f 04				db 3 + 1 
4c90 .. 00			db "V3@",0              
4c94				endm 
# End of macro CWHEAD
4c94			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4c94 2a 2e ea				ld hl, (cli_var_array+6) 
4c97 cd 46 1c				call forth_push_numhl 
4c9a				       NEXTW 
4c9a c3 f3 1f			jp macro_next 
4c9d				endm 
# End of macro NEXTW
4c9d			 
4c9d			 
4c9d			 
4c9d			 
4c9d			 
4c9d			; end of dict marker 
4c9d			 
4c9d 00			.END:    db WORD_SYS_END 
4c9e 00 00			dw 0 
4ca0 00				db 0 
4ca1			 
4ca1			; use to jp here for user dict words to save on macro expansion  
4ca1			 
4ca1			user_dict_next: 
4ca1				NEXTW 
4ca1 c3 f3 1f			jp macro_next 
4ca4				endm 
# End of macro NEXTW
4ca4			 
4ca4			 
4ca4			user_exec: 
4ca4				;    ld hl, <word code> 
4ca4				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4ca4				;    call forthexec 
4ca4				;    jp user_dict_next   (NEXT) 
4ca4			        ;    <word code bytes> 
4ca4 eb				ex de, hl 
4ca5 2a c2 e5			ld hl,(os_tok_ptr) 
4ca8				 
4ca8				FORTH_RSP_NEXT 
4ca8 cd ed 1b			call macro_forth_rsp_next 
4cab				endm 
# End of macro FORTH_RSP_NEXT
4cab			 
4cab			if DEBUG_FORTH_UWORD 
4cab						DMARK "UEX" 
4cab f5				push af  
4cac 3a c0 4c			ld a, (.dmark)  
4caf 32 6b ee			ld (debug_mark),a  
4cb2 3a c1 4c			ld a, (.dmark+1)  
4cb5 32 6c ee			ld (debug_mark+1),a  
4cb8 3a c2 4c			ld a, (.dmark+2)  
4cbb 32 6d ee			ld (debug_mark+2),a  
4cbe 18 03			jr .pastdmark  
4cc0 ..			.dmark: db "UEX"  
4cc3 f1			.pastdmark: pop af  
4cc4			endm  
# End of macro DMARK
4cc4				CALLMONITOR 
4cc4 cd 6f ee			call debug_vector  
4cc7				endm  
# End of macro CALLMONITOR
4cc7			endif 
4cc7			 
4cc7			 
4cc7			 
4cc7 eb				ex de, hl 
4cc8 22 c2 e5			ld (os_tok_ptr), hl 
4ccb				 
4ccb				; Don't use next - Skips the first word in uword. 
4ccb			 
4ccb c3 84 20			jp exec1 
4cce			;	NEXT 
4cce			 
4cce			 
4cce			; eof 
# End of file forth_wordsv4.asm
4cce			endif 
4cce			;;;;;;;;;;;;;; Debug code 
4cce			 
4cce			 
4cce			;if DEBUG_FORTH_PARSE 
4cce .. 00		.nowordfound: db "No match",0 
4cd7 .. 00		.compword:	db "Comparing word ",0 
4ce7 .. 00		.nextwordat:	db "Next word at",0 
4cf4 .. 00		.charmatch:	db "Char match",0 
4cff			;endif 
4cff			if DEBUG_FORTH_JP 
4cff			.foundword:	db "Word match. Exec..",0 
4cff			endif 
4cff			;if DEBUG_FORTH_PUSH 
4cff .. 00		.enddict:	db "Dict end. Push.",0 
4d0f .. 00		.push_str:	db "Pushing string",0 
4d1e .. 00		.push_num:	db "Pushing number",0 
4d2d .. 00		.data_sp:	db "SP:",0 
4d31 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4d43 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4d55 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4d67			;endif 
4d67			;if DEBUG_FORTH_MALLOC 
4d67 .. 00		.push_malloc:	db "Malloc address",0 
4d76			;endif 
4d76			 
4d76			 
4d76			 
4d76			; display malloc address and current data stack pointer  
4d76			 
4d76			malloc_error: 
4d76 d5				push de 
4d77 f5				push af 
4d78 e5				push hl 
4d79 cd b9 0b			call clear_display 
4d7c 11 9c 4d			ld de, .mallocerr 
4d7f 3e 00			ld a,0 
4d81			;	ld de,os_word_scratch 
4d81 cd cc 0b			call str_at_display 
4d84 3e 11			ld a, display_row_1+17 
4d86 11 6b ee			ld de, debug_mark 
4d89 cd cc 0b			call str_at_display 
4d8c cd dc 0b			call update_display 
4d8f				;call break_point_state 
4d8f cd b3 65			call cin_wait 
4d92			 
4d92			;	ld a, ' ' 
4d92			;	ld (os_view_disable), a 
4d92 cd dc 15			call bp_on 
4d95 e1				pop hl 
4d96 f1				pop af 
4d97 d1				pop de	 
4d98				CALLMONITOR 
4d98 cd 6f ee			call debug_vector  
4d9b				endm  
# End of macro CALLMONITOR
4d9b c9				ret 
4d9c			 
4d9c .. 00		.mallocerr: 	db "Malloc Error",0 
4da9			;if DEBUG_FORTH_PUSH 
4da9			display_data_sp: 
4da9 f5				push af 
4daa			 
4daa				; see if disabled 
4daa			 
4daa			 
4daa 3a 6f ee			ld a, (debug_vector) 
4dad fe c9			cp $C9  ; RET 
4daf				;ld a, (os_view_disable) 
4daf				;cp '*' 
4daf 28 67			jr z, .skipdsp 
4db1			 
4db1 e5				push hl 
4db2 e5				push hl 
4db3 e5			push hl 
4db4 cd b9 0b			call clear_display 
4db7 e1			pop hl 
4db8 7c				ld a,h 
4db9 21 c6 e5			ld hl, os_word_scratch 
4dbc cd e7 10			call hexout 
4dbf e1				pop hl 
4dc0 7d				ld a,l 
4dc1 21 c8 e5			ld hl, os_word_scratch+2 
4dc4 cd e7 10			call hexout 
4dc7 21 ca e5			ld hl, os_word_scratch+4 
4dca 3e 00			ld a,0 
4dcc 77				ld (hl),a 
4dcd 11 c6 e5			ld de,os_word_scratch 
4dd0 3e 28				ld a, display_row_2 
4dd2 cd cc 0b				call str_at_display 
4dd5 11 31 4d			ld de, .wordinhl 
4dd8 3e 00			ld a, display_row_1 
4dda			 
4dda cd cc 0b				call str_at_display 
4ddd 11 6b ee			ld de, debug_mark 
4de0 3e 11			ld a, display_row_1+17 
4de2			 
4de2 cd cc 0b				call str_at_display 
4de5			 
4de5				; display current data stack pointer 
4de5 11 2d 4d			ld de,.data_sp 
4de8 3e 30				ld a, display_row_2 + 8 
4dea cd cc 0b				call str_at_display 
4ded			 
4ded 2a ee e9			ld hl,(cli_data_sp) 
4df0 e5				push hl 
4df1 7c				ld a,h 
4df2 21 c6 e5			ld hl, os_word_scratch 
4df5 cd e7 10			call hexout 
4df8 e1				pop hl 
4df9 7d				ld a,l 
4dfa 21 c8 e5			ld hl, os_word_scratch+2 
4dfd cd e7 10			call hexout 
4e00 21 ca e5			ld hl, os_word_scratch+4 
4e03 3e 00			ld a,0 
4e05 77				ld (hl),a 
4e06 11 c6 e5			ld de,os_word_scratch 
4e09 3e 33				ld a, display_row_2 + 11 
4e0b cd cc 0b				call str_at_display 
4e0e			 
4e0e			 
4e0e cd dc 0b			call update_display 
4e11 cd f1 0a			call delay1s 
4e14 cd f1 0a			call delay1s 
4e17 e1				pop hl 
4e18			.skipdsp: 
4e18 f1				pop af 
4e19 c9				ret 
4e1a			 
4e1a			display_data_malloc: 
4e1a			 
4e1a f5				push af 
4e1b e5				push hl 
4e1c e5				push hl 
4e1d e5			push hl 
4e1e cd b9 0b			call clear_display 
4e21 e1			pop hl 
4e22 7c				ld a,h 
4e23 21 c6 e5			ld hl, os_word_scratch 
4e26 cd e7 10			call hexout 
4e29 e1				pop hl 
4e2a 7d				ld a,l 
4e2b 21 c8 e5			ld hl, os_word_scratch+2 
4e2e cd e7 10			call hexout 
4e31 21 ca e5			ld hl, os_word_scratch+4 
4e34 3e 00			ld a,0 
4e36 77				ld (hl),a 
4e37 11 c6 e5			ld de,os_word_scratch 
4e3a 3e 28				ld a, display_row_2 
4e3c cd cc 0b				call str_at_display 
4e3f 11 67 4d			ld de, .push_malloc 
4e42 3e 00			ld a, display_row_1 
4e44			 
4e44 cd cc 0b				call str_at_display 
4e47			 
4e47				; display current data stack pointer 
4e47 11 2d 4d			ld de,.data_sp 
4e4a 3e 30				ld a, display_row_2 + 8 
4e4c cd cc 0b				call str_at_display 
4e4f			 
4e4f 2a ee e9			ld hl,(cli_data_sp) 
4e52 e5				push hl 
4e53 7c				ld a,h 
4e54 21 c6 e5			ld hl, os_word_scratch 
4e57 cd e7 10			call hexout 
4e5a e1				pop hl 
4e5b 7d				ld a,l 
4e5c 21 c8 e5			ld hl, os_word_scratch+2 
4e5f cd e7 10			call hexout 
4e62 21 ca e5			ld hl, os_word_scratch+4 
4e65 3e 00			ld a,0 
4e67 77				ld (hl),a 
4e68 11 c6 e5			ld de,os_word_scratch 
4e6b 3e 33				ld a, display_row_2 + 11 
4e6d cd cc 0b				call str_at_display 
4e70			 
4e70 cd dc 0b			call update_display 
4e73 cd f1 0a			call delay1s 
4e76 cd f1 0a			call delay1s 
4e79 e1				pop hl 
4e7a f1				pop af 
4e7b c9				ret 
4e7c			;endif 
4e7c			 
4e7c			include "forth_autostart.asm" 
4e7c			; list of commands to perform at system start up 
4e7c			 
4e7c			startcmds: 
4e7c			;	dw test11 
4e7c			;	dw test12 
4e7c			;	dw test13 
4e7c			;	dw test14 
4e7c			;	dw test15 
4e7c			;	dw test16 
4e7c			;	dw test17 
4e7c			;	dw ifthtest1 
4e7c			;	dw ifthtest2 
4e7c			;	dw ifthtest3 
4e7c			;	dw mmtest1 
4e7c			;	dw mmtest2 
4e7c			;	dw mmtest3 
4e7c			;	dw mmtest4 
4e7c			;	dw mmtest5 
4e7c			;	dw mmtest6 
4e7c			;	dw iftest1 
4e7c			;	dw iftest2 
4e7c			;	dw iftest3 
4e7c			;	dw looptest1 
4e7c			;	dw looptest2 
4e7c			;	dw test1 
4e7c			;	dw test2 
4e7c			;	dw test3 
4e7c			;	dw test4 
4e7c			;	dw game2r 
4e7c			;	dw game2b1 
4e7c			;	dw game2b2 
4e7c			 
4e7c				; start up words that are actually useful 
4e7c			 
4e7c			;    dw spi1 
4e7c			;    dw spi2 
4e7c			;    dw spi3 
4e7c			;    dw spi4 
4e7c			;    dw spi5 
4e7c			;    dw spi6 
4e7c			;    dw spi7 
4e7c			; 
4e7c			;    dw spi8 
4e7c			;    dw spi9 
4e7c			;    dw spi10 
4e7c			 
4e7c			; file editor 
4e7c			;	dw edit1 
4e7c			;	dw edit2 
4e7c			;	dw edit3 
4e7c			 
4e7c			;	dw longread 
4e7c 7c 52			dw clrstack 
4e7e b0 52			dw type 
4e80			;	dw stest 
4e80 d5 52			dw strncpy 
4e82			;	dw list 
4e82 36 53			dw start1 
4e84 46 53			dw start2 
4e86			;	dw start3 
4e86			;	dw start3b 
4e86			;	dw start3c 
4e86			 
4e86				; (unit) testing words 
4e86			 
4e86			;	dw mtesta 
4e86			;	dw mtestb 
4e86			;	dw mtestc 
4e86			;	dw mtestd 
4e86			;	dw mteste 
4e86			 
4e86				; demo/game words 
4e86			 
4e86			;        dw game3w 
4e86			;        dw game3p 
4e86			;        dw game3sc 
4e86			;        dw game3vsi 
4e86			;        dw game3vs 
4e86				 
4e86 9f 5d			dw game2b 
4e88 0d 5e			dw game2bf 
4e8a 57 5e			dw game2mba 
4e8c ed 5e			dw game2mbas 
4e8e 2f 5f			dw game2mb 
4e90			 
4e90 60 5a			dw game1 
4e92 71 5a			dw game1a 
4e94 d3 5a			dw game1b 
4e96 08 5b			dw game1c 
4e98 3e 5b			dw game1d 
4e9a 6f 5b			dw game1s 
4e9c 83 5b			dw game1t 
4e9e 98 5b			dw game1f 
4ea0 cc 5b			dw game1z 
4ea2 10 5c			dw game1zz 
4ea4			 
4ea4 7a 58			dw test5 
4ea6 b2 58			dw test6 
4ea8 ea 58			dw test7 
4eaa fe 58			dw test8 
4eac 2a 59			dw test9 
4eae 40 59			dw test10 
4eb0				 
4eb0 e7 5c		        dw ssv5 
4eb2 cb 5c		        dw ssv4 
4eb4 af 5c		        dw ssv3 
4eb6 79 5c		        dw ssv2 
4eb8 00 5d		        dw ssv1 
4eba 48 5d		        dw ssv1cpm 
4ebc			;	dw keyup 
4ebc			;	dw keydown 
4ebc			;	dw keyleft 
4ebc			;	dw keyright 
4ebc			;	dw 	keyf1 
4ebc			;	dw keyf2 
4ebc			;	dw keyf3 
4ebc			;	dw keyf4 
4ebc			;	dw keyf5 
4ebc			;	dw keyf6 
4ebc			;	dw keyf7 
4ebc			;	dw keyf8 
4ebc			;	dw keyf9 
4ebc			;	dw keyf10 
4ebc			;	dw keyf11 
4ebc			;	dw keyf12 
4ebc			;	dw keytab 
4ebc			;	dw keycr 
4ebc			;	dw keyhome 
4ebc			;	dw keyend 
4ebc			;	dw keybs 
4ebc 00 00			db 0, 0	 
4ebe			 
4ebe			 
4ebe			; File Editor 
4ebe			 
4ebe			; ( id - ) use 'e' to edit the displayed line 
4ebe .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
4edf .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4f14			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4f14 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
4f4c			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
4f4c			 
4f4c			; SPI Net support words 
4f4c			 
4f4c			; v0! = node to send to 
4f4c			; ( str count - ) 
4f4c .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
4fa5			 
4fa5			; spiputchr ( char node - ) 
4fa5 .. 00		spi2:       db ": spiputchr spicel $10 spio spio ptr @ spio spiceh ; ",0 
4fdb			 
4fdb			; spigetchr ( - n ) 
4fdb .. 00		spi4:       db ": spigetchr spicel $11 spio spii spiceh ; ", 0 
5006			 
5006			; getnode ( - n ) 
5006 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
5033			 
5033			; ( str node - )  
5033 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
5099			; store string ( str i - ) 
5099			 
5099			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
5099 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
50ee			 
50ee			; get string ( addr i -  )    TO FIX 
50ee			 
50ee .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
5146			 
5146			 
5146			; NETCHAT (TODO) 
5146			; Program to allow two nodes to chat with eachother 
5146			; 
5146			; v0 - target node 
5146			;  
5146			; accept input at 0,0 
5146			; if input is string send spitype to target node 
5146			; starting at row 2,0 , while spigetchr is not zero ->  
5146			; 
5146			; 
5146			; TODO add paging of get request 
5146			 
5146			; ( node - ) 
5146 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
5165 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
51bd .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
5235			 
5235			 
5235			; Long read of currently open file 
5235 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
527c			 
527c			; clear stack  
527c			 
527c .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
52b0			 
52b0			; type ( addr count - ) 
52b0 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
52d5			 
52d5			; some direct memory words 
52d5			; strncpy ( len t f -- t ) 
52d5			 
52d5 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
5336			 
5336 .. 00		start1:     	db ": bpon $00 bp ;",0 
5346 .. 00		start2:     	db ": bpoff $01 bp ;",0 
5357 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
53d2 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
5432			 
5432			 
5432			; a handy word to list items on the stack 
5432			 
5432 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
549c			 
549c			 
549c			; test stack  
549c			; rnd8 stest 
549c			 
549c .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
5513			 
5513			; random malloc and free cycles 
5513			 
5513 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
55c8			 
55c8			; fixed malloc and free cycles 
55c8			 
55c8 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
566b			 
566b			; fixed double string push and drop cycle  
566b			 
566b .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
5720			 
5720			; consistent fixed string push and drop cycle  
5720			 
5720 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
57c4			 
57c4 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
587a			 
587a			;test1:		db ": aa 1 2 3 ;", 0 
587a			;test2:     	db "111 aa 888 999",0 
587a			;test3:     	db ": bb 77 ;",0 
587a			;test4:     	db "$02 $01 do i . loop bb",0 
587a			 
587a .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
58b2 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
58ea .. 00		test7:     	db ": box hline vline ;",0 
58fe .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
592a .. 00		test9:     	db ": sw $01 adsp world ;",0 
5940 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5965 .. 00		test11:     	db "hello create .",0 
5974 .. 00		test12:     	db "hello2 create .",0 
5984			 
5984			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5984			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5984			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5984			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5984			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5984			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5984			 
5984			;iftest1:     	db "$0001 IF cls .",0 
5984			;iftest2:     	db "$0000 IF cls .",0 
5984			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5984			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5984			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5984			 
5984			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5984			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5984			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5984			 
5984			 
5984 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
59a8 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
59d8 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
59fd .. 00		sound4: db ": cha $00 ; ",0 
5a0a .. 00		sound5: db ": chb $20 ; ",0 
5a17 .. 00		sound6: db ": chc $40 ; ",0 
5a24 .. 00		sound7: db ": chd $60 ; ",0 
5a31 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
5a49 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
5a60			 
5a60			 
5a60			 
5a60			 
5a60			; a small guess the number game 
5a60			 
5a60 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5a71 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5ad3			 
5ad3 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
5b08 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
5b3e .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5b6f .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5b83 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5b98 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5bcc .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
5c10			 
5c10			; Using 'ga' save a high score across multiple runs using external storage 
5c10			 
5c10 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5c79			 
5c79			 
5c79			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5c79			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c79			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5c79			 
5c79			; simple screen saver to test code memory reuse to destruction 
5c79			 
5c79 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5caf .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5ccb .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5ce7 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5d00 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d48 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5d9f			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5d9f			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5d9f			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5d9f			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5d9f			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5d9f			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5d9f			 
5d9f			 
5d9f			 
5d9f			; minesweeper/battleship finding game 
5d9f			; draws a game board of random ship/mine positions 
5d9f			; user enters coords to see if it hits on 
5d9f			; game ends when all are hit 
5d9f			; when hit or miss says how many may be in the area 
5d9f			 
5d9f			; setup the game board and then hide it 
5d9f .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5e0d .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5e57			; prompt for where to target 
5e57 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5eed .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5f12			; TODO see if the entered coords hits or misses pushes char hit of miss 
5f12 .. 00		game2mbht:      db ": mbckht nop ;",0 
5f21 .. 00		game2mbms:      db ": mbcms nop ;",0 
5f2f			; TODO how many might be near by 
5f2f .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5fac			 
5fac			; Game 3 
5fac			 
5fac			; Vert scroller ski game - avoid the trees! 
5fac			 
5fac			; v0 score (ie turns) 
5fac			; v1 player pos 
5fac			; v2 left wall 
5fac			; v3 right wall 
5fac			 
5fac			; Draw side walls randomly 
5fac			 
5fac .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5fda			 
5fda			; Draw player 
5fda .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5ff8			 
5ff8			; TODO Get Key 
5ff8			 
5ff8			; TODO Move left right 
5ff8			 
5ff8			; scroll and move walls a bit 
5ff8			 
5ff8 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6029			 
6029			; main game loop 
6029			 
6029 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6055 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6094			 
6094			; key board defs 
6094			 
6094 .. 00		keyup:       db ": keyup $05 ;",0 
60a2 .. 00		keydown:       db ": keydown $0a ;",0 
60b2 .. 00		keyleft:       db ": keyleft $0b ;",0 
60c2 .. 00		keyright:       db ": keyright $0c ;",0 
60d3 .. 00		keyf1:       db ": keyf1 $10 ;",0 
60e1 .. 00		keyf2:       db ": keyf2 $11 ;",0 
60ef .. 00		keyf3:       db ": keyf3 $12 ;",0 
60fd .. 00		keyf4:       db ": keyf4 $13 ;",0 
610b .. 00		keyf5:       db ": keyf5 $14 ;",0 
6119 .. 00		keyf6:       db ": keyf6 $15 ;",0 
6127 .. 00		keyf7:       db ": keyf7 $16 ;",0 
6135 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6143 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6151 .. 00		keyf10:       db ": keyf10 $19 ;",0 
6160 .. 00		keyf11:       db ": keyf11 $1a ;",0 
616f .. 00		keyf12:       db ": keyf12 $1b ;",0 
617e			 
617e .. 00		keytab:       db ": keytab $09 ;",0 
618d .. 00		keycr:       db ": keycr $0d ;",0 
619b .. 00		keyhome:       db ": keyhome $0e ;",0 
61ab .. 00		keyend:       db ": keyend $0f ;",0 
61ba .. 00		keybs:       db ": keybs $08 ;",0 
61c8			 
61c8			   
61c8			 
61c8			 
61c8			 
61c8			; eof 
# End of file forth_autostart.asm
61c8			 
61c8			 
61c8			 
61c8			; stack over and underflow checks 
61c8			 
61c8			; init the words to detect the under/overflow 
61c8			 
61c8			chk_stk_init: 
61c8				; a vague random number to check so we dont get any "lucky" hits 
61c8 3e 2d			ld a, 45 
61ca 6f				ld l, a 
61cb 00				nop 
61cc 3e 17			ld a, 23 
61ce 67				ld h, a 
61cf			 
61cf 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
61d2			 
61d2			;	ld (chk_stund), hl	; stack points.... 
61d2 22 00 ef			ld (chk_stovr), hl 
61d5 22 ec e9			ld (chk_ret_und), hl 
61d8 22 aa e9			ld (chk_ret_ovr), hl 
61db 22 28 e9			ld (chk_loop_ovr), hl 
61de 22 26 e8			ld (chk_data_ovr), hl 
61e1 c9				ret 
61e2				 
61e2			check_stacks: 
61e2				; check all stack words 
61e2			 
61e2 e5				push hl 
61e3 d5				push de 
61e4			 
61e4			;	ld de,(chk_word) 
61e4			;	ld hl, (chk_stund)	; stack points.... 
61e4			;	if DEBUG_STK_FAULT 
61e4			;		DMARK "FAa" 
61e4			;		CALLMONITOR 
61e4			;	endif 
61e4			;	call cmp16 
61e4			;	jp z, .chk_faulta 
61e4			; 
61e4			;	ld de, sfaultsu 
61e4			;	jp .chk_fault 
61e4			 
61e4 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
61e7 ed 5b 9d e2		ld de,(chk_word) 
61eb				if DEBUG_STK_FAULT 
61eb					DMARK "FAb" 
61eb					CALLMONITOR 
61eb				endif 
61eb cd 04 0e			call cmp16 
61ee 28 06			jr z, .chk_fault1 
61f0 11 91 62			ld de, sfaultso 
61f3 c3 45 62			jp .chk_fault 
61f6			.chk_fault1:  
61f6 2a ec e9			ld hl, (chk_ret_und) 
61f9 ed 5b 9d e2		ld de,(chk_word) 
61fd				if DEBUG_STK_FAULT 
61fd					DMARK "FAU" 
61fd					CALLMONITOR 
61fd				endif 
61fd cd 04 0e			call cmp16 
6200 ca 09 62			jp z, .chk_fault2 
6203 11 a1 62			ld de, sfaultru 
6206 c3 45 62			jp .chk_fault 
6209			.chk_fault2:  
6209 2a aa e9			ld hl, (chk_ret_ovr) 
620c ed 5b 9d e2		ld de,(chk_word) 
6210				if DEBUG_STK_FAULT 
6210					DMARK "FA1" 
6210					CALLMONITOR 
6210				endif 
6210 cd 04 0e			call cmp16 
6213 ca 1c 62			jp z, .chk_fault3 
6216 11 af 62			ld de, sfaultro 
6219 c3 45 62			jp .chk_fault 
621c			.chk_fault3:  
621c 2a 28 e9			ld hl, (chk_loop_ovr) 
621f ed 5b 9d e2		ld de,(chk_word) 
6223				if DEBUG_STK_FAULT 
6223					DMARK "FA2" 
6223					CALLMONITOR 
6223				endif 
6223 cd 04 0e			call cmp16 
6226 ca 2f 62			jp z, .chk_fault4 
6229 11 c9 62			ld de, sfaultlo 
622c c3 45 62			jp .chk_fault 
622f			.chk_fault4:  
622f 2a 26 e8			ld hl, (chk_data_ovr) 
6232 ed 5b 9d e2		ld de,(chk_word) 
6236				if DEBUG_STK_FAULT 
6236					DMARK "FA3" 
6236					CALLMONITOR 
6236				endif 
6236 cd 04 0e			call cmp16 
6239 ca 42 62			jp z, .chk_fault5 
623c 11 e3 62			ld de, sfaultdo 
623f c3 45 62			jp .chk_fault 
6242			 
6242			 
6242			.chk_fault5:  
6242 d1				pop de 
6243 e1				pop hl 
6244			 
6244 c9				ret 
6245			 
6245 cd b9 0b		.chk_fault: 	call clear_display 
6248 3e 28				ld a, display_row_2 
624a cd cc 0b				call str_at_display 
624d 11 73 62				   ld de, .stackfault 
6250 3e 00				ld a, display_row_1 
6252 cd cc 0b				call str_at_display 
6255 11 6b ee				    ld de, debug_mark 
6258 3e 11				ld a, display_row_1+17 
625a cd cc 0b				call str_at_display 
625d cd dc 0b				call update_display 
6260			 
6260				; prompt before entering montior for investigating issue 
6260			 
6260 3e 78			ld a, display_row_4 
6262 11 38 19			ld de, endprog 
6265			 
6265 cd dc 0b			call update_display		 
6268			 
6268 cd be 1b			call next_page_prompt 
626b			 
626b d1				pop de 
626c e1				pop hl 
626d cd 8c 19				call monitor 
6270 c3 95 18				jp warmstart 
6273					;jp 0 
6273					;halt 
6273			 
6273			 
6273			 
6273 .. 00		.stackfault: 	db "Stack fault:",0 
6280			 
6280 .. 00		sfaultsu: 	db	"Stack under flow",0 
6291 .. 00		sfaultso: 	db	"Stack over flow",0 
62a1 .. 00		sfaultru:	db "RTS underflow",0 
62af .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
62c9 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
62e3 .. 00		sfaultdo:	db "DTS overflow", 0 
62f0			 
62f0			 
62f0			fault_dsp_under: 
62f0 11 02 63			ld de, .dsp_under 
62f3 c3 b2 63			jp .show_fault 
62f6			 
62f6			fault_rsp_under: 
62f6 11 10 63			ld de, .rsp_under 
62f9 c3 b2 63			jp .show_fault 
62fc			fault_loop_under: 
62fc 11 1e 63			ld de, .loop_under 
62ff c3 b2 63			jp .show_fault 
6302			 
6302 .. 00		.dsp_under: db "DSP Underflow",0 
6310 .. 00		.rsp_under: db "RSP Underflow",0 
631e .. 00		.loop_under: db "LOOP Underflow",0 
632d			 
632d			 
632d d5			type_faultn: 	push de 
632e e5					push hl 
632f cd b9 0b				call clear_display 
6332 11 59 63				   ld de, .typefaultn 
6335 3e 00				ld a, display_row_1 
6337 cd cc 0b				call str_at_display 
633a 11 6b ee				    ld de, debug_mark 
633d 3e 11				ld a, display_row_1+17 
633f cd cc 0b				call str_at_display 
6342 cd dc 0b				call update_display 
6345			 
6345				; prompt before entering montior for investigating issue 
6345			 
6345 3e 78			ld a, display_row_4 
6347 11 38 19			ld de, endprog 
634a			 
634a cd dc 0b			call update_display		 
634d			 
634d cd be 1b			call next_page_prompt 
6350			 
6350 e5					push hl 
6351 d5					push de 
6352 cd 8c 19				call monitor 
6355 c3 95 18				jp warmstart 
6358 76					halt 
6359			 
6359			 
6359 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6370			 
6370 d5			type_faults: 	push de 
6371 e5					push hl 
6372 cd b9 0b				call clear_display 
6375 11 9b 63				   ld de, .typefaults 
6378 3e 00				ld a, display_row_1 
637a cd cc 0b				call str_at_display 
637d 11 6b ee				    ld de, debug_mark 
6380 3e 11				ld a, display_row_1+17 
6382 cd cc 0b				call str_at_display 
6385 cd dc 0b				call update_display 
6388			 
6388				; prompt before entering montior for investigating issue 
6388			 
6388 3e 78			ld a, display_row_4 
638a 11 38 19			ld de, endprog 
638d			 
638d cd dc 0b			call update_display		 
6390			 
6390 cd be 1b			call next_page_prompt 
6393			 
6393 e1					pop hl 
6394 d1					pop de 
6395 cd 8c 19				call monitor 
6398 c3 95 18				jp warmstart 
639b			 
639b			 
639b .. 00		.typefaults: db "STR Type Expected TOS!",0 
63b2			 
63b2			.show_fault: 	 
63b2 d5					push de 
63b3 cd b9 0b				call clear_display 
63b6 d1					pop de 
63b7 3e 00				ld a, display_row_1 
63b9 cd cc 0b				call str_at_display 
63bc 11 6b ee				    ld de, debug_mark 
63bf 3e 11				ld a, display_row_1+17 
63c1 cd cc 0b				call str_at_display 
63c4 cd dc 0b				call update_display 
63c7			 
63c7				; prompt before entering montior for investigating issue 
63c7			 
63c7 3e 78			ld a, display_row_4 
63c9 11 38 19			ld de, endprog 
63cc			 
63cc cd dc 0b			call update_display		 
63cf			 
63cf cd be 1b			call next_page_prompt 
63d2			 
63d2 e1					pop hl 
63d3 d1					pop de 
63d4 cd 8c 19				call monitor 
63d7			; do a dump to cli and not warmstart so we preserve all of the uwords.  
63d7			; TODO Make optional fault restart to cli or warm boot? 
63d7					;jp warmstart 
63d7 c3 df 18				jp cli 
63da 76					halt 
63db			 
63db			; handle the auto run of code from files in storage 
63db			 
63db			 
63db			include "forth_startup.asm" 
63db			; Which startup method to use? 
63db			; 
63db			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
63db			; followed by loading of a list of scripts in eeprom 
63db			 
63db			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
63db			; from eeprom 
63db			 
63db			; Select with define in main stubs 
63db			 
63db			if STARTUP_V1 
63db				include "forth_startupv1.asm" 
63db			; Startup script loading version 1 
63db			 
63db			; If SE storage is available first stage is to use the selected file 
63db			; then go through the eeprom list 
63db			 
63db .. 00		sprompt1: db "Startup load...",0 
63eb .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
6401			 
6401			 
6401			 
6401			 
6401			forth_startup: 
6401 21 7c 4e			ld hl, startcmds 
6404 3e 00			ld a, 0 
6406 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6409			 
6409 e5			.start1:	push hl 
640a cd b9 0b			call clear_display 
640d 11 db 63			ld de, sprompt1 
6410 3e 00		        ld a, display_row_1 
6412 cd cc 0b			call str_at_display 
6415 11 eb 63			ld de, sprompt2 
6418 3e 28		        ld a, display_row_2 
641a cd cc 0b			call str_at_display 
641d e1				pop hl 
641e e5				push hl 
641f 5e				ld e,(hl) 
6420 23				inc hl 
6421 56				ld d,(hl) 
6422 3e 50		        ld a, display_row_3 
6424 cd cc 0b			call str_at_display 
6427 cd dc 0b			call update_display 
642a			 
642a			 
642a 3a e7 e6			ld a, (os_last_cmd) 
642d fe 00			cp 0 
642f 28 05			jr z, .startprompt 
6431 cd e5 0a			call delay250ms 
6434 18 24			jr .startdo 
6436				 
6436				 
6436			 
6436			.startprompt: 
6436			 
6436 3e 9f			ld a,display_row_4 + display_cols - 1 
6438 11 bc 1b		        ld de, endprg 
643b cd cc 0b			call str_at_display 
643e cd dc 0b			call update_display 
6441 cd f1 0a			call delay1s 
6444 cd b3 65			call cin_wait 
6447						 
6447 fe 2a			cp '*' 
6449 28 5e			jr z, .startupend1 
644b fe 23			cp '#' 
644d 20 07			jr nz, .startno 
644f 3e 01			ld a, 1 
6451 32 e7 e6			ld (os_last_cmd),a 
6454 18 04			jr .startdo 
6456 fe 31		.startno:	cp '1' 
6458 28 3a			jr z,.startnxt  
645a			 
645a				; exec startup line 
645a			.startdo:	 
645a e1				pop hl 
645b e5				push hl 
645c				 
645c 5e				ld e,(hl) 
645d 23				inc hl 
645e 56				ld d,(hl) 
645f eb				ex de,hl 
6460			 
6460 e5				push hl 
6461			 
6461 3e 00			ld a, 0 
6463				;ld a, FORTH_END_BUFFER 
6463 cd 4f 12			call strlent 
6466 23				inc hl   ; include zero term to copy 
6467 06 00			ld b,0 
6469 4d				ld c,l 
646a e1				pop hl 
646b 11 c1 e2			ld de, scratch 
646e ed b0			ldir 
6470			 
6470			 
6470 21 c1 e2			ld hl, scratch 
6473 cd 41 20			call forthparse 
6476 cd 81 20			call forthexec 
6479 cd 93 1f			call forthexec_cleanup 
647c			 
647c 3e 78			ld a, display_row_4 
647e 11 38 19			ld de, endprog 
6481			 
6481 cd dc 0b			call update_display		 
6484			 
6484 3a e7 e6			ld a, (os_last_cmd) 
6487 fe 00			cp 0 
6489 20 09			jr nz, .startnxt 
648b cd be 1b			call next_page_prompt 
648e cd b9 0b		        call clear_display 
6491 cd dc 0b			call update_display		 
6494			 
6494				; move onto next startup line? 
6494			.startnxt: 
6494			 
6494 cd e5 0a			call delay250ms 
6497 e1				pop hl 
6498			 
6498 23				inc hl 
6499 23				inc hl 
649a			 
649a e5				push hl 
649b 5e				ld e, (hl) 
649c 23				inc hl 
649d 56				ld d, (hl) 
649e e1				pop hl 
649f				; TODO replace 0 test 
649f			 
649f eb				ex de, hl 
64a0 cd 0f 0e			call ishlzero 
64a3			;	ld a,e 
64a3			;	add d 
64a3			;	cp 0    ; any left to do? 
64a3 eb				ex de, hl 
64a4 c2 09 64			jp nz, .start1 
64a7 18 01			jr .startupend 
64a9			 
64a9 e1			.startupend1: pop hl 
64aa			.startupend: 
64aa			 
64aa cd b9 0b			call clear_display 
64ad cd dc 0b			call update_display 
64b0 c9				ret 
64b1			if STORAGE_SE 
64b1			 
64b1			sprompt3: db "Loading from start-up file?:",0 
64b1			sprompt4: db "(Y=Any key/N=No)",0 
64b1			 
64b1			 
64b1			forth_autoload: 
64b1			 
64b1				; load block 0 of store 1 
64b1				 
64b1				ld a, $fe      ; bit 0 clear 
64b1				ld (spi_device), a 
64b1			 
64b1				call storage_get_block_0 
64b1			 
64b1				ld a, (store_page+STORE_0_AUTOFILE) 
64b1			 
64b1				cp 0 
64b1				ret z     ; auto start not enabled 
64b1			 
64b1				call clear_display 
64b1			 
64b1				; set bank 
64b1			 
64b1					ld a, (store_page+STORE_0_BANKRUN) 
64b1					ld (spi_device), a 
64b1			 
64b1				; get file id to load from and get the file name to display 
64b1			 
64b1					ld a, (store_page+STORE_0_FILERUN) 
64b1			 
64b1					ld l, 0 
64b1					ld h, a 
64b1					ld de, store_page 
64b1			 
64b1					if DEBUG_FORTH_WORDS 
64b1						DMARK "ASp" 
64b1						CALLMONITOR 
64b1					endif 
64b1					call storage_read 
64b1			 
64b1					if DEBUG_FORTH_WORDS 
64b1						DMARK "ASr" 
64b1						CALLMONITOR 
64b1					endif 
64b1			 
64b1					call ishlzero 
64b1					ret z             ; file not found 
64b1			 
64b1					ld a, display_row_2 + 10 
64b1					ld de, store_page+3 
64b1					call str_at_display 
64b1				 
64b1			; 
64b1			 
64b1				ld a, display_row_1+5 
64b1				ld de, sprompt3 
64b1				call str_at_display 
64b1				ld a, display_row_3+15 
64b1				ld de, sprompt4 
64b1				call str_at_display 
64b1			 
64b1				call update_display 
64b1			 
64b1				call cin_wait 
64b1				cp 'n' 
64b1				ret z 
64b1				cp 'N' 
64b1				ret z 
64b1			 
64b1				call delay1s 
64b1			 
64b1				ld a, (store_page+2) 
64b1				ld (store_openmaxext), a    ; save count of ext 
64b1				ld a, 1  
64b1				ld (store_openext), a    ; save count of ext 
64b1			 
64b1			.autof:  
64b1				ld l , a 
64b1				 
64b1				ld a, (store_page) 
64b1				ld h, a	 
64b1				ld de, store_page 
64b1					if DEBUG_FORTH_WORDS 
64b1						DMARK "ASl" 
64b1						CALLMONITOR 
64b1					endif 
64b1					call storage_read 
64b1				call ishlzero 
64b1				ret z 
64b1			;	jr z, .autoend 
64b1			 
64b1					if DEBUG_FORTH_WORDS 
64b1						DMARK "ASc" 
64b1						CALLMONITOR 
64b1					endif 
64b1				ld de, store_page+2 
64b1				ld a, display_row_4 
64b1				call str_at_display 
64b1			 
64b1				call update_display 
64b1				call delay250ms 
64b1			 
64b1			 
64b1			 
64b1				ld hl, store_page+2 
64b1				call forthparse 
64b1				call forthexec 
64b1				call forthexec_cleanup 
64b1			 
64b1				 
64b1				ld a, (store_openext) 
64b1				inc a 
64b1				ld (store_openext), a    ; save count of ext 
64b1			 
64b1				jr .autof 
64b1			;.autofdone: 
64b1			; 
64b1			;		if DEBUG_FORTH_WORDS 
64b1			;			DMARK "ASx" 
64b1			;			CALLMONITOR 
64b1			;		endif 
64b1			;;	call clear_display 
64b1			;	ret 
64b1			 
64b1			 
64b1			 
64b1			endif 
# End of file forth_startupv1.asm
64b1			endif 
64b1			if STARTUP_V2 
64b1				include "forth_startupv2.asm" 
64b1			endif 
64b1			 
# End of file forth_startup.asm
64b1			 
64b1			; eof 
# End of file forth_kernel.asm
64b1			;include "nascombasic.asm" 
64b1			 
64b1			 
64b1			; find out where the code ends if loaded into RAM (for SC114) 
64b1			;endofcode:  
64b1			;	nop 
64b1			 
64b1			 
64b1			; jump to nmi vector 
64b1			 
64b1			init_nmi: 
64b1 3e c9			ld a, $c9   ; RET 
64b3 32 72 ee			ld (nmi_vector), a 
64b6 c9				ret 
64b7			nmi: 
64b7 e5				push hl 
64b8 d5				push de 
64b9 c5				push bc 
64ba f5				push af 
64bb cd 72 ee			call nmi_vector 
64be f5				push af 
64bf c5				push bc 
64c0 d5				push de 
64c1 e5				push hl 
64c2 ed 4d			reti 
64c4			 
64c4			 
64c4			; eof 
64c4			 
# End of file main.asm
64c4			;include "firmware_lcd_4x40.asm" 
64c4			;;include "firmware_lcd_4x20.asm" 
64c4			include "firmware_cpm_display.asm" 
64c4			 
64c4			; Serial display interface for SC114 
64c4			 
64c4			 
64c4			display_row_1: equ 0 
64c4			display_row_2: equ display_row_1+display_cols 
64c4			display_row_3: equ display_row_2 + display_cols 
64c4			display_row_4: equ display_row_3 + display_cols 
64c4			 
64c4			kLCDWidth:  EQU display_cols             ;Width in characters 
64c4			kLCD_Line1: EQU 0x00  
64c4			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
64c4			; E1 
64c4			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
64c4			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
64c4			 
64c4			lcd_init: 
64c4				; no init as handled by the SCM bios 
64c4 c9				ret 
64c5			 
64c5			 
64c5			; low level functions for direct screen writes 
64c5			 
64c5			; output char at pos? 
64c5			fLCD_Str: 
64c5			        ;out (SC114_SIO_1_OUT),a 
64c5 c5				push bc 
64c6 d5				push de 
64c7 5f				ld e, a 
64c8			; TODO Replace with CP/M BIOS call 
64c8 0e 02			ld c, $02 
64ca cd 05 00			call 5 
64cd d1				pop de 
64ce c1				pop bc 
64cf c9				ret 
64d0			 
64d0			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
64d0			fLCD_Pos: 
64d0				; use ASCII escape to position 
64d0			        ;out (SC114_SIO_1_OUT),a 
64d0 c5				push bc 
64d1 d5				push de 
64d2 5f				ld e, a 
64d3 0e 02			ld c, $02 
64d5			; TODO Replace with CP/M BIOS call 
64d5 cd 05 00			call 5 
64d8 d1				pop de 
64d9 c1				pop bc 
64da			 
64da c9				ret 
64db			 
64db			; output char at pos 
64db			fLCD_Data: 
64db			      ;  out (SC114_SIO_1_OUT),a 
64db c5				push bc 
64dc d5				push de 
64dd 0e 02			ld c, $02 
64df 5f				ld e, a 
64e0			; TODO Replace with CP/M BIOS call 
64e0 cd 05 00			call 5 
64e3 d1				pop de 
64e4 c1				pop bc 
64e5			 
64e5 c9				ret 
64e6			 
64e6			; ascii cls  
64e6			 
64e6 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
64ea			 
64ea 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
6501			;.clscpm: db 3, $3c,"$" 
6501			 
6501			; write the frame buffer given in hl to hardware  
6501			write_display: 
6501			 
6501			API: equ 0 
6501			 
6501			if API 
6501				push bc 
6501				ld b, 4 
6501			 
6501			        ld (display_write_tmp), hl 	  
6501			 
6501				; clear and home cursor 
6501			 
6501				ld c, 9 
6501				ld de, .cls 
6501			; TODO Replace with CP/M BIOS call 
6501				call 5 
6501			 
6501			 
6501			.writeln: 
6501			 
6501				ld de, (display_write_tmp) 
6501				ld c, 6 
6501			; TODO Replace with CP/M BIOS call 
6501				rst $30 
6501				ld c, 7 
6501				rst $30 
6501			 
6501				ld hl, (display_write_tmp) 
6501				ld de, display_cols 
6501				add hl,de 
6501				ld (display_write_tmp),hl 
6501			 
6501				djnz  .writeln 
6501			 
6501				pop bc 
6501			 
6501			 
6501				ret 
6501			endif 
6501 e5				push hl 
6502 c5				push bc 
6503 d5				push de 
6504			 
6504			;	ld c, 2 
6504			;	;ld de, .cls 
6504			;	ld a, 27 
6504			;	rst $30 
6504			;	ld c, 2 
6504			;	;ld de, .cls 
6504			;	ld a, '[' 
6504			;	rst $30 
6504			; 
6504			;	ld c, 2 
6504			;	;ld de, .cls 
6504			;	ld a, 'H' 
6504			;	rst $30 
6504			; 
6504			 
6504			 
6504			; lots of CR/LF 
6504			;	ld c, 9 
6504			;	ld de, .clscpm 
6504			;	call 5 
6504			 
6504			; xterm cls 
6504 0e 02			ld c, 2 
6506 1e 1b			ld e, 27 
6508 cd 05 00			call 5 
650b			; cls causes too much flicker 
650b			;	ld c, 2 
650b			;	ld e, 'c' 
650b			;	call 5 
650b			 
650b			; use xterm home instead 
650b 0e 02			ld c, 2 
650d 1e 5b			ld e, '[' 
650f cd 05 00			call 5 
6512 0e 02			ld c, 2 
6514 1e 48			ld e, 'H' 
6516 cd 05 00			call 5 
6519			LLL: equ 0 
6519			 
6519			if LLL 
6519			 
6519				ld c, 2 
6519				;ld de, .cls 
6519				ld e, 27 
6519			; TODO Replace with CP/M BIOS call 
6519				call 5 
6519			 
6519			 
6519				ld c, 2 
6519				;ld de, .cls 
6519				ld e, '[' 
6519			; TODO Replace with CP/M BIOS call 
6519				call 5 
6519				ld c, 2 
6519				;ld de, .cls 
6519				ld e, '2' 
6519			; TODO Replace with CP/M BIOS call 
6519				call 5 
6519				ld c, 2 
6519				;ld de, .cls 
6519				ld e, 'J' 
6519			; TODO Replace with CP/M BIOS call 
6519				call 5 
6519			 
6519			endif 
6519			 
6519 d1				pop de 
651a c1				pop bc 
651b e1				pop hl 
651c			 
651c			 
651c 22 c9 eb		        ld (display_write_tmp), hl 	  
651f 3e 00			ld a, kLCD_Line1 
6521			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
6521 06 28			ld b, display_cols 
6523 ed 5b c9 eb		ld de, (display_write_tmp) 
6527 cd aa 65			call write_len_string 
652a				 
652a			 
652a e5			push hl 
652b d5			push de 
652c c5			push bc 
652d 0e 02			ld c, 2 
652f 1e 0a			ld e, 10 
6531 cd 05 00			call 5 
6534 0e 02			ld c, 2 
6536 1e 0d			ld e, 13 
6538 cd 05 00			call 5 
653b			; TODO Replace with CP/M BIOS call 
653b				;rst $30 
653b c1			pop bc 
653c d1			pop de 
653d e1			pop hl 
653e			 
653e				 
653e 2a c9 eb			ld hl, (display_write_tmp) 
6541 11 28 00			ld de, display_cols 
6544 19				add hl,de 
6545 22 c9 eb			ld (display_write_tmp),hl 
6548			 
6548				 
6548 3e 28			ld a, kLCD_Line2 
654a			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
654a 06 28			ld b, display_cols 
654c ed 5b c9 eb		ld de, (display_write_tmp) 
6550 cd aa 65			call write_len_string 
6553				 
6553 2a c9 eb			ld hl, (display_write_tmp) 
6556 11 28 00			ld de, display_cols 
6559 19				add hl,de 
655a 22 c9 eb			ld (display_write_tmp),hl 
655d			 
655d e5			push hl 
655e d5			push de 
655f c5			push bc 
6560 0e 07			ld c, 7 
6562			; TODO Replace with CP/M BIOS call 
6562				;rst $30 
6562 0e 02			ld c, 2 
6564 1e 0a			ld e, 10 
6566 cd 05 00			call 5 
6569 0e 02			ld c, 2 
656b 1e 0d			ld e, 13 
656d cd 05 00			call 5 
6570 c1			pop bc 
6571 d1			pop de 
6572 e1			pop hl 
6573			 
6573				 
6573 3e 50			ld a, kLCD_Line3 
6575			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
6575 06 28			ld b, display_cols 
6577 ed 5b c9 eb		ld de, (display_write_tmp) 
657b cd aa 65			call write_len_string 
657e				 
657e 2a c9 eb			ld hl, (display_write_tmp) 
6581 11 28 00			ld de, display_cols 
6584 19				add hl,de 
6585 22 c9 eb			ld (display_write_tmp),hl 
6588			 
6588 e5			push hl 
6589 d5			push de 
658a c5			push bc 
658b 0e 07			ld c, 7 
658d			; TODO Replace with CP/M BIOS call 
658d				;rst $30 
658d 0e 02			ld c, 2 
658f 1e 0a			ld e, 10 
6591 cd 05 00			call 5 
6594 0e 02			ld c, 2 
6596 1e 0d			ld e, 13 
6598 cd 05 00			call 5 
659b c1			pop bc 
659c d1			pop de 
659d e1			pop hl 
659e			 
659e				 
659e 3e 78			ld a, kLCD_Line4 
65a0			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
65a0 06 28			ld b, display_cols 
65a2 ed 5b c9 eb		ld de, (display_write_tmp) 
65a6 cd aa 65			call write_len_string 
65a9 c9					ret 
65aa			 
65aa			 
65aa				; write out a fixed length string given in b from de 
65aa			 
65aa 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
65ab cd db 64		            CALL fLCD_Data      ;Write character to display 
65ae 13				inc de 
65af 10 f9			djnz write_len_string 
65b1 c9				ret 
65b2			 
65b2			 
65b2			; eof 
# End of file firmware_cpm_display.asm
65b2			;include "firmware_key_5x10.asm" 
65b2			;;include "firmware_key_4x10.asm" 
65b2			include "firmware_key_cpm.asm" 
65b2			; Serial keyboard interface for SC114 
65b2			 
65b2			 
65b2			key_init: 
65b2				; no init as handled by the SCM bios 
65b2 c9				ret 
65b3			 
65b3			 
65b3			cin_wait: 
65b3			;	ld a, 0 
65b3			;	ret 
65b3			 
65b3				;in a,(SC114_SIO_1_IN) 
65b3			        ; Use SCM API to get from whatever console device we are using 
65b3			 
65b3			; TODO Replace with CP/M BIOS call 
65b3 c5				push bc 
65b4 0e 01			ld c, $01 
65b6 cd 05 00			call 5 
65b9 c1				pop bc 
65ba c9				ret 
65bb			 
65bb			cin: 
65bb			 
65bb			 
65bb c5				push bc 
65bc			 
65bc				; any key waiting to process? 
65bc			; TODO Replace with CP/M BIOS call 
65bc 0e 06			ld c, $06 
65be cd 05 00			call 5 
65c1 28 0d			jr z, .cin_skip 
65c3			 
65c3				; yep, get it 
65c3			 
65c3 0e 01			ld c, $01 
65c5			; TODO Replace with CP/M BIOS call 
65c5 cd 05 00			call 5 
65c8			 
65c8 fe 7f			cp $7f     ; back space 
65ca 20 02			jr nz, .skipbs 
65cc 3e 08			ld a, KEY_BS 
65ce			.skipbs: 
65ce			 
65ce c1				pop bc 
65cf c9				ret 
65d0			.cin_skip: 
65d0 3e 00			ld a, 0 
65d2 c1				pop bc 
65d3 c9				ret 
65d4			 
65d4			 
65d4			 
65d4			 
# End of file firmware_key_cpm.asm
65d4			endofcode:  
65d4			baseram:  
65d4 00				nop 
65d5			 
65d5			heap_start: equ baseram+15  ; Starting address of heap 
65d5			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
65d5			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
65d5			;VDU:  EQU     endofcode           ; BASIC Work space 
65d5			; eof 
65d5			 
# End of file os_mega_cpm.asm
65d5
