# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 40 97			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			 
8003 .. 00		buildtime: db   "Build: 00/00/00 00:00:00",0 
801c			 
801c			 
801c			;        nop  
801c			;        nop 
801c			;;	org 05h		; null out bdos call 
801c			; 
801c			;        nop  
801c			;        nop  
801c			;        nop 
801c			;;	org 08h 
801c			;;; 
801c			;;	jp cin		; rst 8 - char in 
801c			;;; 
801c			; 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;        nop 
801c			;	org 010h 
801c			;; 
801c			;	jp cout		; rest 010h  - char out 
801c			;; 
801c			;	org 01bh   
801c			; 
801c			;	;jp  		; rst 01bh   - write string to display 
801c			;	jp str_at_display 
801c			; 
801c			; 
801c			;	org 020h 
801c			; 
801c			;	; jp		 ; rst 020h - read char at screen location 
801c			; 
801c			;	org 028h 
801c			 
801c				; jp		 ; rst 028h  - storage i/o 
801c			 
801c			; 	org 030h 
801c			;	jp break_point_state 
801c			  
801c			; $30  
801c			; org 038h 
801c			; $38 
801c			 
801c			; TODO any more important entry points to add to jump table for easier coding use? 
801c			 
801c			 
801c			include "firmware.asm" 
801c			  
801c			; main constants (used here and in firmware)  
801c			  
801c			; TODO have page 0 of storage as bios  
801c			  
801c			Device_A: equ 0h  
801c			Device_B: equ 040h          ; Sound  
801c			  
801c			if BASE_KEV  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_SC114  
801c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			; TODO fixup for CPM  
801c			Device_C: equ 080h          ; Storage and ext cart devices  
801c			endif  
801c			  
801c			Device_D: equ 0c0h             ; Keyboard and LCD  
801c			  
801c			; Odd specific debug points for testing hardware dev  
801c			  
801c			DEBUG_SOUND: equ 1  
801c			DEBUG_STK_FAULT: equ 0  
801c			DEBUG_INPUT: equ 0     ; Debug input entry code  
801c			DEBUG_KEYCINWAIT: equ 0  
801c			DEBUG_KEYCIN: equ 0  
801c			DEBUG_KEY: equ 0  
801c			DEBUG_KEY_MATRIX: equ 0  
801c			DEBUG_STORECF: equ 0  
801c			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
801c			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
801c			DEBUG_SPI: equ 0    ; low level spi tests  
801c			  
801c			; Enable many break points  
801c			  
801c			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
801c			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
801c			DEBUG_FORTH_JP: equ 0    ; 4  
801c			DEBUG_FORTH_MALLOC: equ 0  
801c			DEBUG_FORTH_MALLOC_INT: equ 0  
801c			DEBUG_FORTH_DOT: equ 0  
801c			DEBUG_FORTH_DOT_WAIT: equ 0  
801c			DEBUG_FORTH_MATHS: equ 0  
801c			DEBUG_FORTH_TOK: equ 0    ; 4  
801c			DEBUG_FORTH_PARSE: equ 0    ; 3  
801c			DEBUG_FORTH: equ 0  ;2  
801c			DEBUG_FORTH_WORDS: equ 1   ; 1  
801c			DEBUG_FORTH_PUSH: equ 1   ; 1  
801c			DEBUG_FORTH_UWORD: equ 1   ; 1  
801c			  
801c			; Enable key point breakpoints  
801c			  
801c			DEBUG_FORTH_DOT_KEY: equ 0  
801c			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
801c			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
801c			  
801c			; Debug stack imbalances  
801c			  
801c			ON: equ 1  
801c			OFF: equ 0  
801c			  
801c			DEBUG_STACK_IMB: equ 0  
801c			STACK_IMB_STORE: equ 20  
801c			  
801c			; House keeping and protections  
801c			  
801c			DEBUG_FORTH_STACK_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_GUARD: equ 1  
801c			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
801c			FORTH_ENABLE_FREE: equ 0  
801c			FORTH_ENABLE_MALLOCFREE: equ 1  
801c			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
801c			FORTH_ENABLE_FLOATMATH: equ 0  
801c			  
801c			  
801c			CALLMONITOR: macro  
801c				call break_point_state  
801c				endm  
801c			  
801c			MALLOC_1: equ 1        ; from dk88   
801c			MALLOC_2: equ 0           ; broke  
801c			MALLOC_3: equ 0           ; really broke  
801c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
801c			  
801c			if BASE_KEV   
801c			stacksize: equ 256  
801c			  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 512  
801c			endif  
801c			if BASE_SC114  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			if BASE_CPM  
801c			;tos:	equ 0f000h  
801c			stacksize: equ 256  
801c			STACK_RET_SIZE: equ 64  
801c			STACK_LOOP_SIZE: equ 128  
801c			STACK_DATA_SIZE: equ 256  
801c			endif  
801c			  
801c			;if STORAGE_SE == 0  
801c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
801c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
801c			;endif  
801c			  
801c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
801c			  
801c			STORE_0_AUTORUN: equ $20  
801c			  
801c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
801c			  
801c			STORE_0_AUTOFILE: equ $21  
801c			STORE_0_BANKRUN: equ $23  
801c			STORE_0_FILERUN: equ $24  
801c			  
801c			; Block 0 offsets for settings  
801c			  
801c			; if set then skip prompt for start up and accept all  
801c			  
801c			STORE_0_QUICKSTART: equ $25  
801c			  
801c			; Blocks where directory table is held  
801c			  
801c			; Reducing the number of entries increases the max file size  
801c			  
801c			;STORE_DIR_START: equ 1  
801c			;STORE_DIR_END: equ 33  
801c			  
801c			; Blocks from where file data is stored  
801c			  
801c			;STORE_DATA_START: equ STORE_DIR_END + 1  
801c			  
801c			; Block indicators (<32 are data files)  
801c			  
801c			;STORE_BLOCK_CFG: equ $8f       ; config block  
801c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
801c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
801c			;STORE_BLOCK_FREE: equ $85       ; data block free  
801c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
801c			  
801c			  
801c			  
801c			; Directory entry flags  
801c			  
801c			;STORE_DIR_FREE: equ 0  
801c			;STORE_DIR_FILE:  equ 1  
801c			  
801c			; Structure offsets to directory entries  
801c			;STORE_DE_FLAG: equ 0  
801c			;STORE_DE_MAXEXT: equ 1  
801c			;STORE_DE_FILENAME: equ 2  
801c			  
801c			; Structure offsets to block 0  
801c			  
801c			;STORE_BK0_ISFOR: equ 1  
801c			;STORE_BK0_LABEL: equ 3  
801c			  
801c			; memory allocation   
801c			  
801c			chk_stund: equ tos+2           ; underflow check word  
801c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
801c			  
801c			; keyscan table needs rows x cols buffer  
801c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
801c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
801c			  
801c			keyscan_table_row1: equ chk_stovr -key_cols-1  
801c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
801c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
801c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
801c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
801c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
801c			keyscan_scancol: equ keyscan_table-key_cols  
801c			;keyscan_table_len: equ key_rows*key_cols  
801c			;keybufptr: equ keyscan_table - 2  
801c			;keysymbol: equ keybufptr - 1  
801c			key_held: equ keyscan_scancol-1	; currently held  
801c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
801c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
801c			key_fa: equ key_repeat_ct -1 ;  
801c			key_fb: equ key_fa -1 ;  
801c			key_fc: equ key_fb -1 ;  
801c			key_fd: equ key_fc -1 ;  
801c			key_face_held: equ key_fd - 1   
801c			  
801c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
801c			  
801c			hardware_config: equ key_face_held - 10  
801c			  
801c			; hardware config switches  
801c			; TODO add bitmasks on includes for hardware  
801c			; high byte for expansion ids  
801c			;     0000 0000  no card inserted  
801c			;     0000 0001  storage card inserted  
801c			;     0000 0010  spi sd card active  
801c			  
801c			;       
801c			; low byte:  
801c			;     0000 0001   4x4 keypad  
801c			;     0000 0010   full keyboard  
801c			;     0000 0011   spi/ext keyboard  
801c			;     0000 0100   20x4 lcd  
801c			;     0000 1000   40x4 lcd  
801c			;     0000 1100   spi/ext display  
801c			;     0001 0000   ide interface available  
801c			  
801c			hardware_word: equ hardware_config - 2  
801c			  
801c			; debug marker - optional display of debug point on the debug screens  
801c			  
801c			debug_mark: equ hardware_word - 4  
801c			  
801c			; input_str vars  
801c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
801c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
801c			input_size: equ input_start -1  ; number of chars  
801c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
801c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
801c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
801c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
801c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
801c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
801c			input_len: equ input_cur_onoff - 5 ; length of current input  
801c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
801c			  
801c			CUR_BLINK_RATE: equ 15  
801c			  
801c			key_actual_pressed: equ input_cursor - 1   
801c			key_symbol: equ key_actual_pressed - 1   
801c			key_shift: equ key_symbol - 1   
801c			  
801c			; Display allocation  
801c			  
801c			;display_rows: equ 4     ; move out to mini and mega files  
801c			;display_cols: equ 20  
801c			  
801c			display_fb_len: equ display_rows*display_cols  
801c			  
801c			; primary frame buffer     
801c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
801c			; working frame buffers  
801c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
801c			display_fb3: equ  display_fb1-display_fb_len - 1  
801c			display_fb2: equ  display_fb3-display_fb_len - 1  
801c			;  
801c			; pointer to active frame buffer  
801c			display_fb_active: equ display_fb2 - 2  
801c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
801c			display_write_tmp: equ display_lcde1e2 - 2  
801c			  
801c			  
801c			;  
801c			  
801c			;; can load into de directory  
801c			cursor_col: equ display_write_tmp-1  
801c			cursor_row: equ cursor_col-1  
801c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
801c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
801c			  
801c			; maths vars  
801c			  
801c			LFSRSeed: equ cursor_shape -20   
801c			randData: equ LFSRSeed - 2  
801c			xrandc: equ randData - 2  
801c			stackstore: equ xrandc - 2  
801c			seed1: equ  stackstore -2   
801c			seed2: equ seed1 - 2  
801c			  
801c			; cf storage vars  
801c			  
801c			iErrorNum:  equ seed2-1         ;Error number  
801c			iErrorReg:  equ iErrorNum -1              ;Error register  
801c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
801c			  
801c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
801c			  
801c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
801c			  
801c			store_page: equ store_bank_active-STORE_BLOCK_LOG            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
801c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
801c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
801c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
801c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
801c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
801c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
801c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
801c			store_tmpid: equ store_tmp3 - 1		; page temp id  
801c			store_tmpext: equ store_tmpid - 1		; file extent temp  
801c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
801c			store_openext: equ store_readcont - 1		; file extent of current opened file for read  
801c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
801c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
801c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
801c			;  
801c			; spi vars  
801c			  
801c			  
801c			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
801c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
801c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
801c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
801c			spi_device_id: equ spi_device - 1    ; human readable bank number  
801c			  
801c			;;;;; forth cli params  
801c			  
801c			; TODO use a different frame buffer for forth???  
801c			  
801c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
801c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
801c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
801c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
801c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
801c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
801c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
801c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
801c			  
801c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
801c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
801c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
801c			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
801c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
801c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
801c			  
801c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
801c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
801c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
801c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
801c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
801c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
801c			  
801c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
801c			  
801c			; os/forth token vars  
801c			  
801c			os_last_cmd: equ os_var_array-255  
801c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
801c			os_current_i: equ os_cli_cmd-2  
801c			os_cur_ptr: equ os_current_i-2  
801c			os_word_scratch: equ os_cur_ptr-30  
801c			os_tok_len: equ os_word_scratch - 2  
801c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
801c			os_tok_malloc: equ os_tok_ptr - 2  
801c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
801c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
801c			execscratch: equ os_input-255        ; exec cmd eval buffer  
801c			scratch: equ execscratch-255  
801c			  
801c			  
801c			; temp locations for new word processing to save on adding more   
801c			  
801c			os_new_malloc: equ scratch-2  
801c			os_new_parse_len: equ os_new_malloc - 2  
801c			os_new_word_len: equ os_new_parse_len - 2  
801c			os_new_work_ptr: equ os_new_word_len - 2  
801c			os_new_src_ptr: equ os_new_work_ptr - 2  
801c			os_new_exec: equ os_new_src_ptr - 2  
801c			os_new_exec_ptr: equ os_new_exec - 2  
801c			  
801c			; resume memory alloocations....  
801c			  
801c			os_view_disable: equ os_new_exec_ptr - 1  
801c			os_view_af: equ os_view_disable - 2  
801c			os_view_hl: equ os_view_af -2  
801c			os_view_de: equ os_view_hl - 2  
801c			os_view_bc: equ os_view_de - 2  
801c			  
801c			; stack checksum word  
801c			if DEBUG_STACK_IMB  
801c				curframe: equ  os_view_de - 5  
801c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
801c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			else  
801c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
801c			endif  
801c			  
801c			; with data stack could see memory filled with junk. need some memory management   
801c			; malloc and free entry points added  
801c			  
801c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
801c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			;heap_end: equ free_list-1  ; Starting address of heap  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			  
801c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
801c			heap_end: equ chk_word-1  ; Starting address of heap  
801c			  
801c			  
801c			;if BASE_KEV   
801c			;heap_start: equ 0800eh  ; Starting address of heap  
801c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;heap_start: equ baseram+15  ; Starting address of heap  
801c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
801c			;endif  
801c			  
801c			  
801c			;;;;  
801c			  
801c			  
801c			; change below to point to last memory alloc above  
801c			topusermem:  equ   heap_start  
801c			  
801c			;if BASE_KEV   
801c			;baseusermem: equ 08000h  
801c			;endif  
801c			  
801c			;if BASE_SC114  
801c			;;aseusermem:     equ    12  
801c			;baseusermem:     equ    prompt  
801c			;;baseusermem:     equ    endofcode  
801c			;endif  
801c			  
801c			  
801c			; **********************************************************************  
801c			; **  Constants  
801c			; **********************************************************************  
801c			  
801c			; Constants used by this code module  
801c			kDataReg:   EQU Device_D           ;PIO port A data register  
801c			kContReg:   EQU Device_D+2           ;PIO port A control register  
801c			  
801c			  
801c			portbdata:  equ Device_D+1    ; port b data  
801c			portbctl:   equ Device_D+3    ; port b control  
801c			  
801c			  
801c			;KEY_SHIFT:   equ 5  
801c			;KEY_SYMBOLSHIFT:  equ 6  
801c			  
801c			KEY_SHIFTLOCK: equ 4  
801c			  
801c			  
801c			KEY_UP: equ 5  
801c			KEY_NEXTWORD: equ 6  
801c			KEY_PREVWORD: equ 7  
801c			KEY_BS: equ 8  
801c			KEY_TAB:  equ 9  
801c			KEY_DOWN: equ 10  
801c			KEY_LEFT: equ 11  
801c			KEY_RIGHT: equ 12  
801c			KEY_CR:   equ 13  
801c			KEY_HOME: equ 14  
801c			KEY_END: equ 15  
801c			  
801c			KEY_F1: equ 16  
801c			KEY_F2: equ 17  
801c			KEY_F3: equ 18  
801c			KEY_F4: equ 19  
801c			  
801c			KEY_F5: equ 20  
801c			KEY_F6: equ 21  
801c			KEY_F7: equ 22  
801c			KEY_F8: equ 23  
801c			  
801c			KEY_F9: equ 24  
801c			KEY_F10: equ 25  
801c			KEY_F11: equ 26  
801c			KEY_F12: equ 27  
801c			  
801c			;if DEBUG_KEY  
801c			;	KEY_MATRIX_NO_PRESS: equ '.'  
801c			;	KEY_SHIFT:   equ '.'  
801c			;	KEY_SYMBOLSHIFT:  equ '.'  
801c			;else  
801c				KEY_SHIFT:   equ '~'  
801c				KEY_SYMBOLSHIFT:  equ '~'  
801c				KEY_MATRIX_NO_PRESS: equ '~'  
801c			;endi  
801c			  
801c			  
801c			  
801c			  
801c			; Macro to make adding debug marks easier  
801c			  
801c			DMARK: macro str  
801c				push af  
801c				ld a, (.dmark)  
801c				ld (debug_mark),a  
801c				ld a, (.dmark+1)  
801c				ld (debug_mark+1),a  
801c				ld a, (.dmark+2)  
801c				ld (debug_mark+2),a  
801c				jr .pastdmark  
801c			.dmark: db str  
801c			.pastdmark: pop af  
801c			  
801c			endm  
801c			  
801c			  
801c			; macro to detect for stack imbalances  
801c			  
801c			include "stackimbal.asm"  
801c			; Macro and code to detect stock imbalances 
801c			 
801c			SPPUSH: equ 0 
801c			 
801c			; Add a stack frame which can be checked before return 
801c			 
801c			STACKFRAME: macro onoff frame1 frame2 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c						exx 
801c			 
801c						ld de, frame1 
801c						ld a, d 
801c						ld hl, curframe 
801c						call hexout 
801c						ld a, e 
801c						ld hl, curframe+2 
801c						call hexout 
801c			  
801c						ld hl, frame1 
801c						push hl 
801c						ld hl, frame2 
801c						push hl 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			endm 
801c			 
801c			STACKFRAMECHK: macro onoff frame1 frame2 
801c			 
801c					 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						exx 
801c						; check stack frame SP 
801c			 
801c						ld hl, frame2 
801c						pop de   ; frame2 
801c			 
801c						call cmp16 
801c						jr nz, .spnosame 
801c						 
801c			 
801c						ld hl, frame1 
801c						pop de   ; frame1 
801c			 
801c						call cmp16 
801c						jr z, .spfrsame 
801c			 
801c						.spnosame: call showsperror 
801c			 
801c						.spfrsame: nop 
801c			 
801c						exx 
801c					endif 
801c					 
801c				endif 
801c			 
801c			 
801c			endm 
801c			 
801c			 
801c			; for a sub routine, wrap SP collection and comparisons 
801c			 
801c			; Usage: 
801c			; 
801c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
801c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
801c			 
801c			SAVESP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c						; save current SP 
801c			 
801c						ld (store_sp+(storeword*4)), sp 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			CHECKSP: macro onoff storeword 
801c			 
801c				if DEBUG_STACK_IMB 
801c					if onoff 
801c			 
801c						; save SP after last save 
801c				 
801c						ld (store_sp+(storeword*4)+2), sp 
801c			 
801c						push hl 
801c						ld hl, store_sp+(storeword*4) 
801c						call check_stack_sp  
801c						pop hl 
801c			 
801c			 
801c					endif 
801c					 
801c				endif 
801c			 
801c			endm 
801c			 
801c			if DEBUG_STACK_IMB 
801c			 
801c			check_stack_sp: 
801c					push de 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					push de 
801c			 
801c			 
801c					ld e, (hl) 
801c					inc hl 
801c					ld d, (hl) 
801c					inc hl 
801c			 
801c					pop hl 
801c			 
801c			 
801c					; check to see if the same 
801c			 
801c					call cmp16 
801c					jr z, .spsame 
801c			 
801c					; not same 
801c			 
801c					call showsperror 
801c			.spsame: 
801c			 
801c					pop de 
801c			 
801c					ret 
801c			 
801c			.sperr:  db "Stack imbalance",0 
801c			 
801c			 
801c			showsperror: 
801c			 
801c			 
801c				push hl 
801c				push af 
801c				push de 
801c				call clear_display 
801c				ld de, .sperr 
801c				ld a,0 
801c			;	ld de,os_word_scratch 
801c				call str_at_display 
801c				ld a, display_row_1+17 
801c				ld de, debug_mark 
801c				call str_at_display 
801c				ld a, 0 
801c				ld (curframe+4),a 
801c				ld hl, curframe 
801c				ld de, os_word_scratch 
801c				ld a, display_row_4 
801c				call str_at_display 
801c				call update_display 
801c				;call break_point_state 
801c				call cin_wait 
801c			 
801c				ld a, ' ' 
801c				ld (os_view_disable), a 
801c				pop de	 
801c				pop af 
801c				pop hl 
801c				CALLMONITOR 
801c				ret 
801c			 
801c			endif 
801c			 
801c			 
801c			 
801c			; eof 
# End of file stackimbal.asm
801c			  
801c			;TODO macro to calc col and row offset into screen  
801c			  
801c			  
801c			  
801c			hardware_init:  
801c			  
801c				  
801c			  
801c					;ld a, 0  
801c					;ld (hardware_diag), a  
801c			  
801c					; clear all the buffers  
801c			  
801c 21 16 ed				ld hl, display_fb1  
801f 22 d2 eb				ld (display_fb_active), hl  
8022			  
8022 cd 6f 8a				call clear_display  
8025			  
8025 21 d4 eb				ld hl, display_fb2  
8028 22 d2 eb				ld (display_fb_active), hl  
802b			  
802b cd 6f 8a				call clear_display  
802e			  
802e					; init primary frame buffer area  
802e 21 b7 ed				ld hl, display_fb0  
8031 22 d2 eb				ld (display_fb_active), hl  
8034			  
8034 cd 6f 8a				call clear_display  
8037			  
8037			  
8037 cd ee d9				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
803a			  
803a cd 90 da			call key_init  
803d cd 9f 80			call storage_init  
8040			  
8040				; setup malloc functions  
8040			  
8040				if MALLOC_1  
8040 cd 3f 91				call  heap_init  
8043				endif  
8043				if MALLOC_4  
8043					call  heap_init  
8043				endif  
8043			  
8043				; init sound hardware if present  
8043			  
8043				if SOUND_ENABLE  
8043					call sound_init  
8043				endif  
8043			  
8043				; lcd test sequence  
8043					  
8043 cd 92 8a			call update_display  
8046 cd ec 89			call delay1s  
8049 3e 2b			ld a,'+'  
804b cd 74 8a			call fill_display  
804e cd 92 8a			call update_display  
8051 cd ec 89			call delay1s  
8054 3e 2a			ld a,'*'  
8056 cd 74 8a			call fill_display  
8059 cd 92 8a			call update_display  
805c cd ec 89			call delay1s  
805f 3e 2d			ld a,'-'  
8061 cd 74 8a			call fill_display  
8064 cd 92 8a			call update_display  
8067 cd ec 89			call delay1s  
806a			  
806a			; boot splash screen  
806a			if display_cols == 20	  
806a			        ld a, display_row_1    
806a			else  
806a 3e 0a		        ld a, display_row_1 +10   
806c			endif  
806c 11 73 96			ld de, prom_bootmsg  
806f cd 82 8a			call str_at_display  
8072 cd 92 8a			call update_display  
8075			  
8075			  
8075 cd ec 89			call delay1s  
8078 cd ec 89			call delay1s  
807b			if display_cols == 20	  
807b			            LD   A, display_row_3+2  
807b			else  
807b 3e 5c		            LD   A, display_row_3+12  
807d			endif  
807d 11 88 96			ld de, prom_bootmsg1  
8080 cd 82 8a			call str_at_display  
8083 cd 92 8a			call update_display  
8086 cd ec 89			call delay1s  
8089 cd ec 89			call delay1s  
808c			  
808c			;	ld a, display_row_4+3  
808c			;	ld de, bootmsg2  
808c			;	call str_at_display  
808c			;	call update_display  
808c			;	call delay1s  
808c			;	call delay1s  
808c			  
808c			; debug mark setup  
808c			  
808c 3e 5f		ld a, '_'  
808e 32 71 ee		ld (debug_mark),a  
8091 32 72 ee		ld (debug_mark+1),a  
8094 32 73 ee		ld (debug_mark+2),a  
8097 3e 00		ld a,0  
8099 32 74 ee		ld (debug_mark+3),a  
809c			  
809c c9					ret  
809d			  
809d			  
809d			;bootmsg2:	db "Firmware v0.1",0  
809d			  
809d			; a 4x20 lcd  
809d			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
809d			  
809d			;if display_cols == 20  
809d			;	include "firmware_lcd_4x20.asm"  
809d			;endif  
809d			  
809d			;if display_cols == 40  
809d			;	include "firmware_lcd_4x40.asm"  
809d			;endif  
809d			  
809d			;  
809d			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
809d			; TODO abstract the bit bang video out interface for dual display  
809d			; TODO wire video out to tx pin on rc2014 bus  
809d			  
809d			; must supply cin, and cin_wait for low level hardware abstraction   
809d			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
809d			; test scancode  
809d			  
809d			;;;;;  
809d			;;;  
809d			; Moved out to mini and maxi versions  
809d			;  
809d			; include "firmware_key_4x4.asm"  
809d			; using existing 4 wire x 4 resistor array for input  
809d			;include "firmware_key_4x10.asm"  
809d			; need to mod the board for 5 rows due to resistor array  
809d			;include "firmware_key_5x10.asm"  
809d			  
809d			; storage hardware interface  
809d			  
809d			; use microchip serial eeprom for storage  
809d			  
809d			  
809d			if STORAGE_SE  
809d				include "firmware_spi.asm"  
809d				include "firmware_seeprom.asm"  
809d			else  
809d			   ; create some stubs for the labels  
809d c9			se_readbyte: ret  
809e c9			se_writebyte: ret  
809f c9			storage_init: ret  
80a0			  
80a0			endif  
80a0			  
80a0			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80a0			;include "firmware_cf.asm"  
80a0			  
80a0			; load up high level storage hardward abstractions  
80a0			include "firmware_storage.asm"  
80a0			 
80a0			; persisent storage hardware abstraction layer  
80a0			 
80a0			 
80a0			 
80a0			; Block 0 on storage is a config state 
80a0			 
80a0			 
80a0			 
80a0			; TODO add read phy block and write phy block functions 
80a0			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80a0			 
80a0			; Abstraction layer  
80a0			 
80a0			; Logocial block size is same size as physical size - using tape concept 
80a0			 
80a0			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80a0			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80a0			 
80a0			 
80a0			 
80a0			; Filesystem layout (Logical layout) 
80a0			; 
80a0			; Block 0 - Bank config  
80a0			; 
80a0			;      Byte - 0 file id counter 
80a0			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80a0			;      Byte - 3-20 zero terminated bank label 
80a0			; 
80a0			; Block 1 > File storage 
80a0			; 
80a0			;      Byte 0 file id    - block 0 file details 
80a0			;      Byte 1 block id - block 0 is file  
80a0			;            Byte 2-15 - File name 
80a0			; 
80a0			;       - to end of block data 
80a0			; 
80a0			 
80a0			; Get ID for the file named in pointer held HL 
80a0			; Returns ID in HL = 255 if no file found 
80a0			 
80a0			storage_getid: 
80a0			 
80a0 22 7d ea			ld (store_tmp1), hl 
80a3			 
80a3				if DEBUG_STORESE 
80a3					DMARK "SGI" 
80a3 f5				push af  
80a4 3a b8 80			ld a, (.dmark)  
80a7 32 71 ee			ld (debug_mark),a  
80aa 3a b9 80			ld a, (.dmark+1)  
80ad 32 72 ee			ld (debug_mark+1),a  
80b0 3a ba 80			ld a, (.dmark+2)  
80b3 32 73 ee			ld (debug_mark+2),a  
80b6 18 03			jr .pastdmark  
80b8 ..			.dmark: db "SGI"  
80bb f1			.pastdmark: pop af  
80bc			endm  
# End of macro DMARK
80bc					CALLMONITOR 
80bc cd 9d 94			call break_point_state  
80bf				endm  
# End of macro CALLMONITOR
80bf				endif 
80bf				; get block 0 and set counter for number of files to scan 
80bf			 
80bf cd 2a 82			call storage_get_block_0 
80c2			 
80c2 3a 84 ea			ld a, (store_page) 
80c5 47				ld b, a 
80c6			 
80c6				; get extent 0 of each file id 
80c6			 
80c6				if DEBUG_STORESE 
80c6					DMARK "SGc" 
80c6 f5				push af  
80c7 3a db 80			ld a, (.dmark)  
80ca 32 71 ee			ld (debug_mark),a  
80cd 3a dc 80			ld a, (.dmark+1)  
80d0 32 72 ee			ld (debug_mark+1),a  
80d3 3a dd 80			ld a, (.dmark+2)  
80d6 32 73 ee			ld (debug_mark+2),a  
80d9 18 03			jr .pastdmark  
80db ..			.dmark: db "SGc"  
80de f1			.pastdmark: pop af  
80df			endm  
# End of macro DMARK
80df					CALLMONITOR 
80df cd 9d 94			call break_point_state  
80e2				endm  
# End of macro CALLMONITOR
80e2				endif 
80e2 60			.getloop:	ld h, b 
80e3 2e 00				ld l, 0 
80e5 c5					push bc 
80e6			 
80e6 11 84 ea				ld de, store_page 
80e9				if DEBUG_STORESE 
80e9					DMARK "SGr" 
80e9 f5				push af  
80ea 3a fe 80			ld a, (.dmark)  
80ed 32 71 ee			ld (debug_mark),a  
80f0 3a ff 80			ld a, (.dmark+1)  
80f3 32 72 ee			ld (debug_mark+1),a  
80f6 3a 00 81			ld a, (.dmark+2)  
80f9 32 73 ee			ld (debug_mark+2),a  
80fc 18 03			jr .pastdmark  
80fe ..			.dmark: db "SGr"  
8101 f1			.pastdmark: pop af  
8102			endm  
# End of macro DMARK
8102					CALLMONITOR 
8102 cd 9d 94			call break_point_state  
8105				endm  
# End of macro CALLMONITOR
8105				endif 
8105 cd d2 86				call storage_read 
8108 cd c5 8c				call ishlzero 
810b 28 2d				jr z, .gap 
810d					 
810d					; have a file name read. Is it one we want. 
810d			 
810d 2a 7d ea				ld hl, (store_tmp1) 
8110 11 87 ea				ld de, store_page+3   ; file name 
8113			 
8113				if DEBUG_STORESE 
8113					DMARK "SGc" 
8113 f5				push af  
8114 3a 28 81			ld a, (.dmark)  
8117 32 71 ee			ld (debug_mark),a  
811a 3a 29 81			ld a, (.dmark+1)  
811d 32 72 ee			ld (debug_mark+1),a  
8120 3a 2a 81			ld a, (.dmark+2)  
8123 32 73 ee			ld (debug_mark+2),a  
8126 18 03			jr .pastdmark  
8128 ..			.dmark: db "SGc"  
812b f1			.pastdmark: pop af  
812c			endm  
# End of macro DMARK
812c					CALLMONITOR 
812c cd 9d 94			call break_point_state  
812f				endm  
# End of macro CALLMONITOR
812f				endif 
812f cd 32 91				call strcmp 
8132 20 06				jr nz, .gap   ; not this one 
8134			 
8134 c1				        pop bc 
8135			 
8135 26 00				ld h, 0 
8137 68					ld l, b 
8138 18 22				jr .getdone 
813a						 
813a			 
813a			 
813a			 
813a			.gap: 
813a				if DEBUG_STORESE 
813a					DMARK "SGg" 
813a f5				push af  
813b 3a 4f 81			ld a, (.dmark)  
813e 32 71 ee			ld (debug_mark),a  
8141 3a 50 81			ld a, (.dmark+1)  
8144 32 72 ee			ld (debug_mark+1),a  
8147 3a 51 81			ld a, (.dmark+2)  
814a 32 73 ee			ld (debug_mark+2),a  
814d 18 03			jr .pastdmark  
814f ..			.dmark: db "SGg"  
8152 f1			.pastdmark: pop af  
8153			endm  
# End of macro DMARK
8153					CALLMONITOR 
8153 cd 9d 94			call break_point_state  
8156				endm  
# End of macro CALLMONITOR
8156				endif 
8156			 
8156 c1					pop bc 
8157 10 89				djnz .getloop 
8159 21 ff 00				ld hl, 255 
815c			.getdone: 
815c			 
815c				if DEBUG_STORESE 
815c					DMARK "SGe" 
815c f5				push af  
815d 3a 71 81			ld a, (.dmark)  
8160 32 71 ee			ld (debug_mark),a  
8163 3a 72 81			ld a, (.dmark+1)  
8166 32 72 ee			ld (debug_mark+1),a  
8169 3a 73 81			ld a, (.dmark+2)  
816c 32 73 ee			ld (debug_mark+2),a  
816f 18 03			jr .pastdmark  
8171 ..			.dmark: db "SGe"  
8174 f1			.pastdmark: pop af  
8175			endm  
# End of macro DMARK
8175					CALLMONITOR 
8175 cd 9d 94			call break_point_state  
8178				endm  
# End of macro CALLMONITOR
8178				endif 
8178			 
8178 c9				ret 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			 
8179			; Read Block 
8179			; ---------- 
8179			; 
8179			; With current bank 
8179			;  
8179			; Get block number to read 
8179			; Load physical blocks starting at start block into buffer 
8179			 
8179			; de points to buffer to use 
8179			; hl holds logical block number  
8179			 
8179			storage_read_block: 
8179			 
8179				; TODO bank selection 
8179			 
8179				; for each of the physical blocks read it into the buffer 
8179 06 40			ld b, STORE_BLOCK_PHY 
817b			 
817b				if DEBUG_STORESE 
817b d5					push de 
817c				endif 
817c				 
817c			.rl1:    
817c			 
817c				; read physical block at hl into de 
817c			        ; increment hl and de to next read position on exit 
817c			 
817c e5				push hl 
817d d5				push de	 
817e c5				push bc 
817f			;	if DEBUG_STORESE 
817f			;		push af 
817f			;		ld a, 'R' 
817f			;		ld (debug_mark),a 
817f			;		pop af 
817f			;		CALLMONITOR 
817f			;	endif 
817f cd 9d 80			call se_readbyte 
8182			;	if DEBUG_STORESE 
8182			;		ld a,(spi_portbyte) 
8182			;		ld l, a 
8182			;		push af 
8182			;		ld a, '1' 
8182			;		ld (debug_mark),a 
8182			;		pop af 
8182			;		CALLMONITOR 
8182			;	endif 
8182 c1				pop bc 
8183 d1				pop de 
8184 e1				pop hl 
8185 12				ld (de),a 
8186 23				inc hl 
8187 13				inc de 
8188			 
8188			;	if DEBUG_STORESE 
8188			;		push af 
8188			;		ld a, 'r' 
8188			;		ld (debug_mark),a 
8188			;		pop af 
8188			;		CALLMONITOR 
8188			;	endif 
8188			 
8188 10 f2			djnz .rl1 
818a			 
818a				if DEBUG_STORESE 
818a					DMARK "SRB" 
818a f5				push af  
818b 3a 9f 81			ld a, (.dmark)  
818e 32 71 ee			ld (debug_mark),a  
8191 3a a0 81			ld a, (.dmark+1)  
8194 32 72 ee			ld (debug_mark+1),a  
8197 3a a1 81			ld a, (.dmark+2)  
819a 32 73 ee			ld (debug_mark+2),a  
819d 18 03			jr .pastdmark  
819f ..			.dmark: db "SRB"  
81a2 f1			.pastdmark: pop af  
81a3			endm  
# End of macro DMARK
81a3 d1					pop de 
81a4			; 
81a4			;		push af 
81a4			;		ld a, 'R' 
81a4			;		ld (debug_mark),a 
81a4			;		pop af 
81a4					CALLMONITOR 
81a4 cd 9d 94			call break_point_state  
81a7				endm  
# End of macro CALLMONITOR
81a7				endif 
81a7 c9				ret	 
81a8				 
81a8			 
81a8			; File Size 
81a8			; --------- 
81a8			; 
81a8			;   hl file id 
81a8			; 
81a8			;  returns in hl the number of blocks 
81a8			 
81a8			storage_file_size: 
81a8 5d				ld e, l 
81a9 16 00			ld d, 0 
81ab 21 40 00			ld hl, STORE_BLOCK_PHY 
81ae					if DEBUG_FORTH_WORDS 
81ae						DMARK "SIZ" 
81ae f5				push af  
81af 3a c3 81			ld a, (.dmark)  
81b2 32 71 ee			ld (debug_mark),a  
81b5 3a c4 81			ld a, (.dmark+1)  
81b8 32 72 ee			ld (debug_mark+1),a  
81bb 3a c5 81			ld a, (.dmark+2)  
81be 32 73 ee			ld (debug_mark+2),a  
81c1 18 03			jr .pastdmark  
81c3 ..			.dmark: db "SIZ"  
81c6 f1			.pastdmark: pop af  
81c7			endm  
# End of macro DMARK
81c7						CALLMONITOR 
81c7 cd 9d 94			call break_point_state  
81ca				endm  
# End of macro CALLMONITOR
81ca					endif 
81ca cd ac 84			call storage_findnextid 
81cd			 
81cd cd c5 8c			call ishlzero 
81d0			;	ld a, l 
81d0			;	add h 
81d0			;	cp 0 
81d0 c8				ret z			; block not found so EOF 
81d1			 
81d1 11 84 ea			ld de, store_page 
81d4 cd 79 81			call storage_read_block 
81d7			 
81d7 3a 86 ea			ld a, (store_page+2)	 ; get extent count 
81da 6f				ld l, a 
81db 26 00			ld h, 0 
81dd c9			 	ret 
81de			 
81de			 
81de			; Write Block 
81de			; ----------- 
81de			; 
81de			; With current bank 
81de			;  
81de			; Get block number to write 
81de			; Write physical blocks starting at start block from buffer 
81de			  
81de			storage_write_block: 
81de				; TODO bank selection 
81de			 
81de				; for each of the physical blocks read it into the buffer 
81de 06 40			ld b, STORE_BLOCK_PHY 
81e0			 
81e0				if DEBUG_STORESE 
81e0					DMARK "SWB" 
81e0 f5				push af  
81e1 3a f5 81			ld a, (.dmark)  
81e4 32 71 ee			ld (debug_mark),a  
81e7 3a f6 81			ld a, (.dmark+1)  
81ea 32 72 ee			ld (debug_mark+1),a  
81ed 3a f7 81			ld a, (.dmark+2)  
81f0 32 73 ee			ld (debug_mark+2),a  
81f3 18 03			jr .pastdmark  
81f5 ..			.dmark: db "SWB"  
81f8 f1			.pastdmark: pop af  
81f9			endm  
# End of macro DMARK
81f9			 
81f9					;push af 
81f9					;ld a, 'W' 
81f9					;ld (debug_mark),a 
81f9					;pop af 
81f9					CALLMONITOR 
81f9 cd 9d 94			call break_point_state  
81fc				endm  
# End of macro CALLMONITOR
81fc				endif 
81fc			 
81fc			; might not be working 
81fc			;	call se_writepage 
81fc			 
81fc			;	ret 
81fc			; 
81fc			 
81fc			 
81fc			 
81fc			.wl1:    
81fc			 
81fc				; read physical block at hl into de 
81fc			        ; increment hl and de to next read position on exit 
81fc			 
81fc e5				push hl 
81fd d5				push de	 
81fe c5				push bc 
81ff 1a				ld a,(de) 
8200				;if DEBUG_STORESE 
8200			;		push af 
8200			;		ld a, 'W' 
8200			;		ld (debug_mark),a 
8200			;		pop af 
8200			;		CALLMONITOR 
8200			;	endif 
8200 cd 9e 80			call se_writebyte 
8203			;	call delay250ms 
8203 00				nop 
8204 00				nop 
8205 00				nop 
8206			;	if DEBUG_STORESE 
8206			;		push af 
8206			;		ld a, 'w' 
8206			;		ld (debug_mark),a 
8206			;		pop af 
8206			;		CALLMONITOR 
8206			;	endif 
8206 c1				pop bc 
8207 d1				pop de 
8208 e1				pop hl 
8209 23				inc hl 
820a 13				inc de 
820b			 
820b			 
820b 10 ef			djnz .wl1 
820d			 
820d				if DEBUG_STORESE 
820d					DMARK "SW2" 
820d f5				push af  
820e 3a 22 82			ld a, (.dmark)  
8211 32 71 ee			ld (debug_mark),a  
8214 3a 23 82			ld a, (.dmark+1)  
8217 32 72 ee			ld (debug_mark+1),a  
821a 3a 24 82			ld a, (.dmark+2)  
821d 32 73 ee			ld (debug_mark+2),a  
8220 18 03			jr .pastdmark  
8222 ..			.dmark: db "SW2"  
8225 f1			.pastdmark: pop af  
8226			endm  
# End of macro DMARK
8226			 
8226					;push af 
8226					;ld a, 'W' 
8226					;ld (debug_mark),a 
8226					;pop af 
8226					CALLMONITOR 
8226 cd 9d 94			call break_point_state  
8229				endm  
# End of macro CALLMONITOR
8229				endif 
8229 c9				ret	 
822a			 
822a			; Init bank 
822a			; --------- 
822a			; 
822a			; With current bank 
822a			; 
822a			; Setup block 0 config 
822a			;     Set 0 file id counter 
822a			;     Set formatted byte pattern 
822a			;     Zero out bank label 
822a			;      
822a			; For every logical block write 0-1 byte as null 
822a			 
822a			storage_get_block_0: 
822a			 
822a				; TODO check presence 
822a			 
822a				; get block 0 config 
822a			 
822a 21 00 00			ld hl, 0 
822d 11 84 ea			ld de, store_page 
8230 cd 79 81			call storage_read_block 
8233			 
8233				if DEBUG_STORESE 
8233					DMARK "SB0" 
8233 f5				push af  
8234 3a 48 82			ld a, (.dmark)  
8237 32 71 ee			ld (debug_mark),a  
823a 3a 49 82			ld a, (.dmark+1)  
823d 32 72 ee			ld (debug_mark+1),a  
8240 3a 4a 82			ld a, (.dmark+2)  
8243 32 73 ee			ld (debug_mark+2),a  
8246 18 03			jr .pastdmark  
8248 ..			.dmark: db "SB0"  
824b f1			.pastdmark: pop af  
824c			endm  
# End of macro DMARK
824c 11 84 ea				ld de, store_page 
824f			;		push af 
824f			;		ld a, 'i' 
824f			;		ld (debug_mark),a 
824f			;		pop af 
824f					CALLMONITOR 
824f cd 9d 94			call break_point_state  
8252				endm  
# End of macro CALLMONITOR
8252				endif 
8252			 
8252				; is this area formatted? 
8252			 
8252			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
8252 2a 85 ea			ld hl, (store_page+1) 
8255 3e 80			ld a,0x80 
8257 bd				cp l 
8258 20 22			jr nz, .ininotformatted 
825a				; do a double check 
825a 3e 27			ld a, 0x27 
825c bc				cp h 
825d 20 1d			jr nz, .ininotformatted 
825f			 
825f				; formatted then 
825f			 
825f				if DEBUG_STORESE 
825f					DMARK "SB1" 
825f f5				push af  
8260 3a 74 82			ld a, (.dmark)  
8263 32 71 ee			ld (debug_mark),a  
8266 3a 75 82			ld a, (.dmark+1)  
8269 32 72 ee			ld (debug_mark+1),a  
826c 3a 76 82			ld a, (.dmark+2)  
826f 32 73 ee			ld (debug_mark+2),a  
8272 18 03			jr .pastdmark  
8274 ..			.dmark: db "SB1"  
8277 f1			.pastdmark: pop af  
8278			endm  
# End of macro DMARK
8278					;push af 
8278					;ld a, 'I' 
8278					;ld (debug_mark),a 
8278					;pop af 
8278					CALLMONITOR 
8278 cd 9d 94			call break_point_state  
827b				endm  
# End of macro CALLMONITOR
827b				endif 
827b c9				ret 
827c			 
827c			.ininotformatted: 
827c				; bank not formatted so poke various bits to make sure 
827c			 
827c				if DEBUG_STORESE 
827c					DMARK "SB2" 
827c f5				push af  
827d 3a 91 82			ld a, (.dmark)  
8280 32 71 ee			ld (debug_mark),a  
8283 3a 92 82			ld a, (.dmark+1)  
8286 32 72 ee			ld (debug_mark+1),a  
8289 3a 93 82			ld a, (.dmark+2)  
828c 32 73 ee			ld (debug_mark+2),a  
828f 18 03			jr .pastdmark  
8291 ..			.dmark: db "SB2"  
8294 f1			.pastdmark: pop af  
8295			endm  
# End of macro DMARK
8295					;push af 
8295					;ld a, 'f' 
8295					;ld (debug_mark),a 
8295					;pop af 
8295					CALLMONITOR 
8295 cd 9d 94			call break_point_state  
8298				endm  
# End of macro CALLMONITOR
8298				endif 
8298			 
8298 cd af 89			call storage_clear_page 
829b			 
829b 21 84 ea			ld hl, store_page 
829e 3e 00			ld a, 0 
82a0				 
82a0 77				ld (hl),a   ; reset file counter 
82a1			 
82a1 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
82a4 22 85 ea		 	ld (store_page+1), hl	 
82a7			 
82a7				; set default label 
82a7			 
82a7 21 43 83			ld hl, .defaultbanklabl 
82aa 11 87 ea		 	ld de, store_page+3 
82ad 01 0f 00			ld bc, 15 
82b0 ed b0			ldir 
82b2			 
82b2				; Append the current bank id 
82b2 21 90 ea			ld hl, store_page+3+9 
82b5 3a 6c ea			ld a, (spi_device_id) 
82b8 77				ld (hl), a 
82b9			 
82b9				; save default page 0 
82b9			 
82b9 21 00 00			ld hl, 0 
82bc 11 84 ea			ld de, store_page 
82bf				if DEBUG_STORESE 
82bf					DMARK "SB3" 
82bf f5				push af  
82c0 3a d4 82			ld a, (.dmark)  
82c3 32 71 ee			ld (debug_mark),a  
82c6 3a d5 82			ld a, (.dmark+1)  
82c9 32 72 ee			ld (debug_mark+1),a  
82cc 3a d6 82			ld a, (.dmark+2)  
82cf 32 73 ee			ld (debug_mark+2),a  
82d2 18 03			jr .pastdmark  
82d4 ..			.dmark: db "SB3"  
82d7 f1			.pastdmark: pop af  
82d8			endm  
# End of macro DMARK
82d8			;		push af 
82d8			;		ld a, 'F' 
82d8			;		ld (debug_mark),a 
82d8			;		pop af 
82d8					CALLMONITOR 
82d8 cd 9d 94			call break_point_state  
82db				endm  
# End of macro CALLMONITOR
82db				endif 
82db cd de 81			call storage_write_block 
82de				if DEBUG_STORESE 
82de					DMARK "SB4" 
82de f5				push af  
82df 3a f3 82			ld a, (.dmark)  
82e2 32 71 ee			ld (debug_mark),a  
82e5 3a f4 82			ld a, (.dmark+1)  
82e8 32 72 ee			ld (debug_mark+1),a  
82eb 3a f5 82			ld a, (.dmark+2)  
82ee 32 73 ee			ld (debug_mark+2),a  
82f1 18 03			jr .pastdmark  
82f3 ..			.dmark: db "SB4"  
82f6 f1			.pastdmark: pop af  
82f7			endm  
# End of macro DMARK
82f7			;		push af 
82f7			;		ld a, '>' 
82f7			;		ld (debug_mark),a 
82f7			;		pop af 
82f7					CALLMONITOR 
82f7 cd 9d 94			call break_point_state  
82fa				endm  
# End of macro CALLMONITOR
82fa				endif 
82fa			 
82fa 00				nop 
82fb 00				nop 
82fc 00				nop 
82fd			 
82fd				; now set 0 in every page to mark as a free block 
82fd			 
82fd 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
82ff 21 40 00			ld hl, STORE_BLOCK_PHY 
8302			 
8302 3e 00		.setmark1:   	ld a,0 
8304 e5					push hl 
8305 c5					push bc 
8306 cd 9e 80				call se_writebyte 
8309 3e 0a			ld a, 10 
830b cd d1 89			call aDelayInMS 
830e 23				inc hl 
830f cd 9e 80				call se_writebyte 
8312 3e 0a			ld a, 10 
8314 cd d1 89			call aDelayInMS 
8317 2b				dec hl 
8318 c1					pop bc 
8319 e1					pop hl 
831a 3e 40				ld a, STORE_BLOCK_PHY 
831c cd 9c 8c				call addatohl 
831f 10 e1				djnz .setmark1 
8321			 
8321 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8323 3e 00		.setmark2:   	ld a,0 
8325 e5					push hl 
8326 c5					push bc 
8327 cd 9e 80				call se_writebyte 
832a 3e 0a			ld a, 10 
832c cd d1 89			call aDelayInMS 
832f 23				inc hl 
8330 cd 9e 80				call se_writebyte 
8333 3e 0a			ld a, 10 
8335 cd d1 89			call aDelayInMS 
8338 2b				dec hl 
8339 c1					pop bc 
833a e1					pop hl 
833b 3e 40				ld a, STORE_BLOCK_PHY 
833d cd 9c 8c				call addatohl 
8340 10 e1				djnz .setmark2 
8342			 
8342					 
8342			 
8342			 
8342 c9				ret 
8343			 
8343			 
8343			 
8343			 
8343 .. 00		.defaultbanklabl:   db "BankLabel_",0 
834e			 
834e			 
834e			 
834e			; Label Bank 
834e			; ---------- 
834e			; 
834e			; With current bank 
834e			; Read block 0 
834e			; Set label 
834e			; Write block 0 
834e			 
834e			; label str pointer in hl 
834e			 
834e			storage_label:     
834e			 
834e				if DEBUG_STORESE 
834e					DMARK "LBL" 
834e f5				push af  
834f 3a 63 83			ld a, (.dmark)  
8352 32 71 ee			ld (debug_mark),a  
8355 3a 64 83			ld a, (.dmark+1)  
8358 32 72 ee			ld (debug_mark+1),a  
835b 3a 65 83			ld a, (.dmark+2)  
835e 32 73 ee			ld (debug_mark+2),a  
8361 18 03			jr .pastdmark  
8363 ..			.dmark: db "LBL"  
8366 f1			.pastdmark: pop af  
8367			endm  
# End of macro DMARK
8367					CALLMONITOR 
8367 cd 9d 94			call break_point_state  
836a				endm  
# End of macro CALLMONITOR
836a				endif 
836a			 
836a e5				push hl 
836b			 
836b cd 2a 82			call storage_get_block_0 
836e			 
836e				; set default label 
836e			 
836e e1				pop hl 
836f			 
836f 11 87 ea		 	ld de, store_page+3 
8372 01 0f 00			ld bc, 15 
8375				if DEBUG_STORESE 
8375					DMARK "LB3" 
8375 f5				push af  
8376 3a 8a 83			ld a, (.dmark)  
8379 32 71 ee			ld (debug_mark),a  
837c 3a 8b 83			ld a, (.dmark+1)  
837f 32 72 ee			ld (debug_mark+1),a  
8382 3a 8c 83			ld a, (.dmark+2)  
8385 32 73 ee			ld (debug_mark+2),a  
8388 18 03			jr .pastdmark  
838a ..			.dmark: db "LB3"  
838d f1			.pastdmark: pop af  
838e			endm  
# End of macro DMARK
838e					CALLMONITOR 
838e cd 9d 94			call break_point_state  
8391				endm  
# End of macro CALLMONITOR
8391				endif 
8391 ed b0			ldir 
8393				; save default page 0 
8393			 
8393 21 00 00			ld hl, 0 
8396 11 84 ea			ld de, store_page 
8399				if DEBUG_STORESE 
8399					DMARK "LBW" 
8399 f5				push af  
839a 3a ae 83			ld a, (.dmark)  
839d 32 71 ee			ld (debug_mark),a  
83a0 3a af 83			ld a, (.dmark+1)  
83a3 32 72 ee			ld (debug_mark+1),a  
83a6 3a b0 83			ld a, (.dmark+2)  
83a9 32 73 ee			ld (debug_mark+2),a  
83ac 18 03			jr .pastdmark  
83ae ..			.dmark: db "LBW"  
83b1 f1			.pastdmark: pop af  
83b2			endm  
# End of macro DMARK
83b2					CALLMONITOR 
83b2 cd 9d 94			call break_point_state  
83b5				endm  
# End of macro CALLMONITOR
83b5				endif 
83b5 cd de 81			call storage_write_block 
83b8			 
83b8 c9				ret 
83b9			 
83b9			 
83b9			 
83b9			; Read Block 0 - Config 
83b9			; --------------------- 
83b9			; 
83b9			; With current bank 
83b9			; Call presence test 
83b9			;    If not present format/init bank  
83b9			; Read block 0  
83b9			;  
83b9			 
83b9			 
83b9			; Dir 
83b9			; --- 
83b9			; 
83b9			; With current bank 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block read byte 2 
83b9			;      if first block of file 
83b9			;         Display file name 
83b9			;         Display type flags for file 
83b9			;        
83b9			 
83b9			; moving to words as this requires stack control 
83b9			 
83b9			 
83b9			; Delete File 
83b9			; ----------- 
83b9			; 
83b9			; With current bank 
83b9			; 
83b9			; Load Block 0 Config 
83b9			; Get max file id number 
83b9			; For each logical block 
83b9			;    Read block file id 
83b9			;      If first block of file and dont have file id 
83b9			;         if file to delete 
83b9			;         Save file id 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			;      If file id is one saved 
83b9			;         Null file id 
83b9			;         Write this block back 
83b9			 
83b9			 
83b9			.se_done: 
83b9 e1				pop hl 
83ba c9				ret 
83bb			 
83bb			storage_erase: 
83bb			 
83bb				; hl contains the file id 
83bb			 
83bb 5d				ld e, l 
83bc 16 00			ld d, 0 
83be 21 40 00			ld hl, STORE_BLOCK_PHY 
83c1					if DEBUG_FORTH_WORDS 
83c1						DMARK "ERA" 
83c1 f5				push af  
83c2 3a d6 83			ld a, (.dmark)  
83c5 32 71 ee			ld (debug_mark),a  
83c8 3a d7 83			ld a, (.dmark+1)  
83cb 32 72 ee			ld (debug_mark+1),a  
83ce 3a d8 83			ld a, (.dmark+2)  
83d1 32 73 ee			ld (debug_mark+2),a  
83d4 18 03			jr .pastdmark  
83d6 ..			.dmark: db "ERA"  
83d9 f1			.pastdmark: pop af  
83da			endm  
# End of macro DMARK
83da						CALLMONITOR 
83da cd 9d 94			call break_point_state  
83dd				endm  
# End of macro CALLMONITOR
83dd					endif 
83dd cd ac 84			call storage_findnextid 
83e0 cd c5 8c			call ishlzero 
83e3 c8				ret z 
83e4			 
83e4 e5				push hl 
83e5			 
83e5				; TODO check file not found 
83e5			 
83e5 11 84 ea			ld de, store_page 
83e8 cd 79 81			call storage_read_block 
83eb			 
83eb cd c5 8c			call ishlzero 
83ee ca b9 83			jp z,.se_done 
83f1			 
83f1					if DEBUG_FORTH_WORDS 
83f1						DMARK "ER1" 
83f1 f5				push af  
83f2 3a 06 84			ld a, (.dmark)  
83f5 32 71 ee			ld (debug_mark),a  
83f8 3a 07 84			ld a, (.dmark+1)  
83fb 32 72 ee			ld (debug_mark+1),a  
83fe 3a 08 84			ld a, (.dmark+2)  
8401 32 73 ee			ld (debug_mark+2),a  
8404 18 03			jr .pastdmark  
8406 ..			.dmark: db "ER1"  
8409 f1			.pastdmark: pop af  
840a			endm  
# End of macro DMARK
840a						CALLMONITOR 
840a cd 9d 94			call break_point_state  
840d				endm  
# End of macro CALLMONITOR
840d					endif 
840d 3a 84 ea			ld a, (store_page)	; get file id 
8410 32 78 ea			ld (store_tmpid), a 
8413			 
8413 3a 86 ea			ld a, (store_page+2)    ; get count of extends 
8416 32 77 ea			ld (store_tmpext), a 
8419			 
8419				; wipe file header 
8419			 
8419 e1				pop hl 
841a 3e 00			ld a, 0 
841c 32 84 ea			ld (store_page), a 
841f 32 85 ea			ld (store_page+1),a 
8422 11 84 ea			ld de, store_page 
8425					if DEBUG_FORTH_WORDS 
8425						DMARK "ER2" 
8425 f5				push af  
8426 3a 3a 84			ld a, (.dmark)  
8429 32 71 ee			ld (debug_mark),a  
842c 3a 3b 84			ld a, (.dmark+1)  
842f 32 72 ee			ld (debug_mark+1),a  
8432 3a 3c 84			ld a, (.dmark+2)  
8435 32 73 ee			ld (debug_mark+2),a  
8438 18 03			jr .pastdmark  
843a ..			.dmark: db "ER2"  
843d f1			.pastdmark: pop af  
843e			endm  
# End of macro DMARK
843e						CALLMONITOR 
843e cd 9d 94			call break_point_state  
8441				endm  
# End of macro CALLMONITOR
8441					endif 
8441 cd de 81			call storage_write_block 
8444			 
8444			 
8444				; wipe file extents 
8444			 
8444 3a 77 ea			ld a, (store_tmpext) 
8447 47				ld b, a 
8448			 
8448			.eraext:	  
8448 c5				push bc 
8449			 
8449 21 40 00			ld hl, STORE_BLOCK_PHY 
844c 3a 78 ea			ld a,(store_tmpid) 
844f 5f				ld e, a 
8450 50				ld d, b	 
8451					if DEBUG_FORTH_WORDS 
8451						DMARK "ER3" 
8451 f5				push af  
8452 3a 66 84			ld a, (.dmark)  
8455 32 71 ee			ld (debug_mark),a  
8458 3a 67 84			ld a, (.dmark+1)  
845b 32 72 ee			ld (debug_mark+1),a  
845e 3a 68 84			ld a, (.dmark+2)  
8461 32 73 ee			ld (debug_mark+2),a  
8464 18 03			jr .pastdmark  
8466 ..			.dmark: db "ER3"  
8469 f1			.pastdmark: pop af  
846a			endm  
# End of macro DMARK
846a						CALLMONITOR 
846a cd 9d 94			call break_point_state  
846d				endm  
# End of macro CALLMONITOR
846d					endif 
846d cd ac 84			call storage_findnextid 
8470 cd c5 8c			call ishlzero 
8473 ca b9 83			jp z,.se_done 
8476			 
8476 e5				push hl 
8477 11 84 ea			ld de, store_page 
847a cd 79 81			call storage_read_block 
847d			 
847d				; free block	 
847d			 
847d 3e 00			ld a, 0 
847f 32 84 ea			ld (store_page), a 
8482 32 85 ea			ld (store_page+1),a 
8485 11 84 ea			ld de, store_page 
8488 e1				pop hl 
8489					if DEBUG_FORTH_WORDS 
8489						DMARK "ER4" 
8489 f5				push af  
848a 3a 9e 84			ld a, (.dmark)  
848d 32 71 ee			ld (debug_mark),a  
8490 3a 9f 84			ld a, (.dmark+1)  
8493 32 72 ee			ld (debug_mark+1),a  
8496 3a a0 84			ld a, (.dmark+2)  
8499 32 73 ee			ld (debug_mark+2),a  
849c 18 03			jr .pastdmark  
849e ..			.dmark: db "ER4"  
84a1 f1			.pastdmark: pop af  
84a2			endm  
# End of macro DMARK
84a2						CALLMONITOR 
84a2 cd 9d 94			call break_point_state  
84a5				endm  
# End of macro CALLMONITOR
84a5					endif 
84a5 cd de 81			call storage_write_block 
84a8			 
84a8 c1				pop bc 
84a9 10 9d			djnz .eraext 
84ab			 
84ab c9				ret 
84ac			 
84ac			 
84ac			; Find Free Block 
84ac			; --------------- 
84ac			; 
84ac			; With current bank 
84ac			;  
84ac			; From given starting logical block 
84ac			;    Read block  
84ac			;    If no file id 
84ac			;         Return block id 
84ac			 
84ac			 
84ac			; hl starting page number 
84ac			; hl contains free page number or zero if no pages free 
84ac			; e contains the file id to locate 
84ac			; d contains the block number 
84ac			 
84ac			; TODO change to find file id and use zero for free block 
84ac			 
84ac			storage_findnextid: 
84ac			 
84ac				; now locate first 0 page to mark as a free block 
84ac			 
84ac 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84ae			;	ld hl, STORE_BLOCK_PHY 
84ae			 
84ae					if DEBUG_FORTH_WORDS 
84ae					DMARK "FNI" 
84ae f5				push af  
84af 3a c3 84			ld a, (.dmark)  
84b2 32 71 ee			ld (debug_mark),a  
84b5 3a c4 84			ld a, (.dmark+1)  
84b8 32 72 ee			ld (debug_mark+1),a  
84bb 3a c5 84			ld a, (.dmark+2)  
84be 32 73 ee			ld (debug_mark+2),a  
84c1 18 03			jr .pastdmark  
84c3 ..			.dmark: db "FNI"  
84c6 f1			.pastdmark: pop af  
84c7			endm  
# End of macro DMARK
84c7						CALLMONITOR 
84c7 cd 9d 94			call break_point_state  
84ca				endm  
# End of macro CALLMONITOR
84ca					endif 
84ca			.ff1:   	 
84ca e5					push hl 
84cb c5					push bc 
84cc d5					push de 
84cd cd 9d 80				call se_readbyte 
84d0 5f					ld e,a 
84d1 23					inc hl 
84d2 cd 9d 80				call se_readbyte 
84d5 57					ld d, a 
84d6 e1					pop hl 
84d7 e5					push hl 
84d8 cd ba 8c				call cmp16 
84db 28 49				jr z, .fffound 
84dd			 
84dd d1					pop de 
84de c1					pop bc 
84df e1					pop hl 
84e0			 
84e0					; is found? 
84e0					;cp e 
84e0					;ret z 
84e0			 
84e0 3e 40				ld a, STORE_BLOCK_PHY 
84e2 cd 9c 8c				call addatohl 
84e5 10 e3				djnz .ff1 
84e7			 
84e7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
84e9			.ff2:   	 
84e9			 
84e9 e5					push hl 
84ea c5					push bc 
84eb d5					push de 
84ec cd 9d 80				call se_readbyte 
84ef 5f					ld e,a 
84f0 23					inc hl 
84f1 cd 9d 80				call se_readbyte 
84f4 57					ld d, a 
84f5			 
84f5 e1					pop hl 
84f6 e5					push hl 
84f7 cd ba 8c				call cmp16 
84fa 28 2a				jr z, .fffound 
84fc			 
84fc d1					pop de 
84fd c1					pop bc 
84fe e1					pop hl 
84ff					; is found? 
84ff					;cp e 
84ff					;ret z 
84ff			 
84ff 3e 40				ld a, STORE_BLOCK_PHY 
8501 cd 9c 8c				call addatohl 
8504 10 e3				djnz .ff2 
8506			 
8506			 
8506					if DEBUG_FORTH_WORDS 
8506					DMARK "FN-" 
8506 f5				push af  
8507 3a 1b 85			ld a, (.dmark)  
850a 32 71 ee			ld (debug_mark),a  
850d 3a 1c 85			ld a, (.dmark+1)  
8510 32 72 ee			ld (debug_mark+1),a  
8513 3a 1d 85			ld a, (.dmark+2)  
8516 32 73 ee			ld (debug_mark+2),a  
8519 18 03			jr .pastdmark  
851b ..			.dmark: db "FN-"  
851e f1			.pastdmark: pop af  
851f			endm  
# End of macro DMARK
851f					;	push af 
851f					;	ld a, 'n' 
851f					;	ld (debug_mark),a 
851f					;	pop af 
851f						CALLMONITOR 
851f cd 9d 94			call break_point_state  
8522				endm  
# End of macro CALLMONITOR
8522					endif 
8522				; no free marks! 
8522 21 00 00				ld hl, 0 
8525 c9				ret 
8526			.fffound: 
8526				 
8526			 
8526 d1					pop de 
8527 c1					pop bc 
8528 e1					pop hl 
8529					if DEBUG_FORTH_WORDS 
8529					DMARK "FNF" 
8529 f5				push af  
852a 3a 3e 85			ld a, (.dmark)  
852d 32 71 ee			ld (debug_mark),a  
8530 3a 3f 85			ld a, (.dmark+1)  
8533 32 72 ee			ld (debug_mark+1),a  
8536 3a 40 85			ld a, (.dmark+2)  
8539 32 73 ee			ld (debug_mark+2),a  
853c 18 03			jr .pastdmark  
853e ..			.dmark: db "FNF"  
8541 f1			.pastdmark: pop af  
8542			endm  
# End of macro DMARK
8542					;	push af 
8542					;	ld a, 'n' 
8542					;	ld (debug_mark),a 
8542					;	pop af 
8542						CALLMONITOR 
8542 cd 9d 94			call break_point_state  
8545				endm  
# End of macro CALLMONITOR
8545					endif 
8545 c9				ret 
8546			 
8546			 
8546			 
8546			; Free Space 
8546			; ---------- 
8546			; 
8546			; With current bank 
8546			; 
8546			; Set block count to zero 
8546			; Starting with first logical block 
8546			;      Find free block  
8546			;      If block id given, increment block count 
8546			; 
8546			;  
8546			 
8546			 
8546			; hl contains count of free blocks 
8546			 
8546			storage_freeblocks: 
8546			 
8546				; now locate first 0 page to mark as a free block 
8546			 
8546 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8548 21 40 00			ld hl, STORE_BLOCK_PHY 
854b 11 00 00			ld de, 0 
854e			 
854e			.fb1:   	 
854e e5					push hl 
854f c5					push bc 
8550 d5					push de 
8551 cd 9d 80				call se_readbyte 
8554 d1					pop de 
8555 c1					pop bc 
8556 e1					pop hl 
8557			 
8557					; is free? 
8557 fe 00				cp 0 
8559 20 01				jr nz, .ff1cont 
855b 13					inc de 
855c			 
855c			.ff1cont: 
855c			 
855c			 
855c 3e 40				ld a, STORE_BLOCK_PHY 
855e cd 9c 8c				call addatohl 
8561 10 eb				djnz .fb1 
8563			 
8563 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8565			.fb2:   	 
8565 e5					push hl 
8566 c5					push bc 
8567 d5					push de 
8568 cd 9d 80				call se_readbyte 
856b d1					pop de 
856c c1					pop bc 
856d e1					pop hl 
856e			 
856e					; is free? 
856e fe 00				cp 0 
8570 20 01				jr nz, .ff2cont 
8572 13					inc de 
8573			 
8573			.ff2cont: 
8573			 
8573 3e 40				ld a, STORE_BLOCK_PHY 
8575 cd 9c 8c				call addatohl 
8578 10 eb				djnz .fb2 
857a			 
857a eb				ex de, hl 
857b c9				ret 
857c			 
857c			; Get File ID 
857c			; ----------- 
857c			; 
857c			; With current bank 
857c			;  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; For each logical block 
857c			;    Read block file id 
857c			;      If first block of file and dont have file id 
857c			;         if file get id and exit 
857c			 
857c			 
857c			 
857c			 
857c			; Create File 
857c			; ----------- 
857c			; 
857c			; With current bank  
857c			; Load Block 0 Config 
857c			; Get max file id number 
857c			; Increment file id number 
857c			; Save Config 
857c			; Find free block 
857c			; Set buffer with file name and file id 
857c			; Write buffer to free block  
857c			 
857c			 
857c			; hl point to file name 
857c			; hl returns file id 
857c			 
857c			; file format: 
857c			; byte 0 - file id 
857c			; byte 1 - extent number 
857c			; byte 2-> data 
857c			 
857c			; format for extent number 0: 
857c			; 
857c			; byte 0 - file id 
857c			; byte 1 - extent 0 
857c			; byte 2 - extent count 
857c			; byte 3 -> file name and meta data 
857c			 
857c			 
857c			storage_create: 
857c				if DEBUG_STORESE 
857c					DMARK "SCR" 
857c f5				push af  
857d 3a 91 85			ld a, (.dmark)  
8580 32 71 ee			ld (debug_mark),a  
8583 3a 92 85			ld a, (.dmark+1)  
8586 32 72 ee			ld (debug_mark+1),a  
8589 3a 93 85			ld a, (.dmark+2)  
858c 32 73 ee			ld (debug_mark+2),a  
858f 18 03			jr .pastdmark  
8591 ..			.dmark: db "SCR"  
8594 f1			.pastdmark: pop af  
8595			endm  
# End of macro DMARK
8595					CALLMONITOR 
8595 cd 9d 94			call break_point_state  
8598				endm  
# End of macro CALLMONITOR
8598				endif 
8598			 
8598 e5				push hl		; save file name pointer 
8599			 
8599 cd 2a 82			call storage_get_block_0 
859c			 
859c 3a 84 ea			ld a,(store_page)	; get current file id 
859f 3c				inc a 
85a0 32 84 ea			ld (store_page),a 
85a3				 
85a3 32 78 ea			ld (store_tmpid),a			; save id 
85a6			 
85a6 21 00 00			ld hl, 0 
85a9 11 84 ea			ld de, store_page 
85ac				if DEBUG_STORESE 
85ac					DMARK "SCw" 
85ac f5				push af  
85ad 3a c1 85			ld a, (.dmark)  
85b0 32 71 ee			ld (debug_mark),a  
85b3 3a c2 85			ld a, (.dmark+1)  
85b6 32 72 ee			ld (debug_mark+1),a  
85b9 3a c3 85			ld a, (.dmark+2)  
85bc 32 73 ee			ld (debug_mark+2),a  
85bf 18 03			jr .pastdmark  
85c1 ..			.dmark: db "SCw"  
85c4 f1			.pastdmark: pop af  
85c5			endm  
# End of macro DMARK
85c5					CALLMONITOR 
85c5 cd 9d 94			call break_point_state  
85c8				endm  
# End of macro CALLMONITOR
85c8				endif 
85c8 cd de 81			call storage_write_block	 ; save update 
85cb			 
85cb				if DEBUG_STORESE 
85cb 11 84 ea				ld de, store_page 
85ce					DMARK "SCC" 
85ce f5				push af  
85cf 3a e3 85			ld a, (.dmark)  
85d2 32 71 ee			ld (debug_mark),a  
85d5 3a e4 85			ld a, (.dmark+1)  
85d8 32 72 ee			ld (debug_mark+1),a  
85db 3a e5 85			ld a, (.dmark+2)  
85de 32 73 ee			ld (debug_mark+2),a  
85e1 18 03			jr .pastdmark  
85e3 ..			.dmark: db "SCC"  
85e6 f1			.pastdmark: pop af  
85e7			endm  
# End of macro DMARK
85e7					CALLMONITOR 
85e7 cd 9d 94			call break_point_state  
85ea				endm  
# End of macro CALLMONITOR
85ea				endif 
85ea				;  
85ea				 
85ea 21 40 00			ld hl, STORE_BLOCK_PHY 
85ed 11 00 00			ld de, 0 
85f0 cd ac 84			call storage_findnextid 
85f3			 
85f3 22 71 ea			ld (store_tmppageid), hl    ; save page to use  
85f6			 
85f6				; TODO detect 0 = no spare blocks 
85f6			 
85f6				; hl now contains the free page to use for the file header page 
85f6			 
85f6				if DEBUG_STORESE 
85f6				DMARK "SCF" 
85f6 f5				push af  
85f7 3a 0b 86			ld a, (.dmark)  
85fa 32 71 ee			ld (debug_mark),a  
85fd 3a 0c 86			ld a, (.dmark+1)  
8600 32 72 ee			ld (debug_mark+1),a  
8603 3a 0d 86			ld a, (.dmark+2)  
8606 32 73 ee			ld (debug_mark+2),a  
8609 18 03			jr .pastdmark  
860b ..			.dmark: db "SCF"  
860e f1			.pastdmark: pop af  
860f			endm  
# End of macro DMARK
860f					CALLMONITOR 
860f cd 9d 94			call break_point_state  
8612				endm  
# End of macro CALLMONITOR
8612				endif 
8612			 
8612 22 71 ea			ld (store_tmppageid), hl 
8615				 
8615 3a 78 ea			ld a,(store_tmpid)    ; get file id 
8618			;	ld a, (store_filecache)			; save to cache 
8618			 
8618 32 84 ea			ld (store_page),a    ; set page id 
861b 3e 00			ld a, 0			 ; extent 0 is file header 
861d 32 85 ea			ld (store_page+1), a   ; set file extent 
8620			 
8620 32 86 ea			ld (store_page+2), a   ; extent count for the file 
8623			 
8623			;	inc hl 		; init block 0 of file 
8623			;	inc hl   		; skip file and extent id 
8623			 ;       ld a, 0 
8623			;	ld (hl),a 
8623			;	ld a, (store_filecache+1)  	; save to cache 
8623			 
8623			;	inc hl    ; file name 
8623				 
8623				 
8623 11 87 ea			ld de, store_page+3    ; get buffer for term string to use as file name 
8626				if DEBUG_STORESE 
8626					DMARK "SCc" 
8626 f5				push af  
8627 3a 3b 86			ld a, (.dmark)  
862a 32 71 ee			ld (debug_mark),a  
862d 3a 3c 86			ld a, (.dmark+1)  
8630 32 72 ee			ld (debug_mark+1),a  
8633 3a 3d 86			ld a, (.dmark+2)  
8636 32 73 ee			ld (debug_mark+2),a  
8639 18 03			jr .pastdmark  
863b ..			.dmark: db "SCc"  
863e f1			.pastdmark: pop af  
863f			endm  
# End of macro DMARK
863f					CALLMONITOR 
863f cd 9d 94			call break_point_state  
8642				endm  
# End of macro CALLMONITOR
8642				endif 
8642 e1				pop hl    ; get zero term string 
8643 e5				push hl 
8644 3e 00			ld a, 0 
8646 cd 05 91			call strlent 
8649 23				inc hl   ; cover zero term 
864a 06 00			ld b,0 
864c 4d				ld c,l 
864d e1				pop hl 
864e				;ex de, hl 
864e				if DEBUG_STORESE 
864e					DMARK "SCa" 
864e f5				push af  
864f 3a 63 86			ld a, (.dmark)  
8652 32 71 ee			ld (debug_mark),a  
8655 3a 64 86			ld a, (.dmark+1)  
8658 32 72 ee			ld (debug_mark+1),a  
865b 3a 65 86			ld a, (.dmark+2)  
865e 32 73 ee			ld (debug_mark+2),a  
8661 18 03			jr .pastdmark  
8663 ..			.dmark: db "SCa"  
8666 f1			.pastdmark: pop af  
8667			endm  
# End of macro DMARK
8667					;push af 
8667					;ld a, 'a' 
8667					;ld (debug_mark),a 
8667					;pop af 
8667					CALLMONITOR 
8667 cd 9d 94			call break_point_state  
866a				endm  
# End of macro CALLMONITOR
866a				endif 
866a ed b0			ldir    ; copy zero term string 
866c				if DEBUG_STORESE 
866c					DMARK "SCA" 
866c f5				push af  
866d 3a 81 86			ld a, (.dmark)  
8670 32 71 ee			ld (debug_mark),a  
8673 3a 82 86			ld a, (.dmark+1)  
8676 32 72 ee			ld (debug_mark+1),a  
8679 3a 83 86			ld a, (.dmark+2)  
867c 32 73 ee			ld (debug_mark+2),a  
867f 18 03			jr .pastdmark  
8681 ..			.dmark: db "SCA"  
8684 f1			.pastdmark: pop af  
8685			endm  
# End of macro DMARK
8685					CALLMONITOR 
8685 cd 9d 94			call break_point_state  
8688				endm  
# End of macro CALLMONITOR
8688				endif 
8688			 
8688				; write file header page 
8688			 
8688 2a 71 ea			ld hl,(store_tmppageid) 
868b 11 84 ea			ld de, store_page 
868e				if DEBUG_STORESE 
868e					DMARK "SCb" 
868e f5				push af  
868f 3a a3 86			ld a, (.dmark)  
8692 32 71 ee			ld (debug_mark),a  
8695 3a a4 86			ld a, (.dmark+1)  
8698 32 72 ee			ld (debug_mark+1),a  
869b 3a a5 86			ld a, (.dmark+2)  
869e 32 73 ee			ld (debug_mark+2),a  
86a1 18 03			jr .pastdmark  
86a3 ..			.dmark: db "SCb"  
86a6 f1			.pastdmark: pop af  
86a7			endm  
# End of macro DMARK
86a7					;push af 
86a7					;ld a, 'b' 
86a7					;ld (debug_mark),a 
86a7					;pop af 
86a7					CALLMONITOR 
86a7 cd 9d 94			call break_point_state  
86aa				endm  
# End of macro CALLMONITOR
86aa				endif 
86aa cd de 81			call storage_write_block 
86ad			 
86ad 3a 78 ea			ld a, (store_tmpid) 
86b0 6f				ld l, a 
86b1 26 00			ld h,0 
86b3				if DEBUG_STORESE 
86b3					DMARK "SCz" 
86b3 f5				push af  
86b4 3a c8 86			ld a, (.dmark)  
86b7 32 71 ee			ld (debug_mark),a  
86ba 3a c9 86			ld a, (.dmark+1)  
86bd 32 72 ee			ld (debug_mark+1),a  
86c0 3a ca 86			ld a, (.dmark+2)  
86c3 32 73 ee			ld (debug_mark+2),a  
86c6 18 03			jr .pastdmark  
86c8 ..			.dmark: db "SCz"  
86cb f1			.pastdmark: pop af  
86cc			endm  
# End of macro DMARK
86cc					CALLMONITOR 
86cc cd 9d 94			call break_point_state  
86cf				endm  
# End of macro CALLMONITOR
86cf				endif 
86cf c9				ret 
86d0				 
86d0			 
86d0			 
86d0			; 
86d0			; Read File 
86d0			; 
86d0			; h - file id to locate 
86d0			; l - extent to locate 
86d0			; de - pointer to string to read into 
86d0			; 
86d0			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
86d0			 
86d0			.sr_fail: 
86d0 d1				pop de 
86d1 c9				ret 
86d2			 
86d2			storage_read: 
86d2			 
86d2			 
86d2 d5				push de 
86d3			 
86d3			; TODO BUG the above push is it popped before the RET Z? 
86d3			 
86d3			; TODO how to handle multiple part blocks 
86d3			 
86d3				; locate file extent to read 
86d3			 
86d3 5c				ld e, h 
86d4 55				ld d, l 
86d5			 
86d5			.srext: 
86d5 22 82 ea			ld (store_readptr), hl     ; save the current extent to load 
86d8 ed 53 80 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
86dc			 
86dc 21 40 00			ld hl, STORE_BLOCK_PHY 
86df				if DEBUG_STORESE 
86df					DMARK "sre" 
86df f5				push af  
86e0 3a f4 86			ld a, (.dmark)  
86e3 32 71 ee			ld (debug_mark),a  
86e6 3a f5 86			ld a, (.dmark+1)  
86e9 32 72 ee			ld (debug_mark+1),a  
86ec 3a f6 86			ld a, (.dmark+2)  
86ef 32 73 ee			ld (debug_mark+2),a  
86f2 18 03			jr .pastdmark  
86f4 ..			.dmark: db "sre"  
86f7 f1			.pastdmark: pop af  
86f8			endm  
# End of macro DMARK
86f8					CALLMONITOR 
86f8 cd 9d 94			call break_point_state  
86fb				endm  
# End of macro CALLMONITOR
86fb				endif 
86fb cd ac 84			call storage_findnextid 
86fe			 
86fe				if DEBUG_STORESE 
86fe					DMARK "srf" 
86fe f5				push af  
86ff 3a 13 87			ld a, (.dmark)  
8702 32 71 ee			ld (debug_mark),a  
8705 3a 14 87			ld a, (.dmark+1)  
8708 32 72 ee			ld (debug_mark+1),a  
870b 3a 15 87			ld a, (.dmark+2)  
870e 32 73 ee			ld (debug_mark+2),a  
8711 18 03			jr .pastdmark  
8713 ..			.dmark: db "srf"  
8716 f1			.pastdmark: pop af  
8717			endm  
# End of macro DMARK
8717					CALLMONITOR 
8717 cd 9d 94			call break_point_state  
871a				endm  
# End of macro CALLMONITOR
871a				endif 
871a cd c5 8c			call ishlzero 
871d			;	ld a, l 
871d			;	add h 
871d			;	cp 0 
871d 28 b1			jr z,.sr_fail			; block not found so EOF 
871f			 
871f				; hl contains page number to load 
871f d1				pop de   ; get storage 
8720 ed 53 80 ea		ld (store_readbuf), de     ; current buffer to load in to 
8724 d5				push de 
8725				if DEBUG_STORESE 
8725					DMARK "srg" 
8725 f5				push af  
8726 3a 3a 87			ld a, (.dmark)  
8729 32 71 ee			ld (debug_mark),a  
872c 3a 3b 87			ld a, (.dmark+1)  
872f 32 72 ee			ld (debug_mark+1),a  
8732 3a 3c 87			ld a, (.dmark+2)  
8735 32 73 ee			ld (debug_mark+2),a  
8738 18 03			jr .pastdmark  
873a ..			.dmark: db "srg"  
873d f1			.pastdmark: pop af  
873e			endm  
# End of macro DMARK
873e					CALLMONITOR 
873e cd 9d 94			call break_point_state  
8741				endm  
# End of macro CALLMONITOR
8741				endif 
8741 cd 79 81			call storage_read_block 
8744			 
8744				; if this a continuation read??? 
8744			 
8744 2a 80 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
8747			 
8747 3e 3f			ld a, STORE_BLOCK_PHY-1 
8749 cd 9c 8c			call addatohl 
874c 7e				ld a,(hl) 
874d fe 00			cp 0 
874f 28 02			jr z, .markiscont 
8751 3e ff			ld a, 255 
8753			 
8753			.markiscont: 
8753 32 77 ea			ld (store_readcont), a 
8756			 
8756				if DEBUG_STORESE 
8756					DMARK "srC" 
8756 f5				push af  
8757 3a 6b 87			ld a, (.dmark)  
875a 32 71 ee			ld (debug_mark),a  
875d 3a 6c 87			ld a, (.dmark+1)  
8760 32 72 ee			ld (debug_mark+1),a  
8763 3a 6d 87			ld a, (.dmark+2)  
8766 32 73 ee			ld (debug_mark+2),a  
8769 18 03			jr .pastdmark  
876b ..			.dmark: db "srC"  
876e f1			.pastdmark: pop af  
876f			endm  
# End of macro DMARK
876f					CALLMONITOR 
876f cd 9d 94			call break_point_state  
8772				endm  
# End of macro CALLMONITOR
8772				endif 
8772				; only short reads enabled 
8772			 
8772 3a 7f ea			ld a, (store_longread) 
8775 fe 00			cp 0 
8777 ca 41 88			jp z, .readdone 
877a			 
877a			; TODO if block has no zeros then need to read next block  
877a			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
877a			; check last byte of physical block. 
877a			; if not zero then the next block needs to be loaded 
877a			 
877a			 
877a 2a 80 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
877d			 
877d 3e 3f			ld a, STORE_BLOCK_PHY-1 
877f cd 9c 8c			call addatohl 
8782				;dec hl 
8782 7e				ld a,(hl) 
8783				if DEBUG_STORESE 
8783					DMARK "sr?" 
8783 f5				push af  
8784 3a 98 87			ld a, (.dmark)  
8787 32 71 ee			ld (debug_mark),a  
878a 3a 99 87			ld a, (.dmark+1)  
878d 32 72 ee			ld (debug_mark+1),a  
8790 3a 9a 87			ld a, (.dmark+2)  
8793 32 73 ee			ld (debug_mark+2),a  
8796 18 03			jr .pastdmark  
8798 ..			.dmark: db "sr?"  
879b f1			.pastdmark: pop af  
879c			endm  
# End of macro DMARK
879c					CALLMONITOR 
879c cd 9d 94			call break_point_state  
879f				endm  
# End of macro CALLMONITOR
879f				endif 
879f fe 00			cp 0 
87a1 ca 41 88			jp z, .readdone 
87a4			 
87a4				; last byte is not zero so there is more in the next extent. Load it on the end.	 
87a4			 
87a4 23				inc hl 
87a5			 
87a5 22 80 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
87a8			 
87a8 ed 5b 82 ea		ld de, (store_readptr)     ; save the current extent to load 
87ac			 
87ac eb				ex de, hl 
87ad			 
87ad				; next ext 
87ad			 
87ad 23				inc hl 
87ae 22 82 ea			ld  (store_readptr), hl     ; save the current extent to load 
87b1			 
87b1				if DEBUG_STORESE 
87b1					DMARK "sF2" 
87b1 f5				push af  
87b2 3a c6 87			ld a, (.dmark)  
87b5 32 71 ee			ld (debug_mark),a  
87b8 3a c7 87			ld a, (.dmark+1)  
87bb 32 72 ee			ld (debug_mark+1),a  
87be 3a c8 87			ld a, (.dmark+2)  
87c1 32 73 ee			ld (debug_mark+2),a  
87c4 18 03			jr .pastdmark  
87c6 ..			.dmark: db "sF2"  
87c9 f1			.pastdmark: pop af  
87ca			endm  
# End of macro DMARK
87ca					CALLMONITOR 
87ca cd 9d 94			call break_point_state  
87cd				endm  
# End of macro CALLMONITOR
87cd				endif 
87cd			 
87cd				; get and load block 
87cd			 
87cd cd ac 84			call storage_findnextid 
87d0			 
87d0				if DEBUG_STORESE 
87d0					DMARK "sf2" 
87d0 f5				push af  
87d1 3a e5 87			ld a, (.dmark)  
87d4 32 71 ee			ld (debug_mark),a  
87d7 3a e6 87			ld a, (.dmark+1)  
87da 32 72 ee			ld (debug_mark+1),a  
87dd 3a e7 87			ld a, (.dmark+2)  
87e0 32 73 ee			ld (debug_mark+2),a  
87e3 18 03			jr .pastdmark  
87e5 ..			.dmark: db "sf2"  
87e8 f1			.pastdmark: pop af  
87e9			endm  
# End of macro DMARK
87e9					CALLMONITOR 
87e9 cd 9d 94			call break_point_state  
87ec				endm  
# End of macro CALLMONITOR
87ec				endif 
87ec cd c5 8c			call ishlzero 
87ef			;	ld a, l 
87ef			;	add h 
87ef			;	cp 0 
87ef ca d0 86			jp z,.sr_fail			; block not found so EOF 
87f2				 
87f2 cd 79 81			call storage_read_block 
87f5			 
87f5				; on a continuation block, we now have the file id and ext in the middle of the block 
87f5				; we need to pull everything back  
87f5			 
87f5 ed 5b 80 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
87f9 2a 80 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
87fc 23				inc hl 
87fd 23				inc hl     ; skip id and ext 
87fe 01 40 00			ld bc, STORE_BLOCK_PHY 
8801				if DEBUG_STORESE 
8801					DMARK "SR<" 
8801 f5				push af  
8802 3a 16 88			ld a, (.dmark)  
8805 32 71 ee			ld (debug_mark),a  
8808 3a 17 88			ld a, (.dmark+1)  
880b 32 72 ee			ld (debug_mark+1),a  
880e 3a 18 88			ld a, (.dmark+2)  
8811 32 73 ee			ld (debug_mark+2),a  
8814 18 03			jr .pastdmark  
8816 ..			.dmark: db "SR<"  
8819 f1			.pastdmark: pop af  
881a			endm  
# End of macro DMARK
881a					CALLMONITOR 
881a cd 9d 94			call break_point_state  
881d				endm  
# End of macro CALLMONITOR
881d				endif 
881d ed b0			ldir     ; copy data 
881f			 
881f				; move the pointer back and pretend we have a full buffer for next recheck 
881f			 
881f 1b				dec de 
8820 1b				dec de 
8821			 
8821			; TODO do pop below now short circuit loop????? 
8821 c1				pop bc     ; get rid of spare de on stack 
8822				if DEBUG_STORESE 
8822					DMARK "SR>" 
8822 f5				push af  
8823 3a 37 88			ld a, (.dmark)  
8826 32 71 ee			ld (debug_mark),a  
8829 3a 38 88			ld a, (.dmark+1)  
882c 32 72 ee			ld (debug_mark+1),a  
882f 3a 39 88			ld a, (.dmark+2)  
8832 32 73 ee			ld (debug_mark+2),a  
8835 18 03			jr .pastdmark  
8837 ..			.dmark: db "SR>"  
883a f1			.pastdmark: pop af  
883b			endm  
# End of macro DMARK
883b					CALLMONITOR 
883b cd 9d 94			call break_point_state  
883e				endm  
# End of macro CALLMONITOR
883e				endif 
883e c3 d5 86			jp .srext 
8841			 
8841			 
8841			 
8841			 
8841			 
8841			.readdone:		 
8841 e1				pop hl 		 ; return start of data to show as not EOF 
8842 23				inc hl   ; past file id 
8843 23				inc hl   ; past ext 
8844				if DEBUG_STORESE 
8844					DMARK "SRe" 
8844 f5				push af  
8845 3a 59 88			ld a, (.dmark)  
8848 32 71 ee			ld (debug_mark),a  
884b 3a 5a 88			ld a, (.dmark+1)  
884e 32 72 ee			ld (debug_mark+1),a  
8851 3a 5b 88			ld a, (.dmark+2)  
8854 32 73 ee			ld (debug_mark+2),a  
8857 18 03			jr .pastdmark  
8859 ..			.dmark: db "SRe"  
885c f1			.pastdmark: pop af  
885d			endm  
# End of macro DMARK
885d					CALLMONITOR 
885d cd 9d 94			call break_point_state  
8860				endm  
# End of macro CALLMONITOR
8860				endif 
8860 c9					ret 
8861			 
8861			 
8861			 
8861			; 
8861			; Append File 
8861			; 
8861			; hl - file id to locate 
8861			; de - pointer to (multi block) string to write 
8861			 
8861			.sa_notfound: 
8861 d1				pop de 
8862 c9				ret 
8863			 
8863			 
8863			storage_append: 
8863				; hl -  file id to append to 
8863				; de - string to append 
8863			 
8863 d5				push de 
8864				 
8864				if DEBUG_STORESE 
8864					DMARK "AP1" 
8864 f5				push af  
8865 3a 79 88			ld a, (.dmark)  
8868 32 71 ee			ld (debug_mark),a  
886b 3a 7a 88			ld a, (.dmark+1)  
886e 32 72 ee			ld (debug_mark+1),a  
8871 3a 7b 88			ld a, (.dmark+2)  
8874 32 73 ee			ld (debug_mark+2),a  
8877 18 03			jr .pastdmark  
8879 ..			.dmark: db "AP1"  
887c f1			.pastdmark: pop af  
887d			endm  
# End of macro DMARK
887d					CALLMONITOR 
887d cd 9d 94			call break_point_state  
8880				endm  
# End of macro CALLMONITOR
8880				endif 
8880			 
8880 7d				ld a, l 
8881 32 78 ea			ld (store_tmpid), a 
8884			 
8884				; get file header  
8884			 
8884 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
8886 3a 78 ea			ld a, (store_tmpid) 
8889 5f				ld e, a 
888a			 
888a 21 40 00				ld hl, STORE_BLOCK_PHY 
888d cd ac 84				call storage_findnextid 
8890			 
8890 cd c5 8c			call ishlzero 
8893 28 cc			jr z, .sa_notfound 
8895			 
8895 22 71 ea			ld (store_tmppageid), hl 
8898			 
8898				; TODO handle file id not found 
8898			 
8898				if DEBUG_STORESE 
8898					DMARK "AP2" 
8898 f5				push af  
8899 3a ad 88			ld a, (.dmark)  
889c 32 71 ee			ld (debug_mark),a  
889f 3a ae 88			ld a, (.dmark+1)  
88a2 32 72 ee			ld (debug_mark+1),a  
88a5 3a af 88			ld a, (.dmark+2)  
88a8 32 73 ee			ld (debug_mark+2),a  
88ab 18 03			jr .pastdmark  
88ad ..			.dmark: db "AP2"  
88b0 f1			.pastdmark: pop af  
88b1			endm  
# End of macro DMARK
88b1					CALLMONITOR 
88b1 cd 9d 94			call break_point_state  
88b4				endm  
# End of macro CALLMONITOR
88b4				endif 
88b4			 
88b4				; update file extent count 
88b4			 
88b4 11 84 ea			ld de, store_page 
88b7			 
88b7 cd 79 81			call storage_read_block 
88ba			 
88ba				if DEBUG_STORESE 
88ba					DMARK "AP3" 
88ba f5				push af  
88bb 3a cf 88			ld a, (.dmark)  
88be 32 71 ee			ld (debug_mark),a  
88c1 3a d0 88			ld a, (.dmark+1)  
88c4 32 72 ee			ld (debug_mark+1),a  
88c7 3a d1 88			ld a, (.dmark+2)  
88ca 32 73 ee			ld (debug_mark+2),a  
88cd 18 03			jr .pastdmark  
88cf ..			.dmark: db "AP3"  
88d2 f1			.pastdmark: pop af  
88d3			endm  
# End of macro DMARK
88d3					CALLMONITOR 
88d3 cd 9d 94			call break_point_state  
88d6				endm  
# End of macro CALLMONITOR
88d6				endif 
88d6			;	ld (store_tmppageid), hl 
88d6			 
88d6 3a 86 ea			ld a, (store_page+2) 
88d9 3c				inc a 
88da 32 86 ea			ld (store_page+2), a 
88dd 32 77 ea			ld (store_tmpext), a 
88e0				 
88e0				if DEBUG_STORESE 
88e0					DMARK "AP3" 
88e0 f5				push af  
88e1 3a f5 88			ld a, (.dmark)  
88e4 32 71 ee			ld (debug_mark),a  
88e7 3a f6 88			ld a, (.dmark+1)  
88ea 32 72 ee			ld (debug_mark+1),a  
88ed 3a f7 88			ld a, (.dmark+2)  
88f0 32 73 ee			ld (debug_mark+2),a  
88f3 18 03			jr .pastdmark  
88f5 ..			.dmark: db "AP3"  
88f8 f1			.pastdmark: pop af  
88f9			endm  
# End of macro DMARK
88f9					CALLMONITOR 
88f9 cd 9d 94			call break_point_state  
88fc				endm  
# End of macro CALLMONITOR
88fc				endif 
88fc 2a 71 ea			ld hl, (store_tmppageid) 
88ff 11 84 ea			ld de, store_page 
8902 cd de 81			call storage_write_block 
8905			 
8905				; find free block 
8905			 
8905 11 00 00			ld de, 0			 ; file extent to locate 
8908			 
8908 21 40 00				ld hl, STORE_BLOCK_PHY 
890b cd ac 84				call storage_findnextid 
890e cd c5 8c			call ishlzero 
8911 ca 61 88			jp z, .sa_notfound 
8914			 
8914					; TODO handle no space left 
8914					 
8914 22 71 ea				ld (store_tmppageid), hl 
8917			 
8917				if DEBUG_STORESE 
8917					DMARK "AP4" 
8917 f5				push af  
8918 3a 2c 89			ld a, (.dmark)  
891b 32 71 ee			ld (debug_mark),a  
891e 3a 2d 89			ld a, (.dmark+1)  
8921 32 72 ee			ld (debug_mark+1),a  
8924 3a 2e 89			ld a, (.dmark+2)  
8927 32 73 ee			ld (debug_mark+2),a  
892a 18 03			jr .pastdmark  
892c ..			.dmark: db "AP4"  
892f f1			.pastdmark: pop af  
8930			endm  
# End of macro DMARK
8930					CALLMONITOR 
8930 cd 9d 94			call break_point_state  
8933				endm  
# End of macro CALLMONITOR
8933				endif 
8933					; init the buffer with zeros so we can id if the buffer is full or not 
8933			 
8933 e5					push hl 
8934 c5					push bc 
8935			 
8935 21 84 ea				ld hl, store_page 
8938 06 40				ld b, STORE_BLOCK_PHY 
893a 3e 00				ld a, 0 
893c 77			.zeroblock:	ld (hl), a 
893d 23					inc hl 
893e 10 fc				djnz .zeroblock 
8940			 
8940 c1					pop bc 
8941 e1					pop hl 
8942			 
8942					; construct block 
8942			 
8942 3a 78 ea				ld a, (store_tmpid) 
8945 32 84 ea				ld (store_page), a   ; file id 
8948 3a 77 ea				ld a, (store_tmpext)   ; extent for this block 
894b 32 85 ea				ld (store_page+1), a 
894e			 
894e e1					pop hl    ; get string to write 
894f 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8951 11 86 ea				ld de, store_page+2 
8954			 
8954				if DEBUG_STORESE 
8954					DMARK "AP5" 
8954 f5				push af  
8955 3a 69 89			ld a, (.dmark)  
8958 32 71 ee			ld (debug_mark),a  
895b 3a 6a 89			ld a, (.dmark+1)  
895e 32 72 ee			ld (debug_mark+1),a  
8961 3a 6b 89			ld a, (.dmark+2)  
8964 32 73 ee			ld (debug_mark+2),a  
8967 18 03			jr .pastdmark  
8969 ..			.dmark: db "AP5"  
896c f1			.pastdmark: pop af  
896d			endm  
# End of macro DMARK
896d					CALLMONITOR 
896d cd 9d 94			call break_point_state  
8970				endm  
# End of macro CALLMONITOR
8970				endif 
8970			 
8970			 
8970			 
8970					; fill buffer with data until end of string or full block 
8970			 
8970 7e			.appd:		ld a, (hl) 
8971 12					ld (de), a 
8972 fe 00				cp 0 
8974 28 04				jr z, .appdone 
8976 23					inc hl 
8977 13					inc de 
8978 10 f6				djnz .appd 
897a			 
897a e5			.appdone:	push hl		 	; save current source in case we need to go around again 
897b f5					push af   		; save last byte dumped 
897c			 
897c			 
897c 2a 71 ea			ld hl, (store_tmppageid) 
897f 11 84 ea			ld de, store_page 
8982				if DEBUG_STORESE 
8982					DMARK "AP6" 
8982 f5				push af  
8983 3a 97 89			ld a, (.dmark)  
8986 32 71 ee			ld (debug_mark),a  
8989 3a 98 89			ld a, (.dmark+1)  
898c 32 72 ee			ld (debug_mark+1),a  
898f 3a 99 89			ld a, (.dmark+2)  
8992 32 73 ee			ld (debug_mark+2),a  
8995 18 03			jr .pastdmark  
8997 ..			.dmark: db "AP6"  
899a f1			.pastdmark: pop af  
899b			endm  
# End of macro DMARK
899b					CALLMONITOR 
899b cd 9d 94			call break_point_state  
899e				endm  
# End of macro CALLMONITOR
899e				endif 
899e cd de 81				call storage_write_block 
89a1			 
89a1			 
89a1				; was that a full block of data written? 
89a1				; any more to write out? 
89a1			 
89a1				; if yes then set vars and jump to start of function again 
89a1			 
89a1 f1					pop af 
89a2 d1					pop de 
89a3			 
89a3 fe 00				cp 0		 ; no, string was fully written 
89a5 c8					ret z 
89a6			 
89a6					; setup vars for next cycle 
89a6			 
89a6 3a 78 ea				ld a, (store_tmpid) 
89a9 6f					ld l, a 
89aa 26 00				ld h, 0 
89ac			 
89ac c3 63 88			 	jp storage_append	 ; yes, need to write out some more 
89af			 
89af			 
89af			 
89af			 
89af			 
89af			 
89af			 
89af			if DEBUG_STORECF 
89af			storageput:	 
89af					ret 
89af			storageread: 
89af					ld hl, store_page 
89af					ld b, 200 
89af					ld a,0 
89af			.src:		ld (hl),a 
89af					inc hl 
89af					djnz .src 
89af					 
89af			 
89af					ld de, 0 
89af					ld bc, 1 
89af					ld hl, store_page 
89af					call cfRead 
89af			 
89af				call cfGetError 
89af				ld hl,scratch 
89af				call hexout 
89af				ld hl, scratch+2 
89af				ld a, 0 
89af				ld (hl),a 
89af				ld de, scratch 
89af				ld a,display_row_1 
89af				call str_at_display 
89af				call update_display 
89af			 
89af					ld hl, store_page 
89af					ld (os_cur_ptr),hl 
89af			 
89af					ret 
89af			endif 
89af			 
89af			 
89af			; Clear out the main buffer store (used to remove junk before writing a new block) 
89af			 
89af			storage_clear_page: 
89af e5				push hl 
89b0 d5				push de 
89b1 c5				push bc 
89b2 21 84 ea			ld hl, store_page 
89b5 3e 00			ld a, 0 
89b7 77				ld (hl), a 
89b8			 
89b8 11 85 ea			ld de, store_page+1 
89bb 01 18 01			ld bc, STORE_BLOCK_LOG 
89be			 
89be ed b0			ldir 
89c0				 
89c0 c1				pop bc 
89c1 d1				pop de 
89c2 e1				pop hl 
89c3 c9				ret 
89c4			 
89c4			; eof 
# End of file firmware_storage.asm
89c4			  
89c4			; support routines for above hardware abstraction layer  
89c4			  
89c4			include "firmware_general.asm"        ; general support functions  
89c4			 
89c4			; word look up 
89c4			 
89c4			; in 
89c4			; a is the index 
89c4			; hl is pointer start of array 
89c4			; 
89c4			; returns 
89c4			; hl to the word 
89c4			; 
89c4			 
89c4			table_lookup:  
89c4 d5					push de 
89c5 eb					ex de, hl 
89c6			 
89c6 6f					ld l, a 
89c7 26 00				ld h, 0 
89c9 29					add hl, hl 
89ca 19					add hl, de 
89cb 7e					ld a, (hl) 
89cc 23					inc hl 
89cd 66					ld h,(hl) 
89ce 6f					ld l, a 
89cf			 
89cf d1					pop de 
89d0 c9					ret 
89d1			 
89d1			; Delay loops 
89d1			 
89d1			 
89d1			 
89d1			aDelayInMS: 
89d1 c5				push bc 
89d2 47				ld b,a 
89d3			msdelay: 
89d3 c5				push bc 
89d4				 
89d4			 
89d4 01 41 00			ld bc,041h 
89d7 cd ef 89			call delayloop 
89da c1				pop bc 
89db 05				dec b 
89dc 20 f5			jr nz,msdelay 
89de			 
89de			;if CPU_CLOCK_8MHZ 
89de			;msdelay8: 
89de			;	push bc 
89de			;	 
89de			; 
89de			;	ld bc,041h 
89de			;	call delayloop 
89de			;	pop bc 
89de			;	dec b 
89de			;	jr nz,msdelay8 
89de			;endif 
89de			 
89de			 
89de c1				pop bc 
89df c9				ret 
89e0			 
89e0			 
89e0			delay250ms: 
89e0				;push de 
89e0 01 00 40			ld bc, 04000h 
89e3 c3 ef 89			jp delayloop 
89e6			delay500ms: 
89e6				;push de 
89e6 01 00 80			ld bc, 08000h 
89e9 c3 ef 89			jp delayloop 
89ec			delay1s: 
89ec				;push bc 
89ec			   ; Clobbers A, d and e 
89ec 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
89ef			delayloop: 
89ef c5			    push bc 
89f0			 
89f0			if BASE_CPM 
89f0				ld bc, CPM_DELAY_TUNE 
89f0			.cpmloop: 
89f0				push bc 
89f0			 
89f0			endif 
89f0			 
89f0			 
89f0			 
89f0			delayloopi: 
89f0			;	push bc 
89f0			;.dl: 
89f0 cb 47		    bit     0,a    	; 8 
89f2 cb 47		    bit     0,a    	; 8 
89f4 cb 47		    bit     0,a    	; 8 
89f6 e6 ff		    and     255  	; 7 
89f8 0b			    dec     bc      	; 6 
89f9 79			    ld      a,c     	; 4 
89fa b0			    or      b     	; 4 
89fb c2 f0 89		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
89fe			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
89fe				;pop de 
89fe			;pop bc 
89fe			 
89fe			if BASE_CPM 
89fe				pop bc 
89fe				 
89fe			    dec     bc      	; 6 
89fe			    ld      a,c     	; 4 
89fe			    or      b     	; 4 
89fe			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
89fe				 
89fe			 
89fe			endif 
89fe			;if CPU_CLOCK_8MHZ 
89fe			;    pop bc 
89fe			;    push bc 
89fe			;.dl8: 
89fe			;    bit     0,a    	; 8 
89fe			;    bit     0,a    	; 8 
89fe			;    bit     0,a    	; 8 
89fe			;    and     255  	; 7 
89fe			;    dec     bc      	; 6 
89fe			;    ld      a,c     	; 4 
89fe			;    or      b     	; 4 
89fe			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
89fe			;endif 
89fe			 
89fe			;if CPU_CLOCK_10MHZ 
89fe			;    pop bc 
89fe			;    push bc 
89fe			;.dl8: 
89fe			;    bit     0,a    	; 8 
89fe			;    bit     0,a    	; 8 
89fe			;    bit     0,a    	; 8 
89fe			;    and     255  	; 7 
89fe			;    dec     bc      	; 6 
89fe			;    ld      a,c     	; 4 
89fe			;    or      b     	; 4 
89fe			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
89fe			;endif 
89fe c1			    pop bc 
89ff			 
89ff c9				ret 
8a00			 
8a00			 
8a00			 
8a00			; eof 
# End of file firmware_general.asm
8a00			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8a00			; display routines that use the physical hardware abstraction layer 
8a00			 
8a00			 
8a00			; information window 
8a00			 
8a00			; pass hl with 1st string to display 
8a00			; pass de with 2nd string to display 
8a00			 
8a00			info_panel: 
8a00 e5				push hl 
8a01			 
8a01 2a d2 eb			ld hl, (display_fb_active) 
8a04 e5				push hl    ; future de destination 
8a05 21 b7 ed				ld hl, display_fb0 
8a08 22 d2 eb				ld (display_fb_active), hl 
8a0b			 
8a0b			;	call clear_display 
8a0b			 
8a0b				if BASE_CPM 
8a0b				ld a, '.' 
8a0b				else 
8a0b 3e a5			ld a, 165 
8a0d				endif 
8a0d cd 74 8a			call fill_display 
8a10			 
8a10			 
8a10 3e 55			ld a, display_row_3 + 5 
8a12 cd 82 8a			call str_at_display 
8a15			 
8a15 e1				pop hl 
8a16 d1				pop de 
8a17			 
8a17 e5				push hl 
8a18			 
8a18			 
8a18 3e 2d			ld a, display_row_2 + 5 
8a1a cd 82 8a			call str_at_display 
8a1d			 
8a1d			 
8a1d cd 92 8a			call update_display 
8a20 cd 86 9a			call next_page_prompt 
8a23 cd 6f 8a			call clear_display 
8a26			 
8a26				 
8a26 21 16 ed				ld hl, display_fb1 
8a29 22 d2 eb				ld (display_fb_active), hl 
8a2c cd 92 8a			call update_display 
8a2f			 
8a2f e1				pop hl 
8a30			 
8a30 c9				ret 
8a31			 
8a31			 
8a31			 
8a31			 
8a31			; TODO windowing? 
8a31			 
8a31			; TODO scroll line up 
8a31			 
8a31			scroll_up: 
8a31			 
8a31 e5				push hl 
8a32 d5				push de 
8a33 c5				push bc 
8a34			 
8a34				; get frame buffer  
8a34			 
8a34 2a d2 eb			ld hl, (display_fb_active) 
8a37 e5				push hl    ; future de destination 
8a38			 
8a38 11 28 00			ld  de, display_cols 
8a3b 19				add hl, de 
8a3c			 
8a3c d1				pop de 
8a3d			 
8a3d				;ex de, hl 
8a3d 01 9f 00			ld bc, display_fb_len -1  
8a40			;if DEBUG_FORTH_WORDS 
8a40			;	DMARK "SCL" 
8a40			;	CALLMONITOR 
8a40			;endif	 
8a40 ed b0			ldir 
8a42			 
8a42				; wipe bottom row 
8a42			 
8a42			 
8a42 2a d2 eb			ld hl, (display_fb_active) 
8a45 11 a0 00			ld de, display_cols*display_rows 
8a48 19				add hl, de 
8a49 06 28			ld b, display_cols 
8a4b 3e 20			ld a, ' ' 
8a4d			.scwipe: 
8a4d 77				ld (hl), a 
8a4e 2b				dec hl 
8a4f 10 fc			djnz .scwipe 
8a51			 
8a51				;pop hl 
8a51			 
8a51 c1				pop bc 
8a52 d1				pop de 
8a53 e1				pop hl 
8a54			 
8a54 c9				ret 
8a55			 
8a55			 
8a55			;scroll_upo: 
8a55			;	ld de, display_row_1 
8a55			 ;	ld hl, display_row_2 
8a55			;	ld bc, display_cols 
8a55			;	ldir 
8a55			;	ld de, display_row_2 
8a55			 ;	ld hl, display_row_3 
8a55			;	ld bc, display_cols 
8a55			;	ldir 
8a55			;	ld de, display_row_3 
8a55			 ;	ld hl, display_row_4 
8a55			;	ld bc, display_cols 
8a55			;	ldir 
8a55			 
8a55			; TODO clear row 4 
8a55			 
8a55			;	ret 
8a55			 
8a55				 
8a55			scroll_down: 
8a55			 
8a55 e5				push hl 
8a56 d5				push de 
8a57 c5				push bc 
8a58			 
8a58				; get frame buffer  
8a58			 
8a58 2a d2 eb			ld hl, (display_fb_active) 
8a5b			 
8a5b 11 9f 00			ld de, display_fb_len - 1 
8a5e 19				add hl, de 
8a5f			 
8a5f e5			push hl    ; future de destination 
8a60			 
8a60 11 28 00			ld  de, display_cols 
8a63 ed 52			sbc hl, de 
8a65			 
8a65			 
8a65 d1				pop de 
8a66			 
8a66			;	ex de, hl 
8a66 01 9f 00			ld bc, display_fb_len -1  
8a69			 
8a69			 
8a69				 
8a69			 
8a69 ed b0			ldir 
8a6b			 
8a6b				; wipe bottom row 
8a6b			 
8a6b			 
8a6b			;	ld hl, (display_fb_active) 
8a6b			;;	ld de, display_cols*display_rows 
8a6b			;;	add hl, de 
8a6b			;	ld b, display_cols 
8a6b			;	ld a, ' ' 
8a6b			;.scwiped: 
8a6b			;	ld (hl), a 
8a6b			;	dec hl 
8a6b			;	djnz .scwiped 
8a6b			 
8a6b				;pop hl 
8a6b			 
8a6b c1				pop bc 
8a6c d1				pop de 
8a6d e1				pop hl 
8a6e			 
8a6e c9				ret 
8a6f			;scroll_down: 
8a6f			;	ld de, display_row_4 
8a6f			;	ld hl, display_row_3 
8a6f			;	ld bc, display_cols 
8a6f			;	ldir 
8a6f			;	ld de, display_row_3 
8a6f			; 	ld hl, display_row_2 
8a6f			;	ld bc, display_cols 
8a6f			;	ldir 
8a6f			;	ld de, display_row_2 
8a6f			;	ld hl, display_row_1 
8a6f			;	ld bc, display_cols 
8a6f			;	ldir 
8a6f			;;; TODO clear row 1 
8a6f			;	ret 
8a6f			 
8a6f			 
8a6f			 
8a6f			 
8a6f			 
8a6f			; clear active frame buffer 
8a6f			 
8a6f			clear_display: 
8a6f 3e 20			ld a, ' ' 
8a71 c3 74 8a			jp fill_display 
8a74			 
8a74			; fill active frame buffer with a char in A 
8a74			 
8a74			fill_display: 
8a74 06 a0			ld b,display_fb_len 
8a76 2a d2 eb			ld hl, (display_fb_active) 
8a79 77			.fd1:	ld (hl),a 
8a7a 23				inc hl 
8a7b 10 fc			djnz .fd1 
8a7d 23				inc hl 
8a7e 3e 00			ld a,0 
8a80 77				ld (hl),a 
8a81			 
8a81			 
8a81 c9				ret 
8a82			; Write string (DE) at pos (A) to active frame buffer 
8a82			 
8a82 2a d2 eb		str_at_display:    ld hl,(display_fb_active) 
8a85 06 00					ld b,0 
8a87 4f					ld c,a 
8a88 09					add hl,bc 
8a89 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
8a8a b7			            OR   A              ;Null terminator? 
8a8b c8			            RET  Z              ;Yes, so finished 
8a8c 77					ld (hl),a 
8a8d 23				inc hl 
8a8e 13			            INC  DE             ;Point to next character 
8a8f 18 f8		            JR   .sad1     ;Repeat 
8a91 c9					ret 
8a92			 
8a92			; using current frame buffer write to physical display 
8a92			 
8a92			update_display: 
8a92 e5				push hl 
8a93 2a d2 eb			ld hl, (display_fb_active) 
8a96 cd 05 da			call write_display 
8a99 e1				pop hl 
8a9a c9				ret 
8a9b			 
8a9b			; TODO scrolling 
8a9b			 
8a9b			 
8a9b			; move cursor right one char 
8a9b			cursor_right: 
8a9b			 
8a9b				; TODO shift right 
8a9b				; TODO if beyond max col 
8a9b				; TODO       cursor_next_line 
8a9b			 
8a9b c9				ret 
8a9c			 
8a9c			 
8a9c			cursor_next_line: 
8a9c				; TODO first char 
8a9c				; TODO line down 
8a9c				; TODO if past last row 
8a9c				; TODO    scroll up 
8a9c			 
8a9c c9				ret 
8a9d			 
8a9d			cursor_left: 
8a9d				; TODO shift left 
8a9d				; TODO if beyond left  
8a9d				; TODO     cursor prev line 
8a9d				 
8a9d c9				ret 
8a9e			 
8a9e			cursor_prev_line: 
8a9e				; TODO last char 
8a9e				; TODO line up 
8a9e				; TODO if past first row 
8a9e				; TODO   scroll down 
8a9e			 
8a9e c9				ret 
8a9f			 
8a9f			 
8a9f			cout: 
8a9f				; A - char 
8a9f c9				ret 
8aa0			 
8aa0			 
8aa0			; Display a menu and allow item selection (optional toggle items) 
8aa0			; 
8aa0			; format: 
8aa0			; hl pointer to word array with zero term for items 
8aa0			; e.g.    db item1 
8aa0			;         db .... 
8aa0			;         db 0 
8aa0			; 
8aa0			; a = starting menu item  
8aa0			; 
8aa0			; de = pointer item toggle array   (todo) 
8aa0			; 
8aa0			; returns item selected in a 1-... 
8aa0			; returns 0 if back button pressed 
8aa0			; 
8aa0			; NOTE: Uses system frame buffer to display 
8aa0			; 
8aa0			; LEFT, Q = go back 
8aa0			; RIGHT, SPACE, CR = select 
8aa0			; UP, A - Up 
8aa0			; DOWN, Z - Down 
8aa0			 
8aa0			 
8aa0			 
8aa0			 
8aa0			 
8aa0			menu: 
8aa0			 
8aa0					; keep array pointer 
8aa0			 
8aa0 22 7d ea				ld (store_tmp1), hl 
8aa3 32 7b ea				ld (store_tmp2), a 
8aa6			 
8aa6					; check for key bounce 
8aa6			 
8aa6			if BASE_KEV 
8aa6			 
8aa6			.mbounce:	call cin 
8aa6					cp 0 
8aa6					jr nz, .mbounce 
8aa6			endif 
8aa6					; for ease use ex 
8aa6			 
8aa6					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
8aa6 21 b7 ed				ld hl, display_fb0 
8aa9 22 d2 eb				ld (display_fb_active), hl 
8aac			 
8aac cd 6f 8a		.mloop:		call clear_display 
8aaf cd 92 8a				call update_display 
8ab2			 
8ab2					; draw selection id '>' at 1 
8ab2			 
8ab2					; init start of list display 
8ab2			 
8ab2 3e 05				ld a, 5 
8ab4 32 79 ea				ld (store_tmp3), a   ; display row count 
8ab7 3a 7b ea				ld a,( store_tmp2) 
8aba 32 7c ea				ld (store_tmp2+1), a   ; display item count 
8abd			 
8abd					 
8abd			.mitem:	 
8abd			 
8abd			 
8abd 3a 7c ea				ld a,(store_tmp2+1) 
8ac0 6f					ld l, a 
8ac1 26 00				ld h, 0 
8ac3 29					add hl, hl 
8ac4 ed 5b 7d ea			ld de, (store_tmp1) 
8ac8 19					add hl, de 
8ac9 7e					ld a, (hl) 
8aca 23					inc hl 
8acb 66					ld h,(hl) 
8acc 6f					ld l, a 
8acd			 
8acd cd c5 8c				call ishlzero 
8ad0 28 1a				jr z, .mdone 
8ad2			 
8ad2 eb					ex de, hl 
8ad3 3a 79 ea				ld a, (store_tmp3) 
8ad6 cd 82 8a				call str_at_display 
8ad9					 
8ad9			 
8ad9					; next item 
8ad9 3a 7c ea				ld a, (store_tmp2+1) 
8adc 3c					inc a 
8add 32 7c ea				ld (store_tmp2+1), a   ; display item count 
8ae0			 
8ae0			 		; next row 
8ae0			 
8ae0 3a 79 ea				ld a, (store_tmp3) 
8ae3 c6 28				add display_cols 
8ae5 32 79 ea				ld (store_tmp3), a 
8ae8			 
8ae8					; at end of screen? 
8ae8			 
8ae8 fe 10				cp display_rows*4 
8aea 20 d1				jr nz, .mitem 
8aec			 
8aec			 
8aec			.mdone: 
8aec cd c5 8c				call ishlzero 
8aef 28 08				jr z, .nodn 
8af1			 
8af1 3e 78				ld a, display_row_4 
8af3 11 72 8b				ld de, .mdown 
8af6 cd 82 8a				call str_at_display 
8af9			 
8af9					; draw options to fill the screens with active item on line 1 
8af9					; if current option is 2 or more then display ^ in top 
8af9			 
8af9 3a 7b ea		.nodn:		ld a, (store_tmp2) 
8afc fe 00				cp 0 
8afe 28 08				jr z, .noup 
8b00			 
8b00 3e 00				ld a, 0 
8b02 11 70 8b				ld de, .mup 
8b05 cd 82 8a				call str_at_display 
8b08			 
8b08 3e 02		.noup:		ld a, 2 
8b0a 11 6e 8b				ld de, .msel 
8b0d cd 82 8a				call str_at_display 
8b10			 
8b10					; if current option + 1 is not null then display V in bottom 
8b10					; get key 
8b10 cd 92 8a				call update_display 
8b13			 
8b13			 
8b13					; handle key 
8b13			 
8b13 cd 91 da				call cin_wait 
8b16			 
8b16 fe 05				cp KEY_UP 
8b18 28 2b				jr z, .mgoup 
8b1a fe 61				cp 'a' 
8b1c 28 27				jr z, .mgoup 
8b1e fe 0a				cp KEY_DOWN 
8b20 28 32				jr z, .mgod 
8b22 fe 7a				cp 'z' 
8b24 28 2e				jr z, .mgod 
8b26 fe 20				cp ' ' 
8b28 28 34				jr z, .goend 
8b2a fe 0c				cp KEY_RIGHT 
8b2c 28 30				jr z, .goend 
8b2e fe 0d				cp KEY_CR 
8b30 28 2c				jr z, .goend 
8b32 fe 71				cp 'q' 
8b34 28 0b				jr z, .goback 
8b36			 
8b36 fe 0b				cp KEY_LEFT 
8b38 28 07				jr z, .goback 
8b3a fe 08				cp KEY_BS 
8b3c 28 03				jr z, .goback 
8b3e c3 ac 8a				jp .mloop 
8b41			 
8b41			.goback: 
8b41 3e 00			ld a, 0 
8b43 18 1d			jr .goend2 
8b45			 
8b45				; move up one 
8b45			.mgoup: 
8b45 3a 7b ea				ld a, (store_tmp2) 
8b48 fe 00				cp 0 
8b4a ca ac 8a				jp z, .mloop 
8b4d 3d					dec a 
8b4e 32 7b ea				ld (store_tmp2), a 
8b51 c3 ac 8a				jp .mloop 
8b54			 
8b54				; move down one 
8b54			.mgod: 
8b54 3a 7b ea				ld a, (store_tmp2) 
8b57 3c					inc a 
8b58 32 7b ea				ld (store_tmp2), a 
8b5b c3 ac 8a				jp .mloop 
8b5e			 
8b5e			 
8b5e			.goend: 
8b5e					; get selected item number 
8b5e			 
8b5e 3a 7b ea				ld a, (store_tmp2) 
8b61 3c					inc a 
8b62			 
8b62			.goend2: 
8b62 f5					push af 
8b63			 
8b63					; restore active fb 
8b63					; TODO BUG assumes fb1 
8b63			 
8b63 21 16 ed				ld hl, display_fb1 
8b66 22 d2 eb				ld (display_fb_active), hl 
8b69			 
8b69					; restore main regs 
8b69			 
8b69			 
8b69 cd 92 8a				call update_display 
8b6c			 
8b6c f1					pop af 
8b6d			 
8b6d c9				ret 
8b6e			 
8b6e .. 00		.msel:   db ">",0 
8b70 .. 00		.mup:   db "^",0 
8b72 .. 00		.mdown:   db "v",0 
8b74			 
8b74			 
8b74			; eof 
8b74			 
# End of file firmware_display.asm
8b74			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8b74			; random number generators 
8b74			 
8b74			 
8b74			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8b74			 
8b74			 
8b74			;-----> Generate a random number 
8b74			; output a=answer 0<=a<=255 
8b74			; all registers are preserved except: af 
8b74			random: 
8b74 e5			        push    hl 
8b75 d5			        push    de 
8b76 2a b4 eb		        ld      hl,(randData) 
8b79 ed 5f		        ld      a,r 
8b7b 57			        ld      d,a 
8b7c 5e			        ld      e,(hl) 
8b7d 19			        add     hl,de 
8b7e 85			        add     a,l 
8b7f ac			        xor     h 
8b80 22 b4 eb		        ld      (randData),hl 
8b83 d1			        pop     de 
8b84 e1			        pop     hl 
8b85 c9			        ret 
8b86			 
8b86			 
8b86			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
8b86			 
8b86			 
8b86			 
8b86			;------LFSR------ 
8b86			;James Montelongo 
8b86			;optimized by Spencer Putt 
8b86			;out: 
8b86			; a = 8 bit random number 
8b86			RandLFSR: 
8b86 21 ba eb		        ld hl,LFSRSeed+4 
8b89 5e			        ld e,(hl) 
8b8a 23			        inc hl 
8b8b 56			        ld d,(hl) 
8b8c 23			        inc hl 
8b8d 4e			        ld c,(hl) 
8b8e 23			        inc hl 
8b8f 7e			        ld a,(hl) 
8b90 47			        ld b,a 
8b91 cb 13		        rl e  
8b93 cb 12			rl d 
8b95 cb 11		        rl c  
8b97 17				rla 
8b98 cb 13		        rl e  
8b9a cb 12			rl d 
8b9c cb 11		        rl c  
8b9e 17				rla 
8b9f cb 13		        rl e  
8ba1 cb 12			rl d 
8ba3 cb 11		        rl c  
8ba5 17				rla 
8ba6 67			        ld h,a 
8ba7 cb 13		        rl e  
8ba9 cb 12			rl d 
8bab cb 11		        rl c  
8bad 17				rla 
8bae a8			        xor b 
8baf cb 13		        rl e  
8bb1 cb 12			rl d 
8bb3 ac			        xor h 
8bb4 a9			        xor c 
8bb5 aa			        xor d 
8bb6 21 bc eb		        ld hl,LFSRSeed+6 
8bb9 11 bd eb		        ld de,LFSRSeed+7 
8bbc 01 07 00		        ld bc,7 
8bbf ed b8		        lddr 
8bc1 12			        ld (de),a 
8bc2 c9			        ret 
8bc3			 
8bc3			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
8bc3			 
8bc3			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
8bc3			 
8bc3			 
8bc3			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
8bc3			 
8bc3			prng16: 
8bc3			;Inputs: 
8bc3			;   (seed1) contains a 16-bit seed value 
8bc3			;   (seed2) contains a NON-ZERO 16-bit seed value 
8bc3			;Outputs: 
8bc3			;   HL is the result 
8bc3			;   BC is the result of the LCG, so not that great of quality 
8bc3			;   DE is preserved 
8bc3			;Destroys: 
8bc3			;   AF 
8bc3			;cycle: 4,294,901,760 (almost 4.3 billion) 
8bc3			;160cc 
8bc3			;26 bytes 
8bc3 2a ae eb		    ld hl,(seed1) 
8bc6 44			    ld b,h 
8bc7 4d			    ld c,l 
8bc8 29			    add hl,hl 
8bc9 29			    add hl,hl 
8bca 2c			    inc l 
8bcb 09			    add hl,bc 
8bcc 22 ae eb		    ld (seed1),hl 
8bcf 2a ac eb		    ld hl,(seed2) 
8bd2 29			    add hl,hl 
8bd3 9f			    sbc a,a 
8bd4 e6 2d		    and %00101101 
8bd6 ad			    xor l 
8bd7 6f			    ld l,a 
8bd8 22 ac eb		    ld (seed2),hl 
8bdb 09			    add hl,bc 
8bdc c9			    ret 
8bdd			 
8bdd			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
8bdd			 
8bdd			rand32: 
8bdd			;Inputs: 
8bdd			;   (seed1_0) holds the lower 16 bits of the first seed 
8bdd			;   (seed1_1) holds the upper 16 bits of the first seed 
8bdd			;   (seed2_0) holds the lower 16 bits of the second seed 
8bdd			;   (seed2_1) holds the upper 16 bits of the second seed 
8bdd			;   **NOTE: seed2 must be non-zero 
8bdd			;Outputs: 
8bdd			;   HL is the result 
8bdd			;   BC,DE can be used as lower quality values, but are not independent of HL. 
8bdd			;Destroys: 
8bdd			;   AF 
8bdd			;Tested and passes all CAcert tests 
8bdd			;Uses a very simple 32-bit LCG and 32-bit LFSR 
8bdd			;it has a period of 18,446,744,069,414,584,320 
8bdd			;roughly 18.4 quintillion. 
8bdd			;LFSR taps: 0,2,6,7  = 11000101 
8bdd			;291cc 
8bdd			;seed1_0=$+1 
8bdd			;    ld hl,12345 
8bdd			;seed1_1=$+1 
8bdd			;    ld de,6789 
8bdd			;    ld b,h 
8bdd			;    ld c,l 
8bdd			;    add hl,hl \ rl e \ rl d 
8bdd			;    add hl,hl \ rl e \ rl d 
8bdd			;    inc l 
8bdd			;    add hl,bc 
8bdd			;    ld (seed1_0),hl 
8bdd			;    ld hl,(seed1_1) 
8bdd			;    adc hl,de 
8bdd			;    ld (seed1_1),hl 
8bdd			;    ex de,hl 
8bdd			;seed2_0=$+1 
8bdd			;    ld hl,9876 
8bdd			;seed2_1=$+1 
8bdd			;    ld bc,54321 
8bdd			;    add hl,hl \ rl c \ rl b 
8bdd			;    ld (seed2_1),bc 
8bdd			;    sbc a,a 
8bdd			;    and %11000101 
8bdd			;    xor l 
8bdd			;    ld l,a 
8bdd			;    ld (seed2_0),hl 
8bdd			;    ex de,hl 
8bdd			;    add hl,bc 
8bdd			;    ret 
8bdd			; 
8bdd			 
8bdd			; 16-bit xorshift pseudorandom number generator by John Metcalf 
8bdd			; 20 bytes, 86 cycles (excluding ret) 
8bdd			 
8bdd			; returns   hl = pseudorandom number 
8bdd			; corrupts   a 
8bdd			 
8bdd			; generates 16-bit pseudorandom numbers with a period of 65535 
8bdd			; using the xorshift method: 
8bdd			 
8bdd			; hl ^= hl << 7 
8bdd			; hl ^= hl >> 9 
8bdd			; hl ^= hl << 8 
8bdd			 
8bdd			; some alternative shift triplets which also perform well are: 
8bdd			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
8bdd			 
8bdd			;  org 32768 
8bdd			 
8bdd			xrnd: 
8bdd 2a b2 eb		  ld hl,(xrandc)       ; seed must not be 0 
8be0 3e 00		  ld a,0 
8be2 bd			  cp l 
8be3 20 02		  jr nz, .xrnd1 
8be5 2e 01		  ld l, 1 
8be7			.xrnd1: 
8be7			 
8be7 7c			  ld a,h 
8be8 1f			  rra 
8be9 7d			  ld a,l 
8bea 1f			  rra 
8beb ac			  xor h 
8bec 67			  ld h,a 
8bed 7d			  ld a,l 
8bee 1f			  rra 
8bef 7c			  ld a,h 
8bf0 1f			  rra 
8bf1 ad			  xor l 
8bf2 6f			  ld l,a 
8bf3 ac			  xor h 
8bf4 67			  ld h,a 
8bf5			 
8bf5 22 b2 eb		  ld (xrandc),hl 
8bf8			 
8bf8 c9			  ret 
8bf9			;  
8bf9			 
8bf9			 
8bf9			;;;; int maths 
8bf9			 
8bf9			; https://map.grauw.nl/articles/mult_div_shifts.php 
8bf9			; Divide 16-bit values (with 16-bit result) 
8bf9			; In: Divide BC by divider DE 
8bf9			; Out: BC = result, HL = rest 
8bf9			; 
8bf9			Div16: 
8bf9 21 00 00		    ld hl,0 
8bfc 78			    ld a,b 
8bfd 06 08		    ld b,8 
8bff			Div16_Loop1: 
8bff 17			    rla 
8c00 ed 6a		    adc hl,hl 
8c02 ed 52		    sbc hl,de 
8c04 30 01		    jr nc,Div16_NoAdd1 
8c06 19			    add hl,de 
8c07			Div16_NoAdd1: 
8c07 10 f6		    djnz Div16_Loop1 
8c09 17			    rla 
8c0a 2f			    cpl 
8c0b 47			    ld b,a 
8c0c 79			    ld a,c 
8c0d 48			    ld c,b 
8c0e 06 08		    ld b,8 
8c10			Div16_Loop2: 
8c10 17			    rla 
8c11 ed 6a		    adc hl,hl 
8c13 ed 52		    sbc hl,de 
8c15 30 01		    jr nc,Div16_NoAdd2 
8c17 19			    add hl,de 
8c18			Div16_NoAdd2: 
8c18 10 f6		    djnz Div16_Loop2 
8c1a 17			    rla 
8c1b 2f			    cpl 
8c1c 41			    ld b,c 
8c1d 4f			    ld c,a 
8c1e c9			ret 
8c1f			 
8c1f			 
8c1f			;http://z80-heaven.wikidot.com/math 
8c1f			; 
8c1f			;Inputs: 
8c1f			;     DE and A are factors 
8c1f			;Outputs: 
8c1f			;     A is not changed 
8c1f			;     B is 0 
8c1f			;     C is not changed 
8c1f			;     DE is not changed 
8c1f			;     HL is the product 
8c1f			;Time: 
8c1f			;     342+6x 
8c1f			; 
8c1f			Mult16: 
8c1f			 
8c1f 06 08		     ld b,8          ;7           7 
8c21 21 00 00		     ld hl,0         ;10         10 
8c24 29			       add hl,hl     ;11*8       88 
8c25 07			       rlca          ;4*8        32 
8c26 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8c28 19			         add hl,de   ;--         -- 
8c29 10 f9		       djnz $-5      ;13*7+8     99 
8c2b c9			ret 
8c2c			 
8c2c			; 
8c2c			; Square root of 16-bit value 
8c2c			; In:  HL = value 
8c2c			; Out:  D = result (rounded down) 
8c2c			; 
8c2c			;Sqr16: 
8c2c			;    ld de,#0040 
8c2c			;    ld a,l 
8c2c			;    ld l,h 
8c2c			;    ld h,d 
8c2c			;    or a 
8c2c			;    ld b,8 
8c2c			;Sqr16_Loop: 
8c2c			;    sbc hl,de 
8c2c			;    jr nc,Sqr16_Skip 
8c2c			;    add hl,de 
8c2c			;Sqr16_Skip: 
8c2c			;    ccf 
8c2c			;    rl d 
8c2c			;    add a,a 
8c2c			;    adc hl,hl 
8c2c			;    add a,a 
8c2c			;    adc hl,hl 
8c2c			;    djnz Sqr16_Loop 
8c2c			;    ret 
8c2c			; 
8c2c			; 
8c2c			; Divide 8-bit values 
8c2c			; In: Divide E by divider C 
8c2c			; Out: A = result, B = rest 
8c2c			; 
8c2c			Div8: 
8c2c af			    xor a 
8c2d 06 08		    ld b,8 
8c2f			Div8_Loop: 
8c2f cb 13		    rl e 
8c31 17			    rla 
8c32 91			    sub c 
8c33 30 01		    jr nc,Div8_NoAdd 
8c35 81			    add a,c 
8c36			Div8_NoAdd: 
8c36 10 f7		    djnz Div8_Loop 
8c38 47			    ld b,a 
8c39 7b			    ld a,e 
8c3a 17			    rla 
8c3b 2f			    cpl 
8c3c c9			    ret 
8c3d			 
8c3d			; 
8c3d			; Multiply 8-bit value with a 16-bit value (unrolled) 
8c3d			; In: Multiply A with DE 
8c3d			; Out: HL = result 
8c3d			; 
8c3d			Mult12U: 
8c3d 2e 00		    ld l,0 
8c3f 87			    add a,a 
8c40 30 01		    jr nc,Mult12U_NoAdd0 
8c42 19			    add hl,de 
8c43			Mult12U_NoAdd0: 
8c43 29			    add hl,hl 
8c44 87			    add a,a 
8c45 30 01		    jr nc,Mult12U_NoAdd1 
8c47 19			    add hl,de 
8c48			Mult12U_NoAdd1: 
8c48 29			    add hl,hl 
8c49 87			    add a,a 
8c4a 30 01		    jr nc,Mult12U_NoAdd2 
8c4c 19			    add hl,de 
8c4d			Mult12U_NoAdd2: 
8c4d 29			    add hl,hl 
8c4e 87			    add a,a 
8c4f 30 01		    jr nc,Mult12U_NoAdd3 
8c51 19			    add hl,de 
8c52			Mult12U_NoAdd3: 
8c52 29			    add hl,hl 
8c53 87			    add a,a 
8c54 30 01		    jr nc,Mult12U_NoAdd4 
8c56 19			    add hl,de 
8c57			Mult12U_NoAdd4: 
8c57 29			    add hl,hl 
8c58 87			    add a,a 
8c59 30 01		    jr nc,Mult12U_NoAdd5 
8c5b 19			    add hl,de 
8c5c			Mult12U_NoAdd5: 
8c5c 29			    add hl,hl 
8c5d 87			    add a,a 
8c5e 30 01		    jr nc,Mult12U_NoAdd6 
8c60 19			    add hl,de 
8c61			Mult12U_NoAdd6: 
8c61 29			    add hl,hl 
8c62 87			    add a,a 
8c63 d0			    ret nc 
8c64 19			    add hl,de 
8c65 c9			    ret 
8c66			 
8c66			; 
8c66			; Multiply 8-bit value with a 16-bit value (right rotating) 
8c66			; In: Multiply A with DE 
8c66			;      Put lowest value in A for most efficient calculation 
8c66			; Out: HL = result 
8c66			; 
8c66			Mult12R: 
8c66 21 00 00		    ld hl,0 
8c69			Mult12R_Loop: 
8c69 cb 3f		    srl a 
8c6b 30 01		    jr nc,Mult12R_NoAdd 
8c6d 19			    add hl,de 
8c6e			Mult12R_NoAdd: 
8c6e cb 23		    sla e 
8c70 cb 12		    rl d 
8c72 b7			    or a 
8c73 c2 69 8c		    jp nz,Mult12R_Loop 
8c76 c9			    ret 
8c77			 
8c77			; 
8c77			; Multiply 16-bit values (with 32-bit result) 
8c77			; In: Multiply BC with DE 
8c77			; Out: BCHL = result 
8c77			; 
8c77			Mult32: 
8c77 79			    ld a,c 
8c78 48			    ld c,b 
8c79 21 00 00		    ld hl,0 
8c7c 06 10		    ld b,16 
8c7e			Mult32_Loop: 
8c7e 29			    add hl,hl 
8c7f 17			    rla 
8c80 cb 11		    rl c 
8c82 30 07		    jr nc,Mult32_NoAdd 
8c84 19			    add hl,de 
8c85 ce 00		    adc a,0 
8c87 d2 8b 8c		    jp nc,Mult32_NoAdd 
8c8a 0c			    inc c 
8c8b			Mult32_NoAdd: 
8c8b 10 f1		    djnz Mult32_Loop 
8c8d 41			    ld b,c 
8c8e 4f			    ld c,a 
8c8f c9			    ret 
8c90			 
8c90			 
8c90			 
8c90			; 
8c90			; Multiply 8-bit values 
8c90			; In:  Multiply H with E 
8c90			; Out: HL = result 
8c90			; 
8c90			Mult8: 
8c90 16 00		    ld d,0 
8c92 6a			    ld l,d 
8c93 06 08		    ld b,8 
8c95			Mult8_Loop: 
8c95 29			    add hl,hl 
8c96 30 01		    jr nc,Mult8_NoAdd 
8c98 19			    add hl,de 
8c99			Mult8_NoAdd: 
8c99 10 fa		    djnz Mult8_Loop 
8c9b c9			    ret 
8c9c			 
8c9c			 
8c9c			 
8c9c			 
8c9c			 
8c9c			 
8c9c			 
8c9c			 
8c9c			;;http://z80-heaven.wikidot.com/math 
8c9c			;;This divides DE by BC, storing the result in DE, remainder in HL 
8c9c			; 
8c9c			;DE_Div_BC:          ;1281-2x, x is at most 16 
8c9c			;     ld a,16        ;7 
8c9c			;     ld hl,0        ;10 
8c9c			;     jp $+5         ;10 
8c9c			;.DivLoop: 
8c9c			;       add hl,bc    ;-- 
8c9c			;       dec a        ;64 
8c9c			;       jr z,.DivLoopEnd        ;86 
8c9c			; 
8c9c			;       sla e        ;128 
8c9c			;       rl d         ;128 
8c9c			;       adc hl,hl    ;240 
8c9c			;       sbc hl,bc    ;240 
8c9c			;       jr nc,.DivLoop ;23|21 
8c9c			;       inc e        ;-- 
8c9c			;       jp .DivLoop+1 
8c9c			; 
8c9c			;.DivLoopEnd: 
8c9c			 
8c9c			;HL_Div_C: 
8c9c			;Inputs: 
8c9c			;     HL is the numerator 
8c9c			;     C is the denominator 
8c9c			;Outputs: 
8c9c			;     A is the remainder 
8c9c			;     B is 0 
8c9c			;     C is not changed 
8c9c			;     DE is not changed 
8c9c			;     HL is the quotient 
8c9c			; 
8c9c			;       ld b,16 
8c9c			;       xor a 
8c9c			;         add hl,hl 
8c9c			;         rla 
8c9c			;         cp c 
8c9c			;         jr c,$+4 
8c9c			;           inc l 
8c9c			;           sub c 
8c9c			;         djnz $-7 
8c9c			 
8c9c			; https://plutiedev.com/z80-add-8bit-to-16bit 
8c9c			 
8c9c			addatohl: 
8c9c 85			    add   a, l    ; A = A+L 
8c9d 6f			    ld    l, a    ; L = A+L 
8c9e 8c			    adc   a, h    ; A = A+L+H+carry 
8c9f 95			    sub   l       ; A = H+carry 
8ca0 67			    ld    h, a    ; H = H+carry 
8ca1 c9			ret 
8ca2			 
8ca2			addatode: 
8ca2 83			    add   a, e    ; A = A+L 
8ca3 5f			    ld    e, a    ; L = A+L 
8ca4 8a			    adc   a, d    ; A = A+L+H+carry 
8ca5 93			    sub   e       ; A = H+carry 
8ca6 57			    ld    d, a    ; H = H+carry 
8ca7 c9			ret 
8ca8			 
8ca8			 
8ca8			addatobc: 
8ca8 81			    add   a, c    ; A = A+L 
8ca9 4f			    ld    c, a    ; L = A+L 
8caa 88			    adc   a, b    ; A = A+L+H+carry 
8cab 91			    sub   c       ; A = H+carry 
8cac 47			    ld    b, a    ; H = H+carry 
8cad c9			ret 
8cae			 
8cae			subafromhl: 
8cae			   ; If A=0 do nothing 
8cae			    ; Otherwise flip A's sign. Since 
8cae			    ; the upper byte becomes -1, also 
8cae			    ; substract 1 from H. 
8cae ed 44		    neg 
8cb0 ca b9 8c		    jp    z, Skip 
8cb3 25			    dec   h 
8cb4			     
8cb4			    ; Now add the low byte as usual 
8cb4			    ; Two's complement takes care of 
8cb4			    ; ensuring the result is correct 
8cb4 85			    add   a, l 
8cb5 6f			    ld    l, a 
8cb6 8c			    adc   a, h 
8cb7 95			    sub   l 
8cb8 67			    ld    h, a 
8cb9			Skip: 
8cb9 c9				ret 
8cba			 
8cba			 
8cba			; compare hl and de 
8cba			; returns:  
8cba			; if hl = de, z=1, s=0, c0=0 
8cba			; if hl > de, z=0, s=0, c=0 
8cba			; if hl < de, z=0, s=1, c=1 
8cba			cmp16:	 
8cba b7				or a 
8cbb ed 52			sbc hl,de 
8cbd e0				ret po 
8cbe 7c				ld a,h 
8cbf 1f				rra 
8cc0 ee 40			xor 01000000B 
8cc2 37				scf 
8cc3 8f				adc a,a 
8cc4 c9				ret 
8cc5			 
8cc5			 
8cc5			; test if hl contains zero   - A is destroyed 
8cc5			 
8cc5			ishlzero:    
8cc5 b7				or a     ; reset flags 
8cc6 7c				ld a, h 
8cc7 b5				or l        	 
8cc8			 
8cc8 c9				ret 
8cc9			 
8cc9			 
8cc9			 
8cc9			 
8cc9			if FORTH_ENABLE_FLOATMATH 
8cc9			;include "float/bbcmath.z80" 
8cc9			include "float/lpfpcalc.asm" 
8cc9			endif 
8cc9			 
8cc9			 
8cc9			; eof 
8cc9			 
# End of file firmware_maths.asm
8cc9			include "firmware_strings.asm"   ; string handling  
8cc9			 
8cc9			 
8cc9			; TODO string len 
8cc9			; input text string, end on cr with zero term 
8cc9			; a offset into frame buffer to start prompt 
8cc9			; d is max length 
8cc9			; e is display size TODO 
8cc9			; c is current cursor position 
8cc9			; hl is ptr to where string will be stored 
8cc9			 
8cc9			 
8cc9			; TODO check limit of buffer for new inserts 
8cc9			; TODO check insert does not push beyond buffer 
8cc9			; TODO scroll in a limited display area 
8cc9			; TODO scroll whole screen on page wrap 
8cc9			 
8cc9			 
8cc9			; TODO handle KEY_PREVWORD 
8cc9			; TODO handle KEY_NEXTWORD 
8cc9			; TODO handle KEY_HOME 
8cc9			; TODO handle KEY_END 
8cc9			; TODO use LCD cursor? 
8cc9			 
8cc9 32 6a ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8ccc 81					add c 
8ccd 32 68 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8cd0 22 6d ee				ld (input_start), hl     ; save ptr to buffer 
8cd3 79					ld a, c 
8cd4 cd 9c 8c				call addatohl 
8cd7 22 6f ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8cda 7a					ld a,d 
8cdb 32 6c ee			        ld (input_size), a       ; save length of input area 
8cde 79					ld a, c 
8cdf 32 5b ee				ld (input_cursor),a      ; init cursor start position  
8ce2 7b					ld a,e 
8ce3 32 6b ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8ce6					 
8ce6					 
8ce6			 
8ce6			;		ld a,(input_ptr) 
8ce6			;		ld (input_under_cursor),a 	; save what is under the cursor 
8ce6			 
8ce6			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8ce6					; init cursor shape if not set by the cin routines 
8ce6 21 ca eb				ld hl, cursor_shape 
8ce9 3e ff				ld a, 255 
8ceb 77					ld (hl), a 
8cec 23					inc hl 
8ced 3e 00				ld a, 0 
8cef 77					ld (hl), a 
8cf0			 
8cf0 3e 0f				ld a, CUR_BLINK_RATE 
8cf2 32 66 ee				ld (input_cur_flash), a 
8cf5 3e 01				ld a, 1 
8cf7 32 65 ee				ld (input_cur_onoff),a 
8cfa			 
8cfa			;	if DEBUG_INPUT 
8cfa			;		push af 
8cfa			;		ld a, 'I' 
8cfa			;		ld (debug_mark),a 
8cfa			;		pop af 
8cfa			;		CALLMONITOR 
8cfa			;	endif 
8cfa			.is1:		; main entry loop 
8cfa			 
8cfa			 
8cfa			 
8cfa					; pause 1ms 
8cfa			 
8cfa 3e 01				ld a, 1 
8cfc cd d1 89				call aDelayInMS 
8cff			 
8cff					; dec flash counter 
8cff 3a 66 ee				ld a, (input_cur_flash) 
8d02 3d					dec a 
8d03 32 66 ee				ld (input_cur_flash), a 
8d06 fe 00				cp 0 
8d08 20 0d				jr nz, .nochgstate 
8d0a			 
8d0a			 
8d0a					; change state 
8d0a 3a 65 ee				ld a,(input_cur_onoff) 
8d0d ed 44				neg 
8d0f 32 65 ee				ld (input_cur_onoff),a 
8d12			 
8d12			 
8d12					; reset on change of state 
8d12 3e 0f				ld a, CUR_BLINK_RATE 
8d14 32 66 ee				ld (input_cur_flash), a 
8d17			 
8d17			.nochgstate: 
8d17					 
8d17					 
8d17			 
8d17					; display cursor  
8d17			 
8d17			;		ld hl, (input_start) 
8d17			;		ld a, (input_cursor) 
8d17			;		call addatohl 
8d17			 
8d17					; get char under cursor and replace with cursor 
8d17 2a 6f ee		ld hl, (input_ptr) 
8d1a			;		ld a, (hl) 
8d1a			;		ld (input_under_cursor),a 
8d1a			;		ld a, '_' 
8d1a			;		ld (hl), a 
8d1a			 
8d1a					; display string 
8d1a			 
8d1a ed 5b 6d ee			ld de, (input_start) 
8d1e 3a 6a ee				ld a, (input_at_pos) 
8d21 cd 82 8a				call str_at_display 
8d24			;	        call update_display 
8d24			 
8d24					; find place to put the cursor 
8d24			;		add h 
8d24			;		ld l, display_row_1 
8d24			;		sub l 
8d24			; (input_at_pos) 
8d24					;ld c, a 
8d24			;		ld a, (input_cursor) 
8d24			;		ld l, (input_at_pos) 
8d24			;		;ld b, h 
8d24			;		add l 
8d24			;		ld (input_at_cursor),a 
8d24					;ld l,h 
8d24			 
8d24			;		ld h, 0 
8d24			;		ld l,(input_at_pos) 
8d24			;		ld a, (input_cursor) 
8d24			;		call addatohl 
8d24			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8d24			;		call subafromhl 
8d24			;		ld a,l 
8d24			;		ld (input_at_cursor), a 
8d24			 
8d24				if DEBUG_INPUT 
8d24					ld a, (hardware_diag) 
8d24					cp 0 
8d24					jr z, .skip_input_diag 
8d24			 
8d24					ld a,(input_at_pos) 
8d24					ld hl, LFSRSeed 
8d24					call hexout 
8d24					ld a, (input_cursor) 
8d24					ld hl, LFSRSeed+2 
8d24					call hexout 
8d24					ld a,(input_at_cursor) 
8d24					ld hl, LFSRSeed+4 
8d24					call hexout 
8d24			 
8d24					ld a,(input_cur_onoff) 
8d24					ld hl, LFSRSeed+6 
8d24					call hexout 
8d24			 
8d24					ld a,(input_cur_flash) 
8d24					ld hl, LFSRSeed+8 
8d24					call hexout 
8d24			 
8d24					ld a,(input_len) 
8d24					ld hl, LFSRSeed+10 
8d24					call hexout 
8d24					ld hl, LFSRSeed+12 
8d24					ld a, 0 
8d24					ld (hl),a 
8d24					ld a, display_row_4 
8d24					ld de, LFSRSeed 
8d24					call str_at_display 
8d24					.skip_input_diag: 
8d24				endif 
8d24			 
8d24					; decide on if we are showing the cursor this time round 
8d24			 
8d24 3a 65 ee				ld a, (input_cur_onoff) 
8d27 fe ff				cp 255 
8d29 28 13				jr z, .skipcur 
8d2b			 
8d2b			 
8d2b 3a 68 ee				ld a,(input_at_cursor) 
8d2e 11 ca eb				ld de, cursor_shape 
8d31 cd 82 8a				call str_at_display 
8d34			 
8d34					; save length of current input string 
8d34 2a 6d ee				ld hl, (input_start) 
8d37 cd fa 90				call strlenz 
8d3a 7d					ld a,l 
8d3b 32 60 ee				ld (input_len),a 
8d3e			 
8d3e			.skipcur: 
8d3e			 
8d3e cd 92 8a			        call update_display 
8d41					 
8d41			 
8d41			 
8d41					; wait 
8d41				 
8d41					; TODO loop without wait to flash the cursor and char under cursor	 
8d41 cd 97 da				call cin    ; _wait 
8d44			 
8d44 fe 00				cp 0 
8d46 ca fa 8c				jp z, .is1 
8d49			 
8d49					; get ptr to char to input into 
8d49			 
8d49 4f					ld c,a 
8d4a 2a 6d ee				ld hl, (input_start) 
8d4d 3a 5b ee				ld a, (input_cursor) 
8d50 cd 9c 8c				call addatohl 
8d53 22 6f ee				ld (input_ptr), hl 
8d56 79					ld a,c 
8d57			 
8d57					; replace char under cursor 
8d57			 
8d57			;		ld hl, (input_ptr) 
8d57			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8d57			;		ld (hl), a 
8d57			 
8d57			;	if DEBUG_INPUT 
8d57			;		push af 
8d57			;		ld a, 'i' 
8d57			;		ld (debug_mark),a 
8d57			;		pop af 
8d57			;		CALLMONITOR 
8d57			;	endif 
8d57 fe 0e				cp KEY_HOME 
8d59 20 0e				jr nz, .iske 
8d5b			 
8d5b 3a 6a ee				ld a, (input_at_pos) 
8d5e 32 68 ee				ld (input_at_cursor),a 
8d61 3e 00				ld a, 0 
8d63 32 5b ee				ld (input_cursor), a 
8d66 c3 fa 8c				jp .is1 
8d69					 
8d69 fe 0f		.iske:		cp KEY_END 
8d6b 20 03				jr nz, .isknw 
8d6d c3 fa 8c				jp .is1 
8d70			 
8d70 fe 06		.isknw:		cp KEY_NEXTWORD 
8d72 20 1b				jr nz, .iskpw 
8d74			 
8d74 2a 6f ee		.isknwm:	ld hl, (input_ptr) 
8d77 7e					ld a,(hl)	 
8d78 fe 00				cp 0 
8d7a ca fa 8c				jp z, .is1    ; end of string 
8d7d fe 20				cp ' ' 
8d7f ca fa 8c				jp z, .is1    ; end of word 
8d82 23					inc hl 
8d83 22 6f ee				ld (input_ptr), hl 
8d86 3a 68 ee				ld a, (input_at_cursor) 
8d89 3c					inc a 
8d8a 32 68 ee				ld (input_at_cursor), a 
8d8d 18 e5				jr .isknwm 
8d8f			 
8d8f fe 07		.iskpw:		cp KEY_PREVWORD 
8d91 20 1b				jr nz, .iskl 
8d93			.iskpwm:	 
8d93 2a 6f ee				ld hl, (input_ptr) 
8d96 7e					ld a,(hl)	 
8d97 fe 00				cp 0  
8d99 ca fa 8c				jp z, .is1    ; end of string 
8d9c fe 20				cp ' ' 
8d9e ca fa 8c				jp z, .is1    ; end of word 
8da1 2b					dec hl 
8da2 22 6f ee				ld (input_ptr), hl 
8da5 3a 68 ee				ld a, (input_at_cursor) 
8da8 3d					dec a 
8da9 32 68 ee				ld (input_at_cursor), a 
8dac 18 e5				jr .iskpwm 
8dae			 
8dae			 
8dae fe 0b		.iskl:		cp KEY_LEFT 
8db0 20 27				jr nz, .isk1 
8db2			 
8db2 3a 5b ee				ld a, (input_cursor) 
8db5			 
8db5 fe 00				cp 0 
8db7 ca fa 8c				jp z, .is1 		; at start of line to ignore  
8dba			 
8dba 3d					dec  a 		; TODO check underflow 
8dbb 32 5b ee				ld (input_cursor), a 
8dbe			 
8dbe 2a 6f ee				ld hl, (input_ptr) 
8dc1 2b					dec hl 
8dc2 22 6f ee				ld (input_ptr), hl 
8dc5					 
8dc5 3a 68 ee				ld a, (input_at_cursor) 
8dc8 3d					dec a 
8dc9 32 68 ee				ld (input_at_cursor), a 
8dcc			 
8dcc 3e 01				ld a, 1		; show cursor moving 
8dce 32 65 ee				ld (input_cur_onoff),a 
8dd1 3e 0f				ld a, CUR_BLINK_RATE 
8dd3 32 66 ee				ld (input_cur_flash), a 
8dd6			 
8dd6 c3 fa 8c				jp .is1 
8dd9			 
8dd9 fe 0c		.isk1:		cp KEY_RIGHT 
8ddb 20 2a				jr nz, .isk2 
8ddd			 
8ddd 3a 60 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8de0 5f					ld e,a 
8de1 3a 5b ee				ld a, (input_cursor) 
8de4 bb					cp e 
8de5 ca fa 8c				jp z, .is1		; at the end of string so dont go right 
8de8			 
8de8 3c					inc  a 		; TODO check overflow 
8de9 32 5b ee				ld (input_cursor), a 
8dec			 
8dec 3a 68 ee				ld a, (input_at_cursor) 
8def 3c					inc a 
8df0 32 68 ee				ld (input_at_cursor), a 
8df3			 
8df3 2a 6f ee				ld hl, (input_ptr) 
8df6 23					inc hl 
8df7 22 6f ee				ld (input_ptr), hl 
8dfa			 
8dfa 3e 01				ld a, 1		; show cursor moving 
8dfc 32 65 ee				ld (input_cur_onoff),a 
8dff 3e 0f				ld a, CUR_BLINK_RATE 
8e01 32 66 ee				ld (input_cur_flash), a 
8e04			 
8e04 c3 fa 8c				jp .is1 
8e07			 
8e07 fe 05		.isk2:		cp KEY_UP 
8e09			 
8e09 20 26				jr nz, .isk3 
8e0b			 
8e0b					; swap last command with the current on 
8e0b			 
8e0b					; move cursor to start of string 
8e0b 2a 6d ee				ld hl, (input_start) 
8e0e 22 6f ee				ld (input_ptr), hl 
8e11			 
8e11 3a 6a ee				ld a, (input_at_pos) 
8e14 32 68 ee				ld (input_at_cursor), a 
8e17			 
8e17 3e 00				ld a, 0 
8e19 32 5b ee				ld (input_cursor), a 
8e1c					 
8e1c					; swap input and last command buffers 
8e1c			 
8e1c 21 29 e6				ld hl, os_cli_cmd 
8e1f 11 28 e7				ld de, os_last_cmd 
8e22 06 ff				ld b, 255 
8e24 7e			.swap1:		ld a, (hl) 
8e25 4f					ld c,a 
8e26 1a					ld a, (de) 
8e27 77					ld (hl), a 
8e28 79					ld a,c 
8e29 12					ld (de),a 
8e2a 23					inc hl 
8e2b 13					inc de 
8e2c 10 f6				djnz .swap1 
8e2e			 
8e2e			 
8e2e			 
8e2e			 
8e2e			 
8e2e c3 fa 8c				jp .is1 
8e31			 
8e31 fe 08		.isk3:		cp KEY_BS 
8e33 20 3c				jr nz, .isk4 
8e35			 
8e35 3a 5b ee				ld a, (input_cursor) 
8e38			 
8e38 fe 00				cp 0 
8e3a ca fa 8c				jp z, .is1 		; at start of line to ignore  
8e3d			 
8e3d 3d					dec  a 		; TODO check underflow 
8e3e 32 5b ee				ld (input_cursor), a 
8e41			 
8e41					; hl is source 
8e41					; de needs to be source - 1 
8e41			 
8e41			;		ld a, 0 
8e41			;		dec hl 
8e41			;		ld (hl), a 
8e41			 
8e41 2a 6f ee				ld hl, (input_ptr) 
8e44 2b					dec hl 
8e45 22 6f ee				ld (input_ptr), hl 
8e48			 
8e48					; shift all data 
8e48			 
8e48 e5					push hl 
8e49 23					inc hl 
8e4a d1					pop de 
8e4b 3a 60 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8e4e 4f					ld c,a 
8e4f 06 00				ld b,0 
8e51 ed b0				ldir  
8e53			 
8e53			 
8e53			 
8e53			 
8e53 3a 68 ee				ld a, (input_at_cursor) 
8e56 3d					dec a 
8e57 32 68 ee				ld (input_at_cursor), a 
8e5a			 
8e5a			 
8e5a 3e 01				ld a, 1		; show cursor moving 
8e5c 32 65 ee				ld (input_cur_onoff),a 
8e5f 3e 0f				ld a, CUR_BLINK_RATE 
8e61 32 66 ee				ld (input_cur_flash), a 
8e64			 
8e64					; remove char 
8e64 3a 68 ee				ld a, (input_at_cursor) 
8e67 3c					inc a 
8e68 11 f2 8e				ld de,.iblank 
8e6b cd 82 8a				call str_at_display 
8e6e			 
8e6e c3 fa 8c				jp .is1 
8e71			 
8e71 fe 0d		.isk4:		cp KEY_CR 
8e73 28 6c				jr z, .endinput 
8e75			 
8e75					; else add the key press to the end 
8e75			 
8e75 4f					ld c, a			; save key pressed 
8e76			 
8e76 7e					ld a,(hl)		; get what is currently under char 
8e77			 
8e77 fe 00				cp 0			; we are at the end of the string 
8e79 20 2f				jr nz, .onchar 
8e7b					 
8e7b					; add a char to the end of the string 
8e7b				 
8e7b 71					ld (hl),c 
8e7c 23					inc hl 
8e7d			;		ld a,' ' 
8e7d			;		ld (hl),a 
8e7d			;		inc hl 
8e7d 3e 00				ld a,0 
8e7f 77					ld (hl),a 
8e80 2b					dec hl 
8e81			 
8e81 3a 5b ee				ld a, (input_cursor) 
8e84 3c					inc a				; TODO check max string length and scroll  
8e85 32 5b ee				ld (input_cursor), a		; inc cursor pos 
8e88							 
8e88 3a 68 ee				ld a, (input_at_cursor) 
8e8b 3c					inc a 
8e8c 32 68 ee				ld (input_at_cursor), a 
8e8f			 
8e8f 2a 6f ee				ld hl, (input_ptr) 
8e92 23					inc hl 
8e93 22 6f ee				ld (input_ptr), hl 
8e96			 
8e96 2a 6f ee				ld hl, (input_ptr) 
8e99 23					inc hl 
8e9a 22 6f ee				ld (input_ptr), hl 
8e9d			;	if DEBUG_INPUT 
8e9d			;		push af 
8e9d			;		ld a, '+' 
8e9d			;		ld (debug_mark),a 
8e9d			;		pop af 
8e9d			;		CALLMONITOR 
8e9d			;	endif 
8e9d 3e 01				ld a, 1		; show cursor moving 
8e9f 32 65 ee				ld (input_cur_onoff),a 
8ea2 3e 0f				ld a, CUR_BLINK_RATE 
8ea4 32 66 ee				ld (input_cur_flash), a 
8ea7 c3 fa 8c				jp .is1 
8eaa					 
8eaa			 
8eaa			 
8eaa					; if on a char then insert 
8eaa			.onchar: 
8eaa			 
8eaa					; TODO over flow check: make sure insert does not blow out buffer 
8eaa			 
8eaa					; need to do some maths to use lddr 
8eaa			 
8eaa e5					push hl   ; save char pos 
8eab c5					push bc 
8eac			 
8eac 2a 6d ee				ld hl, (input_start) 
8eaf 3a 60 ee				ld a, (input_len) 
8eb2 cd 9c 8c				call addatohl  		; end of string 
8eb5 23					inc hl 
8eb6 23					inc hl		; past zero term 
8eb7 e5					push hl 
8eb8 23					inc hl 
8eb9 e5					push hl  
8eba			 
8eba								; start and end of lddr set, now how much to move? 
8eba			 
8eba							 
8eba 3a 5b ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8ebd 47					ld b,a 
8ebe 3a 60 ee				ld a,(input_len) 
8ec1 5f					ld e,a 
8ec2 90					sub b 
8ec3 3c					inc a		;?? 
8ec4 3c					inc a		;?? 
8ec5 3c					inc a		;?? 
8ec6			 
8ec6 06 00				ld b,0 
8ec8 4f					ld c,a 
8ec9			 
8ec9				if DEBUG_INPUT 
8ec9					push af 
8ec9					ld a, 'i' 
8ec9					ld (debug_mark),a 
8ec9					pop af 
8ec9			;		CALLMONITOR 
8ec9				endif 
8ec9 d1					pop de 
8eca e1					pop hl 
8ecb				if DEBUG_INPUT 
8ecb					push af 
8ecb					ld a, 'I' 
8ecb					ld (debug_mark),a 
8ecb					pop af 
8ecb			;		CALLMONITOR 
8ecb				endif 
8ecb ed b8				lddr 
8ecd				 
8ecd			 
8ecd			 
8ecd					; TODO have a key for insert/overwrite mode???? 
8ecd c1					pop bc 
8ece e1					pop hl 
8ecf 71					ld (hl), c		; otherwise overwrite current char 
8ed0					 
8ed0			 
8ed0			 
8ed0			 
8ed0 3a 5b ee				ld a, (input_cursor) 
8ed3 3c					inc  a 		; TODO check overflow 
8ed4 32 5b ee				ld (input_cursor), a 
8ed7			 
8ed7 3a 68 ee				ld a, (input_at_cursor) 
8eda 3c					inc a 
8edb 32 68 ee				ld (input_at_cursor), a 
8ede			 
8ede c3 fa 8c				jp .is1 
8ee1			 
8ee1			.endinput:	; TODO look for end of string 
8ee1			 
8ee1					; add trailing space for end of token 
8ee1			 
8ee1 2a 6d ee				ld hl, (input_start) 
8ee4 3a 60 ee				ld a,(input_len) 
8ee7 cd 9c 8c				call addatohl 
8eea 3e 20				ld a, ' ' 
8eec 77					ld (hl),a 
8eed					; TODO eof of parse marker 
8eed			 
8eed 23					inc hl 
8eee 3e 00				ld a, 0 
8ef0 77					ld (hl),a 
8ef1			 
8ef1			 
8ef1 c9					ret 
8ef2			 
8ef2 .. 00		.iblank: db " ",0 
8ef4			 
8ef4			 
8ef4 32 6a ee		input_str_prev:	ld (input_at_pos), a 
8ef7 22 6d ee				ld (input_start), hl 
8efa 3e 01				ld a,1			; add cursor 
8efc 77					ld (hl),a 
8efd 23					inc hl 
8efe 3e 00				ld a,0 
8f00 77					ld (hl),a 
8f01 22 6f ee				ld (input_ptr), hl 
8f04 7a					ld a,d 
8f05 32 6c ee				ld (input_size), a 
8f08 3e 00				ld a,0 
8f0a 32 5b ee				ld (input_cursor),a 
8f0d			.instr1:	 
8f0d			 
8f0d					; TODO do block cursor 
8f0d					; TODO switch cursor depending on the modifer key 
8f0d			 
8f0d					; update cursor shape change on key hold 
8f0d			 
8f0d 2a 6f ee				ld hl, (input_ptr) 
8f10 2b					dec hl 
8f11 3a ca eb				ld a,(cursor_shape) 
8f14 77					ld (hl), a 
8f15			 
8f15					; display entered text 
8f15 3a 6a ee				ld a,(input_at_pos) 
8f18 cd f5 d9		            	CALL fLCD_Pos       ;Position cursor to location in A 
8f1b ed 5b 6d ee	            	LD   de, (input_start) 
8f1f cd ef d9		            	CALL fLCD_Str       ;Display string pointed to by DE 
8f22			 
8f22 cd 97 da				call cin 
8f25 fe 00				cp 0 
8f27 28 e4				jr z, .instr1 
8f29			 
8f29					; proecess keyboard controls first 
8f29			 
8f29 2a 6f ee				ld hl,(input_ptr) 
8f2c			 
8f2c fe 0d				cp KEY_CR	 ; pressing enter ends input 
8f2e 28 5a				jr z, .instrcr 
8f30			 
8f30 fe 08				cp KEY_BS 	; back space 
8f32 20 0f				jr nz, .instr2 
8f34					; process back space 
8f34			 
8f34					; TODO stop back space if at start of string 
8f34 2b					dec hl 
8f35 2b					dec hl ; to over write cursor 
8f36 3a ca eb				ld a,(cursor_shape) 
8f39					;ld a,0 
8f39 77					ld (hl),a 
8f3a 23					inc hl 
8f3b 3e 20				ld a," " 
8f3d 77					ld (hl),a 
8f3e 22 6f ee				ld (input_ptr),hl 
8f41					 
8f41			 
8f41 18 ca				jr .instr1 
8f43			 
8f43 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8f45 20 06				jr nz, .instr3 
8f47 2b					dec hl 
8f48 22 6f ee				ld (input_ptr),hl 
8f4b 18 c0				jr .instr1 
8f4d				 
8f4d fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8f4f 20 06				jr nz, .instr4 
8f51 23					inc hl 
8f52 22 6f ee				ld (input_ptr),hl 
8f55 18 b6				jr .instr1 
8f57			 
8f57 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8f59 20 06				jr nz, .instr5 
8f5b 2b					dec hl 
8f5c 22 6f ee				ld (input_ptr),hl 
8f5f 18 ac				jr .instr1 
8f61			 
8f61 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8f63 20 06				jr nz, .instr6 
8f65 2b					dec hl 
8f66 22 6f ee				ld (input_ptr),hl 
8f69 18 a2				jr .instr1 
8f6b fe 05		.instr6:        cp KEY_UP      ; recall last command 
8f6d 20 0b				jr nz, .instrnew 
8f6f			 
8f6f 21 02 e3			ld hl, scratch 
8f72 11 28 e7			ld de, os_last_cmd 
8f75 cd 93 8f			call strcpy 
8f78 18 93				jr .instr1 
8f7a			 
8f7a			 
8f7a			.instrnew:	; no special key pressed to see if we have room to store it 
8f7a			 
8f7a					; TODO do string size test 
8f7a			 
8f7a 2b					dec hl ; to over write cursor 
8f7b 77					ld (hl),a 
8f7c 23					inc hl 
8f7d 3a ca eb				ld a,(cursor_shape) 
8f80 77					ld (hl),a 
8f81 23					inc hl 
8f82 3e 00				ld a,0 
8f84 77					ld (hl),a 
8f85			 
8f85 22 6f ee				ld (input_ptr),hl 
8f88					 
8f88 18 83				jr .instr1 
8f8a 2b			.instrcr:	dec hl		; remove cursor 
8f8b 3e 20				ld a,' '	; TODO add a trailing space for safety 
8f8d 77					ld (hl),a 
8f8e 23					inc hl 
8f8f 3e 00				ld a,0 
8f91 77					ld (hl),a 
8f92			 
8f92			 
8f92					; if at end of line scroll up    
8f92					; TODO detecting only end of line 4 for scroll up  
8f92			 
8f92					;ld   
8f92			 
8f92 c9					ret 
8f93			 
8f93			 
8f93			; strcpy hl = dest, de source 
8f93			 
8f93 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8f94 b7			            OR   A              ;Null terminator? 
8f95 c8			            RET  Z              ;Yes, so finished 
8f96 1a					ld a,(de) 
8f97 77					ld (hl),a 
8f98 13			            INC  DE             ;Point to next character 
8f99 23					inc hl 
8f9a 18 f7		            JR   strcpy       ;Repeat 
8f9c c9					ret 
8f9d			 
8f9d			 
8f9d			; TODO string_at  
8f9d			; pass string which starts with lcd offset address and then null term string 
8f9d			 
8f9d			; TODO string to dec 
8f9d			; TODO string to hex 
8f9d			; TODO byte to string hex 
8f9d			; TODO byte to string dec 
8f9d			 
8f9d			 
8f9d			 
8f9d			; from z80uartmonitor 
8f9d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f9d			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8f9d			; pass hl for where to put the text 
8f9d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8f9d c5			hexout:	PUSH BC 
8f9e f5					PUSH AF 
8f9f 47					LD B, A 
8fa0					; Upper nybble 
8fa0 cb 3f				SRL A 
8fa2 cb 3f				SRL A 
8fa4 cb 3f				SRL A 
8fa6 cb 3f				SRL A 
8fa8 cd b8 8f				CALL tohex 
8fab 77					ld (hl),a 
8fac 23					inc hl	 
8fad					 
8fad					; Lower nybble 
8fad 78					LD A, B 
8fae e6 0f				AND 0FH 
8fb0 cd b8 8f				CALL tohex 
8fb3 77					ld (hl),a 
8fb4 23					inc hl	 
8fb5					 
8fb5 f1					POP AF 
8fb6 c1					POP BC 
8fb7 c9					RET 
8fb8					 
8fb8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fb8			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8fb8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8fb8			tohex: 
8fb8 e5					PUSH HL 
8fb9 d5					PUSH DE 
8fba 16 00				LD D, 0 
8fbc 5f					LD E, A 
8fbd 21 c5 8f				LD HL, .DATA 
8fc0 19					ADD HL, DE 
8fc1 7e					LD A, (HL) 
8fc2 d1					POP DE 
8fc3 e1					POP HL 
8fc4 c9					RET 
8fc5			 
8fc5			.DATA: 
8fc5 30					DEFB	30h	; 0 
8fc6 31					DEFB	31h	; 1 
8fc7 32					DEFB	32h	; 2 
8fc8 33					DEFB	33h	; 3 
8fc9 34					DEFB	34h	; 4 
8fca 35					DEFB	35h	; 5 
8fcb 36					DEFB	36h	; 6 
8fcc 37					DEFB	37h	; 7 
8fcd 38					DEFB	38h	; 8 
8fce 39					DEFB	39h	; 9 
8fcf 41					DEFB	41h	; A 
8fd0 42					DEFB	42h	; B 
8fd1 43					DEFB	43h	; C 
8fd2 44					DEFB	44h	; D 
8fd3 45					DEFB	45h	; E 
8fd4 46					DEFB	46h	; F 
8fd5			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8fd5			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8fd5			;;    subtract $30, if result > 9 then subtract $7 more 
8fd5			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8fd5			atohex: 
8fd5 d6 30				SUB $30 
8fd7 fe 0a				CP 10 
8fd9 f8					RET M		; If result negative it was 0-9 so we're done 
8fda d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8fdc c9					RET		 
8fdd			 
8fdd			 
8fdd			 
8fdd			 
8fdd			; Get 2 ASCII characters as hex byte from pointer in hl 
8fdd			 
8fdd			BYTERD: 
8fdd 16 00			LD	D,00h		;Set up 
8fdf cd e7 8f			CALL	HEXCON		;Get byte and convert to hex 
8fe2 87				ADD	A,A		;First nibble so 
8fe3 87				ADD	A,A		;multiply by 16 
8fe4 87				ADD	A,A		; 
8fe5 87				ADD	A,A		; 
8fe6 57				LD	D,A		;Save hi nibble in D 
8fe7			HEXCON: 
8fe7 7e				ld a, (hl)		;Get next chr 
8fe8 23				inc hl 
8fe9 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8feb fe 0a			CP	00Ah		;Is it 0-9 ? 
8fed 38 02			JR	C,NALPHA	;If so miss next bit 
8fef d6 07			SUB	007h		;Else convert alpha 
8ff1			NALPHA: 
8ff1 b2				OR	D		;Add hi nibble back 
8ff2 c9				RET			; 
8ff3			 
8ff3			 
8ff3			; 
8ff3			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8ff3			; Since the routines get_byte and therefore get_nibble are called, only valid 
8ff3			; characters (0-9a-f) are accepted. 
8ff3			; 
8ff3			;get_word        push    af 
8ff3			;                call    get_byte        ; Get the upper byte 
8ff3			;                ld      h, a 
8ff3			;                call    get_byte        ; Get the lower byte 
8ff3			;                ld      l, a 
8ff3			;                pop     af 
8ff3			;                ret 
8ff3			; 
8ff3			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8ff3			; the routine get_nibble is used only valid characters are accepted - the  
8ff3			; input routine only accepts characters 0-9a-f. 
8ff3			; 
8ff3 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8ff4 7e					ld a,(hl) 
8ff5 23					inc hl 
8ff6 cd 1b 90		                call    nibble2val      ; Get upper nibble 
8ff9 cb 07		                rlc     a 
8ffb cb 07		                rlc     a 
8ffd cb 07		                rlc     a 
8fff cb 07		                rlc     a 
9001 47			                ld      b, a            ; Save upper four bits 
9002 7e					ld a,(hl) 
9003 cd 1b 90		                call    nibble2val      ; Get lower nibble 
9006 b0			                or      b               ; Combine both nibbles 
9007 c1			                pop     bc              ; Restore B (and C) 
9008 c9			                ret 
9009			; 
9009			; Get a hexadecimal digit from the serial line. This routine blocks until 
9009			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
9009			; to the serial line interface. The lower 4 bits of A contain the value of  
9009			; that particular digit. 
9009			; 
9009			;get_nibble      ld a,(hl)           ; Read a character 
9009			;                call    to_upper        ; Convert to upper case 
9009			;                call    is_hex          ; Was it a hex digit? 
9009			;                jr      nc, get_nibble  ; No, get another character 
9009			 ;               call    nibble2val      ; Convert nibble to value 
9009			 ;               call    print_nibble 
9009			 ;               ret 
9009			; 
9009			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
9009			; A valid hexadecimal digit is denoted by a set C flag. 
9009			; 
9009			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
9009			;                ret     nc              ; Yes 
9009			;                cp      '0'             ; Less than '0'? 
9009			;                jr      nc, is_hex_1    ; No, continue 
9009			;                ccf                     ; Complement carry (i.e. clear it) 
9009			;                ret 
9009			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
9009			;                ret     c               ; Yes 
9009			;                cp      'A'             ; Less than 'A'? 
9009			;                jr      nc, is_hex_2    ; No, continue 
9009			;                ccf                     ; Yes - clear carry and return 
9009			;                ret 
9009			;is_hex_2        scf                     ; Set carry 
9009			;                ret 
9009			; 
9009			; Convert a single character contained in A to upper case: 
9009			; 
9009 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
900b d8			                ret     c 
900c fe 7b		                cp      'z' + 1         ; > 'z'? 
900e d0			                ret     nc              ; Nothing to do, either 
900f e6 5f		                and     $5f             ; Convert to upper case 
9011 c9			                ret 
9012			 
9012			 
9012			to_lower: 
9012			 
9012			   ; if char is in [A-Z] make it lower case 
9012			 
9012			   ; enter : a = char 
9012			   ; exit  : a = lower case char 
9012			   ; uses  : af 
9012			 
9012 fe 41		   cp 'A' 
9014 d8			   ret c 
9015			    
9015 fe 5b		   cp 'Z'+1 
9017 d0			   ret nc 
9018			    
9018 f6 20		   or $20 
901a c9			   ret 
901b			 
901b			; 
901b			; Expects a hexadecimal digit (upper case!) in A and returns the 
901b			; corresponding value in A. 
901b			; 
901b fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
901d 38 02		                jr      c, nibble2val_1 ; Yes 
901f d6 07		                sub     7               ; Adjust for A-F 
9021 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
9023 e6 0f		                and     $f              ; Only return lower 4 bits 
9025 c9			                ret 
9026			; 
9026			; Print_nibble prints a single hex nibble which is contained in the lower  
9026			; four bits of A: 
9026			; 
9026			;print_nibble    push    af              ; We won't destroy the contents of A 
9026			;                and     $f              ; Just in case... 
9026			;                add     a, '0'             ; If we have a digit we are done here. 
9026			;                cp      '9' + 1         ; Is the result > 9? 
9026			;                jr      c, print_nibble_1 
9026			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
9026			;print_nibble_1  call    putc            ; Print the nibble and 
9026			;                pop     af              ; restore the original value of A 
9026			;                ret 
9026			;; 
9026			;; Send a CR/LF pair: 
9026			; 
9026			;crlf            push    af 
9026			;                ld      a, cr 
9026			;                call    putc 
9026			;                ld      a, lf 
9026			;                call    putc 
9026			;                pop     af 
9026			;                ret 
9026			; 
9026			; Print_word prints the four hex digits of a word to the serial line. The  
9026			; word is expected to be in HL. 
9026			; 
9026			;print_word      push    hl 
9026			;                push    af 
9026			;                ld      a, h 
9026			;                call    print_byte 
9026			;                ld      a, l 
9026			;                call    print_byte 
9026			;                pop     af 
9026			;                pop     hl 
9026			;                ret 
9026			; 
9026			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
9026			; The byte to be printed is expected to be in A. 
9026			; 
9026			;print_byte      push    af              ; Save the contents of the registers 
9026			;                push    bc 
9026			;                ld      b, a 
9026			;                rrca 
9026			;                rrca 
9026			;                rrca 
9026			;                rrca 
9026			;                call    print_nibble    ; Print high nibble 
9026			;                ld      a, b 
9026			;                call    print_nibble    ; Print low nibble 
9026			;                pop     bc              ; Restore original register contents 
9026			;                pop     af 
9026			;                ret 
9026			 
9026			 
9026			 
9026			 
9026			 
9026			fourehexhl:  
9026 7e				ld a,(hl) 
9027 cd d5 8f			call atohex 
902a cb 3f				SRL A 
902c cb 3f				SRL A 
902e cb 3f				SRL A 
9030 cb 3f				SRL A 
9032 47				ld b, a 
9033 23				inc hl 
9034 7e				ld a,(hl) 
9035 23				inc hl 
9036 cd d5 8f			call atohex 
9039 80				add b 
903a 57				ld d,a 
903b 7e				ld a,(hl) 
903c cd d5 8f			call atohex 
903f cb 3f				SRL A 
9041 cb 3f				SRL A 
9043 cb 3f				SRL A 
9045 cb 3f				SRL A 
9047 47				ld b, a 
9048 23				inc hl 
9049 7e				ld a,(hl) 
904a 23				inc hl 
904b cd d5 8f			call atohex 
904e 80				add b 
904f 5f				ld e, a 
9050 d5				push de 
9051 e1				pop hl 
9052 c9				ret 
9053			 
9053			; pass hl. returns z set if the byte at hl is a digit 
9053			;isdigithl:  
9053			;	push bc 
9053			;	ld a,(hl) 
9053			;	cp ':' 
9053			;	jr nc, .isdf 		; > 
9053			;	cp '0' 
9053			;	jr c, .isdf		; < 
9053			; 
9053			;	; TODO find a better way to set z 
9053			; 
9053			;	ld b,a 
9053			;	cp b 
9053			;	pop bc 
9053			;	ret 
9053			; 
9053			;.isdf:	; not digit so clear z 
9053			; 
9053			;	; TODO find a better way to unset z 
9053			; 
9053			;	ld b,a 
9053			;	inc b 
9053			;	cp b 
9053			; 
9053			;	pop bc 
9053			;	ret 
9053				 
9053				 
9053			 
9053			 
9053			; pass hl as the four byte address to load 
9053			 
9053			get_word_hl:  
9053 e5				push hl 
9054 cd f3 8f			call get_byte 
9057				 
9057 47				ld b, a 
9058			 
9058 e1				pop hl 
9059 23				inc hl 
905a 23				inc hl 
905b			 
905b			; TODO not able to handle a-f  
905b 7e				ld a,(hl) 
905c			;	;cp ':' 
905c			;	cp 'g' 
905c			;	jr nc, .single_byte_hl 		; > 
905c			;	cp 'G' 
905c			;	jr nc, .single_byte_hl 		; > 
905c			;	cp '0' 
905c			;	jr c, .single_byte_hl		; < 
905c			 
905c				;call isdigithl 
905c fe 00			cp 0 
905e 28 06			jr z, .single_byte_hl 
9060			 
9060			.getwhln:   ; hex word so get next byte 
9060			 
9060 cd f3 8f			call get_byte 
9063 6f				ld l, a 
9064 60				ld h,b 
9065 c9				ret 
9066 68			.single_byte_hl:   ld l,b 
9067 26 00				ld h,0 
9069 c9					ret 
906a			 
906a			 
906a			 
906a			 
906a 21 25 98			ld hl,asc+1 
906d			;	ld a, (hl) 
906d			;	call nibble2val 
906d cd f3 8f			call get_byte 
9070			 
9070			;	call fourehexhl 
9070 32 36 e3			ld (scratch+52),a 
9073				 
9073 21 34 e3			ld hl,scratch+50 
9076 22 25 e6			ld (os_cur_ptr),hl 
9079			 
9079 c9				ret 
907a			 
907a			 
907a			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
907a			 
907a			; Decimal Unsigned Version 
907a			 
907a			;Number in a to decimal ASCII 
907a			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
907a			;Example: display a=56 as "056" 
907a			;input: a = number 
907a			;Output: a=0,value of a in the screen 
907a			;destroys af,bc (don't know about hl and de) 
907a			DispAToASCII: 
907a 0e 9c			ld	c,-100 
907c cd 86 90			call	.Na1 
907f 0e f6			ld	c,-10 
9081 cd 86 90			call	.Na1 
9084 0e ff			ld	c,-1 
9086 06 2f		.Na1:	ld	b,'0'-1 
9088 04			.Na2:	inc	b 
9089 81				add	a,c 
908a 38 fc			jr	c,.Na2 
908c 91				sub	c		;works as add 100/10/1 
908d f5				push af		;safer than ld c,a 
908e 78				ld	a,b		;char is in b 
908f			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
908f f1				pop af		;safer than ld a,c 
9090 c9				ret 
9091			 
9091			; Decimal Signed Version 
9091			 
9091			; DispA 
9091			; -------------------------------------------------------------- 
9091			; Converts a signed integer value to a zero-terminated ASCII 
9091			; string representative of that value (using radix 10). 
9091			; -------------------------------------------------------------- 
9091			; INPUTS: 
9091			;     HL     Value to convert (two's complement integer). 
9091			;     DE     Base address of string destination. (pointer). 
9091			; -------------------------------------------------------------- 
9091			; OUTPUTS: 
9091			;     None 
9091			; -------------------------------------------------------------- 
9091			; REGISTERS/MEMORY DESTROYED 
9091			; AF HL 
9091			; -------------------------------------------------------------- 
9091			 
9091			;DispHLToASCII: 
9091			;   push    de 
9091			;   push    bc 
9091			; 
9091			;; Detect sign of HL. 
9091			;    bit    7, h 
9091			;    jr     z, ._DoConvert 
9091			; 
9091			;; HL is negative. Output '-' to string and negate HL. 
9091			;    ld     a, '-' 
9091			;    ld     (de), a 
9091			;    inc    de 
9091			; 
9091			;; Negate HL (using two's complement) 
9091			;    xor    a 
9091			;    sub    l 
9091			;    ld     l, a 
9091			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
9091			;    sbc    a, h 
9091			;    ld     h, a 
9091			; 
9091			;; Convert HL to digit characters 
9091			;._DoConvert: 
9091			;    ld     b, 0     ; B will count character length of number 
9091			;-   ld     a, 10 
9091			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
9091			;    push   af 
9091			;    inc    b 
9091			;    ld     a, h 
9091			;    or     l 
9091			;    jr     nz, - 
9091			; 
9091			;; Retrieve digits from stack 
9091			;-   pop    af 
9091			;    or     $30 
9091			;    ld     (de), a 
9091			;    inc    de 
9091			;    djnz   - 
9091			; 
9091			;; Terminate string with NULL 
9091			;    xor    a 
9091			;    ld     (de), a 
9091			; 
9091			;    pop    bc 
9091			;    pop    de 
9091			;    ret 
9091			 
9091			;Comments 
9091			; 
9091			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
9091			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
9091			;    Note that the output string will not be fixed-width. 
9091			; 
9091			;Example Usage 
9091			; 
9091			;    ld    hl, -1004 
9091			;    ld    de, OP1 
9091			;    call  DispA 
9091			;    ld    hl, OP1 
9091			;    syscall  PutS 
9091			 
9091			 
9091			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
9091			 
9091			 
9091			;Converts an ASCII string to an unsigned 16-bit integer 
9091			;Quits when it reaches a non-decimal digit 
9091			 
9091			string_to_uint16: 
9091			atoui_16: 
9091			;Input: 
9091			;     DE points to the string 
9091			;Outputs: 
9091			;     HL is the result 
9091			;     A is the 8-bit value of the number 
9091			;     DE points to the byte after the number 
9091			;Destroys: 
9091			;     BC 
9091			;       if the string is non-empty, BC is HL/10 
9091			;Size:  24 bytes 
9091			;Speed: 42+d(104+{0,9}) 
9091			;       d is the number of digits in the number 
9091			;       max is 640 cycles for a 5 digit number 
9091			;Assuming no leading zeros: 
9091			;1 digit:  146cc 
9091			;2 digit:  250cc 
9091			;3 digit:  354cc or 363cc (avg: 354.126cc) 
9091			;4 digit:  458cc or 467cc (avg: 458.27cc) 
9091			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
9091			;avg: 544.81158447265625cc (544+13297/16384) 
9091			;=============================================================== 
9091 21 00 00		  ld hl,0 
9094			.u16a: 
9094 1a			  ld a,(de) 
9095 d6 30		  sub 30h 
9097 fe 0a		  cp 10 
9099 d0			  ret nc 
909a 13			  inc de 
909b 44			  ld b,h 
909c 4d			  ld c,l 
909d 29			  add hl,hl 
909e 29			  add hl,hl 
909f 09			  add hl,bc 
90a0 29			  add hl,hl 
90a1 85			  add a,l 
90a2 6f			  ld l,a 
90a3 30 ef		  jr nc,.u16a 
90a5 24			  inc h 
90a6 c3 94 90		  jp .u16a 
90a9			 
90a9			 
90a9			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
90a9			 
90a9			;written by Zeda 
90a9			;Converts a 16-bit unsigned integer to an ASCII string. 
90a9			 
90a9			uitoa_16: 
90a9			;Input: 
90a9			;   DE is the number to convert 
90a9			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
90a9			;Output: 
90a9			;   HL points to the null-terminated ASCII string 
90a9			;      NOTE: This isn't necessarily the same as the input HL. 
90a9 d5			  push de 
90aa c5			  push bc 
90ab f5			  push af 
90ac eb			  ex de,hl 
90ad			 
90ad 01 f0 d8		  ld bc,-10000 
90b0 3e 2f		  ld a,'0'-1 
90b2 3c			  inc a 
90b3 09			  add hl,bc  
90b4 38 fc		   jr c,$-2 
90b6 12			  ld (de),a 
90b7 13			  inc de 
90b8			 
90b8 01 e8 03		  ld bc,1000 
90bb 3e 3a		  ld a,'9'+1 
90bd 3d			  dec a  
90be 09			  add hl,bc  
90bf 30 fc		   jr nc,$-2 
90c1 12			  ld (de),a 
90c2 13			  inc de 
90c3			 
90c3 01 9c ff		  ld bc,-100 
90c6 3e 2f		  ld a,'0'-1 
90c8 3c			  inc a  
90c9 09			  add hl,bc  
90ca 38 fc		   jr c,$-2 
90cc 12			  ld (de),a 
90cd 13			  inc de 
90ce			 
90ce 7d			  ld a,l 
90cf 26 3a		  ld h,'9'+1 
90d1 25			  dec h  
90d2 c6 0a		  add a,10  
90d4 30 fb		   jr nc,$-3 
90d6 c6 30		  add a,'0' 
90d8 eb			  ex de,hl 
90d9 72			  ld (hl),d 
90da 23			  inc hl 
90db 77			  ld (hl),a 
90dc 23			  inc hl 
90dd 36 00		  ld (hl),0 
90df			 
90df			;Now strip the leading zeros 
90df 0e fa		  ld c,-6 
90e1 09			  add hl,bc 
90e2 3e 30		  ld a,'0' 
90e4 23			  inc hl  
90e5 be			  cp (hl)  
90e6 28 fc		  jr z,$-2 
90e8			 
90e8			;Make sure that the string is non-empty! 
90e8 7e			  ld a,(hl) 
90e9 b7			  or a 
90ea 20 01		  jr nz,.atoub 
90ec 2b			  dec hl 
90ed			.atoub: 
90ed			 
90ed f1			  pop af 
90ee c1			  pop bc 
90ef d1			  pop de 
90f0 c9			  ret 
90f1			 
90f1			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
90f1			 
90f1			toUpper: 
90f1			;A is the char. 
90f1			;If A is a lowercase letter, this sets it to the matching uppercase 
90f1			;18cc or 30cc or 41cc 
90f1			;avg: 26.75cc 
90f1 fe 61		  cp 'a' 
90f3 d8			  ret c 
90f4 fe 7b		  cp 'z'+1 
90f6 d0			  ret nc 
90f7 d6 20		  sub 'a'-'A' 
90f9 c9			  ret 
90fa			 
90fa			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
90fa			 
90fa			; String Length 
90fa			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
90fa			 
90fa			; Get the length of the null-terminated string starting at $8000 hl 
90fa			;    LD     HL, $8000 
90fa			 
90fa			strlenz: 
90fa			 
90fa af			    XOR    A               ; Zero is the value we are looking for. 
90fb 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
90fc 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
90fd			                           ; 65, 536 bytes (the entire addressable memory space). 
90fd ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
90ff			 
90ff			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
90ff 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
9100 6f			    LD     L, A             ; number of bytes 
9101 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9103 2b			    DEC    HL              ; Compensate for null. 
9104 c9				ret 
9105			 
9105			; Get the length of the A terminated string starting at $8000 hl 
9105			;    LD     HL, $8000 
9105			 
9105			strlent: 
9105			 
9105			                  ; A is the value we are looking for. 
9105 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
9107 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
9109			                           ; 65, 536 bytes (the entire addressable memory space). 
9109 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
910b			 
910b			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
910b 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
910d 2e 00		    LD     L, 0             ; number of bytes 
910f ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
9111 2b			    DEC    HL              ; Compensate for null. 
9112 c9				ret 
9113			 
9113			 
9113			;Comparing Strings 
9113			 
9113			;IN    HL     Address of string1. 
9113			;      DE     Address of string2. 
9113			 
9113			; doc given but wrong??? 
9113			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
9113			;      carry  Set if string1 > string2, reset if string1 <= string2. 
9113			; tested 
9113			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
9113			 
9113			strcmp_old: 
9113 e5			    PUSH   HL 
9114 d5			    PUSH   DE 
9115			 
9115 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
9116 be			    CP     (HL)            ; (want to minimize work). 
9117 38 01		    JR     C, Str1IsBigger 
9119 7e			    LD     A, (HL) 
911a			 
911a			Str1IsBigger: 
911a 4f			    LD     C, A             ; Put length in BC 
911b 06 00		    LD     B, 0 
911d 13			    INC    DE              ; Increment pointers to meat of string. 
911e 23			    INC    HL 
911f			 
911f			CmpLoop: 
911f 1a			    LD     A, (DE)          ; Compare bytes. 
9120 ed a1		    CPI 
9122 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
9124 13			    INC    DE              ; Update pointer. 
9125 ea 1f 91		    JP     PE, CmpLoop 
9128			 
9128 d1			    POP    DE 
9129 e1			    POP    HL 
912a 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
912b be			    CP     (HL) 
912c c9			    RET 
912d			 
912d			NoMatch: 
912d 2b			    DEC    HL 
912e be			    CP     (HL)            ; Compare again to affect carry. 
912f d1			    POP    DE 
9130 e1			    POP    HL 
9131 c9			    RET 
9132			 
9132			;; test strmp 
9132			; 
9132			;ld de, .str1 
9132			;ld hl, .str2 
9132			;call strcmp 
9132			;jr z, .z1 
9132			;;this 
9132			;	if DEBUG_FORTH_WORDS 
9132			;		DMARK "NZ1" 
9132			;		CALLMONITOR 
9132			;	endif 
9132			;.z1: 
9132			; 
9132			;	if DEBUG_FORTH_WORDS 
9132			;		DMARK "ZZ1" 
9132			;		CALLMONITOR 
9132			;	endif 
9132			; 
9132			;ld de, .str1 
9132			;ld hl, .str1 
9132			;call strcmp 
9132			;jr z, .z2 
9132			;;this 
9132			;	if DEBUG_FORTH_WORDS 
9132			;		DMARK "NZ2" 
9132			;		CALLMONITOR 
9132			;	endif 
9132			;.z2: 
9132			; 
9132			;	if DEBUG_FORTH_WORDS 
9132			;		DMARK "ZZ2" 
9132			;		CALLMONITOR 
9132			;	endif 
9132			; 
9132			;ld de, .str1 
9132			;ld hl, .str2 
9132			;call strcmp 
9132			;jr c, .c1 
9132			; 
9132			;	if DEBUG_FORTH_WORDS 
9132			;		DMARK "Nc1" 
9132			;		CALLMONITOR 
9132			;	endif 
9132			;.c1: 
9132			;;this 
9132			;	if DEBUG_FORTH_WORDS 
9132			;		DMARK "cc1" 
9132			;		CALLMONITOR 
9132			;	endif 
9132			; 
9132			;ld de, .str1 
9132			;ld hl, .str1 
9132			;call strcmp 
9132			;jr c, .c2 
9132			;;this 
9132			;	if DEBUG_FORTH_WORDS 
9132			;		DMARK "Nc2" 
9132			;		CALLMONITOR 
9132			;	endif 
9132			;.c2: 
9132			; 
9132			;	if DEBUG_FORTH_WORDS 
9132			;		DMARK "cc2" 
9132			;		CALLMONITOR 
9132			;	endif 
9132			;	NEXTW 
9132			;.str1:   db "string1",0 
9132			;.str2:   db "string2",0 
9132			 
9132			; only care about direct match or not 
9132			; hl and de strings 
9132			; zero set if the same 
9132			 
9132			strcmp: 
9132 1a				ld a, (de) 
9133 be				cp (hl) 
9134 28 02			jr z, .ssame 
9136 b7				or a 
9137 c9				ret 
9138			 
9138			.ssame:  
9138 fe 00			cp 0 
913a c8				ret z 
913b			 
913b 23				inc hl 
913c 13				inc de 
913d 18 f3			jr strcmp 
913f				 
913f				 
913f			 
913f			 
913f			 
913f			 
913f			; eof 
913f			 
913f			 
913f			 
913f			 
913f			 
913f			 
# End of file firmware_strings.asm
913f			include "firmware_memory.asm"   ; malloc and free  
913f			 
913f			if DEBUG_FORTH_MALLOC_HIGH 
913f			.mallocsize: db "Wants malloc >256",0 
913f			.mallocasize: db "MALLOC gives >256",0 
913f			.malloczero: db "MALLOC gives zero",0 
913f			 
913f			malloc_guard_zerolen: 
913f				push hl 
913f				push de 
913f				push af 
913f			 
913f				ld de, 0 
913f			        call cmp16 
913f				jr nz, .lowalloz 
913f			 
913f				push hl 
913f				push de 
913f					ld hl, display_fb0 
913f					ld (display_fb_active), hl 
913f				call clear_display 
913f				ld a, 0 
913f				ld de, .malloczero 
913f				call str_at_display 
913f				call update_display 
913f				call delay1s 
913f				call delay1s 
913f				ld a, 0 
913f				ld (os_view_disable), a 
913f			 
913f				pop de 
913f				pop hl 
913f			 
913f				 
913f			 
913f				CALLMONITOR 
913f			.lowalloz: 
913f			 
913f			 
913f				pop af 
913f				pop de 
913f				pop hl 
913f			ret 
913f			 
913f			malloc_guard_entry: 
913f				push hl 
913f				push de 
913f				push af 
913f			 
913f			 	or a      ;clear carry flag 
913f				push hl 
913f				ld de, 255 
913f				sbc hl, de 
913f				jr c, .lowalloc 
913f			 
913f				push de 
913f					ld hl, display_fb0 
913f					ld (display_fb_active), hl 
913f				call clear_display 
913f				ld a, 0 
913f				ld de, .mallocsize 
913f				call str_at_display 
913f				call update_display 
913f				call delay1s 
913f				call delay1s 
913f				ld a, 0 
913f				ld (os_view_disable), a 
913f			 
913f				pop de 
913f				pop hl 
913f			 
913f				 
913f			 
913f				CALLMONITOR 
913f				jr .lowdone 
913f			.lowalloc: 
913f			 
913f			 
913f				pop hl 
913f			.lowdone:	pop af 
913f				pop de 
913f				pop hl 
913f			ret 
913f			 
913f			malloc_guard_exit: 
913f				push hl 
913f				push de 
913f				push af 
913f			 
913f			 	or a      ;clear carry flag 
913f				push hl 
913f				ld de, 255 
913f				sbc hl, de 
913f				jr c, .lowallocx 
913f			 
913f				push de 
913f					ld hl, display_fb0 
913f					ld (display_fb_active), hl 
913f				call clear_display 
913f				ld a, 0 
913f				ld de, .mallocasize 
913f				call str_at_display 
913f				call update_display 
913f				call delay1s 
913f				call delay1s 
913f				ld a, 0 
913f				ld (os_view_disable), a 
913f				pop de 
913f				pop hl 
913f			 
913f				CALLMONITOR 
913f				jr .lowdonex 
913f			.lowallocx: 
913f			 
913f				pop hl 
913f			.lowdonex:	pop af 
913f				pop de 
913f				pop hl 
913f			ret 
913f			endif 
913f			 
913f			if MALLOC_2 
913f			; Z80 Malloc and Free Functions 
913f			 
913f			; Malloc Function: 
913f			; Input: 
913f			;   HL: Size of block to allocate 
913f			; Output: 
913f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
913f			 
913f			malloc: 
913f				 
913f			if DEBUG_FORTH_MALLOC_HIGH 
913f			call malloc_guard_entry 
913f			endif 
913f			 
913f			 
913f			 
913f			 
913f					if DEBUG_FORTH_MALLOC 
913f						DMARK "mal" 
913f						CALLMONITOR 
913f					endif 
913f			    push af            ; Save AF register 
913f			    ld a, l            ; Load low byte of size into A 
913f			    or h               ; Check if size is zero 
913f			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
913f			 
913f			    ; Allocate memory 
913f			    ld hl, (heap_start) ; Load start of heap into HL 
913f					if DEBUG_FORTH_MALLOC 
913f						DMARK "ma1" 
913f						CALLMONITOR 
913f					endif 
913f			    call malloc_internal ; Call internal malloc function 
913f			    pop af             ; Restore AF register 
913f			if DEBUG_FORTH_MALLOC_HIGH 
913f			call malloc_guard_exit 
913f			call malloc_guard_zerolen 
913f			endif 
913f			    ret                ; Return 
913f			 
913f			; Free Function: 
913f			; Input: 
913f			;   HL: Pointer to memory block to free 
913f			; Output: 
913f			;   None 
913f			 
913f			free: 
913f			    push af            ; Save AF register 
913f			    ld a, l            ; Load low byte of pointer into A 
913f			    or h               ; Check if pointer is NULL 
913f			    jp z, free_exit    ; If pointer is NULL, exit 
913f			 
913f			    ; Free memory 
913f			    ld hl, (heap_start) ; Load start of heap into HL 
913f			    call free_internal  ; Call internal free function 
913f			    pop af             ; Restore AF register 
913f			    ret                ; Return 
913f			 
913f			; Internal Malloc Function: 
913f			; Input: 
913f			;   HL: Size of block to allocate 
913f			; Output: 
913f			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
913f			 
913f			malloc_internal: 
913f			    ld bc, 2           ; Number of bytes to allocate for management overhead 
913f			    add hl, bc         ; Add management overhead to requested size 
913f			    ex de, hl          ; Save total size in DE, and keep it in HL 
913f					if DEBUG_FORTH_MALLOC 
913f						DMARK "ma2" 
913f						CALLMONITOR 
913f					endif 
913f			 
913f			    ; Search for free memory block 
913f			    ld de, (heap_end)  ; Load end of heap into DE 
913f			    ld bc, 0           ; Initialize counter 
913f			 
913f					if DEBUG_FORTH_MALLOC 
913f						DMARK "ma2" 
913f						CALLMONITOR 
913f					endif 
913f			malloc_search_loop: 
913f			    ; Check if current block is free 
913f			    ld a, (hl)         ; Load current block's status (free or used) 
913f			    cp 0               ; Compare with zero (free) 
913f			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
913f			 
913f			    ; Check if current block is large enough 
913f			    ld a, (hl+1)       ; Load high byte of block size 
913f			    cp l               ; Compare with low byte of requested size 
913f			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
913f			 
913f			    ld a, (hl+2)       ; Load low byte of block size 
913f			    cp h               ; Compare with high byte of requested size 
913f			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
913f			 
913f			    ; Mark block as used 
913f			    ld (hl), 0xFF      ; Set status byte to indicate used block 
913f			 
913f			    ; Calculate remaining space in block 
913f			    ld bc, 0           ; Clear BC 
913f			    add hl, bc         ; Increment HL to point to start of data block 
913f			    add hl, de         ; HL = HL + DE (total size) 
913f			    ld bc, 1           ; Number of bytes to allocate for management overhead 
913f			    add hl, bc         ; Add management overhead to start of data block 
913f			 
913f			    ; Save pointer to allocated block in HL 
913f			if DEBUG_FORTH_MALLOC_HIGH 
913f						DMARK "ma5" 
913f			call malloc_guard_exit 
913f			call malloc_guard_zerolen 
913f			endif 
913f			    ret 
913f			 
913f			malloc_skip_block_check: 
913f			    ; Move to the next block 
913f			    ld bc, 3           ; Size of management overhead 
913f			    add hl, bc         ; Move to the next block 
913f			    inc de             ; Increment counter 
913f			 
913f			    ; Check if we have reached the end of heap 
913f			    ld a, e            ; Load low byte of heap end address 
913f			    cp (hl)            ; Compare with low byte of current address 
913f			    jr nz, malloc_search_loop  ; If not equal, continue searching 
913f			    ld a, d            ; Load high byte of heap end address 
913f			    cp 0               ; Check if it's zero (end of memory) 
913f			    jr nz, malloc_search_loop  ; If not zero, continue searching 
913f			 
913f			    ; If we reached here, allocation failed 
913f			    xor a              ; Set result to NULL 
913f			if DEBUG_FORTH_MALLOC_HIGH 
913f						DMARK "ma6" 
913f			call malloc_guard_exit 
913f			call malloc_guard_zerolen 
913f			endif 
913f			    ret 
913f			malloc_exit: 
913f			if DEBUG_FORTH_MALLOC_HIGH 
913f						DMARK "ma7" 
913f			call malloc_guard_exit 
913f			call malloc_guard_zerolen 
913f			endif 
913f			    ret 
913f			 
913f			; Internal Free Function: 
913f			; Input: 
913f			;   HL: Pointer to memory block to free 
913f			; Output: 
913f			;   None 
913f			 
913f			free_internal: 
913f			    ld de, (heap_start) ; Load start of heap into DE 
913f			    ld bc, 0            ; Initialize counter 
913f			 
913f			free_search_loop: 
913f			    ; Check if current block contains the pointer 
913f			    ld a, l             ; Load low byte of pointer 
913f			    cp (hl+1)           ; Compare with high byte of current block's address 
913f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
913f			    ld a, h             ; Load high byte of pointer 
913f			    cp (hl+2)           ; Compare with low byte of current block's address 
913f			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
913f			 
913f			    ; Mark block as free 
913f			    ld (hl), 0          ; Set status byte to indicate free block 
913f			    ret                 ; Return 
913f			 
913f			free_skip_block_check: 
913f			    ; Move to the next block 
913f			    ld bc, 3            ; Size of management overhead 
913f			    add hl, bc          ; Move to the next block 
913f			    inc de              ; Increment counter 
913f			 
913f			    ; Check if we have reached the end of heap 
913f			    ld a, e             ; Load low byte of heap end address 
913f			    cp (hl)             ; Compare with low byte of current address 
913f			    jr nz, free_search_loop  ; If not equal, continue searching 
913f			    ld a, d             ; Load high byte of heap end address 
913f			    cp 0                ; Check if it's zero (end of memory) 
913f			    jr nz, free_search_loop  ; If not zero, continue searching 
913f			 
913f			    ; If we reached here, pointer is not found in heap 
913f			    ret 
913f			 
913f			free_exit: 
913f			    ret                 ; Return 
913f			 
913f			; Define heap start and end addresses 
913f			;heap_start:    .dw 0xC000   ; Start of heap 
913f			;heap_end:      .dw 0xE000   ; End of heap 
913f			 
913f			endif 
913f			 
913f			 
913f			if MALLOC_1 
913f			 
913f			 
913f			 
913f			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
913f			 
913f			;moved to firmware.asm 
913f			;heap_start        .equ  0x9000      ; Starting address of heap 
913f			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
913f			 
913f			;      .org 0 
913f			;      jp    main 
913f			 
913f			 
913f			;      .org  0x100 
913f			;main: 
913f			;      ld    HL, 0x8100 
913f			;      ld    SP, HL 
913f			; 
913f			;      call  heap_init 
913f			; 
913f			;      ; Make some allocations 
913f			;      ld    HL, 12 
913f			;      call  malloc            ; Allocates 0x9004 
913f			; 
913f			;      ld    HL, 12 
913f			;      call  malloc            ; Allocates 0x9014 
913f			; 
913f			;      ld    HL, 12 
913f			;      call  malloc            ; Allocates 0x9024 
913f			; 
913f			;      ; Free some allocations 
913f			;      ld    HL, 0x9014 
913f			;      call  free 
913f			; 
913f			;      ld    HL, 0x9004 
913f			;      call  free 
913f			; 
913f			;      ld    HL, 0x9024 
913f			;      call  free 
913f			; 
913f			; 
913f			;      halt 
913f			 
913f			 
913f			;------------------------------------------------------------------------------ 
913f			;     heap_init                                                               : 
913f			;                                                                             : 
913f			; Description                                                                 : 
913f			;     Initialise the heap and make it ready for malloc and free operations.   : 
913f			;                                                                             : 
913f			;     The heap is maintained as a linked list, starting with an initial       : 
913f			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
913f			;     the first free block in the heap. Each block then points to the next    : 
913f			;     free block within the heap, and the free list ends at the first block   : 
913f			;     with a null pointer to the next free block.                             : 
913f			;                                                                             : 
913f			; Parameters                                                                  : 
913f			;     Inputs are compile-time only. Two defines which specify the starting    : 
913f			;     address of the heap and its size are required, along with a memory      : 
913f			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
913f			;     principally stores a pointer to the first free block in the heap.       : 
913f			;                                                                             : 
913f			; Returns                                                                     : 
913f			;     Nothing                                                                 : 
913f			;------------------------------------------------------------------------------ 
913f			heap_init: 
913f e5			      push  HL 
9140			 
9140			      ; Initialise free list struct 
9140 21 b5 da		      ld    HL, heap_start 
9143 22 b0 da		      ld    (free_list), HL 
9146 21 00 00		      ld    HL, 0 
9149 22 b2 da		      ld    (free_list+2), HL 
914c			 
914c			      ; Insert first free block at bottom of heap, consumes entire heap 
914c 21 e4 e2		      ld    HL, heap_start+heap_size-4 
914f 22 b5 da		      ld    (heap_start), HL        ; Next block (end of free list) 
9152 21 2f 08		      ld    HL, heap_size-4 
9155 22 b7 da		      ld    (heap_start+2), HL      ; Block size 
9158			 
9158			      ; Insert end of free list block at top of heap - two null words will 
9158			      ; terminate the free list 
9158 21 00 00		      ld    HL, 0 
915b 22 e6 e2		      ld    (heap_start+heap_size-2), HL 
915e 22 e4 e2		      ld    (heap_start+heap_size-4), HL 
9161			 
9161 e1			      pop   HL 
9162			 
9162 c9			      ret 
9163			 
9163			 
9163			;------------------------------------------------------------------------------ 
9163			;     malloc                                                                  : 
9163			;                                                                             : 
9163			; Description                                                                 : 
9163			;     Allocates the wanted space from the heap and returns the address of the : 
9163			;     first useable byte of the allocation.                                   : 
9163			;                                                                             : 
9163			;     Allocations can happen in one of two ways:                              : 
9163			;                                                                             : 
9163			;     1. A free block may be found which is the exact size wanted. In this    : 
9163			;        case the block is removed from the free list and retuedn to the      : 
9163			;        caller.                                                              : 
9163			;     2. A free block may be found which is larger than the size wanted. In   : 
9163			;        this case, the larger block is split into two. The first portion of  : 
9163			;        this block will become the requested space by the malloc call and    : 
9163			;        is returned to the caller. The second portion becomes a new free     : 
9163			;        block, and the free list is adjusted to maintain continuity via this : 
9163			;        newly created block.                                                 : 
9163			;                                                                             : 
9163			;     malloc does not set any initial value in the allocated space, the       : 
9163			;     caller is required to do this as required.                              : 
9163			;                                                                             : 
9163			;     This implementation of malloc uses the stack exclusively, and is        : 
9163			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
9163			;     advisable to disable interrupts before calling malloc, and recommended  : 
9163			;     to avoid the use of malloc inside ISRs in general.                      : 
9163			;                                                                             : 
9163			;     NOTE: heap_init must be called before malloc and free can be used.      : 
9163			;                                                                             : 
9163			; Parameters                                                                  : 
9163			;     HL  Number of bytes wanted                                              : 
9163			;                                                                             : 
9163			; Returns                                                                     : 
9163			;     HL  Address of the first useable byte of the allocation                 : 
9163			;                                                                             : 
9163			; Flags                                                                       : 
9163			;     Z   Set if the allocation did not succeed, clear otherwise              : 
9163			;                                                                             : 
9163			; Stack frame                                                                 : 
9163			;       |             |                                                       : 
9163			;       +-------------+                                                       : 
9163			;       |     BC      |                                                       : 
9163			;       +-------------+                                                       : 
9163			;       |     DE      |                                                       : 
9163			;       +-------------+                                                       : 
9163			;       |     IX      |                                                       : 
9163			;       +-------------+                                                       : 
9163			;       |  prev_free  |                                                       : 
9163			;   +4  +-------------+                                                       : 
9163			;       |  this_free  |                                                       : 
9163			;   +2  +-------------+                                                       : 
9163			;       |  next_free  |                                                       : 
9163			;   +0  +-------------+                                                       : 
9163			;       |             |                                                       : 
9163			;                                                                             : 
9163			;------------------------------------------------------------------------------ 
9163			 
9163			 
9163			;malloc: 
9163			; 
9163			;	SAVESP ON 1 
9163			; 
9163			;	call malloc_code 
9163			; 
9163			;	CHECKSP ON 1 
9163			;	ret 
9163			 
9163			 
9163			malloc: 
9163 c5			      push  BC 
9164 d5			      push  DE 
9165 dd e5		      push  IX 
9167			if DEBUG_FORTH_MALLOC_HIGH 
9167			call malloc_guard_entry 
9167			endif 
9167			 
9167					if DEBUG_FORTH_MALLOC 
9167						DMARK "mal" 
9167						CALLMONITOR 
9167					endif 
9167 7c			      ld    A, H                    ; Exit if no space requested 
9168 b5			      or    L 
9169 ca 28 92		      jp    Z, malloc_early_exit 
916c			 
916c			;inc hl 
916c			;inc hl 
916c			;inc hl 
916c			; 
916c			;inc hl 
916c			;inc hl 
916c			;inc hl 
916c			;inc hl 
916c			;inc hl 
916c			;inc hl 
916c			;inc hl 
916c			;inc hl 
916c			;inc hl 
916c			 
916c			 
916c			 
916c			 
916c					if DEBUG_FORTH_MALLOC 
916c						DMARK "maA" 
916c						CALLMONITOR 
916c					endif 
916c			      ; Set up stack frame 
916c eb			      ex    DE, HL 
916d 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
9170 39			      add   HL, SP 
9171 f9			      ld    SP, HL 
9172 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9176 dd 39		      add   IX, SP 
9178			 
9178			      ; Setup initial state 
9178 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
917b 19			      add   HL, DE 
917c			 
917c 44			      ld    B, H                    ; Move want to BC 
917d 4d			      ld    C, L 
917e			 
917e 21 b0 da		      ld    HL, free_list           ; Store prev_free ptr to stack 
9181 dd 75 04		      ld    (IX+4), L 
9184 dd 74 05		      ld    (IX+5), H 
9187			 
9187 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
9188 23			      inc   HL 
9189 56			      ld    D, (HL) 
918a dd 73 02		      ld    (IX+2), E 
918d dd 72 03		      ld    (IX+3), D 
9190 eb			      ex    DE, HL                  ; this_free ptr into HL 
9191			 
9191					if DEBUG_FORTH_MALLOC 
9191						DMARK "maB" 
9191						CALLMONITOR 
9191					endif 
9191			      ; Loop through free block list to find some space 
9191			malloc_find_space: 
9191 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
9192 23			      inc   HL 
9193 56			      ld    D, (HL) 
9194			 
9194 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
9195 b3			      or    E 
9196 ca 22 92		      jp    Z, malloc_no_space 
9199			 
9199 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
919c dd 72 01		      ld    (IX+1), D 
919f			 
919f			      ; Does this block have enough space to make the allocation? 
919f 23			      inc   HL                      ; Load free block size into DE 
91a0 5e			      ld    E, (HL) 
91a1 23			      inc   HL 
91a2 56			      ld    D, (HL) 
91a3			 
91a3 eb			      ex    DE, HL                  ; Check size of block against want 
91a4 b7			      or    A                       ; Ensure carry flag clear 
91a5 ed 42		      sbc   HL, BC 
91a7 e5			      push  HL                      ; Store the result for later (new block size) 
91a8			 
91a8 ca f7 91		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
91ab 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
91ad			 
91ad			      ; this_free block is not big enough, setup ptrs to test next free block 
91ad e1			      pop   HL                      ; Discard previous result 
91ae			 
91ae dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
91b1 dd 66 03		      ld    H, (IX+3) 
91b4 dd 75 04		      ld    (IX+4), L 
91b7 dd 74 05		      ld    (IX+5), H 
91ba			 
91ba dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
91bd dd 66 01		      ld    H, (IX+1) 
91c0 dd 75 02		      ld    (IX+2), L 
91c3 dd 74 03		      ld    (IX+3), H 
91c6			 
91c6					if DEBUG_FORTH_MALLOC 
91c6						DMARK "MA>" 
91c6						CALLMONITOR 
91c6					endif 
91c6 18 c9		      jr    malloc_find_space 
91c8			 
91c8			      ; split a bigger block into two - requested size and remaining size 
91c8			malloc_alloc_split: 
91c8					if DEBUG_FORTH_MALLOC 
91c8						DMARK "MAs" 
91c8						CALLMONITOR 
91c8					endif 
91c8 eb			      ex    DE, HL                  ; Calculate address of new free block 
91c9 2b			      dec   HL 
91ca 2b			      dec   HL 
91cb 2b			      dec   HL 
91cc 09			      add   HL, BC 
91cd			 
91cd			      ; Create a new block and point it at next_free 
91cd dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
91d0 dd 56 01		      ld    D, (IX+1) 
91d3			 
91d3 73			      ld    (HL), E                 ; Store next_free ptr into new block 
91d4 23			      inc   HL 
91d5 72			      ld    (HL), D 
91d6			 
91d6 d1			      pop   DE                      ; Store size of new block into new block 
91d7 23			      inc   HL 
91d8 73			      ld    (HL), E 
91d9 23			      inc   HL 
91da 72			      ld    (HL), D 
91db			 
91db			      ; Update this_free ptr to point to new block 
91db 2b			      dec   HL 
91dc 2b			      dec   HL 
91dd 2b			      dec   HL 
91de			 
91de dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
91e1 dd 56 03		      ld    D, (IX+3) 
91e4			 
91e4 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
91e7 dd 74 03		      ld    (IX+3), H 
91ea			 
91ea			      ; Modify this_free block to be allocation 
91ea eb			      ex    DE, HL 
91eb af			      xor   A                       ; Null the next block ptr of allocated block 
91ec 77			      ld    (HL), A 
91ed 23			      inc   HL 
91ee 77			      ld    (HL), A 
91ef			 
91ef 23			      inc   HL                      ; Store want size into allocated block 
91f0 71			      ld    (HL), C 
91f1 23			      inc   HL 
91f2 70			      ld    (HL), B 
91f3 23			      inc   HL 
91f4 e5			      push  HL                      ; Address of allocation to return 
91f5			 
91f5 18 19		      jr    malloc_update_links 
91f7			 
91f7			malloc_alloc_fit: 
91f7 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
91f8			 
91f8					if DEBUG_FORTH_MALLOC 
91f8						DMARK "MAf" 
91f8						CALLMONITOR 
91f8					endif 
91f8			      ; Modify this_free block to be allocation 
91f8 eb			      ex    DE, HL 
91f9 2b			      dec   HL 
91fa 2b			      dec   HL 
91fb 2b			      dec   HL 
91fc			 
91fc af			      xor   A                       ; Null the next block ptr of allocated block 
91fd 77			      ld    (HL), A 
91fe 23			      inc   HL 
91ff 77			      ld    (HL), A 
9200			 
9200 23			      inc   HL                      ; Store address of allocation to return 
9201 23			      inc   HL 
9202 23			      inc   HL 
9203 e5			      push  HL 
9204			 
9204			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9204 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9207 dd 66 01		      ld    H, (IX+1) 
920a			 
920a dd 75 02		      ld    (IX+2), L               ; HL to this_free 
920d dd 74 03		      ld    (IX+3), H 
9210			 
9210			 
9210			malloc_update_links: 
9210			      ; Update prev_free ptr to point to this_free 
9210 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9213 dd 66 05		      ld    H, (IX+5) 
9216			 
9216 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
9219 dd 56 03		      ld    D, (IX+3) 
921c			 
921c 73			      ld    (HL), E                 ; this_free ptr into prev_free 
921d 23			      inc   HL 
921e 72			      ld    (HL), D 
921f			 
921f					if DEBUG_FORTH_MALLOC 
921f						DMARK "Mul" 
921f						CALLMONITOR 
921f					endif 
921f			      ; Clear the Z flag to indicate successful allocation 
921f 7a			      ld    A, D 
9220 b3			      or    E 
9221			 
9221 d1			      pop   DE                      ; Address of allocation 
9222					if DEBUG_FORTH_MALLOC 
9222						DMARK "MAu" 
9222						CALLMONITOR 
9222					endif 
9222			 
9222			malloc_no_space: 
9222 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9225 39			      add   HL, SP 
9226 f9			      ld    SP, HL 
9227			 
9227 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
9228					if DEBUG_FORTH_MALLOC 
9228						DMARK "MAN" 
9228						CALLMONITOR 
9228					endif 
9228			 
9228			malloc_early_exit: 
9228					if DEBUG_FORTH_MALLOC 
9228						DMARK "MAx" 
9228						CALLMONITOR 
9228					endif 
9228 dd e1		      pop   IX 
922a d1			      pop   DE 
922b c1			      pop   BC 
922c			 
922c			if DEBUG_FORTH_MALLOC_HIGH 
922c			call malloc_guard_exit 
922c			call malloc_guard_zerolen 
922c			endif 
922c c9			      ret 
922d			 
922d			 
922d			;------------------------------------------------------------------------------ 
922d			;     free                                                                    : 
922d			;                                                                             : 
922d			; Description                                                                 : 
922d			;     Return the space pointed to by HL to the heap. HL must be an address as : 
922d			;     returned by malloc, otherwise the behaviour is undefined.               : 
922d			;                                                                             : 
922d			;     Where possible, directly adjacent free blocks will be merged together   : 
922d			;     into larger blocks to help ensure that the heap does not become         : 
922d			;     excessively fragmented.                                                 : 
922d			;                                                                             : 
922d			;     free does not clear or set any other value into the freed space, and    : 
922d			;     therefore its contents may be visible through subsequent malloc's. The  : 
922d			;     caller should clear the freed space as required.                        : 
922d			;                                                                             : 
922d			;     This implementation of free uses the stack exclusively, and is          : 
922d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
922d			;     advisable to disable interrupts before calling free, and recommended    : 
922d			;     to avoid the use of free inside ISRs in general.                        : 
922d			;                                                                             : 
922d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
922d			;                                                                             : 
922d			; Parameters                                                                  : 
922d			;     HL  Pointer to address of first byte of allocation to be freed          : 
922d			;                                                                             : 
922d			; Returns                                                                     : 
922d			;     Nothing                                                                 : 
922d			;                                                                             : 
922d			; Stack frame                                                                 : 
922d			;       |             |                                                       : 
922d			;       +-------------+                                                       : 
922d			;       |     BC      |                                                       : 
922d			;       +-------------+                                                       : 
922d			;       |     DE      |                                                       : 
922d			;       +-------------+                                                       : 
922d			;       |     IX      |                                                       : 
922d			;       +-------------+                                                       : 
922d			;       |  prev_free  |                                                       : 
922d			;   +2  +-------------+                                                       : 
922d			;       |  next_free  |                                                       : 
922d			;   +0  +-------------+                                                       : 
922d			;       |             |                                                       : 
922d			;                                                                             : 
922d			;------------------------------------------------------------------------------ 
922d			free: 
922d c5			      push  BC 
922e d5			      push  DE 
922f dd e5		      push  IX 
9231			 
9231 7c			      ld    A, H                    ; Exit if ptr is null 
9232 b5			      or    L 
9233 ca f7 92		      jp    Z, free_early_exit 
9236			 
9236			      ; Set up stack frame 
9236 eb			      ex    DE, HL 
9237 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
923a 39			      add   HL, SP 
923b f9			      ld    SP, HL 
923c dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9240 dd 39		      add   IX, SP 
9242			 
9242			      ; The address in HL points to the start of the useable allocated space, 
9242			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9242			      ; address of the block itself. 
9242 eb			      ex    DE, HL 
9243 11 fc ff		      ld    DE, -4 
9246 19			      add   HL, DE 
9247			 
9247			      ; An allocated block must have a null next block pointer in it 
9247 7e			      ld    A, (HL) 
9248 23			      inc   HL 
9249 b6			      or    (HL) 
924a c2 f2 92		      jp    NZ, free_done 
924d			 
924d 2b			      dec   HL 
924e			 
924e 44			      ld    B, H                    ; Copy HL to BC 
924f 4d			      ld    C, L 
9250			 
9250			      ; Loop through the free list to find the first block with an address 
9250			      ; higher than the block being freed 
9250 21 b0 da		      ld    HL, free_list 
9253			 
9253			free_find_higher_block: 
9253 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9254 23			      inc   HL 
9255 56			      ld    D, (HL) 
9256 2b			      dec   HL 
9257			 
9257 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
925a dd 72 01		      ld    (IX+1), D 
925d dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
9260 dd 74 03		      ld    (IX+3), H 
9263			 
9263 78			      ld    A, B                    ; Check if DE is greater than BC 
9264 ba			      cp    D                       ; Compare MSB first 
9265 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
9267 30 04		      jr    NC, free_find_higher_block_skip 
9269 79			      ld    A, C 
926a bb			      cp    E                       ; Then compare LSB 
926b 38 08		      jr    C, free_found_higher_block 
926d			 
926d			free_find_higher_block_skip: 
926d 7a			      ld    A, D                    ; Reached the end of the free list? 
926e b3			      or    E 
926f ca f2 92		      jp    Z, free_done 
9272			 
9272 eb			      ex    DE, HL 
9273			 
9273 18 de		      jr    free_find_higher_block 
9275			 
9275			free_found_higher_block: 
9275			      ; Insert freed block between prev and next free blocks 
9275 71			      ld    (HL), C                 ; Point prev free block to freed block 
9276 23			      inc   HL 
9277 70			      ld    (HL), B 
9278			 
9278 60			      ld    H, B                    ; Point freed block at next free block 
9279 69			      ld    L, C 
927a 73			      ld    (HL), E 
927b 23			      inc   HL 
927c 72			      ld    (HL), D 
927d			 
927d			      ; Check if the freed block is adjacent to the next free block 
927d 23			      inc   HL                      ; Load size of freed block into HL 
927e 5e			      ld    E, (HL) 
927f 23			      inc   HL 
9280 56			      ld    D, (HL) 
9281 eb			      ex    DE, HL 
9282			 
9282 09			      add   HL, BC                  ; Add addr of freed block and its size 
9283			 
9283 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
9286 dd 56 01		      ld    D, (IX+1) 
9289			 
9289 b7			      or    A                       ; Clear the carry flag 
928a ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
928c 20 22		      jr    NZ, free_check_adjacent_to_prev 
928e			 
928e			      ; Freed block is adjacent to next, merge into one bigger block 
928e eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
928f 5e			      ld    E, (HL) 
9290 23			      inc   HL 
9291 56			      ld    D, (HL) 
9292 e5			      push  HL                      ; Save ptr to next block for later 
9293			 
9293 60			      ld    H, B                    ; Store ptr from next block into freed block 
9294 69			      ld    L, C 
9295 73			      ld    (HL), E 
9296 23			      inc   HL 
9297 72			      ld    (HL), D 
9298			 
9298 e1			      pop   HL                      ; Restore ptr to next block 
9299 23			      inc   HL                      ; Load size of next block into DE 
929a 5e			      ld    E, (HL) 
929b 23			      inc   HL 
929c 56			      ld    D, (HL) 
929d d5			      push  DE                      ; Save next block size for later 
929e			 
929e 60			      ld    H, B                    ; Load size of freed block into HL 
929f 69			      ld    L, C 
92a0 23			      inc   HL 
92a1 23			      inc   HL 
92a2 5e			      ld    E, (HL) 
92a3 23			      inc   HL 
92a4 56			      ld    D, (HL) 
92a5 eb			      ex    DE, HL 
92a6			 
92a6 d1			      pop   DE                      ; Restore size of next block 
92a7 19			      add   HL, DE                  ; Add sizes of both blocks 
92a8 eb			      ex    DE, HL 
92a9			 
92a9 60			      ld    H, B                    ; Store new bigger size into freed block 
92aa 69			      ld    L, C 
92ab 23			      inc   HL 
92ac 23			      inc   HL 
92ad 73			      ld    (HL), E 
92ae 23			      inc   HL 
92af 72			      ld    (HL), D 
92b0			 
92b0			free_check_adjacent_to_prev: 
92b0			      ; Check if the freed block is adjacent to the prev free block 
92b0 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
92b3 dd 66 03		      ld    H, (IX+3) 
92b6			 
92b6 23			      inc   HL                      ; Size of prev free block into DE 
92b7 23			      inc   HL 
92b8 5e			      ld    E, (HL) 
92b9 23			      inc   HL 
92ba 56			      ld    D, (HL) 
92bb 2b			      dec   HL 
92bc 2b			      dec   HL 
92bd 2b			      dec   HL 
92be			 
92be 19			      add   HL, DE                  ; Add prev block addr and size 
92bf			 
92bf b7			      or    A                       ; Clear the carry flag 
92c0 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
92c2 20 2e		      jr    NZ, free_done 
92c4			 
92c4			      ; Freed block is adjacent to prev, merge into one bigger block 
92c4 60			      ld    H, B                    ; Load next ptr from freed block into DE 
92c5 69			      ld    L, C 
92c6 5e			      ld    E, (HL) 
92c7 23			      inc   HL 
92c8 56			      ld    D, (HL) 
92c9 e5			      push  HL                      ; Save freed block ptr for later 
92ca			 
92ca dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
92cd dd 66 03		      ld    H, (IX+3) 
92d0 73			      ld    (HL), E 
92d1 23			      inc   HL 
92d2 72			      ld    (HL), D 
92d3			 
92d3 e1			      pop   HL                      ; Restore freed block ptr 
92d4 23			      inc   HL                      ; Load size of freed block into DE 
92d5 5e			      ld    E, (HL) 
92d6 23			      inc   HL 
92d7 56			      ld    D, (HL) 
92d8 d5			      push  DE                      ; Save freed block size for later 
92d9			 
92d9 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
92dc dd 66 03		      ld    H, (IX+3) 
92df 23			      inc   HL 
92e0 23			      inc   HL 
92e1 5e			      ld    E, (HL) 
92e2 23			      inc   HL 
92e3 56			      ld    D, (HL) 
92e4			 
92e4 e1			      pop   HL                      ; Add sizes of both blocks 
92e5 19			      add   HL, DE 
92e6 eb			      ex    DE, HL 
92e7			 
92e7 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
92ea dd 66 03		      ld    H, (IX+3) 
92ed 23			      inc   HL 
92ee 23			      inc   HL 
92ef 73			      ld    (HL), E 
92f0 23			      inc   HL 
92f1 72			      ld    (HL), D 
92f2			 
92f2			free_done: 
92f2 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
92f5 39			      add   HL, SP 
92f6 f9			      ld    SP, HL 
92f7			 
92f7			free_early_exit: 
92f7 dd e1		      pop   IX 
92f9 d1			      pop   DE 
92fa c1			      pop   BC 
92fb			 
92fb c9			      ret 
92fc			 
92fc			; moved to firmware.asm 
92fc			; 
92fc			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
92fc			;                  .dw   0 
92fc			 
92fc			 
92fc			endif 
92fc			 
92fc			 
92fc			if MALLOC_3 
92fc			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
92fc			;heap_start        .equ  0x9000      ; Starting address of heap 
92fc			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
92fc			; 
92fc			 ;     .org 0 
92fc			  ;    jp    main 
92fc			; 
92fc			; 
92fc			 ;     .org  0x100 
92fc			;main: 
92fc			 ;     ld    HL, 0x8100 
92fc			  ;    ld    SP, HL 
92fc			; 
92fc			;      call  heap_init 
92fc			 
92fc			      ; Make some allocations 
92fc			;      ld    HL, 12 
92fc			;      call  malloc            ; Allocates 0x9004 
92fc			; 
92fc			 ;     ld    HL, 12 
92fc			;      call  malloc            ; Allocates 0x9014 
92fc			 
92fc			;      ld    HL, 12 
92fc			;      call  malloc            ; Allocates 0x9024 
92fc			 
92fc			      ; Free some allocations 
92fc			;      ld    HL, 0x9014 
92fc			;      call  free 
92fc			 
92fc			;      ld    HL, 0x9004 
92fc			;      call  free 
92fc			; 
92fc			;      ld    HL, 0x9024 
92fc			;      call  free 
92fc			 
92fc			 
92fc			 ;     halt 
92fc			 
92fc			 
92fc			;------------------------------------------------------------------------------ 
92fc			;     heap_init                                                               : 
92fc			;                                                                             : 
92fc			; Description                                                                 : 
92fc			;     Initialise the heap and make it ready for malloc and free operations.   : 
92fc			;                                                                             : 
92fc			;     The heap is maintained as a linked list, starting with an initial       : 
92fc			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
92fc			;     the first free block in the heap. Each block then points to the next    : 
92fc			;     free block within the heap, and the free list ends at the first block   : 
92fc			;     with a null pointer to the next free block.                             : 
92fc			;                                                                             : 
92fc			; Parameters                                                                  : 
92fc			;     Inputs are compile-time only. Two defines which specify the starting    : 
92fc			;     address of the heap and its size are required, along with a memory      : 
92fc			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
92fc			;     principally stores a pointer to the first free block in the heap.       : 
92fc			;                                                                             : 
92fc			; Returns                                                                     : 
92fc			;     Nothing                                                                 : 
92fc			;------------------------------------------------------------------------------ 
92fc			heap_init: 
92fc			      push  HL 
92fc			 
92fc			      ; Initialise free list struct 
92fc			      ld    HL, heap_start 
92fc			      ld    (free_list), HL 
92fc			      ld    HL, 0 
92fc			      ld    (free_list+2), HL 
92fc			 
92fc			      ; Insert first free block at bottom of heap, consumes entire heap 
92fc			      ld    HL, heap_start+heap_size-4 
92fc			      ld    (heap_start), HL        ; Next block (end of free list) 
92fc			      ld    HL, heap_size-4 
92fc			      ld    (heap_start+2), HL      ; Block size 
92fc			 
92fc			      ; Insert end of free list block at top of heap - two null words will 
92fc			      ; terminate the free list 
92fc			      ld    HL, 0 
92fc			      ld    (heap_start+heap_size-2), HL 
92fc			      ld    (heap_start+heap_size-4), HL 
92fc			 
92fc			      pop   HL 
92fc			 
92fc			      ret 
92fc			 
92fc			 
92fc			;------------------------------------------------------------------------------ 
92fc			;     malloc                                                                  : 
92fc			;                                                                             : 
92fc			; Description                                                                 : 
92fc			;     Allocates the wanted space from the heap and returns the address of the : 
92fc			;     first useable byte of the allocation.                                   : 
92fc			;                                                                             : 
92fc			;     Allocations can happen in one of two ways:                              : 
92fc			;                                                                             : 
92fc			;     1. A free block may be found which is the exact size wanted. In this    : 
92fc			;        case the block is removed from the free list and retuedn to the      : 
92fc			;        caller.                                                              : 
92fc			;     2. A free block may be found which is larger than the size wanted. In   : 
92fc			;        this case, the larger block is split into two. The first portion of  : 
92fc			;        this block will become the requested space by the malloc call and    : 
92fc			;        is returned to the caller. The second portion becomes a new free     : 
92fc			;        block, and the free list is adjusted to maintain continuity via this : 
92fc			;        newly created block.                                                 : 
92fc			;                                                                             : 
92fc			;     malloc does not set any initial value in the allocated space, the       : 
92fc			;     caller is required to do this as required.                              : 
92fc			;                                                                             : 
92fc			;     This implementation of malloc uses the stack exclusively, and is        : 
92fc			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
92fc			;     advisable to disable interrupts before calling malloc, and recommended  : 
92fc			;     to avoid the use of malloc inside ISRs in general.                      : 
92fc			;                                                                             : 
92fc			;     NOTE: heap_init must be called before malloc and free can be used.      : 
92fc			;                                                                             : 
92fc			; Parameters                                                                  : 
92fc			;     HL  Number of bytes wanted                                              : 
92fc			;                                                                             : 
92fc			; Returns                                                                     : 
92fc			;     HL  Address of the first useable byte of the allocation                 : 
92fc			;                                                                             : 
92fc			; Flags                                                                       : 
92fc			;     Z   Set if the allocation did not succeed, clear otherwise              : 
92fc			;                                                                             : 
92fc			; Stack frame                                                                 : 
92fc			;       |             |                                                       : 
92fc			;       +-------------+                                                       : 
92fc			;       |     BC      |                                                       : 
92fc			;       +-------------+                                                       : 
92fc			;       |     DE      |                                                       : 
92fc			;       +-------------+                                                       : 
92fc			;       |     IX      |                                                       : 
92fc			;       +-------------+                                                       : 
92fc			;       |  prev_free  |                                                       : 
92fc			;   +4  +-------------+                                                       : 
92fc			;       |  this_free  |                                                       : 
92fc			;   +2  +-------------+                                                       : 
92fc			;       |  next_free  |                                                       : 
92fc			;   +0  +-------------+                                                       : 
92fc			;       |             |                                                       : 
92fc			;                                                                             : 
92fc			;------------------------------------------------------------------------------ 
92fc			malloc: 
92fc			      push  BC 
92fc			      push  DE 
92fc			      push  IX 
92fc			 
92fc			      ld    A, H                    ; Exit if no space requested 
92fc			      or    L 
92fc			      jp    Z, malloc_early_exit 
92fc			 
92fc			      ; Set up stack frame 
92fc			      ex    DE, HL 
92fc			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
92fc			      add   HL, SP 
92fc			      ld    SP, HL 
92fc			      ld    IX, 0                   ; Use IX as a frame pointer 
92fc			      add   IX, SP 
92fc			 
92fc			      ; Setup initial state 
92fc			      ld    HL, 4                   ; want must also include space used by block struct 
92fc			      add   HL, DE 
92fc			 
92fc			      ld    B, H                    ; Move want to BC 
92fc			      ld    C, L 
92fc			 
92fc			      ld    HL, free_list           ; Store prev_free ptr to stack 
92fc			      ld    (IX+4), L 
92fc			      ld    (IX+5), H 
92fc			 
92fc			      ld    E, (HL)                 ; Store this_free ptr to stack 
92fc			      inc   HL 
92fc			      ld    D, (HL) 
92fc			      ld    (IX+2), E 
92fc			      ld    (IX+3), D 
92fc			      ex    DE, HL                  ; this_free ptr into HL 
92fc			 
92fc			      ; Loop through free block list to find some space 
92fc			malloc_find_space: 
92fc			      ld    E, (HL)                 ; Load next_free ptr into DE 
92fc			      inc   HL 
92fc			      ld    D, (HL) 
92fc			 
92fc			      ld    A, D                    ; Check for null next_free ptr - end of free list 
92fc			      or    E 
92fc			      jp    Z, malloc_no_space 
92fc			 
92fc			      ld    (IX+0), E               ; Store next_free ptr to stack 
92fc			      ld    (IX+1), D 
92fc			 
92fc			      ; Does this block have enough space to make the allocation? 
92fc			      inc   HL                      ; Load free block size into DE 
92fc			      ld    E, (HL) 
92fc			      inc   HL 
92fc			      ld    D, (HL) 
92fc			 
92fc			      ex    DE, HL                  ; Check size of block against want 
92fc			      or    A                       ; Ensure carry flag clear 
92fc			      sbc   HL, BC 
92fc			      push  HL                      ; Store the result for later (new block size) 
92fc			 
92fc			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
92fc			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
92fc			 
92fc			      ; this_free block is not big enough, setup ptrs to test next free block 
92fc			      pop   HL                      ; Discard previous result 
92fc			 
92fc			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
92fc			      ld    H, (IX+3) 
92fc			      ld    (IX+4), L 
92fc			      ld    (IX+5), H 
92fc			 
92fc			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
92fc			      ld    H, (IX+1) 
92fc			      ld    (IX+2), L 
92fc			      ld    (IX+3), H 
92fc			 
92fc			      jr    malloc_find_space 
92fc			 
92fc			      ; split a bigger block into two - requested size and remaining size 
92fc			malloc_alloc_split: 
92fc			      ex    DE, HL                  ; Calculate address of new free block 
92fc			      dec   HL 
92fc			      dec   HL 
92fc			      dec   HL 
92fc			      add   HL, BC 
92fc			 
92fc			      ; Create a new block and point it at next_free 
92fc			      ld    E, (IX+0)               ; Load next_free ptr into DE 
92fc			      ld    D, (IX+1) 
92fc			 
92fc			      ld    (HL), E                 ; Store next_free ptr into new block 
92fc			      inc   HL 
92fc			      ld    (HL), D 
92fc			 
92fc			      pop   DE                      ; Store size of new block into new block 
92fc			      inc   HL 
92fc			      ld    (HL), E 
92fc			      inc   HL 
92fc			      ld    (HL), D 
92fc			 
92fc			      ; Update this_free ptr to point to new block 
92fc			      dec   HL 
92fc			      dec   HL 
92fc			      dec   HL 
92fc			 
92fc			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
92fc			      ld    D, (IX+3) 
92fc			 
92fc			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
92fc			      ld    (IX+3), H 
92fc			 
92fc			      ; Modify this_free block to be allocation 
92fc			      ex    DE, HL 
92fc			      xor   A                       ; Null the next block ptr of allocated block 
92fc			      ld    (HL), A 
92fc			      inc   HL 
92fc			      ld    (HL), A 
92fc			 
92fc			      inc   HL                      ; Store want size into allocated block 
92fc			      ld    (HL), C 
92fc			      inc   HL 
92fc			      ld    (HL), B 
92fc			      inc   HL 
92fc			      push  HL                      ; Address of allocation to return 
92fc			 
92fc			      jr    malloc_update_links 
92fc			 
92fc			malloc_alloc_fit: 
92fc			      pop   HL                      ; Dont need new block size, want is exact fit 
92fc			 
92fc			      ; Modify this_free block to be allocation 
92fc			      ex    DE, HL 
92fc			      dec   HL 
92fc			      dec   HL 
92fc			      dec   HL 
92fc			 
92fc			      xor   A                       ; Null the next block ptr of allocated block 
92fc			      ld    (HL), A 
92fc			      inc   HL 
92fc			      ld    (HL), A 
92fc			 
92fc			      inc   HL                      ; Store address of allocation to return 
92fc			      inc   HL 
92fc			      inc   HL 
92fc			      push  HL 
92fc			 
92fc			      ; Copy next_free ptr to this_free, remove allocated block from free list 
92fc			      ld    L, (IX+0)               ; next_free to HL 
92fc			      ld    H, (IX+1) 
92fc			 
92fc			      ld    (IX+2), L               ; HL to this_free 
92fc			      ld    (IX+3), H 
92fc			 
92fc			 
92fc			malloc_update_links: 
92fc			      ; Update prev_free ptr to point to this_free 
92fc			      ld    L, (IX+4)               ; prev_free ptr to HL 
92fc			      ld    H, (IX+5) 
92fc			 
92fc			      ld    E, (IX+2)               ; this_free ptr to DE 
92fc			      ld    D, (IX+3) 
92fc			 
92fc			      ld    (HL), E                 ; this_free ptr into prev_free 
92fc			      inc   HL 
92fc			      ld    (HL), D 
92fc			 
92fc			      ; Clear the Z flag to indicate successful allocation 
92fc			      ld    A, D 
92fc			      or    E 
92fc			 
92fc			      pop   DE                      ; Address of allocation 
92fc			 
92fc			malloc_no_space: 
92fc			      ld    HL, 6                   ; Clean up stack frame 
92fc			      add   HL, SP 
92fc			      ld    SP, HL 
92fc			 
92fc			      ex    DE, HL                  ; Alloc addr into HL for return 
92fc			 
92fc			malloc_early_exit: 
92fc			      pop   IX 
92fc			      pop   DE 
92fc			      pop   BC 
92fc			 
92fc			      ret 
92fc			 
92fc			 
92fc			;------------------------------------------------------------------------------ 
92fc			;     free                                                                    : 
92fc			;                                                                             : 
92fc			; Description                                                                 : 
92fc			;     Return the space pointed to by HL to the heap. HL must be an address as : 
92fc			;     returned by malloc, otherwise the behaviour is undefined.               : 
92fc			;                                                                             : 
92fc			;     Where possible, directly adjacent free blocks will be merged together   : 
92fc			;     into larger blocks to help ensure that the heap does not become         : 
92fc			;     excessively fragmented.                                                 : 
92fc			;                                                                             : 
92fc			;     free does not clear or set any other value into the freed space, and    : 
92fc			;     therefore its contents may be visible through subsequent malloc's. The  : 
92fc			;     caller should clear the freed space as required.                        : 
92fc			;                                                                             : 
92fc			;     This implementation of free uses the stack exclusively, and is          : 
92fc			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
92fc			;     advisable to disable interrupts before calling free, and recommended    : 
92fc			;     to avoid the use of free inside ISRs in general.                        : 
92fc			;                                                                             : 
92fc			;     NOTE: heap_init must be called before malloc and free can be used.      : 
92fc			;                                                                             : 
92fc			; Parameters                                                                  : 
92fc			;     HL  Pointer to address of first byte of allocation to be freed          : 
92fc			;                                                                             : 
92fc			; Returns                                                                     : 
92fc			;     Nothing                                                                 : 
92fc			;                                                                             : 
92fc			; Stack frame                                                                 : 
92fc			;       |             |                                                       : 
92fc			;       +-------------+                                                       : 
92fc			;       |     BC      |                                                       : 
92fc			;       +-------------+                                                       : 
92fc			;       |     DE      |                                                       : 
92fc			;       +-------------+                                                       : 
92fc			;       |     IX      |                                                       : 
92fc			;       +-------------+                                                       : 
92fc			;       |  prev_free  |                                                       : 
92fc			;   +2  +-------------+                                                       : 
92fc			;       |  next_free  |                                                       : 
92fc			;   +0  +-------------+                                                       : 
92fc			;       |             |                                                       : 
92fc			;                                                                             : 
92fc			;------------------------------------------------------------------------------ 
92fc			free: 
92fc			      push  BC 
92fc			      push  DE 
92fc			      push  IX 
92fc			 
92fc			      ld    A, H                    ; Exit if ptr is null 
92fc			      or    L 
92fc			      jp    Z, free_early_exit 
92fc			 
92fc			      ; Set up stack frame 
92fc			      ex    DE, HL 
92fc			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
92fc			      add   HL, SP 
92fc			      ld    SP, HL 
92fc			      ld    IX, 0                   ; Use IX as a frame pointer 
92fc			      add   IX, SP 
92fc			 
92fc			      ; The address in HL points to the start of the useable allocated space, 
92fc			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
92fc			      ; address of the block itself. 
92fc			      ex    DE, HL 
92fc			      ld    DE, -4 
92fc			      add   HL, DE 
92fc			 
92fc			      ; An allocated block must have a null next block pointer in it 
92fc			      ld    A, (HL) 
92fc			      inc   HL 
92fc			      or    (HL) 
92fc			      jp    NZ, free_done 
92fc			 
92fc			      dec   HL 
92fc			 
92fc			      ld    B, H                    ; Copy HL to BC 
92fc			      ld    C, L 
92fc			 
92fc			      ; Loop through the free list to find the first block with an address 
92fc			      ; higher than the block being freed 
92fc			      ld    HL, free_list 
92fc			 
92fc			free_find_higher_block: 
92fc			      ld    E, (HL)                 ; Load next ptr from free block 
92fc			      inc   HL 
92fc			      ld    D, (HL) 
92fc			      dec   HL 
92fc			 
92fc			      ld    (IX+0), E               ; Save ptr to next free block 
92fc			      ld    (IX+1), D 
92fc			      ld    (IX+2), L               ; Save ptr to prev free block 
92fc			      ld    (IX+3), H 
92fc			 
92fc			      ld    A, B                    ; Check if DE is greater than BC 
92fc			      cp    D                       ; Compare MSB first 
92fc			      jr    Z, $+4                  ; MSB the same, compare LSB 
92fc			      jr    NC, free_find_higher_block_skip 
92fc			      ld    A, C 
92fc			      cp    E                       ; Then compare LSB 
92fc			      jr    C, free_found_higher_block 
92fc			 
92fc			free_find_higher_block_skip: 
92fc			      ld    A, D                    ; Reached the end of the free list? 
92fc			      or    E 
92fc			      jp    Z, free_done 
92fc			 
92fc			      ex    DE, HL 
92fc			 
92fc			      jr    free_find_higher_block 
92fc			 
92fc			free_found_higher_block: 
92fc			      ; Insert freed block between prev and next free blocks 
92fc			      ld    (HL), C                 ; Point prev free block to freed block 
92fc			      inc   HL 
92fc			      ld    (HL), B 
92fc			 
92fc			      ld    H, B                    ; Point freed block at next free block 
92fc			      ld    L, C 
92fc			      ld    (HL), E 
92fc			      inc   HL 
92fc			      ld    (HL), D 
92fc			 
92fc			      ; Check if the freed block is adjacent to the next free block 
92fc			      inc   HL                      ; Load size of freed block into HL 
92fc			      ld    E, (HL) 
92fc			      inc   HL 
92fc			      ld    D, (HL) 
92fc			      ex    DE, HL 
92fc			 
92fc			      add   HL, BC                  ; Add addr of freed block and its size 
92fc			 
92fc			      ld    E, (IX+0)               ; Load addr of next free block into DE 
92fc			      ld    D, (IX+1) 
92fc			 
92fc			      or    A                       ; Clear the carry flag 
92fc			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
92fc			      jr    NZ, free_check_adjacent_to_prev 
92fc			 
92fc			      ; Freed block is adjacent to next, merge into one bigger block 
92fc			      ex    DE, HL                  ; Load next ptr from next block into DE 
92fc			      ld    E, (HL) 
92fc			      inc   HL 
92fc			      ld    D, (HL) 
92fc			      push  HL                      ; Save ptr to next block for later 
92fc			 
92fc			      ld    H, B                    ; Store ptr from next block into freed block 
92fc			      ld    L, C 
92fc			      ld    (HL), E 
92fc			      inc   HL 
92fc			      ld    (HL), D 
92fc			 
92fc			      pop   HL                      ; Restore ptr to next block 
92fc			      inc   HL                      ; Load size of next block into DE 
92fc			      ld    E, (HL) 
92fc			      inc   HL 
92fc			      ld    D, (HL) 
92fc			      push  DE                      ; Save next block size for later 
92fc			 
92fc			      ld    H, B                    ; Load size of freed block into HL 
92fc			      ld    L, C 
92fc			      inc   HL 
92fc			      inc   HL 
92fc			      ld    E, (HL) 
92fc			      inc   HL 
92fc			      ld    D, (HL) 
92fc			      ex    DE, HL 
92fc			 
92fc			      pop   DE                      ; Restore size of next block 
92fc			      add   HL, DE                  ; Add sizes of both blocks 
92fc			      ex    DE, HL 
92fc			 
92fc			      ld    H, B                    ; Store new bigger size into freed block 
92fc			      ld    L, C 
92fc			      inc   HL 
92fc			      inc   HL 
92fc			      ld    (HL), E 
92fc			      inc   HL 
92fc			      ld    (HL), D 
92fc			 
92fc			free_check_adjacent_to_prev: 
92fc			      ; Check if the freed block is adjacent to the prev free block 
92fc			      ld    L, (IX+2)               ; Prev free block ptr into HL 
92fc			      ld    H, (IX+3) 
92fc			 
92fc			      inc   HL                      ; Size of prev free block into DE 
92fc			      inc   HL 
92fc			      ld    E, (HL) 
92fc			      inc   HL 
92fc			      ld    D, (HL) 
92fc			      dec   HL 
92fc			      dec   HL 
92fc			      dec   HL 
92fc			 
92fc			      add   HL, DE                  ; Add prev block addr and size 
92fc			 
92fc			      or    A                       ; Clear the carry flag 
92fc			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
92fc			      jr    NZ, free_done 
92fc			 
92fc			      ; Freed block is adjacent to prev, merge into one bigger block 
92fc			      ld    H, B                    ; Load next ptr from freed block into DE 
92fc			      ld    L, C 
92fc			      ld    E, (HL) 
92fc			      inc   HL 
92fc			      ld    D, (HL) 
92fc			      push  HL                      ; Save freed block ptr for later 
92fc			 
92fc			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
92fc			      ld    H, (IX+3) 
92fc			      ld    (HL), E 
92fc			      inc   HL 
92fc			      ld    (HL), D 
92fc			 
92fc			      pop   HL                      ; Restore freed block ptr 
92fc			      inc   HL                      ; Load size of freed block into DE 
92fc			      ld    E, (HL) 
92fc			      inc   HL 
92fc			      ld    D, (HL) 
92fc			      push  DE                      ; Save freed block size for later 
92fc			 
92fc			      ld    L, (IX+2)               ; Load size of prev block into DE 
92fc			      ld    H, (IX+3) 
92fc			      inc   HL 
92fc			      inc   HL 
92fc			      ld    E, (HL) 
92fc			      inc   HL 
92fc			      ld    D, (HL) 
92fc			 
92fc			      pop   HL                      ; Add sizes of both blocks 
92fc			      add   HL, DE 
92fc			      ex    DE, HL 
92fc			 
92fc			      ld    L, (IX+2)               ; Store new bigger size into prev block 
92fc			      ld    H, (IX+3) 
92fc			      inc   HL 
92fc			      inc   HL 
92fc			      ld    (HL), E 
92fc			      inc   HL 
92fc			      ld    (HL), D 
92fc			 
92fc			free_done: 
92fc			      ld    HL, 4                   ; Clean up stack frame 
92fc			      add   HL, SP 
92fc			      ld    SP, HL 
92fc			 
92fc			free_early_exit: 
92fc			      pop   IX 
92fc			      pop   DE 
92fc			      pop   BC 
92fc			 
92fc			      ret 
92fc			 
92fc			 
92fc			;      .org 0x8000 
92fc			; 
92fc			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
92fc			 ;                 .dw   0 
92fc			 
92fc			endif 
92fc			 
92fc			 
92fc			if MALLOC_4 
92fc			 
92fc			; My memory allocation code. Very very simple.... 
92fc			; allocate space under 250 chars 
92fc			 
92fc			heap_init: 
92fc				; init start of heap as zero 
92fc				;  
92fc			 
92fc				ld hl, heap_start 
92fc				ld a, 0 
92fc				ld (hl), a      ; empty block 
92fc				inc hl 
92fc				ld a, 0 
92fc				ld (hl), a      ; length of block 
92fc				; write end of list 
92fc				inc hl 
92fc				ld a,(hl) 
92fc				inc hl 
92fc				ld a,(hl) 
92fc				 
92fc			 
92fc				; init some malloc vars 
92fc			 
92fc				ld hl, 0 
92fc				ld (free_list), hl       ; store last malloc location 
92fc			 
92fc				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
92fc				ld a, 0 
92fc				ld (hl), a 
92fc			 
92fc			 
92fc				ld hl, heap_start 
92fc				;  
92fc				  
92fc				ret 
92fc			 
92fc			 
92fc			;    free block marker 
92fc			;    requested size  
92fc			;    pointer to next block 
92fc			;    .... 
92fc			;    next block marker 
92fc			 
92fc			 
92fc			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
92fc			; 
92fc			 
92fc			 
92fc			malloc:  
92fc				push de 
92fc				push bc 
92fc				push af 
92fc			 
92fc				; hl space required 
92fc				 
92fc				ld c, l    ; hold space   (TODO only a max of 255) 
92fc			 
92fc			;	inc c     ; TODO BUG need to fix memory leak on push str 
92fc			;	inc c 
92fc			;	inc c 
92fc			;	inc c 
92fc			;	inc c 
92fc			;	inc c 
92fc			;	inc c 
92fc			 
92fc			 
92fc			 
92fc				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
92fc			 
92fc				ld a, (free_list+3) 
92fc				cp 0 
92fc				jr z, .contheap 
92fc			 
92fc				ld hl, (free_list)     ; get last alloc 
92fc					if DEBUG_FORTH_MALLOC_INT 
92fc						DMARK "mrs" 
92fc						CALLMONITOR 
92fc					endif 
92fc				jr .startalloc 
92fc			 
92fc			.contheap: 
92fc				ld hl, heap_start 
92fc			 
92fc			.startalloc: 
92fc			 
92fc					if DEBUG_FORTH_MALLOC_INT 
92fc						DMARK "mym" 
92fc						CALLMONITOR 
92fc					endif 
92fc			.findblock: 
92fc					if DEBUG_FORTH_MALLOC_INT 
92fc						DMARK "mmf" 
92fc						CALLMONITOR 
92fc					endif 
92fc			 
92fc				ld a,(hl)  
92fc				; if byte is zero then clear to use 
92fc			 
92fc				cp 0 
92fc				jr z, .foundemptyblock 
92fc			 
92fc				; if byte is not clear 
92fc				;     then byte is offset to next block 
92fc			 
92fc				inc hl 
92fc				ld a, (hl) ; get size 
92fc			.nextblock:	inc hl 
92fc					ld e, (hl) 
92fc					inc hl 
92fc					ld d, (hl) 
92fc					ex de, hl 
92fc			;	inc hl  ; move past the store space 
92fc			;	inc hl  ; move past zero index  
92fc			 
92fc				; TODO detect no more space 
92fc			 
92fc				push hl 
92fc				ld de, heap_end 
92fc				call cmp16 
92fc				pop hl 
92fc				jr nc, .nospace 
92fc			 
92fc				jr .findblock 
92fc			 
92fc			.nospace: ld hl, 0 
92fc				jp .exit 
92fc			 
92fc			 
92fc			.foundemptyblock:	 
92fc					if DEBUG_FORTH_MALLOC_INT 
92fc						DMARK "mme" 
92fc						CALLMONITOR 
92fc					endif 
92fc			 
92fc			; TODO has block enough space if reusing??? 
92fc			 
92fc				;  
92fc			 
92fc			; see if this block has been previously used 
92fc				inc hl 
92fc				ld a, (hl) 
92fc				dec hl 
92fc				cp 0 
92fc				jr z, .newblock 
92fc			 
92fc					if DEBUG_FORTH_MALLOC_INT 
92fc						DMARK "meR" 
92fc						CALLMONITOR 
92fc					endif 
92fc			 
92fc			; no reusing previously allocated block 
92fc			 
92fc			; is it smaller than previously used? 
92fc				 
92fc				inc hl    ; move to size 
92fc				ld a, c 
92fc				sub (hl)        ; we want c < (hl) 
92fc				dec hl    ; move back to marker 
92fc			        jr z, .findblock 
92fc			 
92fc				; update with the new size which should be lower 
92fc			 
92fc			        ;inc  hl   ; negate next move. move back to size  
92fc			 
92fc			.newblock: 
92fc				; need to be at marker here 
92fc			 
92fc					if DEBUG_FORTH_MALLOC_INT 
92fc						DMARK "meN" 
92fc						CALLMONITOR 
92fc					endif 
92fc			 
92fc			 
92fc				ld a, c 
92fc			 
92fc				ld (free_list+3), a	 ; flag resume from last malloc  
92fc				ld (free_list), hl    ; save out last location 
92fc			 
92fc			 
92fc				;inc a     ; space for length byte 
92fc				ld (hl), a     ; save block in use marker 
92fc			 
92fc				inc hl   ; move to space marker 
92fc				ld (hl), a    ; save new space 
92fc			 
92fc				inc hl   ; move to start of allocated area 
92fc				 
92fc			;	push hl     ; save where we are - 1  
92fc			 
92fc			;	inc hl  ; move past zero index  
92fc				; skip space to set down new marker 
92fc			 
92fc				; provide some extra space for now 
92fc			 
92fc				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
92fc				inc a 
92fc				inc a 
92fc			 
92fc				push hl   ; save where we are in the node block 
92fc			 
92fc				call addatohl 
92fc			 
92fc				; write linked list point 
92fc			 
92fc				pop de     ; get our node position 
92fc				ex de, hl 
92fc			 
92fc				ld (hl), e 
92fc				inc hl 
92fc				ld (hl), d 
92fc			 
92fc				inc hl 
92fc			 
92fc				; now at start of allocated data so save pointer 
92fc			 
92fc				push hl 
92fc			 
92fc				; jump to position of next node and setup empty header in DE 
92fc			 
92fc				ex de, hl 
92fc			 
92fc			;	inc hl ; move past end of block 
92fc			 
92fc				ld a, 0 
92fc				ld (hl), a   ; empty marker 
92fc				inc hl 
92fc				ld (hl), a   ; size 
92fc				inc hl  
92fc				ld (hl), a   ; ptr 
92fc				inc hl 
92fc				ld (hl), a   ; ptr 
92fc			 
92fc			 
92fc				pop hl 
92fc			 
92fc					if DEBUG_FORTH_MALLOC_INT 
92fc						DMARK "mmr" 
92fc						CALLMONITOR 
92fc					endif 
92fc			 
92fc			.exit: 
92fc				pop af 
92fc				pop bc 
92fc				pop de  
92fc				ret 
92fc			 
92fc			 
92fc			 
92fc			 
92fc			free:  
92fc				push hl 
92fc				push af 
92fc				; get address in hl 
92fc			 
92fc					if DEBUG_FORTH_MALLOC_INT 
92fc						DMARK "fre" 
92fc						CALLMONITOR 
92fc					endif 
92fc				; data is at hl - move to block count 
92fc				dec hl 
92fc				dec hl    ; get past pointer 
92fc				dec hl 
92fc			 
92fc				ld a, (hl)    ; need this for a validation check 
92fc			 
92fc				dec hl    ; move to block marker 
92fc			 
92fc				; now check that the block count and block marker are the same  
92fc			        ; this checks that we are on a malloc node and not random memory 
92fc			        ; OK a faint chance this could be a problem but rare - famous last words! 
92fc			 
92fc				ld c, a 
92fc				ld a, (hl)    
92fc			 
92fc				cp c 
92fc				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
92fc			 
92fc				; yes good chance we are on a malloc node 
92fc			 
92fc				ld a, 0      
92fc				ld (hl), a   ; mark as free 
92fc			 
92fc				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
92fc			 
92fc			.freeignore:  
92fc			 
92fc				pop af 
92fc				pop hl 
92fc			 
92fc				ret 
92fc			 
92fc			 
92fc			 
92fc			endif 
92fc			 
92fc			; eof 
# End of file firmware_memory.asm
92fc			  
92fc			; device C  
92fc			if SOUND_ENABLE  
92fc				include "firmware_sound.asm"  
92fc			endif  
92fc			  
92fc			include "firmware_diags.asm"  
92fc			; Hardware diags menu 
92fc			 
92fc			 
92fc			config: 
92fc			 
92fc 3e 00			ld a, 0 
92fe 21 2c 93			ld hl, .configmn 
9301 cd a0 8a			call menu 
9304			 
9304 fe 00			cp 0 
9306 c8				ret z 
9307			 
9307 fe 01			cp 1 
9309 cc 5a 93			call z, .savetostore 
930c			 
930c fe 02			cp 2 
930e cc 46 93			call z, .selautoload 
9311 fe 03			cp 3 
9313 cc 3c 93			call z, .disautoload 
9316 fe 04			cp 4 
9318 cc 50 93			call z, .selbank 
931b fe 05			cp 5 
931d cc 64 93			call z, .debug_tog 
9320 fe 06			cp 6 
9322 cc a7 94			call z, .bpsgo 
9325 fe 07			cp 7 
9327 cc 8a 93			call z, hardware_diags 
932a			 
932a 18 d0			jr config 
932c			 
932c			.configmn: 
932c 98 96			dw prom_c3 
932e af 96			dw prom_c2 
9330 c4 96			dw prom_c2a 
9332 da 96			dw prom_c2b 
9334			;	dw prom_c4 
9334 f7 96			dw prom_m4 
9336 12 97			dw prom_m4b 
9338 1a 97			dw prom_c1 
933a 00 00			dw 0 
933c				 
933c			 
933c			 
933c			 
933c			.disautoload: 
933c				if STORAGE_SE 
933c				ld a, $fe      ; bit 0 clear 
933c				ld (spi_device), a 
933c			 
933c				call storage_get_block_0 
933c			 
933c				ld a, 0 
933c				ld (store_page+STORE_0_AUTOFILE), a 
933c			 
933c					ld hl, 0 
933c					ld de, store_page 
933c				call storage_write_block	 ; save update 
933c				else 
933c			 
933c 21 29 97			ld hl, prom_notav 
933f 11 3f 97			ld de, prom_empty 
9342 cd 00 8a			call info_panel 
9345				endif 
9345			 
9345			 
9345 c9				ret 
9346			 
9346			 
9346			 
9346			; Select auto start 
9346			 
9346			.selautoload: 
9346			 
9346				 
9346				if STORAGE_SE 
9346			 
9346					call config_dir 
9346				        ld hl, scratch 
9346					ld a, 0 
9346					call menu 
9346			 
9346					cp 0 
9346					ret z 
9346			 
9346					dec a 
9346			 
9346			 
9346					; locate menu option 
9346			 
9346					ld hl, scratch 
9346					call table_lookup 
9346			 
9346					if DEBUG_FORTH_WORDS 
9346						DMARK "ALl" 
9346						CALLMONITOR 
9346					endif 
9346					; with the pointer to the menu it, the byte following the zero term is the file id 
9346			 
9346					ld a, 0 
9346					ld bc, 50   ; max of bytes to look at 
9346					cpir  
9346			 
9346					if DEBUG_FORTH_WORDS 
9346						DMARK "ALb" 
9346						CALLMONITOR 
9346					endif 
9346					;inc hl 
9346			 
9346					ld a, (hl)   ; file id 
9346					 
9346				        ; save bank and file ids 
9346			 
9346					push af 
9346			 
9346			; TODO need to save to block 0 on bank 1	 
9346			 
9346					call storage_get_block_0 
9346			 
9346					if DEBUG_FORTH_WORDS 
9346						DMARK "AL0" 
9346						CALLMONITOR 
9346					endif 
9346					pop af 
9346			 
9346					ld (store_page+STORE_0_FILERUN),a 
9346					 
9346					; save bank id 
9346			 
9346					ld a,(spi_device) 
9346					ld (store_page+STORE_0_BANKRUN),a 
9346			 
9346					; enable auto run of store file 
9346			 
9346					ld a, 1 
9346					ld (store_page+STORE_0_AUTOFILE),a 
9346			 
9346					; save buffer 
9346			 
9346					ld hl, 0 
9346					ld de, store_page 
9346					if DEBUG_FORTH_WORDS 
9346						DMARK "ALw" 
9346						CALLMONITOR 
9346					endif 
9346				call storage_write_block	 ; save update 
9346			  
9346			 
9346			 
9346			 
9346					ld hl, scratch 
9346					call config_fdir 
9346			 
9346				else 
9346			 
9346 21 29 97			ld hl, prom_notav 
9349 11 3f 97			ld de, prom_empty 
934c cd 00 8a			call info_panel 
934f			 
934f				endif 
934f c9				ret 
9350			 
9350			 
9350			 
9350			; Select storage bank 
9350			 
9350			.selbank: 
9350			 
9350				if STORAGE_SE 
9350				else 
9350			 
9350 21 29 97			ld hl, prom_notav 
9353 11 3f 97			ld de, prom_empty 
9356 cd 00 8a			call info_panel 
9359				endif 
9359				 
9359 c9				ret 
935a			 
935a			if STORAGE_SE 
935a			 
935a			.config_ldir:   
935a				; Load storage bank labels into menu array 
935a			 
935a				 
935a			 
935a			 
935a				ret 
935a			 
935a			 
935a			endif 
935a			 
935a			 
935a			; Save user words to storage 
935a			 
935a			.savetostore: 
935a			 
935a				if STORAGE_SE 
935a			 
935a					call config_dir 
935a				        ld hl, scratch 
935a					ld a, 0 
935a					call menu 
935a					 
935a					ld hl, scratch 
935a					call config_fdir 
935a			 
935a				else 
935a			 
935a 21 29 97			ld hl, prom_notav 
935d 11 3f 97			ld de, prom_empty 
9360 cd 00 8a			call info_panel 
9363			 
9363				endif 
9363			 
9363 c9				ret 
9364			 
9364			 
9364			 
9364			if STORAGE_SE 
9364			 
9364			config_fdir: 
9364				; using the scratch dir go through and release the memory allocated for each string 
9364				 
9364				ld hl, scratch 
9364			.cfdir:	ld e,(hl) 
9364				inc hl 
9364				ld d,(hl) 
9364				inc hl 
9364			 
9364				ex de, hl 
9364				call ishlzero 
9364				ret z     ; return on null pointer 
9364				call free 
9364				ex de, hl 
9364				jr .cfdir 
9364			 
9364			 
9364				ret 
9364			 
9364			 
9364			config_dir: 
9364			 
9364				; for the config menus that need to build a directory of storage call this routine 
9364				; it will construct a menu in scratch to pass to menu 
9364			 
9364				; open storage device 
9364			 
9364				; execute DIR to build a list of files and their ids into scratch in menu format 
9364				; once the menu has finished then will need to call config_fdir to release the strings 
9364				 
9364				; c = number items 
9364			 
9364				 
9364				call storage_get_block_0 
9364			 
9364				ld hl, store_page     ; get current id count 
9364				ld b, (hl) 
9364				ld c, 0    ; count of files   
9364			 
9364			 
9364				ld hl, scratch 
9364				ld (store_tmp2), hl    ; location to poke strings 
9364			 
9364				; check for empty drive 
9364			 
9364				ld a, 0 
9364				cp b 
9364				jp z, .dirdone 
9364			 
9364				 
9364					if DEBUG_FORTH_WORDS 
9364						DMARK "Cdc" 
9364						CALLMONITOR 
9364					endif 
9364			 
9364			 
9364			.diritem:	 
9364				push bc 
9364				; for each of the current ids do a search for them and if found push to stack 
9364			 
9364					ld hl, STORE_BLOCK_PHY 
9364					ld d, 0		 ; look for extent 0 of block id as this contains file name 
9364					ld e,b 
9364			 
9364					call storage_findnextid 
9364			 
9364			 
9364					; if found hl will be non zero 
9364			 
9364					call ishlzero 
9364					jr z, .dirnotfound 
9364			 
9364					; increase count 
9364			 
9364					pop bc	 
9364					inc c 
9364					push bc 
9364					 
9364			 
9364					; get file header and push the file name 
9364			 
9364					ld de, store_page 
9364					call storage_read_block 
9364			 
9364					; push file id to stack 
9364				 
9364					ld a, (store_page) 
9364					ld h, 0 
9364					ld l, a 
9364			 
9364					;call forth_push_numhl 
9364					; TODO store id 
9364			 
9364					push hl 
9364			 
9364					; push extent count to stack  
9364				 
9364					ld hl, store_page+3 
9364			 
9364					; get file name length 
9364			 
9364					call strlenz   
9364			 
9364					inc hl   ; cover zero term 
9364					inc hl  ; stick the id at the end of the area 
9364			 
9364					push hl 
9364					pop bc    ; move length to bc 
9364			 
9364					call malloc 
9364			 
9364					; TODO save malloc area to scratch 
9364			 
9364					ex de, hl 
9364					ld hl, (store_tmp2) 
9364					ld (hl), e 
9364					inc hl 
9364					ld (hl), d 
9364					inc hl 
9364					ld (store_tmp2), hl 
9364			 
9364					 
9364			 
9364					;pop hl   ; get source 
9364			;		ex de, hl    ; swap aronund	 
9364			 
9364					ld hl, store_page+3 
9364					if DEBUG_FORTH_WORDS 
9364						DMARK "CFd" 
9364						CALLMONITOR 
9364					endif 
9364					ldir 
9364			 
9364					; de is past string, move back one and store id 
9364					 
9364					dec de 
9364			 
9364					; store file id 
9364			 
9364					pop hl 
9364					ex de,hl 
9364					ld (hl), e 
9364			 
9364					if DEBUG_FORTH_WORDS 
9364						DMARK "Cdi" 
9364						CALLMONITOR 
9364					endif 
9364					 
9364			.dirnotfound: 
9364					pop bc     
9364					djnz .diritem 
9364				 
9364			.dirdone:	 
9364			 
9364					ld a, 0 
9364					ld hl, (store_tmp2) 
9364					ld (hl), a 
9364					inc hl 
9364					ld (hl), a 
9364					inc hl 
9364					; push a count of the dir items found 
9364			 
9364			;		ld h, 0 
9364			;		ld l, c 
9364			 
9364				ret 
9364			 
9364			endif 
9364			 
9364			 
9364			; Settings 
9364			; Run  
9364			 
9364			 
9364			 
9364			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
9364			;;hd_menu2:   db "        2: Editor",0   
9364			;hd_menu2:   db "        2: Editor       6: Menu",0   
9364			;hd_menu3:   db "        3: Storage",0 
9364			;hd_menu4:   db "0=quit  4: Debug",0 
9364			;hd_don:     db "ON",0 
9364			;hd_doff:     db "OFF",0 
9364			; 
9364			; 
9364			; 
9364			;hardware_diags_old:       
9364			; 
9364			;.diagmenu: 
9364			;	call clear_display 
9364			;	ld a, display_row_1 
9364			;	ld de, hd_menu1 
9364			;	call str_at_display 
9364			; 
9364			;	ld a, display_row_2 
9364			;	ld de, hd_menu2 
9364			;	call str_at_display 
9364			; 
9364			;	ld a, display_row_3 
9364			;	ld de, hd_menu3 
9364			;	call str_at_display 
9364			; 
9364			;	ld a,  display_row_4 
9364			;	ld de, hd_menu4 
9364			;	call str_at_display 
9364			; 
9364			;	; display debug state 
9364			; 
9364			;	ld de, hd_don 
9364			;	ld a, (os_view_disable) 
9364			;	cp 0 
9364			;	jr z, .distog 
9364			;	ld de, hd_doff 
9364			;.distog: ld a, display_row_4+17 
9364			;	call str_at_display 
9364			; 
9364			;	call update_display 
9364			; 
9364			;	call cin_wait 
9364			; 
9364			; 
9364			; 
9364			;	cp '4' 
9364			;	jr nz, .diagn1 
9364			; 
9364			;	; debug toggle 
9364			; 
9364			;	ld a, (os_view_disable) 
9364			;	ld b, '*' 
9364			;	cp 0 
9364			;	jr z, .debtog 
9364			;	ld b, 0 
9364			;.debtog:	 
9364			;	ld a,b 
9364			;	ld (os_view_disable),a 
9364			; 
9364			;.diagn1: cp '0' 
9364			;	 ret z 
9364			; 
9364			;;	cp '1' 
9364			;;       jp z, matrix	 
9364			;;   TODO keyboard matrix test 
9364			; 
9364			;	cp '2' 
9364			;	jp z, .diagedit 
9364			; 
9364			;;	cp '6' 
9364			;;	jp z, .menutest 
9364			;;if ENABLE_BASIC 
9364			;;	cp '6' 
9364			;;	jp z, basic 
9364			;;endif 
9364			 ; 
9364			;	jp .diagmenu 
9364			; 
9364			; 
9364			;	ret 
9364			 
9364			 
9364			.debug_tog: 
9364 21 ab 93			ld hl, .menudebug 
9367				 
9367 3a f3 e2			ld a, (os_view_disable) 
936a fe 2a			cp '*' 
936c 20 04			jr nz,.tdon  
936e 3e 01			ld a, 1 
9370 18 02			jr .tog1 
9372 3e 00		.tdon: ld a, 0 
9374			 
9374			.tog1: 
9374 cd a0 8a			call menu 
9377 fe 00			cp 0 
9379 c8				ret z 
937a fe 01			cp 1    ; disable debug 
937c 28 04			jr z, .dtog0 
937e 3e 2a			ld a, '*' 
9380 18 02			jr .dtogset 
9382 3e 00		.dtog0: ld a, 0 
9384 32 f3 e2		.dtogset:  ld (os_view_disable), a 
9387 c3 64 93			jp .debug_tog 
938a			 
938a			 
938a			hardware_diags:       
938a			 
938a			.diagm: 
938a 21 9d 93			ld hl, .menuitems 
938d 3e 00			ld a, 0 
938f cd a0 8a			call menu 
9392			 
9392 fe 00		         cp 0 
9394 c8				 ret z 
9395			 
9395 fe 02			cp 2 
9397 ca f6 93			jp z, .diagedit 
939a			 
939a			;	cp '6' 
939a			;	jp z, .menutest 
939a			;if ENABLE_BASIC 
939a			;	cp '6' 
939a			;	jp z, basic 
939a			;endif 
939a			  
939a c3 8a 93			jp .diagm 
939d			 
939d				 
939d b1 93		.menuitems:   	dw .m1 
939f bc 93				dw .m2 
93a1 c3 93				dw .m3 
93a3 cb 93				dw .m5 
93a5 d1 93				dw .m5a 
93a7 da 93				dw .m5b 
93a9 00 00				dw 0 
93ab			 
93ab			.menudebug: 
93ab e3 93				dw .m6 
93ad ec 93				dw .m7 
93af 00 00				dw 0 
93b1			 
93b1 .. 00		.m1:   db "Key Matrix",0 
93bc .. 00		.m2:   db "Editor",0 
93c3 .. 00		.m3:   db "Storage",0 
93cb .. 00		.m5:   db "Sound",0 
93d1 .. 00		.m5a:  db "RAM Test",0 
93da .. 00		.m5b:  db "LCD Test",0 
93e3			 
93e3 .. 00		.m6:   db "Debug ON",0 
93ec .. 00		.m7:   db "Debug OFF",0 
93f6			 
93f6			; debug editor 
93f6			 
93f6			.diagedit: 
93f6			 
93f6 21 02 e3			ld hl, scratch 
93f9			;	ld bc, 250 
93f9			;	ldir 
93f9				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
93f9 3e 00			ld a, 0 
93fb 77				ld (hl), a 
93fc 23				inc hl 
93fd 77				ld (hl), a 
93fe 23				inc hl 
93ff 77				ld (hl), a 
9400			 
9400 cd 6f 8a		        call clear_display 
9403 cd 92 8a			call update_display 
9406				;ld a, 1 
9406				;ld (hardware_diag), a 
9406			.diloop: 
9406 3e 00			ld a, display_row_1 
9408 0e 00			ld c, 0 
940a 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
940c 1e 28			ld e, 40 
940e			 
940e 21 02 e3			ld hl, scratch	 
9411 cd c9 8c			call input_str 
9414			 
9414 3e 28			ld a, display_row_2 
9416 11 02 e3			ld de, scratch 
9419 cd 82 8a			call str_at_display 
941c cd 92 8a			call update_display 
941f			 
941f c3 06 94			jp .diloop 
9422			 
9422			 
9422			; pass word in hl 
9422			; a has display location 
9422			display_word_at: 
9422 f5				push af 
9423 e5				push hl 
9424 7c				ld a,h 
9425 21 07 e6			ld hl, os_word_scratch 
9428 cd 9d 8f			call hexout 
942b e1				pop hl 
942c 7d				ld a,l 
942d 21 09 e6			ld hl, os_word_scratch+2 
9430 cd 9d 8f			call hexout 
9433 21 0b e6			ld hl, os_word_scratch+4 
9436 3e 00			ld a,0 
9438 77				ld (hl),a 
9439 11 07 e6			ld de,os_word_scratch 
943c f1				pop af 
943d cd 82 8a				call str_at_display 
9440 c9				ret 
9441			 
9441			display_ptr_state: 
9441			 
9441				; to restore afterwards 
9441			 
9441 d5				push de 
9442 c5				push bc 
9443 e5				push hl 
9444 f5				push af 
9445			 
9445				; for use in here 
9445			 
9445			;	push bc 
9445			;	push de 
9445			;	push hl 
9445			;	push af 
9445			 
9445 cd 6f 8a			call clear_display 
9448			 
9448 11 1b 96			ld de, .ptrstate 
944b 3e 00			ld a, display_row_1 
944d cd 82 8a			call str_at_display 
9450			 
9450				; display debug step 
9450			 
9450			 
9450 11 71 ee			ld de, debug_mark 
9453 3e 26			ld a, display_row_1+display_cols-2 
9455 cd 82 8a			call str_at_display 
9458			 
9458				; display a 
9458 11 25 96			ld de, .ptrcliptr 
945b 3e 28			ld a, display_row_2 
945d cd 82 8a			call str_at_display 
9460			 
9460 f1				pop af 
9461 2a 4d ea			ld hl,(cli_ptr) 
9464 3e 30			ld a, display_row_2+8 
9466 cd 22 94			call display_word_at 
9469			 
9469			 
9469				; display hl 
9469			 
9469			 
9469 11 2d 96			ld de, .ptrclioptr 
946c 3e 32			ld a, display_row_2+10 
946e cd 82 8a			call str_at_display 
9471			; 
9471			;	pop hl 
9471 3e 35			ld a, display_row_2+13 
9473 2a 4b ea			ld hl,(cli_origptr) 
9476 cd 22 94			call display_word_at 
9479			; 
9479			;	 
9479			;	; display de 
9479			 
9479			;	ld de, .regstatede 
9479			;	ld a, display_row_3 
9479			;	call str_at_display 
9479			 
9479			;	pop de 
9479			;	ld h,d 
9479			;	ld l, e 
9479			;	ld a, display_row_3+3 
9479			;	call display_word_at 
9479			 
9479			 
9479				; display bc 
9479			 
9479			;	ld de, .regstatebc 
9479			;	ld a, display_row_3+10 
9479			;	call str_at_display 
9479			 
9479			;	pop bc 
9479			;	ld h,b 
9479			;	ld l, c 
9479			;	ld a, display_row_3+13 
9479			;	call display_word_at 
9479			 
9479			 
9479				; display dsp 
9479			 
9479			;	ld de, .regstatedsp 
9479			;	ld a, display_row_4 
9479			;	call str_at_display 
9479			 
9479				 
9479			;	ld hl,(cli_data_sp) 
9479			;	ld a, display_row_4+4 
9479			;	call display_word_at 
9479			 
9479				; display rsp 
9479			 
9479 11 5c 96			ld de, .regstatersp 
947c 3e 82			ld a, display_row_4+10 
947e cd 82 8a			call str_at_display 
9481			 
9481				 
9481 2a 33 ea			ld hl,(cli_ret_sp) 
9484 3e 86			ld a, display_row_4+14 
9486 cd 22 94			call display_word_at 
9489			 
9489 cd 92 8a			call update_display 
948c			 
948c cd ec 89			call delay1s 
948f cd ec 89			call delay1s 
9492 cd ec 89			call delay1s 
9495			 
9495			 
9495 cd 86 9a			call next_page_prompt 
9498			 
9498				; restore  
9498			 
9498 f1				pop af 
9499 e1				pop hl 
949a c1				pop bc 
949b d1				pop de 
949c c9				ret 
949d			 
949d			break_point_state: 
949d f5				push af 
949e			 
949e				; see if disabled 
949e			 
949e 3a f3 e2			ld a, (os_view_disable) 
94a1 fe 2a			cp '*' 
94a3 20 02			jr nz, .bpsgo 
94a5 f1				pop af 
94a6 c9				ret 
94a7			 
94a7			.bpsgo: 
94a7 f1				pop af 
94a8 f5				push af 
94a9 22 ef e2			ld (os_view_hl), hl 
94ac ed 53 ed e2		ld (os_view_de), de 
94b0 ed 43 eb e2		ld (os_view_bc), bc 
94b4 e5				push hl 
94b5 6f				ld l, a 
94b6 26 00			ld h, 0 
94b8 22 f1 e2			ld (os_view_af),hl 
94bb			 
94bb 21 b7 ed				ld hl, display_fb0 
94be 22 d2 eb				ld (display_fb_active), hl 
94c1 e1				pop hl	 
94c2			 
94c2 3e 31			ld a, '1' 
94c4 fe 2a		.bps1:  cp '*' 
94c6 20 03			jr nz, .bps1b 
94c8 32 f3 e2			ld (os_view_disable),a 
94cb fe 31		.bps1b:  cp '1' 
94cd 20 14			jr nz, .bps2 
94cf			 
94cf				; display reg 
94cf			 
94cf				 
94cf			 
94cf 3a f1 e2			ld a, (os_view_af) 
94d2 2a ef e2			ld hl, (os_view_hl) 
94d5 ed 5b ed e2		ld de, (os_view_de) 
94d9 ed 4b eb e2		ld bc, (os_view_bc) 
94dd cd 77 95			call display_reg_state 
94e0 c3 63 95			jp .bpschk 
94e3			 
94e3 fe 32		.bps2:  cp '2' 
94e5 20 08			jr nz, .bps3 
94e7				 
94e7				; display hl 
94e7 2a ef e2			ld hl, (os_view_hl) 
94ea cd 61 96			call display_dump_at_hl 
94ed			 
94ed 18 74			jr .bpschk 
94ef			 
94ef fe 33		.bps3:  cp '3' 
94f1 20 08			jr nz, .bps4 
94f3			 
94f3			        ; display de 
94f3 2a ed e2			ld hl, (os_view_de) 
94f6 cd 61 96			call display_dump_at_hl 
94f9			 
94f9 18 68			jr .bpschk 
94fb fe 34		.bps4:  cp '4' 
94fd 20 08			jr nz, .bps5 
94ff			 
94ff			        ; display bc 
94ff 2a eb e2			ld hl, (os_view_bc) 
9502 cd 61 96			call display_dump_at_hl 
9505			 
9505 18 5c			jr .bpschk 
9507 fe 35		.bps5:  cp '5' 
9509 20 08		        jr nz, .bps7 
950b			 
950b				; display cur ptr 
950b 2a 4d ea			ld hl, (cli_ptr) 
950e cd 61 96			call display_dump_at_hl 
9511			 
9511 18 50			jr .bpschk 
9513 fe 36		.bps7:  cp '6' 
9515 20 08			jr nz, .bps8b 
9517				 
9517				; display cur orig ptr 
9517 2a 4b ea			ld hl, (cli_origptr) 
951a cd 61 96			call display_dump_at_hl 
951d 18 44			jr .bpschk 
951f fe 37		.bps8b:  cp '7' 
9521 20 08			jr nz, .bps9 
9523				 
9523				; display dsp 
9523 2a 2f ea			ld hl, (cli_data_sp) 
9526 cd 61 96			call display_dump_at_hl 
9529			 
9529 18 38			jr .bpschk 
952b fe 39		.bps9:  cp '9' 
952d 20 05			jr nz, .bps8c 
952f				 
952f				; display SP 
952f			;	ld hl, sp 
952f cd 61 96			call display_dump_at_hl 
9532			 
9532 18 2f			jr .bpschk 
9534 fe 38		.bps8c:  cp '8' 
9536 20 08			jr nz, .bps8d 
9538				 
9538				; display rsp 
9538 2a 33 ea			ld hl, (cli_ret_sp) 
953b cd 61 96			call display_dump_at_hl 
953e			 
953e 18 23			jr .bpschk 
9540 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
9542 20 05			jr nz, .bps8 
9544 cd 7c 98			call monitor 
9547			 
9547 18 1a			jr .bpschk 
9549 fe 30		.bps8:  cp '0' 
954b 20 16			jr nz, .bpschk 
954d			 
954d 21 16 ed				ld hl, display_fb1 
9550 22 d2 eb				ld (display_fb_active), hl 
9553 cd 92 8a				call update_display 
9556			 
9556				;ld a, (os_view_af) 
9556 2a ef e2			ld hl, (os_view_hl) 
9559 ed 5b ed e2		ld de, (os_view_de) 
955d ed 4b eb e2		ld bc, (os_view_bc) 
9561 f1				pop af 
9562 c9				ret 
9563			 
9563			.bpschk:   
9563 cd ec 89			call delay1s 
9566 3e 9f		ld a,display_row_4 + display_cols - 1 
9568 11 84 9a		        ld de, endprg 
956b cd 82 8a			call str_at_display 
956e cd 92 8a			call update_display 
9571 cd 91 da			call cin_wait 
9574			 
9574 c3 c4 94			jp .bps1 
9577			 
9577			 
9577			display_reg_state: 
9577			 
9577				; to restore afterwards 
9577			 
9577 d5				push de 
9578 c5				push bc 
9579 e5				push hl 
957a f5				push af 
957b			 
957b				; for use in here 
957b			 
957b c5				push bc 
957c d5				push de 
957d e5				push hl 
957e f5				push af 
957f			 
957f cd 6f 8a			call clear_display 
9582			 
9582 11 37 96			ld de, .regstate 
9585 3e 00			ld a, display_row_1 
9587 cd 82 8a			call str_at_display 
958a			 
958a				; display debug step 
958a			 
958a			 
958a 11 71 ee			ld de, debug_mark 
958d 3e 25			ld a, display_row_1+display_cols-3 
958f cd 82 8a			call str_at_display 
9592			 
9592				; display a 
9592 11 53 96			ld de, .regstatea 
9595 3e 28			ld a, display_row_2 
9597 cd 82 8a			call str_at_display 
959a			 
959a e1				pop hl 
959b			;	ld h,0 
959b			;	ld l, a 
959b 3e 2b			ld a, display_row_2+3 
959d cd 22 94			call display_word_at 
95a0			 
95a0			 
95a0				; display hl 
95a0			 
95a0			 
95a0 11 47 96			ld de, .regstatehl 
95a3 3e 32			ld a, display_row_2+10 
95a5 cd 82 8a			call str_at_display 
95a8			 
95a8 e1				pop hl 
95a9 3e 35			ld a, display_row_2+13 
95ab cd 22 94			call display_word_at 
95ae			 
95ae				 
95ae				; display de 
95ae			 
95ae 11 4b 96			ld de, .regstatede 
95b1 3e 50			ld a, display_row_3 
95b3 cd 82 8a			call str_at_display 
95b6			 
95b6 e1				pop hl 
95b7			;	ld h,d 
95b7			;	ld l, e 
95b7 3e 53			ld a, display_row_3+3 
95b9 cd 22 94			call display_word_at 
95bc			 
95bc			 
95bc				; display bc 
95bc			 
95bc 11 4f 96			ld de, .regstatebc 
95bf 3e 5a			ld a, display_row_3+10 
95c1 cd 82 8a			call str_at_display 
95c4			 
95c4 e1				pop hl 
95c5			;	ld h,b 
95c5			;	ld l, c 
95c5 3e 5d			ld a, display_row_3+13 
95c7 cd 22 94			call display_word_at 
95ca			 
95ca			 
95ca				; display dsp 
95ca			 
95ca 11 57 96			ld de, .regstatedsp 
95cd 3e 78			ld a, display_row_4 
95cf cd 82 8a			call str_at_display 
95d2			 
95d2				 
95d2 2a 2f ea			ld hl,(cli_data_sp) 
95d5 3e 7c			ld a, display_row_4+4 
95d7 cd 22 94			call display_word_at 
95da			 
95da				; display rsp 
95da			 
95da 11 5c 96			ld de, .regstatersp 
95dd 3e 82			ld a, display_row_4+10 
95df cd 82 8a			call str_at_display 
95e2			 
95e2				 
95e2 2a 33 ea			ld hl,(cli_ret_sp) 
95e5 3e 86			ld a, display_row_4+14 
95e7 cd 22 94			call display_word_at 
95ea			 
95ea cd 92 8a			call update_display 
95ed			 
95ed			;	call delay1s 
95ed			;	call delay1s 
95ed			;	call delay1s 
95ed			 
95ed			 
95ed			;	call next_page_prompt 
95ed			 
95ed				; restore  
95ed			 
95ed f1				pop af 
95ee e1				pop hl 
95ef c1				pop bc 
95f0 d1				pop de 
95f1 c9				ret 
95f2			 
95f2 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
9606 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
961b .. 00		.ptrstate:	db "Ptr State",0 
9625 .. 00		.ptrcliptr:     db "cli_ptr",0 
962d .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9637 .. 00		.regstate:	db "Reg State (1/0)",0 
9647 .. 00		.regstatehl:	db "HL:",0 
964b .. 00		.regstatede:	db "DE:",0 
964f .. 00		.regstatebc:	db "BC:",0 
9653 .. 00		.regstatea:	db "A :",0 
9657 .. 00		.regstatedsp:	db "DSP:",0 
965c .. 00		.regstatersp:	db "RSP:",0 
9661			 
9661			display_dump_at_hl: 
9661 e5				push hl 
9662 d5				push de 
9663 c5				push bc 
9664 f5				push af 
9665			 
9665 22 25 e6			ld (os_cur_ptr),hl	 
9668 cd 6f 8a			call clear_display 
966b cd 8e 99			call dumpcont 
966e			;	call delay1s 
966e			;	call next_page_prompt 
966e			 
966e			 
966e f1				pop af 
966f c1				pop bc 
9670 d1				pop de 
9671 e1				pop hl 
9672 c9				ret 
9673			 
9673			;if ENABLE_BASIC 
9673			;	include "nascombasic.asm" 
9673			;	basic: 
9673			;	include "forth/FORTH.ASM" 
9673			;endif 
9673			 
9673			; eof 
9673			 
9673			 
# End of file firmware_diags.asm
9673			  
9673			include "firmware_prompts.asm"  
9673			; Prompts  
9673			 
9673			; boot messages 
9673			 
9673 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
9688 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
9698			 
9698			 
9698			; config menus 
9698			 
9698 .. 00		prom_c3: db "Add Dictionary To File",0 
96af .. 00		prom_c2: db "Select Autoload File",0 
96c4 .. 00		prom_c2a: db "Disable Autoload File", 0 
96da .. 00		prom_c2b: db "Select Storage Bank",0 
96ee .. 00		prom_c4: db "Settings",0 
96f7 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
9712 .. 00		prom_m4b:   db "Monitor",0 
971a .. 00		prom_c1: db "Hardware Diags",0 
9729			 
9729			 
9729 .. 00		prom_notav:    db "Feature not available",0 
973f .. 00		prom_empty:    db "",0 
9740			 
9740			; eof 
9740			 
# End of file firmware_prompts.asm
9740			  
9740			  
9740			; eof  
9740			  
# End of file firmware.asm
9740			 
9740			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9740			;if BASE_KEV  
9740			;baseram: equ 08000h 
9740			;endif 
9740			 
9740			;if BASE_SC114 
9740			;baseram:     equ    endofcode 
9740			;endif 
9740			 
9740			 
9740			; start system 
9740			 
9740			coldstart: 
9740				; set sp 
9740				; di/ei 
9740			 
9740 f3				di 
9741 31 00 f0			ld sp, tos 
9744			;	ei 
9744			 
9744			 
9744				; disable breakpoint by default 
9744			 
9744 3e 2a			ld a,'*' 
9746 32 f3 e2			ld (os_view_disable),a 
9749			 
9749				; init hardware 
9749			 
9749				; init keyboard and screen hardware 
9749			 
9749 cd 1c 80			call hardware_init 
974c			 
974c			 
974c cd ec 89			call delay1s 
974f 3e 58			ld a, display_row_3+8 
9751 11 03 80			ld de, buildtime 
9754 cd 82 8a			call str_at_display 
9757 cd 92 8a			call update_display 
975a			 
975a cd ec 89			call delay1s 
975d cd ec 89			call delay1s 
9760 cd ec 89			call delay1s 
9763			 
9763				; detect if any keys are held down to enable breakpoints at start up 
9763			 
9763 cd 97 da			call cin  
9766 fe 00			cp 0 
9768 28 03			jr z, .nokeys 
976a			 
976a				;call hardware_diags 
976a cd fc 92			call config 
976d			 
976d			;	ld de, .bpen 
976d			;	ld a, display_row_4 
976d			;	call str_at_display 
976d			;	call update_display 
976d			; 
976d			;	ld a,0 
976d			;	ld (os_view_disable),a 
976d			; 
976d			;.bpwait: 
976d			;	call cin 
976d			;	cp 0 
976d			;	jr z, .bpwait 
976d			;	jr .nokeys 
976d			; 
976d			; 
976d			;.bpen:  db "Break points enabled!",0 
976d			 
976d			 
976d			 
976d			 
976d			 
976d			 
976d			.nokeys: 
976d			 
976d			 
976d				 
976d			 
976d			;jp  testkey 
976d			 
976d			;call storage_get_block_0 
976d			; 
976d			;ld hl, 0 
976d			;ld de, store_page 
976d			;call storage_read_block 
976d			 
976d				 
976d			;ld hl, 10 
976d			;ld de, store_page 
976d			;call storage_read_block 
976d			 
976d			 
976d			 
976d			 
976d			 
976d			;stop:	nop 
976d			;	jp stop 
976d			 
976d			 
976d			 
976d			main: 
976d cd 6f 8a			call clear_display 
9770 cd 92 8a			call update_display 
9773			 
9773			 
9773			 
9773			;	call testlcd 
9773			 
9773			 
9773			 
9773 cd 4c 9e			call forth_init 
9776			 
9776			 
9776			warmstart: 
9776 cd 22 9e			call forth_warmstart 
9779			 
9779				; run startup word load 
9779			        ; TODO prevent this running at warmstart after crash  
9779			 
9779				if STARTUP_ENABLE 
9779					if STORAGE_SE 
9779						call forth_autoload 
9779					endif 
9779 cd 2b d7				call forth_startup 
977c			 
977c			 
977c				endif 
977c			 
977c				; show free memory after boot 
977c 11 16 98			ld de, freeram 
977f 3e 00			ld a, display_row_1 
9781 cd 82 8a			call str_at_display 
9784			 
9784			; Or use heap_size word???? 
9784 21 e8 e2			ld hl, heap_end 
9787 11 b5 da			ld de, heap_start 
978a ed 52			sbc hl, de 
978c e5				push hl 
978d 7c				ld a,h	         	 
978e 21 07 e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
9791 cd 9d 8f			call hexout 
9794 e1			   	pop hl 
9795			 
9795 7d				ld a,l 
9796 21 09 e6			ld hl, os_word_scratch+2 
9799 cd 9d 8f			call hexout 
979c 21 0b e6			ld hl, os_word_scratch+4 
979f 3e 00			ld a, 0 
97a1 77				ld (hl),a 
97a2 11 07 e6			ld de, os_word_scratch 
97a5 3e 0d			ld a, display_row_1 + 13 
97a7 cd 82 8a			call str_at_display 
97aa cd 92 8a			call update_display 
97ad			 
97ad			 
97ad				;call demo 
97ad			 
97ad			 
97ad				; init scratch input area for cli commands 
97ad			 
97ad 21 29 e6			ld hl, os_cli_cmd 
97b0 3e 00			ld a,0 
97b2 77				ld (hl),a 
97b3 23				inc hl 
97b4 77				ld (hl),a 
97b5			 
97b5 3e 00			ld a,0 
97b7 32 28 e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
97ba			 
97ba 32 25 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
97bd 32 26 e6			ld (os_cur_ptr+1),a	 
97c0			 
97c0 32 07 e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
97c3 32 08 e6			ld (os_word_scratch+1),a	 
97c6				 
97c6			 
97c6				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97c6 21 29 e6			ld hl, os_cli_cmd 
97c9			 
97c9 3e 00			ld a, 0		 ; init cli input 
97cb 77				ld (hl), a 
97cc 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
97ce			cli: 
97ce				; show cli prompt 
97ce				;push af 
97ce				;ld a, 0 
97ce				;ld de, prompt 
97ce				;call str_at_display 
97ce			 
97ce				;call update_display 
97ce				;pop af 
97ce				;inc a 
97ce				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
97ce 0e 00			ld c, 0 
97d0 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
97d2 1e 28			ld e, 40 
97d4			 
97d4 21 29 e6			ld hl, os_cli_cmd 
97d7			 
97d7				STACKFRAME OFF $fefe $9f9f 
97d7				if DEBUG_STACK_IMB 
97d7					if OFF 
97d7						exx 
97d7						ld de, $fefe 
97d7						ld a, d 
97d7						ld hl, curframe 
97d7						call hexout 
97d7						ld a, e 
97d7						ld hl, curframe+2 
97d7						call hexout 
97d7						ld hl, $fefe 
97d7						push hl 
97d7						ld hl, $9f9f 
97d7						push hl 
97d7						exx 
97d7					endif 
97d7				endif 
97d7			endm 
# End of macro STACKFRAME
97d7			 
97d7 cd c9 8c			call input_str 
97da			 
97da				STACKFRAMECHK OFF $fefe $9f9f 
97da				if DEBUG_STACK_IMB 
97da					if OFF 
97da						exx 
97da						ld hl, $9f9f 
97da						pop de   ; $9f9f 
97da						call cmp16 
97da						jr nz, .spnosame 
97da						ld hl, $fefe 
97da						pop de   ; $fefe 
97da						call cmp16 
97da						jr z, .spfrsame 
97da						.spnosame: call showsperror 
97da						.spfrsame: nop 
97da						exx 
97da					endif 
97da				endif 
97da			endm 
# End of macro STACKFRAMECHK
97da			 
97da				; copy input to last command 
97da			 
97da 21 29 e6			ld hl, os_cli_cmd 
97dd 11 28 e7			ld de, os_last_cmd 
97e0 01 ff 00			ld bc, 255 
97e3 ed b0			ldir 
97e5			 
97e5				; wipe current buffer 
97e5			 
97e5			;	ld a, 0 
97e5			;	ld hl, os_cli_cmd 
97e5			;	ld de, os_cli_cmd+1 
97e5			;	ld bc, 254 
97e5			;	ldir 
97e5				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
97e5			;	call strcpy 
97e5			;	ld a, 0 
97e5			;	ld (hl), a 
97e5			;	inc hl 
97e5			;	ld (hl), a 
97e5			;	inc hl 
97e5			;	ld (hl), a 
97e5			 
97e5				; switch frame buffer to program  
97e5			 
97e5 21 16 ed				ld hl, display_fb1 
97e8 22 d2 eb				ld (display_fb_active), hl 
97eb			 
97eb			;	nop 
97eb				STACKFRAME ON $fbfe $8f9f 
97eb				if DEBUG_STACK_IMB 
97eb					if ON 
97eb						exx 
97eb						ld de, $fbfe 
97eb						ld a, d 
97eb						ld hl, curframe 
97eb						call hexout 
97eb						ld a, e 
97eb						ld hl, curframe+2 
97eb						call hexout 
97eb						ld hl, $fbfe 
97eb						push hl 
97eb						ld hl, $8f9f 
97eb						push hl 
97eb						exx 
97eb					endif 
97eb				endif 
97eb			endm 
# End of macro STACKFRAME
97eb				; first time into the parser so pass over the current scratch pad 
97eb 21 29 e6			ld hl,os_cli_cmd 
97ee				; tokenise the entered statement(s) in HL 
97ee cd ca 9e			call forthparse 
97f1			        ; exec forth statements in top of return stack 
97f1 cd 0a 9f			call forthexec 
97f4				;call forthexec_cleanup 
97f4			;	call parsenext 
97f4			 
97f4				STACKFRAMECHK ON $fbfe $8f9f 
97f4				if DEBUG_STACK_IMB 
97f4					if ON 
97f4						exx 
97f4						ld hl, $8f9f 
97f4						pop de   ; $8f9f 
97f4						call cmp16 
97f4						jr nz, .spnosame 
97f4						ld hl, $fbfe 
97f4						pop de   ; $fbfe 
97f4						call cmp16 
97f4						jr z, .spfrsame 
97f4						.spnosame: call showsperror 
97f4						.spfrsame: nop 
97f4						exx 
97f4					endif 
97f4				endif 
97f4			endm 
# End of macro STACKFRAMECHK
97f4				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
97f4			 
97f4 3e 78			ld a, display_row_4 
97f6 11 28 98			ld de, endprog 
97f9			 
97f9 cd 92 8a			call update_display		 
97fc			 
97fc cd 86 9a			call next_page_prompt 
97ff			 
97ff				; switch frame buffer to cli 
97ff			 
97ff 21 b7 ed				ld hl, display_fb0 
9802 22 d2 eb				ld (display_fb_active), hl 
9805			 
9805			 
9805 cd 6f 8a		        call clear_display 
9808 cd 92 8a			call update_display		 
980b			 
980b 21 29 e6			ld hl, os_cli_cmd 
980e			 
980e 3e 00			ld a, 0		 ; init cli input 
9810 77				ld (hl), a 
9811			 
9811				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
9811			 
9811				; now on last line 
9811			 
9811				; TODO scroll screen up 
9811			 
9811				; TODO instead just clear screen and place at top of screen 
9811			 
9811			;	ld a, 0 
9811			;	ld (f_cursor_ptr),a 
9811			 
9811				;call clear_display 
9811				;call update_display 
9811			 
9811				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9811 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
9813 c3 ce 97			jp cli 
9816			 
9816 .. 00		freeram: db "Free bytes: $",0 
9824 ..			asc: db "1A2F" 
9828 .. 00		endprog: db "End prog...",0 
9834			 
9834			testenter2:   
9834 21 34 e3			ld hl,scratch+50 
9837 22 25 e6			ld (os_cur_ptr),hl 
983a c3 ce 97			jp cli 
983d			 
983d			testenter:  
983d			 
983d 21 24 98			ld hl,asc 
9840			;	ld a,(hl) 
9840			;	call nibble2val 
9840 cd f3 8f			call get_byte 
9843			 
9843			 
9843			;	ld a,(hl) 
9843			;	call atohex 
9843			 
9843			;	call fourehexhl 
9843 32 34 e3			ld (scratch+50),a 
9846			 
9846			 
9846			 
9846 21 26 98			ld hl,asc+2 
9849			;	ld a, (hl) 
9849			;	call nibble2val 
9849 cd f3 8f			call get_byte 
984c			 
984c			;	call fourehexhl 
984c 32 36 e3			ld (scratch+52),a 
984f				 
984f 21 34 e3			ld hl,scratch+50 
9852 22 25 e6			ld (os_cur_ptr),hl 
9855 c3 ce 97			jp cli 
9858			 
9858			enter:	 
9858 3a 06 e3			ld a,(scratch+4) 
985b fe 00			cp 0 
985d 28 0c			jr z, .entercont 
985f				; no, not a null term line so has an address to work out.... 
985f			 
985f 21 04 e3			ld hl,scratch+2 
9862 cd 53 90			call get_word_hl 
9865			 
9865 22 25 e6			ld (os_cur_ptr),hl	 
9868 c3 ce 97			jp cli 
986b			 
986b			 
986b			.entercont:  
986b			 
986b 21 04 e3			ld hl, scratch+2 
986e cd f3 8f			call get_byte 
9871			 
9871 2a 25 e6		   	ld hl,(os_cur_ptr) 
9874 77					ld (hl),a 
9875 23					inc hl 
9876 22 25 e6				ld (os_cur_ptr),hl 
9879				 
9879			; get byte  
9879			 
9879			 
9879 c3 ce 97			jp cli 
987c			 
987c			 
987c			; basic monitor support 
987c			 
987c			monitor: 
987c				;  
987c cd 6f 8a			call clear_display 
987f 3e 00			ld a, 0 
9881 11 c9 98			ld de, .monprompt 
9884 cd 82 8a			call str_at_display 
9887 cd 92 8a			call update_display 
988a			 
988a				; get a monitor command 
988a			 
988a 0e 00			ld c, 0     ; entry at top left 
988c 16 64			ld d, 100   ; max buffer size 
988e 1e 0f			ld e, 15    ; input scroll area 
9890 3e 00			ld a, 0     ; init string 
9892 21 00 e5			ld hl, os_input 
9895 77				ld (hl), a 
9896 23				inc hl 
9897 77				ld (hl), a 
9898 21 00 e5			ld hl, os_input 
989b 3e 01			ld a, 1     ; init string 
989d cd c9 8c			call input_str 
98a0			 
98a0 cd 6f 8a		        call clear_display 
98a3 cd 92 8a			call update_display		 
98a6			 
98a6 3a 00 e5			ld a, (os_input) 
98a9 cd f1 90			call toUpper 
98ac fe 48		        cp 'H' 
98ae 28 6f		        jr z, .monhelp 
98b0 fe 44			cp 'D'		; dump 
98b2 ca 40 99			jp z, .mondump	 
98b5 fe 43			cp 'C'		; dump 
98b7 ca 5a 99			jp z, .moncdump	 
98ba fe 4d			cp 'M'		; dump 
98bc ca cb 98			jp z, .moneditstart 
98bf fe 55			cp 'U'		; dump 
98c1 28 14			jr z, .monedit	 
98c3 fe 51			cp 'Q'		; dump 
98c5 c8				ret z	 
98c6			 
98c6			 
98c6				; TODO "S" to access symbol by name and not need the address 
98c6				; TODO "F" to find a string in memory 
98c6			 
98c6 c3 7c 98			jp monitor 
98c9			 
98c9 .. 00		.monprompt: db ">", 0 
98cb			 
98cb			.moneditstart: 
98cb				; get starting address 
98cb			 
98cb 21 02 e5			ld hl,os_input+2 
98ce cd 53 90			call get_word_hl 
98d1			 
98d1 22 25 e6			ld (os_cur_ptr),hl	 
98d4			 
98d4 c3 7c 98			jp monitor 
98d7			 
98d7			.monedit: 
98d7				; get byte to load 
98d7			 
98d7 21 02 e5			ld hl,os_input+2 
98da cd f3 8f			call get_byte 
98dd			 
98dd				; get address to update 
98dd 2a 25 e6			ld hl, (os_cur_ptr) 
98e0			 
98e0				; update byte 
98e0			 
98e0 77				ld (hl), a 
98e1			 
98e1				; move to next address and save it 
98e1			 
98e1 23				inc hl 
98e2 22 25 e6			ld (os_cur_ptr),hl	 
98e5			 
98e5 c3 7c 98			jp monitor 
98e8			 
98e8			 
98e8 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
98fc .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9918 .. 00		.monhelptext3:  db "Q-Quit",0 
991f			        
991f			.monhelp: 
991f 3e 00			ld a, display_row_1 
9921 11 e8 98		        ld de, .monhelptext1 
9924			 
9924 cd 82 8a			call str_at_display 
9927 3e 28			ld a, display_row_2 
9929 11 fc 98		        ld de, .monhelptext2 
992c					 
992c cd 82 8a			call str_at_display 
992f 3e 50			ld a, display_row_3 
9931 11 18 99		        ld de, .monhelptext3 
9934					 
9934 cd 82 8a			call str_at_display 
9937 cd 92 8a			call update_display		 
993a			 
993a cd 86 9a			call next_page_prompt 
993d c3 7c 98			jp monitor 
9940			 
9940			.mondump:    
9940 21 02 e5			ld hl,os_input+2 
9943 cd 53 90			call get_word_hl 
9946			 
9946 22 25 e6			ld (os_cur_ptr),hl	 
9949 cd 8e 99			call dumpcont 
994c 3e 78			ld a, display_row_4 
994e 11 28 98			ld de, endprog 
9951			 
9951 cd 92 8a			call update_display		 
9954			 
9954 cd 86 9a			call next_page_prompt 
9957 c3 7c 98			jp monitor 
995a			.moncdump: 
995a cd 8e 99			call dumpcont 
995d 3e 78			ld a, display_row_4 
995f 11 28 98			ld de, endprog 
9962			 
9962 cd 92 8a			call update_display		 
9965			 
9965 cd 86 9a			call next_page_prompt 
9968 c3 7c 98			jp monitor 
996b			 
996b			 
996b			; TODO symbol access  
996b			 
996b			.symbols:     ;; A list of symbols that can be called up  
996b b7 ed			dw display_fb0 
996d .. 00			db "fb0",0  
9971 84 ea		     	dw store_page 
9973 .. 00			db "store_page",0 
997e			 
997e			 
997e			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
997e			 
997e 3a 03 e3			ld a,(scratch+1) 
9981 fe 00			cp 0 
9983 28 09			jr z, dumpcont 
9985			 
9985				; no, not a null term line so has an address to work out.... 
9985			 
9985 21 04 e3			ld hl,scratch+2 
9988 cd 53 90			call get_word_hl 
998b			 
998b 22 25 e6			ld (os_cur_ptr),hl	 
998e			 
998e			 
998e			 
998e			dumpcont: 
998e			 
998e				; dump bytes at ptr 
998e			 
998e			 
998e 3e 00			ld a, display_row_1 
9990 2a d2 eb			ld hl, (display_fb_active) 
9993 cd 9c 8c			call addatohl 
9996 cd be 99			call .dumpbyterow 
9999			 
9999 3e 28			ld a, display_row_2 
999b 2a d2 eb			ld hl, (display_fb_active) 
999e cd 9c 8c			call addatohl 
99a1 cd be 99			call .dumpbyterow 
99a4			 
99a4			 
99a4 3e 50			ld a, display_row_3 
99a6 2a d2 eb			ld hl, (display_fb_active) 
99a9 cd 9c 8c			call addatohl 
99ac cd be 99			call .dumpbyterow 
99af			 
99af 3e 78			ld a, display_row_4 
99b1 2a d2 eb			ld hl, (display_fb_active) 
99b4 cd 9c 8c			call addatohl 
99b7 cd be 99			call .dumpbyterow 
99ba			 
99ba cd 92 8a			call update_display 
99bd			;		jp cli 
99bd c9				ret 
99be			 
99be			.dumpbyterow: 
99be			 
99be				;push af 
99be			 
99be e5				push hl 
99bf			 
99bf				; calc where to poke the ascii 
99bf			if display_cols == 20 
99bf				ld a, 16 
99bf			else 
99bf 3e 1f			ld a, 31 
99c1			endif 
99c1			 
99c1 cd 9c 8c			call addatohl 
99c4 22 07 e6			ld (os_word_scratch),hl  		; save pos for later 
99c7			 
99c7			 
99c7			; display decoding address 
99c7 2a 25 e6		   	ld hl,(os_cur_ptr) 
99ca			 
99ca 7c				ld a,h 
99cb e1				pop hl 
99cc e5				push hl 
99cd			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
99cd cd 9d 8f			call hexout 
99d0 2a 25 e6		   	ld hl,(os_cur_ptr) 
99d3			 
99d3 7d				ld a,l 
99d4 e1				pop hl 
99d5 23				inc hl 
99d6 23				inc hl 
99d7 e5				push hl 
99d8			;	ld hl, os_word_scratch+2 
99d8 cd 9d 8f			call hexout 
99db e1				pop hl 
99dc 23				inc hl 
99dd 23				inc hl 
99de				;ld hl, os_word_scratch+4 
99de 3e 3a			ld a, ':' 
99e0 77				ld (hl),a 
99e1 23				inc hl 
99e2				;ld a, 0 
99e2				;ld (hl),a 
99e2				;ld de, os_word_scratch 
99e2				;pop af 
99e2				;push af 
99e2			;		ld a, display_row_2 
99e2			;		call str_at_display 
99e2			;		call update_display 
99e2			 
99e2			 
99e2			;pop af 
99e2			;	add 5 
99e2			 
99e2			if display_cols == 20 
99e2				ld b, 4 
99e2			else 
99e2 06 08			ld b, 8 
99e4			endif	 
99e4			 
99e4			.dumpbyte: 
99e4 c5				push bc 
99e5 e5				push hl 
99e6			 
99e6			 
99e6 2a 25 e6		   	ld hl,(os_cur_ptr) 
99e9 7e					ld a,(hl) 
99ea			 
99ea					; poke the ascii to display 
99ea 2a 07 e6				ld hl,(os_word_scratch) 
99ed 77					ld (hl),a 
99ee 23					inc hl 
99ef 22 07 e6				ld (os_word_scratch),hl 
99f2			 
99f2					 
99f2			 
99f2			 
99f2 e1					pop hl 
99f3 e5					push hl 
99f4			 
99f4 cd 9d 8f				call hexout 
99f7			 
99f7					 
99f7 2a 25 e6		   	ld hl,(os_cur_ptr) 
99fa 23				inc hl 
99fb 22 25 e6		   	ld (os_cur_ptr),hl 
99fe			 
99fe e1					pop hl 
99ff 23					inc hl 
9a00 23					inc hl 
9a01 23					inc hl 
9a02			 
9a02			 
9a02			 
9a02					;ld a,0 
9a02					;ld (os_word_scratch+2),a 
9a02					;pop af 
9a02					;push af 
9a02			 
9a02					;ld de, os_word_scratch 
9a02					;call str_at_display 
9a02			;		call update_display 
9a02			;		pop af 
9a02 c1					pop bc 
9a03 c6 03				add 3 
9a05 10 dd			djnz .dumpbyte 
9a07			 
9a07				 
9a07			 
9a07 c9				ret 
9a08			 
9a08			jump:	 
9a08			 
9a08 21 04 e3			ld hl,scratch+2 
9a0b cd 53 90			call get_word_hl 
9a0e				;ld hl,(scratch+2) 
9a0e				;call fourehexhl 
9a0e			 
9a0e 22 25 e6			ld (os_cur_ptr),hl	 
9a11			 
9a11 e9				jp (hl) 
9a12			 
9a12			 
9a12			 
9a12			; TODO implement a basic monitor mode to start with 
9a12			 
9a12			 
9a12			 
9a12			 
9a12			 
9a12			 
9a12			 
9a12			 
9a12			 
9a12			; testing and demo code during development 
9a12			 
9a12			 
9a12 .. 00		str1: db "Enter some text...",0 
9a25 .. 00		clear: db "                    ",0 
9a3a			 
9a3a			demo: 
9a3a			 
9a3a			 
9a3a			 
9a3a			;	call update_display 
9a3a			 
9a3a				; init scratch input area for testing 
9a3a 21 02 e3			ld hl, scratch	 
9a3d 3e 00			ld a,0 
9a3f 77				ld (hl),a 
9a40			 
9a40			 
9a40 3e 28		            LD   A, display_row_2 
9a42			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a42 11 12 9a		            LD   DE, str1 
9a45 cd 82 8a			call str_at_display 
9a48			 
9a48			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a48			cloop:	 
9a48 3e 50		            LD   A, display_row_3 
9a4a			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a4a 11 25 9a		            LD   DE, clear 
9a4d			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9a4d cd 82 8a				call str_at_display 
9a50 3e 78			ld a, display_row_4 
9a52 11 82 9a			ld de, prompt 
9a55			 
9a55 cd 82 8a				call str_at_display 
9a58 cd 92 8a			call update_display 
9a5b			 
9a5b 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9a5d 16 0a			ld d, 10 
9a5f 21 02 e3			ld hl, scratch	 
9a62 cd c9 8c			call input_str 
9a65			 
9a65			;	call clear_display 
9a65			;'	call update_display 
9a65			 
9a65 3e 00		            LD   A, display_row_1 
9a67			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a67 11 25 9a		            LD   DE, clear 
9a6a cd 82 8a				call str_at_display 
9a6d			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a6d 3e 00		            LD   A, display_row_1 
9a6f			;            CALL fLCD_Pos       ;Position cursor to location in A 
9a6f 11 02 e3		            LD   DE, scratch 
9a72			;            CALL fLCD_Str       ;Display string pointed to by DE 
9a72 cd 82 8a				call str_at_display 
9a75 cd 92 8a			call update_display 
9a78			 
9a78 3e 00				ld a,0 
9a7a 21 02 e3			ld hl, scratch 
9a7d 77				ld (hl),a 
9a7e			 
9a7e 00				nop 
9a7f c3 48 9a			jp cloop 
9a82			 
9a82			 
9a82			 
9a82			; OS Prompt 
9a82			 
9a82 .. 00		prompt: db ">",0 
9a84 .. 00		endprg: db "?",0 
9a86			 
9a86			 
9a86			; handy next page prompt 
9a86			next_page_prompt: 
9a86 e5				push hl 
9a87 d5				push de 
9a88 f5				push af 
9a89 c5				push bc 
9a8a			 
9a8a 3e 9f			ld a,display_row_4 + display_cols - 1 
9a8c 11 84 9a		        ld de, endprg 
9a8f cd 82 8a			call str_at_display 
9a92 cd 92 8a			call update_display 
9a95 cd 91 da			call cin_wait 
9a98 c1				pop bc 
9a99 f1				pop af 
9a9a d1				pop de 
9a9b e1				pop hl 
9a9c			 
9a9c			 
9a9c c9				ret 
9a9d			 
9a9d			 
9a9d			; forth parser 
9a9d			 
9a9d			; My forth kernel 
9a9d			include "forth_kernel.asm" 
9a9d			; 
9a9d			; kernel to the forth OS 
9a9d			 
9a9d			DS_TYPE_STR: equ 1     ; string type 
9a9d			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9a9d			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9a9d			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9a9d			 
9a9d			FORTH_PARSEV1: equ 0 
9a9d			FORTH_PARSEV2: equ 0 
9a9d			FORTH_PARSEV3: equ 0 
9a9d			FORTH_PARSEV4: equ 0 
9a9d			FORTH_PARSEV5: equ 1 
9a9d			 
9a9d			;if FORTH_PARSEV5 
9a9d			;	FORTH_END_BUFFER: equ 0 
9a9d			;else 
9a9d			FORTH_END_BUFFER: equ 127 
9a9d			;endif 
9a9d			 
9a9d			FORTH_TRUE: equ 1 
9a9d			FORTH_FALSE: equ 0 
9a9d			 
9a9d			if FORTH_PARSEV4 
9a9d			include "forth_stackops.asm" 
9a9d			endif 
9a9d			 
9a9d			if FORTH_PARSEV5 
9a9d			include "forth_stackopsv5.asm" 
9a9d			 
9a9d			; Stack operations for v5 parser on wards 
9a9d			; * DATA stack 
9a9d			; * LOOP stack 
9a9d			; * RETURN stack 
9a9d			 
9a9d			 
9a9d			 
9a9d			FORTH_CHK_DSP_UNDER: macro 
9a9d				push hl 
9a9d				push de 
9a9d				ld hl,(cli_data_sp) 
9a9d				ld de, cli_data_stack 
9a9d				call cmp16 
9a9d				jp c, fault_dsp_under 
9a9d				pop de 
9a9d				pop hl 
9a9d				endm 
9a9d			 
9a9d			 
9a9d			FORTH_CHK_RSP_UNDER: macro 
9a9d				push hl 
9a9d				push de 
9a9d				ld hl,(cli_ret_sp) 
9a9d				ld de, cli_ret_stack 
9a9d				call cmp16 
9a9d				jp c, fault_rsp_under 
9a9d				pop de 
9a9d				pop hl 
9a9d				endm 
9a9d			 
9a9d			FORTH_CHK_LOOP_UNDER: macro 
9a9d				push hl 
9a9d				push de 
9a9d				ld hl,(cli_loop_sp) 
9a9d				ld de, cli_loop_stack 
9a9d				call cmp16 
9a9d				jp c, fault_loop_under 
9a9d				pop de 
9a9d				pop hl 
9a9d				endm 
9a9d			 
9a9d			FORTH_ERR_TOS_NOTSTR: macro 
9a9d				; TOSO might need more for checks when used 
9a9d				push af 
9a9d				ld a,(hl) 
9a9d				cp DS_TYPE_STR 
9a9d				jp nz, type_faultn   
9a9d				pop af 
9a9d				endm 
9a9d			 
9a9d			FORTH_ERR_TOS_NOTNUM: macro 
9a9d				push af 
9a9d				ld a,(hl) 
9a9d				cp DS_TYPE_INUM 
9a9d				jp nz, type_faultn   
9a9d				pop af 
9a9d				endm 
9a9d			 
9a9d			 
9a9d			; increase data stack pointer and save hl to it 
9a9d				 
9a9d			FORTH_DSP_NEXT: macro 
9a9d				call macro_forth_dsp_next 
9a9d				endm 
9a9d			 
9a9d			 
9a9d			macro_forth_dsp_next: 
9a9d				if DEBUG_FORTH_STACK_GUARD 
9a9d cd f5 d7				call check_stacks 
9aa0				endif 
9aa0 e5				push hl 
9aa1 d5				push de 
9aa2 eb				ex de,hl 
9aa3 2a 2f ea			ld hl,(cli_data_sp) 
9aa6 23				inc hl 
9aa7 23				inc hl 
9aa8			 
9aa8			; PARSEV5 
9aa8 23				inc hl 
9aa9 22 2f ea			ld (cli_data_sp),hl 
9aac 73				ld (hl), e 
9aad 23				inc hl 
9aae 72				ld (hl), d 
9aaf d1				pop de 
9ab0 e1				pop hl 
9ab1				if DEBUG_FORTH_STACK_GUARD 
9ab1 cd f5 d7				call check_stacks 
9ab4				endif 
9ab4 c9				ret 
9ab5			 
9ab5			 
9ab5			; increase ret stack pointer and save hl to it 
9ab5				 
9ab5			FORTH_RSP_NEXT: macro 
9ab5				call macro_forth_rsp_next 
9ab5				endm 
9ab5			 
9ab5			macro_forth_rsp_next: 
9ab5				if DEBUG_FORTH_STACK_GUARD 
9ab5 cd f5 d7				call check_stacks 
9ab8				endif 
9ab8 e5				push hl 
9ab9 d5				push de 
9aba eb				ex de,hl 
9abb 2a 33 ea			ld hl,(cli_ret_sp) 
9abe 23				inc hl 
9abf 23				inc hl 
9ac0 22 33 ea			ld (cli_ret_sp),hl 
9ac3 73				ld (hl), e 
9ac4 23				inc hl 
9ac5 72				ld (hl), d 
9ac6 d1				pop de 
9ac7 e1				pop hl 
9ac8				if DEBUG_FORTH_STACK_GUARD 
9ac8 cd f5 d7				call check_stacks 
9acb				endif 
9acb c9				ret 
9acc			 
9acc			; get current ret stack pointer and save to hl  
9acc				 
9acc			FORTH_RSP_TOS: macro 
9acc				call macro_forth_rsp_tos 
9acc				endm 
9acc			 
9acc			macro_forth_rsp_tos: 
9acc				;push de 
9acc 2a 33 ea			ld hl,(cli_ret_sp) 
9acf cd 07 9b			call loadhlptrtohl 
9ad2				;ld e, (hl) 
9ad2				;inc hl 
9ad2				;ld d, (hl) 
9ad2				;ex de, hl 
9ad2					if DEBUG_FORTH_WORDS 
9ad2			;			DMARK "RST" 
9ad2						CALLMONITOR 
9ad2 cd 9d 94			call break_point_state  
9ad5				endm  
# End of macro CALLMONITOR
9ad5					endif 
9ad5				;pop de 
9ad5 c9				ret 
9ad6			 
9ad6			; pop ret stack pointer 
9ad6				 
9ad6			FORTH_RSP_POP: macro 
9ad6				call macro_forth_rsp_pop 
9ad6				endm 
9ad6			 
9ad6			 
9ad6			macro_forth_rsp_pop: 
9ad6				if DEBUG_FORTH_STACK_GUARD 
9ad6			;		DMARK "RPP" 
9ad6 cd f5 d7				call check_stacks 
9ad9					FORTH_CHK_RSP_UNDER 
9ad9 e5				push hl 
9ada d5				push de 
9adb 2a 33 ea			ld hl,(cli_ret_sp) 
9ade 11 ed e9			ld de, cli_ret_stack 
9ae1 cd ba 8c			call cmp16 
9ae4 da 09 d9			jp c, fault_rsp_under 
9ae7 d1				pop de 
9ae8 e1				pop hl 
9ae9				endm 
# End of macro FORTH_CHK_RSP_UNDER
9ae9				endif 
9ae9 e5				push hl 
9aea 2a 33 ea			ld hl,(cli_ret_sp) 
9aed			 
9aed			 
9aed				if FORTH_ENABLE_FREE 
9aed			 
9aed					; get pointer 
9aed			 
9aed					push de 
9aed					push hl 
9aed			 
9aed					ld e, (hl) 
9aed					inc hl 
9aed					ld d, (hl) 
9aed			 
9aed					ex de, hl 
9aed					call free 
9aed			 
9aed					pop hl 
9aed					pop de 
9aed			 
9aed			 
9aed				endif 
9aed			 
9aed			 
9aed 2b				dec hl 
9aee 2b				dec hl 
9aef 22 33 ea			ld (cli_ret_sp), hl 
9af2				; do stack underflow checks 
9af2 e1				pop hl 
9af3				if DEBUG_FORTH_STACK_GUARD 
9af3 cd f5 d7				call check_stacks 
9af6					FORTH_CHK_RSP_UNDER 
9af6 e5				push hl 
9af7 d5				push de 
9af8 2a 33 ea			ld hl,(cli_ret_sp) 
9afb 11 ed e9			ld de, cli_ret_stack 
9afe cd ba 8c			call cmp16 
9b01 da 09 d9			jp c, fault_rsp_under 
9b04 d1				pop de 
9b05 e1				pop hl 
9b06				endm 
# End of macro FORTH_CHK_RSP_UNDER
9b06				endif 
9b06 c9				ret 
9b07			 
9b07			 
9b07			 
9b07			; routine to load word pointed to by hl into hl 
9b07			 
9b07			loadhlptrtohl: 
9b07			 
9b07 d5				push de 
9b08 5e				ld e, (hl) 
9b09 23				inc hl 
9b0a 56				ld d, (hl) 
9b0b eb				ex de, hl 
9b0c d1				pop de 
9b0d			 
9b0d c9				ret 
9b0e			 
9b0e			 
9b0e			 
9b0e			 
9b0e			 
9b0e			; push a number held in HL onto the data stack 
9b0e			; entry point for pushing a value when already in hl used in function above 
9b0e			 
9b0e			forth_push_numhl: 
9b0e			 
9b0e e5				push hl    ; save value to push 
9b0f			 
9b0f			if DEBUG_FORTH_PUSH 
9b0f				; see if disabled 
9b0f			 
9b0f			 
9b0f f5				push af 
9b10 3a f3 e2			ld a, (os_view_disable) 
9b13 fe 2a			cp '*' 
9b15 28 34			jr z, .pskip2 
9b17 e5				push hl 
9b18 e5			push hl 
9b19 cd 6f 8a			call clear_display 
9b1c e1			pop hl 
9b1d 7c				ld a,h 
9b1e 21 07 e6			ld hl, os_word_scratch 
9b21 cd 9d 8f			call hexout 
9b24 e1				pop hl 
9b25 7d				ld a,l 
9b26 21 09 e6			ld hl, os_word_scratch+2 
9b29 cd 9d 8f			call hexout 
9b2c			 
9b2c 21 0b e6			ld hl, os_word_scratch+4 
9b2f 3e 00			ld a,0 
9b31 77				ld (hl),a 
9b32 11 07 e6			ld de,os_word_scratch 
9b35 3e 28				ld a, display_row_2 
9b37 cd 82 8a				call str_at_display 
9b3a 11 8b c6			ld de, .push_num 
9b3d 3e 00			ld a, display_row_1 
9b3f			 
9b3f cd 82 8a				call str_at_display 
9b42			 
9b42			 
9b42 cd 92 8a			call update_display 
9b45 cd ec 89			call delay1s 
9b48 cd ec 89			call delay1s 
9b4b			.pskip2:  
9b4b			 
9b4b f1				pop af 
9b4c			endif	 
9b4c			 
9b4c			 
9b4c				FORTH_DSP_NEXT 
9b4c cd 9d 9a			call macro_forth_dsp_next 
9b4f				endm 
# End of macro FORTH_DSP_NEXT
9b4f			 
9b4f 2a 2f ea			ld hl, (cli_data_sp) 
9b52			 
9b52				; save item type 
9b52 3e 02			ld a,  DS_TYPE_INUM 
9b54 77				ld (hl), a 
9b55 23				inc hl 
9b56			 
9b56				; get word off stack 
9b56 d1				pop de 
9b57 7b				ld a,e 
9b58 77				ld (hl), a 
9b59 23				inc hl 
9b5a 7a				ld a,d 
9b5b 77				ld (hl), a 
9b5c			 
9b5c			if DEBUG_FORTH_PUSH 
9b5c 2b				dec hl 
9b5d 2b				dec hl 
9b5e 2b				dec hl 
9b5f						DMARK "PH5" 
9b5f f5				push af  
9b60 3a 74 9b			ld a, (.dmark)  
9b63 32 71 ee			ld (debug_mark),a  
9b66 3a 75 9b			ld a, (.dmark+1)  
9b69 32 72 ee			ld (debug_mark+1),a  
9b6c 3a 76 9b			ld a, (.dmark+2)  
9b6f 32 73 ee			ld (debug_mark+2),a  
9b72 18 03			jr .pastdmark  
9b74 ..			.dmark: db "PH5"  
9b77 f1			.pastdmark: pop af  
9b78			endm  
# End of macro DMARK
9b78				CALLMONITOR 
9b78 cd 9d 94			call break_point_state  
9b7b				endm  
# End of macro CALLMONITOR
9b7b			endif	 
9b7b			 
9b7b c9				ret 
9b7c			 
9b7c			 
9b7c			; Push a string to stack pointed to by hl 
9b7c			 
9b7c			forth_push_str: 
9b7c			 
9b7c			if DEBUG_FORTH_PUSH 
9b7c						DMARK "PSQ" 
9b7c f5				push af  
9b7d 3a 91 9b			ld a, (.dmark)  
9b80 32 71 ee			ld (debug_mark),a  
9b83 3a 92 9b			ld a, (.dmark+1)  
9b86 32 72 ee			ld (debug_mark+1),a  
9b89 3a 93 9b			ld a, (.dmark+2)  
9b8c 32 73 ee			ld (debug_mark+2),a  
9b8f 18 03			jr .pastdmark  
9b91 ..			.dmark: db "PSQ"  
9b94 f1			.pastdmark: pop af  
9b95			endm  
# End of macro DMARK
9b95				CALLMONITOR 
9b95 cd 9d 94			call break_point_state  
9b98				endm  
# End of macro CALLMONITOR
9b98			endif	 
9b98			    
9b98 e5				push hl 
9b99 e5				push hl 
9b9a			 
9b9a			;	ld a, 0   ; find end of string 
9b9a cd fa 90			call strlenz 
9b9d			if DEBUG_FORTH_PUSH 
9b9d						DMARK "PQ2" 
9b9d f5				push af  
9b9e 3a b2 9b			ld a, (.dmark)  
9ba1 32 71 ee			ld (debug_mark),a  
9ba4 3a b3 9b			ld a, (.dmark+1)  
9ba7 32 72 ee			ld (debug_mark+1),a  
9baa 3a b4 9b			ld a, (.dmark+2)  
9bad 32 73 ee			ld (debug_mark+2),a  
9bb0 18 03			jr .pastdmark  
9bb2 ..			.dmark: db "PQ2"  
9bb5 f1			.pastdmark: pop af  
9bb6			endm  
# End of macro DMARK
9bb6				CALLMONITOR 
9bb6 cd 9d 94			call break_point_state  
9bb9				endm  
# End of macro CALLMONITOR
9bb9			endif	 
9bb9 eb				ex de, hl 
9bba e1				pop hl   ; get ptr to start of string 
9bbb			if DEBUG_FORTH_PUSH 
9bbb						DMARK "PQ3" 
9bbb f5				push af  
9bbc 3a d0 9b			ld a, (.dmark)  
9bbf 32 71 ee			ld (debug_mark),a  
9bc2 3a d1 9b			ld a, (.dmark+1)  
9bc5 32 72 ee			ld (debug_mark+1),a  
9bc8 3a d2 9b			ld a, (.dmark+2)  
9bcb 32 73 ee			ld (debug_mark+2),a  
9bce 18 03			jr .pastdmark  
9bd0 ..			.dmark: db "PQ3"  
9bd3 f1			.pastdmark: pop af  
9bd4			endm  
# End of macro DMARK
9bd4				CALLMONITOR 
9bd4 cd 9d 94			call break_point_state  
9bd7				endm  
# End of macro CALLMONITOR
9bd7			endif	 
9bd7 19				add hl,de 
9bd8			if DEBUG_FORTH_PUSH 
9bd8						DMARK "PQE" 
9bd8 f5				push af  
9bd9 3a ed 9b			ld a, (.dmark)  
9bdc 32 71 ee			ld (debug_mark),a  
9bdf 3a ee 9b			ld a, (.dmark+1)  
9be2 32 72 ee			ld (debug_mark+1),a  
9be5 3a ef 9b			ld a, (.dmark+2)  
9be8 32 73 ee			ld (debug_mark+2),a  
9beb 18 03			jr .pastdmark  
9bed ..			.dmark: db "PQE"  
9bf0 f1			.pastdmark: pop af  
9bf1			endm  
# End of macro DMARK
9bf1				CALLMONITOR 
9bf1 cd 9d 94			call break_point_state  
9bf4				endm  
# End of macro CALLMONITOR
9bf4			endif	 
9bf4			 
9bf4 2b				dec hl    ; see if there is an optional trailing double quote 
9bf5 7e				ld a,(hl) 
9bf6 fe 22			cp '"' 
9bf8 20 03			jr nz, .strnoq 
9bfa 3e 00			ld a, 0      ; get rid of double quote 
9bfc 77				ld (hl), a 
9bfd 23			.strnoq: inc hl 
9bfe			 
9bfe 3e 00			ld a, 0 
9c00 77				ld (hl), a     ; add null term and get rid of trailing double quote 
9c01			 
9c01 13				inc de ; add one for the type string 
9c02 13				inc de ; add one for null term??? 
9c03			 
9c03				; tos is get string pointer again 
9c03				; de contains space to allocate 
9c03				 
9c03 d5				push de 
9c04			 
9c04 eb				ex de, hl 
9c05			 
9c05				;push af 
9c05			 
9c05			if DEBUG_FORTH_PUSH 
9c05						DMARK "PHm" 
9c05 f5				push af  
9c06 3a 1a 9c			ld a, (.dmark)  
9c09 32 71 ee			ld (debug_mark),a  
9c0c 3a 1b 9c			ld a, (.dmark+1)  
9c0f 32 72 ee			ld (debug_mark+1),a  
9c12 3a 1c 9c			ld a, (.dmark+2)  
9c15 32 73 ee			ld (debug_mark+2),a  
9c18 18 03			jr .pastdmark  
9c1a ..			.dmark: db "PHm"  
9c1d f1			.pastdmark: pop af  
9c1e			endm  
# End of macro DMARK
9c1e				CALLMONITOR 
9c1e cd 9d 94			call break_point_state  
9c21				endm  
# End of macro CALLMONITOR
9c21			endif	 
9c21 cd 63 91			call malloc	; on ret hl now contains allocated memory 
9c24				if DEBUG_FORTH_MALLOC_GUARD 
9c24 cc e3 c6				call z,malloc_error 
9c27				endif 
9c27			 
9c27				 
9c27 c1				pop bc    ; get length 
9c28 d1				pop de   ;  get string start    
9c29			 
9c29				; hl has destination from malloc 
9c29			 
9c29 eb				ex de, hl    ; prep for ldir 
9c2a			 
9c2a d5				push de   ; save malloc area for DSP later 
9c2b				;push hl   ; save malloc area for DSP later 
9c2b			 
9c2b			if DEBUG_FORTH_PUSH 
9c2b						DMARK "PHc" 
9c2b f5				push af  
9c2c 3a 40 9c			ld a, (.dmark)  
9c2f 32 71 ee			ld (debug_mark),a  
9c32 3a 41 9c			ld a, (.dmark+1)  
9c35 32 72 ee			ld (debug_mark+1),a  
9c38 3a 42 9c			ld a, (.dmark+2)  
9c3b 32 73 ee			ld (debug_mark+2),a  
9c3e 18 03			jr .pastdmark  
9c40 ..			.dmark: db "PHc"  
9c43 f1			.pastdmark: pop af  
9c44			endm  
# End of macro DMARK
9c44				CALLMONITOR 
9c44 cd 9d 94			call break_point_state  
9c47				endm  
# End of macro CALLMONITOR
9c47			endif	 
9c47			 
9c47			 
9c47 ed b0			ldir 
9c49			 
9c49			 
9c49				; push malloc to data stack     macro?????  
9c49			 
9c49				FORTH_DSP_NEXT 
9c49 cd 9d 9a			call macro_forth_dsp_next 
9c4c				endm 
# End of macro FORTH_DSP_NEXT
9c4c			 
9c4c				; save value and type 
9c4c			 
9c4c 2a 2f ea			ld hl, (cli_data_sp) 
9c4f			 
9c4f				; save item type 
9c4f 3e 01			ld a,  DS_TYPE_STR 
9c51 77				ld (hl), a 
9c52 23				inc hl 
9c53			 
9c53				; get malloc word off stack 
9c53 d1				pop de 
9c54 73				ld (hl), e 
9c55 23				inc hl 
9c56 72				ld (hl), d 
9c57			 
9c57			 
9c57			 
9c57			if DEBUG_FORTH_PUSH 
9c57 2a 2f ea			ld hl, (cli_data_sp) 
9c5a						DMARK "PHS" 
9c5a f5				push af  
9c5b 3a 6f 9c			ld a, (.dmark)  
9c5e 32 71 ee			ld (debug_mark),a  
9c61 3a 70 9c			ld a, (.dmark+1)  
9c64 32 72 ee			ld (debug_mark+1),a  
9c67 3a 71 9c			ld a, (.dmark+2)  
9c6a 32 73 ee			ld (debug_mark+2),a  
9c6d 18 03			jr .pastdmark  
9c6f ..			.dmark: db "PHS"  
9c72 f1			.pastdmark: pop af  
9c73			endm  
# End of macro DMARK
9c73				CALLMONITOR 
9c73 cd 9d 94			call break_point_state  
9c76				endm  
# End of macro CALLMONITOR
9c76			;	ex de,hl 
9c76			endif	 
9c76				; in case of spaces, skip the ptr past the copied string 
9c76				;pop af 
9c76				;ld (cli_origptr),hl 
9c76			 
9c76 c9				ret 
9c77			 
9c77			 
9c77			 
9c77			; TODO ascii push input onto stack given hl to start of input 
9c77			 
9c77			; identify type 
9c77			; if starts with a " then a string 
9c77			; otherwise it is a number 
9c77			;  
9c77			; if a string 
9c77			;     scan for ending " to get length of string to malloc for + 1 
9c77			;     malloc 
9c77			;     put pointer to string on stack first byte flags as string 
9c77			; 
9c77			; else a number 
9c77			;    look for number format identifier 
9c77			;    $xx hex 
9c77			;    %xxxxx bin 
9c77			;    xxxxx decimal 
9c77			;    convert number to 16bit word.  
9c77			;    malloc word + 1 with flag to identiy as num 
9c77			;    put pointer to number on stack 
9c77			;   
9c77			;  
9c77			  
9c77			forth_apush: 
9c77				; kernel push 
9c77			 
9c77			if DEBUG_FORTH_PUSH 
9c77						DMARK "PSH" 
9c77 f5				push af  
9c78 3a 8c 9c			ld a, (.dmark)  
9c7b 32 71 ee			ld (debug_mark),a  
9c7e 3a 8d 9c			ld a, (.dmark+1)  
9c81 32 72 ee			ld (debug_mark+1),a  
9c84 3a 8e 9c			ld a, (.dmark+2)  
9c87 32 73 ee			ld (debug_mark+2),a  
9c8a 18 03			jr .pastdmark  
9c8c ..			.dmark: db "PSH"  
9c8f f1			.pastdmark: pop af  
9c90			endm  
# End of macro DMARK
9c90				CALLMONITOR 
9c90 cd 9d 94			call break_point_state  
9c93				endm  
# End of macro CALLMONITOR
9c93			endif	 
9c93				; identify input type 
9c93			 
9c93 7e				ld a,(hl) 
9c94 fe 22			cp '"' 
9c96 28 0a			jr z, .fapstr 
9c98 fe 24			cp '$' 
9c9a ca c2 9c			jp z, .faphex 
9c9d fe 25			cp '%' 
9c9f ca aa 9c			jp z, .fapbin 
9ca2			;	cp 'b' 
9ca2			;	jp z, .fabin 
9ca2				; else decimal 
9ca2			 
9ca2				; TODO do decimal conversion 
9ca2				; decimal is stored as a 16bit word 
9ca2			 
9ca2				; by default everything is a string if type is not detected 
9ca2			.fapstr: ; 
9ca2 fe 22			cp '"' 
9ca4 20 01			jr nz, .strnoqu 
9ca6 23				inc hl 
9ca7			.strnoqu: 
9ca7 c3 7c 9b			jp forth_push_str 
9caa			 
9caa			 
9caa			 
9caa			.fapbin:    ; push a binary string.  
9caa 11 00 00			ld de, 0   ; hold a 16bit value 
9cad			 
9cad 23			.fapbinshift:	inc hl  
9cae 7e				ld a,(hl) 
9caf fe 00			cp 0     ; done scanning  
9cb1 28 0b			jr z, .fapbdone  	; got it in HL so push  
9cb3			 
9cb3				; left shift de 
9cb3 eb				ex de, hl	 
9cb4 29				add hl, hl 
9cb5			 
9cb5				; is 1 
9cb5 fe 31			cp '1' 
9cb7 20 02			jr nz, .binzero 
9cb9 cb 4d			bit 1, l 
9cbb			.binzero: 
9cbb eb				ex de, hl	 ; save current de 
9cbc 18 ef			jr .fapbinshift 
9cbe			 
9cbe			.fapbdone: 
9cbe eb				ex de, hl 
9cbf c3 0e 9b			jp forth_push_numhl 
9cc2			 
9cc2			 
9cc2			.faphex:   ; hex is always stored as a 16bit word 
9cc2				; skip number prefix 
9cc2 23				inc hl 
9cc3				; turn ascii into number 
9cc3 cd 53 90			call get_word_hl	; ret 16bit word in hl 
9cc6			 
9cc6 c3 0e 9b			jp forth_push_numhl 
9cc9			 
9cc9 00				 nop 
9cca			 
9cca			.fabin:   ; TODO bin conversion 
9cca			 
9cca			 
9cca c9				ret 
9ccb			 
9ccb			 
9ccb			; get either a string ptr or a 16bit word from the data stack 
9ccb			 
9ccb			FORTH_DSP: macro 
9ccb				call macro_forth_dsp 
9ccb				endm 
9ccb			 
9ccb			macro_forth_dsp: 
9ccb				; data stack pointer points to current word on tos 
9ccb			 
9ccb 2a 2f ea			ld hl,(cli_data_sp) 
9cce			 
9cce				if DEBUG_FORTH_PUSH 
9cce						DMARK "DSP" 
9cce f5				push af  
9ccf 3a e3 9c			ld a, (.dmark)  
9cd2 32 71 ee			ld (debug_mark),a  
9cd5 3a e4 9c			ld a, (.dmark+1)  
9cd8 32 72 ee			ld (debug_mark+1),a  
9cdb 3a e5 9c			ld a, (.dmark+2)  
9cde 32 73 ee			ld (debug_mark+2),a  
9ce1 18 03			jr .pastdmark  
9ce3 ..			.dmark: db "DSP"  
9ce6 f1			.pastdmark: pop af  
9ce7			endm  
# End of macro DMARK
9ce7			 
9ce7 cd 18 c7				call display_data_sp 
9cea				;call break_point_state 
9cea				;rst 030h 
9cea				CALLMONITOR 
9cea cd 9d 94			call break_point_state  
9ced				endm  
# End of macro CALLMONITOR
9ced				endif 
9ced			 
9ced c9				ret 
9cee			 
9cee			; return hl to start of value on stack 
9cee			 
9cee			FORTH_DSP_VALUE: macro 
9cee				call macro_forth_dsp_value 
9cee				endm 
9cee			 
9cee			macro_forth_dsp_value: 
9cee			 
9cee				FORTH_DSP 
9cee cd cb 9c			call macro_forth_dsp 
9cf1				endm 
# End of macro FORTH_DSP
9cf1			 
9cf1 d5				push de 
9cf2			 
9cf2 23				inc hl ; skip type 
9cf3			 
9cf3 5e				ld e, (hl) 
9cf4 23				inc hl 
9cf5 56				ld d, (hl) 
9cf6 eb				ex de,hl  
9cf7			 
9cf7 d1				pop de 
9cf8			 
9cf8 c9				ret 
9cf9			 
9cf9			; return hl to start of value to second item on stack 
9cf9			 
9cf9			FORTH_DSP_VALUEM1: macro 
9cf9				call macro_forth_dsp_value_m1 
9cf9				endm 
9cf9			 
9cf9			macro_forth_dsp_value_m1: 
9cf9			 
9cf9				FORTH_DSP 
9cf9 cd cb 9c			call macro_forth_dsp 
9cfc				endm 
# End of macro FORTH_DSP
9cfc			 
9cfc 2b				dec hl 
9cfd 2b				dec hl 
9cfe			;	dec hl 
9cfe			 
9cfe d5				push de 
9cff			 
9cff 5e				ld e, (hl) 
9d00 23				inc hl 
9d01 56				ld d, (hl) 
9d02 eb				ex de,hl  
9d03			 
9d03 d1				pop de 
9d04			 
9d04 c9				ret 
9d05			 
9d05				 
9d05			 
9d05			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9d05			 
9d05			FORTH_DSP_POP: macro 
9d05				call macro_forth_dsp_pop 
9d05				endm 
9d05			 
9d05			 
9d05			; get the tos data type 
9d05			 
9d05			FORTH_DSP_TYPE:   macro 
9d05			 
9d05				;FORTH_DSP_VALUE 
9d05				FORTH_DSP 
9d05				 
9d05				; hl points to value 
9d05				; check type 
9d05			 
9d05				ld a,(hl) 
9d05			 
9d05				endm 
9d05			 
9d05			; load the tos value into hl 
9d05			 
9d05			 
9d05			FORTH_DSP_VALUEHL:  macro 
9d05				call macro_dsp_valuehl 
9d05				endm 
9d05			 
9d05			 
9d05			 
9d05			macro_dsp_valuehl: 
9d05				FORTH_DSP_VALUE 
9d05 cd ee 9c			call macro_forth_dsp_value 
9d08				endm 
# End of macro FORTH_DSP_VALUE
9d08			 
9d08				;FORTH_ERR_TOS_NOTNUM 
9d08			 
9d08				;inc hl   ; skip type id 
9d08			 
9d08			;	push de 
9d08			; 
9d08			;	ld e, (hl) 
9d08			;	inc hl 
9d08			;	ld d, (hl) 
9d08			;	ex de,hl  
9d08			 
9d08			;	pop de 
9d08			 
9d08				if DEBUG_FORTH_PUSH 
9d08						DMARK "DVL" 
9d08 f5				push af  
9d09 3a 1d 9d			ld a, (.dmark)  
9d0c 32 71 ee			ld (debug_mark),a  
9d0f 3a 1e 9d			ld a, (.dmark+1)  
9d12 32 72 ee			ld (debug_mark+1),a  
9d15 3a 1f 9d			ld a, (.dmark+2)  
9d18 32 73 ee			ld (debug_mark+2),a  
9d1b 18 03			jr .pastdmark  
9d1d ..			.dmark: db "DVL"  
9d20 f1			.pastdmark: pop af  
9d21			endm  
# End of macro DMARK
9d21				CALLMONITOR 
9d21 cd 9d 94			call break_point_state  
9d24				endm  
# End of macro CALLMONITOR
9d24				endif 
9d24 c9				ret 
9d25			 
9d25			forth_apushstrhl:      
9d25				; push of string requires use of cli_origptr 
9d25				; bodge use 
9d25			 
9d25				; get current cli_origptr, save, update with temp pointer  
9d25 ed 5b 4b ea		ld de, (cli_origptr) 
9d29 22 4b ea			ld (cli_origptr), hl 
9d2c d5				push de 
9d2d cd 77 9c			call forth_apush 
9d30 d1				pop de 
9d31 ed 53 4b ea		ld (cli_origptr), de 
9d35 c9			        ret	 
9d36			 
9d36			 
9d36			; increase loop stack pointer and save hl to it 
9d36				 
9d36			FORTH_LOOP_NEXT: macro 
9d36				call macro_forth_loop_next 
9d36				;nop 
9d36				endm 
9d36			 
9d36			macro_forth_loop_next: 
9d36				if DEBUG_FORTH_STACK_GUARD 
9d36 cd f5 d7				call check_stacks 
9d39				endif 
9d39 e5				push hl 
9d3a d5				push de 
9d3b eb				ex de,hl 
9d3c 2a 31 ea			ld hl,(cli_loop_sp) 
9d3f 23				inc hl 
9d40 23				inc hl 
9d41					if DEBUG_FORTH_WORDS 
9d41						DMARK "LNX" 
9d41 f5				push af  
9d42 3a 56 9d			ld a, (.dmark)  
9d45 32 71 ee			ld (debug_mark),a  
9d48 3a 57 9d			ld a, (.dmark+1)  
9d4b 32 72 ee			ld (debug_mark+1),a  
9d4e 3a 58 9d			ld a, (.dmark+2)  
9d51 32 73 ee			ld (debug_mark+2),a  
9d54 18 03			jr .pastdmark  
9d56 ..			.dmark: db "LNX"  
9d59 f1			.pastdmark: pop af  
9d5a			endm  
# End of macro DMARK
9d5a						CALLMONITOR 
9d5a cd 9d 94			call break_point_state  
9d5d				endm  
# End of macro CALLMONITOR
9d5d					endif 
9d5d 22 31 ea			ld (cli_loop_sp),hl 
9d60 73				ld (hl), e 
9d61 23				inc hl 
9d62 72				ld (hl), d 
9d63 d1				pop de    ; been reversed so save a swap on restore 
9d64 e1				pop hl 
9d65				if DEBUG_FORTH_STACK_GUARD 
9d65 cd f5 d7				call check_stacks 
9d68				endif 
9d68 c9				ret 
9d69			 
9d69			; get current ret stack pointer and save to hl  
9d69				 
9d69			FORTH_LOOP_TOS: macro 
9d69				call macro_forth_loop_tos 
9d69				endm 
9d69			 
9d69			macro_forth_loop_tos: 
9d69 d5				push de 
9d6a 2a 31 ea			ld hl,(cli_loop_sp) 
9d6d 5e				ld e, (hl) 
9d6e 23				inc hl 
9d6f 56				ld d, (hl) 
9d70 eb				ex de, hl 
9d71 d1				pop de 
9d72 c9				ret 
9d73			 
9d73			; pop loop stack pointer 
9d73				 
9d73			FORTH_LOOP_POP: macro 
9d73				call macro_forth_loop_pop 
9d73				endm 
9d73			 
9d73			 
9d73			macro_forth_loop_pop: 
9d73				if DEBUG_FORTH_STACK_GUARD 
9d73					DMARK "LPP" 
9d73 f5				push af  
9d74 3a 88 9d			ld a, (.dmark)  
9d77 32 71 ee			ld (debug_mark),a  
9d7a 3a 89 9d			ld a, (.dmark+1)  
9d7d 32 72 ee			ld (debug_mark+1),a  
9d80 3a 8a 9d			ld a, (.dmark+2)  
9d83 32 73 ee			ld (debug_mark+2),a  
9d86 18 03			jr .pastdmark  
9d88 ..			.dmark: db "LPP"  
9d8b f1			.pastdmark: pop af  
9d8c			endm  
# End of macro DMARK
9d8c cd f5 d7				call check_stacks 
9d8f					FORTH_CHK_LOOP_UNDER 
9d8f e5				push hl 
9d90 d5				push de 
9d91 2a 31 ea			ld hl,(cli_loop_sp) 
9d94 11 6b e9			ld de, cli_loop_stack 
9d97 cd ba 8c			call cmp16 
9d9a da 0f d9			jp c, fault_loop_under 
9d9d d1				pop de 
9d9e e1				pop hl 
9d9f				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9d9f				endif 
9d9f e5				push hl 
9da0 2a 31 ea			ld hl,(cli_loop_sp) 
9da3 2b				dec hl 
9da4 2b				dec hl 
9da5 22 31 ea			ld (cli_loop_sp), hl 
9da8				; TODO do stack underflow checks 
9da8 e1				pop hl 
9da9				if DEBUG_FORTH_STACK_GUARD 
9da9 cd f5 d7				call check_stacks 
9dac					FORTH_CHK_LOOP_UNDER 
9dac e5				push hl 
9dad d5				push de 
9dae 2a 31 ea			ld hl,(cli_loop_sp) 
9db1 11 6b e9			ld de, cli_loop_stack 
9db4 cd ba 8c			call cmp16 
9db7 da 0f d9			jp c, fault_loop_under 
9dba d1				pop de 
9dbb e1				pop hl 
9dbc				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9dbc				endif 
9dbc c9				ret 
9dbd			 
9dbd			macro_forth_dsp_pop: 
9dbd			 
9dbd e5				push hl 
9dbe			 
9dbe				; release malloc data 
9dbe			 
9dbe				if DEBUG_FORTH_STACK_GUARD 
9dbe cd f5 d7				call check_stacks 
9dc1					FORTH_CHK_DSP_UNDER 
9dc1 e5				push hl 
9dc2 d5				push de 
9dc3 2a 2f ea			ld hl,(cli_data_sp) 
9dc6 11 69 e8			ld de, cli_data_stack 
9dc9 cd ba 8c			call cmp16 
9dcc da 03 d9			jp c, fault_dsp_under 
9dcf d1				pop de 
9dd0 e1				pop hl 
9dd1				endm 
# End of macro FORTH_CHK_DSP_UNDER
9dd1				endif 
9dd1				;ld hl,(cli_data_sp) 
9dd1			if DEBUG_FORTH_DOT 
9dd1				DMARK "DPP" 
9dd1				CALLMONITOR 
9dd1			endif	 
9dd1			 
9dd1			 
9dd1			if FORTH_ENABLE_DSPPOPFREE 
9dd1			 
9dd1				FORTH_DSP 
9dd1 cd cb 9c			call macro_forth_dsp 
9dd4				endm 
# End of macro FORTH_DSP
9dd4			 
9dd4 7e				ld a, (hl) 
9dd5 fe 01			cp DS_TYPE_STR 
9dd7 20 07			jr nz, .skippopfree 
9dd9			 
9dd9				FORTH_DSP_VALUEHL 
9dd9 cd 05 9d			call macro_dsp_valuehl 
9ddc				endm 
# End of macro FORTH_DSP_VALUEHL
9ddc 00				nop 
9ddd			if DEBUG_FORTH_DOT 
9ddd				DMARK "DPf" 
9ddd				CALLMONITOR 
9ddd			endif	 
9ddd cd 2d 92			call free 
9de0			.skippopfree: 
9de0				 
9de0			 
9de0			endif 
9de0			 
9de0			if DEBUG_FORTH_DOT_KEY 
9de0				DMARK "DP2" 
9de0				CALLMONITOR 
9de0			endif	 
9de0			 
9de0				; move pointer down 
9de0			 
9de0 2a 2f ea			ld hl,(cli_data_sp) 
9de3 2b				dec hl 
9de4 2b				dec hl 
9de5			; PARSEV5 
9de5 2b				dec hl 
9de6 22 2f ea			ld (cli_data_sp), hl 
9de9			 
9de9				if DEBUG_FORTH_STACK_GUARD 
9de9 cd f5 d7				call check_stacks 
9dec					FORTH_CHK_DSP_UNDER 
9dec e5				push hl 
9ded d5				push de 
9dee 2a 2f ea			ld hl,(cli_data_sp) 
9df1 11 69 e8			ld de, cli_data_stack 
9df4 cd ba 8c			call cmp16 
9df7 da 03 d9			jp c, fault_dsp_under 
9dfa d1				pop de 
9dfb e1				pop hl 
9dfc				endm 
# End of macro FORTH_CHK_DSP_UNDER
9dfc				endif 
9dfc			 
9dfc e1				pop hl 
9dfd			 
9dfd c9				ret 
9dfe			 
9dfe			getwordathl: 
9dfe				; hl points to an address 
9dfe				; load hl with the word at that address 
9dfe			 
9dfe d5				push de 
9dff			 
9dff 5e				ld e, (hl) 
9e00 23				inc hl 
9e01 56				ld d, (hl) 
9e02 eb				ex de, hl 
9e03			 
9e03 d1				pop de 
9e04 c9				ret 
9e05			 
9e05			 
9e05			 
9e05			 
9e05			 
9e05			; eof 
9e05			 
# End of file forth_stackopsv5.asm
9e05			endif 
9e05			 
9e05			user_word_eol:  
9e05				; hl contains the pointer to where to create a linked list item from the end 
9e05				; of the user dict to continue on at the system word dict 
9e05				 
9e05				; poke the stub of the word list linked list to repoint to rom words 
9e05			 
9e05				; stub format 
9e05				; db   word id 
9e05				; dw    link to next word 
9e05			        ; db char length of token 
9e05				; db string + 0 term 
9e05				; db exec code....  
9e05			 
9e05 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9e07 77				ld (hl), a		; word id 
9e08 23				inc hl 
9e09			 
9e09 11 d4 9f			ld de, sysdict 
9e0c 73				ld (hl), e		; next word link ie system dict 
9e0d 23				inc hl 
9e0e 72				ld (hl), d		; next word link ie system dict 
9e0f 23				inc hl	 
9e10			 
9e10			;	ld (hl), sysdict		; next word link ie system dict 
9e10			;	inc hl 
9e10			;	inc hl 
9e10			 
9e10			;	inc hl 
9e10			;	inc hl 
9e10			 
9e10 3e 02			ld a, 2			; word length is 0 
9e12 77				ld (hl), a	 
9e13 23				inc hl 
9e14			 
9e14 3e 7e			ld a, '~'			; word length is 0 
9e16 77				ld (hl), a	 
9e17 23				inc hl 
9e18 3e 00			ld a, 0			; save empty word 
9e1a 77				ld (hl), a 
9e1b			 
9e1b c9				ret 
9e1c			 
9e1c				 
9e1c			 
9e1c			forthexec_cleanup: 
9e1c				FORTH_RSP_POP 
9e1c cd d6 9a			call macro_forth_rsp_pop 
9e1f				endm 
# End of macro FORTH_RSP_POP
9e1f c9				ret 
9e20			 
9e20			forth_call_hl: 
9e20				; taking hl 
9e20 e5				push hl 
9e21 c9				ret 
9e22			 
9e22			; this is called to reset Forth system but keep existing uwords etc 
9e22			 
9e22			forth_warmstart: 
9e22				; setup stack over/under flow checks 
9e22				if DEBUG_FORTH_STACK_GUARD 
9e22 cd db d7				call chk_stk_init 
9e25				endif 
9e25			 
9e25				; init stack pointers  - * these stacks go upwards *  
9e25 21 ed e9			ld hl, cli_ret_stack 
9e28 22 33 ea			ld (cli_ret_sp), hl	 
9e2b				; set bottom of stack 
9e2b 3e 00			ld a,0 
9e2d 77				ld (hl),a 
9e2e 23				inc hl 
9e2f 77				ld (hl),a 
9e30			 
9e30 21 69 e8			ld hl, cli_data_stack 
9e33 22 2f ea			ld (cli_data_sp), hl	 
9e36				; set bottom of stack 
9e36 3e 00			ld a,0 
9e38 77				ld (hl),a 
9e39 23				inc hl 
9e3a 77				ld (hl),a 
9e3b			 
9e3b 21 6b e9			ld hl, cli_loop_stack 
9e3e 22 31 ea			ld (cli_loop_sp), hl	 
9e41				; set bottom of stack 
9e41 3e 00			ld a,0 
9e43 77				ld (hl),a 
9e44 23				inc hl 
9e45 77				ld (hl),a 
9e46			 
9e46				; init extent of current open file 
9e46			 
9e46 3e 00			ld a, 0 
9e48 32 76 ea			ld (store_openext), a 
9e4b			 
9e4b c9				ret 
9e4c			 
9e4c			 
9e4c			; Cold Start - this is called to setup the whole Forth system 
9e4c			 
9e4c			forth_init: 
9e4c			 
9e4c				; setup stack over/under flow checks 
9e4c			 
9e4c			;	if DEBUG_FORTH_STACK_GUARD 
9e4c			;		call chk_stk_init 
9e4c			;	endif 
9e4c			 
9e4c				; enable auto display updates (slow.....) 
9e4c			 
9e4c 3e 01			ld a, 1 
9e4e 32 49 ea			ld (cli_autodisplay), a 
9e51			 
9e51				; if storage is in use disable long reads for now 
9e51 3e 00			ld a, 0 
9e53 32 7f ea			ld (store_longread), a 
9e56			 
9e56			 
9e56				; show start up screen 
9e56			 
9e56 cd 6f 8a			call clear_display 
9e59			 
9e59 3e 00			ld a,0 
9e5b 32 6b ea			ld (f_cursor_ptr), a 
9e5e			 
9e5e				; set start of word list in start of ram - for use when creating user words 
9e5e			 
9e5e 21 a6 da			ld hl, baseram 
9e61 22 ff e5			ld (os_last_new_uword), hl 
9e64 cd 05 9e			call user_word_eol 
9e67				 
9e67			;		call display_data_sp 
9e67			;		call next_page_prompt 
9e67			 
9e67			 
9e67			 
9e67			 
9e67 c9				ret 
9e68			 
9e68 .. 00		.bootforth: db " Forth Kernel Init ",0 
9e7c			 
9e7c			; TODO push to stack 
9e7c			 
9e7c			;  
9e7c			 
9e7c			if FORTH_PARSEV2 
9e7c			 
9e7c			 
9e7c				include "forth_parserv2.asm" 
9e7c			 
9e7c			endif 
9e7c			 
9e7c			 
9e7c			; parse cli version 1 
9e7c			 
9e7c			if FORTH_PARSEV1 
9e7c			 
9e7c			 
9e7c			 
9e7c			      include "forth_parserv1.asm" 
9e7c			endif 
9e7c				 
9e7c			if FORTH_PARSEV3 
9e7c			 
9e7c			 
9e7c			 
9e7c			      include "forth_parserv3.asm" 
9e7c				include "forth_wordsv3.asm" 
9e7c			endif 
9e7c			 
9e7c			if FORTH_PARSEV4 
9e7c			 
9e7c			 
9e7c			 
9e7c			      include "forth_parserv4.asm" 
9e7c				include "forth_wordsv4.asm" 
9e7c			endif 
9e7c			 
9e7c			if FORTH_PARSEV5 
9e7c			 
9e7c			 
9e7c			 
9e7c			      include "forth_parserv5.asm" 
9e7c			 
9e7c			 
9e7c			; A better parser without using malloc and string copies all over the place.  
9e7c			; Exec in situ should be faster 
9e7c			 
9e7c			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9e7c			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9e7c			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9e7c			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9e7c			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9e7c			WORD_SYS_END: equ 0   ; Opcode for all user words 
9e7c			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9e7c			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9e7c			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9e7c			 
9e7c			; Core word preamble macro 
9e7c			 
9e7c			CWHEAD:   macro nxtword opcode lit len opflags 
9e7c				db WORD_SYS_CORE+opcode             
9e7c				; internal op code number 
9e7c				dw nxtword            
9e7c				; link to next dict word block 
9e7c				db len + 1 
9e7c				; literal length of dict word inc zero term 
9e7c				db lit,0              
9e7c				; literal dict word 
9e7c			        ; TODO db opflags        
9e7c				endm 
9e7c			 
9e7c			 
9e7c			NEXTW: macro  
9e7c				jp macro_next 
9e7c				endm 
9e7c			 
9e7c			macro_next: 
9e7c			if DEBUG_FORTH_PARSE_KEY 
9e7c				DMARK "NXT" 
9e7c				CALLMONITOR 
9e7c			endif	 
9e7c			;	inc hl  ; skip token null term  
9e7c ed 4b 4d ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9e80 ed 5b 4b ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9e84 2a 03 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9e87			if DEBUG_FORTH_PARSE_KEY 
9e87				DMARK "}AA" 
9e87				CALLMONITOR 
9e87			endif	 
9e87 c3 8a 9f			jp execnext 
9e8a				;jp exec1 
9e8a			       
9e8a			 
9e8a			 
9e8a			; Another go at the parser to compile  
9e8a			 
9e8a			 
9e8a			; TODO rework parser to change all of the string words to byte tokens 
9e8a			; TODO do a search for  
9e8a			 
9e8a			; TODO first run normal parser to zero term sections 
9e8a			; TODO for each word do a token look up to get the op code 
9e8a			; TODO need some means to flag to the exec that this is a byte code form    
9e8a			 
9e8a			 
9e8a			forthcompile: 
9e8a			 
9e8a			; 
9e8a			; line parse: 
9e8a			;       parse raw input buffer 
9e8a			;       tokenise the words 
9e8a			;       malloc new copy (for looping etc) 
9e8a			;       copy to malloc + current pc in line to start of string and add line term 
9e8a			;       save on new rsp 
9e8a			; 
9e8a			 
9e8a			; hl to point to the line to tokenise 
9e8a			 
9e8a			;	push hl 
9e8a 22 03 e6			ld (os_tok_ptr), hl  ; save ptr to string 
9e8d			 
9e8d			;	ld a,0		; string term on input 
9e8d			;	call strlent 
9e8d			 
9e8d			;	ld (os_tok_len), hl	 ; save string length 
9e8d			 
9e8d			;if DEBUG_FORTH_TOK 
9e8d			;	ex de,hl		 
9e8d			;endif 
9e8d			 
9e8d			;	pop hl 		; get back string pointer 
9e8d			 
9e8d			if DEBUG_FORTH_TOK 
9e8d						DMARK "TOc" 
9e8d				CALLMONITOR 
9e8d			endif 
9e8d 7e			.cptoken2:    ld a,(hl) 
9e8e 23				inc hl 
9e8f fe 7f			cp FORTH_END_BUFFER 
9e91 28 29			jr z, .cptokendone2 
9e93 fe 00			cp 0 
9e95 28 25			jr z, .cptokendone2 
9e97 fe 22			cp '"' 
9e99 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9e9b fe 20			cp ' ' 
9e9d 20 ee			jr nz,  .cptoken2 
9e9f			 
9e9f			; TODO consume comments held between ( and ) 
9e9f			 
9e9f				; we have a space so change to zero term for dict match later 
9e9f 2b				dec hl 
9ea0 3e 00			ld a,0 
9ea2 77				ld (hl), a 
9ea3 23				inc hl 
9ea4 18 e7			jr .cptoken2 
9ea6				 
9ea6			 
9ea6			.cptokenstr2: 
9ea6				; skip all white space until either eol (because forgot to term) or end double quote 
9ea6			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9ea6				;inc hl ; skip current double quote 
9ea6 7e				ld a,(hl) 
9ea7 23				inc hl 
9ea8 fe 22			cp '"' 
9eaa 28 e1			jr z, .cptoken2 
9eac fe 7f			cp FORTH_END_BUFFER 
9eae 28 0c			jr z, .cptokendone2 
9eb0 fe 00			cp 0 
9eb2 28 08			jr z, .cptokendone2 
9eb4 fe 20			cp ' ' 
9eb6 28 02			jr z, .cptmp2 
9eb8 18 ec			jr .cptokenstr2 
9eba			 
9eba			.cptmp2:	; we have a space so change to zero term for dict match later 
9eba				;dec hl 
9eba				;ld a,"-"	; TODO remove this when working 
9eba				;ld (hl), a 
9eba				;inc hl 
9eba 18 ea			jr .cptokenstr2 
9ebc			 
9ebc			.cptokendone2: 
9ebc				;inc hl 
9ebc 3e 7f			ld a, FORTH_END_BUFFER 
9ebe 77				ld (hl),a 
9ebf 23				inc hl 
9ec0 3e 21			ld a, '!' 
9ec2 77				ld (hl),a 
9ec3			 
9ec3 2a 03 e6			ld hl,(os_tok_ptr) 
9ec6			         
9ec6			if DEBUG_FORTH_TOK 
9ec6						DMARK "Tc1" 
9ec6				CALLMONITOR 
9ec6			endif 
9ec6			 
9ec6				; push exec string to top of return stack 
9ec6				FORTH_RSP_NEXT 
9ec6 cd b5 9a			call macro_forth_rsp_next 
9ec9				endm 
# End of macro FORTH_RSP_NEXT
9ec9 c9				ret 
9eca			 
9eca			; Another go at the parser need to simplify the process 
9eca			 
9eca			forthparse: 
9eca			 
9eca			; 
9eca			; line parse: 
9eca			;       parse raw input buffer 
9eca			;       tokenise the words 
9eca			;       malloc new copy (for looping etc) 
9eca			;       copy to malloc + current pc in line to start of string and add line term 
9eca			;       save on new rsp 
9eca			; 
9eca			 
9eca			; hl to point to the line to tokenise 
9eca			 
9eca			;	push hl 
9eca 22 03 e6			ld (os_tok_ptr), hl  ; save ptr to string 
9ecd			 
9ecd			;	ld a,0		; string term on input 
9ecd			;	call strlent 
9ecd			 
9ecd			;	ld (os_tok_len), hl	 ; save string length 
9ecd			 
9ecd			;if DEBUG_FORTH_TOK 
9ecd			;	ex de,hl		 
9ecd			;endif 
9ecd			 
9ecd			;	pop hl 		; get back string pointer 
9ecd			 
9ecd			if DEBUG_FORTH_TOK 
9ecd						DMARK "TOK" 
9ecd				CALLMONITOR 
9ecd			endif 
9ecd 7e			.ptoken2:    ld a,(hl) 
9ece 23				inc hl 
9ecf fe 7f			cp FORTH_END_BUFFER 
9ed1 28 29			jr z, .ptokendone2 
9ed3 fe 00			cp 0 
9ed5 28 25			jr z, .ptokendone2 
9ed7 fe 22			cp '"' 
9ed9 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9edb fe 20			cp ' ' 
9edd 20 ee			jr nz,  .ptoken2 
9edf			 
9edf			; TODO consume comments held between ( and ) 
9edf			 
9edf				; we have a space so change to zero term for dict match later 
9edf 2b				dec hl 
9ee0 3e 00			ld a,0 
9ee2 77				ld (hl), a 
9ee3 23				inc hl 
9ee4 18 e7			jr .ptoken2 
9ee6				 
9ee6			 
9ee6			.ptokenstr2: 
9ee6				; skip all white space until either eol (because forgot to term) or end double quote 
9ee6			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9ee6				;inc hl ; skip current double quote 
9ee6 7e				ld a,(hl) 
9ee7 23				inc hl 
9ee8 fe 22			cp '"' 
9eea 28 e1			jr z, .ptoken2 
9eec fe 7f			cp FORTH_END_BUFFER 
9eee 28 0c			jr z, .ptokendone2 
9ef0 fe 00			cp 0 
9ef2 28 08			jr z, .ptokendone2 
9ef4 fe 20			cp ' ' 
9ef6 28 02			jr z, .ptmp2 
9ef8 18 ec			jr .ptokenstr2 
9efa			 
9efa			.ptmp2:	; we have a space so change to zero term for dict match later 
9efa				;dec hl 
9efa				;ld a,"-"	; TODO remove this when working 
9efa				;ld (hl), a 
9efa				;inc hl 
9efa 18 ea			jr .ptokenstr2 
9efc			 
9efc			.ptokendone2: 
9efc				;inc hl 
9efc 3e 7f			ld a, FORTH_END_BUFFER 
9efe 77				ld (hl),a 
9eff 23				inc hl 
9f00 3e 21			ld a, '!' 
9f02 77				ld (hl),a 
9f03			 
9f03 2a 03 e6			ld hl,(os_tok_ptr) 
9f06			         
9f06			if DEBUG_FORTH_TOK 
9f06						DMARK "TK1" 
9f06				CALLMONITOR 
9f06			endif 
9f06			 
9f06				; push exec string to top of return stack 
9f06				FORTH_RSP_NEXT 
9f06 cd b5 9a			call macro_forth_rsp_next 
9f09				endm 
# End of macro FORTH_RSP_NEXT
9f09 c9				ret 
9f0a			 
9f0a			; 
9f0a			;	; malloc size + buffer pointer + if is loop flag 
9f0a			;	ld hl,(os_tok_len) 		 ; get string length 
9f0a			; 
9f0a			;	ld a,l 
9f0a			; 
9f0a			;	cp 0			; we dont want to use a null string 
9f0a			;	ret z 
9f0a			; 
9f0a			;;	add 3    ; prefix malloc with buffer for current word ptr 
9f0a			; 
9f0a			;	add 5     ; TODO when certain not over writing memory remove 
9f0a			; 
9f0a			;		 
9f0a			; 
9f0a			;if DEBUG_FORTH_TOK 
9f0a			;			DMARK "TKE" 
9f0a			;	CALLMONITOR 
9f0a			;endif 
9f0a			; 
9f0a			;	ld l,a 
9f0a			;	ld h,0 
9f0a			;;	push hl   ; save required space for the copy later 
9f0a			;	call malloc 
9f0a			;if DEBUG_FORTH_TOK 
9f0a			;			DMARK "TKM" 
9f0a			;	CALLMONITOR 
9f0a			;endif 
9f0a			;	if DEBUG_FORTH_MALLOC_GUARD 
9f0a			;		push af 
9f0a			;		call ishlzero 
9f0a			;;		ld a, l 
9f0a			;;		add h 
9f0a			;;		cp 0 
9f0a			;		pop af 
9f0a			;		 
9f0a			;		call z,malloc_error 
9f0a			;	endif 
9f0a			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9f0a			; 
9f0a			; 
9f0a			;if DEBUG_FORTH_TOK 
9f0a			;			DMARK "TKR" 
9f0a			;	CALLMONITOR 
9f0a			;endif 
9f0a			; 
9f0a			;	FORTH_RSP_NEXT 
9f0a			; 
9f0a			;	;inc hl	 ; go past current buffer pointer 
9f0a			;	;inc hl 
9f0a			;	;inc hl   ; and past if loop flag 
9f0a			;		; TODO Need to set flag  
9f0a			; 
9f0a			;	 
9f0a			;	 
9f0a			;	ex de,hl	; malloc is dest 
9f0a			;	ld hl, (os_tok_len) 
9f0a			;;	pop bc 
9f0a			;	ld c, l                
9f0a			;	ld b,0 
9f0a			;	ld hl, (os_tok_ptr) 
9f0a			; 
9f0a			;if DEBUG_FORTH_TOK 
9f0a			;			DMARK "TKT" 
9f0a			;	CALLMONITOR 
9f0a			;endif 
9f0a			; 
9f0a			;	; do str cpy 
9f0a			; 
9f0a			;	ldir      ; copy byte in hl to de 
9f0a			; 
9f0a			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9f0a			; 
9f0a			;if DEBUG_FORTH_TOK 
9f0a			; 
9f0a			;			DMARK "TKY" 
9f0a			;	CALLMONITOR 
9f0a			;endif 
9f0a			;	;ld a,0 
9f0a			;	;ld a,FORTH_END_BUFFER 
9f0a			;	ex de, hl 
9f0a			;	;dec hl			 ; go back over the space delim at the end of word 
9f0a			;	;ld (hl),a 
9f0a			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9f0a			;	ld a,FORTH_END_BUFFER 
9f0a			;	ld (hl),a 
9f0a			;	inc hl 
9f0a			;	ld a,FORTH_END_BUFFER 
9f0a			;	ld (hl),a 
9f0a			; 
9f0a			;	; init the malloc area data 
9f0a			;	; set pc for in current area 
9f0a			;	;ld hl, (os_tok_malloc) 
9f0a			;	;inc hl 
9f0a			;	;inc hl 
9f0a			;	;inc hl 
9f0a			;	;ex de,hl 
9f0a			;	;ld hl, (os_tok_malloc) 
9f0a			;	;ld (hl),e 
9f0a			;	;inc hl 
9f0a			;	;ld (hl),d 
9f0a			; 
9f0a			; 
9f0a			;	ld hl,(os_tok_malloc) 
9f0a			;if DEBUG_FORTH_PARSE_KEY 
9f0a			;			DMARK "TKU" 
9f0a			;	CALLMONITOR 
9f0a			;endif 
9f0a			; 
9f0a			;	ret 
9f0a			 
9f0a			forthexec: 
9f0a			 
9f0a			; line exec: 
9f0a			; forth parser 
9f0a			 
9f0a			; 
9f0a			;       get current exec line on rsp 
9f0a			 
9f0a				FORTH_RSP_TOS 
9f0a cd cc 9a			call macro_forth_rsp_tos 
9f0d				endm 
# End of macro FORTH_RSP_TOS
9f0d			 
9f0d			;       restore current pc - hl points to malloc of data 
9f0d			 
9f0d				;ld e, (hl) 
9f0d				;inc hl 
9f0d				;ld d, (hl) 
9f0d				;ex de,hl 
9f0d			 
9f0d			 
9f0d			exec1: 
9f0d 22 03 e6			ld (os_tok_ptr), hl 
9f10			 
9f10				; copy our PC to working vars  
9f10 22 4d ea			ld (cli_ptr), hl 
9f13 22 4b ea			ld (cli_origptr), hl 
9f16			 
9f16 7e				ld a,(hl) 
9f17 fe 7f			cp FORTH_END_BUFFER 
9f19 c8				ret z 
9f1a			 
9f1a				; skip any nulls 
9f1a			 
9f1a fe 00			cp 0 
9f1c 20 03			jr nz, .execword 
9f1e 23				inc hl 
9f1f 18 ec			jr exec1 
9f21			 
9f21			 
9f21			.execword: 
9f21			 
9f21			 
9f21			 
9f21			if DEBUG_FORTH_PARSE_KEY 
9f21						DMARK "KYQ" 
9f21				CALLMONITOR 
9f21			endif 
9f21			;       while at start of word: 
9f21			; get start of dict (in user area first) 
9f21			 
9f21 21 a6 da		ld hl, baseram 
9f24			;ld hl, sysdict 
9f24 22 4f ea		ld (cli_nextword),hl 
9f27			;           match word at pc 
9f27			;           exec word 
9f27			;           or push to dsp 
9f27			;           forward to next token 
9f27			;           if line term pop rsp and exit 
9f27			;        
9f27			 
9f27			if DEBUG_FORTH_PARSE_KEY 
9f27						DMARK "KYq" 
9f27				CALLMONITOR 
9f27			endif 
9f27			 
9f27			; 
9f27			; word comp 
9f27			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9f27			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9f27			;    move to start of word  
9f27			;    compare word to cli_token 
9f27			 
9f27			.execpnword:	; HL at start of a word in the dictionary to check 
9f27			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9f27			;	ld (cli_ptr), hl 
9f27			 
9f27 2a 4f ea			ld hl,(cli_nextword) 
9f2a			 
9f2a cd cd 9f			call forth_tok_next 
9f2d			; tok next start here 
9f2d			;	; TODO skip compiled symbol for now 
9f2d			;	inc hl 
9f2d			; 
9f2d			;	; save pointer to next word 
9f2d			; 
9f2d			;	; hl now points to the address of the next word pointer  
9f2d			;	ld e, (hl) 
9f2d			;	inc hl 
9f2d			;	ld d, (hl) 
9f2d			;	inc l 
9f2d			; 
9f2d			;	ex de,hl 
9f2d			;if DEBUG_FORTH_PARSE_NEXTWORD 
9f2d			;	push bc 
9f2d			;	ld bc, (cli_nextword) 
9f2d			;			DMARK "NXW" 
9f2d			;	CALLMONITOR 
9f2d			;	pop bc 
9f2d			;endif 
9f2d			; tok next end here 
9f2d 22 4f ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
9f30 eb				ex de, hl 
9f31			 
9f31			 
9f31				; save the pointer of the current token - 1 to check against 
9f31				 
9f31 22 53 ea			ld (cli_token), hl   
9f34				; TODO maybe remove below save if no debug 
9f34				; save token string ptr for any debug later 
9f34 23				inc hl  
9f35 22 55 ea			ld (cli_origtoken), hl 
9f38 2b				dec hl 
9f39				; save pointer to the start of the next dictionay word 
9f39 7e				ld a,(hl)   ; get string length 
9f3a 47				ld b,a 
9f3b			.execpnwordinc:  
9f3b 23				inc hl 
9f3c 10 fd			djnz .execpnwordinc 
9f3e 22 51 ea			ld (cli_execword), hl      ; save start of this words code 
9f41			 
9f41				; now check the word token against the string being parsed 
9f41			 
9f41 2a 53 ea			ld hl,(cli_token) 
9f44 23				inc hl     ; skip string length (use zero term instead to end) 
9f45 22 53 ea			ld (cli_token), hl 
9f48			 
9f48			if DEBUG_FORTH_PARSE_KEY 
9f48						DMARK "KY2" 
9f48			endif 
9f48			if DEBUG_FORTH_PARSE_EXEC 
9f48				; see if disabled 
9f48			 
9f48				ld a, (os_view_disable) 
9f48				cp '*' 
9f48				jr z, .skip 
9f48			 
9f48				push hl 
9f48				push hl 
9f48				call clear_display 
9f48				ld de, .compword 
9f48				ld a, display_row_1 
9f48				call str_at_display 
9f48				pop de 
9f48				ld a, display_row_2 
9f48				call str_at_display 
9f48				ld hl,(cli_ptr) 
9f48				ld a,(hl) 
9f48			        ld hl, os_word_scratch 
9f48				ld (hl),a 
9f48				ld a,0 
9f48				inc hl 
9f48				ld (hl),a 	 
9f48				ld de, os_word_scratch 
9f48				ld a, display_row_2+10 
9f48				call str_at_display 
9f48				call update_display 
9f48				ld a, 100 
9f48				call aDelayInMS 
9f48				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f48				call delay250ms 
9f48				endif 
9f48				pop hl 
9f48			.skip:  
9f48			endif	 
9f48			.execpnchar:    ; compare char between token and string to parse 
9f48			 
9f48			if DEBUG_FORTH_PARSE_KEY 
9f48						DMARK "Ky3" 
9f48			endif 
9f48			if DEBUG_FORTH_PARSE_EXEC 
9f48				; see if disabled 
9f48			 
9f48				ld a, (os_view_disable) 
9f48				cp '*' 
9f48				jr z, .skip2 
9f48			 
9f48			;	call clear_display 
9f48			ld hl,(cli_token) 
9f48			ld a,(hl) 
9f48			ld (os_word_scratch),a 
9f48				ld hl,(cli_ptr) 
9f48			ld a,(hl) 
9f48				ld (os_word_scratch+1),a 
9f48				ld a,0 
9f48				ld (os_word_scratch+2),a 
9f48				ld de,os_word_scratch 
9f48				ld a,display_row_4 
9f48				call str_at_display 
9f48				call update_display 
9f48			.skip2:  
9f48			endif 
9f48 2a 53 ea			ld hl,(cli_token) 
9f4b 7e				ld a, (hl)	 ; char in word token 
9f4c 23				inc hl 		; move to next char 
9f4d 22 53 ea			ld (cli_token), hl ; and save it 
9f50 47				ld b,a 
9f51			 
9f51 2a 4d ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
9f54 7e				ld a,(hl) 
9f55 23				inc hl 
9f56 22 4d ea			ld (cli_ptr), hl		; move to next char 
9f59 cd f1 90			call toUpper 		; make sure the input string matches case 
9f5c			 
9f5c			if DEBUG_FORTH_PARSE 
9f5c			endif 
9f5c			 
9f5c				; input stream end of token is a space so get rid of it 
9f5c			 
9f5c			;	cp ' ' 
9f5c			;	jr nz, .pnskipspace 
9f5c			; 
9f5c			;	ld a, 0		; make same term as word token term 
9f5c			; 
9f5c			;.pnskipspace: 
9f5c			 
9f5c			if DEBUG_FORTH_PARSE_KEY 
9f5c						DMARK "KY7" 
9f5c			endif 
9f5c b8				cp b 
9f5d c2 73 9f			jp nz, .execpnskipword	 ; no match so move to next word 
9f60				 
9f60			;    if same 
9f60			;       scan for string terms 0 for token and 32 for input 
9f60			 
9f60				 
9f60			if DEBUG_FORTH_PARSE_KEY 
9f60						DMARK "KY8" 
9f60			endif 
9f60			 
9f60 80				add b			 
9f61 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9f63							; TODO need to make sure last word in zero term string is accounted for 
9f63 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9f65			 
9f65			 
9f65				; at end of both strings so both are exact match 
9f65			 
9f65			;       skip ptr for next word 
9f65			 
9f65 2a 4d ea			ld hl,(cli_ptr) 	; at input string term 
9f68 23				inc hl			 ; at next char 
9f69 22 4d ea			ld (cli_ptr), hl     ; save for next round of the parser 
9f6c 22 4b ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9f6f				 
9f6f				 
9f6f			if DEBUG_FORTH_PARSE_KEY 
9f6f						DMARK "KY3" 
9f6f			endif 
9f6f			 
9f6f			 
9f6f			 
9f6f			;       exec code block 
9f6f			if DEBUG_FORTH_JP 
9f6f				call clear_display 
9f6f				call update_display 
9f6f				call delay1s 
9f6f				ld hl, (cli_execword)     ; save for next check if no match on this word 
9f6f				ld a,h 
9f6f				ld hl, os_word_scratch 
9f6f				call hexout 
9f6f				ld hl, (cli_execword)     ; save for next check if no match on this word 
9f6f				ld a,l 
9f6f				ld hl, os_word_scratch+2 
9f6f				call hexout 
9f6f				ld hl, os_word_scratch+4 
9f6f				ld a,0 
9f6f				ld (hl),a 
9f6f				ld de,os_word_scratch 
9f6f				call str_at_display 
9f6f					ld a, display_row_2 
9f6f					call str_at_display 
9f6f				ld de, (cli_origtoken) 
9f6f				ld a, display_row_1+10 
9f6f					call str_at_display 
9f6f			 
9f6f				ld a,display_row_1 
9f6f				ld de, .foundword 
9f6f				ld a, display_row_3 
9f6f				call str_at_display 
9f6f				call update_display 
9f6f				call delay1s 
9f6f				call delay1s 
9f6f				call delay1s 
9f6f			endif 
9f6f			 
9f6f			if DEBUG_FORTH_PARSE_KEY 
9f6f						DMARK "KYj" 
9f6f			endif 
9f6f				; TODO save the word pointer in this exec 
9f6f			 
9f6f 2a 51 ea			ld hl,(cli_execword) 
9f72 e9				jp (hl) 
9f73			 
9f73			 
9f73			;    if not same 
9f73			;	scan for zero term 
9f73			;	get ptr for next word 
9f73			;	goto word comp 
9f73			 
9f73			.execpnskipword:	; get pointer to next word 
9f73 2a 4f ea			ld hl,(cli_nextword) 
9f76			 
9f76 7e				ld a,(hl) 
9f77 fe 00			cp WORD_SYS_END 
9f79			;	cp 0 
9f79 28 09			jr z, .execendofdict			 ; at end of words 
9f7b			 
9f7b			if DEBUG_FORTH_PARSE_KEY 
9f7b						DMARK "KY4" 
9f7b			endif 
9f7b			if DEBUG_FORTH_PARSE_EXEC 
9f7b			 
9f7b				; see if disabled 
9f7b			 
9f7b				ld a, (os_view_disable) 
9f7b				cp '*' 
9f7b				jr z, .noskip 
9f7b			 
9f7b			 
9f7b				ld de, .nowordfound 
9f7b				ld a, display_row_3 
9f7b				call str_at_display 
9f7b				call update_display 
9f7b				ld a, 100 
9f7b				call aDelayInMS 
9f7b				 
9f7b				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f7b					call delay250ms 
9f7b				endif 
9f7b			.noskip:  
9f7b			 
9f7b			endif	 
9f7b			 
9f7b 2a 4b ea			ld hl,(cli_origptr) 
9f7e 22 4d ea			ld (cli_ptr),hl 
9f81			 
9f81			if DEBUG_FORTH_PARSE_KEY 
9f81						DMARK "KY5" 
9f81			endif 
9f81 c3 27 9f			jp .execpnword			; else go to next word 
9f84			 
9f84			.execendofdict:  
9f84			 
9f84			if DEBUG_FORTH_PARSE_KEY 
9f84						DMARK "KYe" 
9f84			endif 
9f84			if DEBUG_FORTH_PARSE_EXEC 
9f84				; see if disabled 
9f84			 
9f84				ld a, (os_view_disable) 
9f84				cp '*' 
9f84				jr z, .ispskip 
9f84			 
9f84				call clear_display 
9f84				call update_display 
9f84				call delay1s 
9f84				ld de, (cli_origptr) 
9f84				ld a, display_row_1 
9f84				call str_at_display 
9f84				 
9f84				ld de, .enddict 
9f84				ld a, display_row_3 
9f84				call str_at_display 
9f84				call update_display 
9f84				ld a, 100 
9f84				call aDelayInMS 
9f84				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9f84				call delay1s 
9f84				call delay1s 
9f84				call delay1s 
9f84				endif 
9f84			.ispskip:  
9f84				 
9f84			endif	 
9f84			 
9f84			 
9f84			 
9f84				; if the word is not a keyword then must be a literal so push it to stack 
9f84			 
9f84			; push token to stack to end of word 
9f84			 
9f84				STACKFRAME ON $1efe $2f9f 
9f84				if DEBUG_STACK_IMB 
9f84					if ON 
9f84						exx 
9f84						ld de, $1efe 
9f84						ld a, d 
9f84						ld hl, curframe 
9f84						call hexout 
9f84						ld a, e 
9f84						ld hl, curframe+2 
9f84						call hexout 
9f84						ld hl, $1efe 
9f84						push hl 
9f84						ld hl, $2f9f 
9f84						push hl 
9f84						exx 
9f84					endif 
9f84				endif 
9f84			endm 
# End of macro STACKFRAME
9f84			 
9f84 2a 03 e6		ld hl,(os_tok_ptr) 
9f87 cd 77 9c		call forth_apush 
9f8a			 
9f8a				STACKFRAMECHK ON $1efe $2f9f 
9f8a				if DEBUG_STACK_IMB 
9f8a					if ON 
9f8a						exx 
9f8a						ld hl, $2f9f 
9f8a						pop de   ; $2f9f 
9f8a						call cmp16 
9f8a						jr nz, .spnosame 
9f8a						ld hl, $1efe 
9f8a						pop de   ; $1efe 
9f8a						call cmp16 
9f8a						jr z, .spfrsame 
9f8a						.spnosame: call showsperror 
9f8a						.spfrsame: nop 
9f8a						exx 
9f8a					endif 
9f8a				endif 
9f8a			endm 
# End of macro STACKFRAMECHK
9f8a			 
9f8a			execnext: 
9f8a			 
9f8a			if DEBUG_FORTH_PARSE_KEY 
9f8a						DMARK "KY>" 
9f8a			endif 
9f8a			; move past token to next word 
9f8a			 
9f8a 2a 03 e6		ld hl, (os_tok_ptr) 
9f8d 3e 00		ld a, 0 
9f8f 01 ff 00		ld bc, 255     ; input buffer size 
9f92 ed b1		cpir 
9f94			 
9f94			if DEBUG_FORTH_PARSE_KEY 
9f94						DMARK "KY!" 
9f94				CALLMONITOR 
9f94			endif	 
9f94			; TODO this might place hl on the null, so will need to forward on??? 
9f94			;inc hl   ; see if this gets onto the next item 
9f94			 
9f94			 
9f94			; TODO pass a pointer to the buffer to push 
9f94			; TODO call function to push 
9f94			 
9f94			; look for end of input 
9f94			 
9f94			;inc hl 
9f94			;ld a,(hl) 
9f94			;cp FORTH_END_BUFFER 
9f94			;ret z 
9f94			 
9f94			 
9f94 c3 0d 9f		jp exec1 
9f97			 
9f97			 
9f97			 
9f97			 
9f97			 
9f97			 
9f97			 
9f97			 
9f97			 
9f97			findnexttok: 
9f97			 
9f97				; hl is pointer to move 
9f97				; de is the token to locate 
9f97			 
9f97					if DEBUG_FORTH 
9f97						DMARK "NTK" 
9f97						CALLMONITOR 
9f97					endif 
9f97 d5				push de 
9f98			 
9f98			.fnt1:	 
9f98				; find first char of token to locate 
9f98			 
9f98 1a				ld a, (de) 
9f99 4f				ld c,a 
9f9a 7e				ld a,(hl) 
9f9b cd f1 90			call toUpper 
9f9e					if DEBUG_FORTH 
9f9e						DMARK "NT1" 
9f9e						CALLMONITOR 
9f9e					endif 
9f9e b9				cp c 
9f9f			 
9f9f 28 03			jr z, .fnt2cmpmorefirst	 
9fa1			 
9fa1				; first char not found move to next char 
9fa1			 
9fa1 23				inc hl 
9fa2 18 f4			jr .fnt1 
9fa4			 
9fa4			.fnt2cmpmorefirst:	 
9fa4				; first char of token found.  
9fa4			 
9fa4 e5				push hl     ; save start of token just in case it is the right one 
9fa5 d9				exx 
9fa6 e1				pop hl        ; save it to hl' 
9fa7 d9				exx 
9fa8			 
9fa8			 
9fa8			.fnt2cmpmore:	 
9fa8				; compare the rest 
9fa8				 
9fa8 23				inc hl 
9fa9 13				inc de 
9faa				 
9faa 1a				ld a, (de) 
9fab 4f				ld c,a 
9fac 7e				ld a,(hl) 
9fad cd f1 90			call toUpper 
9fb0			 
9fb0					if DEBUG_FORTH 
9fb0						DMARK "NT2" 
9fb0						CALLMONITOR 
9fb0					endif 
9fb0				; c has the token to find char 
9fb0				; a has the mem to scan char 
9fb0			 
9fb0 b9				cp c 
9fb1 28 04			jr z,.fntmatch1 
9fb3			 
9fb3				; they are not the same 
9fb3			 
9fb3					if DEBUG_FORTH 
9fb3						DMARK "NT3" 
9fb3						CALLMONITOR 
9fb3					endif 
9fb3 d1				pop de	; reset de token to look for 
9fb4 d5				push de 
9fb5 18 e1			jr .fnt1 
9fb7				 
9fb7			.fntmatch1: 
9fb7			 
9fb7				; is the same char a null which means we might have a full hit? 
9fb7					if DEBUG_FORTH 
9fb7						DMARK "NT4" 
9fb7						CALLMONITOR 
9fb7					endif 
9fb7			 
9fb7 fe 00			cp 0 
9fb9 28 0b			jr z, .fntmatchyes 
9fbb			 
9fbb				; are we at the end of the token to find? 
9fbb			 
9fbb					if DEBUG_FORTH 
9fbb						DMARK "NT5" 
9fbb						CALLMONITOR 
9fbb					endif 
9fbb 3e 00			ld a, 0 
9fbd b9				cp c 
9fbe			 
9fbe c2 a8 9f			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9fc1			 
9fc1					if DEBUG_FORTH 
9fc1						DMARK "NT6" 
9fc1						CALLMONITOR 
9fc1					endif 
9fc1				; token to find is exhusted but no match to stream 
9fc1			 
9fc1				; restore tok pointer and continue on 
9fc1 d1				pop de 
9fc2 d5				push de 
9fc3 c3 98 9f			jp .fnt1 
9fc6			 
9fc6			 
9fc6			.fntmatchyes: 
9fc6			 
9fc6				; hl now contains the end of the found token 
9fc6			 
9fc6				; get rid of saved token pointer to find 
9fc6			 
9fc6 d1				pop de 
9fc7			 
9fc7					if DEBUG_FORTH 
9fc7						DMARK "NT9" 
9fc7						CALLMONITOR 
9fc7					endif 
9fc7			 
9fc7				; hl will be on the null term so forward on 
9fc7			 
9fc7				; get back the saved start of the token 
9fc7			 
9fc7 d9				exx 
9fc8 e5				push hl     ; save start of token just in case it is the right one 
9fc9 d9				exx 
9fca e1				pop hl        ; save it to hl 
9fcb			 
9fcb c9				ret 
9fcc			 
9fcc			 
9fcc			; LIST needs to find a specific token   
9fcc			; FORGET needs to find a spefici token 
9fcc			 
9fcc			; SAVE needs to find all tokens by flag 
9fcc			; WORDS just needs to scan through all  by flag 
9fcc			; UWORDS needs to scan through all by flag 
9fcc			 
9fcc			 
9fcc			; given hl as pointer to start of dict look up string 
9fcc			; return hl as pointer to start of word block 
9fcc			; or 0 if not found 
9fcc			 
9fcc			forth_find_tok: 
9fcc c9				ret 
9fcd			 
9fcd			; given hl as pointer to dict structure 
9fcd			; move to the next dict block structure 
9fcd			 
9fcd			forth_tok_next: 
9fcd				; hl now points to the address of the next word pointer  
9fcd				; TODO skip compiled symbol for now 
9fcd			;	push de 
9fcd 23				inc hl 
9fce 5e				ld e, (hl) 
9fcf 23				inc hl 
9fd0 56				ld d, (hl) 
9fd1 23				inc hl 
9fd2			 
9fd2 eb				ex de,hl 
9fd3			if DEBUG_FORTH_PARSE_NEXTWORD 
9fd3				push bc 
9fd3				ld bc, (cli_nextword) 
9fd3						DMARK "NXW" 
9fd3				CALLMONITOR 
9fd3				pop bc 
9fd3			endif 
9fd3			;	pop de	 
9fd3 c9				ret 
9fd4			 
9fd4			 
9fd4			 
9fd4			; eof 
# End of file forth_parserv5.asm
9fd4				include "forth_wordsv4.asm" 
9fd4			 
9fd4			; the core word dictionary v4 
9fd4			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9fd4			 
9fd4			; this is a linked list for each of the system words used 
9fd4			; user defined words will follow the same format but will be in ram 
9fd4			 
9fd4			 
9fd4			; 
9fd4			; 
9fd4			; define linked list: 
9fd4			; 
9fd4			; 1. compiled byte op code 
9fd4			; 2. len of text word 
9fd4			; 3. text word 
9fd4			; 4. ptr to next dictionary word 
9fd4			; 5. asm, calls etc for the word 
9fd4			; 
9fd4			;  if 1 == 0 then last word in dict  
9fd4			;   
9fd4			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9fd4			;  
9fd4			;  
9fd4			; create basic standard set of words 
9fd4			; 
9fd4			;  
9fd4			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9fd4			; 2DUP 2DROP 2SWAP  
9fd4			; @ C@ - get byte  
9fd4			; ! C! - store byte 
9fd4			; 0< true if less than zero 
9fd4			; 0= true if zero 
9fd4			; < >  
9fd4			; = true if same 
9fd4			; variables 
9fd4			 
9fd4			 
9fd4			; Hardware specific words I may need 
9fd4			; 
9fd4			; IN OUT  
9fd4			; calls to key util functions 
9fd4			; calls to hardward abstraction stuff 
9fd4			; easy control of frame buffers and lcd i/o 
9fd4			; keyboard  
9fd4			 
9fd4			 
9fd4			;DICT: macro 
9fd4			; op_code, len, word, next 
9fd4			;    word: 
9fd4			;    db op_code 
9fd4			;    ds word zero term 
9fd4			;    dw next 
9fd4			;    endm 
9fd4			 
9fd4			 
9fd4			 
9fd4			 
9fd4			; op code 1 is a flag for user define words which are to be handled differently 
9fd4			 
9fd4			 
9fd4			; 
9fd4			; 
9fd4			;    TODO on entry to a word this should be the expected environment 
9fd4			;    hl - tos value if number then held, if string this is the ptr 
9fd4			;    de -  
9fd4			 
9fd4			 
9fd4			; opcode ranges 
9fd4			; 0 - end of word dict 
9fd4			; 255 - user define words 
9fd4			 
9fd4			sysdict: 
9fd4			include "forth_opcodes.asm" 
9fd4			; op codes for forth keywords 
9fd4			; free to use code 0  
9fd4				OPCODE_HEAP: equ  1 
9fd4				OPCODE_EXEC: equ 2 
9fd4				OPCODE_DUP: equ 3 
9fd4				OPCODE_SWAP: equ 4 
9fd4				OPCODE_COLN: equ 5 
9fd4				OPCODE_SCOLN: equ 6 
9fd4				OPCODE_DROP: equ 7 
9fd4				OPCODE_DUP2: equ 8 
9fd4				OPCODE_DROP2: equ 9 
9fd4				OPCODE_SWAP2: equ 10 
9fd4				OPCODE_AT: equ 11 
9fd4				OPCODE_CAT: equ 12 
9fd4				OPCODE_BANG: equ 13 
9fd4				OPCODE_CBANG: equ 14 
9fd4				OPCODE_SCALL: equ 15 
9fd4				OPCODE_DEPTH: equ 16 
9fd4				OPCODE_OVER: equ 17 
9fd4				OPCODE_PAUSE: equ 18 
9fd4				OPCODE_PAUSES: equ 19 
9fd4				OPCODE_ROT: equ 20 
9fd4			;free to reuse	OPCODE_WORDS: equ 21 
9fd4			        OPCODE_NOT: equ 21 
9fd4				OPCODE_UWORDS: equ 22 
9fd4				OPCODE_BP: equ 23 
9fd4				OPCODE_MONITOR: equ 24  
9fd4				OPCODE_MALLOC: equ 25 
9fd4				OPCODE_FREE: equ 26 
9fd4				OPCODE_LIST: equ 27 
9fd4				OPCODE_FORGET: equ 28 
9fd4				OPCODE_NOP: equ 29 
9fd4				OPCODE_COMO: equ 30 
9fd4				OPCODE_COMC: equ 31 
9fd4			;free to reuse	OPCODE_ENDCORE: equ 32 
9fd4				OPCODE_AFTERSOUND: equ 33 
9fd4				OPCODE_GP2: equ 34 
9fd4				OPCODE_GP3: equ 35 
9fd4				OPCODE_GP4: equ 36 
9fd4				OPCODE_SIN: equ 37 
9fd4				OPCODE_SOUT: equ 38 
9fd4				OPCODE_SPIO: equ 39 
9fd4				OPCODE_SPICEH: equ 40 
9fd4				OPCODE_SPIOb: equ 41 
9fd4				OPCODE_SPII: equ 42 
9fd4				OPCODE_SESEL: equ 43 
9fd4				OPCODE_CARTDEV: equ 44 
9fd4			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9fd4				OPCODE_FB: equ 46 
9fd4				OPCODE_EMIT: equ 47 
9fd4				OPCODE_DOTH: equ 48 
9fd4				OPCODE_DOTF: equ 49 
9fd4				OPCODE_DOT: equ 50 
9fd4				OPCODE_CLS: equ 51 
9fd4				OPCODE_DRAW: equ 52 
9fd4				OPCODE_DUMP: equ 53 
9fd4				OPCODE_CDUMP: equ 54 
9fd4				OPCODE_DAT: equ 55 
9fd4				OPCODE_HOME: equ 56 
9fd4				OPCODE_SPACE: equ 57 
9fd4				OPCODE_SPACES: equ 58 
9fd4				OPCODE_SCROLL: equ 59 
9fd4				OPCODE_ATQ: equ 60 
9fd4				OPCODE_AUTODSP: equ 61 
9fd4				OPCODE_MENU: equ 62 
9fd4			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9fd4				OPCODE_THEN: equ 64 
9fd4				OPCODE_ELSE: equ 65 
9fd4				OPCODE_DO: equ 66 
9fd4				OPCODE_LOOP: equ 67 
9fd4				OPCODE_I: equ 68 
9fd4				OPCODE_DLOOP: equ 69  
9fd4				OPCODE_REPEAT: equ 70  
9fd4				OPCODE_UNTIL: equ 71 
9fd4				OPCODE_ENDFLOW: equ 72 
9fd4				OPCODE_WAITK: equ 73 
9fd4				OPCODE_ACCEPT: equ 74 
9fd4				OPCODE_EDIT: equ 75 
9fd4			;free to reuse	OPCODE_ENDKEY: equ 76 
9fd4				OPCODE_LZERO: equ 77 
9fd4				OPCODE_TZERO: equ 78 
9fd4				OPCODE_LESS: equ 79 
9fd4				OPCODE_GT: equ 80 
9fd4				OPCODE_EQUAL: equ 81  
9fd4			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9fd4				OPCODE_NEG: equ 83 
9fd4				OPCODE_DIV: equ 84 
9fd4				OPCODE_MUL: equ 85 
9fd4				OPCODE_MIN: equ 86 
9fd4				OPCODE_MAX: equ 87 
9fd4				OPCODE_RND16: equ 88 
9fd4				OPCODE_RND8: equ 89 
9fd4				OPCODE_RND: equ 90 
9fd4			;free to reuse	OPCODE_ENDMATHS: equ 91  
9fd4				OPCODE_BYNAME: equ 92 
9fd4				OPCODE_DIR: equ 93 
9fd4				OPCODE_SAVE: equ 94 
9fd4				OPCODE_LOAD: equ 95 
9fd4				OPCODE_BSAVE: equ 96 
9fd4				OPCODE_BLOAD: equ 97 
9fd4				OPCODE_SEO: equ 98  
9fd4				OPCODE_SEI: equ 99 
9fd4				OPCODE_SFREE: equ 100 
9fd4				OPCODE_SIZE: equ 101 
9fd4				OPCODE_CREATE: equ 102 
9fd4				OPCODE_APPEND: equ 103 
9fd4				OPCODE_SDEL: equ 104 
9fd4				OPCODE_OPEN: equ 105 
9fd4				OPCODE_READ: equ 106 
9fd4				OPCODE_EOF: equ 106 
9fd4				OPCODE_FORMAT: equ 107 
9fd4				OPCODE_LABEL: equ 108 
9fd4				OPCODE_LABELS: equ 109 
9fd4			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9fd4				OPCODE_UPPER: equ 111 
9fd4				OPCODE_LOWER: equ 112 
9fd4				OPCODE_SUBSTR: equ 113 
9fd4				OPCODE_LEFT: equ 114 
9fd4				OPCODE_RIGHT: equ 115 
9fd4				OPCODE_STR2NUM: equ 116 
9fd4				OPCODE_NUM2STR: equ 117 
9fd4				OPCODE_CONCAT: equ 118 
9fd4				OPCODE_FIND: equ 119 
9fd4				OPCODE_LEN: equ 120 
9fd4				OPCODE_CHAR: equ 121 
9fd4			; free to reuse	OPCODE_STRLEN: equ 122 
9fd4			; free to reuse	OPCODE_ENDSTR: equ 123 
9fd4				OPCODE_V0S: equ 124 
9fd4				OPCODE_V0Q: equ 125 
9fd4				OPCODE_V1S: equ 126 
9fd4				OPCODE_V1Q: equ 127 
9fd4				OPCODE_V2S: equ 128 
9fd4				OPCODE_V2Q: equ 129 
9fd4				OPCODE_V3S: equ 130 
9fd4				OPCODE_V3Q: equ 131 
9fd4			;free to reuse	OPCODE_END: equ 132 
9fd4				OPCODE_ZDUP: equ 133 
9fd4			 
9fd4			; eof 
# End of file forth_opcodes.asm
9fd4			 
9fd4			include "forth_words_core.asm" 
9fd4			 
9fd4			; | ## Core Words 
9fd4			 
9fd4			;if MALLOC_4 
9fd4			 
9fd4			.HEAP: 
9fd4				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9fd4 15				db WORD_SYS_CORE+OPCODE_HEAP             
9fd5 13 a0			dw .EXEC            
9fd7 05				db 4 + 1 
9fd8 .. 00			db "HEAP",0              
9fdd				endm 
# End of macro CWHEAD
9fdd			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9fdd			; | | u1 - Current number of bytes in the heap 
9fdd			; | | u2 - Remaining bytes left on the heap 
9fdd			; | |  
9fdd			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9fdd			 
9fdd			 
9fdd					if DEBUG_FORTH_WORDS_KEY 
9fdd						DMARK "HEP" 
9fdd f5				push af  
9fde 3a f2 9f			ld a, (.dmark)  
9fe1 32 71 ee			ld (debug_mark),a  
9fe4 3a f3 9f			ld a, (.dmark+1)  
9fe7 32 72 ee			ld (debug_mark+1),a  
9fea 3a f4 9f			ld a, (.dmark+2)  
9fed 32 73 ee			ld (debug_mark+2),a  
9ff0 18 03			jr .pastdmark  
9ff2 ..			.dmark: db "HEP"  
9ff5 f1			.pastdmark: pop af  
9ff6			endm  
# End of macro DMARK
9ff6						CALLMONITOR 
9ff6 cd 9d 94			call break_point_state  
9ff9				endm  
# End of macro CALLMONITOR
9ff9					endif 
9ff9 2a b0 da				ld hl, (free_list )      
9ffc 11 b5 da				ld de, heap_start 
9fff			 
9fff ed 52				sbc hl, de  
a001			 
a001 cd 0e 9b				call forth_push_numhl 
a004			 
a004			 
a004 ed 5b b0 da			ld de, (free_list )      
a008 21 e8 e2				ld hl, heap_end 
a00b			 
a00b ed 52				sbc hl, de 
a00d			 
a00d cd 0e 9b				call forth_push_numhl 
a010					 
a010			 
a010					 
a010			 
a010			 
a010			 
a010					NEXTW 
a010 c3 7c 9e			jp macro_next 
a013				endm 
# End of macro NEXTW
a013			;endif 
a013			 
a013			.EXEC: 
a013			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
a013			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
a013			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
a013			;; > > 
a013			;; > >   
a013			;	STACKFRAME OFF $5efe $5f9f 
a013			; 
a013			;		if DEBUG_FORTH_WORDS_KEY 
a013			;			DMARK "EXE" 
a013			;			CALLMONITOR 
a013			;		endif 
a013			; 
a013			;	FORTH_DSP_VALUEHL 
a013			; 
a013			;	FORTH_DSP_POP 
a013			; 
a013			;		if DEBUG_FORTH_WORDS 
a013			;			DMARK "EX1" 
a013			;			CALLMONITOR 
a013			;		endif 
a013			;;	ld e,(hl) 
a013			;;	inc hl 
a013			;;	ld d,(hl) 
a013			;;	ex de,hl 
a013			; 
a013			;;		if DEBUG_FORTH_WORDS 
a013			;;			DMARK "EX2" 
a013			;;			CALLMONITOR 
a013			;;		endif 
a013			;	push hl 
a013			; 
a013			;	;ld a, 0 
a013			;	;ld a, FORTH_END_BUFFER 
a013			;	call strlenz 
a013			;	inc hl   ; include zero term to copy 
a013			;	inc hl   ; include term 
a013			;	inc hl   ; include term 
a013			;	ld b,0 
a013			;	ld c,l 
a013			;	pop hl 
a013			;	ld de, execscratch 
a013			;		if DEBUG_FORTH_WORDS 
a013			;			DMARK "EX3" 
a013			;			CALLMONITOR 
a013			;		endif 
a013			;	ldir 
a013			; 
a013			; 
a013			;	ld hl, execscratch 
a013			; 
a013			;		if DEBUG_FORTH_WORDS 
a013			;			DMARK "EXe" 
a013			;			CALLMONITOR 
a013			;		endif 
a013			; 
a013			;	call forthparse 
a013			;	call forthexec 
a013			;;	call forthexec_cleanup 
a013			;;	call forthparse 
a013			;;	call forthexec 
a013			; 
a013			;	STACKFRAMECHK OFF $5efe $5f9f 
a013			; 
a013			;	; an immediate word so no need to process any more words 
a013			;	ret 
a013			;	NEXTW 
a013			 
a013			; dead code - old version  
a013			;	FORTH_RSP_NEXT 
a013			 
a013			;  
a013			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
a013			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
a013			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
a013			;	push hl 
a013			;	push de 
a013			;	push bc 
a013			; 
a013			; 
a013			;		if DEBUG_FORTH_WORDS_KEY 
a013			;			DMARK "EXR" 
a013			;			CALLMONITOR 
a013			;		endif 
a013			; 
a013			; 
a013			; 
a013			;	;v5 FORTH_DSP_VALUE 
a013			;	FORTH_DSP_VALUEHL 
a013			; 
a013			;	; TODO do string type checks 
a013			; 
a013			;;v5	inc hl   ; skip type 
a013			; 
a013			;	push hl  ; source code  
a013			;		if DEBUG_FORTH_WORDS 
a013			;			DMARK "EX1" 
a013			;			CALLMONITOR 
a013			;		endif 
a013			;	ld a, 0 
a013			;	call strlent 
a013			; 
a013			;	inc hl 
a013			;	inc hl 
a013			;	inc hl 
a013			;	inc hl 
a013			; 
a013			;	push hl    ; size 
a013			; 
a013			;		if DEBUG_FORTH_WORDS 
a013			;			DMARK "EX2" 
a013			;			CALLMONITOR 
a013			;		endif 
a013			;	call malloc 
a013			; 
a013			;	ex de, hl    ; de now contains malloc area 
a013			;	pop bc   	; get byte count 
a013			;	pop hl      ; get string to copy 
a013			; 
a013			;	push de     ; save malloc for free later 
a013			; 
a013			;		if DEBUG_FORTH_WORDS 
a013			;			DMARK "EX3" 
a013			;			CALLMONITOR 
a013			;		endif 
a013			;	ldir       ; duplicate string 
a013			; 
a013			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
a013			;	 
a013			;	; TODO fix the parse would be better than this...  
a013			;	ex de, hl 
a013			;	dec hl 
a013			;	ld a, 0 
a013			;	ld (hl), a 
a013			;	dec hl 
a013			;	ld a, ' ' 
a013			;	ld (hl), a 
a013			;	dec hl 
a013			;	ld (hl), a 
a013			; 
a013			;	dec hl 
a013			;	ld (hl), a 
a013			; 
a013			; 
a013			;	FORTH_DSP_POP  
a013			; 
a013			;	pop hl     
a013			;	push hl    ; save malloc area 
a013			; 
a013			;		if DEBUG_FORTH_WORDS 
a013			;			DMARK "EX4" 
a013			;			CALLMONITOR 
a013			;		endif 
a013			; 
a013			;	call forthparse 
a013			;	call forthexec 
a013			;	 
a013			;	pop hl 
a013			;	if DEBUG_FORTH_WORDS 
a013			;		DMARK "EX5" 
a013			;		CALLMONITOR 
a013			;	endif 
a013			; 
a013			;	if FORTH_ENABLE_FREE 
a013			;	call free 
a013			;	endif 
a013			; 
a013			;	if DEBUG_FORTH_WORDS 
a013			;		DMARK "EX6" 
a013			;		CALLMONITOR 
a013			;	endif 
a013			; 
a013			;	pop bc 
a013			;	pop de 
a013			;	pop hl 
a013			;;	FORTH_RSP_POP	  
a013			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
a013			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
a013			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
a013			; 
a013			;	if DEBUG_FORTH_WORDS 
a013			;		DMARK "EX7" 
a013			;		CALLMONITOR 
a013			;	endif 
a013			;	NEXTW 
a013			 
a013			;.STKEXEC: 
a013			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
a013			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
a013			; 
a013			; 
a013			;		if DEBUG_FORTH_WORDS_KEY 
a013			;			DMARK "STX" 
a013			;			CALLMONITOR 
a013			;		endif 
a013			; 
a013			;	FORTH_DSP_VALUEHL 
a013			; 
a013			;	ld (store_tmp1), hl    ; count 
a013			; 
a013			;	FORTH_DSP_POP 
a013			;.stkexec1: 
a013			;	ld hl, (store_tmp1)   ; count 
a013			;	ld a, 0 
a013			;	cp l 
a013			;	ret z 
a013			; 
a013			;	dec hl 
a013			;	ld (store_tmp1), hl    ; count 
a013			;	 
a013			;	FORTH_DSP_VALUEHL 
a013			;	push hl 
a013			;	 
a013			;		if DEBUG_FORTH_WORDS 
a013			;			DMARK "EXp" 
a013			;			CALLMONITOR 
a013			;		endif 
a013			;	FORTH_DSP_POP 
a013			; 
a013			;	call strlenz 
a013			;	inc hl   ; include zero term to copy 
a013			;	inc hl   ; include zero term to copy 
a013			;	inc hl   ; include zero term to copy 
a013			;	ld b,0 
a013			;	ld c,l 
a013			;	pop hl 
a013			;	ld de, execscratch 
a013			;		if DEBUG_FORTH_WORDS 
a013			;			DMARK "EX3" 
a013			;			CALLMONITOR 
a013			;		endif 
a013			;	ldir 
a013			; 
a013			; 
a013			;	ld hl, execscratch 
a013			; 
a013			;		if DEBUG_FORTH_WORDS 
a013			;			DMARK "EXP" 
a013			;			CALLMONITOR 
a013			;		endif 
a013			; 
a013			;	call forthparse 
a013			;	ld hl, execscratch 
a013			;		if DEBUG_FORTH_WORDS 
a013			;			DMARK "EXx" 
a013			;			CALLMONITOR 
a013			;		endif 
a013			;	call forthexec 
a013			; 
a013			;	jp .stkexec1 
a013			; 
a013			;	ret 
a013			 
a013			 
a013			.DUP: 
a013				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
a013 17				db WORD_SYS_CORE+OPCODE_DUP             
a014 89 a0			dw .ZDUP            
a016 04				db 3 + 1 
a017 .. 00			db "DUP",0              
a01b				endm 
# End of macro CWHEAD
a01b			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
a01b			 
a01b					if DEBUG_FORTH_WORDS_KEY 
a01b						DMARK "DUP" 
a01b f5				push af  
a01c 3a 30 a0			ld a, (.dmark)  
a01f 32 71 ee			ld (debug_mark),a  
a022 3a 31 a0			ld a, (.dmark+1)  
a025 32 72 ee			ld (debug_mark+1),a  
a028 3a 32 a0			ld a, (.dmark+2)  
a02b 32 73 ee			ld (debug_mark+2),a  
a02e 18 03			jr .pastdmark  
a030 ..			.dmark: db "DUP"  
a033 f1			.pastdmark: pop af  
a034			endm  
# End of macro DMARK
a034						CALLMONITOR 
a034 cd 9d 94			call break_point_state  
a037				endm  
# End of macro CALLMONITOR
a037					endif 
a037			 
a037					FORTH_DSP 
a037 cd cb 9c			call macro_forth_dsp 
a03a				endm 
# End of macro FORTH_DSP
a03a			 
a03a 7e					ld a, (HL) 
a03b fe 01				cp DS_TYPE_STR 
a03d 20 25				jr nz, .dupinum 
a03f			 
a03f					; push another string 
a03f			 
a03f					FORTH_DSP_VALUEHL     		 
a03f cd 05 9d			call macro_dsp_valuehl 
a042				endm 
# End of macro FORTH_DSP_VALUEHL
a042			 
a042				if DEBUG_FORTH_WORDS 
a042					DMARK "DUs" 
a042 f5				push af  
a043 3a 57 a0			ld a, (.dmark)  
a046 32 71 ee			ld (debug_mark),a  
a049 3a 58 a0			ld a, (.dmark+1)  
a04c 32 72 ee			ld (debug_mark+1),a  
a04f 3a 59 a0			ld a, (.dmark+2)  
a052 32 73 ee			ld (debug_mark+2),a  
a055 18 03			jr .pastdmark  
a057 ..			.dmark: db "DUs"  
a05a f1			.pastdmark: pop af  
a05b			endm  
# End of macro DMARK
a05b					CALLMONITOR 
a05b cd 9d 94			call break_point_state  
a05e				endm  
# End of macro CALLMONITOR
a05e				endif 
a05e cd 7c 9b				call forth_push_str 
a061			 
a061					NEXTW 
a061 c3 7c 9e			jp macro_next 
a064				endm 
# End of macro NEXTW
a064			 
a064			 
a064			.dupinum: 
a064					 
a064			 
a064			 
a064					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a064 cd 05 9d			call macro_dsp_valuehl 
a067				endm 
# End of macro FORTH_DSP_VALUEHL
a067			 
a067				; TODO add floating point number detection 
a067			 
a067				if DEBUG_FORTH_WORDS 
a067					DMARK "DUi" 
a067 f5				push af  
a068 3a 7c a0			ld a, (.dmark)  
a06b 32 71 ee			ld (debug_mark),a  
a06e 3a 7d a0			ld a, (.dmark+1)  
a071 32 72 ee			ld (debug_mark+1),a  
a074 3a 7e a0			ld a, (.dmark+2)  
a077 32 73 ee			ld (debug_mark+2),a  
a07a 18 03			jr .pastdmark  
a07c ..			.dmark: db "DUi"  
a07f f1			.pastdmark: pop af  
a080			endm  
# End of macro DMARK
a080					CALLMONITOR 
a080 cd 9d 94			call break_point_state  
a083				endm  
# End of macro CALLMONITOR
a083				endif 
a083			 
a083 cd 0e 9b				call forth_push_numhl 
a086					NEXTW 
a086 c3 7c 9e			jp macro_next 
a089				endm 
# End of macro NEXTW
a089			.ZDUP: 
a089				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
a089 99				db WORD_SYS_CORE+OPCODE_ZDUP             
a08a c1 a0			dw .SWAP            
a08c 05				db 4 + 1 
a08d .. 00			db "?DUP",0              
a092				endm 
# End of macro CWHEAD
a092			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
a092			 
a092					if DEBUG_FORTH_WORDS_KEY 
a092						DMARK "qDU" 
a092 f5				push af  
a093 3a a7 a0			ld a, (.dmark)  
a096 32 71 ee			ld (debug_mark),a  
a099 3a a8 a0			ld a, (.dmark+1)  
a09c 32 72 ee			ld (debug_mark+1),a  
a09f 3a a9 a0			ld a, (.dmark+2)  
a0a2 32 73 ee			ld (debug_mark+2),a  
a0a5 18 03			jr .pastdmark  
a0a7 ..			.dmark: db "qDU"  
a0aa f1			.pastdmark: pop af  
a0ab			endm  
# End of macro DMARK
a0ab						CALLMONITOR 
a0ab cd 9d 94			call break_point_state  
a0ae				endm  
# End of macro CALLMONITOR
a0ae					endif 
a0ae					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a0ae cd 05 9d			call macro_dsp_valuehl 
a0b1				endm 
# End of macro FORTH_DSP_VALUEHL
a0b1			 
a0b1 e5					push hl 
a0b2			 
a0b2					; is it a zero? 
a0b2			 
a0b2 3e 00				ld a, 0 
a0b4 84					add h 
a0b5 85					add l 
a0b6			 
a0b6 e1					pop hl 
a0b7			 
a0b7 fe 00				cp 0 
a0b9 28 03				jr z, .dup2orig 
a0bb			 
a0bb			 
a0bb cd 0e 9b				call forth_push_numhl 
a0be			 
a0be			 
a0be				; TODO add floating point number detection 
a0be			 
a0be			.dup2orig: 
a0be			 
a0be					NEXTW 
a0be c3 7c 9e			jp macro_next 
a0c1				endm 
# End of macro NEXTW
a0c1			.SWAP: 
a0c1				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
a0c1 18				db WORD_SYS_CORE+OPCODE_SWAP             
a0c2 00 a1			dw .COLN            
a0c4 05				db 4 + 1 
a0c5 .. 00			db "SWAP",0              
a0ca				endm 
# End of macro CWHEAD
a0ca			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
a0ca					if DEBUG_FORTH_WORDS_KEY 
a0ca						DMARK "SWP" 
a0ca f5				push af  
a0cb 3a df a0			ld a, (.dmark)  
a0ce 32 71 ee			ld (debug_mark),a  
a0d1 3a e0 a0			ld a, (.dmark+1)  
a0d4 32 72 ee			ld (debug_mark+1),a  
a0d7 3a e1 a0			ld a, (.dmark+2)  
a0da 32 73 ee			ld (debug_mark+2),a  
a0dd 18 03			jr .pastdmark  
a0df ..			.dmark: db "SWP"  
a0e2 f1			.pastdmark: pop af  
a0e3			endm  
# End of macro DMARK
a0e3						CALLMONITOR 
a0e3 cd 9d 94			call break_point_state  
a0e6				endm  
# End of macro CALLMONITOR
a0e6					endif 
a0e6			 
a0e6					FORTH_DSP_VALUEHL 
a0e6 cd 05 9d			call macro_dsp_valuehl 
a0e9				endm 
# End of macro FORTH_DSP_VALUEHL
a0e9 e5					push hl     ; w2 
a0ea			 
a0ea					FORTH_DSP_POP 
a0ea cd bd 9d			call macro_forth_dsp_pop 
a0ed				endm 
# End of macro FORTH_DSP_POP
a0ed			 
a0ed					FORTH_DSP_VALUEHL 
a0ed cd 05 9d			call macro_dsp_valuehl 
a0f0				endm 
# End of macro FORTH_DSP_VALUEHL
a0f0			 
a0f0					FORTH_DSP_POP 
a0f0 cd bd 9d			call macro_forth_dsp_pop 
a0f3				endm 
# End of macro FORTH_DSP_POP
a0f3			 
a0f3 d1					pop de     ; w2	, hl = w1 
a0f4			 
a0f4 eb					ex de, hl 
a0f5 d5					push de 
a0f6			 
a0f6 cd 0e 9b				call forth_push_numhl 
a0f9			 
a0f9 e1					pop hl 
a0fa			 
a0fa cd 0e 9b				call forth_push_numhl 
a0fd					 
a0fd			 
a0fd					NEXTW 
a0fd c3 7c 9e			jp macro_next 
a100				endm 
# End of macro NEXTW
a100			.COLN: 
a100				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
a100 19				db WORD_SYS_CORE+OPCODE_COLN             
a101 8c a2			dw .SCOLN            
a103 02				db 1 + 1 
a104 .. 00			db ":",0              
a106				endm 
# End of macro CWHEAD
a106			; | : ( -- )         Create new word | DONE 
a106			 
a106					if DEBUG_FORTH_WORDS_KEY 
a106						DMARK "CLN" 
a106 f5				push af  
a107 3a 1b a1			ld a, (.dmark)  
a10a 32 71 ee			ld (debug_mark),a  
a10d 3a 1c a1			ld a, (.dmark+1)  
a110 32 72 ee			ld (debug_mark+1),a  
a113 3a 1d a1			ld a, (.dmark+2)  
a116 32 73 ee			ld (debug_mark+2),a  
a119 18 03			jr .pastdmark  
a11b ..			.dmark: db "CLN"  
a11e f1			.pastdmark: pop af  
a11f			endm  
# End of macro DMARK
a11f						CALLMONITOR 
a11f cd 9d 94			call break_point_state  
a122				endm  
# End of macro CALLMONITOR
a122					endif 
a122				STACKFRAME OFF $8efe $989f 
a122				if DEBUG_STACK_IMB 
a122					if OFF 
a122						exx 
a122						ld de, $8efe 
a122						ld a, d 
a122						ld hl, curframe 
a122						call hexout 
a122						ld a, e 
a122						ld hl, curframe+2 
a122						call hexout 
a122						ld hl, $8efe 
a122						push hl 
a122						ld hl, $989f 
a122						push hl 
a122						exx 
a122					endif 
a122				endif 
a122			endm 
# End of macro STACKFRAME
a122				; get parser buffer length  of new word 
a122			 
a122				 
a122			 
a122					; move tok past this to start of name defintition 
a122					; TODO get word to define 
a122					; TODO Move past word token 
a122					; TODO get length of string up to the ';' 
a122			 
a122 2a 03 e6			ld hl, (os_tok_ptr) 
a125 23				inc hl 
a126 23				inc hl 
a127			 
a127 3e 3b			ld a, ';' 
a129 cd 05 91			call strlent 
a12c			 
a12c 7d				ld a,l 
a12d 32 fe e2			ld (os_new_parse_len), a 
a130			 
a130			 
a130			if DEBUG_FORTH_UWORD 
a130 ed 5b 03 e6		ld de, (os_tok_ptr) 
a134						DMARK ":01" 
a134 f5				push af  
a135 3a 49 a1			ld a, (.dmark)  
a138 32 71 ee			ld (debug_mark),a  
a13b 3a 4a a1			ld a, (.dmark+1)  
a13e 32 72 ee			ld (debug_mark+1),a  
a141 3a 4b a1			ld a, (.dmark+2)  
a144 32 73 ee			ld (debug_mark+2),a  
a147 18 03			jr .pastdmark  
a149 ..			.dmark: db ":01"  
a14c f1			.pastdmark: pop af  
a14d			endm  
# End of macro DMARK
a14d				CALLMONITOR 
a14d cd 9d 94			call break_point_state  
a150				endm  
# End of macro CALLMONITOR
a150			endif 
a150			 
a150			; 
a150			;  new word memory layout: 
a150			;  
a150			;    : adg 6666 ;  
a150			; 
a150			;    db   1     ; user defined word  
a150 23				inc hl    
a151			;    dw   sysdict 
a151 23				inc hl 
a152 23				inc hl 
a153			;    db <word len>+1 (for null) 
a153 23				inc hl 
a154			;    db .... <word> 
a154			; 
a154			 
a154 23				inc hl    ; some extras for the word preamble before the above 
a155 23				inc hl 
a156 23				inc hl 
a157 23				inc hl 
a158 23				inc hl 
a159 23				inc hl 
a15a 23				inc hl  
a15b 23				inc hl 
a15c 23				inc hl 
a15d 23				inc hl 
a15e 23				inc hl 
a15f 23				inc hl 
a160 23				inc hl 
a161 23				inc hl     ; TODO how many do we really need?     maybe only 6 
a162			;       exec word buffer 
a162			;	<ptr word>   
a162 23				inc hl 
a163 23				inc hl 
a164			;       <word list><null term> 7F final term 
a164			 
a164			 
a164			if DEBUG_FORTH_UWORD 
a164						DMARK ":02" 
a164 f5				push af  
a165 3a 79 a1			ld a, (.dmark)  
a168 32 71 ee			ld (debug_mark),a  
a16b 3a 7a a1			ld a, (.dmark+1)  
a16e 32 72 ee			ld (debug_mark+1),a  
a171 3a 7b a1			ld a, (.dmark+2)  
a174 32 73 ee			ld (debug_mark+2),a  
a177 18 03			jr .pastdmark  
a179 ..			.dmark: db ":02"  
a17c f1			.pastdmark: pop af  
a17d			endm  
# End of macro DMARK
a17d				CALLMONITOR 
a17d cd 9d 94			call break_point_state  
a180				endm  
# End of macro CALLMONITOR
a180			endif 
a180			 
a180				 
a180					; malloc the size 
a180			 
a180 cd 63 91				call malloc 
a183 22 00 e3				ld (os_new_malloc), hl     ; save malloc start 
a186			 
a186			;    db   1     ; user defined word  
a186 3e 01				ld a, WORD_SYS_UWORD  
a188 77					ld (hl), a 
a189				 
a189 23				inc hl    
a18a			;    dw   sysdict 
a18a 11 d4 9f			ld de, sysdict       ; continue on with the scan to the system dict 
a18d 73				ld (hl), e 
a18e 23				inc hl 
a18f 72				ld (hl), d 
a190 23				inc hl 
a191			 
a191			 
a191			;    Setup dict word 
a191			 
a191 23				inc hl 
a192 22 fa e2			ld (os_new_work_ptr), hl     ; save start of dict word  
a195			 
a195				; 1. get length of dict word 
a195			 
a195			 
a195 2a 03 e6			ld hl, (os_tok_ptr) 
a198 23				inc hl 
a199 23				inc hl    ; position to start of dict word 
a19a 3e 00			ld a, 0 
a19c cd 05 91			call strlent 
a19f			 
a19f			 
a19f 23				inc hl    ; to include null??? 
a1a0			 
a1a0				; write length of dict word 
a1a0			 
a1a0 ed 5b fa e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a1a4 1b				dec de 
a1a5 eb				ex de, hl 
a1a6 73				ld (hl), e 
a1a7 eb				ex de, hl 
a1a8			 
a1a8				 
a1a8			 
a1a8				; copy  
a1a8 4d				ld c, l 
a1a9 06 00			ld b, 0 
a1ab ed 5b fa e2		ld de, (os_new_work_ptr)   ; get dest for copy of word 
a1af 2a 03 e6			ld hl, (os_tok_ptr) 
a1b2 23				inc hl 
a1b3 23				inc hl    ; position to start of dict word 
a1b4				 
a1b4			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
a1b4				 
a1b4				; TODO need to convert word to upper case 
a1b4			 
a1b4			ucasetok:	 
a1b4 7e				ld a,(hl) 
a1b5 cd f1 90			call toUpper 
a1b8 77				ld (hl),a 
a1b9 ed a0			ldi 
a1bb f2 b4 a1		 	jp p, ucasetok 
a1be			 
a1be			 
a1be			 
a1be				; de now points to start of where the word body code should be placed 
a1be ed 53 fa e2		ld (os_new_work_ptr), de 
a1c2				; hl now points to the words to throw at forthexec which needs to be copied 
a1c2 22 f8 e2			ld (os_new_src_ptr), hl 
a1c5			 
a1c5				; TODO add 'call to forthexec' 
a1c5			 
a1c5			if DEBUG_FORTH_UWORD 
a1c5 c5				push bc 
a1c6 ed 4b 00 e3		ld bc, (os_new_malloc) 
a1ca						DMARK ":0x" 
a1ca f5				push af  
a1cb 3a df a1			ld a, (.dmark)  
a1ce 32 71 ee			ld (debug_mark),a  
a1d1 3a e0 a1			ld a, (.dmark+1)  
a1d4 32 72 ee			ld (debug_mark+1),a  
a1d7 3a e1 a1			ld a, (.dmark+2)  
a1da 32 73 ee			ld (debug_mark+2),a  
a1dd 18 03			jr .pastdmark  
a1df ..			.dmark: db ":0x"  
a1e2 f1			.pastdmark: pop af  
a1e3			endm  
# End of macro DMARK
a1e3				CALLMONITOR 
a1e3 cd 9d 94			call break_point_state  
a1e6				endm  
# End of macro CALLMONITOR
a1e6 c1				pop bc 
a1e7			endif 
a1e7			 
a1e7			 
a1e7				; create word preamble which should be: 
a1e7			 
a1e7			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
a1e7			 
a1e7				;    ld hl, <word code> 
a1e7				;    jp user_exec 
a1e7			        ;    <word code bytes> 
a1e7			 
a1e7			 
a1e7			;	inc de     ; TODO ??? or are we already past the word's null 
a1e7 eb				ex de, hl 
a1e8			 
a1e8 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
a1ea			 
a1ea 23				inc hl 
a1eb 22 f4 e2			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
a1ee 23				inc hl 
a1ef			 
a1ef 23				inc hl 
a1f0 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
a1f2			 
a1f2 01 11 c6			ld bc, user_exec 
a1f5 23				inc hl 
a1f6 71				ld (hl), c     ; poke address of user_exec 
a1f7 23				inc hl 
a1f8 70				ld (hl), b     
a1f9			 ; 
a1f9			;	inc hl 
a1f9			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a1f9			; 
a1f9			; 
a1f9			;	ld bc, macro_forth_rsp_next 
a1f9			;	inc hl 
a1f9			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
a1f9			;	inc hl 
a1f9			;	ld (hl), b     
a1f9			 ; 
a1f9			;	inc hl 
a1f9			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
a1f9			; 
a1f9			; 
a1f9			;	inc hl 
a1f9			;	ld bc, forthexec 
a1f9			;	ld (hl), c     ; poke address of forthexec 
a1f9			;	inc hl 
a1f9			;	ld (hl), b      
a1f9			; 
a1f9			;	inc hl 
a1f9			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
a1f9			; 
a1f9			;	ld bc, user_dict_next 
a1f9			;	inc hl 
a1f9			;	ld (hl), c     ; poke address of forthexec 
a1f9			;	inc hl 
a1f9			;	ld (hl), b      
a1f9			 
a1f9				; hl is now where we need to copy the word byte data to save this 
a1f9			 
a1f9 23				inc hl 
a1fa 22 f6 e2			ld (os_new_exec), hl 
a1fd				 
a1fd				; copy definition 
a1fd			 
a1fd eb				ex de, hl 
a1fe			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
a1fe			;	inc de    ; skip the PC for this parse 
a1fe 3a fe e2			ld a, (os_new_parse_len) 
a201 4f				ld c, a 
a202 06 00			ld b, 0 
a204 ed b0			ldir		 ; copy defintion 
a206			 
a206			 
a206				; poke the address of where the new word bytes live for forthexec 
a206			 
a206 2a f4 e2			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
a209			 
a209 ed 5b f6 e2		ld de, (os_new_exec)      
a20d				 
a20d 73				ld (hl), e 
a20e 23				inc hl 
a20f 72				ld (hl), d 
a210			 
a210					; TODO copy last user dict word next link to this word 
a210					; TODO update last user dict word to point to this word 
a210			; 
a210			; hl f923 de 812a ; bc 811a 
a210			 
a210			if DEBUG_FORTH_UWORD 
a210 c5				push bc 
a211 ed 4b 00 e3		ld bc, (os_new_malloc) 
a215						DMARK ":0A" 
a215 f5				push af  
a216 3a 2a a2			ld a, (.dmark)  
a219 32 71 ee			ld (debug_mark),a  
a21c 3a 2b a2			ld a, (.dmark+1)  
a21f 32 72 ee			ld (debug_mark+1),a  
a222 3a 2c a2			ld a, (.dmark+2)  
a225 32 73 ee			ld (debug_mark+2),a  
a228 18 03			jr .pastdmark  
a22a ..			.dmark: db ":0A"  
a22d f1			.pastdmark: pop af  
a22e			endm  
# End of macro DMARK
a22e				CALLMONITOR 
a22e cd 9d 94			call break_point_state  
a231				endm  
# End of macro CALLMONITOR
a231 c1				pop bc 
a232			endif 
a232			if DEBUG_FORTH_UWORD 
a232 c5				push bc 
a233 ed 4b 00 e3		ld bc, (os_new_malloc) 
a237 03				inc bc 
a238 03				inc bc 
a239 03				inc bc 
a23a 03				inc bc 
a23b 03				inc bc 
a23c 03				inc bc 
a23d 03				inc bc 
a23e 03				inc bc 
a23f			 
a23f						DMARK ":0B" 
a23f f5				push af  
a240 3a 54 a2			ld a, (.dmark)  
a243 32 71 ee			ld (debug_mark),a  
a246 3a 55 a2			ld a, (.dmark+1)  
a249 32 72 ee			ld (debug_mark+1),a  
a24c 3a 56 a2			ld a, (.dmark+2)  
a24f 32 73 ee			ld (debug_mark+2),a  
a252 18 03			jr .pastdmark  
a254 ..			.dmark: db ":0B"  
a257 f1			.pastdmark: pop af  
a258			endm  
# End of macro DMARK
a258				CALLMONITOR 
a258 cd 9d 94			call break_point_state  
a25b				endm  
# End of macro CALLMONITOR
a25b c1				pop bc 
a25c			endif 
a25c			 
a25c			; update word dict linked list for new word 
a25c			 
a25c			 
a25c 2a ff e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a25f 23			inc hl     ; move to next work linked list ptr 
a260			 
a260 ed 5b 00 e3	ld de, (os_new_malloc)		 ; new next word 
a264 73			ld (hl), e 
a265 23			inc hl 
a266 72			ld (hl), d 
a267			 
a267			if DEBUG_FORTH_UWORD 
a267 ed 4b ff e5		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a26b			endif 
a26b			 
a26b ed 53 ff e5	ld (os_last_new_uword), de      ; update last new uword ptr 
a26f			 
a26f			 
a26f			if DEBUG_FORTH_UWORD 
a26f						DMARK ":0+" 
a26f f5				push af  
a270 3a 84 a2			ld a, (.dmark)  
a273 32 71 ee			ld (debug_mark),a  
a276 3a 85 a2			ld a, (.dmark+1)  
a279 32 72 ee			ld (debug_mark+1),a  
a27c 3a 86 a2			ld a, (.dmark+2)  
a27f 32 73 ee			ld (debug_mark+2),a  
a282 18 03			jr .pastdmark  
a284 ..			.dmark: db ":0+"  
a287 f1			.pastdmark: pop af  
a288			endm  
# End of macro DMARK
a288				CALLMONITOR 
a288 cd 9d 94			call break_point_state  
a28b				endm  
# End of macro CALLMONITOR
a28b			endif 
a28b			 
a28b				STACKFRAMECHK OFF $8efe $989f 
a28b				if DEBUG_STACK_IMB 
a28b					if OFF 
a28b						exx 
a28b						ld hl, $989f 
a28b						pop de   ; $989f 
a28b						call cmp16 
a28b						jr nz, .spnosame 
a28b						ld hl, $8efe 
a28b						pop de   ; $8efe 
a28b						call cmp16 
a28b						jr z, .spfrsame 
a28b						.spnosame: call showsperror 
a28b						.spfrsame: nop 
a28b						exx 
a28b					endif 
a28b				endif 
a28b			endm 
# End of macro STACKFRAMECHK
a28b			 
a28b c9			ret    ; dont process any remaining parser tokens as they form new word 
a28c			 
a28c			 
a28c			 
a28c			 
a28c			;		NEXT 
a28c			.SCOLN: 
a28c			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a28c 06				db OPCODE_SCOLN 
a28d d8 a2			dw .DROP 
a28f 02				db 2 
a290 .. 00			db ";",0           
a292			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a292					if DEBUG_FORTH_WORDS_KEY 
a292						DMARK "SCN" 
a292 f5				push af  
a293 3a a7 a2			ld a, (.dmark)  
a296 32 71 ee			ld (debug_mark),a  
a299 3a a8 a2			ld a, (.dmark+1)  
a29c 32 72 ee			ld (debug_mark+1),a  
a29f 3a a9 a2			ld a, (.dmark+2)  
a2a2 32 73 ee			ld (debug_mark+2),a  
a2a5 18 03			jr .pastdmark  
a2a7 ..			.dmark: db "SCN"  
a2aa f1			.pastdmark: pop af  
a2ab			endm  
# End of macro DMARK
a2ab						CALLMONITOR 
a2ab cd 9d 94			call break_point_state  
a2ae				endm  
# End of macro CALLMONITOR
a2ae					endif 
a2ae					FORTH_RSP_TOS 
a2ae cd cc 9a			call macro_forth_rsp_tos 
a2b1				endm 
# End of macro FORTH_RSP_TOS
a2b1 e5					push hl 
a2b2					FORTH_RSP_POP 
a2b2 cd d6 9a			call macro_forth_rsp_pop 
a2b5				endm 
# End of macro FORTH_RSP_POP
a2b5 e1					pop hl 
a2b6			;		ex de,hl 
a2b6 22 03 e6				ld (os_tok_ptr),hl 
a2b9			 
a2b9			if DEBUG_FORTH_UWORD 
a2b9						DMARK "SCL" 
a2b9 f5				push af  
a2ba 3a ce a2			ld a, (.dmark)  
a2bd 32 71 ee			ld (debug_mark),a  
a2c0 3a cf a2			ld a, (.dmark+1)  
a2c3 32 72 ee			ld (debug_mark+1),a  
a2c6 3a d0 a2			ld a, (.dmark+2)  
a2c9 32 73 ee			ld (debug_mark+2),a  
a2cc 18 03			jr .pastdmark  
a2ce ..			.dmark: db "SCL"  
a2d1 f1			.pastdmark: pop af  
a2d2			endm  
# End of macro DMARK
a2d2				CALLMONITOR 
a2d2 cd 9d 94			call break_point_state  
a2d5				endm  
# End of macro CALLMONITOR
a2d5			endif 
a2d5					NEXTW 
a2d5 c3 7c 9e			jp macro_next 
a2d8				endm 
# End of macro NEXTW
a2d8			 
a2d8			.DROP: 
a2d8				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a2d8 1b				db WORD_SYS_CORE+OPCODE_DROP             
a2d9 03 a3			dw .DUP2            
a2db 05				db 4 + 1 
a2dc .. 00			db "DROP",0              
a2e1				endm 
# End of macro CWHEAD
a2e1			; | DROP ( w -- )   drop the TOS item   | DONE 
a2e1					if DEBUG_FORTH_WORDS_KEY 
a2e1						DMARK "DRP" 
a2e1 f5				push af  
a2e2 3a f6 a2			ld a, (.dmark)  
a2e5 32 71 ee			ld (debug_mark),a  
a2e8 3a f7 a2			ld a, (.dmark+1)  
a2eb 32 72 ee			ld (debug_mark+1),a  
a2ee 3a f8 a2			ld a, (.dmark+2)  
a2f1 32 73 ee			ld (debug_mark+2),a  
a2f4 18 03			jr .pastdmark  
a2f6 ..			.dmark: db "DRP"  
a2f9 f1			.pastdmark: pop af  
a2fa			endm  
# End of macro DMARK
a2fa						CALLMONITOR 
a2fa cd 9d 94			call break_point_state  
a2fd				endm  
# End of macro CALLMONITOR
a2fd					endif 
a2fd					FORTH_DSP_POP 
a2fd cd bd 9d			call macro_forth_dsp_pop 
a300				endm 
# End of macro FORTH_DSP_POP
a300					NEXTW 
a300 c3 7c 9e			jp macro_next 
a303				endm 
# End of macro NEXTW
a303			.DUP2: 
a303				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a303 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a304 48 a3			dw .DROP2            
a306 05				db 4 + 1 
a307 .. 00			db "2DUP",0              
a30c				endm 
# End of macro CWHEAD
a30c			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a30c					if DEBUG_FORTH_WORDS_KEY 
a30c						DMARK "2DU" 
a30c f5				push af  
a30d 3a 21 a3			ld a, (.dmark)  
a310 32 71 ee			ld (debug_mark),a  
a313 3a 22 a3			ld a, (.dmark+1)  
a316 32 72 ee			ld (debug_mark+1),a  
a319 3a 23 a3			ld a, (.dmark+2)  
a31c 32 73 ee			ld (debug_mark+2),a  
a31f 18 03			jr .pastdmark  
a321 ..			.dmark: db "2DU"  
a324 f1			.pastdmark: pop af  
a325			endm  
# End of macro DMARK
a325						CALLMONITOR 
a325 cd 9d 94			call break_point_state  
a328				endm  
# End of macro CALLMONITOR
a328					endif 
a328					FORTH_DSP_VALUEHL 
a328 cd 05 9d			call macro_dsp_valuehl 
a32b				endm 
# End of macro FORTH_DSP_VALUEHL
a32b e5					push hl      ; 2 
a32c			 
a32c					FORTH_DSP_POP 
a32c cd bd 9d			call macro_forth_dsp_pop 
a32f				endm 
# End of macro FORTH_DSP_POP
a32f					 
a32f					FORTH_DSP_VALUEHL 
a32f cd 05 9d			call macro_dsp_valuehl 
a332				endm 
# End of macro FORTH_DSP_VALUEHL
a332			;		push hl      ; 1 
a332			 
a332					FORTH_DSP_POP 
a332 cd bd 9d			call macro_forth_dsp_pop 
a335				endm 
# End of macro FORTH_DSP_POP
a335			 
a335			;		pop hl       ; 1 
a335 d1					pop de       ; 2 
a336			 
a336 cd 0e 9b				call forth_push_numhl 
a339 eb					ex de, hl 
a33a cd 0e 9b				call forth_push_numhl 
a33d			 
a33d					 
a33d eb					ex de, hl 
a33e			 
a33e cd 0e 9b				call forth_push_numhl 
a341 eb					ex de, hl 
a342 cd 0e 9b				call forth_push_numhl 
a345			 
a345			 
a345					NEXTW 
a345 c3 7c 9e			jp macro_next 
a348				endm 
# End of macro NEXTW
a348			.DROP2: 
a348				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a348 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a349 77 a3			dw .SWAP2            
a34b 06				db 5 + 1 
a34c .. 00			db "2DROP",0              
a352				endm 
# End of macro CWHEAD
a352			; | 2DROP ( w w -- )    Double drop | DONE 
a352					if DEBUG_FORTH_WORDS_KEY 
a352						DMARK "2DR" 
a352 f5				push af  
a353 3a 67 a3			ld a, (.dmark)  
a356 32 71 ee			ld (debug_mark),a  
a359 3a 68 a3			ld a, (.dmark+1)  
a35c 32 72 ee			ld (debug_mark+1),a  
a35f 3a 69 a3			ld a, (.dmark+2)  
a362 32 73 ee			ld (debug_mark+2),a  
a365 18 03			jr .pastdmark  
a367 ..			.dmark: db "2DR"  
a36a f1			.pastdmark: pop af  
a36b			endm  
# End of macro DMARK
a36b						CALLMONITOR 
a36b cd 9d 94			call break_point_state  
a36e				endm  
# End of macro CALLMONITOR
a36e					endif 
a36e					FORTH_DSP_POP 
a36e cd bd 9d			call macro_forth_dsp_pop 
a371				endm 
# End of macro FORTH_DSP_POP
a371					FORTH_DSP_POP 
a371 cd bd 9d			call macro_forth_dsp_pop 
a374				endm 
# End of macro FORTH_DSP_POP
a374					NEXTW 
a374 c3 7c 9e			jp macro_next 
a377				endm 
# End of macro NEXTW
a377			.SWAP2: 
a377				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a377 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a378 a0 a3			dw .AT            
a37a 06				db 5 + 1 
a37b .. 00			db "2SWAP",0              
a381				endm 
# End of macro CWHEAD
a381			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a381					if DEBUG_FORTH_WORDS_KEY 
a381						DMARK "2SW" 
a381 f5				push af  
a382 3a 96 a3			ld a, (.dmark)  
a385 32 71 ee			ld (debug_mark),a  
a388 3a 97 a3			ld a, (.dmark+1)  
a38b 32 72 ee			ld (debug_mark+1),a  
a38e 3a 98 a3			ld a, (.dmark+2)  
a391 32 73 ee			ld (debug_mark+2),a  
a394 18 03			jr .pastdmark  
a396 ..			.dmark: db "2SW"  
a399 f1			.pastdmark: pop af  
a39a			endm  
# End of macro DMARK
a39a						CALLMONITOR 
a39a cd 9d 94			call break_point_state  
a39d				endm  
# End of macro CALLMONITOR
a39d					endif 
a39d					NEXTW 
a39d c3 7c 9e			jp macro_next 
a3a0				endm 
# End of macro NEXTW
a3a0			.AT: 
a3a0				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a3a0 1f				db WORD_SYS_CORE+OPCODE_AT             
a3a1 d2 a3			dw .CAT            
a3a3 02				db 1 + 1 
a3a4 .. 00			db "@",0              
a3a6				endm 
# End of macro CWHEAD
a3a6			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a3a6			 
a3a6					if DEBUG_FORTH_WORDS_KEY 
a3a6						DMARK "AT." 
a3a6 f5				push af  
a3a7 3a bb a3			ld a, (.dmark)  
a3aa 32 71 ee			ld (debug_mark),a  
a3ad 3a bc a3			ld a, (.dmark+1)  
a3b0 32 72 ee			ld (debug_mark+1),a  
a3b3 3a bd a3			ld a, (.dmark+2)  
a3b6 32 73 ee			ld (debug_mark+2),a  
a3b9 18 03			jr .pastdmark  
a3bb ..			.dmark: db "AT."  
a3be f1			.pastdmark: pop af  
a3bf			endm  
# End of macro DMARK
a3bf						CALLMONITOR 
a3bf cd 9d 94			call break_point_state  
a3c2				endm  
# End of macro CALLMONITOR
a3c2					endif 
a3c2			.getbyteat:	 
a3c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a3c2 cd 05 9d			call macro_dsp_valuehl 
a3c5				endm 
# End of macro FORTH_DSP_VALUEHL
a3c5					 
a3c5			;		push hl 
a3c5				 
a3c5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a3c5 cd bd 9d			call macro_forth_dsp_pop 
a3c8				endm 
# End of macro FORTH_DSP_POP
a3c8			 
a3c8			;		pop hl 
a3c8			 
a3c8 7e					ld a, (hl) 
a3c9			 
a3c9 6f					ld l, a 
a3ca 26 00				ld h, 0 
a3cc cd 0e 9b				call forth_push_numhl 
a3cf			 
a3cf					NEXTW 
a3cf c3 7c 9e			jp macro_next 
a3d2				endm 
# End of macro NEXTW
a3d2			.CAT: 
a3d2				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a3d2 20				db WORD_SYS_CORE+OPCODE_CAT             
a3d3 fb a3			dw .BANG            
a3d5 03				db 2 + 1 
a3d6 .. 00			db "C@",0              
a3d9				endm 
# End of macro CWHEAD
a3d9			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a3d9					if DEBUG_FORTH_WORDS_KEY 
a3d9						DMARK "CAA" 
a3d9 f5				push af  
a3da 3a ee a3			ld a, (.dmark)  
a3dd 32 71 ee			ld (debug_mark),a  
a3e0 3a ef a3			ld a, (.dmark+1)  
a3e3 32 72 ee			ld (debug_mark+1),a  
a3e6 3a f0 a3			ld a, (.dmark+2)  
a3e9 32 73 ee			ld (debug_mark+2),a  
a3ec 18 03			jr .pastdmark  
a3ee ..			.dmark: db "CAA"  
a3f1 f1			.pastdmark: pop af  
a3f2			endm  
# End of macro DMARK
a3f2						CALLMONITOR 
a3f2 cd 9d 94			call break_point_state  
a3f5				endm  
# End of macro CALLMONITOR
a3f5					endif 
a3f5 c3 c2 a3				jp .getbyteat 
a3f8					NEXTW 
a3f8 c3 7c 9e			jp macro_next 
a3fb				endm 
# End of macro NEXTW
a3fb			.BANG: 
a3fb				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a3fb 21				db WORD_SYS_CORE+OPCODE_BANG             
a3fc 31 a4			dw .CBANG            
a3fe 02				db 1 + 1 
a3ff .. 00			db "!",0              
a401				endm 
# End of macro CWHEAD
a401			; | ! ( x w -- ) Store x at address w      | DONE 
a401					if DEBUG_FORTH_WORDS_KEY 
a401						DMARK "BNG" 
a401 f5				push af  
a402 3a 16 a4			ld a, (.dmark)  
a405 32 71 ee			ld (debug_mark),a  
a408 3a 17 a4			ld a, (.dmark+1)  
a40b 32 72 ee			ld (debug_mark+1),a  
a40e 3a 18 a4			ld a, (.dmark+2)  
a411 32 73 ee			ld (debug_mark+2),a  
a414 18 03			jr .pastdmark  
a416 ..			.dmark: db "BNG"  
a419 f1			.pastdmark: pop af  
a41a			endm  
# End of macro DMARK
a41a						CALLMONITOR 
a41a cd 9d 94			call break_point_state  
a41d				endm  
# End of macro CALLMONITOR
a41d					endif 
a41d			 
a41d			.storebyteat:		 
a41d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a41d cd 05 9d			call macro_dsp_valuehl 
a420				endm 
# End of macro FORTH_DSP_VALUEHL
a420					 
a420 e5					push hl 
a421				 
a421					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a421 cd bd 9d			call macro_forth_dsp_pop 
a424				endm 
# End of macro FORTH_DSP_POP
a424			 
a424					; get byte to poke 
a424			 
a424					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a424 cd 05 9d			call macro_dsp_valuehl 
a427				endm 
# End of macro FORTH_DSP_VALUEHL
a427 e5					push hl 
a428			 
a428			 
a428					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a428 cd bd 9d			call macro_forth_dsp_pop 
a42b				endm 
# End of macro FORTH_DSP_POP
a42b			 
a42b			 
a42b d1					pop de 
a42c e1					pop hl 
a42d			 
a42d 73					ld (hl),e 
a42e			 
a42e			 
a42e					NEXTW 
a42e c3 7c 9e			jp macro_next 
a431				endm 
# End of macro NEXTW
a431			.CBANG: 
a431				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a431 22				db WORD_SYS_CORE+OPCODE_CBANG             
a432 5a a4			dw .SCALL            
a434 03				db 2 + 1 
a435 .. 00			db "C!",0              
a438				endm 
# End of macro CWHEAD
a438			; | C!  ( x w -- ) Store x at address w  | DONE 
a438					if DEBUG_FORTH_WORDS_KEY 
a438						DMARK "CBA" 
a438 f5				push af  
a439 3a 4d a4			ld a, (.dmark)  
a43c 32 71 ee			ld (debug_mark),a  
a43f 3a 4e a4			ld a, (.dmark+1)  
a442 32 72 ee			ld (debug_mark+1),a  
a445 3a 4f a4			ld a, (.dmark+2)  
a448 32 73 ee			ld (debug_mark+2),a  
a44b 18 03			jr .pastdmark  
a44d ..			.dmark: db "CBA"  
a450 f1			.pastdmark: pop af  
a451			endm  
# End of macro DMARK
a451						CALLMONITOR 
a451 cd 9d 94			call break_point_state  
a454				endm  
# End of macro CALLMONITOR
a454					endif 
a454 c3 1d a4				jp .storebyteat 
a457					NEXTW 
a457 c3 7c 9e			jp macro_next 
a45a				endm 
# End of macro NEXTW
a45a			.SCALL: 
a45a				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a45a 23				db WORD_SYS_CORE+OPCODE_SCALL             
a45b 8e a4			dw .DEPTH            
a45d 05				db 4 + 1 
a45e .. 00			db "CALL",0              
a463				endm 
# End of macro CWHEAD
a463			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a463					if DEBUG_FORTH_WORDS_KEY 
a463						DMARK "CLL" 
a463 f5				push af  
a464 3a 78 a4			ld a, (.dmark)  
a467 32 71 ee			ld (debug_mark),a  
a46a 3a 79 a4			ld a, (.dmark+1)  
a46d 32 72 ee			ld (debug_mark+1),a  
a470 3a 7a a4			ld a, (.dmark+2)  
a473 32 73 ee			ld (debug_mark+2),a  
a476 18 03			jr .pastdmark  
a478 ..			.dmark: db "CLL"  
a47b f1			.pastdmark: pop af  
a47c			endm  
# End of macro DMARK
a47c						CALLMONITOR 
a47c cd 9d 94			call break_point_state  
a47f				endm  
# End of macro CALLMONITOR
a47f					endif 
a47f			 
a47f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a47f cd 05 9d			call macro_dsp_valuehl 
a482				endm 
# End of macro FORTH_DSP_VALUEHL
a482			 
a482			;		push hl 
a482			 
a482					; destroy value TOS 
a482			 
a482					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a482 cd bd 9d			call macro_forth_dsp_pop 
a485				endm 
# End of macro FORTH_DSP_POP
a485			 
a485						 
a485			;		pop hl 
a485			 
a485					; how to do a call with hl???? save SP? 
a485 cd 20 9e				call forth_call_hl 
a488			 
a488			 
a488					; TODO push value back onto stack for another op etc 
a488			 
a488 cd 0e 9b				call forth_push_numhl 
a48b					NEXTW 
a48b c3 7c 9e			jp macro_next 
a48e				endm 
# End of macro NEXTW
a48e			.DEPTH: 
a48e				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a48e 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a48f cb a4			dw .OVER            
a491 06				db 5 + 1 
a492 .. 00			db "DEPTH",0              
a498				endm 
# End of macro CWHEAD
a498			; | DEPTH ( -- u ) Push count of stack | DONE 
a498					; take current TOS and remove from base value div by two to get count 
a498					if DEBUG_FORTH_WORDS_KEY 
a498						DMARK "DEP" 
a498 f5				push af  
a499 3a ad a4			ld a, (.dmark)  
a49c 32 71 ee			ld (debug_mark),a  
a49f 3a ae a4			ld a, (.dmark+1)  
a4a2 32 72 ee			ld (debug_mark+1),a  
a4a5 3a af a4			ld a, (.dmark+2)  
a4a8 32 73 ee			ld (debug_mark+2),a  
a4ab 18 03			jr .pastdmark  
a4ad ..			.dmark: db "DEP"  
a4b0 f1			.pastdmark: pop af  
a4b1			endm  
# End of macro DMARK
a4b1						CALLMONITOR 
a4b1 cd 9d 94			call break_point_state  
a4b4				endm  
# End of macro CALLMONITOR
a4b4					endif 
a4b4			 
a4b4			 
a4b4 2a 2f ea			ld hl, (cli_data_sp) 
a4b7 11 69 e8			ld de, cli_data_stack 
a4ba ed 52			sbc hl,de 
a4bc				 
a4bc				; div by size of stack item 
a4bc			 
a4bc 5d				ld e,l 
a4bd 0e 03			ld c, 3 
a4bf cd 2c 8c			call Div8 
a4c2			 
a4c2 6f				ld l,a 
a4c3 26 00			ld h,0 
a4c5			 
a4c5				;srl h 
a4c5				;rr l 
a4c5			 
a4c5 cd 0e 9b				call forth_push_numhl 
a4c8					NEXTW 
a4c8 c3 7c 9e			jp macro_next 
a4cb				endm 
# End of macro NEXTW
a4cb			.OVER: 
a4cb				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a4cb 42				db WORD_SYS_CORE+46             
a4cc 12 a5			dw .PAUSE            
a4ce 05				db 4 + 1 
a4cf .. 00			db "OVER",0              
a4d4				endm 
# End of macro CWHEAD
a4d4			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a4d4					if DEBUG_FORTH_WORDS_KEY 
a4d4						DMARK "OVR" 
a4d4 f5				push af  
a4d5 3a e9 a4			ld a, (.dmark)  
a4d8 32 71 ee			ld (debug_mark),a  
a4db 3a ea a4			ld a, (.dmark+1)  
a4de 32 72 ee			ld (debug_mark+1),a  
a4e1 3a eb a4			ld a, (.dmark+2)  
a4e4 32 73 ee			ld (debug_mark+2),a  
a4e7 18 03			jr .pastdmark  
a4e9 ..			.dmark: db "OVR"  
a4ec f1			.pastdmark: pop af  
a4ed			endm  
# End of macro DMARK
a4ed						CALLMONITOR 
a4ed cd 9d 94			call break_point_state  
a4f0				endm  
# End of macro CALLMONITOR
a4f0					endif 
a4f0			 
a4f0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4f0 cd 05 9d			call macro_dsp_valuehl 
a4f3				endm 
# End of macro FORTH_DSP_VALUEHL
a4f3 e5					push hl    ; n2 
a4f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4f4 cd bd 9d			call macro_forth_dsp_pop 
a4f7				endm 
# End of macro FORTH_DSP_POP
a4f7			 
a4f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4f7 cd 05 9d			call macro_dsp_valuehl 
a4fa				endm 
# End of macro FORTH_DSP_VALUEHL
a4fa e5					push hl    ; n1 
a4fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4fb cd bd 9d			call macro_forth_dsp_pop 
a4fe				endm 
# End of macro FORTH_DSP_POP
a4fe			 
a4fe d1					pop de     ; n1 
a4ff e1					pop hl     ; n2 
a500			 
a500 d5					push de 
a501 e5					push hl 
a502 d5					push de 
a503			 
a503					; push back  
a503			 
a503 e1					pop hl 
a504 cd 0e 9b				call forth_push_numhl 
a507 e1					pop hl 
a508 cd 0e 9b				call forth_push_numhl 
a50b e1					pop hl 
a50c cd 0e 9b				call forth_push_numhl 
a50f					NEXTW 
a50f c3 7c 9e			jp macro_next 
a512				endm 
# End of macro NEXTW
a512			 
a512			.PAUSE: 
a512				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a512 43				db WORD_SYS_CORE+47             
a513 47 a5			dw .PAUSES            
a515 08				db 7 + 1 
a516 .. 00			db "PAUSEMS",0              
a51e				endm 
# End of macro CWHEAD
a51e			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a51e					if DEBUG_FORTH_WORDS_KEY 
a51e						DMARK "PMS" 
a51e f5				push af  
a51f 3a 33 a5			ld a, (.dmark)  
a522 32 71 ee			ld (debug_mark),a  
a525 3a 34 a5			ld a, (.dmark+1)  
a528 32 72 ee			ld (debug_mark+1),a  
a52b 3a 35 a5			ld a, (.dmark+2)  
a52e 32 73 ee			ld (debug_mark+2),a  
a531 18 03			jr .pastdmark  
a533 ..			.dmark: db "PMS"  
a536 f1			.pastdmark: pop af  
a537			endm  
# End of macro DMARK
a537						CALLMONITOR 
a537 cd 9d 94			call break_point_state  
a53a				endm  
# End of macro CALLMONITOR
a53a					endif 
a53a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a53a cd 05 9d			call macro_dsp_valuehl 
a53d				endm 
# End of macro FORTH_DSP_VALUEHL
a53d			;		push hl    ; n2 
a53d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a53d cd bd 9d			call macro_forth_dsp_pop 
a540				endm 
# End of macro FORTH_DSP_POP
a540			;		pop hl 
a540			 
a540 7d					ld a, l 
a541 cd d1 89				call aDelayInMS 
a544				       NEXTW 
a544 c3 7c 9e			jp macro_next 
a547				endm 
# End of macro NEXTW
a547			.PAUSES:  
a547				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a547 44				db WORD_SYS_CORE+48             
a548 b6 a5			dw .ROT            
a54a 06				db 5 + 1 
a54b .. 00			db "PAUSE",0              
a551				endm 
# End of macro CWHEAD
a551			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a551					if DEBUG_FORTH_WORDS_KEY 
a551						DMARK "PAU" 
a551 f5				push af  
a552 3a 66 a5			ld a, (.dmark)  
a555 32 71 ee			ld (debug_mark),a  
a558 3a 67 a5			ld a, (.dmark+1)  
a55b 32 72 ee			ld (debug_mark+1),a  
a55e 3a 68 a5			ld a, (.dmark+2)  
a561 32 73 ee			ld (debug_mark+2),a  
a564 18 03			jr .pastdmark  
a566 ..			.dmark: db "PAU"  
a569 f1			.pastdmark: pop af  
a56a			endm  
# End of macro DMARK
a56a						CALLMONITOR 
a56a cd 9d 94			call break_point_state  
a56d				endm  
# End of macro CALLMONITOR
a56d					endif 
a56d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a56d cd 05 9d			call macro_dsp_valuehl 
a570				endm 
# End of macro FORTH_DSP_VALUEHL
a570			;		push hl    ; n2 
a570					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a570 cd bd 9d			call macro_forth_dsp_pop 
a573				endm 
# End of macro FORTH_DSP_POP
a573			;		pop hl 
a573 45					ld b, l 
a574					if DEBUG_FORTH_WORDS 
a574						DMARK "PAU" 
a574 f5				push af  
a575 3a 89 a5			ld a, (.dmark)  
a578 32 71 ee			ld (debug_mark),a  
a57b 3a 8a a5			ld a, (.dmark+1)  
a57e 32 72 ee			ld (debug_mark+1),a  
a581 3a 8b a5			ld a, (.dmark+2)  
a584 32 73 ee			ld (debug_mark+2),a  
a587 18 03			jr .pastdmark  
a589 ..			.dmark: db "PAU"  
a58c f1			.pastdmark: pop af  
a58d			endm  
# End of macro DMARK
a58d						CALLMONITOR 
a58d cd 9d 94			call break_point_state  
a590				endm  
# End of macro CALLMONITOR
a590					endif 
a590 c5			.pauses1:	push bc 
a591 cd ec 89				call delay1s 
a594 c1					pop bc 
a595					if DEBUG_FORTH_WORDS 
a595						DMARK "PA1" 
a595 f5				push af  
a596 3a aa a5			ld a, (.dmark)  
a599 32 71 ee			ld (debug_mark),a  
a59c 3a ab a5			ld a, (.dmark+1)  
a59f 32 72 ee			ld (debug_mark+1),a  
a5a2 3a ac a5			ld a, (.dmark+2)  
a5a5 32 73 ee			ld (debug_mark+2),a  
a5a8 18 03			jr .pastdmark  
a5aa ..			.dmark: db "PA1"  
a5ad f1			.pastdmark: pop af  
a5ae			endm  
# End of macro DMARK
a5ae						CALLMONITOR 
a5ae cd 9d 94			call break_point_state  
a5b1				endm  
# End of macro CALLMONITOR
a5b1					endif 
a5b1 10 dd				djnz .pauses1 
a5b3			 
a5b3				       NEXTW 
a5b3 c3 7c 9e			jp macro_next 
a5b6				endm 
# End of macro NEXTW
a5b6			.ROT: 
a5b6				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a5b6 45				db WORD_SYS_CORE+49             
a5b7 04 a6			dw .UWORDS            
a5b9 04				db 3 + 1 
a5ba .. 00			db "ROT",0              
a5be				endm 
# End of macro CWHEAD
a5be			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a5be					if DEBUG_FORTH_WORDS_KEY 
a5be						DMARK "ROT" 
a5be f5				push af  
a5bf 3a d3 a5			ld a, (.dmark)  
a5c2 32 71 ee			ld (debug_mark),a  
a5c5 3a d4 a5			ld a, (.dmark+1)  
a5c8 32 72 ee			ld (debug_mark+1),a  
a5cb 3a d5 a5			ld a, (.dmark+2)  
a5ce 32 73 ee			ld (debug_mark+2),a  
a5d1 18 03			jr .pastdmark  
a5d3 ..			.dmark: db "ROT"  
a5d6 f1			.pastdmark: pop af  
a5d7			endm  
# End of macro DMARK
a5d7						CALLMONITOR 
a5d7 cd 9d 94			call break_point_state  
a5da				endm  
# End of macro CALLMONITOR
a5da					endif 
a5da			 
a5da					FORTH_DSP_VALUEHL 
a5da cd 05 9d			call macro_dsp_valuehl 
a5dd				endm 
# End of macro FORTH_DSP_VALUEHL
a5dd e5					push hl    ; u3  
a5de			 
a5de					FORTH_DSP_POP 
a5de cd bd 9d			call macro_forth_dsp_pop 
a5e1				endm 
# End of macro FORTH_DSP_POP
a5e1			   
a5e1					FORTH_DSP_VALUEHL 
a5e1 cd 05 9d			call macro_dsp_valuehl 
a5e4				endm 
# End of macro FORTH_DSP_VALUEHL
a5e4 e5					push hl     ; u2 
a5e5			 
a5e5					FORTH_DSP_POP 
a5e5 cd bd 9d			call macro_forth_dsp_pop 
a5e8				endm 
# End of macro FORTH_DSP_POP
a5e8			 
a5e8					FORTH_DSP_VALUEHL 
a5e8 cd 05 9d			call macro_dsp_valuehl 
a5eb				endm 
# End of macro FORTH_DSP_VALUEHL
a5eb e5					push hl     ; u1 
a5ec			 
a5ec					FORTH_DSP_POP 
a5ec cd bd 9d			call macro_forth_dsp_pop 
a5ef				endm 
# End of macro FORTH_DSP_POP
a5ef			 
a5ef c1					pop bc      ; u1 
a5f0 e1					pop hl      ; u2 
a5f1 d1					pop de      ; u3 
a5f2			 
a5f2			 
a5f2 c5					push bc 
a5f3 d5					push de 
a5f4 e5					push hl 
a5f5			 
a5f5			 
a5f5 e1					pop hl 
a5f6 cd 0e 9b				call forth_push_numhl 
a5f9			 
a5f9 e1					pop hl 
a5fa cd 0e 9b				call forth_push_numhl 
a5fd			 
a5fd e1					pop hl 
a5fe cd 0e 9b				call forth_push_numhl 
a601					 
a601			 
a601			 
a601			 
a601			 
a601			 
a601				       NEXTW 
a601 c3 7c 9e			jp macro_next 
a604				endm 
# End of macro NEXTW
a604			 
a604			.UWORDS: 
a604				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a604 50				db WORD_SYS_CORE+60             
a605 c6 a6			dw .BP            
a607 07				db 6 + 1 
a608 .. 00			db "UWORDS",0              
a60f				endm 
# End of macro CWHEAD
a60f			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a60f			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a60f			; | | Following the count are the individual words. 
a60f			; | | 
a60f			; | | e.g. UWORDS 
a60f			; | | BOX DIRLIST 2 
a60f			; | |  
a60f			; | | Can be used to save the words to storage via: 
a60f			; | | UWORDS $01 DO $01 APPEND LOOP 
a60f				if DEBUG_FORTH_WORDS_KEY 
a60f					DMARK "UWR" 
a60f f5				push af  
a610 3a 24 a6			ld a, (.dmark)  
a613 32 71 ee			ld (debug_mark),a  
a616 3a 25 a6			ld a, (.dmark+1)  
a619 32 72 ee			ld (debug_mark+1),a  
a61c 3a 26 a6			ld a, (.dmark+2)  
a61f 32 73 ee			ld (debug_mark+2),a  
a622 18 03			jr .pastdmark  
a624 ..			.dmark: db "UWR"  
a627 f1			.pastdmark: pop af  
a628			endm  
# End of macro DMARK
a628					CALLMONITOR 
a628 cd 9d 94			call break_point_state  
a62b				endm  
# End of macro CALLMONITOR
a62b				endif 
a62b 21 a6 da				ld hl, baseram 
a62e					;ld hl, baseusermem 
a62e 01 00 00				ld bc, 0    ; start a counter 
a631			 
a631				; skip dict stub 
a631			 
a631 cd cd 9f				call forth_tok_next 
a634			 
a634			 
a634			; while we have words to look for 
a634			 
a634 7e			.douscan:	ld a, (hl)      
a635				if DEBUG_FORTH_WORDS 
a635					DMARK "UWs" 
a635 f5				push af  
a636 3a 4a a6			ld a, (.dmark)  
a639 32 71 ee			ld (debug_mark),a  
a63c 3a 4b a6			ld a, (.dmark+1)  
a63f 32 72 ee			ld (debug_mark+1),a  
a642 3a 4c a6			ld a, (.dmark+2)  
a645 32 73 ee			ld (debug_mark+2),a  
a648 18 03			jr .pastdmark  
a64a ..			.dmark: db "UWs"  
a64d f1			.pastdmark: pop af  
a64e			endm  
# End of macro DMARK
a64e					CALLMONITOR 
a64e cd 9d 94			call break_point_state  
a651				endm  
# End of macro CALLMONITOR
a651				endif 
a651 fe 00				cp WORD_SYS_END 
a653 28 4d				jr z, .udone 
a655 fe 01				cp WORD_SYS_UWORD 
a657 20 44				jr nz, .nuword 
a659			 
a659				if DEBUG_FORTH_WORDS 
a659					DMARK "UWu" 
a659 f5				push af  
a65a 3a 6e a6			ld a, (.dmark)  
a65d 32 71 ee			ld (debug_mark),a  
a660 3a 6f a6			ld a, (.dmark+1)  
a663 32 72 ee			ld (debug_mark+1),a  
a666 3a 70 a6			ld a, (.dmark+2)  
a669 32 73 ee			ld (debug_mark+2),a  
a66c 18 03			jr .pastdmark  
a66e ..			.dmark: db "UWu"  
a671 f1			.pastdmark: pop af  
a672			endm  
# End of macro DMARK
a672					CALLMONITOR 
a672 cd 9d 94			call break_point_state  
a675				endm  
# End of macro CALLMONITOR
a675				endif 
a675					; we have a uword so push its name to the stack 
a675			 
a675 e5				   	push hl  ; save so we can move to next dict block 
a676			 
a676					; skip opcode 
a676 23					inc hl  
a677					; skip next ptr 
a677 23					inc hl  
a678 23					inc hl 
a679					; skip len 
a679 23					inc hl 
a67a				if DEBUG_FORTH_WORDS 
a67a					DMARK "UWt" 
a67a f5				push af  
a67b 3a 8f a6			ld a, (.dmark)  
a67e 32 71 ee			ld (debug_mark),a  
a681 3a 90 a6			ld a, (.dmark+1)  
a684 32 72 ee			ld (debug_mark+1),a  
a687 3a 91 a6			ld a, (.dmark+2)  
a68a 32 73 ee			ld (debug_mark+2),a  
a68d 18 03			jr .pastdmark  
a68f ..			.dmark: db "UWt"  
a692 f1			.pastdmark: pop af  
a693			endm  
# End of macro DMARK
a693					CALLMONITOR 
a693 cd 9d 94			call break_point_state  
a696				endm  
# End of macro CALLMONITOR
a696				endif 
a696 03					inc bc 
a697			 
a697 c5					push bc 
a698 cd 7c 9b				call forth_push_str 
a69b c1					pop bc 
a69c			 
a69c e1					pop hl 	 
a69d			 
a69d cd cd 9f		.nuword:	call forth_tok_next 
a6a0 18 92				jr .douscan  
a6a2			 
a6a2			.udone:		 ; push count of uwords found 
a6a2 c5					push bc 
a6a3 e1					pop hl 
a6a4			 
a6a4				if DEBUG_FORTH_WORDS 
a6a4					DMARK "UWc" 
a6a4 f5				push af  
a6a5 3a b9 a6			ld a, (.dmark)  
a6a8 32 71 ee			ld (debug_mark),a  
a6ab 3a ba a6			ld a, (.dmark+1)  
a6ae 32 72 ee			ld (debug_mark+1),a  
a6b1 3a bb a6			ld a, (.dmark+2)  
a6b4 32 73 ee			ld (debug_mark+2),a  
a6b7 18 03			jr .pastdmark  
a6b9 ..			.dmark: db "UWc"  
a6bc f1			.pastdmark: pop af  
a6bd			endm  
# End of macro DMARK
a6bd					CALLMONITOR 
a6bd cd 9d 94			call break_point_state  
a6c0				endm  
# End of macro CALLMONITOR
a6c0				endif 
a6c0 cd 0e 9b				call forth_push_numhl 
a6c3			 
a6c3			 
a6c3				       NEXTW 
a6c3 c3 7c 9e			jp macro_next 
a6c6				endm 
# End of macro NEXTW
a6c6			 
a6c6			.BP: 
a6c6				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a6c6 54				db WORD_SYS_CORE+64             
a6c7 fc a6			dw .MONITOR            
a6c9 03				db 2 + 1 
a6ca .. 00			db "BP",0              
a6cd				endm 
# End of macro CWHEAD
a6cd			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a6cd			; | | $00 Will enable the break points within specific code paths 
a6cd			; | | $01 Will disable break points 
a6cd			; | |  
a6cd			; | | By default break points are off. Either the above can be used to enable them 
a6cd			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a6cd			; | | and on release of the pressed key a message will be disaplayed to notify 
a6cd			; | | that break points are enabled. Pressing any key will then continue boot process. 
a6cd					; get byte count 
a6cd					if DEBUG_FORTH_WORDS_KEY 
a6cd						DMARK "BP." 
a6cd f5				push af  
a6ce 3a e2 a6			ld a, (.dmark)  
a6d1 32 71 ee			ld (debug_mark),a  
a6d4 3a e3 a6			ld a, (.dmark+1)  
a6d7 32 72 ee			ld (debug_mark+1),a  
a6da 3a e4 a6			ld a, (.dmark+2)  
a6dd 32 73 ee			ld (debug_mark+2),a  
a6e0 18 03			jr .pastdmark  
a6e2 ..			.dmark: db "BP."  
a6e5 f1			.pastdmark: pop af  
a6e6			endm  
# End of macro DMARK
a6e6						CALLMONITOR 
a6e6 cd 9d 94			call break_point_state  
a6e9				endm  
# End of macro CALLMONITOR
a6e9					endif 
a6e9			 
a6e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a6e9 cd 05 9d			call macro_dsp_valuehl 
a6ec				endm 
# End of macro FORTH_DSP_VALUEHL
a6ec			 
a6ec			;		push hl 
a6ec			 
a6ec					; destroy value TOS 
a6ec			 
a6ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a6ec cd bd 9d			call macro_forth_dsp_pop 
a6ef				endm 
# End of macro FORTH_DSP_POP
a6ef			 
a6ef			;		pop hl 
a6ef			 
a6ef 3e 00				ld a,0 
a6f1 bd					cp l 
a6f2 28 02				jr z, .bpset 
a6f4 3e 2a				ld a, '*' 
a6f6			 
a6f6 32 f3 e2		.bpset:		ld (os_view_disable), a 
a6f9			 
a6f9			 
a6f9					NEXTW 
a6f9 c3 7c 9e			jp macro_next 
a6fc				endm 
# End of macro NEXTW
a6fc			 
a6fc			 
a6fc			.MONITOR: 
a6fc				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a6fc 55				db WORD_SYS_CORE+65             
a6fd 2f a7			dw .MALLOC            
a6ff 08				db 7 + 1 
a700 .. 00			db "MONITOR",0              
a708				endm 
# End of macro CWHEAD
a708			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a708			; | | At start the current various registers will be displayed with contents. 
a708			; | | Top right corner will show the most recent debug marker seen. 
a708			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a708			; | | and the return stack pointer (RSP). 
a708			; | | Pressing: 
a708			; | |    1 - Initial screen 
a708			; | |    2 - Display a data dump of HL 
a708			; | |    3 - Display a data dump of DE 
a708			; | |    4 - Display a data dump of BC 
a708			; | |    5 - Display a data dump of HL 
a708			; | |    6 - Display a data dump of DSP 
a708			; | |    7 - Display a data dump of RSP 
a708			; | |    8 - Display a data dump of what is at DSP 
a708			; | |    9 - Display a data dump of what is at RSP 
a708			; | |    0 - Exit monitor and continue running. This will also enable break points 
a708			; | |    * - Disable break points 
a708			; | |    # - Enter traditional monitor mode 
a708			; | | 
a708			; | | Monitor Mode 
a708			; | | ------------ 
a708			; | | A prompt of '>' will be shown for various commands: 
a708			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a708			; | |    C - Continue display a data dump from the last set address 
a708			; | |    M xxxx - Set start of memory edit at address xx 
a708			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a708			; | |    Q - Return to previous 
a708					if DEBUG_FORTH_WORDS_KEY 
a708						DMARK "MON" 
a708 f5				push af  
a709 3a 1d a7			ld a, (.dmark)  
a70c 32 71 ee			ld (debug_mark),a  
a70f 3a 1e a7			ld a, (.dmark+1)  
a712 32 72 ee			ld (debug_mark+1),a  
a715 3a 1f a7			ld a, (.dmark+2)  
a718 32 73 ee			ld (debug_mark+2),a  
a71b 18 03			jr .pastdmark  
a71d ..			.dmark: db "MON"  
a720 f1			.pastdmark: pop af  
a721			endm  
# End of macro DMARK
a721						CALLMONITOR 
a721 cd 9d 94			call break_point_state  
a724				endm  
# End of macro CALLMONITOR
a724					endif 
a724 3e 00				ld a, 0 
a726 32 f3 e2				ld (os_view_disable), a 
a729			 
a729					CALLMONITOR 
a729 cd 9d 94			call break_point_state  
a72c				endm  
# End of macro CALLMONITOR
a72c			 
a72c			;	call monitor 
a72c			 
a72c					NEXTW 
a72c c3 7c 9e			jp macro_next 
a72f				endm 
# End of macro NEXTW
a72f			 
a72f			 
a72f			.MALLOC: 
a72f				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a72f 56				db WORD_SYS_CORE+66             
a730 58 a7			dw .MALLOC2            
a732 06				db 5 + 1 
a733 .. 00			db "ALLOT",0              
a739				endm 
# End of macro CWHEAD
a739			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a739					if DEBUG_FORTH_WORDS_KEY 
a739						DMARK "ALL" 
a739 f5				push af  
a73a 3a 4e a7			ld a, (.dmark)  
a73d 32 71 ee			ld (debug_mark),a  
a740 3a 4f a7			ld a, (.dmark+1)  
a743 32 72 ee			ld (debug_mark+1),a  
a746 3a 50 a7			ld a, (.dmark+2)  
a749 32 73 ee			ld (debug_mark+2),a  
a74c 18 03			jr .pastdmark  
a74e ..			.dmark: db "ALL"  
a751 f1			.pastdmark: pop af  
a752			endm  
# End of macro DMARK
a752						CALLMONITOR 
a752 cd 9d 94			call break_point_state  
a755				endm  
# End of macro CALLMONITOR
a755					endif 
a755 c3 7f a7				jp .mallocc 
a758			.MALLOC2: 
a758				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a758 56				db WORD_SYS_CORE+66             
a759 96 a7			dw .FREE            
a75b 07				db 6 + 1 
a75c .. 00			db "MALLOC",0              
a763				endm 
# End of macro CWHEAD
a763			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a763					; get byte count 
a763					if DEBUG_FORTH_WORDS_KEY 
a763						DMARK "MAL" 
a763 f5				push af  
a764 3a 78 a7			ld a, (.dmark)  
a767 32 71 ee			ld (debug_mark),a  
a76a 3a 79 a7			ld a, (.dmark+1)  
a76d 32 72 ee			ld (debug_mark+1),a  
a770 3a 7a a7			ld a, (.dmark+2)  
a773 32 73 ee			ld (debug_mark+2),a  
a776 18 03			jr .pastdmark  
a778 ..			.dmark: db "MAL"  
a77b f1			.pastdmark: pop af  
a77c			endm  
# End of macro DMARK
a77c						CALLMONITOR 
a77c cd 9d 94			call break_point_state  
a77f				endm  
# End of macro CALLMONITOR
a77f					endif 
a77f			.mallocc: 
a77f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a77f cd 05 9d			call macro_dsp_valuehl 
a782				endm 
# End of macro FORTH_DSP_VALUEHL
a782			 
a782			;		push hl 
a782			 
a782					; destroy value TOS 
a782			 
a782					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a782 cd bd 9d			call macro_forth_dsp_pop 
a785				endm 
# End of macro FORTH_DSP_POP
a785			 
a785			;		pop hl 
a785 cd 63 91				call malloc 
a788				if DEBUG_FORTH_MALLOC_GUARD 
a788 f5					push af 
a789 cd c5 8c				call ishlzero 
a78c			;		ld a, l 
a78c			;		add h 
a78c			;		cp 0 
a78c f1					pop af 
a78d					 
a78d cc e3 c6				call z,malloc_error 
a790				endif 
a790			 
a790 cd 0e 9b				call forth_push_numhl 
a793					NEXTW 
a793 c3 7c 9e			jp macro_next 
a796				endm 
# End of macro NEXTW
a796			 
a796			.FREE: 
a796				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a796 57				db WORD_SYS_CORE+67             
a797 c7 a7			dw .LIST            
a799 05				db 4 + 1 
a79a .. 00			db "FREE",0              
a79f				endm 
# End of macro CWHEAD
a79f			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a79f					if DEBUG_FORTH_WORDS_KEY 
a79f						DMARK "FRE" 
a79f f5				push af  
a7a0 3a b4 a7			ld a, (.dmark)  
a7a3 32 71 ee			ld (debug_mark),a  
a7a6 3a b5 a7			ld a, (.dmark+1)  
a7a9 32 72 ee			ld (debug_mark+1),a  
a7ac 3a b6 a7			ld a, (.dmark+2)  
a7af 32 73 ee			ld (debug_mark+2),a  
a7b2 18 03			jr .pastdmark  
a7b4 ..			.dmark: db "FRE"  
a7b7 f1			.pastdmark: pop af  
a7b8			endm  
# End of macro DMARK
a7b8						CALLMONITOR 
a7b8 cd 9d 94			call break_point_state  
a7bb				endm  
# End of macro CALLMONITOR
a7bb					endif 
a7bb					; get address 
a7bb			 
a7bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a7bb cd 05 9d			call macro_dsp_valuehl 
a7be				endm 
# End of macro FORTH_DSP_VALUEHL
a7be			 
a7be			;		push hl 
a7be			 
a7be					; destroy value TOS 
a7be			 
a7be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a7be cd bd 9d			call macro_forth_dsp_pop 
a7c1				endm 
# End of macro FORTH_DSP_POP
a7c1			 
a7c1			;		pop hl 
a7c1			if FORTH_ENABLE_MALLOCFREE 
a7c1 cd 2d 92				call free 
a7c4			endif 
a7c4					NEXTW 
a7c4 c3 7c 9e			jp macro_next 
a7c7				endm 
# End of macro NEXTW
a7c7			.LIST: 
a7c7				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a7c7 5c				db WORD_SYS_CORE+72             
a7c8 b5 a9			dw .FORGET            
a7ca 05				db 4 + 1 
a7cb .. 00			db "LIST",0              
a7d0				endm 
# End of macro CWHEAD
a7d0			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a7d0			; | | The quoted word must be in upper case. 
a7d0				if DEBUG_FORTH_WORDS_KEY 
a7d0					DMARK "LST" 
a7d0 f5				push af  
a7d1 3a e5 a7			ld a, (.dmark)  
a7d4 32 71 ee			ld (debug_mark),a  
a7d7 3a e6 a7			ld a, (.dmark+1)  
a7da 32 72 ee			ld (debug_mark+1),a  
a7dd 3a e7 a7			ld a, (.dmark+2)  
a7e0 32 73 ee			ld (debug_mark+2),a  
a7e3 18 03			jr .pastdmark  
a7e5 ..			.dmark: db "LST"  
a7e8 f1			.pastdmark: pop af  
a7e9			endm  
# End of macro DMARK
a7e9					CALLMONITOR 
a7e9 cd 9d 94			call break_point_state  
a7ec				endm  
# End of macro CALLMONITOR
a7ec				endif 
a7ec			 
a7ec					FORTH_DSP_VALUEHL 
a7ec cd 05 9d			call macro_dsp_valuehl 
a7ef				endm 
# End of macro FORTH_DSP_VALUEHL
a7ef			 
a7ef e5					push hl 
a7f0					FORTH_DSP_POP 
a7f0 cd bd 9d			call macro_forth_dsp_pop 
a7f3				endm 
# End of macro FORTH_DSP_POP
a7f3 c1					pop bc 
a7f4			 
a7f4			; Start format of scratch string 
a7f4			 
a7f4 21 02 e3				ld hl, scratch 
a7f7			 
a7f7 3e 3a				ld a, ':' 
a7f9 77					ld (hl),a 
a7fa 23					inc hl 
a7fb 3e 20				ld a, ' ' 
a7fd 77					ld (hl), a 
a7fe			 
a7fe					; Get ptr to the word we need to look up 
a7fe			 
a7fe			;		FORTH_DSP_VALUEHL 
a7fe					;v5 FORTH_DSP_VALUE 
a7fe				; TODO type check 
a7fe			;		inc hl    ; Skip type check  
a7fe			;		push hl 
a7fe			;		ex de, hl    ; put into DE 
a7fe			 
a7fe			 
a7fe 21 a6 da				ld hl, baseram 
a801					;ld hl, baseusermem 
a801			 
a801 e5			push hl   ; sacreifical push 
a802			 
a802			.ldouscanm: 
a802 e1				pop hl 
a803			.ldouscan: 
a803				if DEBUG_FORTH_WORDS 
a803					DMARK "LSs" 
a803 f5				push af  
a804 3a 18 a8			ld a, (.dmark)  
a807 32 71 ee			ld (debug_mark),a  
a80a 3a 19 a8			ld a, (.dmark+1)  
a80d 32 72 ee			ld (debug_mark+1),a  
a810 3a 1a a8			ld a, (.dmark+2)  
a813 32 73 ee			ld (debug_mark+2),a  
a816 18 03			jr .pastdmark  
a818 ..			.dmark: db "LSs"  
a81b f1			.pastdmark: pop af  
a81c			endm  
# End of macro DMARK
a81c					CALLMONITOR 
a81c cd 9d 94			call break_point_state  
a81f				endm  
# End of macro CALLMONITOR
a81f				endif 
a81f				; skip dict stub 
a81f cd cd 9f				call forth_tok_next 
a822			 
a822			 
a822			; while we have words to look for 
a822			 
a822 7e				ld a, (hl)      
a823				if DEBUG_FORTH_WORDS 
a823					DMARK "LSk" 
a823 f5				push af  
a824 3a 38 a8			ld a, (.dmark)  
a827 32 71 ee			ld (debug_mark),a  
a82a 3a 39 a8			ld a, (.dmark+1)  
a82d 32 72 ee			ld (debug_mark+1),a  
a830 3a 3a a8			ld a, (.dmark+2)  
a833 32 73 ee			ld (debug_mark+2),a  
a836 18 03			jr .pastdmark  
a838 ..			.dmark: db "LSk"  
a83b f1			.pastdmark: pop af  
a83c			endm  
# End of macro DMARK
a83c					CALLMONITOR 
a83c cd 9d 94			call break_point_state  
a83f				endm  
# End of macro CALLMONITOR
a83f				endif 
a83f					;cp WORD_SYS_END 
a83f					;jp z, .lunotfound 
a83f			 
a83f					; if we hit non uwords then gone too far 
a83f fe 01				cp WORD_SYS_UWORD 
a841 c2 71 a9				jp nz, .lunotfound 
a844			 
a844				if DEBUG_FORTH_WORDS 
a844					DMARK "LSu" 
a844 f5				push af  
a845 3a 59 a8			ld a, (.dmark)  
a848 32 71 ee			ld (debug_mark),a  
a84b 3a 5a a8			ld a, (.dmark+1)  
a84e 32 72 ee			ld (debug_mark+1),a  
a851 3a 5b a8			ld a, (.dmark+2)  
a854 32 73 ee			ld (debug_mark+2),a  
a857 18 03			jr .pastdmark  
a859 ..			.dmark: db "LSu"  
a85c f1			.pastdmark: pop af  
a85d			endm  
# End of macro DMARK
a85d					CALLMONITOR 
a85d cd 9d 94			call break_point_state  
a860				endm  
# End of macro CALLMONITOR
a860				endif 
a860			 
a860					; found a uword but is it the one we want... 
a860			 
a860 c5					push bc     ; uword to find is on bc 
a861 d1					pop de 
a862			 
a862 e5					push hl  ; to save the ptr 
a863			 
a863					; skip opcode 
a863 23					inc hl  
a864					; skip next ptr 
a864 23					inc hl  
a865 23					inc hl 
a866					; skip len 
a866 23					inc hl 
a867			 
a867				if DEBUG_FORTH_WORDS 
a867					DMARK "LSc" 
a867 f5				push af  
a868 3a 7c a8			ld a, (.dmark)  
a86b 32 71 ee			ld (debug_mark),a  
a86e 3a 7d a8			ld a, (.dmark+1)  
a871 32 72 ee			ld (debug_mark+1),a  
a874 3a 7e a8			ld a, (.dmark+2)  
a877 32 73 ee			ld (debug_mark+2),a  
a87a 18 03			jr .pastdmark  
a87c ..			.dmark: db "LSc"  
a87f f1			.pastdmark: pop af  
a880			endm  
# End of macro DMARK
a880					CALLMONITOR 
a880 cd 9d 94			call break_point_state  
a883				endm  
# End of macro CALLMONITOR
a883				endif 
a883 cd 32 91				call strcmp 
a886 c2 02 a8				jp nz, .ldouscanm 
a889				 
a889			 
a889			 
a889					; we have a uword so push its name to the stack 
a889			 
a889			;	   	push hl  ; save so we can move to next dict block 
a889 e1			pop hl 
a88a			 
a88a				if DEBUG_FORTH_WORDS 
a88a					DMARK "LSm" 
a88a f5				push af  
a88b 3a 9f a8			ld a, (.dmark)  
a88e 32 71 ee			ld (debug_mark),a  
a891 3a a0 a8			ld a, (.dmark+1)  
a894 32 72 ee			ld (debug_mark+1),a  
a897 3a a1 a8			ld a, (.dmark+2)  
a89a 32 73 ee			ld (debug_mark+2),a  
a89d 18 03			jr .pastdmark  
a89f ..			.dmark: db "LSm"  
a8a2 f1			.pastdmark: pop af  
a8a3			endm  
# End of macro DMARK
a8a3					CALLMONITOR 
a8a3 cd 9d 94			call break_point_state  
a8a6				endm  
# End of macro CALLMONITOR
a8a6				endif 
a8a6			 
a8a6					; skip opcode 
a8a6 23					inc hl  
a8a7					; skip next ptr 
a8a7 23					inc hl  
a8a8 23					inc hl 
a8a9					; skip len 
a8a9 7e					ld a, (hl)   ; save length to add 
a8aa				if DEBUG_FORTH_WORDS 
a8aa					DMARK "LS2" 
a8aa f5				push af  
a8ab 3a bf a8			ld a, (.dmark)  
a8ae 32 71 ee			ld (debug_mark),a  
a8b1 3a c0 a8			ld a, (.dmark+1)  
a8b4 32 72 ee			ld (debug_mark+1),a  
a8b7 3a c1 a8			ld a, (.dmark+2)  
a8ba 32 73 ee			ld (debug_mark+2),a  
a8bd 18 03			jr .pastdmark  
a8bf ..			.dmark: db "LS2"  
a8c2 f1			.pastdmark: pop af  
a8c3			endm  
# End of macro DMARK
a8c3					CALLMONITOR 
a8c3 cd 9d 94			call break_point_state  
a8c6				endm  
# End of macro CALLMONITOR
a8c6				endif 
a8c6			 
a8c6					; save this location 
a8c6				 
a8c6 e5					push hl 
a8c7			 
a8c7 23					inc hl 
a8c8 11 04 e3				ld de, scratch+2 
a8cb 4f					ld c, a 
a8cc 06 00				ld b, 0 
a8ce			 
a8ce				if DEBUG_FORTH_WORDS 
a8ce					DMARK "LSn" 
a8ce f5				push af  
a8cf 3a e3 a8			ld a, (.dmark)  
a8d2 32 71 ee			ld (debug_mark),a  
a8d5 3a e4 a8			ld a, (.dmark+1)  
a8d8 32 72 ee			ld (debug_mark+1),a  
a8db 3a e5 a8			ld a, (.dmark+2)  
a8de 32 73 ee			ld (debug_mark+2),a  
a8e1 18 03			jr .pastdmark  
a8e3 ..			.dmark: db "LSn"  
a8e6 f1			.pastdmark: pop af  
a8e7			endm  
# End of macro DMARK
a8e7					CALLMONITOR 
a8e7 cd 9d 94			call break_point_state  
a8ea				endm  
# End of macro CALLMONITOR
a8ea				endif 
a8ea			 
a8ea					; copy uword name to scratch 
a8ea			 
a8ea ed b0				ldir 
a8ec			 
a8ec 1b					dec de 
a8ed 3e 20				ld a, ' '    ; change null to space 
a8ef 12					ld (de), a 
a8f0			 
a8f0 13					inc de 
a8f1			 
a8f1 d5					push de 
a8f2 c1					pop bc     ; move scratch pointer to end of word name and save it 
a8f3			 
a8f3 e1					pop hl 
a8f4 7e					ld a, (hl) 
a8f5					;inc hl 
a8f5					; skip word string 
a8f5 cd 9c 8c				call addatohl 
a8f8			 
a8f8 23					inc hl 
a8f9			 
a8f9				if DEBUG_FORTH_WORDS 
a8f9					DMARK "LS3" 
a8f9 f5				push af  
a8fa 3a 0e a9			ld a, (.dmark)  
a8fd 32 71 ee			ld (debug_mark),a  
a900 3a 0f a9			ld a, (.dmark+1)  
a903 32 72 ee			ld (debug_mark+1),a  
a906 3a 10 a9			ld a, (.dmark+2)  
a909 32 73 ee			ld (debug_mark+2),a  
a90c 18 03			jr .pastdmark  
a90e ..			.dmark: db "LS3"  
a911 f1			.pastdmark: pop af  
a912			endm  
# End of macro DMARK
a912					CALLMONITOR 
a912 cd 9d 94			call break_point_state  
a915				endm  
# End of macro CALLMONITOR
a915				endif 
a915					; should now be at the start of the machine code to setup the eval of the uword 
a915					; now locate the ptr to the string defintion 
a915			 
a915					; skip ld hl, 
a915					; then load the ptr 
a915			; TODO use get from hl ptr 
a915 23					inc hl 
a916 5e					ld e, (hl) 
a917 23					inc hl 
a918 56					ld d, (hl) 
a919 eb					ex de, hl 
a91a			 
a91a			 
a91a				if DEBUG_FORTH_WORDS 
a91a					DMARK "LSt" 
a91a f5				push af  
a91b 3a 2f a9			ld a, (.dmark)  
a91e 32 71 ee			ld (debug_mark),a  
a921 3a 30 a9			ld a, (.dmark+1)  
a924 32 72 ee			ld (debug_mark+1),a  
a927 3a 31 a9			ld a, (.dmark+2)  
a92a 32 73 ee			ld (debug_mark+2),a  
a92d 18 03			jr .pastdmark  
a92f ..			.dmark: db "LSt"  
a932 f1			.pastdmark: pop af  
a933			endm  
# End of macro DMARK
a933					CALLMONITOR 
a933 cd 9d 94			call break_point_state  
a936				endm  
# End of macro CALLMONITOR
a936				endif 
a936			 
a936			; cant push right now due to tokenised strings  
a936			 
a936			; get the destination of where to copy this definition to. 
a936			 
a936 c5					push bc 
a937 d1					pop de 
a938			 
a938 7e			.listl:         ld a,(hl) 
a939 fe 00				cp 0 
a93b 28 09				jr z, .lreplsp     ; replace zero with space 
a93d					;cp FORTH_END_BUFFER 
a93d fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a93f 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a941				 
a941					; just copy this char as is then 
a941			 
a941 12					ld (de), a 
a942			 
a942 23			.listnxt:	inc hl 
a943 13					inc de 
a944 18 f2				jr .listl 
a946			 
a946 3e 20		.lreplsp:	ld a,' ' 
a948 12					ld (de), a 
a949 18 f7				jr .listnxt 
a94b			 
a94b			; close up uword def 
a94b			 
a94b			.listdone: 
a94b 12					ld (de), a 
a94c 13					inc de 
a94d 3e 00				ld a, 0 
a94f 12					ld (de), a 
a950			 
a950			; now have def so clean up and push to stack 
a950			 
a950 21 02 e3				ld hl, scratch 
a953				if DEBUG_FORTH_WORDS 
a953					DMARK "Ltp" 
a953 f5				push af  
a954 3a 68 a9			ld a, (.dmark)  
a957 32 71 ee			ld (debug_mark),a  
a95a 3a 69 a9			ld a, (.dmark+1)  
a95d 32 72 ee			ld (debug_mark+1),a  
a960 3a 6a a9			ld a, (.dmark+2)  
a963 32 73 ee			ld (debug_mark+2),a  
a966 18 03			jr .pastdmark  
a968 ..			.dmark: db "Ltp"  
a96b f1			.pastdmark: pop af  
a96c			endm  
# End of macro DMARK
a96c					CALLMONITOR 
a96c cd 9d 94			call break_point_state  
a96f				endm  
# End of macro CALLMONITOR
a96f				endif 
a96f			 
a96f 18 1f			jr .listpush 
a971			 
a971			;.lnuword:	pop hl 
a971			;		call forth_tok_next 
a971			;		jp .ldouscan  
a971			 
a971			.lunotfound:		  
a971			 
a971				if DEBUG_FORTH_WORDS 
a971					DMARK "LSn" 
a971 f5				push af  
a972 3a 86 a9			ld a, (.dmark)  
a975 32 71 ee			ld (debug_mark),a  
a978 3a 87 a9			ld a, (.dmark+1)  
a97b 32 72 ee			ld (debug_mark+1),a  
a97e 3a 88 a9			ld a, (.dmark+2)  
a981 32 73 ee			ld (debug_mark+2),a  
a984 18 03			jr .pastdmark  
a986 ..			.dmark: db "LSn"  
a989 f1			.pastdmark: pop af  
a98a			endm  
# End of macro DMARK
a98a					CALLMONITOR 
a98a cd 9d 94			call break_point_state  
a98d				endm  
# End of macro CALLMONITOR
a98d				endif 
a98d			 
a98d					 
a98d			;		FORTH_DSP_POP 
a98d			;		ld hl, .luno 
a98d			 
a98d					NEXTW			 
a98d c3 7c 9e			jp macro_next 
a990				endm 
# End of macro NEXTW
a990			 
a990			.listpush: 
a990				if DEBUG_FORTH_WORDS 
a990					DMARK "LS>" 
a990 f5				push af  
a991 3a a5 a9			ld a, (.dmark)  
a994 32 71 ee			ld (debug_mark),a  
a997 3a a6 a9			ld a, (.dmark+1)  
a99a 32 72 ee			ld (debug_mark+1),a  
a99d 3a a7 a9			ld a, (.dmark+2)  
a9a0 32 73 ee			ld (debug_mark+2),a  
a9a3 18 03			jr .pastdmark  
a9a5 ..			.dmark: db "LS>"  
a9a8 f1			.pastdmark: pop af  
a9a9			endm  
# End of macro DMARK
a9a9					CALLMONITOR 
a9a9 cd 9d 94			call break_point_state  
a9ac				endm  
# End of macro CALLMONITOR
a9ac				endif 
a9ac cd 7c 9b				call forth_push_str 
a9af			 
a9af			 
a9af			 
a9af					NEXTW 
a9af c3 7c 9e			jp macro_next 
a9b2				endm 
# End of macro NEXTW
a9b2			 
a9b2			;.luno:    db "Word not found",0 
a9b2			 
a9b2			 
a9b2			 
a9b2			 
a9b2			 
a9b2			;		push hl   ; save pointer to start of uword def string 
a9b2			; 
a9b2			;; look for FORTH_EOL_LINE 
a9b2			;		ld a, FORTH_END_BUFFER 
a9b2			;		call strlent 
a9b2			; 
a9b2			;		inc hl		 ; space for coln def 
a9b2			;		inc hl 
a9b2			;		inc hl          ; space for terms 
a9b2			;		inc hl 
a9b2			; 
a9b2			;		ld a, 20   ; TODO get actual length 
a9b2			;		call addatohl    ; include a random amount of room for the uword name 
a9b2			; 
a9b2			;		 
a9b2			;	if DEBUG_FORTH_WORDS 
a9b2			;		DMARK "Lt1" 
a9b2			;		CALLMONITOR 
a9b2			;	endif 
a9b2			;		 
a9b2			; 
a9b2			;; malloc space for the string because we cant change it 
a9b2			; 
a9b2			;		call malloc 
a9b2			;	if DEBUG_FORTH_MALLOC_GUARD 
a9b2			;		push af 
a9b2			;		call ishlzero 
a9b2			;		pop af 
a9b2			;		 
a9b2			;		call z,malloc_error 
a9b2			;	endif 
a9b2			; 
a9b2			;	if DEBUG_FORTH_WORDS 
a9b2			;		DMARK "Lt2" 
a9b2			;		CALLMONITOR 
a9b2			;	endif 
a9b2			;		pop de 
a9b2			;		push hl    ; push the malloc to release later 
a9b2			;		push hl   ;  push back a copy for the later stack push 
a9b2			;		 
a9b2			;; copy the string swapping out the zero terms for spaces 
a9b2			; 
a9b2			;		; de has our source 
a9b2			;		; hl has our dest 
a9b2			; 
a9b2			;; add the coln def 
a9b2			; 
a9b2			;		ld a, ':' 
a9b2			;		ld (hl), a 
a9b2			;		inc hl 
a9b2			;		ld a, ' ' 
a9b2			;		ld (hl), a 
a9b2			;		inc hl 
a9b2			; 
a9b2			;; add the uname word 
a9b2			;		push de   ; save our string for now 
a9b2			;		ex de, hl 
a9b2			; 
a9b2			;		FORTH_DSP_VALUE 
a9b2			;		;v5 FORTH_DSP_VALUE 
a9b2			; 
a9b2			;		inc hl   ; skip type but we know by now this is OK 
a9b2			; 
a9b2			;.luword:	ld a,(hl) 
a9b2			;		cp 0 
a9b2			;		jr z, .luword2 
a9b2			;		ld (de), a 
a9b2			;		inc de 
a9b2			;		inc hl 
a9b2			;		jr .luword 
a9b2			; 
a9b2			;.luword2:	ld a, ' ' 
a9b2			;		ld (de), a 
a9b2			;;		inc hl 
a9b2			;;		inc de 
a9b2			;;		ld (de), a 
a9b2			;;		inc hl 
a9b2			;		inc de 
a9b2			; 
a9b2			;		ex de, hl 
a9b2			;		pop de 
a9b2			;		 
a9b2			;		 
a9b2			; 
a9b2			;; detoken that string and copy it 
a9b2			; 
a9b2			;	if DEBUG_FORTH_WORDS 
a9b2			;		DMARK "Lt2" 
a9b2			;		CALLMONITOR 
a9b2			;	endif 
a9b2			;.ldetok:	ld a, (de) 
a9b2			;		cp FORTH_END_BUFFER 
a9b2			;		jr z, .ldetokend 
a9b2			;		; swap out any zero term for space 
a9b2			;		cp 0 
a9b2			;		jr nz, .ldetoknext 
a9b2			;		ld a, ' ' 
a9b2			; 
a9b2			;	if DEBUG_FORTH_WORDS 
a9b2			;		DMARK "LtS" 
a9b2			;		CALLMONITOR 
a9b2			;	endif 
a9b2			;.ldetoknext:	ld (hl), a 
a9b2			;		inc de 
a9b2			;		inc hl 
a9b2			;		jr .ldetok 
a9b2			; 
a9b2			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a9b2			;		ld (hl), a  
a9b2			; 
a9b2			;; free that temp malloc 
a9b2			; 
a9b2			;		pop hl    
a9b2			; 
a9b2			;	if DEBUG_FORTH_WORDS 
a9b2			;		DMARK "Lt4" 
a9b2			;		CALLMONITOR 
a9b2			;	endif 
a9b2			;		call forth_apushstrhl 
a9b2			; 
a9b2			;		; get rid of temp malloc area 
a9b2			; 
a9b2			;		pop hl 
a9b2			;		call free 
a9b2			; 
a9b2			;		jr .ludone 
a9b2			; 
a9b2			;.lnuword:	pop hl 
a9b2			;		call forth_tok_next 
a9b2			;		jp .ldouscan  
a9b2			; 
a9b2			;.ludone:		 pop hl 
a9b2			; 
a9b2					NEXTW 
a9b2 c3 7c 9e			jp macro_next 
a9b5				endm 
# End of macro NEXTW
a9b5			 
a9b5			.FORGET: 
a9b5				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a9b5 5d				db WORD_SYS_CORE+73             
a9b6 2e aa			dw .NOP            
a9b8 07				db 6 + 1 
a9b9 .. 00			db "FORGET",0              
a9c0				endm 
# End of macro CWHEAD
a9c0			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a9c0			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
a9c0			; | |  
a9c0			; | | e.g. "MORE" forget 
a9c0					if DEBUG_FORTH_WORDS_KEY 
a9c0						DMARK "FRG" 
a9c0 f5				push af  
a9c1 3a d5 a9			ld a, (.dmark)  
a9c4 32 71 ee			ld (debug_mark),a  
a9c7 3a d6 a9			ld a, (.dmark+1)  
a9ca 32 72 ee			ld (debug_mark+1),a  
a9cd 3a d7 a9			ld a, (.dmark+2)  
a9d0 32 73 ee			ld (debug_mark+2),a  
a9d3 18 03			jr .pastdmark  
a9d5 ..			.dmark: db "FRG"  
a9d8 f1			.pastdmark: pop af  
a9d9			endm  
# End of macro DMARK
a9d9						CALLMONITOR 
a9d9 cd 9d 94			call break_point_state  
a9dc				endm  
# End of macro CALLMONITOR
a9dc					endif 
a9dc			 
a9dc				; find uword 
a9dc			        ; update start of word with "_" 
a9dc				; replace uword with deleted flag 
a9dc			 
a9dc			 
a9dc			;	if DEBUG_FORTH_WORDS 
a9dc			;		DMARK "FOG" 
a9dc			;		CALLMONITOR 
a9dc			;	endif 
a9dc			 
a9dc			 
a9dc					; Get ptr to the word we need to look up 
a9dc			 
a9dc					FORTH_DSP_VALUEHL 
a9dc cd 05 9d			call macro_dsp_valuehl 
a9df				endm 
# End of macro FORTH_DSP_VALUEHL
a9df					;v5 FORTH_DSP_VALUE 
a9df				; TODO type check 
a9df			;		inc hl    ; Skip type check  
a9df e5					push hl 
a9e0 c1					pop bc 
a9e1			;		ex de, hl    ; put into DE 
a9e1			 
a9e1			 
a9e1 21 a6 da				ld hl, baseram 
a9e4					;ld hl, baseusermem 
a9e4			 
a9e4				; skip dict stub 
a9e4			;	call forth_tok_next 
a9e4 e5			push hl   ; sacreifical push 
a9e5			 
a9e5			.fldouscanm: 
a9e5 e1				pop hl 
a9e6			.fldouscan: 
a9e6			;	if DEBUG_FORTH_WORDS 
a9e6			;		DMARK "LSs" 
a9e6			;		CALLMONITOR 
a9e6			;	endif 
a9e6				; skip dict stub 
a9e6 cd cd 9f				call forth_tok_next 
a9e9			 
a9e9			 
a9e9			; while we have words to look for 
a9e9			 
a9e9 7e				ld a, (hl)      
a9ea			;	if DEBUG_FORTH_WORDS 
a9ea			;		DMARK "LSk" 
a9ea			;		CALLMONITOR 
a9ea			;	endif 
a9ea fe 00				cp WORD_SYS_END 
a9ec ca 28 aa				jp z, .flunotfound 
a9ef fe 01				cp WORD_SYS_UWORD 
a9f1 c2 e6 a9				jp nz, .fldouscan 
a9f4			 
a9f4			;	if DEBUG_FORTH_WORDS 
a9f4			;		DMARK "LSu" 
a9f4			;		CALLMONITOR 
a9f4			;	endif 
a9f4			 
a9f4					; found a uword but is it the one we want... 
a9f4			 
a9f4 c5					push bc     ; uword to find is on bc 
a9f5 d1					pop de 
a9f6			 
a9f6 e5					push hl  ; to save the ptr 
a9f7			 
a9f7					; skip opcode 
a9f7 23					inc hl  
a9f8					; skip next ptr 
a9f8 23					inc hl  
a9f9 23					inc hl 
a9fa					; skip len 
a9fa 23					inc hl 
a9fb			 
a9fb			;	if DEBUG_FORTH_WORDS 
a9fb			;		DMARK "LSc" 
a9fb			;		CALLMONITOR 
a9fb			;	endif 
a9fb cd 32 91				call strcmp 
a9fe c2 e5 a9				jp nz, .fldouscanm 
aa01			; 
aa01			; 
aa01			;; while we have words to look for 
aa01			; 
aa01			;.fdouscan:	ld a, (hl)      
aa01			;	if DEBUG_FORTH_WORDS 
aa01			;		DMARK "LSs" 
aa01			;		CALLMONITOR 
aa01			;	endif 
aa01			;		cp WORD_SYS_END 
aa01			;		jp z, .fudone 
aa01			;		cp WORD_SYS_UWORD 
aa01			;		jp nz, .fnuword 
aa01			; 
aa01			;	if DEBUG_FORTH_WORDS 
aa01			;		DMARK "FGu" 
aa01			;		CALLMONITOR 
aa01			;	endif 
aa01			; 
aa01			;		; found a uword but is it the one we want... 
aa01			; 
aa01			; 
aa01			;	        pop de   ; get back the dsp name 
aa01			;		push de 
aa01			; 
aa01			;		push hl  ; to save the ptr 
aa01			; 
aa01			;		; skip opcode 
aa01			;		inc hl  
aa01			;		; skip next ptr 
aa01			;		inc hl  
aa01			;		inc hl 
aa01			;		; skip len 
aa01			;		inc hl 
aa01			; 
aa01			;	if DEBUG_FORTH_WORDS 
aa01			;		DMARK "FGc" 
aa01			;		CALLMONITOR 
aa01			;	endif 
aa01			;		call strcmp 
aa01			;		jp nz, .fnuword 
aa01			 
aa01			 
aa01 e1			pop hl 
aa02			 
aa02				 
aa02				if DEBUG_FORTH_WORDS 
aa02					DMARK "FGm" 
aa02 f5				push af  
aa03 3a 17 aa			ld a, (.dmark)  
aa06 32 71 ee			ld (debug_mark),a  
aa09 3a 18 aa			ld a, (.dmark+1)  
aa0c 32 72 ee			ld (debug_mark+1),a  
aa0f 3a 19 aa			ld a, (.dmark+2)  
aa12 32 73 ee			ld (debug_mark+2),a  
aa15 18 03			jr .pastdmark  
aa17 ..			.dmark: db "FGm"  
aa1a f1			.pastdmark: pop af  
aa1b			endm  
# End of macro DMARK
aa1b					CALLMONITOR 
aa1b cd 9d 94			call break_point_state  
aa1e				endm  
# End of macro CALLMONITOR
aa1e				endif 
aa1e			 
aa1e			 
aa1e			 
aa1e					; we have a uword so push its name to the stack 
aa1e			 
aa1e			;	   	push hl  ; save so we can move to next dict block 
aa1e			;pop hl 
aa1e			 
aa1e					; update opcode to deleted 
aa1e 3e 03				ld a, WORD_SYS_DELETED 
aa20 77					ld (hl), a 
aa21			 
aa21 23					inc hl  
aa22					; skip next ptr 
aa22 23					inc hl  
aa23 23					inc hl 
aa24					; skip len 
aa24 23					inc hl 
aa25			 
aa25					; TODO change parser to skip deleted words but for now mark it out 
aa25 3e 5f				ld a, "_" 
aa27 77					ld  (hl),a 
aa28			 
aa28			;		jr .fudone 
aa28			; 
aa28			;.fnuword:	pop hl 
aa28			;		call forth_tok_next 
aa28			;		jp .fdouscan  
aa28			 
aa28			.flunotfound:		  
aa28			 
aa28			 
aa28					 
aa28					FORTH_DSP_POP 
aa28 cd bd 9d			call macro_forth_dsp_pop 
aa2b				endm 
# End of macro FORTH_DSP_POP
aa2b			;		ld hl, .luno 
aa2b			;.fudone:		 pop hl 
aa2b					NEXTW 
aa2b c3 7c 9e			jp macro_next 
aa2e				endm 
# End of macro NEXTW
aa2e			.NOP: 
aa2e				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
aa2e 61				db WORD_SYS_CORE+77             
aa2f 55 aa			dw .COMO            
aa31 04				db 3 + 1 
aa32 .. 00			db "NOP",0              
aa36				endm 
# End of macro CWHEAD
aa36			; | NOP (  --  ) Do nothing | DONE 
aa36					if DEBUG_FORTH_WORDS_KEY 
aa36						DMARK "NOP" 
aa36 f5				push af  
aa37 3a 4b aa			ld a, (.dmark)  
aa3a 32 71 ee			ld (debug_mark),a  
aa3d 3a 4c aa			ld a, (.dmark+1)  
aa40 32 72 ee			ld (debug_mark+1),a  
aa43 3a 4d aa			ld a, (.dmark+2)  
aa46 32 73 ee			ld (debug_mark+2),a  
aa49 18 03			jr .pastdmark  
aa4b ..			.dmark: db "NOP"  
aa4e f1			.pastdmark: pop af  
aa4f			endm  
# End of macro DMARK
aa4f						CALLMONITOR 
aa4f cd 9d 94			call break_point_state  
aa52				endm  
# End of macro CALLMONITOR
aa52					endif 
aa52				       NEXTW 
aa52 c3 7c 9e			jp macro_next 
aa55				endm 
# End of macro NEXTW
aa55			.COMO: 
aa55				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
aa55 6e				db WORD_SYS_CORE+90             
aa56 a7 aa			dw .COMC            
aa58 02				db 1 + 1 
aa59 .. 00			db "(",0              
aa5b				endm 
# End of macro CWHEAD
aa5b			; | ( ( -- )  Start of comment | DONE 
aa5b			 
aa5b			 
aa5b 2a 03 e6				ld hl, ( os_tok_ptr) 
aa5e 11 a2 aa			ld de, .closepar 
aa61					 
aa61					if DEBUG_FORTH_WORDS 
aa61						DMARK ").." 
aa61 f5				push af  
aa62 3a 76 aa			ld a, (.dmark)  
aa65 32 71 ee			ld (debug_mark),a  
aa68 3a 77 aa			ld a, (.dmark+1)  
aa6b 32 72 ee			ld (debug_mark+1),a  
aa6e 3a 78 aa			ld a, (.dmark+2)  
aa71 32 73 ee			ld (debug_mark+2),a  
aa74 18 03			jr .pastdmark  
aa76 ..			.dmark: db ").."  
aa79 f1			.pastdmark: pop af  
aa7a			endm  
# End of macro DMARK
aa7a						CALLMONITOR 
aa7a cd 9d 94			call break_point_state  
aa7d				endm  
# End of macro CALLMONITOR
aa7d					endif 
aa7d cd 97 9f			call findnexttok  
aa80			 
aa80					if DEBUG_FORTH_WORDS 
aa80						DMARK "IF5" 
aa80 f5				push af  
aa81 3a 95 aa			ld a, (.dmark)  
aa84 32 71 ee			ld (debug_mark),a  
aa87 3a 96 aa			ld a, (.dmark+1)  
aa8a 32 72 ee			ld (debug_mark+1),a  
aa8d 3a 97 aa			ld a, (.dmark+2)  
aa90 32 73 ee			ld (debug_mark+2),a  
aa93 18 03			jr .pastdmark  
aa95 ..			.dmark: db "IF5"  
aa98 f1			.pastdmark: pop af  
aa99			endm  
# End of macro DMARK
aa99						CALLMONITOR 
aa99 cd 9d 94			call break_point_state  
aa9c				endm  
# End of macro CALLMONITOR
aa9c					endif 
aa9c				; replace below with ) exec using tok_ptr 
aa9c 22 03 e6			ld (os_tok_ptr), hl 
aa9f c3 0d 9f			jp exec1 
aaa2			 
aaa2 .. 00			.closepar:   db ")",0 
aaa4			 
aaa4				       NEXTW 
aaa4 c3 7c 9e			jp macro_next 
aaa7				endm 
# End of macro NEXTW
aaa7			.COMC: 
aaa7				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
aaa7 6f				db WORD_SYS_CORE+91             
aaa8 b0 aa			dw .SCRATCH            
aaaa 02				db 1 + 1 
aaab .. 00			db ")",0              
aaad				endm 
# End of macro CWHEAD
aaad			; | ) ( -- )  End of comment |  DONE  
aaad				       NEXTW 
aaad c3 7c 9e			jp macro_next 
aab0				endm 
# End of macro NEXTW
aab0			 
aab0			.SCRATCH: 
aab0				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
aab0 6f				db WORD_SYS_CORE+91             
aab1 eb aa			dw .INC            
aab3 08				db 7 + 1 
aab4 .. 00			db "SCRATCH",0              
aabc				endm 
# End of macro CWHEAD
aabc			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
aabc			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
aabc			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
aabc			; | |  
aabc			; | | e.g.    : score $00 scratch ; 
aabc			; | |  
aabc			; | | $00 score ! 
aabc			; | | $01 score +! 
aabc			; | |  
aabc			; | | e.g.   : varword $0a scratch ;  
aabc			; | | 
aabc			; | | $8000 varword ! 
aabc					if DEBUG_FORTH_WORDS_KEY 
aabc						DMARK "SCR" 
aabc f5				push af  
aabd 3a d1 aa			ld a, (.dmark)  
aac0 32 71 ee			ld (debug_mark),a  
aac3 3a d2 aa			ld a, (.dmark+1)  
aac6 32 72 ee			ld (debug_mark+1),a  
aac9 3a d3 aa			ld a, (.dmark+2)  
aacc 32 73 ee			ld (debug_mark+2),a  
aacf 18 03			jr .pastdmark  
aad1 ..			.dmark: db "SCR"  
aad4 f1			.pastdmark: pop af  
aad5			endm  
# End of macro DMARK
aad5						CALLMONITOR 
aad5 cd 9d 94			call break_point_state  
aad8				endm  
# End of macro CALLMONITOR
aad8					endif 
aad8			 
aad8					FORTH_DSP_VALUEHL 
aad8 cd 05 9d			call macro_dsp_valuehl 
aadb				endm 
# End of macro FORTH_DSP_VALUEHL
aadb				 
aadb					FORTH_DSP_POP 
aadb cd bd 9d			call macro_forth_dsp_pop 
aade				endm 
# End of macro FORTH_DSP_POP
aade			 
aade 7d					ld a, l 
aadf 21 27 e8				ld hl, os_var_array 
aae2 cd 9c 8c				call addatohl 
aae5			 
aae5 cd 0e 9b				call forth_push_numhl 
aae8			 
aae8				       NEXTW 
aae8 c3 7c 9e			jp macro_next 
aaeb				endm 
# End of macro NEXTW
aaeb			 
aaeb			.INC: 
aaeb				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
aaeb 6f				db WORD_SYS_CORE+91             
aaec 3f ab			dw .DEC            
aaee 03				db 2 + 1 
aaef .. 00			db "+!",0              
aaf2				endm 
# End of macro CWHEAD
aaf2			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
aaf2					if DEBUG_FORTH_WORDS_KEY 
aaf2						DMARK "+s_" 
aaf2 f5				push af  
aaf3 3a 07 ab			ld a, (.dmark)  
aaf6 32 71 ee			ld (debug_mark),a  
aaf9 3a 08 ab			ld a, (.dmark+1)  
aafc 32 72 ee			ld (debug_mark+1),a  
aaff 3a 09 ab			ld a, (.dmark+2)  
ab02 32 73 ee			ld (debug_mark+2),a  
ab05 18 03			jr .pastdmark  
ab07 ..			.dmark: db "+s_"  
ab0a f1			.pastdmark: pop af  
ab0b			endm  
# End of macro DMARK
ab0b						CALLMONITOR 
ab0b cd 9d 94			call break_point_state  
ab0e				endm  
# End of macro CALLMONITOR
ab0e					endif 
ab0e			 
ab0e					FORTH_DSP_VALUEHL 
ab0e cd 05 9d			call macro_dsp_valuehl 
ab11				endm 
# End of macro FORTH_DSP_VALUEHL
ab11			 
ab11 e5					push hl   ; save address 
ab12			 
ab12					FORTH_DSP_POP 
ab12 cd bd 9d			call macro_forth_dsp_pop 
ab15				endm 
# End of macro FORTH_DSP_POP
ab15			 
ab15					FORTH_DSP_VALUEHL 
ab15 cd 05 9d			call macro_dsp_valuehl 
ab18				endm 
# End of macro FORTH_DSP_VALUEHL
ab18			 
ab18					FORTH_DSP_POP 
ab18 cd bd 9d			call macro_forth_dsp_pop 
ab1b				endm 
# End of macro FORTH_DSP_POP
ab1b			 
ab1b					; hl contains value to add to byte at a 
ab1b				 
ab1b eb					ex de, hl 
ab1c			 
ab1c e1					pop hl 
ab1d			 
ab1d					if DEBUG_FORTH_WORDS 
ab1d						DMARK "INC" 
ab1d f5				push af  
ab1e 3a 32 ab			ld a, (.dmark)  
ab21 32 71 ee			ld (debug_mark),a  
ab24 3a 33 ab			ld a, (.dmark+1)  
ab27 32 72 ee			ld (debug_mark+1),a  
ab2a 3a 34 ab			ld a, (.dmark+2)  
ab2d 32 73 ee			ld (debug_mark+2),a  
ab30 18 03			jr .pastdmark  
ab32 ..			.dmark: db "INC"  
ab35 f1			.pastdmark: pop af  
ab36			endm  
# End of macro DMARK
ab36						CALLMONITOR 
ab36 cd 9d 94			call break_point_state  
ab39				endm  
# End of macro CALLMONITOR
ab39					endif 
ab39			 
ab39 7e					ld a,(hl) 
ab3a 83					add e 
ab3b 77					ld (hl),a 
ab3c			 
ab3c			 
ab3c			 
ab3c				       NEXTW 
ab3c c3 7c 9e			jp macro_next 
ab3f				endm 
# End of macro NEXTW
ab3f			 
ab3f			.DEC: 
ab3f				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
ab3f 6f				db WORD_SYS_CORE+91             
ab40 90 ab			dw .INC2            
ab42 03				db 2 + 1 
ab43 .. 00			db "-!",0              
ab46				endm 
# End of macro CWHEAD
ab46			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
ab46					if DEBUG_FORTH_WORDS_KEY 
ab46						DMARK "-s_" 
ab46 f5				push af  
ab47 3a 5b ab			ld a, (.dmark)  
ab4a 32 71 ee			ld (debug_mark),a  
ab4d 3a 5c ab			ld a, (.dmark+1)  
ab50 32 72 ee			ld (debug_mark+1),a  
ab53 3a 5d ab			ld a, (.dmark+2)  
ab56 32 73 ee			ld (debug_mark+2),a  
ab59 18 03			jr .pastdmark  
ab5b ..			.dmark: db "-s_"  
ab5e f1			.pastdmark: pop af  
ab5f			endm  
# End of macro DMARK
ab5f						CALLMONITOR 
ab5f cd 9d 94			call break_point_state  
ab62				endm  
# End of macro CALLMONITOR
ab62					endif 
ab62			 
ab62					FORTH_DSP_VALUEHL 
ab62 cd 05 9d			call macro_dsp_valuehl 
ab65				endm 
# End of macro FORTH_DSP_VALUEHL
ab65			 
ab65 e5					push hl   ; save address 
ab66			 
ab66					FORTH_DSP_POP 
ab66 cd bd 9d			call macro_forth_dsp_pop 
ab69				endm 
# End of macro FORTH_DSP_POP
ab69			 
ab69					FORTH_DSP_VALUEHL 
ab69 cd 05 9d			call macro_dsp_valuehl 
ab6c				endm 
# End of macro FORTH_DSP_VALUEHL
ab6c			 
ab6c					; hl contains value to add to byte at a 
ab6c				 
ab6c eb					ex de, hl 
ab6d			 
ab6d e1					pop hl 
ab6e			 
ab6e					if DEBUG_FORTH_WORDS 
ab6e						DMARK "DEC" 
ab6e f5				push af  
ab6f 3a 83 ab			ld a, (.dmark)  
ab72 32 71 ee			ld (debug_mark),a  
ab75 3a 84 ab			ld a, (.dmark+1)  
ab78 32 72 ee			ld (debug_mark+1),a  
ab7b 3a 85 ab			ld a, (.dmark+2)  
ab7e 32 73 ee			ld (debug_mark+2),a  
ab81 18 03			jr .pastdmark  
ab83 ..			.dmark: db "DEC"  
ab86 f1			.pastdmark: pop af  
ab87			endm  
# End of macro DMARK
ab87						CALLMONITOR 
ab87 cd 9d 94			call break_point_state  
ab8a				endm  
# End of macro CALLMONITOR
ab8a					endif 
ab8a			 
ab8a 7e					ld a,(hl) 
ab8b 93					sub e 
ab8c 77					ld (hl),a 
ab8d			 
ab8d			 
ab8d			 
ab8d				       NEXTW 
ab8d c3 7c 9e			jp macro_next 
ab90				endm 
# End of macro NEXTW
ab90			 
ab90			.INC2: 
ab90				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
ab90 6f				db WORD_SYS_CORE+91             
ab91 3a ac			dw .DEC2            
ab93 04				db 3 + 1 
ab94 .. 00			db "+2!",0              
ab98				endm 
# End of macro CWHEAD
ab98			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
ab98			 
ab98					if DEBUG_FORTH_WORDS_KEY 
ab98						DMARK "+2s" 
ab98 f5				push af  
ab99 3a ad ab			ld a, (.dmark)  
ab9c 32 71 ee			ld (debug_mark),a  
ab9f 3a ae ab			ld a, (.dmark+1)  
aba2 32 72 ee			ld (debug_mark+1),a  
aba5 3a af ab			ld a, (.dmark+2)  
aba8 32 73 ee			ld (debug_mark+2),a  
abab 18 03			jr .pastdmark  
abad ..			.dmark: db "+2s"  
abb0 f1			.pastdmark: pop af  
abb1			endm  
# End of macro DMARK
abb1						CALLMONITOR 
abb1 cd 9d 94			call break_point_state  
abb4				endm  
# End of macro CALLMONITOR
abb4					endif 
abb4			 
abb4					; Address 
abb4			 
abb4					FORTH_DSP_VALUEHL 
abb4 cd 05 9d			call macro_dsp_valuehl 
abb7				endm 
# End of macro FORTH_DSP_VALUEHL
abb7			 
abb7 e5					push hl    ; save address 
abb8			 
abb8					; load content into de 
abb8			 
abb8 5e					ld e,(hl) 
abb9 23					inc hl 
abba 56					ld d, (hl) 
abbb			 
abbb					if DEBUG_FORTH_WORDS 
abbb						DMARK "+2a" 
abbb f5				push af  
abbc 3a d0 ab			ld a, (.dmark)  
abbf 32 71 ee			ld (debug_mark),a  
abc2 3a d1 ab			ld a, (.dmark+1)  
abc5 32 72 ee			ld (debug_mark+1),a  
abc8 3a d2 ab			ld a, (.dmark+2)  
abcb 32 73 ee			ld (debug_mark+2),a  
abce 18 03			jr .pastdmark  
abd0 ..			.dmark: db "+2a"  
abd3 f1			.pastdmark: pop af  
abd4			endm  
# End of macro DMARK
abd4						CALLMONITOR 
abd4 cd 9d 94			call break_point_state  
abd7				endm  
# End of macro CALLMONITOR
abd7					endif 
abd7			 
abd7					FORTH_DSP_POP 
abd7 cd bd 9d			call macro_forth_dsp_pop 
abda				endm 
# End of macro FORTH_DSP_POP
abda			 
abda					; Get value to add 
abda			 
abda					FORTH_DSP_VALUE 
abda cd ee 9c			call macro_forth_dsp_value 
abdd				endm 
# End of macro FORTH_DSP_VALUE
abdd			 
abdd					if DEBUG_FORTH_WORDS 
abdd						DMARK "+2v" 
abdd f5				push af  
abde 3a f2 ab			ld a, (.dmark)  
abe1 32 71 ee			ld (debug_mark),a  
abe4 3a f3 ab			ld a, (.dmark+1)  
abe7 32 72 ee			ld (debug_mark+1),a  
abea 3a f4 ab			ld a, (.dmark+2)  
abed 32 73 ee			ld (debug_mark+2),a  
abf0 18 03			jr .pastdmark  
abf2 ..			.dmark: db "+2v"  
abf5 f1			.pastdmark: pop af  
abf6			endm  
# End of macro DMARK
abf6						CALLMONITOR 
abf6 cd 9d 94			call break_point_state  
abf9				endm  
# End of macro CALLMONITOR
abf9					endif 
abf9			 
abf9 19					add hl, de 
abfa			 
abfa					if DEBUG_FORTH_WORDS 
abfa						DMARK "+2+" 
abfa f5				push af  
abfb 3a 0f ac			ld a, (.dmark)  
abfe 32 71 ee			ld (debug_mark),a  
ac01 3a 10 ac			ld a, (.dmark+1)  
ac04 32 72 ee			ld (debug_mark+1),a  
ac07 3a 11 ac			ld a, (.dmark+2)  
ac0a 32 73 ee			ld (debug_mark+2),a  
ac0d 18 03			jr .pastdmark  
ac0f ..			.dmark: db "+2+"  
ac12 f1			.pastdmark: pop af  
ac13			endm  
# End of macro DMARK
ac13						CALLMONITOR 
ac13 cd 9d 94			call break_point_state  
ac16				endm  
# End of macro CALLMONITOR
ac16					endif 
ac16			 
ac16					; move result to de 
ac16			 
ac16 eb					ex de, hl 
ac17			 
ac17					; Address 
ac17			 
ac17 e1					pop hl 
ac18			 
ac18					; save it back 
ac18			 
ac18 73					ld (hl), e 
ac19 23					inc hl 
ac1a 72					ld (hl), d 
ac1b			 
ac1b					if DEBUG_FORTH_WORDS 
ac1b						DMARK "+2e" 
ac1b f5				push af  
ac1c 3a 30 ac			ld a, (.dmark)  
ac1f 32 71 ee			ld (debug_mark),a  
ac22 3a 31 ac			ld a, (.dmark+1)  
ac25 32 72 ee			ld (debug_mark+1),a  
ac28 3a 32 ac			ld a, (.dmark+2)  
ac2b 32 73 ee			ld (debug_mark+2),a  
ac2e 18 03			jr .pastdmark  
ac30 ..			.dmark: db "+2e"  
ac33 f1			.pastdmark: pop af  
ac34			endm  
# End of macro DMARK
ac34						CALLMONITOR 
ac34 cd 9d 94			call break_point_state  
ac37				endm  
# End of macro CALLMONITOR
ac37					endif 
ac37			 
ac37			 
ac37			 
ac37			 
ac37			 
ac37				       NEXTW 
ac37 c3 7c 9e			jp macro_next 
ac3a				endm 
# End of macro NEXTW
ac3a			 
ac3a			.DEC2: 
ac3a				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
ac3a 6f				db WORD_SYS_CORE+91             
ac3b e6 ac			dw .GET2            
ac3d 04				db 3 + 1 
ac3e .. 00			db "-2!",0              
ac42				endm 
# End of macro CWHEAD
ac42			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
ac42			 
ac42			 
ac42					if DEBUG_FORTH_WORDS_KEY 
ac42						DMARK "-2s" 
ac42 f5				push af  
ac43 3a 57 ac			ld a, (.dmark)  
ac46 32 71 ee			ld (debug_mark),a  
ac49 3a 58 ac			ld a, (.dmark+1)  
ac4c 32 72 ee			ld (debug_mark+1),a  
ac4f 3a 59 ac			ld a, (.dmark+2)  
ac52 32 73 ee			ld (debug_mark+2),a  
ac55 18 03			jr .pastdmark  
ac57 ..			.dmark: db "-2s"  
ac5a f1			.pastdmark: pop af  
ac5b			endm  
# End of macro DMARK
ac5b						CALLMONITOR 
ac5b cd 9d 94			call break_point_state  
ac5e				endm  
# End of macro CALLMONITOR
ac5e					endif 
ac5e			 
ac5e					; Address 
ac5e			 
ac5e					FORTH_DSP_VALUEHL 
ac5e cd 05 9d			call macro_dsp_valuehl 
ac61				endm 
# End of macro FORTH_DSP_VALUEHL
ac61			 
ac61 e5					push hl    ; save address 
ac62			 
ac62					; load content into de 
ac62			 
ac62 5e					ld e,(hl) 
ac63 23					inc hl 
ac64 56					ld d, (hl) 
ac65			 
ac65					if DEBUG_FORTH_WORDS 
ac65						DMARK "-2a" 
ac65 f5				push af  
ac66 3a 7a ac			ld a, (.dmark)  
ac69 32 71 ee			ld (debug_mark),a  
ac6c 3a 7b ac			ld a, (.dmark+1)  
ac6f 32 72 ee			ld (debug_mark+1),a  
ac72 3a 7c ac			ld a, (.dmark+2)  
ac75 32 73 ee			ld (debug_mark+2),a  
ac78 18 03			jr .pastdmark  
ac7a ..			.dmark: db "-2a"  
ac7d f1			.pastdmark: pop af  
ac7e			endm  
# End of macro DMARK
ac7e						CALLMONITOR 
ac7e cd 9d 94			call break_point_state  
ac81				endm  
# End of macro CALLMONITOR
ac81					endif 
ac81			 
ac81					FORTH_DSP_POP 
ac81 cd bd 9d			call macro_forth_dsp_pop 
ac84				endm 
# End of macro FORTH_DSP_POP
ac84			 
ac84					; Get value to remove 
ac84			 
ac84					FORTH_DSP_VALUE 
ac84 cd ee 9c			call macro_forth_dsp_value 
ac87				endm 
# End of macro FORTH_DSP_VALUE
ac87			 
ac87					if DEBUG_FORTH_WORDS 
ac87						DMARK "-2v" 
ac87 f5				push af  
ac88 3a 9c ac			ld a, (.dmark)  
ac8b 32 71 ee			ld (debug_mark),a  
ac8e 3a 9d ac			ld a, (.dmark+1)  
ac91 32 72 ee			ld (debug_mark+1),a  
ac94 3a 9e ac			ld a, (.dmark+2)  
ac97 32 73 ee			ld (debug_mark+2),a  
ac9a 18 03			jr .pastdmark  
ac9c ..			.dmark: db "-2v"  
ac9f f1			.pastdmark: pop af  
aca0			endm  
# End of macro DMARK
aca0						CALLMONITOR 
aca0 cd 9d 94			call break_point_state  
aca3				endm  
# End of macro CALLMONITOR
aca3					endif 
aca3			 
aca3 eb					ex de, hl 
aca4 ed 52				sbc hl, de 
aca6			 
aca6					if DEBUG_FORTH_WORDS 
aca6						DMARK "-2d" 
aca6 f5				push af  
aca7 3a bb ac			ld a, (.dmark)  
acaa 32 71 ee			ld (debug_mark),a  
acad 3a bc ac			ld a, (.dmark+1)  
acb0 32 72 ee			ld (debug_mark+1),a  
acb3 3a bd ac			ld a, (.dmark+2)  
acb6 32 73 ee			ld (debug_mark+2),a  
acb9 18 03			jr .pastdmark  
acbb ..			.dmark: db "-2d"  
acbe f1			.pastdmark: pop af  
acbf			endm  
# End of macro DMARK
acbf						CALLMONITOR 
acbf cd 9d 94			call break_point_state  
acc2				endm  
# End of macro CALLMONITOR
acc2					endif 
acc2			 
acc2					; move result to de 
acc2			 
acc2 eb					ex de, hl 
acc3			 
acc3					; Address 
acc3			 
acc3 e1					pop hl 
acc4			 
acc4					; save it back 
acc4			 
acc4 73					ld (hl), e 
acc5 23					inc hl 
acc6 72					ld (hl), d 
acc7			 
acc7					if DEBUG_FORTH_WORDS 
acc7						DMARK "-2e" 
acc7 f5				push af  
acc8 3a dc ac			ld a, (.dmark)  
accb 32 71 ee			ld (debug_mark),a  
acce 3a dd ac			ld a, (.dmark+1)  
acd1 32 72 ee			ld (debug_mark+1),a  
acd4 3a de ac			ld a, (.dmark+2)  
acd7 32 73 ee			ld (debug_mark+2),a  
acda 18 03			jr .pastdmark  
acdc ..			.dmark: db "-2e"  
acdf f1			.pastdmark: pop af  
ace0			endm  
# End of macro DMARK
ace0						CALLMONITOR 
ace0 cd 9d 94			call break_point_state  
ace3				endm  
# End of macro CALLMONITOR
ace3					endif 
ace3			 
ace3			 
ace3			 
ace3			 
ace3			 
ace3				       NEXTW 
ace3 c3 7c 9e			jp macro_next 
ace6				endm 
# End of macro NEXTW
ace6			.GET2: 
ace6				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
ace6 6f				db WORD_SYS_CORE+91             
ace7 16 ad			dw .BANG2            
ace9 03				db 2 + 1 
acea .. 00			db "2@",0              
aced				endm 
# End of macro CWHEAD
aced			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
aced					if DEBUG_FORTH_WORDS_KEY 
aced						DMARK "2A_" 
aced f5				push af  
acee 3a 02 ad			ld a, (.dmark)  
acf1 32 71 ee			ld (debug_mark),a  
acf4 3a 03 ad			ld a, (.dmark+1)  
acf7 32 72 ee			ld (debug_mark+1),a  
acfa 3a 04 ad			ld a, (.dmark+2)  
acfd 32 73 ee			ld (debug_mark+2),a  
ad00 18 03			jr .pastdmark  
ad02 ..			.dmark: db "2A_"  
ad05 f1			.pastdmark: pop af  
ad06			endm  
# End of macro DMARK
ad06						CALLMONITOR 
ad06 cd 9d 94			call break_point_state  
ad09				endm  
# End of macro CALLMONITOR
ad09					endif 
ad09			 
ad09					FORTH_DSP_VALUEHL 
ad09 cd 05 9d			call macro_dsp_valuehl 
ad0c				endm 
# End of macro FORTH_DSP_VALUEHL
ad0c			 
ad0c 5e					ld e, (hl) 
ad0d 23					inc hl 
ad0e 56					ld d, (hl) 
ad0f			 
ad0f eb					ex de, hl 
ad10			 
ad10 cd 0e 9b				call forth_push_numhl 
ad13			 
ad13				       NEXTW 
ad13 c3 7c 9e			jp macro_next 
ad16				endm 
# End of macro NEXTW
ad16			.BANG2: 
ad16				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
ad16 6f				db WORD_SYS_CORE+91             
ad17 4e ad			dw .CONFIG            
ad19 03				db 2 + 1 
ad1a .. 00			db "2!",0              
ad1d				endm 
# End of macro CWHEAD
ad1d			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
ad1d					if DEBUG_FORTH_WORDS_KEY 
ad1d						DMARK "2S_" 
ad1d f5				push af  
ad1e 3a 32 ad			ld a, (.dmark)  
ad21 32 71 ee			ld (debug_mark),a  
ad24 3a 33 ad			ld a, (.dmark+1)  
ad27 32 72 ee			ld (debug_mark+1),a  
ad2a 3a 34 ad			ld a, (.dmark+2)  
ad2d 32 73 ee			ld (debug_mark+2),a  
ad30 18 03			jr .pastdmark  
ad32 ..			.dmark: db "2S_"  
ad35 f1			.pastdmark: pop af  
ad36			endm  
# End of macro DMARK
ad36						CALLMONITOR 
ad36 cd 9d 94			call break_point_state  
ad39				endm  
# End of macro CALLMONITOR
ad39					endif 
ad39			 
ad39					FORTH_DSP_VALUEHL 
ad39 cd 05 9d			call macro_dsp_valuehl 
ad3c				endm 
# End of macro FORTH_DSP_VALUEHL
ad3c			 
ad3c e5					push hl   ; save address 
ad3d			 
ad3d			 
ad3d					FORTH_DSP_POP 
ad3d cd bd 9d			call macro_forth_dsp_pop 
ad40				endm 
# End of macro FORTH_DSP_POP
ad40			 
ad40					 
ad40					FORTH_DSP_VALUEHL 
ad40 cd 05 9d			call macro_dsp_valuehl 
ad43				endm 
# End of macro FORTH_DSP_VALUEHL
ad43			 
ad43					FORTH_DSP_POP 
ad43 cd bd 9d			call macro_forth_dsp_pop 
ad46				endm 
# End of macro FORTH_DSP_POP
ad46			 
ad46 eb					ex de, hl    ; value now in de 
ad47			 
ad47 e1					pop hl 
ad48			 
ad48 73					ld (hl), e 
ad49			 
ad49 23					inc hl 
ad4a			 
ad4a 72					ld (hl), d 
ad4b			 
ad4b			 
ad4b				       NEXTW 
ad4b c3 7c 9e			jp macro_next 
ad4e				endm 
# End of macro NEXTW
ad4e			.CONFIG: 
ad4e				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
ad4e 6f				db WORD_SYS_CORE+91             
ad4f 5f ad			dw .ENDCORE            
ad51 07				db 6 + 1 
ad52 .. 00			db "CONFIG",0              
ad59				endm 
# End of macro CWHEAD
ad59			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
ad59			 
ad59 cd fc 92				call config 
ad5c					NEXTW 
ad5c c3 7c 9e			jp macro_next 
ad5f				endm 
# End of macro NEXTW
ad5f			.ENDCORE: 
ad5f			 
ad5f			; eof 
ad5f			 
ad5f			 
# End of file forth_words_core.asm
ad5f			include "forth_words_flow.asm" 
ad5f			 
ad5f			; | ## Program Flow Words 
ad5f			 
ad5f			.IF: 
ad5f				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ad5f 1e				db WORD_SYS_CORE+10             
ad60 54 ae			dw .THEN            
ad62 03				db 2 + 1 
ad63 .. 00			db "IF",0              
ad66				endm 
# End of macro CWHEAD
ad66			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ad66			; 
ad66					if DEBUG_FORTH_WORDS_KEY 
ad66						DMARK "IF." 
ad66 f5				push af  
ad67 3a 7b ad			ld a, (.dmark)  
ad6a 32 71 ee			ld (debug_mark),a  
ad6d 3a 7c ad			ld a, (.dmark+1)  
ad70 32 72 ee			ld (debug_mark+1),a  
ad73 3a 7d ad			ld a, (.dmark+2)  
ad76 32 73 ee			ld (debug_mark+2),a  
ad79 18 03			jr .pastdmark  
ad7b ..			.dmark: db "IF."  
ad7e f1			.pastdmark: pop af  
ad7f			endm  
# End of macro DMARK
ad7f						CALLMONITOR 
ad7f cd 9d 94			call break_point_state  
ad82				endm  
# End of macro CALLMONITOR
ad82					endif 
ad82			; eval TOS 
ad82			 
ad82				FORTH_DSP_VALUEHL 
ad82 cd 05 9d			call macro_dsp_valuehl 
ad85				endm 
# End of macro FORTH_DSP_VALUEHL
ad85			 
ad85			;	push hl 
ad85				FORTH_DSP_POP 
ad85 cd bd 9d			call macro_forth_dsp_pop 
ad88				endm 
# End of macro FORTH_DSP_POP
ad88			;	pop hl 
ad88			 
ad88					if DEBUG_FORTH_WORDS 
ad88						DMARK "IF1" 
ad88 f5				push af  
ad89 3a 9d ad			ld a, (.dmark)  
ad8c 32 71 ee			ld (debug_mark),a  
ad8f 3a 9e ad			ld a, (.dmark+1)  
ad92 32 72 ee			ld (debug_mark+1),a  
ad95 3a 9f ad			ld a, (.dmark+2)  
ad98 32 73 ee			ld (debug_mark+2),a  
ad9b 18 03			jr .pastdmark  
ad9d ..			.dmark: db "IF1"  
ada0 f1			.pastdmark: pop af  
ada1			endm  
# End of macro DMARK
ada1						CALLMONITOR 
ada1 cd 9d 94			call break_point_state  
ada4				endm  
# End of macro CALLMONITOR
ada4					endif 
ada4 b7				or a        ; clear carry flag 
ada5 11 00 00			ld de, 0 
ada8 eb				ex de,hl 
ada9 ed 52			sbc hl, de 
adab c2 35 ae			jp nz, .iftrue 
adae			 
adae					if DEBUG_FORTH_WORDS 
adae						DMARK "IF2" 
adae f5				push af  
adaf 3a c3 ad			ld a, (.dmark)  
adb2 32 71 ee			ld (debug_mark),a  
adb5 3a c4 ad			ld a, (.dmark+1)  
adb8 32 72 ee			ld (debug_mark+1),a  
adbb 3a c5 ad			ld a, (.dmark+2)  
adbe 32 73 ee			ld (debug_mark+2),a  
adc1 18 03			jr .pastdmark  
adc3 ..			.dmark: db "IF2"  
adc6 f1			.pastdmark: pop af  
adc7			endm  
# End of macro DMARK
adc7						CALLMONITOR 
adc7 cd 9d 94			call break_point_state  
adca				endm  
# End of macro CALLMONITOR
adca					endif 
adca			 
adca			; if not true then skip to THEN 
adca			 
adca				; TODO get tok_ptr 
adca				; TODO consume toks until we get to THEN 
adca			 
adca 2a 03 e6			ld hl, (os_tok_ptr) 
adcd					if DEBUG_FORTH_WORDS 
adcd						DMARK "IF3" 
adcd f5				push af  
adce 3a e2 ad			ld a, (.dmark)  
add1 32 71 ee			ld (debug_mark),a  
add4 3a e3 ad			ld a, (.dmark+1)  
add7 32 72 ee			ld (debug_mark+1),a  
adda 3a e4 ad			ld a, (.dmark+2)  
addd 32 73 ee			ld (debug_mark+2),a  
ade0 18 03			jr .pastdmark  
ade2 ..			.dmark: db "IF3"  
ade5 f1			.pastdmark: pop af  
ade6			endm  
# End of macro DMARK
ade6						CALLMONITOR 
ade6 cd 9d 94			call break_point_state  
ade9				endm  
# End of macro CALLMONITOR
ade9						 
ade9					endif 
ade9 11 30 ae			ld de, .ifthen 
adec					if DEBUG_FORTH_WORDS 
adec						DMARK "IF4" 
adec f5				push af  
aded 3a 01 ae			ld a, (.dmark)  
adf0 32 71 ee			ld (debug_mark),a  
adf3 3a 02 ae			ld a, (.dmark+1)  
adf6 32 72 ee			ld (debug_mark+1),a  
adf9 3a 03 ae			ld a, (.dmark+2)  
adfc 32 73 ee			ld (debug_mark+2),a  
adff 18 03			jr .pastdmark  
ae01 ..			.dmark: db "IF4"  
ae04 f1			.pastdmark: pop af  
ae05			endm  
# End of macro DMARK
ae05						CALLMONITOR 
ae05 cd 9d 94			call break_point_state  
ae08				endm  
# End of macro CALLMONITOR
ae08					endif 
ae08 cd 97 9f			call findnexttok  
ae0b			 
ae0b					if DEBUG_FORTH_WORDS 
ae0b						DMARK "IF5" 
ae0b f5				push af  
ae0c 3a 20 ae			ld a, (.dmark)  
ae0f 32 71 ee			ld (debug_mark),a  
ae12 3a 21 ae			ld a, (.dmark+1)  
ae15 32 72 ee			ld (debug_mark+1),a  
ae18 3a 22 ae			ld a, (.dmark+2)  
ae1b 32 73 ee			ld (debug_mark+2),a  
ae1e 18 03			jr .pastdmark  
ae20 ..			.dmark: db "IF5"  
ae23 f1			.pastdmark: pop af  
ae24			endm  
# End of macro DMARK
ae24						CALLMONITOR 
ae24 cd 9d 94			call break_point_state  
ae27				endm  
# End of macro CALLMONITOR
ae27					endif 
ae27				; TODO replace below with ; exec using tok_ptr 
ae27 22 03 e6			ld (os_tok_ptr), hl 
ae2a c3 0d 9f			jp exec1 
ae2d				NEXTW 
ae2d c3 7c 9e			jp macro_next 
ae30				endm 
# End of macro NEXTW
ae30			 
ae30 .. 00		.ifthen:  db "THEN",0 
ae35			 
ae35			.iftrue:		 
ae35				; Exec next words normally 
ae35			 
ae35				; if true then exec following IF as normal 
ae35					if DEBUG_FORTH_WORDS 
ae35						DMARK "IFT" 
ae35 f5				push af  
ae36 3a 4a ae			ld a, (.dmark)  
ae39 32 71 ee			ld (debug_mark),a  
ae3c 3a 4b ae			ld a, (.dmark+1)  
ae3f 32 72 ee			ld (debug_mark+1),a  
ae42 3a 4c ae			ld a, (.dmark+2)  
ae45 32 73 ee			ld (debug_mark+2),a  
ae48 18 03			jr .pastdmark  
ae4a ..			.dmark: db "IFT"  
ae4d f1			.pastdmark: pop af  
ae4e			endm  
# End of macro DMARK
ae4e						CALLMONITOR 
ae4e cd 9d 94			call break_point_state  
ae51				endm  
# End of macro CALLMONITOR
ae51					endif 
ae51			 
ae51					NEXTW 
ae51 c3 7c 9e			jp macro_next 
ae54				endm 
# End of macro NEXTW
ae54			.THEN: 
ae54				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
ae54 1f				db WORD_SYS_CORE+11             
ae55 7c ae			dw .ELSE            
ae57 05				db 4 + 1 
ae58 .. 00			db "THEN",0              
ae5d				endm 
# End of macro CWHEAD
ae5d			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
ae5d					if DEBUG_FORTH_WORDS_KEY 
ae5d						DMARK "THN" 
ae5d f5				push af  
ae5e 3a 72 ae			ld a, (.dmark)  
ae61 32 71 ee			ld (debug_mark),a  
ae64 3a 73 ae			ld a, (.dmark+1)  
ae67 32 72 ee			ld (debug_mark+1),a  
ae6a 3a 74 ae			ld a, (.dmark+2)  
ae6d 32 73 ee			ld (debug_mark+2),a  
ae70 18 03			jr .pastdmark  
ae72 ..			.dmark: db "THN"  
ae75 f1			.pastdmark: pop af  
ae76			endm  
# End of macro DMARK
ae76						CALLMONITOR 
ae76 cd 9d 94			call break_point_state  
ae79				endm  
# End of macro CALLMONITOR
ae79					endif 
ae79					NEXTW 
ae79 c3 7c 9e			jp macro_next 
ae7c				endm 
# End of macro NEXTW
ae7c			.ELSE: 
ae7c				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
ae7c 20				db WORD_SYS_CORE+12             
ae7d a4 ae			dw .DO            
ae7f 03				db 2 + 1 
ae80 .. 00			db "ELSE",0              
ae85				endm 
# End of macro CWHEAD
ae85			; | ELSE ( -- ) Not supported - does nothing | TODO 
ae85			 
ae85					if DEBUG_FORTH_WORDS_KEY 
ae85						DMARK "ELS" 
ae85 f5				push af  
ae86 3a 9a ae			ld a, (.dmark)  
ae89 32 71 ee			ld (debug_mark),a  
ae8c 3a 9b ae			ld a, (.dmark+1)  
ae8f 32 72 ee			ld (debug_mark+1),a  
ae92 3a 9c ae			ld a, (.dmark+2)  
ae95 32 73 ee			ld (debug_mark+2),a  
ae98 18 03			jr .pastdmark  
ae9a ..			.dmark: db "ELS"  
ae9d f1			.pastdmark: pop af  
ae9e			endm  
# End of macro DMARK
ae9e						CALLMONITOR 
ae9e cd 9d 94			call break_point_state  
aea1				endm  
# End of macro CALLMONITOR
aea1					endif 
aea1			 
aea1			 
aea1					NEXTW 
aea1 c3 7c 9e			jp macro_next 
aea4				endm 
# End of macro NEXTW
aea4			.DO: 
aea4				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
aea4 21				db WORD_SYS_CORE+13             
aea5 cb af			dw .LOOP            
aea7 03				db 2 + 1 
aea8 .. 00			db "DO",0              
aeab				endm 
# End of macro CWHEAD
aeab			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
aeab			 
aeab					if DEBUG_FORTH_WORDS_KEY 
aeab						DMARK "DO." 
aeab f5				push af  
aeac 3a c0 ae			ld a, (.dmark)  
aeaf 32 71 ee			ld (debug_mark),a  
aeb2 3a c1 ae			ld a, (.dmark+1)  
aeb5 32 72 ee			ld (debug_mark+1),a  
aeb8 3a c2 ae			ld a, (.dmark+2)  
aebb 32 73 ee			ld (debug_mark+2),a  
aebe 18 03			jr .pastdmark  
aec0 ..			.dmark: db "DO."  
aec3 f1			.pastdmark: pop af  
aec4			endm  
# End of macro DMARK
aec4						CALLMONITOR 
aec4 cd 9d 94			call break_point_state  
aec7				endm  
# End of macro CALLMONITOR
aec7					endif 
aec7			;  push pc to rsp stack past the DO 
aec7			 
aec7 2a 03 e6				ld hl, (os_tok_ptr) 
aeca 23					inc hl   ; D 
aecb 23					inc hl  ; O 
aecc 23					inc hl   ; null 
aecd					if DEBUG_FORTH_WORDS 
aecd						DMARK "DO2" 
aecd f5				push af  
aece 3a e2 ae			ld a, (.dmark)  
aed1 32 71 ee			ld (debug_mark),a  
aed4 3a e3 ae			ld a, (.dmark+1)  
aed7 32 72 ee			ld (debug_mark+1),a  
aeda 3a e4 ae			ld a, (.dmark+2)  
aedd 32 73 ee			ld (debug_mark+2),a  
aee0 18 03			jr .pastdmark  
aee2 ..			.dmark: db "DO2"  
aee5 f1			.pastdmark: pop af  
aee6			endm  
# End of macro DMARK
aee6						CALLMONITOR 
aee6 cd 9d 94			call break_point_state  
aee9				endm  
# End of macro CALLMONITOR
aee9					endif 
aee9					FORTH_RSP_NEXT 
aee9 cd b5 9a			call macro_forth_rsp_next 
aeec				endm 
# End of macro FORTH_RSP_NEXT
aeec					if DEBUG_FORTH_WORDS 
aeec						DMARK "DO3" 
aeec f5				push af  
aeed 3a 01 af			ld a, (.dmark)  
aef0 32 71 ee			ld (debug_mark),a  
aef3 3a 02 af			ld a, (.dmark+1)  
aef6 32 72 ee			ld (debug_mark+1),a  
aef9 3a 03 af			ld a, (.dmark+2)  
aefc 32 73 ee			ld (debug_mark+2),a  
aeff 18 03			jr .pastdmark  
af01 ..			.dmark: db "DO3"  
af04 f1			.pastdmark: pop af  
af05			endm  
# End of macro DMARK
af05						CALLMONITOR 
af05 cd 9d 94			call break_point_state  
af08				endm  
# End of macro CALLMONITOR
af08					endif 
af08			 
af08					;if DEBUG_FORTH_WORDS 
af08				;		push hl 
af08			;		endif  
af08			 
af08			; get counters from data stack 
af08			 
af08			 
af08					FORTH_DSP_VALUEHL 
af08 cd 05 9d			call macro_dsp_valuehl 
af0b				endm 
# End of macro FORTH_DSP_VALUEHL
af0b e5					push hl		 ; hl now has starting counter which needs to be tos 
af0c			 
af0c					if DEBUG_FORTH_WORDS 
af0c						DMARK "DO4" 
af0c f5				push af  
af0d 3a 21 af			ld a, (.dmark)  
af10 32 71 ee			ld (debug_mark),a  
af13 3a 22 af			ld a, (.dmark+1)  
af16 32 72 ee			ld (debug_mark+1),a  
af19 3a 23 af			ld a, (.dmark+2)  
af1c 32 73 ee			ld (debug_mark+2),a  
af1f 18 03			jr .pastdmark  
af21 ..			.dmark: db "DO4"  
af24 f1			.pastdmark: pop af  
af25			endm  
# End of macro DMARK
af25						CALLMONITOR 
af25 cd 9d 94			call break_point_state  
af28				endm  
# End of macro CALLMONITOR
af28					endif 
af28					FORTH_DSP_POP 
af28 cd bd 9d			call macro_forth_dsp_pop 
af2b				endm 
# End of macro FORTH_DSP_POP
af2b			 
af2b					if DEBUG_FORTH_WORDS 
af2b						DMARK "DO5" 
af2b f5				push af  
af2c 3a 40 af			ld a, (.dmark)  
af2f 32 71 ee			ld (debug_mark),a  
af32 3a 41 af			ld a, (.dmark+1)  
af35 32 72 ee			ld (debug_mark+1),a  
af38 3a 42 af			ld a, (.dmark+2)  
af3b 32 73 ee			ld (debug_mark+2),a  
af3e 18 03			jr .pastdmark  
af40 ..			.dmark: db "DO5"  
af43 f1			.pastdmark: pop af  
af44			endm  
# End of macro DMARK
af44						CALLMONITOR 
af44 cd 9d 94			call break_point_state  
af47				endm  
# End of macro CALLMONITOR
af47					endif 
af47			 
af47					FORTH_DSP_VALUEHL 
af47 cd 05 9d			call macro_dsp_valuehl 
af4a				endm 
# End of macro FORTH_DSP_VALUEHL
af4a			;		push hl		 ; hl now has starting limit counter 
af4a			 
af4a					if DEBUG_FORTH_WORDS 
af4a						DMARK "DO6" 
af4a f5				push af  
af4b 3a 5f af			ld a, (.dmark)  
af4e 32 71 ee			ld (debug_mark),a  
af51 3a 60 af			ld a, (.dmark+1)  
af54 32 72 ee			ld (debug_mark+1),a  
af57 3a 61 af			ld a, (.dmark+2)  
af5a 32 73 ee			ld (debug_mark+2),a  
af5d 18 03			jr .pastdmark  
af5f ..			.dmark: db "DO6"  
af62 f1			.pastdmark: pop af  
af63			endm  
# End of macro DMARK
af63						CALLMONITOR 
af63 cd 9d 94			call break_point_state  
af66				endm  
# End of macro CALLMONITOR
af66					endif 
af66					FORTH_DSP_POP 
af66 cd bd 9d			call macro_forth_dsp_pop 
af69				endm 
# End of macro FORTH_DSP_POP
af69			 
af69			; put counters on the loop stack 
af69			 
af69			;		pop hl			 ; limit counter 
af69 d1					pop de			; start counter 
af6a			 
af6a					; push limit counter 
af6a			 
af6a					if DEBUG_FORTH_WORDS 
af6a						DMARK "DO7" 
af6a f5				push af  
af6b 3a 7f af			ld a, (.dmark)  
af6e 32 71 ee			ld (debug_mark),a  
af71 3a 80 af			ld a, (.dmark+1)  
af74 32 72 ee			ld (debug_mark+1),a  
af77 3a 81 af			ld a, (.dmark+2)  
af7a 32 73 ee			ld (debug_mark+2),a  
af7d 18 03			jr .pastdmark  
af7f ..			.dmark: db "DO7"  
af82 f1			.pastdmark: pop af  
af83			endm  
# End of macro DMARK
af83						CALLMONITOR 
af83 cd 9d 94			call break_point_state  
af86				endm  
# End of macro CALLMONITOR
af86					endif 
af86					FORTH_LOOP_NEXT 
af86 cd 36 9d			call macro_forth_loop_next 
af89				endm 
# End of macro FORTH_LOOP_NEXT
af89			 
af89					; push start counter 
af89			 
af89 eb					ex de, hl 
af8a					if DEBUG_FORTH_WORDS 
af8a						DMARK "DO7" 
af8a f5				push af  
af8b 3a 9f af			ld a, (.dmark)  
af8e 32 71 ee			ld (debug_mark),a  
af91 3a a0 af			ld a, (.dmark+1)  
af94 32 72 ee			ld (debug_mark+1),a  
af97 3a a1 af			ld a, (.dmark+2)  
af9a 32 73 ee			ld (debug_mark+2),a  
af9d 18 03			jr .pastdmark  
af9f ..			.dmark: db "DO7"  
afa2 f1			.pastdmark: pop af  
afa3			endm  
# End of macro DMARK
afa3						CALLMONITOR 
afa3 cd 9d 94			call break_point_state  
afa6				endm  
# End of macro CALLMONITOR
afa6					endif 
afa6					FORTH_LOOP_NEXT 
afa6 cd 36 9d			call macro_forth_loop_next 
afa9				endm 
# End of macro FORTH_LOOP_NEXT
afa9			 
afa9			 
afa9					; init first round of I counter 
afa9			 
afa9 22 27 e6				ld (os_current_i), hl 
afac			 
afac					if DEBUG_FORTH_WORDS 
afac						DMARK "DO8" 
afac f5				push af  
afad 3a c1 af			ld a, (.dmark)  
afb0 32 71 ee			ld (debug_mark),a  
afb3 3a c2 af			ld a, (.dmark+1)  
afb6 32 72 ee			ld (debug_mark+1),a  
afb9 3a c3 af			ld a, (.dmark+2)  
afbc 32 73 ee			ld (debug_mark+2),a  
afbf 18 03			jr .pastdmark  
afc1 ..			.dmark: db "DO8"  
afc4 f1			.pastdmark: pop af  
afc5			endm  
# End of macro DMARK
afc5						CALLMONITOR 
afc5 cd 9d 94			call break_point_state  
afc8				endm  
# End of macro CALLMONITOR
afc8					endif 
afc8			 
afc8					NEXTW 
afc8 c3 7c 9e			jp macro_next 
afcb				endm 
# End of macro NEXTW
afcb			.LOOP: 
afcb				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
afcb 22				db WORD_SYS_CORE+14             
afcc e3 b0			dw .I            
afce 05				db 4 + 1 
afcf .. 00			db "LOOP",0              
afd4				endm 
# End of macro CWHEAD
afd4			; | LOOP ( -- ) Increment and test loop counter  | DONE 
afd4			 
afd4				; pop tos as current loop count to hl 
afd4			 
afd4				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
afd4			 
afd4				FORTH_LOOP_TOS 
afd4 cd 69 9d			call macro_forth_loop_tos 
afd7				endm 
# End of macro FORTH_LOOP_TOS
afd7 e5				push hl 
afd8			 
afd8					if DEBUG_FORTH_WORDS_KEY 
afd8						DMARK "LOP" 
afd8 f5				push af  
afd9 3a ed af			ld a, (.dmark)  
afdc 32 71 ee			ld (debug_mark),a  
afdf 3a ee af			ld a, (.dmark+1)  
afe2 32 72 ee			ld (debug_mark+1),a  
afe5 3a ef af			ld a, (.dmark+2)  
afe8 32 73 ee			ld (debug_mark+2),a  
afeb 18 03			jr .pastdmark  
afed ..			.dmark: db "LOP"  
aff0 f1			.pastdmark: pop af  
aff1			endm  
# End of macro DMARK
aff1						CALLMONITOR 
aff1 cd 9d 94			call break_point_state  
aff4				endm  
# End of macro CALLMONITOR
aff4					endif 
aff4				; next item on the stack is the limit. get it 
aff4			 
aff4			 
aff4				FORTH_LOOP_POP 
aff4 cd 73 9d			call macro_forth_loop_pop 
aff7				endm 
# End of macro FORTH_LOOP_POP
aff7			 
aff7				FORTH_LOOP_TOS 
aff7 cd 69 9d			call macro_forth_loop_tos 
affa				endm 
# End of macro FORTH_LOOP_TOS
affa			 
affa d1				pop de		 ; de = i, hl = limit 
affb			 
affb					if DEBUG_FORTH_WORDS 
affb						DMARK "LP1" 
affb f5				push af  
affc 3a 10 b0			ld a, (.dmark)  
afff 32 71 ee			ld (debug_mark),a  
b002 3a 11 b0			ld a, (.dmark+1)  
b005 32 72 ee			ld (debug_mark+1),a  
b008 3a 12 b0			ld a, (.dmark+2)  
b00b 32 73 ee			ld (debug_mark+2),a  
b00e 18 03			jr .pastdmark  
b010 ..			.dmark: db "LP1"  
b013 f1			.pastdmark: pop af  
b014			endm  
# End of macro DMARK
b014						CALLMONITOR 
b014 cd 9d 94			call break_point_state  
b017				endm  
# End of macro CALLMONITOR
b017					endif 
b017			 
b017				; go back to previous word 
b017			 
b017 d5				push de    ; save I for inc later 
b018			 
b018			 
b018				; get limit 
b018				;  is I at limit? 
b018			 
b018			 
b018					if DEBUG_FORTH_WORDS 
b018						DMARK "LP1" 
b018 f5				push af  
b019 3a 2d b0			ld a, (.dmark)  
b01c 32 71 ee			ld (debug_mark),a  
b01f 3a 2e b0			ld a, (.dmark+1)  
b022 32 72 ee			ld (debug_mark+1),a  
b025 3a 2f b0			ld a, (.dmark+2)  
b028 32 73 ee			ld (debug_mark+2),a  
b02b 18 03			jr .pastdmark  
b02d ..			.dmark: db "LP1"  
b030 f1			.pastdmark: pop af  
b031			endm  
# End of macro DMARK
b031						CALLMONITOR 
b031 cd 9d 94			call break_point_state  
b034				endm  
# End of macro CALLMONITOR
b034					endif 
b034			 
b034 ed 52			sbc hl, de 
b036			 
b036			 
b036				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b036			 
b036 20 26				jr nz, .loopnotdone 
b038			 
b038 e1				pop hl   ; get rid of saved I 
b039				FORTH_LOOP_POP     ; get rid of limit 
b039 cd 73 9d			call macro_forth_loop_pop 
b03c				endm 
# End of macro FORTH_LOOP_POP
b03c			 
b03c				FORTH_RSP_POP     ; get rid of DO ptr 
b03c cd d6 9a			call macro_forth_rsp_pop 
b03f				endm 
# End of macro FORTH_RSP_POP
b03f			 
b03f			if DEBUG_FORTH_WORDS 
b03f						DMARK "LP>" 
b03f f5				push af  
b040 3a 54 b0			ld a, (.dmark)  
b043 32 71 ee			ld (debug_mark),a  
b046 3a 55 b0			ld a, (.dmark+1)  
b049 32 72 ee			ld (debug_mark+1),a  
b04c 3a 56 b0			ld a, (.dmark+2)  
b04f 32 73 ee			ld (debug_mark+2),a  
b052 18 03			jr .pastdmark  
b054 ..			.dmark: db "LP>"  
b057 f1			.pastdmark: pop af  
b058			endm  
# End of macro DMARK
b058				CALLMONITOR 
b058 cd 9d 94			call break_point_state  
b05b				endm  
# End of macro CALLMONITOR
b05b			endif 
b05b			 
b05b					NEXTW 
b05b c3 7c 9e			jp macro_next 
b05e				endm 
# End of macro NEXTW
b05e				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b05e			 
b05e			.loopnotdone: 
b05e			 
b05e e1				pop hl    ; get I 
b05f 23				inc hl 
b060			 
b060			   	; save new I 
b060			 
b060			 
b060					; set I counter 
b060			 
b060 22 27 e6				ld (os_current_i), hl 
b063			 
b063					if DEBUG_FORTH_WORDS 
b063						DMARK "LPN" 
b063 f5				push af  
b064 3a 78 b0			ld a, (.dmark)  
b067 32 71 ee			ld (debug_mark),a  
b06a 3a 79 b0			ld a, (.dmark+1)  
b06d 32 72 ee			ld (debug_mark+1),a  
b070 3a 7a b0			ld a, (.dmark+2)  
b073 32 73 ee			ld (debug_mark+2),a  
b076 18 03			jr .pastdmark  
b078 ..			.dmark: db "LPN"  
b07b f1			.pastdmark: pop af  
b07c			endm  
# End of macro DMARK
b07c					CALLMONITOR 
b07c cd 9d 94			call break_point_state  
b07f				endm  
# End of macro CALLMONITOR
b07f					endif 
b07f					 
b07f				FORTH_LOOP_NEXT 
b07f cd 36 9d			call macro_forth_loop_next 
b082				endm 
# End of macro FORTH_LOOP_NEXT
b082			 
b082			 
b082					if DEBUG_FORTH_WORDS 
b082 eb						ex de,hl 
b083					endif 
b083			 
b083			;	; get DO ptr 
b083			; 
b083					if DEBUG_FORTH_WORDS 
b083						DMARK "LP7" 
b083 f5				push af  
b084 3a 98 b0			ld a, (.dmark)  
b087 32 71 ee			ld (debug_mark),a  
b08a 3a 99 b0			ld a, (.dmark+1)  
b08d 32 72 ee			ld (debug_mark+1),a  
b090 3a 9a b0			ld a, (.dmark+2)  
b093 32 73 ee			ld (debug_mark+2),a  
b096 18 03			jr .pastdmark  
b098 ..			.dmark: db "LP7"  
b09b f1			.pastdmark: pop af  
b09c			endm  
# End of macro DMARK
b09c					CALLMONITOR 
b09c cd 9d 94			call break_point_state  
b09f				endm  
# End of macro CALLMONITOR
b09f					endif 
b09f				FORTH_RSP_TOS 
b09f cd cc 9a			call macro_forth_rsp_tos 
b0a2				endm 
# End of macro FORTH_RSP_TOS
b0a2			 
b0a2					if DEBUG_FORTH_WORDS 
b0a2						DMARK "LP8" 
b0a2 f5				push af  
b0a3 3a b7 b0			ld a, (.dmark)  
b0a6 32 71 ee			ld (debug_mark),a  
b0a9 3a b8 b0			ld a, (.dmark+1)  
b0ac 32 72 ee			ld (debug_mark+1),a  
b0af 3a b9 b0			ld a, (.dmark+2)  
b0b2 32 73 ee			ld (debug_mark+2),a  
b0b5 18 03			jr .pastdmark  
b0b7 ..			.dmark: db "LP8"  
b0ba f1			.pastdmark: pop af  
b0bb			endm  
# End of macro DMARK
b0bb					CALLMONITOR 
b0bb cd 9d 94			call break_point_state  
b0be				endm  
# End of macro CALLMONITOR
b0be					endif 
b0be				;push hl 
b0be			 
b0be				; not going to DO any more 
b0be				; get rid of the RSP pointer as DO will add it back in 
b0be				;FORTH_RSP_POP 
b0be				;pop hl 
b0be			 
b0be				;ld hl,(cli_ret_sp) 
b0be				;ld e, (hl) 
b0be				;inc hl 
b0be				;ld d, (hl) 
b0be				;ex de,hl 
b0be 22 03 e6			ld (os_tok_ptr), hl 
b0c1					if DEBUG_FORTH_WORDS 
b0c1						DMARK "LP<" 
b0c1 f5				push af  
b0c2 3a d6 b0			ld a, (.dmark)  
b0c5 32 71 ee			ld (debug_mark),a  
b0c8 3a d7 b0			ld a, (.dmark+1)  
b0cb 32 72 ee			ld (debug_mark+1),a  
b0ce 3a d8 b0			ld a, (.dmark+2)  
b0d1 32 73 ee			ld (debug_mark+2),a  
b0d4 18 03			jr .pastdmark  
b0d6 ..			.dmark: db "LP<"  
b0d9 f1			.pastdmark: pop af  
b0da			endm  
# End of macro DMARK
b0da					CALLMONITOR 
b0da cd 9d 94			call break_point_state  
b0dd				endm  
# End of macro CALLMONITOR
b0dd				endif 
b0dd c3 0d 9f			jp exec1 
b0e0			 
b0e0					 
b0e0			 
b0e0			 
b0e0					NEXTW 
b0e0 c3 7c 9e			jp macro_next 
b0e3				endm 
# End of macro NEXTW
b0e3			.I:  
b0e3			 
b0e3				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
b0e3 5e				db WORD_SYS_CORE+74             
b0e4 0e b1			dw .DLOOP            
b0e6 02				db 1 + 1 
b0e7 .. 00			db "I",0              
b0e9				endm 
# End of macro CWHEAD
b0e9			; | I ( -- ) Current loop counter | DONE 
b0e9					if DEBUG_FORTH_WORDS_KEY 
b0e9						DMARK "I.." 
b0e9 f5				push af  
b0ea 3a fe b0			ld a, (.dmark)  
b0ed 32 71 ee			ld (debug_mark),a  
b0f0 3a ff b0			ld a, (.dmark+1)  
b0f3 32 72 ee			ld (debug_mark+1),a  
b0f6 3a 00 b1			ld a, (.dmark+2)  
b0f9 32 73 ee			ld (debug_mark+2),a  
b0fc 18 03			jr .pastdmark  
b0fe ..			.dmark: db "I.."  
b101 f1			.pastdmark: pop af  
b102			endm  
# End of macro DMARK
b102						CALLMONITOR 
b102 cd 9d 94			call break_point_state  
b105				endm  
# End of macro CALLMONITOR
b105					endif 
b105			 
b105 2a 27 e6				ld hl,(os_current_i) 
b108 cd 0e 9b				call forth_push_numhl 
b10b			 
b10b					NEXTW 
b10b c3 7c 9e			jp macro_next 
b10e				endm 
# End of macro NEXTW
b10e			.DLOOP: 
b10e				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
b10e 5f				db WORD_SYS_CORE+75             
b10f ef b1			dw .REPEAT            
b111 06				db 5 + 1 
b112 .. 00			db "-LOOP",0              
b118				endm 
# End of macro CWHEAD
b118			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
b118				; pop tos as current loop count to hl 
b118					if DEBUG_FORTH_WORDS_KEY 
b118						DMARK "-LP" 
b118 f5				push af  
b119 3a 2d b1			ld a, (.dmark)  
b11c 32 71 ee			ld (debug_mark),a  
b11f 3a 2e b1			ld a, (.dmark+1)  
b122 32 72 ee			ld (debug_mark+1),a  
b125 3a 2f b1			ld a, (.dmark+2)  
b128 32 73 ee			ld (debug_mark+2),a  
b12b 18 03			jr .pastdmark  
b12d ..			.dmark: db "-LP"  
b130 f1			.pastdmark: pop af  
b131			endm  
# End of macro DMARK
b131						CALLMONITOR 
b131 cd 9d 94			call break_point_state  
b134				endm  
# End of macro CALLMONITOR
b134					endif 
b134			 
b134				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b134			 
b134				FORTH_LOOP_TOS 
b134 cd 69 9d			call macro_forth_loop_tos 
b137				endm 
# End of macro FORTH_LOOP_TOS
b137 e5				push hl 
b138			 
b138					if DEBUG_FORTH_WORDS 
b138						DMARK "-LP" 
b138 f5				push af  
b139 3a 4d b1			ld a, (.dmark)  
b13c 32 71 ee			ld (debug_mark),a  
b13f 3a 4e b1			ld a, (.dmark+1)  
b142 32 72 ee			ld (debug_mark+1),a  
b145 3a 4f b1			ld a, (.dmark+2)  
b148 32 73 ee			ld (debug_mark+2),a  
b14b 18 03			jr .pastdmark  
b14d ..			.dmark: db "-LP"  
b150 f1			.pastdmark: pop af  
b151			endm  
# End of macro DMARK
b151						CALLMONITOR 
b151 cd 9d 94			call break_point_state  
b154				endm  
# End of macro CALLMONITOR
b154					endif 
b154				; next item on the stack is the limit. get it 
b154			 
b154			 
b154				FORTH_LOOP_POP 
b154 cd 73 9d			call macro_forth_loop_pop 
b157				endm 
# End of macro FORTH_LOOP_POP
b157			 
b157				FORTH_LOOP_TOS 
b157 cd 69 9d			call macro_forth_loop_tos 
b15a				endm 
# End of macro FORTH_LOOP_TOS
b15a			 
b15a d1				pop de		 ; de = i, hl = limit 
b15b			 
b15b					if DEBUG_FORTH_WORDS 
b15b						DMARK "-L1" 
b15b f5				push af  
b15c 3a 70 b1			ld a, (.dmark)  
b15f 32 71 ee			ld (debug_mark),a  
b162 3a 71 b1			ld a, (.dmark+1)  
b165 32 72 ee			ld (debug_mark+1),a  
b168 3a 72 b1			ld a, (.dmark+2)  
b16b 32 73 ee			ld (debug_mark+2),a  
b16e 18 03			jr .pastdmark  
b170 ..			.dmark: db "-L1"  
b173 f1			.pastdmark: pop af  
b174			endm  
# End of macro DMARK
b174						CALLMONITOR 
b174 cd 9d 94			call break_point_state  
b177				endm  
# End of macro CALLMONITOR
b177					endif 
b177			 
b177				; go back to previous word 
b177			 
b177 d5				push de    ; save I for inc later 
b178			 
b178			 
b178				; get limit 
b178				;  is I at limit? 
b178			 
b178			 
b178					if DEBUG_FORTH_WORDS 
b178						DMARK "-L1" 
b178 f5				push af  
b179 3a 8d b1			ld a, (.dmark)  
b17c 32 71 ee			ld (debug_mark),a  
b17f 3a 8e b1			ld a, (.dmark+1)  
b182 32 72 ee			ld (debug_mark+1),a  
b185 3a 8f b1			ld a, (.dmark+2)  
b188 32 73 ee			ld (debug_mark+2),a  
b18b 18 03			jr .pastdmark  
b18d ..			.dmark: db "-L1"  
b190 f1			.pastdmark: pop af  
b191			endm  
# End of macro DMARK
b191						CALLMONITOR 
b191 cd 9d 94			call break_point_state  
b194				endm  
# End of macro CALLMONITOR
b194					endif 
b194			 
b194 ed 52			sbc hl, de 
b196			 
b196			 
b196				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
b196			 
b196 20 26				jr nz, .mloopnotdone 
b198			 
b198 e1				pop hl   ; get rid of saved I 
b199				FORTH_LOOP_POP     ; get rid of limit 
b199 cd 73 9d			call macro_forth_loop_pop 
b19c				endm 
# End of macro FORTH_LOOP_POP
b19c			 
b19c				FORTH_RSP_POP     ; get rid of DO ptr 
b19c cd d6 9a			call macro_forth_rsp_pop 
b19f				endm 
# End of macro FORTH_RSP_POP
b19f			 
b19f			if DEBUG_FORTH_WORDS 
b19f						DMARK "-L>" 
b19f f5				push af  
b1a0 3a b4 b1			ld a, (.dmark)  
b1a3 32 71 ee			ld (debug_mark),a  
b1a6 3a b5 b1			ld a, (.dmark+1)  
b1a9 32 72 ee			ld (debug_mark+1),a  
b1ac 3a b6 b1			ld a, (.dmark+2)  
b1af 32 73 ee			ld (debug_mark+2),a  
b1b2 18 03			jr .pastdmark  
b1b4 ..			.dmark: db "-L>"  
b1b7 f1			.pastdmark: pop af  
b1b8			endm  
# End of macro DMARK
b1b8				CALLMONITOR 
b1b8 cd 9d 94			call break_point_state  
b1bb				endm  
# End of macro CALLMONITOR
b1bb			endif 
b1bb			 
b1bb					NEXTW 
b1bb c3 7c 9e			jp macro_next 
b1be				endm 
# End of macro NEXTW
b1be				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b1be			 
b1be			.mloopnotdone: 
b1be			 
b1be e1				pop hl    ; get I 
b1bf 2b				dec hl 
b1c0			 
b1c0			   	; save new I 
b1c0			 
b1c0			 
b1c0					; set I counter 
b1c0			 
b1c0 22 27 e6				ld (os_current_i), hl 
b1c3			 
b1c3					 
b1c3				FORTH_LOOP_NEXT 
b1c3 cd 36 9d			call macro_forth_loop_next 
b1c6				endm 
# End of macro FORTH_LOOP_NEXT
b1c6			 
b1c6			 
b1c6					if DEBUG_FORTH_WORDS 
b1c6 eb						ex de,hl 
b1c7					endif 
b1c7			 
b1c7			;	; get DO ptr 
b1c7			; 
b1c7				FORTH_RSP_TOS 
b1c7 cd cc 9a			call macro_forth_rsp_tos 
b1ca				endm 
# End of macro FORTH_RSP_TOS
b1ca			 
b1ca				;push hl 
b1ca			 
b1ca				; not going to DO any more 
b1ca				; get rid of the RSP pointer as DO will add it back in 
b1ca				;FORTH_RSP_POP 
b1ca				;pop hl 
b1ca			 
b1ca			 
b1ca 22 03 e6			ld (os_tok_ptr), hl 
b1cd					if DEBUG_FORTH_WORDS 
b1cd						DMARK "-L<" 
b1cd f5				push af  
b1ce 3a e2 b1			ld a, (.dmark)  
b1d1 32 71 ee			ld (debug_mark),a  
b1d4 3a e3 b1			ld a, (.dmark+1)  
b1d7 32 72 ee			ld (debug_mark+1),a  
b1da 3a e4 b1			ld a, (.dmark+2)  
b1dd 32 73 ee			ld (debug_mark+2),a  
b1e0 18 03			jr .pastdmark  
b1e2 ..			.dmark: db "-L<"  
b1e5 f1			.pastdmark: pop af  
b1e6			endm  
# End of macro DMARK
b1e6					CALLMONITOR 
b1e6 cd 9d 94			call break_point_state  
b1e9				endm  
# End of macro CALLMONITOR
b1e9				endif 
b1e9 c3 0d 9f			jp exec1 
b1ec			 
b1ec					 
b1ec			 
b1ec			 
b1ec			 
b1ec				NEXTW 
b1ec c3 7c 9e			jp macro_next 
b1ef				endm 
# End of macro NEXTW
b1ef			 
b1ef			 
b1ef			 
b1ef			 
b1ef			.REPEAT: 
b1ef				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
b1ef 71				db WORD_SYS_CORE+93             
b1f0 42 b2			dw .UNTIL            
b1f2 06				db 5 + 1 
b1f3 .. 00			db "REPEAT",0              
b1fa				endm 
# End of macro CWHEAD
b1fa			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
b1fa			;  push pc to rsp stack past the REPEAT 
b1fa					if DEBUG_FORTH_WORDS_KEY 
b1fa						DMARK "REP" 
b1fa f5				push af  
b1fb 3a 0f b2			ld a, (.dmark)  
b1fe 32 71 ee			ld (debug_mark),a  
b201 3a 10 b2			ld a, (.dmark+1)  
b204 32 72 ee			ld (debug_mark+1),a  
b207 3a 11 b2			ld a, (.dmark+2)  
b20a 32 73 ee			ld (debug_mark+2),a  
b20d 18 03			jr .pastdmark  
b20f ..			.dmark: db "REP"  
b212 f1			.pastdmark: pop af  
b213			endm  
# End of macro DMARK
b213						CALLMONITOR 
b213 cd 9d 94			call break_point_state  
b216				endm  
# End of macro CALLMONITOR
b216					endif 
b216			 
b216 2a 03 e6				ld hl, (os_tok_ptr) 
b219 23					inc hl   ; R 
b21a 23					inc hl  ; E 
b21b 23					inc hl   ; P 
b21c 23					inc hl   ; E 
b21d 23					inc hl   ; A 
b21e 23					inc hl   ; T 
b21f 23					inc hl   ; zero 
b220					FORTH_RSP_NEXT 
b220 cd b5 9a			call macro_forth_rsp_next 
b223				endm 
# End of macro FORTH_RSP_NEXT
b223			 
b223			 
b223					if DEBUG_FORTH_WORDS 
b223						DMARK "REP" 
b223 f5				push af  
b224 3a 38 b2			ld a, (.dmark)  
b227 32 71 ee			ld (debug_mark),a  
b22a 3a 39 b2			ld a, (.dmark+1)  
b22d 32 72 ee			ld (debug_mark+1),a  
b230 3a 3a b2			ld a, (.dmark+2)  
b233 32 73 ee			ld (debug_mark+2),a  
b236 18 03			jr .pastdmark  
b238 ..			.dmark: db "REP"  
b23b f1			.pastdmark: pop af  
b23c			endm  
# End of macro DMARK
b23c						;pop bc    ; TODO BUG ?????? what is this for???? 
b23c						CALLMONITOR 
b23c cd 9d 94			call break_point_state  
b23f				endm  
# End of macro CALLMONITOR
b23f					endif 
b23f			 
b23f					NEXTW 
b23f c3 7c 9e			jp macro_next 
b242				endm 
# End of macro NEXTW
b242			;	       NEXTW 
b242			 
b242			.UNTIL: 
b242				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b242 72				db WORD_SYS_CORE+94             
b243 d9 b2			dw .ENDFLOW            
b245 06				db 5 + 1 
b246 .. 00			db "UNTIL",0              
b24c				endm 
# End of macro CWHEAD
b24c			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b24c			 
b24c				; pop tos as check 
b24c			 
b24c				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b24c			 
b24c				FORTH_DSP_VALUEHL 
b24c cd 05 9d			call macro_dsp_valuehl 
b24f				endm 
# End of macro FORTH_DSP_VALUEHL
b24f			 
b24f					if DEBUG_FORTH_WORDS_KEY 
b24f						DMARK "UNT" 
b24f f5				push af  
b250 3a 64 b2			ld a, (.dmark)  
b253 32 71 ee			ld (debug_mark),a  
b256 3a 65 b2			ld a, (.dmark+1)  
b259 32 72 ee			ld (debug_mark+1),a  
b25c 3a 66 b2			ld a, (.dmark+2)  
b25f 32 73 ee			ld (debug_mark+2),a  
b262 18 03			jr .pastdmark  
b264 ..			.dmark: db "UNT"  
b267 f1			.pastdmark: pop af  
b268			endm  
# End of macro DMARK
b268						CALLMONITOR 
b268 cd 9d 94			call break_point_state  
b26b				endm  
# End of macro CALLMONITOR
b26b					endif 
b26b			 
b26b			;	push hl 
b26b				FORTH_DSP_POP 
b26b cd bd 9d			call macro_forth_dsp_pop 
b26e				endm 
# End of macro FORTH_DSP_POP
b26e			 
b26e			;	pop hl 
b26e			 
b26e				; test if true 
b26e			 
b26e cd c5 8c			call ishlzero 
b271			;	ld a,l 
b271			;	add h 
b271			; 
b271			;	cp 0 
b271			 
b271 20 3e			jr nz, .untilnotdone 
b273			 
b273					if DEBUG_FORTH_WORDS 
b273						DMARK "UNf" 
b273 f5				push af  
b274 3a 88 b2			ld a, (.dmark)  
b277 32 71 ee			ld (debug_mark),a  
b27a 3a 89 b2			ld a, (.dmark+1)  
b27d 32 72 ee			ld (debug_mark+1),a  
b280 3a 8a b2			ld a, (.dmark+2)  
b283 32 73 ee			ld (debug_mark+2),a  
b286 18 03			jr .pastdmark  
b288 ..			.dmark: db "UNf"  
b28b f1			.pastdmark: pop af  
b28c			endm  
# End of macro DMARK
b28c						CALLMONITOR 
b28c cd 9d 94			call break_point_state  
b28f				endm  
# End of macro CALLMONITOR
b28f					endif 
b28f			 
b28f			 
b28f			 
b28f				FORTH_RSP_POP     ; get rid of DO ptr 
b28f cd d6 9a			call macro_forth_rsp_pop 
b292				endm 
# End of macro FORTH_RSP_POP
b292			 
b292			if DEBUG_FORTH_WORDS 
b292						DMARK "UN>" 
b292 f5				push af  
b293 3a a7 b2			ld a, (.dmark)  
b296 32 71 ee			ld (debug_mark),a  
b299 3a a8 b2			ld a, (.dmark+1)  
b29c 32 72 ee			ld (debug_mark+1),a  
b29f 3a a9 b2			ld a, (.dmark+2)  
b2a2 32 73 ee			ld (debug_mark+2),a  
b2a5 18 03			jr .pastdmark  
b2a7 ..			.dmark: db "UN>"  
b2aa f1			.pastdmark: pop af  
b2ab			endm  
# End of macro DMARK
b2ab				CALLMONITOR 
b2ab cd 9d 94			call break_point_state  
b2ae				endm  
# End of macro CALLMONITOR
b2ae			endif 
b2ae			 
b2ae					NEXTW 
b2ae c3 7c 9e			jp macro_next 
b2b1				endm 
# End of macro NEXTW
b2b1				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b2b1			 
b2b1			.untilnotdone: 
b2b1			 
b2b1			 
b2b1			;	; get DO ptr 
b2b1			; 
b2b1				FORTH_RSP_TOS 
b2b1 cd cc 9a			call macro_forth_rsp_tos 
b2b4				endm 
# End of macro FORTH_RSP_TOS
b2b4			 
b2b4				;push hl 
b2b4			 
b2b4				; not going to DO any more 
b2b4				; get rid of the RSP pointer as DO will add it back in 
b2b4				;FORTH_RSP_POP 
b2b4				;pop hl 
b2b4			 
b2b4			 
b2b4 22 03 e6			ld (os_tok_ptr), hl 
b2b7					if DEBUG_FORTH_WORDS 
b2b7						DMARK "UN<" 
b2b7 f5				push af  
b2b8 3a cc b2			ld a, (.dmark)  
b2bb 32 71 ee			ld (debug_mark),a  
b2be 3a cd b2			ld a, (.dmark+1)  
b2c1 32 72 ee			ld (debug_mark+1),a  
b2c4 3a ce b2			ld a, (.dmark+2)  
b2c7 32 73 ee			ld (debug_mark+2),a  
b2ca 18 03			jr .pastdmark  
b2cc ..			.dmark: db "UN<"  
b2cf f1			.pastdmark: pop af  
b2d0			endm  
# End of macro DMARK
b2d0					CALLMONITOR 
b2d0 cd 9d 94			call break_point_state  
b2d3				endm  
# End of macro CALLMONITOR
b2d3				endif 
b2d3 c3 0d 9f			jp exec1 
b2d6			 
b2d6					 
b2d6			 
b2d6			 
b2d6					NEXTW 
b2d6 c3 7c 9e			jp macro_next 
b2d9				endm 
# End of macro NEXTW
b2d9			 
b2d9			 
b2d9			.ENDFLOW: 
b2d9			 
b2d9			; eof 
b2d9			 
# End of file forth_words_flow.asm
b2d9			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b2d9			include "forth_words_logic.asm" 
b2d9			 
b2d9			; | ## Logic Words 
b2d9			 
b2d9			.NOT: 
b2d9				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b2d9 2d				db WORD_SYS_CORE+25             
b2da 21 b3			dw .IS            
b2dc 04				db 3 + 1 
b2dd .. 00			db "NOT",0              
b2e1				endm 
# End of macro CWHEAD
b2e1			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b2e1					if DEBUG_FORTH_WORDS_KEY 
b2e1						DMARK "NOT" 
b2e1 f5				push af  
b2e2 3a f6 b2			ld a, (.dmark)  
b2e5 32 71 ee			ld (debug_mark),a  
b2e8 3a f7 b2			ld a, (.dmark+1)  
b2eb 32 72 ee			ld (debug_mark+1),a  
b2ee 3a f8 b2			ld a, (.dmark+2)  
b2f1 32 73 ee			ld (debug_mark+2),a  
b2f4 18 03			jr .pastdmark  
b2f6 ..			.dmark: db "NOT"  
b2f9 f1			.pastdmark: pop af  
b2fa			endm  
# End of macro DMARK
b2fa						CALLMONITOR 
b2fa cd 9d 94			call break_point_state  
b2fd				endm  
# End of macro CALLMONITOR
b2fd					endif 
b2fd					FORTH_DSP 
b2fd cd cb 9c			call macro_forth_dsp 
b300				endm 
# End of macro FORTH_DSP
b300 7e					ld a,(hl)	; get type of value on TOS 
b301 fe 02				cp DS_TYPE_INUM  
b303 28 03				jr z, .noti 
b305					NEXTW 
b305 c3 7c 9e			jp macro_next 
b308				endm 
# End of macro NEXTW
b308			.noti:          FORTH_DSP_VALUEHL 
b308 cd 05 9d			call macro_dsp_valuehl 
b30b				endm 
# End of macro FORTH_DSP_VALUEHL
b30b			;		push hl 
b30b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b30b cd bd 9d			call macro_forth_dsp_pop 
b30e				endm 
# End of macro FORTH_DSP_POP
b30e			;		pop hl 
b30e 3e 00				ld a,0 
b310 bd					cp l 
b311 28 04				jr z, .not2t 
b313 2e 00				ld l, 0 
b315 18 02				jr .notip 
b317			 
b317 2e ff		.not2t:		ld l, 255 
b319			 
b319 26 00		.notip:		ld h, 0	 
b31b			 
b31b cd 0e 9b				call forth_push_numhl 
b31e					NEXTW 
b31e c3 7c 9e			jp macro_next 
b321				endm 
# End of macro NEXTW
b321			 
b321			.IS: 
b321				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b321 2d				db WORD_SYS_CORE+25             
b322 47 b3			dw .LZERO            
b324 03				db 2 + 1 
b325 .. 00			db "IS",0              
b328				endm 
# End of macro CWHEAD
b328			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b328					if DEBUG_FORTH_WORDS_KEY 
b328						DMARK "IS." 
b328 f5				push af  
b329 3a 3d b3			ld a, (.dmark)  
b32c 32 71 ee			ld (debug_mark),a  
b32f 3a 3e b3			ld a, (.dmark+1)  
b332 32 72 ee			ld (debug_mark+1),a  
b335 3a 3f b3			ld a, (.dmark+2)  
b338 32 73 ee			ld (debug_mark+2),a  
b33b 18 03			jr .pastdmark  
b33d ..			.dmark: db "IS."  
b340 f1			.pastdmark: pop af  
b341			endm  
# End of macro DMARK
b341						CALLMONITOR 
b341 cd 9d 94			call break_point_state  
b344				endm  
# End of macro CALLMONITOR
b344					endif 
b344					NEXTW 
b344 c3 7c 9e			jp macro_next 
b347				endm 
# End of macro NEXTW
b347			.LZERO: 
b347				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b347 2d				db WORD_SYS_CORE+25             
b348 51 b3			dw .TZERO            
b34a 03				db 2 + 1 
b34b .. 00			db "0<",0              
b34e				endm 
# End of macro CWHEAD
b34e			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b34e					NEXTW 
b34e c3 7c 9e			jp macro_next 
b351				endm 
# End of macro NEXTW
b351			.TZERO: 
b351				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b351 2e				db WORD_SYS_CORE+26             
b352 98 b3			dw .LESS            
b354 03				db 2 + 1 
b355 .. 00			db "0=",0              
b358				endm 
# End of macro CWHEAD
b358			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b358				; TODO add floating point number detection 
b358					;v5 FORTH_DSP_VALUE 
b358					if DEBUG_FORTH_WORDS_KEY 
b358						DMARK "0=." 
b358 f5				push af  
b359 3a 6d b3			ld a, (.dmark)  
b35c 32 71 ee			ld (debug_mark),a  
b35f 3a 6e b3			ld a, (.dmark+1)  
b362 32 72 ee			ld (debug_mark+1),a  
b365 3a 6f b3			ld a, (.dmark+2)  
b368 32 73 ee			ld (debug_mark+2),a  
b36b 18 03			jr .pastdmark  
b36d ..			.dmark: db "0=."  
b370 f1			.pastdmark: pop af  
b371			endm  
# End of macro DMARK
b371						CALLMONITOR 
b371 cd 9d 94			call break_point_state  
b374				endm  
# End of macro CALLMONITOR
b374					endif 
b374					FORTH_DSP 
b374 cd cb 9c			call macro_forth_dsp 
b377				endm 
# End of macro FORTH_DSP
b377 7e					ld a,(hl)	; get type of value on TOS 
b378 fe 02				cp DS_TYPE_INUM  
b37a 28 00				jr z, .tz_inum 
b37c			 
b37c				if FORTH_ENABLE_FLOATMATH 
b37c					jr .tz_done 
b37c			 
b37c				endif 
b37c					 
b37c			 
b37c			.tz_inum: 
b37c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b37c cd 05 9d			call macro_dsp_valuehl 
b37f				endm 
# End of macro FORTH_DSP_VALUEHL
b37f			 
b37f			;		push hl 
b37f			 
b37f					; destroy value TOS 
b37f			 
b37f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b37f cd bd 9d			call macro_forth_dsp_pop 
b382				endm 
# End of macro FORTH_DSP_POP
b382			 
b382			;		pop hl 
b382			 
b382 3e 00				ld a,0 
b384			 
b384 bd					cp l 
b385 20 08				jr nz, .tz_notzero 
b387			 
b387 bc					cp h 
b388			 
b388 20 05				jr nz, .tz_notzero 
b38a			 
b38a			 
b38a 21 01 00				ld hl, FORTH_TRUE 
b38d 18 03				jr .tz_done 
b38f			 
b38f 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b392			 
b392					; push value back onto stack for another op etc 
b392			 
b392			.tz_done: 
b392 cd 0e 9b				call forth_push_numhl 
b395			 
b395					NEXTW 
b395 c3 7c 9e			jp macro_next 
b398				endm 
# End of macro NEXTW
b398			.LESS: 
b398				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b398 2f				db WORD_SYS_CORE+27             
b399 01 b4			dw .GT            
b39b 02				db 1 + 1 
b39c .. 00			db "<",0              
b39e				endm 
# End of macro CWHEAD
b39e			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b39e				; TODO add floating point number detection 
b39e					if DEBUG_FORTH_WORDS_KEY 
b39e						DMARK "LES" 
b39e f5				push af  
b39f 3a b3 b3			ld a, (.dmark)  
b3a2 32 71 ee			ld (debug_mark),a  
b3a5 3a b4 b3			ld a, (.dmark+1)  
b3a8 32 72 ee			ld (debug_mark+1),a  
b3ab 3a b5 b3			ld a, (.dmark+2)  
b3ae 32 73 ee			ld (debug_mark+2),a  
b3b1 18 03			jr .pastdmark  
b3b3 ..			.dmark: db "LES"  
b3b6 f1			.pastdmark: pop af  
b3b7			endm  
# End of macro DMARK
b3b7						CALLMONITOR 
b3b7 cd 9d 94			call break_point_state  
b3ba				endm  
# End of macro CALLMONITOR
b3ba					endif 
b3ba					FORTH_DSP 
b3ba cd cb 9c			call macro_forth_dsp 
b3bd				endm 
# End of macro FORTH_DSP
b3bd					;v5 FORTH_DSP_VALUE 
b3bd 7e					ld a,(hl)	; get type of value on TOS 
b3be fe 02				cp DS_TYPE_INUM  
b3c0 28 00				jr z, .less_inum 
b3c2			 
b3c2				if FORTH_ENABLE_FLOATMATH 
b3c2					jr .less_done 
b3c2			 
b3c2				endif 
b3c2					 
b3c2			 
b3c2			.less_inum: 
b3c2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3c2 cd 05 9d			call macro_dsp_valuehl 
b3c5				endm 
# End of macro FORTH_DSP_VALUEHL
b3c5			 
b3c5 e5					push hl  ; u2 
b3c6			 
b3c6					; destroy value TOS 
b3c6			 
b3c6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3c6 cd bd 9d			call macro_forth_dsp_pop 
b3c9				endm 
# End of macro FORTH_DSP_POP
b3c9			 
b3c9			 
b3c9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3c9 cd 05 9d			call macro_dsp_valuehl 
b3cc				endm 
# End of macro FORTH_DSP_VALUEHL
b3cc			 
b3cc e5					push hl    ; u1 
b3cd			 
b3cd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3cd cd bd 9d			call macro_forth_dsp_pop 
b3d0				endm 
# End of macro FORTH_DSP_POP
b3d0			 
b3d0			 
b3d0 b7			 or a      ;clear carry flag 
b3d1 01 00 00		 ld bc, FORTH_FALSE 
b3d4 e1			  pop hl    ; u1 
b3d5 d1			  pop de    ; u2 
b3d6 ed 52		  sbc hl,de 
b3d8 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b3da			 
b3da 01 01 00		 ld bc, FORTH_TRUE 
b3dd			.lscont:  
b3dd c5					push bc 
b3de e1					pop hl 
b3df			 
b3df					if DEBUG_FORTH_WORDS 
b3df						DMARK "LT1" 
b3df f5				push af  
b3e0 3a f4 b3			ld a, (.dmark)  
b3e3 32 71 ee			ld (debug_mark),a  
b3e6 3a f5 b3			ld a, (.dmark+1)  
b3e9 32 72 ee			ld (debug_mark+1),a  
b3ec 3a f6 b3			ld a, (.dmark+2)  
b3ef 32 73 ee			ld (debug_mark+2),a  
b3f2 18 03			jr .pastdmark  
b3f4 ..			.dmark: db "LT1"  
b3f7 f1			.pastdmark: pop af  
b3f8			endm  
# End of macro DMARK
b3f8						CALLMONITOR 
b3f8 cd 9d 94			call break_point_state  
b3fb				endm  
# End of macro CALLMONITOR
b3fb					endif 
b3fb cd 0e 9b				call forth_push_numhl 
b3fe			 
b3fe					NEXTW 
b3fe c3 7c 9e			jp macro_next 
b401				endm 
# End of macro NEXTW
b401			.GT: 
b401				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b401 30				db WORD_SYS_CORE+28             
b402 6a b4			dw .EQUAL            
b404 02				db 1 + 1 
b405 .. 00			db ">",0              
b407				endm 
# End of macro CWHEAD
b407			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b407				; TODO add floating point number detection 
b407					if DEBUG_FORTH_WORDS_KEY 
b407						DMARK "GRT" 
b407 f5				push af  
b408 3a 1c b4			ld a, (.dmark)  
b40b 32 71 ee			ld (debug_mark),a  
b40e 3a 1d b4			ld a, (.dmark+1)  
b411 32 72 ee			ld (debug_mark+1),a  
b414 3a 1e b4			ld a, (.dmark+2)  
b417 32 73 ee			ld (debug_mark+2),a  
b41a 18 03			jr .pastdmark  
b41c ..			.dmark: db "GRT"  
b41f f1			.pastdmark: pop af  
b420			endm  
# End of macro DMARK
b420						CALLMONITOR 
b420 cd 9d 94			call break_point_state  
b423				endm  
# End of macro CALLMONITOR
b423					endif 
b423					FORTH_DSP 
b423 cd cb 9c			call macro_forth_dsp 
b426				endm 
# End of macro FORTH_DSP
b426					;FORTH_DSP_VALUE 
b426 7e					ld a,(hl)	; get type of value on TOS 
b427 fe 02				cp DS_TYPE_INUM  
b429 28 00				jr z, .gt_inum 
b42b			 
b42b				if FORTH_ENABLE_FLOATMATH 
b42b					jr .gt_done 
b42b			 
b42b				endif 
b42b					 
b42b			 
b42b			.gt_inum: 
b42b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b42b cd 05 9d			call macro_dsp_valuehl 
b42e				endm 
# End of macro FORTH_DSP_VALUEHL
b42e			 
b42e e5					push hl  ; u2 
b42f			 
b42f					; destroy value TOS 
b42f			 
b42f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b42f cd bd 9d			call macro_forth_dsp_pop 
b432				endm 
# End of macro FORTH_DSP_POP
b432			 
b432			 
b432					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b432 cd 05 9d			call macro_dsp_valuehl 
b435				endm 
# End of macro FORTH_DSP_VALUEHL
b435			 
b435 e5					push hl    ; u1 
b436			 
b436					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b436 cd bd 9d			call macro_forth_dsp_pop 
b439				endm 
# End of macro FORTH_DSP_POP
b439			 
b439			 
b439 b7			 or a      ;clear carry flag 
b43a 01 00 00		 ld bc, FORTH_FALSE 
b43d e1			  pop hl    ; u1 
b43e d1			  pop de    ; u2 
b43f ed 52		  sbc hl,de 
b441 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b443			 
b443 01 01 00		 ld bc, FORTH_TRUE 
b446			.gtcont:  
b446 c5					push bc 
b447 e1					pop hl 
b448			 
b448					if DEBUG_FORTH_WORDS 
b448						DMARK "GT1" 
b448 f5				push af  
b449 3a 5d b4			ld a, (.dmark)  
b44c 32 71 ee			ld (debug_mark),a  
b44f 3a 5e b4			ld a, (.dmark+1)  
b452 32 72 ee			ld (debug_mark+1),a  
b455 3a 5f b4			ld a, (.dmark+2)  
b458 32 73 ee			ld (debug_mark+2),a  
b45b 18 03			jr .pastdmark  
b45d ..			.dmark: db "GT1"  
b460 f1			.pastdmark: pop af  
b461			endm  
# End of macro DMARK
b461						CALLMONITOR 
b461 cd 9d 94			call break_point_state  
b464				endm  
# End of macro CALLMONITOR
b464					endif 
b464 cd 0e 9b				call forth_push_numhl 
b467			 
b467					NEXTW 
b467 c3 7c 9e			jp macro_next 
b46a				endm 
# End of macro NEXTW
b46a			.EQUAL: 
b46a				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b46a 31				db WORD_SYS_CORE+29             
b46b d5 b4			dw .ENDLOGIC            
b46d 02				db 1 + 1 
b46e .. 00			db "=",0              
b470				endm 
# End of macro CWHEAD
b470			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b470				; TODO add floating point number detection 
b470					if DEBUG_FORTH_WORDS_KEY 
b470						DMARK "EQ." 
b470 f5				push af  
b471 3a 85 b4			ld a, (.dmark)  
b474 32 71 ee			ld (debug_mark),a  
b477 3a 86 b4			ld a, (.dmark+1)  
b47a 32 72 ee			ld (debug_mark+1),a  
b47d 3a 87 b4			ld a, (.dmark+2)  
b480 32 73 ee			ld (debug_mark+2),a  
b483 18 03			jr .pastdmark  
b485 ..			.dmark: db "EQ."  
b488 f1			.pastdmark: pop af  
b489			endm  
# End of macro DMARK
b489						CALLMONITOR 
b489 cd 9d 94			call break_point_state  
b48c				endm  
# End of macro CALLMONITOR
b48c					endif 
b48c					FORTH_DSP 
b48c cd cb 9c			call macro_forth_dsp 
b48f				endm 
# End of macro FORTH_DSP
b48f					;v5 FORTH_DSP_VALUE 
b48f 7e					ld a,(hl)	; get type of value on TOS 
b490 fe 02				cp DS_TYPE_INUM  
b492 28 00				jr z, .eq_inum 
b494			 
b494				if FORTH_ENABLE_FLOATMATH 
b494					jr .eq_done 
b494			 
b494				endif 
b494					 
b494			 
b494			.eq_inum: 
b494					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b494 cd 05 9d			call macro_dsp_valuehl 
b497				endm 
# End of macro FORTH_DSP_VALUEHL
b497			 
b497 e5					push hl 
b498			 
b498					; destroy value TOS 
b498			 
b498					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b498 cd bd 9d			call macro_forth_dsp_pop 
b49b				endm 
# End of macro FORTH_DSP_POP
b49b			 
b49b			 
b49b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b49b cd 05 9d			call macro_dsp_valuehl 
b49e				endm 
# End of macro FORTH_DSP_VALUEHL
b49e			 
b49e					; one value on hl get other one back 
b49e			 
b49e e5					push hl 
b49f			 
b49f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b49f cd bd 9d			call macro_forth_dsp_pop 
b4a2				endm 
# End of macro FORTH_DSP_POP
b4a2			 
b4a2 0e 00				ld c, FORTH_FALSE 
b4a4			 
b4a4 e1					pop hl 
b4a5 d1					pop de 
b4a6			 
b4a6 7b					ld a, e 
b4a7 bd					cp l 
b4a8			 
b4a8 20 06				jr nz, .eq_done 
b4aa			 
b4aa 7a					ld a, d 
b4ab bc					cp h 
b4ac			 
b4ac 20 02				jr nz, .eq_done 
b4ae			 
b4ae 0e 01				ld c, FORTH_TRUE 
b4b0					 
b4b0			 
b4b0			 
b4b0			.eq_done: 
b4b0			 
b4b0					; TODO push value back onto stack for another op etc 
b4b0			 
b4b0 26 00				ld h, 0 
b4b2 69					ld l, c 
b4b3					if DEBUG_FORTH_WORDS 
b4b3						DMARK "EQ1" 
b4b3 f5				push af  
b4b4 3a c8 b4			ld a, (.dmark)  
b4b7 32 71 ee			ld (debug_mark),a  
b4ba 3a c9 b4			ld a, (.dmark+1)  
b4bd 32 72 ee			ld (debug_mark+1),a  
b4c0 3a ca b4			ld a, (.dmark+2)  
b4c3 32 73 ee			ld (debug_mark+2),a  
b4c6 18 03			jr .pastdmark  
b4c8 ..			.dmark: db "EQ1"  
b4cb f1			.pastdmark: pop af  
b4cc			endm  
# End of macro DMARK
b4cc						CALLMONITOR 
b4cc cd 9d 94			call break_point_state  
b4cf				endm  
# End of macro CALLMONITOR
b4cf					endif 
b4cf cd 0e 9b				call forth_push_numhl 
b4d2			 
b4d2					NEXTW 
b4d2 c3 7c 9e			jp macro_next 
b4d5				endm 
# End of macro NEXTW
b4d5			 
b4d5			 
b4d5			.ENDLOGIC: 
b4d5			; eof 
b4d5			 
b4d5			 
# End of file forth_words_logic.asm
b4d5			include "forth_words_maths.asm" 
b4d5			 
b4d5			; | ## Maths Words 
b4d5			 
b4d5			.PLUS:	 
b4d5				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b4d5 15				db WORD_SYS_CORE+1             
b4d6 17 b5			dw .NEG            
b4d8 02				db 1 + 1 
b4d9 .. 00			db "+",0              
b4db				endm 
# End of macro CWHEAD
b4db			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b4db					if DEBUG_FORTH_WORDS_KEY 
b4db						DMARK "PLU" 
b4db f5				push af  
b4dc 3a f0 b4			ld a, (.dmark)  
b4df 32 71 ee			ld (debug_mark),a  
b4e2 3a f1 b4			ld a, (.dmark+1)  
b4e5 32 72 ee			ld (debug_mark+1),a  
b4e8 3a f2 b4			ld a, (.dmark+2)  
b4eb 32 73 ee			ld (debug_mark+2),a  
b4ee 18 03			jr .pastdmark  
b4f0 ..			.dmark: db "PLU"  
b4f3 f1			.pastdmark: pop af  
b4f4			endm  
# End of macro DMARK
b4f4						CALLMONITOR 
b4f4 cd 9d 94			call break_point_state  
b4f7				endm  
# End of macro CALLMONITOR
b4f7					endif 
b4f7					; add top two values and push back result 
b4f7			 
b4f7					;for v5 FORTH_DSP_VALUE 
b4f7					FORTH_DSP 
b4f7 cd cb 9c			call macro_forth_dsp 
b4fa				endm 
# End of macro FORTH_DSP
b4fa 7e					ld a,(hl)	; get type of value on TOS 
b4fb fe 02				cp DS_TYPE_INUM  
b4fd 28 03				jr z, .dot_inum 
b4ff			 
b4ff					NEXTW 
b4ff c3 7c 9e			jp macro_next 
b502				endm 
# End of macro NEXTW
b502			 
b502			; float maths 
b502			 
b502				if FORTH_ENABLE_FLOATMATH 
b502						inc hl      ; now at start of numeric as string 
b502			 
b502					if DEBUG_FORTH_MATHS 
b502						DMARK "ADD" 
b502				CALLMONITOR 
b502					endif 
b502			 
b502					;ld ix, hl 
b502					call CON 
b502			 
b502			 
b502					push hl 
b502					 
b502					 
b502			 
b502						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b502			 
b502					; get next number 
b502			 
b502						FORTH_DSP_VALUE 
b502			 
b502						inc hl      ; now at start of numeric as string 
b502			 
b502					;ld ix, hl 
b502					call CON 
b502			 
b502					push hl 
b502			 
b502			 
b502						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b502			 
b502						; TODO do add 
b502			 
b502						call IADD 
b502			 
b502						; TODO get result back as ascii 
b502			 
b502						; TODO push result  
b502			 
b502			 
b502			 
b502						jr .dot_done 
b502				endif 
b502			 
b502			.dot_inum: 
b502			 
b502			 
b502					if DEBUG_FORTH_DOT 
b502						DMARK "+IT" 
b502				CALLMONITOR 
b502					endif 
b502			 
b502					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b502 cd 05 9d			call macro_dsp_valuehl 
b505				endm 
# End of macro FORTH_DSP_VALUEHL
b505			 
b505				; TODO add floating point number detection 
b505			 
b505 e5					push hl 
b506			 
b506					; destroy value TOS 
b506			 
b506					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b506 cd bd 9d			call macro_forth_dsp_pop 
b509				endm 
# End of macro FORTH_DSP_POP
b509			 
b509			 
b509					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b509 cd 05 9d			call macro_dsp_valuehl 
b50c				endm 
# End of macro FORTH_DSP_VALUEHL
b50c			 
b50c					; one value on hl get other one back 
b50c			 
b50c d1					pop de 
b50d			 
b50d					; do the add 
b50d			 
b50d 19					add hl,de 
b50e			 
b50e					; save it 
b50e			 
b50e			;		push hl	 
b50e			 
b50e					; 
b50e			 
b50e					; destroy value TOS 
b50e			 
b50e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b50e cd bd 9d			call macro_forth_dsp_pop 
b511				endm 
# End of macro FORTH_DSP_POP
b511			 
b511					; TODO push value back onto stack for another op etc 
b511			 
b511			;		pop hl 
b511			 
b511			.dot_done: 
b511 cd 0e 9b				call forth_push_numhl 
b514			 
b514					NEXTW 
b514 c3 7c 9e			jp macro_next 
b517				endm 
# End of macro NEXTW
b517			.NEG: 
b517			 
b517				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b517 17				db WORD_SYS_CORE+3             
b518 5a b5			dw .DIV            
b51a 02				db 1 + 1 
b51b .. 00			db "-",0              
b51d				endm 
# End of macro CWHEAD
b51d			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b51d					if DEBUG_FORTH_WORDS_KEY 
b51d						DMARK "SUB" 
b51d f5				push af  
b51e 3a 32 b5			ld a, (.dmark)  
b521 32 71 ee			ld (debug_mark),a  
b524 3a 33 b5			ld a, (.dmark+1)  
b527 32 72 ee			ld (debug_mark+1),a  
b52a 3a 34 b5			ld a, (.dmark+2)  
b52d 32 73 ee			ld (debug_mark+2),a  
b530 18 03			jr .pastdmark  
b532 ..			.dmark: db "SUB"  
b535 f1			.pastdmark: pop af  
b536			endm  
# End of macro DMARK
b536						CALLMONITOR 
b536 cd 9d 94			call break_point_state  
b539				endm  
# End of macro CALLMONITOR
b539					endif 
b539			 
b539			 
b539				; TODO add floating point number detection 
b539					; v5 FORTH_DSP_VALUE 
b539					FORTH_DSP 
b539 cd cb 9c			call macro_forth_dsp 
b53c				endm 
# End of macro FORTH_DSP
b53c 7e					ld a,(hl)	; get type of value on TOS 
b53d fe 02				cp DS_TYPE_INUM  
b53f 28 03				jr z, .neg_inum 
b541			 
b541					NEXTW 
b541 c3 7c 9e			jp macro_next 
b544				endm 
# End of macro NEXTW
b544			 
b544			; float maths 
b544			 
b544				if FORTH_ENABLE_FLOATMATH 
b544					jr .neg_done 
b544			 
b544				endif 
b544					 
b544			 
b544			.neg_inum: 
b544					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b544 cd 05 9d			call macro_dsp_valuehl 
b547				endm 
# End of macro FORTH_DSP_VALUEHL
b547			 
b547 e5					push hl 
b548			 
b548					; destroy value TOS 
b548			 
b548					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b548 cd bd 9d			call macro_forth_dsp_pop 
b54b				endm 
# End of macro FORTH_DSP_POP
b54b			 
b54b			 
b54b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b54b cd 05 9d			call macro_dsp_valuehl 
b54e				endm 
# End of macro FORTH_DSP_VALUEHL
b54e			 
b54e					; one value on hl get other one back 
b54e			 
b54e d1					pop de 
b54f			 
b54f					; do the sub 
b54f			;		ex de, hl 
b54f			 
b54f ed 52				sbc hl,de 
b551			 
b551					; save it 
b551			 
b551			;		push hl	 
b551			 
b551					; 
b551			 
b551					; destroy value TOS 
b551			 
b551					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b551 cd bd 9d			call macro_forth_dsp_pop 
b554				endm 
# End of macro FORTH_DSP_POP
b554			 
b554					; TODO push value back onto stack for another op etc 
b554			 
b554			;		pop hl 
b554			 
b554 cd 0e 9b				call forth_push_numhl 
b557			.neg_done: 
b557			 
b557					NEXTW 
b557 c3 7c 9e			jp macro_next 
b55a				endm 
# End of macro NEXTW
b55a			.DIV: 
b55a				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b55a 18				db WORD_SYS_CORE+4             
b55b a7 b5			dw .MUL            
b55d 02				db 1 + 1 
b55e .. 00			db "/",0              
b560				endm 
# End of macro CWHEAD
b560			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b560					if DEBUG_FORTH_WORDS_KEY 
b560						DMARK "DIV" 
b560 f5				push af  
b561 3a 75 b5			ld a, (.dmark)  
b564 32 71 ee			ld (debug_mark),a  
b567 3a 76 b5			ld a, (.dmark+1)  
b56a 32 72 ee			ld (debug_mark+1),a  
b56d 3a 77 b5			ld a, (.dmark+2)  
b570 32 73 ee			ld (debug_mark+2),a  
b573 18 03			jr .pastdmark  
b575 ..			.dmark: db "DIV"  
b578 f1			.pastdmark: pop af  
b579			endm  
# End of macro DMARK
b579						CALLMONITOR 
b579 cd 9d 94			call break_point_state  
b57c				endm  
# End of macro CALLMONITOR
b57c					endif 
b57c				; TODO add floating point number detection 
b57c					; v5 FORTH_DSP_VALUE 
b57c					FORTH_DSP 
b57c cd cb 9c			call macro_forth_dsp 
b57f				endm 
# End of macro FORTH_DSP
b57f 7e					ld a,(hl)	; get type of value on TOS 
b580 fe 02				cp DS_TYPE_INUM  
b582 28 03				jr z, .div_inum 
b584			 
b584				if FORTH_ENABLE_FLOATMATH 
b584					jr .div_done 
b584			 
b584				endif 
b584					NEXTW 
b584 c3 7c 9e			jp macro_next 
b587				endm 
# End of macro NEXTW
b587			.div_inum: 
b587			 
b587					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b587 cd 05 9d			call macro_dsp_valuehl 
b58a				endm 
# End of macro FORTH_DSP_VALUEHL
b58a			 
b58a e5					push hl    ; to go to bc 
b58b			 
b58b					; destroy value TOS 
b58b			 
b58b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b58b cd bd 9d			call macro_forth_dsp_pop 
b58e				endm 
# End of macro FORTH_DSP_POP
b58e			 
b58e			 
b58e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b58e cd 05 9d			call macro_dsp_valuehl 
b591				endm 
# End of macro FORTH_DSP_VALUEHL
b591			 
b591					; hl to go to de 
b591			 
b591 e5					push hl 
b592			 
b592 c1					pop bc 
b593 d1					pop de		 
b594			 
b594			 
b594					if DEBUG_FORTH_MATHS 
b594						DMARK "DIV" 
b594				CALLMONITOR 
b594					endif 
b594					; one value on hl but move to a get other one back 
b594			 
b594			        
b594 cd f9 8b			call Div16 
b597			 
b597			;	push af	 
b597 e5				push hl 
b598 c5				push bc 
b599			 
b599					if DEBUG_FORTH_MATHS 
b599						DMARK "DI1" 
b599				CALLMONITOR 
b599					endif 
b599			 
b599					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b599 cd bd 9d			call macro_forth_dsp_pop 
b59c				endm 
# End of macro FORTH_DSP_POP
b59c			 
b59c			 
b59c			 
b59c e1					pop hl    ; result 
b59d			 
b59d cd 0e 9b				call forth_push_numhl 
b5a0			 
b5a0 e1					pop hl    ; reminder 
b5a1			;		ld h,0 
b5a1			;		ld l,d 
b5a1			 
b5a1 cd 0e 9b				call forth_push_numhl 
b5a4			.div_done: 
b5a4					NEXTW 
b5a4 c3 7c 9e			jp macro_next 
b5a7				endm 
# End of macro NEXTW
b5a7			.MUL: 
b5a7				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b5a7 19				db WORD_SYS_CORE+5             
b5a8 ec b5			dw .MIN            
b5aa 02				db 1 + 1 
b5ab .. 00			db "*",0              
b5ad				endm 
# End of macro CWHEAD
b5ad			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b5ad				; TODO add floating point number detection 
b5ad					if DEBUG_FORTH_WORDS_KEY 
b5ad						DMARK "MUL" 
b5ad f5				push af  
b5ae 3a c2 b5			ld a, (.dmark)  
b5b1 32 71 ee			ld (debug_mark),a  
b5b4 3a c3 b5			ld a, (.dmark+1)  
b5b7 32 72 ee			ld (debug_mark+1),a  
b5ba 3a c4 b5			ld a, (.dmark+2)  
b5bd 32 73 ee			ld (debug_mark+2),a  
b5c0 18 03			jr .pastdmark  
b5c2 ..			.dmark: db "MUL"  
b5c5 f1			.pastdmark: pop af  
b5c6			endm  
# End of macro DMARK
b5c6						CALLMONITOR 
b5c6 cd 9d 94			call break_point_state  
b5c9				endm  
# End of macro CALLMONITOR
b5c9					endif 
b5c9					FORTH_DSP 
b5c9 cd cb 9c			call macro_forth_dsp 
b5cc				endm 
# End of macro FORTH_DSP
b5cc					; v5 FORTH_DSP_VALUE 
b5cc 7e					ld a,(hl)	; get type of value on TOS 
b5cd fe 02				cp DS_TYPE_INUM  
b5cf 28 03				jr z, .mul_inum 
b5d1			 
b5d1				if FORTH_ENABLE_FLOATMATH 
b5d1					jr .mul_done 
b5d1			 
b5d1				endif 
b5d1			 
b5d1					NEXTW 
b5d1 c3 7c 9e			jp macro_next 
b5d4				endm 
# End of macro NEXTW
b5d4			.mul_inum:	 
b5d4			 
b5d4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5d4 cd 05 9d			call macro_dsp_valuehl 
b5d7				endm 
# End of macro FORTH_DSP_VALUEHL
b5d7			 
b5d7 e5					push hl 
b5d8			 
b5d8					; destroy value TOS 
b5d8			 
b5d8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5d8 cd bd 9d			call macro_forth_dsp_pop 
b5db				endm 
# End of macro FORTH_DSP_POP
b5db			 
b5db			 
b5db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b5db cd 05 9d			call macro_dsp_valuehl 
b5de				endm 
# End of macro FORTH_DSP_VALUEHL
b5de			 
b5de					; one value on hl but move to a get other one back 
b5de			 
b5de 7d					ld a, l 
b5df			 
b5df d1					pop de 
b5e0			 
b5e0					; do the mull 
b5e0			;		ex de, hl 
b5e0			 
b5e0 cd 1f 8c				call Mult16 
b5e3					; save it 
b5e3			 
b5e3			;		push hl	 
b5e3			 
b5e3					; 
b5e3			 
b5e3					; destroy value TOS 
b5e3			 
b5e3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b5e3 cd bd 9d			call macro_forth_dsp_pop 
b5e6				endm 
# End of macro FORTH_DSP_POP
b5e6			 
b5e6					; TODO push value back onto stack for another op etc 
b5e6			 
b5e6			;		pop hl 
b5e6			 
b5e6 cd 0e 9b				call forth_push_numhl 
b5e9			 
b5e9			.mul_done: 
b5e9					NEXTW 
b5e9 c3 7c 9e			jp macro_next 
b5ec				endm 
# End of macro NEXTW
b5ec			 
b5ec			 
b5ec			 
b5ec			 
b5ec			.MIN: 
b5ec				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b5ec 49				db WORD_SYS_CORE+53             
b5ed 6d b6			dw .MAX            
b5ef 04				db 3 + 1 
b5f0 .. 00			db "MIN",0              
b5f4				endm 
# End of macro CWHEAD
b5f4			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b5f4					if DEBUG_FORTH_WORDS_KEY 
b5f4						DMARK "MIN" 
b5f4 f5				push af  
b5f5 3a 09 b6			ld a, (.dmark)  
b5f8 32 71 ee			ld (debug_mark),a  
b5fb 3a 0a b6			ld a, (.dmark+1)  
b5fe 32 72 ee			ld (debug_mark+1),a  
b601 3a 0b b6			ld a, (.dmark+2)  
b604 32 73 ee			ld (debug_mark+2),a  
b607 18 03			jr .pastdmark  
b609 ..			.dmark: db "MIN"  
b60c f1			.pastdmark: pop af  
b60d			endm  
# End of macro DMARK
b60d						CALLMONITOR 
b60d cd 9d 94			call break_point_state  
b610				endm  
# End of macro CALLMONITOR
b610					endif 
b610					; get u2 
b610			 
b610					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b610 cd 05 9d			call macro_dsp_valuehl 
b613				endm 
# End of macro FORTH_DSP_VALUEHL
b613			 
b613 e5					push hl   ; u2 
b614			 
b614					; destroy value TOS 
b614			 
b614					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b614 cd bd 9d			call macro_forth_dsp_pop 
b617				endm 
# End of macro FORTH_DSP_POP
b617			 
b617					; get u1 
b617			 
b617					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b617 cd 05 9d			call macro_dsp_valuehl 
b61a				endm 
# End of macro FORTH_DSP_VALUEHL
b61a			 
b61a e5					push hl  ; u1 
b61b			 
b61b					; destroy value TOS 
b61b			 
b61b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b61b cd bd 9d			call macro_forth_dsp_pop 
b61e				endm 
# End of macro FORTH_DSP_POP
b61e			 
b61e b7			 or a      ;clear carry flag 
b61f e1			  pop hl    ; u1 
b620 d1			  pop de    ; u2 
b621 e5				push hl   ; saved in case hl is lowest 
b622 ed 52		  sbc hl,de 
b624 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b626			 
b626 e1				pop hl 
b627					if DEBUG_FORTH_WORDS 
b627						DMARK "MIN" 
b627 f5				push af  
b628 3a 3c b6			ld a, (.dmark)  
b62b 32 71 ee			ld (debug_mark),a  
b62e 3a 3d b6			ld a, (.dmark+1)  
b631 32 72 ee			ld (debug_mark+1),a  
b634 3a 3e b6			ld a, (.dmark+2)  
b637 32 73 ee			ld (debug_mark+2),a  
b63a 18 03			jr .pastdmark  
b63c ..			.dmark: db "MIN"  
b63f f1			.pastdmark: pop af  
b640			endm  
# End of macro DMARK
b640						CALLMONITOR 
b640 cd 9d 94			call break_point_state  
b643				endm  
# End of macro CALLMONITOR
b643					endif 
b643 cd 0e 9b				call forth_push_numhl 
b646			 
b646				       NEXTW 
b646 c3 7c 9e			jp macro_next 
b649				endm 
# End of macro NEXTW
b649			 
b649			.mincont:  
b649 c1				pop bc   ; tidy up 
b64a eb				ex de , hl  
b64b					if DEBUG_FORTH_WORDS 
b64b						DMARK "MI1" 
b64b f5				push af  
b64c 3a 60 b6			ld a, (.dmark)  
b64f 32 71 ee			ld (debug_mark),a  
b652 3a 61 b6			ld a, (.dmark+1)  
b655 32 72 ee			ld (debug_mark+1),a  
b658 3a 62 b6			ld a, (.dmark+2)  
b65b 32 73 ee			ld (debug_mark+2),a  
b65e 18 03			jr .pastdmark  
b660 ..			.dmark: db "MI1"  
b663 f1			.pastdmark: pop af  
b664			endm  
# End of macro DMARK
b664						CALLMONITOR 
b664 cd 9d 94			call break_point_state  
b667				endm  
# End of macro CALLMONITOR
b667					endif 
b667 cd 0e 9b				call forth_push_numhl 
b66a			 
b66a				       NEXTW 
b66a c3 7c 9e			jp macro_next 
b66d				endm 
# End of macro NEXTW
b66d			.MAX: 
b66d				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b66d 4a				db WORD_SYS_CORE+54             
b66e ee b6			dw .RND16            
b670 04				db 3 + 1 
b671 .. 00			db "MAX",0              
b675				endm 
# End of macro CWHEAD
b675			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b675					if DEBUG_FORTH_WORDS_KEY 
b675						DMARK "MAX" 
b675 f5				push af  
b676 3a 8a b6			ld a, (.dmark)  
b679 32 71 ee			ld (debug_mark),a  
b67c 3a 8b b6			ld a, (.dmark+1)  
b67f 32 72 ee			ld (debug_mark+1),a  
b682 3a 8c b6			ld a, (.dmark+2)  
b685 32 73 ee			ld (debug_mark+2),a  
b688 18 03			jr .pastdmark  
b68a ..			.dmark: db "MAX"  
b68d f1			.pastdmark: pop af  
b68e			endm  
# End of macro DMARK
b68e						CALLMONITOR 
b68e cd 9d 94			call break_point_state  
b691				endm  
# End of macro CALLMONITOR
b691					endif 
b691					; get u2 
b691			 
b691					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b691 cd 05 9d			call macro_dsp_valuehl 
b694				endm 
# End of macro FORTH_DSP_VALUEHL
b694			 
b694 e5					push hl   ; u2 
b695			 
b695					; destroy value TOS 
b695			 
b695					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b695 cd bd 9d			call macro_forth_dsp_pop 
b698				endm 
# End of macro FORTH_DSP_POP
b698			 
b698					; get u1 
b698			 
b698					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b698 cd 05 9d			call macro_dsp_valuehl 
b69b				endm 
# End of macro FORTH_DSP_VALUEHL
b69b			 
b69b e5					push hl  ; u1 
b69c			 
b69c					; destroy value TOS 
b69c			 
b69c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b69c cd bd 9d			call macro_forth_dsp_pop 
b69f				endm 
# End of macro FORTH_DSP_POP
b69f			 
b69f b7			 or a      ;clear carry flag 
b6a0 e1			  pop hl    ; u1 
b6a1 d1			  pop de    ; u2 
b6a2 e5				push hl   ; saved in case hl is lowest 
b6a3 ed 52		  sbc hl,de 
b6a5 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b6a7			 
b6a7 e1				pop hl 
b6a8					if DEBUG_FORTH_WORDS 
b6a8						DMARK "MAX" 
b6a8 f5				push af  
b6a9 3a bd b6			ld a, (.dmark)  
b6ac 32 71 ee			ld (debug_mark),a  
b6af 3a be b6			ld a, (.dmark+1)  
b6b2 32 72 ee			ld (debug_mark+1),a  
b6b5 3a bf b6			ld a, (.dmark+2)  
b6b8 32 73 ee			ld (debug_mark+2),a  
b6bb 18 03			jr .pastdmark  
b6bd ..			.dmark: db "MAX"  
b6c0 f1			.pastdmark: pop af  
b6c1			endm  
# End of macro DMARK
b6c1						CALLMONITOR 
b6c1 cd 9d 94			call break_point_state  
b6c4				endm  
# End of macro CALLMONITOR
b6c4					endif 
b6c4 cd 0e 9b				call forth_push_numhl 
b6c7			 
b6c7				       NEXTW 
b6c7 c3 7c 9e			jp macro_next 
b6ca				endm 
# End of macro NEXTW
b6ca			 
b6ca			.maxcont:  
b6ca c1				pop bc   ; tidy up 
b6cb eb				ex de , hl  
b6cc					if DEBUG_FORTH_WORDS 
b6cc						DMARK "MA1" 
b6cc f5				push af  
b6cd 3a e1 b6			ld a, (.dmark)  
b6d0 32 71 ee			ld (debug_mark),a  
b6d3 3a e2 b6			ld a, (.dmark+1)  
b6d6 32 72 ee			ld (debug_mark+1),a  
b6d9 3a e3 b6			ld a, (.dmark+2)  
b6dc 32 73 ee			ld (debug_mark+2),a  
b6df 18 03			jr .pastdmark  
b6e1 ..			.dmark: db "MA1"  
b6e4 f1			.pastdmark: pop af  
b6e5			endm  
# End of macro DMARK
b6e5						CALLMONITOR 
b6e5 cd 9d 94			call break_point_state  
b6e8				endm  
# End of macro CALLMONITOR
b6e8					endif 
b6e8 cd 0e 9b				call forth_push_numhl 
b6eb				       NEXTW 
b6eb c3 7c 9e			jp macro_next 
b6ee				endm 
# End of macro NEXTW
b6ee			 
b6ee			.RND16: 
b6ee				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b6ee 4e				db WORD_SYS_CORE+58             
b6ef 1d b7			dw .RND8            
b6f1 06				db 5 + 1 
b6f2 .. 00			db "RND16",0              
b6f8				endm 
# End of macro CWHEAD
b6f8			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b6f8					if DEBUG_FORTH_WORDS_KEY 
b6f8						DMARK "R16" 
b6f8 f5				push af  
b6f9 3a 0d b7			ld a, (.dmark)  
b6fc 32 71 ee			ld (debug_mark),a  
b6ff 3a 0e b7			ld a, (.dmark+1)  
b702 32 72 ee			ld (debug_mark+1),a  
b705 3a 0f b7			ld a, (.dmark+2)  
b708 32 73 ee			ld (debug_mark+2),a  
b70b 18 03			jr .pastdmark  
b70d ..			.dmark: db "R16"  
b710 f1			.pastdmark: pop af  
b711			endm  
# End of macro DMARK
b711						CALLMONITOR 
b711 cd 9d 94			call break_point_state  
b714				endm  
# End of macro CALLMONITOR
b714					endif 
b714 cd c3 8b				call prng16  
b717 cd 0e 9b				call forth_push_numhl 
b71a				       NEXTW 
b71a c3 7c 9e			jp macro_next 
b71d				endm 
# End of macro NEXTW
b71d			.RND8: 
b71d				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b71d 60				db WORD_SYS_CORE+76             
b71e 52 b7			dw .RND            
b720 05				db 4 + 1 
b721 .. 00			db "RND8",0              
b726				endm 
# End of macro CWHEAD
b726			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b726					if DEBUG_FORTH_WORDS_KEY 
b726						DMARK "RN8" 
b726 f5				push af  
b727 3a 3b b7			ld a, (.dmark)  
b72a 32 71 ee			ld (debug_mark),a  
b72d 3a 3c b7			ld a, (.dmark+1)  
b730 32 72 ee			ld (debug_mark+1),a  
b733 3a 3d b7			ld a, (.dmark+2)  
b736 32 73 ee			ld (debug_mark+2),a  
b739 18 03			jr .pastdmark  
b73b ..			.dmark: db "RN8"  
b73e f1			.pastdmark: pop af  
b73f			endm  
# End of macro DMARK
b73f						CALLMONITOR 
b73f cd 9d 94			call break_point_state  
b742				endm  
# End of macro CALLMONITOR
b742					endif 
b742 2a b2 eb				ld hl,(xrandc) 
b745 23					inc hl 
b746 cd dd 8b				call xrnd 
b749 6f					ld l,a	 
b74a 26 00				ld h,0 
b74c cd 0e 9b				call forth_push_numhl 
b74f				       NEXTW 
b74f c3 7c 9e			jp macro_next 
b752				endm 
# End of macro NEXTW
b752			.RND: 
b752				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b752 60				db WORD_SYS_CORE+76             
b753 58 b8			dw .ENDMATHS            
b755 04				db 3 + 1 
b756 .. 00			db "RND",0              
b75a				endm 
# End of macro CWHEAD
b75a			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b75a			 
b75a					if DEBUG_FORTH_WORDS_KEY 
b75a						DMARK "RND" 
b75a f5				push af  
b75b 3a 6f b7			ld a, (.dmark)  
b75e 32 71 ee			ld (debug_mark),a  
b761 3a 70 b7			ld a, (.dmark+1)  
b764 32 72 ee			ld (debug_mark+1),a  
b767 3a 71 b7			ld a, (.dmark+2)  
b76a 32 73 ee			ld (debug_mark+2),a  
b76d 18 03			jr .pastdmark  
b76f ..			.dmark: db "RND"  
b772 f1			.pastdmark: pop af  
b773			endm  
# End of macro DMARK
b773						CALLMONITOR 
b773 cd 9d 94			call break_point_state  
b776				endm  
# End of macro CALLMONITOR
b776					endif 
b776					 
b776					FORTH_DSP_VALUEHL    ; upper range 
b776 cd 05 9d			call macro_dsp_valuehl 
b779				endm 
# End of macro FORTH_DSP_VALUEHL
b779			 
b779 22 b6 eb				ld (LFSRSeed), hl	 
b77c			 
b77c					if DEBUG_FORTH_WORDS 
b77c						DMARK "RN1" 
b77c f5				push af  
b77d 3a 91 b7			ld a, (.dmark)  
b780 32 71 ee			ld (debug_mark),a  
b783 3a 92 b7			ld a, (.dmark+1)  
b786 32 72 ee			ld (debug_mark+1),a  
b789 3a 93 b7			ld a, (.dmark+2)  
b78c 32 73 ee			ld (debug_mark+2),a  
b78f 18 03			jr .pastdmark  
b791 ..			.dmark: db "RN1"  
b794 f1			.pastdmark: pop af  
b795			endm  
# End of macro DMARK
b795						CALLMONITOR 
b795 cd 9d 94			call break_point_state  
b798				endm  
# End of macro CALLMONITOR
b798					endif 
b798					FORTH_DSP_POP 
b798 cd bd 9d			call macro_forth_dsp_pop 
b79b				endm 
# End of macro FORTH_DSP_POP
b79b			 
b79b					FORTH_DSP_VALUEHL    ; low range 
b79b cd 05 9d			call macro_dsp_valuehl 
b79e				endm 
# End of macro FORTH_DSP_VALUEHL
b79e			 
b79e					if DEBUG_FORTH_WORDS 
b79e						DMARK "RN2" 
b79e f5				push af  
b79f 3a b3 b7			ld a, (.dmark)  
b7a2 32 71 ee			ld (debug_mark),a  
b7a5 3a b4 b7			ld a, (.dmark+1)  
b7a8 32 72 ee			ld (debug_mark+1),a  
b7ab 3a b5 b7			ld a, (.dmark+2)  
b7ae 32 73 ee			ld (debug_mark+2),a  
b7b1 18 03			jr .pastdmark  
b7b3 ..			.dmark: db "RN2"  
b7b6 f1			.pastdmark: pop af  
b7b7			endm  
# End of macro DMARK
b7b7						CALLMONITOR 
b7b7 cd 9d 94			call break_point_state  
b7ba				endm  
# End of macro CALLMONITOR
b7ba					endif 
b7ba 22 b8 eb				ld (LFSRSeed+2), hl 
b7bd			 
b7bd					FORTH_DSP_POP 
b7bd cd bd 9d			call macro_forth_dsp_pop 
b7c0				endm 
# End of macro FORTH_DSP_POP
b7c0			 
b7c0 e5					push hl 
b7c1			 
b7c1 e1			.inrange:	pop hl 
b7c2 cd c3 8b				call prng16  
b7c5					if DEBUG_FORTH_WORDS 
b7c5						DMARK "RN3" 
b7c5 f5				push af  
b7c6 3a da b7			ld a, (.dmark)  
b7c9 32 71 ee			ld (debug_mark),a  
b7cc 3a db b7			ld a, (.dmark+1)  
b7cf 32 72 ee			ld (debug_mark+1),a  
b7d2 3a dc b7			ld a, (.dmark+2)  
b7d5 32 73 ee			ld (debug_mark+2),a  
b7d8 18 03			jr .pastdmark  
b7da ..			.dmark: db "RN3"  
b7dd f1			.pastdmark: pop af  
b7de			endm  
# End of macro DMARK
b7de						CALLMONITOR 
b7de cd 9d 94			call break_point_state  
b7e1				endm  
# End of macro CALLMONITOR
b7e1					endif 
b7e1					 
b7e1					; if the range is 8bit knock out the high byte 
b7e1			 
b7e1 ed 5b b6 eb			ld de, (LFSRSeed)     ; check high level 
b7e5			 
b7e5 3e 00				ld a, 0 
b7e7 ba					cp d  
b7e8 20 1e				jr nz, .hirange 
b7ea 26 00				ld h, 0   ; knock it down to 8bit 
b7ec			 
b7ec					if DEBUG_FORTH_WORDS 
b7ec						DMARK "RNk" 
b7ec f5				push af  
b7ed 3a 01 b8			ld a, (.dmark)  
b7f0 32 71 ee			ld (debug_mark),a  
b7f3 3a 02 b8			ld a, (.dmark+1)  
b7f6 32 72 ee			ld (debug_mark+1),a  
b7f9 3a 03 b8			ld a, (.dmark+2)  
b7fc 32 73 ee			ld (debug_mark+2),a  
b7ff 18 03			jr .pastdmark  
b801 ..			.dmark: db "RNk"  
b804 f1			.pastdmark: pop af  
b805			endm  
# End of macro DMARK
b805						CALLMONITOR 
b805 cd 9d 94			call break_point_state  
b808				endm  
# End of macro CALLMONITOR
b808					endif 
b808			.hirange:   
b808 e5					push hl  
b809 b7					or a  
b80a ed 52		                sbc hl, de 
b80c			 
b80c					;call cmp16 
b80c			 
b80c 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b80e e1					pop hl 
b80f e5					push hl 
b810			 
b810					if DEBUG_FORTH_WORDS 
b810						DMARK "RN4" 
b810 f5				push af  
b811 3a 25 b8			ld a, (.dmark)  
b814 32 71 ee			ld (debug_mark),a  
b817 3a 26 b8			ld a, (.dmark+1)  
b81a 32 72 ee			ld (debug_mark+1),a  
b81d 3a 27 b8			ld a, (.dmark+2)  
b820 32 73 ee			ld (debug_mark+2),a  
b823 18 03			jr .pastdmark  
b825 ..			.dmark: db "RN4"  
b828 f1			.pastdmark: pop af  
b829			endm  
# End of macro DMARK
b829						CALLMONITOR 
b829 cd 9d 94			call break_point_state  
b82c				endm  
# End of macro CALLMONITOR
b82c					endif 
b82c ed 5b b8 eb			ld de, (LFSRSeed+2)   ; check low range 
b830					;call cmp16 
b830				 
b830 b7					or a  
b831 ed 52		                sbc hl, de 
b833 38 8c				jr c, .inrange 
b835			 
b835 e1					pop hl 
b836					 
b836					if DEBUG_FORTH_WORDS 
b836						DMARK "RNd" 
b836 f5				push af  
b837 3a 4b b8			ld a, (.dmark)  
b83a 32 71 ee			ld (debug_mark),a  
b83d 3a 4c b8			ld a, (.dmark+1)  
b840 32 72 ee			ld (debug_mark+1),a  
b843 3a 4d b8			ld a, (.dmark+2)  
b846 32 73 ee			ld (debug_mark+2),a  
b849 18 03			jr .pastdmark  
b84b ..			.dmark: db "RNd"  
b84e f1			.pastdmark: pop af  
b84f			endm  
# End of macro DMARK
b84f						CALLMONITOR 
b84f cd 9d 94			call break_point_state  
b852				endm  
# End of macro CALLMONITOR
b852					endif 
b852			 
b852			 
b852 cd 0e 9b				call forth_push_numhl 
b855				       NEXTW 
b855 c3 7c 9e			jp macro_next 
b858				endm 
# End of macro NEXTW
b858			 
b858			.ENDMATHS: 
b858			 
b858			; eof 
b858			 
# End of file forth_words_maths.asm
b858			include "forth_words_display.asm" 
b858			 
b858			; | ## Display Words 
b858			 
b858			.INFO: 
b858			 
b858				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b858 62				db WORD_SYS_CORE+78             
b859 75 b8			dw .ATP            
b85b 05				db 4 + 1 
b85c .. 00			db "INFO",0              
b861				endm 
# End of macro CWHEAD
b861			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b861					FORTH_DSP_VALUEHL 
b861 cd 05 9d			call macro_dsp_valuehl 
b864				endm 
# End of macro FORTH_DSP_VALUEHL
b864			 
b864					FORTH_DSP_POP 
b864 cd bd 9d			call macro_forth_dsp_pop 
b867				endm 
# End of macro FORTH_DSP_POP
b867			 
b867 e5					push hl 
b868			 
b868					FORTH_DSP_VALUEHL 
b868 cd 05 9d			call macro_dsp_valuehl 
b86b				endm 
# End of macro FORTH_DSP_VALUEHL
b86b			 
b86b					FORTH_DSP_POP 
b86b cd bd 9d			call macro_forth_dsp_pop 
b86e				endm 
# End of macro FORTH_DSP_POP
b86e			 
b86e d1					pop de 
b86f			 
b86f cd 00 8a				call info_panel 
b872			 
b872			 
b872					NEXTW 
b872 c3 7c 9e			jp macro_next 
b875				endm 
# End of macro NEXTW
b875			.ATP: 
b875				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b875 62				db WORD_SYS_CORE+78             
b876 ec b8			dw .FB            
b878 04				db 3 + 1 
b879 .. 00			db "AT?",0              
b87d				endm 
# End of macro CWHEAD
b87d			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b87d					if DEBUG_FORTH_WORDS_KEY 
b87d						DMARK "AT?" 
b87d f5				push af  
b87e 3a 92 b8			ld a, (.dmark)  
b881 32 71 ee			ld (debug_mark),a  
b884 3a 93 b8			ld a, (.dmark+1)  
b887 32 72 ee			ld (debug_mark+1),a  
b88a 3a 94 b8			ld a, (.dmark+2)  
b88d 32 73 ee			ld (debug_mark+2),a  
b890 18 03			jr .pastdmark  
b892 ..			.dmark: db "AT?"  
b895 f1			.pastdmark: pop af  
b896			endm  
# End of macro DMARK
b896						CALLMONITOR 
b896 cd 9d 94			call break_point_state  
b899				endm  
# End of macro CALLMONITOR
b899					endif 
b899 3a 6b ea				ld a, (f_cursor_ptr) 
b89c			 
b89c			if DEBUG_FORTH_WORDS 
b89c				DMARK "AT?" 
b89c f5				push af  
b89d 3a b1 b8			ld a, (.dmark)  
b8a0 32 71 ee			ld (debug_mark),a  
b8a3 3a b2 b8			ld a, (.dmark+1)  
b8a6 32 72 ee			ld (debug_mark+1),a  
b8a9 3a b3 b8			ld a, (.dmark+2)  
b8ac 32 73 ee			ld (debug_mark+2),a  
b8af 18 03			jr .pastdmark  
b8b1 ..			.dmark: db "AT?"  
b8b4 f1			.pastdmark: pop af  
b8b5			endm  
# End of macro DMARK
b8b5				CALLMONITOR 
b8b5 cd 9d 94			call break_point_state  
b8b8				endm  
# End of macro CALLMONITOR
b8b8			endif	 
b8b8					; count the number of rows 
b8b8			 
b8b8 06 00				ld b, 0 
b8ba 4f			.atpr:		ld c, a    ; save in case we go below zero 
b8bb d6 28				sub display_cols 
b8bd f2 c3 b8				jp p, .atprunder 
b8c0 04					inc b 
b8c1 18 f7				jr .atpr 
b8c3			.atprunder:	 
b8c3			if DEBUG_FORTH_WORDS 
b8c3				DMARK "A?2" 
b8c3 f5				push af  
b8c4 3a d8 b8			ld a, (.dmark)  
b8c7 32 71 ee			ld (debug_mark),a  
b8ca 3a d9 b8			ld a, (.dmark+1)  
b8cd 32 72 ee			ld (debug_mark+1),a  
b8d0 3a da b8			ld a, (.dmark+2)  
b8d3 32 73 ee			ld (debug_mark+2),a  
b8d6 18 03			jr .pastdmark  
b8d8 ..			.dmark: db "A?2"  
b8db f1			.pastdmark: pop af  
b8dc			endm  
# End of macro DMARK
b8dc				CALLMONITOR 
b8dc cd 9d 94			call break_point_state  
b8df				endm  
# End of macro CALLMONITOR
b8df			endif	 
b8df 26 00				ld h, 0 
b8e1 69					ld l, c 
b8e2 cd 0e 9b				call forth_push_numhl 
b8e5 68					ld l, b  
b8e6 cd 0e 9b				call forth_push_numhl 
b8e9			 
b8e9			 
b8e9				NEXTW 
b8e9 c3 7c 9e			jp macro_next 
b8ec				endm 
# End of macro NEXTW
b8ec			 
b8ec			.FB: 
b8ec				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b8ec 1b				db WORD_SYS_CORE+7             
b8ed 3a b9			dw .EMIT            
b8ef 03				db 2 + 1 
b8f0 .. 00			db "FB",0              
b8f3				endm 
# End of macro CWHEAD
b8f3			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b8f3			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b8f3			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b8f3			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b8f3					if DEBUG_FORTH_WORDS_KEY 
b8f3						DMARK "FB." 
b8f3 f5				push af  
b8f4 3a 08 b9			ld a, (.dmark)  
b8f7 32 71 ee			ld (debug_mark),a  
b8fa 3a 09 b9			ld a, (.dmark+1)  
b8fd 32 72 ee			ld (debug_mark+1),a  
b900 3a 0a b9			ld a, (.dmark+2)  
b903 32 73 ee			ld (debug_mark+2),a  
b906 18 03			jr .pastdmark  
b908 ..			.dmark: db "FB."  
b90b f1			.pastdmark: pop af  
b90c			endm  
# End of macro DMARK
b90c						CALLMONITOR 
b90c cd 9d 94			call break_point_state  
b90f				endm  
# End of macro CALLMONITOR
b90f					endif 
b90f			 
b90f					FORTH_DSP_VALUEHL 
b90f cd 05 9d			call macro_dsp_valuehl 
b912				endm 
# End of macro FORTH_DSP_VALUEHL
b912			 
b912 7d					ld a, l 
b913 fe 01				cp 1 
b915 20 05				jr nz, .fbn1 
b917 21 16 ed				ld hl, display_fb1 
b91a 18 15				jr .fbset 
b91c fe 02		.fbn1:		cp 2 
b91e 20 05				jr nz, .fbn2 
b920 21 d4 eb				ld hl, display_fb2 
b923 18 0c				jr .fbset 
b925 fe 03		.fbn2:		cp 3 
b927 20 05				jr nz, .fbn3 
b929 21 75 ec				ld hl, display_fb3 
b92c 18 03				jr .fbset 
b92e			.fbn3:		 ; if invalid number select first 
b92e 21 16 ed				ld hl, display_fb1 
b931 22 d2 eb		.fbset:		ld (display_fb_active), hl 
b934			 
b934					FORTH_DSP_POP 
b934 cd bd 9d			call macro_forth_dsp_pop 
b937				endm 
# End of macro FORTH_DSP_POP
b937			 
b937					NEXTW 
b937 c3 7c 9e			jp macro_next 
b93a				endm 
# End of macro NEXTW
b93a			 
b93a			 
b93a			.EMIT: 
b93a				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b93a 1b				db WORD_SYS_CORE+7             
b93b 8b b9			dw .DOTH            
b93d 05				db 4 + 1 
b93e .. 00			db "EMIT",0              
b943				endm 
# End of macro CWHEAD
b943			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b943					; get value off TOS and display it 
b943			 
b943					if DEBUG_FORTH_WORDS_KEY 
b943						DMARK "EMT" 
b943 f5				push af  
b944 3a 58 b9			ld a, (.dmark)  
b947 32 71 ee			ld (debug_mark),a  
b94a 3a 59 b9			ld a, (.dmark+1)  
b94d 32 72 ee			ld (debug_mark+1),a  
b950 3a 5a b9			ld a, (.dmark+2)  
b953 32 73 ee			ld (debug_mark+2),a  
b956 18 03			jr .pastdmark  
b958 ..			.dmark: db "EMT"  
b95b f1			.pastdmark: pop af  
b95c			endm  
# End of macro DMARK
b95c						CALLMONITOR 
b95c cd 9d 94			call break_point_state  
b95f				endm  
# End of macro CALLMONITOR
b95f					endif 
b95f			 
b95f					FORTH_DSP_VALUEHL 
b95f cd 05 9d			call macro_dsp_valuehl 
b962				endm 
# End of macro FORTH_DSP_VALUEHL
b962			 
b962 7d					ld a,l 
b963			 
b963					; TODO write to display 
b963			 
b963 32 00 e5				ld (os_input), a 
b966 3e 00				ld a, 0 
b968 32 01 e5				ld (os_input+1), a 
b96b					 
b96b 3a 6b ea				ld a, (f_cursor_ptr) 
b96e 11 00 e5				ld de, os_input 
b971 cd 82 8a				call str_at_display 
b974			 
b974			 
b974 3a 49 ea				ld a,(cli_autodisplay) 
b977 fe 00				cp 0 
b979 28 03				jr z, .enoupdate 
b97b cd 92 8a						call update_display 
b97e					.enoupdate: 
b97e			 
b97e 3a 6b ea				ld a, (f_cursor_ptr) 
b981 3c					inc a 
b982 32 6b ea				ld (f_cursor_ptr), a   ; save new pos 
b985			 
b985			 
b985					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b985 cd bd 9d			call macro_forth_dsp_pop 
b988				endm 
# End of macro FORTH_DSP_POP
b988			  
b988			 
b988					NEXTW 
b988 c3 7c 9e			jp macro_next 
b98b				endm 
# End of macro NEXTW
b98b			.DOTH: 
b98b				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b98b 1c				db WORD_SYS_CORE+8             
b98c bb b9			dw .DOTF            
b98e 03				db 2 + 1 
b98f .. 00			db ".-",0              
b992				endm 
# End of macro CWHEAD
b992			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b992					; get value off TOS and display it 
b992					if DEBUG_FORTH_WORDS_KEY 
b992						DMARK "DTD" 
b992 f5				push af  
b993 3a a7 b9			ld a, (.dmark)  
b996 32 71 ee			ld (debug_mark),a  
b999 3a a8 b9			ld a, (.dmark+1)  
b99c 32 72 ee			ld (debug_mark+1),a  
b99f 3a a9 b9			ld a, (.dmark+2)  
b9a2 32 73 ee			ld (debug_mark+2),a  
b9a5 18 03			jr .pastdmark  
b9a7 ..			.dmark: db "DTD"  
b9aa f1			.pastdmark: pop af  
b9ab			endm  
# End of macro DMARK
b9ab						CALLMONITOR 
b9ab cd 9d 94			call break_point_state  
b9ae				endm  
# End of macro CALLMONITOR
b9ae					endif 
b9ae 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
b9b0 3e 00			ld a, 0 
b9b2 32 4a ea			ld (cli_mvdot), a 
b9b5 c3 12 ba			jp .dotgo 
b9b8				NEXTW 
b9b8 c3 7c 9e			jp macro_next 
b9bb				endm 
# End of macro NEXTW
b9bb			.DOTF: 
b9bb				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
b9bb 1c				db WORD_SYS_CORE+8             
b9bc e9 b9			dw .DOT            
b9be 03				db 2 + 1 
b9bf .. 00			db ".>",0              
b9c2				endm 
# End of macro CWHEAD
b9c2			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
b9c2					; get value off TOS and display it 
b9c2			        ; TODO BUG adds extra spaces 
b9c2			        ; TODO BUG handle numerics? 
b9c2					if DEBUG_FORTH_WORDS_KEY 
b9c2						DMARK "DTC" 
b9c2 f5				push af  
b9c3 3a d7 b9			ld a, (.dmark)  
b9c6 32 71 ee			ld (debug_mark),a  
b9c9 3a d8 b9			ld a, (.dmark+1)  
b9cc 32 72 ee			ld (debug_mark+1),a  
b9cf 3a d9 b9			ld a, (.dmark+2)  
b9d2 32 73 ee			ld (debug_mark+2),a  
b9d5 18 03			jr .pastdmark  
b9d7 ..			.dmark: db "DTC"  
b9da f1			.pastdmark: pop af  
b9db			endm  
# End of macro DMARK
b9db						CALLMONITOR 
b9db cd 9d 94			call break_point_state  
b9de				endm  
# End of macro CALLMONITOR
b9de					endif 
b9de 3e 01			ld a, 1 
b9e0 32 4a ea			ld (cli_mvdot), a 
b9e3 c3 12 ba			jp .dotgo 
b9e6				NEXTW 
b9e6 c3 7c 9e			jp macro_next 
b9e9				endm 
# End of macro NEXTW
b9e9			 
b9e9			.DOT: 
b9e9				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
b9e9 1c				db WORD_SYS_CORE+8             
b9ea 75 ba			dw .CLS            
b9ec 02				db 1 + 1 
b9ed .. 00			db ".",0              
b9ef				endm 
# End of macro CWHEAD
b9ef			        ; | . ( u -- ) Display TOS | DONE 
b9ef					; get value off TOS and display it 
b9ef			 
b9ef					if DEBUG_FORTH_WORDS_KEY 
b9ef						DMARK "DOT" 
b9ef f5				push af  
b9f0 3a 04 ba			ld a, (.dmark)  
b9f3 32 71 ee			ld (debug_mark),a  
b9f6 3a 05 ba			ld a, (.dmark+1)  
b9f9 32 72 ee			ld (debug_mark+1),a  
b9fc 3a 06 ba			ld a, (.dmark+2)  
b9ff 32 73 ee			ld (debug_mark+2),a  
ba02 18 03			jr .pastdmark  
ba04 ..			.dmark: db "DOT"  
ba07 f1			.pastdmark: pop af  
ba08			endm  
# End of macro DMARK
ba08						CALLMONITOR 
ba08 cd 9d 94			call break_point_state  
ba0b				endm  
# End of macro CALLMONITOR
ba0b					endif 
ba0b 3e 00			ld a, 0 
ba0d 32 4a ea			ld (cli_mvdot), a 
ba10 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
ba12				 
ba12			 
ba12			.dotgo: 
ba12			 
ba12			; move up type to on stack for parserv5 
ba12					FORTH_DSP 
ba12 cd cb 9c			call macro_forth_dsp 
ba15				endm 
# End of macro FORTH_DSP
ba15				;FORTH_DSP_VALUE  
ba15			 
ba15			if DEBUG_FORTH_DOT 
ba15				DMARK "DOT" 
ba15				CALLMONITOR 
ba15			endif	 
ba15			;		.print: 
ba15			 
ba15 7e				ld a,(hl)  ; work out what type of value is on the TOS 
ba16 23				inc hl   ; position to the actual value 
ba17 fe 01			cp DS_TYPE_STR 
ba19 20 06			jr nz, .dotnum1  
ba1b			 
ba1b			; display string 
ba1b				FORTH_DSP_VALUE  
ba1b cd ee 9c			call macro_forth_dsp_value 
ba1e				endm 
# End of macro FORTH_DSP_VALUE
ba1e eb				ex de,hl 
ba1f 18 11			jr .dotwrite 
ba21			 
ba21			.dotnum1: 
ba21 fe 02			cp DS_TYPE_INUM 
ba23 20 0c			jr nz, .dotflot 
ba25			 
ba25			 
ba25			; display number 
ba25			 
ba25			;	push hl 
ba25			;	call clear_display 
ba25			;	pop hl 
ba25			 
ba25 5e				ld e, (hl) 
ba26 23				inc hl 
ba27 56				ld d, (hl) 
ba28 21 02 e3			ld hl, scratch 
ba2b			if DEBUG_FORTH_DOT 
ba2b				DMARK "DT1" 
ba2b				CALLMONITOR 
ba2b			endif	 
ba2b			 
ba2b cd a9 90			call uitoa_16 
ba2e eb				ex de,hl 
ba2f			 
ba2f			if DEBUG_FORTH_DOT 
ba2f				DMARK "DT2" 
ba2f				CALLMONITOR 
ba2f			endif	 
ba2f			 
ba2f			;	ld de, os_word_scratch 
ba2f 18 01			jr .dotwrite 
ba31			 
ba31 00			.dotflot:   nop 
ba32			; TODO print floating point number 
ba32			 
ba32			.dotwrite:		 
ba32			 
ba32					; if c is set then set all '-' to spaces 
ba32					; need to also take into account .>  
ba32			 
ba32 3e 01				ld a, 1 
ba34 b9					cp c 
ba35 20 13				jr nz, .nodashswap 
ba37			 
ba37					; DE has the string to write, working with HL 
ba37			 
ba37 06 ff				ld b, 255 
ba39 d5					push de 
ba3a e1					pop hl 
ba3b			 
ba3b			if DEBUG_FORTH_DOT 
ba3b				DMARK "DT-" 
ba3b				CALLMONITOR 
ba3b			endif	 
ba3b 7e			.dashscan:	ld a, (hl) 
ba3c fe 00				cp 0 
ba3e 28 0a				jr z, .nodashswap 
ba40 fe 2d				cp '-' 
ba42 20 03				jr nz, .dashskip 
ba44 3e 20				ld a, ' ' 
ba46 77					ld (hl), a 
ba47 23			.dashskip:	inc hl 
ba48			if DEBUG_FORTH_DOT 
ba48				DMARK "D-2" 
ba48				CALLMONITOR 
ba48			endif	 
ba48 10 f1				djnz .dashscan 
ba4a			 
ba4a			if DEBUG_FORTH_DOT 
ba4a				DMARK "D-1" 
ba4a				CALLMONITOR 
ba4a			endif	 
ba4a			 
ba4a			.nodashswap: 
ba4a			 
ba4a e5					push hl   ; save string start in case we need to advance print 
ba4b			 
ba4b 3a 6b ea				ld a, (f_cursor_ptr) 
ba4e cd 82 8a				call str_at_display 
ba51 3a 49 ea				ld a,(cli_autodisplay) 
ba54 fe 00				cp 0 
ba56 28 03				jr z, .noupdate 
ba58 cd 92 8a						call update_display 
ba5b					.noupdate: 
ba5b			 
ba5b			 
ba5b					; see if we need to advance the print position 
ba5b			 
ba5b e1					pop hl   ; get back string 
ba5c			 
ba5c 3a 4a ea				ld a, (cli_mvdot) 
ba5f			if DEBUG_FORTH_DOT 
ba5f					ld e,a 
ba5f				DMARK "D>1" 
ba5f				CALLMONITOR 
ba5f			endif	 
ba5f fe 00				cp 0 
ba61 28 0c				jr z, .noadv 
ba63					; yes, lets advance the print position 
ba63 3e 00				ld a, 0 
ba65 cd 05 91				call strlent 
ba68 3a 6b ea				ld a, (f_cursor_ptr) 
ba6b 85					add a,l 
ba6c					;call addatohl 
ba6c					;ld a, l 
ba6c 32 6b ea				ld (f_cursor_ptr), a   ; save new pos 
ba6f			 
ba6f			if DEBUG_FORTH_DOT 
ba6f				DMARK "D->" 
ba6f				CALLMONITOR 
ba6f			endif	 
ba6f			 
ba6f			.noadv:	 
ba6f			 
ba6f					if DEBUG_FORTH_DOT_WAIT 
ba6f							call next_page_prompt 
ba6f					endif	 
ba6f			; TODO this pop off the stack causes a crash. i dont know why 
ba6f			 
ba6f			 
ba6f			if DEBUG_FORTH_DOT 
ba6f				DMARK "DTh" 
ba6f				CALLMONITOR 
ba6f			endif	 
ba6f			 
ba6f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba6f cd bd 9d			call macro_forth_dsp_pop 
ba72				endm 
# End of macro FORTH_DSP_POP
ba72			 
ba72			if DEBUG_FORTH_DOT 
ba72				DMARK "DTi" 
ba72				CALLMONITOR 
ba72			endif	 
ba72			 
ba72			 
ba72					NEXTW 
ba72 c3 7c 9e			jp macro_next 
ba75				endm 
# End of macro NEXTW
ba75			 
ba75			.CLS: 
ba75				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
ba75 35				db WORD_SYS_CORE+33             
ba76 a2 ba			dw .DRAW            
ba78 04				db 3 + 1 
ba79 .. 00			db "CLS",0              
ba7d				endm 
# End of macro CWHEAD
ba7d			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
ba7d					if DEBUG_FORTH_WORDS_KEY 
ba7d						DMARK "CLS" 
ba7d f5				push af  
ba7e 3a 92 ba			ld a, (.dmark)  
ba81 32 71 ee			ld (debug_mark),a  
ba84 3a 93 ba			ld a, (.dmark+1)  
ba87 32 72 ee			ld (debug_mark+1),a  
ba8a 3a 94 ba			ld a, (.dmark+2)  
ba8d 32 73 ee			ld (debug_mark+2),a  
ba90 18 03			jr .pastdmark  
ba92 ..			.dmark: db "CLS"  
ba95 f1			.pastdmark: pop af  
ba96			endm  
# End of macro DMARK
ba96						CALLMONITOR 
ba96 cd 9d 94			call break_point_state  
ba99				endm  
# End of macro CALLMONITOR
ba99					endif 
ba99 cd 6f 8a				call clear_display 
ba9c c3 b0 bb				jp .home		; and home cursor 
ba9f					NEXTW 
ba9f c3 7c 9e			jp macro_next 
baa2				endm 
# End of macro NEXTW
baa2			 
baa2			.DRAW: 
baa2				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
baa2 36				db WORD_SYS_CORE+34             
baa3 cd ba			dw .DUMP            
baa5 05				db 4 + 1 
baa6 .. 00			db "DRAW",0              
baab				endm 
# End of macro CWHEAD
baab			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
baab					if DEBUG_FORTH_WORDS_KEY 
baab						DMARK "DRW" 
baab f5				push af  
baac 3a c0 ba			ld a, (.dmark)  
baaf 32 71 ee			ld (debug_mark),a  
bab2 3a c1 ba			ld a, (.dmark+1)  
bab5 32 72 ee			ld (debug_mark+1),a  
bab8 3a c2 ba			ld a, (.dmark+2)  
babb 32 73 ee			ld (debug_mark+2),a  
babe 18 03			jr .pastdmark  
bac0 ..			.dmark: db "DRW"  
bac3 f1			.pastdmark: pop af  
bac4			endm  
# End of macro DMARK
bac4						CALLMONITOR 
bac4 cd 9d 94			call break_point_state  
bac7				endm  
# End of macro CALLMONITOR
bac7					endif 
bac7 cd 92 8a				call update_display 
baca					NEXTW 
baca c3 7c 9e			jp macro_next 
bacd				endm 
# End of macro NEXTW
bacd			 
bacd			.DUMP: 
bacd				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
bacd 37				db WORD_SYS_CORE+35             
bace 05 bb			dw .CDUMP            
bad0 05				db 4 + 1 
bad1 .. 00			db "DUMP",0              
bad6				endm 
# End of macro CWHEAD
bad6			; | DUMP ( x -- ) With address x display dump   | DONE 
bad6			; TODO pop address to use off of the stack 
bad6					if DEBUG_FORTH_WORDS_KEY 
bad6						DMARK "DUM" 
bad6 f5				push af  
bad7 3a eb ba			ld a, (.dmark)  
bada 32 71 ee			ld (debug_mark),a  
badd 3a ec ba			ld a, (.dmark+1)  
bae0 32 72 ee			ld (debug_mark+1),a  
bae3 3a ed ba			ld a, (.dmark+2)  
bae6 32 73 ee			ld (debug_mark+2),a  
bae9 18 03			jr .pastdmark  
baeb ..			.dmark: db "DUM"  
baee f1			.pastdmark: pop af  
baef			endm  
# End of macro DMARK
baef						CALLMONITOR 
baef cd 9d 94			call break_point_state  
baf2				endm  
# End of macro CALLMONITOR
baf2					endif 
baf2 cd 6f 8a				call clear_display 
baf5			 
baf5					; get address 
baf5			 
baf5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
baf5 cd 05 9d			call macro_dsp_valuehl 
baf8				endm 
# End of macro FORTH_DSP_VALUEHL
baf8				 
baf8					; save it for cdump 
baf8			 
baf8 22 25 e6				ld (os_cur_ptr),hl 
bafb			 
bafb					; destroy value TOS 
bafb			 
bafb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bafb cd bd 9d			call macro_forth_dsp_pop 
bafe				endm 
# End of macro FORTH_DSP_POP
bafe			 
bafe cd 8e 99				call dumpcont	; skip old style of param parsing	 
bb01 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
bb02					NEXTW 
bb02 c3 7c 9e			jp macro_next 
bb05				endm 
# End of macro NEXTW
bb05			.CDUMP: 
bb05				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
bb05 38				db WORD_SYS_CORE+36             
bb06 35 bb			dw .DAT            
bb08 06				db 5 + 1 
bb09 .. 00			db "CDUMP",0              
bb0f				endm 
# End of macro CWHEAD
bb0f			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
bb0f					if DEBUG_FORTH_WORDS_KEY 
bb0f						DMARK "CDP" 
bb0f f5				push af  
bb10 3a 24 bb			ld a, (.dmark)  
bb13 32 71 ee			ld (debug_mark),a  
bb16 3a 25 bb			ld a, (.dmark+1)  
bb19 32 72 ee			ld (debug_mark+1),a  
bb1c 3a 26 bb			ld a, (.dmark+2)  
bb1f 32 73 ee			ld (debug_mark+2),a  
bb22 18 03			jr .pastdmark  
bb24 ..			.dmark: db "CDP"  
bb27 f1			.pastdmark: pop af  
bb28			endm  
# End of macro DMARK
bb28						CALLMONITOR 
bb28 cd 9d 94			call break_point_state  
bb2b				endm  
# End of macro CALLMONITOR
bb2b					endif 
bb2b cd 6f 8a				call clear_display 
bb2e cd 8e 99				call dumpcont	 
bb31 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
bb32					NEXTW 
bb32 c3 7c 9e			jp macro_next 
bb35				endm 
# End of macro NEXTW
bb35			 
bb35			 
bb35			 
bb35			 
bb35			.DAT: 
bb35				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
bb35 3d				db WORD_SYS_CORE+41             
bb36 8b bb			dw .HOME            
bb38 03				db 2 + 1 
bb39 .. 00			db "AT",0              
bb3c				endm 
# End of macro CWHEAD
bb3c			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
bb3c					if DEBUG_FORTH_WORDS_KEY 
bb3c						DMARK "AT." 
bb3c f5				push af  
bb3d 3a 51 bb			ld a, (.dmark)  
bb40 32 71 ee			ld (debug_mark),a  
bb43 3a 52 bb			ld a, (.dmark+1)  
bb46 32 72 ee			ld (debug_mark+1),a  
bb49 3a 53 bb			ld a, (.dmark+2)  
bb4c 32 73 ee			ld (debug_mark+2),a  
bb4f 18 03			jr .pastdmark  
bb51 ..			.dmark: db "AT."  
bb54 f1			.pastdmark: pop af  
bb55			endm  
# End of macro DMARK
bb55						CALLMONITOR 
bb55 cd 9d 94			call break_point_state  
bb58				endm  
# End of macro CALLMONITOR
bb58					endif 
bb58					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb58 cd 05 9d			call macro_dsp_valuehl 
bb5b				endm 
# End of macro FORTH_DSP_VALUEHL
bb5b			 
bb5b			 
bb5b					; TODO save cursor row 
bb5b 7d					ld a,l 
bb5c fe 02				cp 2 
bb5e 20 04				jr nz, .crow3 
bb60 3e 28				ld a, display_row_2 
bb62 18 12				jr .ccol1 
bb64 fe 03		.crow3:		cp 3 
bb66 20 04				jr nz, .crow4 
bb68 3e 50				ld a, display_row_3 
bb6a 18 0a				jr .ccol1 
bb6c fe 04		.crow4:		cp 4 
bb6e 20 04				jr nz, .crow1 
bb70 3e 78				ld a, display_row_4 
bb72 18 02				jr .ccol1 
bb74 3e 00		.crow1:		ld a,display_row_1 
bb76 f5			.ccol1:		push af			; got row offset 
bb77 6f					ld l,a 
bb78 26 00				ld h,0 
bb7a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb7a cd bd 9d			call macro_forth_dsp_pop 
bb7d				endm 
# End of macro FORTH_DSP_POP
bb7d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb7d cd 05 9d			call macro_dsp_valuehl 
bb80				endm 
# End of macro FORTH_DSP_VALUEHL
bb80					; TODO save cursor col 
bb80 f1					pop af 
bb81 85					add l		; add col offset 
bb82 32 6b ea				ld (f_cursor_ptr), a 
bb85					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb85 cd bd 9d			call macro_forth_dsp_pop 
bb88				endm 
# End of macro FORTH_DSP_POP
bb88			 
bb88					; calculate  
bb88			 
bb88					NEXTW 
bb88 c3 7c 9e			jp macro_next 
bb8b				endm 
# End of macro NEXTW
bb8b			 
bb8b			 
bb8b			.HOME: 
bb8b				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
bb8b 41				db WORD_SYS_CORE+45             
bb8c b8 bb			dw .SPACE            
bb8e 05				db 4 + 1 
bb8f .. 00			db "HOME",0              
bb94				endm 
# End of macro CWHEAD
bb94			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
bb94					if DEBUG_FORTH_WORDS_KEY 
bb94						DMARK "HOM" 
bb94 f5				push af  
bb95 3a a9 bb			ld a, (.dmark)  
bb98 32 71 ee			ld (debug_mark),a  
bb9b 3a aa bb			ld a, (.dmark+1)  
bb9e 32 72 ee			ld (debug_mark+1),a  
bba1 3a ab bb			ld a, (.dmark+2)  
bba4 32 73 ee			ld (debug_mark+2),a  
bba7 18 03			jr .pastdmark  
bba9 ..			.dmark: db "HOM"  
bbac f1			.pastdmark: pop af  
bbad			endm  
# End of macro DMARK
bbad						CALLMONITOR 
bbad cd 9d 94			call break_point_state  
bbb0				endm  
# End of macro CALLMONITOR
bbb0					endif 
bbb0 3e 00		.home:		ld a, 0		; and home cursor 
bbb2 32 6b ea				ld (f_cursor_ptr), a 
bbb5					NEXTW 
bbb5 c3 7c 9e			jp macro_next 
bbb8				endm 
# End of macro NEXTW
bbb8			 
bbb8			 
bbb8			.SPACE: 
bbb8				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
bbb8 46				db WORD_SYS_CORE+50             
bbb9 e6 bb			dw .SPACES            
bbbb 03				db 2 + 1 
bbbc .. 00			db "BL",0              
bbbf				endm 
# End of macro CWHEAD
bbbf			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
bbbf					if DEBUG_FORTH_WORDS_KEY 
bbbf						DMARK "BL." 
bbbf f5				push af  
bbc0 3a d4 bb			ld a, (.dmark)  
bbc3 32 71 ee			ld (debug_mark),a  
bbc6 3a d5 bb			ld a, (.dmark+1)  
bbc9 32 72 ee			ld (debug_mark+1),a  
bbcc 3a d6 bb			ld a, (.dmark+2)  
bbcf 32 73 ee			ld (debug_mark+2),a  
bbd2 18 03			jr .pastdmark  
bbd4 ..			.dmark: db "BL."  
bbd7 f1			.pastdmark: pop af  
bbd8			endm  
# End of macro DMARK
bbd8						CALLMONITOR 
bbd8 cd 9d 94			call break_point_state  
bbdb				endm  
# End of macro CALLMONITOR
bbdb					endif 
bbdb 21 e4 bb				ld hl, .blstr 
bbde cd 7c 9b				call forth_push_str 
bbe1					 
bbe1				       NEXTW 
bbe1 c3 7c 9e			jp macro_next 
bbe4				endm 
# End of macro NEXTW
bbe4			 
bbe4 .. 00		.blstr: db " ", 0 
bbe6			 
bbe6			.SPACES: 
bbe6				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
bbe6 47				db WORD_SYS_CORE+51             
bbe7 81 bc			dw .SCROLL            
bbe9 07				db 6 + 1 
bbea .. 00			db "SPACES",0              
bbf1				endm 
# End of macro CWHEAD
bbf1			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
bbf1					if DEBUG_FORTH_WORDS_KEY 
bbf1						DMARK "SPS" 
bbf1 f5				push af  
bbf2 3a 06 bc			ld a, (.dmark)  
bbf5 32 71 ee			ld (debug_mark),a  
bbf8 3a 07 bc			ld a, (.dmark+1)  
bbfb 32 72 ee			ld (debug_mark+1),a  
bbfe 3a 08 bc			ld a, (.dmark+2)  
bc01 32 73 ee			ld (debug_mark+2),a  
bc04 18 03			jr .pastdmark  
bc06 ..			.dmark: db "SPS"  
bc09 f1			.pastdmark: pop af  
bc0a			endm  
# End of macro DMARK
bc0a						CALLMONITOR 
bc0a cd 9d 94			call break_point_state  
bc0d				endm  
# End of macro CALLMONITOR
bc0d					endif 
bc0d			 
bc0d			 
bc0d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bc0d cd 05 9d			call macro_dsp_valuehl 
bc10				endm 
# End of macro FORTH_DSP_VALUEHL
bc10			 
bc10			;		push hl    ; u 
bc10					if DEBUG_FORTH_WORDS 
bc10						DMARK "SPA" 
bc10 f5				push af  
bc11 3a 25 bc			ld a, (.dmark)  
bc14 32 71 ee			ld (debug_mark),a  
bc17 3a 26 bc			ld a, (.dmark+1)  
bc1a 32 72 ee			ld (debug_mark+1),a  
bc1d 3a 27 bc			ld a, (.dmark+2)  
bc20 32 73 ee			ld (debug_mark+2),a  
bc23 18 03			jr .pastdmark  
bc25 ..			.dmark: db "SPA"  
bc28 f1			.pastdmark: pop af  
bc29			endm  
# End of macro DMARK
bc29						CALLMONITOR 
bc29 cd 9d 94			call break_point_state  
bc2c				endm  
# End of macro CALLMONITOR
bc2c					endif 
bc2c			 
bc2c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bc2c cd bd 9d			call macro_forth_dsp_pop 
bc2f				endm 
# End of macro FORTH_DSP_POP
bc2f			;		pop hl 
bc2f 4d					ld c, l 
bc30 06 00				ld b, 0 
bc32 21 02 e3				ld hl, scratch  
bc35			 
bc35					if DEBUG_FORTH_WORDS 
bc35						DMARK "SP2" 
bc35 f5				push af  
bc36 3a 4a bc			ld a, (.dmark)  
bc39 32 71 ee			ld (debug_mark),a  
bc3c 3a 4b bc			ld a, (.dmark+1)  
bc3f 32 72 ee			ld (debug_mark+1),a  
bc42 3a 4c bc			ld a, (.dmark+2)  
bc45 32 73 ee			ld (debug_mark+2),a  
bc48 18 03			jr .pastdmark  
bc4a ..			.dmark: db "SP2"  
bc4d f1			.pastdmark: pop af  
bc4e			endm  
# End of macro DMARK
bc4e						CALLMONITOR 
bc4e cd 9d 94			call break_point_state  
bc51				endm  
# End of macro CALLMONITOR
bc51					endif 
bc51 3e 20				ld a, ' ' 
bc53 c5			.spaces1:	push bc 
bc54 77					ld (hl),a 
bc55 23					inc hl 
bc56 c1					pop bc 
bc57 10 fa				djnz .spaces1 
bc59 3e 00				ld a,0 
bc5b 77					ld (hl),a 
bc5c 21 02 e3				ld hl, scratch 
bc5f					if DEBUG_FORTH_WORDS 
bc5f						DMARK "SP3" 
bc5f f5				push af  
bc60 3a 74 bc			ld a, (.dmark)  
bc63 32 71 ee			ld (debug_mark),a  
bc66 3a 75 bc			ld a, (.dmark+1)  
bc69 32 72 ee			ld (debug_mark+1),a  
bc6c 3a 76 bc			ld a, (.dmark+2)  
bc6f 32 73 ee			ld (debug_mark+2),a  
bc72 18 03			jr .pastdmark  
bc74 ..			.dmark: db "SP3"  
bc77 f1			.pastdmark: pop af  
bc78			endm  
# End of macro DMARK
bc78						CALLMONITOR 
bc78 cd 9d 94			call break_point_state  
bc7b				endm  
# End of macro CALLMONITOR
bc7b					endif 
bc7b cd 77 9c				call forth_apush 
bc7e			 
bc7e				       NEXTW 
bc7e c3 7c 9e			jp macro_next 
bc81				endm 
# End of macro NEXTW
bc81			 
bc81			 
bc81			 
bc81			.SCROLL: 
bc81				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
bc81 53				db WORD_SYS_CORE+63             
bc82 ae bc			dw .SCROLLD            
bc84 07				db 6 + 1 
bc85 .. 00			db "SCROLL",0              
bc8c				endm 
# End of macro CWHEAD
bc8c			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
bc8c					if DEBUG_FORTH_WORDS_KEY 
bc8c						DMARK "SCR" 
bc8c f5				push af  
bc8d 3a a1 bc			ld a, (.dmark)  
bc90 32 71 ee			ld (debug_mark),a  
bc93 3a a2 bc			ld a, (.dmark+1)  
bc96 32 72 ee			ld (debug_mark+1),a  
bc99 3a a3 bc			ld a, (.dmark+2)  
bc9c 32 73 ee			ld (debug_mark+2),a  
bc9f 18 03			jr .pastdmark  
bca1 ..			.dmark: db "SCR"  
bca4 f1			.pastdmark: pop af  
bca5			endm  
# End of macro DMARK
bca5						CALLMONITOR 
bca5 cd 9d 94			call break_point_state  
bca8				endm  
# End of macro CALLMONITOR
bca8					endif 
bca8			 
bca8 cd 31 8a			call scroll_up 
bcab			;	call update_display 
bcab			 
bcab					NEXTW 
bcab c3 7c 9e			jp macro_next 
bcae				endm 
# End of macro NEXTW
bcae			 
bcae			 
bcae			 
bcae			;		; get dir 
bcae			; 
bcae			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bcae			; 
bcae			;		push hl 
bcae			; 
bcae			;		; destroy value TOS 
bcae			; 
bcae			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bcae			; 
bcae			;		; get count 
bcae			; 
bcae			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bcae			; 
bcae			;		push hl 
bcae			; 
bcae			;		; destroy value TOS 
bcae			; 
bcae			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bcae			; 
bcae			;		; one value on hl get other one back 
bcae			; 
bcae			;		pop bc    ; count 
bcae			; 
bcae			;		pop de   ; dir 
bcae			; 
bcae			; 
bcae			;		ld b, c 
bcae			; 
bcae			;.scrolldir:     push bc 
bcae			;		push de 
bcae			; 
bcae			;		ld a, 0 
bcae			;		cp e 
bcae			;		jr z, .scrollup  
bcae			;		call scroll_down 
bcae			;		jr .scrollnext 
bcae			;.scrollup:	call scroll_up 
bcae			; 
bcae			;		 
bcae			;.scrollnext: 
bcae			;		pop de 
bcae			;		pop bc 
bcae			;		djnz .scrolldir 
bcae			; 
bcae			; 
bcae			; 
bcae			; 
bcae			; 
bcae			;		NEXTW 
bcae			 
bcae			.SCROLLD: 
bcae				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
bcae 53				db WORD_SYS_CORE+63             
bcaf dc bc			dw .ATQ            
bcb1 08				db 7 + 1 
bcb2 .. 00			db "SCROLLD",0              
bcba				endm 
# End of macro CWHEAD
bcba			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
bcba					if DEBUG_FORTH_WORDS_KEY 
bcba						DMARK "SCD" 
bcba f5				push af  
bcbb 3a cf bc			ld a, (.dmark)  
bcbe 32 71 ee			ld (debug_mark),a  
bcc1 3a d0 bc			ld a, (.dmark+1)  
bcc4 32 72 ee			ld (debug_mark+1),a  
bcc7 3a d1 bc			ld a, (.dmark+2)  
bcca 32 73 ee			ld (debug_mark+2),a  
bccd 18 03			jr .pastdmark  
bccf ..			.dmark: db "SCD"  
bcd2 f1			.pastdmark: pop af  
bcd3			endm  
# End of macro DMARK
bcd3						CALLMONITOR 
bcd3 cd 9d 94			call break_point_state  
bcd6				endm  
# End of macro CALLMONITOR
bcd6					endif 
bcd6			 
bcd6 cd 55 8a			call scroll_down 
bcd9			;	call update_display 
bcd9			 
bcd9					NEXTW 
bcd9 c3 7c 9e			jp macro_next 
bcdc				endm 
# End of macro NEXTW
bcdc			 
bcdc			 
bcdc			.ATQ: 
bcdc				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bcdc 62				db WORD_SYS_CORE+78             
bcdd 3a bd			dw .AUTODSP            
bcdf 04				db 3 + 1 
bce0 .. 00			db "AT@",0              
bce4				endm 
# End of macro CWHEAD
bce4			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
bce4					if DEBUG_FORTH_WORDS_KEY 
bce4						DMARK "ATA" 
bce4 f5				push af  
bce5 3a f9 bc			ld a, (.dmark)  
bce8 32 71 ee			ld (debug_mark),a  
bceb 3a fa bc			ld a, (.dmark+1)  
bcee 32 72 ee			ld (debug_mark+1),a  
bcf1 3a fb bc			ld a, (.dmark+2)  
bcf4 32 73 ee			ld (debug_mark+2),a  
bcf7 18 03			jr .pastdmark  
bcf9 ..			.dmark: db "ATA"  
bcfc f1			.pastdmark: pop af  
bcfd			endm  
# End of macro DMARK
bcfd						CALLMONITOR 
bcfd cd 9d 94			call break_point_state  
bd00				endm  
# End of macro CALLMONITOR
bd00					endif 
bd00			 
bd00			 
bd00					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd00 cd 05 9d			call macro_dsp_valuehl 
bd03				endm 
# End of macro FORTH_DSP_VALUEHL
bd03			 
bd03					; TODO save cursor row 
bd03 7d					ld a,l 
bd04 fe 02				cp 2 
bd06 20 04				jr nz, .crow3aq 
bd08 3e 28				ld a, display_row_2 
bd0a 18 12				jr .ccol1aq 
bd0c fe 03		.crow3aq:		cp 3 
bd0e 20 04				jr nz, .crow4aq 
bd10 3e 50				ld a, display_row_3 
bd12 18 0a				jr .ccol1aq 
bd14 fe 04		.crow4aq:		cp 4 
bd16 20 04				jr nz, .crow1aq 
bd18 3e 78				ld a, display_row_4 
bd1a 18 02				jr .ccol1aq 
bd1c 3e 00		.crow1aq:		ld a,display_row_1 
bd1e f5			.ccol1aq:		push af			; got row offset 
bd1f 6f					ld l,a 
bd20 26 00				ld h,0 
bd22					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd22 cd bd 9d			call macro_forth_dsp_pop 
bd25				endm 
# End of macro FORTH_DSP_POP
bd25					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd25 cd 05 9d			call macro_dsp_valuehl 
bd28				endm 
# End of macro FORTH_DSP_VALUEHL
bd28					; TODO save cursor col 
bd28 f1					pop af 
bd29 85					add l		; add col offset 
bd2a			 
bd2a					; add current frame buffer address 
bd2a 2a d2 eb				ld hl, (display_fb_active) 
bd2d cd 9c 8c				call addatohl 
bd30			 
bd30			 
bd30			 
bd30			 
bd30					; get char frame buffer location offset in hl 
bd30			 
bd30 7e					ld a,(hl) 
bd31 26 00				ld h, 0 
bd33 6f					ld l, a 
bd34			 
bd34 cd 0e 9b				call forth_push_numhl 
bd37			 
bd37			 
bd37					NEXTW 
bd37 c3 7c 9e			jp macro_next 
bd3a				endm 
# End of macro NEXTW
bd3a			 
bd3a			.AUTODSP: 
bd3a				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bd3a 63				db WORD_SYS_CORE+79             
bd3b 50 bd			dw .MENU            
bd3d 05				db 4 + 1 
bd3e .. 00			db "ADSP",0              
bd43				endm 
# End of macro CWHEAD
bd43			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bd43			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bd43			 
bd43					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bd43 cd 05 9d			call macro_dsp_valuehl 
bd46				endm 
# End of macro FORTH_DSP_VALUEHL
bd46			 
bd46			;		push hl 
bd46			 
bd46					; destroy value TOS 
bd46			 
bd46					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd46 cd bd 9d			call macro_forth_dsp_pop 
bd49				endm 
# End of macro FORTH_DSP_POP
bd49			 
bd49			;		pop hl 
bd49			 
bd49 7d					ld a,l 
bd4a 32 49 ea				ld (cli_autodisplay), a 
bd4d				       NEXTW 
bd4d c3 7c 9e			jp macro_next 
bd50				endm 
# End of macro NEXTW
bd50			 
bd50			.MENU: 
bd50				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bd50 70				db WORD_SYS_CORE+92             
bd51 f9 bd			dw .ENDDISPLAY            
bd53 05				db 4 + 1 
bd54 .. 00			db "MENU",0              
bd59				endm 
# End of macro CWHEAD
bd59			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bd59			 
bd59			;		; get number of items on the stack 
bd59			; 
bd59				 
bd59					FORTH_DSP_VALUEHL 
bd59 cd 05 9d			call macro_dsp_valuehl 
bd5c				endm 
# End of macro FORTH_DSP_VALUEHL
bd5c				 
bd5c					if DEBUG_FORTH_WORDS_KEY 
bd5c						DMARK "MNU" 
bd5c f5				push af  
bd5d 3a 71 bd			ld a, (.dmark)  
bd60 32 71 ee			ld (debug_mark),a  
bd63 3a 72 bd			ld a, (.dmark+1)  
bd66 32 72 ee			ld (debug_mark+1),a  
bd69 3a 73 bd			ld a, (.dmark+2)  
bd6c 32 73 ee			ld (debug_mark+2),a  
bd6f 18 03			jr .pastdmark  
bd71 ..			.dmark: db "MNU"  
bd74 f1			.pastdmark: pop af  
bd75			endm  
# End of macro DMARK
bd75						CALLMONITOR 
bd75 cd 9d 94			call break_point_state  
bd78				endm  
# End of macro CALLMONITOR
bd78					endif 
bd78			 
bd78 45					ld b, l	 
bd79 05					dec b 
bd7a			 
bd7a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bd7a cd bd 9d			call macro_forth_dsp_pop 
bd7d				endm 
# End of macro FORTH_DSP_POP
bd7d			 
bd7d			 
bd7d					; go directly through the stack to pluck out the string pointers and build an array 
bd7d			 
bd7d			;		FORTH_DSP 
bd7d			 
bd7d					; hl contains top most stack item 
bd7d				 
bd7d 11 02 e3				ld de, scratch 
bd80			 
bd80			.mbuild: 
bd80			 
bd80					FORTH_DSP_VALUEHL 
bd80 cd 05 9d			call macro_dsp_valuehl 
bd83				endm 
# End of macro FORTH_DSP_VALUEHL
bd83			 
bd83					if DEBUG_FORTH_WORDS 
bd83						DMARK "MN3" 
bd83 f5				push af  
bd84 3a 98 bd			ld a, (.dmark)  
bd87 32 71 ee			ld (debug_mark),a  
bd8a 3a 99 bd			ld a, (.dmark+1)  
bd8d 32 72 ee			ld (debug_mark+1),a  
bd90 3a 9a bd			ld a, (.dmark+2)  
bd93 32 73 ee			ld (debug_mark+2),a  
bd96 18 03			jr .pastdmark  
bd98 ..			.dmark: db "MN3"  
bd9b f1			.pastdmark: pop af  
bd9c			endm  
# End of macro DMARK
bd9c						CALLMONITOR 
bd9c cd 9d 94			call break_point_state  
bd9f				endm  
# End of macro CALLMONITOR
bd9f					endif 
bd9f eb					ex de, hl 
bda0 73					ld (hl), e 
bda1 23					inc hl 
bda2 72					ld (hl), d 
bda3 23					inc hl 
bda4 eb					ex de, hl 
bda5			 
bda5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bda5 cd bd 9d			call macro_forth_dsp_pop 
bda8				endm 
# End of macro FORTH_DSP_POP
bda8			 
bda8 10 d6				djnz .mbuild 
bdaa			 
bdaa					; done add term 
bdaa			 
bdaa eb					ex de, hl 
bdab 36 00				ld (hl), 0 
bdad 23					inc hl 
bdae 36 00				ld (hl), 0 
bdb0			 
bdb0				 
bdb0					 
bdb0 21 02 e3				ld hl, scratch 
bdb3			 
bdb3					if DEBUG_FORTH_WORDS 
bdb3						DMARK "MNx" 
bdb3 f5				push af  
bdb4 3a c8 bd			ld a, (.dmark)  
bdb7 32 71 ee			ld (debug_mark),a  
bdba 3a c9 bd			ld a, (.dmark+1)  
bdbd 32 72 ee			ld (debug_mark+1),a  
bdc0 3a ca bd			ld a, (.dmark+2)  
bdc3 32 73 ee			ld (debug_mark+2),a  
bdc6 18 03			jr .pastdmark  
bdc8 ..			.dmark: db "MNx"  
bdcb f1			.pastdmark: pop af  
bdcc			endm  
# End of macro DMARK
bdcc						CALLMONITOR 
bdcc cd 9d 94			call break_point_state  
bdcf				endm  
# End of macro CALLMONITOR
bdcf					endif 
bdcf			 
bdcf			 
bdcf			 
bdcf 3e 00				ld a, 0 
bdd1 cd a0 8a				call menu 
bdd4			 
bdd4			 
bdd4 6f					ld l, a 
bdd5 26 00				ld h, 0 
bdd7			 
bdd7					if DEBUG_FORTH_WORDS 
bdd7						DMARK "MNr" 
bdd7 f5				push af  
bdd8 3a ec bd			ld a, (.dmark)  
bddb 32 71 ee			ld (debug_mark),a  
bdde 3a ed bd			ld a, (.dmark+1)  
bde1 32 72 ee			ld (debug_mark+1),a  
bde4 3a ee bd			ld a, (.dmark+2)  
bde7 32 73 ee			ld (debug_mark+2),a  
bdea 18 03			jr .pastdmark  
bdec ..			.dmark: db "MNr"  
bdef f1			.pastdmark: pop af  
bdf0			endm  
# End of macro DMARK
bdf0						CALLMONITOR 
bdf0 cd 9d 94			call break_point_state  
bdf3				endm  
# End of macro CALLMONITOR
bdf3					endif 
bdf3			 
bdf3 cd 0e 9b				call forth_push_numhl 
bdf6			 
bdf6			 
bdf6			 
bdf6			 
bdf6				       NEXTW 
bdf6 c3 7c 9e			jp macro_next 
bdf9				endm 
# End of macro NEXTW
bdf9			 
bdf9			 
bdf9			.ENDDISPLAY: 
bdf9			 
bdf9			; eof 
# End of file forth_words_display.asm
bdf9			include "forth_words_str.asm" 
bdf9			 
bdf9			; | ## String Words 
bdf9			 
bdf9			.PTR:   
bdf9			 
bdf9				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
bdf9 48				db WORD_SYS_CORE+52             
bdfa 26 be			dw .STYPE            
bdfc 04				db 3 + 1 
bdfd .. 00			db "PTR",0              
be01				endm 
# End of macro CWHEAD
be01			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
be01			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
be01			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
be01			 
be01					if DEBUG_FORTH_WORDS_KEY 
be01						DMARK "PTR" 
be01 f5				push af  
be02 3a 16 be			ld a, (.dmark)  
be05 32 71 ee			ld (debug_mark),a  
be08 3a 17 be			ld a, (.dmark+1)  
be0b 32 72 ee			ld (debug_mark+1),a  
be0e 3a 18 be			ld a, (.dmark+2)  
be11 32 73 ee			ld (debug_mark+2),a  
be14 18 03			jr .pastdmark  
be16 ..			.dmark: db "PTR"  
be19 f1			.pastdmark: pop af  
be1a			endm  
# End of macro DMARK
be1a						CALLMONITOR 
be1a cd 9d 94			call break_point_state  
be1d				endm  
# End of macro CALLMONITOR
be1d					endif 
be1d					FORTH_DSP_VALUEHL 
be1d cd 05 9d			call macro_dsp_valuehl 
be20				endm 
# End of macro FORTH_DSP_VALUEHL
be20 cd 0e 9b				call forth_push_numhl 
be23			 
be23			 
be23					NEXTW 
be23 c3 7c 9e			jp macro_next 
be26				endm 
# End of macro NEXTW
be26			.STYPE: 
be26				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
be26 48				db WORD_SYS_CORE+52             
be27 75 be			dw .UPPER            
be29 06				db 5 + 1 
be2a .. 00			db "STYPE",0              
be30				endm 
# End of macro CWHEAD
be30			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
be30					if DEBUG_FORTH_WORDS_KEY 
be30						DMARK "STY" 
be30 f5				push af  
be31 3a 45 be			ld a, (.dmark)  
be34 32 71 ee			ld (debug_mark),a  
be37 3a 46 be			ld a, (.dmark+1)  
be3a 32 72 ee			ld (debug_mark+1),a  
be3d 3a 47 be			ld a, (.dmark+2)  
be40 32 73 ee			ld (debug_mark+2),a  
be43 18 03			jr .pastdmark  
be45 ..			.dmark: db "STY"  
be48 f1			.pastdmark: pop af  
be49			endm  
# End of macro DMARK
be49						CALLMONITOR 
be49 cd 9d 94			call break_point_state  
be4c				endm  
# End of macro CALLMONITOR
be4c					endif 
be4c					FORTH_DSP 
be4c cd cb 9c			call macro_forth_dsp 
be4f				endm 
# End of macro FORTH_DSP
be4f					;v5 FORTH_DSP_VALUE 
be4f			 
be4f 7e					ld a, (hl) 
be50			 
be50 f5					push af 
be51			 
be51			; Dont destroy TOS		FORTH_DSP_POP 
be51			 
be51 f1					pop af 
be52			 
be52 fe 01				cp DS_TYPE_STR 
be54 28 09				jr z, .typestr 
be56			 
be56 fe 02				cp DS_TYPE_INUM 
be58 28 0a				jr z, .typeinum 
be5a			 
be5a 21 73 be				ld hl, .tna 
be5d 18 0a				jr .tpush 
be5f			 
be5f 21 6f be		.typestr:	ld hl, .tstr 
be62 18 05				jr .tpush 
be64 21 71 be		.typeinum:	ld hl, .tinum 
be67 18 00				jr .tpush 
be69			 
be69			.tpush: 
be69			 
be69 cd 7c 9b				call forth_push_str 
be6c			 
be6c					NEXTW 
be6c c3 7c 9e			jp macro_next 
be6f				endm 
# End of macro NEXTW
be6f .. 00		.tstr:	db "s",0 
be71 .. 00		.tinum:  db "i",0 
be73 .. 00		.tna:   db "?", 0 
be75			 
be75			 
be75			.UPPER: 
be75				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
be75 48				db WORD_SYS_CORE+52             
be76 b0 be			dw .LOWER            
be78 06				db 5 + 1 
be79 .. 00			db "UPPER",0              
be7f				endm 
# End of macro CWHEAD
be7f			; | UPPER ( s -- s ) Upper case string s  | DONE 
be7f					if DEBUG_FORTH_WORDS_KEY 
be7f						DMARK "UPR" 
be7f f5				push af  
be80 3a 94 be			ld a, (.dmark)  
be83 32 71 ee			ld (debug_mark),a  
be86 3a 95 be			ld a, (.dmark+1)  
be89 32 72 ee			ld (debug_mark+1),a  
be8c 3a 96 be			ld a, (.dmark+2)  
be8f 32 73 ee			ld (debug_mark+2),a  
be92 18 03			jr .pastdmark  
be94 ..			.dmark: db "UPR"  
be97 f1			.pastdmark: pop af  
be98			endm  
# End of macro DMARK
be98						CALLMONITOR 
be98 cd 9d 94			call break_point_state  
be9b				endm  
# End of macro CALLMONITOR
be9b					endif 
be9b			 
be9b					FORTH_DSP 
be9b cd cb 9c			call macro_forth_dsp 
be9e				endm 
# End of macro FORTH_DSP
be9e					 
be9e			; TODO check is string type 
be9e			 
be9e					FORTH_DSP_VALUEHL 
be9e cd 05 9d			call macro_dsp_valuehl 
bea1				endm 
# End of macro FORTH_DSP_VALUEHL
bea1			; get pointer to string in hl 
bea1			 
bea1 7e			.toup:		ld a, (hl) 
bea2 fe 00				cp 0 
bea4 28 07				jr z, .toupdone 
bea6			 
bea6 cd 09 90				call to_upper 
bea9			 
bea9 77					ld (hl), a 
beaa 23					inc hl 
beab 18 f4				jr .toup 
bead			 
bead					 
bead			 
bead			 
bead			; for each char convert to upper 
bead					 
bead			.toupdone: 
bead			 
bead			 
bead					NEXTW 
bead c3 7c 9e			jp macro_next 
beb0				endm 
# End of macro NEXTW
beb0			.LOWER: 
beb0				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
beb0 48				db WORD_SYS_CORE+52             
beb1 eb be			dw .TCASE            
beb3 06				db 5 + 1 
beb4 .. 00			db "LOWER",0              
beba				endm 
# End of macro CWHEAD
beba			; | LOWER ( s -- s ) Lower case string s  | DONE 
beba					if DEBUG_FORTH_WORDS_KEY 
beba						DMARK "LWR" 
beba f5				push af  
bebb 3a cf be			ld a, (.dmark)  
bebe 32 71 ee			ld (debug_mark),a  
bec1 3a d0 be			ld a, (.dmark+1)  
bec4 32 72 ee			ld (debug_mark+1),a  
bec7 3a d1 be			ld a, (.dmark+2)  
beca 32 73 ee			ld (debug_mark+2),a  
becd 18 03			jr .pastdmark  
becf ..			.dmark: db "LWR"  
bed2 f1			.pastdmark: pop af  
bed3			endm  
# End of macro DMARK
bed3						CALLMONITOR 
bed3 cd 9d 94			call break_point_state  
bed6				endm  
# End of macro CALLMONITOR
bed6					endif 
bed6			 
bed6					FORTH_DSP 
bed6 cd cb 9c			call macro_forth_dsp 
bed9				endm 
# End of macro FORTH_DSP
bed9					 
bed9			; TODO check is string type 
bed9			 
bed9					FORTH_DSP_VALUEHL 
bed9 cd 05 9d			call macro_dsp_valuehl 
bedc				endm 
# End of macro FORTH_DSP_VALUEHL
bedc			; get pointer to string in hl 
bedc			 
bedc 7e			.tolow:		ld a, (hl) 
bedd fe 00				cp 0 
bedf 28 07				jr z, .tolowdone 
bee1			 
bee1 cd 12 90				call to_lower 
bee4			 
bee4 77					ld (hl), a 
bee5 23					inc hl 
bee6 18 f4				jr .tolow 
bee8			 
bee8					 
bee8			 
bee8			 
bee8			; for each char convert to low 
bee8					 
bee8			.tolowdone: 
bee8					NEXTW 
bee8 c3 7c 9e			jp macro_next 
beeb				endm 
# End of macro NEXTW
beeb			.TCASE: 
beeb				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
beeb 48				db WORD_SYS_CORE+52             
beec 21 c0			dw .SUBSTR            
beee 06				db 5 + 1 
beef .. 00			db "TCASE",0              
bef5				endm 
# End of macro CWHEAD
bef5			; | TCASE ( s -- s ) Title case string s  | DONE 
bef5					if DEBUG_FORTH_WORDS_KEY 
bef5						DMARK "TCS" 
bef5 f5				push af  
bef6 3a 0a bf			ld a, (.dmark)  
bef9 32 71 ee			ld (debug_mark),a  
befc 3a 0b bf			ld a, (.dmark+1)  
beff 32 72 ee			ld (debug_mark+1),a  
bf02 3a 0c bf			ld a, (.dmark+2)  
bf05 32 73 ee			ld (debug_mark+2),a  
bf08 18 03			jr .pastdmark  
bf0a ..			.dmark: db "TCS"  
bf0d f1			.pastdmark: pop af  
bf0e			endm  
# End of macro DMARK
bf0e						CALLMONITOR 
bf0e cd 9d 94			call break_point_state  
bf11				endm  
# End of macro CALLMONITOR
bf11					endif 
bf11			 
bf11					FORTH_DSP 
bf11 cd cb 9c			call macro_forth_dsp 
bf14				endm 
# End of macro FORTH_DSP
bf14					 
bf14			; TODO check is string type 
bf14			 
bf14					FORTH_DSP_VALUEHL 
bf14 cd 05 9d			call macro_dsp_valuehl 
bf17				endm 
# End of macro FORTH_DSP_VALUEHL
bf17			; get pointer to string in hl 
bf17			 
bf17					if DEBUG_FORTH_WORDS 
bf17						DMARK "TC1" 
bf17 f5				push af  
bf18 3a 2c bf			ld a, (.dmark)  
bf1b 32 71 ee			ld (debug_mark),a  
bf1e 3a 2d bf			ld a, (.dmark+1)  
bf21 32 72 ee			ld (debug_mark+1),a  
bf24 3a 2e bf			ld a, (.dmark+2)  
bf27 32 73 ee			ld (debug_mark+2),a  
bf2a 18 03			jr .pastdmark  
bf2c ..			.dmark: db "TC1"  
bf2f f1			.pastdmark: pop af  
bf30			endm  
# End of macro DMARK
bf30						CALLMONITOR 
bf30 cd 9d 94			call break_point_state  
bf33				endm  
# End of macro CALLMONITOR
bf33					endif 
bf33			 
bf33					; first time in turn to upper case first char 
bf33			 
bf33 7e					ld a, (hl) 
bf34 c3 be bf				jp .totsiptou 
bf37			 
bf37			 
bf37 7e			.tot:		ld a, (hl) 
bf38 fe 00				cp 0 
bf3a ca 02 c0				jp z, .totdone 
bf3d			 
bf3d					if DEBUG_FORTH_WORDS 
bf3d						DMARK "TC2" 
bf3d f5				push af  
bf3e 3a 52 bf			ld a, (.dmark)  
bf41 32 71 ee			ld (debug_mark),a  
bf44 3a 53 bf			ld a, (.dmark+1)  
bf47 32 72 ee			ld (debug_mark+1),a  
bf4a 3a 54 bf			ld a, (.dmark+2)  
bf4d 32 73 ee			ld (debug_mark+2),a  
bf50 18 03			jr .pastdmark  
bf52 ..			.dmark: db "TC2"  
bf55 f1			.pastdmark: pop af  
bf56			endm  
# End of macro DMARK
bf56						CALLMONITOR 
bf56 cd 9d 94			call break_point_state  
bf59				endm  
# End of macro CALLMONITOR
bf59					endif 
bf59					; check to see if current char is a space 
bf59			 
bf59 fe 20				cp ' ' 
bf5b 28 21				jr z, .totsp 
bf5d cd 12 90				call to_lower 
bf60					if DEBUG_FORTH_WORDS 
bf60						DMARK "TC3" 
bf60 f5				push af  
bf61 3a 75 bf			ld a, (.dmark)  
bf64 32 71 ee			ld (debug_mark),a  
bf67 3a 76 bf			ld a, (.dmark+1)  
bf6a 32 72 ee			ld (debug_mark+1),a  
bf6d 3a 77 bf			ld a, (.dmark+2)  
bf70 32 73 ee			ld (debug_mark+2),a  
bf73 18 03			jr .pastdmark  
bf75 ..			.dmark: db "TC3"  
bf78 f1			.pastdmark: pop af  
bf79			endm  
# End of macro DMARK
bf79						CALLMONITOR 
bf79 cd 9d 94			call break_point_state  
bf7c				endm  
# End of macro CALLMONITOR
bf7c					endif 
bf7c 18 63				jr .totnxt 
bf7e			 
bf7e			.totsp:         ; on a space, find next char which should be upper 
bf7e			 
bf7e					if DEBUG_FORTH_WORDS 
bf7e						DMARK "TC4" 
bf7e f5				push af  
bf7f 3a 93 bf			ld a, (.dmark)  
bf82 32 71 ee			ld (debug_mark),a  
bf85 3a 94 bf			ld a, (.dmark+1)  
bf88 32 72 ee			ld (debug_mark+1),a  
bf8b 3a 95 bf			ld a, (.dmark+2)  
bf8e 32 73 ee			ld (debug_mark+2),a  
bf91 18 03			jr .pastdmark  
bf93 ..			.dmark: db "TC4"  
bf96 f1			.pastdmark: pop af  
bf97			endm  
# End of macro DMARK
bf97						CALLMONITOR 
bf97 cd 9d 94			call break_point_state  
bf9a				endm  
# End of macro CALLMONITOR
bf9a					endif 
bf9a					;; 
bf9a			 
bf9a fe 20				cp ' ' 
bf9c 20 20				jr nz, .totsiptou 
bf9e 23					inc hl 
bf9f 7e					ld a, (hl) 
bfa0					if DEBUG_FORTH_WORDS 
bfa0						DMARK "TC5" 
bfa0 f5				push af  
bfa1 3a b5 bf			ld a, (.dmark)  
bfa4 32 71 ee			ld (debug_mark),a  
bfa7 3a b6 bf			ld a, (.dmark+1)  
bfaa 32 72 ee			ld (debug_mark+1),a  
bfad 3a b7 bf			ld a, (.dmark+2)  
bfb0 32 73 ee			ld (debug_mark+2),a  
bfb3 18 03			jr .pastdmark  
bfb5 ..			.dmark: db "TC5"  
bfb8 f1			.pastdmark: pop af  
bfb9			endm  
# End of macro DMARK
bfb9						CALLMONITOR 
bfb9 cd 9d 94			call break_point_state  
bfbc				endm  
# End of macro CALLMONITOR
bfbc					endif 
bfbc 18 c0				jr .totsp 
bfbe fe 00		.totsiptou:    cp 0 
bfc0 28 40				jr z, .totdone 
bfc2					; not space and not zero term so upper case it 
bfc2 cd 09 90				call to_upper 
bfc5			 
bfc5					if DEBUG_FORTH_WORDS 
bfc5						DMARK "TC6" 
bfc5 f5				push af  
bfc6 3a da bf			ld a, (.dmark)  
bfc9 32 71 ee			ld (debug_mark),a  
bfcc 3a db bf			ld a, (.dmark+1)  
bfcf 32 72 ee			ld (debug_mark+1),a  
bfd2 3a dc bf			ld a, (.dmark+2)  
bfd5 32 73 ee			ld (debug_mark+2),a  
bfd8 18 03			jr .pastdmark  
bfda ..			.dmark: db "TC6"  
bfdd f1			.pastdmark: pop af  
bfde			endm  
# End of macro DMARK
bfde						CALLMONITOR 
bfde cd 9d 94			call break_point_state  
bfe1				endm  
# End of macro CALLMONITOR
bfe1					endif 
bfe1			 
bfe1			 
bfe1			.totnxt: 
bfe1			 
bfe1 77					ld (hl), a 
bfe2 23					inc hl 
bfe3					if DEBUG_FORTH_WORDS 
bfe3						DMARK "TC7" 
bfe3 f5				push af  
bfe4 3a f8 bf			ld a, (.dmark)  
bfe7 32 71 ee			ld (debug_mark),a  
bfea 3a f9 bf			ld a, (.dmark+1)  
bfed 32 72 ee			ld (debug_mark+1),a  
bff0 3a fa bf			ld a, (.dmark+2)  
bff3 32 73 ee			ld (debug_mark+2),a  
bff6 18 03			jr .pastdmark  
bff8 ..			.dmark: db "TC7"  
bffb f1			.pastdmark: pop af  
bffc			endm  
# End of macro DMARK
bffc						CALLMONITOR 
bffc cd 9d 94			call break_point_state  
bfff				endm  
# End of macro CALLMONITOR
bfff					endif 
bfff c3 37 bf				jp .tot 
c002			 
c002					 
c002			 
c002			 
c002			; for each char convert to low 
c002					 
c002			.totdone: 
c002					if DEBUG_FORTH_WORDS 
c002						DMARK "TCd" 
c002 f5				push af  
c003 3a 17 c0			ld a, (.dmark)  
c006 32 71 ee			ld (debug_mark),a  
c009 3a 18 c0			ld a, (.dmark+1)  
c00c 32 72 ee			ld (debug_mark+1),a  
c00f 3a 19 c0			ld a, (.dmark+2)  
c012 32 73 ee			ld (debug_mark+2),a  
c015 18 03			jr .pastdmark  
c017 ..			.dmark: db "TCd"  
c01a f1			.pastdmark: pop af  
c01b			endm  
# End of macro DMARK
c01b						CALLMONITOR 
c01b cd 9d 94			call break_point_state  
c01e				endm  
# End of macro CALLMONITOR
c01e					endif 
c01e					NEXTW 
c01e c3 7c 9e			jp macro_next 
c021				endm 
# End of macro NEXTW
c021			 
c021			.SUBSTR: 
c021				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
c021 48				db WORD_SYS_CORE+52             
c022 7f c0			dw .LEFT            
c024 07				db 6 + 1 
c025 .. 00			db "SUBSTR",0              
c02c				endm 
# End of macro CWHEAD
c02c			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
c02c			 
c02c					if DEBUG_FORTH_WORDS_KEY 
c02c						DMARK "SST" 
c02c f5				push af  
c02d 3a 41 c0			ld a, (.dmark)  
c030 32 71 ee			ld (debug_mark),a  
c033 3a 42 c0			ld a, (.dmark+1)  
c036 32 72 ee			ld (debug_mark+1),a  
c039 3a 43 c0			ld a, (.dmark+2)  
c03c 32 73 ee			ld (debug_mark+2),a  
c03f 18 03			jr .pastdmark  
c041 ..			.dmark: db "SST"  
c044 f1			.pastdmark: pop af  
c045			endm  
# End of macro DMARK
c045						CALLMONITOR 
c045 cd 9d 94			call break_point_state  
c048				endm  
# End of macro CALLMONITOR
c048					endif 
c048			; TODO check string type 
c048					FORTH_DSP_VALUEHL 
c048 cd 05 9d			call macro_dsp_valuehl 
c04b				endm 
# End of macro FORTH_DSP_VALUEHL
c04b			 
c04b e5					push hl      ; string length 
c04c			 
c04c					FORTH_DSP_POP 
c04c cd bd 9d			call macro_forth_dsp_pop 
c04f				endm 
# End of macro FORTH_DSP_POP
c04f			 
c04f					FORTH_DSP_VALUEHL 
c04f cd 05 9d			call macro_dsp_valuehl 
c052				endm 
# End of macro FORTH_DSP_VALUEHL
c052			 
c052 e5					push hl     ; start char 
c053			 
c053					FORTH_DSP_POP 
c053 cd bd 9d			call macro_forth_dsp_pop 
c056				endm 
# End of macro FORTH_DSP_POP
c056			 
c056			 
c056					FORTH_DSP_VALUE 
c056 cd ee 9c			call macro_forth_dsp_value 
c059				endm 
# End of macro FORTH_DSP_VALUE
c059			 
c059 d1					pop de    ; get start post offset 
c05a			 
c05a 19					add hl, de    ; starting offset 
c05b			 
c05b c1					pop bc 
c05c c5					push bc      ; grab size of string 
c05d			 
c05d e5					push hl    ; save string start  
c05e			 
c05e 26 00				ld h, 0 
c060 69					ld l, c 
c061 23					inc hl 
c062 23					inc hl 
c063			 
c063 cd 63 91				call malloc 
c066				if DEBUG_FORTH_MALLOC_GUARD 
c066 cc e3 c6				call z,malloc_error 
c069				endif 
c069			 
c069 eb					ex de, hl      ; save malloc area for string copy 
c06a e1					pop hl    ; get back source 
c06b c1					pop bc    ; get length of string back 
c06c			 
c06c d5					push de    ; save malloc area for after we push 
c06d ed b0				ldir     ; copy substr 
c06f			 
c06f			 
c06f eb					ex de, hl 
c070 3e 00				ld a, 0 
c072 77					ld (hl), a   ; term substr 
c073			 
c073					 
c073 e1					pop hl    ; get malloc so we can push it 
c074 e5					push hl   ; save so we can free it afterwards 
c075			 
c075 cd 7c 9b				call forth_push_str 
c078			 
c078 e1					pop hl 
c079 cd 2d 92				call free 
c07c			 
c07c					 
c07c					 
c07c			 
c07c			 
c07c					NEXTW 
c07c c3 7c 9e			jp macro_next 
c07f				endm 
# End of macro NEXTW
c07f			 
c07f			.LEFT: 
c07f				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
c07f 48				db WORD_SYS_CORE+52             
c080 a7 c0			dw .RIGHT            
c082 05				db 4 + 1 
c083 .. 00			db "LEFT",0              
c088				endm 
# End of macro CWHEAD
c088			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
c088					if DEBUG_FORTH_WORDS_KEY 
c088						DMARK "LEF" 
c088 f5				push af  
c089 3a 9d c0			ld a, (.dmark)  
c08c 32 71 ee			ld (debug_mark),a  
c08f 3a 9e c0			ld a, (.dmark+1)  
c092 32 72 ee			ld (debug_mark+1),a  
c095 3a 9f c0			ld a, (.dmark+2)  
c098 32 73 ee			ld (debug_mark+2),a  
c09b 18 03			jr .pastdmark  
c09d ..			.dmark: db "LEF"  
c0a0 f1			.pastdmark: pop af  
c0a1			endm  
# End of macro DMARK
c0a1						CALLMONITOR 
c0a1 cd 9d 94			call break_point_state  
c0a4				endm  
# End of macro CALLMONITOR
c0a4					endif 
c0a4			 
c0a4					NEXTW 
c0a4 c3 7c 9e			jp macro_next 
c0a7				endm 
# End of macro NEXTW
c0a7			.RIGHT: 
c0a7				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
c0a7 48				db WORD_SYS_CORE+52             
c0a8 d0 c0			dw .STR2NUM            
c0aa 06				db 5 + 1 
c0ab .. 00			db "RIGHT",0              
c0b1				endm 
# End of macro CWHEAD
c0b1			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
c0b1					if DEBUG_FORTH_WORDS_KEY 
c0b1						DMARK "RIG" 
c0b1 f5				push af  
c0b2 3a c6 c0			ld a, (.dmark)  
c0b5 32 71 ee			ld (debug_mark),a  
c0b8 3a c7 c0			ld a, (.dmark+1)  
c0bb 32 72 ee			ld (debug_mark+1),a  
c0be 3a c8 c0			ld a, (.dmark+2)  
c0c1 32 73 ee			ld (debug_mark+2),a  
c0c4 18 03			jr .pastdmark  
c0c6 ..			.dmark: db "RIG"  
c0c9 f1			.pastdmark: pop af  
c0ca			endm  
# End of macro DMARK
c0ca						CALLMONITOR 
c0ca cd 9d 94			call break_point_state  
c0cd				endm  
# End of macro CALLMONITOR
c0cd					endif 
c0cd			 
c0cd					NEXTW 
c0cd c3 7c 9e			jp macro_next 
c0d0				endm 
# End of macro NEXTW
c0d0			 
c0d0			 
c0d0			.STR2NUM: 
c0d0				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
c0d0 48				db WORD_SYS_CORE+52             
c0d1 5c c1			dw .NUM2STR            
c0d3 08				db 7 + 1 
c0d4 .. 00			db "STR2NUM",0              
c0dc				endm 
# End of macro CWHEAD
c0dc			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
c0dc			 
c0dc			 
c0dc			; TODO STR type check to do 
c0dc					if DEBUG_FORTH_WORDS_KEY 
c0dc						DMARK "S2N" 
c0dc f5				push af  
c0dd 3a f1 c0			ld a, (.dmark)  
c0e0 32 71 ee			ld (debug_mark),a  
c0e3 3a f2 c0			ld a, (.dmark+1)  
c0e6 32 72 ee			ld (debug_mark+1),a  
c0e9 3a f3 c0			ld a, (.dmark+2)  
c0ec 32 73 ee			ld (debug_mark+2),a  
c0ef 18 03			jr .pastdmark  
c0f1 ..			.dmark: db "S2N"  
c0f4 f1			.pastdmark: pop af  
c0f5			endm  
# End of macro DMARK
c0f5						CALLMONITOR 
c0f5 cd 9d 94			call break_point_state  
c0f8				endm  
# End of macro CALLMONITOR
c0f8					endif 
c0f8			 
c0f8					;FORTH_DSP 
c0f8					FORTH_DSP_VALUE 
c0f8 cd ee 9c			call macro_forth_dsp_value 
c0fb				endm 
# End of macro FORTH_DSP_VALUE
c0fb					;inc hl 
c0fb			 
c0fb eb					ex de, hl 
c0fc					if DEBUG_FORTH_WORDS 
c0fc						DMARK "S2a" 
c0fc f5				push af  
c0fd 3a 11 c1			ld a, (.dmark)  
c100 32 71 ee			ld (debug_mark),a  
c103 3a 12 c1			ld a, (.dmark+1)  
c106 32 72 ee			ld (debug_mark+1),a  
c109 3a 13 c1			ld a, (.dmark+2)  
c10c 32 73 ee			ld (debug_mark+2),a  
c10f 18 03			jr .pastdmark  
c111 ..			.dmark: db "S2a"  
c114 f1			.pastdmark: pop af  
c115			endm  
# End of macro DMARK
c115						CALLMONITOR 
c115 cd 9d 94			call break_point_state  
c118				endm  
# End of macro CALLMONITOR
c118					endif 
c118 cd 91 90				call string_to_uint16 
c11b			 
c11b					if DEBUG_FORTH_WORDS 
c11b						DMARK "S2b" 
c11b f5				push af  
c11c 3a 30 c1			ld a, (.dmark)  
c11f 32 71 ee			ld (debug_mark),a  
c122 3a 31 c1			ld a, (.dmark+1)  
c125 32 72 ee			ld (debug_mark+1),a  
c128 3a 32 c1			ld a, (.dmark+2)  
c12b 32 73 ee			ld (debug_mark+2),a  
c12e 18 03			jr .pastdmark  
c130 ..			.dmark: db "S2b"  
c133 f1			.pastdmark: pop af  
c134			endm  
# End of macro DMARK
c134						CALLMONITOR 
c134 cd 9d 94			call break_point_state  
c137				endm  
# End of macro CALLMONITOR
c137					endif 
c137			;		push hl 
c137					FORTH_DSP_POP 
c137 cd bd 9d			call macro_forth_dsp_pop 
c13a				endm 
# End of macro FORTH_DSP_POP
c13a			;		pop hl 
c13a					 
c13a					if DEBUG_FORTH_WORDS 
c13a						DMARK "S2b" 
c13a f5				push af  
c13b 3a 4f c1			ld a, (.dmark)  
c13e 32 71 ee			ld (debug_mark),a  
c141 3a 50 c1			ld a, (.dmark+1)  
c144 32 72 ee			ld (debug_mark+1),a  
c147 3a 51 c1			ld a, (.dmark+2)  
c14a 32 73 ee			ld (debug_mark+2),a  
c14d 18 03			jr .pastdmark  
c14f ..			.dmark: db "S2b"  
c152 f1			.pastdmark: pop af  
c153			endm  
# End of macro DMARK
c153						CALLMONITOR 
c153 cd 9d 94			call break_point_state  
c156				endm  
# End of macro CALLMONITOR
c156					endif 
c156 cd 0e 9b				call forth_push_numhl	 
c159			 
c159				 
c159				       NEXTW 
c159 c3 7c 9e			jp macro_next 
c15c				endm 
# End of macro NEXTW
c15c			.NUM2STR: 
c15c				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
c15c 48				db WORD_SYS_CORE+52             
c15d 6b c1			dw .CONCAT            
c15f 08				db 7 + 1 
c160 .. 00			db "NUM2STR",0              
c168				endm 
# End of macro CWHEAD
c168			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
c168			 
c168			;		; malloc a string to target 
c168			;		ld hl, 10     ; TODO max string size should be fine 
c168			;		call malloc 
c168			;		push hl    ; save malloc location 
c168			; 
c168			; 
c168			;; TODO check int type 
c168			;		FORTH_DSP_VALUEHL 
c168			;		ld a, l 
c168			;		call DispAToASCII   
c168			;;TODO need to chage above call to dump into string 
c168			; 
c168			; 
c168			 
c168				       NEXTW 
c168 c3 7c 9e			jp macro_next 
c16b				endm 
# End of macro NEXTW
c16b			 
c16b			.CONCAT: 
c16b				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
c16b 48				db WORD_SYS_CORE+52             
c16c 1e c2			dw .FIND            
c16e 07				db 6 + 1 
c16f .. 00			db "CONCAT",0              
c176				endm 
# End of macro CWHEAD
c176			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
c176			 
c176			; TODO check string type 
c176			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
c176			 
c176					if DEBUG_FORTH_WORDS_KEY 
c176						DMARK "CON" 
c176 f5				push af  
c177 3a 8b c1			ld a, (.dmark)  
c17a 32 71 ee			ld (debug_mark),a  
c17d 3a 8c c1			ld a, (.dmark+1)  
c180 32 72 ee			ld (debug_mark+1),a  
c183 3a 8d c1			ld a, (.dmark+2)  
c186 32 73 ee			ld (debug_mark+2),a  
c189 18 03			jr .pastdmark  
c18b ..			.dmark: db "CON"  
c18e f1			.pastdmark: pop af  
c18f			endm  
# End of macro DMARK
c18f						CALLMONITOR 
c18f cd 9d 94			call break_point_state  
c192				endm  
# End of macro CALLMONITOR
c192					endif 
c192			 
c192			 
c192					FORTH_DSP_VALUE 
c192 cd ee 9c			call macro_forth_dsp_value 
c195				endm 
# End of macro FORTH_DSP_VALUE
c195 e5					push hl   ; s2 
c196			 
c196					FORTH_DSP_POP 
c196 cd bd 9d			call macro_forth_dsp_pop 
c199				endm 
# End of macro FORTH_DSP_POP
c199			 
c199					FORTH_DSP_VALUE 
c199 cd ee 9c			call macro_forth_dsp_value 
c19c				endm 
# End of macro FORTH_DSP_VALUE
c19c			 
c19c e5					push hl   ; s1 
c19d			 
c19d					FORTH_DSP_POP 
c19d cd bd 9d			call macro_forth_dsp_pop 
c1a0				endm 
# End of macro FORTH_DSP_POP
c1a0					 
c1a0			 
c1a0					; copy s1 
c1a0			 
c1a0				 
c1a0					; save ptr 
c1a0 e1					pop hl  
c1a1 e5					push hl 
c1a2 3e 00				ld a, 0 
c1a4 cd 05 91				call strlent 
c1a7					;inc hl    ; zer0 
c1a7 06 00				ld b, 0 
c1a9 4d					ld c, l 
c1aa e1					pop hl		 
c1ab 11 02 e3				ld de, scratch	 
c1ae					if DEBUG_FORTH_WORDS 
c1ae						DMARK "CO1" 
c1ae f5				push af  
c1af 3a c3 c1			ld a, (.dmark)  
c1b2 32 71 ee			ld (debug_mark),a  
c1b5 3a c4 c1			ld a, (.dmark+1)  
c1b8 32 72 ee			ld (debug_mark+1),a  
c1bb 3a c5 c1			ld a, (.dmark+2)  
c1be 32 73 ee			ld (debug_mark+2),a  
c1c1 18 03			jr .pastdmark  
c1c3 ..			.dmark: db "CO1"  
c1c6 f1			.pastdmark: pop af  
c1c7			endm  
# End of macro DMARK
c1c7						CALLMONITOR 
c1c7 cd 9d 94			call break_point_state  
c1ca				endm  
# End of macro CALLMONITOR
c1ca					endif 
c1ca ed b0				ldir 
c1cc			 
c1cc e1					pop hl 
c1cd e5					push hl 
c1ce d5					push de 
c1cf			 
c1cf			 
c1cf 3e 00				ld a, 0 
c1d1 cd 05 91				call strlent 
c1d4 23					inc hl    ; zer0 
c1d5 23					inc hl 
c1d6 06 00				ld b, 0 
c1d8 4d					ld c, l 
c1d9 d1					pop de 
c1da e1					pop hl		 
c1db					if DEBUG_FORTH_WORDS 
c1db						DMARK "CO2" 
c1db f5				push af  
c1dc 3a f0 c1			ld a, (.dmark)  
c1df 32 71 ee			ld (debug_mark),a  
c1e2 3a f1 c1			ld a, (.dmark+1)  
c1e5 32 72 ee			ld (debug_mark+1),a  
c1e8 3a f2 c1			ld a, (.dmark+2)  
c1eb 32 73 ee			ld (debug_mark+2),a  
c1ee 18 03			jr .pastdmark  
c1f0 ..			.dmark: db "CO2"  
c1f3 f1			.pastdmark: pop af  
c1f4			endm  
# End of macro DMARK
c1f4						CALLMONITOR 
c1f4 cd 9d 94			call break_point_state  
c1f7				endm  
# End of macro CALLMONITOR
c1f7					endif 
c1f7 ed b0				ldir 
c1f9			 
c1f9			 
c1f9			 
c1f9 21 02 e3				ld hl, scratch 
c1fc					if DEBUG_FORTH_WORDS 
c1fc						DMARK "CO5" 
c1fc f5				push af  
c1fd 3a 11 c2			ld a, (.dmark)  
c200 32 71 ee			ld (debug_mark),a  
c203 3a 12 c2			ld a, (.dmark+1)  
c206 32 72 ee			ld (debug_mark+1),a  
c209 3a 13 c2			ld a, (.dmark+2)  
c20c 32 73 ee			ld (debug_mark+2),a  
c20f 18 03			jr .pastdmark  
c211 ..			.dmark: db "CO5"  
c214 f1			.pastdmark: pop af  
c215			endm  
# End of macro DMARK
c215						CALLMONITOR 
c215 cd 9d 94			call break_point_state  
c218				endm  
# End of macro CALLMONITOR
c218					endif 
c218			 
c218 cd 7c 9b				call forth_push_str 
c21b			 
c21b			 
c21b			 
c21b			 
c21b				       NEXTW 
c21b c3 7c 9e			jp macro_next 
c21e				endm 
# End of macro NEXTW
c21e			 
c21e			 
c21e			.FIND: 
c21e				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c21e 4b				db WORD_SYS_CORE+55             
c21f dc c2			dw .LEN            
c221 05				db 4 + 1 
c222 .. 00			db "FIND",0              
c227				endm 
# End of macro CWHEAD
c227			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c227			 
c227					if DEBUG_FORTH_WORDS_KEY 
c227						DMARK "FND" 
c227 f5				push af  
c228 3a 3c c2			ld a, (.dmark)  
c22b 32 71 ee			ld (debug_mark),a  
c22e 3a 3d c2			ld a, (.dmark+1)  
c231 32 72 ee			ld (debug_mark+1),a  
c234 3a 3e c2			ld a, (.dmark+2)  
c237 32 73 ee			ld (debug_mark+2),a  
c23a 18 03			jr .pastdmark  
c23c ..			.dmark: db "FND"  
c23f f1			.pastdmark: pop af  
c240			endm  
# End of macro DMARK
c240						CALLMONITOR 
c240 cd 9d 94			call break_point_state  
c243				endm  
# End of macro CALLMONITOR
c243					endif 
c243			 
c243			; TODO check string type 
c243					FORTH_DSP_VALUE 
c243 cd ee 9c			call macro_forth_dsp_value 
c246				endm 
# End of macro FORTH_DSP_VALUE
c246			 
c246 e5					push hl    
c247 7e					ld a,(hl)    ; char to find   
c248			; TODO change char to substr 
c248			 
c248 f5					push af 
c249					 
c249			 
c249			 
c249					if DEBUG_FORTH_WORDS 
c249						DMARK "FN1" 
c249 f5				push af  
c24a 3a 5e c2			ld a, (.dmark)  
c24d 32 71 ee			ld (debug_mark),a  
c250 3a 5f c2			ld a, (.dmark+1)  
c253 32 72 ee			ld (debug_mark+1),a  
c256 3a 60 c2			ld a, (.dmark+2)  
c259 32 73 ee			ld (debug_mark+2),a  
c25c 18 03			jr .pastdmark  
c25e ..			.dmark: db "FN1"  
c261 f1			.pastdmark: pop af  
c262			endm  
# End of macro DMARK
c262						CALLMONITOR 
c262 cd 9d 94			call break_point_state  
c265				endm  
# End of macro CALLMONITOR
c265					endif 
c265			 
c265					FORTH_DSP_POP 
c265 cd bd 9d			call macro_forth_dsp_pop 
c268				endm 
# End of macro FORTH_DSP_POP
c268			 
c268					; string to search 
c268			 
c268					FORTH_DSP_VALUE 
c268 cd ee 9c			call macro_forth_dsp_value 
c26b				endm 
# End of macro FORTH_DSP_VALUE
c26b			 
c26b d1					pop de  ; d is char to find  
c26c			 
c26c					if DEBUG_FORTH_WORDS 
c26c						DMARK "FN2" 
c26c f5				push af  
c26d 3a 81 c2			ld a, (.dmark)  
c270 32 71 ee			ld (debug_mark),a  
c273 3a 82 c2			ld a, (.dmark+1)  
c276 32 72 ee			ld (debug_mark+1),a  
c279 3a 83 c2			ld a, (.dmark+2)  
c27c 32 73 ee			ld (debug_mark+2),a  
c27f 18 03			jr .pastdmark  
c281 ..			.dmark: db "FN2"  
c284 f1			.pastdmark: pop af  
c285			endm  
# End of macro DMARK
c285						CALLMONITOR 
c285 cd 9d 94			call break_point_state  
c288				endm  
# End of macro CALLMONITOR
c288					endif 
c288					 
c288 01 00 00				ld bc, 0 
c28b 7e			.findchar:      ld a,(hl) 
c28c fe 00				cp 0   		 
c28e 28 27				jr z, .finddone     
c290 ba					cp d 
c291 28 20				jr z, .foundchar 
c293 03					inc bc 
c294 23					inc hl 
c295					if DEBUG_FORTH_WORDS 
c295						DMARK "FN3" 
c295 f5				push af  
c296 3a aa c2			ld a, (.dmark)  
c299 32 71 ee			ld (debug_mark),a  
c29c 3a ab c2			ld a, (.dmark+1)  
c29f 32 72 ee			ld (debug_mark+1),a  
c2a2 3a ac c2			ld a, (.dmark+2)  
c2a5 32 73 ee			ld (debug_mark+2),a  
c2a8 18 03			jr .pastdmark  
c2aa ..			.dmark: db "FN3"  
c2ad f1			.pastdmark: pop af  
c2ae			endm  
# End of macro DMARK
c2ae						CALLMONITOR 
c2ae cd 9d 94			call break_point_state  
c2b1				endm  
# End of macro CALLMONITOR
c2b1					endif 
c2b1 18 d8				jr .findchar 
c2b3			 
c2b3			 
c2b3 c5			.foundchar:	push bc 
c2b4 e1					pop hl 
c2b5 18 03				jr .findexit 
c2b7			 
c2b7			 
c2b7							 
c2b7			 
c2b7			.finddone:     ; got to end of string with no find 
c2b7 21 00 00				ld hl, 0 
c2ba			.findexit: 
c2ba			 
c2ba					if DEBUG_FORTH_WORDS 
c2ba						DMARK "FNd" 
c2ba f5				push af  
c2bb 3a cf c2			ld a, (.dmark)  
c2be 32 71 ee			ld (debug_mark),a  
c2c1 3a d0 c2			ld a, (.dmark+1)  
c2c4 32 72 ee			ld (debug_mark+1),a  
c2c7 3a d1 c2			ld a, (.dmark+2)  
c2ca 32 73 ee			ld (debug_mark+2),a  
c2cd 18 03			jr .pastdmark  
c2cf ..			.dmark: db "FNd"  
c2d2 f1			.pastdmark: pop af  
c2d3			endm  
# End of macro DMARK
c2d3						CALLMONITOR 
c2d3 cd 9d 94			call break_point_state  
c2d6				endm  
# End of macro CALLMONITOR
c2d6					endif 
c2d6 cd 0e 9b			call forth_push_numhl 
c2d9			 
c2d9				       NEXTW 
c2d9 c3 7c 9e			jp macro_next 
c2dc				endm 
# End of macro NEXTW
c2dc			 
c2dc			.LEN: 
c2dc				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
c2dc 4c				db WORD_SYS_CORE+56             
c2dd 46 c3			dw .CHAR            
c2df 06				db 5 + 1 
c2e0 .. 00			db "COUNT",0              
c2e6				endm 
# End of macro CWHEAD
c2e6			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
c2e6			 
c2e6					if DEBUG_FORTH_WORDS_KEY 
c2e6						DMARK "CNT" 
c2e6 f5				push af  
c2e7 3a fb c2			ld a, (.dmark)  
c2ea 32 71 ee			ld (debug_mark),a  
c2ed 3a fc c2			ld a, (.dmark+1)  
c2f0 32 72 ee			ld (debug_mark+1),a  
c2f3 3a fd c2			ld a, (.dmark+2)  
c2f6 32 73 ee			ld (debug_mark+2),a  
c2f9 18 03			jr .pastdmark  
c2fb ..			.dmark: db "CNT"  
c2fe f1			.pastdmark: pop af  
c2ff			endm  
# End of macro DMARK
c2ff						CALLMONITOR 
c2ff cd 9d 94			call break_point_state  
c302				endm  
# End of macro CALLMONITOR
c302					endif 
c302			; TODO check string type 
c302					FORTH_DSP_VALUE 
c302 cd ee 9c			call macro_forth_dsp_value 
c305				endm 
# End of macro FORTH_DSP_VALUE
c305			 
c305			 
c305					if DEBUG_FORTH_WORDS 
c305						DMARK "CN?" 
c305 f5				push af  
c306 3a 1a c3			ld a, (.dmark)  
c309 32 71 ee			ld (debug_mark),a  
c30c 3a 1b c3			ld a, (.dmark+1)  
c30f 32 72 ee			ld (debug_mark+1),a  
c312 3a 1c c3			ld a, (.dmark+2)  
c315 32 73 ee			ld (debug_mark+2),a  
c318 18 03			jr .pastdmark  
c31a ..			.dmark: db "CN?"  
c31d f1			.pastdmark: pop af  
c31e			endm  
# End of macro DMARK
c31e						CALLMONITOR 
c31e cd 9d 94			call break_point_state  
c321				endm  
# End of macro CALLMONITOR
c321					endif 
c321 cd fa 90				call strlenz 
c324					if DEBUG_FORTH_WORDS 
c324						DMARK "CNl" 
c324 f5				push af  
c325 3a 39 c3			ld a, (.dmark)  
c328 32 71 ee			ld (debug_mark),a  
c32b 3a 3a c3			ld a, (.dmark+1)  
c32e 32 72 ee			ld (debug_mark+1),a  
c331 3a 3b c3			ld a, (.dmark+2)  
c334 32 73 ee			ld (debug_mark+2),a  
c337 18 03			jr .pastdmark  
c339 ..			.dmark: db "CNl"  
c33c f1			.pastdmark: pop af  
c33d			endm  
# End of macro DMARK
c33d						CALLMONITOR 
c33d cd 9d 94			call break_point_state  
c340				endm  
# End of macro CALLMONITOR
c340					endif 
c340			 
c340 cd 0e 9b				call forth_push_numhl 
c343			 
c343			 
c343			 
c343				       NEXTW 
c343 c3 7c 9e			jp macro_next 
c346				endm 
# End of macro NEXTW
c346			.CHAR: 
c346				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
c346 4d				db WORD_SYS_CORE+57             
c347 7c c3			dw .ENDSTR            
c349 05				db 4 + 1 
c34a .. 00			db "CHAR",0              
c34f				endm 
# End of macro CWHEAD
c34f			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c34f					if DEBUG_FORTH_WORDS_KEY 
c34f						DMARK "CHR" 
c34f f5				push af  
c350 3a 64 c3			ld a, (.dmark)  
c353 32 71 ee			ld (debug_mark),a  
c356 3a 65 c3			ld a, (.dmark+1)  
c359 32 72 ee			ld (debug_mark+1),a  
c35c 3a 66 c3			ld a, (.dmark+2)  
c35f 32 73 ee			ld (debug_mark+2),a  
c362 18 03			jr .pastdmark  
c364 ..			.dmark: db "CHR"  
c367 f1			.pastdmark: pop af  
c368			endm  
# End of macro DMARK
c368						CALLMONITOR 
c368 cd 9d 94			call break_point_state  
c36b				endm  
# End of macro CALLMONITOR
c36b					endif 
c36b					FORTH_DSP 
c36b cd cb 9c			call macro_forth_dsp 
c36e				endm 
# End of macro FORTH_DSP
c36e					;v5 FORTH_DSP_VALUE 
c36e 23					inc hl      ; now at start of numeric as string 
c36f			 
c36f			;		push hl 
c36f			 
c36f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c36f cd bd 9d			call macro_forth_dsp_pop 
c372				endm 
# End of macro FORTH_DSP_POP
c372			 
c372			;		pop hl 
c372			 
c372					; push the content of a onto the stack as a value 
c372			 
c372 7e					ld a,(hl)   ; get char 
c373 26 00				ld h,0 
c375 6f					ld l,a 
c376 cd 0e 9b				call forth_push_numhl 
c379			 
c379				       NEXTW 
c379 c3 7c 9e			jp macro_next 
c37c				endm 
# End of macro NEXTW
c37c			 
c37c			 
c37c			 
c37c			 
c37c			.ENDSTR: 
c37c			; eof 
c37c			 
# End of file forth_words_str.asm
c37c			include "forth_words_key.asm" 
c37c			 
c37c			; | ## Keyboard Words 
c37c			 
c37c			.KEY: 
c37c				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c37c 3e				db WORD_SYS_CORE+42             
c37d ac c3			dw .WAITK            
c37f 04				db 3 + 1 
c380 .. 00			db "KEY",0              
c384				endm 
# End of macro CWHEAD
c384			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c384			 
c384					if DEBUG_FORTH_WORDS_KEY 
c384						DMARK "KEY" 
c384 f5				push af  
c385 3a 99 c3			ld a, (.dmark)  
c388 32 71 ee			ld (debug_mark),a  
c38b 3a 9a c3			ld a, (.dmark+1)  
c38e 32 72 ee			ld (debug_mark+1),a  
c391 3a 9b c3			ld a, (.dmark+2)  
c394 32 73 ee			ld (debug_mark+2),a  
c397 18 03			jr .pastdmark  
c399 ..			.dmark: db "KEY"  
c39c f1			.pastdmark: pop af  
c39d			endm  
# End of macro DMARK
c39d						CALLMONITOR 
c39d cd 9d 94			call break_point_state  
c3a0				endm  
# End of macro CALLMONITOR
c3a0					endif 
c3a0			; TODO currently waits 
c3a0 cd 97 da				call cin 
c3a3					;call cin_wait 
c3a3 6f					ld l, a 
c3a4 26 00				ld h, 0 
c3a6 cd 0e 9b				call forth_push_numhl 
c3a9					NEXTW 
c3a9 c3 7c 9e			jp macro_next 
c3ac				endm 
# End of macro NEXTW
c3ac			.WAITK: 
c3ac				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c3ac 3f				db WORD_SYS_CORE+43             
c3ad de c3			dw .ACCEPT            
c3af 06				db 5 + 1 
c3b0 .. 00			db "WAITK",0              
c3b6				endm 
# End of macro CWHEAD
c3b6			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c3b6					if DEBUG_FORTH_WORDS_KEY 
c3b6						DMARK "WAI" 
c3b6 f5				push af  
c3b7 3a cb c3			ld a, (.dmark)  
c3ba 32 71 ee			ld (debug_mark),a  
c3bd 3a cc c3			ld a, (.dmark+1)  
c3c0 32 72 ee			ld (debug_mark+1),a  
c3c3 3a cd c3			ld a, (.dmark+2)  
c3c6 32 73 ee			ld (debug_mark+2),a  
c3c9 18 03			jr .pastdmark  
c3cb ..			.dmark: db "WAI"  
c3ce f1			.pastdmark: pop af  
c3cf			endm  
# End of macro DMARK
c3cf						CALLMONITOR 
c3cf cd 9d 94			call break_point_state  
c3d2				endm  
# End of macro CALLMONITOR
c3d2					endif 
c3d2 cd 91 da				call cin_wait 
c3d5 6f					ld l, a 
c3d6 26 00				ld h, 0 
c3d8 cd 0e 9b				call forth_push_numhl 
c3db					NEXTW 
c3db c3 7c 9e			jp macro_next 
c3de				endm 
# End of macro NEXTW
c3de			.ACCEPT: 
c3de				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c3de 40				db WORD_SYS_CORE+44             
c3df 3c c4			dw .EDIT            
c3e1 07				db 6 + 1 
c3e2 .. 00			db "ACCEPT",0              
c3e9				endm 
# End of macro CWHEAD
c3e9			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c3e9					; TODO crashes on push 
c3e9					if DEBUG_FORTH_WORDS_KEY 
c3e9						DMARK "ACC" 
c3e9 f5				push af  
c3ea 3a fe c3			ld a, (.dmark)  
c3ed 32 71 ee			ld (debug_mark),a  
c3f0 3a ff c3			ld a, (.dmark+1)  
c3f3 32 72 ee			ld (debug_mark+1),a  
c3f6 3a 00 c4			ld a, (.dmark+2)  
c3f9 32 73 ee			ld (debug_mark+2),a  
c3fc 18 03			jr .pastdmark  
c3fe ..			.dmark: db "ACC"  
c401 f1			.pastdmark: pop af  
c402			endm  
# End of macro DMARK
c402						CALLMONITOR 
c402 cd 9d 94			call break_point_state  
c405				endm  
# End of macro CALLMONITOR
c405					endif 
c405 21 00 e5				ld hl, os_input 
c408 3e 00				ld a, 0 
c40a 77					ld (hl),a 
c40b 3a 6b ea				ld a,(f_cursor_ptr) 
c40e 16 64				ld d, 100 
c410 0e 00				ld c, 0 
c412 1e 28				ld e, 40 
c414 cd c9 8c				call input_str 
c417					; TODO perhaps do a type check and wrap in quotes if not a number 
c417 21 00 e5				ld hl, os_input 
c41a					if DEBUG_FORTH_WORDS 
c41a						DMARK "AC1" 
c41a f5				push af  
c41b 3a 2f c4			ld a, (.dmark)  
c41e 32 71 ee			ld (debug_mark),a  
c421 3a 30 c4			ld a, (.dmark+1)  
c424 32 72 ee			ld (debug_mark+1),a  
c427 3a 31 c4			ld a, (.dmark+2)  
c42a 32 73 ee			ld (debug_mark+2),a  
c42d 18 03			jr .pastdmark  
c42f ..			.dmark: db "AC1"  
c432 f1			.pastdmark: pop af  
c433			endm  
# End of macro DMARK
c433						CALLMONITOR 
c433 cd 9d 94			call break_point_state  
c436				endm  
# End of macro CALLMONITOR
c436					endif 
c436 cd 7c 9b				call forth_push_str 
c439					NEXTW 
c439 c3 7c 9e			jp macro_next 
c43c				endm 
# End of macro NEXTW
c43c			 
c43c			.EDIT: 
c43c				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
c43c 40				db WORD_SYS_CORE+44             
c43d de c4			dw .ENDKEY            
c43f 05				db 4 + 1 
c440 .. 00			db "EDIT",0              
c445				endm 
# End of macro CWHEAD
c445			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c445			 
c445					; TODO does not copy from stack 
c445					if DEBUG_FORTH_WORDS_KEY 
c445						DMARK "EDT" 
c445 f5				push af  
c446 3a 5a c4			ld a, (.dmark)  
c449 32 71 ee			ld (debug_mark),a  
c44c 3a 5b c4			ld a, (.dmark+1)  
c44f 32 72 ee			ld (debug_mark+1),a  
c452 3a 5c c4			ld a, (.dmark+2)  
c455 32 73 ee			ld (debug_mark+2),a  
c458 18 03			jr .pastdmark  
c45a ..			.dmark: db "EDT"  
c45d f1			.pastdmark: pop af  
c45e			endm  
# End of macro DMARK
c45e						CALLMONITOR 
c45e cd 9d 94			call break_point_state  
c461				endm  
# End of macro CALLMONITOR
c461					endif 
c461			 
c461					;FORTH_DSP 
c461					FORTH_DSP_VALUEHL 
c461 cd 05 9d			call macro_dsp_valuehl 
c464				endm 
# End of macro FORTH_DSP_VALUEHL
c464			;		inc hl    ; TODO do type check 
c464			 
c464			;		call get_word_hl 
c464 e5					push hl 
c465					if DEBUG_FORTH_WORDS 
c465						DMARK "EDp" 
c465 f5				push af  
c466 3a 7a c4			ld a, (.dmark)  
c469 32 71 ee			ld (debug_mark),a  
c46c 3a 7b c4			ld a, (.dmark+1)  
c46f 32 72 ee			ld (debug_mark+1),a  
c472 3a 7c c4			ld a, (.dmark+2)  
c475 32 73 ee			ld (debug_mark+2),a  
c478 18 03			jr .pastdmark  
c47a ..			.dmark: db "EDp"  
c47d f1			.pastdmark: pop af  
c47e			endm  
# End of macro DMARK
c47e						CALLMONITOR 
c47e cd 9d 94			call break_point_state  
c481				endm  
# End of macro CALLMONITOR
c481					endif 
c481				;	ld a, 0 
c481 cd fa 90				call strlenz 
c484 23					inc hl 
c485			 
c485 06 00				ld b, 0 
c487 4d					ld c, l 
c488			 
c488 e1					pop hl 
c489 11 00 e5				ld de, os_input 
c48c					if DEBUG_FORTH_WORDS_KEY 
c48c						DMARK "EDc" 
c48c f5				push af  
c48d 3a a1 c4			ld a, (.dmark)  
c490 32 71 ee			ld (debug_mark),a  
c493 3a a2 c4			ld a, (.dmark+1)  
c496 32 72 ee			ld (debug_mark+1),a  
c499 3a a3 c4			ld a, (.dmark+2)  
c49c 32 73 ee			ld (debug_mark+2),a  
c49f 18 03			jr .pastdmark  
c4a1 ..			.dmark: db "EDc"  
c4a4 f1			.pastdmark: pop af  
c4a5			endm  
# End of macro DMARK
c4a5						CALLMONITOR 
c4a5 cd 9d 94			call break_point_state  
c4a8				endm  
# End of macro CALLMONITOR
c4a8					endif 
c4a8 ed b0				ldir 
c4aa			 
c4aa			 
c4aa 21 00 e5				ld hl, os_input 
c4ad					;ld a, 0 
c4ad					;ld (hl),a 
c4ad 3a 6b ea				ld a,(f_cursor_ptr) 
c4b0 16 64				ld d, 100 
c4b2 0e 00				ld c, 0 
c4b4 1e 28				ld e, 40 
c4b6 cd c9 8c				call input_str 
c4b9					; TODO perhaps do a type check and wrap in quotes if not a number 
c4b9 21 00 e5				ld hl, os_input 
c4bc					if DEBUG_FORTH_WORDS 
c4bc						DMARK "ED1" 
c4bc f5				push af  
c4bd 3a d1 c4			ld a, (.dmark)  
c4c0 32 71 ee			ld (debug_mark),a  
c4c3 3a d2 c4			ld a, (.dmark+1)  
c4c6 32 72 ee			ld (debug_mark+1),a  
c4c9 3a d3 c4			ld a, (.dmark+2)  
c4cc 32 73 ee			ld (debug_mark+2),a  
c4cf 18 03			jr .pastdmark  
c4d1 ..			.dmark: db "ED1"  
c4d4 f1			.pastdmark: pop af  
c4d5			endm  
# End of macro DMARK
c4d5						CALLMONITOR 
c4d5 cd 9d 94			call break_point_state  
c4d8				endm  
# End of macro CALLMONITOR
c4d8					endif 
c4d8 cd 7c 9b				call forth_push_str 
c4db					NEXTW 
c4db c3 7c 9e			jp macro_next 
c4de				endm 
# End of macro NEXTW
c4de			 
c4de			 
c4de			 
c4de			.ENDKEY: 
c4de			; eof 
c4de			 
# End of file forth_words_key.asm
c4de			 
c4de			if STORAGE_SE 
c4de			   	include "forth_words_storage.asm" 
c4de			endif 
c4de				include "forth_words_device.asm" 
c4de			; Device related words 
c4de			 
c4de			; | ## Device Words 
c4de			 
c4de			if SOUND_ENABLE 
c4de			.NOTE: 
c4de				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c4de			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c4de					if DEBUG_FORTH_WORDS_KEY 
c4de						DMARK "NTE" 
c4de						CALLMONITOR 
c4de					endif 
c4de			 
c4de				 
c4de			 
c4de					NEXTW 
c4de			.AFTERSOUND: 
c4de			endif 
c4de			 
c4de			 
c4de			USE_GPIO: equ 0 
c4de			 
c4de			if USE_GPIO 
c4de			.GP1: 
c4de				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c4de			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c4de					NEXTW 
c4de			.GP2: 
c4de				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c4de			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c4de			 
c4de					NEXTW 
c4de			 
c4de			.GP3: 
c4de				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c4de			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c4de			 
c4de					NEXTW 
c4de			 
c4de			.GP4: 
c4de				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c4de			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c4de			 
c4de					NEXTW 
c4de			.SIN: 
c4de			 
c4de			 
c4de			endif 
c4de			 
c4de			 
c4de				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c4de 33				db WORD_SYS_CORE+31             
c4df 13 c5			dw .SOUT            
c4e1 03				db 2 + 1 
c4e2 .. 00			db "IN",0              
c4e5				endm 
# End of macro CWHEAD
c4e5			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c4e5					if DEBUG_FORTH_WORDS_KEY 
c4e5						DMARK "IN." 
c4e5 f5				push af  
c4e6 3a fa c4			ld a, (.dmark)  
c4e9 32 71 ee			ld (debug_mark),a  
c4ec 3a fb c4			ld a, (.dmark+1)  
c4ef 32 72 ee			ld (debug_mark+1),a  
c4f2 3a fc c4			ld a, (.dmark+2)  
c4f5 32 73 ee			ld (debug_mark+2),a  
c4f8 18 03			jr .pastdmark  
c4fa ..			.dmark: db "IN."  
c4fd f1			.pastdmark: pop af  
c4fe			endm  
# End of macro DMARK
c4fe						CALLMONITOR 
c4fe cd 9d 94			call break_point_state  
c501				endm  
# End of macro CALLMONITOR
c501					endif 
c501					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c501 cd 05 9d			call macro_dsp_valuehl 
c504				endm 
# End of macro FORTH_DSP_VALUEHL
c504			 
c504 e5					push hl 
c505			 
c505					; destroy value TOS 
c505			 
c505					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c505 cd bd 9d			call macro_forth_dsp_pop 
c508				endm 
# End of macro FORTH_DSP_POP
c508			 
c508					; one value on hl get other one back 
c508			 
c508 c1					pop bc 
c509			 
c509					; do the sub 
c509			;		ex de, hl 
c509			 
c509 ed 68				in l,(c) 
c50b			 
c50b					; save it 
c50b			 
c50b 26 00				ld h,0 
c50d			 
c50d					; TODO push value back onto stack for another op etc 
c50d			 
c50d cd 0e 9b				call forth_push_numhl 
c510					NEXTW 
c510 c3 7c 9e			jp macro_next 
c513				endm 
# End of macro NEXTW
c513			.SOUT: 
c513				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c513 34				db WORD_SYS_CORE+32             
c514 66 c5			dw .SPIO            
c516 04				db 3 + 1 
c517 .. 00			db "OUT",0              
c51b				endm 
# End of macro CWHEAD
c51b			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c51b					if DEBUG_FORTH_WORDS_KEY 
c51b						DMARK "OUT" 
c51b f5				push af  
c51c 3a 30 c5			ld a, (.dmark)  
c51f 32 71 ee			ld (debug_mark),a  
c522 3a 31 c5			ld a, (.dmark+1)  
c525 32 72 ee			ld (debug_mark+1),a  
c528 3a 32 c5			ld a, (.dmark+2)  
c52b 32 73 ee			ld (debug_mark+2),a  
c52e 18 03			jr .pastdmark  
c530 ..			.dmark: db "OUT"  
c533 f1			.pastdmark: pop af  
c534			endm  
# End of macro DMARK
c534						CALLMONITOR 
c534 cd 9d 94			call break_point_state  
c537				endm  
# End of macro CALLMONITOR
c537					endif 
c537			 
c537					; get port 
c537			 
c537					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c537 cd 05 9d			call macro_dsp_valuehl 
c53a				endm 
# End of macro FORTH_DSP_VALUEHL
c53a			 
c53a e5					push hl 
c53b			 
c53b					; destroy value TOS 
c53b			 
c53b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c53b cd bd 9d			call macro_forth_dsp_pop 
c53e				endm 
# End of macro FORTH_DSP_POP
c53e			 
c53e					; get byte to send 
c53e			 
c53e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c53e cd 05 9d			call macro_dsp_valuehl 
c541				endm 
# End of macro FORTH_DSP_VALUEHL
c541			 
c541			;		push hl 
c541			 
c541					; destroy value TOS 
c541			 
c541					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c541 cd bd 9d			call macro_forth_dsp_pop 
c544				endm 
# End of macro FORTH_DSP_POP
c544			 
c544					; one value on hl get other one back 
c544			 
c544			;		pop hl 
c544			 
c544 c1					pop bc 
c545			 
c545					if DEBUG_FORTH_WORDS 
c545						DMARK "OUT" 
c545 f5				push af  
c546 3a 5a c5			ld a, (.dmark)  
c549 32 71 ee			ld (debug_mark),a  
c54c 3a 5b c5			ld a, (.dmark+1)  
c54f 32 72 ee			ld (debug_mark+1),a  
c552 3a 5c c5			ld a, (.dmark+2)  
c555 32 73 ee			ld (debug_mark+2),a  
c558 18 03			jr .pastdmark  
c55a ..			.dmark: db "OUT"  
c55d f1			.pastdmark: pop af  
c55e			endm  
# End of macro DMARK
c55e						CALLMONITOR 
c55e cd 9d 94			call break_point_state  
c561				endm  
# End of macro CALLMONITOR
c561					endif 
c561			 
c561 ed 69				out (c), l 
c563			 
c563					NEXTW 
c563 c3 7c 9e			jp macro_next 
c566				endm 
# End of macro NEXTW
c566			 
c566			 
c566			.SPIO: 
c566			 
c566			if STORAGE_SE 
c566				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c566			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c566			 
c566					call spi_ce_low 
c566			    NEXTW 
c566			 
c566			.SPICEH: 
c566				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c566			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c566			 
c566					call spi_ce_high 
c566			    NEXTW 
c566			 
c566			 
c566			.SPIOb: 
c566			 
c566				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c566			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c566			 
c566					; get port 
c566			 
c566			 
c566					; get byte to send 
c566			 
c566					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c566			 
c566			;		push hl    ; u1  
c566			 
c566					; destroy value TOS 
c566			 
c566					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c566			 
c566					; one value on hl get other one back 
c566			 
c566			;		pop hl   ; u2 - addr 
c566			 
c566					; TODO Send SPI byte 
c566			 
c566					ld a, l 
c566					call spi_send_byte 
c566			 
c566					NEXTW 
c566			 
c566			.SPII: 
c566				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c566			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c566			 
c566					; TODO Get SPI byte 
c566			 
c566					call spi_read_byte 
c566			 
c566					ld h, 0 
c566					ld l, a 
c566					call forth_push_numhl 
c566			 
c566					NEXTW 
c566			 
c566			 
c566			 
c566			.SESEL: 
c566				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c566			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c566					if DEBUG_FORTH_WORDS_KEY 
c566						DMARK "BNK" 
c566						CALLMONITOR 
c566					endif 
c566			 
c566					ld a, 255 
c566					ld (spi_cartdev), a 
c566			 
c566					; get bank 
c566			 
c566					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c566			 
c566			;		push hl 
c566			 
c566					; destroy value TOS 
c566			 
c566					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c566			 
c566					; one value on hl get other one back 
c566			 
c566			;		pop hl 
c566			 
c566			 
c566					ld c, SPI_CE_HIGH 
c566					ld b, '0'    ; human readable bank number 
c566			 
c566					ld a, l 
c566			 
c566					if DEBUG_FORTH_WORDS 
c566						DMARK "BNK" 
c566						CALLMONITOR 
c566					endif 
c566			 
c566					; active low 
c566			 
c566					cp 0 
c566					jr z, .bset 
c566					cp 1 
c566					jr nz, .b2 
c566					res 0, c 
c566					ld b, '1'    ; human readable bank number 
c566			.b2:		cp 2 
c566					jr nz, .b3 
c566					res 1, c 
c566					ld b, '2'    ; human readable bank number 
c566			.b3:		cp 3 
c566					jr nz, .b4 
c566					res 2, c 
c566					ld b, '3'    ; human readable bank number 
c566			.b4:		cp 4 
c566					jr nz, .b5 
c566					res 3, c 
c566					ld b, '4'    ; human readable bank number 
c566			.b5:		cp 5 
c566					jr nz, .bset 
c566					res 4, c 
c566					ld b, '5'    ; human readable bank number 
c566			 
c566			.bset: 
c566					ld a, c 
c566					ld (spi_device),a 
c566					ld a, b 
c566					ld (spi_device_id),a 
c566					if DEBUG_FORTH_WORDS 
c566						DMARK "BN2" 
c566						CALLMONITOR 
c566					endif 
c566			 
c566					NEXTW 
c566			 
c566			.CARTDEV: 
c566				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c566			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c566					if DEBUG_FORTH_WORDS_KEY 
c566						DMARK "CDV" 
c566						CALLMONITOR 
c566					endif 
c566			 
c566					; disable se storage bank selection 
c566			 
c566					ld a, SPI_CE_HIGH		; ce high 
c566					ld (spi_device), a 
c566			 
c566					; get bank 
c566			 
c566					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c566			 
c566			;		push hl 
c566			 
c566					; destroy value TOS 
c566			 
c566					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c566			 
c566					; one value on hl get other one back 
c566			 
c566			;		pop hl 
c566			 
c566					; active low 
c566			 
c566					ld c, 255 
c566			 
c566					ld a, l 
c566					if DEBUG_FORTH_WORDS 
c566						DMARK "CDV" 
c566						CALLMONITOR 
c566					endif 
c566					cp 0 
c566					jr z, .cset 
c566					cp 1 
c566					jr nz, .c2 
c566					res 0, c 
c566			.c2:		cp 2 
c566					jr nz, .c3 
c566					res 1, c 
c566			.c3:		cp 3 
c566					jr nz, .c4 
c566					res 2, c 
c566			.c4:		cp 4 
c566					jr nz, .c5 
c566					res 3, c 
c566			.c5:		cp 5 
c566					jr nz, .c6 
c566					res 4, c 
c566			.c6:		cp 6 
c566					jr nz, .c7 
c566					res 5, c 
c566			.c7:		cp 7 
c566					jr nz, .c8 
c566					res 6, c 
c566			.c8:		cp 8 
c566					jr nz, .cset 
c566					res 7, c 
c566			.cset:		ld a, c 
c566					ld (spi_cartdev),a 
c566			 
c566					if DEBUG_FORTH_WORDS 
c566						DMARK "CD2" 
c566						CALLMONITOR 
c566					endif 
c566					NEXTW 
c566			endif 
c566			 
c566			.ENDDEVICE: 
c566			; eof 
c566			 
# End of file forth_words_device.asm
c566			 
c566			; var handler 
c566			 
c566			 
c566			.VARS: 
c566				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
c566 78				db WORD_SYS_CORE+100             
c567 7e c5			dw .V0Q            
c569 04				db 3 + 1 
c56a .. 00			db "V0!",0              
c56e				endm 
# End of macro CWHEAD
c56e			;| V0! ( u1 -- )  Store value to v0  | DONE 
c56e			 
c56e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c56e cd 05 9d			call macro_dsp_valuehl 
c571				endm 
# End of macro FORTH_DSP_VALUEHL
c571			 
c571 11 35 ea				ld de, cli_var_array 
c574			 
c574 eb					ex de, hl 
c575 73					ld (hl), e 
c576 23					inc hl 
c577 72					ld (hl), d 
c578			 
c578					; destroy value TOS 
c578			 
c578					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c578 cd bd 9d			call macro_forth_dsp_pop 
c57b				endm 
# End of macro FORTH_DSP_POP
c57b			 
c57b				       NEXTW 
c57b c3 7c 9e			jp macro_next 
c57e				endm 
# End of macro NEXTW
c57e			.V0Q: 
c57e				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
c57e 79				db WORD_SYS_CORE+101             
c57f 8f c5			dw .V1S            
c581 04				db 3 + 1 
c582 .. 00			db "V0@",0              
c586				endm 
# End of macro CWHEAD
c586			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
c586 2a 35 ea				ld hl, (cli_var_array) 
c589 cd 0e 9b				call forth_push_numhl 
c58c			 
c58c				       NEXTW 
c58c c3 7c 9e			jp macro_next 
c58f				endm 
# End of macro NEXTW
c58f			.V1S: 
c58f				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
c58f 7a				db WORD_SYS_CORE+102             
c590 a7 c5			dw .V1Q            
c592 04				db 3 + 1 
c593 .. 00			db "V1!",0              
c597				endm 
# End of macro CWHEAD
c597			;| V1! ( u1 -- )  Store value to v1 | DONE 
c597					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c597 cd 05 9d			call macro_dsp_valuehl 
c59a				endm 
# End of macro FORTH_DSP_VALUEHL
c59a			 
c59a 11 37 ea				ld de, cli_var_array+2 
c59d				 
c59d eb					ex de, hl 
c59e 73					ld (hl), e 
c59f 23					inc hl 
c5a0 72					ld (hl), d 
c5a1			 
c5a1					; destroy value TOS 
c5a1			 
c5a1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c5a1 cd bd 9d			call macro_forth_dsp_pop 
c5a4				endm 
# End of macro FORTH_DSP_POP
c5a4				       NEXTW 
c5a4 c3 7c 9e			jp macro_next 
c5a7				endm 
# End of macro NEXTW
c5a7			.V1Q: 
c5a7				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
c5a7 7b				db WORD_SYS_CORE+103             
c5a8 b8 c5			dw .V2S            
c5aa 04				db 3 + 1 
c5ab .. 00			db "V1@",0              
c5af				endm 
# End of macro CWHEAD
c5af			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
c5af 2a 37 ea				ld hl, (cli_var_array+2) 
c5b2 cd 0e 9b				call forth_push_numhl 
c5b5				       NEXTW 
c5b5 c3 7c 9e			jp macro_next 
c5b8				endm 
# End of macro NEXTW
c5b8			.V2S: 
c5b8				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
c5b8 7c				db WORD_SYS_CORE+104             
c5b9 d0 c5			dw .V2Q            
c5bb 04				db 3 + 1 
c5bc .. 00			db "V2!",0              
c5c0				endm 
# End of macro CWHEAD
c5c0			;| V2! ( u1 -- )  Store value to v2 | DONE 
c5c0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c5c0 cd 05 9d			call macro_dsp_valuehl 
c5c3				endm 
# End of macro FORTH_DSP_VALUEHL
c5c3			 
c5c3 11 39 ea				ld de, cli_var_array+4 
c5c6				 
c5c6 eb					ex de, hl 
c5c7 73					ld (hl), e 
c5c8 23					inc hl 
c5c9 72					ld (hl), d 
c5ca			 
c5ca					; destroy value TOS 
c5ca			 
c5ca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c5ca cd bd 9d			call macro_forth_dsp_pop 
c5cd				endm 
# End of macro FORTH_DSP_POP
c5cd				       NEXTW 
c5cd c3 7c 9e			jp macro_next 
c5d0				endm 
# End of macro NEXTW
c5d0			.V2Q: 
c5d0				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
c5d0 7d				db WORD_SYS_CORE+105             
c5d1 e1 c5			dw .V3S            
c5d3 04				db 3 + 1 
c5d4 .. 00			db "V2@",0              
c5d8				endm 
# End of macro CWHEAD
c5d8			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
c5d8 2a 39 ea				ld hl, (cli_var_array+4) 
c5db cd 0e 9b				call forth_push_numhl 
c5de				       NEXTW 
c5de c3 7c 9e			jp macro_next 
c5e1				endm 
# End of macro NEXTW
c5e1			.V3S: 
c5e1				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
c5e1 7c				db WORD_SYS_CORE+104             
c5e2 f9 c5			dw .V3Q            
c5e4 04				db 3 + 1 
c5e5 .. 00			db "V3!",0              
c5e9				endm 
# End of macro CWHEAD
c5e9			;| V3! ( u1 -- )  Store value to v3 | DONE 
c5e9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c5e9 cd 05 9d			call macro_dsp_valuehl 
c5ec				endm 
# End of macro FORTH_DSP_VALUEHL
c5ec			 
c5ec 11 3b ea				ld de, cli_var_array+6 
c5ef				 
c5ef eb					ex de, hl 
c5f0 73					ld (hl), e 
c5f1 23					inc hl 
c5f2 72					ld (hl), d 
c5f3			 
c5f3					; destroy value TOS 
c5f3			 
c5f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c5f3 cd bd 9d			call macro_forth_dsp_pop 
c5f6				endm 
# End of macro FORTH_DSP_POP
c5f6				       NEXTW 
c5f6 c3 7c 9e			jp macro_next 
c5f9				endm 
# End of macro NEXTW
c5f9			.V3Q: 
c5f9				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
c5f9 7d				db WORD_SYS_CORE+105             
c5fa 0a c6			dw .END            
c5fc 04				db 3 + 1 
c5fd .. 00			db "V3@",0              
c601				endm 
# End of macro CWHEAD
c601			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
c601 2a 3b ea				ld hl, (cli_var_array+6) 
c604 cd 0e 9b				call forth_push_numhl 
c607				       NEXTW 
c607 c3 7c 9e			jp macro_next 
c60a				endm 
# End of macro NEXTW
c60a			 
c60a			 
c60a			 
c60a			 
c60a			 
c60a			; end of dict marker 
c60a			 
c60a 00			.END:    db WORD_SYS_END 
c60b 00 00			dw 0 
c60d 00				db 0 
c60e			 
c60e			; use to jp here for user dict words to save on macro expansion  
c60e			 
c60e			user_dict_next: 
c60e				NEXTW 
c60e c3 7c 9e			jp macro_next 
c611				endm 
# End of macro NEXTW
c611			 
c611			 
c611			user_exec: 
c611				;    ld hl, <word code> 
c611				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
c611				;    call forthexec 
c611				;    jp user_dict_next   (NEXT) 
c611			        ;    <word code bytes> 
c611 eb				ex de, hl 
c612 2a 03 e6			ld hl,(os_tok_ptr) 
c615				 
c615				FORTH_RSP_NEXT 
c615 cd b5 9a			call macro_forth_rsp_next 
c618				endm 
# End of macro FORTH_RSP_NEXT
c618			 
c618			if DEBUG_FORTH_UWORD 
c618						DMARK "UEX" 
c618 f5				push af  
c619 3a 2d c6			ld a, (.dmark)  
c61c 32 71 ee			ld (debug_mark),a  
c61f 3a 2e c6			ld a, (.dmark+1)  
c622 32 72 ee			ld (debug_mark+1),a  
c625 3a 2f c6			ld a, (.dmark+2)  
c628 32 73 ee			ld (debug_mark+2),a  
c62b 18 03			jr .pastdmark  
c62d ..			.dmark: db "UEX"  
c630 f1			.pastdmark: pop af  
c631			endm  
# End of macro DMARK
c631				CALLMONITOR 
c631 cd 9d 94			call break_point_state  
c634				endm  
# End of macro CALLMONITOR
c634			endif 
c634			 
c634			 
c634			 
c634 eb				ex de, hl 
c635 22 03 e6			ld (os_tok_ptr), hl 
c638				 
c638				; Don't use next - Skips the first word in uword. 
c638			 
c638 c3 0d 9f			jp exec1 
c63b			;	NEXT 
c63b			 
c63b			 
c63b			; eof 
# End of file forth_wordsv4.asm
c63b			endif 
c63b			;;;;;;;;;;;;;; Debug code 
c63b			 
c63b			 
c63b			;if DEBUG_FORTH_PARSE 
c63b .. 00		.nowordfound: db "No match",0 
c644 .. 00		.compword:	db "Comparing word ",0 
c654 .. 00		.nextwordat:	db "Next word at",0 
c661 .. 00		.charmatch:	db "Char match",0 
c66c			;endif 
c66c			if DEBUG_FORTH_JP 
c66c			.foundword:	db "Word match. Exec..",0 
c66c			endif 
c66c			;if DEBUG_FORTH_PUSH 
c66c .. 00		.enddict:	db "Dict end. Push.",0 
c67c .. 00		.push_str:	db "Pushing string",0 
c68b .. 00		.push_num:	db "Pushing number",0 
c69a .. 00		.data_sp:	db "SP:",0 
c69e .. 00		.wordinhl:	db "Word in HL (2/0):",0 
c6b0 .. 00		.wordinde:	db "Word in DE (3/0):",0 
c6c2 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
c6d4			;endif 
c6d4			;if DEBUG_FORTH_MALLOC 
c6d4 .. 00		.push_malloc:	db "Malloc address",0 
c6e3			;endif 
c6e3			 
c6e3			 
c6e3			 
c6e3			; display malloc address and current data stack pointer  
c6e3			 
c6e3			malloc_error: 
c6e3 d5				push de 
c6e4 f5				push af 
c6e5 e5				push hl 
c6e6 cd 6f 8a			call clear_display 
c6e9 11 0b c7			ld de, .mallocerr 
c6ec 3e 00			ld a,0 
c6ee			;	ld de,os_word_scratch 
c6ee cd 82 8a			call str_at_display 
c6f1 3e 11			ld a, display_row_1+17 
c6f3 11 71 ee			ld de, debug_mark 
c6f6 cd 82 8a			call str_at_display 
c6f9 cd 92 8a			call update_display 
c6fc				;call break_point_state 
c6fc cd 91 da			call cin_wait 
c6ff			 
c6ff 3e 20			ld a, ' ' 
c701 32 f3 e2			ld (os_view_disable), a 
c704 e1				pop hl 
c705 f1				pop af 
c706 d1				pop de	 
c707				CALLMONITOR 
c707 cd 9d 94			call break_point_state  
c70a				endm  
# End of macro CALLMONITOR
c70a c9				ret 
c70b			 
c70b .. 00		.mallocerr: 	db "Malloc Error",0 
c718			;if DEBUG_FORTH_PUSH 
c718			display_data_sp: 
c718 f5				push af 
c719			 
c719				; see if disabled 
c719			 
c719 3a f3 e2			ld a, (os_view_disable) 
c71c fe 2a			cp '*' 
c71e 28 67			jr z, .skipdsp 
c720			 
c720 e5				push hl 
c721 e5				push hl 
c722 e5			push hl 
c723 cd 6f 8a			call clear_display 
c726 e1			pop hl 
c727 7c				ld a,h 
c728 21 07 e6			ld hl, os_word_scratch 
c72b cd 9d 8f			call hexout 
c72e e1				pop hl 
c72f 7d				ld a,l 
c730 21 09 e6			ld hl, os_word_scratch+2 
c733 cd 9d 8f			call hexout 
c736 21 0b e6			ld hl, os_word_scratch+4 
c739 3e 00			ld a,0 
c73b 77				ld (hl),a 
c73c 11 07 e6			ld de,os_word_scratch 
c73f 3e 28				ld a, display_row_2 
c741 cd 82 8a				call str_at_display 
c744 11 9e c6			ld de, .wordinhl 
c747 3e 00			ld a, display_row_1 
c749			 
c749 cd 82 8a				call str_at_display 
c74c 11 71 ee			ld de, debug_mark 
c74f 3e 11			ld a, display_row_1+17 
c751			 
c751 cd 82 8a				call str_at_display 
c754			 
c754				; display current data stack pointer 
c754 11 9a c6			ld de,.data_sp 
c757 3e 30				ld a, display_row_2 + 8 
c759 cd 82 8a				call str_at_display 
c75c			 
c75c 2a 2f ea			ld hl,(cli_data_sp) 
c75f e5				push hl 
c760 7c				ld a,h 
c761 21 07 e6			ld hl, os_word_scratch 
c764 cd 9d 8f			call hexout 
c767 e1				pop hl 
c768 7d				ld a,l 
c769 21 09 e6			ld hl, os_word_scratch+2 
c76c cd 9d 8f			call hexout 
c76f 21 0b e6			ld hl, os_word_scratch+4 
c772 3e 00			ld a,0 
c774 77				ld (hl),a 
c775 11 07 e6			ld de,os_word_scratch 
c778 3e 33				ld a, display_row_2 + 11 
c77a cd 82 8a				call str_at_display 
c77d			 
c77d			 
c77d cd 92 8a			call update_display 
c780 cd ec 89			call delay1s 
c783 cd ec 89			call delay1s 
c786 e1				pop hl 
c787			.skipdsp: 
c787 f1				pop af 
c788 c9				ret 
c789			 
c789			display_data_malloc: 
c789			 
c789 f5				push af 
c78a e5				push hl 
c78b e5				push hl 
c78c e5			push hl 
c78d cd 6f 8a			call clear_display 
c790 e1			pop hl 
c791 7c				ld a,h 
c792 21 07 e6			ld hl, os_word_scratch 
c795 cd 9d 8f			call hexout 
c798 e1				pop hl 
c799 7d				ld a,l 
c79a 21 09 e6			ld hl, os_word_scratch+2 
c79d cd 9d 8f			call hexout 
c7a0 21 0b e6			ld hl, os_word_scratch+4 
c7a3 3e 00			ld a,0 
c7a5 77				ld (hl),a 
c7a6 11 07 e6			ld de,os_word_scratch 
c7a9 3e 28				ld a, display_row_2 
c7ab cd 82 8a				call str_at_display 
c7ae 11 d4 c6			ld de, .push_malloc 
c7b1 3e 00			ld a, display_row_1 
c7b3			 
c7b3 cd 82 8a				call str_at_display 
c7b6			 
c7b6				; display current data stack pointer 
c7b6 11 9a c6			ld de,.data_sp 
c7b9 3e 30				ld a, display_row_2 + 8 
c7bb cd 82 8a				call str_at_display 
c7be			 
c7be 2a 2f ea			ld hl,(cli_data_sp) 
c7c1 e5				push hl 
c7c2 7c				ld a,h 
c7c3 21 07 e6			ld hl, os_word_scratch 
c7c6 cd 9d 8f			call hexout 
c7c9 e1				pop hl 
c7ca 7d				ld a,l 
c7cb 21 09 e6			ld hl, os_word_scratch+2 
c7ce cd 9d 8f			call hexout 
c7d1 21 0b e6			ld hl, os_word_scratch+4 
c7d4 3e 00			ld a,0 
c7d6 77				ld (hl),a 
c7d7 11 07 e6			ld de,os_word_scratch 
c7da 3e 33				ld a, display_row_2 + 11 
c7dc cd 82 8a				call str_at_display 
c7df			 
c7df cd 92 8a			call update_display 
c7e2 cd ec 89			call delay1s 
c7e5 cd ec 89			call delay1s 
c7e8 e1				pop hl 
c7e9 f1				pop af 
c7ea c9				ret 
c7eb			;endif 
c7eb			 
c7eb			include "forth_autostart.asm" 
c7eb			; list of commands to perform at system start up 
c7eb			 
c7eb			startcmds: 
c7eb			;	dw test11 
c7eb			;	dw test12 
c7eb			;	dw test13 
c7eb			;	dw test14 
c7eb			;	dw test15 
c7eb			;	dw test16 
c7eb			;	dw test17 
c7eb			;	dw ifthtest1 
c7eb			;	dw ifthtest2 
c7eb			;	dw ifthtest3 
c7eb			;	dw mmtest1 
c7eb			;	dw mmtest2 
c7eb			;	dw mmtest3 
c7eb			;	dw mmtest4 
c7eb			;	dw mmtest5 
c7eb			;	dw mmtest6 
c7eb			;	dw iftest1 
c7eb			;	dw iftest2 
c7eb			;	dw iftest3 
c7eb			;	dw looptest1 
c7eb			;	dw looptest2 
c7eb			;	dw test1 
c7eb			;	dw test2 
c7eb			;	dw test3 
c7eb			;	dw test4 
c7eb			;	dw game2r 
c7eb			;	dw game2b1 
c7eb			;	dw game2b2 
c7eb			 
c7eb				; start up words that are actually useful 
c7eb			 
c7eb 4b c8			dw longread 
c7ed 92 c8			dw clrstack 
c7ef c5 c8			dw type 
c7f1 b5 ca			dw stest 
c7f3 e9 c8			dw strncpy 
c7f5 4b ca			dw list 
c7f7 4a c9			dw start1 
c7f9 5c c9			dw start2 
c7fb			;	dw start3 
c7fb 6f c9			dw start3b 
c7fd eb c9			dw start3c 
c7ff			 
c7ff				; (unit) testing words 
c7ff			 
c7ff 2c cb			dw mtesta 
c801 e1 cb			dw mtestb 
c803 84 cc			dw mtestc 
c805 39 cd			dw mtestd 
c807 dd cd			dw mteste 
c809			 
c809				; demo/game words 
c809			 
c809 e9 d4		        dw game3w 
c80b 17 d5		        dw game3p 
c80d 35 d5		        dw game3sc 
c80f 66 d5		        dw game3vsi 
c811 92 d5		        dw game3vs 
c813				 
c813 dc d2			dw game2b 
c815 4a d3			dw game2bf 
c817 94 d3			dw game2mba 
c819 2a d4			dw game2mbas 
c81b 6c d4			dw game2mb 
c81d			 
c81d 9d cf			dw game1 
c81f ae cf			dw game1a 
c821 10 d0			dw game1b 
c823 45 d0			dw game1c 
c825 7b d0			dw game1d 
c827 ac d0			dw game1s 
c829 c0 d0			dw game1t 
c82b d5 d0			dw game1f 
c82d 09 d1			dw game1z 
c82f 4d d1			dw game1zz 
c831			 
c831 93 ce			dw test5 
c833 cb ce			dw test6 
c835 03 cf			dw test7 
c837 17 cf			dw test8 
c839 43 cf			dw test9 
c83b 59 cf			dw test10 
c83d				 
c83d 24 d2		        dw ssv5 
c83f 08 d2		        dw ssv4 
c841 ec d1		        dw ssv3 
c843 b6 d1		        dw ssv2 
c845 3d d2		        dw ssv1 
c847 85 d2		        dw ssv1cpm 
c849			;	dw keyup 
c849			;	dw keydown 
c849			;	dw keyleft 
c849			;	dw keyright 
c849			;	dw 	keyf1 
c849			;	dw keyf2 
c849			;	dw keyf3 
c849			;	dw keyf4 
c849			;	dw keyf5 
c849			;	dw keyf6 
c849			;	dw keyf7 
c849			;	dw keyf8 
c849			;	dw keyf9 
c849			;	dw keyf10 
c849			;	dw keyf11 
c849			;	dw keyf12 
c849			;	dw keytab 
c849			;	dw keycr 
c849			;	dw keyhome 
c849			;	dw keyend 
c849			;	dw keybs 
c849 00 00			db 0, 0	 
c84b			 
c84b			 
c84b			; Long read of currently open file 
c84b .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
c892			 
c892			; clear stack  
c892			 
c892 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
c8c5			 
c8c5			; type ( addr count - ) 
c8c5 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
c8e9			 
c8e9			; some direct memory words 
c8e9			; strncpy ( len t f -- t ) 
c8e9			 
c8e9 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
c94a			 
c94a .. 00		start1:     	db ": bpon $0000 bp ;",0 
c95c .. 00		start2:     	db ": bpoff $0001 bp ;",0 
c96f .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
c9eb .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
ca4b			 
ca4b			 
ca4b			; a handy word to list items on the stack 
ca4b			 
ca4b .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
cab5			 
cab5			 
cab5			; test stack  
cab5			; rnd8 stest 
cab5			 
cab5 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
cb2c			 
cb2c			; random malloc and free cycles 
cb2c			 
cb2c .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
cbe1			 
cbe1			; fixed malloc and free cycles 
cbe1			 
cbe1 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
cc84			 
cc84			; fixed double string push and drop cycle  
cc84			 
cc84 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
cd39			 
cd39			; consistent fixed string push and drop cycle  
cd39			 
cd39 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cddd			 
cddd .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
ce93			 
ce93			;test1:		db ": aa 1 2 3 ;", 0 
ce93			;test2:     	db "111 aa 888 999",0 
ce93			;test3:     	db ": bb 77 ;",0 
ce93			;test4:     	db "$02 $01 do i . loop bb",0 
ce93			 
ce93 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
cecb .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
cf03 .. 00		test7:     	db ": box hline vline ;",0 
cf17 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
cf43 .. 00		test9:     	db ": sw $01 adsp world ;",0 
cf59 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
cf7e .. 00		test11:     	db "hello create .",0 
cf8d .. 00		test12:     	db "hello2 create .",0 
cf9d			 
cf9d			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
cf9d			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
cf9d			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
cf9d			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
cf9d			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
cf9d			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
cf9d			 
cf9d			;iftest1:     	db "$0001 IF cls .",0 
cf9d			;iftest2:     	db "$0000 IF cls .",0 
cf9d			;iftest3:     	db "$0002 $0003 - IF cls .",0 
cf9d			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
cf9d			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
cf9d			 
cf9d			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cf9d			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cf9d			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
cf9d			 
cf9d			 
cf9d			 
cf9d			; a small guess the number game 
cf9d			 
cf9d .. 00		game1:          db ": gsn rnd8 v1! ;",0 
cfae .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
d010			 
d010 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
d045 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
d07b .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
d0ac .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
d0c0 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
d0d5 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
d109 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
d14d			 
d14d			; Using 'ga' save a high score across multiple runs using external storage 
d14d			 
d14d .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
d1b6			 
d1b6			 
d1b6			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
d1b6			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
d1b6			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
d1b6			 
d1b6			; simple screen saver to test code memory reuse to destruction 
d1b6			 
d1b6 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
d1ec .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
d208 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
d224 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
d23d .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
d285 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
d2dc			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
d2dc			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
d2dc			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
d2dc			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
d2dc			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
d2dc			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
d2dc			 
d2dc			 
d2dc			 
d2dc			; minesweeper/battleship finding game 
d2dc			; draws a game board of random ship/mine positions 
d2dc			; user enters coords to see if it hits on 
d2dc			; game ends when all are hit 
d2dc			; when hit or miss says how many may be in the area 
d2dc			 
d2dc			; setup the game board and then hide it 
d2dc .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
d34a .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
d394			; prompt for where to target 
d394 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
d42a .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
d44f			; TODO see if the entered coords hits or misses pushes char hit of miss 
d44f .. 00		game2mbht:      db ": mbckht nop ;",0 
d45e .. 00		game2mbms:      db ": mbcms nop ;",0 
d46c			; TODO how many might be near by 
d46c .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
d4e9			 
d4e9			; Game 3 
d4e9			 
d4e9			; Vert scroller ski game - avoid the trees! 
d4e9			 
d4e9			; v0 score (ie turns) 
d4e9			; v1 player pos 
d4e9			; v2 left wall 
d4e9			; v3 right wall 
d4e9			 
d4e9			; Draw side walls randomly 
d4e9			 
d4e9 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
d517			 
d517			; Draw player 
d517 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
d535			 
d535			; TODO Get Key 
d535			 
d535			; TODO Move left right 
d535			 
d535			; scroll and move walls a bit 
d535			 
d535 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
d566			 
d566			; main game loop 
d566			 
d566 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
d592 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
d5d1			 
d5d1			; key board defs 
d5d1			 
d5d1 .. 00		keyup:       db ": keyup $05 ;",0 
d5df .. 00		keydown:       db ": keydown $0a ;",0 
d5ef .. 00		keyleft:       db ": keyleft $0b ;",0 
d5ff .. 00		keyright:       db ": keyright $0c ;",0 
d610 .. 00		keyf1:       db ": keyf1 $10 ;",0 
d61e .. 00		keyf2:       db ": keyf2 $11 ;",0 
d62c .. 00		keyf3:       db ": keyf3 $12 ;",0 
d63a .. 00		keyf4:       db ": keyf4 $13 ;",0 
d648 .. 00		keyf5:       db ": keyf5 $14 ;",0 
d656 .. 00		keyf6:       db ": keyf6 $15 ;",0 
d664 .. 00		keyf7:       db ": keyf7 $16 ;",0 
d672 .. 00		keyf8:       db ": keyf8 $17 ;",0 
d680 .. 00		keyf9:       db ": keyf9 $18 ;",0 
d68e .. 00		keyf10:       db ": keyf10 $19 ;",0 
d69d .. 00		keyf11:       db ": keyf11 $1a ;",0 
d6ac .. 00		keyf12:       db ": keyf12 $1b ;",0 
d6bb			 
d6bb .. 00		keytab:       db ": keytab $09 ;",0 
d6ca .. 00		keycr:       db ": keycr $0d ;",0 
d6d8 .. 00		keyhome:       db ": keyhome $0e ;",0 
d6e8 .. 00		keyend:       db ": keyend $0f ;",0 
d6f7 .. 00		keybs:       db ": keybs $08 ;",0 
d705			 
d705			   
d705			 
d705			 
d705			 
d705			; eof 
# End of file forth_autostart.asm
d705			 
d705 .. 00		sprompt1: db "Startup load...",0 
d715 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
d72b			 
d72b			 
d72b			 
d72b			 
d72b			forth_startup: 
d72b 21 eb c7			ld hl, startcmds 
d72e 3e 00			ld a, 0 
d730 32 28 e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
d733			 
d733 e5			.start1:	push hl 
d734 cd 6f 8a			call clear_display 
d737 11 05 d7			ld de, sprompt1 
d73a 3e 00		        ld a, display_row_1 
d73c cd 82 8a			call str_at_display 
d73f 11 15 d7			ld de, sprompt2 
d742 3e 28		        ld a, display_row_2 
d744 cd 82 8a			call str_at_display 
d747 e1				pop hl 
d748 e5				push hl 
d749 5e				ld e,(hl) 
d74a 23				inc hl 
d74b 56				ld d,(hl) 
d74c 3e 50		        ld a, display_row_3 
d74e cd 82 8a			call str_at_display 
d751 cd 92 8a			call update_display 
d754			 
d754			 
d754 3a 28 e7			ld a, (os_last_cmd) 
d757 fe 00			cp 0 
d759 28 05			jr z, .startprompt 
d75b cd e0 89			call delay250ms 
d75e 18 24			jr .startdo 
d760				 
d760				 
d760			 
d760			.startprompt: 
d760			 
d760 3e 9f			ld a,display_row_4 + display_cols - 1 
d762 11 84 9a		        ld de, endprg 
d765 cd 82 8a			call str_at_display 
d768 cd 92 8a			call update_display 
d76b cd ec 89			call delay1s 
d76e cd 91 da			call cin_wait 
d771						 
d771 fe 2a			cp '*' 
d773 28 5e			jr z, .startupend1 
d775 fe 23			cp '#' 
d777 20 07			jr nz, .startno 
d779 3e 01			ld a, 1 
d77b 32 28 e7			ld (os_last_cmd),a 
d77e 18 04			jr .startdo 
d780 fe 31		.startno:	cp '1' 
d782 28 3a			jr z,.startnxt  
d784			 
d784				; exec startup line 
d784			.startdo:	 
d784 e1				pop hl 
d785 e5				push hl 
d786				 
d786 5e				ld e,(hl) 
d787 23				inc hl 
d788 56				ld d,(hl) 
d789 eb				ex de,hl 
d78a			 
d78a e5				push hl 
d78b			 
d78b 3e 00			ld a, 0 
d78d				;ld a, FORTH_END_BUFFER 
d78d cd 05 91			call strlent 
d790 23				inc hl   ; include zero term to copy 
d791 06 00			ld b,0 
d793 4d				ld c,l 
d794 e1				pop hl 
d795 11 02 e3			ld de, scratch 
d798 ed b0			ldir 
d79a			 
d79a			 
d79a 21 02 e3			ld hl, scratch 
d79d cd ca 9e			call forthparse 
d7a0 cd 0a 9f			call forthexec 
d7a3 cd 1c 9e			call forthexec_cleanup 
d7a6			 
d7a6 3e 78			ld a, display_row_4 
d7a8 11 28 98			ld de, endprog 
d7ab			 
d7ab cd 92 8a			call update_display		 
d7ae			 
d7ae 3a 28 e7			ld a, (os_last_cmd) 
d7b1 fe 00			cp 0 
d7b3 20 09			jr nz, .startnxt 
d7b5 cd 86 9a			call next_page_prompt 
d7b8 cd 6f 8a		        call clear_display 
d7bb cd 92 8a			call update_display		 
d7be			 
d7be				; move onto next startup line? 
d7be			.startnxt: 
d7be			 
d7be cd e0 89			call delay250ms 
d7c1 e1				pop hl 
d7c2			 
d7c2 23				inc hl 
d7c3 23				inc hl 
d7c4			 
d7c4 e5				push hl 
d7c5 5e				ld e, (hl) 
d7c6 23				inc hl 
d7c7 56				ld d, (hl) 
d7c8 e1				pop hl 
d7c9				; TODO replace 0 test 
d7c9			 
d7c9 eb				ex de, hl 
d7ca cd c5 8c			call ishlzero 
d7cd			;	ld a,e 
d7cd			;	add d 
d7cd			;	cp 0    ; any left to do? 
d7cd eb				ex de, hl 
d7ce c2 33 d7			jp nz, .start1 
d7d1 18 01			jr .startupend 
d7d3			 
d7d3 e1			.startupend1: pop hl 
d7d4			.startupend: 
d7d4			 
d7d4 cd 6f 8a			call clear_display 
d7d7 cd 92 8a			call update_display 
d7da c9				ret 
d7db			 
d7db			 
d7db			; stack over and underflow checks 
d7db			 
d7db			; init the words to detect the under/overflow 
d7db			 
d7db			chk_stk_init: 
d7db				; a vague random number to check so we dont get any "lucky" hits 
d7db 3e 2d			ld a, 45 
d7dd 6f				ld l, a 
d7de 00				nop 
d7df 3e 17			ld a, 23 
d7e1 67				ld h, a 
d7e2			 
d7e2 22 e9 e2			ld (chk_word), hl     ; the word we need to check against 
d7e5			 
d7e5			;	ld (chk_stund), hl	; stack points.... 
d7e5 22 00 ef			ld (chk_stovr), hl 
d7e8 22 2d ea			ld (chk_ret_und), hl 
d7eb 22 eb e9			ld (chk_ret_ovr), hl 
d7ee 22 69 e9			ld (chk_loop_ovr), hl 
d7f1 22 67 e8			ld (chk_data_ovr), hl 
d7f4 c9				ret 
d7f5				 
d7f5			check_stacks: 
d7f5				; check all stack words 
d7f5			 
d7f5 e5				push hl 
d7f6 d5				push de 
d7f7			 
d7f7			;	ld de,(chk_word) 
d7f7			;	ld hl, (chk_stund)	; stack points.... 
d7f7			;	if DEBUG_STK_FAULT 
d7f7			;		DMARK "FAa" 
d7f7			;		CALLMONITOR 
d7f7			;	endif 
d7f7			;	call cmp16 
d7f7			;	jp z, .chk_faulta 
d7f7			; 
d7f7			;	ld de, sfaultsu 
d7f7			;	jp .chk_fault 
d7f7			 
d7f7 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d7fa ed 5b e9 e2		ld de,(chk_word) 
d7fe				if DEBUG_STK_FAULT 
d7fe					DMARK "FAb" 
d7fe					CALLMONITOR 
d7fe				endif 
d7fe cd ba 8c			call cmp16 
d801 28 06			jr z, .chk_fault1 
d803 11 a4 d8			ld de, sfaultso 
d806 c3 58 d8			jp .chk_fault 
d809			.chk_fault1:  
d809 2a 2d ea			ld hl, (chk_ret_und) 
d80c ed 5b e9 e2		ld de,(chk_word) 
d810				if DEBUG_STK_FAULT 
d810					DMARK "FAU" 
d810					CALLMONITOR 
d810				endif 
d810 cd ba 8c			call cmp16 
d813 ca 1c d8			jp z, .chk_fault2 
d816 11 b4 d8			ld de, sfaultru 
d819 c3 58 d8			jp .chk_fault 
d81c			.chk_fault2:  
d81c 2a eb e9			ld hl, (chk_ret_ovr) 
d81f ed 5b e9 e2		ld de,(chk_word) 
d823				if DEBUG_STK_FAULT 
d823					DMARK "FA1" 
d823					CALLMONITOR 
d823				endif 
d823 cd ba 8c			call cmp16 
d826 ca 2f d8			jp z, .chk_fault3 
d829 11 c2 d8			ld de, sfaultro 
d82c c3 58 d8			jp .chk_fault 
d82f			.chk_fault3:  
d82f 2a 69 e9			ld hl, (chk_loop_ovr) 
d832 ed 5b e9 e2		ld de,(chk_word) 
d836				if DEBUG_STK_FAULT 
d836					DMARK "FA2" 
d836					CALLMONITOR 
d836				endif 
d836 cd ba 8c			call cmp16 
d839 ca 42 d8			jp z, .chk_fault4 
d83c 11 dc d8			ld de, sfaultlo 
d83f c3 58 d8			jp .chk_fault 
d842			.chk_fault4:  
d842 2a 67 e8			ld hl, (chk_data_ovr) 
d845 ed 5b e9 e2		ld de,(chk_word) 
d849				if DEBUG_STK_FAULT 
d849					DMARK "FA3" 
d849					CALLMONITOR 
d849				endif 
d849 cd ba 8c			call cmp16 
d84c ca 55 d8			jp z, .chk_fault5 
d84f 11 f6 d8			ld de, sfaultdo 
d852 c3 58 d8			jp .chk_fault 
d855			 
d855			 
d855			.chk_fault5:  
d855 d1				pop de 
d856 e1				pop hl 
d857			 
d857 c9				ret 
d858			 
d858 cd 6f 8a		.chk_fault: 	call clear_display 
d85b 3e 28				ld a, display_row_2 
d85d cd 82 8a				call str_at_display 
d860 11 86 d8				   ld de, .stackfault 
d863 3e 00				ld a, display_row_1 
d865 cd 82 8a				call str_at_display 
d868 11 71 ee				    ld de, debug_mark 
d86b 3e 11				ld a, display_row_1+17 
d86d cd 82 8a				call str_at_display 
d870 cd 92 8a				call update_display 
d873			 
d873				; prompt before entering montior for investigating issue 
d873			 
d873 3e 78			ld a, display_row_4 
d875 11 28 98			ld de, endprog 
d878			 
d878 cd 92 8a			call update_display		 
d87b			 
d87b cd 86 9a			call next_page_prompt 
d87e			 
d87e d1				pop de 
d87f e1				pop hl 
d880 cd 7c 98				call monitor 
d883 c3 76 97				jp warmstart 
d886					;jp 0 
d886					;halt 
d886			 
d886			 
d886			 
d886 .. 00		.stackfault: 	db "Stack fault:",0 
d893			 
d893 .. 00		sfaultsu: 	db	"Stack under flow",0 
d8a4 .. 00		sfaultso: 	db	"Stack over flow",0 
d8b4 .. 00		sfaultru:	db "RTS underflow",0 
d8c2 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
d8dc .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
d8f6 .. 00		sfaultdo:	db "DTS overflow", 0 
d903			 
d903			 
d903			fault_dsp_under: 
d903 11 15 d9			ld de, .dsp_under 
d906 c3 c5 d9			jp .show_fault 
d909			 
d909			fault_rsp_under: 
d909 11 23 d9			ld de, .rsp_under 
d90c c3 c5 d9			jp .show_fault 
d90f			fault_loop_under: 
d90f 11 31 d9			ld de, .loop_under 
d912 c3 c5 d9			jp .show_fault 
d915			 
d915 .. 00		.dsp_under: db "DSP Underflow",0 
d923 .. 00		.rsp_under: db "RSP Underflow",0 
d931 .. 00		.loop_under: db "LOOP Underflow",0 
d940			 
d940			 
d940 d5			type_faultn: 	push de 
d941 e5					push hl 
d942 cd 6f 8a				call clear_display 
d945 11 6c d9				   ld de, .typefaultn 
d948 3e 00				ld a, display_row_1 
d94a cd 82 8a				call str_at_display 
d94d 11 71 ee				    ld de, debug_mark 
d950 3e 11				ld a, display_row_1+17 
d952 cd 82 8a				call str_at_display 
d955 cd 92 8a				call update_display 
d958			 
d958				; prompt before entering montior for investigating issue 
d958			 
d958 3e 78			ld a, display_row_4 
d95a 11 28 98			ld de, endprog 
d95d			 
d95d cd 92 8a			call update_display		 
d960			 
d960 cd 86 9a			call next_page_prompt 
d963			 
d963 e5					push hl 
d964 d5					push de 
d965 cd 7c 98				call monitor 
d968 c3 76 97				jp warmstart 
d96b 76					halt 
d96c			 
d96c			 
d96c .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
d983			 
d983 d5			type_faults: 	push de 
d984 e5					push hl 
d985 cd 6f 8a				call clear_display 
d988 11 ae d9				   ld de, .typefaults 
d98b 3e 00				ld a, display_row_1 
d98d cd 82 8a				call str_at_display 
d990 11 71 ee				    ld de, debug_mark 
d993 3e 11				ld a, display_row_1+17 
d995 cd 82 8a				call str_at_display 
d998 cd 92 8a				call update_display 
d99b			 
d99b				; prompt before entering montior for investigating issue 
d99b			 
d99b 3e 78			ld a, display_row_4 
d99d 11 28 98			ld de, endprog 
d9a0			 
d9a0 cd 92 8a			call update_display		 
d9a3			 
d9a3 cd 86 9a			call next_page_prompt 
d9a6			 
d9a6 e1					pop hl 
d9a7 d1					pop de 
d9a8 cd 7c 98				call monitor 
d9ab c3 76 97				jp warmstart 
d9ae			 
d9ae			 
d9ae .. 00		.typefaults: db "STR Type Expected TOS!",0 
d9c5			 
d9c5			.show_fault: 	 
d9c5 d5					push de 
d9c6 cd 6f 8a				call clear_display 
d9c9 d1					pop de 
d9ca 3e 00				ld a, display_row_1 
d9cc cd 82 8a				call str_at_display 
d9cf 11 71 ee				    ld de, debug_mark 
d9d2 3e 11				ld a, display_row_1+17 
d9d4 cd 82 8a				call str_at_display 
d9d7 cd 92 8a				call update_display 
d9da			 
d9da				; prompt before entering montior for investigating issue 
d9da			 
d9da 3e 78			ld a, display_row_4 
d9dc 11 28 98			ld de, endprog 
d9df			 
d9df cd 92 8a			call update_display		 
d9e2			 
d9e2 cd 86 9a			call next_page_prompt 
d9e5			 
d9e5 e1					pop hl 
d9e6 d1					pop de 
d9e7 cd 7c 98				call monitor 
d9ea			; do a dump to cli and not warmstart so we preserve all of the uwords.  
d9ea			; TODO Make optional fault restart to cli or warm boot? 
d9ea					;jp warmstart 
d9ea c3 ce 97				jp cli 
d9ed 76					halt 
d9ee			 
d9ee			; handle the auto run of code from files in storage 
d9ee			 
d9ee			 
d9ee			if STORAGE_SE 
d9ee			 
d9ee			sprompt3: db "Loading from start-up file?:",0 
d9ee			sprompt4: db "(Y=Any key/N=No)",0 
d9ee			 
d9ee			 
d9ee			forth_autoload: 
d9ee			 
d9ee				; load block 0 of store 1 
d9ee				 
d9ee				ld a, $fe      ; bit 0 clear 
d9ee				ld (spi_device), a 
d9ee			 
d9ee				call storage_get_block_0 
d9ee			 
d9ee				ld a, (store_page+STORE_0_AUTOFILE) 
d9ee			 
d9ee				cp 0 
d9ee				ret z     ; auto start not enabled 
d9ee			 
d9ee				call clear_display 
d9ee			 
d9ee				; set bank 
d9ee			 
d9ee					ld a, (store_page+STORE_0_BANKRUN) 
d9ee					ld (spi_device), a 
d9ee			 
d9ee				; get file id to load from and get the file name to display 
d9ee			 
d9ee					ld a, (store_page+STORE_0_FILERUN) 
d9ee			 
d9ee					ld l, 0 
d9ee					ld h, a 
d9ee					ld de, store_page 
d9ee			 
d9ee					if DEBUG_FORTH_WORDS 
d9ee						DMARK "ASp" 
d9ee						CALLMONITOR 
d9ee					endif 
d9ee					call storage_read 
d9ee			 
d9ee					if DEBUG_FORTH_WORDS 
d9ee						DMARK "ASr" 
d9ee						CALLMONITOR 
d9ee					endif 
d9ee			 
d9ee					call ishlzero 
d9ee					ret z             ; file not found 
d9ee			 
d9ee					ld a, display_row_2 + 10 
d9ee					ld de, store_page+3 
d9ee					call str_at_display 
d9ee				 
d9ee			; 
d9ee			 
d9ee				ld a, display_row_1+5 
d9ee				ld de, sprompt3 
d9ee				call str_at_display 
d9ee				ld a, display_row_3+15 
d9ee				ld de, sprompt4 
d9ee				call str_at_display 
d9ee			 
d9ee				call update_display 
d9ee			 
d9ee				call cin_wait 
d9ee				cp 'n' 
d9ee				ret z 
d9ee				cp 'N' 
d9ee				ret z 
d9ee			 
d9ee				call delay1s 
d9ee			 
d9ee				ld a, (store_page+2) 
d9ee				ld (store_openmaxext), a    ; save count of ext 
d9ee				ld a, 1  
d9ee				ld (store_openext), a    ; save count of ext 
d9ee			 
d9ee			.autof:  
d9ee				ld l , a 
d9ee				 
d9ee				ld a, (store_page) 
d9ee				ld h, a	 
d9ee				ld de, store_page 
d9ee					if DEBUG_FORTH_WORDS 
d9ee						DMARK "ASl" 
d9ee						CALLMONITOR 
d9ee					endif 
d9ee					call storage_read 
d9ee				call ishlzero 
d9ee				ret z 
d9ee			;	jr z, .autoend 
d9ee			 
d9ee					if DEBUG_FORTH_WORDS 
d9ee						DMARK "ASc" 
d9ee						CALLMONITOR 
d9ee					endif 
d9ee				ld de, store_page+2 
d9ee				ld a, display_row_4 
d9ee				call str_at_display 
d9ee			 
d9ee				call update_display 
d9ee				call delay250ms 
d9ee			 
d9ee			 
d9ee			 
d9ee				ld hl, store_page+2 
d9ee				call forthparse 
d9ee				call forthexec 
d9ee				call forthexec_cleanup 
d9ee			 
d9ee				 
d9ee				ld a, (store_openext) 
d9ee				inc a 
d9ee				ld (store_openext), a    ; save count of ext 
d9ee			 
d9ee				jr .autof 
d9ee			;.autofdone: 
d9ee			; 
d9ee			;		if DEBUG_FORTH_WORDS 
d9ee			;			DMARK "ASx" 
d9ee			;			CALLMONITOR 
d9ee			;		endif 
d9ee			;;	call clear_display 
d9ee			;	ret 
d9ee			 
d9ee			 
d9ee			 
d9ee			endif 
d9ee			 
d9ee			 
d9ee			; eof 
# End of file forth_kernel.asm
d9ee			;include "nascombasic.asm" 
d9ee			 
d9ee			 
d9ee			; find out where the code ends if loaded into RAM (for SC114) 
d9ee			;endofcode:  
d9ee			;	nop 
d9ee			 
d9ee			 
d9ee			; eof 
d9ee			 
# End of file main.asm
d9ee			;include "firmware_lcd_4x40.asm" 
d9ee			;;include "firmware_lcd_4x20.asm" 
d9ee			include "firmware_serial_display.asm" 
d9ee			 
d9ee			; Serial display interface for SC114 
d9ee			 
d9ee			 
d9ee			display_row_1: equ 0 
d9ee			display_row_2: equ display_row_1+display_cols 
d9ee			display_row_3: equ display_row_2 + display_cols 
d9ee			display_row_4: equ display_row_3 + display_cols 
d9ee			 
d9ee			kLCDWidth:  EQU display_cols             ;Width in characters 
d9ee			kLCD_Line1: EQU 0x00  
d9ee			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
d9ee			; E1 
d9ee			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
d9ee			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
d9ee			 
d9ee			lcd_init: 
d9ee				; no init as handled by the SCM bios 
d9ee c9				ret 
d9ef			 
d9ef			 
d9ef			; low level functions for direct screen writes 
d9ef			 
d9ef			; output char at pos? 
d9ef			fLCD_Str: 
d9ef			        ;out (SC114_SIO_1_OUT),a 
d9ef c5				push bc 
d9f0 0e 02			ld c, $02 
d9f2 f7				rst $30 
d9f3 c1				pop bc 
d9f4 c9				ret 
d9f5			 
d9f5			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
d9f5			fLCD_Pos: 
d9f5				; use ASCII escape to position 
d9f5			        ;out (SC114_SIO_1_OUT),a 
d9f5 c5				push bc 
d9f6 0e 02			ld c, $02 
d9f8 f7				rst $30 
d9f9 c1				pop bc 
d9fa			 
d9fa c9				ret 
d9fb			 
d9fb			; output char at pos 
d9fb			fLCD_Data: 
d9fb			      ;  out (SC114_SIO_1_OUT),a 
d9fb c5				push bc 
d9fc 0e 02			ld c, $02 
d9fe f7				rst $30 
d9ff c1				pop bc 
da00			 
da00 c9				ret 
da01			 
da01			; ascii cls  
da01			 
da01 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
da05			 
da05			; write the frame buffer given in hl to hardware  
da05			write_display: 
da05			 
da05			API: equ 0 
da05			 
da05			if API 
da05				push bc 
da05				ld b, 4 
da05			 
da05			        ld (display_write_tmp), hl 	  
da05			 
da05				; clear and home cursor 
da05			 
da05				ld c, 6 
da05				ld de, .cls 
da05				rst $30 
da05			 
da05			 
da05			.writeln: 
da05			 
da05				ld de, (display_write_tmp) 
da05				ld c, 6 
da05				rst $30 
da05				ld c, 7 
da05				rst $30 
da05			 
da05				ld hl, (display_write_tmp) 
da05				ld de, display_cols 
da05				add hl,de 
da05				ld (display_write_tmp),hl 
da05			 
da05				djnz  .writeln 
da05			 
da05				pop bc 
da05			 
da05			 
da05				ret 
da05			endif 
da05 e5				push hl 
da06 c5				push bc 
da07 d5				push de 
da08			 
da08			;	ld c, 2 
da08			;	;ld de, .cls 
da08			;	ld a, 27 
da08			;	rst $30 
da08			;	ld c, 2 
da08			;	;ld de, .cls 
da08			;	ld a, '[' 
da08			;	rst $30 
da08			; 
da08			;	ld c, 2 
da08			;	;ld de, .cls 
da08			;	ld a, 'H' 
da08			;	rst $30 
da08			; 
da08			 
da08 0e 02			ld c, 2 
da0a				;ld de, .cls 
da0a 3e 1b			ld a, 27 
da0c f7				rst $30 
da0d			 
da0d			 
da0d 0e 02			ld c, 2 
da0f				;ld de, .cls 
da0f 3e 5b			ld a, '[' 
da11 f7				rst $30 
da12 0e 02			ld c, 2 
da14				;ld de, .cls 
da14 3e 32			ld a, '2' 
da16 f7				rst $30 
da17 0e 02			ld c, 2 
da19				;ld de, .cls 
da19 3e 4a			ld a, 'J' 
da1b f7				rst $30 
da1c d1				pop de 
da1d c1				pop bc 
da1e e1				pop hl 
da1f			 
da1f			 
da1f 22 cf eb		        ld (display_write_tmp), hl 	  
da22 3e 00			ld a, kLCD_Line1 
da24			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
da24 06 28			ld b, display_cols 
da26 ed 5b cf eb		ld de, (display_write_tmp) 
da2a cd 88 da			call write_len_string 
da2d				 
da2d			 
da2d e5			push hl 
da2e d5			push de 
da2f c5			push bc 
da30 0e 07			ld c, 7 
da32 f7				rst $30 
da33 c1			pop bc 
da34 d1			pop de 
da35 e1			pop hl 
da36			 
da36				 
da36 2a cf eb			ld hl, (display_write_tmp) 
da39 11 28 00			ld de, display_cols 
da3c 19				add hl,de 
da3d 22 cf eb			ld (display_write_tmp),hl 
da40			 
da40				 
da40 3e 28			ld a, kLCD_Line2 
da42			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
da42 06 28			ld b, display_cols 
da44 ed 5b cf eb		ld de, (display_write_tmp) 
da48 cd 88 da			call write_len_string 
da4b				 
da4b 2a cf eb			ld hl, (display_write_tmp) 
da4e 11 28 00			ld de, display_cols 
da51 19				add hl,de 
da52 22 cf eb			ld (display_write_tmp),hl 
da55			 
da55 e5			push hl 
da56 d5			push de 
da57 c5			push bc 
da58 0e 07			ld c, 7 
da5a f7				rst $30 
da5b c1			pop bc 
da5c d1			pop de 
da5d e1			pop hl 
da5e			 
da5e				 
da5e 3e 50			ld a, kLCD_Line3 
da60			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
da60 06 28			ld b, display_cols 
da62 ed 5b cf eb		ld de, (display_write_tmp) 
da66 cd 88 da			call write_len_string 
da69				 
da69 2a cf eb			ld hl, (display_write_tmp) 
da6c 11 28 00			ld de, display_cols 
da6f 19				add hl,de 
da70 22 cf eb			ld (display_write_tmp),hl 
da73			 
da73 e5			push hl 
da74 d5			push de 
da75 c5			push bc 
da76 0e 07			ld c, 7 
da78 f7				rst $30 
da79 c1			pop bc 
da7a d1			pop de 
da7b e1			pop hl 
da7c			 
da7c				 
da7c 3e 78			ld a, kLCD_Line4 
da7e			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
da7e 06 28			ld b, display_cols 
da80 ed 5b cf eb		ld de, (display_write_tmp) 
da84 cd 88 da			call write_len_string 
da87 c9					ret 
da88			 
da88			 
da88				; write out a fixed length string given in b from de 
da88			 
da88 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
da89 cd fb d9		            CALL fLCD_Data      ;Write character to display 
da8c 13				inc de 
da8d 10 f9			djnz write_len_string 
da8f c9				ret 
da90			 
da90			 
da90			; eof 
# End of file firmware_serial_display.asm
da90			;include "firmware_key_5x10.asm" 
da90			;;include "firmware_key_4x10.asm" 
da90			include "firmware_key_serial.asm" 
da90			; Serial keyboard interface for SC114 
da90			 
da90			key_init: 
da90				; no init as handled by the SCM bios 
da90 c9				ret 
da91			 
da91			 
da91			cin_wait: 
da91			;	ld a, 0 
da91			;	ret 
da91			 
da91				;in a,(SC114_SIO_1_IN) 
da91			        ; Use SCM API to get from whatever console device we are using 
da91 c5				push bc 
da92 0e 01			ld c, $01 
da94 f7				rst $30 
da95 c1				pop bc 
da96 c9				ret 
da97			 
da97			cin: 
da97			 
da97			 
da97 c5				push bc 
da98			 
da98				; any key waiting to process? 
da98 0e 03			ld c, $03 
da9a f7				rst $30 
da9b 28 05			jr z, .cin_skip 
da9d			 
da9d				; yep, get it 
da9d			 
da9d 0e 01			ld c, $01 
da9f f7				rst $30 
daa0 c1				pop bc 
daa1 c9				ret 
daa2			.cin_skip: 
daa2 3e 00			ld a, 0 
daa4 c1				pop bc 
daa5 c9				ret 
daa6			 
daa6			 
daa6			 
daa6			 
# End of file firmware_key_serial.asm
daa6			endofcode:  
daa6			baseram:  
daa6 00				nop 
daa7			 
daa7			heap_start: equ baseram+15  ; Starting address of heap 
daa7			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
daa7			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
daa7			;VDU:  EQU     endofcode           ; BASIC Work space 
daa7			; eof 
daa7			 
# End of file os_mega_sc114.asm
daa7
