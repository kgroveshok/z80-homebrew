# File os_mega_sc114.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 1 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
8000			endif 
8000			 
8000			if BASE_KEV = 1  
8000			 
8000				org 0h 
8000			endif 
8000			 
8000			if BASE_CPM = 1  
8000			 
8000				org 100h 
8000			endif 
8000 c3 42 95			jp coldstart     ; rst 0 - cold boot 
8003			 
8003			;        nop  
8003			;        nop 
8003			;;	org 05h		; null out bdos call 
8003			; 
8003			;        nop  
8003			;        nop  
8003			;        nop 
8003			;;	org 08h 
8003			;;; 
8003			;;	jp cin		; rst 8 - char in 
8003			;;; 
8003			; 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;        nop 
8003			;	org 010h 
8003			;; 
8003			;	jp cout		; rest 010h  - char out 
8003			;; 
8003			;	org 01bh   
8003			; 
8003			;	;jp  		; rst 01bh   - write string to display 
8003			;	jp str_at_display 
8003			; 
8003			; 
8003			;	org 020h 
8003			; 
8003			;	; jp		 ; rst 020h - read char at screen location 
8003			; 
8003			;	org 028h 
8003			 
8003				; jp		 ; rst 028h  - storage i/o 
8003			 
8003			; 	org 030h 
8003			;	jp break_point_state 
8003			  
8003			; $30  
8003			; org 038h 
8003			; $38 
8003			 
8003			; TODO any more important entry points to add to jump table for easier coding use? 
8003			 
8003			 
8003			include "firmware.asm" 
8003			  
8003			; main constants (used here and in firmware)  
8003			  
8003			; TODO have page 0 of storage as bios  
8003			  
8003			Device_A: equ 0h  
8003			Device_B: equ 040h          ; Sound  
8003			  
8003			if BASE_KEV  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_SC114  
8003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			; TODO fixup for CPM  
8003			Device_C: equ 080h          ; Storage and ext cart devices  
8003			endif  
8003			  
8003			Device_D: equ 0c0h             ; Keyboard and LCD  
8003			  
8003			; Odd specific debug points for testing hardware dev  
8003			  
8003			DEBUG_SOUND: equ 1  
8003			DEBUG_STK_FAULT: equ 0  
8003			DEBUG_INPUT: equ 0     ; Debug input entry code  
8003			DEBUG_KEYCINWAIT: equ 0  
8003			DEBUG_KEYCIN: equ 0  
8003			DEBUG_KEY: equ 0  
8003			DEBUG_KEY_MATRIX: equ 0  
8003			DEBUG_STORECF: equ 0  
8003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
8003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
8003			DEBUG_SPI: equ 0    ; low level spi tests  
8003			  
8003			; Enable many break points  
8003			  
8003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
8003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
8003			DEBUG_FORTH_JP: equ 0    ; 4  
8003			DEBUG_FORTH_MALLOC: equ 0  
8003			DEBUG_FORTH_MALLOC_INT: equ 0  
8003			DEBUG_FORTH_DOT: equ 0  
8003			DEBUG_FORTH_DOT_WAIT: equ 0  
8003			DEBUG_FORTH_MATHS: equ 0  
8003			DEBUG_FORTH_TOK: equ 0    ; 4  
8003			DEBUG_FORTH_PARSE: equ 0    ; 3  
8003			DEBUG_FORTH: equ 0  ;2  
8003			DEBUG_FORTH_WORDS: equ 1   ; 1  
8003			DEBUG_FORTH_PUSH: equ 1   ; 1  
8003			DEBUG_FORTH_UWORD: equ 1   ; 1  
8003			  
8003			; Enable key point breakpoints  
8003			  
8003			DEBUG_FORTH_DOT_KEY: equ 0  
8003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
8003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
8003			  
8003			; Debug stack imbalances  
8003			  
8003			ON: equ 1  
8003			OFF: equ 0  
8003			  
8003			DEBUG_STACK_IMB: equ 0  
8003			STACK_IMB_STORE: equ 20  
8003			  
8003			; House keeping and protections  
8003			  
8003			DEBUG_FORTH_STACK_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
8003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
8003			FORTH_ENABLE_FREE: equ 0  
8003			FORTH_ENABLE_MALLOCFREE: equ 1  
8003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
8003			FORTH_ENABLE_FLOATMATH: equ 0  
8003			  
8003			  
8003			CALLMONITOR: macro  
8003				call break_point_state  
8003				endm  
8003			  
8003			MALLOC_1: equ 1        ; from dk88   
8003			MALLOC_2: equ 0           ; broke  
8003			MALLOC_3: equ 0           ; really broke  
8003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
8003			  
8003			if BASE_KEV   
8003			stacksize: equ 512*2  
8003			  
8003			STACK_RET_SIZE: equ 128  
8003			STACK_LOOP_SIZE: equ 512  
8003			STACK_DATA_SIZE: equ 512  
8003			endif  
8003			if BASE_SC114  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			if BASE_CPM  
8003			;tos:	equ 0f000h  
8003			stacksize: equ 256  
8003			STACK_RET_SIZE: equ 64  
8003			STACK_LOOP_SIZE: equ 256  
8003			STACK_DATA_SIZE: equ 256  
8003			endif  
8003			  
8003			;if STORAGE_SE == 0  
8003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
8003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
8003			;endif  
8003			  
8003			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
8003			  
8003			STORE_0_AUTOFILE: equ $21  
8003			STORE_0_BANKRUN: equ $23  
8003			STORE_0_FILERUN: equ $24  
8003			  
8003			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
8003			  
8003			STORE_0_AUTORUN: equ $20  
8003			  
8003			; Blocks where directory table is held  
8003			  
8003			; Reducing the number of entries increases the max file size  
8003			  
8003			;STORE_DIR_START: equ 1  
8003			;STORE_DIR_END: equ 33  
8003			  
8003			; Blocks from where file data is stored  
8003			  
8003			;STORE_DATA_START: equ STORE_DIR_END + 1  
8003			  
8003			; Block indicators (<32 are data files)  
8003			  
8003			;STORE_BLOCK_CFG: equ $8f       ; config block  
8003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
8003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
8003			;STORE_BLOCK_FREE: equ $85       ; data block free  
8003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
8003			  
8003			  
8003			  
8003			; Directory entry flags  
8003			  
8003			;STORE_DIR_FREE: equ 0  
8003			;STORE_DIR_FILE:  equ 1  
8003			  
8003			; Structure offsets to directory entries  
8003			;STORE_DE_FLAG: equ 0  
8003			;STORE_DE_MAXEXT: equ 1  
8003			;STORE_DE_FILENAME: equ 2  
8003			  
8003			; Structure offsets to block 0  
8003			  
8003			;STORE_BK0_ISFOR: equ 1  
8003			;STORE_BK0_LABEL: equ 3  
8003			  
8003			; memory allocation   
8003			  
8003			chk_stund: equ tos+2           ; underflow check word  
8003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
8003			  
8003			; keyscan table needs rows x cols buffer  
8003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
8003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
8003			  
8003			keyscan_table_row1: equ chk_stovr -key_cols-1  
8003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
8003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
8003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
8003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
8003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
8003			keyscan_scancol: equ keyscan_table-key_cols  
8003			;keyscan_table_len: equ key_rows*key_cols  
8003			;keybufptr: equ keyscan_table - 2  
8003			;keysymbol: equ keybufptr - 1  
8003			key_held: equ keyscan_scancol-1	; currently held  
8003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
8003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
8003			key_fa: equ key_repeat_ct -1 ;  
8003			key_fb: equ key_fa -1 ;  
8003			key_fc: equ key_fb -1 ;  
8003			key_fd: equ key_fc -1 ;  
8003			key_face_held: equ key_fd - 1   
8003			  
8003			; flag for enabling/disabling various hardware diags   
8003			  
8003			hardware_diag: equ key_face_held - 1  
8003			  
8003			; hardware config switches  
8003			; TODO add bitmasks on includes for hardware  
8003			; high byte for expansion ids  
8003			;     0000 0000  no card inserted  
8003			;     0000 0001  storage card inserted  
8003			;     0000 0010  spi sd card active  
8003			  
8003			;       
8003			; low byte:  
8003			;     0000 0001   4x4 keypad  
8003			;     0000 0010   full keyboard  
8003			;     0000 0011   spi/ext keyboard  
8003			;     0000 0100   20x4 lcd  
8003			;     0000 1000   40x4 lcd  
8003			;     0000 1100   spi/ext display  
8003			;     0001 0000   ide interface available  
8003			  
8003			hardware_word: equ hardware_diag - 2  
8003			  
8003			; debug marker - optional display of debug point on the debug screens  
8003			  
8003			debug_mark: equ hardware_word - 4  
8003			  
8003			; input_str vars  
8003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
8003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
8003			input_size: equ input_start -1  ; number of chars  
8003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
8003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
8003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
8003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
8003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
8003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
8003			input_len: equ input_cur_onoff - 5 ; length of current input  
8003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
8003			  
8003			CUR_BLINK_RATE: equ 15  
8003			  
8003			key_actual_pressed: equ input_cursor - 1   
8003			key_symbol: equ key_actual_pressed - 1   
8003			key_shift: equ key_symbol - 1   
8003			  
8003			; Display allocation  
8003			  
8003			;display_rows: equ 4     ; move out to mini and mega files  
8003			;display_cols: equ 20  
8003			  
8003			display_fb_len: equ display_rows*display_cols  
8003			  
8003			; primary frame buffer     
8003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
8003			; working frame buffers  
8003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
8003			display_fb3: equ  display_fb1-display_fb_len - 1  
8003			display_fb2: equ  display_fb3-display_fb_len - 1  
8003			;  
8003			; pointer to active frame buffer  
8003			display_fb_active: equ display_fb2 - 2  
8003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
8003			display_write_tmp: equ display_lcde1e2 - 2  
8003			  
8003			  
8003			;  
8003			  
8003			;; can load into de directory  
8003			cursor_col: equ display_write_tmp-1  
8003			cursor_row: equ cursor_col-1  
8003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
8003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
8003			  
8003			; maths vars  
8003			  
8003			LFSRSeed: equ cursor_shape -20   
8003			randData: equ LFSRSeed - 2  
8003			xrandc: equ randData - 2  
8003			stackstore: equ xrandc - 2  
8003			seed1: equ  stackstore -2   
8003			seed2: equ seed1 - 2  
8003			  
8003			; cf storage vars  
8003			  
8003			iErrorNum:  equ seed2-1         ;Error number  
8003			iErrorReg:  equ iErrorNum -1              ;Error register  
8003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
8003			  
8003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
8003			  
8003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
8003			  
8003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
8003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
8003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
8003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
8003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
8003			store_tmpid: equ store_tmp3 - 1		; page temp id  
8003			store_tmpext: equ store_tmpid - 1		; file extent temp  
8003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
8003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
8003			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
8003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
8003			;  
8003			; spi vars  
8003			  
8003			  
8003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
8003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
8003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
8003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
8003			spi_device_id: equ spi_device - 1    ; human readable bank number  
8003			  
8003			;;;;; forth cli params  
8003			  
8003			; TODO use a different frame buffer for forth???  
8003			  
8003			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
8003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
8003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
8003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
8003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
8003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
8003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
8003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
8003			  
8003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
8003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
8003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
8003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
8003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
8003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
8003			  
8003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
8003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
8003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
8003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
8003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
8003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
8003			  
8003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
8003			  
8003			; os/forth token vars  
8003			  
8003			os_last_cmd: equ os_var_array-255  
8003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
8003			os_current_i: equ os_cli_cmd-2  
8003			os_cur_ptr: equ os_current_i-2  
8003			os_word_scratch: equ os_cur_ptr-30  
8003			os_tok_len: equ os_word_scratch - 2  
8003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
8003			os_tok_malloc: equ os_tok_ptr - 2  
8003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
8003			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
8003			execscratch: equ os_input-255        ; exec cmd eval buffer  
8003			scratch: equ execscratch-255  
8003			  
8003			  
8003			; temp locations for new word processing to save on adding more   
8003			  
8003			os_new_malloc: equ scratch-2  
8003			os_new_parse_len: equ os_new_malloc - 2  
8003			os_new_word_len: equ os_new_parse_len - 2  
8003			os_new_work_ptr: equ os_new_word_len - 2  
8003			os_new_src_ptr: equ os_new_work_ptr - 2  
8003			os_new_exec: equ os_new_src_ptr - 2  
8003			os_new_exec_ptr: equ os_new_exec - 2  
8003			  
8003			; resume memory alloocations....  
8003			  
8003			os_view_disable: equ os_new_exec_ptr - 1  
8003			os_view_af: equ os_view_disable - 2  
8003			os_view_hl: equ os_view_af -2  
8003			os_view_de: equ os_view_hl - 2  
8003			os_view_bc: equ os_view_de - 2  
8003			  
8003			; stack checksum word  
8003			if DEBUG_STACK_IMB  
8003				curframe: equ  os_view_de - 5  
8003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
8003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			else  
8003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
8003			endif  
8003			  
8003			; with data stack could see memory filled with junk. need some memory management   
8003			; malloc and free entry points added  
8003			  
8003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
8003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			;heap_end: equ free_list-1  ; Starting address of heap  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			  
8003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
8003			heap_end: equ chk_word-1  ; Starting address of heap  
8003			  
8003			  
8003			;if BASE_KEV   
8003			;heap_start: equ 0800eh  ; Starting address of heap  
8003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;heap_start: equ baseram+15  ; Starting address of heap  
8003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
8003			;endif  
8003			  
8003			  
8003			;;;;  
8003			  
8003			  
8003			; change below to point to last memory alloc above  
8003			topusermem:  equ   heap_start  
8003			  
8003			;if BASE_KEV   
8003			;baseusermem: equ 08000h  
8003			;endif  
8003			  
8003			;if BASE_SC114  
8003			;;aseusermem:     equ    12  
8003			;baseusermem:     equ    prompt  
8003			;;baseusermem:     equ    endofcode  
8003			;endif  
8003			  
8003			  
8003			; **********************************************************************  
8003			; **  Constants  
8003			; **********************************************************************  
8003			  
8003			; Constants used by this code module  
8003			kDataReg:   EQU Device_D           ;PIO port A data register  
8003			kContReg:   EQU Device_D+2           ;PIO port A control register  
8003			  
8003			  
8003			portbdata:  equ Device_D+1    ; port b data  
8003			portbctl:   equ Device_D+3    ; port b control  
8003			  
8003			  
8003			;KEY_SHIFT:   equ 5  
8003			;KEY_SYMBOLSHIFT:  equ 6  
8003			  
8003			KEY_SHIFTLOCK: equ 4  
8003			  
8003			  
8003			KEY_UP: equ 5  
8003			KEY_NEXTWORD: equ 6  
8003			KEY_PREVWORD: equ 7  
8003			KEY_BS: equ 8  
8003			KEY_TAB:  equ 9  
8003			KEY_DOWN: equ 10  
8003			KEY_LEFT: equ 11  
8003			KEY_RIGHT: equ 12  
8003			KEY_CR:   equ 13  
8003			KEY_HOME: equ 14  
8003			KEY_END: equ 15  
8003			  
8003			KEY_F1: equ 16  
8003			KEY_F2: equ 17  
8003			KEY_F3: equ 18  
8003			KEY_F4: equ 19  
8003			  
8003			KEY_F5: equ 20  
8003			KEY_F6: equ 21  
8003			KEY_F7: equ 22  
8003			KEY_F8: equ 23  
8003			  
8003			KEY_F9: equ 24  
8003			KEY_F10: equ 25  
8003			KEY_F11: equ 26  
8003			KEY_F12: equ 27  
8003			  
8003			;if DEBUG_KEY  
8003			;	KEY_MATRIX_NO_PRESS: equ '.'  
8003			;	KEY_SHIFT:   equ '.'  
8003			;	KEY_SYMBOLSHIFT:  equ '.'  
8003			;else  
8003				KEY_SHIFT:   equ '~'  
8003				KEY_SYMBOLSHIFT:  equ '~'  
8003				KEY_MATRIX_NO_PRESS: equ '~'  
8003			;endi  
8003			  
8003			  
8003			  
8003			  
8003			; Macro to make adding debug marks easier  
8003			  
8003			DMARK: macro str  
8003				push af  
8003				ld a, (.dmark)  
8003				ld (debug_mark),a  
8003				ld a, (.dmark+1)  
8003				ld (debug_mark+1),a  
8003				ld a, (.dmark+2)  
8003				ld (debug_mark+2),a  
8003				jr .pastdmark  
8003			.dmark: db str  
8003			.pastdmark: pop af  
8003			  
8003			endm  
8003			  
8003			  
8003			; macro to detect for stack imbalances  
8003			  
8003			include "stackimbal.asm"  
8003			; Macro and code to detect stock imbalances 
8003			 
8003			SPPUSH: equ 0 
8003			 
8003			; Add a stack frame which can be checked before return 
8003			 
8003			STACKFRAME: macro onoff frame1 frame2 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003						exx 
8003			 
8003						ld de, frame1 
8003						ld a, d 
8003						ld hl, curframe 
8003						call hexout 
8003						ld a, e 
8003						ld hl, curframe+2 
8003						call hexout 
8003			  
8003						ld hl, frame1 
8003						push hl 
8003						ld hl, frame2 
8003						push hl 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			endm 
8003			 
8003			STACKFRAMECHK: macro onoff frame1 frame2 
8003			 
8003					 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						exx 
8003						; check stack frame SP 
8003			 
8003						ld hl, frame2 
8003						pop de   ; frame2 
8003			 
8003						call cmp16 
8003						jr nz, .spnosame 
8003						 
8003			 
8003						ld hl, frame1 
8003						pop de   ; frame1 
8003			 
8003						call cmp16 
8003						jr z, .spfrsame 
8003			 
8003						.spnosame: call showsperror 
8003			 
8003						.spfrsame: nop 
8003			 
8003						exx 
8003					endif 
8003					 
8003				endif 
8003			 
8003			 
8003			endm 
8003			 
8003			 
8003			; for a sub routine, wrap SP collection and comparisons 
8003			 
8003			; Usage: 
8003			; 
8003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
8003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
8003			 
8003			SAVESP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003						; save current SP 
8003			 
8003						ld (store_sp+(storeword*4)), sp 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			CHECKSP: macro onoff storeword 
8003			 
8003				if DEBUG_STACK_IMB 
8003					if onoff 
8003			 
8003						; save SP after last save 
8003				 
8003						ld (store_sp+(storeword*4)+2), sp 
8003			 
8003						push hl 
8003						ld hl, store_sp+(storeword*4) 
8003						call check_stack_sp  
8003						pop hl 
8003			 
8003			 
8003					endif 
8003					 
8003				endif 
8003			 
8003			endm 
8003			 
8003			if DEBUG_STACK_IMB 
8003			 
8003			check_stack_sp: 
8003					push de 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					push de 
8003			 
8003			 
8003					ld e, (hl) 
8003					inc hl 
8003					ld d, (hl) 
8003					inc hl 
8003			 
8003					pop hl 
8003			 
8003			 
8003					; check to see if the same 
8003			 
8003					call cmp16 
8003					jr z, .spsame 
8003			 
8003					; not same 
8003			 
8003					call showsperror 
8003			.spsame: 
8003			 
8003					pop de 
8003			 
8003					ret 
8003			 
8003			.sperr:  db "Stack imbalance",0 
8003			 
8003			 
8003			showsperror: 
8003			 
8003			 
8003				push hl 
8003				push af 
8003				push de 
8003				call clear_display 
8003				ld de, .sperr 
8003				ld a,0 
8003			;	ld de,os_word_scratch 
8003				call str_at_display 
8003				ld a, display_row_1+17 
8003				ld de, debug_mark 
8003				call str_at_display 
8003				ld a, 0 
8003				ld (curframe+4),a 
8003				ld hl, curframe 
8003				ld de, os_word_scratch 
8003				ld a, display_row_4 
8003				call str_at_display 
8003				call update_display 
8003				;call break_point_state 
8003				call cin_wait 
8003			 
8003				ld a, ' ' 
8003				ld (os_view_disable), a 
8003				pop de	 
8003				pop af 
8003				pop hl 
8003				CALLMONITOR 
8003				ret 
8003			 
8003			endif 
8003			 
8003			 
8003			 
8003			; eof 
# End of file stackimbal.asm
8003			  
8003			;TODO macro to calc col and row offset into screen  
8003			  
8003			  
8003			  
8003			hardware_init:  
8003			  
8003 3e 00				ld a, 0  
8005 32 80 ee				ld (hardware_diag), a  
8008			  
8008					; clear all the buffers  
8008			  
8008 21 1f ed				ld hl, display_fb1  
800b 22 db eb				ld (display_fb_active), hl  
800e			  
800e cd 91 88				call clear_display  
8011			  
8011 21 dd eb				ld hl, display_fb2  
8014 22 db eb				ld (display_fb_active), hl  
8017			  
8017 cd 91 88				call clear_display  
801a			  
801a					; init primary frame buffer area  
801a 21 c0 ed				ld hl, display_fb0  
801d 22 db eb				ld (display_fb_active), hl  
8020			  
8020 cd 91 88				call clear_display  
8023			  
8023			  
8023 cd 27 d7				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
8026			  
8026 cd c9 d7			call key_init  
8029 cd b0 80			call storage_init  
802c			  
802c				; setup malloc functions  
802c			  
802c				if MALLOC_1  
802c cd 61 8f				call  heap_init  
802f				endif  
802f				if MALLOC_4  
802f					call  heap_init  
802f				endif  
802f			  
802f				; init sound hardware if present  
802f			  
802f				if SOUND_ENABLE  
802f					call sound_init  
802f				endif  
802f			  
802f				; lcd test sequence  
802f					  
802f cd b4 88			call update_display  
8032 cd 0e 88			call delay1s  
8035 3e 2b			ld a,'+'  
8037 cd 96 88			call fill_display  
803a cd b4 88			call update_display  
803d cd 0e 88			call delay1s  
8040 3e 2a			ld a,'*'  
8042 cd 96 88			call fill_display  
8045 cd b4 88			call update_display  
8048 cd 0e 88			call delay1s  
804b 3e 2d			ld a,'-'  
804d cd 96 88			call fill_display  
8050 cd b4 88			call update_display  
8053 cd 0e 88			call delay1s  
8056			  
8056			; boot splash screen  
8056			if display_cols == 20	  
8056			        ld a, display_row_1    
8056			else  
8056 3e 0a		        ld a, display_row_1 +10   
8058			endif  
8058 11 89 80			ld de, bootmsg  
805b cd a4 88			call str_at_display  
805e cd b4 88			call update_display  
8061			  
8061			  
8061 cd 0e 88			call delay1s  
8064 cd 0e 88			call delay1s  
8067			if display_cols == 20	  
8067			            LD   A, display_row_3+2  
8067			else  
8067 3e 5c		            LD   A, display_row_3+12  
8069			endif  
8069 11 9e 80			ld de, bootmsg1  
806c cd a4 88			call str_at_display  
806f cd b4 88			call update_display  
8072 cd 0e 88			call delay1s  
8075 cd 0e 88			call delay1s  
8078			  
8078			;	ld a, display_row_4+3  
8078			;	ld de, bootmsg2  
8078			;	call str_at_display  
8078			;	call update_display  
8078			;	call delay1s  
8078			;	call delay1s  
8078			  
8078			; debug mark setup  
8078			  
8078 3e 5f		ld a, '_'  
807a 32 7a ee		ld (debug_mark),a  
807d 32 7b ee		ld (debug_mark+1),a  
8080 32 7c ee		ld (debug_mark+2),a  
8083 3e 00		ld a,0  
8085 32 7d ee		ld (debug_mark+3),a  
8088			  
8088 c9					ret  
8089			  
8089			  
8089 .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
809e .. 00		bootmsg1:	db "by Kevin Groves",0  
80ae			;bootmsg2:	db "Firmware v0.1",0  
80ae			  
80ae			; a 4x20 lcd  
80ae			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
80ae			  
80ae			;if display_cols == 20  
80ae			;	include "firmware_lcd_4x20.asm"  
80ae			;endif  
80ae			  
80ae			;if display_cols == 40  
80ae			;	include "firmware_lcd_4x40.asm"  
80ae			;endif  
80ae			  
80ae			;  
80ae			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
80ae			; TODO abstract the bit bang video out interface for dual display  
80ae			; TODO wire video out to tx pin on rc2014 bus  
80ae			  
80ae			; must supply cin, and cin_wait for low level hardware abstraction   
80ae			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
80ae			; test scancode  
80ae			  
80ae			;;;;;  
80ae			;;;  
80ae			; Moved out to mini and maxi versions  
80ae			;  
80ae			; include "firmware_key_4x4.asm"  
80ae			; using existing 4 wire x 4 resistor array for input  
80ae			;include "firmware_key_4x10.asm"  
80ae			; need to mod the board for 5 rows due to resistor array  
80ae			;include "firmware_key_5x10.asm"  
80ae			  
80ae			; storage hardware interface  
80ae			  
80ae			; use microchip serial eeprom for storage  
80ae			  
80ae			  
80ae			if STORAGE_SE  
80ae				include "firmware_spi.asm"  
80ae				include "firmware_seeprom.asm"  
80ae			else  
80ae			   ; create some stubs for the labels  
80ae c9			se_readbyte: ret  
80af c9			se_writebyte: ret  
80b0 c9			storage_init: ret  
80b1			  
80b1			endif  
80b1			  
80b1			; use cf card for storage - throwing timeout errors. Hardware or software?????  
80b1			;include "firmware_cf.asm"  
80b1			  
80b1			; load up high level storage hardward abstractions  
80b1			include "firmware_storage.asm"  
80b1			 
80b1			; persisent storage hardware abstraction layer  
80b1			 
80b1			 
80b1			 
80b1			; Block 0 on storage is a config state 
80b1			 
80b1			 
80b1			 
80b1			; TODO add read phy block and write phy block functions 
80b1			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
80b1			 
80b1			; Abstraction layer  
80b1			 
80b1			; Logocial block size is same size as physical size - using tape concept 
80b1			 
80b1			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
80b1			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
80b1			 
80b1			 
80b1			 
80b1			; Filesystem layout (Logical layout) 
80b1			; 
80b1			; Block 0 - Bank config  
80b1			; 
80b1			;      Byte - 0 file id counter 
80b1			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
80b1			;      Byte - 3-20 zero terminated bank label 
80b1			; 
80b1			; Block 1 > File storage 
80b1			; 
80b1			;      Byte 0 file id    - block 0 file details 
80b1			;      Byte 1 block id - block 0 is file  
80b1			;            Byte 2-15 - File name 
80b1			; 
80b1			;       - to end of block data 
80b1			; 
80b1			 
80b1			 
80b1			; Read Block 
80b1			; ---------- 
80b1			; 
80b1			; With current bank 
80b1			;  
80b1			; Get block number to read 
80b1			; Load physical blocks starting at start block into buffer 
80b1			 
80b1			; de points to buffer to use 
80b1			; hl holds logical block number  
80b1			 
80b1			storage_read_block: 
80b1			 
80b1				; TODO bank selection 
80b1			 
80b1				; for each of the physical blocks read it into the buffer 
80b1 06 40			ld b, STORE_BLOCK_PHY 
80b3			 
80b3				if DEBUG_STORESE 
80b3 d5					push de 
80b4				endif 
80b4				 
80b4			.rl1:    
80b4			 
80b4				; read physical block at hl into de 
80b4			        ; increment hl and de to next read position on exit 
80b4			 
80b4 e5				push hl 
80b5 d5				push de	 
80b6 c5				push bc 
80b7			;	if DEBUG_STORESE 
80b7			;		push af 
80b7			;		ld a, 'R' 
80b7			;		ld (debug_mark),a 
80b7			;		pop af 
80b7			;		CALLMONITOR 
80b7			;	endif 
80b7 cd ae 80			call se_readbyte 
80ba			;	if DEBUG_STORESE 
80ba			;		ld a,(spi_portbyte) 
80ba			;		ld l, a 
80ba			;		push af 
80ba			;		ld a, '1' 
80ba			;		ld (debug_mark),a 
80ba			;		pop af 
80ba			;		CALLMONITOR 
80ba			;	endif 
80ba c1				pop bc 
80bb d1				pop de 
80bc e1				pop hl 
80bd 12				ld (de),a 
80be 23				inc hl 
80bf 13				inc de 
80c0			 
80c0			;	if DEBUG_STORESE 
80c0			;		push af 
80c0			;		ld a, 'r' 
80c0			;		ld (debug_mark),a 
80c0			;		pop af 
80c0			;		CALLMONITOR 
80c0			;	endif 
80c0			 
80c0 10 f2			djnz .rl1 
80c2			 
80c2				if DEBUG_STORESE 
80c2					DMARK "SRB" 
80c2 f5				push af  
80c3 3a d7 80			ld a, (.dmark)  
80c6 32 7a ee			ld (debug_mark),a  
80c9 3a d8 80			ld a, (.dmark+1)  
80cc 32 7b ee			ld (debug_mark+1),a  
80cf 3a d9 80			ld a, (.dmark+2)  
80d2 32 7c ee			ld (debug_mark+2),a  
80d5 18 03			jr .pastdmark  
80d7 ..			.dmark: db "SRB"  
80da f1			.pastdmark: pop af  
80db			endm  
# End of macro DMARK
80db d1					pop de 
80dc			; 
80dc			;		push af 
80dc			;		ld a, 'R' 
80dc			;		ld (debug_mark),a 
80dc			;		pop af 
80dc					CALLMONITOR 
80dc cd 6c 93			call break_point_state  
80df				endm  
# End of macro CALLMONITOR
80df				endif 
80df c9				ret	 
80e0				 
80e0			 
80e0			; File Size 
80e0			; --------- 
80e0			; 
80e0			;   hl file id 
80e0			; 
80e0			;  returns in hl the number of blocks 
80e0			 
80e0			storage_file_size: 
80e0 5d				ld e, l 
80e1 16 00			ld d, 0 
80e3 21 40 00			ld hl, STORE_BLOCK_PHY 
80e6					if DEBUG_FORTH_WORDS 
80e6						DMARK "SIZ" 
80e6 f5				push af  
80e7 3a fb 80			ld a, (.dmark)  
80ea 32 7a ee			ld (debug_mark),a  
80ed 3a fc 80			ld a, (.dmark+1)  
80f0 32 7b ee			ld (debug_mark+1),a  
80f3 3a fd 80			ld a, (.dmark+2)  
80f6 32 7c ee			ld (debug_mark+2),a  
80f9 18 03			jr .pastdmark  
80fb ..			.dmark: db "SIZ"  
80fe f1			.pastdmark: pop af  
80ff			endm  
# End of macro DMARK
80ff						CALLMONITOR 
80ff cd 6c 93			call break_point_state  
8102				endm  
# End of macro CALLMONITOR
8102					endif 
8102 cd d6 83			call storage_findnextid 
8105			 
8105 cd e7 8a			call ishlzero 
8108			;	ld a, l 
8108			;	add h 
8108			;	cp 0 
8108 c8				ret z			; block not found so EOF 
8109			 
8109 11 65 eb			ld de, store_page 
810c cd b1 80			call storage_read_block 
810f			 
810f 3a 67 eb			ld a, (store_page+2)	 ; get extent count 
8112 6f				ld l, a 
8113 26 00			ld h, 0 
8115 c9			 	ret 
8116			 
8116			 
8116			; Write Block 
8116			; ----------- 
8116			; 
8116			; With current bank 
8116			;  
8116			; Get block number to write 
8116			; Write physical blocks starting at start block from buffer 
8116			  
8116			storage_write_block: 
8116				; TODO bank selection 
8116			 
8116				; for each of the physical blocks read it into the buffer 
8116 06 40			ld b, STORE_BLOCK_PHY 
8118			 
8118				if DEBUG_STORESE 
8118					DMARK "SWB" 
8118 f5				push af  
8119 3a 2d 81			ld a, (.dmark)  
811c 32 7a ee			ld (debug_mark),a  
811f 3a 2e 81			ld a, (.dmark+1)  
8122 32 7b ee			ld (debug_mark+1),a  
8125 3a 2f 81			ld a, (.dmark+2)  
8128 32 7c ee			ld (debug_mark+2),a  
812b 18 03			jr .pastdmark  
812d ..			.dmark: db "SWB"  
8130 f1			.pastdmark: pop af  
8131			endm  
# End of macro DMARK
8131			 
8131					;push af 
8131					;ld a, 'W' 
8131					;ld (debug_mark),a 
8131					;pop af 
8131					CALLMONITOR 
8131 cd 6c 93			call break_point_state  
8134				endm  
# End of macro CALLMONITOR
8134				endif 
8134			 
8134			; might not be working 
8134			;	call se_writepage 
8134			 
8134			;	ret 
8134			; 
8134			 
8134			 
8134			 
8134			.wl1:    
8134			 
8134				; read physical block at hl into de 
8134			        ; increment hl and de to next read position on exit 
8134			 
8134 e5				push hl 
8135 d5				push de	 
8136 c5				push bc 
8137 1a				ld a,(de) 
8138				;if DEBUG_STORESE 
8138			;		push af 
8138			;		ld a, 'W' 
8138			;		ld (debug_mark),a 
8138			;		pop af 
8138			;		CALLMONITOR 
8138			;	endif 
8138 cd af 80			call se_writebyte 
813b			;	call delay250ms 
813b 00				nop 
813c 00				nop 
813d 00				nop 
813e			;	if DEBUG_STORESE 
813e			;		push af 
813e			;		ld a, 'w' 
813e			;		ld (debug_mark),a 
813e			;		pop af 
813e			;		CALLMONITOR 
813e			;	endif 
813e c1				pop bc 
813f d1				pop de 
8140 e1				pop hl 
8141 23				inc hl 
8142 13				inc de 
8143			 
8143			 
8143 10 ef			djnz .wl1 
8145			 
8145				if DEBUG_STORESE 
8145					DMARK "SW2" 
8145 f5				push af  
8146 3a 5a 81			ld a, (.dmark)  
8149 32 7a ee			ld (debug_mark),a  
814c 3a 5b 81			ld a, (.dmark+1)  
814f 32 7b ee			ld (debug_mark+1),a  
8152 3a 5c 81			ld a, (.dmark+2)  
8155 32 7c ee			ld (debug_mark+2),a  
8158 18 03			jr .pastdmark  
815a ..			.dmark: db "SW2"  
815d f1			.pastdmark: pop af  
815e			endm  
# End of macro DMARK
815e			 
815e					;push af 
815e					;ld a, 'W' 
815e					;ld (debug_mark),a 
815e					;pop af 
815e					CALLMONITOR 
815e cd 6c 93			call break_point_state  
8161				endm  
# End of macro CALLMONITOR
8161				endif 
8161 c9				ret	 
8162			 
8162			; Init bank 
8162			; --------- 
8162			; 
8162			; With current bank 
8162			; 
8162			; Setup block 0 config 
8162			;     Set 0 file id counter 
8162			;     Set formatted byte pattern 
8162			;     Zero out bank label 
8162			;      
8162			; For every logical block write 0-1 byte as null 
8162			 
8162			storage_get_block_0: 
8162			 
8162				; TODO check presence 
8162			 
8162				; get block 0 config 
8162			 
8162 21 00 00			ld hl, 0 
8165 11 65 eb			ld de, store_page 
8168 cd b1 80			call storage_read_block 
816b			 
816b				if DEBUG_STORESE 
816b					DMARK "SB0" 
816b f5				push af  
816c 3a 80 81			ld a, (.dmark)  
816f 32 7a ee			ld (debug_mark),a  
8172 3a 81 81			ld a, (.dmark+1)  
8175 32 7b ee			ld (debug_mark+1),a  
8178 3a 82 81			ld a, (.dmark+2)  
817b 32 7c ee			ld (debug_mark+2),a  
817e 18 03			jr .pastdmark  
8180 ..			.dmark: db "SB0"  
8183 f1			.pastdmark: pop af  
8184			endm  
# End of macro DMARK
8184 11 65 eb				ld de, store_page 
8187			;		push af 
8187			;		ld a, 'i' 
8187			;		ld (debug_mark),a 
8187			;		pop af 
8187					CALLMONITOR 
8187 cd 6c 93			call break_point_state  
818a				endm  
# End of macro CALLMONITOR
818a				endif 
818a			 
818a				; is this area formatted? 
818a			 
818a			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
818a 2a 66 eb			ld hl, (store_page+1) 
818d 3e 80			ld a,0x80 
818f bd				cp l 
8190 20 22			jr nz, .ininotformatted 
8192				; do a double check 
8192 3e 27			ld a, 0x27 
8194 bc				cp h 
8195 20 1d			jr nz, .ininotformatted 
8197			 
8197				; formatted then 
8197			 
8197				if DEBUG_STORESE 
8197					DMARK "SB1" 
8197 f5				push af  
8198 3a ac 81			ld a, (.dmark)  
819b 32 7a ee			ld (debug_mark),a  
819e 3a ad 81			ld a, (.dmark+1)  
81a1 32 7b ee			ld (debug_mark+1),a  
81a4 3a ae 81			ld a, (.dmark+2)  
81a7 32 7c ee			ld (debug_mark+2),a  
81aa 18 03			jr .pastdmark  
81ac ..			.dmark: db "SB1"  
81af f1			.pastdmark: pop af  
81b0			endm  
# End of macro DMARK
81b0					;push af 
81b0					;ld a, 'I' 
81b0					;ld (debug_mark),a 
81b0					;pop af 
81b0					CALLMONITOR 
81b0 cd 6c 93			call break_point_state  
81b3				endm  
# End of macro CALLMONITOR
81b3				endif 
81b3 c9				ret 
81b4			 
81b4			.ininotformatted: 
81b4				; bank not formatted so poke various bits to make sure 
81b4			 
81b4				if DEBUG_STORESE 
81b4					DMARK "SB2" 
81b4 f5				push af  
81b5 3a c9 81			ld a, (.dmark)  
81b8 32 7a ee			ld (debug_mark),a  
81bb 3a ca 81			ld a, (.dmark+1)  
81be 32 7b ee			ld (debug_mark+1),a  
81c1 3a cb 81			ld a, (.dmark+2)  
81c4 32 7c ee			ld (debug_mark+2),a  
81c7 18 03			jr .pastdmark  
81c9 ..			.dmark: db "SB2"  
81cc f1			.pastdmark: pop af  
81cd			endm  
# End of macro DMARK
81cd					;push af 
81cd					;ld a, 'f' 
81cd					;ld (debug_mark),a 
81cd					;pop af 
81cd					CALLMONITOR 
81cd cd 6c 93			call break_point_state  
81d0				endm  
# End of macro CALLMONITOR
81d0				endif 
81d0			 
81d0 cd d1 87			call storage_clear_page 
81d3			 
81d3 21 65 eb			ld hl, store_page 
81d6 3e 00			ld a, 0 
81d8				 
81d8 77				ld (hl),a   ; reset file counter 
81d9			 
81d9 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
81dc 22 66 eb		 	ld (store_page+1), hl	 
81df			 
81df				; set default label 
81df			 
81df 21 7b 82			ld hl, .defaultbanklabl 
81e2 11 68 eb		 	ld de, store_page+3 
81e5 01 0f 00			ld bc, 15 
81e8 ed b0			ldir 
81ea			 
81ea				; Append the current bank id 
81ea 21 71 eb			ld hl, store_page+3+9 
81ed 3a 4a eb			ld a, (spi_device_id) 
81f0 77				ld (hl), a 
81f1			 
81f1				; save default page 0 
81f1			 
81f1 21 00 00			ld hl, 0 
81f4 11 65 eb			ld de, store_page 
81f7				if DEBUG_STORESE 
81f7					DMARK "SB3" 
81f7 f5				push af  
81f8 3a 0c 82			ld a, (.dmark)  
81fb 32 7a ee			ld (debug_mark),a  
81fe 3a 0d 82			ld a, (.dmark+1)  
8201 32 7b ee			ld (debug_mark+1),a  
8204 3a 0e 82			ld a, (.dmark+2)  
8207 32 7c ee			ld (debug_mark+2),a  
820a 18 03			jr .pastdmark  
820c ..			.dmark: db "SB3"  
820f f1			.pastdmark: pop af  
8210			endm  
# End of macro DMARK
8210			;		push af 
8210			;		ld a, 'F' 
8210			;		ld (debug_mark),a 
8210			;		pop af 
8210					CALLMONITOR 
8210 cd 6c 93			call break_point_state  
8213				endm  
# End of macro CALLMONITOR
8213				endif 
8213 cd 16 81			call storage_write_block 
8216				if DEBUG_STORESE 
8216					DMARK "SB4" 
8216 f5				push af  
8217 3a 2b 82			ld a, (.dmark)  
821a 32 7a ee			ld (debug_mark),a  
821d 3a 2c 82			ld a, (.dmark+1)  
8220 32 7b ee			ld (debug_mark+1),a  
8223 3a 2d 82			ld a, (.dmark+2)  
8226 32 7c ee			ld (debug_mark+2),a  
8229 18 03			jr .pastdmark  
822b ..			.dmark: db "SB4"  
822e f1			.pastdmark: pop af  
822f			endm  
# End of macro DMARK
822f			;		push af 
822f			;		ld a, '>' 
822f			;		ld (debug_mark),a 
822f			;		pop af 
822f					CALLMONITOR 
822f cd 6c 93			call break_point_state  
8232				endm  
# End of macro CALLMONITOR
8232				endif 
8232			 
8232 00				nop 
8233 00				nop 
8234 00				nop 
8235			 
8235				; now set 0 in every page to mark as a free block 
8235			 
8235 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8237 21 40 00			ld hl, STORE_BLOCK_PHY 
823a			 
823a 3e 00		.setmark1:   	ld a,0 
823c e5					push hl 
823d c5					push bc 
823e cd af 80				call se_writebyte 
8241 3e 0a			ld a, 10 
8243 cd f3 87			call aDelayInMS 
8246 23				inc hl 
8247 cd af 80				call se_writebyte 
824a 3e 0a			ld a, 10 
824c cd f3 87			call aDelayInMS 
824f 2b				dec hl 
8250 c1					pop bc 
8251 e1					pop hl 
8252 3e 40				ld a, STORE_BLOCK_PHY 
8254 cd be 8a				call addatohl 
8257 10 e1				djnz .setmark1 
8259			 
8259 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
825b 3e 00		.setmark2:   	ld a,0 
825d e5					push hl 
825e c5					push bc 
825f cd af 80				call se_writebyte 
8262 3e 0a			ld a, 10 
8264 cd f3 87			call aDelayInMS 
8267 23				inc hl 
8268 cd af 80				call se_writebyte 
826b 3e 0a			ld a, 10 
826d cd f3 87			call aDelayInMS 
8270 2b				dec hl 
8271 c1					pop bc 
8272 e1					pop hl 
8273 3e 40				ld a, STORE_BLOCK_PHY 
8275 cd be 8a				call addatohl 
8278 10 e1				djnz .setmark2 
827a			 
827a					 
827a			 
827a			 
827a c9				ret 
827b			 
827b			 
827b			 
827b			 
827b .. 00		.defaultbanklabl:   db "BankLabel_",0 
8286			 
8286			 
8286			 
8286			; Label Bank 
8286			; ---------- 
8286			; 
8286			; With current bank 
8286			; Read block 0 
8286			; Set label 
8286			; Write block 0 
8286			 
8286			; label str pointer in hl 
8286			 
8286			storage_label:     
8286			 
8286				if DEBUG_STORESE 
8286					DMARK "LBL" 
8286 f5				push af  
8287 3a 9b 82			ld a, (.dmark)  
828a 32 7a ee			ld (debug_mark),a  
828d 3a 9c 82			ld a, (.dmark+1)  
8290 32 7b ee			ld (debug_mark+1),a  
8293 3a 9d 82			ld a, (.dmark+2)  
8296 32 7c ee			ld (debug_mark+2),a  
8299 18 03			jr .pastdmark  
829b ..			.dmark: db "LBL"  
829e f1			.pastdmark: pop af  
829f			endm  
# End of macro DMARK
829f					CALLMONITOR 
829f cd 6c 93			call break_point_state  
82a2				endm  
# End of macro CALLMONITOR
82a2				endif 
82a2			 
82a2 e5				push hl 
82a3			 
82a3 cd 62 81			call storage_get_block_0 
82a6			 
82a6				; set default label 
82a6			 
82a6 e1				pop hl 
82a7			 
82a7 11 68 eb		 	ld de, store_page+3 
82aa 01 0f 00			ld bc, 15 
82ad				if DEBUG_STORESE 
82ad					DMARK "LB3" 
82ad f5				push af  
82ae 3a c2 82			ld a, (.dmark)  
82b1 32 7a ee			ld (debug_mark),a  
82b4 3a c3 82			ld a, (.dmark+1)  
82b7 32 7b ee			ld (debug_mark+1),a  
82ba 3a c4 82			ld a, (.dmark+2)  
82bd 32 7c ee			ld (debug_mark+2),a  
82c0 18 03			jr .pastdmark  
82c2 ..			.dmark: db "LB3"  
82c5 f1			.pastdmark: pop af  
82c6			endm  
# End of macro DMARK
82c6					CALLMONITOR 
82c6 cd 6c 93			call break_point_state  
82c9				endm  
# End of macro CALLMONITOR
82c9				endif 
82c9 ed b0			ldir 
82cb				; save default page 0 
82cb			 
82cb 21 00 00			ld hl, 0 
82ce 11 65 eb			ld de, store_page 
82d1				if DEBUG_STORESE 
82d1					DMARK "LBW" 
82d1 f5				push af  
82d2 3a e6 82			ld a, (.dmark)  
82d5 32 7a ee			ld (debug_mark),a  
82d8 3a e7 82			ld a, (.dmark+1)  
82db 32 7b ee			ld (debug_mark+1),a  
82de 3a e8 82			ld a, (.dmark+2)  
82e1 32 7c ee			ld (debug_mark+2),a  
82e4 18 03			jr .pastdmark  
82e6 ..			.dmark: db "LBW"  
82e9 f1			.pastdmark: pop af  
82ea			endm  
# End of macro DMARK
82ea					CALLMONITOR 
82ea cd 6c 93			call break_point_state  
82ed				endm  
# End of macro CALLMONITOR
82ed				endif 
82ed cd 16 81			call storage_write_block 
82f0			 
82f0 c9				ret 
82f1			 
82f1			 
82f1			 
82f1			; Read Block 0 - Config 
82f1			; --------------------- 
82f1			; 
82f1			; With current bank 
82f1			; Call presence test 
82f1			;    If not present format/init bank  
82f1			; Read block 0  
82f1			;  
82f1			 
82f1			 
82f1			; Dir 
82f1			; --- 
82f1			; 
82f1			; With current bank 
82f1			; Load Block 0 Config 
82f1			; Get max file id number 
82f1			; For each logical block 
82f1			;    Read block read byte 2 
82f1			;      if first block of file 
82f1			;         Display file name 
82f1			;         Display type flags for file 
82f1			;        
82f1			 
82f1			; moving to words as this requires stack control 
82f1			 
82f1			 
82f1			; Delete File 
82f1			; ----------- 
82f1			; 
82f1			; With current bank 
82f1			; 
82f1			; Load Block 0 Config 
82f1			; Get max file id number 
82f1			; For each logical block 
82f1			;    Read block file id 
82f1			;      If first block of file and dont have file id 
82f1			;         if file to delete 
82f1			;         Save file id 
82f1			;         Null file id 
82f1			;         Write this block back 
82f1			;      If file id is one saved 
82f1			;         Null file id 
82f1			;         Write this block back 
82f1			 
82f1			storage_erase: 
82f1			 
82f1				; hl contains the file id 
82f1			 
82f1 5d				ld e, l 
82f2 16 00			ld d, 0 
82f4 21 40 00			ld hl, STORE_BLOCK_PHY 
82f7					if DEBUG_FORTH_WORDS 
82f7						DMARK "ERA" 
82f7 f5				push af  
82f8 3a 0c 83			ld a, (.dmark)  
82fb 32 7a ee			ld (debug_mark),a  
82fe 3a 0d 83			ld a, (.dmark+1)  
8301 32 7b ee			ld (debug_mark+1),a  
8304 3a 0e 83			ld a, (.dmark+2)  
8307 32 7c ee			ld (debug_mark+2),a  
830a 18 03			jr .pastdmark  
830c ..			.dmark: db "ERA"  
830f f1			.pastdmark: pop af  
8310			endm  
# End of macro DMARK
8310						CALLMONITOR 
8310 cd 6c 93			call break_point_state  
8313				endm  
# End of macro CALLMONITOR
8313					endif 
8313 cd d6 83			call storage_findnextid 
8316 cd e7 8a			call ishlzero 
8319 c8				ret z 
831a			 
831a e5				push hl 
831b			 
831b				; TODO check file not found 
831b			 
831b 11 65 eb			ld de, store_page 
831e cd b1 80			call storage_read_block 
8321			 
8321					if DEBUG_FORTH_WORDS 
8321						DMARK "ER1" 
8321 f5				push af  
8322 3a 36 83			ld a, (.dmark)  
8325 32 7a ee			ld (debug_mark),a  
8328 3a 37 83			ld a, (.dmark+1)  
832b 32 7b ee			ld (debug_mark+1),a  
832e 3a 38 83			ld a, (.dmark+2)  
8331 32 7c ee			ld (debug_mark+2),a  
8334 18 03			jr .pastdmark  
8336 ..			.dmark: db "ER1"  
8339 f1			.pastdmark: pop af  
833a			endm  
# End of macro DMARK
833a						CALLMONITOR 
833a cd 6c 93			call break_point_state  
833d				endm  
# End of macro CALLMONITOR
833d					endif 
833d 3a 65 eb			ld a, (store_page)	; get file id 
8340 32 5e eb			ld (store_tmpid), a 
8343			 
8343 3a 67 eb			ld a, (store_page+2)    ; get count of extends 
8346 32 5d eb			ld (store_tmpext), a 
8349			 
8349				; wipe file header 
8349			 
8349 e1				pop hl 
834a 3e 00			ld a, 0 
834c 32 65 eb			ld (store_page), a 
834f 32 66 eb			ld (store_page+1),a 
8352 11 65 eb			ld de, store_page 
8355					if DEBUG_FORTH_WORDS 
8355						DMARK "ER2" 
8355 f5				push af  
8356 3a 6a 83			ld a, (.dmark)  
8359 32 7a ee			ld (debug_mark),a  
835c 3a 6b 83			ld a, (.dmark+1)  
835f 32 7b ee			ld (debug_mark+1),a  
8362 3a 6c 83			ld a, (.dmark+2)  
8365 32 7c ee			ld (debug_mark+2),a  
8368 18 03			jr .pastdmark  
836a ..			.dmark: db "ER2"  
836d f1			.pastdmark: pop af  
836e			endm  
# End of macro DMARK
836e						CALLMONITOR 
836e cd 6c 93			call break_point_state  
8371				endm  
# End of macro CALLMONITOR
8371					endif 
8371 cd 16 81			call storage_write_block 
8374			 
8374			 
8374				; wipe file extents 
8374			 
8374 3a 5d eb			ld a, (store_tmpext) 
8377 47				ld b, a 
8378			 
8378			.eraext:	  
8378 c5				push bc 
8379			 
8379 21 40 00			ld hl, STORE_BLOCK_PHY 
837c 3a 5e eb			ld a,(store_tmpid) 
837f 5f				ld e, a 
8380 50				ld d, b	 
8381					if DEBUG_FORTH_WORDS 
8381						DMARK "ER3" 
8381 f5				push af  
8382 3a 96 83			ld a, (.dmark)  
8385 32 7a ee			ld (debug_mark),a  
8388 3a 97 83			ld a, (.dmark+1)  
838b 32 7b ee			ld (debug_mark+1),a  
838e 3a 98 83			ld a, (.dmark+2)  
8391 32 7c ee			ld (debug_mark+2),a  
8394 18 03			jr .pastdmark  
8396 ..			.dmark: db "ER3"  
8399 f1			.pastdmark: pop af  
839a			endm  
# End of macro DMARK
839a						CALLMONITOR 
839a cd 6c 93			call break_point_state  
839d				endm  
# End of macro CALLMONITOR
839d					endif 
839d cd d6 83			call storage_findnextid 
83a0			 
83a0 e5				push hl 
83a1 11 65 eb			ld de, store_page 
83a4 cd b1 80			call storage_read_block 
83a7			 
83a7				; free block	 
83a7			 
83a7 3e 00			ld a, 0 
83a9 32 65 eb			ld (store_page), a 
83ac 32 66 eb			ld (store_page+1),a 
83af 11 65 eb			ld de, store_page 
83b2 e1				pop hl 
83b3					if DEBUG_FORTH_WORDS 
83b3						DMARK "ER4" 
83b3 f5				push af  
83b4 3a c8 83			ld a, (.dmark)  
83b7 32 7a ee			ld (debug_mark),a  
83ba 3a c9 83			ld a, (.dmark+1)  
83bd 32 7b ee			ld (debug_mark+1),a  
83c0 3a ca 83			ld a, (.dmark+2)  
83c3 32 7c ee			ld (debug_mark+2),a  
83c6 18 03			jr .pastdmark  
83c8 ..			.dmark: db "ER4"  
83cb f1			.pastdmark: pop af  
83cc			endm  
# End of macro DMARK
83cc						CALLMONITOR 
83cc cd 6c 93			call break_point_state  
83cf				endm  
# End of macro CALLMONITOR
83cf					endif 
83cf cd 16 81			call storage_write_block 
83d2			 
83d2 c1				pop bc 
83d3 10 a3			djnz .eraext 
83d5			 
83d5 c9				ret 
83d6			 
83d6			 
83d6			; Find Free Block 
83d6			; --------------- 
83d6			; 
83d6			; With current bank 
83d6			;  
83d6			; From given starting logical block 
83d6			;    Read block  
83d6			;    If no file id 
83d6			;         Return block id 
83d6			 
83d6			 
83d6			; hl starting page number 
83d6			; hl contains free page number or zero if no pages free 
83d6			; e contains the file id to locate 
83d6			; d contains the block number 
83d6			 
83d6			; TODO change to find file id and use zero for free block 
83d6			 
83d6			storage_findnextid: 
83d6			 
83d6				; now locate first 0 page to mark as a free block 
83d6			 
83d6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
83d8			;	ld hl, STORE_BLOCK_PHY 
83d8			 
83d8					if DEBUG_FORTH_WORDS 
83d8					DMARK "FNI" 
83d8 f5				push af  
83d9 3a ed 83			ld a, (.dmark)  
83dc 32 7a ee			ld (debug_mark),a  
83df 3a ee 83			ld a, (.dmark+1)  
83e2 32 7b ee			ld (debug_mark+1),a  
83e5 3a ef 83			ld a, (.dmark+2)  
83e8 32 7c ee			ld (debug_mark+2),a  
83eb 18 03			jr .pastdmark  
83ed ..			.dmark: db "FNI"  
83f0 f1			.pastdmark: pop af  
83f1			endm  
# End of macro DMARK
83f1						CALLMONITOR 
83f1 cd 6c 93			call break_point_state  
83f4				endm  
# End of macro CALLMONITOR
83f4					endif 
83f4			.ff1:   	 
83f4 e5					push hl 
83f5 c5					push bc 
83f6 d5					push de 
83f7 cd ae 80				call se_readbyte 
83fa 5f					ld e,a 
83fb 23					inc hl 
83fc cd ae 80				call se_readbyte 
83ff 57					ld d, a 
8400 e1					pop hl 
8401 e5					push hl 
8402 cd dc 8a				call cmp16 
8405 28 49				jr z, .fffound 
8407			 
8407 d1					pop de 
8408 c1					pop bc 
8409 e1					pop hl 
840a			 
840a					; is found? 
840a					;cp e 
840a					;ret z 
840a			 
840a 3e 40				ld a, STORE_BLOCK_PHY 
840c cd be 8a				call addatohl 
840f 10 e3				djnz .ff1 
8411			 
8411 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8413			.ff2:   	 
8413			 
8413 e5					push hl 
8414 c5					push bc 
8415 d5					push de 
8416 cd ae 80				call se_readbyte 
8419 5f					ld e,a 
841a 23					inc hl 
841b cd ae 80				call se_readbyte 
841e 57					ld d, a 
841f			 
841f e1					pop hl 
8420 e5					push hl 
8421 cd dc 8a				call cmp16 
8424 28 2a				jr z, .fffound 
8426			 
8426 d1					pop de 
8427 c1					pop bc 
8428 e1					pop hl 
8429					; is found? 
8429					;cp e 
8429					;ret z 
8429			 
8429 3e 40				ld a, STORE_BLOCK_PHY 
842b cd be 8a				call addatohl 
842e 10 e3				djnz .ff2 
8430			 
8430			 
8430					if DEBUG_FORTH_WORDS 
8430					DMARK "FN-" 
8430 f5				push af  
8431 3a 45 84			ld a, (.dmark)  
8434 32 7a ee			ld (debug_mark),a  
8437 3a 46 84			ld a, (.dmark+1)  
843a 32 7b ee			ld (debug_mark+1),a  
843d 3a 47 84			ld a, (.dmark+2)  
8440 32 7c ee			ld (debug_mark+2),a  
8443 18 03			jr .pastdmark  
8445 ..			.dmark: db "FN-"  
8448 f1			.pastdmark: pop af  
8449			endm  
# End of macro DMARK
8449					;	push af 
8449					;	ld a, 'n' 
8449					;	ld (debug_mark),a 
8449					;	pop af 
8449						CALLMONITOR 
8449 cd 6c 93			call break_point_state  
844c				endm  
# End of macro CALLMONITOR
844c					endif 
844c				; no free marks! 
844c 21 00 00				ld hl, 0 
844f c9				ret 
8450			.fffound: 
8450				 
8450			 
8450 d1					pop de 
8451 c1					pop bc 
8452 e1					pop hl 
8453					if DEBUG_FORTH_WORDS 
8453					DMARK "FNF" 
8453 f5				push af  
8454 3a 68 84			ld a, (.dmark)  
8457 32 7a ee			ld (debug_mark),a  
845a 3a 69 84			ld a, (.dmark+1)  
845d 32 7b ee			ld (debug_mark+1),a  
8460 3a 6a 84			ld a, (.dmark+2)  
8463 32 7c ee			ld (debug_mark+2),a  
8466 18 03			jr .pastdmark  
8468 ..			.dmark: db "FNF"  
846b f1			.pastdmark: pop af  
846c			endm  
# End of macro DMARK
846c					;	push af 
846c					;	ld a, 'n' 
846c					;	ld (debug_mark),a 
846c					;	pop af 
846c						CALLMONITOR 
846c cd 6c 93			call break_point_state  
846f				endm  
# End of macro CALLMONITOR
846f					endif 
846f c9				ret 
8470			 
8470			 
8470			 
8470			; Free Space 
8470			; ---------- 
8470			; 
8470			; With current bank 
8470			; 
8470			; Set block count to zero 
8470			; Starting with first logical block 
8470			;      Find free block  
8470			;      If block id given, increment block count 
8470			; 
8470			;  
8470			 
8470			 
8470			; hl contains count of free blocks 
8470			 
8470			storage_freeblocks: 
8470			 
8470				; now locate first 0 page to mark as a free block 
8470			 
8470 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
8472 21 40 00			ld hl, STORE_BLOCK_PHY 
8475 11 00 00			ld de, 0 
8478			 
8478			.fb1:   	 
8478 e5					push hl 
8479 c5					push bc 
847a d5					push de 
847b cd ae 80				call se_readbyte 
847e d1					pop de 
847f c1					pop bc 
8480 e1					pop hl 
8481			 
8481					; is free? 
8481 fe 00				cp 0 
8483 20 01				jr nz, .ff1cont 
8485 13					inc de 
8486			 
8486			.ff1cont: 
8486			 
8486			 
8486 3e 40				ld a, STORE_BLOCK_PHY 
8488 cd be 8a				call addatohl 
848b 10 eb				djnz .fb1 
848d			 
848d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
848f			.fb2:   	 
848f e5					push hl 
8490 c5					push bc 
8491 d5					push de 
8492 cd ae 80				call se_readbyte 
8495 d1					pop de 
8496 c1					pop bc 
8497 e1					pop hl 
8498			 
8498					; is free? 
8498 fe 00				cp 0 
849a 20 01				jr nz, .ff2cont 
849c 13					inc de 
849d			 
849d			.ff2cont: 
849d			 
849d 3e 40				ld a, STORE_BLOCK_PHY 
849f cd be 8a				call addatohl 
84a2 10 eb				djnz .fb2 
84a4			 
84a4 eb				ex de, hl 
84a5 c9				ret 
84a6			 
84a6			; Get File ID 
84a6			; ----------- 
84a6			; 
84a6			; With current bank 
84a6			;  
84a6			; Load Block 0 Config 
84a6			; Get max file id number 
84a6			; For each logical block 
84a6			;    Read block file id 
84a6			;      If first block of file and dont have file id 
84a6			;         if file get id and exit 
84a6			 
84a6			 
84a6			 
84a6			 
84a6			; Create File 
84a6			; ----------- 
84a6			; 
84a6			; With current bank  
84a6			; Load Block 0 Config 
84a6			; Get max file id number 
84a6			; Increment file id number 
84a6			; Save Config 
84a6			; Find free block 
84a6			; Set buffer with file name and file id 
84a6			; Write buffer to free block  
84a6			 
84a6			 
84a6			; hl point to file name 
84a6			; hl returns file id 
84a6			 
84a6			; file format: 
84a6			; byte 0 - file id 
84a6			; byte 1 - extent number 
84a6			; byte 2-> data 
84a6			 
84a6			; format for extent number 0: 
84a6			; 
84a6			; byte 0 - file id 
84a6			; byte 1 - extent 0 
84a6			; byte 2 - extent count 
84a6			; byte 3 -> file name and meta data 
84a6			 
84a6			 
84a6			storage_create: 
84a6				if DEBUG_STORESE 
84a6					DMARK "SCR" 
84a6 f5				push af  
84a7 3a bb 84			ld a, (.dmark)  
84aa 32 7a ee			ld (debug_mark),a  
84ad 3a bc 84			ld a, (.dmark+1)  
84b0 32 7b ee			ld (debug_mark+1),a  
84b3 3a bd 84			ld a, (.dmark+2)  
84b6 32 7c ee			ld (debug_mark+2),a  
84b9 18 03			jr .pastdmark  
84bb ..			.dmark: db "SCR"  
84be f1			.pastdmark: pop af  
84bf			endm  
# End of macro DMARK
84bf					CALLMONITOR 
84bf cd 6c 93			call break_point_state  
84c2				endm  
# End of macro CALLMONITOR
84c2				endif 
84c2			 
84c2 e5				push hl		; save file name pointer 
84c3			 
84c3 cd 62 81			call storage_get_block_0 
84c6			 
84c6 3a 65 eb			ld a,(store_page)	; get current file id 
84c9 3c				inc a 
84ca 32 65 eb			ld (store_page),a 
84cd				 
84cd 32 5e eb			ld (store_tmpid),a			; save id 
84d0			 
84d0 21 00 00			ld hl, 0 
84d3 11 65 eb			ld de, store_page 
84d6				if DEBUG_STORESE 
84d6					DMARK "SCw" 
84d6 f5				push af  
84d7 3a eb 84			ld a, (.dmark)  
84da 32 7a ee			ld (debug_mark),a  
84dd 3a ec 84			ld a, (.dmark+1)  
84e0 32 7b ee			ld (debug_mark+1),a  
84e3 3a ed 84			ld a, (.dmark+2)  
84e6 32 7c ee			ld (debug_mark+2),a  
84e9 18 03			jr .pastdmark  
84eb ..			.dmark: db "SCw"  
84ee f1			.pastdmark: pop af  
84ef			endm  
# End of macro DMARK
84ef					CALLMONITOR 
84ef cd 6c 93			call break_point_state  
84f2				endm  
# End of macro CALLMONITOR
84f2				endif 
84f2 cd 16 81			call storage_write_block	 ; save update 
84f5			 
84f5				if DEBUG_STORESE 
84f5 11 65 eb				ld de, store_page 
84f8					DMARK "SCC" 
84f8 f5				push af  
84f9 3a 0d 85			ld a, (.dmark)  
84fc 32 7a ee			ld (debug_mark),a  
84ff 3a 0e 85			ld a, (.dmark+1)  
8502 32 7b ee			ld (debug_mark+1),a  
8505 3a 0f 85			ld a, (.dmark+2)  
8508 32 7c ee			ld (debug_mark+2),a  
850b 18 03			jr .pastdmark  
850d ..			.dmark: db "SCC"  
8510 f1			.pastdmark: pop af  
8511			endm  
# End of macro DMARK
8511					CALLMONITOR 
8511 cd 6c 93			call break_point_state  
8514				endm  
# End of macro CALLMONITOR
8514				endif 
8514				;  
8514				 
8514 21 40 00			ld hl, STORE_BLOCK_PHY 
8517 11 00 00			ld de, 0 
851a cd d6 83			call storage_findnextid 
851d			 
851d 22 4f eb			ld (store_tmppageid), hl    ; save page to use  
8520			 
8520				; TODO detect 0 = no spare blocks 
8520			 
8520				; hl now contains the free page to use for the file header page 
8520			 
8520				if DEBUG_STORESE 
8520				DMARK "SCF" 
8520 f5				push af  
8521 3a 35 85			ld a, (.dmark)  
8524 32 7a ee			ld (debug_mark),a  
8527 3a 36 85			ld a, (.dmark+1)  
852a 32 7b ee			ld (debug_mark+1),a  
852d 3a 37 85			ld a, (.dmark+2)  
8530 32 7c ee			ld (debug_mark+2),a  
8533 18 03			jr .pastdmark  
8535 ..			.dmark: db "SCF"  
8538 f1			.pastdmark: pop af  
8539			endm  
# End of macro DMARK
8539					CALLMONITOR 
8539 cd 6c 93			call break_point_state  
853c				endm  
# End of macro CALLMONITOR
853c				endif 
853c			 
853c 22 4f eb			ld (store_tmppageid), hl 
853f				 
853f 3a 5e eb			ld a,(store_tmpid)    ; get file id 
8542			;	ld a, (store_filecache)			; save to cache 
8542			 
8542 32 65 eb			ld (store_page),a    ; set page id 
8545 3e 00			ld a, 0			 ; extent 0 is file header 
8547 32 66 eb			ld (store_page+1), a   ; set file extent 
854a			 
854a 32 67 eb			ld (store_page+2), a   ; extent count for the file 
854d			 
854d			;	inc hl 		; init block 0 of file 
854d			;	inc hl   		; skip file and extent id 
854d			 ;       ld a, 0 
854d			;	ld (hl),a 
854d			;	ld a, (store_filecache+1)  	; save to cache 
854d			 
854d			;	inc hl    ; file name 
854d				 
854d				 
854d 11 68 eb			ld de, store_page+3    ; get buffer for term string to use as file name 
8550				if DEBUG_STORESE 
8550					DMARK "SCc" 
8550 f5				push af  
8551 3a 65 85			ld a, (.dmark)  
8554 32 7a ee			ld (debug_mark),a  
8557 3a 66 85			ld a, (.dmark+1)  
855a 32 7b ee			ld (debug_mark+1),a  
855d 3a 67 85			ld a, (.dmark+2)  
8560 32 7c ee			ld (debug_mark+2),a  
8563 18 03			jr .pastdmark  
8565 ..			.dmark: db "SCc"  
8568 f1			.pastdmark: pop af  
8569			endm  
# End of macro DMARK
8569					CALLMONITOR 
8569 cd 6c 93			call break_point_state  
856c				endm  
# End of macro CALLMONITOR
856c				endif 
856c e1				pop hl    ; get zero term string 
856d e5				push hl 
856e 3e 00			ld a, 0 
8570 cd 27 8f			call strlent 
8573 23				inc hl   ; cover zero term 
8574 06 00			ld b,0 
8576 4d				ld c,l 
8577 e1				pop hl 
8578				;ex de, hl 
8578				if DEBUG_STORESE 
8578					DMARK "SCa" 
8578 f5				push af  
8579 3a 8d 85			ld a, (.dmark)  
857c 32 7a ee			ld (debug_mark),a  
857f 3a 8e 85			ld a, (.dmark+1)  
8582 32 7b ee			ld (debug_mark+1),a  
8585 3a 8f 85			ld a, (.dmark+2)  
8588 32 7c ee			ld (debug_mark+2),a  
858b 18 03			jr .pastdmark  
858d ..			.dmark: db "SCa"  
8590 f1			.pastdmark: pop af  
8591			endm  
# End of macro DMARK
8591					;push af 
8591					;ld a, 'a' 
8591					;ld (debug_mark),a 
8591					;pop af 
8591					CALLMONITOR 
8591 cd 6c 93			call break_point_state  
8594				endm  
# End of macro CALLMONITOR
8594				endif 
8594 ed b0			ldir    ; copy zero term string 
8596				if DEBUG_STORESE 
8596					DMARK "SCA" 
8596 f5				push af  
8597 3a ab 85			ld a, (.dmark)  
859a 32 7a ee			ld (debug_mark),a  
859d 3a ac 85			ld a, (.dmark+1)  
85a0 32 7b ee			ld (debug_mark+1),a  
85a3 3a ad 85			ld a, (.dmark+2)  
85a6 32 7c ee			ld (debug_mark+2),a  
85a9 18 03			jr .pastdmark  
85ab ..			.dmark: db "SCA"  
85ae f1			.pastdmark: pop af  
85af			endm  
# End of macro DMARK
85af					CALLMONITOR 
85af cd 6c 93			call break_point_state  
85b2				endm  
# End of macro CALLMONITOR
85b2				endif 
85b2			 
85b2				; write file header page 
85b2			 
85b2 2a 4f eb			ld hl,(store_tmppageid) 
85b5 11 65 eb			ld de, store_page 
85b8				if DEBUG_STORESE 
85b8					DMARK "SCb" 
85b8 f5				push af  
85b9 3a cd 85			ld a, (.dmark)  
85bc 32 7a ee			ld (debug_mark),a  
85bf 3a ce 85			ld a, (.dmark+1)  
85c2 32 7b ee			ld (debug_mark+1),a  
85c5 3a cf 85			ld a, (.dmark+2)  
85c8 32 7c ee			ld (debug_mark+2),a  
85cb 18 03			jr .pastdmark  
85cd ..			.dmark: db "SCb"  
85d0 f1			.pastdmark: pop af  
85d1			endm  
# End of macro DMARK
85d1					;push af 
85d1					;ld a, 'b' 
85d1					;ld (debug_mark),a 
85d1					;pop af 
85d1					CALLMONITOR 
85d1 cd 6c 93			call break_point_state  
85d4				endm  
# End of macro CALLMONITOR
85d4				endif 
85d4 cd 16 81			call storage_write_block 
85d7			 
85d7 3a 5e eb			ld a, (store_tmpid) 
85da 6f				ld l, a 
85db 26 00			ld h,0 
85dd				if DEBUG_STORESE 
85dd					DMARK "SCz" 
85dd f5				push af  
85de 3a f2 85			ld a, (.dmark)  
85e1 32 7a ee			ld (debug_mark),a  
85e4 3a f3 85			ld a, (.dmark+1)  
85e7 32 7b ee			ld (debug_mark+1),a  
85ea 3a f4 85			ld a, (.dmark+2)  
85ed 32 7c ee			ld (debug_mark+2),a  
85f0 18 03			jr .pastdmark  
85f2 ..			.dmark: db "SCz"  
85f5 f1			.pastdmark: pop af  
85f6			endm  
# End of macro DMARK
85f6					CALLMONITOR 
85f6 cd 6c 93			call break_point_state  
85f9				endm  
# End of macro CALLMONITOR
85f9				endif 
85f9 c9				ret 
85fa				 
85fa			 
85fa			 
85fa			; 
85fa			; Read File 
85fa			; 
85fa			; h - file id to locate 
85fa			; l - extent to locate 
85fa			; de - pointer to string to read into 
85fa			; 
85fa			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
85fa			 
85fa			.sr_fail: 
85fa d1				pop de 
85fb c9				ret 
85fc			 
85fc			storage_read: 
85fc d5				push de 
85fd			 
85fd			; TODO BUG the above push is it popped before the RET Z? 
85fd			 
85fd			; TODO how to handle multiple part blocks 
85fd			 
85fd				; locate file extent to read 
85fd			 
85fd 5c				ld e, h 
85fe 55				ld d, l 
85ff 21 40 00			ld hl, STORE_BLOCK_PHY 
8602				if DEBUG_STORESE 
8602					DMARK "SRE" 
8602 f5				push af  
8603 3a 17 86			ld a, (.dmark)  
8606 32 7a ee			ld (debug_mark),a  
8609 3a 18 86			ld a, (.dmark+1)  
860c 32 7b ee			ld (debug_mark+1),a  
860f 3a 19 86			ld a, (.dmark+2)  
8612 32 7c ee			ld (debug_mark+2),a  
8615 18 03			jr .pastdmark  
8617 ..			.dmark: db "SRE"  
861a f1			.pastdmark: pop af  
861b			endm  
# End of macro DMARK
861b					CALLMONITOR 
861b cd 6c 93			call break_point_state  
861e				endm  
# End of macro CALLMONITOR
861e				endif 
861e cd d6 83			call storage_findnextid 
8621			 
8621				if DEBUG_STORESE 
8621					DMARK "SRf" 
8621 f5				push af  
8622 3a 36 86			ld a, (.dmark)  
8625 32 7a ee			ld (debug_mark),a  
8628 3a 37 86			ld a, (.dmark+1)  
862b 32 7b ee			ld (debug_mark+1),a  
862e 3a 38 86			ld a, (.dmark+2)  
8631 32 7c ee			ld (debug_mark+2),a  
8634 18 03			jr .pastdmark  
8636 ..			.dmark: db "SRf"  
8639 f1			.pastdmark: pop af  
863a			endm  
# End of macro DMARK
863a					CALLMONITOR 
863a cd 6c 93			call break_point_state  
863d				endm  
# End of macro CALLMONITOR
863d				endif 
863d cd e7 8a			call ishlzero 
8640			;	ld a, l 
8640			;	add h 
8640			;	cp 0 
8640 28 b8			jr z,.sr_fail			; block not found so EOF 
8642			 
8642				; hl contains page number to load 
8642 d1				pop de   ; get storage 
8643 d5				push de 
8644				if DEBUG_STORESE 
8644					DMARK "SRg" 
8644 f5				push af  
8645 3a 59 86			ld a, (.dmark)  
8648 32 7a ee			ld (debug_mark),a  
864b 3a 5a 86			ld a, (.dmark+1)  
864e 32 7b ee			ld (debug_mark+1),a  
8651 3a 5b 86			ld a, (.dmark+2)  
8654 32 7c ee			ld (debug_mark+2),a  
8657 18 03			jr .pastdmark  
8659 ..			.dmark: db "SRg"  
865c f1			.pastdmark: pop af  
865d			endm  
# End of macro DMARK
865d					CALLMONITOR 
865d cd 6c 93			call break_point_state  
8660				endm  
# End of macro CALLMONITOR
8660				endif 
8660 cd b1 80			call storage_read_block 
8663			 
8663			 
8663			; TODO if block has no zeros then need to read next block  
8663			 
8663			 
8663					 
8663 e1				pop hl 		 ; return start of data to show as not EOF 
8664 23				inc hl   ; past file id 
8665 23				inc hl   ; past ext 
8666				if DEBUG_STORESE 
8666					DMARK "SRe" 
8666 f5				push af  
8667 3a 7b 86			ld a, (.dmark)  
866a 32 7a ee			ld (debug_mark),a  
866d 3a 7c 86			ld a, (.dmark+1)  
8670 32 7b ee			ld (debug_mark+1),a  
8673 3a 7d 86			ld a, (.dmark+2)  
8676 32 7c ee			ld (debug_mark+2),a  
8679 18 03			jr .pastdmark  
867b ..			.dmark: db "SRe"  
867e f1			.pastdmark: pop af  
867f			endm  
# End of macro DMARK
867f					CALLMONITOR 
867f cd 6c 93			call break_point_state  
8682				endm  
# End of macro CALLMONITOR
8682				endif 
8682 c9					ret 
8683			 
8683			 
8683			 
8683			; 
8683			; Append File 
8683			; 
8683			; hl - file id to locate 
8683			; de - pointer to (multi block) string to write 
8683			 
8683			.sa_notfound: 
8683 d1				pop de 
8684 c9				ret 
8685			 
8685			 
8685			storage_append: 
8685				; hl -  file id to append to 
8685				; de - string to append 
8685			 
8685 d5				push de 
8686				 
8686				if DEBUG_STORESE 
8686					DMARK "AP1" 
8686 f5				push af  
8687 3a 9b 86			ld a, (.dmark)  
868a 32 7a ee			ld (debug_mark),a  
868d 3a 9c 86			ld a, (.dmark+1)  
8690 32 7b ee			ld (debug_mark+1),a  
8693 3a 9d 86			ld a, (.dmark+2)  
8696 32 7c ee			ld (debug_mark+2),a  
8699 18 03			jr .pastdmark  
869b ..			.dmark: db "AP1"  
869e f1			.pastdmark: pop af  
869f			endm  
# End of macro DMARK
869f					CALLMONITOR 
869f cd 6c 93			call break_point_state  
86a2				endm  
# End of macro CALLMONITOR
86a2				endif 
86a2			 
86a2 7d				ld a, l 
86a3 32 5e eb			ld (store_tmpid), a 
86a6			 
86a6				; get file header  
86a6			 
86a6 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
86a8 3a 5e eb			ld a, (store_tmpid) 
86ab 5f				ld e, a 
86ac			 
86ac 21 40 00				ld hl, STORE_BLOCK_PHY 
86af cd d6 83				call storage_findnextid 
86b2			 
86b2 cd e7 8a			call ishlzero 
86b5 28 cc			jr z, .sa_notfound 
86b7			 
86b7 22 4f eb			ld (store_tmppageid), hl 
86ba			 
86ba				; TODO handle file id not found 
86ba			 
86ba				if DEBUG_STORESE 
86ba					DMARK "AP2" 
86ba f5				push af  
86bb 3a cf 86			ld a, (.dmark)  
86be 32 7a ee			ld (debug_mark),a  
86c1 3a d0 86			ld a, (.dmark+1)  
86c4 32 7b ee			ld (debug_mark+1),a  
86c7 3a d1 86			ld a, (.dmark+2)  
86ca 32 7c ee			ld (debug_mark+2),a  
86cd 18 03			jr .pastdmark  
86cf ..			.dmark: db "AP2"  
86d2 f1			.pastdmark: pop af  
86d3			endm  
# End of macro DMARK
86d3					CALLMONITOR 
86d3 cd 6c 93			call break_point_state  
86d6				endm  
# End of macro CALLMONITOR
86d6				endif 
86d6			 
86d6				; update file extent count 
86d6			 
86d6 11 65 eb			ld de, store_page 
86d9			 
86d9 cd b1 80			call storage_read_block 
86dc			 
86dc				if DEBUG_STORESE 
86dc					DMARK "AP3" 
86dc f5				push af  
86dd 3a f1 86			ld a, (.dmark)  
86e0 32 7a ee			ld (debug_mark),a  
86e3 3a f2 86			ld a, (.dmark+1)  
86e6 32 7b ee			ld (debug_mark+1),a  
86e9 3a f3 86			ld a, (.dmark+2)  
86ec 32 7c ee			ld (debug_mark+2),a  
86ef 18 03			jr .pastdmark  
86f1 ..			.dmark: db "AP3"  
86f4 f1			.pastdmark: pop af  
86f5			endm  
# End of macro DMARK
86f5					CALLMONITOR 
86f5 cd 6c 93			call break_point_state  
86f8				endm  
# End of macro CALLMONITOR
86f8				endif 
86f8			;	ld (store_tmppageid), hl 
86f8			 
86f8 3a 67 eb			ld a, (store_page+2) 
86fb 3c				inc a 
86fc 32 67 eb			ld (store_page+2), a 
86ff 32 5d eb			ld (store_tmpext), a 
8702				 
8702				if DEBUG_STORESE 
8702					DMARK "AP3" 
8702 f5				push af  
8703 3a 17 87			ld a, (.dmark)  
8706 32 7a ee			ld (debug_mark),a  
8709 3a 18 87			ld a, (.dmark+1)  
870c 32 7b ee			ld (debug_mark+1),a  
870f 3a 19 87			ld a, (.dmark+2)  
8712 32 7c ee			ld (debug_mark+2),a  
8715 18 03			jr .pastdmark  
8717 ..			.dmark: db "AP3"  
871a f1			.pastdmark: pop af  
871b			endm  
# End of macro DMARK
871b					CALLMONITOR 
871b cd 6c 93			call break_point_state  
871e				endm  
# End of macro CALLMONITOR
871e				endif 
871e 2a 4f eb			ld hl, (store_tmppageid) 
8721 11 65 eb			ld de, store_page 
8724 cd 16 81			call storage_write_block 
8727			 
8727				; find free block 
8727			 
8727 11 00 00			ld de, 0			 ; file extent to locate 
872a			 
872a 21 40 00				ld hl, STORE_BLOCK_PHY 
872d cd d6 83				call storage_findnextid 
8730 cd e7 8a			call ishlzero 
8733 ca 83 86			jp z, .sa_notfound 
8736			 
8736					; TODO handle no space left 
8736					 
8736 22 4f eb				ld (store_tmppageid), hl 
8739			 
8739				if DEBUG_STORESE 
8739					DMARK "AP4" 
8739 f5				push af  
873a 3a 4e 87			ld a, (.dmark)  
873d 32 7a ee			ld (debug_mark),a  
8740 3a 4f 87			ld a, (.dmark+1)  
8743 32 7b ee			ld (debug_mark+1),a  
8746 3a 50 87			ld a, (.dmark+2)  
8749 32 7c ee			ld (debug_mark+2),a  
874c 18 03			jr .pastdmark  
874e ..			.dmark: db "AP4"  
8751 f1			.pastdmark: pop af  
8752			endm  
# End of macro DMARK
8752					CALLMONITOR 
8752 cd 6c 93			call break_point_state  
8755				endm  
# End of macro CALLMONITOR
8755				endif 
8755					; init the buffer with zeros so we can id if the buffer is full or not 
8755			 
8755 e5					push hl 
8756 c5					push bc 
8757			 
8757 21 65 eb				ld hl, store_page 
875a 06 40				ld b, STORE_BLOCK_PHY 
875c 3e 00				ld a, 0 
875e 77			.zeroblock:	ld (hl), a 
875f 23					inc hl 
8760 10 fc				djnz .zeroblock 
8762			 
8762 c1					pop bc 
8763 e1					pop hl 
8764			 
8764					; construct block 
8764			 
8764 3a 5e eb				ld a, (store_tmpid) 
8767 32 65 eb				ld (store_page), a   ; file id 
876a 3a 5d eb				ld a, (store_tmpext)   ; extent for this block 
876d 32 66 eb				ld (store_page+1), a 
8770			 
8770 e1					pop hl    ; get string to write 
8771 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
8773 11 67 eb				ld de, store_page+2 
8776			 
8776				if DEBUG_STORESE 
8776					DMARK "AP5" 
8776 f5				push af  
8777 3a 8b 87			ld a, (.dmark)  
877a 32 7a ee			ld (debug_mark),a  
877d 3a 8c 87			ld a, (.dmark+1)  
8780 32 7b ee			ld (debug_mark+1),a  
8783 3a 8d 87			ld a, (.dmark+2)  
8786 32 7c ee			ld (debug_mark+2),a  
8789 18 03			jr .pastdmark  
878b ..			.dmark: db "AP5"  
878e f1			.pastdmark: pop af  
878f			endm  
# End of macro DMARK
878f					CALLMONITOR 
878f cd 6c 93			call break_point_state  
8792				endm  
# End of macro CALLMONITOR
8792				endif 
8792			 
8792			 
8792			 
8792					; fill buffer with data until end of string or full block 
8792			 
8792 7e			.appd:		ld a, (hl) 
8793 12					ld (de), a 
8794 fe 00				cp 0 
8796 28 04				jr z, .appdone 
8798 23					inc hl 
8799 13					inc de 
879a 10 f6				djnz .appd 
879c			 
879c e5			.appdone:	push hl		 	; save current source in case we need to go around again 
879d f5					push af   		; save last byte dumped 
879e			 
879e			 
879e 2a 4f eb			ld hl, (store_tmppageid) 
87a1 11 65 eb			ld de, store_page 
87a4				if DEBUG_STORESE 
87a4					DMARK "AP6" 
87a4 f5				push af  
87a5 3a b9 87			ld a, (.dmark)  
87a8 32 7a ee			ld (debug_mark),a  
87ab 3a ba 87			ld a, (.dmark+1)  
87ae 32 7b ee			ld (debug_mark+1),a  
87b1 3a bb 87			ld a, (.dmark+2)  
87b4 32 7c ee			ld (debug_mark+2),a  
87b7 18 03			jr .pastdmark  
87b9 ..			.dmark: db "AP6"  
87bc f1			.pastdmark: pop af  
87bd			endm  
# End of macro DMARK
87bd					CALLMONITOR 
87bd cd 6c 93			call break_point_state  
87c0				endm  
# End of macro CALLMONITOR
87c0				endif 
87c0 cd 16 81				call storage_write_block 
87c3			 
87c3			 
87c3				; was that a full block of data written? 
87c3				; any more to write out? 
87c3			 
87c3				; if yes then set vars and jump to start of function again 
87c3			 
87c3 f1					pop af 
87c4 d1					pop de 
87c5			 
87c5 fe 00				cp 0		 ; no, string was fully written 
87c7 c8					ret z 
87c8			 
87c8					; setup vars for next cycle 
87c8			 
87c8 3a 5e eb				ld a, (store_tmpid) 
87cb 6f					ld l, a 
87cc 26 00				ld h, 0 
87ce			 
87ce c3 85 86			 	jp storage_append	 ; yes, need to write out some more 
87d1			 
87d1			 
87d1			 
87d1			 
87d1			 
87d1			 
87d1			 
87d1			if DEBUG_STORECF 
87d1			storageput:	 
87d1					ret 
87d1			storageread: 
87d1					ld hl, store_page 
87d1					ld b, 200 
87d1					ld a,0 
87d1			.src:		ld (hl),a 
87d1					inc hl 
87d1					djnz .src 
87d1					 
87d1			 
87d1					ld de, 0 
87d1					ld bc, 1 
87d1					ld hl, store_page 
87d1					call cfRead 
87d1			 
87d1				call cfGetError 
87d1				ld hl,scratch 
87d1				call hexout 
87d1				ld hl, scratch+2 
87d1				ld a, 0 
87d1				ld (hl),a 
87d1				ld de, scratch 
87d1				ld a,display_row_1 
87d1				call str_at_display 
87d1				call update_display 
87d1			 
87d1					ld hl, store_page 
87d1					ld (os_cur_ptr),hl 
87d1			 
87d1					ret 
87d1			endif 
87d1			 
87d1			 
87d1			; Clear out the main buffer store (used to remove junk before writing a new block) 
87d1			 
87d1			storage_clear_page: 
87d1 e5				push hl 
87d2 d5				push de 
87d3 c5				push bc 
87d4 21 65 eb			ld hl, store_page 
87d7 3e 00			ld a, 0 
87d9 77				ld (hl), a 
87da			 
87da 11 66 eb			ld de, store_page+1 
87dd 01 40 00			ld bc, STORE_BLOCK_PHY 
87e0			 
87e0 ed b0			ldir 
87e2				 
87e2 c1				pop bc 
87e3 d1				pop de 
87e4 e1				pop hl 
87e5 c9				ret 
87e6			 
87e6			; eof 
# End of file firmware_storage.asm
87e6			  
87e6			; support routines for above hardware abstraction layer  
87e6			  
87e6			include "firmware_general.asm"        ; general support functions  
87e6			 
87e6			; word look up 
87e6			 
87e6			; in 
87e6			; a is the index 
87e6			; hl is pointer start of array 
87e6			; 
87e6			; returns 
87e6			; hl to the word 
87e6			; 
87e6			 
87e6			table_lookup:  
87e6 d5					push de 
87e7 eb					ex de, hl 
87e8			 
87e8 6f					ld l, a 
87e9 26 00				ld h, 0 
87eb 29					add hl, hl 
87ec 19					add hl, de 
87ed 7e					ld a, (hl) 
87ee 23					inc hl 
87ef 66					ld h,(hl) 
87f0 6f					ld l, a 
87f1			 
87f1 d1					pop de 
87f2 c9					ret 
87f3			 
87f3			; Delay loops 
87f3			 
87f3			 
87f3			 
87f3			aDelayInMS: 
87f3 c5				push bc 
87f4 47				ld b,a 
87f5			msdelay: 
87f5 c5				push bc 
87f6				 
87f6			 
87f6 01 41 00			ld bc,041h 
87f9 cd 11 88			call delayloop 
87fc c1				pop bc 
87fd 05				dec b 
87fe 20 f5			jr nz,msdelay 
8800			 
8800			;if CPU_CLOCK_8MHZ 
8800			;msdelay8: 
8800			;	push bc 
8800			;	 
8800			; 
8800			;	ld bc,041h 
8800			;	call delayloop 
8800			;	pop bc 
8800			;	dec b 
8800			;	jr nz,msdelay8 
8800			;endif 
8800			 
8800			 
8800 c1				pop bc 
8801 c9				ret 
8802			 
8802			 
8802			delay250ms: 
8802				;push de 
8802 01 00 40			ld bc, 04000h 
8805 c3 11 88			jp delayloop 
8808			delay500ms: 
8808				;push de 
8808 01 00 80			ld bc, 08000h 
880b c3 11 88			jp delayloop 
880e			delay1s: 
880e				;push bc 
880e			   ; Clobbers A, d and e 
880e 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
8811			delayloop: 
8811 c5			    push bc 
8812			 
8812			if BASE_CPM 
8812				ld bc, CPM_DELAY_TUNE 
8812			.cpmloop: 
8812				push bc 
8812			 
8812			endif 
8812			 
8812			 
8812			 
8812			delayloopi: 
8812			;	push bc 
8812			;.dl: 
8812 cb 47		    bit     0,a    	; 8 
8814 cb 47		    bit     0,a    	; 8 
8816 cb 47		    bit     0,a    	; 8 
8818 e6 ff		    and     255  	; 7 
881a 0b			    dec     bc      	; 6 
881b 79			    ld      a,c     	; 4 
881c b0			    or      b     	; 4 
881d c2 12 88		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
8820			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
8820				;pop de 
8820			;pop bc 
8820			 
8820			if BASE_CPM 
8820				pop bc 
8820				 
8820			    dec     bc      	; 6 
8820			    ld      a,c     	; 4 
8820			    or      b     	; 4 
8820			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
8820				 
8820			 
8820			endif 
8820			;if CPU_CLOCK_8MHZ 
8820			;    pop bc 
8820			;    push bc 
8820			;.dl8: 
8820			;    bit     0,a    	; 8 
8820			;    bit     0,a    	; 8 
8820			;    bit     0,a    	; 8 
8820			;    and     255  	; 7 
8820			;    dec     bc      	; 6 
8820			;    ld      a,c     	; 4 
8820			;    or      b     	; 4 
8820			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8820			;endif 
8820			 
8820			;if CPU_CLOCK_10MHZ 
8820			;    pop bc 
8820			;    push bc 
8820			;.dl8: 
8820			;    bit     0,a    	; 8 
8820			;    bit     0,a    	; 8 
8820			;    bit     0,a    	; 8 
8820			;    and     255  	; 7 
8820			;    dec     bc      	; 6 
8820			;    ld      a,c     	; 4 
8820			;    or      b     	; 4 
8820			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
8820			;endif 
8820 c1			    pop bc 
8821			 
8821 c9				ret 
8822			 
8822			 
8822			 
8822			; eof 
# End of file firmware_general.asm
8822			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
8822			; display routines that use the physical hardware abstraction layer 
8822			 
8822			 
8822			; information window 
8822			 
8822			; pass hl with 1st string to display 
8822			; pass de with 2nd string to display 
8822			 
8822			info_panel: 
8822 e5				push hl 
8823			 
8823 2a db eb			ld hl, (display_fb_active) 
8826 e5				push hl    ; future de destination 
8827 21 c0 ed				ld hl, display_fb0 
882a 22 db eb				ld (display_fb_active), hl 
882d			 
882d			;	call clear_display 
882d			 
882d				if BASE_CPM 
882d				ld a, '.' 
882d				else 
882d 3e a5			ld a, 165 
882f				endif 
882f cd 96 88			call fill_display 
8832			 
8832			 
8832 3e 55			ld a, display_row_3 + 5 
8834 cd a4 88			call str_at_display 
8837			 
8837 e1				pop hl 
8838 d1				pop de 
8839			 
8839 e5				push hl 
883a			 
883a			 
883a 3e 2d			ld a, display_row_2 + 5 
883c cd a4 88			call str_at_display 
883f			 
883f			 
883f cd b4 88			call update_display 
8842 cd 71 98			call next_page_prompt 
8845 cd 91 88			call clear_display 
8848			 
8848				 
8848 21 1f ed				ld hl, display_fb1 
884b 22 db eb				ld (display_fb_active), hl 
884e cd b4 88			call update_display 
8851			 
8851 e1				pop hl 
8852			 
8852 c9				ret 
8853			 
8853			 
8853			 
8853			 
8853			; TODO windowing? 
8853			 
8853			; TODO scroll line up 
8853			 
8853			scroll_up: 
8853			 
8853 e5				push hl 
8854 d5				push de 
8855 c5				push bc 
8856			 
8856				; get frame buffer  
8856			 
8856 2a db eb			ld hl, (display_fb_active) 
8859 e5				push hl    ; future de destination 
885a			 
885a 11 28 00			ld  de, display_cols 
885d 19				add hl, de 
885e			 
885e d1				pop de 
885f			 
885f				;ex de, hl 
885f 01 9f 00			ld bc, display_fb_len -1  
8862			;if DEBUG_FORTH_WORDS 
8862			;	DMARK "SCL" 
8862			;	CALLMONITOR 
8862			;endif	 
8862 ed b0			ldir 
8864			 
8864				; wipe bottom row 
8864			 
8864			 
8864 2a db eb			ld hl, (display_fb_active) 
8867 11 a0 00			ld de, display_cols*display_rows 
886a 19				add hl, de 
886b 06 28			ld b, display_cols 
886d 3e 20			ld a, ' ' 
886f			.scwipe: 
886f 77				ld (hl), a 
8870 2b				dec hl 
8871 10 fc			djnz .scwipe 
8873			 
8873				;pop hl 
8873			 
8873 c1				pop bc 
8874 d1				pop de 
8875 e1				pop hl 
8876			 
8876 c9				ret 
8877			 
8877			 
8877			;scroll_upo: 
8877			;	ld de, display_row_1 
8877			 ;	ld hl, display_row_2 
8877			;	ld bc, display_cols 
8877			;	ldir 
8877			;	ld de, display_row_2 
8877			 ;	ld hl, display_row_3 
8877			;	ld bc, display_cols 
8877			;	ldir 
8877			;	ld de, display_row_3 
8877			 ;	ld hl, display_row_4 
8877			;	ld bc, display_cols 
8877			;	ldir 
8877			 
8877			; TODO clear row 4 
8877			 
8877			;	ret 
8877			 
8877				 
8877			scroll_down: 
8877			 
8877 e5				push hl 
8878 d5				push de 
8879 c5				push bc 
887a			 
887a				; get frame buffer  
887a			 
887a 2a db eb			ld hl, (display_fb_active) 
887d			 
887d 11 9f 00			ld de, display_fb_len - 1 
8880 19				add hl, de 
8881			 
8881 e5			push hl    ; future de destination 
8882			 
8882 11 28 00			ld  de, display_cols 
8885 ed 52			sbc hl, de 
8887			 
8887			 
8887 d1				pop de 
8888			 
8888			;	ex de, hl 
8888 01 9f 00			ld bc, display_fb_len -1  
888b			 
888b			 
888b				 
888b			 
888b ed b0			ldir 
888d			 
888d				; wipe bottom row 
888d			 
888d			 
888d			;	ld hl, (display_fb_active) 
888d			;;	ld de, display_cols*display_rows 
888d			;;	add hl, de 
888d			;	ld b, display_cols 
888d			;	ld a, ' ' 
888d			;.scwiped: 
888d			;	ld (hl), a 
888d			;	dec hl 
888d			;	djnz .scwiped 
888d			 
888d				;pop hl 
888d			 
888d c1				pop bc 
888e d1				pop de 
888f e1				pop hl 
8890			 
8890 c9				ret 
8891			;scroll_down: 
8891			;	ld de, display_row_4 
8891			;	ld hl, display_row_3 
8891			;	ld bc, display_cols 
8891			;	ldir 
8891			;	ld de, display_row_3 
8891			; 	ld hl, display_row_2 
8891			;	ld bc, display_cols 
8891			;	ldir 
8891			;	ld de, display_row_2 
8891			;	ld hl, display_row_1 
8891			;	ld bc, display_cols 
8891			;	ldir 
8891			;;; TODO clear row 1 
8891			;	ret 
8891			 
8891			 
8891			 
8891			 
8891			 
8891			; clear active frame buffer 
8891			 
8891			clear_display: 
8891 3e 20			ld a, ' ' 
8893 c3 96 88			jp fill_display 
8896			 
8896			; fill active frame buffer with a char in A 
8896			 
8896			fill_display: 
8896 06 a0			ld b,display_fb_len 
8898 2a db eb			ld hl, (display_fb_active) 
889b 77			.fd1:	ld (hl),a 
889c 23				inc hl 
889d 10 fc			djnz .fd1 
889f 23				inc hl 
88a0 3e 00			ld a,0 
88a2 77				ld (hl),a 
88a3			 
88a3			 
88a3 c9				ret 
88a4			; Write string (DE) at pos (A) to active frame buffer 
88a4			 
88a4 2a db eb		str_at_display:    ld hl,(display_fb_active) 
88a7 06 00					ld b,0 
88a9 4f					ld c,a 
88aa 09					add hl,bc 
88ab 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
88ac b7			            OR   A              ;Null terminator? 
88ad c8			            RET  Z              ;Yes, so finished 
88ae 77					ld (hl),a 
88af 23				inc hl 
88b0 13			            INC  DE             ;Point to next character 
88b1 18 f8		            JR   .sad1     ;Repeat 
88b3 c9					ret 
88b4			 
88b4			; using current frame buffer write to physical display 
88b4			 
88b4			update_display: 
88b4 e5				push hl 
88b5 2a db eb			ld hl, (display_fb_active) 
88b8 cd 3e d7			call write_display 
88bb e1				pop hl 
88bc c9				ret 
88bd			 
88bd			; TODO scrolling 
88bd			 
88bd			 
88bd			; move cursor right one char 
88bd			cursor_right: 
88bd			 
88bd				; TODO shift right 
88bd				; TODO if beyond max col 
88bd				; TODO       cursor_next_line 
88bd			 
88bd c9				ret 
88be			 
88be			 
88be			cursor_next_line: 
88be				; TODO first char 
88be				; TODO line down 
88be				; TODO if past last row 
88be				; TODO    scroll up 
88be			 
88be c9				ret 
88bf			 
88bf			cursor_left: 
88bf				; TODO shift left 
88bf				; TODO if beyond left  
88bf				; TODO     cursor prev line 
88bf				 
88bf c9				ret 
88c0			 
88c0			cursor_prev_line: 
88c0				; TODO last char 
88c0				; TODO line up 
88c0				; TODO if past first row 
88c0				; TODO   scroll down 
88c0			 
88c0 c9				ret 
88c1			 
88c1			 
88c1			cout: 
88c1				; A - char 
88c1 c9				ret 
88c2			 
88c2			 
88c2			; Display a menu and allow item selection (optional toggle items) 
88c2			; 
88c2			; format: 
88c2			; hl pointer to word array with zero term for items 
88c2			; e.g.    db item1 
88c2			;         db .... 
88c2			;         db 0 
88c2			; 
88c2			; a = starting menu item  
88c2			; 
88c2			; de = pointer item toggle array   (todo) 
88c2			; 
88c2			; returns item selected in a 1-... 
88c2			; returns 0 if back button pressed 
88c2			; 
88c2			; NOTE: Uses system frame buffer to display 
88c2			; 
88c2			; LEFT, Q = go back 
88c2			; RIGHT, SPACE, CR = select 
88c2			; UP, A - Up 
88c2			; DOWN, Z - Down 
88c2			 
88c2			 
88c2			 
88c2			 
88c2			 
88c2			menu: 
88c2			 
88c2					; keep array pointer 
88c2			 
88c2 22 63 eb				ld (store_tmp1), hl 
88c5 32 61 eb				ld (store_tmp2), a 
88c8			 
88c8					; check for key bounce 
88c8			 
88c8			if BASE_KEV 
88c8			 
88c8			.mbounce:	call cin 
88c8					cp 0 
88c8					jr nz, .mbounce 
88c8			endif 
88c8					; for ease use ex 
88c8			 
88c8					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
88c8 21 c0 ed				ld hl, display_fb0 
88cb 22 db eb				ld (display_fb_active), hl 
88ce			 
88ce cd 91 88		.mloop:		call clear_display 
88d1 cd b4 88				call update_display 
88d4			 
88d4					; draw selection id '>' at 1 
88d4			 
88d4					; init start of list display 
88d4			 
88d4 3e 05				ld a, 5 
88d6 32 5f eb				ld (store_tmp3), a   ; display row count 
88d9 3a 61 eb				ld a,( store_tmp2) 
88dc 32 62 eb				ld (store_tmp2+1), a   ; display item count 
88df			 
88df					 
88df			.mitem:	 
88df			 
88df			 
88df 3a 62 eb				ld a,(store_tmp2+1) 
88e2 6f					ld l, a 
88e3 26 00				ld h, 0 
88e5 29					add hl, hl 
88e6 ed 5b 63 eb			ld de, (store_tmp1) 
88ea 19					add hl, de 
88eb 7e					ld a, (hl) 
88ec 23					inc hl 
88ed 66					ld h,(hl) 
88ee 6f					ld l, a 
88ef			 
88ef cd e7 8a				call ishlzero 
88f2 28 1a				jr z, .mdone 
88f4			 
88f4 eb					ex de, hl 
88f5 3a 5f eb				ld a, (store_tmp3) 
88f8 cd a4 88				call str_at_display 
88fb					 
88fb			 
88fb					; next item 
88fb 3a 62 eb				ld a, (store_tmp2+1) 
88fe 3c					inc a 
88ff 32 62 eb				ld (store_tmp2+1), a   ; display item count 
8902			 
8902			 		; next row 
8902			 
8902 3a 5f eb				ld a, (store_tmp3) 
8905 c6 28				add display_cols 
8907 32 5f eb				ld (store_tmp3), a 
890a			 
890a					; at end of screen? 
890a			 
890a fe 10				cp display_rows*4 
890c 20 d1				jr nz, .mitem 
890e			 
890e			 
890e			.mdone: 
890e cd e7 8a				call ishlzero 
8911 28 08				jr z, .nodn 
8913			 
8913 3e 78				ld a, display_row_4 
8915 11 94 89				ld de, .mdown 
8918 cd a4 88				call str_at_display 
891b			 
891b					; draw options to fill the screens with active item on line 1 
891b					; if current option is 2 or more then display ^ in top 
891b			 
891b 3a 61 eb		.nodn:		ld a, (store_tmp2) 
891e fe 00				cp 0 
8920 28 08				jr z, .noup 
8922			 
8922 3e 00				ld a, 0 
8924 11 92 89				ld de, .mup 
8927 cd a4 88				call str_at_display 
892a			 
892a 3e 02		.noup:		ld a, 2 
892c 11 90 89				ld de, .msel 
892f cd a4 88				call str_at_display 
8932			 
8932					; if current option + 1 is not null then display V in bottom 
8932					; get key 
8932 cd b4 88				call update_display 
8935			 
8935			 
8935					; handle key 
8935			 
8935 cd ca d7				call cin_wait 
8938			 
8938 fe 05				cp KEY_UP 
893a 28 2b				jr z, .mgoup 
893c fe 61				cp 'a' 
893e 28 27				jr z, .mgoup 
8940 fe 0a				cp KEY_DOWN 
8942 28 32				jr z, .mgod 
8944 fe 7a				cp 'z' 
8946 28 2e				jr z, .mgod 
8948 fe 20				cp ' ' 
894a 28 34				jr z, .goend 
894c fe 0c				cp KEY_RIGHT 
894e 28 30				jr z, .goend 
8950 fe 0d				cp KEY_CR 
8952 28 2c				jr z, .goend 
8954 fe 71				cp 'q' 
8956 28 0b				jr z, .goback 
8958			 
8958 fe 0b				cp KEY_LEFT 
895a 28 07				jr z, .goback 
895c fe 08				cp KEY_BS 
895e 28 03				jr z, .goback 
8960 c3 ce 88				jp .mloop 
8963			 
8963			.goback: 
8963 3e 00			ld a, 0 
8965 18 1d			jr .goend2 
8967			 
8967				; move up one 
8967			.mgoup: 
8967 3a 61 eb				ld a, (store_tmp2) 
896a fe 00				cp 0 
896c ca ce 88				jp z, .mloop 
896f 3d					dec a 
8970 32 61 eb				ld (store_tmp2), a 
8973 c3 ce 88				jp .mloop 
8976			 
8976				; move down one 
8976			.mgod: 
8976 3a 61 eb				ld a, (store_tmp2) 
8979 3c					inc a 
897a 32 61 eb				ld (store_tmp2), a 
897d c3 ce 88				jp .mloop 
8980			 
8980			 
8980			.goend: 
8980					; get selected item number 
8980			 
8980 3a 61 eb				ld a, (store_tmp2) 
8983 3c					inc a 
8984			 
8984			.goend2: 
8984 f5					push af 
8985			 
8985					; restore active fb 
8985					; TODO BUG assumes fb1 
8985			 
8985 21 1f ed				ld hl, display_fb1 
8988 22 db eb				ld (display_fb_active), hl 
898b			 
898b					; restore main regs 
898b			 
898b			 
898b cd b4 88				call update_display 
898e			 
898e f1					pop af 
898f			 
898f c9				ret 
8990			 
8990 .. 00		.msel:   db ">",0 
8992 .. 00		.mup:   db "^",0 
8994 .. 00		.mdown:   db "v",0 
8996			 
8996			 
8996			; eof 
8996			 
# End of file firmware_display.asm
8996			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
8996			; random number generators 
8996			 
8996			 
8996			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
8996			 
8996			 
8996			;-----> Generate a random number 
8996			; output a=answer 0<=a<=255 
8996			; all registers are preserved except: af 
8996			random: 
8996 e5			        push    hl 
8997 d5			        push    de 
8998 2a bd eb		        ld      hl,(randData) 
899b ed 5f		        ld      a,r 
899d 57			        ld      d,a 
899e 5e			        ld      e,(hl) 
899f 19			        add     hl,de 
89a0 85			        add     a,l 
89a1 ac			        xor     h 
89a2 22 bd eb		        ld      (randData),hl 
89a5 d1			        pop     de 
89a6 e1			        pop     hl 
89a7 c9			        ret 
89a8			 
89a8			 
89a8			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
89a8			 
89a8			 
89a8			 
89a8			;------LFSR------ 
89a8			;James Montelongo 
89a8			;optimized by Spencer Putt 
89a8			;out: 
89a8			; a = 8 bit random number 
89a8			RandLFSR: 
89a8 21 c3 eb		        ld hl,LFSRSeed+4 
89ab 5e			        ld e,(hl) 
89ac 23			        inc hl 
89ad 56			        ld d,(hl) 
89ae 23			        inc hl 
89af 4e			        ld c,(hl) 
89b0 23			        inc hl 
89b1 7e			        ld a,(hl) 
89b2 47			        ld b,a 
89b3 cb 13		        rl e  
89b5 cb 12			rl d 
89b7 cb 11		        rl c  
89b9 17				rla 
89ba cb 13		        rl e  
89bc cb 12			rl d 
89be cb 11		        rl c  
89c0 17				rla 
89c1 cb 13		        rl e  
89c3 cb 12			rl d 
89c5 cb 11		        rl c  
89c7 17				rla 
89c8 67			        ld h,a 
89c9 cb 13		        rl e  
89cb cb 12			rl d 
89cd cb 11		        rl c  
89cf 17				rla 
89d0 a8			        xor b 
89d1 cb 13		        rl e  
89d3 cb 12			rl d 
89d5 ac			        xor h 
89d6 a9			        xor c 
89d7 aa			        xor d 
89d8 21 c5 eb		        ld hl,LFSRSeed+6 
89db 11 c6 eb		        ld de,LFSRSeed+7 
89de 01 07 00		        ld bc,7 
89e1 ed b8		        lddr 
89e3 12			        ld (de),a 
89e4 c9			        ret 
89e5			 
89e5			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
89e5			 
89e5			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
89e5			 
89e5			 
89e5			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
89e5			 
89e5			prng16: 
89e5			;Inputs: 
89e5			;   (seed1) contains a 16-bit seed value 
89e5			;   (seed2) contains a NON-ZERO 16-bit seed value 
89e5			;Outputs: 
89e5			;   HL is the result 
89e5			;   BC is the result of the LCG, so not that great of quality 
89e5			;   DE is preserved 
89e5			;Destroys: 
89e5			;   AF 
89e5			;cycle: 4,294,901,760 (almost 4.3 billion) 
89e5			;160cc 
89e5			;26 bytes 
89e5 2a b7 eb		    ld hl,(seed1) 
89e8 44			    ld b,h 
89e9 4d			    ld c,l 
89ea 29			    add hl,hl 
89eb 29			    add hl,hl 
89ec 2c			    inc l 
89ed 09			    add hl,bc 
89ee 22 b7 eb		    ld (seed1),hl 
89f1 2a b5 eb		    ld hl,(seed2) 
89f4 29			    add hl,hl 
89f5 9f			    sbc a,a 
89f6 e6 2d		    and %00101101 
89f8 ad			    xor l 
89f9 6f			    ld l,a 
89fa 22 b5 eb		    ld (seed2),hl 
89fd 09			    add hl,bc 
89fe c9			    ret 
89ff			 
89ff			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
89ff			 
89ff			rand32: 
89ff			;Inputs: 
89ff			;   (seed1_0) holds the lower 16 bits of the first seed 
89ff			;   (seed1_1) holds the upper 16 bits of the first seed 
89ff			;   (seed2_0) holds the lower 16 bits of the second seed 
89ff			;   (seed2_1) holds the upper 16 bits of the second seed 
89ff			;   **NOTE: seed2 must be non-zero 
89ff			;Outputs: 
89ff			;   HL is the result 
89ff			;   BC,DE can be used as lower quality values, but are not independent of HL. 
89ff			;Destroys: 
89ff			;   AF 
89ff			;Tested and passes all CAcert tests 
89ff			;Uses a very simple 32-bit LCG and 32-bit LFSR 
89ff			;it has a period of 18,446,744,069,414,584,320 
89ff			;roughly 18.4 quintillion. 
89ff			;LFSR taps: 0,2,6,7  = 11000101 
89ff			;291cc 
89ff			;seed1_0=$+1 
89ff			;    ld hl,12345 
89ff			;seed1_1=$+1 
89ff			;    ld de,6789 
89ff			;    ld b,h 
89ff			;    ld c,l 
89ff			;    add hl,hl \ rl e \ rl d 
89ff			;    add hl,hl \ rl e \ rl d 
89ff			;    inc l 
89ff			;    add hl,bc 
89ff			;    ld (seed1_0),hl 
89ff			;    ld hl,(seed1_1) 
89ff			;    adc hl,de 
89ff			;    ld (seed1_1),hl 
89ff			;    ex de,hl 
89ff			;seed2_0=$+1 
89ff			;    ld hl,9876 
89ff			;seed2_1=$+1 
89ff			;    ld bc,54321 
89ff			;    add hl,hl \ rl c \ rl b 
89ff			;    ld (seed2_1),bc 
89ff			;    sbc a,a 
89ff			;    and %11000101 
89ff			;    xor l 
89ff			;    ld l,a 
89ff			;    ld (seed2_0),hl 
89ff			;    ex de,hl 
89ff			;    add hl,bc 
89ff			;    ret 
89ff			; 
89ff			 
89ff			; 16-bit xorshift pseudorandom number generator by John Metcalf 
89ff			; 20 bytes, 86 cycles (excluding ret) 
89ff			 
89ff			; returns   hl = pseudorandom number 
89ff			; corrupts   a 
89ff			 
89ff			; generates 16-bit pseudorandom numbers with a period of 65535 
89ff			; using the xorshift method: 
89ff			 
89ff			; hl ^= hl << 7 
89ff			; hl ^= hl >> 9 
89ff			; hl ^= hl << 8 
89ff			 
89ff			; some alternative shift triplets which also perform well are: 
89ff			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
89ff			 
89ff			;  org 32768 
89ff			 
89ff			xrnd: 
89ff 2a bb eb		  ld hl,(xrandc)       ; seed must not be 0 
8a02 3e 00		  ld a,0 
8a04 bd			  cp l 
8a05 20 02		  jr nz, .xrnd1 
8a07 2e 01		  ld l, 1 
8a09			.xrnd1: 
8a09			 
8a09 7c			  ld a,h 
8a0a 1f			  rra 
8a0b 7d			  ld a,l 
8a0c 1f			  rra 
8a0d ac			  xor h 
8a0e 67			  ld h,a 
8a0f 7d			  ld a,l 
8a10 1f			  rra 
8a11 7c			  ld a,h 
8a12 1f			  rra 
8a13 ad			  xor l 
8a14 6f			  ld l,a 
8a15 ac			  xor h 
8a16 67			  ld h,a 
8a17			 
8a17 22 bb eb		  ld (xrandc),hl 
8a1a			 
8a1a c9			  ret 
8a1b			;  
8a1b			 
8a1b			 
8a1b			;;;; int maths 
8a1b			 
8a1b			; https://map.grauw.nl/articles/mult_div_shifts.php 
8a1b			; Divide 16-bit values (with 16-bit result) 
8a1b			; In: Divide BC by divider DE 
8a1b			; Out: BC = result, HL = rest 
8a1b			; 
8a1b			Div16: 
8a1b 21 00 00		    ld hl,0 
8a1e 78			    ld a,b 
8a1f 06 08		    ld b,8 
8a21			Div16_Loop1: 
8a21 17			    rla 
8a22 ed 6a		    adc hl,hl 
8a24 ed 52		    sbc hl,de 
8a26 30 01		    jr nc,Div16_NoAdd1 
8a28 19			    add hl,de 
8a29			Div16_NoAdd1: 
8a29 10 f6		    djnz Div16_Loop1 
8a2b 17			    rla 
8a2c 2f			    cpl 
8a2d 47			    ld b,a 
8a2e 79			    ld a,c 
8a2f 48			    ld c,b 
8a30 06 08		    ld b,8 
8a32			Div16_Loop2: 
8a32 17			    rla 
8a33 ed 6a		    adc hl,hl 
8a35 ed 52		    sbc hl,de 
8a37 30 01		    jr nc,Div16_NoAdd2 
8a39 19			    add hl,de 
8a3a			Div16_NoAdd2: 
8a3a 10 f6		    djnz Div16_Loop2 
8a3c 17			    rla 
8a3d 2f			    cpl 
8a3e 41			    ld b,c 
8a3f 4f			    ld c,a 
8a40 c9			ret 
8a41			 
8a41			 
8a41			;http://z80-heaven.wikidot.com/math 
8a41			; 
8a41			;Inputs: 
8a41			;     DE and A are factors 
8a41			;Outputs: 
8a41			;     A is not changed 
8a41			;     B is 0 
8a41			;     C is not changed 
8a41			;     DE is not changed 
8a41			;     HL is the product 
8a41			;Time: 
8a41			;     342+6x 
8a41			; 
8a41			Mult16: 
8a41			 
8a41 06 08		     ld b,8          ;7           7 
8a43 21 00 00		     ld hl,0         ;10         10 
8a46 29			       add hl,hl     ;11*8       88 
8a47 07			       rlca          ;4*8        32 
8a48 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
8a4a 19			         add hl,de   ;--         -- 
8a4b 10 f9		       djnz $-5      ;13*7+8     99 
8a4d c9			ret 
8a4e			 
8a4e			; 
8a4e			; Square root of 16-bit value 
8a4e			; In:  HL = value 
8a4e			; Out:  D = result (rounded down) 
8a4e			; 
8a4e			;Sqr16: 
8a4e			;    ld de,#0040 
8a4e			;    ld a,l 
8a4e			;    ld l,h 
8a4e			;    ld h,d 
8a4e			;    or a 
8a4e			;    ld b,8 
8a4e			;Sqr16_Loop: 
8a4e			;    sbc hl,de 
8a4e			;    jr nc,Sqr16_Skip 
8a4e			;    add hl,de 
8a4e			;Sqr16_Skip: 
8a4e			;    ccf 
8a4e			;    rl d 
8a4e			;    add a,a 
8a4e			;    adc hl,hl 
8a4e			;    add a,a 
8a4e			;    adc hl,hl 
8a4e			;    djnz Sqr16_Loop 
8a4e			;    ret 
8a4e			; 
8a4e			; 
8a4e			; Divide 8-bit values 
8a4e			; In: Divide E by divider C 
8a4e			; Out: A = result, B = rest 
8a4e			; 
8a4e			Div8: 
8a4e af			    xor a 
8a4f 06 08		    ld b,8 
8a51			Div8_Loop: 
8a51 cb 13		    rl e 
8a53 17			    rla 
8a54 91			    sub c 
8a55 30 01		    jr nc,Div8_NoAdd 
8a57 81			    add a,c 
8a58			Div8_NoAdd: 
8a58 10 f7		    djnz Div8_Loop 
8a5a 47			    ld b,a 
8a5b 7b			    ld a,e 
8a5c 17			    rla 
8a5d 2f			    cpl 
8a5e c9			    ret 
8a5f			 
8a5f			; 
8a5f			; Multiply 8-bit value with a 16-bit value (unrolled) 
8a5f			; In: Multiply A with DE 
8a5f			; Out: HL = result 
8a5f			; 
8a5f			Mult12U: 
8a5f 2e 00		    ld l,0 
8a61 87			    add a,a 
8a62 30 01		    jr nc,Mult12U_NoAdd0 
8a64 19			    add hl,de 
8a65			Mult12U_NoAdd0: 
8a65 29			    add hl,hl 
8a66 87			    add a,a 
8a67 30 01		    jr nc,Mult12U_NoAdd1 
8a69 19			    add hl,de 
8a6a			Mult12U_NoAdd1: 
8a6a 29			    add hl,hl 
8a6b 87			    add a,a 
8a6c 30 01		    jr nc,Mult12U_NoAdd2 
8a6e 19			    add hl,de 
8a6f			Mult12U_NoAdd2: 
8a6f 29			    add hl,hl 
8a70 87			    add a,a 
8a71 30 01		    jr nc,Mult12U_NoAdd3 
8a73 19			    add hl,de 
8a74			Mult12U_NoAdd3: 
8a74 29			    add hl,hl 
8a75 87			    add a,a 
8a76 30 01		    jr nc,Mult12U_NoAdd4 
8a78 19			    add hl,de 
8a79			Mult12U_NoAdd4: 
8a79 29			    add hl,hl 
8a7a 87			    add a,a 
8a7b 30 01		    jr nc,Mult12U_NoAdd5 
8a7d 19			    add hl,de 
8a7e			Mult12U_NoAdd5: 
8a7e 29			    add hl,hl 
8a7f 87			    add a,a 
8a80 30 01		    jr nc,Mult12U_NoAdd6 
8a82 19			    add hl,de 
8a83			Mult12U_NoAdd6: 
8a83 29			    add hl,hl 
8a84 87			    add a,a 
8a85 d0			    ret nc 
8a86 19			    add hl,de 
8a87 c9			    ret 
8a88			 
8a88			; 
8a88			; Multiply 8-bit value with a 16-bit value (right rotating) 
8a88			; In: Multiply A with DE 
8a88			;      Put lowest value in A for most efficient calculation 
8a88			; Out: HL = result 
8a88			; 
8a88			Mult12R: 
8a88 21 00 00		    ld hl,0 
8a8b			Mult12R_Loop: 
8a8b cb 3f		    srl a 
8a8d 30 01		    jr nc,Mult12R_NoAdd 
8a8f 19			    add hl,de 
8a90			Mult12R_NoAdd: 
8a90 cb 23		    sla e 
8a92 cb 12		    rl d 
8a94 b7			    or a 
8a95 c2 8b 8a		    jp nz,Mult12R_Loop 
8a98 c9			    ret 
8a99			 
8a99			; 
8a99			; Multiply 16-bit values (with 32-bit result) 
8a99			; In: Multiply BC with DE 
8a99			; Out: BCHL = result 
8a99			; 
8a99			Mult32: 
8a99 79			    ld a,c 
8a9a 48			    ld c,b 
8a9b 21 00 00		    ld hl,0 
8a9e 06 10		    ld b,16 
8aa0			Mult32_Loop: 
8aa0 29			    add hl,hl 
8aa1 17			    rla 
8aa2 cb 11		    rl c 
8aa4 30 07		    jr nc,Mult32_NoAdd 
8aa6 19			    add hl,de 
8aa7 ce 00		    adc a,0 
8aa9 d2 ad 8a		    jp nc,Mult32_NoAdd 
8aac 0c			    inc c 
8aad			Mult32_NoAdd: 
8aad 10 f1		    djnz Mult32_Loop 
8aaf 41			    ld b,c 
8ab0 4f			    ld c,a 
8ab1 c9			    ret 
8ab2			 
8ab2			 
8ab2			 
8ab2			; 
8ab2			; Multiply 8-bit values 
8ab2			; In:  Multiply H with E 
8ab2			; Out: HL = result 
8ab2			; 
8ab2			Mult8: 
8ab2 16 00		    ld d,0 
8ab4 6a			    ld l,d 
8ab5 06 08		    ld b,8 
8ab7			Mult8_Loop: 
8ab7 29			    add hl,hl 
8ab8 30 01		    jr nc,Mult8_NoAdd 
8aba 19			    add hl,de 
8abb			Mult8_NoAdd: 
8abb 10 fa		    djnz Mult8_Loop 
8abd c9			    ret 
8abe			 
8abe			 
8abe			 
8abe			 
8abe			 
8abe			 
8abe			 
8abe			 
8abe			;;http://z80-heaven.wikidot.com/math 
8abe			;;This divides DE by BC, storing the result in DE, remainder in HL 
8abe			; 
8abe			;DE_Div_BC:          ;1281-2x, x is at most 16 
8abe			;     ld a,16        ;7 
8abe			;     ld hl,0        ;10 
8abe			;     jp $+5         ;10 
8abe			;.DivLoop: 
8abe			;       add hl,bc    ;-- 
8abe			;       dec a        ;64 
8abe			;       jr z,.DivLoopEnd        ;86 
8abe			; 
8abe			;       sla e        ;128 
8abe			;       rl d         ;128 
8abe			;       adc hl,hl    ;240 
8abe			;       sbc hl,bc    ;240 
8abe			;       jr nc,.DivLoop ;23|21 
8abe			;       inc e        ;-- 
8abe			;       jp .DivLoop+1 
8abe			; 
8abe			;.DivLoopEnd: 
8abe			 
8abe			;HL_Div_C: 
8abe			;Inputs: 
8abe			;     HL is the numerator 
8abe			;     C is the denominator 
8abe			;Outputs: 
8abe			;     A is the remainder 
8abe			;     B is 0 
8abe			;     C is not changed 
8abe			;     DE is not changed 
8abe			;     HL is the quotient 
8abe			; 
8abe			;       ld b,16 
8abe			;       xor a 
8abe			;         add hl,hl 
8abe			;         rla 
8abe			;         cp c 
8abe			;         jr c,$+4 
8abe			;           inc l 
8abe			;           sub c 
8abe			;         djnz $-7 
8abe			 
8abe			; https://plutiedev.com/z80-add-8bit-to-16bit 
8abe			 
8abe			addatohl: 
8abe 85			    add   a, l    ; A = A+L 
8abf 6f			    ld    l, a    ; L = A+L 
8ac0 8c			    adc   a, h    ; A = A+L+H+carry 
8ac1 95			    sub   l       ; A = H+carry 
8ac2 67			    ld    h, a    ; H = H+carry 
8ac3 c9			ret 
8ac4			 
8ac4			addatode: 
8ac4 83			    add   a, e    ; A = A+L 
8ac5 5f			    ld    e, a    ; L = A+L 
8ac6 8a			    adc   a, d    ; A = A+L+H+carry 
8ac7 93			    sub   e       ; A = H+carry 
8ac8 57			    ld    d, a    ; H = H+carry 
8ac9 c9			ret 
8aca			 
8aca			 
8aca			addatobc: 
8aca 81			    add   a, c    ; A = A+L 
8acb 4f			    ld    c, a    ; L = A+L 
8acc 88			    adc   a, b    ; A = A+L+H+carry 
8acd 91			    sub   c       ; A = H+carry 
8ace 47			    ld    b, a    ; H = H+carry 
8acf c9			ret 
8ad0			 
8ad0			subafromhl: 
8ad0			   ; If A=0 do nothing 
8ad0			    ; Otherwise flip A's sign. Since 
8ad0			    ; the upper byte becomes -1, also 
8ad0			    ; substract 1 from H. 
8ad0 ed 44		    neg 
8ad2 ca db 8a		    jp    z, Skip 
8ad5 25			    dec   h 
8ad6			     
8ad6			    ; Now add the low byte as usual 
8ad6			    ; Two's complement takes care of 
8ad6			    ; ensuring the result is correct 
8ad6 85			    add   a, l 
8ad7 6f			    ld    l, a 
8ad8 8c			    adc   a, h 
8ad9 95			    sub   l 
8ada 67			    ld    h, a 
8adb			Skip: 
8adb c9				ret 
8adc			 
8adc			 
8adc			; compare hl and de 
8adc			; returns:  
8adc			; if hl = de, z=1, s=0, c0=0 
8adc			; if hl > de, z=0, s=0, c=0 
8adc			; if hl < de, z=0, s=1, c=1 
8adc			cmp16:	 
8adc b7				or a 
8add ed 52			sbc hl,de 
8adf e0				ret po 
8ae0 7c				ld a,h 
8ae1 1f				rra 
8ae2 ee 40			xor 01000000B 
8ae4 37				scf 
8ae5 8f				adc a,a 
8ae6 c9				ret 
8ae7			 
8ae7			 
8ae7			; test if hl contains zero   - A is destroyed 
8ae7			 
8ae7			ishlzero:    
8ae7 b7				or a     ; reset flags 
8ae8 7c				ld a, h 
8ae9 b5				or l        	 
8aea			 
8aea c9				ret 
8aeb			 
8aeb			 
8aeb			 
8aeb			 
8aeb			if FORTH_ENABLE_FLOATMATH 
8aeb			;include "float/bbcmath.z80" 
8aeb			include "float/lpfpcalc.asm" 
8aeb			endif 
8aeb			 
8aeb			 
8aeb			; eof 
8aeb			 
# End of file firmware_maths.asm
8aeb			include "firmware_strings.asm"   ; string handling  
8aeb			 
8aeb			 
8aeb			; TODO string len 
8aeb			; input text string, end on cr with zero term 
8aeb			; a offset into frame buffer to start prompt 
8aeb			; d is max length 
8aeb			; e is display size TODO 
8aeb			; c is current cursor position 
8aeb			; hl is ptr to where string will be stored 
8aeb			 
8aeb			 
8aeb			; TODO check limit of buffer for new inserts 
8aeb			; TODO check insert does not push beyond buffer 
8aeb			; TODO scroll in a limited display area 
8aeb			; TODO scroll whole screen on page wrap 
8aeb			 
8aeb			 
8aeb			; TODO handle KEY_PREVWORD 
8aeb			; TODO handle KEY_NEXTWORD 
8aeb			; TODO handle KEY_HOME 
8aeb			; TODO handle KEY_END 
8aeb			; TODO use LCD cursor? 
8aeb			 
8aeb 32 73 ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
8aee 81					add c 
8aef 32 71 ee				ld (input_at_cursor),a	; save draw pos of cursor 
8af2 22 76 ee				ld (input_start), hl     ; save ptr to buffer 
8af5 79					ld a, c 
8af6 cd be 8a				call addatohl 
8af9 22 78 ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
8afc 7a					ld a,d 
8afd 32 75 ee			        ld (input_size), a       ; save length of input area 
8b00 79					ld a, c 
8b01 32 64 ee				ld (input_cursor),a      ; init cursor start position  
8b04 7b					ld a,e 
8b05 32 74 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
8b08					 
8b08					 
8b08			 
8b08			;		ld a,(input_ptr) 
8b08			;		ld (input_under_cursor),a 	; save what is under the cursor 
8b08			 
8b08			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
8b08					; init cursor shape if not set by the cin routines 
8b08 21 d3 eb				ld hl, cursor_shape 
8b0b 3e ff				ld a, 255 
8b0d 77					ld (hl), a 
8b0e 23					inc hl 
8b0f 3e 00				ld a, 0 
8b11 77					ld (hl), a 
8b12			 
8b12 3e 0f				ld a, CUR_BLINK_RATE 
8b14 32 6f ee				ld (input_cur_flash), a 
8b17 3e 01				ld a, 1 
8b19 32 6e ee				ld (input_cur_onoff),a 
8b1c			 
8b1c			;	if DEBUG_INPUT 
8b1c			;		push af 
8b1c			;		ld a, 'I' 
8b1c			;		ld (debug_mark),a 
8b1c			;		pop af 
8b1c			;		CALLMONITOR 
8b1c			;	endif 
8b1c			.is1:		; main entry loop 
8b1c			 
8b1c			 
8b1c			 
8b1c					; pause 1ms 
8b1c			 
8b1c 3e 01				ld a, 1 
8b1e cd f3 87				call aDelayInMS 
8b21			 
8b21					; dec flash counter 
8b21 3a 6f ee				ld a, (input_cur_flash) 
8b24 3d					dec a 
8b25 32 6f ee				ld (input_cur_flash), a 
8b28 fe 00				cp 0 
8b2a 20 0d				jr nz, .nochgstate 
8b2c			 
8b2c			 
8b2c					; change state 
8b2c 3a 6e ee				ld a,(input_cur_onoff) 
8b2f ed 44				neg 
8b31 32 6e ee				ld (input_cur_onoff),a 
8b34			 
8b34			 
8b34					; reset on change of state 
8b34 3e 0f				ld a, CUR_BLINK_RATE 
8b36 32 6f ee				ld (input_cur_flash), a 
8b39			 
8b39			.nochgstate: 
8b39					 
8b39					 
8b39			 
8b39					; display cursor  
8b39			 
8b39			;		ld hl, (input_start) 
8b39			;		ld a, (input_cursor) 
8b39			;		call addatohl 
8b39			 
8b39					; get char under cursor and replace with cursor 
8b39 2a 78 ee		ld hl, (input_ptr) 
8b3c			;		ld a, (hl) 
8b3c			;		ld (input_under_cursor),a 
8b3c			;		ld a, '_' 
8b3c			;		ld (hl), a 
8b3c			 
8b3c					; display string 
8b3c			 
8b3c ed 5b 76 ee			ld de, (input_start) 
8b40 3a 73 ee				ld a, (input_at_pos) 
8b43 cd a4 88				call str_at_display 
8b46			;	        call update_display 
8b46			 
8b46					; find place to put the cursor 
8b46			;		add h 
8b46			;		ld l, display_row_1 
8b46			;		sub l 
8b46			; (input_at_pos) 
8b46					;ld c, a 
8b46			;		ld a, (input_cursor) 
8b46			;		ld l, (input_at_pos) 
8b46			;		;ld b, h 
8b46			;		add l 
8b46			;		ld (input_at_cursor),a 
8b46					;ld l,h 
8b46			 
8b46			;		ld h, 0 
8b46			;		ld l,(input_at_pos) 
8b46			;		ld a, (input_cursor) 
8b46			;		call addatohl 
8b46			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
8b46			;		call subafromhl 
8b46			;		ld a,l 
8b46			;		ld (input_at_cursor), a 
8b46			 
8b46				if DEBUG_INPUT 
8b46					ld a, (hardware_diag) 
8b46					cp 0 
8b46					jr z, .skip_input_diag 
8b46			 
8b46					ld a,(input_at_pos) 
8b46					ld hl, LFSRSeed 
8b46					call hexout 
8b46					ld a, (input_cursor) 
8b46					ld hl, LFSRSeed+2 
8b46					call hexout 
8b46					ld a,(input_at_cursor) 
8b46					ld hl, LFSRSeed+4 
8b46					call hexout 
8b46			 
8b46					ld a,(input_cur_onoff) 
8b46					ld hl, LFSRSeed+6 
8b46					call hexout 
8b46			 
8b46					ld a,(input_cur_flash) 
8b46					ld hl, LFSRSeed+8 
8b46					call hexout 
8b46			 
8b46					ld a,(input_len) 
8b46					ld hl, LFSRSeed+10 
8b46					call hexout 
8b46					ld hl, LFSRSeed+12 
8b46					ld a, 0 
8b46					ld (hl),a 
8b46					ld a, display_row_4 
8b46					ld de, LFSRSeed 
8b46					call str_at_display 
8b46					.skip_input_diag: 
8b46				endif 
8b46			 
8b46					; decide on if we are showing the cursor this time round 
8b46			 
8b46 3a 6e ee				ld a, (input_cur_onoff) 
8b49 fe ff				cp 255 
8b4b 28 13				jr z, .skipcur 
8b4d			 
8b4d			 
8b4d 3a 71 ee				ld a,(input_at_cursor) 
8b50 11 d3 eb				ld de, cursor_shape 
8b53 cd a4 88				call str_at_display 
8b56			 
8b56					; save length of current input string 
8b56 2a 76 ee				ld hl, (input_start) 
8b59 cd 1c 8f				call strlenz 
8b5c 7d					ld a,l 
8b5d 32 69 ee				ld (input_len),a 
8b60			 
8b60			.skipcur: 
8b60			 
8b60 cd b4 88			        call update_display 
8b63					 
8b63			 
8b63			 
8b63					; wait 
8b63				 
8b63					; TODO loop without wait to flash the cursor and char under cursor	 
8b63 cd d0 d7				call cin    ; _wait 
8b66			 
8b66 fe 00				cp 0 
8b68 ca 1c 8b				jp z, .is1 
8b6b			 
8b6b					; get ptr to char to input into 
8b6b			 
8b6b 4f					ld c,a 
8b6c 2a 76 ee				ld hl, (input_start) 
8b6f 3a 64 ee				ld a, (input_cursor) 
8b72 cd be 8a				call addatohl 
8b75 22 78 ee				ld (input_ptr), hl 
8b78 79					ld a,c 
8b79			 
8b79					; replace char under cursor 
8b79			 
8b79			;		ld hl, (input_ptr) 
8b79			;		ld a, (input_under_cursor) 	; get what is under the cursor 
8b79			;		ld (hl), a 
8b79			 
8b79			;	if DEBUG_INPUT 
8b79			;		push af 
8b79			;		ld a, 'i' 
8b79			;		ld (debug_mark),a 
8b79			;		pop af 
8b79			;		CALLMONITOR 
8b79			;	endif 
8b79 fe 0e				cp KEY_HOME 
8b7b 20 0e				jr nz, .iske 
8b7d			 
8b7d 3a 73 ee				ld a, (input_at_pos) 
8b80 32 71 ee				ld (input_at_cursor),a 
8b83 3e 00				ld a, 0 
8b85 32 64 ee				ld (input_cursor), a 
8b88 c3 1c 8b				jp .is1 
8b8b					 
8b8b fe 0f		.iske:		cp KEY_END 
8b8d 20 03				jr nz, .isknw 
8b8f c3 1c 8b				jp .is1 
8b92			 
8b92 fe 06		.isknw:		cp KEY_NEXTWORD 
8b94 20 1b				jr nz, .iskpw 
8b96			 
8b96 2a 78 ee		.isknwm:	ld hl, (input_ptr) 
8b99 7e					ld a,(hl)	 
8b9a fe 00				cp 0 
8b9c ca 1c 8b				jp z, .is1    ; end of string 
8b9f fe 20				cp ' ' 
8ba1 ca 1c 8b				jp z, .is1    ; end of word 
8ba4 23					inc hl 
8ba5 22 78 ee				ld (input_ptr), hl 
8ba8 3a 71 ee				ld a, (input_at_cursor) 
8bab 3c					inc a 
8bac 32 71 ee				ld (input_at_cursor), a 
8baf 18 e5				jr .isknwm 
8bb1			 
8bb1 fe 07		.iskpw:		cp KEY_PREVWORD 
8bb3 20 1b				jr nz, .iskl 
8bb5			.iskpwm:	 
8bb5 2a 78 ee				ld hl, (input_ptr) 
8bb8 7e					ld a,(hl)	 
8bb9 fe 00				cp 0  
8bbb ca 1c 8b				jp z, .is1    ; end of string 
8bbe fe 20				cp ' ' 
8bc0 ca 1c 8b				jp z, .is1    ; end of word 
8bc3 2b					dec hl 
8bc4 22 78 ee				ld (input_ptr), hl 
8bc7 3a 71 ee				ld a, (input_at_cursor) 
8bca 3d					dec a 
8bcb 32 71 ee				ld (input_at_cursor), a 
8bce 18 e5				jr .iskpwm 
8bd0			 
8bd0			 
8bd0 fe 0b		.iskl:		cp KEY_LEFT 
8bd2 20 27				jr nz, .isk1 
8bd4			 
8bd4 3a 64 ee				ld a, (input_cursor) 
8bd7			 
8bd7 fe 00				cp 0 
8bd9 ca 1c 8b				jp z, .is1 		; at start of line to ignore  
8bdc			 
8bdc 3d					dec  a 		; TODO check underflow 
8bdd 32 64 ee				ld (input_cursor), a 
8be0			 
8be0 2a 78 ee				ld hl, (input_ptr) 
8be3 2b					dec hl 
8be4 22 78 ee				ld (input_ptr), hl 
8be7					 
8be7 3a 71 ee				ld a, (input_at_cursor) 
8bea 3d					dec a 
8beb 32 71 ee				ld (input_at_cursor), a 
8bee			 
8bee 3e 01				ld a, 1		; show cursor moving 
8bf0 32 6e ee				ld (input_cur_onoff),a 
8bf3 3e 0f				ld a, CUR_BLINK_RATE 
8bf5 32 6f ee				ld (input_cur_flash), a 
8bf8			 
8bf8 c3 1c 8b				jp .is1 
8bfb			 
8bfb fe 0c		.isk1:		cp KEY_RIGHT 
8bfd 20 2a				jr nz, .isk2 
8bff			 
8bff 3a 69 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
8c02 5f					ld e,a 
8c03 3a 64 ee				ld a, (input_cursor) 
8c06 bb					cp e 
8c07 ca 1c 8b				jp z, .is1		; at the end of string so dont go right 
8c0a			 
8c0a 3c					inc  a 		; TODO check overflow 
8c0b 32 64 ee				ld (input_cursor), a 
8c0e			 
8c0e 3a 71 ee				ld a, (input_at_cursor) 
8c11 3c					inc a 
8c12 32 71 ee				ld (input_at_cursor), a 
8c15			 
8c15 2a 78 ee				ld hl, (input_ptr) 
8c18 23					inc hl 
8c19 22 78 ee				ld (input_ptr), hl 
8c1c			 
8c1c 3e 01				ld a, 1		; show cursor moving 
8c1e 32 6e ee				ld (input_cur_onoff),a 
8c21 3e 0f				ld a, CUR_BLINK_RATE 
8c23 32 6f ee				ld (input_cur_flash), a 
8c26			 
8c26 c3 1c 8b				jp .is1 
8c29			 
8c29 fe 05		.isk2:		cp KEY_UP 
8c2b			 
8c2b 20 26				jr nz, .isk3 
8c2d			 
8c2d					; swap last command with the current on 
8c2d			 
8c2d					; move cursor to start of string 
8c2d 2a 76 ee				ld hl, (input_start) 
8c30 22 78 ee				ld (input_ptr), hl 
8c33			 
8c33 3a 73 ee				ld a, (input_at_pos) 
8c36 32 71 ee				ld (input_at_cursor), a 
8c39			 
8c39 3e 00				ld a, 0 
8c3b 32 64 ee				ld (input_cursor), a 
8c3e					 
8c3e					; swap input and last command buffers 
8c3e			 
8c3e 21 87 e6				ld hl, os_cli_cmd 
8c41 11 86 e7				ld de, os_last_cmd 
8c44 06 ff				ld b, 255 
8c46 7e			.swap1:		ld a, (hl) 
8c47 4f					ld c,a 
8c48 1a					ld a, (de) 
8c49 77					ld (hl), a 
8c4a 79					ld a,c 
8c4b 12					ld (de),a 
8c4c 23					inc hl 
8c4d 13					inc de 
8c4e 10 f6				djnz .swap1 
8c50			 
8c50			 
8c50			 
8c50			 
8c50			 
8c50 c3 1c 8b				jp .is1 
8c53			 
8c53 fe 08		.isk3:		cp KEY_BS 
8c55 20 3c				jr nz, .isk4 
8c57			 
8c57 3a 64 ee				ld a, (input_cursor) 
8c5a			 
8c5a fe 00				cp 0 
8c5c ca 1c 8b				jp z, .is1 		; at start of line to ignore  
8c5f			 
8c5f 3d					dec  a 		; TODO check underflow 
8c60 32 64 ee				ld (input_cursor), a 
8c63			 
8c63					; hl is source 
8c63					; de needs to be source - 1 
8c63			 
8c63			;		ld a, 0 
8c63			;		dec hl 
8c63			;		ld (hl), a 
8c63			 
8c63 2a 78 ee				ld hl, (input_ptr) 
8c66 2b					dec hl 
8c67 22 78 ee				ld (input_ptr), hl 
8c6a			 
8c6a					; shift all data 
8c6a			 
8c6a e5					push hl 
8c6b 23					inc hl 
8c6c d1					pop de 
8c6d 3a 69 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
8c70 4f					ld c,a 
8c71 06 00				ld b,0 
8c73 ed b0				ldir  
8c75			 
8c75			 
8c75			 
8c75			 
8c75 3a 71 ee				ld a, (input_at_cursor) 
8c78 3d					dec a 
8c79 32 71 ee				ld (input_at_cursor), a 
8c7c			 
8c7c			 
8c7c 3e 01				ld a, 1		; show cursor moving 
8c7e 32 6e ee				ld (input_cur_onoff),a 
8c81 3e 0f				ld a, CUR_BLINK_RATE 
8c83 32 6f ee				ld (input_cur_flash), a 
8c86			 
8c86					; remove char 
8c86 3a 71 ee				ld a, (input_at_cursor) 
8c89 3c					inc a 
8c8a 11 14 8d				ld de,.iblank 
8c8d cd a4 88				call str_at_display 
8c90			 
8c90 c3 1c 8b				jp .is1 
8c93			 
8c93 fe 0d		.isk4:		cp KEY_CR 
8c95 28 6c				jr z, .endinput 
8c97			 
8c97					; else add the key press to the end 
8c97			 
8c97 4f					ld c, a			; save key pressed 
8c98			 
8c98 7e					ld a,(hl)		; get what is currently under char 
8c99			 
8c99 fe 00				cp 0			; we are at the end of the string 
8c9b 20 2f				jr nz, .onchar 
8c9d					 
8c9d					; add a char to the end of the string 
8c9d				 
8c9d 71					ld (hl),c 
8c9e 23					inc hl 
8c9f			;		ld a,' ' 
8c9f			;		ld (hl),a 
8c9f			;		inc hl 
8c9f 3e 00				ld a,0 
8ca1 77					ld (hl),a 
8ca2 2b					dec hl 
8ca3			 
8ca3 3a 64 ee				ld a, (input_cursor) 
8ca6 3c					inc a				; TODO check max string length and scroll  
8ca7 32 64 ee				ld (input_cursor), a		; inc cursor pos 
8caa							 
8caa 3a 71 ee				ld a, (input_at_cursor) 
8cad 3c					inc a 
8cae 32 71 ee				ld (input_at_cursor), a 
8cb1			 
8cb1 2a 78 ee				ld hl, (input_ptr) 
8cb4 23					inc hl 
8cb5 22 78 ee				ld (input_ptr), hl 
8cb8			 
8cb8 2a 78 ee				ld hl, (input_ptr) 
8cbb 23					inc hl 
8cbc 22 78 ee				ld (input_ptr), hl 
8cbf			;	if DEBUG_INPUT 
8cbf			;		push af 
8cbf			;		ld a, '+' 
8cbf			;		ld (debug_mark),a 
8cbf			;		pop af 
8cbf			;		CALLMONITOR 
8cbf			;	endif 
8cbf 3e 01				ld a, 1		; show cursor moving 
8cc1 32 6e ee				ld (input_cur_onoff),a 
8cc4 3e 0f				ld a, CUR_BLINK_RATE 
8cc6 32 6f ee				ld (input_cur_flash), a 
8cc9 c3 1c 8b				jp .is1 
8ccc					 
8ccc			 
8ccc			 
8ccc					; if on a char then insert 
8ccc			.onchar: 
8ccc			 
8ccc					; TODO over flow check: make sure insert does not blow out buffer 
8ccc			 
8ccc					; need to do some maths to use lddr 
8ccc			 
8ccc e5					push hl   ; save char pos 
8ccd c5					push bc 
8cce			 
8cce 2a 76 ee				ld hl, (input_start) 
8cd1 3a 69 ee				ld a, (input_len) 
8cd4 cd be 8a				call addatohl  		; end of string 
8cd7 23					inc hl 
8cd8 23					inc hl		; past zero term 
8cd9 e5					push hl 
8cda 23					inc hl 
8cdb e5					push hl  
8cdc			 
8cdc								; start and end of lddr set, now how much to move? 
8cdc			 
8cdc							 
8cdc 3a 64 ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
8cdf 47					ld b,a 
8ce0 3a 69 ee				ld a,(input_len) 
8ce3 5f					ld e,a 
8ce4 90					sub b 
8ce5 3c					inc a		;?? 
8ce6 3c					inc a		;?? 
8ce7 3c					inc a		;?? 
8ce8			 
8ce8 06 00				ld b,0 
8cea 4f					ld c,a 
8ceb			 
8ceb				if DEBUG_INPUT 
8ceb					push af 
8ceb					ld a, 'i' 
8ceb					ld (debug_mark),a 
8ceb					pop af 
8ceb			;		CALLMONITOR 
8ceb				endif 
8ceb d1					pop de 
8cec e1					pop hl 
8ced				if DEBUG_INPUT 
8ced					push af 
8ced					ld a, 'I' 
8ced					ld (debug_mark),a 
8ced					pop af 
8ced			;		CALLMONITOR 
8ced				endif 
8ced ed b8				lddr 
8cef				 
8cef			 
8cef			 
8cef					; TODO have a key for insert/overwrite mode???? 
8cef c1					pop bc 
8cf0 e1					pop hl 
8cf1 71					ld (hl), c		; otherwise overwrite current char 
8cf2					 
8cf2			 
8cf2			 
8cf2			 
8cf2 3a 64 ee				ld a, (input_cursor) 
8cf5 3c					inc  a 		; TODO check overflow 
8cf6 32 64 ee				ld (input_cursor), a 
8cf9			 
8cf9 3a 71 ee				ld a, (input_at_cursor) 
8cfc 3c					inc a 
8cfd 32 71 ee				ld (input_at_cursor), a 
8d00			 
8d00 c3 1c 8b				jp .is1 
8d03			 
8d03			.endinput:	; TODO look for end of string 
8d03			 
8d03					; add trailing space for end of token 
8d03			 
8d03 2a 76 ee				ld hl, (input_start) 
8d06 3a 69 ee				ld a,(input_len) 
8d09 cd be 8a				call addatohl 
8d0c 3e 20				ld a, ' ' 
8d0e 77					ld (hl),a 
8d0f					; TODO eof of parse marker 
8d0f			 
8d0f 23					inc hl 
8d10 3e 00				ld a, 0 
8d12 77					ld (hl),a 
8d13			 
8d13			 
8d13 c9					ret 
8d14			 
8d14 .. 00		.iblank: db " ",0 
8d16			 
8d16			 
8d16 32 73 ee		input_str_prev:	ld (input_at_pos), a 
8d19 22 76 ee				ld (input_start), hl 
8d1c 3e 01				ld a,1			; add cursor 
8d1e 77					ld (hl),a 
8d1f 23					inc hl 
8d20 3e 00				ld a,0 
8d22 77					ld (hl),a 
8d23 22 78 ee				ld (input_ptr), hl 
8d26 7a					ld a,d 
8d27 32 75 ee				ld (input_size), a 
8d2a 3e 00				ld a,0 
8d2c 32 64 ee				ld (input_cursor),a 
8d2f			.instr1:	 
8d2f			 
8d2f					; TODO do block cursor 
8d2f					; TODO switch cursor depending on the modifer key 
8d2f			 
8d2f					; update cursor shape change on key hold 
8d2f			 
8d2f 2a 78 ee				ld hl, (input_ptr) 
8d32 2b					dec hl 
8d33 3a d3 eb				ld a,(cursor_shape) 
8d36 77					ld (hl), a 
8d37			 
8d37					; display entered text 
8d37 3a 73 ee				ld a,(input_at_pos) 
8d3a cd 2e d7		            	CALL fLCD_Pos       ;Position cursor to location in A 
8d3d ed 5b 76 ee	            	LD   de, (input_start) 
8d41 cd 28 d7		            	CALL fLCD_Str       ;Display string pointed to by DE 
8d44			 
8d44 cd d0 d7				call cin 
8d47 fe 00				cp 0 
8d49 28 e4				jr z, .instr1 
8d4b			 
8d4b					; proecess keyboard controls first 
8d4b			 
8d4b 2a 78 ee				ld hl,(input_ptr) 
8d4e			 
8d4e fe 0d				cp KEY_CR	 ; pressing enter ends input 
8d50 28 5a				jr z, .instrcr 
8d52			 
8d52 fe 08				cp KEY_BS 	; back space 
8d54 20 0f				jr nz, .instr2 
8d56					; process back space 
8d56			 
8d56					; TODO stop back space if at start of string 
8d56 2b					dec hl 
8d57 2b					dec hl ; to over write cursor 
8d58 3a d3 eb				ld a,(cursor_shape) 
8d5b					;ld a,0 
8d5b 77					ld (hl),a 
8d5c 23					inc hl 
8d5d 3e 20				ld a," " 
8d5f 77					ld (hl),a 
8d60 22 78 ee				ld (input_ptr),hl 
8d63					 
8d63			 
8d63 18 ca				jr .instr1 
8d65			 
8d65 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
8d67 20 06				jr nz, .instr3 
8d69 2b					dec hl 
8d6a 22 78 ee				ld (input_ptr),hl 
8d6d 18 c0				jr .instr1 
8d6f				 
8d6f fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
8d71 20 06				jr nz, .instr4 
8d73 23					inc hl 
8d74 22 78 ee				ld (input_ptr),hl 
8d77 18 b6				jr .instr1 
8d79			 
8d79 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
8d7b 20 06				jr nz, .instr5 
8d7d 2b					dec hl 
8d7e 22 78 ee				ld (input_ptr),hl 
8d81 18 ac				jr .instr1 
8d83			 
8d83 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
8d85 20 06				jr nz, .instr6 
8d87 2b					dec hl 
8d88 22 78 ee				ld (input_ptr),hl 
8d8b 18 a2				jr .instr1 
8d8d fe 05		.instr6:        cp KEY_UP      ; recall last command 
8d8f 20 0b				jr nz, .instrnew 
8d91			 
8d91 21 60 e3			ld hl, scratch 
8d94 11 86 e7			ld de, os_last_cmd 
8d97 cd b5 8d			call strcpy 
8d9a 18 93				jr .instr1 
8d9c			 
8d9c			 
8d9c			.instrnew:	; no special key pressed to see if we have room to store it 
8d9c			 
8d9c					; TODO do string size test 
8d9c			 
8d9c 2b					dec hl ; to over write cursor 
8d9d 77					ld (hl),a 
8d9e 23					inc hl 
8d9f 3a d3 eb				ld a,(cursor_shape) 
8da2 77					ld (hl),a 
8da3 23					inc hl 
8da4 3e 00				ld a,0 
8da6 77					ld (hl),a 
8da7			 
8da7 22 78 ee				ld (input_ptr),hl 
8daa					 
8daa 18 83				jr .instr1 
8dac 2b			.instrcr:	dec hl		; remove cursor 
8dad 3e 20				ld a,' '	; TODO add a trailing space for safety 
8daf 77					ld (hl),a 
8db0 23					inc hl 
8db1 3e 00				ld a,0 
8db3 77					ld (hl),a 
8db4			 
8db4			 
8db4					; if at end of line scroll up    
8db4					; TODO detecting only end of line 4 for scroll up  
8db4			 
8db4					;ld   
8db4			 
8db4 c9					ret 
8db5			 
8db5			 
8db5			; strcpy hl = dest, de source 
8db5			 
8db5 1a			strcpy:   LD   A, (DE)        ;Get character from string 
8db6 b7			            OR   A              ;Null terminator? 
8db7 c8			            RET  Z              ;Yes, so finished 
8db8 1a					ld a,(de) 
8db9 77					ld (hl),a 
8dba 13			            INC  DE             ;Point to next character 
8dbb 23					inc hl 
8dbc 18 f7		            JR   strcpy       ;Repeat 
8dbe c9					ret 
8dbf			 
8dbf			 
8dbf			; TODO string_at  
8dbf			; pass string which starts with lcd offset address and then null term string 
8dbf			 
8dbf			; TODO string to dec 
8dbf			; TODO string to hex 
8dbf			; TODO byte to string hex 
8dbf			; TODO byte to string dec 
8dbf			 
8dbf			 
8dbf			 
8dbf			; from z80uartmonitor 
8dbf			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dbf			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
8dbf			; pass hl for where to put the text 
8dbf			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dbf c5			hexout:	PUSH BC 
8dc0 f5					PUSH AF 
8dc1 47					LD B, A 
8dc2					; Upper nybble 
8dc2 cb 3f				SRL A 
8dc4 cb 3f				SRL A 
8dc6 cb 3f				SRL A 
8dc8 cb 3f				SRL A 
8dca cd da 8d				CALL tohex 
8dcd 77					ld (hl),a 
8dce 23					inc hl	 
8dcf					 
8dcf					; Lower nybble 
8dcf 78					LD A, B 
8dd0 e6 0f				AND 0FH 
8dd2 cd da 8d				CALL tohex 
8dd5 77					ld (hl),a 
8dd6 23					inc hl	 
8dd7					 
8dd7 f1					POP AF 
8dd8 c1					POP BC 
8dd9 c9					RET 
8dda					 
8dda			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dda			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
8dda			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
8dda			tohex: 
8dda e5					PUSH HL 
8ddb d5					PUSH DE 
8ddc 16 00				LD D, 0 
8dde 5f					LD E, A 
8ddf 21 e7 8d				LD HL, .DATA 
8de2 19					ADD HL, DE 
8de3 7e					LD A, (HL) 
8de4 d1					POP DE 
8de5 e1					POP HL 
8de6 c9					RET 
8de7			 
8de7			.DATA: 
8de7 30					DEFB	30h	; 0 
8de8 31					DEFB	31h	; 1 
8de9 32					DEFB	32h	; 2 
8dea 33					DEFB	33h	; 3 
8deb 34					DEFB	34h	; 4 
8dec 35					DEFB	35h	; 5 
8ded 36					DEFB	36h	; 6 
8dee 37					DEFB	37h	; 7 
8def 38					DEFB	38h	; 8 
8df0 39					DEFB	39h	; 9 
8df1 41					DEFB	41h	; A 
8df2 42					DEFB	42h	; B 
8df3 43					DEFB	43h	; C 
8df4 44					DEFB	44h	; D 
8df5 45					DEFB	45h	; E 
8df6 46					DEFB	46h	; F 
8df7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8df7			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
8df7			;;    subtract $30, if result > 9 then subtract $7 more 
8df7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
8df7			atohex: 
8df7 d6 30				SUB $30 
8df9 fe 0a				CP 10 
8dfb f8					RET M		; If result negative it was 0-9 so we're done 
8dfc d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
8dfe c9					RET		 
8dff			 
8dff			 
8dff			 
8dff			 
8dff			; Get 2 ASCII characters as hex byte from pointer in hl 
8dff			 
8dff			BYTERD: 
8dff 16 00			LD	D,00h		;Set up 
8e01 cd 09 8e			CALL	HEXCON		;Get byte and convert to hex 
8e04 87				ADD	A,A		;First nibble so 
8e05 87				ADD	A,A		;multiply by 16 
8e06 87				ADD	A,A		; 
8e07 87				ADD	A,A		; 
8e08 57				LD	D,A		;Save hi nibble in D 
8e09			HEXCON: 
8e09 7e				ld a, (hl)		;Get next chr 
8e0a 23				inc hl 
8e0b d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
8e0d fe 0a			CP	00Ah		;Is it 0-9 ? 
8e0f 38 02			JR	C,NALPHA	;If so miss next bit 
8e11 d6 07			SUB	007h		;Else convert alpha 
8e13			NALPHA: 
8e13 b2				OR	D		;Add hi nibble back 
8e14 c9				RET			; 
8e15			 
8e15			 
8e15			; 
8e15			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
8e15			; Since the routines get_byte and therefore get_nibble are called, only valid 
8e15			; characters (0-9a-f) are accepted. 
8e15			; 
8e15			;get_word        push    af 
8e15			;                call    get_byte        ; Get the upper byte 
8e15			;                ld      h, a 
8e15			;                call    get_byte        ; Get the lower byte 
8e15			;                ld      l, a 
8e15			;                pop     af 
8e15			;                ret 
8e15			; 
8e15			; Get a byte in hexadecimal notation. The result is returned in A. Since 
8e15			; the routine get_nibble is used only valid characters are accepted - the  
8e15			; input routine only accepts characters 0-9a-f. 
8e15			; 
8e15 c5			get_byte:        push    bc              ; Save contents of B (and C) 
8e16 7e					ld a,(hl) 
8e17 23					inc hl 
8e18 cd 3d 8e		                call    nibble2val      ; Get upper nibble 
8e1b cb 07		                rlc     a 
8e1d cb 07		                rlc     a 
8e1f cb 07		                rlc     a 
8e21 cb 07		                rlc     a 
8e23 47			                ld      b, a            ; Save upper four bits 
8e24 7e					ld a,(hl) 
8e25 cd 3d 8e		                call    nibble2val      ; Get lower nibble 
8e28 b0			                or      b               ; Combine both nibbles 
8e29 c1			                pop     bc              ; Restore B (and C) 
8e2a c9			                ret 
8e2b			; 
8e2b			; Get a hexadecimal digit from the serial line. This routine blocks until 
8e2b			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
8e2b			; to the serial line interface. The lower 4 bits of A contain the value of  
8e2b			; that particular digit. 
8e2b			; 
8e2b			;get_nibble      ld a,(hl)           ; Read a character 
8e2b			;                call    to_upper        ; Convert to upper case 
8e2b			;                call    is_hex          ; Was it a hex digit? 
8e2b			;                jr      nc, get_nibble  ; No, get another character 
8e2b			 ;               call    nibble2val      ; Convert nibble to value 
8e2b			 ;               call    print_nibble 
8e2b			 ;               ret 
8e2b			; 
8e2b			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
8e2b			; A valid hexadecimal digit is denoted by a set C flag. 
8e2b			; 
8e2b			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
8e2b			;                ret     nc              ; Yes 
8e2b			;                cp      '0'             ; Less than '0'? 
8e2b			;                jr      nc, is_hex_1    ; No, continue 
8e2b			;                ccf                     ; Complement carry (i.e. clear it) 
8e2b			;                ret 
8e2b			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
8e2b			;                ret     c               ; Yes 
8e2b			;                cp      'A'             ; Less than 'A'? 
8e2b			;                jr      nc, is_hex_2    ; No, continue 
8e2b			;                ccf                     ; Yes - clear carry and return 
8e2b			;                ret 
8e2b			;is_hex_2        scf                     ; Set carry 
8e2b			;                ret 
8e2b			; 
8e2b			; Convert a single character contained in A to upper case: 
8e2b			; 
8e2b fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
8e2d d8			                ret     c 
8e2e fe 7b		                cp      'z' + 1         ; > 'z'? 
8e30 d0			                ret     nc              ; Nothing to do, either 
8e31 e6 5f		                and     $5f             ; Convert to upper case 
8e33 c9			                ret 
8e34			 
8e34			 
8e34			to_lower: 
8e34			 
8e34			   ; if char is in [A-Z] make it lower case 
8e34			 
8e34			   ; enter : a = char 
8e34			   ; exit  : a = lower case char 
8e34			   ; uses  : af 
8e34			 
8e34 fe 41		   cp 'A' 
8e36 d8			   ret c 
8e37			    
8e37 fe 5b		   cp 'Z'+1 
8e39 d0			   ret nc 
8e3a			    
8e3a f6 20		   or $20 
8e3c c9			   ret 
8e3d			 
8e3d			; 
8e3d			; Expects a hexadecimal digit (upper case!) in A and returns the 
8e3d			; corresponding value in A. 
8e3d			; 
8e3d fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
8e3f 38 02		                jr      c, nibble2val_1 ; Yes 
8e41 d6 07		                sub     7               ; Adjust for A-F 
8e43 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
8e45 e6 0f		                and     $f              ; Only return lower 4 bits 
8e47 c9			                ret 
8e48			; 
8e48			; Print_nibble prints a single hex nibble which is contained in the lower  
8e48			; four bits of A: 
8e48			; 
8e48			;print_nibble    push    af              ; We won't destroy the contents of A 
8e48			;                and     $f              ; Just in case... 
8e48			;                add     a, '0'             ; If we have a digit we are done here. 
8e48			;                cp      '9' + 1         ; Is the result > 9? 
8e48			;                jr      c, print_nibble_1 
8e48			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
8e48			;print_nibble_1  call    putc            ; Print the nibble and 
8e48			;                pop     af              ; restore the original value of A 
8e48			;                ret 
8e48			;; 
8e48			;; Send a CR/LF pair: 
8e48			; 
8e48			;crlf            push    af 
8e48			;                ld      a, cr 
8e48			;                call    putc 
8e48			;                ld      a, lf 
8e48			;                call    putc 
8e48			;                pop     af 
8e48			;                ret 
8e48			; 
8e48			; Print_word prints the four hex digits of a word to the serial line. The  
8e48			; word is expected to be in HL. 
8e48			; 
8e48			;print_word      push    hl 
8e48			;                push    af 
8e48			;                ld      a, h 
8e48			;                call    print_byte 
8e48			;                ld      a, l 
8e48			;                call    print_byte 
8e48			;                pop     af 
8e48			;                pop     hl 
8e48			;                ret 
8e48			; 
8e48			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
8e48			; The byte to be printed is expected to be in A. 
8e48			; 
8e48			;print_byte      push    af              ; Save the contents of the registers 
8e48			;                push    bc 
8e48			;                ld      b, a 
8e48			;                rrca 
8e48			;                rrca 
8e48			;                rrca 
8e48			;                rrca 
8e48			;                call    print_nibble    ; Print high nibble 
8e48			;                ld      a, b 
8e48			;                call    print_nibble    ; Print low nibble 
8e48			;                pop     bc              ; Restore original register contents 
8e48			;                pop     af 
8e48			;                ret 
8e48			 
8e48			 
8e48			 
8e48			 
8e48			 
8e48			fourehexhl:  
8e48 7e				ld a,(hl) 
8e49 cd f7 8d			call atohex 
8e4c cb 3f				SRL A 
8e4e cb 3f				SRL A 
8e50 cb 3f				SRL A 
8e52 cb 3f				SRL A 
8e54 47				ld b, a 
8e55 23				inc hl 
8e56 7e				ld a,(hl) 
8e57 23				inc hl 
8e58 cd f7 8d			call atohex 
8e5b 80				add b 
8e5c 57				ld d,a 
8e5d 7e				ld a,(hl) 
8e5e cd f7 8d			call atohex 
8e61 cb 3f				SRL A 
8e63 cb 3f				SRL A 
8e65 cb 3f				SRL A 
8e67 cb 3f				SRL A 
8e69 47				ld b, a 
8e6a 23				inc hl 
8e6b 7e				ld a,(hl) 
8e6c 23				inc hl 
8e6d cd f7 8d			call atohex 
8e70 80				add b 
8e71 5f				ld e, a 
8e72 d5				push de 
8e73 e1				pop hl 
8e74 c9				ret 
8e75			 
8e75			; pass hl. returns z set if the byte at hl is a digit 
8e75			;isdigithl:  
8e75			;	push bc 
8e75			;	ld a,(hl) 
8e75			;	cp ':' 
8e75			;	jr nc, .isdf 		; > 
8e75			;	cp '0' 
8e75			;	jr c, .isdf		; < 
8e75			; 
8e75			;	; TODO find a better way to set z 
8e75			; 
8e75			;	ld b,a 
8e75			;	cp b 
8e75			;	pop bc 
8e75			;	ret 
8e75			; 
8e75			;.isdf:	; not digit so clear z 
8e75			; 
8e75			;	; TODO find a better way to unset z 
8e75			; 
8e75			;	ld b,a 
8e75			;	inc b 
8e75			;	cp b 
8e75			; 
8e75			;	pop bc 
8e75			;	ret 
8e75				 
8e75				 
8e75			 
8e75			 
8e75			; pass hl as the four byte address to load 
8e75			 
8e75			get_word_hl:  
8e75 e5				push hl 
8e76 cd 15 8e			call get_byte 
8e79				 
8e79 47				ld b, a 
8e7a			 
8e7a e1				pop hl 
8e7b 23				inc hl 
8e7c 23				inc hl 
8e7d			 
8e7d			; TODO not able to handle a-f  
8e7d 7e				ld a,(hl) 
8e7e			;	;cp ':' 
8e7e			;	cp 'g' 
8e7e			;	jr nc, .single_byte_hl 		; > 
8e7e			;	cp 'G' 
8e7e			;	jr nc, .single_byte_hl 		; > 
8e7e			;	cp '0' 
8e7e			;	jr c, .single_byte_hl		; < 
8e7e			 
8e7e				;call isdigithl 
8e7e fe 00			cp 0 
8e80 28 06			jr z, .single_byte_hl 
8e82			 
8e82			.getwhln:   ; hex word so get next byte 
8e82			 
8e82 cd 15 8e			call get_byte 
8e85 6f				ld l, a 
8e86 60				ld h,b 
8e87 c9				ret 
8e88 68			.single_byte_hl:   ld l,b 
8e89 26 00				ld h,0 
8e8b c9					ret 
8e8c			 
8e8c			 
8e8c			 
8e8c			 
8e8c 21 10 96			ld hl,asc+1 
8e8f			;	ld a, (hl) 
8e8f			;	call nibble2val 
8e8f cd 15 8e			call get_byte 
8e92			 
8e92			;	call fourehexhl 
8e92 32 94 e3			ld (scratch+52),a 
8e95				 
8e95 21 92 e3			ld hl,scratch+50 
8e98 22 83 e6			ld (os_cur_ptr),hl 
8e9b			 
8e9b c9				ret 
8e9c			 
8e9c			 
8e9c			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
8e9c			 
8e9c			; Decimal Unsigned Version 
8e9c			 
8e9c			;Number in a to decimal ASCII 
8e9c			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
8e9c			;Example: display a=56 as "056" 
8e9c			;input: a = number 
8e9c			;Output: a=0,value of a in the screen 
8e9c			;destroys af,bc (don't know about hl and de) 
8e9c			DispAToASCII: 
8e9c 0e 9c			ld	c,-100 
8e9e cd a8 8e			call	.Na1 
8ea1 0e f6			ld	c,-10 
8ea3 cd a8 8e			call	.Na1 
8ea6 0e ff			ld	c,-1 
8ea8 06 2f		.Na1:	ld	b,'0'-1 
8eaa 04			.Na2:	inc	b 
8eab 81				add	a,c 
8eac 38 fc			jr	c,.Na2 
8eae 91				sub	c		;works as add 100/10/1 
8eaf f5				push af		;safer than ld c,a 
8eb0 78				ld	a,b		;char is in b 
8eb1			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
8eb1 f1				pop af		;safer than ld a,c 
8eb2 c9				ret 
8eb3			 
8eb3			; Decimal Signed Version 
8eb3			 
8eb3			; DispA 
8eb3			; -------------------------------------------------------------- 
8eb3			; Converts a signed integer value to a zero-terminated ASCII 
8eb3			; string representative of that value (using radix 10). 
8eb3			; -------------------------------------------------------------- 
8eb3			; INPUTS: 
8eb3			;     HL     Value to convert (two's complement integer). 
8eb3			;     DE     Base address of string destination. (pointer). 
8eb3			; -------------------------------------------------------------- 
8eb3			; OUTPUTS: 
8eb3			;     None 
8eb3			; -------------------------------------------------------------- 
8eb3			; REGISTERS/MEMORY DESTROYED 
8eb3			; AF HL 
8eb3			; -------------------------------------------------------------- 
8eb3			 
8eb3			;DispHLToASCII: 
8eb3			;   push    de 
8eb3			;   push    bc 
8eb3			; 
8eb3			;; Detect sign of HL. 
8eb3			;    bit    7, h 
8eb3			;    jr     z, ._DoConvert 
8eb3			; 
8eb3			;; HL is negative. Output '-' to string and negate HL. 
8eb3			;    ld     a, '-' 
8eb3			;    ld     (de), a 
8eb3			;    inc    de 
8eb3			; 
8eb3			;; Negate HL (using two's complement) 
8eb3			;    xor    a 
8eb3			;    sub    l 
8eb3			;    ld     l, a 
8eb3			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
8eb3			;    sbc    a, h 
8eb3			;    ld     h, a 
8eb3			; 
8eb3			;; Convert HL to digit characters 
8eb3			;._DoConvert: 
8eb3			;    ld     b, 0     ; B will count character length of number 
8eb3			;-   ld     a, 10 
8eb3			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
8eb3			;    push   af 
8eb3			;    inc    b 
8eb3			;    ld     a, h 
8eb3			;    or     l 
8eb3			;    jr     nz, - 
8eb3			; 
8eb3			;; Retrieve digits from stack 
8eb3			;-   pop    af 
8eb3			;    or     $30 
8eb3			;    ld     (de), a 
8eb3			;    inc    de 
8eb3			;    djnz   - 
8eb3			; 
8eb3			;; Terminate string with NULL 
8eb3			;    xor    a 
8eb3			;    ld     (de), a 
8eb3			; 
8eb3			;    pop    bc 
8eb3			;    pop    de 
8eb3			;    ret 
8eb3			 
8eb3			;Comments 
8eb3			; 
8eb3			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
8eb3			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
8eb3			;    Note that the output string will not be fixed-width. 
8eb3			; 
8eb3			;Example Usage 
8eb3			; 
8eb3			;    ld    hl, -1004 
8eb3			;    ld    de, OP1 
8eb3			;    call  DispA 
8eb3			;    ld    hl, OP1 
8eb3			;    syscall  PutS 
8eb3			 
8eb3			 
8eb3			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8eb3			 
8eb3			 
8eb3			;Converts an ASCII string to an unsigned 16-bit integer 
8eb3			;Quits when it reaches a non-decimal digit 
8eb3			 
8eb3			string_to_uint16: 
8eb3			atoui_16: 
8eb3			;Input: 
8eb3			;     DE points to the string 
8eb3			;Outputs: 
8eb3			;     HL is the result 
8eb3			;     A is the 8-bit value of the number 
8eb3			;     DE points to the byte after the number 
8eb3			;Destroys: 
8eb3			;     BC 
8eb3			;       if the string is non-empty, BC is HL/10 
8eb3			;Size:  24 bytes 
8eb3			;Speed: 42+d(104+{0,9}) 
8eb3			;       d is the number of digits in the number 
8eb3			;       max is 640 cycles for a 5 digit number 
8eb3			;Assuming no leading zeros: 
8eb3			;1 digit:  146cc 
8eb3			;2 digit:  250cc 
8eb3			;3 digit:  354cc or 363cc (avg: 354.126cc) 
8eb3			;4 digit:  458cc or 467cc (avg: 458.27cc) 
8eb3			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
8eb3			;avg: 544.81158447265625cc (544+13297/16384) 
8eb3			;=============================================================== 
8eb3 21 00 00		  ld hl,0 
8eb6			.u16a: 
8eb6 1a			  ld a,(de) 
8eb7 d6 30		  sub 30h 
8eb9 fe 0a		  cp 10 
8ebb d0			  ret nc 
8ebc 13			  inc de 
8ebd 44			  ld b,h 
8ebe 4d			  ld c,l 
8ebf 29			  add hl,hl 
8ec0 29			  add hl,hl 
8ec1 09			  add hl,bc 
8ec2 29			  add hl,hl 
8ec3 85			  add a,l 
8ec4 6f			  ld l,a 
8ec5 30 ef		  jr nc,.u16a 
8ec7 24			  inc h 
8ec8 c3 b6 8e		  jp .u16a 
8ecb			 
8ecb			 
8ecb			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
8ecb			 
8ecb			;written by Zeda 
8ecb			;Converts a 16-bit unsigned integer to an ASCII string. 
8ecb			 
8ecb			uitoa_16: 
8ecb			;Input: 
8ecb			;   DE is the number to convert 
8ecb			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
8ecb			;Output: 
8ecb			;   HL points to the null-terminated ASCII string 
8ecb			;      NOTE: This isn't necessarily the same as the input HL. 
8ecb d5			  push de 
8ecc c5			  push bc 
8ecd f5			  push af 
8ece eb			  ex de,hl 
8ecf			 
8ecf 01 f0 d8		  ld bc,-10000 
8ed2 3e 2f		  ld a,'0'-1 
8ed4 3c			  inc a 
8ed5 09			  add hl,bc  
8ed6 38 fc		   jr c,$-2 
8ed8 12			  ld (de),a 
8ed9 13			  inc de 
8eda			 
8eda 01 e8 03		  ld bc,1000 
8edd 3e 3a		  ld a,'9'+1 
8edf 3d			  dec a  
8ee0 09			  add hl,bc  
8ee1 30 fc		   jr nc,$-2 
8ee3 12			  ld (de),a 
8ee4 13			  inc de 
8ee5			 
8ee5 01 9c ff		  ld bc,-100 
8ee8 3e 2f		  ld a,'0'-1 
8eea 3c			  inc a  
8eeb 09			  add hl,bc  
8eec 38 fc		   jr c,$-2 
8eee 12			  ld (de),a 
8eef 13			  inc de 
8ef0			 
8ef0 7d			  ld a,l 
8ef1 26 3a		  ld h,'9'+1 
8ef3 25			  dec h  
8ef4 c6 0a		  add a,10  
8ef6 30 fb		   jr nc,$-3 
8ef8 c6 30		  add a,'0' 
8efa eb			  ex de,hl 
8efb 72			  ld (hl),d 
8efc 23			  inc hl 
8efd 77			  ld (hl),a 
8efe 23			  inc hl 
8eff 36 00		  ld (hl),0 
8f01			 
8f01			;Now strip the leading zeros 
8f01 0e fa		  ld c,-6 
8f03 09			  add hl,bc 
8f04 3e 30		  ld a,'0' 
8f06 23			  inc hl  
8f07 be			  cp (hl)  
8f08 28 fc		  jr z,$-2 
8f0a			 
8f0a			;Make sure that the string is non-empty! 
8f0a 7e			  ld a,(hl) 
8f0b b7			  or a 
8f0c 20 01		  jr nz,.atoub 
8f0e 2b			  dec hl 
8f0f			.atoub: 
8f0f			 
8f0f f1			  pop af 
8f10 c1			  pop bc 
8f11 d1			  pop de 
8f12 c9			  ret 
8f13			 
8f13			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
8f13			 
8f13			toUpper: 
8f13			;A is the char. 
8f13			;If A is a lowercase letter, this sets it to the matching uppercase 
8f13			;18cc or 30cc or 41cc 
8f13			;avg: 26.75cc 
8f13 fe 61		  cp 'a' 
8f15 d8			  ret c 
8f16 fe 7b		  cp 'z'+1 
8f18 d0			  ret nc 
8f19 d6 20		  sub 'a'-'A' 
8f1b c9			  ret 
8f1c			 
8f1c			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
8f1c			 
8f1c			; String Length 
8f1c			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
8f1c			 
8f1c			; Get the length of the null-terminated string starting at $8000 hl 
8f1c			;    LD     HL, $8000 
8f1c			 
8f1c			strlenz: 
8f1c			 
8f1c af			    XOR    A               ; Zero is the value we are looking for. 
8f1d 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
8f1e 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
8f1f			                           ; 65, 536 bytes (the entire addressable memory space). 
8f1f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8f21			 
8f21			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8f21 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
8f22 6f			    LD     L, A             ; number of bytes 
8f23 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8f25 2b			    DEC    HL              ; Compensate for null. 
8f26 c9				ret 
8f27			 
8f27			; Get the length of the A terminated string starting at $8000 hl 
8f27			;    LD     HL, $8000 
8f27			 
8f27			strlent: 
8f27			 
8f27			                  ; A is the value we are looking for. 
8f27 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
8f29 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
8f2b			                           ; 65, 536 bytes (the entire addressable memory space). 
8f2b ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
8f2d			 
8f2d			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
8f2d 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
8f2f 2e 00		    LD     L, 0             ; number of bytes 
8f31 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
8f33 2b			    DEC    HL              ; Compensate for null. 
8f34 c9				ret 
8f35			 
8f35			 
8f35			;Comparing Strings 
8f35			 
8f35			;IN    HL     Address of string1. 
8f35			;      DE     Address of string2. 
8f35			 
8f35			; doc given but wrong??? 
8f35			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
8f35			;      carry  Set if string1 > string2, reset if string1 <= string2. 
8f35			; tested 
8f35			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
8f35			 
8f35			strcmp_old: 
8f35 e5			    PUSH   HL 
8f36 d5			    PUSH   DE 
8f37			 
8f37 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
8f38 be			    CP     (HL)            ; (want to minimize work). 
8f39 38 01		    JR     C, Str1IsBigger 
8f3b 7e			    LD     A, (HL) 
8f3c			 
8f3c			Str1IsBigger: 
8f3c 4f			    LD     C, A             ; Put length in BC 
8f3d 06 00		    LD     B, 0 
8f3f 13			    INC    DE              ; Increment pointers to meat of string. 
8f40 23			    INC    HL 
8f41			 
8f41			CmpLoop: 
8f41 1a			    LD     A, (DE)          ; Compare bytes. 
8f42 ed a1		    CPI 
8f44 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
8f46 13			    INC    DE              ; Update pointer. 
8f47 ea 41 8f		    JP     PE, CmpLoop 
8f4a			 
8f4a d1			    POP    DE 
8f4b e1			    POP    HL 
8f4c 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
8f4d be			    CP     (HL) 
8f4e c9			    RET 
8f4f			 
8f4f			NoMatch: 
8f4f 2b			    DEC    HL 
8f50 be			    CP     (HL)            ; Compare again to affect carry. 
8f51 d1			    POP    DE 
8f52 e1			    POP    HL 
8f53 c9			    RET 
8f54			 
8f54			;; test strmp 
8f54			; 
8f54			;ld de, .str1 
8f54			;ld hl, .str2 
8f54			;call strcmp 
8f54			;jr z, .z1 
8f54			;;this 
8f54			;	if DEBUG_FORTH_WORDS 
8f54			;		DMARK "NZ1" 
8f54			;		CALLMONITOR 
8f54			;	endif 
8f54			;.z1: 
8f54			; 
8f54			;	if DEBUG_FORTH_WORDS 
8f54			;		DMARK "ZZ1" 
8f54			;		CALLMONITOR 
8f54			;	endif 
8f54			; 
8f54			;ld de, .str1 
8f54			;ld hl, .str1 
8f54			;call strcmp 
8f54			;jr z, .z2 
8f54			;;this 
8f54			;	if DEBUG_FORTH_WORDS 
8f54			;		DMARK "NZ2" 
8f54			;		CALLMONITOR 
8f54			;	endif 
8f54			;.z2: 
8f54			; 
8f54			;	if DEBUG_FORTH_WORDS 
8f54			;		DMARK "ZZ2" 
8f54			;		CALLMONITOR 
8f54			;	endif 
8f54			; 
8f54			;ld de, .str1 
8f54			;ld hl, .str2 
8f54			;call strcmp 
8f54			;jr c, .c1 
8f54			; 
8f54			;	if DEBUG_FORTH_WORDS 
8f54			;		DMARK "Nc1" 
8f54			;		CALLMONITOR 
8f54			;	endif 
8f54			;.c1: 
8f54			;;this 
8f54			;	if DEBUG_FORTH_WORDS 
8f54			;		DMARK "cc1" 
8f54			;		CALLMONITOR 
8f54			;	endif 
8f54			; 
8f54			;ld de, .str1 
8f54			;ld hl, .str1 
8f54			;call strcmp 
8f54			;jr c, .c2 
8f54			;;this 
8f54			;	if DEBUG_FORTH_WORDS 
8f54			;		DMARK "Nc2" 
8f54			;		CALLMONITOR 
8f54			;	endif 
8f54			;.c2: 
8f54			; 
8f54			;	if DEBUG_FORTH_WORDS 
8f54			;		DMARK "cc2" 
8f54			;		CALLMONITOR 
8f54			;	endif 
8f54			;	NEXTW 
8f54			;.str1:   db "string1",0 
8f54			;.str2:   db "string2",0 
8f54			 
8f54			; only care about direct match or not 
8f54			; hl and de strings 
8f54			; zero set if the same 
8f54			 
8f54			strcmp: 
8f54 1a				ld a, (de) 
8f55 be				cp (hl) 
8f56 28 02			jr z, .ssame 
8f58 b7				or a 
8f59 c9				ret 
8f5a			 
8f5a			.ssame:  
8f5a fe 00			cp 0 
8f5c c8				ret z 
8f5d			 
8f5d 23				inc hl 
8f5e 13				inc de 
8f5f 18 f3			jr strcmp 
8f61				 
8f61				 
8f61			 
8f61			 
8f61			 
8f61			 
8f61			; eof 
8f61			 
8f61			 
8f61			 
8f61			 
8f61			 
8f61			 
# End of file firmware_strings.asm
8f61			include "firmware_memory.asm"   ; malloc and free  
8f61			 
8f61			if DEBUG_FORTH_MALLOC_HIGH 
8f61			.mallocsize: db "Wants malloc >256",0 
8f61			.mallocasize: db "MALLOC gives >256",0 
8f61			.malloczero: db "MALLOC gives zero",0 
8f61			 
8f61			malloc_guard_zerolen: 
8f61				push hl 
8f61				push de 
8f61				push af 
8f61			 
8f61				ld de, 0 
8f61			        call cmp16 
8f61				jr nz, .lowalloz 
8f61			 
8f61				push hl 
8f61				push de 
8f61					ld hl, display_fb0 
8f61					ld (display_fb_active), hl 
8f61				call clear_display 
8f61				ld a, 0 
8f61				ld de, .malloczero 
8f61				call str_at_display 
8f61				call update_display 
8f61				call delay1s 
8f61				call delay1s 
8f61				ld a, 0 
8f61				ld (os_view_disable), a 
8f61			 
8f61				pop de 
8f61				pop hl 
8f61			 
8f61				 
8f61			 
8f61				CALLMONITOR 
8f61			.lowalloz: 
8f61			 
8f61			 
8f61				pop af 
8f61				pop de 
8f61				pop hl 
8f61			ret 
8f61			 
8f61			malloc_guard_entry: 
8f61				push hl 
8f61				push de 
8f61				push af 
8f61			 
8f61			 	or a      ;clear carry flag 
8f61				push hl 
8f61				ld de, 255 
8f61				sbc hl, de 
8f61				jr c, .lowalloc 
8f61			 
8f61				push de 
8f61					ld hl, display_fb0 
8f61					ld (display_fb_active), hl 
8f61				call clear_display 
8f61				ld a, 0 
8f61				ld de, .mallocsize 
8f61				call str_at_display 
8f61				call update_display 
8f61				call delay1s 
8f61				call delay1s 
8f61				ld a, 0 
8f61				ld (os_view_disable), a 
8f61			 
8f61				pop de 
8f61				pop hl 
8f61			 
8f61				 
8f61			 
8f61				CALLMONITOR 
8f61				jr .lowdone 
8f61			.lowalloc: 
8f61			 
8f61			 
8f61				pop hl 
8f61			.lowdone:	pop af 
8f61				pop de 
8f61				pop hl 
8f61			ret 
8f61			 
8f61			malloc_guard_exit: 
8f61				push hl 
8f61				push de 
8f61				push af 
8f61			 
8f61			 	or a      ;clear carry flag 
8f61				push hl 
8f61				ld de, 255 
8f61				sbc hl, de 
8f61				jr c, .lowallocx 
8f61			 
8f61				push de 
8f61					ld hl, display_fb0 
8f61					ld (display_fb_active), hl 
8f61				call clear_display 
8f61				ld a, 0 
8f61				ld de, .mallocasize 
8f61				call str_at_display 
8f61				call update_display 
8f61				call delay1s 
8f61				call delay1s 
8f61				ld a, 0 
8f61				ld (os_view_disable), a 
8f61				pop de 
8f61				pop hl 
8f61			 
8f61				CALLMONITOR 
8f61				jr .lowdonex 
8f61			.lowallocx: 
8f61			 
8f61				pop hl 
8f61			.lowdonex:	pop af 
8f61				pop de 
8f61				pop hl 
8f61			ret 
8f61			endif 
8f61			 
8f61			if MALLOC_2 
8f61			; Z80 Malloc and Free Functions 
8f61			 
8f61			; Malloc Function: 
8f61			; Input: 
8f61			;   HL: Size of block to allocate 
8f61			; Output: 
8f61			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f61			 
8f61			malloc: 
8f61				 
8f61			if DEBUG_FORTH_MALLOC_HIGH 
8f61			call malloc_guard_entry 
8f61			endif 
8f61			 
8f61			 
8f61			 
8f61			 
8f61					if DEBUG_FORTH_MALLOC 
8f61						DMARK "mal" 
8f61						CALLMONITOR 
8f61					endif 
8f61			    push af            ; Save AF register 
8f61			    ld a, l            ; Load low byte of size into A 
8f61			    or h               ; Check if size is zero 
8f61			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
8f61			 
8f61			    ; Allocate memory 
8f61			    ld hl, (heap_start) ; Load start of heap into HL 
8f61					if DEBUG_FORTH_MALLOC 
8f61						DMARK "ma1" 
8f61						CALLMONITOR 
8f61					endif 
8f61			    call malloc_internal ; Call internal malloc function 
8f61			    pop af             ; Restore AF register 
8f61			if DEBUG_FORTH_MALLOC_HIGH 
8f61			call malloc_guard_exit 
8f61			call malloc_guard_zerolen 
8f61			endif 
8f61			    ret                ; Return 
8f61			 
8f61			; Free Function: 
8f61			; Input: 
8f61			;   HL: Pointer to memory block to free 
8f61			; Output: 
8f61			;   None 
8f61			 
8f61			free: 
8f61			    push af            ; Save AF register 
8f61			    ld a, l            ; Load low byte of pointer into A 
8f61			    or h               ; Check if pointer is NULL 
8f61			    jp z, free_exit    ; If pointer is NULL, exit 
8f61			 
8f61			    ; Free memory 
8f61			    ld hl, (heap_start) ; Load start of heap into HL 
8f61			    call free_internal  ; Call internal free function 
8f61			    pop af             ; Restore AF register 
8f61			    ret                ; Return 
8f61			 
8f61			; Internal Malloc Function: 
8f61			; Input: 
8f61			;   HL: Size of block to allocate 
8f61			; Output: 
8f61			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
8f61			 
8f61			malloc_internal: 
8f61			    ld bc, 2           ; Number of bytes to allocate for management overhead 
8f61			    add hl, bc         ; Add management overhead to requested size 
8f61			    ex de, hl          ; Save total size in DE, and keep it in HL 
8f61					if DEBUG_FORTH_MALLOC 
8f61						DMARK "ma2" 
8f61						CALLMONITOR 
8f61					endif 
8f61			 
8f61			    ; Search for free memory block 
8f61			    ld de, (heap_end)  ; Load end of heap into DE 
8f61			    ld bc, 0           ; Initialize counter 
8f61			 
8f61					if DEBUG_FORTH_MALLOC 
8f61						DMARK "ma2" 
8f61						CALLMONITOR 
8f61					endif 
8f61			malloc_search_loop: 
8f61			    ; Check if current block is free 
8f61			    ld a, (hl)         ; Load current block's status (free or used) 
8f61			    cp 0               ; Compare with zero (free) 
8f61			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
8f61			 
8f61			    ; Check if current block is large enough 
8f61			    ld a, (hl+1)       ; Load high byte of block size 
8f61			    cp l               ; Compare with low byte of requested size 
8f61			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
8f61			 
8f61			    ld a, (hl+2)       ; Load low byte of block size 
8f61			    cp h               ; Compare with high byte of requested size 
8f61			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
8f61			 
8f61			    ; Mark block as used 
8f61			    ld (hl), 0xFF      ; Set status byte to indicate used block 
8f61			 
8f61			    ; Calculate remaining space in block 
8f61			    ld bc, 0           ; Clear BC 
8f61			    add hl, bc         ; Increment HL to point to start of data block 
8f61			    add hl, de         ; HL = HL + DE (total size) 
8f61			    ld bc, 1           ; Number of bytes to allocate for management overhead 
8f61			    add hl, bc         ; Add management overhead to start of data block 
8f61			 
8f61			    ; Save pointer to allocated block in HL 
8f61			if DEBUG_FORTH_MALLOC_HIGH 
8f61						DMARK "ma5" 
8f61			call malloc_guard_exit 
8f61			call malloc_guard_zerolen 
8f61			endif 
8f61			    ret 
8f61			 
8f61			malloc_skip_block_check: 
8f61			    ; Move to the next block 
8f61			    ld bc, 3           ; Size of management overhead 
8f61			    add hl, bc         ; Move to the next block 
8f61			    inc de             ; Increment counter 
8f61			 
8f61			    ; Check if we have reached the end of heap 
8f61			    ld a, e            ; Load low byte of heap end address 
8f61			    cp (hl)            ; Compare with low byte of current address 
8f61			    jr nz, malloc_search_loop  ; If not equal, continue searching 
8f61			    ld a, d            ; Load high byte of heap end address 
8f61			    cp 0               ; Check if it's zero (end of memory) 
8f61			    jr nz, malloc_search_loop  ; If not zero, continue searching 
8f61			 
8f61			    ; If we reached here, allocation failed 
8f61			    xor a              ; Set result to NULL 
8f61			if DEBUG_FORTH_MALLOC_HIGH 
8f61						DMARK "ma6" 
8f61			call malloc_guard_exit 
8f61			call malloc_guard_zerolen 
8f61			endif 
8f61			    ret 
8f61			malloc_exit: 
8f61			if DEBUG_FORTH_MALLOC_HIGH 
8f61						DMARK "ma7" 
8f61			call malloc_guard_exit 
8f61			call malloc_guard_zerolen 
8f61			endif 
8f61			    ret 
8f61			 
8f61			; Internal Free Function: 
8f61			; Input: 
8f61			;   HL: Pointer to memory block to free 
8f61			; Output: 
8f61			;   None 
8f61			 
8f61			free_internal: 
8f61			    ld de, (heap_start) ; Load start of heap into DE 
8f61			    ld bc, 0            ; Initialize counter 
8f61			 
8f61			free_search_loop: 
8f61			    ; Check if current block contains the pointer 
8f61			    ld a, l             ; Load low byte of pointer 
8f61			    cp (hl+1)           ; Compare with high byte of current block's address 
8f61			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f61			    ld a, h             ; Load high byte of pointer 
8f61			    cp (hl+2)           ; Compare with low byte of current block's address 
8f61			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
8f61			 
8f61			    ; Mark block as free 
8f61			    ld (hl), 0          ; Set status byte to indicate free block 
8f61			    ret                 ; Return 
8f61			 
8f61			free_skip_block_check: 
8f61			    ; Move to the next block 
8f61			    ld bc, 3            ; Size of management overhead 
8f61			    add hl, bc          ; Move to the next block 
8f61			    inc de              ; Increment counter 
8f61			 
8f61			    ; Check if we have reached the end of heap 
8f61			    ld a, e             ; Load low byte of heap end address 
8f61			    cp (hl)             ; Compare with low byte of current address 
8f61			    jr nz, free_search_loop  ; If not equal, continue searching 
8f61			    ld a, d             ; Load high byte of heap end address 
8f61			    cp 0                ; Check if it's zero (end of memory) 
8f61			    jr nz, free_search_loop  ; If not zero, continue searching 
8f61			 
8f61			    ; If we reached here, pointer is not found in heap 
8f61			    ret 
8f61			 
8f61			free_exit: 
8f61			    ret                 ; Return 
8f61			 
8f61			; Define heap start and end addresses 
8f61			;heap_start:    .dw 0xC000   ; Start of heap 
8f61			;heap_end:      .dw 0xE000   ; End of heap 
8f61			 
8f61			endif 
8f61			 
8f61			 
8f61			if MALLOC_1 
8f61			 
8f61			 
8f61			 
8f61			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
8f61			 
8f61			;moved to firmware.asm 
8f61			;heap_start        .equ  0x9000      ; Starting address of heap 
8f61			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
8f61			 
8f61			;      .org 0 
8f61			;      jp    main 
8f61			 
8f61			 
8f61			;      .org  0x100 
8f61			;main: 
8f61			;      ld    HL, 0x8100 
8f61			;      ld    SP, HL 
8f61			; 
8f61			;      call  heap_init 
8f61			; 
8f61			;      ; Make some allocations 
8f61			;      ld    HL, 12 
8f61			;      call  malloc            ; Allocates 0x9004 
8f61			; 
8f61			;      ld    HL, 12 
8f61			;      call  malloc            ; Allocates 0x9014 
8f61			; 
8f61			;      ld    HL, 12 
8f61			;      call  malloc            ; Allocates 0x9024 
8f61			; 
8f61			;      ; Free some allocations 
8f61			;      ld    HL, 0x9014 
8f61			;      call  free 
8f61			; 
8f61			;      ld    HL, 0x9004 
8f61			;      call  free 
8f61			; 
8f61			;      ld    HL, 0x9024 
8f61			;      call  free 
8f61			; 
8f61			; 
8f61			;      halt 
8f61			 
8f61			 
8f61			;------------------------------------------------------------------------------ 
8f61			;     heap_init                                                               : 
8f61			;                                                                             : 
8f61			; Description                                                                 : 
8f61			;     Initialise the heap and make it ready for malloc and free operations.   : 
8f61			;                                                                             : 
8f61			;     The heap is maintained as a linked list, starting with an initial       : 
8f61			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
8f61			;     the first free block in the heap. Each block then points to the next    : 
8f61			;     free block within the heap, and the free list ends at the first block   : 
8f61			;     with a null pointer to the next free block.                             : 
8f61			;                                                                             : 
8f61			; Parameters                                                                  : 
8f61			;     Inputs are compile-time only. Two defines which specify the starting    : 
8f61			;     address of the heap and its size are required, along with a memory      : 
8f61			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
8f61			;     principally stores a pointer to the first free block in the heap.       : 
8f61			;                                                                             : 
8f61			; Returns                                                                     : 
8f61			;     Nothing                                                                 : 
8f61			;------------------------------------------------------------------------------ 
8f61			heap_init: 
8f61 e5			      push  HL 
8f62			 
8f62			      ; Initialise free list struct 
8f62 21 ee d7		      ld    HL, heap_start 
8f65 22 e9 d7		      ld    (free_list), HL 
8f68 21 00 00		      ld    HL, 0 
8f6b 22 eb d7		      ld    (free_list+2), HL 
8f6e			 
8f6e			      ; Insert first free block at bottom of heap, consumes entire heap 
8f6e 21 42 e3		      ld    HL, heap_start+heap_size-4 
8f71 22 ee d7		      ld    (heap_start), HL        ; Next block (end of free list) 
8f74 21 54 0b		      ld    HL, heap_size-4 
8f77 22 f0 d7		      ld    (heap_start+2), HL      ; Block size 
8f7a			 
8f7a			      ; Insert end of free list block at top of heap - two null words will 
8f7a			      ; terminate the free list 
8f7a 21 00 00		      ld    HL, 0 
8f7d 22 44 e3		      ld    (heap_start+heap_size-2), HL 
8f80 22 42 e3		      ld    (heap_start+heap_size-4), HL 
8f83			 
8f83 e1			      pop   HL 
8f84			 
8f84 c9			      ret 
8f85			 
8f85			 
8f85			;------------------------------------------------------------------------------ 
8f85			;     malloc                                                                  : 
8f85			;                                                                             : 
8f85			; Description                                                                 : 
8f85			;     Allocates the wanted space from the heap and returns the address of the : 
8f85			;     first useable byte of the allocation.                                   : 
8f85			;                                                                             : 
8f85			;     Allocations can happen in one of two ways:                              : 
8f85			;                                                                             : 
8f85			;     1. A free block may be found which is the exact size wanted. In this    : 
8f85			;        case the block is removed from the free list and retuedn to the      : 
8f85			;        caller.                                                              : 
8f85			;     2. A free block may be found which is larger than the size wanted. In   : 
8f85			;        this case, the larger block is split into two. The first portion of  : 
8f85			;        this block will become the requested space by the malloc call and    : 
8f85			;        is returned to the caller. The second portion becomes a new free     : 
8f85			;        block, and the free list is adjusted to maintain continuity via this : 
8f85			;        newly created block.                                                 : 
8f85			;                                                                             : 
8f85			;     malloc does not set any initial value in the allocated space, the       : 
8f85			;     caller is required to do this as required.                              : 
8f85			;                                                                             : 
8f85			;     This implementation of malloc uses the stack exclusively, and is        : 
8f85			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
8f85			;     advisable to disable interrupts before calling malloc, and recommended  : 
8f85			;     to avoid the use of malloc inside ISRs in general.                      : 
8f85			;                                                                             : 
8f85			;     NOTE: heap_init must be called before malloc and free can be used.      : 
8f85			;                                                                             : 
8f85			; Parameters                                                                  : 
8f85			;     HL  Number of bytes wanted                                              : 
8f85			;                                                                             : 
8f85			; Returns                                                                     : 
8f85			;     HL  Address of the first useable byte of the allocation                 : 
8f85			;                                                                             : 
8f85			; Flags                                                                       : 
8f85			;     Z   Set if the allocation did not succeed, clear otherwise              : 
8f85			;                                                                             : 
8f85			; Stack frame                                                                 : 
8f85			;       |             |                                                       : 
8f85			;       +-------------+                                                       : 
8f85			;       |     BC      |                                                       : 
8f85			;       +-------------+                                                       : 
8f85			;       |     DE      |                                                       : 
8f85			;       +-------------+                                                       : 
8f85			;       |     IX      |                                                       : 
8f85			;       +-------------+                                                       : 
8f85			;       |  prev_free  |                                                       : 
8f85			;   +4  +-------------+                                                       : 
8f85			;       |  this_free  |                                                       : 
8f85			;   +2  +-------------+                                                       : 
8f85			;       |  next_free  |                                                       : 
8f85			;   +0  +-------------+                                                       : 
8f85			;       |             |                                                       : 
8f85			;                                                                             : 
8f85			;------------------------------------------------------------------------------ 
8f85			 
8f85			 
8f85			;malloc: 
8f85			; 
8f85			;	SAVESP ON 1 
8f85			; 
8f85			;	call malloc_code 
8f85			; 
8f85			;	CHECKSP ON 1 
8f85			;	ret 
8f85			 
8f85			 
8f85			malloc: 
8f85 c5			      push  BC 
8f86 d5			      push  DE 
8f87 dd e5		      push  IX 
8f89			if DEBUG_FORTH_MALLOC_HIGH 
8f89			call malloc_guard_entry 
8f89			endif 
8f89			 
8f89					if DEBUG_FORTH_MALLOC 
8f89						DMARK "mal" 
8f89						CALLMONITOR 
8f89					endif 
8f89 7c			      ld    A, H                    ; Exit if no space requested 
8f8a b5			      or    L 
8f8b ca 4a 90		      jp    Z, malloc_early_exit 
8f8e			 
8f8e			;inc hl 
8f8e			;inc hl 
8f8e			;inc hl 
8f8e			; 
8f8e			;inc hl 
8f8e			;inc hl 
8f8e			;inc hl 
8f8e			;inc hl 
8f8e			;inc hl 
8f8e			;inc hl 
8f8e			;inc hl 
8f8e			;inc hl 
8f8e			;inc hl 
8f8e			 
8f8e			 
8f8e			 
8f8e			 
8f8e					if DEBUG_FORTH_MALLOC 
8f8e						DMARK "maA" 
8f8e						CALLMONITOR 
8f8e					endif 
8f8e			      ; Set up stack frame 
8f8e eb			      ex    DE, HL 
8f8f 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
8f92 39			      add   HL, SP 
8f93 f9			      ld    SP, HL 
8f94 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
8f98 dd 39		      add   IX, SP 
8f9a			 
8f9a			      ; Setup initial state 
8f9a 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
8f9d 19			      add   HL, DE 
8f9e			 
8f9e 44			      ld    B, H                    ; Move want to BC 
8f9f 4d			      ld    C, L 
8fa0			 
8fa0 21 e9 d7		      ld    HL, free_list           ; Store prev_free ptr to stack 
8fa3 dd 75 04		      ld    (IX+4), L 
8fa6 dd 74 05		      ld    (IX+5), H 
8fa9			 
8fa9 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
8faa 23			      inc   HL 
8fab 56			      ld    D, (HL) 
8fac dd 73 02		      ld    (IX+2), E 
8faf dd 72 03		      ld    (IX+3), D 
8fb2 eb			      ex    DE, HL                  ; this_free ptr into HL 
8fb3			 
8fb3					if DEBUG_FORTH_MALLOC 
8fb3						DMARK "maB" 
8fb3						CALLMONITOR 
8fb3					endif 
8fb3			      ; Loop through free block list to find some space 
8fb3			malloc_find_space: 
8fb3 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
8fb4 23			      inc   HL 
8fb5 56			      ld    D, (HL) 
8fb6			 
8fb6 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
8fb7 b3			      or    E 
8fb8 ca 44 90		      jp    Z, malloc_no_space 
8fbb			 
8fbb dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
8fbe dd 72 01		      ld    (IX+1), D 
8fc1			 
8fc1			      ; Does this block have enough space to make the allocation? 
8fc1 23			      inc   HL                      ; Load free block size into DE 
8fc2 5e			      ld    E, (HL) 
8fc3 23			      inc   HL 
8fc4 56			      ld    D, (HL) 
8fc5			 
8fc5 eb			      ex    DE, HL                  ; Check size of block against want 
8fc6 b7			      or    A                       ; Ensure carry flag clear 
8fc7 ed 42		      sbc   HL, BC 
8fc9 e5			      push  HL                      ; Store the result for later (new block size) 
8fca			 
8fca ca 19 90		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
8fcd 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
8fcf			 
8fcf			      ; this_free block is not big enough, setup ptrs to test next free block 
8fcf e1			      pop   HL                      ; Discard previous result 
8fd0			 
8fd0 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
8fd3 dd 66 03		      ld    H, (IX+3) 
8fd6 dd 75 04		      ld    (IX+4), L 
8fd9 dd 74 05		      ld    (IX+5), H 
8fdc			 
8fdc dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
8fdf dd 66 01		      ld    H, (IX+1) 
8fe2 dd 75 02		      ld    (IX+2), L 
8fe5 dd 74 03		      ld    (IX+3), H 
8fe8			 
8fe8					if DEBUG_FORTH_MALLOC 
8fe8						DMARK "MA>" 
8fe8						CALLMONITOR 
8fe8					endif 
8fe8 18 c9		      jr    malloc_find_space 
8fea			 
8fea			      ; split a bigger block into two - requested size and remaining size 
8fea			malloc_alloc_split: 
8fea					if DEBUG_FORTH_MALLOC 
8fea						DMARK "MAs" 
8fea						CALLMONITOR 
8fea					endif 
8fea eb			      ex    DE, HL                  ; Calculate address of new free block 
8feb 2b			      dec   HL 
8fec 2b			      dec   HL 
8fed 2b			      dec   HL 
8fee 09			      add   HL, BC 
8fef			 
8fef			      ; Create a new block and point it at next_free 
8fef dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
8ff2 dd 56 01		      ld    D, (IX+1) 
8ff5			 
8ff5 73			      ld    (HL), E                 ; Store next_free ptr into new block 
8ff6 23			      inc   HL 
8ff7 72			      ld    (HL), D 
8ff8			 
8ff8 d1			      pop   DE                      ; Store size of new block into new block 
8ff9 23			      inc   HL 
8ffa 73			      ld    (HL), E 
8ffb 23			      inc   HL 
8ffc 72			      ld    (HL), D 
8ffd			 
8ffd			      ; Update this_free ptr to point to new block 
8ffd 2b			      dec   HL 
8ffe 2b			      dec   HL 
8fff 2b			      dec   HL 
9000			 
9000 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
9003 dd 56 03		      ld    D, (IX+3) 
9006			 
9006 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
9009 dd 74 03		      ld    (IX+3), H 
900c			 
900c			      ; Modify this_free block to be allocation 
900c eb			      ex    DE, HL 
900d af			      xor   A                       ; Null the next block ptr of allocated block 
900e 77			      ld    (HL), A 
900f 23			      inc   HL 
9010 77			      ld    (HL), A 
9011			 
9011 23			      inc   HL                      ; Store want size into allocated block 
9012 71			      ld    (HL), C 
9013 23			      inc   HL 
9014 70			      ld    (HL), B 
9015 23			      inc   HL 
9016 e5			      push  HL                      ; Address of allocation to return 
9017			 
9017 18 19		      jr    malloc_update_links 
9019			 
9019			malloc_alloc_fit: 
9019 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
901a			 
901a					if DEBUG_FORTH_MALLOC 
901a						DMARK "MAf" 
901a						CALLMONITOR 
901a					endif 
901a			      ; Modify this_free block to be allocation 
901a eb			      ex    DE, HL 
901b 2b			      dec   HL 
901c 2b			      dec   HL 
901d 2b			      dec   HL 
901e			 
901e af			      xor   A                       ; Null the next block ptr of allocated block 
901f 77			      ld    (HL), A 
9020 23			      inc   HL 
9021 77			      ld    (HL), A 
9022			 
9022 23			      inc   HL                      ; Store address of allocation to return 
9023 23			      inc   HL 
9024 23			      inc   HL 
9025 e5			      push  HL 
9026			 
9026			      ; Copy next_free ptr to this_free, remove allocated block from free list 
9026 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
9029 dd 66 01		      ld    H, (IX+1) 
902c			 
902c dd 75 02		      ld    (IX+2), L               ; HL to this_free 
902f dd 74 03		      ld    (IX+3), H 
9032			 
9032			 
9032			malloc_update_links: 
9032			      ; Update prev_free ptr to point to this_free 
9032 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
9035 dd 66 05		      ld    H, (IX+5) 
9038			 
9038 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
903b dd 56 03		      ld    D, (IX+3) 
903e			 
903e 73			      ld    (HL), E                 ; this_free ptr into prev_free 
903f 23			      inc   HL 
9040 72			      ld    (HL), D 
9041			 
9041					if DEBUG_FORTH_MALLOC 
9041						DMARK "Mul" 
9041						CALLMONITOR 
9041					endif 
9041			      ; Clear the Z flag to indicate successful allocation 
9041 7a			      ld    A, D 
9042 b3			      or    E 
9043			 
9043 d1			      pop   DE                      ; Address of allocation 
9044					if DEBUG_FORTH_MALLOC 
9044						DMARK "MAu" 
9044						CALLMONITOR 
9044					endif 
9044			 
9044			malloc_no_space: 
9044 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
9047 39			      add   HL, SP 
9048 f9			      ld    SP, HL 
9049			 
9049 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
904a					if DEBUG_FORTH_MALLOC 
904a						DMARK "MAN" 
904a						CALLMONITOR 
904a					endif 
904a			 
904a			malloc_early_exit: 
904a					if DEBUG_FORTH_MALLOC 
904a						DMARK "MAx" 
904a						CALLMONITOR 
904a					endif 
904a dd e1		      pop   IX 
904c d1			      pop   DE 
904d c1			      pop   BC 
904e			 
904e			if DEBUG_FORTH_MALLOC_HIGH 
904e			call malloc_guard_exit 
904e			call malloc_guard_zerolen 
904e			endif 
904e c9			      ret 
904f			 
904f			 
904f			;------------------------------------------------------------------------------ 
904f			;     free                                                                    : 
904f			;                                                                             : 
904f			; Description                                                                 : 
904f			;     Return the space pointed to by HL to the heap. HL must be an address as : 
904f			;     returned by malloc, otherwise the behaviour is undefined.               : 
904f			;                                                                             : 
904f			;     Where possible, directly adjacent free blocks will be merged together   : 
904f			;     into larger blocks to help ensure that the heap does not become         : 
904f			;     excessively fragmented.                                                 : 
904f			;                                                                             : 
904f			;     free does not clear or set any other value into the freed space, and    : 
904f			;     therefore its contents may be visible through subsequent malloc's. The  : 
904f			;     caller should clear the freed space as required.                        : 
904f			;                                                                             : 
904f			;     This implementation of free uses the stack exclusively, and is          : 
904f			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
904f			;     advisable to disable interrupts before calling free, and recommended    : 
904f			;     to avoid the use of free inside ISRs in general.                        : 
904f			;                                                                             : 
904f			;     NOTE: heap_init must be called before malloc and free can be used.      : 
904f			;                                                                             : 
904f			; Parameters                                                                  : 
904f			;     HL  Pointer to address of first byte of allocation to be freed          : 
904f			;                                                                             : 
904f			; Returns                                                                     : 
904f			;     Nothing                                                                 : 
904f			;                                                                             : 
904f			; Stack frame                                                                 : 
904f			;       |             |                                                       : 
904f			;       +-------------+                                                       : 
904f			;       |     BC      |                                                       : 
904f			;       +-------------+                                                       : 
904f			;       |     DE      |                                                       : 
904f			;       +-------------+                                                       : 
904f			;       |     IX      |                                                       : 
904f			;       +-------------+                                                       : 
904f			;       |  prev_free  |                                                       : 
904f			;   +2  +-------------+                                                       : 
904f			;       |  next_free  |                                                       : 
904f			;   +0  +-------------+                                                       : 
904f			;       |             |                                                       : 
904f			;                                                                             : 
904f			;------------------------------------------------------------------------------ 
904f			free: 
904f c5			      push  BC 
9050 d5			      push  DE 
9051 dd e5		      push  IX 
9053			 
9053 7c			      ld    A, H                    ; Exit if ptr is null 
9054 b5			      or    L 
9055 ca 19 91		      jp    Z, free_early_exit 
9058			 
9058			      ; Set up stack frame 
9058 eb			      ex    DE, HL 
9059 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
905c 39			      add   HL, SP 
905d f9			      ld    SP, HL 
905e dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
9062 dd 39		      add   IX, SP 
9064			 
9064			      ; The address in HL points to the start of the useable allocated space, 
9064			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
9064			      ; address of the block itself. 
9064 eb			      ex    DE, HL 
9065 11 fc ff		      ld    DE, -4 
9068 19			      add   HL, DE 
9069			 
9069			      ; An allocated block must have a null next block pointer in it 
9069 7e			      ld    A, (HL) 
906a 23			      inc   HL 
906b b6			      or    (HL) 
906c c2 14 91		      jp    NZ, free_done 
906f			 
906f 2b			      dec   HL 
9070			 
9070 44			      ld    B, H                    ; Copy HL to BC 
9071 4d			      ld    C, L 
9072			 
9072			      ; Loop through the free list to find the first block with an address 
9072			      ; higher than the block being freed 
9072 21 e9 d7		      ld    HL, free_list 
9075			 
9075			free_find_higher_block: 
9075 5e			      ld    E, (HL)                 ; Load next ptr from free block 
9076 23			      inc   HL 
9077 56			      ld    D, (HL) 
9078 2b			      dec   HL 
9079			 
9079 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
907c dd 72 01		      ld    (IX+1), D 
907f dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
9082 dd 74 03		      ld    (IX+3), H 
9085			 
9085 78			      ld    A, B                    ; Check if DE is greater than BC 
9086 ba			      cp    D                       ; Compare MSB first 
9087 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
9089 30 04		      jr    NC, free_find_higher_block_skip 
908b 79			      ld    A, C 
908c bb			      cp    E                       ; Then compare LSB 
908d 38 08		      jr    C, free_found_higher_block 
908f			 
908f			free_find_higher_block_skip: 
908f 7a			      ld    A, D                    ; Reached the end of the free list? 
9090 b3			      or    E 
9091 ca 14 91		      jp    Z, free_done 
9094			 
9094 eb			      ex    DE, HL 
9095			 
9095 18 de		      jr    free_find_higher_block 
9097			 
9097			free_found_higher_block: 
9097			      ; Insert freed block between prev and next free blocks 
9097 71			      ld    (HL), C                 ; Point prev free block to freed block 
9098 23			      inc   HL 
9099 70			      ld    (HL), B 
909a			 
909a 60			      ld    H, B                    ; Point freed block at next free block 
909b 69			      ld    L, C 
909c 73			      ld    (HL), E 
909d 23			      inc   HL 
909e 72			      ld    (HL), D 
909f			 
909f			      ; Check if the freed block is adjacent to the next free block 
909f 23			      inc   HL                      ; Load size of freed block into HL 
90a0 5e			      ld    E, (HL) 
90a1 23			      inc   HL 
90a2 56			      ld    D, (HL) 
90a3 eb			      ex    DE, HL 
90a4			 
90a4 09			      add   HL, BC                  ; Add addr of freed block and its size 
90a5			 
90a5 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
90a8 dd 56 01		      ld    D, (IX+1) 
90ab			 
90ab b7			      or    A                       ; Clear the carry flag 
90ac ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
90ae 20 22		      jr    NZ, free_check_adjacent_to_prev 
90b0			 
90b0			      ; Freed block is adjacent to next, merge into one bigger block 
90b0 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
90b1 5e			      ld    E, (HL) 
90b2 23			      inc   HL 
90b3 56			      ld    D, (HL) 
90b4 e5			      push  HL                      ; Save ptr to next block for later 
90b5			 
90b5 60			      ld    H, B                    ; Store ptr from next block into freed block 
90b6 69			      ld    L, C 
90b7 73			      ld    (HL), E 
90b8 23			      inc   HL 
90b9 72			      ld    (HL), D 
90ba			 
90ba e1			      pop   HL                      ; Restore ptr to next block 
90bb 23			      inc   HL                      ; Load size of next block into DE 
90bc 5e			      ld    E, (HL) 
90bd 23			      inc   HL 
90be 56			      ld    D, (HL) 
90bf d5			      push  DE                      ; Save next block size for later 
90c0			 
90c0 60			      ld    H, B                    ; Load size of freed block into HL 
90c1 69			      ld    L, C 
90c2 23			      inc   HL 
90c3 23			      inc   HL 
90c4 5e			      ld    E, (HL) 
90c5 23			      inc   HL 
90c6 56			      ld    D, (HL) 
90c7 eb			      ex    DE, HL 
90c8			 
90c8 d1			      pop   DE                      ; Restore size of next block 
90c9 19			      add   HL, DE                  ; Add sizes of both blocks 
90ca eb			      ex    DE, HL 
90cb			 
90cb 60			      ld    H, B                    ; Store new bigger size into freed block 
90cc 69			      ld    L, C 
90cd 23			      inc   HL 
90ce 23			      inc   HL 
90cf 73			      ld    (HL), E 
90d0 23			      inc   HL 
90d1 72			      ld    (HL), D 
90d2			 
90d2			free_check_adjacent_to_prev: 
90d2			      ; Check if the freed block is adjacent to the prev free block 
90d2 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
90d5 dd 66 03		      ld    H, (IX+3) 
90d8			 
90d8 23			      inc   HL                      ; Size of prev free block into DE 
90d9 23			      inc   HL 
90da 5e			      ld    E, (HL) 
90db 23			      inc   HL 
90dc 56			      ld    D, (HL) 
90dd 2b			      dec   HL 
90de 2b			      dec   HL 
90df 2b			      dec   HL 
90e0			 
90e0 19			      add   HL, DE                  ; Add prev block addr and size 
90e1			 
90e1 b7			      or    A                       ; Clear the carry flag 
90e2 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
90e4 20 2e		      jr    NZ, free_done 
90e6			 
90e6			      ; Freed block is adjacent to prev, merge into one bigger block 
90e6 60			      ld    H, B                    ; Load next ptr from freed block into DE 
90e7 69			      ld    L, C 
90e8 5e			      ld    E, (HL) 
90e9 23			      inc   HL 
90ea 56			      ld    D, (HL) 
90eb e5			      push  HL                      ; Save freed block ptr for later 
90ec			 
90ec dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
90ef dd 66 03		      ld    H, (IX+3) 
90f2 73			      ld    (HL), E 
90f3 23			      inc   HL 
90f4 72			      ld    (HL), D 
90f5			 
90f5 e1			      pop   HL                      ; Restore freed block ptr 
90f6 23			      inc   HL                      ; Load size of freed block into DE 
90f7 5e			      ld    E, (HL) 
90f8 23			      inc   HL 
90f9 56			      ld    D, (HL) 
90fa d5			      push  DE                      ; Save freed block size for later 
90fb			 
90fb dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
90fe dd 66 03		      ld    H, (IX+3) 
9101 23			      inc   HL 
9102 23			      inc   HL 
9103 5e			      ld    E, (HL) 
9104 23			      inc   HL 
9105 56			      ld    D, (HL) 
9106			 
9106 e1			      pop   HL                      ; Add sizes of both blocks 
9107 19			      add   HL, DE 
9108 eb			      ex    DE, HL 
9109			 
9109 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
910c dd 66 03		      ld    H, (IX+3) 
910f 23			      inc   HL 
9110 23			      inc   HL 
9111 73			      ld    (HL), E 
9112 23			      inc   HL 
9113 72			      ld    (HL), D 
9114			 
9114			free_done: 
9114 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
9117 39			      add   HL, SP 
9118 f9			      ld    SP, HL 
9119			 
9119			free_early_exit: 
9119 dd e1		      pop   IX 
911b d1			      pop   DE 
911c c1			      pop   BC 
911d			 
911d c9			      ret 
911e			 
911e			; moved to firmware.asm 
911e			; 
911e			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
911e			;                  .dw   0 
911e			 
911e			 
911e			endif 
911e			 
911e			 
911e			if MALLOC_3 
911e			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
911e			;heap_start        .equ  0x9000      ; Starting address of heap 
911e			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
911e			; 
911e			 ;     .org 0 
911e			  ;    jp    main 
911e			; 
911e			; 
911e			 ;     .org  0x100 
911e			;main: 
911e			 ;     ld    HL, 0x8100 
911e			  ;    ld    SP, HL 
911e			; 
911e			;      call  heap_init 
911e			 
911e			      ; Make some allocations 
911e			;      ld    HL, 12 
911e			;      call  malloc            ; Allocates 0x9004 
911e			; 
911e			 ;     ld    HL, 12 
911e			;      call  malloc            ; Allocates 0x9014 
911e			 
911e			;      ld    HL, 12 
911e			;      call  malloc            ; Allocates 0x9024 
911e			 
911e			      ; Free some allocations 
911e			;      ld    HL, 0x9014 
911e			;      call  free 
911e			 
911e			;      ld    HL, 0x9004 
911e			;      call  free 
911e			; 
911e			;      ld    HL, 0x9024 
911e			;      call  free 
911e			 
911e			 
911e			 ;     halt 
911e			 
911e			 
911e			;------------------------------------------------------------------------------ 
911e			;     heap_init                                                               : 
911e			;                                                                             : 
911e			; Description                                                                 : 
911e			;     Initialise the heap and make it ready for malloc and free operations.   : 
911e			;                                                                             : 
911e			;     The heap is maintained as a linked list, starting with an initial       : 
911e			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
911e			;     the first free block in the heap. Each block then points to the next    : 
911e			;     free block within the heap, and the free list ends at the first block   : 
911e			;     with a null pointer to the next free block.                             : 
911e			;                                                                             : 
911e			; Parameters                                                                  : 
911e			;     Inputs are compile-time only. Two defines which specify the starting    : 
911e			;     address of the heap and its size are required, along with a memory      : 
911e			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
911e			;     principally stores a pointer to the first free block in the heap.       : 
911e			;                                                                             : 
911e			; Returns                                                                     : 
911e			;     Nothing                                                                 : 
911e			;------------------------------------------------------------------------------ 
911e			heap_init: 
911e			      push  HL 
911e			 
911e			      ; Initialise free list struct 
911e			      ld    HL, heap_start 
911e			      ld    (free_list), HL 
911e			      ld    HL, 0 
911e			      ld    (free_list+2), HL 
911e			 
911e			      ; Insert first free block at bottom of heap, consumes entire heap 
911e			      ld    HL, heap_start+heap_size-4 
911e			      ld    (heap_start), HL        ; Next block (end of free list) 
911e			      ld    HL, heap_size-4 
911e			      ld    (heap_start+2), HL      ; Block size 
911e			 
911e			      ; Insert end of free list block at top of heap - two null words will 
911e			      ; terminate the free list 
911e			      ld    HL, 0 
911e			      ld    (heap_start+heap_size-2), HL 
911e			      ld    (heap_start+heap_size-4), HL 
911e			 
911e			      pop   HL 
911e			 
911e			      ret 
911e			 
911e			 
911e			;------------------------------------------------------------------------------ 
911e			;     malloc                                                                  : 
911e			;                                                                             : 
911e			; Description                                                                 : 
911e			;     Allocates the wanted space from the heap and returns the address of the : 
911e			;     first useable byte of the allocation.                                   : 
911e			;                                                                             : 
911e			;     Allocations can happen in one of two ways:                              : 
911e			;                                                                             : 
911e			;     1. A free block may be found which is the exact size wanted. In this    : 
911e			;        case the block is removed from the free list and retuedn to the      : 
911e			;        caller.                                                              : 
911e			;     2. A free block may be found which is larger than the size wanted. In   : 
911e			;        this case, the larger block is split into two. The first portion of  : 
911e			;        this block will become the requested space by the malloc call and    : 
911e			;        is returned to the caller. The second portion becomes a new free     : 
911e			;        block, and the free list is adjusted to maintain continuity via this : 
911e			;        newly created block.                                                 : 
911e			;                                                                             : 
911e			;     malloc does not set any initial value in the allocated space, the       : 
911e			;     caller is required to do this as required.                              : 
911e			;                                                                             : 
911e			;     This implementation of malloc uses the stack exclusively, and is        : 
911e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
911e			;     advisable to disable interrupts before calling malloc, and recommended  : 
911e			;     to avoid the use of malloc inside ISRs in general.                      : 
911e			;                                                                             : 
911e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
911e			;                                                                             : 
911e			; Parameters                                                                  : 
911e			;     HL  Number of bytes wanted                                              : 
911e			;                                                                             : 
911e			; Returns                                                                     : 
911e			;     HL  Address of the first useable byte of the allocation                 : 
911e			;                                                                             : 
911e			; Flags                                                                       : 
911e			;     Z   Set if the allocation did not succeed, clear otherwise              : 
911e			;                                                                             : 
911e			; Stack frame                                                                 : 
911e			;       |             |                                                       : 
911e			;       +-------------+                                                       : 
911e			;       |     BC      |                                                       : 
911e			;       +-------------+                                                       : 
911e			;       |     DE      |                                                       : 
911e			;       +-------------+                                                       : 
911e			;       |     IX      |                                                       : 
911e			;       +-------------+                                                       : 
911e			;       |  prev_free  |                                                       : 
911e			;   +4  +-------------+                                                       : 
911e			;       |  this_free  |                                                       : 
911e			;   +2  +-------------+                                                       : 
911e			;       |  next_free  |                                                       : 
911e			;   +0  +-------------+                                                       : 
911e			;       |             |                                                       : 
911e			;                                                                             : 
911e			;------------------------------------------------------------------------------ 
911e			malloc: 
911e			      push  BC 
911e			      push  DE 
911e			      push  IX 
911e			 
911e			      ld    A, H                    ; Exit if no space requested 
911e			      or    L 
911e			      jp    Z, malloc_early_exit 
911e			 
911e			      ; Set up stack frame 
911e			      ex    DE, HL 
911e			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
911e			      add   HL, SP 
911e			      ld    SP, HL 
911e			      ld    IX, 0                   ; Use IX as a frame pointer 
911e			      add   IX, SP 
911e			 
911e			      ; Setup initial state 
911e			      ld    HL, 4                   ; want must also include space used by block struct 
911e			      add   HL, DE 
911e			 
911e			      ld    B, H                    ; Move want to BC 
911e			      ld    C, L 
911e			 
911e			      ld    HL, free_list           ; Store prev_free ptr to stack 
911e			      ld    (IX+4), L 
911e			      ld    (IX+5), H 
911e			 
911e			      ld    E, (HL)                 ; Store this_free ptr to stack 
911e			      inc   HL 
911e			      ld    D, (HL) 
911e			      ld    (IX+2), E 
911e			      ld    (IX+3), D 
911e			      ex    DE, HL                  ; this_free ptr into HL 
911e			 
911e			      ; Loop through free block list to find some space 
911e			malloc_find_space: 
911e			      ld    E, (HL)                 ; Load next_free ptr into DE 
911e			      inc   HL 
911e			      ld    D, (HL) 
911e			 
911e			      ld    A, D                    ; Check for null next_free ptr - end of free list 
911e			      or    E 
911e			      jp    Z, malloc_no_space 
911e			 
911e			      ld    (IX+0), E               ; Store next_free ptr to stack 
911e			      ld    (IX+1), D 
911e			 
911e			      ; Does this block have enough space to make the allocation? 
911e			      inc   HL                      ; Load free block size into DE 
911e			      ld    E, (HL) 
911e			      inc   HL 
911e			      ld    D, (HL) 
911e			 
911e			      ex    DE, HL                  ; Check size of block against want 
911e			      or    A                       ; Ensure carry flag clear 
911e			      sbc   HL, BC 
911e			      push  HL                      ; Store the result for later (new block size) 
911e			 
911e			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
911e			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
911e			 
911e			      ; this_free block is not big enough, setup ptrs to test next free block 
911e			      pop   HL                      ; Discard previous result 
911e			 
911e			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
911e			      ld    H, (IX+3) 
911e			      ld    (IX+4), L 
911e			      ld    (IX+5), H 
911e			 
911e			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
911e			      ld    H, (IX+1) 
911e			      ld    (IX+2), L 
911e			      ld    (IX+3), H 
911e			 
911e			      jr    malloc_find_space 
911e			 
911e			      ; split a bigger block into two - requested size and remaining size 
911e			malloc_alloc_split: 
911e			      ex    DE, HL                  ; Calculate address of new free block 
911e			      dec   HL 
911e			      dec   HL 
911e			      dec   HL 
911e			      add   HL, BC 
911e			 
911e			      ; Create a new block and point it at next_free 
911e			      ld    E, (IX+0)               ; Load next_free ptr into DE 
911e			      ld    D, (IX+1) 
911e			 
911e			      ld    (HL), E                 ; Store next_free ptr into new block 
911e			      inc   HL 
911e			      ld    (HL), D 
911e			 
911e			      pop   DE                      ; Store size of new block into new block 
911e			      inc   HL 
911e			      ld    (HL), E 
911e			      inc   HL 
911e			      ld    (HL), D 
911e			 
911e			      ; Update this_free ptr to point to new block 
911e			      dec   HL 
911e			      dec   HL 
911e			      dec   HL 
911e			 
911e			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
911e			      ld    D, (IX+3) 
911e			 
911e			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
911e			      ld    (IX+3), H 
911e			 
911e			      ; Modify this_free block to be allocation 
911e			      ex    DE, HL 
911e			      xor   A                       ; Null the next block ptr of allocated block 
911e			      ld    (HL), A 
911e			      inc   HL 
911e			      ld    (HL), A 
911e			 
911e			      inc   HL                      ; Store want size into allocated block 
911e			      ld    (HL), C 
911e			      inc   HL 
911e			      ld    (HL), B 
911e			      inc   HL 
911e			      push  HL                      ; Address of allocation to return 
911e			 
911e			      jr    malloc_update_links 
911e			 
911e			malloc_alloc_fit: 
911e			      pop   HL                      ; Dont need new block size, want is exact fit 
911e			 
911e			      ; Modify this_free block to be allocation 
911e			      ex    DE, HL 
911e			      dec   HL 
911e			      dec   HL 
911e			      dec   HL 
911e			 
911e			      xor   A                       ; Null the next block ptr of allocated block 
911e			      ld    (HL), A 
911e			      inc   HL 
911e			      ld    (HL), A 
911e			 
911e			      inc   HL                      ; Store address of allocation to return 
911e			      inc   HL 
911e			      inc   HL 
911e			      push  HL 
911e			 
911e			      ; Copy next_free ptr to this_free, remove allocated block from free list 
911e			      ld    L, (IX+0)               ; next_free to HL 
911e			      ld    H, (IX+1) 
911e			 
911e			      ld    (IX+2), L               ; HL to this_free 
911e			      ld    (IX+3), H 
911e			 
911e			 
911e			malloc_update_links: 
911e			      ; Update prev_free ptr to point to this_free 
911e			      ld    L, (IX+4)               ; prev_free ptr to HL 
911e			      ld    H, (IX+5) 
911e			 
911e			      ld    E, (IX+2)               ; this_free ptr to DE 
911e			      ld    D, (IX+3) 
911e			 
911e			      ld    (HL), E                 ; this_free ptr into prev_free 
911e			      inc   HL 
911e			      ld    (HL), D 
911e			 
911e			      ; Clear the Z flag to indicate successful allocation 
911e			      ld    A, D 
911e			      or    E 
911e			 
911e			      pop   DE                      ; Address of allocation 
911e			 
911e			malloc_no_space: 
911e			      ld    HL, 6                   ; Clean up stack frame 
911e			      add   HL, SP 
911e			      ld    SP, HL 
911e			 
911e			      ex    DE, HL                  ; Alloc addr into HL for return 
911e			 
911e			malloc_early_exit: 
911e			      pop   IX 
911e			      pop   DE 
911e			      pop   BC 
911e			 
911e			      ret 
911e			 
911e			 
911e			;------------------------------------------------------------------------------ 
911e			;     free                                                                    : 
911e			;                                                                             : 
911e			; Description                                                                 : 
911e			;     Return the space pointed to by HL to the heap. HL must be an address as : 
911e			;     returned by malloc, otherwise the behaviour is undefined.               : 
911e			;                                                                             : 
911e			;     Where possible, directly adjacent free blocks will be merged together   : 
911e			;     into larger blocks to help ensure that the heap does not become         : 
911e			;     excessively fragmented.                                                 : 
911e			;                                                                             : 
911e			;     free does not clear or set any other value into the freed space, and    : 
911e			;     therefore its contents may be visible through subsequent malloc's. The  : 
911e			;     caller should clear the freed space as required.                        : 
911e			;                                                                             : 
911e			;     This implementation of free uses the stack exclusively, and is          : 
911e			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
911e			;     advisable to disable interrupts before calling free, and recommended    : 
911e			;     to avoid the use of free inside ISRs in general.                        : 
911e			;                                                                             : 
911e			;     NOTE: heap_init must be called before malloc and free can be used.      : 
911e			;                                                                             : 
911e			; Parameters                                                                  : 
911e			;     HL  Pointer to address of first byte of allocation to be freed          : 
911e			;                                                                             : 
911e			; Returns                                                                     : 
911e			;     Nothing                                                                 : 
911e			;                                                                             : 
911e			; Stack frame                                                                 : 
911e			;       |             |                                                       : 
911e			;       +-------------+                                                       : 
911e			;       |     BC      |                                                       : 
911e			;       +-------------+                                                       : 
911e			;       |     DE      |                                                       : 
911e			;       +-------------+                                                       : 
911e			;       |     IX      |                                                       : 
911e			;       +-------------+                                                       : 
911e			;       |  prev_free  |                                                       : 
911e			;   +2  +-------------+                                                       : 
911e			;       |  next_free  |                                                       : 
911e			;   +0  +-------------+                                                       : 
911e			;       |             |                                                       : 
911e			;                                                                             : 
911e			;------------------------------------------------------------------------------ 
911e			free: 
911e			      push  BC 
911e			      push  DE 
911e			      push  IX 
911e			 
911e			      ld    A, H                    ; Exit if ptr is null 
911e			      or    L 
911e			      jp    Z, free_early_exit 
911e			 
911e			      ; Set up stack frame 
911e			      ex    DE, HL 
911e			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
911e			      add   HL, SP 
911e			      ld    SP, HL 
911e			      ld    IX, 0                   ; Use IX as a frame pointer 
911e			      add   IX, SP 
911e			 
911e			      ; The address in HL points to the start of the useable allocated space, 
911e			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
911e			      ; address of the block itself. 
911e			      ex    DE, HL 
911e			      ld    DE, -4 
911e			      add   HL, DE 
911e			 
911e			      ; An allocated block must have a null next block pointer in it 
911e			      ld    A, (HL) 
911e			      inc   HL 
911e			      or    (HL) 
911e			      jp    NZ, free_done 
911e			 
911e			      dec   HL 
911e			 
911e			      ld    B, H                    ; Copy HL to BC 
911e			      ld    C, L 
911e			 
911e			      ; Loop through the free list to find the first block with an address 
911e			      ; higher than the block being freed 
911e			      ld    HL, free_list 
911e			 
911e			free_find_higher_block: 
911e			      ld    E, (HL)                 ; Load next ptr from free block 
911e			      inc   HL 
911e			      ld    D, (HL) 
911e			      dec   HL 
911e			 
911e			      ld    (IX+0), E               ; Save ptr to next free block 
911e			      ld    (IX+1), D 
911e			      ld    (IX+2), L               ; Save ptr to prev free block 
911e			      ld    (IX+3), H 
911e			 
911e			      ld    A, B                    ; Check if DE is greater than BC 
911e			      cp    D                       ; Compare MSB first 
911e			      jr    Z, $+4                  ; MSB the same, compare LSB 
911e			      jr    NC, free_find_higher_block_skip 
911e			      ld    A, C 
911e			      cp    E                       ; Then compare LSB 
911e			      jr    C, free_found_higher_block 
911e			 
911e			free_find_higher_block_skip: 
911e			      ld    A, D                    ; Reached the end of the free list? 
911e			      or    E 
911e			      jp    Z, free_done 
911e			 
911e			      ex    DE, HL 
911e			 
911e			      jr    free_find_higher_block 
911e			 
911e			free_found_higher_block: 
911e			      ; Insert freed block between prev and next free blocks 
911e			      ld    (HL), C                 ; Point prev free block to freed block 
911e			      inc   HL 
911e			      ld    (HL), B 
911e			 
911e			      ld    H, B                    ; Point freed block at next free block 
911e			      ld    L, C 
911e			      ld    (HL), E 
911e			      inc   HL 
911e			      ld    (HL), D 
911e			 
911e			      ; Check if the freed block is adjacent to the next free block 
911e			      inc   HL                      ; Load size of freed block into HL 
911e			      ld    E, (HL) 
911e			      inc   HL 
911e			      ld    D, (HL) 
911e			      ex    DE, HL 
911e			 
911e			      add   HL, BC                  ; Add addr of freed block and its size 
911e			 
911e			      ld    E, (IX+0)               ; Load addr of next free block into DE 
911e			      ld    D, (IX+1) 
911e			 
911e			      or    A                       ; Clear the carry flag 
911e			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
911e			      jr    NZ, free_check_adjacent_to_prev 
911e			 
911e			      ; Freed block is adjacent to next, merge into one bigger block 
911e			      ex    DE, HL                  ; Load next ptr from next block into DE 
911e			      ld    E, (HL) 
911e			      inc   HL 
911e			      ld    D, (HL) 
911e			      push  HL                      ; Save ptr to next block for later 
911e			 
911e			      ld    H, B                    ; Store ptr from next block into freed block 
911e			      ld    L, C 
911e			      ld    (HL), E 
911e			      inc   HL 
911e			      ld    (HL), D 
911e			 
911e			      pop   HL                      ; Restore ptr to next block 
911e			      inc   HL                      ; Load size of next block into DE 
911e			      ld    E, (HL) 
911e			      inc   HL 
911e			      ld    D, (HL) 
911e			      push  DE                      ; Save next block size for later 
911e			 
911e			      ld    H, B                    ; Load size of freed block into HL 
911e			      ld    L, C 
911e			      inc   HL 
911e			      inc   HL 
911e			      ld    E, (HL) 
911e			      inc   HL 
911e			      ld    D, (HL) 
911e			      ex    DE, HL 
911e			 
911e			      pop   DE                      ; Restore size of next block 
911e			      add   HL, DE                  ; Add sizes of both blocks 
911e			      ex    DE, HL 
911e			 
911e			      ld    H, B                    ; Store new bigger size into freed block 
911e			      ld    L, C 
911e			      inc   HL 
911e			      inc   HL 
911e			      ld    (HL), E 
911e			      inc   HL 
911e			      ld    (HL), D 
911e			 
911e			free_check_adjacent_to_prev: 
911e			      ; Check if the freed block is adjacent to the prev free block 
911e			      ld    L, (IX+2)               ; Prev free block ptr into HL 
911e			      ld    H, (IX+3) 
911e			 
911e			      inc   HL                      ; Size of prev free block into DE 
911e			      inc   HL 
911e			      ld    E, (HL) 
911e			      inc   HL 
911e			      ld    D, (HL) 
911e			      dec   HL 
911e			      dec   HL 
911e			      dec   HL 
911e			 
911e			      add   HL, DE                  ; Add prev block addr and size 
911e			 
911e			      or    A                       ; Clear the carry flag 
911e			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
911e			      jr    NZ, free_done 
911e			 
911e			      ; Freed block is adjacent to prev, merge into one bigger block 
911e			      ld    H, B                    ; Load next ptr from freed block into DE 
911e			      ld    L, C 
911e			      ld    E, (HL) 
911e			      inc   HL 
911e			      ld    D, (HL) 
911e			      push  HL                      ; Save freed block ptr for later 
911e			 
911e			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
911e			      ld    H, (IX+3) 
911e			      ld    (HL), E 
911e			      inc   HL 
911e			      ld    (HL), D 
911e			 
911e			      pop   HL                      ; Restore freed block ptr 
911e			      inc   HL                      ; Load size of freed block into DE 
911e			      ld    E, (HL) 
911e			      inc   HL 
911e			      ld    D, (HL) 
911e			      push  DE                      ; Save freed block size for later 
911e			 
911e			      ld    L, (IX+2)               ; Load size of prev block into DE 
911e			      ld    H, (IX+3) 
911e			      inc   HL 
911e			      inc   HL 
911e			      ld    E, (HL) 
911e			      inc   HL 
911e			      ld    D, (HL) 
911e			 
911e			      pop   HL                      ; Add sizes of both blocks 
911e			      add   HL, DE 
911e			      ex    DE, HL 
911e			 
911e			      ld    L, (IX+2)               ; Store new bigger size into prev block 
911e			      ld    H, (IX+3) 
911e			      inc   HL 
911e			      inc   HL 
911e			      ld    (HL), E 
911e			      inc   HL 
911e			      ld    (HL), D 
911e			 
911e			free_done: 
911e			      ld    HL, 4                   ; Clean up stack frame 
911e			      add   HL, SP 
911e			      ld    SP, HL 
911e			 
911e			free_early_exit: 
911e			      pop   IX 
911e			      pop   DE 
911e			      pop   BC 
911e			 
911e			      ret 
911e			 
911e			 
911e			;      .org 0x8000 
911e			; 
911e			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
911e			 ;                 .dw   0 
911e			 
911e			endif 
911e			 
911e			 
911e			if MALLOC_4 
911e			 
911e			; My memory allocation code. Very very simple.... 
911e			; allocate space under 250 chars 
911e			 
911e			heap_init: 
911e				; init start of heap as zero 
911e				;  
911e			 
911e				ld hl, heap_start 
911e				ld a, 0 
911e				ld (hl), a      ; empty block 
911e				inc hl 
911e				ld a, 0 
911e				ld (hl), a      ; length of block 
911e				; write end of list 
911e				inc hl 
911e				ld a,(hl) 
911e				inc hl 
911e				ld a,(hl) 
911e				 
911e			 
911e				; init some malloc vars 
911e			 
911e				ld hl, 0 
911e				ld (free_list), hl       ; store last malloc location 
911e			 
911e				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
911e				ld a, 0 
911e				ld (hl), a 
911e			 
911e			 
911e				ld hl, heap_start 
911e				;  
911e				  
911e				ret 
911e			 
911e			 
911e			;    free block marker 
911e			;    requested size  
911e			;    pointer to next block 
911e			;    .... 
911e			;    next block marker 
911e			 
911e			 
911e			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
911e			; 
911e			 
911e			 
911e			malloc:  
911e				push de 
911e				push bc 
911e				push af 
911e			 
911e				; hl space required 
911e				 
911e				ld c, l    ; hold space   (TODO only a max of 255) 
911e			 
911e			;	inc c     ; TODO BUG need to fix memory leak on push str 
911e			;	inc c 
911e			;	inc c 
911e			;	inc c 
911e			;	inc c 
911e			;	inc c 
911e			;	inc c 
911e			 
911e			 
911e			 
911e				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
911e			 
911e				ld a, (free_list+3) 
911e				cp 0 
911e				jr z, .contheap 
911e			 
911e				ld hl, (free_list)     ; get last alloc 
911e					if DEBUG_FORTH_MALLOC_INT 
911e						DMARK "mrs" 
911e						CALLMONITOR 
911e					endif 
911e				jr .startalloc 
911e			 
911e			.contheap: 
911e				ld hl, heap_start 
911e			 
911e			.startalloc: 
911e			 
911e					if DEBUG_FORTH_MALLOC_INT 
911e						DMARK "mym" 
911e						CALLMONITOR 
911e					endif 
911e			.findblock: 
911e					if DEBUG_FORTH_MALLOC_INT 
911e						DMARK "mmf" 
911e						CALLMONITOR 
911e					endif 
911e			 
911e				ld a,(hl)  
911e				; if byte is zero then clear to use 
911e			 
911e				cp 0 
911e				jr z, .foundemptyblock 
911e			 
911e				; if byte is not clear 
911e				;     then byte is offset to next block 
911e			 
911e				inc hl 
911e				ld a, (hl) ; get size 
911e			.nextblock:	inc hl 
911e					ld e, (hl) 
911e					inc hl 
911e					ld d, (hl) 
911e					ex de, hl 
911e			;	inc hl  ; move past the store space 
911e			;	inc hl  ; move past zero index  
911e			 
911e				; TODO detect no more space 
911e			 
911e				push hl 
911e				ld de, heap_end 
911e				call cmp16 
911e				pop hl 
911e				jr nc, .nospace 
911e			 
911e				jr .findblock 
911e			 
911e			.nospace: ld hl, 0 
911e				jp .exit 
911e			 
911e			 
911e			.foundemptyblock:	 
911e					if DEBUG_FORTH_MALLOC_INT 
911e						DMARK "mme" 
911e						CALLMONITOR 
911e					endif 
911e			 
911e			; TODO has block enough space if reusing??? 
911e			 
911e				;  
911e			 
911e			; see if this block has been previously used 
911e				inc hl 
911e				ld a, (hl) 
911e				dec hl 
911e				cp 0 
911e				jr z, .newblock 
911e			 
911e					if DEBUG_FORTH_MALLOC_INT 
911e						DMARK "meR" 
911e						CALLMONITOR 
911e					endif 
911e			 
911e			; no reusing previously allocated block 
911e			 
911e			; is it smaller than previously used? 
911e				 
911e				inc hl    ; move to size 
911e				ld a, c 
911e				sub (hl)        ; we want c < (hl) 
911e				dec hl    ; move back to marker 
911e			        jr z, .findblock 
911e			 
911e				; update with the new size which should be lower 
911e			 
911e			        ;inc  hl   ; negate next move. move back to size  
911e			 
911e			.newblock: 
911e				; need to be at marker here 
911e			 
911e					if DEBUG_FORTH_MALLOC_INT 
911e						DMARK "meN" 
911e						CALLMONITOR 
911e					endif 
911e			 
911e			 
911e				ld a, c 
911e			 
911e				ld (free_list+3), a	 ; flag resume from last malloc  
911e				ld (free_list), hl    ; save out last location 
911e			 
911e			 
911e				;inc a     ; space for length byte 
911e				ld (hl), a     ; save block in use marker 
911e			 
911e				inc hl   ; move to space marker 
911e				ld (hl), a    ; save new space 
911e			 
911e				inc hl   ; move to start of allocated area 
911e				 
911e			;	push hl     ; save where we are - 1  
911e			 
911e			;	inc hl  ; move past zero index  
911e				; skip space to set down new marker 
911e			 
911e				; provide some extra space for now 
911e			 
911e				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
911e				inc a 
911e				inc a 
911e			 
911e				push hl   ; save where we are in the node block 
911e			 
911e				call addatohl 
911e			 
911e				; write linked list point 
911e			 
911e				pop de     ; get our node position 
911e				ex de, hl 
911e			 
911e				ld (hl), e 
911e				inc hl 
911e				ld (hl), d 
911e			 
911e				inc hl 
911e			 
911e				; now at start of allocated data so save pointer 
911e			 
911e				push hl 
911e			 
911e				; jump to position of next node and setup empty header in DE 
911e			 
911e				ex de, hl 
911e			 
911e			;	inc hl ; move past end of block 
911e			 
911e				ld a, 0 
911e				ld (hl), a   ; empty marker 
911e				inc hl 
911e				ld (hl), a   ; size 
911e				inc hl  
911e				ld (hl), a   ; ptr 
911e				inc hl 
911e				ld (hl), a   ; ptr 
911e			 
911e			 
911e				pop hl 
911e			 
911e					if DEBUG_FORTH_MALLOC_INT 
911e						DMARK "mmr" 
911e						CALLMONITOR 
911e					endif 
911e			 
911e			.exit: 
911e				pop af 
911e				pop bc 
911e				pop de  
911e				ret 
911e			 
911e			 
911e			 
911e			 
911e			free:  
911e				push hl 
911e				push af 
911e				; get address in hl 
911e			 
911e					if DEBUG_FORTH_MALLOC_INT 
911e						DMARK "fre" 
911e						CALLMONITOR 
911e					endif 
911e				; data is at hl - move to block count 
911e				dec hl 
911e				dec hl    ; get past pointer 
911e				dec hl 
911e			 
911e				ld a, (hl)    ; need this for a validation check 
911e			 
911e				dec hl    ; move to block marker 
911e			 
911e				; now check that the block count and block marker are the same  
911e			        ; this checks that we are on a malloc node and not random memory 
911e			        ; OK a faint chance this could be a problem but rare - famous last words! 
911e			 
911e				ld c, a 
911e				ld a, (hl)    
911e			 
911e				cp c 
911e				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
911e			 
911e				; yes good chance we are on a malloc node 
911e			 
911e				ld a, 0      
911e				ld (hl), a   ; mark as free 
911e			 
911e				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
911e			 
911e			.freeignore:  
911e			 
911e				pop af 
911e				pop hl 
911e			 
911e				ret 
911e			 
911e			 
911e			 
911e			endif 
911e			 
911e			; eof 
# End of file firmware_memory.asm
911e			  
911e			; device C  
911e			if SOUND_ENABLE  
911e				include "firmware_sound.asm"  
911e			endif  
911e			  
911e			include "firmware_diags.asm"  
911e			; Hardware diags menu 
911e			 
911e			 
911e			config: 
911e			 
911e 3e 00			ld a, 0 
9120 21 4e 91			ld hl, .configmn 
9123 cd c2 88			call menu 
9126			 
9126 fe 00			cp 0 
9128 c8				ret z 
9129			 
9129 fe 01			cp 1 
912b cc 0d 92			call z, .savetostore 
912e			 
912e fe 02			cp 2 
9130 cc f9 91			call z, .selautoload 
9133 fe 03			cp 3 
9135 cc ef 91			call z, .disautoload 
9138 fe 04			cp 4 
913a cc 03 92			call z, .selbank 
913d fe 05			cp 5 
913f cc 2e 92			call z, .debug_tog 
9142 fe 06			cp 6 
9144 cc 76 93			call z, .bpsgo 
9147 fe 07			cp 7 
9149 cc 54 92			call z, hardware_diags 
914c			 
914c 18 d0			jr config 
914e			 
914e			.configmn: 
914e 5e 91			dw .c3 
9150 75 91			dw .c2 
9152 8a 91			dw .c2a 
9154 a0 91			dw .c2b 
9156			;	dw .c4 
9156 bd 91			dw .m4 
9158 d8 91			dw .m4b 
915a e0 91			dw .c1 
915c 00 00			dw 0 
915e				 
915e			 
915e .. 00		.c3: db "Add Dictionary To File",0 
9175 .. 00		.c2: db "Select Autoload File",0 
918a .. 00		.c2a: db "Disable Autoload File", 0 
91a0 .. 00		.c2b: db "Select Storage Bank",0 
91b4 .. 00		.c4: db "Settings",0 
91bd .. 00		.m4:   db "Debug & Breakpoints On/Off",0 
91d8 .. 00		.m4b:   db "Monitor",0 
91e0 .. 00		.c1: db "Hardware Diags",0 
91ef			 
91ef			 
91ef			.disautoload: 
91ef				if STORAGE_SE 
91ef				ld a, $fe      ; bit 0 clear 
91ef				ld (spi_device), a 
91ef			 
91ef				call storage_get_block_0 
91ef			 
91ef				ld a, 0 
91ef				ld (store_page+STORE_0_AUTOFILE), a 
91ef			 
91ef					ld hl, 0 
91ef					ld de, store_page 
91ef				call storage_write_block	 ; save update 
91ef				else 
91ef			 
91ef 21 17 92			ld hl, .notav 
91f2 11 2d 92			ld de, .empty 
91f5 cd 22 88			call info_panel 
91f8				endif 
91f8			 
91f8			 
91f8 c9				ret 
91f9			 
91f9			 
91f9			 
91f9			; Select auto start 
91f9			 
91f9			.selautoload: 
91f9			 
91f9				 
91f9				if STORAGE_SE 
91f9			 
91f9					call config_dir 
91f9				        ld hl, scratch 
91f9					ld a, 0 
91f9					call menu 
91f9			 
91f9					cp 0 
91f9					ret z 
91f9			 
91f9					dec a 
91f9			 
91f9			 
91f9					; locate menu option 
91f9			 
91f9					ld hl, scratch 
91f9					call table_lookup 
91f9			 
91f9					if DEBUG_FORTH_WORDS 
91f9						DMARK "ALl" 
91f9						CALLMONITOR 
91f9					endif 
91f9					; with the pointer to the menu it, the byte following the zero term is the file id 
91f9			 
91f9					ld a, 0 
91f9					ld bc, 50   ; max of bytes to look at 
91f9					cpir  
91f9			 
91f9					if DEBUG_FORTH_WORDS 
91f9						DMARK "ALb" 
91f9						CALLMONITOR 
91f9					endif 
91f9					;inc hl 
91f9			 
91f9					ld a, (hl)   ; file id 
91f9					 
91f9				        ; save bank and file ids 
91f9			 
91f9					push af 
91f9			 
91f9			; TODO need to save to block 0 on bank 1	 
91f9			 
91f9					call storage_get_block_0 
91f9			 
91f9					if DEBUG_FORTH_WORDS 
91f9						DMARK "AL0" 
91f9						CALLMONITOR 
91f9					endif 
91f9					pop af 
91f9			 
91f9					ld (store_page+STORE_0_FILERUN),a 
91f9					 
91f9					; save bank id 
91f9			 
91f9					ld a,(spi_device) 
91f9					ld (store_page+STORE_0_BANKRUN),a 
91f9			 
91f9					; enable auto run of store file 
91f9			 
91f9					ld a, 1 
91f9					ld (store_page+STORE_0_AUTOFILE),a 
91f9			 
91f9					; save buffer 
91f9			 
91f9					ld hl, 0 
91f9					ld de, store_page 
91f9					if DEBUG_FORTH_WORDS 
91f9						DMARK "ALw" 
91f9						CALLMONITOR 
91f9					endif 
91f9				call storage_write_block	 ; save update 
91f9			  
91f9			 
91f9			 
91f9			 
91f9					ld hl, scratch 
91f9					call config_fdir 
91f9			 
91f9				else 
91f9			 
91f9 21 17 92			ld hl, .notav 
91fc 11 2d 92			ld de, .empty 
91ff cd 22 88			call info_panel 
9202			 
9202				endif 
9202 c9				ret 
9203			 
9203			 
9203			 
9203			; Select storage bank 
9203			 
9203			.selbank: 
9203			 
9203				if STORAGE_SE 
9203				else 
9203			 
9203 21 17 92			ld hl, .notav 
9206 11 2d 92			ld de, .empty 
9209 cd 22 88			call info_panel 
920c				endif 
920c				 
920c c9				ret 
920d			 
920d			if STORAGE_SE 
920d			 
920d			.config_ldir:   
920d				; Load storage bank labels into menu array 
920d			 
920d				 
920d			 
920d			 
920d				ret 
920d			 
920d			 
920d			endif 
920d			 
920d			 
920d			; Save user words to storage 
920d			 
920d			.savetostore: 
920d			 
920d				if STORAGE_SE 
920d			 
920d					call config_dir 
920d				        ld hl, scratch 
920d					ld a, 0 
920d					call menu 
920d					 
920d					ld hl, scratch 
920d					call config_fdir 
920d			 
920d				else 
920d			 
920d 21 17 92			ld hl, .notav 
9210 11 2d 92			ld de, .empty 
9213 cd 22 88			call info_panel 
9216			 
9216				endif 
9216			 
9216 c9				ret 
9217 .. 00		.notav:    db "Feature not available",0 
922d .. 00		.empty:    db "",0 
922e			 
922e			 
922e			 
922e			if STORAGE_SE 
922e			 
922e			config_fdir: 
922e				; using the scratch dir go through and release the memory allocated for each string 
922e				 
922e				ld hl, scratch 
922e			.cfdir:	ld e,(hl) 
922e				inc hl 
922e				ld d,(hl) 
922e				inc hl 
922e			 
922e				ex de, hl 
922e				call ishlzero 
922e				ret z     ; return on null pointer 
922e				call free 
922e				ex de, hl 
922e				jr .cfdir 
922e			 
922e			 
922e				ret 
922e			 
922e			 
922e			config_dir: 
922e			 
922e				; for the config menus that need to build a directory of storage call this routine 
922e				; it will construct a menu in scratch to pass to menu 
922e			 
922e				; open storage device 
922e			 
922e				; execute DIR to build a list of files and their ids into scratch in menu format 
922e				; once the menu has finished then will need to call config_fdir to release the strings 
922e				 
922e				; c = number items 
922e			 
922e				 
922e				call storage_get_block_0 
922e			 
922e				ld hl, store_page     ; get current id count 
922e				ld b, (hl) 
922e				ld c, 0    ; count of files   
922e			 
922e			 
922e				ld hl, scratch 
922e				ld (store_tmp2), hl    ; location to poke strings 
922e			 
922e				; check for empty drive 
922e			 
922e				ld a, 0 
922e				cp b 
922e				jp z, .dirdone 
922e			 
922e				 
922e					if DEBUG_FORTH_WORDS 
922e						DMARK "Cdc" 
922e						CALLMONITOR 
922e					endif 
922e			 
922e			 
922e			.diritem:	 
922e				push bc 
922e				; for each of the current ids do a search for them and if found push to stack 
922e			 
922e					ld hl, STORE_BLOCK_PHY 
922e					ld d, 0		 ; look for extent 0 of block id as this contains file name 
922e					ld e,b 
922e			 
922e					call storage_findnextid 
922e			 
922e			 
922e					; if found hl will be non zero 
922e			 
922e					call ishlzero 
922e					jr z, .dirnotfound 
922e			 
922e					; increase count 
922e			 
922e					pop bc	 
922e					inc c 
922e					push bc 
922e					 
922e			 
922e					; get file header and push the file name 
922e			 
922e					ld de, store_page 
922e					call storage_read_block 
922e			 
922e					; push file id to stack 
922e				 
922e					ld a, (store_page) 
922e					ld h, 0 
922e					ld l, a 
922e			 
922e					;call forth_push_numhl 
922e					; TODO store id 
922e			 
922e					push hl 
922e			 
922e					; push extent count to stack  
922e				 
922e					ld hl, store_page+3 
922e			 
922e					; get file name length 
922e			 
922e					call strlenz   
922e			 
922e					inc hl   ; cover zero term 
922e					inc hl  ; stick the id at the end of the area 
922e			 
922e					push hl 
922e					pop bc    ; move length to bc 
922e			 
922e					call malloc 
922e			 
922e					; TODO save malloc area to scratch 
922e			 
922e					ex de, hl 
922e					ld hl, (store_tmp2) 
922e					ld (hl), e 
922e					inc hl 
922e					ld (hl), d 
922e					inc hl 
922e					ld (store_tmp2), hl 
922e			 
922e					 
922e			 
922e					;pop hl   ; get source 
922e			;		ex de, hl    ; swap aronund	 
922e			 
922e					ld hl, store_page+3 
922e					if DEBUG_FORTH_WORDS 
922e						DMARK "CFd" 
922e						CALLMONITOR 
922e					endif 
922e					ldir 
922e			 
922e					; de is past string, move back one and store id 
922e					 
922e					dec de 
922e			 
922e					; store file id 
922e			 
922e					pop hl 
922e					ex de,hl 
922e					ld (hl), e 
922e			 
922e					if DEBUG_FORTH_WORDS 
922e						DMARK "Cdi" 
922e						CALLMONITOR 
922e					endif 
922e					 
922e			.dirnotfound: 
922e					pop bc     
922e					djnz .diritem 
922e				 
922e			.dirdone:	 
922e			 
922e					ld a, 0 
922e					ld hl, (store_tmp2) 
922e					ld (hl), a 
922e					inc hl 
922e					ld (hl), a 
922e					inc hl 
922e					; push a count of the dir items found 
922e			 
922e			;		ld h, 0 
922e			;		ld l, c 
922e			 
922e				ret 
922e			 
922e			endif 
922e			 
922e			 
922e			; Settings 
922e			; Run  
922e			 
922e			 
922e			 
922e			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
922e			;;hd_menu2:   db "        2: Editor",0   
922e			;hd_menu2:   db "        2: Editor       6: Menu",0   
922e			;hd_menu3:   db "        3: Storage",0 
922e			;hd_menu4:   db "0=quit  4: Debug",0 
922e			;hd_don:     db "ON",0 
922e			;hd_doff:     db "OFF",0 
922e			; 
922e			; 
922e			; 
922e			;hardware_diags_old:       
922e			; 
922e			;.diagmenu: 
922e			;	call clear_display 
922e			;	ld a, display_row_1 
922e			;	ld de, hd_menu1 
922e			;	call str_at_display 
922e			; 
922e			;	ld a, display_row_2 
922e			;	ld de, hd_menu2 
922e			;	call str_at_display 
922e			; 
922e			;	ld a, display_row_3 
922e			;	ld de, hd_menu3 
922e			;	call str_at_display 
922e			; 
922e			;	ld a,  display_row_4 
922e			;	ld de, hd_menu4 
922e			;	call str_at_display 
922e			; 
922e			;	; display debug state 
922e			; 
922e			;	ld de, hd_don 
922e			;	ld a, (os_view_disable) 
922e			;	cp 0 
922e			;	jr z, .distog 
922e			;	ld de, hd_doff 
922e			;.distog: ld a, display_row_4+17 
922e			;	call str_at_display 
922e			; 
922e			;	call update_display 
922e			; 
922e			;	call cin_wait 
922e			; 
922e			; 
922e			; 
922e			;	cp '4' 
922e			;	jr nz, .diagn1 
922e			; 
922e			;	; debug toggle 
922e			; 
922e			;	ld a, (os_view_disable) 
922e			;	ld b, '*' 
922e			;	cp 0 
922e			;	jr z, .debtog 
922e			;	ld b, 0 
922e			;.debtog:	 
922e			;	ld a,b 
922e			;	ld (os_view_disable),a 
922e			; 
922e			;.diagn1: cp '0' 
922e			;	 ret z 
922e			; 
922e			;;	cp '1' 
922e			;;       jp z, matrix	 
922e			;;   TODO keyboard matrix test 
922e			; 
922e			;	cp '2' 
922e			;	jp z, .diagedit 
922e			; 
922e			;;	cp '6' 
922e			;;	jp z, .menutest 
922e			;;if ENABLE_BASIC 
922e			;;	cp '6' 
922e			;;	jp z, basic 
922e			;;endif 
922e			 ; 
922e			;	jp .diagmenu 
922e			; 
922e			; 
922e			;	ret 
922e			 
922e			 
922e			.debug_tog: 
922e 21 75 92			ld hl, .menudebug 
9231				 
9231 3a 51 e3			ld a, (os_view_disable) 
9234 fe 2a			cp '*' 
9236 20 04			jr nz,.tdon  
9238 3e 01			ld a, 1 
923a 18 02			jr .tog1 
923c 3e 00		.tdon: ld a, 0 
923e			 
923e			.tog1: 
923e cd c2 88			call menu 
9241 fe 00			cp 0 
9243 c8				ret z 
9244 fe 01			cp 1    ; disable debug 
9246 28 04			jr z, .dtog0 
9248 3e 2a			ld a, '*' 
924a 18 02			jr .dtogset 
924c 3e 00		.dtog0: ld a, 0 
924e 32 51 e3		.dtogset:  ld (os_view_disable), a 
9251 c3 2e 92			jp .debug_tog 
9254			 
9254			 
9254			hardware_diags:       
9254			 
9254			.diagm: 
9254 21 67 92			ld hl, .menuitems 
9257 3e 00			ld a, 0 
9259 cd c2 88			call menu 
925c			 
925c fe 00		         cp 0 
925e c8				 ret z 
925f			 
925f fe 02			cp 2 
9261 ca c0 92			jp z, .diagedit 
9264			 
9264			;	cp '6' 
9264			;	jp z, .menutest 
9264			;if ENABLE_BASIC 
9264			;	cp '6' 
9264			;	jp z, basic 
9264			;endif 
9264			  
9264 c3 54 92			jp .diagm 
9267			 
9267				 
9267 7b 92		.menuitems:   	dw .m1 
9269 86 92				dw .m2 
926b 8d 92				dw .m3 
926d 95 92				dw .m5 
926f 9b 92				dw .m5a 
9271 a4 92				dw .m5b 
9273 00 00				dw 0 
9275			 
9275			.menudebug: 
9275 ad 92				dw .m6 
9277 b6 92				dw .m7 
9279 00 00				dw 0 
927b			 
927b .. 00		.m1:   db "Key Matrix",0 
9286 .. 00		.m2:   db "Editor",0 
928d .. 00		.m3:   db "Storage",0 
9295 .. 00		.m5:   db "Sound",0 
929b .. 00		.m5a:  db "RAM Test",0 
92a4 .. 00		.m5b:  db "LCD Test",0 
92ad			 
92ad .. 00		.m6:   db "Debug ON",0 
92b6 .. 00		.m7:   db "Debug OFF",0 
92c0			 
92c0			; debug editor 
92c0			 
92c0			.diagedit: 
92c0			 
92c0 21 60 e3			ld hl, scratch 
92c3			;	ld bc, 250 
92c3			;	ldir 
92c3				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
92c3 3e 00			ld a, 0 
92c5 77				ld (hl), a 
92c6 23				inc hl 
92c7 77				ld (hl), a 
92c8 23				inc hl 
92c9 77				ld (hl), a 
92ca			 
92ca cd 91 88		        call clear_display 
92cd cd b4 88			call update_display 
92d0 3e 01			ld a, 1 
92d2 32 80 ee			ld (hardware_diag), a 
92d5			.diloop: 
92d5 3e 00			ld a, display_row_1 
92d7 0e 00			ld c, 0 
92d9 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
92db 1e 28			ld e, 40 
92dd			 
92dd 21 60 e3			ld hl, scratch	 
92e0 cd eb 8a			call input_str 
92e3			 
92e3 3e 28			ld a, display_row_2 
92e5 11 60 e3			ld de, scratch 
92e8 cd a4 88			call str_at_display 
92eb cd b4 88			call update_display 
92ee			 
92ee c3 d5 92			jp .diloop 
92f1			 
92f1			 
92f1			; pass word in hl 
92f1			; a has display location 
92f1			display_word_at: 
92f1 f5				push af 
92f2 e5				push hl 
92f3 7c				ld a,h 
92f4 21 65 e6			ld hl, os_word_scratch 
92f7 cd bf 8d			call hexout 
92fa e1				pop hl 
92fb 7d				ld a,l 
92fc 21 67 e6			ld hl, os_word_scratch+2 
92ff cd bf 8d			call hexout 
9302 21 69 e6			ld hl, os_word_scratch+4 
9305 3e 00			ld a,0 
9307 77				ld (hl),a 
9308 11 65 e6			ld de,os_word_scratch 
930b f1				pop af 
930c cd a4 88				call str_at_display 
930f c9				ret 
9310			 
9310			display_ptr_state: 
9310			 
9310				; to restore afterwards 
9310			 
9310 d5				push de 
9311 c5				push bc 
9312 e5				push hl 
9313 f5				push af 
9314			 
9314				; for use in here 
9314			 
9314			;	push bc 
9314			;	push de 
9314			;	push hl 
9314			;	push af 
9314			 
9314 cd 91 88			call clear_display 
9317			 
9317 11 ea 94			ld de, .ptrstate 
931a 3e 00			ld a, display_row_1 
931c cd a4 88			call str_at_display 
931f			 
931f				; display debug step 
931f			 
931f			 
931f 11 7a ee			ld de, debug_mark 
9322 3e 26			ld a, display_row_1+display_cols-2 
9324 cd a4 88			call str_at_display 
9327			 
9327				; display a 
9327 11 f4 94			ld de, .ptrcliptr 
932a 3e 28			ld a, display_row_2 
932c cd a4 88			call str_at_display 
932f			 
932f f1				pop af 
9330 2a 2b eb			ld hl,(cli_ptr) 
9333 3e 30			ld a, display_row_2+8 
9335 cd f1 92			call display_word_at 
9338			 
9338			 
9338				; display hl 
9338			 
9338			 
9338 11 fc 94			ld de, .ptrclioptr 
933b 3e 32			ld a, display_row_2+10 
933d cd a4 88			call str_at_display 
9340			; 
9340			;	pop hl 
9340 3e 35			ld a, display_row_2+13 
9342 2a 29 eb			ld hl,(cli_origptr) 
9345 cd f1 92			call display_word_at 
9348			; 
9348			;	 
9348			;	; display de 
9348			 
9348			;	ld de, .regstatede 
9348			;	ld a, display_row_3 
9348			;	call str_at_display 
9348			 
9348			;	pop de 
9348			;	ld h,d 
9348			;	ld l, e 
9348			;	ld a, display_row_3+3 
9348			;	call display_word_at 
9348			 
9348			 
9348				; display bc 
9348			 
9348			;	ld de, .regstatebc 
9348			;	ld a, display_row_3+10 
9348			;	call str_at_display 
9348			 
9348			;	pop bc 
9348			;	ld h,b 
9348			;	ld l, c 
9348			;	ld a, display_row_3+13 
9348			;	call display_word_at 
9348			 
9348			 
9348				; display dsp 
9348			 
9348			;	ld de, .regstatedsp 
9348			;	ld a, display_row_4 
9348			;	call str_at_display 
9348			 
9348				 
9348			;	ld hl,(cli_data_sp) 
9348			;	ld a, display_row_4+4 
9348			;	call display_word_at 
9348			 
9348				; display rsp 
9348			 
9348 11 2b 95			ld de, .regstatersp 
934b 3e 82			ld a, display_row_4+10 
934d cd a4 88			call str_at_display 
9350			 
9350				 
9350 2a 11 eb			ld hl,(cli_ret_sp) 
9353 3e 86			ld a, display_row_4+14 
9355 cd f1 92			call display_word_at 
9358			 
9358 cd b4 88			call update_display 
935b			 
935b cd 0e 88			call delay1s 
935e cd 0e 88			call delay1s 
9361 cd 0e 88			call delay1s 
9364			 
9364			 
9364 cd 71 98			call next_page_prompt 
9367			 
9367				; restore  
9367			 
9367 f1				pop af 
9368 e1				pop hl 
9369 c1				pop bc 
936a d1				pop de 
936b c9				ret 
936c			 
936c			break_point_state: 
936c f5				push af 
936d			 
936d				; see if disabled 
936d			 
936d 3a 51 e3			ld a, (os_view_disable) 
9370 fe 2a			cp '*' 
9372 20 02			jr nz, .bpsgo 
9374 f1				pop af 
9375 c9				ret 
9376			 
9376			.bpsgo: 
9376 f1				pop af 
9377 f5				push af 
9378 22 4d e3			ld (os_view_hl), hl 
937b ed 53 4b e3		ld (os_view_de), de 
937f ed 43 49 e3		ld (os_view_bc), bc 
9383 e5				push hl 
9384 6f				ld l, a 
9385 26 00			ld h, 0 
9387 22 4f e3			ld (os_view_af),hl 
938a			 
938a 21 c0 ed				ld hl, display_fb0 
938d 22 db eb				ld (display_fb_active), hl 
9390 e1				pop hl	 
9391			 
9391 3e 31			ld a, '1' 
9393 fe 2a		.bps1:  cp '*' 
9395 20 03			jr nz, .bps1b 
9397 32 51 e3			ld (os_view_disable),a 
939a fe 31		.bps1b:  cp '1' 
939c 20 14			jr nz, .bps2 
939e			 
939e				; display reg 
939e			 
939e				 
939e			 
939e 3a 4f e3			ld a, (os_view_af) 
93a1 2a 4d e3			ld hl, (os_view_hl) 
93a4 ed 5b 4b e3		ld de, (os_view_de) 
93a8 ed 4b 49 e3		ld bc, (os_view_bc) 
93ac cd 46 94			call display_reg_state 
93af c3 32 94			jp .bpschk 
93b2			 
93b2 fe 32		.bps2:  cp '2' 
93b4 20 08			jr nz, .bps3 
93b6				 
93b6				; display hl 
93b6 2a 4d e3			ld hl, (os_view_hl) 
93b9 cd 30 95			call display_dump_at_hl 
93bc			 
93bc 18 74			jr .bpschk 
93be			 
93be fe 33		.bps3:  cp '3' 
93c0 20 08			jr nz, .bps4 
93c2			 
93c2			        ; display de 
93c2 2a 4b e3			ld hl, (os_view_de) 
93c5 cd 30 95			call display_dump_at_hl 
93c8			 
93c8 18 68			jr .bpschk 
93ca fe 34		.bps4:  cp '4' 
93cc 20 08			jr nz, .bps5 
93ce			 
93ce			        ; display bc 
93ce 2a 49 e3			ld hl, (os_view_bc) 
93d1 cd 30 95			call display_dump_at_hl 
93d4			 
93d4 18 5c			jr .bpschk 
93d6 fe 35		.bps5:  cp '5' 
93d8 20 08		        jr nz, .bps7 
93da			 
93da				; display cur ptr 
93da 2a 2b eb			ld hl, (cli_ptr) 
93dd cd 30 95			call display_dump_at_hl 
93e0			 
93e0 18 50			jr .bpschk 
93e2 fe 36		.bps7:  cp '6' 
93e4 20 08			jr nz, .bps8b 
93e6				 
93e6				; display cur orig ptr 
93e6 2a 29 eb			ld hl, (cli_origptr) 
93e9 cd 30 95			call display_dump_at_hl 
93ec 18 44			jr .bpschk 
93ee fe 37		.bps8b:  cp '7' 
93f0 20 08			jr nz, .bps9 
93f2				 
93f2				; display dsp 
93f2 2a 0d eb			ld hl, (cli_data_sp) 
93f5 cd 30 95			call display_dump_at_hl 
93f8			 
93f8 18 38			jr .bpschk 
93fa fe 39		.bps9:  cp '9' 
93fc 20 05			jr nz, .bps8c 
93fe				 
93fe				; display SP 
93fe			;	ld hl, sp 
93fe cd 30 95			call display_dump_at_hl 
9401			 
9401 18 2f			jr .bpschk 
9403 fe 38		.bps8c:  cp '8' 
9405 20 08			jr nz, .bps8d 
9407				 
9407				; display rsp 
9407 2a 11 eb			ld hl, (cli_ret_sp) 
940a cd 30 95			call display_dump_at_hl 
940d			 
940d 18 23			jr .bpschk 
940f fe 23		.bps8d:  cp '#'     ; access monitor sub system 
9411 20 05			jr nz, .bps8 
9413 cd 67 96			call monitor 
9416			 
9416 18 1a			jr .bpschk 
9418 fe 30		.bps8:  cp '0' 
941a 20 16			jr nz, .bpschk 
941c			 
941c 21 1f ed				ld hl, display_fb1 
941f 22 db eb				ld (display_fb_active), hl 
9422 cd b4 88				call update_display 
9425			 
9425				;ld a, (os_view_af) 
9425 2a 4d e3			ld hl, (os_view_hl) 
9428 ed 5b 4b e3		ld de, (os_view_de) 
942c ed 4b 49 e3		ld bc, (os_view_bc) 
9430 f1				pop af 
9431 c9				ret 
9432			 
9432			.bpschk:   
9432 cd 0e 88			call delay1s 
9435 3e 9f		ld a,display_row_4 + display_cols - 1 
9437 11 6f 98		        ld de, endprg 
943a cd a4 88			call str_at_display 
943d cd b4 88			call update_display 
9440 cd ca d7			call cin_wait 
9443			 
9443 c3 93 93			jp .bps1 
9446			 
9446			 
9446			display_reg_state: 
9446			 
9446				; to restore afterwards 
9446			 
9446 d5				push de 
9447 c5				push bc 
9448 e5				push hl 
9449 f5				push af 
944a			 
944a				; for use in here 
944a			 
944a c5				push bc 
944b d5				push de 
944c e5				push hl 
944d f5				push af 
944e			 
944e cd 91 88			call clear_display 
9451			 
9451 11 06 95			ld de, .regstate 
9454 3e 00			ld a, display_row_1 
9456 cd a4 88			call str_at_display 
9459			 
9459				; display debug step 
9459			 
9459			 
9459 11 7a ee			ld de, debug_mark 
945c 3e 25			ld a, display_row_1+display_cols-3 
945e cd a4 88			call str_at_display 
9461			 
9461				; display a 
9461 11 22 95			ld de, .regstatea 
9464 3e 28			ld a, display_row_2 
9466 cd a4 88			call str_at_display 
9469			 
9469 e1				pop hl 
946a			;	ld h,0 
946a			;	ld l, a 
946a 3e 2b			ld a, display_row_2+3 
946c cd f1 92			call display_word_at 
946f			 
946f			 
946f				; display hl 
946f			 
946f			 
946f 11 16 95			ld de, .regstatehl 
9472 3e 32			ld a, display_row_2+10 
9474 cd a4 88			call str_at_display 
9477			 
9477 e1				pop hl 
9478 3e 35			ld a, display_row_2+13 
947a cd f1 92			call display_word_at 
947d			 
947d				 
947d				; display de 
947d			 
947d 11 1a 95			ld de, .regstatede 
9480 3e 50			ld a, display_row_3 
9482 cd a4 88			call str_at_display 
9485			 
9485 e1				pop hl 
9486			;	ld h,d 
9486			;	ld l, e 
9486 3e 53			ld a, display_row_3+3 
9488 cd f1 92			call display_word_at 
948b			 
948b			 
948b				; display bc 
948b			 
948b 11 1e 95			ld de, .regstatebc 
948e 3e 5a			ld a, display_row_3+10 
9490 cd a4 88			call str_at_display 
9493			 
9493 e1				pop hl 
9494			;	ld h,b 
9494			;	ld l, c 
9494 3e 5d			ld a, display_row_3+13 
9496 cd f1 92			call display_word_at 
9499			 
9499			 
9499				; display dsp 
9499			 
9499 11 26 95			ld de, .regstatedsp 
949c 3e 78			ld a, display_row_4 
949e cd a4 88			call str_at_display 
94a1			 
94a1				 
94a1 2a 0d eb			ld hl,(cli_data_sp) 
94a4 3e 7c			ld a, display_row_4+4 
94a6 cd f1 92			call display_word_at 
94a9			 
94a9				; display rsp 
94a9			 
94a9 11 2b 95			ld de, .regstatersp 
94ac 3e 82			ld a, display_row_4+10 
94ae cd a4 88			call str_at_display 
94b1			 
94b1				 
94b1 2a 11 eb			ld hl,(cli_ret_sp) 
94b4 3e 86			ld a, display_row_4+14 
94b6 cd f1 92			call display_word_at 
94b9			 
94b9 cd b4 88			call update_display 
94bc			 
94bc			;	call delay1s 
94bc			;	call delay1s 
94bc			;	call delay1s 
94bc			 
94bc			 
94bc			;	call next_page_prompt 
94bc			 
94bc				; restore  
94bc			 
94bc f1				pop af 
94bd e1				pop hl 
94be c1				pop bc 
94bf d1				pop de 
94c0 c9				ret 
94c1			 
94c1 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
94d5 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
94ea .. 00		.ptrstate:	db "Ptr State",0 
94f4 .. 00		.ptrcliptr:     db "cli_ptr",0 
94fc .. 00		.ptrclioptr:     db "cli_o_ptr",0 
9506 .. 00		.regstate:	db "Reg State (1/0)",0 
9516 .. 00		.regstatehl:	db "HL:",0 
951a .. 00		.regstatede:	db "DE:",0 
951e .. 00		.regstatebc:	db "BC:",0 
9522 .. 00		.regstatea:	db "A :",0 
9526 .. 00		.regstatedsp:	db "DSP:",0 
952b .. 00		.regstatersp:	db "RSP:",0 
9530			 
9530			display_dump_at_hl: 
9530 e5				push hl 
9531 d5				push de 
9532 c5				push bc 
9533 f5				push af 
9534			 
9534 22 83 e6			ld (os_cur_ptr),hl	 
9537 cd 91 88			call clear_display 
953a cd 79 97			call dumpcont 
953d			;	call delay1s 
953d			;	call next_page_prompt 
953d			 
953d			 
953d f1				pop af 
953e c1				pop bc 
953f d1				pop de 
9540 e1				pop hl 
9541 c9				ret 
9542			 
9542			;if ENABLE_BASIC 
9542			;	include "nascombasic.asm" 
9542			;	basic: 
9542			;	include "forth/FORTH.ASM" 
9542			;endif 
9542			 
9542			; eof 
9542			 
9542			 
# End of file firmware_diags.asm
9542			  
9542			  
9542			  
9542			  
9542			; eof  
9542			  
# End of file firmware.asm
9542			 
9542			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
9542			;if BASE_KEV  
9542			;baseram: equ 08000h 
9542			;endif 
9542			 
9542			;if BASE_SC114 
9542			;baseram:     equ    endofcode 
9542			;endif 
9542			 
9542			 
9542			; start system 
9542			 
9542			coldstart: 
9542				; set sp 
9542				; di/ei 
9542			 
9542 f3				di 
9543 31 00 f0			ld sp, tos 
9546			;	ei 
9546			 
9546			 
9546				; disable breakpoint by default 
9546			 
9546 3e 2a			ld a,'*' 
9548 32 51 e3			ld (os_view_disable),a 
954b			 
954b				; init hardware 
954b			 
954b				; init keyboard and screen hardware 
954b			 
954b cd 03 80			call hardware_init 
954e			 
954e			 
954e				; detect if any keys are held down to enable breakpoints at start up 
954e			 
954e cd d0 d7			call cin  
9551 fe 00			cp 0 
9553 28 03			jr z, .nokeys 
9555			 
9555				;call hardware_diags 
9555 cd 1e 91			call config 
9558			 
9558			;	ld de, .bpen 
9558			;	ld a, display_row_4 
9558			;	call str_at_display 
9558			;	call update_display 
9558			; 
9558			;	ld a,0 
9558			;	ld (os_view_disable),a 
9558			; 
9558			;.bpwait: 
9558			;	call cin 
9558			;	cp 0 
9558			;	jr z, .bpwait 
9558			;	jr .nokeys 
9558			; 
9558			; 
9558			;.bpen:  db "Break points enabled!",0 
9558			 
9558			 
9558			 
9558			 
9558			 
9558			 
9558			.nokeys: 
9558			 
9558			 
9558				 
9558			 
9558			;jp  testkey 
9558			 
9558			;call storage_get_block_0 
9558			; 
9558			;ld hl, 0 
9558			;ld de, store_page 
9558			;call storage_read_block 
9558			 
9558				 
9558			;ld hl, 10 
9558			;ld de, store_page 
9558			;call storage_read_block 
9558			 
9558			 
9558			 
9558			 
9558			 
9558			;stop:	nop 
9558			;	jp stop 
9558			 
9558			 
9558			 
9558			main: 
9558 cd 91 88			call clear_display 
955b cd b4 88			call update_display 
955e			 
955e			 
955e			 
955e			;	call testlcd 
955e			 
955e			 
955e			 
955e cd 37 9c			call forth_init 
9561			 
9561			 
9561			warmstart: 
9561 cd 0d 9c			call forth_warmstart 
9564			 
9564				; run startup word load 
9564			        ; TODO prevent this running at warmstart after crash  
9564			 
9564				if STARTUP_ENABLE 
9564					if STORAGE_SE 
9564						call forth_autoload 
9564					endif 
9564 cd 64 d4				call forth_startup 
9567			 
9567			 
9567				endif 
9567			 
9567				; show free memory after boot 
9567 11 01 96			ld de, freeram 
956a 3e 00			ld a, display_row_1 
956c cd a4 88			call str_at_display 
956f			 
956f			; Or use heap_size word???? 
956f 21 46 e3			ld hl, heap_end 
9572 11 ee d7			ld de, heap_start 
9575 ed 52			sbc hl, de 
9577 e5				push hl 
9578 7c				ld a,h	         	 
9579 21 65 e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
957c cd bf 8d			call hexout 
957f e1			   	pop hl 
9580			 
9580 7d				ld a,l 
9581 21 67 e6			ld hl, os_word_scratch+2 
9584 cd bf 8d			call hexout 
9587 21 69 e6			ld hl, os_word_scratch+4 
958a 3e 00			ld a, 0 
958c 77				ld (hl),a 
958d 11 65 e6			ld de, os_word_scratch 
9590 3e 0d			ld a, display_row_1 + 13 
9592 cd a4 88			call str_at_display 
9595 cd b4 88			call update_display 
9598			 
9598			 
9598				;call demo 
9598			 
9598			 
9598				; init scratch input area for cli commands 
9598			 
9598 21 87 e6			ld hl, os_cli_cmd 
959b 3e 00			ld a,0 
959d 77				ld (hl),a 
959e 23				inc hl 
959f 77				ld (hl),a 
95a0			 
95a0 3e 00			ld a,0 
95a2 32 86 e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
95a5			 
95a5 32 83 e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
95a8 32 84 e6			ld (os_cur_ptr+1),a	 
95ab			 
95ab 32 65 e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
95ae 32 66 e6			ld (os_word_scratch+1),a	 
95b1				 
95b1			 
95b1				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
95b1 21 87 e6			ld hl, os_cli_cmd 
95b4			 
95b4 3e 00			ld a, 0		 ; init cli input 
95b6 77				ld (hl), a 
95b7 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
95b9			cli: 
95b9				; show cli prompt 
95b9				;push af 
95b9				;ld a, 0 
95b9				;ld de, prompt 
95b9				;call str_at_display 
95b9			 
95b9				;call update_display 
95b9				;pop af 
95b9				;inc a 
95b9				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
95b9 0e 00			ld c, 0 
95bb 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
95bd 1e 28			ld e, 40 
95bf			 
95bf 21 87 e6			ld hl, os_cli_cmd 
95c2			 
95c2				STACKFRAME OFF $fefe $9f9f 
95c2				if DEBUG_STACK_IMB 
95c2					if OFF 
95c2						exx 
95c2						ld de, $fefe 
95c2						ld a, d 
95c2						ld hl, curframe 
95c2						call hexout 
95c2						ld a, e 
95c2						ld hl, curframe+2 
95c2						call hexout 
95c2						ld hl, $fefe 
95c2						push hl 
95c2						ld hl, $9f9f 
95c2						push hl 
95c2						exx 
95c2					endif 
95c2				endif 
95c2			endm 
# End of macro STACKFRAME
95c2			 
95c2 cd eb 8a			call input_str 
95c5			 
95c5				STACKFRAMECHK OFF $fefe $9f9f 
95c5				if DEBUG_STACK_IMB 
95c5					if OFF 
95c5						exx 
95c5						ld hl, $9f9f 
95c5						pop de   ; $9f9f 
95c5						call cmp16 
95c5						jr nz, .spnosame 
95c5						ld hl, $fefe 
95c5						pop de   ; $fefe 
95c5						call cmp16 
95c5						jr z, .spfrsame 
95c5						.spnosame: call showsperror 
95c5						.spfrsame: nop 
95c5						exx 
95c5					endif 
95c5				endif 
95c5			endm 
# End of macro STACKFRAMECHK
95c5			 
95c5				; copy input to last command 
95c5			 
95c5 21 87 e6			ld hl, os_cli_cmd 
95c8 11 86 e7			ld de, os_last_cmd 
95cb 01 ff 00			ld bc, 255 
95ce ed b0			ldir 
95d0			 
95d0				; wipe current buffer 
95d0			 
95d0			;	ld a, 0 
95d0			;	ld hl, os_cli_cmd 
95d0			;	ld de, os_cli_cmd+1 
95d0			;	ld bc, 254 
95d0			;	ldir 
95d0				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
95d0			;	call strcpy 
95d0			;	ld a, 0 
95d0			;	ld (hl), a 
95d0			;	inc hl 
95d0			;	ld (hl), a 
95d0			;	inc hl 
95d0			;	ld (hl), a 
95d0			 
95d0				; switch frame buffer to program  
95d0			 
95d0 21 1f ed				ld hl, display_fb1 
95d3 22 db eb				ld (display_fb_active), hl 
95d6			 
95d6			;	nop 
95d6				STACKFRAME ON $fbfe $8f9f 
95d6				if DEBUG_STACK_IMB 
95d6					if ON 
95d6						exx 
95d6						ld de, $fbfe 
95d6						ld a, d 
95d6						ld hl, curframe 
95d6						call hexout 
95d6						ld a, e 
95d6						ld hl, curframe+2 
95d6						call hexout 
95d6						ld hl, $fbfe 
95d6						push hl 
95d6						ld hl, $8f9f 
95d6						push hl 
95d6						exx 
95d6					endif 
95d6				endif 
95d6			endm 
# End of macro STACKFRAME
95d6				; first time into the parser so pass over the current scratch pad 
95d6 21 87 e6			ld hl,os_cli_cmd 
95d9				; tokenise the entered statement(s) in HL 
95d9 cd b0 9c			call forthparse 
95dc			        ; exec forth statements in top of return stack 
95dc cd f0 9c			call forthexec 
95df				;call forthexec_cleanup 
95df			;	call parsenext 
95df			 
95df				STACKFRAMECHK ON $fbfe $8f9f 
95df				if DEBUG_STACK_IMB 
95df					if ON 
95df						exx 
95df						ld hl, $8f9f 
95df						pop de   ; $8f9f 
95df						call cmp16 
95df						jr nz, .spnosame 
95df						ld hl, $fbfe 
95df						pop de   ; $fbfe 
95df						call cmp16 
95df						jr z, .spfrsame 
95df						.spnosame: call showsperror 
95df						.spfrsame: nop 
95df						exx 
95df					endif 
95df				endif 
95df			endm 
# End of macro STACKFRAMECHK
95df				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
95df			 
95df 3e 78			ld a, display_row_4 
95e1 11 13 96			ld de, endprog 
95e4			 
95e4 cd b4 88			call update_display		 
95e7			 
95e7 cd 71 98			call next_page_prompt 
95ea			 
95ea				; switch frame buffer to cli 
95ea			 
95ea 21 c0 ed				ld hl, display_fb0 
95ed 22 db eb				ld (display_fb_active), hl 
95f0			 
95f0			 
95f0 cd 91 88		        call clear_display 
95f3 cd b4 88			call update_display		 
95f6			 
95f6 21 87 e6			ld hl, os_cli_cmd 
95f9			 
95f9 3e 00			ld a, 0		 ; init cli input 
95fb 77				ld (hl), a 
95fc			 
95fc				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
95fc			 
95fc				; now on last line 
95fc			 
95fc				; TODO scroll screen up 
95fc			 
95fc				; TODO instead just clear screen and place at top of screen 
95fc			 
95fc			;	ld a, 0 
95fc			;	ld (f_cursor_ptr),a 
95fc			 
95fc				;call clear_display 
95fc				;call update_display 
95fc			 
95fc				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
95fc 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
95fe c3 b9 95			jp cli 
9601			 
9601 .. 00		freeram: db "Free bytes: $",0 
960f ..			asc: db "1A2F" 
9613 .. 00		endprog: db "End prog...",0 
961f			 
961f			testenter2:   
961f 21 92 e3			ld hl,scratch+50 
9622 22 83 e6			ld (os_cur_ptr),hl 
9625 c3 b9 95			jp cli 
9628			 
9628			testenter:  
9628			 
9628 21 0f 96			ld hl,asc 
962b			;	ld a,(hl) 
962b			;	call nibble2val 
962b cd 15 8e			call get_byte 
962e			 
962e			 
962e			;	ld a,(hl) 
962e			;	call atohex 
962e			 
962e			;	call fourehexhl 
962e 32 92 e3			ld (scratch+50),a 
9631			 
9631			 
9631			 
9631 21 11 96			ld hl,asc+2 
9634			;	ld a, (hl) 
9634			;	call nibble2val 
9634 cd 15 8e			call get_byte 
9637			 
9637			;	call fourehexhl 
9637 32 94 e3			ld (scratch+52),a 
963a				 
963a 21 92 e3			ld hl,scratch+50 
963d 22 83 e6			ld (os_cur_ptr),hl 
9640 c3 b9 95			jp cli 
9643			 
9643			enter:	 
9643 3a 64 e3			ld a,(scratch+4) 
9646 fe 00			cp 0 
9648 28 0c			jr z, .entercont 
964a				; no, not a null term line so has an address to work out.... 
964a			 
964a 21 62 e3			ld hl,scratch+2 
964d cd 75 8e			call get_word_hl 
9650			 
9650 22 83 e6			ld (os_cur_ptr),hl	 
9653 c3 b9 95			jp cli 
9656			 
9656			 
9656			.entercont:  
9656			 
9656 21 62 e3			ld hl, scratch+2 
9659 cd 15 8e			call get_byte 
965c			 
965c 2a 83 e6		   	ld hl,(os_cur_ptr) 
965f 77					ld (hl),a 
9660 23					inc hl 
9661 22 83 e6				ld (os_cur_ptr),hl 
9664				 
9664			; get byte  
9664			 
9664			 
9664 c3 b9 95			jp cli 
9667			 
9667			 
9667			; basic monitor support 
9667			 
9667			monitor: 
9667				;  
9667 cd 91 88			call clear_display 
966a 3e 00			ld a, 0 
966c 11 b4 96			ld de, .monprompt 
966f cd a4 88			call str_at_display 
9672 cd b4 88			call update_display 
9675			 
9675				; get a monitor command 
9675			 
9675 0e 00			ld c, 0     ; entry at top left 
9677 16 64			ld d, 100   ; max buffer size 
9679 1e 0f			ld e, 15    ; input scroll area 
967b 3e 00			ld a, 0     ; init string 
967d 21 5e e5			ld hl, os_input 
9680 77				ld (hl), a 
9681 23				inc hl 
9682 77				ld (hl), a 
9683 21 5e e5			ld hl, os_input 
9686 3e 01			ld a, 1     ; init string 
9688 cd eb 8a			call input_str 
968b			 
968b cd 91 88		        call clear_display 
968e cd b4 88			call update_display		 
9691			 
9691 3a 5e e5			ld a, (os_input) 
9694 cd 13 8f			call toUpper 
9697 fe 48		        cp 'H' 
9699 28 6f		        jr z, .monhelp 
969b fe 44			cp 'D'		; dump 
969d ca 2b 97			jp z, .mondump	 
96a0 fe 43			cp 'C'		; dump 
96a2 ca 45 97			jp z, .moncdump	 
96a5 fe 4d			cp 'M'		; dump 
96a7 ca b6 96			jp z, .moneditstart 
96aa fe 55			cp 'U'		; dump 
96ac 28 14			jr z, .monedit	 
96ae fe 51			cp 'Q'		; dump 
96b0 c8				ret z	 
96b1			 
96b1			 
96b1				; TODO "S" to access symbol by name and not need the address 
96b1				; TODO "F" to find a string in memory 
96b1			 
96b1 c3 67 96			jp monitor 
96b4			 
96b4 .. 00		.monprompt: db ">", 0 
96b6			 
96b6			.moneditstart: 
96b6				; get starting address 
96b6			 
96b6 21 60 e5			ld hl,os_input+2 
96b9 cd 75 8e			call get_word_hl 
96bc			 
96bc 22 83 e6			ld (os_cur_ptr),hl	 
96bf			 
96bf c3 67 96			jp monitor 
96c2			 
96c2			.monedit: 
96c2				; get byte to load 
96c2			 
96c2 21 60 e5			ld hl,os_input+2 
96c5 cd 15 8e			call get_byte 
96c8			 
96c8				; get address to update 
96c8 2a 83 e6			ld hl, (os_cur_ptr) 
96cb			 
96cb				; update byte 
96cb			 
96cb 77				ld (hl), a 
96cc			 
96cc				; move to next address and save it 
96cc			 
96cc 23				inc hl 
96cd 22 83 e6			ld (os_cur_ptr),hl	 
96d0			 
96d0 c3 67 96			jp monitor 
96d3			 
96d3			 
96d3 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
96e7 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
9703 .. 00		.monhelptext3:  db "Q-Quit",0 
970a			        
970a			.monhelp: 
970a 3e 00			ld a, display_row_1 
970c 11 d3 96		        ld de, .monhelptext1 
970f			 
970f cd a4 88			call str_at_display 
9712 3e 28			ld a, display_row_2 
9714 11 e7 96		        ld de, .monhelptext2 
9717					 
9717 cd a4 88			call str_at_display 
971a 3e 50			ld a, display_row_3 
971c 11 03 97		        ld de, .monhelptext3 
971f					 
971f cd a4 88			call str_at_display 
9722 cd b4 88			call update_display		 
9725			 
9725 cd 71 98			call next_page_prompt 
9728 c3 67 96			jp monitor 
972b			 
972b			.mondump:    
972b 21 60 e5			ld hl,os_input+2 
972e cd 75 8e			call get_word_hl 
9731			 
9731 22 83 e6			ld (os_cur_ptr),hl	 
9734 cd 79 97			call dumpcont 
9737 3e 78			ld a, display_row_4 
9739 11 13 96			ld de, endprog 
973c			 
973c cd b4 88			call update_display		 
973f			 
973f cd 71 98			call next_page_prompt 
9742 c3 67 96			jp monitor 
9745			.moncdump: 
9745 cd 79 97			call dumpcont 
9748 3e 78			ld a, display_row_4 
974a 11 13 96			ld de, endprog 
974d			 
974d cd b4 88			call update_display		 
9750			 
9750 cd 71 98			call next_page_prompt 
9753 c3 67 96			jp monitor 
9756			 
9756			 
9756			; TODO symbol access  
9756			 
9756			.symbols:     ;; A list of symbols that can be called up  
9756 c0 ed			dw display_fb0 
9758 .. 00			db "fb0",0  
975c 65 eb		     	dw store_page 
975e .. 00			db "store_page",0 
9769			 
9769			 
9769			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
9769			 
9769 3a 61 e3			ld a,(scratch+1) 
976c fe 00			cp 0 
976e 28 09			jr z, dumpcont 
9770			 
9770				; no, not a null term line so has an address to work out.... 
9770			 
9770 21 62 e3			ld hl,scratch+2 
9773 cd 75 8e			call get_word_hl 
9776			 
9776 22 83 e6			ld (os_cur_ptr),hl	 
9779			 
9779			 
9779			 
9779			dumpcont: 
9779			 
9779				; dump bytes at ptr 
9779			 
9779			 
9779 3e 00			ld a, display_row_1 
977b 2a db eb			ld hl, (display_fb_active) 
977e cd be 8a			call addatohl 
9781 cd a9 97			call .dumpbyterow 
9784			 
9784 3e 28			ld a, display_row_2 
9786 2a db eb			ld hl, (display_fb_active) 
9789 cd be 8a			call addatohl 
978c cd a9 97			call .dumpbyterow 
978f			 
978f			 
978f 3e 50			ld a, display_row_3 
9791 2a db eb			ld hl, (display_fb_active) 
9794 cd be 8a			call addatohl 
9797 cd a9 97			call .dumpbyterow 
979a			 
979a 3e 78			ld a, display_row_4 
979c 2a db eb			ld hl, (display_fb_active) 
979f cd be 8a			call addatohl 
97a2 cd a9 97			call .dumpbyterow 
97a5			 
97a5 cd b4 88			call update_display 
97a8			;		jp cli 
97a8 c9				ret 
97a9			 
97a9			.dumpbyterow: 
97a9			 
97a9				;push af 
97a9			 
97a9 e5				push hl 
97aa			 
97aa				; calc where to poke the ascii 
97aa			if display_cols == 20 
97aa				ld a, 16 
97aa			else 
97aa 3e 1f			ld a, 31 
97ac			endif 
97ac			 
97ac cd be 8a			call addatohl 
97af 22 65 e6			ld (os_word_scratch),hl  		; save pos for later 
97b2			 
97b2			 
97b2			; display decoding address 
97b2 2a 83 e6		   	ld hl,(os_cur_ptr) 
97b5			 
97b5 7c				ld a,h 
97b6 e1				pop hl 
97b7 e5				push hl 
97b8			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
97b8 cd bf 8d			call hexout 
97bb 2a 83 e6		   	ld hl,(os_cur_ptr) 
97be			 
97be 7d				ld a,l 
97bf e1				pop hl 
97c0 23				inc hl 
97c1 23				inc hl 
97c2 e5				push hl 
97c3			;	ld hl, os_word_scratch+2 
97c3 cd bf 8d			call hexout 
97c6 e1				pop hl 
97c7 23				inc hl 
97c8 23				inc hl 
97c9				;ld hl, os_word_scratch+4 
97c9 3e 3a			ld a, ':' 
97cb 77				ld (hl),a 
97cc 23				inc hl 
97cd				;ld a, 0 
97cd				;ld (hl),a 
97cd				;ld de, os_word_scratch 
97cd				;pop af 
97cd				;push af 
97cd			;		ld a, display_row_2 
97cd			;		call str_at_display 
97cd			;		call update_display 
97cd			 
97cd			 
97cd			;pop af 
97cd			;	add 5 
97cd			 
97cd			if display_cols == 20 
97cd				ld b, 4 
97cd			else 
97cd 06 08			ld b, 8 
97cf			endif	 
97cf			 
97cf			.dumpbyte: 
97cf c5				push bc 
97d0 e5				push hl 
97d1			 
97d1			 
97d1 2a 83 e6		   	ld hl,(os_cur_ptr) 
97d4 7e					ld a,(hl) 
97d5			 
97d5					; poke the ascii to display 
97d5 2a 65 e6				ld hl,(os_word_scratch) 
97d8 77					ld (hl),a 
97d9 23					inc hl 
97da 22 65 e6				ld (os_word_scratch),hl 
97dd			 
97dd					 
97dd			 
97dd			 
97dd e1					pop hl 
97de e5					push hl 
97df			 
97df cd bf 8d				call hexout 
97e2			 
97e2					 
97e2 2a 83 e6		   	ld hl,(os_cur_ptr) 
97e5 23				inc hl 
97e6 22 83 e6		   	ld (os_cur_ptr),hl 
97e9			 
97e9 e1					pop hl 
97ea 23					inc hl 
97eb 23					inc hl 
97ec 23					inc hl 
97ed			 
97ed			 
97ed			 
97ed					;ld a,0 
97ed					;ld (os_word_scratch+2),a 
97ed					;pop af 
97ed					;push af 
97ed			 
97ed					;ld de, os_word_scratch 
97ed					;call str_at_display 
97ed			;		call update_display 
97ed			;		pop af 
97ed c1					pop bc 
97ee c6 03				add 3 
97f0 10 dd			djnz .dumpbyte 
97f2			 
97f2				 
97f2			 
97f2 c9				ret 
97f3			 
97f3			jump:	 
97f3			 
97f3 21 62 e3			ld hl,scratch+2 
97f6 cd 75 8e			call get_word_hl 
97f9				;ld hl,(scratch+2) 
97f9				;call fourehexhl 
97f9			 
97f9 22 83 e6			ld (os_cur_ptr),hl	 
97fc			 
97fc e9				jp (hl) 
97fd			 
97fd			 
97fd			 
97fd			; TODO implement a basic monitor mode to start with 
97fd			 
97fd			 
97fd			 
97fd			 
97fd			 
97fd			 
97fd			 
97fd			 
97fd			 
97fd			; testing and demo code during development 
97fd			 
97fd			 
97fd .. 00		str1: db "Enter some text...",0 
9810 .. 00		clear: db "                    ",0 
9825			 
9825			demo: 
9825			 
9825			 
9825			 
9825			;	call update_display 
9825			 
9825				; init scratch input area for testing 
9825 21 60 e3			ld hl, scratch	 
9828 3e 00			ld a,0 
982a 77				ld (hl),a 
982b			 
982b			 
982b 3e 28		            LD   A, display_row_2 
982d			;            CALL fLCD_Pos       ;Position cursor to location in A 
982d 11 fd 97		            LD   DE, str1 
9830 cd a4 88			call str_at_display 
9833			 
9833			;            CALL fLCD_Str       ;Display string pointed to by DE 
9833			cloop:	 
9833 3e 50		            LD   A, display_row_3 
9835			;            CALL fLCD_Pos       ;Position cursor to location in A 
9835 11 10 98		            LD   DE, clear 
9838			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
9838 cd a4 88				call str_at_display 
983b 3e 78			ld a, display_row_4 
983d 11 6d 98			ld de, prompt 
9840			 
9840 cd a4 88				call str_at_display 
9843 cd b4 88			call update_display 
9846			 
9846 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
9848 16 0a			ld d, 10 
984a 21 60 e3			ld hl, scratch	 
984d cd eb 8a			call input_str 
9850			 
9850			;	call clear_display 
9850			;'	call update_display 
9850			 
9850 3e 00		            LD   A, display_row_1 
9852			;            CALL fLCD_Pos       ;Position cursor to location in A 
9852 11 10 98		            LD   DE, clear 
9855 cd a4 88				call str_at_display 
9858			;            CALL fLCD_Str       ;Display string pointed to by DE 
9858 3e 00		            LD   A, display_row_1 
985a			;            CALL fLCD_Pos       ;Position cursor to location in A 
985a 11 60 e3		            LD   DE, scratch 
985d			;            CALL fLCD_Str       ;Display string pointed to by DE 
985d cd a4 88				call str_at_display 
9860 cd b4 88			call update_display 
9863			 
9863 3e 00				ld a,0 
9865 21 60 e3			ld hl, scratch 
9868 77				ld (hl),a 
9869			 
9869 00				nop 
986a c3 33 98			jp cloop 
986d			 
986d			 
986d			 
986d			; OS Prompt 
986d			 
986d .. 00		prompt: db ">",0 
986f .. 00		endprg: db "?",0 
9871			 
9871			 
9871			; handy next page prompt 
9871			next_page_prompt: 
9871 e5				push hl 
9872 d5				push de 
9873 f5				push af 
9874 c5				push bc 
9875			 
9875 3e 9f			ld a,display_row_4 + display_cols - 1 
9877 11 6f 98		        ld de, endprg 
987a cd a4 88			call str_at_display 
987d cd b4 88			call update_display 
9880 cd ca d7			call cin_wait 
9883 c1				pop bc 
9884 f1				pop af 
9885 d1				pop de 
9886 e1				pop hl 
9887			 
9887			 
9887 c9				ret 
9888			 
9888			 
9888			; forth parser 
9888			 
9888			; My forth kernel 
9888			include "forth_kernel.asm" 
9888			; 
9888			; kernel to the forth OS 
9888			 
9888			DS_TYPE_STR: equ 1     ; string type 
9888			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
9888			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
9888			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
9888			 
9888			FORTH_PARSEV1: equ 0 
9888			FORTH_PARSEV2: equ 0 
9888			FORTH_PARSEV3: equ 0 
9888			FORTH_PARSEV4: equ 0 
9888			FORTH_PARSEV5: equ 1 
9888			 
9888			;if FORTH_PARSEV5 
9888			;	FORTH_END_BUFFER: equ 0 
9888			;else 
9888			FORTH_END_BUFFER: equ 127 
9888			;endif 
9888			 
9888			FORTH_TRUE: equ 1 
9888			FORTH_FALSE: equ 0 
9888			 
9888			if FORTH_PARSEV4 
9888			include "forth_stackops.asm" 
9888			endif 
9888			 
9888			if FORTH_PARSEV5 
9888			include "forth_stackopsv5.asm" 
9888			 
9888			; Stack operations for v5 parser on wards 
9888			; * DATA stack 
9888			; * LOOP stack 
9888			; * RETURN stack 
9888			 
9888			 
9888			 
9888			FORTH_CHK_DSP_UNDER: macro 
9888				push hl 
9888				push de 
9888				ld hl,(cli_data_sp) 
9888				ld de, cli_data_stack 
9888				call cmp16 
9888				jp c, fault_dsp_under 
9888				pop de 
9888				pop hl 
9888				endm 
9888			 
9888			 
9888			FORTH_CHK_RSP_UNDER: macro 
9888				push hl 
9888				push de 
9888				ld hl,(cli_ret_sp) 
9888				ld de, cli_ret_stack 
9888				call cmp16 
9888				jp c, fault_rsp_under 
9888				pop de 
9888				pop hl 
9888				endm 
9888			 
9888			FORTH_CHK_LOOP_UNDER: macro 
9888				push hl 
9888				push de 
9888				ld hl,(cli_loop_sp) 
9888				ld de, cli_loop_stack 
9888				call cmp16 
9888				jp c, fault_loop_under 
9888				pop de 
9888				pop hl 
9888				endm 
9888			 
9888			FORTH_ERR_TOS_NOTSTR: macro 
9888				; TOSO might need more for checks when used 
9888				push af 
9888				ld a,(hl) 
9888				cp DS_TYPE_STR 
9888				jp nz, type_faultn   
9888				pop af 
9888				endm 
9888			 
9888			FORTH_ERR_TOS_NOTNUM: macro 
9888				push af 
9888				ld a,(hl) 
9888				cp DS_TYPE_INUM 
9888				jp nz, type_faultn   
9888				pop af 
9888				endm 
9888			 
9888			 
9888			; increase data stack pointer and save hl to it 
9888				 
9888			FORTH_DSP_NEXT: macro 
9888				call macro_forth_dsp_next 
9888				endm 
9888			 
9888			 
9888			macro_forth_dsp_next: 
9888				if DEBUG_FORTH_STACK_GUARD 
9888 cd 2e d5				call check_stacks 
988b				endif 
988b e5				push hl 
988c d5				push de 
988d eb				ex de,hl 
988e 2a 0d eb			ld hl,(cli_data_sp) 
9891 23				inc hl 
9892 23				inc hl 
9893			 
9893			; PARSEV5 
9893 23				inc hl 
9894 22 0d eb			ld (cli_data_sp),hl 
9897 73				ld (hl), e 
9898 23				inc hl 
9899 72				ld (hl), d 
989a d1				pop de 
989b e1				pop hl 
989c				if DEBUG_FORTH_STACK_GUARD 
989c cd 2e d5				call check_stacks 
989f				endif 
989f c9				ret 
98a0			 
98a0			 
98a0			; increase ret stack pointer and save hl to it 
98a0				 
98a0			FORTH_RSP_NEXT: macro 
98a0				call macro_forth_rsp_next 
98a0				endm 
98a0			 
98a0			macro_forth_rsp_next: 
98a0				if DEBUG_FORTH_STACK_GUARD 
98a0 cd 2e d5				call check_stacks 
98a3				endif 
98a3 e5				push hl 
98a4 d5				push de 
98a5 eb				ex de,hl 
98a6 2a 11 eb			ld hl,(cli_ret_sp) 
98a9 23				inc hl 
98aa 23				inc hl 
98ab 22 11 eb			ld (cli_ret_sp),hl 
98ae 73				ld (hl), e 
98af 23				inc hl 
98b0 72				ld (hl), d 
98b1 d1				pop de 
98b2 e1				pop hl 
98b3				if DEBUG_FORTH_STACK_GUARD 
98b3 cd 2e d5				call check_stacks 
98b6				endif 
98b6 c9				ret 
98b7			 
98b7			; get current ret stack pointer and save to hl  
98b7				 
98b7			FORTH_RSP_TOS: macro 
98b7				call macro_forth_rsp_tos 
98b7				endm 
98b7			 
98b7			macro_forth_rsp_tos: 
98b7				;push de 
98b7 2a 11 eb			ld hl,(cli_ret_sp) 
98ba cd f2 98			call loadhlptrtohl 
98bd				;ld e, (hl) 
98bd				;inc hl 
98bd				;ld d, (hl) 
98bd				;ex de, hl 
98bd					if DEBUG_FORTH_WORDS 
98bd			;			DMARK "RST" 
98bd						CALLMONITOR 
98bd cd 6c 93			call break_point_state  
98c0				endm  
# End of macro CALLMONITOR
98c0					endif 
98c0				;pop de 
98c0 c9				ret 
98c1			 
98c1			; pop ret stack pointer 
98c1				 
98c1			FORTH_RSP_POP: macro 
98c1				call macro_forth_rsp_pop 
98c1				endm 
98c1			 
98c1			 
98c1			macro_forth_rsp_pop: 
98c1				if DEBUG_FORTH_STACK_GUARD 
98c1			;		DMARK "RPP" 
98c1 cd 2e d5				call check_stacks 
98c4					FORTH_CHK_RSP_UNDER 
98c4 e5				push hl 
98c5 d5				push de 
98c6 2a 11 eb			ld hl,(cli_ret_sp) 
98c9 11 cb ea			ld de, cli_ret_stack 
98cc cd dc 8a			call cmp16 
98cf da 42 d6			jp c, fault_rsp_under 
98d2 d1				pop de 
98d3 e1				pop hl 
98d4				endm 
# End of macro FORTH_CHK_RSP_UNDER
98d4				endif 
98d4 e5				push hl 
98d5 2a 11 eb			ld hl,(cli_ret_sp) 
98d8			 
98d8			 
98d8				if FORTH_ENABLE_FREE 
98d8			 
98d8					; get pointer 
98d8			 
98d8					push de 
98d8					push hl 
98d8			 
98d8					ld e, (hl) 
98d8					inc hl 
98d8					ld d, (hl) 
98d8			 
98d8					ex de, hl 
98d8					call free 
98d8			 
98d8					pop hl 
98d8					pop de 
98d8			 
98d8			 
98d8				endif 
98d8			 
98d8			 
98d8 2b				dec hl 
98d9 2b				dec hl 
98da 22 11 eb			ld (cli_ret_sp), hl 
98dd				; do stack underflow checks 
98dd e1				pop hl 
98de				if DEBUG_FORTH_STACK_GUARD 
98de cd 2e d5				call check_stacks 
98e1					FORTH_CHK_RSP_UNDER 
98e1 e5				push hl 
98e2 d5				push de 
98e3 2a 11 eb			ld hl,(cli_ret_sp) 
98e6 11 cb ea			ld de, cli_ret_stack 
98e9 cd dc 8a			call cmp16 
98ec da 42 d6			jp c, fault_rsp_under 
98ef d1				pop de 
98f0 e1				pop hl 
98f1				endm 
# End of macro FORTH_CHK_RSP_UNDER
98f1				endif 
98f1 c9				ret 
98f2			 
98f2			 
98f2			 
98f2			; routine to load word pointed to by hl into hl 
98f2			 
98f2			loadhlptrtohl: 
98f2			 
98f2 d5				push de 
98f3 5e				ld e, (hl) 
98f4 23				inc hl 
98f5 56				ld d, (hl) 
98f6 eb				ex de, hl 
98f7 d1				pop de 
98f8			 
98f8 c9				ret 
98f9			 
98f9			 
98f9			 
98f9			 
98f9			 
98f9			; push a number held in HL onto the data stack 
98f9			; entry point for pushing a value when already in hl used in function above 
98f9			 
98f9			forth_push_numhl: 
98f9			 
98f9 e5				push hl    ; save value to push 
98fa			 
98fa			if DEBUG_FORTH_PUSH 
98fa				; see if disabled 
98fa			 
98fa			 
98fa f5				push af 
98fb 3a 51 e3			ld a, (os_view_disable) 
98fe fe 2a			cp '*' 
9900 28 34			jr z, .pskip2 
9902 e5				push hl 
9903 e5			push hl 
9904 cd 91 88			call clear_display 
9907 e1			pop hl 
9908 7c				ld a,h 
9909 21 65 e6			ld hl, os_word_scratch 
990c cd bf 8d			call hexout 
990f e1				pop hl 
9910 7d				ld a,l 
9911 21 67 e6			ld hl, os_word_scratch+2 
9914 cd bf 8d			call hexout 
9917			 
9917 21 69 e6			ld hl, os_word_scratch+4 
991a 3e 00			ld a,0 
991c 77				ld (hl),a 
991d 11 65 e6			ld de,os_word_scratch 
9920 3e 28				ld a, display_row_2 
9922 cd a4 88				call str_at_display 
9925 11 3c c4			ld de, .push_num 
9928 3e 00			ld a, display_row_1 
992a			 
992a cd a4 88				call str_at_display 
992d			 
992d			 
992d cd b4 88			call update_display 
9930 cd 0e 88			call delay1s 
9933 cd 0e 88			call delay1s 
9936			.pskip2:  
9936			 
9936 f1				pop af 
9937			endif	 
9937			 
9937			 
9937				FORTH_DSP_NEXT 
9937 cd 88 98			call macro_forth_dsp_next 
993a				endm 
# End of macro FORTH_DSP_NEXT
993a			 
993a 2a 0d eb			ld hl, (cli_data_sp) 
993d			 
993d				; save item type 
993d 3e 02			ld a,  DS_TYPE_INUM 
993f 77				ld (hl), a 
9940 23				inc hl 
9941			 
9941				; get word off stack 
9941 d1				pop de 
9942 7b				ld a,e 
9943 77				ld (hl), a 
9944 23				inc hl 
9945 7a				ld a,d 
9946 77				ld (hl), a 
9947			 
9947			if DEBUG_FORTH_PUSH 
9947 2b				dec hl 
9948 2b				dec hl 
9949 2b				dec hl 
994a						DMARK "PH5" 
994a f5				push af  
994b 3a 5f 99			ld a, (.dmark)  
994e 32 7a ee			ld (debug_mark),a  
9951 3a 60 99			ld a, (.dmark+1)  
9954 32 7b ee			ld (debug_mark+1),a  
9957 3a 61 99			ld a, (.dmark+2)  
995a 32 7c ee			ld (debug_mark+2),a  
995d 18 03			jr .pastdmark  
995f ..			.dmark: db "PH5"  
9962 f1			.pastdmark: pop af  
9963			endm  
# End of macro DMARK
9963				CALLMONITOR 
9963 cd 6c 93			call break_point_state  
9966				endm  
# End of macro CALLMONITOR
9966			endif	 
9966			 
9966 c9				ret 
9967			 
9967			 
9967			; Push a string to stack pointed to by hl 
9967			 
9967			forth_push_str: 
9967			 
9967			if DEBUG_FORTH_PUSH 
9967						DMARK "PSQ" 
9967 f5				push af  
9968 3a 7c 99			ld a, (.dmark)  
996b 32 7a ee			ld (debug_mark),a  
996e 3a 7d 99			ld a, (.dmark+1)  
9971 32 7b ee			ld (debug_mark+1),a  
9974 3a 7e 99			ld a, (.dmark+2)  
9977 32 7c ee			ld (debug_mark+2),a  
997a 18 03			jr .pastdmark  
997c ..			.dmark: db "PSQ"  
997f f1			.pastdmark: pop af  
9980			endm  
# End of macro DMARK
9980				CALLMONITOR 
9980 cd 6c 93			call break_point_state  
9983				endm  
# End of macro CALLMONITOR
9983			endif	 
9983			    
9983 e5				push hl 
9984 e5				push hl 
9985			 
9985			;	ld a, 0   ; find end of string 
9985 cd 1c 8f			call strlenz 
9988			if DEBUG_FORTH_PUSH 
9988						DMARK "PQ2" 
9988 f5				push af  
9989 3a 9d 99			ld a, (.dmark)  
998c 32 7a ee			ld (debug_mark),a  
998f 3a 9e 99			ld a, (.dmark+1)  
9992 32 7b ee			ld (debug_mark+1),a  
9995 3a 9f 99			ld a, (.dmark+2)  
9998 32 7c ee			ld (debug_mark+2),a  
999b 18 03			jr .pastdmark  
999d ..			.dmark: db "PQ2"  
99a0 f1			.pastdmark: pop af  
99a1			endm  
# End of macro DMARK
99a1				CALLMONITOR 
99a1 cd 6c 93			call break_point_state  
99a4				endm  
# End of macro CALLMONITOR
99a4			endif	 
99a4 eb				ex de, hl 
99a5 e1				pop hl   ; get ptr to start of string 
99a6			if DEBUG_FORTH_PUSH 
99a6						DMARK "PQ3" 
99a6 f5				push af  
99a7 3a bb 99			ld a, (.dmark)  
99aa 32 7a ee			ld (debug_mark),a  
99ad 3a bc 99			ld a, (.dmark+1)  
99b0 32 7b ee			ld (debug_mark+1),a  
99b3 3a bd 99			ld a, (.dmark+2)  
99b6 32 7c ee			ld (debug_mark+2),a  
99b9 18 03			jr .pastdmark  
99bb ..			.dmark: db "PQ3"  
99be f1			.pastdmark: pop af  
99bf			endm  
# End of macro DMARK
99bf				CALLMONITOR 
99bf cd 6c 93			call break_point_state  
99c2				endm  
# End of macro CALLMONITOR
99c2			endif	 
99c2 19				add hl,de 
99c3			if DEBUG_FORTH_PUSH 
99c3						DMARK "PQE" 
99c3 f5				push af  
99c4 3a d8 99			ld a, (.dmark)  
99c7 32 7a ee			ld (debug_mark),a  
99ca 3a d9 99			ld a, (.dmark+1)  
99cd 32 7b ee			ld (debug_mark+1),a  
99d0 3a da 99			ld a, (.dmark+2)  
99d3 32 7c ee			ld (debug_mark+2),a  
99d6 18 03			jr .pastdmark  
99d8 ..			.dmark: db "PQE"  
99db f1			.pastdmark: pop af  
99dc			endm  
# End of macro DMARK
99dc				CALLMONITOR 
99dc cd 6c 93			call break_point_state  
99df				endm  
# End of macro CALLMONITOR
99df			endif	 
99df			 
99df 2b				dec hl    ; see if there is an optional trailing double quote 
99e0 7e				ld a,(hl) 
99e1 fe 22			cp '"' 
99e3 20 03			jr nz, .strnoq 
99e5 3e 00			ld a, 0      ; get rid of double quote 
99e7 77				ld (hl), a 
99e8 23			.strnoq: inc hl 
99e9			 
99e9 3e 00			ld a, 0 
99eb 77				ld (hl), a     ; add null term and get rid of trailing double quote 
99ec			 
99ec 13				inc de ; add one for the type string 
99ed 13				inc de ; add one for null term??? 
99ee			 
99ee				; tos is get string pointer again 
99ee				; de contains space to allocate 
99ee				 
99ee d5				push de 
99ef			 
99ef eb				ex de, hl 
99f0			 
99f0				;push af 
99f0			 
99f0			if DEBUG_FORTH_PUSH 
99f0						DMARK "PHm" 
99f0 f5				push af  
99f1 3a 05 9a			ld a, (.dmark)  
99f4 32 7a ee			ld (debug_mark),a  
99f7 3a 06 9a			ld a, (.dmark+1)  
99fa 32 7b ee			ld (debug_mark+1),a  
99fd 3a 07 9a			ld a, (.dmark+2)  
9a00 32 7c ee			ld (debug_mark+2),a  
9a03 18 03			jr .pastdmark  
9a05 ..			.dmark: db "PHm"  
9a08 f1			.pastdmark: pop af  
9a09			endm  
# End of macro DMARK
9a09				CALLMONITOR 
9a09 cd 6c 93			call break_point_state  
9a0c				endm  
# End of macro CALLMONITOR
9a0c			endif	 
9a0c cd 85 8f			call malloc	; on ret hl now contains allocated memory 
9a0f				if DEBUG_FORTH_MALLOC_GUARD 
9a0f cc 94 c4				call z,malloc_error 
9a12				endif 
9a12			 
9a12				 
9a12 c1				pop bc    ; get length 
9a13 d1				pop de   ;  get string start    
9a14			 
9a14				; hl has destination from malloc 
9a14			 
9a14 eb				ex de, hl    ; prep for ldir 
9a15			 
9a15 d5				push de   ; save malloc area for DSP later 
9a16				;push hl   ; save malloc area for DSP later 
9a16			 
9a16			if DEBUG_FORTH_PUSH 
9a16						DMARK "PHc" 
9a16 f5				push af  
9a17 3a 2b 9a			ld a, (.dmark)  
9a1a 32 7a ee			ld (debug_mark),a  
9a1d 3a 2c 9a			ld a, (.dmark+1)  
9a20 32 7b ee			ld (debug_mark+1),a  
9a23 3a 2d 9a			ld a, (.dmark+2)  
9a26 32 7c ee			ld (debug_mark+2),a  
9a29 18 03			jr .pastdmark  
9a2b ..			.dmark: db "PHc"  
9a2e f1			.pastdmark: pop af  
9a2f			endm  
# End of macro DMARK
9a2f				CALLMONITOR 
9a2f cd 6c 93			call break_point_state  
9a32				endm  
# End of macro CALLMONITOR
9a32			endif	 
9a32			 
9a32			 
9a32 ed b0			ldir 
9a34			 
9a34			 
9a34				; push malloc to data stack     macro?????  
9a34			 
9a34				FORTH_DSP_NEXT 
9a34 cd 88 98			call macro_forth_dsp_next 
9a37				endm 
# End of macro FORTH_DSP_NEXT
9a37			 
9a37				; save value and type 
9a37			 
9a37 2a 0d eb			ld hl, (cli_data_sp) 
9a3a			 
9a3a				; save item type 
9a3a 3e 01			ld a,  DS_TYPE_STR 
9a3c 77				ld (hl), a 
9a3d 23				inc hl 
9a3e			 
9a3e				; get malloc word off stack 
9a3e d1				pop de 
9a3f 73				ld (hl), e 
9a40 23				inc hl 
9a41 72				ld (hl), d 
9a42			 
9a42			 
9a42			 
9a42			if DEBUG_FORTH_PUSH 
9a42 2a 0d eb			ld hl, (cli_data_sp) 
9a45						DMARK "PHS" 
9a45 f5				push af  
9a46 3a 5a 9a			ld a, (.dmark)  
9a49 32 7a ee			ld (debug_mark),a  
9a4c 3a 5b 9a			ld a, (.dmark+1)  
9a4f 32 7b ee			ld (debug_mark+1),a  
9a52 3a 5c 9a			ld a, (.dmark+2)  
9a55 32 7c ee			ld (debug_mark+2),a  
9a58 18 03			jr .pastdmark  
9a5a ..			.dmark: db "PHS"  
9a5d f1			.pastdmark: pop af  
9a5e			endm  
# End of macro DMARK
9a5e				CALLMONITOR 
9a5e cd 6c 93			call break_point_state  
9a61				endm  
# End of macro CALLMONITOR
9a61			;	ex de,hl 
9a61			endif	 
9a61				; in case of spaces, skip the ptr past the copied string 
9a61				;pop af 
9a61				;ld (cli_origptr),hl 
9a61			 
9a61 c9				ret 
9a62			 
9a62			 
9a62			 
9a62			; TODO ascii push input onto stack given hl to start of input 
9a62			 
9a62			; identify type 
9a62			; if starts with a " then a string 
9a62			; otherwise it is a number 
9a62			;  
9a62			; if a string 
9a62			;     scan for ending " to get length of string to malloc for + 1 
9a62			;     malloc 
9a62			;     put pointer to string on stack first byte flags as string 
9a62			; 
9a62			; else a number 
9a62			;    look for number format identifier 
9a62			;    $xx hex 
9a62			;    %xxxxx bin 
9a62			;    xxxxx decimal 
9a62			;    convert number to 16bit word.  
9a62			;    malloc word + 1 with flag to identiy as num 
9a62			;    put pointer to number on stack 
9a62			;   
9a62			;  
9a62			  
9a62			forth_apush: 
9a62				; kernel push 
9a62			 
9a62			if DEBUG_FORTH_PUSH 
9a62						DMARK "PSH" 
9a62 f5				push af  
9a63 3a 77 9a			ld a, (.dmark)  
9a66 32 7a ee			ld (debug_mark),a  
9a69 3a 78 9a			ld a, (.dmark+1)  
9a6c 32 7b ee			ld (debug_mark+1),a  
9a6f 3a 79 9a			ld a, (.dmark+2)  
9a72 32 7c ee			ld (debug_mark+2),a  
9a75 18 03			jr .pastdmark  
9a77 ..			.dmark: db "PSH"  
9a7a f1			.pastdmark: pop af  
9a7b			endm  
# End of macro DMARK
9a7b				CALLMONITOR 
9a7b cd 6c 93			call break_point_state  
9a7e				endm  
# End of macro CALLMONITOR
9a7e			endif	 
9a7e				; identify input type 
9a7e			 
9a7e 7e				ld a,(hl) 
9a7f fe 22			cp '"' 
9a81 28 0a			jr z, .fapstr 
9a83 fe 24			cp '$' 
9a85 ca ad 9a			jp z, .faphex 
9a88 fe 25			cp '%' 
9a8a ca 95 9a			jp z, .fapbin 
9a8d			;	cp 'b' 
9a8d			;	jp z, .fabin 
9a8d				; else decimal 
9a8d			 
9a8d				; TODO do decimal conversion 
9a8d				; decimal is stored as a 16bit word 
9a8d			 
9a8d				; by default everything is a string if type is not detected 
9a8d			.fapstr: ; 
9a8d fe 22			cp '"' 
9a8f 20 01			jr nz, .strnoqu 
9a91 23				inc hl 
9a92			.strnoqu: 
9a92 c3 67 99			jp forth_push_str 
9a95			 
9a95			 
9a95			 
9a95			.fapbin:    ; push a binary string.  
9a95 11 00 00			ld de, 0   ; hold a 16bit value 
9a98			 
9a98 23			.fapbinshift:	inc hl  
9a99 7e				ld a,(hl) 
9a9a fe 00			cp 0     ; done scanning  
9a9c 28 0b			jr z, .fapbdone  	; got it in HL so push  
9a9e			 
9a9e				; left shift de 
9a9e eb				ex de, hl	 
9a9f 29				add hl, hl 
9aa0			 
9aa0				; is 1 
9aa0 fe 31			cp '1' 
9aa2 20 02			jr nz, .binzero 
9aa4 cb 4d			bit 1, l 
9aa6			.binzero: 
9aa6 eb				ex de, hl	 ; save current de 
9aa7 18 ef			jr .fapbinshift 
9aa9			 
9aa9			.fapbdone: 
9aa9 eb				ex de, hl 
9aaa c3 f9 98			jp forth_push_numhl 
9aad			 
9aad			 
9aad			.faphex:   ; hex is always stored as a 16bit word 
9aad				; skip number prefix 
9aad 23				inc hl 
9aae				; turn ascii into number 
9aae cd 75 8e			call get_word_hl	; ret 16bit word in hl 
9ab1			 
9ab1 c3 f9 98			jp forth_push_numhl 
9ab4			 
9ab4 00				 nop 
9ab5			 
9ab5			.fabin:   ; TODO bin conversion 
9ab5			 
9ab5			 
9ab5 c9				ret 
9ab6			 
9ab6			 
9ab6			; get either a string ptr or a 16bit word from the data stack 
9ab6			 
9ab6			FORTH_DSP: macro 
9ab6				call macro_forth_dsp 
9ab6				endm 
9ab6			 
9ab6			macro_forth_dsp: 
9ab6				; data stack pointer points to current word on tos 
9ab6			 
9ab6 2a 0d eb			ld hl,(cli_data_sp) 
9ab9			 
9ab9				if DEBUG_FORTH_PUSH 
9ab9						DMARK "DSP" 
9ab9 f5				push af  
9aba 3a ce 9a			ld a, (.dmark)  
9abd 32 7a ee			ld (debug_mark),a  
9ac0 3a cf 9a			ld a, (.dmark+1)  
9ac3 32 7b ee			ld (debug_mark+1),a  
9ac6 3a d0 9a			ld a, (.dmark+2)  
9ac9 32 7c ee			ld (debug_mark+2),a  
9acc 18 03			jr .pastdmark  
9ace ..			.dmark: db "DSP"  
9ad1 f1			.pastdmark: pop af  
9ad2			endm  
# End of macro DMARK
9ad2			 
9ad2 cd c9 c4				call display_data_sp 
9ad5				;call break_point_state 
9ad5				;rst 030h 
9ad5				CALLMONITOR 
9ad5 cd 6c 93			call break_point_state  
9ad8				endm  
# End of macro CALLMONITOR
9ad8				endif 
9ad8			 
9ad8 c9				ret 
9ad9			 
9ad9			; return hl to start of value on stack 
9ad9			 
9ad9			FORTH_DSP_VALUE: macro 
9ad9				call macro_forth_dsp_value 
9ad9				endm 
9ad9			 
9ad9			macro_forth_dsp_value: 
9ad9			 
9ad9				FORTH_DSP 
9ad9 cd b6 9a			call macro_forth_dsp 
9adc				endm 
# End of macro FORTH_DSP
9adc			 
9adc d5				push de 
9add			 
9add 23				inc hl ; skip type 
9ade			 
9ade 5e				ld e, (hl) 
9adf 23				inc hl 
9ae0 56				ld d, (hl) 
9ae1 eb				ex de,hl  
9ae2			 
9ae2 d1				pop de 
9ae3			 
9ae3 c9				ret 
9ae4			 
9ae4			; return hl to start of value to second item on stack 
9ae4			 
9ae4			FORTH_DSP_VALUEM1: macro 
9ae4				call macro_forth_dsp_value_m1 
9ae4				endm 
9ae4			 
9ae4			macro_forth_dsp_value_m1: 
9ae4			 
9ae4				FORTH_DSP 
9ae4 cd b6 9a			call macro_forth_dsp 
9ae7				endm 
# End of macro FORTH_DSP
9ae7			 
9ae7 2b				dec hl 
9ae8 2b				dec hl 
9ae9			;	dec hl 
9ae9			 
9ae9 d5				push de 
9aea			 
9aea 5e				ld e, (hl) 
9aeb 23				inc hl 
9aec 56				ld d, (hl) 
9aed eb				ex de,hl  
9aee			 
9aee d1				pop de 
9aef			 
9aef c9				ret 
9af0			 
9af0				 
9af0			 
9af0			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
9af0			 
9af0			FORTH_DSP_POP: macro 
9af0				call macro_forth_dsp_pop 
9af0				endm 
9af0			 
9af0			 
9af0			; get the tos data type 
9af0			 
9af0			FORTH_DSP_TYPE:   macro 
9af0			 
9af0				;FORTH_DSP_VALUE 
9af0				FORTH_DSP 
9af0				 
9af0				; hl points to value 
9af0				; check type 
9af0			 
9af0				ld a,(hl) 
9af0			 
9af0				endm 
9af0			 
9af0			; load the tos value into hl 
9af0			 
9af0			 
9af0			FORTH_DSP_VALUEHL:  macro 
9af0				call macro_dsp_valuehl 
9af0				endm 
9af0			 
9af0			 
9af0			 
9af0			macro_dsp_valuehl: 
9af0				FORTH_DSP_VALUE 
9af0 cd d9 9a			call macro_forth_dsp_value 
9af3				endm 
# End of macro FORTH_DSP_VALUE
9af3			 
9af3				;FORTH_ERR_TOS_NOTNUM 
9af3			 
9af3				;inc hl   ; skip type id 
9af3			 
9af3			;	push de 
9af3			; 
9af3			;	ld e, (hl) 
9af3			;	inc hl 
9af3			;	ld d, (hl) 
9af3			;	ex de,hl  
9af3			 
9af3			;	pop de 
9af3			 
9af3				if DEBUG_FORTH_PUSH 
9af3						DMARK "DVL" 
9af3 f5				push af  
9af4 3a 08 9b			ld a, (.dmark)  
9af7 32 7a ee			ld (debug_mark),a  
9afa 3a 09 9b			ld a, (.dmark+1)  
9afd 32 7b ee			ld (debug_mark+1),a  
9b00 3a 0a 9b			ld a, (.dmark+2)  
9b03 32 7c ee			ld (debug_mark+2),a  
9b06 18 03			jr .pastdmark  
9b08 ..			.dmark: db "DVL"  
9b0b f1			.pastdmark: pop af  
9b0c			endm  
# End of macro DMARK
9b0c				CALLMONITOR 
9b0c cd 6c 93			call break_point_state  
9b0f				endm  
# End of macro CALLMONITOR
9b0f				endif 
9b0f c9				ret 
9b10			 
9b10			forth_apushstrhl:      
9b10				; push of string requires use of cli_origptr 
9b10				; bodge use 
9b10			 
9b10				; get current cli_origptr, save, update with temp pointer  
9b10 ed 5b 29 eb		ld de, (cli_origptr) 
9b14 22 29 eb			ld (cli_origptr), hl 
9b17 d5				push de 
9b18 cd 62 9a			call forth_apush 
9b1b d1				pop de 
9b1c ed 53 29 eb		ld (cli_origptr), de 
9b20 c9			        ret	 
9b21			 
9b21			 
9b21			; increase loop stack pointer and save hl to it 
9b21				 
9b21			FORTH_LOOP_NEXT: macro 
9b21				call macro_forth_loop_next 
9b21				;nop 
9b21				endm 
9b21			 
9b21			macro_forth_loop_next: 
9b21				if DEBUG_FORTH_STACK_GUARD 
9b21 cd 2e d5				call check_stacks 
9b24				endif 
9b24 e5				push hl 
9b25 d5				push de 
9b26 eb				ex de,hl 
9b27 2a 0f eb			ld hl,(cli_loop_sp) 
9b2a 23				inc hl 
9b2b 23				inc hl 
9b2c					if DEBUG_FORTH_WORDS 
9b2c						DMARK "LNX" 
9b2c f5				push af  
9b2d 3a 41 9b			ld a, (.dmark)  
9b30 32 7a ee			ld (debug_mark),a  
9b33 3a 42 9b			ld a, (.dmark+1)  
9b36 32 7b ee			ld (debug_mark+1),a  
9b39 3a 43 9b			ld a, (.dmark+2)  
9b3c 32 7c ee			ld (debug_mark+2),a  
9b3f 18 03			jr .pastdmark  
9b41 ..			.dmark: db "LNX"  
9b44 f1			.pastdmark: pop af  
9b45			endm  
# End of macro DMARK
9b45						CALLMONITOR 
9b45 cd 6c 93			call break_point_state  
9b48				endm  
# End of macro CALLMONITOR
9b48					endif 
9b48 22 0f eb			ld (cli_loop_sp),hl 
9b4b 73				ld (hl), e 
9b4c 23				inc hl 
9b4d 72				ld (hl), d 
9b4e d1				pop de    ; been reversed so save a swap on restore 
9b4f e1				pop hl 
9b50				if DEBUG_FORTH_STACK_GUARD 
9b50 cd 2e d5				call check_stacks 
9b53				endif 
9b53 c9				ret 
9b54			 
9b54			; get current ret stack pointer and save to hl  
9b54				 
9b54			FORTH_LOOP_TOS: macro 
9b54				call macro_forth_loop_tos 
9b54				endm 
9b54			 
9b54			macro_forth_loop_tos: 
9b54 d5				push de 
9b55 2a 0f eb			ld hl,(cli_loop_sp) 
9b58 5e				ld e, (hl) 
9b59 23				inc hl 
9b5a 56				ld d, (hl) 
9b5b eb				ex de, hl 
9b5c d1				pop de 
9b5d c9				ret 
9b5e			 
9b5e			; pop loop stack pointer 
9b5e				 
9b5e			FORTH_LOOP_POP: macro 
9b5e				call macro_forth_loop_pop 
9b5e				endm 
9b5e			 
9b5e			 
9b5e			macro_forth_loop_pop: 
9b5e				if DEBUG_FORTH_STACK_GUARD 
9b5e					DMARK "LPP" 
9b5e f5				push af  
9b5f 3a 73 9b			ld a, (.dmark)  
9b62 32 7a ee			ld (debug_mark),a  
9b65 3a 74 9b			ld a, (.dmark+1)  
9b68 32 7b ee			ld (debug_mark+1),a  
9b6b 3a 75 9b			ld a, (.dmark+2)  
9b6e 32 7c ee			ld (debug_mark+2),a  
9b71 18 03			jr .pastdmark  
9b73 ..			.dmark: db "LPP"  
9b76 f1			.pastdmark: pop af  
9b77			endm  
# End of macro DMARK
9b77 cd 2e d5				call check_stacks 
9b7a					FORTH_CHK_LOOP_UNDER 
9b7a e5				push hl 
9b7b d5				push de 
9b7c 2a 0f eb			ld hl,(cli_loop_sp) 
9b7f 11 c9 e9			ld de, cli_loop_stack 
9b82 cd dc 8a			call cmp16 
9b85 da 48 d6			jp c, fault_loop_under 
9b88 d1				pop de 
9b89 e1				pop hl 
9b8a				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9b8a				endif 
9b8a e5				push hl 
9b8b 2a 0f eb			ld hl,(cli_loop_sp) 
9b8e 2b				dec hl 
9b8f 2b				dec hl 
9b90 22 0f eb			ld (cli_loop_sp), hl 
9b93				; TODO do stack underflow checks 
9b93 e1				pop hl 
9b94				if DEBUG_FORTH_STACK_GUARD 
9b94 cd 2e d5				call check_stacks 
9b97					FORTH_CHK_LOOP_UNDER 
9b97 e5				push hl 
9b98 d5				push de 
9b99 2a 0f eb			ld hl,(cli_loop_sp) 
9b9c 11 c9 e9			ld de, cli_loop_stack 
9b9f cd dc 8a			call cmp16 
9ba2 da 48 d6			jp c, fault_loop_under 
9ba5 d1				pop de 
9ba6 e1				pop hl 
9ba7				endm 
# End of macro FORTH_CHK_LOOP_UNDER
9ba7				endif 
9ba7 c9				ret 
9ba8			 
9ba8			macro_forth_dsp_pop: 
9ba8			 
9ba8 e5				push hl 
9ba9			 
9ba9				; release malloc data 
9ba9			 
9ba9				if DEBUG_FORTH_STACK_GUARD 
9ba9 cd 2e d5				call check_stacks 
9bac					FORTH_CHK_DSP_UNDER 
9bac e5				push hl 
9bad d5				push de 
9bae 2a 0d eb			ld hl,(cli_data_sp) 
9bb1 11 c7 e8			ld de, cli_data_stack 
9bb4 cd dc 8a			call cmp16 
9bb7 da 3c d6			jp c, fault_dsp_under 
9bba d1				pop de 
9bbb e1				pop hl 
9bbc				endm 
# End of macro FORTH_CHK_DSP_UNDER
9bbc				endif 
9bbc				;ld hl,(cli_data_sp) 
9bbc			if DEBUG_FORTH_DOT 
9bbc				DMARK "DPP" 
9bbc				CALLMONITOR 
9bbc			endif	 
9bbc			 
9bbc			 
9bbc			if FORTH_ENABLE_DSPPOPFREE 
9bbc			 
9bbc				FORTH_DSP 
9bbc cd b6 9a			call macro_forth_dsp 
9bbf				endm 
# End of macro FORTH_DSP
9bbf			 
9bbf 7e				ld a, (hl) 
9bc0 fe 01			cp DS_TYPE_STR 
9bc2 20 07			jr nz, .skippopfree 
9bc4			 
9bc4				FORTH_DSP_VALUEHL 
9bc4 cd f0 9a			call macro_dsp_valuehl 
9bc7				endm 
# End of macro FORTH_DSP_VALUEHL
9bc7 00				nop 
9bc8			if DEBUG_FORTH_DOT 
9bc8				DMARK "DPf" 
9bc8				CALLMONITOR 
9bc8			endif	 
9bc8 cd 4f 90			call free 
9bcb			.skippopfree: 
9bcb				 
9bcb			 
9bcb			endif 
9bcb			 
9bcb			if DEBUG_FORTH_DOT_KEY 
9bcb				DMARK "DP2" 
9bcb				CALLMONITOR 
9bcb			endif	 
9bcb			 
9bcb				; move pointer down 
9bcb			 
9bcb 2a 0d eb			ld hl,(cli_data_sp) 
9bce 2b				dec hl 
9bcf 2b				dec hl 
9bd0			; PARSEV5 
9bd0 2b				dec hl 
9bd1 22 0d eb			ld (cli_data_sp), hl 
9bd4			 
9bd4				if DEBUG_FORTH_STACK_GUARD 
9bd4 cd 2e d5				call check_stacks 
9bd7					FORTH_CHK_DSP_UNDER 
9bd7 e5				push hl 
9bd8 d5				push de 
9bd9 2a 0d eb			ld hl,(cli_data_sp) 
9bdc 11 c7 e8			ld de, cli_data_stack 
9bdf cd dc 8a			call cmp16 
9be2 da 3c d6			jp c, fault_dsp_under 
9be5 d1				pop de 
9be6 e1				pop hl 
9be7				endm 
# End of macro FORTH_CHK_DSP_UNDER
9be7				endif 
9be7			 
9be7 e1				pop hl 
9be8			 
9be8 c9				ret 
9be9			 
9be9			getwordathl: 
9be9				; hl points to an address 
9be9				; load hl with the word at that address 
9be9			 
9be9 d5				push de 
9bea			 
9bea 5e				ld e, (hl) 
9beb 23				inc hl 
9bec 56				ld d, (hl) 
9bed eb				ex de, hl 
9bee			 
9bee d1				pop de 
9bef c9				ret 
9bf0			 
9bf0			 
9bf0			 
9bf0			 
9bf0			 
9bf0			; eof 
9bf0			 
# End of file forth_stackopsv5.asm
9bf0			endif 
9bf0			 
9bf0			user_word_eol:  
9bf0				; hl contains the pointer to where to create a linked list item from the end 
9bf0				; of the user dict to continue on at the system word dict 
9bf0				 
9bf0				; poke the stub of the word list linked list to repoint to rom words 
9bf0			 
9bf0				; stub format 
9bf0				; db   word id 
9bf0				; dw    link to next word 
9bf0			        ; db char length of token 
9bf0				; db string + 0 term 
9bf0				; db exec code....  
9bf0			 
9bf0 3e 00			ld a, WORD_SYS_ROOT     ; root word 
9bf2 77				ld (hl), a		; word id 
9bf3 23				inc hl 
9bf4			 
9bf4 11 ba 9d			ld de, sysdict 
9bf7 73				ld (hl), e		; next word link ie system dict 
9bf8 23				inc hl 
9bf9 72				ld (hl), d		; next word link ie system dict 
9bfa 23				inc hl	 
9bfb			 
9bfb			;	ld (hl), sysdict		; next word link ie system dict 
9bfb			;	inc hl 
9bfb			;	inc hl 
9bfb			 
9bfb			;	inc hl 
9bfb			;	inc hl 
9bfb			 
9bfb 3e 02			ld a, 2			; word length is 0 
9bfd 77				ld (hl), a	 
9bfe 23				inc hl 
9bff			 
9bff 3e 7e			ld a, '~'			; word length is 0 
9c01 77				ld (hl), a	 
9c02 23				inc hl 
9c03 3e 00			ld a, 0			; save empty word 
9c05 77				ld (hl), a 
9c06			 
9c06 c9				ret 
9c07			 
9c07				 
9c07			 
9c07			forthexec_cleanup: 
9c07				FORTH_RSP_POP 
9c07 cd c1 98			call macro_forth_rsp_pop 
9c0a				endm 
# End of macro FORTH_RSP_POP
9c0a c9				ret 
9c0b			 
9c0b			forth_call_hl: 
9c0b				; taking hl 
9c0b e5				push hl 
9c0c c9				ret 
9c0d			 
9c0d			; this is called to reset Forth system but keep existing uwords etc 
9c0d			 
9c0d			forth_warmstart: 
9c0d				; setup stack over/under flow checks 
9c0d				if DEBUG_FORTH_STACK_GUARD 
9c0d cd 14 d5				call chk_stk_init 
9c10				endif 
9c10			 
9c10				; init stack pointers  - * these stacks go upwards *  
9c10 21 cb ea			ld hl, cli_ret_stack 
9c13 22 11 eb			ld (cli_ret_sp), hl	 
9c16				; set bottom of stack 
9c16 3e 00			ld a,0 
9c18 77				ld (hl),a 
9c19 23				inc hl 
9c1a 77				ld (hl),a 
9c1b			 
9c1b 21 c7 e8			ld hl, cli_data_stack 
9c1e 22 0d eb			ld (cli_data_sp), hl	 
9c21				; set bottom of stack 
9c21 3e 00			ld a,0 
9c23 77				ld (hl),a 
9c24 23				inc hl 
9c25 77				ld (hl),a 
9c26			 
9c26 21 c9 e9			ld hl, cli_loop_stack 
9c29 22 0f eb			ld (cli_loop_sp), hl	 
9c2c				; set bottom of stack 
9c2c 3e 00			ld a,0 
9c2e 77				ld (hl),a 
9c2f 23				inc hl 
9c30 77				ld (hl),a 
9c31			 
9c31				; init extent of current open file 
9c31			 
9c31 3e 00			ld a, 0 
9c33 32 5c eb			ld (store_openext), a 
9c36			 
9c36 c9				ret 
9c37			 
9c37			 
9c37			; Cold Start - this is called to setup the whole Forth system 
9c37			 
9c37			forth_init: 
9c37			 
9c37				; setup stack over/under flow checks 
9c37			 
9c37			;	if DEBUG_FORTH_STACK_GUARD 
9c37			;		call chk_stk_init 
9c37			;	endif 
9c37			 
9c37				; enable auto display updates (slow.....) 
9c37			 
9c37 3e 01			ld a, 1 
9c39 32 27 eb			ld (cli_autodisplay), a 
9c3c			 
9c3c			 
9c3c			 
9c3c				; show start up screen 
9c3c			 
9c3c cd 91 88			call clear_display 
9c3f			 
9c3f 3e 00			ld a,0 
9c41 32 49 eb			ld (f_cursor_ptr), a 
9c44			 
9c44				; set start of word list in start of ram - for use when creating user words 
9c44			 
9c44 21 df d7			ld hl, baseram 
9c47 22 5d e6			ld (os_last_new_uword), hl 
9c4a cd f0 9b			call user_word_eol 
9c4d				 
9c4d			;		call display_data_sp 
9c4d			;		call next_page_prompt 
9c4d			 
9c4d			 
9c4d			 
9c4d			 
9c4d c9				ret 
9c4e			 
9c4e .. 00		.bootforth: db " Forth Kernel Init ",0 
9c62			 
9c62			; TODO push to stack 
9c62			 
9c62			;  
9c62			 
9c62			if FORTH_PARSEV2 
9c62			 
9c62			 
9c62				include "forth_parserv2.asm" 
9c62			 
9c62			endif 
9c62			 
9c62			 
9c62			; parse cli version 1 
9c62			 
9c62			if FORTH_PARSEV1 
9c62			 
9c62			 
9c62			 
9c62			      include "forth_parserv1.asm" 
9c62			endif 
9c62				 
9c62			if FORTH_PARSEV3 
9c62			 
9c62			 
9c62			 
9c62			      include "forth_parserv3.asm" 
9c62				include "forth_wordsv3.asm" 
9c62			endif 
9c62			 
9c62			if FORTH_PARSEV4 
9c62			 
9c62			 
9c62			 
9c62			      include "forth_parserv4.asm" 
9c62				include "forth_wordsv4.asm" 
9c62			endif 
9c62			 
9c62			if FORTH_PARSEV5 
9c62			 
9c62			 
9c62			 
9c62			      include "forth_parserv5.asm" 
9c62			 
9c62			 
9c62			; A better parser without using malloc and string copies all over the place.  
9c62			; Exec in situ should be faster 
9c62			 
9c62			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
9c62			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
9c62			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
9c62			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
9c62			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
9c62			WORD_SYS_END: equ 0   ; Opcode for all user words 
9c62			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
9c62			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
9c62			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
9c62			 
9c62			; Core word preamble macro 
9c62			 
9c62			CWHEAD:   macro nxtword opcode lit len opflags 
9c62				db WORD_SYS_CORE+opcode             
9c62				; internal op code number 
9c62				dw nxtword            
9c62				; link to next dict word block 
9c62				db len + 1 
9c62				; literal length of dict word inc zero term 
9c62				db lit,0              
9c62				; literal dict word 
9c62			        ; TODO db opflags        
9c62				endm 
9c62			 
9c62			 
9c62			NEXTW: macro  
9c62				jp macro_next 
9c62				endm 
9c62			 
9c62			macro_next: 
9c62			if DEBUG_FORTH_PARSE_KEY 
9c62				DMARK "NXT" 
9c62				CALLMONITOR 
9c62			endif	 
9c62			;	inc hl  ; skip token null term  
9c62 ed 4b 2b eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9c66 ed 5b 29 eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9c6a 2a 61 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9c6d			if DEBUG_FORTH_PARSE_KEY 
9c6d				DMARK "}AA" 
9c6d				CALLMONITOR 
9c6d			endif	 
9c6d c3 70 9d			jp execnext 
9c70				;jp exec1 
9c70			       
9c70			 
9c70			 
9c70			; Another go at the parser to compile  
9c70			 
9c70			 
9c70			; TODO rework parser to change all of the string words to byte tokens 
9c70			; TODO do a search for  
9c70			 
9c70			; TODO first run normal parser to zero term sections 
9c70			; TODO for each word do a token look up to get the op code 
9c70			; TODO need some means to flag to the exec that this is a byte code form    
9c70			 
9c70			 
9c70			forthcompile: 
9c70			 
9c70			; 
9c70			; line parse: 
9c70			;       parse raw input buffer 
9c70			;       tokenise the words 
9c70			;       malloc new copy (for looping etc) 
9c70			;       copy to malloc + current pc in line to start of string and add line term 
9c70			;       save on new rsp 
9c70			; 
9c70			 
9c70			; hl to point to the line to tokenise 
9c70			 
9c70			;	push hl 
9c70 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
9c73			 
9c73			;	ld a,0		; string term on input 
9c73			;	call strlent 
9c73			 
9c73			;	ld (os_tok_len), hl	 ; save string length 
9c73			 
9c73			;if DEBUG_FORTH_TOK 
9c73			;	ex de,hl		 
9c73			;endif 
9c73			 
9c73			;	pop hl 		; get back string pointer 
9c73			 
9c73			if DEBUG_FORTH_TOK 
9c73						DMARK "TOc" 
9c73				CALLMONITOR 
9c73			endif 
9c73 7e			.cptoken2:    ld a,(hl) 
9c74 23				inc hl 
9c75 fe 7f			cp FORTH_END_BUFFER 
9c77 28 29			jr z, .cptokendone2 
9c79 fe 00			cp 0 
9c7b 28 25			jr z, .cptokendone2 
9c7d fe 22			cp '"' 
9c7f 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
9c81 fe 20			cp ' ' 
9c83 20 ee			jr nz,  .cptoken2 
9c85			 
9c85			; TODO consume comments held between ( and ) 
9c85			 
9c85				; we have a space so change to zero term for dict match later 
9c85 2b				dec hl 
9c86 3e 00			ld a,0 
9c88 77				ld (hl), a 
9c89 23				inc hl 
9c8a 18 e7			jr .cptoken2 
9c8c				 
9c8c			 
9c8c			.cptokenstr2: 
9c8c				; skip all white space until either eol (because forgot to term) or end double quote 
9c8c			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9c8c				;inc hl ; skip current double quote 
9c8c 7e				ld a,(hl) 
9c8d 23				inc hl 
9c8e fe 22			cp '"' 
9c90 28 e1			jr z, .cptoken2 
9c92 fe 7f			cp FORTH_END_BUFFER 
9c94 28 0c			jr z, .cptokendone2 
9c96 fe 00			cp 0 
9c98 28 08			jr z, .cptokendone2 
9c9a fe 20			cp ' ' 
9c9c 28 02			jr z, .cptmp2 
9c9e 18 ec			jr .cptokenstr2 
9ca0			 
9ca0			.cptmp2:	; we have a space so change to zero term for dict match later 
9ca0				;dec hl 
9ca0				;ld a,"-"	; TODO remove this when working 
9ca0				;ld (hl), a 
9ca0				;inc hl 
9ca0 18 ea			jr .cptokenstr2 
9ca2			 
9ca2			.cptokendone2: 
9ca2				;inc hl 
9ca2 3e 7f			ld a, FORTH_END_BUFFER 
9ca4 77				ld (hl),a 
9ca5 23				inc hl 
9ca6 3e 21			ld a, '!' 
9ca8 77				ld (hl),a 
9ca9			 
9ca9 2a 61 e6			ld hl,(os_tok_ptr) 
9cac			         
9cac			if DEBUG_FORTH_TOK 
9cac						DMARK "Tc1" 
9cac				CALLMONITOR 
9cac			endif 
9cac			 
9cac				; push exec string to top of return stack 
9cac				FORTH_RSP_NEXT 
9cac cd a0 98			call macro_forth_rsp_next 
9caf				endm 
# End of macro FORTH_RSP_NEXT
9caf c9				ret 
9cb0			 
9cb0			; Another go at the parser need to simplify the process 
9cb0			 
9cb0			forthparse: 
9cb0			 
9cb0			; 
9cb0			; line parse: 
9cb0			;       parse raw input buffer 
9cb0			;       tokenise the words 
9cb0			;       malloc new copy (for looping etc) 
9cb0			;       copy to malloc + current pc in line to start of string and add line term 
9cb0			;       save on new rsp 
9cb0			; 
9cb0			 
9cb0			; hl to point to the line to tokenise 
9cb0			 
9cb0			;	push hl 
9cb0 22 61 e6			ld (os_tok_ptr), hl  ; save ptr to string 
9cb3			 
9cb3			;	ld a,0		; string term on input 
9cb3			;	call strlent 
9cb3			 
9cb3			;	ld (os_tok_len), hl	 ; save string length 
9cb3			 
9cb3			;if DEBUG_FORTH_TOK 
9cb3			;	ex de,hl		 
9cb3			;endif 
9cb3			 
9cb3			;	pop hl 		; get back string pointer 
9cb3			 
9cb3			if DEBUG_FORTH_TOK 
9cb3						DMARK "TOK" 
9cb3				CALLMONITOR 
9cb3			endif 
9cb3 7e			.ptoken2:    ld a,(hl) 
9cb4 23				inc hl 
9cb5 fe 7f			cp FORTH_END_BUFFER 
9cb7 28 29			jr z, .ptokendone2 
9cb9 fe 00			cp 0 
9cbb 28 25			jr z, .ptokendone2 
9cbd fe 22			cp '"' 
9cbf 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
9cc1 fe 20			cp ' ' 
9cc3 20 ee			jr nz,  .ptoken2 
9cc5			 
9cc5			; TODO consume comments held between ( and ) 
9cc5			 
9cc5				; we have a space so change to zero term for dict match later 
9cc5 2b				dec hl 
9cc6 3e 00			ld a,0 
9cc8 77				ld (hl), a 
9cc9 23				inc hl 
9cca 18 e7			jr .ptoken2 
9ccc				 
9ccc			 
9ccc			.ptokenstr2: 
9ccc				; skip all white space until either eol (because forgot to term) or end double quote 
9ccc			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
9ccc				;inc hl ; skip current double quote 
9ccc 7e				ld a,(hl) 
9ccd 23				inc hl 
9cce fe 22			cp '"' 
9cd0 28 e1			jr z, .ptoken2 
9cd2 fe 7f			cp FORTH_END_BUFFER 
9cd4 28 0c			jr z, .ptokendone2 
9cd6 fe 00			cp 0 
9cd8 28 08			jr z, .ptokendone2 
9cda fe 20			cp ' ' 
9cdc 28 02			jr z, .ptmp2 
9cde 18 ec			jr .ptokenstr2 
9ce0			 
9ce0			.ptmp2:	; we have a space so change to zero term for dict match later 
9ce0				;dec hl 
9ce0				;ld a,"-"	; TODO remove this when working 
9ce0				;ld (hl), a 
9ce0				;inc hl 
9ce0 18 ea			jr .ptokenstr2 
9ce2			 
9ce2			.ptokendone2: 
9ce2				;inc hl 
9ce2 3e 7f			ld a, FORTH_END_BUFFER 
9ce4 77				ld (hl),a 
9ce5 23				inc hl 
9ce6 3e 21			ld a, '!' 
9ce8 77				ld (hl),a 
9ce9			 
9ce9 2a 61 e6			ld hl,(os_tok_ptr) 
9cec			         
9cec			if DEBUG_FORTH_TOK 
9cec						DMARK "TK1" 
9cec				CALLMONITOR 
9cec			endif 
9cec			 
9cec				; push exec string to top of return stack 
9cec				FORTH_RSP_NEXT 
9cec cd a0 98			call macro_forth_rsp_next 
9cef				endm 
# End of macro FORTH_RSP_NEXT
9cef c9				ret 
9cf0			 
9cf0			; 
9cf0			;	; malloc size + buffer pointer + if is loop flag 
9cf0			;	ld hl,(os_tok_len) 		 ; get string length 
9cf0			; 
9cf0			;	ld a,l 
9cf0			; 
9cf0			;	cp 0			; we dont want to use a null string 
9cf0			;	ret z 
9cf0			; 
9cf0			;;	add 3    ; prefix malloc with buffer for current word ptr 
9cf0			; 
9cf0			;	add 5     ; TODO when certain not over writing memory remove 
9cf0			; 
9cf0			;		 
9cf0			; 
9cf0			;if DEBUG_FORTH_TOK 
9cf0			;			DMARK "TKE" 
9cf0			;	CALLMONITOR 
9cf0			;endif 
9cf0			; 
9cf0			;	ld l,a 
9cf0			;	ld h,0 
9cf0			;;	push hl   ; save required space for the copy later 
9cf0			;	call malloc 
9cf0			;if DEBUG_FORTH_TOK 
9cf0			;			DMARK "TKM" 
9cf0			;	CALLMONITOR 
9cf0			;endif 
9cf0			;	if DEBUG_FORTH_MALLOC_GUARD 
9cf0			;		push af 
9cf0			;		call ishlzero 
9cf0			;;		ld a, l 
9cf0			;;		add h 
9cf0			;;		cp 0 
9cf0			;		pop af 
9cf0			;		 
9cf0			;		call z,malloc_error 
9cf0			;	endif 
9cf0			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
9cf0			; 
9cf0			; 
9cf0			;if DEBUG_FORTH_TOK 
9cf0			;			DMARK "TKR" 
9cf0			;	CALLMONITOR 
9cf0			;endif 
9cf0			; 
9cf0			;	FORTH_RSP_NEXT 
9cf0			; 
9cf0			;	;inc hl	 ; go past current buffer pointer 
9cf0			;	;inc hl 
9cf0			;	;inc hl   ; and past if loop flag 
9cf0			;		; TODO Need to set flag  
9cf0			; 
9cf0			;	 
9cf0			;	 
9cf0			;	ex de,hl	; malloc is dest 
9cf0			;	ld hl, (os_tok_len) 
9cf0			;;	pop bc 
9cf0			;	ld c, l                
9cf0			;	ld b,0 
9cf0			;	ld hl, (os_tok_ptr) 
9cf0			; 
9cf0			;if DEBUG_FORTH_TOK 
9cf0			;			DMARK "TKT" 
9cf0			;	CALLMONITOR 
9cf0			;endif 
9cf0			; 
9cf0			;	; do str cpy 
9cf0			; 
9cf0			;	ldir      ; copy byte in hl to de 
9cf0			; 
9cf0			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
9cf0			; 
9cf0			;if DEBUG_FORTH_TOK 
9cf0			; 
9cf0			;			DMARK "TKY" 
9cf0			;	CALLMONITOR 
9cf0			;endif 
9cf0			;	;ld a,0 
9cf0			;	;ld a,FORTH_END_BUFFER 
9cf0			;	ex de, hl 
9cf0			;	;dec hl			 ; go back over the space delim at the end of word 
9cf0			;	;ld (hl),a 
9cf0			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
9cf0			;	ld a,FORTH_END_BUFFER 
9cf0			;	ld (hl),a 
9cf0			;	inc hl 
9cf0			;	ld a,FORTH_END_BUFFER 
9cf0			;	ld (hl),a 
9cf0			; 
9cf0			;	; init the malloc area data 
9cf0			;	; set pc for in current area 
9cf0			;	;ld hl, (os_tok_malloc) 
9cf0			;	;inc hl 
9cf0			;	;inc hl 
9cf0			;	;inc hl 
9cf0			;	;ex de,hl 
9cf0			;	;ld hl, (os_tok_malloc) 
9cf0			;	;ld (hl),e 
9cf0			;	;inc hl 
9cf0			;	;ld (hl),d 
9cf0			; 
9cf0			; 
9cf0			;	ld hl,(os_tok_malloc) 
9cf0			;if DEBUG_FORTH_PARSE_KEY 
9cf0			;			DMARK "TKU" 
9cf0			;	CALLMONITOR 
9cf0			;endif 
9cf0			; 
9cf0			;	ret 
9cf0			 
9cf0			forthexec: 
9cf0			 
9cf0			; line exec: 
9cf0			; forth parser 
9cf0			 
9cf0			; 
9cf0			;       get current exec line on rsp 
9cf0			 
9cf0				FORTH_RSP_TOS 
9cf0 cd b7 98			call macro_forth_rsp_tos 
9cf3				endm 
# End of macro FORTH_RSP_TOS
9cf3			 
9cf3			;       restore current pc - hl points to malloc of data 
9cf3			 
9cf3				;ld e, (hl) 
9cf3				;inc hl 
9cf3				;ld d, (hl) 
9cf3				;ex de,hl 
9cf3			 
9cf3			 
9cf3			exec1: 
9cf3 22 61 e6			ld (os_tok_ptr), hl 
9cf6			 
9cf6				; copy our PC to working vars  
9cf6 22 2b eb			ld (cli_ptr), hl 
9cf9 22 29 eb			ld (cli_origptr), hl 
9cfc			 
9cfc 7e				ld a,(hl) 
9cfd fe 7f			cp FORTH_END_BUFFER 
9cff c8				ret z 
9d00			 
9d00				; skip any nulls 
9d00			 
9d00 fe 00			cp 0 
9d02 20 03			jr nz, .execword 
9d04 23				inc hl 
9d05 18 ec			jr exec1 
9d07			 
9d07			 
9d07			.execword: 
9d07			 
9d07			 
9d07			 
9d07			if DEBUG_FORTH_PARSE_KEY 
9d07						DMARK "KYQ" 
9d07				CALLMONITOR 
9d07			endif 
9d07			;       while at start of word: 
9d07			; get start of dict (in user area first) 
9d07			 
9d07 21 df d7		ld hl, baseram 
9d0a			;ld hl, sysdict 
9d0a 22 2d eb		ld (cli_nextword),hl 
9d0d			;           match word at pc 
9d0d			;           exec word 
9d0d			;           or push to dsp 
9d0d			;           forward to next token 
9d0d			;           if line term pop rsp and exit 
9d0d			;        
9d0d			 
9d0d			if DEBUG_FORTH_PARSE_KEY 
9d0d						DMARK "KYq" 
9d0d				CALLMONITOR 
9d0d			endif 
9d0d			 
9d0d			; 
9d0d			; word comp 
9d0d			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
9d0d			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
9d0d			;    move to start of word  
9d0d			;    compare word to cli_token 
9d0d			 
9d0d			.execpnword:	; HL at start of a word in the dictionary to check 
9d0d			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
9d0d			;	ld (cli_ptr), hl 
9d0d			 
9d0d 2a 2d eb			ld hl,(cli_nextword) 
9d10			 
9d10 cd b3 9d			call forth_tok_next 
9d13			; tok next start here 
9d13			;	; TODO skip compiled symbol for now 
9d13			;	inc hl 
9d13			; 
9d13			;	; save pointer to next word 
9d13			; 
9d13			;	; hl now points to the address of the next word pointer  
9d13			;	ld e, (hl) 
9d13			;	inc hl 
9d13			;	ld d, (hl) 
9d13			;	inc l 
9d13			; 
9d13			;	ex de,hl 
9d13			;if DEBUG_FORTH_PARSE_NEXTWORD 
9d13			;	push bc 
9d13			;	ld bc, (cli_nextword) 
9d13			;			DMARK "NXW" 
9d13			;	CALLMONITOR 
9d13			;	pop bc 
9d13			;endif 
9d13			; tok next end here 
9d13 22 2d eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
9d16 eb				ex de, hl 
9d17			 
9d17			 
9d17				; save the pointer of the current token - 1 to check against 
9d17				 
9d17 22 31 eb			ld (cli_token), hl   
9d1a				; TODO maybe remove below save if no debug 
9d1a				; save token string ptr for any debug later 
9d1a 23				inc hl  
9d1b 22 33 eb			ld (cli_origtoken), hl 
9d1e 2b				dec hl 
9d1f				; save pointer to the start of the next dictionay word 
9d1f 7e				ld a,(hl)   ; get string length 
9d20 47				ld b,a 
9d21			.execpnwordinc:  
9d21 23				inc hl 
9d22 10 fd			djnz .execpnwordinc 
9d24 22 2f eb			ld (cli_execword), hl      ; save start of this words code 
9d27			 
9d27				; now check the word token against the string being parsed 
9d27			 
9d27 2a 31 eb			ld hl,(cli_token) 
9d2a 23				inc hl     ; skip string length (use zero term instead to end) 
9d2b 22 31 eb			ld (cli_token), hl 
9d2e			 
9d2e			if DEBUG_FORTH_PARSE_KEY 
9d2e						DMARK "KY2" 
9d2e			endif 
9d2e			if DEBUG_FORTH_PARSE_EXEC 
9d2e				; see if disabled 
9d2e			 
9d2e				ld a, (os_view_disable) 
9d2e				cp '*' 
9d2e				jr z, .skip 
9d2e			 
9d2e				push hl 
9d2e				push hl 
9d2e				call clear_display 
9d2e				ld de, .compword 
9d2e				ld a, display_row_1 
9d2e				call str_at_display 
9d2e				pop de 
9d2e				ld a, display_row_2 
9d2e				call str_at_display 
9d2e				ld hl,(cli_ptr) 
9d2e				ld a,(hl) 
9d2e			        ld hl, os_word_scratch 
9d2e				ld (hl),a 
9d2e				ld a,0 
9d2e				inc hl 
9d2e				ld (hl),a 	 
9d2e				ld de, os_word_scratch 
9d2e				ld a, display_row_2+10 
9d2e				call str_at_display 
9d2e				call update_display 
9d2e				ld a, 100 
9d2e				call aDelayInMS 
9d2e				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9d2e				call delay250ms 
9d2e				endif 
9d2e				pop hl 
9d2e			.skip:  
9d2e			endif	 
9d2e			.execpnchar:    ; compare char between token and string to parse 
9d2e			 
9d2e			if DEBUG_FORTH_PARSE_KEY 
9d2e						DMARK "Ky3" 
9d2e			endif 
9d2e			if DEBUG_FORTH_PARSE_EXEC 
9d2e				; see if disabled 
9d2e			 
9d2e				ld a, (os_view_disable) 
9d2e				cp '*' 
9d2e				jr z, .skip2 
9d2e			 
9d2e			;	call clear_display 
9d2e			ld hl,(cli_token) 
9d2e			ld a,(hl) 
9d2e			ld (os_word_scratch),a 
9d2e				ld hl,(cli_ptr) 
9d2e			ld a,(hl) 
9d2e				ld (os_word_scratch+1),a 
9d2e				ld a,0 
9d2e				ld (os_word_scratch+2),a 
9d2e				ld de,os_word_scratch 
9d2e				ld a,display_row_4 
9d2e				call str_at_display 
9d2e				call update_display 
9d2e			.skip2:  
9d2e			endif 
9d2e 2a 31 eb			ld hl,(cli_token) 
9d31 7e				ld a, (hl)	 ; char in word token 
9d32 23				inc hl 		; move to next char 
9d33 22 31 eb			ld (cli_token), hl ; and save it 
9d36 47				ld b,a 
9d37			 
9d37 2a 2b eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
9d3a 7e				ld a,(hl) 
9d3b 23				inc hl 
9d3c 22 2b eb			ld (cli_ptr), hl		; move to next char 
9d3f cd 13 8f			call toUpper 		; make sure the input string matches case 
9d42			 
9d42			if DEBUG_FORTH_PARSE 
9d42			endif 
9d42			 
9d42				; input stream end of token is a space so get rid of it 
9d42			 
9d42			;	cp ' ' 
9d42			;	jr nz, .pnskipspace 
9d42			; 
9d42			;	ld a, 0		; make same term as word token term 
9d42			; 
9d42			;.pnskipspace: 
9d42			 
9d42			if DEBUG_FORTH_PARSE_KEY 
9d42						DMARK "KY7" 
9d42			endif 
9d42 b8				cp b 
9d43 c2 59 9d			jp nz, .execpnskipword	 ; no match so move to next word 
9d46				 
9d46			;    if same 
9d46			;       scan for string terms 0 for token and 32 for input 
9d46			 
9d46				 
9d46			if DEBUG_FORTH_PARSE_KEY 
9d46						DMARK "KY8" 
9d46			endif 
9d46			 
9d46 80				add b			 
9d47 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
9d49							; TODO need to make sure last word in zero term string is accounted for 
9d49 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
9d4b			 
9d4b			 
9d4b				; at end of both strings so both are exact match 
9d4b			 
9d4b			;       skip ptr for next word 
9d4b			 
9d4b 2a 2b eb			ld hl,(cli_ptr) 	; at input string term 
9d4e 23				inc hl			 ; at next char 
9d4f 22 2b eb			ld (cli_ptr), hl     ; save for next round of the parser 
9d52 22 29 eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
9d55				 
9d55				 
9d55			if DEBUG_FORTH_PARSE_KEY 
9d55						DMARK "KY3" 
9d55			endif 
9d55			 
9d55			 
9d55			 
9d55			;       exec code block 
9d55			if DEBUG_FORTH_JP 
9d55				call clear_display 
9d55				call update_display 
9d55				call delay1s 
9d55				ld hl, (cli_execword)     ; save for next check if no match on this word 
9d55				ld a,h 
9d55				ld hl, os_word_scratch 
9d55				call hexout 
9d55				ld hl, (cli_execword)     ; save for next check if no match on this word 
9d55				ld a,l 
9d55				ld hl, os_word_scratch+2 
9d55				call hexout 
9d55				ld hl, os_word_scratch+4 
9d55				ld a,0 
9d55				ld (hl),a 
9d55				ld de,os_word_scratch 
9d55				call str_at_display 
9d55					ld a, display_row_2 
9d55					call str_at_display 
9d55				ld de, (cli_origtoken) 
9d55				ld a, display_row_1+10 
9d55					call str_at_display 
9d55			 
9d55				ld a,display_row_1 
9d55				ld de, .foundword 
9d55				ld a, display_row_3 
9d55				call str_at_display 
9d55				call update_display 
9d55				call delay1s 
9d55				call delay1s 
9d55				call delay1s 
9d55			endif 
9d55			 
9d55			if DEBUG_FORTH_PARSE_KEY 
9d55						DMARK "KYj" 
9d55			endif 
9d55				; TODO save the word pointer in this exec 
9d55			 
9d55 2a 2f eb			ld hl,(cli_execword) 
9d58 e9				jp (hl) 
9d59			 
9d59			 
9d59			;    if not same 
9d59			;	scan for zero term 
9d59			;	get ptr for next word 
9d59			;	goto word comp 
9d59			 
9d59			.execpnskipword:	; get pointer to next word 
9d59 2a 2d eb			ld hl,(cli_nextword) 
9d5c			 
9d5c 7e				ld a,(hl) 
9d5d fe 00			cp WORD_SYS_END 
9d5f			;	cp 0 
9d5f 28 09			jr z, .execendofdict			 ; at end of words 
9d61			 
9d61			if DEBUG_FORTH_PARSE_KEY 
9d61						DMARK "KY4" 
9d61			endif 
9d61			if DEBUG_FORTH_PARSE_EXEC 
9d61			 
9d61				; see if disabled 
9d61			 
9d61				ld a, (os_view_disable) 
9d61				cp '*' 
9d61				jr z, .noskip 
9d61			 
9d61			 
9d61				ld de, .nowordfound 
9d61				ld a, display_row_3 
9d61				call str_at_display 
9d61				call update_display 
9d61				ld a, 100 
9d61				call aDelayInMS 
9d61				 
9d61				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9d61					call delay250ms 
9d61				endif 
9d61			.noskip:  
9d61			 
9d61			endif	 
9d61			 
9d61 2a 29 eb			ld hl,(cli_origptr) 
9d64 22 2b eb			ld (cli_ptr),hl 
9d67			 
9d67			if DEBUG_FORTH_PARSE_KEY 
9d67						DMARK "KY5" 
9d67			endif 
9d67 c3 0d 9d			jp .execpnword			; else go to next word 
9d6a			 
9d6a			.execendofdict:  
9d6a			 
9d6a			if DEBUG_FORTH_PARSE_KEY 
9d6a						DMARK "KYe" 
9d6a			endif 
9d6a			if DEBUG_FORTH_PARSE_EXEC 
9d6a				; see if disabled 
9d6a			 
9d6a				ld a, (os_view_disable) 
9d6a				cp '*' 
9d6a				jr z, .ispskip 
9d6a			 
9d6a				call clear_display 
9d6a				call update_display 
9d6a				call delay1s 
9d6a				ld de, (cli_origptr) 
9d6a				ld a, display_row_1 
9d6a				call str_at_display 
9d6a				 
9d6a				ld de, .enddict 
9d6a				ld a, display_row_3 
9d6a				call str_at_display 
9d6a				call update_display 
9d6a				ld a, 100 
9d6a				call aDelayInMS 
9d6a				if DEBUG_FORTH_PARSE_EXEC_SLOW 
9d6a				call delay1s 
9d6a				call delay1s 
9d6a				call delay1s 
9d6a				endif 
9d6a			.ispskip:  
9d6a				 
9d6a			endif	 
9d6a			 
9d6a			 
9d6a			 
9d6a				; if the word is not a keyword then must be a literal so push it to stack 
9d6a			 
9d6a			; push token to stack to end of word 
9d6a			 
9d6a				STACKFRAME ON $1efe $2f9f 
9d6a				if DEBUG_STACK_IMB 
9d6a					if ON 
9d6a						exx 
9d6a						ld de, $1efe 
9d6a						ld a, d 
9d6a						ld hl, curframe 
9d6a						call hexout 
9d6a						ld a, e 
9d6a						ld hl, curframe+2 
9d6a						call hexout 
9d6a						ld hl, $1efe 
9d6a						push hl 
9d6a						ld hl, $2f9f 
9d6a						push hl 
9d6a						exx 
9d6a					endif 
9d6a				endif 
9d6a			endm 
# End of macro STACKFRAME
9d6a			 
9d6a 2a 61 e6		ld hl,(os_tok_ptr) 
9d6d cd 62 9a		call forth_apush 
9d70			 
9d70				STACKFRAMECHK ON $1efe $2f9f 
9d70				if DEBUG_STACK_IMB 
9d70					if ON 
9d70						exx 
9d70						ld hl, $2f9f 
9d70						pop de   ; $2f9f 
9d70						call cmp16 
9d70						jr nz, .spnosame 
9d70						ld hl, $1efe 
9d70						pop de   ; $1efe 
9d70						call cmp16 
9d70						jr z, .spfrsame 
9d70						.spnosame: call showsperror 
9d70						.spfrsame: nop 
9d70						exx 
9d70					endif 
9d70				endif 
9d70			endm 
# End of macro STACKFRAMECHK
9d70			 
9d70			execnext: 
9d70			 
9d70			if DEBUG_FORTH_PARSE_KEY 
9d70						DMARK "KY>" 
9d70			endif 
9d70			; move past token to next word 
9d70			 
9d70 2a 61 e6		ld hl, (os_tok_ptr) 
9d73 3e 00		ld a, 0 
9d75 01 ff 00		ld bc, 255     ; input buffer size 
9d78 ed b1		cpir 
9d7a			 
9d7a			if DEBUG_FORTH_PARSE_KEY 
9d7a						DMARK "KY!" 
9d7a				CALLMONITOR 
9d7a			endif	 
9d7a			; TODO this might place hl on the null, so will need to forward on??? 
9d7a			;inc hl   ; see if this gets onto the next item 
9d7a			 
9d7a			 
9d7a			; TODO pass a pointer to the buffer to push 
9d7a			; TODO call function to push 
9d7a			 
9d7a			; look for end of input 
9d7a			 
9d7a			;inc hl 
9d7a			;ld a,(hl) 
9d7a			;cp FORTH_END_BUFFER 
9d7a			;ret z 
9d7a			 
9d7a			 
9d7a c3 f3 9c		jp exec1 
9d7d			 
9d7d			 
9d7d			 
9d7d			 
9d7d			 
9d7d			 
9d7d			 
9d7d			 
9d7d			 
9d7d			findnexttok: 
9d7d			 
9d7d				; hl is pointer to move 
9d7d				; de is the token to locate 
9d7d			 
9d7d					if DEBUG_FORTH 
9d7d						DMARK "NTK" 
9d7d						CALLMONITOR 
9d7d					endif 
9d7d d5				push de 
9d7e			 
9d7e			.fnt1:	 
9d7e				; find first char of token to locate 
9d7e			 
9d7e 1a				ld a, (de) 
9d7f 4f				ld c,a 
9d80 7e				ld a,(hl) 
9d81 cd 13 8f			call toUpper 
9d84					if DEBUG_FORTH 
9d84						DMARK "NT1" 
9d84						CALLMONITOR 
9d84					endif 
9d84 b9				cp c 
9d85			 
9d85 28 03			jr z, .fnt2cmpmorefirst	 
9d87			 
9d87				; first char not found move to next char 
9d87			 
9d87 23				inc hl 
9d88 18 f4			jr .fnt1 
9d8a			 
9d8a			.fnt2cmpmorefirst:	 
9d8a				; first char of token found.  
9d8a			 
9d8a e5				push hl     ; save start of token just in case it is the right one 
9d8b d9				exx 
9d8c e1				pop hl        ; save it to hl' 
9d8d d9				exx 
9d8e			 
9d8e			 
9d8e			.fnt2cmpmore:	 
9d8e				; compare the rest 
9d8e				 
9d8e 23				inc hl 
9d8f 13				inc de 
9d90				 
9d90 1a				ld a, (de) 
9d91 4f				ld c,a 
9d92 7e				ld a,(hl) 
9d93 cd 13 8f			call toUpper 
9d96			 
9d96					if DEBUG_FORTH 
9d96						DMARK "NT2" 
9d96						CALLMONITOR 
9d96					endif 
9d96				; c has the token to find char 
9d96				; a has the mem to scan char 
9d96			 
9d96 b9				cp c 
9d97 28 04			jr z,.fntmatch1 
9d99			 
9d99				; they are not the same 
9d99			 
9d99					if DEBUG_FORTH 
9d99						DMARK "NT3" 
9d99						CALLMONITOR 
9d99					endif 
9d99 d1				pop de	; reset de token to look for 
9d9a d5				push de 
9d9b 18 e1			jr .fnt1 
9d9d				 
9d9d			.fntmatch1: 
9d9d			 
9d9d				; is the same char a null which means we might have a full hit? 
9d9d					if DEBUG_FORTH 
9d9d						DMARK "NT4" 
9d9d						CALLMONITOR 
9d9d					endif 
9d9d			 
9d9d fe 00			cp 0 
9d9f 28 0b			jr z, .fntmatchyes 
9da1			 
9da1				; are we at the end of the token to find? 
9da1			 
9da1					if DEBUG_FORTH 
9da1						DMARK "NT5" 
9da1						CALLMONITOR 
9da1					endif 
9da1 3e 00			ld a, 0 
9da3 b9				cp c 
9da4			 
9da4 c2 8e 9d			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
9da7			 
9da7					if DEBUG_FORTH 
9da7						DMARK "NT6" 
9da7						CALLMONITOR 
9da7					endif 
9da7				; token to find is exhusted but no match to stream 
9da7			 
9da7				; restore tok pointer and continue on 
9da7 d1				pop de 
9da8 d5				push de 
9da9 c3 7e 9d			jp .fnt1 
9dac			 
9dac			 
9dac			.fntmatchyes: 
9dac			 
9dac				; hl now contains the end of the found token 
9dac			 
9dac				; get rid of saved token pointer to find 
9dac			 
9dac d1				pop de 
9dad			 
9dad					if DEBUG_FORTH 
9dad						DMARK "NT9" 
9dad						CALLMONITOR 
9dad					endif 
9dad			 
9dad				; hl will be on the null term so forward on 
9dad			 
9dad				; get back the saved start of the token 
9dad			 
9dad d9				exx 
9dae e5				push hl     ; save start of token just in case it is the right one 
9daf d9				exx 
9db0 e1				pop hl        ; save it to hl 
9db1			 
9db1 c9				ret 
9db2			 
9db2			 
9db2			; LIST needs to find a specific token   
9db2			; FORGET needs to find a spefici token 
9db2			 
9db2			; SAVE needs to find all tokens by flag 
9db2			; WORDS just needs to scan through all  by flag 
9db2			; UWORDS needs to scan through all by flag 
9db2			 
9db2			 
9db2			; given hl as pointer to start of dict look up string 
9db2			; return hl as pointer to start of word block 
9db2			; or 0 if not found 
9db2			 
9db2			forth_find_tok: 
9db2 c9				ret 
9db3			 
9db3			; given hl as pointer to dict structure 
9db3			; move to the next dict block structure 
9db3			 
9db3			forth_tok_next: 
9db3				; hl now points to the address of the next word pointer  
9db3				; TODO skip compiled symbol for now 
9db3			;	push de 
9db3 23				inc hl 
9db4 5e				ld e, (hl) 
9db5 23				inc hl 
9db6 56				ld d, (hl) 
9db7 23				inc hl 
9db8			 
9db8 eb				ex de,hl 
9db9			if DEBUG_FORTH_PARSE_NEXTWORD 
9db9				push bc 
9db9				ld bc, (cli_nextword) 
9db9						DMARK "NXW" 
9db9				CALLMONITOR 
9db9				pop bc 
9db9			endif 
9db9			;	pop de	 
9db9 c9				ret 
9dba			 
9dba			 
9dba			 
9dba			; eof 
# End of file forth_parserv5.asm
9dba				include "forth_wordsv4.asm" 
9dba			 
9dba			; the core word dictionary v4 
9dba			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
9dba			 
9dba			; this is a linked list for each of the system words used 
9dba			; user defined words will follow the same format but will be in ram 
9dba			 
9dba			 
9dba			; 
9dba			; 
9dba			; define linked list: 
9dba			; 
9dba			; 1. compiled byte op code 
9dba			; 2. len of text word 
9dba			; 3. text word 
9dba			; 4. ptr to next dictionary word 
9dba			; 5. asm, calls etc for the word 
9dba			; 
9dba			;  if 1 == 0 then last word in dict  
9dba			;   
9dba			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
9dba			;  
9dba			;  
9dba			; create basic standard set of words 
9dba			; 
9dba			;  
9dba			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
9dba			; 2DUP 2DROP 2SWAP  
9dba			; @ C@ - get byte  
9dba			; ! C! - store byte 
9dba			; 0< true if less than zero 
9dba			; 0= true if zero 
9dba			; < >  
9dba			; = true if same 
9dba			; variables 
9dba			 
9dba			 
9dba			; Hardware specific words I may need 
9dba			; 
9dba			; IN OUT  
9dba			; calls to key util functions 
9dba			; calls to hardward abstraction stuff 
9dba			; easy control of frame buffers and lcd i/o 
9dba			; keyboard  
9dba			 
9dba			 
9dba			;DICT: macro 
9dba			; op_code, len, word, next 
9dba			;    word: 
9dba			;    db op_code 
9dba			;    ds word zero term 
9dba			;    dw next 
9dba			;    endm 
9dba			 
9dba			 
9dba			 
9dba			 
9dba			; op code 1 is a flag for user define words which are to be handled differently 
9dba			 
9dba			 
9dba			; 
9dba			; 
9dba			;    TODO on entry to a word this should be the expected environment 
9dba			;    hl - tos value if number then held, if string this is the ptr 
9dba			;    de -  
9dba			 
9dba			 
9dba			; opcode ranges 
9dba			; 0 - end of word dict 
9dba			; 255 - user define words 
9dba			 
9dba			sysdict: 
9dba			include "forth_opcodes.asm" 
9dba			; op codes for forth keywords 
9dba			; free to use code 0  
9dba				OPCODE_HEAP: equ  1 
9dba				OPCODE_EXEC: equ 2 
9dba				OPCODE_DUP: equ 3 
9dba				OPCODE_SWAP: equ 4 
9dba				OPCODE_COLN: equ 5 
9dba				OPCODE_SCOLN: equ 6 
9dba				OPCODE_DROP: equ 7 
9dba				OPCODE_DUP2: equ 8 
9dba				OPCODE_DROP2: equ 9 
9dba				OPCODE_SWAP2: equ 10 
9dba				OPCODE_AT: equ 11 
9dba				OPCODE_CAT: equ 12 
9dba				OPCODE_BANG: equ 13 
9dba				OPCODE_CBANG: equ 14 
9dba				OPCODE_SCALL: equ 15 
9dba				OPCODE_DEPTH: equ 16 
9dba				OPCODE_OVER: equ 17 
9dba				OPCODE_PAUSE: equ 18 
9dba				OPCODE_PAUSES: equ 19 
9dba				OPCODE_ROT: equ 20 
9dba			;free to reuse	OPCODE_WORDS: equ 21 
9dba			        OPCODE_NOT: equ 21 
9dba				OPCODE_UWORDS: equ 22 
9dba				OPCODE_BP: equ 23 
9dba				OPCODE_MONITOR: equ 24  
9dba				OPCODE_MALLOC: equ 25 
9dba				OPCODE_FREE: equ 26 
9dba				OPCODE_LIST: equ 27 
9dba				OPCODE_FORGET: equ 28 
9dba				OPCODE_NOP: equ 29 
9dba				OPCODE_COMO: equ 30 
9dba				OPCODE_COMC: equ 31 
9dba			;free to reuse	OPCODE_ENDCORE: equ 32 
9dba				OPCODE_AFTERSOUND: equ 33 
9dba				OPCODE_GP2: equ 34 
9dba				OPCODE_GP3: equ 35 
9dba				OPCODE_GP4: equ 36 
9dba				OPCODE_SIN: equ 37 
9dba				OPCODE_SOUT: equ 38 
9dba				OPCODE_SPIO: equ 39 
9dba				OPCODE_SPICEH: equ 40 
9dba				OPCODE_SPIOb: equ 41 
9dba				OPCODE_SPII: equ 42 
9dba				OPCODE_SESEL: equ 43 
9dba				OPCODE_CARTDEV: equ 44 
9dba			; free to reuse	OPCODE_ENDDEVICE: equ 45 
9dba				OPCODE_FB: equ 46 
9dba				OPCODE_EMIT: equ 47 
9dba				OPCODE_DOTH: equ 48 
9dba				OPCODE_DOTF: equ 49 
9dba				OPCODE_DOT: equ 50 
9dba				OPCODE_CLS: equ 51 
9dba				OPCODE_DRAW: equ 52 
9dba				OPCODE_DUMP: equ 53 
9dba				OPCODE_CDUMP: equ 54 
9dba				OPCODE_DAT: equ 55 
9dba				OPCODE_HOME: equ 56 
9dba				OPCODE_SPACE: equ 57 
9dba				OPCODE_SPACES: equ 58 
9dba				OPCODE_SCROLL: equ 59 
9dba				OPCODE_ATQ: equ 60 
9dba				OPCODE_AUTODSP: equ 61 
9dba				OPCODE_MENU: equ 62 
9dba			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
9dba				OPCODE_THEN: equ 64 
9dba				OPCODE_ELSE: equ 65 
9dba				OPCODE_DO: equ 66 
9dba				OPCODE_LOOP: equ 67 
9dba				OPCODE_I: equ 68 
9dba				OPCODE_DLOOP: equ 69  
9dba				OPCODE_REPEAT: equ 70  
9dba				OPCODE_UNTIL: equ 71 
9dba				OPCODE_ENDFLOW: equ 72 
9dba				OPCODE_WAITK: equ 73 
9dba				OPCODE_ACCEPT: equ 74 
9dba				OPCODE_EDIT: equ 75 
9dba			;free to reuse	OPCODE_ENDKEY: equ 76 
9dba				OPCODE_LZERO: equ 77 
9dba				OPCODE_TZERO: equ 78 
9dba				OPCODE_LESS: equ 79 
9dba				OPCODE_GT: equ 80 
9dba				OPCODE_EQUAL: equ 81  
9dba			;free to reuse	OPCODE_ENDLOGIC: equ 82 
9dba				OPCODE_NEG: equ 83 
9dba				OPCODE_DIV: equ 84 
9dba				OPCODE_MUL: equ 85 
9dba				OPCODE_MIN: equ 86 
9dba				OPCODE_MAX: equ 87 
9dba				OPCODE_RND16: equ 88 
9dba				OPCODE_RND8: equ 89 
9dba				OPCODE_RND: equ 90 
9dba			;free to reuse	OPCODE_ENDMATHS: equ 91  
9dba				OPCODE_BYNAME: equ 92 
9dba				OPCODE_DIR: equ 93 
9dba				OPCODE_SAVE: equ 94 
9dba				OPCODE_LOAD: equ 95 
9dba				OPCODE_BSAVE: equ 96 
9dba				OPCODE_BLOAD: equ 97 
9dba				OPCODE_SEO: equ 98  
9dba				OPCODE_SEI: equ 99 
9dba				OPCODE_SFREE: equ 100 
9dba				OPCODE_SIZE: equ 101 
9dba				OPCODE_CREATE: equ 102 
9dba				OPCODE_APPEND: equ 103 
9dba				OPCODE_SDEL: equ 104 
9dba				OPCODE_OPEN: equ 105 
9dba				OPCODE_READ: equ 106 
9dba				OPCODE_EOF: equ 106 
9dba				OPCODE_FORMAT: equ 107 
9dba				OPCODE_LABEL: equ 108 
9dba				OPCODE_LABELS: equ 109 
9dba			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
9dba				OPCODE_UPPER: equ 111 
9dba				OPCODE_LOWER: equ 112 
9dba				OPCODE_SUBSTR: equ 113 
9dba				OPCODE_LEFT: equ 114 
9dba				OPCODE_RIGHT: equ 115 
9dba				OPCODE_STR2NUM: equ 116 
9dba				OPCODE_NUM2STR: equ 117 
9dba				OPCODE_CONCAT: equ 118 
9dba				OPCODE_FIND: equ 119 
9dba				OPCODE_LEN: equ 120 
9dba				OPCODE_CHAR: equ 121 
9dba			; free to reuse	OPCODE_STRLEN: equ 122 
9dba			; free to reuse	OPCODE_ENDSTR: equ 123 
9dba				OPCODE_V0S: equ 124 
9dba				OPCODE_V0Q: equ 125 
9dba				OPCODE_V1S: equ 126 
9dba				OPCODE_V1Q: equ 127 
9dba				OPCODE_V2S: equ 128 
9dba				OPCODE_V2Q: equ 129 
9dba				OPCODE_V3S: equ 130 
9dba				OPCODE_V3Q: equ 131 
9dba			;free to reuse	OPCODE_END: equ 132 
9dba				OPCODE_ZDUP: equ 133 
9dba			 
9dba			; eof 
# End of file forth_opcodes.asm
9dba			 
9dba			include "forth_words_core.asm" 
9dba			 
9dba			; | ## Core Words 
9dba			 
9dba			;if MALLOC_4 
9dba			 
9dba			.HEAP: 
9dba				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
9dba 15				db WORD_SYS_CORE+OPCODE_HEAP             
9dbb f9 9d			dw .EXEC            
9dbd 05				db 4 + 1 
9dbe .. 00			db "HEAP",0              
9dc3				endm 
# End of macro CWHEAD
9dc3			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
9dc3			; | | u1 - Current number of bytes in the heap 
9dc3			; | | u2 - Remaining bytes left on the heap 
9dc3			; | |  
9dc3			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
9dc3			 
9dc3			 
9dc3					if DEBUG_FORTH_WORDS_KEY 
9dc3						DMARK "HEP" 
9dc3 f5				push af  
9dc4 3a d8 9d			ld a, (.dmark)  
9dc7 32 7a ee			ld (debug_mark),a  
9dca 3a d9 9d			ld a, (.dmark+1)  
9dcd 32 7b ee			ld (debug_mark+1),a  
9dd0 3a da 9d			ld a, (.dmark+2)  
9dd3 32 7c ee			ld (debug_mark+2),a  
9dd6 18 03			jr .pastdmark  
9dd8 ..			.dmark: db "HEP"  
9ddb f1			.pastdmark: pop af  
9ddc			endm  
# End of macro DMARK
9ddc						CALLMONITOR 
9ddc cd 6c 93			call break_point_state  
9ddf				endm  
# End of macro CALLMONITOR
9ddf					endif 
9ddf 2a e9 d7				ld hl, (free_list )      
9de2 11 ee d7				ld de, heap_start 
9de5			 
9de5 ed 52				sbc hl, de  
9de7			 
9de7 cd f9 98				call forth_push_numhl 
9dea			 
9dea			 
9dea ed 5b e9 d7			ld de, (free_list )      
9dee 21 46 e3				ld hl, heap_end 
9df1			 
9df1 ed 52				sbc hl, de 
9df3			 
9df3 cd f9 98				call forth_push_numhl 
9df6					 
9df6			 
9df6					 
9df6			 
9df6			 
9df6			 
9df6					NEXTW 
9df6 c3 62 9c			jp macro_next 
9df9				endm 
# End of macro NEXTW
9df9			;endif 
9df9			 
9df9			.EXEC: 
9df9			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
9df9			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
9df9			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
9df9			;; > > 
9df9			;; > >   
9df9			;	STACKFRAME OFF $5efe $5f9f 
9df9			; 
9df9			;		if DEBUG_FORTH_WORDS_KEY 
9df9			;			DMARK "EXE" 
9df9			;			CALLMONITOR 
9df9			;		endif 
9df9			; 
9df9			;	FORTH_DSP_VALUEHL 
9df9			; 
9df9			;	FORTH_DSP_POP 
9df9			; 
9df9			;		if DEBUG_FORTH_WORDS 
9df9			;			DMARK "EX1" 
9df9			;			CALLMONITOR 
9df9			;		endif 
9df9			;;	ld e,(hl) 
9df9			;;	inc hl 
9df9			;;	ld d,(hl) 
9df9			;;	ex de,hl 
9df9			; 
9df9			;;		if DEBUG_FORTH_WORDS 
9df9			;;			DMARK "EX2" 
9df9			;;			CALLMONITOR 
9df9			;;		endif 
9df9			;	push hl 
9df9			; 
9df9			;	;ld a, 0 
9df9			;	;ld a, FORTH_END_BUFFER 
9df9			;	call strlenz 
9df9			;	inc hl   ; include zero term to copy 
9df9			;	inc hl   ; include term 
9df9			;	inc hl   ; include term 
9df9			;	ld b,0 
9df9			;	ld c,l 
9df9			;	pop hl 
9df9			;	ld de, execscratch 
9df9			;		if DEBUG_FORTH_WORDS 
9df9			;			DMARK "EX3" 
9df9			;			CALLMONITOR 
9df9			;		endif 
9df9			;	ldir 
9df9			; 
9df9			; 
9df9			;	ld hl, execscratch 
9df9			; 
9df9			;		if DEBUG_FORTH_WORDS 
9df9			;			DMARK "EXe" 
9df9			;			CALLMONITOR 
9df9			;		endif 
9df9			; 
9df9			;	call forthparse 
9df9			;	call forthexec 
9df9			;;	call forthexec_cleanup 
9df9			;;	call forthparse 
9df9			;;	call forthexec 
9df9			; 
9df9			;	STACKFRAMECHK OFF $5efe $5f9f 
9df9			; 
9df9			;	; an immediate word so no need to process any more words 
9df9			;	ret 
9df9			;	NEXTW 
9df9			 
9df9			; dead code - old version  
9df9			;	FORTH_RSP_NEXT 
9df9			 
9df9			;  
9df9			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
9df9			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
9df9			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
9df9			;	push hl 
9df9			;	push de 
9df9			;	push bc 
9df9			; 
9df9			; 
9df9			;		if DEBUG_FORTH_WORDS_KEY 
9df9			;			DMARK "EXR" 
9df9			;			CALLMONITOR 
9df9			;		endif 
9df9			; 
9df9			; 
9df9			; 
9df9			;	;v5 FORTH_DSP_VALUE 
9df9			;	FORTH_DSP_VALUEHL 
9df9			; 
9df9			;	; TODO do string type checks 
9df9			; 
9df9			;;v5	inc hl   ; skip type 
9df9			; 
9df9			;	push hl  ; source code  
9df9			;		if DEBUG_FORTH_WORDS 
9df9			;			DMARK "EX1" 
9df9			;			CALLMONITOR 
9df9			;		endif 
9df9			;	ld a, 0 
9df9			;	call strlent 
9df9			; 
9df9			;	inc hl 
9df9			;	inc hl 
9df9			;	inc hl 
9df9			;	inc hl 
9df9			; 
9df9			;	push hl    ; size 
9df9			; 
9df9			;		if DEBUG_FORTH_WORDS 
9df9			;			DMARK "EX2" 
9df9			;			CALLMONITOR 
9df9			;		endif 
9df9			;	call malloc 
9df9			; 
9df9			;	ex de, hl    ; de now contains malloc area 
9df9			;	pop bc   	; get byte count 
9df9			;	pop hl      ; get string to copy 
9df9			; 
9df9			;	push de     ; save malloc for free later 
9df9			; 
9df9			;		if DEBUG_FORTH_WORDS 
9df9			;			DMARK "EX3" 
9df9			;			CALLMONITOR 
9df9			;		endif 
9df9			;	ldir       ; duplicate string 
9df9			; 
9df9			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
9df9			;	 
9df9			;	; TODO fix the parse would be better than this...  
9df9			;	ex de, hl 
9df9			;	dec hl 
9df9			;	ld a, 0 
9df9			;	ld (hl), a 
9df9			;	dec hl 
9df9			;	ld a, ' ' 
9df9			;	ld (hl), a 
9df9			;	dec hl 
9df9			;	ld (hl), a 
9df9			; 
9df9			;	dec hl 
9df9			;	ld (hl), a 
9df9			; 
9df9			; 
9df9			;	FORTH_DSP_POP  
9df9			; 
9df9			;	pop hl     
9df9			;	push hl    ; save malloc area 
9df9			; 
9df9			;		if DEBUG_FORTH_WORDS 
9df9			;			DMARK "EX4" 
9df9			;			CALLMONITOR 
9df9			;		endif 
9df9			; 
9df9			;	call forthparse 
9df9			;	call forthexec 
9df9			;	 
9df9			;	pop hl 
9df9			;	if DEBUG_FORTH_WORDS 
9df9			;		DMARK "EX5" 
9df9			;		CALLMONITOR 
9df9			;	endif 
9df9			; 
9df9			;	if FORTH_ENABLE_FREE 
9df9			;	call free 
9df9			;	endif 
9df9			; 
9df9			;	if DEBUG_FORTH_WORDS 
9df9			;		DMARK "EX6" 
9df9			;		CALLMONITOR 
9df9			;	endif 
9df9			; 
9df9			;	pop bc 
9df9			;	pop de 
9df9			;	pop hl 
9df9			;;	FORTH_RSP_POP	  
9df9			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
9df9			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
9df9			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
9df9			; 
9df9			;	if DEBUG_FORTH_WORDS 
9df9			;		DMARK "EX7" 
9df9			;		CALLMONITOR 
9df9			;	endif 
9df9			;	NEXTW 
9df9			 
9df9			;.STKEXEC: 
9df9			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
9df9			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
9df9			; 
9df9			; 
9df9			;		if DEBUG_FORTH_WORDS_KEY 
9df9			;			DMARK "STX" 
9df9			;			CALLMONITOR 
9df9			;		endif 
9df9			; 
9df9			;	FORTH_DSP_VALUEHL 
9df9			; 
9df9			;	ld (store_tmp1), hl    ; count 
9df9			; 
9df9			;	FORTH_DSP_POP 
9df9			;.stkexec1: 
9df9			;	ld hl, (store_tmp1)   ; count 
9df9			;	ld a, 0 
9df9			;	cp l 
9df9			;	ret z 
9df9			; 
9df9			;	dec hl 
9df9			;	ld (store_tmp1), hl    ; count 
9df9			;	 
9df9			;	FORTH_DSP_VALUEHL 
9df9			;	push hl 
9df9			;	 
9df9			;		if DEBUG_FORTH_WORDS 
9df9			;			DMARK "EXp" 
9df9			;			CALLMONITOR 
9df9			;		endif 
9df9			;	FORTH_DSP_POP 
9df9			; 
9df9			;	call strlenz 
9df9			;	inc hl   ; include zero term to copy 
9df9			;	inc hl   ; include zero term to copy 
9df9			;	inc hl   ; include zero term to copy 
9df9			;	ld b,0 
9df9			;	ld c,l 
9df9			;	pop hl 
9df9			;	ld de, execscratch 
9df9			;		if DEBUG_FORTH_WORDS 
9df9			;			DMARK "EX3" 
9df9			;			CALLMONITOR 
9df9			;		endif 
9df9			;	ldir 
9df9			; 
9df9			; 
9df9			;	ld hl, execscratch 
9df9			; 
9df9			;		if DEBUG_FORTH_WORDS 
9df9			;			DMARK "EXP" 
9df9			;			CALLMONITOR 
9df9			;		endif 
9df9			; 
9df9			;	call forthparse 
9df9			;	ld hl, execscratch 
9df9			;		if DEBUG_FORTH_WORDS 
9df9			;			DMARK "EXx" 
9df9			;			CALLMONITOR 
9df9			;		endif 
9df9			;	call forthexec 
9df9			; 
9df9			;	jp .stkexec1 
9df9			; 
9df9			;	ret 
9df9			 
9df9			 
9df9			.DUP: 
9df9				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
9df9 17				db WORD_SYS_CORE+OPCODE_DUP             
9dfa 6f 9e			dw .ZDUP            
9dfc 04				db 3 + 1 
9dfd .. 00			db "DUP",0              
9e01				endm 
# End of macro CWHEAD
9e01			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
9e01			 
9e01					if DEBUG_FORTH_WORDS_KEY 
9e01						DMARK "DUP" 
9e01 f5				push af  
9e02 3a 16 9e			ld a, (.dmark)  
9e05 32 7a ee			ld (debug_mark),a  
9e08 3a 17 9e			ld a, (.dmark+1)  
9e0b 32 7b ee			ld (debug_mark+1),a  
9e0e 3a 18 9e			ld a, (.dmark+2)  
9e11 32 7c ee			ld (debug_mark+2),a  
9e14 18 03			jr .pastdmark  
9e16 ..			.dmark: db "DUP"  
9e19 f1			.pastdmark: pop af  
9e1a			endm  
# End of macro DMARK
9e1a						CALLMONITOR 
9e1a cd 6c 93			call break_point_state  
9e1d				endm  
# End of macro CALLMONITOR
9e1d					endif 
9e1d			 
9e1d					FORTH_DSP 
9e1d cd b6 9a			call macro_forth_dsp 
9e20				endm 
# End of macro FORTH_DSP
9e20			 
9e20 7e					ld a, (HL) 
9e21 fe 01				cp DS_TYPE_STR 
9e23 20 25				jr nz, .dupinum 
9e25			 
9e25					; push another string 
9e25			 
9e25					FORTH_DSP_VALUEHL     		 
9e25 cd f0 9a			call macro_dsp_valuehl 
9e28				endm 
# End of macro FORTH_DSP_VALUEHL
9e28			 
9e28				if DEBUG_FORTH_WORDS 
9e28					DMARK "DUs" 
9e28 f5				push af  
9e29 3a 3d 9e			ld a, (.dmark)  
9e2c 32 7a ee			ld (debug_mark),a  
9e2f 3a 3e 9e			ld a, (.dmark+1)  
9e32 32 7b ee			ld (debug_mark+1),a  
9e35 3a 3f 9e			ld a, (.dmark+2)  
9e38 32 7c ee			ld (debug_mark+2),a  
9e3b 18 03			jr .pastdmark  
9e3d ..			.dmark: db "DUs"  
9e40 f1			.pastdmark: pop af  
9e41			endm  
# End of macro DMARK
9e41					CALLMONITOR 
9e41 cd 6c 93			call break_point_state  
9e44				endm  
# End of macro CALLMONITOR
9e44				endif 
9e44 cd 67 99				call forth_push_str 
9e47			 
9e47					NEXTW 
9e47 c3 62 9c			jp macro_next 
9e4a				endm 
# End of macro NEXTW
9e4a			 
9e4a			 
9e4a			.dupinum: 
9e4a					 
9e4a			 
9e4a			 
9e4a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9e4a cd f0 9a			call macro_dsp_valuehl 
9e4d				endm 
# End of macro FORTH_DSP_VALUEHL
9e4d			 
9e4d				; TODO add floating point number detection 
9e4d			 
9e4d				if DEBUG_FORTH_WORDS 
9e4d					DMARK "DUi" 
9e4d f5				push af  
9e4e 3a 62 9e			ld a, (.dmark)  
9e51 32 7a ee			ld (debug_mark),a  
9e54 3a 63 9e			ld a, (.dmark+1)  
9e57 32 7b ee			ld (debug_mark+1),a  
9e5a 3a 64 9e			ld a, (.dmark+2)  
9e5d 32 7c ee			ld (debug_mark+2),a  
9e60 18 03			jr .pastdmark  
9e62 ..			.dmark: db "DUi"  
9e65 f1			.pastdmark: pop af  
9e66			endm  
# End of macro DMARK
9e66					CALLMONITOR 
9e66 cd 6c 93			call break_point_state  
9e69				endm  
# End of macro CALLMONITOR
9e69				endif 
9e69			 
9e69 cd f9 98				call forth_push_numhl 
9e6c					NEXTW 
9e6c c3 62 9c			jp macro_next 
9e6f				endm 
# End of macro NEXTW
9e6f			.ZDUP: 
9e6f				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
9e6f 99				db WORD_SYS_CORE+OPCODE_ZDUP             
9e70 a7 9e			dw .SWAP            
9e72 05				db 4 + 1 
9e73 .. 00			db "?DUP",0              
9e78				endm 
# End of macro CWHEAD
9e78			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
9e78			 
9e78					if DEBUG_FORTH_WORDS_KEY 
9e78						DMARK "qDU" 
9e78 f5				push af  
9e79 3a 8d 9e			ld a, (.dmark)  
9e7c 32 7a ee			ld (debug_mark),a  
9e7f 3a 8e 9e			ld a, (.dmark+1)  
9e82 32 7b ee			ld (debug_mark+1),a  
9e85 3a 8f 9e			ld a, (.dmark+2)  
9e88 32 7c ee			ld (debug_mark+2),a  
9e8b 18 03			jr .pastdmark  
9e8d ..			.dmark: db "qDU"  
9e90 f1			.pastdmark: pop af  
9e91			endm  
# End of macro DMARK
9e91						CALLMONITOR 
9e91 cd 6c 93			call break_point_state  
9e94				endm  
# End of macro CALLMONITOR
9e94					endif 
9e94					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
9e94 cd f0 9a			call macro_dsp_valuehl 
9e97				endm 
# End of macro FORTH_DSP_VALUEHL
9e97			 
9e97 e5					push hl 
9e98			 
9e98					; is it a zero? 
9e98			 
9e98 3e 00				ld a, 0 
9e9a 84					add h 
9e9b 85					add l 
9e9c			 
9e9c e1					pop hl 
9e9d			 
9e9d fe 00				cp 0 
9e9f 28 03				jr z, .dup2orig 
9ea1			 
9ea1			 
9ea1 cd f9 98				call forth_push_numhl 
9ea4			 
9ea4			 
9ea4				; TODO add floating point number detection 
9ea4			 
9ea4			.dup2orig: 
9ea4			 
9ea4					NEXTW 
9ea4 c3 62 9c			jp macro_next 
9ea7				endm 
# End of macro NEXTW
9ea7			.SWAP: 
9ea7				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
9ea7 18				db WORD_SYS_CORE+OPCODE_SWAP             
9ea8 e6 9e			dw .COLN            
9eaa 05				db 4 + 1 
9eab .. 00			db "SWAP",0              
9eb0				endm 
# End of macro CWHEAD
9eb0			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
9eb0					if DEBUG_FORTH_WORDS_KEY 
9eb0						DMARK "SWP" 
9eb0 f5				push af  
9eb1 3a c5 9e			ld a, (.dmark)  
9eb4 32 7a ee			ld (debug_mark),a  
9eb7 3a c6 9e			ld a, (.dmark+1)  
9eba 32 7b ee			ld (debug_mark+1),a  
9ebd 3a c7 9e			ld a, (.dmark+2)  
9ec0 32 7c ee			ld (debug_mark+2),a  
9ec3 18 03			jr .pastdmark  
9ec5 ..			.dmark: db "SWP"  
9ec8 f1			.pastdmark: pop af  
9ec9			endm  
# End of macro DMARK
9ec9						CALLMONITOR 
9ec9 cd 6c 93			call break_point_state  
9ecc				endm  
# End of macro CALLMONITOR
9ecc					endif 
9ecc			 
9ecc					FORTH_DSP_VALUEHL 
9ecc cd f0 9a			call macro_dsp_valuehl 
9ecf				endm 
# End of macro FORTH_DSP_VALUEHL
9ecf e5					push hl     ; w2 
9ed0			 
9ed0					FORTH_DSP_POP 
9ed0 cd a8 9b			call macro_forth_dsp_pop 
9ed3				endm 
# End of macro FORTH_DSP_POP
9ed3			 
9ed3					FORTH_DSP_VALUEHL 
9ed3 cd f0 9a			call macro_dsp_valuehl 
9ed6				endm 
# End of macro FORTH_DSP_VALUEHL
9ed6			 
9ed6					FORTH_DSP_POP 
9ed6 cd a8 9b			call macro_forth_dsp_pop 
9ed9				endm 
# End of macro FORTH_DSP_POP
9ed9			 
9ed9 d1					pop de     ; w2	, hl = w1 
9eda			 
9eda eb					ex de, hl 
9edb d5					push de 
9edc			 
9edc cd f9 98				call forth_push_numhl 
9edf			 
9edf e1					pop hl 
9ee0			 
9ee0 cd f9 98				call forth_push_numhl 
9ee3					 
9ee3			 
9ee3					NEXTW 
9ee3 c3 62 9c			jp macro_next 
9ee6				endm 
# End of macro NEXTW
9ee6			.COLN: 
9ee6				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
9ee6 19				db WORD_SYS_CORE+OPCODE_COLN             
9ee7 72 a0			dw .SCOLN            
9ee9 02				db 1 + 1 
9eea .. 00			db ":",0              
9eec				endm 
# End of macro CWHEAD
9eec			; | : ( -- )         Create new word | DONE 
9eec			 
9eec					if DEBUG_FORTH_WORDS_KEY 
9eec						DMARK "CLN" 
9eec f5				push af  
9eed 3a 01 9f			ld a, (.dmark)  
9ef0 32 7a ee			ld (debug_mark),a  
9ef3 3a 02 9f			ld a, (.dmark+1)  
9ef6 32 7b ee			ld (debug_mark+1),a  
9ef9 3a 03 9f			ld a, (.dmark+2)  
9efc 32 7c ee			ld (debug_mark+2),a  
9eff 18 03			jr .pastdmark  
9f01 ..			.dmark: db "CLN"  
9f04 f1			.pastdmark: pop af  
9f05			endm  
# End of macro DMARK
9f05						CALLMONITOR 
9f05 cd 6c 93			call break_point_state  
9f08				endm  
# End of macro CALLMONITOR
9f08					endif 
9f08				STACKFRAME OFF $8efe $989f 
9f08				if DEBUG_STACK_IMB 
9f08					if OFF 
9f08						exx 
9f08						ld de, $8efe 
9f08						ld a, d 
9f08						ld hl, curframe 
9f08						call hexout 
9f08						ld a, e 
9f08						ld hl, curframe+2 
9f08						call hexout 
9f08						ld hl, $8efe 
9f08						push hl 
9f08						ld hl, $989f 
9f08						push hl 
9f08						exx 
9f08					endif 
9f08				endif 
9f08			endm 
# End of macro STACKFRAME
9f08				; get parser buffer length  of new word 
9f08			 
9f08				 
9f08			 
9f08					; move tok past this to start of name defintition 
9f08					; TODO get word to define 
9f08					; TODO Move past word token 
9f08					; TODO get length of string up to the ';' 
9f08			 
9f08 2a 61 e6			ld hl, (os_tok_ptr) 
9f0b 23				inc hl 
9f0c 23				inc hl 
9f0d			 
9f0d 3e 3b			ld a, ';' 
9f0f cd 27 8f			call strlent 
9f12			 
9f12 7d				ld a,l 
9f13 32 5c e3			ld (os_new_parse_len), a 
9f16			 
9f16			 
9f16			if DEBUG_FORTH_UWORD 
9f16 ed 5b 61 e6		ld de, (os_tok_ptr) 
9f1a						DMARK ":01" 
9f1a f5				push af  
9f1b 3a 2f 9f			ld a, (.dmark)  
9f1e 32 7a ee			ld (debug_mark),a  
9f21 3a 30 9f			ld a, (.dmark+1)  
9f24 32 7b ee			ld (debug_mark+1),a  
9f27 3a 31 9f			ld a, (.dmark+2)  
9f2a 32 7c ee			ld (debug_mark+2),a  
9f2d 18 03			jr .pastdmark  
9f2f ..			.dmark: db ":01"  
9f32 f1			.pastdmark: pop af  
9f33			endm  
# End of macro DMARK
9f33				CALLMONITOR 
9f33 cd 6c 93			call break_point_state  
9f36				endm  
# End of macro CALLMONITOR
9f36			endif 
9f36			 
9f36			; 
9f36			;  new word memory layout: 
9f36			;  
9f36			;    : adg 6666 ;  
9f36			; 
9f36			;    db   1     ; user defined word  
9f36 23				inc hl    
9f37			;    dw   sysdict 
9f37 23				inc hl 
9f38 23				inc hl 
9f39			;    db <word len>+1 (for null) 
9f39 23				inc hl 
9f3a			;    db .... <word> 
9f3a			; 
9f3a			 
9f3a 23				inc hl    ; some extras for the word preamble before the above 
9f3b 23				inc hl 
9f3c 23				inc hl 
9f3d 23				inc hl 
9f3e 23				inc hl 
9f3f 23				inc hl 
9f40 23				inc hl  
9f41 23				inc hl 
9f42 23				inc hl 
9f43 23				inc hl 
9f44 23				inc hl 
9f45 23				inc hl 
9f46 23				inc hl 
9f47 23				inc hl     ; TODO how many do we really need?     maybe only 6 
9f48			;       exec word buffer 
9f48			;	<ptr word>   
9f48 23				inc hl 
9f49 23				inc hl 
9f4a			;       <word list><null term> 7F final term 
9f4a			 
9f4a			 
9f4a			if DEBUG_FORTH_UWORD 
9f4a						DMARK ":02" 
9f4a f5				push af  
9f4b 3a 5f 9f			ld a, (.dmark)  
9f4e 32 7a ee			ld (debug_mark),a  
9f51 3a 60 9f			ld a, (.dmark+1)  
9f54 32 7b ee			ld (debug_mark+1),a  
9f57 3a 61 9f			ld a, (.dmark+2)  
9f5a 32 7c ee			ld (debug_mark+2),a  
9f5d 18 03			jr .pastdmark  
9f5f ..			.dmark: db ":02"  
9f62 f1			.pastdmark: pop af  
9f63			endm  
# End of macro DMARK
9f63				CALLMONITOR 
9f63 cd 6c 93			call break_point_state  
9f66				endm  
# End of macro CALLMONITOR
9f66			endif 
9f66			 
9f66				 
9f66					; malloc the size 
9f66			 
9f66 cd 85 8f				call malloc 
9f69 22 5e e3				ld (os_new_malloc), hl     ; save malloc start 
9f6c			 
9f6c			;    db   1     ; user defined word  
9f6c 3e 01				ld a, WORD_SYS_UWORD  
9f6e 77					ld (hl), a 
9f6f				 
9f6f 23				inc hl    
9f70			;    dw   sysdict 
9f70 11 ba 9d			ld de, sysdict       ; continue on with the scan to the system dict 
9f73 73				ld (hl), e 
9f74 23				inc hl 
9f75 72				ld (hl), d 
9f76 23				inc hl 
9f77			 
9f77			 
9f77			;    Setup dict word 
9f77			 
9f77 23				inc hl 
9f78 22 58 e3			ld (os_new_work_ptr), hl     ; save start of dict word  
9f7b			 
9f7b				; 1. get length of dict word 
9f7b			 
9f7b			 
9f7b 2a 61 e6			ld hl, (os_tok_ptr) 
9f7e 23				inc hl 
9f7f 23				inc hl    ; position to start of dict word 
9f80 3e 00			ld a, 0 
9f82 cd 27 8f			call strlent 
9f85			 
9f85			 
9f85 23				inc hl    ; to include null??? 
9f86			 
9f86				; write length of dict word 
9f86			 
9f86 ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9f8a 1b				dec de 
9f8b eb				ex de, hl 
9f8c 73				ld (hl), e 
9f8d eb				ex de, hl 
9f8e			 
9f8e				 
9f8e			 
9f8e				; copy  
9f8e 4d				ld c, l 
9f8f 06 00			ld b, 0 
9f91 ed 5b 58 e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
9f95 2a 61 e6			ld hl, (os_tok_ptr) 
9f98 23				inc hl 
9f99 23				inc hl    ; position to start of dict word 
9f9a				 
9f9a			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
9f9a				 
9f9a				; TODO need to convert word to upper case 
9f9a			 
9f9a			ucasetok:	 
9f9a 7e				ld a,(hl) 
9f9b cd 13 8f			call toUpper 
9f9e 77				ld (hl),a 
9f9f ed a0			ldi 
9fa1 f2 9a 9f		 	jp p, ucasetok 
9fa4			 
9fa4			 
9fa4			 
9fa4				; de now points to start of where the word body code should be placed 
9fa4 ed 53 58 e3		ld (os_new_work_ptr), de 
9fa8				; hl now points to the words to throw at forthexec which needs to be copied 
9fa8 22 56 e3			ld (os_new_src_ptr), hl 
9fab			 
9fab				; TODO add 'call to forthexec' 
9fab			 
9fab			if DEBUG_FORTH_UWORD 
9fab c5				push bc 
9fac ed 4b 5e e3		ld bc, (os_new_malloc) 
9fb0						DMARK ":0x" 
9fb0 f5				push af  
9fb1 3a c5 9f			ld a, (.dmark)  
9fb4 32 7a ee			ld (debug_mark),a  
9fb7 3a c6 9f			ld a, (.dmark+1)  
9fba 32 7b ee			ld (debug_mark+1),a  
9fbd 3a c7 9f			ld a, (.dmark+2)  
9fc0 32 7c ee			ld (debug_mark+2),a  
9fc3 18 03			jr .pastdmark  
9fc5 ..			.dmark: db ":0x"  
9fc8 f1			.pastdmark: pop af  
9fc9			endm  
# End of macro DMARK
9fc9				CALLMONITOR 
9fc9 cd 6c 93			call break_point_state  
9fcc				endm  
# End of macro CALLMONITOR
9fcc c1				pop bc 
9fcd			endif 
9fcd			 
9fcd			 
9fcd				; create word preamble which should be: 
9fcd			 
9fcd			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
9fcd			 
9fcd				;    ld hl, <word code> 
9fcd				;    jp user_exec 
9fcd			        ;    <word code bytes> 
9fcd			 
9fcd			 
9fcd			;	inc de     ; TODO ??? or are we already past the word's null 
9fcd eb				ex de, hl 
9fce			 
9fce 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
9fd0			 
9fd0 23				inc hl 
9fd1 22 52 e3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
9fd4 23				inc hl 
9fd5			 
9fd5 23				inc hl 
9fd6 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
9fd8			 
9fd8 01 c2 c3			ld bc, user_exec 
9fdb 23				inc hl 
9fdc 71				ld (hl), c     ; poke address of user_exec 
9fdd 23				inc hl 
9fde 70				ld (hl), b     
9fdf			 ; 
9fdf			;	inc hl 
9fdf			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9fdf			; 
9fdf			; 
9fdf			;	ld bc, macro_forth_rsp_next 
9fdf			;	inc hl 
9fdf			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
9fdf			;	inc hl 
9fdf			;	ld (hl), b     
9fdf			 ; 
9fdf			;	inc hl 
9fdf			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
9fdf			; 
9fdf			; 
9fdf			;	inc hl 
9fdf			;	ld bc, forthexec 
9fdf			;	ld (hl), c     ; poke address of forthexec 
9fdf			;	inc hl 
9fdf			;	ld (hl), b      
9fdf			; 
9fdf			;	inc hl 
9fdf			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
9fdf			; 
9fdf			;	ld bc, user_dict_next 
9fdf			;	inc hl 
9fdf			;	ld (hl), c     ; poke address of forthexec 
9fdf			;	inc hl 
9fdf			;	ld (hl), b      
9fdf			 
9fdf				; hl is now where we need to copy the word byte data to save this 
9fdf			 
9fdf 23				inc hl 
9fe0 22 54 e3			ld (os_new_exec), hl 
9fe3				 
9fe3				; copy definition 
9fe3			 
9fe3 eb				ex de, hl 
9fe4			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
9fe4			;	inc de    ; skip the PC for this parse 
9fe4 3a 5c e3			ld a, (os_new_parse_len) 
9fe7 4f				ld c, a 
9fe8 06 00			ld b, 0 
9fea ed b0			ldir		 ; copy defintion 
9fec			 
9fec			 
9fec				; poke the address of where the new word bytes live for forthexec 
9fec			 
9fec 2a 52 e3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
9fef			 
9fef ed 5b 54 e3		ld de, (os_new_exec)      
9ff3				 
9ff3 73				ld (hl), e 
9ff4 23				inc hl 
9ff5 72				ld (hl), d 
9ff6			 
9ff6					; TODO copy last user dict word next link to this word 
9ff6					; TODO update last user dict word to point to this word 
9ff6			; 
9ff6			; hl f923 de 812a ; bc 811a 
9ff6			 
9ff6			if DEBUG_FORTH_UWORD 
9ff6 c5				push bc 
9ff7 ed 4b 5e e3		ld bc, (os_new_malloc) 
9ffb						DMARK ":0A" 
9ffb f5				push af  
9ffc 3a 10 a0			ld a, (.dmark)  
9fff 32 7a ee			ld (debug_mark),a  
a002 3a 11 a0			ld a, (.dmark+1)  
a005 32 7b ee			ld (debug_mark+1),a  
a008 3a 12 a0			ld a, (.dmark+2)  
a00b 32 7c ee			ld (debug_mark+2),a  
a00e 18 03			jr .pastdmark  
a010 ..			.dmark: db ":0A"  
a013 f1			.pastdmark: pop af  
a014			endm  
# End of macro DMARK
a014				CALLMONITOR 
a014 cd 6c 93			call break_point_state  
a017				endm  
# End of macro CALLMONITOR
a017 c1				pop bc 
a018			endif 
a018			if DEBUG_FORTH_UWORD 
a018 c5				push bc 
a019 ed 4b 5e e3		ld bc, (os_new_malloc) 
a01d 03				inc bc 
a01e 03				inc bc 
a01f 03				inc bc 
a020 03				inc bc 
a021 03				inc bc 
a022 03				inc bc 
a023 03				inc bc 
a024 03				inc bc 
a025			 
a025						DMARK ":0B" 
a025 f5				push af  
a026 3a 3a a0			ld a, (.dmark)  
a029 32 7a ee			ld (debug_mark),a  
a02c 3a 3b a0			ld a, (.dmark+1)  
a02f 32 7b ee			ld (debug_mark+1),a  
a032 3a 3c a0			ld a, (.dmark+2)  
a035 32 7c ee			ld (debug_mark+2),a  
a038 18 03			jr .pastdmark  
a03a ..			.dmark: db ":0B"  
a03d f1			.pastdmark: pop af  
a03e			endm  
# End of macro DMARK
a03e				CALLMONITOR 
a03e cd 6c 93			call break_point_state  
a041				endm  
# End of macro CALLMONITOR
a041 c1				pop bc 
a042			endif 
a042			 
a042			; update word dict linked list for new word 
a042			 
a042			 
a042 2a 5d e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
a045 23			inc hl     ; move to next work linked list ptr 
a046			 
a046 ed 5b 5e e3	ld de, (os_new_malloc)		 ; new next word 
a04a 73			ld (hl), e 
a04b 23			inc hl 
a04c 72			ld (hl), d 
a04d			 
a04d			if DEBUG_FORTH_UWORD 
a04d ed 4b 5d e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
a051			endif 
a051			 
a051 ed 53 5d e6	ld (os_last_new_uword), de      ; update last new uword ptr 
a055			 
a055			 
a055			if DEBUG_FORTH_UWORD 
a055						DMARK ":0+" 
a055 f5				push af  
a056 3a 6a a0			ld a, (.dmark)  
a059 32 7a ee			ld (debug_mark),a  
a05c 3a 6b a0			ld a, (.dmark+1)  
a05f 32 7b ee			ld (debug_mark+1),a  
a062 3a 6c a0			ld a, (.dmark+2)  
a065 32 7c ee			ld (debug_mark+2),a  
a068 18 03			jr .pastdmark  
a06a ..			.dmark: db ":0+"  
a06d f1			.pastdmark: pop af  
a06e			endm  
# End of macro DMARK
a06e				CALLMONITOR 
a06e cd 6c 93			call break_point_state  
a071				endm  
# End of macro CALLMONITOR
a071			endif 
a071			 
a071				STACKFRAMECHK OFF $8efe $989f 
a071				if DEBUG_STACK_IMB 
a071					if OFF 
a071						exx 
a071						ld hl, $989f 
a071						pop de   ; $989f 
a071						call cmp16 
a071						jr nz, .spnosame 
a071						ld hl, $8efe 
a071						pop de   ; $8efe 
a071						call cmp16 
a071						jr z, .spfrsame 
a071						.spnosame: call showsperror 
a071						.spfrsame: nop 
a071						exx 
a071					endif 
a071				endif 
a071			endm 
# End of macro STACKFRAMECHK
a071			 
a071 c9			ret    ; dont process any remaining parser tokens as they form new word 
a072			 
a072			 
a072			 
a072			 
a072			;		NEXT 
a072			.SCOLN: 
a072			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
a072 06				db OPCODE_SCOLN 
a073 be a0			dw .DROP 
a075 02				db 2 
a076 .. 00			db ";",0           
a078			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
a078					if DEBUG_FORTH_WORDS_KEY 
a078						DMARK "SCN" 
a078 f5				push af  
a079 3a 8d a0			ld a, (.dmark)  
a07c 32 7a ee			ld (debug_mark),a  
a07f 3a 8e a0			ld a, (.dmark+1)  
a082 32 7b ee			ld (debug_mark+1),a  
a085 3a 8f a0			ld a, (.dmark+2)  
a088 32 7c ee			ld (debug_mark+2),a  
a08b 18 03			jr .pastdmark  
a08d ..			.dmark: db "SCN"  
a090 f1			.pastdmark: pop af  
a091			endm  
# End of macro DMARK
a091						CALLMONITOR 
a091 cd 6c 93			call break_point_state  
a094				endm  
# End of macro CALLMONITOR
a094					endif 
a094					FORTH_RSP_TOS 
a094 cd b7 98			call macro_forth_rsp_tos 
a097				endm 
# End of macro FORTH_RSP_TOS
a097 e5					push hl 
a098					FORTH_RSP_POP 
a098 cd c1 98			call macro_forth_rsp_pop 
a09b				endm 
# End of macro FORTH_RSP_POP
a09b e1					pop hl 
a09c			;		ex de,hl 
a09c 22 61 e6				ld (os_tok_ptr),hl 
a09f			 
a09f			if DEBUG_FORTH_UWORD 
a09f						DMARK "SCL" 
a09f f5				push af  
a0a0 3a b4 a0			ld a, (.dmark)  
a0a3 32 7a ee			ld (debug_mark),a  
a0a6 3a b5 a0			ld a, (.dmark+1)  
a0a9 32 7b ee			ld (debug_mark+1),a  
a0ac 3a b6 a0			ld a, (.dmark+2)  
a0af 32 7c ee			ld (debug_mark+2),a  
a0b2 18 03			jr .pastdmark  
a0b4 ..			.dmark: db "SCL"  
a0b7 f1			.pastdmark: pop af  
a0b8			endm  
# End of macro DMARK
a0b8				CALLMONITOR 
a0b8 cd 6c 93			call break_point_state  
a0bb				endm  
# End of macro CALLMONITOR
a0bb			endif 
a0bb					NEXTW 
a0bb c3 62 9c			jp macro_next 
a0be				endm 
# End of macro NEXTW
a0be			 
a0be			.DROP: 
a0be				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
a0be 1b				db WORD_SYS_CORE+OPCODE_DROP             
a0bf e9 a0			dw .DUP2            
a0c1 05				db 4 + 1 
a0c2 .. 00			db "DROP",0              
a0c7				endm 
# End of macro CWHEAD
a0c7			; | DROP ( w -- )   drop the TOS item   | DONE 
a0c7					if DEBUG_FORTH_WORDS_KEY 
a0c7						DMARK "DRP" 
a0c7 f5				push af  
a0c8 3a dc a0			ld a, (.dmark)  
a0cb 32 7a ee			ld (debug_mark),a  
a0ce 3a dd a0			ld a, (.dmark+1)  
a0d1 32 7b ee			ld (debug_mark+1),a  
a0d4 3a de a0			ld a, (.dmark+2)  
a0d7 32 7c ee			ld (debug_mark+2),a  
a0da 18 03			jr .pastdmark  
a0dc ..			.dmark: db "DRP"  
a0df f1			.pastdmark: pop af  
a0e0			endm  
# End of macro DMARK
a0e0						CALLMONITOR 
a0e0 cd 6c 93			call break_point_state  
a0e3				endm  
# End of macro CALLMONITOR
a0e3					endif 
a0e3					FORTH_DSP_POP 
a0e3 cd a8 9b			call macro_forth_dsp_pop 
a0e6				endm 
# End of macro FORTH_DSP_POP
a0e6					NEXTW 
a0e6 c3 62 9c			jp macro_next 
a0e9				endm 
# End of macro NEXTW
a0e9			.DUP2: 
a0e9				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
a0e9 1c				db WORD_SYS_CORE+OPCODE_DUP2             
a0ea 2e a1			dw .DROP2            
a0ec 05				db 4 + 1 
a0ed .. 00			db "2DUP",0              
a0f2				endm 
# End of macro CWHEAD
a0f2			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
a0f2					if DEBUG_FORTH_WORDS_KEY 
a0f2						DMARK "2DU" 
a0f2 f5				push af  
a0f3 3a 07 a1			ld a, (.dmark)  
a0f6 32 7a ee			ld (debug_mark),a  
a0f9 3a 08 a1			ld a, (.dmark+1)  
a0fc 32 7b ee			ld (debug_mark+1),a  
a0ff 3a 09 a1			ld a, (.dmark+2)  
a102 32 7c ee			ld (debug_mark+2),a  
a105 18 03			jr .pastdmark  
a107 ..			.dmark: db "2DU"  
a10a f1			.pastdmark: pop af  
a10b			endm  
# End of macro DMARK
a10b						CALLMONITOR 
a10b cd 6c 93			call break_point_state  
a10e				endm  
# End of macro CALLMONITOR
a10e					endif 
a10e					FORTH_DSP_VALUEHL 
a10e cd f0 9a			call macro_dsp_valuehl 
a111				endm 
# End of macro FORTH_DSP_VALUEHL
a111 e5					push hl      ; 2 
a112			 
a112					FORTH_DSP_POP 
a112 cd a8 9b			call macro_forth_dsp_pop 
a115				endm 
# End of macro FORTH_DSP_POP
a115					 
a115					FORTH_DSP_VALUEHL 
a115 cd f0 9a			call macro_dsp_valuehl 
a118				endm 
# End of macro FORTH_DSP_VALUEHL
a118			;		push hl      ; 1 
a118			 
a118					FORTH_DSP_POP 
a118 cd a8 9b			call macro_forth_dsp_pop 
a11b				endm 
# End of macro FORTH_DSP_POP
a11b			 
a11b			;		pop hl       ; 1 
a11b d1					pop de       ; 2 
a11c			 
a11c cd f9 98				call forth_push_numhl 
a11f eb					ex de, hl 
a120 cd f9 98				call forth_push_numhl 
a123			 
a123					 
a123 eb					ex de, hl 
a124			 
a124 cd f9 98				call forth_push_numhl 
a127 eb					ex de, hl 
a128 cd f9 98				call forth_push_numhl 
a12b			 
a12b			 
a12b					NEXTW 
a12b c3 62 9c			jp macro_next 
a12e				endm 
# End of macro NEXTW
a12e			.DROP2: 
a12e				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
a12e 1d				db WORD_SYS_CORE+OPCODE_DROP2             
a12f 5d a1			dw .SWAP2            
a131 06				db 5 + 1 
a132 .. 00			db "2DROP",0              
a138				endm 
# End of macro CWHEAD
a138			; | 2DROP ( w w -- )    Double drop | DONE 
a138					if DEBUG_FORTH_WORDS_KEY 
a138						DMARK "2DR" 
a138 f5				push af  
a139 3a 4d a1			ld a, (.dmark)  
a13c 32 7a ee			ld (debug_mark),a  
a13f 3a 4e a1			ld a, (.dmark+1)  
a142 32 7b ee			ld (debug_mark+1),a  
a145 3a 4f a1			ld a, (.dmark+2)  
a148 32 7c ee			ld (debug_mark+2),a  
a14b 18 03			jr .pastdmark  
a14d ..			.dmark: db "2DR"  
a150 f1			.pastdmark: pop af  
a151			endm  
# End of macro DMARK
a151						CALLMONITOR 
a151 cd 6c 93			call break_point_state  
a154				endm  
# End of macro CALLMONITOR
a154					endif 
a154					FORTH_DSP_POP 
a154 cd a8 9b			call macro_forth_dsp_pop 
a157				endm 
# End of macro FORTH_DSP_POP
a157					FORTH_DSP_POP 
a157 cd a8 9b			call macro_forth_dsp_pop 
a15a				endm 
# End of macro FORTH_DSP_POP
a15a					NEXTW 
a15a c3 62 9c			jp macro_next 
a15d				endm 
# End of macro NEXTW
a15d			.SWAP2: 
a15d				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
a15d 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
a15e 86 a1			dw .AT            
a160 06				db 5 + 1 
a161 .. 00			db "2SWAP",0              
a167				endm 
# End of macro CWHEAD
a167			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
a167					if DEBUG_FORTH_WORDS_KEY 
a167						DMARK "2SW" 
a167 f5				push af  
a168 3a 7c a1			ld a, (.dmark)  
a16b 32 7a ee			ld (debug_mark),a  
a16e 3a 7d a1			ld a, (.dmark+1)  
a171 32 7b ee			ld (debug_mark+1),a  
a174 3a 7e a1			ld a, (.dmark+2)  
a177 32 7c ee			ld (debug_mark+2),a  
a17a 18 03			jr .pastdmark  
a17c ..			.dmark: db "2SW"  
a17f f1			.pastdmark: pop af  
a180			endm  
# End of macro DMARK
a180						CALLMONITOR 
a180 cd 6c 93			call break_point_state  
a183				endm  
# End of macro CALLMONITOR
a183					endif 
a183					NEXTW 
a183 c3 62 9c			jp macro_next 
a186				endm 
# End of macro NEXTW
a186			.AT: 
a186				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
a186 1f				db WORD_SYS_CORE+OPCODE_AT             
a187 b8 a1			dw .CAT            
a189 02				db 1 + 1 
a18a .. 00			db "@",0              
a18c				endm 
# End of macro CWHEAD
a18c			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
a18c			 
a18c					if DEBUG_FORTH_WORDS_KEY 
a18c						DMARK "AT." 
a18c f5				push af  
a18d 3a a1 a1			ld a, (.dmark)  
a190 32 7a ee			ld (debug_mark),a  
a193 3a a2 a1			ld a, (.dmark+1)  
a196 32 7b ee			ld (debug_mark+1),a  
a199 3a a3 a1			ld a, (.dmark+2)  
a19c 32 7c ee			ld (debug_mark+2),a  
a19f 18 03			jr .pastdmark  
a1a1 ..			.dmark: db "AT."  
a1a4 f1			.pastdmark: pop af  
a1a5			endm  
# End of macro DMARK
a1a5						CALLMONITOR 
a1a5 cd 6c 93			call break_point_state  
a1a8				endm  
# End of macro CALLMONITOR
a1a8					endif 
a1a8			.getbyteat:	 
a1a8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a1a8 cd f0 9a			call macro_dsp_valuehl 
a1ab				endm 
# End of macro FORTH_DSP_VALUEHL
a1ab					 
a1ab			;		push hl 
a1ab				 
a1ab					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a1ab cd a8 9b			call macro_forth_dsp_pop 
a1ae				endm 
# End of macro FORTH_DSP_POP
a1ae			 
a1ae			;		pop hl 
a1ae			 
a1ae 7e					ld a, (hl) 
a1af			 
a1af 6f					ld l, a 
a1b0 26 00				ld h, 0 
a1b2 cd f9 98				call forth_push_numhl 
a1b5			 
a1b5					NEXTW 
a1b5 c3 62 9c			jp macro_next 
a1b8				endm 
# End of macro NEXTW
a1b8			.CAT: 
a1b8				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
a1b8 20				db WORD_SYS_CORE+OPCODE_CAT             
a1b9 e1 a1			dw .BANG            
a1bb 03				db 2 + 1 
a1bc .. 00			db "C@",0              
a1bf				endm 
# End of macro CWHEAD
a1bf			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
a1bf					if DEBUG_FORTH_WORDS_KEY 
a1bf						DMARK "CAA" 
a1bf f5				push af  
a1c0 3a d4 a1			ld a, (.dmark)  
a1c3 32 7a ee			ld (debug_mark),a  
a1c6 3a d5 a1			ld a, (.dmark+1)  
a1c9 32 7b ee			ld (debug_mark+1),a  
a1cc 3a d6 a1			ld a, (.dmark+2)  
a1cf 32 7c ee			ld (debug_mark+2),a  
a1d2 18 03			jr .pastdmark  
a1d4 ..			.dmark: db "CAA"  
a1d7 f1			.pastdmark: pop af  
a1d8			endm  
# End of macro DMARK
a1d8						CALLMONITOR 
a1d8 cd 6c 93			call break_point_state  
a1db				endm  
# End of macro CALLMONITOR
a1db					endif 
a1db c3 a8 a1				jp .getbyteat 
a1de					NEXTW 
a1de c3 62 9c			jp macro_next 
a1e1				endm 
# End of macro NEXTW
a1e1			.BANG: 
a1e1				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
a1e1 21				db WORD_SYS_CORE+OPCODE_BANG             
a1e2 17 a2			dw .CBANG            
a1e4 02				db 1 + 1 
a1e5 .. 00			db "!",0              
a1e7				endm 
# End of macro CWHEAD
a1e7			; | ! ( x w -- ) Store x at address w      | DONE 
a1e7					if DEBUG_FORTH_WORDS_KEY 
a1e7						DMARK "BNG" 
a1e7 f5				push af  
a1e8 3a fc a1			ld a, (.dmark)  
a1eb 32 7a ee			ld (debug_mark),a  
a1ee 3a fd a1			ld a, (.dmark+1)  
a1f1 32 7b ee			ld (debug_mark+1),a  
a1f4 3a fe a1			ld a, (.dmark+2)  
a1f7 32 7c ee			ld (debug_mark+2),a  
a1fa 18 03			jr .pastdmark  
a1fc ..			.dmark: db "BNG"  
a1ff f1			.pastdmark: pop af  
a200			endm  
# End of macro DMARK
a200						CALLMONITOR 
a200 cd 6c 93			call break_point_state  
a203				endm  
# End of macro CALLMONITOR
a203					endif 
a203			 
a203			.storebyteat:		 
a203					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a203 cd f0 9a			call macro_dsp_valuehl 
a206				endm 
# End of macro FORTH_DSP_VALUEHL
a206					 
a206 e5					push hl 
a207				 
a207					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a207 cd a8 9b			call macro_forth_dsp_pop 
a20a				endm 
# End of macro FORTH_DSP_POP
a20a			 
a20a					; get byte to poke 
a20a			 
a20a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a20a cd f0 9a			call macro_dsp_valuehl 
a20d				endm 
# End of macro FORTH_DSP_VALUEHL
a20d e5					push hl 
a20e			 
a20e			 
a20e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a20e cd a8 9b			call macro_forth_dsp_pop 
a211				endm 
# End of macro FORTH_DSP_POP
a211			 
a211			 
a211 d1					pop de 
a212 e1					pop hl 
a213			 
a213 73					ld (hl),e 
a214			 
a214			 
a214					NEXTW 
a214 c3 62 9c			jp macro_next 
a217				endm 
# End of macro NEXTW
a217			.CBANG: 
a217				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
a217 22				db WORD_SYS_CORE+OPCODE_CBANG             
a218 40 a2			dw .SCALL            
a21a 03				db 2 + 1 
a21b .. 00			db "C!",0              
a21e				endm 
# End of macro CWHEAD
a21e			; | C!  ( x w -- ) Store x at address w  | DONE 
a21e					if DEBUG_FORTH_WORDS_KEY 
a21e						DMARK "CBA" 
a21e f5				push af  
a21f 3a 33 a2			ld a, (.dmark)  
a222 32 7a ee			ld (debug_mark),a  
a225 3a 34 a2			ld a, (.dmark+1)  
a228 32 7b ee			ld (debug_mark+1),a  
a22b 3a 35 a2			ld a, (.dmark+2)  
a22e 32 7c ee			ld (debug_mark+2),a  
a231 18 03			jr .pastdmark  
a233 ..			.dmark: db "CBA"  
a236 f1			.pastdmark: pop af  
a237			endm  
# End of macro DMARK
a237						CALLMONITOR 
a237 cd 6c 93			call break_point_state  
a23a				endm  
# End of macro CALLMONITOR
a23a					endif 
a23a c3 03 a2				jp .storebyteat 
a23d					NEXTW 
a23d c3 62 9c			jp macro_next 
a240				endm 
# End of macro NEXTW
a240			.SCALL: 
a240				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
a240 23				db WORD_SYS_CORE+OPCODE_SCALL             
a241 74 a2			dw .DEPTH            
a243 05				db 4 + 1 
a244 .. 00			db "CALL",0              
a249				endm 
# End of macro CWHEAD
a249			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
a249					if DEBUG_FORTH_WORDS_KEY 
a249						DMARK "CLL" 
a249 f5				push af  
a24a 3a 5e a2			ld a, (.dmark)  
a24d 32 7a ee			ld (debug_mark),a  
a250 3a 5f a2			ld a, (.dmark+1)  
a253 32 7b ee			ld (debug_mark+1),a  
a256 3a 60 a2			ld a, (.dmark+2)  
a259 32 7c ee			ld (debug_mark+2),a  
a25c 18 03			jr .pastdmark  
a25e ..			.dmark: db "CLL"  
a261 f1			.pastdmark: pop af  
a262			endm  
# End of macro DMARK
a262						CALLMONITOR 
a262 cd 6c 93			call break_point_state  
a265				endm  
# End of macro CALLMONITOR
a265					endif 
a265			 
a265					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a265 cd f0 9a			call macro_dsp_valuehl 
a268				endm 
# End of macro FORTH_DSP_VALUEHL
a268			 
a268			;		push hl 
a268			 
a268					; destroy value TOS 
a268			 
a268					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a268 cd a8 9b			call macro_forth_dsp_pop 
a26b				endm 
# End of macro FORTH_DSP_POP
a26b			 
a26b						 
a26b			;		pop hl 
a26b			 
a26b					; how to do a call with hl???? save SP? 
a26b cd 0b 9c				call forth_call_hl 
a26e			 
a26e			 
a26e					; TODO push value back onto stack for another op etc 
a26e			 
a26e cd f9 98				call forth_push_numhl 
a271					NEXTW 
a271 c3 62 9c			jp macro_next 
a274				endm 
# End of macro NEXTW
a274			.DEPTH: 
a274				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
a274 24				db WORD_SYS_CORE+OPCODE_DEPTH             
a275 b1 a2			dw .OVER            
a277 06				db 5 + 1 
a278 .. 00			db "DEPTH",0              
a27e				endm 
# End of macro CWHEAD
a27e			; | DEPTH ( -- u ) Push count of stack | DONE 
a27e					; take current TOS and remove from base value div by two to get count 
a27e					if DEBUG_FORTH_WORDS_KEY 
a27e						DMARK "DEP" 
a27e f5				push af  
a27f 3a 93 a2			ld a, (.dmark)  
a282 32 7a ee			ld (debug_mark),a  
a285 3a 94 a2			ld a, (.dmark+1)  
a288 32 7b ee			ld (debug_mark+1),a  
a28b 3a 95 a2			ld a, (.dmark+2)  
a28e 32 7c ee			ld (debug_mark+2),a  
a291 18 03			jr .pastdmark  
a293 ..			.dmark: db "DEP"  
a296 f1			.pastdmark: pop af  
a297			endm  
# End of macro DMARK
a297						CALLMONITOR 
a297 cd 6c 93			call break_point_state  
a29a				endm  
# End of macro CALLMONITOR
a29a					endif 
a29a			 
a29a			 
a29a 2a 0d eb			ld hl, (cli_data_sp) 
a29d 11 c7 e8			ld de, cli_data_stack 
a2a0 ed 52			sbc hl,de 
a2a2				 
a2a2				; div by size of stack item 
a2a2			 
a2a2 5d				ld e,l 
a2a3 0e 03			ld c, 3 
a2a5 cd 4e 8a			call Div8 
a2a8			 
a2a8 6f				ld l,a 
a2a9 26 00			ld h,0 
a2ab			 
a2ab				;srl h 
a2ab				;rr l 
a2ab			 
a2ab cd f9 98				call forth_push_numhl 
a2ae					NEXTW 
a2ae c3 62 9c			jp macro_next 
a2b1				endm 
# End of macro NEXTW
a2b1			.OVER: 
a2b1				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
a2b1 42				db WORD_SYS_CORE+46             
a2b2 f8 a2			dw .PAUSE            
a2b4 05				db 4 + 1 
a2b5 .. 00			db "OVER",0              
a2ba				endm 
# End of macro CWHEAD
a2ba			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
a2ba					if DEBUG_FORTH_WORDS_KEY 
a2ba						DMARK "OVR" 
a2ba f5				push af  
a2bb 3a cf a2			ld a, (.dmark)  
a2be 32 7a ee			ld (debug_mark),a  
a2c1 3a d0 a2			ld a, (.dmark+1)  
a2c4 32 7b ee			ld (debug_mark+1),a  
a2c7 3a d1 a2			ld a, (.dmark+2)  
a2ca 32 7c ee			ld (debug_mark+2),a  
a2cd 18 03			jr .pastdmark  
a2cf ..			.dmark: db "OVR"  
a2d2 f1			.pastdmark: pop af  
a2d3			endm  
# End of macro DMARK
a2d3						CALLMONITOR 
a2d3 cd 6c 93			call break_point_state  
a2d6				endm  
# End of macro CALLMONITOR
a2d6					endif 
a2d6			 
a2d6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a2d6 cd f0 9a			call macro_dsp_valuehl 
a2d9				endm 
# End of macro FORTH_DSP_VALUEHL
a2d9 e5					push hl    ; n2 
a2da					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2da cd a8 9b			call macro_forth_dsp_pop 
a2dd				endm 
# End of macro FORTH_DSP_POP
a2dd			 
a2dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a2dd cd f0 9a			call macro_dsp_valuehl 
a2e0				endm 
# End of macro FORTH_DSP_VALUEHL
a2e0 e5					push hl    ; n1 
a2e1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a2e1 cd a8 9b			call macro_forth_dsp_pop 
a2e4				endm 
# End of macro FORTH_DSP_POP
a2e4			 
a2e4 d1					pop de     ; n1 
a2e5 e1					pop hl     ; n2 
a2e6			 
a2e6 d5					push de 
a2e7 e5					push hl 
a2e8 d5					push de 
a2e9			 
a2e9					; push back  
a2e9			 
a2e9 e1					pop hl 
a2ea cd f9 98				call forth_push_numhl 
a2ed e1					pop hl 
a2ee cd f9 98				call forth_push_numhl 
a2f1 e1					pop hl 
a2f2 cd f9 98				call forth_push_numhl 
a2f5					NEXTW 
a2f5 c3 62 9c			jp macro_next 
a2f8				endm 
# End of macro NEXTW
a2f8			 
a2f8			.PAUSE: 
a2f8				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
a2f8 43				db WORD_SYS_CORE+47             
a2f9 2d a3			dw .PAUSES            
a2fb 08				db 7 + 1 
a2fc .. 00			db "PAUSEMS",0              
a304				endm 
# End of macro CWHEAD
a304			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
a304					if DEBUG_FORTH_WORDS_KEY 
a304						DMARK "PMS" 
a304 f5				push af  
a305 3a 19 a3			ld a, (.dmark)  
a308 32 7a ee			ld (debug_mark),a  
a30b 3a 1a a3			ld a, (.dmark+1)  
a30e 32 7b ee			ld (debug_mark+1),a  
a311 3a 1b a3			ld a, (.dmark+2)  
a314 32 7c ee			ld (debug_mark+2),a  
a317 18 03			jr .pastdmark  
a319 ..			.dmark: db "PMS"  
a31c f1			.pastdmark: pop af  
a31d			endm  
# End of macro DMARK
a31d						CALLMONITOR 
a31d cd 6c 93			call break_point_state  
a320				endm  
# End of macro CALLMONITOR
a320					endif 
a320					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a320 cd f0 9a			call macro_dsp_valuehl 
a323				endm 
# End of macro FORTH_DSP_VALUEHL
a323			;		push hl    ; n2 
a323					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a323 cd a8 9b			call macro_forth_dsp_pop 
a326				endm 
# End of macro FORTH_DSP_POP
a326			;		pop hl 
a326			 
a326 7d					ld a, l 
a327 cd f3 87				call aDelayInMS 
a32a				       NEXTW 
a32a c3 62 9c			jp macro_next 
a32d				endm 
# End of macro NEXTW
a32d			.PAUSES:  
a32d				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
a32d 44				db WORD_SYS_CORE+48             
a32e 9c a3			dw .ROT            
a330 06				db 5 + 1 
a331 .. 00			db "PAUSE",0              
a337				endm 
# End of macro CWHEAD
a337			; | PAUSE ( n -- )  Pause for n seconds | DONE 
a337					if DEBUG_FORTH_WORDS_KEY 
a337						DMARK "PAU" 
a337 f5				push af  
a338 3a 4c a3			ld a, (.dmark)  
a33b 32 7a ee			ld (debug_mark),a  
a33e 3a 4d a3			ld a, (.dmark+1)  
a341 32 7b ee			ld (debug_mark+1),a  
a344 3a 4e a3			ld a, (.dmark+2)  
a347 32 7c ee			ld (debug_mark+2),a  
a34a 18 03			jr .pastdmark  
a34c ..			.dmark: db "PAU"  
a34f f1			.pastdmark: pop af  
a350			endm  
# End of macro DMARK
a350						CALLMONITOR 
a350 cd 6c 93			call break_point_state  
a353				endm  
# End of macro CALLMONITOR
a353					endif 
a353					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a353 cd f0 9a			call macro_dsp_valuehl 
a356				endm 
# End of macro FORTH_DSP_VALUEHL
a356			;		push hl    ; n2 
a356					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a356 cd a8 9b			call macro_forth_dsp_pop 
a359				endm 
# End of macro FORTH_DSP_POP
a359			;		pop hl 
a359 45					ld b, l 
a35a					if DEBUG_FORTH_WORDS 
a35a						DMARK "PAU" 
a35a f5				push af  
a35b 3a 6f a3			ld a, (.dmark)  
a35e 32 7a ee			ld (debug_mark),a  
a361 3a 70 a3			ld a, (.dmark+1)  
a364 32 7b ee			ld (debug_mark+1),a  
a367 3a 71 a3			ld a, (.dmark+2)  
a36a 32 7c ee			ld (debug_mark+2),a  
a36d 18 03			jr .pastdmark  
a36f ..			.dmark: db "PAU"  
a372 f1			.pastdmark: pop af  
a373			endm  
# End of macro DMARK
a373						CALLMONITOR 
a373 cd 6c 93			call break_point_state  
a376				endm  
# End of macro CALLMONITOR
a376					endif 
a376 c5			.pauses1:	push bc 
a377 cd 0e 88				call delay1s 
a37a c1					pop bc 
a37b					if DEBUG_FORTH_WORDS 
a37b						DMARK "PA1" 
a37b f5				push af  
a37c 3a 90 a3			ld a, (.dmark)  
a37f 32 7a ee			ld (debug_mark),a  
a382 3a 91 a3			ld a, (.dmark+1)  
a385 32 7b ee			ld (debug_mark+1),a  
a388 3a 92 a3			ld a, (.dmark+2)  
a38b 32 7c ee			ld (debug_mark+2),a  
a38e 18 03			jr .pastdmark  
a390 ..			.dmark: db "PA1"  
a393 f1			.pastdmark: pop af  
a394			endm  
# End of macro DMARK
a394						CALLMONITOR 
a394 cd 6c 93			call break_point_state  
a397				endm  
# End of macro CALLMONITOR
a397					endif 
a397 10 dd				djnz .pauses1 
a399			 
a399				       NEXTW 
a399 c3 62 9c			jp macro_next 
a39c				endm 
# End of macro NEXTW
a39c			.ROT: 
a39c				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
a39c 45				db WORD_SYS_CORE+49             
a39d ea a3			dw .UWORDS            
a39f 04				db 3 + 1 
a3a0 .. 00			db "ROT",0              
a3a4				endm 
# End of macro CWHEAD
a3a4			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
a3a4					if DEBUG_FORTH_WORDS_KEY 
a3a4						DMARK "ROT" 
a3a4 f5				push af  
a3a5 3a b9 a3			ld a, (.dmark)  
a3a8 32 7a ee			ld (debug_mark),a  
a3ab 3a ba a3			ld a, (.dmark+1)  
a3ae 32 7b ee			ld (debug_mark+1),a  
a3b1 3a bb a3			ld a, (.dmark+2)  
a3b4 32 7c ee			ld (debug_mark+2),a  
a3b7 18 03			jr .pastdmark  
a3b9 ..			.dmark: db "ROT"  
a3bc f1			.pastdmark: pop af  
a3bd			endm  
# End of macro DMARK
a3bd						CALLMONITOR 
a3bd cd 6c 93			call break_point_state  
a3c0				endm  
# End of macro CALLMONITOR
a3c0					endif 
a3c0			 
a3c0					FORTH_DSP_VALUEHL 
a3c0 cd f0 9a			call macro_dsp_valuehl 
a3c3				endm 
# End of macro FORTH_DSP_VALUEHL
a3c3 e5					push hl    ; u3  
a3c4			 
a3c4					FORTH_DSP_POP 
a3c4 cd a8 9b			call macro_forth_dsp_pop 
a3c7				endm 
# End of macro FORTH_DSP_POP
a3c7			   
a3c7					FORTH_DSP_VALUEHL 
a3c7 cd f0 9a			call macro_dsp_valuehl 
a3ca				endm 
# End of macro FORTH_DSP_VALUEHL
a3ca e5					push hl     ; u2 
a3cb			 
a3cb					FORTH_DSP_POP 
a3cb cd a8 9b			call macro_forth_dsp_pop 
a3ce				endm 
# End of macro FORTH_DSP_POP
a3ce			 
a3ce					FORTH_DSP_VALUEHL 
a3ce cd f0 9a			call macro_dsp_valuehl 
a3d1				endm 
# End of macro FORTH_DSP_VALUEHL
a3d1 e5					push hl     ; u1 
a3d2			 
a3d2					FORTH_DSP_POP 
a3d2 cd a8 9b			call macro_forth_dsp_pop 
a3d5				endm 
# End of macro FORTH_DSP_POP
a3d5			 
a3d5 c1					pop bc      ; u1 
a3d6 e1					pop hl      ; u2 
a3d7 d1					pop de      ; u3 
a3d8			 
a3d8			 
a3d8 c5					push bc 
a3d9 d5					push de 
a3da e5					push hl 
a3db			 
a3db			 
a3db e1					pop hl 
a3dc cd f9 98				call forth_push_numhl 
a3df			 
a3df e1					pop hl 
a3e0 cd f9 98				call forth_push_numhl 
a3e3			 
a3e3 e1					pop hl 
a3e4 cd f9 98				call forth_push_numhl 
a3e7					 
a3e7			 
a3e7			 
a3e7			 
a3e7			 
a3e7			 
a3e7				       NEXTW 
a3e7 c3 62 9c			jp macro_next 
a3ea				endm 
# End of macro NEXTW
a3ea			 
a3ea			.UWORDS: 
a3ea				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
a3ea 50				db WORD_SYS_CORE+60             
a3eb ac a4			dw .BP            
a3ed 07				db 6 + 1 
a3ee .. 00			db "UWORDS",0              
a3f5				endm 
# End of macro CWHEAD
a3f5			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
a3f5			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
a3f5			; | | Following the count are the individual words. 
a3f5			; | | 
a3f5			; | | e.g. UWORDS 
a3f5			; | | BOX DIRLIST 2 
a3f5			; | |  
a3f5			; | | Can be used to save the words to storage via: 
a3f5			; | | UWORDS $01 DO $01 APPEND LOOP 
a3f5				if DEBUG_FORTH_WORDS_KEY 
a3f5					DMARK "UWR" 
a3f5 f5				push af  
a3f6 3a 0a a4			ld a, (.dmark)  
a3f9 32 7a ee			ld (debug_mark),a  
a3fc 3a 0b a4			ld a, (.dmark+1)  
a3ff 32 7b ee			ld (debug_mark+1),a  
a402 3a 0c a4			ld a, (.dmark+2)  
a405 32 7c ee			ld (debug_mark+2),a  
a408 18 03			jr .pastdmark  
a40a ..			.dmark: db "UWR"  
a40d f1			.pastdmark: pop af  
a40e			endm  
# End of macro DMARK
a40e					CALLMONITOR 
a40e cd 6c 93			call break_point_state  
a411				endm  
# End of macro CALLMONITOR
a411				endif 
a411 21 df d7				ld hl, baseram 
a414					;ld hl, baseusermem 
a414 01 00 00				ld bc, 0    ; start a counter 
a417			 
a417				; skip dict stub 
a417			 
a417 cd b3 9d				call forth_tok_next 
a41a			 
a41a			 
a41a			; while we have words to look for 
a41a			 
a41a 7e			.douscan:	ld a, (hl)      
a41b				if DEBUG_FORTH_WORDS 
a41b					DMARK "UWs" 
a41b f5				push af  
a41c 3a 30 a4			ld a, (.dmark)  
a41f 32 7a ee			ld (debug_mark),a  
a422 3a 31 a4			ld a, (.dmark+1)  
a425 32 7b ee			ld (debug_mark+1),a  
a428 3a 32 a4			ld a, (.dmark+2)  
a42b 32 7c ee			ld (debug_mark+2),a  
a42e 18 03			jr .pastdmark  
a430 ..			.dmark: db "UWs"  
a433 f1			.pastdmark: pop af  
a434			endm  
# End of macro DMARK
a434					CALLMONITOR 
a434 cd 6c 93			call break_point_state  
a437				endm  
# End of macro CALLMONITOR
a437				endif 
a437 fe 00				cp WORD_SYS_END 
a439 28 4d				jr z, .udone 
a43b fe 01				cp WORD_SYS_UWORD 
a43d 20 44				jr nz, .nuword 
a43f			 
a43f				if DEBUG_FORTH_WORDS 
a43f					DMARK "UWu" 
a43f f5				push af  
a440 3a 54 a4			ld a, (.dmark)  
a443 32 7a ee			ld (debug_mark),a  
a446 3a 55 a4			ld a, (.dmark+1)  
a449 32 7b ee			ld (debug_mark+1),a  
a44c 3a 56 a4			ld a, (.dmark+2)  
a44f 32 7c ee			ld (debug_mark+2),a  
a452 18 03			jr .pastdmark  
a454 ..			.dmark: db "UWu"  
a457 f1			.pastdmark: pop af  
a458			endm  
# End of macro DMARK
a458					CALLMONITOR 
a458 cd 6c 93			call break_point_state  
a45b				endm  
# End of macro CALLMONITOR
a45b				endif 
a45b					; we have a uword so push its name to the stack 
a45b			 
a45b e5				   	push hl  ; save so we can move to next dict block 
a45c			 
a45c					; skip opcode 
a45c 23					inc hl  
a45d					; skip next ptr 
a45d 23					inc hl  
a45e 23					inc hl 
a45f					; skip len 
a45f 23					inc hl 
a460				if DEBUG_FORTH_WORDS 
a460					DMARK "UWt" 
a460 f5				push af  
a461 3a 75 a4			ld a, (.dmark)  
a464 32 7a ee			ld (debug_mark),a  
a467 3a 76 a4			ld a, (.dmark+1)  
a46a 32 7b ee			ld (debug_mark+1),a  
a46d 3a 77 a4			ld a, (.dmark+2)  
a470 32 7c ee			ld (debug_mark+2),a  
a473 18 03			jr .pastdmark  
a475 ..			.dmark: db "UWt"  
a478 f1			.pastdmark: pop af  
a479			endm  
# End of macro DMARK
a479					CALLMONITOR 
a479 cd 6c 93			call break_point_state  
a47c				endm  
# End of macro CALLMONITOR
a47c				endif 
a47c 03					inc bc 
a47d			 
a47d c5					push bc 
a47e cd 67 99				call forth_push_str 
a481 c1					pop bc 
a482			 
a482 e1					pop hl 	 
a483			 
a483 cd b3 9d		.nuword:	call forth_tok_next 
a486 18 92				jr .douscan  
a488			 
a488			.udone:		 ; push count of uwords found 
a488 c5					push bc 
a489 e1					pop hl 
a48a			 
a48a				if DEBUG_FORTH_WORDS 
a48a					DMARK "UWc" 
a48a f5				push af  
a48b 3a 9f a4			ld a, (.dmark)  
a48e 32 7a ee			ld (debug_mark),a  
a491 3a a0 a4			ld a, (.dmark+1)  
a494 32 7b ee			ld (debug_mark+1),a  
a497 3a a1 a4			ld a, (.dmark+2)  
a49a 32 7c ee			ld (debug_mark+2),a  
a49d 18 03			jr .pastdmark  
a49f ..			.dmark: db "UWc"  
a4a2 f1			.pastdmark: pop af  
a4a3			endm  
# End of macro DMARK
a4a3					CALLMONITOR 
a4a3 cd 6c 93			call break_point_state  
a4a6				endm  
# End of macro CALLMONITOR
a4a6				endif 
a4a6 cd f9 98				call forth_push_numhl 
a4a9			 
a4a9			 
a4a9				       NEXTW 
a4a9 c3 62 9c			jp macro_next 
a4ac				endm 
# End of macro NEXTW
a4ac			 
a4ac			.BP: 
a4ac				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
a4ac 54				db WORD_SYS_CORE+64             
a4ad e2 a4			dw .MONITOR            
a4af 03				db 2 + 1 
a4b0 .. 00			db "BP",0              
a4b3				endm 
# End of macro CWHEAD
a4b3			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
a4b3			; | | $00 Will enable the break points within specific code paths 
a4b3			; | | $01 Will disable break points 
a4b3			; | |  
a4b3			; | | By default break points are off. Either the above can be used to enable them 
a4b3			; | | or if a key is held down during start up the spashscreen will appear to freeze 
a4b3			; | | and on release of the pressed key a message will be disaplayed to notify 
a4b3			; | | that break points are enabled. Pressing any key will then continue boot process. 
a4b3					; get byte count 
a4b3					if DEBUG_FORTH_WORDS_KEY 
a4b3						DMARK "BP." 
a4b3 f5				push af  
a4b4 3a c8 a4			ld a, (.dmark)  
a4b7 32 7a ee			ld (debug_mark),a  
a4ba 3a c9 a4			ld a, (.dmark+1)  
a4bd 32 7b ee			ld (debug_mark+1),a  
a4c0 3a ca a4			ld a, (.dmark+2)  
a4c3 32 7c ee			ld (debug_mark+2),a  
a4c6 18 03			jr .pastdmark  
a4c8 ..			.dmark: db "BP."  
a4cb f1			.pastdmark: pop af  
a4cc			endm  
# End of macro DMARK
a4cc						CALLMONITOR 
a4cc cd 6c 93			call break_point_state  
a4cf				endm  
# End of macro CALLMONITOR
a4cf					endif 
a4cf			 
a4cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a4cf cd f0 9a			call macro_dsp_valuehl 
a4d2				endm 
# End of macro FORTH_DSP_VALUEHL
a4d2			 
a4d2			;		push hl 
a4d2			 
a4d2					; destroy value TOS 
a4d2			 
a4d2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a4d2 cd a8 9b			call macro_forth_dsp_pop 
a4d5				endm 
# End of macro FORTH_DSP_POP
a4d5			 
a4d5			;		pop hl 
a4d5			 
a4d5 3e 00				ld a,0 
a4d7 bd					cp l 
a4d8 28 02				jr z, .bpset 
a4da 3e 2a				ld a, '*' 
a4dc			 
a4dc 32 51 e3		.bpset:		ld (os_view_disable), a 
a4df			 
a4df			 
a4df					NEXTW 
a4df c3 62 9c			jp macro_next 
a4e2				endm 
# End of macro NEXTW
a4e2			 
a4e2			 
a4e2			.MONITOR: 
a4e2				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
a4e2 55				db WORD_SYS_CORE+65             
a4e3 15 a5			dw .MALLOC            
a4e5 08				db 7 + 1 
a4e6 .. 00			db "MONITOR",0              
a4ee				endm 
# End of macro CWHEAD
a4ee			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
a4ee			; | | At start the current various registers will be displayed with contents. 
a4ee			; | | Top right corner will show the most recent debug marker seen. 
a4ee			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
a4ee			; | | and the return stack pointer (RSP). 
a4ee			; | | Pressing: 
a4ee			; | |    1 - Initial screen 
a4ee			; | |    2 - Display a data dump of HL 
a4ee			; | |    3 - Display a data dump of DE 
a4ee			; | |    4 - Display a data dump of BC 
a4ee			; | |    5 - Display a data dump of HL 
a4ee			; | |    6 - Display a data dump of DSP 
a4ee			; | |    7 - Display a data dump of RSP 
a4ee			; | |    8 - Display a data dump of what is at DSP 
a4ee			; | |    9 - Display a data dump of what is at RSP 
a4ee			; | |    0 - Exit monitor and continue running. This will also enable break points 
a4ee			; | |    * - Disable break points 
a4ee			; | |    # - Enter traditional monitor mode 
a4ee			; | | 
a4ee			; | | Monitor Mode 
a4ee			; | | ------------ 
a4ee			; | | A prompt of '>' will be shown for various commands: 
a4ee			; | |    D xxxx - Display a data dump starting from hex address xxxx 
a4ee			; | |    C - Continue display a data dump from the last set address 
a4ee			; | |    M xxxx - Set start of memory edit at address xx 
a4ee			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
a4ee			; | |    Q - Return to previous 
a4ee					if DEBUG_FORTH_WORDS_KEY 
a4ee						DMARK "MON" 
a4ee f5				push af  
a4ef 3a 03 a5			ld a, (.dmark)  
a4f2 32 7a ee			ld (debug_mark),a  
a4f5 3a 04 a5			ld a, (.dmark+1)  
a4f8 32 7b ee			ld (debug_mark+1),a  
a4fb 3a 05 a5			ld a, (.dmark+2)  
a4fe 32 7c ee			ld (debug_mark+2),a  
a501 18 03			jr .pastdmark  
a503 ..			.dmark: db "MON"  
a506 f1			.pastdmark: pop af  
a507			endm  
# End of macro DMARK
a507						CALLMONITOR 
a507 cd 6c 93			call break_point_state  
a50a				endm  
# End of macro CALLMONITOR
a50a					endif 
a50a 3e 00				ld a, 0 
a50c 32 51 e3				ld (os_view_disable), a 
a50f			 
a50f					CALLMONITOR 
a50f cd 6c 93			call break_point_state  
a512				endm  
# End of macro CALLMONITOR
a512			 
a512			;	call monitor 
a512			 
a512					NEXTW 
a512 c3 62 9c			jp macro_next 
a515				endm 
# End of macro NEXTW
a515			 
a515			 
a515			.MALLOC: 
a515				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
a515 56				db WORD_SYS_CORE+66             
a516 3e a5			dw .MALLOC2            
a518 06				db 5 + 1 
a519 .. 00			db "ALLOT",0              
a51f				endm 
# End of macro CWHEAD
a51f			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a51f					if DEBUG_FORTH_WORDS_KEY 
a51f						DMARK "ALL" 
a51f f5				push af  
a520 3a 34 a5			ld a, (.dmark)  
a523 32 7a ee			ld (debug_mark),a  
a526 3a 35 a5			ld a, (.dmark+1)  
a529 32 7b ee			ld (debug_mark+1),a  
a52c 3a 36 a5			ld a, (.dmark+2)  
a52f 32 7c ee			ld (debug_mark+2),a  
a532 18 03			jr .pastdmark  
a534 ..			.dmark: db "ALL"  
a537 f1			.pastdmark: pop af  
a538			endm  
# End of macro DMARK
a538						CALLMONITOR 
a538 cd 6c 93			call break_point_state  
a53b				endm  
# End of macro CALLMONITOR
a53b					endif 
a53b c3 65 a5				jp .mallocc 
a53e			.MALLOC2: 
a53e				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
a53e 56				db WORD_SYS_CORE+66             
a53f 7c a5			dw .FREE            
a541 07				db 6 + 1 
a542 .. 00			db "MALLOC",0              
a549				endm 
# End of macro CWHEAD
a549			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
a549					; get byte count 
a549					if DEBUG_FORTH_WORDS_KEY 
a549						DMARK "MAL" 
a549 f5				push af  
a54a 3a 5e a5			ld a, (.dmark)  
a54d 32 7a ee			ld (debug_mark),a  
a550 3a 5f a5			ld a, (.dmark+1)  
a553 32 7b ee			ld (debug_mark+1),a  
a556 3a 60 a5			ld a, (.dmark+2)  
a559 32 7c ee			ld (debug_mark+2),a  
a55c 18 03			jr .pastdmark  
a55e ..			.dmark: db "MAL"  
a561 f1			.pastdmark: pop af  
a562			endm  
# End of macro DMARK
a562						CALLMONITOR 
a562 cd 6c 93			call break_point_state  
a565				endm  
# End of macro CALLMONITOR
a565					endif 
a565			.mallocc: 
a565					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a565 cd f0 9a			call macro_dsp_valuehl 
a568				endm 
# End of macro FORTH_DSP_VALUEHL
a568			 
a568			;		push hl 
a568			 
a568					; destroy value TOS 
a568			 
a568					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a568 cd a8 9b			call macro_forth_dsp_pop 
a56b				endm 
# End of macro FORTH_DSP_POP
a56b			 
a56b			;		pop hl 
a56b cd 85 8f				call malloc 
a56e				if DEBUG_FORTH_MALLOC_GUARD 
a56e f5					push af 
a56f cd e7 8a				call ishlzero 
a572			;		ld a, l 
a572			;		add h 
a572			;		cp 0 
a572 f1					pop af 
a573					 
a573 cc 94 c4				call z,malloc_error 
a576				endif 
a576			 
a576 cd f9 98				call forth_push_numhl 
a579					NEXTW 
a579 c3 62 9c			jp macro_next 
a57c				endm 
# End of macro NEXTW
a57c			 
a57c			.FREE: 
a57c				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
a57c 57				db WORD_SYS_CORE+67             
a57d ad a5			dw .LIST            
a57f 05				db 4 + 1 
a580 .. 00			db "FREE",0              
a585				endm 
# End of macro CWHEAD
a585			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
a585					if DEBUG_FORTH_WORDS_KEY 
a585						DMARK "FRE" 
a585 f5				push af  
a586 3a 9a a5			ld a, (.dmark)  
a589 32 7a ee			ld (debug_mark),a  
a58c 3a 9b a5			ld a, (.dmark+1)  
a58f 32 7b ee			ld (debug_mark+1),a  
a592 3a 9c a5			ld a, (.dmark+2)  
a595 32 7c ee			ld (debug_mark+2),a  
a598 18 03			jr .pastdmark  
a59a ..			.dmark: db "FRE"  
a59d f1			.pastdmark: pop af  
a59e			endm  
# End of macro DMARK
a59e						CALLMONITOR 
a59e cd 6c 93			call break_point_state  
a5a1				endm  
# End of macro CALLMONITOR
a5a1					endif 
a5a1					; get address 
a5a1			 
a5a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
a5a1 cd f0 9a			call macro_dsp_valuehl 
a5a4				endm 
# End of macro FORTH_DSP_VALUEHL
a5a4			 
a5a4			;		push hl 
a5a4			 
a5a4					; destroy value TOS 
a5a4			 
a5a4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
a5a4 cd a8 9b			call macro_forth_dsp_pop 
a5a7				endm 
# End of macro FORTH_DSP_POP
a5a7			 
a5a7			;		pop hl 
a5a7			if FORTH_ENABLE_MALLOCFREE 
a5a7 cd 4f 90				call free 
a5aa			endif 
a5aa					NEXTW 
a5aa c3 62 9c			jp macro_next 
a5ad				endm 
# End of macro NEXTW
a5ad			.LIST: 
a5ad				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
a5ad 5c				db WORD_SYS_CORE+72             
a5ae 9b a7			dw .FORGET            
a5b0 05				db 4 + 1 
a5b1 .. 00			db "LIST",0              
a5b6				endm 
# End of macro CWHEAD
a5b6			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
a5b6			; | | The quoted word must be in upper case. 
a5b6				if DEBUG_FORTH_WORDS_KEY 
a5b6					DMARK "LST" 
a5b6 f5				push af  
a5b7 3a cb a5			ld a, (.dmark)  
a5ba 32 7a ee			ld (debug_mark),a  
a5bd 3a cc a5			ld a, (.dmark+1)  
a5c0 32 7b ee			ld (debug_mark+1),a  
a5c3 3a cd a5			ld a, (.dmark+2)  
a5c6 32 7c ee			ld (debug_mark+2),a  
a5c9 18 03			jr .pastdmark  
a5cb ..			.dmark: db "LST"  
a5ce f1			.pastdmark: pop af  
a5cf			endm  
# End of macro DMARK
a5cf					CALLMONITOR 
a5cf cd 6c 93			call break_point_state  
a5d2				endm  
# End of macro CALLMONITOR
a5d2				endif 
a5d2			 
a5d2					FORTH_DSP_VALUEHL 
a5d2 cd f0 9a			call macro_dsp_valuehl 
a5d5				endm 
# End of macro FORTH_DSP_VALUEHL
a5d5			 
a5d5 e5					push hl 
a5d6					FORTH_DSP_POP 
a5d6 cd a8 9b			call macro_forth_dsp_pop 
a5d9				endm 
# End of macro FORTH_DSP_POP
a5d9 c1					pop bc 
a5da			 
a5da			; Start format of scratch string 
a5da			 
a5da 21 60 e3				ld hl, scratch 
a5dd			 
a5dd 3e 3a				ld a, ':' 
a5df 77					ld (hl),a 
a5e0 23					inc hl 
a5e1 3e 20				ld a, ' ' 
a5e3 77					ld (hl), a 
a5e4			 
a5e4					; Get ptr to the word we need to look up 
a5e4			 
a5e4			;		FORTH_DSP_VALUEHL 
a5e4					;v5 FORTH_DSP_VALUE 
a5e4				; TODO type check 
a5e4			;		inc hl    ; Skip type check  
a5e4			;		push hl 
a5e4			;		ex de, hl    ; put into DE 
a5e4			 
a5e4			 
a5e4 21 df d7				ld hl, baseram 
a5e7					;ld hl, baseusermem 
a5e7			 
a5e7 e5			push hl   ; sacreifical push 
a5e8			 
a5e8			.ldouscanm: 
a5e8 e1				pop hl 
a5e9			.ldouscan: 
a5e9				if DEBUG_FORTH_WORDS 
a5e9					DMARK "LSs" 
a5e9 f5				push af  
a5ea 3a fe a5			ld a, (.dmark)  
a5ed 32 7a ee			ld (debug_mark),a  
a5f0 3a ff a5			ld a, (.dmark+1)  
a5f3 32 7b ee			ld (debug_mark+1),a  
a5f6 3a 00 a6			ld a, (.dmark+2)  
a5f9 32 7c ee			ld (debug_mark+2),a  
a5fc 18 03			jr .pastdmark  
a5fe ..			.dmark: db "LSs"  
a601 f1			.pastdmark: pop af  
a602			endm  
# End of macro DMARK
a602					CALLMONITOR 
a602 cd 6c 93			call break_point_state  
a605				endm  
# End of macro CALLMONITOR
a605				endif 
a605				; skip dict stub 
a605 cd b3 9d				call forth_tok_next 
a608			 
a608			 
a608			; while we have words to look for 
a608			 
a608 7e				ld a, (hl)      
a609				if DEBUG_FORTH_WORDS 
a609					DMARK "LSk" 
a609 f5				push af  
a60a 3a 1e a6			ld a, (.dmark)  
a60d 32 7a ee			ld (debug_mark),a  
a610 3a 1f a6			ld a, (.dmark+1)  
a613 32 7b ee			ld (debug_mark+1),a  
a616 3a 20 a6			ld a, (.dmark+2)  
a619 32 7c ee			ld (debug_mark+2),a  
a61c 18 03			jr .pastdmark  
a61e ..			.dmark: db "LSk"  
a621 f1			.pastdmark: pop af  
a622			endm  
# End of macro DMARK
a622					CALLMONITOR 
a622 cd 6c 93			call break_point_state  
a625				endm  
# End of macro CALLMONITOR
a625				endif 
a625					;cp WORD_SYS_END 
a625					;jp z, .lunotfound 
a625			 
a625					; if we hit non uwords then gone too far 
a625 fe 01				cp WORD_SYS_UWORD 
a627 c2 57 a7				jp nz, .lunotfound 
a62a			 
a62a				if DEBUG_FORTH_WORDS 
a62a					DMARK "LSu" 
a62a f5				push af  
a62b 3a 3f a6			ld a, (.dmark)  
a62e 32 7a ee			ld (debug_mark),a  
a631 3a 40 a6			ld a, (.dmark+1)  
a634 32 7b ee			ld (debug_mark+1),a  
a637 3a 41 a6			ld a, (.dmark+2)  
a63a 32 7c ee			ld (debug_mark+2),a  
a63d 18 03			jr .pastdmark  
a63f ..			.dmark: db "LSu"  
a642 f1			.pastdmark: pop af  
a643			endm  
# End of macro DMARK
a643					CALLMONITOR 
a643 cd 6c 93			call break_point_state  
a646				endm  
# End of macro CALLMONITOR
a646				endif 
a646			 
a646					; found a uword but is it the one we want... 
a646			 
a646 c5					push bc     ; uword to find is on bc 
a647 d1					pop de 
a648			 
a648 e5					push hl  ; to save the ptr 
a649			 
a649					; skip opcode 
a649 23					inc hl  
a64a					; skip next ptr 
a64a 23					inc hl  
a64b 23					inc hl 
a64c					; skip len 
a64c 23					inc hl 
a64d			 
a64d				if DEBUG_FORTH_WORDS 
a64d					DMARK "LSc" 
a64d f5				push af  
a64e 3a 62 a6			ld a, (.dmark)  
a651 32 7a ee			ld (debug_mark),a  
a654 3a 63 a6			ld a, (.dmark+1)  
a657 32 7b ee			ld (debug_mark+1),a  
a65a 3a 64 a6			ld a, (.dmark+2)  
a65d 32 7c ee			ld (debug_mark+2),a  
a660 18 03			jr .pastdmark  
a662 ..			.dmark: db "LSc"  
a665 f1			.pastdmark: pop af  
a666			endm  
# End of macro DMARK
a666					CALLMONITOR 
a666 cd 6c 93			call break_point_state  
a669				endm  
# End of macro CALLMONITOR
a669				endif 
a669 cd 54 8f				call strcmp 
a66c c2 e8 a5				jp nz, .ldouscanm 
a66f				 
a66f			 
a66f			 
a66f					; we have a uword so push its name to the stack 
a66f			 
a66f			;	   	push hl  ; save so we can move to next dict block 
a66f e1			pop hl 
a670			 
a670				if DEBUG_FORTH_WORDS 
a670					DMARK "LSm" 
a670 f5				push af  
a671 3a 85 a6			ld a, (.dmark)  
a674 32 7a ee			ld (debug_mark),a  
a677 3a 86 a6			ld a, (.dmark+1)  
a67a 32 7b ee			ld (debug_mark+1),a  
a67d 3a 87 a6			ld a, (.dmark+2)  
a680 32 7c ee			ld (debug_mark+2),a  
a683 18 03			jr .pastdmark  
a685 ..			.dmark: db "LSm"  
a688 f1			.pastdmark: pop af  
a689			endm  
# End of macro DMARK
a689					CALLMONITOR 
a689 cd 6c 93			call break_point_state  
a68c				endm  
# End of macro CALLMONITOR
a68c				endif 
a68c			 
a68c					; skip opcode 
a68c 23					inc hl  
a68d					; skip next ptr 
a68d 23					inc hl  
a68e 23					inc hl 
a68f					; skip len 
a68f 7e					ld a, (hl)   ; save length to add 
a690				if DEBUG_FORTH_WORDS 
a690					DMARK "LS2" 
a690 f5				push af  
a691 3a a5 a6			ld a, (.dmark)  
a694 32 7a ee			ld (debug_mark),a  
a697 3a a6 a6			ld a, (.dmark+1)  
a69a 32 7b ee			ld (debug_mark+1),a  
a69d 3a a7 a6			ld a, (.dmark+2)  
a6a0 32 7c ee			ld (debug_mark+2),a  
a6a3 18 03			jr .pastdmark  
a6a5 ..			.dmark: db "LS2"  
a6a8 f1			.pastdmark: pop af  
a6a9			endm  
# End of macro DMARK
a6a9					CALLMONITOR 
a6a9 cd 6c 93			call break_point_state  
a6ac				endm  
# End of macro CALLMONITOR
a6ac				endif 
a6ac			 
a6ac					; save this location 
a6ac				 
a6ac e5					push hl 
a6ad			 
a6ad 23					inc hl 
a6ae 11 62 e3				ld de, scratch+2 
a6b1 4f					ld c, a 
a6b2 06 00				ld b, 0 
a6b4			 
a6b4				if DEBUG_FORTH_WORDS 
a6b4					DMARK "LSn" 
a6b4 f5				push af  
a6b5 3a c9 a6			ld a, (.dmark)  
a6b8 32 7a ee			ld (debug_mark),a  
a6bb 3a ca a6			ld a, (.dmark+1)  
a6be 32 7b ee			ld (debug_mark+1),a  
a6c1 3a cb a6			ld a, (.dmark+2)  
a6c4 32 7c ee			ld (debug_mark+2),a  
a6c7 18 03			jr .pastdmark  
a6c9 ..			.dmark: db "LSn"  
a6cc f1			.pastdmark: pop af  
a6cd			endm  
# End of macro DMARK
a6cd					CALLMONITOR 
a6cd cd 6c 93			call break_point_state  
a6d0				endm  
# End of macro CALLMONITOR
a6d0				endif 
a6d0			 
a6d0					; copy uword name to scratch 
a6d0			 
a6d0 ed b0				ldir 
a6d2			 
a6d2 1b					dec de 
a6d3 3e 20				ld a, ' '    ; change null to space 
a6d5 12					ld (de), a 
a6d6			 
a6d6 13					inc de 
a6d7			 
a6d7 d5					push de 
a6d8 c1					pop bc     ; move scratch pointer to end of word name and save it 
a6d9			 
a6d9 e1					pop hl 
a6da 7e					ld a, (hl) 
a6db					;inc hl 
a6db					; skip word string 
a6db cd be 8a				call addatohl 
a6de			 
a6de 23					inc hl 
a6df			 
a6df				if DEBUG_FORTH_WORDS 
a6df					DMARK "LS3" 
a6df f5				push af  
a6e0 3a f4 a6			ld a, (.dmark)  
a6e3 32 7a ee			ld (debug_mark),a  
a6e6 3a f5 a6			ld a, (.dmark+1)  
a6e9 32 7b ee			ld (debug_mark+1),a  
a6ec 3a f6 a6			ld a, (.dmark+2)  
a6ef 32 7c ee			ld (debug_mark+2),a  
a6f2 18 03			jr .pastdmark  
a6f4 ..			.dmark: db "LS3"  
a6f7 f1			.pastdmark: pop af  
a6f8			endm  
# End of macro DMARK
a6f8					CALLMONITOR 
a6f8 cd 6c 93			call break_point_state  
a6fb				endm  
# End of macro CALLMONITOR
a6fb				endif 
a6fb					; should now be at the start of the machine code to setup the eval of the uword 
a6fb					; now locate the ptr to the string defintion 
a6fb			 
a6fb					; skip ld hl, 
a6fb					; then load the ptr 
a6fb			; TODO use get from hl ptr 
a6fb 23					inc hl 
a6fc 5e					ld e, (hl) 
a6fd 23					inc hl 
a6fe 56					ld d, (hl) 
a6ff eb					ex de, hl 
a700			 
a700			 
a700				if DEBUG_FORTH_WORDS 
a700					DMARK "LSt" 
a700 f5				push af  
a701 3a 15 a7			ld a, (.dmark)  
a704 32 7a ee			ld (debug_mark),a  
a707 3a 16 a7			ld a, (.dmark+1)  
a70a 32 7b ee			ld (debug_mark+1),a  
a70d 3a 17 a7			ld a, (.dmark+2)  
a710 32 7c ee			ld (debug_mark+2),a  
a713 18 03			jr .pastdmark  
a715 ..			.dmark: db "LSt"  
a718 f1			.pastdmark: pop af  
a719			endm  
# End of macro DMARK
a719					CALLMONITOR 
a719 cd 6c 93			call break_point_state  
a71c				endm  
# End of macro CALLMONITOR
a71c				endif 
a71c			 
a71c			; cant push right now due to tokenised strings  
a71c			 
a71c			; get the destination of where to copy this definition to. 
a71c			 
a71c c5					push bc 
a71d d1					pop de 
a71e			 
a71e 7e			.listl:         ld a,(hl) 
a71f fe 00				cp 0 
a721 28 09				jr z, .lreplsp     ; replace zero with space 
a723					;cp FORTH_END_BUFFER 
a723 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
a725 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
a727				 
a727					; just copy this char as is then 
a727			 
a727 12					ld (de), a 
a728			 
a728 23			.listnxt:	inc hl 
a729 13					inc de 
a72a 18 f2				jr .listl 
a72c			 
a72c 3e 20		.lreplsp:	ld a,' ' 
a72e 12					ld (de), a 
a72f 18 f7				jr .listnxt 
a731			 
a731			; close up uword def 
a731			 
a731			.listdone: 
a731 12					ld (de), a 
a732 13					inc de 
a733 3e 00				ld a, 0 
a735 12					ld (de), a 
a736			 
a736			; now have def so clean up and push to stack 
a736			 
a736 21 60 e3				ld hl, scratch 
a739				if DEBUG_FORTH_WORDS 
a739					DMARK "Ltp" 
a739 f5				push af  
a73a 3a 4e a7			ld a, (.dmark)  
a73d 32 7a ee			ld (debug_mark),a  
a740 3a 4f a7			ld a, (.dmark+1)  
a743 32 7b ee			ld (debug_mark+1),a  
a746 3a 50 a7			ld a, (.dmark+2)  
a749 32 7c ee			ld (debug_mark+2),a  
a74c 18 03			jr .pastdmark  
a74e ..			.dmark: db "Ltp"  
a751 f1			.pastdmark: pop af  
a752			endm  
# End of macro DMARK
a752					CALLMONITOR 
a752 cd 6c 93			call break_point_state  
a755				endm  
# End of macro CALLMONITOR
a755				endif 
a755			 
a755 18 1f			jr .listpush 
a757			 
a757			;.lnuword:	pop hl 
a757			;		call forth_tok_next 
a757			;		jp .ldouscan  
a757			 
a757			.lunotfound:		  
a757			 
a757				if DEBUG_FORTH_WORDS 
a757					DMARK "LSn" 
a757 f5				push af  
a758 3a 6c a7			ld a, (.dmark)  
a75b 32 7a ee			ld (debug_mark),a  
a75e 3a 6d a7			ld a, (.dmark+1)  
a761 32 7b ee			ld (debug_mark+1),a  
a764 3a 6e a7			ld a, (.dmark+2)  
a767 32 7c ee			ld (debug_mark+2),a  
a76a 18 03			jr .pastdmark  
a76c ..			.dmark: db "LSn"  
a76f f1			.pastdmark: pop af  
a770			endm  
# End of macro DMARK
a770					CALLMONITOR 
a770 cd 6c 93			call break_point_state  
a773				endm  
# End of macro CALLMONITOR
a773				endif 
a773			 
a773					 
a773			;		FORTH_DSP_POP 
a773			;		ld hl, .luno 
a773			 
a773					NEXTW			 
a773 c3 62 9c			jp macro_next 
a776				endm 
# End of macro NEXTW
a776			 
a776			.listpush: 
a776				if DEBUG_FORTH_WORDS 
a776					DMARK "LS>" 
a776 f5				push af  
a777 3a 8b a7			ld a, (.dmark)  
a77a 32 7a ee			ld (debug_mark),a  
a77d 3a 8c a7			ld a, (.dmark+1)  
a780 32 7b ee			ld (debug_mark+1),a  
a783 3a 8d a7			ld a, (.dmark+2)  
a786 32 7c ee			ld (debug_mark+2),a  
a789 18 03			jr .pastdmark  
a78b ..			.dmark: db "LS>"  
a78e f1			.pastdmark: pop af  
a78f			endm  
# End of macro DMARK
a78f					CALLMONITOR 
a78f cd 6c 93			call break_point_state  
a792				endm  
# End of macro CALLMONITOR
a792				endif 
a792 cd 67 99				call forth_push_str 
a795			 
a795			 
a795			 
a795					NEXTW 
a795 c3 62 9c			jp macro_next 
a798				endm 
# End of macro NEXTW
a798			 
a798			;.luno:    db "Word not found",0 
a798			 
a798			 
a798			 
a798			 
a798			 
a798			;		push hl   ; save pointer to start of uword def string 
a798			; 
a798			;; look for FORTH_EOL_LINE 
a798			;		ld a, FORTH_END_BUFFER 
a798			;		call strlent 
a798			; 
a798			;		inc hl		 ; space for coln def 
a798			;		inc hl 
a798			;		inc hl          ; space for terms 
a798			;		inc hl 
a798			; 
a798			;		ld a, 20   ; TODO get actual length 
a798			;		call addatohl    ; include a random amount of room for the uword name 
a798			; 
a798			;		 
a798			;	if DEBUG_FORTH_WORDS 
a798			;		DMARK "Lt1" 
a798			;		CALLMONITOR 
a798			;	endif 
a798			;		 
a798			; 
a798			;; malloc space for the string because we cant change it 
a798			; 
a798			;		call malloc 
a798			;	if DEBUG_FORTH_MALLOC_GUARD 
a798			;		push af 
a798			;		call ishlzero 
a798			;		pop af 
a798			;		 
a798			;		call z,malloc_error 
a798			;	endif 
a798			; 
a798			;	if DEBUG_FORTH_WORDS 
a798			;		DMARK "Lt2" 
a798			;		CALLMONITOR 
a798			;	endif 
a798			;		pop de 
a798			;		push hl    ; push the malloc to release later 
a798			;		push hl   ;  push back a copy for the later stack push 
a798			;		 
a798			;; copy the string swapping out the zero terms for spaces 
a798			; 
a798			;		; de has our source 
a798			;		; hl has our dest 
a798			; 
a798			;; add the coln def 
a798			; 
a798			;		ld a, ':' 
a798			;		ld (hl), a 
a798			;		inc hl 
a798			;		ld a, ' ' 
a798			;		ld (hl), a 
a798			;		inc hl 
a798			; 
a798			;; add the uname word 
a798			;		push de   ; save our string for now 
a798			;		ex de, hl 
a798			; 
a798			;		FORTH_DSP_VALUE 
a798			;		;v5 FORTH_DSP_VALUE 
a798			; 
a798			;		inc hl   ; skip type but we know by now this is OK 
a798			; 
a798			;.luword:	ld a,(hl) 
a798			;		cp 0 
a798			;		jr z, .luword2 
a798			;		ld (de), a 
a798			;		inc de 
a798			;		inc hl 
a798			;		jr .luword 
a798			; 
a798			;.luword2:	ld a, ' ' 
a798			;		ld (de), a 
a798			;;		inc hl 
a798			;;		inc de 
a798			;;		ld (de), a 
a798			;;		inc hl 
a798			;		inc de 
a798			; 
a798			;		ex de, hl 
a798			;		pop de 
a798			;		 
a798			;		 
a798			; 
a798			;; detoken that string and copy it 
a798			; 
a798			;	if DEBUG_FORTH_WORDS 
a798			;		DMARK "Lt2" 
a798			;		CALLMONITOR 
a798			;	endif 
a798			;.ldetok:	ld a, (de) 
a798			;		cp FORTH_END_BUFFER 
a798			;		jr z, .ldetokend 
a798			;		; swap out any zero term for space 
a798			;		cp 0 
a798			;		jr nz, .ldetoknext 
a798			;		ld a, ' ' 
a798			; 
a798			;	if DEBUG_FORTH_WORDS 
a798			;		DMARK "LtS" 
a798			;		CALLMONITOR 
a798			;	endif 
a798			;.ldetoknext:	ld (hl), a 
a798			;		inc de 
a798			;		inc hl 
a798			;		jr .ldetok 
a798			; 
a798			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
a798			;		ld (hl), a  
a798			; 
a798			;; free that temp malloc 
a798			; 
a798			;		pop hl    
a798			; 
a798			;	if DEBUG_FORTH_WORDS 
a798			;		DMARK "Lt4" 
a798			;		CALLMONITOR 
a798			;	endif 
a798			;		call forth_apushstrhl 
a798			; 
a798			;		; get rid of temp malloc area 
a798			; 
a798			;		pop hl 
a798			;		call free 
a798			; 
a798			;		jr .ludone 
a798			; 
a798			;.lnuword:	pop hl 
a798			;		call forth_tok_next 
a798			;		jp .ldouscan  
a798			; 
a798			;.ludone:		 pop hl 
a798			; 
a798					NEXTW 
a798 c3 62 9c			jp macro_next 
a79b				endm 
# End of macro NEXTW
a79b			 
a79b			.FORGET: 
a79b				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
a79b 5d				db WORD_SYS_CORE+73             
a79c 14 a8			dw .NOP            
a79e 07				db 6 + 1 
a79f .. 00			db "FORGET",0              
a7a6				endm 
# End of macro CWHEAD
a7a6			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
a7a6			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
a7a6			; | |  
a7a6			; | | e.g. "MORE" forget 
a7a6					if DEBUG_FORTH_WORDS_KEY 
a7a6						DMARK "FRG" 
a7a6 f5				push af  
a7a7 3a bb a7			ld a, (.dmark)  
a7aa 32 7a ee			ld (debug_mark),a  
a7ad 3a bc a7			ld a, (.dmark+1)  
a7b0 32 7b ee			ld (debug_mark+1),a  
a7b3 3a bd a7			ld a, (.dmark+2)  
a7b6 32 7c ee			ld (debug_mark+2),a  
a7b9 18 03			jr .pastdmark  
a7bb ..			.dmark: db "FRG"  
a7be f1			.pastdmark: pop af  
a7bf			endm  
# End of macro DMARK
a7bf						CALLMONITOR 
a7bf cd 6c 93			call break_point_state  
a7c2				endm  
# End of macro CALLMONITOR
a7c2					endif 
a7c2			 
a7c2				; find uword 
a7c2			        ; update start of word with "_" 
a7c2				; replace uword with deleted flag 
a7c2			 
a7c2			 
a7c2			;	if DEBUG_FORTH_WORDS 
a7c2			;		DMARK "FOG" 
a7c2			;		CALLMONITOR 
a7c2			;	endif 
a7c2			 
a7c2			 
a7c2					; Get ptr to the word we need to look up 
a7c2			 
a7c2					FORTH_DSP_VALUEHL 
a7c2 cd f0 9a			call macro_dsp_valuehl 
a7c5				endm 
# End of macro FORTH_DSP_VALUEHL
a7c5					;v5 FORTH_DSP_VALUE 
a7c5				; TODO type check 
a7c5			;		inc hl    ; Skip type check  
a7c5 e5					push hl 
a7c6 c1					pop bc 
a7c7			;		ex de, hl    ; put into DE 
a7c7			 
a7c7			 
a7c7 21 df d7				ld hl, baseram 
a7ca					;ld hl, baseusermem 
a7ca			 
a7ca				; skip dict stub 
a7ca			;	call forth_tok_next 
a7ca e5			push hl   ; sacreifical push 
a7cb			 
a7cb			.fldouscanm: 
a7cb e1				pop hl 
a7cc			.fldouscan: 
a7cc			;	if DEBUG_FORTH_WORDS 
a7cc			;		DMARK "LSs" 
a7cc			;		CALLMONITOR 
a7cc			;	endif 
a7cc				; skip dict stub 
a7cc cd b3 9d				call forth_tok_next 
a7cf			 
a7cf			 
a7cf			; while we have words to look for 
a7cf			 
a7cf 7e				ld a, (hl)      
a7d0			;	if DEBUG_FORTH_WORDS 
a7d0			;		DMARK "LSk" 
a7d0			;		CALLMONITOR 
a7d0			;	endif 
a7d0 fe 00				cp WORD_SYS_END 
a7d2 ca 0e a8				jp z, .flunotfound 
a7d5 fe 01				cp WORD_SYS_UWORD 
a7d7 c2 cc a7				jp nz, .fldouscan 
a7da			 
a7da			;	if DEBUG_FORTH_WORDS 
a7da			;		DMARK "LSu" 
a7da			;		CALLMONITOR 
a7da			;	endif 
a7da			 
a7da					; found a uword but is it the one we want... 
a7da			 
a7da c5					push bc     ; uword to find is on bc 
a7db d1					pop de 
a7dc			 
a7dc e5					push hl  ; to save the ptr 
a7dd			 
a7dd					; skip opcode 
a7dd 23					inc hl  
a7de					; skip next ptr 
a7de 23					inc hl  
a7df 23					inc hl 
a7e0					; skip len 
a7e0 23					inc hl 
a7e1			 
a7e1			;	if DEBUG_FORTH_WORDS 
a7e1			;		DMARK "LSc" 
a7e1			;		CALLMONITOR 
a7e1			;	endif 
a7e1 cd 54 8f				call strcmp 
a7e4 c2 cb a7				jp nz, .fldouscanm 
a7e7			; 
a7e7			; 
a7e7			;; while we have words to look for 
a7e7			; 
a7e7			;.fdouscan:	ld a, (hl)      
a7e7			;	if DEBUG_FORTH_WORDS 
a7e7			;		DMARK "LSs" 
a7e7			;		CALLMONITOR 
a7e7			;	endif 
a7e7			;		cp WORD_SYS_END 
a7e7			;		jp z, .fudone 
a7e7			;		cp WORD_SYS_UWORD 
a7e7			;		jp nz, .fnuword 
a7e7			; 
a7e7			;	if DEBUG_FORTH_WORDS 
a7e7			;		DMARK "FGu" 
a7e7			;		CALLMONITOR 
a7e7			;	endif 
a7e7			; 
a7e7			;		; found a uword but is it the one we want... 
a7e7			; 
a7e7			; 
a7e7			;	        pop de   ; get back the dsp name 
a7e7			;		push de 
a7e7			; 
a7e7			;		push hl  ; to save the ptr 
a7e7			; 
a7e7			;		; skip opcode 
a7e7			;		inc hl  
a7e7			;		; skip next ptr 
a7e7			;		inc hl  
a7e7			;		inc hl 
a7e7			;		; skip len 
a7e7			;		inc hl 
a7e7			; 
a7e7			;	if DEBUG_FORTH_WORDS 
a7e7			;		DMARK "FGc" 
a7e7			;		CALLMONITOR 
a7e7			;	endif 
a7e7			;		call strcmp 
a7e7			;		jp nz, .fnuword 
a7e7			 
a7e7			 
a7e7 e1			pop hl 
a7e8			 
a7e8				 
a7e8				if DEBUG_FORTH_WORDS 
a7e8					DMARK "FGm" 
a7e8 f5				push af  
a7e9 3a fd a7			ld a, (.dmark)  
a7ec 32 7a ee			ld (debug_mark),a  
a7ef 3a fe a7			ld a, (.dmark+1)  
a7f2 32 7b ee			ld (debug_mark+1),a  
a7f5 3a ff a7			ld a, (.dmark+2)  
a7f8 32 7c ee			ld (debug_mark+2),a  
a7fb 18 03			jr .pastdmark  
a7fd ..			.dmark: db "FGm"  
a800 f1			.pastdmark: pop af  
a801			endm  
# End of macro DMARK
a801					CALLMONITOR 
a801 cd 6c 93			call break_point_state  
a804				endm  
# End of macro CALLMONITOR
a804				endif 
a804			 
a804			 
a804			 
a804					; we have a uword so push its name to the stack 
a804			 
a804			;	   	push hl  ; save so we can move to next dict block 
a804			;pop hl 
a804			 
a804					; update opcode to deleted 
a804 3e 03				ld a, WORD_SYS_DELETED 
a806 77					ld (hl), a 
a807			 
a807 23					inc hl  
a808					; skip next ptr 
a808 23					inc hl  
a809 23					inc hl 
a80a					; skip len 
a80a 23					inc hl 
a80b			 
a80b					; TODO change parser to skip deleted words but for now mark it out 
a80b 3e 5f				ld a, "_" 
a80d 77					ld  (hl),a 
a80e			 
a80e			;		jr .fudone 
a80e			; 
a80e			;.fnuword:	pop hl 
a80e			;		call forth_tok_next 
a80e			;		jp .fdouscan  
a80e			 
a80e			.flunotfound:		  
a80e			 
a80e			 
a80e					 
a80e					FORTH_DSP_POP 
a80e cd a8 9b			call macro_forth_dsp_pop 
a811				endm 
# End of macro FORTH_DSP_POP
a811			;		ld hl, .luno 
a811			;.fudone:		 pop hl 
a811					NEXTW 
a811 c3 62 9c			jp macro_next 
a814				endm 
# End of macro NEXTW
a814			.NOP: 
a814				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
a814 61				db WORD_SYS_CORE+77             
a815 3b a8			dw .COMO            
a817 04				db 3 + 1 
a818 .. 00			db "NOP",0              
a81c				endm 
# End of macro CWHEAD
a81c			; | NOP (  --  ) Do nothing | DONE 
a81c					if DEBUG_FORTH_WORDS_KEY 
a81c						DMARK "NOP" 
a81c f5				push af  
a81d 3a 31 a8			ld a, (.dmark)  
a820 32 7a ee			ld (debug_mark),a  
a823 3a 32 a8			ld a, (.dmark+1)  
a826 32 7b ee			ld (debug_mark+1),a  
a829 3a 33 a8			ld a, (.dmark+2)  
a82c 32 7c ee			ld (debug_mark+2),a  
a82f 18 03			jr .pastdmark  
a831 ..			.dmark: db "NOP"  
a834 f1			.pastdmark: pop af  
a835			endm  
# End of macro DMARK
a835						CALLMONITOR 
a835 cd 6c 93			call break_point_state  
a838				endm  
# End of macro CALLMONITOR
a838					endif 
a838				       NEXTW 
a838 c3 62 9c			jp macro_next 
a83b				endm 
# End of macro NEXTW
a83b			.COMO: 
a83b				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
a83b 6e				db WORD_SYS_CORE+90             
a83c 8d a8			dw .COMC            
a83e 02				db 1 + 1 
a83f .. 00			db "(",0              
a841				endm 
# End of macro CWHEAD
a841			; | ( ( -- )  Start of comment | DONE 
a841			 
a841			 
a841 2a 61 e6				ld hl, ( os_tok_ptr) 
a844 11 88 a8			ld de, .closepar 
a847					 
a847					if DEBUG_FORTH_WORDS 
a847						DMARK ").." 
a847 f5				push af  
a848 3a 5c a8			ld a, (.dmark)  
a84b 32 7a ee			ld (debug_mark),a  
a84e 3a 5d a8			ld a, (.dmark+1)  
a851 32 7b ee			ld (debug_mark+1),a  
a854 3a 5e a8			ld a, (.dmark+2)  
a857 32 7c ee			ld (debug_mark+2),a  
a85a 18 03			jr .pastdmark  
a85c ..			.dmark: db ").."  
a85f f1			.pastdmark: pop af  
a860			endm  
# End of macro DMARK
a860						CALLMONITOR 
a860 cd 6c 93			call break_point_state  
a863				endm  
# End of macro CALLMONITOR
a863					endif 
a863 cd 7d 9d			call findnexttok  
a866			 
a866					if DEBUG_FORTH_WORDS 
a866						DMARK "IF5" 
a866 f5				push af  
a867 3a 7b a8			ld a, (.dmark)  
a86a 32 7a ee			ld (debug_mark),a  
a86d 3a 7c a8			ld a, (.dmark+1)  
a870 32 7b ee			ld (debug_mark+1),a  
a873 3a 7d a8			ld a, (.dmark+2)  
a876 32 7c ee			ld (debug_mark+2),a  
a879 18 03			jr .pastdmark  
a87b ..			.dmark: db "IF5"  
a87e f1			.pastdmark: pop af  
a87f			endm  
# End of macro DMARK
a87f						CALLMONITOR 
a87f cd 6c 93			call break_point_state  
a882				endm  
# End of macro CALLMONITOR
a882					endif 
a882				; replace below with ) exec using tok_ptr 
a882 22 61 e6			ld (os_tok_ptr), hl 
a885 c3 f3 9c			jp exec1 
a888			 
a888 .. 00			.closepar:   db ")",0 
a88a			 
a88a				       NEXTW 
a88a c3 62 9c			jp macro_next 
a88d				endm 
# End of macro NEXTW
a88d			.COMC: 
a88d				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
a88d 6f				db WORD_SYS_CORE+91             
a88e 96 a8			dw .SCRATCH            
a890 02				db 1 + 1 
a891 .. 00			db ")",0              
a893				endm 
# End of macro CWHEAD
a893			; | ) ( -- )  End of comment |  DONE  
a893				       NEXTW 
a893 c3 62 9c			jp macro_next 
a896				endm 
# End of macro NEXTW
a896			 
a896			.SCRATCH: 
a896				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
a896 6f				db WORD_SYS_CORE+91             
a897 d1 a8			dw .INC            
a899 08				db 7 + 1 
a89a .. 00			db "SCRATCH",0              
a8a2				endm 
# End of macro CWHEAD
a8a2			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
a8a2			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
a8a2			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
a8a2			; | |  
a8a2			; | | e.g.    : score $00 scratch ; 
a8a2			; | |  
a8a2			; | | $00 score ! 
a8a2			; | | $01 score +! 
a8a2			; | |  
a8a2			; | | e.g.   : varword $0a scratch ;  
a8a2			; | | 
a8a2			; | | $8000 varword ! 
a8a2					if DEBUG_FORTH_WORDS_KEY 
a8a2						DMARK "SCR" 
a8a2 f5				push af  
a8a3 3a b7 a8			ld a, (.dmark)  
a8a6 32 7a ee			ld (debug_mark),a  
a8a9 3a b8 a8			ld a, (.dmark+1)  
a8ac 32 7b ee			ld (debug_mark+1),a  
a8af 3a b9 a8			ld a, (.dmark+2)  
a8b2 32 7c ee			ld (debug_mark+2),a  
a8b5 18 03			jr .pastdmark  
a8b7 ..			.dmark: db "SCR"  
a8ba f1			.pastdmark: pop af  
a8bb			endm  
# End of macro DMARK
a8bb						CALLMONITOR 
a8bb cd 6c 93			call break_point_state  
a8be				endm  
# End of macro CALLMONITOR
a8be					endif 
a8be			 
a8be					FORTH_DSP_VALUEHL 
a8be cd f0 9a			call macro_dsp_valuehl 
a8c1				endm 
# End of macro FORTH_DSP_VALUEHL
a8c1				 
a8c1					FORTH_DSP_POP 
a8c1 cd a8 9b			call macro_forth_dsp_pop 
a8c4				endm 
# End of macro FORTH_DSP_POP
a8c4			 
a8c4 7d					ld a, l 
a8c5 21 85 e8				ld hl, os_var_array 
a8c8 cd be 8a				call addatohl 
a8cb			 
a8cb cd f9 98				call forth_push_numhl 
a8ce			 
a8ce				       NEXTW 
a8ce c3 62 9c			jp macro_next 
a8d1				endm 
# End of macro NEXTW
a8d1			 
a8d1			.INC: 
a8d1				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
a8d1 6f				db WORD_SYS_CORE+91             
a8d2 25 a9			dw .DEC            
a8d4 03				db 2 + 1 
a8d5 .. 00			db "+!",0              
a8d8				endm 
# End of macro CWHEAD
a8d8			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
a8d8					if DEBUG_FORTH_WORDS_KEY 
a8d8						DMARK "+s_" 
a8d8 f5				push af  
a8d9 3a ed a8			ld a, (.dmark)  
a8dc 32 7a ee			ld (debug_mark),a  
a8df 3a ee a8			ld a, (.dmark+1)  
a8e2 32 7b ee			ld (debug_mark+1),a  
a8e5 3a ef a8			ld a, (.dmark+2)  
a8e8 32 7c ee			ld (debug_mark+2),a  
a8eb 18 03			jr .pastdmark  
a8ed ..			.dmark: db "+s_"  
a8f0 f1			.pastdmark: pop af  
a8f1			endm  
# End of macro DMARK
a8f1						CALLMONITOR 
a8f1 cd 6c 93			call break_point_state  
a8f4				endm  
# End of macro CALLMONITOR
a8f4					endif 
a8f4			 
a8f4					FORTH_DSP_VALUEHL 
a8f4 cd f0 9a			call macro_dsp_valuehl 
a8f7				endm 
# End of macro FORTH_DSP_VALUEHL
a8f7			 
a8f7 e5					push hl   ; save address 
a8f8			 
a8f8					FORTH_DSP_POP 
a8f8 cd a8 9b			call macro_forth_dsp_pop 
a8fb				endm 
# End of macro FORTH_DSP_POP
a8fb			 
a8fb					FORTH_DSP_VALUEHL 
a8fb cd f0 9a			call macro_dsp_valuehl 
a8fe				endm 
# End of macro FORTH_DSP_VALUEHL
a8fe			 
a8fe					FORTH_DSP_POP 
a8fe cd a8 9b			call macro_forth_dsp_pop 
a901				endm 
# End of macro FORTH_DSP_POP
a901			 
a901					; hl contains value to add to byte at a 
a901				 
a901 eb					ex de, hl 
a902			 
a902 e1					pop hl 
a903			 
a903					if DEBUG_FORTH_WORDS 
a903						DMARK "INC" 
a903 f5				push af  
a904 3a 18 a9			ld a, (.dmark)  
a907 32 7a ee			ld (debug_mark),a  
a90a 3a 19 a9			ld a, (.dmark+1)  
a90d 32 7b ee			ld (debug_mark+1),a  
a910 3a 1a a9			ld a, (.dmark+2)  
a913 32 7c ee			ld (debug_mark+2),a  
a916 18 03			jr .pastdmark  
a918 ..			.dmark: db "INC"  
a91b f1			.pastdmark: pop af  
a91c			endm  
# End of macro DMARK
a91c						CALLMONITOR 
a91c cd 6c 93			call break_point_state  
a91f				endm  
# End of macro CALLMONITOR
a91f					endif 
a91f			 
a91f 7e					ld a,(hl) 
a920 83					add e 
a921 77					ld (hl),a 
a922			 
a922			 
a922			 
a922				       NEXTW 
a922 c3 62 9c			jp macro_next 
a925				endm 
# End of macro NEXTW
a925			 
a925			.DEC: 
a925				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
a925 6f				db WORD_SYS_CORE+91             
a926 76 a9			dw .INC2            
a928 03				db 2 + 1 
a929 .. 00			db "-!",0              
a92c				endm 
# End of macro CWHEAD
a92c			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
a92c					if DEBUG_FORTH_WORDS_KEY 
a92c						DMARK "-s_" 
a92c f5				push af  
a92d 3a 41 a9			ld a, (.dmark)  
a930 32 7a ee			ld (debug_mark),a  
a933 3a 42 a9			ld a, (.dmark+1)  
a936 32 7b ee			ld (debug_mark+1),a  
a939 3a 43 a9			ld a, (.dmark+2)  
a93c 32 7c ee			ld (debug_mark+2),a  
a93f 18 03			jr .pastdmark  
a941 ..			.dmark: db "-s_"  
a944 f1			.pastdmark: pop af  
a945			endm  
# End of macro DMARK
a945						CALLMONITOR 
a945 cd 6c 93			call break_point_state  
a948				endm  
# End of macro CALLMONITOR
a948					endif 
a948			 
a948					FORTH_DSP_VALUEHL 
a948 cd f0 9a			call macro_dsp_valuehl 
a94b				endm 
# End of macro FORTH_DSP_VALUEHL
a94b			 
a94b e5					push hl   ; save address 
a94c			 
a94c					FORTH_DSP_POP 
a94c cd a8 9b			call macro_forth_dsp_pop 
a94f				endm 
# End of macro FORTH_DSP_POP
a94f			 
a94f					FORTH_DSP_VALUEHL 
a94f cd f0 9a			call macro_dsp_valuehl 
a952				endm 
# End of macro FORTH_DSP_VALUEHL
a952			 
a952					; hl contains value to add to byte at a 
a952				 
a952 eb					ex de, hl 
a953			 
a953 e1					pop hl 
a954			 
a954					if DEBUG_FORTH_WORDS 
a954						DMARK "DEC" 
a954 f5				push af  
a955 3a 69 a9			ld a, (.dmark)  
a958 32 7a ee			ld (debug_mark),a  
a95b 3a 6a a9			ld a, (.dmark+1)  
a95e 32 7b ee			ld (debug_mark+1),a  
a961 3a 6b a9			ld a, (.dmark+2)  
a964 32 7c ee			ld (debug_mark+2),a  
a967 18 03			jr .pastdmark  
a969 ..			.dmark: db "DEC"  
a96c f1			.pastdmark: pop af  
a96d			endm  
# End of macro DMARK
a96d						CALLMONITOR 
a96d cd 6c 93			call break_point_state  
a970				endm  
# End of macro CALLMONITOR
a970					endif 
a970			 
a970 7e					ld a,(hl) 
a971 93					sub e 
a972 77					ld (hl),a 
a973			 
a973			 
a973			 
a973				       NEXTW 
a973 c3 62 9c			jp macro_next 
a976				endm 
# End of macro NEXTW
a976			 
a976			.INC2: 
a976				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
a976 6f				db WORD_SYS_CORE+91             
a977 20 aa			dw .DEC2            
a979 04				db 3 + 1 
a97a .. 00			db "+2!",0              
a97e				endm 
# End of macro CWHEAD
a97e			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
a97e			 
a97e					if DEBUG_FORTH_WORDS_KEY 
a97e						DMARK "+2s" 
a97e f5				push af  
a97f 3a 93 a9			ld a, (.dmark)  
a982 32 7a ee			ld (debug_mark),a  
a985 3a 94 a9			ld a, (.dmark+1)  
a988 32 7b ee			ld (debug_mark+1),a  
a98b 3a 95 a9			ld a, (.dmark+2)  
a98e 32 7c ee			ld (debug_mark+2),a  
a991 18 03			jr .pastdmark  
a993 ..			.dmark: db "+2s"  
a996 f1			.pastdmark: pop af  
a997			endm  
# End of macro DMARK
a997						CALLMONITOR 
a997 cd 6c 93			call break_point_state  
a99a				endm  
# End of macro CALLMONITOR
a99a					endif 
a99a			 
a99a					; Address 
a99a			 
a99a					FORTH_DSP_VALUEHL 
a99a cd f0 9a			call macro_dsp_valuehl 
a99d				endm 
# End of macro FORTH_DSP_VALUEHL
a99d			 
a99d e5					push hl    ; save address 
a99e			 
a99e					; load content into de 
a99e			 
a99e 5e					ld e,(hl) 
a99f 23					inc hl 
a9a0 56					ld d, (hl) 
a9a1			 
a9a1					if DEBUG_FORTH_WORDS 
a9a1						DMARK "+2a" 
a9a1 f5				push af  
a9a2 3a b6 a9			ld a, (.dmark)  
a9a5 32 7a ee			ld (debug_mark),a  
a9a8 3a b7 a9			ld a, (.dmark+1)  
a9ab 32 7b ee			ld (debug_mark+1),a  
a9ae 3a b8 a9			ld a, (.dmark+2)  
a9b1 32 7c ee			ld (debug_mark+2),a  
a9b4 18 03			jr .pastdmark  
a9b6 ..			.dmark: db "+2a"  
a9b9 f1			.pastdmark: pop af  
a9ba			endm  
# End of macro DMARK
a9ba						CALLMONITOR 
a9ba cd 6c 93			call break_point_state  
a9bd				endm  
# End of macro CALLMONITOR
a9bd					endif 
a9bd			 
a9bd					FORTH_DSP_POP 
a9bd cd a8 9b			call macro_forth_dsp_pop 
a9c0				endm 
# End of macro FORTH_DSP_POP
a9c0			 
a9c0					; Get value to add 
a9c0			 
a9c0					FORTH_DSP_VALUE 
a9c0 cd d9 9a			call macro_forth_dsp_value 
a9c3				endm 
# End of macro FORTH_DSP_VALUE
a9c3			 
a9c3					if DEBUG_FORTH_WORDS 
a9c3						DMARK "+2v" 
a9c3 f5				push af  
a9c4 3a d8 a9			ld a, (.dmark)  
a9c7 32 7a ee			ld (debug_mark),a  
a9ca 3a d9 a9			ld a, (.dmark+1)  
a9cd 32 7b ee			ld (debug_mark+1),a  
a9d0 3a da a9			ld a, (.dmark+2)  
a9d3 32 7c ee			ld (debug_mark+2),a  
a9d6 18 03			jr .pastdmark  
a9d8 ..			.dmark: db "+2v"  
a9db f1			.pastdmark: pop af  
a9dc			endm  
# End of macro DMARK
a9dc						CALLMONITOR 
a9dc cd 6c 93			call break_point_state  
a9df				endm  
# End of macro CALLMONITOR
a9df					endif 
a9df			 
a9df 19					add hl, de 
a9e0			 
a9e0					if DEBUG_FORTH_WORDS 
a9e0						DMARK "+2+" 
a9e0 f5				push af  
a9e1 3a f5 a9			ld a, (.dmark)  
a9e4 32 7a ee			ld (debug_mark),a  
a9e7 3a f6 a9			ld a, (.dmark+1)  
a9ea 32 7b ee			ld (debug_mark+1),a  
a9ed 3a f7 a9			ld a, (.dmark+2)  
a9f0 32 7c ee			ld (debug_mark+2),a  
a9f3 18 03			jr .pastdmark  
a9f5 ..			.dmark: db "+2+"  
a9f8 f1			.pastdmark: pop af  
a9f9			endm  
# End of macro DMARK
a9f9						CALLMONITOR 
a9f9 cd 6c 93			call break_point_state  
a9fc				endm  
# End of macro CALLMONITOR
a9fc					endif 
a9fc			 
a9fc					; move result to de 
a9fc			 
a9fc eb					ex de, hl 
a9fd			 
a9fd					; Address 
a9fd			 
a9fd e1					pop hl 
a9fe			 
a9fe					; save it back 
a9fe			 
a9fe 73					ld (hl), e 
a9ff 23					inc hl 
aa00 72					ld (hl), d 
aa01			 
aa01					if DEBUG_FORTH_WORDS 
aa01						DMARK "+2e" 
aa01 f5				push af  
aa02 3a 16 aa			ld a, (.dmark)  
aa05 32 7a ee			ld (debug_mark),a  
aa08 3a 17 aa			ld a, (.dmark+1)  
aa0b 32 7b ee			ld (debug_mark+1),a  
aa0e 3a 18 aa			ld a, (.dmark+2)  
aa11 32 7c ee			ld (debug_mark+2),a  
aa14 18 03			jr .pastdmark  
aa16 ..			.dmark: db "+2e"  
aa19 f1			.pastdmark: pop af  
aa1a			endm  
# End of macro DMARK
aa1a						CALLMONITOR 
aa1a cd 6c 93			call break_point_state  
aa1d				endm  
# End of macro CALLMONITOR
aa1d					endif 
aa1d			 
aa1d			 
aa1d			 
aa1d			 
aa1d			 
aa1d				       NEXTW 
aa1d c3 62 9c			jp macro_next 
aa20				endm 
# End of macro NEXTW
aa20			 
aa20			.DEC2: 
aa20				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
aa20 6f				db WORD_SYS_CORE+91             
aa21 cc aa			dw .GET2            
aa23 04				db 3 + 1 
aa24 .. 00			db "-2!",0              
aa28				endm 
# End of macro CWHEAD
aa28			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
aa28			 
aa28			 
aa28					if DEBUG_FORTH_WORDS_KEY 
aa28						DMARK "-2s" 
aa28 f5				push af  
aa29 3a 3d aa			ld a, (.dmark)  
aa2c 32 7a ee			ld (debug_mark),a  
aa2f 3a 3e aa			ld a, (.dmark+1)  
aa32 32 7b ee			ld (debug_mark+1),a  
aa35 3a 3f aa			ld a, (.dmark+2)  
aa38 32 7c ee			ld (debug_mark+2),a  
aa3b 18 03			jr .pastdmark  
aa3d ..			.dmark: db "-2s"  
aa40 f1			.pastdmark: pop af  
aa41			endm  
# End of macro DMARK
aa41						CALLMONITOR 
aa41 cd 6c 93			call break_point_state  
aa44				endm  
# End of macro CALLMONITOR
aa44					endif 
aa44			 
aa44					; Address 
aa44			 
aa44					FORTH_DSP_VALUEHL 
aa44 cd f0 9a			call macro_dsp_valuehl 
aa47				endm 
# End of macro FORTH_DSP_VALUEHL
aa47			 
aa47 e5					push hl    ; save address 
aa48			 
aa48					; load content into de 
aa48			 
aa48 5e					ld e,(hl) 
aa49 23					inc hl 
aa4a 56					ld d, (hl) 
aa4b			 
aa4b					if DEBUG_FORTH_WORDS 
aa4b						DMARK "-2a" 
aa4b f5				push af  
aa4c 3a 60 aa			ld a, (.dmark)  
aa4f 32 7a ee			ld (debug_mark),a  
aa52 3a 61 aa			ld a, (.dmark+1)  
aa55 32 7b ee			ld (debug_mark+1),a  
aa58 3a 62 aa			ld a, (.dmark+2)  
aa5b 32 7c ee			ld (debug_mark+2),a  
aa5e 18 03			jr .pastdmark  
aa60 ..			.dmark: db "-2a"  
aa63 f1			.pastdmark: pop af  
aa64			endm  
# End of macro DMARK
aa64						CALLMONITOR 
aa64 cd 6c 93			call break_point_state  
aa67				endm  
# End of macro CALLMONITOR
aa67					endif 
aa67			 
aa67					FORTH_DSP_POP 
aa67 cd a8 9b			call macro_forth_dsp_pop 
aa6a				endm 
# End of macro FORTH_DSP_POP
aa6a			 
aa6a					; Get value to remove 
aa6a			 
aa6a					FORTH_DSP_VALUE 
aa6a cd d9 9a			call macro_forth_dsp_value 
aa6d				endm 
# End of macro FORTH_DSP_VALUE
aa6d			 
aa6d					if DEBUG_FORTH_WORDS 
aa6d						DMARK "-2v" 
aa6d f5				push af  
aa6e 3a 82 aa			ld a, (.dmark)  
aa71 32 7a ee			ld (debug_mark),a  
aa74 3a 83 aa			ld a, (.dmark+1)  
aa77 32 7b ee			ld (debug_mark+1),a  
aa7a 3a 84 aa			ld a, (.dmark+2)  
aa7d 32 7c ee			ld (debug_mark+2),a  
aa80 18 03			jr .pastdmark  
aa82 ..			.dmark: db "-2v"  
aa85 f1			.pastdmark: pop af  
aa86			endm  
# End of macro DMARK
aa86						CALLMONITOR 
aa86 cd 6c 93			call break_point_state  
aa89				endm  
# End of macro CALLMONITOR
aa89					endif 
aa89			 
aa89 eb					ex de, hl 
aa8a ed 52				sbc hl, de 
aa8c			 
aa8c					if DEBUG_FORTH_WORDS 
aa8c						DMARK "-2d" 
aa8c f5				push af  
aa8d 3a a1 aa			ld a, (.dmark)  
aa90 32 7a ee			ld (debug_mark),a  
aa93 3a a2 aa			ld a, (.dmark+1)  
aa96 32 7b ee			ld (debug_mark+1),a  
aa99 3a a3 aa			ld a, (.dmark+2)  
aa9c 32 7c ee			ld (debug_mark+2),a  
aa9f 18 03			jr .pastdmark  
aaa1 ..			.dmark: db "-2d"  
aaa4 f1			.pastdmark: pop af  
aaa5			endm  
# End of macro DMARK
aaa5						CALLMONITOR 
aaa5 cd 6c 93			call break_point_state  
aaa8				endm  
# End of macro CALLMONITOR
aaa8					endif 
aaa8			 
aaa8					; move result to de 
aaa8			 
aaa8 eb					ex de, hl 
aaa9			 
aaa9					; Address 
aaa9			 
aaa9 e1					pop hl 
aaaa			 
aaaa					; save it back 
aaaa			 
aaaa 73					ld (hl), e 
aaab 23					inc hl 
aaac 72					ld (hl), d 
aaad			 
aaad					if DEBUG_FORTH_WORDS 
aaad						DMARK "-2e" 
aaad f5				push af  
aaae 3a c2 aa			ld a, (.dmark)  
aab1 32 7a ee			ld (debug_mark),a  
aab4 3a c3 aa			ld a, (.dmark+1)  
aab7 32 7b ee			ld (debug_mark+1),a  
aaba 3a c4 aa			ld a, (.dmark+2)  
aabd 32 7c ee			ld (debug_mark+2),a  
aac0 18 03			jr .pastdmark  
aac2 ..			.dmark: db "-2e"  
aac5 f1			.pastdmark: pop af  
aac6			endm  
# End of macro DMARK
aac6						CALLMONITOR 
aac6 cd 6c 93			call break_point_state  
aac9				endm  
# End of macro CALLMONITOR
aac9					endif 
aac9			 
aac9			 
aac9			 
aac9			 
aac9			 
aac9				       NEXTW 
aac9 c3 62 9c			jp macro_next 
aacc				endm 
# End of macro NEXTW
aacc			.GET2: 
aacc				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
aacc 6f				db WORD_SYS_CORE+91             
aacd fc aa			dw .BANG2            
aacf 03				db 2 + 1 
aad0 .. 00			db "2@",0              
aad3				endm 
# End of macro CWHEAD
aad3			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
aad3					if DEBUG_FORTH_WORDS_KEY 
aad3						DMARK "2A_" 
aad3 f5				push af  
aad4 3a e8 aa			ld a, (.dmark)  
aad7 32 7a ee			ld (debug_mark),a  
aada 3a e9 aa			ld a, (.dmark+1)  
aadd 32 7b ee			ld (debug_mark+1),a  
aae0 3a ea aa			ld a, (.dmark+2)  
aae3 32 7c ee			ld (debug_mark+2),a  
aae6 18 03			jr .pastdmark  
aae8 ..			.dmark: db "2A_"  
aaeb f1			.pastdmark: pop af  
aaec			endm  
# End of macro DMARK
aaec						CALLMONITOR 
aaec cd 6c 93			call break_point_state  
aaef				endm  
# End of macro CALLMONITOR
aaef					endif 
aaef			 
aaef					FORTH_DSP_VALUEHL 
aaef cd f0 9a			call macro_dsp_valuehl 
aaf2				endm 
# End of macro FORTH_DSP_VALUEHL
aaf2			 
aaf2 5e					ld e, (hl) 
aaf3 23					inc hl 
aaf4 56					ld d, (hl) 
aaf5			 
aaf5 eb					ex de, hl 
aaf6			 
aaf6 cd f9 98				call forth_push_numhl 
aaf9			 
aaf9				       NEXTW 
aaf9 c3 62 9c			jp macro_next 
aafc				endm 
# End of macro NEXTW
aafc			.BANG2: 
aafc				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
aafc 6f				db WORD_SYS_CORE+91             
aafd 34 ab			dw .CONFIG            
aaff 03				db 2 + 1 
ab00 .. 00			db "2!",0              
ab03				endm 
# End of macro CWHEAD
ab03			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
ab03					if DEBUG_FORTH_WORDS_KEY 
ab03						DMARK "2S_" 
ab03 f5				push af  
ab04 3a 18 ab			ld a, (.dmark)  
ab07 32 7a ee			ld (debug_mark),a  
ab0a 3a 19 ab			ld a, (.dmark+1)  
ab0d 32 7b ee			ld (debug_mark+1),a  
ab10 3a 1a ab			ld a, (.dmark+2)  
ab13 32 7c ee			ld (debug_mark+2),a  
ab16 18 03			jr .pastdmark  
ab18 ..			.dmark: db "2S_"  
ab1b f1			.pastdmark: pop af  
ab1c			endm  
# End of macro DMARK
ab1c						CALLMONITOR 
ab1c cd 6c 93			call break_point_state  
ab1f				endm  
# End of macro CALLMONITOR
ab1f					endif 
ab1f			 
ab1f					FORTH_DSP_VALUEHL 
ab1f cd f0 9a			call macro_dsp_valuehl 
ab22				endm 
# End of macro FORTH_DSP_VALUEHL
ab22			 
ab22 e5					push hl   ; save address 
ab23			 
ab23			 
ab23					FORTH_DSP_POP 
ab23 cd a8 9b			call macro_forth_dsp_pop 
ab26				endm 
# End of macro FORTH_DSP_POP
ab26			 
ab26					 
ab26					FORTH_DSP_VALUEHL 
ab26 cd f0 9a			call macro_dsp_valuehl 
ab29				endm 
# End of macro FORTH_DSP_VALUEHL
ab29			 
ab29					FORTH_DSP_POP 
ab29 cd a8 9b			call macro_forth_dsp_pop 
ab2c				endm 
# End of macro FORTH_DSP_POP
ab2c			 
ab2c eb					ex de, hl    ; value now in de 
ab2d			 
ab2d e1					pop hl 
ab2e			 
ab2e 73					ld (hl), e 
ab2f			 
ab2f 23					inc hl 
ab30			 
ab30 72					ld (hl), d 
ab31			 
ab31			 
ab31				       NEXTW 
ab31 c3 62 9c			jp macro_next 
ab34				endm 
# End of macro NEXTW
ab34			.CONFIG: 
ab34				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
ab34 6f				db WORD_SYS_CORE+91             
ab35 45 ab			dw .ENDCORE            
ab37 07				db 6 + 1 
ab38 .. 00			db "CONFIG",0              
ab3f				endm 
# End of macro CWHEAD
ab3f			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
ab3f			 
ab3f cd 1e 91				call config 
ab42					NEXTW 
ab42 c3 62 9c			jp macro_next 
ab45				endm 
# End of macro NEXTW
ab45			.ENDCORE: 
ab45			 
ab45			; eof 
ab45			 
ab45			 
# End of file forth_words_core.asm
ab45			include "forth_words_flow.asm" 
ab45			 
ab45			; | ## Program Flow Words 
ab45			 
ab45			.IF: 
ab45				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
ab45 1e				db WORD_SYS_CORE+10             
ab46 3a ac			dw .THEN            
ab48 03				db 2 + 1 
ab49 .. 00			db "IF",0              
ab4c				endm 
# End of macro CWHEAD
ab4c			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
ab4c			; 
ab4c					if DEBUG_FORTH_WORDS_KEY 
ab4c						DMARK "IF." 
ab4c f5				push af  
ab4d 3a 61 ab			ld a, (.dmark)  
ab50 32 7a ee			ld (debug_mark),a  
ab53 3a 62 ab			ld a, (.dmark+1)  
ab56 32 7b ee			ld (debug_mark+1),a  
ab59 3a 63 ab			ld a, (.dmark+2)  
ab5c 32 7c ee			ld (debug_mark+2),a  
ab5f 18 03			jr .pastdmark  
ab61 ..			.dmark: db "IF."  
ab64 f1			.pastdmark: pop af  
ab65			endm  
# End of macro DMARK
ab65						CALLMONITOR 
ab65 cd 6c 93			call break_point_state  
ab68				endm  
# End of macro CALLMONITOR
ab68					endif 
ab68			; eval TOS 
ab68			 
ab68				FORTH_DSP_VALUEHL 
ab68 cd f0 9a			call macro_dsp_valuehl 
ab6b				endm 
# End of macro FORTH_DSP_VALUEHL
ab6b			 
ab6b			;	push hl 
ab6b				FORTH_DSP_POP 
ab6b cd a8 9b			call macro_forth_dsp_pop 
ab6e				endm 
# End of macro FORTH_DSP_POP
ab6e			;	pop hl 
ab6e			 
ab6e					if DEBUG_FORTH_WORDS 
ab6e						DMARK "IF1" 
ab6e f5				push af  
ab6f 3a 83 ab			ld a, (.dmark)  
ab72 32 7a ee			ld (debug_mark),a  
ab75 3a 84 ab			ld a, (.dmark+1)  
ab78 32 7b ee			ld (debug_mark+1),a  
ab7b 3a 85 ab			ld a, (.dmark+2)  
ab7e 32 7c ee			ld (debug_mark+2),a  
ab81 18 03			jr .pastdmark  
ab83 ..			.dmark: db "IF1"  
ab86 f1			.pastdmark: pop af  
ab87			endm  
# End of macro DMARK
ab87						CALLMONITOR 
ab87 cd 6c 93			call break_point_state  
ab8a				endm  
# End of macro CALLMONITOR
ab8a					endif 
ab8a b7				or a        ; clear carry flag 
ab8b 11 00 00			ld de, 0 
ab8e eb				ex de,hl 
ab8f ed 52			sbc hl, de 
ab91 c2 1b ac			jp nz, .iftrue 
ab94			 
ab94					if DEBUG_FORTH_WORDS 
ab94						DMARK "IF2" 
ab94 f5				push af  
ab95 3a a9 ab			ld a, (.dmark)  
ab98 32 7a ee			ld (debug_mark),a  
ab9b 3a aa ab			ld a, (.dmark+1)  
ab9e 32 7b ee			ld (debug_mark+1),a  
aba1 3a ab ab			ld a, (.dmark+2)  
aba4 32 7c ee			ld (debug_mark+2),a  
aba7 18 03			jr .pastdmark  
aba9 ..			.dmark: db "IF2"  
abac f1			.pastdmark: pop af  
abad			endm  
# End of macro DMARK
abad						CALLMONITOR 
abad cd 6c 93			call break_point_state  
abb0				endm  
# End of macro CALLMONITOR
abb0					endif 
abb0			 
abb0			; if not true then skip to THEN 
abb0			 
abb0				; TODO get tok_ptr 
abb0				; TODO consume toks until we get to THEN 
abb0			 
abb0 2a 61 e6			ld hl, (os_tok_ptr) 
abb3					if DEBUG_FORTH_WORDS 
abb3						DMARK "IF3" 
abb3 f5				push af  
abb4 3a c8 ab			ld a, (.dmark)  
abb7 32 7a ee			ld (debug_mark),a  
abba 3a c9 ab			ld a, (.dmark+1)  
abbd 32 7b ee			ld (debug_mark+1),a  
abc0 3a ca ab			ld a, (.dmark+2)  
abc3 32 7c ee			ld (debug_mark+2),a  
abc6 18 03			jr .pastdmark  
abc8 ..			.dmark: db "IF3"  
abcb f1			.pastdmark: pop af  
abcc			endm  
# End of macro DMARK
abcc						CALLMONITOR 
abcc cd 6c 93			call break_point_state  
abcf				endm  
# End of macro CALLMONITOR
abcf						 
abcf					endif 
abcf 11 16 ac			ld de, .ifthen 
abd2					if DEBUG_FORTH_WORDS 
abd2						DMARK "IF4" 
abd2 f5				push af  
abd3 3a e7 ab			ld a, (.dmark)  
abd6 32 7a ee			ld (debug_mark),a  
abd9 3a e8 ab			ld a, (.dmark+1)  
abdc 32 7b ee			ld (debug_mark+1),a  
abdf 3a e9 ab			ld a, (.dmark+2)  
abe2 32 7c ee			ld (debug_mark+2),a  
abe5 18 03			jr .pastdmark  
abe7 ..			.dmark: db "IF4"  
abea f1			.pastdmark: pop af  
abeb			endm  
# End of macro DMARK
abeb						CALLMONITOR 
abeb cd 6c 93			call break_point_state  
abee				endm  
# End of macro CALLMONITOR
abee					endif 
abee cd 7d 9d			call findnexttok  
abf1			 
abf1					if DEBUG_FORTH_WORDS 
abf1						DMARK "IF5" 
abf1 f5				push af  
abf2 3a 06 ac			ld a, (.dmark)  
abf5 32 7a ee			ld (debug_mark),a  
abf8 3a 07 ac			ld a, (.dmark+1)  
abfb 32 7b ee			ld (debug_mark+1),a  
abfe 3a 08 ac			ld a, (.dmark+2)  
ac01 32 7c ee			ld (debug_mark+2),a  
ac04 18 03			jr .pastdmark  
ac06 ..			.dmark: db "IF5"  
ac09 f1			.pastdmark: pop af  
ac0a			endm  
# End of macro DMARK
ac0a						CALLMONITOR 
ac0a cd 6c 93			call break_point_state  
ac0d				endm  
# End of macro CALLMONITOR
ac0d					endif 
ac0d				; TODO replace below with ; exec using tok_ptr 
ac0d 22 61 e6			ld (os_tok_ptr), hl 
ac10 c3 f3 9c			jp exec1 
ac13				NEXTW 
ac13 c3 62 9c			jp macro_next 
ac16				endm 
# End of macro NEXTW
ac16			 
ac16 .. 00		.ifthen:  db "THEN",0 
ac1b			 
ac1b			.iftrue:		 
ac1b				; Exec next words normally 
ac1b			 
ac1b				; if true then exec following IF as normal 
ac1b					if DEBUG_FORTH_WORDS 
ac1b						DMARK "IFT" 
ac1b f5				push af  
ac1c 3a 30 ac			ld a, (.dmark)  
ac1f 32 7a ee			ld (debug_mark),a  
ac22 3a 31 ac			ld a, (.dmark+1)  
ac25 32 7b ee			ld (debug_mark+1),a  
ac28 3a 32 ac			ld a, (.dmark+2)  
ac2b 32 7c ee			ld (debug_mark+2),a  
ac2e 18 03			jr .pastdmark  
ac30 ..			.dmark: db "IFT"  
ac33 f1			.pastdmark: pop af  
ac34			endm  
# End of macro DMARK
ac34						CALLMONITOR 
ac34 cd 6c 93			call break_point_state  
ac37				endm  
# End of macro CALLMONITOR
ac37					endif 
ac37			 
ac37					NEXTW 
ac37 c3 62 9c			jp macro_next 
ac3a				endm 
# End of macro NEXTW
ac3a			.THEN: 
ac3a				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
ac3a 1f				db WORD_SYS_CORE+11             
ac3b 62 ac			dw .ELSE            
ac3d 05				db 4 + 1 
ac3e .. 00			db "THEN",0              
ac43				endm 
# End of macro CWHEAD
ac43			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
ac43					if DEBUG_FORTH_WORDS_KEY 
ac43						DMARK "THN" 
ac43 f5				push af  
ac44 3a 58 ac			ld a, (.dmark)  
ac47 32 7a ee			ld (debug_mark),a  
ac4a 3a 59 ac			ld a, (.dmark+1)  
ac4d 32 7b ee			ld (debug_mark+1),a  
ac50 3a 5a ac			ld a, (.dmark+2)  
ac53 32 7c ee			ld (debug_mark+2),a  
ac56 18 03			jr .pastdmark  
ac58 ..			.dmark: db "THN"  
ac5b f1			.pastdmark: pop af  
ac5c			endm  
# End of macro DMARK
ac5c						CALLMONITOR 
ac5c cd 6c 93			call break_point_state  
ac5f				endm  
# End of macro CALLMONITOR
ac5f					endif 
ac5f					NEXTW 
ac5f c3 62 9c			jp macro_next 
ac62				endm 
# End of macro NEXTW
ac62			.ELSE: 
ac62				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
ac62 20				db WORD_SYS_CORE+12             
ac63 8a ac			dw .DO            
ac65 03				db 2 + 1 
ac66 .. 00			db "ELSE",0              
ac6b				endm 
# End of macro CWHEAD
ac6b			; | ELSE ( -- ) Not supported - does nothing | TODO 
ac6b			 
ac6b					if DEBUG_FORTH_WORDS_KEY 
ac6b						DMARK "ELS" 
ac6b f5				push af  
ac6c 3a 80 ac			ld a, (.dmark)  
ac6f 32 7a ee			ld (debug_mark),a  
ac72 3a 81 ac			ld a, (.dmark+1)  
ac75 32 7b ee			ld (debug_mark+1),a  
ac78 3a 82 ac			ld a, (.dmark+2)  
ac7b 32 7c ee			ld (debug_mark+2),a  
ac7e 18 03			jr .pastdmark  
ac80 ..			.dmark: db "ELS"  
ac83 f1			.pastdmark: pop af  
ac84			endm  
# End of macro DMARK
ac84						CALLMONITOR 
ac84 cd 6c 93			call break_point_state  
ac87				endm  
# End of macro CALLMONITOR
ac87					endif 
ac87			 
ac87			 
ac87					NEXTW 
ac87 c3 62 9c			jp macro_next 
ac8a				endm 
# End of macro NEXTW
ac8a			.DO: 
ac8a				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
ac8a 21				db WORD_SYS_CORE+13             
ac8b b1 ad			dw .LOOP            
ac8d 03				db 2 + 1 
ac8e .. 00			db "DO",0              
ac91				endm 
# End of macro CWHEAD
ac91			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
ac91			 
ac91					if DEBUG_FORTH_WORDS_KEY 
ac91						DMARK "DO." 
ac91 f5				push af  
ac92 3a a6 ac			ld a, (.dmark)  
ac95 32 7a ee			ld (debug_mark),a  
ac98 3a a7 ac			ld a, (.dmark+1)  
ac9b 32 7b ee			ld (debug_mark+1),a  
ac9e 3a a8 ac			ld a, (.dmark+2)  
aca1 32 7c ee			ld (debug_mark+2),a  
aca4 18 03			jr .pastdmark  
aca6 ..			.dmark: db "DO."  
aca9 f1			.pastdmark: pop af  
acaa			endm  
# End of macro DMARK
acaa						CALLMONITOR 
acaa cd 6c 93			call break_point_state  
acad				endm  
# End of macro CALLMONITOR
acad					endif 
acad			;  push pc to rsp stack past the DO 
acad			 
acad 2a 61 e6				ld hl, (os_tok_ptr) 
acb0 23					inc hl   ; D 
acb1 23					inc hl  ; O 
acb2 23					inc hl   ; null 
acb3					if DEBUG_FORTH_WORDS 
acb3						DMARK "DO2" 
acb3 f5				push af  
acb4 3a c8 ac			ld a, (.dmark)  
acb7 32 7a ee			ld (debug_mark),a  
acba 3a c9 ac			ld a, (.dmark+1)  
acbd 32 7b ee			ld (debug_mark+1),a  
acc0 3a ca ac			ld a, (.dmark+2)  
acc3 32 7c ee			ld (debug_mark+2),a  
acc6 18 03			jr .pastdmark  
acc8 ..			.dmark: db "DO2"  
accb f1			.pastdmark: pop af  
accc			endm  
# End of macro DMARK
accc						CALLMONITOR 
accc cd 6c 93			call break_point_state  
accf				endm  
# End of macro CALLMONITOR
accf					endif 
accf					FORTH_RSP_NEXT 
accf cd a0 98			call macro_forth_rsp_next 
acd2				endm 
# End of macro FORTH_RSP_NEXT
acd2					if DEBUG_FORTH_WORDS 
acd2						DMARK "DO3" 
acd2 f5				push af  
acd3 3a e7 ac			ld a, (.dmark)  
acd6 32 7a ee			ld (debug_mark),a  
acd9 3a e8 ac			ld a, (.dmark+1)  
acdc 32 7b ee			ld (debug_mark+1),a  
acdf 3a e9 ac			ld a, (.dmark+2)  
ace2 32 7c ee			ld (debug_mark+2),a  
ace5 18 03			jr .pastdmark  
ace7 ..			.dmark: db "DO3"  
acea f1			.pastdmark: pop af  
aceb			endm  
# End of macro DMARK
aceb						CALLMONITOR 
aceb cd 6c 93			call break_point_state  
acee				endm  
# End of macro CALLMONITOR
acee					endif 
acee			 
acee					;if DEBUG_FORTH_WORDS 
acee				;		push hl 
acee			;		endif  
acee			 
acee			; get counters from data stack 
acee			 
acee			 
acee					FORTH_DSP_VALUEHL 
acee cd f0 9a			call macro_dsp_valuehl 
acf1				endm 
# End of macro FORTH_DSP_VALUEHL
acf1 e5					push hl		 ; hl now has starting counter which needs to be tos 
acf2			 
acf2					if DEBUG_FORTH_WORDS 
acf2						DMARK "DO4" 
acf2 f5				push af  
acf3 3a 07 ad			ld a, (.dmark)  
acf6 32 7a ee			ld (debug_mark),a  
acf9 3a 08 ad			ld a, (.dmark+1)  
acfc 32 7b ee			ld (debug_mark+1),a  
acff 3a 09 ad			ld a, (.dmark+2)  
ad02 32 7c ee			ld (debug_mark+2),a  
ad05 18 03			jr .pastdmark  
ad07 ..			.dmark: db "DO4"  
ad0a f1			.pastdmark: pop af  
ad0b			endm  
# End of macro DMARK
ad0b						CALLMONITOR 
ad0b cd 6c 93			call break_point_state  
ad0e				endm  
# End of macro CALLMONITOR
ad0e					endif 
ad0e					FORTH_DSP_POP 
ad0e cd a8 9b			call macro_forth_dsp_pop 
ad11				endm 
# End of macro FORTH_DSP_POP
ad11			 
ad11					if DEBUG_FORTH_WORDS 
ad11						DMARK "DO5" 
ad11 f5				push af  
ad12 3a 26 ad			ld a, (.dmark)  
ad15 32 7a ee			ld (debug_mark),a  
ad18 3a 27 ad			ld a, (.dmark+1)  
ad1b 32 7b ee			ld (debug_mark+1),a  
ad1e 3a 28 ad			ld a, (.dmark+2)  
ad21 32 7c ee			ld (debug_mark+2),a  
ad24 18 03			jr .pastdmark  
ad26 ..			.dmark: db "DO5"  
ad29 f1			.pastdmark: pop af  
ad2a			endm  
# End of macro DMARK
ad2a						CALLMONITOR 
ad2a cd 6c 93			call break_point_state  
ad2d				endm  
# End of macro CALLMONITOR
ad2d					endif 
ad2d			 
ad2d					FORTH_DSP_VALUEHL 
ad2d cd f0 9a			call macro_dsp_valuehl 
ad30				endm 
# End of macro FORTH_DSP_VALUEHL
ad30			;		push hl		 ; hl now has starting limit counter 
ad30			 
ad30					if DEBUG_FORTH_WORDS 
ad30						DMARK "DO6" 
ad30 f5				push af  
ad31 3a 45 ad			ld a, (.dmark)  
ad34 32 7a ee			ld (debug_mark),a  
ad37 3a 46 ad			ld a, (.dmark+1)  
ad3a 32 7b ee			ld (debug_mark+1),a  
ad3d 3a 47 ad			ld a, (.dmark+2)  
ad40 32 7c ee			ld (debug_mark+2),a  
ad43 18 03			jr .pastdmark  
ad45 ..			.dmark: db "DO6"  
ad48 f1			.pastdmark: pop af  
ad49			endm  
# End of macro DMARK
ad49						CALLMONITOR 
ad49 cd 6c 93			call break_point_state  
ad4c				endm  
# End of macro CALLMONITOR
ad4c					endif 
ad4c					FORTH_DSP_POP 
ad4c cd a8 9b			call macro_forth_dsp_pop 
ad4f				endm 
# End of macro FORTH_DSP_POP
ad4f			 
ad4f			; put counters on the loop stack 
ad4f			 
ad4f			;		pop hl			 ; limit counter 
ad4f d1					pop de			; start counter 
ad50			 
ad50					; push limit counter 
ad50			 
ad50					if DEBUG_FORTH_WORDS 
ad50						DMARK "DO7" 
ad50 f5				push af  
ad51 3a 65 ad			ld a, (.dmark)  
ad54 32 7a ee			ld (debug_mark),a  
ad57 3a 66 ad			ld a, (.dmark+1)  
ad5a 32 7b ee			ld (debug_mark+1),a  
ad5d 3a 67 ad			ld a, (.dmark+2)  
ad60 32 7c ee			ld (debug_mark+2),a  
ad63 18 03			jr .pastdmark  
ad65 ..			.dmark: db "DO7"  
ad68 f1			.pastdmark: pop af  
ad69			endm  
# End of macro DMARK
ad69						CALLMONITOR 
ad69 cd 6c 93			call break_point_state  
ad6c				endm  
# End of macro CALLMONITOR
ad6c					endif 
ad6c					FORTH_LOOP_NEXT 
ad6c cd 21 9b			call macro_forth_loop_next 
ad6f				endm 
# End of macro FORTH_LOOP_NEXT
ad6f			 
ad6f					; push start counter 
ad6f			 
ad6f eb					ex de, hl 
ad70					if DEBUG_FORTH_WORDS 
ad70						DMARK "DO7" 
ad70 f5				push af  
ad71 3a 85 ad			ld a, (.dmark)  
ad74 32 7a ee			ld (debug_mark),a  
ad77 3a 86 ad			ld a, (.dmark+1)  
ad7a 32 7b ee			ld (debug_mark+1),a  
ad7d 3a 87 ad			ld a, (.dmark+2)  
ad80 32 7c ee			ld (debug_mark+2),a  
ad83 18 03			jr .pastdmark  
ad85 ..			.dmark: db "DO7"  
ad88 f1			.pastdmark: pop af  
ad89			endm  
# End of macro DMARK
ad89						CALLMONITOR 
ad89 cd 6c 93			call break_point_state  
ad8c				endm  
# End of macro CALLMONITOR
ad8c					endif 
ad8c					FORTH_LOOP_NEXT 
ad8c cd 21 9b			call macro_forth_loop_next 
ad8f				endm 
# End of macro FORTH_LOOP_NEXT
ad8f			 
ad8f			 
ad8f					; init first round of I counter 
ad8f			 
ad8f 22 85 e6				ld (os_current_i), hl 
ad92			 
ad92					if DEBUG_FORTH_WORDS 
ad92						DMARK "DO8" 
ad92 f5				push af  
ad93 3a a7 ad			ld a, (.dmark)  
ad96 32 7a ee			ld (debug_mark),a  
ad99 3a a8 ad			ld a, (.dmark+1)  
ad9c 32 7b ee			ld (debug_mark+1),a  
ad9f 3a a9 ad			ld a, (.dmark+2)  
ada2 32 7c ee			ld (debug_mark+2),a  
ada5 18 03			jr .pastdmark  
ada7 ..			.dmark: db "DO8"  
adaa f1			.pastdmark: pop af  
adab			endm  
# End of macro DMARK
adab						CALLMONITOR 
adab cd 6c 93			call break_point_state  
adae				endm  
# End of macro CALLMONITOR
adae					endif 
adae			 
adae					NEXTW 
adae c3 62 9c			jp macro_next 
adb1				endm 
# End of macro NEXTW
adb1			.LOOP: 
adb1				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
adb1 22				db WORD_SYS_CORE+14             
adb2 c9 ae			dw .I            
adb4 05				db 4 + 1 
adb5 .. 00			db "LOOP",0              
adba				endm 
# End of macro CWHEAD
adba			; | LOOP ( -- ) Increment and test loop counter  | DONE 
adba			 
adba				; pop tos as current loop count to hl 
adba			 
adba				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
adba			 
adba				FORTH_LOOP_TOS 
adba cd 54 9b			call macro_forth_loop_tos 
adbd				endm 
# End of macro FORTH_LOOP_TOS
adbd e5				push hl 
adbe			 
adbe					if DEBUG_FORTH_WORDS_KEY 
adbe						DMARK "LOP" 
adbe f5				push af  
adbf 3a d3 ad			ld a, (.dmark)  
adc2 32 7a ee			ld (debug_mark),a  
adc5 3a d4 ad			ld a, (.dmark+1)  
adc8 32 7b ee			ld (debug_mark+1),a  
adcb 3a d5 ad			ld a, (.dmark+2)  
adce 32 7c ee			ld (debug_mark+2),a  
add1 18 03			jr .pastdmark  
add3 ..			.dmark: db "LOP"  
add6 f1			.pastdmark: pop af  
add7			endm  
# End of macro DMARK
add7						CALLMONITOR 
add7 cd 6c 93			call break_point_state  
adda				endm  
# End of macro CALLMONITOR
adda					endif 
adda				; next item on the stack is the limit. get it 
adda			 
adda			 
adda				FORTH_LOOP_POP 
adda cd 5e 9b			call macro_forth_loop_pop 
addd				endm 
# End of macro FORTH_LOOP_POP
addd			 
addd				FORTH_LOOP_TOS 
addd cd 54 9b			call macro_forth_loop_tos 
ade0				endm 
# End of macro FORTH_LOOP_TOS
ade0			 
ade0 d1				pop de		 ; de = i, hl = limit 
ade1			 
ade1					if DEBUG_FORTH_WORDS 
ade1						DMARK "LP1" 
ade1 f5				push af  
ade2 3a f6 ad			ld a, (.dmark)  
ade5 32 7a ee			ld (debug_mark),a  
ade8 3a f7 ad			ld a, (.dmark+1)  
adeb 32 7b ee			ld (debug_mark+1),a  
adee 3a f8 ad			ld a, (.dmark+2)  
adf1 32 7c ee			ld (debug_mark+2),a  
adf4 18 03			jr .pastdmark  
adf6 ..			.dmark: db "LP1"  
adf9 f1			.pastdmark: pop af  
adfa			endm  
# End of macro DMARK
adfa						CALLMONITOR 
adfa cd 6c 93			call break_point_state  
adfd				endm  
# End of macro CALLMONITOR
adfd					endif 
adfd			 
adfd				; go back to previous word 
adfd			 
adfd d5				push de    ; save I for inc later 
adfe			 
adfe			 
adfe				; get limit 
adfe				;  is I at limit? 
adfe			 
adfe			 
adfe					if DEBUG_FORTH_WORDS 
adfe						DMARK "LP1" 
adfe f5				push af  
adff 3a 13 ae			ld a, (.dmark)  
ae02 32 7a ee			ld (debug_mark),a  
ae05 3a 14 ae			ld a, (.dmark+1)  
ae08 32 7b ee			ld (debug_mark+1),a  
ae0b 3a 15 ae			ld a, (.dmark+2)  
ae0e 32 7c ee			ld (debug_mark+2),a  
ae11 18 03			jr .pastdmark  
ae13 ..			.dmark: db "LP1"  
ae16 f1			.pastdmark: pop af  
ae17			endm  
# End of macro DMARK
ae17						CALLMONITOR 
ae17 cd 6c 93			call break_point_state  
ae1a				endm  
# End of macro CALLMONITOR
ae1a					endif 
ae1a			 
ae1a ed 52			sbc hl, de 
ae1c			 
ae1c			 
ae1c				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
ae1c			 
ae1c 20 26				jr nz, .loopnotdone 
ae1e			 
ae1e e1				pop hl   ; get rid of saved I 
ae1f				FORTH_LOOP_POP     ; get rid of limit 
ae1f cd 5e 9b			call macro_forth_loop_pop 
ae22				endm 
# End of macro FORTH_LOOP_POP
ae22			 
ae22				FORTH_RSP_POP     ; get rid of DO ptr 
ae22 cd c1 98			call macro_forth_rsp_pop 
ae25				endm 
# End of macro FORTH_RSP_POP
ae25			 
ae25			if DEBUG_FORTH_WORDS 
ae25						DMARK "LP>" 
ae25 f5				push af  
ae26 3a 3a ae			ld a, (.dmark)  
ae29 32 7a ee			ld (debug_mark),a  
ae2c 3a 3b ae			ld a, (.dmark+1)  
ae2f 32 7b ee			ld (debug_mark+1),a  
ae32 3a 3c ae			ld a, (.dmark+2)  
ae35 32 7c ee			ld (debug_mark+2),a  
ae38 18 03			jr .pastdmark  
ae3a ..			.dmark: db "LP>"  
ae3d f1			.pastdmark: pop af  
ae3e			endm  
# End of macro DMARK
ae3e				CALLMONITOR 
ae3e cd 6c 93			call break_point_state  
ae41				endm  
# End of macro CALLMONITOR
ae41			endif 
ae41			 
ae41					NEXTW 
ae41 c3 62 9c			jp macro_next 
ae44				endm 
# End of macro NEXTW
ae44				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
ae44			 
ae44			.loopnotdone: 
ae44			 
ae44 e1				pop hl    ; get I 
ae45 23				inc hl 
ae46			 
ae46			   	; save new I 
ae46			 
ae46			 
ae46					; set I counter 
ae46			 
ae46 22 85 e6				ld (os_current_i), hl 
ae49			 
ae49					if DEBUG_FORTH_WORDS 
ae49						DMARK "LPN" 
ae49 f5				push af  
ae4a 3a 5e ae			ld a, (.dmark)  
ae4d 32 7a ee			ld (debug_mark),a  
ae50 3a 5f ae			ld a, (.dmark+1)  
ae53 32 7b ee			ld (debug_mark+1),a  
ae56 3a 60 ae			ld a, (.dmark+2)  
ae59 32 7c ee			ld (debug_mark+2),a  
ae5c 18 03			jr .pastdmark  
ae5e ..			.dmark: db "LPN"  
ae61 f1			.pastdmark: pop af  
ae62			endm  
# End of macro DMARK
ae62					CALLMONITOR 
ae62 cd 6c 93			call break_point_state  
ae65				endm  
# End of macro CALLMONITOR
ae65					endif 
ae65					 
ae65				FORTH_LOOP_NEXT 
ae65 cd 21 9b			call macro_forth_loop_next 
ae68				endm 
# End of macro FORTH_LOOP_NEXT
ae68			 
ae68			 
ae68					if DEBUG_FORTH_WORDS 
ae68 eb						ex de,hl 
ae69					endif 
ae69			 
ae69			;	; get DO ptr 
ae69			; 
ae69					if DEBUG_FORTH_WORDS 
ae69						DMARK "LP7" 
ae69 f5				push af  
ae6a 3a 7e ae			ld a, (.dmark)  
ae6d 32 7a ee			ld (debug_mark),a  
ae70 3a 7f ae			ld a, (.dmark+1)  
ae73 32 7b ee			ld (debug_mark+1),a  
ae76 3a 80 ae			ld a, (.dmark+2)  
ae79 32 7c ee			ld (debug_mark+2),a  
ae7c 18 03			jr .pastdmark  
ae7e ..			.dmark: db "LP7"  
ae81 f1			.pastdmark: pop af  
ae82			endm  
# End of macro DMARK
ae82					CALLMONITOR 
ae82 cd 6c 93			call break_point_state  
ae85				endm  
# End of macro CALLMONITOR
ae85					endif 
ae85				FORTH_RSP_TOS 
ae85 cd b7 98			call macro_forth_rsp_tos 
ae88				endm 
# End of macro FORTH_RSP_TOS
ae88			 
ae88					if DEBUG_FORTH_WORDS 
ae88						DMARK "LP8" 
ae88 f5				push af  
ae89 3a 9d ae			ld a, (.dmark)  
ae8c 32 7a ee			ld (debug_mark),a  
ae8f 3a 9e ae			ld a, (.dmark+1)  
ae92 32 7b ee			ld (debug_mark+1),a  
ae95 3a 9f ae			ld a, (.dmark+2)  
ae98 32 7c ee			ld (debug_mark+2),a  
ae9b 18 03			jr .pastdmark  
ae9d ..			.dmark: db "LP8"  
aea0 f1			.pastdmark: pop af  
aea1			endm  
# End of macro DMARK
aea1					CALLMONITOR 
aea1 cd 6c 93			call break_point_state  
aea4				endm  
# End of macro CALLMONITOR
aea4					endif 
aea4				;push hl 
aea4			 
aea4				; not going to DO any more 
aea4				; get rid of the RSP pointer as DO will add it back in 
aea4				;FORTH_RSP_POP 
aea4				;pop hl 
aea4			 
aea4				;ld hl,(cli_ret_sp) 
aea4				;ld e, (hl) 
aea4				;inc hl 
aea4				;ld d, (hl) 
aea4				;ex de,hl 
aea4 22 61 e6			ld (os_tok_ptr), hl 
aea7					if DEBUG_FORTH_WORDS 
aea7						DMARK "LP<" 
aea7 f5				push af  
aea8 3a bc ae			ld a, (.dmark)  
aeab 32 7a ee			ld (debug_mark),a  
aeae 3a bd ae			ld a, (.dmark+1)  
aeb1 32 7b ee			ld (debug_mark+1),a  
aeb4 3a be ae			ld a, (.dmark+2)  
aeb7 32 7c ee			ld (debug_mark+2),a  
aeba 18 03			jr .pastdmark  
aebc ..			.dmark: db "LP<"  
aebf f1			.pastdmark: pop af  
aec0			endm  
# End of macro DMARK
aec0					CALLMONITOR 
aec0 cd 6c 93			call break_point_state  
aec3				endm  
# End of macro CALLMONITOR
aec3				endif 
aec3 c3 f3 9c			jp exec1 
aec6			 
aec6					 
aec6			 
aec6			 
aec6					NEXTW 
aec6 c3 62 9c			jp macro_next 
aec9				endm 
# End of macro NEXTW
aec9			.I:  
aec9			 
aec9				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
aec9 5e				db WORD_SYS_CORE+74             
aeca f4 ae			dw .DLOOP            
aecc 02				db 1 + 1 
aecd .. 00			db "I",0              
aecf				endm 
# End of macro CWHEAD
aecf			; | I ( -- ) Current loop counter | DONE 
aecf					if DEBUG_FORTH_WORDS_KEY 
aecf						DMARK "I.." 
aecf f5				push af  
aed0 3a e4 ae			ld a, (.dmark)  
aed3 32 7a ee			ld (debug_mark),a  
aed6 3a e5 ae			ld a, (.dmark+1)  
aed9 32 7b ee			ld (debug_mark+1),a  
aedc 3a e6 ae			ld a, (.dmark+2)  
aedf 32 7c ee			ld (debug_mark+2),a  
aee2 18 03			jr .pastdmark  
aee4 ..			.dmark: db "I.."  
aee7 f1			.pastdmark: pop af  
aee8			endm  
# End of macro DMARK
aee8						CALLMONITOR 
aee8 cd 6c 93			call break_point_state  
aeeb				endm  
# End of macro CALLMONITOR
aeeb					endif 
aeeb			 
aeeb 2a 85 e6				ld hl,(os_current_i) 
aeee cd f9 98				call forth_push_numhl 
aef1			 
aef1					NEXTW 
aef1 c3 62 9c			jp macro_next 
aef4				endm 
# End of macro NEXTW
aef4			.DLOOP: 
aef4				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
aef4 5f				db WORD_SYS_CORE+75             
aef5 d5 af			dw .REPEAT            
aef7 06				db 5 + 1 
aef8 .. 00			db "-LOOP",0              
aefe				endm 
# End of macro CWHEAD
aefe			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
aefe				; pop tos as current loop count to hl 
aefe					if DEBUG_FORTH_WORDS_KEY 
aefe						DMARK "-LP" 
aefe f5				push af  
aeff 3a 13 af			ld a, (.dmark)  
af02 32 7a ee			ld (debug_mark),a  
af05 3a 14 af			ld a, (.dmark+1)  
af08 32 7b ee			ld (debug_mark+1),a  
af0b 3a 15 af			ld a, (.dmark+2)  
af0e 32 7c ee			ld (debug_mark+2),a  
af11 18 03			jr .pastdmark  
af13 ..			.dmark: db "-LP"  
af16 f1			.pastdmark: pop af  
af17			endm  
# End of macro DMARK
af17						CALLMONITOR 
af17 cd 6c 93			call break_point_state  
af1a				endm  
# End of macro CALLMONITOR
af1a					endif 
af1a			 
af1a				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
af1a			 
af1a				FORTH_LOOP_TOS 
af1a cd 54 9b			call macro_forth_loop_tos 
af1d				endm 
# End of macro FORTH_LOOP_TOS
af1d e5				push hl 
af1e			 
af1e					if DEBUG_FORTH_WORDS 
af1e						DMARK "-LP" 
af1e f5				push af  
af1f 3a 33 af			ld a, (.dmark)  
af22 32 7a ee			ld (debug_mark),a  
af25 3a 34 af			ld a, (.dmark+1)  
af28 32 7b ee			ld (debug_mark+1),a  
af2b 3a 35 af			ld a, (.dmark+2)  
af2e 32 7c ee			ld (debug_mark+2),a  
af31 18 03			jr .pastdmark  
af33 ..			.dmark: db "-LP"  
af36 f1			.pastdmark: pop af  
af37			endm  
# End of macro DMARK
af37						CALLMONITOR 
af37 cd 6c 93			call break_point_state  
af3a				endm  
# End of macro CALLMONITOR
af3a					endif 
af3a				; next item on the stack is the limit. get it 
af3a			 
af3a			 
af3a				FORTH_LOOP_POP 
af3a cd 5e 9b			call macro_forth_loop_pop 
af3d				endm 
# End of macro FORTH_LOOP_POP
af3d			 
af3d				FORTH_LOOP_TOS 
af3d cd 54 9b			call macro_forth_loop_tos 
af40				endm 
# End of macro FORTH_LOOP_TOS
af40			 
af40 d1				pop de		 ; de = i, hl = limit 
af41			 
af41					if DEBUG_FORTH_WORDS 
af41						DMARK "-L1" 
af41 f5				push af  
af42 3a 56 af			ld a, (.dmark)  
af45 32 7a ee			ld (debug_mark),a  
af48 3a 57 af			ld a, (.dmark+1)  
af4b 32 7b ee			ld (debug_mark+1),a  
af4e 3a 58 af			ld a, (.dmark+2)  
af51 32 7c ee			ld (debug_mark+2),a  
af54 18 03			jr .pastdmark  
af56 ..			.dmark: db "-L1"  
af59 f1			.pastdmark: pop af  
af5a			endm  
# End of macro DMARK
af5a						CALLMONITOR 
af5a cd 6c 93			call break_point_state  
af5d				endm  
# End of macro CALLMONITOR
af5d					endif 
af5d			 
af5d				; go back to previous word 
af5d			 
af5d d5				push de    ; save I for inc later 
af5e			 
af5e			 
af5e				; get limit 
af5e				;  is I at limit? 
af5e			 
af5e			 
af5e					if DEBUG_FORTH_WORDS 
af5e						DMARK "-L1" 
af5e f5				push af  
af5f 3a 73 af			ld a, (.dmark)  
af62 32 7a ee			ld (debug_mark),a  
af65 3a 74 af			ld a, (.dmark+1)  
af68 32 7b ee			ld (debug_mark+1),a  
af6b 3a 75 af			ld a, (.dmark+2)  
af6e 32 7c ee			ld (debug_mark+2),a  
af71 18 03			jr .pastdmark  
af73 ..			.dmark: db "-L1"  
af76 f1			.pastdmark: pop af  
af77			endm  
# End of macro DMARK
af77						CALLMONITOR 
af77 cd 6c 93			call break_point_state  
af7a				endm  
# End of macro CALLMONITOR
af7a					endif 
af7a			 
af7a ed 52			sbc hl, de 
af7c			 
af7c			 
af7c				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
af7c			 
af7c 20 26				jr nz, .mloopnotdone 
af7e			 
af7e e1				pop hl   ; get rid of saved I 
af7f				FORTH_LOOP_POP     ; get rid of limit 
af7f cd 5e 9b			call macro_forth_loop_pop 
af82				endm 
# End of macro FORTH_LOOP_POP
af82			 
af82				FORTH_RSP_POP     ; get rid of DO ptr 
af82 cd c1 98			call macro_forth_rsp_pop 
af85				endm 
# End of macro FORTH_RSP_POP
af85			 
af85			if DEBUG_FORTH_WORDS 
af85						DMARK "-L>" 
af85 f5				push af  
af86 3a 9a af			ld a, (.dmark)  
af89 32 7a ee			ld (debug_mark),a  
af8c 3a 9b af			ld a, (.dmark+1)  
af8f 32 7b ee			ld (debug_mark+1),a  
af92 3a 9c af			ld a, (.dmark+2)  
af95 32 7c ee			ld (debug_mark+2),a  
af98 18 03			jr .pastdmark  
af9a ..			.dmark: db "-L>"  
af9d f1			.pastdmark: pop af  
af9e			endm  
# End of macro DMARK
af9e				CALLMONITOR 
af9e cd 6c 93			call break_point_state  
afa1				endm  
# End of macro CALLMONITOR
afa1			endif 
afa1			 
afa1					NEXTW 
afa1 c3 62 9c			jp macro_next 
afa4				endm 
# End of macro NEXTW
afa4				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
afa4			 
afa4			.mloopnotdone: 
afa4			 
afa4 e1				pop hl    ; get I 
afa5 2b				dec hl 
afa6			 
afa6			   	; save new I 
afa6			 
afa6			 
afa6					; set I counter 
afa6			 
afa6 22 85 e6				ld (os_current_i), hl 
afa9			 
afa9					 
afa9				FORTH_LOOP_NEXT 
afa9 cd 21 9b			call macro_forth_loop_next 
afac				endm 
# End of macro FORTH_LOOP_NEXT
afac			 
afac			 
afac					if DEBUG_FORTH_WORDS 
afac eb						ex de,hl 
afad					endif 
afad			 
afad			;	; get DO ptr 
afad			; 
afad				FORTH_RSP_TOS 
afad cd b7 98			call macro_forth_rsp_tos 
afb0				endm 
# End of macro FORTH_RSP_TOS
afb0			 
afb0				;push hl 
afb0			 
afb0				; not going to DO any more 
afb0				; get rid of the RSP pointer as DO will add it back in 
afb0				;FORTH_RSP_POP 
afb0				;pop hl 
afb0			 
afb0			 
afb0 22 61 e6			ld (os_tok_ptr), hl 
afb3					if DEBUG_FORTH_WORDS 
afb3						DMARK "-L<" 
afb3 f5				push af  
afb4 3a c8 af			ld a, (.dmark)  
afb7 32 7a ee			ld (debug_mark),a  
afba 3a c9 af			ld a, (.dmark+1)  
afbd 32 7b ee			ld (debug_mark+1),a  
afc0 3a ca af			ld a, (.dmark+2)  
afc3 32 7c ee			ld (debug_mark+2),a  
afc6 18 03			jr .pastdmark  
afc8 ..			.dmark: db "-L<"  
afcb f1			.pastdmark: pop af  
afcc			endm  
# End of macro DMARK
afcc					CALLMONITOR 
afcc cd 6c 93			call break_point_state  
afcf				endm  
# End of macro CALLMONITOR
afcf				endif 
afcf c3 f3 9c			jp exec1 
afd2			 
afd2					 
afd2			 
afd2			 
afd2			 
afd2				NEXTW 
afd2 c3 62 9c			jp macro_next 
afd5				endm 
# End of macro NEXTW
afd5			 
afd5			 
afd5			 
afd5			 
afd5			.REPEAT: 
afd5				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
afd5 71				db WORD_SYS_CORE+93             
afd6 28 b0			dw .UNTIL            
afd8 06				db 5 + 1 
afd9 .. 00			db "REPEAT",0              
afe0				endm 
# End of macro CWHEAD
afe0			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
afe0			;  push pc to rsp stack past the REPEAT 
afe0					if DEBUG_FORTH_WORDS_KEY 
afe0						DMARK "REP" 
afe0 f5				push af  
afe1 3a f5 af			ld a, (.dmark)  
afe4 32 7a ee			ld (debug_mark),a  
afe7 3a f6 af			ld a, (.dmark+1)  
afea 32 7b ee			ld (debug_mark+1),a  
afed 3a f7 af			ld a, (.dmark+2)  
aff0 32 7c ee			ld (debug_mark+2),a  
aff3 18 03			jr .pastdmark  
aff5 ..			.dmark: db "REP"  
aff8 f1			.pastdmark: pop af  
aff9			endm  
# End of macro DMARK
aff9						CALLMONITOR 
aff9 cd 6c 93			call break_point_state  
affc				endm  
# End of macro CALLMONITOR
affc					endif 
affc			 
affc 2a 61 e6				ld hl, (os_tok_ptr) 
afff 23					inc hl   ; R 
b000 23					inc hl  ; E 
b001 23					inc hl   ; P 
b002 23					inc hl   ; E 
b003 23					inc hl   ; A 
b004 23					inc hl   ; T 
b005 23					inc hl   ; zero 
b006					FORTH_RSP_NEXT 
b006 cd a0 98			call macro_forth_rsp_next 
b009				endm 
# End of macro FORTH_RSP_NEXT
b009			 
b009			 
b009					if DEBUG_FORTH_WORDS 
b009						DMARK "REP" 
b009 f5				push af  
b00a 3a 1e b0			ld a, (.dmark)  
b00d 32 7a ee			ld (debug_mark),a  
b010 3a 1f b0			ld a, (.dmark+1)  
b013 32 7b ee			ld (debug_mark+1),a  
b016 3a 20 b0			ld a, (.dmark+2)  
b019 32 7c ee			ld (debug_mark+2),a  
b01c 18 03			jr .pastdmark  
b01e ..			.dmark: db "REP"  
b021 f1			.pastdmark: pop af  
b022			endm  
# End of macro DMARK
b022						;pop bc    ; TODO BUG ?????? what is this for???? 
b022						CALLMONITOR 
b022 cd 6c 93			call break_point_state  
b025				endm  
# End of macro CALLMONITOR
b025					endif 
b025			 
b025					NEXTW 
b025 c3 62 9c			jp macro_next 
b028				endm 
# End of macro NEXTW
b028			;	       NEXTW 
b028			 
b028			.UNTIL: 
b028				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
b028 72				db WORD_SYS_CORE+94             
b029 bf b0			dw .ENDFLOW            
b02b 06				db 5 + 1 
b02c .. 00			db "UNTIL",0              
b032				endm 
# End of macro CWHEAD
b032			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
b032			 
b032				; pop tos as check 
b032			 
b032				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
b032			 
b032				FORTH_DSP_VALUEHL 
b032 cd f0 9a			call macro_dsp_valuehl 
b035				endm 
# End of macro FORTH_DSP_VALUEHL
b035			 
b035					if DEBUG_FORTH_WORDS_KEY 
b035						DMARK "UNT" 
b035 f5				push af  
b036 3a 4a b0			ld a, (.dmark)  
b039 32 7a ee			ld (debug_mark),a  
b03c 3a 4b b0			ld a, (.dmark+1)  
b03f 32 7b ee			ld (debug_mark+1),a  
b042 3a 4c b0			ld a, (.dmark+2)  
b045 32 7c ee			ld (debug_mark+2),a  
b048 18 03			jr .pastdmark  
b04a ..			.dmark: db "UNT"  
b04d f1			.pastdmark: pop af  
b04e			endm  
# End of macro DMARK
b04e						CALLMONITOR 
b04e cd 6c 93			call break_point_state  
b051				endm  
# End of macro CALLMONITOR
b051					endif 
b051			 
b051			;	push hl 
b051				FORTH_DSP_POP 
b051 cd a8 9b			call macro_forth_dsp_pop 
b054				endm 
# End of macro FORTH_DSP_POP
b054			 
b054			;	pop hl 
b054			 
b054				; test if true 
b054			 
b054 cd e7 8a			call ishlzero 
b057			;	ld a,l 
b057			;	add h 
b057			; 
b057			;	cp 0 
b057			 
b057 20 3e			jr nz, .untilnotdone 
b059			 
b059					if DEBUG_FORTH_WORDS 
b059						DMARK "UNf" 
b059 f5				push af  
b05a 3a 6e b0			ld a, (.dmark)  
b05d 32 7a ee			ld (debug_mark),a  
b060 3a 6f b0			ld a, (.dmark+1)  
b063 32 7b ee			ld (debug_mark+1),a  
b066 3a 70 b0			ld a, (.dmark+2)  
b069 32 7c ee			ld (debug_mark+2),a  
b06c 18 03			jr .pastdmark  
b06e ..			.dmark: db "UNf"  
b071 f1			.pastdmark: pop af  
b072			endm  
# End of macro DMARK
b072						CALLMONITOR 
b072 cd 6c 93			call break_point_state  
b075				endm  
# End of macro CALLMONITOR
b075					endif 
b075			 
b075			 
b075			 
b075				FORTH_RSP_POP     ; get rid of DO ptr 
b075 cd c1 98			call macro_forth_rsp_pop 
b078				endm 
# End of macro FORTH_RSP_POP
b078			 
b078			if DEBUG_FORTH_WORDS 
b078						DMARK "UN>" 
b078 f5				push af  
b079 3a 8d b0			ld a, (.dmark)  
b07c 32 7a ee			ld (debug_mark),a  
b07f 3a 8e b0			ld a, (.dmark+1)  
b082 32 7b ee			ld (debug_mark+1),a  
b085 3a 8f b0			ld a, (.dmark+2)  
b088 32 7c ee			ld (debug_mark+2),a  
b08b 18 03			jr .pastdmark  
b08d ..			.dmark: db "UN>"  
b090 f1			.pastdmark: pop af  
b091			endm  
# End of macro DMARK
b091				CALLMONITOR 
b091 cd 6c 93			call break_point_state  
b094				endm  
# End of macro CALLMONITOR
b094			endif 
b094			 
b094					NEXTW 
b094 c3 62 9c			jp macro_next 
b097				endm 
# End of macro NEXTW
b097				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
b097			 
b097			.untilnotdone: 
b097			 
b097			 
b097			;	; get DO ptr 
b097			; 
b097				FORTH_RSP_TOS 
b097 cd b7 98			call macro_forth_rsp_tos 
b09a				endm 
# End of macro FORTH_RSP_TOS
b09a			 
b09a				;push hl 
b09a			 
b09a				; not going to DO any more 
b09a				; get rid of the RSP pointer as DO will add it back in 
b09a				;FORTH_RSP_POP 
b09a				;pop hl 
b09a			 
b09a			 
b09a 22 61 e6			ld (os_tok_ptr), hl 
b09d					if DEBUG_FORTH_WORDS 
b09d						DMARK "UN<" 
b09d f5				push af  
b09e 3a b2 b0			ld a, (.dmark)  
b0a1 32 7a ee			ld (debug_mark),a  
b0a4 3a b3 b0			ld a, (.dmark+1)  
b0a7 32 7b ee			ld (debug_mark+1),a  
b0aa 3a b4 b0			ld a, (.dmark+2)  
b0ad 32 7c ee			ld (debug_mark+2),a  
b0b0 18 03			jr .pastdmark  
b0b2 ..			.dmark: db "UN<"  
b0b5 f1			.pastdmark: pop af  
b0b6			endm  
# End of macro DMARK
b0b6					CALLMONITOR 
b0b6 cd 6c 93			call break_point_state  
b0b9				endm  
# End of macro CALLMONITOR
b0b9				endif 
b0b9 c3 f3 9c			jp exec1 
b0bc			 
b0bc					 
b0bc			 
b0bc			 
b0bc					NEXTW 
b0bc c3 62 9c			jp macro_next 
b0bf				endm 
# End of macro NEXTW
b0bf			 
b0bf			 
b0bf			.ENDFLOW: 
b0bf			 
b0bf			; eof 
b0bf			 
# End of file forth_words_flow.asm
b0bf			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
b0bf			include "forth_words_logic.asm" 
b0bf			 
b0bf			; | ## Logic Words 
b0bf			 
b0bf			.NOT: 
b0bf				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
b0bf 2d				db WORD_SYS_CORE+25             
b0c0 07 b1			dw .IS            
b0c2 04				db 3 + 1 
b0c3 .. 00			db "NOT",0              
b0c7				endm 
# End of macro CWHEAD
b0c7			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
b0c7					if DEBUG_FORTH_WORDS_KEY 
b0c7						DMARK "NOT" 
b0c7 f5				push af  
b0c8 3a dc b0			ld a, (.dmark)  
b0cb 32 7a ee			ld (debug_mark),a  
b0ce 3a dd b0			ld a, (.dmark+1)  
b0d1 32 7b ee			ld (debug_mark+1),a  
b0d4 3a de b0			ld a, (.dmark+2)  
b0d7 32 7c ee			ld (debug_mark+2),a  
b0da 18 03			jr .pastdmark  
b0dc ..			.dmark: db "NOT"  
b0df f1			.pastdmark: pop af  
b0e0			endm  
# End of macro DMARK
b0e0						CALLMONITOR 
b0e0 cd 6c 93			call break_point_state  
b0e3				endm  
# End of macro CALLMONITOR
b0e3					endif 
b0e3					FORTH_DSP 
b0e3 cd b6 9a			call macro_forth_dsp 
b0e6				endm 
# End of macro FORTH_DSP
b0e6 7e					ld a,(hl)	; get type of value on TOS 
b0e7 fe 02				cp DS_TYPE_INUM  
b0e9 28 03				jr z, .noti 
b0eb					NEXTW 
b0eb c3 62 9c			jp macro_next 
b0ee				endm 
# End of macro NEXTW
b0ee			.noti:          FORTH_DSP_VALUEHL 
b0ee cd f0 9a			call macro_dsp_valuehl 
b0f1				endm 
# End of macro FORTH_DSP_VALUEHL
b0f1			;		push hl 
b0f1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b0f1 cd a8 9b			call macro_forth_dsp_pop 
b0f4				endm 
# End of macro FORTH_DSP_POP
b0f4			;		pop hl 
b0f4 3e 00				ld a,0 
b0f6 bd					cp l 
b0f7 28 04				jr z, .not2t 
b0f9 2e 00				ld l, 0 
b0fb 18 02				jr .notip 
b0fd			 
b0fd 2e ff		.not2t:		ld l, 255 
b0ff			 
b0ff 26 00		.notip:		ld h, 0	 
b101			 
b101 cd f9 98				call forth_push_numhl 
b104					NEXTW 
b104 c3 62 9c			jp macro_next 
b107				endm 
# End of macro NEXTW
b107			 
b107			.IS: 
b107				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
b107 2d				db WORD_SYS_CORE+25             
b108 2d b1			dw .LZERO            
b10a 03				db 2 + 1 
b10b .. 00			db "IS",0              
b10e				endm 
# End of macro CWHEAD
b10e			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
b10e					if DEBUG_FORTH_WORDS_KEY 
b10e						DMARK "IS." 
b10e f5				push af  
b10f 3a 23 b1			ld a, (.dmark)  
b112 32 7a ee			ld (debug_mark),a  
b115 3a 24 b1			ld a, (.dmark+1)  
b118 32 7b ee			ld (debug_mark+1),a  
b11b 3a 25 b1			ld a, (.dmark+2)  
b11e 32 7c ee			ld (debug_mark+2),a  
b121 18 03			jr .pastdmark  
b123 ..			.dmark: db "IS."  
b126 f1			.pastdmark: pop af  
b127			endm  
# End of macro DMARK
b127						CALLMONITOR 
b127 cd 6c 93			call break_point_state  
b12a				endm  
# End of macro CALLMONITOR
b12a					endif 
b12a					NEXTW 
b12a c3 62 9c			jp macro_next 
b12d				endm 
# End of macro NEXTW
b12d			.LZERO: 
b12d				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
b12d 2d				db WORD_SYS_CORE+25             
b12e 37 b1			dw .TZERO            
b130 03				db 2 + 1 
b131 .. 00			db "0<",0              
b134				endm 
# End of macro CWHEAD
b134			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
b134					NEXTW 
b134 c3 62 9c			jp macro_next 
b137				endm 
# End of macro NEXTW
b137			.TZERO: 
b137				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
b137 2e				db WORD_SYS_CORE+26             
b138 7e b1			dw .LESS            
b13a 03				db 2 + 1 
b13b .. 00			db "0=",0              
b13e				endm 
# End of macro CWHEAD
b13e			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
b13e				; TODO add floating point number detection 
b13e					;v5 FORTH_DSP_VALUE 
b13e					if DEBUG_FORTH_WORDS_KEY 
b13e						DMARK "0=." 
b13e f5				push af  
b13f 3a 53 b1			ld a, (.dmark)  
b142 32 7a ee			ld (debug_mark),a  
b145 3a 54 b1			ld a, (.dmark+1)  
b148 32 7b ee			ld (debug_mark+1),a  
b14b 3a 55 b1			ld a, (.dmark+2)  
b14e 32 7c ee			ld (debug_mark+2),a  
b151 18 03			jr .pastdmark  
b153 ..			.dmark: db "0=."  
b156 f1			.pastdmark: pop af  
b157			endm  
# End of macro DMARK
b157						CALLMONITOR 
b157 cd 6c 93			call break_point_state  
b15a				endm  
# End of macro CALLMONITOR
b15a					endif 
b15a					FORTH_DSP 
b15a cd b6 9a			call macro_forth_dsp 
b15d				endm 
# End of macro FORTH_DSP
b15d 7e					ld a,(hl)	; get type of value on TOS 
b15e fe 02				cp DS_TYPE_INUM  
b160 28 00				jr z, .tz_inum 
b162			 
b162				if FORTH_ENABLE_FLOATMATH 
b162					jr .tz_done 
b162			 
b162				endif 
b162					 
b162			 
b162			.tz_inum: 
b162					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b162 cd f0 9a			call macro_dsp_valuehl 
b165				endm 
# End of macro FORTH_DSP_VALUEHL
b165			 
b165			;		push hl 
b165			 
b165					; destroy value TOS 
b165			 
b165					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b165 cd a8 9b			call macro_forth_dsp_pop 
b168				endm 
# End of macro FORTH_DSP_POP
b168			 
b168			;		pop hl 
b168			 
b168 3e 00				ld a,0 
b16a			 
b16a bd					cp l 
b16b 20 08				jr nz, .tz_notzero 
b16d			 
b16d bc					cp h 
b16e			 
b16e 20 05				jr nz, .tz_notzero 
b170			 
b170			 
b170 21 01 00				ld hl, FORTH_TRUE 
b173 18 03				jr .tz_done 
b175			 
b175 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
b178			 
b178					; push value back onto stack for another op etc 
b178			 
b178			.tz_done: 
b178 cd f9 98				call forth_push_numhl 
b17b			 
b17b					NEXTW 
b17b c3 62 9c			jp macro_next 
b17e				endm 
# End of macro NEXTW
b17e			.LESS: 
b17e				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
b17e 2f				db WORD_SYS_CORE+27             
b17f e7 b1			dw .GT            
b181 02				db 1 + 1 
b182 .. 00			db "<",0              
b184				endm 
# End of macro CWHEAD
b184			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
b184				; TODO add floating point number detection 
b184					if DEBUG_FORTH_WORDS_KEY 
b184						DMARK "LES" 
b184 f5				push af  
b185 3a 99 b1			ld a, (.dmark)  
b188 32 7a ee			ld (debug_mark),a  
b18b 3a 9a b1			ld a, (.dmark+1)  
b18e 32 7b ee			ld (debug_mark+1),a  
b191 3a 9b b1			ld a, (.dmark+2)  
b194 32 7c ee			ld (debug_mark+2),a  
b197 18 03			jr .pastdmark  
b199 ..			.dmark: db "LES"  
b19c f1			.pastdmark: pop af  
b19d			endm  
# End of macro DMARK
b19d						CALLMONITOR 
b19d cd 6c 93			call break_point_state  
b1a0				endm  
# End of macro CALLMONITOR
b1a0					endif 
b1a0					FORTH_DSP 
b1a0 cd b6 9a			call macro_forth_dsp 
b1a3				endm 
# End of macro FORTH_DSP
b1a3					;v5 FORTH_DSP_VALUE 
b1a3 7e					ld a,(hl)	; get type of value on TOS 
b1a4 fe 02				cp DS_TYPE_INUM  
b1a6 28 00				jr z, .less_inum 
b1a8			 
b1a8				if FORTH_ENABLE_FLOATMATH 
b1a8					jr .less_done 
b1a8			 
b1a8				endif 
b1a8					 
b1a8			 
b1a8			.less_inum: 
b1a8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b1a8 cd f0 9a			call macro_dsp_valuehl 
b1ab				endm 
# End of macro FORTH_DSP_VALUEHL
b1ab			 
b1ab e5					push hl  ; u2 
b1ac			 
b1ac					; destroy value TOS 
b1ac			 
b1ac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1ac cd a8 9b			call macro_forth_dsp_pop 
b1af				endm 
# End of macro FORTH_DSP_POP
b1af			 
b1af			 
b1af					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b1af cd f0 9a			call macro_dsp_valuehl 
b1b2				endm 
# End of macro FORTH_DSP_VALUEHL
b1b2			 
b1b2 e5					push hl    ; u1 
b1b3			 
b1b3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b1b3 cd a8 9b			call macro_forth_dsp_pop 
b1b6				endm 
# End of macro FORTH_DSP_POP
b1b6			 
b1b6			 
b1b6 b7			 or a      ;clear carry flag 
b1b7 01 00 00		 ld bc, FORTH_FALSE 
b1ba e1			  pop hl    ; u1 
b1bb d1			  pop de    ; u2 
b1bc ed 52		  sbc hl,de 
b1be 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
b1c0			 
b1c0 01 01 00		 ld bc, FORTH_TRUE 
b1c3			.lscont:  
b1c3 c5					push bc 
b1c4 e1					pop hl 
b1c5			 
b1c5					if DEBUG_FORTH_WORDS 
b1c5						DMARK "LT1" 
b1c5 f5				push af  
b1c6 3a da b1			ld a, (.dmark)  
b1c9 32 7a ee			ld (debug_mark),a  
b1cc 3a db b1			ld a, (.dmark+1)  
b1cf 32 7b ee			ld (debug_mark+1),a  
b1d2 3a dc b1			ld a, (.dmark+2)  
b1d5 32 7c ee			ld (debug_mark+2),a  
b1d8 18 03			jr .pastdmark  
b1da ..			.dmark: db "LT1"  
b1dd f1			.pastdmark: pop af  
b1de			endm  
# End of macro DMARK
b1de						CALLMONITOR 
b1de cd 6c 93			call break_point_state  
b1e1				endm  
# End of macro CALLMONITOR
b1e1					endif 
b1e1 cd f9 98				call forth_push_numhl 
b1e4			 
b1e4					NEXTW 
b1e4 c3 62 9c			jp macro_next 
b1e7				endm 
# End of macro NEXTW
b1e7			.GT: 
b1e7				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
b1e7 30				db WORD_SYS_CORE+28             
b1e8 50 b2			dw .EQUAL            
b1ea 02				db 1 + 1 
b1eb .. 00			db ">",0              
b1ed				endm 
# End of macro CWHEAD
b1ed			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
b1ed				; TODO add floating point number detection 
b1ed					if DEBUG_FORTH_WORDS_KEY 
b1ed						DMARK "GRT" 
b1ed f5				push af  
b1ee 3a 02 b2			ld a, (.dmark)  
b1f1 32 7a ee			ld (debug_mark),a  
b1f4 3a 03 b2			ld a, (.dmark+1)  
b1f7 32 7b ee			ld (debug_mark+1),a  
b1fa 3a 04 b2			ld a, (.dmark+2)  
b1fd 32 7c ee			ld (debug_mark+2),a  
b200 18 03			jr .pastdmark  
b202 ..			.dmark: db "GRT"  
b205 f1			.pastdmark: pop af  
b206			endm  
# End of macro DMARK
b206						CALLMONITOR 
b206 cd 6c 93			call break_point_state  
b209				endm  
# End of macro CALLMONITOR
b209					endif 
b209					FORTH_DSP 
b209 cd b6 9a			call macro_forth_dsp 
b20c				endm 
# End of macro FORTH_DSP
b20c					;FORTH_DSP_VALUE 
b20c 7e					ld a,(hl)	; get type of value on TOS 
b20d fe 02				cp DS_TYPE_INUM  
b20f 28 00				jr z, .gt_inum 
b211			 
b211				if FORTH_ENABLE_FLOATMATH 
b211					jr .gt_done 
b211			 
b211				endif 
b211					 
b211			 
b211			.gt_inum: 
b211					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b211 cd f0 9a			call macro_dsp_valuehl 
b214				endm 
# End of macro FORTH_DSP_VALUEHL
b214			 
b214 e5					push hl  ; u2 
b215			 
b215					; destroy value TOS 
b215			 
b215					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b215 cd a8 9b			call macro_forth_dsp_pop 
b218				endm 
# End of macro FORTH_DSP_POP
b218			 
b218			 
b218					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b218 cd f0 9a			call macro_dsp_valuehl 
b21b				endm 
# End of macro FORTH_DSP_VALUEHL
b21b			 
b21b e5					push hl    ; u1 
b21c			 
b21c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b21c cd a8 9b			call macro_forth_dsp_pop 
b21f				endm 
# End of macro FORTH_DSP_POP
b21f			 
b21f			 
b21f b7			 or a      ;clear carry flag 
b220 01 00 00		 ld bc, FORTH_FALSE 
b223 e1			  pop hl    ; u1 
b224 d1			  pop de    ; u2 
b225 ed 52		  sbc hl,de 
b227 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
b229			 
b229 01 01 00		 ld bc, FORTH_TRUE 
b22c			.gtcont:  
b22c c5					push bc 
b22d e1					pop hl 
b22e			 
b22e					if DEBUG_FORTH_WORDS 
b22e						DMARK "GT1" 
b22e f5				push af  
b22f 3a 43 b2			ld a, (.dmark)  
b232 32 7a ee			ld (debug_mark),a  
b235 3a 44 b2			ld a, (.dmark+1)  
b238 32 7b ee			ld (debug_mark+1),a  
b23b 3a 45 b2			ld a, (.dmark+2)  
b23e 32 7c ee			ld (debug_mark+2),a  
b241 18 03			jr .pastdmark  
b243 ..			.dmark: db "GT1"  
b246 f1			.pastdmark: pop af  
b247			endm  
# End of macro DMARK
b247						CALLMONITOR 
b247 cd 6c 93			call break_point_state  
b24a				endm  
# End of macro CALLMONITOR
b24a					endif 
b24a cd f9 98				call forth_push_numhl 
b24d			 
b24d					NEXTW 
b24d c3 62 9c			jp macro_next 
b250				endm 
# End of macro NEXTW
b250			.EQUAL: 
b250				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
b250 31				db WORD_SYS_CORE+29             
b251 bb b2			dw .ENDLOGIC            
b253 02				db 1 + 1 
b254 .. 00			db "=",0              
b256				endm 
# End of macro CWHEAD
b256			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
b256				; TODO add floating point number detection 
b256					if DEBUG_FORTH_WORDS_KEY 
b256						DMARK "EQ." 
b256 f5				push af  
b257 3a 6b b2			ld a, (.dmark)  
b25a 32 7a ee			ld (debug_mark),a  
b25d 3a 6c b2			ld a, (.dmark+1)  
b260 32 7b ee			ld (debug_mark+1),a  
b263 3a 6d b2			ld a, (.dmark+2)  
b266 32 7c ee			ld (debug_mark+2),a  
b269 18 03			jr .pastdmark  
b26b ..			.dmark: db "EQ."  
b26e f1			.pastdmark: pop af  
b26f			endm  
# End of macro DMARK
b26f						CALLMONITOR 
b26f cd 6c 93			call break_point_state  
b272				endm  
# End of macro CALLMONITOR
b272					endif 
b272					FORTH_DSP 
b272 cd b6 9a			call macro_forth_dsp 
b275				endm 
# End of macro FORTH_DSP
b275					;v5 FORTH_DSP_VALUE 
b275 7e					ld a,(hl)	; get type of value on TOS 
b276 fe 02				cp DS_TYPE_INUM  
b278 28 00				jr z, .eq_inum 
b27a			 
b27a				if FORTH_ENABLE_FLOATMATH 
b27a					jr .eq_done 
b27a			 
b27a				endif 
b27a					 
b27a			 
b27a			.eq_inum: 
b27a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b27a cd f0 9a			call macro_dsp_valuehl 
b27d				endm 
# End of macro FORTH_DSP_VALUEHL
b27d			 
b27d e5					push hl 
b27e			 
b27e					; destroy value TOS 
b27e			 
b27e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b27e cd a8 9b			call macro_forth_dsp_pop 
b281				endm 
# End of macro FORTH_DSP_POP
b281			 
b281			 
b281					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b281 cd f0 9a			call macro_dsp_valuehl 
b284				endm 
# End of macro FORTH_DSP_VALUEHL
b284			 
b284					; one value on hl get other one back 
b284			 
b284 e5					push hl 
b285			 
b285					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b285 cd a8 9b			call macro_forth_dsp_pop 
b288				endm 
# End of macro FORTH_DSP_POP
b288			 
b288 0e 00				ld c, FORTH_FALSE 
b28a			 
b28a e1					pop hl 
b28b d1					pop de 
b28c			 
b28c 7b					ld a, e 
b28d bd					cp l 
b28e			 
b28e 20 06				jr nz, .eq_done 
b290			 
b290 7a					ld a, d 
b291 bc					cp h 
b292			 
b292 20 02				jr nz, .eq_done 
b294			 
b294 0e 01				ld c, FORTH_TRUE 
b296					 
b296			 
b296			 
b296			.eq_done: 
b296			 
b296					; TODO push value back onto stack for another op etc 
b296			 
b296 26 00				ld h, 0 
b298 69					ld l, c 
b299					if DEBUG_FORTH_WORDS 
b299						DMARK "EQ1" 
b299 f5				push af  
b29a 3a ae b2			ld a, (.dmark)  
b29d 32 7a ee			ld (debug_mark),a  
b2a0 3a af b2			ld a, (.dmark+1)  
b2a3 32 7b ee			ld (debug_mark+1),a  
b2a6 3a b0 b2			ld a, (.dmark+2)  
b2a9 32 7c ee			ld (debug_mark+2),a  
b2ac 18 03			jr .pastdmark  
b2ae ..			.dmark: db "EQ1"  
b2b1 f1			.pastdmark: pop af  
b2b2			endm  
# End of macro DMARK
b2b2						CALLMONITOR 
b2b2 cd 6c 93			call break_point_state  
b2b5				endm  
# End of macro CALLMONITOR
b2b5					endif 
b2b5 cd f9 98				call forth_push_numhl 
b2b8			 
b2b8					NEXTW 
b2b8 c3 62 9c			jp macro_next 
b2bb				endm 
# End of macro NEXTW
b2bb			 
b2bb			 
b2bb			.ENDLOGIC: 
b2bb			; eof 
b2bb			 
b2bb			 
# End of file forth_words_logic.asm
b2bb			include "forth_words_maths.asm" 
b2bb			 
b2bb			; | ## Maths Words 
b2bb			 
b2bb			.PLUS:	 
b2bb				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
b2bb 15				db WORD_SYS_CORE+1             
b2bc fd b2			dw .NEG            
b2be 02				db 1 + 1 
b2bf .. 00			db "+",0              
b2c1				endm 
# End of macro CWHEAD
b2c1			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
b2c1					if DEBUG_FORTH_WORDS_KEY 
b2c1						DMARK "PLU" 
b2c1 f5				push af  
b2c2 3a d6 b2			ld a, (.dmark)  
b2c5 32 7a ee			ld (debug_mark),a  
b2c8 3a d7 b2			ld a, (.dmark+1)  
b2cb 32 7b ee			ld (debug_mark+1),a  
b2ce 3a d8 b2			ld a, (.dmark+2)  
b2d1 32 7c ee			ld (debug_mark+2),a  
b2d4 18 03			jr .pastdmark  
b2d6 ..			.dmark: db "PLU"  
b2d9 f1			.pastdmark: pop af  
b2da			endm  
# End of macro DMARK
b2da						CALLMONITOR 
b2da cd 6c 93			call break_point_state  
b2dd				endm  
# End of macro CALLMONITOR
b2dd					endif 
b2dd					; add top two values and push back result 
b2dd			 
b2dd					;for v5 FORTH_DSP_VALUE 
b2dd					FORTH_DSP 
b2dd cd b6 9a			call macro_forth_dsp 
b2e0				endm 
# End of macro FORTH_DSP
b2e0 7e					ld a,(hl)	; get type of value on TOS 
b2e1 fe 02				cp DS_TYPE_INUM  
b2e3 28 03				jr z, .dot_inum 
b2e5			 
b2e5					NEXTW 
b2e5 c3 62 9c			jp macro_next 
b2e8				endm 
# End of macro NEXTW
b2e8			 
b2e8			; float maths 
b2e8			 
b2e8				if FORTH_ENABLE_FLOATMATH 
b2e8						inc hl      ; now at start of numeric as string 
b2e8			 
b2e8					if DEBUG_FORTH_MATHS 
b2e8						DMARK "ADD" 
b2e8				CALLMONITOR 
b2e8					endif 
b2e8			 
b2e8					;ld ix, hl 
b2e8					call CON 
b2e8			 
b2e8			 
b2e8					push hl 
b2e8					 
b2e8					 
b2e8			 
b2e8						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
b2e8			 
b2e8					; get next number 
b2e8			 
b2e8						FORTH_DSP_VALUE 
b2e8			 
b2e8						inc hl      ; now at start of numeric as string 
b2e8			 
b2e8					;ld ix, hl 
b2e8					call CON 
b2e8			 
b2e8					push hl 
b2e8			 
b2e8			 
b2e8						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2e8			 
b2e8						; TODO do add 
b2e8			 
b2e8						call IADD 
b2e8			 
b2e8						; TODO get result back as ascii 
b2e8			 
b2e8						; TODO push result  
b2e8			 
b2e8			 
b2e8			 
b2e8						jr .dot_done 
b2e8				endif 
b2e8			 
b2e8			.dot_inum: 
b2e8			 
b2e8			 
b2e8					if DEBUG_FORTH_DOT 
b2e8						DMARK "+IT" 
b2e8				CALLMONITOR 
b2e8					endif 
b2e8			 
b2e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2e8 cd f0 9a			call macro_dsp_valuehl 
b2eb				endm 
# End of macro FORTH_DSP_VALUEHL
b2eb			 
b2eb				; TODO add floating point number detection 
b2eb			 
b2eb e5					push hl 
b2ec			 
b2ec					; destroy value TOS 
b2ec			 
b2ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2ec cd a8 9b			call macro_forth_dsp_pop 
b2ef				endm 
# End of macro FORTH_DSP_POP
b2ef			 
b2ef			 
b2ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b2ef cd f0 9a			call macro_dsp_valuehl 
b2f2				endm 
# End of macro FORTH_DSP_VALUEHL
b2f2			 
b2f2					; one value on hl get other one back 
b2f2			 
b2f2 d1					pop de 
b2f3			 
b2f3					; do the add 
b2f3			 
b2f3 19					add hl,de 
b2f4			 
b2f4					; save it 
b2f4			 
b2f4			;		push hl	 
b2f4			 
b2f4					; 
b2f4			 
b2f4					; destroy value TOS 
b2f4			 
b2f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b2f4 cd a8 9b			call macro_forth_dsp_pop 
b2f7				endm 
# End of macro FORTH_DSP_POP
b2f7			 
b2f7					; TODO push value back onto stack for another op etc 
b2f7			 
b2f7			;		pop hl 
b2f7			 
b2f7			.dot_done: 
b2f7 cd f9 98				call forth_push_numhl 
b2fa			 
b2fa					NEXTW 
b2fa c3 62 9c			jp macro_next 
b2fd				endm 
# End of macro NEXTW
b2fd			.NEG: 
b2fd			 
b2fd				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
b2fd 17				db WORD_SYS_CORE+3             
b2fe 40 b3			dw .DIV            
b300 02				db 1 + 1 
b301 .. 00			db "-",0              
b303				endm 
# End of macro CWHEAD
b303			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
b303					if DEBUG_FORTH_WORDS_KEY 
b303						DMARK "SUB" 
b303 f5				push af  
b304 3a 18 b3			ld a, (.dmark)  
b307 32 7a ee			ld (debug_mark),a  
b30a 3a 19 b3			ld a, (.dmark+1)  
b30d 32 7b ee			ld (debug_mark+1),a  
b310 3a 1a b3			ld a, (.dmark+2)  
b313 32 7c ee			ld (debug_mark+2),a  
b316 18 03			jr .pastdmark  
b318 ..			.dmark: db "SUB"  
b31b f1			.pastdmark: pop af  
b31c			endm  
# End of macro DMARK
b31c						CALLMONITOR 
b31c cd 6c 93			call break_point_state  
b31f				endm  
# End of macro CALLMONITOR
b31f					endif 
b31f			 
b31f			 
b31f				; TODO add floating point number detection 
b31f					; v5 FORTH_DSP_VALUE 
b31f					FORTH_DSP 
b31f cd b6 9a			call macro_forth_dsp 
b322				endm 
# End of macro FORTH_DSP
b322 7e					ld a,(hl)	; get type of value on TOS 
b323 fe 02				cp DS_TYPE_INUM  
b325 28 03				jr z, .neg_inum 
b327			 
b327					NEXTW 
b327 c3 62 9c			jp macro_next 
b32a				endm 
# End of macro NEXTW
b32a			 
b32a			; float maths 
b32a			 
b32a				if FORTH_ENABLE_FLOATMATH 
b32a					jr .neg_done 
b32a			 
b32a				endif 
b32a					 
b32a			 
b32a			.neg_inum: 
b32a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b32a cd f0 9a			call macro_dsp_valuehl 
b32d				endm 
# End of macro FORTH_DSP_VALUEHL
b32d			 
b32d e5					push hl 
b32e			 
b32e					; destroy value TOS 
b32e			 
b32e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b32e cd a8 9b			call macro_forth_dsp_pop 
b331				endm 
# End of macro FORTH_DSP_POP
b331			 
b331			 
b331					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b331 cd f0 9a			call macro_dsp_valuehl 
b334				endm 
# End of macro FORTH_DSP_VALUEHL
b334			 
b334					; one value on hl get other one back 
b334			 
b334 d1					pop de 
b335			 
b335					; do the sub 
b335			;		ex de, hl 
b335			 
b335 ed 52				sbc hl,de 
b337			 
b337					; save it 
b337			 
b337			;		push hl	 
b337			 
b337					; 
b337			 
b337					; destroy value TOS 
b337			 
b337					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b337 cd a8 9b			call macro_forth_dsp_pop 
b33a				endm 
# End of macro FORTH_DSP_POP
b33a			 
b33a					; TODO push value back onto stack for another op etc 
b33a			 
b33a			;		pop hl 
b33a			 
b33a cd f9 98				call forth_push_numhl 
b33d			.neg_done: 
b33d			 
b33d					NEXTW 
b33d c3 62 9c			jp macro_next 
b340				endm 
# End of macro NEXTW
b340			.DIV: 
b340				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
b340 18				db WORD_SYS_CORE+4             
b341 8d b3			dw .MUL            
b343 02				db 1 + 1 
b344 .. 00			db "/",0              
b346				endm 
# End of macro CWHEAD
b346			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
b346					if DEBUG_FORTH_WORDS_KEY 
b346						DMARK "DIV" 
b346 f5				push af  
b347 3a 5b b3			ld a, (.dmark)  
b34a 32 7a ee			ld (debug_mark),a  
b34d 3a 5c b3			ld a, (.dmark+1)  
b350 32 7b ee			ld (debug_mark+1),a  
b353 3a 5d b3			ld a, (.dmark+2)  
b356 32 7c ee			ld (debug_mark+2),a  
b359 18 03			jr .pastdmark  
b35b ..			.dmark: db "DIV"  
b35e f1			.pastdmark: pop af  
b35f			endm  
# End of macro DMARK
b35f						CALLMONITOR 
b35f cd 6c 93			call break_point_state  
b362				endm  
# End of macro CALLMONITOR
b362					endif 
b362				; TODO add floating point number detection 
b362					; v5 FORTH_DSP_VALUE 
b362					FORTH_DSP 
b362 cd b6 9a			call macro_forth_dsp 
b365				endm 
# End of macro FORTH_DSP
b365 7e					ld a,(hl)	; get type of value on TOS 
b366 fe 02				cp DS_TYPE_INUM  
b368 28 03				jr z, .div_inum 
b36a			 
b36a				if FORTH_ENABLE_FLOATMATH 
b36a					jr .div_done 
b36a			 
b36a				endif 
b36a					NEXTW 
b36a c3 62 9c			jp macro_next 
b36d				endm 
# End of macro NEXTW
b36d			.div_inum: 
b36d			 
b36d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b36d cd f0 9a			call macro_dsp_valuehl 
b370				endm 
# End of macro FORTH_DSP_VALUEHL
b370			 
b370 e5					push hl    ; to go to bc 
b371			 
b371					; destroy value TOS 
b371			 
b371					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b371 cd a8 9b			call macro_forth_dsp_pop 
b374				endm 
# End of macro FORTH_DSP_POP
b374			 
b374			 
b374					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b374 cd f0 9a			call macro_dsp_valuehl 
b377				endm 
# End of macro FORTH_DSP_VALUEHL
b377			 
b377					; hl to go to de 
b377			 
b377 e5					push hl 
b378			 
b378 c1					pop bc 
b379 d1					pop de		 
b37a			 
b37a			 
b37a					if DEBUG_FORTH_MATHS 
b37a						DMARK "DIV" 
b37a				CALLMONITOR 
b37a					endif 
b37a					; one value on hl but move to a get other one back 
b37a			 
b37a			        
b37a cd 1b 8a			call Div16 
b37d			 
b37d			;	push af	 
b37d e5				push hl 
b37e c5				push bc 
b37f			 
b37f					if DEBUG_FORTH_MATHS 
b37f						DMARK "DI1" 
b37f				CALLMONITOR 
b37f					endif 
b37f			 
b37f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b37f cd a8 9b			call macro_forth_dsp_pop 
b382				endm 
# End of macro FORTH_DSP_POP
b382			 
b382			 
b382			 
b382 e1					pop hl    ; result 
b383			 
b383 cd f9 98				call forth_push_numhl 
b386			 
b386 e1					pop hl    ; reminder 
b387			;		ld h,0 
b387			;		ld l,d 
b387			 
b387 cd f9 98				call forth_push_numhl 
b38a			.div_done: 
b38a					NEXTW 
b38a c3 62 9c			jp macro_next 
b38d				endm 
# End of macro NEXTW
b38d			.MUL: 
b38d				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
b38d 19				db WORD_SYS_CORE+5             
b38e d2 b3			dw .MIN            
b390 02				db 1 + 1 
b391 .. 00			db "*",0              
b393				endm 
# End of macro CWHEAD
b393			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
b393				; TODO add floating point number detection 
b393					if DEBUG_FORTH_WORDS_KEY 
b393						DMARK "MUL" 
b393 f5				push af  
b394 3a a8 b3			ld a, (.dmark)  
b397 32 7a ee			ld (debug_mark),a  
b39a 3a a9 b3			ld a, (.dmark+1)  
b39d 32 7b ee			ld (debug_mark+1),a  
b3a0 3a aa b3			ld a, (.dmark+2)  
b3a3 32 7c ee			ld (debug_mark+2),a  
b3a6 18 03			jr .pastdmark  
b3a8 ..			.dmark: db "MUL"  
b3ab f1			.pastdmark: pop af  
b3ac			endm  
# End of macro DMARK
b3ac						CALLMONITOR 
b3ac cd 6c 93			call break_point_state  
b3af				endm  
# End of macro CALLMONITOR
b3af					endif 
b3af					FORTH_DSP 
b3af cd b6 9a			call macro_forth_dsp 
b3b2				endm 
# End of macro FORTH_DSP
b3b2					; v5 FORTH_DSP_VALUE 
b3b2 7e					ld a,(hl)	; get type of value on TOS 
b3b3 fe 02				cp DS_TYPE_INUM  
b3b5 28 03				jr z, .mul_inum 
b3b7			 
b3b7				if FORTH_ENABLE_FLOATMATH 
b3b7					jr .mul_done 
b3b7			 
b3b7				endif 
b3b7			 
b3b7					NEXTW 
b3b7 c3 62 9c			jp macro_next 
b3ba				endm 
# End of macro NEXTW
b3ba			.mul_inum:	 
b3ba			 
b3ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3ba cd f0 9a			call macro_dsp_valuehl 
b3bd				endm 
# End of macro FORTH_DSP_VALUEHL
b3bd			 
b3bd e5					push hl 
b3be			 
b3be					; destroy value TOS 
b3be			 
b3be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3be cd a8 9b			call macro_forth_dsp_pop 
b3c1				endm 
# End of macro FORTH_DSP_POP
b3c1			 
b3c1			 
b3c1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3c1 cd f0 9a			call macro_dsp_valuehl 
b3c4				endm 
# End of macro FORTH_DSP_VALUEHL
b3c4			 
b3c4					; one value on hl but move to a get other one back 
b3c4			 
b3c4 7d					ld a, l 
b3c5			 
b3c5 d1					pop de 
b3c6			 
b3c6					; do the mull 
b3c6			;		ex de, hl 
b3c6			 
b3c6 cd 41 8a				call Mult16 
b3c9					; save it 
b3c9			 
b3c9			;		push hl	 
b3c9			 
b3c9					; 
b3c9			 
b3c9					; destroy value TOS 
b3c9			 
b3c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3c9 cd a8 9b			call macro_forth_dsp_pop 
b3cc				endm 
# End of macro FORTH_DSP_POP
b3cc			 
b3cc					; TODO push value back onto stack for another op etc 
b3cc			 
b3cc			;		pop hl 
b3cc			 
b3cc cd f9 98				call forth_push_numhl 
b3cf			 
b3cf			.mul_done: 
b3cf					NEXTW 
b3cf c3 62 9c			jp macro_next 
b3d2				endm 
# End of macro NEXTW
b3d2			 
b3d2			 
b3d2			 
b3d2			 
b3d2			.MIN: 
b3d2				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
b3d2 49				db WORD_SYS_CORE+53             
b3d3 53 b4			dw .MAX            
b3d5 04				db 3 + 1 
b3d6 .. 00			db "MIN",0              
b3da				endm 
# End of macro CWHEAD
b3da			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
b3da					if DEBUG_FORTH_WORDS_KEY 
b3da						DMARK "MIN" 
b3da f5				push af  
b3db 3a ef b3			ld a, (.dmark)  
b3de 32 7a ee			ld (debug_mark),a  
b3e1 3a f0 b3			ld a, (.dmark+1)  
b3e4 32 7b ee			ld (debug_mark+1),a  
b3e7 3a f1 b3			ld a, (.dmark+2)  
b3ea 32 7c ee			ld (debug_mark+2),a  
b3ed 18 03			jr .pastdmark  
b3ef ..			.dmark: db "MIN"  
b3f2 f1			.pastdmark: pop af  
b3f3			endm  
# End of macro DMARK
b3f3						CALLMONITOR 
b3f3 cd 6c 93			call break_point_state  
b3f6				endm  
# End of macro CALLMONITOR
b3f6					endif 
b3f6					; get u2 
b3f6			 
b3f6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3f6 cd f0 9a			call macro_dsp_valuehl 
b3f9				endm 
# End of macro FORTH_DSP_VALUEHL
b3f9			 
b3f9 e5					push hl   ; u2 
b3fa			 
b3fa					; destroy value TOS 
b3fa			 
b3fa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b3fa cd a8 9b			call macro_forth_dsp_pop 
b3fd				endm 
# End of macro FORTH_DSP_POP
b3fd			 
b3fd					; get u1 
b3fd			 
b3fd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b3fd cd f0 9a			call macro_dsp_valuehl 
b400				endm 
# End of macro FORTH_DSP_VALUEHL
b400			 
b400 e5					push hl  ; u1 
b401			 
b401					; destroy value TOS 
b401			 
b401					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b401 cd a8 9b			call macro_forth_dsp_pop 
b404				endm 
# End of macro FORTH_DSP_POP
b404			 
b404 b7			 or a      ;clear carry flag 
b405 e1			  pop hl    ; u1 
b406 d1			  pop de    ; u2 
b407 e5				push hl   ; saved in case hl is lowest 
b408 ed 52		  sbc hl,de 
b40a 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
b40c			 
b40c e1				pop hl 
b40d					if DEBUG_FORTH_WORDS 
b40d						DMARK "MIN" 
b40d f5				push af  
b40e 3a 22 b4			ld a, (.dmark)  
b411 32 7a ee			ld (debug_mark),a  
b414 3a 23 b4			ld a, (.dmark+1)  
b417 32 7b ee			ld (debug_mark+1),a  
b41a 3a 24 b4			ld a, (.dmark+2)  
b41d 32 7c ee			ld (debug_mark+2),a  
b420 18 03			jr .pastdmark  
b422 ..			.dmark: db "MIN"  
b425 f1			.pastdmark: pop af  
b426			endm  
# End of macro DMARK
b426						CALLMONITOR 
b426 cd 6c 93			call break_point_state  
b429				endm  
# End of macro CALLMONITOR
b429					endif 
b429 cd f9 98				call forth_push_numhl 
b42c			 
b42c				       NEXTW 
b42c c3 62 9c			jp macro_next 
b42f				endm 
# End of macro NEXTW
b42f			 
b42f			.mincont:  
b42f c1				pop bc   ; tidy up 
b430 eb				ex de , hl  
b431					if DEBUG_FORTH_WORDS 
b431						DMARK "MI1" 
b431 f5				push af  
b432 3a 46 b4			ld a, (.dmark)  
b435 32 7a ee			ld (debug_mark),a  
b438 3a 47 b4			ld a, (.dmark+1)  
b43b 32 7b ee			ld (debug_mark+1),a  
b43e 3a 48 b4			ld a, (.dmark+2)  
b441 32 7c ee			ld (debug_mark+2),a  
b444 18 03			jr .pastdmark  
b446 ..			.dmark: db "MI1"  
b449 f1			.pastdmark: pop af  
b44a			endm  
# End of macro DMARK
b44a						CALLMONITOR 
b44a cd 6c 93			call break_point_state  
b44d				endm  
# End of macro CALLMONITOR
b44d					endif 
b44d cd f9 98				call forth_push_numhl 
b450			 
b450				       NEXTW 
b450 c3 62 9c			jp macro_next 
b453				endm 
# End of macro NEXTW
b453			.MAX: 
b453				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
b453 4a				db WORD_SYS_CORE+54             
b454 d4 b4			dw .RND16            
b456 04				db 3 + 1 
b457 .. 00			db "MAX",0              
b45b				endm 
# End of macro CWHEAD
b45b			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
b45b					if DEBUG_FORTH_WORDS_KEY 
b45b						DMARK "MAX" 
b45b f5				push af  
b45c 3a 70 b4			ld a, (.dmark)  
b45f 32 7a ee			ld (debug_mark),a  
b462 3a 71 b4			ld a, (.dmark+1)  
b465 32 7b ee			ld (debug_mark+1),a  
b468 3a 72 b4			ld a, (.dmark+2)  
b46b 32 7c ee			ld (debug_mark+2),a  
b46e 18 03			jr .pastdmark  
b470 ..			.dmark: db "MAX"  
b473 f1			.pastdmark: pop af  
b474			endm  
# End of macro DMARK
b474						CALLMONITOR 
b474 cd 6c 93			call break_point_state  
b477				endm  
# End of macro CALLMONITOR
b477					endif 
b477					; get u2 
b477			 
b477					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b477 cd f0 9a			call macro_dsp_valuehl 
b47a				endm 
# End of macro FORTH_DSP_VALUEHL
b47a			 
b47a e5					push hl   ; u2 
b47b			 
b47b					; destroy value TOS 
b47b			 
b47b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b47b cd a8 9b			call macro_forth_dsp_pop 
b47e				endm 
# End of macro FORTH_DSP_POP
b47e			 
b47e					; get u1 
b47e			 
b47e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b47e cd f0 9a			call macro_dsp_valuehl 
b481				endm 
# End of macro FORTH_DSP_VALUEHL
b481			 
b481 e5					push hl  ; u1 
b482			 
b482					; destroy value TOS 
b482			 
b482					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b482 cd a8 9b			call macro_forth_dsp_pop 
b485				endm 
# End of macro FORTH_DSP_POP
b485			 
b485 b7			 or a      ;clear carry flag 
b486 e1			  pop hl    ; u1 
b487 d1			  pop de    ; u2 
b488 e5				push hl   ; saved in case hl is lowest 
b489 ed 52		  sbc hl,de 
b48b 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
b48d			 
b48d e1				pop hl 
b48e					if DEBUG_FORTH_WORDS 
b48e						DMARK "MAX" 
b48e f5				push af  
b48f 3a a3 b4			ld a, (.dmark)  
b492 32 7a ee			ld (debug_mark),a  
b495 3a a4 b4			ld a, (.dmark+1)  
b498 32 7b ee			ld (debug_mark+1),a  
b49b 3a a5 b4			ld a, (.dmark+2)  
b49e 32 7c ee			ld (debug_mark+2),a  
b4a1 18 03			jr .pastdmark  
b4a3 ..			.dmark: db "MAX"  
b4a6 f1			.pastdmark: pop af  
b4a7			endm  
# End of macro DMARK
b4a7						CALLMONITOR 
b4a7 cd 6c 93			call break_point_state  
b4aa				endm  
# End of macro CALLMONITOR
b4aa					endif 
b4aa cd f9 98				call forth_push_numhl 
b4ad			 
b4ad				       NEXTW 
b4ad c3 62 9c			jp macro_next 
b4b0				endm 
# End of macro NEXTW
b4b0			 
b4b0			.maxcont:  
b4b0 c1				pop bc   ; tidy up 
b4b1 eb				ex de , hl  
b4b2					if DEBUG_FORTH_WORDS 
b4b2						DMARK "MA1" 
b4b2 f5				push af  
b4b3 3a c7 b4			ld a, (.dmark)  
b4b6 32 7a ee			ld (debug_mark),a  
b4b9 3a c8 b4			ld a, (.dmark+1)  
b4bc 32 7b ee			ld (debug_mark+1),a  
b4bf 3a c9 b4			ld a, (.dmark+2)  
b4c2 32 7c ee			ld (debug_mark+2),a  
b4c5 18 03			jr .pastdmark  
b4c7 ..			.dmark: db "MA1"  
b4ca f1			.pastdmark: pop af  
b4cb			endm  
# End of macro DMARK
b4cb						CALLMONITOR 
b4cb cd 6c 93			call break_point_state  
b4ce				endm  
# End of macro CALLMONITOR
b4ce					endif 
b4ce cd f9 98				call forth_push_numhl 
b4d1				       NEXTW 
b4d1 c3 62 9c			jp macro_next 
b4d4				endm 
# End of macro NEXTW
b4d4			 
b4d4			.RND16: 
b4d4				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
b4d4 4e				db WORD_SYS_CORE+58             
b4d5 03 b5			dw .RND8            
b4d7 06				db 5 + 1 
b4d8 .. 00			db "RND16",0              
b4de				endm 
# End of macro CWHEAD
b4de			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
b4de					if DEBUG_FORTH_WORDS_KEY 
b4de						DMARK "R16" 
b4de f5				push af  
b4df 3a f3 b4			ld a, (.dmark)  
b4e2 32 7a ee			ld (debug_mark),a  
b4e5 3a f4 b4			ld a, (.dmark+1)  
b4e8 32 7b ee			ld (debug_mark+1),a  
b4eb 3a f5 b4			ld a, (.dmark+2)  
b4ee 32 7c ee			ld (debug_mark+2),a  
b4f1 18 03			jr .pastdmark  
b4f3 ..			.dmark: db "R16"  
b4f6 f1			.pastdmark: pop af  
b4f7			endm  
# End of macro DMARK
b4f7						CALLMONITOR 
b4f7 cd 6c 93			call break_point_state  
b4fa				endm  
# End of macro CALLMONITOR
b4fa					endif 
b4fa cd e5 89				call prng16  
b4fd cd f9 98				call forth_push_numhl 
b500				       NEXTW 
b500 c3 62 9c			jp macro_next 
b503				endm 
# End of macro NEXTW
b503			.RND8: 
b503				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
b503 60				db WORD_SYS_CORE+76             
b504 38 b5			dw .RND            
b506 05				db 4 + 1 
b507 .. 00			db "RND8",0              
b50c				endm 
# End of macro CWHEAD
b50c			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
b50c					if DEBUG_FORTH_WORDS_KEY 
b50c						DMARK "RN8" 
b50c f5				push af  
b50d 3a 21 b5			ld a, (.dmark)  
b510 32 7a ee			ld (debug_mark),a  
b513 3a 22 b5			ld a, (.dmark+1)  
b516 32 7b ee			ld (debug_mark+1),a  
b519 3a 23 b5			ld a, (.dmark+2)  
b51c 32 7c ee			ld (debug_mark+2),a  
b51f 18 03			jr .pastdmark  
b521 ..			.dmark: db "RN8"  
b524 f1			.pastdmark: pop af  
b525			endm  
# End of macro DMARK
b525						CALLMONITOR 
b525 cd 6c 93			call break_point_state  
b528				endm  
# End of macro CALLMONITOR
b528					endif 
b528 2a bb eb				ld hl,(xrandc) 
b52b 23					inc hl 
b52c cd ff 89				call xrnd 
b52f 6f					ld l,a	 
b530 26 00				ld h,0 
b532 cd f9 98				call forth_push_numhl 
b535				       NEXTW 
b535 c3 62 9c			jp macro_next 
b538				endm 
# End of macro NEXTW
b538			.RND: 
b538				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
b538 60				db WORD_SYS_CORE+76             
b539 3e b6			dw .ENDMATHS            
b53b 04				db 3 + 1 
b53c .. 00			db "RND",0              
b540				endm 
# End of macro CWHEAD
b540			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
b540			 
b540					if DEBUG_FORTH_WORDS_KEY 
b540						DMARK "RND" 
b540 f5				push af  
b541 3a 55 b5			ld a, (.dmark)  
b544 32 7a ee			ld (debug_mark),a  
b547 3a 56 b5			ld a, (.dmark+1)  
b54a 32 7b ee			ld (debug_mark+1),a  
b54d 3a 57 b5			ld a, (.dmark+2)  
b550 32 7c ee			ld (debug_mark+2),a  
b553 18 03			jr .pastdmark  
b555 ..			.dmark: db "RND"  
b558 f1			.pastdmark: pop af  
b559			endm  
# End of macro DMARK
b559						CALLMONITOR 
b559 cd 6c 93			call break_point_state  
b55c				endm  
# End of macro CALLMONITOR
b55c					endif 
b55c					 
b55c					FORTH_DSP_VALUEHL    ; upper range 
b55c cd f0 9a			call macro_dsp_valuehl 
b55f				endm 
# End of macro FORTH_DSP_VALUEHL
b55f			 
b55f 22 bf eb				ld (LFSRSeed), hl	 
b562			 
b562					if DEBUG_FORTH_WORDS 
b562						DMARK "RN1" 
b562 f5				push af  
b563 3a 77 b5			ld a, (.dmark)  
b566 32 7a ee			ld (debug_mark),a  
b569 3a 78 b5			ld a, (.dmark+1)  
b56c 32 7b ee			ld (debug_mark+1),a  
b56f 3a 79 b5			ld a, (.dmark+2)  
b572 32 7c ee			ld (debug_mark+2),a  
b575 18 03			jr .pastdmark  
b577 ..			.dmark: db "RN1"  
b57a f1			.pastdmark: pop af  
b57b			endm  
# End of macro DMARK
b57b						CALLMONITOR 
b57b cd 6c 93			call break_point_state  
b57e				endm  
# End of macro CALLMONITOR
b57e					endif 
b57e					FORTH_DSP_POP 
b57e cd a8 9b			call macro_forth_dsp_pop 
b581				endm 
# End of macro FORTH_DSP_POP
b581			 
b581					FORTH_DSP_VALUEHL    ; low range 
b581 cd f0 9a			call macro_dsp_valuehl 
b584				endm 
# End of macro FORTH_DSP_VALUEHL
b584			 
b584					if DEBUG_FORTH_WORDS 
b584						DMARK "RN2" 
b584 f5				push af  
b585 3a 99 b5			ld a, (.dmark)  
b588 32 7a ee			ld (debug_mark),a  
b58b 3a 9a b5			ld a, (.dmark+1)  
b58e 32 7b ee			ld (debug_mark+1),a  
b591 3a 9b b5			ld a, (.dmark+2)  
b594 32 7c ee			ld (debug_mark+2),a  
b597 18 03			jr .pastdmark  
b599 ..			.dmark: db "RN2"  
b59c f1			.pastdmark: pop af  
b59d			endm  
# End of macro DMARK
b59d						CALLMONITOR 
b59d cd 6c 93			call break_point_state  
b5a0				endm  
# End of macro CALLMONITOR
b5a0					endif 
b5a0 22 c1 eb				ld (LFSRSeed+2), hl 
b5a3			 
b5a3					FORTH_DSP_POP 
b5a3 cd a8 9b			call macro_forth_dsp_pop 
b5a6				endm 
# End of macro FORTH_DSP_POP
b5a6			 
b5a6 e5					push hl 
b5a7			 
b5a7 e1			.inrange:	pop hl 
b5a8 cd e5 89				call prng16  
b5ab					if DEBUG_FORTH_WORDS 
b5ab						DMARK "RN3" 
b5ab f5				push af  
b5ac 3a c0 b5			ld a, (.dmark)  
b5af 32 7a ee			ld (debug_mark),a  
b5b2 3a c1 b5			ld a, (.dmark+1)  
b5b5 32 7b ee			ld (debug_mark+1),a  
b5b8 3a c2 b5			ld a, (.dmark+2)  
b5bb 32 7c ee			ld (debug_mark+2),a  
b5be 18 03			jr .pastdmark  
b5c0 ..			.dmark: db "RN3"  
b5c3 f1			.pastdmark: pop af  
b5c4			endm  
# End of macro DMARK
b5c4						CALLMONITOR 
b5c4 cd 6c 93			call break_point_state  
b5c7				endm  
# End of macro CALLMONITOR
b5c7					endif 
b5c7					 
b5c7					; if the range is 8bit knock out the high byte 
b5c7			 
b5c7 ed 5b bf eb			ld de, (LFSRSeed)     ; check high level 
b5cb			 
b5cb 3e 00				ld a, 0 
b5cd ba					cp d  
b5ce 20 1e				jr nz, .hirange 
b5d0 26 00				ld h, 0   ; knock it down to 8bit 
b5d2			 
b5d2					if DEBUG_FORTH_WORDS 
b5d2						DMARK "RNk" 
b5d2 f5				push af  
b5d3 3a e7 b5			ld a, (.dmark)  
b5d6 32 7a ee			ld (debug_mark),a  
b5d9 3a e8 b5			ld a, (.dmark+1)  
b5dc 32 7b ee			ld (debug_mark+1),a  
b5df 3a e9 b5			ld a, (.dmark+2)  
b5e2 32 7c ee			ld (debug_mark+2),a  
b5e5 18 03			jr .pastdmark  
b5e7 ..			.dmark: db "RNk"  
b5ea f1			.pastdmark: pop af  
b5eb			endm  
# End of macro DMARK
b5eb						CALLMONITOR 
b5eb cd 6c 93			call break_point_state  
b5ee				endm  
# End of macro CALLMONITOR
b5ee					endif 
b5ee			.hirange:   
b5ee e5					push hl  
b5ef b7					or a  
b5f0 ed 52		                sbc hl, de 
b5f2			 
b5f2					;call cmp16 
b5f2			 
b5f2 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
b5f4 e1					pop hl 
b5f5 e5					push hl 
b5f6			 
b5f6					if DEBUG_FORTH_WORDS 
b5f6						DMARK "RN4" 
b5f6 f5				push af  
b5f7 3a 0b b6			ld a, (.dmark)  
b5fa 32 7a ee			ld (debug_mark),a  
b5fd 3a 0c b6			ld a, (.dmark+1)  
b600 32 7b ee			ld (debug_mark+1),a  
b603 3a 0d b6			ld a, (.dmark+2)  
b606 32 7c ee			ld (debug_mark+2),a  
b609 18 03			jr .pastdmark  
b60b ..			.dmark: db "RN4"  
b60e f1			.pastdmark: pop af  
b60f			endm  
# End of macro DMARK
b60f						CALLMONITOR 
b60f cd 6c 93			call break_point_state  
b612				endm  
# End of macro CALLMONITOR
b612					endif 
b612 ed 5b c1 eb			ld de, (LFSRSeed+2)   ; check low range 
b616					;call cmp16 
b616				 
b616 b7					or a  
b617 ed 52		                sbc hl, de 
b619 38 8c				jr c, .inrange 
b61b			 
b61b e1					pop hl 
b61c					 
b61c					if DEBUG_FORTH_WORDS 
b61c						DMARK "RNd" 
b61c f5				push af  
b61d 3a 31 b6			ld a, (.dmark)  
b620 32 7a ee			ld (debug_mark),a  
b623 3a 32 b6			ld a, (.dmark+1)  
b626 32 7b ee			ld (debug_mark+1),a  
b629 3a 33 b6			ld a, (.dmark+2)  
b62c 32 7c ee			ld (debug_mark+2),a  
b62f 18 03			jr .pastdmark  
b631 ..			.dmark: db "RNd"  
b634 f1			.pastdmark: pop af  
b635			endm  
# End of macro DMARK
b635						CALLMONITOR 
b635 cd 6c 93			call break_point_state  
b638				endm  
# End of macro CALLMONITOR
b638					endif 
b638			 
b638			 
b638 cd f9 98				call forth_push_numhl 
b63b				       NEXTW 
b63b c3 62 9c			jp macro_next 
b63e				endm 
# End of macro NEXTW
b63e			 
b63e			.ENDMATHS: 
b63e			 
b63e			; eof 
b63e			 
# End of file forth_words_maths.asm
b63e			include "forth_words_display.asm" 
b63e			 
b63e			; | ## Display Words 
b63e			 
b63e			.INFO: 
b63e			 
b63e				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
b63e 62				db WORD_SYS_CORE+78             
b63f 5b b6			dw .ATP            
b641 05				db 4 + 1 
b642 .. 00			db "INFO",0              
b647				endm 
# End of macro CWHEAD
b647			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
b647					FORTH_DSP_VALUEHL 
b647 cd f0 9a			call macro_dsp_valuehl 
b64a				endm 
# End of macro FORTH_DSP_VALUEHL
b64a			 
b64a					FORTH_DSP_POP 
b64a cd a8 9b			call macro_forth_dsp_pop 
b64d				endm 
# End of macro FORTH_DSP_POP
b64d			 
b64d e5					push hl 
b64e			 
b64e					FORTH_DSP_VALUEHL 
b64e cd f0 9a			call macro_dsp_valuehl 
b651				endm 
# End of macro FORTH_DSP_VALUEHL
b651			 
b651					FORTH_DSP_POP 
b651 cd a8 9b			call macro_forth_dsp_pop 
b654				endm 
# End of macro FORTH_DSP_POP
b654			 
b654 d1					pop de 
b655			 
b655 cd 22 88				call info_panel 
b658			 
b658			 
b658					NEXTW 
b658 c3 62 9c			jp macro_next 
b65b				endm 
# End of macro NEXTW
b65b			.ATP: 
b65b				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
b65b 62				db WORD_SYS_CORE+78             
b65c d2 b6			dw .FB            
b65e 04				db 3 + 1 
b65f .. 00			db "AT?",0              
b663				endm 
# End of macro CWHEAD
b663			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
b663					if DEBUG_FORTH_WORDS_KEY 
b663						DMARK "AT?" 
b663 f5				push af  
b664 3a 78 b6			ld a, (.dmark)  
b667 32 7a ee			ld (debug_mark),a  
b66a 3a 79 b6			ld a, (.dmark+1)  
b66d 32 7b ee			ld (debug_mark+1),a  
b670 3a 7a b6			ld a, (.dmark+2)  
b673 32 7c ee			ld (debug_mark+2),a  
b676 18 03			jr .pastdmark  
b678 ..			.dmark: db "AT?"  
b67b f1			.pastdmark: pop af  
b67c			endm  
# End of macro DMARK
b67c						CALLMONITOR 
b67c cd 6c 93			call break_point_state  
b67f				endm  
# End of macro CALLMONITOR
b67f					endif 
b67f 3a 49 eb				ld a, (f_cursor_ptr) 
b682			 
b682			if DEBUG_FORTH_WORDS 
b682				DMARK "AT?" 
b682 f5				push af  
b683 3a 97 b6			ld a, (.dmark)  
b686 32 7a ee			ld (debug_mark),a  
b689 3a 98 b6			ld a, (.dmark+1)  
b68c 32 7b ee			ld (debug_mark+1),a  
b68f 3a 99 b6			ld a, (.dmark+2)  
b692 32 7c ee			ld (debug_mark+2),a  
b695 18 03			jr .pastdmark  
b697 ..			.dmark: db "AT?"  
b69a f1			.pastdmark: pop af  
b69b			endm  
# End of macro DMARK
b69b				CALLMONITOR 
b69b cd 6c 93			call break_point_state  
b69e				endm  
# End of macro CALLMONITOR
b69e			endif	 
b69e					; count the number of rows 
b69e			 
b69e 06 00				ld b, 0 
b6a0 4f			.atpr:		ld c, a    ; save in case we go below zero 
b6a1 d6 28				sub display_cols 
b6a3 f2 a9 b6				jp p, .atprunder 
b6a6 04					inc b 
b6a7 18 f7				jr .atpr 
b6a9			.atprunder:	 
b6a9			if DEBUG_FORTH_WORDS 
b6a9				DMARK "A?2" 
b6a9 f5				push af  
b6aa 3a be b6			ld a, (.dmark)  
b6ad 32 7a ee			ld (debug_mark),a  
b6b0 3a bf b6			ld a, (.dmark+1)  
b6b3 32 7b ee			ld (debug_mark+1),a  
b6b6 3a c0 b6			ld a, (.dmark+2)  
b6b9 32 7c ee			ld (debug_mark+2),a  
b6bc 18 03			jr .pastdmark  
b6be ..			.dmark: db "A?2"  
b6c1 f1			.pastdmark: pop af  
b6c2			endm  
# End of macro DMARK
b6c2				CALLMONITOR 
b6c2 cd 6c 93			call break_point_state  
b6c5				endm  
# End of macro CALLMONITOR
b6c5			endif	 
b6c5 26 00				ld h, 0 
b6c7 69					ld l, c 
b6c8 cd f9 98				call forth_push_numhl 
b6cb 68					ld l, b  
b6cc cd f9 98				call forth_push_numhl 
b6cf			 
b6cf			 
b6cf				NEXTW 
b6cf c3 62 9c			jp macro_next 
b6d2				endm 
# End of macro NEXTW
b6d2			 
b6d2			.FB: 
b6d2				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
b6d2 1b				db WORD_SYS_CORE+7             
b6d3 20 b7			dw .EMIT            
b6d5 03				db 2 + 1 
b6d6 .. 00			db "FB",0              
b6d9				endm 
# End of macro CWHEAD
b6d9			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
b6d9			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
b6d9			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
b6d9			; | | If automatic display is off then updates will not be shown until DRAW is used. 
b6d9					if DEBUG_FORTH_WORDS_KEY 
b6d9						DMARK "FB." 
b6d9 f5				push af  
b6da 3a ee b6			ld a, (.dmark)  
b6dd 32 7a ee			ld (debug_mark),a  
b6e0 3a ef b6			ld a, (.dmark+1)  
b6e3 32 7b ee			ld (debug_mark+1),a  
b6e6 3a f0 b6			ld a, (.dmark+2)  
b6e9 32 7c ee			ld (debug_mark+2),a  
b6ec 18 03			jr .pastdmark  
b6ee ..			.dmark: db "FB."  
b6f1 f1			.pastdmark: pop af  
b6f2			endm  
# End of macro DMARK
b6f2						CALLMONITOR 
b6f2 cd 6c 93			call break_point_state  
b6f5				endm  
# End of macro CALLMONITOR
b6f5					endif 
b6f5			 
b6f5					FORTH_DSP_VALUEHL 
b6f5 cd f0 9a			call macro_dsp_valuehl 
b6f8				endm 
# End of macro FORTH_DSP_VALUEHL
b6f8			 
b6f8 7d					ld a, l 
b6f9 fe 01				cp 1 
b6fb 20 05				jr nz, .fbn1 
b6fd 21 1f ed				ld hl, display_fb1 
b700 18 15				jr .fbset 
b702 fe 02		.fbn1:		cp 2 
b704 20 05				jr nz, .fbn2 
b706 21 dd eb				ld hl, display_fb2 
b709 18 0c				jr .fbset 
b70b fe 03		.fbn2:		cp 3 
b70d 20 05				jr nz, .fbn3 
b70f 21 7e ec				ld hl, display_fb3 
b712 18 03				jr .fbset 
b714			.fbn3:		 ; if invalid number select first 
b714 21 1f ed				ld hl, display_fb1 
b717 22 db eb		.fbset:		ld (display_fb_active), hl 
b71a			 
b71a					FORTH_DSP_POP 
b71a cd a8 9b			call macro_forth_dsp_pop 
b71d				endm 
# End of macro FORTH_DSP_POP
b71d			 
b71d					NEXTW 
b71d c3 62 9c			jp macro_next 
b720				endm 
# End of macro NEXTW
b720			 
b720			 
b720			.EMIT: 
b720				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
b720 1b				db WORD_SYS_CORE+7             
b721 71 b7			dw .DOTH            
b723 05				db 4 + 1 
b724 .. 00			db "EMIT",0              
b729				endm 
# End of macro CWHEAD
b729			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
b729					; get value off TOS and display it 
b729			 
b729					if DEBUG_FORTH_WORDS_KEY 
b729						DMARK "EMT" 
b729 f5				push af  
b72a 3a 3e b7			ld a, (.dmark)  
b72d 32 7a ee			ld (debug_mark),a  
b730 3a 3f b7			ld a, (.dmark+1)  
b733 32 7b ee			ld (debug_mark+1),a  
b736 3a 40 b7			ld a, (.dmark+2)  
b739 32 7c ee			ld (debug_mark+2),a  
b73c 18 03			jr .pastdmark  
b73e ..			.dmark: db "EMT"  
b741 f1			.pastdmark: pop af  
b742			endm  
# End of macro DMARK
b742						CALLMONITOR 
b742 cd 6c 93			call break_point_state  
b745				endm  
# End of macro CALLMONITOR
b745					endif 
b745			 
b745					FORTH_DSP_VALUEHL 
b745 cd f0 9a			call macro_dsp_valuehl 
b748				endm 
# End of macro FORTH_DSP_VALUEHL
b748			 
b748 7d					ld a,l 
b749			 
b749					; TODO write to display 
b749			 
b749 32 5e e5				ld (os_input), a 
b74c 3e 00				ld a, 0 
b74e 32 5f e5				ld (os_input+1), a 
b751					 
b751 3a 49 eb				ld a, (f_cursor_ptr) 
b754 11 5e e5				ld de, os_input 
b757 cd a4 88				call str_at_display 
b75a			 
b75a			 
b75a 3a 27 eb				ld a,(cli_autodisplay) 
b75d fe 00				cp 0 
b75f 28 03				jr z, .enoupdate 
b761 cd b4 88						call update_display 
b764					.enoupdate: 
b764			 
b764 3a 49 eb				ld a, (f_cursor_ptr) 
b767 3c					inc a 
b768 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
b76b			 
b76b			 
b76b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b76b cd a8 9b			call macro_forth_dsp_pop 
b76e				endm 
# End of macro FORTH_DSP_POP
b76e			  
b76e			 
b76e					NEXTW 
b76e c3 62 9c			jp macro_next 
b771				endm 
# End of macro NEXTW
b771			.DOTH: 
b771				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
b771 1c				db WORD_SYS_CORE+8             
b772 a1 b7			dw .DOTF            
b774 03				db 2 + 1 
b775 .. 00			db ".-",0              
b778				endm 
# End of macro CWHEAD
b778			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
b778					; get value off TOS and display it 
b778					if DEBUG_FORTH_WORDS_KEY 
b778						DMARK "DTD" 
b778 f5				push af  
b779 3a 8d b7			ld a, (.dmark)  
b77c 32 7a ee			ld (debug_mark),a  
b77f 3a 8e b7			ld a, (.dmark+1)  
b782 32 7b ee			ld (debug_mark+1),a  
b785 3a 8f b7			ld a, (.dmark+2)  
b788 32 7c ee			ld (debug_mark+2),a  
b78b 18 03			jr .pastdmark  
b78d ..			.dmark: db "DTD"  
b790 f1			.pastdmark: pop af  
b791			endm  
# End of macro DMARK
b791						CALLMONITOR 
b791 cd 6c 93			call break_point_state  
b794				endm  
# End of macro CALLMONITOR
b794					endif 
b794 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
b796 3e 00			ld a, 0 
b798 32 28 eb			ld (cli_mvdot), a 
b79b c3 f8 b7			jp .dotgo 
b79e				NEXTW 
b79e c3 62 9c			jp macro_next 
b7a1				endm 
# End of macro NEXTW
b7a1			.DOTF: 
b7a1				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
b7a1 1c				db WORD_SYS_CORE+8             
b7a2 cf b7			dw .DOT            
b7a4 03				db 2 + 1 
b7a5 .. 00			db ".>",0              
b7a8				endm 
# End of macro CWHEAD
b7a8			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
b7a8					; get value off TOS and display it 
b7a8			        ; TODO BUG adds extra spaces 
b7a8			        ; TODO BUG handle numerics? 
b7a8					if DEBUG_FORTH_WORDS_KEY 
b7a8						DMARK "DTC" 
b7a8 f5				push af  
b7a9 3a bd b7			ld a, (.dmark)  
b7ac 32 7a ee			ld (debug_mark),a  
b7af 3a be b7			ld a, (.dmark+1)  
b7b2 32 7b ee			ld (debug_mark+1),a  
b7b5 3a bf b7			ld a, (.dmark+2)  
b7b8 32 7c ee			ld (debug_mark+2),a  
b7bb 18 03			jr .pastdmark  
b7bd ..			.dmark: db "DTC"  
b7c0 f1			.pastdmark: pop af  
b7c1			endm  
# End of macro DMARK
b7c1						CALLMONITOR 
b7c1 cd 6c 93			call break_point_state  
b7c4				endm  
# End of macro CALLMONITOR
b7c4					endif 
b7c4 3e 01			ld a, 1 
b7c6 32 28 eb			ld (cli_mvdot), a 
b7c9 c3 f8 b7			jp .dotgo 
b7cc				NEXTW 
b7cc c3 62 9c			jp macro_next 
b7cf				endm 
# End of macro NEXTW
b7cf			 
b7cf			.DOT: 
b7cf				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
b7cf 1c				db WORD_SYS_CORE+8             
b7d0 5b b8			dw .CLS            
b7d2 02				db 1 + 1 
b7d3 .. 00			db ".",0              
b7d5				endm 
# End of macro CWHEAD
b7d5			        ; | . ( u -- ) Display TOS | DONE 
b7d5					; get value off TOS and display it 
b7d5			 
b7d5					if DEBUG_FORTH_WORDS_KEY 
b7d5						DMARK "DOT" 
b7d5 f5				push af  
b7d6 3a ea b7			ld a, (.dmark)  
b7d9 32 7a ee			ld (debug_mark),a  
b7dc 3a eb b7			ld a, (.dmark+1)  
b7df 32 7b ee			ld (debug_mark+1),a  
b7e2 3a ec b7			ld a, (.dmark+2)  
b7e5 32 7c ee			ld (debug_mark+2),a  
b7e8 18 03			jr .pastdmark  
b7ea ..			.dmark: db "DOT"  
b7ed f1			.pastdmark: pop af  
b7ee			endm  
# End of macro DMARK
b7ee						CALLMONITOR 
b7ee cd 6c 93			call break_point_state  
b7f1				endm  
# End of macro CALLMONITOR
b7f1					endif 
b7f1 3e 00			ld a, 0 
b7f3 32 28 eb			ld (cli_mvdot), a 
b7f6 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
b7f8				 
b7f8			 
b7f8			.dotgo: 
b7f8			 
b7f8			; move up type to on stack for parserv5 
b7f8					FORTH_DSP 
b7f8 cd b6 9a			call macro_forth_dsp 
b7fb				endm 
# End of macro FORTH_DSP
b7fb				;FORTH_DSP_VALUE  
b7fb			 
b7fb			if DEBUG_FORTH_DOT 
b7fb				DMARK "DOT" 
b7fb				CALLMONITOR 
b7fb			endif	 
b7fb			;		.print: 
b7fb			 
b7fb 7e				ld a,(hl)  ; work out what type of value is on the TOS 
b7fc 23				inc hl   ; position to the actual value 
b7fd fe 01			cp DS_TYPE_STR 
b7ff 20 06			jr nz, .dotnum1  
b801			 
b801			; display string 
b801				FORTH_DSP_VALUE  
b801 cd d9 9a			call macro_forth_dsp_value 
b804				endm 
# End of macro FORTH_DSP_VALUE
b804 eb				ex de,hl 
b805 18 11			jr .dotwrite 
b807			 
b807			.dotnum1: 
b807 fe 02			cp DS_TYPE_INUM 
b809 20 0c			jr nz, .dotflot 
b80b			 
b80b			 
b80b			; display number 
b80b			 
b80b			;	push hl 
b80b			;	call clear_display 
b80b			;	pop hl 
b80b			 
b80b 5e				ld e, (hl) 
b80c 23				inc hl 
b80d 56				ld d, (hl) 
b80e 21 60 e3			ld hl, scratch 
b811			if DEBUG_FORTH_DOT 
b811				DMARK "DT1" 
b811				CALLMONITOR 
b811			endif	 
b811			 
b811 cd cb 8e			call uitoa_16 
b814 eb				ex de,hl 
b815			 
b815			if DEBUG_FORTH_DOT 
b815				DMARK "DT2" 
b815				CALLMONITOR 
b815			endif	 
b815			 
b815			;	ld de, os_word_scratch 
b815 18 01			jr .dotwrite 
b817			 
b817 00			.dotflot:   nop 
b818			; TODO print floating point number 
b818			 
b818			.dotwrite:		 
b818			 
b818					; if c is set then set all '-' to spaces 
b818					; need to also take into account .>  
b818			 
b818 3e 01				ld a, 1 
b81a b9					cp c 
b81b 20 13				jr nz, .nodashswap 
b81d			 
b81d					; DE has the string to write, working with HL 
b81d			 
b81d 06 ff				ld b, 255 
b81f d5					push de 
b820 e1					pop hl 
b821			 
b821			if DEBUG_FORTH_DOT 
b821				DMARK "DT-" 
b821				CALLMONITOR 
b821			endif	 
b821 7e			.dashscan:	ld a, (hl) 
b822 fe 00				cp 0 
b824 28 0a				jr z, .nodashswap 
b826 fe 2d				cp '-' 
b828 20 03				jr nz, .dashskip 
b82a 3e 20				ld a, ' ' 
b82c 77					ld (hl), a 
b82d 23			.dashskip:	inc hl 
b82e			if DEBUG_FORTH_DOT 
b82e				DMARK "D-2" 
b82e				CALLMONITOR 
b82e			endif	 
b82e 10 f1				djnz .dashscan 
b830			 
b830			if DEBUG_FORTH_DOT 
b830				DMARK "D-1" 
b830				CALLMONITOR 
b830			endif	 
b830			 
b830			.nodashswap: 
b830			 
b830 e5					push hl   ; save string start in case we need to advance print 
b831			 
b831 3a 49 eb				ld a, (f_cursor_ptr) 
b834 cd a4 88				call str_at_display 
b837 3a 27 eb				ld a,(cli_autodisplay) 
b83a fe 00				cp 0 
b83c 28 03				jr z, .noupdate 
b83e cd b4 88						call update_display 
b841					.noupdate: 
b841			 
b841			 
b841					; see if we need to advance the print position 
b841			 
b841 e1					pop hl   ; get back string 
b842			 
b842 3a 28 eb				ld a, (cli_mvdot) 
b845			if DEBUG_FORTH_DOT 
b845					ld e,a 
b845				DMARK "D>1" 
b845				CALLMONITOR 
b845			endif	 
b845 fe 00				cp 0 
b847 28 0c				jr z, .noadv 
b849					; yes, lets advance the print position 
b849 3e 00				ld a, 0 
b84b cd 27 8f				call strlent 
b84e 3a 49 eb				ld a, (f_cursor_ptr) 
b851 85					add a,l 
b852					;call addatohl 
b852					;ld a, l 
b852 32 49 eb				ld (f_cursor_ptr), a   ; save new pos 
b855			 
b855			if DEBUG_FORTH_DOT 
b855				DMARK "D->" 
b855				CALLMONITOR 
b855			endif	 
b855			 
b855			.noadv:	 
b855			 
b855					if DEBUG_FORTH_DOT_WAIT 
b855							call next_page_prompt 
b855					endif	 
b855			; TODO this pop off the stack causes a crash. i dont know why 
b855			 
b855			 
b855			if DEBUG_FORTH_DOT 
b855				DMARK "DTh" 
b855				CALLMONITOR 
b855			endif	 
b855			 
b855					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b855 cd a8 9b			call macro_forth_dsp_pop 
b858				endm 
# End of macro FORTH_DSP_POP
b858			 
b858			if DEBUG_FORTH_DOT 
b858				DMARK "DTi" 
b858				CALLMONITOR 
b858			endif	 
b858			 
b858			 
b858					NEXTW 
b858 c3 62 9c			jp macro_next 
b85b				endm 
# End of macro NEXTW
b85b			 
b85b			.CLS: 
b85b				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
b85b 35				db WORD_SYS_CORE+33             
b85c 88 b8			dw .DRAW            
b85e 04				db 3 + 1 
b85f .. 00			db "CLS",0              
b863				endm 
# End of macro CWHEAD
b863			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
b863					if DEBUG_FORTH_WORDS_KEY 
b863						DMARK "CLS" 
b863 f5				push af  
b864 3a 78 b8			ld a, (.dmark)  
b867 32 7a ee			ld (debug_mark),a  
b86a 3a 79 b8			ld a, (.dmark+1)  
b86d 32 7b ee			ld (debug_mark+1),a  
b870 3a 7a b8			ld a, (.dmark+2)  
b873 32 7c ee			ld (debug_mark+2),a  
b876 18 03			jr .pastdmark  
b878 ..			.dmark: db "CLS"  
b87b f1			.pastdmark: pop af  
b87c			endm  
# End of macro DMARK
b87c						CALLMONITOR 
b87c cd 6c 93			call break_point_state  
b87f				endm  
# End of macro CALLMONITOR
b87f					endif 
b87f cd 91 88				call clear_display 
b882 c3 96 b9				jp .home		; and home cursor 
b885					NEXTW 
b885 c3 62 9c			jp macro_next 
b888				endm 
# End of macro NEXTW
b888			 
b888			.DRAW: 
b888				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
b888 36				db WORD_SYS_CORE+34             
b889 b3 b8			dw .DUMP            
b88b 05				db 4 + 1 
b88c .. 00			db "DRAW",0              
b891				endm 
# End of macro CWHEAD
b891			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
b891					if DEBUG_FORTH_WORDS_KEY 
b891						DMARK "DRW" 
b891 f5				push af  
b892 3a a6 b8			ld a, (.dmark)  
b895 32 7a ee			ld (debug_mark),a  
b898 3a a7 b8			ld a, (.dmark+1)  
b89b 32 7b ee			ld (debug_mark+1),a  
b89e 3a a8 b8			ld a, (.dmark+2)  
b8a1 32 7c ee			ld (debug_mark+2),a  
b8a4 18 03			jr .pastdmark  
b8a6 ..			.dmark: db "DRW"  
b8a9 f1			.pastdmark: pop af  
b8aa			endm  
# End of macro DMARK
b8aa						CALLMONITOR 
b8aa cd 6c 93			call break_point_state  
b8ad				endm  
# End of macro CALLMONITOR
b8ad					endif 
b8ad cd b4 88				call update_display 
b8b0					NEXTW 
b8b0 c3 62 9c			jp macro_next 
b8b3				endm 
# End of macro NEXTW
b8b3			 
b8b3			.DUMP: 
b8b3				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
b8b3 37				db WORD_SYS_CORE+35             
b8b4 eb b8			dw .CDUMP            
b8b6 05				db 4 + 1 
b8b7 .. 00			db "DUMP",0              
b8bc				endm 
# End of macro CWHEAD
b8bc			; | DUMP ( x -- ) With address x display dump   | DONE 
b8bc			; TODO pop address to use off of the stack 
b8bc					if DEBUG_FORTH_WORDS_KEY 
b8bc						DMARK "DUM" 
b8bc f5				push af  
b8bd 3a d1 b8			ld a, (.dmark)  
b8c0 32 7a ee			ld (debug_mark),a  
b8c3 3a d2 b8			ld a, (.dmark+1)  
b8c6 32 7b ee			ld (debug_mark+1),a  
b8c9 3a d3 b8			ld a, (.dmark+2)  
b8cc 32 7c ee			ld (debug_mark+2),a  
b8cf 18 03			jr .pastdmark  
b8d1 ..			.dmark: db "DUM"  
b8d4 f1			.pastdmark: pop af  
b8d5			endm  
# End of macro DMARK
b8d5						CALLMONITOR 
b8d5 cd 6c 93			call break_point_state  
b8d8				endm  
# End of macro CALLMONITOR
b8d8					endif 
b8d8 cd 91 88				call clear_display 
b8db			 
b8db					; get address 
b8db			 
b8db					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b8db cd f0 9a			call macro_dsp_valuehl 
b8de				endm 
# End of macro FORTH_DSP_VALUEHL
b8de				 
b8de					; save it for cdump 
b8de			 
b8de 22 83 e6				ld (os_cur_ptr),hl 
b8e1			 
b8e1					; destroy value TOS 
b8e1			 
b8e1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b8e1 cd a8 9b			call macro_forth_dsp_pop 
b8e4				endm 
# End of macro FORTH_DSP_POP
b8e4			 
b8e4 cd 79 97				call dumpcont	; skip old style of param parsing	 
b8e7 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
b8e8					NEXTW 
b8e8 c3 62 9c			jp macro_next 
b8eb				endm 
# End of macro NEXTW
b8eb			.CDUMP: 
b8eb				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
b8eb 38				db WORD_SYS_CORE+36             
b8ec 1b b9			dw .DAT            
b8ee 06				db 5 + 1 
b8ef .. 00			db "CDUMP",0              
b8f5				endm 
# End of macro CWHEAD
b8f5			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
b8f5					if DEBUG_FORTH_WORDS_KEY 
b8f5						DMARK "CDP" 
b8f5 f5				push af  
b8f6 3a 0a b9			ld a, (.dmark)  
b8f9 32 7a ee			ld (debug_mark),a  
b8fc 3a 0b b9			ld a, (.dmark+1)  
b8ff 32 7b ee			ld (debug_mark+1),a  
b902 3a 0c b9			ld a, (.dmark+2)  
b905 32 7c ee			ld (debug_mark+2),a  
b908 18 03			jr .pastdmark  
b90a ..			.dmark: db "CDP"  
b90d f1			.pastdmark: pop af  
b90e			endm  
# End of macro DMARK
b90e						CALLMONITOR 
b90e cd 6c 93			call break_point_state  
b911				endm  
# End of macro CALLMONITOR
b911					endif 
b911 cd 91 88				call clear_display 
b914 cd 79 97				call dumpcont	 
b917 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
b918					NEXTW 
b918 c3 62 9c			jp macro_next 
b91b				endm 
# End of macro NEXTW
b91b			 
b91b			 
b91b			 
b91b			 
b91b			.DAT: 
b91b				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
b91b 3d				db WORD_SYS_CORE+41             
b91c 71 b9			dw .HOME            
b91e 03				db 2 + 1 
b91f .. 00			db "AT",0              
b922				endm 
# End of macro CWHEAD
b922			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
b922					if DEBUG_FORTH_WORDS_KEY 
b922						DMARK "AT." 
b922 f5				push af  
b923 3a 37 b9			ld a, (.dmark)  
b926 32 7a ee			ld (debug_mark),a  
b929 3a 38 b9			ld a, (.dmark+1)  
b92c 32 7b ee			ld (debug_mark+1),a  
b92f 3a 39 b9			ld a, (.dmark+2)  
b932 32 7c ee			ld (debug_mark+2),a  
b935 18 03			jr .pastdmark  
b937 ..			.dmark: db "AT."  
b93a f1			.pastdmark: pop af  
b93b			endm  
# End of macro DMARK
b93b						CALLMONITOR 
b93b cd 6c 93			call break_point_state  
b93e				endm  
# End of macro CALLMONITOR
b93e					endif 
b93e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b93e cd f0 9a			call macro_dsp_valuehl 
b941				endm 
# End of macro FORTH_DSP_VALUEHL
b941			 
b941			 
b941					; TODO save cursor row 
b941 7d					ld a,l 
b942 fe 02				cp 2 
b944 20 04				jr nz, .crow3 
b946 3e 28				ld a, display_row_2 
b948 18 12				jr .ccol1 
b94a fe 03		.crow3:		cp 3 
b94c 20 04				jr nz, .crow4 
b94e 3e 50				ld a, display_row_3 
b950 18 0a				jr .ccol1 
b952 fe 04		.crow4:		cp 4 
b954 20 04				jr nz, .crow1 
b956 3e 78				ld a, display_row_4 
b958 18 02				jr .ccol1 
b95a 3e 00		.crow1:		ld a,display_row_1 
b95c f5			.ccol1:		push af			; got row offset 
b95d 6f					ld l,a 
b95e 26 00				ld h,0 
b960					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b960 cd a8 9b			call macro_forth_dsp_pop 
b963				endm 
# End of macro FORTH_DSP_POP
b963					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b963 cd f0 9a			call macro_dsp_valuehl 
b966				endm 
# End of macro FORTH_DSP_VALUEHL
b966					; TODO save cursor col 
b966 f1					pop af 
b967 85					add l		; add col offset 
b968 32 49 eb				ld (f_cursor_ptr), a 
b96b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
b96b cd a8 9b			call macro_forth_dsp_pop 
b96e				endm 
# End of macro FORTH_DSP_POP
b96e			 
b96e					; calculate  
b96e			 
b96e					NEXTW 
b96e c3 62 9c			jp macro_next 
b971				endm 
# End of macro NEXTW
b971			 
b971			 
b971			.HOME: 
b971				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
b971 41				db WORD_SYS_CORE+45             
b972 9e b9			dw .SPACE            
b974 05				db 4 + 1 
b975 .. 00			db "HOME",0              
b97a				endm 
# End of macro CWHEAD
b97a			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
b97a					if DEBUG_FORTH_WORDS_KEY 
b97a						DMARK "HOM" 
b97a f5				push af  
b97b 3a 8f b9			ld a, (.dmark)  
b97e 32 7a ee			ld (debug_mark),a  
b981 3a 90 b9			ld a, (.dmark+1)  
b984 32 7b ee			ld (debug_mark+1),a  
b987 3a 91 b9			ld a, (.dmark+2)  
b98a 32 7c ee			ld (debug_mark+2),a  
b98d 18 03			jr .pastdmark  
b98f ..			.dmark: db "HOM"  
b992 f1			.pastdmark: pop af  
b993			endm  
# End of macro DMARK
b993						CALLMONITOR 
b993 cd 6c 93			call break_point_state  
b996				endm  
# End of macro CALLMONITOR
b996					endif 
b996 3e 00		.home:		ld a, 0		; and home cursor 
b998 32 49 eb				ld (f_cursor_ptr), a 
b99b					NEXTW 
b99b c3 62 9c			jp macro_next 
b99e				endm 
# End of macro NEXTW
b99e			 
b99e			 
b99e			.SPACE: 
b99e				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
b99e 46				db WORD_SYS_CORE+50             
b99f cc b9			dw .SPACES            
b9a1 03				db 2 + 1 
b9a2 .. 00			db "BL",0              
b9a5				endm 
# End of macro CWHEAD
b9a5			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
b9a5					if DEBUG_FORTH_WORDS_KEY 
b9a5						DMARK "BL." 
b9a5 f5				push af  
b9a6 3a ba b9			ld a, (.dmark)  
b9a9 32 7a ee			ld (debug_mark),a  
b9ac 3a bb b9			ld a, (.dmark+1)  
b9af 32 7b ee			ld (debug_mark+1),a  
b9b2 3a bc b9			ld a, (.dmark+2)  
b9b5 32 7c ee			ld (debug_mark+2),a  
b9b8 18 03			jr .pastdmark  
b9ba ..			.dmark: db "BL."  
b9bd f1			.pastdmark: pop af  
b9be			endm  
# End of macro DMARK
b9be						CALLMONITOR 
b9be cd 6c 93			call break_point_state  
b9c1				endm  
# End of macro CALLMONITOR
b9c1					endif 
b9c1 21 ca b9				ld hl, .blstr 
b9c4 cd 67 99				call forth_push_str 
b9c7					 
b9c7				       NEXTW 
b9c7 c3 62 9c			jp macro_next 
b9ca				endm 
# End of macro NEXTW
b9ca			 
b9ca .. 00		.blstr: db " ", 0 
b9cc			 
b9cc			.SPACES: 
b9cc				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
b9cc 47				db WORD_SYS_CORE+51             
b9cd 67 ba			dw .SCROLL            
b9cf 07				db 6 + 1 
b9d0 .. 00			db "SPACES",0              
b9d7				endm 
# End of macro CWHEAD
b9d7			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
b9d7					if DEBUG_FORTH_WORDS_KEY 
b9d7						DMARK "SPS" 
b9d7 f5				push af  
b9d8 3a ec b9			ld a, (.dmark)  
b9db 32 7a ee			ld (debug_mark),a  
b9de 3a ed b9			ld a, (.dmark+1)  
b9e1 32 7b ee			ld (debug_mark+1),a  
b9e4 3a ee b9			ld a, (.dmark+2)  
b9e7 32 7c ee			ld (debug_mark+2),a  
b9ea 18 03			jr .pastdmark  
b9ec ..			.dmark: db "SPS"  
b9ef f1			.pastdmark: pop af  
b9f0			endm  
# End of macro DMARK
b9f0						CALLMONITOR 
b9f0 cd 6c 93			call break_point_state  
b9f3				endm  
# End of macro CALLMONITOR
b9f3					endif 
b9f3			 
b9f3			 
b9f3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
b9f3 cd f0 9a			call macro_dsp_valuehl 
b9f6				endm 
# End of macro FORTH_DSP_VALUEHL
b9f6			 
b9f6			;		push hl    ; u 
b9f6					if DEBUG_FORTH_WORDS 
b9f6						DMARK "SPA" 
b9f6 f5				push af  
b9f7 3a 0b ba			ld a, (.dmark)  
b9fa 32 7a ee			ld (debug_mark),a  
b9fd 3a 0c ba			ld a, (.dmark+1)  
ba00 32 7b ee			ld (debug_mark+1),a  
ba03 3a 0d ba			ld a, (.dmark+2)  
ba06 32 7c ee			ld (debug_mark+2),a  
ba09 18 03			jr .pastdmark  
ba0b ..			.dmark: db "SPA"  
ba0e f1			.pastdmark: pop af  
ba0f			endm  
# End of macro DMARK
ba0f						CALLMONITOR 
ba0f cd 6c 93			call break_point_state  
ba12				endm  
# End of macro CALLMONITOR
ba12					endif 
ba12			 
ba12					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba12 cd a8 9b			call macro_forth_dsp_pop 
ba15				endm 
# End of macro FORTH_DSP_POP
ba15			;		pop hl 
ba15 4d					ld c, l 
ba16 06 00				ld b, 0 
ba18 21 60 e3				ld hl, scratch  
ba1b			 
ba1b					if DEBUG_FORTH_WORDS 
ba1b						DMARK "SP2" 
ba1b f5				push af  
ba1c 3a 30 ba			ld a, (.dmark)  
ba1f 32 7a ee			ld (debug_mark),a  
ba22 3a 31 ba			ld a, (.dmark+1)  
ba25 32 7b ee			ld (debug_mark+1),a  
ba28 3a 32 ba			ld a, (.dmark+2)  
ba2b 32 7c ee			ld (debug_mark+2),a  
ba2e 18 03			jr .pastdmark  
ba30 ..			.dmark: db "SP2"  
ba33 f1			.pastdmark: pop af  
ba34			endm  
# End of macro DMARK
ba34						CALLMONITOR 
ba34 cd 6c 93			call break_point_state  
ba37				endm  
# End of macro CALLMONITOR
ba37					endif 
ba37 3e 20				ld a, ' ' 
ba39 c5			.spaces1:	push bc 
ba3a 77					ld (hl),a 
ba3b 23					inc hl 
ba3c c1					pop bc 
ba3d 10 fa				djnz .spaces1 
ba3f 3e 00				ld a,0 
ba41 77					ld (hl),a 
ba42 21 60 e3				ld hl, scratch 
ba45					if DEBUG_FORTH_WORDS 
ba45						DMARK "SP3" 
ba45 f5				push af  
ba46 3a 5a ba			ld a, (.dmark)  
ba49 32 7a ee			ld (debug_mark),a  
ba4c 3a 5b ba			ld a, (.dmark+1)  
ba4f 32 7b ee			ld (debug_mark+1),a  
ba52 3a 5c ba			ld a, (.dmark+2)  
ba55 32 7c ee			ld (debug_mark+2),a  
ba58 18 03			jr .pastdmark  
ba5a ..			.dmark: db "SP3"  
ba5d f1			.pastdmark: pop af  
ba5e			endm  
# End of macro DMARK
ba5e						CALLMONITOR 
ba5e cd 6c 93			call break_point_state  
ba61				endm  
# End of macro CALLMONITOR
ba61					endif 
ba61 cd 62 9a				call forth_apush 
ba64			 
ba64				       NEXTW 
ba64 c3 62 9c			jp macro_next 
ba67				endm 
# End of macro NEXTW
ba67			 
ba67			 
ba67			 
ba67			.SCROLL: 
ba67				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
ba67 53				db WORD_SYS_CORE+63             
ba68 94 ba			dw .SCROLLD            
ba6a 07				db 6 + 1 
ba6b .. 00			db "SCROLL",0              
ba72				endm 
# End of macro CWHEAD
ba72			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
ba72					if DEBUG_FORTH_WORDS_KEY 
ba72						DMARK "SCR" 
ba72 f5				push af  
ba73 3a 87 ba			ld a, (.dmark)  
ba76 32 7a ee			ld (debug_mark),a  
ba79 3a 88 ba			ld a, (.dmark+1)  
ba7c 32 7b ee			ld (debug_mark+1),a  
ba7f 3a 89 ba			ld a, (.dmark+2)  
ba82 32 7c ee			ld (debug_mark+2),a  
ba85 18 03			jr .pastdmark  
ba87 ..			.dmark: db "SCR"  
ba8a f1			.pastdmark: pop af  
ba8b			endm  
# End of macro DMARK
ba8b						CALLMONITOR 
ba8b cd 6c 93			call break_point_state  
ba8e				endm  
# End of macro CALLMONITOR
ba8e					endif 
ba8e			 
ba8e cd 53 88			call scroll_up 
ba91			;	call update_display 
ba91			 
ba91					NEXTW 
ba91 c3 62 9c			jp macro_next 
ba94				endm 
# End of macro NEXTW
ba94			 
ba94			 
ba94			 
ba94			;		; get dir 
ba94			; 
ba94			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba94			; 
ba94			;		push hl 
ba94			; 
ba94			;		; destroy value TOS 
ba94			; 
ba94			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba94			; 
ba94			;		; get count 
ba94			; 
ba94			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
ba94			; 
ba94			;		push hl 
ba94			; 
ba94			;		; destroy value TOS 
ba94			; 
ba94			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
ba94			; 
ba94			;		; one value on hl get other one back 
ba94			; 
ba94			;		pop bc    ; count 
ba94			; 
ba94			;		pop de   ; dir 
ba94			; 
ba94			; 
ba94			;		ld b, c 
ba94			; 
ba94			;.scrolldir:     push bc 
ba94			;		push de 
ba94			; 
ba94			;		ld a, 0 
ba94			;		cp e 
ba94			;		jr z, .scrollup  
ba94			;		call scroll_down 
ba94			;		jr .scrollnext 
ba94			;.scrollup:	call scroll_up 
ba94			; 
ba94			;		 
ba94			;.scrollnext: 
ba94			;		pop de 
ba94			;		pop bc 
ba94			;		djnz .scrolldir 
ba94			; 
ba94			; 
ba94			; 
ba94			; 
ba94			; 
ba94			;		NEXTW 
ba94			 
ba94			.SCROLLD: 
ba94				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
ba94 53				db WORD_SYS_CORE+63             
ba95 c2 ba			dw .ATQ            
ba97 08				db 7 + 1 
ba98 .. 00			db "SCROLLD",0              
baa0				endm 
# End of macro CWHEAD
baa0			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
baa0					if DEBUG_FORTH_WORDS_KEY 
baa0						DMARK "SCD" 
baa0 f5				push af  
baa1 3a b5 ba			ld a, (.dmark)  
baa4 32 7a ee			ld (debug_mark),a  
baa7 3a b6 ba			ld a, (.dmark+1)  
baaa 32 7b ee			ld (debug_mark+1),a  
baad 3a b7 ba			ld a, (.dmark+2)  
bab0 32 7c ee			ld (debug_mark+2),a  
bab3 18 03			jr .pastdmark  
bab5 ..			.dmark: db "SCD"  
bab8 f1			.pastdmark: pop af  
bab9			endm  
# End of macro DMARK
bab9						CALLMONITOR 
bab9 cd 6c 93			call break_point_state  
babc				endm  
# End of macro CALLMONITOR
babc					endif 
babc			 
babc cd 77 88			call scroll_down 
babf			;	call update_display 
babf			 
babf					NEXTW 
babf c3 62 9c			jp macro_next 
bac2				endm 
# End of macro NEXTW
bac2			 
bac2			 
bac2			.ATQ: 
bac2				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
bac2 62				db WORD_SYS_CORE+78             
bac3 20 bb			dw .AUTODSP            
bac5 04				db 3 + 1 
bac6 .. 00			db "AT@",0              
baca				endm 
# End of macro CWHEAD
baca			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
baca					if DEBUG_FORTH_WORDS_KEY 
baca						DMARK "ATA" 
baca f5				push af  
bacb 3a df ba			ld a, (.dmark)  
bace 32 7a ee			ld (debug_mark),a  
bad1 3a e0 ba			ld a, (.dmark+1)  
bad4 32 7b ee			ld (debug_mark+1),a  
bad7 3a e1 ba			ld a, (.dmark+2)  
bada 32 7c ee			ld (debug_mark+2),a  
badd 18 03			jr .pastdmark  
badf ..			.dmark: db "ATA"  
bae2 f1			.pastdmark: pop af  
bae3			endm  
# End of macro DMARK
bae3						CALLMONITOR 
bae3 cd 6c 93			call break_point_state  
bae6				endm  
# End of macro CALLMONITOR
bae6					endif 
bae6			 
bae6			 
bae6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bae6 cd f0 9a			call macro_dsp_valuehl 
bae9				endm 
# End of macro FORTH_DSP_VALUEHL
bae9			 
bae9					; TODO save cursor row 
bae9 7d					ld a,l 
baea fe 02				cp 2 
baec 20 04				jr nz, .crow3aq 
baee 3e 28				ld a, display_row_2 
baf0 18 12				jr .ccol1aq 
baf2 fe 03		.crow3aq:		cp 3 
baf4 20 04				jr nz, .crow4aq 
baf6 3e 50				ld a, display_row_3 
baf8 18 0a				jr .ccol1aq 
bafa fe 04		.crow4aq:		cp 4 
bafc 20 04				jr nz, .crow1aq 
bafe 3e 78				ld a, display_row_4 
bb00 18 02				jr .ccol1aq 
bb02 3e 00		.crow1aq:		ld a,display_row_1 
bb04 f5			.ccol1aq:		push af			; got row offset 
bb05 6f					ld l,a 
bb06 26 00				ld h,0 
bb08					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb08 cd a8 9b			call macro_forth_dsp_pop 
bb0b				endm 
# End of macro FORTH_DSP_POP
bb0b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb0b cd f0 9a			call macro_dsp_valuehl 
bb0e				endm 
# End of macro FORTH_DSP_VALUEHL
bb0e					; TODO save cursor col 
bb0e f1					pop af 
bb0f 85					add l		; add col offset 
bb10			 
bb10					; add current frame buffer address 
bb10 2a db eb				ld hl, (display_fb_active) 
bb13 cd be 8a				call addatohl 
bb16			 
bb16			 
bb16			 
bb16			 
bb16					; get char frame buffer location offset in hl 
bb16			 
bb16 7e					ld a,(hl) 
bb17 26 00				ld h, 0 
bb19 6f					ld l, a 
bb1a			 
bb1a cd f9 98				call forth_push_numhl 
bb1d			 
bb1d			 
bb1d					NEXTW 
bb1d c3 62 9c			jp macro_next 
bb20				endm 
# End of macro NEXTW
bb20			 
bb20			.AUTODSP: 
bb20				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
bb20 63				db WORD_SYS_CORE+79             
bb21 36 bb			dw .MENU            
bb23 05				db 4 + 1 
bb24 .. 00			db "ADSP",0              
bb29				endm 
# End of macro CWHEAD
bb29			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
bb29			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
bb29			 
bb29					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
bb29 cd f0 9a			call macro_dsp_valuehl 
bb2c				endm 
# End of macro FORTH_DSP_VALUEHL
bb2c			 
bb2c			;		push hl 
bb2c			 
bb2c					; destroy value TOS 
bb2c			 
bb2c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb2c cd a8 9b			call macro_forth_dsp_pop 
bb2f				endm 
# End of macro FORTH_DSP_POP
bb2f			 
bb2f			;		pop hl 
bb2f			 
bb2f 7d					ld a,l 
bb30 32 27 eb				ld (cli_autodisplay), a 
bb33				       NEXTW 
bb33 c3 62 9c			jp macro_next 
bb36				endm 
# End of macro NEXTW
bb36			 
bb36			.MENU: 
bb36				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
bb36 70				db WORD_SYS_CORE+92             
bb37 df bb			dw .ENDDISPLAY            
bb39 05				db 4 + 1 
bb3a .. 00			db "MENU",0              
bb3f				endm 
# End of macro CWHEAD
bb3f			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
bb3f			 
bb3f			;		; get number of items on the stack 
bb3f			; 
bb3f				 
bb3f					FORTH_DSP_VALUEHL 
bb3f cd f0 9a			call macro_dsp_valuehl 
bb42				endm 
# End of macro FORTH_DSP_VALUEHL
bb42				 
bb42					if DEBUG_FORTH_WORDS_KEY 
bb42						DMARK "MNU" 
bb42 f5				push af  
bb43 3a 57 bb			ld a, (.dmark)  
bb46 32 7a ee			ld (debug_mark),a  
bb49 3a 58 bb			ld a, (.dmark+1)  
bb4c 32 7b ee			ld (debug_mark+1),a  
bb4f 3a 59 bb			ld a, (.dmark+2)  
bb52 32 7c ee			ld (debug_mark+2),a  
bb55 18 03			jr .pastdmark  
bb57 ..			.dmark: db "MNU"  
bb5a f1			.pastdmark: pop af  
bb5b			endm  
# End of macro DMARK
bb5b						CALLMONITOR 
bb5b cd 6c 93			call break_point_state  
bb5e				endm  
# End of macro CALLMONITOR
bb5e					endif 
bb5e			 
bb5e 45					ld b, l	 
bb5f 05					dec b 
bb60			 
bb60					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb60 cd a8 9b			call macro_forth_dsp_pop 
bb63				endm 
# End of macro FORTH_DSP_POP
bb63			 
bb63			 
bb63					; go directly through the stack to pluck out the string pointers and build an array 
bb63			 
bb63			;		FORTH_DSP 
bb63			 
bb63					; hl contains top most stack item 
bb63				 
bb63 11 60 e3				ld de, scratch 
bb66			 
bb66			.mbuild: 
bb66			 
bb66					FORTH_DSP_VALUEHL 
bb66 cd f0 9a			call macro_dsp_valuehl 
bb69				endm 
# End of macro FORTH_DSP_VALUEHL
bb69			 
bb69					if DEBUG_FORTH_WORDS 
bb69						DMARK "MN3" 
bb69 f5				push af  
bb6a 3a 7e bb			ld a, (.dmark)  
bb6d 32 7a ee			ld (debug_mark),a  
bb70 3a 7f bb			ld a, (.dmark+1)  
bb73 32 7b ee			ld (debug_mark+1),a  
bb76 3a 80 bb			ld a, (.dmark+2)  
bb79 32 7c ee			ld (debug_mark+2),a  
bb7c 18 03			jr .pastdmark  
bb7e ..			.dmark: db "MN3"  
bb81 f1			.pastdmark: pop af  
bb82			endm  
# End of macro DMARK
bb82						CALLMONITOR 
bb82 cd 6c 93			call break_point_state  
bb85				endm  
# End of macro CALLMONITOR
bb85					endif 
bb85 eb					ex de, hl 
bb86 73					ld (hl), e 
bb87 23					inc hl 
bb88 72					ld (hl), d 
bb89 23					inc hl 
bb8a eb					ex de, hl 
bb8b			 
bb8b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
bb8b cd a8 9b			call macro_forth_dsp_pop 
bb8e				endm 
# End of macro FORTH_DSP_POP
bb8e			 
bb8e 10 d6				djnz .mbuild 
bb90			 
bb90					; done add term 
bb90			 
bb90 eb					ex de, hl 
bb91 36 00				ld (hl), 0 
bb93 23					inc hl 
bb94 36 00				ld (hl), 0 
bb96			 
bb96				 
bb96					 
bb96 21 60 e3				ld hl, scratch 
bb99			 
bb99					if DEBUG_FORTH_WORDS 
bb99						DMARK "MNx" 
bb99 f5				push af  
bb9a 3a ae bb			ld a, (.dmark)  
bb9d 32 7a ee			ld (debug_mark),a  
bba0 3a af bb			ld a, (.dmark+1)  
bba3 32 7b ee			ld (debug_mark+1),a  
bba6 3a b0 bb			ld a, (.dmark+2)  
bba9 32 7c ee			ld (debug_mark+2),a  
bbac 18 03			jr .pastdmark  
bbae ..			.dmark: db "MNx"  
bbb1 f1			.pastdmark: pop af  
bbb2			endm  
# End of macro DMARK
bbb2						CALLMONITOR 
bbb2 cd 6c 93			call break_point_state  
bbb5				endm  
# End of macro CALLMONITOR
bbb5					endif 
bbb5			 
bbb5			 
bbb5			 
bbb5 3e 00				ld a, 0 
bbb7 cd c2 88				call menu 
bbba			 
bbba			 
bbba 6f					ld l, a 
bbbb 26 00				ld h, 0 
bbbd			 
bbbd					if DEBUG_FORTH_WORDS 
bbbd						DMARK "MNr" 
bbbd f5				push af  
bbbe 3a d2 bb			ld a, (.dmark)  
bbc1 32 7a ee			ld (debug_mark),a  
bbc4 3a d3 bb			ld a, (.dmark+1)  
bbc7 32 7b ee			ld (debug_mark+1),a  
bbca 3a d4 bb			ld a, (.dmark+2)  
bbcd 32 7c ee			ld (debug_mark+2),a  
bbd0 18 03			jr .pastdmark  
bbd2 ..			.dmark: db "MNr"  
bbd5 f1			.pastdmark: pop af  
bbd6			endm  
# End of macro DMARK
bbd6						CALLMONITOR 
bbd6 cd 6c 93			call break_point_state  
bbd9				endm  
# End of macro CALLMONITOR
bbd9					endif 
bbd9			 
bbd9 cd f9 98				call forth_push_numhl 
bbdc			 
bbdc			 
bbdc			 
bbdc			 
bbdc				       NEXTW 
bbdc c3 62 9c			jp macro_next 
bbdf				endm 
# End of macro NEXTW
bbdf			 
bbdf			 
bbdf			.ENDDISPLAY: 
bbdf			 
bbdf			; eof 
# End of file forth_words_display.asm
bbdf			include "forth_words_str.asm" 
bbdf			 
bbdf			; | ## String Words 
bbdf			 
bbdf			.PTR:   
bbdf			 
bbdf				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
bbdf 48				db WORD_SYS_CORE+52             
bbe0 0c bc			dw .STYPE            
bbe2 04				db 3 + 1 
bbe3 .. 00			db "PTR",0              
bbe7				endm 
# End of macro CWHEAD
bbe7			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
bbe7			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
bbe7			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
bbe7			 
bbe7					if DEBUG_FORTH_WORDS_KEY 
bbe7						DMARK "PTR" 
bbe7 f5				push af  
bbe8 3a fc bb			ld a, (.dmark)  
bbeb 32 7a ee			ld (debug_mark),a  
bbee 3a fd bb			ld a, (.dmark+1)  
bbf1 32 7b ee			ld (debug_mark+1),a  
bbf4 3a fe bb			ld a, (.dmark+2)  
bbf7 32 7c ee			ld (debug_mark+2),a  
bbfa 18 03			jr .pastdmark  
bbfc ..			.dmark: db "PTR"  
bbff f1			.pastdmark: pop af  
bc00			endm  
# End of macro DMARK
bc00						CALLMONITOR 
bc00 cd 6c 93			call break_point_state  
bc03				endm  
# End of macro CALLMONITOR
bc03					endif 
bc03					FORTH_DSP_VALUEHL 
bc03 cd f0 9a			call macro_dsp_valuehl 
bc06				endm 
# End of macro FORTH_DSP_VALUEHL
bc06 cd f9 98				call forth_push_numhl 
bc09			 
bc09			 
bc09					NEXTW 
bc09 c3 62 9c			jp macro_next 
bc0c				endm 
# End of macro NEXTW
bc0c			.STYPE: 
bc0c				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
bc0c 48				db WORD_SYS_CORE+52             
bc0d 5b bc			dw .UPPER            
bc0f 06				db 5 + 1 
bc10 .. 00			db "STYPE",0              
bc16				endm 
# End of macro CWHEAD
bc16			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
bc16					if DEBUG_FORTH_WORDS_KEY 
bc16						DMARK "STY" 
bc16 f5				push af  
bc17 3a 2b bc			ld a, (.dmark)  
bc1a 32 7a ee			ld (debug_mark),a  
bc1d 3a 2c bc			ld a, (.dmark+1)  
bc20 32 7b ee			ld (debug_mark+1),a  
bc23 3a 2d bc			ld a, (.dmark+2)  
bc26 32 7c ee			ld (debug_mark+2),a  
bc29 18 03			jr .pastdmark  
bc2b ..			.dmark: db "STY"  
bc2e f1			.pastdmark: pop af  
bc2f			endm  
# End of macro DMARK
bc2f						CALLMONITOR 
bc2f cd 6c 93			call break_point_state  
bc32				endm  
# End of macro CALLMONITOR
bc32					endif 
bc32					FORTH_DSP 
bc32 cd b6 9a			call macro_forth_dsp 
bc35				endm 
# End of macro FORTH_DSP
bc35					;v5 FORTH_DSP_VALUE 
bc35			 
bc35 7e					ld a, (hl) 
bc36			 
bc36 f5					push af 
bc37			 
bc37			; Dont destroy TOS		FORTH_DSP_POP 
bc37			 
bc37 f1					pop af 
bc38			 
bc38 fe 01				cp DS_TYPE_STR 
bc3a 28 09				jr z, .typestr 
bc3c			 
bc3c fe 02				cp DS_TYPE_INUM 
bc3e 28 0a				jr z, .typeinum 
bc40			 
bc40 21 59 bc				ld hl, .tna 
bc43 18 0a				jr .tpush 
bc45			 
bc45 21 55 bc		.typestr:	ld hl, .tstr 
bc48 18 05				jr .tpush 
bc4a 21 57 bc		.typeinum:	ld hl, .tinum 
bc4d 18 00				jr .tpush 
bc4f			 
bc4f			.tpush: 
bc4f			 
bc4f cd 67 99				call forth_push_str 
bc52			 
bc52					NEXTW 
bc52 c3 62 9c			jp macro_next 
bc55				endm 
# End of macro NEXTW
bc55 .. 00		.tstr:	db "s",0 
bc57 .. 00		.tinum:  db "i",0 
bc59 .. 00		.tna:   db "?", 0 
bc5b			 
bc5b			 
bc5b			.UPPER: 
bc5b				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
bc5b 48				db WORD_SYS_CORE+52             
bc5c 96 bc			dw .LOWER            
bc5e 06				db 5 + 1 
bc5f .. 00			db "UPPER",0              
bc65				endm 
# End of macro CWHEAD
bc65			; | UPPER ( s -- s ) Upper case string s  | DONE 
bc65					if DEBUG_FORTH_WORDS_KEY 
bc65						DMARK "UPR" 
bc65 f5				push af  
bc66 3a 7a bc			ld a, (.dmark)  
bc69 32 7a ee			ld (debug_mark),a  
bc6c 3a 7b bc			ld a, (.dmark+1)  
bc6f 32 7b ee			ld (debug_mark+1),a  
bc72 3a 7c bc			ld a, (.dmark+2)  
bc75 32 7c ee			ld (debug_mark+2),a  
bc78 18 03			jr .pastdmark  
bc7a ..			.dmark: db "UPR"  
bc7d f1			.pastdmark: pop af  
bc7e			endm  
# End of macro DMARK
bc7e						CALLMONITOR 
bc7e cd 6c 93			call break_point_state  
bc81				endm  
# End of macro CALLMONITOR
bc81					endif 
bc81			 
bc81					FORTH_DSP 
bc81 cd b6 9a			call macro_forth_dsp 
bc84				endm 
# End of macro FORTH_DSP
bc84					 
bc84			; TODO check is string type 
bc84			 
bc84					FORTH_DSP_VALUEHL 
bc84 cd f0 9a			call macro_dsp_valuehl 
bc87				endm 
# End of macro FORTH_DSP_VALUEHL
bc87			; get pointer to string in hl 
bc87			 
bc87 7e			.toup:		ld a, (hl) 
bc88 fe 00				cp 0 
bc8a 28 07				jr z, .toupdone 
bc8c			 
bc8c cd 2b 8e				call to_upper 
bc8f			 
bc8f 77					ld (hl), a 
bc90 23					inc hl 
bc91 18 f4				jr .toup 
bc93			 
bc93					 
bc93			 
bc93			 
bc93			; for each char convert to upper 
bc93					 
bc93			.toupdone: 
bc93			 
bc93			 
bc93					NEXTW 
bc93 c3 62 9c			jp macro_next 
bc96				endm 
# End of macro NEXTW
bc96			.LOWER: 
bc96				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
bc96 48				db WORD_SYS_CORE+52             
bc97 d1 bc			dw .TCASE            
bc99 06				db 5 + 1 
bc9a .. 00			db "LOWER",0              
bca0				endm 
# End of macro CWHEAD
bca0			; | LOWER ( s -- s ) Lower case string s  | DONE 
bca0					if DEBUG_FORTH_WORDS_KEY 
bca0						DMARK "LWR" 
bca0 f5				push af  
bca1 3a b5 bc			ld a, (.dmark)  
bca4 32 7a ee			ld (debug_mark),a  
bca7 3a b6 bc			ld a, (.dmark+1)  
bcaa 32 7b ee			ld (debug_mark+1),a  
bcad 3a b7 bc			ld a, (.dmark+2)  
bcb0 32 7c ee			ld (debug_mark+2),a  
bcb3 18 03			jr .pastdmark  
bcb5 ..			.dmark: db "LWR"  
bcb8 f1			.pastdmark: pop af  
bcb9			endm  
# End of macro DMARK
bcb9						CALLMONITOR 
bcb9 cd 6c 93			call break_point_state  
bcbc				endm  
# End of macro CALLMONITOR
bcbc					endif 
bcbc			 
bcbc					FORTH_DSP 
bcbc cd b6 9a			call macro_forth_dsp 
bcbf				endm 
# End of macro FORTH_DSP
bcbf					 
bcbf			; TODO check is string type 
bcbf			 
bcbf					FORTH_DSP_VALUEHL 
bcbf cd f0 9a			call macro_dsp_valuehl 
bcc2				endm 
# End of macro FORTH_DSP_VALUEHL
bcc2			; get pointer to string in hl 
bcc2			 
bcc2 7e			.tolow:		ld a, (hl) 
bcc3 fe 00				cp 0 
bcc5 28 07				jr z, .tolowdone 
bcc7			 
bcc7 cd 34 8e				call to_lower 
bcca			 
bcca 77					ld (hl), a 
bccb 23					inc hl 
bccc 18 f4				jr .tolow 
bcce			 
bcce					 
bcce			 
bcce			 
bcce			; for each char convert to low 
bcce					 
bcce			.tolowdone: 
bcce					NEXTW 
bcce c3 62 9c			jp macro_next 
bcd1				endm 
# End of macro NEXTW
bcd1			.TCASE: 
bcd1				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
bcd1 48				db WORD_SYS_CORE+52             
bcd2 07 be			dw .SUBSTR            
bcd4 06				db 5 + 1 
bcd5 .. 00			db "TCASE",0              
bcdb				endm 
# End of macro CWHEAD
bcdb			; | TCASE ( s -- s ) Title case string s  | DONE 
bcdb					if DEBUG_FORTH_WORDS_KEY 
bcdb						DMARK "TCS" 
bcdb f5				push af  
bcdc 3a f0 bc			ld a, (.dmark)  
bcdf 32 7a ee			ld (debug_mark),a  
bce2 3a f1 bc			ld a, (.dmark+1)  
bce5 32 7b ee			ld (debug_mark+1),a  
bce8 3a f2 bc			ld a, (.dmark+2)  
bceb 32 7c ee			ld (debug_mark+2),a  
bcee 18 03			jr .pastdmark  
bcf0 ..			.dmark: db "TCS"  
bcf3 f1			.pastdmark: pop af  
bcf4			endm  
# End of macro DMARK
bcf4						CALLMONITOR 
bcf4 cd 6c 93			call break_point_state  
bcf7				endm  
# End of macro CALLMONITOR
bcf7					endif 
bcf7			 
bcf7					FORTH_DSP 
bcf7 cd b6 9a			call macro_forth_dsp 
bcfa				endm 
# End of macro FORTH_DSP
bcfa					 
bcfa			; TODO check is string type 
bcfa			 
bcfa					FORTH_DSP_VALUEHL 
bcfa cd f0 9a			call macro_dsp_valuehl 
bcfd				endm 
# End of macro FORTH_DSP_VALUEHL
bcfd			; get pointer to string in hl 
bcfd			 
bcfd					if DEBUG_FORTH_WORDS 
bcfd						DMARK "TC1" 
bcfd f5				push af  
bcfe 3a 12 bd			ld a, (.dmark)  
bd01 32 7a ee			ld (debug_mark),a  
bd04 3a 13 bd			ld a, (.dmark+1)  
bd07 32 7b ee			ld (debug_mark+1),a  
bd0a 3a 14 bd			ld a, (.dmark+2)  
bd0d 32 7c ee			ld (debug_mark+2),a  
bd10 18 03			jr .pastdmark  
bd12 ..			.dmark: db "TC1"  
bd15 f1			.pastdmark: pop af  
bd16			endm  
# End of macro DMARK
bd16						CALLMONITOR 
bd16 cd 6c 93			call break_point_state  
bd19				endm  
# End of macro CALLMONITOR
bd19					endif 
bd19			 
bd19					; first time in turn to upper case first char 
bd19			 
bd19 7e					ld a, (hl) 
bd1a c3 a4 bd				jp .totsiptou 
bd1d			 
bd1d			 
bd1d 7e			.tot:		ld a, (hl) 
bd1e fe 00				cp 0 
bd20 ca e8 bd				jp z, .totdone 
bd23			 
bd23					if DEBUG_FORTH_WORDS 
bd23						DMARK "TC2" 
bd23 f5				push af  
bd24 3a 38 bd			ld a, (.dmark)  
bd27 32 7a ee			ld (debug_mark),a  
bd2a 3a 39 bd			ld a, (.dmark+1)  
bd2d 32 7b ee			ld (debug_mark+1),a  
bd30 3a 3a bd			ld a, (.dmark+2)  
bd33 32 7c ee			ld (debug_mark+2),a  
bd36 18 03			jr .pastdmark  
bd38 ..			.dmark: db "TC2"  
bd3b f1			.pastdmark: pop af  
bd3c			endm  
# End of macro DMARK
bd3c						CALLMONITOR 
bd3c cd 6c 93			call break_point_state  
bd3f				endm  
# End of macro CALLMONITOR
bd3f					endif 
bd3f					; check to see if current char is a space 
bd3f			 
bd3f fe 20				cp ' ' 
bd41 28 21				jr z, .totsp 
bd43 cd 34 8e				call to_lower 
bd46					if DEBUG_FORTH_WORDS 
bd46						DMARK "TC3" 
bd46 f5				push af  
bd47 3a 5b bd			ld a, (.dmark)  
bd4a 32 7a ee			ld (debug_mark),a  
bd4d 3a 5c bd			ld a, (.dmark+1)  
bd50 32 7b ee			ld (debug_mark+1),a  
bd53 3a 5d bd			ld a, (.dmark+2)  
bd56 32 7c ee			ld (debug_mark+2),a  
bd59 18 03			jr .pastdmark  
bd5b ..			.dmark: db "TC3"  
bd5e f1			.pastdmark: pop af  
bd5f			endm  
# End of macro DMARK
bd5f						CALLMONITOR 
bd5f cd 6c 93			call break_point_state  
bd62				endm  
# End of macro CALLMONITOR
bd62					endif 
bd62 18 63				jr .totnxt 
bd64			 
bd64			.totsp:         ; on a space, find next char which should be upper 
bd64			 
bd64					if DEBUG_FORTH_WORDS 
bd64						DMARK "TC4" 
bd64 f5				push af  
bd65 3a 79 bd			ld a, (.dmark)  
bd68 32 7a ee			ld (debug_mark),a  
bd6b 3a 7a bd			ld a, (.dmark+1)  
bd6e 32 7b ee			ld (debug_mark+1),a  
bd71 3a 7b bd			ld a, (.dmark+2)  
bd74 32 7c ee			ld (debug_mark+2),a  
bd77 18 03			jr .pastdmark  
bd79 ..			.dmark: db "TC4"  
bd7c f1			.pastdmark: pop af  
bd7d			endm  
# End of macro DMARK
bd7d						CALLMONITOR 
bd7d cd 6c 93			call break_point_state  
bd80				endm  
# End of macro CALLMONITOR
bd80					endif 
bd80					;; 
bd80			 
bd80 fe 20				cp ' ' 
bd82 20 20				jr nz, .totsiptou 
bd84 23					inc hl 
bd85 7e					ld a, (hl) 
bd86					if DEBUG_FORTH_WORDS 
bd86						DMARK "TC5" 
bd86 f5				push af  
bd87 3a 9b bd			ld a, (.dmark)  
bd8a 32 7a ee			ld (debug_mark),a  
bd8d 3a 9c bd			ld a, (.dmark+1)  
bd90 32 7b ee			ld (debug_mark+1),a  
bd93 3a 9d bd			ld a, (.dmark+2)  
bd96 32 7c ee			ld (debug_mark+2),a  
bd99 18 03			jr .pastdmark  
bd9b ..			.dmark: db "TC5"  
bd9e f1			.pastdmark: pop af  
bd9f			endm  
# End of macro DMARK
bd9f						CALLMONITOR 
bd9f cd 6c 93			call break_point_state  
bda2				endm  
# End of macro CALLMONITOR
bda2					endif 
bda2 18 c0				jr .totsp 
bda4 fe 00		.totsiptou:    cp 0 
bda6 28 40				jr z, .totdone 
bda8					; not space and not zero term so upper case it 
bda8 cd 2b 8e				call to_upper 
bdab			 
bdab					if DEBUG_FORTH_WORDS 
bdab						DMARK "TC6" 
bdab f5				push af  
bdac 3a c0 bd			ld a, (.dmark)  
bdaf 32 7a ee			ld (debug_mark),a  
bdb2 3a c1 bd			ld a, (.dmark+1)  
bdb5 32 7b ee			ld (debug_mark+1),a  
bdb8 3a c2 bd			ld a, (.dmark+2)  
bdbb 32 7c ee			ld (debug_mark+2),a  
bdbe 18 03			jr .pastdmark  
bdc0 ..			.dmark: db "TC6"  
bdc3 f1			.pastdmark: pop af  
bdc4			endm  
# End of macro DMARK
bdc4						CALLMONITOR 
bdc4 cd 6c 93			call break_point_state  
bdc7				endm  
# End of macro CALLMONITOR
bdc7					endif 
bdc7			 
bdc7			 
bdc7			.totnxt: 
bdc7			 
bdc7 77					ld (hl), a 
bdc8 23					inc hl 
bdc9					if DEBUG_FORTH_WORDS 
bdc9						DMARK "TC7" 
bdc9 f5				push af  
bdca 3a de bd			ld a, (.dmark)  
bdcd 32 7a ee			ld (debug_mark),a  
bdd0 3a df bd			ld a, (.dmark+1)  
bdd3 32 7b ee			ld (debug_mark+1),a  
bdd6 3a e0 bd			ld a, (.dmark+2)  
bdd9 32 7c ee			ld (debug_mark+2),a  
bddc 18 03			jr .pastdmark  
bdde ..			.dmark: db "TC7"  
bde1 f1			.pastdmark: pop af  
bde2			endm  
# End of macro DMARK
bde2						CALLMONITOR 
bde2 cd 6c 93			call break_point_state  
bde5				endm  
# End of macro CALLMONITOR
bde5					endif 
bde5 c3 1d bd				jp .tot 
bde8			 
bde8					 
bde8			 
bde8			 
bde8			; for each char convert to low 
bde8					 
bde8			.totdone: 
bde8					if DEBUG_FORTH_WORDS 
bde8						DMARK "TCd" 
bde8 f5				push af  
bde9 3a fd bd			ld a, (.dmark)  
bdec 32 7a ee			ld (debug_mark),a  
bdef 3a fe bd			ld a, (.dmark+1)  
bdf2 32 7b ee			ld (debug_mark+1),a  
bdf5 3a ff bd			ld a, (.dmark+2)  
bdf8 32 7c ee			ld (debug_mark+2),a  
bdfb 18 03			jr .pastdmark  
bdfd ..			.dmark: db "TCd"  
be00 f1			.pastdmark: pop af  
be01			endm  
# End of macro DMARK
be01						CALLMONITOR 
be01 cd 6c 93			call break_point_state  
be04				endm  
# End of macro CALLMONITOR
be04					endif 
be04					NEXTW 
be04 c3 62 9c			jp macro_next 
be07				endm 
# End of macro NEXTW
be07			 
be07			.SUBSTR: 
be07				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
be07 48				db WORD_SYS_CORE+52             
be08 65 be			dw .LEFT            
be0a 07				db 6 + 1 
be0b .. 00			db "SUBSTR",0              
be12				endm 
# End of macro CWHEAD
be12			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
be12			 
be12					if DEBUG_FORTH_WORDS_KEY 
be12						DMARK "SST" 
be12 f5				push af  
be13 3a 27 be			ld a, (.dmark)  
be16 32 7a ee			ld (debug_mark),a  
be19 3a 28 be			ld a, (.dmark+1)  
be1c 32 7b ee			ld (debug_mark+1),a  
be1f 3a 29 be			ld a, (.dmark+2)  
be22 32 7c ee			ld (debug_mark+2),a  
be25 18 03			jr .pastdmark  
be27 ..			.dmark: db "SST"  
be2a f1			.pastdmark: pop af  
be2b			endm  
# End of macro DMARK
be2b						CALLMONITOR 
be2b cd 6c 93			call break_point_state  
be2e				endm  
# End of macro CALLMONITOR
be2e					endif 
be2e			; TODO check string type 
be2e					FORTH_DSP_VALUEHL 
be2e cd f0 9a			call macro_dsp_valuehl 
be31				endm 
# End of macro FORTH_DSP_VALUEHL
be31			 
be31 e5					push hl      ; string length 
be32			 
be32					FORTH_DSP_POP 
be32 cd a8 9b			call macro_forth_dsp_pop 
be35				endm 
# End of macro FORTH_DSP_POP
be35			 
be35					FORTH_DSP_VALUEHL 
be35 cd f0 9a			call macro_dsp_valuehl 
be38				endm 
# End of macro FORTH_DSP_VALUEHL
be38			 
be38 e5					push hl     ; start char 
be39			 
be39					FORTH_DSP_POP 
be39 cd a8 9b			call macro_forth_dsp_pop 
be3c				endm 
# End of macro FORTH_DSP_POP
be3c			 
be3c			 
be3c					FORTH_DSP_VALUE 
be3c cd d9 9a			call macro_forth_dsp_value 
be3f				endm 
# End of macro FORTH_DSP_VALUE
be3f			 
be3f d1					pop de    ; get start post offset 
be40			 
be40 19					add hl, de    ; starting offset 
be41			 
be41 c1					pop bc 
be42 c5					push bc      ; grab size of string 
be43			 
be43 e5					push hl    ; save string start  
be44			 
be44 26 00				ld h, 0 
be46 69					ld l, c 
be47 23					inc hl 
be48 23					inc hl 
be49			 
be49 cd 85 8f				call malloc 
be4c				if DEBUG_FORTH_MALLOC_GUARD 
be4c cc 94 c4				call z,malloc_error 
be4f				endif 
be4f			 
be4f eb					ex de, hl      ; save malloc area for string copy 
be50 e1					pop hl    ; get back source 
be51 c1					pop bc    ; get length of string back 
be52			 
be52 d5					push de    ; save malloc area for after we push 
be53 ed b0				ldir     ; copy substr 
be55			 
be55			 
be55 eb					ex de, hl 
be56 3e 00				ld a, 0 
be58 77					ld (hl), a   ; term substr 
be59			 
be59					 
be59 e1					pop hl    ; get malloc so we can push it 
be5a e5					push hl   ; save so we can free it afterwards 
be5b			 
be5b cd 67 99				call forth_push_str 
be5e			 
be5e e1					pop hl 
be5f cd 4f 90				call free 
be62			 
be62					 
be62					 
be62			 
be62			 
be62					NEXTW 
be62 c3 62 9c			jp macro_next 
be65				endm 
# End of macro NEXTW
be65			 
be65			.LEFT: 
be65				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
be65 48				db WORD_SYS_CORE+52             
be66 8d be			dw .RIGHT            
be68 05				db 4 + 1 
be69 .. 00			db "LEFT",0              
be6e				endm 
# End of macro CWHEAD
be6e			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
be6e					if DEBUG_FORTH_WORDS_KEY 
be6e						DMARK "LEF" 
be6e f5				push af  
be6f 3a 83 be			ld a, (.dmark)  
be72 32 7a ee			ld (debug_mark),a  
be75 3a 84 be			ld a, (.dmark+1)  
be78 32 7b ee			ld (debug_mark+1),a  
be7b 3a 85 be			ld a, (.dmark+2)  
be7e 32 7c ee			ld (debug_mark+2),a  
be81 18 03			jr .pastdmark  
be83 ..			.dmark: db "LEF"  
be86 f1			.pastdmark: pop af  
be87			endm  
# End of macro DMARK
be87						CALLMONITOR 
be87 cd 6c 93			call break_point_state  
be8a				endm  
# End of macro CALLMONITOR
be8a					endif 
be8a			 
be8a					NEXTW 
be8a c3 62 9c			jp macro_next 
be8d				endm 
# End of macro NEXTW
be8d			.RIGHT: 
be8d				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
be8d 48				db WORD_SYS_CORE+52             
be8e b6 be			dw .STR2NUM            
be90 06				db 5 + 1 
be91 .. 00			db "RIGHT",0              
be97				endm 
# End of macro CWHEAD
be97			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
be97					if DEBUG_FORTH_WORDS_KEY 
be97						DMARK "RIG" 
be97 f5				push af  
be98 3a ac be			ld a, (.dmark)  
be9b 32 7a ee			ld (debug_mark),a  
be9e 3a ad be			ld a, (.dmark+1)  
bea1 32 7b ee			ld (debug_mark+1),a  
bea4 3a ae be			ld a, (.dmark+2)  
bea7 32 7c ee			ld (debug_mark+2),a  
beaa 18 03			jr .pastdmark  
beac ..			.dmark: db "RIG"  
beaf f1			.pastdmark: pop af  
beb0			endm  
# End of macro DMARK
beb0						CALLMONITOR 
beb0 cd 6c 93			call break_point_state  
beb3				endm  
# End of macro CALLMONITOR
beb3					endif 
beb3			 
beb3					NEXTW 
beb3 c3 62 9c			jp macro_next 
beb6				endm 
# End of macro NEXTW
beb6			 
beb6			 
beb6			.STR2NUM: 
beb6				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
beb6 48				db WORD_SYS_CORE+52             
beb7 42 bf			dw .NUM2STR            
beb9 08				db 7 + 1 
beba .. 00			db "STR2NUM",0              
bec2				endm 
# End of macro CWHEAD
bec2			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
bec2			 
bec2			 
bec2			; TODO STR type check to do 
bec2					if DEBUG_FORTH_WORDS_KEY 
bec2						DMARK "S2N" 
bec2 f5				push af  
bec3 3a d7 be			ld a, (.dmark)  
bec6 32 7a ee			ld (debug_mark),a  
bec9 3a d8 be			ld a, (.dmark+1)  
becc 32 7b ee			ld (debug_mark+1),a  
becf 3a d9 be			ld a, (.dmark+2)  
bed2 32 7c ee			ld (debug_mark+2),a  
bed5 18 03			jr .pastdmark  
bed7 ..			.dmark: db "S2N"  
beda f1			.pastdmark: pop af  
bedb			endm  
# End of macro DMARK
bedb						CALLMONITOR 
bedb cd 6c 93			call break_point_state  
bede				endm  
# End of macro CALLMONITOR
bede					endif 
bede			 
bede					;FORTH_DSP 
bede					FORTH_DSP_VALUE 
bede cd d9 9a			call macro_forth_dsp_value 
bee1				endm 
# End of macro FORTH_DSP_VALUE
bee1					;inc hl 
bee1			 
bee1 eb					ex de, hl 
bee2					if DEBUG_FORTH_WORDS 
bee2						DMARK "S2a" 
bee2 f5				push af  
bee3 3a f7 be			ld a, (.dmark)  
bee6 32 7a ee			ld (debug_mark),a  
bee9 3a f8 be			ld a, (.dmark+1)  
beec 32 7b ee			ld (debug_mark+1),a  
beef 3a f9 be			ld a, (.dmark+2)  
bef2 32 7c ee			ld (debug_mark+2),a  
bef5 18 03			jr .pastdmark  
bef7 ..			.dmark: db "S2a"  
befa f1			.pastdmark: pop af  
befb			endm  
# End of macro DMARK
befb						CALLMONITOR 
befb cd 6c 93			call break_point_state  
befe				endm  
# End of macro CALLMONITOR
befe					endif 
befe cd b3 8e				call string_to_uint16 
bf01			 
bf01					if DEBUG_FORTH_WORDS 
bf01						DMARK "S2b" 
bf01 f5				push af  
bf02 3a 16 bf			ld a, (.dmark)  
bf05 32 7a ee			ld (debug_mark),a  
bf08 3a 17 bf			ld a, (.dmark+1)  
bf0b 32 7b ee			ld (debug_mark+1),a  
bf0e 3a 18 bf			ld a, (.dmark+2)  
bf11 32 7c ee			ld (debug_mark+2),a  
bf14 18 03			jr .pastdmark  
bf16 ..			.dmark: db "S2b"  
bf19 f1			.pastdmark: pop af  
bf1a			endm  
# End of macro DMARK
bf1a						CALLMONITOR 
bf1a cd 6c 93			call break_point_state  
bf1d				endm  
# End of macro CALLMONITOR
bf1d					endif 
bf1d			;		push hl 
bf1d					FORTH_DSP_POP 
bf1d cd a8 9b			call macro_forth_dsp_pop 
bf20				endm 
# End of macro FORTH_DSP_POP
bf20			;		pop hl 
bf20					 
bf20					if DEBUG_FORTH_WORDS 
bf20						DMARK "S2b" 
bf20 f5				push af  
bf21 3a 35 bf			ld a, (.dmark)  
bf24 32 7a ee			ld (debug_mark),a  
bf27 3a 36 bf			ld a, (.dmark+1)  
bf2a 32 7b ee			ld (debug_mark+1),a  
bf2d 3a 37 bf			ld a, (.dmark+2)  
bf30 32 7c ee			ld (debug_mark+2),a  
bf33 18 03			jr .pastdmark  
bf35 ..			.dmark: db "S2b"  
bf38 f1			.pastdmark: pop af  
bf39			endm  
# End of macro DMARK
bf39						CALLMONITOR 
bf39 cd 6c 93			call break_point_state  
bf3c				endm  
# End of macro CALLMONITOR
bf3c					endif 
bf3c cd f9 98				call forth_push_numhl	 
bf3f			 
bf3f				 
bf3f				       NEXTW 
bf3f c3 62 9c			jp macro_next 
bf42				endm 
# End of macro NEXTW
bf42			.NUM2STR: 
bf42				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
bf42 48				db WORD_SYS_CORE+52             
bf43 51 bf			dw .CONCAT            
bf45 08				db 7 + 1 
bf46 .. 00			db "NUM2STR",0              
bf4e				endm 
# End of macro CWHEAD
bf4e			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
bf4e			 
bf4e			;		; malloc a string to target 
bf4e			;		ld hl, 10     ; TODO max string size should be fine 
bf4e			;		call malloc 
bf4e			;		push hl    ; save malloc location 
bf4e			; 
bf4e			; 
bf4e			;; TODO check int type 
bf4e			;		FORTH_DSP_VALUEHL 
bf4e			;		ld a, l 
bf4e			;		call DispAToASCII   
bf4e			;;TODO need to chage above call to dump into string 
bf4e			; 
bf4e			; 
bf4e			 
bf4e				       NEXTW 
bf4e c3 62 9c			jp macro_next 
bf51				endm 
# End of macro NEXTW
bf51			 
bf51			.CONCAT: 
bf51				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
bf51 48				db WORD_SYS_CORE+52             
bf52 04 c0			dw .FIND            
bf54 07				db 6 + 1 
bf55 .. 00			db "CONCAT",0              
bf5c				endm 
# End of macro CWHEAD
bf5c			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
bf5c			 
bf5c			; TODO check string type 
bf5c			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
bf5c			 
bf5c					if DEBUG_FORTH_WORDS_KEY 
bf5c						DMARK "CON" 
bf5c f5				push af  
bf5d 3a 71 bf			ld a, (.dmark)  
bf60 32 7a ee			ld (debug_mark),a  
bf63 3a 72 bf			ld a, (.dmark+1)  
bf66 32 7b ee			ld (debug_mark+1),a  
bf69 3a 73 bf			ld a, (.dmark+2)  
bf6c 32 7c ee			ld (debug_mark+2),a  
bf6f 18 03			jr .pastdmark  
bf71 ..			.dmark: db "CON"  
bf74 f1			.pastdmark: pop af  
bf75			endm  
# End of macro DMARK
bf75						CALLMONITOR 
bf75 cd 6c 93			call break_point_state  
bf78				endm  
# End of macro CALLMONITOR
bf78					endif 
bf78			 
bf78			 
bf78					FORTH_DSP_VALUE 
bf78 cd d9 9a			call macro_forth_dsp_value 
bf7b				endm 
# End of macro FORTH_DSP_VALUE
bf7b e5					push hl   ; s2 
bf7c			 
bf7c					FORTH_DSP_POP 
bf7c cd a8 9b			call macro_forth_dsp_pop 
bf7f				endm 
# End of macro FORTH_DSP_POP
bf7f			 
bf7f					FORTH_DSP_VALUE 
bf7f cd d9 9a			call macro_forth_dsp_value 
bf82				endm 
# End of macro FORTH_DSP_VALUE
bf82			 
bf82 e5					push hl   ; s1 
bf83			 
bf83					FORTH_DSP_POP 
bf83 cd a8 9b			call macro_forth_dsp_pop 
bf86				endm 
# End of macro FORTH_DSP_POP
bf86					 
bf86			 
bf86					; copy s1 
bf86			 
bf86				 
bf86					; save ptr 
bf86 e1					pop hl  
bf87 e5					push hl 
bf88 3e 00				ld a, 0 
bf8a cd 27 8f				call strlent 
bf8d					;inc hl    ; zer0 
bf8d 06 00				ld b, 0 
bf8f 4d					ld c, l 
bf90 e1					pop hl		 
bf91 11 60 e3				ld de, scratch	 
bf94					if DEBUG_FORTH_WORDS 
bf94						DMARK "CO1" 
bf94 f5				push af  
bf95 3a a9 bf			ld a, (.dmark)  
bf98 32 7a ee			ld (debug_mark),a  
bf9b 3a aa bf			ld a, (.dmark+1)  
bf9e 32 7b ee			ld (debug_mark+1),a  
bfa1 3a ab bf			ld a, (.dmark+2)  
bfa4 32 7c ee			ld (debug_mark+2),a  
bfa7 18 03			jr .pastdmark  
bfa9 ..			.dmark: db "CO1"  
bfac f1			.pastdmark: pop af  
bfad			endm  
# End of macro DMARK
bfad						CALLMONITOR 
bfad cd 6c 93			call break_point_state  
bfb0				endm  
# End of macro CALLMONITOR
bfb0					endif 
bfb0 ed b0				ldir 
bfb2			 
bfb2 e1					pop hl 
bfb3 e5					push hl 
bfb4 d5					push de 
bfb5			 
bfb5			 
bfb5 3e 00				ld a, 0 
bfb7 cd 27 8f				call strlent 
bfba 23					inc hl    ; zer0 
bfbb 23					inc hl 
bfbc 06 00				ld b, 0 
bfbe 4d					ld c, l 
bfbf d1					pop de 
bfc0 e1					pop hl		 
bfc1					if DEBUG_FORTH_WORDS 
bfc1						DMARK "CO2" 
bfc1 f5				push af  
bfc2 3a d6 bf			ld a, (.dmark)  
bfc5 32 7a ee			ld (debug_mark),a  
bfc8 3a d7 bf			ld a, (.dmark+1)  
bfcb 32 7b ee			ld (debug_mark+1),a  
bfce 3a d8 bf			ld a, (.dmark+2)  
bfd1 32 7c ee			ld (debug_mark+2),a  
bfd4 18 03			jr .pastdmark  
bfd6 ..			.dmark: db "CO2"  
bfd9 f1			.pastdmark: pop af  
bfda			endm  
# End of macro DMARK
bfda						CALLMONITOR 
bfda cd 6c 93			call break_point_state  
bfdd				endm  
# End of macro CALLMONITOR
bfdd					endif 
bfdd ed b0				ldir 
bfdf			 
bfdf			 
bfdf			 
bfdf 21 60 e3				ld hl, scratch 
bfe2					if DEBUG_FORTH_WORDS 
bfe2						DMARK "CO5" 
bfe2 f5				push af  
bfe3 3a f7 bf			ld a, (.dmark)  
bfe6 32 7a ee			ld (debug_mark),a  
bfe9 3a f8 bf			ld a, (.dmark+1)  
bfec 32 7b ee			ld (debug_mark+1),a  
bfef 3a f9 bf			ld a, (.dmark+2)  
bff2 32 7c ee			ld (debug_mark+2),a  
bff5 18 03			jr .pastdmark  
bff7 ..			.dmark: db "CO5"  
bffa f1			.pastdmark: pop af  
bffb			endm  
# End of macro DMARK
bffb						CALLMONITOR 
bffb cd 6c 93			call break_point_state  
bffe				endm  
# End of macro CALLMONITOR
bffe					endif 
bffe			 
bffe cd 67 99				call forth_push_str 
c001			 
c001			 
c001			 
c001			 
c001				       NEXTW 
c001 c3 62 9c			jp macro_next 
c004				endm 
# End of macro NEXTW
c004			 
c004			 
c004			.FIND: 
c004				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
c004 4b				db WORD_SYS_CORE+55             
c005 c2 c0			dw .LEN            
c007 05				db 4 + 1 
c008 .. 00			db "FIND",0              
c00d				endm 
# End of macro CWHEAD
c00d			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
c00d			 
c00d					if DEBUG_FORTH_WORDS_KEY 
c00d						DMARK "FND" 
c00d f5				push af  
c00e 3a 22 c0			ld a, (.dmark)  
c011 32 7a ee			ld (debug_mark),a  
c014 3a 23 c0			ld a, (.dmark+1)  
c017 32 7b ee			ld (debug_mark+1),a  
c01a 3a 24 c0			ld a, (.dmark+2)  
c01d 32 7c ee			ld (debug_mark+2),a  
c020 18 03			jr .pastdmark  
c022 ..			.dmark: db "FND"  
c025 f1			.pastdmark: pop af  
c026			endm  
# End of macro DMARK
c026						CALLMONITOR 
c026 cd 6c 93			call break_point_state  
c029				endm  
# End of macro CALLMONITOR
c029					endif 
c029			 
c029			; TODO check string type 
c029					FORTH_DSP_VALUE 
c029 cd d9 9a			call macro_forth_dsp_value 
c02c				endm 
# End of macro FORTH_DSP_VALUE
c02c			 
c02c e5					push hl    
c02d 7e					ld a,(hl)    ; char to find   
c02e			; TODO change char to substr 
c02e			 
c02e f5					push af 
c02f					 
c02f			 
c02f			 
c02f					if DEBUG_FORTH_WORDS 
c02f						DMARK "FN1" 
c02f f5				push af  
c030 3a 44 c0			ld a, (.dmark)  
c033 32 7a ee			ld (debug_mark),a  
c036 3a 45 c0			ld a, (.dmark+1)  
c039 32 7b ee			ld (debug_mark+1),a  
c03c 3a 46 c0			ld a, (.dmark+2)  
c03f 32 7c ee			ld (debug_mark+2),a  
c042 18 03			jr .pastdmark  
c044 ..			.dmark: db "FN1"  
c047 f1			.pastdmark: pop af  
c048			endm  
# End of macro DMARK
c048						CALLMONITOR 
c048 cd 6c 93			call break_point_state  
c04b				endm  
# End of macro CALLMONITOR
c04b					endif 
c04b			 
c04b					FORTH_DSP_POP 
c04b cd a8 9b			call macro_forth_dsp_pop 
c04e				endm 
# End of macro FORTH_DSP_POP
c04e			 
c04e					; string to search 
c04e			 
c04e					FORTH_DSP_VALUE 
c04e cd d9 9a			call macro_forth_dsp_value 
c051				endm 
# End of macro FORTH_DSP_VALUE
c051			 
c051 d1					pop de  ; d is char to find  
c052			 
c052					if DEBUG_FORTH_WORDS 
c052						DMARK "FN2" 
c052 f5				push af  
c053 3a 67 c0			ld a, (.dmark)  
c056 32 7a ee			ld (debug_mark),a  
c059 3a 68 c0			ld a, (.dmark+1)  
c05c 32 7b ee			ld (debug_mark+1),a  
c05f 3a 69 c0			ld a, (.dmark+2)  
c062 32 7c ee			ld (debug_mark+2),a  
c065 18 03			jr .pastdmark  
c067 ..			.dmark: db "FN2"  
c06a f1			.pastdmark: pop af  
c06b			endm  
# End of macro DMARK
c06b						CALLMONITOR 
c06b cd 6c 93			call break_point_state  
c06e				endm  
# End of macro CALLMONITOR
c06e					endif 
c06e					 
c06e 01 00 00				ld bc, 0 
c071 7e			.findchar:      ld a,(hl) 
c072 fe 00				cp 0   		 
c074 28 27				jr z, .finddone     
c076 ba					cp d 
c077 28 20				jr z, .foundchar 
c079 03					inc bc 
c07a 23					inc hl 
c07b					if DEBUG_FORTH_WORDS 
c07b						DMARK "FN3" 
c07b f5				push af  
c07c 3a 90 c0			ld a, (.dmark)  
c07f 32 7a ee			ld (debug_mark),a  
c082 3a 91 c0			ld a, (.dmark+1)  
c085 32 7b ee			ld (debug_mark+1),a  
c088 3a 92 c0			ld a, (.dmark+2)  
c08b 32 7c ee			ld (debug_mark+2),a  
c08e 18 03			jr .pastdmark  
c090 ..			.dmark: db "FN3"  
c093 f1			.pastdmark: pop af  
c094			endm  
# End of macro DMARK
c094						CALLMONITOR 
c094 cd 6c 93			call break_point_state  
c097				endm  
# End of macro CALLMONITOR
c097					endif 
c097 18 d8				jr .findchar 
c099			 
c099			 
c099 c5			.foundchar:	push bc 
c09a e1					pop hl 
c09b 18 03				jr .findexit 
c09d			 
c09d			 
c09d							 
c09d			 
c09d			.finddone:     ; got to end of string with no find 
c09d 21 00 00				ld hl, 0 
c0a0			.findexit: 
c0a0			 
c0a0					if DEBUG_FORTH_WORDS 
c0a0						DMARK "FNd" 
c0a0 f5				push af  
c0a1 3a b5 c0			ld a, (.dmark)  
c0a4 32 7a ee			ld (debug_mark),a  
c0a7 3a b6 c0			ld a, (.dmark+1)  
c0aa 32 7b ee			ld (debug_mark+1),a  
c0ad 3a b7 c0			ld a, (.dmark+2)  
c0b0 32 7c ee			ld (debug_mark+2),a  
c0b3 18 03			jr .pastdmark  
c0b5 ..			.dmark: db "FNd"  
c0b8 f1			.pastdmark: pop af  
c0b9			endm  
# End of macro DMARK
c0b9						CALLMONITOR 
c0b9 cd 6c 93			call break_point_state  
c0bc				endm  
# End of macro CALLMONITOR
c0bc					endif 
c0bc cd f9 98			call forth_push_numhl 
c0bf			 
c0bf				       NEXTW 
c0bf c3 62 9c			jp macro_next 
c0c2				endm 
# End of macro NEXTW
c0c2			 
c0c2			.LEN: 
c0c2				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
c0c2 4c				db WORD_SYS_CORE+56             
c0c3 f7 c0			dw .CHAR            
c0c5 06				db 5 + 1 
c0c6 .. 00			db "COUNT",0              
c0cc				endm 
# End of macro CWHEAD
c0cc			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
c0cc			 
c0cc					if DEBUG_FORTH_WORDS_KEY 
c0cc						DMARK "CNT" 
c0cc f5				push af  
c0cd 3a e1 c0			ld a, (.dmark)  
c0d0 32 7a ee			ld (debug_mark),a  
c0d3 3a e2 c0			ld a, (.dmark+1)  
c0d6 32 7b ee			ld (debug_mark+1),a  
c0d9 3a e3 c0			ld a, (.dmark+2)  
c0dc 32 7c ee			ld (debug_mark+2),a  
c0df 18 03			jr .pastdmark  
c0e1 ..			.dmark: db "CNT"  
c0e4 f1			.pastdmark: pop af  
c0e5			endm  
# End of macro DMARK
c0e5						CALLMONITOR 
c0e5 cd 6c 93			call break_point_state  
c0e8				endm  
# End of macro CALLMONITOR
c0e8					endif 
c0e8			; TODO check string type 
c0e8					FORTH_DSP 
c0e8 cd b6 9a			call macro_forth_dsp 
c0eb				endm 
# End of macro FORTH_DSP
c0eb					;v5FORTH_DSP_VALUE 
c0eb			 
c0eb 23					inc hl 
c0ec			 
c0ec 3e 00				ld a, 0 
c0ee cd 27 8f				call strlent 
c0f1			 
c0f1 cd f9 98				call forth_push_numhl 
c0f4			 
c0f4			 
c0f4			 
c0f4				       NEXTW 
c0f4 c3 62 9c			jp macro_next 
c0f7				endm 
# End of macro NEXTW
c0f7			.CHAR: 
c0f7				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
c0f7 4d				db WORD_SYS_CORE+57             
c0f8 2d c1			dw .ENDSTR            
c0fa 05				db 4 + 1 
c0fb .. 00			db "CHAR",0              
c100				endm 
# End of macro CWHEAD
c100			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
c100					if DEBUG_FORTH_WORDS_KEY 
c100						DMARK "CHR" 
c100 f5				push af  
c101 3a 15 c1			ld a, (.dmark)  
c104 32 7a ee			ld (debug_mark),a  
c107 3a 16 c1			ld a, (.dmark+1)  
c10a 32 7b ee			ld (debug_mark+1),a  
c10d 3a 17 c1			ld a, (.dmark+2)  
c110 32 7c ee			ld (debug_mark+2),a  
c113 18 03			jr .pastdmark  
c115 ..			.dmark: db "CHR"  
c118 f1			.pastdmark: pop af  
c119			endm  
# End of macro DMARK
c119						CALLMONITOR 
c119 cd 6c 93			call break_point_state  
c11c				endm  
# End of macro CALLMONITOR
c11c					endif 
c11c					FORTH_DSP 
c11c cd b6 9a			call macro_forth_dsp 
c11f				endm 
# End of macro FORTH_DSP
c11f					;v5 FORTH_DSP_VALUE 
c11f 23					inc hl      ; now at start of numeric as string 
c120			 
c120			;		push hl 
c120			 
c120					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c120 cd a8 9b			call macro_forth_dsp_pop 
c123				endm 
# End of macro FORTH_DSP_POP
c123			 
c123			;		pop hl 
c123			 
c123					; push the content of a onto the stack as a value 
c123			 
c123 7e					ld a,(hl)   ; get char 
c124 26 00				ld h,0 
c126 6f					ld l,a 
c127 cd f9 98				call forth_push_numhl 
c12a			 
c12a				       NEXTW 
c12a c3 62 9c			jp macro_next 
c12d				endm 
# End of macro NEXTW
c12d			 
c12d			 
c12d			 
c12d			 
c12d			.ENDSTR: 
c12d			; eof 
c12d			 
# End of file forth_words_str.asm
c12d			include "forth_words_key.asm" 
c12d			 
c12d			; | ## Keyboard Words 
c12d			 
c12d			.KEY: 
c12d				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
c12d 3e				db WORD_SYS_CORE+42             
c12e 5d c1			dw .WAITK            
c130 04				db 3 + 1 
c131 .. 00			db "KEY",0              
c135				endm 
# End of macro CWHEAD
c135			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
c135			 
c135					if DEBUG_FORTH_WORDS_KEY 
c135						DMARK "KEY" 
c135 f5				push af  
c136 3a 4a c1			ld a, (.dmark)  
c139 32 7a ee			ld (debug_mark),a  
c13c 3a 4b c1			ld a, (.dmark+1)  
c13f 32 7b ee			ld (debug_mark+1),a  
c142 3a 4c c1			ld a, (.dmark+2)  
c145 32 7c ee			ld (debug_mark+2),a  
c148 18 03			jr .pastdmark  
c14a ..			.dmark: db "KEY"  
c14d f1			.pastdmark: pop af  
c14e			endm  
# End of macro DMARK
c14e						CALLMONITOR 
c14e cd 6c 93			call break_point_state  
c151				endm  
# End of macro CALLMONITOR
c151					endif 
c151			; TODO currently waits 
c151 cd d0 d7				call cin 
c154					;call cin_wait 
c154 6f					ld l, a 
c155 26 00				ld h, 0 
c157 cd f9 98				call forth_push_numhl 
c15a					NEXTW 
c15a c3 62 9c			jp macro_next 
c15d				endm 
# End of macro NEXTW
c15d			.WAITK: 
c15d				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
c15d 3f				db WORD_SYS_CORE+43             
c15e 8f c1			dw .ACCEPT            
c160 06				db 5 + 1 
c161 .. 00			db "WAITK",0              
c167				endm 
# End of macro CWHEAD
c167			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
c167					if DEBUG_FORTH_WORDS_KEY 
c167						DMARK "WAI" 
c167 f5				push af  
c168 3a 7c c1			ld a, (.dmark)  
c16b 32 7a ee			ld (debug_mark),a  
c16e 3a 7d c1			ld a, (.dmark+1)  
c171 32 7b ee			ld (debug_mark+1),a  
c174 3a 7e c1			ld a, (.dmark+2)  
c177 32 7c ee			ld (debug_mark+2),a  
c17a 18 03			jr .pastdmark  
c17c ..			.dmark: db "WAI"  
c17f f1			.pastdmark: pop af  
c180			endm  
# End of macro DMARK
c180						CALLMONITOR 
c180 cd 6c 93			call break_point_state  
c183				endm  
# End of macro CALLMONITOR
c183					endif 
c183 cd ca d7				call cin_wait 
c186 6f					ld l, a 
c187 26 00				ld h, 0 
c189 cd f9 98				call forth_push_numhl 
c18c					NEXTW 
c18c c3 62 9c			jp macro_next 
c18f				endm 
# End of macro NEXTW
c18f			.ACCEPT: 
c18f				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
c18f 40				db WORD_SYS_CORE+44             
c190 ed c1			dw .EDIT            
c192 07				db 6 + 1 
c193 .. 00			db "ACCEPT",0              
c19a				endm 
# End of macro CWHEAD
c19a			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
c19a					; TODO crashes on push 
c19a					if DEBUG_FORTH_WORDS_KEY 
c19a						DMARK "ACC" 
c19a f5				push af  
c19b 3a af c1			ld a, (.dmark)  
c19e 32 7a ee			ld (debug_mark),a  
c1a1 3a b0 c1			ld a, (.dmark+1)  
c1a4 32 7b ee			ld (debug_mark+1),a  
c1a7 3a b1 c1			ld a, (.dmark+2)  
c1aa 32 7c ee			ld (debug_mark+2),a  
c1ad 18 03			jr .pastdmark  
c1af ..			.dmark: db "ACC"  
c1b2 f1			.pastdmark: pop af  
c1b3			endm  
# End of macro DMARK
c1b3						CALLMONITOR 
c1b3 cd 6c 93			call break_point_state  
c1b6				endm  
# End of macro CALLMONITOR
c1b6					endif 
c1b6 21 5e e5				ld hl, os_input 
c1b9 3e 00				ld a, 0 
c1bb 77					ld (hl),a 
c1bc 3a 49 eb				ld a,(f_cursor_ptr) 
c1bf 16 64				ld d, 100 
c1c1 0e 00				ld c, 0 
c1c3 1e 28				ld e, 40 
c1c5 cd eb 8a				call input_str 
c1c8					; TODO perhaps do a type check and wrap in quotes if not a number 
c1c8 21 5e e5				ld hl, os_input 
c1cb					if DEBUG_FORTH_WORDS 
c1cb						DMARK "AC1" 
c1cb f5				push af  
c1cc 3a e0 c1			ld a, (.dmark)  
c1cf 32 7a ee			ld (debug_mark),a  
c1d2 3a e1 c1			ld a, (.dmark+1)  
c1d5 32 7b ee			ld (debug_mark+1),a  
c1d8 3a e2 c1			ld a, (.dmark+2)  
c1db 32 7c ee			ld (debug_mark+2),a  
c1de 18 03			jr .pastdmark  
c1e0 ..			.dmark: db "AC1"  
c1e3 f1			.pastdmark: pop af  
c1e4			endm  
# End of macro DMARK
c1e4						CALLMONITOR 
c1e4 cd 6c 93			call break_point_state  
c1e7				endm  
# End of macro CALLMONITOR
c1e7					endif 
c1e7 cd 67 99				call forth_push_str 
c1ea					NEXTW 
c1ea c3 62 9c			jp macro_next 
c1ed				endm 
# End of macro NEXTW
c1ed			 
c1ed			.EDIT: 
c1ed				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
c1ed 40				db WORD_SYS_CORE+44             
c1ee 8f c2			dw .ENDKEY            
c1f0 05				db 4 + 1 
c1f1 .. 00			db "EDIT",0              
c1f6				endm 
# End of macro CWHEAD
c1f6			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
c1f6			 
c1f6					; TODO does not copy from stack 
c1f6					if DEBUG_FORTH_WORDS_KEY 
c1f6						DMARK "EDT" 
c1f6 f5				push af  
c1f7 3a 0b c2			ld a, (.dmark)  
c1fa 32 7a ee			ld (debug_mark),a  
c1fd 3a 0c c2			ld a, (.dmark+1)  
c200 32 7b ee			ld (debug_mark+1),a  
c203 3a 0d c2			ld a, (.dmark+2)  
c206 32 7c ee			ld (debug_mark+2),a  
c209 18 03			jr .pastdmark  
c20b ..			.dmark: db "EDT"  
c20e f1			.pastdmark: pop af  
c20f			endm  
# End of macro DMARK
c20f						CALLMONITOR 
c20f cd 6c 93			call break_point_state  
c212				endm  
# End of macro CALLMONITOR
c212					endif 
c212			 
c212					;FORTH_DSP 
c212					FORTH_DSP_VALUEHL 
c212 cd f0 9a			call macro_dsp_valuehl 
c215				endm 
# End of macro FORTH_DSP_VALUEHL
c215			;		inc hl    ; TODO do type check 
c215			 
c215			;		call get_word_hl 
c215 e5					push hl 
c216					if DEBUG_FORTH_WORDS 
c216						DMARK "EDp" 
c216 f5				push af  
c217 3a 2b c2			ld a, (.dmark)  
c21a 32 7a ee			ld (debug_mark),a  
c21d 3a 2c c2			ld a, (.dmark+1)  
c220 32 7b ee			ld (debug_mark+1),a  
c223 3a 2d c2			ld a, (.dmark+2)  
c226 32 7c ee			ld (debug_mark+2),a  
c229 18 03			jr .pastdmark  
c22b ..			.dmark: db "EDp"  
c22e f1			.pastdmark: pop af  
c22f			endm  
# End of macro DMARK
c22f						CALLMONITOR 
c22f cd 6c 93			call break_point_state  
c232				endm  
# End of macro CALLMONITOR
c232					endif 
c232				;	ld a, 0 
c232 cd 1c 8f				call strlenz 
c235 23					inc hl 
c236			 
c236 06 00				ld b, 0 
c238 4d					ld c, l 
c239			 
c239 e1					pop hl 
c23a 11 5e e5				ld de, os_input 
c23d					if DEBUG_FORTH_WORDS_KEY 
c23d						DMARK "EDc" 
c23d f5				push af  
c23e 3a 52 c2			ld a, (.dmark)  
c241 32 7a ee			ld (debug_mark),a  
c244 3a 53 c2			ld a, (.dmark+1)  
c247 32 7b ee			ld (debug_mark+1),a  
c24a 3a 54 c2			ld a, (.dmark+2)  
c24d 32 7c ee			ld (debug_mark+2),a  
c250 18 03			jr .pastdmark  
c252 ..			.dmark: db "EDc"  
c255 f1			.pastdmark: pop af  
c256			endm  
# End of macro DMARK
c256						CALLMONITOR 
c256 cd 6c 93			call break_point_state  
c259				endm  
# End of macro CALLMONITOR
c259					endif 
c259 ed b0				ldir 
c25b			 
c25b			 
c25b 21 5e e5				ld hl, os_input 
c25e					;ld a, 0 
c25e					;ld (hl),a 
c25e 3a 49 eb				ld a,(f_cursor_ptr) 
c261 16 64				ld d, 100 
c263 0e 00				ld c, 0 
c265 1e 28				ld e, 40 
c267 cd eb 8a				call input_str 
c26a					; TODO perhaps do a type check and wrap in quotes if not a number 
c26a 21 5e e5				ld hl, os_input 
c26d					if DEBUG_FORTH_WORDS 
c26d						DMARK "ED1" 
c26d f5				push af  
c26e 3a 82 c2			ld a, (.dmark)  
c271 32 7a ee			ld (debug_mark),a  
c274 3a 83 c2			ld a, (.dmark+1)  
c277 32 7b ee			ld (debug_mark+1),a  
c27a 3a 84 c2			ld a, (.dmark+2)  
c27d 32 7c ee			ld (debug_mark+2),a  
c280 18 03			jr .pastdmark  
c282 ..			.dmark: db "ED1"  
c285 f1			.pastdmark: pop af  
c286			endm  
# End of macro DMARK
c286						CALLMONITOR 
c286 cd 6c 93			call break_point_state  
c289				endm  
# End of macro CALLMONITOR
c289					endif 
c289 cd 67 99				call forth_push_str 
c28c					NEXTW 
c28c c3 62 9c			jp macro_next 
c28f				endm 
# End of macro NEXTW
c28f			 
c28f			 
c28f			 
c28f			.ENDKEY: 
c28f			; eof 
c28f			 
# End of file forth_words_key.asm
c28f			 
c28f			if STORAGE_SE 
c28f			   	include "forth_words_storage.asm" 
c28f			endif 
c28f				include "forth_words_device.asm" 
c28f			; Device related words 
c28f			 
c28f			; | ## Device Words 
c28f			 
c28f			if SOUND_ENABLE 
c28f			.NOTE: 
c28f				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
c28f			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
c28f					if DEBUG_FORTH_WORDS_KEY 
c28f						DMARK "NTE" 
c28f						CALLMONITOR 
c28f					endif 
c28f			 
c28f				 
c28f			 
c28f					NEXTW 
c28f			.AFTERSOUND: 
c28f			endif 
c28f			 
c28f			 
c28f			USE_GPIO: equ 0 
c28f			 
c28f			if USE_GPIO 
c28f			.GP1: 
c28f				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
c28f			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
c28f					NEXTW 
c28f			.GP2: 
c28f				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
c28f			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
c28f			 
c28f					NEXTW 
c28f			 
c28f			.GP3: 
c28f				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
c28f			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
c28f			 
c28f					NEXTW 
c28f			 
c28f			.GP4: 
c28f				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
c28f			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
c28f			 
c28f					NEXTW 
c28f			.SIN: 
c28f			 
c28f			 
c28f			endif 
c28f			 
c28f			 
c28f				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
c28f 33				db WORD_SYS_CORE+31             
c290 c4 c2			dw .SOUT            
c292 03				db 2 + 1 
c293 .. 00			db "IN",0              
c296				endm 
# End of macro CWHEAD
c296			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
c296					if DEBUG_FORTH_WORDS_KEY 
c296						DMARK "IN." 
c296 f5				push af  
c297 3a ab c2			ld a, (.dmark)  
c29a 32 7a ee			ld (debug_mark),a  
c29d 3a ac c2			ld a, (.dmark+1)  
c2a0 32 7b ee			ld (debug_mark+1),a  
c2a3 3a ad c2			ld a, (.dmark+2)  
c2a6 32 7c ee			ld (debug_mark+2),a  
c2a9 18 03			jr .pastdmark  
c2ab ..			.dmark: db "IN."  
c2ae f1			.pastdmark: pop af  
c2af			endm  
# End of macro DMARK
c2af						CALLMONITOR 
c2af cd 6c 93			call break_point_state  
c2b2				endm  
# End of macro CALLMONITOR
c2b2					endif 
c2b2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2b2 cd f0 9a			call macro_dsp_valuehl 
c2b5				endm 
# End of macro FORTH_DSP_VALUEHL
c2b5			 
c2b5 e5					push hl 
c2b6			 
c2b6					; destroy value TOS 
c2b6			 
c2b6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2b6 cd a8 9b			call macro_forth_dsp_pop 
c2b9				endm 
# End of macro FORTH_DSP_POP
c2b9			 
c2b9					; one value on hl get other one back 
c2b9			 
c2b9 c1					pop bc 
c2ba			 
c2ba					; do the sub 
c2ba			;		ex de, hl 
c2ba			 
c2ba ed 68				in l,(c) 
c2bc			 
c2bc					; save it 
c2bc			 
c2bc 26 00				ld h,0 
c2be			 
c2be					; TODO push value back onto stack for another op etc 
c2be			 
c2be cd f9 98				call forth_push_numhl 
c2c1					NEXTW 
c2c1 c3 62 9c			jp macro_next 
c2c4				endm 
# End of macro NEXTW
c2c4			.SOUT: 
c2c4				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
c2c4 34				db WORD_SYS_CORE+32             
c2c5 17 c3			dw .SPIO            
c2c7 04				db 3 + 1 
c2c8 .. 00			db "OUT",0              
c2cc				endm 
# End of macro CWHEAD
c2cc			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
c2cc					if DEBUG_FORTH_WORDS_KEY 
c2cc						DMARK "OUT" 
c2cc f5				push af  
c2cd 3a e1 c2			ld a, (.dmark)  
c2d0 32 7a ee			ld (debug_mark),a  
c2d3 3a e2 c2			ld a, (.dmark+1)  
c2d6 32 7b ee			ld (debug_mark+1),a  
c2d9 3a e3 c2			ld a, (.dmark+2)  
c2dc 32 7c ee			ld (debug_mark+2),a  
c2df 18 03			jr .pastdmark  
c2e1 ..			.dmark: db "OUT"  
c2e4 f1			.pastdmark: pop af  
c2e5			endm  
# End of macro DMARK
c2e5						CALLMONITOR 
c2e5 cd 6c 93			call break_point_state  
c2e8				endm  
# End of macro CALLMONITOR
c2e8					endif 
c2e8			 
c2e8					; get port 
c2e8			 
c2e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2e8 cd f0 9a			call macro_dsp_valuehl 
c2eb				endm 
# End of macro FORTH_DSP_VALUEHL
c2eb			 
c2eb e5					push hl 
c2ec			 
c2ec					; destroy value TOS 
c2ec			 
c2ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2ec cd a8 9b			call macro_forth_dsp_pop 
c2ef				endm 
# End of macro FORTH_DSP_POP
c2ef			 
c2ef					; get byte to send 
c2ef			 
c2ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c2ef cd f0 9a			call macro_dsp_valuehl 
c2f2				endm 
# End of macro FORTH_DSP_VALUEHL
c2f2			 
c2f2			;		push hl 
c2f2			 
c2f2					; destroy value TOS 
c2f2			 
c2f2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c2f2 cd a8 9b			call macro_forth_dsp_pop 
c2f5				endm 
# End of macro FORTH_DSP_POP
c2f5			 
c2f5					; one value on hl get other one back 
c2f5			 
c2f5			;		pop hl 
c2f5			 
c2f5 c1					pop bc 
c2f6			 
c2f6					if DEBUG_FORTH_WORDS 
c2f6						DMARK "OUT" 
c2f6 f5				push af  
c2f7 3a 0b c3			ld a, (.dmark)  
c2fa 32 7a ee			ld (debug_mark),a  
c2fd 3a 0c c3			ld a, (.dmark+1)  
c300 32 7b ee			ld (debug_mark+1),a  
c303 3a 0d c3			ld a, (.dmark+2)  
c306 32 7c ee			ld (debug_mark+2),a  
c309 18 03			jr .pastdmark  
c30b ..			.dmark: db "OUT"  
c30e f1			.pastdmark: pop af  
c30f			endm  
# End of macro DMARK
c30f						CALLMONITOR 
c30f cd 6c 93			call break_point_state  
c312				endm  
# End of macro CALLMONITOR
c312					endif 
c312			 
c312 ed 69				out (c), l 
c314			 
c314					NEXTW 
c314 c3 62 9c			jp macro_next 
c317				endm 
# End of macro NEXTW
c317			 
c317			 
c317			.SPIO: 
c317			 
c317			if STORAGE_SE 
c317				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
c317			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
c317			 
c317					call spi_ce_low 
c317			    NEXTW 
c317			 
c317			.SPICEH: 
c317				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
c317			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
c317			 
c317					call spi_ce_high 
c317			    NEXTW 
c317			 
c317			 
c317			.SPIOb: 
c317			 
c317				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
c317			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
c317			 
c317					; get port 
c317			 
c317			 
c317					; get byte to send 
c317			 
c317					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c317			 
c317			;		push hl    ; u1  
c317			 
c317					; destroy value TOS 
c317			 
c317					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c317			 
c317					; one value on hl get other one back 
c317			 
c317			;		pop hl   ; u2 - addr 
c317			 
c317					; TODO Send SPI byte 
c317			 
c317					ld a, l 
c317					call spi_send_byte 
c317			 
c317					NEXTW 
c317			 
c317			.SPII: 
c317				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
c317			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
c317			 
c317					; TODO Get SPI byte 
c317			 
c317					call spi_read_byte 
c317			 
c317					ld h, 0 
c317					ld l, a 
c317					call forth_push_numhl 
c317			 
c317					NEXTW 
c317			 
c317			 
c317			 
c317			.SESEL: 
c317				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
c317			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
c317					if DEBUG_FORTH_WORDS_KEY 
c317						DMARK "BNK" 
c317						CALLMONITOR 
c317					endif 
c317			 
c317					ld a, 255 
c317					ld (spi_cartdev), a 
c317			 
c317					; get bank 
c317			 
c317					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c317			 
c317			;		push hl 
c317			 
c317					; destroy value TOS 
c317			 
c317					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c317			 
c317					; one value on hl get other one back 
c317			 
c317			;		pop hl 
c317			 
c317			 
c317					ld c, SPI_CE_HIGH 
c317					ld b, '0'    ; human readable bank number 
c317			 
c317					ld a, l 
c317			 
c317					if DEBUG_FORTH_WORDS 
c317						DMARK "BNK" 
c317						CALLMONITOR 
c317					endif 
c317			 
c317					; active low 
c317			 
c317					cp 0 
c317					jr z, .bset 
c317					cp 1 
c317					jr nz, .b2 
c317					res 0, c 
c317					ld b, '1'    ; human readable bank number 
c317			.b2:		cp 2 
c317					jr nz, .b3 
c317					res 1, c 
c317					ld b, '2'    ; human readable bank number 
c317			.b3:		cp 3 
c317					jr nz, .b4 
c317					res 2, c 
c317					ld b, '3'    ; human readable bank number 
c317			.b4:		cp 4 
c317					jr nz, .b5 
c317					res 3, c 
c317					ld b, '4'    ; human readable bank number 
c317			.b5:		cp 5 
c317					jr nz, .bset 
c317					res 4, c 
c317					ld b, '5'    ; human readable bank number 
c317			 
c317			.bset: 
c317					ld a, c 
c317					ld (spi_device),a 
c317					ld a, b 
c317					ld (spi_device_id),a 
c317					if DEBUG_FORTH_WORDS 
c317						DMARK "BN2" 
c317						CALLMONITOR 
c317					endif 
c317			 
c317					NEXTW 
c317			 
c317			.CARTDEV: 
c317				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
c317			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
c317					if DEBUG_FORTH_WORDS_KEY 
c317						DMARK "CDV" 
c317						CALLMONITOR 
c317					endif 
c317			 
c317					; disable se storage bank selection 
c317			 
c317					ld a, SPI_CE_HIGH		; ce high 
c317					ld (spi_device), a 
c317			 
c317					; get bank 
c317			 
c317					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c317			 
c317			;		push hl 
c317			 
c317					; destroy value TOS 
c317			 
c317					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c317			 
c317					; one value on hl get other one back 
c317			 
c317			;		pop hl 
c317			 
c317					; active low 
c317			 
c317					ld c, 255 
c317			 
c317					ld a, l 
c317					if DEBUG_FORTH_WORDS 
c317						DMARK "CDV" 
c317						CALLMONITOR 
c317					endif 
c317					cp 0 
c317					jr z, .cset 
c317					cp 1 
c317					jr nz, .c2 
c317					res 0, c 
c317			.c2:		cp 2 
c317					jr nz, .c3 
c317					res 1, c 
c317			.c3:		cp 3 
c317					jr nz, .c4 
c317					res 2, c 
c317			.c4:		cp 4 
c317					jr nz, .c5 
c317					res 3, c 
c317			.c5:		cp 5 
c317					jr nz, .c6 
c317					res 4, c 
c317			.c6:		cp 6 
c317					jr nz, .c7 
c317					res 5, c 
c317			.c7:		cp 7 
c317					jr nz, .c8 
c317					res 6, c 
c317			.c8:		cp 8 
c317					jr nz, .cset 
c317					res 7, c 
c317			.cset:		ld a, c 
c317					ld (spi_cartdev),a 
c317			 
c317					if DEBUG_FORTH_WORDS 
c317						DMARK "CD2" 
c317						CALLMONITOR 
c317					endif 
c317					NEXTW 
c317			endif 
c317			 
c317			.ENDDEVICE: 
c317			; eof 
c317			 
# End of file forth_words_device.asm
c317			 
c317			; var handler 
c317			 
c317			 
c317			.VARS: 
c317				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
c317 78				db WORD_SYS_CORE+100             
c318 2f c3			dw .V0Q            
c31a 04				db 3 + 1 
c31b .. 00			db "V0!",0              
c31f				endm 
# End of macro CWHEAD
c31f			;| V0! ( u1 -- )  Store value to v0  | DONE 
c31f			 
c31f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c31f cd f0 9a			call macro_dsp_valuehl 
c322				endm 
# End of macro FORTH_DSP_VALUEHL
c322			 
c322 11 13 eb				ld de, cli_var_array 
c325			 
c325 eb					ex de, hl 
c326 73					ld (hl), e 
c327 23					inc hl 
c328 72					ld (hl), d 
c329			 
c329					; destroy value TOS 
c329			 
c329					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c329 cd a8 9b			call macro_forth_dsp_pop 
c32c				endm 
# End of macro FORTH_DSP_POP
c32c			 
c32c				       NEXTW 
c32c c3 62 9c			jp macro_next 
c32f				endm 
# End of macro NEXTW
c32f			.V0Q: 
c32f				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
c32f 79				db WORD_SYS_CORE+101             
c330 40 c3			dw .V1S            
c332 04				db 3 + 1 
c333 .. 00			db "V0@",0              
c337				endm 
# End of macro CWHEAD
c337			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
c337 2a 13 eb				ld hl, (cli_var_array) 
c33a cd f9 98				call forth_push_numhl 
c33d			 
c33d				       NEXTW 
c33d c3 62 9c			jp macro_next 
c340				endm 
# End of macro NEXTW
c340			.V1S: 
c340				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
c340 7a				db WORD_SYS_CORE+102             
c341 58 c3			dw .V1Q            
c343 04				db 3 + 1 
c344 .. 00			db "V1!",0              
c348				endm 
# End of macro CWHEAD
c348			;| V1! ( u1 -- )  Store value to v1 | DONE 
c348					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c348 cd f0 9a			call macro_dsp_valuehl 
c34b				endm 
# End of macro FORTH_DSP_VALUEHL
c34b			 
c34b 11 15 eb				ld de, cli_var_array+2 
c34e				 
c34e eb					ex de, hl 
c34f 73					ld (hl), e 
c350 23					inc hl 
c351 72					ld (hl), d 
c352			 
c352					; destroy value TOS 
c352			 
c352					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c352 cd a8 9b			call macro_forth_dsp_pop 
c355				endm 
# End of macro FORTH_DSP_POP
c355				       NEXTW 
c355 c3 62 9c			jp macro_next 
c358				endm 
# End of macro NEXTW
c358			.V1Q: 
c358				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
c358 7b				db WORD_SYS_CORE+103             
c359 69 c3			dw .V2S            
c35b 04				db 3 + 1 
c35c .. 00			db "V1@",0              
c360				endm 
# End of macro CWHEAD
c360			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
c360 2a 15 eb				ld hl, (cli_var_array+2) 
c363 cd f9 98				call forth_push_numhl 
c366				       NEXTW 
c366 c3 62 9c			jp macro_next 
c369				endm 
# End of macro NEXTW
c369			.V2S: 
c369				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
c369 7c				db WORD_SYS_CORE+104             
c36a 81 c3			dw .V2Q            
c36c 04				db 3 + 1 
c36d .. 00			db "V2!",0              
c371				endm 
# End of macro CWHEAD
c371			;| V2! ( u1 -- )  Store value to v2 | DONE 
c371					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c371 cd f0 9a			call macro_dsp_valuehl 
c374				endm 
# End of macro FORTH_DSP_VALUEHL
c374			 
c374 11 17 eb				ld de, cli_var_array+4 
c377				 
c377 eb					ex de, hl 
c378 73					ld (hl), e 
c379 23					inc hl 
c37a 72					ld (hl), d 
c37b			 
c37b					; destroy value TOS 
c37b			 
c37b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c37b cd a8 9b			call macro_forth_dsp_pop 
c37e				endm 
# End of macro FORTH_DSP_POP
c37e				       NEXTW 
c37e c3 62 9c			jp macro_next 
c381				endm 
# End of macro NEXTW
c381			.V2Q: 
c381				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
c381 7d				db WORD_SYS_CORE+105             
c382 92 c3			dw .V3S            
c384 04				db 3 + 1 
c385 .. 00			db "V2@",0              
c389				endm 
# End of macro CWHEAD
c389			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
c389 2a 17 eb				ld hl, (cli_var_array+4) 
c38c cd f9 98				call forth_push_numhl 
c38f				       NEXTW 
c38f c3 62 9c			jp macro_next 
c392				endm 
# End of macro NEXTW
c392			.V3S: 
c392				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
c392 7c				db WORD_SYS_CORE+104             
c393 aa c3			dw .V3Q            
c395 04				db 3 + 1 
c396 .. 00			db "V3!",0              
c39a				endm 
# End of macro CWHEAD
c39a			;| V3! ( u1 -- )  Store value to v3 | DONE 
c39a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
c39a cd f0 9a			call macro_dsp_valuehl 
c39d				endm 
# End of macro FORTH_DSP_VALUEHL
c39d			 
c39d 11 19 eb				ld de, cli_var_array+6 
c3a0				 
c3a0 eb					ex de, hl 
c3a1 73					ld (hl), e 
c3a2 23					inc hl 
c3a3 72					ld (hl), d 
c3a4			 
c3a4					; destroy value TOS 
c3a4			 
c3a4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
c3a4 cd a8 9b			call macro_forth_dsp_pop 
c3a7				endm 
# End of macro FORTH_DSP_POP
c3a7				       NEXTW 
c3a7 c3 62 9c			jp macro_next 
c3aa				endm 
# End of macro NEXTW
c3aa			.V3Q: 
c3aa				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
c3aa 7d				db WORD_SYS_CORE+105             
c3ab bb c3			dw .END            
c3ad 04				db 3 + 1 
c3ae .. 00			db "V3@",0              
c3b2				endm 
# End of macro CWHEAD
c3b2			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
c3b2 2a 19 eb				ld hl, (cli_var_array+6) 
c3b5 cd f9 98				call forth_push_numhl 
c3b8				       NEXTW 
c3b8 c3 62 9c			jp macro_next 
c3bb				endm 
# End of macro NEXTW
c3bb			 
c3bb			 
c3bb			 
c3bb			 
c3bb			 
c3bb			; end of dict marker 
c3bb			 
c3bb 00			.END:    db WORD_SYS_END 
c3bc 00 00			dw 0 
c3be 00				db 0 
c3bf			 
c3bf			; use to jp here for user dict words to save on macro expansion  
c3bf			 
c3bf			user_dict_next: 
c3bf				NEXTW 
c3bf c3 62 9c			jp macro_next 
c3c2				endm 
# End of macro NEXTW
c3c2			 
c3c2			 
c3c2			user_exec: 
c3c2				;    ld hl, <word code> 
c3c2				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
c3c2				;    call forthexec 
c3c2				;    jp user_dict_next   (NEXT) 
c3c2			        ;    <word code bytes> 
c3c2 eb				ex de, hl 
c3c3 2a 61 e6			ld hl,(os_tok_ptr) 
c3c6				 
c3c6				FORTH_RSP_NEXT 
c3c6 cd a0 98			call macro_forth_rsp_next 
c3c9				endm 
# End of macro FORTH_RSP_NEXT
c3c9			 
c3c9			if DEBUG_FORTH_UWORD 
c3c9						DMARK "UEX" 
c3c9 f5				push af  
c3ca 3a de c3			ld a, (.dmark)  
c3cd 32 7a ee			ld (debug_mark),a  
c3d0 3a df c3			ld a, (.dmark+1)  
c3d3 32 7b ee			ld (debug_mark+1),a  
c3d6 3a e0 c3			ld a, (.dmark+2)  
c3d9 32 7c ee			ld (debug_mark+2),a  
c3dc 18 03			jr .pastdmark  
c3de ..			.dmark: db "UEX"  
c3e1 f1			.pastdmark: pop af  
c3e2			endm  
# End of macro DMARK
c3e2				CALLMONITOR 
c3e2 cd 6c 93			call break_point_state  
c3e5				endm  
# End of macro CALLMONITOR
c3e5			endif 
c3e5			 
c3e5			 
c3e5			 
c3e5 eb				ex de, hl 
c3e6 22 61 e6			ld (os_tok_ptr), hl 
c3e9				 
c3e9				; Don't use next - Skips the first word in uword. 
c3e9			 
c3e9 c3 f3 9c			jp exec1 
c3ec			;	NEXT 
c3ec			 
c3ec			 
c3ec			; eof 
# End of file forth_wordsv4.asm
c3ec			endif 
c3ec			;;;;;;;;;;;;;; Debug code 
c3ec			 
c3ec			 
c3ec			;if DEBUG_FORTH_PARSE 
c3ec .. 00		.nowordfound: db "No match",0 
c3f5 .. 00		.compword:	db "Comparing word ",0 
c405 .. 00		.nextwordat:	db "Next word at",0 
c412 .. 00		.charmatch:	db "Char match",0 
c41d			;endif 
c41d			if DEBUG_FORTH_JP 
c41d			.foundword:	db "Word match. Exec..",0 
c41d			endif 
c41d			;if DEBUG_FORTH_PUSH 
c41d .. 00		.enddict:	db "Dict end. Push.",0 
c42d .. 00		.push_str:	db "Pushing string",0 
c43c .. 00		.push_num:	db "Pushing number",0 
c44b .. 00		.data_sp:	db "SP:",0 
c44f .. 00		.wordinhl:	db "Word in HL (2/0):",0 
c461 .. 00		.wordinde:	db "Word in DE (3/0):",0 
c473 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
c485			;endif 
c485			;if DEBUG_FORTH_MALLOC 
c485 .. 00		.push_malloc:	db "Malloc address",0 
c494			;endif 
c494			 
c494			 
c494			 
c494			; display malloc address and current data stack pointer  
c494			 
c494			malloc_error: 
c494 d5				push de 
c495 f5				push af 
c496 e5				push hl 
c497 cd 91 88			call clear_display 
c49a 11 bc c4			ld de, .mallocerr 
c49d 3e 00			ld a,0 
c49f			;	ld de,os_word_scratch 
c49f cd a4 88			call str_at_display 
c4a2 3e 11			ld a, display_row_1+17 
c4a4 11 7a ee			ld de, debug_mark 
c4a7 cd a4 88			call str_at_display 
c4aa cd b4 88			call update_display 
c4ad				;call break_point_state 
c4ad cd ca d7			call cin_wait 
c4b0			 
c4b0 3e 20			ld a, ' ' 
c4b2 32 51 e3			ld (os_view_disable), a 
c4b5 e1				pop hl 
c4b6 f1				pop af 
c4b7 d1				pop de	 
c4b8				CALLMONITOR 
c4b8 cd 6c 93			call break_point_state  
c4bb				endm  
# End of macro CALLMONITOR
c4bb c9				ret 
c4bc			 
c4bc .. 00		.mallocerr: 	db "Malloc Error",0 
c4c9			;if DEBUG_FORTH_PUSH 
c4c9			display_data_sp: 
c4c9 f5				push af 
c4ca			 
c4ca				; see if disabled 
c4ca			 
c4ca 3a 51 e3			ld a, (os_view_disable) 
c4cd fe 2a			cp '*' 
c4cf 28 67			jr z, .skipdsp 
c4d1			 
c4d1 e5				push hl 
c4d2 e5				push hl 
c4d3 e5			push hl 
c4d4 cd 91 88			call clear_display 
c4d7 e1			pop hl 
c4d8 7c				ld a,h 
c4d9 21 65 e6			ld hl, os_word_scratch 
c4dc cd bf 8d			call hexout 
c4df e1				pop hl 
c4e0 7d				ld a,l 
c4e1 21 67 e6			ld hl, os_word_scratch+2 
c4e4 cd bf 8d			call hexout 
c4e7 21 69 e6			ld hl, os_word_scratch+4 
c4ea 3e 00			ld a,0 
c4ec 77				ld (hl),a 
c4ed 11 65 e6			ld de,os_word_scratch 
c4f0 3e 28				ld a, display_row_2 
c4f2 cd a4 88				call str_at_display 
c4f5 11 4f c4			ld de, .wordinhl 
c4f8 3e 00			ld a, display_row_1 
c4fa			 
c4fa cd a4 88				call str_at_display 
c4fd 11 7a ee			ld de, debug_mark 
c500 3e 11			ld a, display_row_1+17 
c502			 
c502 cd a4 88				call str_at_display 
c505			 
c505				; display current data stack pointer 
c505 11 4b c4			ld de,.data_sp 
c508 3e 30				ld a, display_row_2 + 8 
c50a cd a4 88				call str_at_display 
c50d			 
c50d 2a 0d eb			ld hl,(cli_data_sp) 
c510 e5				push hl 
c511 7c				ld a,h 
c512 21 65 e6			ld hl, os_word_scratch 
c515 cd bf 8d			call hexout 
c518 e1				pop hl 
c519 7d				ld a,l 
c51a 21 67 e6			ld hl, os_word_scratch+2 
c51d cd bf 8d			call hexout 
c520 21 69 e6			ld hl, os_word_scratch+4 
c523 3e 00			ld a,0 
c525 77				ld (hl),a 
c526 11 65 e6			ld de,os_word_scratch 
c529 3e 33				ld a, display_row_2 + 11 
c52b cd a4 88				call str_at_display 
c52e			 
c52e			 
c52e cd b4 88			call update_display 
c531 cd 0e 88			call delay1s 
c534 cd 0e 88			call delay1s 
c537 e1				pop hl 
c538			.skipdsp: 
c538 f1				pop af 
c539 c9				ret 
c53a			 
c53a			display_data_malloc: 
c53a			 
c53a f5				push af 
c53b e5				push hl 
c53c e5				push hl 
c53d e5			push hl 
c53e cd 91 88			call clear_display 
c541 e1			pop hl 
c542 7c				ld a,h 
c543 21 65 e6			ld hl, os_word_scratch 
c546 cd bf 8d			call hexout 
c549 e1				pop hl 
c54a 7d				ld a,l 
c54b 21 67 e6			ld hl, os_word_scratch+2 
c54e cd bf 8d			call hexout 
c551 21 69 e6			ld hl, os_word_scratch+4 
c554 3e 00			ld a,0 
c556 77				ld (hl),a 
c557 11 65 e6			ld de,os_word_scratch 
c55a 3e 28				ld a, display_row_2 
c55c cd a4 88				call str_at_display 
c55f 11 85 c4			ld de, .push_malloc 
c562 3e 00			ld a, display_row_1 
c564			 
c564 cd a4 88				call str_at_display 
c567			 
c567				; display current data stack pointer 
c567 11 4b c4			ld de,.data_sp 
c56a 3e 30				ld a, display_row_2 + 8 
c56c cd a4 88				call str_at_display 
c56f			 
c56f 2a 0d eb			ld hl,(cli_data_sp) 
c572 e5				push hl 
c573 7c				ld a,h 
c574 21 65 e6			ld hl, os_word_scratch 
c577 cd bf 8d			call hexout 
c57a e1				pop hl 
c57b 7d				ld a,l 
c57c 21 67 e6			ld hl, os_word_scratch+2 
c57f cd bf 8d			call hexout 
c582 21 69 e6			ld hl, os_word_scratch+4 
c585 3e 00			ld a,0 
c587 77				ld (hl),a 
c588 11 65 e6			ld de,os_word_scratch 
c58b 3e 33				ld a, display_row_2 + 11 
c58d cd a4 88				call str_at_display 
c590			 
c590 cd b4 88			call update_display 
c593 cd 0e 88			call delay1s 
c596 cd 0e 88			call delay1s 
c599 e1				pop hl 
c59a f1				pop af 
c59b c9				ret 
c59c			;endif 
c59c			 
c59c			include "forth_autostart.asm" 
c59c			; list of commands to perform at system start up 
c59c			 
c59c			startcmds: 
c59c			;	dw test11 
c59c			;	dw test12 
c59c			;	dw test13 
c59c			;	dw test14 
c59c			;	dw test15 
c59c			;	dw test16 
c59c			;	dw test17 
c59c			;	dw ifthtest1 
c59c			;	dw ifthtest2 
c59c			;	dw ifthtest3 
c59c			;	dw mmtest1 
c59c			;	dw mmtest2 
c59c			;	dw mmtest3 
c59c			;	dw mmtest4 
c59c			;	dw mmtest5 
c59c			;	dw mmtest6 
c59c			;	dw iftest1 
c59c			;	dw iftest2 
c59c			;	dw iftest3 
c59c			;	dw looptest1 
c59c			;	dw looptest2 
c59c			;	dw test1 
c59c			;	dw test2 
c59c			;	dw test3 
c59c			;	dw test4 
c59c			;	dw game2r 
c59c			;	dw game2b1 
c59c			;	dw game2b2 
c59c			 
c59c				; start up words that are actually useful 
c59c			 
c59c fa c5			dw clrstack 
c59e 2d c6			dw type 
c5a0 ee c7			dw stest 
c5a2 51 c6			dw strncpy 
c5a4 8f c7			dw list 
c5a6 b2 c6			dw start1 
c5a8 c4 c6			dw start2 
c5aa			;	dw start3 
c5aa d7 c6			dw start3b 
c5ac 2f c7			dw start3c 
c5ae			 
c5ae				; (unit) testing words 
c5ae			 
c5ae 65 c8			dw mtesta 
c5b0 1a c9			dw mtestb 
c5b2 bd c9			dw mtestc 
c5b4 72 ca			dw mtestd 
c5b6 16 cb			dw mteste 
c5b8			 
c5b8				; demo/game words 
c5b8			 
c5b8 22 d2		        dw game3w 
c5ba 50 d2		        dw game3p 
c5bc 6e d2		        dw game3sc 
c5be 9f d2		        dw game3vsi 
c5c0 cb d2		        dw game3vs 
c5c2				 
c5c2 15 d0			dw game2b 
c5c4 83 d0			dw game2bf 
c5c6 cd d0			dw game2mba 
c5c8 63 d1			dw game2mbas 
c5ca a5 d1			dw game2mb 
c5cc			 
c5cc d6 cc			dw game1 
c5ce e7 cc			dw game1a 
c5d0 49 cd			dw game1b 
c5d2 7e cd			dw game1c 
c5d4 b4 cd			dw game1d 
c5d6 e5 cd			dw game1s 
c5d8 f9 cd			dw game1t 
c5da 0e ce			dw game1f 
c5dc 42 ce			dw game1z 
c5de 86 ce			dw game1zz 
c5e0			 
c5e0 cc cb			dw test5 
c5e2 04 cc			dw test6 
c5e4 3c cc			dw test7 
c5e6 50 cc			dw test8 
c5e8 7c cc			dw test9 
c5ea 92 cc			dw test10 
c5ec				 
c5ec 5d cf		        dw ssv5 
c5ee 41 cf		        dw ssv4 
c5f0 25 cf		        dw ssv3 
c5f2 ef ce		        dw ssv2 
c5f4 76 cf		        dw ssv1 
c5f6 be cf		        dw ssv1cpm 
c5f8			;	dw keyup 
c5f8			;	dw keydown 
c5f8			;	dw keyleft 
c5f8			;	dw keyright 
c5f8			;	dw 	keyf1 
c5f8			;	dw keyf2 
c5f8			;	dw keyf3 
c5f8			;	dw keyf4 
c5f8			;	dw keyf5 
c5f8			;	dw keyf6 
c5f8			;	dw keyf7 
c5f8			;	dw keyf8 
c5f8			;	dw keyf9 
c5f8			;	dw keyf10 
c5f8			;	dw keyf11 
c5f8			;	dw keyf12 
c5f8			;	dw keytab 
c5f8			;	dw keycr 
c5f8			;	dw keyhome 
c5f8			;	dw keyend 
c5f8			;	dw keybs 
c5f8 00 00			db 0, 0	 
c5fa			 
c5fa			 
c5fa			; clear stack  
c5fa			 
c5fa .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
c62d			 
c62d			; type ( addr count - ) 
c62d .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
c651			 
c651			; some direct memory words 
c651			; strncpy ( len t f -- t ) 
c651			 
c651 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
c6b2			 
c6b2 .. 00		start1:     	db ": bpon $0000 bp ;",0 
c6c4 .. 00		start2:     	db ": bpoff $0001 bp ;",0 
c6d7			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
c6d7 .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
c72f .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
c78f			 
c78f			 
c78f			; a handy word to list items on the stack 
c78f			 
c78f .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
c7ee			 
c7ee			 
c7ee			; test stack  
c7ee			; rnd8 stest 
c7ee			 
c7ee .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
c865			 
c865			; random malloc and free cycles 
c865			 
c865 .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c91a			 
c91a			; fixed malloc and free cycles 
c91a			 
c91a .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
c9bd			 
c9bd			; fixed double string push and drop cycle  
c9bd			 
c9bd .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
ca72			 
ca72			; consistent fixed string push and drop cycle  
ca72			 
ca72 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cb16			 
cb16 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
cbcc			 
cbcc			;test1:		db ": aa 1 2 3 ;", 0 
cbcc			;test2:     	db "111 aa 888 999",0 
cbcc			;test3:     	db ": bb 77 ;",0 
cbcc			;test4:     	db "$02 $01 do i . loop bb",0 
cbcc			 
cbcc .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
cc04 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
cc3c .. 00		test7:     	db ": box hline vline ;",0 
cc50 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
cc7c .. 00		test9:     	db ": sw $01 adsp world ;",0 
cc92 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
ccb7 .. 00		test11:     	db "hello create .",0 
ccc6 .. 00		test12:     	db "hello2 create .",0 
ccd6			 
ccd6			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
ccd6			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
ccd6			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
ccd6			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
ccd6			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
ccd6			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
ccd6			 
ccd6			;iftest1:     	db "$0001 IF cls .",0 
ccd6			;iftest2:     	db "$0000 IF cls .",0 
ccd6			;iftest3:     	db "$0002 $0003 - IF cls .",0 
ccd6			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
ccd6			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
ccd6			 
ccd6			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
ccd6			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
ccd6			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
ccd6			 
ccd6			 
ccd6			 
ccd6			; a small guess the number game 
ccd6			 
ccd6 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
cce7 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
cd49			 
cd49 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
cd7e .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
cdb4 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
cde5 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
cdf9 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
ce0e .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
ce42 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
ce86			 
ce86			; Using 'ga' save a high score across multiple runs using external storage 
ce86			 
ce86 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
ceef			 
ceef			 
ceef			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
ceef			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
ceef			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
ceef			 
ceef			; simple screen saver to test code memory reuse to destruction 
ceef			 
ceef .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
cf25 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
cf41 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
cf5d .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
cf76 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
cfbe .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
d015			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
d015			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
d015			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
d015			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
d015			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
d015			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
d015			 
d015			 
d015			 
d015			; minesweeper/battleship finding game 
d015			; draws a game board of random ship/mine positions 
d015			; user enters coords to see if it hits on 
d015			; game ends when all are hit 
d015			; when hit or miss says how many may be in the area 
d015			 
d015			; setup the game board and then hide it 
d015 .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
d083 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
d0cd			; prompt for where to target 
d0cd .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
d163 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
d188			; TODO see if the entered coords hits or misses pushes char hit of miss 
d188 .. 00		game2mbht:      db ": mbckht nop ;",0 
d197 .. 00		game2mbms:      db ": mbcms nop ;",0 
d1a5			; TODO how many might be near by 
d1a5 .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
d222			 
d222			; Game 3 
d222			 
d222			; Vert scroller ski game - avoid the trees! 
d222			 
d222			; v0 score (ie turns) 
d222			; v1 player pos 
d222			; v2 left wall 
d222			; v3 right wall 
d222			 
d222			; Draw side walls randomly 
d222			 
d222 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
d250			 
d250			; Draw player 
d250 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
d26e			 
d26e			; TODO Get Key 
d26e			 
d26e			; TODO Move left right 
d26e			 
d26e			; scroll and move walls a bit 
d26e			 
d26e .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
d29f			 
d29f			; main game loop 
d29f			 
d29f .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
d2cb .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
d30a			 
d30a			; key board defs 
d30a			 
d30a .. 00		keyup:       db ": keyup $05 ;",0 
d318 .. 00		keydown:       db ": keydown $0a ;",0 
d328 .. 00		keyleft:       db ": keyleft $0b ;",0 
d338 .. 00		keyright:       db ": keyright $0c ;",0 
d349 .. 00		keyf1:       db ": keyf1 $10 ;",0 
d357 .. 00		keyf2:       db ": keyf2 $11 ;",0 
d365 .. 00		keyf3:       db ": keyf3 $12 ;",0 
d373 .. 00		keyf4:       db ": keyf4 $13 ;",0 
d381 .. 00		keyf5:       db ": keyf5 $14 ;",0 
d38f .. 00		keyf6:       db ": keyf6 $15 ;",0 
d39d .. 00		keyf7:       db ": keyf7 $16 ;",0 
d3ab .. 00		keyf8:       db ": keyf8 $17 ;",0 
d3b9 .. 00		keyf9:       db ": keyf9 $18 ;",0 
d3c7 .. 00		keyf10:       db ": keyf10 $19 ;",0 
d3d6 .. 00		keyf11:       db ": keyf11 $1a ;",0 
d3e5 .. 00		keyf12:       db ": keyf12 $1b ;",0 
d3f4			 
d3f4 .. 00		keytab:       db ": keytab $09 ;",0 
d403 .. 00		keycr:       db ": keycr $0d ;",0 
d411 .. 00		keyhome:       db ": keyhome $0e ;",0 
d421 .. 00		keyend:       db ": keyend $0f ;",0 
d430 .. 00		keybs:       db ": keybs $08 ;",0 
d43e			 
d43e			   
d43e			 
d43e			 
d43e			 
d43e			; eof 
# End of file forth_autostart.asm
d43e			 
d43e .. 00		sprompt1: db "Startup load...",0 
d44e .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
d464			 
d464			 
d464			 
d464			 
d464			forth_startup: 
d464 21 9c c5			ld hl, startcmds 
d467 3e 00			ld a, 0 
d469 32 86 e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
d46c			 
d46c e5			.start1:	push hl 
d46d cd 91 88			call clear_display 
d470 11 3e d4			ld de, sprompt1 
d473 3e 00		        ld a, display_row_1 
d475 cd a4 88			call str_at_display 
d478 11 4e d4			ld de, sprompt2 
d47b 3e 28		        ld a, display_row_2 
d47d cd a4 88			call str_at_display 
d480 e1				pop hl 
d481 e5				push hl 
d482 5e				ld e,(hl) 
d483 23				inc hl 
d484 56				ld d,(hl) 
d485 3e 50		        ld a, display_row_3 
d487 cd a4 88			call str_at_display 
d48a cd b4 88			call update_display 
d48d			 
d48d			 
d48d 3a 86 e7			ld a, (os_last_cmd) 
d490 fe 00			cp 0 
d492 28 05			jr z, .startprompt 
d494 cd 02 88			call delay250ms 
d497 18 24			jr .startdo 
d499				 
d499				 
d499			 
d499			.startprompt: 
d499			 
d499 3e 9f			ld a,display_row_4 + display_cols - 1 
d49b 11 6f 98		        ld de, endprg 
d49e cd a4 88			call str_at_display 
d4a1 cd b4 88			call update_display 
d4a4 cd 0e 88			call delay1s 
d4a7 cd ca d7			call cin_wait 
d4aa						 
d4aa fe 2a			cp '*' 
d4ac 28 5e			jr z, .startupend1 
d4ae fe 23			cp '#' 
d4b0 20 07			jr nz, .startno 
d4b2 3e 01			ld a, 1 
d4b4 32 86 e7			ld (os_last_cmd),a 
d4b7 18 04			jr .startdo 
d4b9 fe 31		.startno:	cp '1' 
d4bb 28 3a			jr z,.startnxt  
d4bd			 
d4bd				; exec startup line 
d4bd			.startdo:	 
d4bd e1				pop hl 
d4be e5				push hl 
d4bf				 
d4bf 5e				ld e,(hl) 
d4c0 23				inc hl 
d4c1 56				ld d,(hl) 
d4c2 eb				ex de,hl 
d4c3			 
d4c3 e5				push hl 
d4c4			 
d4c4 3e 00			ld a, 0 
d4c6				;ld a, FORTH_END_BUFFER 
d4c6 cd 27 8f			call strlent 
d4c9 23				inc hl   ; include zero term to copy 
d4ca 06 00			ld b,0 
d4cc 4d				ld c,l 
d4cd e1				pop hl 
d4ce 11 60 e3			ld de, scratch 
d4d1 ed b0			ldir 
d4d3			 
d4d3			 
d4d3 21 60 e3			ld hl, scratch 
d4d6 cd b0 9c			call forthparse 
d4d9 cd f0 9c			call forthexec 
d4dc cd 07 9c			call forthexec_cleanup 
d4df			 
d4df 3e 78			ld a, display_row_4 
d4e1 11 13 96			ld de, endprog 
d4e4			 
d4e4 cd b4 88			call update_display		 
d4e7			 
d4e7 3a 86 e7			ld a, (os_last_cmd) 
d4ea fe 00			cp 0 
d4ec 20 09			jr nz, .startnxt 
d4ee cd 71 98			call next_page_prompt 
d4f1 cd 91 88		        call clear_display 
d4f4 cd b4 88			call update_display		 
d4f7			 
d4f7				; move onto next startup line? 
d4f7			.startnxt: 
d4f7			 
d4f7 cd 02 88			call delay250ms 
d4fa e1				pop hl 
d4fb			 
d4fb 23				inc hl 
d4fc 23				inc hl 
d4fd			 
d4fd e5				push hl 
d4fe 5e				ld e, (hl) 
d4ff 23				inc hl 
d500 56				ld d, (hl) 
d501 e1				pop hl 
d502				; TODO replace 0 test 
d502			 
d502 eb				ex de, hl 
d503 cd e7 8a			call ishlzero 
d506			;	ld a,e 
d506			;	add d 
d506			;	cp 0    ; any left to do? 
d506 eb				ex de, hl 
d507 c2 6c d4			jp nz, .start1 
d50a 18 01			jr .startupend 
d50c			 
d50c e1			.startupend1: pop hl 
d50d			.startupend: 
d50d			 
d50d cd 91 88			call clear_display 
d510 cd b4 88			call update_display 
d513 c9				ret 
d514			 
d514			 
d514			; stack over and underflow checks 
d514			 
d514			; init the words to detect the under/overflow 
d514			 
d514			chk_stk_init: 
d514				; a vague random number to check so we dont get any "lucky" hits 
d514 3e 2d			ld a, 45 
d516 6f				ld l, a 
d517 00				nop 
d518 3e 17			ld a, 23 
d51a 67				ld h, a 
d51b			 
d51b 22 47 e3			ld (chk_word), hl     ; the word we need to check against 
d51e			 
d51e			;	ld (chk_stund), hl	; stack points.... 
d51e 22 00 ef			ld (chk_stovr), hl 
d521 22 0b eb			ld (chk_ret_und), hl 
d524 22 c9 ea			ld (chk_ret_ovr), hl 
d527 22 c7 e9			ld (chk_loop_ovr), hl 
d52a 22 c5 e8			ld (chk_data_ovr), hl 
d52d c9				ret 
d52e				 
d52e			check_stacks: 
d52e				; check all stack words 
d52e			 
d52e e5				push hl 
d52f d5				push de 
d530			 
d530			;	ld de,(chk_word) 
d530			;	ld hl, (chk_stund)	; stack points.... 
d530			;	if DEBUG_STK_FAULT 
d530			;		DMARK "FAa" 
d530			;		CALLMONITOR 
d530			;	endif 
d530			;	call cmp16 
d530			;	jp z, .chk_faulta 
d530			; 
d530			;	ld de, sfaultsu 
d530			;	jp .chk_fault 
d530			 
d530 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
d533 ed 5b 47 e3		ld de,(chk_word) 
d537				if DEBUG_STK_FAULT 
d537					DMARK "FAb" 
d537					CALLMONITOR 
d537				endif 
d537 cd dc 8a			call cmp16 
d53a 28 06			jr z, .chk_fault1 
d53c 11 dd d5			ld de, sfaultso 
d53f c3 91 d5			jp .chk_fault 
d542			.chk_fault1:  
d542 2a 0b eb			ld hl, (chk_ret_und) 
d545 ed 5b 47 e3		ld de,(chk_word) 
d549				if DEBUG_STK_FAULT 
d549					DMARK "FAU" 
d549					CALLMONITOR 
d549				endif 
d549 cd dc 8a			call cmp16 
d54c ca 55 d5			jp z, .chk_fault2 
d54f 11 ed d5			ld de, sfaultru 
d552 c3 91 d5			jp .chk_fault 
d555			.chk_fault2:  
d555 2a c9 ea			ld hl, (chk_ret_ovr) 
d558 ed 5b 47 e3		ld de,(chk_word) 
d55c				if DEBUG_STK_FAULT 
d55c					DMARK "FA1" 
d55c					CALLMONITOR 
d55c				endif 
d55c cd dc 8a			call cmp16 
d55f ca 68 d5			jp z, .chk_fault3 
d562 11 fb d5			ld de, sfaultro 
d565 c3 91 d5			jp .chk_fault 
d568			.chk_fault3:  
d568 2a c7 e9			ld hl, (chk_loop_ovr) 
d56b ed 5b 47 e3		ld de,(chk_word) 
d56f				if DEBUG_STK_FAULT 
d56f					DMARK "FA2" 
d56f					CALLMONITOR 
d56f				endif 
d56f cd dc 8a			call cmp16 
d572 ca 7b d5			jp z, .chk_fault4 
d575 11 15 d6			ld de, sfaultlo 
d578 c3 91 d5			jp .chk_fault 
d57b			.chk_fault4:  
d57b 2a c5 e8			ld hl, (chk_data_ovr) 
d57e ed 5b 47 e3		ld de,(chk_word) 
d582				if DEBUG_STK_FAULT 
d582					DMARK "FA3" 
d582					CALLMONITOR 
d582				endif 
d582 cd dc 8a			call cmp16 
d585 ca 8e d5			jp z, .chk_fault5 
d588 11 2f d6			ld de, sfaultdo 
d58b c3 91 d5			jp .chk_fault 
d58e			 
d58e			 
d58e			.chk_fault5:  
d58e d1				pop de 
d58f e1				pop hl 
d590			 
d590 c9				ret 
d591			 
d591 cd 91 88		.chk_fault: 	call clear_display 
d594 3e 28				ld a, display_row_2 
d596 cd a4 88				call str_at_display 
d599 11 bf d5				   ld de, .stackfault 
d59c 3e 00				ld a, display_row_1 
d59e cd a4 88				call str_at_display 
d5a1 11 7a ee				    ld de, debug_mark 
d5a4 3e 11				ld a, display_row_1+17 
d5a6 cd a4 88				call str_at_display 
d5a9 cd b4 88				call update_display 
d5ac			 
d5ac				; prompt before entering montior for investigating issue 
d5ac			 
d5ac 3e 78			ld a, display_row_4 
d5ae 11 13 96			ld de, endprog 
d5b1			 
d5b1 cd b4 88			call update_display		 
d5b4			 
d5b4 cd 71 98			call next_page_prompt 
d5b7			 
d5b7 d1				pop de 
d5b8 e1				pop hl 
d5b9 cd 67 96				call monitor 
d5bc c3 61 95				jp warmstart 
d5bf					;jp 0 
d5bf					;halt 
d5bf			 
d5bf			 
d5bf			 
d5bf .. 00		.stackfault: 	db "Stack fault:",0 
d5cc			 
d5cc .. 00		sfaultsu: 	db	"Stack under flow",0 
d5dd .. 00		sfaultso: 	db	"Stack over flow",0 
d5ed .. 00		sfaultru:	db "RTS underflow",0 
d5fb .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
d615 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
d62f .. 00		sfaultdo:	db "DTS overflow", 0 
d63c			 
d63c			 
d63c			fault_dsp_under: 
d63c 11 4e d6			ld de, .dsp_under 
d63f c3 fe d6			jp .show_fault 
d642			 
d642			fault_rsp_under: 
d642 11 5c d6			ld de, .rsp_under 
d645 c3 fe d6			jp .show_fault 
d648			fault_loop_under: 
d648 11 6a d6			ld de, .loop_under 
d64b c3 fe d6			jp .show_fault 
d64e			 
d64e .. 00		.dsp_under: db "DSP Underflow",0 
d65c .. 00		.rsp_under: db "RSP Underflow",0 
d66a .. 00		.loop_under: db "LOOP Underflow",0 
d679			 
d679			 
d679 d5			type_faultn: 	push de 
d67a e5					push hl 
d67b cd 91 88				call clear_display 
d67e 11 a5 d6				   ld de, .typefaultn 
d681 3e 00				ld a, display_row_1 
d683 cd a4 88				call str_at_display 
d686 11 7a ee				    ld de, debug_mark 
d689 3e 11				ld a, display_row_1+17 
d68b cd a4 88				call str_at_display 
d68e cd b4 88				call update_display 
d691			 
d691				; prompt before entering montior for investigating issue 
d691			 
d691 3e 78			ld a, display_row_4 
d693 11 13 96			ld de, endprog 
d696			 
d696 cd b4 88			call update_display		 
d699			 
d699 cd 71 98			call next_page_prompt 
d69c			 
d69c e5					push hl 
d69d d5					push de 
d69e cd 67 96				call monitor 
d6a1 c3 61 95				jp warmstart 
d6a4 76					halt 
d6a5			 
d6a5			 
d6a5 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
d6bc			 
d6bc d5			type_faults: 	push de 
d6bd e5					push hl 
d6be cd 91 88				call clear_display 
d6c1 11 e7 d6				   ld de, .typefaults 
d6c4 3e 00				ld a, display_row_1 
d6c6 cd a4 88				call str_at_display 
d6c9 11 7a ee				    ld de, debug_mark 
d6cc 3e 11				ld a, display_row_1+17 
d6ce cd a4 88				call str_at_display 
d6d1 cd b4 88				call update_display 
d6d4			 
d6d4				; prompt before entering montior for investigating issue 
d6d4			 
d6d4 3e 78			ld a, display_row_4 
d6d6 11 13 96			ld de, endprog 
d6d9			 
d6d9 cd b4 88			call update_display		 
d6dc			 
d6dc cd 71 98			call next_page_prompt 
d6df			 
d6df e1					pop hl 
d6e0 d1					pop de 
d6e1 cd 67 96				call monitor 
d6e4 c3 61 95				jp warmstart 
d6e7			 
d6e7			 
d6e7 .. 00		.typefaults: db "STR Type Expected TOS!",0 
d6fe			 
d6fe			.show_fault: 	 
d6fe d5					push de 
d6ff cd 91 88				call clear_display 
d702 d1					pop de 
d703 3e 00				ld a, display_row_1 
d705 cd a4 88				call str_at_display 
d708 11 7a ee				    ld de, debug_mark 
d70b 3e 11				ld a, display_row_1+17 
d70d cd a4 88				call str_at_display 
d710 cd b4 88				call update_display 
d713			 
d713				; prompt before entering montior for investigating issue 
d713			 
d713 3e 78			ld a, display_row_4 
d715 11 13 96			ld de, endprog 
d718			 
d718 cd b4 88			call update_display		 
d71b			 
d71b cd 71 98			call next_page_prompt 
d71e			 
d71e e1					pop hl 
d71f d1					pop de 
d720 cd 67 96				call monitor 
d723			; do a dump to cli and not warmstart so we preserve all of the uwords.  
d723			; TODO Make optional fault restart to cli or warm boot? 
d723					;jp warmstart 
d723 c3 b9 95				jp cli 
d726 76					halt 
d727			 
d727			; handle the auto run of code from files in storage 
d727			 
d727			 
d727			if STORAGE_SE 
d727			 
d727			sprompt3: db "Loading from start-up file?:",0 
d727			sprompt4: db "(Y=Any key/N=No)",0 
d727			 
d727			 
d727			forth_autoload: 
d727			 
d727				; load block 0 of store 1 
d727				 
d727				ld a, $fe      ; bit 0 clear 
d727				ld (spi_device), a 
d727			 
d727				call storage_get_block_0 
d727			 
d727				ld a, (store_page+STORE_0_AUTOFILE) 
d727			 
d727				cp 0 
d727				ret z     ; auto start not enabled 
d727			 
d727				call clear_display 
d727			 
d727				; set bank 
d727			 
d727					ld a, (store_page+STORE_0_BANKRUN) 
d727					ld (spi_device), a 
d727			 
d727				; get file id to load from and get the file name to display 
d727			 
d727					ld a, (store_page+STORE_0_FILERUN) 
d727			 
d727					ld l, 0 
d727					ld h, a 
d727					ld de, store_page 
d727			 
d727					if DEBUG_FORTH_WORDS 
d727						DMARK "ASp" 
d727						CALLMONITOR 
d727					endif 
d727					call storage_read 
d727			 
d727					if DEBUG_FORTH_WORDS 
d727						DMARK "ASr" 
d727						CALLMONITOR 
d727					endif 
d727			 
d727					call ishlzero 
d727					ret z             ; file not found 
d727			 
d727					ld a, display_row_2 + 10 
d727					ld de, store_page+3 
d727					call str_at_display 
d727				 
d727			; 
d727			 
d727				ld a, display_row_1+5 
d727				ld de, sprompt3 
d727				call str_at_display 
d727				ld a, display_row_3+15 
d727				ld de, sprompt4 
d727				call str_at_display 
d727			 
d727				call update_display 
d727			 
d727				call cin_wait 
d727				cp 'n' 
d727				ret z 
d727				cp 'N' 
d727				ret z 
d727			 
d727				call delay1s 
d727			 
d727				ld a, (store_page+2) 
d727				ld (store_openmaxext), a    ; save count of ext 
d727				ld a, 1  
d727				ld (store_openext), a    ; save count of ext 
d727			 
d727			.autof:  
d727				ld l , a 
d727				 
d727				ld a, (store_page) 
d727				ld h, a	 
d727				ld de, store_page 
d727					if DEBUG_FORTH_WORDS 
d727						DMARK "ASl" 
d727						CALLMONITOR 
d727					endif 
d727					call storage_read 
d727				call ishlzero 
d727				ret z 
d727			;	jr z, .autoend 
d727			 
d727					if DEBUG_FORTH_WORDS 
d727						DMARK "ASc" 
d727						CALLMONITOR 
d727					endif 
d727				ld de, store_page+2 
d727				ld a, display_row_4 
d727				call str_at_display 
d727			 
d727				call update_display 
d727				call delay250ms 
d727			 
d727			 
d727			 
d727				ld hl, store_page+2 
d727				call forthparse 
d727				call forthexec 
d727				call forthexec_cleanup 
d727			 
d727				 
d727				ld a, (store_openext) 
d727				inc a 
d727				ld (store_openext), a    ; save count of ext 
d727			 
d727				jr .autof 
d727			;.autofdone: 
d727			; 
d727			;		if DEBUG_FORTH_WORDS 
d727			;			DMARK "ASx" 
d727			;			CALLMONITOR 
d727			;		endif 
d727			;;	call clear_display 
d727			;	ret 
d727			 
d727			 
d727			 
d727			endif 
d727			 
d727			 
d727			; eof 
# End of file forth_kernel.asm
d727			;include "nascombasic.asm" 
d727			 
d727			 
d727			; find out where the code ends if loaded into RAM (for SC114) 
d727			;endofcode:  
d727			;	nop 
d727			 
d727			 
d727			; eof 
d727			 
# End of file main.asm
d727			;include "firmware_lcd_4x40.asm" 
d727			;;include "firmware_lcd_4x20.asm" 
d727			include "firmware_serial_display.asm" 
d727			 
d727			; Serial display interface for SC114 
d727			 
d727			 
d727			display_row_1: equ 0 
d727			display_row_2: equ display_row_1+display_cols 
d727			display_row_3: equ display_row_2 + display_cols 
d727			display_row_4: equ display_row_3 + display_cols 
d727			 
d727			kLCDWidth:  EQU display_cols             ;Width in characters 
d727			kLCD_Line1: EQU 0x00  
d727			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
d727			; E1 
d727			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
d727			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
d727			 
d727			lcd_init: 
d727				; no init as handled by the SCM bios 
d727 c9				ret 
d728			 
d728			 
d728			; low level functions for direct screen writes 
d728			 
d728			; output char at pos? 
d728			fLCD_Str: 
d728			        ;out (SC114_SIO_1_OUT),a 
d728 c5				push bc 
d729 0e 02			ld c, $02 
d72b f7				rst $30 
d72c c1				pop bc 
d72d c9				ret 
d72e			 
d72e			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
d72e			fLCD_Pos: 
d72e				; use ASCII escape to position 
d72e			        ;out (SC114_SIO_1_OUT),a 
d72e c5				push bc 
d72f 0e 02			ld c, $02 
d731 f7				rst $30 
d732 c1				pop bc 
d733			 
d733 c9				ret 
d734			 
d734			; output char at pos 
d734			fLCD_Data: 
d734			      ;  out (SC114_SIO_1_OUT),a 
d734 c5				push bc 
d735 0e 02			ld c, $02 
d737 f7				rst $30 
d738 c1				pop bc 
d739			 
d739 c9				ret 
d73a			 
d73a			; ascii cls  
d73a			 
d73a 1b 5b 48 00	.cls:   db 27, '[', 'H', 0 
d73e			 
d73e			; write the frame buffer given in hl to hardware  
d73e			write_display: 
d73e			 
d73e			API: equ 0 
d73e			 
d73e			if API 
d73e				push bc 
d73e				ld b, 4 
d73e			 
d73e			        ld (display_write_tmp), hl 	  
d73e			 
d73e				; clear and home cursor 
d73e			 
d73e				ld c, 6 
d73e				ld de, .cls 
d73e				rst $30 
d73e			 
d73e			 
d73e			.writeln: 
d73e			 
d73e				ld de, (display_write_tmp) 
d73e				ld c, 6 
d73e				rst $30 
d73e				ld c, 7 
d73e				rst $30 
d73e			 
d73e				ld hl, (display_write_tmp) 
d73e				ld de, display_cols 
d73e				add hl,de 
d73e				ld (display_write_tmp),hl 
d73e			 
d73e				djnz  .writeln 
d73e			 
d73e				pop bc 
d73e			 
d73e			 
d73e				ret 
d73e			endif 
d73e e5				push hl 
d73f c5				push bc 
d740 d5				push de 
d741			 
d741			;	ld c, 2 
d741			;	;ld de, .cls 
d741			;	ld a, 27 
d741			;	rst $30 
d741			;	ld c, 2 
d741			;	;ld de, .cls 
d741			;	ld a, '[' 
d741			;	rst $30 
d741			; 
d741			;	ld c, 2 
d741			;	;ld de, .cls 
d741			;	ld a, 'H' 
d741			;	rst $30 
d741			; 
d741			 
d741 0e 02			ld c, 2 
d743				;ld de, .cls 
d743 3e 1b			ld a, 27 
d745 f7				rst $30 
d746			 
d746			 
d746 0e 02			ld c, 2 
d748				;ld de, .cls 
d748 3e 5b			ld a, '[' 
d74a f7				rst $30 
d74b 0e 02			ld c, 2 
d74d				;ld de, .cls 
d74d 3e 32			ld a, '2' 
d74f f7				rst $30 
d750 0e 02			ld c, 2 
d752				;ld de, .cls 
d752 3e 4a			ld a, 'J' 
d754 f7				rst $30 
d755 d1				pop de 
d756 c1				pop bc 
d757 e1				pop hl 
d758			 
d758			 
d758 22 d8 eb		        ld (display_write_tmp), hl 	  
d75b 3e 00			ld a, kLCD_Line1 
d75d			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d75d 06 28			ld b, display_cols 
d75f ed 5b d8 eb		ld de, (display_write_tmp) 
d763 cd c1 d7			call write_len_string 
d766				 
d766			 
d766 e5			push hl 
d767 d5			push de 
d768 c5			push bc 
d769 0e 07			ld c, 7 
d76b f7				rst $30 
d76c c1			pop bc 
d76d d1			pop de 
d76e e1			pop hl 
d76f			 
d76f				 
d76f 2a d8 eb			ld hl, (display_write_tmp) 
d772 11 28 00			ld de, display_cols 
d775 19				add hl,de 
d776 22 d8 eb			ld (display_write_tmp),hl 
d779			 
d779				 
d779 3e 28			ld a, kLCD_Line2 
d77b			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
d77b 06 28			ld b, display_cols 
d77d ed 5b d8 eb		ld de, (display_write_tmp) 
d781 cd c1 d7			call write_len_string 
d784				 
d784 2a d8 eb			ld hl, (display_write_tmp) 
d787 11 28 00			ld de, display_cols 
d78a 19				add hl,de 
d78b 22 d8 eb			ld (display_write_tmp),hl 
d78e			 
d78e e5			push hl 
d78f d5			push de 
d790 c5			push bc 
d791 0e 07			ld c, 7 
d793 f7				rst $30 
d794 c1			pop bc 
d795 d1			pop de 
d796 e1			pop hl 
d797			 
d797				 
d797 3e 50			ld a, kLCD_Line3 
d799			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
d799 06 28			ld b, display_cols 
d79b ed 5b d8 eb		ld de, (display_write_tmp) 
d79f cd c1 d7			call write_len_string 
d7a2				 
d7a2 2a d8 eb			ld hl, (display_write_tmp) 
d7a5 11 28 00			ld de, display_cols 
d7a8 19				add hl,de 
d7a9 22 d8 eb			ld (display_write_tmp),hl 
d7ac			 
d7ac e5			push hl 
d7ad d5			push de 
d7ae c5			push bc 
d7af 0e 07			ld c, 7 
d7b1 f7				rst $30 
d7b2 c1			pop bc 
d7b3 d1			pop de 
d7b4 e1			pop hl 
d7b5			 
d7b5				 
d7b5 3e 78			ld a, kLCD_Line4 
d7b7			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
d7b7 06 28			ld b, display_cols 
d7b9 ed 5b d8 eb		ld de, (display_write_tmp) 
d7bd cd c1 d7			call write_len_string 
d7c0 c9					ret 
d7c1			 
d7c1			 
d7c1				; write out a fixed length string given in b from de 
d7c1			 
d7c1 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
d7c2 cd 34 d7		            CALL fLCD_Data      ;Write character to display 
d7c5 13				inc de 
d7c6 10 f9			djnz write_len_string 
d7c8 c9				ret 
d7c9			 
d7c9			 
d7c9			; eof 
# End of file firmware_serial_display.asm
d7c9			;include "firmware_key_5x10.asm" 
d7c9			;;include "firmware_key_4x10.asm" 
d7c9			include "firmware_key_serial.asm" 
d7c9			; Serial keyboard interface for SC114 
d7c9			 
d7c9			key_init: 
d7c9				; no init as handled by the SCM bios 
d7c9 c9				ret 
d7ca			 
d7ca			 
d7ca			cin_wait: 
d7ca			;	ld a, 0 
d7ca			;	ret 
d7ca			 
d7ca				;in a,(SC114_SIO_1_IN) 
d7ca			        ; Use SCM API to get from whatever console device we are using 
d7ca c5				push bc 
d7cb 0e 01			ld c, $01 
d7cd f7				rst $30 
d7ce c1				pop bc 
d7cf c9				ret 
d7d0			 
d7d0			cin: 
d7d0			 
d7d0			 
d7d0 c5				push bc 
d7d1			 
d7d1				; any key waiting to process? 
d7d1 0e 03			ld c, $03 
d7d3 f7				rst $30 
d7d4 28 05			jr z, .cin_skip 
d7d6			 
d7d6				; yep, get it 
d7d6			 
d7d6 0e 01			ld c, $01 
d7d8 f7				rst $30 
d7d9 c1				pop bc 
d7da c9				ret 
d7db			.cin_skip: 
d7db 3e 00			ld a, 0 
d7dd c1				pop bc 
d7de c9				ret 
d7df			 
d7df			 
d7df			 
d7df			 
# End of file firmware_key_serial.asm
d7df			endofcode:  
d7df			baseram:  
d7df 00				nop 
d7e0			 
d7e0			heap_start: equ baseram+15  ; Starting address of heap 
d7e0			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
d7e0			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
d7e0			;VDU:  EQU     endofcode           ; BASIC Work space 
d7e0			; eof 
d7e0			 
# End of file os_mega_sc114.asm
d7e0
