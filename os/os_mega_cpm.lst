# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 1 
0000			STARTUP_V2: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 6d 17			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			 
0103 ..			buildtime: db   "Build: " 
010a					include "romtimestamp.asm" 
010a ..			db '2025-08-09 11:33' 
# End of file romtimestamp.asm
011a 00				   db 0 
011b			 
011b			 
011b			 
011b			;        nop  
011b			;        nop 
011b			;;	org 05h		; null out bdos call 
011b			; 
011b			;        nop  
011b			;        nop  
011b			;        nop 
011b			;;	org 08h 
011b			;;; 
011b			;;	jp cin		; rst 8 - char in 
011b			;;; 
011b			; 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;        nop 
011b			;	org 010h 
011b			;; 
011b			;	jp cout		; rest 010h  - char out 
011b			;; 
011b			;	org 01bh   
011b			; 
011b			;	;jp  		; rst 01bh   - write string to display 
011b			;	jp str_at_display 
011b			; 
011b			; 
011b			;	org 020h 
011b			; 
011b			;	; jp		 ; rst 020h - read char at screen location 
011b			; 
011b			;	org 028h 
011b			 
011b				; jp		 ; rst 028h  - storage i/o 
011b			 
011b			; 	org 030h 
011b			;	jp break_point_state 
011b			  
011b			; $30  
011b			; org 038h 
011b			; $38 
011b			 
011b			; TODO any more important entry points to add to jump table for easier coding use? 
011b			 
011b			if BASE_KEV = 1  
011b			 
011b				; need to be at $66 for nmi support 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255,0,255,0,255 
011b				db 0,255 
011b				jp nmi 
011b			endif 
011b			 
011b			include "firmware.asm" 
011b			  
011b			; main constants (used here and in firmware)  
011b			  
011b			; TODO have page 0 of storage as bios  
011b			  
011b			Device_A: equ 0h  
011b			Device_B: equ 040h          ; Sound  
011b			  
011b			if BASE_KEV  
011b			Device_C: equ 080h          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			if BASE_SC114  
011b			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			if BASE_CPM  
011b			; TODO fixup for CPM  
011b			Device_C: equ 080h          ; Storage and ext cart devices  
011b			endif  
011b			  
011b			Device_D: equ 0c0h             ; Keyboard and LCD  
011b			  
011b			; Odd specific debug points for testing hardware dev  
011b			  
011b			DEBUG_SOUND: equ 0       
011b			DEBUG_STK_FAULT: equ 0  
011b			DEBUG_INPUT: equ 0     ; Debug input entry code  
011b			DEBUG_INPUTV2: equ 0     ; Debug input entry code  
011b			DEBUG_KEYCINWAIT: equ 0  
011b			DEBUG_KEYCIN: equ 0  
011b			DEBUG_KEY: equ 0  
011b			DEBUG_KEY_MATRIX: equ 0  
011b			DEBUG_STORECF: equ 0  
011b			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
011b			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
011b			DEBUG_SPI: equ 0    ; low level spi tests  
011b			  
011b			; Enable many break points  
011b			  
011b			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
011b			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
011b			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
011b			DEBUG_FORTH_JP: equ 0    ; 4  
011b			DEBUG_FORTH_MALLOC: equ 0  
011b			DEBUG_FORTH_MALLOC_INT: equ 0  
011b			DEBUG_FORTH_DOT: equ 1  
011b			DEBUG_FORTH_DOT_WAIT: equ 0  
011b			DEBUG_FORTH_MATHS: equ 0  
011b			DEBUG_FORTH_TOK: equ 0    ; 4  
011b			DEBUG_FORTH_PARSE: equ 0    ; 3  
011b			DEBUG_FORTH: equ 0  ;2  
011b			DEBUG_FORTH_WORDS: equ 1   ; 1  
011b			DEBUG_FORTH_PUSH: equ 1   ; 1  
011b			DEBUG_FORTH_UWORD: equ 1   ; 1  
011b			  
011b			; Enable key point breakpoints  
011b			  
011b			DEBUG_FORTH_DOT_KEY: equ 0  
011b			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
011b			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
011b			  
011b			; Debug stack imbalances  
011b			  
011b			ON: equ 1  
011b			OFF: equ 0  
011b			  
011b			DEBUG_STACK_IMB: equ 0  
011b			STACK_IMB_STORE: equ 20  
011b			  
011b			; House keeping and protections  
011b			  
011b			DEBUG_FORTH_STACK_GUARD: equ 1  
011b			DEBUG_FORTH_MALLOC_GUARD: equ 1  
011b			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
011b			FORTH_ENABLE_FREE: equ 0  
011b			FORTH_ENABLE_MALLOCFREE: equ 1  
011b			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
011b			FORTH_ENABLE_FLOATMATH: equ 0  
011b			  
011b			  
011b			CALLMONITOR: macro  
011b			;	call break_point_state  
011b			; now use the break point debug vector  
011b				call debug_vector  
011b				endm  
011b			  
011b			MALLOC_1: equ 1        ; from dk88   
011b			MALLOC_2: equ 0           ; broke  
011b			MALLOC_3: equ 0           ; really broke  
011b			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
011b			  
011b			if BASE_KEV   
011b			;stacksize: equ 256  
011b			; each stack entry is three bytes (type + word)  
011b			stacksize: equ 3*150  
011b			  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 512  
011b			endif  
011b			if BASE_SC114  
011b			;tos:	equ 0f000h  
011b			stacksize: equ 256  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 256  
011b			endif  
011b			  
011b			if BASE_CPM  
011b			;tos:	equ 0f000h  
011b			stacksize: equ 256  
011b			STACK_RET_SIZE: equ 64  
011b			STACK_LOOP_SIZE: equ 128  
011b			STACK_DATA_SIZE: equ 256  
011b			endif  
011b			  
011b			;if STORAGE_SE == 0  
011b			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
011b			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
011b			;endif  
011b			  
011b			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
011b			  
011b			STORE_0_AUTORUN: equ $20  
011b			  
011b			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
011b			  
011b			STORE_0_AUTOFILE: equ $21  
011b			STORE_0_BANKRUN: equ $23  
011b			STORE_0_FILERUN: equ $24  
011b			  
011b			; Block 0 offsets for settings  
011b			  
011b			; if set then skip prompt for start up and accept all  
011b			  
011b			STORE_0_QUICKSTART: equ $25  
011b			  
011b			; Blocks where directory table is held  
011b			  
011b			; Reducing the number of entries increases the max file size  
011b			  
011b			;STORE_DIR_START: equ 1  
011b			;STORE_DIR_END: equ 33  
011b			  
011b			; Blocks from where file data is stored  
011b			  
011b			;STORE_DATA_START: equ STORE_DIR_END + 1  
011b			  
011b			; Block indicators (<32 are data files)  
011b			  
011b			;STORE_BLOCK_CFG: equ $8f       ; config block  
011b			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
011b			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
011b			;STORE_BLOCK_FREE: equ $85       ; data block free  
011b			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
011b			  
011b			  
011b			  
011b			; Directory entry flags  
011b			  
011b			;STORE_DIR_FREE: equ 0  
011b			;STORE_DIR_FILE:  equ 1  
011b			  
011b			; Structure offsets to directory entries  
011b			;STORE_DE_FLAG: equ 0  
011b			;STORE_DE_MAXEXT: equ 1  
011b			;STORE_DE_FILENAME: equ 2  
011b			  
011b			; Structure offsets to block 0  
011b			  
011b			;STORE_BK0_ISFOR: equ 1  
011b			;STORE_BK0_LABEL: equ 3  
011b			  
011b			; memory allocation   
011b			  
011b			chk_stund: equ tos+2           ; underflow check word  
011b			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
011b			  
011b			; keyscan table needs rows x cols buffer  
011b			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
011b			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
011b			  
011b			keyscan_table_row1: equ chk_stovr -key_cols-1  
011b			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
011b			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
011b			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
011b			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
011b			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
011b			keyscan_scancol: equ keyscan_table-key_cols  
011b			;keyscan_table_len: equ key_rows*key_cols  
011b			;keybufptr: equ keyscan_table - 2  
011b			;keysymbol: equ keybufptr - 1  
011b			key_held: equ keyscan_scancol-1	; currently held  
011b			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
011b			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
011b			key_fa: equ key_repeat_ct -1 ;  
011b			key_fb: equ key_fa -1 ;  
011b			key_fc: equ key_fb -1 ;  
011b			key_fd: equ key_fc -1 ;  
011b			key_face_held: equ key_fd - 1   
011b			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
011b			  
011b			hardware_config: equ key_face_held - 10  
011b			  
011b			; hardware config switches  
011b			; TODO add bitmasks on includes for hardware  
011b			; high byte for expansion ids  
011b			;     0000 0000  no card inserted  
011b			;     0000 0001  storage card inserted  
011b			;     0000 0010  spi sd card active  
011b			  
011b			;       
011b			; low byte:  
011b			;     0000 0001   4x4 keypad  
011b			;     0000 0010   full keyboard  
011b			;     0000 0011   spi/ext keyboard  
011b			;     0000 0100   20x4 lcd  
011b			;     0000 1000   40x4 lcd  
011b			;     0000 1100   spi/ext display  
011b			;     0001 0000   ide interface available  
011b			  
011b			hardware_word: equ hardware_config - 2  
011b			  
011b			; debug marker - optional display of debug point on the debug screens  
011b			  
011b			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
011b			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
011b			  
011b			debug_mark: equ debug_vector - 4  
011b			  
011b			; input_str vars  
011b			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
011b			input_start:  equ input_ptr - 2    ; ptr to the start of string   
011b			input_size: equ input_start -1  ; number of chars  
011b			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
011b			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
011b			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
011b			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
011b			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
011b			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
011b			input_len: equ input_cur_onoff - 5 ; length of current input  
011b			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
011b			  
011b			; cursor blink rate  
011b			CUR_BLINK_RATE: equ $09  
011b			;CUR_BLINK_RATE: equ 15  
011b			  
011b			key_actual_pressed: equ input_cursor - 1   
011b			key_symbol: equ key_actual_pressed - 1   
011b			key_shift: equ key_symbol - 1   
011b			  
011b			; Display allocation  
011b			  
011b			;display_rows: equ 4     ; move out to mini and mega files  
011b			;display_cols: equ 20  
011b			  
011b			display_fb_len: equ display_rows*display_cols  
011b			  
011b			; primary frame buffer     
011b			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
011b			; working frame buffers  
011b			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
011b			display_fb3: equ  display_fb1-display_fb_len - 1  
011b			display_fb2: equ  display_fb3-display_fb_len - 1  
011b			;  
011b			; pointer to active frame buffer  
011b			display_fb_active: equ display_fb2 - 2  
011b			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
011b			display_write_tmp: equ display_lcde1e2 - 2  
011b			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
011b			  
011b			;  
011b			  
011b			;; can load into de directory  
011b			cursor_col: equ display_active-1  
011b			cursor_row: equ cursor_col-1  
011b			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
011b			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
011b			  
011b			; maths vars  
011b			  
011b			LFSRSeed: equ cursor_shape -20   
011b			randData: equ LFSRSeed - 2  
011b			xrandc: equ randData - 2  
011b			stackstore: equ xrandc - 2  
011b			seed1: equ  stackstore -2   
011b			seed2: equ seed1 - 2  
011b			  
011b			; cf storage vars  
011b			  
011b			iErrorNum:  equ seed2-1         ;Error number  
011b			iErrorReg:  equ iErrorNum -1              ;Error register  
011b			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
011b			  
011b			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
011b			  
011b			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
011b			  
011b			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
011b			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
011b			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
011b			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
011b			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
011b			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
011b			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
011b			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
011b			store_tmpid: equ store_tmp3 - 1		; page temp id  
011b			store_tmpext: equ store_tmpid - 1		; file extent temp  
011b			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
011b			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
011b			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
011b			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
011b			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
011b			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
011b			;  
011b			; spi vars  
011b			  
011b			  
011b			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
011b			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
011b			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
011b			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
011b			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
011b			spi_device_id: equ spi_device - 1    ; human readable bank number  
011b			  
011b			;;;;; forth cli params  
011b			  
011b			; TODO use a different frame buffer for forth???  
011b			  
011b			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
011b			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
011b			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
011b			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
011b			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
011b			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
011b			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
011b			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
011b			  
011b			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
011b			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
011b			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
011b			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
011b			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
011b			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
011b			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
011b			  
011b			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
011b			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011b			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
011b			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
011b			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
011b			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
011b			chk_data_ovr: equ cli_data_stack -2; overflow check word  
011b			  
011b			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
011b			  
011b			; os/forth token vars  
011b			  
011b			os_last_cmd: equ os_var_array-255  
011b			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
011b			os_current_i: equ os_cli_cmd-2  
011b			os_cur_ptr: equ os_current_i-2  
011b			os_word_scratch: equ os_cur_ptr-30  
011b			os_tok_len: equ os_word_scratch - 2  
011b			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
011b			os_tok_malloc: equ os_tok_ptr - 2  
011b			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
011b			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
011b			execscratch: equ os_input-255        ; exec cmd eval buffer  
011b			scratch: equ execscratch-255  
011b			  
011b			os_stack_1: equ scratch - 3       ; stack holding area 1  
011b			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
011b			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
011b			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
011b			  
011b			  
011b			; temp locations for new word processing to save on adding more   
011b			  
011b			os_new_malloc: equ os_stack_4-2  
011b			os_new_parse_len: equ os_new_malloc - 2  
011b			os_new_word_len: equ os_new_parse_len - 2  
011b			os_new_work_ptr: equ os_new_word_len - 2  
011b			os_new_src_ptr: equ os_new_work_ptr - 2  
011b			os_new_exec: equ os_new_src_ptr - 2  
011b			os_new_exec_ptr: equ os_new_exec - 2  
011b			  
011b			; resume memory alloocations....  
011b			  
011b			;os_view_disable: equ os_new_exec_ptr - 1  
011b			os_view_af: equ os_new_exec_ptr - 2  
011b			os_view_hl: equ os_view_af -2  
011b			os_view_de: equ os_view_hl - 2  
011b			os_view_bc: equ os_view_de - 2  
011b			  
011b			; stack checksum word  
011b			if DEBUG_STACK_IMB  
011b				curframe: equ  os_view_de - 5  
011b				store_sp: equ curframe - (STACK_IMB_STORE*4)  
011b				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011b			else  
011b				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
011b			endif  
011b			  
011b			; with data stack could see memory filled with junk. need some memory management   
011b			; malloc and free entry points added  
011b			  
011b			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
011b			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
011b			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			;heap_end: equ free_list-1  ; Starting address of heap  
011b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			  
011b			;heap_start: equ free_list - heap_size  ; Starting address of heap  
011b			heap_end: equ chk_word-1  ; Starting address of heap  
011b			  
011b			  
011b			;if BASE_KEV   
011b			;heap_start: equ 0800eh  ; Starting address of heap  
011b			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
011b			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
011b			;endif  
011b			  
011b			;if BASE_SC114  
011b			;heap_start: equ baseram+15  ; Starting address of heap  
011b			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
011b			;endif  
011b			  
011b			  
011b			;;;;  
011b			  
011b			  
011b			; change below to point to last memory alloc above  
011b			topusermem:  equ   heap_start  
011b			  
011b			;if BASE_KEV   
011b			;baseusermem: equ 08000h  
011b			;endif  
011b			  
011b			;if BASE_SC114  
011b			;;aseusermem:     equ    12  
011b			;baseusermem:     equ    prompt  
011b			;;baseusermem:     equ    endofcode  
011b			;endif  
011b			  
011b			  
011b			; **********************************************************************  
011b			; **  Constants  
011b			; **********************************************************************  
011b			  
011b			; Constants used by this code module  
011b			kDataReg:   EQU Device_D           ;PIO port A data register  
011b			kContReg:   EQU Device_D+2           ;PIO port A control register  
011b			  
011b			  
011b			portbdata:  equ Device_D+1    ; port b data  
011b			portbctl:   equ Device_D+3    ; port b control  
011b			  
011b			  
011b			;KEY_SHIFT:   equ 5  
011b			;KEY_SYMBOLSHIFT:  equ 6  
011b			  
011b			KEY_SHIFTLOCK: equ 4  
011b			  
011b			  
011b			KEY_UP: equ 5  
011b			KEY_NEXTWORD: equ 6  
011b			KEY_PREVWORD: equ 7  
011b			KEY_BS: equ 8  
011b			KEY_TAB:  equ 9  
011b			KEY_DOWN: equ 10  
011b			KEY_LEFT: equ 11  
011b			KEY_RIGHT: equ 12  
011b			KEY_CR:   equ 13  
011b			KEY_HOME: equ 14  
011b			KEY_END: equ 15  
011b			  
011b			KEY_F1: equ 16  
011b			KEY_F2: equ 17  
011b			KEY_F3: equ 18  
011b			KEY_F4: equ 19  
011b			  
011b			KEY_F5: equ 20  
011b			KEY_F6: equ 21  
011b			KEY_F7: equ 22  
011b			KEY_F8: equ 23  
011b			  
011b			KEY_F9: equ 24  
011b			KEY_F10: equ 25  
011b			KEY_F11: equ 26  
011b			KEY_F12: equ 27  
011b			  
011b			;if DEBUG_KEY  
011b			;	KEY_MATRIX_NO_PRESS: equ '.'  
011b			;	KEY_SHIFT:   equ '.'  
011b			;	KEY_SYMBOLSHIFT:  equ '.'  
011b			;else  
011b				KEY_SHIFT:   equ '~'  
011b				KEY_SYMBOLSHIFT:  equ '~'  
011b				KEY_MATRIX_NO_PRESS: equ '~'  
011b			;endi  
011b			  
011b			  
011b			  
011b			  
011b			; Macro to make adding debug marks easier  
011b			  
011b			DMARK: macro str  
011b				push af  
011b				ld a, (.dmark)  
011b				ld (debug_mark),a  
011b				ld a, (.dmark+1)  
011b				ld (debug_mark+1),a  
011b				ld a, (.dmark+2)  
011b				ld (debug_mark+2),a  
011b				jr .pastdmark  
011b			.dmark: db str  
011b			.pastdmark: pop af  
011b			  
011b			endm  
011b			  
011b			  
011b			; macro to detect for stack imbalances  
011b			  
011b			include "stackimbal.asm"  
011b			; Macro and code to detect stock imbalances 
011b			 
011b			SPPUSH: equ 0 
011b			 
011b			; Add a stack frame which can be checked before return 
011b			 
011b			STACKFRAME: macro onoff frame1 frame2 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						; save current SP 
011b						exx 
011b			 
011b						ld de, frame1 
011b						ld a, d 
011b						ld hl, curframe 
011b						call hexout 
011b						ld a, e 
011b						ld hl, curframe+2 
011b						call hexout 
011b			  
011b						ld hl, frame1 
011b						push hl 
011b						ld hl, frame2 
011b						push hl 
011b						exx 
011b					endif 
011b					 
011b				endif 
011b			endm 
011b			 
011b			STACKFRAMECHK: macro onoff frame1 frame2 
011b			 
011b					 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						exx 
011b						; check stack frame SP 
011b			 
011b						ld hl, frame2 
011b						pop de   ; frame2 
011b			 
011b						call cmp16 
011b						jr nz, .spnosame 
011b						 
011b			 
011b						ld hl, frame1 
011b						pop de   ; frame1 
011b			 
011b						call cmp16 
011b						jr z, .spfrsame 
011b			 
011b						.spnosame: call showsperror 
011b			 
011b						.spfrsame: nop 
011b			 
011b						exx 
011b					endif 
011b					 
011b				endif 
011b			 
011b			 
011b			endm 
011b			 
011b			 
011b			; for a sub routine, wrap SP collection and comparisons 
011b			 
011b			; Usage: 
011b			; 
011b			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
011b			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
011b			 
011b			SAVESP: macro onoff storeword 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b						; save current SP 
011b			 
011b						ld (store_sp+(storeword*4)), sp 
011b			 
011b					endif 
011b					 
011b				endif 
011b			 
011b			endm 
011b			 
011b			CHECKSP: macro onoff storeword 
011b			 
011b				if DEBUG_STACK_IMB 
011b					if onoff 
011b			 
011b						; save SP after last save 
011b				 
011b						ld (store_sp+(storeword*4)+2), sp 
011b			 
011b						push hl 
011b						ld hl, store_sp+(storeword*4) 
011b						call check_stack_sp  
011b						pop hl 
011b			 
011b			 
011b					endif 
011b					 
011b				endif 
011b			 
011b			endm 
011b			 
011b			if DEBUG_STACK_IMB 
011b			 
011b			check_stack_sp: 
011b					push de 
011b			 
011b					ld e, (hl) 
011b					inc hl 
011b					ld d, (hl) 
011b					inc hl 
011b			 
011b					push de 
011b			 
011b			 
011b					ld e, (hl) 
011b					inc hl 
011b					ld d, (hl) 
011b					inc hl 
011b			 
011b					pop hl 
011b			 
011b			 
011b					; check to see if the same 
011b			 
011b					call cmp16 
011b					jr z, .spsame 
011b			 
011b					; not same 
011b			 
011b					call showsperror 
011b			.spsame: 
011b			 
011b					pop de 
011b			 
011b					ret 
011b			 
011b			.sperr:  db "Stack imbalance",0 
011b			 
011b			 
011b			showsperror: 
011b			 
011b			 
011b				push hl 
011b				push af 
011b				push de 
011b				call clear_display 
011b				ld de, .sperr 
011b				ld a,0 
011b			;	ld de,os_word_scratch 
011b				call str_at_display 
011b				ld a, display_row_1+17 
011b				ld de, debug_mark 
011b				call str_at_display 
011b				ld a, 0 
011b				ld (curframe+4),a 
011b				ld hl, curframe 
011b				ld de, os_word_scratch 
011b				ld a, display_row_4 
011b				call str_at_display 
011b				call update_display 
011b				;call break_point_state 
011b				call cin_wait 
011b			 
011b			;	ld a, ' ' 
011b			;	ld (os_view_disable), a 
011b				call bp_on 
011b				pop de	 
011b				pop af 
011b				pop hl 
011b				CALLMONITOR 
011b				ret 
011b			 
011b			endif 
011b			 
011b			 
011b			 
011b			; eof 
# End of file stackimbal.asm
011b			  
011b			;TODO macro to calc col and row offset into screen  
011b			  
011b			  
011b			  
011b			hardware_init:  
011b			  
011b				  
011b			  
011b					;ld a, 0  
011b					;ld (hardware_diag), a  
011b			  
011b					; clear all the buffers  
011b			  
011b 21 10 ed				ld hl, display_fb1  
011e 22 cc eb				ld (display_fb_active), hl  
0121			  
0121 cd b9 0b				call clear_display  
0124			  
0124 21 ce eb				ld hl, display_fb2  
0127 22 cc eb				ld (display_fb_active), hl  
012a			  
012a cd b9 0b				call clear_display  
012d			  
012d					; init primary frame buffer area  
012d 21 b1 ed				ld hl, display_fb0  
0130 22 cc eb				ld (display_fb_active), hl  
0133			  
0133 cd b9 0b				call clear_display  
0136			  
0136			  
0136 cd 64 5d				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0139			  
0139 cd 52 5e			call key_init  
013c cd 9e 01			call storage_init  
013f			  
013f				; setup malloc functions  
013f			  
013f				if MALLOC_1  
013f cd 9d 11				call  heap_init  
0142				endif  
0142				if MALLOC_4  
0142					call  heap_init  
0142				endif  
0142			  
0142				; init sound hardware if present  
0142			  
0142				if SOUND_ENABLE  
0142					call sound_init  
0142				endif  
0142			  
0142				; lcd test sequence  
0142					  
0142 cd dc 0b			call update_display  
0145 cd f1 0a			call delay1s  
0148 3e 2b			ld a,'+'  
014a cd be 0b			call fill_display  
014d cd dc 0b			call update_display  
0150 cd f1 0a			call delay1s  
0153 3e 2a			ld a,'*'  
0155 cd be 0b			call fill_display  
0158 cd dc 0b			call update_display  
015b cd f1 0a			call delay1s  
015e 3e 2d			ld a,'-'  
0160 cd be 0b			call fill_display  
0163 cd dc 0b			call update_display  
0166 cd f1 0a			call delay1s  
0169			  
0169			; boot splash screen  
0169			if display_cols == 20	  
0169			        ld a, display_row_1    
0169			else  
0169 3e 0a		        ld a, display_row_1 +10   
016b			endif  
016b 11 cb 16			ld de, prom_bootmsg  
016e cd cc 0b			call str_at_display  
0171 cd dc 0b			call update_display  
0174			  
0174			  
0174 cd f1 0a			call delay1s  
0177 cd f1 0a			call delay1s  
017a			if display_cols == 20	  
017a			            LD   A, display_row_3+2  
017a			else  
017a 3e 5c		            LD   A, display_row_3+12  
017c			endif  
017c 11 e0 16			ld de, prom_bootmsg1  
017f cd cc 0b			call str_at_display  
0182 cd dc 0b			call update_display  
0185 cd f1 0a			call delay1s  
0188 cd f1 0a			call delay1s  
018b			  
018b			;	ld a, display_row_4+3  
018b			;	ld de, bootmsg2  
018b			;	call str_at_display  
018b			;	call update_display  
018b			;	call delay1s  
018b			;	call delay1s  
018b			  
018b			; debug mark setup  
018b			  
018b 3e 5f		ld a, '_'  
018d 32 6b ee		ld (debug_mark),a  
0190 32 6c ee		ld (debug_mark+1),a  
0193 32 6d ee		ld (debug_mark+2),a  
0196 3e 00		ld a,0  
0198 32 6e ee		ld (debug_mark+3),a  
019b			  
019b c9					ret  
019c			  
019c			  
019c			;bootmsg2:	db "Firmware v0.1",0  
019c			  
019c			; a 4x20 lcd  
019c			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
019c			  
019c			;if display_cols == 20  
019c			;	include "firmware_lcd_4x20.asm"  
019c			;endif  
019c			  
019c			;if display_cols == 40  
019c			;	include "firmware_lcd_4x40.asm"  
019c			;endif  
019c			  
019c			;  
019c			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
019c			; TODO abstract the bit bang video out interface for dual display  
019c			; TODO wire video out to tx pin on rc2014 bus  
019c			  
019c			; must supply cin, and cin_wait for low level hardware abstraction   
019c			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
019c			; test scancode  
019c			  
019c			;;;;;  
019c			;;;  
019c			; Moved out to mini and maxi versions  
019c			;  
019c			; include "firmware_key_4x4.asm"  
019c			; using existing 4 wire x 4 resistor array for input  
019c			;include "firmware_key_4x10.asm"  
019c			; need to mod the board for 5 rows due to resistor array  
019c			;include "firmware_key_5x10.asm"  
019c			  
019c			; storage hardware interface  
019c			  
019c			; use microchip serial eeprom for storage  
019c			  
019c			  
019c			if STORAGE_SE  
019c				include "firmware_spi.asm"  
019c				include "firmware_seeprom.asm"  
019c			else  
019c			   ; create some stubs for the labels  
019c c9			se_readbyte: ret  
019d c9			se_writebyte: ret  
019e c9			storage_init: ret  
019f			  
019f			endif  
019f			  
019f			; use cf card for storage - throwing timeout errors. Hardware or software?????  
019f			;include "firmware_cf.asm"  
019f			  
019f			; load up high level storage hardward abstractions  
019f			include "firmware_storage.asm"  
019f			 
019f			; persisent storage hardware abstraction layer  
019f			 
019f			 
019f			 
019f			; Block 0 on storage is a config state 
019f			 
019f			 
019f			 
019f			; TODO add read phy block and write phy block functions 
019f			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
019f			 
019f			; Abstraction layer  
019f			 
019f			; Logocial block size is same size as physical size - using tape concept 
019f			 
019f			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
019f			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
019f			 
019f			 
019f			 
019f			; Filesystem layout (Logical layout) 
019f			; 
019f			; Block 0 - Bank config  
019f			; 
019f			;      Byte - 0 file id counter 
019f			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
019f			;      Byte - 3-20 zero terminated bank label 
019f			; 
019f			; Block 1 > File storage 
019f			; 
019f			;      Byte 0 file id    - block 0 file details 
019f			;      Byte 1 block id - block 0 is file  
019f			;            Byte 2-15 - File name 
019f			; 
019f			;       - to end of block data 
019f			; 
019f			 
019f			; Get ID for the file named in pointer held HL 
019f			; Returns ID in HL = 255 if no file found 
019f			 
019f			storage_getid: 
019f			 
019f 22 73 ea			ld (store_tmp1), hl 
01a2			 
01a2				if DEBUG_STORESE 
01a2					DMARK "SGI" 
01a2 f5				push af  
01a3 3a b7 01			ld a, (.dmark)  
01a6 32 6b ee			ld (debug_mark),a  
01a9 3a b8 01			ld a, (.dmark+1)  
01ac 32 6c ee			ld (debug_mark+1),a  
01af 3a b9 01			ld a, (.dmark+2)  
01b2 32 6d ee			ld (debug_mark+2),a  
01b5 18 03			jr .pastdmark  
01b7 ..			.dmark: db "SGI"  
01ba f1			.pastdmark: pop af  
01bb			endm  
# End of macro DMARK
01bb					CALLMONITOR 
01bb cd 6f ee			call debug_vector  
01be				endm  
# End of macro CALLMONITOR
01be				endif 
01be				; get block 0 and set counter for number of files to scan 
01be			 
01be cd 29 03			call storage_get_block_0 
01c1			 
01c1 3a 7a ea			ld a, (store_page) 
01c4 47				ld b, a 
01c5			 
01c5				; get extent 0 of each file id 
01c5			 
01c5				if DEBUG_STORESE 
01c5					DMARK "SGc" 
01c5 f5				push af  
01c6 3a da 01			ld a, (.dmark)  
01c9 32 6b ee			ld (debug_mark),a  
01cc 3a db 01			ld a, (.dmark+1)  
01cf 32 6c ee			ld (debug_mark+1),a  
01d2 3a dc 01			ld a, (.dmark+2)  
01d5 32 6d ee			ld (debug_mark+2),a  
01d8 18 03			jr .pastdmark  
01da ..			.dmark: db "SGc"  
01dd f1			.pastdmark: pop af  
01de			endm  
# End of macro DMARK
01de					CALLMONITOR 
01de cd 6f ee			call debug_vector  
01e1				endm  
# End of macro CALLMONITOR
01e1				endif 
01e1 60			.getloop:	ld h, b 
01e2 2e 00				ld l, 0 
01e4 c5					push bc 
01e5			 
01e5 11 7a ea				ld de, store_page 
01e8				if DEBUG_STORESE 
01e8					DMARK "SGr" 
01e8 f5				push af  
01e9 3a fd 01			ld a, (.dmark)  
01ec 32 6b ee			ld (debug_mark),a  
01ef 3a fe 01			ld a, (.dmark+1)  
01f2 32 6c ee			ld (debug_mark+1),a  
01f5 3a ff 01			ld a, (.dmark+2)  
01f8 32 6d ee			ld (debug_mark+2),a  
01fb 18 03			jr .pastdmark  
01fd ..			.dmark: db "SGr"  
0200 f1			.pastdmark: pop af  
0201			endm  
# End of macro DMARK
0201					CALLMONITOR 
0201 cd 6f ee			call debug_vector  
0204				endm  
# End of macro CALLMONITOR
0204				endif 
0204 cd d1 07				call storage_read 
0207 cd 0f 0e				call ishlzero 
020a 28 2d				jr z, .gap 
020c					 
020c					; have a file name read. Is it one we want. 
020c			 
020c 2a 73 ea				ld hl, (store_tmp1) 
020f 11 7d ea				ld de, store_page+3   ; file name 
0212			 
0212				if DEBUG_STORESE 
0212					DMARK "SGc" 
0212 f5				push af  
0213 3a 27 02			ld a, (.dmark)  
0216 32 6b ee			ld (debug_mark),a  
0219 3a 28 02			ld a, (.dmark+1)  
021c 32 6c ee			ld (debug_mark+1),a  
021f 3a 29 02			ld a, (.dmark+2)  
0222 32 6d ee			ld (debug_mark+2),a  
0225 18 03			jr .pastdmark  
0227 ..			.dmark: db "SGc"  
022a f1			.pastdmark: pop af  
022b			endm  
# End of macro DMARK
022b					CALLMONITOR 
022b cd 6f ee			call debug_vector  
022e				endm  
# End of macro CALLMONITOR
022e				endif 
022e cd 84 11				call strcmp 
0231 20 06				jr nz, .gap   ; not this one 
0233			 
0233 c1				        pop bc 
0234			 
0234 26 00				ld h, 0 
0236 68					ld l, b 
0237 18 22				jr .getdone 
0239						 
0239			 
0239			 
0239			 
0239			.gap: 
0239				if DEBUG_STORESE 
0239					DMARK "SGg" 
0239 f5				push af  
023a 3a 4e 02			ld a, (.dmark)  
023d 32 6b ee			ld (debug_mark),a  
0240 3a 4f 02			ld a, (.dmark+1)  
0243 32 6c ee			ld (debug_mark+1),a  
0246 3a 50 02			ld a, (.dmark+2)  
0249 32 6d ee			ld (debug_mark+2),a  
024c 18 03			jr .pastdmark  
024e ..			.dmark: db "SGg"  
0251 f1			.pastdmark: pop af  
0252			endm  
# End of macro DMARK
0252					CALLMONITOR 
0252 cd 6f ee			call debug_vector  
0255				endm  
# End of macro CALLMONITOR
0255				endif 
0255			 
0255 c1					pop bc 
0256 10 89				djnz .getloop 
0258 21 ff 00				ld hl, 255 
025b			.getdone: 
025b			 
025b				if DEBUG_STORESE 
025b					DMARK "SGe" 
025b f5				push af  
025c 3a 70 02			ld a, (.dmark)  
025f 32 6b ee			ld (debug_mark),a  
0262 3a 71 02			ld a, (.dmark+1)  
0265 32 6c ee			ld (debug_mark+1),a  
0268 3a 72 02			ld a, (.dmark+2)  
026b 32 6d ee			ld (debug_mark+2),a  
026e 18 03			jr .pastdmark  
0270 ..			.dmark: db "SGe"  
0273 f1			.pastdmark: pop af  
0274			endm  
# End of macro DMARK
0274					CALLMONITOR 
0274 cd 6f ee			call debug_vector  
0277				endm  
# End of macro CALLMONITOR
0277				endif 
0277			 
0277 c9				ret 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			 
0278			; Read Block 
0278			; ---------- 
0278			; 
0278			; With current bank 
0278			;  
0278			; Get block number to read 
0278			; Load physical blocks starting at start block into buffer 
0278			 
0278			; de points to buffer to use 
0278			; hl holds logical block number  
0278			 
0278			storage_read_block: 
0278			 
0278				; TODO bank selection 
0278			 
0278				; for each of the physical blocks read it into the buffer 
0278 06 40			ld b, STORE_BLOCK_PHY 
027a			 
027a				if DEBUG_STORESE 
027a d5					push de 
027b				endif 
027b				 
027b			.rl1:    
027b			 
027b				; read physical block at hl into de 
027b			        ; increment hl and de to next read position on exit 
027b			 
027b e5				push hl 
027c d5				push de	 
027d c5				push bc 
027e			;	if DEBUG_STORESE 
027e			;		push af 
027e			;		ld a, 'R' 
027e			;		ld (debug_mark),a 
027e			;		pop af 
027e			;		CALLMONITOR 
027e			;	endif 
027e cd 9c 01			call se_readbyte 
0281			;	if DEBUG_STORESE 
0281			;		ld a,(spi_portbyte) 
0281			;		ld l, a 
0281			;		push af 
0281			;		ld a, '1' 
0281			;		ld (debug_mark),a 
0281			;		pop af 
0281			;		CALLMONITOR 
0281			;	endif 
0281 c1				pop bc 
0282 d1				pop de 
0283 e1				pop hl 
0284 12				ld (de),a 
0285 23				inc hl 
0286 13				inc de 
0287			 
0287			;	if DEBUG_STORESE 
0287			;		push af 
0287			;		ld a, 'r' 
0287			;		ld (debug_mark),a 
0287			;		pop af 
0287			;		CALLMONITOR 
0287			;	endif 
0287			 
0287 10 f2			djnz .rl1 
0289			 
0289				if DEBUG_STORESE 
0289					DMARK "SRB" 
0289 f5				push af  
028a 3a 9e 02			ld a, (.dmark)  
028d 32 6b ee			ld (debug_mark),a  
0290 3a 9f 02			ld a, (.dmark+1)  
0293 32 6c ee			ld (debug_mark+1),a  
0296 3a a0 02			ld a, (.dmark+2)  
0299 32 6d ee			ld (debug_mark+2),a  
029c 18 03			jr .pastdmark  
029e ..			.dmark: db "SRB"  
02a1 f1			.pastdmark: pop af  
02a2			endm  
# End of macro DMARK
02a2 d1					pop de 
02a3			; 
02a3			;		push af 
02a3			;		ld a, 'R' 
02a3			;		ld (debug_mark),a 
02a3			;		pop af 
02a3					CALLMONITOR 
02a3 cd 6f ee			call debug_vector  
02a6				endm  
# End of macro CALLMONITOR
02a6				endif 
02a6 c9				ret	 
02a7				 
02a7			 
02a7			; File Size 
02a7			; --------- 
02a7			; 
02a7			;   hl file id 
02a7			; 
02a7			;  returns in hl the number of blocks 
02a7			 
02a7			storage_file_size: 
02a7 5d				ld e, l 
02a8 16 00			ld d, 0 
02aa 21 40 00			ld hl, STORE_BLOCK_PHY 
02ad					if DEBUG_FORTH_WORDS 
02ad						DMARK "SIZ" 
02ad f5				push af  
02ae 3a c2 02			ld a, (.dmark)  
02b1 32 6b ee			ld (debug_mark),a  
02b4 3a c3 02			ld a, (.dmark+1)  
02b7 32 6c ee			ld (debug_mark+1),a  
02ba 3a c4 02			ld a, (.dmark+2)  
02bd 32 6d ee			ld (debug_mark+2),a  
02c0 18 03			jr .pastdmark  
02c2 ..			.dmark: db "SIZ"  
02c5 f1			.pastdmark: pop af  
02c6			endm  
# End of macro DMARK
02c6						CALLMONITOR 
02c6 cd 6f ee			call debug_vector  
02c9				endm  
# End of macro CALLMONITOR
02c9					endif 
02c9 cd ab 05			call storage_findnextid 
02cc			 
02cc cd 0f 0e			call ishlzero 
02cf			;	ld a, l 
02cf			;	add h 
02cf			;	cp 0 
02cf c8				ret z			; block not found so EOF 
02d0			 
02d0 11 7a ea			ld de, store_page 
02d3 cd 78 02			call storage_read_block 
02d6			 
02d6 3a 7c ea			ld a, (store_page+2)	 ; get extent count 
02d9 6f				ld l, a 
02da 26 00			ld h, 0 
02dc c9			 	ret 
02dd			 
02dd			 
02dd			; Write Block 
02dd			; ----------- 
02dd			; 
02dd			; With current bank 
02dd			;  
02dd			; Get block number to write 
02dd			; Write physical blocks starting at start block from buffer 
02dd			  
02dd			storage_write_block: 
02dd				; TODO bank selection 
02dd			 
02dd				; for each of the physical blocks read it into the buffer 
02dd 06 40			ld b, STORE_BLOCK_PHY 
02df			 
02df				if DEBUG_STORESE 
02df					DMARK "SWB" 
02df f5				push af  
02e0 3a f4 02			ld a, (.dmark)  
02e3 32 6b ee			ld (debug_mark),a  
02e6 3a f5 02			ld a, (.dmark+1)  
02e9 32 6c ee			ld (debug_mark+1),a  
02ec 3a f6 02			ld a, (.dmark+2)  
02ef 32 6d ee			ld (debug_mark+2),a  
02f2 18 03			jr .pastdmark  
02f4 ..			.dmark: db "SWB"  
02f7 f1			.pastdmark: pop af  
02f8			endm  
# End of macro DMARK
02f8			 
02f8					;push af 
02f8					;ld a, 'W' 
02f8					;ld (debug_mark),a 
02f8					;pop af 
02f8					CALLMONITOR 
02f8 cd 6f ee			call debug_vector  
02fb				endm  
# End of macro CALLMONITOR
02fb				endif 
02fb			 
02fb			; might not be working 
02fb			;	call se_writepage 
02fb			 
02fb			;	ret 
02fb			; 
02fb			 
02fb			 
02fb			 
02fb			.wl1:    
02fb			 
02fb				; read physical block at hl into de 
02fb			        ; increment hl and de to next read position on exit 
02fb			 
02fb e5				push hl 
02fc d5				push de	 
02fd c5				push bc 
02fe 1a				ld a,(de) 
02ff				;if DEBUG_STORESE 
02ff			;		push af 
02ff			;		ld a, 'W' 
02ff			;		ld (debug_mark),a 
02ff			;		pop af 
02ff			;		CALLMONITOR 
02ff			;	endif 
02ff cd 9d 01			call se_writebyte 
0302			;	call delay250ms 
0302 00				nop 
0303 00				nop 
0304 00				nop 
0305			;	if DEBUG_STORESE 
0305			;		push af 
0305			;		ld a, 'w' 
0305			;		ld (debug_mark),a 
0305			;		pop af 
0305			;		CALLMONITOR 
0305			;	endif 
0305 c1				pop bc 
0306 d1				pop de 
0307 e1				pop hl 
0308 23				inc hl 
0309 13				inc de 
030a			 
030a			 
030a 10 ef			djnz .wl1 
030c			 
030c				if DEBUG_STORESE 
030c					DMARK "SW2" 
030c f5				push af  
030d 3a 21 03			ld a, (.dmark)  
0310 32 6b ee			ld (debug_mark),a  
0313 3a 22 03			ld a, (.dmark+1)  
0316 32 6c ee			ld (debug_mark+1),a  
0319 3a 23 03			ld a, (.dmark+2)  
031c 32 6d ee			ld (debug_mark+2),a  
031f 18 03			jr .pastdmark  
0321 ..			.dmark: db "SW2"  
0324 f1			.pastdmark: pop af  
0325			endm  
# End of macro DMARK
0325			 
0325					;push af 
0325					;ld a, 'W' 
0325					;ld (debug_mark),a 
0325					;pop af 
0325					CALLMONITOR 
0325 cd 6f ee			call debug_vector  
0328				endm  
# End of macro CALLMONITOR
0328				endif 
0328 c9				ret	 
0329			 
0329			; Init bank 
0329			; --------- 
0329			; 
0329			; With current bank 
0329			; 
0329			; Setup block 0 config 
0329			;     Set 0 file id counter 
0329			;     Set formatted byte pattern 
0329			;     Zero out bank label 
0329			;      
0329			; For every logical block write 0-1 byte as null 
0329			 
0329			storage_get_block_0: 
0329			 
0329				; TODO check presence 
0329			 
0329				; get block 0 config 
0329			 
0329 21 00 00			ld hl, 0 
032c 11 7a ea			ld de, store_page 
032f cd 78 02			call storage_read_block 
0332			 
0332				if DEBUG_STORESE 
0332					DMARK "SB0" 
0332 f5				push af  
0333 3a 47 03			ld a, (.dmark)  
0336 32 6b ee			ld (debug_mark),a  
0339 3a 48 03			ld a, (.dmark+1)  
033c 32 6c ee			ld (debug_mark+1),a  
033f 3a 49 03			ld a, (.dmark+2)  
0342 32 6d ee			ld (debug_mark+2),a  
0345 18 03			jr .pastdmark  
0347 ..			.dmark: db "SB0"  
034a f1			.pastdmark: pop af  
034b			endm  
# End of macro DMARK
034b 11 7a ea				ld de, store_page 
034e			;		push af 
034e			;		ld a, 'i' 
034e			;		ld (debug_mark),a 
034e			;		pop af 
034e					CALLMONITOR 
034e cd 6f ee			call debug_vector  
0351				endm  
# End of macro CALLMONITOR
0351				endif 
0351			 
0351				; is this area formatted? 
0351			 
0351			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0351 2a 7b ea			ld hl, (store_page+1) 
0354 3e 80			ld a,0x80 
0356 bd				cp l 
0357 20 22			jr nz, .ininotformatted 
0359				; do a double check 
0359 3e 27			ld a, 0x27 
035b bc				cp h 
035c 20 1d			jr nz, .ininotformatted 
035e			 
035e				; formatted then 
035e			 
035e				if DEBUG_STORESE 
035e					DMARK "SB1" 
035e f5				push af  
035f 3a 73 03			ld a, (.dmark)  
0362 32 6b ee			ld (debug_mark),a  
0365 3a 74 03			ld a, (.dmark+1)  
0368 32 6c ee			ld (debug_mark+1),a  
036b 3a 75 03			ld a, (.dmark+2)  
036e 32 6d ee			ld (debug_mark+2),a  
0371 18 03			jr .pastdmark  
0373 ..			.dmark: db "SB1"  
0376 f1			.pastdmark: pop af  
0377			endm  
# End of macro DMARK
0377					;push af 
0377					;ld a, 'I' 
0377					;ld (debug_mark),a 
0377					;pop af 
0377					CALLMONITOR 
0377 cd 6f ee			call debug_vector  
037a				endm  
# End of macro CALLMONITOR
037a				endif 
037a c9				ret 
037b			 
037b			.ininotformatted: 
037b				; bank not formatted so poke various bits to make sure 
037b			 
037b				if DEBUG_STORESE 
037b					DMARK "SB2" 
037b f5				push af  
037c 3a 90 03			ld a, (.dmark)  
037f 32 6b ee			ld (debug_mark),a  
0382 3a 91 03			ld a, (.dmark+1)  
0385 32 6c ee			ld (debug_mark+1),a  
0388 3a 92 03			ld a, (.dmark+2)  
038b 32 6d ee			ld (debug_mark+2),a  
038e 18 03			jr .pastdmark  
0390 ..			.dmark: db "SB2"  
0393 f1			.pastdmark: pop af  
0394			endm  
# End of macro DMARK
0394					;push af 
0394					;ld a, 'f' 
0394					;ld (debug_mark),a 
0394					;pop af 
0394					CALLMONITOR 
0394 cd 6f ee			call debug_vector  
0397				endm  
# End of macro CALLMONITOR
0397				endif 
0397			 
0397 cd b4 0a			call storage_clear_page 
039a			 
039a 21 7a ea			ld hl, store_page 
039d 3e 00			ld a, 0 
039f				 
039f 77				ld (hl),a   ; reset file counter 
03a0			 
03a0 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03a3 22 7b ea		 	ld (store_page+1), hl	 
03a6			 
03a6				; set default label 
03a6			 
03a6 21 42 04			ld hl, .defaultbanklabl 
03a9 11 7d ea		 	ld de, store_page+3 
03ac 01 0f 00			ld bc, 15 
03af ed b0			ldir 
03b1			 
03b1				; Append the current bank id 
03b1 21 86 ea			ld hl, store_page+3+9 
03b4 3a 5f ea			ld a, (spi_device_id) 
03b7 77				ld (hl), a 
03b8			 
03b8				; save default page 0 
03b8			 
03b8 21 00 00			ld hl, 0 
03bb 11 7a ea			ld de, store_page 
03be				if DEBUG_STORESE 
03be					DMARK "SB3" 
03be f5				push af  
03bf 3a d3 03			ld a, (.dmark)  
03c2 32 6b ee			ld (debug_mark),a  
03c5 3a d4 03			ld a, (.dmark+1)  
03c8 32 6c ee			ld (debug_mark+1),a  
03cb 3a d5 03			ld a, (.dmark+2)  
03ce 32 6d ee			ld (debug_mark+2),a  
03d1 18 03			jr .pastdmark  
03d3 ..			.dmark: db "SB3"  
03d6 f1			.pastdmark: pop af  
03d7			endm  
# End of macro DMARK
03d7			;		push af 
03d7			;		ld a, 'F' 
03d7			;		ld (debug_mark),a 
03d7			;		pop af 
03d7					CALLMONITOR 
03d7 cd 6f ee			call debug_vector  
03da				endm  
# End of macro CALLMONITOR
03da				endif 
03da cd dd 02			call storage_write_block 
03dd				if DEBUG_STORESE 
03dd					DMARK "SB4" 
03dd f5				push af  
03de 3a f2 03			ld a, (.dmark)  
03e1 32 6b ee			ld (debug_mark),a  
03e4 3a f3 03			ld a, (.dmark+1)  
03e7 32 6c ee			ld (debug_mark+1),a  
03ea 3a f4 03			ld a, (.dmark+2)  
03ed 32 6d ee			ld (debug_mark+2),a  
03f0 18 03			jr .pastdmark  
03f2 ..			.dmark: db "SB4"  
03f5 f1			.pastdmark: pop af  
03f6			endm  
# End of macro DMARK
03f6			;		push af 
03f6			;		ld a, '>' 
03f6			;		ld (debug_mark),a 
03f6			;		pop af 
03f6					CALLMONITOR 
03f6 cd 6f ee			call debug_vector  
03f9				endm  
# End of macro CALLMONITOR
03f9				endif 
03f9			 
03f9 00				nop 
03fa 00				nop 
03fb 00				nop 
03fc			 
03fc				; now set 0 in every page to mark as a free block 
03fc			 
03fc 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03fe 21 40 00			ld hl, STORE_BLOCK_PHY 
0401			 
0401 3e 00		.setmark1:   	ld a,0 
0403 e5					push hl 
0404 c5					push bc 
0405 cd 9d 01				call se_writebyte 
0408 3e 0a			ld a, 10 
040a cd d6 0a			call aDelayInMS 
040d 23				inc hl 
040e cd 9d 01				call se_writebyte 
0411 3e 0a			ld a, 10 
0413 cd d6 0a			call aDelayInMS 
0416 2b				dec hl 
0417 c1					pop bc 
0418 e1					pop hl 
0419 3e 40				ld a, STORE_BLOCK_PHY 
041b cd e6 0d				call addatohl 
041e 10 e1				djnz .setmark1 
0420			 
0420 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0422 3e 00		.setmark2:   	ld a,0 
0424 e5					push hl 
0425 c5					push bc 
0426 cd 9d 01				call se_writebyte 
0429 3e 0a			ld a, 10 
042b cd d6 0a			call aDelayInMS 
042e 23				inc hl 
042f cd 9d 01				call se_writebyte 
0432 3e 0a			ld a, 10 
0434 cd d6 0a			call aDelayInMS 
0437 2b				dec hl 
0438 c1					pop bc 
0439 e1					pop hl 
043a 3e 40				ld a, STORE_BLOCK_PHY 
043c cd e6 0d				call addatohl 
043f 10 e1				djnz .setmark2 
0441			 
0441					 
0441			 
0441			 
0441 c9				ret 
0442			 
0442			 
0442			 
0442			 
0442 .. 00		.defaultbanklabl:   db "BankLabel_",0 
044d			 
044d			 
044d			 
044d			; Label Bank 
044d			; ---------- 
044d			; 
044d			; With current bank 
044d			; Read block 0 
044d			; Set label 
044d			; Write block 0 
044d			 
044d			; label str pointer in hl 
044d			 
044d			storage_label:     
044d			 
044d				if DEBUG_STORESE 
044d					DMARK "LBL" 
044d f5				push af  
044e 3a 62 04			ld a, (.dmark)  
0451 32 6b ee			ld (debug_mark),a  
0454 3a 63 04			ld a, (.dmark+1)  
0457 32 6c ee			ld (debug_mark+1),a  
045a 3a 64 04			ld a, (.dmark+2)  
045d 32 6d ee			ld (debug_mark+2),a  
0460 18 03			jr .pastdmark  
0462 ..			.dmark: db "LBL"  
0465 f1			.pastdmark: pop af  
0466			endm  
# End of macro DMARK
0466					CALLMONITOR 
0466 cd 6f ee			call debug_vector  
0469				endm  
# End of macro CALLMONITOR
0469				endif 
0469			 
0469 e5				push hl 
046a			 
046a cd 29 03			call storage_get_block_0 
046d			 
046d				; set default label 
046d			 
046d e1				pop hl 
046e			 
046e 11 7d ea		 	ld de, store_page+3 
0471 01 0f 00			ld bc, 15 
0474				if DEBUG_STORESE 
0474					DMARK "LB3" 
0474 f5				push af  
0475 3a 89 04			ld a, (.dmark)  
0478 32 6b ee			ld (debug_mark),a  
047b 3a 8a 04			ld a, (.dmark+1)  
047e 32 6c ee			ld (debug_mark+1),a  
0481 3a 8b 04			ld a, (.dmark+2)  
0484 32 6d ee			ld (debug_mark+2),a  
0487 18 03			jr .pastdmark  
0489 ..			.dmark: db "LB3"  
048c f1			.pastdmark: pop af  
048d			endm  
# End of macro DMARK
048d					CALLMONITOR 
048d cd 6f ee			call debug_vector  
0490				endm  
# End of macro CALLMONITOR
0490				endif 
0490 ed b0			ldir 
0492				; save default page 0 
0492			 
0492 21 00 00			ld hl, 0 
0495 11 7a ea			ld de, store_page 
0498				if DEBUG_STORESE 
0498					DMARK "LBW" 
0498 f5				push af  
0499 3a ad 04			ld a, (.dmark)  
049c 32 6b ee			ld (debug_mark),a  
049f 3a ae 04			ld a, (.dmark+1)  
04a2 32 6c ee			ld (debug_mark+1),a  
04a5 3a af 04			ld a, (.dmark+2)  
04a8 32 6d ee			ld (debug_mark+2),a  
04ab 18 03			jr .pastdmark  
04ad ..			.dmark: db "LBW"  
04b0 f1			.pastdmark: pop af  
04b1			endm  
# End of macro DMARK
04b1					CALLMONITOR 
04b1 cd 6f ee			call debug_vector  
04b4				endm  
# End of macro CALLMONITOR
04b4				endif 
04b4 cd dd 02			call storage_write_block 
04b7			 
04b7 c9				ret 
04b8			 
04b8			 
04b8			 
04b8			; Read Block 0 - Config 
04b8			; --------------------- 
04b8			; 
04b8			; With current bank 
04b8			; Call presence test 
04b8			;    If not present format/init bank  
04b8			; Read block 0  
04b8			;  
04b8			 
04b8			 
04b8			; Dir 
04b8			; --- 
04b8			; 
04b8			; With current bank 
04b8			; Load Block 0 Config 
04b8			; Get max file id number 
04b8			; For each logical block 
04b8			;    Read block read byte 2 
04b8			;      if first block of file 
04b8			;         Display file name 
04b8			;         Display type flags for file 
04b8			;        
04b8			 
04b8			; moving to words as this requires stack control 
04b8			 
04b8			 
04b8			; Delete File 
04b8			; ----------- 
04b8			; 
04b8			; With current bank 
04b8			; 
04b8			; Load Block 0 Config 
04b8			; Get max file id number 
04b8			; For each logical block 
04b8			;    Read block file id 
04b8			;      If first block of file and dont have file id 
04b8			;         if file to delete 
04b8			;         Save file id 
04b8			;         Null file id 
04b8			;         Write this block back 
04b8			;      If file id is one saved 
04b8			;         Null file id 
04b8			;         Write this block back 
04b8			 
04b8			 
04b8			.se_done: 
04b8 e1				pop hl 
04b9 c9				ret 
04ba			 
04ba			storage_erase: 
04ba			 
04ba				; hl contains the file id 
04ba			 
04ba 5d				ld e, l 
04bb 16 00			ld d, 0 
04bd 21 40 00			ld hl, STORE_BLOCK_PHY 
04c0					if DEBUG_FORTH_WORDS 
04c0						DMARK "ERA" 
04c0 f5				push af  
04c1 3a d5 04			ld a, (.dmark)  
04c4 32 6b ee			ld (debug_mark),a  
04c7 3a d6 04			ld a, (.dmark+1)  
04ca 32 6c ee			ld (debug_mark+1),a  
04cd 3a d7 04			ld a, (.dmark+2)  
04d0 32 6d ee			ld (debug_mark+2),a  
04d3 18 03			jr .pastdmark  
04d5 ..			.dmark: db "ERA"  
04d8 f1			.pastdmark: pop af  
04d9			endm  
# End of macro DMARK
04d9						CALLMONITOR 
04d9 cd 6f ee			call debug_vector  
04dc				endm  
# End of macro CALLMONITOR
04dc					endif 
04dc cd ab 05			call storage_findnextid 
04df cd 0f 0e			call ishlzero 
04e2 c8				ret z 
04e3			 
04e3 e5				push hl 
04e4			 
04e4				; TODO check file not found 
04e4			 
04e4 11 7a ea			ld de, store_page 
04e7 cd 78 02			call storage_read_block 
04ea			 
04ea cd 0f 0e			call ishlzero 
04ed ca b8 04			jp z,.se_done 
04f0			 
04f0					if DEBUG_FORTH_WORDS 
04f0						DMARK "ER1" 
04f0 f5				push af  
04f1 3a 05 05			ld a, (.dmark)  
04f4 32 6b ee			ld (debug_mark),a  
04f7 3a 06 05			ld a, (.dmark+1)  
04fa 32 6c ee			ld (debug_mark+1),a  
04fd 3a 07 05			ld a, (.dmark+2)  
0500 32 6d ee			ld (debug_mark+2),a  
0503 18 03			jr .pastdmark  
0505 ..			.dmark: db "ER1"  
0508 f1			.pastdmark: pop af  
0509			endm  
# End of macro DMARK
0509						CALLMONITOR 
0509 cd 6f ee			call debug_vector  
050c				endm  
# End of macro CALLMONITOR
050c					endif 
050c 3a 7a ea			ld a, (store_page)	; get file id 
050f 32 6e ea			ld (store_tmpid), a 
0512			 
0512 3a 7c ea			ld a, (store_page+2)    ; get count of extends 
0515 32 6d ea			ld (store_tmpext), a 
0518			 
0518				; wipe file header 
0518			 
0518 e1				pop hl 
0519 3e 00			ld a, 0 
051b 32 7a ea			ld (store_page), a 
051e 32 7b ea			ld (store_page+1),a 
0521 11 7a ea			ld de, store_page 
0524					if DEBUG_FORTH_WORDS 
0524						DMARK "ER2" 
0524 f5				push af  
0525 3a 39 05			ld a, (.dmark)  
0528 32 6b ee			ld (debug_mark),a  
052b 3a 3a 05			ld a, (.dmark+1)  
052e 32 6c ee			ld (debug_mark+1),a  
0531 3a 3b 05			ld a, (.dmark+2)  
0534 32 6d ee			ld (debug_mark+2),a  
0537 18 03			jr .pastdmark  
0539 ..			.dmark: db "ER2"  
053c f1			.pastdmark: pop af  
053d			endm  
# End of macro DMARK
053d						CALLMONITOR 
053d cd 6f ee			call debug_vector  
0540				endm  
# End of macro CALLMONITOR
0540					endif 
0540 cd dd 02			call storage_write_block 
0543			 
0543			 
0543				; wipe file extents 
0543			 
0543 3a 6d ea			ld a, (store_tmpext) 
0546 47				ld b, a 
0547			 
0547			.eraext:	  
0547 c5				push bc 
0548			 
0548 21 40 00			ld hl, STORE_BLOCK_PHY 
054b 3a 6e ea			ld a,(store_tmpid) 
054e 5f				ld e, a 
054f 50				ld d, b	 
0550					if DEBUG_FORTH_WORDS 
0550						DMARK "ER3" 
0550 f5				push af  
0551 3a 65 05			ld a, (.dmark)  
0554 32 6b ee			ld (debug_mark),a  
0557 3a 66 05			ld a, (.dmark+1)  
055a 32 6c ee			ld (debug_mark+1),a  
055d 3a 67 05			ld a, (.dmark+2)  
0560 32 6d ee			ld (debug_mark+2),a  
0563 18 03			jr .pastdmark  
0565 ..			.dmark: db "ER3"  
0568 f1			.pastdmark: pop af  
0569			endm  
# End of macro DMARK
0569						CALLMONITOR 
0569 cd 6f ee			call debug_vector  
056c				endm  
# End of macro CALLMONITOR
056c					endif 
056c cd ab 05			call storage_findnextid 
056f cd 0f 0e			call ishlzero 
0572 ca b8 04			jp z,.se_done 
0575			 
0575 e5				push hl 
0576 11 7a ea			ld de, store_page 
0579 cd 78 02			call storage_read_block 
057c			 
057c				; free block	 
057c			 
057c 3e 00			ld a, 0 
057e 32 7a ea			ld (store_page), a 
0581 32 7b ea			ld (store_page+1),a 
0584 11 7a ea			ld de, store_page 
0587 e1				pop hl 
0588					if DEBUG_FORTH_WORDS 
0588						DMARK "ER4" 
0588 f5				push af  
0589 3a 9d 05			ld a, (.dmark)  
058c 32 6b ee			ld (debug_mark),a  
058f 3a 9e 05			ld a, (.dmark+1)  
0592 32 6c ee			ld (debug_mark+1),a  
0595 3a 9f 05			ld a, (.dmark+2)  
0598 32 6d ee			ld (debug_mark+2),a  
059b 18 03			jr .pastdmark  
059d ..			.dmark: db "ER4"  
05a0 f1			.pastdmark: pop af  
05a1			endm  
# End of macro DMARK
05a1						CALLMONITOR 
05a1 cd 6f ee			call debug_vector  
05a4				endm  
# End of macro CALLMONITOR
05a4					endif 
05a4 cd dd 02			call storage_write_block 
05a7			 
05a7 c1				pop bc 
05a8 10 9d			djnz .eraext 
05aa			 
05aa c9				ret 
05ab			 
05ab			 
05ab			; Find Free Block 
05ab			; --------------- 
05ab			; 
05ab			; With current bank 
05ab			;  
05ab			; From given starting logical block 
05ab			;    Read block  
05ab			;    If no file id 
05ab			;         Return block id 
05ab			 
05ab			 
05ab			; hl starting page number 
05ab			; hl contains free page number or zero if no pages free 
05ab			; e contains the file id to locate 
05ab			; d contains the block number 
05ab			 
05ab			; TODO change to find file id and use zero for free block 
05ab			 
05ab			storage_findnextid: 
05ab			 
05ab				; now locate first 0 page to mark as a free block 
05ab			 
05ab 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05ad			;	ld hl, STORE_BLOCK_PHY 
05ad			 
05ad					if DEBUG_FORTH_WORDS 
05ad					DMARK "FNI" 
05ad f5				push af  
05ae 3a c2 05			ld a, (.dmark)  
05b1 32 6b ee			ld (debug_mark),a  
05b4 3a c3 05			ld a, (.dmark+1)  
05b7 32 6c ee			ld (debug_mark+1),a  
05ba 3a c4 05			ld a, (.dmark+2)  
05bd 32 6d ee			ld (debug_mark+2),a  
05c0 18 03			jr .pastdmark  
05c2 ..			.dmark: db "FNI"  
05c5 f1			.pastdmark: pop af  
05c6			endm  
# End of macro DMARK
05c6						CALLMONITOR 
05c6 cd 6f ee			call debug_vector  
05c9				endm  
# End of macro CALLMONITOR
05c9					endif 
05c9			.ff1:   	 
05c9 e5					push hl 
05ca c5					push bc 
05cb d5					push de 
05cc cd 9c 01				call se_readbyte 
05cf 5f					ld e,a 
05d0 23					inc hl 
05d1 cd 9c 01				call se_readbyte 
05d4 57					ld d, a 
05d5 e1					pop hl 
05d6 e5					push hl 
05d7 cd 04 0e				call cmp16 
05da 28 49				jr z, .fffound 
05dc			 
05dc d1					pop de 
05dd c1					pop bc 
05de e1					pop hl 
05df			 
05df					; is found? 
05df					;cp e 
05df					;ret z 
05df			 
05df 3e 40				ld a, STORE_BLOCK_PHY 
05e1 cd e6 0d				call addatohl 
05e4 10 e3				djnz .ff1 
05e6			 
05e6 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05e8			.ff2:   	 
05e8			 
05e8 e5					push hl 
05e9 c5					push bc 
05ea d5					push de 
05eb cd 9c 01				call se_readbyte 
05ee 5f					ld e,a 
05ef 23					inc hl 
05f0 cd 9c 01				call se_readbyte 
05f3 57					ld d, a 
05f4			 
05f4 e1					pop hl 
05f5 e5					push hl 
05f6 cd 04 0e				call cmp16 
05f9 28 2a				jr z, .fffound 
05fb			 
05fb d1					pop de 
05fc c1					pop bc 
05fd e1					pop hl 
05fe					; is found? 
05fe					;cp e 
05fe					;ret z 
05fe			 
05fe 3e 40				ld a, STORE_BLOCK_PHY 
0600 cd e6 0d				call addatohl 
0603 10 e3				djnz .ff2 
0605			 
0605			 
0605					if DEBUG_FORTH_WORDS 
0605					DMARK "FN-" 
0605 f5				push af  
0606 3a 1a 06			ld a, (.dmark)  
0609 32 6b ee			ld (debug_mark),a  
060c 3a 1b 06			ld a, (.dmark+1)  
060f 32 6c ee			ld (debug_mark+1),a  
0612 3a 1c 06			ld a, (.dmark+2)  
0615 32 6d ee			ld (debug_mark+2),a  
0618 18 03			jr .pastdmark  
061a ..			.dmark: db "FN-"  
061d f1			.pastdmark: pop af  
061e			endm  
# End of macro DMARK
061e					;	push af 
061e					;	ld a, 'n' 
061e					;	ld (debug_mark),a 
061e					;	pop af 
061e						CALLMONITOR 
061e cd 6f ee			call debug_vector  
0621				endm  
# End of macro CALLMONITOR
0621					endif 
0621				; no free marks! 
0621 21 00 00				ld hl, 0 
0624 c9				ret 
0625			.fffound: 
0625				 
0625			 
0625 d1					pop de 
0626 c1					pop bc 
0627 e1					pop hl 
0628					if DEBUG_FORTH_WORDS 
0628					DMARK "FNF" 
0628 f5				push af  
0629 3a 3d 06			ld a, (.dmark)  
062c 32 6b ee			ld (debug_mark),a  
062f 3a 3e 06			ld a, (.dmark+1)  
0632 32 6c ee			ld (debug_mark+1),a  
0635 3a 3f 06			ld a, (.dmark+2)  
0638 32 6d ee			ld (debug_mark+2),a  
063b 18 03			jr .pastdmark  
063d ..			.dmark: db "FNF"  
0640 f1			.pastdmark: pop af  
0641			endm  
# End of macro DMARK
0641					;	push af 
0641					;	ld a, 'n' 
0641					;	ld (debug_mark),a 
0641					;	pop af 
0641						CALLMONITOR 
0641 cd 6f ee			call debug_vector  
0644				endm  
# End of macro CALLMONITOR
0644					endif 
0644 c9				ret 
0645			 
0645			 
0645			 
0645			; Free Space 
0645			; ---------- 
0645			; 
0645			; With current bank 
0645			; 
0645			; Set block count to zero 
0645			; Starting with first logical block 
0645			;      Find free block  
0645			;      If block id given, increment block count 
0645			; 
0645			;  
0645			 
0645			 
0645			; hl contains count of free blocks 
0645			 
0645			storage_freeblocks: 
0645			 
0645				; now locate first 0 page to mark as a free block 
0645			 
0645 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0647 21 40 00			ld hl, STORE_BLOCK_PHY 
064a 11 00 00			ld de, 0 
064d			 
064d			.fb1:   	 
064d e5					push hl 
064e c5					push bc 
064f d5					push de 
0650 cd 9c 01				call se_readbyte 
0653 d1					pop de 
0654 c1					pop bc 
0655 e1					pop hl 
0656			 
0656					; is free? 
0656 fe 00				cp 0 
0658 20 01				jr nz, .ff1cont 
065a 13					inc de 
065b			 
065b			.ff1cont: 
065b			 
065b			 
065b 3e 40				ld a, STORE_BLOCK_PHY 
065d cd e6 0d				call addatohl 
0660 10 eb				djnz .fb1 
0662			 
0662 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0664			.fb2:   	 
0664 e5					push hl 
0665 c5					push bc 
0666 d5					push de 
0667 cd 9c 01				call se_readbyte 
066a d1					pop de 
066b c1					pop bc 
066c e1					pop hl 
066d			 
066d					; is free? 
066d fe 00				cp 0 
066f 20 01				jr nz, .ff2cont 
0671 13					inc de 
0672			 
0672			.ff2cont: 
0672			 
0672 3e 40				ld a, STORE_BLOCK_PHY 
0674 cd e6 0d				call addatohl 
0677 10 eb				djnz .fb2 
0679			 
0679 eb				ex de, hl 
067a c9				ret 
067b			 
067b			; Get File ID 
067b			; ----------- 
067b			; 
067b			; With current bank 
067b			;  
067b			; Load Block 0 Config 
067b			; Get max file id number 
067b			; For each logical block 
067b			;    Read block file id 
067b			;      If first block of file and dont have file id 
067b			;         if file get id and exit 
067b			 
067b			 
067b			 
067b			 
067b			; Create File 
067b			; ----------- 
067b			; 
067b			; With current bank  
067b			; Load Block 0 Config 
067b			; Get max file id number 
067b			; Increment file id number 
067b			; Save Config 
067b			; Find free block 
067b			; Set buffer with file name and file id 
067b			; Write buffer to free block  
067b			 
067b			 
067b			; hl point to file name 
067b			; hl returns file id 
067b			 
067b			; file format: 
067b			; byte 0 - file id 
067b			; byte 1 - extent number 
067b			; byte 2-> data 
067b			 
067b			; format for extent number 0: 
067b			; 
067b			; byte 0 - file id 
067b			; byte 1 - extent 0 
067b			; byte 2 - extent count 
067b			; byte 3 -> file name and meta data 
067b			 
067b			 
067b			storage_create: 
067b				if DEBUG_STORESE 
067b					DMARK "SCR" 
067b f5				push af  
067c 3a 90 06			ld a, (.dmark)  
067f 32 6b ee			ld (debug_mark),a  
0682 3a 91 06			ld a, (.dmark+1)  
0685 32 6c ee			ld (debug_mark+1),a  
0688 3a 92 06			ld a, (.dmark+2)  
068b 32 6d ee			ld (debug_mark+2),a  
068e 18 03			jr .pastdmark  
0690 ..			.dmark: db "SCR"  
0693 f1			.pastdmark: pop af  
0694			endm  
# End of macro DMARK
0694					CALLMONITOR 
0694 cd 6f ee			call debug_vector  
0697				endm  
# End of macro CALLMONITOR
0697				endif 
0697			 
0697 e5				push hl		; save file name pointer 
0698			 
0698 cd 29 03			call storage_get_block_0 
069b			 
069b 3a 7a ea			ld a,(store_page)	; get current file id 
069e 3c				inc a 
069f 32 7a ea			ld (store_page),a 
06a2				 
06a2 32 6e ea			ld (store_tmpid),a			; save id 
06a5			 
06a5 21 00 00			ld hl, 0 
06a8 11 7a ea			ld de, store_page 
06ab				if DEBUG_STORESE 
06ab					DMARK "SCw" 
06ab f5				push af  
06ac 3a c0 06			ld a, (.dmark)  
06af 32 6b ee			ld (debug_mark),a  
06b2 3a c1 06			ld a, (.dmark+1)  
06b5 32 6c ee			ld (debug_mark+1),a  
06b8 3a c2 06			ld a, (.dmark+2)  
06bb 32 6d ee			ld (debug_mark+2),a  
06be 18 03			jr .pastdmark  
06c0 ..			.dmark: db "SCw"  
06c3 f1			.pastdmark: pop af  
06c4			endm  
# End of macro DMARK
06c4					CALLMONITOR 
06c4 cd 6f ee			call debug_vector  
06c7				endm  
# End of macro CALLMONITOR
06c7				endif 
06c7 cd dd 02			call storage_write_block	 ; save update 
06ca			 
06ca				if DEBUG_STORESE 
06ca 11 7a ea				ld de, store_page 
06cd					DMARK "SCC" 
06cd f5				push af  
06ce 3a e2 06			ld a, (.dmark)  
06d1 32 6b ee			ld (debug_mark),a  
06d4 3a e3 06			ld a, (.dmark+1)  
06d7 32 6c ee			ld (debug_mark+1),a  
06da 3a e4 06			ld a, (.dmark+2)  
06dd 32 6d ee			ld (debug_mark+2),a  
06e0 18 03			jr .pastdmark  
06e2 ..			.dmark: db "SCC"  
06e5 f1			.pastdmark: pop af  
06e6			endm  
# End of macro DMARK
06e6					CALLMONITOR 
06e6 cd 6f ee			call debug_vector  
06e9				endm  
# End of macro CALLMONITOR
06e9				endif 
06e9				;  
06e9				 
06e9 21 40 00			ld hl, STORE_BLOCK_PHY 
06ec 11 00 00			ld de, 0 
06ef cd ab 05			call storage_findnextid 
06f2			 
06f2 22 65 ea			ld (store_tmppageid), hl    ; save page to use  
06f5			 
06f5				; TODO detect 0 = no spare blocks 
06f5			 
06f5				; hl now contains the free page to use for the file header page 
06f5			 
06f5				if DEBUG_STORESE 
06f5				DMARK "SCF" 
06f5 f5				push af  
06f6 3a 0a 07			ld a, (.dmark)  
06f9 32 6b ee			ld (debug_mark),a  
06fc 3a 0b 07			ld a, (.dmark+1)  
06ff 32 6c ee			ld (debug_mark+1),a  
0702 3a 0c 07			ld a, (.dmark+2)  
0705 32 6d ee			ld (debug_mark+2),a  
0708 18 03			jr .pastdmark  
070a ..			.dmark: db "SCF"  
070d f1			.pastdmark: pop af  
070e			endm  
# End of macro DMARK
070e					CALLMONITOR 
070e cd 6f ee			call debug_vector  
0711				endm  
# End of macro CALLMONITOR
0711				endif 
0711			 
0711 22 65 ea			ld (store_tmppageid), hl 
0714				 
0714 3a 6e ea			ld a,(store_tmpid)    ; get file id 
0717			;	ld a, (store_filecache)			; save to cache 
0717			 
0717 32 7a ea			ld (store_page),a    ; set page id 
071a 3e 00			ld a, 0			 ; extent 0 is file header 
071c 32 7b ea			ld (store_page+1), a   ; set file extent 
071f			 
071f 32 7c ea			ld (store_page+2), a   ; extent count for the file 
0722			 
0722			;	inc hl 		; init block 0 of file 
0722			;	inc hl   		; skip file and extent id 
0722			 ;       ld a, 0 
0722			;	ld (hl),a 
0722			;	ld a, (store_filecache+1)  	; save to cache 
0722			 
0722			;	inc hl    ; file name 
0722				 
0722				 
0722 11 7d ea			ld de, store_page+3    ; get buffer for term string to use as file name 
0725				if DEBUG_STORESE 
0725					DMARK "SCc" 
0725 f5				push af  
0726 3a 3a 07			ld a, (.dmark)  
0729 32 6b ee			ld (debug_mark),a  
072c 3a 3b 07			ld a, (.dmark+1)  
072f 32 6c ee			ld (debug_mark+1),a  
0732 3a 3c 07			ld a, (.dmark+2)  
0735 32 6d ee			ld (debug_mark+2),a  
0738 18 03			jr .pastdmark  
073a ..			.dmark: db "SCc"  
073d f1			.pastdmark: pop af  
073e			endm  
# End of macro DMARK
073e					CALLMONITOR 
073e cd 6f ee			call debug_vector  
0741				endm  
# End of macro CALLMONITOR
0741				endif 
0741 e1				pop hl    ; get zero term string 
0742 e5				push hl 
0743 3e 00			ld a, 0 
0745 cd 57 11			call strlent 
0748 23				inc hl   ; cover zero term 
0749 06 00			ld b,0 
074b 4d				ld c,l 
074c e1				pop hl 
074d				;ex de, hl 
074d				if DEBUG_STORESE 
074d					DMARK "SCa" 
074d f5				push af  
074e 3a 62 07			ld a, (.dmark)  
0751 32 6b ee			ld (debug_mark),a  
0754 3a 63 07			ld a, (.dmark+1)  
0757 32 6c ee			ld (debug_mark+1),a  
075a 3a 64 07			ld a, (.dmark+2)  
075d 32 6d ee			ld (debug_mark+2),a  
0760 18 03			jr .pastdmark  
0762 ..			.dmark: db "SCa"  
0765 f1			.pastdmark: pop af  
0766			endm  
# End of macro DMARK
0766					;push af 
0766					;ld a, 'a' 
0766					;ld (debug_mark),a 
0766					;pop af 
0766					CALLMONITOR 
0766 cd 6f ee			call debug_vector  
0769				endm  
# End of macro CALLMONITOR
0769				endif 
0769 ed b0			ldir    ; copy zero term string 
076b				if DEBUG_STORESE 
076b					DMARK "SCA" 
076b f5				push af  
076c 3a 80 07			ld a, (.dmark)  
076f 32 6b ee			ld (debug_mark),a  
0772 3a 81 07			ld a, (.dmark+1)  
0775 32 6c ee			ld (debug_mark+1),a  
0778 3a 82 07			ld a, (.dmark+2)  
077b 32 6d ee			ld (debug_mark+2),a  
077e 18 03			jr .pastdmark  
0780 ..			.dmark: db "SCA"  
0783 f1			.pastdmark: pop af  
0784			endm  
# End of macro DMARK
0784					CALLMONITOR 
0784 cd 6f ee			call debug_vector  
0787				endm  
# End of macro CALLMONITOR
0787				endif 
0787			 
0787				; write file header page 
0787			 
0787 2a 65 ea			ld hl,(store_tmppageid) 
078a 11 7a ea			ld de, store_page 
078d				if DEBUG_STORESE 
078d					DMARK "SCb" 
078d f5				push af  
078e 3a a2 07			ld a, (.dmark)  
0791 32 6b ee			ld (debug_mark),a  
0794 3a a3 07			ld a, (.dmark+1)  
0797 32 6c ee			ld (debug_mark+1),a  
079a 3a a4 07			ld a, (.dmark+2)  
079d 32 6d ee			ld (debug_mark+2),a  
07a0 18 03			jr .pastdmark  
07a2 ..			.dmark: db "SCb"  
07a5 f1			.pastdmark: pop af  
07a6			endm  
# End of macro DMARK
07a6					;push af 
07a6					;ld a, 'b' 
07a6					;ld (debug_mark),a 
07a6					;pop af 
07a6					CALLMONITOR 
07a6 cd 6f ee			call debug_vector  
07a9				endm  
# End of macro CALLMONITOR
07a9				endif 
07a9 cd dd 02			call storage_write_block 
07ac			 
07ac 3a 6e ea			ld a, (store_tmpid) 
07af 6f				ld l, a 
07b0 26 00			ld h,0 
07b2				if DEBUG_STORESE 
07b2					DMARK "SCz" 
07b2 f5				push af  
07b3 3a c7 07			ld a, (.dmark)  
07b6 32 6b ee			ld (debug_mark),a  
07b9 3a c8 07			ld a, (.dmark+1)  
07bc 32 6c ee			ld (debug_mark+1),a  
07bf 3a c9 07			ld a, (.dmark+2)  
07c2 32 6d ee			ld (debug_mark+2),a  
07c5 18 03			jr .pastdmark  
07c7 ..			.dmark: db "SCz"  
07ca f1			.pastdmark: pop af  
07cb			endm  
# End of macro DMARK
07cb					CALLMONITOR 
07cb cd 6f ee			call debug_vector  
07ce				endm  
# End of macro CALLMONITOR
07ce				endif 
07ce c9				ret 
07cf				 
07cf			 
07cf			 
07cf			; 
07cf			; Read File 
07cf			; 
07cf			; h - file id to locate 
07cf			; l - extent to locate 
07cf			; de - pointer to string to read into 
07cf			; 
07cf			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07cf			 
07cf			.sr_fail: 
07cf d1				pop de 
07d0 c9				ret 
07d1			 
07d1			storage_read: 
07d1			 
07d1			 
07d1 d5				push de 
07d2			 
07d2			; TODO BUG the above push is it popped before the RET Z? 
07d2			 
07d2			; TODO how to handle multiple part blocks 
07d2			 
07d2				; locate file extent to read 
07d2			 
07d2 5c				ld e, h 
07d3 55				ld d, l 
07d4			 
07d4			.srext: 
07d4 22 78 ea			ld (store_readptr), hl     ; save the current extent to load 
07d7 ed 53 76 ea		ld (store_readbuf), de     ; save the current buffer to load in to 
07db			 
07db 21 40 00			ld hl, STORE_BLOCK_PHY 
07de				if DEBUG_STORESE 
07de					DMARK "sre" 
07de f5				push af  
07df 3a f3 07			ld a, (.dmark)  
07e2 32 6b ee			ld (debug_mark),a  
07e5 3a f4 07			ld a, (.dmark+1)  
07e8 32 6c ee			ld (debug_mark+1),a  
07eb 3a f5 07			ld a, (.dmark+2)  
07ee 32 6d ee			ld (debug_mark+2),a  
07f1 18 03			jr .pastdmark  
07f3 ..			.dmark: db "sre"  
07f6 f1			.pastdmark: pop af  
07f7			endm  
# End of macro DMARK
07f7					CALLMONITOR 
07f7 cd 6f ee			call debug_vector  
07fa				endm  
# End of macro CALLMONITOR
07fa				endif 
07fa cd ab 05			call storage_findnextid 
07fd			 
07fd				if DEBUG_STORESE 
07fd					DMARK "srf" 
07fd f5				push af  
07fe 3a 12 08			ld a, (.dmark)  
0801 32 6b ee			ld (debug_mark),a  
0804 3a 13 08			ld a, (.dmark+1)  
0807 32 6c ee			ld (debug_mark+1),a  
080a 3a 14 08			ld a, (.dmark+2)  
080d 32 6d ee			ld (debug_mark+2),a  
0810 18 03			jr .pastdmark  
0812 ..			.dmark: db "srf"  
0815 f1			.pastdmark: pop af  
0816			endm  
# End of macro DMARK
0816					CALLMONITOR 
0816 cd 6f ee			call debug_vector  
0819				endm  
# End of macro CALLMONITOR
0819				endif 
0819 cd 0f 0e			call ishlzero 
081c			;	ld a, l 
081c			;	add h 
081c			;	cp 0 
081c 28 b1			jr z,.sr_fail			; block not found so EOF 
081e			 
081e				; save current address for use by higher level words etc 
081e			 
081e 22 6b ea			ld (store_openaddr),hl 
0821			 
0821			 
0821				; hl contains page number to load 
0821 d1				pop de   ; get storage 
0822 ed 53 76 ea		ld (store_readbuf), de     ; current buffer to load in to 
0826 d5				push de 
0827				if DEBUG_STORESE 
0827					DMARK "srg" 
0827 f5				push af  
0828 3a 3c 08			ld a, (.dmark)  
082b 32 6b ee			ld (debug_mark),a  
082e 3a 3d 08			ld a, (.dmark+1)  
0831 32 6c ee			ld (debug_mark+1),a  
0834 3a 3e 08			ld a, (.dmark+2)  
0837 32 6d ee			ld (debug_mark+2),a  
083a 18 03			jr .pastdmark  
083c ..			.dmark: db "srg"  
083f f1			.pastdmark: pop af  
0840			endm  
# End of macro DMARK
0840					CALLMONITOR 
0840 cd 6f ee			call debug_vector  
0843				endm  
# End of macro CALLMONITOR
0843				endif 
0843 cd 78 02			call storage_read_block 
0846			 
0846				; if this a continuation read??? 
0846			 
0846 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
0849			 
0849 3e 3f			ld a, STORE_BLOCK_PHY-1 
084b cd e6 0d			call addatohl 
084e 7e				ld a,(hl) 
084f fe 00			cp 0 
0851 28 02			jr z, .markiscont 
0853 3e ff			ld a, 255 
0855			 
0855			.markiscont: 
0855 32 6d ea			ld (store_readcont), a 
0858			 
0858				if DEBUG_STORESE 
0858					DMARK "srC" 
0858 f5				push af  
0859 3a 6d 08			ld a, (.dmark)  
085c 32 6b ee			ld (debug_mark),a  
085f 3a 6e 08			ld a, (.dmark+1)  
0862 32 6c ee			ld (debug_mark+1),a  
0865 3a 6f 08			ld a, (.dmark+2)  
0868 32 6d ee			ld (debug_mark+2),a  
086b 18 03			jr .pastdmark  
086d ..			.dmark: db "srC"  
0870 f1			.pastdmark: pop af  
0871			endm  
# End of macro DMARK
0871					CALLMONITOR 
0871 cd 6f ee			call debug_vector  
0874				endm  
# End of macro CALLMONITOR
0874				endif 
0874				; only short reads enabled 
0874			 
0874 3a 75 ea			ld a, (store_longread) 
0877 fe 00			cp 0 
0879 ca 46 09			jp z, .readdone 
087c			 
087c			; TODO if block has no zeros then need to read next block  
087c			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
087c			; check last byte of physical block. 
087c			; if not zero then the next block needs to be loaded 
087c			 
087c			 
087c 2a 76 ea			ld hl, (store_readbuf)     ; current buffer to load in to 
087f			 
087f 3e 3f			ld a, STORE_BLOCK_PHY-1 
0881 cd e6 0d			call addatohl 
0884				;dec hl 
0884 7e				ld a,(hl) 
0885				if DEBUG_STORESE 
0885					DMARK "sr?" 
0885 f5				push af  
0886 3a 9a 08			ld a, (.dmark)  
0889 32 6b ee			ld (debug_mark),a  
088c 3a 9b 08			ld a, (.dmark+1)  
088f 32 6c ee			ld (debug_mark+1),a  
0892 3a 9c 08			ld a, (.dmark+2)  
0895 32 6d ee			ld (debug_mark+2),a  
0898 18 03			jr .pastdmark  
089a ..			.dmark: db "sr?"  
089d f1			.pastdmark: pop af  
089e			endm  
# End of macro DMARK
089e					CALLMONITOR 
089e cd 6f ee			call debug_vector  
08a1				endm  
# End of macro CALLMONITOR
08a1				endif 
08a1 fe 00			cp 0 
08a3 ca 46 09			jp z, .readdone 
08a6			 
08a6				; last byte is not zero so there is more in the next extent. Load it on the end.	 
08a6			 
08a6 23				inc hl 
08a7			 
08a7 22 76 ea			ld (store_readbuf), hl     ; save the current buffer to load in to 
08aa			 
08aa ed 5b 78 ea		ld de, (store_readptr)     ; save the current extent to load 
08ae			 
08ae eb				ex de, hl 
08af			 
08af				; next ext 
08af			 
08af 23				inc hl 
08b0 22 78 ea			ld  (store_readptr), hl     ; save the current extent to load 
08b3			 
08b3				if DEBUG_STORESE 
08b3					DMARK "sF2" 
08b3 f5				push af  
08b4 3a c8 08			ld a, (.dmark)  
08b7 32 6b ee			ld (debug_mark),a  
08ba 3a c9 08			ld a, (.dmark+1)  
08bd 32 6c ee			ld (debug_mark+1),a  
08c0 3a ca 08			ld a, (.dmark+2)  
08c3 32 6d ee			ld (debug_mark+2),a  
08c6 18 03			jr .pastdmark  
08c8 ..			.dmark: db "sF2"  
08cb f1			.pastdmark: pop af  
08cc			endm  
# End of macro DMARK
08cc					CALLMONITOR 
08cc cd 6f ee			call debug_vector  
08cf				endm  
# End of macro CALLMONITOR
08cf				endif 
08cf			 
08cf				; get and load block 
08cf			 
08cf cd ab 05			call storage_findnextid 
08d2			 
08d2				if DEBUG_STORESE 
08d2					DMARK "sf2" 
08d2 f5				push af  
08d3 3a e7 08			ld a, (.dmark)  
08d6 32 6b ee			ld (debug_mark),a  
08d9 3a e8 08			ld a, (.dmark+1)  
08dc 32 6c ee			ld (debug_mark+1),a  
08df 3a e9 08			ld a, (.dmark+2)  
08e2 32 6d ee			ld (debug_mark+2),a  
08e5 18 03			jr .pastdmark  
08e7 ..			.dmark: db "sf2"  
08ea f1			.pastdmark: pop af  
08eb			endm  
# End of macro DMARK
08eb					CALLMONITOR 
08eb cd 6f ee			call debug_vector  
08ee				endm  
# End of macro CALLMONITOR
08ee				endif 
08ee cd 0f 0e			call ishlzero 
08f1			;	ld a, l 
08f1			;	add h 
08f1			;	cp 0 
08f1 ca cf 07			jp z,.sr_fail			; block not found so EOF 
08f4				 
08f4				; save current address for use by higher level words etc 
08f4			 
08f4 22 6b ea			ld (store_openaddr),hl 
08f7			 
08f7 cd 78 02			call storage_read_block 
08fa			 
08fa				; on a continuation block, we now have the file id and ext in the middle of the block 
08fa				; we need to pull everything back  
08fa			 
08fa ed 5b 76 ea		ld de, (store_readbuf)     ; current buffer to nudge into 
08fe 2a 76 ea			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0901 23				inc hl 
0902 23				inc hl     ; skip id and ext 
0903 01 40 00			ld bc, STORE_BLOCK_PHY 
0906				if DEBUG_STORESE 
0906					DMARK "SR<" 
0906 f5				push af  
0907 3a 1b 09			ld a, (.dmark)  
090a 32 6b ee			ld (debug_mark),a  
090d 3a 1c 09			ld a, (.dmark+1)  
0910 32 6c ee			ld (debug_mark+1),a  
0913 3a 1d 09			ld a, (.dmark+2)  
0916 32 6d ee			ld (debug_mark+2),a  
0919 18 03			jr .pastdmark  
091b ..			.dmark: db "SR<"  
091e f1			.pastdmark: pop af  
091f			endm  
# End of macro DMARK
091f					CALLMONITOR 
091f cd 6f ee			call debug_vector  
0922				endm  
# End of macro CALLMONITOR
0922				endif 
0922 ed b0			ldir     ; copy data 
0924			 
0924				; move the pointer back and pretend we have a full buffer for next recheck 
0924			 
0924 1b				dec de 
0925 1b				dec de 
0926			 
0926			; TODO do pop below now short circuit loop????? 
0926 c1				pop bc     ; get rid of spare de on stack 
0927				if DEBUG_STORESE 
0927					DMARK "SR>" 
0927 f5				push af  
0928 3a 3c 09			ld a, (.dmark)  
092b 32 6b ee			ld (debug_mark),a  
092e 3a 3d 09			ld a, (.dmark+1)  
0931 32 6c ee			ld (debug_mark+1),a  
0934 3a 3e 09			ld a, (.dmark+2)  
0937 32 6d ee			ld (debug_mark+2),a  
093a 18 03			jr .pastdmark  
093c ..			.dmark: db "SR>"  
093f f1			.pastdmark: pop af  
0940			endm  
# End of macro DMARK
0940					CALLMONITOR 
0940 cd 6f ee			call debug_vector  
0943				endm  
# End of macro CALLMONITOR
0943				endif 
0943 c3 d4 07			jp .srext 
0946			 
0946			 
0946			 
0946			 
0946			 
0946			.readdone:		 
0946 e1				pop hl 		 ; return start of data to show as not EOF 
0947 23				inc hl   ; past file id 
0948 23				inc hl   ; past ext 
0949				if DEBUG_STORESE 
0949					DMARK "SRe" 
0949 f5				push af  
094a 3a 5e 09			ld a, (.dmark)  
094d 32 6b ee			ld (debug_mark),a  
0950 3a 5f 09			ld a, (.dmark+1)  
0953 32 6c ee			ld (debug_mark+1),a  
0956 3a 60 09			ld a, (.dmark+2)  
0959 32 6d ee			ld (debug_mark+2),a  
095c 18 03			jr .pastdmark  
095e ..			.dmark: db "SRe"  
0961 f1			.pastdmark: pop af  
0962			endm  
# End of macro DMARK
0962					CALLMONITOR 
0962 cd 6f ee			call debug_vector  
0965				endm  
# End of macro CALLMONITOR
0965				endif 
0965 c9					ret 
0966			 
0966			 
0966			 
0966			; 
0966			; Append File 
0966			; 
0966			; hl - file id to locate 
0966			; de - pointer to (multi block) string to write 
0966			 
0966			.sa_notfound: 
0966 d1				pop de 
0967 c9				ret 
0968			 
0968			 
0968			storage_append: 
0968				; hl -  file id to append to 
0968				; de - string to append 
0968			 
0968 d5				push de 
0969				 
0969				if DEBUG_STORESE 
0969					DMARK "AP1" 
0969 f5				push af  
096a 3a 7e 09			ld a, (.dmark)  
096d 32 6b ee			ld (debug_mark),a  
0970 3a 7f 09			ld a, (.dmark+1)  
0973 32 6c ee			ld (debug_mark+1),a  
0976 3a 80 09			ld a, (.dmark+2)  
0979 32 6d ee			ld (debug_mark+2),a  
097c 18 03			jr .pastdmark  
097e ..			.dmark: db "AP1"  
0981 f1			.pastdmark: pop af  
0982			endm  
# End of macro DMARK
0982					CALLMONITOR 
0982 cd 6f ee			call debug_vector  
0985				endm  
# End of macro CALLMONITOR
0985				endif 
0985			 
0985 7d				ld a, l 
0986 32 6e ea			ld (store_tmpid), a 
0989			 
0989				; get file header  
0989			 
0989 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
098b 3a 6e ea			ld a, (store_tmpid) 
098e 5f				ld e, a 
098f			 
098f 21 40 00				ld hl, STORE_BLOCK_PHY 
0992 cd ab 05				call storage_findnextid 
0995			 
0995 cd 0f 0e			call ishlzero 
0998 28 cc			jr z, .sa_notfound 
099a			 
099a 22 65 ea			ld (store_tmppageid), hl 
099d			 
099d				; TODO handle file id not found 
099d			 
099d				if DEBUG_STORESE 
099d					DMARK "AP2" 
099d f5				push af  
099e 3a b2 09			ld a, (.dmark)  
09a1 32 6b ee			ld (debug_mark),a  
09a4 3a b3 09			ld a, (.dmark+1)  
09a7 32 6c ee			ld (debug_mark+1),a  
09aa 3a b4 09			ld a, (.dmark+2)  
09ad 32 6d ee			ld (debug_mark+2),a  
09b0 18 03			jr .pastdmark  
09b2 ..			.dmark: db "AP2"  
09b5 f1			.pastdmark: pop af  
09b6			endm  
# End of macro DMARK
09b6					CALLMONITOR 
09b6 cd 6f ee			call debug_vector  
09b9				endm  
# End of macro CALLMONITOR
09b9				endif 
09b9			 
09b9				; update file extent count 
09b9			 
09b9 11 7a ea			ld de, store_page 
09bc			 
09bc cd 78 02			call storage_read_block 
09bf			 
09bf				if DEBUG_STORESE 
09bf					DMARK "AP3" 
09bf f5				push af  
09c0 3a d4 09			ld a, (.dmark)  
09c3 32 6b ee			ld (debug_mark),a  
09c6 3a d5 09			ld a, (.dmark+1)  
09c9 32 6c ee			ld (debug_mark+1),a  
09cc 3a d6 09			ld a, (.dmark+2)  
09cf 32 6d ee			ld (debug_mark+2),a  
09d2 18 03			jr .pastdmark  
09d4 ..			.dmark: db "AP3"  
09d7 f1			.pastdmark: pop af  
09d8			endm  
# End of macro DMARK
09d8					CALLMONITOR 
09d8 cd 6f ee			call debug_vector  
09db				endm  
# End of macro CALLMONITOR
09db				endif 
09db			;	ld (store_tmppageid), hl 
09db			 
09db 3a 7c ea			ld a, (store_page+2) 
09de 3c				inc a 
09df 32 7c ea			ld (store_page+2), a 
09e2 32 6d ea			ld (store_tmpext), a 
09e5				 
09e5				if DEBUG_STORESE 
09e5					DMARK "AP3" 
09e5 f5				push af  
09e6 3a fa 09			ld a, (.dmark)  
09e9 32 6b ee			ld (debug_mark),a  
09ec 3a fb 09			ld a, (.dmark+1)  
09ef 32 6c ee			ld (debug_mark+1),a  
09f2 3a fc 09			ld a, (.dmark+2)  
09f5 32 6d ee			ld (debug_mark+2),a  
09f8 18 03			jr .pastdmark  
09fa ..			.dmark: db "AP3"  
09fd f1			.pastdmark: pop af  
09fe			endm  
# End of macro DMARK
09fe					CALLMONITOR 
09fe cd 6f ee			call debug_vector  
0a01				endm  
# End of macro CALLMONITOR
0a01				endif 
0a01 2a 65 ea			ld hl, (store_tmppageid) 
0a04 11 7a ea			ld de, store_page 
0a07 cd dd 02			call storage_write_block 
0a0a			 
0a0a				; find free block 
0a0a			 
0a0a 11 00 00			ld de, 0			 ; file extent to locate 
0a0d			 
0a0d 21 40 00				ld hl, STORE_BLOCK_PHY 
0a10 cd ab 05				call storage_findnextid 
0a13 cd 0f 0e			call ishlzero 
0a16 ca 66 09			jp z, .sa_notfound 
0a19			 
0a19					; TODO handle no space left 
0a19					 
0a19 22 65 ea				ld (store_tmppageid), hl 
0a1c			 
0a1c				if DEBUG_STORESE 
0a1c					DMARK "AP4" 
0a1c f5				push af  
0a1d 3a 31 0a			ld a, (.dmark)  
0a20 32 6b ee			ld (debug_mark),a  
0a23 3a 32 0a			ld a, (.dmark+1)  
0a26 32 6c ee			ld (debug_mark+1),a  
0a29 3a 33 0a			ld a, (.dmark+2)  
0a2c 32 6d ee			ld (debug_mark+2),a  
0a2f 18 03			jr .pastdmark  
0a31 ..			.dmark: db "AP4"  
0a34 f1			.pastdmark: pop af  
0a35			endm  
# End of macro DMARK
0a35					CALLMONITOR 
0a35 cd 6f ee			call debug_vector  
0a38				endm  
# End of macro CALLMONITOR
0a38				endif 
0a38					; init the buffer with zeros so we can id if the buffer is full or not 
0a38			 
0a38 e5					push hl 
0a39 c5					push bc 
0a3a			 
0a3a 21 7a ea				ld hl, store_page 
0a3d 06 40				ld b, STORE_BLOCK_PHY 
0a3f 3e 00				ld a, 0 
0a41 77			.zeroblock:	ld (hl), a 
0a42 23					inc hl 
0a43 10 fc				djnz .zeroblock 
0a45			 
0a45 c1					pop bc 
0a46 e1					pop hl 
0a47			 
0a47					; construct block 
0a47			 
0a47 3a 6e ea				ld a, (store_tmpid) 
0a4a 32 7a ea				ld (store_page), a   ; file id 
0a4d 3a 6d ea				ld a, (store_tmpext)   ; extent for this block 
0a50 32 7b ea				ld (store_page+1), a 
0a53			 
0a53 e1					pop hl    ; get string to write 
0a54 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0a56 11 7c ea				ld de, store_page+2 
0a59			 
0a59				if DEBUG_STORESE 
0a59					DMARK "AP5" 
0a59 f5				push af  
0a5a 3a 6e 0a			ld a, (.dmark)  
0a5d 32 6b ee			ld (debug_mark),a  
0a60 3a 6f 0a			ld a, (.dmark+1)  
0a63 32 6c ee			ld (debug_mark+1),a  
0a66 3a 70 0a			ld a, (.dmark+2)  
0a69 32 6d ee			ld (debug_mark+2),a  
0a6c 18 03			jr .pastdmark  
0a6e ..			.dmark: db "AP5"  
0a71 f1			.pastdmark: pop af  
0a72			endm  
# End of macro DMARK
0a72					CALLMONITOR 
0a72 cd 6f ee			call debug_vector  
0a75				endm  
# End of macro CALLMONITOR
0a75				endif 
0a75			 
0a75			 
0a75			 
0a75					; fill buffer with data until end of string or full block 
0a75			 
0a75 7e			.appd:		ld a, (hl) 
0a76 12					ld (de), a 
0a77 fe 00				cp 0 
0a79 28 04				jr z, .appdone 
0a7b 23					inc hl 
0a7c 13					inc de 
0a7d 10 f6				djnz .appd 
0a7f			 
0a7f e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0a80 f5					push af   		; save last byte dumped 
0a81			 
0a81			 
0a81 2a 65 ea			ld hl, (store_tmppageid) 
0a84 11 7a ea			ld de, store_page 
0a87				if DEBUG_STORESE 
0a87					DMARK "AP6" 
0a87 f5				push af  
0a88 3a 9c 0a			ld a, (.dmark)  
0a8b 32 6b ee			ld (debug_mark),a  
0a8e 3a 9d 0a			ld a, (.dmark+1)  
0a91 32 6c ee			ld (debug_mark+1),a  
0a94 3a 9e 0a			ld a, (.dmark+2)  
0a97 32 6d ee			ld (debug_mark+2),a  
0a9a 18 03			jr .pastdmark  
0a9c ..			.dmark: db "AP6"  
0a9f f1			.pastdmark: pop af  
0aa0			endm  
# End of macro DMARK
0aa0					CALLMONITOR 
0aa0 cd 6f ee			call debug_vector  
0aa3				endm  
# End of macro CALLMONITOR
0aa3				endif 
0aa3 cd dd 02				call storage_write_block 
0aa6			 
0aa6			 
0aa6				; was that a full block of data written? 
0aa6				; any more to write out? 
0aa6			 
0aa6				; if yes then set vars and jump to start of function again 
0aa6			 
0aa6 f1					pop af 
0aa7 d1					pop de 
0aa8			 
0aa8 fe 00				cp 0		 ; no, string was fully written 
0aaa c8					ret z 
0aab			 
0aab					; setup vars for next cycle 
0aab			 
0aab 3a 6e ea				ld a, (store_tmpid) 
0aae 6f					ld l, a 
0aaf 26 00				ld h, 0 
0ab1			 
0ab1 c3 68 09			 	jp storage_append	 ; yes, need to write out some more 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			 
0ab4			if DEBUG_STORECF 
0ab4			storageput:	 
0ab4					ret 
0ab4			storageread: 
0ab4					ld hl, store_page 
0ab4					ld b, 200 
0ab4					ld a,0 
0ab4			.src:		ld (hl),a 
0ab4					inc hl 
0ab4					djnz .src 
0ab4					 
0ab4			 
0ab4					ld de, 0 
0ab4					ld bc, 1 
0ab4					ld hl, store_page 
0ab4					call cfRead 
0ab4			 
0ab4				call cfGetError 
0ab4				ld hl,scratch 
0ab4				call hexout 
0ab4				ld hl, scratch+2 
0ab4				ld a, 0 
0ab4				ld (hl),a 
0ab4				ld de, scratch 
0ab4				ld a,display_row_1 
0ab4				call str_at_display 
0ab4				call update_display 
0ab4			 
0ab4					ld hl, store_page 
0ab4					ld (os_cur_ptr),hl 
0ab4			 
0ab4					ret 
0ab4			endif 
0ab4			 
0ab4			 
0ab4			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ab4			 
0ab4			storage_clear_page: 
0ab4 e5				push hl 
0ab5 d5				push de 
0ab6 c5				push bc 
0ab7 21 7a ea			ld hl, store_page 
0aba 3e 00			ld a, 0 
0abc 77				ld (hl), a 
0abd			 
0abd 11 7b ea			ld de, store_page+1 
0ac0 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0ac3			 
0ac3 ed b0			ldir 
0ac5				 
0ac5 c1				pop bc 
0ac6 d1				pop de 
0ac7 e1				pop hl 
0ac8 c9				ret 
0ac9			 
0ac9			; eof 
# End of file firmware_storage.asm
0ac9			  
0ac9			; support routines for above hardware abstraction layer  
0ac9			  
0ac9			include "firmware_general.asm"        ; general support functions  
0ac9			 
0ac9			; word look up 
0ac9			 
0ac9			; in 
0ac9			; a is the index 
0ac9			; hl is pointer start of array 
0ac9			; 
0ac9			; returns 
0ac9			; hl to the word 
0ac9			; 
0ac9			 
0ac9			table_lookup:  
0ac9 d5					push de 
0aca eb					ex de, hl 
0acb			 
0acb 6f					ld l, a 
0acc 26 00				ld h, 0 
0ace 29					add hl, hl 
0acf 19					add hl, de 
0ad0 7e					ld a, (hl) 
0ad1 23					inc hl 
0ad2 66					ld h,(hl) 
0ad3 6f					ld l, a 
0ad4			 
0ad4 d1					pop de 
0ad5 c9					ret 
0ad6			 
0ad6			; Delay loops 
0ad6			 
0ad6			 
0ad6			 
0ad6			aDelayInMS: 
0ad6 c5				push bc 
0ad7 47				ld b,a 
0ad8			msdelay: 
0ad8 c5				push bc 
0ad9				 
0ad9			 
0ad9 01 41 00			ld bc,041h 
0adc cd f4 0a			call delayloop 
0adf c1				pop bc 
0ae0 05				dec b 
0ae1 20 f5			jr nz,msdelay 
0ae3			 
0ae3			;if CPU_CLOCK_8MHZ 
0ae3			;msdelay8: 
0ae3			;	push bc 
0ae3			;	 
0ae3			; 
0ae3			;	ld bc,041h 
0ae3			;	call delayloop 
0ae3			;	pop bc 
0ae3			;	dec b 
0ae3			;	jr nz,msdelay8 
0ae3			;endif 
0ae3			 
0ae3			 
0ae3 c1				pop bc 
0ae4 c9				ret 
0ae5			 
0ae5			 
0ae5			delay250ms: 
0ae5				;push de 
0ae5 01 00 40			ld bc, 04000h 
0ae8 c3 f4 0a			jp delayloop 
0aeb			delay500ms: 
0aeb				;push de 
0aeb 01 00 80			ld bc, 08000h 
0aee c3 f4 0a			jp delayloop 
0af1			delay1s: 
0af1				;push bc 
0af1			   ; Clobbers A, d and e 
0af1 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0af4			delayloop: 
0af4 c5			    push bc 
0af5			 
0af5			if BASE_CPM 
0af5 01 a0 0f			ld bc, CPM_DELAY_TUNE 
0af8			.cpmloop: 
0af8 c5				push bc 
0af9			 
0af9			endif 
0af9			 
0af9			 
0af9			 
0af9			delayloopi: 
0af9			;	push bc 
0af9			;.dl: 
0af9 cb 47		    bit     0,a    	; 8 
0afb cb 47		    bit     0,a    	; 8 
0afd cb 47		    bit     0,a    	; 8 
0aff e6 ff		    and     255  	; 7 
0b01 0b			    dec     bc      	; 6 
0b02 79			    ld      a,c     	; 4 
0b03 b0			    or      b     	; 4 
0b04 c2 f9 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0b07			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0b07				;pop de 
0b07			;pop bc 
0b07			 
0b07			if BASE_CPM 
0b07 c1				pop bc 
0b08				 
0b08 0b			    dec     bc      	; 6 
0b09 79			    ld      a,c     	; 4 
0b0a b0			    or      b     	; 4 
0b0b c2 f8 0a		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0b0e				 
0b0e			 
0b0e			endif 
0b0e			;if CPU_CLOCK_8MHZ 
0b0e			;    pop bc 
0b0e			;    push bc 
0b0e			;.dl8: 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    and     255  	; 7 
0b0e			;    dec     bc      	; 6 
0b0e			;    ld      a,c     	; 4 
0b0e			;    or      b     	; 4 
0b0e			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0e			;endif 
0b0e			 
0b0e			;if CPU_CLOCK_10MHZ 
0b0e			;    pop bc 
0b0e			;    push bc 
0b0e			;.dl8: 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    bit     0,a    	; 8 
0b0e			;    and     255  	; 7 
0b0e			;    dec     bc      	; 6 
0b0e			;    ld      a,c     	; 4 
0b0e			;    or      b     	; 4 
0b0e			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0b0e			;endif 
0b0e c1			    pop bc 
0b0f			 
0b0f c9				ret 
0b10			 
0b10			 
0b10			 
0b10			; eof 
# End of file firmware_general.asm
0b10			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0b10			; display routines that use the physical hardware abstraction layer 
0b10			 
0b10			 
0b10			; Display an activity indicator 
0b10			; Each call returns the new char pointed to in hl 
0b10			 
0b10			active: 
0b10 3a c6 eb			ld a, (display_active) 
0b13 fe 06			cp 6 
0b15			 
0b15 20 02			jr nz, .sne 
0b17				; gone past the last one reset sequence 
0b17 3e ff			ld a, 255 
0b19			 
0b19			.sne:   
0b19				; get the next char in seq 
0b19 3c				inc a 
0b1a 32 c6 eb			ld (display_active), a 
0b1d			 
0b1d				; look up the string in the table 
0b1d 21 34 0b			ld hl, actseq 
0b20 cb 27			sla a 
0b22 cd e6 0d			call addatohl 
0b25 cd aa 1e			call loadwordinhl 
0b28			 
0b28				; forth will write the to string when pushing so move from rom to ram 
0b28			 
0b28 11 c7 eb			ld de, display_active+1 
0b2b 01 02 00			ld bc, 2 
0b2e ed b0			ldir 
0b30			 
0b30 21 c7 eb			ld hl, display_active+1 
0b33 c9				ret 
0b34				 
0b34				 
0b34			 
0b34			 
0b34			;db "|/-\|-\" 
0b34			 
0b34			actseq: 
0b34			 
0b34 42 0b		dw spin0 
0b36 44 0b		dw spin1 
0b38 46 0b		dw spin2 
0b3a 48 0b		dw spin3 
0b3c 46 0b		dw spin2 
0b3e 44 0b		dw spin1 
0b40 42 0b		dw spin0 
0b42			 
0b42 .. 00		spin0: db " ", 0 
0b44 .. 00		spin1: db "-", 0 
0b46 .. 00		spin2: db "+", 0 
0b48 .. 00		spin3: db "#", 0 
0b4a			 
0b4a			 
0b4a			; information window 
0b4a			 
0b4a			; pass hl with 1st string to display 
0b4a			; pass de with 2nd string to display 
0b4a			 
0b4a			info_panel: 
0b4a e5				push hl 
0b4b			 
0b4b 2a cc eb			ld hl, (display_fb_active) 
0b4e e5				push hl    ; future de destination 
0b4f 21 b1 ed				ld hl, display_fb0 
0b52 22 cc eb				ld (display_fb_active), hl 
0b55			 
0b55			;	call clear_display 
0b55			 
0b55				if BASE_CPM 
0b55 3e 2e			ld a, '.' 
0b57				else 
0b57				ld a, 165 
0b57				endif 
0b57 cd be 0b			call fill_display 
0b5a			 
0b5a			 
0b5a 3e 55			ld a, display_row_3 + 5 
0b5c cd cc 0b			call str_at_display 
0b5f			 
0b5f e1				pop hl 
0b60 d1				pop de 
0b61			 
0b61 e5				push hl 
0b62			 
0b62			 
0b62 3e 2d			ld a, display_row_2 + 5 
0b64 cd cc 0b			call str_at_display 
0b67			 
0b67			 
0b67 cd dc 0b			call update_display 
0b6a cd e5 1a			call next_page_prompt 
0b6d cd b9 0b			call clear_display 
0b70			 
0b70				 
0b70 21 10 ed				ld hl, display_fb1 
0b73 22 cc eb				ld (display_fb_active), hl 
0b76 cd dc 0b			call update_display 
0b79			 
0b79 e1				pop hl 
0b7a			 
0b7a c9				ret 
0b7b			 
0b7b			 
0b7b			 
0b7b			 
0b7b			; TODO windowing? 
0b7b			 
0b7b			; TODO scroll line up 
0b7b			 
0b7b			scroll_up: 
0b7b			 
0b7b e5				push hl 
0b7c d5				push de 
0b7d c5				push bc 
0b7e			 
0b7e				; get frame buffer  
0b7e			 
0b7e 2a cc eb			ld hl, (display_fb_active) 
0b81 e5				push hl    ; future de destination 
0b82			 
0b82 11 28 00			ld  de, display_cols 
0b85 19				add hl, de 
0b86			 
0b86 d1				pop de 
0b87			 
0b87				;ex de, hl 
0b87 01 9f 00			ld bc, display_fb_len -1  
0b8a			;if DEBUG_FORTH_WORDS 
0b8a			;	DMARK "SCL" 
0b8a			;	CALLMONITOR 
0b8a			;endif	 
0b8a ed b0			ldir 
0b8c			 
0b8c				; wipe bottom row 
0b8c			 
0b8c			 
0b8c 2a cc eb			ld hl, (display_fb_active) 
0b8f 11 a0 00			ld de, display_cols*display_rows 
0b92 19				add hl, de 
0b93 06 28			ld b, display_cols 
0b95 3e 20			ld a, ' ' 
0b97			.scwipe: 
0b97 77				ld (hl), a 
0b98 2b				dec hl 
0b99 10 fc			djnz .scwipe 
0b9b			 
0b9b				;pop hl 
0b9b			 
0b9b c1				pop bc 
0b9c d1				pop de 
0b9d e1				pop hl 
0b9e			 
0b9e c9				ret 
0b9f			 
0b9f			 
0b9f			;scroll_upo: 
0b9f			;	ld de, display_row_1 
0b9f			 ;	ld hl, display_row_2 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			;	ld de, display_row_2 
0b9f			 ;	ld hl, display_row_3 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			;	ld de, display_row_3 
0b9f			 ;	ld hl, display_row_4 
0b9f			;	ld bc, display_cols 
0b9f			;	ldir 
0b9f			 
0b9f			; TODO clear row 4 
0b9f			 
0b9f			;	ret 
0b9f			 
0b9f				 
0b9f			scroll_down: 
0b9f			 
0b9f e5				push hl 
0ba0 d5				push de 
0ba1 c5				push bc 
0ba2			 
0ba2				; get frame buffer  
0ba2			 
0ba2 2a cc eb			ld hl, (display_fb_active) 
0ba5			 
0ba5 11 9f 00			ld de, display_fb_len - 1 
0ba8 19				add hl, de 
0ba9			 
0ba9 e5			push hl    ; future de destination 
0baa			 
0baa 11 28 00			ld  de, display_cols 
0bad ed 52			sbc hl, de 
0baf			 
0baf			 
0baf d1				pop de 
0bb0			 
0bb0			;	ex de, hl 
0bb0 01 9f 00			ld bc, display_fb_len -1  
0bb3			 
0bb3			 
0bb3				 
0bb3			 
0bb3 ed b0			ldir 
0bb5			 
0bb5				; wipe bottom row 
0bb5			 
0bb5			 
0bb5			;	ld hl, (display_fb_active) 
0bb5			;;	ld de, display_cols*display_rows 
0bb5			;;	add hl, de 
0bb5			;	ld b, display_cols 
0bb5			;	ld a, ' ' 
0bb5			;.scwiped: 
0bb5			;	ld (hl), a 
0bb5			;	dec hl 
0bb5			;	djnz .scwiped 
0bb5			 
0bb5				;pop hl 
0bb5			 
0bb5 c1				pop bc 
0bb6 d1				pop de 
0bb7 e1				pop hl 
0bb8			 
0bb8 c9				ret 
0bb9			;scroll_down: 
0bb9			;	ld de, display_row_4 
0bb9			;	ld hl, display_row_3 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;	ld de, display_row_3 
0bb9			; 	ld hl, display_row_2 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;	ld de, display_row_2 
0bb9			;	ld hl, display_row_1 
0bb9			;	ld bc, display_cols 
0bb9			;	ldir 
0bb9			;;; TODO clear row 1 
0bb9			;	ret 
0bb9			 
0bb9			 
0bb9			 
0bb9			 
0bb9			 
0bb9			; clear active frame buffer 
0bb9			 
0bb9			clear_display: 
0bb9 3e 20			ld a, ' ' 
0bbb c3 be 0b			jp fill_display 
0bbe			 
0bbe			; fill active frame buffer with a char in A 
0bbe			 
0bbe			fill_display: 
0bbe 06 a0			ld b,display_fb_len 
0bc0 2a cc eb			ld hl, (display_fb_active) 
0bc3 77			.fd1:	ld (hl),a 
0bc4 23				inc hl 
0bc5 10 fc			djnz .fd1 
0bc7 23				inc hl 
0bc8 3e 00			ld a,0 
0bca 77				ld (hl),a 
0bcb			 
0bcb			 
0bcb c9				ret 
0bcc			; Write string (DE) at pos (A) to active frame buffer 
0bcc			 
0bcc 2a cc eb		str_at_display:    ld hl,(display_fb_active) 
0bcf 06 00					ld b,0 
0bd1 4f					ld c,a 
0bd2 09					add hl,bc 
0bd3 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0bd4 b7			            OR   A              ;Null terminator? 
0bd5 c8			            RET  Z              ;Yes, so finished 
0bd6 77					ld (hl),a 
0bd7 23				inc hl 
0bd8 13			            INC  DE             ;Point to next character 
0bd9 18 f8		            JR   .sad1     ;Repeat 
0bdb c9					ret 
0bdc			 
0bdc			; using current frame buffer write to physical display 
0bdc			 
0bdc			update_display: 
0bdc e5				push hl 
0bdd 2a cc eb			ld hl, (display_fb_active) 
0be0 cd a1 5d			call write_display 
0be3 e1				pop hl 
0be4 c9				ret 
0be5			 
0be5			; TODO scrolling 
0be5			 
0be5			 
0be5			; move cursor right one char 
0be5			cursor_right: 
0be5			 
0be5				; TODO shift right 
0be5				; TODO if beyond max col 
0be5				; TODO       cursor_next_line 
0be5			 
0be5 c9				ret 
0be6			 
0be6			 
0be6			cursor_next_line: 
0be6				; TODO first char 
0be6				; TODO line down 
0be6				; TODO if past last row 
0be6				; TODO    scroll up 
0be6			 
0be6 c9				ret 
0be7			 
0be7			cursor_left: 
0be7				; TODO shift left 
0be7				; TODO if beyond left  
0be7				; TODO     cursor prev line 
0be7				 
0be7 c9				ret 
0be8			 
0be8			cursor_prev_line: 
0be8				; TODO last char 
0be8				; TODO line up 
0be8				; TODO if past first row 
0be8				; TODO   scroll down 
0be8			 
0be8 c9				ret 
0be9			 
0be9			 
0be9			cout: 
0be9				; A - char 
0be9 c9				ret 
0bea			 
0bea			 
0bea			; Display a menu and allow item selection (optional toggle items) 
0bea			; 
0bea			; format: 
0bea			; hl pointer to word array with zero term for items 
0bea			; e.g.    db item1 
0bea			;         db .... 
0bea			;         db 0 
0bea			; 
0bea			; a = starting menu item  
0bea			; 
0bea			; de = pointer item toggle array   (todo) 
0bea			; 
0bea			; returns item selected in a 1-... 
0bea			; returns 0 if back button pressed 
0bea			; 
0bea			; NOTE: Uses system frame buffer to display 
0bea			; 
0bea			; LEFT, Q = go back 
0bea			; RIGHT, SPACE, CR = select 
0bea			; UP, A - Up 
0bea			; DOWN, Z - Down 
0bea			 
0bea			 
0bea			 
0bea			 
0bea			 
0bea			menu: 
0bea			 
0bea					; keep array pointer 
0bea			 
0bea 22 73 ea				ld (store_tmp1), hl 
0bed 32 71 ea				ld (store_tmp2), a 
0bf0			 
0bf0					; check for key bounce 
0bf0			 
0bf0			if BASE_KEV 
0bf0			 
0bf0			.mbounce:	call cin 
0bf0					cp 0 
0bf0					jr nz, .mbounce 
0bf0			endif 
0bf0					; for ease use ex 
0bf0			 
0bf0					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0bf0 21 b1 ed				ld hl, display_fb0 
0bf3 22 cc eb				ld (display_fb_active), hl 
0bf6			 
0bf6 cd b9 0b		.mloop:		call clear_display 
0bf9 cd dc 0b				call update_display 
0bfc			 
0bfc					; draw selection id '>' at 1 
0bfc			 
0bfc					; init start of list display 
0bfc			 
0bfc 3e 05				ld a, 5 
0bfe 32 6f ea				ld (store_tmp3), a   ; display row count 
0c01 3a 71 ea				ld a,( store_tmp2) 
0c04 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c07			 
0c07					 
0c07			.mitem:	 
0c07			 
0c07			 
0c07 3a 72 ea				ld a,(store_tmp2+1) 
0c0a 6f					ld l, a 
0c0b 26 00				ld h, 0 
0c0d 29					add hl, hl 
0c0e ed 5b 73 ea			ld de, (store_tmp1) 
0c12 19					add hl, de 
0c13 7e					ld a, (hl) 
0c14 23					inc hl 
0c15 66					ld h,(hl) 
0c16 6f					ld l, a 
0c17			 
0c17 cd 0f 0e				call ishlzero 
0c1a 28 1a				jr z, .mdone 
0c1c			 
0c1c eb					ex de, hl 
0c1d 3a 6f ea				ld a, (store_tmp3) 
0c20 cd cc 0b				call str_at_display 
0c23					 
0c23			 
0c23					; next item 
0c23 3a 72 ea				ld a, (store_tmp2+1) 
0c26 3c					inc a 
0c27 32 72 ea				ld (store_tmp2+1), a   ; display item count 
0c2a			 
0c2a			 		; next row 
0c2a			 
0c2a 3a 6f ea				ld a, (store_tmp3) 
0c2d c6 28				add display_cols 
0c2f 32 6f ea				ld (store_tmp3), a 
0c32			 
0c32					; at end of screen? 
0c32			 
0c32 fe 10				cp display_rows*4 
0c34 20 d1				jr nz, .mitem 
0c36			 
0c36			 
0c36			.mdone: 
0c36 cd 0f 0e				call ishlzero 
0c39 28 08				jr z, .nodn 
0c3b			 
0c3b 3e 78				ld a, display_row_4 
0c3d 11 bc 0c				ld de, .mdown 
0c40 cd cc 0b				call str_at_display 
0c43			 
0c43					; draw options to fill the screens with active item on line 1 
0c43					; if current option is 2 or more then display ^ in top 
0c43			 
0c43 3a 71 ea		.nodn:		ld a, (store_tmp2) 
0c46 fe 00				cp 0 
0c48 28 08				jr z, .noup 
0c4a			 
0c4a 3e 00				ld a, 0 
0c4c 11 ba 0c				ld de, .mup 
0c4f cd cc 0b				call str_at_display 
0c52			 
0c52 3e 02		.noup:		ld a, 2 
0c54 11 b8 0c				ld de, .msel 
0c57 cd cc 0b				call str_at_display 
0c5a			 
0c5a					; if current option + 1 is not null then display V in bottom 
0c5a					; get key 
0c5a cd dc 0b				call update_display 
0c5d			 
0c5d			 
0c5d					; handle key 
0c5d			 
0c5d cd 53 5e				call cin_wait 
0c60			 
0c60 fe 05				cp KEY_UP 
0c62 28 2b				jr z, .mgoup 
0c64 fe 61				cp 'a' 
0c66 28 27				jr z, .mgoup 
0c68 fe 0a				cp KEY_DOWN 
0c6a 28 32				jr z, .mgod 
0c6c fe 7a				cp 'z' 
0c6e 28 2e				jr z, .mgod 
0c70 fe 20				cp ' ' 
0c72 28 34				jr z, .goend 
0c74 fe 0c				cp KEY_RIGHT 
0c76 28 30				jr z, .goend 
0c78 fe 0d				cp KEY_CR 
0c7a 28 2c				jr z, .goend 
0c7c fe 71				cp 'q' 
0c7e 28 0b				jr z, .goback 
0c80			 
0c80 fe 0b				cp KEY_LEFT 
0c82 28 07				jr z, .goback 
0c84 fe 08				cp KEY_BS 
0c86 28 03				jr z, .goback 
0c88 c3 f6 0b				jp .mloop 
0c8b			 
0c8b			.goback: 
0c8b 3e 00			ld a, 0 
0c8d 18 1d			jr .goend2 
0c8f			 
0c8f				; move up one 
0c8f			.mgoup: 
0c8f 3a 71 ea				ld a, (store_tmp2) 
0c92 fe 00				cp 0 
0c94 ca f6 0b				jp z, .mloop 
0c97 3d					dec a 
0c98 32 71 ea				ld (store_tmp2), a 
0c9b c3 f6 0b				jp .mloop 
0c9e			 
0c9e				; move down one 
0c9e			.mgod: 
0c9e 3a 71 ea				ld a, (store_tmp2) 
0ca1 3c					inc a 
0ca2 32 71 ea				ld (store_tmp2), a 
0ca5 c3 f6 0b				jp .mloop 
0ca8			 
0ca8			 
0ca8			.goend: 
0ca8					; get selected item number 
0ca8			 
0ca8 3a 71 ea				ld a, (store_tmp2) 
0cab 3c					inc a 
0cac			 
0cac			.goend2: 
0cac f5					push af 
0cad			 
0cad					; restore active fb 
0cad					; TODO BUG assumes fb1 
0cad			 
0cad 21 10 ed				ld hl, display_fb1 
0cb0 22 cc eb				ld (display_fb_active), hl 
0cb3			 
0cb3					; restore main regs 
0cb3			 
0cb3			 
0cb3 cd dc 0b				call update_display 
0cb6			 
0cb6 f1					pop af 
0cb7			 
0cb7 c9				ret 
0cb8			 
0cb8 .. 00		.msel:   db ">",0 
0cba .. 00		.mup:   db "^",0 
0cbc .. 00		.mdown:   db "v",0 
0cbe			 
0cbe			 
0cbe			; eof 
0cbe			 
# End of file firmware_display.asm
0cbe			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0cbe			; random number generators 
0cbe			 
0cbe			 
0cbe			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0cbe			 
0cbe			 
0cbe			;-----> Generate a random number 
0cbe			; output a=answer 0<=a<=255 
0cbe			; all registers are preserved except: af 
0cbe			random: 
0cbe e5			        push    hl 
0cbf d5			        push    de 
0cc0 2a ab eb		        ld      hl,(randData) 
0cc3 ed 5f		        ld      a,r 
0cc5 57			        ld      d,a 
0cc6 5e			        ld      e,(hl) 
0cc7 19			        add     hl,de 
0cc8 85			        add     a,l 
0cc9 ac			        xor     h 
0cca 22 ab eb		        ld      (randData),hl 
0ccd d1			        pop     de 
0cce e1			        pop     hl 
0ccf c9			        ret 
0cd0			 
0cd0			 
0cd0			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0cd0			 
0cd0			 
0cd0			 
0cd0			;------LFSR------ 
0cd0			;James Montelongo 
0cd0			;optimized by Spencer Putt 
0cd0			;out: 
0cd0			; a = 8 bit random number 
0cd0			RandLFSR: 
0cd0 21 b1 eb		        ld hl,LFSRSeed+4 
0cd3 5e			        ld e,(hl) 
0cd4 23			        inc hl 
0cd5 56			        ld d,(hl) 
0cd6 23			        inc hl 
0cd7 4e			        ld c,(hl) 
0cd8 23			        inc hl 
0cd9 7e			        ld a,(hl) 
0cda 47			        ld b,a 
0cdb cb 13		        rl e  
0cdd cb 12			rl d 
0cdf cb 11		        rl c  
0ce1 17				rla 
0ce2 cb 13		        rl e  
0ce4 cb 12			rl d 
0ce6 cb 11		        rl c  
0ce8 17				rla 
0ce9 cb 13		        rl e  
0ceb cb 12			rl d 
0ced cb 11		        rl c  
0cef 17				rla 
0cf0 67			        ld h,a 
0cf1 cb 13		        rl e  
0cf3 cb 12			rl d 
0cf5 cb 11		        rl c  
0cf7 17				rla 
0cf8 a8			        xor b 
0cf9 cb 13		        rl e  
0cfb cb 12			rl d 
0cfd ac			        xor h 
0cfe a9			        xor c 
0cff aa			        xor d 
0d00 21 b3 eb		        ld hl,LFSRSeed+6 
0d03 11 b4 eb		        ld de,LFSRSeed+7 
0d06 01 07 00		        ld bc,7 
0d09 ed b8		        lddr 
0d0b 12			        ld (de),a 
0d0c c9			        ret 
0d0d			 
0d0d			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0d0d			 
0d0d			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0d0d			 
0d0d			 
0d0d			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0d0d			 
0d0d			prng16: 
0d0d			;Inputs: 
0d0d			;   (seed1) contains a 16-bit seed value 
0d0d			;   (seed2) contains a NON-ZERO 16-bit seed value 
0d0d			;Outputs: 
0d0d			;   HL is the result 
0d0d			;   BC is the result of the LCG, so not that great of quality 
0d0d			;   DE is preserved 
0d0d			;Destroys: 
0d0d			;   AF 
0d0d			;cycle: 4,294,901,760 (almost 4.3 billion) 
0d0d			;160cc 
0d0d			;26 bytes 
0d0d 2a a5 eb		    ld hl,(seed1) 
0d10 44			    ld b,h 
0d11 4d			    ld c,l 
0d12 29			    add hl,hl 
0d13 29			    add hl,hl 
0d14 2c			    inc l 
0d15 09			    add hl,bc 
0d16 22 a5 eb		    ld (seed1),hl 
0d19 2a a3 eb		    ld hl,(seed2) 
0d1c 29			    add hl,hl 
0d1d 9f			    sbc a,a 
0d1e e6 2d		    and %00101101 
0d20 ad			    xor l 
0d21 6f			    ld l,a 
0d22 22 a3 eb		    ld (seed2),hl 
0d25 09			    add hl,bc 
0d26 c9			    ret 
0d27			 
0d27			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0d27			 
0d27			rand32: 
0d27			;Inputs: 
0d27			;   (seed1_0) holds the lower 16 bits of the first seed 
0d27			;   (seed1_1) holds the upper 16 bits of the first seed 
0d27			;   (seed2_0) holds the lower 16 bits of the second seed 
0d27			;   (seed2_1) holds the upper 16 bits of the second seed 
0d27			;   **NOTE: seed2 must be non-zero 
0d27			;Outputs: 
0d27			;   HL is the result 
0d27			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0d27			;Destroys: 
0d27			;   AF 
0d27			;Tested and passes all CAcert tests 
0d27			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0d27			;it has a period of 18,446,744,069,414,584,320 
0d27			;roughly 18.4 quintillion. 
0d27			;LFSR taps: 0,2,6,7  = 11000101 
0d27			;291cc 
0d27			;seed1_0=$+1 
0d27			;    ld hl,12345 
0d27			;seed1_1=$+1 
0d27			;    ld de,6789 
0d27			;    ld b,h 
0d27			;    ld c,l 
0d27			;    add hl,hl \ rl e \ rl d 
0d27			;    add hl,hl \ rl e \ rl d 
0d27			;    inc l 
0d27			;    add hl,bc 
0d27			;    ld (seed1_0),hl 
0d27			;    ld hl,(seed1_1) 
0d27			;    adc hl,de 
0d27			;    ld (seed1_1),hl 
0d27			;    ex de,hl 
0d27			;seed2_0=$+1 
0d27			;    ld hl,9876 
0d27			;seed2_1=$+1 
0d27			;    ld bc,54321 
0d27			;    add hl,hl \ rl c \ rl b 
0d27			;    ld (seed2_1),bc 
0d27			;    sbc a,a 
0d27			;    and %11000101 
0d27			;    xor l 
0d27			;    ld l,a 
0d27			;    ld (seed2_0),hl 
0d27			;    ex de,hl 
0d27			;    add hl,bc 
0d27			;    ret 
0d27			; 
0d27			 
0d27			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0d27			; 20 bytes, 86 cycles (excluding ret) 
0d27			 
0d27			; returns   hl = pseudorandom number 
0d27			; corrupts   a 
0d27			 
0d27			; generates 16-bit pseudorandom numbers with a period of 65535 
0d27			; using the xorshift method: 
0d27			 
0d27			; hl ^= hl << 7 
0d27			; hl ^= hl >> 9 
0d27			; hl ^= hl << 8 
0d27			 
0d27			; some alternative shift triplets which also perform well are: 
0d27			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0d27			 
0d27			;  org 32768 
0d27			 
0d27			xrnd: 
0d27 2a a9 eb		  ld hl,(xrandc)       ; seed must not be 0 
0d2a 3e 00		  ld a,0 
0d2c bd			  cp l 
0d2d 20 02		  jr nz, .xrnd1 
0d2f 2e 01		  ld l, 1 
0d31			.xrnd1: 
0d31			 
0d31 7c			  ld a,h 
0d32 1f			  rra 
0d33 7d			  ld a,l 
0d34 1f			  rra 
0d35 ac			  xor h 
0d36 67			  ld h,a 
0d37 7d			  ld a,l 
0d38 1f			  rra 
0d39 7c			  ld a,h 
0d3a 1f			  rra 
0d3b ad			  xor l 
0d3c 6f			  ld l,a 
0d3d ac			  xor h 
0d3e 67			  ld h,a 
0d3f			 
0d3f 22 a9 eb		  ld (xrandc),hl 
0d42			 
0d42 c9			  ret 
0d43			;  
0d43			 
0d43			 
0d43			;;;; int maths 
0d43			 
0d43			; https://map.grauw.nl/articles/mult_div_shifts.php 
0d43			; Divide 16-bit values (with 16-bit result) 
0d43			; In: Divide BC by divider DE 
0d43			; Out: BC = result, HL = rest 
0d43			; 
0d43			Div16: 
0d43 21 00 00		    ld hl,0 
0d46 78			    ld a,b 
0d47 06 08		    ld b,8 
0d49			Div16_Loop1: 
0d49 17			    rla 
0d4a ed 6a		    adc hl,hl 
0d4c ed 52		    sbc hl,de 
0d4e 30 01		    jr nc,Div16_NoAdd1 
0d50 19			    add hl,de 
0d51			Div16_NoAdd1: 
0d51 10 f6		    djnz Div16_Loop1 
0d53 17			    rla 
0d54 2f			    cpl 
0d55 47			    ld b,a 
0d56 79			    ld a,c 
0d57 48			    ld c,b 
0d58 06 08		    ld b,8 
0d5a			Div16_Loop2: 
0d5a 17			    rla 
0d5b ed 6a		    adc hl,hl 
0d5d ed 52		    sbc hl,de 
0d5f 30 01		    jr nc,Div16_NoAdd2 
0d61 19			    add hl,de 
0d62			Div16_NoAdd2: 
0d62 10 f6		    djnz Div16_Loop2 
0d64 17			    rla 
0d65 2f			    cpl 
0d66 41			    ld b,c 
0d67 4f			    ld c,a 
0d68 c9			ret 
0d69			 
0d69			 
0d69			;http://z80-heaven.wikidot.com/math 
0d69			; 
0d69			;Inputs: 
0d69			;     DE and A are factors 
0d69			;Outputs: 
0d69			;     A is not changed 
0d69			;     B is 0 
0d69			;     C is not changed 
0d69			;     DE is not changed 
0d69			;     HL is the product 
0d69			;Time: 
0d69			;     342+6x 
0d69			; 
0d69			Mult16: 
0d69			 
0d69 06 08		     ld b,8          ;7           7 
0d6b 21 00 00		     ld hl,0         ;10         10 
0d6e 29			       add hl,hl     ;11*8       88 
0d6f 07			       rlca          ;4*8        32 
0d70 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0d72 19			         add hl,de   ;--         -- 
0d73 10 f9		       djnz $-5      ;13*7+8     99 
0d75 c9			ret 
0d76			 
0d76			; 
0d76			; Square root of 16-bit value 
0d76			; In:  HL = value 
0d76			; Out:  D = result (rounded down) 
0d76			; 
0d76			;Sqr16: 
0d76			;    ld de,#0040 
0d76			;    ld a,l 
0d76			;    ld l,h 
0d76			;    ld h,d 
0d76			;    or a 
0d76			;    ld b,8 
0d76			;Sqr16_Loop: 
0d76			;    sbc hl,de 
0d76			;    jr nc,Sqr16_Skip 
0d76			;    add hl,de 
0d76			;Sqr16_Skip: 
0d76			;    ccf 
0d76			;    rl d 
0d76			;    add a,a 
0d76			;    adc hl,hl 
0d76			;    add a,a 
0d76			;    adc hl,hl 
0d76			;    djnz Sqr16_Loop 
0d76			;    ret 
0d76			; 
0d76			; 
0d76			; Divide 8-bit values 
0d76			; In: Divide E by divider C 
0d76			; Out: A = result, B = rest 
0d76			; 
0d76			Div8: 
0d76 af			    xor a 
0d77 06 08		    ld b,8 
0d79			Div8_Loop: 
0d79 cb 13		    rl e 
0d7b 17			    rla 
0d7c 91			    sub c 
0d7d 30 01		    jr nc,Div8_NoAdd 
0d7f 81			    add a,c 
0d80			Div8_NoAdd: 
0d80 10 f7		    djnz Div8_Loop 
0d82 47			    ld b,a 
0d83 7b			    ld a,e 
0d84 17			    rla 
0d85 2f			    cpl 
0d86 c9			    ret 
0d87			 
0d87			; 
0d87			; Multiply 8-bit value with a 16-bit value (unrolled) 
0d87			; In: Multiply A with DE 
0d87			; Out: HL = result 
0d87			; 
0d87			Mult12U: 
0d87 2e 00		    ld l,0 
0d89 87			    add a,a 
0d8a 30 01		    jr nc,Mult12U_NoAdd0 
0d8c 19			    add hl,de 
0d8d			Mult12U_NoAdd0: 
0d8d 29			    add hl,hl 
0d8e 87			    add a,a 
0d8f 30 01		    jr nc,Mult12U_NoAdd1 
0d91 19			    add hl,de 
0d92			Mult12U_NoAdd1: 
0d92 29			    add hl,hl 
0d93 87			    add a,a 
0d94 30 01		    jr nc,Mult12U_NoAdd2 
0d96 19			    add hl,de 
0d97			Mult12U_NoAdd2: 
0d97 29			    add hl,hl 
0d98 87			    add a,a 
0d99 30 01		    jr nc,Mult12U_NoAdd3 
0d9b 19			    add hl,de 
0d9c			Mult12U_NoAdd3: 
0d9c 29			    add hl,hl 
0d9d 87			    add a,a 
0d9e 30 01		    jr nc,Mult12U_NoAdd4 
0da0 19			    add hl,de 
0da1			Mult12U_NoAdd4: 
0da1 29			    add hl,hl 
0da2 87			    add a,a 
0da3 30 01		    jr nc,Mult12U_NoAdd5 
0da5 19			    add hl,de 
0da6			Mult12U_NoAdd5: 
0da6 29			    add hl,hl 
0da7 87			    add a,a 
0da8 30 01		    jr nc,Mult12U_NoAdd6 
0daa 19			    add hl,de 
0dab			Mult12U_NoAdd6: 
0dab 29			    add hl,hl 
0dac 87			    add a,a 
0dad d0			    ret nc 
0dae 19			    add hl,de 
0daf c9			    ret 
0db0			 
0db0			; 
0db0			; Multiply 8-bit value with a 16-bit value (right rotating) 
0db0			; In: Multiply A with DE 
0db0			;      Put lowest value in A for most efficient calculation 
0db0			; Out: HL = result 
0db0			; 
0db0			Mult12R: 
0db0 21 00 00		    ld hl,0 
0db3			Mult12R_Loop: 
0db3 cb 3f		    srl a 
0db5 30 01		    jr nc,Mult12R_NoAdd 
0db7 19			    add hl,de 
0db8			Mult12R_NoAdd: 
0db8 cb 23		    sla e 
0dba cb 12		    rl d 
0dbc b7			    or a 
0dbd c2 b3 0d		    jp nz,Mult12R_Loop 
0dc0 c9			    ret 
0dc1			 
0dc1			; 
0dc1			; Multiply 16-bit values (with 32-bit result) 
0dc1			; In: Multiply BC with DE 
0dc1			; Out: BCHL = result 
0dc1			; 
0dc1			Mult32: 
0dc1 79			    ld a,c 
0dc2 48			    ld c,b 
0dc3 21 00 00		    ld hl,0 
0dc6 06 10		    ld b,16 
0dc8			Mult32_Loop: 
0dc8 29			    add hl,hl 
0dc9 17			    rla 
0dca cb 11		    rl c 
0dcc 30 07		    jr nc,Mult32_NoAdd 
0dce 19			    add hl,de 
0dcf ce 00		    adc a,0 
0dd1 d2 d5 0d		    jp nc,Mult32_NoAdd 
0dd4 0c			    inc c 
0dd5			Mult32_NoAdd: 
0dd5 10 f1		    djnz Mult32_Loop 
0dd7 41			    ld b,c 
0dd8 4f			    ld c,a 
0dd9 c9			    ret 
0dda			 
0dda			 
0dda			 
0dda			; 
0dda			; Multiply 8-bit values 
0dda			; In:  Multiply H with E 
0dda			; Out: HL = result 
0dda			; 
0dda			Mult8: 
0dda 16 00		    ld d,0 
0ddc 6a			    ld l,d 
0ddd 06 08		    ld b,8 
0ddf			Mult8_Loop: 
0ddf 29			    add hl,hl 
0de0 30 01		    jr nc,Mult8_NoAdd 
0de2 19			    add hl,de 
0de3			Mult8_NoAdd: 
0de3 10 fa		    djnz Mult8_Loop 
0de5 c9			    ret 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			 
0de6			;;http://z80-heaven.wikidot.com/math 
0de6			;;This divides DE by BC, storing the result in DE, remainder in HL 
0de6			; 
0de6			;DE_Div_BC:          ;1281-2x, x is at most 16 
0de6			;     ld a,16        ;7 
0de6			;     ld hl,0        ;10 
0de6			;     jp $+5         ;10 
0de6			;.DivLoop: 
0de6			;       add hl,bc    ;-- 
0de6			;       dec a        ;64 
0de6			;       jr z,.DivLoopEnd        ;86 
0de6			; 
0de6			;       sla e        ;128 
0de6			;       rl d         ;128 
0de6			;       adc hl,hl    ;240 
0de6			;       sbc hl,bc    ;240 
0de6			;       jr nc,.DivLoop ;23|21 
0de6			;       inc e        ;-- 
0de6			;       jp .DivLoop+1 
0de6			; 
0de6			;.DivLoopEnd: 
0de6			 
0de6			;HL_Div_C: 
0de6			;Inputs: 
0de6			;     HL is the numerator 
0de6			;     C is the denominator 
0de6			;Outputs: 
0de6			;     A is the remainder 
0de6			;     B is 0 
0de6			;     C is not changed 
0de6			;     DE is not changed 
0de6			;     HL is the quotient 
0de6			; 
0de6			;       ld b,16 
0de6			;       xor a 
0de6			;         add hl,hl 
0de6			;         rla 
0de6			;         cp c 
0de6			;         jr c,$+4 
0de6			;           inc l 
0de6			;           sub c 
0de6			;         djnz $-7 
0de6			 
0de6			; https://plutiedev.com/z80-add-8bit-to-16bit 
0de6			 
0de6			addatohl: 
0de6 85			    add   a, l    ; A = A+L 
0de7 6f			    ld    l, a    ; L = A+L 
0de8 8c			    adc   a, h    ; A = A+L+H+carry 
0de9 95			    sub   l       ; A = H+carry 
0dea 67			    ld    h, a    ; H = H+carry 
0deb c9			ret 
0dec			 
0dec			addatode: 
0dec 83			    add   a, e    ; A = A+L 
0ded 5f			    ld    e, a    ; L = A+L 
0dee 8a			    adc   a, d    ; A = A+L+H+carry 
0def 93			    sub   e       ; A = H+carry 
0df0 57			    ld    d, a    ; H = H+carry 
0df1 c9			ret 
0df2			 
0df2			 
0df2			addatobc: 
0df2 81			    add   a, c    ; A = A+L 
0df3 4f			    ld    c, a    ; L = A+L 
0df4 88			    adc   a, b    ; A = A+L+H+carry 
0df5 91			    sub   c       ; A = H+carry 
0df6 47			    ld    b, a    ; H = H+carry 
0df7 c9			ret 
0df8			 
0df8			subafromhl: 
0df8			   ; If A=0 do nothing 
0df8			    ; Otherwise flip A's sign. Since 
0df8			    ; the upper byte becomes -1, also 
0df8			    ; substract 1 from H. 
0df8 ed 44		    neg 
0dfa ca 03 0e		    jp    z, Skip 
0dfd 25			    dec   h 
0dfe			     
0dfe			    ; Now add the low byte as usual 
0dfe			    ; Two's complement takes care of 
0dfe			    ; ensuring the result is correct 
0dfe 85			    add   a, l 
0dff 6f			    ld    l, a 
0e00 8c			    adc   a, h 
0e01 95			    sub   l 
0e02 67			    ld    h, a 
0e03			Skip: 
0e03 c9				ret 
0e04			 
0e04			 
0e04			; compare hl and de 
0e04			; returns:  
0e04			; if hl = de, z=1, s=0, c0=0 
0e04			; if hl > de, z=0, s=0, c=0 
0e04			; if hl < de, z=0, s=1, c=1 
0e04			cmp16:	 
0e04 b7				or a 
0e05 ed 52			sbc hl,de 
0e07 e0				ret po 
0e08 7c				ld a,h 
0e09 1f				rra 
0e0a ee 40			xor 01000000B 
0e0c 37				scf 
0e0d 8f				adc a,a 
0e0e c9				ret 
0e0f			 
0e0f			 
0e0f			; test if hl contains zero   - A is destroyed 
0e0f			 
0e0f			ishlzero:    
0e0f b7				or a     ; reset flags 
0e10 7c				ld a, h 
0e11 b5				or l        	 
0e12			 
0e12 c9				ret 
0e13			 
0e13			 
0e13			 
0e13			 
0e13			if FORTH_ENABLE_FLOATMATH 
0e13			;include "float/bbcmath.z80" 
0e13			include "float/lpfpcalc.asm" 
0e13			endif 
0e13			 
0e13			 
0e13			; eof 
0e13			 
# End of file firmware_maths.asm
0e13			include "firmware_strings.asm"   ; string handling  
0e13			 
0e13			 
0e13			; TODO string len 
0e13			; input text string, end on cr with zero term 
0e13			; a offset into frame buffer to start prompt 
0e13			; d is max length 
0e13			; e is display size TODO 
0e13			; c is current cursor position 
0e13			; hl is ptr to where string will be stored and edited directly 
0e13			 
0e13			 
0e13			; TODO check limit of buffer for new inserts 
0e13			; TODO check insert does not push beyond buffer 
0e13			; TODO scroll in a limited display area 
0e13			; TODO scroll whole screen on page wrap 
0e13			 
0e13			 
0e13			; TODO use LCD cursor? 
0e13			 
0e13			EDIT_V1: equ 0 
0e13			EDIT_V2: equ 1 
0e13			 
0e13			 
0e13			 
0e13			if EDIT_V2 
0e13			input_str: 
0e13			 
0e13 32 64 ee			    	ld (input_at_pos),a      ; save display position to start 
0e16			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0e16 22 67 ee				ld (input_start), hl     ; save ptr to buffer 
0e19			;		ld a, c 
0e19			;		call addatohl 
0e19			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
0e19 7a					ld a,d 
0e1a 32 66 ee			        ld (input_size), a       ; save length of input area 
0e1d 79					ld a, c 
0e1e 32 55 ee				ld (input_cursor),a      ; init cursor start position relative to start of string 
0e21 7b					ld a,e 
0e22 32 65 ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0e25			 
0e25			 
0e25					; add a trailing space to make screen refresh nicer 
0e25			 
0e25					;ld hl, (input_start) 
0e25					;push hl 
0e25					;ld a, 0 
0e25					;call strlent 
0e25					;ld a, l 
0e25					;pop hl 
0e25					;call addatohl 
0e25					;dec hl 
0e25					;ld a, ' ' 
0e25					;ld (hl), a 
0e25					;inc hl 
0e25					;ld (hl), a 
0e25					;inc hl 
0e25					;ld a, 0 
0e25					;ld (hl), a 
0e25			 
0e25			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0e25					; init cursor shape if not set by the cin routines 
0e25 21 c1 eb				ld hl, cursor_shape 
0e28			if BASE_KEV 
0e28					ld a, 255 
0e28			else 
0e28 3e 23				ld a, '#' 
0e2a			endif 
0e2a 77					ld (hl), a 
0e2b 23					inc hl 
0e2c 3e 00				ld a, 0 
0e2e 77					ld (hl), a 
0e2f			 
0e2f 3e 09				ld a, CUR_BLINK_RATE 
0e31 32 60 ee				ld (input_cur_flash), a 
0e34 3e 01				ld a, 1 
0e36 32 5f ee				ld (input_cur_onoff),a 
0e39			.inmain:	 
0e39			 
0e39 cd 61 0f				call input_disp_ref 
0e3c			 
0e3c					; save current length of string 
0e3c			 
0e3c 2a 67 ee				ld hl, (input_start) 
0e3f 3e 00				ld a, 0 
0e41 cd 57 11				call strlent 
0e44 7d					ld a,l 
0e45 32 5a ee				ld (input_len), a 
0e48			 
0e48					;call input_disp_oncur 
0e48			 
0e48					; display current state of input buffer 
0e48			 
0e48					; clean any backspace chars 
0e48			 
0e48 3e 20				ld a, " " 
0e4a 32 c1 e2				ld (scratch),a 
0e4d 3e 00				ld a, 0 
0e4f 32 c2 e2				ld (scratch+1),a 
0e52 3a 64 ee				ld a,(input_at_pos) 
0e55 85					add l 
0e56 11 c1 e2				ld de, scratch 
0e59 cd cc 0b				call str_at_display 
0e5c			 
0e5c					; pause 1ms 
0e5c			 
0e5c 3e 01				ld a, 1 
0e5e cd d6 0a				call aDelayInMS 
0e61			 
0e61			; display cursor if visible on this cycle 
0e61			 
0e61					; dec flash counter 
0e61 3a 60 ee				ld a, (input_cur_flash) 
0e64 3d					dec a 
0e65 32 60 ee				ld (input_cur_flash), a 
0e68 fe 00				cp 0 
0e6a 20 0d				jr nz, .inochgstate 
0e6c			 
0e6c			 
0e6c					; reset on change of state 
0e6c 3e 09				ld a, CUR_BLINK_RATE 
0e6e 32 60 ee				ld (input_cur_flash), a 
0e71			 
0e71					; change state 
0e71 3a 5f ee				ld a,(input_cur_onoff) 
0e74 ed 44				neg 
0e76 32 5f ee				ld (input_cur_onoff),a 
0e79			 
0e79			 
0e79			 
0e79			 
0e79					; TODO is cursor visible? 
0e79					; TODO if so then over write the char at curspos pos with the cursor shape 
0e79			 
0e79								 
0e79			 
0e79			.inochgstate: 
0e79 3a 5f ee				ld a,(input_cur_onoff) 
0e7c fe ff				cp 255 
0e7e 28 0e				jr z, .skipcursor 
0e80 3a 64 ee				ld a, (input_at_pos) 
0e83 47					ld b, a 
0e84 3a 55 ee				ld a, (input_cursor) 
0e87 80					add b 
0e88 11 c1 eb				ld de, cursor_shape 
0e8b					 
0e8b cd cc 0b				call str_at_display 
0e8e			 
0e8e			.skipcursor: 
0e8e				if DEBUG_INPUTV2 
0e8e			 
0e8e					ld a,(input_at_pos) 
0e8e					ld hl, LFSRSeed 
0e8e					call hexout 
0e8e					ld a, (input_cursor) 
0e8e					ld hl, LFSRSeed+2 
0e8e					call hexout 
0e8e					ld a,(input_size) 
0e8e					ld hl, LFSRSeed+4 
0e8e					call hexout 
0e8e			 
0e8e					ld a,(input_cur_onoff) 
0e8e					ld hl, LFSRSeed+6 
0e8e					call hexout 
0e8e			 
0e8e					ld a,(input_cur_flash) 
0e8e					ld hl, LFSRSeed+8 
0e8e					call hexout 
0e8e			 
0e8e					ld a,(input_len) 
0e8e					ld hl, LFSRSeed+10 
0e8e					call hexout 
0e8e					ld hl, LFSRSeed+12 
0e8e					ld a, 0 
0e8e					ld (hl),a 
0e8e					ld a, display_row_4 
0e8e					ld de, LFSRSeed 
0e8e					call str_at_display 
0e8e				endif 
0e8e cd dc 0b				call update_display 
0e91			 
0e91					; TODO keyboard processing 
0e91			 
0e91			if BASE_CPM 
0e91 cd 53 5e				call cin_wait 
0e94			else 
0e94					call cin    ; _wait 
0e94			endif 
0e94 fe 00				cp 0 
0e96 ca 39 0e				jp z, .inmain 
0e99			 
0e99 fe 0b				cp KEY_LEFT    ; cursor left 
0e9b ca 53 0f				jp z, input_left 
0e9e				 
0e9e fe 0c				cp KEY_RIGHT      ; cursor right 
0ea0 ca 5a 0f				jp z, input_right 
0ea3			 
0ea3 fe 0d				cp KEY_CR 
0ea5 c8					ret z 
0ea6			 
0ea6 fe 08				cp KEY_BS 
0ea8 ca c8 0f				jp z, input_delchar 
0eab			 
0eab fe 06				cp KEY_NEXTWORD 
0ead ca d4 0e				jp z, input_nxtword 
0eb0			 
0eb0 fe 07				cp KEY_PREVWORD 
0eb2 ca fb 0e				jp z, input_prvword 
0eb5			 
0eb5 fe 0e				cp KEY_HOME    ; jump to start of line 
0eb7 20 08				jr nz, .ikh 
0eb9 3e 00				ld a, 0 
0ebb 32 55 ee				ld (input_cursor), a 
0ebe ca 39 0e				jp z, .inmain 
0ec1			.ikh: 
0ec1			 
0ec1 fe 0f				cp KEY_END     ; jump to end of line 
0ec3 20 09				jr nz, .ike 
0ec5 3a 5a ee				ld a, (input_len) 
0ec8 32 55 ee				ld (input_cursor),a 
0ecb ca 39 0e				jp z, .inmain 
0ece			.ike: 
0ece fe 05			        cp KEY_UP      ; recall last command 
0ed0 c8					ret z 
0ed1			;jr nz, .irec 
0ed1			; TODO next word 
0ed1			; TODO prev word 
0ed1			;  
0ed1			; 
0ed1			;	ld hl, scratch 
0ed1			;	ld de, os_last_cmd 
0ed1			;	call strcpy 
0ed1			;		jp  .inmain 
0ed1			.irec: 
0ed1			;		jr .instr1 
0ed1			 
0ed1			 
0ed1			 
0ed1					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
0ed1			 
0ed1			; TODO return if any special keys are given 
0ed1			;		ld l, a 
0ed1			;		ld a, 28 ; KEY_F12   ; 27 
0ed1			;		sub l 
0ed1			;		ret m 
0ed1			;		ld a, l 
0ed1					; if no special key then insert as a char 
0ed1			 
0ed1 c3 9a 0f				jp input_inschr 
0ed4			 
0ed4				 
0ed4			input_nxtword: 
0ed4				; jump to start next word after the cursor 
0ed4			 
0ed4			.insknwn:	 
0ed4 cd 90 0f				call input_curptr	 
0ed7 7e					ld a,(hl)	 
0ed8 fe 00				cp 0 
0eda ca 39 0e				jp z, .inmain    ; end of string 
0edd			 
0edd			; if we are on a word, then move off of it 
0edd			 
0edd fe 20				cp ' ' 
0edf 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
0ee1 21 55 ee				ld hl, input_cursor 
0ee4 34					inc (hl) 
0ee5 18 ed				jr .insknwn 
0ee7			 
0ee7			.inspace: 
0ee7			 
0ee7 cd 90 0f				call input_curptr	 
0eea 7e					ld a,(hl)	 
0eeb fe 00				cp 0 
0eed ca 39 0e				jp z, .inmain    ; end of string 
0ef0			 
0ef0			; if we are on a word, then move off of it 
0ef0			 
0ef0 fe 20				cp ' ' 
0ef2 c2 39 0e				jp nz, .inmain     ; we are on non space so at next word 
0ef5 21 55 ee				ld hl, input_cursor 
0ef8 34					inc (hl) 
0ef9 18 ec				jr .inspace 
0efb			 
0efb			 
0efb			 
0efb			 
0efb			input_prvword: 
0efb				; jump to the start of previous word before the cursor 
0efb			 
0efb			; where are we to start with currently? 
0efb			 
0efb cd 90 0f				call input_curptr	 
0efe 7e					ld a, (hl) 
0eff fe 20				cp ' ' 
0f01 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
0f03			 
0f03			 
0f03			 
0f03			.inskpwn:	 
0f03 3a 55 ee				ld a,(input_cursor) 
0f06 fe 00				cp 0 
0f08 ca 39 0e				jp z, .inmain    ; start of string 
0f0b			 
0f0b			;if we are on a word, then move off of it 
0f0b			 
0f0b cd 90 0f				call input_curptr	 
0f0e 7e					ld a, (hl) 
0f0f fe 20				cp ' ' 
0f11 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
0f13					;jp z, .inmain    ; start of string 
0f13 21 55 ee				ld hl, input_cursor 
0f16 35					dec (hl) 
0f17 18 ea				jr .inskpwn 
0f19			.iwstart: 
0f19 21 55 ee				ld hl, input_cursor 
0f1c 34					inc (hl) 
0f1d c3 39 0e				jp .inmain 
0f20					 
0f20			 
0f20			.inspacep: 
0f20			 
0f20					;jp .inmain    ; start of string 
0f20			 
0f20			 
0f20			 
0f20 3a 55 ee				ld a,(input_cursor) 
0f23 fe 00				cp 0 
0f25 ca 39 0e				jp z, .inmain    ; start of string 
0f28			 
0f28			; if we are on a word, then move off of it 
0f28			 
0f28 cd 90 0f				call input_curptr	 
0f2b 7e					ld a, (hl) 
0f2c fe 20				cp ' ' 
0f2e c2 37 0f				jp nz, .incharp     ; we are on non space so at end of prev word 
0f31 21 55 ee				ld hl, input_cursor 
0f34 35					dec (hl) 
0f35 18 e9				jr .inspacep 
0f37			 
0f37			 
0f37			.incharp:	 
0f37					; eat the word to get to the start 
0f37 3a 55 ee				ld a,(input_cursor) 
0f3a fe 00				cp 0 
0f3c ca 39 0e				jp z, .inmain    ; start of string 
0f3f			 
0f3f			; if we are on a word, then move off of it 
0f3f			 
0f3f cd 90 0f				call input_curptr	 
0f42 7e					ld a, (hl) 
0f43 fe 20				cp ' ' 
0f45 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
0f47 21 55 ee				ld hl, input_cursor 
0f4a 35					dec (hl) 
0f4b 18 ea				jr .incharp 
0f4d			.ipwordst: 
0f4d					; at space before the prev word so reposition over it 
0f4d 21 55 ee				ld hl, input_cursor 
0f50 34					inc (hl) 
0f51 18 b0				jr .inskpwn 
0f53					 
0f53			 
0f53			 
0f53			input_left: 
0f53				; move cursor left 
0f53 21 55 ee			ld hl, input_cursor 
0f56 35				dec (hl) 
0f57			;	cp 0 
0f57			;	jp z, .inmain    ; ignore left as at the start of the string 
0f57 c3 39 0e			jp .inmain 
0f5a			 
0f5a			input_right: 
0f5a				; move cursor right 
0f5a				 
0f5a				;ld a, (input_size) 
0f5a				;ld b, a 
0f5a 21 55 ee			ld hl, input_cursor 
0f5d 34				inc (hl) 
0f5e				;dec b 
0f5e				;cp 0 
0f5e				;jp z, .inmain   ; ignore as at end of the string buffer 
0f5e				;ld a, b 
0f5e				;inc a 
0f5e				;ld (input_cursor), a 
0f5e c3 39 0e			jp .inmain 
0f61			 
0f61			 
0f61			 
0f61			input_disp_ref: 
0f61				; display the text from start of buffer (ie full refresh) 
0f61 3a 64 ee			ld a, (input_at_pos) 
0f64 2a 67 ee			ld hl,(input_start) 
0f67 eb				ex de, hl 
0f68 cd cc 0b			call str_at_display  
0f6b c9				ret 
0f6c			input_disp_oncur: 
0f6c				; display the text from cursor position to end of buffer 
0f6c				; TODO position start of string at cursor position on screen 
0f6c				; TODO draw from that point on 
0f6c 3a 55 ee			ld a, (input_cursor) 
0f6f 47				ld b, a 
0f70 3a 64 ee			ld a, (input_at_pos) 
0f73 80				add b 
0f74 48				ld c, b     ; save a 
0f75 78				ld a, b     ; inc string start for cursor 
0f76 2a 67 ee			ld hl,(input_start) 
0f79 cd e6 0d			call addatohl 
0f7c eb				ex de, hl 
0f7d 79				ld a, c 
0f7e cd cc 0b			call str_at_display  
0f81 c9				ret 
0f82			 
0f82			input_nxtw: 
0f82				; Find next word 
0f82 c9				ret 
0f83			 
0f83			input_prvw: 
0f83				; Find previous word 
0f83 c9				ret 
0f84			 
0f84			input_lenrem:   
0f84				; Calculate the length of string remaining from current cursor 
0f84				; position to end of buffer (exc null term) 
0f84				 
0f84 3a 55 ee			ld a, (input_cursor) 
0f87 4f				ld c, a 
0f88 3a 66 ee			ld a, (input_size) 
0f8b 91				sub c 
0f8c 06 00			ld b, 0 
0f8e 0d				dec c 
0f8f c9				ret	 
0f90			 
0f90			input_curptr: 
0f90				; calc address of the character under the cursor 
0f90				 
0f90 2a 67 ee			ld hl, (input_start) 
0f93 3a 55 ee			ld a, (input_cursor) 
0f96 cd e6 0d			call addatohl 
0f99 c9				ret 
0f9a			 
0f9a			input_inschr: 
0f9a				; Insert char at cursor position 
0f9a f5				push af   ; save char 
0f9b				;call input_lenrem    ; get bc length of remaining string 
0f9b			 
0f9b				 
0f9b cd 90 0f			call input_curptr 
0f9e			;	ld hl, (input_start) 
0f9e			;	ld a, (input_cursor) 
0f9e			;	call addatohl 
0f9e				;push hl   ; save to come back to 
0f9e			 
0f9e				; shift everything up one to end of buffer 
0f9e			 
0f9e				;push hl 
0f9e				;dec de 
0f9e				;inc de 
0f9e			;	ldir 
0f9e				 
0f9e				;pop hl 
0f9e			 
0f9e				; are we adding to the end of line? 
0f9e			 
0f9e 3a 55 ee			ld a, (input_cursor) 
0fa1 47				ld b, a 
0fa2 3a 5a ee			ld a, (input_len) 
0fa5 b8				cp b 
0fa6 20 09			jr nz, .insmid   ; no, insert in middle of text 
0fa8			 
0fa8				; tack on the end of the line 
0fa8 f1				pop af 
0fa9 77				ld (hl), a   ; save new char 
0faa 23				inc hl 
0fab 3e 00			ld a, 0 
0fad 77				ld (hl), a 
0fae c3 5a 0f			jp input_right 
0fb1				 
0fb1			.insmid: 
0fb1				; hl has insertion point so move everything up one to allow for insertion 
0fb1				;call input_shiftright 
0fb1 f1				pop af 
0fb2			 
0fb2			.shufinsmid: 
0fb2 47				ld b, a     ; b contains new char, c prev char at this position  
0fb3 7e				ld a, (hl) 
0fb4			 
0fb4 fe 00			cp 0    ; at end of string need to then dump new char and add term 
0fb6 28 07			jr z, .endinsmid 
0fb8 4f				ld c, a 
0fb9 78				ld a, b 
0fba 77				ld (hl), a 
0fbb 23				inc hl 
0fbc 79				ld a, c 
0fbd 18 f3			jr .shufinsmid 
0fbf				 
0fbf			 
0fbf			 
0fbf			 
0fbf			.endinsmid: 
0fbf 78				ld a, b 
0fc0 77				ld (hl), a 
0fc1 23				inc hl 
0fc2 3e 00			ld a, 0 
0fc4 77				ld (hl), a 
0fc5			 
0fc5			 
0fc5			;	ld (hl), a   ; save new char 
0fc5			 
0fc5 c3 5a 0f			jp input_right 
0fc8			 
0fc8			;input_shiftright: 
0fc8			;	; shift text right at cursor, hl has shift start 
0fc8			;	push hl 
0fc8			;	push de 
0fc8			;	push bc 
0fc8			; 
0fc8			; 
0fc8			;	; move to end of string past zero term 
0fc8			;	ld hl,(input_start) 
0fc8			;	ld a, (input_len) 
0fc8			;	call addatohl 
0fc8			;	inc hl 
0fc8			;;	inc hl 
0fc8			;;	inc hl 
0fc8			;	ld a, 0 
0fc8			;	ld (hl), a 
0fc8			;;	dec hl 
0fc8			;	 
0fc8			;;	ld (hl), a 
0fc8			;;	dec hl 
0fc8			; 
0fc8			;	push hl 
0fc8			;	pop de 
0fc8			;	inc de 
0fc8			;	 
0fc8			; 
0fc8			;;	ld hl,(input_start) 
0fc8			;;	ld a, (input_cursor) 
0fc8			;;	call addatohl 
0fc8			; 
0fc8			; 
0fc8			;	; calc how many bytes from cursor pos to end of string we need to shift 
0fc8			;	call input_lenrem    ; get bc length of remaining string 
0fc8			;	;ld a, (input_cursor) 
0fc8			;	;ld c, a 
0fc8			;	ld a, (input_len) 
0fc8			;	cp 2 
0fc8			;	jr z, .iskipzero	 
0fc8			;	;sub c 
0fc8			;	;inc a 
0fc8			;	;ld c, a 
0fc8			;	;ld b, 0 
0fc8			;	inc c 
0fc8			;	inc c 
0fc8			;	; move data 
0fc8			;	lddr 
0fc8			;.iskipzero: 
0fc8			; 
0fc8			;	pop bc 
0fc8			;	pop de 
0fc8			;	pop hl 
0fc8			;	ret	 
0fc8			 
0fc8			input_delchar: 
0fc8				; Delete char at cursor position 
0fc8 cd 84 0f			call input_lenrem    ; get bc length of remaining string 
0fcb 2a 67 ee			ld hl, (input_start) 
0fce 3a 55 ee			ld a, (input_cursor) 
0fd1 cd e6 0d			call addatohl 
0fd4			 
0fd4 e5				push hl 
0fd5 d1				pop de 
0fd6 1b				dec de 
0fd7			 
0fd7			.dl:	 
0fd7 ed a0			ldi  
0fd9 7e				ld a, (hl) 
0fda fe 00			cp 0 
0fdc 28 02			jr z, .dldone 
0fde 18 f7			jr .dl 
0fe0			.dldone: 
0fe0 ed a0			ldi 
0fe2			 
0fe2 c3 53 0f			jp input_left 
0fe5			 
0fe5			 
0fe5			endif 
0fe5			 
0fe5			 
0fe5			 
0fe5			if EDIT_V1 
0fe5			input_str: 
0fe5			 
0fe5				    	ld (input_at_pos),a      ; save display position to start 
0fe5					add c 
0fe5					ld (input_at_cursor),a	; save draw pos of cursor 
0fe5					ld (input_start), hl     ; save ptr to buffer 
0fe5					ld a, c 
0fe5					call addatohl 
0fe5					ld (input_ptr), hl     ; save ptr to point under the cursor 
0fe5					ld a,d 
0fe5				        ld (input_size), a       ; save length of input area 
0fe5					ld a, c 
0fe5					ld (input_cursor),a      ; init cursor start position  
0fe5					ld a,e 
0fe5				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0fe5					 
0fe5					 
0fe5			 
0fe5			;		ld a,(input_ptr) 
0fe5			;		ld (input_under_cursor),a 	; save what is under the cursor 
0fe5			 
0fe5			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0fe5					; init cursor shape if not set by the cin routines 
0fe5					ld hl, cursor_shape 
0fe5			if BASE_KEV 
0fe5					ld a, 255 
0fe5			else 
0fe5					ld a, '#' 
0fe5			endif 
0fe5					ld (hl), a 
0fe5					inc hl 
0fe5					ld a, 0 
0fe5					ld (hl), a 
0fe5			 
0fe5					ld a, CUR_BLINK_RATE 
0fe5					ld (input_cur_flash), a 
0fe5					ld a, 1 
0fe5					ld (input_cur_onoff),a 
0fe5			 
0fe5			;	if DEBUG_INPUT 
0fe5			;		push af 
0fe5			;		ld a, 'I' 
0fe5			;		ld (debug_mark),a 
0fe5			;		pop af 
0fe5			;		CALLMONITOR 
0fe5			;	endif 
0fe5			.is1:		; main entry loop 
0fe5			 
0fe5			 
0fe5			 
0fe5					; pause 1ms 
0fe5			 
0fe5					ld a, 1 
0fe5					call aDelayInMS 
0fe5			 
0fe5					; dec flash counter 
0fe5					ld a, (input_cur_flash) 
0fe5					dec a 
0fe5					ld (input_cur_flash), a 
0fe5					cp 0 
0fe5					jr nz, .nochgstate 
0fe5			 
0fe5			 
0fe5					; change state 
0fe5					ld a,(input_cur_onoff) 
0fe5					neg 
0fe5					ld (input_cur_onoff),a 
0fe5			 
0fe5			 
0fe5					; reset on change of state 
0fe5					ld a, CUR_BLINK_RATE 
0fe5					ld (input_cur_flash), a 
0fe5			 
0fe5			.nochgstate: 
0fe5					 
0fe5					 
0fe5			 
0fe5					; display cursor  
0fe5			 
0fe5			;		ld hl, (input_start) 
0fe5			;		ld a, (input_cursor) 
0fe5			;		call addatohl 
0fe5			 
0fe5					; get char under cursor and replace with cursor 
0fe5			ld hl, (input_ptr) 
0fe5			;		ld a, (hl) 
0fe5			;		ld (input_under_cursor),a 
0fe5			;		ld a, '_' 
0fe5			;		ld (hl), a 
0fe5			 
0fe5					; display string 
0fe5			 
0fe5					ld de, (input_start) 
0fe5					ld a, (input_at_pos) 
0fe5					call str_at_display 
0fe5			;	        call update_display 
0fe5			 
0fe5					; find place to put the cursor 
0fe5			;		add h 
0fe5			;		ld l, display_row_1 
0fe5			;		sub l 
0fe5			; (input_at_pos) 
0fe5					;ld c, a 
0fe5			;		ld a, (input_cursor) 
0fe5			;		ld l, (input_at_pos) 
0fe5			;		;ld b, h 
0fe5			;		add l 
0fe5			;		ld (input_at_cursor),a 
0fe5					;ld l,h 
0fe5			 
0fe5			;		ld h, 0 
0fe5			;		ld l,(input_at_pos) 
0fe5			;		ld a, (input_cursor) 
0fe5			;		call addatohl 
0fe5			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0fe5			;		call subafromhl 
0fe5			;		ld a,l 
0fe5			;		ld (input_at_cursor), a 
0fe5			 
0fe5				if DEBUG_INPUT 
0fe5					ld a, (hardware_diag) 
0fe5					cp 0 
0fe5					jr z, .skip_input_diag 
0fe5			 
0fe5					ld a,(input_at_pos) 
0fe5					ld hl, LFSRSeed 
0fe5					call hexout 
0fe5					ld a, (input_cursor) 
0fe5					ld hl, LFSRSeed+2 
0fe5					call hexout 
0fe5					ld a,(input_at_cursor) 
0fe5					ld hl, LFSRSeed+4 
0fe5					call hexout 
0fe5			 
0fe5					ld a,(input_cur_onoff) 
0fe5					ld hl, LFSRSeed+6 
0fe5					call hexout 
0fe5			 
0fe5					ld a,(input_cur_flash) 
0fe5					ld hl, LFSRSeed+8 
0fe5					call hexout 
0fe5			 
0fe5					ld a,(input_len) 
0fe5					ld hl, LFSRSeed+10 
0fe5					call hexout 
0fe5					ld hl, LFSRSeed+12 
0fe5					ld a, 0 
0fe5					ld (hl),a 
0fe5					ld a, display_row_4 
0fe5					ld de, LFSRSeed 
0fe5					call str_at_display 
0fe5					.skip_input_diag: 
0fe5				endif 
0fe5			 
0fe5					; decide on if we are showing the cursor this time round 
0fe5			 
0fe5					ld a, (input_cur_onoff) 
0fe5					cp 255 
0fe5					jr z, .skipcur 
0fe5			 
0fe5			 
0fe5					ld a,(input_at_cursor) 
0fe5					ld de, cursor_shape 
0fe5					call str_at_display 
0fe5			 
0fe5					; save length of current input string 
0fe5					ld hl, (input_start) 
0fe5					ld a, 0 
0fe5					call strlent 
0fe5					ld a,l 
0fe5					ld (input_len),a 
0fe5			 
0fe5			.skipcur: 
0fe5			 
0fe5				        call update_display 
0fe5					 
0fe5			 
0fe5			 
0fe5					; wait 
0fe5				 
0fe5					; TODO loop without wait to flash the cursor and char under cursor	 
0fe5					call cin    ; _wait 
0fe5			 
0fe5					cp 0 
0fe5					jp z, .is1 
0fe5			 
0fe5					; get ptr to char to input into 
0fe5			 
0fe5					ld c,a 
0fe5					ld hl, (input_start) 
0fe5					ld a, (input_cursor) 
0fe5					call addatohl 
0fe5					ld (input_ptr), hl 
0fe5					ld a,c 
0fe5			 
0fe5					; replace char under cursor 
0fe5			 
0fe5			;		ld hl, (input_ptr) 
0fe5			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0fe5			;		ld (hl), a 
0fe5			 
0fe5			;	if DEBUG_INPUT 
0fe5			;		push af 
0fe5			;		ld a, 'i' 
0fe5			;		ld (debug_mark),a 
0fe5			;		pop af 
0fe5			;		CALLMONITOR 
0fe5			;	endif 
0fe5					cp KEY_HOME 
0fe5					jr nz, .iske 
0fe5			 
0fe5					ld a, (input_at_pos) 
0fe5					ld (input_at_cursor),a 
0fe5					ld a, 0 
0fe5					ld (input_cursor), a 
0fe5					jp .is1 
0fe5					 
0fe5			.iske:		cp KEY_END 
0fe5					jr nz, .isknw 
0fe5					jp .is1 
0fe5			 
0fe5			.isknw:		cp KEY_NEXTWORD 
0fe5					jr nz, .iskpw 
0fe5			 
0fe5			.isknwm:	ld hl, (input_ptr) 
0fe5					ld a,(hl)	 
0fe5					cp 0 
0fe5					jp z, .is1    ; end of string 
0fe5					cp ' ' 
0fe5					jp z, .is1    ; end of word 
0fe5					inc hl 
0fe5					ld (input_ptr), hl 
0fe5					ld a, (input_at_cursor) 
0fe5					inc a 
0fe5					ld (input_at_cursor), a 
0fe5					jr .isknwm 
0fe5			 
0fe5			.iskpw:		cp KEY_PREVWORD 
0fe5					jr nz, .iskl 
0fe5			.iskpwm:	 
0fe5					ld hl, (input_ptr) 
0fe5					ld a,(hl)	 
0fe5					cp 0  
0fe5					jp z, .is1    ; end of string 
0fe5					cp ' ' 
0fe5					jp z, .is1    ; end of word 
0fe5					dec hl 
0fe5					ld (input_ptr), hl 
0fe5					ld a, (input_at_cursor) 
0fe5					dec a 
0fe5					ld (input_at_cursor), a 
0fe5					jr .iskpwm 
0fe5			 
0fe5			 
0fe5			.iskl:		cp KEY_LEFT 
0fe5					jr nz, .isk1 
0fe5			 
0fe5					ld a, (input_cursor) 
0fe5			 
0fe5					cp 0 
0fe5					jp z, .is1 		; at start of line to ignore  
0fe5			 
0fe5					dec  a 		; TODO check underflow 
0fe5					ld (input_cursor), a 
0fe5			 
0fe5					ld hl, (input_ptr) 
0fe5					dec hl 
0fe5					ld (input_ptr), hl 
0fe5					 
0fe5					ld a, (input_at_cursor) 
0fe5					dec a 
0fe5					ld (input_at_cursor), a 
0fe5			 
0fe5					ld a, 1		; show cursor moving 
0fe5					ld (input_cur_onoff),a 
0fe5					ld a, CUR_BLINK_RATE 
0fe5					ld (input_cur_flash), a 
0fe5			 
0fe5					jp .is1 
0fe5			 
0fe5			.isk1:		cp KEY_RIGHT 
0fe5					jr nz, .isk2 
0fe5			 
0fe5					ld a,(input_len)		; TODO BUG why cant i load e direct? 
0fe5					ld e,a 
0fe5					ld a, (input_cursor) 
0fe5					cp e 
0fe5					jp z, .is1		; at the end of string so dont go right 
0fe5			 
0fe5					inc  a 		; TODO check overflow 
0fe5					ld (input_cursor), a 
0fe5			 
0fe5					ld a, (input_at_cursor) 
0fe5					inc a 
0fe5					ld (input_at_cursor), a 
0fe5			 
0fe5					ld hl, (input_ptr) 
0fe5					inc hl 
0fe5					ld (input_ptr), hl 
0fe5			 
0fe5					ld a, 1		; show cursor moving 
0fe5					ld (input_cur_onoff),a 
0fe5					ld a, CUR_BLINK_RATE 
0fe5					ld (input_cur_flash), a 
0fe5			 
0fe5					jp .is1 
0fe5			 
0fe5			.isk2:		cp KEY_UP 
0fe5			 
0fe5					jr nz, .isk3 
0fe5			 
0fe5					; swap last command with the current on 
0fe5			 
0fe5					; move cursor to start of string 
0fe5					ld hl, (input_start) 
0fe5					ld (input_ptr), hl 
0fe5			 
0fe5					ld a, (input_at_pos) 
0fe5					ld (input_at_cursor), a 
0fe5			 
0fe5					ld a, 0 
0fe5					ld (input_cursor), a 
0fe5					 
0fe5					; swap input and last command buffers 
0fe5			 
0fe5					ld hl, os_cli_cmd 
0fe5					ld de, os_last_cmd 
0fe5					ld b, 255 
0fe5			.swap1:		ld a, (hl) 
0fe5					ld c,a 
0fe5					ld a, (de) 
0fe5					ld (hl), a 
0fe5					ld a,c 
0fe5					ld (de),a 
0fe5					inc hl 
0fe5					inc de 
0fe5					djnz .swap1 
0fe5			 
0fe5			 
0fe5			 
0fe5			 
0fe5			 
0fe5					jp .is1 
0fe5			 
0fe5			.isk3:		cp KEY_BS 
0fe5					jr nz, .isk4 
0fe5			 
0fe5					ld a, (input_cursor) 
0fe5			 
0fe5					cp 0 
0fe5					jp z, .is1 		; at start of line to ignore  
0fe5			 
0fe5					dec  a 		; TODO check underflow 
0fe5					ld (input_cursor), a 
0fe5			 
0fe5					; hl is source 
0fe5					; de needs to be source - 1 
0fe5			 
0fe5			;		ld a, 0 
0fe5			;		dec hl 
0fe5			;		ld (hl), a 
0fe5			 
0fe5					ld hl, (input_ptr) 
0fe5					dec hl 
0fe5					ld (input_ptr), hl 
0fe5			 
0fe5					; shift all data 
0fe5			 
0fe5					push hl 
0fe5					inc hl 
0fe5					pop de 
0fe5					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0fe5					ld c,a 
0fe5					ld b,0 
0fe5					ldir  
0fe5			 
0fe5			 
0fe5			 
0fe5			 
0fe5					ld a, (input_at_cursor) 
0fe5					dec a 
0fe5					ld (input_at_cursor), a 
0fe5			 
0fe5			 
0fe5					ld a, 1		; show cursor moving 
0fe5					ld (input_cur_onoff),a 
0fe5					ld a, CUR_BLINK_RATE 
0fe5					ld (input_cur_flash), a 
0fe5			 
0fe5					; remove char 
0fe5					ld a, (input_at_cursor) 
0fe5					inc a 
0fe5					ld de,.iblank 
0fe5					call str_at_display 
0fe5			 
0fe5					jp .is1 
0fe5			 
0fe5			.isk4:		cp KEY_CR 
0fe5					jr z, .endinput 
0fe5			 
0fe5					; else add the key press to the end 
0fe5			 
0fe5					ld c, a			; save key pressed 
0fe5			 
0fe5					ld a,(hl)		; get what is currently under char 
0fe5			 
0fe5					cp 0			; we are at the end of the string 
0fe5					jr nz, .onchar 
0fe5					 
0fe5					; add a char to the end of the string 
0fe5				 
0fe5					ld (hl),c 
0fe5					inc hl 
0fe5			;		ld a,' ' 
0fe5			;		ld (hl),a 
0fe5			;		inc hl 
0fe5					ld a,0 
0fe5					ld (hl),a 
0fe5					dec hl 
0fe5			 
0fe5					ld a, (input_cursor) 
0fe5					inc a				; TODO check max string length and scroll  
0fe5					ld (input_cursor), a		; inc cursor pos 
0fe5							 
0fe5					ld a, (input_at_cursor) 
0fe5					inc a 
0fe5					ld (input_at_cursor), a 
0fe5			 
0fe5					ld hl, (input_ptr) 
0fe5					inc hl 
0fe5					ld (input_ptr), hl 
0fe5			 
0fe5					ld hl, (input_ptr) 
0fe5					inc hl 
0fe5					ld (input_ptr), hl 
0fe5			;	if DEBUG_INPUT 
0fe5			;		push af 
0fe5			;		ld a, '+' 
0fe5			;		ld (debug_mark),a 
0fe5			;		pop af 
0fe5			;		CALLMONITOR 
0fe5			;	endif 
0fe5					ld a, 1		; show cursor moving 
0fe5					ld (input_cur_onoff),a 
0fe5					ld a, CUR_BLINK_RATE 
0fe5					ld (input_cur_flash), a 
0fe5					jp .is1 
0fe5					 
0fe5			 
0fe5			 
0fe5					; if on a char then insert 
0fe5			.onchar: 
0fe5			 
0fe5					; TODO over flow check: make sure insert does not blow out buffer 
0fe5			 
0fe5					; need to do some maths to use lddr 
0fe5			 
0fe5					push hl   ; save char pos 
0fe5					push bc 
0fe5			 
0fe5					ld hl, (input_start) 
0fe5					ld a, (input_len) 
0fe5					call addatohl  		; end of string 
0fe5					inc hl 
0fe5					inc hl		; past zero term 
0fe5					push hl 
0fe5					inc hl 
0fe5					push hl  
0fe5			 
0fe5								; start and end of lddr set, now how much to move? 
0fe5			 
0fe5							 
0fe5					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0fe5					ld b,a 
0fe5					ld a,(input_len) 
0fe5					ld e,a 
0fe5					sub b 
0fe5					inc a		;?? 
0fe5					inc a		;?? 
0fe5					inc a		;?? 
0fe5			 
0fe5					ld b,0 
0fe5					ld c,a 
0fe5			 
0fe5				if DEBUG_INPUT 
0fe5					push af 
0fe5					ld a, 'i' 
0fe5					ld (debug_mark),a 
0fe5					pop af 
0fe5			;		CALLMONITOR 
0fe5				endif 
0fe5					pop de 
0fe5					pop hl 
0fe5				if DEBUG_INPUT 
0fe5					push af 
0fe5					ld a, 'I' 
0fe5					ld (debug_mark),a 
0fe5					pop af 
0fe5			;		CALLMONITOR 
0fe5				endif 
0fe5					lddr 
0fe5				 
0fe5			 
0fe5			 
0fe5					; TODO have a key for insert/overwrite mode???? 
0fe5					pop bc 
0fe5					pop hl 
0fe5					ld (hl), c		; otherwise overwrite current char 
0fe5					 
0fe5			 
0fe5			 
0fe5			 
0fe5					ld a, (input_cursor) 
0fe5					inc  a 		; TODO check overflow 
0fe5					ld (input_cursor), a 
0fe5			 
0fe5					ld a, (input_at_cursor) 
0fe5					inc a 
0fe5					ld (input_at_cursor), a 
0fe5			 
0fe5					jp .is1 
0fe5			 
0fe5			.endinput:	; TODO look for end of string 
0fe5			 
0fe5					; add trailing space for end of token 
0fe5			 
0fe5					ld hl, (input_start) 
0fe5					ld a,(input_len) 
0fe5					call addatohl 
0fe5					ld a, ' ' 
0fe5					ld (hl),a 
0fe5					; TODO eof of parse marker 
0fe5			 
0fe5					inc hl 
0fe5					ld a, 0 
0fe5					ld (hl),a 
0fe5			 
0fe5			 
0fe5					ret 
0fe5			 
0fe5			.iblank: db " ",0 
0fe5			 
0fe5			 
0fe5			input_str_prev:	ld (input_at_pos), a 
0fe5					ld (input_start), hl 
0fe5					ld a,1			; add cursor 
0fe5					ld (hl),a 
0fe5					inc hl 
0fe5					ld a,0 
0fe5					ld (hl),a 
0fe5					ld (input_ptr), hl 
0fe5					ld a,d 
0fe5					ld (input_size), a 
0fe5					ld a,0 
0fe5					ld (input_cursor),a 
0fe5			.instr1:	 
0fe5			 
0fe5					; TODO do block cursor 
0fe5					; TODO switch cursor depending on the modifer key 
0fe5			 
0fe5					; update cursor shape change on key hold 
0fe5			 
0fe5					ld hl, (input_ptr) 
0fe5					dec hl 
0fe5					ld a,(cursor_shape) 
0fe5					ld (hl), a 
0fe5			 
0fe5					; display entered text 
0fe5					ld a,(input_at_pos) 
0fe5			            	CALL fLCD_Pos       ;Position cursor to location in A 
0fe5			            	LD   de, (input_start) 
0fe5			            	CALL fLCD_Str       ;Display string pointed to by DE 
0fe5			 
0fe5					call cin 
0fe5					cp 0 
0fe5					jr z, .instr1 
0fe5			 
0fe5					; proecess keyboard controls first 
0fe5			 
0fe5					ld hl,(input_ptr) 
0fe5			 
0fe5					cp KEY_CR	 ; pressing enter ends input 
0fe5					jr z, .instrcr 
0fe5			 
0fe5					cp KEY_BS 	; back space 
0fe5					jr nz, .instr2 
0fe5					; process back space 
0fe5			 
0fe5					; TODO stop back space if at start of string 
0fe5					dec hl 
0fe5					dec hl ; to over write cursor 
0fe5					ld a,(cursor_shape) 
0fe5					;ld a,0 
0fe5					ld (hl),a 
0fe5					inc hl 
0fe5					ld a," " 
0fe5					ld (hl),a 
0fe5					ld (input_ptr),hl 
0fe5					 
0fe5			 
0fe5					jr .instr1 
0fe5			 
0fe5			.instr2:	cp KEY_LEFT    ; cursor left 
0fe5					jr nz, .instr3 
0fe5					dec hl 
0fe5					ld (input_ptr),hl 
0fe5					jr .instr1 
0fe5				 
0fe5			.instr3:	cp KEY_RIGHT      ; cursor right 
0fe5					jr nz, .instr4 
0fe5					inc hl 
0fe5					ld (input_ptr),hl 
0fe5					jr .instr1 
0fe5			 
0fe5			.instr4:	cp KEY_HOME    ; jump to start of line 
0fe5					jr nz, .instr5 
0fe5					dec hl 
0fe5					ld (input_ptr),hl 
0fe5					jr .instr1 
0fe5			 
0fe5			.instr5:	cp KEY_END     ; jump to end of line 
0fe5					jr nz, .instr6 
0fe5					dec hl 
0fe5					ld (input_ptr),hl 
0fe5					jr .instr1 
0fe5			.instr6:        cp KEY_UP      ; recall last command 
0fe5					jr nz, .instrnew 
0fe5			 
0fe5				ld hl, scratch 
0fe5				ld de, os_last_cmd 
0fe5				call strcpy 
0fe5					jr .instr1 
0fe5			 
0fe5			 
0fe5			.instrnew:	; no special key pressed to see if we have room to store it 
0fe5			 
0fe5					; TODO do string size test 
0fe5			 
0fe5					dec hl ; to over write cursor 
0fe5					ld (hl),a 
0fe5					inc hl 
0fe5					ld a,(cursor_shape) 
0fe5					ld (hl),a 
0fe5					inc hl 
0fe5					ld a,0 
0fe5					ld (hl),a 
0fe5			 
0fe5					ld (input_ptr),hl 
0fe5					 
0fe5					jr .instr1 
0fe5			.instrcr:	dec hl		; remove cursor 
0fe5					ld a,' '	; TODO add a trailing space for safety 
0fe5					ld (hl),a 
0fe5					inc hl 
0fe5					ld a,0 
0fe5					ld (hl),a 
0fe5			 
0fe5			 
0fe5					; if at end of line scroll up    
0fe5					; TODO detecting only end of line 4 for scroll up  
0fe5			 
0fe5					;ld   
0fe5			 
0fe5					ret 
0fe5			 
0fe5			 
0fe5			endif 
0fe5			; strcpy hl = dest, de source 
0fe5			 
0fe5 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0fe6 b7			            OR   A              ;Null terminator? 
0fe7 c8			            RET  Z              ;Yes, so finished 
0fe8 1a					ld a,(de) 
0fe9 77					ld (hl),a 
0fea 13			            INC  DE             ;Point to next character 
0feb 23					inc hl 
0fec 18 f7		            JR   strcpy       ;Repeat 
0fee c9					ret 
0fef			 
0fef			 
0fef			; TODO string_at  
0fef			; pass string which starts with lcd offset address and then null term string 
0fef			 
0fef			; TODO string to dec 
0fef			; TODO string to hex 
0fef			; TODO byte to string hex 
0fef			; TODO byte to string dec 
0fef			 
0fef			 
0fef			 
0fef			; from z80uartmonitor 
0fef			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fef			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0fef			; pass hl for where to put the text 
0fef			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fef c5			hexout:	PUSH BC 
0ff0 f5					PUSH AF 
0ff1 47					LD B, A 
0ff2					; Upper nybble 
0ff2 cb 3f				SRL A 
0ff4 cb 3f				SRL A 
0ff6 cb 3f				SRL A 
0ff8 cb 3f				SRL A 
0ffa cd 0a 10				CALL tohex 
0ffd 77					ld (hl),a 
0ffe 23					inc hl	 
0fff					 
0fff					; Lower nybble 
0fff 78					LD A, B 
1000 e6 0f				AND 0FH 
1002 cd 0a 10				CALL tohex 
1005 77					ld (hl),a 
1006 23					inc hl	 
1007					 
1007 f1					POP AF 
1008 c1					POP BC 
1009 c9					RET 
100a					 
100a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
100a			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
100a			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
100a			tohex: 
100a e5					PUSH HL 
100b d5					PUSH DE 
100c 16 00				LD D, 0 
100e 5f					LD E, A 
100f 21 17 10				LD HL, .DATA 
1012 19					ADD HL, DE 
1013 7e					LD A, (HL) 
1014 d1					POP DE 
1015 e1					POP HL 
1016 c9					RET 
1017			 
1017			.DATA: 
1017 30					DEFB	30h	; 0 
1018 31					DEFB	31h	; 1 
1019 32					DEFB	32h	; 2 
101a 33					DEFB	33h	; 3 
101b 34					DEFB	34h	; 4 
101c 35					DEFB	35h	; 5 
101d 36					DEFB	36h	; 6 
101e 37					DEFB	37h	; 7 
101f 38					DEFB	38h	; 8 
1020 39					DEFB	39h	; 9 
1021 41					DEFB	41h	; A 
1022 42					DEFB	42h	; B 
1023 43					DEFB	43h	; C 
1024 44					DEFB	44h	; D 
1025 45					DEFB	45h	; E 
1026 46					DEFB	46h	; F 
1027			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1027			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
1027			;;    subtract $30, if result > 9 then subtract $7 more 
1027			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
1027			atohex: 
1027 d6 30				SUB $30 
1029 fe 0a				CP 10 
102b f8					RET M		; If result negative it was 0-9 so we're done 
102c d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
102e c9					RET		 
102f			 
102f			 
102f			 
102f			 
102f			; Get 2 ASCII characters as hex byte from pointer in hl 
102f			 
102f			BYTERD: 
102f 16 00			LD	D,00h		;Set up 
1031 cd 39 10			CALL	HEXCON		;Get byte and convert to hex 
1034 87				ADD	A,A		;First nibble so 
1035 87				ADD	A,A		;multiply by 16 
1036 87				ADD	A,A		; 
1037 87				ADD	A,A		; 
1038 57				LD	D,A		;Save hi nibble in D 
1039			HEXCON: 
1039 7e				ld a, (hl)		;Get next chr 
103a 23				inc hl 
103b d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
103d fe 0a			CP	00Ah		;Is it 0-9 ? 
103f 38 02			JR	C,NALPHA	;If so miss next bit 
1041 d6 07			SUB	007h		;Else convert alpha 
1043			NALPHA: 
1043 b2				OR	D		;Add hi nibble back 
1044 c9				RET			; 
1045			 
1045			 
1045			; 
1045			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
1045			; Since the routines get_byte and therefore get_nibble are called, only valid 
1045			; characters (0-9a-f) are accepted. 
1045			; 
1045			;get_word        push    af 
1045			;                call    get_byte        ; Get the upper byte 
1045			;                ld      h, a 
1045			;                call    get_byte        ; Get the lower byte 
1045			;                ld      l, a 
1045			;                pop     af 
1045			;                ret 
1045			; 
1045			; Get a byte in hexadecimal notation. The result is returned in A. Since 
1045			; the routine get_nibble is used only valid characters are accepted - the  
1045			; input routine only accepts characters 0-9a-f. 
1045			; 
1045 c5			get_byte:        push    bc              ; Save contents of B (and C) 
1046 7e					ld a,(hl) 
1047 23					inc hl 
1048 cd 6d 10		                call    nibble2val      ; Get upper nibble 
104b cb 07		                rlc     a 
104d cb 07		                rlc     a 
104f cb 07		                rlc     a 
1051 cb 07		                rlc     a 
1053 47			                ld      b, a            ; Save upper four bits 
1054 7e					ld a,(hl) 
1055 cd 6d 10		                call    nibble2val      ; Get lower nibble 
1058 b0			                or      b               ; Combine both nibbles 
1059 c1			                pop     bc              ; Restore B (and C) 
105a c9			                ret 
105b			; 
105b			; Get a hexadecimal digit from the serial line. This routine blocks until 
105b			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
105b			; to the serial line interface. The lower 4 bits of A contain the value of  
105b			; that particular digit. 
105b			; 
105b			;get_nibble      ld a,(hl)           ; Read a character 
105b			;                call    to_upper        ; Convert to upper case 
105b			;                call    is_hex          ; Was it a hex digit? 
105b			;                jr      nc, get_nibble  ; No, get another character 
105b			 ;               call    nibble2val      ; Convert nibble to value 
105b			 ;               call    print_nibble 
105b			 ;               ret 
105b			; 
105b			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
105b			; A valid hexadecimal digit is denoted by a set C flag. 
105b			; 
105b			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
105b			;                ret     nc              ; Yes 
105b			;                cp      '0'             ; Less than '0'? 
105b			;                jr      nc, is_hex_1    ; No, continue 
105b			;                ccf                     ; Complement carry (i.e. clear it) 
105b			;                ret 
105b			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
105b			;                ret     c               ; Yes 
105b			;                cp      'A'             ; Less than 'A'? 
105b			;                jr      nc, is_hex_2    ; No, continue 
105b			;                ccf                     ; Yes - clear carry and return 
105b			;                ret 
105b			;is_hex_2        scf                     ; Set carry 
105b			;                ret 
105b			; 
105b			; Convert a single character contained in A to upper case: 
105b			; 
105b fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
105d d8			                ret     c 
105e fe 7b		                cp      'z' + 1         ; > 'z'? 
1060 d0			                ret     nc              ; Nothing to do, either 
1061 e6 5f		                and     $5f             ; Convert to upper case 
1063 c9			                ret 
1064			 
1064			 
1064			to_lower: 
1064			 
1064			   ; if char is in [A-Z] make it lower case 
1064			 
1064			   ; enter : a = char 
1064			   ; exit  : a = lower case char 
1064			   ; uses  : af 
1064			 
1064 fe 41		   cp 'A' 
1066 d8			   ret c 
1067			    
1067 fe 5b		   cp 'Z'+1 
1069 d0			   ret nc 
106a			    
106a f6 20		   or $20 
106c c9			   ret 
106d			 
106d			; 
106d			; Expects a hexadecimal digit (upper case!) in A and returns the 
106d			; corresponding value in A. 
106d			; 
106d fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
106f 38 02		                jr      c, nibble2val_1 ; Yes 
1071 d6 07		                sub     7               ; Adjust for A-F 
1073 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
1075 e6 0f		                and     $f              ; Only return lower 4 bits 
1077 c9			                ret 
1078			; 
1078			; Print_nibble prints a single hex nibble which is contained in the lower  
1078			; four bits of A: 
1078			; 
1078			;print_nibble    push    af              ; We won't destroy the contents of A 
1078			;                and     $f              ; Just in case... 
1078			;                add     a, '0'             ; If we have a digit we are done here. 
1078			;                cp      '9' + 1         ; Is the result > 9? 
1078			;                jr      c, print_nibble_1 
1078			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1078			;print_nibble_1  call    putc            ; Print the nibble and 
1078			;                pop     af              ; restore the original value of A 
1078			;                ret 
1078			;; 
1078			;; Send a CR/LF pair: 
1078			; 
1078			;crlf            push    af 
1078			;                ld      a, cr 
1078			;                call    putc 
1078			;                ld      a, lf 
1078			;                call    putc 
1078			;                pop     af 
1078			;                ret 
1078			; 
1078			; Print_word prints the four hex digits of a word to the serial line. The  
1078			; word is expected to be in HL. 
1078			; 
1078			;print_word      push    hl 
1078			;                push    af 
1078			;                ld      a, h 
1078			;                call    print_byte 
1078			;                ld      a, l 
1078			;                call    print_byte 
1078			;                pop     af 
1078			;                pop     hl 
1078			;                ret 
1078			; 
1078			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1078			; The byte to be printed is expected to be in A. 
1078			; 
1078			;print_byte      push    af              ; Save the contents of the registers 
1078			;                push    bc 
1078			;                ld      b, a 
1078			;                rrca 
1078			;                rrca 
1078			;                rrca 
1078			;                rrca 
1078			;                call    print_nibble    ; Print high nibble 
1078			;                ld      a, b 
1078			;                call    print_nibble    ; Print low nibble 
1078			;                pop     bc              ; Restore original register contents 
1078			;                pop     af 
1078			;                ret 
1078			 
1078			 
1078			 
1078			 
1078			 
1078			fourehexhl:  
1078 7e				ld a,(hl) 
1079 cd 27 10			call atohex 
107c cb 3f				SRL A 
107e cb 3f				SRL A 
1080 cb 3f				SRL A 
1082 cb 3f				SRL A 
1084 47				ld b, a 
1085 23				inc hl 
1086 7e				ld a,(hl) 
1087 23				inc hl 
1088 cd 27 10			call atohex 
108b 80				add b 
108c 57				ld d,a 
108d 7e				ld a,(hl) 
108e cd 27 10			call atohex 
1091 cb 3f				SRL A 
1093 cb 3f				SRL A 
1095 cb 3f				SRL A 
1097 cb 3f				SRL A 
1099 47				ld b, a 
109a 23				inc hl 
109b 7e				ld a,(hl) 
109c 23				inc hl 
109d cd 27 10			call atohex 
10a0 80				add b 
10a1 5f				ld e, a 
10a2 d5				push de 
10a3 e1				pop hl 
10a4 c9				ret 
10a5			 
10a5			; pass hl. returns z set if the byte at hl is a digit 
10a5			;isdigithl:  
10a5			;	push bc 
10a5			;	ld a,(hl) 
10a5			;	cp ':' 
10a5			;	jr nc, .isdf 		; > 
10a5			;	cp '0' 
10a5			;	jr c, .isdf		; < 
10a5			; 
10a5			;	; TODO find a better way to set z 
10a5			; 
10a5			;	ld b,a 
10a5			;	cp b 
10a5			;	pop bc 
10a5			;	ret 
10a5			; 
10a5			;.isdf:	; not digit so clear z 
10a5			; 
10a5			;	; TODO find a better way to unset z 
10a5			; 
10a5			;	ld b,a 
10a5			;	inc b 
10a5			;	cp b 
10a5			; 
10a5			;	pop bc 
10a5			;	ret 
10a5				 
10a5				 
10a5			 
10a5			 
10a5			; pass hl as the four byte address to load 
10a5			 
10a5			get_word_hl:  
10a5 e5				push hl 
10a6 cd 45 10			call get_byte 
10a9				 
10a9 47				ld b, a 
10aa			 
10aa e1				pop hl 
10ab 23				inc hl 
10ac 23				inc hl 
10ad			 
10ad			; TODO not able to handle a-f  
10ad 7e				ld a,(hl) 
10ae			;	;cp ':' 
10ae			;	cp 'g' 
10ae			;	jr nc, .single_byte_hl 		; > 
10ae			;	cp 'G' 
10ae			;	jr nc, .single_byte_hl 		; > 
10ae			;	cp '0' 
10ae			;	jr c, .single_byte_hl		; < 
10ae			 
10ae				;call isdigithl 
10ae fe 00			cp 0 
10b0 28 06			jr z, .single_byte_hl 
10b2			 
10b2			.getwhln:   ; hex word so get next byte 
10b2			 
10b2 cd 45 10			call get_byte 
10b5 6f				ld l, a 
10b6 60				ld h,b 
10b7 c9				ret 
10b8 68			.single_byte_hl:   ld l,b 
10b9 26 00				ld h,0 
10bb c9					ret 
10bc			 
10bc			 
10bc			 
10bc			 
10bc 21 5c 18			ld hl,asc+1 
10bf			;	ld a, (hl) 
10bf			;	call nibble2val 
10bf cd 45 10			call get_byte 
10c2			 
10c2			;	call fourehexhl 
10c2 32 f5 e2			ld (scratch+52),a 
10c5				 
10c5 21 f3 e2			ld hl,scratch+50 
10c8 22 e4 e5			ld (os_cur_ptr),hl 
10cb			 
10cb c9				ret 
10cc			 
10cc			 
10cc			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
10cc			 
10cc			; Decimal Unsigned Version 
10cc			 
10cc			;Number in a to decimal ASCII 
10cc			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
10cc			;Example: display a=56 as "056" 
10cc			;input: a = number 
10cc			;Output: a=0,value of a in the screen 
10cc			;destroys af,bc (don't know about hl and de) 
10cc			DispAToASCII: 
10cc 0e 9c			ld	c,-100 
10ce cd d8 10			call	.Na1 
10d1 0e f6			ld	c,-10 
10d3 cd d8 10			call	.Na1 
10d6 0e ff			ld	c,-1 
10d8 06 2f		.Na1:	ld	b,'0'-1 
10da 04			.Na2:	inc	b 
10db 81				add	a,c 
10dc 38 fc			jr	c,.Na2 
10de 91				sub	c		;works as add 100/10/1 
10df f5				push af		;safer than ld c,a 
10e0 78				ld	a,b		;char is in b 
10e1			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
10e1 f1				pop af		;safer than ld a,c 
10e2 c9				ret 
10e3			 
10e3			; Decimal Signed Version 
10e3			 
10e3			; DispA 
10e3			; -------------------------------------------------------------- 
10e3			; Converts a signed integer value to a zero-terminated ASCII 
10e3			; string representative of that value (using radix 10). 
10e3			; -------------------------------------------------------------- 
10e3			; INPUTS: 
10e3			;     HL     Value to convert (two's complement integer). 
10e3			;     DE     Base address of string destination. (pointer). 
10e3			; -------------------------------------------------------------- 
10e3			; OUTPUTS: 
10e3			;     None 
10e3			; -------------------------------------------------------------- 
10e3			; REGISTERS/MEMORY DESTROYED 
10e3			; AF HL 
10e3			; -------------------------------------------------------------- 
10e3			 
10e3			;DispHLToASCII: 
10e3			;   push    de 
10e3			;   push    bc 
10e3			; 
10e3			;; Detect sign of HL. 
10e3			;    bit    7, h 
10e3			;    jr     z, ._DoConvert 
10e3			; 
10e3			;; HL is negative. Output '-' to string and negate HL. 
10e3			;    ld     a, '-' 
10e3			;    ld     (de), a 
10e3			;    inc    de 
10e3			; 
10e3			;; Negate HL (using two's complement) 
10e3			;    xor    a 
10e3			;    sub    l 
10e3			;    ld     l, a 
10e3			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
10e3			;    sbc    a, h 
10e3			;    ld     h, a 
10e3			; 
10e3			;; Convert HL to digit characters 
10e3			;._DoConvert: 
10e3			;    ld     b, 0     ; B will count character length of number 
10e3			;-   ld     a, 10 
10e3			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
10e3			;    push   af 
10e3			;    inc    b 
10e3			;    ld     a, h 
10e3			;    or     l 
10e3			;    jr     nz, - 
10e3			; 
10e3			;; Retrieve digits from stack 
10e3			;-   pop    af 
10e3			;    or     $30 
10e3			;    ld     (de), a 
10e3			;    inc    de 
10e3			;    djnz   - 
10e3			; 
10e3			;; Terminate string with NULL 
10e3			;    xor    a 
10e3			;    ld     (de), a 
10e3			; 
10e3			;    pop    bc 
10e3			;    pop    de 
10e3			;    ret 
10e3			 
10e3			;Comments 
10e3			; 
10e3			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
10e3			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
10e3			;    Note that the output string will not be fixed-width. 
10e3			; 
10e3			;Example Usage 
10e3			; 
10e3			;    ld    hl, -1004 
10e3			;    ld    de, OP1 
10e3			;    call  DispA 
10e3			;    ld    hl, OP1 
10e3			;    syscall  PutS 
10e3			 
10e3			 
10e3			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10e3			 
10e3			 
10e3			;Converts an ASCII string to an unsigned 16-bit integer 
10e3			;Quits when it reaches a non-decimal digit 
10e3			 
10e3			string_to_uint16: 
10e3			atoui_16: 
10e3			;Input: 
10e3			;     DE points to the string 
10e3			;Outputs: 
10e3			;     HL is the result 
10e3			;     A is the 8-bit value of the number 
10e3			;     DE points to the byte after the number 
10e3			;Destroys: 
10e3			;     BC 
10e3			;       if the string is non-empty, BC is HL/10 
10e3			;Size:  24 bytes 
10e3			;Speed: 42+d(104+{0,9}) 
10e3			;       d is the number of digits in the number 
10e3			;       max is 640 cycles for a 5 digit number 
10e3			;Assuming no leading zeros: 
10e3			;1 digit:  146cc 
10e3			;2 digit:  250cc 
10e3			;3 digit:  354cc or 363cc (avg: 354.126cc) 
10e3			;4 digit:  458cc or 467cc (avg: 458.27cc) 
10e3			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
10e3			;avg: 544.81158447265625cc (544+13297/16384) 
10e3			;=============================================================== 
10e3 21 00 00		  ld hl,0 
10e6			.u16a: 
10e6 1a			  ld a,(de) 
10e7 d6 30		  sub 30h 
10e9 fe 0a		  cp 10 
10eb d0			  ret nc 
10ec 13			  inc de 
10ed 44			  ld b,h 
10ee 4d			  ld c,l 
10ef 29			  add hl,hl 
10f0 29			  add hl,hl 
10f1 09			  add hl,bc 
10f2 29			  add hl,hl 
10f3 85			  add a,l 
10f4 6f			  ld l,a 
10f5 30 ef		  jr nc,.u16a 
10f7 24			  inc h 
10f8 c3 e6 10		  jp .u16a 
10fb			 
10fb			 
10fb			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
10fb			 
10fb			;written by Zeda 
10fb			;Converts a 16-bit unsigned integer to an ASCII string. 
10fb			 
10fb			uitoa_16: 
10fb			;Input: 
10fb			;   DE is the number to convert 
10fb			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
10fb			;Output: 
10fb			;   HL points to the null-terminated ASCII string 
10fb			;      NOTE: This isn't necessarily the same as the input HL. 
10fb d5			  push de 
10fc c5			  push bc 
10fd f5			  push af 
10fe eb			  ex de,hl 
10ff			 
10ff 01 f0 d8		  ld bc,-10000 
1102 3e 2f		  ld a,'0'-1 
1104 3c			  inc a 
1105 09			  add hl,bc  
1106 38 fc		   jr c,$-2 
1108 12			  ld (de),a 
1109 13			  inc de 
110a			 
110a 01 e8 03		  ld bc,1000 
110d 3e 3a		  ld a,'9'+1 
110f 3d			  dec a  
1110 09			  add hl,bc  
1111 30 fc		   jr nc,$-2 
1113 12			  ld (de),a 
1114 13			  inc de 
1115			 
1115 01 9c ff		  ld bc,-100 
1118 3e 2f		  ld a,'0'-1 
111a 3c			  inc a  
111b 09			  add hl,bc  
111c 38 fc		   jr c,$-2 
111e 12			  ld (de),a 
111f 13			  inc de 
1120			 
1120 7d			  ld a,l 
1121 26 3a		  ld h,'9'+1 
1123 25			  dec h  
1124 c6 0a		  add a,10  
1126 30 fb		   jr nc,$-3 
1128 c6 30		  add a,'0' 
112a eb			  ex de,hl 
112b 72			  ld (hl),d 
112c 23			  inc hl 
112d 77			  ld (hl),a 
112e 23			  inc hl 
112f 36 00		  ld (hl),0 
1131			 
1131			;Now strip the leading zeros 
1131 0e fa		  ld c,-6 
1133 09			  add hl,bc 
1134 3e 30		  ld a,'0' 
1136 23			  inc hl  
1137 be			  cp (hl)  
1138 28 fc		  jr z,$-2 
113a			 
113a			;Make sure that the string is non-empty! 
113a 7e			  ld a,(hl) 
113b b7			  or a 
113c 20 01		  jr nz,.atoub 
113e 2b			  dec hl 
113f			.atoub: 
113f			 
113f f1			  pop af 
1140 c1			  pop bc 
1141 d1			  pop de 
1142 c9			  ret 
1143			 
1143			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1143			 
1143			toUpper: 
1143			;A is the char. 
1143			;If A is a lowercase letter, this sets it to the matching uppercase 
1143			;18cc or 30cc or 41cc 
1143			;avg: 26.75cc 
1143 fe 61		  cp 'a' 
1145 d8			  ret c 
1146 fe 7b		  cp 'z'+1 
1148 d0			  ret nc 
1149 d6 20		  sub 'a'-'A' 
114b c9			  ret 
114c			 
114c			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
114c			 
114c			; String Length 
114c			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
114c			 
114c			; Get the length of the null-terminated string starting at $8000 hl 
114c			;    LD     HL, $8000 
114c			 
114c			strlenz: 
114c			 
114c af			    XOR    A               ; Zero is the value we are looking for. 
114d 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
114e 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
114f			                           ; 65, 536 bytes (the entire addressable memory space). 
114f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1151			 
1151			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1151 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1152 6f			    LD     L, A             ; number of bytes 
1153 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1155 2b			    DEC    HL              ; Compensate for null. 
1156 c9				ret 
1157			 
1157			; Get the length of the A terminated string starting at $8000 hl 
1157			;    LD     HL, $8000 
1157			 
1157			strlent: 
1157			 
1157			                  ; A is the value we are looking for. 
1157 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1159 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
115b			                           ; 65, 536 bytes (the entire addressable memory space). 
115b ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
115d			 
115d			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
115d 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
115f 2e 00		    LD     L, 0             ; number of bytes 
1161 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1163 2b			    DEC    HL              ; Compensate for null. 
1164 c9				ret 
1165			 
1165			 
1165			;Comparing Strings 
1165			 
1165			;IN    HL     Address of string1. 
1165			;      DE     Address of string2. 
1165			 
1165			; doc given but wrong??? 
1165			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1165			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1165			; tested 
1165			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1165			 
1165			strcmp_old: 
1165 e5			    PUSH   HL 
1166 d5			    PUSH   DE 
1167			 
1167 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1168 be			    CP     (HL)            ; (want to minimize work). 
1169 38 01		    JR     C, Str1IsBigger 
116b 7e			    LD     A, (HL) 
116c			 
116c			Str1IsBigger: 
116c 4f			    LD     C, A             ; Put length in BC 
116d 06 00		    LD     B, 0 
116f 13			    INC    DE              ; Increment pointers to meat of string. 
1170 23			    INC    HL 
1171			 
1171			CmpLoop: 
1171 1a			    LD     A, (DE)          ; Compare bytes. 
1172 ed a1		    CPI 
1174 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
1176 13			    INC    DE              ; Update pointer. 
1177 ea 71 11		    JP     PE, CmpLoop 
117a			 
117a d1			    POP    DE 
117b e1			    POP    HL 
117c 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
117d be			    CP     (HL) 
117e c9			    RET 
117f			 
117f			NoMatch: 
117f 2b			    DEC    HL 
1180 be			    CP     (HL)            ; Compare again to affect carry. 
1181 d1			    POP    DE 
1182 e1			    POP    HL 
1183 c9			    RET 
1184			 
1184			;; test strmp 
1184			; 
1184			;ld de, .str1 
1184			;ld hl, .str2 
1184			;call strcmp 
1184			;jr z, .z1 
1184			;;this 
1184			;	if DEBUG_FORTH_WORDS 
1184			;		DMARK "NZ1" 
1184			;		CALLMONITOR 
1184			;	endif 
1184			;.z1: 
1184			; 
1184			;	if DEBUG_FORTH_WORDS 
1184			;		DMARK "ZZ1" 
1184			;		CALLMONITOR 
1184			;	endif 
1184			; 
1184			;ld de, .str1 
1184			;ld hl, .str1 
1184			;call strcmp 
1184			;jr z, .z2 
1184			;;this 
1184			;	if DEBUG_FORTH_WORDS 
1184			;		DMARK "NZ2" 
1184			;		CALLMONITOR 
1184			;	endif 
1184			;.z2: 
1184			; 
1184			;	if DEBUG_FORTH_WORDS 
1184			;		DMARK "ZZ2" 
1184			;		CALLMONITOR 
1184			;	endif 
1184			; 
1184			;ld de, .str1 
1184			;ld hl, .str2 
1184			;call strcmp 
1184			;jr c, .c1 
1184			; 
1184			;	if DEBUG_FORTH_WORDS 
1184			;		DMARK "Nc1" 
1184			;		CALLMONITOR 
1184			;	endif 
1184			;.c1: 
1184			;;this 
1184			;	if DEBUG_FORTH_WORDS 
1184			;		DMARK "cc1" 
1184			;		CALLMONITOR 
1184			;	endif 
1184			; 
1184			;ld de, .str1 
1184			;ld hl, .str1 
1184			;call strcmp 
1184			;jr c, .c2 
1184			;;this 
1184			;	if DEBUG_FORTH_WORDS 
1184			;		DMARK "Nc2" 
1184			;		CALLMONITOR 
1184			;	endif 
1184			;.c2: 
1184			; 
1184			;	if DEBUG_FORTH_WORDS 
1184			;		DMARK "cc2" 
1184			;		CALLMONITOR 
1184			;	endif 
1184			;	NEXTW 
1184			;.str1:   db "string1",0 
1184			;.str2:   db "string2",0 
1184			 
1184			; only care about direct match or not 
1184			; hl and de strings 
1184			; zero set if the same 
1184			 
1184			strcmp: 
1184 1a				ld a, (de) 
1185 be				cp (hl) 
1186 28 02			jr z, .ssame 
1188 b7				or a 
1189 c9				ret 
118a			 
118a			.ssame:  
118a fe 00			cp 0 
118c c8				ret z 
118d			 
118d 23				inc hl 
118e 13				inc de 
118f 18 f3			jr strcmp 
1191				 
1191				 
1191			 
1191			;Copyright (c) 2014, Luke Maurits 
1191			;All rights reserved. 
1191			; 
1191			;Redistribution and use in source and binary forms, with or without 
1191			;modification, are permitted provided that the following conditions are met: 
1191			; 
1191			;* Redistributions of source code must retain the above copyright notice, this 
1191			;  list of conditions and the following disclaimer. 
1191			; 
1191			;* Redistributions in binary form must reproduce the above copyright notice, 
1191			;  this list of conditions and the following disclaimer in the documentation 
1191			;  and/or other materials provided with the distribution. 
1191			; 
1191			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
1191			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
1191			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
1191			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
1191			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
1191			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
1191			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
1191			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
1191			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
1191			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
1191			 
1191			; https://github.com/lmaurits/lm512/blob/master/string.z80 
1191			 
1191			StrictStrCmp: 
1191				; Load next chars of each string 
1191 1a				ld a, (de) 
1192 47				ld b, a 
1193 7e				ld a, (hl) 
1194				; Compare 
1194 b8				cp b 
1195				; Return non-zero if chars don't match 
1195 c0				ret nz 
1196				; Check for end of both strings 
1196 fe 00			cp "\0" 
1198				; Return if strings have ended 
1198 c8				ret z 
1199				; Otherwise, advance to next chars 
1199 23				inc hl 
119a 13				inc de 
119b 18 f4			jr StrictStrCmp 
119d			 
119d			;end 
119d			; eof 
119d			 
119d			 
119d			 
119d			 
119d			 
119d			 
# End of file firmware_strings.asm
119d			include "firmware_memory.asm"   ; malloc and free  
119d			 
119d			if DEBUG_FORTH_MALLOC_HIGH 
119d			.mallocsize: db "Wants malloc >256",0 
119d			.mallocasize: db "MALLOC gives >256",0 
119d			.malloczero: db "MALLOC gives zero",0 
119d			 
119d			malloc_guard_zerolen: 
119d				push hl 
119d				push de 
119d				push af 
119d			 
119d				ld de, 0 
119d			        call cmp16 
119d				jr nz, .lowalloz 
119d			 
119d				push hl 
119d				push de 
119d					ld hl, display_fb0 
119d					ld (display_fb_active), hl 
119d				call clear_display 
119d				ld a, 0 
119d				ld de, .malloczero 
119d				call str_at_display 
119d				call update_display 
119d				call delay1s 
119d				call delay1s 
119d				call bp_on 
119d			;	ld a, 0 
119d			;	ld (os_view_disable), a 
119d			 
119d				pop de 
119d				pop hl 
119d			 
119d				 
119d			 
119d				CALLMONITOR 
119d			.lowalloz: 
119d			 
119d			 
119d				pop af 
119d				pop de 
119d				pop hl 
119d			ret 
119d			 
119d			malloc_guard_entry: 
119d				push hl 
119d				push de 
119d				push af 
119d			 
119d			 	or a      ;clear carry flag 
119d				push hl 
119d				ld de, 255 
119d				sbc hl, de 
119d				jr c, .lowalloc 
119d			 
119d				push de 
119d					ld hl, display_fb0 
119d					ld (display_fb_active), hl 
119d				call clear_display 
119d				ld a, 0 
119d				ld de, .mallocsize 
119d				call str_at_display 
119d				call update_display 
119d				call delay1s 
119d				call delay1s 
119d			;	ld a, 0 
119d			;	ld (os_view_disable), a 
119d				call bp_on 
119d			 
119d				pop de 
119d				pop hl 
119d			 
119d				 
119d			 
119d				CALLMONITOR 
119d				jr .lowdone 
119d			.lowalloc: 
119d			 
119d			 
119d				pop hl 
119d			.lowdone:	pop af 
119d				pop de 
119d				pop hl 
119d			ret 
119d			 
119d			malloc_guard_exit: 
119d				push hl 
119d				push de 
119d				push af 
119d			 
119d			 	or a      ;clear carry flag 
119d				push hl 
119d				ld de, 255 
119d				sbc hl, de 
119d				jr c, .lowallocx 
119d			 
119d				push de 
119d					ld hl, display_fb0 
119d					ld (display_fb_active), hl 
119d				call clear_display 
119d				ld a, 0 
119d				ld de, .mallocasize 
119d				call str_at_display 
119d				call update_display 
119d				call delay1s 
119d				call delay1s 
119d			;	ld a, 0 
119d			;	ld (os_view_disable), a 
119d				call bp_on 
119d				pop de 
119d				pop hl 
119d			 
119d				CALLMONITOR 
119d				jr .lowdonex 
119d			.lowallocx: 
119d			 
119d				pop hl 
119d			.lowdonex:	pop af 
119d				pop de 
119d				pop hl 
119d			ret 
119d			endif 
119d			 
119d			if MALLOC_2 
119d			; Z80 Malloc and Free Functions 
119d			 
119d			; Malloc Function: 
119d			; Input: 
119d			;   HL: Size of block to allocate 
119d			; Output: 
119d			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
119d			 
119d			malloc: 
119d				 
119d			if DEBUG_FORTH_MALLOC_HIGH 
119d			call malloc_guard_entry 
119d			endif 
119d			 
119d			 
119d			 
119d			 
119d					if DEBUG_FORTH_MALLOC 
119d						DMARK "mal" 
119d						CALLMONITOR 
119d					endif 
119d			    push af            ; Save AF register 
119d			    ld a, l            ; Load low byte of size into A 
119d			    or h               ; Check if size is zero 
119d			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
119d			 
119d			    ; Allocate memory 
119d			    ld hl, (heap_start) ; Load start of heap into HL 
119d					if DEBUG_FORTH_MALLOC 
119d						DMARK "ma1" 
119d						CALLMONITOR 
119d					endif 
119d			    call malloc_internal ; Call internal malloc function 
119d			    pop af             ; Restore AF register 
119d			if DEBUG_FORTH_MALLOC_HIGH 
119d			call malloc_guard_exit 
119d			call malloc_guard_zerolen 
119d			endif 
119d			    ret                ; Return 
119d			 
119d			; Free Function: 
119d			; Input: 
119d			;   HL: Pointer to memory block to free 
119d			; Output: 
119d			;   None 
119d			 
119d			free: 
119d			    push af            ; Save AF register 
119d			    ld a, l            ; Load low byte of pointer into A 
119d			    or h               ; Check if pointer is NULL 
119d			    jp z, free_exit    ; If pointer is NULL, exit 
119d			 
119d			    ; Free memory 
119d			    ld hl, (heap_start) ; Load start of heap into HL 
119d			    call free_internal  ; Call internal free function 
119d			    pop af             ; Restore AF register 
119d			    ret                ; Return 
119d			 
119d			; Internal Malloc Function: 
119d			; Input: 
119d			;   HL: Size of block to allocate 
119d			; Output: 
119d			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
119d			 
119d			malloc_internal: 
119d			    ld bc, 2           ; Number of bytes to allocate for management overhead 
119d			    add hl, bc         ; Add management overhead to requested size 
119d			    ex de, hl          ; Save total size in DE, and keep it in HL 
119d					if DEBUG_FORTH_MALLOC 
119d						DMARK "ma2" 
119d						CALLMONITOR 
119d					endif 
119d			 
119d			    ; Search for free memory block 
119d			    ld de, (heap_end)  ; Load end of heap into DE 
119d			    ld bc, 0           ; Initialize counter 
119d			 
119d					if DEBUG_FORTH_MALLOC 
119d						DMARK "ma2" 
119d						CALLMONITOR 
119d					endif 
119d			malloc_search_loop: 
119d			    ; Check if current block is free 
119d			    ld a, (hl)         ; Load current block's status (free or used) 
119d			    cp 0               ; Compare with zero (free) 
119d			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
119d			 
119d			    ; Check if current block is large enough 
119d			    ld a, (hl+1)       ; Load high byte of block size 
119d			    cp l               ; Compare with low byte of requested size 
119d			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
119d			 
119d			    ld a, (hl+2)       ; Load low byte of block size 
119d			    cp h               ; Compare with high byte of requested size 
119d			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
119d			 
119d			    ; Mark block as used 
119d			    ld (hl), 0xFF      ; Set status byte to indicate used block 
119d			 
119d			    ; Calculate remaining space in block 
119d			    ld bc, 0           ; Clear BC 
119d			    add hl, bc         ; Increment HL to point to start of data block 
119d			    add hl, de         ; HL = HL + DE (total size) 
119d			    ld bc, 1           ; Number of bytes to allocate for management overhead 
119d			    add hl, bc         ; Add management overhead to start of data block 
119d			 
119d			    ; Save pointer to allocated block in HL 
119d			if DEBUG_FORTH_MALLOC_HIGH 
119d						DMARK "ma5" 
119d			call malloc_guard_exit 
119d			call malloc_guard_zerolen 
119d			endif 
119d			    ret 
119d			 
119d			malloc_skip_block_check: 
119d			    ; Move to the next block 
119d			    ld bc, 3           ; Size of management overhead 
119d			    add hl, bc         ; Move to the next block 
119d			    inc de             ; Increment counter 
119d			 
119d			    ; Check if we have reached the end of heap 
119d			    ld a, e            ; Load low byte of heap end address 
119d			    cp (hl)            ; Compare with low byte of current address 
119d			    jr nz, malloc_search_loop  ; If not equal, continue searching 
119d			    ld a, d            ; Load high byte of heap end address 
119d			    cp 0               ; Check if it's zero (end of memory) 
119d			    jr nz, malloc_search_loop  ; If not zero, continue searching 
119d			 
119d			    ; If we reached here, allocation failed 
119d			    xor a              ; Set result to NULL 
119d			if DEBUG_FORTH_MALLOC_HIGH 
119d						DMARK "ma6" 
119d			call malloc_guard_exit 
119d			call malloc_guard_zerolen 
119d			endif 
119d			    ret 
119d			malloc_exit: 
119d			if DEBUG_FORTH_MALLOC_HIGH 
119d						DMARK "ma7" 
119d			call malloc_guard_exit 
119d			call malloc_guard_zerolen 
119d			endif 
119d			    ret 
119d			 
119d			; Internal Free Function: 
119d			; Input: 
119d			;   HL: Pointer to memory block to free 
119d			; Output: 
119d			;   None 
119d			 
119d			free_internal: 
119d			    ld de, (heap_start) ; Load start of heap into DE 
119d			    ld bc, 0            ; Initialize counter 
119d			 
119d			free_search_loop: 
119d			    ; Check if current block contains the pointer 
119d			    ld a, l             ; Load low byte of pointer 
119d			    cp (hl+1)           ; Compare with high byte of current block's address 
119d			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
119d			    ld a, h             ; Load high byte of pointer 
119d			    cp (hl+2)           ; Compare with low byte of current block's address 
119d			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
119d			 
119d			    ; Mark block as free 
119d			    ld (hl), 0          ; Set status byte to indicate free block 
119d			    ret                 ; Return 
119d			 
119d			free_skip_block_check: 
119d			    ; Move to the next block 
119d			    ld bc, 3            ; Size of management overhead 
119d			    add hl, bc          ; Move to the next block 
119d			    inc de              ; Increment counter 
119d			 
119d			    ; Check if we have reached the end of heap 
119d			    ld a, e             ; Load low byte of heap end address 
119d			    cp (hl)             ; Compare with low byte of current address 
119d			    jr nz, free_search_loop  ; If not equal, continue searching 
119d			    ld a, d             ; Load high byte of heap end address 
119d			    cp 0                ; Check if it's zero (end of memory) 
119d			    jr nz, free_search_loop  ; If not zero, continue searching 
119d			 
119d			    ; If we reached here, pointer is not found in heap 
119d			    ret 
119d			 
119d			free_exit: 
119d			    ret                 ; Return 
119d			 
119d			; Define heap start and end addresses 
119d			;heap_start:    .dw 0xC000   ; Start of heap 
119d			;heap_end:      .dw 0xE000   ; End of heap 
119d			 
119d			endif 
119d			 
119d			 
119d			if MALLOC_1 
119d			 
119d			 
119d			 
119d			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
119d			 
119d			;moved to firmware.asm 
119d			;heap_start        .equ  0x9000      ; Starting address of heap 
119d			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
119d			 
119d			;      .org 0 
119d			;      jp    main 
119d			 
119d			 
119d			;      .org  0x100 
119d			;main: 
119d			;      ld    HL, 0x8100 
119d			;      ld    SP, HL 
119d			; 
119d			;      call  heap_init 
119d			; 
119d			;      ; Make some allocations 
119d			;      ld    HL, 12 
119d			;      call  malloc            ; Allocates 0x9004 
119d			; 
119d			;      ld    HL, 12 
119d			;      call  malloc            ; Allocates 0x9014 
119d			; 
119d			;      ld    HL, 12 
119d			;      call  malloc            ; Allocates 0x9024 
119d			; 
119d			;      ; Free some allocations 
119d			;      ld    HL, 0x9014 
119d			;      call  free 
119d			; 
119d			;      ld    HL, 0x9004 
119d			;      call  free 
119d			; 
119d			;      ld    HL, 0x9024 
119d			;      call  free 
119d			; 
119d			; 
119d			;      halt 
119d			 
119d			 
119d			;------------------------------------------------------------------------------ 
119d			;     heap_init                                                               : 
119d			;                                                                             : 
119d			; Description                                                                 : 
119d			;     Initialise the heap and make it ready for malloc and free operations.   : 
119d			;                                                                             : 
119d			;     The heap is maintained as a linked list, starting with an initial       : 
119d			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
119d			;     the first free block in the heap. Each block then points to the next    : 
119d			;     free block within the heap, and the free list ends at the first block   : 
119d			;     with a null pointer to the next free block.                             : 
119d			;                                                                             : 
119d			; Parameters                                                                  : 
119d			;     Inputs are compile-time only. Two defines which specify the starting    : 
119d			;     address of the heap and its size are required, along with a memory      : 
119d			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
119d			;     principally stores a pointer to the first free block in the heap.       : 
119d			;                                                                             : 
119d			; Returns                                                                     : 
119d			;     Nothing                                                                 : 
119d			;------------------------------------------------------------------------------ 
119d			heap_init: 
119d e5			      push  HL 
119e			 
119e			      ; Initialise free list struct 
119e 21 83 5e		      ld    HL, heap_start 
11a1 22 7e 5e		      ld    (free_list), HL 
11a4 21 00 00		      ld    HL, 0 
11a7 22 80 5e		      ld    (free_list+2), HL 
11aa			 
11aa			      ; Insert first free block at bottom of heap, consumes entire heap 
11aa 21 98 e2		      ld    HL, heap_start+heap_size-4 
11ad 22 83 5e		      ld    (heap_start), HL        ; Next block (end of free list) 
11b0 21 15 84		      ld    HL, heap_size-4 
11b3 22 85 5e		      ld    (heap_start+2), HL      ; Block size 
11b6			 
11b6			      ; Insert end of free list block at top of heap - two null words will 
11b6			      ; terminate the free list 
11b6 21 00 00		      ld    HL, 0 
11b9 22 9a e2		      ld    (heap_start+heap_size-2), HL 
11bc 22 98 e2		      ld    (heap_start+heap_size-4), HL 
11bf			 
11bf e1			      pop   HL 
11c0			 
11c0 c9			      ret 
11c1			 
11c1			 
11c1			;------------------------------------------------------------------------------ 
11c1			;     malloc                                                                  : 
11c1			;                                                                             : 
11c1			; Description                                                                 : 
11c1			;     Allocates the wanted space from the heap and returns the address of the : 
11c1			;     first useable byte of the allocation.                                   : 
11c1			;                                                                             : 
11c1			;     Allocations can happen in one of two ways:                              : 
11c1			;                                                                             : 
11c1			;     1. A free block may be found which is the exact size wanted. In this    : 
11c1			;        case the block is removed from the free list and retuedn to the      : 
11c1			;        caller.                                                              : 
11c1			;     2. A free block may be found which is larger than the size wanted. In   : 
11c1			;        this case, the larger block is split into two. The first portion of  : 
11c1			;        this block will become the requested space by the malloc call and    : 
11c1			;        is returned to the caller. The second portion becomes a new free     : 
11c1			;        block, and the free list is adjusted to maintain continuity via this : 
11c1			;        newly created block.                                                 : 
11c1			;                                                                             : 
11c1			;     malloc does not set any initial value in the allocated space, the       : 
11c1			;     caller is required to do this as required.                              : 
11c1			;                                                                             : 
11c1			;     This implementation of malloc uses the stack exclusively, and is        : 
11c1			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11c1			;     advisable to disable interrupts before calling malloc, and recommended  : 
11c1			;     to avoid the use of malloc inside ISRs in general.                      : 
11c1			;                                                                             : 
11c1			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11c1			;                                                                             : 
11c1			; Parameters                                                                  : 
11c1			;     HL  Number of bytes wanted                                              : 
11c1			;                                                                             : 
11c1			; Returns                                                                     : 
11c1			;     HL  Address of the first useable byte of the allocation                 : 
11c1			;                                                                             : 
11c1			; Flags                                                                       : 
11c1			;     Z   Set if the allocation did not succeed, clear otherwise              : 
11c1			;                                                                             : 
11c1			; Stack frame                                                                 : 
11c1			;       |             |                                                       : 
11c1			;       +-------------+                                                       : 
11c1			;       |     BC      |                                                       : 
11c1			;       +-------------+                                                       : 
11c1			;       |     DE      |                                                       : 
11c1			;       +-------------+                                                       : 
11c1			;       |     IX      |                                                       : 
11c1			;       +-------------+                                                       : 
11c1			;       |  prev_free  |                                                       : 
11c1			;   +4  +-------------+                                                       : 
11c1			;       |  this_free  |                                                       : 
11c1			;   +2  +-------------+                                                       : 
11c1			;       |  next_free  |                                                       : 
11c1			;   +0  +-------------+                                                       : 
11c1			;       |             |                                                       : 
11c1			;                                                                             : 
11c1			;------------------------------------------------------------------------------ 
11c1			 
11c1			 
11c1			;malloc: 
11c1			; 
11c1			;	SAVESP ON 1 
11c1			; 
11c1			;	call malloc_code 
11c1			; 
11c1			;	CHECKSP ON 1 
11c1			;	ret 
11c1			 
11c1			 
11c1			malloc: 
11c1 c5			      push  BC 
11c2 d5			      push  DE 
11c3 dd e5		      push  IX 
11c5			if DEBUG_FORTH_MALLOC_HIGH 
11c5			call malloc_guard_entry 
11c5			endif 
11c5			 
11c5					if DEBUG_FORTH_MALLOC 
11c5						DMARK "mal" 
11c5						CALLMONITOR 
11c5					endif 
11c5 7c			      ld    A, H                    ; Exit if no space requested 
11c6 b5			      or    L 
11c7 ca 86 12		      jp    Z, malloc_early_exit 
11ca			 
11ca			;inc hl 
11ca			;inc hl 
11ca			;inc hl 
11ca			; 
11ca			;inc hl 
11ca			;inc hl 
11ca			;inc hl 
11ca			;inc hl 
11ca			;inc hl 
11ca			;inc hl 
11ca			;inc hl 
11ca			;inc hl 
11ca			;inc hl 
11ca			 
11ca			 
11ca			 
11ca			 
11ca					if DEBUG_FORTH_MALLOC 
11ca						DMARK "maA" 
11ca						CALLMONITOR 
11ca					endif 
11ca			      ; Set up stack frame 
11ca eb			      ex    DE, HL 
11cb 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
11ce 39			      add   HL, SP 
11cf f9			      ld    SP, HL 
11d0 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11d4 dd 39		      add   IX, SP 
11d6			 
11d6			      ; Setup initial state 
11d6 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
11d9 19			      add   HL, DE 
11da			 
11da 44			      ld    B, H                    ; Move want to BC 
11db 4d			      ld    C, L 
11dc			 
11dc 21 7e 5e		      ld    HL, free_list           ; Store prev_free ptr to stack 
11df dd 75 04		      ld    (IX+4), L 
11e2 dd 74 05		      ld    (IX+5), H 
11e5			 
11e5 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
11e6 23			      inc   HL 
11e7 56			      ld    D, (HL) 
11e8 dd 73 02		      ld    (IX+2), E 
11eb dd 72 03		      ld    (IX+3), D 
11ee eb			      ex    DE, HL                  ; this_free ptr into HL 
11ef			 
11ef					if DEBUG_FORTH_MALLOC 
11ef						DMARK "maB" 
11ef						CALLMONITOR 
11ef					endif 
11ef			      ; Loop through free block list to find some space 
11ef			malloc_find_space: 
11ef 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
11f0 23			      inc   HL 
11f1 56			      ld    D, (HL) 
11f2			 
11f2 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
11f3 b3			      or    E 
11f4 ca 80 12		      jp    Z, malloc_no_space 
11f7			 
11f7 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
11fa dd 72 01		      ld    (IX+1), D 
11fd			 
11fd			      ; Does this block have enough space to make the allocation? 
11fd 23			      inc   HL                      ; Load free block size into DE 
11fe 5e			      ld    E, (HL) 
11ff 23			      inc   HL 
1200 56			      ld    D, (HL) 
1201			 
1201 eb			      ex    DE, HL                  ; Check size of block against want 
1202 b7			      or    A                       ; Ensure carry flag clear 
1203 ed 42		      sbc   HL, BC 
1205 e5			      push  HL                      ; Store the result for later (new block size) 
1206			 
1206 ca 55 12		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1209 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
120b			 
120b			      ; this_free block is not big enough, setup ptrs to test next free block 
120b e1			      pop   HL                      ; Discard previous result 
120c			 
120c dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
120f dd 66 03		      ld    H, (IX+3) 
1212 dd 75 04		      ld    (IX+4), L 
1215 dd 74 05		      ld    (IX+5), H 
1218			 
1218 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
121b dd 66 01		      ld    H, (IX+1) 
121e dd 75 02		      ld    (IX+2), L 
1221 dd 74 03		      ld    (IX+3), H 
1224			 
1224					if DEBUG_FORTH_MALLOC 
1224						DMARK "MA>" 
1224						CALLMONITOR 
1224					endif 
1224 18 c9		      jr    malloc_find_space 
1226			 
1226			      ; split a bigger block into two - requested size and remaining size 
1226			malloc_alloc_split: 
1226					if DEBUG_FORTH_MALLOC 
1226						DMARK "MAs" 
1226						CALLMONITOR 
1226					endif 
1226 eb			      ex    DE, HL                  ; Calculate address of new free block 
1227 2b			      dec   HL 
1228 2b			      dec   HL 
1229 2b			      dec   HL 
122a 09			      add   HL, BC 
122b			 
122b			      ; Create a new block and point it at next_free 
122b dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
122e dd 56 01		      ld    D, (IX+1) 
1231			 
1231 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1232 23			      inc   HL 
1233 72			      ld    (HL), D 
1234			 
1234 d1			      pop   DE                      ; Store size of new block into new block 
1235 23			      inc   HL 
1236 73			      ld    (HL), E 
1237 23			      inc   HL 
1238 72			      ld    (HL), D 
1239			 
1239			      ; Update this_free ptr to point to new block 
1239 2b			      dec   HL 
123a 2b			      dec   HL 
123b 2b			      dec   HL 
123c			 
123c dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
123f dd 56 03		      ld    D, (IX+3) 
1242			 
1242 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1245 dd 74 03		      ld    (IX+3), H 
1248			 
1248			      ; Modify this_free block to be allocation 
1248 eb			      ex    DE, HL 
1249 af			      xor   A                       ; Null the next block ptr of allocated block 
124a 77			      ld    (HL), A 
124b 23			      inc   HL 
124c 77			      ld    (HL), A 
124d			 
124d 23			      inc   HL                      ; Store want size into allocated block 
124e 71			      ld    (HL), C 
124f 23			      inc   HL 
1250 70			      ld    (HL), B 
1251 23			      inc   HL 
1252 e5			      push  HL                      ; Address of allocation to return 
1253			 
1253 18 19		      jr    malloc_update_links 
1255			 
1255			malloc_alloc_fit: 
1255 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
1256			 
1256					if DEBUG_FORTH_MALLOC 
1256						DMARK "MAf" 
1256						CALLMONITOR 
1256					endif 
1256			      ; Modify this_free block to be allocation 
1256 eb			      ex    DE, HL 
1257 2b			      dec   HL 
1258 2b			      dec   HL 
1259 2b			      dec   HL 
125a			 
125a af			      xor   A                       ; Null the next block ptr of allocated block 
125b 77			      ld    (HL), A 
125c 23			      inc   HL 
125d 77			      ld    (HL), A 
125e			 
125e 23			      inc   HL                      ; Store address of allocation to return 
125f 23			      inc   HL 
1260 23			      inc   HL 
1261 e5			      push  HL 
1262			 
1262			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1262 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
1265 dd 66 01		      ld    H, (IX+1) 
1268			 
1268 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
126b dd 74 03		      ld    (IX+3), H 
126e			 
126e			 
126e			malloc_update_links: 
126e			      ; Update prev_free ptr to point to this_free 
126e dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1271 dd 66 05		      ld    H, (IX+5) 
1274			 
1274 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1277 dd 56 03		      ld    D, (IX+3) 
127a			 
127a 73			      ld    (HL), E                 ; this_free ptr into prev_free 
127b 23			      inc   HL 
127c 72			      ld    (HL), D 
127d			 
127d					if DEBUG_FORTH_MALLOC 
127d						DMARK "Mul" 
127d						CALLMONITOR 
127d					endif 
127d			      ; Clear the Z flag to indicate successful allocation 
127d 7a			      ld    A, D 
127e b3			      or    E 
127f			 
127f d1			      pop   DE                      ; Address of allocation 
1280					if DEBUG_FORTH_MALLOC 
1280						DMARK "MAu" 
1280						CALLMONITOR 
1280					endif 
1280			 
1280			malloc_no_space: 
1280 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1283 39			      add   HL, SP 
1284 f9			      ld    SP, HL 
1285			 
1285 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1286					if DEBUG_FORTH_MALLOC 
1286						DMARK "MAN" 
1286						CALLMONITOR 
1286					endif 
1286			 
1286			malloc_early_exit: 
1286					if DEBUG_FORTH_MALLOC 
1286						DMARK "MAx" 
1286						CALLMONITOR 
1286					endif 
1286 dd e1		      pop   IX 
1288 d1			      pop   DE 
1289 c1			      pop   BC 
128a			 
128a			if DEBUG_FORTH_MALLOC_HIGH 
128a			call malloc_guard_exit 
128a			call malloc_guard_zerolen 
128a			endif 
128a c9			      ret 
128b			 
128b			 
128b			;------------------------------------------------------------------------------ 
128b			;     free                                                                    : 
128b			;                                                                             : 
128b			; Description                                                                 : 
128b			;     Return the space pointed to by HL to the heap. HL must be an address as : 
128b			;     returned by malloc, otherwise the behaviour is undefined.               : 
128b			;                                                                             : 
128b			;     Where possible, directly adjacent free blocks will be merged together   : 
128b			;     into larger blocks to help ensure that the heap does not become         : 
128b			;     excessively fragmented.                                                 : 
128b			;                                                                             : 
128b			;     free does not clear or set any other value into the freed space, and    : 
128b			;     therefore its contents may be visible through subsequent malloc's. The  : 
128b			;     caller should clear the freed space as required.                        : 
128b			;                                                                             : 
128b			;     This implementation of free uses the stack exclusively, and is          : 
128b			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
128b			;     advisable to disable interrupts before calling free, and recommended    : 
128b			;     to avoid the use of free inside ISRs in general.                        : 
128b			;                                                                             : 
128b			;     NOTE: heap_init must be called before malloc and free can be used.      : 
128b			;                                                                             : 
128b			; Parameters                                                                  : 
128b			;     HL  Pointer to address of first byte of allocation to be freed          : 
128b			;                                                                             : 
128b			; Returns                                                                     : 
128b			;     Nothing                                                                 : 
128b			;                                                                             : 
128b			; Stack frame                                                                 : 
128b			;       |             |                                                       : 
128b			;       +-------------+                                                       : 
128b			;       |     BC      |                                                       : 
128b			;       +-------------+                                                       : 
128b			;       |     DE      |                                                       : 
128b			;       +-------------+                                                       : 
128b			;       |     IX      |                                                       : 
128b			;       +-------------+                                                       : 
128b			;       |  prev_free  |                                                       : 
128b			;   +2  +-------------+                                                       : 
128b			;       |  next_free  |                                                       : 
128b			;   +0  +-------------+                                                       : 
128b			;       |             |                                                       : 
128b			;                                                                             : 
128b			;------------------------------------------------------------------------------ 
128b			free: 
128b c5			      push  BC 
128c d5			      push  DE 
128d dd e5		      push  IX 
128f			 
128f 7c			      ld    A, H                    ; Exit if ptr is null 
1290 b5			      or    L 
1291 ca 55 13		      jp    Z, free_early_exit 
1294			 
1294			      ; Set up stack frame 
1294 eb			      ex    DE, HL 
1295 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1298 39			      add   HL, SP 
1299 f9			      ld    SP, HL 
129a dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
129e dd 39		      add   IX, SP 
12a0			 
12a0			      ; The address in HL points to the start of the useable allocated space, 
12a0			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12a0			      ; address of the block itself. 
12a0 eb			      ex    DE, HL 
12a1 11 fc ff		      ld    DE, -4 
12a4 19			      add   HL, DE 
12a5			 
12a5			      ; An allocated block must have a null next block pointer in it 
12a5 7e			      ld    A, (HL) 
12a6 23			      inc   HL 
12a7 b6			      or    (HL) 
12a8 c2 50 13		      jp    NZ, free_done 
12ab			 
12ab 2b			      dec   HL 
12ac			 
12ac 44			      ld    B, H                    ; Copy HL to BC 
12ad 4d			      ld    C, L 
12ae			 
12ae			      ; Loop through the free list to find the first block with an address 
12ae			      ; higher than the block being freed 
12ae 21 7e 5e		      ld    HL, free_list 
12b1			 
12b1			free_find_higher_block: 
12b1 5e			      ld    E, (HL)                 ; Load next ptr from free block 
12b2 23			      inc   HL 
12b3 56			      ld    D, (HL) 
12b4 2b			      dec   HL 
12b5			 
12b5 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
12b8 dd 72 01		      ld    (IX+1), D 
12bb dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
12be dd 74 03		      ld    (IX+3), H 
12c1			 
12c1 78			      ld    A, B                    ; Check if DE is greater than BC 
12c2 ba			      cp    D                       ; Compare MSB first 
12c3 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
12c5 30 04		      jr    NC, free_find_higher_block_skip 
12c7 79			      ld    A, C 
12c8 bb			      cp    E                       ; Then compare LSB 
12c9 38 08		      jr    C, free_found_higher_block 
12cb			 
12cb			free_find_higher_block_skip: 
12cb 7a			      ld    A, D                    ; Reached the end of the free list? 
12cc b3			      or    E 
12cd ca 50 13		      jp    Z, free_done 
12d0			 
12d0 eb			      ex    DE, HL 
12d1			 
12d1 18 de		      jr    free_find_higher_block 
12d3			 
12d3			free_found_higher_block: 
12d3			      ; Insert freed block between prev and next free blocks 
12d3 71			      ld    (HL), C                 ; Point prev free block to freed block 
12d4 23			      inc   HL 
12d5 70			      ld    (HL), B 
12d6			 
12d6 60			      ld    H, B                    ; Point freed block at next free block 
12d7 69			      ld    L, C 
12d8 73			      ld    (HL), E 
12d9 23			      inc   HL 
12da 72			      ld    (HL), D 
12db			 
12db			      ; Check if the freed block is adjacent to the next free block 
12db 23			      inc   HL                      ; Load size of freed block into HL 
12dc 5e			      ld    E, (HL) 
12dd 23			      inc   HL 
12de 56			      ld    D, (HL) 
12df eb			      ex    DE, HL 
12e0			 
12e0 09			      add   HL, BC                  ; Add addr of freed block and its size 
12e1			 
12e1 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
12e4 dd 56 01		      ld    D, (IX+1) 
12e7			 
12e7 b7			      or    A                       ; Clear the carry flag 
12e8 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12ea 20 22		      jr    NZ, free_check_adjacent_to_prev 
12ec			 
12ec			      ; Freed block is adjacent to next, merge into one bigger block 
12ec eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
12ed 5e			      ld    E, (HL) 
12ee 23			      inc   HL 
12ef 56			      ld    D, (HL) 
12f0 e5			      push  HL                      ; Save ptr to next block for later 
12f1			 
12f1 60			      ld    H, B                    ; Store ptr from next block into freed block 
12f2 69			      ld    L, C 
12f3 73			      ld    (HL), E 
12f4 23			      inc   HL 
12f5 72			      ld    (HL), D 
12f6			 
12f6 e1			      pop   HL                      ; Restore ptr to next block 
12f7 23			      inc   HL                      ; Load size of next block into DE 
12f8 5e			      ld    E, (HL) 
12f9 23			      inc   HL 
12fa 56			      ld    D, (HL) 
12fb d5			      push  DE                      ; Save next block size for later 
12fc			 
12fc 60			      ld    H, B                    ; Load size of freed block into HL 
12fd 69			      ld    L, C 
12fe 23			      inc   HL 
12ff 23			      inc   HL 
1300 5e			      ld    E, (HL) 
1301 23			      inc   HL 
1302 56			      ld    D, (HL) 
1303 eb			      ex    DE, HL 
1304			 
1304 d1			      pop   DE                      ; Restore size of next block 
1305 19			      add   HL, DE                  ; Add sizes of both blocks 
1306 eb			      ex    DE, HL 
1307			 
1307 60			      ld    H, B                    ; Store new bigger size into freed block 
1308 69			      ld    L, C 
1309 23			      inc   HL 
130a 23			      inc   HL 
130b 73			      ld    (HL), E 
130c 23			      inc   HL 
130d 72			      ld    (HL), D 
130e			 
130e			free_check_adjacent_to_prev: 
130e			      ; Check if the freed block is adjacent to the prev free block 
130e dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1311 dd 66 03		      ld    H, (IX+3) 
1314			 
1314 23			      inc   HL                      ; Size of prev free block into DE 
1315 23			      inc   HL 
1316 5e			      ld    E, (HL) 
1317 23			      inc   HL 
1318 56			      ld    D, (HL) 
1319 2b			      dec   HL 
131a 2b			      dec   HL 
131b 2b			      dec   HL 
131c			 
131c 19			      add   HL, DE                  ; Add prev block addr and size 
131d			 
131d b7			      or    A                       ; Clear the carry flag 
131e ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1320 20 2e		      jr    NZ, free_done 
1322			 
1322			      ; Freed block is adjacent to prev, merge into one bigger block 
1322 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1323 69			      ld    L, C 
1324 5e			      ld    E, (HL) 
1325 23			      inc   HL 
1326 56			      ld    D, (HL) 
1327 e5			      push  HL                      ; Save freed block ptr for later 
1328			 
1328 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
132b dd 66 03		      ld    H, (IX+3) 
132e 73			      ld    (HL), E 
132f 23			      inc   HL 
1330 72			      ld    (HL), D 
1331			 
1331 e1			      pop   HL                      ; Restore freed block ptr 
1332 23			      inc   HL                      ; Load size of freed block into DE 
1333 5e			      ld    E, (HL) 
1334 23			      inc   HL 
1335 56			      ld    D, (HL) 
1336 d5			      push  DE                      ; Save freed block size for later 
1337			 
1337 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
133a dd 66 03		      ld    H, (IX+3) 
133d 23			      inc   HL 
133e 23			      inc   HL 
133f 5e			      ld    E, (HL) 
1340 23			      inc   HL 
1341 56			      ld    D, (HL) 
1342			 
1342 e1			      pop   HL                      ; Add sizes of both blocks 
1343 19			      add   HL, DE 
1344 eb			      ex    DE, HL 
1345			 
1345 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1348 dd 66 03		      ld    H, (IX+3) 
134b 23			      inc   HL 
134c 23			      inc   HL 
134d 73			      ld    (HL), E 
134e 23			      inc   HL 
134f 72			      ld    (HL), D 
1350			 
1350			free_done: 
1350 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1353 39			      add   HL, SP 
1354 f9			      ld    SP, HL 
1355			 
1355			free_early_exit: 
1355 dd e1		      pop   IX 
1357 d1			      pop   DE 
1358 c1			      pop   BC 
1359			 
1359 c9			      ret 
135a			 
135a			; moved to firmware.asm 
135a			; 
135a			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
135a			;                  .dw   0 
135a			 
135a			 
135a			endif 
135a			 
135a			 
135a			if MALLOC_3 
135a			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
135a			;heap_start        .equ  0x9000      ; Starting address of heap 
135a			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
135a			; 
135a			 ;     .org 0 
135a			  ;    jp    main 
135a			; 
135a			; 
135a			 ;     .org  0x100 
135a			;main: 
135a			 ;     ld    HL, 0x8100 
135a			  ;    ld    SP, HL 
135a			; 
135a			;      call  heap_init 
135a			 
135a			      ; Make some allocations 
135a			;      ld    HL, 12 
135a			;      call  malloc            ; Allocates 0x9004 
135a			; 
135a			 ;     ld    HL, 12 
135a			;      call  malloc            ; Allocates 0x9014 
135a			 
135a			;      ld    HL, 12 
135a			;      call  malloc            ; Allocates 0x9024 
135a			 
135a			      ; Free some allocations 
135a			;      ld    HL, 0x9014 
135a			;      call  free 
135a			 
135a			;      ld    HL, 0x9004 
135a			;      call  free 
135a			; 
135a			;      ld    HL, 0x9024 
135a			;      call  free 
135a			 
135a			 
135a			 ;     halt 
135a			 
135a			 
135a			;------------------------------------------------------------------------------ 
135a			;     heap_init                                                               : 
135a			;                                                                             : 
135a			; Description                                                                 : 
135a			;     Initialise the heap and make it ready for malloc and free operations.   : 
135a			;                                                                             : 
135a			;     The heap is maintained as a linked list, starting with an initial       : 
135a			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
135a			;     the first free block in the heap. Each block then points to the next    : 
135a			;     free block within the heap, and the free list ends at the first block   : 
135a			;     with a null pointer to the next free block.                             : 
135a			;                                                                             : 
135a			; Parameters                                                                  : 
135a			;     Inputs are compile-time only. Two defines which specify the starting    : 
135a			;     address of the heap and its size are required, along with a memory      : 
135a			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
135a			;     principally stores a pointer to the first free block in the heap.       : 
135a			;                                                                             : 
135a			; Returns                                                                     : 
135a			;     Nothing                                                                 : 
135a			;------------------------------------------------------------------------------ 
135a			heap_init: 
135a			      push  HL 
135a			 
135a			      ; Initialise free list struct 
135a			      ld    HL, heap_start 
135a			      ld    (free_list), HL 
135a			      ld    HL, 0 
135a			      ld    (free_list+2), HL 
135a			 
135a			      ; Insert first free block at bottom of heap, consumes entire heap 
135a			      ld    HL, heap_start+heap_size-4 
135a			      ld    (heap_start), HL        ; Next block (end of free list) 
135a			      ld    HL, heap_size-4 
135a			      ld    (heap_start+2), HL      ; Block size 
135a			 
135a			      ; Insert end of free list block at top of heap - two null words will 
135a			      ; terminate the free list 
135a			      ld    HL, 0 
135a			      ld    (heap_start+heap_size-2), HL 
135a			      ld    (heap_start+heap_size-4), HL 
135a			 
135a			      pop   HL 
135a			 
135a			      ret 
135a			 
135a			 
135a			;------------------------------------------------------------------------------ 
135a			;     malloc                                                                  : 
135a			;                                                                             : 
135a			; Description                                                                 : 
135a			;     Allocates the wanted space from the heap and returns the address of the : 
135a			;     first useable byte of the allocation.                                   : 
135a			;                                                                             : 
135a			;     Allocations can happen in one of two ways:                              : 
135a			;                                                                             : 
135a			;     1. A free block may be found which is the exact size wanted. In this    : 
135a			;        case the block is removed from the free list and retuedn to the      : 
135a			;        caller.                                                              : 
135a			;     2. A free block may be found which is larger than the size wanted. In   : 
135a			;        this case, the larger block is split into two. The first portion of  : 
135a			;        this block will become the requested space by the malloc call and    : 
135a			;        is returned to the caller. The second portion becomes a new free     : 
135a			;        block, and the free list is adjusted to maintain continuity via this : 
135a			;        newly created block.                                                 : 
135a			;                                                                             : 
135a			;     malloc does not set any initial value in the allocated space, the       : 
135a			;     caller is required to do this as required.                              : 
135a			;                                                                             : 
135a			;     This implementation of malloc uses the stack exclusively, and is        : 
135a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
135a			;     advisable to disable interrupts before calling malloc, and recommended  : 
135a			;     to avoid the use of malloc inside ISRs in general.                      : 
135a			;                                                                             : 
135a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
135a			;                                                                             : 
135a			; Parameters                                                                  : 
135a			;     HL  Number of bytes wanted                                              : 
135a			;                                                                             : 
135a			; Returns                                                                     : 
135a			;     HL  Address of the first useable byte of the allocation                 : 
135a			;                                                                             : 
135a			; Flags                                                                       : 
135a			;     Z   Set if the allocation did not succeed, clear otherwise              : 
135a			;                                                                             : 
135a			; Stack frame                                                                 : 
135a			;       |             |                                                       : 
135a			;       +-------------+                                                       : 
135a			;       |     BC      |                                                       : 
135a			;       +-------------+                                                       : 
135a			;       |     DE      |                                                       : 
135a			;       +-------------+                                                       : 
135a			;       |     IX      |                                                       : 
135a			;       +-------------+                                                       : 
135a			;       |  prev_free  |                                                       : 
135a			;   +4  +-------------+                                                       : 
135a			;       |  this_free  |                                                       : 
135a			;   +2  +-------------+                                                       : 
135a			;       |  next_free  |                                                       : 
135a			;   +0  +-------------+                                                       : 
135a			;       |             |                                                       : 
135a			;                                                                             : 
135a			;------------------------------------------------------------------------------ 
135a			malloc: 
135a			      push  BC 
135a			      push  DE 
135a			      push  IX 
135a			 
135a			      ld    A, H                    ; Exit if no space requested 
135a			      or    L 
135a			      jp    Z, malloc_early_exit 
135a			 
135a			      ; Set up stack frame 
135a			      ex    DE, HL 
135a			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
135a			      add   HL, SP 
135a			      ld    SP, HL 
135a			      ld    IX, 0                   ; Use IX as a frame pointer 
135a			      add   IX, SP 
135a			 
135a			      ; Setup initial state 
135a			      ld    HL, 4                   ; want must also include space used by block struct 
135a			      add   HL, DE 
135a			 
135a			      ld    B, H                    ; Move want to BC 
135a			      ld    C, L 
135a			 
135a			      ld    HL, free_list           ; Store prev_free ptr to stack 
135a			      ld    (IX+4), L 
135a			      ld    (IX+5), H 
135a			 
135a			      ld    E, (HL)                 ; Store this_free ptr to stack 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			      ld    (IX+2), E 
135a			      ld    (IX+3), D 
135a			      ex    DE, HL                  ; this_free ptr into HL 
135a			 
135a			      ; Loop through free block list to find some space 
135a			malloc_find_space: 
135a			      ld    E, (HL)                 ; Load next_free ptr into DE 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			 
135a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
135a			      or    E 
135a			      jp    Z, malloc_no_space 
135a			 
135a			      ld    (IX+0), E               ; Store next_free ptr to stack 
135a			      ld    (IX+1), D 
135a			 
135a			      ; Does this block have enough space to make the allocation? 
135a			      inc   HL                      ; Load free block size into DE 
135a			      ld    E, (HL) 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			 
135a			      ex    DE, HL                  ; Check size of block against want 
135a			      or    A                       ; Ensure carry flag clear 
135a			      sbc   HL, BC 
135a			      push  HL                      ; Store the result for later (new block size) 
135a			 
135a			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
135a			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
135a			 
135a			      ; this_free block is not big enough, setup ptrs to test next free block 
135a			      pop   HL                      ; Discard previous result 
135a			 
135a			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
135a			      ld    H, (IX+3) 
135a			      ld    (IX+4), L 
135a			      ld    (IX+5), H 
135a			 
135a			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
135a			      ld    H, (IX+1) 
135a			      ld    (IX+2), L 
135a			      ld    (IX+3), H 
135a			 
135a			      jr    malloc_find_space 
135a			 
135a			      ; split a bigger block into two - requested size and remaining size 
135a			malloc_alloc_split: 
135a			      ex    DE, HL                  ; Calculate address of new free block 
135a			      dec   HL 
135a			      dec   HL 
135a			      dec   HL 
135a			      add   HL, BC 
135a			 
135a			      ; Create a new block and point it at next_free 
135a			      ld    E, (IX+0)               ; Load next_free ptr into DE 
135a			      ld    D, (IX+1) 
135a			 
135a			      ld    (HL), E                 ; Store next_free ptr into new block 
135a			      inc   HL 
135a			      ld    (HL), D 
135a			 
135a			      pop   DE                      ; Store size of new block into new block 
135a			      inc   HL 
135a			      ld    (HL), E 
135a			      inc   HL 
135a			      ld    (HL), D 
135a			 
135a			      ; Update this_free ptr to point to new block 
135a			      dec   HL 
135a			      dec   HL 
135a			      dec   HL 
135a			 
135a			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
135a			      ld    D, (IX+3) 
135a			 
135a			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
135a			      ld    (IX+3), H 
135a			 
135a			      ; Modify this_free block to be allocation 
135a			      ex    DE, HL 
135a			      xor   A                       ; Null the next block ptr of allocated block 
135a			      ld    (HL), A 
135a			      inc   HL 
135a			      ld    (HL), A 
135a			 
135a			      inc   HL                      ; Store want size into allocated block 
135a			      ld    (HL), C 
135a			      inc   HL 
135a			      ld    (HL), B 
135a			      inc   HL 
135a			      push  HL                      ; Address of allocation to return 
135a			 
135a			      jr    malloc_update_links 
135a			 
135a			malloc_alloc_fit: 
135a			      pop   HL                      ; Dont need new block size, want is exact fit 
135a			 
135a			      ; Modify this_free block to be allocation 
135a			      ex    DE, HL 
135a			      dec   HL 
135a			      dec   HL 
135a			      dec   HL 
135a			 
135a			      xor   A                       ; Null the next block ptr of allocated block 
135a			      ld    (HL), A 
135a			      inc   HL 
135a			      ld    (HL), A 
135a			 
135a			      inc   HL                      ; Store address of allocation to return 
135a			      inc   HL 
135a			      inc   HL 
135a			      push  HL 
135a			 
135a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
135a			      ld    L, (IX+0)               ; next_free to HL 
135a			      ld    H, (IX+1) 
135a			 
135a			      ld    (IX+2), L               ; HL to this_free 
135a			      ld    (IX+3), H 
135a			 
135a			 
135a			malloc_update_links: 
135a			      ; Update prev_free ptr to point to this_free 
135a			      ld    L, (IX+4)               ; prev_free ptr to HL 
135a			      ld    H, (IX+5) 
135a			 
135a			      ld    E, (IX+2)               ; this_free ptr to DE 
135a			      ld    D, (IX+3) 
135a			 
135a			      ld    (HL), E                 ; this_free ptr into prev_free 
135a			      inc   HL 
135a			      ld    (HL), D 
135a			 
135a			      ; Clear the Z flag to indicate successful allocation 
135a			      ld    A, D 
135a			      or    E 
135a			 
135a			      pop   DE                      ; Address of allocation 
135a			 
135a			malloc_no_space: 
135a			      ld    HL, 6                   ; Clean up stack frame 
135a			      add   HL, SP 
135a			      ld    SP, HL 
135a			 
135a			      ex    DE, HL                  ; Alloc addr into HL for return 
135a			 
135a			malloc_early_exit: 
135a			      pop   IX 
135a			      pop   DE 
135a			      pop   BC 
135a			 
135a			      ret 
135a			 
135a			 
135a			;------------------------------------------------------------------------------ 
135a			;     free                                                                    : 
135a			;                                                                             : 
135a			; Description                                                                 : 
135a			;     Return the space pointed to by HL to the heap. HL must be an address as : 
135a			;     returned by malloc, otherwise the behaviour is undefined.               : 
135a			;                                                                             : 
135a			;     Where possible, directly adjacent free blocks will be merged together   : 
135a			;     into larger blocks to help ensure that the heap does not become         : 
135a			;     excessively fragmented.                                                 : 
135a			;                                                                             : 
135a			;     free does not clear or set any other value into the freed space, and    : 
135a			;     therefore its contents may be visible through subsequent malloc's. The  : 
135a			;     caller should clear the freed space as required.                        : 
135a			;                                                                             : 
135a			;     This implementation of free uses the stack exclusively, and is          : 
135a			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
135a			;     advisable to disable interrupts before calling free, and recommended    : 
135a			;     to avoid the use of free inside ISRs in general.                        : 
135a			;                                                                             : 
135a			;     NOTE: heap_init must be called before malloc and free can be used.      : 
135a			;                                                                             : 
135a			; Parameters                                                                  : 
135a			;     HL  Pointer to address of first byte of allocation to be freed          : 
135a			;                                                                             : 
135a			; Returns                                                                     : 
135a			;     Nothing                                                                 : 
135a			;                                                                             : 
135a			; Stack frame                                                                 : 
135a			;       |             |                                                       : 
135a			;       +-------------+                                                       : 
135a			;       |     BC      |                                                       : 
135a			;       +-------------+                                                       : 
135a			;       |     DE      |                                                       : 
135a			;       +-------------+                                                       : 
135a			;       |     IX      |                                                       : 
135a			;       +-------------+                                                       : 
135a			;       |  prev_free  |                                                       : 
135a			;   +2  +-------------+                                                       : 
135a			;       |  next_free  |                                                       : 
135a			;   +0  +-------------+                                                       : 
135a			;       |             |                                                       : 
135a			;                                                                             : 
135a			;------------------------------------------------------------------------------ 
135a			free: 
135a			      push  BC 
135a			      push  DE 
135a			      push  IX 
135a			 
135a			      ld    A, H                    ; Exit if ptr is null 
135a			      or    L 
135a			      jp    Z, free_early_exit 
135a			 
135a			      ; Set up stack frame 
135a			      ex    DE, HL 
135a			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
135a			      add   HL, SP 
135a			      ld    SP, HL 
135a			      ld    IX, 0                   ; Use IX as a frame pointer 
135a			      add   IX, SP 
135a			 
135a			      ; The address in HL points to the start of the useable allocated space, 
135a			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
135a			      ; address of the block itself. 
135a			      ex    DE, HL 
135a			      ld    DE, -4 
135a			      add   HL, DE 
135a			 
135a			      ; An allocated block must have a null next block pointer in it 
135a			      ld    A, (HL) 
135a			      inc   HL 
135a			      or    (HL) 
135a			      jp    NZ, free_done 
135a			 
135a			      dec   HL 
135a			 
135a			      ld    B, H                    ; Copy HL to BC 
135a			      ld    C, L 
135a			 
135a			      ; Loop through the free list to find the first block with an address 
135a			      ; higher than the block being freed 
135a			      ld    HL, free_list 
135a			 
135a			free_find_higher_block: 
135a			      ld    E, (HL)                 ; Load next ptr from free block 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			      dec   HL 
135a			 
135a			      ld    (IX+0), E               ; Save ptr to next free block 
135a			      ld    (IX+1), D 
135a			      ld    (IX+2), L               ; Save ptr to prev free block 
135a			      ld    (IX+3), H 
135a			 
135a			      ld    A, B                    ; Check if DE is greater than BC 
135a			      cp    D                       ; Compare MSB first 
135a			      jr    Z, $+4                  ; MSB the same, compare LSB 
135a			      jr    NC, free_find_higher_block_skip 
135a			      ld    A, C 
135a			      cp    E                       ; Then compare LSB 
135a			      jr    C, free_found_higher_block 
135a			 
135a			free_find_higher_block_skip: 
135a			      ld    A, D                    ; Reached the end of the free list? 
135a			      or    E 
135a			      jp    Z, free_done 
135a			 
135a			      ex    DE, HL 
135a			 
135a			      jr    free_find_higher_block 
135a			 
135a			free_found_higher_block: 
135a			      ; Insert freed block between prev and next free blocks 
135a			      ld    (HL), C                 ; Point prev free block to freed block 
135a			      inc   HL 
135a			      ld    (HL), B 
135a			 
135a			      ld    H, B                    ; Point freed block at next free block 
135a			      ld    L, C 
135a			      ld    (HL), E 
135a			      inc   HL 
135a			      ld    (HL), D 
135a			 
135a			      ; Check if the freed block is adjacent to the next free block 
135a			      inc   HL                      ; Load size of freed block into HL 
135a			      ld    E, (HL) 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			      ex    DE, HL 
135a			 
135a			      add   HL, BC                  ; Add addr of freed block and its size 
135a			 
135a			      ld    E, (IX+0)               ; Load addr of next free block into DE 
135a			      ld    D, (IX+1) 
135a			 
135a			      or    A                       ; Clear the carry flag 
135a			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
135a			      jr    NZ, free_check_adjacent_to_prev 
135a			 
135a			      ; Freed block is adjacent to next, merge into one bigger block 
135a			      ex    DE, HL                  ; Load next ptr from next block into DE 
135a			      ld    E, (HL) 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			      push  HL                      ; Save ptr to next block for later 
135a			 
135a			      ld    H, B                    ; Store ptr from next block into freed block 
135a			      ld    L, C 
135a			      ld    (HL), E 
135a			      inc   HL 
135a			      ld    (HL), D 
135a			 
135a			      pop   HL                      ; Restore ptr to next block 
135a			      inc   HL                      ; Load size of next block into DE 
135a			      ld    E, (HL) 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			      push  DE                      ; Save next block size for later 
135a			 
135a			      ld    H, B                    ; Load size of freed block into HL 
135a			      ld    L, C 
135a			      inc   HL 
135a			      inc   HL 
135a			      ld    E, (HL) 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			      ex    DE, HL 
135a			 
135a			      pop   DE                      ; Restore size of next block 
135a			      add   HL, DE                  ; Add sizes of both blocks 
135a			      ex    DE, HL 
135a			 
135a			      ld    H, B                    ; Store new bigger size into freed block 
135a			      ld    L, C 
135a			      inc   HL 
135a			      inc   HL 
135a			      ld    (HL), E 
135a			      inc   HL 
135a			      ld    (HL), D 
135a			 
135a			free_check_adjacent_to_prev: 
135a			      ; Check if the freed block is adjacent to the prev free block 
135a			      ld    L, (IX+2)               ; Prev free block ptr into HL 
135a			      ld    H, (IX+3) 
135a			 
135a			      inc   HL                      ; Size of prev free block into DE 
135a			      inc   HL 
135a			      ld    E, (HL) 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			      dec   HL 
135a			      dec   HL 
135a			      dec   HL 
135a			 
135a			      add   HL, DE                  ; Add prev block addr and size 
135a			 
135a			      or    A                       ; Clear the carry flag 
135a			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
135a			      jr    NZ, free_done 
135a			 
135a			      ; Freed block is adjacent to prev, merge into one bigger block 
135a			      ld    H, B                    ; Load next ptr from freed block into DE 
135a			      ld    L, C 
135a			      ld    E, (HL) 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			      push  HL                      ; Save freed block ptr for later 
135a			 
135a			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
135a			      ld    H, (IX+3) 
135a			      ld    (HL), E 
135a			      inc   HL 
135a			      ld    (HL), D 
135a			 
135a			      pop   HL                      ; Restore freed block ptr 
135a			      inc   HL                      ; Load size of freed block into DE 
135a			      ld    E, (HL) 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			      push  DE                      ; Save freed block size for later 
135a			 
135a			      ld    L, (IX+2)               ; Load size of prev block into DE 
135a			      ld    H, (IX+3) 
135a			      inc   HL 
135a			      inc   HL 
135a			      ld    E, (HL) 
135a			      inc   HL 
135a			      ld    D, (HL) 
135a			 
135a			      pop   HL                      ; Add sizes of both blocks 
135a			      add   HL, DE 
135a			      ex    DE, HL 
135a			 
135a			      ld    L, (IX+2)               ; Store new bigger size into prev block 
135a			      ld    H, (IX+3) 
135a			      inc   HL 
135a			      inc   HL 
135a			      ld    (HL), E 
135a			      inc   HL 
135a			      ld    (HL), D 
135a			 
135a			free_done: 
135a			      ld    HL, 4                   ; Clean up stack frame 
135a			      add   HL, SP 
135a			      ld    SP, HL 
135a			 
135a			free_early_exit: 
135a			      pop   IX 
135a			      pop   DE 
135a			      pop   BC 
135a			 
135a			      ret 
135a			 
135a			 
135a			;      .org 0x8000 
135a			; 
135a			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
135a			 ;                 .dw   0 
135a			 
135a			endif 
135a			 
135a			 
135a			if MALLOC_4 
135a			 
135a			; My memory allocation code. Very very simple.... 
135a			; allocate space under 250 chars 
135a			 
135a			heap_init: 
135a				; init start of heap as zero 
135a				;  
135a			 
135a				ld hl, heap_start 
135a				ld a, 0 
135a				ld (hl), a      ; empty block 
135a				inc hl 
135a				ld a, 0 
135a				ld (hl), a      ; length of block 
135a				; write end of list 
135a				inc hl 
135a				ld a,(hl) 
135a				inc hl 
135a				ld a,(hl) 
135a				 
135a			 
135a				; init some malloc vars 
135a			 
135a				ld hl, 0 
135a				ld (free_list), hl       ; store last malloc location 
135a			 
135a				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
135a				ld a, 0 
135a				ld (hl), a 
135a			 
135a			 
135a				ld hl, heap_start 
135a				;  
135a				  
135a				ret 
135a			 
135a			 
135a			;    free block marker 
135a			;    requested size  
135a			;    pointer to next block 
135a			;    .... 
135a			;    next block marker 
135a			 
135a			 
135a			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
135a			; 
135a			 
135a			 
135a			malloc:  
135a				push de 
135a				push bc 
135a				push af 
135a			 
135a				; hl space required 
135a				 
135a				ld c, l    ; hold space   (TODO only a max of 255) 
135a			 
135a			;	inc c     ; TODO BUG need to fix memory leak on push str 
135a			;	inc c 
135a			;	inc c 
135a			;	inc c 
135a			;	inc c 
135a			;	inc c 
135a			;	inc c 
135a			 
135a			 
135a			 
135a				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
135a			 
135a				ld a, (free_list+3) 
135a				cp 0 
135a				jr z, .contheap 
135a			 
135a				ld hl, (free_list)     ; get last alloc 
135a					if DEBUG_FORTH_MALLOC_INT 
135a						DMARK "mrs" 
135a						CALLMONITOR 
135a					endif 
135a				jr .startalloc 
135a			 
135a			.contheap: 
135a				ld hl, heap_start 
135a			 
135a			.startalloc: 
135a			 
135a					if DEBUG_FORTH_MALLOC_INT 
135a						DMARK "mym" 
135a						CALLMONITOR 
135a					endif 
135a			.findblock: 
135a					if DEBUG_FORTH_MALLOC_INT 
135a						DMARK "mmf" 
135a						CALLMONITOR 
135a					endif 
135a			 
135a				ld a,(hl)  
135a				; if byte is zero then clear to use 
135a			 
135a				cp 0 
135a				jr z, .foundemptyblock 
135a			 
135a				; if byte is not clear 
135a				;     then byte is offset to next block 
135a			 
135a				inc hl 
135a				ld a, (hl) ; get size 
135a			.nextblock:	inc hl 
135a					ld e, (hl) 
135a					inc hl 
135a					ld d, (hl) 
135a					ex de, hl 
135a			;	inc hl  ; move past the store space 
135a			;	inc hl  ; move past zero index  
135a			 
135a				; TODO detect no more space 
135a			 
135a				push hl 
135a				ld de, heap_end 
135a				call cmp16 
135a				pop hl 
135a				jr nc, .nospace 
135a			 
135a				jr .findblock 
135a			 
135a			.nospace: ld hl, 0 
135a				jp .exit 
135a			 
135a			 
135a			.foundemptyblock:	 
135a					if DEBUG_FORTH_MALLOC_INT 
135a						DMARK "mme" 
135a						CALLMONITOR 
135a					endif 
135a			 
135a			; TODO has block enough space if reusing??? 
135a			 
135a				;  
135a			 
135a			; see if this block has been previously used 
135a				inc hl 
135a				ld a, (hl) 
135a				dec hl 
135a				cp 0 
135a				jr z, .newblock 
135a			 
135a					if DEBUG_FORTH_MALLOC_INT 
135a						DMARK "meR" 
135a						CALLMONITOR 
135a					endif 
135a			 
135a			; no reusing previously allocated block 
135a			 
135a			; is it smaller than previously used? 
135a				 
135a				inc hl    ; move to size 
135a				ld a, c 
135a				sub (hl)        ; we want c < (hl) 
135a				dec hl    ; move back to marker 
135a			        jr z, .findblock 
135a			 
135a				; update with the new size which should be lower 
135a			 
135a			        ;inc  hl   ; negate next move. move back to size  
135a			 
135a			.newblock: 
135a				; need to be at marker here 
135a			 
135a					if DEBUG_FORTH_MALLOC_INT 
135a						DMARK "meN" 
135a						CALLMONITOR 
135a					endif 
135a			 
135a			 
135a				ld a, c 
135a			 
135a				ld (free_list+3), a	 ; flag resume from last malloc  
135a				ld (free_list), hl    ; save out last location 
135a			 
135a			 
135a				;inc a     ; space for length byte 
135a				ld (hl), a     ; save block in use marker 
135a			 
135a				inc hl   ; move to space marker 
135a				ld (hl), a    ; save new space 
135a			 
135a				inc hl   ; move to start of allocated area 
135a				 
135a			;	push hl     ; save where we are - 1  
135a			 
135a			;	inc hl  ; move past zero index  
135a				; skip space to set down new marker 
135a			 
135a				; provide some extra space for now 
135a			 
135a				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
135a				inc a 
135a				inc a 
135a			 
135a				push hl   ; save where we are in the node block 
135a			 
135a				call addatohl 
135a			 
135a				; write linked list point 
135a			 
135a				pop de     ; get our node position 
135a				ex de, hl 
135a			 
135a				ld (hl), e 
135a				inc hl 
135a				ld (hl), d 
135a			 
135a				inc hl 
135a			 
135a				; now at start of allocated data so save pointer 
135a			 
135a				push hl 
135a			 
135a				; jump to position of next node and setup empty header in DE 
135a			 
135a				ex de, hl 
135a			 
135a			;	inc hl ; move past end of block 
135a			 
135a				ld a, 0 
135a				ld (hl), a   ; empty marker 
135a				inc hl 
135a				ld (hl), a   ; size 
135a				inc hl  
135a				ld (hl), a   ; ptr 
135a				inc hl 
135a				ld (hl), a   ; ptr 
135a			 
135a			 
135a				pop hl 
135a			 
135a					if DEBUG_FORTH_MALLOC_INT 
135a						DMARK "mmr" 
135a						CALLMONITOR 
135a					endif 
135a			 
135a			.exit: 
135a				pop af 
135a				pop bc 
135a				pop de  
135a				ret 
135a			 
135a			 
135a			 
135a			 
135a			free:  
135a				push hl 
135a				push af 
135a				; get address in hl 
135a			 
135a					if DEBUG_FORTH_MALLOC_INT 
135a						DMARK "fre" 
135a						CALLMONITOR 
135a					endif 
135a				; data is at hl - move to block count 
135a				dec hl 
135a				dec hl    ; get past pointer 
135a				dec hl 
135a			 
135a				ld a, (hl)    ; need this for a validation check 
135a			 
135a				dec hl    ; move to block marker 
135a			 
135a				; now check that the block count and block marker are the same  
135a			        ; this checks that we are on a malloc node and not random memory 
135a			        ; OK a faint chance this could be a problem but rare - famous last words! 
135a			 
135a				ld c, a 
135a				ld a, (hl)    
135a			 
135a				cp c 
135a				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
135a			 
135a				; yes good chance we are on a malloc node 
135a			 
135a				ld a, 0      
135a				ld (hl), a   ; mark as free 
135a			 
135a				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
135a			 
135a			.freeignore:  
135a			 
135a				pop af 
135a				pop hl 
135a			 
135a				ret 
135a			 
135a			 
135a			 
135a			endif 
135a			 
135a			; eof 
# End of file firmware_memory.asm
135a			  
135a			; device C  
135a			; Now handled by SPI  
135a			;if SOUND_ENABLE  
135a			;	include "firmware_sound.asm"  
135a			;endif  
135a			  
135a			include "firmware_diags.asm"  
135a			; Hardware diags menu 
135a			 
135a			 
135a			config: 
135a			 
135a 3e 00			ld a, 0 
135c 21 80 13			ld hl, .configmn 
135f cd ea 0b			call menu 
1362			 
1362 fe 00			cp 0 
1364 c8				ret z 
1365			 
1365			;	cp 1 
1365			;	call z, .savetostore 
1365			 
1365 fe 01			cp 1 
1367			if STARTUP_V1 
1367 cc 96 13			call z, .selautoload 
136a			endif 
136a			 
136a			if STARTUP_V2 
136a				call z, .enautoload 
136a			endif 
136a fe 02			cp 2 
136c cc 8c 13			call z, .disautoload 
136f			;	cp 3 
136f			;	call z, .selbank 
136f fe 03			cp 3 
1371 cc b4 13			call z, .debug_tog 
1374 fe 04			cp 4 
1376 cc 02 15			call z, .bpsgo 
1379 fe 05			cp 5 
137b cc dd 13			call z, hardware_diags 
137e			if STARTUP_V2 
137e				cp 6 
137e				call z, create_startup 
137e			endif 
137e 18 da			jr config 
1380			 
1380			.configmn: 
1380			;	dw prom_c3 
1380 f0 16			dw prom_c2 
1382 05 17			dw prom_c2a 
1384			;	dw prom_c2b 
1384			;	dw prom_c4 
1384 24 17			dw prom_m4 
1386 3f 17			dw prom_m4b 
1388 47 17			dw prom_c1 
138a			if STARTUP_V2 
138a				dw prom_c9 
138a			endif 
138a 00 00			dw 0 
138c				 
138c			 
138c			if STARTUP_V2 
138c			.enautoload: 
138c				if STORAGE_SE 
138c				ld a, $fe      ; bit 0 clear 
138c				ld (spi_device), a 
138c			 
138c				call storage_get_block_0 
138c			 
138c				ld a, 1 
138c				ld (store_page+STORE_0_AUTOFILE), a 
138c			 
138c					ld hl, 0 
138c					ld de, store_page 
138c				call storage_write_block	 ; save update 
138c				else 
138c			 
138c				ld hl, prom_notav 
138c				ld de, prom_empty 
138c				call info_panel 
138c				endif 
138c			 
138c			 
138c				ret 
138c			endif 
138c			 
138c			.disautoload: 
138c				if STORAGE_SE 
138c				ld a, $fe      ; bit 0 clear 
138c				ld (spi_device), a 
138c			 
138c				call storage_get_block_0 
138c			 
138c				ld a, 0 
138c				ld (store_page+STORE_0_AUTOFILE), a 
138c			 
138c					ld hl, 0 
138c					ld de, store_page 
138c				call storage_write_block	 ; save update 
138c				else 
138c			 
138c 21 56 17			ld hl, prom_notav 
138f 11 6c 17			ld de, prom_empty 
1392 cd 4a 0b			call info_panel 
1395				endif 
1395			 
1395			 
1395 c9				ret 
1396			 
1396			if STARTUP_V1 
1396			 
1396			; Select auto start 
1396			 
1396			.selautoload: 
1396			 
1396				 
1396				if STORAGE_SE 
1396			 
1396					call config_dir 
1396				        ld hl, scratch 
1396					ld a, 0 
1396					call menu 
1396			 
1396					cp 0 
1396					ret z 
1396			 
1396					dec a 
1396			 
1396			 
1396					; locate menu option 
1396			 
1396					ld hl, scratch 
1396					call table_lookup 
1396			 
1396					if DEBUG_FORTH_WORDS 
1396						DMARK "ALl" 
1396						CALLMONITOR 
1396					endif 
1396					; with the pointer to the menu it, the byte following the zero term is the file id 
1396			 
1396					ld a, 0 
1396					ld bc, 50   ; max of bytes to look at 
1396					cpir  
1396			 
1396					if DEBUG_FORTH_WORDS 
1396						DMARK "ALb" 
1396						CALLMONITOR 
1396					endif 
1396					;inc hl 
1396			 
1396					ld a, (hl)   ; file id 
1396					 
1396				        ; save bank and file ids 
1396			 
1396					push af 
1396			 
1396			; TODO need to save to block 0 on bank 1	 
1396			 
1396					call storage_get_block_0 
1396			 
1396					if DEBUG_FORTH_WORDS 
1396						DMARK "AL0" 
1396						CALLMONITOR 
1396					endif 
1396					pop af 
1396			 
1396					ld (store_page+STORE_0_FILERUN),a 
1396					 
1396					; save bank id 
1396			 
1396					ld a,(spi_device) 
1396					ld (store_page+STORE_0_BANKRUN),a 
1396			 
1396					; enable auto run of store file 
1396			 
1396					ld a, 1 
1396					ld (store_page+STORE_0_AUTOFILE),a 
1396			 
1396					; save buffer 
1396			 
1396					ld hl, 0 
1396					ld de, store_page 
1396					if DEBUG_FORTH_WORDS 
1396						DMARK "ALw" 
1396						CALLMONITOR 
1396					endif 
1396				call storage_write_block	 ; save update 
1396			  
1396			 
1396			 
1396			 
1396					ld hl, scratch 
1396					call config_fdir 
1396			 
1396				else 
1396			 
1396 21 56 17			ld hl, prom_notav 
1399 11 6c 17			ld de, prom_empty 
139c cd 4a 0b			call info_panel 
139f			 
139f				endif 
139f c9				ret 
13a0			endif 
13a0			 
13a0			 
13a0			; Select storage bank 
13a0			 
13a0			.selbank: 
13a0			 
13a0			;	if STORAGE_SE 
13a0			;	else 
13a0			 
13a0 21 56 17			ld hl, prom_notav 
13a3 11 6c 17			ld de, prom_empty 
13a6 cd 4a 0b			call info_panel 
13a9			;	endif 
13a9				 
13a9 c9				ret 
13aa			 
13aa			if STORAGE_SE 
13aa			 
13aa			.config_ldir:   
13aa				; Load storage bank labels into menu array 
13aa			 
13aa				 
13aa			 
13aa			 
13aa				ret 
13aa			 
13aa			 
13aa			endif 
13aa			 
13aa			 
13aa			; Save user words to storage 
13aa			 
13aa			.savetostore: 
13aa			 
13aa			;	if STORAGE_SE 
13aa			; 
13aa			;		call config_dir 
13aa			;	        ld hl, scratch 
13aa			;		ld a, 0 
13aa			;		call menu 
13aa			;		 
13aa			;		ld hl, scratch 
13aa			;		call config_fdir 
13aa			; 
13aa			;	else 
13aa			 
13aa 21 56 17			ld hl, prom_notav 
13ad 11 6c 17			ld de, prom_empty 
13b0 cd 4a 0b			call info_panel 
13b3			 
13b3			;	endif 
13b3			 
13b3 c9				ret 
13b4			 
13b4			if STARTUP_V2 
13b4			 
13b4			create_startup: 
13b4			 
13b4				ld a, 0 
13b4				ld hl, .crstart 
13b4				call menu 
13b4			 
13b4				cp 0 
13b4				ret z 
13b4			 
13b4				cp 1 
13b4				call z, .genlsword 
13b4				cp 2 
13b4				call z, .genedword 
13b4			 
13b4				cp 3 
13b4				call z, .gendemword 
13b4			 
13b4				cp 4 
13b4				call z, .genutlword 
13b4				cp 5 
13b4				call z, .genspiword 
13b4				cp 6 
13b4				call z, .genkeyword 
13b4				cp 7 
13b4				call z, .gensoundword 
13b4				cp 7 
13b4				call z, .genhwword 
13b4				jr create_startup 
13b4			 
13b4			.genhwword: 
13b4				ld hl, crs_hw 
13b4				ld de, .hwworddef 
13b4				call .genfile 
13b4				ret 
13b4			.gensoundword: 
13b4				ld hl, crs_sound 
13b4				ld de, .soundworddef 
13b4				call .genfile 
13b4				ret 
13b4			.genlsword: 
13b4				ld hl, crs_s1 
13b4				ld de, .lsworddef 
13b4				call .genfile 
13b4				ret 
13b4			 
13b4			.genedword: 
13b4				ld de, .edworddef 
13b4				ld hl, crs_s2 
13b4				call .genfile 
13b4				ret 
13b4			 
13b4			.gendemword: 
13b4				ld de, .demoworddef 
13b4				ld hl, crs_s3 
13b4				call .genfile 
13b4				ret 
13b4			 
13b4			.genutlword: 
13b4				ld hl, crs_s4 
13b4				ld de, .utilwordef 
13b4				call .genfile 
13b4				ret 
13b4			.genspiword: 
13b4				ld hl, crs_s5 
13b4				ld de, .spiworddef 
13b4				call .genfile 
13b4				ret 
13b4			.genkeyword: 
13b4				ld hl, crs_s6 
13b4				ld de, .keyworddef 
13b4				call .genfile 
13b4				ret 
13b4			 
13b4			; hl - points to file name 
13b4			; de - points to strings to add to file 
13b4			 
13b4			.genfile: 
13b4				push hl 
13b4				push de 
13b4			 
13b4				call clear_display 
13b4				ld a, display_row_1 
13b4				ld de, .genfiletxt 
13b4				call str_at_display 
13b4				call update_display 
13b4			 
13b4				pop de 
13b4				pop hl 
13b4			 
13b4			 
13b4				push de 
13b4				call storage_create 
13b4				; id in hl 
13b4				pop de   ; table of strings to add 
13b4			 
13b4			.genloop: 
13b4			 
13b4				push hl ; save id for next time around 
13b4				push de ; save de for next time around 
13b4			 
13b4				ex de, hl 
13b4				call loadwordinhl 
13b4				ex de, hl 
13b4			 
13b4				; need hl to be the id 
13b4				; need de to be the string ptr 
13b4				 
13b4				call storage_append 
13b4			 
13b4				pop de 
13b4				pop hl 
13b4			 
13b4				inc de 
13b4				inc de 
13b4			 
13b4				ld a,(de) 
13b4				cp 0 
13b4				jr nz, .genloop 
13b4				inc de 
13b4				ld a, (de) 
13b4				dec de 
13b4				cp 0 
13b4				jr nz, .genloop	 
13b4			 
13b4				ret 
13b4			 
13b4			.genfiletxt:  db "Creating file...",0 
13b4			 
13b4			.hwworddef: 
13b4				dw test5 
13b4				dw test6 
13b4				dw test7 
13b4				dw test8 
13b4				dw test9 
13b4				dw test10 
13b4				dw 0 
13b4			 
13b4			.soundworddef: 
13b4				dw sound1 
13b4				dw sound2 
13b4				dw sound3 
13b4				dw sound4 
13b4				dw sound5 
13b4				dw sound6 
13b4				dw sound7 
13b4				dw sound8 
13b4				dw sound9 
13b4				dw 0 
13b4			 
13b4			.utilwordef: 
13b4				dw strncpy 
13b4				dw type 
13b4				dw clrstack 
13b4				dw longread 
13b4				dw start1 
13b4				dw start2 
13b4			; duplicated 
13b4			;	dw start3b 
13b4			;	dw start3c 
13b4				dw list 
13b4				dw 0 
13b4			 
13b4			.lsworddef: 
13b4				dw start3b 
13b4				dw 0 
13b4			 
13b4			.edworddef: 
13b4				dw edit1 
13b4				dw edit2 
13b4				dw edit3 
13b4				dw 0 
13b4			 
13b4			.demoworddef: 
13b4				dw game1 
13b4				dw game1a 
13b4				dw game1b 
13b4				dw game1c 
13b4				dw game1d 
13b4				dw game1s 
13b4				dw game1t 
13b4				dw game1f 
13b4				dw game1z 
13b4				dw game1zz 
13b4				dw ssv2 
13b4				dw ssv3 
13b4				dw ssv4 
13b4				dw ssv5 
13b4				dw ssv1 
13b4				dw ssv1cpm	 
13b4			;	dw game2b 
13b4			;	dw game2bf 
13b4			;	dw game2mba 
13b4			;	dw game2mbas	 
13b4			;	dw game2mbht 
13b4			;	dw game2mbms 
13b4			;	dw game2mb 
13b4			;	dw game3w 
13b4			;	dw game3p 
13b4			;	dw game3sc 
13b4			;	dw game3vsi 
13b4			;	dw game3vs 
13b4				dw 0 
13b4			 
13b4			 
13b4			.spiworddef: 
13b4			 
13b4			    dw spi1 
13b4			    dw spi2 
13b4			    dw spi2b 
13b4			    dw spi3 
13b4			    dw spi4 
13b4			    dw spi5 
13b4			;    dw spi6 
13b4			;    dw spi7 
13b4			 
13b4			;    dw spi8 
13b4			;    dw spi9 
13b4			;    dw spi10 
13b4			    dw 0 
13b4			 
13b4			.keyworddef: 
13b4			 
13b4				dw keyup 
13b4				dw keydown 
13b4				dw keyleft 
13b4				dw keyright 
13b4				dw 	keyf1 
13b4				dw keyf2 
13b4				dw keyf3 
13b4				dw keyf4 
13b4				dw keyf5 
13b4				dw keyf6 
13b4				dw keyf7 
13b4				dw keyf8 
13b4				dw keyf9 
13b4				dw keyf10 
13b4				dw keyf11 
13b4				dw keyf12 
13b4				dw keytab 
13b4				dw keycr 
13b4				dw keyhome 
13b4				dw keyend 
13b4				dw keybs 
13b4				dw 0 
13b4			 
13b4			.crstart: 
13b4				dw crs_s1 
13b4				dw crs_s2 
13b4				dw crs_s3 
13b4				dw crs_s4 
13b4				dw crs_s5 
13b4				dw crs_s6 
13b4				dw crs_sound 
13b4				dw crs_hw 
13b4				dw 0 
13b4			 
13b4			endif 
13b4			 
13b4			 
13b4			if STORAGE_SE 
13b4			 
13b4			config_fdir: 
13b4				; using the scratch dir go through and release the memory allocated for each string 
13b4				 
13b4				ld hl, scratch 
13b4			.cfdir:	ld e,(hl) 
13b4				inc hl 
13b4				ld d,(hl) 
13b4				inc hl 
13b4			 
13b4				ex de, hl 
13b4				call ishlzero 
13b4				ret z     ; return on null pointer 
13b4				call free 
13b4				ex de, hl 
13b4				jr .cfdir 
13b4			 
13b4			 
13b4				ret 
13b4			 
13b4			 
13b4			config_dir: 
13b4			 
13b4				; for the config menus that need to build a directory of storage call this routine 
13b4				; it will construct a menu in scratch to pass to menu 
13b4			 
13b4				; open storage device 
13b4			 
13b4				; execute DIR to build a list of files and their ids into scratch in menu format 
13b4				; once the menu has finished then will need to call config_fdir to release the strings 
13b4				 
13b4				; c = number items 
13b4			 
13b4				 
13b4				call storage_get_block_0 
13b4			 
13b4				ld hl, store_page     ; get current id count 
13b4				ld b, (hl) 
13b4				ld c, 0    ; count of files   
13b4			 
13b4			 
13b4				ld hl, scratch 
13b4				ld (store_tmp2), hl    ; location to poke strings 
13b4			 
13b4				; check for empty drive 
13b4			 
13b4				ld a, 0 
13b4				cp b 
13b4				jp z, .dirdone 
13b4			 
13b4				 
13b4					if DEBUG_FORTH_WORDS 
13b4						DMARK "Cdc" 
13b4						CALLMONITOR 
13b4					endif 
13b4			 
13b4			 
13b4			.diritem:	 
13b4				push bc 
13b4				; for each of the current ids do a search for them and if found push to stack 
13b4			 
13b4					ld hl, STORE_BLOCK_PHY 
13b4					ld d, 0		 ; look for extent 0 of block id as this contains file name 
13b4					ld e,b 
13b4			 
13b4					call storage_findnextid 
13b4			 
13b4			 
13b4					; if found hl will be non zero 
13b4			 
13b4					call ishlzero 
13b4					jr z, .dirnotfound 
13b4			 
13b4					; increase count 
13b4			 
13b4					pop bc	 
13b4					inc c 
13b4					push bc 
13b4					 
13b4			 
13b4					; get file header and push the file name 
13b4			 
13b4					ld de, store_page 
13b4					call storage_read_block 
13b4			 
13b4					; push file id to stack 
13b4				 
13b4					ld a, (store_page) 
13b4					ld h, 0 
13b4					ld l, a 
13b4			 
13b4					;call forth_push_numhl 
13b4					; TODO store id 
13b4			 
13b4					push hl 
13b4			 
13b4					; push extent count to stack  
13b4				 
13b4					ld hl, store_page+3 
13b4			 
13b4					; get file name length 
13b4			 
13b4					call strlenz   
13b4			 
13b4					inc hl   ; cover zero term 
13b4					inc hl  ; stick the id at the end of the area 
13b4			 
13b4					push hl 
13b4					pop bc    ; move length to bc 
13b4			 
13b4					call malloc 
13b4			 
13b4					; TODO save malloc area to scratch 
13b4			 
13b4					ex de, hl 
13b4					ld hl, (store_tmp2) 
13b4					ld (hl), e 
13b4					inc hl 
13b4					ld (hl), d 
13b4					inc hl 
13b4					ld (store_tmp2), hl 
13b4			 
13b4					 
13b4			 
13b4					;pop hl   ; get source 
13b4			;		ex de, hl    ; swap aronund	 
13b4			 
13b4					ld hl, store_page+3 
13b4					if DEBUG_FORTH_WORDS 
13b4						DMARK "CFd" 
13b4						CALLMONITOR 
13b4					endif 
13b4					ldir 
13b4			 
13b4					; de is past string, move back one and store id 
13b4					 
13b4					dec de 
13b4			 
13b4					; store file id 
13b4			 
13b4					pop hl 
13b4					ex de,hl 
13b4					ld (hl), e 
13b4			 
13b4					if DEBUG_FORTH_WORDS 
13b4						DMARK "Cdi" 
13b4						CALLMONITOR 
13b4					endif 
13b4					 
13b4			.dirnotfound: 
13b4					pop bc     
13b4					djnz .diritem 
13b4				 
13b4			.dirdone:	 
13b4			 
13b4					ld a, 0 
13b4					ld hl, (store_tmp2) 
13b4					ld (hl), a 
13b4					inc hl 
13b4					ld (hl), a 
13b4					inc hl 
13b4					; push a count of the dir items found 
13b4			 
13b4			;		ld h, 0 
13b4			;		ld l, c 
13b4			 
13b4				ret 
13b4			 
13b4			endif 
13b4			 
13b4			 
13b4			; Settings 
13b4			; Run  
13b4			 
13b4			 
13b4			 
13b4			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
13b4			;;hd_menu2:   db "        2: Editor",0   
13b4			;hd_menu2:   db "        2: Editor       6: Menu",0   
13b4			;hd_menu3:   db "        3: Storage",0 
13b4			;hd_menu4:   db "0=quit  4: Debug",0 
13b4			;hd_don:     db "ON",0 
13b4			;hd_doff:     db "OFF",0 
13b4			; 
13b4			; 
13b4			; 
13b4			;hardware_diags_old:       
13b4			; 
13b4			;.diagmenu: 
13b4			;	call clear_display 
13b4			;	ld a, display_row_1 
13b4			;	ld de, hd_menu1 
13b4			;	call str_at_display 
13b4			; 
13b4			;	ld a, display_row_2 
13b4			;	ld de, hd_menu2 
13b4			;	call str_at_display 
13b4			; 
13b4			;	ld a, display_row_3 
13b4			;	ld de, hd_menu3 
13b4			;	call str_at_display 
13b4			; 
13b4			;	ld a,  display_row_4 
13b4			;	ld de, hd_menu4 
13b4			;	call str_at_display 
13b4			; 
13b4			;	; display debug state 
13b4			; 
13b4			;	ld de, hd_don 
13b4			;	ld a, (os_view_disable) 
13b4			;	cp 0 
13b4			;	jr z, .distog 
13b4			;	ld de, hd_doff 
13b4			;.distog: ld a, display_row_4+17 
13b4			;	call str_at_display 
13b4			; 
13b4			;	call update_display 
13b4			; 
13b4			;	call cin_wait 
13b4			; 
13b4			; 
13b4			; 
13b4			;	cp '4' 
13b4			;	jr nz, .diagn1 
13b4			; 
13b4			;	; debug toggle 
13b4			; 
13b4			;	ld a, (os_view_disable) 
13b4			;	ld b, '*' 
13b4			;	cp 0 
13b4			;	jr z, .debtog 
13b4			;	ld b, 0 
13b4			;.debtog:	 
13b4			;	ld a,b 
13b4			;	ld (os_view_disable),a 
13b4			; 
13b4			;.diagn1: cp '0' 
13b4			;	 ret z 
13b4			; 
13b4			;;	cp '1' 
13b4			;;       jp z, matrix	 
13b4			;;   TODO keyboard matrix test 
13b4			; 
13b4			;	cp '2' 
13b4			;	jp z, .diagedit 
13b4			; 
13b4			;;	cp '6' 
13b4			;;	jp z, .menutest 
13b4			;;if ENABLE_BASIC 
13b4			;;	cp '6' 
13b4			;;	jp z, basic 
13b4			;;endif 
13b4			 ; 
13b4			;	jp .diagmenu 
13b4			; 
13b4			; 
13b4			;	ret 
13b4			 
13b4			 
13b4			.debug_tog: 
13b4 21 fe 13			ld hl, .menudebug 
13b7				 
13b7			;	ld a, (os_view_disable) 
13b7			;	cp '*' 
13b7 3a 6f ee			ld a,(debug_vector) 
13ba fe c9			cp $C9   ; RET 
13bc 20 04			jr nz,.tdon  
13be 3e 01			ld a, 1 
13c0 18 02			jr .tog1 
13c2 3e 00		.tdon: ld a, 0 
13c4			 
13c4			.tog1: 
13c4 cd ea 0b			call menu 
13c7 fe 00			cp 0 
13c9 c8				ret z 
13ca fe 01			cp 1    ; disable debug 
13cc 28 04			jr z, .dtog0 
13ce 3e 2a			ld a, '*' 
13d0 18 05			jr .dtogset 
13d2			.dtog0:  
13d2				;ld a, 0 
13d2 cd f0 14			call bp_on 
13d5 18 dd			jr .debug_tog 
13d7			.dtogset:  
13d7				; ld (os_view_disable), a 
13d7 cd fc 14			call bp_off 
13da c3 b4 13			jp .debug_tog 
13dd			 
13dd			 
13dd			hardware_diags:       
13dd			 
13dd			.diagm: 
13dd 21 f0 13			ld hl, .menuitems 
13e0 3e 00			ld a, 0 
13e2 cd ea 0b			call menu 
13e5			 
13e5 fe 00		         cp 0 
13e7 c8				 ret z 
13e8			 
13e8 fe 02			cp 2 
13ea ca 49 14			jp z, .diagedit 
13ed			 
13ed			;	cp '6' 
13ed			;	jp z, .menutest 
13ed			;if ENABLE_BASIC 
13ed			;	cp '6' 
13ed			;	jp z, basic 
13ed			;endif 
13ed			  
13ed c3 dd 13			jp .diagm 
13f0			 
13f0				 
13f0 04 14		.menuitems:   	dw .m1 
13f2 0f 14				dw .m2 
13f4 16 14				dw .m3 
13f6 1e 14				dw .m5 
13f8 24 14				dw .m5a 
13fa 2d 14				dw .m5b 
13fc 00 00				dw 0 
13fe			 
13fe			.menudebug: 
13fe 36 14				dw .m6 
1400 3f 14				dw .m7 
1402 00 00				dw 0 
1404			 
1404 .. 00		.m1:   db "Key Matrix",0 
140f .. 00		.m2:   db "Editor",0 
1416 .. 00		.m3:   db "Storage",0 
141e .. 00		.m5:   db "Sound",0 
1424 .. 00		.m5a:  db "RAM Test",0 
142d .. 00		.m5b:  db "LCD Test",0 
1436			 
1436 .. 00		.m6:   db "Debug ON",0 
143f .. 00		.m7:   db "Debug OFF",0 
1449			 
1449			; debug editor 
1449			 
1449			.diagedit: 
1449			 
1449 21 c1 e2			ld hl, scratch 
144c			;	ld bc, 250 
144c			;	ldir 
144c				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
144c 3e 00			ld a, 0 
144e 77				ld (hl), a 
144f 23				inc hl 
1450 77				ld (hl), a 
1451 23				inc hl 
1452 77				ld (hl), a 
1453			 
1453 cd b9 0b		        call clear_display 
1456 cd dc 0b			call update_display 
1459				;ld a, 1 
1459				;ld (hardware_diag), a 
1459			.diloop: 
1459 3e 00			ld a, display_row_1 
145b 0e 00			ld c, 0 
145d 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
145f 1e 28			ld e, 40 
1461			 
1461 21 c1 e2			ld hl, scratch	 
1464 cd 13 0e			call input_str 
1467			 
1467 3e 28			ld a, display_row_2 
1469 11 c1 e2			ld de, scratch 
146c cd cc 0b			call str_at_display 
146f cd dc 0b			call update_display 
1472			 
1472 c3 59 14			jp .diloop 
1475			 
1475			 
1475			; pass word in hl 
1475			; a has display location 
1475			display_word_at: 
1475 f5				push af 
1476 e5				push hl 
1477 7c				ld a,h 
1478 21 c6 e5			ld hl, os_word_scratch 
147b cd ef 0f			call hexout 
147e e1				pop hl 
147f 7d				ld a,l 
1480 21 c8 e5			ld hl, os_word_scratch+2 
1483 cd ef 0f			call hexout 
1486 21 ca e5			ld hl, os_word_scratch+4 
1489 3e 00			ld a,0 
148b 77				ld (hl),a 
148c 11 c6 e5			ld de,os_word_scratch 
148f f1				pop af 
1490 cd cc 0b				call str_at_display 
1493 c9				ret 
1494			 
1494			display_ptr_state: 
1494			 
1494				; to restore afterwards 
1494			 
1494 d5				push de 
1495 c5				push bc 
1496 e5				push hl 
1497 f5				push af 
1498			 
1498				; for use in here 
1498			 
1498			;	push bc 
1498			;	push de 
1498			;	push hl 
1498			;	push af 
1498			 
1498 cd b9 0b			call clear_display 
149b			 
149b 11 73 16			ld de, .ptrstate 
149e 3e 00			ld a, display_row_1 
14a0 cd cc 0b			call str_at_display 
14a3			 
14a3				; display debug step 
14a3			 
14a3			 
14a3 11 6b ee			ld de, debug_mark 
14a6 3e 26			ld a, display_row_1+display_cols-2 
14a8 cd cc 0b			call str_at_display 
14ab			 
14ab				; display a 
14ab 11 7d 16			ld de, .ptrcliptr 
14ae 3e 28			ld a, display_row_2 
14b0 cd cc 0b			call str_at_display 
14b3			 
14b3 f1				pop af 
14b4 2a 40 ea			ld hl,(cli_ptr) 
14b7 3e 30			ld a, display_row_2+8 
14b9 cd 75 14			call display_word_at 
14bc			 
14bc			 
14bc				; display hl 
14bc			 
14bc			 
14bc 11 85 16			ld de, .ptrclioptr 
14bf 3e 32			ld a, display_row_2+10 
14c1 cd cc 0b			call str_at_display 
14c4			; 
14c4			;	pop hl 
14c4 3e 35			ld a, display_row_2+13 
14c6 2a 3e ea			ld hl,(cli_origptr) 
14c9 cd 75 14			call display_word_at 
14cc			; 
14cc			;	 
14cc			;	; display de 
14cc			 
14cc			;	ld de, .regstatede 
14cc			;	ld a, display_row_3 
14cc			;	call str_at_display 
14cc			 
14cc			;	pop de 
14cc			;	ld h,d 
14cc			;	ld l, e 
14cc			;	ld a, display_row_3+3 
14cc			;	call display_word_at 
14cc			 
14cc			 
14cc				; display bc 
14cc			 
14cc			;	ld de, .regstatebc 
14cc			;	ld a, display_row_3+10 
14cc			;	call str_at_display 
14cc			 
14cc			;	pop bc 
14cc			;	ld h,b 
14cc			;	ld l, c 
14cc			;	ld a, display_row_3+13 
14cc			;	call display_word_at 
14cc			 
14cc			 
14cc				; display dsp 
14cc			 
14cc			;	ld de, .regstatedsp 
14cc			;	ld a, display_row_4 
14cc			;	call str_at_display 
14cc			 
14cc				 
14cc			;	ld hl,(cli_data_sp) 
14cc			;	ld a, display_row_4+4 
14cc			;	call display_word_at 
14cc			 
14cc				; display rsp 
14cc			 
14cc 11 b4 16			ld de, .regstatersp 
14cf 3e 82			ld a, display_row_4+10 
14d1 cd cc 0b			call str_at_display 
14d4			 
14d4				 
14d4 2a f2 e9			ld hl,(cli_ret_sp) 
14d7 3e 86			ld a, display_row_4+14 
14d9 cd 75 14			call display_word_at 
14dc			 
14dc cd dc 0b			call update_display 
14df			 
14df cd f1 0a			call delay1s 
14e2 cd f1 0a			call delay1s 
14e5 cd f1 0a			call delay1s 
14e8			 
14e8			 
14e8 cd e5 1a			call next_page_prompt 
14eb			 
14eb				; restore  
14eb			 
14eb f1				pop af 
14ec e1				pop hl 
14ed c1				pop bc 
14ee d1				pop de 
14ef c9				ret 
14f0			 
14f0			; Update the break point vector so that the user can hook a new routine 
14f0			 
14f0			bp_on: 
14f0 3e c3			ld a, $c3    ; JP 
14f2 32 6f ee			ld (debug_vector), a 
14f5 21 02 15			ld hl, break_point_state 
14f8 22 70 ee			ld (debug_vector+1), hl 
14fb c9				ret 
14fc			 
14fc			bp_off: 
14fc 3e c9			ld a, $c9    ; RET 
14fe 32 6f ee			ld (debug_vector), a 
1501 c9				ret 
1502			 
1502			 
1502			break_point_state: 
1502			;	push af 
1502			; 
1502			;	; see if disabled 
1502			; 
1502			;	ld a, (os_view_disable) 
1502			;	cp '*' 
1502			;	jr nz, .bpsgo 
1502			;	pop af 
1502			;	ret 
1502			 
1502			.bpsgo: 
1502			;	pop af 
1502 f5				push af 
1503 22 a3 e2			ld (os_view_hl), hl 
1506 ed 53 a1 e2		ld (os_view_de), de 
150a ed 43 9f e2		ld (os_view_bc), bc 
150e e5				push hl 
150f 6f				ld l, a 
1510 26 00			ld h, 0 
1512 22 a5 e2			ld (os_view_af),hl 
1515			 
1515 21 b1 ed				ld hl, display_fb0 
1518 22 cc eb				ld (display_fb_active), hl 
151b e1				pop hl	 
151c			 
151c 3e 31			ld a, '1' 
151e fe 2a		.bps1:  cp '*' 
1520 cc fc 14			call z, bp_off 
1523			;	jr nz, .bps1b 
1523			;	ld (os_view_disable),a 
1523 fe 31		.bps1b:  cp '1' 
1525 20 14			jr nz, .bps2 
1527			 
1527				; display reg 
1527			 
1527				 
1527			 
1527 3a a5 e2			ld a, (os_view_af) 
152a 2a a3 e2			ld hl, (os_view_hl) 
152d ed 5b a1 e2		ld de, (os_view_de) 
1531 ed 4b 9f e2		ld bc, (os_view_bc) 
1535 cd cf 15			call display_reg_state 
1538 c3 bb 15			jp .bpschk 
153b			 
153b fe 32		.bps2:  cp '2' 
153d 20 08			jr nz, .bps3 
153f				 
153f				; display hl 
153f 2a a3 e2			ld hl, (os_view_hl) 
1542 cd b9 16			call display_dump_at_hl 
1545			 
1545 18 74			jr .bpschk 
1547			 
1547 fe 33		.bps3:  cp '3' 
1549 20 08			jr nz, .bps4 
154b			 
154b			        ; display de 
154b 2a a1 e2			ld hl, (os_view_de) 
154e cd b9 16			call display_dump_at_hl 
1551			 
1551 18 68			jr .bpschk 
1553 fe 34		.bps4:  cp '4' 
1555 20 08			jr nz, .bps5 
1557			 
1557			        ; display bc 
1557 2a 9f e2			ld hl, (os_view_bc) 
155a cd b9 16			call display_dump_at_hl 
155d			 
155d 18 5c			jr .bpschk 
155f fe 35		.bps5:  cp '5' 
1561 20 08		        jr nz, .bps7 
1563			 
1563				; display cur ptr 
1563 2a 40 ea			ld hl, (cli_ptr) 
1566 cd b9 16			call display_dump_at_hl 
1569			 
1569 18 50			jr .bpschk 
156b fe 36		.bps7:  cp '6' 
156d 20 08			jr nz, .bps8b 
156f				 
156f				; display cur orig ptr 
156f 2a 3e ea			ld hl, (cli_origptr) 
1572 cd b9 16			call display_dump_at_hl 
1575 18 44			jr .bpschk 
1577 fe 37		.bps8b:  cp '7' 
1579 20 08			jr nz, .bps9 
157b				 
157b				; display dsp 
157b 2a ee e9			ld hl, (cli_data_sp) 
157e cd b9 16			call display_dump_at_hl 
1581			 
1581 18 38			jr .bpschk 
1583 fe 39		.bps9:  cp '9' 
1585 20 05			jr nz, .bps8c 
1587				 
1587				; display SP 
1587			;	ld hl, sp 
1587 cd b9 16			call display_dump_at_hl 
158a			 
158a 18 2f			jr .bpschk 
158c fe 38		.bps8c:  cp '8' 
158e 20 08			jr nz, .bps8d 
1590				 
1590				; display rsp 
1590 2a f2 e9			ld hl, (cli_ret_sp) 
1593 cd b9 16			call display_dump_at_hl 
1596			 
1596 18 23			jr .bpschk 
1598 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
159a 20 05			jr nz, .bps8 
159c cd b3 18			call monitor 
159f			 
159f 18 1a			jr .bpschk 
15a1 fe 30		.bps8:  cp '0' 
15a3 20 16			jr nz, .bpschk 
15a5			 
15a5 21 10 ed				ld hl, display_fb1 
15a8 22 cc eb				ld (display_fb_active), hl 
15ab cd dc 0b				call update_display 
15ae			 
15ae				;ld a, (os_view_af) 
15ae 2a a3 e2			ld hl, (os_view_hl) 
15b1 ed 5b a1 e2		ld de, (os_view_de) 
15b5 ed 4b 9f e2		ld bc, (os_view_bc) 
15b9 f1				pop af 
15ba c9				ret 
15bb			 
15bb			.bpschk:   
15bb cd f1 0a			call delay1s 
15be 3e 9f		ld a,display_row_4 + display_cols - 1 
15c0 11 e3 1a		        ld de, endprg 
15c3 cd cc 0b			call str_at_display 
15c6 cd dc 0b			call update_display 
15c9 cd 53 5e			call cin_wait 
15cc			 
15cc c3 1e 15			jp .bps1 
15cf			 
15cf			 
15cf			display_reg_state: 
15cf			 
15cf				; to restore afterwards 
15cf			 
15cf d5				push de 
15d0 c5				push bc 
15d1 e5				push hl 
15d2 f5				push af 
15d3			 
15d3				; for use in here 
15d3			 
15d3 c5				push bc 
15d4 d5				push de 
15d5 e5				push hl 
15d6 f5				push af 
15d7			 
15d7 cd b9 0b			call clear_display 
15da			 
15da 11 8f 16			ld de, .regstate 
15dd 3e 00			ld a, display_row_1 
15df cd cc 0b			call str_at_display 
15e2			 
15e2				; display debug step 
15e2			 
15e2			 
15e2 11 6b ee			ld de, debug_mark 
15e5 3e 25			ld a, display_row_1+display_cols-3 
15e7 cd cc 0b			call str_at_display 
15ea			 
15ea				; display a 
15ea 11 ab 16			ld de, .regstatea 
15ed 3e 28			ld a, display_row_2 
15ef cd cc 0b			call str_at_display 
15f2			 
15f2 e1				pop hl 
15f3			;	ld h,0 
15f3			;	ld l, a 
15f3 3e 2b			ld a, display_row_2+3 
15f5 cd 75 14			call display_word_at 
15f8			 
15f8			 
15f8				; display hl 
15f8			 
15f8			 
15f8 11 9f 16			ld de, .regstatehl 
15fb 3e 32			ld a, display_row_2+10 
15fd cd cc 0b			call str_at_display 
1600			 
1600 e1				pop hl 
1601 3e 35			ld a, display_row_2+13 
1603 cd 75 14			call display_word_at 
1606			 
1606				 
1606				; display de 
1606			 
1606 11 a3 16			ld de, .regstatede 
1609 3e 50			ld a, display_row_3 
160b cd cc 0b			call str_at_display 
160e			 
160e e1				pop hl 
160f			;	ld h,d 
160f			;	ld l, e 
160f 3e 53			ld a, display_row_3+3 
1611 cd 75 14			call display_word_at 
1614			 
1614			 
1614				; display bc 
1614			 
1614 11 a7 16			ld de, .regstatebc 
1617 3e 5a			ld a, display_row_3+10 
1619 cd cc 0b			call str_at_display 
161c			 
161c e1				pop hl 
161d			;	ld h,b 
161d			;	ld l, c 
161d 3e 5d			ld a, display_row_3+13 
161f cd 75 14			call display_word_at 
1622			 
1622			 
1622				; display dsp 
1622			 
1622 11 af 16			ld de, .regstatedsp 
1625 3e 78			ld a, display_row_4 
1627 cd cc 0b			call str_at_display 
162a			 
162a				 
162a 2a ee e9			ld hl,(cli_data_sp) 
162d 3e 7c			ld a, display_row_4+4 
162f cd 75 14			call display_word_at 
1632			 
1632				; display rsp 
1632			 
1632 11 b4 16			ld de, .regstatersp 
1635 3e 82			ld a, display_row_4+10 
1637 cd cc 0b			call str_at_display 
163a			 
163a				 
163a 2a f2 e9			ld hl,(cli_ret_sp) 
163d 3e 86			ld a, display_row_4+14 
163f cd 75 14			call display_word_at 
1642			 
1642 cd dc 0b			call update_display 
1645			 
1645			;	call delay1s 
1645			;	call delay1s 
1645			;	call delay1s 
1645			 
1645			 
1645			;	call next_page_prompt 
1645			 
1645				; restore  
1645			 
1645 f1				pop af 
1646 e1				pop hl 
1647 c1				pop bc 
1648 d1				pop de 
1649 c9				ret 
164a			 
164a .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
165e .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1673 .. 00		.ptrstate:	db "Ptr State",0 
167d .. 00		.ptrcliptr:     db "cli_ptr",0 
1685 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
168f .. 00		.regstate:	db "Reg State (1/0)",0 
169f .. 00		.regstatehl:	db "HL:",0 
16a3 .. 00		.regstatede:	db "DE:",0 
16a7 .. 00		.regstatebc:	db "BC:",0 
16ab .. 00		.regstatea:	db "A :",0 
16af .. 00		.regstatedsp:	db "DSP:",0 
16b4 .. 00		.regstatersp:	db "RSP:",0 
16b9			 
16b9			display_dump_at_hl: 
16b9 e5				push hl 
16ba d5				push de 
16bb c5				push bc 
16bc f5				push af 
16bd			 
16bd 22 e4 e5			ld (os_cur_ptr),hl	 
16c0 cd b9 0b			call clear_display 
16c3 cd ed 19			call dumpcont 
16c6			;	call delay1s 
16c6			;	call next_page_prompt 
16c6			 
16c6			 
16c6 f1				pop af 
16c7 c1				pop bc 
16c8 d1				pop de 
16c9 e1				pop hl 
16ca c9				ret 
16cb			 
16cb			;if ENABLE_BASIC 
16cb			;	include "nascombasic.asm" 
16cb			;	basic: 
16cb			;	include "forth/FORTH.ASM" 
16cb			;endif 
16cb			 
16cb			; eof 
16cb			 
16cb			 
# End of file firmware_diags.asm
16cb			  
16cb			include "firmware_prompts.asm"  
16cb			; Prompts  
16cb			 
16cb			; boot messages 
16cb			 
16cb .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
16e0 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
16f0			 
16f0			 
16f0			; config menus 
16f0			 
16f0			;prom_c3: db "Add Dictionary To File",0 
16f0			 
16f0			if STARTUP_V1 
16f0 .. 00		prom_c2: db "Select Autoload File",0 
1705 .. 00		prom_c2a: db "Disable Autoload File", 0 
171b			endif 
171b			 
171b			if STARTUP_V2 
171b			prom_c2: db "Enable Autoload Files",0 
171b			prom_c2a: db "Disable Autoload Files", 0 
171b			 
171b			crs_s1: db "*ls-word", 0 
171b			crs_s2: db "*ed-word", 0 
171b			crs_s3: db "*Demo-Games", 0 
171b			crs_s4: db "*Utils", 0 
171b			crs_s5: db "*SPI-Util", 0 
171b			crs_s6: db "*Key-Constants", 0 
171b			crs_sound: db "*Sound-Util", 0 
171b			crs_hw: db "*Hello-World",0 
171b			 
171b			 
171b			 
171b			endif 
171b			;prom_c2b: db "Select Storage Bank",0 
171b .. 00		prom_c4: db "Settings",0 
1724 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
173f .. 00		prom_m4b:   db "Monitor",0 
1747 .. 00		prom_c1: db "Hardware Diags",0 
1756			 
1756			 
1756			if STARTUP_V2 
1756			prom_c9: db "Create Startup Files",0 
1756			endif 
1756			 
1756 .. 00		prom_notav:    db "Feature not available",0 
176c .. 00		prom_empty:    db "",0 
176d			 
176d			; eof 
176d			 
# End of file firmware_prompts.asm
176d			  
176d			  
176d			; eof  
176d			  
# End of file firmware.asm
176d			 
176d			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
176d			;if BASE_KEV  
176d			;baseram: equ 08000h 
176d			;endif 
176d			 
176d			;if BASE_SC114 
176d			;baseram:     equ    endofcode 
176d			;endif 
176d			 
176d			 
176d			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
176d			 
176d			; start system 
176d			 
176d			coldstart: 
176d				; set sp 
176d				; di/ei 
176d			 
176d f3				di 
176e 31 00 f0			ld sp, tos 
1771 cd 51 5d			call init_nmi 
1774			;	ei 
1774			 
1774				; init spinner 
1774 3e 00			ld a,0 
1776 32 c6 eb			ld (display_active), a 
1779			 
1779				; disable breakpoint by default 
1779			 
1779				;ld a,'*' 
1779			;	ld a,' ' 
1779			;	ld (os_view_disable),a 
1779			 
1779				; set break point vector as new break point on or off 
1779 cd fc 14			call bp_off 
177c			 
177c				; init hardware 
177c			 
177c				; init keyboard and screen hardware 
177c			 
177c cd 1b 01			call hardware_init 
177f			 
177f			 
177f cd f1 0a			call delay1s 
1782 3e 58			ld a, display_row_3+8 
1784 11 03 01			ld de, buildtime 
1787 cd cc 0b			call str_at_display 
178a cd dc 0b			call update_display 
178d			 
178d cd f1 0a			call delay1s 
1790 cd f1 0a			call delay1s 
1793 cd f1 0a			call delay1s 
1796			 
1796				; detect if any keys are held down to enable breakpoints at start up 
1796			 
1796 cd 5b 5e			call cin  
1799 fe 00			cp 0 
179b 28 03			jr z, .nokeys 
179d			 
179d				;call hardware_diags 
179d cd 5a 13			call config 
17a0			 
17a0			;	ld de, .bpen 
17a0			;	ld a, display_row_4 
17a0			;	call str_at_display 
17a0			;	call update_display 
17a0			; 
17a0			;	ld a,0 
17a0			;	ld (os_view_disable),a 
17a0			; 
17a0			;.bpwait: 
17a0			;	call cin 
17a0			;	cp 0 
17a0			;	jr z, .bpwait 
17a0			;	jr .nokeys 
17a0			; 
17a0			; 
17a0			;.bpen:  db "Break points enabled!",0 
17a0			 
17a0			 
17a0			 
17a0			 
17a0			 
17a0			 
17a0			.nokeys: 
17a0			 
17a0			 
17a0				 
17a0			 
17a0			;jp  testkey 
17a0			 
17a0			;call storage_get_block_0 
17a0			; 
17a0			;ld hl, 0 
17a0			;ld de, store_page 
17a0			;call storage_read_block 
17a0			 
17a0				 
17a0			;ld hl, 10 
17a0			;ld de, store_page 
17a0			;call storage_read_block 
17a0			 
17a0			 
17a0			 
17a0			 
17a0			 
17a0			;stop:	nop 
17a0			;	jp stop 
17a0			 
17a0			 
17a0			 
17a0			main: 
17a0 cd b9 0b			call clear_display 
17a3 cd dc 0b			call update_display 
17a6			 
17a6			 
17a6			 
17a6			;	call testlcd 
17a6			 
17a6			 
17a6			 
17a6 cd f8 1e			call forth_init 
17a9			 
17a9			 
17a9			warmstart: 
17a9 cd ce 1e			call forth_warmstart 
17ac			 
17ac				; run startup word load 
17ac			        ; TODO prevent this running at warmstart after crash  
17ac			 
17ac				if STARTUP_ENABLE 
17ac			 
17ac					if STARTUP_V1 
17ac			 
17ac						if STORAGE_SE 
17ac							call forth_autoload 
17ac						endif 
17ac cd a1 5c					call forth_startup 
17af					endif 
17af			 
17af					if STARTUP_V2 
17af			 
17af						if STORAGE_SE 
17af							call forth_autoload 
17af						else 
17af							call forth_startup 
17af						endif 
17af			 
17af			 
17af					endif 
17af			 
17af				endif 
17af			 
17af				; show free memory after boot 
17af 11 4e 18			ld de, freeram 
17b2 3e 00			ld a, display_row_1 
17b4 cd cc 0b			call str_at_display 
17b7			 
17b7				; get current heap start after loading any uwords 
17b7			 
17b7				;ld de, (os_last_new_uword) 
17b7				;ex de, hl 
17b7			 
17b7			; Or use heap_size word???? 
17b7				;ld hl, heap_end 
17b7				;ld hl, heap_size 
17b7				;ld de, topusermem 
17b7				;ld de, heap_start 
17b7 ed 5b 7e 5e			ld de, (free_list )      
17bb 21 9c e2				ld hl, heap_end 
17be ed 52			sbc hl, de 
17c0				;push hl 
17c0				;ld a,h	         	 
17c0				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
17c0				;call hexout 
17c0			   	;pop hl 
17c0			; 
17c0			;	ld a,l 
17c0			;	ld hl, os_word_scratch+2 
17c0			;	call hexout 
17c0			;	ld hl, os_word_scratch+4 
17c0			;	ld a, 0 
17c0			;	ld (hl),a 
17c0 eb				ex de, hl 
17c1 21 c6 e5			ld hl, os_word_scratch 
17c4 cd fb 10			call uitoa_16 
17c7			 
17c7			 
17c7 11 c6 e5			ld de, os_word_scratch 
17ca 3e 0d			ld a, display_row_1 + 13 
17cc cd cc 0b			call str_at_display 
17cf cd dc 0b			call update_display 
17d2			 
17d2			 
17d2				;call demo 
17d2			 
17d2			 
17d2				; init scratch input area for cli commands 
17d2			 
17d2 21 e8 e5			ld hl, os_cli_cmd 
17d5 3e 00			ld a,0 
17d7 77				ld (hl),a 
17d8 23				inc hl 
17d9 77				ld (hl),a 
17da			 
17da 3e 00			ld a,0 
17dc 32 e7 e6			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
17df			 
17df 32 e4 e5			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
17e2 32 e5 e5			ld (os_cur_ptr+1),a	 
17e5			 
17e5 32 c6 e5			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
17e8 32 c7 e5			ld (os_word_scratch+1),a	 
17eb				 
17eb			 
17eb				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17eb 21 e8 e5			ld hl, os_cli_cmd 
17ee			 
17ee 3e 00			ld a, 0		 ; init cli input 
17f0 77				ld (hl), a 
17f1 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17f3			cli: 
17f3				; show cli prompt 
17f3				;push af 
17f3				;ld a, 0 
17f3				;ld de, prompt 
17f3				;call str_at_display 
17f3			 
17f3				;call update_display 
17f3				;pop af 
17f3				;inc a 
17f3				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
17f3			 
17f3			.lastrecall: 
17f3			 
17f3 0e 00			ld c, 0 
17f5 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
17f7 1e 28			ld e, 40 
17f9			 
17f9 21 e8 e5			ld hl, os_cli_cmd 
17fc			 
17fc				STACKFRAME OFF $fefe $9f9f 
17fc				if DEBUG_STACK_IMB 
17fc					if OFF 
17fc						exx 
17fc						ld de, $fefe 
17fc						ld a, d 
17fc						ld hl, curframe 
17fc						call hexout 
17fc						ld a, e 
17fc						ld hl, curframe+2 
17fc						call hexout 
17fc						ld hl, $fefe 
17fc						push hl 
17fc						ld hl, $9f9f 
17fc						push hl 
17fc						exx 
17fc					endif 
17fc				endif 
17fc			endm 
# End of macro STACKFRAME
17fc			 
17fc cd 13 0e			call input_str 
17ff			 
17ff				STACKFRAMECHK OFF $fefe $9f9f 
17ff				if DEBUG_STACK_IMB 
17ff					if OFF 
17ff						exx 
17ff						ld hl, $9f9f 
17ff						pop de   ; $9f9f 
17ff						call cmp16 
17ff						jr nz, .spnosame 
17ff						ld hl, $fefe 
17ff						pop de   ; $fefe 
17ff						call cmp16 
17ff						jr z, .spfrsame 
17ff						.spnosame: call showsperror 
17ff						.spfrsame: nop 
17ff						exx 
17ff					endif 
17ff				endif 
17ff			endm 
# End of macro STACKFRAMECHK
17ff			 
17ff			 
17ff				; check to see if last line recall has been requested 
17ff			 
17ff			if EDIT_V2 
17ff fe 05			cp KEY_UP 
1801 20 0f			jr nz, .noexecline 
1803			 
1803 11 e8 e5			ld de, os_cli_cmd 
1806 21 e7 e6			ld hl, os_last_cmd 
1809 01 ff 00			ld bc, 255 
180c ed b0			ldir 
180e 3e 00			ld a, 0 
1810 18 e1			jr .lastrecall 
1812			endif 
1812			 
1812			.noexecline: 
1812				; no so exec the line		 
1812			 
1812				; copy input to last command 
1812			 
1812 21 e8 e5			ld hl, os_cli_cmd 
1815 11 e7 e6			ld de, os_last_cmd 
1818 01 ff 00			ld bc, 255 
181b ed b0			ldir 
181d			 
181d				; wipe current buffer 
181d			 
181d			;	ld a, 0 
181d			;	ld hl, os_cli_cmd 
181d			;	ld de, os_cli_cmd+1 
181d			;	ld bc, 254 
181d			;	ldir 
181d				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
181d			;	call strcpy 
181d			;	ld a, 0 
181d			;	ld (hl), a 
181d			;	inc hl 
181d			;	ld (hl), a 
181d			;	inc hl 
181d			;	ld (hl), a 
181d			 
181d				; switch frame buffer to program  
181d			 
181d 21 10 ed				ld hl, display_fb1 
1820 22 cc eb				ld (display_fb_active), hl 
1823			 
1823			;	nop 
1823				STACKFRAME ON $fbfe $8f9f 
1823				if DEBUG_STACK_IMB 
1823					if ON 
1823						exx 
1823						ld de, $fbfe 
1823						ld a, d 
1823						ld hl, curframe 
1823						call hexout 
1823						ld a, e 
1823						ld hl, curframe+2 
1823						call hexout 
1823						ld hl, $fbfe 
1823						push hl 
1823						ld hl, $8f9f 
1823						push hl 
1823						exx 
1823					endif 
1823				endif 
1823			endm 
# End of macro STACKFRAME
1823				; first time into the parser so pass over the current scratch pad 
1823 21 e8 e5			ld hl,os_cli_cmd 
1826				; tokenise the entered statement(s) in HL 
1826 cd 76 1f			call forthparse 
1829			        ; exec forth statements in top of return stack 
1829 cd b6 1f			call forthexec 
182c				;call forthexec_cleanup 
182c			;	call parsenext 
182c			 
182c				STACKFRAMECHK ON $fbfe $8f9f 
182c				if DEBUG_STACK_IMB 
182c					if ON 
182c						exx 
182c						ld hl, $8f9f 
182c						pop de   ; $8f9f 
182c						call cmp16 
182c						jr nz, .spnosame 
182c						ld hl, $fbfe 
182c						pop de   ; $fbfe 
182c						call cmp16 
182c						jr z, .spfrsame 
182c						.spnosame: call showsperror 
182c						.spfrsame: nop 
182c						exx 
182c					endif 
182c				endif 
182c			endm 
# End of macro STACKFRAMECHK
182c				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
182c			 
182c 3e 78			ld a, display_row_4 
182e 11 5f 18			ld de, endprog 
1831			 
1831 cd dc 0b			call update_display		 
1834			 
1834 cd e5 1a			call next_page_prompt 
1837			 
1837				; switch frame buffer to cli 
1837			 
1837 21 b1 ed				ld hl, display_fb0 
183a 22 cc eb				ld (display_fb_active), hl 
183d			 
183d			 
183d cd b9 0b		        call clear_display 
1840 cd dc 0b			call update_display		 
1843			 
1843 21 e8 e5			ld hl, os_cli_cmd 
1846			 
1846 3e 00			ld a, 0		 ; init cli input 
1848 77				ld (hl), a 
1849			 
1849				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1849			 
1849				; now on last line 
1849			 
1849				; TODO scroll screen up 
1849			 
1849				; TODO instead just clear screen and place at top of screen 
1849			 
1849			;	ld a, 0 
1849			;	ld (f_cursor_ptr),a 
1849			 
1849				;call clear_display 
1849				;call update_display 
1849			 
1849				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1849 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
184b c3 f3 17			jp cli 
184e			 
184e .. 00		freeram: db "Free bytes: ",0 
185b ..			asc: db "1A2F" 
185f .. 00		endprog: db "End prog...",0 
186b			 
186b			testenter2:   
186b 21 f3 e2			ld hl,scratch+50 
186e 22 e4 e5			ld (os_cur_ptr),hl 
1871 c3 f3 17			jp cli 
1874			 
1874			testenter:  
1874			 
1874 21 5b 18			ld hl,asc 
1877			;	ld a,(hl) 
1877			;	call nibble2val 
1877 cd 45 10			call get_byte 
187a			 
187a			 
187a			;	ld a,(hl) 
187a			;	call atohex 
187a			 
187a			;	call fourehexhl 
187a 32 f3 e2			ld (scratch+50),a 
187d			 
187d			 
187d			 
187d 21 5d 18			ld hl,asc+2 
1880			;	ld a, (hl) 
1880			;	call nibble2val 
1880 cd 45 10			call get_byte 
1883			 
1883			;	call fourehexhl 
1883 32 f5 e2			ld (scratch+52),a 
1886				 
1886 21 f3 e2			ld hl,scratch+50 
1889 22 e4 e5			ld (os_cur_ptr),hl 
188c c3 f3 17			jp cli 
188f			 
188f			enter:	 
188f 3a c5 e2			ld a,(scratch+4) 
1892 fe 00			cp 0 
1894 28 0c			jr z, .entercont 
1896				; no, not a null term line so has an address to work out.... 
1896			 
1896 21 c3 e2			ld hl,scratch+2 
1899 cd a5 10			call get_word_hl 
189c			 
189c 22 e4 e5			ld (os_cur_ptr),hl	 
189f c3 f3 17			jp cli 
18a2			 
18a2			 
18a2			.entercont:  
18a2			 
18a2 21 c3 e2			ld hl, scratch+2 
18a5 cd 45 10			call get_byte 
18a8			 
18a8 2a e4 e5		   	ld hl,(os_cur_ptr) 
18ab 77					ld (hl),a 
18ac 23					inc hl 
18ad 22 e4 e5				ld (os_cur_ptr),hl 
18b0				 
18b0			; get byte  
18b0			 
18b0			 
18b0 c3 f3 17			jp cli 
18b3			 
18b3			 
18b3			; basic monitor support 
18b3			 
18b3			monitor: 
18b3				;  
18b3 cd b9 0b			call clear_display 
18b6 3e 00			ld a, 0 
18b8 11 07 19			ld de, .monprompt 
18bb cd cc 0b			call str_at_display 
18be cd dc 0b			call update_display 
18c1			 
18c1				; get a monitor command 
18c1			 
18c1 0e 00			ld c, 0     ; entry at top left 
18c3 16 64			ld d, 100   ; max buffer size 
18c5 1e 0f			ld e, 15    ; input scroll area 
18c7 3e 00			ld a, 0     ; init string 
18c9 21 bf e4			ld hl, os_input 
18cc 77				ld (hl), a 
18cd 23				inc hl 
18ce 77				ld (hl), a 
18cf 21 bf e4			ld hl, os_input 
18d2 3e 01			ld a, 1     ; init string 
18d4 cd 13 0e			call input_str 
18d7			 
18d7 cd b9 0b		        call clear_display 
18da cd dc 0b			call update_display		 
18dd			 
18dd 3a bf e4			ld a, (os_input) 
18e0 cd 43 11			call toUpper 
18e3 fe 48		        cp 'H' 
18e5 ca 6c 19		        jp z, .monhelp 
18e8 fe 44			cp 'D'		; dump 
18ea ca 9f 19			jp z, .mondump	 
18ed fe 43			cp 'C'		; dump 
18ef ca b9 19			jp z, .moncdump	 
18f2 fe 4d			cp 'M'		; dump 
18f4 ca 09 19			jp z, .moneditstart 
18f7 fe 55			cp 'U'		; dump 
18f9 ca 15 19			jp z, .monedit	 
18fc fe 47			cp 'G'		; dump 
18fe ca 95 19			jp z, .monjump 
1901 fe 51			cp 'Q'		; dump 
1903 c8				ret z	 
1904			 
1904			 
1904				; TODO "S" to access symbol by name and not need the address 
1904				; TODO "F" to find a string in memory 
1904			 
1904 c3 b3 18			jp monitor 
1907			 
1907 .. 00		.monprompt: db ">", 0 
1909			 
1909			.moneditstart: 
1909				; get starting address 
1909			 
1909 21 c1 e4			ld hl,os_input+2 
190c cd a5 10			call get_word_hl 
190f			 
190f 22 e4 e5			ld (os_cur_ptr),hl	 
1912			 
1912 c3 b3 18			jp monitor 
1915			 
1915			.monedit: 
1915				; get byte to load 
1915			 
1915 21 c1 e4			ld hl,os_input+2 
1918 cd 45 10			call get_byte 
191b			 
191b				; get address to update 
191b 2a e4 e5			ld hl, (os_cur_ptr) 
191e			 
191e				; update byte 
191e			 
191e 77				ld (hl), a 
191f			 
191f				; move to next address and save it 
191f			 
191f 23				inc hl 
1920 22 e4 e5			ld (os_cur_ptr),hl	 
1923			 
1923 c3 b3 18			jp monitor 
1926			 
1926			 
1926 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
193a .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1956 .. 00		.monhelptext3:  db "G-Call address",0 
1965 .. 00		.monhelptext4:  db "Q-Quit",0 
196c			        
196c			.monhelp: 
196c 3e 00			ld a, display_row_1 
196e 11 26 19		        ld de, .monhelptext1 
1971			 
1971 cd cc 0b			call str_at_display 
1974 3e 28			ld a, display_row_2 
1976 11 3a 19		        ld de, .monhelptext2 
1979					 
1979 cd cc 0b			call str_at_display 
197c 3e 50			ld a, display_row_3 
197e 11 56 19		        ld de, .monhelptext3 
1981					 
1981 cd cc 0b			call str_at_display 
1984 3e 78			ld a, display_row_4 
1986 11 65 19		        ld de, .monhelptext4 
1989 cd cc 0b			call str_at_display 
198c			 
198c cd dc 0b			call update_display		 
198f			 
198f cd e5 1a			call next_page_prompt 
1992 c3 b3 18			jp monitor 
1995			 
1995			.monjump:    
1995 21 c1 e4			ld hl,os_input+2 
1998 cd a5 10			call get_word_hl 
199b			 
199b e9				jp (hl) 
199c c3 b3 18			jp monitor 
199f			 
199f			.mondump:    
199f 21 c1 e4			ld hl,os_input+2 
19a2 cd a5 10			call get_word_hl 
19a5			 
19a5 22 e4 e5			ld (os_cur_ptr),hl	 
19a8 cd ed 19			call dumpcont 
19ab 3e 78			ld a, display_row_4 
19ad 11 5f 18			ld de, endprog 
19b0			 
19b0 cd dc 0b			call update_display		 
19b3			 
19b3 cd e5 1a			call next_page_prompt 
19b6 c3 b3 18			jp monitor 
19b9			.moncdump: 
19b9 cd ed 19			call dumpcont 
19bc 3e 78			ld a, display_row_4 
19be 11 5f 18			ld de, endprog 
19c1			 
19c1 cd dc 0b			call update_display		 
19c4			 
19c4 cd e5 1a			call next_page_prompt 
19c7 c3 b3 18			jp monitor 
19ca			 
19ca			 
19ca			; TODO symbol access  
19ca			 
19ca			.symbols:     ;; A list of symbols that can be called up  
19ca b1 ed			dw display_fb0 
19cc .. 00			db "fb0",0  
19d0 7a ea		     	dw store_page 
19d2 .. 00			db "store_page",0 
19dd			 
19dd			 
19dd			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
19dd			 
19dd 3a c2 e2			ld a,(scratch+1) 
19e0 fe 00			cp 0 
19e2 28 09			jr z, dumpcont 
19e4			 
19e4				; no, not a null term line so has an address to work out.... 
19e4			 
19e4 21 c3 e2			ld hl,scratch+2 
19e7 cd a5 10			call get_word_hl 
19ea			 
19ea 22 e4 e5			ld (os_cur_ptr),hl	 
19ed			 
19ed			 
19ed			 
19ed			dumpcont: 
19ed			 
19ed				; dump bytes at ptr 
19ed			 
19ed			 
19ed 3e 00			ld a, display_row_1 
19ef 2a cc eb			ld hl, (display_fb_active) 
19f2 cd e6 0d			call addatohl 
19f5 cd 1d 1a			call .dumpbyterow 
19f8			 
19f8 3e 28			ld a, display_row_2 
19fa 2a cc eb			ld hl, (display_fb_active) 
19fd cd e6 0d			call addatohl 
1a00 cd 1d 1a			call .dumpbyterow 
1a03			 
1a03			 
1a03 3e 50			ld a, display_row_3 
1a05 2a cc eb			ld hl, (display_fb_active) 
1a08 cd e6 0d			call addatohl 
1a0b cd 1d 1a			call .dumpbyterow 
1a0e			 
1a0e 3e 78			ld a, display_row_4 
1a10 2a cc eb			ld hl, (display_fb_active) 
1a13 cd e6 0d			call addatohl 
1a16 cd 1d 1a			call .dumpbyterow 
1a19			 
1a19 cd dc 0b			call update_display 
1a1c			;		jp cli 
1a1c c9				ret 
1a1d			 
1a1d			.dumpbyterow: 
1a1d			 
1a1d				;push af 
1a1d			 
1a1d e5				push hl 
1a1e			 
1a1e				; calc where to poke the ascii 
1a1e			if display_cols == 20 
1a1e				ld a, 16 
1a1e			else 
1a1e 3e 1f			ld a, 31 
1a20			endif 
1a20			 
1a20 cd e6 0d			call addatohl 
1a23 22 c6 e5			ld (os_word_scratch),hl  		; save pos for later 
1a26			 
1a26			 
1a26			; display decoding address 
1a26 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a29			 
1a29 7c				ld a,h 
1a2a e1				pop hl 
1a2b e5				push hl 
1a2c			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1a2c cd ef 0f			call hexout 
1a2f 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a32			 
1a32 7d				ld a,l 
1a33 e1				pop hl 
1a34 23				inc hl 
1a35 23				inc hl 
1a36 e5				push hl 
1a37			;	ld hl, os_word_scratch+2 
1a37 cd ef 0f			call hexout 
1a3a e1				pop hl 
1a3b 23				inc hl 
1a3c 23				inc hl 
1a3d				;ld hl, os_word_scratch+4 
1a3d 3e 3a			ld a, ':' 
1a3f 77				ld (hl),a 
1a40 23				inc hl 
1a41				;ld a, 0 
1a41				;ld (hl),a 
1a41				;ld de, os_word_scratch 
1a41				;pop af 
1a41				;push af 
1a41			;		ld a, display_row_2 
1a41			;		call str_at_display 
1a41			;		call update_display 
1a41			 
1a41			 
1a41			;pop af 
1a41			;	add 5 
1a41			 
1a41			if display_cols == 20 
1a41				ld b, 4 
1a41			else 
1a41 06 08			ld b, 8 
1a43			endif	 
1a43			 
1a43			.dumpbyte: 
1a43 c5				push bc 
1a44 e5				push hl 
1a45			 
1a45			 
1a45 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a48 7e					ld a,(hl) 
1a49			 
1a49					; poke the ascii to display 
1a49 2a c6 e5				ld hl,(os_word_scratch) 
1a4c 77					ld (hl),a 
1a4d 23					inc hl 
1a4e 22 c6 e5				ld (os_word_scratch),hl 
1a51			 
1a51					 
1a51			 
1a51			 
1a51 e1					pop hl 
1a52 e5					push hl 
1a53			 
1a53 cd ef 0f				call hexout 
1a56			 
1a56					 
1a56 2a e4 e5		   	ld hl,(os_cur_ptr) 
1a59 23				inc hl 
1a5a 22 e4 e5		   	ld (os_cur_ptr),hl 
1a5d			 
1a5d e1					pop hl 
1a5e 23					inc hl 
1a5f 23					inc hl 
1a60 23					inc hl 
1a61			 
1a61			 
1a61			 
1a61					;ld a,0 
1a61					;ld (os_word_scratch+2),a 
1a61					;pop af 
1a61					;push af 
1a61			 
1a61					;ld de, os_word_scratch 
1a61					;call str_at_display 
1a61			;		call update_display 
1a61			;		pop af 
1a61 c1					pop bc 
1a62 c6 03				add 3 
1a64 10 dd			djnz .dumpbyte 
1a66			 
1a66				 
1a66			 
1a66 c9				ret 
1a67			 
1a67			jump:	 
1a67			 
1a67 21 c3 e2			ld hl,scratch+2 
1a6a cd a5 10			call get_word_hl 
1a6d				;ld hl,(scratch+2) 
1a6d				;call fourehexhl 
1a6d			 
1a6d 22 e4 e5			ld (os_cur_ptr),hl	 
1a70			 
1a70 e9				jp (hl) 
1a71			 
1a71			 
1a71			 
1a71			; TODO implement a basic monitor mode to start with 
1a71			 
1a71			 
1a71			 
1a71			 
1a71			 
1a71			 
1a71			 
1a71			 
1a71			 
1a71			; testing and demo code during development 
1a71			 
1a71			 
1a71 .. 00		str1: db "Enter some text...",0 
1a84 .. 00		clear: db "                    ",0 
1a99			 
1a99			demo: 
1a99			 
1a99			 
1a99			 
1a99			;	call update_display 
1a99			 
1a99				; init scratch input area for testing 
1a99 21 c1 e2			ld hl, scratch	 
1a9c 3e 00			ld a,0 
1a9e 77				ld (hl),a 
1a9f			 
1a9f			 
1a9f 3e 28		            LD   A, display_row_2 
1aa1			;            CALL fLCD_Pos       ;Position cursor to location in A 
1aa1 11 71 1a		            LD   DE, str1 
1aa4 cd cc 0b			call str_at_display 
1aa7			 
1aa7			;            CALL fLCD_Str       ;Display string pointed to by DE 
1aa7			cloop:	 
1aa7 3e 50		            LD   A, display_row_3 
1aa9			;            CALL fLCD_Pos       ;Position cursor to location in A 
1aa9 11 84 1a		            LD   DE, clear 
1aac			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1aac cd cc 0b				call str_at_display 
1aaf 3e 78			ld a, display_row_4 
1ab1 11 e1 1a			ld de, prompt 
1ab4			 
1ab4 cd cc 0b				call str_at_display 
1ab7 cd dc 0b			call update_display 
1aba			 
1aba 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1abc 16 0a			ld d, 10 
1abe 21 c1 e2			ld hl, scratch	 
1ac1 cd 13 0e			call input_str 
1ac4			 
1ac4			;	call clear_display 
1ac4			;'	call update_display 
1ac4			 
1ac4 3e 00		            LD   A, display_row_1 
1ac6			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ac6 11 84 1a		            LD   DE, clear 
1ac9 cd cc 0b				call str_at_display 
1acc			;            CALL fLCD_Str       ;Display string pointed to by DE 
1acc 3e 00		            LD   A, display_row_1 
1ace			;            CALL fLCD_Pos       ;Position cursor to location in A 
1ace 11 c1 e2		            LD   DE, scratch 
1ad1			;            CALL fLCD_Str       ;Display string pointed to by DE 
1ad1 cd cc 0b				call str_at_display 
1ad4 cd dc 0b			call update_display 
1ad7			 
1ad7 3e 00				ld a,0 
1ad9 21 c1 e2			ld hl, scratch 
1adc 77				ld (hl),a 
1add			 
1add 00				nop 
1ade c3 a7 1a			jp cloop 
1ae1			 
1ae1			 
1ae1			 
1ae1			; OS Prompt 
1ae1			 
1ae1 .. 00		prompt: db ">",0 
1ae3 .. 00		endprg: db "?",0 
1ae5			 
1ae5			 
1ae5			; handy next page prompt 
1ae5			next_page_prompt: 
1ae5 e5				push hl 
1ae6 d5				push de 
1ae7 f5				push af 
1ae8 c5				push bc 
1ae9			 
1ae9 3e 9f			ld a,display_row_4 + display_cols - 1 
1aeb 11 e3 1a		        ld de, endprg 
1aee cd cc 0b			call str_at_display 
1af1 cd dc 0b			call update_display 
1af4 cd 53 5e			call cin_wait 
1af7 c1				pop bc 
1af8 f1				pop af 
1af9 d1				pop de 
1afa e1				pop hl 
1afb			 
1afb			 
1afb c9				ret 
1afc			 
1afc			 
1afc			; forth parser 
1afc			 
1afc			; My forth kernel 
1afc			include "forth_kernel.asm" 
1afc			; 
1afc			; kernel to the forth OS 
1afc			 
1afc			DS_TYPE_STR: equ 1     ; string type 
1afc			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1afc			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1afc			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1afc			 
1afc			FORTH_PARSEV1: equ 0 
1afc			FORTH_PARSEV2: equ 0 
1afc			FORTH_PARSEV3: equ 0 
1afc			FORTH_PARSEV4: equ 0 
1afc			FORTH_PARSEV5: equ 1 
1afc			 
1afc			;if FORTH_PARSEV5 
1afc			;	FORTH_END_BUFFER: equ 0 
1afc			;else 
1afc			FORTH_END_BUFFER: equ 127 
1afc			;endif 
1afc			 
1afc			FORTH_TRUE: equ 1 
1afc			FORTH_FALSE: equ 0 
1afc			 
1afc			if FORTH_PARSEV4 
1afc			include "forth_stackops.asm" 
1afc			endif 
1afc			 
1afc			if FORTH_PARSEV5 
1afc			include "forth_stackopsv5.asm" 
1afc			 
1afc			; Stack operations for v5 parser on wards 
1afc			; * DATA stack 
1afc			; * LOOP stack 
1afc			; * RETURN stack 
1afc			 
1afc			 
1afc			 
1afc			FORTH_CHK_DSP_UNDER: macro 
1afc				push hl 
1afc				push de 
1afc				ld hl,(cli_data_sp) 
1afc				ld de, cli_data_stack 
1afc				call cmp16 
1afc				jp c, fault_dsp_under 
1afc				pop de 
1afc				pop hl 
1afc				endm 
1afc			 
1afc			 
1afc			FORTH_CHK_RSP_UNDER: macro 
1afc				push hl 
1afc				push de 
1afc				ld hl,(cli_ret_sp) 
1afc				ld de, cli_ret_stack 
1afc				call cmp16 
1afc				jp c, fault_rsp_under 
1afc				pop de 
1afc				pop hl 
1afc				endm 
1afc			 
1afc			FORTH_CHK_LOOP_UNDER: macro 
1afc				push hl 
1afc				push de 
1afc				ld hl,(cli_loop_sp) 
1afc				ld de, cli_loop_stack 
1afc				call cmp16 
1afc				jp c, fault_loop_under 
1afc				pop de 
1afc				pop hl 
1afc				endm 
1afc			 
1afc			FORTH_ERR_TOS_NOTSTR: macro 
1afc				; TOSO might need more for checks when used 
1afc				push af 
1afc				ld a,(hl) 
1afc				cp DS_TYPE_STR 
1afc				jp nz, type_faultn   
1afc				pop af 
1afc				endm 
1afc			 
1afc			FORTH_ERR_TOS_NOTNUM: macro 
1afc				push af 
1afc				ld a,(hl) 
1afc				cp DS_TYPE_INUM 
1afc				jp nz, type_faultn   
1afc				pop af 
1afc				endm 
1afc			 
1afc			 
1afc			; increase data stack pointer and save hl to it 
1afc				 
1afc			FORTH_DSP_NEXT: macro 
1afc				call macro_forth_dsp_next 
1afc				endm 
1afc			 
1afc			 
1afc			macro_forth_dsp_next: 
1afc				if DEBUG_FORTH_STACK_GUARD 
1afc cd 82 5a				call check_stacks 
1aff				endif 
1aff e5				push hl 
1b00 d5				push de 
1b01 eb				ex de,hl 
1b02 2a ee e9			ld hl,(cli_data_sp) 
1b05 23				inc hl 
1b06 23				inc hl 
1b07			 
1b07			; PARSEV5 
1b07 23				inc hl 
1b08 22 ee e9			ld (cli_data_sp),hl 
1b0b 73				ld (hl), e 
1b0c 23				inc hl 
1b0d 72				ld (hl), d 
1b0e d1				pop de 
1b0f e1				pop hl 
1b10				if DEBUG_FORTH_STACK_GUARD 
1b10 cd 82 5a				call check_stacks 
1b13				endif 
1b13 c9				ret 
1b14			 
1b14			 
1b14			; increase ret stack pointer and save hl to it 
1b14				 
1b14			FORTH_RSP_NEXT: macro 
1b14				call macro_forth_rsp_next 
1b14				endm 
1b14			 
1b14			macro_forth_rsp_next: 
1b14				if DEBUG_FORTH_STACK_GUARD 
1b14 cd 82 5a				call check_stacks 
1b17				endif 
1b17 e5				push hl 
1b18 d5				push de 
1b19 eb				ex de,hl 
1b1a 2a f2 e9			ld hl,(cli_ret_sp) 
1b1d 23				inc hl 
1b1e 23				inc hl 
1b1f 22 f2 e9			ld (cli_ret_sp),hl 
1b22 73				ld (hl), e 
1b23 23				inc hl 
1b24 72				ld (hl), d 
1b25 d1				pop de 
1b26 e1				pop hl 
1b27				if DEBUG_FORTH_STACK_GUARD 
1b27 cd 82 5a				call check_stacks 
1b2a				endif 
1b2a c9				ret 
1b2b			 
1b2b			; get current ret stack pointer and save to hl  
1b2b				 
1b2b			FORTH_RSP_TOS: macro 
1b2b				call macro_forth_rsp_tos 
1b2b				endm 
1b2b			 
1b2b			macro_forth_rsp_tos: 
1b2b				;push de 
1b2b 2a f2 e9			ld hl,(cli_ret_sp) 
1b2e cd 66 1b			call loadhlptrtohl 
1b31				;ld e, (hl) 
1b31				;inc hl 
1b31				;ld d, (hl) 
1b31				;ex de, hl 
1b31					if DEBUG_FORTH_WORDS 
1b31			;			DMARK "RST" 
1b31						CALLMONITOR 
1b31 cd 6f ee			call debug_vector  
1b34				endm  
# End of macro CALLMONITOR
1b34					endif 
1b34				;pop de 
1b34 c9				ret 
1b35			 
1b35			; pop ret stack pointer 
1b35				 
1b35			FORTH_RSP_POP: macro 
1b35				call macro_forth_rsp_pop 
1b35				endm 
1b35			 
1b35			 
1b35			macro_forth_rsp_pop: 
1b35				if DEBUG_FORTH_STACK_GUARD 
1b35			;		DMARK "RPP" 
1b35 cd 82 5a				call check_stacks 
1b38					FORTH_CHK_RSP_UNDER 
1b38 e5				push hl 
1b39 d5				push de 
1b3a 2a f2 e9			ld hl,(cli_ret_sp) 
1b3d 11 ac e9			ld de, cli_ret_stack 
1b40 cd 04 0e			call cmp16 
1b43 da 96 5b			jp c, fault_rsp_under 
1b46 d1				pop de 
1b47 e1				pop hl 
1b48				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b48				endif 
1b48 e5				push hl 
1b49 2a f2 e9			ld hl,(cli_ret_sp) 
1b4c			 
1b4c			 
1b4c				if FORTH_ENABLE_FREE 
1b4c			 
1b4c					; get pointer 
1b4c			 
1b4c					push de 
1b4c					push hl 
1b4c			 
1b4c					ld e, (hl) 
1b4c					inc hl 
1b4c					ld d, (hl) 
1b4c			 
1b4c					ex de, hl 
1b4c					call free 
1b4c			 
1b4c					pop hl 
1b4c					pop de 
1b4c			 
1b4c			 
1b4c				endif 
1b4c			 
1b4c			 
1b4c 2b				dec hl 
1b4d 2b				dec hl 
1b4e 22 f2 e9			ld (cli_ret_sp), hl 
1b51				; do stack underflow checks 
1b51 e1				pop hl 
1b52				if DEBUG_FORTH_STACK_GUARD 
1b52 cd 82 5a				call check_stacks 
1b55					FORTH_CHK_RSP_UNDER 
1b55 e5				push hl 
1b56 d5				push de 
1b57 2a f2 e9			ld hl,(cli_ret_sp) 
1b5a 11 ac e9			ld de, cli_ret_stack 
1b5d cd 04 0e			call cmp16 
1b60 da 96 5b			jp c, fault_rsp_under 
1b63 d1				pop de 
1b64 e1				pop hl 
1b65				endm 
# End of macro FORTH_CHK_RSP_UNDER
1b65				endif 
1b65 c9				ret 
1b66			 
1b66			 
1b66			 
1b66			; routine to load word pointed to by hl into hl 
1b66			 
1b66			loadhlptrtohl: 
1b66			 
1b66 d5				push de 
1b67 5e				ld e, (hl) 
1b68 23				inc hl 
1b69 56				ld d, (hl) 
1b6a eb				ex de, hl 
1b6b d1				pop de 
1b6c			 
1b6c c9				ret 
1b6d			 
1b6d			 
1b6d			 
1b6d			 
1b6d			 
1b6d			; push a number held in HL onto the data stack 
1b6d			; entry point for pushing a value when already in hl used in function above 
1b6d			 
1b6d			forth_push_numhl: 
1b6d			 
1b6d e5				push hl    ; save value to push 
1b6e			 
1b6e			if DEBUG_FORTH_PUSH 
1b6e				; see if disabled 
1b6e			 
1b6e			 
1b6e f5				push af 
1b6f 3a 6f ee			ld a,(debug_vector) 
1b72 fe c9			cp $c9   ; ret 
1b74			;	ld a, (os_view_disable) 
1b74			;	cp '*' 
1b74 28 34			jr z, .pskip2 
1b76 e5				push hl 
1b77 e5			push hl 
1b78 cd b9 0b			call clear_display 
1b7b e1			pop hl 
1b7c 7c				ld a,h 
1b7d 21 c6 e5			ld hl, os_word_scratch 
1b80 cd ef 0f			call hexout 
1b83 e1				pop hl 
1b84 7d				ld a,l 
1b85 21 c8 e5			ld hl, os_word_scratch+2 
1b88 cd ef 0f			call hexout 
1b8b			 
1b8b 21 ca e5			ld hl, os_word_scratch+4 
1b8e 3e 00			ld a,0 
1b90 77				ld (hl),a 
1b91 11 c6 e5			ld de,os_word_scratch 
1b94 3e 28				ld a, display_row_2 
1b96 cd cc 0b				call str_at_display 
1b99 11 90 4c			ld de, .push_num 
1b9c 3e 00			ld a, display_row_1 
1b9e			 
1b9e cd cc 0b				call str_at_display 
1ba1			 
1ba1			 
1ba1 cd dc 0b			call update_display 
1ba4 cd f1 0a			call delay1s 
1ba7 cd f1 0a			call delay1s 
1baa			.pskip2:  
1baa			 
1baa f1				pop af 
1bab			endif	 
1bab			 
1bab			 
1bab				FORTH_DSP_NEXT 
1bab cd fc 1a			call macro_forth_dsp_next 
1bae				endm 
# End of macro FORTH_DSP_NEXT
1bae			 
1bae 2a ee e9			ld hl, (cli_data_sp) 
1bb1			 
1bb1				; save item type 
1bb1 3e 02			ld a,  DS_TYPE_INUM 
1bb3 77				ld (hl), a 
1bb4 23				inc hl 
1bb5			 
1bb5				; get word off stack 
1bb5 d1				pop de 
1bb6 7b				ld a,e 
1bb7 77				ld (hl), a 
1bb8 23				inc hl 
1bb9 7a				ld a,d 
1bba 77				ld (hl), a 
1bbb			 
1bbb			if DEBUG_FORTH_PUSH 
1bbb 2b				dec hl 
1bbc 2b				dec hl 
1bbd 2b				dec hl 
1bbe						DMARK "PH5" 
1bbe f5				push af  
1bbf 3a d3 1b			ld a, (.dmark)  
1bc2 32 6b ee			ld (debug_mark),a  
1bc5 3a d4 1b			ld a, (.dmark+1)  
1bc8 32 6c ee			ld (debug_mark+1),a  
1bcb 3a d5 1b			ld a, (.dmark+2)  
1bce 32 6d ee			ld (debug_mark+2),a  
1bd1 18 03			jr .pastdmark  
1bd3 ..			.dmark: db "PH5"  
1bd6 f1			.pastdmark: pop af  
1bd7			endm  
# End of macro DMARK
1bd7				CALLMONITOR 
1bd7 cd 6f ee			call debug_vector  
1bda				endm  
# End of macro CALLMONITOR
1bda			endif	 
1bda			 
1bda c9				ret 
1bdb			 
1bdb			 
1bdb			; Push a string to stack pointed to by hl 
1bdb			 
1bdb			forth_push_str: 
1bdb			 
1bdb			if DEBUG_FORTH_PUSH 
1bdb						DMARK "PSQ" 
1bdb f5				push af  
1bdc 3a f0 1b			ld a, (.dmark)  
1bdf 32 6b ee			ld (debug_mark),a  
1be2 3a f1 1b			ld a, (.dmark+1)  
1be5 32 6c ee			ld (debug_mark+1),a  
1be8 3a f2 1b			ld a, (.dmark+2)  
1beb 32 6d ee			ld (debug_mark+2),a  
1bee 18 03			jr .pastdmark  
1bf0 ..			.dmark: db "PSQ"  
1bf3 f1			.pastdmark: pop af  
1bf4			endm  
# End of macro DMARK
1bf4				CALLMONITOR 
1bf4 cd 6f ee			call debug_vector  
1bf7				endm  
# End of macro CALLMONITOR
1bf7			endif	 
1bf7			 
1bf7			 
1bf7			    
1bf7 e5				push hl 
1bf8 e5				push hl 
1bf9			 
1bf9			;	ld a, 0   ; find end of string 
1bf9 cd 4c 11			call strlenz 
1bfc			if DEBUG_FORTH_PUSH 
1bfc						DMARK "PQ2" 
1bfc f5				push af  
1bfd 3a 11 1c			ld a, (.dmark)  
1c00 32 6b ee			ld (debug_mark),a  
1c03 3a 12 1c			ld a, (.dmark+1)  
1c06 32 6c ee			ld (debug_mark+1),a  
1c09 3a 13 1c			ld a, (.dmark+2)  
1c0c 32 6d ee			ld (debug_mark+2),a  
1c0f 18 03			jr .pastdmark  
1c11 ..			.dmark: db "PQ2"  
1c14 f1			.pastdmark: pop af  
1c15			endm  
# End of macro DMARK
1c15				CALLMONITOR 
1c15 cd 6f ee			call debug_vector  
1c18				endm  
# End of macro CALLMONITOR
1c18			endif	 
1c18 eb				ex de, hl 
1c19 e1				pop hl   ; get ptr to start of string 
1c1a			if DEBUG_FORTH_PUSH 
1c1a						DMARK "PQ3" 
1c1a f5				push af  
1c1b 3a 2f 1c			ld a, (.dmark)  
1c1e 32 6b ee			ld (debug_mark),a  
1c21 3a 30 1c			ld a, (.dmark+1)  
1c24 32 6c ee			ld (debug_mark+1),a  
1c27 3a 31 1c			ld a, (.dmark+2)  
1c2a 32 6d ee			ld (debug_mark+2),a  
1c2d 18 03			jr .pastdmark  
1c2f ..			.dmark: db "PQ3"  
1c32 f1			.pastdmark: pop af  
1c33			endm  
# End of macro DMARK
1c33				CALLMONITOR 
1c33 cd 6f ee			call debug_vector  
1c36				endm  
# End of macro CALLMONITOR
1c36			endif	 
1c36 19				add hl,de 
1c37			if DEBUG_FORTH_PUSH 
1c37						DMARK "PQE" 
1c37 f5				push af  
1c38 3a 4c 1c			ld a, (.dmark)  
1c3b 32 6b ee			ld (debug_mark),a  
1c3e 3a 4d 1c			ld a, (.dmark+1)  
1c41 32 6c ee			ld (debug_mark+1),a  
1c44 3a 4e 1c			ld a, (.dmark+2)  
1c47 32 6d ee			ld (debug_mark+2),a  
1c4a 18 03			jr .pastdmark  
1c4c ..			.dmark: db "PQE"  
1c4f f1			.pastdmark: pop af  
1c50			endm  
# End of macro DMARK
1c50				CALLMONITOR 
1c50 cd 6f ee			call debug_vector  
1c53				endm  
# End of macro CALLMONITOR
1c53			endif	 
1c53			 
1c53 2b				dec hl    ; see if there is an optional trailing double quote 
1c54 7e				ld a,(hl) 
1c55 fe 22			cp '"' 
1c57 20 03			jr nz, .strnoq 
1c59 3e 00			ld a, 0      ; get rid of double quote 
1c5b 77				ld (hl), a 
1c5c 23			.strnoq: inc hl 
1c5d			 
1c5d 3e 00			ld a, 0 
1c5f 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1c60			 
1c60 13				inc de ; add one for the type string 
1c61 13				inc de ; add one for null term??? 
1c62			 
1c62				; tos is get string pointer again 
1c62				; de contains space to allocate 
1c62				 
1c62 d5				push de 
1c63			 
1c63 eb				ex de, hl 
1c64			 
1c64				;push af 
1c64			 
1c64			if DEBUG_FORTH_PUSH 
1c64						DMARK "PHm" 
1c64 f5				push af  
1c65 3a 79 1c			ld a, (.dmark)  
1c68 32 6b ee			ld (debug_mark),a  
1c6b 3a 7a 1c			ld a, (.dmark+1)  
1c6e 32 6c ee			ld (debug_mark+1),a  
1c71 3a 7b 1c			ld a, (.dmark+2)  
1c74 32 6d ee			ld (debug_mark+2),a  
1c77 18 03			jr .pastdmark  
1c79 ..			.dmark: db "PHm"  
1c7c f1			.pastdmark: pop af  
1c7d			endm  
# End of macro DMARK
1c7d				CALLMONITOR 
1c7d cd 6f ee			call debug_vector  
1c80				endm  
# End of macro CALLMONITOR
1c80			endif	 
1c80 cd c1 11			call malloc	; on ret hl now contains allocated memory 
1c83				if DEBUG_FORTH_MALLOC_GUARD 
1c83 cc e8 4c				call z,malloc_error 
1c86				endif 
1c86			 
1c86				 
1c86 c1				pop bc    ; get length 
1c87 d1				pop de   ;  get string start    
1c88			 
1c88				; hl has destination from malloc 
1c88			 
1c88 eb				ex de, hl    ; prep for ldir 
1c89			 
1c89 d5				push de   ; save malloc area for DSP later 
1c8a				;push hl   ; save malloc area for DSP later 
1c8a			 
1c8a			if DEBUG_FORTH_PUSH 
1c8a						DMARK "PHc" 
1c8a f5				push af  
1c8b 3a 9f 1c			ld a, (.dmark)  
1c8e 32 6b ee			ld (debug_mark),a  
1c91 3a a0 1c			ld a, (.dmark+1)  
1c94 32 6c ee			ld (debug_mark+1),a  
1c97 3a a1 1c			ld a, (.dmark+2)  
1c9a 32 6d ee			ld (debug_mark+2),a  
1c9d 18 03			jr .pastdmark  
1c9f ..			.dmark: db "PHc"  
1ca2 f1			.pastdmark: pop af  
1ca3			endm  
# End of macro DMARK
1ca3				CALLMONITOR 
1ca3 cd 6f ee			call debug_vector  
1ca6				endm  
# End of macro CALLMONITOR
1ca6			endif	 
1ca6			 
1ca6			 
1ca6 ed b0			ldir 
1ca8			 
1ca8			 
1ca8				; push malloc to data stack     macro?????  
1ca8			 
1ca8				FORTH_DSP_NEXT 
1ca8 cd fc 1a			call macro_forth_dsp_next 
1cab				endm 
# End of macro FORTH_DSP_NEXT
1cab			 
1cab				; save value and type 
1cab			 
1cab 2a ee e9			ld hl, (cli_data_sp) 
1cae			 
1cae				; save item type 
1cae 3e 01			ld a,  DS_TYPE_STR 
1cb0 77				ld (hl), a 
1cb1 23				inc hl 
1cb2			 
1cb2				; get malloc word off stack 
1cb2 d1				pop de 
1cb3 73				ld (hl), e 
1cb4 23				inc hl 
1cb5 72				ld (hl), d 
1cb6			 
1cb6			 
1cb6			 
1cb6			if DEBUG_FORTH_PUSH 
1cb6 2a ee e9			ld hl, (cli_data_sp) 
1cb9						DMARK "PHS" 
1cb9 f5				push af  
1cba 3a ce 1c			ld a, (.dmark)  
1cbd 32 6b ee			ld (debug_mark),a  
1cc0 3a cf 1c			ld a, (.dmark+1)  
1cc3 32 6c ee			ld (debug_mark+1),a  
1cc6 3a d0 1c			ld a, (.dmark+2)  
1cc9 32 6d ee			ld (debug_mark+2),a  
1ccc 18 03			jr .pastdmark  
1cce ..			.dmark: db "PHS"  
1cd1 f1			.pastdmark: pop af  
1cd2			endm  
# End of macro DMARK
1cd2				CALLMONITOR 
1cd2 cd 6f ee			call debug_vector  
1cd5				endm  
# End of macro CALLMONITOR
1cd5			;	ex de,hl 
1cd5			endif	 
1cd5				; in case of spaces, skip the ptr past the copied string 
1cd5				;pop af 
1cd5				;ld (cli_origptr),hl 
1cd5			 
1cd5 c9				ret 
1cd6			 
1cd6			 
1cd6			 
1cd6			; TODO ascii push input onto stack given hl to start of input 
1cd6			 
1cd6			; identify type 
1cd6			; if starts with a " then a string 
1cd6			; otherwise it is a number 
1cd6			;  
1cd6			; if a string 
1cd6			;     scan for ending " to get length of string to malloc for + 1 
1cd6			;     malloc 
1cd6			;     put pointer to string on stack first byte flags as string 
1cd6			; 
1cd6			; else a number 
1cd6			;    look for number format identifier 
1cd6			;    $xx hex 
1cd6			;    %xxxxx bin 
1cd6			;    xxxxx decimal 
1cd6			;    convert number to 16bit word.  
1cd6			;    malloc word + 1 with flag to identiy as num 
1cd6			;    put pointer to number on stack 
1cd6			;   
1cd6			;  
1cd6			  
1cd6			forth_apush: 
1cd6				; kernel push 
1cd6			 
1cd6			if DEBUG_FORTH_PUSH 
1cd6						DMARK "PSH" 
1cd6 f5				push af  
1cd7 3a eb 1c			ld a, (.dmark)  
1cda 32 6b ee			ld (debug_mark),a  
1cdd 3a ec 1c			ld a, (.dmark+1)  
1ce0 32 6c ee			ld (debug_mark+1),a  
1ce3 3a ed 1c			ld a, (.dmark+2)  
1ce6 32 6d ee			ld (debug_mark+2),a  
1ce9 18 03			jr .pastdmark  
1ceb ..			.dmark: db "PSH"  
1cee f1			.pastdmark: pop af  
1cef			endm  
# End of macro DMARK
1cef				CALLMONITOR 
1cef cd 6f ee			call debug_vector  
1cf2				endm  
# End of macro CALLMONITOR
1cf2			endif	 
1cf2				; identify input type 
1cf2			 
1cf2 7e				ld a,(hl) 
1cf3			 
1cf3 fe 23			cp '#' 
1cf5 ca 2f 1d			jp z, .fapdec 
1cf8			 
1cf8			 
1cf8 fe 22			cp '"' 
1cfa 28 0a			jr z, .fapstr 
1cfc fe 24			cp '$' 
1cfe ca 26 1d			jp z, .faphex 
1d01 fe 25			cp '%' 
1d03 ca 0e 1d			jp z, .fapbin 
1d06			;	cp 'b' 
1d06			;	jp z, .fabin 
1d06				; else decimal 
1d06			 
1d06				; TODO do decimal conversion 
1d06				; decimal is stored as a 16bit word 
1d06			 
1d06				; by default everything is a string if type is not detected 
1d06			.fapstr: ; 
1d06 fe 22			cp '"' 
1d08 20 01			jr nz, .strnoqu 
1d0a 23				inc hl 
1d0b			.strnoqu: 
1d0b c3 db 1b			jp forth_push_str 
1d0e			 
1d0e			 
1d0e			 
1d0e			.fapbin:    ; push a binary string.  
1d0e 11 00 00			ld de, 0   ; hold a 16bit value 
1d11			 
1d11 23			.fapbinshift:	inc hl  
1d12 7e				ld a,(hl) 
1d13 fe 00			cp 0     ; done scanning  
1d15 28 0b			jr z, .fapbdone  	; got it in HL so push  
1d17			 
1d17				; left shift de 
1d17 eb				ex de, hl	 
1d18 29				add hl, hl 
1d19			 
1d19				; is 1 
1d19 fe 31			cp '1' 
1d1b 20 02			jr nz, .binzero 
1d1d cb 4d			bit 1, l 
1d1f			.binzero: 
1d1f eb				ex de, hl	 ; save current de 
1d20 18 ef			jr .fapbinshift 
1d22			 
1d22			.fapbdone: 
1d22 eb				ex de, hl 
1d23 c3 6d 1b			jp forth_push_numhl 
1d26			 
1d26			 
1d26			.faphex:   ; hex is always stored as a 16bit word 
1d26				; skip number prefix 
1d26 23				inc hl 
1d27				; turn ascii into number 
1d27 cd a5 10			call get_word_hl	; ret 16bit word in hl 
1d2a			 
1d2a c3 6d 1b			jp forth_push_numhl 
1d2d			 
1d2d 00				 nop 
1d2e			 
1d2e			.fabin:   ; TODO bin conversion 
1d2e			 
1d2e			 
1d2e c9				ret 
1d2f			.fapdec:	 
1d2f				; string to dec conversion 
1d2f 23				inc hl 
1d30 eb				ex de, hl 
1d31 cd e3 10			call string_to_uint16 
1d34 c3 6d 1b			jp forth_push_numhl 
1d37 c9				ret 
1d38				 
1d38			;atoui_16: 
1d38			 
1d38			; get either a string ptr or a 16bit word from the data stack 
1d38			 
1d38			FORTH_DSP: macro 
1d38				call macro_forth_dsp 
1d38				endm 
1d38			 
1d38			macro_forth_dsp: 
1d38				; data stack pointer points to current word on tos 
1d38			 
1d38 2a ee e9			ld hl,(cli_data_sp) 
1d3b			 
1d3b				if DEBUG_FORTH_PUSH 
1d3b						DMARK "DSP" 
1d3b f5				push af  
1d3c 3a 50 1d			ld a, (.dmark)  
1d3f 32 6b ee			ld (debug_mark),a  
1d42 3a 51 1d			ld a, (.dmark+1)  
1d45 32 6c ee			ld (debug_mark+1),a  
1d48 3a 52 1d			ld a, (.dmark+2)  
1d4b 32 6d ee			ld (debug_mark+2),a  
1d4e 18 03			jr .pastdmark  
1d50 ..			.dmark: db "DSP"  
1d53 f1			.pastdmark: pop af  
1d54			endm  
# End of macro DMARK
1d54			 
1d54 cd 1b 4d				call display_data_sp 
1d57				;call break_point_state 
1d57				;rst 030h 
1d57				CALLMONITOR 
1d57 cd 6f ee			call debug_vector  
1d5a				endm  
# End of macro CALLMONITOR
1d5a				endif 
1d5a			 
1d5a c9				ret 
1d5b			 
1d5b			; return hl to start of value on stack 
1d5b			 
1d5b			FORTH_DSP_VALUE: macro 
1d5b				call macro_forth_dsp_value 
1d5b				endm 
1d5b			 
1d5b			macro_forth_dsp_value: 
1d5b			 
1d5b				FORTH_DSP 
1d5b cd 38 1d			call macro_forth_dsp 
1d5e				endm 
# End of macro FORTH_DSP
1d5e			 
1d5e d5				push de 
1d5f			 
1d5f 23				inc hl ; skip type 
1d60			 
1d60 5e				ld e, (hl) 
1d61 23				inc hl 
1d62 56				ld d, (hl) 
1d63 eb				ex de,hl  
1d64			 
1d64 d1				pop de 
1d65			 
1d65 c9				ret 
1d66			 
1d66			; return hl to start of value to second item on stack 
1d66			 
1d66			FORTH_DSP_VALUEM1: macro 
1d66				call macro_forth_dsp_value_m1 
1d66				endm 
1d66			 
1d66			macro_forth_dsp_value_m1: 
1d66			 
1d66				FORTH_DSP 
1d66 cd 38 1d			call macro_forth_dsp 
1d69				endm 
# End of macro FORTH_DSP
1d69			 
1d69 2b				dec hl 
1d6a 2b				dec hl 
1d6b			;	dec hl 
1d6b			 
1d6b d5				push de 
1d6c			 
1d6c 5e				ld e, (hl) 
1d6d 23				inc hl 
1d6e 56				ld d, (hl) 
1d6f eb				ex de,hl  
1d70			 
1d70 d1				pop de 
1d71			 
1d71 c9				ret 
1d72			 
1d72				 
1d72			 
1d72			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1d72			 
1d72			FORTH_DSP_POP: macro 
1d72				call macro_forth_dsp_pop 
1d72				endm 
1d72			 
1d72			 
1d72			; get the tos data type 
1d72			 
1d72			FORTH_DSP_TYPE:   macro 
1d72			 
1d72				;FORTH_DSP_VALUE 
1d72				FORTH_DSP 
1d72				 
1d72				; hl points to value 
1d72				; check type 
1d72			 
1d72				ld a,(hl) 
1d72			 
1d72				endm 
1d72			 
1d72			; load the tos value into hl 
1d72			 
1d72			 
1d72			FORTH_DSP_VALUEHL:  macro 
1d72				call macro_dsp_valuehl 
1d72				endm 
1d72			 
1d72			 
1d72			 
1d72			macro_dsp_valuehl: 
1d72				FORTH_DSP_VALUE 
1d72 cd 5b 1d			call macro_forth_dsp_value 
1d75				endm 
# End of macro FORTH_DSP_VALUE
1d75			 
1d75				;FORTH_ERR_TOS_NOTNUM 
1d75			 
1d75				;inc hl   ; skip type id 
1d75			 
1d75			;	push de 
1d75			; 
1d75			;	ld e, (hl) 
1d75			;	inc hl 
1d75			;	ld d, (hl) 
1d75			;	ex de,hl  
1d75			 
1d75			;	pop de 
1d75			 
1d75				if DEBUG_FORTH_PUSH 
1d75						DMARK "DVL" 
1d75 f5				push af  
1d76 3a 8a 1d			ld a, (.dmark)  
1d79 32 6b ee			ld (debug_mark),a  
1d7c 3a 8b 1d			ld a, (.dmark+1)  
1d7f 32 6c ee			ld (debug_mark+1),a  
1d82 3a 8c 1d			ld a, (.dmark+2)  
1d85 32 6d ee			ld (debug_mark+2),a  
1d88 18 03			jr .pastdmark  
1d8a ..			.dmark: db "DVL"  
1d8d f1			.pastdmark: pop af  
1d8e			endm  
# End of macro DMARK
1d8e				CALLMONITOR 
1d8e cd 6f ee			call debug_vector  
1d91				endm  
# End of macro CALLMONITOR
1d91				endif 
1d91 c9				ret 
1d92			 
1d92			forth_apushstrhl:      
1d92				; push of string requires use of cli_origptr 
1d92				; bodge use 
1d92			 
1d92				; get current cli_origptr, save, update with temp pointer  
1d92 ed 5b 3e ea		ld de, (cli_origptr) 
1d96 22 3e ea			ld (cli_origptr), hl 
1d99 d5				push de 
1d9a cd d6 1c			call forth_apush 
1d9d d1				pop de 
1d9e ed 53 3e ea		ld (cli_origptr), de 
1da2 c9			        ret	 
1da3			 
1da3			 
1da3			; increase loop stack pointer and save hl to it 
1da3				 
1da3			FORTH_LOOP_NEXT: macro 
1da3				call macro_forth_loop_next 
1da3				;nop 
1da3				endm 
1da3			 
1da3			macro_forth_loop_next: 
1da3				if DEBUG_FORTH_STACK_GUARD 
1da3 cd 82 5a				call check_stacks 
1da6				endif 
1da6 e5				push hl 
1da7 d5				push de 
1da8 eb				ex de,hl 
1da9 2a f0 e9			ld hl,(cli_loop_sp) 
1dac 23				inc hl 
1dad 23				inc hl 
1dae					if DEBUG_FORTH_WORDS 
1dae						DMARK "LNX" 
1dae f5				push af  
1daf 3a c3 1d			ld a, (.dmark)  
1db2 32 6b ee			ld (debug_mark),a  
1db5 3a c4 1d			ld a, (.dmark+1)  
1db8 32 6c ee			ld (debug_mark+1),a  
1dbb 3a c5 1d			ld a, (.dmark+2)  
1dbe 32 6d ee			ld (debug_mark+2),a  
1dc1 18 03			jr .pastdmark  
1dc3 ..			.dmark: db "LNX"  
1dc6 f1			.pastdmark: pop af  
1dc7			endm  
# End of macro DMARK
1dc7						CALLMONITOR 
1dc7 cd 6f ee			call debug_vector  
1dca				endm  
# End of macro CALLMONITOR
1dca					endif 
1dca 22 f0 e9			ld (cli_loop_sp),hl 
1dcd 73				ld (hl), e 
1dce 23				inc hl 
1dcf 72				ld (hl), d 
1dd0 d1				pop de    ; been reversed so save a swap on restore 
1dd1 e1				pop hl 
1dd2				if DEBUG_FORTH_STACK_GUARD 
1dd2 cd 82 5a				call check_stacks 
1dd5				endif 
1dd5 c9				ret 
1dd6			 
1dd6			; get current ret stack pointer and save to hl  
1dd6				 
1dd6			FORTH_LOOP_TOS: macro 
1dd6				call macro_forth_loop_tos 
1dd6				endm 
1dd6			 
1dd6			macro_forth_loop_tos: 
1dd6 d5				push de 
1dd7 2a f0 e9			ld hl,(cli_loop_sp) 
1dda 5e				ld e, (hl) 
1ddb 23				inc hl 
1ddc 56				ld d, (hl) 
1ddd eb				ex de, hl 
1dde d1				pop de 
1ddf c9				ret 
1de0			 
1de0			; pop loop stack pointer 
1de0				 
1de0			FORTH_LOOP_POP: macro 
1de0				call macro_forth_loop_pop 
1de0				endm 
1de0			 
1de0			 
1de0			macro_forth_loop_pop: 
1de0				if DEBUG_FORTH_STACK_GUARD 
1de0					DMARK "LPP" 
1de0 f5				push af  
1de1 3a f5 1d			ld a, (.dmark)  
1de4 32 6b ee			ld (debug_mark),a  
1de7 3a f6 1d			ld a, (.dmark+1)  
1dea 32 6c ee			ld (debug_mark+1),a  
1ded 3a f7 1d			ld a, (.dmark+2)  
1df0 32 6d ee			ld (debug_mark+2),a  
1df3 18 03			jr .pastdmark  
1df5 ..			.dmark: db "LPP"  
1df8 f1			.pastdmark: pop af  
1df9			endm  
# End of macro DMARK
1df9 cd 82 5a				call check_stacks 
1dfc					FORTH_CHK_LOOP_UNDER 
1dfc e5				push hl 
1dfd d5				push de 
1dfe 2a f0 e9			ld hl,(cli_loop_sp) 
1e01 11 2a e9			ld de, cli_loop_stack 
1e04 cd 04 0e			call cmp16 
1e07 da 9c 5b			jp c, fault_loop_under 
1e0a d1				pop de 
1e0b e1				pop hl 
1e0c				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e0c				endif 
1e0c e5				push hl 
1e0d 2a f0 e9			ld hl,(cli_loop_sp) 
1e10 2b				dec hl 
1e11 2b				dec hl 
1e12 22 f0 e9			ld (cli_loop_sp), hl 
1e15				; TODO do stack underflow checks 
1e15 e1				pop hl 
1e16				if DEBUG_FORTH_STACK_GUARD 
1e16 cd 82 5a				call check_stacks 
1e19					FORTH_CHK_LOOP_UNDER 
1e19 e5				push hl 
1e1a d5				push de 
1e1b 2a f0 e9			ld hl,(cli_loop_sp) 
1e1e 11 2a e9			ld de, cli_loop_stack 
1e21 cd 04 0e			call cmp16 
1e24 da 9c 5b			jp c, fault_loop_under 
1e27 d1				pop de 
1e28 e1				pop hl 
1e29				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1e29				endif 
1e29 c9				ret 
1e2a			 
1e2a			macro_forth_dsp_pop: 
1e2a			 
1e2a e5				push hl 
1e2b			 
1e2b				; release malloc data 
1e2b			 
1e2b				if DEBUG_FORTH_STACK_GUARD 
1e2b cd 82 5a				call check_stacks 
1e2e					FORTH_CHK_DSP_UNDER 
1e2e e5				push hl 
1e2f d5				push de 
1e30 2a ee e9			ld hl,(cli_data_sp) 
1e33 11 28 e8			ld de, cli_data_stack 
1e36 cd 04 0e			call cmp16 
1e39 da 90 5b			jp c, fault_dsp_under 
1e3c d1				pop de 
1e3d e1				pop hl 
1e3e				endm 
# End of macro FORTH_CHK_DSP_UNDER
1e3e				endif 
1e3e				;ld hl,(cli_data_sp) 
1e3e			if DEBUG_FORTH_DOT 
1e3e				DMARK "DPP" 
1e3e f5				push af  
1e3f 3a 53 1e			ld a, (.dmark)  
1e42 32 6b ee			ld (debug_mark),a  
1e45 3a 54 1e			ld a, (.dmark+1)  
1e48 32 6c ee			ld (debug_mark+1),a  
1e4b 3a 55 1e			ld a, (.dmark+2)  
1e4e 32 6d ee			ld (debug_mark+2),a  
1e51 18 03			jr .pastdmark  
1e53 ..			.dmark: db "DPP"  
1e56 f1			.pastdmark: pop af  
1e57			endm  
# End of macro DMARK
1e57				CALLMONITOR 
1e57 cd 6f ee			call debug_vector  
1e5a				endm  
# End of macro CALLMONITOR
1e5a			endif	 
1e5a			 
1e5a			 
1e5a			if FORTH_ENABLE_DSPPOPFREE 
1e5a			 
1e5a				FORTH_DSP 
1e5a cd 38 1d			call macro_forth_dsp 
1e5d				endm 
# End of macro FORTH_DSP
1e5d			 
1e5d 7e				ld a, (hl) 
1e5e fe 01			cp DS_TYPE_STR 
1e60 20 23			jr nz, .skippopfree 
1e62			 
1e62				FORTH_DSP_VALUEHL 
1e62 cd 72 1d			call macro_dsp_valuehl 
1e65				endm 
# End of macro FORTH_DSP_VALUEHL
1e65 00				nop 
1e66			if DEBUG_FORTH_DOT 
1e66				DMARK "DPf" 
1e66 f5				push af  
1e67 3a 7b 1e			ld a, (.dmark)  
1e6a 32 6b ee			ld (debug_mark),a  
1e6d 3a 7c 1e			ld a, (.dmark+1)  
1e70 32 6c ee			ld (debug_mark+1),a  
1e73 3a 7d 1e			ld a, (.dmark+2)  
1e76 32 6d ee			ld (debug_mark+2),a  
1e79 18 03			jr .pastdmark  
1e7b ..			.dmark: db "DPf"  
1e7e f1			.pastdmark: pop af  
1e7f			endm  
# End of macro DMARK
1e7f				CALLMONITOR 
1e7f cd 6f ee			call debug_vector  
1e82				endm  
# End of macro CALLMONITOR
1e82			endif	 
1e82 cd 8b 12			call free 
1e85			.skippopfree: 
1e85				 
1e85			 
1e85			endif 
1e85			 
1e85			if DEBUG_FORTH_DOT_KEY 
1e85				DMARK "DP2" 
1e85				CALLMONITOR 
1e85			endif	 
1e85			 
1e85				; move pointer down 
1e85			 
1e85 2a ee e9			ld hl,(cli_data_sp) 
1e88 2b				dec hl 
1e89 2b				dec hl 
1e8a			; PARSEV5 
1e8a 2b				dec hl 
1e8b 22 ee e9			ld (cli_data_sp), hl 
1e8e			 
1e8e				if DEBUG_FORTH_STACK_GUARD 
1e8e cd 82 5a				call check_stacks 
1e91					FORTH_CHK_DSP_UNDER 
1e91 e5				push hl 
1e92 d5				push de 
1e93 2a ee e9			ld hl,(cli_data_sp) 
1e96 11 28 e8			ld de, cli_data_stack 
1e99 cd 04 0e			call cmp16 
1e9c da 90 5b			jp c, fault_dsp_under 
1e9f d1				pop de 
1ea0 e1				pop hl 
1ea1				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ea1				endif 
1ea1			 
1ea1 e1				pop hl 
1ea2			 
1ea2 c9				ret 
1ea3			 
1ea3			getwordathl: 
1ea3				; hl points to an address 
1ea3				; load hl with the word at that address 
1ea3			 
1ea3 d5				push de 
1ea4			 
1ea4 5e				ld e, (hl) 
1ea5 23				inc hl 
1ea6 56				ld d, (hl) 
1ea7 eb				ex de, hl 
1ea8			 
1ea8 d1				pop de 
1ea9 c9				ret 
1eaa			 
1eaa			 
1eaa			 
1eaa			 
1eaa			 
1eaa			; eof 
1eaa			 
# End of file forth_stackopsv5.asm
1eaa			endif 
1eaa			 
1eaa			loadwordinhl:	 
1eaa			 
1eaa d5				push de 
1eab			 
1eab 5e				ld e, (hl) 
1eac 23				inc hl 
1ead 56				ld d, (hl) 
1eae eb				ex de,hl  
1eaf			 
1eaf d1				pop de 
1eb0			 
1eb0 c9				ret 
1eb1			 
1eb1			user_word_eol:  
1eb1				; hl contains the pointer to where to create a linked list item from the end 
1eb1				; of the user dict to continue on at the system word dict 
1eb1				 
1eb1				; poke the stub of the word list linked list to repoint to rom words 
1eb1			 
1eb1				; stub format 
1eb1				; db   word id 
1eb1				; dw    link to next word 
1eb1			        ; db char length of token 
1eb1				; db string + 0 term 
1eb1				; db exec code....  
1eb1			 
1eb1 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1eb3 77				ld (hl), a		; word id 
1eb4 23				inc hl 
1eb5			 
1eb5 11 80 20			ld de, sysdict 
1eb8 73				ld (hl), e		; next word link ie system dict 
1eb9 23				inc hl 
1eba 72				ld (hl), d		; next word link ie system dict 
1ebb 23				inc hl	 
1ebc			 
1ebc			;	ld (hl), sysdict		; next word link ie system dict 
1ebc			;	inc hl 
1ebc			;	inc hl 
1ebc			 
1ebc			;	inc hl 
1ebc			;	inc hl 
1ebc			 
1ebc 3e 02			ld a, 2			; word length is 0 
1ebe 77				ld (hl), a	 
1ebf 23				inc hl 
1ec0			 
1ec0 3e 7e			ld a, '~'			; word length is 0 
1ec2 77				ld (hl), a	 
1ec3 23				inc hl 
1ec4 3e 00			ld a, 0			; save empty word 
1ec6 77				ld (hl), a 
1ec7			 
1ec7 c9				ret 
1ec8			 
1ec8				 
1ec8			 
1ec8			forthexec_cleanup: 
1ec8				FORTH_RSP_POP 
1ec8 cd 35 1b			call macro_forth_rsp_pop 
1ecb				endm 
# End of macro FORTH_RSP_POP
1ecb c9				ret 
1ecc			 
1ecc			forth_call_hl: 
1ecc				; taking hl 
1ecc e5				push hl 
1ecd c9				ret 
1ece			 
1ece			; this is called to reset Forth system but keep existing uwords etc 
1ece			 
1ece			forth_warmstart: 
1ece				; setup stack over/under flow checks 
1ece				if DEBUG_FORTH_STACK_GUARD 
1ece cd 68 5a				call chk_stk_init 
1ed1				endif 
1ed1			 
1ed1				; init stack pointers  - * these stacks go upwards *  
1ed1 21 ac e9			ld hl, cli_ret_stack 
1ed4 22 f2 e9			ld (cli_ret_sp), hl	 
1ed7				; set bottom of stack 
1ed7 3e 00			ld a,0 
1ed9 77				ld (hl),a 
1eda 23				inc hl 
1edb 77				ld (hl),a 
1edc			 
1edc 21 28 e8			ld hl, cli_data_stack 
1edf 22 ee e9			ld (cli_data_sp), hl	 
1ee2				; set bottom of stack 
1ee2 3e 00			ld a,0 
1ee4 77				ld (hl),a 
1ee5 23				inc hl 
1ee6 77				ld (hl),a 
1ee7			 
1ee7 21 2a e9			ld hl, cli_loop_stack 
1eea 22 f0 e9			ld (cli_loop_sp), hl	 
1eed				; set bottom of stack 
1eed 3e 00			ld a,0 
1eef 77				ld (hl),a 
1ef0 23				inc hl 
1ef1 77				ld (hl),a 
1ef2			 
1ef2				; init extent of current open file 
1ef2			 
1ef2 3e 00			ld a, 0 
1ef4 32 6a ea			ld (store_openext), a 
1ef7			 
1ef7 c9				ret 
1ef8			 
1ef8			 
1ef8			 
1ef8			; Cold Start - this is called to setup the whole Forth system 
1ef8			 
1ef8			forth_init: 
1ef8			 
1ef8				; setup stack over/under flow checks 
1ef8			 
1ef8			;	if DEBUG_FORTH_STACK_GUARD 
1ef8			;		call chk_stk_init 
1ef8			;	endif 
1ef8			 
1ef8				; enable auto display updates (slow.....) 
1ef8			 
1ef8 3e 01			ld a, 1 
1efa 32 3c ea			ld (cli_autodisplay), a 
1efd			 
1efd				; if storage is in use disable long reads for now 
1efd 3e 00			ld a, 0 
1eff 32 75 ea			ld (store_longread), a 
1f02			 
1f02			 
1f02				; show start up screen 
1f02			 
1f02 cd b9 0b			call clear_display 
1f05			 
1f05 3e 00			ld a,0 
1f07 32 5e ea			ld (f_cursor_ptr), a 
1f0a			 
1f0a				; set start of word list in start of ram - for use when creating user words 
1f0a			 
1f0a 21 74 5e			ld hl, baseram 
1f0d 22 be e5			ld (os_last_new_uword), hl 
1f10 cd b1 1e			call user_word_eol 
1f13				 
1f13			;		call display_data_sp 
1f13			;		call next_page_prompt 
1f13			 
1f13			 
1f13			 
1f13			 
1f13 c9				ret 
1f14			 
1f14 .. 00		.bootforth: db " Forth Kernel Init ",0 
1f28			 
1f28			; TODO push to stack 
1f28			 
1f28			;  
1f28			 
1f28			if FORTH_PARSEV2 
1f28			 
1f28			 
1f28				include "forth_parserv2.asm" 
1f28			 
1f28			endif 
1f28			 
1f28			 
1f28			; parse cli version 1 
1f28			 
1f28			if FORTH_PARSEV1 
1f28			 
1f28			 
1f28			 
1f28			      include "forth_parserv1.asm" 
1f28			endif 
1f28				 
1f28			if FORTH_PARSEV3 
1f28			 
1f28			 
1f28			 
1f28			      include "forth_parserv3.asm" 
1f28				include "forth_wordsv3.asm" 
1f28			endif 
1f28			 
1f28			if FORTH_PARSEV4 
1f28			 
1f28			 
1f28			 
1f28			      include "forth_parserv4.asm" 
1f28				include "forth_wordsv4.asm" 
1f28			endif 
1f28			 
1f28			if FORTH_PARSEV5 
1f28			 
1f28			 
1f28			 
1f28			      include "forth_parserv5.asm" 
1f28			 
1f28			 
1f28			; A better parser without using malloc and string copies all over the place.  
1f28			; Exec in situ should be faster 
1f28			 
1f28			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1f28			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1f28			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1f28			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1f28			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1f28			WORD_SYS_END: equ 0   ; Opcode for all user words 
1f28			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1f28			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1f28			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1f28			 
1f28			; Core word preamble macro 
1f28			 
1f28			CWHEAD:   macro nxtword opcode lit len opflags 
1f28				db WORD_SYS_CORE+opcode             
1f28				; internal op code number 
1f28				dw nxtword            
1f28				; link to next dict word block 
1f28				db len + 1 
1f28				; literal length of dict word inc zero term 
1f28				db lit,0              
1f28				; literal dict word 
1f28			        ; TODO db opflags        
1f28				endm 
1f28			 
1f28			 
1f28			NEXTW: macro  
1f28				jp macro_next 
1f28				endm 
1f28			 
1f28			macro_next: 
1f28			if DEBUG_FORTH_PARSE_KEY 
1f28				DMARK "NXT" 
1f28				CALLMONITOR 
1f28			endif	 
1f28			;	inc hl  ; skip token null term  
1f28 ed 4b 40 ea		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1f2c ed 5b 3e ea		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1f30 2a c2 e5			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1f33			if DEBUG_FORTH_PARSE_KEY 
1f33				DMARK "}AA" 
1f33				CALLMONITOR 
1f33			endif	 
1f33 c3 36 20			jp execnext 
1f36				;jp exec1 
1f36			       
1f36			 
1f36			 
1f36			; Another go at the parser to compile  
1f36			 
1f36			 
1f36			; TODO rework parser to change all of the string words to byte tokens 
1f36			; TODO do a search for  
1f36			 
1f36			; TODO first run normal parser to zero term sections 
1f36			; TODO for each word do a token look up to get the op code 
1f36			; TODO need some means to flag to the exec that this is a byte code form    
1f36			 
1f36			 
1f36			forthcompile: 
1f36			 
1f36			; 
1f36			; line parse: 
1f36			;       parse raw input buffer 
1f36			;       tokenise the words 
1f36			;       malloc new copy (for looping etc) 
1f36			;       copy to malloc + current pc in line to start of string and add line term 
1f36			;       save on new rsp 
1f36			; 
1f36			 
1f36			; hl to point to the line to tokenise 
1f36			 
1f36			;	push hl 
1f36 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
1f39			 
1f39			;	ld a,0		; string term on input 
1f39			;	call strlent 
1f39			 
1f39			;	ld (os_tok_len), hl	 ; save string length 
1f39			 
1f39			;if DEBUG_FORTH_TOK 
1f39			;	ex de,hl		 
1f39			;endif 
1f39			 
1f39			;	pop hl 		; get back string pointer 
1f39			 
1f39			if DEBUG_FORTH_TOK 
1f39						DMARK "TOc" 
1f39				CALLMONITOR 
1f39			endif 
1f39 7e			.cptoken2:    ld a,(hl) 
1f3a 23				inc hl 
1f3b fe 7f			cp FORTH_END_BUFFER 
1f3d 28 29			jr z, .cptokendone2 
1f3f fe 00			cp 0 
1f41 28 25			jr z, .cptokendone2 
1f43 fe 22			cp '"' 
1f45 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1f47 fe 20			cp ' ' 
1f49 20 ee			jr nz,  .cptoken2 
1f4b			 
1f4b			; TODO consume comments held between ( and ) 
1f4b			 
1f4b				; we have a space so change to zero term for dict match later 
1f4b 2b				dec hl 
1f4c 3e 00			ld a,0 
1f4e 77				ld (hl), a 
1f4f 23				inc hl 
1f50 18 e7			jr .cptoken2 
1f52				 
1f52			 
1f52			.cptokenstr2: 
1f52				; skip all white space until either eol (because forgot to term) or end double quote 
1f52			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f52				;inc hl ; skip current double quote 
1f52 7e				ld a,(hl) 
1f53 23				inc hl 
1f54 fe 22			cp '"' 
1f56 28 e1			jr z, .cptoken2 
1f58 fe 7f			cp FORTH_END_BUFFER 
1f5a 28 0c			jr z, .cptokendone2 
1f5c fe 00			cp 0 
1f5e 28 08			jr z, .cptokendone2 
1f60 fe 20			cp ' ' 
1f62 28 02			jr z, .cptmp2 
1f64 18 ec			jr .cptokenstr2 
1f66			 
1f66			.cptmp2:	; we have a space so change to zero term for dict match later 
1f66				;dec hl 
1f66				;ld a,"-"	; TODO remove this when working 
1f66				;ld (hl), a 
1f66				;inc hl 
1f66 18 ea			jr .cptokenstr2 
1f68			 
1f68			.cptokendone2: 
1f68				;inc hl 
1f68 3e 7f			ld a, FORTH_END_BUFFER 
1f6a 77				ld (hl),a 
1f6b 23				inc hl 
1f6c 3e 21			ld a, '!' 
1f6e 77				ld (hl),a 
1f6f			 
1f6f 2a c2 e5			ld hl,(os_tok_ptr) 
1f72			         
1f72			if DEBUG_FORTH_TOK 
1f72						DMARK "Tc1" 
1f72				CALLMONITOR 
1f72			endif 
1f72			 
1f72				; push exec string to top of return stack 
1f72				FORTH_RSP_NEXT 
1f72 cd 14 1b			call macro_forth_rsp_next 
1f75				endm 
# End of macro FORTH_RSP_NEXT
1f75 c9				ret 
1f76			 
1f76			; Another go at the parser need to simplify the process 
1f76			 
1f76			forthparse: 
1f76			 
1f76			; 
1f76			; line parse: 
1f76			;       parse raw input buffer 
1f76			;       tokenise the words 
1f76			;       malloc new copy (for looping etc) 
1f76			;       copy to malloc + current pc in line to start of string and add line term 
1f76			;       save on new rsp 
1f76			; 
1f76			 
1f76			; hl to point to the line to tokenise 
1f76			 
1f76			;	push hl 
1f76 22 c2 e5			ld (os_tok_ptr), hl  ; save ptr to string 
1f79			 
1f79			;	ld a,0		; string term on input 
1f79			;	call strlent 
1f79			 
1f79			;	ld (os_tok_len), hl	 ; save string length 
1f79			 
1f79			;if DEBUG_FORTH_TOK 
1f79			;	ex de,hl		 
1f79			;endif 
1f79			 
1f79			;	pop hl 		; get back string pointer 
1f79			 
1f79			if DEBUG_FORTH_TOK 
1f79						DMARK "TOK" 
1f79				CALLMONITOR 
1f79			endif 
1f79 7e			.ptoken2:    ld a,(hl) 
1f7a 23				inc hl 
1f7b fe 7f			cp FORTH_END_BUFFER 
1f7d 28 29			jr z, .ptokendone2 
1f7f fe 00			cp 0 
1f81 28 25			jr z, .ptokendone2 
1f83 fe 22			cp '"' 
1f85 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1f87 fe 20			cp ' ' 
1f89 20 ee			jr nz,  .ptoken2 
1f8b			 
1f8b			; TODO consume comments held between ( and ) 
1f8b			 
1f8b				; we have a space so change to zero term for dict match later 
1f8b 2b				dec hl 
1f8c 3e 00			ld a,0 
1f8e 77				ld (hl), a 
1f8f 23				inc hl 
1f90 18 e7			jr .ptoken2 
1f92				 
1f92			 
1f92			.ptokenstr2: 
1f92				; skip all white space until either eol (because forgot to term) or end double quote 
1f92			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1f92				;inc hl ; skip current double quote 
1f92 7e				ld a,(hl) 
1f93 23				inc hl 
1f94 fe 22			cp '"' 
1f96 28 e1			jr z, .ptoken2 
1f98 fe 7f			cp FORTH_END_BUFFER 
1f9a 28 0c			jr z, .ptokendone2 
1f9c fe 00			cp 0 
1f9e 28 08			jr z, .ptokendone2 
1fa0 fe 20			cp ' ' 
1fa2 28 02			jr z, .ptmp2 
1fa4 18 ec			jr .ptokenstr2 
1fa6			 
1fa6			.ptmp2:	; we have a space so change to zero term for dict match later 
1fa6				;dec hl 
1fa6				;ld a,"-"	; TODO remove this when working 
1fa6				;ld (hl), a 
1fa6				;inc hl 
1fa6 18 ea			jr .ptokenstr2 
1fa8			 
1fa8			.ptokendone2: 
1fa8				;inc hl 
1fa8 3e 7f			ld a, FORTH_END_BUFFER 
1faa 77				ld (hl),a 
1fab 23				inc hl 
1fac 3e 21			ld a, '!' 
1fae 77				ld (hl),a 
1faf			 
1faf 2a c2 e5			ld hl,(os_tok_ptr) 
1fb2			         
1fb2			if DEBUG_FORTH_TOK 
1fb2						DMARK "TK1" 
1fb2				CALLMONITOR 
1fb2			endif 
1fb2			 
1fb2				; push exec string to top of return stack 
1fb2				FORTH_RSP_NEXT 
1fb2 cd 14 1b			call macro_forth_rsp_next 
1fb5				endm 
# End of macro FORTH_RSP_NEXT
1fb5 c9				ret 
1fb6			 
1fb6			; 
1fb6			;	; malloc size + buffer pointer + if is loop flag 
1fb6			;	ld hl,(os_tok_len) 		 ; get string length 
1fb6			; 
1fb6			;	ld a,l 
1fb6			; 
1fb6			;	cp 0			; we dont want to use a null string 
1fb6			;	ret z 
1fb6			; 
1fb6			;;	add 3    ; prefix malloc with buffer for current word ptr 
1fb6			; 
1fb6			;	add 5     ; TODO when certain not over writing memory remove 
1fb6			; 
1fb6			;		 
1fb6			; 
1fb6			;if DEBUG_FORTH_TOK 
1fb6			;			DMARK "TKE" 
1fb6			;	CALLMONITOR 
1fb6			;endif 
1fb6			; 
1fb6			;	ld l,a 
1fb6			;	ld h,0 
1fb6			;;	push hl   ; save required space for the copy later 
1fb6			;	call malloc 
1fb6			;if DEBUG_FORTH_TOK 
1fb6			;			DMARK "TKM" 
1fb6			;	CALLMONITOR 
1fb6			;endif 
1fb6			;	if DEBUG_FORTH_MALLOC_GUARD 
1fb6			;		push af 
1fb6			;		call ishlzero 
1fb6			;;		ld a, l 
1fb6			;;		add h 
1fb6			;;		cp 0 
1fb6			;		pop af 
1fb6			;		 
1fb6			;		call z,malloc_error 
1fb6			;	endif 
1fb6			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1fb6			; 
1fb6			; 
1fb6			;if DEBUG_FORTH_TOK 
1fb6			;			DMARK "TKR" 
1fb6			;	CALLMONITOR 
1fb6			;endif 
1fb6			; 
1fb6			;	FORTH_RSP_NEXT 
1fb6			; 
1fb6			;	;inc hl	 ; go past current buffer pointer 
1fb6			;	;inc hl 
1fb6			;	;inc hl   ; and past if loop flag 
1fb6			;		; TODO Need to set flag  
1fb6			; 
1fb6			;	 
1fb6			;	 
1fb6			;	ex de,hl	; malloc is dest 
1fb6			;	ld hl, (os_tok_len) 
1fb6			;;	pop bc 
1fb6			;	ld c, l                
1fb6			;	ld b,0 
1fb6			;	ld hl, (os_tok_ptr) 
1fb6			; 
1fb6			;if DEBUG_FORTH_TOK 
1fb6			;			DMARK "TKT" 
1fb6			;	CALLMONITOR 
1fb6			;endif 
1fb6			; 
1fb6			;	; do str cpy 
1fb6			; 
1fb6			;	ldir      ; copy byte in hl to de 
1fb6			; 
1fb6			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1fb6			; 
1fb6			;if DEBUG_FORTH_TOK 
1fb6			; 
1fb6			;			DMARK "TKY" 
1fb6			;	CALLMONITOR 
1fb6			;endif 
1fb6			;	;ld a,0 
1fb6			;	;ld a,FORTH_END_BUFFER 
1fb6			;	ex de, hl 
1fb6			;	;dec hl			 ; go back over the space delim at the end of word 
1fb6			;	;ld (hl),a 
1fb6			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1fb6			;	ld a,FORTH_END_BUFFER 
1fb6			;	ld (hl),a 
1fb6			;	inc hl 
1fb6			;	ld a,FORTH_END_BUFFER 
1fb6			;	ld (hl),a 
1fb6			; 
1fb6			;	; init the malloc area data 
1fb6			;	; set pc for in current area 
1fb6			;	;ld hl, (os_tok_malloc) 
1fb6			;	;inc hl 
1fb6			;	;inc hl 
1fb6			;	;inc hl 
1fb6			;	;ex de,hl 
1fb6			;	;ld hl, (os_tok_malloc) 
1fb6			;	;ld (hl),e 
1fb6			;	;inc hl 
1fb6			;	;ld (hl),d 
1fb6			; 
1fb6			; 
1fb6			;	ld hl,(os_tok_malloc) 
1fb6			;if DEBUG_FORTH_PARSE_KEY 
1fb6			;			DMARK "TKU" 
1fb6			;	CALLMONITOR 
1fb6			;endif 
1fb6			; 
1fb6			;	ret 
1fb6			 
1fb6			forthexec: 
1fb6			 
1fb6			; line exec: 
1fb6			; forth parser 
1fb6			 
1fb6			; 
1fb6			;       get current exec line on rsp 
1fb6			 
1fb6				FORTH_RSP_TOS 
1fb6 cd 2b 1b			call macro_forth_rsp_tos 
1fb9				endm 
# End of macro FORTH_RSP_TOS
1fb9			 
1fb9			;       restore current pc - hl points to malloc of data 
1fb9			 
1fb9				;ld e, (hl) 
1fb9				;inc hl 
1fb9				;ld d, (hl) 
1fb9				;ex de,hl 
1fb9			 
1fb9			 
1fb9			exec1: 
1fb9 22 c2 e5			ld (os_tok_ptr), hl 
1fbc			 
1fbc				; copy our PC to working vars  
1fbc 22 40 ea			ld (cli_ptr), hl 
1fbf 22 3e ea			ld (cli_origptr), hl 
1fc2			 
1fc2 7e				ld a,(hl) 
1fc3 fe 7f			cp FORTH_END_BUFFER 
1fc5 c8				ret z 
1fc6			 
1fc6				; skip any nulls 
1fc6			 
1fc6 fe 00			cp 0 
1fc8 20 03			jr nz, .execword 
1fca 23				inc hl 
1fcb 18 ec			jr exec1 
1fcd			 
1fcd			 
1fcd			.execword: 
1fcd			 
1fcd			 
1fcd			 
1fcd			if DEBUG_FORTH_PARSE_KEY 
1fcd						DMARK "KYQ" 
1fcd				CALLMONITOR 
1fcd			endif 
1fcd			;       while at start of word: 
1fcd			; get start of dict (in user area first) 
1fcd			 
1fcd 21 74 5e		ld hl, baseram 
1fd0			;ld hl, sysdict 
1fd0 22 42 ea		ld (cli_nextword),hl 
1fd3			;           match word at pc 
1fd3			;           exec word 
1fd3			;           or push to dsp 
1fd3			;           forward to next token 
1fd3			;           if line term pop rsp and exit 
1fd3			;        
1fd3			 
1fd3			if DEBUG_FORTH_PARSE_KEY 
1fd3						DMARK "KYq" 
1fd3				CALLMONITOR 
1fd3			endif 
1fd3			 
1fd3			; 
1fd3			; word comp 
1fd3			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1fd3			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1fd3			;    move to start of word  
1fd3			;    compare word to cli_token 
1fd3			 
1fd3			.execpnword:	; HL at start of a word in the dictionary to check 
1fd3			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1fd3			;	ld (cli_ptr), hl 
1fd3			 
1fd3 2a 42 ea			ld hl,(cli_nextword) 
1fd6			 
1fd6 cd 79 20			call forth_tok_next 
1fd9			; tok next start here 
1fd9			;	; TODO skip compiled symbol for now 
1fd9			;	inc hl 
1fd9			; 
1fd9			;	; save pointer to next word 
1fd9			; 
1fd9			;	; hl now points to the address of the next word pointer  
1fd9			;	ld e, (hl) 
1fd9			;	inc hl 
1fd9			;	ld d, (hl) 
1fd9			;	inc l 
1fd9			; 
1fd9			;	ex de,hl 
1fd9			;if DEBUG_FORTH_PARSE_NEXTWORD 
1fd9			;	push bc 
1fd9			;	ld bc, (cli_nextword) 
1fd9			;			DMARK "NXW" 
1fd9			;	CALLMONITOR 
1fd9			;	pop bc 
1fd9			;endif 
1fd9			; tok next end here 
1fd9 22 42 ea			ld (cli_nextword), hl     ; save for next check if no match on this word 
1fdc eb				ex de, hl 
1fdd			 
1fdd			 
1fdd				; save the pointer of the current token - 1 to check against 
1fdd				 
1fdd 22 46 ea			ld (cli_token), hl   
1fe0				; TODO maybe remove below save if no debug 
1fe0				; save token string ptr for any debug later 
1fe0 23				inc hl  
1fe1 22 48 ea			ld (cli_origtoken), hl 
1fe4 2b				dec hl 
1fe5				; save pointer to the start of the next dictionay word 
1fe5 7e				ld a,(hl)   ; get string length 
1fe6 47				ld b,a 
1fe7			.execpnwordinc:  
1fe7 23				inc hl 
1fe8 10 fd			djnz .execpnwordinc 
1fea 22 44 ea			ld (cli_execword), hl      ; save start of this words code 
1fed			 
1fed				; now check the word token against the string being parsed 
1fed			 
1fed 2a 46 ea			ld hl,(cli_token) 
1ff0 23				inc hl     ; skip string length (use zero term instead to end) 
1ff1 22 46 ea			ld (cli_token), hl 
1ff4			 
1ff4			if DEBUG_FORTH_PARSE_KEY 
1ff4						DMARK "KY2" 
1ff4			endif 
1ff4			if DEBUG_FORTH_PARSE_EXEC 
1ff4				; see if disabled 
1ff4			 
1ff4			;	ld a, (os_view_disable) 
1ff4			;	cp '*' 
1ff4				ld a, (debug_vector) 
1ff4				cp $c9   ; RET  
1ff4				jr z, .skip 
1ff4			 
1ff4				push hl 
1ff4				push hl 
1ff4				call clear_display 
1ff4				ld de, .compword 
1ff4				ld a, display_row_1 
1ff4				call str_at_display 
1ff4				pop de 
1ff4				ld a, display_row_2 
1ff4				call str_at_display 
1ff4				ld hl,(cli_ptr) 
1ff4				ld a,(hl) 
1ff4			        ld hl, os_word_scratch 
1ff4				ld (hl),a 
1ff4				ld a,0 
1ff4				inc hl 
1ff4				ld (hl),a 	 
1ff4				ld de, os_word_scratch 
1ff4				ld a, display_row_2+10 
1ff4				call str_at_display 
1ff4				call update_display 
1ff4				ld a, 100 
1ff4				call aDelayInMS 
1ff4				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1ff4				call delay250ms 
1ff4				endif 
1ff4				pop hl 
1ff4			.skip:  
1ff4			endif	 
1ff4			.execpnchar:    ; compare char between token and string to parse 
1ff4			 
1ff4			if DEBUG_FORTH_PARSE_KEY 
1ff4						DMARK "Ky3" 
1ff4			endif 
1ff4			if DEBUG_FORTH_PARSE_EXEC 
1ff4				; see if disabled 
1ff4			 
1ff4			;	ld a, (os_view_disable) 
1ff4			;	cp '*' 
1ff4				ld a, (debug_vector) 
1ff4				cp $C9  ; RET 
1ff4				jr z, .skip2 
1ff4			 
1ff4			;	call clear_display 
1ff4			ld hl,(cli_token) 
1ff4			ld a,(hl) 
1ff4			ld (os_word_scratch),a 
1ff4				ld hl,(cli_ptr) 
1ff4			ld a,(hl) 
1ff4				ld (os_word_scratch+1),a 
1ff4				ld a,0 
1ff4				ld (os_word_scratch+2),a 
1ff4				ld de,os_word_scratch 
1ff4				ld a,display_row_4 
1ff4				call str_at_display 
1ff4				call update_display 
1ff4			.skip2:  
1ff4			endif 
1ff4 2a 46 ea			ld hl,(cli_token) 
1ff7 7e				ld a, (hl)	 ; char in word token 
1ff8 23				inc hl 		; move to next char 
1ff9 22 46 ea			ld (cli_token), hl ; and save it 
1ffc 47				ld b,a 
1ffd			 
1ffd 2a 40 ea			ld hl,(cli_ptr) ;	get the char from the string to parse 
2000 7e				ld a,(hl) 
2001 23				inc hl 
2002 22 40 ea			ld (cli_ptr), hl		; move to next char 
2005 cd 43 11			call toUpper 		; make sure the input string matches case 
2008			 
2008			if DEBUG_FORTH_PARSE 
2008			endif 
2008			 
2008				; input stream end of token is a space so get rid of it 
2008			 
2008			;	cp ' ' 
2008			;	jr nz, .pnskipspace 
2008			; 
2008			;	ld a, 0		; make same term as word token term 
2008			; 
2008			;.pnskipspace: 
2008			 
2008			if DEBUG_FORTH_PARSE_KEY 
2008						DMARK "KY7" 
2008			endif 
2008 b8				cp b 
2009 c2 1f 20			jp nz, .execpnskipword	 ; no match so move to next word 
200c				 
200c			;    if same 
200c			;       scan for string terms 0 for token and 32 for input 
200c			 
200c				 
200c			if DEBUG_FORTH_PARSE_KEY 
200c						DMARK "KY8" 
200c			endif 
200c			 
200c 80				add b			 
200d fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
200f							; TODO need to make sure last word in zero term string is accounted for 
200f 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2011			 
2011			 
2011				; at end of both strings so both are exact match 
2011			 
2011			;       skip ptr for next word 
2011			 
2011 2a 40 ea			ld hl,(cli_ptr) 	; at input string term 
2014 23				inc hl			 ; at next char 
2015 22 40 ea			ld (cli_ptr), hl     ; save for next round of the parser 
2018 22 3e ea			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
201b				 
201b				 
201b			if DEBUG_FORTH_PARSE_KEY 
201b						DMARK "KY3" 
201b			endif 
201b			 
201b			 
201b			 
201b			;       exec code block 
201b			if DEBUG_FORTH_JP 
201b				call clear_display 
201b				call update_display 
201b				call delay1s 
201b				ld hl, (cli_execword)     ; save for next check if no match on this word 
201b				ld a,h 
201b				ld hl, os_word_scratch 
201b				call hexout 
201b				ld hl, (cli_execword)     ; save for next check if no match on this word 
201b				ld a,l 
201b				ld hl, os_word_scratch+2 
201b				call hexout 
201b				ld hl, os_word_scratch+4 
201b				ld a,0 
201b				ld (hl),a 
201b				ld de,os_word_scratch 
201b				call str_at_display 
201b					ld a, display_row_2 
201b					call str_at_display 
201b				ld de, (cli_origtoken) 
201b				ld a, display_row_1+10 
201b					call str_at_display 
201b			 
201b				ld a,display_row_1 
201b				ld de, .foundword 
201b				ld a, display_row_3 
201b				call str_at_display 
201b				call update_display 
201b				call delay1s 
201b				call delay1s 
201b				call delay1s 
201b			endif 
201b			 
201b			if DEBUG_FORTH_PARSE_KEY 
201b						DMARK "KYj" 
201b			endif 
201b				; TODO save the word pointer in this exec 
201b			 
201b 2a 44 ea			ld hl,(cli_execword) 
201e e9				jp (hl) 
201f			 
201f			 
201f			;    if not same 
201f			;	scan for zero term 
201f			;	get ptr for next word 
201f			;	goto word comp 
201f			 
201f			.execpnskipword:	; get pointer to next word 
201f 2a 42 ea			ld hl,(cli_nextword) 
2022			 
2022 7e				ld a,(hl) 
2023 fe 00			cp WORD_SYS_END 
2025			;	cp 0 
2025 28 09			jr z, .execendofdict			 ; at end of words 
2027			 
2027			if DEBUG_FORTH_PARSE_KEY 
2027						DMARK "KY4" 
2027			endif 
2027			if DEBUG_FORTH_PARSE_EXEC 
2027			 
2027				; see if disabled 
2027			 
2027			;	ld a, (os_view_disable) 
2027			;	cp '*' 
2027				ld a,(debug_vector) 
2027				cp $c9   ; RET 
2027				jr z, .noskip 
2027			 
2027			 
2027				ld de, .nowordfound 
2027				ld a, display_row_3 
2027				call str_at_display 
2027				call update_display 
2027				ld a, 100 
2027				call aDelayInMS 
2027				 
2027				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2027					call delay250ms 
2027				endif 
2027			.noskip:  
2027			 
2027			endif	 
2027			 
2027 2a 3e ea			ld hl,(cli_origptr) 
202a 22 40 ea			ld (cli_ptr),hl 
202d			 
202d			if DEBUG_FORTH_PARSE_KEY 
202d						DMARK "KY5" 
202d			endif 
202d c3 d3 1f			jp .execpnword			; else go to next word 
2030			 
2030			.execendofdict:  
2030			 
2030			if DEBUG_FORTH_PARSE_KEY 
2030						DMARK "KYe" 
2030			endif 
2030			if DEBUG_FORTH_PARSE_EXEC 
2030				; see if disabled 
2030			 
2030			;	ld a, (os_view_disable) 
2030			;	cp '*' 
2030				ld a,(debug_vector) 
2030				cp $c9   ; ret 
2030				jr z, .ispskip 
2030			 
2030				call clear_display 
2030				call update_display 
2030				call delay1s 
2030				ld de, (cli_origptr) 
2030				ld a, display_row_1 
2030				call str_at_display 
2030				 
2030				ld de, .enddict 
2030				ld a, display_row_3 
2030				call str_at_display 
2030				call update_display 
2030				ld a, 100 
2030				call aDelayInMS 
2030				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2030				call delay1s 
2030				call delay1s 
2030				call delay1s 
2030				endif 
2030			.ispskip:  
2030				 
2030			endif	 
2030			 
2030			 
2030			 
2030				; if the word is not a keyword then must be a literal so push it to stack 
2030			 
2030			; push token to stack to end of word 
2030			 
2030				STACKFRAME ON $1efe $2f9f 
2030				if DEBUG_STACK_IMB 
2030					if ON 
2030						exx 
2030						ld de, $1efe 
2030						ld a, d 
2030						ld hl, curframe 
2030						call hexout 
2030						ld a, e 
2030						ld hl, curframe+2 
2030						call hexout 
2030						ld hl, $1efe 
2030						push hl 
2030						ld hl, $2f9f 
2030						push hl 
2030						exx 
2030					endif 
2030				endif 
2030			endm 
# End of macro STACKFRAME
2030			 
2030 2a c2 e5		ld hl,(os_tok_ptr) 
2033 cd d6 1c		call forth_apush 
2036			 
2036				STACKFRAMECHK ON $1efe $2f9f 
2036				if DEBUG_STACK_IMB 
2036					if ON 
2036						exx 
2036						ld hl, $2f9f 
2036						pop de   ; $2f9f 
2036						call cmp16 
2036						jr nz, .spnosame 
2036						ld hl, $1efe 
2036						pop de   ; $1efe 
2036						call cmp16 
2036						jr z, .spfrsame 
2036						.spnosame: call showsperror 
2036						.spfrsame: nop 
2036						exx 
2036					endif 
2036				endif 
2036			endm 
# End of macro STACKFRAMECHK
2036			 
2036			execnext: 
2036			 
2036			if DEBUG_FORTH_PARSE_KEY 
2036						DMARK "KY>" 
2036			endif 
2036			; move past token to next word 
2036			 
2036 2a c2 e5		ld hl, (os_tok_ptr) 
2039 3e 00		ld a, 0 
203b 01 ff 00		ld bc, 255     ; input buffer size 
203e ed b1		cpir 
2040			 
2040			if DEBUG_FORTH_PARSE_KEY 
2040						DMARK "KY!" 
2040				CALLMONITOR 
2040			endif	 
2040			; TODO this might place hl on the null, so will need to forward on??? 
2040			;inc hl   ; see if this gets onto the next item 
2040			 
2040			 
2040			; TODO pass a pointer to the buffer to push 
2040			; TODO call function to push 
2040			 
2040			; look for end of input 
2040			 
2040			;inc hl 
2040			;ld a,(hl) 
2040			;cp FORTH_END_BUFFER 
2040			;ret z 
2040			 
2040			 
2040 c3 b9 1f		jp exec1 
2043			 
2043			 
2043			 
2043			 
2043			 
2043			 
2043			 
2043			 
2043			 
2043			findnexttok: 
2043			 
2043				; hl is pointer to move 
2043				; de is the token to locate 
2043			 
2043					if DEBUG_FORTH 
2043						DMARK "NTK" 
2043						CALLMONITOR 
2043					endif 
2043 d5				push de 
2044			 
2044			.fnt1:	 
2044				; find first char of token to locate 
2044			 
2044 1a				ld a, (de) 
2045 4f				ld c,a 
2046 7e				ld a,(hl) 
2047 cd 43 11			call toUpper 
204a					if DEBUG_FORTH 
204a						DMARK "NT1" 
204a						CALLMONITOR 
204a					endif 
204a b9				cp c 
204b			 
204b 28 03			jr z, .fnt2cmpmorefirst	 
204d			 
204d				; first char not found move to next char 
204d			 
204d 23				inc hl 
204e 18 f4			jr .fnt1 
2050			 
2050			.fnt2cmpmorefirst:	 
2050				; first char of token found.  
2050			 
2050 e5				push hl     ; save start of token just in case it is the right one 
2051 d9				exx 
2052 e1				pop hl        ; save it to hl' 
2053 d9				exx 
2054			 
2054			 
2054			.fnt2cmpmore:	 
2054				; compare the rest 
2054				 
2054 23				inc hl 
2055 13				inc de 
2056				 
2056 1a				ld a, (de) 
2057 4f				ld c,a 
2058 7e				ld a,(hl) 
2059 cd 43 11			call toUpper 
205c			 
205c					if DEBUG_FORTH 
205c						DMARK "NT2" 
205c						CALLMONITOR 
205c					endif 
205c				; c has the token to find char 
205c				; a has the mem to scan char 
205c			 
205c b9				cp c 
205d 28 04			jr z,.fntmatch1 
205f			 
205f				; they are not the same 
205f			 
205f					if DEBUG_FORTH 
205f						DMARK "NT3" 
205f						CALLMONITOR 
205f					endif 
205f d1				pop de	; reset de token to look for 
2060 d5				push de 
2061 18 e1			jr .fnt1 
2063				 
2063			.fntmatch1: 
2063			 
2063				; is the same char a null which means we might have a full hit? 
2063					if DEBUG_FORTH 
2063						DMARK "NT4" 
2063						CALLMONITOR 
2063					endif 
2063			 
2063 fe 00			cp 0 
2065 28 0b			jr z, .fntmatchyes 
2067			 
2067				; are we at the end of the token to find? 
2067			 
2067					if DEBUG_FORTH 
2067						DMARK "NT5" 
2067						CALLMONITOR 
2067					endif 
2067 3e 00			ld a, 0 
2069 b9				cp c 
206a			 
206a c2 54 20			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
206d			 
206d					if DEBUG_FORTH 
206d						DMARK "NT6" 
206d						CALLMONITOR 
206d					endif 
206d				; token to find is exhusted but no match to stream 
206d			 
206d				; restore tok pointer and continue on 
206d d1				pop de 
206e d5				push de 
206f c3 44 20			jp .fnt1 
2072			 
2072			 
2072			.fntmatchyes: 
2072			 
2072				; hl now contains the end of the found token 
2072			 
2072				; get rid of saved token pointer to find 
2072			 
2072 d1				pop de 
2073			 
2073					if DEBUG_FORTH 
2073						DMARK "NT9" 
2073						CALLMONITOR 
2073					endif 
2073			 
2073				; hl will be on the null term so forward on 
2073			 
2073				; get back the saved start of the token 
2073			 
2073 d9				exx 
2074 e5				push hl     ; save start of token just in case it is the right one 
2075 d9				exx 
2076 e1				pop hl        ; save it to hl 
2077			 
2077 c9				ret 
2078			 
2078			 
2078			; LIST needs to find a specific token   
2078			; FORGET needs to find a spefici token 
2078			 
2078			; SAVE needs to find all tokens by flag 
2078			; WORDS just needs to scan through all  by flag 
2078			; UWORDS needs to scan through all by flag 
2078			 
2078			 
2078			; given hl as pointer to start of dict look up string 
2078			; return hl as pointer to start of word block 
2078			; or 0 if not found 
2078			 
2078			forth_find_tok: 
2078 c9				ret 
2079			 
2079			; given hl as pointer to dict structure 
2079			; move to the next dict block structure 
2079			 
2079			forth_tok_next: 
2079				; hl now points to the address of the next word pointer  
2079				; TODO skip compiled symbol for now 
2079			;	push de 
2079 23				inc hl 
207a 5e				ld e, (hl) 
207b 23				inc hl 
207c 56				ld d, (hl) 
207d 23				inc hl 
207e			 
207e eb				ex de,hl 
207f			if DEBUG_FORTH_PARSE_NEXTWORD 
207f				push bc 
207f				ld bc, (cli_nextword) 
207f						DMARK "NXW" 
207f				CALLMONITOR 
207f				pop bc 
207f			endif 
207f			;	pop de	 
207f c9				ret 
2080			 
2080			 
2080			 
2080			; eof 
# End of file forth_parserv5.asm
2080				include "forth_wordsv4.asm" 
2080			 
2080			; the core word dictionary v4 
2080			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2080			 
2080			; this is a linked list for each of the system words used 
2080			; user defined words will follow the same format but will be in ram 
2080			 
2080			 
2080			; 
2080			; 
2080			; define linked list: 
2080			; 
2080			; 1. compiled byte op code 
2080			; 2. len of text word 
2080			; 3. text word 
2080			; 4. ptr to next dictionary word 
2080			; 5. asm, calls etc for the word 
2080			; 
2080			;  if 1 == 0 then last word in dict  
2080			;   
2080			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2080			;  
2080			;  
2080			; create basic standard set of words 
2080			; 
2080			;  
2080			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2080			; 2DUP 2DROP 2SWAP  
2080			; @ C@ - get byte  
2080			; ! C! - store byte 
2080			; 0< true if less than zero 
2080			; 0= true if zero 
2080			; < >  
2080			; = true if same 
2080			; variables 
2080			 
2080			 
2080			; Hardware specific words I may need 
2080			; 
2080			; IN OUT  
2080			; calls to key util functions 
2080			; calls to hardward abstraction stuff 
2080			; easy control of frame buffers and lcd i/o 
2080			; keyboard  
2080			 
2080			 
2080			;DICT: macro 
2080			; op_code, len, word, next 
2080			;    word: 
2080			;    db op_code 
2080			;    ds word zero term 
2080			;    dw next 
2080			;    endm 
2080			 
2080			 
2080			 
2080			 
2080			; op code 1 is a flag for user define words which are to be handled differently 
2080			 
2080			 
2080			; 
2080			; 
2080			;    TODO on entry to a word this should be the expected environment 
2080			;    hl - tos value if number then held, if string this is the ptr 
2080			;    de -  
2080			 
2080			 
2080			; opcode ranges 
2080			; 0 - end of word dict 
2080			; 255 - user define words 
2080			 
2080			sysdict: 
2080			include "forth_opcodes.asm" 
2080			; op codes for forth keywords 
2080			; free to use code 0  
2080				OPCODE_HEAP: equ  1 
2080				OPCODE_EXEC: equ 2 
2080				OPCODE_DUP: equ 3 
2080				OPCODE_SWAP: equ 4 
2080				OPCODE_COLN: equ 5 
2080				OPCODE_SCOLN: equ 6 
2080				OPCODE_DROP: equ 7 
2080				OPCODE_DUP2: equ 8 
2080				OPCODE_DROP2: equ 9 
2080				OPCODE_SWAP2: equ 10 
2080				OPCODE_AT: equ 11 
2080				OPCODE_CAT: equ 12 
2080				OPCODE_BANG: equ 13 
2080				OPCODE_CBANG: equ 14 
2080				OPCODE_SCALL: equ 15 
2080				OPCODE_DEPTH: equ 16 
2080				OPCODE_OVER: equ 17 
2080				OPCODE_PAUSE: equ 18 
2080				OPCODE_PAUSES: equ 19 
2080				OPCODE_ROT: equ 20 
2080			;free to reuse	OPCODE_WORDS: equ 21 
2080			        OPCODE_NOT: equ 21 
2080				OPCODE_UWORDS: equ 22 
2080				OPCODE_BP: equ 23 
2080				OPCODE_MONITOR: equ 24  
2080				OPCODE_MALLOC: equ 25 
2080				OPCODE_FREE: equ 26 
2080				OPCODE_LIST: equ 27 
2080				OPCODE_FORGET: equ 28 
2080				OPCODE_NOP: equ 29 
2080				OPCODE_COMO: equ 30 
2080				OPCODE_COMC: equ 31 
2080			;free to reuse	OPCODE_ENDCORE: equ 32 
2080				OPCODE_AFTERSOUND: equ 33 
2080				OPCODE_GP2: equ 34 
2080				OPCODE_GP3: equ 35 
2080				OPCODE_GP4: equ 36 
2080				OPCODE_SIN: equ 37 
2080				OPCODE_SOUT: equ 38 
2080				OPCODE_SPIO: equ 39 
2080				OPCODE_SPICEH: equ 40 
2080				OPCODE_SPIOb: equ 41 
2080				OPCODE_SPII: equ 42 
2080				OPCODE_SESEL: equ 43 
2080				OPCODE_CARTDEV: equ 44 
2080			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2080				OPCODE_FB: equ 46 
2080				OPCODE_EMIT: equ 47 
2080				OPCODE_DOTH: equ 48 
2080				OPCODE_DOTF: equ 49 
2080				OPCODE_DOT: equ 50 
2080				OPCODE_CLS: equ 51 
2080				OPCODE_DRAW: equ 52 
2080				OPCODE_DUMP: equ 53 
2080				OPCODE_CDUMP: equ 54 
2080				OPCODE_DAT: equ 55 
2080				OPCODE_HOME: equ 56 
2080				OPCODE_SPACE: equ 57 
2080				OPCODE_SPACES: equ 58 
2080				OPCODE_SCROLL: equ 59 
2080				OPCODE_ATQ: equ 60 
2080				OPCODE_AUTODSP: equ 61 
2080				OPCODE_MENU: equ 62 
2080			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2080				OPCODE_THEN: equ 64 
2080				OPCODE_ELSE: equ 65 
2080				OPCODE_DO: equ 66 
2080				OPCODE_LOOP: equ 67 
2080				OPCODE_I: equ 68 
2080				OPCODE_DLOOP: equ 69  
2080				OPCODE_REPEAT: equ 70  
2080				OPCODE_UNTIL: equ 71 
2080				OPCODE_ENDFLOW: equ 72 
2080				OPCODE_WAITK: equ 73 
2080				OPCODE_ACCEPT: equ 74 
2080				OPCODE_EDIT: equ 75 
2080			;free to reuse	OPCODE_ENDKEY: equ 76 
2080				OPCODE_LZERO: equ 77 
2080				OPCODE_TZERO: equ 78 
2080				OPCODE_LESS: equ 79 
2080				OPCODE_GT: equ 80 
2080				OPCODE_EQUAL: equ 81  
2080			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2080				OPCODE_NEG: equ 83 
2080				OPCODE_DIV: equ 84 
2080				OPCODE_MUL: equ 85 
2080				OPCODE_MIN: equ 86 
2080				OPCODE_MAX: equ 87 
2080				OPCODE_RND16: equ 88 
2080				OPCODE_RND8: equ 89 
2080				OPCODE_RND: equ 90 
2080			;free to reuse	OPCODE_ENDMATHS: equ 91  
2080				OPCODE_BYNAME: equ 92 
2080				OPCODE_DIR: equ 93 
2080				OPCODE_SAVE: equ 94 
2080				OPCODE_LOAD: equ 95 
2080				OPCODE_BSAVE: equ 96 
2080				OPCODE_BLOAD: equ 97 
2080				OPCODE_SEO: equ 98  
2080				OPCODE_SEI: equ 99 
2080				OPCODE_SFREE: equ 100 
2080				OPCODE_SIZE: equ 101 
2080				OPCODE_CREATE: equ 102 
2080				OPCODE_APPEND: equ 103 
2080				OPCODE_SDEL: equ 104 
2080				OPCODE_OPEN: equ 105 
2080				OPCODE_READ: equ 106 
2080				OPCODE_EOF: equ 106 
2080				OPCODE_FORMAT: equ 107 
2080				OPCODE_LABEL: equ 108 
2080				OPCODE_LABELS: equ 109 
2080			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2080				OPCODE_UPPER: equ 111 
2080				OPCODE_LOWER: equ 112 
2080				OPCODE_SUBSTR: equ 113 
2080				OPCODE_LEFT: equ 114 
2080				OPCODE_RIGHT: equ 115 
2080				OPCODE_STR2NUM: equ 116 
2080				OPCODE_NUM2STR: equ 117 
2080				OPCODE_CONCAT: equ 118 
2080				OPCODE_FIND: equ 119 
2080				OPCODE_LEN: equ 120 
2080				OPCODE_CHAR: equ 121 
2080			; free to reuse	OPCODE_STRLEN: equ 122 
2080			; free to reuse	OPCODE_ENDSTR: equ 123 
2080				OPCODE_V0S: equ 124 
2080				OPCODE_V0Q: equ 125 
2080				OPCODE_V1S: equ 126 
2080				OPCODE_V1Q: equ 127 
2080				OPCODE_V2S: equ 128 
2080				OPCODE_V2Q: equ 129 
2080				OPCODE_V3S: equ 130 
2080				OPCODE_V3Q: equ 131 
2080			;free to reuse	OPCODE_END: equ 132 
2080				OPCODE_ZDUP: equ 133 
2080			 
2080			; eof 
# End of file forth_opcodes.asm
2080			 
2080			include "forth_words_core.asm" 
2080			 
2080			; | ## Core Words 
2080			 
2080			;if MALLOC_4 
2080			 
2080			.HEAP: 
2080			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2080 15				db WORD_SYS_CORE+OPCODE_HEAP             
2081 bf 20			dw .EXEC            
2083 05				db 4 + 1 
2084 .. 00			db "HEAP",0              
2089				endm 
# End of macro CWHEAD
2089			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2089			; | | u1 - Current number of bytes in the heap 
2089			; | | u2 - Remaining bytes left on the heap 
2089			; | |  
2089			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2089			 
2089			 
2089				if DEBUG_FORTH_WORDS_KEY 
2089					DMARK "HEP" 
2089 f5				push af  
208a 3a 9e 20			ld a, (.dmark)  
208d 32 6b ee			ld (debug_mark),a  
2090 3a 9f 20			ld a, (.dmark+1)  
2093 32 6c ee			ld (debug_mark+1),a  
2096 3a a0 20			ld a, (.dmark+2)  
2099 32 6d ee			ld (debug_mark+2),a  
209c 18 03			jr .pastdmark  
209e ..			.dmark: db "HEP"  
20a1 f1			.pastdmark: pop af  
20a2			endm  
# End of macro DMARK
20a2					CALLMONITOR 
20a2 cd 6f ee			call debug_vector  
20a5				endm  
# End of macro CALLMONITOR
20a5				endif 
20a5 2a 7e 5e			ld hl, (free_list )      
20a8 11 83 5e			ld de, heap_start 
20ab			 
20ab ed 52			sbc hl, de  
20ad			 
20ad cd 6d 1b			call forth_push_numhl 
20b0			 
20b0			 
20b0 ed 5b 7e 5e		ld de, (free_list )      
20b4 21 9c e2			ld hl, heap_end 
20b7			 
20b7 ed 52			sbc hl, de 
20b9			 
20b9 cd 6d 1b			call forth_push_numhl 
20bc				 
20bc			 
20bc				 
20bc			 
20bc			 
20bc			 
20bc				NEXTW 
20bc c3 28 1f			jp macro_next 
20bf				endm 
# End of macro NEXTW
20bf			;endif 
20bf			 
20bf			.EXEC: 
20bf			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
20bf			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
20bf			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
20bf			;; > > 
20bf			;; > >   
20bf			;	STACKFRAME OFF $5efe $5f9f 
20bf			; 
20bf			;		if DEBUG_FORTH_WORDS_KEY 
20bf			;			DMARK "EXE" 
20bf			;			CALLMONITOR 
20bf			;		endif 
20bf			; 
20bf			;	FORTH_DSP_VALUEHL 
20bf			; 
20bf			;	FORTH_DSP_POP 
20bf			; 
20bf			;		if DEBUG_FORTH_WORDS 
20bf			;			DMARK "EX1" 
20bf			;			CALLMONITOR 
20bf			;		endif 
20bf			;;	ld e,(hl) 
20bf			;;	inc hl 
20bf			;;	ld d,(hl) 
20bf			;;	ex de,hl 
20bf			; 
20bf			;;		if DEBUG_FORTH_WORDS 
20bf			;;			DMARK "EX2" 
20bf			;;			CALLMONITOR 
20bf			;;		endif 
20bf			;	push hl 
20bf			; 
20bf			;	;ld a, 0 
20bf			;	;ld a, FORTH_END_BUFFER 
20bf			;	call strlenz 
20bf			;	inc hl   ; include zero term to copy 
20bf			;	inc hl   ; include term 
20bf			;	inc hl   ; include term 
20bf			;	ld b,0 
20bf			;	ld c,l 
20bf			;	pop hl 
20bf			;	ld de, execscratch 
20bf			;		if DEBUG_FORTH_WORDS 
20bf			;			DMARK "EX3" 
20bf			;			CALLMONITOR 
20bf			;		endif 
20bf			;	ldir 
20bf			; 
20bf			; 
20bf			;	ld hl, execscratch 
20bf			; 
20bf			;		if DEBUG_FORTH_WORDS 
20bf			;			DMARK "EXe" 
20bf			;			CALLMONITOR 
20bf			;		endif 
20bf			; 
20bf			;	call forthparse 
20bf			;	call forthexec 
20bf			;;	call forthexec_cleanup 
20bf			;;	call forthparse 
20bf			;;	call forthexec 
20bf			; 
20bf			;	STACKFRAMECHK OFF $5efe $5f9f 
20bf			; 
20bf			;	; an immediate word so no need to process any more words 
20bf			;	ret 
20bf			;	NEXTW 
20bf			 
20bf			; dead code - old version  
20bf			;	FORTH_RSP_NEXT 
20bf			 
20bf			;  
20bf			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
20bf			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
20bf			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
20bf			;	push hl 
20bf			;	push de 
20bf			;	push bc 
20bf			; 
20bf			; 
20bf			;		if DEBUG_FORTH_WORDS_KEY 
20bf			;			DMARK "EXR" 
20bf			;			CALLMONITOR 
20bf			;		endif 
20bf			; 
20bf			; 
20bf			; 
20bf			;	;v5 FORTH_DSP_VALUE 
20bf			;	FORTH_DSP_VALUEHL 
20bf			; 
20bf			;	; TODO do string type checks 
20bf			; 
20bf			;;v5	inc hl   ; skip type 
20bf			; 
20bf			;	push hl  ; source code  
20bf			;		if DEBUG_FORTH_WORDS 
20bf			;			DMARK "EX1" 
20bf			;			CALLMONITOR 
20bf			;		endif 
20bf			;	ld a, 0 
20bf			;	call strlent 
20bf			; 
20bf			;	inc hl 
20bf			;	inc hl 
20bf			;	inc hl 
20bf			;	inc hl 
20bf			; 
20bf			;	push hl    ; size 
20bf			; 
20bf			;		if DEBUG_FORTH_WORDS 
20bf			;			DMARK "EX2" 
20bf			;			CALLMONITOR 
20bf			;		endif 
20bf			;	call malloc 
20bf			; 
20bf			;	ex de, hl    ; de now contains malloc area 
20bf			;	pop bc   	; get byte count 
20bf			;	pop hl      ; get string to copy 
20bf			; 
20bf			;	push de     ; save malloc for free later 
20bf			; 
20bf			;		if DEBUG_FORTH_WORDS 
20bf			;			DMARK "EX3" 
20bf			;			CALLMONITOR 
20bf			;		endif 
20bf			;	ldir       ; duplicate string 
20bf			; 
20bf			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
20bf			;	 
20bf			;	; TODO fix the parse would be better than this...  
20bf			;	ex de, hl 
20bf			;	dec hl 
20bf			;	ld a, 0 
20bf			;	ld (hl), a 
20bf			;	dec hl 
20bf			;	ld a, ' ' 
20bf			;	ld (hl), a 
20bf			;	dec hl 
20bf			;	ld (hl), a 
20bf			; 
20bf			;	dec hl 
20bf			;	ld (hl), a 
20bf			; 
20bf			; 
20bf			;	FORTH_DSP_POP  
20bf			; 
20bf			;	pop hl     
20bf			;	push hl    ; save malloc area 
20bf			; 
20bf			;		if DEBUG_FORTH_WORDS 
20bf			;			DMARK "EX4" 
20bf			;			CALLMONITOR 
20bf			;		endif 
20bf			; 
20bf			;	call forthparse 
20bf			;	call forthexec 
20bf			;	 
20bf			;	pop hl 
20bf			;	if DEBUG_FORTH_WORDS 
20bf			;		DMARK "EX5" 
20bf			;		CALLMONITOR 
20bf			;	endif 
20bf			; 
20bf			;	if FORTH_ENABLE_FREE 
20bf			;	call free 
20bf			;	endif 
20bf			; 
20bf			;	if DEBUG_FORTH_WORDS 
20bf			;		DMARK "EX6" 
20bf			;		CALLMONITOR 
20bf			;	endif 
20bf			; 
20bf			;	pop bc 
20bf			;	pop de 
20bf			;	pop hl 
20bf			;;	FORTH_RSP_POP	  
20bf			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
20bf			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
20bf			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
20bf			; 
20bf			;	if DEBUG_FORTH_WORDS 
20bf			;		DMARK "EX7" 
20bf			;		CALLMONITOR 
20bf			;	endif 
20bf			;	NEXTW 
20bf			 
20bf			;.STKEXEC: 
20bf			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
20bf			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
20bf			; 
20bf			; 
20bf			;		if DEBUG_FORTH_WORDS_KEY 
20bf			;			DMARK "STX" 
20bf			;			CALLMONITOR 
20bf			;		endif 
20bf			; 
20bf			;	FORTH_DSP_VALUEHL 
20bf			; 
20bf			;	ld (store_tmp1), hl    ; count 
20bf			; 
20bf			;	FORTH_DSP_POP 
20bf			;.stkexec1: 
20bf			;	ld hl, (store_tmp1)   ; count 
20bf			;	ld a, 0 
20bf			;	cp l 
20bf			;	ret z 
20bf			; 
20bf			;	dec hl 
20bf			;	ld (store_tmp1), hl    ; count 
20bf			;	 
20bf			;	FORTH_DSP_VALUEHL 
20bf			;	push hl 
20bf			;	 
20bf			;		if DEBUG_FORTH_WORDS 
20bf			;			DMARK "EXp" 
20bf			;			CALLMONITOR 
20bf			;		endif 
20bf			;	FORTH_DSP_POP 
20bf			; 
20bf			;	call strlenz 
20bf			;	inc hl   ; include zero term to copy 
20bf			;	inc hl   ; include zero term to copy 
20bf			;	inc hl   ; include zero term to copy 
20bf			;	ld b,0 
20bf			;	ld c,l 
20bf			;	pop hl 
20bf			;	ld de, execscratch 
20bf			;		if DEBUG_FORTH_WORDS 
20bf			;			DMARK "EX3" 
20bf			;			CALLMONITOR 
20bf			;		endif 
20bf			;	ldir 
20bf			; 
20bf			; 
20bf			;	ld hl, execscratch 
20bf			; 
20bf			;		if DEBUG_FORTH_WORDS 
20bf			;			DMARK "EXP" 
20bf			;			CALLMONITOR 
20bf			;		endif 
20bf			; 
20bf			;	call forthparse 
20bf			;	ld hl, execscratch 
20bf			;		if DEBUG_FORTH_WORDS 
20bf			;			DMARK "EXx" 
20bf			;			CALLMONITOR 
20bf			;		endif 
20bf			;	call forthexec 
20bf			; 
20bf			;	jp .stkexec1 
20bf			; 
20bf			;	ret 
20bf			 
20bf			 
20bf			.DUP: 
20bf			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
20bf 17				db WORD_SYS_CORE+OPCODE_DUP             
20c0 35 21			dw .ZDUP            
20c2 04				db 3 + 1 
20c3 .. 00			db "DUP",0              
20c7				endm 
# End of macro CWHEAD
20c7			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
20c7			 
20c7				if DEBUG_FORTH_WORDS_KEY 
20c7					DMARK "DUP" 
20c7 f5				push af  
20c8 3a dc 20			ld a, (.dmark)  
20cb 32 6b ee			ld (debug_mark),a  
20ce 3a dd 20			ld a, (.dmark+1)  
20d1 32 6c ee			ld (debug_mark+1),a  
20d4 3a de 20			ld a, (.dmark+2)  
20d7 32 6d ee			ld (debug_mark+2),a  
20da 18 03			jr .pastdmark  
20dc ..			.dmark: db "DUP"  
20df f1			.pastdmark: pop af  
20e0			endm  
# End of macro DMARK
20e0					CALLMONITOR 
20e0 cd 6f ee			call debug_vector  
20e3				endm  
# End of macro CALLMONITOR
20e3				endif 
20e3			 
20e3				FORTH_DSP 
20e3 cd 38 1d			call macro_forth_dsp 
20e6				endm 
# End of macro FORTH_DSP
20e6			 
20e6 7e				ld a, (HL) 
20e7 fe 01			cp DS_TYPE_STR 
20e9 20 25			jr nz, .dupinum 
20eb			 
20eb				; push another string 
20eb			 
20eb				FORTH_DSP_VALUEHL     		 
20eb cd 72 1d			call macro_dsp_valuehl 
20ee				endm 
# End of macro FORTH_DSP_VALUEHL
20ee			 
20ee			if DEBUG_FORTH_WORDS 
20ee				DMARK "DUs" 
20ee f5				push af  
20ef 3a 03 21			ld a, (.dmark)  
20f2 32 6b ee			ld (debug_mark),a  
20f5 3a 04 21			ld a, (.dmark+1)  
20f8 32 6c ee			ld (debug_mark+1),a  
20fb 3a 05 21			ld a, (.dmark+2)  
20fe 32 6d ee			ld (debug_mark+2),a  
2101 18 03			jr .pastdmark  
2103 ..			.dmark: db "DUs"  
2106 f1			.pastdmark: pop af  
2107			endm  
# End of macro DMARK
2107				CALLMONITOR 
2107 cd 6f ee			call debug_vector  
210a				endm  
# End of macro CALLMONITOR
210a			endif 
210a cd db 1b			call forth_push_str 
210d			 
210d				NEXTW 
210d c3 28 1f			jp macro_next 
2110				endm 
# End of macro NEXTW
2110			 
2110			 
2110			.dupinum: 
2110				 
2110			 
2110			 
2110				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2110 cd 72 1d			call macro_dsp_valuehl 
2113				endm 
# End of macro FORTH_DSP_VALUEHL
2113			 
2113			; TODO add floating point number detection 
2113			 
2113			if DEBUG_FORTH_WORDS 
2113				DMARK "DUi" 
2113 f5				push af  
2114 3a 28 21			ld a, (.dmark)  
2117 32 6b ee			ld (debug_mark),a  
211a 3a 29 21			ld a, (.dmark+1)  
211d 32 6c ee			ld (debug_mark+1),a  
2120 3a 2a 21			ld a, (.dmark+2)  
2123 32 6d ee			ld (debug_mark+2),a  
2126 18 03			jr .pastdmark  
2128 ..			.dmark: db "DUi"  
212b f1			.pastdmark: pop af  
212c			endm  
# End of macro DMARK
212c				CALLMONITOR 
212c cd 6f ee			call debug_vector  
212f				endm  
# End of macro CALLMONITOR
212f			endif 
212f			 
212f cd 6d 1b			call forth_push_numhl 
2132				NEXTW 
2132 c3 28 1f			jp macro_next 
2135				endm 
# End of macro NEXTW
2135			.ZDUP: 
2135			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2135 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2136 6d 21			dw .SWAP            
2138 05				db 4 + 1 
2139 .. 00			db "?DUP",0              
213e				endm 
# End of macro CWHEAD
213e			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
213e			 
213e				if DEBUG_FORTH_WORDS_KEY 
213e					DMARK "qDU" 
213e f5				push af  
213f 3a 53 21			ld a, (.dmark)  
2142 32 6b ee			ld (debug_mark),a  
2145 3a 54 21			ld a, (.dmark+1)  
2148 32 6c ee			ld (debug_mark+1),a  
214b 3a 55 21			ld a, (.dmark+2)  
214e 32 6d ee			ld (debug_mark+2),a  
2151 18 03			jr .pastdmark  
2153 ..			.dmark: db "qDU"  
2156 f1			.pastdmark: pop af  
2157			endm  
# End of macro DMARK
2157					CALLMONITOR 
2157 cd 6f ee			call debug_vector  
215a				endm  
# End of macro CALLMONITOR
215a				endif 
215a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
215a cd 72 1d			call macro_dsp_valuehl 
215d				endm 
# End of macro FORTH_DSP_VALUEHL
215d			 
215d e5				push hl 
215e			 
215e				; is it a zero? 
215e			 
215e 3e 00			ld a, 0 
2160 84				add h 
2161 85				add l 
2162			 
2162 e1				pop hl 
2163			 
2163 fe 00			cp 0 
2165 28 03			jr z, .dup2orig 
2167			 
2167			 
2167 cd 6d 1b			call forth_push_numhl 
216a			 
216a			 
216a			; TODO add floating point number detection 
216a			 
216a			.dup2orig: 
216a			 
216a				NEXTW 
216a c3 28 1f			jp macro_next 
216d				endm 
# End of macro NEXTW
216d			.SWAP: 
216d			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
216d 18				db WORD_SYS_CORE+OPCODE_SWAP             
216e ac 21			dw .COLN            
2170 05				db 4 + 1 
2171 .. 00			db "SWAP",0              
2176				endm 
# End of macro CWHEAD
2176			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2176				if DEBUG_FORTH_WORDS_KEY 
2176					DMARK "SWP" 
2176 f5				push af  
2177 3a 8b 21			ld a, (.dmark)  
217a 32 6b ee			ld (debug_mark),a  
217d 3a 8c 21			ld a, (.dmark+1)  
2180 32 6c ee			ld (debug_mark+1),a  
2183 3a 8d 21			ld a, (.dmark+2)  
2186 32 6d ee			ld (debug_mark+2),a  
2189 18 03			jr .pastdmark  
218b ..			.dmark: db "SWP"  
218e f1			.pastdmark: pop af  
218f			endm  
# End of macro DMARK
218f					CALLMONITOR 
218f cd 6f ee			call debug_vector  
2192				endm  
# End of macro CALLMONITOR
2192				endif 
2192			 
2192			; TODO Use os stack swap memory 
2192				FORTH_DSP_VALUEHL 
2192 cd 72 1d			call macro_dsp_valuehl 
2195				endm 
# End of macro FORTH_DSP_VALUEHL
2195 e5				push hl     ; w2 
2196			 
2196				FORTH_DSP_POP 
2196 cd 2a 1e			call macro_forth_dsp_pop 
2199				endm 
# End of macro FORTH_DSP_POP
2199			 
2199				FORTH_DSP_VALUEHL 
2199 cd 72 1d			call macro_dsp_valuehl 
219c				endm 
# End of macro FORTH_DSP_VALUEHL
219c			 
219c				FORTH_DSP_POP 
219c cd 2a 1e			call macro_forth_dsp_pop 
219f				endm 
# End of macro FORTH_DSP_POP
219f			 
219f d1				pop de     ; w2	, hl = w1 
21a0			 
21a0 eb				ex de, hl 
21a1 d5				push de 
21a2			 
21a2 cd 6d 1b			call forth_push_numhl 
21a5			 
21a5 e1				pop hl 
21a6			 
21a6 cd 6d 1b			call forth_push_numhl 
21a9				 
21a9			 
21a9				NEXTW 
21a9 c3 28 1f			jp macro_next 
21ac				endm 
# End of macro NEXTW
21ac			.COLN: 
21ac			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
21ac 19				db WORD_SYS_CORE+OPCODE_COLN             
21ad 38 23			dw .SCOLN            
21af 02				db 1 + 1 
21b0 .. 00			db ":",0              
21b2				endm 
# End of macro CWHEAD
21b2			; | : ( -- )         Create new word | DONE 
21b2			 
21b2				if DEBUG_FORTH_WORDS_KEY 
21b2					DMARK "CLN" 
21b2 f5				push af  
21b3 3a c7 21			ld a, (.dmark)  
21b6 32 6b ee			ld (debug_mark),a  
21b9 3a c8 21			ld a, (.dmark+1)  
21bc 32 6c ee			ld (debug_mark+1),a  
21bf 3a c9 21			ld a, (.dmark+2)  
21c2 32 6d ee			ld (debug_mark+2),a  
21c5 18 03			jr .pastdmark  
21c7 ..			.dmark: db "CLN"  
21ca f1			.pastdmark: pop af  
21cb			endm  
# End of macro DMARK
21cb					CALLMONITOR 
21cb cd 6f ee			call debug_vector  
21ce				endm  
# End of macro CALLMONITOR
21ce				endif 
21ce			STACKFRAME OFF $8efe $989f 
21ce				if DEBUG_STACK_IMB 
21ce					if OFF 
21ce						exx 
21ce						ld de, $8efe 
21ce						ld a, d 
21ce						ld hl, curframe 
21ce						call hexout 
21ce						ld a, e 
21ce						ld hl, curframe+2 
21ce						call hexout 
21ce						ld hl, $8efe 
21ce						push hl 
21ce						ld hl, $989f 
21ce						push hl 
21ce						exx 
21ce					endif 
21ce				endif 
21ce			endm 
# End of macro STACKFRAME
21ce			; get parser buffer length  of new word 
21ce			 
21ce			 
21ce			 
21ce				; move tok past this to start of name defintition 
21ce				; TODO get word to define 
21ce				; TODO Move past word token 
21ce				; TODO get length of string up to the ';' 
21ce			 
21ce 2a c2 e5		ld hl, (os_tok_ptr) 
21d1 23			inc hl 
21d2 23			inc hl 
21d3			 
21d3 3e 3b		ld a, ';' 
21d5 cd 57 11		call strlent 
21d8			 
21d8 7d			ld a,l 
21d9 32 b1 e2		ld (os_new_parse_len), a 
21dc			 
21dc			 
21dc			if DEBUG_FORTH_UWORD 
21dc ed 5b c2 e5	ld de, (os_tok_ptr) 
21e0					DMARK ":01" 
21e0 f5				push af  
21e1 3a f5 21			ld a, (.dmark)  
21e4 32 6b ee			ld (debug_mark),a  
21e7 3a f6 21			ld a, (.dmark+1)  
21ea 32 6c ee			ld (debug_mark+1),a  
21ed 3a f7 21			ld a, (.dmark+2)  
21f0 32 6d ee			ld (debug_mark+2),a  
21f3 18 03			jr .pastdmark  
21f5 ..			.dmark: db ":01"  
21f8 f1			.pastdmark: pop af  
21f9			endm  
# End of macro DMARK
21f9			CALLMONITOR 
21f9 cd 6f ee			call debug_vector  
21fc				endm  
# End of macro CALLMONITOR
21fc			endif 
21fc			 
21fc			; 
21fc			;  new word memory layout: 
21fc			;  
21fc			;    : adg 6666 ;  
21fc			; 
21fc			;    db   1     ; user defined word  
21fc 23			inc hl    
21fd			;    dw   sysdict 
21fd 23			inc hl 
21fe 23			inc hl 
21ff			;    db <word len>+1 (for null) 
21ff 23			inc hl 
2200			;    db .... <word> 
2200			; 
2200			 
2200 23			inc hl    ; some extras for the word preamble before the above 
2201 23			inc hl 
2202 23			inc hl 
2203 23			inc hl 
2204 23			inc hl 
2205 23			inc hl 
2206 23			inc hl  
2207 23			inc hl 
2208 23			inc hl 
2209 23			inc hl 
220a 23			inc hl 
220b 23			inc hl 
220c 23			inc hl 
220d 23			inc hl     ; TODO how many do we really need?     maybe only 6 
220e			;       exec word buffer 
220e			;	<ptr word>   
220e 23			inc hl 
220f 23			inc hl 
2210			;       <word list><null term> 7F final term 
2210			 
2210			 
2210			if DEBUG_FORTH_UWORD 
2210					DMARK ":02" 
2210 f5				push af  
2211 3a 25 22			ld a, (.dmark)  
2214 32 6b ee			ld (debug_mark),a  
2217 3a 26 22			ld a, (.dmark+1)  
221a 32 6c ee			ld (debug_mark+1),a  
221d 3a 27 22			ld a, (.dmark+2)  
2220 32 6d ee			ld (debug_mark+2),a  
2223 18 03			jr .pastdmark  
2225 ..			.dmark: db ":02"  
2228 f1			.pastdmark: pop af  
2229			endm  
# End of macro DMARK
2229			CALLMONITOR 
2229 cd 6f ee			call debug_vector  
222c				endm  
# End of macro CALLMONITOR
222c			endif 
222c			 
222c			 
222c				; malloc the size 
222c			 
222c cd c1 11			call malloc 
222f 22 b3 e2			ld (os_new_malloc), hl     ; save malloc start 
2232			 
2232			;    db   1     ; user defined word  
2232 3e 01			ld a, WORD_SYS_UWORD  
2234 77				ld (hl), a 
2235			 
2235 23			inc hl    
2236			;    dw   sysdict 
2236 11 80 20		ld de, sysdict       ; continue on with the scan to the system dict 
2239 73			ld (hl), e 
223a 23			inc hl 
223b 72			ld (hl), d 
223c 23			inc hl 
223d			 
223d			 
223d			;    Setup dict word 
223d			 
223d 23			inc hl 
223e 22 ad e2		ld (os_new_work_ptr), hl     ; save start of dict word  
2241			 
2241			; 1. get length of dict word 
2241			 
2241			 
2241 2a c2 e5		ld hl, (os_tok_ptr) 
2244 23			inc hl 
2245 23			inc hl    ; position to start of dict word 
2246 3e 00		ld a, 0 
2248 cd 57 11		call strlent 
224b			 
224b			 
224b 23			inc hl    ; to include null??? 
224c			 
224c			; write length of dict word 
224c			 
224c ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2250 1b			dec de 
2251 eb			ex de, hl 
2252 73			ld (hl), e 
2253 eb			ex de, hl 
2254			 
2254			 
2254			 
2254			; copy  
2254 4d			ld c, l 
2255 06 00		ld b, 0 
2257 ed 5b ad e2	ld de, (os_new_work_ptr)   ; get dest for copy of word 
225b 2a c2 e5		ld hl, (os_tok_ptr) 
225e 23			inc hl 
225f 23			inc hl    ; position to start of dict word 
2260			 
2260			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2260			 
2260			; TODO need to convert word to upper case 
2260			 
2260			ucasetok:	 
2260 7e			ld a,(hl) 
2261 cd 43 11		call toUpper 
2264 77			ld (hl),a 
2265 ed a0		ldi 
2267 f2 60 22		jp p, ucasetok 
226a			 
226a			 
226a			 
226a			; de now points to start of where the word body code should be placed 
226a ed 53 ad e2	ld (os_new_work_ptr), de 
226e			; hl now points to the words to throw at forthexec which needs to be copied 
226e 22 ab e2		ld (os_new_src_ptr), hl 
2271			 
2271			; TODO add 'call to forthexec' 
2271			 
2271			if DEBUG_FORTH_UWORD 
2271 c5			push bc 
2272 ed 4b b3 e2	ld bc, (os_new_malloc) 
2276					DMARK ":0x" 
2276 f5				push af  
2277 3a 8b 22			ld a, (.dmark)  
227a 32 6b ee			ld (debug_mark),a  
227d 3a 8c 22			ld a, (.dmark+1)  
2280 32 6c ee			ld (debug_mark+1),a  
2283 3a 8d 22			ld a, (.dmark+2)  
2286 32 6d ee			ld (debug_mark+2),a  
2289 18 03			jr .pastdmark  
228b ..			.dmark: db ":0x"  
228e f1			.pastdmark: pop af  
228f			endm  
# End of macro DMARK
228f			CALLMONITOR 
228f cd 6f ee			call debug_vector  
2292				endm  
# End of macro CALLMONITOR
2292 c1			pop bc 
2293			endif 
2293			 
2293			 
2293			; create word preamble which should be: 
2293			 
2293			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2293			 
2293			;    ld hl, <word code> 
2293			;    jp user_exec 
2293			;    <word code bytes> 
2293			 
2293			 
2293			;	inc de     ; TODO ??? or are we already past the word's null 
2293 eb			ex de, hl 
2294			 
2294 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2296			 
2296 23			inc hl 
2297 22 a7 e2		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
229a 23			inc hl 
229b			 
229b 23			inc hl 
229c 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
229e			 
229e 01 16 4c		ld bc, user_exec 
22a1 23			inc hl 
22a2 71			ld (hl), c     ; poke address of user_exec 
22a3 23			inc hl 
22a4 70			ld (hl), b     
22a5			; 
22a5			;	inc hl 
22a5			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
22a5			; 
22a5			; 
22a5			;	ld bc, macro_forth_rsp_next 
22a5			;	inc hl 
22a5			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
22a5			;	inc hl 
22a5			;	ld (hl), b     
22a5			; 
22a5			;	inc hl 
22a5			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
22a5			; 
22a5			; 
22a5			;	inc hl 
22a5			;	ld bc, forthexec 
22a5			;	ld (hl), c     ; poke address of forthexec 
22a5			;	inc hl 
22a5			;	ld (hl), b      
22a5			; 
22a5			;	inc hl 
22a5			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
22a5			; 
22a5			;	ld bc, user_dict_next 
22a5			;	inc hl 
22a5			;	ld (hl), c     ; poke address of forthexec 
22a5			;	inc hl 
22a5			;	ld (hl), b      
22a5			 
22a5			; hl is now where we need to copy the word byte data to save this 
22a5			 
22a5 23			inc hl 
22a6 22 a9 e2		ld (os_new_exec), hl 
22a9			 
22a9			; copy definition 
22a9			 
22a9 eb			ex de, hl 
22aa			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
22aa			;	inc de    ; skip the PC for this parse 
22aa 3a b1 e2		ld a, (os_new_parse_len) 
22ad 4f			ld c, a 
22ae 06 00		ld b, 0 
22b0 ed b0		ldir		 ; copy defintion 
22b2			 
22b2			 
22b2			; poke the address of where the new word bytes live for forthexec 
22b2			 
22b2 2a a7 e2		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
22b5			 
22b5 ed 5b a9 e2	ld de, (os_new_exec)      
22b9			 
22b9 73			ld (hl), e 
22ba 23			inc hl 
22bb 72			ld (hl), d 
22bc			 
22bc				; TODO copy last user dict word next link to this word 
22bc				; TODO update last user dict word to point to this word 
22bc			; 
22bc			; hl f923 de 812a ; bc 811a 
22bc			 
22bc			if DEBUG_FORTH_UWORD 
22bc c5			push bc 
22bd ed 4b b3 e2	ld bc, (os_new_malloc) 
22c1					DMARK ":0A" 
22c1 f5				push af  
22c2 3a d6 22			ld a, (.dmark)  
22c5 32 6b ee			ld (debug_mark),a  
22c8 3a d7 22			ld a, (.dmark+1)  
22cb 32 6c ee			ld (debug_mark+1),a  
22ce 3a d8 22			ld a, (.dmark+2)  
22d1 32 6d ee			ld (debug_mark+2),a  
22d4 18 03			jr .pastdmark  
22d6 ..			.dmark: db ":0A"  
22d9 f1			.pastdmark: pop af  
22da			endm  
# End of macro DMARK
22da			CALLMONITOR 
22da cd 6f ee			call debug_vector  
22dd				endm  
# End of macro CALLMONITOR
22dd c1			pop bc 
22de			endif 
22de			if DEBUG_FORTH_UWORD 
22de c5			push bc 
22df ed 4b b3 e2	ld bc, (os_new_malloc) 
22e3 03			inc bc 
22e4 03			inc bc 
22e5 03			inc bc 
22e6 03			inc bc 
22e7 03			inc bc 
22e8 03			inc bc 
22e9 03			inc bc 
22ea 03			inc bc 
22eb			 
22eb					DMARK ":0B" 
22eb f5				push af  
22ec 3a 00 23			ld a, (.dmark)  
22ef 32 6b ee			ld (debug_mark),a  
22f2 3a 01 23			ld a, (.dmark+1)  
22f5 32 6c ee			ld (debug_mark+1),a  
22f8 3a 02 23			ld a, (.dmark+2)  
22fb 32 6d ee			ld (debug_mark+2),a  
22fe 18 03			jr .pastdmark  
2300 ..			.dmark: db ":0B"  
2303 f1			.pastdmark: pop af  
2304			endm  
# End of macro DMARK
2304			CALLMONITOR 
2304 cd 6f ee			call debug_vector  
2307				endm  
# End of macro CALLMONITOR
2307 c1			pop bc 
2308			endif 
2308			 
2308			; update word dict linked list for new word 
2308			 
2308			 
2308 2a be e5		ld hl, (os_last_new_uword)		; get the start of the last added uword 
230b 23			inc hl     ; move to next work linked list ptr 
230c			 
230c ed 5b b3 e2	ld de, (os_new_malloc)		 ; new next word 
2310 73			ld (hl), e 
2311 23			inc hl 
2312 72			ld (hl), d 
2313			 
2313			if DEBUG_FORTH_UWORD 
2313 ed 4b be e5	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2317			endif 
2317			 
2317 ed 53 be e5	ld (os_last_new_uword), de      ; update last new uword ptr 
231b			 
231b			 
231b			if DEBUG_FORTH_UWORD 
231b					DMARK ":0+" 
231b f5				push af  
231c 3a 30 23			ld a, (.dmark)  
231f 32 6b ee			ld (debug_mark),a  
2322 3a 31 23			ld a, (.dmark+1)  
2325 32 6c ee			ld (debug_mark+1),a  
2328 3a 32 23			ld a, (.dmark+2)  
232b 32 6d ee			ld (debug_mark+2),a  
232e 18 03			jr .pastdmark  
2330 ..			.dmark: db ":0+"  
2333 f1			.pastdmark: pop af  
2334			endm  
# End of macro DMARK
2334			CALLMONITOR 
2334 cd 6f ee			call debug_vector  
2337				endm  
# End of macro CALLMONITOR
2337			endif 
2337			 
2337			STACKFRAMECHK OFF $8efe $989f 
2337				if DEBUG_STACK_IMB 
2337					if OFF 
2337						exx 
2337						ld hl, $989f 
2337						pop de   ; $989f 
2337						call cmp16 
2337						jr nz, .spnosame 
2337						ld hl, $8efe 
2337						pop de   ; $8efe 
2337						call cmp16 
2337						jr z, .spfrsame 
2337						.spnosame: call showsperror 
2337						.spfrsame: nop 
2337						exx 
2337					endif 
2337				endif 
2337			endm 
# End of macro STACKFRAMECHK
2337			 
2337 c9			ret    ; dont process any remaining parser tokens as they form new word 
2338			 
2338			 
2338			 
2338			 
2338			;		NEXT 
2338			.SCOLN: 
2338			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2338 06			db OPCODE_SCOLN 
2339 84 23		dw .DROP 
233b 02			db 2 
233c .. 00		db ";",0           
233e			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
233e				if DEBUG_FORTH_WORDS_KEY 
233e					DMARK "SCN" 
233e f5				push af  
233f 3a 53 23			ld a, (.dmark)  
2342 32 6b ee			ld (debug_mark),a  
2345 3a 54 23			ld a, (.dmark+1)  
2348 32 6c ee			ld (debug_mark+1),a  
234b 3a 55 23			ld a, (.dmark+2)  
234e 32 6d ee			ld (debug_mark+2),a  
2351 18 03			jr .pastdmark  
2353 ..			.dmark: db "SCN"  
2356 f1			.pastdmark: pop af  
2357			endm  
# End of macro DMARK
2357					CALLMONITOR 
2357 cd 6f ee			call debug_vector  
235a				endm  
# End of macro CALLMONITOR
235a				endif 
235a				FORTH_RSP_TOS 
235a cd 2b 1b			call macro_forth_rsp_tos 
235d				endm 
# End of macro FORTH_RSP_TOS
235d e5				push hl 
235e				FORTH_RSP_POP 
235e cd 35 1b			call macro_forth_rsp_pop 
2361				endm 
# End of macro FORTH_RSP_POP
2361 e1				pop hl 
2362			;		ex de,hl 
2362 22 c2 e5			ld (os_tok_ptr),hl 
2365			 
2365			if DEBUG_FORTH_UWORD 
2365					DMARK "SCL" 
2365 f5				push af  
2366 3a 7a 23			ld a, (.dmark)  
2369 32 6b ee			ld (debug_mark),a  
236c 3a 7b 23			ld a, (.dmark+1)  
236f 32 6c ee			ld (debug_mark+1),a  
2372 3a 7c 23			ld a, (.dmark+2)  
2375 32 6d ee			ld (debug_mark+2),a  
2378 18 03			jr .pastdmark  
237a ..			.dmark: db "SCL"  
237d f1			.pastdmark: pop af  
237e			endm  
# End of macro DMARK
237e			CALLMONITOR 
237e cd 6f ee			call debug_vector  
2381				endm  
# End of macro CALLMONITOR
2381			endif 
2381				NEXTW 
2381 c3 28 1f			jp macro_next 
2384				endm 
# End of macro NEXTW
2384			 
2384			.DROP: 
2384			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2384 1b				db WORD_SYS_CORE+OPCODE_DROP             
2385 af 23			dw .DUP2            
2387 05				db 4 + 1 
2388 .. 00			db "DROP",0              
238d				endm 
# End of macro CWHEAD
238d			; | DROP ( w -- )   drop the TOS item   | DONE 
238d				if DEBUG_FORTH_WORDS_KEY 
238d					DMARK "DRP" 
238d f5				push af  
238e 3a a2 23			ld a, (.dmark)  
2391 32 6b ee			ld (debug_mark),a  
2394 3a a3 23			ld a, (.dmark+1)  
2397 32 6c ee			ld (debug_mark+1),a  
239a 3a a4 23			ld a, (.dmark+2)  
239d 32 6d ee			ld (debug_mark+2),a  
23a0 18 03			jr .pastdmark  
23a2 ..			.dmark: db "DRP"  
23a5 f1			.pastdmark: pop af  
23a6			endm  
# End of macro DMARK
23a6					CALLMONITOR 
23a6 cd 6f ee			call debug_vector  
23a9				endm  
# End of macro CALLMONITOR
23a9				endif 
23a9				FORTH_DSP_POP 
23a9 cd 2a 1e			call macro_forth_dsp_pop 
23ac				endm 
# End of macro FORTH_DSP_POP
23ac				NEXTW 
23ac c3 28 1f			jp macro_next 
23af				endm 
# End of macro NEXTW
23af			.DUP2: 
23af			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
23af 1c				db WORD_SYS_CORE+OPCODE_DUP2             
23b0 f4 23			dw .DROP2            
23b2 05				db 4 + 1 
23b3 .. 00			db "2DUP",0              
23b8				endm 
# End of macro CWHEAD
23b8			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
23b8				if DEBUG_FORTH_WORDS_KEY 
23b8					DMARK "2DU" 
23b8 f5				push af  
23b9 3a cd 23			ld a, (.dmark)  
23bc 32 6b ee			ld (debug_mark),a  
23bf 3a ce 23			ld a, (.dmark+1)  
23c2 32 6c ee			ld (debug_mark+1),a  
23c5 3a cf 23			ld a, (.dmark+2)  
23c8 32 6d ee			ld (debug_mark+2),a  
23cb 18 03			jr .pastdmark  
23cd ..			.dmark: db "2DU"  
23d0 f1			.pastdmark: pop af  
23d1			endm  
# End of macro DMARK
23d1					CALLMONITOR 
23d1 cd 6f ee			call debug_vector  
23d4				endm  
# End of macro CALLMONITOR
23d4				endif 
23d4				FORTH_DSP_VALUEHL 
23d4 cd 72 1d			call macro_dsp_valuehl 
23d7				endm 
# End of macro FORTH_DSP_VALUEHL
23d7 e5				push hl      ; 2 
23d8			 
23d8				FORTH_DSP_POP 
23d8 cd 2a 1e			call macro_forth_dsp_pop 
23db				endm 
# End of macro FORTH_DSP_POP
23db				 
23db				FORTH_DSP_VALUEHL 
23db cd 72 1d			call macro_dsp_valuehl 
23de				endm 
# End of macro FORTH_DSP_VALUEHL
23de			;		push hl      ; 1 
23de			 
23de				FORTH_DSP_POP 
23de cd 2a 1e			call macro_forth_dsp_pop 
23e1				endm 
# End of macro FORTH_DSP_POP
23e1			 
23e1			;		pop hl       ; 1 
23e1 d1				pop de       ; 2 
23e2			 
23e2 cd 6d 1b			call forth_push_numhl 
23e5 eb				ex de, hl 
23e6 cd 6d 1b			call forth_push_numhl 
23e9			 
23e9				 
23e9 eb				ex de, hl 
23ea			 
23ea cd 6d 1b			call forth_push_numhl 
23ed eb				ex de, hl 
23ee cd 6d 1b			call forth_push_numhl 
23f1			 
23f1			 
23f1				NEXTW 
23f1 c3 28 1f			jp macro_next 
23f4				endm 
# End of macro NEXTW
23f4			.DROP2: 
23f4			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
23f4 1d				db WORD_SYS_CORE+OPCODE_DROP2             
23f5 23 24			dw .SWAP2            
23f7 06				db 5 + 1 
23f8 .. 00			db "2DROP",0              
23fe				endm 
# End of macro CWHEAD
23fe			; | 2DROP ( w w -- )    Double drop | DONE 
23fe				if DEBUG_FORTH_WORDS_KEY 
23fe					DMARK "2DR" 
23fe f5				push af  
23ff 3a 13 24			ld a, (.dmark)  
2402 32 6b ee			ld (debug_mark),a  
2405 3a 14 24			ld a, (.dmark+1)  
2408 32 6c ee			ld (debug_mark+1),a  
240b 3a 15 24			ld a, (.dmark+2)  
240e 32 6d ee			ld (debug_mark+2),a  
2411 18 03			jr .pastdmark  
2413 ..			.dmark: db "2DR"  
2416 f1			.pastdmark: pop af  
2417			endm  
# End of macro DMARK
2417					CALLMONITOR 
2417 cd 6f ee			call debug_vector  
241a				endm  
# End of macro CALLMONITOR
241a				endif 
241a				FORTH_DSP_POP 
241a cd 2a 1e			call macro_forth_dsp_pop 
241d				endm 
# End of macro FORTH_DSP_POP
241d				FORTH_DSP_POP 
241d cd 2a 1e			call macro_forth_dsp_pop 
2420				endm 
# End of macro FORTH_DSP_POP
2420				NEXTW 
2420 c3 28 1f			jp macro_next 
2423				endm 
# End of macro NEXTW
2423			.SWAP2: 
2423			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2423 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2424 4c 24			dw .AT            
2426 06				db 5 + 1 
2427 .. 00			db "2SWAP",0              
242d				endm 
# End of macro CWHEAD
242d			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
242d				if DEBUG_FORTH_WORDS_KEY 
242d					DMARK "2SW" 
242d f5				push af  
242e 3a 42 24			ld a, (.dmark)  
2431 32 6b ee			ld (debug_mark),a  
2434 3a 43 24			ld a, (.dmark+1)  
2437 32 6c ee			ld (debug_mark+1),a  
243a 3a 44 24			ld a, (.dmark+2)  
243d 32 6d ee			ld (debug_mark+2),a  
2440 18 03			jr .pastdmark  
2442 ..			.dmark: db "2SW"  
2445 f1			.pastdmark: pop af  
2446			endm  
# End of macro DMARK
2446					CALLMONITOR 
2446 cd 6f ee			call debug_vector  
2449				endm  
# End of macro CALLMONITOR
2449				endif 
2449			; TODO Use os stack swap memory 
2449				NEXTW 
2449 c3 28 1f			jp macro_next 
244c				endm 
# End of macro NEXTW
244c			.AT: 
244c			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
244c 1f				db WORD_SYS_CORE+OPCODE_AT             
244d 7e 24			dw .CAT            
244f 02				db 1 + 1 
2450 .. 00			db "@",0              
2452				endm 
# End of macro CWHEAD
2452			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2452			 
2452				if DEBUG_FORTH_WORDS_KEY 
2452					DMARK "AT." 
2452 f5				push af  
2453 3a 67 24			ld a, (.dmark)  
2456 32 6b ee			ld (debug_mark),a  
2459 3a 68 24			ld a, (.dmark+1)  
245c 32 6c ee			ld (debug_mark+1),a  
245f 3a 69 24			ld a, (.dmark+2)  
2462 32 6d ee			ld (debug_mark+2),a  
2465 18 03			jr .pastdmark  
2467 ..			.dmark: db "AT."  
246a f1			.pastdmark: pop af  
246b			endm  
# End of macro DMARK
246b					CALLMONITOR 
246b cd 6f ee			call debug_vector  
246e				endm  
# End of macro CALLMONITOR
246e				endif 
246e			.getbyteat:	 
246e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
246e cd 72 1d			call macro_dsp_valuehl 
2471				endm 
# End of macro FORTH_DSP_VALUEHL
2471				 
2471			;		push hl 
2471			 
2471				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2471 cd 2a 1e			call macro_forth_dsp_pop 
2474				endm 
# End of macro FORTH_DSP_POP
2474			 
2474			;		pop hl 
2474			 
2474 7e				ld a, (hl) 
2475			 
2475 6f				ld l, a 
2476 26 00			ld h, 0 
2478 cd 6d 1b			call forth_push_numhl 
247b			 
247b				NEXTW 
247b c3 28 1f			jp macro_next 
247e				endm 
# End of macro NEXTW
247e			.CAT: 
247e			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
247e 20				db WORD_SYS_CORE+OPCODE_CAT             
247f a7 24			dw .BANG            
2481 03				db 2 + 1 
2482 .. 00			db "C@",0              
2485				endm 
# End of macro CWHEAD
2485			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2485				if DEBUG_FORTH_WORDS_KEY 
2485					DMARK "CAA" 
2485 f5				push af  
2486 3a 9a 24			ld a, (.dmark)  
2489 32 6b ee			ld (debug_mark),a  
248c 3a 9b 24			ld a, (.dmark+1)  
248f 32 6c ee			ld (debug_mark+1),a  
2492 3a 9c 24			ld a, (.dmark+2)  
2495 32 6d ee			ld (debug_mark+2),a  
2498 18 03			jr .pastdmark  
249a ..			.dmark: db "CAA"  
249d f1			.pastdmark: pop af  
249e			endm  
# End of macro DMARK
249e					CALLMONITOR 
249e cd 6f ee			call debug_vector  
24a1				endm  
# End of macro CALLMONITOR
24a1				endif 
24a1 c3 6e 24			jp .getbyteat 
24a4				NEXTW 
24a4 c3 28 1f			jp macro_next 
24a7				endm 
# End of macro NEXTW
24a7			.BANG: 
24a7			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
24a7 21				db WORD_SYS_CORE+OPCODE_BANG             
24a8 dd 24			dw .CBANG            
24aa 02				db 1 + 1 
24ab .. 00			db "!",0              
24ad				endm 
# End of macro CWHEAD
24ad			; | ! ( x w -- ) Store x at address w      | DONE 
24ad				if DEBUG_FORTH_WORDS_KEY 
24ad					DMARK "BNG" 
24ad f5				push af  
24ae 3a c2 24			ld a, (.dmark)  
24b1 32 6b ee			ld (debug_mark),a  
24b4 3a c3 24			ld a, (.dmark+1)  
24b7 32 6c ee			ld (debug_mark+1),a  
24ba 3a c4 24			ld a, (.dmark+2)  
24bd 32 6d ee			ld (debug_mark+2),a  
24c0 18 03			jr .pastdmark  
24c2 ..			.dmark: db "BNG"  
24c5 f1			.pastdmark: pop af  
24c6			endm  
# End of macro DMARK
24c6					CALLMONITOR 
24c6 cd 6f ee			call debug_vector  
24c9				endm  
# End of macro CALLMONITOR
24c9				endif 
24c9			 
24c9			.storebyteat:		 
24c9				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24c9 cd 72 1d			call macro_dsp_valuehl 
24cc				endm 
# End of macro FORTH_DSP_VALUEHL
24cc				 
24cc e5				push hl 
24cd			 
24cd				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24cd cd 2a 1e			call macro_forth_dsp_pop 
24d0				endm 
# End of macro FORTH_DSP_POP
24d0			 
24d0				; get byte to poke 
24d0			 
24d0				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24d0 cd 72 1d			call macro_dsp_valuehl 
24d3				endm 
# End of macro FORTH_DSP_VALUEHL
24d3 e5				push hl 
24d4			 
24d4			 
24d4				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24d4 cd 2a 1e			call macro_forth_dsp_pop 
24d7				endm 
# End of macro FORTH_DSP_POP
24d7			 
24d7			 
24d7 d1				pop de 
24d8 e1				pop hl 
24d9			 
24d9 73				ld (hl),e 
24da			 
24da			 
24da				NEXTW 
24da c3 28 1f			jp macro_next 
24dd				endm 
# End of macro NEXTW
24dd			.CBANG: 
24dd			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
24dd 22				db WORD_SYS_CORE+OPCODE_CBANG             
24de 06 25			dw .SCALL            
24e0 03				db 2 + 1 
24e1 .. 00			db "C!",0              
24e4				endm 
# End of macro CWHEAD
24e4			; | C!  ( x w -- ) Store x at address w  | DONE 
24e4				if DEBUG_FORTH_WORDS_KEY 
24e4					DMARK "CBA" 
24e4 f5				push af  
24e5 3a f9 24			ld a, (.dmark)  
24e8 32 6b ee			ld (debug_mark),a  
24eb 3a fa 24			ld a, (.dmark+1)  
24ee 32 6c ee			ld (debug_mark+1),a  
24f1 3a fb 24			ld a, (.dmark+2)  
24f4 32 6d ee			ld (debug_mark+2),a  
24f7 18 03			jr .pastdmark  
24f9 ..			.dmark: db "CBA"  
24fc f1			.pastdmark: pop af  
24fd			endm  
# End of macro DMARK
24fd					CALLMONITOR 
24fd cd 6f ee			call debug_vector  
2500				endm  
# End of macro CALLMONITOR
2500				endif 
2500 c3 c9 24			jp .storebyteat 
2503				NEXTW 
2503 c3 28 1f			jp macro_next 
2506				endm 
# End of macro NEXTW
2506			.SCALL: 
2506			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2506 23				db WORD_SYS_CORE+OPCODE_SCALL             
2507 3a 25			dw .DEPTH            
2509 05				db 4 + 1 
250a .. 00			db "CALL",0              
250f				endm 
# End of macro CWHEAD
250f			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
250f				if DEBUG_FORTH_WORDS_KEY 
250f					DMARK "CLL" 
250f f5				push af  
2510 3a 24 25			ld a, (.dmark)  
2513 32 6b ee			ld (debug_mark),a  
2516 3a 25 25			ld a, (.dmark+1)  
2519 32 6c ee			ld (debug_mark+1),a  
251c 3a 26 25			ld a, (.dmark+2)  
251f 32 6d ee			ld (debug_mark+2),a  
2522 18 03			jr .pastdmark  
2524 ..			.dmark: db "CLL"  
2527 f1			.pastdmark: pop af  
2528			endm  
# End of macro DMARK
2528					CALLMONITOR 
2528 cd 6f ee			call debug_vector  
252b				endm  
# End of macro CALLMONITOR
252b				endif 
252b			 
252b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
252b cd 72 1d			call macro_dsp_valuehl 
252e				endm 
# End of macro FORTH_DSP_VALUEHL
252e			 
252e			;		push hl 
252e			 
252e				; destroy value TOS 
252e			 
252e				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
252e cd 2a 1e			call macro_forth_dsp_pop 
2531				endm 
# End of macro FORTH_DSP_POP
2531			 
2531					 
2531			;		pop hl 
2531			 
2531				; how to do a call with hl???? save SP? 
2531 cd cc 1e			call forth_call_hl 
2534			 
2534			 
2534				; TODO push value back onto stack for another op etc 
2534			 
2534 cd 6d 1b			call forth_push_numhl 
2537				NEXTW 
2537 c3 28 1f			jp macro_next 
253a				endm 
# End of macro NEXTW
253a			.DEPTH: 
253a			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
253a 24				db WORD_SYS_CORE+OPCODE_DEPTH             
253b 77 25			dw .OVER            
253d 06				db 5 + 1 
253e .. 00			db "DEPTH",0              
2544				endm 
# End of macro CWHEAD
2544			; | DEPTH ( -- u ) Push count of stack | DONE 
2544				; take current TOS and remove from base value div by two to get count 
2544				if DEBUG_FORTH_WORDS_KEY 
2544					DMARK "DEP" 
2544 f5				push af  
2545 3a 59 25			ld a, (.dmark)  
2548 32 6b ee			ld (debug_mark),a  
254b 3a 5a 25			ld a, (.dmark+1)  
254e 32 6c ee			ld (debug_mark+1),a  
2551 3a 5b 25			ld a, (.dmark+2)  
2554 32 6d ee			ld (debug_mark+2),a  
2557 18 03			jr .pastdmark  
2559 ..			.dmark: db "DEP"  
255c f1			.pastdmark: pop af  
255d			endm  
# End of macro DMARK
255d					CALLMONITOR 
255d cd 6f ee			call debug_vector  
2560				endm  
# End of macro CALLMONITOR
2560				endif 
2560			 
2560			 
2560 2a ee e9		ld hl, (cli_data_sp) 
2563 11 28 e8		ld de, cli_data_stack 
2566 ed 52		sbc hl,de 
2568			 
2568			; div by size of stack item 
2568			 
2568 5d			ld e,l 
2569 0e 03		ld c, 3 
256b cd 76 0d		call Div8 
256e			 
256e 6f			ld l,a 
256f 26 00		ld h,0 
2571			 
2571			;srl h 
2571			;rr l 
2571			 
2571 cd 6d 1b			call forth_push_numhl 
2574				NEXTW 
2574 c3 28 1f			jp macro_next 
2577				endm 
# End of macro NEXTW
2577			.OVER: 
2577			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2577 42				db WORD_SYS_CORE+46             
2578 be 25			dw .PAUSE            
257a 05				db 4 + 1 
257b .. 00			db "OVER",0              
2580				endm 
# End of macro CWHEAD
2580			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2580				if DEBUG_FORTH_WORDS_KEY 
2580					DMARK "OVR" 
2580 f5				push af  
2581 3a 95 25			ld a, (.dmark)  
2584 32 6b ee			ld (debug_mark),a  
2587 3a 96 25			ld a, (.dmark+1)  
258a 32 6c ee			ld (debug_mark+1),a  
258d 3a 97 25			ld a, (.dmark+2)  
2590 32 6d ee			ld (debug_mark+2),a  
2593 18 03			jr .pastdmark  
2595 ..			.dmark: db "OVR"  
2598 f1			.pastdmark: pop af  
2599			endm  
# End of macro DMARK
2599					CALLMONITOR 
2599 cd 6f ee			call debug_vector  
259c				endm  
# End of macro CALLMONITOR
259c				endif 
259c			 
259c			; TODO Use os stack swap memory 
259c				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
259c cd 72 1d			call macro_dsp_valuehl 
259f				endm 
# End of macro FORTH_DSP_VALUEHL
259f e5				push hl    ; n2 
25a0				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25a0 cd 2a 1e			call macro_forth_dsp_pop 
25a3				endm 
# End of macro FORTH_DSP_POP
25a3			 
25a3				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25a3 cd 72 1d			call macro_dsp_valuehl 
25a6				endm 
# End of macro FORTH_DSP_VALUEHL
25a6 e5				push hl    ; n1 
25a7				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25a7 cd 2a 1e			call macro_forth_dsp_pop 
25aa				endm 
# End of macro FORTH_DSP_POP
25aa			 
25aa d1				pop de     ; n1 
25ab e1				pop hl     ; n2 
25ac			 
25ac d5				push de 
25ad e5				push hl 
25ae d5				push de 
25af			 
25af				; push back  
25af			 
25af e1				pop hl 
25b0 cd 6d 1b			call forth_push_numhl 
25b3 e1				pop hl 
25b4 cd 6d 1b			call forth_push_numhl 
25b7 e1				pop hl 
25b8 cd 6d 1b			call forth_push_numhl 
25bb				NEXTW 
25bb c3 28 1f			jp macro_next 
25be				endm 
# End of macro NEXTW
25be			 
25be			.PAUSE: 
25be			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
25be 43				db WORD_SYS_CORE+47             
25bf f3 25			dw .PAUSES            
25c1 08				db 7 + 1 
25c2 .. 00			db "PAUSEMS",0              
25ca				endm 
# End of macro CWHEAD
25ca			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
25ca				if DEBUG_FORTH_WORDS_KEY 
25ca					DMARK "PMS" 
25ca f5				push af  
25cb 3a df 25			ld a, (.dmark)  
25ce 32 6b ee			ld (debug_mark),a  
25d1 3a e0 25			ld a, (.dmark+1)  
25d4 32 6c ee			ld (debug_mark+1),a  
25d7 3a e1 25			ld a, (.dmark+2)  
25da 32 6d ee			ld (debug_mark+2),a  
25dd 18 03			jr .pastdmark  
25df ..			.dmark: db "PMS"  
25e2 f1			.pastdmark: pop af  
25e3			endm  
# End of macro DMARK
25e3					CALLMONITOR 
25e3 cd 6f ee			call debug_vector  
25e6				endm  
# End of macro CALLMONITOR
25e6				endif 
25e6				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25e6 cd 72 1d			call macro_dsp_valuehl 
25e9				endm 
# End of macro FORTH_DSP_VALUEHL
25e9			;		push hl    ; n2 
25e9				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25e9 cd 2a 1e			call macro_forth_dsp_pop 
25ec				endm 
# End of macro FORTH_DSP_POP
25ec			;		pop hl 
25ec			 
25ec 7d				ld a, l 
25ed cd d6 0a			call aDelayInMS 
25f0			       NEXTW 
25f0 c3 28 1f			jp macro_next 
25f3				endm 
# End of macro NEXTW
25f3			.PAUSES:  
25f3			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
25f3 44				db WORD_SYS_CORE+48             
25f4 62 26			dw .ROT            
25f6 06				db 5 + 1 
25f7 .. 00			db "PAUSE",0              
25fd				endm 
# End of macro CWHEAD
25fd			; | PAUSE ( n -- )  Pause for n seconds | DONE 
25fd				if DEBUG_FORTH_WORDS_KEY 
25fd					DMARK "PAU" 
25fd f5				push af  
25fe 3a 12 26			ld a, (.dmark)  
2601 32 6b ee			ld (debug_mark),a  
2604 3a 13 26			ld a, (.dmark+1)  
2607 32 6c ee			ld (debug_mark+1),a  
260a 3a 14 26			ld a, (.dmark+2)  
260d 32 6d ee			ld (debug_mark+2),a  
2610 18 03			jr .pastdmark  
2612 ..			.dmark: db "PAU"  
2615 f1			.pastdmark: pop af  
2616			endm  
# End of macro DMARK
2616					CALLMONITOR 
2616 cd 6f ee			call debug_vector  
2619				endm  
# End of macro CALLMONITOR
2619				endif 
2619				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2619 cd 72 1d			call macro_dsp_valuehl 
261c				endm 
# End of macro FORTH_DSP_VALUEHL
261c			;		push hl    ; n2 
261c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
261c cd 2a 1e			call macro_forth_dsp_pop 
261f				endm 
# End of macro FORTH_DSP_POP
261f			;		pop hl 
261f 45				ld b, l 
2620				if DEBUG_FORTH_WORDS 
2620					DMARK "PAU" 
2620 f5				push af  
2621 3a 35 26			ld a, (.dmark)  
2624 32 6b ee			ld (debug_mark),a  
2627 3a 36 26			ld a, (.dmark+1)  
262a 32 6c ee			ld (debug_mark+1),a  
262d 3a 37 26			ld a, (.dmark+2)  
2630 32 6d ee			ld (debug_mark+2),a  
2633 18 03			jr .pastdmark  
2635 ..			.dmark: db "PAU"  
2638 f1			.pastdmark: pop af  
2639			endm  
# End of macro DMARK
2639					CALLMONITOR 
2639 cd 6f ee			call debug_vector  
263c				endm  
# End of macro CALLMONITOR
263c				endif 
263c c5			.pauses1:	push bc 
263d cd f1 0a			call delay1s 
2640 c1				pop bc 
2641				if DEBUG_FORTH_WORDS 
2641					DMARK "PA1" 
2641 f5				push af  
2642 3a 56 26			ld a, (.dmark)  
2645 32 6b ee			ld (debug_mark),a  
2648 3a 57 26			ld a, (.dmark+1)  
264b 32 6c ee			ld (debug_mark+1),a  
264e 3a 58 26			ld a, (.dmark+2)  
2651 32 6d ee			ld (debug_mark+2),a  
2654 18 03			jr .pastdmark  
2656 ..			.dmark: db "PA1"  
2659 f1			.pastdmark: pop af  
265a			endm  
# End of macro DMARK
265a					CALLMONITOR 
265a cd 6f ee			call debug_vector  
265d				endm  
# End of macro CALLMONITOR
265d				endif 
265d 10 dd			djnz .pauses1 
265f			 
265f			       NEXTW 
265f c3 28 1f			jp macro_next 
2662				endm 
# End of macro NEXTW
2662			.ROT: 
2662			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2662 45				db WORD_SYS_CORE+49             
2663 b0 26			dw .UWORDS            
2665 04				db 3 + 1 
2666 .. 00			db "ROT",0              
266a				endm 
# End of macro CWHEAD
266a			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
266a				if DEBUG_FORTH_WORDS_KEY 
266a					DMARK "ROT" 
266a f5				push af  
266b 3a 7f 26			ld a, (.dmark)  
266e 32 6b ee			ld (debug_mark),a  
2671 3a 80 26			ld a, (.dmark+1)  
2674 32 6c ee			ld (debug_mark+1),a  
2677 3a 81 26			ld a, (.dmark+2)  
267a 32 6d ee			ld (debug_mark+2),a  
267d 18 03			jr .pastdmark  
267f ..			.dmark: db "ROT"  
2682 f1			.pastdmark: pop af  
2683			endm  
# End of macro DMARK
2683					CALLMONITOR 
2683 cd 6f ee			call debug_vector  
2686				endm  
# End of macro CALLMONITOR
2686				endif 
2686			 
2686			; TODO Use os stack swap memory 
2686				FORTH_DSP_VALUEHL 
2686 cd 72 1d			call macro_dsp_valuehl 
2689				endm 
# End of macro FORTH_DSP_VALUEHL
2689 e5				push hl    ; u3  
268a			 
268a				FORTH_DSP_POP 
268a cd 2a 1e			call macro_forth_dsp_pop 
268d				endm 
# End of macro FORTH_DSP_POP
268d			 
268d				FORTH_DSP_VALUEHL 
268d cd 72 1d			call macro_dsp_valuehl 
2690				endm 
# End of macro FORTH_DSP_VALUEHL
2690 e5				push hl     ; u2 
2691			 
2691				FORTH_DSP_POP 
2691 cd 2a 1e			call macro_forth_dsp_pop 
2694				endm 
# End of macro FORTH_DSP_POP
2694			 
2694				FORTH_DSP_VALUEHL 
2694 cd 72 1d			call macro_dsp_valuehl 
2697				endm 
# End of macro FORTH_DSP_VALUEHL
2697 e5				push hl     ; u1 
2698			 
2698				FORTH_DSP_POP 
2698 cd 2a 1e			call macro_forth_dsp_pop 
269b				endm 
# End of macro FORTH_DSP_POP
269b			 
269b c1				pop bc      ; u1 
269c e1				pop hl      ; u2 
269d d1				pop de      ; u3 
269e			 
269e			 
269e c5				push bc 
269f d5				push de 
26a0 e5				push hl 
26a1			 
26a1			 
26a1 e1				pop hl 
26a2 cd 6d 1b			call forth_push_numhl 
26a5			 
26a5 e1				pop hl 
26a6 cd 6d 1b			call forth_push_numhl 
26a9			 
26a9 e1				pop hl 
26aa cd 6d 1b			call forth_push_numhl 
26ad				 
26ad			 
26ad			 
26ad			 
26ad			 
26ad			 
26ad			       NEXTW 
26ad c3 28 1f			jp macro_next 
26b0				endm 
# End of macro NEXTW
26b0			 
26b0			.UWORDS: 
26b0			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
26b0 50				db WORD_SYS_CORE+60             
26b1 72 27			dw .BP            
26b3 07				db 6 + 1 
26b4 .. 00			db "UWORDS",0              
26bb				endm 
# End of macro CWHEAD
26bb			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
26bb			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
26bb			; | | Following the count are the individual words. 
26bb			; | | 
26bb			; | | e.g. UWORDS 
26bb			; | | BOX DIRLIST 2 
26bb			; | |  
26bb			; | | Can be used to save the words to storage via: 
26bb			; | | UWORDS $01 DO $01 APPEND LOOP 
26bb			if DEBUG_FORTH_WORDS_KEY 
26bb				DMARK "UWR" 
26bb f5				push af  
26bc 3a d0 26			ld a, (.dmark)  
26bf 32 6b ee			ld (debug_mark),a  
26c2 3a d1 26			ld a, (.dmark+1)  
26c5 32 6c ee			ld (debug_mark+1),a  
26c8 3a d2 26			ld a, (.dmark+2)  
26cb 32 6d ee			ld (debug_mark+2),a  
26ce 18 03			jr .pastdmark  
26d0 ..			.dmark: db "UWR"  
26d3 f1			.pastdmark: pop af  
26d4			endm  
# End of macro DMARK
26d4				CALLMONITOR 
26d4 cd 6f ee			call debug_vector  
26d7				endm  
# End of macro CALLMONITOR
26d7			endif 
26d7 21 74 5e			ld hl, baseram 
26da				;ld hl, baseusermem 
26da 01 00 00			ld bc, 0    ; start a counter 
26dd			 
26dd			; skip dict stub 
26dd			 
26dd cd 79 20			call forth_tok_next 
26e0			 
26e0			 
26e0			; while we have words to look for 
26e0			 
26e0 7e			.douscan:	ld a, (hl)      
26e1			if DEBUG_FORTH_WORDS 
26e1				DMARK "UWs" 
26e1 f5				push af  
26e2 3a f6 26			ld a, (.dmark)  
26e5 32 6b ee			ld (debug_mark),a  
26e8 3a f7 26			ld a, (.dmark+1)  
26eb 32 6c ee			ld (debug_mark+1),a  
26ee 3a f8 26			ld a, (.dmark+2)  
26f1 32 6d ee			ld (debug_mark+2),a  
26f4 18 03			jr .pastdmark  
26f6 ..			.dmark: db "UWs"  
26f9 f1			.pastdmark: pop af  
26fa			endm  
# End of macro DMARK
26fa				CALLMONITOR 
26fa cd 6f ee			call debug_vector  
26fd				endm  
# End of macro CALLMONITOR
26fd			endif 
26fd fe 00			cp WORD_SYS_END 
26ff 28 4d			jr z, .udone 
2701 fe 01			cp WORD_SYS_UWORD 
2703 20 44			jr nz, .nuword 
2705			 
2705			if DEBUG_FORTH_WORDS 
2705				DMARK "UWu" 
2705 f5				push af  
2706 3a 1a 27			ld a, (.dmark)  
2709 32 6b ee			ld (debug_mark),a  
270c 3a 1b 27			ld a, (.dmark+1)  
270f 32 6c ee			ld (debug_mark+1),a  
2712 3a 1c 27			ld a, (.dmark+2)  
2715 32 6d ee			ld (debug_mark+2),a  
2718 18 03			jr .pastdmark  
271a ..			.dmark: db "UWu"  
271d f1			.pastdmark: pop af  
271e			endm  
# End of macro DMARK
271e				CALLMONITOR 
271e cd 6f ee			call debug_vector  
2721				endm  
# End of macro CALLMONITOR
2721			endif 
2721				; we have a uword so push its name to the stack 
2721			 
2721 e5				push hl  ; save so we can move to next dict block 
2722			 
2722				; skip opcode 
2722 23				inc hl  
2723				; skip next ptr 
2723 23				inc hl  
2724 23				inc hl 
2725				; skip len 
2725 23				inc hl 
2726			if DEBUG_FORTH_WORDS 
2726				DMARK "UWt" 
2726 f5				push af  
2727 3a 3b 27			ld a, (.dmark)  
272a 32 6b ee			ld (debug_mark),a  
272d 3a 3c 27			ld a, (.dmark+1)  
2730 32 6c ee			ld (debug_mark+1),a  
2733 3a 3d 27			ld a, (.dmark+2)  
2736 32 6d ee			ld (debug_mark+2),a  
2739 18 03			jr .pastdmark  
273b ..			.dmark: db "UWt"  
273e f1			.pastdmark: pop af  
273f			endm  
# End of macro DMARK
273f				CALLMONITOR 
273f cd 6f ee			call debug_vector  
2742				endm  
# End of macro CALLMONITOR
2742			endif 
2742 03				inc bc 
2743			 
2743 c5				push bc 
2744 cd db 1b			call forth_push_str 
2747 c1				pop bc 
2748			 
2748 e1				pop hl 	 
2749			 
2749 cd 79 20		.nuword:	call forth_tok_next 
274c 18 92			jr .douscan  
274e			 
274e			.udone:		 ; push count of uwords found 
274e c5				push bc 
274f e1				pop hl 
2750			 
2750			if DEBUG_FORTH_WORDS 
2750				DMARK "UWc" 
2750 f5				push af  
2751 3a 65 27			ld a, (.dmark)  
2754 32 6b ee			ld (debug_mark),a  
2757 3a 66 27			ld a, (.dmark+1)  
275a 32 6c ee			ld (debug_mark+1),a  
275d 3a 67 27			ld a, (.dmark+2)  
2760 32 6d ee			ld (debug_mark+2),a  
2763 18 03			jr .pastdmark  
2765 ..			.dmark: db "UWc"  
2768 f1			.pastdmark: pop af  
2769			endm  
# End of macro DMARK
2769				CALLMONITOR 
2769 cd 6f ee			call debug_vector  
276c				endm  
# End of macro CALLMONITOR
276c			endif 
276c cd 6d 1b			call forth_push_numhl 
276f			 
276f			 
276f			       NEXTW 
276f c3 28 1f			jp macro_next 
2772				endm 
# End of macro NEXTW
2772			 
2772			.BP: 
2772			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2772 54				db WORD_SYS_CORE+64             
2773 ac 27			dw .MONITOR            
2775 03				db 2 + 1 
2776 .. 00			db "BP",0              
2779				endm 
# End of macro CWHEAD
2779			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2779			; | | $00 Will enable the break points within specific code paths 
2779			; | | $01 Will disable break points 
2779			; | |  
2779			; | | By default break points are off. Either the above can be used to enable them 
2779			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2779			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2779			; | | can disable break points. Exiting will then continue boot process. 
2779				; get byte count 
2779				if DEBUG_FORTH_WORDS_KEY 
2779					DMARK "BP." 
2779 f5				push af  
277a 3a 8e 27			ld a, (.dmark)  
277d 32 6b ee			ld (debug_mark),a  
2780 3a 8f 27			ld a, (.dmark+1)  
2783 32 6c ee			ld (debug_mark+1),a  
2786 3a 90 27			ld a, (.dmark+2)  
2789 32 6d ee			ld (debug_mark+2),a  
278c 18 03			jr .pastdmark  
278e ..			.dmark: db "BP."  
2791 f1			.pastdmark: pop af  
2792			endm  
# End of macro DMARK
2792					CALLMONITOR 
2792 cd 6f ee			call debug_vector  
2795				endm  
# End of macro CALLMONITOR
2795				endif 
2795			 
2795				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2795 cd 72 1d			call macro_dsp_valuehl 
2798				endm 
# End of macro FORTH_DSP_VALUEHL
2798			 
2798			;		push hl 
2798			 
2798				; destroy value TOS 
2798			 
2798				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2798 cd 2a 1e			call macro_forth_dsp_pop 
279b				endm 
# End of macro FORTH_DSP_POP
279b			 
279b			;		pop hl 
279b			 
279b 3e 00			ld a,0 
279d bd				cp l 
279e 28 06			jr z, .bpset 
27a0			;		ld a, '*' 
27a0 cd fc 14			call bp_off 
27a3				NEXTW 
27a3 c3 28 1f			jp macro_next 
27a6				endm 
# End of macro NEXTW
27a6			 
27a6			.bpset:	 
27a6				;	ld (os_view_disable), a 
27a6 cd f0 14			call bp_on 
27a9			 
27a9			 
27a9				NEXTW 
27a9 c3 28 1f			jp macro_next 
27ac				endm 
# End of macro NEXTW
27ac			 
27ac			 
27ac			.MONITOR: 
27ac			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
27ac 55				db WORD_SYS_CORE+65             
27ad dd 27			dw .MALLOC            
27af 08				db 7 + 1 
27b0 .. 00			db "MONITOR",0              
27b8				endm 
# End of macro CWHEAD
27b8			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
27b8			; | | At start the current various registers will be displayed with contents. 
27b8			; | | Top right corner will show the most recent debug marker seen. 
27b8			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
27b8			; | | and the return stack pointer (RSP). 
27b8			; | | Pressing: 
27b8			; | |    1 - Initial screen 
27b8			; | |    2 - Display a data dump of HL 
27b8			; | |    3 - Display a data dump of DE 
27b8			; | |    4 - Display a data dump of BC 
27b8			; | |    5 - Display a data dump of HL 
27b8			; | |    6 - Display a data dump of DSP 
27b8			; | |    7 - Display a data dump of RSP 
27b8			; | |    8 - Display a data dump of what is at DSP 
27b8			; | |    9 - Display a data dump of what is at RSP 
27b8			; | |    0 - Exit monitor and continue running. This will also enable break points 
27b8			; | |    * - Disable break points 
27b8			; | |    # - Enter traditional monitor mode 
27b8			; | | 
27b8			; | | Monitor Mode 
27b8			; | | ------------ 
27b8			; | | A prompt of '>' will be shown for various commands: 
27b8			; | |    D xxxx - Display a data dump starting from hex address xxxx 
27b8			; | |    C - Continue display a data dump from the last set address 
27b8			; | |    M xxxx - Set start of memory edit at address xx 
27b8			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
27b8			; | |    G xxxx - Exec code at specific address 
27b8			; | |    Q - Return to previous 
27b8				if DEBUG_FORTH_WORDS_KEY 
27b8					DMARK "MON" 
27b8 f5				push af  
27b9 3a cd 27			ld a, (.dmark)  
27bc 32 6b ee			ld (debug_mark),a  
27bf 3a ce 27			ld a, (.dmark+1)  
27c2 32 6c ee			ld (debug_mark+1),a  
27c5 3a cf 27			ld a, (.dmark+2)  
27c8 32 6d ee			ld (debug_mark+2),a  
27cb 18 03			jr .pastdmark  
27cd ..			.dmark: db "MON"  
27d0 f1			.pastdmark: pop af  
27d1			endm  
# End of macro DMARK
27d1					CALLMONITOR 
27d1 cd 6f ee			call debug_vector  
27d4				endm  
# End of macro CALLMONITOR
27d4				endif 
27d4			;		ld a, 0 
27d4			;		ld (os_view_disable), a 
27d4 cd f0 14			call bp_on 
27d7			 
27d7				CALLMONITOR 
27d7 cd 6f ee			call debug_vector  
27da				endm  
# End of macro CALLMONITOR
27da			 
27da			;	call monitor 
27da			 
27da				NEXTW 
27da c3 28 1f			jp macro_next 
27dd				endm 
# End of macro NEXTW
27dd			 
27dd			 
27dd			.MALLOC: 
27dd			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
27dd 56				db WORD_SYS_CORE+66             
27de 06 28			dw .MALLOC2            
27e0 06				db 5 + 1 
27e1 .. 00			db "ALLOT",0              
27e7				endm 
# End of macro CWHEAD
27e7			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
27e7				if DEBUG_FORTH_WORDS_KEY 
27e7					DMARK "ALL" 
27e7 f5				push af  
27e8 3a fc 27			ld a, (.dmark)  
27eb 32 6b ee			ld (debug_mark),a  
27ee 3a fd 27			ld a, (.dmark+1)  
27f1 32 6c ee			ld (debug_mark+1),a  
27f4 3a fe 27			ld a, (.dmark+2)  
27f7 32 6d ee			ld (debug_mark+2),a  
27fa 18 03			jr .pastdmark  
27fc ..			.dmark: db "ALL"  
27ff f1			.pastdmark: pop af  
2800			endm  
# End of macro DMARK
2800					CALLMONITOR 
2800 cd 6f ee			call debug_vector  
2803				endm  
# End of macro CALLMONITOR
2803				endif 
2803 c3 2d 28			jp .mallocc 
2806			.MALLOC2: 
2806			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2806 56				db WORD_SYS_CORE+66             
2807 44 28			dw .FREE            
2809 07				db 6 + 1 
280a .. 00			db "MALLOC",0              
2811				endm 
# End of macro CWHEAD
2811			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2811				; get byte count 
2811				if DEBUG_FORTH_WORDS_KEY 
2811					DMARK "MAL" 
2811 f5				push af  
2812 3a 26 28			ld a, (.dmark)  
2815 32 6b ee			ld (debug_mark),a  
2818 3a 27 28			ld a, (.dmark+1)  
281b 32 6c ee			ld (debug_mark+1),a  
281e 3a 28 28			ld a, (.dmark+2)  
2821 32 6d ee			ld (debug_mark+2),a  
2824 18 03			jr .pastdmark  
2826 ..			.dmark: db "MAL"  
2829 f1			.pastdmark: pop af  
282a			endm  
# End of macro DMARK
282a					CALLMONITOR 
282a cd 6f ee			call debug_vector  
282d				endm  
# End of macro CALLMONITOR
282d				endif 
282d			.mallocc: 
282d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
282d cd 72 1d			call macro_dsp_valuehl 
2830				endm 
# End of macro FORTH_DSP_VALUEHL
2830			 
2830			;		push hl 
2830			 
2830				; destroy value TOS 
2830			 
2830				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2830 cd 2a 1e			call macro_forth_dsp_pop 
2833				endm 
# End of macro FORTH_DSP_POP
2833			 
2833			;		pop hl 
2833 cd c1 11			call malloc 
2836			if DEBUG_FORTH_MALLOC_GUARD 
2836 f5				push af 
2837 cd 0f 0e			call ishlzero 
283a			;		ld a, l 
283a			;		add h 
283a			;		cp 0 
283a f1				pop af 
283b				 
283b cc e8 4c			call z,malloc_error 
283e			endif 
283e			 
283e cd 6d 1b			call forth_push_numhl 
2841				NEXTW 
2841 c3 28 1f			jp macro_next 
2844				endm 
# End of macro NEXTW
2844			 
2844			.FREE: 
2844			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2844 57				db WORD_SYS_CORE+67             
2845 75 28			dw .LIST            
2847 05				db 4 + 1 
2848 .. 00			db "FREE",0              
284d				endm 
# End of macro CWHEAD
284d			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
284d				if DEBUG_FORTH_WORDS_KEY 
284d					DMARK "FRE" 
284d f5				push af  
284e 3a 62 28			ld a, (.dmark)  
2851 32 6b ee			ld (debug_mark),a  
2854 3a 63 28			ld a, (.dmark+1)  
2857 32 6c ee			ld (debug_mark+1),a  
285a 3a 64 28			ld a, (.dmark+2)  
285d 32 6d ee			ld (debug_mark+2),a  
2860 18 03			jr .pastdmark  
2862 ..			.dmark: db "FRE"  
2865 f1			.pastdmark: pop af  
2866			endm  
# End of macro DMARK
2866					CALLMONITOR 
2866 cd 6f ee			call debug_vector  
2869				endm  
# End of macro CALLMONITOR
2869				endif 
2869				; get address 
2869			 
2869				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2869 cd 72 1d			call macro_dsp_valuehl 
286c				endm 
# End of macro FORTH_DSP_VALUEHL
286c			 
286c			;		push hl 
286c			 
286c				; destroy value TOS 
286c			 
286c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
286c cd 2a 1e			call macro_forth_dsp_pop 
286f				endm 
# End of macro FORTH_DSP_POP
286f			 
286f			;		pop hl 
286f			if FORTH_ENABLE_MALLOCFREE 
286f cd 8b 12			call free 
2872			endif 
2872				NEXTW 
2872 c3 28 1f			jp macro_next 
2875				endm 
# End of macro NEXTW
2875			.LIST: 
2875			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2875 5c				db WORD_SYS_CORE+72             
2876 65 2a			dw .FORGET            
2878 05				db 4 + 1 
2879 .. 00			db "LIST",0              
287e				endm 
# End of macro CWHEAD
287e			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
287e			; | | The quoted word must be in upper case. 
287e			if DEBUG_FORTH_WORDS_KEY 
287e				DMARK "LST" 
287e f5				push af  
287f 3a 93 28			ld a, (.dmark)  
2882 32 6b ee			ld (debug_mark),a  
2885 3a 94 28			ld a, (.dmark+1)  
2888 32 6c ee			ld (debug_mark+1),a  
288b 3a 95 28			ld a, (.dmark+2)  
288e 32 6d ee			ld (debug_mark+2),a  
2891 18 03			jr .pastdmark  
2893 ..			.dmark: db "LST"  
2896 f1			.pastdmark: pop af  
2897			endm  
# End of macro DMARK
2897				CALLMONITOR 
2897 cd 6f ee			call debug_vector  
289a				endm  
# End of macro CALLMONITOR
289a			endif 
289a			 
289a				FORTH_DSP_VALUEHL 
289a cd 72 1d			call macro_dsp_valuehl 
289d				endm 
# End of macro FORTH_DSP_VALUEHL
289d			 
289d e5				push hl 
289e				FORTH_DSP_POP 
289e cd 2a 1e			call macro_forth_dsp_pop 
28a1				endm 
# End of macro FORTH_DSP_POP
28a1 c1				pop bc 
28a2			 
28a2			; Start format of scratch string 
28a2			 
28a2 21 c1 e2			ld hl, scratch 
28a5			 
28a5 3e 3a			ld a, ':' 
28a7 77				ld (hl),a 
28a8 23				inc hl 
28a9 3e 20			ld a, ' ' 
28ab 77				ld (hl), a 
28ac			 
28ac				; Get ptr to the word we need to look up 
28ac			 
28ac			;		FORTH_DSP_VALUEHL 
28ac				;v5 FORTH_DSP_VALUE 
28ac			; TODO type check 
28ac			;		inc hl    ; Skip type check  
28ac			;		push hl 
28ac			;		ex de, hl    ; put into DE 
28ac			 
28ac			 
28ac 21 74 5e			ld hl, baseram 
28af				;ld hl, baseusermem 
28af			 
28af e5			push hl   ; sacreifical push 
28b0			 
28b0			.ldouscanm: 
28b0 e1			pop hl 
28b1			.ldouscan: 
28b1			if DEBUG_FORTH_WORDS 
28b1				DMARK "LSs" 
28b1 f5				push af  
28b2 3a c6 28			ld a, (.dmark)  
28b5 32 6b ee			ld (debug_mark),a  
28b8 3a c7 28			ld a, (.dmark+1)  
28bb 32 6c ee			ld (debug_mark+1),a  
28be 3a c8 28			ld a, (.dmark+2)  
28c1 32 6d ee			ld (debug_mark+2),a  
28c4 18 03			jr .pastdmark  
28c6 ..			.dmark: db "LSs"  
28c9 f1			.pastdmark: pop af  
28ca			endm  
# End of macro DMARK
28ca				CALLMONITOR 
28ca cd 6f ee			call debug_vector  
28cd				endm  
# End of macro CALLMONITOR
28cd			endif 
28cd			; skip dict stub 
28cd cd 79 20			call forth_tok_next 
28d0			 
28d0			 
28d0			; while we have words to look for 
28d0			 
28d0 7e			ld a, (hl)      
28d1			if DEBUG_FORTH_WORDS 
28d1				DMARK "LSk" 
28d1 f5				push af  
28d2 3a e6 28			ld a, (.dmark)  
28d5 32 6b ee			ld (debug_mark),a  
28d8 3a e7 28			ld a, (.dmark+1)  
28db 32 6c ee			ld (debug_mark+1),a  
28de 3a e8 28			ld a, (.dmark+2)  
28e1 32 6d ee			ld (debug_mark+2),a  
28e4 18 03			jr .pastdmark  
28e6 ..			.dmark: db "LSk"  
28e9 f1			.pastdmark: pop af  
28ea			endm  
# End of macro DMARK
28ea				CALLMONITOR 
28ea cd 6f ee			call debug_vector  
28ed				endm  
# End of macro CALLMONITOR
28ed			endif 
28ed				;cp WORD_SYS_END 
28ed				;jp z, .lunotfound 
28ed			 
28ed					; if we hit non uwords then gone too far 
28ed fe 01				cp WORD_SYS_UWORD 
28ef c2 21 2a				jp nz, .lunotfound 
28f2			 
28f2				if DEBUG_FORTH_WORDS 
28f2					DMARK "LSu" 
28f2 f5				push af  
28f3 3a 07 29			ld a, (.dmark)  
28f6 32 6b ee			ld (debug_mark),a  
28f9 3a 08 29			ld a, (.dmark+1)  
28fc 32 6c ee			ld (debug_mark+1),a  
28ff 3a 09 29			ld a, (.dmark+2)  
2902 32 6d ee			ld (debug_mark+2),a  
2905 18 03			jr .pastdmark  
2907 ..			.dmark: db "LSu"  
290a f1			.pastdmark: pop af  
290b			endm  
# End of macro DMARK
290b					CALLMONITOR 
290b cd 6f ee			call debug_vector  
290e				endm  
# End of macro CALLMONITOR
290e				endif 
290e			 
290e					; found a uword but is it the one we want... 
290e			 
290e c5					push bc     ; uword to find is on bc 
290f d1					pop de 
2910			 
2910 e5					push hl  ; to save the ptr 
2911			 
2911					; skip opcode 
2911 23					inc hl  
2912					; skip next ptr 
2912 23					inc hl  
2913 23					inc hl 
2914					; skip len 
2914 23					inc hl 
2915			 
2915				if DEBUG_FORTH_WORDS 
2915					DMARK "LSc" 
2915 f5				push af  
2916 3a 2a 29			ld a, (.dmark)  
2919 32 6b ee			ld (debug_mark),a  
291c 3a 2b 29			ld a, (.dmark+1)  
291f 32 6c ee			ld (debug_mark+1),a  
2922 3a 2c 29			ld a, (.dmark+2)  
2925 32 6d ee			ld (debug_mark+2),a  
2928 18 03			jr .pastdmark  
292a ..			.dmark: db "LSc"  
292d f1			.pastdmark: pop af  
292e			endm  
# End of macro DMARK
292e					CALLMONITOR 
292e cd 6f ee			call debug_vector  
2931				endm  
# End of macro CALLMONITOR
2931				endif 
2931			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2931			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2931			; Nope that has gone the other way. It needs to be exact not on first zero 
2931			;		call strcmp 
2931 c5					push bc 
2932 cd 91 11				call StrictStrCmp 
2935 c1					pop bc 
2936 c2 b0 28				jp nz, .ldouscanm 
2939				 
2939			 
2939			 
2939					; we have a uword so push its name to the stack 
2939			 
2939			;	   	push hl  ; save so we can move to next dict block 
2939 e1			pop hl 
293a			 
293a				if DEBUG_FORTH_WORDS 
293a					DMARK "LSm" 
293a f5				push af  
293b 3a 4f 29			ld a, (.dmark)  
293e 32 6b ee			ld (debug_mark),a  
2941 3a 50 29			ld a, (.dmark+1)  
2944 32 6c ee			ld (debug_mark+1),a  
2947 3a 51 29			ld a, (.dmark+2)  
294a 32 6d ee			ld (debug_mark+2),a  
294d 18 03			jr .pastdmark  
294f ..			.dmark: db "LSm"  
2952 f1			.pastdmark: pop af  
2953			endm  
# End of macro DMARK
2953					CALLMONITOR 
2953 cd 6f ee			call debug_vector  
2956				endm  
# End of macro CALLMONITOR
2956				endif 
2956			 
2956					; skip opcode 
2956 23					inc hl  
2957					; skip next ptr 
2957 23					inc hl  
2958 23					inc hl 
2959					; skip len 
2959 7e					ld a, (hl)   ; save length to add 
295a				if DEBUG_FORTH_WORDS 
295a					DMARK "LS2" 
295a f5				push af  
295b 3a 6f 29			ld a, (.dmark)  
295e 32 6b ee			ld (debug_mark),a  
2961 3a 70 29			ld a, (.dmark+1)  
2964 32 6c ee			ld (debug_mark+1),a  
2967 3a 71 29			ld a, (.dmark+2)  
296a 32 6d ee			ld (debug_mark+2),a  
296d 18 03			jr .pastdmark  
296f ..			.dmark: db "LS2"  
2972 f1			.pastdmark: pop af  
2973			endm  
# End of macro DMARK
2973					CALLMONITOR 
2973 cd 6f ee			call debug_vector  
2976				endm  
# End of macro CALLMONITOR
2976				endif 
2976			 
2976					; save this location 
2976				 
2976 e5					push hl 
2977			 
2977 23					inc hl 
2978 11 c3 e2				ld de, scratch+2 
297b 4f					ld c, a 
297c 06 00				ld b, 0 
297e			 
297e				if DEBUG_FORTH_WORDS 
297e					DMARK "LSn" 
297e f5				push af  
297f 3a 93 29			ld a, (.dmark)  
2982 32 6b ee			ld (debug_mark),a  
2985 3a 94 29			ld a, (.dmark+1)  
2988 32 6c ee			ld (debug_mark+1),a  
298b 3a 95 29			ld a, (.dmark+2)  
298e 32 6d ee			ld (debug_mark+2),a  
2991 18 03			jr .pastdmark  
2993 ..			.dmark: db "LSn"  
2996 f1			.pastdmark: pop af  
2997			endm  
# End of macro DMARK
2997					CALLMONITOR 
2997 cd 6f ee			call debug_vector  
299a				endm  
# End of macro CALLMONITOR
299a				endif 
299a			 
299a					; copy uword name to scratch 
299a			 
299a ed b0				ldir 
299c			 
299c 1b					dec de 
299d 3e 20				ld a, ' '    ; change null to space 
299f 12					ld (de), a 
29a0			 
29a0 13					inc de 
29a1			 
29a1 d5					push de 
29a2 c1					pop bc     ; move scratch pointer to end of word name and save it 
29a3			 
29a3 e1					pop hl 
29a4 7e					ld a, (hl) 
29a5					;inc hl 
29a5					; skip word string 
29a5 cd e6 0d				call addatohl 
29a8			 
29a8 23					inc hl 
29a9			 
29a9				if DEBUG_FORTH_WORDS 
29a9					DMARK "LS3" 
29a9 f5				push af  
29aa 3a be 29			ld a, (.dmark)  
29ad 32 6b ee			ld (debug_mark),a  
29b0 3a bf 29			ld a, (.dmark+1)  
29b3 32 6c ee			ld (debug_mark+1),a  
29b6 3a c0 29			ld a, (.dmark+2)  
29b9 32 6d ee			ld (debug_mark+2),a  
29bc 18 03			jr .pastdmark  
29be ..			.dmark: db "LS3"  
29c1 f1			.pastdmark: pop af  
29c2			endm  
# End of macro DMARK
29c2					CALLMONITOR 
29c2 cd 6f ee			call debug_vector  
29c5				endm  
# End of macro CALLMONITOR
29c5				endif 
29c5					; should now be at the start of the machine code to setup the eval of the uword 
29c5					; now locate the ptr to the string defintion 
29c5			 
29c5					; skip ld hl, 
29c5					; then load the ptr 
29c5			; TODO use get from hl ptr 
29c5 23					inc hl 
29c6 5e					ld e, (hl) 
29c7 23					inc hl 
29c8 56					ld d, (hl) 
29c9 eb					ex de, hl 
29ca			 
29ca			 
29ca				if DEBUG_FORTH_WORDS 
29ca					DMARK "LSt" 
29ca f5				push af  
29cb 3a df 29			ld a, (.dmark)  
29ce 32 6b ee			ld (debug_mark),a  
29d1 3a e0 29			ld a, (.dmark+1)  
29d4 32 6c ee			ld (debug_mark+1),a  
29d7 3a e1 29			ld a, (.dmark+2)  
29da 32 6d ee			ld (debug_mark+2),a  
29dd 18 03			jr .pastdmark  
29df ..			.dmark: db "LSt"  
29e2 f1			.pastdmark: pop af  
29e3			endm  
# End of macro DMARK
29e3					CALLMONITOR 
29e3 cd 6f ee			call debug_vector  
29e6				endm  
# End of macro CALLMONITOR
29e6				endif 
29e6			 
29e6			; cant push right now due to tokenised strings  
29e6			 
29e6			; get the destination of where to copy this definition to. 
29e6			 
29e6 c5					push bc 
29e7 d1					pop de 
29e8			 
29e8 7e			.listl:         ld a,(hl) 
29e9 fe 00				cp 0 
29eb 28 09				jr z, .lreplsp     ; replace zero with space 
29ed					;cp FORTH_END_BUFFER 
29ed fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
29ef 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
29f1				 
29f1					; just copy this char as is then 
29f1			 
29f1 12					ld (de), a 
29f2			 
29f2 23			.listnxt:	inc hl 
29f3 13					inc de 
29f4 18 f2				jr .listl 
29f6			 
29f6 3e 20		.lreplsp:	ld a,' ' 
29f8 12					ld (de), a 
29f9 18 f7				jr .listnxt 
29fb			 
29fb			; close up uword def 
29fb			 
29fb			.listdone: 
29fb 12					ld (de), a 
29fc 13					inc de 
29fd 3e 00				ld a, 0 
29ff 12					ld (de), a 
2a00			 
2a00			; now have def so clean up and push to stack 
2a00			 
2a00 21 c1 e2				ld hl, scratch 
2a03				if DEBUG_FORTH_WORDS 
2a03					DMARK "Ltp" 
2a03 f5				push af  
2a04 3a 18 2a			ld a, (.dmark)  
2a07 32 6b ee			ld (debug_mark),a  
2a0a 3a 19 2a			ld a, (.dmark+1)  
2a0d 32 6c ee			ld (debug_mark+1),a  
2a10 3a 1a 2a			ld a, (.dmark+2)  
2a13 32 6d ee			ld (debug_mark+2),a  
2a16 18 03			jr .pastdmark  
2a18 ..			.dmark: db "Ltp"  
2a1b f1			.pastdmark: pop af  
2a1c			endm  
# End of macro DMARK
2a1c					CALLMONITOR 
2a1c cd 6f ee			call debug_vector  
2a1f				endm  
# End of macro CALLMONITOR
2a1f				endif 
2a1f			 
2a1f 18 1f			jr .listpush 
2a21			 
2a21			;.lnuword:	pop hl 
2a21			;		call forth_tok_next 
2a21			;		jp .ldouscan  
2a21			 
2a21			.lunotfound:		  
2a21			 
2a21				if DEBUG_FORTH_WORDS 
2a21					DMARK "LSn" 
2a21 f5				push af  
2a22 3a 36 2a			ld a, (.dmark)  
2a25 32 6b ee			ld (debug_mark),a  
2a28 3a 37 2a			ld a, (.dmark+1)  
2a2b 32 6c ee			ld (debug_mark+1),a  
2a2e 3a 38 2a			ld a, (.dmark+2)  
2a31 32 6d ee			ld (debug_mark+2),a  
2a34 18 03			jr .pastdmark  
2a36 ..			.dmark: db "LSn"  
2a39 f1			.pastdmark: pop af  
2a3a			endm  
# End of macro DMARK
2a3a					CALLMONITOR 
2a3a cd 6f ee			call debug_vector  
2a3d				endm  
# End of macro CALLMONITOR
2a3d				endif 
2a3d			 
2a3d					 
2a3d			;		FORTH_DSP_POP 
2a3d			;		ld hl, .luno 
2a3d			 
2a3d					NEXTW			 
2a3d c3 28 1f			jp macro_next 
2a40				endm 
# End of macro NEXTW
2a40			 
2a40			.listpush: 
2a40				if DEBUG_FORTH_WORDS 
2a40					DMARK "LS>" 
2a40 f5				push af  
2a41 3a 55 2a			ld a, (.dmark)  
2a44 32 6b ee			ld (debug_mark),a  
2a47 3a 56 2a			ld a, (.dmark+1)  
2a4a 32 6c ee			ld (debug_mark+1),a  
2a4d 3a 57 2a			ld a, (.dmark+2)  
2a50 32 6d ee			ld (debug_mark+2),a  
2a53 18 03			jr .pastdmark  
2a55 ..			.dmark: db "LS>"  
2a58 f1			.pastdmark: pop af  
2a59			endm  
# End of macro DMARK
2a59					CALLMONITOR 
2a59 cd 6f ee			call debug_vector  
2a5c				endm  
# End of macro CALLMONITOR
2a5c				endif 
2a5c cd db 1b				call forth_push_str 
2a5f			 
2a5f			 
2a5f			 
2a5f					NEXTW 
2a5f c3 28 1f			jp macro_next 
2a62				endm 
# End of macro NEXTW
2a62			 
2a62			;.luno:    db "Word not found",0 
2a62			 
2a62			 
2a62			 
2a62			 
2a62			 
2a62			;		push hl   ; save pointer to start of uword def string 
2a62			; 
2a62			;; look for FORTH_EOL_LINE 
2a62			;		ld a, FORTH_END_BUFFER 
2a62			;		call strlent 
2a62			; 
2a62			;		inc hl		 ; space for coln def 
2a62			;		inc hl 
2a62			;		inc hl          ; space for terms 
2a62			;		inc hl 
2a62			; 
2a62			;		ld a, 20   ; TODO get actual length 
2a62			;		call addatohl    ; include a random amount of room for the uword name 
2a62			; 
2a62			;		 
2a62			;	if DEBUG_FORTH_WORDS 
2a62			;		DMARK "Lt1" 
2a62			;		CALLMONITOR 
2a62			;	endif 
2a62			;		 
2a62			; 
2a62			;; malloc space for the string because we cant change it 
2a62			; 
2a62			;		call malloc 
2a62			;	if DEBUG_FORTH_MALLOC_GUARD 
2a62			;		push af 
2a62			;		call ishlzero 
2a62			;		pop af 
2a62			;		 
2a62			;		call z,malloc_error 
2a62			;	endif 
2a62			; 
2a62			;	if DEBUG_FORTH_WORDS 
2a62			;		DMARK "Lt2" 
2a62			;		CALLMONITOR 
2a62			;	endif 
2a62			;		pop de 
2a62			;		push hl    ; push the malloc to release later 
2a62			;		push hl   ;  push back a copy for the later stack push 
2a62			;		 
2a62			;; copy the string swapping out the zero terms for spaces 
2a62			; 
2a62			;		; de has our source 
2a62			;		; hl has our dest 
2a62			; 
2a62			;; add the coln def 
2a62			; 
2a62			;		ld a, ':' 
2a62			;		ld (hl), a 
2a62			;		inc hl 
2a62			;		ld a, ' ' 
2a62			;		ld (hl), a 
2a62			;		inc hl 
2a62			; 
2a62			;; add the uname word 
2a62			;		push de   ; save our string for now 
2a62			;		ex de, hl 
2a62			; 
2a62			;		FORTH_DSP_VALUE 
2a62			;		;v5 FORTH_DSP_VALUE 
2a62			; 
2a62			;		inc hl   ; skip type but we know by now this is OK 
2a62			; 
2a62			;.luword:	ld a,(hl) 
2a62			;		cp 0 
2a62			;		jr z, .luword2 
2a62			;		ld (de), a 
2a62			;		inc de 
2a62			;		inc hl 
2a62			;		jr .luword 
2a62			; 
2a62			;.luword2:	ld a, ' ' 
2a62			;		ld (de), a 
2a62			;;		inc hl 
2a62			;;		inc de 
2a62			;;		ld (de), a 
2a62			;;		inc hl 
2a62			;		inc de 
2a62			; 
2a62			;		ex de, hl 
2a62			;		pop de 
2a62			;		 
2a62			;		 
2a62			; 
2a62			;; detoken that string and copy it 
2a62			; 
2a62			;	if DEBUG_FORTH_WORDS 
2a62			;		DMARK "Lt2" 
2a62			;		CALLMONITOR 
2a62			;	endif 
2a62			;.ldetok:	ld a, (de) 
2a62			;		cp FORTH_END_BUFFER 
2a62			;		jr z, .ldetokend 
2a62			;		; swap out any zero term for space 
2a62			;		cp 0 
2a62			;		jr nz, .ldetoknext 
2a62			;		ld a, ' ' 
2a62			; 
2a62			;	if DEBUG_FORTH_WORDS 
2a62			;		DMARK "LtS" 
2a62			;		CALLMONITOR 
2a62			;	endif 
2a62			;.ldetoknext:	ld (hl), a 
2a62			;		inc de 
2a62			;		inc hl 
2a62			;		jr .ldetok 
2a62			; 
2a62			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2a62			;		ld (hl), a  
2a62			; 
2a62			;; free that temp malloc 
2a62			; 
2a62			;		pop hl    
2a62			; 
2a62			;	if DEBUG_FORTH_WORDS 
2a62			;		DMARK "Lt4" 
2a62			;		CALLMONITOR 
2a62			;	endif 
2a62			;		call forth_apushstrhl 
2a62			; 
2a62			;		; get rid of temp malloc area 
2a62			; 
2a62			;		pop hl 
2a62			;		call free 
2a62			; 
2a62			;		jr .ludone 
2a62			; 
2a62			;.lnuword:	pop hl 
2a62			;		call forth_tok_next 
2a62			;		jp .ldouscan  
2a62			; 
2a62			;.ludone:		 pop hl 
2a62			; 
2a62					NEXTW 
2a62 c3 28 1f			jp macro_next 
2a65				endm 
# End of macro NEXTW
2a65			 
2a65			.FORGET: 
2a65				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2a65 5d				db WORD_SYS_CORE+73             
2a66 de 2a			dw .NOP            
2a68 07				db 6 + 1 
2a69 .. 00			db "FORGET",0              
2a70				endm 
# End of macro CWHEAD
2a70			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2a70			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2a70			; | |  
2a70			; | | e.g. "MORE" forget 
2a70					if DEBUG_FORTH_WORDS_KEY 
2a70						DMARK "FRG" 
2a70 f5				push af  
2a71 3a 85 2a			ld a, (.dmark)  
2a74 32 6b ee			ld (debug_mark),a  
2a77 3a 86 2a			ld a, (.dmark+1)  
2a7a 32 6c ee			ld (debug_mark+1),a  
2a7d 3a 87 2a			ld a, (.dmark+2)  
2a80 32 6d ee			ld (debug_mark+2),a  
2a83 18 03			jr .pastdmark  
2a85 ..			.dmark: db "FRG"  
2a88 f1			.pastdmark: pop af  
2a89			endm  
# End of macro DMARK
2a89						CALLMONITOR 
2a89 cd 6f ee			call debug_vector  
2a8c				endm  
# End of macro CALLMONITOR
2a8c					endif 
2a8c			 
2a8c				; find uword 
2a8c			        ; update start of word with "_" 
2a8c				; replace uword with deleted flag 
2a8c			 
2a8c			 
2a8c			;	if DEBUG_FORTH_WORDS 
2a8c			;		DMARK "FOG" 
2a8c			;		CALLMONITOR 
2a8c			;	endif 
2a8c			 
2a8c			 
2a8c					; Get ptr to the word we need to look up 
2a8c			 
2a8c					FORTH_DSP_VALUEHL 
2a8c cd 72 1d			call macro_dsp_valuehl 
2a8f				endm 
# End of macro FORTH_DSP_VALUEHL
2a8f					;v5 FORTH_DSP_VALUE 
2a8f				; TODO type check 
2a8f			;		inc hl    ; Skip type check  
2a8f e5					push hl 
2a90 c1					pop bc 
2a91			;		ex de, hl    ; put into DE 
2a91			 
2a91			 
2a91 21 74 5e				ld hl, baseram 
2a94					;ld hl, baseusermem 
2a94			 
2a94				; skip dict stub 
2a94			;	call forth_tok_next 
2a94 e5			push hl   ; sacreifical push 
2a95			 
2a95			.fldouscanm: 
2a95 e1				pop hl 
2a96			.fldouscan: 
2a96			;	if DEBUG_FORTH_WORDS 
2a96			;		DMARK "LSs" 
2a96			;		CALLMONITOR 
2a96			;	endif 
2a96				; skip dict stub 
2a96 cd 79 20				call forth_tok_next 
2a99			 
2a99			 
2a99			; while we have words to look for 
2a99			 
2a99 7e				ld a, (hl)      
2a9a			;	if DEBUG_FORTH_WORDS 
2a9a			;		DMARK "LSk" 
2a9a			;		CALLMONITOR 
2a9a			;	endif 
2a9a fe 00				cp WORD_SYS_END 
2a9c ca d8 2a				jp z, .flunotfound 
2a9f fe 01				cp WORD_SYS_UWORD 
2aa1 c2 96 2a				jp nz, .fldouscan 
2aa4			 
2aa4			;	if DEBUG_FORTH_WORDS 
2aa4			;		DMARK "LSu" 
2aa4			;		CALLMONITOR 
2aa4			;	endif 
2aa4			 
2aa4					; found a uword but is it the one we want... 
2aa4			 
2aa4 c5					push bc     ; uword to find is on bc 
2aa5 d1					pop de 
2aa6			 
2aa6 e5					push hl  ; to save the ptr 
2aa7			 
2aa7					; skip opcode 
2aa7 23					inc hl  
2aa8					; skip next ptr 
2aa8 23					inc hl  
2aa9 23					inc hl 
2aaa					; skip len 
2aaa 23					inc hl 
2aab			 
2aab			;	if DEBUG_FORTH_WORDS 
2aab			;		DMARK "LSc" 
2aab			;		CALLMONITOR 
2aab			;	endif 
2aab cd 84 11				call strcmp 
2aae c2 95 2a				jp nz, .fldouscanm 
2ab1			; 
2ab1			; 
2ab1			;; while we have words to look for 
2ab1			; 
2ab1			;.fdouscan:	ld a, (hl)      
2ab1			;	if DEBUG_FORTH_WORDS 
2ab1			;		DMARK "LSs" 
2ab1			;		CALLMONITOR 
2ab1			;	endif 
2ab1			;		cp WORD_SYS_END 
2ab1			;		jp z, .fudone 
2ab1			;		cp WORD_SYS_UWORD 
2ab1			;		jp nz, .fnuword 
2ab1			; 
2ab1			;	if DEBUG_FORTH_WORDS 
2ab1			;		DMARK "FGu" 
2ab1			;		CALLMONITOR 
2ab1			;	endif 
2ab1			; 
2ab1			;		; found a uword but is it the one we want... 
2ab1			; 
2ab1			; 
2ab1			;	        pop de   ; get back the dsp name 
2ab1			;		push de 
2ab1			; 
2ab1			;		push hl  ; to save the ptr 
2ab1			; 
2ab1			;		; skip opcode 
2ab1			;		inc hl  
2ab1			;		; skip next ptr 
2ab1			;		inc hl  
2ab1			;		inc hl 
2ab1			;		; skip len 
2ab1			;		inc hl 
2ab1			; 
2ab1			;	if DEBUG_FORTH_WORDS 
2ab1			;		DMARK "FGc" 
2ab1			;		CALLMONITOR 
2ab1			;	endif 
2ab1			;		call strcmp 
2ab1			;		jp nz, .fnuword 
2ab1			 
2ab1			 
2ab1 e1			pop hl 
2ab2			 
2ab2				 
2ab2				if DEBUG_FORTH_WORDS 
2ab2					DMARK "FGm" 
2ab2 f5				push af  
2ab3 3a c7 2a			ld a, (.dmark)  
2ab6 32 6b ee			ld (debug_mark),a  
2ab9 3a c8 2a			ld a, (.dmark+1)  
2abc 32 6c ee			ld (debug_mark+1),a  
2abf 3a c9 2a			ld a, (.dmark+2)  
2ac2 32 6d ee			ld (debug_mark+2),a  
2ac5 18 03			jr .pastdmark  
2ac7 ..			.dmark: db "FGm"  
2aca f1			.pastdmark: pop af  
2acb			endm  
# End of macro DMARK
2acb					CALLMONITOR 
2acb cd 6f ee			call debug_vector  
2ace				endm  
# End of macro CALLMONITOR
2ace				endif 
2ace			 
2ace			 
2ace			 
2ace					; we have a uword so push its name to the stack 
2ace			 
2ace			;	   	push hl  ; save so we can move to next dict block 
2ace			;pop hl 
2ace			 
2ace					; update opcode to deleted 
2ace 3e 03				ld a, WORD_SYS_DELETED 
2ad0 77					ld (hl), a 
2ad1			 
2ad1 23					inc hl  
2ad2					; skip next ptr 
2ad2 23					inc hl  
2ad3 23					inc hl 
2ad4					; skip len 
2ad4 23					inc hl 
2ad5			 
2ad5					; TODO change parser to skip deleted words but for now mark it out 
2ad5 3e 5f				ld a, "_" 
2ad7 77					ld  (hl),a 
2ad8			 
2ad8			;		jr .fudone 
2ad8			; 
2ad8			;.fnuword:	pop hl 
2ad8			;		call forth_tok_next 
2ad8			;		jp .fdouscan  
2ad8			 
2ad8			.flunotfound:		  
2ad8			 
2ad8			 
2ad8					 
2ad8					FORTH_DSP_POP 
2ad8 cd 2a 1e			call macro_forth_dsp_pop 
2adb				endm 
# End of macro FORTH_DSP_POP
2adb			;		ld hl, .luno 
2adb			;.fudone:		 pop hl 
2adb					NEXTW 
2adb c3 28 1f			jp macro_next 
2ade				endm 
# End of macro NEXTW
2ade			.NOP: 
2ade				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2ade 61				db WORD_SYS_CORE+77             
2adf 05 2b			dw .COMO            
2ae1 04				db 3 + 1 
2ae2 .. 00			db "NOP",0              
2ae6				endm 
# End of macro CWHEAD
2ae6			; | NOP (  --  ) Do nothing | DONE 
2ae6					if DEBUG_FORTH_WORDS_KEY 
2ae6						DMARK "NOP" 
2ae6 f5				push af  
2ae7 3a fb 2a			ld a, (.dmark)  
2aea 32 6b ee			ld (debug_mark),a  
2aed 3a fc 2a			ld a, (.dmark+1)  
2af0 32 6c ee			ld (debug_mark+1),a  
2af3 3a fd 2a			ld a, (.dmark+2)  
2af6 32 6d ee			ld (debug_mark+2),a  
2af9 18 03			jr .pastdmark  
2afb ..			.dmark: db "NOP"  
2afe f1			.pastdmark: pop af  
2aff			endm  
# End of macro DMARK
2aff						CALLMONITOR 
2aff cd 6f ee			call debug_vector  
2b02				endm  
# End of macro CALLMONITOR
2b02					endif 
2b02				       NEXTW 
2b02 c3 28 1f			jp macro_next 
2b05				endm 
# End of macro NEXTW
2b05			.COMO: 
2b05				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2b05 6e				db WORD_SYS_CORE+90             
2b06 57 2b			dw .COMC            
2b08 02				db 1 + 1 
2b09 .. 00			db "(",0              
2b0b				endm 
# End of macro CWHEAD
2b0b			; | ( ( -- )  Start of comment | DONE 
2b0b			 
2b0b			 
2b0b 2a c2 e5				ld hl, ( os_tok_ptr) 
2b0e 11 52 2b			ld de, .closepar 
2b11					 
2b11					if DEBUG_FORTH_WORDS 
2b11						DMARK ").." 
2b11 f5				push af  
2b12 3a 26 2b			ld a, (.dmark)  
2b15 32 6b ee			ld (debug_mark),a  
2b18 3a 27 2b			ld a, (.dmark+1)  
2b1b 32 6c ee			ld (debug_mark+1),a  
2b1e 3a 28 2b			ld a, (.dmark+2)  
2b21 32 6d ee			ld (debug_mark+2),a  
2b24 18 03			jr .pastdmark  
2b26 ..			.dmark: db ").."  
2b29 f1			.pastdmark: pop af  
2b2a			endm  
# End of macro DMARK
2b2a						CALLMONITOR 
2b2a cd 6f ee			call debug_vector  
2b2d				endm  
# End of macro CALLMONITOR
2b2d					endif 
2b2d cd 43 20			call findnexttok  
2b30			 
2b30					if DEBUG_FORTH_WORDS 
2b30						DMARK "IF5" 
2b30 f5				push af  
2b31 3a 45 2b			ld a, (.dmark)  
2b34 32 6b ee			ld (debug_mark),a  
2b37 3a 46 2b			ld a, (.dmark+1)  
2b3a 32 6c ee			ld (debug_mark+1),a  
2b3d 3a 47 2b			ld a, (.dmark+2)  
2b40 32 6d ee			ld (debug_mark+2),a  
2b43 18 03			jr .pastdmark  
2b45 ..			.dmark: db "IF5"  
2b48 f1			.pastdmark: pop af  
2b49			endm  
# End of macro DMARK
2b49						CALLMONITOR 
2b49 cd 6f ee			call debug_vector  
2b4c				endm  
# End of macro CALLMONITOR
2b4c					endif 
2b4c				; replace below with ) exec using tok_ptr 
2b4c 22 c2 e5			ld (os_tok_ptr), hl 
2b4f c3 b9 1f			jp exec1 
2b52			 
2b52 .. 00			.closepar:   db ")",0 
2b54			 
2b54				       NEXTW 
2b54 c3 28 1f			jp macro_next 
2b57				endm 
# End of macro NEXTW
2b57			.COMC: 
2b57				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2b57 6f				db WORD_SYS_CORE+91             
2b58 60 2b			dw .SCRATCH            
2b5a 02				db 1 + 1 
2b5b .. 00			db ")",0              
2b5d				endm 
# End of macro CWHEAD
2b5d			; | ) ( -- )  End of comment |  DONE  
2b5d				       NEXTW 
2b5d c3 28 1f			jp macro_next 
2b60				endm 
# End of macro NEXTW
2b60			 
2b60			.SCRATCH: 
2b60				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2b60 6f				db WORD_SYS_CORE+91             
2b61 9b 2b			dw .INC            
2b63 08				db 7 + 1 
2b64 .. 00			db "SCRATCH",0              
2b6c				endm 
# End of macro CWHEAD
2b6c			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2b6c			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2b6c			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2b6c			; | |  
2b6c			; | | e.g.    : score $00 scratch ; 
2b6c			; | |  
2b6c			; | | $00 score ! 
2b6c			; | | $01 score +! 
2b6c			; | |  
2b6c			; | | e.g.   : varword $0a scratch ;  
2b6c			; | | 
2b6c			; | | $8000 varword ! 
2b6c					if DEBUG_FORTH_WORDS_KEY 
2b6c						DMARK "SCR" 
2b6c f5				push af  
2b6d 3a 81 2b			ld a, (.dmark)  
2b70 32 6b ee			ld (debug_mark),a  
2b73 3a 82 2b			ld a, (.dmark+1)  
2b76 32 6c ee			ld (debug_mark+1),a  
2b79 3a 83 2b			ld a, (.dmark+2)  
2b7c 32 6d ee			ld (debug_mark+2),a  
2b7f 18 03			jr .pastdmark  
2b81 ..			.dmark: db "SCR"  
2b84 f1			.pastdmark: pop af  
2b85			endm  
# End of macro DMARK
2b85						CALLMONITOR 
2b85 cd 6f ee			call debug_vector  
2b88				endm  
# End of macro CALLMONITOR
2b88					endif 
2b88			 
2b88					FORTH_DSP_VALUEHL 
2b88 cd 72 1d			call macro_dsp_valuehl 
2b8b				endm 
# End of macro FORTH_DSP_VALUEHL
2b8b				 
2b8b					FORTH_DSP_POP 
2b8b cd 2a 1e			call macro_forth_dsp_pop 
2b8e				endm 
# End of macro FORTH_DSP_POP
2b8e			 
2b8e 7d					ld a, l 
2b8f 21 e6 e7				ld hl, os_var_array 
2b92 cd e6 0d				call addatohl 
2b95			 
2b95 cd 6d 1b				call forth_push_numhl 
2b98			 
2b98				       NEXTW 
2b98 c3 28 1f			jp macro_next 
2b9b				endm 
# End of macro NEXTW
2b9b			 
2b9b			.INC: 
2b9b				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2b9b 6f				db WORD_SYS_CORE+91             
2b9c f1 2b			dw .DEC            
2b9e 03				db 2 + 1 
2b9f .. 00			db "+!",0              
2ba2				endm 
# End of macro CWHEAD
2ba2			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2ba2					if DEBUG_FORTH_WORDS_KEY 
2ba2						DMARK "+s_" 
2ba2 f5				push af  
2ba3 3a b7 2b			ld a, (.dmark)  
2ba6 32 6b ee			ld (debug_mark),a  
2ba9 3a b8 2b			ld a, (.dmark+1)  
2bac 32 6c ee			ld (debug_mark+1),a  
2baf 3a b9 2b			ld a, (.dmark+2)  
2bb2 32 6d ee			ld (debug_mark+2),a  
2bb5 18 03			jr .pastdmark  
2bb7 ..			.dmark: db "+s_"  
2bba f1			.pastdmark: pop af  
2bbb			endm  
# End of macro DMARK
2bbb						CALLMONITOR 
2bbb cd 6f ee			call debug_vector  
2bbe				endm  
# End of macro CALLMONITOR
2bbe					endif 
2bbe			 
2bbe					FORTH_DSP_VALUEHL 
2bbe cd 72 1d			call macro_dsp_valuehl 
2bc1				endm 
# End of macro FORTH_DSP_VALUEHL
2bc1			 
2bc1 e5					push hl   ; save address 
2bc2			 
2bc2					FORTH_DSP_POP 
2bc2 cd 2a 1e			call macro_forth_dsp_pop 
2bc5				endm 
# End of macro FORTH_DSP_POP
2bc5			 
2bc5					FORTH_DSP_VALUEHL 
2bc5 cd 72 1d			call macro_dsp_valuehl 
2bc8				endm 
# End of macro FORTH_DSP_VALUEHL
2bc8			 
2bc8 e5					push hl 
2bc9					FORTH_DSP_POP 
2bc9 cd 2a 1e			call macro_forth_dsp_pop 
2bcc				endm 
# End of macro FORTH_DSP_POP
2bcc e1					pop hl 
2bcd			 
2bcd					; hl contains value to add to byte at a 
2bcd				 
2bcd eb					ex de, hl 
2bce			 
2bce e1					pop hl 
2bcf			 
2bcf					if DEBUG_FORTH_WORDS 
2bcf						DMARK "INC" 
2bcf f5				push af  
2bd0 3a e4 2b			ld a, (.dmark)  
2bd3 32 6b ee			ld (debug_mark),a  
2bd6 3a e5 2b			ld a, (.dmark+1)  
2bd9 32 6c ee			ld (debug_mark+1),a  
2bdc 3a e6 2b			ld a, (.dmark+2)  
2bdf 32 6d ee			ld (debug_mark+2),a  
2be2 18 03			jr .pastdmark  
2be4 ..			.dmark: db "INC"  
2be7 f1			.pastdmark: pop af  
2be8			endm  
# End of macro DMARK
2be8						CALLMONITOR 
2be8 cd 6f ee			call debug_vector  
2beb				endm  
# End of macro CALLMONITOR
2beb					endif 
2beb			 
2beb 7e					ld a,(hl) 
2bec 83					add e 
2bed 77					ld (hl),a 
2bee			 
2bee			 
2bee			 
2bee				       NEXTW 
2bee c3 28 1f			jp macro_next 
2bf1				endm 
# End of macro NEXTW
2bf1			 
2bf1			.DEC: 
2bf1				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2bf1 6f				db WORD_SYS_CORE+91             
2bf2 45 2c			dw .INC2            
2bf4 03				db 2 + 1 
2bf5 .. 00			db "-!",0              
2bf8				endm 
# End of macro CWHEAD
2bf8			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2bf8					if DEBUG_FORTH_WORDS_KEY 
2bf8						DMARK "-s_" 
2bf8 f5				push af  
2bf9 3a 0d 2c			ld a, (.dmark)  
2bfc 32 6b ee			ld (debug_mark),a  
2bff 3a 0e 2c			ld a, (.dmark+1)  
2c02 32 6c ee			ld (debug_mark+1),a  
2c05 3a 0f 2c			ld a, (.dmark+2)  
2c08 32 6d ee			ld (debug_mark+2),a  
2c0b 18 03			jr .pastdmark  
2c0d ..			.dmark: db "-s_"  
2c10 f1			.pastdmark: pop af  
2c11			endm  
# End of macro DMARK
2c11						CALLMONITOR 
2c11 cd 6f ee			call debug_vector  
2c14				endm  
# End of macro CALLMONITOR
2c14					endif 
2c14			 
2c14					FORTH_DSP_VALUEHL 
2c14 cd 72 1d			call macro_dsp_valuehl 
2c17				endm 
# End of macro FORTH_DSP_VALUEHL
2c17			 
2c17 e5					push hl   ; save address 
2c18			 
2c18					FORTH_DSP_POP 
2c18 cd 2a 1e			call macro_forth_dsp_pop 
2c1b				endm 
# End of macro FORTH_DSP_POP
2c1b			 
2c1b					FORTH_DSP_VALUEHL 
2c1b cd 72 1d			call macro_dsp_valuehl 
2c1e				endm 
# End of macro FORTH_DSP_VALUEHL
2c1e			 
2c1e					; hl contains value to add to byte at a 
2c1e				 
2c1e eb					ex de, hl 
2c1f			 
2c1f e1					pop hl 
2c20			 
2c20					if DEBUG_FORTH_WORDS 
2c20						DMARK "DEC" 
2c20 f5				push af  
2c21 3a 35 2c			ld a, (.dmark)  
2c24 32 6b ee			ld (debug_mark),a  
2c27 3a 36 2c			ld a, (.dmark+1)  
2c2a 32 6c ee			ld (debug_mark+1),a  
2c2d 3a 37 2c			ld a, (.dmark+2)  
2c30 32 6d ee			ld (debug_mark+2),a  
2c33 18 03			jr .pastdmark  
2c35 ..			.dmark: db "DEC"  
2c38 f1			.pastdmark: pop af  
2c39			endm  
# End of macro DMARK
2c39						CALLMONITOR 
2c39 cd 6f ee			call debug_vector  
2c3c				endm  
# End of macro CALLMONITOR
2c3c					endif 
2c3c			 
2c3c 7e					ld a,(hl) 
2c3d 93					sub e 
2c3e 77					ld (hl),a 
2c3f			 
2c3f			 
2c3f					FORTH_DSP_POP 
2c3f cd 2a 1e			call macro_forth_dsp_pop 
2c42				endm 
# End of macro FORTH_DSP_POP
2c42			 
2c42				       NEXTW 
2c42 c3 28 1f			jp macro_next 
2c45				endm 
# End of macro NEXTW
2c45			 
2c45			.INC2: 
2c45				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2c45 6f				db WORD_SYS_CORE+91             
2c46 f2 2c			dw .DEC2            
2c48 04				db 3 + 1 
2c49 .. 00			db "+2!",0              
2c4d				endm 
# End of macro CWHEAD
2c4d			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2c4d			 
2c4d					if DEBUG_FORTH_WORDS_KEY 
2c4d						DMARK "+2s" 
2c4d f5				push af  
2c4e 3a 62 2c			ld a, (.dmark)  
2c51 32 6b ee			ld (debug_mark),a  
2c54 3a 63 2c			ld a, (.dmark+1)  
2c57 32 6c ee			ld (debug_mark+1),a  
2c5a 3a 64 2c			ld a, (.dmark+2)  
2c5d 32 6d ee			ld (debug_mark+2),a  
2c60 18 03			jr .pastdmark  
2c62 ..			.dmark: db "+2s"  
2c65 f1			.pastdmark: pop af  
2c66			endm  
# End of macro DMARK
2c66						CALLMONITOR 
2c66 cd 6f ee			call debug_vector  
2c69				endm  
# End of macro CALLMONITOR
2c69					endif 
2c69			 
2c69					; Address 
2c69			 
2c69					FORTH_DSP_VALUEHL 
2c69 cd 72 1d			call macro_dsp_valuehl 
2c6c				endm 
# End of macro FORTH_DSP_VALUEHL
2c6c			 
2c6c e5					push hl    ; save address 
2c6d			 
2c6d					; load content into de 
2c6d			 
2c6d 5e					ld e,(hl) 
2c6e 23					inc hl 
2c6f 56					ld d, (hl) 
2c70			 
2c70					if DEBUG_FORTH_WORDS 
2c70						DMARK "+2a" 
2c70 f5				push af  
2c71 3a 85 2c			ld a, (.dmark)  
2c74 32 6b ee			ld (debug_mark),a  
2c77 3a 86 2c			ld a, (.dmark+1)  
2c7a 32 6c ee			ld (debug_mark+1),a  
2c7d 3a 87 2c			ld a, (.dmark+2)  
2c80 32 6d ee			ld (debug_mark+2),a  
2c83 18 03			jr .pastdmark  
2c85 ..			.dmark: db "+2a"  
2c88 f1			.pastdmark: pop af  
2c89			endm  
# End of macro DMARK
2c89						CALLMONITOR 
2c89 cd 6f ee			call debug_vector  
2c8c				endm  
# End of macro CALLMONITOR
2c8c					endif 
2c8c			 
2c8c					FORTH_DSP_POP 
2c8c cd 2a 1e			call macro_forth_dsp_pop 
2c8f				endm 
# End of macro FORTH_DSP_POP
2c8f			 
2c8f					; Get value to add 
2c8f			 
2c8f					FORTH_DSP_VALUE 
2c8f cd 5b 1d			call macro_forth_dsp_value 
2c92				endm 
# End of macro FORTH_DSP_VALUE
2c92			 
2c92					if DEBUG_FORTH_WORDS 
2c92						DMARK "+2v" 
2c92 f5				push af  
2c93 3a a7 2c			ld a, (.dmark)  
2c96 32 6b ee			ld (debug_mark),a  
2c99 3a a8 2c			ld a, (.dmark+1)  
2c9c 32 6c ee			ld (debug_mark+1),a  
2c9f 3a a9 2c			ld a, (.dmark+2)  
2ca2 32 6d ee			ld (debug_mark+2),a  
2ca5 18 03			jr .pastdmark  
2ca7 ..			.dmark: db "+2v"  
2caa f1			.pastdmark: pop af  
2cab			endm  
# End of macro DMARK
2cab						CALLMONITOR 
2cab cd 6f ee			call debug_vector  
2cae				endm  
# End of macro CALLMONITOR
2cae					endif 
2cae			 
2cae 19					add hl, de 
2caf			 
2caf					if DEBUG_FORTH_WORDS 
2caf						DMARK "+2+" 
2caf f5				push af  
2cb0 3a c4 2c			ld a, (.dmark)  
2cb3 32 6b ee			ld (debug_mark),a  
2cb6 3a c5 2c			ld a, (.dmark+1)  
2cb9 32 6c ee			ld (debug_mark+1),a  
2cbc 3a c6 2c			ld a, (.dmark+2)  
2cbf 32 6d ee			ld (debug_mark+2),a  
2cc2 18 03			jr .pastdmark  
2cc4 ..			.dmark: db "+2+"  
2cc7 f1			.pastdmark: pop af  
2cc8			endm  
# End of macro DMARK
2cc8						CALLMONITOR 
2cc8 cd 6f ee			call debug_vector  
2ccb				endm  
# End of macro CALLMONITOR
2ccb					endif 
2ccb			 
2ccb					; move result to de 
2ccb			 
2ccb eb					ex de, hl 
2ccc			 
2ccc					; Address 
2ccc			 
2ccc e1					pop hl 
2ccd			 
2ccd					; save it back 
2ccd			 
2ccd 73					ld (hl), e 
2cce 23					inc hl 
2ccf 72					ld (hl), d 
2cd0			 
2cd0					if DEBUG_FORTH_WORDS 
2cd0						DMARK "+2e" 
2cd0 f5				push af  
2cd1 3a e5 2c			ld a, (.dmark)  
2cd4 32 6b ee			ld (debug_mark),a  
2cd7 3a e6 2c			ld a, (.dmark+1)  
2cda 32 6c ee			ld (debug_mark+1),a  
2cdd 3a e7 2c			ld a, (.dmark+2)  
2ce0 32 6d ee			ld (debug_mark+2),a  
2ce3 18 03			jr .pastdmark  
2ce5 ..			.dmark: db "+2e"  
2ce8 f1			.pastdmark: pop af  
2ce9			endm  
# End of macro DMARK
2ce9						CALLMONITOR 
2ce9 cd 6f ee			call debug_vector  
2cec				endm  
# End of macro CALLMONITOR
2cec					endif 
2cec			 
2cec			 
2cec			 
2cec					FORTH_DSP_POP 
2cec cd 2a 1e			call macro_forth_dsp_pop 
2cef				endm 
# End of macro FORTH_DSP_POP
2cef			 
2cef			 
2cef				       NEXTW 
2cef c3 28 1f			jp macro_next 
2cf2				endm 
# End of macro NEXTW
2cf2			 
2cf2			.DEC2: 
2cf2				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2cf2 6f				db WORD_SYS_CORE+91             
2cf3 a1 2d			dw .GET2            
2cf5 04				db 3 + 1 
2cf6 .. 00			db "-2!",0              
2cfa				endm 
# End of macro CWHEAD
2cfa			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2cfa			 
2cfa			 
2cfa					if DEBUG_FORTH_WORDS_KEY 
2cfa						DMARK "-2s" 
2cfa f5				push af  
2cfb 3a 0f 2d			ld a, (.dmark)  
2cfe 32 6b ee			ld (debug_mark),a  
2d01 3a 10 2d			ld a, (.dmark+1)  
2d04 32 6c ee			ld (debug_mark+1),a  
2d07 3a 11 2d			ld a, (.dmark+2)  
2d0a 32 6d ee			ld (debug_mark+2),a  
2d0d 18 03			jr .pastdmark  
2d0f ..			.dmark: db "-2s"  
2d12 f1			.pastdmark: pop af  
2d13			endm  
# End of macro DMARK
2d13						CALLMONITOR 
2d13 cd 6f ee			call debug_vector  
2d16				endm  
# End of macro CALLMONITOR
2d16					endif 
2d16			 
2d16					; Address 
2d16			 
2d16					FORTH_DSP_VALUEHL 
2d16 cd 72 1d			call macro_dsp_valuehl 
2d19				endm 
# End of macro FORTH_DSP_VALUEHL
2d19			 
2d19 e5					push hl    ; save address 
2d1a			 
2d1a					; load content into de 
2d1a			 
2d1a 5e					ld e,(hl) 
2d1b 23					inc hl 
2d1c 56					ld d, (hl) 
2d1d			 
2d1d					if DEBUG_FORTH_WORDS 
2d1d						DMARK "-2a" 
2d1d f5				push af  
2d1e 3a 32 2d			ld a, (.dmark)  
2d21 32 6b ee			ld (debug_mark),a  
2d24 3a 33 2d			ld a, (.dmark+1)  
2d27 32 6c ee			ld (debug_mark+1),a  
2d2a 3a 34 2d			ld a, (.dmark+2)  
2d2d 32 6d ee			ld (debug_mark+2),a  
2d30 18 03			jr .pastdmark  
2d32 ..			.dmark: db "-2a"  
2d35 f1			.pastdmark: pop af  
2d36			endm  
# End of macro DMARK
2d36						CALLMONITOR 
2d36 cd 6f ee			call debug_vector  
2d39				endm  
# End of macro CALLMONITOR
2d39					endif 
2d39			 
2d39					FORTH_DSP_POP 
2d39 cd 2a 1e			call macro_forth_dsp_pop 
2d3c				endm 
# End of macro FORTH_DSP_POP
2d3c			 
2d3c					; Get value to remove 
2d3c			 
2d3c					FORTH_DSP_VALUE 
2d3c cd 5b 1d			call macro_forth_dsp_value 
2d3f				endm 
# End of macro FORTH_DSP_VALUE
2d3f			 
2d3f					if DEBUG_FORTH_WORDS 
2d3f						DMARK "-2v" 
2d3f f5				push af  
2d40 3a 54 2d			ld a, (.dmark)  
2d43 32 6b ee			ld (debug_mark),a  
2d46 3a 55 2d			ld a, (.dmark+1)  
2d49 32 6c ee			ld (debug_mark+1),a  
2d4c 3a 56 2d			ld a, (.dmark+2)  
2d4f 32 6d ee			ld (debug_mark+2),a  
2d52 18 03			jr .pastdmark  
2d54 ..			.dmark: db "-2v"  
2d57 f1			.pastdmark: pop af  
2d58			endm  
# End of macro DMARK
2d58						CALLMONITOR 
2d58 cd 6f ee			call debug_vector  
2d5b				endm  
# End of macro CALLMONITOR
2d5b					endif 
2d5b			 
2d5b eb					ex de, hl 
2d5c ed 52				sbc hl, de 
2d5e			 
2d5e					if DEBUG_FORTH_WORDS 
2d5e						DMARK "-2d" 
2d5e f5				push af  
2d5f 3a 73 2d			ld a, (.dmark)  
2d62 32 6b ee			ld (debug_mark),a  
2d65 3a 74 2d			ld a, (.dmark+1)  
2d68 32 6c ee			ld (debug_mark+1),a  
2d6b 3a 75 2d			ld a, (.dmark+2)  
2d6e 32 6d ee			ld (debug_mark+2),a  
2d71 18 03			jr .pastdmark  
2d73 ..			.dmark: db "-2d"  
2d76 f1			.pastdmark: pop af  
2d77			endm  
# End of macro DMARK
2d77						CALLMONITOR 
2d77 cd 6f ee			call debug_vector  
2d7a				endm  
# End of macro CALLMONITOR
2d7a					endif 
2d7a			 
2d7a					; move result to de 
2d7a			 
2d7a eb					ex de, hl 
2d7b			 
2d7b					; Address 
2d7b			 
2d7b e1					pop hl 
2d7c			 
2d7c					; save it back 
2d7c			 
2d7c 73					ld (hl), e 
2d7d 23					inc hl 
2d7e 72					ld (hl), d 
2d7f			 
2d7f					if DEBUG_FORTH_WORDS 
2d7f						DMARK "-2e" 
2d7f f5				push af  
2d80 3a 94 2d			ld a, (.dmark)  
2d83 32 6b ee			ld (debug_mark),a  
2d86 3a 95 2d			ld a, (.dmark+1)  
2d89 32 6c ee			ld (debug_mark+1),a  
2d8c 3a 96 2d			ld a, (.dmark+2)  
2d8f 32 6d ee			ld (debug_mark+2),a  
2d92 18 03			jr .pastdmark  
2d94 ..			.dmark: db "-2e"  
2d97 f1			.pastdmark: pop af  
2d98			endm  
# End of macro DMARK
2d98						CALLMONITOR 
2d98 cd 6f ee			call debug_vector  
2d9b				endm  
# End of macro CALLMONITOR
2d9b					endif 
2d9b			 
2d9b			 
2d9b					FORTH_DSP_POP 
2d9b cd 2a 1e			call macro_forth_dsp_pop 
2d9e				endm 
# End of macro FORTH_DSP_POP
2d9e			 
2d9e			 
2d9e			 
2d9e				       NEXTW 
2d9e c3 28 1f			jp macro_next 
2da1				endm 
# End of macro NEXTW
2da1			.GET2: 
2da1				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2da1 6f				db WORD_SYS_CORE+91             
2da2 d6 2d			dw .BANG2            
2da4 03				db 2 + 1 
2da5 .. 00			db "2@",0              
2da8				endm 
# End of macro CWHEAD
2da8			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2da8					if DEBUG_FORTH_WORDS_KEY 
2da8						DMARK "2A_" 
2da8 f5				push af  
2da9 3a bd 2d			ld a, (.dmark)  
2dac 32 6b ee			ld (debug_mark),a  
2daf 3a be 2d			ld a, (.dmark+1)  
2db2 32 6c ee			ld (debug_mark+1),a  
2db5 3a bf 2d			ld a, (.dmark+2)  
2db8 32 6d ee			ld (debug_mark+2),a  
2dbb 18 03			jr .pastdmark  
2dbd ..			.dmark: db "2A_"  
2dc0 f1			.pastdmark: pop af  
2dc1			endm  
# End of macro DMARK
2dc1						CALLMONITOR 
2dc1 cd 6f ee			call debug_vector  
2dc4				endm  
# End of macro CALLMONITOR
2dc4					endif 
2dc4			 
2dc4					FORTH_DSP_VALUEHL 
2dc4 cd 72 1d			call macro_dsp_valuehl 
2dc7				endm 
# End of macro FORTH_DSP_VALUEHL
2dc7			 
2dc7 e5					push hl   ; save address 
2dc8			 
2dc8					FORTH_DSP_POP 
2dc8 cd 2a 1e			call macro_forth_dsp_pop 
2dcb				endm 
# End of macro FORTH_DSP_POP
2dcb			 
2dcb e1					pop hl 
2dcc			 
2dcc 5e					ld e, (hl) 
2dcd 23					inc hl 
2dce 56					ld d, (hl) 
2dcf			 
2dcf eb					ex de, hl 
2dd0			 
2dd0 cd 6d 1b				call forth_push_numhl 
2dd3			 
2dd3				       NEXTW 
2dd3 c3 28 1f			jp macro_next 
2dd6				endm 
# End of macro NEXTW
2dd6			.BANG2: 
2dd6				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2dd6 6f				db WORD_SYS_CORE+91             
2dd7 0e 2e			dw .CONFIG            
2dd9 03				db 2 + 1 
2dda .. 00			db "2!",0              
2ddd				endm 
# End of macro CWHEAD
2ddd			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2ddd					if DEBUG_FORTH_WORDS_KEY 
2ddd						DMARK "2S_" 
2ddd f5				push af  
2dde 3a f2 2d			ld a, (.dmark)  
2de1 32 6b ee			ld (debug_mark),a  
2de4 3a f3 2d			ld a, (.dmark+1)  
2de7 32 6c ee			ld (debug_mark+1),a  
2dea 3a f4 2d			ld a, (.dmark+2)  
2ded 32 6d ee			ld (debug_mark+2),a  
2df0 18 03			jr .pastdmark  
2df2 ..			.dmark: db "2S_"  
2df5 f1			.pastdmark: pop af  
2df6			endm  
# End of macro DMARK
2df6						CALLMONITOR 
2df6 cd 6f ee			call debug_vector  
2df9				endm  
# End of macro CALLMONITOR
2df9					endif 
2df9			 
2df9					FORTH_DSP_VALUEHL 
2df9 cd 72 1d			call macro_dsp_valuehl 
2dfc				endm 
# End of macro FORTH_DSP_VALUEHL
2dfc			 
2dfc e5					push hl   ; save address 
2dfd			 
2dfd			 
2dfd					FORTH_DSP_POP 
2dfd cd 2a 1e			call macro_forth_dsp_pop 
2e00				endm 
# End of macro FORTH_DSP_POP
2e00			 
2e00					 
2e00					FORTH_DSP_VALUEHL 
2e00 cd 72 1d			call macro_dsp_valuehl 
2e03				endm 
# End of macro FORTH_DSP_VALUEHL
2e03			 
2e03					FORTH_DSP_POP 
2e03 cd 2a 1e			call macro_forth_dsp_pop 
2e06				endm 
# End of macro FORTH_DSP_POP
2e06			 
2e06 eb					ex de, hl    ; value now in de 
2e07			 
2e07 e1					pop hl 
2e08			 
2e08 73					ld (hl), e 
2e09			 
2e09 23					inc hl 
2e0a			 
2e0a 72					ld (hl), d 
2e0b			 
2e0b			 
2e0b				       NEXTW 
2e0b c3 28 1f			jp macro_next 
2e0e				endm 
# End of macro NEXTW
2e0e			.CONFIG: 
2e0e				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
2e0e 6f				db WORD_SYS_CORE+91             
2e0f 1f 2e			dw .ADTOS            
2e11 07				db 6 + 1 
2e12 .. 00			db "CONFIG",0              
2e19				endm 
# End of macro CWHEAD
2e19			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2e19			 
2e19 cd 5a 13				call config 
2e1c					NEXTW 
2e1c c3 28 1f			jp macro_next 
2e1f				endm 
# End of macro NEXTW
2e1f			 
2e1f			.ADTOS: 
2e1f				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
2e1f 6f				db WORD_SYS_CORE+91             
2e20 35 2e			dw .SBTOS            
2e22 03				db 2 + 1 
2e23 .. 00			db "1+",0              
2e26				endm 
# End of macro CWHEAD
2e26			; | 1+ ( u -- u )  Increment value on TOS | DONE 
2e26			 
2e26					FORTH_DSP_VALUEHL 
2e26 cd 72 1d			call macro_dsp_valuehl 
2e29				endm 
# End of macro FORTH_DSP_VALUEHL
2e29 e5					push hl 
2e2a			 
2e2a					FORTH_DSP_POP 
2e2a cd 2a 1e			call macro_forth_dsp_pop 
2e2d				endm 
# End of macro FORTH_DSP_POP
2e2d e1					pop hl 
2e2e			 
2e2e 23					inc hl 
2e2f cd 6d 1b				call forth_push_numhl 
2e32					 
2e32					NEXTW 
2e32 c3 28 1f			jp macro_next 
2e35				endm 
# End of macro NEXTW
2e35			.SBTOS: 
2e35				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
2e35 6f				db WORD_SYS_CORE+91             
2e36 4b 2e			dw .ADSTORE            
2e38 03				db 2 + 1 
2e39 .. 00			db "1-",0              
2e3c				endm 
# End of macro CWHEAD
2e3c			; | 1- ( u -- u )  Decrement value on TOS | DONE 
2e3c			 
2e3c					FORTH_DSP_VALUEHL 
2e3c cd 72 1d			call macro_dsp_valuehl 
2e3f				endm 
# End of macro FORTH_DSP_VALUEHL
2e3f e5					push hl 
2e40			 
2e40					FORTH_DSP_POP 
2e40 cd 2a 1e			call macro_forth_dsp_pop 
2e43				endm 
# End of macro FORTH_DSP_POP
2e43 e1					pop hl 
2e44			 
2e44 2b					dec hl 
2e45 cd 6d 1b				call forth_push_numhl 
2e48					 
2e48					NEXTW 
2e48 c3 28 1f			jp macro_next 
2e4b				endm 
# End of macro NEXTW
2e4b			.ADSTORE: 
2e4b				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
2e4b 6f				db WORD_SYS_CORE+91             
2e4c 61 2e			dw .ADWSTORE            
2e4e 04				db 3 + 1 
2e4f .. 00			db "1+!",0              
2e53				endm 
# End of macro CWHEAD
2e53			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
2e53			 
2e53					FORTH_DSP_VALUEHL 
2e53 cd 72 1d			call macro_dsp_valuehl 
2e56				endm 
# End of macro FORTH_DSP_VALUEHL
2e56 e5					push hl 
2e57			 
2e57					FORTH_DSP_POP 
2e57 cd 2a 1e			call macro_forth_dsp_pop 
2e5a				endm 
# End of macro FORTH_DSP_POP
2e5a e1					pop hl 
2e5b			 
2e5b 7e					ld a, (hl) 
2e5c 3c					inc a 
2e5d 77					ld (hl), a 
2e5e					 
2e5e					NEXTW 
2e5e c3 28 1f			jp macro_next 
2e61				endm 
# End of macro NEXTW
2e61			.ADWSTORE: 
2e61				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
2e61 6f				db WORD_SYS_CORE+91             
2e62 7f 2e			dw .SBSTORE            
2e64 05				db 4 + 1 
2e65 .. 00			db "1+2!",0              
2e6a				endm 
# End of macro CWHEAD
2e6a			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
2e6a			 
2e6a					FORTH_DSP_VALUEHL 
2e6a cd 72 1d			call macro_dsp_valuehl 
2e6d				endm 
# End of macro FORTH_DSP_VALUEHL
2e6d e5					push hl 
2e6e			 
2e6e					FORTH_DSP_POP 
2e6e cd 2a 1e			call macro_forth_dsp_pop 
2e71				endm 
# End of macro FORTH_DSP_POP
2e71 e1					pop hl 
2e72			 
2e72 e5					push hl 
2e73			 
2e73 cd aa 1e				call loadwordinhl 
2e76 23					inc hl 
2e77			 
2e77 d1					pop de 
2e78 eb					ex de, hl 
2e79 73					ld (hl), e 
2e7a 23					inc hl 
2e7b 72					ld (hl), d 
2e7c					 
2e7c					NEXTW 
2e7c c3 28 1f			jp macro_next 
2e7f				endm 
# End of macro NEXTW
2e7f			.SBSTORE: 
2e7f				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
2e7f 6f				db WORD_SYS_CORE+91             
2e80 95 2e			dw .SBWSTORE            
2e82 04				db 3 + 1 
2e83 .. 00			db "1-!",0              
2e87				endm 
# End of macro CWHEAD
2e87			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
2e87			 
2e87					FORTH_DSP_VALUEHL 
2e87 cd 72 1d			call macro_dsp_valuehl 
2e8a				endm 
# End of macro FORTH_DSP_VALUEHL
2e8a e5					push hl 
2e8b			 
2e8b					FORTH_DSP_POP 
2e8b cd 2a 1e			call macro_forth_dsp_pop 
2e8e				endm 
# End of macro FORTH_DSP_POP
2e8e e1					pop hl 
2e8f			 
2e8f 7e					ld a, (hl) 
2e90 3d					dec a 
2e91 77					ld (hl), a 
2e92					 
2e92					NEXTW 
2e92 c3 28 1f			jp macro_next 
2e95				endm 
# End of macro NEXTW
2e95			.SBWSTORE: 
2e95				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
2e95 6f				db WORD_SYS_CORE+91             
2e96 b3 2e			dw .ENDCORE            
2e98 05				db 4 + 1 
2e99 .. 00			db "1-2!",0              
2e9e				endm 
# End of macro CWHEAD
2e9e			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
2e9e			 
2e9e					FORTH_DSP_VALUEHL 
2e9e cd 72 1d			call macro_dsp_valuehl 
2ea1				endm 
# End of macro FORTH_DSP_VALUEHL
2ea1 e5					push hl 
2ea2			 
2ea2					FORTH_DSP_POP 
2ea2 cd 2a 1e			call macro_forth_dsp_pop 
2ea5				endm 
# End of macro FORTH_DSP_POP
2ea5 e1					pop hl 
2ea6			 
2ea6 e5					push hl 
2ea7			 
2ea7 cd aa 1e				call loadwordinhl 
2eaa 2b					dec hl 
2eab			 
2eab d1					pop de 
2eac eb					ex de, hl 
2ead 73					ld (hl), e 
2eae 23					inc hl 
2eaf 72					ld (hl), d 
2eb0					 
2eb0					NEXTW 
2eb0 c3 28 1f			jp macro_next 
2eb3				endm 
# End of macro NEXTW
2eb3			.ENDCORE: 
2eb3			 
2eb3			; eof 
2eb3			 
2eb3			 
# End of file forth_words_core.asm
2eb3			include "forth_words_flow.asm" 
2eb3			 
2eb3			; | ## Program Flow Words 
2eb3			 
2eb3			.IF: 
2eb3				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2eb3 1e				db WORD_SYS_CORE+10             
2eb4 a8 2f			dw .THEN            
2eb6 03				db 2 + 1 
2eb7 .. 00			db "IF",0              
2eba				endm 
# End of macro CWHEAD
2eba			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2eba			; 
2eba					if DEBUG_FORTH_WORDS_KEY 
2eba						DMARK "IF." 
2eba f5				push af  
2ebb 3a cf 2e			ld a, (.dmark)  
2ebe 32 6b ee			ld (debug_mark),a  
2ec1 3a d0 2e			ld a, (.dmark+1)  
2ec4 32 6c ee			ld (debug_mark+1),a  
2ec7 3a d1 2e			ld a, (.dmark+2)  
2eca 32 6d ee			ld (debug_mark+2),a  
2ecd 18 03			jr .pastdmark  
2ecf ..			.dmark: db "IF."  
2ed2 f1			.pastdmark: pop af  
2ed3			endm  
# End of macro DMARK
2ed3						CALLMONITOR 
2ed3 cd 6f ee			call debug_vector  
2ed6				endm  
# End of macro CALLMONITOR
2ed6					endif 
2ed6			; eval TOS 
2ed6			 
2ed6				FORTH_DSP_VALUEHL 
2ed6 cd 72 1d			call macro_dsp_valuehl 
2ed9				endm 
# End of macro FORTH_DSP_VALUEHL
2ed9			 
2ed9			;	push hl 
2ed9				FORTH_DSP_POP 
2ed9 cd 2a 1e			call macro_forth_dsp_pop 
2edc				endm 
# End of macro FORTH_DSP_POP
2edc			;	pop hl 
2edc			 
2edc					if DEBUG_FORTH_WORDS 
2edc						DMARK "IF1" 
2edc f5				push af  
2edd 3a f1 2e			ld a, (.dmark)  
2ee0 32 6b ee			ld (debug_mark),a  
2ee3 3a f2 2e			ld a, (.dmark+1)  
2ee6 32 6c ee			ld (debug_mark+1),a  
2ee9 3a f3 2e			ld a, (.dmark+2)  
2eec 32 6d ee			ld (debug_mark+2),a  
2eef 18 03			jr .pastdmark  
2ef1 ..			.dmark: db "IF1"  
2ef4 f1			.pastdmark: pop af  
2ef5			endm  
# End of macro DMARK
2ef5						CALLMONITOR 
2ef5 cd 6f ee			call debug_vector  
2ef8				endm  
# End of macro CALLMONITOR
2ef8					endif 
2ef8 b7				or a        ; clear carry flag 
2ef9 11 00 00			ld de, 0 
2efc eb				ex de,hl 
2efd ed 52			sbc hl, de 
2eff c2 89 2f			jp nz, .iftrue 
2f02			 
2f02					if DEBUG_FORTH_WORDS 
2f02						DMARK "IF2" 
2f02 f5				push af  
2f03 3a 17 2f			ld a, (.dmark)  
2f06 32 6b ee			ld (debug_mark),a  
2f09 3a 18 2f			ld a, (.dmark+1)  
2f0c 32 6c ee			ld (debug_mark+1),a  
2f0f 3a 19 2f			ld a, (.dmark+2)  
2f12 32 6d ee			ld (debug_mark+2),a  
2f15 18 03			jr .pastdmark  
2f17 ..			.dmark: db "IF2"  
2f1a f1			.pastdmark: pop af  
2f1b			endm  
# End of macro DMARK
2f1b						CALLMONITOR 
2f1b cd 6f ee			call debug_vector  
2f1e				endm  
# End of macro CALLMONITOR
2f1e					endif 
2f1e			 
2f1e			; if not true then skip to THEN 
2f1e			 
2f1e				; TODO get tok_ptr 
2f1e				; TODO consume toks until we get to THEN 
2f1e			 
2f1e 2a c2 e5			ld hl, (os_tok_ptr) 
2f21					if DEBUG_FORTH_WORDS 
2f21						DMARK "IF3" 
2f21 f5				push af  
2f22 3a 36 2f			ld a, (.dmark)  
2f25 32 6b ee			ld (debug_mark),a  
2f28 3a 37 2f			ld a, (.dmark+1)  
2f2b 32 6c ee			ld (debug_mark+1),a  
2f2e 3a 38 2f			ld a, (.dmark+2)  
2f31 32 6d ee			ld (debug_mark+2),a  
2f34 18 03			jr .pastdmark  
2f36 ..			.dmark: db "IF3"  
2f39 f1			.pastdmark: pop af  
2f3a			endm  
# End of macro DMARK
2f3a						CALLMONITOR 
2f3a cd 6f ee			call debug_vector  
2f3d				endm  
# End of macro CALLMONITOR
2f3d						 
2f3d					endif 
2f3d 11 84 2f			ld de, .ifthen 
2f40					if DEBUG_FORTH_WORDS 
2f40						DMARK "IF4" 
2f40 f5				push af  
2f41 3a 55 2f			ld a, (.dmark)  
2f44 32 6b ee			ld (debug_mark),a  
2f47 3a 56 2f			ld a, (.dmark+1)  
2f4a 32 6c ee			ld (debug_mark+1),a  
2f4d 3a 57 2f			ld a, (.dmark+2)  
2f50 32 6d ee			ld (debug_mark+2),a  
2f53 18 03			jr .pastdmark  
2f55 ..			.dmark: db "IF4"  
2f58 f1			.pastdmark: pop af  
2f59			endm  
# End of macro DMARK
2f59						CALLMONITOR 
2f59 cd 6f ee			call debug_vector  
2f5c				endm  
# End of macro CALLMONITOR
2f5c					endif 
2f5c cd 43 20			call findnexttok  
2f5f			 
2f5f					if DEBUG_FORTH_WORDS 
2f5f						DMARK "IF5" 
2f5f f5				push af  
2f60 3a 74 2f			ld a, (.dmark)  
2f63 32 6b ee			ld (debug_mark),a  
2f66 3a 75 2f			ld a, (.dmark+1)  
2f69 32 6c ee			ld (debug_mark+1),a  
2f6c 3a 76 2f			ld a, (.dmark+2)  
2f6f 32 6d ee			ld (debug_mark+2),a  
2f72 18 03			jr .pastdmark  
2f74 ..			.dmark: db "IF5"  
2f77 f1			.pastdmark: pop af  
2f78			endm  
# End of macro DMARK
2f78						CALLMONITOR 
2f78 cd 6f ee			call debug_vector  
2f7b				endm  
# End of macro CALLMONITOR
2f7b					endif 
2f7b				; TODO replace below with ; exec using tok_ptr 
2f7b 22 c2 e5			ld (os_tok_ptr), hl 
2f7e c3 b9 1f			jp exec1 
2f81				NEXTW 
2f81 c3 28 1f			jp macro_next 
2f84				endm 
# End of macro NEXTW
2f84			 
2f84 .. 00		.ifthen:  db "THEN",0 
2f89			 
2f89			.iftrue:		 
2f89				; Exec next words normally 
2f89			 
2f89				; if true then exec following IF as normal 
2f89					if DEBUG_FORTH_WORDS 
2f89						DMARK "IFT" 
2f89 f5				push af  
2f8a 3a 9e 2f			ld a, (.dmark)  
2f8d 32 6b ee			ld (debug_mark),a  
2f90 3a 9f 2f			ld a, (.dmark+1)  
2f93 32 6c ee			ld (debug_mark+1),a  
2f96 3a a0 2f			ld a, (.dmark+2)  
2f99 32 6d ee			ld (debug_mark+2),a  
2f9c 18 03			jr .pastdmark  
2f9e ..			.dmark: db "IFT"  
2fa1 f1			.pastdmark: pop af  
2fa2			endm  
# End of macro DMARK
2fa2						CALLMONITOR 
2fa2 cd 6f ee			call debug_vector  
2fa5				endm  
# End of macro CALLMONITOR
2fa5					endif 
2fa5			 
2fa5					NEXTW 
2fa5 c3 28 1f			jp macro_next 
2fa8				endm 
# End of macro NEXTW
2fa8			.THEN: 
2fa8				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2fa8 1f				db WORD_SYS_CORE+11             
2fa9 d0 2f			dw .ELSE            
2fab 05				db 4 + 1 
2fac .. 00			db "THEN",0              
2fb1				endm 
# End of macro CWHEAD
2fb1			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2fb1					if DEBUG_FORTH_WORDS_KEY 
2fb1						DMARK "THN" 
2fb1 f5				push af  
2fb2 3a c6 2f			ld a, (.dmark)  
2fb5 32 6b ee			ld (debug_mark),a  
2fb8 3a c7 2f			ld a, (.dmark+1)  
2fbb 32 6c ee			ld (debug_mark+1),a  
2fbe 3a c8 2f			ld a, (.dmark+2)  
2fc1 32 6d ee			ld (debug_mark+2),a  
2fc4 18 03			jr .pastdmark  
2fc6 ..			.dmark: db "THN"  
2fc9 f1			.pastdmark: pop af  
2fca			endm  
# End of macro DMARK
2fca						CALLMONITOR 
2fca cd 6f ee			call debug_vector  
2fcd				endm  
# End of macro CALLMONITOR
2fcd					endif 
2fcd					NEXTW 
2fcd c3 28 1f			jp macro_next 
2fd0				endm 
# End of macro NEXTW
2fd0			.ELSE: 
2fd0				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2fd0 20				db WORD_SYS_CORE+12             
2fd1 f8 2f			dw .DO            
2fd3 03				db 2 + 1 
2fd4 .. 00			db "ELSE",0              
2fd9				endm 
# End of macro CWHEAD
2fd9			; | ELSE ( -- ) Not supported - does nothing | TODO 
2fd9			 
2fd9					if DEBUG_FORTH_WORDS_KEY 
2fd9						DMARK "ELS" 
2fd9 f5				push af  
2fda 3a ee 2f			ld a, (.dmark)  
2fdd 32 6b ee			ld (debug_mark),a  
2fe0 3a ef 2f			ld a, (.dmark+1)  
2fe3 32 6c ee			ld (debug_mark+1),a  
2fe6 3a f0 2f			ld a, (.dmark+2)  
2fe9 32 6d ee			ld (debug_mark+2),a  
2fec 18 03			jr .pastdmark  
2fee ..			.dmark: db "ELS"  
2ff1 f1			.pastdmark: pop af  
2ff2			endm  
# End of macro DMARK
2ff2						CALLMONITOR 
2ff2 cd 6f ee			call debug_vector  
2ff5				endm  
# End of macro CALLMONITOR
2ff5					endif 
2ff5			 
2ff5			 
2ff5					NEXTW 
2ff5 c3 28 1f			jp macro_next 
2ff8				endm 
# End of macro NEXTW
2ff8			.DO: 
2ff8				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2ff8 21				db WORD_SYS_CORE+13             
2ff9 1f 31			dw .LOOP            
2ffb 03				db 2 + 1 
2ffc .. 00			db "DO",0              
2fff				endm 
# End of macro CWHEAD
2fff			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2fff			 
2fff					if DEBUG_FORTH_WORDS_KEY 
2fff						DMARK "DO." 
2fff f5				push af  
3000 3a 14 30			ld a, (.dmark)  
3003 32 6b ee			ld (debug_mark),a  
3006 3a 15 30			ld a, (.dmark+1)  
3009 32 6c ee			ld (debug_mark+1),a  
300c 3a 16 30			ld a, (.dmark+2)  
300f 32 6d ee			ld (debug_mark+2),a  
3012 18 03			jr .pastdmark  
3014 ..			.dmark: db "DO."  
3017 f1			.pastdmark: pop af  
3018			endm  
# End of macro DMARK
3018						CALLMONITOR 
3018 cd 6f ee			call debug_vector  
301b				endm  
# End of macro CALLMONITOR
301b					endif 
301b			;  push pc to rsp stack past the DO 
301b			 
301b 2a c2 e5				ld hl, (os_tok_ptr) 
301e 23					inc hl   ; D 
301f 23					inc hl  ; O 
3020 23					inc hl   ; null 
3021					if DEBUG_FORTH_WORDS 
3021						DMARK "DO2" 
3021 f5				push af  
3022 3a 36 30			ld a, (.dmark)  
3025 32 6b ee			ld (debug_mark),a  
3028 3a 37 30			ld a, (.dmark+1)  
302b 32 6c ee			ld (debug_mark+1),a  
302e 3a 38 30			ld a, (.dmark+2)  
3031 32 6d ee			ld (debug_mark+2),a  
3034 18 03			jr .pastdmark  
3036 ..			.dmark: db "DO2"  
3039 f1			.pastdmark: pop af  
303a			endm  
# End of macro DMARK
303a						CALLMONITOR 
303a cd 6f ee			call debug_vector  
303d				endm  
# End of macro CALLMONITOR
303d					endif 
303d					FORTH_RSP_NEXT 
303d cd 14 1b			call macro_forth_rsp_next 
3040				endm 
# End of macro FORTH_RSP_NEXT
3040					if DEBUG_FORTH_WORDS 
3040						DMARK "DO3" 
3040 f5				push af  
3041 3a 55 30			ld a, (.dmark)  
3044 32 6b ee			ld (debug_mark),a  
3047 3a 56 30			ld a, (.dmark+1)  
304a 32 6c ee			ld (debug_mark+1),a  
304d 3a 57 30			ld a, (.dmark+2)  
3050 32 6d ee			ld (debug_mark+2),a  
3053 18 03			jr .pastdmark  
3055 ..			.dmark: db "DO3"  
3058 f1			.pastdmark: pop af  
3059			endm  
# End of macro DMARK
3059						CALLMONITOR 
3059 cd 6f ee			call debug_vector  
305c				endm  
# End of macro CALLMONITOR
305c					endif 
305c			 
305c					;if DEBUG_FORTH_WORDS 
305c				;		push hl 
305c			;		endif  
305c			 
305c			; get counters from data stack 
305c			 
305c			 
305c					FORTH_DSP_VALUEHL 
305c cd 72 1d			call macro_dsp_valuehl 
305f				endm 
# End of macro FORTH_DSP_VALUEHL
305f e5					push hl		 ; hl now has starting counter which needs to be tos 
3060			 
3060					if DEBUG_FORTH_WORDS 
3060						DMARK "DO4" 
3060 f5				push af  
3061 3a 75 30			ld a, (.dmark)  
3064 32 6b ee			ld (debug_mark),a  
3067 3a 76 30			ld a, (.dmark+1)  
306a 32 6c ee			ld (debug_mark+1),a  
306d 3a 77 30			ld a, (.dmark+2)  
3070 32 6d ee			ld (debug_mark+2),a  
3073 18 03			jr .pastdmark  
3075 ..			.dmark: db "DO4"  
3078 f1			.pastdmark: pop af  
3079			endm  
# End of macro DMARK
3079						CALLMONITOR 
3079 cd 6f ee			call debug_vector  
307c				endm  
# End of macro CALLMONITOR
307c					endif 
307c					FORTH_DSP_POP 
307c cd 2a 1e			call macro_forth_dsp_pop 
307f				endm 
# End of macro FORTH_DSP_POP
307f			 
307f					if DEBUG_FORTH_WORDS 
307f						DMARK "DO5" 
307f f5				push af  
3080 3a 94 30			ld a, (.dmark)  
3083 32 6b ee			ld (debug_mark),a  
3086 3a 95 30			ld a, (.dmark+1)  
3089 32 6c ee			ld (debug_mark+1),a  
308c 3a 96 30			ld a, (.dmark+2)  
308f 32 6d ee			ld (debug_mark+2),a  
3092 18 03			jr .pastdmark  
3094 ..			.dmark: db "DO5"  
3097 f1			.pastdmark: pop af  
3098			endm  
# End of macro DMARK
3098						CALLMONITOR 
3098 cd 6f ee			call debug_vector  
309b				endm  
# End of macro CALLMONITOR
309b					endif 
309b			 
309b					FORTH_DSP_VALUEHL 
309b cd 72 1d			call macro_dsp_valuehl 
309e				endm 
# End of macro FORTH_DSP_VALUEHL
309e			;		push hl		 ; hl now has starting limit counter 
309e			 
309e					if DEBUG_FORTH_WORDS 
309e						DMARK "DO6" 
309e f5				push af  
309f 3a b3 30			ld a, (.dmark)  
30a2 32 6b ee			ld (debug_mark),a  
30a5 3a b4 30			ld a, (.dmark+1)  
30a8 32 6c ee			ld (debug_mark+1),a  
30ab 3a b5 30			ld a, (.dmark+2)  
30ae 32 6d ee			ld (debug_mark+2),a  
30b1 18 03			jr .pastdmark  
30b3 ..			.dmark: db "DO6"  
30b6 f1			.pastdmark: pop af  
30b7			endm  
# End of macro DMARK
30b7						CALLMONITOR 
30b7 cd 6f ee			call debug_vector  
30ba				endm  
# End of macro CALLMONITOR
30ba					endif 
30ba					FORTH_DSP_POP 
30ba cd 2a 1e			call macro_forth_dsp_pop 
30bd				endm 
# End of macro FORTH_DSP_POP
30bd			 
30bd			; put counters on the loop stack 
30bd			 
30bd			;		pop hl			 ; limit counter 
30bd d1					pop de			; start counter 
30be			 
30be					; push limit counter 
30be			 
30be					if DEBUG_FORTH_WORDS 
30be						DMARK "DO7" 
30be f5				push af  
30bf 3a d3 30			ld a, (.dmark)  
30c2 32 6b ee			ld (debug_mark),a  
30c5 3a d4 30			ld a, (.dmark+1)  
30c8 32 6c ee			ld (debug_mark+1),a  
30cb 3a d5 30			ld a, (.dmark+2)  
30ce 32 6d ee			ld (debug_mark+2),a  
30d1 18 03			jr .pastdmark  
30d3 ..			.dmark: db "DO7"  
30d6 f1			.pastdmark: pop af  
30d7			endm  
# End of macro DMARK
30d7						CALLMONITOR 
30d7 cd 6f ee			call debug_vector  
30da				endm  
# End of macro CALLMONITOR
30da					endif 
30da					FORTH_LOOP_NEXT 
30da cd a3 1d			call macro_forth_loop_next 
30dd				endm 
# End of macro FORTH_LOOP_NEXT
30dd			 
30dd					; push start counter 
30dd			 
30dd eb					ex de, hl 
30de					if DEBUG_FORTH_WORDS 
30de						DMARK "DO7" 
30de f5				push af  
30df 3a f3 30			ld a, (.dmark)  
30e2 32 6b ee			ld (debug_mark),a  
30e5 3a f4 30			ld a, (.dmark+1)  
30e8 32 6c ee			ld (debug_mark+1),a  
30eb 3a f5 30			ld a, (.dmark+2)  
30ee 32 6d ee			ld (debug_mark+2),a  
30f1 18 03			jr .pastdmark  
30f3 ..			.dmark: db "DO7"  
30f6 f1			.pastdmark: pop af  
30f7			endm  
# End of macro DMARK
30f7						CALLMONITOR 
30f7 cd 6f ee			call debug_vector  
30fa				endm  
# End of macro CALLMONITOR
30fa					endif 
30fa					FORTH_LOOP_NEXT 
30fa cd a3 1d			call macro_forth_loop_next 
30fd				endm 
# End of macro FORTH_LOOP_NEXT
30fd			 
30fd			 
30fd					; init first round of I counter 
30fd			 
30fd 22 e6 e5				ld (os_current_i), hl 
3100			 
3100					if DEBUG_FORTH_WORDS 
3100						DMARK "DO8" 
3100 f5				push af  
3101 3a 15 31			ld a, (.dmark)  
3104 32 6b ee			ld (debug_mark),a  
3107 3a 16 31			ld a, (.dmark+1)  
310a 32 6c ee			ld (debug_mark+1),a  
310d 3a 17 31			ld a, (.dmark+2)  
3110 32 6d ee			ld (debug_mark+2),a  
3113 18 03			jr .pastdmark  
3115 ..			.dmark: db "DO8"  
3118 f1			.pastdmark: pop af  
3119			endm  
# End of macro DMARK
3119						CALLMONITOR 
3119 cd 6f ee			call debug_vector  
311c				endm  
# End of macro CALLMONITOR
311c					endif 
311c			 
311c					NEXTW 
311c c3 28 1f			jp macro_next 
311f				endm 
# End of macro NEXTW
311f			.LOOP: 
311f				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
311f 22				db WORD_SYS_CORE+14             
3120 37 32			dw .I            
3122 05				db 4 + 1 
3123 .. 00			db "LOOP",0              
3128				endm 
# End of macro CWHEAD
3128			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3128			 
3128				; pop tos as current loop count to hl 
3128			 
3128				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3128			 
3128				FORTH_LOOP_TOS 
3128 cd d6 1d			call macro_forth_loop_tos 
312b				endm 
# End of macro FORTH_LOOP_TOS
312b e5				push hl 
312c			 
312c					if DEBUG_FORTH_WORDS_KEY 
312c						DMARK "LOP" 
312c f5				push af  
312d 3a 41 31			ld a, (.dmark)  
3130 32 6b ee			ld (debug_mark),a  
3133 3a 42 31			ld a, (.dmark+1)  
3136 32 6c ee			ld (debug_mark+1),a  
3139 3a 43 31			ld a, (.dmark+2)  
313c 32 6d ee			ld (debug_mark+2),a  
313f 18 03			jr .pastdmark  
3141 ..			.dmark: db "LOP"  
3144 f1			.pastdmark: pop af  
3145			endm  
# End of macro DMARK
3145						CALLMONITOR 
3145 cd 6f ee			call debug_vector  
3148				endm  
# End of macro CALLMONITOR
3148					endif 
3148				; next item on the stack is the limit. get it 
3148			 
3148			 
3148				FORTH_LOOP_POP 
3148 cd e0 1d			call macro_forth_loop_pop 
314b				endm 
# End of macro FORTH_LOOP_POP
314b			 
314b				FORTH_LOOP_TOS 
314b cd d6 1d			call macro_forth_loop_tos 
314e				endm 
# End of macro FORTH_LOOP_TOS
314e			 
314e d1				pop de		 ; de = i, hl = limit 
314f			 
314f					if DEBUG_FORTH_WORDS 
314f						DMARK "LP1" 
314f f5				push af  
3150 3a 64 31			ld a, (.dmark)  
3153 32 6b ee			ld (debug_mark),a  
3156 3a 65 31			ld a, (.dmark+1)  
3159 32 6c ee			ld (debug_mark+1),a  
315c 3a 66 31			ld a, (.dmark+2)  
315f 32 6d ee			ld (debug_mark+2),a  
3162 18 03			jr .pastdmark  
3164 ..			.dmark: db "LP1"  
3167 f1			.pastdmark: pop af  
3168			endm  
# End of macro DMARK
3168						CALLMONITOR 
3168 cd 6f ee			call debug_vector  
316b				endm  
# End of macro CALLMONITOR
316b					endif 
316b			 
316b				; go back to previous word 
316b			 
316b d5				push de    ; save I for inc later 
316c			 
316c			 
316c				; get limit 
316c				;  is I at limit? 
316c			 
316c			 
316c					if DEBUG_FORTH_WORDS 
316c						DMARK "LP1" 
316c f5				push af  
316d 3a 81 31			ld a, (.dmark)  
3170 32 6b ee			ld (debug_mark),a  
3173 3a 82 31			ld a, (.dmark+1)  
3176 32 6c ee			ld (debug_mark+1),a  
3179 3a 83 31			ld a, (.dmark+2)  
317c 32 6d ee			ld (debug_mark+2),a  
317f 18 03			jr .pastdmark  
3181 ..			.dmark: db "LP1"  
3184 f1			.pastdmark: pop af  
3185			endm  
# End of macro DMARK
3185						CALLMONITOR 
3185 cd 6f ee			call debug_vector  
3188				endm  
# End of macro CALLMONITOR
3188					endif 
3188			 
3188 ed 52			sbc hl, de 
318a			 
318a			 
318a				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
318a			 
318a 20 26				jr nz, .loopnotdone 
318c			 
318c e1				pop hl   ; get rid of saved I 
318d				FORTH_LOOP_POP     ; get rid of limit 
318d cd e0 1d			call macro_forth_loop_pop 
3190				endm 
# End of macro FORTH_LOOP_POP
3190			 
3190				FORTH_RSP_POP     ; get rid of DO ptr 
3190 cd 35 1b			call macro_forth_rsp_pop 
3193				endm 
# End of macro FORTH_RSP_POP
3193			 
3193			if DEBUG_FORTH_WORDS 
3193						DMARK "LP>" 
3193 f5				push af  
3194 3a a8 31			ld a, (.dmark)  
3197 32 6b ee			ld (debug_mark),a  
319a 3a a9 31			ld a, (.dmark+1)  
319d 32 6c ee			ld (debug_mark+1),a  
31a0 3a aa 31			ld a, (.dmark+2)  
31a3 32 6d ee			ld (debug_mark+2),a  
31a6 18 03			jr .pastdmark  
31a8 ..			.dmark: db "LP>"  
31ab f1			.pastdmark: pop af  
31ac			endm  
# End of macro DMARK
31ac				CALLMONITOR 
31ac cd 6f ee			call debug_vector  
31af				endm  
# End of macro CALLMONITOR
31af			endif 
31af			 
31af					NEXTW 
31af c3 28 1f			jp macro_next 
31b2				endm 
# End of macro NEXTW
31b2				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
31b2			 
31b2			.loopnotdone: 
31b2			 
31b2 e1				pop hl    ; get I 
31b3 23				inc hl 
31b4			 
31b4			   	; save new I 
31b4			 
31b4			 
31b4					; set I counter 
31b4			 
31b4 22 e6 e5				ld (os_current_i), hl 
31b7			 
31b7					if DEBUG_FORTH_WORDS 
31b7						DMARK "LPN" 
31b7 f5				push af  
31b8 3a cc 31			ld a, (.dmark)  
31bb 32 6b ee			ld (debug_mark),a  
31be 3a cd 31			ld a, (.dmark+1)  
31c1 32 6c ee			ld (debug_mark+1),a  
31c4 3a ce 31			ld a, (.dmark+2)  
31c7 32 6d ee			ld (debug_mark+2),a  
31ca 18 03			jr .pastdmark  
31cc ..			.dmark: db "LPN"  
31cf f1			.pastdmark: pop af  
31d0			endm  
# End of macro DMARK
31d0					CALLMONITOR 
31d0 cd 6f ee			call debug_vector  
31d3				endm  
# End of macro CALLMONITOR
31d3					endif 
31d3					 
31d3				FORTH_LOOP_NEXT 
31d3 cd a3 1d			call macro_forth_loop_next 
31d6				endm 
# End of macro FORTH_LOOP_NEXT
31d6			 
31d6			 
31d6					if DEBUG_FORTH_WORDS 
31d6 eb						ex de,hl 
31d7					endif 
31d7			 
31d7			;	; get DO ptr 
31d7			; 
31d7					if DEBUG_FORTH_WORDS 
31d7						DMARK "LP7" 
31d7 f5				push af  
31d8 3a ec 31			ld a, (.dmark)  
31db 32 6b ee			ld (debug_mark),a  
31de 3a ed 31			ld a, (.dmark+1)  
31e1 32 6c ee			ld (debug_mark+1),a  
31e4 3a ee 31			ld a, (.dmark+2)  
31e7 32 6d ee			ld (debug_mark+2),a  
31ea 18 03			jr .pastdmark  
31ec ..			.dmark: db "LP7"  
31ef f1			.pastdmark: pop af  
31f0			endm  
# End of macro DMARK
31f0					CALLMONITOR 
31f0 cd 6f ee			call debug_vector  
31f3				endm  
# End of macro CALLMONITOR
31f3					endif 
31f3				FORTH_RSP_TOS 
31f3 cd 2b 1b			call macro_forth_rsp_tos 
31f6				endm 
# End of macro FORTH_RSP_TOS
31f6			 
31f6					if DEBUG_FORTH_WORDS 
31f6						DMARK "LP8" 
31f6 f5				push af  
31f7 3a 0b 32			ld a, (.dmark)  
31fa 32 6b ee			ld (debug_mark),a  
31fd 3a 0c 32			ld a, (.dmark+1)  
3200 32 6c ee			ld (debug_mark+1),a  
3203 3a 0d 32			ld a, (.dmark+2)  
3206 32 6d ee			ld (debug_mark+2),a  
3209 18 03			jr .pastdmark  
320b ..			.dmark: db "LP8"  
320e f1			.pastdmark: pop af  
320f			endm  
# End of macro DMARK
320f					CALLMONITOR 
320f cd 6f ee			call debug_vector  
3212				endm  
# End of macro CALLMONITOR
3212					endif 
3212				;push hl 
3212			 
3212				; not going to DO any more 
3212				; get rid of the RSP pointer as DO will add it back in 
3212				;FORTH_RSP_POP 
3212				;pop hl 
3212			 
3212				;ld hl,(cli_ret_sp) 
3212				;ld e, (hl) 
3212				;inc hl 
3212				;ld d, (hl) 
3212				;ex de,hl 
3212 22 c2 e5			ld (os_tok_ptr), hl 
3215					if DEBUG_FORTH_WORDS 
3215						DMARK "LP<" 
3215 f5				push af  
3216 3a 2a 32			ld a, (.dmark)  
3219 32 6b ee			ld (debug_mark),a  
321c 3a 2b 32			ld a, (.dmark+1)  
321f 32 6c ee			ld (debug_mark+1),a  
3222 3a 2c 32			ld a, (.dmark+2)  
3225 32 6d ee			ld (debug_mark+2),a  
3228 18 03			jr .pastdmark  
322a ..			.dmark: db "LP<"  
322d f1			.pastdmark: pop af  
322e			endm  
# End of macro DMARK
322e					CALLMONITOR 
322e cd 6f ee			call debug_vector  
3231				endm  
# End of macro CALLMONITOR
3231				endif 
3231 c3 b9 1f			jp exec1 
3234			 
3234					 
3234			 
3234			 
3234					NEXTW 
3234 c3 28 1f			jp macro_next 
3237				endm 
# End of macro NEXTW
3237			.I:  
3237			 
3237				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3237 5e				db WORD_SYS_CORE+74             
3238 62 32			dw .DLOOP            
323a 02				db 1 + 1 
323b .. 00			db "I",0              
323d				endm 
# End of macro CWHEAD
323d			; | I ( -- ) Current loop counter | DONE 
323d					if DEBUG_FORTH_WORDS_KEY 
323d						DMARK "I.." 
323d f5				push af  
323e 3a 52 32			ld a, (.dmark)  
3241 32 6b ee			ld (debug_mark),a  
3244 3a 53 32			ld a, (.dmark+1)  
3247 32 6c ee			ld (debug_mark+1),a  
324a 3a 54 32			ld a, (.dmark+2)  
324d 32 6d ee			ld (debug_mark+2),a  
3250 18 03			jr .pastdmark  
3252 ..			.dmark: db "I.."  
3255 f1			.pastdmark: pop af  
3256			endm  
# End of macro DMARK
3256						CALLMONITOR 
3256 cd 6f ee			call debug_vector  
3259				endm  
# End of macro CALLMONITOR
3259					endif 
3259			 
3259 2a e6 e5				ld hl,(os_current_i) 
325c cd 6d 1b				call forth_push_numhl 
325f			 
325f					NEXTW 
325f c3 28 1f			jp macro_next 
3262				endm 
# End of macro NEXTW
3262			.DLOOP: 
3262				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3262 5f				db WORD_SYS_CORE+75             
3263 43 33			dw .REPEAT            
3265 06				db 5 + 1 
3266 .. 00			db "-LOOP",0              
326c				endm 
# End of macro CWHEAD
326c			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
326c				; pop tos as current loop count to hl 
326c					if DEBUG_FORTH_WORDS_KEY 
326c						DMARK "-LP" 
326c f5				push af  
326d 3a 81 32			ld a, (.dmark)  
3270 32 6b ee			ld (debug_mark),a  
3273 3a 82 32			ld a, (.dmark+1)  
3276 32 6c ee			ld (debug_mark+1),a  
3279 3a 83 32			ld a, (.dmark+2)  
327c 32 6d ee			ld (debug_mark+2),a  
327f 18 03			jr .pastdmark  
3281 ..			.dmark: db "-LP"  
3284 f1			.pastdmark: pop af  
3285			endm  
# End of macro DMARK
3285						CALLMONITOR 
3285 cd 6f ee			call debug_vector  
3288				endm  
# End of macro CALLMONITOR
3288					endif 
3288			 
3288				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3288			 
3288				FORTH_LOOP_TOS 
3288 cd d6 1d			call macro_forth_loop_tos 
328b				endm 
# End of macro FORTH_LOOP_TOS
328b e5				push hl 
328c			 
328c					if DEBUG_FORTH_WORDS 
328c						DMARK "-LP" 
328c f5				push af  
328d 3a a1 32			ld a, (.dmark)  
3290 32 6b ee			ld (debug_mark),a  
3293 3a a2 32			ld a, (.dmark+1)  
3296 32 6c ee			ld (debug_mark+1),a  
3299 3a a3 32			ld a, (.dmark+2)  
329c 32 6d ee			ld (debug_mark+2),a  
329f 18 03			jr .pastdmark  
32a1 ..			.dmark: db "-LP"  
32a4 f1			.pastdmark: pop af  
32a5			endm  
# End of macro DMARK
32a5						CALLMONITOR 
32a5 cd 6f ee			call debug_vector  
32a8				endm  
# End of macro CALLMONITOR
32a8					endif 
32a8				; next item on the stack is the limit. get it 
32a8			 
32a8			 
32a8				FORTH_LOOP_POP 
32a8 cd e0 1d			call macro_forth_loop_pop 
32ab				endm 
# End of macro FORTH_LOOP_POP
32ab			 
32ab				FORTH_LOOP_TOS 
32ab cd d6 1d			call macro_forth_loop_tos 
32ae				endm 
# End of macro FORTH_LOOP_TOS
32ae			 
32ae d1				pop de		 ; de = i, hl = limit 
32af			 
32af					if DEBUG_FORTH_WORDS 
32af						DMARK "-L1" 
32af f5				push af  
32b0 3a c4 32			ld a, (.dmark)  
32b3 32 6b ee			ld (debug_mark),a  
32b6 3a c5 32			ld a, (.dmark+1)  
32b9 32 6c ee			ld (debug_mark+1),a  
32bc 3a c6 32			ld a, (.dmark+2)  
32bf 32 6d ee			ld (debug_mark+2),a  
32c2 18 03			jr .pastdmark  
32c4 ..			.dmark: db "-L1"  
32c7 f1			.pastdmark: pop af  
32c8			endm  
# End of macro DMARK
32c8						CALLMONITOR 
32c8 cd 6f ee			call debug_vector  
32cb				endm  
# End of macro CALLMONITOR
32cb					endif 
32cb			 
32cb				; go back to previous word 
32cb			 
32cb d5				push de    ; save I for inc later 
32cc			 
32cc			 
32cc				; get limit 
32cc				;  is I at limit? 
32cc			 
32cc			 
32cc					if DEBUG_FORTH_WORDS 
32cc						DMARK "-L1" 
32cc f5				push af  
32cd 3a e1 32			ld a, (.dmark)  
32d0 32 6b ee			ld (debug_mark),a  
32d3 3a e2 32			ld a, (.dmark+1)  
32d6 32 6c ee			ld (debug_mark+1),a  
32d9 3a e3 32			ld a, (.dmark+2)  
32dc 32 6d ee			ld (debug_mark+2),a  
32df 18 03			jr .pastdmark  
32e1 ..			.dmark: db "-L1"  
32e4 f1			.pastdmark: pop af  
32e5			endm  
# End of macro DMARK
32e5						CALLMONITOR 
32e5 cd 6f ee			call debug_vector  
32e8				endm  
# End of macro CALLMONITOR
32e8					endif 
32e8			 
32e8 ed 52			sbc hl, de 
32ea			 
32ea			 
32ea				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
32ea			 
32ea 20 26				jr nz, .mloopnotdone 
32ec			 
32ec e1				pop hl   ; get rid of saved I 
32ed				FORTH_LOOP_POP     ; get rid of limit 
32ed cd e0 1d			call macro_forth_loop_pop 
32f0				endm 
# End of macro FORTH_LOOP_POP
32f0			 
32f0				FORTH_RSP_POP     ; get rid of DO ptr 
32f0 cd 35 1b			call macro_forth_rsp_pop 
32f3				endm 
# End of macro FORTH_RSP_POP
32f3			 
32f3			if DEBUG_FORTH_WORDS 
32f3						DMARK "-L>" 
32f3 f5				push af  
32f4 3a 08 33			ld a, (.dmark)  
32f7 32 6b ee			ld (debug_mark),a  
32fa 3a 09 33			ld a, (.dmark+1)  
32fd 32 6c ee			ld (debug_mark+1),a  
3300 3a 0a 33			ld a, (.dmark+2)  
3303 32 6d ee			ld (debug_mark+2),a  
3306 18 03			jr .pastdmark  
3308 ..			.dmark: db "-L>"  
330b f1			.pastdmark: pop af  
330c			endm  
# End of macro DMARK
330c				CALLMONITOR 
330c cd 6f ee			call debug_vector  
330f				endm  
# End of macro CALLMONITOR
330f			endif 
330f			 
330f					NEXTW 
330f c3 28 1f			jp macro_next 
3312				endm 
# End of macro NEXTW
3312				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3312			 
3312			.mloopnotdone: 
3312			 
3312 e1				pop hl    ; get I 
3313 2b				dec hl 
3314			 
3314			   	; save new I 
3314			 
3314			 
3314					; set I counter 
3314			 
3314 22 e6 e5				ld (os_current_i), hl 
3317			 
3317					 
3317				FORTH_LOOP_NEXT 
3317 cd a3 1d			call macro_forth_loop_next 
331a				endm 
# End of macro FORTH_LOOP_NEXT
331a			 
331a			 
331a					if DEBUG_FORTH_WORDS 
331a eb						ex de,hl 
331b					endif 
331b			 
331b			;	; get DO ptr 
331b			; 
331b				FORTH_RSP_TOS 
331b cd 2b 1b			call macro_forth_rsp_tos 
331e				endm 
# End of macro FORTH_RSP_TOS
331e			 
331e				;push hl 
331e			 
331e				; not going to DO any more 
331e				; get rid of the RSP pointer as DO will add it back in 
331e				;FORTH_RSP_POP 
331e				;pop hl 
331e			 
331e			 
331e 22 c2 e5			ld (os_tok_ptr), hl 
3321					if DEBUG_FORTH_WORDS 
3321						DMARK "-L<" 
3321 f5				push af  
3322 3a 36 33			ld a, (.dmark)  
3325 32 6b ee			ld (debug_mark),a  
3328 3a 37 33			ld a, (.dmark+1)  
332b 32 6c ee			ld (debug_mark+1),a  
332e 3a 38 33			ld a, (.dmark+2)  
3331 32 6d ee			ld (debug_mark+2),a  
3334 18 03			jr .pastdmark  
3336 ..			.dmark: db "-L<"  
3339 f1			.pastdmark: pop af  
333a			endm  
# End of macro DMARK
333a					CALLMONITOR 
333a cd 6f ee			call debug_vector  
333d				endm  
# End of macro CALLMONITOR
333d				endif 
333d c3 b9 1f			jp exec1 
3340			 
3340					 
3340			 
3340			 
3340			 
3340				NEXTW 
3340 c3 28 1f			jp macro_next 
3343				endm 
# End of macro NEXTW
3343			 
3343			 
3343			 
3343			 
3343			.REPEAT: 
3343				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3343 71				db WORD_SYS_CORE+93             
3344 96 33			dw .UNTIL            
3346 06				db 5 + 1 
3347 .. 00			db "REPEAT",0              
334e				endm 
# End of macro CWHEAD
334e			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
334e			;  push pc to rsp stack past the REPEAT 
334e					if DEBUG_FORTH_WORDS_KEY 
334e						DMARK "REP" 
334e f5				push af  
334f 3a 63 33			ld a, (.dmark)  
3352 32 6b ee			ld (debug_mark),a  
3355 3a 64 33			ld a, (.dmark+1)  
3358 32 6c ee			ld (debug_mark+1),a  
335b 3a 65 33			ld a, (.dmark+2)  
335e 32 6d ee			ld (debug_mark+2),a  
3361 18 03			jr .pastdmark  
3363 ..			.dmark: db "REP"  
3366 f1			.pastdmark: pop af  
3367			endm  
# End of macro DMARK
3367						CALLMONITOR 
3367 cd 6f ee			call debug_vector  
336a				endm  
# End of macro CALLMONITOR
336a					endif 
336a			 
336a 2a c2 e5				ld hl, (os_tok_ptr) 
336d 23					inc hl   ; R 
336e 23					inc hl  ; E 
336f 23					inc hl   ; P 
3370 23					inc hl   ; E 
3371 23					inc hl   ; A 
3372 23					inc hl   ; T 
3373 23					inc hl   ; zero 
3374					FORTH_RSP_NEXT 
3374 cd 14 1b			call macro_forth_rsp_next 
3377				endm 
# End of macro FORTH_RSP_NEXT
3377			 
3377			 
3377					if DEBUG_FORTH_WORDS 
3377						DMARK "REP" 
3377 f5				push af  
3378 3a 8c 33			ld a, (.dmark)  
337b 32 6b ee			ld (debug_mark),a  
337e 3a 8d 33			ld a, (.dmark+1)  
3381 32 6c ee			ld (debug_mark+1),a  
3384 3a 8e 33			ld a, (.dmark+2)  
3387 32 6d ee			ld (debug_mark+2),a  
338a 18 03			jr .pastdmark  
338c ..			.dmark: db "REP"  
338f f1			.pastdmark: pop af  
3390			endm  
# End of macro DMARK
3390						;pop bc    ; TODO BUG ?????? what is this for???? 
3390						CALLMONITOR 
3390 cd 6f ee			call debug_vector  
3393				endm  
# End of macro CALLMONITOR
3393					endif 
3393			 
3393					NEXTW 
3393 c3 28 1f			jp macro_next 
3396				endm 
# End of macro NEXTW
3396			;	       NEXTW 
3396			 
3396			.UNTIL: 
3396				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3396 72				db WORD_SYS_CORE+94             
3397 2d 34			dw .ENDFLOW            
3399 06				db 5 + 1 
339a .. 00			db "UNTIL",0              
33a0				endm 
# End of macro CWHEAD
33a0			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
33a0			 
33a0				; pop tos as check 
33a0			 
33a0				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
33a0			 
33a0				FORTH_DSP_VALUEHL 
33a0 cd 72 1d			call macro_dsp_valuehl 
33a3				endm 
# End of macro FORTH_DSP_VALUEHL
33a3			 
33a3					if DEBUG_FORTH_WORDS_KEY 
33a3						DMARK "UNT" 
33a3 f5				push af  
33a4 3a b8 33			ld a, (.dmark)  
33a7 32 6b ee			ld (debug_mark),a  
33aa 3a b9 33			ld a, (.dmark+1)  
33ad 32 6c ee			ld (debug_mark+1),a  
33b0 3a ba 33			ld a, (.dmark+2)  
33b3 32 6d ee			ld (debug_mark+2),a  
33b6 18 03			jr .pastdmark  
33b8 ..			.dmark: db "UNT"  
33bb f1			.pastdmark: pop af  
33bc			endm  
# End of macro DMARK
33bc						CALLMONITOR 
33bc cd 6f ee			call debug_vector  
33bf				endm  
# End of macro CALLMONITOR
33bf					endif 
33bf			 
33bf			;	push hl 
33bf				FORTH_DSP_POP 
33bf cd 2a 1e			call macro_forth_dsp_pop 
33c2				endm 
# End of macro FORTH_DSP_POP
33c2			 
33c2			;	pop hl 
33c2			 
33c2				; test if true 
33c2			 
33c2 cd 0f 0e			call ishlzero 
33c5			;	ld a,l 
33c5			;	add h 
33c5			; 
33c5			;	cp 0 
33c5			 
33c5 20 3e			jr nz, .untilnotdone 
33c7			 
33c7					if DEBUG_FORTH_WORDS 
33c7						DMARK "UNf" 
33c7 f5				push af  
33c8 3a dc 33			ld a, (.dmark)  
33cb 32 6b ee			ld (debug_mark),a  
33ce 3a dd 33			ld a, (.dmark+1)  
33d1 32 6c ee			ld (debug_mark+1),a  
33d4 3a de 33			ld a, (.dmark+2)  
33d7 32 6d ee			ld (debug_mark+2),a  
33da 18 03			jr .pastdmark  
33dc ..			.dmark: db "UNf"  
33df f1			.pastdmark: pop af  
33e0			endm  
# End of macro DMARK
33e0						CALLMONITOR 
33e0 cd 6f ee			call debug_vector  
33e3				endm  
# End of macro CALLMONITOR
33e3					endif 
33e3			 
33e3			 
33e3			 
33e3				FORTH_RSP_POP     ; get rid of DO ptr 
33e3 cd 35 1b			call macro_forth_rsp_pop 
33e6				endm 
# End of macro FORTH_RSP_POP
33e6			 
33e6			if DEBUG_FORTH_WORDS 
33e6						DMARK "UN>" 
33e6 f5				push af  
33e7 3a fb 33			ld a, (.dmark)  
33ea 32 6b ee			ld (debug_mark),a  
33ed 3a fc 33			ld a, (.dmark+1)  
33f0 32 6c ee			ld (debug_mark+1),a  
33f3 3a fd 33			ld a, (.dmark+2)  
33f6 32 6d ee			ld (debug_mark+2),a  
33f9 18 03			jr .pastdmark  
33fb ..			.dmark: db "UN>"  
33fe f1			.pastdmark: pop af  
33ff			endm  
# End of macro DMARK
33ff				CALLMONITOR 
33ff cd 6f ee			call debug_vector  
3402				endm  
# End of macro CALLMONITOR
3402			endif 
3402			 
3402					NEXTW 
3402 c3 28 1f			jp macro_next 
3405				endm 
# End of macro NEXTW
3405				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3405			 
3405			.untilnotdone: 
3405			 
3405			 
3405			;	; get DO ptr 
3405			; 
3405				FORTH_RSP_TOS 
3405 cd 2b 1b			call macro_forth_rsp_tos 
3408				endm 
# End of macro FORTH_RSP_TOS
3408			 
3408				;push hl 
3408			 
3408				; not going to DO any more 
3408				; get rid of the RSP pointer as DO will add it back in 
3408				;FORTH_RSP_POP 
3408				;pop hl 
3408			 
3408			 
3408 22 c2 e5			ld (os_tok_ptr), hl 
340b					if DEBUG_FORTH_WORDS 
340b						DMARK "UN<" 
340b f5				push af  
340c 3a 20 34			ld a, (.dmark)  
340f 32 6b ee			ld (debug_mark),a  
3412 3a 21 34			ld a, (.dmark+1)  
3415 32 6c ee			ld (debug_mark+1),a  
3418 3a 22 34			ld a, (.dmark+2)  
341b 32 6d ee			ld (debug_mark+2),a  
341e 18 03			jr .pastdmark  
3420 ..			.dmark: db "UN<"  
3423 f1			.pastdmark: pop af  
3424			endm  
# End of macro DMARK
3424					CALLMONITOR 
3424 cd 6f ee			call debug_vector  
3427				endm  
# End of macro CALLMONITOR
3427				endif 
3427 c3 b9 1f			jp exec1 
342a			 
342a					 
342a			 
342a			 
342a					NEXTW 
342a c3 28 1f			jp macro_next 
342d				endm 
# End of macro NEXTW
342d			 
342d			 
342d			.ENDFLOW: 
342d			 
342d			; eof 
342d			 
# End of file forth_words_flow.asm
342d			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
342d			include "forth_words_logic.asm" 
342d			 
342d			; | ## Logic Words 
342d			 
342d			.NOT: 
342d				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
342d 2d				db WORD_SYS_CORE+25             
342e 75 34			dw .IS            
3430 04				db 3 + 1 
3431 .. 00			db "NOT",0              
3435				endm 
# End of macro CWHEAD
3435			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3435					if DEBUG_FORTH_WORDS_KEY 
3435						DMARK "NOT" 
3435 f5				push af  
3436 3a 4a 34			ld a, (.dmark)  
3439 32 6b ee			ld (debug_mark),a  
343c 3a 4b 34			ld a, (.dmark+1)  
343f 32 6c ee			ld (debug_mark+1),a  
3442 3a 4c 34			ld a, (.dmark+2)  
3445 32 6d ee			ld (debug_mark+2),a  
3448 18 03			jr .pastdmark  
344a ..			.dmark: db "NOT"  
344d f1			.pastdmark: pop af  
344e			endm  
# End of macro DMARK
344e						CALLMONITOR 
344e cd 6f ee			call debug_vector  
3451				endm  
# End of macro CALLMONITOR
3451					endif 
3451					FORTH_DSP 
3451 cd 38 1d			call macro_forth_dsp 
3454				endm 
# End of macro FORTH_DSP
3454 7e					ld a,(hl)	; get type of value on TOS 
3455 fe 02				cp DS_TYPE_INUM  
3457 28 03				jr z, .noti 
3459					NEXTW 
3459 c3 28 1f			jp macro_next 
345c				endm 
# End of macro NEXTW
345c			.noti:          FORTH_DSP_VALUEHL 
345c cd 72 1d			call macro_dsp_valuehl 
345f				endm 
# End of macro FORTH_DSP_VALUEHL
345f			;		push hl 
345f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
345f cd 2a 1e			call macro_forth_dsp_pop 
3462				endm 
# End of macro FORTH_DSP_POP
3462			;		pop hl 
3462 3e 00				ld a,0 
3464 bd					cp l 
3465 28 04				jr z, .not2t 
3467 2e 00				ld l, 0 
3469 18 02				jr .notip 
346b			 
346b 2e ff		.not2t:		ld l, 255 
346d			 
346d 26 00		.notip:		ld h, 0	 
346f			 
346f cd 6d 1b				call forth_push_numhl 
3472					NEXTW 
3472 c3 28 1f			jp macro_next 
3475				endm 
# End of macro NEXTW
3475			 
3475			.IS: 
3475				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3475 2d				db WORD_SYS_CORE+25             
3476 9b 34			dw .LZERO            
3478 03				db 2 + 1 
3479 .. 00			db "IS",0              
347c				endm 
# End of macro CWHEAD
347c			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
347c					if DEBUG_FORTH_WORDS_KEY 
347c						DMARK "IS." 
347c f5				push af  
347d 3a 91 34			ld a, (.dmark)  
3480 32 6b ee			ld (debug_mark),a  
3483 3a 92 34			ld a, (.dmark+1)  
3486 32 6c ee			ld (debug_mark+1),a  
3489 3a 93 34			ld a, (.dmark+2)  
348c 32 6d ee			ld (debug_mark+2),a  
348f 18 03			jr .pastdmark  
3491 ..			.dmark: db "IS."  
3494 f1			.pastdmark: pop af  
3495			endm  
# End of macro DMARK
3495						CALLMONITOR 
3495 cd 6f ee			call debug_vector  
3498				endm  
# End of macro CALLMONITOR
3498					endif 
3498					NEXTW 
3498 c3 28 1f			jp macro_next 
349b				endm 
# End of macro NEXTW
349b			.LZERO: 
349b				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
349b 2d				db WORD_SYS_CORE+25             
349c a5 34			dw .TZERO            
349e 03				db 2 + 1 
349f .. 00			db "0<",0              
34a2				endm 
# End of macro CWHEAD
34a2			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
34a2					NEXTW 
34a2 c3 28 1f			jp macro_next 
34a5				endm 
# End of macro NEXTW
34a5			.TZERO: 
34a5				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
34a5 2e				db WORD_SYS_CORE+26             
34a6 ec 34			dw .LESS            
34a8 03				db 2 + 1 
34a9 .. 00			db "0=",0              
34ac				endm 
# End of macro CWHEAD
34ac			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
34ac				; TODO add floating point number detection 
34ac					;v5 FORTH_DSP_VALUE 
34ac					if DEBUG_FORTH_WORDS_KEY 
34ac						DMARK "0=." 
34ac f5				push af  
34ad 3a c1 34			ld a, (.dmark)  
34b0 32 6b ee			ld (debug_mark),a  
34b3 3a c2 34			ld a, (.dmark+1)  
34b6 32 6c ee			ld (debug_mark+1),a  
34b9 3a c3 34			ld a, (.dmark+2)  
34bc 32 6d ee			ld (debug_mark+2),a  
34bf 18 03			jr .pastdmark  
34c1 ..			.dmark: db "0=."  
34c4 f1			.pastdmark: pop af  
34c5			endm  
# End of macro DMARK
34c5						CALLMONITOR 
34c5 cd 6f ee			call debug_vector  
34c8				endm  
# End of macro CALLMONITOR
34c8					endif 
34c8					FORTH_DSP 
34c8 cd 38 1d			call macro_forth_dsp 
34cb				endm 
# End of macro FORTH_DSP
34cb 7e					ld a,(hl)	; get type of value on TOS 
34cc fe 02				cp DS_TYPE_INUM  
34ce 28 00				jr z, .tz_inum 
34d0			 
34d0				if FORTH_ENABLE_FLOATMATH 
34d0					jr .tz_done 
34d0			 
34d0				endif 
34d0					 
34d0			 
34d0			.tz_inum: 
34d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34d0 cd 72 1d			call macro_dsp_valuehl 
34d3				endm 
# End of macro FORTH_DSP_VALUEHL
34d3			 
34d3			;		push hl 
34d3			 
34d3					; destroy value TOS 
34d3			 
34d3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34d3 cd 2a 1e			call macro_forth_dsp_pop 
34d6				endm 
# End of macro FORTH_DSP_POP
34d6			 
34d6			;		pop hl 
34d6			 
34d6 3e 00				ld a,0 
34d8			 
34d8 bd					cp l 
34d9 20 08				jr nz, .tz_notzero 
34db			 
34db bc					cp h 
34dc			 
34dc 20 05				jr nz, .tz_notzero 
34de			 
34de			 
34de 21 01 00				ld hl, FORTH_TRUE 
34e1 18 03				jr .tz_done 
34e3			 
34e3 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
34e6			 
34e6					; push value back onto stack for another op etc 
34e6			 
34e6			.tz_done: 
34e6 cd 6d 1b				call forth_push_numhl 
34e9			 
34e9					NEXTW 
34e9 c3 28 1f			jp macro_next 
34ec				endm 
# End of macro NEXTW
34ec			.LESS: 
34ec				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
34ec 2f				db WORD_SYS_CORE+27             
34ed 55 35			dw .GT            
34ef 02				db 1 + 1 
34f0 .. 00			db "<",0              
34f2				endm 
# End of macro CWHEAD
34f2			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
34f2				; TODO add floating point number detection 
34f2					if DEBUG_FORTH_WORDS_KEY 
34f2						DMARK "LES" 
34f2 f5				push af  
34f3 3a 07 35			ld a, (.dmark)  
34f6 32 6b ee			ld (debug_mark),a  
34f9 3a 08 35			ld a, (.dmark+1)  
34fc 32 6c ee			ld (debug_mark+1),a  
34ff 3a 09 35			ld a, (.dmark+2)  
3502 32 6d ee			ld (debug_mark+2),a  
3505 18 03			jr .pastdmark  
3507 ..			.dmark: db "LES"  
350a f1			.pastdmark: pop af  
350b			endm  
# End of macro DMARK
350b						CALLMONITOR 
350b cd 6f ee			call debug_vector  
350e				endm  
# End of macro CALLMONITOR
350e					endif 
350e					FORTH_DSP 
350e cd 38 1d			call macro_forth_dsp 
3511				endm 
# End of macro FORTH_DSP
3511					;v5 FORTH_DSP_VALUE 
3511 7e					ld a,(hl)	; get type of value on TOS 
3512 fe 02				cp DS_TYPE_INUM  
3514 28 00				jr z, .less_inum 
3516			 
3516				if FORTH_ENABLE_FLOATMATH 
3516					jr .less_done 
3516			 
3516				endif 
3516					 
3516			 
3516			.less_inum: 
3516					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3516 cd 72 1d			call macro_dsp_valuehl 
3519				endm 
# End of macro FORTH_DSP_VALUEHL
3519			 
3519 e5					push hl  ; u2 
351a			 
351a					; destroy value TOS 
351a			 
351a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
351a cd 2a 1e			call macro_forth_dsp_pop 
351d				endm 
# End of macro FORTH_DSP_POP
351d			 
351d			 
351d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
351d cd 72 1d			call macro_dsp_valuehl 
3520				endm 
# End of macro FORTH_DSP_VALUEHL
3520			 
3520 e5					push hl    ; u1 
3521			 
3521					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3521 cd 2a 1e			call macro_forth_dsp_pop 
3524				endm 
# End of macro FORTH_DSP_POP
3524			 
3524			 
3524 b7			 or a      ;clear carry flag 
3525 01 00 00		 ld bc, FORTH_FALSE 
3528 e1			  pop hl    ; u1 
3529 d1			  pop de    ; u2 
352a ed 52		  sbc hl,de 
352c 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
352e			 
352e 01 01 00		 ld bc, FORTH_TRUE 
3531			.lscont:  
3531 c5					push bc 
3532 e1					pop hl 
3533			 
3533					if DEBUG_FORTH_WORDS 
3533						DMARK "LT1" 
3533 f5				push af  
3534 3a 48 35			ld a, (.dmark)  
3537 32 6b ee			ld (debug_mark),a  
353a 3a 49 35			ld a, (.dmark+1)  
353d 32 6c ee			ld (debug_mark+1),a  
3540 3a 4a 35			ld a, (.dmark+2)  
3543 32 6d ee			ld (debug_mark+2),a  
3546 18 03			jr .pastdmark  
3548 ..			.dmark: db "LT1"  
354b f1			.pastdmark: pop af  
354c			endm  
# End of macro DMARK
354c						CALLMONITOR 
354c cd 6f ee			call debug_vector  
354f				endm  
# End of macro CALLMONITOR
354f					endif 
354f cd 6d 1b				call forth_push_numhl 
3552			 
3552					NEXTW 
3552 c3 28 1f			jp macro_next 
3555				endm 
# End of macro NEXTW
3555			.GT: 
3555				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3555 30				db WORD_SYS_CORE+28             
3556 be 35			dw .EQUAL            
3558 02				db 1 + 1 
3559 .. 00			db ">",0              
355b				endm 
# End of macro CWHEAD
355b			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
355b				; TODO add floating point number detection 
355b					if DEBUG_FORTH_WORDS_KEY 
355b						DMARK "GRT" 
355b f5				push af  
355c 3a 70 35			ld a, (.dmark)  
355f 32 6b ee			ld (debug_mark),a  
3562 3a 71 35			ld a, (.dmark+1)  
3565 32 6c ee			ld (debug_mark+1),a  
3568 3a 72 35			ld a, (.dmark+2)  
356b 32 6d ee			ld (debug_mark+2),a  
356e 18 03			jr .pastdmark  
3570 ..			.dmark: db "GRT"  
3573 f1			.pastdmark: pop af  
3574			endm  
# End of macro DMARK
3574						CALLMONITOR 
3574 cd 6f ee			call debug_vector  
3577				endm  
# End of macro CALLMONITOR
3577					endif 
3577					FORTH_DSP 
3577 cd 38 1d			call macro_forth_dsp 
357a				endm 
# End of macro FORTH_DSP
357a					;FORTH_DSP_VALUE 
357a 7e					ld a,(hl)	; get type of value on TOS 
357b fe 02				cp DS_TYPE_INUM  
357d 28 00				jr z, .gt_inum 
357f			 
357f				if FORTH_ENABLE_FLOATMATH 
357f					jr .gt_done 
357f			 
357f				endif 
357f					 
357f			 
357f			.gt_inum: 
357f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
357f cd 72 1d			call macro_dsp_valuehl 
3582				endm 
# End of macro FORTH_DSP_VALUEHL
3582			 
3582 e5					push hl  ; u2 
3583			 
3583					; destroy value TOS 
3583			 
3583					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3583 cd 2a 1e			call macro_forth_dsp_pop 
3586				endm 
# End of macro FORTH_DSP_POP
3586			 
3586			 
3586					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3586 cd 72 1d			call macro_dsp_valuehl 
3589				endm 
# End of macro FORTH_DSP_VALUEHL
3589			 
3589 e5					push hl    ; u1 
358a			 
358a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
358a cd 2a 1e			call macro_forth_dsp_pop 
358d				endm 
# End of macro FORTH_DSP_POP
358d			 
358d			 
358d b7			 or a      ;clear carry flag 
358e 01 00 00		 ld bc, FORTH_FALSE 
3591 e1			  pop hl    ; u1 
3592 d1			  pop de    ; u2 
3593 ed 52		  sbc hl,de 
3595 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3597			 
3597 01 01 00		 ld bc, FORTH_TRUE 
359a			.gtcont:  
359a c5					push bc 
359b e1					pop hl 
359c			 
359c					if DEBUG_FORTH_WORDS 
359c						DMARK "GT1" 
359c f5				push af  
359d 3a b1 35			ld a, (.dmark)  
35a0 32 6b ee			ld (debug_mark),a  
35a3 3a b2 35			ld a, (.dmark+1)  
35a6 32 6c ee			ld (debug_mark+1),a  
35a9 3a b3 35			ld a, (.dmark+2)  
35ac 32 6d ee			ld (debug_mark+2),a  
35af 18 03			jr .pastdmark  
35b1 ..			.dmark: db "GT1"  
35b4 f1			.pastdmark: pop af  
35b5			endm  
# End of macro DMARK
35b5						CALLMONITOR 
35b5 cd 6f ee			call debug_vector  
35b8				endm  
# End of macro CALLMONITOR
35b8					endif 
35b8 cd 6d 1b				call forth_push_numhl 
35bb			 
35bb					NEXTW 
35bb c3 28 1f			jp macro_next 
35be				endm 
# End of macro NEXTW
35be			.EQUAL: 
35be				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
35be 31				db WORD_SYS_CORE+29             
35bf 29 36			dw .ENDLOGIC            
35c1 02				db 1 + 1 
35c2 .. 00			db "=",0              
35c4				endm 
# End of macro CWHEAD
35c4			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
35c4				; TODO add floating point number detection 
35c4					if DEBUG_FORTH_WORDS_KEY 
35c4						DMARK "EQ." 
35c4 f5				push af  
35c5 3a d9 35			ld a, (.dmark)  
35c8 32 6b ee			ld (debug_mark),a  
35cb 3a da 35			ld a, (.dmark+1)  
35ce 32 6c ee			ld (debug_mark+1),a  
35d1 3a db 35			ld a, (.dmark+2)  
35d4 32 6d ee			ld (debug_mark+2),a  
35d7 18 03			jr .pastdmark  
35d9 ..			.dmark: db "EQ."  
35dc f1			.pastdmark: pop af  
35dd			endm  
# End of macro DMARK
35dd						CALLMONITOR 
35dd cd 6f ee			call debug_vector  
35e0				endm  
# End of macro CALLMONITOR
35e0					endif 
35e0					FORTH_DSP 
35e0 cd 38 1d			call macro_forth_dsp 
35e3				endm 
# End of macro FORTH_DSP
35e3					;v5 FORTH_DSP_VALUE 
35e3 7e					ld a,(hl)	; get type of value on TOS 
35e4 fe 02				cp DS_TYPE_INUM  
35e6 28 00				jr z, .eq_inum 
35e8			 
35e8				if FORTH_ENABLE_FLOATMATH 
35e8					jr .eq_done 
35e8			 
35e8				endif 
35e8					 
35e8			 
35e8			.eq_inum: 
35e8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35e8 cd 72 1d			call macro_dsp_valuehl 
35eb				endm 
# End of macro FORTH_DSP_VALUEHL
35eb			 
35eb e5					push hl 
35ec			 
35ec					; destroy value TOS 
35ec			 
35ec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35ec cd 2a 1e			call macro_forth_dsp_pop 
35ef				endm 
# End of macro FORTH_DSP_POP
35ef			 
35ef			 
35ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35ef cd 72 1d			call macro_dsp_valuehl 
35f2				endm 
# End of macro FORTH_DSP_VALUEHL
35f2			 
35f2					; one value on hl get other one back 
35f2			 
35f2 e5					push hl 
35f3			 
35f3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35f3 cd 2a 1e			call macro_forth_dsp_pop 
35f6				endm 
# End of macro FORTH_DSP_POP
35f6			 
35f6 0e 00				ld c, FORTH_FALSE 
35f8			 
35f8 e1					pop hl 
35f9 d1					pop de 
35fa			 
35fa 7b					ld a, e 
35fb bd					cp l 
35fc			 
35fc 20 06				jr nz, .eq_done 
35fe			 
35fe 7a					ld a, d 
35ff bc					cp h 
3600			 
3600 20 02				jr nz, .eq_done 
3602			 
3602 0e 01				ld c, FORTH_TRUE 
3604					 
3604			 
3604			 
3604			.eq_done: 
3604			 
3604					; TODO push value back onto stack for another op etc 
3604			 
3604 26 00				ld h, 0 
3606 69					ld l, c 
3607					if DEBUG_FORTH_WORDS 
3607						DMARK "EQ1" 
3607 f5				push af  
3608 3a 1c 36			ld a, (.dmark)  
360b 32 6b ee			ld (debug_mark),a  
360e 3a 1d 36			ld a, (.dmark+1)  
3611 32 6c ee			ld (debug_mark+1),a  
3614 3a 1e 36			ld a, (.dmark+2)  
3617 32 6d ee			ld (debug_mark+2),a  
361a 18 03			jr .pastdmark  
361c ..			.dmark: db "EQ1"  
361f f1			.pastdmark: pop af  
3620			endm  
# End of macro DMARK
3620						CALLMONITOR 
3620 cd 6f ee			call debug_vector  
3623				endm  
# End of macro CALLMONITOR
3623					endif 
3623 cd 6d 1b				call forth_push_numhl 
3626			 
3626					NEXTW 
3626 c3 28 1f			jp macro_next 
3629				endm 
# End of macro NEXTW
3629			 
3629			 
3629			.ENDLOGIC: 
3629			; eof 
3629			 
3629			 
# End of file forth_words_logic.asm
3629			include "forth_words_maths.asm" 
3629			 
3629			; | ## Maths Words 
3629			 
3629			.PLUS:	 
3629				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3629 15				db WORD_SYS_CORE+1             
362a 87 36			dw .NEG            
362c 02				db 1 + 1 
362d .. 00			db "+",0              
362f				endm 
# End of macro CWHEAD
362f			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
362f					if DEBUG_FORTH_WORDS_KEY 
362f						DMARK "PLU" 
362f f5				push af  
3630 3a 44 36			ld a, (.dmark)  
3633 32 6b ee			ld (debug_mark),a  
3636 3a 45 36			ld a, (.dmark+1)  
3639 32 6c ee			ld (debug_mark+1),a  
363c 3a 46 36			ld a, (.dmark+2)  
363f 32 6d ee			ld (debug_mark+2),a  
3642 18 03			jr .pastdmark  
3644 ..			.dmark: db "PLU"  
3647 f1			.pastdmark: pop af  
3648			endm  
# End of macro DMARK
3648						CALLMONITOR 
3648 cd 6f ee			call debug_vector  
364b				endm  
# End of macro CALLMONITOR
364b					endif 
364b					; add top two values and push back result 
364b			 
364b					;for v5 FORTH_DSP_VALUE 
364b					FORTH_DSP 
364b cd 38 1d			call macro_forth_dsp 
364e				endm 
# End of macro FORTH_DSP
364e 7e					ld a,(hl)	; get type of value on TOS 
364f fe 02				cp DS_TYPE_INUM  
3651 28 03				jr z, .dot_inum 
3653			 
3653					NEXTW 
3653 c3 28 1f			jp macro_next 
3656				endm 
# End of macro NEXTW
3656			 
3656			; float maths 
3656			 
3656				if FORTH_ENABLE_FLOATMATH 
3656						inc hl      ; now at start of numeric as string 
3656			 
3656					if DEBUG_FORTH_MATHS 
3656						DMARK "ADD" 
3656				CALLMONITOR 
3656					endif 
3656			 
3656					;ld ix, hl 
3656					call CON 
3656			 
3656			 
3656					push hl 
3656					 
3656					 
3656			 
3656						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3656			 
3656					; get next number 
3656			 
3656						FORTH_DSP_VALUE 
3656			 
3656						inc hl      ; now at start of numeric as string 
3656			 
3656					;ld ix, hl 
3656					call CON 
3656			 
3656					push hl 
3656			 
3656			 
3656						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3656			 
3656						; TODO do add 
3656			 
3656						call IADD 
3656			 
3656						; TODO get result back as ascii 
3656			 
3656						; TODO push result  
3656			 
3656			 
3656			 
3656						jr .dot_done 
3656				endif 
3656			 
3656			.dot_inum: 
3656			 
3656			 
3656					if DEBUG_FORTH_DOT 
3656						DMARK "+IT" 
3656 f5				push af  
3657 3a 6b 36			ld a, (.dmark)  
365a 32 6b ee			ld (debug_mark),a  
365d 3a 6c 36			ld a, (.dmark+1)  
3660 32 6c ee			ld (debug_mark+1),a  
3663 3a 6d 36			ld a, (.dmark+2)  
3666 32 6d ee			ld (debug_mark+2),a  
3669 18 03			jr .pastdmark  
366b ..			.dmark: db "+IT"  
366e f1			.pastdmark: pop af  
366f			endm  
# End of macro DMARK
366f				CALLMONITOR 
366f cd 6f ee			call debug_vector  
3672				endm  
# End of macro CALLMONITOR
3672					endif 
3672			 
3672					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3672 cd 72 1d			call macro_dsp_valuehl 
3675				endm 
# End of macro FORTH_DSP_VALUEHL
3675			 
3675				; TODO add floating point number detection 
3675			 
3675 e5					push hl 
3676			 
3676					; destroy value TOS 
3676			 
3676					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3676 cd 2a 1e			call macro_forth_dsp_pop 
3679				endm 
# End of macro FORTH_DSP_POP
3679			 
3679			 
3679					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3679 cd 72 1d			call macro_dsp_valuehl 
367c				endm 
# End of macro FORTH_DSP_VALUEHL
367c			 
367c					; one value on hl get other one back 
367c			 
367c d1					pop de 
367d			 
367d					; do the add 
367d			 
367d 19					add hl,de 
367e			 
367e					; save it 
367e			 
367e			;		push hl	 
367e			 
367e					; 
367e			 
367e					; destroy value TOS 
367e			 
367e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
367e cd 2a 1e			call macro_forth_dsp_pop 
3681				endm 
# End of macro FORTH_DSP_POP
3681			 
3681					; TODO push value back onto stack for another op etc 
3681			 
3681			;		pop hl 
3681			 
3681			.dot_done: 
3681 cd 6d 1b				call forth_push_numhl 
3684			 
3684					NEXTW 
3684 c3 28 1f			jp macro_next 
3687				endm 
# End of macro NEXTW
3687			.NEG: 
3687			 
3687				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3687 17				db WORD_SYS_CORE+3             
3688 ca 36			dw .DIV            
368a 02				db 1 + 1 
368b .. 00			db "-",0              
368d				endm 
# End of macro CWHEAD
368d			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
368d					if DEBUG_FORTH_WORDS_KEY 
368d						DMARK "SUB" 
368d f5				push af  
368e 3a a2 36			ld a, (.dmark)  
3691 32 6b ee			ld (debug_mark),a  
3694 3a a3 36			ld a, (.dmark+1)  
3697 32 6c ee			ld (debug_mark+1),a  
369a 3a a4 36			ld a, (.dmark+2)  
369d 32 6d ee			ld (debug_mark+2),a  
36a0 18 03			jr .pastdmark  
36a2 ..			.dmark: db "SUB"  
36a5 f1			.pastdmark: pop af  
36a6			endm  
# End of macro DMARK
36a6						CALLMONITOR 
36a6 cd 6f ee			call debug_vector  
36a9				endm  
# End of macro CALLMONITOR
36a9					endif 
36a9			 
36a9			 
36a9				; TODO add floating point number detection 
36a9					; v5 FORTH_DSP_VALUE 
36a9					FORTH_DSP 
36a9 cd 38 1d			call macro_forth_dsp 
36ac				endm 
# End of macro FORTH_DSP
36ac 7e					ld a,(hl)	; get type of value on TOS 
36ad fe 02				cp DS_TYPE_INUM  
36af 28 03				jr z, .neg_inum 
36b1			 
36b1					NEXTW 
36b1 c3 28 1f			jp macro_next 
36b4				endm 
# End of macro NEXTW
36b4			 
36b4			; float maths 
36b4			 
36b4				if FORTH_ENABLE_FLOATMATH 
36b4					jr .neg_done 
36b4			 
36b4				endif 
36b4					 
36b4			 
36b4			.neg_inum: 
36b4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36b4 cd 72 1d			call macro_dsp_valuehl 
36b7				endm 
# End of macro FORTH_DSP_VALUEHL
36b7			 
36b7 e5					push hl 
36b8			 
36b8					; destroy value TOS 
36b8			 
36b8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36b8 cd 2a 1e			call macro_forth_dsp_pop 
36bb				endm 
# End of macro FORTH_DSP_POP
36bb			 
36bb			 
36bb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36bb cd 72 1d			call macro_dsp_valuehl 
36be				endm 
# End of macro FORTH_DSP_VALUEHL
36be			 
36be					; one value on hl get other one back 
36be			 
36be d1					pop de 
36bf			 
36bf					; do the sub 
36bf			;		ex de, hl 
36bf			 
36bf ed 52				sbc hl,de 
36c1			 
36c1					; save it 
36c1			 
36c1			;		push hl	 
36c1			 
36c1					; 
36c1			 
36c1					; destroy value TOS 
36c1			 
36c1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36c1 cd 2a 1e			call macro_forth_dsp_pop 
36c4				endm 
# End of macro FORTH_DSP_POP
36c4			 
36c4					; TODO push value back onto stack for another op etc 
36c4			 
36c4			;		pop hl 
36c4			 
36c4 cd 6d 1b				call forth_push_numhl 
36c7			.neg_done: 
36c7			 
36c7					NEXTW 
36c7 c3 28 1f			jp macro_next 
36ca				endm 
# End of macro NEXTW
36ca			.DIV: 
36ca				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
36ca 18				db WORD_SYS_CORE+4             
36cb 17 37			dw .MUL            
36cd 02				db 1 + 1 
36ce .. 00			db "/",0              
36d0				endm 
# End of macro CWHEAD
36d0			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
36d0					if DEBUG_FORTH_WORDS_KEY 
36d0						DMARK "DIV" 
36d0 f5				push af  
36d1 3a e5 36			ld a, (.dmark)  
36d4 32 6b ee			ld (debug_mark),a  
36d7 3a e6 36			ld a, (.dmark+1)  
36da 32 6c ee			ld (debug_mark+1),a  
36dd 3a e7 36			ld a, (.dmark+2)  
36e0 32 6d ee			ld (debug_mark+2),a  
36e3 18 03			jr .pastdmark  
36e5 ..			.dmark: db "DIV"  
36e8 f1			.pastdmark: pop af  
36e9			endm  
# End of macro DMARK
36e9						CALLMONITOR 
36e9 cd 6f ee			call debug_vector  
36ec				endm  
# End of macro CALLMONITOR
36ec					endif 
36ec				; TODO add floating point number detection 
36ec					; v5 FORTH_DSP_VALUE 
36ec					FORTH_DSP 
36ec cd 38 1d			call macro_forth_dsp 
36ef				endm 
# End of macro FORTH_DSP
36ef 7e					ld a,(hl)	; get type of value on TOS 
36f0 fe 02				cp DS_TYPE_INUM  
36f2 28 03				jr z, .div_inum 
36f4			 
36f4				if FORTH_ENABLE_FLOATMATH 
36f4					jr .div_done 
36f4			 
36f4				endif 
36f4					NEXTW 
36f4 c3 28 1f			jp macro_next 
36f7				endm 
# End of macro NEXTW
36f7			.div_inum: 
36f7			 
36f7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36f7 cd 72 1d			call macro_dsp_valuehl 
36fa				endm 
# End of macro FORTH_DSP_VALUEHL
36fa			 
36fa e5					push hl    ; to go to bc 
36fb			 
36fb					; destroy value TOS 
36fb			 
36fb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
36fb cd 2a 1e			call macro_forth_dsp_pop 
36fe				endm 
# End of macro FORTH_DSP_POP
36fe			 
36fe			 
36fe					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
36fe cd 72 1d			call macro_dsp_valuehl 
3701				endm 
# End of macro FORTH_DSP_VALUEHL
3701			 
3701					; hl to go to de 
3701			 
3701 e5					push hl 
3702			 
3702 c1					pop bc 
3703 d1					pop de		 
3704			 
3704			 
3704					if DEBUG_FORTH_MATHS 
3704						DMARK "DIV" 
3704				CALLMONITOR 
3704					endif 
3704					; one value on hl but move to a get other one back 
3704			 
3704			        
3704 cd 43 0d			call Div16 
3707			 
3707			;	push af	 
3707 e5				push hl 
3708 c5				push bc 
3709			 
3709					if DEBUG_FORTH_MATHS 
3709						DMARK "DI1" 
3709				CALLMONITOR 
3709					endif 
3709			 
3709					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3709 cd 2a 1e			call macro_forth_dsp_pop 
370c				endm 
# End of macro FORTH_DSP_POP
370c			 
370c			 
370c			 
370c e1					pop hl    ; result 
370d			 
370d cd 6d 1b				call forth_push_numhl 
3710			 
3710 e1					pop hl    ; reminder 
3711			;		ld h,0 
3711			;		ld l,d 
3711			 
3711 cd 6d 1b				call forth_push_numhl 
3714			.div_done: 
3714					NEXTW 
3714 c3 28 1f			jp macro_next 
3717				endm 
# End of macro NEXTW
3717			.MUL: 
3717				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3717 19				db WORD_SYS_CORE+5             
3718 5c 37			dw .MIN            
371a 02				db 1 + 1 
371b .. 00			db "*",0              
371d				endm 
# End of macro CWHEAD
371d			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
371d				; TODO add floating point number detection 
371d					if DEBUG_FORTH_WORDS_KEY 
371d						DMARK "MUL" 
371d f5				push af  
371e 3a 32 37			ld a, (.dmark)  
3721 32 6b ee			ld (debug_mark),a  
3724 3a 33 37			ld a, (.dmark+1)  
3727 32 6c ee			ld (debug_mark+1),a  
372a 3a 34 37			ld a, (.dmark+2)  
372d 32 6d ee			ld (debug_mark+2),a  
3730 18 03			jr .pastdmark  
3732 ..			.dmark: db "MUL"  
3735 f1			.pastdmark: pop af  
3736			endm  
# End of macro DMARK
3736						CALLMONITOR 
3736 cd 6f ee			call debug_vector  
3739				endm  
# End of macro CALLMONITOR
3739					endif 
3739					FORTH_DSP 
3739 cd 38 1d			call macro_forth_dsp 
373c				endm 
# End of macro FORTH_DSP
373c					; v5 FORTH_DSP_VALUE 
373c 7e					ld a,(hl)	; get type of value on TOS 
373d fe 02				cp DS_TYPE_INUM  
373f 28 03				jr z, .mul_inum 
3741			 
3741				if FORTH_ENABLE_FLOATMATH 
3741					jr .mul_done 
3741			 
3741				endif 
3741			 
3741					NEXTW 
3741 c3 28 1f			jp macro_next 
3744				endm 
# End of macro NEXTW
3744			.mul_inum:	 
3744			 
3744					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3744 cd 72 1d			call macro_dsp_valuehl 
3747				endm 
# End of macro FORTH_DSP_VALUEHL
3747			 
3747 e5					push hl 
3748			 
3748					; destroy value TOS 
3748			 
3748					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3748 cd 2a 1e			call macro_forth_dsp_pop 
374b				endm 
# End of macro FORTH_DSP_POP
374b			 
374b			 
374b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
374b cd 72 1d			call macro_dsp_valuehl 
374e				endm 
# End of macro FORTH_DSP_VALUEHL
374e			 
374e					; one value on hl but move to a get other one back 
374e			 
374e 7d					ld a, l 
374f			 
374f d1					pop de 
3750			 
3750					; do the mull 
3750			;		ex de, hl 
3750			 
3750 cd 69 0d				call Mult16 
3753					; save it 
3753			 
3753			;		push hl	 
3753			 
3753					; 
3753			 
3753					; destroy value TOS 
3753			 
3753					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3753 cd 2a 1e			call macro_forth_dsp_pop 
3756				endm 
# End of macro FORTH_DSP_POP
3756			 
3756					; TODO push value back onto stack for another op etc 
3756			 
3756			;		pop hl 
3756			 
3756 cd 6d 1b				call forth_push_numhl 
3759			 
3759			.mul_done: 
3759					NEXTW 
3759 c3 28 1f			jp macro_next 
375c				endm 
# End of macro NEXTW
375c			 
375c			 
375c			 
375c			 
375c			.MIN: 
375c				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
375c 49				db WORD_SYS_CORE+53             
375d dd 37			dw .MAX            
375f 04				db 3 + 1 
3760 .. 00			db "MIN",0              
3764				endm 
# End of macro CWHEAD
3764			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3764					if DEBUG_FORTH_WORDS_KEY 
3764						DMARK "MIN" 
3764 f5				push af  
3765 3a 79 37			ld a, (.dmark)  
3768 32 6b ee			ld (debug_mark),a  
376b 3a 7a 37			ld a, (.dmark+1)  
376e 32 6c ee			ld (debug_mark+1),a  
3771 3a 7b 37			ld a, (.dmark+2)  
3774 32 6d ee			ld (debug_mark+2),a  
3777 18 03			jr .pastdmark  
3779 ..			.dmark: db "MIN"  
377c f1			.pastdmark: pop af  
377d			endm  
# End of macro DMARK
377d						CALLMONITOR 
377d cd 6f ee			call debug_vector  
3780				endm  
# End of macro CALLMONITOR
3780					endif 
3780					; get u2 
3780			 
3780					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3780 cd 72 1d			call macro_dsp_valuehl 
3783				endm 
# End of macro FORTH_DSP_VALUEHL
3783			 
3783 e5					push hl   ; u2 
3784			 
3784					; destroy value TOS 
3784			 
3784					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3784 cd 2a 1e			call macro_forth_dsp_pop 
3787				endm 
# End of macro FORTH_DSP_POP
3787			 
3787					; get u1 
3787			 
3787					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3787 cd 72 1d			call macro_dsp_valuehl 
378a				endm 
# End of macro FORTH_DSP_VALUEHL
378a			 
378a e5					push hl  ; u1 
378b			 
378b					; destroy value TOS 
378b			 
378b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
378b cd 2a 1e			call macro_forth_dsp_pop 
378e				endm 
# End of macro FORTH_DSP_POP
378e			 
378e b7			 or a      ;clear carry flag 
378f e1			  pop hl    ; u1 
3790 d1			  pop de    ; u2 
3791 e5				push hl   ; saved in case hl is lowest 
3792 ed 52		  sbc hl,de 
3794 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3796			 
3796 e1				pop hl 
3797					if DEBUG_FORTH_WORDS 
3797						DMARK "MIN" 
3797 f5				push af  
3798 3a ac 37			ld a, (.dmark)  
379b 32 6b ee			ld (debug_mark),a  
379e 3a ad 37			ld a, (.dmark+1)  
37a1 32 6c ee			ld (debug_mark+1),a  
37a4 3a ae 37			ld a, (.dmark+2)  
37a7 32 6d ee			ld (debug_mark+2),a  
37aa 18 03			jr .pastdmark  
37ac ..			.dmark: db "MIN"  
37af f1			.pastdmark: pop af  
37b0			endm  
# End of macro DMARK
37b0						CALLMONITOR 
37b0 cd 6f ee			call debug_vector  
37b3				endm  
# End of macro CALLMONITOR
37b3					endif 
37b3 cd 6d 1b				call forth_push_numhl 
37b6			 
37b6				       NEXTW 
37b6 c3 28 1f			jp macro_next 
37b9				endm 
# End of macro NEXTW
37b9			 
37b9			.mincont:  
37b9 c1				pop bc   ; tidy up 
37ba eb				ex de , hl  
37bb					if DEBUG_FORTH_WORDS 
37bb						DMARK "MI1" 
37bb f5				push af  
37bc 3a d0 37			ld a, (.dmark)  
37bf 32 6b ee			ld (debug_mark),a  
37c2 3a d1 37			ld a, (.dmark+1)  
37c5 32 6c ee			ld (debug_mark+1),a  
37c8 3a d2 37			ld a, (.dmark+2)  
37cb 32 6d ee			ld (debug_mark+2),a  
37ce 18 03			jr .pastdmark  
37d0 ..			.dmark: db "MI1"  
37d3 f1			.pastdmark: pop af  
37d4			endm  
# End of macro DMARK
37d4						CALLMONITOR 
37d4 cd 6f ee			call debug_vector  
37d7				endm  
# End of macro CALLMONITOR
37d7					endif 
37d7 cd 6d 1b				call forth_push_numhl 
37da			 
37da				       NEXTW 
37da c3 28 1f			jp macro_next 
37dd				endm 
# End of macro NEXTW
37dd			.MAX: 
37dd				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
37dd 4a				db WORD_SYS_CORE+54             
37de 5e 38			dw .RND16            
37e0 04				db 3 + 1 
37e1 .. 00			db "MAX",0              
37e5				endm 
# End of macro CWHEAD
37e5			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
37e5					if DEBUG_FORTH_WORDS_KEY 
37e5						DMARK "MAX" 
37e5 f5				push af  
37e6 3a fa 37			ld a, (.dmark)  
37e9 32 6b ee			ld (debug_mark),a  
37ec 3a fb 37			ld a, (.dmark+1)  
37ef 32 6c ee			ld (debug_mark+1),a  
37f2 3a fc 37			ld a, (.dmark+2)  
37f5 32 6d ee			ld (debug_mark+2),a  
37f8 18 03			jr .pastdmark  
37fa ..			.dmark: db "MAX"  
37fd f1			.pastdmark: pop af  
37fe			endm  
# End of macro DMARK
37fe						CALLMONITOR 
37fe cd 6f ee			call debug_vector  
3801				endm  
# End of macro CALLMONITOR
3801					endif 
3801					; get u2 
3801			 
3801					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3801 cd 72 1d			call macro_dsp_valuehl 
3804				endm 
# End of macro FORTH_DSP_VALUEHL
3804			 
3804 e5					push hl   ; u2 
3805			 
3805					; destroy value TOS 
3805			 
3805					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3805 cd 2a 1e			call macro_forth_dsp_pop 
3808				endm 
# End of macro FORTH_DSP_POP
3808			 
3808					; get u1 
3808			 
3808					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3808 cd 72 1d			call macro_dsp_valuehl 
380b				endm 
# End of macro FORTH_DSP_VALUEHL
380b			 
380b e5					push hl  ; u1 
380c			 
380c					; destroy value TOS 
380c			 
380c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
380c cd 2a 1e			call macro_forth_dsp_pop 
380f				endm 
# End of macro FORTH_DSP_POP
380f			 
380f b7			 or a      ;clear carry flag 
3810 e1			  pop hl    ; u1 
3811 d1			  pop de    ; u2 
3812 e5				push hl   ; saved in case hl is lowest 
3813 ed 52		  sbc hl,de 
3815 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3817			 
3817 e1				pop hl 
3818					if DEBUG_FORTH_WORDS 
3818						DMARK "MAX" 
3818 f5				push af  
3819 3a 2d 38			ld a, (.dmark)  
381c 32 6b ee			ld (debug_mark),a  
381f 3a 2e 38			ld a, (.dmark+1)  
3822 32 6c ee			ld (debug_mark+1),a  
3825 3a 2f 38			ld a, (.dmark+2)  
3828 32 6d ee			ld (debug_mark+2),a  
382b 18 03			jr .pastdmark  
382d ..			.dmark: db "MAX"  
3830 f1			.pastdmark: pop af  
3831			endm  
# End of macro DMARK
3831						CALLMONITOR 
3831 cd 6f ee			call debug_vector  
3834				endm  
# End of macro CALLMONITOR
3834					endif 
3834 cd 6d 1b				call forth_push_numhl 
3837			 
3837				       NEXTW 
3837 c3 28 1f			jp macro_next 
383a				endm 
# End of macro NEXTW
383a			 
383a			.maxcont:  
383a c1				pop bc   ; tidy up 
383b eb				ex de , hl  
383c					if DEBUG_FORTH_WORDS 
383c						DMARK "MA1" 
383c f5				push af  
383d 3a 51 38			ld a, (.dmark)  
3840 32 6b ee			ld (debug_mark),a  
3843 3a 52 38			ld a, (.dmark+1)  
3846 32 6c ee			ld (debug_mark+1),a  
3849 3a 53 38			ld a, (.dmark+2)  
384c 32 6d ee			ld (debug_mark+2),a  
384f 18 03			jr .pastdmark  
3851 ..			.dmark: db "MA1"  
3854 f1			.pastdmark: pop af  
3855			endm  
# End of macro DMARK
3855						CALLMONITOR 
3855 cd 6f ee			call debug_vector  
3858				endm  
# End of macro CALLMONITOR
3858					endif 
3858 cd 6d 1b				call forth_push_numhl 
385b				       NEXTW 
385b c3 28 1f			jp macro_next 
385e				endm 
# End of macro NEXTW
385e			 
385e			.RND16: 
385e				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
385e 4e				db WORD_SYS_CORE+58             
385f 8d 38			dw .RND8            
3861 06				db 5 + 1 
3862 .. 00			db "RND16",0              
3868				endm 
# End of macro CWHEAD
3868			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3868					if DEBUG_FORTH_WORDS_KEY 
3868						DMARK "R16" 
3868 f5				push af  
3869 3a 7d 38			ld a, (.dmark)  
386c 32 6b ee			ld (debug_mark),a  
386f 3a 7e 38			ld a, (.dmark+1)  
3872 32 6c ee			ld (debug_mark+1),a  
3875 3a 7f 38			ld a, (.dmark+2)  
3878 32 6d ee			ld (debug_mark+2),a  
387b 18 03			jr .pastdmark  
387d ..			.dmark: db "R16"  
3880 f1			.pastdmark: pop af  
3881			endm  
# End of macro DMARK
3881						CALLMONITOR 
3881 cd 6f ee			call debug_vector  
3884				endm  
# End of macro CALLMONITOR
3884					endif 
3884 cd 0d 0d				call prng16  
3887 cd 6d 1b				call forth_push_numhl 
388a				       NEXTW 
388a c3 28 1f			jp macro_next 
388d				endm 
# End of macro NEXTW
388d			.RND8: 
388d				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
388d 60				db WORD_SYS_CORE+76             
388e c2 38			dw .RND            
3890 05				db 4 + 1 
3891 .. 00			db "RND8",0              
3896				endm 
# End of macro CWHEAD
3896			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3896					if DEBUG_FORTH_WORDS_KEY 
3896						DMARK "RN8" 
3896 f5				push af  
3897 3a ab 38			ld a, (.dmark)  
389a 32 6b ee			ld (debug_mark),a  
389d 3a ac 38			ld a, (.dmark+1)  
38a0 32 6c ee			ld (debug_mark+1),a  
38a3 3a ad 38			ld a, (.dmark+2)  
38a6 32 6d ee			ld (debug_mark+2),a  
38a9 18 03			jr .pastdmark  
38ab ..			.dmark: db "RN8"  
38ae f1			.pastdmark: pop af  
38af			endm  
# End of macro DMARK
38af						CALLMONITOR 
38af cd 6f ee			call debug_vector  
38b2				endm  
# End of macro CALLMONITOR
38b2					endif 
38b2 2a a9 eb				ld hl,(xrandc) 
38b5 23					inc hl 
38b6 cd 27 0d				call xrnd 
38b9 6f					ld l,a	 
38ba 26 00				ld h,0 
38bc cd 6d 1b				call forth_push_numhl 
38bf				       NEXTW 
38bf c3 28 1f			jp macro_next 
38c2				endm 
# End of macro NEXTW
38c2			.RND: 
38c2				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
38c2 60				db WORD_SYS_CORE+76             
38c3 c8 39			dw .ENDMATHS            
38c5 04				db 3 + 1 
38c6 .. 00			db "RND",0              
38ca				endm 
# End of macro CWHEAD
38ca			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
38ca			 
38ca					if DEBUG_FORTH_WORDS_KEY 
38ca						DMARK "RND" 
38ca f5				push af  
38cb 3a df 38			ld a, (.dmark)  
38ce 32 6b ee			ld (debug_mark),a  
38d1 3a e0 38			ld a, (.dmark+1)  
38d4 32 6c ee			ld (debug_mark+1),a  
38d7 3a e1 38			ld a, (.dmark+2)  
38da 32 6d ee			ld (debug_mark+2),a  
38dd 18 03			jr .pastdmark  
38df ..			.dmark: db "RND"  
38e2 f1			.pastdmark: pop af  
38e3			endm  
# End of macro DMARK
38e3						CALLMONITOR 
38e3 cd 6f ee			call debug_vector  
38e6				endm  
# End of macro CALLMONITOR
38e6					endif 
38e6					 
38e6					FORTH_DSP_VALUEHL    ; upper range 
38e6 cd 72 1d			call macro_dsp_valuehl 
38e9				endm 
# End of macro FORTH_DSP_VALUEHL
38e9			 
38e9 22 ad eb				ld (LFSRSeed), hl	 
38ec			 
38ec					if DEBUG_FORTH_WORDS 
38ec						DMARK "RN1" 
38ec f5				push af  
38ed 3a 01 39			ld a, (.dmark)  
38f0 32 6b ee			ld (debug_mark),a  
38f3 3a 02 39			ld a, (.dmark+1)  
38f6 32 6c ee			ld (debug_mark+1),a  
38f9 3a 03 39			ld a, (.dmark+2)  
38fc 32 6d ee			ld (debug_mark+2),a  
38ff 18 03			jr .pastdmark  
3901 ..			.dmark: db "RN1"  
3904 f1			.pastdmark: pop af  
3905			endm  
# End of macro DMARK
3905						CALLMONITOR 
3905 cd 6f ee			call debug_vector  
3908				endm  
# End of macro CALLMONITOR
3908					endif 
3908					FORTH_DSP_POP 
3908 cd 2a 1e			call macro_forth_dsp_pop 
390b				endm 
# End of macro FORTH_DSP_POP
390b			 
390b					FORTH_DSP_VALUEHL    ; low range 
390b cd 72 1d			call macro_dsp_valuehl 
390e				endm 
# End of macro FORTH_DSP_VALUEHL
390e			 
390e					if DEBUG_FORTH_WORDS 
390e						DMARK "RN2" 
390e f5				push af  
390f 3a 23 39			ld a, (.dmark)  
3912 32 6b ee			ld (debug_mark),a  
3915 3a 24 39			ld a, (.dmark+1)  
3918 32 6c ee			ld (debug_mark+1),a  
391b 3a 25 39			ld a, (.dmark+2)  
391e 32 6d ee			ld (debug_mark+2),a  
3921 18 03			jr .pastdmark  
3923 ..			.dmark: db "RN2"  
3926 f1			.pastdmark: pop af  
3927			endm  
# End of macro DMARK
3927						CALLMONITOR 
3927 cd 6f ee			call debug_vector  
392a				endm  
# End of macro CALLMONITOR
392a					endif 
392a 22 af eb				ld (LFSRSeed+2), hl 
392d			 
392d					FORTH_DSP_POP 
392d cd 2a 1e			call macro_forth_dsp_pop 
3930				endm 
# End of macro FORTH_DSP_POP
3930			 
3930 e5					push hl 
3931			 
3931 e1			.inrange:	pop hl 
3932 cd 0d 0d				call prng16  
3935					if DEBUG_FORTH_WORDS 
3935						DMARK "RN3" 
3935 f5				push af  
3936 3a 4a 39			ld a, (.dmark)  
3939 32 6b ee			ld (debug_mark),a  
393c 3a 4b 39			ld a, (.dmark+1)  
393f 32 6c ee			ld (debug_mark+1),a  
3942 3a 4c 39			ld a, (.dmark+2)  
3945 32 6d ee			ld (debug_mark+2),a  
3948 18 03			jr .pastdmark  
394a ..			.dmark: db "RN3"  
394d f1			.pastdmark: pop af  
394e			endm  
# End of macro DMARK
394e						CALLMONITOR 
394e cd 6f ee			call debug_vector  
3951				endm  
# End of macro CALLMONITOR
3951					endif 
3951					 
3951					; if the range is 8bit knock out the high byte 
3951			 
3951 ed 5b ad eb			ld de, (LFSRSeed)     ; check high level 
3955			 
3955 3e 00				ld a, 0 
3957 ba					cp d  
3958 20 1e				jr nz, .hirange 
395a 26 00				ld h, 0   ; knock it down to 8bit 
395c			 
395c					if DEBUG_FORTH_WORDS 
395c						DMARK "RNk" 
395c f5				push af  
395d 3a 71 39			ld a, (.dmark)  
3960 32 6b ee			ld (debug_mark),a  
3963 3a 72 39			ld a, (.dmark+1)  
3966 32 6c ee			ld (debug_mark+1),a  
3969 3a 73 39			ld a, (.dmark+2)  
396c 32 6d ee			ld (debug_mark+2),a  
396f 18 03			jr .pastdmark  
3971 ..			.dmark: db "RNk"  
3974 f1			.pastdmark: pop af  
3975			endm  
# End of macro DMARK
3975						CALLMONITOR 
3975 cd 6f ee			call debug_vector  
3978				endm  
# End of macro CALLMONITOR
3978					endif 
3978			.hirange:   
3978 e5					push hl  
3979 b7					or a  
397a ed 52		                sbc hl, de 
397c			 
397c					;call cmp16 
397c			 
397c 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
397e e1					pop hl 
397f e5					push hl 
3980			 
3980					if DEBUG_FORTH_WORDS 
3980						DMARK "RN4" 
3980 f5				push af  
3981 3a 95 39			ld a, (.dmark)  
3984 32 6b ee			ld (debug_mark),a  
3987 3a 96 39			ld a, (.dmark+1)  
398a 32 6c ee			ld (debug_mark+1),a  
398d 3a 97 39			ld a, (.dmark+2)  
3990 32 6d ee			ld (debug_mark+2),a  
3993 18 03			jr .pastdmark  
3995 ..			.dmark: db "RN4"  
3998 f1			.pastdmark: pop af  
3999			endm  
# End of macro DMARK
3999						CALLMONITOR 
3999 cd 6f ee			call debug_vector  
399c				endm  
# End of macro CALLMONITOR
399c					endif 
399c ed 5b af eb			ld de, (LFSRSeed+2)   ; check low range 
39a0					;call cmp16 
39a0				 
39a0 b7					or a  
39a1 ed 52		                sbc hl, de 
39a3 38 8c				jr c, .inrange 
39a5			 
39a5 e1					pop hl 
39a6					 
39a6					if DEBUG_FORTH_WORDS 
39a6						DMARK "RNd" 
39a6 f5				push af  
39a7 3a bb 39			ld a, (.dmark)  
39aa 32 6b ee			ld (debug_mark),a  
39ad 3a bc 39			ld a, (.dmark+1)  
39b0 32 6c ee			ld (debug_mark+1),a  
39b3 3a bd 39			ld a, (.dmark+2)  
39b6 32 6d ee			ld (debug_mark+2),a  
39b9 18 03			jr .pastdmark  
39bb ..			.dmark: db "RNd"  
39be f1			.pastdmark: pop af  
39bf			endm  
# End of macro DMARK
39bf						CALLMONITOR 
39bf cd 6f ee			call debug_vector  
39c2				endm  
# End of macro CALLMONITOR
39c2					endif 
39c2			 
39c2			 
39c2 cd 6d 1b				call forth_push_numhl 
39c5				       NEXTW 
39c5 c3 28 1f			jp macro_next 
39c8				endm 
# End of macro NEXTW
39c8			 
39c8			.ENDMATHS: 
39c8			 
39c8			; eof 
39c8			 
# End of file forth_words_maths.asm
39c8			include "forth_words_display.asm" 
39c8			 
39c8			; | ## Display Words 
39c8			 
39c8			.ACT: 
39c8			 
39c8				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
39c8 62				db WORD_SYS_CORE+78             
39c9 14 3a			dw .INFO            
39cb 07				db 6 + 1 
39cc .. 00			db "ACTIVE",0              
39d3				endm 
# End of macro CWHEAD
39d3			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
39d3			;  
39d3			; | | To display a pulsing activity indicator in a processing loop do this... 
39d3			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
39d3			 
39d3					if DEBUG_FORTH_WORDS_KEY 
39d3						DMARK "ACT" 
39d3 f5				push af  
39d4 3a e8 39			ld a, (.dmark)  
39d7 32 6b ee			ld (debug_mark),a  
39da 3a e9 39			ld a, (.dmark+1)  
39dd 32 6c ee			ld (debug_mark+1),a  
39e0 3a ea 39			ld a, (.dmark+2)  
39e3 32 6d ee			ld (debug_mark+2),a  
39e6 18 03			jr .pastdmark  
39e8 ..			.dmark: db "ACT"  
39eb f1			.pastdmark: pop af  
39ec			endm  
# End of macro DMARK
39ec						CALLMONITOR 
39ec cd 6f ee			call debug_vector  
39ef				endm  
# End of macro CALLMONITOR
39ef					endif 
39ef cd 10 0b				call active 
39f2					if DEBUG_FORTH_WORDS 
39f2						DMARK "ACp" 
39f2 f5				push af  
39f3 3a 07 3a			ld a, (.dmark)  
39f6 32 6b ee			ld (debug_mark),a  
39f9 3a 08 3a			ld a, (.dmark+1)  
39fc 32 6c ee			ld (debug_mark+1),a  
39ff 3a 09 3a			ld a, (.dmark+2)  
3a02 32 6d ee			ld (debug_mark+2),a  
3a05 18 03			jr .pastdmark  
3a07 ..			.dmark: db "ACp"  
3a0a f1			.pastdmark: pop af  
3a0b			endm  
# End of macro DMARK
3a0b						CALLMONITOR 
3a0b cd 6f ee			call debug_vector  
3a0e				endm  
# End of macro CALLMONITOR
3a0e					endif 
3a0e cd db 1b				call forth_push_str 
3a11			 
3a11					NEXTW 
3a11 c3 28 1f			jp macro_next 
3a14				endm 
# End of macro NEXTW
3a14			.INFO: 
3a14			 
3a14				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3a14 62				db WORD_SYS_CORE+78             
3a15 31 3a			dw .ATP            
3a17 05				db 4 + 1 
3a18 .. 00			db "INFO",0              
3a1d				endm 
# End of macro CWHEAD
3a1d			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3a1d					FORTH_DSP_VALUEHL 
3a1d cd 72 1d			call macro_dsp_valuehl 
3a20				endm 
# End of macro FORTH_DSP_VALUEHL
3a20			 
3a20					FORTH_DSP_POP 
3a20 cd 2a 1e			call macro_forth_dsp_pop 
3a23				endm 
# End of macro FORTH_DSP_POP
3a23			 
3a23 e5					push hl 
3a24			 
3a24					FORTH_DSP_VALUEHL 
3a24 cd 72 1d			call macro_dsp_valuehl 
3a27				endm 
# End of macro FORTH_DSP_VALUEHL
3a27			 
3a27					FORTH_DSP_POP 
3a27 cd 2a 1e			call macro_forth_dsp_pop 
3a2a				endm 
# End of macro FORTH_DSP_POP
3a2a			 
3a2a d1					pop de 
3a2b			 
3a2b cd 4a 0b				call info_panel 
3a2e			 
3a2e			 
3a2e					NEXTW 
3a2e c3 28 1f			jp macro_next 
3a31				endm 
# End of macro NEXTW
3a31			.ATP: 
3a31				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3a31 62				db WORD_SYS_CORE+78             
3a32 a8 3a			dw .FB            
3a34 04				db 3 + 1 
3a35 .. 00			db "AT?",0              
3a39				endm 
# End of macro CWHEAD
3a39			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3a39					if DEBUG_FORTH_WORDS_KEY 
3a39						DMARK "AT?" 
3a39 f5				push af  
3a3a 3a 4e 3a			ld a, (.dmark)  
3a3d 32 6b ee			ld (debug_mark),a  
3a40 3a 4f 3a			ld a, (.dmark+1)  
3a43 32 6c ee			ld (debug_mark+1),a  
3a46 3a 50 3a			ld a, (.dmark+2)  
3a49 32 6d ee			ld (debug_mark+2),a  
3a4c 18 03			jr .pastdmark  
3a4e ..			.dmark: db "AT?"  
3a51 f1			.pastdmark: pop af  
3a52			endm  
# End of macro DMARK
3a52						CALLMONITOR 
3a52 cd 6f ee			call debug_vector  
3a55				endm  
# End of macro CALLMONITOR
3a55					endif 
3a55 3a 5e ea				ld a, (f_cursor_ptr) 
3a58			 
3a58			if DEBUG_FORTH_WORDS 
3a58				DMARK "AT?" 
3a58 f5				push af  
3a59 3a 6d 3a			ld a, (.dmark)  
3a5c 32 6b ee			ld (debug_mark),a  
3a5f 3a 6e 3a			ld a, (.dmark+1)  
3a62 32 6c ee			ld (debug_mark+1),a  
3a65 3a 6f 3a			ld a, (.dmark+2)  
3a68 32 6d ee			ld (debug_mark+2),a  
3a6b 18 03			jr .pastdmark  
3a6d ..			.dmark: db "AT?"  
3a70 f1			.pastdmark: pop af  
3a71			endm  
# End of macro DMARK
3a71				CALLMONITOR 
3a71 cd 6f ee			call debug_vector  
3a74				endm  
# End of macro CALLMONITOR
3a74			endif	 
3a74					; count the number of rows 
3a74			 
3a74 06 00				ld b, 0 
3a76 4f			.atpr:		ld c, a    ; save in case we go below zero 
3a77 d6 28				sub display_cols 
3a79 f2 7f 3a				jp p, .atprunder 
3a7c 04					inc b 
3a7d 18 f7				jr .atpr 
3a7f			.atprunder:	 
3a7f			if DEBUG_FORTH_WORDS 
3a7f				DMARK "A?2" 
3a7f f5				push af  
3a80 3a 94 3a			ld a, (.dmark)  
3a83 32 6b ee			ld (debug_mark),a  
3a86 3a 95 3a			ld a, (.dmark+1)  
3a89 32 6c ee			ld (debug_mark+1),a  
3a8c 3a 96 3a			ld a, (.dmark+2)  
3a8f 32 6d ee			ld (debug_mark+2),a  
3a92 18 03			jr .pastdmark  
3a94 ..			.dmark: db "A?2"  
3a97 f1			.pastdmark: pop af  
3a98			endm  
# End of macro DMARK
3a98				CALLMONITOR 
3a98 cd 6f ee			call debug_vector  
3a9b				endm  
# End of macro CALLMONITOR
3a9b			endif	 
3a9b 26 00				ld h, 0 
3a9d 69					ld l, c 
3a9e cd 6d 1b				call forth_push_numhl 
3aa1 68					ld l, b  
3aa2 cd 6d 1b				call forth_push_numhl 
3aa5			 
3aa5			 
3aa5				NEXTW 
3aa5 c3 28 1f			jp macro_next 
3aa8				endm 
# End of macro NEXTW
3aa8			 
3aa8			.FB: 
3aa8				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3aa8 1b				db WORD_SYS_CORE+7             
3aa9 f6 3a			dw .EMIT            
3aab 03				db 2 + 1 
3aac .. 00			db "FB",0              
3aaf				endm 
# End of macro CWHEAD
3aaf			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3aaf			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3aaf			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3aaf			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3aaf					if DEBUG_FORTH_WORDS_KEY 
3aaf						DMARK "FB." 
3aaf f5				push af  
3ab0 3a c4 3a			ld a, (.dmark)  
3ab3 32 6b ee			ld (debug_mark),a  
3ab6 3a c5 3a			ld a, (.dmark+1)  
3ab9 32 6c ee			ld (debug_mark+1),a  
3abc 3a c6 3a			ld a, (.dmark+2)  
3abf 32 6d ee			ld (debug_mark+2),a  
3ac2 18 03			jr .pastdmark  
3ac4 ..			.dmark: db "FB."  
3ac7 f1			.pastdmark: pop af  
3ac8			endm  
# End of macro DMARK
3ac8						CALLMONITOR 
3ac8 cd 6f ee			call debug_vector  
3acb				endm  
# End of macro CALLMONITOR
3acb					endif 
3acb			 
3acb					FORTH_DSP_VALUEHL 
3acb cd 72 1d			call macro_dsp_valuehl 
3ace				endm 
# End of macro FORTH_DSP_VALUEHL
3ace			 
3ace 7d					ld a, l 
3acf fe 01				cp 1 
3ad1 20 05				jr nz, .fbn1 
3ad3 21 10 ed				ld hl, display_fb1 
3ad6 18 15				jr .fbset 
3ad8 fe 02		.fbn1:		cp 2 
3ada 20 05				jr nz, .fbn2 
3adc 21 ce eb				ld hl, display_fb2 
3adf 18 0c				jr .fbset 
3ae1 fe 03		.fbn2:		cp 3 
3ae3 20 05				jr nz, .fbn3 
3ae5 21 6f ec				ld hl, display_fb3 
3ae8 18 03				jr .fbset 
3aea			.fbn3:		 ; if invalid number select first 
3aea 21 10 ed				ld hl, display_fb1 
3aed 22 cc eb		.fbset:		ld (display_fb_active), hl 
3af0			 
3af0					FORTH_DSP_POP 
3af0 cd 2a 1e			call macro_forth_dsp_pop 
3af3				endm 
# End of macro FORTH_DSP_POP
3af3			 
3af3					NEXTW 
3af3 c3 28 1f			jp macro_next 
3af6				endm 
# End of macro NEXTW
3af6			 
3af6			 
3af6			.EMIT: 
3af6				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3af6 1b				db WORD_SYS_CORE+7             
3af7 47 3b			dw .DOTH            
3af9 05				db 4 + 1 
3afa .. 00			db "EMIT",0              
3aff				endm 
# End of macro CWHEAD
3aff			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3aff					; get value off TOS and display it 
3aff			 
3aff					if DEBUG_FORTH_WORDS_KEY 
3aff						DMARK "EMT" 
3aff f5				push af  
3b00 3a 14 3b			ld a, (.dmark)  
3b03 32 6b ee			ld (debug_mark),a  
3b06 3a 15 3b			ld a, (.dmark+1)  
3b09 32 6c ee			ld (debug_mark+1),a  
3b0c 3a 16 3b			ld a, (.dmark+2)  
3b0f 32 6d ee			ld (debug_mark+2),a  
3b12 18 03			jr .pastdmark  
3b14 ..			.dmark: db "EMT"  
3b17 f1			.pastdmark: pop af  
3b18			endm  
# End of macro DMARK
3b18						CALLMONITOR 
3b18 cd 6f ee			call debug_vector  
3b1b				endm  
# End of macro CALLMONITOR
3b1b					endif 
3b1b			 
3b1b					FORTH_DSP_VALUEHL 
3b1b cd 72 1d			call macro_dsp_valuehl 
3b1e				endm 
# End of macro FORTH_DSP_VALUEHL
3b1e			 
3b1e 7d					ld a,l 
3b1f			 
3b1f					; TODO write to display 
3b1f			 
3b1f 32 bf e4				ld (os_input), a 
3b22 3e 00				ld a, 0 
3b24 32 c0 e4				ld (os_input+1), a 
3b27					 
3b27 3a 5e ea				ld a, (f_cursor_ptr) 
3b2a 11 bf e4				ld de, os_input 
3b2d cd cc 0b				call str_at_display 
3b30			 
3b30			 
3b30 3a 3c ea				ld a,(cli_autodisplay) 
3b33 fe 00				cp 0 
3b35 28 03				jr z, .enoupdate 
3b37 cd dc 0b						call update_display 
3b3a					.enoupdate: 
3b3a			 
3b3a 3a 5e ea				ld a, (f_cursor_ptr) 
3b3d 3c					inc a 
3b3e 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3b41			 
3b41			 
3b41					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b41 cd 2a 1e			call macro_forth_dsp_pop 
3b44				endm 
# End of macro FORTH_DSP_POP
3b44			  
3b44			 
3b44					NEXTW 
3b44 c3 28 1f			jp macro_next 
3b47				endm 
# End of macro NEXTW
3b47			.DOTH: 
3b47				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3b47 1c				db WORD_SYS_CORE+8             
3b48 77 3b			dw .DOTF            
3b4a 03				db 2 + 1 
3b4b .. 00			db ".-",0              
3b4e				endm 
# End of macro CWHEAD
3b4e			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3b4e					; get value off TOS and display it 
3b4e					if DEBUG_FORTH_WORDS_KEY 
3b4e						DMARK "DTD" 
3b4e f5				push af  
3b4f 3a 63 3b			ld a, (.dmark)  
3b52 32 6b ee			ld (debug_mark),a  
3b55 3a 64 3b			ld a, (.dmark+1)  
3b58 32 6c ee			ld (debug_mark+1),a  
3b5b 3a 65 3b			ld a, (.dmark+2)  
3b5e 32 6d ee			ld (debug_mark+2),a  
3b61 18 03			jr .pastdmark  
3b63 ..			.dmark: db "DTD"  
3b66 f1			.pastdmark: pop af  
3b67			endm  
# End of macro DMARK
3b67						CALLMONITOR 
3b67 cd 6f ee			call debug_vector  
3b6a				endm  
# End of macro CALLMONITOR
3b6a					endif 
3b6a 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
3b6c 3e 00			ld a, 0 
3b6e 32 3d ea			ld (cli_mvdot), a 
3b71 c3 ce 3b			jp .dotgo 
3b74				NEXTW 
3b74 c3 28 1f			jp macro_next 
3b77				endm 
# End of macro NEXTW
3b77			.DOTF: 
3b77				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3b77 1c				db WORD_SYS_CORE+8             
3b78 a5 3b			dw .DOT            
3b7a 03				db 2 + 1 
3b7b .. 00			db ".>",0              
3b7e				endm 
# End of macro CWHEAD
3b7e			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
3b7e					; get value off TOS and display it 
3b7e			        ; TODO BUG adds extra spaces 
3b7e			        ; TODO BUG handle numerics? 
3b7e					if DEBUG_FORTH_WORDS_KEY 
3b7e						DMARK "DTC" 
3b7e f5				push af  
3b7f 3a 93 3b			ld a, (.dmark)  
3b82 32 6b ee			ld (debug_mark),a  
3b85 3a 94 3b			ld a, (.dmark+1)  
3b88 32 6c ee			ld (debug_mark+1),a  
3b8b 3a 95 3b			ld a, (.dmark+2)  
3b8e 32 6d ee			ld (debug_mark+2),a  
3b91 18 03			jr .pastdmark  
3b93 ..			.dmark: db "DTC"  
3b96 f1			.pastdmark: pop af  
3b97			endm  
# End of macro DMARK
3b97						CALLMONITOR 
3b97 cd 6f ee			call debug_vector  
3b9a				endm  
# End of macro CALLMONITOR
3b9a					endif 
3b9a 3e 01			ld a, 1 
3b9c 32 3d ea			ld (cli_mvdot), a 
3b9f c3 ce 3b			jp .dotgo 
3ba2				NEXTW 
3ba2 c3 28 1f			jp macro_next 
3ba5				endm 
# End of macro NEXTW
3ba5			 
3ba5			.DOT: 
3ba5				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
3ba5 1c				db WORD_SYS_CORE+8             
3ba6 81 3d			dw .CLS            
3ba8 02				db 1 + 1 
3ba9 .. 00			db ".",0              
3bab				endm 
# End of macro CWHEAD
3bab			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
3bab					; get value off TOS and display it 
3bab			 
3bab					if DEBUG_FORTH_WORDS_KEY 
3bab						DMARK "DOT" 
3bab f5				push af  
3bac 3a c0 3b			ld a, (.dmark)  
3baf 32 6b ee			ld (debug_mark),a  
3bb2 3a c1 3b			ld a, (.dmark+1)  
3bb5 32 6c ee			ld (debug_mark+1),a  
3bb8 3a c2 3b			ld a, (.dmark+2)  
3bbb 32 6d ee			ld (debug_mark+2),a  
3bbe 18 03			jr .pastdmark  
3bc0 ..			.dmark: db "DOT"  
3bc3 f1			.pastdmark: pop af  
3bc4			endm  
# End of macro DMARK
3bc4						CALLMONITOR 
3bc4 cd 6f ee			call debug_vector  
3bc7				endm  
# End of macro CALLMONITOR
3bc7					endif 
3bc7 3e 00			ld a, 0 
3bc9 32 3d ea			ld (cli_mvdot), a 
3bcc 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3bce				 
3bce			 
3bce			.dotgo: 
3bce			 
3bce			; move up type to on stack for parserv5 
3bce					FORTH_DSP 
3bce cd 38 1d			call macro_forth_dsp 
3bd1				endm 
# End of macro FORTH_DSP
3bd1				;FORTH_DSP_VALUE  
3bd1			 
3bd1			if DEBUG_FORTH_DOT 
3bd1				DMARK "DOT" 
3bd1 f5				push af  
3bd2 3a e6 3b			ld a, (.dmark)  
3bd5 32 6b ee			ld (debug_mark),a  
3bd8 3a e7 3b			ld a, (.dmark+1)  
3bdb 32 6c ee			ld (debug_mark+1),a  
3bde 3a e8 3b			ld a, (.dmark+2)  
3be1 32 6d ee			ld (debug_mark+2),a  
3be4 18 03			jr .pastdmark  
3be6 ..			.dmark: db "DOT"  
3be9 f1			.pastdmark: pop af  
3bea			endm  
# End of macro DMARK
3bea				CALLMONITOR 
3bea cd 6f ee			call debug_vector  
3bed				endm  
# End of macro CALLMONITOR
3bed			endif	 
3bed			;		.print: 
3bed			 
3bed 7e				ld a,(hl)  ; work out what type of value is on the TOS 
3bee 23				inc hl   ; position to the actual value 
3bef fe 01			cp DS_TYPE_STR 
3bf1 20 06			jr nz, .dotnum1  
3bf3			 
3bf3			; display string 
3bf3				FORTH_DSP_VALUE  
3bf3 cd 5b 1d			call macro_forth_dsp_value 
3bf6				endm 
# End of macro FORTH_DSP_VALUE
3bf6 eb				ex de,hl 
3bf7 18 49			jr .dotwrite 
3bf9			 
3bf9			.dotnum1: 
3bf9 fe 02			cp DS_TYPE_INUM 
3bfb 20 44			jr nz, .dotflot 
3bfd			 
3bfd			 
3bfd			; display number 
3bfd			 
3bfd			;	push hl 
3bfd			;	call clear_display 
3bfd			;	pop hl 
3bfd			 
3bfd 5e				ld e, (hl) 
3bfe 23				inc hl 
3bff 56				ld d, (hl) 
3c00 21 c1 e2			ld hl, scratch 
3c03			if DEBUG_FORTH_DOT 
3c03				DMARK "DT1" 
3c03 f5				push af  
3c04 3a 18 3c			ld a, (.dmark)  
3c07 32 6b ee			ld (debug_mark),a  
3c0a 3a 19 3c			ld a, (.dmark+1)  
3c0d 32 6c ee			ld (debug_mark+1),a  
3c10 3a 1a 3c			ld a, (.dmark+2)  
3c13 32 6d ee			ld (debug_mark+2),a  
3c16 18 03			jr .pastdmark  
3c18 ..			.dmark: db "DT1"  
3c1b f1			.pastdmark: pop af  
3c1c			endm  
# End of macro DMARK
3c1c				CALLMONITOR 
3c1c cd 6f ee			call debug_vector  
3c1f				endm  
# End of macro CALLMONITOR
3c1f			endif	 
3c1f			 
3c1f cd fb 10			call uitoa_16 
3c22 eb				ex de,hl 
3c23			 
3c23			if DEBUG_FORTH_DOT 
3c23				DMARK "DT2" 
3c23 f5				push af  
3c24 3a 38 3c			ld a, (.dmark)  
3c27 32 6b ee			ld (debug_mark),a  
3c2a 3a 39 3c			ld a, (.dmark+1)  
3c2d 32 6c ee			ld (debug_mark+1),a  
3c30 3a 3a 3c			ld a, (.dmark+2)  
3c33 32 6d ee			ld (debug_mark+2),a  
3c36 18 03			jr .pastdmark  
3c38 ..			.dmark: db "DT2"  
3c3b f1			.pastdmark: pop af  
3c3c			endm  
# End of macro DMARK
3c3c				CALLMONITOR 
3c3c cd 6f ee			call debug_vector  
3c3f				endm  
# End of macro CALLMONITOR
3c3f			endif	 
3c3f			 
3c3f			;	ld de, os_word_scratch 
3c3f 18 01			jr .dotwrite 
3c41			 
3c41 00			.dotflot:   nop 
3c42			; TODO print floating point number 
3c42			 
3c42			.dotwrite:		 
3c42			 
3c42					; if c is set then set all '-' to spaces 
3c42					; need to also take into account .>  
3c42			 
3c42 3e 01				ld a, 1 
3c44 b9					cp c 
3c45 20 67				jr nz, .nodashswap 
3c47			 
3c47					; DE has the string to write, working with HL 
3c47			 
3c47 06 ff				ld b, 255 
3c49 d5					push de 
3c4a e1					pop hl 
3c4b			 
3c4b			if DEBUG_FORTH_DOT 
3c4b				DMARK "DT-" 
3c4b f5				push af  
3c4c 3a 60 3c			ld a, (.dmark)  
3c4f 32 6b ee			ld (debug_mark),a  
3c52 3a 61 3c			ld a, (.dmark+1)  
3c55 32 6c ee			ld (debug_mark+1),a  
3c58 3a 62 3c			ld a, (.dmark+2)  
3c5b 32 6d ee			ld (debug_mark+2),a  
3c5e 18 03			jr .pastdmark  
3c60 ..			.dmark: db "DT-"  
3c63 f1			.pastdmark: pop af  
3c64			endm  
# End of macro DMARK
3c64				CALLMONITOR 
3c64 cd 6f ee			call debug_vector  
3c67				endm  
# End of macro CALLMONITOR
3c67			endif	 
3c67 7e			.dashscan:	ld a, (hl) 
3c68 fe 00				cp 0 
3c6a 28 42				jr z, .nodashswap 
3c6c fe 2d				cp '-' 
3c6e 20 03				jr nz, .dashskip 
3c70 3e 20				ld a, ' ' 
3c72 77					ld (hl), a 
3c73 23			.dashskip:	inc hl 
3c74			if DEBUG_FORTH_DOT 
3c74				DMARK "D-2" 
3c74 f5				push af  
3c75 3a 89 3c			ld a, (.dmark)  
3c78 32 6b ee			ld (debug_mark),a  
3c7b 3a 8a 3c			ld a, (.dmark+1)  
3c7e 32 6c ee			ld (debug_mark+1),a  
3c81 3a 8b 3c			ld a, (.dmark+2)  
3c84 32 6d ee			ld (debug_mark+2),a  
3c87 18 03			jr .pastdmark  
3c89 ..			.dmark: db "D-2"  
3c8c f1			.pastdmark: pop af  
3c8d			endm  
# End of macro DMARK
3c8d				CALLMONITOR 
3c8d cd 6f ee			call debug_vector  
3c90				endm  
# End of macro CALLMONITOR
3c90			endif	 
3c90 10 d5				djnz .dashscan 
3c92			 
3c92			if DEBUG_FORTH_DOT 
3c92				DMARK "D-1" 
3c92 f5				push af  
3c93 3a a7 3c			ld a, (.dmark)  
3c96 32 6b ee			ld (debug_mark),a  
3c99 3a a8 3c			ld a, (.dmark+1)  
3c9c 32 6c ee			ld (debug_mark+1),a  
3c9f 3a a9 3c			ld a, (.dmark+2)  
3ca2 32 6d ee			ld (debug_mark+2),a  
3ca5 18 03			jr .pastdmark  
3ca7 ..			.dmark: db "D-1"  
3caa f1			.pastdmark: pop af  
3cab			endm  
# End of macro DMARK
3cab				CALLMONITOR 
3cab cd 6f ee			call debug_vector  
3cae				endm  
# End of macro CALLMONITOR
3cae			endif	 
3cae			 
3cae			.nodashswap: 
3cae			 
3cae			if DEBUG_FORTH_DOT 
3cae				DMARK "D-o" 
3cae f5				push af  
3caf 3a c3 3c			ld a, (.dmark)  
3cb2 32 6b ee			ld (debug_mark),a  
3cb5 3a c4 3c			ld a, (.dmark+1)  
3cb8 32 6c ee			ld (debug_mark+1),a  
3cbb 3a c5 3c			ld a, (.dmark+2)  
3cbe 32 6d ee			ld (debug_mark+2),a  
3cc1 18 03			jr .pastdmark  
3cc3 ..			.dmark: db "D-o"  
3cc6 f1			.pastdmark: pop af  
3cc7			endm  
# End of macro DMARK
3cc7				CALLMONITOR 
3cc7 cd 6f ee			call debug_vector  
3cca				endm  
# End of macro CALLMONITOR
3cca			endif	 
3cca			 
3cca d5					push de   ; save string start in case we need to advance print 
3ccb			 
3ccb 3a 5e ea				ld a, (f_cursor_ptr) 
3cce cd cc 0b				call str_at_display 
3cd1 3a 3c ea				ld a,(cli_autodisplay) 
3cd4 fe 00				cp 0 
3cd6 28 03				jr z, .noupdate 
3cd8 cd dc 0b						call update_display 
3cdb					.noupdate: 
3cdb			 
3cdb			 
3cdb					; see if we need to advance the print position 
3cdb			 
3cdb e1					pop hl   ; get back string 
3cdc			;		ex de,hl 
3cdc			 
3cdc 3a 3d ea				ld a, (cli_mvdot) 
3cdf			if DEBUG_FORTH_DOT 
3cdf			;		ld e,a 
3cdf				DMARK "D>1" 
3cdf f5				push af  
3ce0 3a f4 3c			ld a, (.dmark)  
3ce3 32 6b ee			ld (debug_mark),a  
3ce6 3a f5 3c			ld a, (.dmark+1)  
3ce9 32 6c ee			ld (debug_mark+1),a  
3cec 3a f6 3c			ld a, (.dmark+2)  
3cef 32 6d ee			ld (debug_mark+2),a  
3cf2 18 03			jr .pastdmark  
3cf4 ..			.dmark: db "D>1"  
3cf7 f1			.pastdmark: pop af  
3cf8			endm  
# End of macro DMARK
3cf8				CALLMONITOR 
3cf8 cd 6f ee			call debug_vector  
3cfb				endm  
# End of macro CALLMONITOR
3cfb			endif	 
3cfb fe 00				cp 0 
3cfd 28 44				jr z, .noadv 
3cff					; yes, lets advance the print position 
3cff 3e 00				ld a, 0 
3d01 cd 57 11				call strlent 
3d04			if DEBUG_FORTH_DOT 
3d04				DMARK "D-?" 
3d04 f5				push af  
3d05 3a 19 3d			ld a, (.dmark)  
3d08 32 6b ee			ld (debug_mark),a  
3d0b 3a 1a 3d			ld a, (.dmark+1)  
3d0e 32 6c ee			ld (debug_mark+1),a  
3d11 3a 1b 3d			ld a, (.dmark+2)  
3d14 32 6d ee			ld (debug_mark+2),a  
3d17 18 03			jr .pastdmark  
3d19 ..			.dmark: db "D-?"  
3d1c f1			.pastdmark: pop af  
3d1d			endm  
# End of macro DMARK
3d1d				CALLMONITOR 
3d1d cd 6f ee			call debug_vector  
3d20				endm  
# End of macro CALLMONITOR
3d20			endif	 
3d20 3a 5e ea				ld a, (f_cursor_ptr) 
3d23 85					add a,l 
3d24					;call addatohl 
3d24					;ld a, l 
3d24 32 5e ea				ld (f_cursor_ptr), a   ; save new pos 
3d27			 
3d27			if DEBUG_FORTH_DOT 
3d27				DMARK "D->" 
3d27 f5				push af  
3d28 3a 3c 3d			ld a, (.dmark)  
3d2b 32 6b ee			ld (debug_mark),a  
3d2e 3a 3d 3d			ld a, (.dmark+1)  
3d31 32 6c ee			ld (debug_mark+1),a  
3d34 3a 3e 3d			ld a, (.dmark+2)  
3d37 32 6d ee			ld (debug_mark+2),a  
3d3a 18 03			jr .pastdmark  
3d3c ..			.dmark: db "D->"  
3d3f f1			.pastdmark: pop af  
3d40			endm  
# End of macro DMARK
3d40				CALLMONITOR 
3d40 cd 6f ee			call debug_vector  
3d43				endm  
# End of macro CALLMONITOR
3d43			endif	 
3d43			 
3d43			.noadv:	 
3d43			 
3d43					if DEBUG_FORTH_DOT_WAIT 
3d43							call next_page_prompt 
3d43					endif	 
3d43			; TODO this pop off the stack causes a crash. i dont know why 
3d43			 
3d43			 
3d43			if DEBUG_FORTH_DOT 
3d43				DMARK "DTh" 
3d43 f5				push af  
3d44 3a 58 3d			ld a, (.dmark)  
3d47 32 6b ee			ld (debug_mark),a  
3d4a 3a 59 3d			ld a, (.dmark+1)  
3d4d 32 6c ee			ld (debug_mark+1),a  
3d50 3a 5a 3d			ld a, (.dmark+2)  
3d53 32 6d ee			ld (debug_mark+2),a  
3d56 18 03			jr .pastdmark  
3d58 ..			.dmark: db "DTh"  
3d5b f1			.pastdmark: pop af  
3d5c			endm  
# End of macro DMARK
3d5c				CALLMONITOR 
3d5c cd 6f ee			call debug_vector  
3d5f				endm  
# End of macro CALLMONITOR
3d5f			endif	 
3d5f			 
3d5f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d5f cd 2a 1e			call macro_forth_dsp_pop 
3d62				endm 
# End of macro FORTH_DSP_POP
3d62			 
3d62			if DEBUG_FORTH_DOT 
3d62				DMARK "DTi" 
3d62 f5				push af  
3d63 3a 77 3d			ld a, (.dmark)  
3d66 32 6b ee			ld (debug_mark),a  
3d69 3a 78 3d			ld a, (.dmark+1)  
3d6c 32 6c ee			ld (debug_mark+1),a  
3d6f 3a 79 3d			ld a, (.dmark+2)  
3d72 32 6d ee			ld (debug_mark+2),a  
3d75 18 03			jr .pastdmark  
3d77 ..			.dmark: db "DTi"  
3d7a f1			.pastdmark: pop af  
3d7b			endm  
# End of macro DMARK
3d7b				CALLMONITOR 
3d7b cd 6f ee			call debug_vector  
3d7e				endm  
# End of macro CALLMONITOR
3d7e			endif	 
3d7e			 
3d7e			 
3d7e					NEXTW 
3d7e c3 28 1f			jp macro_next 
3d81				endm 
# End of macro NEXTW
3d81			 
3d81			.CLS: 
3d81				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3d81 35				db WORD_SYS_CORE+33             
3d82 ae 3d			dw .DRAW            
3d84 04				db 3 + 1 
3d85 .. 00			db "CLS",0              
3d89				endm 
# End of macro CWHEAD
3d89			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3d89					if DEBUG_FORTH_WORDS_KEY 
3d89						DMARK "CLS" 
3d89 f5				push af  
3d8a 3a 9e 3d			ld a, (.dmark)  
3d8d 32 6b ee			ld (debug_mark),a  
3d90 3a 9f 3d			ld a, (.dmark+1)  
3d93 32 6c ee			ld (debug_mark+1),a  
3d96 3a a0 3d			ld a, (.dmark+2)  
3d99 32 6d ee			ld (debug_mark+2),a  
3d9c 18 03			jr .pastdmark  
3d9e ..			.dmark: db "CLS"  
3da1 f1			.pastdmark: pop af  
3da2			endm  
# End of macro DMARK
3da2						CALLMONITOR 
3da2 cd 6f ee			call debug_vector  
3da5				endm  
# End of macro CALLMONITOR
3da5					endif 
3da5 cd b9 0b				call clear_display 
3da8 c3 bc 3e				jp .home		; and home cursor 
3dab					NEXTW 
3dab c3 28 1f			jp macro_next 
3dae				endm 
# End of macro NEXTW
3dae			 
3dae			.DRAW: 
3dae				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3dae 36				db WORD_SYS_CORE+34             
3daf d9 3d			dw .DUMP            
3db1 05				db 4 + 1 
3db2 .. 00			db "DRAW",0              
3db7				endm 
# End of macro CWHEAD
3db7			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3db7					if DEBUG_FORTH_WORDS_KEY 
3db7						DMARK "DRW" 
3db7 f5				push af  
3db8 3a cc 3d			ld a, (.dmark)  
3dbb 32 6b ee			ld (debug_mark),a  
3dbe 3a cd 3d			ld a, (.dmark+1)  
3dc1 32 6c ee			ld (debug_mark+1),a  
3dc4 3a ce 3d			ld a, (.dmark+2)  
3dc7 32 6d ee			ld (debug_mark+2),a  
3dca 18 03			jr .pastdmark  
3dcc ..			.dmark: db "DRW"  
3dcf f1			.pastdmark: pop af  
3dd0			endm  
# End of macro DMARK
3dd0						CALLMONITOR 
3dd0 cd 6f ee			call debug_vector  
3dd3				endm  
# End of macro CALLMONITOR
3dd3					endif 
3dd3 cd dc 0b				call update_display 
3dd6					NEXTW 
3dd6 c3 28 1f			jp macro_next 
3dd9				endm 
# End of macro NEXTW
3dd9			 
3dd9			.DUMP: 
3dd9				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3dd9 37				db WORD_SYS_CORE+35             
3dda 11 3e			dw .CDUMP            
3ddc 05				db 4 + 1 
3ddd .. 00			db "DUMP",0              
3de2				endm 
# End of macro CWHEAD
3de2			; | DUMP ( x -- ) With address x display dump   | DONE 
3de2			; TODO pop address to use off of the stack 
3de2					if DEBUG_FORTH_WORDS_KEY 
3de2						DMARK "DUM" 
3de2 f5				push af  
3de3 3a f7 3d			ld a, (.dmark)  
3de6 32 6b ee			ld (debug_mark),a  
3de9 3a f8 3d			ld a, (.dmark+1)  
3dec 32 6c ee			ld (debug_mark+1),a  
3def 3a f9 3d			ld a, (.dmark+2)  
3df2 32 6d ee			ld (debug_mark+2),a  
3df5 18 03			jr .pastdmark  
3df7 ..			.dmark: db "DUM"  
3dfa f1			.pastdmark: pop af  
3dfb			endm  
# End of macro DMARK
3dfb						CALLMONITOR 
3dfb cd 6f ee			call debug_vector  
3dfe				endm  
# End of macro CALLMONITOR
3dfe					endif 
3dfe cd b9 0b				call clear_display 
3e01			 
3e01					; get address 
3e01			 
3e01					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e01 cd 72 1d			call macro_dsp_valuehl 
3e04				endm 
# End of macro FORTH_DSP_VALUEHL
3e04				 
3e04					; save it for cdump 
3e04			 
3e04 22 e4 e5				ld (os_cur_ptr),hl 
3e07			 
3e07					; destroy value TOS 
3e07			 
3e07					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e07 cd 2a 1e			call macro_forth_dsp_pop 
3e0a				endm 
# End of macro FORTH_DSP_POP
3e0a			 
3e0a cd ed 19				call dumpcont	; skip old style of param parsing	 
3e0d c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3e0e					NEXTW 
3e0e c3 28 1f			jp macro_next 
3e11				endm 
# End of macro NEXTW
3e11			.CDUMP: 
3e11				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3e11 38				db WORD_SYS_CORE+36             
3e12 41 3e			dw .DAT            
3e14 06				db 5 + 1 
3e15 .. 00			db "CDUMP",0              
3e1b				endm 
# End of macro CWHEAD
3e1b			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3e1b					if DEBUG_FORTH_WORDS_KEY 
3e1b						DMARK "CDP" 
3e1b f5				push af  
3e1c 3a 30 3e			ld a, (.dmark)  
3e1f 32 6b ee			ld (debug_mark),a  
3e22 3a 31 3e			ld a, (.dmark+1)  
3e25 32 6c ee			ld (debug_mark+1),a  
3e28 3a 32 3e			ld a, (.dmark+2)  
3e2b 32 6d ee			ld (debug_mark+2),a  
3e2e 18 03			jr .pastdmark  
3e30 ..			.dmark: db "CDP"  
3e33 f1			.pastdmark: pop af  
3e34			endm  
# End of macro DMARK
3e34						CALLMONITOR 
3e34 cd 6f ee			call debug_vector  
3e37				endm  
# End of macro CALLMONITOR
3e37					endif 
3e37 cd b9 0b				call clear_display 
3e3a cd ed 19				call dumpcont	 
3e3d c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3e3e					NEXTW 
3e3e c3 28 1f			jp macro_next 
3e41				endm 
# End of macro NEXTW
3e41			 
3e41			 
3e41			 
3e41			 
3e41			.DAT: 
3e41				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3e41 3d				db WORD_SYS_CORE+41             
3e42 97 3e			dw .HOME            
3e44 03				db 2 + 1 
3e45 .. 00			db "AT",0              
3e48				endm 
# End of macro CWHEAD
3e48			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3e48					if DEBUG_FORTH_WORDS_KEY 
3e48						DMARK "AT." 
3e48 f5				push af  
3e49 3a 5d 3e			ld a, (.dmark)  
3e4c 32 6b ee			ld (debug_mark),a  
3e4f 3a 5e 3e			ld a, (.dmark+1)  
3e52 32 6c ee			ld (debug_mark+1),a  
3e55 3a 5f 3e			ld a, (.dmark+2)  
3e58 32 6d ee			ld (debug_mark+2),a  
3e5b 18 03			jr .pastdmark  
3e5d ..			.dmark: db "AT."  
3e60 f1			.pastdmark: pop af  
3e61			endm  
# End of macro DMARK
3e61						CALLMONITOR 
3e61 cd 6f ee			call debug_vector  
3e64				endm  
# End of macro CALLMONITOR
3e64					endif 
3e64					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e64 cd 72 1d			call macro_dsp_valuehl 
3e67				endm 
# End of macro FORTH_DSP_VALUEHL
3e67			 
3e67			 
3e67					; TODO save cursor row 
3e67 7d					ld a,l 
3e68 fe 02				cp 2 
3e6a 20 04				jr nz, .crow3 
3e6c 3e 28				ld a, display_row_2 
3e6e 18 12				jr .ccol1 
3e70 fe 03		.crow3:		cp 3 
3e72 20 04				jr nz, .crow4 
3e74 3e 50				ld a, display_row_3 
3e76 18 0a				jr .ccol1 
3e78 fe 04		.crow4:		cp 4 
3e7a 20 04				jr nz, .crow1 
3e7c 3e 78				ld a, display_row_4 
3e7e 18 02				jr .ccol1 
3e80 3e 00		.crow1:		ld a,display_row_1 
3e82 f5			.ccol1:		push af			; got row offset 
3e83 6f					ld l,a 
3e84 26 00				ld h,0 
3e86					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e86 cd 2a 1e			call macro_forth_dsp_pop 
3e89				endm 
# End of macro FORTH_DSP_POP
3e89					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e89 cd 72 1d			call macro_dsp_valuehl 
3e8c				endm 
# End of macro FORTH_DSP_VALUEHL
3e8c					; TODO save cursor col 
3e8c f1					pop af 
3e8d 85					add l		; add col offset 
3e8e 32 5e ea				ld (f_cursor_ptr), a 
3e91					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e91 cd 2a 1e			call macro_forth_dsp_pop 
3e94				endm 
# End of macro FORTH_DSP_POP
3e94			 
3e94					; calculate  
3e94			 
3e94					NEXTW 
3e94 c3 28 1f			jp macro_next 
3e97				endm 
# End of macro NEXTW
3e97			 
3e97			 
3e97			.HOME: 
3e97				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
3e97 41				db WORD_SYS_CORE+45             
3e98 c4 3e			dw .CR            
3e9a 05				db 4 + 1 
3e9b .. 00			db "HOME",0              
3ea0				endm 
# End of macro CWHEAD
3ea0			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3ea0					if DEBUG_FORTH_WORDS_KEY 
3ea0						DMARK "HOM" 
3ea0 f5				push af  
3ea1 3a b5 3e			ld a, (.dmark)  
3ea4 32 6b ee			ld (debug_mark),a  
3ea7 3a b6 3e			ld a, (.dmark+1)  
3eaa 32 6c ee			ld (debug_mark+1),a  
3ead 3a b7 3e			ld a, (.dmark+2)  
3eb0 32 6d ee			ld (debug_mark+2),a  
3eb3 18 03			jr .pastdmark  
3eb5 ..			.dmark: db "HOM"  
3eb8 f1			.pastdmark: pop af  
3eb9			endm  
# End of macro DMARK
3eb9						CALLMONITOR 
3eb9 cd 6f ee			call debug_vector  
3ebc				endm  
# End of macro CALLMONITOR
3ebc					endif 
3ebc 3e 00		.home:		ld a, 0		; and home cursor 
3ebe 32 5e ea				ld (f_cursor_ptr), a 
3ec1					NEXTW 
3ec1 c3 28 1f			jp macro_next 
3ec4				endm 
# End of macro NEXTW
3ec4			 
3ec4			 
3ec4			.CR: 
3ec4				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
3ec4 46				db WORD_SYS_CORE+50             
3ec5 ff 3e			dw .SPACE            
3ec7 03				db 2 + 1 
3ec8 .. 00			db "CR",0              
3ecb				endm 
# End of macro CWHEAD
3ecb			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
3ecb					if DEBUG_FORTH_WORDS_KEY 
3ecb						DMARK "CR." 
3ecb f5				push af  
3ecc 3a e0 3e			ld a, (.dmark)  
3ecf 32 6b ee			ld (debug_mark),a  
3ed2 3a e1 3e			ld a, (.dmark+1)  
3ed5 32 6c ee			ld (debug_mark+1),a  
3ed8 3a e2 3e			ld a, (.dmark+2)  
3edb 32 6d ee			ld (debug_mark+2),a  
3ede 18 03			jr .pastdmark  
3ee0 ..			.dmark: db "CR."  
3ee3 f1			.pastdmark: pop af  
3ee4			endm  
# End of macro DMARK
3ee4						CALLMONITOR 
3ee4 cd 6f ee			call debug_vector  
3ee7				endm  
# End of macro CALLMONITOR
3ee7					endif 
3ee7 3e 0d				ld a, 13 
3ee9 32 c1 e2				ld (scratch),a 
3eec 3e 0a				ld a, 10 
3eee 32 c2 e2				ld (scratch+1),a 
3ef1 3e 00				ld a, 0 
3ef3 32 c3 e2				ld (scratch+2),a 
3ef6 21 c1 e2				ld hl, scratch 
3ef9 cd db 1b				call forth_push_str 
3efc					 
3efc				       NEXTW 
3efc c3 28 1f			jp macro_next 
3eff				endm 
# End of macro NEXTW
3eff			.SPACE: 
3eff				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3eff 46				db WORD_SYS_CORE+50             
3f00 35 3f			dw .SPACES            
3f02 03				db 2 + 1 
3f03 .. 00			db "BL",0              
3f06				endm 
# End of macro CWHEAD
3f06			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3f06					if DEBUG_FORTH_WORDS_KEY 
3f06						DMARK "BL." 
3f06 f5				push af  
3f07 3a 1b 3f			ld a, (.dmark)  
3f0a 32 6b ee			ld (debug_mark),a  
3f0d 3a 1c 3f			ld a, (.dmark+1)  
3f10 32 6c ee			ld (debug_mark+1),a  
3f13 3a 1d 3f			ld a, (.dmark+2)  
3f16 32 6d ee			ld (debug_mark+2),a  
3f19 18 03			jr .pastdmark  
3f1b ..			.dmark: db "BL."  
3f1e f1			.pastdmark: pop af  
3f1f			endm  
# End of macro DMARK
3f1f						CALLMONITOR 
3f1f cd 6f ee			call debug_vector  
3f22				endm  
# End of macro CALLMONITOR
3f22					endif 
3f22 3e 20				ld a, " " 
3f24 32 c1 e2				ld (scratch),a 
3f27 3e 00				ld a, 0 
3f29 32 c2 e2				ld (scratch+1),a 
3f2c 21 c1 e2				ld hl, scratch 
3f2f cd db 1b				call forth_push_str 
3f32					 
3f32				       NEXTW 
3f32 c3 28 1f			jp macro_next 
3f35				endm 
# End of macro NEXTW
3f35			 
3f35			;.blstr: db " ", 0 
3f35			 
3f35			.SPACES: 
3f35				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3f35 47				db WORD_SYS_CORE+51             
3f36 d0 3f			dw .SCROLL            
3f38 07				db 6 + 1 
3f39 .. 00			db "SPACES",0              
3f40				endm 
# End of macro CWHEAD
3f40			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
3f40					if DEBUG_FORTH_WORDS_KEY 
3f40						DMARK "SPS" 
3f40 f5				push af  
3f41 3a 55 3f			ld a, (.dmark)  
3f44 32 6b ee			ld (debug_mark),a  
3f47 3a 56 3f			ld a, (.dmark+1)  
3f4a 32 6c ee			ld (debug_mark+1),a  
3f4d 3a 57 3f			ld a, (.dmark+2)  
3f50 32 6d ee			ld (debug_mark+2),a  
3f53 18 03			jr .pastdmark  
3f55 ..			.dmark: db "SPS"  
3f58 f1			.pastdmark: pop af  
3f59			endm  
# End of macro DMARK
3f59						CALLMONITOR 
3f59 cd 6f ee			call debug_vector  
3f5c				endm  
# End of macro CALLMONITOR
3f5c					endif 
3f5c			 
3f5c			 
3f5c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f5c cd 72 1d			call macro_dsp_valuehl 
3f5f				endm 
# End of macro FORTH_DSP_VALUEHL
3f5f			 
3f5f e5					push hl    ; u 
3f60					if DEBUG_FORTH_WORDS 
3f60						DMARK "SPA" 
3f60 f5				push af  
3f61 3a 75 3f			ld a, (.dmark)  
3f64 32 6b ee			ld (debug_mark),a  
3f67 3a 76 3f			ld a, (.dmark+1)  
3f6a 32 6c ee			ld (debug_mark+1),a  
3f6d 3a 77 3f			ld a, (.dmark+2)  
3f70 32 6d ee			ld (debug_mark+2),a  
3f73 18 03			jr .pastdmark  
3f75 ..			.dmark: db "SPA"  
3f78 f1			.pastdmark: pop af  
3f79			endm  
# End of macro DMARK
3f79						CALLMONITOR 
3f79 cd 6f ee			call debug_vector  
3f7c				endm  
# End of macro CALLMONITOR
3f7c					endif 
3f7c			 
3f7c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f7c cd 2a 1e			call macro_forth_dsp_pop 
3f7f				endm 
# End of macro FORTH_DSP_POP
3f7f e1					pop hl 
3f80 0e 00				ld c, 0 
3f82 45					ld b, l 
3f83 21 c1 e2				ld hl, scratch  
3f86			 
3f86					if DEBUG_FORTH_WORDS 
3f86						DMARK "SP2" 
3f86 f5				push af  
3f87 3a 9b 3f			ld a, (.dmark)  
3f8a 32 6b ee			ld (debug_mark),a  
3f8d 3a 9c 3f			ld a, (.dmark+1)  
3f90 32 6c ee			ld (debug_mark+1),a  
3f93 3a 9d 3f			ld a, (.dmark+2)  
3f96 32 6d ee			ld (debug_mark+2),a  
3f99 18 03			jr .pastdmark  
3f9b ..			.dmark: db "SP2"  
3f9e f1			.pastdmark: pop af  
3f9f			endm  
# End of macro DMARK
3f9f						CALLMONITOR 
3f9f cd 6f ee			call debug_vector  
3fa2				endm  
# End of macro CALLMONITOR
3fa2					endif 
3fa2 3e 20				ld a, ' ' 
3fa4			.spaces1:	 
3fa4 77					ld (hl),a 
3fa5 23					inc hl 
3fa6					 
3fa6 10 fc				djnz .spaces1 
3fa8 3e 00				ld a,0 
3faa 77					ld (hl),a 
3fab 21 c1 e2				ld hl, scratch 
3fae					if DEBUG_FORTH_WORDS 
3fae						DMARK "SP3" 
3fae f5				push af  
3faf 3a c3 3f			ld a, (.dmark)  
3fb2 32 6b ee			ld (debug_mark),a  
3fb5 3a c4 3f			ld a, (.dmark+1)  
3fb8 32 6c ee			ld (debug_mark+1),a  
3fbb 3a c5 3f			ld a, (.dmark+2)  
3fbe 32 6d ee			ld (debug_mark+2),a  
3fc1 18 03			jr .pastdmark  
3fc3 ..			.dmark: db "SP3"  
3fc6 f1			.pastdmark: pop af  
3fc7			endm  
# End of macro DMARK
3fc7						CALLMONITOR 
3fc7 cd 6f ee			call debug_vector  
3fca				endm  
# End of macro CALLMONITOR
3fca					endif 
3fca cd db 1b				call forth_push_str 
3fcd			 
3fcd				       NEXTW 
3fcd c3 28 1f			jp macro_next 
3fd0				endm 
# End of macro NEXTW
3fd0			 
3fd0			 
3fd0			 
3fd0			.SCROLL: 
3fd0				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3fd0 53				db WORD_SYS_CORE+63             
3fd1 fd 3f			dw .SCROLLD            
3fd3 07				db 6 + 1 
3fd4 .. 00			db "SCROLL",0              
3fdb				endm 
# End of macro CWHEAD
3fdb			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3fdb					if DEBUG_FORTH_WORDS_KEY 
3fdb						DMARK "SCR" 
3fdb f5				push af  
3fdc 3a f0 3f			ld a, (.dmark)  
3fdf 32 6b ee			ld (debug_mark),a  
3fe2 3a f1 3f			ld a, (.dmark+1)  
3fe5 32 6c ee			ld (debug_mark+1),a  
3fe8 3a f2 3f			ld a, (.dmark+2)  
3feb 32 6d ee			ld (debug_mark+2),a  
3fee 18 03			jr .pastdmark  
3ff0 ..			.dmark: db "SCR"  
3ff3 f1			.pastdmark: pop af  
3ff4			endm  
# End of macro DMARK
3ff4						CALLMONITOR 
3ff4 cd 6f ee			call debug_vector  
3ff7				endm  
# End of macro CALLMONITOR
3ff7					endif 
3ff7			 
3ff7 cd 7b 0b			call scroll_up 
3ffa			;	call update_display 
3ffa			 
3ffa					NEXTW 
3ffa c3 28 1f			jp macro_next 
3ffd				endm 
# End of macro NEXTW
3ffd			 
3ffd			 
3ffd			 
3ffd			;		; get dir 
3ffd			; 
3ffd			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ffd			; 
3ffd			;		push hl 
3ffd			; 
3ffd			;		; destroy value TOS 
3ffd			; 
3ffd			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ffd			; 
3ffd			;		; get count 
3ffd			; 
3ffd			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ffd			; 
3ffd			;		push hl 
3ffd			; 
3ffd			;		; destroy value TOS 
3ffd			; 
3ffd			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ffd			; 
3ffd			;		; one value on hl get other one back 
3ffd			; 
3ffd			;		pop bc    ; count 
3ffd			; 
3ffd			;		pop de   ; dir 
3ffd			; 
3ffd			; 
3ffd			;		ld b, c 
3ffd			; 
3ffd			;.scrolldir:     push bc 
3ffd			;		push de 
3ffd			; 
3ffd			;		ld a, 0 
3ffd			;		cp e 
3ffd			;		jr z, .scrollup  
3ffd			;		call scroll_down 
3ffd			;		jr .scrollnext 
3ffd			;.scrollup:	call scroll_up 
3ffd			; 
3ffd			;		 
3ffd			;.scrollnext: 
3ffd			;		pop de 
3ffd			;		pop bc 
3ffd			;		djnz .scrolldir 
3ffd			; 
3ffd			; 
3ffd			; 
3ffd			; 
3ffd			; 
3ffd			;		NEXTW 
3ffd			 
3ffd			.SCROLLD: 
3ffd				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3ffd 53				db WORD_SYS_CORE+63             
3ffe 2b 40			dw .ATQ            
4000 08				db 7 + 1 
4001 .. 00			db "SCROLLD",0              
4009				endm 
# End of macro CWHEAD
4009			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4009					if DEBUG_FORTH_WORDS_KEY 
4009						DMARK "SCD" 
4009 f5				push af  
400a 3a 1e 40			ld a, (.dmark)  
400d 32 6b ee			ld (debug_mark),a  
4010 3a 1f 40			ld a, (.dmark+1)  
4013 32 6c ee			ld (debug_mark+1),a  
4016 3a 20 40			ld a, (.dmark+2)  
4019 32 6d ee			ld (debug_mark+2),a  
401c 18 03			jr .pastdmark  
401e ..			.dmark: db "SCD"  
4021 f1			.pastdmark: pop af  
4022			endm  
# End of macro DMARK
4022						CALLMONITOR 
4022 cd 6f ee			call debug_vector  
4025				endm  
# End of macro CALLMONITOR
4025					endif 
4025			 
4025 cd 9f 0b			call scroll_down 
4028			;	call update_display 
4028			 
4028					NEXTW 
4028 c3 28 1f			jp macro_next 
402b				endm 
# End of macro NEXTW
402b			 
402b			 
402b			.ATQ: 
402b				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
402b 62				db WORD_SYS_CORE+78             
402c 89 40			dw .AUTODSP            
402e 04				db 3 + 1 
402f .. 00			db "AT@",0              
4033				endm 
# End of macro CWHEAD
4033			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
4033					if DEBUG_FORTH_WORDS_KEY 
4033						DMARK "ATA" 
4033 f5				push af  
4034 3a 48 40			ld a, (.dmark)  
4037 32 6b ee			ld (debug_mark),a  
403a 3a 49 40			ld a, (.dmark+1)  
403d 32 6c ee			ld (debug_mark+1),a  
4040 3a 4a 40			ld a, (.dmark+2)  
4043 32 6d ee			ld (debug_mark+2),a  
4046 18 03			jr .pastdmark  
4048 ..			.dmark: db "ATA"  
404b f1			.pastdmark: pop af  
404c			endm  
# End of macro DMARK
404c						CALLMONITOR 
404c cd 6f ee			call debug_vector  
404f				endm  
# End of macro CALLMONITOR
404f					endif 
404f			 
404f			 
404f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
404f cd 72 1d			call macro_dsp_valuehl 
4052				endm 
# End of macro FORTH_DSP_VALUEHL
4052			 
4052					; TODO save cursor row 
4052 7d					ld a,l 
4053 fe 02				cp 2 
4055 20 04				jr nz, .crow3aq 
4057 3e 28				ld a, display_row_2 
4059 18 12				jr .ccol1aq 
405b fe 03		.crow3aq:		cp 3 
405d 20 04				jr nz, .crow4aq 
405f 3e 50				ld a, display_row_3 
4061 18 0a				jr .ccol1aq 
4063 fe 04		.crow4aq:		cp 4 
4065 20 04				jr nz, .crow1aq 
4067 3e 78				ld a, display_row_4 
4069 18 02				jr .ccol1aq 
406b 3e 00		.crow1aq:		ld a,display_row_1 
406d f5			.ccol1aq:		push af			; got row offset 
406e 6f					ld l,a 
406f 26 00				ld h,0 
4071					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4071 cd 2a 1e			call macro_forth_dsp_pop 
4074				endm 
# End of macro FORTH_DSP_POP
4074					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4074 cd 72 1d			call macro_dsp_valuehl 
4077				endm 
# End of macro FORTH_DSP_VALUEHL
4077					; TODO save cursor col 
4077 f1					pop af 
4078 85					add l		; add col offset 
4079			 
4079					; add current frame buffer address 
4079 2a cc eb				ld hl, (display_fb_active) 
407c cd e6 0d				call addatohl 
407f			 
407f			 
407f			 
407f			 
407f					; get char frame buffer location offset in hl 
407f			 
407f 7e					ld a,(hl) 
4080 26 00				ld h, 0 
4082 6f					ld l, a 
4083			 
4083 cd 6d 1b				call forth_push_numhl 
4086			 
4086			 
4086					NEXTW 
4086 c3 28 1f			jp macro_next 
4089				endm 
# End of macro NEXTW
4089			 
4089			.AUTODSP: 
4089				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4089 63				db WORD_SYS_CORE+79             
408a 9f 40			dw .MENU            
408c 05				db 4 + 1 
408d .. 00			db "ADSP",0              
4092				endm 
# End of macro CWHEAD
4092			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
4092			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
4092			 
4092					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4092 cd 72 1d			call macro_dsp_valuehl 
4095				endm 
# End of macro FORTH_DSP_VALUEHL
4095			 
4095			;		push hl 
4095			 
4095					; destroy value TOS 
4095			 
4095					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4095 cd 2a 1e			call macro_forth_dsp_pop 
4098				endm 
# End of macro FORTH_DSP_POP
4098			 
4098			;		pop hl 
4098			 
4098 7d					ld a,l 
4099 32 3c ea				ld (cli_autodisplay), a 
409c				       NEXTW 
409c c3 28 1f			jp macro_next 
409f				endm 
# End of macro NEXTW
409f			 
409f			.MENU: 
409f				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
409f 70				db WORD_SYS_CORE+92             
40a0 48 41			dw .ENDDISPLAY            
40a2 05				db 4 + 1 
40a3 .. 00			db "MENU",0              
40a8				endm 
# End of macro CWHEAD
40a8			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
40a8			 
40a8			;		; get number of items on the stack 
40a8			; 
40a8				 
40a8					FORTH_DSP_VALUEHL 
40a8 cd 72 1d			call macro_dsp_valuehl 
40ab				endm 
# End of macro FORTH_DSP_VALUEHL
40ab				 
40ab					if DEBUG_FORTH_WORDS_KEY 
40ab						DMARK "MNU" 
40ab f5				push af  
40ac 3a c0 40			ld a, (.dmark)  
40af 32 6b ee			ld (debug_mark),a  
40b2 3a c1 40			ld a, (.dmark+1)  
40b5 32 6c ee			ld (debug_mark+1),a  
40b8 3a c2 40			ld a, (.dmark+2)  
40bb 32 6d ee			ld (debug_mark+2),a  
40be 18 03			jr .pastdmark  
40c0 ..			.dmark: db "MNU"  
40c3 f1			.pastdmark: pop af  
40c4			endm  
# End of macro DMARK
40c4						CALLMONITOR 
40c4 cd 6f ee			call debug_vector  
40c7				endm  
# End of macro CALLMONITOR
40c7					endif 
40c7			 
40c7 45					ld b, l	 
40c8 05					dec b 
40c9			 
40c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40c9 cd 2a 1e			call macro_forth_dsp_pop 
40cc				endm 
# End of macro FORTH_DSP_POP
40cc			 
40cc			 
40cc					; go directly through the stack to pluck out the string pointers and build an array 
40cc			 
40cc			;		FORTH_DSP 
40cc			 
40cc					; hl contains top most stack item 
40cc				 
40cc 11 c1 e2				ld de, scratch 
40cf			 
40cf			.mbuild: 
40cf			 
40cf					FORTH_DSP_VALUEHL 
40cf cd 72 1d			call macro_dsp_valuehl 
40d2				endm 
# End of macro FORTH_DSP_VALUEHL
40d2			 
40d2					if DEBUG_FORTH_WORDS 
40d2						DMARK "MN3" 
40d2 f5				push af  
40d3 3a e7 40			ld a, (.dmark)  
40d6 32 6b ee			ld (debug_mark),a  
40d9 3a e8 40			ld a, (.dmark+1)  
40dc 32 6c ee			ld (debug_mark+1),a  
40df 3a e9 40			ld a, (.dmark+2)  
40e2 32 6d ee			ld (debug_mark+2),a  
40e5 18 03			jr .pastdmark  
40e7 ..			.dmark: db "MN3"  
40ea f1			.pastdmark: pop af  
40eb			endm  
# End of macro DMARK
40eb						CALLMONITOR 
40eb cd 6f ee			call debug_vector  
40ee				endm  
# End of macro CALLMONITOR
40ee					endif 
40ee eb					ex de, hl 
40ef 73					ld (hl), e 
40f0 23					inc hl 
40f1 72					ld (hl), d 
40f2 23					inc hl 
40f3 eb					ex de, hl 
40f4			 
40f4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40f4 cd 2a 1e			call macro_forth_dsp_pop 
40f7				endm 
# End of macro FORTH_DSP_POP
40f7			 
40f7 10 d6				djnz .mbuild 
40f9			 
40f9					; done add term 
40f9			 
40f9 eb					ex de, hl 
40fa 36 00				ld (hl), 0 
40fc 23					inc hl 
40fd 36 00				ld (hl), 0 
40ff			 
40ff				 
40ff					 
40ff 21 c1 e2				ld hl, scratch 
4102			 
4102					if DEBUG_FORTH_WORDS 
4102						DMARK "MNx" 
4102 f5				push af  
4103 3a 17 41			ld a, (.dmark)  
4106 32 6b ee			ld (debug_mark),a  
4109 3a 18 41			ld a, (.dmark+1)  
410c 32 6c ee			ld (debug_mark+1),a  
410f 3a 19 41			ld a, (.dmark+2)  
4112 32 6d ee			ld (debug_mark+2),a  
4115 18 03			jr .pastdmark  
4117 ..			.dmark: db "MNx"  
411a f1			.pastdmark: pop af  
411b			endm  
# End of macro DMARK
411b						CALLMONITOR 
411b cd 6f ee			call debug_vector  
411e				endm  
# End of macro CALLMONITOR
411e					endif 
411e			 
411e			 
411e			 
411e 3e 00				ld a, 0 
4120 cd ea 0b				call menu 
4123			 
4123			 
4123 6f					ld l, a 
4124 26 00				ld h, 0 
4126			 
4126					if DEBUG_FORTH_WORDS 
4126						DMARK "MNr" 
4126 f5				push af  
4127 3a 3b 41			ld a, (.dmark)  
412a 32 6b ee			ld (debug_mark),a  
412d 3a 3c 41			ld a, (.dmark+1)  
4130 32 6c ee			ld (debug_mark+1),a  
4133 3a 3d 41			ld a, (.dmark+2)  
4136 32 6d ee			ld (debug_mark+2),a  
4139 18 03			jr .pastdmark  
413b ..			.dmark: db "MNr"  
413e f1			.pastdmark: pop af  
413f			endm  
# End of macro DMARK
413f						CALLMONITOR 
413f cd 6f ee			call debug_vector  
4142				endm  
# End of macro CALLMONITOR
4142					endif 
4142			 
4142 cd 6d 1b				call forth_push_numhl 
4145			 
4145			 
4145			 
4145			 
4145				       NEXTW 
4145 c3 28 1f			jp macro_next 
4148				endm 
# End of macro NEXTW
4148			 
4148			 
4148			.ENDDISPLAY: 
4148			 
4148			; eof 
# End of file forth_words_display.asm
4148			include "forth_words_str.asm" 
4148			 
4148			; | ## String Words 
4148			 
4148			.PTR:   
4148			 
4148				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4148 48				db WORD_SYS_CORE+52             
4149 75 41			dw .STYPE            
414b 04				db 3 + 1 
414c .. 00			db "PTR",0              
4150				endm 
# End of macro CWHEAD
4150			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4150			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4150			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4150			 
4150					if DEBUG_FORTH_WORDS_KEY 
4150						DMARK "PTR" 
4150 f5				push af  
4151 3a 65 41			ld a, (.dmark)  
4154 32 6b ee			ld (debug_mark),a  
4157 3a 66 41			ld a, (.dmark+1)  
415a 32 6c ee			ld (debug_mark+1),a  
415d 3a 67 41			ld a, (.dmark+2)  
4160 32 6d ee			ld (debug_mark+2),a  
4163 18 03			jr .pastdmark  
4165 ..			.dmark: db "PTR"  
4168 f1			.pastdmark: pop af  
4169			endm  
# End of macro DMARK
4169						CALLMONITOR 
4169 cd 6f ee			call debug_vector  
416c				endm  
# End of macro CALLMONITOR
416c					endif 
416c					FORTH_DSP_VALUEHL 
416c cd 72 1d			call macro_dsp_valuehl 
416f				endm 
# End of macro FORTH_DSP_VALUEHL
416f cd 6d 1b				call forth_push_numhl 
4172			 
4172			 
4172					NEXTW 
4172 c3 28 1f			jp macro_next 
4175				endm 
# End of macro NEXTW
4175			.STYPE: 
4175				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4175 48				db WORD_SYS_CORE+52             
4176 c4 41			dw .UPPER            
4178 06				db 5 + 1 
4179 .. 00			db "STYPE",0              
417f				endm 
# End of macro CWHEAD
417f			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
417f					if DEBUG_FORTH_WORDS_KEY 
417f						DMARK "STY" 
417f f5				push af  
4180 3a 94 41			ld a, (.dmark)  
4183 32 6b ee			ld (debug_mark),a  
4186 3a 95 41			ld a, (.dmark+1)  
4189 32 6c ee			ld (debug_mark+1),a  
418c 3a 96 41			ld a, (.dmark+2)  
418f 32 6d ee			ld (debug_mark+2),a  
4192 18 03			jr .pastdmark  
4194 ..			.dmark: db "STY"  
4197 f1			.pastdmark: pop af  
4198			endm  
# End of macro DMARK
4198						CALLMONITOR 
4198 cd 6f ee			call debug_vector  
419b				endm  
# End of macro CALLMONITOR
419b					endif 
419b					FORTH_DSP 
419b cd 38 1d			call macro_forth_dsp 
419e				endm 
# End of macro FORTH_DSP
419e					;v5 FORTH_DSP_VALUE 
419e			 
419e 7e					ld a, (hl) 
419f			 
419f f5					push af 
41a0			 
41a0			; Dont destroy TOS		FORTH_DSP_POP 
41a0			 
41a0 f1					pop af 
41a1			 
41a1 fe 01				cp DS_TYPE_STR 
41a3 28 09				jr z, .typestr 
41a5			 
41a5 fe 02				cp DS_TYPE_INUM 
41a7 28 0a				jr z, .typeinum 
41a9			 
41a9 21 c2 41				ld hl, .tna 
41ac 18 0a				jr .tpush 
41ae			 
41ae 21 be 41		.typestr:	ld hl, .tstr 
41b1 18 05				jr .tpush 
41b3 21 c0 41		.typeinum:	ld hl, .tinum 
41b6 18 00				jr .tpush 
41b8			 
41b8			.tpush: 
41b8			 
41b8 cd db 1b				call forth_push_str 
41bb			 
41bb					NEXTW 
41bb c3 28 1f			jp macro_next 
41be				endm 
# End of macro NEXTW
41be .. 00		.tstr:	db "s",0 
41c0 .. 00		.tinum:  db "i",0 
41c2 .. 00		.tna:   db "?", 0 
41c4			 
41c4			 
41c4			.UPPER: 
41c4				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
41c4 48				db WORD_SYS_CORE+52             
41c5 ff 41			dw .LOWER            
41c7 06				db 5 + 1 
41c8 .. 00			db "UPPER",0              
41ce				endm 
# End of macro CWHEAD
41ce			; | UPPER ( s -- s ) Upper case string s  | DONE 
41ce					if DEBUG_FORTH_WORDS_KEY 
41ce						DMARK "UPR" 
41ce f5				push af  
41cf 3a e3 41			ld a, (.dmark)  
41d2 32 6b ee			ld (debug_mark),a  
41d5 3a e4 41			ld a, (.dmark+1)  
41d8 32 6c ee			ld (debug_mark+1),a  
41db 3a e5 41			ld a, (.dmark+2)  
41de 32 6d ee			ld (debug_mark+2),a  
41e1 18 03			jr .pastdmark  
41e3 ..			.dmark: db "UPR"  
41e6 f1			.pastdmark: pop af  
41e7			endm  
# End of macro DMARK
41e7						CALLMONITOR 
41e7 cd 6f ee			call debug_vector  
41ea				endm  
# End of macro CALLMONITOR
41ea					endif 
41ea			 
41ea					FORTH_DSP 
41ea cd 38 1d			call macro_forth_dsp 
41ed				endm 
# End of macro FORTH_DSP
41ed					 
41ed			; TODO check is string type 
41ed			 
41ed					FORTH_DSP_VALUEHL 
41ed cd 72 1d			call macro_dsp_valuehl 
41f0				endm 
# End of macro FORTH_DSP_VALUEHL
41f0			; get pointer to string in hl 
41f0			 
41f0 7e			.toup:		ld a, (hl) 
41f1 fe 00				cp 0 
41f3 28 07				jr z, .toupdone 
41f5			 
41f5 cd 5b 10				call to_upper 
41f8			 
41f8 77					ld (hl), a 
41f9 23					inc hl 
41fa 18 f4				jr .toup 
41fc			 
41fc					 
41fc			 
41fc			 
41fc			; for each char convert to upper 
41fc					 
41fc			.toupdone: 
41fc			 
41fc			 
41fc					NEXTW 
41fc c3 28 1f			jp macro_next 
41ff				endm 
# End of macro NEXTW
41ff			.LOWER: 
41ff				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
41ff 48				db WORD_SYS_CORE+52             
4200 3a 42			dw .TCASE            
4202 06				db 5 + 1 
4203 .. 00			db "LOWER",0              
4209				endm 
# End of macro CWHEAD
4209			; | LOWER ( s -- s ) Lower case string s  | DONE 
4209					if DEBUG_FORTH_WORDS_KEY 
4209						DMARK "LWR" 
4209 f5				push af  
420a 3a 1e 42			ld a, (.dmark)  
420d 32 6b ee			ld (debug_mark),a  
4210 3a 1f 42			ld a, (.dmark+1)  
4213 32 6c ee			ld (debug_mark+1),a  
4216 3a 20 42			ld a, (.dmark+2)  
4219 32 6d ee			ld (debug_mark+2),a  
421c 18 03			jr .pastdmark  
421e ..			.dmark: db "LWR"  
4221 f1			.pastdmark: pop af  
4222			endm  
# End of macro DMARK
4222						CALLMONITOR 
4222 cd 6f ee			call debug_vector  
4225				endm  
# End of macro CALLMONITOR
4225					endif 
4225			 
4225					FORTH_DSP 
4225 cd 38 1d			call macro_forth_dsp 
4228				endm 
# End of macro FORTH_DSP
4228					 
4228			; TODO check is string type 
4228			 
4228					FORTH_DSP_VALUEHL 
4228 cd 72 1d			call macro_dsp_valuehl 
422b				endm 
# End of macro FORTH_DSP_VALUEHL
422b			; get pointer to string in hl 
422b			 
422b 7e			.tolow:		ld a, (hl) 
422c fe 00				cp 0 
422e 28 07				jr z, .tolowdone 
4230			 
4230 cd 64 10				call to_lower 
4233			 
4233 77					ld (hl), a 
4234 23					inc hl 
4235 18 f4				jr .tolow 
4237			 
4237					 
4237			 
4237			 
4237			; for each char convert to low 
4237					 
4237			.tolowdone: 
4237					NEXTW 
4237 c3 28 1f			jp macro_next 
423a				endm 
# End of macro NEXTW
423a			.TCASE: 
423a				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
423a 48				db WORD_SYS_CORE+52             
423b 70 43			dw .SUBSTR            
423d 06				db 5 + 1 
423e .. 00			db "TCASE",0              
4244				endm 
# End of macro CWHEAD
4244			; | TCASE ( s -- s ) Title case string s  | DONE 
4244					if DEBUG_FORTH_WORDS_KEY 
4244						DMARK "TCS" 
4244 f5				push af  
4245 3a 59 42			ld a, (.dmark)  
4248 32 6b ee			ld (debug_mark),a  
424b 3a 5a 42			ld a, (.dmark+1)  
424e 32 6c ee			ld (debug_mark+1),a  
4251 3a 5b 42			ld a, (.dmark+2)  
4254 32 6d ee			ld (debug_mark+2),a  
4257 18 03			jr .pastdmark  
4259 ..			.dmark: db "TCS"  
425c f1			.pastdmark: pop af  
425d			endm  
# End of macro DMARK
425d						CALLMONITOR 
425d cd 6f ee			call debug_vector  
4260				endm  
# End of macro CALLMONITOR
4260					endif 
4260			 
4260					FORTH_DSP 
4260 cd 38 1d			call macro_forth_dsp 
4263				endm 
# End of macro FORTH_DSP
4263					 
4263			; TODO check is string type 
4263			 
4263					FORTH_DSP_VALUEHL 
4263 cd 72 1d			call macro_dsp_valuehl 
4266				endm 
# End of macro FORTH_DSP_VALUEHL
4266			; get pointer to string in hl 
4266			 
4266					if DEBUG_FORTH_WORDS 
4266						DMARK "TC1" 
4266 f5				push af  
4267 3a 7b 42			ld a, (.dmark)  
426a 32 6b ee			ld (debug_mark),a  
426d 3a 7c 42			ld a, (.dmark+1)  
4270 32 6c ee			ld (debug_mark+1),a  
4273 3a 7d 42			ld a, (.dmark+2)  
4276 32 6d ee			ld (debug_mark+2),a  
4279 18 03			jr .pastdmark  
427b ..			.dmark: db "TC1"  
427e f1			.pastdmark: pop af  
427f			endm  
# End of macro DMARK
427f						CALLMONITOR 
427f cd 6f ee			call debug_vector  
4282				endm  
# End of macro CALLMONITOR
4282					endif 
4282			 
4282					; first time in turn to upper case first char 
4282			 
4282 7e					ld a, (hl) 
4283 c3 0d 43				jp .totsiptou 
4286			 
4286			 
4286 7e			.tot:		ld a, (hl) 
4287 fe 00				cp 0 
4289 ca 51 43				jp z, .totdone 
428c			 
428c					if DEBUG_FORTH_WORDS 
428c						DMARK "TC2" 
428c f5				push af  
428d 3a a1 42			ld a, (.dmark)  
4290 32 6b ee			ld (debug_mark),a  
4293 3a a2 42			ld a, (.dmark+1)  
4296 32 6c ee			ld (debug_mark+1),a  
4299 3a a3 42			ld a, (.dmark+2)  
429c 32 6d ee			ld (debug_mark+2),a  
429f 18 03			jr .pastdmark  
42a1 ..			.dmark: db "TC2"  
42a4 f1			.pastdmark: pop af  
42a5			endm  
# End of macro DMARK
42a5						CALLMONITOR 
42a5 cd 6f ee			call debug_vector  
42a8				endm  
# End of macro CALLMONITOR
42a8					endif 
42a8					; check to see if current char is a space 
42a8			 
42a8 fe 20				cp ' ' 
42aa 28 21				jr z, .totsp 
42ac cd 64 10				call to_lower 
42af					if DEBUG_FORTH_WORDS 
42af						DMARK "TC3" 
42af f5				push af  
42b0 3a c4 42			ld a, (.dmark)  
42b3 32 6b ee			ld (debug_mark),a  
42b6 3a c5 42			ld a, (.dmark+1)  
42b9 32 6c ee			ld (debug_mark+1),a  
42bc 3a c6 42			ld a, (.dmark+2)  
42bf 32 6d ee			ld (debug_mark+2),a  
42c2 18 03			jr .pastdmark  
42c4 ..			.dmark: db "TC3"  
42c7 f1			.pastdmark: pop af  
42c8			endm  
# End of macro DMARK
42c8						CALLMONITOR 
42c8 cd 6f ee			call debug_vector  
42cb				endm  
# End of macro CALLMONITOR
42cb					endif 
42cb 18 63				jr .totnxt 
42cd			 
42cd			.totsp:         ; on a space, find next char which should be upper 
42cd			 
42cd					if DEBUG_FORTH_WORDS 
42cd						DMARK "TC4" 
42cd f5				push af  
42ce 3a e2 42			ld a, (.dmark)  
42d1 32 6b ee			ld (debug_mark),a  
42d4 3a e3 42			ld a, (.dmark+1)  
42d7 32 6c ee			ld (debug_mark+1),a  
42da 3a e4 42			ld a, (.dmark+2)  
42dd 32 6d ee			ld (debug_mark+2),a  
42e0 18 03			jr .pastdmark  
42e2 ..			.dmark: db "TC4"  
42e5 f1			.pastdmark: pop af  
42e6			endm  
# End of macro DMARK
42e6						CALLMONITOR 
42e6 cd 6f ee			call debug_vector  
42e9				endm  
# End of macro CALLMONITOR
42e9					endif 
42e9					;; 
42e9			 
42e9 fe 20				cp ' ' 
42eb 20 20				jr nz, .totsiptou 
42ed 23					inc hl 
42ee 7e					ld a, (hl) 
42ef					if DEBUG_FORTH_WORDS 
42ef						DMARK "TC5" 
42ef f5				push af  
42f0 3a 04 43			ld a, (.dmark)  
42f3 32 6b ee			ld (debug_mark),a  
42f6 3a 05 43			ld a, (.dmark+1)  
42f9 32 6c ee			ld (debug_mark+1),a  
42fc 3a 06 43			ld a, (.dmark+2)  
42ff 32 6d ee			ld (debug_mark+2),a  
4302 18 03			jr .pastdmark  
4304 ..			.dmark: db "TC5"  
4307 f1			.pastdmark: pop af  
4308			endm  
# End of macro DMARK
4308						CALLMONITOR 
4308 cd 6f ee			call debug_vector  
430b				endm  
# End of macro CALLMONITOR
430b					endif 
430b 18 c0				jr .totsp 
430d fe 00		.totsiptou:    cp 0 
430f 28 40				jr z, .totdone 
4311					; not space and not zero term so upper case it 
4311 cd 5b 10				call to_upper 
4314			 
4314					if DEBUG_FORTH_WORDS 
4314						DMARK "TC6" 
4314 f5				push af  
4315 3a 29 43			ld a, (.dmark)  
4318 32 6b ee			ld (debug_mark),a  
431b 3a 2a 43			ld a, (.dmark+1)  
431e 32 6c ee			ld (debug_mark+1),a  
4321 3a 2b 43			ld a, (.dmark+2)  
4324 32 6d ee			ld (debug_mark+2),a  
4327 18 03			jr .pastdmark  
4329 ..			.dmark: db "TC6"  
432c f1			.pastdmark: pop af  
432d			endm  
# End of macro DMARK
432d						CALLMONITOR 
432d cd 6f ee			call debug_vector  
4330				endm  
# End of macro CALLMONITOR
4330					endif 
4330			 
4330			 
4330			.totnxt: 
4330			 
4330 77					ld (hl), a 
4331 23					inc hl 
4332					if DEBUG_FORTH_WORDS 
4332						DMARK "TC7" 
4332 f5				push af  
4333 3a 47 43			ld a, (.dmark)  
4336 32 6b ee			ld (debug_mark),a  
4339 3a 48 43			ld a, (.dmark+1)  
433c 32 6c ee			ld (debug_mark+1),a  
433f 3a 49 43			ld a, (.dmark+2)  
4342 32 6d ee			ld (debug_mark+2),a  
4345 18 03			jr .pastdmark  
4347 ..			.dmark: db "TC7"  
434a f1			.pastdmark: pop af  
434b			endm  
# End of macro DMARK
434b						CALLMONITOR 
434b cd 6f ee			call debug_vector  
434e				endm  
# End of macro CALLMONITOR
434e					endif 
434e c3 86 42				jp .tot 
4351			 
4351					 
4351			 
4351			 
4351			; for each char convert to low 
4351					 
4351			.totdone: 
4351					if DEBUG_FORTH_WORDS 
4351						DMARK "TCd" 
4351 f5				push af  
4352 3a 66 43			ld a, (.dmark)  
4355 32 6b ee			ld (debug_mark),a  
4358 3a 67 43			ld a, (.dmark+1)  
435b 32 6c ee			ld (debug_mark+1),a  
435e 3a 68 43			ld a, (.dmark+2)  
4361 32 6d ee			ld (debug_mark+2),a  
4364 18 03			jr .pastdmark  
4366 ..			.dmark: db "TCd"  
4369 f1			.pastdmark: pop af  
436a			endm  
# End of macro DMARK
436a						CALLMONITOR 
436a cd 6f ee			call debug_vector  
436d				endm  
# End of macro CALLMONITOR
436d					endif 
436d					NEXTW 
436d c3 28 1f			jp macro_next 
4370				endm 
# End of macro NEXTW
4370			 
4370			.SUBSTR: 
4370				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4370 48				db WORD_SYS_CORE+52             
4371 ce 43			dw .LEFT            
4373 07				db 6 + 1 
4374 .. 00			db "SUBSTR",0              
437b				endm 
# End of macro CWHEAD
437b			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
437b			 
437b					if DEBUG_FORTH_WORDS_KEY 
437b						DMARK "SST" 
437b f5				push af  
437c 3a 90 43			ld a, (.dmark)  
437f 32 6b ee			ld (debug_mark),a  
4382 3a 91 43			ld a, (.dmark+1)  
4385 32 6c ee			ld (debug_mark+1),a  
4388 3a 92 43			ld a, (.dmark+2)  
438b 32 6d ee			ld (debug_mark+2),a  
438e 18 03			jr .pastdmark  
4390 ..			.dmark: db "SST"  
4393 f1			.pastdmark: pop af  
4394			endm  
# End of macro DMARK
4394						CALLMONITOR 
4394 cd 6f ee			call debug_vector  
4397				endm  
# End of macro CALLMONITOR
4397					endif 
4397			; TODO check string type 
4397					FORTH_DSP_VALUEHL 
4397 cd 72 1d			call macro_dsp_valuehl 
439a				endm 
# End of macro FORTH_DSP_VALUEHL
439a			 
439a e5					push hl      ; string length 
439b			 
439b					FORTH_DSP_POP 
439b cd 2a 1e			call macro_forth_dsp_pop 
439e				endm 
# End of macro FORTH_DSP_POP
439e			 
439e					FORTH_DSP_VALUEHL 
439e cd 72 1d			call macro_dsp_valuehl 
43a1				endm 
# End of macro FORTH_DSP_VALUEHL
43a1			 
43a1 e5					push hl     ; start char 
43a2			 
43a2					FORTH_DSP_POP 
43a2 cd 2a 1e			call macro_forth_dsp_pop 
43a5				endm 
# End of macro FORTH_DSP_POP
43a5			 
43a5			 
43a5					FORTH_DSP_VALUE 
43a5 cd 5b 1d			call macro_forth_dsp_value 
43a8				endm 
# End of macro FORTH_DSP_VALUE
43a8			 
43a8 d1					pop de    ; get start post offset 
43a9			 
43a9 19					add hl, de    ; starting offset 
43aa			 
43aa c1					pop bc 
43ab c5					push bc      ; grab size of string 
43ac			 
43ac e5					push hl    ; save string start  
43ad			 
43ad 26 00				ld h, 0 
43af 69					ld l, c 
43b0 23					inc hl 
43b1 23					inc hl 
43b2			 
43b2 cd c1 11				call malloc 
43b5				if DEBUG_FORTH_MALLOC_GUARD 
43b5 cc e8 4c				call z,malloc_error 
43b8				endif 
43b8			 
43b8 eb					ex de, hl      ; save malloc area for string copy 
43b9 e1					pop hl    ; get back source 
43ba c1					pop bc    ; get length of string back 
43bb			 
43bb d5					push de    ; save malloc area for after we push 
43bc ed b0				ldir     ; copy substr 
43be			 
43be			 
43be eb					ex de, hl 
43bf 3e 00				ld a, 0 
43c1 77					ld (hl), a   ; term substr 
43c2			 
43c2					 
43c2 e1					pop hl    ; get malloc so we can push it 
43c3 e5					push hl   ; save so we can free it afterwards 
43c4			 
43c4 cd db 1b				call forth_push_str 
43c7			 
43c7 e1					pop hl 
43c8 cd 8b 12				call free 
43cb			 
43cb					 
43cb					 
43cb			 
43cb			 
43cb					NEXTW 
43cb c3 28 1f			jp macro_next 
43ce				endm 
# End of macro NEXTW
43ce			 
43ce			.LEFT: 
43ce				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
43ce 48				db WORD_SYS_CORE+52             
43cf f6 43			dw .RIGHT            
43d1 05				db 4 + 1 
43d2 .. 00			db "LEFT",0              
43d7				endm 
# End of macro CWHEAD
43d7			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
43d7					if DEBUG_FORTH_WORDS_KEY 
43d7						DMARK "LEF" 
43d7 f5				push af  
43d8 3a ec 43			ld a, (.dmark)  
43db 32 6b ee			ld (debug_mark),a  
43de 3a ed 43			ld a, (.dmark+1)  
43e1 32 6c ee			ld (debug_mark+1),a  
43e4 3a ee 43			ld a, (.dmark+2)  
43e7 32 6d ee			ld (debug_mark+2),a  
43ea 18 03			jr .pastdmark  
43ec ..			.dmark: db "LEF"  
43ef f1			.pastdmark: pop af  
43f0			endm  
# End of macro DMARK
43f0						CALLMONITOR 
43f0 cd 6f ee			call debug_vector  
43f3				endm  
# End of macro CALLMONITOR
43f3					endif 
43f3			 
43f3					NEXTW 
43f3 c3 28 1f			jp macro_next 
43f6				endm 
# End of macro NEXTW
43f6			.RIGHT: 
43f6				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
43f6 48				db WORD_SYS_CORE+52             
43f7 1f 44			dw .STR2NUM            
43f9 06				db 5 + 1 
43fa .. 00			db "RIGHT",0              
4400				endm 
# End of macro CWHEAD
4400			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4400					if DEBUG_FORTH_WORDS_KEY 
4400						DMARK "RIG" 
4400 f5				push af  
4401 3a 15 44			ld a, (.dmark)  
4404 32 6b ee			ld (debug_mark),a  
4407 3a 16 44			ld a, (.dmark+1)  
440a 32 6c ee			ld (debug_mark+1),a  
440d 3a 17 44			ld a, (.dmark+2)  
4410 32 6d ee			ld (debug_mark+2),a  
4413 18 03			jr .pastdmark  
4415 ..			.dmark: db "RIG"  
4418 f1			.pastdmark: pop af  
4419			endm  
# End of macro DMARK
4419						CALLMONITOR 
4419 cd 6f ee			call debug_vector  
441c				endm  
# End of macro CALLMONITOR
441c					endif 
441c			 
441c					NEXTW 
441c c3 28 1f			jp macro_next 
441f				endm 
# End of macro NEXTW
441f			 
441f			 
441f			.STR2NUM: 
441f				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
441f 48				db WORD_SYS_CORE+52             
4420 ab 44			dw .NUM2STR            
4422 08				db 7 + 1 
4423 .. 00			db "STR2NUM",0              
442b				endm 
# End of macro CWHEAD
442b			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
442b			 
442b			 
442b			; TODO STR type check to do 
442b					if DEBUG_FORTH_WORDS_KEY 
442b						DMARK "S2N" 
442b f5				push af  
442c 3a 40 44			ld a, (.dmark)  
442f 32 6b ee			ld (debug_mark),a  
4432 3a 41 44			ld a, (.dmark+1)  
4435 32 6c ee			ld (debug_mark+1),a  
4438 3a 42 44			ld a, (.dmark+2)  
443b 32 6d ee			ld (debug_mark+2),a  
443e 18 03			jr .pastdmark  
4440 ..			.dmark: db "S2N"  
4443 f1			.pastdmark: pop af  
4444			endm  
# End of macro DMARK
4444						CALLMONITOR 
4444 cd 6f ee			call debug_vector  
4447				endm  
# End of macro CALLMONITOR
4447					endif 
4447			 
4447					;FORTH_DSP 
4447					FORTH_DSP_VALUE 
4447 cd 5b 1d			call macro_forth_dsp_value 
444a				endm 
# End of macro FORTH_DSP_VALUE
444a					;inc hl 
444a			 
444a eb					ex de, hl 
444b					if DEBUG_FORTH_WORDS 
444b						DMARK "S2a" 
444b f5				push af  
444c 3a 60 44			ld a, (.dmark)  
444f 32 6b ee			ld (debug_mark),a  
4452 3a 61 44			ld a, (.dmark+1)  
4455 32 6c ee			ld (debug_mark+1),a  
4458 3a 62 44			ld a, (.dmark+2)  
445b 32 6d ee			ld (debug_mark+2),a  
445e 18 03			jr .pastdmark  
4460 ..			.dmark: db "S2a"  
4463 f1			.pastdmark: pop af  
4464			endm  
# End of macro DMARK
4464						CALLMONITOR 
4464 cd 6f ee			call debug_vector  
4467				endm  
# End of macro CALLMONITOR
4467					endif 
4467 cd e3 10				call string_to_uint16 
446a			 
446a					if DEBUG_FORTH_WORDS 
446a						DMARK "S2b" 
446a f5				push af  
446b 3a 7f 44			ld a, (.dmark)  
446e 32 6b ee			ld (debug_mark),a  
4471 3a 80 44			ld a, (.dmark+1)  
4474 32 6c ee			ld (debug_mark+1),a  
4477 3a 81 44			ld a, (.dmark+2)  
447a 32 6d ee			ld (debug_mark+2),a  
447d 18 03			jr .pastdmark  
447f ..			.dmark: db "S2b"  
4482 f1			.pastdmark: pop af  
4483			endm  
# End of macro DMARK
4483						CALLMONITOR 
4483 cd 6f ee			call debug_vector  
4486				endm  
# End of macro CALLMONITOR
4486					endif 
4486			;		push hl 
4486					FORTH_DSP_POP 
4486 cd 2a 1e			call macro_forth_dsp_pop 
4489				endm 
# End of macro FORTH_DSP_POP
4489			;		pop hl 
4489					 
4489					if DEBUG_FORTH_WORDS 
4489						DMARK "S2b" 
4489 f5				push af  
448a 3a 9e 44			ld a, (.dmark)  
448d 32 6b ee			ld (debug_mark),a  
4490 3a 9f 44			ld a, (.dmark+1)  
4493 32 6c ee			ld (debug_mark+1),a  
4496 3a a0 44			ld a, (.dmark+2)  
4499 32 6d ee			ld (debug_mark+2),a  
449c 18 03			jr .pastdmark  
449e ..			.dmark: db "S2b"  
44a1 f1			.pastdmark: pop af  
44a2			endm  
# End of macro DMARK
44a2						CALLMONITOR 
44a2 cd 6f ee			call debug_vector  
44a5				endm  
# End of macro CALLMONITOR
44a5					endif 
44a5 cd 6d 1b				call forth_push_numhl	 
44a8			 
44a8				 
44a8				       NEXTW 
44a8 c3 28 1f			jp macro_next 
44ab				endm 
# End of macro NEXTW
44ab			.NUM2STR: 
44ab				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
44ab 48				db WORD_SYS_CORE+52             
44ac ba 44			dw .CONCAT            
44ae 08				db 7 + 1 
44af .. 00			db "NUM2STR",0              
44b7				endm 
# End of macro CWHEAD
44b7			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
44b7			 
44b7			;		; malloc a string to target 
44b7			;		ld hl, 10     ; TODO max string size should be fine 
44b7			;		call malloc 
44b7			;		push hl    ; save malloc location 
44b7			; 
44b7			; 
44b7			;; TODO check int type 
44b7			;		FORTH_DSP_VALUEHL 
44b7			;		ld a, l 
44b7			;		call DispAToASCII   
44b7			;;TODO need to chage above call to dump into string 
44b7			; 
44b7			; 
44b7			 
44b7				       NEXTW 
44b7 c3 28 1f			jp macro_next 
44ba				endm 
# End of macro NEXTW
44ba			 
44ba			.CONCAT: 
44ba				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
44ba 48				db WORD_SYS_CORE+52             
44bb 6d 45			dw .FIND            
44bd 07				db 6 + 1 
44be .. 00			db "CONCAT",0              
44c5				endm 
# End of macro CWHEAD
44c5			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
44c5			 
44c5			; TODO check string type 
44c5			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
44c5			 
44c5					if DEBUG_FORTH_WORDS_KEY 
44c5						DMARK "CON" 
44c5 f5				push af  
44c6 3a da 44			ld a, (.dmark)  
44c9 32 6b ee			ld (debug_mark),a  
44cc 3a db 44			ld a, (.dmark+1)  
44cf 32 6c ee			ld (debug_mark+1),a  
44d2 3a dc 44			ld a, (.dmark+2)  
44d5 32 6d ee			ld (debug_mark+2),a  
44d8 18 03			jr .pastdmark  
44da ..			.dmark: db "CON"  
44dd f1			.pastdmark: pop af  
44de			endm  
# End of macro DMARK
44de						CALLMONITOR 
44de cd 6f ee			call debug_vector  
44e1				endm  
# End of macro CALLMONITOR
44e1					endif 
44e1			 
44e1			 
44e1					FORTH_DSP_VALUE 
44e1 cd 5b 1d			call macro_forth_dsp_value 
44e4				endm 
# End of macro FORTH_DSP_VALUE
44e4 e5					push hl   ; s2 
44e5			 
44e5					FORTH_DSP_POP 
44e5 cd 2a 1e			call macro_forth_dsp_pop 
44e8				endm 
# End of macro FORTH_DSP_POP
44e8			 
44e8					FORTH_DSP_VALUE 
44e8 cd 5b 1d			call macro_forth_dsp_value 
44eb				endm 
# End of macro FORTH_DSP_VALUE
44eb			 
44eb e5					push hl   ; s1 
44ec			 
44ec					FORTH_DSP_POP 
44ec cd 2a 1e			call macro_forth_dsp_pop 
44ef				endm 
# End of macro FORTH_DSP_POP
44ef					 
44ef			 
44ef					; copy s1 
44ef			 
44ef				 
44ef					; save ptr 
44ef e1					pop hl  
44f0 e5					push hl 
44f1 3e 00				ld a, 0 
44f3 cd 57 11				call strlent 
44f6					;inc hl    ; zer0 
44f6 06 00				ld b, 0 
44f8 4d					ld c, l 
44f9 e1					pop hl		 
44fa 11 c1 e2				ld de, scratch	 
44fd					if DEBUG_FORTH_WORDS 
44fd						DMARK "CO1" 
44fd f5				push af  
44fe 3a 12 45			ld a, (.dmark)  
4501 32 6b ee			ld (debug_mark),a  
4504 3a 13 45			ld a, (.dmark+1)  
4507 32 6c ee			ld (debug_mark+1),a  
450a 3a 14 45			ld a, (.dmark+2)  
450d 32 6d ee			ld (debug_mark+2),a  
4510 18 03			jr .pastdmark  
4512 ..			.dmark: db "CO1"  
4515 f1			.pastdmark: pop af  
4516			endm  
# End of macro DMARK
4516						CALLMONITOR 
4516 cd 6f ee			call debug_vector  
4519				endm  
# End of macro CALLMONITOR
4519					endif 
4519 ed b0				ldir 
451b			 
451b e1					pop hl 
451c e5					push hl 
451d d5					push de 
451e			 
451e			 
451e 3e 00				ld a, 0 
4520 cd 57 11				call strlent 
4523 23					inc hl    ; zer0 
4524 23					inc hl 
4525 06 00				ld b, 0 
4527 4d					ld c, l 
4528 d1					pop de 
4529 e1					pop hl		 
452a					if DEBUG_FORTH_WORDS 
452a						DMARK "CO2" 
452a f5				push af  
452b 3a 3f 45			ld a, (.dmark)  
452e 32 6b ee			ld (debug_mark),a  
4531 3a 40 45			ld a, (.dmark+1)  
4534 32 6c ee			ld (debug_mark+1),a  
4537 3a 41 45			ld a, (.dmark+2)  
453a 32 6d ee			ld (debug_mark+2),a  
453d 18 03			jr .pastdmark  
453f ..			.dmark: db "CO2"  
4542 f1			.pastdmark: pop af  
4543			endm  
# End of macro DMARK
4543						CALLMONITOR 
4543 cd 6f ee			call debug_vector  
4546				endm  
# End of macro CALLMONITOR
4546					endif 
4546 ed b0				ldir 
4548			 
4548			 
4548			 
4548 21 c1 e2				ld hl, scratch 
454b					if DEBUG_FORTH_WORDS 
454b						DMARK "CO5" 
454b f5				push af  
454c 3a 60 45			ld a, (.dmark)  
454f 32 6b ee			ld (debug_mark),a  
4552 3a 61 45			ld a, (.dmark+1)  
4555 32 6c ee			ld (debug_mark+1),a  
4558 3a 62 45			ld a, (.dmark+2)  
455b 32 6d ee			ld (debug_mark+2),a  
455e 18 03			jr .pastdmark  
4560 ..			.dmark: db "CO5"  
4563 f1			.pastdmark: pop af  
4564			endm  
# End of macro DMARK
4564						CALLMONITOR 
4564 cd 6f ee			call debug_vector  
4567				endm  
# End of macro CALLMONITOR
4567					endif 
4567			 
4567 cd db 1b				call forth_push_str 
456a			 
456a			 
456a			 
456a			 
456a				       NEXTW 
456a c3 28 1f			jp macro_next 
456d				endm 
# End of macro NEXTW
456d			 
456d			 
456d			.FIND: 
456d				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
456d 4b				db WORD_SYS_CORE+55             
456e 2b 46			dw .LEN            
4570 05				db 4 + 1 
4571 .. 00			db "FIND",0              
4576				endm 
# End of macro CWHEAD
4576			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4576			 
4576					if DEBUG_FORTH_WORDS_KEY 
4576						DMARK "FND" 
4576 f5				push af  
4577 3a 8b 45			ld a, (.dmark)  
457a 32 6b ee			ld (debug_mark),a  
457d 3a 8c 45			ld a, (.dmark+1)  
4580 32 6c ee			ld (debug_mark+1),a  
4583 3a 8d 45			ld a, (.dmark+2)  
4586 32 6d ee			ld (debug_mark+2),a  
4589 18 03			jr .pastdmark  
458b ..			.dmark: db "FND"  
458e f1			.pastdmark: pop af  
458f			endm  
# End of macro DMARK
458f						CALLMONITOR 
458f cd 6f ee			call debug_vector  
4592				endm  
# End of macro CALLMONITOR
4592					endif 
4592			 
4592			; TODO check string type 
4592					FORTH_DSP_VALUE 
4592 cd 5b 1d			call macro_forth_dsp_value 
4595				endm 
# End of macro FORTH_DSP_VALUE
4595			 
4595 e5					push hl    
4596 7e					ld a,(hl)    ; char to find   
4597			; TODO change char to substr 
4597			 
4597 f5					push af 
4598					 
4598			 
4598			 
4598					if DEBUG_FORTH_WORDS 
4598						DMARK "FN1" 
4598 f5				push af  
4599 3a ad 45			ld a, (.dmark)  
459c 32 6b ee			ld (debug_mark),a  
459f 3a ae 45			ld a, (.dmark+1)  
45a2 32 6c ee			ld (debug_mark+1),a  
45a5 3a af 45			ld a, (.dmark+2)  
45a8 32 6d ee			ld (debug_mark+2),a  
45ab 18 03			jr .pastdmark  
45ad ..			.dmark: db "FN1"  
45b0 f1			.pastdmark: pop af  
45b1			endm  
# End of macro DMARK
45b1						CALLMONITOR 
45b1 cd 6f ee			call debug_vector  
45b4				endm  
# End of macro CALLMONITOR
45b4					endif 
45b4			 
45b4					FORTH_DSP_POP 
45b4 cd 2a 1e			call macro_forth_dsp_pop 
45b7				endm 
# End of macro FORTH_DSP_POP
45b7			 
45b7					; string to search 
45b7			 
45b7					FORTH_DSP_VALUE 
45b7 cd 5b 1d			call macro_forth_dsp_value 
45ba				endm 
# End of macro FORTH_DSP_VALUE
45ba			 
45ba d1					pop de  ; d is char to find  
45bb			 
45bb					if DEBUG_FORTH_WORDS 
45bb						DMARK "FN2" 
45bb f5				push af  
45bc 3a d0 45			ld a, (.dmark)  
45bf 32 6b ee			ld (debug_mark),a  
45c2 3a d1 45			ld a, (.dmark+1)  
45c5 32 6c ee			ld (debug_mark+1),a  
45c8 3a d2 45			ld a, (.dmark+2)  
45cb 32 6d ee			ld (debug_mark+2),a  
45ce 18 03			jr .pastdmark  
45d0 ..			.dmark: db "FN2"  
45d3 f1			.pastdmark: pop af  
45d4			endm  
# End of macro DMARK
45d4						CALLMONITOR 
45d4 cd 6f ee			call debug_vector  
45d7				endm  
# End of macro CALLMONITOR
45d7					endif 
45d7					 
45d7 01 00 00				ld bc, 0 
45da 7e			.findchar:      ld a,(hl) 
45db fe 00				cp 0   		 
45dd 28 27				jr z, .finddone     
45df ba					cp d 
45e0 28 20				jr z, .foundchar 
45e2 03					inc bc 
45e3 23					inc hl 
45e4					if DEBUG_FORTH_WORDS 
45e4						DMARK "FN3" 
45e4 f5				push af  
45e5 3a f9 45			ld a, (.dmark)  
45e8 32 6b ee			ld (debug_mark),a  
45eb 3a fa 45			ld a, (.dmark+1)  
45ee 32 6c ee			ld (debug_mark+1),a  
45f1 3a fb 45			ld a, (.dmark+2)  
45f4 32 6d ee			ld (debug_mark+2),a  
45f7 18 03			jr .pastdmark  
45f9 ..			.dmark: db "FN3"  
45fc f1			.pastdmark: pop af  
45fd			endm  
# End of macro DMARK
45fd						CALLMONITOR 
45fd cd 6f ee			call debug_vector  
4600				endm  
# End of macro CALLMONITOR
4600					endif 
4600 18 d8				jr .findchar 
4602			 
4602			 
4602 c5			.foundchar:	push bc 
4603 e1					pop hl 
4604 18 03				jr .findexit 
4606			 
4606			 
4606							 
4606			 
4606			.finddone:     ; got to end of string with no find 
4606 21 00 00				ld hl, 0 
4609			.findexit: 
4609			 
4609					if DEBUG_FORTH_WORDS 
4609						DMARK "FNd" 
4609 f5				push af  
460a 3a 1e 46			ld a, (.dmark)  
460d 32 6b ee			ld (debug_mark),a  
4610 3a 1f 46			ld a, (.dmark+1)  
4613 32 6c ee			ld (debug_mark+1),a  
4616 3a 20 46			ld a, (.dmark+2)  
4619 32 6d ee			ld (debug_mark+2),a  
461c 18 03			jr .pastdmark  
461e ..			.dmark: db "FNd"  
4621 f1			.pastdmark: pop af  
4622			endm  
# End of macro DMARK
4622						CALLMONITOR 
4622 cd 6f ee			call debug_vector  
4625				endm  
# End of macro CALLMONITOR
4625					endif 
4625 cd 6d 1b			call forth_push_numhl 
4628			 
4628				       NEXTW 
4628 c3 28 1f			jp macro_next 
462b				endm 
# End of macro NEXTW
462b			 
462b			.LEN: 
462b				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
462b 4c				db WORD_SYS_CORE+56             
462c 95 46			dw .ASC            
462e 06				db 5 + 1 
462f .. 00			db "COUNT",0              
4635				endm 
# End of macro CWHEAD
4635			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4635			 
4635					if DEBUG_FORTH_WORDS_KEY 
4635						DMARK "CNT" 
4635 f5				push af  
4636 3a 4a 46			ld a, (.dmark)  
4639 32 6b ee			ld (debug_mark),a  
463c 3a 4b 46			ld a, (.dmark+1)  
463f 32 6c ee			ld (debug_mark+1),a  
4642 3a 4c 46			ld a, (.dmark+2)  
4645 32 6d ee			ld (debug_mark+2),a  
4648 18 03			jr .pastdmark  
464a ..			.dmark: db "CNT"  
464d f1			.pastdmark: pop af  
464e			endm  
# End of macro DMARK
464e						CALLMONITOR 
464e cd 6f ee			call debug_vector  
4651				endm  
# End of macro CALLMONITOR
4651					endif 
4651			; TODO check string type 
4651					FORTH_DSP_VALUE 
4651 cd 5b 1d			call macro_forth_dsp_value 
4654				endm 
# End of macro FORTH_DSP_VALUE
4654			 
4654			 
4654					if DEBUG_FORTH_WORDS 
4654						DMARK "CN?" 
4654 f5				push af  
4655 3a 69 46			ld a, (.dmark)  
4658 32 6b ee			ld (debug_mark),a  
465b 3a 6a 46			ld a, (.dmark+1)  
465e 32 6c ee			ld (debug_mark+1),a  
4661 3a 6b 46			ld a, (.dmark+2)  
4664 32 6d ee			ld (debug_mark+2),a  
4667 18 03			jr .pastdmark  
4669 ..			.dmark: db "CN?"  
466c f1			.pastdmark: pop af  
466d			endm  
# End of macro DMARK
466d						CALLMONITOR 
466d cd 6f ee			call debug_vector  
4670				endm  
# End of macro CALLMONITOR
4670					endif 
4670 cd 4c 11				call strlenz 
4673					if DEBUG_FORTH_WORDS 
4673						DMARK "CNl" 
4673 f5				push af  
4674 3a 88 46			ld a, (.dmark)  
4677 32 6b ee			ld (debug_mark),a  
467a 3a 89 46			ld a, (.dmark+1)  
467d 32 6c ee			ld (debug_mark+1),a  
4680 3a 8a 46			ld a, (.dmark+2)  
4683 32 6d ee			ld (debug_mark+2),a  
4686 18 03			jr .pastdmark  
4688 ..			.dmark: db "CNl"  
468b f1			.pastdmark: pop af  
468c			endm  
# End of macro DMARK
468c						CALLMONITOR 
468c cd 6f ee			call debug_vector  
468f				endm  
# End of macro CALLMONITOR
468f					endif 
468f			 
468f cd 6d 1b				call forth_push_numhl 
4692			 
4692			 
4692			 
4692				       NEXTW 
4692 c3 28 1f			jp macro_next 
4695				endm 
# End of macro NEXTW
4695			.ASC: 
4695				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4695 4d				db WORD_SYS_CORE+57             
4696 03 47			dw .CHR            
4698 04				db 3 + 1 
4699 .. 00			db "ASC",0              
469d				endm 
# End of macro CWHEAD
469d			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
469d					if DEBUG_FORTH_WORDS_KEY 
469d						DMARK "ASC" 
469d f5				push af  
469e 3a b2 46			ld a, (.dmark)  
46a1 32 6b ee			ld (debug_mark),a  
46a4 3a b3 46			ld a, (.dmark+1)  
46a7 32 6c ee			ld (debug_mark+1),a  
46aa 3a b4 46			ld a, (.dmark+2)  
46ad 32 6d ee			ld (debug_mark+2),a  
46b0 18 03			jr .pastdmark  
46b2 ..			.dmark: db "ASC"  
46b5 f1			.pastdmark: pop af  
46b6			endm  
# End of macro DMARK
46b6						CALLMONITOR 
46b6 cd 6f ee			call debug_vector  
46b9				endm  
# End of macro CALLMONITOR
46b9					endif 
46b9					FORTH_DSP_VALUE 
46b9 cd 5b 1d			call macro_forth_dsp_value 
46bc				endm 
# End of macro FORTH_DSP_VALUE
46bc					;v5 FORTH_DSP_VALUE 
46bc			;		inc hl      ; now at start of numeric as string 
46bc			 
46bc e5					push hl 
46bd			 
46bd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46bd cd 2a 1e			call macro_forth_dsp_pop 
46c0				endm 
# End of macro FORTH_DSP_POP
46c0			 
46c0 e1					pop hl 
46c1			 
46c1					if DEBUG_FORTH_WORDS 
46c1						DMARK "AS1" 
46c1 f5				push af  
46c2 3a d6 46			ld a, (.dmark)  
46c5 32 6b ee			ld (debug_mark),a  
46c8 3a d7 46			ld a, (.dmark+1)  
46cb 32 6c ee			ld (debug_mark+1),a  
46ce 3a d8 46			ld a, (.dmark+2)  
46d1 32 6d ee			ld (debug_mark+2),a  
46d4 18 03			jr .pastdmark  
46d6 ..			.dmark: db "AS1"  
46d9 f1			.pastdmark: pop af  
46da			endm  
# End of macro DMARK
46da						CALLMONITOR 
46da cd 6f ee			call debug_vector  
46dd				endm  
# End of macro CALLMONITOR
46dd					endif 
46dd					; push the content of a onto the stack as a value 
46dd			 
46dd 7e					ld a,(hl)   ; get char 
46de 26 00				ld h,0 
46e0 6f					ld l,a 
46e1					if DEBUG_FORTH_WORDS 
46e1						DMARK "AS2" 
46e1 f5				push af  
46e2 3a f6 46			ld a, (.dmark)  
46e5 32 6b ee			ld (debug_mark),a  
46e8 3a f7 46			ld a, (.dmark+1)  
46eb 32 6c ee			ld (debug_mark+1),a  
46ee 3a f8 46			ld a, (.dmark+2)  
46f1 32 6d ee			ld (debug_mark+2),a  
46f4 18 03			jr .pastdmark  
46f6 ..			.dmark: db "AS2"  
46f9 f1			.pastdmark: pop af  
46fa			endm  
# End of macro DMARK
46fa						CALLMONITOR 
46fa cd 6f ee			call debug_vector  
46fd				endm  
# End of macro CALLMONITOR
46fd					endif 
46fd cd 6d 1b				call forth_push_numhl 
4700			 
4700				       NEXTW 
4700 c3 28 1f			jp macro_next 
4703				endm 
# End of macro NEXTW
4703			 
4703			.CHR: 
4703				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4703 4d				db WORD_SYS_CORE+57             
4704 3f 47			dw .ENDSTR            
4706 04				db 3 + 1 
4707 .. 00			db "CHR",0              
470b				endm 
# End of macro CWHEAD
470b			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
470b					if DEBUG_FORTH_WORDS_KEY 
470b						DMARK "CHR" 
470b f5				push af  
470c 3a 20 47			ld a, (.dmark)  
470f 32 6b ee			ld (debug_mark),a  
4712 3a 21 47			ld a, (.dmark+1)  
4715 32 6c ee			ld (debug_mark+1),a  
4718 3a 22 47			ld a, (.dmark+2)  
471b 32 6d ee			ld (debug_mark+2),a  
471e 18 03			jr .pastdmark  
4720 ..			.dmark: db "CHR"  
4723 f1			.pastdmark: pop af  
4724			endm  
# End of macro DMARK
4724						CALLMONITOR 
4724 cd 6f ee			call debug_vector  
4727				endm  
# End of macro CALLMONITOR
4727					endif 
4727					FORTH_DSP_VALUEHL 
4727 cd 72 1d			call macro_dsp_valuehl 
472a				endm 
# End of macro FORTH_DSP_VALUEHL
472a			 
472a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
472a cd 2a 1e			call macro_forth_dsp_pop 
472d				endm 
# End of macro FORTH_DSP_POP
472d			 
472d					; save asci byte as a zero term string and push string 
472d			 
472d 7d					ld a,l 
472e 32 c1 e2				ld (scratch), a 
4731			 
4731 3e 00				ld a, 0 
4733 32 c2 e2				ld (scratch+1), a 
4736			 
4736 21 c1 e2				ld hl, scratch 
4739 cd db 1b				call forth_push_str 
473c			 
473c			 
473c				       NEXTW 
473c c3 28 1f			jp macro_next 
473f				endm 
# End of macro NEXTW
473f			 
473f			 
473f			 
473f			 
473f			.ENDSTR: 
473f			; eof 
473f			 
# End of file forth_words_str.asm
473f			include "forth_words_key.asm" 
473f			 
473f			; | ## Keyboard Words 
473f			 
473f			.KEY: 
473f				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
473f 3e				db WORD_SYS_CORE+42             
4740 6f 47			dw .WAITK            
4742 04				db 3 + 1 
4743 .. 00			db "KEY",0              
4747				endm 
# End of macro CWHEAD
4747			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4747			 
4747					if DEBUG_FORTH_WORDS_KEY 
4747						DMARK "KEY" 
4747 f5				push af  
4748 3a 5c 47			ld a, (.dmark)  
474b 32 6b ee			ld (debug_mark),a  
474e 3a 5d 47			ld a, (.dmark+1)  
4751 32 6c ee			ld (debug_mark+1),a  
4754 3a 5e 47			ld a, (.dmark+2)  
4757 32 6d ee			ld (debug_mark+2),a  
475a 18 03			jr .pastdmark  
475c ..			.dmark: db "KEY"  
475f f1			.pastdmark: pop af  
4760			endm  
# End of macro DMARK
4760						CALLMONITOR 
4760 cd 6f ee			call debug_vector  
4763				endm  
# End of macro CALLMONITOR
4763					endif 
4763			; TODO currently waits 
4763 cd 5b 5e				call cin 
4766					;call cin_wait 
4766 6f					ld l, a 
4767 26 00				ld h, 0 
4769 cd 6d 1b				call forth_push_numhl 
476c					NEXTW 
476c c3 28 1f			jp macro_next 
476f				endm 
# End of macro NEXTW
476f			.WAITK: 
476f				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
476f 3f				db WORD_SYS_CORE+43             
4770 a1 47			dw .ACCEPT            
4772 06				db 5 + 1 
4773 .. 00			db "WAITK",0              
4779				endm 
# End of macro CWHEAD
4779			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4779					if DEBUG_FORTH_WORDS_KEY 
4779						DMARK "WAI" 
4779 f5				push af  
477a 3a 8e 47			ld a, (.dmark)  
477d 32 6b ee			ld (debug_mark),a  
4780 3a 8f 47			ld a, (.dmark+1)  
4783 32 6c ee			ld (debug_mark+1),a  
4786 3a 90 47			ld a, (.dmark+2)  
4789 32 6d ee			ld (debug_mark+2),a  
478c 18 03			jr .pastdmark  
478e ..			.dmark: db "WAI"  
4791 f1			.pastdmark: pop af  
4792			endm  
# End of macro DMARK
4792						CALLMONITOR 
4792 cd 6f ee			call debug_vector  
4795				endm  
# End of macro CALLMONITOR
4795					endif 
4795 cd 53 5e				call cin_wait 
4798 6f					ld l, a 
4799 26 00				ld h, 0 
479b cd 6d 1b				call forth_push_numhl 
479e					NEXTW 
479e c3 28 1f			jp macro_next 
47a1				endm 
# End of macro NEXTW
47a1			.ACCEPT: 
47a1				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
47a1 40				db WORD_SYS_CORE+44             
47a2 ff 47			dw .EDIT            
47a4 07				db 6 + 1 
47a5 .. 00			db "ACCEPT",0              
47ac				endm 
# End of macro CWHEAD
47ac			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
47ac					; TODO crashes on push 
47ac					if DEBUG_FORTH_WORDS_KEY 
47ac						DMARK "ACC" 
47ac f5				push af  
47ad 3a c1 47			ld a, (.dmark)  
47b0 32 6b ee			ld (debug_mark),a  
47b3 3a c2 47			ld a, (.dmark+1)  
47b6 32 6c ee			ld (debug_mark+1),a  
47b9 3a c3 47			ld a, (.dmark+2)  
47bc 32 6d ee			ld (debug_mark+2),a  
47bf 18 03			jr .pastdmark  
47c1 ..			.dmark: db "ACC"  
47c4 f1			.pastdmark: pop af  
47c5			endm  
# End of macro DMARK
47c5						CALLMONITOR 
47c5 cd 6f ee			call debug_vector  
47c8				endm  
# End of macro CALLMONITOR
47c8					endif 
47c8 21 bf e4				ld hl, os_input 
47cb 3e 00				ld a, 0 
47cd 77					ld (hl),a 
47ce 3a 5e ea				ld a,(f_cursor_ptr) 
47d1 16 64				ld d, 100 
47d3 0e 00				ld c, 0 
47d5 1e 28				ld e, 40 
47d7 cd 13 0e				call input_str 
47da					; TODO perhaps do a type check and wrap in quotes if not a number 
47da 21 bf e4				ld hl, os_input 
47dd					if DEBUG_FORTH_WORDS 
47dd						DMARK "AC1" 
47dd f5				push af  
47de 3a f2 47			ld a, (.dmark)  
47e1 32 6b ee			ld (debug_mark),a  
47e4 3a f3 47			ld a, (.dmark+1)  
47e7 32 6c ee			ld (debug_mark+1),a  
47ea 3a f4 47			ld a, (.dmark+2)  
47ed 32 6d ee			ld (debug_mark+2),a  
47f0 18 03			jr .pastdmark  
47f2 ..			.dmark: db "AC1"  
47f5 f1			.pastdmark: pop af  
47f6			endm  
# End of macro DMARK
47f6						CALLMONITOR 
47f6 cd 6f ee			call debug_vector  
47f9				endm  
# End of macro CALLMONITOR
47f9					endif 
47f9 cd db 1b				call forth_push_str 
47fc					NEXTW 
47fc c3 28 1f			jp macro_next 
47ff				endm 
# End of macro NEXTW
47ff			 
47ff			.EDIT: 
47ff				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
47ff 40				db WORD_SYS_CORE+44             
4800 a1 48			dw .DEDIT            
4802 05				db 4 + 1 
4803 .. 00			db "EDIT",0              
4808				endm 
# End of macro CWHEAD
4808			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4808			 
4808					; TODO does not copy from stack 
4808					if DEBUG_FORTH_WORDS_KEY 
4808						DMARK "EDT" 
4808 f5				push af  
4809 3a 1d 48			ld a, (.dmark)  
480c 32 6b ee			ld (debug_mark),a  
480f 3a 1e 48			ld a, (.dmark+1)  
4812 32 6c ee			ld (debug_mark+1),a  
4815 3a 1f 48			ld a, (.dmark+2)  
4818 32 6d ee			ld (debug_mark+2),a  
481b 18 03			jr .pastdmark  
481d ..			.dmark: db "EDT"  
4820 f1			.pastdmark: pop af  
4821			endm  
# End of macro DMARK
4821						CALLMONITOR 
4821 cd 6f ee			call debug_vector  
4824				endm  
# End of macro CALLMONITOR
4824					endif 
4824			 
4824					;FORTH_DSP 
4824					FORTH_DSP_VALUEHL 
4824 cd 72 1d			call macro_dsp_valuehl 
4827				endm 
# End of macro FORTH_DSP_VALUEHL
4827			;		inc hl    ; TODO do type check 
4827			 
4827			;		call get_word_hl 
4827 e5					push hl 
4828					if DEBUG_FORTH_WORDS 
4828						DMARK "EDp" 
4828 f5				push af  
4829 3a 3d 48			ld a, (.dmark)  
482c 32 6b ee			ld (debug_mark),a  
482f 3a 3e 48			ld a, (.dmark+1)  
4832 32 6c ee			ld (debug_mark+1),a  
4835 3a 3f 48			ld a, (.dmark+2)  
4838 32 6d ee			ld (debug_mark+2),a  
483b 18 03			jr .pastdmark  
483d ..			.dmark: db "EDp"  
4840 f1			.pastdmark: pop af  
4841			endm  
# End of macro DMARK
4841						CALLMONITOR 
4841 cd 6f ee			call debug_vector  
4844				endm  
# End of macro CALLMONITOR
4844					endif 
4844				;	ld a, 0 
4844 cd 4c 11				call strlenz 
4847 23					inc hl 
4848			 
4848 06 00				ld b, 0 
484a 4d					ld c, l 
484b			 
484b e1					pop hl 
484c 11 bf e4				ld de, os_input 
484f					if DEBUG_FORTH_WORDS_KEY 
484f						DMARK "EDc" 
484f f5				push af  
4850 3a 64 48			ld a, (.dmark)  
4853 32 6b ee			ld (debug_mark),a  
4856 3a 65 48			ld a, (.dmark+1)  
4859 32 6c ee			ld (debug_mark+1),a  
485c 3a 66 48			ld a, (.dmark+2)  
485f 32 6d ee			ld (debug_mark+2),a  
4862 18 03			jr .pastdmark  
4864 ..			.dmark: db "EDc"  
4867 f1			.pastdmark: pop af  
4868			endm  
# End of macro DMARK
4868						CALLMONITOR 
4868 cd 6f ee			call debug_vector  
486b				endm  
# End of macro CALLMONITOR
486b					endif 
486b ed b0				ldir 
486d			 
486d			 
486d 21 bf e4				ld hl, os_input 
4870					;ld a, 0 
4870					;ld (hl),a 
4870 3a 5e ea				ld a,(f_cursor_ptr) 
4873 16 64				ld d, 100 
4875 0e 00				ld c, 0 
4877 1e 28				ld e, 40 
4879 cd 13 0e				call input_str 
487c					; TODO perhaps do a type check and wrap in quotes if not a number 
487c 21 bf e4				ld hl, os_input 
487f					if DEBUG_FORTH_WORDS 
487f						DMARK "ED1" 
487f f5				push af  
4880 3a 94 48			ld a, (.dmark)  
4883 32 6b ee			ld (debug_mark),a  
4886 3a 95 48			ld a, (.dmark+1)  
4889 32 6c ee			ld (debug_mark+1),a  
488c 3a 96 48			ld a, (.dmark+2)  
488f 32 6d ee			ld (debug_mark+2),a  
4892 18 03			jr .pastdmark  
4894 ..			.dmark: db "ED1"  
4897 f1			.pastdmark: pop af  
4898			endm  
# End of macro DMARK
4898						CALLMONITOR 
4898 cd 6f ee			call debug_vector  
489b				endm  
# End of macro CALLMONITOR
489b					endif 
489b cd db 1b				call forth_push_str 
489e					NEXTW 
489e c3 28 1f			jp macro_next 
48a1				endm 
# End of macro NEXTW
48a1			 
48a1			.DEDIT: 
48a1				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
48a1 40				db WORD_SYS_CORE+44             
48a2 03 49			dw .ENDKEY            
48a4 06				db 5 + 1 
48a5 .. 00			db "DEDIT",0              
48ab				endm 
# End of macro CWHEAD
48ab			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
48ab			 
48ab					; TODO does not copy from stack 
48ab					if DEBUG_FORTH_WORDS_KEY 
48ab						DMARK "DED" 
48ab f5				push af  
48ac 3a c0 48			ld a, (.dmark)  
48af 32 6b ee			ld (debug_mark),a  
48b2 3a c1 48			ld a, (.dmark+1)  
48b5 32 6c ee			ld (debug_mark+1),a  
48b8 3a c2 48			ld a, (.dmark+2)  
48bb 32 6d ee			ld (debug_mark+2),a  
48be 18 03			jr .pastdmark  
48c0 ..			.dmark: db "DED"  
48c3 f1			.pastdmark: pop af  
48c4			endm  
# End of macro DMARK
48c4						CALLMONITOR 
48c4 cd 6f ee			call debug_vector  
48c7				endm  
# End of macro CALLMONITOR
48c7					endif 
48c7			 
48c7					;FORTH_DSP 
48c7					FORTH_DSP_VALUEHL 
48c7 cd 72 1d			call macro_dsp_valuehl 
48ca				endm 
# End of macro FORTH_DSP_VALUEHL
48ca			;		inc hl    ; TODO do type check 
48ca			 
48ca			;		call get_word_hl 
48ca e5					push hl 
48cb e5					push hl 
48cc					FORTH_DSP_POP 
48cc cd 2a 1e			call macro_forth_dsp_pop 
48cf				endm 
# End of macro FORTH_DSP_POP
48cf e1					pop hl 
48d0					if DEBUG_FORTH_WORDS 
48d0						DMARK "EDp" 
48d0 f5				push af  
48d1 3a e5 48			ld a, (.dmark)  
48d4 32 6b ee			ld (debug_mark),a  
48d7 3a e6 48			ld a, (.dmark+1)  
48da 32 6c ee			ld (debug_mark+1),a  
48dd 3a e7 48			ld a, (.dmark+2)  
48e0 32 6d ee			ld (debug_mark+2),a  
48e3 18 03			jr .pastdmark  
48e5 ..			.dmark: db "EDp"  
48e8 f1			.pastdmark: pop af  
48e9			endm  
# End of macro DMARK
48e9						CALLMONITOR 
48e9 cd 6f ee			call debug_vector  
48ec				endm  
# End of macro CALLMONITOR
48ec					endif 
48ec				;	ld a, 0 
48ec cd 4c 11				call strlenz 
48ef 23					inc hl 
48f0			 
48f0 06 00				ld b, 0 
48f2 4d					ld c, l 
48f3			 
48f3 e1					pop hl 
48f4			 
48f4					;ld a, 0 
48f4					;ld (hl),a 
48f4 3a 5e ea				ld a,(f_cursor_ptr) 
48f7 16 64				ld d, 100 
48f9 0e 00				ld c, 0 
48fb 1e 28				ld e, 40 
48fd cd 13 0e				call input_str 
4900					; TODO perhaps do a type check and wrap in quotes if not a number 
4900					NEXTW 
4900 c3 28 1f			jp macro_next 
4903				endm 
# End of macro NEXTW
4903			 
4903			 
4903			.ENDKEY: 
4903			; eof 
4903			 
# End of file forth_words_key.asm
4903			include "forth_words_const.asm" 
4903			 
4903			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4903			 
4903			 
4903			.SPITIME: 
4903				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4903 77				db WORD_SYS_CORE+99             
4904 18 49			dw .VA            
4906 08				db 7 + 1 
4907 .. 00			db "SPITIME",0              
490f				endm 
# End of macro CWHEAD
490f			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
490f			; 
490f			; | | If using BANK devices then leave as is. 
490f			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
490f			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
490f			 
490f 21 64 ea				ld hl, spi_clktime  
4912 cd 6d 1b				call forth_push_numhl 
4915			 
4915					NEXTW 
4915 c3 28 1f			jp macro_next 
4918				endm 
# End of macro NEXTW
4918			 
4918			 
4918			.VA: 
4918				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4918 77				db WORD_SYS_CORE+99             
4919 28 49			dw .SYMBOL            
491b 03				db 2 + 1 
491c .. 00			db "VA",0              
491f				endm 
# End of macro CWHEAD
491f			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
491f 21 28 ea				ld hl, cli_var_array 
4922 cd 6d 1b				call forth_push_numhl 
4925			 
4925					NEXTW 
4925 c3 28 1f			jp macro_next 
4928				endm 
# End of macro NEXTW
4928			 
4928			.SYMBOL: 
4928				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4928 77				db WORD_SYS_CORE+99             
4929 32 4a			dw .ENDCONST            
492b 07				db 6 + 1 
492c .. 00			db "SYMBOL",0              
4933				endm 
# End of macro CWHEAD
4933			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4933			; | 
4933			; | | The value is the number reference and the final address is pushed to stack 
4933			 
4933			; | | ``` 
4933			; | | dw sym_table 
4933			; | | dw nmi_vector 
4933			; | | dw cli_autodisplay 
4933			; | | dw cli_data_sp 
4933			; | | dw cli_data_stack 
4933			; | | dw cli_loop_sp 
4933			; | | dw cli_loop_stack 
4933			; | | dw cli_var_array 
4933			; | | dw cursor_col 
4933			; | | dw cursor_ptr 
4933			; | | ; 10 
4933			; | | dw cursor_row 
4933			; | | dw debug_mark 
4933			; | | dw display_fb0 
4933			; | | dw display_fb1 
4933			; | | dw display_fb2 
4933			; | | dw display_fb3 
4933			; | | dw display_fb_active 
4933			; | | dw execscratch 
4933			; | | dw f_cursor_ptr 
4933			; | | dw hardware_word 
4933			; | | ;20 
4933			; | | dw input_at_cursor 
4933			; | | dw input_at_pos 
4933			; | | dw input_cur_flash 
4933			; | | dw input_cur_onoff 
4933			; | | dw input_cursor 
4933			; | | dw input_display_size 
4933			; | | dw input_len 
4933			; | | dw input_ptr 
4933			; | | dw input_size 
4933			; | | dw input_start 
4933			; | | ; 30 
4933			; | | dw input_str 
4933			; | | dw input_under_cursor 
4933			; | | dw os_cli_cmd 
4933			; | | dw os_cur_ptr 
4933			; | | dw os_current_i 
4933			; | | dw os_input 
4933			; | | dw os_last_cmd 
4933			; | | dw os_last_new_uword 
4933			; | | dw debug_vector 
4933			; | | dw os_view_hl 
4933			; | | ;40 
4933			; | | dw os_word_scratch 
4933			; | | dw portbctl 
4933			; | | dw portbdata 
4933			; | | dw spi_cartdev 
4933			; | | dw spi_cartdev2 
4933			; | | dw spi_clktime 
4933			; | | dw spi_device 
4933			; | | dw spi_device_id 
4933			; | | dw spi_portbyte 
4933			; | | dw stackstore 
4933			; | | ; 50 
4933			; | | if STORAGE_SE 
4933			; | | dw storage_actl 
4933			; | | dw storage_adata 
4933			; | | else 
4933			; | | dw 0 
4933			; | | dw 0 
4933			; | | endif 
4933			; | | dw storage_append 
4933			; | | if STORAGE_SE 
4933			; | | dw storage_bctl 
4933			; | | else 
4933			; | | dw 0 
4933			; | | endif 
4933			; | | dw store_bank_active 
4933			; | | dw store_filecache 
4933			; | | dw store_longread 
4933			; | | dw store_openaddr 
4933			; | | dw store_openext 
4933			; | | dw store_openmaxext 
4933			; | | ; 60 
4933			; | | dw store_page 
4933			; | | dw store_readbuf 
4933			; | | dw store_readcont 
4933			; | | dw store_readptr 
4933			; | | dw store_tmpext 
4933			; | | dw store_tmpid 
4933			; | | dw store_tmppageid 
4933			; | | dw malloc 
4933			; | | dw free 
4933			; | | dw cin 
4933			; | | ; 70 
4933			; | | dw cin_wait 
4933			; | | dw forth_push_numhl 
4933			; | | dw forth_push_str 
4933			; | | ``` 
4933			 
4933					if DEBUG_FORTH_WORDS_KEY 
4933						DMARK "SYM" 
4933 f5				push af  
4934 3a 48 49			ld a, (.dmark)  
4937 32 6b ee			ld (debug_mark),a  
493a 3a 49 49			ld a, (.dmark+1)  
493d 32 6c ee			ld (debug_mark+1),a  
4940 3a 4a 49			ld a, (.dmark+2)  
4943 32 6d ee			ld (debug_mark+2),a  
4946 18 03			jr .pastdmark  
4948 ..			.dmark: db "SYM"  
494b f1			.pastdmark: pop af  
494c			endm  
# End of macro DMARK
494c						CALLMONITOR 
494c cd 6f ee			call debug_vector  
494f				endm  
# End of macro CALLMONITOR
494f					endif 
494f			 
494f					FORTH_DSP_VALUEHL 
494f cd 72 1d			call macro_dsp_valuehl 
4952				endm 
# End of macro FORTH_DSP_VALUEHL
4952			 
4952 7d					ld a, l     
4953			 
4953			 
4953					if DEBUG_FORTH_WORDS 
4953						DMARK "SY1" 
4953 f5				push af  
4954 3a 68 49			ld a, (.dmark)  
4957 32 6b ee			ld (debug_mark),a  
495a 3a 69 49			ld a, (.dmark+1)  
495d 32 6c ee			ld (debug_mark+1),a  
4960 3a 6a 49			ld a, (.dmark+2)  
4963 32 6d ee			ld (debug_mark+2),a  
4966 18 03			jr .pastdmark  
4968 ..			.dmark: db "SY1"  
496b f1			.pastdmark: pop af  
496c			endm  
# End of macro DMARK
496c						CALLMONITOR 
496c cd 6f ee			call debug_vector  
496f				endm  
# End of macro CALLMONITOR
496f					endif 
496f					 
496f f5					push af	 
4970					FORTH_DSP_POP 
4970 cd 2a 1e			call macro_forth_dsp_pop 
4973				endm 
# End of macro FORTH_DSP_POP
4973 f1					pop af 
4974			 
4974 cb 27				sla a  
4976				 
4976					 
4976					if DEBUG_FORTH_WORDS 
4976						DMARK "SY" 
4976 f5				push af  
4977 3a 8b 49			ld a, (.dmark)  
497a 32 6b ee			ld (debug_mark),a  
497d 3a 8c 49			ld a, (.dmark+1)  
4980 32 6c ee			ld (debug_mark+1),a  
4983 3a 8d 49			ld a, (.dmark+2)  
4986 32 6d ee			ld (debug_mark+2),a  
4989 18 02			jr .pastdmark  
498b ..			.dmark: db "SY"  
498d f1			.pastdmark: pop af  
498e			endm  
# End of macro DMARK
498e						CALLMONITOR 
498e cd 6f ee			call debug_vector  
4991				endm  
# End of macro CALLMONITOR
4991					endif 
4991			 
4991 21 a0 49				ld hl, sym_table 
4994 cd e6 0d				call addatohl 
4997 cd aa 1e				call loadwordinhl 
499a cd 6d 1b				call forth_push_numhl 
499d			 
499d			 
499d				       NEXTW 
499d c3 28 1f			jp macro_next 
49a0				endm 
# End of macro NEXTW
49a0			 
49a0			sym_table: 
49a0			 
49a0			; 0 
49a0 a0 49		dw sym_table 
49a2 72 ee		dw nmi_vector 
49a4 3c ea		dw cli_autodisplay 
49a6 ee e9		dw cli_data_sp 
49a8 28 e8		dw cli_data_stack 
49aa f0 e9		dw cli_loop_sp 
49ac 2a e9		dw cli_loop_stack 
49ae 28 ea		dw cli_var_array 
49b0 c5 eb		dw cursor_col 
49b2 c3 eb		dw cursor_ptr 
49b4			; 10 
49b4 c4 eb		dw cursor_row 
49b6 6b ee		dw debug_mark 
49b8 b1 ed		dw display_fb0 
49ba 10 ed		dw display_fb1 
49bc ce eb		dw display_fb2 
49be 6f ec		dw display_fb3 
49c0 cc eb		dw display_fb_active 
49c2 c0 e3		dw execscratch 
49c4 5e ea		dw f_cursor_ptr 
49c6 75 ee		dw hardware_word 
49c8			;20 
49c8 62 ee		dw input_at_cursor 
49ca 64 ee		dw input_at_pos 
49cc 60 ee		dw input_cur_flash 
49ce 5f ee		dw input_cur_onoff 
49d0 55 ee		dw input_cursor 
49d2 65 ee		dw input_display_size 
49d4 5a ee		dw input_len 
49d6 69 ee		dw input_ptr 
49d8 66 ee		dw input_size 
49da 67 ee		dw input_start 
49dc			; 30 
49dc 13 0e		dw input_str 
49de 63 ee		dw input_under_cursor 
49e0 e8 e5		dw os_cli_cmd 
49e2 e4 e5		dw os_cur_ptr 
49e4 e6 e5		dw os_current_i 
49e6 bf e4		dw os_input 
49e8 e7 e6		dw os_last_cmd 
49ea be e5		dw os_last_new_uword 
49ec 6f ee		dw debug_vector 
49ee a3 e2		dw os_view_hl 
49f0			;40 
49f0 c6 e5		dw os_word_scratch 
49f2 c3 00		dw portbctl 
49f4 c1 00		dw portbdata 
49f6 63 ea		dw spi_cartdev 
49f8 62 ea		dw spi_cartdev2 
49fa 64 ea		dw spi_clktime 
49fc 60 ea		dw spi_device 
49fe 5f ea		dw spi_device_id 
4a00 61 ea		dw spi_portbyte 
4a02 a7 eb		dw stackstore 
4a04			; 50 
4a04			if STORAGE_SE 
4a04			dw storage_actl 
4a04			dw storage_adata 
4a04			else 
4a04 00 00		dw 0 
4a06 00 00		dw 0 
4a08			endif 
4a08 68 09		dw storage_append 
4a0a			if STORAGE_SE 
4a0a			dw storage_bctl 
4a0a			else 
4a0a 00 00		dw 0 
4a0c			endif 
4a0c 93 eb		dw store_bank_active 
4a0e 67 ea		dw store_filecache 
4a10 75 ea		dw store_longread 
4a12 6b ea		dw store_openaddr 
4a14 6a ea		dw store_openext 
4a16 69 ea		dw store_openmaxext 
4a18			; 60 
4a18 7a ea		dw store_page 
4a1a 76 ea		dw store_readbuf 
4a1c 6d ea		dw store_readcont 
4a1e 78 ea		dw store_readptr 
4a20 6d ea		dw store_tmpext 
4a22 6e ea		dw store_tmpid 
4a24 65 ea		dw store_tmppageid 
4a26 c1 11		dw malloc 
4a28 8b 12		dw free 
4a2a 5b 5e		dw cin 
4a2c			; 70 
4a2c 53 5e		dw cin_wait 
4a2e 6d 1b		dw forth_push_numhl 
4a30 db 1b		dw forth_push_str 
4a32			 
4a32			 
4a32			.ENDCONST: 
4a32			 
4a32			; eof 
4a32			 
4a32			 
# End of file forth_words_const.asm
4a32			 
4a32			if STORAGE_SE 
4a32			   	include "forth_words_storage.asm" 
4a32			endif 
4a32				include "forth_words_device.asm" 
4a32			; Device related words 
4a32			 
4a32			; | ## Device Words 
4a32			 
4a32			;if SOUND_ENABLE 
4a32			;.NOTE: 
4a32			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4a32			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
4a32			;		if DEBUG_FORTH_WORDS_KEY 
4a32			;			DMARK "NTE" 
4a32			;			CALLMONITOR 
4a32			;		endif 
4a32			; 
4a32			;	 
4a32			; 
4a32			;		NEXTW 
4a32			;.AFTERSOUND: 
4a32			;endif 
4a32			 
4a32			 
4a32			USE_GPIO: equ 0 
4a32			 
4a32			if USE_GPIO 
4a32			.GP1: 
4a32				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4a32			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
4a32					NEXTW 
4a32			.GP2: 
4a32				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4a32			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
4a32			 
4a32					NEXTW 
4a32			 
4a32			.GP3: 
4a32				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4a32			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
4a32			 
4a32					NEXTW 
4a32			 
4a32			.GP4: 
4a32				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4a32			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
4a32			 
4a32					NEXTW 
4a32			.SIN: 
4a32			 
4a32			 
4a32			endif 
4a32			 
4a32			 
4a32				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4a32 33				db WORD_SYS_CORE+31             
4a33 67 4a			dw .SOUT            
4a35 03				db 2 + 1 
4a36 .. 00			db "IN",0              
4a39				endm 
# End of macro CWHEAD
4a39			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4a39					if DEBUG_FORTH_WORDS_KEY 
4a39						DMARK "IN." 
4a39 f5				push af  
4a3a 3a 4e 4a			ld a, (.dmark)  
4a3d 32 6b ee			ld (debug_mark),a  
4a40 3a 4f 4a			ld a, (.dmark+1)  
4a43 32 6c ee			ld (debug_mark+1),a  
4a46 3a 50 4a			ld a, (.dmark+2)  
4a49 32 6d ee			ld (debug_mark+2),a  
4a4c 18 03			jr .pastdmark  
4a4e ..			.dmark: db "IN."  
4a51 f1			.pastdmark: pop af  
4a52			endm  
# End of macro DMARK
4a52						CALLMONITOR 
4a52 cd 6f ee			call debug_vector  
4a55				endm  
# End of macro CALLMONITOR
4a55					endif 
4a55					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a55 cd 72 1d			call macro_dsp_valuehl 
4a58				endm 
# End of macro FORTH_DSP_VALUEHL
4a58			 
4a58 e5					push hl 
4a59			 
4a59					; destroy value TOS 
4a59			 
4a59					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a59 cd 2a 1e			call macro_forth_dsp_pop 
4a5c				endm 
# End of macro FORTH_DSP_POP
4a5c			 
4a5c					; one value on hl get other one back 
4a5c			 
4a5c c1					pop bc 
4a5d			 
4a5d					; do the sub 
4a5d			;		ex de, hl 
4a5d			 
4a5d ed 68				in l,(c) 
4a5f			 
4a5f					; save it 
4a5f			 
4a5f 26 00				ld h,0 
4a61			 
4a61					; TODO push value back onto stack for another op etc 
4a61			 
4a61 cd 6d 1b				call forth_push_numhl 
4a64					NEXTW 
4a64 c3 28 1f			jp macro_next 
4a67				endm 
# End of macro NEXTW
4a67			.SOUT: 
4a67				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4a67 34				db WORD_SYS_CORE+32             
4a68 ba 4a			dw .SPIO            
4a6a 04				db 3 + 1 
4a6b .. 00			db "OUT",0              
4a6f				endm 
# End of macro CWHEAD
4a6f			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4a6f					if DEBUG_FORTH_WORDS_KEY 
4a6f						DMARK "OUT" 
4a6f f5				push af  
4a70 3a 84 4a			ld a, (.dmark)  
4a73 32 6b ee			ld (debug_mark),a  
4a76 3a 85 4a			ld a, (.dmark+1)  
4a79 32 6c ee			ld (debug_mark+1),a  
4a7c 3a 86 4a			ld a, (.dmark+2)  
4a7f 32 6d ee			ld (debug_mark+2),a  
4a82 18 03			jr .pastdmark  
4a84 ..			.dmark: db "OUT"  
4a87 f1			.pastdmark: pop af  
4a88			endm  
# End of macro DMARK
4a88						CALLMONITOR 
4a88 cd 6f ee			call debug_vector  
4a8b				endm  
# End of macro CALLMONITOR
4a8b					endif 
4a8b			 
4a8b					; get port 
4a8b			 
4a8b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a8b cd 72 1d			call macro_dsp_valuehl 
4a8e				endm 
# End of macro FORTH_DSP_VALUEHL
4a8e			 
4a8e e5					push hl 
4a8f			 
4a8f					; destroy value TOS 
4a8f			 
4a8f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a8f cd 2a 1e			call macro_forth_dsp_pop 
4a92				endm 
# End of macro FORTH_DSP_POP
4a92			 
4a92					; get byte to send 
4a92			 
4a92					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4a92 cd 72 1d			call macro_dsp_valuehl 
4a95				endm 
# End of macro FORTH_DSP_VALUEHL
4a95			 
4a95			;		push hl 
4a95			 
4a95					; destroy value TOS 
4a95			 
4a95					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4a95 cd 2a 1e			call macro_forth_dsp_pop 
4a98				endm 
# End of macro FORTH_DSP_POP
4a98			 
4a98					; one value on hl get other one back 
4a98			 
4a98			;		pop hl 
4a98			 
4a98 c1					pop bc 
4a99			 
4a99					if DEBUG_FORTH_WORDS 
4a99						DMARK "OUT" 
4a99 f5				push af  
4a9a 3a ae 4a			ld a, (.dmark)  
4a9d 32 6b ee			ld (debug_mark),a  
4aa0 3a af 4a			ld a, (.dmark+1)  
4aa3 32 6c ee			ld (debug_mark+1),a  
4aa6 3a b0 4a			ld a, (.dmark+2)  
4aa9 32 6d ee			ld (debug_mark+2),a  
4aac 18 03			jr .pastdmark  
4aae ..			.dmark: db "OUT"  
4ab1 f1			.pastdmark: pop af  
4ab2			endm  
# End of macro DMARK
4ab2						CALLMONITOR 
4ab2 cd 6f ee			call debug_vector  
4ab5				endm  
# End of macro CALLMONITOR
4ab5					endif 
4ab5			 
4ab5 ed 69				out (c), l 
4ab7			 
4ab7					NEXTW 
4ab7 c3 28 1f			jp macro_next 
4aba				endm 
# End of macro NEXTW
4aba			 
4aba			 
4aba			.SPIO: 
4aba			 
4aba			if STORAGE_SE 
4aba				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4aba			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4aba			 
4aba					call spi_ce_low 
4aba			    NEXTW 
4aba			 
4aba			.SPICEH: 
4aba				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4aba			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4aba			 
4aba					call spi_ce_high 
4aba			    NEXTW 
4aba			 
4aba			 
4aba			.SPIOb: 
4aba			 
4aba				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4aba			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4aba			 
4aba					if DEBUG_FORTH_WORDS_KEY 
4aba						DMARK "SPo" 
4aba						CALLMONITOR 
4aba					endif 
4aba					; get port 
4aba			 
4aba			 
4aba					; get byte to send 
4aba			 
4aba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aba			 
4aba			;		push hl    ; u1  
4aba			 
4aba					; destroy value TOS 
4aba			 
4aba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aba			 
4aba					; one value on hl get other one back 
4aba			 
4aba			;		pop hl   ; u2 - addr 
4aba			 
4aba					; TODO Send SPI byte 
4aba			 
4aba			;		push hl 
4aba			;		call spi_ce_low 
4aba			;		pop hl 
4aba					ld a, l 
4aba					call spi_send_byte 
4aba			;		call spi_ce_high 
4aba			 
4aba					NEXTW 
4aba			 
4aba			.SPII: 
4aba				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4aba			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4aba					if DEBUG_FORTH_WORDS_KEY 
4aba						DMARK "SPi" 
4aba						CALLMONITOR 
4aba					endif 
4aba			 
4aba					; TODO Get SPI byte 
4aba			 
4aba					call spi_read_byte 
4aba			 
4aba					if DEBUG_FORTH_WORDS 
4aba						DMARK "Si2" 
4aba						CALLMONITOR 
4aba					endif 
4aba					ld h, 0 
4aba					ld l, a 
4aba					if DEBUG_FORTH_WORDS 
4aba						DMARK "Si3" 
4aba						CALLMONITOR 
4aba					endif 
4aba					call forth_push_numhl 
4aba			 
4aba					NEXTW 
4aba			 
4aba			 
4aba			 
4aba			.SESEL: 
4aba				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4aba			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4aba					if DEBUG_FORTH_WORDS_KEY 
4aba						DMARK "BNK" 
4aba						CALLMONITOR 
4aba					endif 
4aba			 
4aba					ld a, 255 
4aba					ld (spi_cartdev), a 
4aba			 
4aba					; get bank 
4aba			 
4aba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aba			 
4aba			;		push hl 
4aba			 
4aba					; destroy value TOS 
4aba			 
4aba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aba			 
4aba					; one value on hl get other one back 
4aba			 
4aba			;		pop hl 
4aba			 
4aba			 
4aba					ld c, SPI_CE_HIGH 
4aba					ld b, '0'    ; human readable bank number 
4aba			 
4aba					ld a, l 
4aba			 
4aba					if DEBUG_FORTH_WORDS 
4aba						DMARK "BNK" 
4aba						CALLMONITOR 
4aba					endif 
4aba			 
4aba					; active low 
4aba			 
4aba					cp 0 
4aba					jr z, .bset 
4aba					cp 1 
4aba					jr nz, .b2 
4aba					res 0, c 
4aba					ld b, '1'    ; human readable bank number 
4aba			.b2:		cp 2 
4aba					jr nz, .b3 
4aba					res 1, c 
4aba					ld b, '2'    ; human readable bank number 
4aba			.b3:		cp 3 
4aba					jr nz, .b4 
4aba					res 2, c 
4aba					ld b, '3'    ; human readable bank number 
4aba			.b4:		cp 4 
4aba					jr nz, .b5 
4aba					res 3, c 
4aba					ld b, '4'    ; human readable bank number 
4aba			.b5:		cp 5 
4aba					jr nz, .bset 
4aba					res 4, c 
4aba					ld b, '5'    ; human readable bank number 
4aba			 
4aba			.bset: 
4aba					ld a, c 
4aba					ld (spi_device),a 
4aba					ld a, b 
4aba					ld (spi_device_id),a 
4aba					if DEBUG_FORTH_WORDS 
4aba						DMARK "BN2" 
4aba						CALLMONITOR 
4aba					endif 
4aba			 
4aba					; set default SPI clk pulse time as disabled for BANK use 
4aba			 
4aba					ld a, 0 
4aba					ld (spi_clktime), a 
4aba			 
4aba					NEXTW 
4aba			 
4aba			.CARTDEV: 
4aba				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4aba			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4aba					if DEBUG_FORTH_WORDS_KEY 
4aba						DMARK "CDV" 
4aba						CALLMONITOR 
4aba					endif 
4aba			 
4aba					; disable se storage bank selection 
4aba			 
4aba					ld a, SPI_CE_HIGH		; ce high 
4aba					ld (spi_device), a 
4aba			 
4aba					; get bank 
4aba			 
4aba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4aba			 
4aba			;		push hl 
4aba			 
4aba					; destroy value TOS 
4aba			 
4aba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4aba			 
4aba					; one value on hl get other one back 
4aba			 
4aba			;		pop hl 
4aba			 
4aba					; active low 
4aba			 
4aba					ld c, 255 
4aba			 
4aba					ld a, l 
4aba					if DEBUG_FORTH_WORDS 
4aba						DMARK "CDV" 
4aba						CALLMONITOR 
4aba					endif 
4aba					cp 0 
4aba					jr z, .cset 
4aba					cp 1 
4aba					jr nz, .c2 
4aba					res 0, c 
4aba			.c2:		cp 2 
4aba					jr nz, .c3 
4aba					res 1, c 
4aba			.c3:		cp 3 
4aba					jr nz, .c4 
4aba					res 2, c 
4aba			.c4:		cp 4 
4aba					jr nz, .c5 
4aba					res 3, c 
4aba			.c5:		cp 5 
4aba					jr nz, .c6 
4aba					res 4, c 
4aba			.c6:		cp 6 
4aba					jr nz, .c7 
4aba					res 5, c 
4aba			.c7:		cp 7 
4aba					jr nz, .c8 
4aba					res 6, c 
4aba			.c8:		cp 8 
4aba					jr nz, .cset 
4aba					res 7, c 
4aba			.cset:		ld a, c 
4aba					ld (spi_cartdev),a 
4aba			 
4aba					if DEBUG_FORTH_WORDS 
4aba						DMARK "CD2" 
4aba						CALLMONITOR 
4aba					endif 
4aba			 
4aba					; set default SPI clk pulse time as 10ms for CARTDEV use 
4aba			 
4aba					ld a, $0a 
4aba					ld (spi_clktime), a 
4aba					NEXTW 
4aba			endif 
4aba			 
4aba			.ENDDEVICE: 
4aba			; eof 
4aba			 
# End of file forth_words_device.asm
4aba			 
4aba			; var handler 
4aba			 
4aba			 
4aba			.VARS: 
4aba				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
4aba 77				db WORD_SYS_CORE+99             
4abb 6b 4b			dw .V0            
4abd 04				db 3 + 1 
4abe .. 00			db "VAR",0              
4ac2				endm 
# End of macro CWHEAD
4ac2			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
4ac2			;| 
4ac2			;| The variable name should consist of a single letter. e.g. "a" 
4ac2			;! If a full string is passed then only the first char is looked at 
4ac2			;| Any other char could exceed bounds checks!  
4ac2			 
4ac2					if DEBUG_FORTH_WORDS_KEY 
4ac2						DMARK "VAR" 
4ac2 f5				push af  
4ac3 3a d7 4a			ld a, (.dmark)  
4ac6 32 6b ee			ld (debug_mark),a  
4ac9 3a d8 4a			ld a, (.dmark+1)  
4acc 32 6c ee			ld (debug_mark+1),a  
4acf 3a d9 4a			ld a, (.dmark+2)  
4ad2 32 6d ee			ld (debug_mark+2),a  
4ad5 18 03			jr .pastdmark  
4ad7 ..			.dmark: db "VAR"  
4ada f1			.pastdmark: pop af  
4adb			endm  
# End of macro DMARK
4adb						CALLMONITOR 
4adb cd 6f ee			call debug_vector  
4ade				endm  
# End of macro CALLMONITOR
4ade					endif 
4ade			 
4ade					FORTH_DSP_VALUEHL 
4ade cd 72 1d			call macro_dsp_valuehl 
4ae1				endm 
# End of macro FORTH_DSP_VALUEHL
4ae1			 
4ae1 7e					ld a, (hl)    ; get first char on of the string 
4ae2			 
4ae2			 
4ae2					if DEBUG_FORTH_WORDS 
4ae2						DMARK "VR1" 
4ae2 f5				push af  
4ae3 3a f7 4a			ld a, (.dmark)  
4ae6 32 6b ee			ld (debug_mark),a  
4ae9 3a f8 4a			ld a, (.dmark+1)  
4aec 32 6c ee			ld (debug_mark+1),a  
4aef 3a f9 4a			ld a, (.dmark+2)  
4af2 32 6d ee			ld (debug_mark+2),a  
4af5 18 03			jr .pastdmark  
4af7 ..			.dmark: db "VR1"  
4afa f1			.pastdmark: pop af  
4afb			endm  
# End of macro DMARK
4afb						CALLMONITOR 
4afb cd 6f ee			call debug_vector  
4afe				endm  
# End of macro CALLMONITOR
4afe					endif 
4afe					 
4afe f5					push af	 
4aff					FORTH_DSP_POP 
4aff cd 2a 1e			call macro_forth_dsp_pop 
4b02				endm 
# End of macro FORTH_DSP_POP
4b02 f1					pop af 
4b03			 
4b03					; convert to upper 
4b03			 
4b03 cd 5b 10				call to_upper 
4b06					if DEBUG_FORTH_WORDS 
4b06						DMARK "Vaa" 
4b06 f5				push af  
4b07 3a 1b 4b			ld a, (.dmark)  
4b0a 32 6b ee			ld (debug_mark),a  
4b0d 3a 1c 4b			ld a, (.dmark+1)  
4b10 32 6c ee			ld (debug_mark+1),a  
4b13 3a 1d 4b			ld a, (.dmark+2)  
4b16 32 6d ee			ld (debug_mark+2),a  
4b19 18 03			jr .pastdmark  
4b1b ..			.dmark: db "Vaa"  
4b1e f1			.pastdmark: pop af  
4b1f			endm  
# End of macro DMARK
4b1f						CALLMONITOR 
4b1f cd 6f ee			call debug_vector  
4b22				endm  
# End of macro CALLMONITOR
4b22					endif 
4b22 06 41				ld b, 'A' 
4b24 90					sub b			; set offset 
4b25					if DEBUG_FORTH_WORDS 
4b25						DMARK "Vbb" 
4b25 f5				push af  
4b26 3a 3a 4b			ld a, (.dmark)  
4b29 32 6b ee			ld (debug_mark),a  
4b2c 3a 3b 4b			ld a, (.dmark+1)  
4b2f 32 6c ee			ld (debug_mark+1),a  
4b32 3a 3c 4b			ld a, (.dmark+2)  
4b35 32 6d ee			ld (debug_mark+2),a  
4b38 18 03			jr .pastdmark  
4b3a ..			.dmark: db "Vbb"  
4b3d f1			.pastdmark: pop af  
4b3e			endm  
# End of macro DMARK
4b3e						CALLMONITOR 
4b3e cd 6f ee			call debug_vector  
4b41				endm  
# End of macro CALLMONITOR
4b41					endif 
4b41 cb 27				sla a  
4b43				 
4b43					 
4b43					if DEBUG_FORTH_WORDS 
4b43						DMARK "VR2" 
4b43 f5				push af  
4b44 3a 58 4b			ld a, (.dmark)  
4b47 32 6b ee			ld (debug_mark),a  
4b4a 3a 59 4b			ld a, (.dmark+1)  
4b4d 32 6c ee			ld (debug_mark+1),a  
4b50 3a 5a 4b			ld a, (.dmark+2)  
4b53 32 6d ee			ld (debug_mark+2),a  
4b56 18 03			jr .pastdmark  
4b58 ..			.dmark: db "VR2"  
4b5b f1			.pastdmark: pop af  
4b5c			endm  
# End of macro DMARK
4b5c						CALLMONITOR 
4b5c cd 6f ee			call debug_vector  
4b5f				endm  
# End of macro CALLMONITOR
4b5f					endif 
4b5f			 
4b5f 21 f4 e9				ld hl, cli_var_array2 
4b62 cd e6 0d				call addatohl 
4b65 cd 6d 1b				call forth_push_numhl 
4b68			 
4b68			 
4b68				       NEXTW 
4b68 c3 28 1f			jp macro_next 
4b6b				endm 
# End of macro NEXTW
4b6b			.V0: 
4b6b				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4b6b 78				db WORD_SYS_CORE+100             
4b6c 83 4b			dw .V0Q            
4b6e 04				db 3 + 1 
4b6f .. 00			db "V0!",0              
4b73				endm 
# End of macro CWHEAD
4b73			;| V0! ( u1 -- )  Store value to v0  | DONE 
4b73			 
4b73					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b73 cd 72 1d			call macro_dsp_valuehl 
4b76				endm 
# End of macro FORTH_DSP_VALUEHL
4b76			 
4b76 11 28 ea				ld de, cli_var_array 
4b79			 
4b79 eb					ex de, hl 
4b7a 73					ld (hl), e 
4b7b 23					inc hl 
4b7c 72					ld (hl), d 
4b7d			 
4b7d					; destroy value TOS 
4b7d			 
4b7d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b7d cd 2a 1e			call macro_forth_dsp_pop 
4b80				endm 
# End of macro FORTH_DSP_POP
4b80			 
4b80				       NEXTW 
4b80 c3 28 1f			jp macro_next 
4b83				endm 
# End of macro NEXTW
4b83			.V0Q: 
4b83				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4b83 79				db WORD_SYS_CORE+101             
4b84 94 4b			dw .V1S            
4b86 04				db 3 + 1 
4b87 .. 00			db "V0@",0              
4b8b				endm 
# End of macro CWHEAD
4b8b			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4b8b 2a 28 ea				ld hl, (cli_var_array) 
4b8e cd 6d 1b				call forth_push_numhl 
4b91			 
4b91				       NEXTW 
4b91 c3 28 1f			jp macro_next 
4b94				endm 
# End of macro NEXTW
4b94			.V1S: 
4b94				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4b94 7a				db WORD_SYS_CORE+102             
4b95 ac 4b			dw .V1Q            
4b97 04				db 3 + 1 
4b98 .. 00			db "V1!",0              
4b9c				endm 
# End of macro CWHEAD
4b9c			;| V1! ( u1 -- )  Store value to v1 | DONE 
4b9c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b9c cd 72 1d			call macro_dsp_valuehl 
4b9f				endm 
# End of macro FORTH_DSP_VALUEHL
4b9f			 
4b9f 11 2a ea				ld de, cli_var_array+2 
4ba2				 
4ba2 eb					ex de, hl 
4ba3 73					ld (hl), e 
4ba4 23					inc hl 
4ba5 72					ld (hl), d 
4ba6			 
4ba6					; destroy value TOS 
4ba6			 
4ba6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4ba6 cd 2a 1e			call macro_forth_dsp_pop 
4ba9				endm 
# End of macro FORTH_DSP_POP
4ba9				       NEXTW 
4ba9 c3 28 1f			jp macro_next 
4bac				endm 
# End of macro NEXTW
4bac			.V1Q: 
4bac				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4bac 7b				db WORD_SYS_CORE+103             
4bad bd 4b			dw .V2S            
4baf 04				db 3 + 1 
4bb0 .. 00			db "V1@",0              
4bb4				endm 
# End of macro CWHEAD
4bb4			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4bb4 2a 2a ea				ld hl, (cli_var_array+2) 
4bb7 cd 6d 1b				call forth_push_numhl 
4bba				       NEXTW 
4bba c3 28 1f			jp macro_next 
4bbd				endm 
# End of macro NEXTW
4bbd			.V2S: 
4bbd				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4bbd 7c				db WORD_SYS_CORE+104             
4bbe d5 4b			dw .V2Q            
4bc0 04				db 3 + 1 
4bc1 .. 00			db "V2!",0              
4bc5				endm 
# End of macro CWHEAD
4bc5			;| V2! ( u1 -- )  Store value to v2 | DONE 
4bc5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bc5 cd 72 1d			call macro_dsp_valuehl 
4bc8				endm 
# End of macro FORTH_DSP_VALUEHL
4bc8			 
4bc8 11 2c ea				ld de, cli_var_array+4 
4bcb				 
4bcb eb					ex de, hl 
4bcc 73					ld (hl), e 
4bcd 23					inc hl 
4bce 72					ld (hl), d 
4bcf			 
4bcf					; destroy value TOS 
4bcf			 
4bcf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bcf cd 2a 1e			call macro_forth_dsp_pop 
4bd2				endm 
# End of macro FORTH_DSP_POP
4bd2				       NEXTW 
4bd2 c3 28 1f			jp macro_next 
4bd5				endm 
# End of macro NEXTW
4bd5			.V2Q: 
4bd5				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4bd5 7d				db WORD_SYS_CORE+105             
4bd6 e6 4b			dw .V3S            
4bd8 04				db 3 + 1 
4bd9 .. 00			db "V2@",0              
4bdd				endm 
# End of macro CWHEAD
4bdd			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4bdd 2a 2c ea				ld hl, (cli_var_array+4) 
4be0 cd 6d 1b				call forth_push_numhl 
4be3				       NEXTW 
4be3 c3 28 1f			jp macro_next 
4be6				endm 
# End of macro NEXTW
4be6			.V3S: 
4be6				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4be6 7c				db WORD_SYS_CORE+104             
4be7 fe 4b			dw .V3Q            
4be9 04				db 3 + 1 
4bea .. 00			db "V3!",0              
4bee				endm 
# End of macro CWHEAD
4bee			;| V3! ( u1 -- )  Store value to v3 | DONE 
4bee					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bee cd 72 1d			call macro_dsp_valuehl 
4bf1				endm 
# End of macro FORTH_DSP_VALUEHL
4bf1			 
4bf1 11 2e ea				ld de, cli_var_array+6 
4bf4				 
4bf4 eb					ex de, hl 
4bf5 73					ld (hl), e 
4bf6 23					inc hl 
4bf7 72					ld (hl), d 
4bf8			 
4bf8					; destroy value TOS 
4bf8			 
4bf8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bf8 cd 2a 1e			call macro_forth_dsp_pop 
4bfb				endm 
# End of macro FORTH_DSP_POP
4bfb				       NEXTW 
4bfb c3 28 1f			jp macro_next 
4bfe				endm 
# End of macro NEXTW
4bfe			.V3Q: 
4bfe				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4bfe 7d				db WORD_SYS_CORE+105             
4bff 0f 4c			dw .END            
4c01 04				db 3 + 1 
4c02 .. 00			db "V3@",0              
4c06				endm 
# End of macro CWHEAD
4c06			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4c06 2a 2e ea				ld hl, (cli_var_array+6) 
4c09 cd 6d 1b				call forth_push_numhl 
4c0c				       NEXTW 
4c0c c3 28 1f			jp macro_next 
4c0f				endm 
# End of macro NEXTW
4c0f			 
4c0f			 
4c0f			 
4c0f			 
4c0f			 
4c0f			; end of dict marker 
4c0f			 
4c0f 00			.END:    db WORD_SYS_END 
4c10 00 00			dw 0 
4c12 00				db 0 
4c13			 
4c13			; use to jp here for user dict words to save on macro expansion  
4c13			 
4c13			user_dict_next: 
4c13				NEXTW 
4c13 c3 28 1f			jp macro_next 
4c16				endm 
# End of macro NEXTW
4c16			 
4c16			 
4c16			user_exec: 
4c16				;    ld hl, <word code> 
4c16				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4c16				;    call forthexec 
4c16				;    jp user_dict_next   (NEXT) 
4c16			        ;    <word code bytes> 
4c16 eb				ex de, hl 
4c17 2a c2 e5			ld hl,(os_tok_ptr) 
4c1a				 
4c1a				FORTH_RSP_NEXT 
4c1a cd 14 1b			call macro_forth_rsp_next 
4c1d				endm 
# End of macro FORTH_RSP_NEXT
4c1d			 
4c1d			if DEBUG_FORTH_UWORD 
4c1d						DMARK "UEX" 
4c1d f5				push af  
4c1e 3a 32 4c			ld a, (.dmark)  
4c21 32 6b ee			ld (debug_mark),a  
4c24 3a 33 4c			ld a, (.dmark+1)  
4c27 32 6c ee			ld (debug_mark+1),a  
4c2a 3a 34 4c			ld a, (.dmark+2)  
4c2d 32 6d ee			ld (debug_mark+2),a  
4c30 18 03			jr .pastdmark  
4c32 ..			.dmark: db "UEX"  
4c35 f1			.pastdmark: pop af  
4c36			endm  
# End of macro DMARK
4c36				CALLMONITOR 
4c36 cd 6f ee			call debug_vector  
4c39				endm  
# End of macro CALLMONITOR
4c39			endif 
4c39			 
4c39			 
4c39			 
4c39 eb				ex de, hl 
4c3a 22 c2 e5			ld (os_tok_ptr), hl 
4c3d				 
4c3d				; Don't use next - Skips the first word in uword. 
4c3d			 
4c3d c3 b9 1f			jp exec1 
4c40			;	NEXT 
4c40			 
4c40			 
4c40			; eof 
# End of file forth_wordsv4.asm
4c40			endif 
4c40			;;;;;;;;;;;;;; Debug code 
4c40			 
4c40			 
4c40			;if DEBUG_FORTH_PARSE 
4c40 .. 00		.nowordfound: db "No match",0 
4c49 .. 00		.compword:	db "Comparing word ",0 
4c59 .. 00		.nextwordat:	db "Next word at",0 
4c66 .. 00		.charmatch:	db "Char match",0 
4c71			;endif 
4c71			if DEBUG_FORTH_JP 
4c71			.foundword:	db "Word match. Exec..",0 
4c71			endif 
4c71			;if DEBUG_FORTH_PUSH 
4c71 .. 00		.enddict:	db "Dict end. Push.",0 
4c81 .. 00		.push_str:	db "Pushing string",0 
4c90 .. 00		.push_num:	db "Pushing number",0 
4c9f .. 00		.data_sp:	db "SP:",0 
4ca3 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4cb5 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4cc7 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4cd9			;endif 
4cd9			;if DEBUG_FORTH_MALLOC 
4cd9 .. 00		.push_malloc:	db "Malloc address",0 
4ce8			;endif 
4ce8			 
4ce8			 
4ce8			 
4ce8			; display malloc address and current data stack pointer  
4ce8			 
4ce8			malloc_error: 
4ce8 d5				push de 
4ce9 f5				push af 
4cea e5				push hl 
4ceb cd b9 0b			call clear_display 
4cee 11 0e 4d			ld de, .mallocerr 
4cf1 3e 00			ld a,0 
4cf3			;	ld de,os_word_scratch 
4cf3 cd cc 0b			call str_at_display 
4cf6 3e 11			ld a, display_row_1+17 
4cf8 11 6b ee			ld de, debug_mark 
4cfb cd cc 0b			call str_at_display 
4cfe cd dc 0b			call update_display 
4d01				;call break_point_state 
4d01 cd 53 5e			call cin_wait 
4d04			 
4d04			;	ld a, ' ' 
4d04			;	ld (os_view_disable), a 
4d04 cd f0 14			call bp_on 
4d07 e1				pop hl 
4d08 f1				pop af 
4d09 d1				pop de	 
4d0a				CALLMONITOR 
4d0a cd 6f ee			call debug_vector  
4d0d				endm  
# End of macro CALLMONITOR
4d0d c9				ret 
4d0e			 
4d0e .. 00		.mallocerr: 	db "Malloc Error",0 
4d1b			;if DEBUG_FORTH_PUSH 
4d1b			display_data_sp: 
4d1b f5				push af 
4d1c			 
4d1c				; see if disabled 
4d1c			 
4d1c			 
4d1c 3a 6f ee			ld a, (debug_vector) 
4d1f fe c9			cp $C9  ; RET 
4d21				;ld a, (os_view_disable) 
4d21				;cp '*' 
4d21 28 67			jr z, .skipdsp 
4d23			 
4d23 e5				push hl 
4d24 e5				push hl 
4d25 e5			push hl 
4d26 cd b9 0b			call clear_display 
4d29 e1			pop hl 
4d2a 7c				ld a,h 
4d2b 21 c6 e5			ld hl, os_word_scratch 
4d2e cd ef 0f			call hexout 
4d31 e1				pop hl 
4d32 7d				ld a,l 
4d33 21 c8 e5			ld hl, os_word_scratch+2 
4d36 cd ef 0f			call hexout 
4d39 21 ca e5			ld hl, os_word_scratch+4 
4d3c 3e 00			ld a,0 
4d3e 77				ld (hl),a 
4d3f 11 c6 e5			ld de,os_word_scratch 
4d42 3e 28				ld a, display_row_2 
4d44 cd cc 0b				call str_at_display 
4d47 11 a3 4c			ld de, .wordinhl 
4d4a 3e 00			ld a, display_row_1 
4d4c			 
4d4c cd cc 0b				call str_at_display 
4d4f 11 6b ee			ld de, debug_mark 
4d52 3e 11			ld a, display_row_1+17 
4d54			 
4d54 cd cc 0b				call str_at_display 
4d57			 
4d57				; display current data stack pointer 
4d57 11 9f 4c			ld de,.data_sp 
4d5a 3e 30				ld a, display_row_2 + 8 
4d5c cd cc 0b				call str_at_display 
4d5f			 
4d5f 2a ee e9			ld hl,(cli_data_sp) 
4d62 e5				push hl 
4d63 7c				ld a,h 
4d64 21 c6 e5			ld hl, os_word_scratch 
4d67 cd ef 0f			call hexout 
4d6a e1				pop hl 
4d6b 7d				ld a,l 
4d6c 21 c8 e5			ld hl, os_word_scratch+2 
4d6f cd ef 0f			call hexout 
4d72 21 ca e5			ld hl, os_word_scratch+4 
4d75 3e 00			ld a,0 
4d77 77				ld (hl),a 
4d78 11 c6 e5			ld de,os_word_scratch 
4d7b 3e 33				ld a, display_row_2 + 11 
4d7d cd cc 0b				call str_at_display 
4d80			 
4d80			 
4d80 cd dc 0b			call update_display 
4d83 cd f1 0a			call delay1s 
4d86 cd f1 0a			call delay1s 
4d89 e1				pop hl 
4d8a			.skipdsp: 
4d8a f1				pop af 
4d8b c9				ret 
4d8c			 
4d8c			display_data_malloc: 
4d8c			 
4d8c f5				push af 
4d8d e5				push hl 
4d8e e5				push hl 
4d8f e5			push hl 
4d90 cd b9 0b			call clear_display 
4d93 e1			pop hl 
4d94 7c				ld a,h 
4d95 21 c6 e5			ld hl, os_word_scratch 
4d98 cd ef 0f			call hexout 
4d9b e1				pop hl 
4d9c 7d				ld a,l 
4d9d 21 c8 e5			ld hl, os_word_scratch+2 
4da0 cd ef 0f			call hexout 
4da3 21 ca e5			ld hl, os_word_scratch+4 
4da6 3e 00			ld a,0 
4da8 77				ld (hl),a 
4da9 11 c6 e5			ld de,os_word_scratch 
4dac 3e 28				ld a, display_row_2 
4dae cd cc 0b				call str_at_display 
4db1 11 d9 4c			ld de, .push_malloc 
4db4 3e 00			ld a, display_row_1 
4db6			 
4db6 cd cc 0b				call str_at_display 
4db9			 
4db9				; display current data stack pointer 
4db9 11 9f 4c			ld de,.data_sp 
4dbc 3e 30				ld a, display_row_2 + 8 
4dbe cd cc 0b				call str_at_display 
4dc1			 
4dc1 2a ee e9			ld hl,(cli_data_sp) 
4dc4 e5				push hl 
4dc5 7c				ld a,h 
4dc6 21 c6 e5			ld hl, os_word_scratch 
4dc9 cd ef 0f			call hexout 
4dcc e1				pop hl 
4dcd 7d				ld a,l 
4dce 21 c8 e5			ld hl, os_word_scratch+2 
4dd1 cd ef 0f			call hexout 
4dd4 21 ca e5			ld hl, os_word_scratch+4 
4dd7 3e 00			ld a,0 
4dd9 77				ld (hl),a 
4dda 11 c6 e5			ld de,os_word_scratch 
4ddd 3e 33				ld a, display_row_2 + 11 
4ddf cd cc 0b				call str_at_display 
4de2			 
4de2 cd dc 0b			call update_display 
4de5 cd f1 0a			call delay1s 
4de8 cd f1 0a			call delay1s 
4deb e1				pop hl 
4dec f1				pop af 
4ded c9				ret 
4dee			;endif 
4dee			 
4dee			include "forth_autostart.asm" 
4dee			; list of commands to perform at system start up 
4dee			 
4dee			startcmds: 
4dee			;	dw test11 
4dee			;	dw test12 
4dee			;	dw test13 
4dee			;	dw test14 
4dee			;	dw test15 
4dee			;	dw test16 
4dee			;	dw test17 
4dee			;	dw ifthtest1 
4dee			;	dw ifthtest2 
4dee			;	dw ifthtest3 
4dee			;	dw mmtest1 
4dee			;	dw mmtest2 
4dee			;	dw mmtest3 
4dee			;	dw mmtest4 
4dee			;	dw mmtest5 
4dee			;	dw mmtest6 
4dee			;	dw iftest1 
4dee			;	dw iftest2 
4dee			;	dw iftest3 
4dee			;	dw looptest1 
4dee			;	dw looptest2 
4dee			;	dw test1 
4dee			;	dw test2 
4dee			;	dw test3 
4dee			;	dw test4 
4dee			;	dw game2r 
4dee			;	dw game2b1 
4dee			;	dw game2b2 
4dee			 
4dee				; start up words that are actually useful 
4dee			 
4dee			;    dw spi1 
4dee			;    dw spi2 
4dee			;    dw spi3 
4dee			;    dw spi4 
4dee			;    dw spi5 
4dee			;    dw spi6 
4dee			;    dw spi7 
4dee			; 
4dee			;    dw spi8 
4dee			;    dw spi9 
4dee			;    dw spi10 
4dee			 
4dee			; file editor 
4dee			;	dw edit1 
4dee			;	dw edit2 
4dee			;	dw edit3 
4dee			 
4dee			;	dw longread 
4dee 0e 52			dw clrstack 
4df0 42 52			dw type 
4df2			;	dw stest 
4df2 67 52			dw strncpy 
4df4			;	dw list 
4df4 c8 52			dw start1 
4df6 d8 52			dw start2 
4df8			;	dw start3 
4df8			;	dw start3b 
4df8			;	dw start3c 
4df8			 
4df8				; (unit) testing words 
4df8			 
4df8			;	dw mtesta 
4df8			;	dw mtestb 
4df8			;	dw mtestc 
4df8			;	dw mtestd 
4df8			;	dw mteste 
4df8			 
4df8				; demo/game words 
4df8			 
4df8			;        dw game3w 
4df8			;        dw game3p 
4df8			;        dw game3sc 
4df8			;        dw game3vsi 
4df8			;        dw game3vs 
4df8				 
4df8			;	dw game2b 
4df8			;	dw game2bf 
4df8			;	dw game2mba 
4df8			;	dw game2mbas 
4df8			;	dw game2mb 
4df8			 
4df8 f5 55			dw game1 
4dfa 06 56			dw game1a 
4dfc 68 56			dw game1b 
4dfe 9d 56			dw game1c 
4e00 d3 56			dw game1d 
4e02 04 57			dw game1s 
4e04 18 57			dw game1t 
4e06 2d 57			dw game1f 
4e08 61 57			dw game1z 
4e0a a5 57			dw game1zz 
4e0c			 
4e0c 2e 54			dw test5 
4e0e 66 54			dw test6 
4e10 9e 54			dw test7 
4e12 b2 54			dw test8 
4e14 de 54			dw test9 
4e16 f4 54			dw test10 
4e18				 
4e18 7c 58		        dw ssv5 
4e1a 60 58		        dw ssv4 
4e1c 44 58		        dw ssv3 
4e1e 0e 58		        dw ssv2 
4e20 95 58		        dw ssv1 
4e22 dd 58		        dw ssv1cpm 
4e24			;	dw keyup 
4e24			;	dw keydown 
4e24			;	dw keyleft 
4e24			;	dw keyright 
4e24			;	dw 	keyf1 
4e24			;	dw keyf2 
4e24			;	dw keyf3 
4e24			;	dw keyf4 
4e24			;	dw keyf5 
4e24			;	dw keyf6 
4e24			;	dw keyf7 
4e24			;	dw keyf8 
4e24			;	dw keyf9 
4e24			;	dw keyf10 
4e24			;	dw keyf11 
4e24			;	dw keyf12 
4e24			;	dw keytab 
4e24			;	dw keycr 
4e24			;	dw keyhome 
4e24			;	dw keyend 
4e24			;	dw keybs 
4e24 00 00			db 0, 0	 
4e26			 
4e26			 
4e26			; File Editor 
4e26			 
4e26			; ( id - ) use 'e' to edit the displayed line 
4e26 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
4e47 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4e7c			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
4e7c .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
4eb4			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
4eb4			 
4eb4			; SPI Net support words 
4eb4			 
4eb4			; v0! = node to send to 
4eb4			; ( str count - ) 
4eb4 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
4f0d			 
4f0d			; spiputc ( char node - ) 
4f0d .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
4f41			; spiputc ( u node - ) 
4f41 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
4f6f			 
4f6f			; spigetc ( - n ) 
4f6f .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
4f98			 
4f98			; getnode ( - n ) 
4f98 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
4fc5			 
4fc5			; ( str node - )  
4fc5 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
502b			; store string ( str i - ) 
502b			 
502b			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
502b .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
5080			 
5080			; get string ( addr i -  )    TO FIX 
5080			 
5080 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
50d8			 
50d8			 
50d8			; NETCHAT (TODO) 
50d8			; Program to allow two nodes to chat with eachother 
50d8			; 
50d8			; v0 - target node 
50d8			;  
50d8			; accept input at 0,0 
50d8			; if input is string send spitype to target node 
50d8			; starting at row 2,0 , while spigetchr is not zero ->  
50d8			; 
50d8			; 
50d8			; TODO add paging of get request 
50d8			 
50d8			; ( node - ) 
50d8 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
50f7 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
514f .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
51c7			 
51c7			 
51c7			; Long read of currently open file 
51c7 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
520e			 
520e			; clear stack  
520e			 
520e .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
5242			 
5242			; type ( addr count - ) 
5242 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
5267			 
5267			; some direct memory words 
5267			; strncpy ( len t f -- t ) 
5267			 
5267 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
52c8			 
52c8 .. 00		start1:     	db ": bpon $00 bp ;",0 
52d8 .. 00		start2:     	db ": bpoff $01 bp ;",0 
52e9 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
5364 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
53c4			 
53c4			 
53c4			; a handy word to list items on the stack 
53c4			 
53c4 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
542e			 
542e			 
542e			; test stack  
542e			; rnd8 stest 
542e			 
542e			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
542e			 
542e			; random malloc and free cycles 
542e			 
542e			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
542e			 
542e			; fixed malloc and free cycles 
542e			 
542e			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
542e			 
542e			; fixed double string push and drop cycle  
542e			 
542e			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
542e			 
542e			; consistent fixed string push and drop cycle  
542e			 
542e			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
542e			 
542e			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
542e			 
542e			;test1:		db ": aa 1 2 3 ;", 0 
542e			;test2:     	db "111 aa 888 999",0 
542e			;test3:     	db ": bb 77 ;",0 
542e			;test4:     	db "$02 $01 do i . loop bb",0 
542e			 
542e .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
5466 .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
549e .. 00		test7:     	db ": box hline vline ;",0 
54b2 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
54de .. 00		test9:     	db ": sw $01 adsp world ;",0 
54f4 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
5519			;test11:     	db "hello create .",0 
5519			;test12:     	db "hello2 create .",0 
5519			 
5519			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
5519			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
5519			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
5519			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
5519			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
5519			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
5519			 
5519			;iftest1:     	db "$0001 IF cls .",0 
5519			;iftest2:     	db "$0000 IF cls .",0 
5519			;iftest3:     	db "$0002 $0003 - IF cls .",0 
5519			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
5519			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
5519			 
5519			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5519			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5519			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
5519			 
5519			 
5519 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
553d .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
556d .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
5592 .. 00		sound4: db ": cha $00 ; ",0 
559f .. 00		sound5: db ": chb $20 ; ",0 
55ac .. 00		sound6: db ": chc $40 ; ",0 
55b9 .. 00		sound7: db ": chd $60 ; ",0 
55c6 .. 00		sound8: db ": cnote $80 + + note ; ", 0 
55de .. 00		sound9: db ": cvol $90 + + note ; ", 0 
55f5			 
55f5			 
55f5			 
55f5			 
55f5			; a small guess the number game 
55f5			 
55f5 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
5606 .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
5668			 
5668 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
569d .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
56d3 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
5704 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5718 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
572d .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5761 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
57a5			 
57a5			; Using 'ga' save a high score across multiple runs using external storage 
57a5			 
57a5 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
580e			 
580e			 
580e			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
580e			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
580e			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
580e			 
580e			; simple screen saver to test code memory reuse to destruction 
580e			 
580e .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
5844 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5860 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
587c .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
5895 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
58dd .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5934			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5934			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5934			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5934			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5934			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5934			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5934			 
5934			 
5934			 
5934			; minesweeper/battleship finding game 
5934			; draws a game board of random ship/mine positions 
5934			; user enters coords to see if it hits on 
5934			; game ends when all are hit 
5934			; when hit or miss says how many may be in the area 
5934			 
5934			; setup the game board and then hide it 
5934			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5934			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5934			;; prompt for where to target 
5934			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5934			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5934			;; TODO see if the entered coords hits or misses pushes char hit of miss 
5934			;game2mbht:      db ": mbckht nop ;",0 
5934			;game2mbms:      db ": mbcms nop ;",0 
5934			; TODO how many might be near by 
5934			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5934			 
5934			; Game 3 
5934			 
5934			; Vert scroller ski game - avoid the trees! 
5934			 
5934			; v0 score (ie turns) 
5934			; v1 player pos 
5934			; v2 left wall 
5934			; v3 right wall 
5934			 
5934			; Draw side walls randomly 
5934			 
5934			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5934			 
5934			; Draw player 
5934			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5934			 
5934			; TODO Get Key 
5934			 
5934			; TODO Move left right 
5934			 
5934			; scroll and move walls a bit 
5934			 
5934			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5934			 
5934			; main game loop 
5934			 
5934			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5934			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5934			 
5934			; key board defs 
5934			 
5934 .. 00		keyup:       db ": keyup $05 ;",0 
5942 .. 00		keydown:       db ": keydown $0a ;",0 
5952 .. 00		keyleft:       db ": keyleft $0b ;",0 
5962 .. 00		keyright:       db ": keyright $0c ;",0 
5973 .. 00		keyf1:       db ": keyf1 $10 ;",0 
5981 .. 00		keyf2:       db ": keyf2 $11 ;",0 
598f .. 00		keyf3:       db ": keyf3 $12 ;",0 
599d .. 00		keyf4:       db ": keyf4 $13 ;",0 
59ab .. 00		keyf5:       db ": keyf5 $14 ;",0 
59b9 .. 00		keyf6:       db ": keyf6 $15 ;",0 
59c7 .. 00		keyf7:       db ": keyf7 $16 ;",0 
59d5 .. 00		keyf8:       db ": keyf8 $17 ;",0 
59e3 .. 00		keyf9:       db ": keyf9 $18 ;",0 
59f1 .. 00		keyf10:       db ": keyf10 $19 ;",0 
5a00 .. 00		keyf11:       db ": keyf11 $1a ;",0 
5a0f .. 00		keyf12:       db ": keyf12 $1b ;",0 
5a1e			 
5a1e .. 00		keytab:       db ": keytab $09 ;",0 
5a2d .. 00		keycr:       db ": keycr $0d ;",0 
5a3b .. 00		keyhome:       db ": keyhome $0e ;",0 
5a4b .. 00		keyend:       db ": keyend $0f ;",0 
5a5a .. 00		keybs:       db ": keybs $08 ;",0 
5a68			 
5a68			   
5a68			 
5a68			 
5a68			 
5a68			; eof 
# End of file forth_autostart.asm
5a68			 
5a68			 
5a68			 
5a68			; stack over and underflow checks 
5a68			 
5a68			; init the words to detect the under/overflow 
5a68			 
5a68			chk_stk_init: 
5a68				; a vague random number to check so we dont get any "lucky" hits 
5a68 3e 2d			ld a, 45 
5a6a 6f				ld l, a 
5a6b 00				nop 
5a6c 3e 17			ld a, 23 
5a6e 67				ld h, a 
5a6f			 
5a6f 22 9d e2			ld (chk_word), hl     ; the word we need to check against 
5a72			 
5a72			;	ld (chk_stund), hl	; stack points.... 
5a72 22 00 ef			ld (chk_stovr), hl 
5a75 22 ec e9			ld (chk_ret_und), hl 
5a78 22 aa e9			ld (chk_ret_ovr), hl 
5a7b 22 28 e9			ld (chk_loop_ovr), hl 
5a7e 22 26 e8			ld (chk_data_ovr), hl 
5a81 c9				ret 
5a82				 
5a82			check_stacks: 
5a82				; check all stack words 
5a82			 
5a82 e5				push hl 
5a83 d5				push de 
5a84			 
5a84			;	ld de,(chk_word) 
5a84			;	ld hl, (chk_stund)	; stack points.... 
5a84			;	if DEBUG_STK_FAULT 
5a84			;		DMARK "FAa" 
5a84			;		CALLMONITOR 
5a84			;	endif 
5a84			;	call cmp16 
5a84			;	jp z, .chk_faulta 
5a84			; 
5a84			;	ld de, sfaultsu 
5a84			;	jp .chk_fault 
5a84			 
5a84 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
5a87 ed 5b 9d e2		ld de,(chk_word) 
5a8b				if DEBUG_STK_FAULT 
5a8b					DMARK "FAb" 
5a8b					CALLMONITOR 
5a8b				endif 
5a8b cd 04 0e			call cmp16 
5a8e 28 06			jr z, .chk_fault1 
5a90 11 31 5b			ld de, sfaultso 
5a93 c3 e5 5a			jp .chk_fault 
5a96			.chk_fault1:  
5a96 2a ec e9			ld hl, (chk_ret_und) 
5a99 ed 5b 9d e2		ld de,(chk_word) 
5a9d				if DEBUG_STK_FAULT 
5a9d					DMARK "FAU" 
5a9d					CALLMONITOR 
5a9d				endif 
5a9d cd 04 0e			call cmp16 
5aa0 ca a9 5a			jp z, .chk_fault2 
5aa3 11 41 5b			ld de, sfaultru 
5aa6 c3 e5 5a			jp .chk_fault 
5aa9			.chk_fault2:  
5aa9 2a aa e9			ld hl, (chk_ret_ovr) 
5aac ed 5b 9d e2		ld de,(chk_word) 
5ab0				if DEBUG_STK_FAULT 
5ab0					DMARK "FA1" 
5ab0					CALLMONITOR 
5ab0				endif 
5ab0 cd 04 0e			call cmp16 
5ab3 ca bc 5a			jp z, .chk_fault3 
5ab6 11 4f 5b			ld de, sfaultro 
5ab9 c3 e5 5a			jp .chk_fault 
5abc			.chk_fault3:  
5abc 2a 28 e9			ld hl, (chk_loop_ovr) 
5abf ed 5b 9d e2		ld de,(chk_word) 
5ac3				if DEBUG_STK_FAULT 
5ac3					DMARK "FA2" 
5ac3					CALLMONITOR 
5ac3				endif 
5ac3 cd 04 0e			call cmp16 
5ac6 ca cf 5a			jp z, .chk_fault4 
5ac9 11 69 5b			ld de, sfaultlo 
5acc c3 e5 5a			jp .chk_fault 
5acf			.chk_fault4:  
5acf 2a 26 e8			ld hl, (chk_data_ovr) 
5ad2 ed 5b 9d e2		ld de,(chk_word) 
5ad6				if DEBUG_STK_FAULT 
5ad6					DMARK "FA3" 
5ad6					CALLMONITOR 
5ad6				endif 
5ad6 cd 04 0e			call cmp16 
5ad9 ca e2 5a			jp z, .chk_fault5 
5adc 11 83 5b			ld de, sfaultdo 
5adf c3 e5 5a			jp .chk_fault 
5ae2			 
5ae2			 
5ae2			.chk_fault5:  
5ae2 d1				pop de 
5ae3 e1				pop hl 
5ae4			 
5ae4 c9				ret 
5ae5			 
5ae5 cd b9 0b		.chk_fault: 	call clear_display 
5ae8 3e 28				ld a, display_row_2 
5aea cd cc 0b				call str_at_display 
5aed 11 13 5b				   ld de, .stackfault 
5af0 3e 00				ld a, display_row_1 
5af2 cd cc 0b				call str_at_display 
5af5 11 6b ee				    ld de, debug_mark 
5af8 3e 11				ld a, display_row_1+17 
5afa cd cc 0b				call str_at_display 
5afd cd dc 0b				call update_display 
5b00			 
5b00				; prompt before entering montior for investigating issue 
5b00			 
5b00 3e 78			ld a, display_row_4 
5b02 11 5f 18			ld de, endprog 
5b05			 
5b05 cd dc 0b			call update_display		 
5b08			 
5b08 cd e5 1a			call next_page_prompt 
5b0b			 
5b0b d1				pop de 
5b0c e1				pop hl 
5b0d cd b3 18				call monitor 
5b10 c3 a9 17				jp warmstart 
5b13					;jp 0 
5b13					;halt 
5b13			 
5b13			 
5b13			 
5b13 .. 00		.stackfault: 	db "Stack fault:",0 
5b20			 
5b20 .. 00		sfaultsu: 	db	"Stack under flow",0 
5b31 .. 00		sfaultso: 	db	"Stack over flow",0 
5b41 .. 00		sfaultru:	db "RTS underflow",0 
5b4f .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
5b69 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
5b83 .. 00		sfaultdo:	db "DTS overflow", 0 
5b90			 
5b90			 
5b90			fault_dsp_under: 
5b90 11 a2 5b			ld de, .dsp_under 
5b93 c3 52 5c			jp .show_fault 
5b96			 
5b96			fault_rsp_under: 
5b96 11 b0 5b			ld de, .rsp_under 
5b99 c3 52 5c			jp .show_fault 
5b9c			fault_loop_under: 
5b9c 11 be 5b			ld de, .loop_under 
5b9f c3 52 5c			jp .show_fault 
5ba2			 
5ba2 .. 00		.dsp_under: db "DSP Underflow",0 
5bb0 .. 00		.rsp_under: db "RSP Underflow",0 
5bbe .. 00		.loop_under: db "LOOP Underflow",0 
5bcd			 
5bcd			 
5bcd d5			type_faultn: 	push de 
5bce e5					push hl 
5bcf cd b9 0b				call clear_display 
5bd2 11 f9 5b				   ld de, .typefaultn 
5bd5 3e 00				ld a, display_row_1 
5bd7 cd cc 0b				call str_at_display 
5bda 11 6b ee				    ld de, debug_mark 
5bdd 3e 11				ld a, display_row_1+17 
5bdf cd cc 0b				call str_at_display 
5be2 cd dc 0b				call update_display 
5be5			 
5be5				; prompt before entering montior for investigating issue 
5be5			 
5be5 3e 78			ld a, display_row_4 
5be7 11 5f 18			ld de, endprog 
5bea			 
5bea cd dc 0b			call update_display		 
5bed			 
5bed cd e5 1a			call next_page_prompt 
5bf0			 
5bf0 e5					push hl 
5bf1 d5					push de 
5bf2 cd b3 18				call monitor 
5bf5 c3 a9 17				jp warmstart 
5bf8 76					halt 
5bf9			 
5bf9			 
5bf9 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
5c10			 
5c10 d5			type_faults: 	push de 
5c11 e5					push hl 
5c12 cd b9 0b				call clear_display 
5c15 11 3b 5c				   ld de, .typefaults 
5c18 3e 00				ld a, display_row_1 
5c1a cd cc 0b				call str_at_display 
5c1d 11 6b ee				    ld de, debug_mark 
5c20 3e 11				ld a, display_row_1+17 
5c22 cd cc 0b				call str_at_display 
5c25 cd dc 0b				call update_display 
5c28			 
5c28				; prompt before entering montior for investigating issue 
5c28			 
5c28 3e 78			ld a, display_row_4 
5c2a 11 5f 18			ld de, endprog 
5c2d			 
5c2d cd dc 0b			call update_display		 
5c30			 
5c30 cd e5 1a			call next_page_prompt 
5c33			 
5c33 e1					pop hl 
5c34 d1					pop de 
5c35 cd b3 18				call monitor 
5c38 c3 a9 17				jp warmstart 
5c3b			 
5c3b			 
5c3b .. 00		.typefaults: db "STR Type Expected TOS!",0 
5c52			 
5c52			.show_fault: 	 
5c52 d5					push de 
5c53 cd b9 0b				call clear_display 
5c56 d1					pop de 
5c57 3e 00				ld a, display_row_1 
5c59 cd cc 0b				call str_at_display 
5c5c 11 6b ee				    ld de, debug_mark 
5c5f 3e 11				ld a, display_row_1+17 
5c61 cd cc 0b				call str_at_display 
5c64 cd dc 0b				call update_display 
5c67			 
5c67				; prompt before entering montior for investigating issue 
5c67			 
5c67 3e 78			ld a, display_row_4 
5c69 11 5f 18			ld de, endprog 
5c6c			 
5c6c cd dc 0b			call update_display		 
5c6f			 
5c6f cd e5 1a			call next_page_prompt 
5c72			 
5c72 e1					pop hl 
5c73 d1					pop de 
5c74 cd b3 18				call monitor 
5c77			; do a dump to cli and not warmstart so we preserve all of the uwords.  
5c77			; TODO Make optional fault restart to cli or warm boot? 
5c77					;jp warmstart 
5c77 c3 f3 17				jp cli 
5c7a 76					halt 
5c7b			 
5c7b			; handle the auto run of code from files in storage 
5c7b			 
5c7b			 
5c7b			include "forth_startup.asm" 
5c7b			; Which startup method to use? 
5c7b			; 
5c7b			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
5c7b			; followed by loading of a list of scripts in eeprom 
5c7b			 
5c7b			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
5c7b			; from eeprom 
5c7b			 
5c7b			; Select with define in main stubs 
5c7b			 
5c7b			if STARTUP_V1 
5c7b				include "forth_startupv1.asm" 
5c7b			; Startup script loading version 1 
5c7b			 
5c7b			; If SE storage is available first stage is to use the selected file 
5c7b			; then go through the eeprom list 
5c7b			 
5c7b .. 00		sprompt1: db "Startup load...",0 
5c8b .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5ca1			 
5ca1			 
5ca1			 
5ca1			 
5ca1			forth_startup: 
5ca1 21 ee 4d			ld hl, startcmds 
5ca4 3e 00			ld a, 0 
5ca6 32 e7 e6			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
5ca9			 
5ca9 e5			.start1:	push hl 
5caa cd b9 0b			call clear_display 
5cad 11 7b 5c			ld de, sprompt1 
5cb0 3e 00		        ld a, display_row_1 
5cb2 cd cc 0b			call str_at_display 
5cb5 11 8b 5c			ld de, sprompt2 
5cb8 3e 28		        ld a, display_row_2 
5cba cd cc 0b			call str_at_display 
5cbd e1				pop hl 
5cbe e5				push hl 
5cbf 5e				ld e,(hl) 
5cc0 23				inc hl 
5cc1 56				ld d,(hl) 
5cc2 3e 50		        ld a, display_row_3 
5cc4 cd cc 0b			call str_at_display 
5cc7 cd dc 0b			call update_display 
5cca			 
5cca			 
5cca 3a e7 e6			ld a, (os_last_cmd) 
5ccd fe 00			cp 0 
5ccf 28 05			jr z, .startprompt 
5cd1 cd e5 0a			call delay250ms 
5cd4 18 24			jr .startdo 
5cd6				 
5cd6				 
5cd6			 
5cd6			.startprompt: 
5cd6			 
5cd6 3e 9f			ld a,display_row_4 + display_cols - 1 
5cd8 11 e3 1a		        ld de, endprg 
5cdb cd cc 0b			call str_at_display 
5cde cd dc 0b			call update_display 
5ce1 cd f1 0a			call delay1s 
5ce4 cd 53 5e			call cin_wait 
5ce7						 
5ce7 fe 2a			cp '*' 
5ce9 28 5e			jr z, .startupend1 
5ceb fe 23			cp '#' 
5ced 20 07			jr nz, .startno 
5cef 3e 01			ld a, 1 
5cf1 32 e7 e6			ld (os_last_cmd),a 
5cf4 18 04			jr .startdo 
5cf6 fe 31		.startno:	cp '1' 
5cf8 28 3a			jr z,.startnxt  
5cfa			 
5cfa				; exec startup line 
5cfa			.startdo:	 
5cfa e1				pop hl 
5cfb e5				push hl 
5cfc				 
5cfc 5e				ld e,(hl) 
5cfd 23				inc hl 
5cfe 56				ld d,(hl) 
5cff eb				ex de,hl 
5d00			 
5d00 e5				push hl 
5d01			 
5d01 3e 00			ld a, 0 
5d03				;ld a, FORTH_END_BUFFER 
5d03 cd 57 11			call strlent 
5d06 23				inc hl   ; include zero term to copy 
5d07 06 00			ld b,0 
5d09 4d				ld c,l 
5d0a e1				pop hl 
5d0b 11 c1 e2			ld de, scratch 
5d0e ed b0			ldir 
5d10			 
5d10			 
5d10 21 c1 e2			ld hl, scratch 
5d13 cd 76 1f			call forthparse 
5d16 cd b6 1f			call forthexec 
5d19 cd c8 1e			call forthexec_cleanup 
5d1c			 
5d1c 3e 78			ld a, display_row_4 
5d1e 11 5f 18			ld de, endprog 
5d21			 
5d21 cd dc 0b			call update_display		 
5d24			 
5d24 3a e7 e6			ld a, (os_last_cmd) 
5d27 fe 00			cp 0 
5d29 20 09			jr nz, .startnxt 
5d2b cd e5 1a			call next_page_prompt 
5d2e cd b9 0b		        call clear_display 
5d31 cd dc 0b			call update_display		 
5d34			 
5d34				; move onto next startup line? 
5d34			.startnxt: 
5d34			 
5d34 cd e5 0a			call delay250ms 
5d37 e1				pop hl 
5d38			 
5d38 23				inc hl 
5d39 23				inc hl 
5d3a			 
5d3a e5				push hl 
5d3b 5e				ld e, (hl) 
5d3c 23				inc hl 
5d3d 56				ld d, (hl) 
5d3e e1				pop hl 
5d3f				; TODO replace 0 test 
5d3f			 
5d3f eb				ex de, hl 
5d40 cd 0f 0e			call ishlzero 
5d43			;	ld a,e 
5d43			;	add d 
5d43			;	cp 0    ; any left to do? 
5d43 eb				ex de, hl 
5d44 c2 a9 5c			jp nz, .start1 
5d47 18 01			jr .startupend 
5d49			 
5d49 e1			.startupend1: pop hl 
5d4a			.startupend: 
5d4a			 
5d4a cd b9 0b			call clear_display 
5d4d cd dc 0b			call update_display 
5d50 c9				ret 
5d51			if STORAGE_SE 
5d51			 
5d51			sprompt3: db "Loading from start-up file?:",0 
5d51			sprompt4: db "(Y=Any key/N=No)",0 
5d51			 
5d51			 
5d51			forth_autoload: 
5d51			 
5d51				; load block 0 of store 1 
5d51				 
5d51				ld a, $fe      ; bit 0 clear 
5d51				ld (spi_device), a 
5d51			 
5d51				call storage_get_block_0 
5d51			 
5d51				ld a, (store_page+STORE_0_AUTOFILE) 
5d51			 
5d51				cp 0 
5d51				ret z     ; auto start not enabled 
5d51			 
5d51				call clear_display 
5d51			 
5d51				; set bank 
5d51			 
5d51					ld a, (store_page+STORE_0_BANKRUN) 
5d51					ld (spi_device), a 
5d51			 
5d51				; get file id to load from and get the file name to display 
5d51			 
5d51					ld a, (store_page+STORE_0_FILERUN) 
5d51			 
5d51					ld l, 0 
5d51					ld h, a 
5d51					ld de, store_page 
5d51			 
5d51					if DEBUG_FORTH_WORDS 
5d51						DMARK "ASp" 
5d51						CALLMONITOR 
5d51					endif 
5d51					call storage_read 
5d51			 
5d51					if DEBUG_FORTH_WORDS 
5d51						DMARK "ASr" 
5d51						CALLMONITOR 
5d51					endif 
5d51			 
5d51					call ishlzero 
5d51					ret z             ; file not found 
5d51			 
5d51					ld a, display_row_2 + 10 
5d51					ld de, store_page+3 
5d51					call str_at_display 
5d51				 
5d51			; 
5d51			 
5d51				ld a, display_row_1+5 
5d51				ld de, sprompt3 
5d51				call str_at_display 
5d51				ld a, display_row_3+15 
5d51				ld de, sprompt4 
5d51				call str_at_display 
5d51			 
5d51				call update_display 
5d51			 
5d51				call cin_wait 
5d51				cp 'n' 
5d51				ret z 
5d51				cp 'N' 
5d51				ret z 
5d51			 
5d51				call delay1s 
5d51			 
5d51				ld a, (store_page+2) 
5d51				ld (store_openmaxext), a    ; save count of ext 
5d51				ld a, 1  
5d51				ld (store_openext), a    ; save count of ext 
5d51			 
5d51			.autof:  
5d51				ld l , a 
5d51				 
5d51				ld a, (store_page) 
5d51				ld h, a	 
5d51				ld de, store_page 
5d51					if DEBUG_FORTH_WORDS 
5d51						DMARK "ASl" 
5d51						CALLMONITOR 
5d51					endif 
5d51					call storage_read 
5d51				call ishlzero 
5d51				ret z 
5d51			;	jr z, .autoend 
5d51			 
5d51					if DEBUG_FORTH_WORDS 
5d51						DMARK "ASc" 
5d51						CALLMONITOR 
5d51					endif 
5d51				ld de, store_page+2 
5d51				ld a, display_row_4 
5d51				call str_at_display 
5d51			 
5d51				call update_display 
5d51				call delay250ms 
5d51			 
5d51			 
5d51			 
5d51				ld hl, store_page+2 
5d51				call forthparse 
5d51				call forthexec 
5d51				call forthexec_cleanup 
5d51			 
5d51				 
5d51				ld a, (store_openext) 
5d51				inc a 
5d51				ld (store_openext), a    ; save count of ext 
5d51			 
5d51				jr .autof 
5d51			;.autofdone: 
5d51			; 
5d51			;		if DEBUG_FORTH_WORDS 
5d51			;			DMARK "ASx" 
5d51			;			CALLMONITOR 
5d51			;		endif 
5d51			;;	call clear_display 
5d51			;	ret 
5d51			 
5d51			 
5d51			 
5d51			endif 
# End of file forth_startupv1.asm
5d51			endif 
5d51			if STARTUP_V2 
5d51				include "forth_startupv2.asm" 
5d51			endif 
5d51			 
# End of file forth_startup.asm
5d51			 
5d51			; eof 
# End of file forth_kernel.asm
5d51			;include "nascombasic.asm" 
5d51			 
5d51			 
5d51			; find out where the code ends if loaded into RAM (for SC114) 
5d51			;endofcode:  
5d51			;	nop 
5d51			 
5d51			 
5d51			; jump to nmi vector 
5d51			 
5d51			init_nmi: 
5d51 3e c9			ld a, $c9   ; RET 
5d53 32 72 ee			ld (nmi_vector), a 
5d56 c9				ret 
5d57			nmi: 
5d57 e5				push hl 
5d58 d5				push de 
5d59 c5				push bc 
5d5a f5				push af 
5d5b cd 72 ee			call nmi_vector 
5d5e f5				push af 
5d5f c5				push bc 
5d60 d5				push de 
5d61 e5				push hl 
5d62 ed 4d			reti 
5d64			 
5d64			 
5d64			; eof 
5d64			 
# End of file main.asm
5d64			;include "firmware_lcd_4x40.asm" 
5d64			;;include "firmware_lcd_4x20.asm" 
5d64			include "firmware_cpm_display.asm" 
5d64			 
5d64			; Serial display interface for SC114 
5d64			 
5d64			 
5d64			display_row_1: equ 0 
5d64			display_row_2: equ display_row_1+display_cols 
5d64			display_row_3: equ display_row_2 + display_cols 
5d64			display_row_4: equ display_row_3 + display_cols 
5d64			 
5d64			kLCDWidth:  EQU display_cols             ;Width in characters 
5d64			kLCD_Line1: EQU 0x00  
5d64			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
5d64			; E1 
5d64			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
5d64			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
5d64			 
5d64			lcd_init: 
5d64				; no init as handled by the SCM bios 
5d64 c9				ret 
5d65			 
5d65			 
5d65			; low level functions for direct screen writes 
5d65			 
5d65			; output char at pos? 
5d65			fLCD_Str: 
5d65			        ;out (SC114_SIO_1_OUT),a 
5d65 c5				push bc 
5d66 d5				push de 
5d67 5f				ld e, a 
5d68			; TODO Replace with CP/M BIOS call 
5d68 0e 02			ld c, $02 
5d6a cd 05 00			call 5 
5d6d d1				pop de 
5d6e c1				pop bc 
5d6f c9				ret 
5d70			 
5d70			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
5d70			fLCD_Pos: 
5d70				; use ASCII escape to position 
5d70			        ;out (SC114_SIO_1_OUT),a 
5d70 c5				push bc 
5d71 d5				push de 
5d72 5f				ld e, a 
5d73 0e 02			ld c, $02 
5d75			; TODO Replace with CP/M BIOS call 
5d75 cd 05 00			call 5 
5d78 d1				pop de 
5d79 c1				pop bc 
5d7a			 
5d7a c9				ret 
5d7b			 
5d7b			; output char at pos 
5d7b			fLCD_Data: 
5d7b			      ;  out (SC114_SIO_1_OUT),a 
5d7b c5				push bc 
5d7c d5				push de 
5d7d 0e 02			ld c, $02 
5d7f 5f				ld e, a 
5d80			; TODO Replace with CP/M BIOS call 
5d80 cd 05 00			call 5 
5d83 d1				pop de 
5d84 c1				pop bc 
5d85			 
5d85 c9				ret 
5d86			 
5d86			; ascii cls  
5d86			 
5d86 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
5d8a			 
5d8a 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
5da1			;.clscpm: db 3, $3c,"$" 
5da1			 
5da1			; write the frame buffer given in hl to hardware  
5da1			write_display: 
5da1			 
5da1			API: equ 0 
5da1			 
5da1			if API 
5da1				push bc 
5da1				ld b, 4 
5da1			 
5da1			        ld (display_write_tmp), hl 	  
5da1			 
5da1				; clear and home cursor 
5da1			 
5da1				ld c, 9 
5da1				ld de, .cls 
5da1			; TODO Replace with CP/M BIOS call 
5da1				call 5 
5da1			 
5da1			 
5da1			.writeln: 
5da1			 
5da1				ld de, (display_write_tmp) 
5da1				ld c, 6 
5da1			; TODO Replace with CP/M BIOS call 
5da1				rst $30 
5da1				ld c, 7 
5da1				rst $30 
5da1			 
5da1				ld hl, (display_write_tmp) 
5da1				ld de, display_cols 
5da1				add hl,de 
5da1				ld (display_write_tmp),hl 
5da1			 
5da1				djnz  .writeln 
5da1			 
5da1				pop bc 
5da1			 
5da1			 
5da1				ret 
5da1			endif 
5da1 e5				push hl 
5da2 c5				push bc 
5da3 d5				push de 
5da4			 
5da4			;	ld c, 2 
5da4			;	;ld de, .cls 
5da4			;	ld a, 27 
5da4			;	rst $30 
5da4			;	ld c, 2 
5da4			;	;ld de, .cls 
5da4			;	ld a, '[' 
5da4			;	rst $30 
5da4			; 
5da4			;	ld c, 2 
5da4			;	;ld de, .cls 
5da4			;	ld a, 'H' 
5da4			;	rst $30 
5da4			; 
5da4			 
5da4			 
5da4			; lots of CR/LF 
5da4			;	ld c, 9 
5da4			;	ld de, .clscpm 
5da4			;	call 5 
5da4			 
5da4			; xterm cls 
5da4 0e 02			ld c, 2 
5da6 1e 1b			ld e, 27 
5da8 cd 05 00			call 5 
5dab			; cls causes too much flicker 
5dab			;	ld c, 2 
5dab			;	ld e, 'c' 
5dab			;	call 5 
5dab			 
5dab			; use xterm home instead 
5dab 0e 02			ld c, 2 
5dad 1e 5b			ld e, '[' 
5daf cd 05 00			call 5 
5db2 0e 02			ld c, 2 
5db4 1e 48			ld e, 'H' 
5db6 cd 05 00			call 5 
5db9			LLL: equ 0 
5db9			 
5db9			if LLL 
5db9			 
5db9				ld c, 2 
5db9				;ld de, .cls 
5db9				ld e, 27 
5db9			; TODO Replace with CP/M BIOS call 
5db9				call 5 
5db9			 
5db9			 
5db9				ld c, 2 
5db9				;ld de, .cls 
5db9				ld e, '[' 
5db9			; TODO Replace with CP/M BIOS call 
5db9				call 5 
5db9				ld c, 2 
5db9				;ld de, .cls 
5db9				ld e, '2' 
5db9			; TODO Replace with CP/M BIOS call 
5db9				call 5 
5db9				ld c, 2 
5db9				;ld de, .cls 
5db9				ld e, 'J' 
5db9			; TODO Replace with CP/M BIOS call 
5db9				call 5 
5db9			 
5db9			endif 
5db9			 
5db9 d1				pop de 
5dba c1				pop bc 
5dbb e1				pop hl 
5dbc			 
5dbc			 
5dbc 22 c9 eb		        ld (display_write_tmp), hl 	  
5dbf 3e 00			ld a, kLCD_Line1 
5dc1			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5dc1 06 28			ld b, display_cols 
5dc3 ed 5b c9 eb		ld de, (display_write_tmp) 
5dc7 cd 4a 5e			call write_len_string 
5dca				 
5dca			 
5dca e5			push hl 
5dcb d5			push de 
5dcc c5			push bc 
5dcd 0e 02			ld c, 2 
5dcf 1e 0a			ld e, 10 
5dd1 cd 05 00			call 5 
5dd4 0e 02			ld c, 2 
5dd6 1e 0d			ld e, 13 
5dd8 cd 05 00			call 5 
5ddb			; TODO Replace with CP/M BIOS call 
5ddb				;rst $30 
5ddb c1			pop bc 
5ddc d1			pop de 
5ddd e1			pop hl 
5dde			 
5dde				 
5dde 2a c9 eb			ld hl, (display_write_tmp) 
5de1 11 28 00			ld de, display_cols 
5de4 19				add hl,de 
5de5 22 c9 eb			ld (display_write_tmp),hl 
5de8			 
5de8				 
5de8 3e 28			ld a, kLCD_Line2 
5dea			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
5dea 06 28			ld b, display_cols 
5dec ed 5b c9 eb		ld de, (display_write_tmp) 
5df0 cd 4a 5e			call write_len_string 
5df3				 
5df3 2a c9 eb			ld hl, (display_write_tmp) 
5df6 11 28 00			ld de, display_cols 
5df9 19				add hl,de 
5dfa 22 c9 eb			ld (display_write_tmp),hl 
5dfd			 
5dfd e5			push hl 
5dfe d5			push de 
5dff c5			push bc 
5e00 0e 07			ld c, 7 
5e02			; TODO Replace with CP/M BIOS call 
5e02				;rst $30 
5e02 0e 02			ld c, 2 
5e04 1e 0a			ld e, 10 
5e06 cd 05 00			call 5 
5e09 0e 02			ld c, 2 
5e0b 1e 0d			ld e, 13 
5e0d cd 05 00			call 5 
5e10 c1			pop bc 
5e11 d1			pop de 
5e12 e1			pop hl 
5e13			 
5e13				 
5e13 3e 50			ld a, kLCD_Line3 
5e15			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
5e15 06 28			ld b, display_cols 
5e17 ed 5b c9 eb		ld de, (display_write_tmp) 
5e1b cd 4a 5e			call write_len_string 
5e1e				 
5e1e 2a c9 eb			ld hl, (display_write_tmp) 
5e21 11 28 00			ld de, display_cols 
5e24 19				add hl,de 
5e25 22 c9 eb			ld (display_write_tmp),hl 
5e28			 
5e28 e5			push hl 
5e29 d5			push de 
5e2a c5			push bc 
5e2b 0e 07			ld c, 7 
5e2d			; TODO Replace with CP/M BIOS call 
5e2d				;rst $30 
5e2d 0e 02			ld c, 2 
5e2f 1e 0a			ld e, 10 
5e31 cd 05 00			call 5 
5e34 0e 02			ld c, 2 
5e36 1e 0d			ld e, 13 
5e38 cd 05 00			call 5 
5e3b c1			pop bc 
5e3c d1			pop de 
5e3d e1			pop hl 
5e3e			 
5e3e				 
5e3e 3e 78			ld a, kLCD_Line4 
5e40			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
5e40 06 28			ld b, display_cols 
5e42 ed 5b c9 eb		ld de, (display_write_tmp) 
5e46 cd 4a 5e			call write_len_string 
5e49 c9					ret 
5e4a			 
5e4a			 
5e4a				; write out a fixed length string given in b from de 
5e4a			 
5e4a 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
5e4b cd 7b 5d		            CALL fLCD_Data      ;Write character to display 
5e4e 13				inc de 
5e4f 10 f9			djnz write_len_string 
5e51 c9				ret 
5e52			 
5e52			 
5e52			; eof 
# End of file firmware_cpm_display.asm
5e52			;include "firmware_key_5x10.asm" 
5e52			;;include "firmware_key_4x10.asm" 
5e52			include "firmware_key_cpm.asm" 
5e52			; Serial keyboard interface for SC114 
5e52			 
5e52			 
5e52			key_init: 
5e52				; no init as handled by the SCM bios 
5e52 c9				ret 
5e53			 
5e53			 
5e53			cin_wait: 
5e53			;	ld a, 0 
5e53			;	ret 
5e53			 
5e53				;in a,(SC114_SIO_1_IN) 
5e53			        ; Use SCM API to get from whatever console device we are using 
5e53			 
5e53			; TODO Replace with CP/M BIOS call 
5e53 c5				push bc 
5e54 0e 01			ld c, $01 
5e56 cd 05 00			call 5 
5e59 c1				pop bc 
5e5a c9				ret 
5e5b			 
5e5b			cin: 
5e5b			 
5e5b			 
5e5b c5				push bc 
5e5c			 
5e5c				; any key waiting to process? 
5e5c			; TODO Replace with CP/M BIOS call 
5e5c 0e 06			ld c, $06 
5e5e cd 05 00			call 5 
5e61 28 0d			jr z, .cin_skip 
5e63			 
5e63				; yep, get it 
5e63			 
5e63 0e 01			ld c, $01 
5e65			; TODO Replace with CP/M BIOS call 
5e65 cd 05 00			call 5 
5e68			 
5e68 fe 7f			cp $7f     ; back space 
5e6a 20 02			jr nz, .skipbs 
5e6c 3e 08			ld a, KEY_BS 
5e6e			.skipbs: 
5e6e			 
5e6e c1				pop bc 
5e6f c9				ret 
5e70			.cin_skip: 
5e70 3e 00			ld a, 0 
5e72 c1				pop bc 
5e73 c9				ret 
5e74			 
5e74			 
5e74			 
5e74			 
# End of file firmware_key_cpm.asm
5e74			endofcode:  
5e74			baseram:  
5e74 00				nop 
5e75			 
5e75			heap_start: equ baseram+15  ; Starting address of heap 
5e75			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
5e75			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
5e75			;VDU:  EQU     endofcode           ; BASIC Work space 
5e75			; eof 
5e75			 
# End of file os_mega_cpm.asm
5e75
