# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 2b 1c			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 ..			buildtime: db   "Build: " 
000a					include "romtimestamp.asm" 
000a ..			db '2025-08-09 10:42' 
# End of file romtimestamp.asm
001a 00				   db 0 
001b			 
001b			 
001b			 
001b			;        nop  
001b			;        nop 
001b			;;	org 05h		; null out bdos call 
001b			; 
001b			;        nop  
001b			;        nop  
001b			;        nop 
001b			;;	org 08h 
001b			;;; 
001b			;;	jp cin		; rst 8 - char in 
001b			;;; 
001b			; 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;        nop 
001b			;	org 010h 
001b			;; 
001b			;	jp cout		; rest 010h  - char out 
001b			;; 
001b			;	org 01bh   
001b			; 
001b			;	;jp  		; rst 01bh   - write string to display 
001b			;	jp str_at_display 
001b			; 
001b			; 
001b			;	org 020h 
001b			; 
001b			;	; jp		 ; rst 020h - read char at screen location 
001b			; 
001b			;	org 028h 
001b			 
001b				; jp		 ; rst 028h  - storage i/o 
001b			 
001b			; 	org 030h 
001b			;	jp break_point_state 
001b			  
001b			; $30  
001b			; org 038h 
001b			; $38 
001b			 
001b			; TODO any more important entry points to add to jump table for easier coding use? 
001b			 
001b			if BASE_KEV = 1  
001b			 
001b				; need to be at $66 for nmi support 
001b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0021 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0027 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0033 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0039 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0045 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0051 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0057 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0063 00 ff			db 0,255 
0065 c3 0e 76			jp nmi 
0068			endif 
0068			 
0068			include "firmware.asm" 
0068			  
0068			; main constants (used here and in firmware)  
0068			  
0068			; TODO have page 0 of storage as bios  
0068			  
0068			Device_A: equ 0h  
0068			Device_B: equ 040h          ; Sound  
0068			  
0068			if BASE_KEV  
0068			Device_C: equ 080h          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			if BASE_SC114  
0068			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			if BASE_CPM  
0068			; TODO fixup for CPM  
0068			Device_C: equ 080h          ; Storage and ext cart devices  
0068			endif  
0068			  
0068			Device_D: equ 0c0h             ; Keyboard and LCD  
0068			  
0068			; Odd specific debug points for testing hardware dev  
0068			  
0068			DEBUG_SOUND: equ 0       
0068			DEBUG_STK_FAULT: equ 0  
0068			DEBUG_INPUT: equ 0     ; Debug input entry code  
0068			DEBUG_INPUTV2: equ 0     ; Debug input entry code  
0068			DEBUG_KEYCINWAIT: equ 0  
0068			DEBUG_KEYCIN: equ 0  
0068			DEBUG_KEY: equ 0  
0068			DEBUG_KEY_MATRIX: equ 0  
0068			DEBUG_STORECF: equ 0  
0068			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0068			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0068			DEBUG_SPI: equ 0    ; low level spi tests  
0068			  
0068			; Enable many break points  
0068			  
0068			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0068			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0068			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0068			DEBUG_FORTH_JP: equ 0    ; 4  
0068			DEBUG_FORTH_MALLOC: equ 0  
0068			DEBUG_FORTH_MALLOC_INT: equ 0  
0068			DEBUG_FORTH_DOT: equ 1  
0068			DEBUG_FORTH_DOT_WAIT: equ 0  
0068			DEBUG_FORTH_MATHS: equ 0  
0068			DEBUG_FORTH_TOK: equ 0    ; 4  
0068			DEBUG_FORTH_PARSE: equ 0    ; 3  
0068			DEBUG_FORTH: equ 0  ;2  
0068			DEBUG_FORTH_WORDS: equ 1   ; 1  
0068			DEBUG_FORTH_PUSH: equ 1   ; 1  
0068			DEBUG_FORTH_UWORD: equ 1   ; 1  
0068			  
0068			; Enable key point breakpoints  
0068			  
0068			DEBUG_FORTH_DOT_KEY: equ 0  
0068			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0068			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0068			  
0068			; Debug stack imbalances  
0068			  
0068			ON: equ 1  
0068			OFF: equ 0  
0068			  
0068			DEBUG_STACK_IMB: equ 0  
0068			STACK_IMB_STORE: equ 20  
0068			  
0068			; House keeping and protections  
0068			  
0068			DEBUG_FORTH_STACK_GUARD: equ 1  
0068			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0068			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0068			FORTH_ENABLE_FREE: equ 0  
0068			FORTH_ENABLE_MALLOCFREE: equ 1  
0068			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0068			FORTH_ENABLE_FLOATMATH: equ 0  
0068			  
0068			  
0068			CALLMONITOR: macro  
0068			;	call break_point_state  
0068			; now use the break point debug vector  
0068				call debug_vector  
0068				endm  
0068			  
0068			MALLOC_1: equ 1        ; from dk88   
0068			MALLOC_2: equ 0           ; broke  
0068			MALLOC_3: equ 0           ; really broke  
0068			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0068			  
0068			if BASE_KEV   
0068			;stacksize: equ 256  
0068			; each stack entry is three bytes (type + word)  
0068			stacksize: equ 3*150  
0068			  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 512  
0068			endif  
0068			if BASE_SC114  
0068			;tos:	equ 0f000h  
0068			stacksize: equ 256  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 256  
0068			endif  
0068			  
0068			if BASE_CPM  
0068			;tos:	equ 0f000h  
0068			stacksize: equ 256  
0068			STACK_RET_SIZE: equ 64  
0068			STACK_LOOP_SIZE: equ 128  
0068			STACK_DATA_SIZE: equ 256  
0068			endif  
0068			  
0068			;if STORAGE_SE == 0  
0068			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0068			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0068			;endif  
0068			  
0068			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0068			  
0068			STORE_0_AUTORUN: equ $20  
0068			  
0068			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0068			  
0068			STORE_0_AUTOFILE: equ $21  
0068			STORE_0_BANKRUN: equ $23  
0068			STORE_0_FILERUN: equ $24  
0068			  
0068			; Block 0 offsets for settings  
0068			  
0068			; if set then skip prompt for start up and accept all  
0068			  
0068			STORE_0_QUICKSTART: equ $25  
0068			  
0068			; Blocks where directory table is held  
0068			  
0068			; Reducing the number of entries increases the max file size  
0068			  
0068			;STORE_DIR_START: equ 1  
0068			;STORE_DIR_END: equ 33  
0068			  
0068			; Blocks from where file data is stored  
0068			  
0068			;STORE_DATA_START: equ STORE_DIR_END + 1  
0068			  
0068			; Block indicators (<32 are data files)  
0068			  
0068			;STORE_BLOCK_CFG: equ $8f       ; config block  
0068			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0068			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0068			;STORE_BLOCK_FREE: equ $85       ; data block free  
0068			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0068			  
0068			  
0068			  
0068			; Directory entry flags  
0068			  
0068			;STORE_DIR_FREE: equ 0  
0068			;STORE_DIR_FILE:  equ 1  
0068			  
0068			; Structure offsets to directory entries  
0068			;STORE_DE_FLAG: equ 0  
0068			;STORE_DE_MAXEXT: equ 1  
0068			;STORE_DE_FILENAME: equ 2  
0068			  
0068			; Structure offsets to block 0  
0068			  
0068			;STORE_BK0_ISFOR: equ 1  
0068			;STORE_BK0_LABEL: equ 3  
0068			  
0068			; memory allocation   
0068			  
0068			chk_stund: equ tos+2           ; underflow check word  
0068			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0068			  
0068			; keyscan table needs rows x cols buffer  
0068			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0068			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0068			  
0068			keyscan_table_row1: equ chk_stovr -key_cols-1  
0068			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0068			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0068			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0068			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0068			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0068			keyscan_scancol: equ keyscan_table-key_cols  
0068			;keyscan_table_len: equ key_rows*key_cols  
0068			;keybufptr: equ keyscan_table - 2  
0068			;keysymbol: equ keybufptr - 1  
0068			key_held: equ keyscan_scancol-1	; currently held  
0068			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0068			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0068			key_fa: equ key_repeat_ct -1 ;  
0068			key_fb: equ key_fa -1 ;  
0068			key_fc: equ key_fb -1 ;  
0068			key_fd: equ key_fc -1 ;  
0068			key_face_held: equ key_fd - 1   
0068			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0068			  
0068			hardware_config: equ key_face_held - 10  
0068			  
0068			; hardware config switches  
0068			; TODO add bitmasks on includes for hardware  
0068			; high byte for expansion ids  
0068			;     0000 0000  no card inserted  
0068			;     0000 0001  storage card inserted  
0068			;     0000 0010  spi sd card active  
0068			  
0068			;       
0068			; low byte:  
0068			;     0000 0001   4x4 keypad  
0068			;     0000 0010   full keyboard  
0068			;     0000 0011   spi/ext keyboard  
0068			;     0000 0100   20x4 lcd  
0068			;     0000 1000   40x4 lcd  
0068			;     0000 1100   spi/ext display  
0068			;     0001 0000   ide interface available  
0068			  
0068			hardware_word: equ hardware_config - 2  
0068			  
0068			; debug marker - optional display of debug point on the debug screens  
0068			  
0068			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
0068			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
0068			  
0068			debug_mark: equ debug_vector - 4  
0068			  
0068			; input_str vars  
0068			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0068			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0068			input_size: equ input_start -1  ; number of chars  
0068			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0068			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0068			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0068			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0068			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0068			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0068			input_len: equ input_cur_onoff - 5 ; length of current input  
0068			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0068			  
0068			; cursor blink rate  
0068			CUR_BLINK_RATE: equ $09  
0068			;CUR_BLINK_RATE: equ 15  
0068			  
0068			key_actual_pressed: equ input_cursor - 1   
0068			key_symbol: equ key_actual_pressed - 1   
0068			key_shift: equ key_symbol - 1   
0068			  
0068			; Display allocation  
0068			  
0068			;display_rows: equ 4     ; move out to mini and mega files  
0068			;display_cols: equ 20  
0068			  
0068			display_fb_len: equ display_rows*display_cols  
0068			  
0068			; primary frame buffer     
0068			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0068			; working frame buffers  
0068			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0068			display_fb3: equ  display_fb1-display_fb_len - 1  
0068			display_fb2: equ  display_fb3-display_fb_len - 1  
0068			;  
0068			; pointer to active frame buffer  
0068			display_fb_active: equ display_fb2 - 2  
0068			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0068			display_write_tmp: equ display_lcde1e2 - 2  
0068			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
0068			  
0068			;  
0068			  
0068			;; can load into de directory  
0068			cursor_col: equ display_active-1  
0068			cursor_row: equ cursor_col-1  
0068			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0068			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0068			  
0068			; maths vars  
0068			  
0068			LFSRSeed: equ cursor_shape -20   
0068			randData: equ LFSRSeed - 2  
0068			xrandc: equ randData - 2  
0068			stackstore: equ xrandc - 2  
0068			seed1: equ  stackstore -2   
0068			seed2: equ seed1 - 2  
0068			  
0068			; cf storage vars  
0068			  
0068			iErrorNum:  equ seed2-1         ;Error number  
0068			iErrorReg:  equ iErrorNum -1              ;Error register  
0068			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0068			  
0068			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0068			  
0068			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
0068			  
0068			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
0068			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0068			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
0068			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
0068			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
0068			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
0068			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0068			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0068			store_tmpid: equ store_tmp3 - 1		; page temp id  
0068			store_tmpext: equ store_tmpid - 1		; file extent temp  
0068			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
0068			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
0068			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
0068			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0068			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
0068			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0068			;  
0068			; spi vars  
0068			  
0068			  
0068			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
0068			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
0068			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0068			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0068			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0068			spi_device_id: equ spi_device - 1    ; human readable bank number  
0068			  
0068			;;;;; forth cli params  
0068			  
0068			; TODO use a different frame buffer for forth???  
0068			  
0068			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0068			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0068			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0068			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0068			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0068			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0068			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0068			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0068			  
0068			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0068			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0068			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0068			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
0068			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
0068			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0068			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0068			  
0068			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0068			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0068			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0068			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0068			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0068			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0068			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0068			  
0068			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0068			  
0068			; os/forth token vars  
0068			  
0068			os_last_cmd: equ os_var_array-255  
0068			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0068			os_current_i: equ os_cli_cmd-2  
0068			os_cur_ptr: equ os_current_i-2  
0068			os_word_scratch: equ os_cur_ptr-30  
0068			os_tok_len: equ os_word_scratch - 2  
0068			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0068			os_tok_malloc: equ os_tok_ptr - 2  
0068			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0068			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0068			execscratch: equ os_input-255        ; exec cmd eval buffer  
0068			scratch: equ execscratch-255  
0068			  
0068			os_stack_1: equ scratch - 3       ; stack holding area 1  
0068			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
0068			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
0068			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
0068			  
0068			  
0068			; temp locations for new word processing to save on adding more   
0068			  
0068			os_new_malloc: equ os_stack_4-2  
0068			os_new_parse_len: equ os_new_malloc - 2  
0068			os_new_word_len: equ os_new_parse_len - 2  
0068			os_new_work_ptr: equ os_new_word_len - 2  
0068			os_new_src_ptr: equ os_new_work_ptr - 2  
0068			os_new_exec: equ os_new_src_ptr - 2  
0068			os_new_exec_ptr: equ os_new_exec - 2  
0068			  
0068			; resume memory alloocations....  
0068			  
0068			;os_view_disable: equ os_new_exec_ptr - 1  
0068			os_view_af: equ os_new_exec_ptr - 2  
0068			os_view_hl: equ os_view_af -2  
0068			os_view_de: equ os_view_hl - 2  
0068			os_view_bc: equ os_view_de - 2  
0068			  
0068			; stack checksum word  
0068			if DEBUG_STACK_IMB  
0068				curframe: equ  os_view_de - 5  
0068				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0068				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0068			else  
0068				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0068			endif  
0068			  
0068			; with data stack could see memory filled with junk. need some memory management   
0068			; malloc and free entry points added  
0068			  
0068			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0068			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0068			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			;heap_end: equ free_list-1  ; Starting address of heap  
0068			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			  
0068			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0068			heap_end: equ chk_word-1  ; Starting address of heap  
0068			  
0068			  
0068			;if BASE_KEV   
0068			;heap_start: equ 0800eh  ; Starting address of heap  
0068			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0068			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0068			;endif  
0068			  
0068			;if BASE_SC114  
0068			;heap_start: equ baseram+15  ; Starting address of heap  
0068			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0068			;endif  
0068			  
0068			  
0068			;;;;  
0068			  
0068			  
0068			; change below to point to last memory alloc above  
0068			topusermem:  equ   heap_start  
0068			  
0068			;if BASE_KEV   
0068			;baseusermem: equ 08000h  
0068			;endif  
0068			  
0068			;if BASE_SC114  
0068			;;aseusermem:     equ    12  
0068			;baseusermem:     equ    prompt  
0068			;;baseusermem:     equ    endofcode  
0068			;endif  
0068			  
0068			  
0068			; **********************************************************************  
0068			; **  Constants  
0068			; **********************************************************************  
0068			  
0068			; Constants used by this code module  
0068			kDataReg:   EQU Device_D           ;PIO port A data register  
0068			kContReg:   EQU Device_D+2           ;PIO port A control register  
0068			  
0068			  
0068			portbdata:  equ Device_D+1    ; port b data  
0068			portbctl:   equ Device_D+3    ; port b control  
0068			  
0068			  
0068			;KEY_SHIFT:   equ 5  
0068			;KEY_SYMBOLSHIFT:  equ 6  
0068			  
0068			KEY_SHIFTLOCK: equ 4  
0068			  
0068			  
0068			KEY_UP: equ 5  
0068			KEY_NEXTWORD: equ 6  
0068			KEY_PREVWORD: equ 7  
0068			KEY_BS: equ 8  
0068			KEY_TAB:  equ 9  
0068			KEY_DOWN: equ 10  
0068			KEY_LEFT: equ 11  
0068			KEY_RIGHT: equ 12  
0068			KEY_CR:   equ 13  
0068			KEY_HOME: equ 14  
0068			KEY_END: equ 15  
0068			  
0068			KEY_F1: equ 16  
0068			KEY_F2: equ 17  
0068			KEY_F3: equ 18  
0068			KEY_F4: equ 19  
0068			  
0068			KEY_F5: equ 20  
0068			KEY_F6: equ 21  
0068			KEY_F7: equ 22  
0068			KEY_F8: equ 23  
0068			  
0068			KEY_F9: equ 24  
0068			KEY_F10: equ 25  
0068			KEY_F11: equ 26  
0068			KEY_F12: equ 27  
0068			  
0068			;if DEBUG_KEY  
0068			;	KEY_MATRIX_NO_PRESS: equ '.'  
0068			;	KEY_SHIFT:   equ '.'  
0068			;	KEY_SYMBOLSHIFT:  equ '.'  
0068			;else  
0068				KEY_SHIFT:   equ '~'  
0068				KEY_SYMBOLSHIFT:  equ '~'  
0068				KEY_MATRIX_NO_PRESS: equ '~'  
0068			;endi  
0068			  
0068			  
0068			  
0068			  
0068			; Macro to make adding debug marks easier  
0068			  
0068			DMARK: macro str  
0068				push af  
0068				ld a, (.dmark)  
0068				ld (debug_mark),a  
0068				ld a, (.dmark+1)  
0068				ld (debug_mark+1),a  
0068				ld a, (.dmark+2)  
0068				ld (debug_mark+2),a  
0068				jr .pastdmark  
0068			.dmark: db str  
0068			.pastdmark: pop af  
0068			  
0068			endm  
0068			  
0068			  
0068			; macro to detect for stack imbalances  
0068			  
0068			include "stackimbal.asm"  
0068			; Macro and code to detect stock imbalances 
0068			 
0068			SPPUSH: equ 0 
0068			 
0068			; Add a stack frame which can be checked before return 
0068			 
0068			STACKFRAME: macro onoff frame1 frame2 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						; save current SP 
0068						exx 
0068			 
0068						ld de, frame1 
0068						ld a, d 
0068						ld hl, curframe 
0068						call hexout 
0068						ld a, e 
0068						ld hl, curframe+2 
0068						call hexout 
0068			  
0068						ld hl, frame1 
0068						push hl 
0068						ld hl, frame2 
0068						push hl 
0068						exx 
0068					endif 
0068					 
0068				endif 
0068			endm 
0068			 
0068			STACKFRAMECHK: macro onoff frame1 frame2 
0068			 
0068					 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						exx 
0068						; check stack frame SP 
0068			 
0068						ld hl, frame2 
0068						pop de   ; frame2 
0068			 
0068						call cmp16 
0068						jr nz, .spnosame 
0068						 
0068			 
0068						ld hl, frame1 
0068						pop de   ; frame1 
0068			 
0068						call cmp16 
0068						jr z, .spfrsame 
0068			 
0068						.spnosame: call showsperror 
0068			 
0068						.spfrsame: nop 
0068			 
0068						exx 
0068					endif 
0068					 
0068				endif 
0068			 
0068			 
0068			endm 
0068			 
0068			 
0068			; for a sub routine, wrap SP collection and comparisons 
0068			 
0068			; Usage: 
0068			; 
0068			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0068			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0068			 
0068			SAVESP: macro onoff storeword 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068						; save current SP 
0068			 
0068						ld (store_sp+(storeword*4)), sp 
0068			 
0068					endif 
0068					 
0068				endif 
0068			 
0068			endm 
0068			 
0068			CHECKSP: macro onoff storeword 
0068			 
0068				if DEBUG_STACK_IMB 
0068					if onoff 
0068			 
0068						; save SP after last save 
0068				 
0068						ld (store_sp+(storeword*4)+2), sp 
0068			 
0068						push hl 
0068						ld hl, store_sp+(storeword*4) 
0068						call check_stack_sp  
0068						pop hl 
0068			 
0068			 
0068					endif 
0068					 
0068				endif 
0068			 
0068			endm 
0068			 
0068			if DEBUG_STACK_IMB 
0068			 
0068			check_stack_sp: 
0068					push de 
0068			 
0068					ld e, (hl) 
0068					inc hl 
0068					ld d, (hl) 
0068					inc hl 
0068			 
0068					push de 
0068			 
0068			 
0068					ld e, (hl) 
0068					inc hl 
0068					ld d, (hl) 
0068					inc hl 
0068			 
0068					pop hl 
0068			 
0068			 
0068					; check to see if the same 
0068			 
0068					call cmp16 
0068					jr z, .spsame 
0068			 
0068					; not same 
0068			 
0068					call showsperror 
0068			.spsame: 
0068			 
0068					pop de 
0068			 
0068					ret 
0068			 
0068			.sperr:  db "Stack imbalance",0 
0068			 
0068			 
0068			showsperror: 
0068			 
0068			 
0068				push hl 
0068				push af 
0068				push de 
0068				call clear_display 
0068				ld de, .sperr 
0068				ld a,0 
0068			;	ld de,os_word_scratch 
0068				call str_at_display 
0068				ld a, display_row_1+17 
0068				ld de, debug_mark 
0068				call str_at_display 
0068				ld a, 0 
0068				ld (curframe+4),a 
0068				ld hl, curframe 
0068				ld de, os_word_scratch 
0068				ld a, display_row_4 
0068				call str_at_display 
0068				call update_display 
0068				;call break_point_state 
0068				call cin_wait 
0068			 
0068			;	ld a, ' ' 
0068			;	ld (os_view_disable), a 
0068				call bp_on 
0068				pop de	 
0068				pop af 
0068				pop hl 
0068				CALLMONITOR 
0068				ret 
0068			 
0068			endif 
0068			 
0068			 
0068			 
0068			; eof 
# End of file stackimbal.asm
0068			  
0068			;TODO macro to calc col and row offset into screen  
0068			  
0068			  
0068			  
0068			hardware_init:  
0068			  
0068				  
0068			  
0068					;ld a, 0  
0068					;ld (hardware_diag), a  
0068			  
0068					; clear all the buffers  
0068			  
0068 21 4b fc				ld hl, display_fb1  
006b 22 07 fb				ld (display_fb_active), hl  
006e			  
006e cd 9b 0d				call clear_display  
0071			  
0071 21 09 fb				ld hl, display_fb2  
0074 22 07 fb				ld (display_fb_active), hl  
0077			  
0077 cd 9b 0d				call clear_display  
007a			  
007a					; init primary frame buffer area  
007a 21 ec fc				ld hl, display_fb0  
007d 22 07 fb				ld (display_fb_active), hl  
0080			  
0080 cd 9b 0d				call clear_display  
0083			  
0083			  
0083 cd 1b 76				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0086			  
0086 cd b2 78			call key_init  
0089 cd 47 02			call storage_init  
008c			  
008c				; setup malloc functions  
008c			  
008c				if MALLOC_1  
008c cd 93 13				call  heap_init  
008f				endif  
008f				if MALLOC_4  
008f					call  heap_init  
008f				endif  
008f			  
008f				; init sound hardware if present  
008f			  
008f				if SOUND_ENABLE  
008f					call sound_init  
008f				endif  
008f			  
008f				; lcd test sequence  
008f					  
008f cd be 0d			call update_display  
0092 cd de 0c			call delay1s  
0095 3e 2b			ld a,'+'  
0097 cd a0 0d			call fill_display  
009a cd be 0d			call update_display  
009d cd de 0c			call delay1s  
00a0 3e 2a			ld a,'*'  
00a2 cd a0 0d			call fill_display  
00a5 cd be 0d			call update_display  
00a8 cd de 0c			call delay1s  
00ab 3e 2d			ld a,'-'  
00ad cd a0 0d			call fill_display  
00b0 cd be 0d			call update_display  
00b3 cd de 0c			call delay1s  
00b6			  
00b6			; boot splash screen  
00b6			if display_cols == 20	  
00b6			        ld a, display_row_1    
00b6			else  
00b6 3e 0a		        ld a, display_row_1 +10   
00b8			endif  
00b8 11 25 1b			ld de, prom_bootmsg  
00bb cd ae 0d			call str_at_display  
00be cd be 0d			call update_display  
00c1			  
00c1			  
00c1 cd de 0c			call delay1s  
00c4 cd de 0c			call delay1s  
00c7			if display_cols == 20	  
00c7			            LD   A, display_row_3+2  
00c7			else  
00c7 3e 5c		            LD   A, display_row_3+12  
00c9			endif  
00c9 11 3a 1b			ld de, prom_bootmsg1  
00cc cd ae 0d			call str_at_display  
00cf cd be 0d			call update_display  
00d2 cd de 0c			call delay1s  
00d5 cd de 0c			call delay1s  
00d8			  
00d8			;	ld a, display_row_4+3  
00d8			;	ld de, bootmsg2  
00d8			;	call str_at_display  
00d8			;	call update_display  
00d8			;	call delay1s  
00d8			;	call delay1s  
00d8			  
00d8			; debug mark setup  
00d8			  
00d8 3e 5f		ld a, '_'  
00da 32 a6 fd		ld (debug_mark),a  
00dd 32 a7 fd		ld (debug_mark+1),a  
00e0 32 a8 fd		ld (debug_mark+2),a  
00e3 3e 00		ld a,0  
00e5 32 a9 fd		ld (debug_mark+3),a  
00e8			  
00e8 c9					ret  
00e9			  
00e9			  
00e9			;bootmsg2:	db "Firmware v0.1",0  
00e9			  
00e9			; a 4x20 lcd  
00e9			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00e9			  
00e9			;if display_cols == 20  
00e9			;	include "firmware_lcd_4x20.asm"  
00e9			;endif  
00e9			  
00e9			;if display_cols == 40  
00e9			;	include "firmware_lcd_4x40.asm"  
00e9			;endif  
00e9			  
00e9			;  
00e9			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00e9			; TODO abstract the bit bang video out interface for dual display  
00e9			; TODO wire video out to tx pin on rc2014 bus  
00e9			  
00e9			; must supply cin, and cin_wait for low level hardware abstraction   
00e9			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00e9			; test scancode  
00e9			  
00e9			;;;;;  
00e9			;;;  
00e9			; Moved out to mini and maxi versions  
00e9			;  
00e9			; include "firmware_key_4x4.asm"  
00e9			; using existing 4 wire x 4 resistor array for input  
00e9			;include "firmware_key_4x10.asm"  
00e9			; need to mod the board for 5 rows due to resistor array  
00e9			;include "firmware_key_5x10.asm"  
00e9			  
00e9			; storage hardware interface  
00e9			  
00e9			; use microchip serial eeprom for storage  
00e9			  
00e9			  
00e9			if STORAGE_SE  
00e9				include "firmware_spi.asm"  
00e9			; my spi protocol (used by storage) 
00e9			 
00e9			; SPI pins 
00e9			 
00e9			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00e9			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00e9			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00e9			 
00e9			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00e9			; chip pin 4 gnd 
00e9			 
00e9			 
00e9			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00e9			SPI_CE1: equ 1      ;    port a1 pin 14  
00e9			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00e9			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00e9			SPI_CE4: equ 4      ; port a4     pin 10 
00e9			 
00e9			; active low AND masks 
00e9			 
00e9			;SPI_CE0_MASK: equ    255-1 
00e9			;SPI_CE1_MASK: equ   255-2 
00e9			;SPI_CE2_MASK: equ   255-4 
00e9			;SPI_CE3_MASK: equ   255-8 
00e9			;SPI_CE4_MASK: equ   255-16 
00e9			SPI_CE_HIGH:  equ 255 
00e9			 
00e9			 
00e9			 
00e9			;  Perform SCLK wait pulse 
00e9			 
00e9			spi_clk: 
00e9 f5				push af 
00ea 3a 9f f9			ld a, (spi_clktime) 
00ed fe 00			cp 0 
00ef 28 03			jr z, .scskip 
00f1 cd c3 0c			call aDelayInMS 
00f4			.scskip: 
00f4 f1				pop af 
00f5 c9				ret 
00f6			 
00f6			 
00f6			 
00f6			; TODO store port id for spi device ie dev c 
00f6			; TODO store pin for SO 
00f6			; TODO store pin for SI 
00f6			; TODO store pin for SCLK 
00f6			 
00f6			; 
00f6			 
00f6			; ensure that spi bus is in a stable state with default pins  
00f6			 
00f6			se_stable_spi:   
00f6			 
00f6				 ; set DI high, CE high , SCLK low 
00f6				;ld a, SPI_DI | SPI_CE0 
00f6 3e 07			ld a, SPI_DI  
00f8 cd 02 02			call spi_ce_high 
00fb d3 80			 out (storage_adata),a 
00fd 32 9c f9			ld (spi_portbyte),a 
0100			 
0100				if DEBUG_SPI 
0100					push hl 
0100					ld l, a 
0100					DMARK "SPI" 
0100					CALLMONITOR 
0100					pop hl 
0100				endif 
0100 c9				ret 
0101			 
0101			; byte to send in a 
0101			 
0101			spi_send_byte: 
0101				; save byte to send for bit mask shift out 
0101 4f			        ld c,a 
0102 3a 9c f9			ld a,(spi_portbyte) 
0105				  
0105				; clock out	each bit of the byte msb first 
0105			 
0105 06 08			ld b, 8 
0107			.ssb1: 
0107				; clear so bit  
0107 cb bf			res SPI_DI, a 
0109 cb 11			rl c 
010b				; if bit 7 is set then carry is set 
010b 30 02			jr nc, .ssb2 
010d cb ff			set SPI_DI,a 
010f			.ssb2:  ; output bit to ensure it is stable 
010f d3 80			out (storage_adata),a 
0111 00				nop 
0112				; clock bit high 
0112 cb ef			set SPI_SCLK,a 
0114 d3 80			out (storage_adata),a 
0116 00				nop 
0117 cd e9 00			call spi_clk 
011a				; then low 
011a cb af			res SPI_SCLK,a 
011c d3 80			out (storage_adata),a 
011e 00				nop 
011f cd e9 00			call spi_clk 
0122 10 e3			djnz .ssb1 
0124			 
0124 32 9c f9			ld (spi_portbyte),a 
0127 c9				ret 
0128			 
0128			; TODO low level get byte into A on spi 
0128			 
0128			spi_read_byte:  
0128			 
0128				; save byte to send for bit mask shift out 
0128 0e 00		    ld c,0 
012a 3a 9c f9			ld a,(spi_portbyte) 
012d				  
012d				; clock out	each bit of the byte msb first 
012d			 
012d			 
012d				; clock bit high 
012d cb ef			set SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132 cd e9 00			call spi_clk 
0135			 
0135			    ; read DO  
0135			 
0135 cb f9		    set 7,c 
0137 db 80			in a,(storage_adata) 
0139 cb 77		    bit SPI_DO,a 
013b 20 02		    jr nz, .b7 
013d cb b9		    res 7,c 
013f			.b7: 
013f				; then low 
013f cb af			res SPI_SCLK,a 
0141 d3 80			out (storage_adata),a 
0143 00				nop 
0144 cd e9 00			call spi_clk 
0147			     
0147			 
0147				; clock bit high 
0147 cb ef			set SPI_SCLK,a 
0149 d3 80			out (storage_adata),a 
014b 00				nop 
014c cd e9 00			call spi_clk 
014f			 
014f			    ; read DO  
014f			 
014f cb f1		    set 6,c 
0151 db 80			in a,(storage_adata) 
0153 cb 77		    bit SPI_DO,a 
0155 20 02		    jr nz, .b6 
0157 cb b1		    res 6,c 
0159			.b6: 
0159				; then low 
0159 cb af			res SPI_SCLK,a 
015b d3 80			out (storage_adata),a 
015d 00				nop 
015e cd e9 00			call spi_clk 
0161			 
0161				; clock bit high 
0161 cb ef			set SPI_SCLK,a 
0163 d3 80			out (storage_adata),a 
0165 00				nop 
0166 cd e9 00			call spi_clk 
0169			 
0169			 
0169			    ; read DO  
0169			 
0169 cb e9		    set 5,c 
016b db 80			in a,(storage_adata) 
016d cb 77		    bit SPI_DO,a 
016f 20 02		    jr nz, .b5 
0171 cb a9		    res 5,c 
0173			.b5: 
0173				; then low 
0173 cb af			res SPI_SCLK,a 
0175 d3 80			out (storage_adata),a 
0177 00				nop 
0178 cd e9 00			call spi_clk 
017b				; clock bit high 
017b cb ef			set SPI_SCLK,a 
017d d3 80			out (storage_adata),a 
017f 00				nop 
0180 cd e9 00			call spi_clk 
0183			 
0183			    ; read DO  
0183			 
0183 cb e1		    set 4,c 
0185 db 80			in a,(storage_adata) 
0187 cb 77		    bit SPI_DO,a 
0189 20 02		    jr nz, .b4 
018b cb a1		    res 4,c 
018d			.b4: 
018d				; then low 
018d cb af			res SPI_SCLK,a 
018f d3 80			out (storage_adata),a 
0191 00				nop 
0192 cd e9 00			call spi_clk 
0195				; clock bit high 
0195 cb ef			set SPI_SCLK,a 
0197 d3 80			out (storage_adata),a 
0199 00				nop 
019a cd e9 00			call spi_clk 
019d			 
019d			    ; read DO  
019d			 
019d cb d9		    set 3,c 
019f db 80			in a,(storage_adata) 
01a1 cb 77		    bit SPI_DO,a 
01a3 20 02		    jr nz, .b3 
01a5 cb 99		    res 3,c 
01a7			.b3: 
01a7				; then low 
01a7 cb af			res SPI_SCLK,a 
01a9 d3 80			out (storage_adata),a 
01ab 00				nop 
01ac cd e9 00			call spi_clk 
01af				; clock bit high 
01af cb ef			set SPI_SCLK,a 
01b1 d3 80			out (storage_adata),a 
01b3 00				nop 
01b4 cd e9 00			call spi_clk 
01b7			 
01b7			    ; read DO  
01b7			 
01b7 cb d1		    set 2,c 
01b9 db 80			in a,(storage_adata) 
01bb cb 77		    bit SPI_DO,a 
01bd 20 02		    jr nz, .b2 
01bf cb 91		    res 2,c 
01c1			.b2: 
01c1				; then low 
01c1 cb af			res SPI_SCLK,a 
01c3 d3 80			out (storage_adata),a 
01c5 00				nop 
01c6 cd e9 00			call spi_clk 
01c9				; clock bit high 
01c9 cb ef			set SPI_SCLK,a 
01cb d3 80			out (storage_adata),a 
01cd 00				nop 
01ce cd e9 00			call spi_clk 
01d1			 
01d1			    ; read DO  
01d1			 
01d1 cb c9		    set 1,c 
01d3 db 80			in a,(storage_adata) 
01d5 cb 77		    bit SPI_DO,a 
01d7 20 02		    jr nz, .b1 
01d9 cb 89		    res 1,c 
01db			.b1: 
01db				; then low 
01db cb af			res SPI_SCLK,a 
01dd d3 80			out (storage_adata),a 
01df 00				nop 
01e0 cd e9 00			call spi_clk 
01e3				; clock bit high 
01e3 cb ef			set SPI_SCLK,a 
01e5 d3 80			out (storage_adata),a 
01e7 00				nop 
01e8 cd e9 00			call spi_clk 
01eb			 
01eb			    ; read DO  
01eb			 
01eb cb c1		    set 0,c 
01ed db 80			in a,(storage_adata) 
01ef cb 77		    bit SPI_DO,a 
01f1 20 02		    jr nz, .b0 
01f3 cb 81		    res 0,c 
01f5			.b0: 
01f5				; then low 
01f5 cb af			res SPI_SCLK,a 
01f7 d3 80			out (storage_adata),a 
01f9 00				nop 
01fa cd e9 00			call spi_clk 
01fd			 
01fd			 
01fd 32 9c f9			ld (spi_portbyte),a 
0200			 
0200			    ; return byte 
0200 79			    ld a,c 
0201			 
0201			 
0201 c9				ret 
0202			 
0202			 
0202			 
0202			spi_ce_high: 
0202			 
0202				if DEBUG_SPI_HARD_CE0 
0202			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202					ret 
0202			 
0202				endif 
0202			 
0202			 
0202 f5				push af 
0203			 
0203				; send direct ce to port b 
0203 3e ff			ld a, 255 
0205 d3 81			out (storage_bdata), a 
0207			 
0207 f1				pop af 
0208			 
0208				; for port a that shares with spi lines AND the mask 
0208			  
0208				if DEBUG_SPI 
0208					push hl 
0208					ld h, a 
0208				endif 
0208			;	ld c, SPI_CE_HIGH 
0208			;	and c 
0208 cb c7			set SPI_CE0, a 
020a cb cf			set SPI_CE1, a 
020c cb d7			set SPI_CE2, a 
020e cb df			set SPI_CE3, a 
0210 cb e7			set SPI_CE4, a 
0212			 
0212				if DEBUG_SPI 
0212					ld l, a 
0212					DMARK "CEh" 
0212					CALLMONITOR 
0212					pop hl 
0212				endif 
0212 c9				ret 
0213			 
0213			 
0213			spi_ce_low: 
0213			 
0213				if DEBUG_SPI_HARD_CE0 
0213			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0213					ret 
0213			 
0213				endif 
0213			 
0213 c5				push bc 
0214 f5				push af 
0215			 
0215				; send direct ce to port b 
0215 3a 9e f9			ld a, (spi_cartdev) 
0218 d3 81			out (storage_bdata), a 
021a			 
021a			 
021a			 
021a				; for port a that shares with spi lines AND the mask 
021a			 
021a 3a 9b f9			ld a, (spi_device)  
021d 4f				ld c, a 
021e			 
021e f1				pop af 
021f			 
021f				; detect CEx 
021f			 
021f				if DEBUG_SPI 
021f					push hl 
021f					ld h, a 
021f				endif 
021f			 
021f cb 41			bit SPI_CE0, c 
0221 20 04			jr nz, .cel1 
0223 cb 87			res SPI_CE0, a 
0225 18 1e			jr .celn 
0227			.cel1: 
0227 cb 49			bit SPI_CE1, c 
0229 20 04			jr nz, .cel2 
022b cb 8f			res SPI_CE1, a 
022d 18 16			jr .celn 
022f			.cel2: 
022f cb 51			bit SPI_CE2, c 
0231 20 04			jr nz, .cel3 
0233 cb 97			res SPI_CE2, a 
0235 18 0e			jr .celn 
0237			.cel3: 
0237 cb 59			bit SPI_CE3, c 
0239 20 04			jr nz, .cel4 
023b cb 9f			res SPI_CE3, a 
023d 18 06			jr .celn 
023f			.cel4: 
023f cb 61			bit SPI_CE4, c 
0241 20 02			jr nz, .celn 
0243 cb a7			res SPI_CE4, a 
0245			.celn: 
0245			 
0245			 
0245			 
0245			;	add c 
0245			 
0245				if DEBUG_SPI 
0245					ld l, a 
0245					DMARK "CEl" 
0245					CALLMONITOR 
0245					pop hl 
0245				endif 
0245 c1				pop bc 
0246 c9				ret 
0247			 
0247			 
0247			 
0247			; eof 
0247			 
0247			 
0247			 
0247			 
0247			 
# End of file firmware_spi.asm
0247				include "firmware_seeprom.asm"  
0247			; 
0247			; persisent storage interface via microchip serial eeprom 
0247			 
0247			; port a pio 2 
0247			; pa 7 - si 
0247			; pa 6 - sclk  
0247			; pa 5 - so 
0247			; pa 4 - cs 
0247			; pa 3 - cs 
0247			; pa 2 - cs 
0247			; pa 1 - cs 
0247			; pa 0 - cs 
0247			; 
0247			; TODO get block 
0247			; TODO save block 
0247			; TODO load file 
0247			; TODO save file 
0247			; TODO get dir  
0247			 
0247			;  
0247			storage_adata: equ Device_C    ; device c port a - onboard storage 
0247			storage_actl: equ Device_C+2     ; device c port a 
0247			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0247			storage_bctl: equ Device_C+3     ; device c port b 
0247			 
0247			 
0247			; TODO move these to hardware driver file 
0247			 
0247			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0247			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0247			; storage bank file system format 
0247			; 
0247			; first page of bank: 
0247			; 	addr 0 - status check 
0247			;       addr 1 - write protect flag 
0247			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0247			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0247			;         TODO see if scanning whole of for available next file id is fast enough 
0247			;	addr 4 > zero term string of bank label 
0247			; 
0247			;        
0247			;  
0247			; first page of any file: 
0247			;      byte 0 - file id  
0247			;      byte 1-17 - fixed file name  
0247			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0247			; 
0247			; other pages of any file: 
0247			;      byte 0 - file id 
0247			;      byte 1> - file data 
0247			; 
0247			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0247			;  
0247			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0247			 
0247			 
0247			;storage_so_bit: 5 
0247			;storage_si_bit: 7 
0247			;storage_sclk_bit: 6 
0247			  
0247			 
0247			; init storage pio 
0247			 
0247			storage_init: 
0247			 
0247			 
0247					; set default SPI clk pulse time as disabled 
0247			 
0247 3e 00				ld a, 0 
0249 32 9f f9				ld (spi_clktime), a 
024c			 
024c					; init hardware 
024c			 
024c 3e cf		            LD   A, 11001111b 
024e d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
0250 3e 00		            LD   A, 00000000b 
0252 cb f7			set SPI_DO,a 
0254			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0254 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0256			 
0256 3e cf		            LD   A, 11001111b 
0258 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
025a 3e 00		            LD   A, 00000000b 
025c d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
025e			 
025e				; set all external spi devices off  
025e 3e ff			ld a, 255 
0260 32 9b f9			ld (spi_device), a 
0263 32 9e f9			ld (spi_cartdev), a 
0266			 
0266					; ensure the spi bus is in a default stable state 
0266 cd f6 00				call se_stable_spi 
0269			 
0269			; TODO scan spi bus and gather which storage banks are present 
0269			 
0269			; populate store_bank_active  
0269			; for each ce line activate and attempt to write first byte of bank and read back 
0269			; if zero is returned then bank is empty 
0269			;   
0269			; 
0269			 
0269					; init file extent cache to save on slow reads 
0269			 
0269			;	ld hl, store_filecache 
0269			;	ld de, 0 
0269			;	ld hl,(de)	 
0269			 
0269			 
0269 c9			    ret 
026a			 
026a			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
026a			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
026a			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
026a			 
026a			; INSTRUCTION SET 
026a			; READ 0000 0011 Read data from memory array beginning at selected address 
026a			; WRITE 0000 0010 Write data to memory array beginning at selected address 
026a			; WREN 0000 0110 Set the write enable latch (enable write operations) 
026a			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
026a			; RDSR 0000 0101 Read STATUS register 
026a			; WRSR 0000 0001 Write STATUS register 
026a			; PE 0100 0010 Page Erase – erase one page in memory array 
026a			; SE 1101 1000 Sector Erase – erase one sector in memory array 
026a			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
026a			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
026a			 
026a			; TODO send byte steam for page without setting the address for every single byte 
026a			; TODO read byte  
026a			 
026a			; byte in a 
026a			; address in hl  
026a			se_writebyte: 
026a			        
026a			    ;   ld c, a 
026a f5			        push af 
026b e5			        push hl 
026c			 
026c			    ; initi write mode 
026c			    ; 
026c			    ;CS low 
026c			 
026c 3a 9c f9		       ld a,(spi_portbyte) 
026f cd 13 02			call spi_ce_low 
0272			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0272 d3 80		       out (storage_adata),a 
0274 32 9c f9		       ld (spi_portbyte), a 
0277			 
0277			    ;clock out wren instruction 
0277			 
0277 3e 06		    ld a, store_wren_ins 
0279 cd 01 01		    call spi_send_byte  
027c			 
027c			    ;cs high to enable write latch 
027c			 
027c 3a 9c f9		       ld a,(spi_portbyte) 
027f cd 02 02			call spi_ce_high 
0282			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0282 d3 80		       out (storage_adata),a 
0284 32 9c f9		       ld (spi_portbyte), a 
0287			 
0287 00				nop 
0288			    ; 
0288			    ; intial write data 
0288			    ; 
0288			    ; cs low 
0288			     
0288 3a 9c f9		       ld a,(spi_portbyte) 
028b cd 13 02			call spi_ce_low 
028e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
028e d3 80		       out (storage_adata),a 
0290 32 9c f9		       ld (spi_portbyte), a 
0293			 
0293			    ; clock out write instruction 
0293			     
0293 3e 02		    ld a, store_write_ins  
0295 cd 01 01		    call spi_send_byte  
0298			 
0298			    ; clock out address (depending on address size) 
0298			     
0298 e1			    pop hl 
0299 7c			    ld a,h    ; address out msb first 
029a cd 01 01		    call spi_send_byte  
029d 7d			    ld a,l 
029e cd 01 01		    call spi_send_byte  
02a1			 
02a1			    ; clock out byte(s) for page 
02a1			 
02a1 f1			    pop af 
02a2 cd 01 01		    call spi_send_byte  
02a5			 
02a5			    ; end write with ce high 
02a5 3a 9c f9		       ld a,(spi_portbyte) 
02a8			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02a8 cd 02 02			call spi_ce_high 
02ab d3 80		       out (storage_adata),a 
02ad 32 9c f9		       ld (spi_portbyte), a 
02b0			 
02b0				; pause for internal write cycle 
02b0 3e 0a			ld a, 10 
02b2 cd c3 0c			call aDelayInMS 
02b5 c9			    ret 
02b6			 
02b6			; buffer to write in de 
02b6			; address in hl  
02b6			se_writepage: 
02b6			        
02b6			    ;   ld c, a 
02b6 d5				push de 
02b7 e5			        push hl 
02b8			 
02b8			    ; initi write mode 
02b8			    ; 
02b8			    ;CS low 
02b8			 
02b8 3a 9c f9		       ld a,(spi_portbyte) 
02bb cd 13 02			call spi_ce_low 
02be			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02be d3 80		       out (storage_adata),a 
02c0 32 9c f9		       ld (spi_portbyte), a 
02c3			 
02c3			    ;clock out wren instruction 
02c3			 
02c3 3e 06		    ld a, store_wren_ins 
02c5 cd 01 01		    call spi_send_byte  
02c8			 
02c8			    ;cs high to enable write latch 
02c8			 
02c8 3a 9c f9		       ld a,(spi_portbyte) 
02cb cd 02 02			call spi_ce_high 
02ce			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02ce d3 80		       out (storage_adata),a 
02d0 32 9c f9		       ld (spi_portbyte), a 
02d3			 
02d3 00				nop 
02d4			    ; 
02d4			    ; intial write data 
02d4			    ; 
02d4			    ; cs low 
02d4			     
02d4 3a 9c f9		       ld a,(spi_portbyte) 
02d7			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02d7 cd 13 02			call spi_ce_low 
02da d3 80		       out (storage_adata),a 
02dc 32 9c f9		       ld (spi_portbyte), a 
02df			 
02df			    ; clock out write instruction 
02df			     
02df 3e 02		    ld a, store_write_ins  
02e1 cd 01 01		    call spi_send_byte  
02e4			 
02e4			    ; clock out address (depending on address size) 
02e4			     
02e4 e1			    pop hl 
02e5 7c			    ld a,h    ; address out msb first 
02e6 cd 01 01		    call spi_send_byte  
02e9 7d			    ld a,l 
02ea cd 01 01		    call spi_send_byte  
02ed			 
02ed			    ; clock out byte(s) for page 
02ed			 
02ed e1				pop hl 
02ee 06 40			ld b, STORE_BLOCK_PHY 
02f0			.bytewrite: 
02f0			 
02f0 7e				ld a,(hl) 
02f1 e5			    push hl 
02f2 c5				push bc 
02f3 cd 01 01		    call spi_send_byte  
02f6 c1				pop bc 
02f7 e1				pop hl 
02f8			 
02f8			    ; end write with ce high 
02f8 3a 9c f9		       ld a,(spi_portbyte) 
02fb cd 02 02			call spi_ce_high 
02fe			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02fe d3 80		       out (storage_adata),a 
0300 32 9c f9		       ld (spi_portbyte), a 
0303			 
0303 23				inc hl 
0304 10 ea			djnz .bytewrite 
0306			 
0306				; pause for internal write cycle 
0306 3e 64			ld a, 100 
0308 cd c3 0c			call aDelayInMS 
030b c9			    ret 
030c			; returns byte in a 
030c			; address in hl  
030c			se_readbyte: 
030c d5				push de 
030d c5				push bc 
030e			 
030e			    ;   ld c, a 
030e e5			        push hl 
030f			 
030f			    ; initi write mode 
030f			    ; 
030f			    ;CS low 
030f			 
030f 3a 9c f9		       ld a,(spi_portbyte) 
0312 cd 13 02			call spi_ce_low 
0315			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0315 d3 80		       out (storage_adata),a 
0317 32 9c f9		       ld (spi_portbyte), a 
031a			 
031a			    ;clock out wren instruction 
031a			 
031a 3e 03		    ld a, store_read_ins 
031c cd 01 01		    call spi_send_byte  
031f			 
031f			 
031f			    ; clock out address (depending on address size) 
031f			     
031f e1			    pop hl 
0320 7c			    ld a,h    ; address out msb first 
0321 cd 01 01		    call spi_send_byte  
0324 7d			    ld a,l 
0325 cd 01 01		    call spi_send_byte  
0328			 
0328			    ; clock in byte(s) for page 
0328			 
0328 cd 28 01		    call spi_read_byte  
032b f5				push af 
032c			 
032c			    ; end write with ce high 
032c 3a 9c f9		       ld a,(spi_portbyte) 
032f			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
032f cd 02 02			call spi_ce_high 
0332 d3 80		       out (storage_adata),a 
0334 32 9c f9		       ld (spi_portbyte), a 
0337			 
0337 f1				pop af 
0338			 
0338 c1				pop bc 
0339 d1				pop de 
033a			 
033a c9			    ret 
033b			 
033b			if DEBUG_STORESE 
033b			 
033b			storageput:  
033b			 
033b			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
033b			 
033b 21 fe f0			ld hl,scratch+2 
033e cd 9b 12			call get_word_hl 
0341			 
0341				; stuff it here for the moment as it will be overwritten later anyway 
0341			 
0341 22 1f f4			ld (os_cur_ptr),hl	 
0344			 
0344			 
0344			; get pointer to start of string 
0344			 
0344 21 03 f1			ld hl, scratch+7 
0347			 
0347			; loop writing char of string to eeprom 
0347			 
0347 7e			.writestr:	ld a,(hl) 
0348 fe 00				cp 0 
034a 28 12				jr z, .wsdone		; done writing 
034c e5					push hl 
034d 2a 1f f4				ld hl,(os_cur_ptr) 
0350 cd 6a 02				call se_writebyte 
0353			 
0353 2a 1f f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0356 23					inc hl 
0357 22 1f f4				ld (os_cur_ptr),hl 
035a			 
035a					; restore string pointer and get next char 
035a			 
035a e1					pop hl 
035b 23					inc hl 
035c 18 e9				jr .writestr 
035e			 
035e			 
035e			 
035e			.wsdone: 
035e			 
035e			 
035e			; when done load first page into a buffer  
035e			 
035e 21 00 80				ld hl,08000h		; start in ram 
0361 22 1f f4				ld (os_cur_ptr),hl 
0364 21 00 00				ld hl, 0		 ; start of page 
0367 22 24 f1				ld (scratch+40),hl	; hang on to it 
036a			 
036a 06 80				ld b, 128		; actually get more then one page 
036c c5			.wsload:	push bc 
036d 2a 24 f1				ld hl,(scratch+40) 
0370 e5					push hl 
0371 cd 0c 03				call se_readbyte 
0374			 
0374					; a now as the byte 
0374			 
0374 2a 1f f4				ld hl,(os_cur_ptr) 
0377 77					ld (hl),a 
0378					; inc next buffer area 
0378 23					inc hl 
0379 22 1f f4				ld (os_cur_ptr),hl 
037c			 
037c					; get eeprom position, inc and save for next round 
037c e1					pop hl		 
037d 23					inc hl 
037e 22 24 f1				ld (scratch+40),hl 
0381 c1					pop bc 
0382 10 e8				djnz .wsload 
0384			 
0384			; set 'd' pointer to start of buffer 
0384			 
0384 21 00 80				ld hl,08000h 
0387 22 1f f4				ld (os_cur_ptr),hl 
038a			 
038a			 
038a c9			ret 
038b			 
038b			 
038b c9			storageread: ret 
038c			 
038c			 
038c			 
038c			 
038c			 
038c			 
038c			endif 
038c			 
038c			 
038c			 
# End of file firmware_seeprom.asm
038c			else  
038c			   ; create some stubs for the labels  
038c			se_readbyte: ret  
038c			se_writebyte: ret  
038c			storage_init: ret  
038c			  
038c			endif  
038c			  
038c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
038c			;include "firmware_cf.asm"  
038c			  
038c			; load up high level storage hardward abstractions  
038c			include "firmware_storage.asm"  
038c			 
038c			; persisent storage hardware abstraction layer  
038c			 
038c			 
038c			 
038c			; Block 0 on storage is a config state 
038c			 
038c			 
038c			 
038c			; TODO add read phy block and write phy block functions 
038c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
038c			 
038c			; Abstraction layer  
038c			 
038c			; Logocial block size is same size as physical size - using tape concept 
038c			 
038c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
038c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
038c			 
038c			 
038c			 
038c			; Filesystem layout (Logical layout) 
038c			; 
038c			; Block 0 - Bank config  
038c			; 
038c			;      Byte - 0 file id counter 
038c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
038c			;      Byte - 3-20 zero terminated bank label 
038c			; 
038c			; Block 1 > File storage 
038c			; 
038c			;      Byte 0 file id    - block 0 file details 
038c			;      Byte 1 block id - block 0 is file  
038c			;            Byte 2-15 - File name 
038c			; 
038c			;       - to end of block data 
038c			; 
038c			 
038c			; Get ID for the file named in pointer held HL 
038c			; Returns ID in HL = 255 if no file found 
038c			 
038c			storage_getid: 
038c			 
038c 22 ae f9			ld (store_tmp1), hl 
038f			 
038f				if DEBUG_STORESE 
038f					DMARK "SGI" 
038f f5				push af  
0390 3a a4 03			ld a, (.dmark)  
0393 32 a6 fd			ld (debug_mark),a  
0396 3a a5 03			ld a, (.dmark+1)  
0399 32 a7 fd			ld (debug_mark+1),a  
039c 3a a6 03			ld a, (.dmark+2)  
039f 32 a8 fd			ld (debug_mark+2),a  
03a2 18 03			jr .pastdmark  
03a4 ..			.dmark: db "SGI"  
03a7 f1			.pastdmark: pop af  
03a8			endm  
# End of macro DMARK
03a8					CALLMONITOR 
03a8 cd aa fd			call debug_vector  
03ab				endm  
# End of macro CALLMONITOR
03ab				endif 
03ab				; get block 0 and set counter for number of files to scan 
03ab			 
03ab cd 16 05			call storage_get_block_0 
03ae			 
03ae 3a b5 f9			ld a, (store_page) 
03b1 47				ld b, a 
03b2			 
03b2				; get extent 0 of each file id 
03b2			 
03b2				if DEBUG_STORESE 
03b2					DMARK "SGc" 
03b2 f5				push af  
03b3 3a c7 03			ld a, (.dmark)  
03b6 32 a6 fd			ld (debug_mark),a  
03b9 3a c8 03			ld a, (.dmark+1)  
03bc 32 a7 fd			ld (debug_mark+1),a  
03bf 3a c9 03			ld a, (.dmark+2)  
03c2 32 a8 fd			ld (debug_mark+2),a  
03c5 18 03			jr .pastdmark  
03c7 ..			.dmark: db "SGc"  
03ca f1			.pastdmark: pop af  
03cb			endm  
# End of macro DMARK
03cb					CALLMONITOR 
03cb cd aa fd			call debug_vector  
03ce				endm  
# End of macro CALLMONITOR
03ce				endif 
03ce 60			.getloop:	ld h, b 
03cf 2e 00				ld l, 0 
03d1 c5					push bc 
03d2			 
03d2 11 b5 f9				ld de, store_page 
03d5				if DEBUG_STORESE 
03d5					DMARK "SGr" 
03d5 f5				push af  
03d6 3a ea 03			ld a, (.dmark)  
03d9 32 a6 fd			ld (debug_mark),a  
03dc 3a eb 03			ld a, (.dmark+1)  
03df 32 a7 fd			ld (debug_mark+1),a  
03e2 3a ec 03			ld a, (.dmark+2)  
03e5 32 a8 fd			ld (debug_mark+2),a  
03e8 18 03			jr .pastdmark  
03ea ..			.dmark: db "SGr"  
03ed f1			.pastdmark: pop af  
03ee			endm  
# End of macro DMARK
03ee					CALLMONITOR 
03ee cd aa fd			call debug_vector  
03f1				endm  
# End of macro CALLMONITOR
03f1				endif 
03f1 cd be 09				call storage_read 
03f4 cd f8 0f				call ishlzero 
03f7 28 2d				jr z, .gap 
03f9					 
03f9					; have a file name read. Is it one we want. 
03f9			 
03f9 2a ae f9				ld hl, (store_tmp1) 
03fc 11 b8 f9				ld de, store_page+3   ; file name 
03ff			 
03ff				if DEBUG_STORESE 
03ff					DMARK "SGc" 
03ff f5				push af  
0400 3a 14 04			ld a, (.dmark)  
0403 32 a6 fd			ld (debug_mark),a  
0406 3a 15 04			ld a, (.dmark+1)  
0409 32 a7 fd			ld (debug_mark+1),a  
040c 3a 16 04			ld a, (.dmark+2)  
040f 32 a8 fd			ld (debug_mark+2),a  
0412 18 03			jr .pastdmark  
0414 ..			.dmark: db "SGc"  
0417 f1			.pastdmark: pop af  
0418			endm  
# End of macro DMARK
0418					CALLMONITOR 
0418 cd aa fd			call debug_vector  
041b				endm  
# End of macro CALLMONITOR
041b				endif 
041b cd 7a 13				call strcmp 
041e 20 06				jr nz, .gap   ; not this one 
0420			 
0420 c1				        pop bc 
0421			 
0421 26 00				ld h, 0 
0423 68					ld l, b 
0424 18 22				jr .getdone 
0426						 
0426			 
0426			 
0426			 
0426			.gap: 
0426				if DEBUG_STORESE 
0426					DMARK "SGg" 
0426 f5				push af  
0427 3a 3b 04			ld a, (.dmark)  
042a 32 a6 fd			ld (debug_mark),a  
042d 3a 3c 04			ld a, (.dmark+1)  
0430 32 a7 fd			ld (debug_mark+1),a  
0433 3a 3d 04			ld a, (.dmark+2)  
0436 32 a8 fd			ld (debug_mark+2),a  
0439 18 03			jr .pastdmark  
043b ..			.dmark: db "SGg"  
043e f1			.pastdmark: pop af  
043f			endm  
# End of macro DMARK
043f					CALLMONITOR 
043f cd aa fd			call debug_vector  
0442				endm  
# End of macro CALLMONITOR
0442				endif 
0442			 
0442 c1					pop bc 
0443 10 89				djnz .getloop 
0445 21 ff 00				ld hl, 255 
0448			.getdone: 
0448			 
0448				if DEBUG_STORESE 
0448					DMARK "SGe" 
0448 f5				push af  
0449 3a 5d 04			ld a, (.dmark)  
044c 32 a6 fd			ld (debug_mark),a  
044f 3a 5e 04			ld a, (.dmark+1)  
0452 32 a7 fd			ld (debug_mark+1),a  
0455 3a 5f 04			ld a, (.dmark+2)  
0458 32 a8 fd			ld (debug_mark+2),a  
045b 18 03			jr .pastdmark  
045d ..			.dmark: db "SGe"  
0460 f1			.pastdmark: pop af  
0461			endm  
# End of macro DMARK
0461					CALLMONITOR 
0461 cd aa fd			call debug_vector  
0464				endm  
# End of macro CALLMONITOR
0464				endif 
0464			 
0464 c9				ret 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			 
0465			; Read Block 
0465			; ---------- 
0465			; 
0465			; With current bank 
0465			;  
0465			; Get block number to read 
0465			; Load physical blocks starting at start block into buffer 
0465			 
0465			; de points to buffer to use 
0465			; hl holds logical block number  
0465			 
0465			storage_read_block: 
0465			 
0465				; TODO bank selection 
0465			 
0465				; for each of the physical blocks read it into the buffer 
0465 06 40			ld b, STORE_BLOCK_PHY 
0467			 
0467				if DEBUG_STORESE 
0467 d5					push de 
0468				endif 
0468				 
0468			.rl1:    
0468			 
0468				; read physical block at hl into de 
0468			        ; increment hl and de to next read position on exit 
0468			 
0468 e5				push hl 
0469 d5				push de	 
046a c5				push bc 
046b			;	if DEBUG_STORESE 
046b			;		push af 
046b			;		ld a, 'R' 
046b			;		ld (debug_mark),a 
046b			;		pop af 
046b			;		CALLMONITOR 
046b			;	endif 
046b cd 0c 03			call se_readbyte 
046e			;	if DEBUG_STORESE 
046e			;		ld a,(spi_portbyte) 
046e			;		ld l, a 
046e			;		push af 
046e			;		ld a, '1' 
046e			;		ld (debug_mark),a 
046e			;		pop af 
046e			;		CALLMONITOR 
046e			;	endif 
046e c1				pop bc 
046f d1				pop de 
0470 e1				pop hl 
0471 12				ld (de),a 
0472 23				inc hl 
0473 13				inc de 
0474			 
0474			;	if DEBUG_STORESE 
0474			;		push af 
0474			;		ld a, 'r' 
0474			;		ld (debug_mark),a 
0474			;		pop af 
0474			;		CALLMONITOR 
0474			;	endif 
0474			 
0474 10 f2			djnz .rl1 
0476			 
0476				if DEBUG_STORESE 
0476					DMARK "SRB" 
0476 f5				push af  
0477 3a 8b 04			ld a, (.dmark)  
047a 32 a6 fd			ld (debug_mark),a  
047d 3a 8c 04			ld a, (.dmark+1)  
0480 32 a7 fd			ld (debug_mark+1),a  
0483 3a 8d 04			ld a, (.dmark+2)  
0486 32 a8 fd			ld (debug_mark+2),a  
0489 18 03			jr .pastdmark  
048b ..			.dmark: db "SRB"  
048e f1			.pastdmark: pop af  
048f			endm  
# End of macro DMARK
048f d1					pop de 
0490			; 
0490			;		push af 
0490			;		ld a, 'R' 
0490			;		ld (debug_mark),a 
0490			;		pop af 
0490					CALLMONITOR 
0490 cd aa fd			call debug_vector  
0493				endm  
# End of macro CALLMONITOR
0493				endif 
0493 c9				ret	 
0494				 
0494			 
0494			; File Size 
0494			; --------- 
0494			; 
0494			;   hl file id 
0494			; 
0494			;  returns in hl the number of blocks 
0494			 
0494			storage_file_size: 
0494 5d				ld e, l 
0495 16 00			ld d, 0 
0497 21 40 00			ld hl, STORE_BLOCK_PHY 
049a					if DEBUG_FORTH_WORDS 
049a						DMARK "SIZ" 
049a f5				push af  
049b 3a af 04			ld a, (.dmark)  
049e 32 a6 fd			ld (debug_mark),a  
04a1 3a b0 04			ld a, (.dmark+1)  
04a4 32 a7 fd			ld (debug_mark+1),a  
04a7 3a b1 04			ld a, (.dmark+2)  
04aa 32 a8 fd			ld (debug_mark+2),a  
04ad 18 03			jr .pastdmark  
04af ..			.dmark: db "SIZ"  
04b2 f1			.pastdmark: pop af  
04b3			endm  
# End of macro DMARK
04b3						CALLMONITOR 
04b3 cd aa fd			call debug_vector  
04b6				endm  
# End of macro CALLMONITOR
04b6					endif 
04b6 cd 98 07			call storage_findnextid 
04b9			 
04b9 cd f8 0f			call ishlzero 
04bc			;	ld a, l 
04bc			;	add h 
04bc			;	cp 0 
04bc c8				ret z			; block not found so EOF 
04bd			 
04bd 11 b5 f9			ld de, store_page 
04c0 cd 65 04			call storage_read_block 
04c3			 
04c3 3a b7 f9			ld a, (store_page+2)	 ; get extent count 
04c6 6f				ld l, a 
04c7 26 00			ld h, 0 
04c9 c9			 	ret 
04ca			 
04ca			 
04ca			; Write Block 
04ca			; ----------- 
04ca			; 
04ca			; With current bank 
04ca			;  
04ca			; Get block number to write 
04ca			; Write physical blocks starting at start block from buffer 
04ca			  
04ca			storage_write_block: 
04ca				; TODO bank selection 
04ca			 
04ca				; for each of the physical blocks read it into the buffer 
04ca 06 40			ld b, STORE_BLOCK_PHY 
04cc			 
04cc				if DEBUG_STORESE 
04cc					DMARK "SWB" 
04cc f5				push af  
04cd 3a e1 04			ld a, (.dmark)  
04d0 32 a6 fd			ld (debug_mark),a  
04d3 3a e2 04			ld a, (.dmark+1)  
04d6 32 a7 fd			ld (debug_mark+1),a  
04d9 3a e3 04			ld a, (.dmark+2)  
04dc 32 a8 fd			ld (debug_mark+2),a  
04df 18 03			jr .pastdmark  
04e1 ..			.dmark: db "SWB"  
04e4 f1			.pastdmark: pop af  
04e5			endm  
# End of macro DMARK
04e5			 
04e5					;push af 
04e5					;ld a, 'W' 
04e5					;ld (debug_mark),a 
04e5					;pop af 
04e5					CALLMONITOR 
04e5 cd aa fd			call debug_vector  
04e8				endm  
# End of macro CALLMONITOR
04e8				endif 
04e8			 
04e8			; might not be working 
04e8			;	call se_writepage 
04e8			 
04e8			;	ret 
04e8			; 
04e8			 
04e8			 
04e8			 
04e8			.wl1:    
04e8			 
04e8				; read physical block at hl into de 
04e8			        ; increment hl and de to next read position on exit 
04e8			 
04e8 e5				push hl 
04e9 d5				push de	 
04ea c5				push bc 
04eb 1a				ld a,(de) 
04ec				;if DEBUG_STORESE 
04ec			;		push af 
04ec			;		ld a, 'W' 
04ec			;		ld (debug_mark),a 
04ec			;		pop af 
04ec			;		CALLMONITOR 
04ec			;	endif 
04ec cd 6a 02			call se_writebyte 
04ef			;	call delay250ms 
04ef 00				nop 
04f0 00				nop 
04f1 00				nop 
04f2			;	if DEBUG_STORESE 
04f2			;		push af 
04f2			;		ld a, 'w' 
04f2			;		ld (debug_mark),a 
04f2			;		pop af 
04f2			;		CALLMONITOR 
04f2			;	endif 
04f2 c1				pop bc 
04f3 d1				pop de 
04f4 e1				pop hl 
04f5 23				inc hl 
04f6 13				inc de 
04f7			 
04f7			 
04f7 10 ef			djnz .wl1 
04f9			 
04f9				if DEBUG_STORESE 
04f9					DMARK "SW2" 
04f9 f5				push af  
04fa 3a 0e 05			ld a, (.dmark)  
04fd 32 a6 fd			ld (debug_mark),a  
0500 3a 0f 05			ld a, (.dmark+1)  
0503 32 a7 fd			ld (debug_mark+1),a  
0506 3a 10 05			ld a, (.dmark+2)  
0509 32 a8 fd			ld (debug_mark+2),a  
050c 18 03			jr .pastdmark  
050e ..			.dmark: db "SW2"  
0511 f1			.pastdmark: pop af  
0512			endm  
# End of macro DMARK
0512			 
0512					;push af 
0512					;ld a, 'W' 
0512					;ld (debug_mark),a 
0512					;pop af 
0512					CALLMONITOR 
0512 cd aa fd			call debug_vector  
0515				endm  
# End of macro CALLMONITOR
0515				endif 
0515 c9				ret	 
0516			 
0516			; Init bank 
0516			; --------- 
0516			; 
0516			; With current bank 
0516			; 
0516			; Setup block 0 config 
0516			;     Set 0 file id counter 
0516			;     Set formatted byte pattern 
0516			;     Zero out bank label 
0516			;      
0516			; For every logical block write 0-1 byte as null 
0516			 
0516			storage_get_block_0: 
0516			 
0516				; TODO check presence 
0516			 
0516				; get block 0 config 
0516			 
0516 21 00 00			ld hl, 0 
0519 11 b5 f9			ld de, store_page 
051c cd 65 04			call storage_read_block 
051f			 
051f				if DEBUG_STORESE 
051f					DMARK "SB0" 
051f f5				push af  
0520 3a 34 05			ld a, (.dmark)  
0523 32 a6 fd			ld (debug_mark),a  
0526 3a 35 05			ld a, (.dmark+1)  
0529 32 a7 fd			ld (debug_mark+1),a  
052c 3a 36 05			ld a, (.dmark+2)  
052f 32 a8 fd			ld (debug_mark+2),a  
0532 18 03			jr .pastdmark  
0534 ..			.dmark: db "SB0"  
0537 f1			.pastdmark: pop af  
0538			endm  
# End of macro DMARK
0538 11 b5 f9				ld de, store_page 
053b			;		push af 
053b			;		ld a, 'i' 
053b			;		ld (debug_mark),a 
053b			;		pop af 
053b					CALLMONITOR 
053b cd aa fd			call debug_vector  
053e				endm  
# End of macro CALLMONITOR
053e				endif 
053e			 
053e				; is this area formatted? 
053e			 
053e			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
053e 2a b6 f9			ld hl, (store_page+1) 
0541 3e 80			ld a,0x80 
0543 bd				cp l 
0544 20 22			jr nz, .ininotformatted 
0546				; do a double check 
0546 3e 27			ld a, 0x27 
0548 bc				cp h 
0549 20 1d			jr nz, .ininotformatted 
054b			 
054b				; formatted then 
054b			 
054b				if DEBUG_STORESE 
054b					DMARK "SB1" 
054b f5				push af  
054c 3a 60 05			ld a, (.dmark)  
054f 32 a6 fd			ld (debug_mark),a  
0552 3a 61 05			ld a, (.dmark+1)  
0555 32 a7 fd			ld (debug_mark+1),a  
0558 3a 62 05			ld a, (.dmark+2)  
055b 32 a8 fd			ld (debug_mark+2),a  
055e 18 03			jr .pastdmark  
0560 ..			.dmark: db "SB1"  
0563 f1			.pastdmark: pop af  
0564			endm  
# End of macro DMARK
0564					;push af 
0564					;ld a, 'I' 
0564					;ld (debug_mark),a 
0564					;pop af 
0564					CALLMONITOR 
0564 cd aa fd			call debug_vector  
0567				endm  
# End of macro CALLMONITOR
0567				endif 
0567 c9				ret 
0568			 
0568			.ininotformatted: 
0568				; bank not formatted so poke various bits to make sure 
0568			 
0568				if DEBUG_STORESE 
0568					DMARK "SB2" 
0568 f5				push af  
0569 3a 7d 05			ld a, (.dmark)  
056c 32 a6 fd			ld (debug_mark),a  
056f 3a 7e 05			ld a, (.dmark+1)  
0572 32 a7 fd			ld (debug_mark+1),a  
0575 3a 7f 05			ld a, (.dmark+2)  
0578 32 a8 fd			ld (debug_mark+2),a  
057b 18 03			jr .pastdmark  
057d ..			.dmark: db "SB2"  
0580 f1			.pastdmark: pop af  
0581			endm  
# End of macro DMARK
0581					;push af 
0581					;ld a, 'f' 
0581					;ld (debug_mark),a 
0581					;pop af 
0581					CALLMONITOR 
0581 cd aa fd			call debug_vector  
0584				endm  
# End of macro CALLMONITOR
0584				endif 
0584			 
0584 cd a1 0c			call storage_clear_page 
0587			 
0587 21 b5 f9			ld hl, store_page 
058a 3e 00			ld a, 0 
058c				 
058c 77				ld (hl),a   ; reset file counter 
058d			 
058d 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0590 22 b6 f9		 	ld (store_page+1), hl	 
0593			 
0593				; set default label 
0593			 
0593 21 2f 06			ld hl, .defaultbanklabl 
0596 11 b8 f9		 	ld de, store_page+3 
0599 01 0f 00			ld bc, 15 
059c ed b0			ldir 
059e			 
059e				; Append the current bank id 
059e 21 c1 f9			ld hl, store_page+3+9 
05a1 3a 9a f9			ld a, (spi_device_id) 
05a4 77				ld (hl), a 
05a5			 
05a5				; save default page 0 
05a5			 
05a5 21 00 00			ld hl, 0 
05a8 11 b5 f9			ld de, store_page 
05ab				if DEBUG_STORESE 
05ab					DMARK "SB3" 
05ab f5				push af  
05ac 3a c0 05			ld a, (.dmark)  
05af 32 a6 fd			ld (debug_mark),a  
05b2 3a c1 05			ld a, (.dmark+1)  
05b5 32 a7 fd			ld (debug_mark+1),a  
05b8 3a c2 05			ld a, (.dmark+2)  
05bb 32 a8 fd			ld (debug_mark+2),a  
05be 18 03			jr .pastdmark  
05c0 ..			.dmark: db "SB3"  
05c3 f1			.pastdmark: pop af  
05c4			endm  
# End of macro DMARK
05c4			;		push af 
05c4			;		ld a, 'F' 
05c4			;		ld (debug_mark),a 
05c4			;		pop af 
05c4					CALLMONITOR 
05c4 cd aa fd			call debug_vector  
05c7				endm  
# End of macro CALLMONITOR
05c7				endif 
05c7 cd ca 04			call storage_write_block 
05ca				if DEBUG_STORESE 
05ca					DMARK "SB4" 
05ca f5				push af  
05cb 3a df 05			ld a, (.dmark)  
05ce 32 a6 fd			ld (debug_mark),a  
05d1 3a e0 05			ld a, (.dmark+1)  
05d4 32 a7 fd			ld (debug_mark+1),a  
05d7 3a e1 05			ld a, (.dmark+2)  
05da 32 a8 fd			ld (debug_mark+2),a  
05dd 18 03			jr .pastdmark  
05df ..			.dmark: db "SB4"  
05e2 f1			.pastdmark: pop af  
05e3			endm  
# End of macro DMARK
05e3			;		push af 
05e3			;		ld a, '>' 
05e3			;		ld (debug_mark),a 
05e3			;		pop af 
05e3					CALLMONITOR 
05e3 cd aa fd			call debug_vector  
05e6				endm  
# End of macro CALLMONITOR
05e6				endif 
05e6			 
05e6 00				nop 
05e7 00				nop 
05e8 00				nop 
05e9			 
05e9				; now set 0 in every page to mark as a free block 
05e9			 
05e9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05eb 21 40 00			ld hl, STORE_BLOCK_PHY 
05ee			 
05ee 3e 00		.setmark1:   	ld a,0 
05f0 e5					push hl 
05f1 c5					push bc 
05f2 cd 6a 02				call se_writebyte 
05f5 3e 0a			ld a, 10 
05f7 cd c3 0c			call aDelayInMS 
05fa 23				inc hl 
05fb cd 6a 02				call se_writebyte 
05fe 3e 0a			ld a, 10 
0600 cd c3 0c			call aDelayInMS 
0603 2b				dec hl 
0604 c1					pop bc 
0605 e1					pop hl 
0606 3e 40				ld a, STORE_BLOCK_PHY 
0608 cd cf 0f				call addatohl 
060b 10 e1				djnz .setmark1 
060d			 
060d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
060f 3e 00		.setmark2:   	ld a,0 
0611 e5					push hl 
0612 c5					push bc 
0613 cd 6a 02				call se_writebyte 
0616 3e 0a			ld a, 10 
0618 cd c3 0c			call aDelayInMS 
061b 23				inc hl 
061c cd 6a 02				call se_writebyte 
061f 3e 0a			ld a, 10 
0621 cd c3 0c			call aDelayInMS 
0624 2b				dec hl 
0625 c1					pop bc 
0626 e1					pop hl 
0627 3e 40				ld a, STORE_BLOCK_PHY 
0629 cd cf 0f				call addatohl 
062c 10 e1				djnz .setmark2 
062e			 
062e					 
062e			 
062e			 
062e c9				ret 
062f			 
062f			 
062f			 
062f			 
062f .. 00		.defaultbanklabl:   db "BankLabel_",0 
063a			 
063a			 
063a			 
063a			; Label Bank 
063a			; ---------- 
063a			; 
063a			; With current bank 
063a			; Read block 0 
063a			; Set label 
063a			; Write block 0 
063a			 
063a			; label str pointer in hl 
063a			 
063a			storage_label:     
063a			 
063a				if DEBUG_STORESE 
063a					DMARK "LBL" 
063a f5				push af  
063b 3a 4f 06			ld a, (.dmark)  
063e 32 a6 fd			ld (debug_mark),a  
0641 3a 50 06			ld a, (.dmark+1)  
0644 32 a7 fd			ld (debug_mark+1),a  
0647 3a 51 06			ld a, (.dmark+2)  
064a 32 a8 fd			ld (debug_mark+2),a  
064d 18 03			jr .pastdmark  
064f ..			.dmark: db "LBL"  
0652 f1			.pastdmark: pop af  
0653			endm  
# End of macro DMARK
0653					CALLMONITOR 
0653 cd aa fd			call debug_vector  
0656				endm  
# End of macro CALLMONITOR
0656				endif 
0656			 
0656 e5				push hl 
0657			 
0657 cd 16 05			call storage_get_block_0 
065a			 
065a				; set default label 
065a			 
065a e1				pop hl 
065b			 
065b 11 b8 f9		 	ld de, store_page+3 
065e 01 0f 00			ld bc, 15 
0661				if DEBUG_STORESE 
0661					DMARK "LB3" 
0661 f5				push af  
0662 3a 76 06			ld a, (.dmark)  
0665 32 a6 fd			ld (debug_mark),a  
0668 3a 77 06			ld a, (.dmark+1)  
066b 32 a7 fd			ld (debug_mark+1),a  
066e 3a 78 06			ld a, (.dmark+2)  
0671 32 a8 fd			ld (debug_mark+2),a  
0674 18 03			jr .pastdmark  
0676 ..			.dmark: db "LB3"  
0679 f1			.pastdmark: pop af  
067a			endm  
# End of macro DMARK
067a					CALLMONITOR 
067a cd aa fd			call debug_vector  
067d				endm  
# End of macro CALLMONITOR
067d				endif 
067d ed b0			ldir 
067f				; save default page 0 
067f			 
067f 21 00 00			ld hl, 0 
0682 11 b5 f9			ld de, store_page 
0685				if DEBUG_STORESE 
0685					DMARK "LBW" 
0685 f5				push af  
0686 3a 9a 06			ld a, (.dmark)  
0689 32 a6 fd			ld (debug_mark),a  
068c 3a 9b 06			ld a, (.dmark+1)  
068f 32 a7 fd			ld (debug_mark+1),a  
0692 3a 9c 06			ld a, (.dmark+2)  
0695 32 a8 fd			ld (debug_mark+2),a  
0698 18 03			jr .pastdmark  
069a ..			.dmark: db "LBW"  
069d f1			.pastdmark: pop af  
069e			endm  
# End of macro DMARK
069e					CALLMONITOR 
069e cd aa fd			call debug_vector  
06a1				endm  
# End of macro CALLMONITOR
06a1				endif 
06a1 cd ca 04			call storage_write_block 
06a4			 
06a4 c9				ret 
06a5			 
06a5			 
06a5			 
06a5			; Read Block 0 - Config 
06a5			; --------------------- 
06a5			; 
06a5			; With current bank 
06a5			; Call presence test 
06a5			;    If not present format/init bank  
06a5			; Read block 0  
06a5			;  
06a5			 
06a5			 
06a5			; Dir 
06a5			; --- 
06a5			; 
06a5			; With current bank 
06a5			; Load Block 0 Config 
06a5			; Get max file id number 
06a5			; For each logical block 
06a5			;    Read block read byte 2 
06a5			;      if first block of file 
06a5			;         Display file name 
06a5			;         Display type flags for file 
06a5			;        
06a5			 
06a5			; moving to words as this requires stack control 
06a5			 
06a5			 
06a5			; Delete File 
06a5			; ----------- 
06a5			; 
06a5			; With current bank 
06a5			; 
06a5			; Load Block 0 Config 
06a5			; Get max file id number 
06a5			; For each logical block 
06a5			;    Read block file id 
06a5			;      If first block of file and dont have file id 
06a5			;         if file to delete 
06a5			;         Save file id 
06a5			;         Null file id 
06a5			;         Write this block back 
06a5			;      If file id is one saved 
06a5			;         Null file id 
06a5			;         Write this block back 
06a5			 
06a5			 
06a5			.se_done: 
06a5 e1				pop hl 
06a6 c9				ret 
06a7			 
06a7			storage_erase: 
06a7			 
06a7				; hl contains the file id 
06a7			 
06a7 5d				ld e, l 
06a8 16 00			ld d, 0 
06aa 21 40 00			ld hl, STORE_BLOCK_PHY 
06ad					if DEBUG_FORTH_WORDS 
06ad						DMARK "ERA" 
06ad f5				push af  
06ae 3a c2 06			ld a, (.dmark)  
06b1 32 a6 fd			ld (debug_mark),a  
06b4 3a c3 06			ld a, (.dmark+1)  
06b7 32 a7 fd			ld (debug_mark+1),a  
06ba 3a c4 06			ld a, (.dmark+2)  
06bd 32 a8 fd			ld (debug_mark+2),a  
06c0 18 03			jr .pastdmark  
06c2 ..			.dmark: db "ERA"  
06c5 f1			.pastdmark: pop af  
06c6			endm  
# End of macro DMARK
06c6						CALLMONITOR 
06c6 cd aa fd			call debug_vector  
06c9				endm  
# End of macro CALLMONITOR
06c9					endif 
06c9 cd 98 07			call storage_findnextid 
06cc cd f8 0f			call ishlzero 
06cf c8				ret z 
06d0			 
06d0 e5				push hl 
06d1			 
06d1				; TODO check file not found 
06d1			 
06d1 11 b5 f9			ld de, store_page 
06d4 cd 65 04			call storage_read_block 
06d7			 
06d7 cd f8 0f			call ishlzero 
06da ca a5 06			jp z,.se_done 
06dd			 
06dd					if DEBUG_FORTH_WORDS 
06dd						DMARK "ER1" 
06dd f5				push af  
06de 3a f2 06			ld a, (.dmark)  
06e1 32 a6 fd			ld (debug_mark),a  
06e4 3a f3 06			ld a, (.dmark+1)  
06e7 32 a7 fd			ld (debug_mark+1),a  
06ea 3a f4 06			ld a, (.dmark+2)  
06ed 32 a8 fd			ld (debug_mark+2),a  
06f0 18 03			jr .pastdmark  
06f2 ..			.dmark: db "ER1"  
06f5 f1			.pastdmark: pop af  
06f6			endm  
# End of macro DMARK
06f6						CALLMONITOR 
06f6 cd aa fd			call debug_vector  
06f9				endm  
# End of macro CALLMONITOR
06f9					endif 
06f9 3a b5 f9			ld a, (store_page)	; get file id 
06fc 32 a9 f9			ld (store_tmpid), a 
06ff			 
06ff 3a b7 f9			ld a, (store_page+2)    ; get count of extends 
0702 32 a8 f9			ld (store_tmpext), a 
0705			 
0705				; wipe file header 
0705			 
0705 e1				pop hl 
0706 3e 00			ld a, 0 
0708 32 b5 f9			ld (store_page), a 
070b 32 b6 f9			ld (store_page+1),a 
070e 11 b5 f9			ld de, store_page 
0711					if DEBUG_FORTH_WORDS 
0711						DMARK "ER2" 
0711 f5				push af  
0712 3a 26 07			ld a, (.dmark)  
0715 32 a6 fd			ld (debug_mark),a  
0718 3a 27 07			ld a, (.dmark+1)  
071b 32 a7 fd			ld (debug_mark+1),a  
071e 3a 28 07			ld a, (.dmark+2)  
0721 32 a8 fd			ld (debug_mark+2),a  
0724 18 03			jr .pastdmark  
0726 ..			.dmark: db "ER2"  
0729 f1			.pastdmark: pop af  
072a			endm  
# End of macro DMARK
072a						CALLMONITOR 
072a cd aa fd			call debug_vector  
072d				endm  
# End of macro CALLMONITOR
072d					endif 
072d cd ca 04			call storage_write_block 
0730			 
0730			 
0730				; wipe file extents 
0730			 
0730 3a a8 f9			ld a, (store_tmpext) 
0733 47				ld b, a 
0734			 
0734			.eraext:	  
0734 c5				push bc 
0735			 
0735 21 40 00			ld hl, STORE_BLOCK_PHY 
0738 3a a9 f9			ld a,(store_tmpid) 
073b 5f				ld e, a 
073c 50				ld d, b	 
073d					if DEBUG_FORTH_WORDS 
073d						DMARK "ER3" 
073d f5				push af  
073e 3a 52 07			ld a, (.dmark)  
0741 32 a6 fd			ld (debug_mark),a  
0744 3a 53 07			ld a, (.dmark+1)  
0747 32 a7 fd			ld (debug_mark+1),a  
074a 3a 54 07			ld a, (.dmark+2)  
074d 32 a8 fd			ld (debug_mark+2),a  
0750 18 03			jr .pastdmark  
0752 ..			.dmark: db "ER3"  
0755 f1			.pastdmark: pop af  
0756			endm  
# End of macro DMARK
0756						CALLMONITOR 
0756 cd aa fd			call debug_vector  
0759				endm  
# End of macro CALLMONITOR
0759					endif 
0759 cd 98 07			call storage_findnextid 
075c cd f8 0f			call ishlzero 
075f ca a5 06			jp z,.se_done 
0762			 
0762 e5				push hl 
0763 11 b5 f9			ld de, store_page 
0766 cd 65 04			call storage_read_block 
0769			 
0769				; free block	 
0769			 
0769 3e 00			ld a, 0 
076b 32 b5 f9			ld (store_page), a 
076e 32 b6 f9			ld (store_page+1),a 
0771 11 b5 f9			ld de, store_page 
0774 e1				pop hl 
0775					if DEBUG_FORTH_WORDS 
0775						DMARK "ER4" 
0775 f5				push af  
0776 3a 8a 07			ld a, (.dmark)  
0779 32 a6 fd			ld (debug_mark),a  
077c 3a 8b 07			ld a, (.dmark+1)  
077f 32 a7 fd			ld (debug_mark+1),a  
0782 3a 8c 07			ld a, (.dmark+2)  
0785 32 a8 fd			ld (debug_mark+2),a  
0788 18 03			jr .pastdmark  
078a ..			.dmark: db "ER4"  
078d f1			.pastdmark: pop af  
078e			endm  
# End of macro DMARK
078e						CALLMONITOR 
078e cd aa fd			call debug_vector  
0791				endm  
# End of macro CALLMONITOR
0791					endif 
0791 cd ca 04			call storage_write_block 
0794			 
0794 c1				pop bc 
0795 10 9d			djnz .eraext 
0797			 
0797 c9				ret 
0798			 
0798			 
0798			; Find Free Block 
0798			; --------------- 
0798			; 
0798			; With current bank 
0798			;  
0798			; From given starting logical block 
0798			;    Read block  
0798			;    If no file id 
0798			;         Return block id 
0798			 
0798			 
0798			; hl starting page number 
0798			; hl contains free page number or zero if no pages free 
0798			; e contains the file id to locate 
0798			; d contains the block number 
0798			 
0798			; TODO change to find file id and use zero for free block 
0798			 
0798			storage_findnextid: 
0798			 
0798				; now locate first 0 page to mark as a free block 
0798			 
0798 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
079a			;	ld hl, STORE_BLOCK_PHY 
079a			 
079a					if DEBUG_FORTH_WORDS 
079a					DMARK "FNI" 
079a f5				push af  
079b 3a af 07			ld a, (.dmark)  
079e 32 a6 fd			ld (debug_mark),a  
07a1 3a b0 07			ld a, (.dmark+1)  
07a4 32 a7 fd			ld (debug_mark+1),a  
07a7 3a b1 07			ld a, (.dmark+2)  
07aa 32 a8 fd			ld (debug_mark+2),a  
07ad 18 03			jr .pastdmark  
07af ..			.dmark: db "FNI"  
07b2 f1			.pastdmark: pop af  
07b3			endm  
# End of macro DMARK
07b3						CALLMONITOR 
07b3 cd aa fd			call debug_vector  
07b6				endm  
# End of macro CALLMONITOR
07b6					endif 
07b6			.ff1:   	 
07b6 e5					push hl 
07b7 c5					push bc 
07b8 d5					push de 
07b9 cd 0c 03				call se_readbyte 
07bc 5f					ld e,a 
07bd 23					inc hl 
07be cd 0c 03				call se_readbyte 
07c1 57					ld d, a 
07c2 e1					pop hl 
07c3 e5					push hl 
07c4 cd ed 0f				call cmp16 
07c7 28 49				jr z, .fffound 
07c9			 
07c9 d1					pop de 
07ca c1					pop bc 
07cb e1					pop hl 
07cc			 
07cc					; is found? 
07cc					;cp e 
07cc					;ret z 
07cc			 
07cc 3e 40				ld a, STORE_BLOCK_PHY 
07ce cd cf 0f				call addatohl 
07d1 10 e3				djnz .ff1 
07d3			 
07d3 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07d5			.ff2:   	 
07d5			 
07d5 e5					push hl 
07d6 c5					push bc 
07d7 d5					push de 
07d8 cd 0c 03				call se_readbyte 
07db 5f					ld e,a 
07dc 23					inc hl 
07dd cd 0c 03				call se_readbyte 
07e0 57					ld d, a 
07e1			 
07e1 e1					pop hl 
07e2 e5					push hl 
07e3 cd ed 0f				call cmp16 
07e6 28 2a				jr z, .fffound 
07e8			 
07e8 d1					pop de 
07e9 c1					pop bc 
07ea e1					pop hl 
07eb					; is found? 
07eb					;cp e 
07eb					;ret z 
07eb			 
07eb 3e 40				ld a, STORE_BLOCK_PHY 
07ed cd cf 0f				call addatohl 
07f0 10 e3				djnz .ff2 
07f2			 
07f2			 
07f2					if DEBUG_FORTH_WORDS 
07f2					DMARK "FN-" 
07f2 f5				push af  
07f3 3a 07 08			ld a, (.dmark)  
07f6 32 a6 fd			ld (debug_mark),a  
07f9 3a 08 08			ld a, (.dmark+1)  
07fc 32 a7 fd			ld (debug_mark+1),a  
07ff 3a 09 08			ld a, (.dmark+2)  
0802 32 a8 fd			ld (debug_mark+2),a  
0805 18 03			jr .pastdmark  
0807 ..			.dmark: db "FN-"  
080a f1			.pastdmark: pop af  
080b			endm  
# End of macro DMARK
080b					;	push af 
080b					;	ld a, 'n' 
080b					;	ld (debug_mark),a 
080b					;	pop af 
080b						CALLMONITOR 
080b cd aa fd			call debug_vector  
080e				endm  
# End of macro CALLMONITOR
080e					endif 
080e				; no free marks! 
080e 21 00 00				ld hl, 0 
0811 c9				ret 
0812			.fffound: 
0812				 
0812			 
0812 d1					pop de 
0813 c1					pop bc 
0814 e1					pop hl 
0815					if DEBUG_FORTH_WORDS 
0815					DMARK "FNF" 
0815 f5				push af  
0816 3a 2a 08			ld a, (.dmark)  
0819 32 a6 fd			ld (debug_mark),a  
081c 3a 2b 08			ld a, (.dmark+1)  
081f 32 a7 fd			ld (debug_mark+1),a  
0822 3a 2c 08			ld a, (.dmark+2)  
0825 32 a8 fd			ld (debug_mark+2),a  
0828 18 03			jr .pastdmark  
082a ..			.dmark: db "FNF"  
082d f1			.pastdmark: pop af  
082e			endm  
# End of macro DMARK
082e					;	push af 
082e					;	ld a, 'n' 
082e					;	ld (debug_mark),a 
082e					;	pop af 
082e						CALLMONITOR 
082e cd aa fd			call debug_vector  
0831				endm  
# End of macro CALLMONITOR
0831					endif 
0831 c9				ret 
0832			 
0832			 
0832			 
0832			; Free Space 
0832			; ---------- 
0832			; 
0832			; With current bank 
0832			; 
0832			; Set block count to zero 
0832			; Starting with first logical block 
0832			;      Find free block  
0832			;      If block id given, increment block count 
0832			; 
0832			;  
0832			 
0832			 
0832			; hl contains count of free blocks 
0832			 
0832			storage_freeblocks: 
0832			 
0832				; now locate first 0 page to mark as a free block 
0832			 
0832 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0834 21 40 00			ld hl, STORE_BLOCK_PHY 
0837 11 00 00			ld de, 0 
083a			 
083a			.fb1:   	 
083a e5					push hl 
083b c5					push bc 
083c d5					push de 
083d cd 0c 03				call se_readbyte 
0840 d1					pop de 
0841 c1					pop bc 
0842 e1					pop hl 
0843			 
0843					; is free? 
0843 fe 00				cp 0 
0845 20 01				jr nz, .ff1cont 
0847 13					inc de 
0848			 
0848			.ff1cont: 
0848			 
0848			 
0848 3e 40				ld a, STORE_BLOCK_PHY 
084a cd cf 0f				call addatohl 
084d 10 eb				djnz .fb1 
084f			 
084f 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0851			.fb2:   	 
0851 e5					push hl 
0852 c5					push bc 
0853 d5					push de 
0854 cd 0c 03				call se_readbyte 
0857 d1					pop de 
0858 c1					pop bc 
0859 e1					pop hl 
085a			 
085a					; is free? 
085a fe 00				cp 0 
085c 20 01				jr nz, .ff2cont 
085e 13					inc de 
085f			 
085f			.ff2cont: 
085f			 
085f 3e 40				ld a, STORE_BLOCK_PHY 
0861 cd cf 0f				call addatohl 
0864 10 eb				djnz .fb2 
0866			 
0866 eb				ex de, hl 
0867 c9				ret 
0868			 
0868			; Get File ID 
0868			; ----------- 
0868			; 
0868			; With current bank 
0868			;  
0868			; Load Block 0 Config 
0868			; Get max file id number 
0868			; For each logical block 
0868			;    Read block file id 
0868			;      If first block of file and dont have file id 
0868			;         if file get id and exit 
0868			 
0868			 
0868			 
0868			 
0868			; Create File 
0868			; ----------- 
0868			; 
0868			; With current bank  
0868			; Load Block 0 Config 
0868			; Get max file id number 
0868			; Increment file id number 
0868			; Save Config 
0868			; Find free block 
0868			; Set buffer with file name and file id 
0868			; Write buffer to free block  
0868			 
0868			 
0868			; hl point to file name 
0868			; hl returns file id 
0868			 
0868			; file format: 
0868			; byte 0 - file id 
0868			; byte 1 - extent number 
0868			; byte 2-> data 
0868			 
0868			; format for extent number 0: 
0868			; 
0868			; byte 0 - file id 
0868			; byte 1 - extent 0 
0868			; byte 2 - extent count 
0868			; byte 3 -> file name and meta data 
0868			 
0868			 
0868			storage_create: 
0868				if DEBUG_STORESE 
0868					DMARK "SCR" 
0868 f5				push af  
0869 3a 7d 08			ld a, (.dmark)  
086c 32 a6 fd			ld (debug_mark),a  
086f 3a 7e 08			ld a, (.dmark+1)  
0872 32 a7 fd			ld (debug_mark+1),a  
0875 3a 7f 08			ld a, (.dmark+2)  
0878 32 a8 fd			ld (debug_mark+2),a  
087b 18 03			jr .pastdmark  
087d ..			.dmark: db "SCR"  
0880 f1			.pastdmark: pop af  
0881			endm  
# End of macro DMARK
0881					CALLMONITOR 
0881 cd aa fd			call debug_vector  
0884				endm  
# End of macro CALLMONITOR
0884				endif 
0884			 
0884 e5				push hl		; save file name pointer 
0885			 
0885 cd 16 05			call storage_get_block_0 
0888			 
0888 3a b5 f9			ld a,(store_page)	; get current file id 
088b 3c				inc a 
088c 32 b5 f9			ld (store_page),a 
088f				 
088f 32 a9 f9			ld (store_tmpid),a			; save id 
0892			 
0892 21 00 00			ld hl, 0 
0895 11 b5 f9			ld de, store_page 
0898				if DEBUG_STORESE 
0898					DMARK "SCw" 
0898 f5				push af  
0899 3a ad 08			ld a, (.dmark)  
089c 32 a6 fd			ld (debug_mark),a  
089f 3a ae 08			ld a, (.dmark+1)  
08a2 32 a7 fd			ld (debug_mark+1),a  
08a5 3a af 08			ld a, (.dmark+2)  
08a8 32 a8 fd			ld (debug_mark+2),a  
08ab 18 03			jr .pastdmark  
08ad ..			.dmark: db "SCw"  
08b0 f1			.pastdmark: pop af  
08b1			endm  
# End of macro DMARK
08b1					CALLMONITOR 
08b1 cd aa fd			call debug_vector  
08b4				endm  
# End of macro CALLMONITOR
08b4				endif 
08b4 cd ca 04			call storage_write_block	 ; save update 
08b7			 
08b7				if DEBUG_STORESE 
08b7 11 b5 f9				ld de, store_page 
08ba					DMARK "SCC" 
08ba f5				push af  
08bb 3a cf 08			ld a, (.dmark)  
08be 32 a6 fd			ld (debug_mark),a  
08c1 3a d0 08			ld a, (.dmark+1)  
08c4 32 a7 fd			ld (debug_mark+1),a  
08c7 3a d1 08			ld a, (.dmark+2)  
08ca 32 a8 fd			ld (debug_mark+2),a  
08cd 18 03			jr .pastdmark  
08cf ..			.dmark: db "SCC"  
08d2 f1			.pastdmark: pop af  
08d3			endm  
# End of macro DMARK
08d3					CALLMONITOR 
08d3 cd aa fd			call debug_vector  
08d6				endm  
# End of macro CALLMONITOR
08d6				endif 
08d6				;  
08d6				 
08d6 21 40 00			ld hl, STORE_BLOCK_PHY 
08d9 11 00 00			ld de, 0 
08dc cd 98 07			call storage_findnextid 
08df			 
08df 22 a0 f9			ld (store_tmppageid), hl    ; save page to use  
08e2			 
08e2				; TODO detect 0 = no spare blocks 
08e2			 
08e2				; hl now contains the free page to use for the file header page 
08e2			 
08e2				if DEBUG_STORESE 
08e2				DMARK "SCF" 
08e2 f5				push af  
08e3 3a f7 08			ld a, (.dmark)  
08e6 32 a6 fd			ld (debug_mark),a  
08e9 3a f8 08			ld a, (.dmark+1)  
08ec 32 a7 fd			ld (debug_mark+1),a  
08ef 3a f9 08			ld a, (.dmark+2)  
08f2 32 a8 fd			ld (debug_mark+2),a  
08f5 18 03			jr .pastdmark  
08f7 ..			.dmark: db "SCF"  
08fa f1			.pastdmark: pop af  
08fb			endm  
# End of macro DMARK
08fb					CALLMONITOR 
08fb cd aa fd			call debug_vector  
08fe				endm  
# End of macro CALLMONITOR
08fe				endif 
08fe			 
08fe 22 a0 f9			ld (store_tmppageid), hl 
0901				 
0901 3a a9 f9			ld a,(store_tmpid)    ; get file id 
0904			;	ld a, (store_filecache)			; save to cache 
0904			 
0904 32 b5 f9			ld (store_page),a    ; set page id 
0907 3e 00			ld a, 0			 ; extent 0 is file header 
0909 32 b6 f9			ld (store_page+1), a   ; set file extent 
090c			 
090c 32 b7 f9			ld (store_page+2), a   ; extent count for the file 
090f			 
090f			;	inc hl 		; init block 0 of file 
090f			;	inc hl   		; skip file and extent id 
090f			 ;       ld a, 0 
090f			;	ld (hl),a 
090f			;	ld a, (store_filecache+1)  	; save to cache 
090f			 
090f			;	inc hl    ; file name 
090f				 
090f				 
090f 11 b8 f9			ld de, store_page+3    ; get buffer for term string to use as file name 
0912				if DEBUG_STORESE 
0912					DMARK "SCc" 
0912 f5				push af  
0913 3a 27 09			ld a, (.dmark)  
0916 32 a6 fd			ld (debug_mark),a  
0919 3a 28 09			ld a, (.dmark+1)  
091c 32 a7 fd			ld (debug_mark+1),a  
091f 3a 29 09			ld a, (.dmark+2)  
0922 32 a8 fd			ld (debug_mark+2),a  
0925 18 03			jr .pastdmark  
0927 ..			.dmark: db "SCc"  
092a f1			.pastdmark: pop af  
092b			endm  
# End of macro DMARK
092b					CALLMONITOR 
092b cd aa fd			call debug_vector  
092e				endm  
# End of macro CALLMONITOR
092e				endif 
092e e1				pop hl    ; get zero term string 
092f e5				push hl 
0930 3e 00			ld a, 0 
0932 cd 4d 13			call strlent 
0935 23				inc hl   ; cover zero term 
0936 06 00			ld b,0 
0938 4d				ld c,l 
0939 e1				pop hl 
093a				;ex de, hl 
093a				if DEBUG_STORESE 
093a					DMARK "SCa" 
093a f5				push af  
093b 3a 4f 09			ld a, (.dmark)  
093e 32 a6 fd			ld (debug_mark),a  
0941 3a 50 09			ld a, (.dmark+1)  
0944 32 a7 fd			ld (debug_mark+1),a  
0947 3a 51 09			ld a, (.dmark+2)  
094a 32 a8 fd			ld (debug_mark+2),a  
094d 18 03			jr .pastdmark  
094f ..			.dmark: db "SCa"  
0952 f1			.pastdmark: pop af  
0953			endm  
# End of macro DMARK
0953					;push af 
0953					;ld a, 'a' 
0953					;ld (debug_mark),a 
0953					;pop af 
0953					CALLMONITOR 
0953 cd aa fd			call debug_vector  
0956				endm  
# End of macro CALLMONITOR
0956				endif 
0956 ed b0			ldir    ; copy zero term string 
0958				if DEBUG_STORESE 
0958					DMARK "SCA" 
0958 f5				push af  
0959 3a 6d 09			ld a, (.dmark)  
095c 32 a6 fd			ld (debug_mark),a  
095f 3a 6e 09			ld a, (.dmark+1)  
0962 32 a7 fd			ld (debug_mark+1),a  
0965 3a 6f 09			ld a, (.dmark+2)  
0968 32 a8 fd			ld (debug_mark+2),a  
096b 18 03			jr .pastdmark  
096d ..			.dmark: db "SCA"  
0970 f1			.pastdmark: pop af  
0971			endm  
# End of macro DMARK
0971					CALLMONITOR 
0971 cd aa fd			call debug_vector  
0974				endm  
# End of macro CALLMONITOR
0974				endif 
0974			 
0974				; write file header page 
0974			 
0974 2a a0 f9			ld hl,(store_tmppageid) 
0977 11 b5 f9			ld de, store_page 
097a				if DEBUG_STORESE 
097a					DMARK "SCb" 
097a f5				push af  
097b 3a 8f 09			ld a, (.dmark)  
097e 32 a6 fd			ld (debug_mark),a  
0981 3a 90 09			ld a, (.dmark+1)  
0984 32 a7 fd			ld (debug_mark+1),a  
0987 3a 91 09			ld a, (.dmark+2)  
098a 32 a8 fd			ld (debug_mark+2),a  
098d 18 03			jr .pastdmark  
098f ..			.dmark: db "SCb"  
0992 f1			.pastdmark: pop af  
0993			endm  
# End of macro DMARK
0993					;push af 
0993					;ld a, 'b' 
0993					;ld (debug_mark),a 
0993					;pop af 
0993					CALLMONITOR 
0993 cd aa fd			call debug_vector  
0996				endm  
# End of macro CALLMONITOR
0996				endif 
0996 cd ca 04			call storage_write_block 
0999			 
0999 3a a9 f9			ld a, (store_tmpid) 
099c 6f				ld l, a 
099d 26 00			ld h,0 
099f				if DEBUG_STORESE 
099f					DMARK "SCz" 
099f f5				push af  
09a0 3a b4 09			ld a, (.dmark)  
09a3 32 a6 fd			ld (debug_mark),a  
09a6 3a b5 09			ld a, (.dmark+1)  
09a9 32 a7 fd			ld (debug_mark+1),a  
09ac 3a b6 09			ld a, (.dmark+2)  
09af 32 a8 fd			ld (debug_mark+2),a  
09b2 18 03			jr .pastdmark  
09b4 ..			.dmark: db "SCz"  
09b7 f1			.pastdmark: pop af  
09b8			endm  
# End of macro DMARK
09b8					CALLMONITOR 
09b8 cd aa fd			call debug_vector  
09bb				endm  
# End of macro CALLMONITOR
09bb				endif 
09bb c9				ret 
09bc				 
09bc			 
09bc			 
09bc			; 
09bc			; Read File 
09bc			; 
09bc			; h - file id to locate 
09bc			; l - extent to locate 
09bc			; de - pointer to string to read into 
09bc			; 
09bc			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09bc			 
09bc			.sr_fail: 
09bc d1				pop de 
09bd c9				ret 
09be			 
09be			storage_read: 
09be			 
09be			 
09be d5				push de 
09bf			 
09bf			; TODO BUG the above push is it popped before the RET Z? 
09bf			 
09bf			; TODO how to handle multiple part blocks 
09bf			 
09bf				; locate file extent to read 
09bf			 
09bf 5c				ld e, h 
09c0 55				ld d, l 
09c1			 
09c1			.srext: 
09c1 22 b3 f9			ld (store_readptr), hl     ; save the current extent to load 
09c4 ed 53 b1 f9		ld (store_readbuf), de     ; save the current buffer to load in to 
09c8			 
09c8 21 40 00			ld hl, STORE_BLOCK_PHY 
09cb				if DEBUG_STORESE 
09cb					DMARK "sre" 
09cb f5				push af  
09cc 3a e0 09			ld a, (.dmark)  
09cf 32 a6 fd			ld (debug_mark),a  
09d2 3a e1 09			ld a, (.dmark+1)  
09d5 32 a7 fd			ld (debug_mark+1),a  
09d8 3a e2 09			ld a, (.dmark+2)  
09db 32 a8 fd			ld (debug_mark+2),a  
09de 18 03			jr .pastdmark  
09e0 ..			.dmark: db "sre"  
09e3 f1			.pastdmark: pop af  
09e4			endm  
# End of macro DMARK
09e4					CALLMONITOR 
09e4 cd aa fd			call debug_vector  
09e7				endm  
# End of macro CALLMONITOR
09e7				endif 
09e7 cd 98 07			call storage_findnextid 
09ea			 
09ea				if DEBUG_STORESE 
09ea					DMARK "srf" 
09ea f5				push af  
09eb 3a ff 09			ld a, (.dmark)  
09ee 32 a6 fd			ld (debug_mark),a  
09f1 3a 00 0a			ld a, (.dmark+1)  
09f4 32 a7 fd			ld (debug_mark+1),a  
09f7 3a 01 0a			ld a, (.dmark+2)  
09fa 32 a8 fd			ld (debug_mark+2),a  
09fd 18 03			jr .pastdmark  
09ff ..			.dmark: db "srf"  
0a02 f1			.pastdmark: pop af  
0a03			endm  
# End of macro DMARK
0a03					CALLMONITOR 
0a03 cd aa fd			call debug_vector  
0a06				endm  
# End of macro CALLMONITOR
0a06				endif 
0a06 cd f8 0f			call ishlzero 
0a09			;	ld a, l 
0a09			;	add h 
0a09			;	cp 0 
0a09 28 b1			jr z,.sr_fail			; block not found so EOF 
0a0b			 
0a0b				; save current address for use by higher level words etc 
0a0b			 
0a0b 22 a6 f9			ld (store_openaddr),hl 
0a0e			 
0a0e			 
0a0e				; hl contains page number to load 
0a0e d1				pop de   ; get storage 
0a0f ed 53 b1 f9		ld (store_readbuf), de     ; current buffer to load in to 
0a13 d5				push de 
0a14				if DEBUG_STORESE 
0a14					DMARK "srg" 
0a14 f5				push af  
0a15 3a 29 0a			ld a, (.dmark)  
0a18 32 a6 fd			ld (debug_mark),a  
0a1b 3a 2a 0a			ld a, (.dmark+1)  
0a1e 32 a7 fd			ld (debug_mark+1),a  
0a21 3a 2b 0a			ld a, (.dmark+2)  
0a24 32 a8 fd			ld (debug_mark+2),a  
0a27 18 03			jr .pastdmark  
0a29 ..			.dmark: db "srg"  
0a2c f1			.pastdmark: pop af  
0a2d			endm  
# End of macro DMARK
0a2d					CALLMONITOR 
0a2d cd aa fd			call debug_vector  
0a30				endm  
# End of macro CALLMONITOR
0a30				endif 
0a30 cd 65 04			call storage_read_block 
0a33			 
0a33				; if this a continuation read??? 
0a33			 
0a33 2a b1 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a36			 
0a36 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a38 cd cf 0f			call addatohl 
0a3b 7e				ld a,(hl) 
0a3c fe 00			cp 0 
0a3e 28 02			jr z, .markiscont 
0a40 3e ff			ld a, 255 
0a42			 
0a42			.markiscont: 
0a42 32 a8 f9			ld (store_readcont), a 
0a45			 
0a45				if DEBUG_STORESE 
0a45					DMARK "srC" 
0a45 f5				push af  
0a46 3a 5a 0a			ld a, (.dmark)  
0a49 32 a6 fd			ld (debug_mark),a  
0a4c 3a 5b 0a			ld a, (.dmark+1)  
0a4f 32 a7 fd			ld (debug_mark+1),a  
0a52 3a 5c 0a			ld a, (.dmark+2)  
0a55 32 a8 fd			ld (debug_mark+2),a  
0a58 18 03			jr .pastdmark  
0a5a ..			.dmark: db "srC"  
0a5d f1			.pastdmark: pop af  
0a5e			endm  
# End of macro DMARK
0a5e					CALLMONITOR 
0a5e cd aa fd			call debug_vector  
0a61				endm  
# End of macro CALLMONITOR
0a61				endif 
0a61				; only short reads enabled 
0a61			 
0a61 3a b0 f9			ld a, (store_longread) 
0a64 fe 00			cp 0 
0a66 ca 33 0b			jp z, .readdone 
0a69			 
0a69			; TODO if block has no zeros then need to read next block  
0a69			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a69			; check last byte of physical block. 
0a69			; if not zero then the next block needs to be loaded 
0a69			 
0a69			 
0a69 2a b1 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a6c			 
0a6c 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a6e cd cf 0f			call addatohl 
0a71				;dec hl 
0a71 7e				ld a,(hl) 
0a72				if DEBUG_STORESE 
0a72					DMARK "sr?" 
0a72 f5				push af  
0a73 3a 87 0a			ld a, (.dmark)  
0a76 32 a6 fd			ld (debug_mark),a  
0a79 3a 88 0a			ld a, (.dmark+1)  
0a7c 32 a7 fd			ld (debug_mark+1),a  
0a7f 3a 89 0a			ld a, (.dmark+2)  
0a82 32 a8 fd			ld (debug_mark+2),a  
0a85 18 03			jr .pastdmark  
0a87 ..			.dmark: db "sr?"  
0a8a f1			.pastdmark: pop af  
0a8b			endm  
# End of macro DMARK
0a8b					CALLMONITOR 
0a8b cd aa fd			call debug_vector  
0a8e				endm  
# End of macro CALLMONITOR
0a8e				endif 
0a8e fe 00			cp 0 
0a90 ca 33 0b			jp z, .readdone 
0a93			 
0a93				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a93			 
0a93 23				inc hl 
0a94			 
0a94 22 b1 f9			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a97			 
0a97 ed 5b b3 f9		ld de, (store_readptr)     ; save the current extent to load 
0a9b			 
0a9b eb				ex de, hl 
0a9c			 
0a9c				; next ext 
0a9c			 
0a9c 23				inc hl 
0a9d 22 b3 f9			ld  (store_readptr), hl     ; save the current extent to load 
0aa0			 
0aa0				if DEBUG_STORESE 
0aa0					DMARK "sF2" 
0aa0 f5				push af  
0aa1 3a b5 0a			ld a, (.dmark)  
0aa4 32 a6 fd			ld (debug_mark),a  
0aa7 3a b6 0a			ld a, (.dmark+1)  
0aaa 32 a7 fd			ld (debug_mark+1),a  
0aad 3a b7 0a			ld a, (.dmark+2)  
0ab0 32 a8 fd			ld (debug_mark+2),a  
0ab3 18 03			jr .pastdmark  
0ab5 ..			.dmark: db "sF2"  
0ab8 f1			.pastdmark: pop af  
0ab9			endm  
# End of macro DMARK
0ab9					CALLMONITOR 
0ab9 cd aa fd			call debug_vector  
0abc				endm  
# End of macro CALLMONITOR
0abc				endif 
0abc			 
0abc				; get and load block 
0abc			 
0abc cd 98 07			call storage_findnextid 
0abf			 
0abf				if DEBUG_STORESE 
0abf					DMARK "sf2" 
0abf f5				push af  
0ac0 3a d4 0a			ld a, (.dmark)  
0ac3 32 a6 fd			ld (debug_mark),a  
0ac6 3a d5 0a			ld a, (.dmark+1)  
0ac9 32 a7 fd			ld (debug_mark+1),a  
0acc 3a d6 0a			ld a, (.dmark+2)  
0acf 32 a8 fd			ld (debug_mark+2),a  
0ad2 18 03			jr .pastdmark  
0ad4 ..			.dmark: db "sf2"  
0ad7 f1			.pastdmark: pop af  
0ad8			endm  
# End of macro DMARK
0ad8					CALLMONITOR 
0ad8 cd aa fd			call debug_vector  
0adb				endm  
# End of macro CALLMONITOR
0adb				endif 
0adb cd f8 0f			call ishlzero 
0ade			;	ld a, l 
0ade			;	add h 
0ade			;	cp 0 
0ade ca bc 09			jp z,.sr_fail			; block not found so EOF 
0ae1				 
0ae1				; save current address for use by higher level words etc 
0ae1			 
0ae1 22 a6 f9			ld (store_openaddr),hl 
0ae4			 
0ae4 cd 65 04			call storage_read_block 
0ae7			 
0ae7				; on a continuation block, we now have the file id and ext in the middle of the block 
0ae7				; we need to pull everything back  
0ae7			 
0ae7 ed 5b b1 f9		ld de, (store_readbuf)     ; current buffer to nudge into 
0aeb 2a b1 f9			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0aee 23				inc hl 
0aef 23				inc hl     ; skip id and ext 
0af0 01 40 00			ld bc, STORE_BLOCK_PHY 
0af3				if DEBUG_STORESE 
0af3					DMARK "SR<" 
0af3 f5				push af  
0af4 3a 08 0b			ld a, (.dmark)  
0af7 32 a6 fd			ld (debug_mark),a  
0afa 3a 09 0b			ld a, (.dmark+1)  
0afd 32 a7 fd			ld (debug_mark+1),a  
0b00 3a 0a 0b			ld a, (.dmark+2)  
0b03 32 a8 fd			ld (debug_mark+2),a  
0b06 18 03			jr .pastdmark  
0b08 ..			.dmark: db "SR<"  
0b0b f1			.pastdmark: pop af  
0b0c			endm  
# End of macro DMARK
0b0c					CALLMONITOR 
0b0c cd aa fd			call debug_vector  
0b0f				endm  
# End of macro CALLMONITOR
0b0f				endif 
0b0f ed b0			ldir     ; copy data 
0b11			 
0b11				; move the pointer back and pretend we have a full buffer for next recheck 
0b11			 
0b11 1b				dec de 
0b12 1b				dec de 
0b13			 
0b13			; TODO do pop below now short circuit loop????? 
0b13 c1				pop bc     ; get rid of spare de on stack 
0b14				if DEBUG_STORESE 
0b14					DMARK "SR>" 
0b14 f5				push af  
0b15 3a 29 0b			ld a, (.dmark)  
0b18 32 a6 fd			ld (debug_mark),a  
0b1b 3a 2a 0b			ld a, (.dmark+1)  
0b1e 32 a7 fd			ld (debug_mark+1),a  
0b21 3a 2b 0b			ld a, (.dmark+2)  
0b24 32 a8 fd			ld (debug_mark+2),a  
0b27 18 03			jr .pastdmark  
0b29 ..			.dmark: db "SR>"  
0b2c f1			.pastdmark: pop af  
0b2d			endm  
# End of macro DMARK
0b2d					CALLMONITOR 
0b2d cd aa fd			call debug_vector  
0b30				endm  
# End of macro CALLMONITOR
0b30				endif 
0b30 c3 c1 09			jp .srext 
0b33			 
0b33			 
0b33			 
0b33			 
0b33			 
0b33			.readdone:		 
0b33 e1				pop hl 		 ; return start of data to show as not EOF 
0b34 23				inc hl   ; past file id 
0b35 23				inc hl   ; past ext 
0b36				if DEBUG_STORESE 
0b36					DMARK "SRe" 
0b36 f5				push af  
0b37 3a 4b 0b			ld a, (.dmark)  
0b3a 32 a6 fd			ld (debug_mark),a  
0b3d 3a 4c 0b			ld a, (.dmark+1)  
0b40 32 a7 fd			ld (debug_mark+1),a  
0b43 3a 4d 0b			ld a, (.dmark+2)  
0b46 32 a8 fd			ld (debug_mark+2),a  
0b49 18 03			jr .pastdmark  
0b4b ..			.dmark: db "SRe"  
0b4e f1			.pastdmark: pop af  
0b4f			endm  
# End of macro DMARK
0b4f					CALLMONITOR 
0b4f cd aa fd			call debug_vector  
0b52				endm  
# End of macro CALLMONITOR
0b52				endif 
0b52 c9					ret 
0b53			 
0b53			 
0b53			 
0b53			; 
0b53			; Append File 
0b53			; 
0b53			; hl - file id to locate 
0b53			; de - pointer to (multi block) string to write 
0b53			 
0b53			.sa_notfound: 
0b53 d1				pop de 
0b54 c9				ret 
0b55			 
0b55			 
0b55			storage_append: 
0b55				; hl -  file id to append to 
0b55				; de - string to append 
0b55			 
0b55 d5				push de 
0b56				 
0b56				if DEBUG_STORESE 
0b56					DMARK "AP1" 
0b56 f5				push af  
0b57 3a 6b 0b			ld a, (.dmark)  
0b5a 32 a6 fd			ld (debug_mark),a  
0b5d 3a 6c 0b			ld a, (.dmark+1)  
0b60 32 a7 fd			ld (debug_mark+1),a  
0b63 3a 6d 0b			ld a, (.dmark+2)  
0b66 32 a8 fd			ld (debug_mark+2),a  
0b69 18 03			jr .pastdmark  
0b6b ..			.dmark: db "AP1"  
0b6e f1			.pastdmark: pop af  
0b6f			endm  
# End of macro DMARK
0b6f					CALLMONITOR 
0b6f cd aa fd			call debug_vector  
0b72				endm  
# End of macro CALLMONITOR
0b72				endif 
0b72			 
0b72 7d				ld a, l 
0b73 32 a9 f9			ld (store_tmpid), a 
0b76			 
0b76				; get file header  
0b76			 
0b76 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b78 3a a9 f9			ld a, (store_tmpid) 
0b7b 5f				ld e, a 
0b7c			 
0b7c 21 40 00				ld hl, STORE_BLOCK_PHY 
0b7f cd 98 07				call storage_findnextid 
0b82			 
0b82 cd f8 0f			call ishlzero 
0b85 28 cc			jr z, .sa_notfound 
0b87			 
0b87 22 a0 f9			ld (store_tmppageid), hl 
0b8a			 
0b8a				; TODO handle file id not found 
0b8a			 
0b8a				if DEBUG_STORESE 
0b8a					DMARK "AP2" 
0b8a f5				push af  
0b8b 3a 9f 0b			ld a, (.dmark)  
0b8e 32 a6 fd			ld (debug_mark),a  
0b91 3a a0 0b			ld a, (.dmark+1)  
0b94 32 a7 fd			ld (debug_mark+1),a  
0b97 3a a1 0b			ld a, (.dmark+2)  
0b9a 32 a8 fd			ld (debug_mark+2),a  
0b9d 18 03			jr .pastdmark  
0b9f ..			.dmark: db "AP2"  
0ba2 f1			.pastdmark: pop af  
0ba3			endm  
# End of macro DMARK
0ba3					CALLMONITOR 
0ba3 cd aa fd			call debug_vector  
0ba6				endm  
# End of macro CALLMONITOR
0ba6				endif 
0ba6			 
0ba6				; update file extent count 
0ba6			 
0ba6 11 b5 f9			ld de, store_page 
0ba9			 
0ba9 cd 65 04			call storage_read_block 
0bac			 
0bac				if DEBUG_STORESE 
0bac					DMARK "AP3" 
0bac f5				push af  
0bad 3a c1 0b			ld a, (.dmark)  
0bb0 32 a6 fd			ld (debug_mark),a  
0bb3 3a c2 0b			ld a, (.dmark+1)  
0bb6 32 a7 fd			ld (debug_mark+1),a  
0bb9 3a c3 0b			ld a, (.dmark+2)  
0bbc 32 a8 fd			ld (debug_mark+2),a  
0bbf 18 03			jr .pastdmark  
0bc1 ..			.dmark: db "AP3"  
0bc4 f1			.pastdmark: pop af  
0bc5			endm  
# End of macro DMARK
0bc5					CALLMONITOR 
0bc5 cd aa fd			call debug_vector  
0bc8				endm  
# End of macro CALLMONITOR
0bc8				endif 
0bc8			;	ld (store_tmppageid), hl 
0bc8			 
0bc8 3a b7 f9			ld a, (store_page+2) 
0bcb 3c				inc a 
0bcc 32 b7 f9			ld (store_page+2), a 
0bcf 32 a8 f9			ld (store_tmpext), a 
0bd2				 
0bd2				if DEBUG_STORESE 
0bd2					DMARK "AP3" 
0bd2 f5				push af  
0bd3 3a e7 0b			ld a, (.dmark)  
0bd6 32 a6 fd			ld (debug_mark),a  
0bd9 3a e8 0b			ld a, (.dmark+1)  
0bdc 32 a7 fd			ld (debug_mark+1),a  
0bdf 3a e9 0b			ld a, (.dmark+2)  
0be2 32 a8 fd			ld (debug_mark+2),a  
0be5 18 03			jr .pastdmark  
0be7 ..			.dmark: db "AP3"  
0bea f1			.pastdmark: pop af  
0beb			endm  
# End of macro DMARK
0beb					CALLMONITOR 
0beb cd aa fd			call debug_vector  
0bee				endm  
# End of macro CALLMONITOR
0bee				endif 
0bee 2a a0 f9			ld hl, (store_tmppageid) 
0bf1 11 b5 f9			ld de, store_page 
0bf4 cd ca 04			call storage_write_block 
0bf7			 
0bf7				; find free block 
0bf7			 
0bf7 11 00 00			ld de, 0			 ; file extent to locate 
0bfa			 
0bfa 21 40 00				ld hl, STORE_BLOCK_PHY 
0bfd cd 98 07				call storage_findnextid 
0c00 cd f8 0f			call ishlzero 
0c03 ca 53 0b			jp z, .sa_notfound 
0c06			 
0c06					; TODO handle no space left 
0c06					 
0c06 22 a0 f9				ld (store_tmppageid), hl 
0c09			 
0c09				if DEBUG_STORESE 
0c09					DMARK "AP4" 
0c09 f5				push af  
0c0a 3a 1e 0c			ld a, (.dmark)  
0c0d 32 a6 fd			ld (debug_mark),a  
0c10 3a 1f 0c			ld a, (.dmark+1)  
0c13 32 a7 fd			ld (debug_mark+1),a  
0c16 3a 20 0c			ld a, (.dmark+2)  
0c19 32 a8 fd			ld (debug_mark+2),a  
0c1c 18 03			jr .pastdmark  
0c1e ..			.dmark: db "AP4"  
0c21 f1			.pastdmark: pop af  
0c22			endm  
# End of macro DMARK
0c22					CALLMONITOR 
0c22 cd aa fd			call debug_vector  
0c25				endm  
# End of macro CALLMONITOR
0c25				endif 
0c25					; init the buffer with zeros so we can id if the buffer is full or not 
0c25			 
0c25 e5					push hl 
0c26 c5					push bc 
0c27			 
0c27 21 b5 f9				ld hl, store_page 
0c2a 06 40				ld b, STORE_BLOCK_PHY 
0c2c 3e 00				ld a, 0 
0c2e 77			.zeroblock:	ld (hl), a 
0c2f 23					inc hl 
0c30 10 fc				djnz .zeroblock 
0c32			 
0c32 c1					pop bc 
0c33 e1					pop hl 
0c34			 
0c34					; construct block 
0c34			 
0c34 3a a9 f9				ld a, (store_tmpid) 
0c37 32 b5 f9				ld (store_page), a   ; file id 
0c3a 3a a8 f9				ld a, (store_tmpext)   ; extent for this block 
0c3d 32 b6 f9				ld (store_page+1), a 
0c40			 
0c40 e1					pop hl    ; get string to write 
0c41 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c43 11 b7 f9				ld de, store_page+2 
0c46			 
0c46				if DEBUG_STORESE 
0c46					DMARK "AP5" 
0c46 f5				push af  
0c47 3a 5b 0c			ld a, (.dmark)  
0c4a 32 a6 fd			ld (debug_mark),a  
0c4d 3a 5c 0c			ld a, (.dmark+1)  
0c50 32 a7 fd			ld (debug_mark+1),a  
0c53 3a 5d 0c			ld a, (.dmark+2)  
0c56 32 a8 fd			ld (debug_mark+2),a  
0c59 18 03			jr .pastdmark  
0c5b ..			.dmark: db "AP5"  
0c5e f1			.pastdmark: pop af  
0c5f			endm  
# End of macro DMARK
0c5f					CALLMONITOR 
0c5f cd aa fd			call debug_vector  
0c62				endm  
# End of macro CALLMONITOR
0c62				endif 
0c62			 
0c62			 
0c62			 
0c62					; fill buffer with data until end of string or full block 
0c62			 
0c62 7e			.appd:		ld a, (hl) 
0c63 12					ld (de), a 
0c64 fe 00				cp 0 
0c66 28 04				jr z, .appdone 
0c68 23					inc hl 
0c69 13					inc de 
0c6a 10 f6				djnz .appd 
0c6c			 
0c6c e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c6d f5					push af   		; save last byte dumped 
0c6e			 
0c6e			 
0c6e 2a a0 f9			ld hl, (store_tmppageid) 
0c71 11 b5 f9			ld de, store_page 
0c74				if DEBUG_STORESE 
0c74					DMARK "AP6" 
0c74 f5				push af  
0c75 3a 89 0c			ld a, (.dmark)  
0c78 32 a6 fd			ld (debug_mark),a  
0c7b 3a 8a 0c			ld a, (.dmark+1)  
0c7e 32 a7 fd			ld (debug_mark+1),a  
0c81 3a 8b 0c			ld a, (.dmark+2)  
0c84 32 a8 fd			ld (debug_mark+2),a  
0c87 18 03			jr .pastdmark  
0c89 ..			.dmark: db "AP6"  
0c8c f1			.pastdmark: pop af  
0c8d			endm  
# End of macro DMARK
0c8d					CALLMONITOR 
0c8d cd aa fd			call debug_vector  
0c90				endm  
# End of macro CALLMONITOR
0c90				endif 
0c90 cd ca 04				call storage_write_block 
0c93			 
0c93			 
0c93				; was that a full block of data written? 
0c93				; any more to write out? 
0c93			 
0c93				; if yes then set vars and jump to start of function again 
0c93			 
0c93 f1					pop af 
0c94 d1					pop de 
0c95			 
0c95 fe 00				cp 0		 ; no, string was fully written 
0c97 c8					ret z 
0c98			 
0c98					; setup vars for next cycle 
0c98			 
0c98 3a a9 f9				ld a, (store_tmpid) 
0c9b 6f					ld l, a 
0c9c 26 00				ld h, 0 
0c9e			 
0c9e c3 55 0b			 	jp storage_append	 ; yes, need to write out some more 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			 
0ca1			if DEBUG_STORECF 
0ca1			storageput:	 
0ca1					ret 
0ca1			storageread: 
0ca1					ld hl, store_page 
0ca1					ld b, 200 
0ca1					ld a,0 
0ca1			.src:		ld (hl),a 
0ca1					inc hl 
0ca1					djnz .src 
0ca1					 
0ca1			 
0ca1					ld de, 0 
0ca1					ld bc, 1 
0ca1					ld hl, store_page 
0ca1					call cfRead 
0ca1			 
0ca1				call cfGetError 
0ca1				ld hl,scratch 
0ca1				call hexout 
0ca1				ld hl, scratch+2 
0ca1				ld a, 0 
0ca1				ld (hl),a 
0ca1				ld de, scratch 
0ca1				ld a,display_row_1 
0ca1				call str_at_display 
0ca1				call update_display 
0ca1			 
0ca1					ld hl, store_page 
0ca1					ld (os_cur_ptr),hl 
0ca1			 
0ca1					ret 
0ca1			endif 
0ca1			 
0ca1			 
0ca1			; Clear out the main buffer store (used to remove junk before writing a new block) 
0ca1			 
0ca1			storage_clear_page: 
0ca1 e5				push hl 
0ca2 d5				push de 
0ca3 c5				push bc 
0ca4 21 b5 f9			ld hl, store_page 
0ca7 3e 00			ld a, 0 
0ca9 77				ld (hl), a 
0caa			 
0caa 11 b6 f9			ld de, store_page+1 
0cad 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cb0			 
0cb0 ed b0			ldir 
0cb2				 
0cb2 c1				pop bc 
0cb3 d1				pop de 
0cb4 e1				pop hl 
0cb5 c9				ret 
0cb6			 
0cb6			; eof 
# End of file firmware_storage.asm
0cb6			  
0cb6			; support routines for above hardware abstraction layer  
0cb6			  
0cb6			include "firmware_general.asm"        ; general support functions  
0cb6			 
0cb6			; word look up 
0cb6			 
0cb6			; in 
0cb6			; a is the index 
0cb6			; hl is pointer start of array 
0cb6			; 
0cb6			; returns 
0cb6			; hl to the word 
0cb6			; 
0cb6			 
0cb6			table_lookup:  
0cb6 d5					push de 
0cb7 eb					ex de, hl 
0cb8			 
0cb8 6f					ld l, a 
0cb9 26 00				ld h, 0 
0cbb 29					add hl, hl 
0cbc 19					add hl, de 
0cbd 7e					ld a, (hl) 
0cbe 23					inc hl 
0cbf 66					ld h,(hl) 
0cc0 6f					ld l, a 
0cc1			 
0cc1 d1					pop de 
0cc2 c9					ret 
0cc3			 
0cc3			; Delay loops 
0cc3			 
0cc3			 
0cc3			 
0cc3			aDelayInMS: 
0cc3 c5				push bc 
0cc4 47				ld b,a 
0cc5			msdelay: 
0cc5 c5				push bc 
0cc6				 
0cc6			 
0cc6 01 41 00			ld bc,041h 
0cc9 cd e1 0c			call delayloop 
0ccc c1				pop bc 
0ccd 05				dec b 
0cce 20 f5			jr nz,msdelay 
0cd0			 
0cd0			;if CPU_CLOCK_8MHZ 
0cd0			;msdelay8: 
0cd0			;	push bc 
0cd0			;	 
0cd0			; 
0cd0			;	ld bc,041h 
0cd0			;	call delayloop 
0cd0			;	pop bc 
0cd0			;	dec b 
0cd0			;	jr nz,msdelay8 
0cd0			;endif 
0cd0			 
0cd0			 
0cd0 c1				pop bc 
0cd1 c9				ret 
0cd2			 
0cd2			 
0cd2			delay250ms: 
0cd2				;push de 
0cd2 01 00 40			ld bc, 04000h 
0cd5 c3 e1 0c			jp delayloop 
0cd8			delay500ms: 
0cd8				;push de 
0cd8 01 00 80			ld bc, 08000h 
0cdb c3 e1 0c			jp delayloop 
0cde			delay1s: 
0cde				;push bc 
0cde			   ; Clobbers A, d and e 
0cde 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0ce1			delayloop: 
0ce1 c5			    push bc 
0ce2			 
0ce2			if BASE_CPM 
0ce2				ld bc, CPM_DELAY_TUNE 
0ce2			.cpmloop: 
0ce2				push bc 
0ce2			 
0ce2			endif 
0ce2			 
0ce2			 
0ce2			 
0ce2			delayloopi: 
0ce2			;	push bc 
0ce2			;.dl: 
0ce2 cb 47		    bit     0,a    	; 8 
0ce4 cb 47		    bit     0,a    	; 8 
0ce6 cb 47		    bit     0,a    	; 8 
0ce8 e6 ff		    and     255  	; 7 
0cea 0b			    dec     bc      	; 6 
0ceb 79			    ld      a,c     	; 4 
0cec b0			    or      b     	; 4 
0ced c2 e2 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cf0			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cf0				;pop de 
0cf0			;pop bc 
0cf0			 
0cf0			if BASE_CPM 
0cf0				pop bc 
0cf0				 
0cf0			    dec     bc      	; 6 
0cf0			    ld      a,c     	; 4 
0cf0			    or      b     	; 4 
0cf0			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cf0				 
0cf0			 
0cf0			endif 
0cf0			;if CPU_CLOCK_8MHZ 
0cf0			;    pop bc 
0cf0			;    push bc 
0cf0			;.dl8: 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    and     255  	; 7 
0cf0			;    dec     bc      	; 6 
0cf0			;    ld      a,c     	; 4 
0cf0			;    or      b     	; 4 
0cf0			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf0			;endif 
0cf0			 
0cf0			;if CPU_CLOCK_10MHZ 
0cf0			;    pop bc 
0cf0			;    push bc 
0cf0			;.dl8: 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    bit     0,a    	; 8 
0cf0			;    and     255  	; 7 
0cf0			;    dec     bc      	; 6 
0cf0			;    ld      a,c     	; 4 
0cf0			;    or      b     	; 4 
0cf0			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cf0			;endif 
0cf0 c1			    pop bc 
0cf1			 
0cf1 c9				ret 
0cf2			 
0cf2			 
0cf2			 
0cf2			; eof 
# End of file firmware_general.asm
0cf2			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0cf2			; display routines that use the physical hardware abstraction layer 
0cf2			 
0cf2			 
0cf2			; Display an activity indicator 
0cf2			; Each call returns the new char pointed to in hl 
0cf2			 
0cf2			active: 
0cf2 3a 01 fb			ld a, (display_active) 
0cf5 fe 06			cp 6 
0cf7			 
0cf7 20 02			jr nz, .sne 
0cf9				; gone past the last one reset sequence 
0cf9 3e ff			ld a, 255 
0cfb			 
0cfb			.sne:   
0cfb				; get the next char in seq 
0cfb 3c				inc a 
0cfc 32 01 fb			ld (display_active), a 
0cff			 
0cff				; look up the string in the table 
0cff 21 16 0d			ld hl, actseq 
0d02 cb 27			sla a 
0d04 cd cf 0f			call addatohl 
0d07 cd 47 23			call loadwordinhl 
0d0a			 
0d0a				; forth will write the to string when pushing so move from rom to ram 
0d0a			 
0d0a 11 02 fb			ld de, display_active+1 
0d0d 01 02 00			ld bc, 2 
0d10 ed b0			ldir 
0d12			 
0d12 21 02 fb			ld hl, display_active+1 
0d15 c9				ret 
0d16				 
0d16				 
0d16			 
0d16			 
0d16			;db "|/-\|-\" 
0d16			 
0d16			actseq: 
0d16			 
0d16 24 0d		dw spin0 
0d18 26 0d		dw spin1 
0d1a 28 0d		dw spin2 
0d1c 2a 0d		dw spin3 
0d1e 28 0d		dw spin2 
0d20 26 0d		dw spin1 
0d22 24 0d		dw spin0 
0d24			 
0d24 .. 00		spin0: db " ", 0 
0d26 .. 00		spin1: db "-", 0 
0d28 .. 00		spin2: db "+", 0 
0d2a .. 00		spin3: db "#", 0 
0d2c			 
0d2c			 
0d2c			; information window 
0d2c			 
0d2c			; pass hl with 1st string to display 
0d2c			; pass de with 2nd string to display 
0d2c			 
0d2c			info_panel: 
0d2c e5				push hl 
0d2d			 
0d2d 2a 07 fb			ld hl, (display_fb_active) 
0d30 e5				push hl    ; future de destination 
0d31 21 ec fc				ld hl, display_fb0 
0d34 22 07 fb				ld (display_fb_active), hl 
0d37			 
0d37			;	call clear_display 
0d37			 
0d37				if BASE_CPM 
0d37				ld a, '.' 
0d37				else 
0d37 3e a5			ld a, 165 
0d39				endif 
0d39 cd a0 0d			call fill_display 
0d3c			 
0d3c			 
0d3c 3e 55			ld a, display_row_3 + 5 
0d3e cd ae 0d			call str_at_display 
0d41			 
0d41 e1				pop hl 
0d42 d1				pop de 
0d43			 
0d43 e5				push hl 
0d44			 
0d44			 
0d44 3e 2d			ld a, display_row_2 + 5 
0d46 cd ae 0d			call str_at_display 
0d49			 
0d49			 
0d49 cd be 0d			call update_display 
0d4c cd 90 1f			call next_page_prompt 
0d4f cd 9b 0d			call clear_display 
0d52			 
0d52				 
0d52 21 4b fc				ld hl, display_fb1 
0d55 22 07 fb				ld (display_fb_active), hl 
0d58 cd be 0d			call update_display 
0d5b			 
0d5b e1				pop hl 
0d5c			 
0d5c c9				ret 
0d5d			 
0d5d			 
0d5d			 
0d5d			 
0d5d			; TODO windowing? 
0d5d			 
0d5d			; TODO scroll line up 
0d5d			 
0d5d			scroll_up: 
0d5d			 
0d5d e5				push hl 
0d5e d5				push de 
0d5f c5				push bc 
0d60			 
0d60				; get frame buffer  
0d60			 
0d60 2a 07 fb			ld hl, (display_fb_active) 
0d63 e5				push hl    ; future de destination 
0d64			 
0d64 11 28 00			ld  de, display_cols 
0d67 19				add hl, de 
0d68			 
0d68 d1				pop de 
0d69			 
0d69				;ex de, hl 
0d69 01 9f 00			ld bc, display_fb_len -1  
0d6c			;if DEBUG_FORTH_WORDS 
0d6c			;	DMARK "SCL" 
0d6c			;	CALLMONITOR 
0d6c			;endif	 
0d6c ed b0			ldir 
0d6e			 
0d6e				; wipe bottom row 
0d6e			 
0d6e			 
0d6e 2a 07 fb			ld hl, (display_fb_active) 
0d71 11 a0 00			ld de, display_cols*display_rows 
0d74 19				add hl, de 
0d75 06 28			ld b, display_cols 
0d77 3e 20			ld a, ' ' 
0d79			.scwipe: 
0d79 77				ld (hl), a 
0d7a 2b				dec hl 
0d7b 10 fc			djnz .scwipe 
0d7d			 
0d7d				;pop hl 
0d7d			 
0d7d c1				pop bc 
0d7e d1				pop de 
0d7f e1				pop hl 
0d80			 
0d80 c9				ret 
0d81			 
0d81			 
0d81			;scroll_upo: 
0d81			;	ld de, display_row_1 
0d81			 ;	ld hl, display_row_2 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			;	ld de, display_row_2 
0d81			 ;	ld hl, display_row_3 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			;	ld de, display_row_3 
0d81			 ;	ld hl, display_row_4 
0d81			;	ld bc, display_cols 
0d81			;	ldir 
0d81			 
0d81			; TODO clear row 4 
0d81			 
0d81			;	ret 
0d81			 
0d81				 
0d81			scroll_down: 
0d81			 
0d81 e5				push hl 
0d82 d5				push de 
0d83 c5				push bc 
0d84			 
0d84				; get frame buffer  
0d84			 
0d84 2a 07 fb			ld hl, (display_fb_active) 
0d87			 
0d87 11 9f 00			ld de, display_fb_len - 1 
0d8a 19				add hl, de 
0d8b			 
0d8b e5			push hl    ; future de destination 
0d8c			 
0d8c 11 28 00			ld  de, display_cols 
0d8f ed 52			sbc hl, de 
0d91			 
0d91			 
0d91 d1				pop de 
0d92			 
0d92			;	ex de, hl 
0d92 01 9f 00			ld bc, display_fb_len -1  
0d95			 
0d95			 
0d95				 
0d95			 
0d95 ed b0			ldir 
0d97			 
0d97				; wipe bottom row 
0d97			 
0d97			 
0d97			;	ld hl, (display_fb_active) 
0d97			;;	ld de, display_cols*display_rows 
0d97			;;	add hl, de 
0d97			;	ld b, display_cols 
0d97			;	ld a, ' ' 
0d97			;.scwiped: 
0d97			;	ld (hl), a 
0d97			;	dec hl 
0d97			;	djnz .scwiped 
0d97			 
0d97				;pop hl 
0d97			 
0d97 c1				pop bc 
0d98 d1				pop de 
0d99 e1				pop hl 
0d9a			 
0d9a c9				ret 
0d9b			;scroll_down: 
0d9b			;	ld de, display_row_4 
0d9b			;	ld hl, display_row_3 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;	ld de, display_row_3 
0d9b			; 	ld hl, display_row_2 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;	ld de, display_row_2 
0d9b			;	ld hl, display_row_1 
0d9b			;	ld bc, display_cols 
0d9b			;	ldir 
0d9b			;;; TODO clear row 1 
0d9b			;	ret 
0d9b			 
0d9b			 
0d9b			 
0d9b			 
0d9b			 
0d9b			; clear active frame buffer 
0d9b			 
0d9b			clear_display: 
0d9b 3e 20			ld a, ' ' 
0d9d c3 a0 0d			jp fill_display 
0da0			 
0da0			; fill active frame buffer with a char in A 
0da0			 
0da0			fill_display: 
0da0 06 a0			ld b,display_fb_len 
0da2 2a 07 fb			ld hl, (display_fb_active) 
0da5 77			.fd1:	ld (hl),a 
0da6 23				inc hl 
0da7 10 fc			djnz .fd1 
0da9 23				inc hl 
0daa 3e 00			ld a,0 
0dac 77				ld (hl),a 
0dad			 
0dad			 
0dad c9				ret 
0dae			; Write string (DE) at pos (A) to active frame buffer 
0dae			 
0dae 2a 07 fb		str_at_display:    ld hl,(display_fb_active) 
0db1 06 00					ld b,0 
0db3 4f					ld c,a 
0db4 09					add hl,bc 
0db5 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0db6 b7			            OR   A              ;Null terminator? 
0db7 c8			            RET  Z              ;Yes, so finished 
0db8 77					ld (hl),a 
0db9 23				inc hl 
0dba 13			            INC  DE             ;Point to next character 
0dbb 18 f8		            JR   .sad1     ;Repeat 
0dbd c9					ret 
0dbe			 
0dbe			; using current frame buffer write to physical display 
0dbe			 
0dbe			update_display: 
0dbe e5				push hl 
0dbf 2a 07 fb			ld hl, (display_fb_active) 
0dc2 cd 47 76			call write_display 
0dc5 e1				pop hl 
0dc6 c9				ret 
0dc7			 
0dc7			; TODO scrolling 
0dc7			 
0dc7			 
0dc7			; move cursor right one char 
0dc7			cursor_right: 
0dc7			 
0dc7				; TODO shift right 
0dc7				; TODO if beyond max col 
0dc7				; TODO       cursor_next_line 
0dc7			 
0dc7 c9				ret 
0dc8			 
0dc8			 
0dc8			cursor_next_line: 
0dc8				; TODO first char 
0dc8				; TODO line down 
0dc8				; TODO if past last row 
0dc8				; TODO    scroll up 
0dc8			 
0dc8 c9				ret 
0dc9			 
0dc9			cursor_left: 
0dc9				; TODO shift left 
0dc9				; TODO if beyond left  
0dc9				; TODO     cursor prev line 
0dc9				 
0dc9 c9				ret 
0dca			 
0dca			cursor_prev_line: 
0dca				; TODO last char 
0dca				; TODO line up 
0dca				; TODO if past first row 
0dca				; TODO   scroll down 
0dca			 
0dca c9				ret 
0dcb			 
0dcb			 
0dcb			cout: 
0dcb				; A - char 
0dcb c9				ret 
0dcc			 
0dcc			 
0dcc			; Display a menu and allow item selection (optional toggle items) 
0dcc			; 
0dcc			; format: 
0dcc			; hl pointer to word array with zero term for items 
0dcc			; e.g.    db item1 
0dcc			;         db .... 
0dcc			;         db 0 
0dcc			; 
0dcc			; a = starting menu item  
0dcc			; 
0dcc			; de = pointer item toggle array   (todo) 
0dcc			; 
0dcc			; returns item selected in a 1-... 
0dcc			; returns 0 if back button pressed 
0dcc			; 
0dcc			; NOTE: Uses system frame buffer to display 
0dcc			; 
0dcc			; LEFT, Q = go back 
0dcc			; RIGHT, SPACE, CR = select 
0dcc			; UP, A - Up 
0dcc			; DOWN, Z - Down 
0dcc			 
0dcc			 
0dcc			 
0dcc			 
0dcc			 
0dcc			menu: 
0dcc			 
0dcc					; keep array pointer 
0dcc			 
0dcc 22 ae f9				ld (store_tmp1), hl 
0dcf 32 ac f9				ld (store_tmp2), a 
0dd2			 
0dd2					; check for key bounce 
0dd2			 
0dd2			if BASE_KEV 
0dd2			 
0dd2 cd 92 79		.mbounce:	call cin 
0dd5 fe 00				cp 0 
0dd7 20 f9				jr nz, .mbounce 
0dd9			endif 
0dd9					; for ease use ex 
0dd9			 
0dd9					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0dd9 21 ec fc				ld hl, display_fb0 
0ddc 22 07 fb				ld (display_fb_active), hl 
0ddf			 
0ddf cd 9b 0d		.mloop:		call clear_display 
0de2 cd be 0d				call update_display 
0de5			 
0de5					; draw selection id '>' at 1 
0de5			 
0de5					; init start of list display 
0de5			 
0de5 3e 05				ld a, 5 
0de7 32 aa f9				ld (store_tmp3), a   ; display row count 
0dea 3a ac f9				ld a,( store_tmp2) 
0ded 32 ad f9				ld (store_tmp2+1), a   ; display item count 
0df0			 
0df0					 
0df0			.mitem:	 
0df0			 
0df0			 
0df0 3a ad f9				ld a,(store_tmp2+1) 
0df3 6f					ld l, a 
0df4 26 00				ld h, 0 
0df6 29					add hl, hl 
0df7 ed 5b ae f9			ld de, (store_tmp1) 
0dfb 19					add hl, de 
0dfc 7e					ld a, (hl) 
0dfd 23					inc hl 
0dfe 66					ld h,(hl) 
0dff 6f					ld l, a 
0e00			 
0e00 cd f8 0f				call ishlzero 
0e03 28 1a				jr z, .mdone 
0e05			 
0e05 eb					ex de, hl 
0e06 3a aa f9				ld a, (store_tmp3) 
0e09 cd ae 0d				call str_at_display 
0e0c					 
0e0c			 
0e0c					; next item 
0e0c 3a ad f9				ld a, (store_tmp2+1) 
0e0f 3c					inc a 
0e10 32 ad f9				ld (store_tmp2+1), a   ; display item count 
0e13			 
0e13			 		; next row 
0e13			 
0e13 3a aa f9				ld a, (store_tmp3) 
0e16 c6 28				add display_cols 
0e18 32 aa f9				ld (store_tmp3), a 
0e1b			 
0e1b					; at end of screen? 
0e1b			 
0e1b fe 10				cp display_rows*4 
0e1d 20 d1				jr nz, .mitem 
0e1f			 
0e1f			 
0e1f			.mdone: 
0e1f cd f8 0f				call ishlzero 
0e22 28 08				jr z, .nodn 
0e24			 
0e24 3e 78				ld a, display_row_4 
0e26 11 a5 0e				ld de, .mdown 
0e29 cd ae 0d				call str_at_display 
0e2c			 
0e2c					; draw options to fill the screens with active item on line 1 
0e2c					; if current option is 2 or more then display ^ in top 
0e2c			 
0e2c 3a ac f9		.nodn:		ld a, (store_tmp2) 
0e2f fe 00				cp 0 
0e31 28 08				jr z, .noup 
0e33			 
0e33 3e 00				ld a, 0 
0e35 11 a3 0e				ld de, .mup 
0e38 cd ae 0d				call str_at_display 
0e3b			 
0e3b 3e 02		.noup:		ld a, 2 
0e3d 11 a1 0e				ld de, .msel 
0e40 cd ae 0d				call str_at_display 
0e43			 
0e43					; if current option + 1 is not null then display V in bottom 
0e43					; get key 
0e43 cd be 0d				call update_display 
0e46			 
0e46			 
0e46					; handle key 
0e46			 
0e46 cd 81 79				call cin_wait 
0e49			 
0e49 fe 05				cp KEY_UP 
0e4b 28 2b				jr z, .mgoup 
0e4d fe 61				cp 'a' 
0e4f 28 27				jr z, .mgoup 
0e51 fe 0a				cp KEY_DOWN 
0e53 28 32				jr z, .mgod 
0e55 fe 7a				cp 'z' 
0e57 28 2e				jr z, .mgod 
0e59 fe 20				cp ' ' 
0e5b 28 34				jr z, .goend 
0e5d fe 0c				cp KEY_RIGHT 
0e5f 28 30				jr z, .goend 
0e61 fe 0d				cp KEY_CR 
0e63 28 2c				jr z, .goend 
0e65 fe 71				cp 'q' 
0e67 28 0b				jr z, .goback 
0e69			 
0e69 fe 0b				cp KEY_LEFT 
0e6b 28 07				jr z, .goback 
0e6d fe 08				cp KEY_BS 
0e6f 28 03				jr z, .goback 
0e71 c3 df 0d				jp .mloop 
0e74			 
0e74			.goback: 
0e74 3e 00			ld a, 0 
0e76 18 1d			jr .goend2 
0e78			 
0e78				; move up one 
0e78			.mgoup: 
0e78 3a ac f9				ld a, (store_tmp2) 
0e7b fe 00				cp 0 
0e7d ca df 0d				jp z, .mloop 
0e80 3d					dec a 
0e81 32 ac f9				ld (store_tmp2), a 
0e84 c3 df 0d				jp .mloop 
0e87			 
0e87				; move down one 
0e87			.mgod: 
0e87 3a ac f9				ld a, (store_tmp2) 
0e8a 3c					inc a 
0e8b 32 ac f9				ld (store_tmp2), a 
0e8e c3 df 0d				jp .mloop 
0e91			 
0e91			 
0e91			.goend: 
0e91					; get selected item number 
0e91			 
0e91 3a ac f9				ld a, (store_tmp2) 
0e94 3c					inc a 
0e95			 
0e95			.goend2: 
0e95 f5					push af 
0e96			 
0e96					; restore active fb 
0e96					; TODO BUG assumes fb1 
0e96			 
0e96 21 4b fc				ld hl, display_fb1 
0e99 22 07 fb				ld (display_fb_active), hl 
0e9c			 
0e9c					; restore main regs 
0e9c			 
0e9c			 
0e9c cd be 0d				call update_display 
0e9f			 
0e9f f1					pop af 
0ea0			 
0ea0 c9				ret 
0ea1			 
0ea1 .. 00		.msel:   db ">",0 
0ea3 .. 00		.mup:   db "^",0 
0ea5 .. 00		.mdown:   db "v",0 
0ea7			 
0ea7			 
0ea7			; eof 
0ea7			 
# End of file firmware_display.asm
0ea7			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0ea7			; random number generators 
0ea7			 
0ea7			 
0ea7			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0ea7			 
0ea7			 
0ea7			;-----> Generate a random number 
0ea7			; output a=answer 0<=a<=255 
0ea7			; all registers are preserved except: af 
0ea7			random: 
0ea7 e5			        push    hl 
0ea8 d5			        push    de 
0ea9 2a e6 fa		        ld      hl,(randData) 
0eac ed 5f		        ld      a,r 
0eae 57			        ld      d,a 
0eaf 5e			        ld      e,(hl) 
0eb0 19			        add     hl,de 
0eb1 85			        add     a,l 
0eb2 ac			        xor     h 
0eb3 22 e6 fa		        ld      (randData),hl 
0eb6 d1			        pop     de 
0eb7 e1			        pop     hl 
0eb8 c9			        ret 
0eb9			 
0eb9			 
0eb9			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0eb9			 
0eb9			 
0eb9			 
0eb9			;------LFSR------ 
0eb9			;James Montelongo 
0eb9			;optimized by Spencer Putt 
0eb9			;out: 
0eb9			; a = 8 bit random number 
0eb9			RandLFSR: 
0eb9 21 ec fa		        ld hl,LFSRSeed+4 
0ebc 5e			        ld e,(hl) 
0ebd 23			        inc hl 
0ebe 56			        ld d,(hl) 
0ebf 23			        inc hl 
0ec0 4e			        ld c,(hl) 
0ec1 23			        inc hl 
0ec2 7e			        ld a,(hl) 
0ec3 47			        ld b,a 
0ec4 cb 13		        rl e  
0ec6 cb 12			rl d 
0ec8 cb 11		        rl c  
0eca 17				rla 
0ecb cb 13		        rl e  
0ecd cb 12			rl d 
0ecf cb 11		        rl c  
0ed1 17				rla 
0ed2 cb 13		        rl e  
0ed4 cb 12			rl d 
0ed6 cb 11		        rl c  
0ed8 17				rla 
0ed9 67			        ld h,a 
0eda cb 13		        rl e  
0edc cb 12			rl d 
0ede cb 11		        rl c  
0ee0 17				rla 
0ee1 a8			        xor b 
0ee2 cb 13		        rl e  
0ee4 cb 12			rl d 
0ee6 ac			        xor h 
0ee7 a9			        xor c 
0ee8 aa			        xor d 
0ee9 21 ee fa		        ld hl,LFSRSeed+6 
0eec 11 ef fa		        ld de,LFSRSeed+7 
0eef 01 07 00		        ld bc,7 
0ef2 ed b8		        lddr 
0ef4 12			        ld (de),a 
0ef5 c9			        ret 
0ef6			 
0ef6			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ef6			 
0ef6			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ef6			 
0ef6			 
0ef6			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ef6			 
0ef6			prng16: 
0ef6			;Inputs: 
0ef6			;   (seed1) contains a 16-bit seed value 
0ef6			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ef6			;Outputs: 
0ef6			;   HL is the result 
0ef6			;   BC is the result of the LCG, so not that great of quality 
0ef6			;   DE is preserved 
0ef6			;Destroys: 
0ef6			;   AF 
0ef6			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ef6			;160cc 
0ef6			;26 bytes 
0ef6 2a e0 fa		    ld hl,(seed1) 
0ef9 44			    ld b,h 
0efa 4d			    ld c,l 
0efb 29			    add hl,hl 
0efc 29			    add hl,hl 
0efd 2c			    inc l 
0efe 09			    add hl,bc 
0eff 22 e0 fa		    ld (seed1),hl 
0f02 2a de fa		    ld hl,(seed2) 
0f05 29			    add hl,hl 
0f06 9f			    sbc a,a 
0f07 e6 2d		    and %00101101 
0f09 ad			    xor l 
0f0a 6f			    ld l,a 
0f0b 22 de fa		    ld (seed2),hl 
0f0e 09			    add hl,bc 
0f0f c9			    ret 
0f10			 
0f10			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f10			 
0f10			rand32: 
0f10			;Inputs: 
0f10			;   (seed1_0) holds the lower 16 bits of the first seed 
0f10			;   (seed1_1) holds the upper 16 bits of the first seed 
0f10			;   (seed2_0) holds the lower 16 bits of the second seed 
0f10			;   (seed2_1) holds the upper 16 bits of the second seed 
0f10			;   **NOTE: seed2 must be non-zero 
0f10			;Outputs: 
0f10			;   HL is the result 
0f10			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f10			;Destroys: 
0f10			;   AF 
0f10			;Tested and passes all CAcert tests 
0f10			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f10			;it has a period of 18,446,744,069,414,584,320 
0f10			;roughly 18.4 quintillion. 
0f10			;LFSR taps: 0,2,6,7  = 11000101 
0f10			;291cc 
0f10			;seed1_0=$+1 
0f10			;    ld hl,12345 
0f10			;seed1_1=$+1 
0f10			;    ld de,6789 
0f10			;    ld b,h 
0f10			;    ld c,l 
0f10			;    add hl,hl \ rl e \ rl d 
0f10			;    add hl,hl \ rl e \ rl d 
0f10			;    inc l 
0f10			;    add hl,bc 
0f10			;    ld (seed1_0),hl 
0f10			;    ld hl,(seed1_1) 
0f10			;    adc hl,de 
0f10			;    ld (seed1_1),hl 
0f10			;    ex de,hl 
0f10			;seed2_0=$+1 
0f10			;    ld hl,9876 
0f10			;seed2_1=$+1 
0f10			;    ld bc,54321 
0f10			;    add hl,hl \ rl c \ rl b 
0f10			;    ld (seed2_1),bc 
0f10			;    sbc a,a 
0f10			;    and %11000101 
0f10			;    xor l 
0f10			;    ld l,a 
0f10			;    ld (seed2_0),hl 
0f10			;    ex de,hl 
0f10			;    add hl,bc 
0f10			;    ret 
0f10			; 
0f10			 
0f10			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f10			; 20 bytes, 86 cycles (excluding ret) 
0f10			 
0f10			; returns   hl = pseudorandom number 
0f10			; corrupts   a 
0f10			 
0f10			; generates 16-bit pseudorandom numbers with a period of 65535 
0f10			; using the xorshift method: 
0f10			 
0f10			; hl ^= hl << 7 
0f10			; hl ^= hl >> 9 
0f10			; hl ^= hl << 8 
0f10			 
0f10			; some alternative shift triplets which also perform well are: 
0f10			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f10			 
0f10			;  org 32768 
0f10			 
0f10			xrnd: 
0f10 2a e4 fa		  ld hl,(xrandc)       ; seed must not be 0 
0f13 3e 00		  ld a,0 
0f15 bd			  cp l 
0f16 20 02		  jr nz, .xrnd1 
0f18 2e 01		  ld l, 1 
0f1a			.xrnd1: 
0f1a			 
0f1a 7c			  ld a,h 
0f1b 1f			  rra 
0f1c 7d			  ld a,l 
0f1d 1f			  rra 
0f1e ac			  xor h 
0f1f 67			  ld h,a 
0f20 7d			  ld a,l 
0f21 1f			  rra 
0f22 7c			  ld a,h 
0f23 1f			  rra 
0f24 ad			  xor l 
0f25 6f			  ld l,a 
0f26 ac			  xor h 
0f27 67			  ld h,a 
0f28			 
0f28 22 e4 fa		  ld (xrandc),hl 
0f2b			 
0f2b c9			  ret 
0f2c			;  
0f2c			 
0f2c			 
0f2c			;;;; int maths 
0f2c			 
0f2c			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f2c			; Divide 16-bit values (with 16-bit result) 
0f2c			; In: Divide BC by divider DE 
0f2c			; Out: BC = result, HL = rest 
0f2c			; 
0f2c			Div16: 
0f2c 21 00 00		    ld hl,0 
0f2f 78			    ld a,b 
0f30 06 08		    ld b,8 
0f32			Div16_Loop1: 
0f32 17			    rla 
0f33 ed 6a		    adc hl,hl 
0f35 ed 52		    sbc hl,de 
0f37 30 01		    jr nc,Div16_NoAdd1 
0f39 19			    add hl,de 
0f3a			Div16_NoAdd1: 
0f3a 10 f6		    djnz Div16_Loop1 
0f3c 17			    rla 
0f3d 2f			    cpl 
0f3e 47			    ld b,a 
0f3f 79			    ld a,c 
0f40 48			    ld c,b 
0f41 06 08		    ld b,8 
0f43			Div16_Loop2: 
0f43 17			    rla 
0f44 ed 6a		    adc hl,hl 
0f46 ed 52		    sbc hl,de 
0f48 30 01		    jr nc,Div16_NoAdd2 
0f4a 19			    add hl,de 
0f4b			Div16_NoAdd2: 
0f4b 10 f6		    djnz Div16_Loop2 
0f4d 17			    rla 
0f4e 2f			    cpl 
0f4f 41			    ld b,c 
0f50 4f			    ld c,a 
0f51 c9			ret 
0f52			 
0f52			 
0f52			;http://z80-heaven.wikidot.com/math 
0f52			; 
0f52			;Inputs: 
0f52			;     DE and A are factors 
0f52			;Outputs: 
0f52			;     A is not changed 
0f52			;     B is 0 
0f52			;     C is not changed 
0f52			;     DE is not changed 
0f52			;     HL is the product 
0f52			;Time: 
0f52			;     342+6x 
0f52			; 
0f52			Mult16: 
0f52			 
0f52 06 08		     ld b,8          ;7           7 
0f54 21 00 00		     ld hl,0         ;10         10 
0f57 29			       add hl,hl     ;11*8       88 
0f58 07			       rlca          ;4*8        32 
0f59 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f5b 19			         add hl,de   ;--         -- 
0f5c 10 f9		       djnz $-5      ;13*7+8     99 
0f5e c9			ret 
0f5f			 
0f5f			; 
0f5f			; Square root of 16-bit value 
0f5f			; In:  HL = value 
0f5f			; Out:  D = result (rounded down) 
0f5f			; 
0f5f			;Sqr16: 
0f5f			;    ld de,#0040 
0f5f			;    ld a,l 
0f5f			;    ld l,h 
0f5f			;    ld h,d 
0f5f			;    or a 
0f5f			;    ld b,8 
0f5f			;Sqr16_Loop: 
0f5f			;    sbc hl,de 
0f5f			;    jr nc,Sqr16_Skip 
0f5f			;    add hl,de 
0f5f			;Sqr16_Skip: 
0f5f			;    ccf 
0f5f			;    rl d 
0f5f			;    add a,a 
0f5f			;    adc hl,hl 
0f5f			;    add a,a 
0f5f			;    adc hl,hl 
0f5f			;    djnz Sqr16_Loop 
0f5f			;    ret 
0f5f			; 
0f5f			; 
0f5f			; Divide 8-bit values 
0f5f			; In: Divide E by divider C 
0f5f			; Out: A = result, B = rest 
0f5f			; 
0f5f			Div8: 
0f5f af			    xor a 
0f60 06 08		    ld b,8 
0f62			Div8_Loop: 
0f62 cb 13		    rl e 
0f64 17			    rla 
0f65 91			    sub c 
0f66 30 01		    jr nc,Div8_NoAdd 
0f68 81			    add a,c 
0f69			Div8_NoAdd: 
0f69 10 f7		    djnz Div8_Loop 
0f6b 47			    ld b,a 
0f6c 7b			    ld a,e 
0f6d 17			    rla 
0f6e 2f			    cpl 
0f6f c9			    ret 
0f70			 
0f70			; 
0f70			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f70			; In: Multiply A with DE 
0f70			; Out: HL = result 
0f70			; 
0f70			Mult12U: 
0f70 2e 00		    ld l,0 
0f72 87			    add a,a 
0f73 30 01		    jr nc,Mult12U_NoAdd0 
0f75 19			    add hl,de 
0f76			Mult12U_NoAdd0: 
0f76 29			    add hl,hl 
0f77 87			    add a,a 
0f78 30 01		    jr nc,Mult12U_NoAdd1 
0f7a 19			    add hl,de 
0f7b			Mult12U_NoAdd1: 
0f7b 29			    add hl,hl 
0f7c 87			    add a,a 
0f7d 30 01		    jr nc,Mult12U_NoAdd2 
0f7f 19			    add hl,de 
0f80			Mult12U_NoAdd2: 
0f80 29			    add hl,hl 
0f81 87			    add a,a 
0f82 30 01		    jr nc,Mult12U_NoAdd3 
0f84 19			    add hl,de 
0f85			Mult12U_NoAdd3: 
0f85 29			    add hl,hl 
0f86 87			    add a,a 
0f87 30 01		    jr nc,Mult12U_NoAdd4 
0f89 19			    add hl,de 
0f8a			Mult12U_NoAdd4: 
0f8a 29			    add hl,hl 
0f8b 87			    add a,a 
0f8c 30 01		    jr nc,Mult12U_NoAdd5 
0f8e 19			    add hl,de 
0f8f			Mult12U_NoAdd5: 
0f8f 29			    add hl,hl 
0f90 87			    add a,a 
0f91 30 01		    jr nc,Mult12U_NoAdd6 
0f93 19			    add hl,de 
0f94			Mult12U_NoAdd6: 
0f94 29			    add hl,hl 
0f95 87			    add a,a 
0f96 d0			    ret nc 
0f97 19			    add hl,de 
0f98 c9			    ret 
0f99			 
0f99			; 
0f99			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f99			; In: Multiply A with DE 
0f99			;      Put lowest value in A for most efficient calculation 
0f99			; Out: HL = result 
0f99			; 
0f99			Mult12R: 
0f99 21 00 00		    ld hl,0 
0f9c			Mult12R_Loop: 
0f9c cb 3f		    srl a 
0f9e 30 01		    jr nc,Mult12R_NoAdd 
0fa0 19			    add hl,de 
0fa1			Mult12R_NoAdd: 
0fa1 cb 23		    sla e 
0fa3 cb 12		    rl d 
0fa5 b7			    or a 
0fa6 c2 9c 0f		    jp nz,Mult12R_Loop 
0fa9 c9			    ret 
0faa			 
0faa			; 
0faa			; Multiply 16-bit values (with 32-bit result) 
0faa			; In: Multiply BC with DE 
0faa			; Out: BCHL = result 
0faa			; 
0faa			Mult32: 
0faa 79			    ld a,c 
0fab 48			    ld c,b 
0fac 21 00 00		    ld hl,0 
0faf 06 10		    ld b,16 
0fb1			Mult32_Loop: 
0fb1 29			    add hl,hl 
0fb2 17			    rla 
0fb3 cb 11		    rl c 
0fb5 30 07		    jr nc,Mult32_NoAdd 
0fb7 19			    add hl,de 
0fb8 ce 00		    adc a,0 
0fba d2 be 0f		    jp nc,Mult32_NoAdd 
0fbd 0c			    inc c 
0fbe			Mult32_NoAdd: 
0fbe 10 f1		    djnz Mult32_Loop 
0fc0 41			    ld b,c 
0fc1 4f			    ld c,a 
0fc2 c9			    ret 
0fc3			 
0fc3			 
0fc3			 
0fc3			; 
0fc3			; Multiply 8-bit values 
0fc3			; In:  Multiply H with E 
0fc3			; Out: HL = result 
0fc3			; 
0fc3			Mult8: 
0fc3 16 00		    ld d,0 
0fc5 6a			    ld l,d 
0fc6 06 08		    ld b,8 
0fc8			Mult8_Loop: 
0fc8 29			    add hl,hl 
0fc9 30 01		    jr nc,Mult8_NoAdd 
0fcb 19			    add hl,de 
0fcc			Mult8_NoAdd: 
0fcc 10 fa		    djnz Mult8_Loop 
0fce c9			    ret 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			 
0fcf			;;http://z80-heaven.wikidot.com/math 
0fcf			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fcf			; 
0fcf			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fcf			;     ld a,16        ;7 
0fcf			;     ld hl,0        ;10 
0fcf			;     jp $+5         ;10 
0fcf			;.DivLoop: 
0fcf			;       add hl,bc    ;-- 
0fcf			;       dec a        ;64 
0fcf			;       jr z,.DivLoopEnd        ;86 
0fcf			; 
0fcf			;       sla e        ;128 
0fcf			;       rl d         ;128 
0fcf			;       adc hl,hl    ;240 
0fcf			;       sbc hl,bc    ;240 
0fcf			;       jr nc,.DivLoop ;23|21 
0fcf			;       inc e        ;-- 
0fcf			;       jp .DivLoop+1 
0fcf			; 
0fcf			;.DivLoopEnd: 
0fcf			 
0fcf			;HL_Div_C: 
0fcf			;Inputs: 
0fcf			;     HL is the numerator 
0fcf			;     C is the denominator 
0fcf			;Outputs: 
0fcf			;     A is the remainder 
0fcf			;     B is 0 
0fcf			;     C is not changed 
0fcf			;     DE is not changed 
0fcf			;     HL is the quotient 
0fcf			; 
0fcf			;       ld b,16 
0fcf			;       xor a 
0fcf			;         add hl,hl 
0fcf			;         rla 
0fcf			;         cp c 
0fcf			;         jr c,$+4 
0fcf			;           inc l 
0fcf			;           sub c 
0fcf			;         djnz $-7 
0fcf			 
0fcf			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fcf			 
0fcf			addatohl: 
0fcf 85			    add   a, l    ; A = A+L 
0fd0 6f			    ld    l, a    ; L = A+L 
0fd1 8c			    adc   a, h    ; A = A+L+H+carry 
0fd2 95			    sub   l       ; A = H+carry 
0fd3 67			    ld    h, a    ; H = H+carry 
0fd4 c9			ret 
0fd5			 
0fd5			addatode: 
0fd5 83			    add   a, e    ; A = A+L 
0fd6 5f			    ld    e, a    ; L = A+L 
0fd7 8a			    adc   a, d    ; A = A+L+H+carry 
0fd8 93			    sub   e       ; A = H+carry 
0fd9 57			    ld    d, a    ; H = H+carry 
0fda c9			ret 
0fdb			 
0fdb			 
0fdb			addatobc: 
0fdb 81			    add   a, c    ; A = A+L 
0fdc 4f			    ld    c, a    ; L = A+L 
0fdd 88			    adc   a, b    ; A = A+L+H+carry 
0fde 91			    sub   c       ; A = H+carry 
0fdf 47			    ld    b, a    ; H = H+carry 
0fe0 c9			ret 
0fe1			 
0fe1			subafromhl: 
0fe1			   ; If A=0 do nothing 
0fe1			    ; Otherwise flip A's sign. Since 
0fe1			    ; the upper byte becomes -1, also 
0fe1			    ; substract 1 from H. 
0fe1 ed 44		    neg 
0fe3 ca ec 0f		    jp    z, Skip 
0fe6 25			    dec   h 
0fe7			     
0fe7			    ; Now add the low byte as usual 
0fe7			    ; Two's complement takes care of 
0fe7			    ; ensuring the result is correct 
0fe7 85			    add   a, l 
0fe8 6f			    ld    l, a 
0fe9 8c			    adc   a, h 
0fea 95			    sub   l 
0feb 67			    ld    h, a 
0fec			Skip: 
0fec c9				ret 
0fed			 
0fed			 
0fed			; compare hl and de 
0fed			; returns:  
0fed			; if hl = de, z=1, s=0, c0=0 
0fed			; if hl > de, z=0, s=0, c=0 
0fed			; if hl < de, z=0, s=1, c=1 
0fed			cmp16:	 
0fed b7				or a 
0fee ed 52			sbc hl,de 
0ff0 e0				ret po 
0ff1 7c				ld a,h 
0ff2 1f				rra 
0ff3 ee 40			xor 01000000B 
0ff5 37				scf 
0ff6 8f				adc a,a 
0ff7 c9				ret 
0ff8			 
0ff8			 
0ff8			; test if hl contains zero   - A is destroyed 
0ff8			 
0ff8			ishlzero:    
0ff8 b7				or a     ; reset flags 
0ff9 7c				ld a, h 
0ffa b5				or l        	 
0ffb			 
0ffb c9				ret 
0ffc			 
0ffc			 
0ffc			 
0ffc			 
0ffc			if FORTH_ENABLE_FLOATMATH 
0ffc			;include "float/bbcmath.z80" 
0ffc			include "float/lpfpcalc.asm" 
0ffc			endif 
0ffc			 
0ffc			 
0ffc			; eof 
0ffc			 
# End of file firmware_maths.asm
0ffc			include "firmware_strings.asm"   ; string handling  
0ffc			 
0ffc			 
0ffc			; TODO string len 
0ffc			; input text string, end on cr with zero term 
0ffc			; a offset into frame buffer to start prompt 
0ffc			; d is max length 
0ffc			; e is display size TODO 
0ffc			; c is current cursor position 
0ffc			; hl is ptr to where string will be stored and edited directly 
0ffc			 
0ffc			 
0ffc			; TODO check limit of buffer for new inserts 
0ffc			; TODO check insert does not push beyond buffer 
0ffc			; TODO scroll in a limited display area 
0ffc			; TODO scroll whole screen on page wrap 
0ffc			 
0ffc			 
0ffc			; TODO use LCD cursor? 
0ffc			 
0ffc			EDIT_V1: equ 0 
0ffc			EDIT_V2: equ 1 
0ffc			 
0ffc			 
0ffc			 
0ffc			if EDIT_V2 
0ffc			input_str: 
0ffc			 
0ffc 32 9f fd			    	ld (input_at_pos),a      ; save display position to start 
0fff			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0fff 22 a2 fd				ld (input_start), hl     ; save ptr to buffer 
1002			;		ld a, c 
1002			;		call addatohl 
1002			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
1002 7a					ld a,d 
1003 32 a1 fd			        ld (input_size), a       ; save length of input area 
1006 79					ld a, c 
1007 32 90 fd				ld (input_cursor),a      ; init cursor start position relative to start of string 
100a 7b					ld a,e 
100b 32 a0 fd			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
100e			 
100e			 
100e					; add a trailing space to make screen refresh nicer 
100e			 
100e					;ld hl, (input_start) 
100e					;push hl 
100e					;ld a, 0 
100e					;call strlent 
100e					;ld a, l 
100e					;pop hl 
100e					;call addatohl 
100e					;dec hl 
100e					;ld a, ' ' 
100e					;ld (hl), a 
100e					;inc hl 
100e					;ld (hl), a 
100e					;inc hl 
100e					;ld a, 0 
100e					;ld (hl), a 
100e			 
100e			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
100e					; init cursor shape if not set by the cin routines 
100e 21 fc fa				ld hl, cursor_shape 
1011			if BASE_KEV 
1011 3e ff				ld a, 255 
1013			else 
1013					ld a, '#' 
1013			endif 
1013 77					ld (hl), a 
1014 23					inc hl 
1015 3e 00				ld a, 0 
1017 77					ld (hl), a 
1018			 
1018 3e 09				ld a, CUR_BLINK_RATE 
101a 32 9b fd				ld (input_cur_flash), a 
101d 3e 01				ld a, 1 
101f 32 9a fd				ld (input_cur_onoff),a 
1022			.inmain:	 
1022			 
1022 cd 57 11				call input_disp_ref 
1025			 
1025					; save current length of string 
1025			 
1025 2a a2 fd				ld hl, (input_start) 
1028 3e 00				ld a, 0 
102a cd 4d 13				call strlent 
102d 7d					ld a,l 
102e 32 95 fd				ld (input_len), a 
1031			 
1031					;call input_disp_oncur 
1031			 
1031					; display current state of input buffer 
1031			 
1031					; clean any backspace chars 
1031			 
1031 3e 20				ld a, " " 
1033 32 fc f0				ld (scratch),a 
1036 3e 00				ld a, 0 
1038 32 fd f0				ld (scratch+1),a 
103b 3a 9f fd				ld a,(input_at_pos) 
103e 85					add l 
103f 11 fc f0				ld de, scratch 
1042 cd ae 0d				call str_at_display 
1045			 
1045					; pause 1ms 
1045			 
1045 3e 01				ld a, 1 
1047 cd c3 0c				call aDelayInMS 
104a			 
104a			; display cursor if visible on this cycle 
104a			 
104a					; dec flash counter 
104a 3a 9b fd				ld a, (input_cur_flash) 
104d 3d					dec a 
104e 32 9b fd				ld (input_cur_flash), a 
1051 fe 00				cp 0 
1053 20 0d				jr nz, .inochgstate 
1055			 
1055			 
1055					; reset on change of state 
1055 3e 09				ld a, CUR_BLINK_RATE 
1057 32 9b fd				ld (input_cur_flash), a 
105a			 
105a					; change state 
105a 3a 9a fd				ld a,(input_cur_onoff) 
105d ed 44				neg 
105f 32 9a fd				ld (input_cur_onoff),a 
1062			 
1062			 
1062			 
1062			 
1062					; TODO is cursor visible? 
1062					; TODO if so then over write the char at curspos pos with the cursor shape 
1062			 
1062								 
1062			 
1062			.inochgstate: 
1062 3a 9a fd				ld a,(input_cur_onoff) 
1065 fe ff				cp 255 
1067 28 0e				jr z, .skipcursor 
1069 3a 9f fd				ld a, (input_at_pos) 
106c 47					ld b, a 
106d 3a 90 fd				ld a, (input_cursor) 
1070 80					add b 
1071 11 fc fa				ld de, cursor_shape 
1074					 
1074 cd ae 0d				call str_at_display 
1077			 
1077			.skipcursor: 
1077				if DEBUG_INPUTV2 
1077			 
1077					ld a,(input_at_pos) 
1077					ld hl, LFSRSeed 
1077					call hexout 
1077					ld a, (input_cursor) 
1077					ld hl, LFSRSeed+2 
1077					call hexout 
1077					ld a,(input_size) 
1077					ld hl, LFSRSeed+4 
1077					call hexout 
1077			 
1077					ld a,(input_cur_onoff) 
1077					ld hl, LFSRSeed+6 
1077					call hexout 
1077			 
1077					ld a,(input_cur_flash) 
1077					ld hl, LFSRSeed+8 
1077					call hexout 
1077			 
1077					ld a,(input_len) 
1077					ld hl, LFSRSeed+10 
1077					call hexout 
1077					ld hl, LFSRSeed+12 
1077					ld a, 0 
1077					ld (hl),a 
1077					ld a, display_row_4 
1077					ld de, LFSRSeed 
1077					call str_at_display 
1077				endif 
1077 cd be 0d				call update_display 
107a			 
107a					; TODO keyboard processing 
107a			 
107a			if BASE_CPM 
107a					call cin_wait 
107a			else 
107a cd 92 79				call cin    ; _wait 
107d			endif 
107d fe 00				cp 0 
107f ca 22 10				jp z, .inmain 
1082			 
1082 fe 0b				cp KEY_LEFT    ; cursor left 
1084 ca 49 11				jp z, input_left 
1087				 
1087 fe 0c				cp KEY_RIGHT      ; cursor right 
1089 ca 50 11				jp z, input_right 
108c			 
108c fe 0d				cp KEY_CR 
108e c8					ret z 
108f			 
108f fe 08				cp KEY_BS 
1091 ca be 11				jp z, input_delchar 
1094			 
1094 fe 06				cp KEY_NEXTWORD 
1096 ca ca 10				jp z, input_nxtword 
1099			 
1099 fe 07				cp KEY_PREVWORD 
109b ca f1 10				jp z, input_prvword 
109e			 
109e fe 0e				cp KEY_HOME    ; jump to start of line 
10a0 20 08				jr nz, .ikh 
10a2 3e 00				ld a, 0 
10a4 32 90 fd				ld (input_cursor), a 
10a7 ca 22 10				jp z, .inmain 
10aa			.ikh: 
10aa			 
10aa fe 0f				cp KEY_END     ; jump to end of line 
10ac 20 09				jr nz, .ike 
10ae 3a 95 fd				ld a, (input_len) 
10b1 32 90 fd				ld (input_cursor),a 
10b4 ca 22 10				jp z, .inmain 
10b7			.ike: 
10b7 fe 05			        cp KEY_UP      ; recall last command 
10b9 20 0c				jr nz, .irec 
10bb			; TODO next word 
10bb			; TODO prev word 
10bb			;  
10bb			; 
10bb 21 fc f0			ld hl, scratch 
10be 11 22 f5			ld de, os_last_cmd 
10c1 cd db 11			call strcpy 
10c4 ca 22 10				jp z, .inmain 
10c7			.irec: 
10c7			;		jr .instr1 
10c7			 
10c7			 
10c7					; if no special key then insert as a char 
10c7			 
10c7 c3 90 11				jp input_inschr 
10ca			 
10ca				 
10ca			input_nxtword: 
10ca				; jump to start next word after the cursor 
10ca			 
10ca			.insknwn:	 
10ca cd 86 11				call input_curptr	 
10cd 7e					ld a,(hl)	 
10ce fe 00				cp 0 
10d0 ca 22 10				jp z, .inmain    ; end of string 
10d3			 
10d3			; if we are on a word, then move off of it 
10d3			 
10d3 fe 20				cp ' ' 
10d5 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
10d7 21 90 fd				ld hl, input_cursor 
10da 34					inc (hl) 
10db 18 ed				jr .insknwn 
10dd			 
10dd			.inspace: 
10dd			 
10dd cd 86 11				call input_curptr	 
10e0 7e					ld a,(hl)	 
10e1 fe 00				cp 0 
10e3 ca 22 10				jp z, .inmain    ; end of string 
10e6			 
10e6			; if we are on a word, then move off of it 
10e6			 
10e6 fe 20				cp ' ' 
10e8 c2 22 10				jp nz, .inmain     ; we are on non space so at next word 
10eb 21 90 fd				ld hl, input_cursor 
10ee 34					inc (hl) 
10ef 18 ec				jr .inspace 
10f1			 
10f1			 
10f1			 
10f1			 
10f1			input_prvword: 
10f1				; jump to the start of previous word before the cursor 
10f1			 
10f1			; where are we to start with currently? 
10f1			 
10f1 cd 86 11				call input_curptr	 
10f4 7e					ld a, (hl) 
10f5 fe 20				cp ' ' 
10f7 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
10f9			 
10f9			 
10f9			 
10f9			.inskpwn:	 
10f9 3a 90 fd				ld a,(input_cursor) 
10fc fe 00				cp 0 
10fe ca 22 10				jp z, .inmain    ; start of string 
1101			 
1101			;if we are on a word, then move off of it 
1101			 
1101 cd 86 11				call input_curptr	 
1104 7e					ld a, (hl) 
1105 fe 20				cp ' ' 
1107 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
1109					;jp z, .inmain    ; start of string 
1109 21 90 fd				ld hl, input_cursor 
110c 35					dec (hl) 
110d 18 ea				jr .inskpwn 
110f			.iwstart: 
110f 21 90 fd				ld hl, input_cursor 
1112 34					inc (hl) 
1113 c3 22 10				jp .inmain 
1116					 
1116			 
1116			.inspacep: 
1116			 
1116					;jp .inmain    ; start of string 
1116			 
1116			 
1116			 
1116 3a 90 fd				ld a,(input_cursor) 
1119 fe 00				cp 0 
111b ca 22 10				jp z, .inmain    ; start of string 
111e			 
111e			; if we are on a word, then move off of it 
111e			 
111e cd 86 11				call input_curptr	 
1121 7e					ld a, (hl) 
1122 fe 20				cp ' ' 
1124 c2 2d 11				jp nz, .incharp     ; we are on non space so at end of prev word 
1127 21 90 fd				ld hl, input_cursor 
112a 35					dec (hl) 
112b 18 e9				jr .inspacep 
112d			 
112d			 
112d			.incharp:	 
112d					; eat the word to get to the start 
112d 3a 90 fd				ld a,(input_cursor) 
1130 fe 00				cp 0 
1132 ca 22 10				jp z, .inmain    ; start of string 
1135			 
1135			; if we are on a word, then move off of it 
1135			 
1135 cd 86 11				call input_curptr	 
1138 7e					ld a, (hl) 
1139 fe 20				cp ' ' 
113b 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
113d 21 90 fd				ld hl, input_cursor 
1140 35					dec (hl) 
1141 18 ea				jr .incharp 
1143			.ipwordst: 
1143					; at space before the prev word so reposition over it 
1143 21 90 fd				ld hl, input_cursor 
1146 34					inc (hl) 
1147 18 b0				jr .inskpwn 
1149					 
1149			 
1149			 
1149			input_left: 
1149				; move cursor left 
1149 21 90 fd			ld hl, input_cursor 
114c 35				dec (hl) 
114d			;	cp 0 
114d			;	jp z, .inmain    ; ignore left as at the start of the string 
114d c3 22 10			jp .inmain 
1150			 
1150			input_right: 
1150				; move cursor right 
1150				 
1150				;ld a, (input_size) 
1150				;ld b, a 
1150 21 90 fd			ld hl, input_cursor 
1153 34				inc (hl) 
1154				;dec b 
1154				;cp 0 
1154				;jp z, .inmain   ; ignore as at end of the string buffer 
1154				;ld a, b 
1154				;inc a 
1154				;ld (input_cursor), a 
1154 c3 22 10			jp .inmain 
1157			 
1157			 
1157			 
1157			input_disp_ref: 
1157				; display the text from start of buffer (ie full refresh) 
1157 3a 9f fd			ld a, (input_at_pos) 
115a 2a a2 fd			ld hl,(input_start) 
115d eb				ex de, hl 
115e cd ae 0d			call str_at_display  
1161 c9				ret 
1162			input_disp_oncur: 
1162				; display the text from cursor position to end of buffer 
1162				; TODO position start of string at cursor position on screen 
1162				; TODO draw from that point on 
1162 3a 90 fd			ld a, (input_cursor) 
1165 47				ld b, a 
1166 3a 9f fd			ld a, (input_at_pos) 
1169 80				add b 
116a 48				ld c, b     ; save a 
116b 78				ld a, b     ; inc string start for cursor 
116c 2a a2 fd			ld hl,(input_start) 
116f cd cf 0f			call addatohl 
1172 eb				ex de, hl 
1173 79				ld a, c 
1174 cd ae 0d			call str_at_display  
1177 c9				ret 
1178			 
1178			input_nxtw: 
1178				; Find next word 
1178 c9				ret 
1179			 
1179			input_prvw: 
1179				; Find previous word 
1179 c9				ret 
117a			 
117a			input_lenrem:   
117a				; Calculate the length of string remaining from current cursor 
117a				; position to end of buffer (exc null term) 
117a				 
117a 3a 90 fd			ld a, (input_cursor) 
117d 4f				ld c, a 
117e 3a a1 fd			ld a, (input_size) 
1181 91				sub c 
1182 06 00			ld b, 0 
1184 0d				dec c 
1185 c9				ret	 
1186			 
1186			input_curptr: 
1186				; calc address of the character under the cursor 
1186				 
1186 2a a2 fd			ld hl, (input_start) 
1189 3a 90 fd			ld a, (input_cursor) 
118c cd cf 0f			call addatohl 
118f c9				ret 
1190			 
1190			input_inschr: 
1190				; Insert char at cursor position 
1190 f5				push af   ; save char 
1191				;call input_lenrem    ; get bc length of remaining string 
1191			 
1191				 
1191 cd 86 11			call input_curptr 
1194			;	ld hl, (input_start) 
1194			;	ld a, (input_cursor) 
1194			;	call addatohl 
1194				;push hl   ; save to come back to 
1194			 
1194				; shift everything up one to end of buffer 
1194			 
1194				;push hl 
1194				;dec de 
1194				;inc de 
1194			;	ldir 
1194				 
1194				;pop hl 
1194			 
1194				; are we adding to the end of line? 
1194			 
1194 3a 90 fd			ld a, (input_cursor) 
1197 47				ld b, a 
1198 3a 95 fd			ld a, (input_len) 
119b b8				cp b 
119c 20 09			jr nz, .insmid   ; no, insert in middle of text 
119e			 
119e				; tack on the end of the line 
119e f1				pop af 
119f 77				ld (hl), a   ; save new char 
11a0 23				inc hl 
11a1 3e 00			ld a, 0 
11a3 77				ld (hl), a 
11a4 c3 50 11			jp input_right 
11a7				 
11a7			.insmid: 
11a7				; hl has insertion point so move everything up one to allow for insertion 
11a7				;call input_shiftright 
11a7 f1				pop af 
11a8			 
11a8			.shufinsmid: 
11a8 47				ld b, a     ; b contains new char, c prev char at this position  
11a9 7e				ld a, (hl) 
11aa			 
11aa fe 00			cp 0    ; at end of string need to then dump new char and add term 
11ac 28 07			jr z, .endinsmid 
11ae 4f				ld c, a 
11af 78				ld a, b 
11b0 77				ld (hl), a 
11b1 23				inc hl 
11b2 79				ld a, c 
11b3 18 f3			jr .shufinsmid 
11b5				 
11b5			 
11b5			 
11b5			 
11b5			.endinsmid: 
11b5 78				ld a, b 
11b6 77				ld (hl), a 
11b7 23				inc hl 
11b8 3e 00			ld a, 0 
11ba 77				ld (hl), a 
11bb			 
11bb			 
11bb			;	ld (hl), a   ; save new char 
11bb			 
11bb c3 50 11			jp input_right 
11be			 
11be			;input_shiftright: 
11be			;	; shift text right at cursor, hl has shift start 
11be			;	push hl 
11be			;	push de 
11be			;	push bc 
11be			; 
11be			; 
11be			;	; move to end of string past zero term 
11be			;	ld hl,(input_start) 
11be			;	ld a, (input_len) 
11be			;	call addatohl 
11be			;	inc hl 
11be			;;	inc hl 
11be			;;	inc hl 
11be			;	ld a, 0 
11be			;	ld (hl), a 
11be			;;	dec hl 
11be			;	 
11be			;;	ld (hl), a 
11be			;;	dec hl 
11be			; 
11be			;	push hl 
11be			;	pop de 
11be			;	inc de 
11be			;	 
11be			; 
11be			;;	ld hl,(input_start) 
11be			;;	ld a, (input_cursor) 
11be			;;	call addatohl 
11be			; 
11be			; 
11be			;	; calc how many bytes from cursor pos to end of string we need to shift 
11be			;	call input_lenrem    ; get bc length of remaining string 
11be			;	;ld a, (input_cursor) 
11be			;	;ld c, a 
11be			;	ld a, (input_len) 
11be			;	cp 2 
11be			;	jr z, .iskipzero	 
11be			;	;sub c 
11be			;	;inc a 
11be			;	;ld c, a 
11be			;	;ld b, 0 
11be			;	inc c 
11be			;	inc c 
11be			;	; move data 
11be			;	lddr 
11be			;.iskipzero: 
11be			; 
11be			;	pop bc 
11be			;	pop de 
11be			;	pop hl 
11be			;	ret	 
11be			 
11be			input_delchar: 
11be				; Delete char at cursor position 
11be cd 7a 11			call input_lenrem    ; get bc length of remaining string 
11c1 2a a2 fd			ld hl, (input_start) 
11c4 3a 90 fd			ld a, (input_cursor) 
11c7 cd cf 0f			call addatohl 
11ca			 
11ca e5				push hl 
11cb d1				pop de 
11cc 1b				dec de 
11cd			 
11cd			.dl:	 
11cd ed a0			ldi  
11cf 7e				ld a, (hl) 
11d0 fe 00			cp 0 
11d2 28 02			jr z, .dldone 
11d4 18 f7			jr .dl 
11d6			.dldone: 
11d6 ed a0			ldi 
11d8			 
11d8 c3 49 11			jp input_left 
11db			 
11db			 
11db			endif 
11db			 
11db			 
11db			 
11db			if EDIT_V1 
11db			input_str: 
11db			 
11db				    	ld (input_at_pos),a      ; save display position to start 
11db					add c 
11db					ld (input_at_cursor),a	; save draw pos of cursor 
11db					ld (input_start), hl     ; save ptr to buffer 
11db					ld a, c 
11db					call addatohl 
11db					ld (input_ptr), hl     ; save ptr to point under the cursor 
11db					ld a,d 
11db				        ld (input_size), a       ; save length of input area 
11db					ld a, c 
11db					ld (input_cursor),a      ; init cursor start position  
11db					ld a,e 
11db				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
11db					 
11db					 
11db			 
11db			;		ld a,(input_ptr) 
11db			;		ld (input_under_cursor),a 	; save what is under the cursor 
11db			 
11db			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
11db					; init cursor shape if not set by the cin routines 
11db					ld hl, cursor_shape 
11db			if BASE_KEV 
11db					ld a, 255 
11db			else 
11db					ld a, '#' 
11db			endif 
11db					ld (hl), a 
11db					inc hl 
11db					ld a, 0 
11db					ld (hl), a 
11db			 
11db					ld a, CUR_BLINK_RATE 
11db					ld (input_cur_flash), a 
11db					ld a, 1 
11db					ld (input_cur_onoff),a 
11db			 
11db			;	if DEBUG_INPUT 
11db			;		push af 
11db			;		ld a, 'I' 
11db			;		ld (debug_mark),a 
11db			;		pop af 
11db			;		CALLMONITOR 
11db			;	endif 
11db			.is1:		; main entry loop 
11db			 
11db			 
11db			 
11db					; pause 1ms 
11db			 
11db					ld a, 1 
11db					call aDelayInMS 
11db			 
11db					; dec flash counter 
11db					ld a, (input_cur_flash) 
11db					dec a 
11db					ld (input_cur_flash), a 
11db					cp 0 
11db					jr nz, .nochgstate 
11db			 
11db			 
11db					; change state 
11db					ld a,(input_cur_onoff) 
11db					neg 
11db					ld (input_cur_onoff),a 
11db			 
11db			 
11db					; reset on change of state 
11db					ld a, CUR_BLINK_RATE 
11db					ld (input_cur_flash), a 
11db			 
11db			.nochgstate: 
11db					 
11db					 
11db			 
11db					; display cursor  
11db			 
11db			;		ld hl, (input_start) 
11db			;		ld a, (input_cursor) 
11db			;		call addatohl 
11db			 
11db					; get char under cursor and replace with cursor 
11db			ld hl, (input_ptr) 
11db			;		ld a, (hl) 
11db			;		ld (input_under_cursor),a 
11db			;		ld a, '_' 
11db			;		ld (hl), a 
11db			 
11db					; display string 
11db			 
11db					ld de, (input_start) 
11db					ld a, (input_at_pos) 
11db					call str_at_display 
11db			;	        call update_display 
11db			 
11db					; find place to put the cursor 
11db			;		add h 
11db			;		ld l, display_row_1 
11db			;		sub l 
11db			; (input_at_pos) 
11db					;ld c, a 
11db			;		ld a, (input_cursor) 
11db			;		ld l, (input_at_pos) 
11db			;		;ld b, h 
11db			;		add l 
11db			;		ld (input_at_cursor),a 
11db					;ld l,h 
11db			 
11db			;		ld h, 0 
11db			;		ld l,(input_at_pos) 
11db			;		ld a, (input_cursor) 
11db			;		call addatohl 
11db			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
11db			;		call subafromhl 
11db			;		ld a,l 
11db			;		ld (input_at_cursor), a 
11db			 
11db				if DEBUG_INPUT 
11db					ld a, (hardware_diag) 
11db					cp 0 
11db					jr z, .skip_input_diag 
11db			 
11db					ld a,(input_at_pos) 
11db					ld hl, LFSRSeed 
11db					call hexout 
11db					ld a, (input_cursor) 
11db					ld hl, LFSRSeed+2 
11db					call hexout 
11db					ld a,(input_at_cursor) 
11db					ld hl, LFSRSeed+4 
11db					call hexout 
11db			 
11db					ld a,(input_cur_onoff) 
11db					ld hl, LFSRSeed+6 
11db					call hexout 
11db			 
11db					ld a,(input_cur_flash) 
11db					ld hl, LFSRSeed+8 
11db					call hexout 
11db			 
11db					ld a,(input_len) 
11db					ld hl, LFSRSeed+10 
11db					call hexout 
11db					ld hl, LFSRSeed+12 
11db					ld a, 0 
11db					ld (hl),a 
11db					ld a, display_row_4 
11db					ld de, LFSRSeed 
11db					call str_at_display 
11db					.skip_input_diag: 
11db				endif 
11db			 
11db					; decide on if we are showing the cursor this time round 
11db			 
11db					ld a, (input_cur_onoff) 
11db					cp 255 
11db					jr z, .skipcur 
11db			 
11db			 
11db					ld a,(input_at_cursor) 
11db					ld de, cursor_shape 
11db					call str_at_display 
11db			 
11db					; save length of current input string 
11db					ld hl, (input_start) 
11db					ld a, 0 
11db					call strlent 
11db					ld a,l 
11db					ld (input_len),a 
11db			 
11db			.skipcur: 
11db			 
11db				        call update_display 
11db					 
11db			 
11db			 
11db					; wait 
11db				 
11db					; TODO loop without wait to flash the cursor and char under cursor	 
11db					call cin    ; _wait 
11db			 
11db					cp 0 
11db					jp z, .is1 
11db			 
11db					; get ptr to char to input into 
11db			 
11db					ld c,a 
11db					ld hl, (input_start) 
11db					ld a, (input_cursor) 
11db					call addatohl 
11db					ld (input_ptr), hl 
11db					ld a,c 
11db			 
11db					; replace char under cursor 
11db			 
11db			;		ld hl, (input_ptr) 
11db			;		ld a, (input_under_cursor) 	; get what is under the cursor 
11db			;		ld (hl), a 
11db			 
11db			;	if DEBUG_INPUT 
11db			;		push af 
11db			;		ld a, 'i' 
11db			;		ld (debug_mark),a 
11db			;		pop af 
11db			;		CALLMONITOR 
11db			;	endif 
11db					cp KEY_HOME 
11db					jr nz, .iske 
11db			 
11db					ld a, (input_at_pos) 
11db					ld (input_at_cursor),a 
11db					ld a, 0 
11db					ld (input_cursor), a 
11db					jp .is1 
11db					 
11db			.iske:		cp KEY_END 
11db					jr nz, .isknw 
11db					jp .is1 
11db			 
11db			.isknw:		cp KEY_NEXTWORD 
11db					jr nz, .iskpw 
11db			 
11db			.isknwm:	ld hl, (input_ptr) 
11db					ld a,(hl)	 
11db					cp 0 
11db					jp z, .is1    ; end of string 
11db					cp ' ' 
11db					jp z, .is1    ; end of word 
11db					inc hl 
11db					ld (input_ptr), hl 
11db					ld a, (input_at_cursor) 
11db					inc a 
11db					ld (input_at_cursor), a 
11db					jr .isknwm 
11db			 
11db			.iskpw:		cp KEY_PREVWORD 
11db					jr nz, .iskl 
11db			.iskpwm:	 
11db					ld hl, (input_ptr) 
11db					ld a,(hl)	 
11db					cp 0  
11db					jp z, .is1    ; end of string 
11db					cp ' ' 
11db					jp z, .is1    ; end of word 
11db					dec hl 
11db					ld (input_ptr), hl 
11db					ld a, (input_at_cursor) 
11db					dec a 
11db					ld (input_at_cursor), a 
11db					jr .iskpwm 
11db			 
11db			 
11db			.iskl:		cp KEY_LEFT 
11db					jr nz, .isk1 
11db			 
11db					ld a, (input_cursor) 
11db			 
11db					cp 0 
11db					jp z, .is1 		; at start of line to ignore  
11db			 
11db					dec  a 		; TODO check underflow 
11db					ld (input_cursor), a 
11db			 
11db					ld hl, (input_ptr) 
11db					dec hl 
11db					ld (input_ptr), hl 
11db					 
11db					ld a, (input_at_cursor) 
11db					dec a 
11db					ld (input_at_cursor), a 
11db			 
11db					ld a, 1		; show cursor moving 
11db					ld (input_cur_onoff),a 
11db					ld a, CUR_BLINK_RATE 
11db					ld (input_cur_flash), a 
11db			 
11db					jp .is1 
11db			 
11db			.isk1:		cp KEY_RIGHT 
11db					jr nz, .isk2 
11db			 
11db					ld a,(input_len)		; TODO BUG why cant i load e direct? 
11db					ld e,a 
11db					ld a, (input_cursor) 
11db					cp e 
11db					jp z, .is1		; at the end of string so dont go right 
11db			 
11db					inc  a 		; TODO check overflow 
11db					ld (input_cursor), a 
11db			 
11db					ld a, (input_at_cursor) 
11db					inc a 
11db					ld (input_at_cursor), a 
11db			 
11db					ld hl, (input_ptr) 
11db					inc hl 
11db					ld (input_ptr), hl 
11db			 
11db					ld a, 1		; show cursor moving 
11db					ld (input_cur_onoff),a 
11db					ld a, CUR_BLINK_RATE 
11db					ld (input_cur_flash), a 
11db			 
11db					jp .is1 
11db			 
11db			.isk2:		cp KEY_UP 
11db			 
11db					jr nz, .isk3 
11db			 
11db					; swap last command with the current on 
11db			 
11db					; move cursor to start of string 
11db					ld hl, (input_start) 
11db					ld (input_ptr), hl 
11db			 
11db					ld a, (input_at_pos) 
11db					ld (input_at_cursor), a 
11db			 
11db					ld a, 0 
11db					ld (input_cursor), a 
11db					 
11db					; swap input and last command buffers 
11db			 
11db					ld hl, os_cli_cmd 
11db					ld de, os_last_cmd 
11db					ld b, 255 
11db			.swap1:		ld a, (hl) 
11db					ld c,a 
11db					ld a, (de) 
11db					ld (hl), a 
11db					ld a,c 
11db					ld (de),a 
11db					inc hl 
11db					inc de 
11db					djnz .swap1 
11db			 
11db			 
11db			 
11db			 
11db			 
11db					jp .is1 
11db			 
11db			.isk3:		cp KEY_BS 
11db					jr nz, .isk4 
11db			 
11db					ld a, (input_cursor) 
11db			 
11db					cp 0 
11db					jp z, .is1 		; at start of line to ignore  
11db			 
11db					dec  a 		; TODO check underflow 
11db					ld (input_cursor), a 
11db			 
11db					; hl is source 
11db					; de needs to be source - 1 
11db			 
11db			;		ld a, 0 
11db			;		dec hl 
11db			;		ld (hl), a 
11db			 
11db					ld hl, (input_ptr) 
11db					dec hl 
11db					ld (input_ptr), hl 
11db			 
11db					; shift all data 
11db			 
11db					push hl 
11db					inc hl 
11db					pop de 
11db					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
11db					ld c,a 
11db					ld b,0 
11db					ldir  
11db			 
11db			 
11db			 
11db			 
11db					ld a, (input_at_cursor) 
11db					dec a 
11db					ld (input_at_cursor), a 
11db			 
11db			 
11db					ld a, 1		; show cursor moving 
11db					ld (input_cur_onoff),a 
11db					ld a, CUR_BLINK_RATE 
11db					ld (input_cur_flash), a 
11db			 
11db					; remove char 
11db					ld a, (input_at_cursor) 
11db					inc a 
11db					ld de,.iblank 
11db					call str_at_display 
11db			 
11db					jp .is1 
11db			 
11db			.isk4:		cp KEY_CR 
11db					jr z, .endinput 
11db			 
11db					; else add the key press to the end 
11db			 
11db					ld c, a			; save key pressed 
11db			 
11db					ld a,(hl)		; get what is currently under char 
11db			 
11db					cp 0			; we are at the end of the string 
11db					jr nz, .onchar 
11db					 
11db					; add a char to the end of the string 
11db				 
11db					ld (hl),c 
11db					inc hl 
11db			;		ld a,' ' 
11db			;		ld (hl),a 
11db			;		inc hl 
11db					ld a,0 
11db					ld (hl),a 
11db					dec hl 
11db			 
11db					ld a, (input_cursor) 
11db					inc a				; TODO check max string length and scroll  
11db					ld (input_cursor), a		; inc cursor pos 
11db							 
11db					ld a, (input_at_cursor) 
11db					inc a 
11db					ld (input_at_cursor), a 
11db			 
11db					ld hl, (input_ptr) 
11db					inc hl 
11db					ld (input_ptr), hl 
11db			 
11db					ld hl, (input_ptr) 
11db					inc hl 
11db					ld (input_ptr), hl 
11db			;	if DEBUG_INPUT 
11db			;		push af 
11db			;		ld a, '+' 
11db			;		ld (debug_mark),a 
11db			;		pop af 
11db			;		CALLMONITOR 
11db			;	endif 
11db					ld a, 1		; show cursor moving 
11db					ld (input_cur_onoff),a 
11db					ld a, CUR_BLINK_RATE 
11db					ld (input_cur_flash), a 
11db					jp .is1 
11db					 
11db			 
11db			 
11db					; if on a char then insert 
11db			.onchar: 
11db			 
11db					; TODO over flow check: make sure insert does not blow out buffer 
11db			 
11db					; need to do some maths to use lddr 
11db			 
11db					push hl   ; save char pos 
11db					push bc 
11db			 
11db					ld hl, (input_start) 
11db					ld a, (input_len) 
11db					call addatohl  		; end of string 
11db					inc hl 
11db					inc hl		; past zero term 
11db					push hl 
11db					inc hl 
11db					push hl  
11db			 
11db								; start and end of lddr set, now how much to move? 
11db			 
11db							 
11db					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11db					ld b,a 
11db					ld a,(input_len) 
11db					ld e,a 
11db					sub b 
11db					inc a		;?? 
11db					inc a		;?? 
11db					inc a		;?? 
11db			 
11db					ld b,0 
11db					ld c,a 
11db			 
11db				if DEBUG_INPUT 
11db					push af 
11db					ld a, 'i' 
11db					ld (debug_mark),a 
11db					pop af 
11db			;		CALLMONITOR 
11db				endif 
11db					pop de 
11db					pop hl 
11db				if DEBUG_INPUT 
11db					push af 
11db					ld a, 'I' 
11db					ld (debug_mark),a 
11db					pop af 
11db			;		CALLMONITOR 
11db				endif 
11db					lddr 
11db				 
11db			 
11db			 
11db					; TODO have a key for insert/overwrite mode???? 
11db					pop bc 
11db					pop hl 
11db					ld (hl), c		; otherwise overwrite current char 
11db					 
11db			 
11db			 
11db			 
11db					ld a, (input_cursor) 
11db					inc  a 		; TODO check overflow 
11db					ld (input_cursor), a 
11db			 
11db					ld a, (input_at_cursor) 
11db					inc a 
11db					ld (input_at_cursor), a 
11db			 
11db					jp .is1 
11db			 
11db			.endinput:	; TODO look for end of string 
11db			 
11db					; add trailing space for end of token 
11db			 
11db					ld hl, (input_start) 
11db					ld a,(input_len) 
11db					call addatohl 
11db					ld a, ' ' 
11db					ld (hl),a 
11db					; TODO eof of parse marker 
11db			 
11db					inc hl 
11db					ld a, 0 
11db					ld (hl),a 
11db			 
11db			 
11db					ret 
11db			 
11db			.iblank: db " ",0 
11db			 
11db			 
11db			input_str_prev:	ld (input_at_pos), a 
11db					ld (input_start), hl 
11db					ld a,1			; add cursor 
11db					ld (hl),a 
11db					inc hl 
11db					ld a,0 
11db					ld (hl),a 
11db					ld (input_ptr), hl 
11db					ld a,d 
11db					ld (input_size), a 
11db					ld a,0 
11db					ld (input_cursor),a 
11db			.instr1:	 
11db			 
11db					; TODO do block cursor 
11db					; TODO switch cursor depending on the modifer key 
11db			 
11db					; update cursor shape change on key hold 
11db			 
11db					ld hl, (input_ptr) 
11db					dec hl 
11db					ld a,(cursor_shape) 
11db					ld (hl), a 
11db			 
11db					; display entered text 
11db					ld a,(input_at_pos) 
11db			            	CALL fLCD_Pos       ;Position cursor to location in A 
11db			            	LD   de, (input_start) 
11db			            	CALL fLCD_Str       ;Display string pointed to by DE 
11db			 
11db					call cin 
11db					cp 0 
11db					jr z, .instr1 
11db			 
11db					; proecess keyboard controls first 
11db			 
11db					ld hl,(input_ptr) 
11db			 
11db					cp KEY_CR	 ; pressing enter ends input 
11db					jr z, .instrcr 
11db			 
11db					cp KEY_BS 	; back space 
11db					jr nz, .instr2 
11db					; process back space 
11db			 
11db					; TODO stop back space if at start of string 
11db					dec hl 
11db					dec hl ; to over write cursor 
11db					ld a,(cursor_shape) 
11db					;ld a,0 
11db					ld (hl),a 
11db					inc hl 
11db					ld a," " 
11db					ld (hl),a 
11db					ld (input_ptr),hl 
11db					 
11db			 
11db					jr .instr1 
11db			 
11db			.instr2:	cp KEY_LEFT    ; cursor left 
11db					jr nz, .instr3 
11db					dec hl 
11db					ld (input_ptr),hl 
11db					jr .instr1 
11db				 
11db			.instr3:	cp KEY_RIGHT      ; cursor right 
11db					jr nz, .instr4 
11db					inc hl 
11db					ld (input_ptr),hl 
11db					jr .instr1 
11db			 
11db			.instr4:	cp KEY_HOME    ; jump to start of line 
11db					jr nz, .instr5 
11db					dec hl 
11db					ld (input_ptr),hl 
11db					jr .instr1 
11db			 
11db			.instr5:	cp KEY_END     ; jump to end of line 
11db					jr nz, .instr6 
11db					dec hl 
11db					ld (input_ptr),hl 
11db					jr .instr1 
11db			.instr6:        cp KEY_UP      ; recall last command 
11db					jr nz, .instrnew 
11db			 
11db				ld hl, scratch 
11db				ld de, os_last_cmd 
11db				call strcpy 
11db					jr .instr1 
11db			 
11db			 
11db			.instrnew:	; no special key pressed to see if we have room to store it 
11db			 
11db					; TODO do string size test 
11db			 
11db					dec hl ; to over write cursor 
11db					ld (hl),a 
11db					inc hl 
11db					ld a,(cursor_shape) 
11db					ld (hl),a 
11db					inc hl 
11db					ld a,0 
11db					ld (hl),a 
11db			 
11db					ld (input_ptr),hl 
11db					 
11db					jr .instr1 
11db			.instrcr:	dec hl		; remove cursor 
11db					ld a,' '	; TODO add a trailing space for safety 
11db					ld (hl),a 
11db					inc hl 
11db					ld a,0 
11db					ld (hl),a 
11db			 
11db			 
11db					; if at end of line scroll up    
11db					; TODO detecting only end of line 4 for scroll up  
11db			 
11db					;ld   
11db			 
11db					ret 
11db			 
11db			 
11db			endif 
11db			; strcpy hl = dest, de source 
11db			 
11db 1a			strcpy:   LD   A, (DE)        ;Get character from string 
11dc b7			            OR   A              ;Null terminator? 
11dd c8			            RET  Z              ;Yes, so finished 
11de 1a					ld a,(de) 
11df 77					ld (hl),a 
11e0 13			            INC  DE             ;Point to next character 
11e1 23					inc hl 
11e2 18 f7		            JR   strcpy       ;Repeat 
11e4 c9					ret 
11e5			 
11e5			 
11e5			; TODO string_at  
11e5			; pass string which starts with lcd offset address and then null term string 
11e5			 
11e5			; TODO string to dec 
11e5			; TODO string to hex 
11e5			; TODO byte to string hex 
11e5			; TODO byte to string dec 
11e5			 
11e5			 
11e5			 
11e5			; from z80uartmonitor 
11e5			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e5			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
11e5			; pass hl for where to put the text 
11e5			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e5 c5			hexout:	PUSH BC 
11e6 f5					PUSH AF 
11e7 47					LD B, A 
11e8					; Upper nybble 
11e8 cb 3f				SRL A 
11ea cb 3f				SRL A 
11ec cb 3f				SRL A 
11ee cb 3f				SRL A 
11f0 cd 00 12				CALL tohex 
11f3 77					ld (hl),a 
11f4 23					inc hl	 
11f5					 
11f5					; Lower nybble 
11f5 78					LD A, B 
11f6 e6 0f				AND 0FH 
11f8 cd 00 12				CALL tohex 
11fb 77					ld (hl),a 
11fc 23					inc hl	 
11fd					 
11fd f1					POP AF 
11fe c1					POP BC 
11ff c9					RET 
1200					 
1200			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1200			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1200			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1200			tohex: 
1200 e5					PUSH HL 
1201 d5					PUSH DE 
1202 16 00				LD D, 0 
1204 5f					LD E, A 
1205 21 0d 12				LD HL, .DATA 
1208 19					ADD HL, DE 
1209 7e					LD A, (HL) 
120a d1					POP DE 
120b e1					POP HL 
120c c9					RET 
120d			 
120d			.DATA: 
120d 30					DEFB	30h	; 0 
120e 31					DEFB	31h	; 1 
120f 32					DEFB	32h	; 2 
1210 33					DEFB	33h	; 3 
1211 34					DEFB	34h	; 4 
1212 35					DEFB	35h	; 5 
1213 36					DEFB	36h	; 6 
1214 37					DEFB	37h	; 7 
1215 38					DEFB	38h	; 8 
1216 39					DEFB	39h	; 9 
1217 41					DEFB	41h	; A 
1218 42					DEFB	42h	; B 
1219 43					DEFB	43h	; C 
121a 44					DEFB	44h	; D 
121b 45					DEFB	45h	; E 
121c 46					DEFB	46h	; F 
121d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
121d			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
121d			;;    subtract $30, if result > 9 then subtract $7 more 
121d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
121d			atohex: 
121d d6 30				SUB $30 
121f fe 0a				CP 10 
1221 f8					RET M		; If result negative it was 0-9 so we're done 
1222 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1224 c9					RET		 
1225			 
1225			 
1225			 
1225			 
1225			; Get 2 ASCII characters as hex byte from pointer in hl 
1225			 
1225			BYTERD: 
1225 16 00			LD	D,00h		;Set up 
1227 cd 2f 12			CALL	HEXCON		;Get byte and convert to hex 
122a 87				ADD	A,A		;First nibble so 
122b 87				ADD	A,A		;multiply by 16 
122c 87				ADD	A,A		; 
122d 87				ADD	A,A		; 
122e 57				LD	D,A		;Save hi nibble in D 
122f			HEXCON: 
122f 7e				ld a, (hl)		;Get next chr 
1230 23				inc hl 
1231 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1233 fe 0a			CP	00Ah		;Is it 0-9 ? 
1235 38 02			JR	C,NALPHA	;If so miss next bit 
1237 d6 07			SUB	007h		;Else convert alpha 
1239			NALPHA: 
1239 b2				OR	D		;Add hi nibble back 
123a c9				RET			; 
123b			 
123b			 
123b			; 
123b			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
123b			; Since the routines get_byte and therefore get_nibble are called, only valid 
123b			; characters (0-9a-f) are accepted. 
123b			; 
123b			;get_word        push    af 
123b			;                call    get_byte        ; Get the upper byte 
123b			;                ld      h, a 
123b			;                call    get_byte        ; Get the lower byte 
123b			;                ld      l, a 
123b			;                pop     af 
123b			;                ret 
123b			; 
123b			; Get a byte in hexadecimal notation. The result is returned in A. Since 
123b			; the routine get_nibble is used only valid characters are accepted - the  
123b			; input routine only accepts characters 0-9a-f. 
123b			; 
123b c5			get_byte:        push    bc              ; Save contents of B (and C) 
123c 7e					ld a,(hl) 
123d 23					inc hl 
123e cd 63 12		                call    nibble2val      ; Get upper nibble 
1241 cb 07		                rlc     a 
1243 cb 07		                rlc     a 
1245 cb 07		                rlc     a 
1247 cb 07		                rlc     a 
1249 47			                ld      b, a            ; Save upper four bits 
124a 7e					ld a,(hl) 
124b cd 63 12		                call    nibble2val      ; Get lower nibble 
124e b0			                or      b               ; Combine both nibbles 
124f c1			                pop     bc              ; Restore B (and C) 
1250 c9			                ret 
1251			; 
1251			; Get a hexadecimal digit from the serial line. This routine blocks until 
1251			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1251			; to the serial line interface. The lower 4 bits of A contain the value of  
1251			; that particular digit. 
1251			; 
1251			;get_nibble      ld a,(hl)           ; Read a character 
1251			;                call    to_upper        ; Convert to upper case 
1251			;                call    is_hex          ; Was it a hex digit? 
1251			;                jr      nc, get_nibble  ; No, get another character 
1251			 ;               call    nibble2val      ; Convert nibble to value 
1251			 ;               call    print_nibble 
1251			 ;               ret 
1251			; 
1251			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1251			; A valid hexadecimal digit is denoted by a set C flag. 
1251			; 
1251			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1251			;                ret     nc              ; Yes 
1251			;                cp      '0'             ; Less than '0'? 
1251			;                jr      nc, is_hex_1    ; No, continue 
1251			;                ccf                     ; Complement carry (i.e. clear it) 
1251			;                ret 
1251			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1251			;                ret     c               ; Yes 
1251			;                cp      'A'             ; Less than 'A'? 
1251			;                jr      nc, is_hex_2    ; No, continue 
1251			;                ccf                     ; Yes - clear carry and return 
1251			;                ret 
1251			;is_hex_2        scf                     ; Set carry 
1251			;                ret 
1251			; 
1251			; Convert a single character contained in A to upper case: 
1251			; 
1251 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1253 d8			                ret     c 
1254 fe 7b		                cp      'z' + 1         ; > 'z'? 
1256 d0			                ret     nc              ; Nothing to do, either 
1257 e6 5f		                and     $5f             ; Convert to upper case 
1259 c9			                ret 
125a			 
125a			 
125a			to_lower: 
125a			 
125a			   ; if char is in [A-Z] make it lower case 
125a			 
125a			   ; enter : a = char 
125a			   ; exit  : a = lower case char 
125a			   ; uses  : af 
125a			 
125a fe 41		   cp 'A' 
125c d8			   ret c 
125d			    
125d fe 5b		   cp 'Z'+1 
125f d0			   ret nc 
1260			    
1260 f6 20		   or $20 
1262 c9			   ret 
1263			 
1263			; 
1263			; Expects a hexadecimal digit (upper case!) in A and returns the 
1263			; corresponding value in A. 
1263			; 
1263 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1265 38 02		                jr      c, nibble2val_1 ; Yes 
1267 d6 07		                sub     7               ; Adjust for A-F 
1269 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
126b e6 0f		                and     $f              ; Only return lower 4 bits 
126d c9			                ret 
126e			; 
126e			; Print_nibble prints a single hex nibble which is contained in the lower  
126e			; four bits of A: 
126e			; 
126e			;print_nibble    push    af              ; We won't destroy the contents of A 
126e			;                and     $f              ; Just in case... 
126e			;                add     a, '0'             ; If we have a digit we are done here. 
126e			;                cp      '9' + 1         ; Is the result > 9? 
126e			;                jr      c, print_nibble_1 
126e			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
126e			;print_nibble_1  call    putc            ; Print the nibble and 
126e			;                pop     af              ; restore the original value of A 
126e			;                ret 
126e			;; 
126e			;; Send a CR/LF pair: 
126e			; 
126e			;crlf            push    af 
126e			;                ld      a, cr 
126e			;                call    putc 
126e			;                ld      a, lf 
126e			;                call    putc 
126e			;                pop     af 
126e			;                ret 
126e			; 
126e			; Print_word prints the four hex digits of a word to the serial line. The  
126e			; word is expected to be in HL. 
126e			; 
126e			;print_word      push    hl 
126e			;                push    af 
126e			;                ld      a, h 
126e			;                call    print_byte 
126e			;                ld      a, l 
126e			;                call    print_byte 
126e			;                pop     af 
126e			;                pop     hl 
126e			;                ret 
126e			; 
126e			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
126e			; The byte to be printed is expected to be in A. 
126e			; 
126e			;print_byte      push    af              ; Save the contents of the registers 
126e			;                push    bc 
126e			;                ld      b, a 
126e			;                rrca 
126e			;                rrca 
126e			;                rrca 
126e			;                rrca 
126e			;                call    print_nibble    ; Print high nibble 
126e			;                ld      a, b 
126e			;                call    print_nibble    ; Print low nibble 
126e			;                pop     bc              ; Restore original register contents 
126e			;                pop     af 
126e			;                ret 
126e			 
126e			 
126e			 
126e			 
126e			 
126e			fourehexhl:  
126e 7e				ld a,(hl) 
126f cd 1d 12			call atohex 
1272 cb 3f				SRL A 
1274 cb 3f				SRL A 
1276 cb 3f				SRL A 
1278 cb 3f				SRL A 
127a 47				ld b, a 
127b 23				inc hl 
127c 7e				ld a,(hl) 
127d 23				inc hl 
127e cd 1d 12			call atohex 
1281 80				add b 
1282 57				ld d,a 
1283 7e				ld a,(hl) 
1284 cd 1d 12			call atohex 
1287 cb 3f				SRL A 
1289 cb 3f				SRL A 
128b cb 3f				SRL A 
128d cb 3f				SRL A 
128f 47				ld b, a 
1290 23				inc hl 
1291 7e				ld a,(hl) 
1292 23				inc hl 
1293 cd 1d 12			call atohex 
1296 80				add b 
1297 5f				ld e, a 
1298 d5				push de 
1299 e1				pop hl 
129a c9				ret 
129b			 
129b			; pass hl. returns z set if the byte at hl is a digit 
129b			;isdigithl:  
129b			;	push bc 
129b			;	ld a,(hl) 
129b			;	cp ':' 
129b			;	jr nc, .isdf 		; > 
129b			;	cp '0' 
129b			;	jr c, .isdf		; < 
129b			; 
129b			;	; TODO find a better way to set z 
129b			; 
129b			;	ld b,a 
129b			;	cp b 
129b			;	pop bc 
129b			;	ret 
129b			; 
129b			;.isdf:	; not digit so clear z 
129b			; 
129b			;	; TODO find a better way to unset z 
129b			; 
129b			;	ld b,a 
129b			;	inc b 
129b			;	cp b 
129b			; 
129b			;	pop bc 
129b			;	ret 
129b				 
129b				 
129b			 
129b			 
129b			; pass hl as the four byte address to load 
129b			 
129b			get_word_hl:  
129b e5				push hl 
129c cd 3b 12			call get_byte 
129f				 
129f 47				ld b, a 
12a0			 
12a0 e1				pop hl 
12a1 23				inc hl 
12a2 23				inc hl 
12a3			 
12a3			; TODO not able to handle a-f  
12a3 7e				ld a,(hl) 
12a4			;	;cp ':' 
12a4			;	cp 'g' 
12a4			;	jr nc, .single_byte_hl 		; > 
12a4			;	cp 'G' 
12a4			;	jr nc, .single_byte_hl 		; > 
12a4			;	cp '0' 
12a4			;	jr c, .single_byte_hl		; < 
12a4			 
12a4				;call isdigithl 
12a4 fe 00			cp 0 
12a6 28 06			jr z, .single_byte_hl 
12a8			 
12a8			.getwhln:   ; hex word so get next byte 
12a8			 
12a8 cd 3b 12			call get_byte 
12ab 6f				ld l, a 
12ac 60				ld h,b 
12ad c9				ret 
12ae 68			.single_byte_hl:   ld l,b 
12af 26 00				ld h,0 
12b1 c9					ret 
12b2			 
12b2			 
12b2			 
12b2			 
12b2 21 07 1d			ld hl,asc+1 
12b5			;	ld a, (hl) 
12b5			;	call nibble2val 
12b5 cd 3b 12			call get_byte 
12b8			 
12b8			;	call fourehexhl 
12b8 32 30 f1			ld (scratch+52),a 
12bb				 
12bb 21 2e f1			ld hl,scratch+50 
12be 22 1f f4			ld (os_cur_ptr),hl 
12c1			 
12c1 c9				ret 
12c2			 
12c2			 
12c2			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
12c2			 
12c2			; Decimal Unsigned Version 
12c2			 
12c2			;Number in a to decimal ASCII 
12c2			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
12c2			;Example: display a=56 as "056" 
12c2			;input: a = number 
12c2			;Output: a=0,value of a in the screen 
12c2			;destroys af,bc (don't know about hl and de) 
12c2			DispAToASCII: 
12c2 0e 9c			ld	c,-100 
12c4 cd ce 12			call	.Na1 
12c7 0e f6			ld	c,-10 
12c9 cd ce 12			call	.Na1 
12cc 0e ff			ld	c,-1 
12ce 06 2f		.Na1:	ld	b,'0'-1 
12d0 04			.Na2:	inc	b 
12d1 81				add	a,c 
12d2 38 fc			jr	c,.Na2 
12d4 91				sub	c		;works as add 100/10/1 
12d5 f5				push af		;safer than ld c,a 
12d6 78				ld	a,b		;char is in b 
12d7			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
12d7 f1				pop af		;safer than ld a,c 
12d8 c9				ret 
12d9			 
12d9			; Decimal Signed Version 
12d9			 
12d9			; DispA 
12d9			; -------------------------------------------------------------- 
12d9			; Converts a signed integer value to a zero-terminated ASCII 
12d9			; string representative of that value (using radix 10). 
12d9			; -------------------------------------------------------------- 
12d9			; INPUTS: 
12d9			;     HL     Value to convert (two's complement integer). 
12d9			;     DE     Base address of string destination. (pointer). 
12d9			; -------------------------------------------------------------- 
12d9			; OUTPUTS: 
12d9			;     None 
12d9			; -------------------------------------------------------------- 
12d9			; REGISTERS/MEMORY DESTROYED 
12d9			; AF HL 
12d9			; -------------------------------------------------------------- 
12d9			 
12d9			;DispHLToASCII: 
12d9			;   push    de 
12d9			;   push    bc 
12d9			; 
12d9			;; Detect sign of HL. 
12d9			;    bit    7, h 
12d9			;    jr     z, ._DoConvert 
12d9			; 
12d9			;; HL is negative. Output '-' to string and negate HL. 
12d9			;    ld     a, '-' 
12d9			;    ld     (de), a 
12d9			;    inc    de 
12d9			; 
12d9			;; Negate HL (using two's complement) 
12d9			;    xor    a 
12d9			;    sub    l 
12d9			;    ld     l, a 
12d9			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
12d9			;    sbc    a, h 
12d9			;    ld     h, a 
12d9			; 
12d9			;; Convert HL to digit characters 
12d9			;._DoConvert: 
12d9			;    ld     b, 0     ; B will count character length of number 
12d9			;-   ld     a, 10 
12d9			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
12d9			;    push   af 
12d9			;    inc    b 
12d9			;    ld     a, h 
12d9			;    or     l 
12d9			;    jr     nz, - 
12d9			; 
12d9			;; Retrieve digits from stack 
12d9			;-   pop    af 
12d9			;    or     $30 
12d9			;    ld     (de), a 
12d9			;    inc    de 
12d9			;    djnz   - 
12d9			; 
12d9			;; Terminate string with NULL 
12d9			;    xor    a 
12d9			;    ld     (de), a 
12d9			; 
12d9			;    pop    bc 
12d9			;    pop    de 
12d9			;    ret 
12d9			 
12d9			;Comments 
12d9			; 
12d9			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
12d9			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
12d9			;    Note that the output string will not be fixed-width. 
12d9			; 
12d9			;Example Usage 
12d9			; 
12d9			;    ld    hl, -1004 
12d9			;    ld    de, OP1 
12d9			;    call  DispA 
12d9			;    ld    hl, OP1 
12d9			;    syscall  PutS 
12d9			 
12d9			 
12d9			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12d9			 
12d9			 
12d9			;Converts an ASCII string to an unsigned 16-bit integer 
12d9			;Quits when it reaches a non-decimal digit 
12d9			 
12d9			string_to_uint16: 
12d9			atoui_16: 
12d9			;Input: 
12d9			;     DE points to the string 
12d9			;Outputs: 
12d9			;     HL is the result 
12d9			;     A is the 8-bit value of the number 
12d9			;     DE points to the byte after the number 
12d9			;Destroys: 
12d9			;     BC 
12d9			;       if the string is non-empty, BC is HL/10 
12d9			;Size:  24 bytes 
12d9			;Speed: 42+d(104+{0,9}) 
12d9			;       d is the number of digits in the number 
12d9			;       max is 640 cycles for a 5 digit number 
12d9			;Assuming no leading zeros: 
12d9			;1 digit:  146cc 
12d9			;2 digit:  250cc 
12d9			;3 digit:  354cc or 363cc (avg: 354.126cc) 
12d9			;4 digit:  458cc or 467cc (avg: 458.27cc) 
12d9			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
12d9			;avg: 544.81158447265625cc (544+13297/16384) 
12d9			;=============================================================== 
12d9 21 00 00		  ld hl,0 
12dc			.u16a: 
12dc 1a			  ld a,(de) 
12dd d6 30		  sub 30h 
12df fe 0a		  cp 10 
12e1 d0			  ret nc 
12e2 13			  inc de 
12e3 44			  ld b,h 
12e4 4d			  ld c,l 
12e5 29			  add hl,hl 
12e6 29			  add hl,hl 
12e7 09			  add hl,bc 
12e8 29			  add hl,hl 
12e9 85			  add a,l 
12ea 6f			  ld l,a 
12eb 30 ef		  jr nc,.u16a 
12ed 24			  inc h 
12ee c3 dc 12		  jp .u16a 
12f1			 
12f1			 
12f1			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12f1			 
12f1			;written by Zeda 
12f1			;Converts a 16-bit unsigned integer to an ASCII string. 
12f1			 
12f1			uitoa_16: 
12f1			;Input: 
12f1			;   DE is the number to convert 
12f1			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
12f1			;Output: 
12f1			;   HL points to the null-terminated ASCII string 
12f1			;      NOTE: This isn't necessarily the same as the input HL. 
12f1 d5			  push de 
12f2 c5			  push bc 
12f3 f5			  push af 
12f4 eb			  ex de,hl 
12f5			 
12f5 01 f0 d8		  ld bc,-10000 
12f8 3e 2f		  ld a,'0'-1 
12fa 3c			  inc a 
12fb 09			  add hl,bc  
12fc 38 fc		   jr c,$-2 
12fe 12			  ld (de),a 
12ff 13			  inc de 
1300			 
1300 01 e8 03		  ld bc,1000 
1303 3e 3a		  ld a,'9'+1 
1305 3d			  dec a  
1306 09			  add hl,bc  
1307 30 fc		   jr nc,$-2 
1309 12			  ld (de),a 
130a 13			  inc de 
130b			 
130b 01 9c ff		  ld bc,-100 
130e 3e 2f		  ld a,'0'-1 
1310 3c			  inc a  
1311 09			  add hl,bc  
1312 38 fc		   jr c,$-2 
1314 12			  ld (de),a 
1315 13			  inc de 
1316			 
1316 7d			  ld a,l 
1317 26 3a		  ld h,'9'+1 
1319 25			  dec h  
131a c6 0a		  add a,10  
131c 30 fb		   jr nc,$-3 
131e c6 30		  add a,'0' 
1320 eb			  ex de,hl 
1321 72			  ld (hl),d 
1322 23			  inc hl 
1323 77			  ld (hl),a 
1324 23			  inc hl 
1325 36 00		  ld (hl),0 
1327			 
1327			;Now strip the leading zeros 
1327 0e fa		  ld c,-6 
1329 09			  add hl,bc 
132a 3e 30		  ld a,'0' 
132c 23			  inc hl  
132d be			  cp (hl)  
132e 28 fc		  jr z,$-2 
1330			 
1330			;Make sure that the string is non-empty! 
1330 7e			  ld a,(hl) 
1331 b7			  or a 
1332 20 01		  jr nz,.atoub 
1334 2b			  dec hl 
1335			.atoub: 
1335			 
1335 f1			  pop af 
1336 c1			  pop bc 
1337 d1			  pop de 
1338 c9			  ret 
1339			 
1339			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1339			 
1339			toUpper: 
1339			;A is the char. 
1339			;If A is a lowercase letter, this sets it to the matching uppercase 
1339			;18cc or 30cc or 41cc 
1339			;avg: 26.75cc 
1339 fe 61		  cp 'a' 
133b d8			  ret c 
133c fe 7b		  cp 'z'+1 
133e d0			  ret nc 
133f d6 20		  sub 'a'-'A' 
1341 c9			  ret 
1342			 
1342			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1342			 
1342			; String Length 
1342			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1342			 
1342			; Get the length of the null-terminated string starting at $8000 hl 
1342			;    LD     HL, $8000 
1342			 
1342			strlenz: 
1342			 
1342 af			    XOR    A               ; Zero is the value we are looking for. 
1343 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1344 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1345			                           ; 65, 536 bytes (the entire addressable memory space). 
1345 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1347			 
1347			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1347 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1348 6f			    LD     L, A             ; number of bytes 
1349 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
134b 2b			    DEC    HL              ; Compensate for null. 
134c c9				ret 
134d			 
134d			; Get the length of the A terminated string starting at $8000 hl 
134d			;    LD     HL, $8000 
134d			 
134d			strlent: 
134d			 
134d			                  ; A is the value we are looking for. 
134d 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
134f 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1351			                           ; 65, 536 bytes (the entire addressable memory space). 
1351 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1353			 
1353			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1353 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1355 2e 00		    LD     L, 0             ; number of bytes 
1357 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1359 2b			    DEC    HL              ; Compensate for null. 
135a c9				ret 
135b			 
135b			 
135b			;Comparing Strings 
135b			 
135b			;IN    HL     Address of string1. 
135b			;      DE     Address of string2. 
135b			 
135b			; doc given but wrong??? 
135b			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
135b			;      carry  Set if string1 > string2, reset if string1 <= string2. 
135b			; tested 
135b			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
135b			 
135b			strcmp_old: 
135b e5			    PUSH   HL 
135c d5			    PUSH   DE 
135d			 
135d 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
135e be			    CP     (HL)            ; (want to minimize work). 
135f 38 01		    JR     C, Str1IsBigger 
1361 7e			    LD     A, (HL) 
1362			 
1362			Str1IsBigger: 
1362 4f			    LD     C, A             ; Put length in BC 
1363 06 00		    LD     B, 0 
1365 13			    INC    DE              ; Increment pointers to meat of string. 
1366 23			    INC    HL 
1367			 
1367			CmpLoop: 
1367 1a			    LD     A, (DE)          ; Compare bytes. 
1368 ed a1		    CPI 
136a 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
136c 13			    INC    DE              ; Update pointer. 
136d ea 67 13		    JP     PE, CmpLoop 
1370			 
1370 d1			    POP    DE 
1371 e1			    POP    HL 
1372 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1373 be			    CP     (HL) 
1374 c9			    RET 
1375			 
1375			NoMatch: 
1375 2b			    DEC    HL 
1376 be			    CP     (HL)            ; Compare again to affect carry. 
1377 d1			    POP    DE 
1378 e1			    POP    HL 
1379 c9			    RET 
137a			 
137a			;; test strmp 
137a			; 
137a			;ld de, .str1 
137a			;ld hl, .str2 
137a			;call strcmp 
137a			;jr z, .z1 
137a			;;this 
137a			;	if DEBUG_FORTH_WORDS 
137a			;		DMARK "NZ1" 
137a			;		CALLMONITOR 
137a			;	endif 
137a			;.z1: 
137a			; 
137a			;	if DEBUG_FORTH_WORDS 
137a			;		DMARK "ZZ1" 
137a			;		CALLMONITOR 
137a			;	endif 
137a			; 
137a			;ld de, .str1 
137a			;ld hl, .str1 
137a			;call strcmp 
137a			;jr z, .z2 
137a			;;this 
137a			;	if DEBUG_FORTH_WORDS 
137a			;		DMARK "NZ2" 
137a			;		CALLMONITOR 
137a			;	endif 
137a			;.z2: 
137a			; 
137a			;	if DEBUG_FORTH_WORDS 
137a			;		DMARK "ZZ2" 
137a			;		CALLMONITOR 
137a			;	endif 
137a			; 
137a			;ld de, .str1 
137a			;ld hl, .str2 
137a			;call strcmp 
137a			;jr c, .c1 
137a			; 
137a			;	if DEBUG_FORTH_WORDS 
137a			;		DMARK "Nc1" 
137a			;		CALLMONITOR 
137a			;	endif 
137a			;.c1: 
137a			;;this 
137a			;	if DEBUG_FORTH_WORDS 
137a			;		DMARK "cc1" 
137a			;		CALLMONITOR 
137a			;	endif 
137a			; 
137a			;ld de, .str1 
137a			;ld hl, .str1 
137a			;call strcmp 
137a			;jr c, .c2 
137a			;;this 
137a			;	if DEBUG_FORTH_WORDS 
137a			;		DMARK "Nc2" 
137a			;		CALLMONITOR 
137a			;	endif 
137a			;.c2: 
137a			; 
137a			;	if DEBUG_FORTH_WORDS 
137a			;		DMARK "cc2" 
137a			;		CALLMONITOR 
137a			;	endif 
137a			;	NEXTW 
137a			;.str1:   db "string1",0 
137a			;.str2:   db "string2",0 
137a			 
137a			; only care about direct match or not 
137a			; hl and de strings 
137a			; zero set if the same 
137a			 
137a			strcmp: 
137a 1a				ld a, (de) 
137b be				cp (hl) 
137c 28 02			jr z, .ssame 
137e b7				or a 
137f c9				ret 
1380			 
1380			.ssame:  
1380 fe 00			cp 0 
1382 c8				ret z 
1383			 
1383 23				inc hl 
1384 13				inc de 
1385 18 f3			jr strcmp 
1387				 
1387				 
1387			 
1387			;Copyright (c) 2014, Luke Maurits 
1387			;All rights reserved. 
1387			; 
1387			;Redistribution and use in source and binary forms, with or without 
1387			;modification, are permitted provided that the following conditions are met: 
1387			; 
1387			;* Redistributions of source code must retain the above copyright notice, this 
1387			;  list of conditions and the following disclaimer. 
1387			; 
1387			;* Redistributions in binary form must reproduce the above copyright notice, 
1387			;  this list of conditions and the following disclaimer in the documentation 
1387			;  and/or other materials provided with the distribution. 
1387			; 
1387			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
1387			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
1387			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
1387			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
1387			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
1387			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
1387			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
1387			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
1387			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
1387			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
1387			 
1387			; https://github.com/lmaurits/lm512/blob/master/string.z80 
1387			 
1387			StrictStrCmp: 
1387				; Load next chars of each string 
1387 1a				ld a, (de) 
1388 47				ld b, a 
1389 7e				ld a, (hl) 
138a				; Compare 
138a b8				cp b 
138b				; Return non-zero if chars don't match 
138b c0				ret nz 
138c				; Check for end of both strings 
138c fe 00			cp "\0" 
138e				; Return if strings have ended 
138e c8				ret z 
138f				; Otherwise, advance to next chars 
138f 23				inc hl 
1390 13				inc de 
1391 18 f4			jr StrictStrCmp 
1393			 
1393			;end 
1393			; eof 
1393			 
1393			 
1393			 
1393			 
1393			 
1393			 
# End of file firmware_strings.asm
1393			include "firmware_memory.asm"   ; malloc and free  
1393			 
1393			if DEBUG_FORTH_MALLOC_HIGH 
1393			.mallocsize: db "Wants malloc >256",0 
1393			.mallocasize: db "MALLOC gives >256",0 
1393			.malloczero: db "MALLOC gives zero",0 
1393			 
1393			malloc_guard_zerolen: 
1393				push hl 
1393				push de 
1393				push af 
1393			 
1393				ld de, 0 
1393			        call cmp16 
1393				jr nz, .lowalloz 
1393			 
1393				push hl 
1393				push de 
1393					ld hl, display_fb0 
1393					ld (display_fb_active), hl 
1393				call clear_display 
1393				ld a, 0 
1393				ld de, .malloczero 
1393				call str_at_display 
1393				call update_display 
1393				call delay1s 
1393				call delay1s 
1393				call bp_on 
1393			;	ld a, 0 
1393			;	ld (os_view_disable), a 
1393			 
1393				pop de 
1393				pop hl 
1393			 
1393				 
1393			 
1393				CALLMONITOR 
1393			.lowalloz: 
1393			 
1393			 
1393				pop af 
1393				pop de 
1393				pop hl 
1393			ret 
1393			 
1393			malloc_guard_entry: 
1393				push hl 
1393				push de 
1393				push af 
1393			 
1393			 	or a      ;clear carry flag 
1393				push hl 
1393				ld de, 255 
1393				sbc hl, de 
1393				jr c, .lowalloc 
1393			 
1393				push de 
1393					ld hl, display_fb0 
1393					ld (display_fb_active), hl 
1393				call clear_display 
1393				ld a, 0 
1393				ld de, .mallocsize 
1393				call str_at_display 
1393				call update_display 
1393				call delay1s 
1393				call delay1s 
1393			;	ld a, 0 
1393			;	ld (os_view_disable), a 
1393				call bp_on 
1393			 
1393				pop de 
1393				pop hl 
1393			 
1393				 
1393			 
1393				CALLMONITOR 
1393				jr .lowdone 
1393			.lowalloc: 
1393			 
1393			 
1393				pop hl 
1393			.lowdone:	pop af 
1393				pop de 
1393				pop hl 
1393			ret 
1393			 
1393			malloc_guard_exit: 
1393				push hl 
1393				push de 
1393				push af 
1393			 
1393			 	or a      ;clear carry flag 
1393				push hl 
1393				ld de, 255 
1393				sbc hl, de 
1393				jr c, .lowallocx 
1393			 
1393				push de 
1393					ld hl, display_fb0 
1393					ld (display_fb_active), hl 
1393				call clear_display 
1393				ld a, 0 
1393				ld de, .mallocasize 
1393				call str_at_display 
1393				call update_display 
1393				call delay1s 
1393				call delay1s 
1393			;	ld a, 0 
1393			;	ld (os_view_disable), a 
1393				call bp_on 
1393				pop de 
1393				pop hl 
1393			 
1393				CALLMONITOR 
1393				jr .lowdonex 
1393			.lowallocx: 
1393			 
1393				pop hl 
1393			.lowdonex:	pop af 
1393				pop de 
1393				pop hl 
1393			ret 
1393			endif 
1393			 
1393			if MALLOC_2 
1393			; Z80 Malloc and Free Functions 
1393			 
1393			; Malloc Function: 
1393			; Input: 
1393			;   HL: Size of block to allocate 
1393			; Output: 
1393			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1393			 
1393			malloc: 
1393				 
1393			if DEBUG_FORTH_MALLOC_HIGH 
1393			call malloc_guard_entry 
1393			endif 
1393			 
1393			 
1393			 
1393			 
1393					if DEBUG_FORTH_MALLOC 
1393						DMARK "mal" 
1393						CALLMONITOR 
1393					endif 
1393			    push af            ; Save AF register 
1393			    ld a, l            ; Load low byte of size into A 
1393			    or h               ; Check if size is zero 
1393			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1393			 
1393			    ; Allocate memory 
1393			    ld hl, (heap_start) ; Load start of heap into HL 
1393					if DEBUG_FORTH_MALLOC 
1393						DMARK "ma1" 
1393						CALLMONITOR 
1393					endif 
1393			    call malloc_internal ; Call internal malloc function 
1393			    pop af             ; Restore AF register 
1393			if DEBUG_FORTH_MALLOC_HIGH 
1393			call malloc_guard_exit 
1393			call malloc_guard_zerolen 
1393			endif 
1393			    ret                ; Return 
1393			 
1393			; Free Function: 
1393			; Input: 
1393			;   HL: Pointer to memory block to free 
1393			; Output: 
1393			;   None 
1393			 
1393			free: 
1393			    push af            ; Save AF register 
1393			    ld a, l            ; Load low byte of pointer into A 
1393			    or h               ; Check if pointer is NULL 
1393			    jp z, free_exit    ; If pointer is NULL, exit 
1393			 
1393			    ; Free memory 
1393			    ld hl, (heap_start) ; Load start of heap into HL 
1393			    call free_internal  ; Call internal free function 
1393			    pop af             ; Restore AF register 
1393			    ret                ; Return 
1393			 
1393			; Internal Malloc Function: 
1393			; Input: 
1393			;   HL: Size of block to allocate 
1393			; Output: 
1393			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1393			 
1393			malloc_internal: 
1393			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1393			    add hl, bc         ; Add management overhead to requested size 
1393			    ex de, hl          ; Save total size in DE, and keep it in HL 
1393					if DEBUG_FORTH_MALLOC 
1393						DMARK "ma2" 
1393						CALLMONITOR 
1393					endif 
1393			 
1393			    ; Search for free memory block 
1393			    ld de, (heap_end)  ; Load end of heap into DE 
1393			    ld bc, 0           ; Initialize counter 
1393			 
1393					if DEBUG_FORTH_MALLOC 
1393						DMARK "ma2" 
1393						CALLMONITOR 
1393					endif 
1393			malloc_search_loop: 
1393			    ; Check if current block is free 
1393			    ld a, (hl)         ; Load current block's status (free or used) 
1393			    cp 0               ; Compare with zero (free) 
1393			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1393			 
1393			    ; Check if current block is large enough 
1393			    ld a, (hl+1)       ; Load high byte of block size 
1393			    cp l               ; Compare with low byte of requested size 
1393			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1393			 
1393			    ld a, (hl+2)       ; Load low byte of block size 
1393			    cp h               ; Compare with high byte of requested size 
1393			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1393			 
1393			    ; Mark block as used 
1393			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1393			 
1393			    ; Calculate remaining space in block 
1393			    ld bc, 0           ; Clear BC 
1393			    add hl, bc         ; Increment HL to point to start of data block 
1393			    add hl, de         ; HL = HL + DE (total size) 
1393			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1393			    add hl, bc         ; Add management overhead to start of data block 
1393			 
1393			    ; Save pointer to allocated block in HL 
1393			if DEBUG_FORTH_MALLOC_HIGH 
1393						DMARK "ma5" 
1393			call malloc_guard_exit 
1393			call malloc_guard_zerolen 
1393			endif 
1393			    ret 
1393			 
1393			malloc_skip_block_check: 
1393			    ; Move to the next block 
1393			    ld bc, 3           ; Size of management overhead 
1393			    add hl, bc         ; Move to the next block 
1393			    inc de             ; Increment counter 
1393			 
1393			    ; Check if we have reached the end of heap 
1393			    ld a, e            ; Load low byte of heap end address 
1393			    cp (hl)            ; Compare with low byte of current address 
1393			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1393			    ld a, d            ; Load high byte of heap end address 
1393			    cp 0               ; Check if it's zero (end of memory) 
1393			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1393			 
1393			    ; If we reached here, allocation failed 
1393			    xor a              ; Set result to NULL 
1393			if DEBUG_FORTH_MALLOC_HIGH 
1393						DMARK "ma6" 
1393			call malloc_guard_exit 
1393			call malloc_guard_zerolen 
1393			endif 
1393			    ret 
1393			malloc_exit: 
1393			if DEBUG_FORTH_MALLOC_HIGH 
1393						DMARK "ma7" 
1393			call malloc_guard_exit 
1393			call malloc_guard_zerolen 
1393			endif 
1393			    ret 
1393			 
1393			; Internal Free Function: 
1393			; Input: 
1393			;   HL: Pointer to memory block to free 
1393			; Output: 
1393			;   None 
1393			 
1393			free_internal: 
1393			    ld de, (heap_start) ; Load start of heap into DE 
1393			    ld bc, 0            ; Initialize counter 
1393			 
1393			free_search_loop: 
1393			    ; Check if current block contains the pointer 
1393			    ld a, l             ; Load low byte of pointer 
1393			    cp (hl+1)           ; Compare with high byte of current block's address 
1393			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1393			    ld a, h             ; Load high byte of pointer 
1393			    cp (hl+2)           ; Compare with low byte of current block's address 
1393			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1393			 
1393			    ; Mark block as free 
1393			    ld (hl), 0          ; Set status byte to indicate free block 
1393			    ret                 ; Return 
1393			 
1393			free_skip_block_check: 
1393			    ; Move to the next block 
1393			    ld bc, 3            ; Size of management overhead 
1393			    add hl, bc          ; Move to the next block 
1393			    inc de              ; Increment counter 
1393			 
1393			    ; Check if we have reached the end of heap 
1393			    ld a, e             ; Load low byte of heap end address 
1393			    cp (hl)             ; Compare with low byte of current address 
1393			    jr nz, free_search_loop  ; If not equal, continue searching 
1393			    ld a, d             ; Load high byte of heap end address 
1393			    cp 0                ; Check if it's zero (end of memory) 
1393			    jr nz, free_search_loop  ; If not zero, continue searching 
1393			 
1393			    ; If we reached here, pointer is not found in heap 
1393			    ret 
1393			 
1393			free_exit: 
1393			    ret                 ; Return 
1393			 
1393			; Define heap start and end addresses 
1393			;heap_start:    .dw 0xC000   ; Start of heap 
1393			;heap_end:      .dw 0xE000   ; End of heap 
1393			 
1393			endif 
1393			 
1393			 
1393			if MALLOC_1 
1393			 
1393			 
1393			 
1393			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1393			 
1393			;moved to firmware.asm 
1393			;heap_start        .equ  0x9000      ; Starting address of heap 
1393			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1393			 
1393			;      .org 0 
1393			;      jp    main 
1393			 
1393			 
1393			;      .org  0x100 
1393			;main: 
1393			;      ld    HL, 0x8100 
1393			;      ld    SP, HL 
1393			; 
1393			;      call  heap_init 
1393			; 
1393			;      ; Make some allocations 
1393			;      ld    HL, 12 
1393			;      call  malloc            ; Allocates 0x9004 
1393			; 
1393			;      ld    HL, 12 
1393			;      call  malloc            ; Allocates 0x9014 
1393			; 
1393			;      ld    HL, 12 
1393			;      call  malloc            ; Allocates 0x9024 
1393			; 
1393			;      ; Free some allocations 
1393			;      ld    HL, 0x9014 
1393			;      call  free 
1393			; 
1393			;      ld    HL, 0x9004 
1393			;      call  free 
1393			; 
1393			;      ld    HL, 0x9024 
1393			;      call  free 
1393			; 
1393			; 
1393			;      halt 
1393			 
1393			 
1393			;------------------------------------------------------------------------------ 
1393			;     heap_init                                                               : 
1393			;                                                                             : 
1393			; Description                                                                 : 
1393			;     Initialise the heap and make it ready for malloc and free operations.   : 
1393			;                                                                             : 
1393			;     The heap is maintained as a linked list, starting with an initial       : 
1393			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1393			;     the first free block in the heap. Each block then points to the next    : 
1393			;     free block within the heap, and the free list ends at the first block   : 
1393			;     with a null pointer to the next free block.                             : 
1393			;                                                                             : 
1393			; Parameters                                                                  : 
1393			;     Inputs are compile-time only. Two defines which specify the starting    : 
1393			;     address of the heap and its size are required, along with a memory      : 
1393			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1393			;     principally stores a pointer to the first free block in the heap.       : 
1393			;                                                                             : 
1393			; Returns                                                                     : 
1393			;     Nothing                                                                 : 
1393			;------------------------------------------------------------------------------ 
1393			heap_init: 
1393 e5			      push  HL 
1394			 
1394			      ; Initialise free list struct 
1394 21 0e 80		      ld    HL, heap_start 
1397 22 0a 80		      ld    (free_list), HL 
139a 21 00 00		      ld    HL, 0 
139d 22 0c 80		      ld    (free_list+2), HL 
13a0			 
13a0			      ; Insert first free block at bottom of heap, consumes entire heap 
13a0 21 d3 f0		      ld    HL, heap_start+heap_size-4 
13a3 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
13a6 21 c5 70		      ld    HL, heap_size-4 
13a9 22 10 80		      ld    (heap_start+2), HL      ; Block size 
13ac			 
13ac			      ; Insert end of free list block at top of heap - two null words will 
13ac			      ; terminate the free list 
13ac 21 00 00		      ld    HL, 0 
13af 22 d5 f0		      ld    (heap_start+heap_size-2), HL 
13b2 22 d3 f0		      ld    (heap_start+heap_size-4), HL 
13b5			 
13b5 e1			      pop   HL 
13b6			 
13b6 c9			      ret 
13b7			 
13b7			 
13b7			;------------------------------------------------------------------------------ 
13b7			;     malloc                                                                  : 
13b7			;                                                                             : 
13b7			; Description                                                                 : 
13b7			;     Allocates the wanted space from the heap and returns the address of the : 
13b7			;     first useable byte of the allocation.                                   : 
13b7			;                                                                             : 
13b7			;     Allocations can happen in one of two ways:                              : 
13b7			;                                                                             : 
13b7			;     1. A free block may be found which is the exact size wanted. In this    : 
13b7			;        case the block is removed from the free list and retuedn to the      : 
13b7			;        caller.                                                              : 
13b7			;     2. A free block may be found which is larger than the size wanted. In   : 
13b7			;        this case, the larger block is split into two. The first portion of  : 
13b7			;        this block will become the requested space by the malloc call and    : 
13b7			;        is returned to the caller. The second portion becomes a new free     : 
13b7			;        block, and the free list is adjusted to maintain continuity via this : 
13b7			;        newly created block.                                                 : 
13b7			;                                                                             : 
13b7			;     malloc does not set any initial value in the allocated space, the       : 
13b7			;     caller is required to do this as required.                              : 
13b7			;                                                                             : 
13b7			;     This implementation of malloc uses the stack exclusively, and is        : 
13b7			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
13b7			;     advisable to disable interrupts before calling malloc, and recommended  : 
13b7			;     to avoid the use of malloc inside ISRs in general.                      : 
13b7			;                                                                             : 
13b7			;     NOTE: heap_init must be called before malloc and free can be used.      : 
13b7			;                                                                             : 
13b7			; Parameters                                                                  : 
13b7			;     HL  Number of bytes wanted                                              : 
13b7			;                                                                             : 
13b7			; Returns                                                                     : 
13b7			;     HL  Address of the first useable byte of the allocation                 : 
13b7			;                                                                             : 
13b7			; Flags                                                                       : 
13b7			;     Z   Set if the allocation did not succeed, clear otherwise              : 
13b7			;                                                                             : 
13b7			; Stack frame                                                                 : 
13b7			;       |             |                                                       : 
13b7			;       +-------------+                                                       : 
13b7			;       |     BC      |                                                       : 
13b7			;       +-------------+                                                       : 
13b7			;       |     DE      |                                                       : 
13b7			;       +-------------+                                                       : 
13b7			;       |     IX      |                                                       : 
13b7			;       +-------------+                                                       : 
13b7			;       |  prev_free  |                                                       : 
13b7			;   +4  +-------------+                                                       : 
13b7			;       |  this_free  |                                                       : 
13b7			;   +2  +-------------+                                                       : 
13b7			;       |  next_free  |                                                       : 
13b7			;   +0  +-------------+                                                       : 
13b7			;       |             |                                                       : 
13b7			;                                                                             : 
13b7			;------------------------------------------------------------------------------ 
13b7			 
13b7			 
13b7			;malloc: 
13b7			; 
13b7			;	SAVESP ON 1 
13b7			; 
13b7			;	call malloc_code 
13b7			; 
13b7			;	CHECKSP ON 1 
13b7			;	ret 
13b7			 
13b7			 
13b7			malloc: 
13b7 c5			      push  BC 
13b8 d5			      push  DE 
13b9 dd e5		      push  IX 
13bb			if DEBUG_FORTH_MALLOC_HIGH 
13bb			call malloc_guard_entry 
13bb			endif 
13bb			 
13bb					if DEBUG_FORTH_MALLOC 
13bb						DMARK "mal" 
13bb						CALLMONITOR 
13bb					endif 
13bb 7c			      ld    A, H                    ; Exit if no space requested 
13bc b5			      or    L 
13bd ca 7c 14		      jp    Z, malloc_early_exit 
13c0			 
13c0			;inc hl 
13c0			;inc hl 
13c0			;inc hl 
13c0			; 
13c0			;inc hl 
13c0			;inc hl 
13c0			;inc hl 
13c0			;inc hl 
13c0			;inc hl 
13c0			;inc hl 
13c0			;inc hl 
13c0			;inc hl 
13c0			;inc hl 
13c0			 
13c0			 
13c0			 
13c0			 
13c0					if DEBUG_FORTH_MALLOC 
13c0						DMARK "maA" 
13c0						CALLMONITOR 
13c0					endif 
13c0			      ; Set up stack frame 
13c0 eb			      ex    DE, HL 
13c1 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
13c4 39			      add   HL, SP 
13c5 f9			      ld    SP, HL 
13c6 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
13ca dd 39		      add   IX, SP 
13cc			 
13cc			      ; Setup initial state 
13cc 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
13cf 19			      add   HL, DE 
13d0			 
13d0 44			      ld    B, H                    ; Move want to BC 
13d1 4d			      ld    C, L 
13d2			 
13d2 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
13d5 dd 75 04		      ld    (IX+4), L 
13d8 dd 74 05		      ld    (IX+5), H 
13db			 
13db 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
13dc 23			      inc   HL 
13dd 56			      ld    D, (HL) 
13de dd 73 02		      ld    (IX+2), E 
13e1 dd 72 03		      ld    (IX+3), D 
13e4 eb			      ex    DE, HL                  ; this_free ptr into HL 
13e5			 
13e5					if DEBUG_FORTH_MALLOC 
13e5						DMARK "maB" 
13e5						CALLMONITOR 
13e5					endif 
13e5			      ; Loop through free block list to find some space 
13e5			malloc_find_space: 
13e5 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
13e6 23			      inc   HL 
13e7 56			      ld    D, (HL) 
13e8			 
13e8 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13e9 b3			      or    E 
13ea ca 76 14		      jp    Z, malloc_no_space 
13ed			 
13ed dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
13f0 dd 72 01		      ld    (IX+1), D 
13f3			 
13f3			      ; Does this block have enough space to make the allocation? 
13f3 23			      inc   HL                      ; Load free block size into DE 
13f4 5e			      ld    E, (HL) 
13f5 23			      inc   HL 
13f6 56			      ld    D, (HL) 
13f7			 
13f7 eb			      ex    DE, HL                  ; Check size of block against want 
13f8 b7			      or    A                       ; Ensure carry flag clear 
13f9 ed 42		      sbc   HL, BC 
13fb e5			      push  HL                      ; Store the result for later (new block size) 
13fc			 
13fc ca 4b 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
13ff 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1401			 
1401			      ; this_free block is not big enough, setup ptrs to test next free block 
1401 e1			      pop   HL                      ; Discard previous result 
1402			 
1402 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1405 dd 66 03		      ld    H, (IX+3) 
1408 dd 75 04		      ld    (IX+4), L 
140b dd 74 05		      ld    (IX+5), H 
140e			 
140e dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1411 dd 66 01		      ld    H, (IX+1) 
1414 dd 75 02		      ld    (IX+2), L 
1417 dd 74 03		      ld    (IX+3), H 
141a			 
141a					if DEBUG_FORTH_MALLOC 
141a						DMARK "MA>" 
141a						CALLMONITOR 
141a					endif 
141a 18 c9		      jr    malloc_find_space 
141c			 
141c			      ; split a bigger block into two - requested size and remaining size 
141c			malloc_alloc_split: 
141c					if DEBUG_FORTH_MALLOC 
141c						DMARK "MAs" 
141c						CALLMONITOR 
141c					endif 
141c eb			      ex    DE, HL                  ; Calculate address of new free block 
141d 2b			      dec   HL 
141e 2b			      dec   HL 
141f 2b			      dec   HL 
1420 09			      add   HL, BC 
1421			 
1421			      ; Create a new block and point it at next_free 
1421 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1424 dd 56 01		      ld    D, (IX+1) 
1427			 
1427 73			      ld    (HL), E                 ; Store next_free ptr into new block 
1428 23			      inc   HL 
1429 72			      ld    (HL), D 
142a			 
142a d1			      pop   DE                      ; Store size of new block into new block 
142b 23			      inc   HL 
142c 73			      ld    (HL), E 
142d 23			      inc   HL 
142e 72			      ld    (HL), D 
142f			 
142f			      ; Update this_free ptr to point to new block 
142f 2b			      dec   HL 
1430 2b			      dec   HL 
1431 2b			      dec   HL 
1432			 
1432 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1435 dd 56 03		      ld    D, (IX+3) 
1438			 
1438 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
143b dd 74 03		      ld    (IX+3), H 
143e			 
143e			      ; Modify this_free block to be allocation 
143e eb			      ex    DE, HL 
143f af			      xor   A                       ; Null the next block ptr of allocated block 
1440 77			      ld    (HL), A 
1441 23			      inc   HL 
1442 77			      ld    (HL), A 
1443			 
1443 23			      inc   HL                      ; Store want size into allocated block 
1444 71			      ld    (HL), C 
1445 23			      inc   HL 
1446 70			      ld    (HL), B 
1447 23			      inc   HL 
1448 e5			      push  HL                      ; Address of allocation to return 
1449			 
1449 18 19		      jr    malloc_update_links 
144b			 
144b			malloc_alloc_fit: 
144b e1			      pop   HL                      ; Dont need new block size, want is exact fit 
144c			 
144c					if DEBUG_FORTH_MALLOC 
144c						DMARK "MAf" 
144c						CALLMONITOR 
144c					endif 
144c			      ; Modify this_free block to be allocation 
144c eb			      ex    DE, HL 
144d 2b			      dec   HL 
144e 2b			      dec   HL 
144f 2b			      dec   HL 
1450			 
1450 af			      xor   A                       ; Null the next block ptr of allocated block 
1451 77			      ld    (HL), A 
1452 23			      inc   HL 
1453 77			      ld    (HL), A 
1454			 
1454 23			      inc   HL                      ; Store address of allocation to return 
1455 23			      inc   HL 
1456 23			      inc   HL 
1457 e5			      push  HL 
1458			 
1458			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1458 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
145b dd 66 01		      ld    H, (IX+1) 
145e			 
145e dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1461 dd 74 03		      ld    (IX+3), H 
1464			 
1464			 
1464			malloc_update_links: 
1464			      ; Update prev_free ptr to point to this_free 
1464 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1467 dd 66 05		      ld    H, (IX+5) 
146a			 
146a dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
146d dd 56 03		      ld    D, (IX+3) 
1470			 
1470 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1471 23			      inc   HL 
1472 72			      ld    (HL), D 
1473			 
1473					if DEBUG_FORTH_MALLOC 
1473						DMARK "Mul" 
1473						CALLMONITOR 
1473					endif 
1473			      ; Clear the Z flag to indicate successful allocation 
1473 7a			      ld    A, D 
1474 b3			      or    E 
1475			 
1475 d1			      pop   DE                      ; Address of allocation 
1476					if DEBUG_FORTH_MALLOC 
1476						DMARK "MAu" 
1476						CALLMONITOR 
1476					endif 
1476			 
1476			malloc_no_space: 
1476 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
1479 39			      add   HL, SP 
147a f9			      ld    SP, HL 
147b			 
147b eb			      ex    DE, HL                  ; Alloc addr into HL for return 
147c					if DEBUG_FORTH_MALLOC 
147c						DMARK "MAN" 
147c						CALLMONITOR 
147c					endif 
147c			 
147c			malloc_early_exit: 
147c					if DEBUG_FORTH_MALLOC 
147c						DMARK "MAx" 
147c						CALLMONITOR 
147c					endif 
147c dd e1		      pop   IX 
147e d1			      pop   DE 
147f c1			      pop   BC 
1480			 
1480			if DEBUG_FORTH_MALLOC_HIGH 
1480			call malloc_guard_exit 
1480			call malloc_guard_zerolen 
1480			endif 
1480 c9			      ret 
1481			 
1481			 
1481			;------------------------------------------------------------------------------ 
1481			;     free                                                                    : 
1481			;                                                                             : 
1481			; Description                                                                 : 
1481			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1481			;     returned by malloc, otherwise the behaviour is undefined.               : 
1481			;                                                                             : 
1481			;     Where possible, directly adjacent free blocks will be merged together   : 
1481			;     into larger blocks to help ensure that the heap does not become         : 
1481			;     excessively fragmented.                                                 : 
1481			;                                                                             : 
1481			;     free does not clear or set any other value into the freed space, and    : 
1481			;     therefore its contents may be visible through subsequent malloc's. The  : 
1481			;     caller should clear the freed space as required.                        : 
1481			;                                                                             : 
1481			;     This implementation of free uses the stack exclusively, and is          : 
1481			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1481			;     advisable to disable interrupts before calling free, and recommended    : 
1481			;     to avoid the use of free inside ISRs in general.                        : 
1481			;                                                                             : 
1481			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1481			;                                                                             : 
1481			; Parameters                                                                  : 
1481			;     HL  Pointer to address of first byte of allocation to be freed          : 
1481			;                                                                             : 
1481			; Returns                                                                     : 
1481			;     Nothing                                                                 : 
1481			;                                                                             : 
1481			; Stack frame                                                                 : 
1481			;       |             |                                                       : 
1481			;       +-------------+                                                       : 
1481			;       |     BC      |                                                       : 
1481			;       +-------------+                                                       : 
1481			;       |     DE      |                                                       : 
1481			;       +-------------+                                                       : 
1481			;       |     IX      |                                                       : 
1481			;       +-------------+                                                       : 
1481			;       |  prev_free  |                                                       : 
1481			;   +2  +-------------+                                                       : 
1481			;       |  next_free  |                                                       : 
1481			;   +0  +-------------+                                                       : 
1481			;       |             |                                                       : 
1481			;                                                                             : 
1481			;------------------------------------------------------------------------------ 
1481			free: 
1481 c5			      push  BC 
1482 d5			      push  DE 
1483 dd e5		      push  IX 
1485			 
1485 7c			      ld    A, H                    ; Exit if ptr is null 
1486 b5			      or    L 
1487 ca 4b 15		      jp    Z, free_early_exit 
148a			 
148a			      ; Set up stack frame 
148a eb			      ex    DE, HL 
148b 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
148e 39			      add   HL, SP 
148f f9			      ld    SP, HL 
1490 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1494 dd 39		      add   IX, SP 
1496			 
1496			      ; The address in HL points to the start of the useable allocated space, 
1496			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1496			      ; address of the block itself. 
1496 eb			      ex    DE, HL 
1497 11 fc ff		      ld    DE, -4 
149a 19			      add   HL, DE 
149b			 
149b			      ; An allocated block must have a null next block pointer in it 
149b 7e			      ld    A, (HL) 
149c 23			      inc   HL 
149d b6			      or    (HL) 
149e c2 46 15		      jp    NZ, free_done 
14a1			 
14a1 2b			      dec   HL 
14a2			 
14a2 44			      ld    B, H                    ; Copy HL to BC 
14a3 4d			      ld    C, L 
14a4			 
14a4			      ; Loop through the free list to find the first block with an address 
14a4			      ; higher than the block being freed 
14a4 21 0a 80		      ld    HL, free_list 
14a7			 
14a7			free_find_higher_block: 
14a7 5e			      ld    E, (HL)                 ; Load next ptr from free block 
14a8 23			      inc   HL 
14a9 56			      ld    D, (HL) 
14aa 2b			      dec   HL 
14ab			 
14ab dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
14ae dd 72 01		      ld    (IX+1), D 
14b1 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
14b4 dd 74 03		      ld    (IX+3), H 
14b7			 
14b7 78			      ld    A, B                    ; Check if DE is greater than BC 
14b8 ba			      cp    D                       ; Compare MSB first 
14b9 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
14bb 30 04		      jr    NC, free_find_higher_block_skip 
14bd 79			      ld    A, C 
14be bb			      cp    E                       ; Then compare LSB 
14bf 38 08		      jr    C, free_found_higher_block 
14c1			 
14c1			free_find_higher_block_skip: 
14c1 7a			      ld    A, D                    ; Reached the end of the free list? 
14c2 b3			      or    E 
14c3 ca 46 15		      jp    Z, free_done 
14c6			 
14c6 eb			      ex    DE, HL 
14c7			 
14c7 18 de		      jr    free_find_higher_block 
14c9			 
14c9			free_found_higher_block: 
14c9			      ; Insert freed block between prev and next free blocks 
14c9 71			      ld    (HL), C                 ; Point prev free block to freed block 
14ca 23			      inc   HL 
14cb 70			      ld    (HL), B 
14cc			 
14cc 60			      ld    H, B                    ; Point freed block at next free block 
14cd 69			      ld    L, C 
14ce 73			      ld    (HL), E 
14cf 23			      inc   HL 
14d0 72			      ld    (HL), D 
14d1			 
14d1			      ; Check if the freed block is adjacent to the next free block 
14d1 23			      inc   HL                      ; Load size of freed block into HL 
14d2 5e			      ld    E, (HL) 
14d3 23			      inc   HL 
14d4 56			      ld    D, (HL) 
14d5 eb			      ex    DE, HL 
14d6			 
14d6 09			      add   HL, BC                  ; Add addr of freed block and its size 
14d7			 
14d7 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
14da dd 56 01		      ld    D, (IX+1) 
14dd			 
14dd b7			      or    A                       ; Clear the carry flag 
14de ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
14e0 20 22		      jr    NZ, free_check_adjacent_to_prev 
14e2			 
14e2			      ; Freed block is adjacent to next, merge into one bigger block 
14e2 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
14e3 5e			      ld    E, (HL) 
14e4 23			      inc   HL 
14e5 56			      ld    D, (HL) 
14e6 e5			      push  HL                      ; Save ptr to next block for later 
14e7			 
14e7 60			      ld    H, B                    ; Store ptr from next block into freed block 
14e8 69			      ld    L, C 
14e9 73			      ld    (HL), E 
14ea 23			      inc   HL 
14eb 72			      ld    (HL), D 
14ec			 
14ec e1			      pop   HL                      ; Restore ptr to next block 
14ed 23			      inc   HL                      ; Load size of next block into DE 
14ee 5e			      ld    E, (HL) 
14ef 23			      inc   HL 
14f0 56			      ld    D, (HL) 
14f1 d5			      push  DE                      ; Save next block size for later 
14f2			 
14f2 60			      ld    H, B                    ; Load size of freed block into HL 
14f3 69			      ld    L, C 
14f4 23			      inc   HL 
14f5 23			      inc   HL 
14f6 5e			      ld    E, (HL) 
14f7 23			      inc   HL 
14f8 56			      ld    D, (HL) 
14f9 eb			      ex    DE, HL 
14fa			 
14fa d1			      pop   DE                      ; Restore size of next block 
14fb 19			      add   HL, DE                  ; Add sizes of both blocks 
14fc eb			      ex    DE, HL 
14fd			 
14fd 60			      ld    H, B                    ; Store new bigger size into freed block 
14fe 69			      ld    L, C 
14ff 23			      inc   HL 
1500 23			      inc   HL 
1501 73			      ld    (HL), E 
1502 23			      inc   HL 
1503 72			      ld    (HL), D 
1504			 
1504			free_check_adjacent_to_prev: 
1504			      ; Check if the freed block is adjacent to the prev free block 
1504 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1507 dd 66 03		      ld    H, (IX+3) 
150a			 
150a 23			      inc   HL                      ; Size of prev free block into DE 
150b 23			      inc   HL 
150c 5e			      ld    E, (HL) 
150d 23			      inc   HL 
150e 56			      ld    D, (HL) 
150f 2b			      dec   HL 
1510 2b			      dec   HL 
1511 2b			      dec   HL 
1512			 
1512 19			      add   HL, DE                  ; Add prev block addr and size 
1513			 
1513 b7			      or    A                       ; Clear the carry flag 
1514 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1516 20 2e		      jr    NZ, free_done 
1518			 
1518			      ; Freed block is adjacent to prev, merge into one bigger block 
1518 60			      ld    H, B                    ; Load next ptr from freed block into DE 
1519 69			      ld    L, C 
151a 5e			      ld    E, (HL) 
151b 23			      inc   HL 
151c 56			      ld    D, (HL) 
151d e5			      push  HL                      ; Save freed block ptr for later 
151e			 
151e dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1521 dd 66 03		      ld    H, (IX+3) 
1524 73			      ld    (HL), E 
1525 23			      inc   HL 
1526 72			      ld    (HL), D 
1527			 
1527 e1			      pop   HL                      ; Restore freed block ptr 
1528 23			      inc   HL                      ; Load size of freed block into DE 
1529 5e			      ld    E, (HL) 
152a 23			      inc   HL 
152b 56			      ld    D, (HL) 
152c d5			      push  DE                      ; Save freed block size for later 
152d			 
152d dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1530 dd 66 03		      ld    H, (IX+3) 
1533 23			      inc   HL 
1534 23			      inc   HL 
1535 5e			      ld    E, (HL) 
1536 23			      inc   HL 
1537 56			      ld    D, (HL) 
1538			 
1538 e1			      pop   HL                      ; Add sizes of both blocks 
1539 19			      add   HL, DE 
153a eb			      ex    DE, HL 
153b			 
153b dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
153e dd 66 03		      ld    H, (IX+3) 
1541 23			      inc   HL 
1542 23			      inc   HL 
1543 73			      ld    (HL), E 
1544 23			      inc   HL 
1545 72			      ld    (HL), D 
1546			 
1546			free_done: 
1546 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
1549 39			      add   HL, SP 
154a f9			      ld    SP, HL 
154b			 
154b			free_early_exit: 
154b dd e1		      pop   IX 
154d d1			      pop   DE 
154e c1			      pop   BC 
154f			 
154f c9			      ret 
1550			 
1550			; moved to firmware.asm 
1550			; 
1550			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1550			;                  .dw   0 
1550			 
1550			 
1550			endif 
1550			 
1550			 
1550			if MALLOC_3 
1550			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1550			;heap_start        .equ  0x9000      ; Starting address of heap 
1550			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1550			; 
1550			 ;     .org 0 
1550			  ;    jp    main 
1550			; 
1550			; 
1550			 ;     .org  0x100 
1550			;main: 
1550			 ;     ld    HL, 0x8100 
1550			  ;    ld    SP, HL 
1550			; 
1550			;      call  heap_init 
1550			 
1550			      ; Make some allocations 
1550			;      ld    HL, 12 
1550			;      call  malloc            ; Allocates 0x9004 
1550			; 
1550			 ;     ld    HL, 12 
1550			;      call  malloc            ; Allocates 0x9014 
1550			 
1550			;      ld    HL, 12 
1550			;      call  malloc            ; Allocates 0x9024 
1550			 
1550			      ; Free some allocations 
1550			;      ld    HL, 0x9014 
1550			;      call  free 
1550			 
1550			;      ld    HL, 0x9004 
1550			;      call  free 
1550			; 
1550			;      ld    HL, 0x9024 
1550			;      call  free 
1550			 
1550			 
1550			 ;     halt 
1550			 
1550			 
1550			;------------------------------------------------------------------------------ 
1550			;     heap_init                                                               : 
1550			;                                                                             : 
1550			; Description                                                                 : 
1550			;     Initialise the heap and make it ready for malloc and free operations.   : 
1550			;                                                                             : 
1550			;     The heap is maintained as a linked list, starting with an initial       : 
1550			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1550			;     the first free block in the heap. Each block then points to the next    : 
1550			;     free block within the heap, and the free list ends at the first block   : 
1550			;     with a null pointer to the next free block.                             : 
1550			;                                                                             : 
1550			; Parameters                                                                  : 
1550			;     Inputs are compile-time only. Two defines which specify the starting    : 
1550			;     address of the heap and its size are required, along with a memory      : 
1550			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1550			;     principally stores a pointer to the first free block in the heap.       : 
1550			;                                                                             : 
1550			; Returns                                                                     : 
1550			;     Nothing                                                                 : 
1550			;------------------------------------------------------------------------------ 
1550			heap_init: 
1550			      push  HL 
1550			 
1550			      ; Initialise free list struct 
1550			      ld    HL, heap_start 
1550			      ld    (free_list), HL 
1550			      ld    HL, 0 
1550			      ld    (free_list+2), HL 
1550			 
1550			      ; Insert first free block at bottom of heap, consumes entire heap 
1550			      ld    HL, heap_start+heap_size-4 
1550			      ld    (heap_start), HL        ; Next block (end of free list) 
1550			      ld    HL, heap_size-4 
1550			      ld    (heap_start+2), HL      ; Block size 
1550			 
1550			      ; Insert end of free list block at top of heap - two null words will 
1550			      ; terminate the free list 
1550			      ld    HL, 0 
1550			      ld    (heap_start+heap_size-2), HL 
1550			      ld    (heap_start+heap_size-4), HL 
1550			 
1550			      pop   HL 
1550			 
1550			      ret 
1550			 
1550			 
1550			;------------------------------------------------------------------------------ 
1550			;     malloc                                                                  : 
1550			;                                                                             : 
1550			; Description                                                                 : 
1550			;     Allocates the wanted space from the heap and returns the address of the : 
1550			;     first useable byte of the allocation.                                   : 
1550			;                                                                             : 
1550			;     Allocations can happen in one of two ways:                              : 
1550			;                                                                             : 
1550			;     1. A free block may be found which is the exact size wanted. In this    : 
1550			;        case the block is removed from the free list and retuedn to the      : 
1550			;        caller.                                                              : 
1550			;     2. A free block may be found which is larger than the size wanted. In   : 
1550			;        this case, the larger block is split into two. The first portion of  : 
1550			;        this block will become the requested space by the malloc call and    : 
1550			;        is returned to the caller. The second portion becomes a new free     : 
1550			;        block, and the free list is adjusted to maintain continuity via this : 
1550			;        newly created block.                                                 : 
1550			;                                                                             : 
1550			;     malloc does not set any initial value in the allocated space, the       : 
1550			;     caller is required to do this as required.                              : 
1550			;                                                                             : 
1550			;     This implementation of malloc uses the stack exclusively, and is        : 
1550			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1550			;     advisable to disable interrupts before calling malloc, and recommended  : 
1550			;     to avoid the use of malloc inside ISRs in general.                      : 
1550			;                                                                             : 
1550			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1550			;                                                                             : 
1550			; Parameters                                                                  : 
1550			;     HL  Number of bytes wanted                                              : 
1550			;                                                                             : 
1550			; Returns                                                                     : 
1550			;     HL  Address of the first useable byte of the allocation                 : 
1550			;                                                                             : 
1550			; Flags                                                                       : 
1550			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1550			;                                                                             : 
1550			; Stack frame                                                                 : 
1550			;       |             |                                                       : 
1550			;       +-------------+                                                       : 
1550			;       |     BC      |                                                       : 
1550			;       +-------------+                                                       : 
1550			;       |     DE      |                                                       : 
1550			;       +-------------+                                                       : 
1550			;       |     IX      |                                                       : 
1550			;       +-------------+                                                       : 
1550			;       |  prev_free  |                                                       : 
1550			;   +4  +-------------+                                                       : 
1550			;       |  this_free  |                                                       : 
1550			;   +2  +-------------+                                                       : 
1550			;       |  next_free  |                                                       : 
1550			;   +0  +-------------+                                                       : 
1550			;       |             |                                                       : 
1550			;                                                                             : 
1550			;------------------------------------------------------------------------------ 
1550			malloc: 
1550			      push  BC 
1550			      push  DE 
1550			      push  IX 
1550			 
1550			      ld    A, H                    ; Exit if no space requested 
1550			      or    L 
1550			      jp    Z, malloc_early_exit 
1550			 
1550			      ; Set up stack frame 
1550			      ex    DE, HL 
1550			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1550			      add   HL, SP 
1550			      ld    SP, HL 
1550			      ld    IX, 0                   ; Use IX as a frame pointer 
1550			      add   IX, SP 
1550			 
1550			      ; Setup initial state 
1550			      ld    HL, 4                   ; want must also include space used by block struct 
1550			      add   HL, DE 
1550			 
1550			      ld    B, H                    ; Move want to BC 
1550			      ld    C, L 
1550			 
1550			      ld    HL, free_list           ; Store prev_free ptr to stack 
1550			      ld    (IX+4), L 
1550			      ld    (IX+5), H 
1550			 
1550			      ld    E, (HL)                 ; Store this_free ptr to stack 
1550			      inc   HL 
1550			      ld    D, (HL) 
1550			      ld    (IX+2), E 
1550			      ld    (IX+3), D 
1550			      ex    DE, HL                  ; this_free ptr into HL 
1550			 
1550			      ; Loop through free block list to find some space 
1550			malloc_find_space: 
1550			      ld    E, (HL)                 ; Load next_free ptr into DE 
1550			      inc   HL 
1550			      ld    D, (HL) 
1550			 
1550			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1550			      or    E 
1550			      jp    Z, malloc_no_space 
1550			 
1550			      ld    (IX+0), E               ; Store next_free ptr to stack 
1550			      ld    (IX+1), D 
1550			 
1550			      ; Does this block have enough space to make the allocation? 
1550			      inc   HL                      ; Load free block size into DE 
1550			      ld    E, (HL) 
1550			      inc   HL 
1550			      ld    D, (HL) 
1550			 
1550			      ex    DE, HL                  ; Check size of block against want 
1550			      or    A                       ; Ensure carry flag clear 
1550			      sbc   HL, BC 
1550			      push  HL                      ; Store the result for later (new block size) 
1550			 
1550			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1550			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1550			 
1550			      ; this_free block is not big enough, setup ptrs to test next free block 
1550			      pop   HL                      ; Discard previous result 
1550			 
1550			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1550			      ld    H, (IX+3) 
1550			      ld    (IX+4), L 
1550			      ld    (IX+5), H 
1550			 
1550			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1550			      ld    H, (IX+1) 
1550			      ld    (IX+2), L 
1550			      ld    (IX+3), H 
1550			 
1550			      jr    malloc_find_space 
1550			 
1550			      ; split a bigger block into two - requested size and remaining size 
1550			malloc_alloc_split: 
1550			      ex    DE, HL                  ; Calculate address of new free block 
1550			      dec   HL 
1550			      dec   HL 
1550			      dec   HL 
1550			      add   HL, BC 
1550			 
1550			      ; Create a new block and point it at next_free 
1550			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1550			      ld    D, (IX+1) 
1550			 
1550			      ld    (HL), E                 ; Store next_free ptr into new block 
1550			      inc   HL 
1550			      ld    (HL), D 
1550			 
1550			      pop   DE                      ; Store size of new block into new block 
1550			      inc   HL 
1550			      ld    (HL), E 
1550			      inc   HL 
1550			      ld    (HL), D 
1550			 
1550			      ; Update this_free ptr to point to new block 
1550			      dec   HL 
1550			      dec   HL 
1550			      dec   HL 
1550			 
1550			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1550			      ld    D, (IX+3) 
1550			 
1550			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1550			      ld    (IX+3), H 
1550			 
1550			      ; Modify this_free block to be allocation 
1550			      ex    DE, HL 
1550			      xor   A                       ; Null the next block ptr of allocated block 
1550			      ld    (HL), A 
1550			      inc   HL 
1550			      ld    (HL), A 
1550			 
1550			      inc   HL                      ; Store want size into allocated block 
1550			      ld    (HL), C 
1550			      inc   HL 
1550			      ld    (HL), B 
1550			      inc   HL 
1550			      push  HL                      ; Address of allocation to return 
1550			 
1550			      jr    malloc_update_links 
1550			 
1550			malloc_alloc_fit: 
1550			      pop   HL                      ; Dont need new block size, want is exact fit 
1550			 
1550			      ; Modify this_free block to be allocation 
1550			      ex    DE, HL 
1550			      dec   HL 
1550			      dec   HL 
1550			      dec   HL 
1550			 
1550			      xor   A                       ; Null the next block ptr of allocated block 
1550			      ld    (HL), A 
1550			      inc   HL 
1550			      ld    (HL), A 
1550			 
1550			      inc   HL                      ; Store address of allocation to return 
1550			      inc   HL 
1550			      inc   HL 
1550			      push  HL 
1550			 
1550			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1550			      ld    L, (IX+0)               ; next_free to HL 
1550			      ld    H, (IX+1) 
1550			 
1550			      ld    (IX+2), L               ; HL to this_free 
1550			      ld    (IX+3), H 
1550			 
1550			 
1550			malloc_update_links: 
1550			      ; Update prev_free ptr to point to this_free 
1550			      ld    L, (IX+4)               ; prev_free ptr to HL 
1550			      ld    H, (IX+5) 
1550			 
1550			      ld    E, (IX+2)               ; this_free ptr to DE 
1550			      ld    D, (IX+3) 
1550			 
1550			      ld    (HL), E                 ; this_free ptr into prev_free 
1550			      inc   HL 
1550			      ld    (HL), D 
1550			 
1550			      ; Clear the Z flag to indicate successful allocation 
1550			      ld    A, D 
1550			      or    E 
1550			 
1550			      pop   DE                      ; Address of allocation 
1550			 
1550			malloc_no_space: 
1550			      ld    HL, 6                   ; Clean up stack frame 
1550			      add   HL, SP 
1550			      ld    SP, HL 
1550			 
1550			      ex    DE, HL                  ; Alloc addr into HL for return 
1550			 
1550			malloc_early_exit: 
1550			      pop   IX 
1550			      pop   DE 
1550			      pop   BC 
1550			 
1550			      ret 
1550			 
1550			 
1550			;------------------------------------------------------------------------------ 
1550			;     free                                                                    : 
1550			;                                                                             : 
1550			; Description                                                                 : 
1550			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1550			;     returned by malloc, otherwise the behaviour is undefined.               : 
1550			;                                                                             : 
1550			;     Where possible, directly adjacent free blocks will be merged together   : 
1550			;     into larger blocks to help ensure that the heap does not become         : 
1550			;     excessively fragmented.                                                 : 
1550			;                                                                             : 
1550			;     free does not clear or set any other value into the freed space, and    : 
1550			;     therefore its contents may be visible through subsequent malloc's. The  : 
1550			;     caller should clear the freed space as required.                        : 
1550			;                                                                             : 
1550			;     This implementation of free uses the stack exclusively, and is          : 
1550			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1550			;     advisable to disable interrupts before calling free, and recommended    : 
1550			;     to avoid the use of free inside ISRs in general.                        : 
1550			;                                                                             : 
1550			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1550			;                                                                             : 
1550			; Parameters                                                                  : 
1550			;     HL  Pointer to address of first byte of allocation to be freed          : 
1550			;                                                                             : 
1550			; Returns                                                                     : 
1550			;     Nothing                                                                 : 
1550			;                                                                             : 
1550			; Stack frame                                                                 : 
1550			;       |             |                                                       : 
1550			;       +-------------+                                                       : 
1550			;       |     BC      |                                                       : 
1550			;       +-------------+                                                       : 
1550			;       |     DE      |                                                       : 
1550			;       +-------------+                                                       : 
1550			;       |     IX      |                                                       : 
1550			;       +-------------+                                                       : 
1550			;       |  prev_free  |                                                       : 
1550			;   +2  +-------------+                                                       : 
1550			;       |  next_free  |                                                       : 
1550			;   +0  +-------------+                                                       : 
1550			;       |             |                                                       : 
1550			;                                                                             : 
1550			;------------------------------------------------------------------------------ 
1550			free: 
1550			      push  BC 
1550			      push  DE 
1550			      push  IX 
1550			 
1550			      ld    A, H                    ; Exit if ptr is null 
1550			      or    L 
1550			      jp    Z, free_early_exit 
1550			 
1550			      ; Set up stack frame 
1550			      ex    DE, HL 
1550			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1550			      add   HL, SP 
1550			      ld    SP, HL 
1550			      ld    IX, 0                   ; Use IX as a frame pointer 
1550			      add   IX, SP 
1550			 
1550			      ; The address in HL points to the start of the useable allocated space, 
1550			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1550			      ; address of the block itself. 
1550			      ex    DE, HL 
1550			      ld    DE, -4 
1550			      add   HL, DE 
1550			 
1550			      ; An allocated block must have a null next block pointer in it 
1550			      ld    A, (HL) 
1550			      inc   HL 
1550			      or    (HL) 
1550			      jp    NZ, free_done 
1550			 
1550			      dec   HL 
1550			 
1550			      ld    B, H                    ; Copy HL to BC 
1550			      ld    C, L 
1550			 
1550			      ; Loop through the free list to find the first block with an address 
1550			      ; higher than the block being freed 
1550			      ld    HL, free_list 
1550			 
1550			free_find_higher_block: 
1550			      ld    E, (HL)                 ; Load next ptr from free block 
1550			      inc   HL 
1550			      ld    D, (HL) 
1550			      dec   HL 
1550			 
1550			      ld    (IX+0), E               ; Save ptr to next free block 
1550			      ld    (IX+1), D 
1550			      ld    (IX+2), L               ; Save ptr to prev free block 
1550			      ld    (IX+3), H 
1550			 
1550			      ld    A, B                    ; Check if DE is greater than BC 
1550			      cp    D                       ; Compare MSB first 
1550			      jr    Z, $+4                  ; MSB the same, compare LSB 
1550			      jr    NC, free_find_higher_block_skip 
1550			      ld    A, C 
1550			      cp    E                       ; Then compare LSB 
1550			      jr    C, free_found_higher_block 
1550			 
1550			free_find_higher_block_skip: 
1550			      ld    A, D                    ; Reached the end of the free list? 
1550			      or    E 
1550			      jp    Z, free_done 
1550			 
1550			      ex    DE, HL 
1550			 
1550			      jr    free_find_higher_block 
1550			 
1550			free_found_higher_block: 
1550			      ; Insert freed block between prev and next free blocks 
1550			      ld    (HL), C                 ; Point prev free block to freed block 
1550			      inc   HL 
1550			      ld    (HL), B 
1550			 
1550			      ld    H, B                    ; Point freed block at next free block 
1550			      ld    L, C 
1550			      ld    (HL), E 
1550			      inc   HL 
1550			      ld    (HL), D 
1550			 
1550			      ; Check if the freed block is adjacent to the next free block 
1550			      inc   HL                      ; Load size of freed block into HL 
1550			      ld    E, (HL) 
1550			      inc   HL 
1550			      ld    D, (HL) 
1550			      ex    DE, HL 
1550			 
1550			      add   HL, BC                  ; Add addr of freed block and its size 
1550			 
1550			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1550			      ld    D, (IX+1) 
1550			 
1550			      or    A                       ; Clear the carry flag 
1550			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1550			      jr    NZ, free_check_adjacent_to_prev 
1550			 
1550			      ; Freed block is adjacent to next, merge into one bigger block 
1550			      ex    DE, HL                  ; Load next ptr from next block into DE 
1550			      ld    E, (HL) 
1550			      inc   HL 
1550			      ld    D, (HL) 
1550			      push  HL                      ; Save ptr to next block for later 
1550			 
1550			      ld    H, B                    ; Store ptr from next block into freed block 
1550			      ld    L, C 
1550			      ld    (HL), E 
1550			      inc   HL 
1550			      ld    (HL), D 
1550			 
1550			      pop   HL                      ; Restore ptr to next block 
1550			      inc   HL                      ; Load size of next block into DE 
1550			      ld    E, (HL) 
1550			      inc   HL 
1550			      ld    D, (HL) 
1550			      push  DE                      ; Save next block size for later 
1550			 
1550			      ld    H, B                    ; Load size of freed block into HL 
1550			      ld    L, C 
1550			      inc   HL 
1550			      inc   HL 
1550			      ld    E, (HL) 
1550			      inc   HL 
1550			      ld    D, (HL) 
1550			      ex    DE, HL 
1550			 
1550			      pop   DE                      ; Restore size of next block 
1550			      add   HL, DE                  ; Add sizes of both blocks 
1550			      ex    DE, HL 
1550			 
1550			      ld    H, B                    ; Store new bigger size into freed block 
1550			      ld    L, C 
1550			      inc   HL 
1550			      inc   HL 
1550			      ld    (HL), E 
1550			      inc   HL 
1550			      ld    (HL), D 
1550			 
1550			free_check_adjacent_to_prev: 
1550			      ; Check if the freed block is adjacent to the prev free block 
1550			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1550			      ld    H, (IX+3) 
1550			 
1550			      inc   HL                      ; Size of prev free block into DE 
1550			      inc   HL 
1550			      ld    E, (HL) 
1550			      inc   HL 
1550			      ld    D, (HL) 
1550			      dec   HL 
1550			      dec   HL 
1550			      dec   HL 
1550			 
1550			      add   HL, DE                  ; Add prev block addr and size 
1550			 
1550			      or    A                       ; Clear the carry flag 
1550			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1550			      jr    NZ, free_done 
1550			 
1550			      ; Freed block is adjacent to prev, merge into one bigger block 
1550			      ld    H, B                    ; Load next ptr from freed block into DE 
1550			      ld    L, C 
1550			      ld    E, (HL) 
1550			      inc   HL 
1550			      ld    D, (HL) 
1550			      push  HL                      ; Save freed block ptr for later 
1550			 
1550			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1550			      ld    H, (IX+3) 
1550			      ld    (HL), E 
1550			      inc   HL 
1550			      ld    (HL), D 
1550			 
1550			      pop   HL                      ; Restore freed block ptr 
1550			      inc   HL                      ; Load size of freed block into DE 
1550			      ld    E, (HL) 
1550			      inc   HL 
1550			      ld    D, (HL) 
1550			      push  DE                      ; Save freed block size for later 
1550			 
1550			      ld    L, (IX+2)               ; Load size of prev block into DE 
1550			      ld    H, (IX+3) 
1550			      inc   HL 
1550			      inc   HL 
1550			      ld    E, (HL) 
1550			      inc   HL 
1550			      ld    D, (HL) 
1550			 
1550			      pop   HL                      ; Add sizes of both blocks 
1550			      add   HL, DE 
1550			      ex    DE, HL 
1550			 
1550			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1550			      ld    H, (IX+3) 
1550			      inc   HL 
1550			      inc   HL 
1550			      ld    (HL), E 
1550			      inc   HL 
1550			      ld    (HL), D 
1550			 
1550			free_done: 
1550			      ld    HL, 4                   ; Clean up stack frame 
1550			      add   HL, SP 
1550			      ld    SP, HL 
1550			 
1550			free_early_exit: 
1550			      pop   IX 
1550			      pop   DE 
1550			      pop   BC 
1550			 
1550			      ret 
1550			 
1550			 
1550			;      .org 0x8000 
1550			; 
1550			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1550			 ;                 .dw   0 
1550			 
1550			endif 
1550			 
1550			 
1550			if MALLOC_4 
1550			 
1550			; My memory allocation code. Very very simple.... 
1550			; allocate space under 250 chars 
1550			 
1550			heap_init: 
1550				; init start of heap as zero 
1550				;  
1550			 
1550				ld hl, heap_start 
1550				ld a, 0 
1550				ld (hl), a      ; empty block 
1550				inc hl 
1550				ld a, 0 
1550				ld (hl), a      ; length of block 
1550				; write end of list 
1550				inc hl 
1550				ld a,(hl) 
1550				inc hl 
1550				ld a,(hl) 
1550				 
1550			 
1550				; init some malloc vars 
1550			 
1550				ld hl, 0 
1550				ld (free_list), hl       ; store last malloc location 
1550			 
1550				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1550				ld a, 0 
1550				ld (hl), a 
1550			 
1550			 
1550				ld hl, heap_start 
1550				;  
1550				  
1550				ret 
1550			 
1550			 
1550			;    free block marker 
1550			;    requested size  
1550			;    pointer to next block 
1550			;    .... 
1550			;    next block marker 
1550			 
1550			 
1550			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1550			; 
1550			 
1550			 
1550			malloc:  
1550				push de 
1550				push bc 
1550				push af 
1550			 
1550				; hl space required 
1550				 
1550				ld c, l    ; hold space   (TODO only a max of 255) 
1550			 
1550			;	inc c     ; TODO BUG need to fix memory leak on push str 
1550			;	inc c 
1550			;	inc c 
1550			;	inc c 
1550			;	inc c 
1550			;	inc c 
1550			;	inc c 
1550			 
1550			 
1550			 
1550				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1550			 
1550				ld a, (free_list+3) 
1550				cp 0 
1550				jr z, .contheap 
1550			 
1550				ld hl, (free_list)     ; get last alloc 
1550					if DEBUG_FORTH_MALLOC_INT 
1550						DMARK "mrs" 
1550						CALLMONITOR 
1550					endif 
1550				jr .startalloc 
1550			 
1550			.contheap: 
1550				ld hl, heap_start 
1550			 
1550			.startalloc: 
1550			 
1550					if DEBUG_FORTH_MALLOC_INT 
1550						DMARK "mym" 
1550						CALLMONITOR 
1550					endif 
1550			.findblock: 
1550					if DEBUG_FORTH_MALLOC_INT 
1550						DMARK "mmf" 
1550						CALLMONITOR 
1550					endif 
1550			 
1550				ld a,(hl)  
1550				; if byte is zero then clear to use 
1550			 
1550				cp 0 
1550				jr z, .foundemptyblock 
1550			 
1550				; if byte is not clear 
1550				;     then byte is offset to next block 
1550			 
1550				inc hl 
1550				ld a, (hl) ; get size 
1550			.nextblock:	inc hl 
1550					ld e, (hl) 
1550					inc hl 
1550					ld d, (hl) 
1550					ex de, hl 
1550			;	inc hl  ; move past the store space 
1550			;	inc hl  ; move past zero index  
1550			 
1550				; TODO detect no more space 
1550			 
1550				push hl 
1550				ld de, heap_end 
1550				call cmp16 
1550				pop hl 
1550				jr nc, .nospace 
1550			 
1550				jr .findblock 
1550			 
1550			.nospace: ld hl, 0 
1550				jp .exit 
1550			 
1550			 
1550			.foundemptyblock:	 
1550					if DEBUG_FORTH_MALLOC_INT 
1550						DMARK "mme" 
1550						CALLMONITOR 
1550					endif 
1550			 
1550			; TODO has block enough space if reusing??? 
1550			 
1550				;  
1550			 
1550			; see if this block has been previously used 
1550				inc hl 
1550				ld a, (hl) 
1550				dec hl 
1550				cp 0 
1550				jr z, .newblock 
1550			 
1550					if DEBUG_FORTH_MALLOC_INT 
1550						DMARK "meR" 
1550						CALLMONITOR 
1550					endif 
1550			 
1550			; no reusing previously allocated block 
1550			 
1550			; is it smaller than previously used? 
1550				 
1550				inc hl    ; move to size 
1550				ld a, c 
1550				sub (hl)        ; we want c < (hl) 
1550				dec hl    ; move back to marker 
1550			        jr z, .findblock 
1550			 
1550				; update with the new size which should be lower 
1550			 
1550			        ;inc  hl   ; negate next move. move back to size  
1550			 
1550			.newblock: 
1550				; need to be at marker here 
1550			 
1550					if DEBUG_FORTH_MALLOC_INT 
1550						DMARK "meN" 
1550						CALLMONITOR 
1550					endif 
1550			 
1550			 
1550				ld a, c 
1550			 
1550				ld (free_list+3), a	 ; flag resume from last malloc  
1550				ld (free_list), hl    ; save out last location 
1550			 
1550			 
1550				;inc a     ; space for length byte 
1550				ld (hl), a     ; save block in use marker 
1550			 
1550				inc hl   ; move to space marker 
1550				ld (hl), a    ; save new space 
1550			 
1550				inc hl   ; move to start of allocated area 
1550				 
1550			;	push hl     ; save where we are - 1  
1550			 
1550			;	inc hl  ; move past zero index  
1550				; skip space to set down new marker 
1550			 
1550				; provide some extra space for now 
1550			 
1550				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1550				inc a 
1550				inc a 
1550			 
1550				push hl   ; save where we are in the node block 
1550			 
1550				call addatohl 
1550			 
1550				; write linked list point 
1550			 
1550				pop de     ; get our node position 
1550				ex de, hl 
1550			 
1550				ld (hl), e 
1550				inc hl 
1550				ld (hl), d 
1550			 
1550				inc hl 
1550			 
1550				; now at start of allocated data so save pointer 
1550			 
1550				push hl 
1550			 
1550				; jump to position of next node and setup empty header in DE 
1550			 
1550				ex de, hl 
1550			 
1550			;	inc hl ; move past end of block 
1550			 
1550				ld a, 0 
1550				ld (hl), a   ; empty marker 
1550				inc hl 
1550				ld (hl), a   ; size 
1550				inc hl  
1550				ld (hl), a   ; ptr 
1550				inc hl 
1550				ld (hl), a   ; ptr 
1550			 
1550			 
1550				pop hl 
1550			 
1550					if DEBUG_FORTH_MALLOC_INT 
1550						DMARK "mmr" 
1550						CALLMONITOR 
1550					endif 
1550			 
1550			.exit: 
1550				pop af 
1550				pop bc 
1550				pop de  
1550				ret 
1550			 
1550			 
1550			 
1550			 
1550			free:  
1550				push hl 
1550				push af 
1550				; get address in hl 
1550			 
1550					if DEBUG_FORTH_MALLOC_INT 
1550						DMARK "fre" 
1550						CALLMONITOR 
1550					endif 
1550				; data is at hl - move to block count 
1550				dec hl 
1550				dec hl    ; get past pointer 
1550				dec hl 
1550			 
1550				ld a, (hl)    ; need this for a validation check 
1550			 
1550				dec hl    ; move to block marker 
1550			 
1550				; now check that the block count and block marker are the same  
1550			        ; this checks that we are on a malloc node and not random memory 
1550			        ; OK a faint chance this could be a problem but rare - famous last words! 
1550			 
1550				ld c, a 
1550				ld a, (hl)    
1550			 
1550				cp c 
1550				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1550			 
1550				; yes good chance we are on a malloc node 
1550			 
1550				ld a, 0      
1550				ld (hl), a   ; mark as free 
1550			 
1550				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1550			 
1550			.freeignore:  
1550			 
1550				pop af 
1550				pop hl 
1550			 
1550				ret 
1550			 
1550			 
1550			 
1550			endif 
1550			 
1550			; eof 
# End of file firmware_memory.asm
1550			  
1550			; device C  
1550			; Now handled by SPI  
1550			;if SOUND_ENABLE  
1550			;	include "firmware_sound.asm"  
1550			;endif  
1550			  
1550			include "firmware_diags.asm"  
1550			; Hardware diags menu 
1550			 
1550			 
1550			config: 
1550			 
1550 3e 00			ld a, 0 
1552 21 7b 15			ld hl, .configmn 
1555 cd cc 0d			call menu 
1558			 
1558 fe 00			cp 0 
155a c8				ret z 
155b			 
155b			;	cp 1 
155b			;	call z, .savetostore 
155b			 
155b fe 01			cp 1 
155d			if STARTUP_V1 
155d				call z, .selautoload 
155d			endif 
155d			 
155d			if STARTUP_V2 
155d cc 89 15			call z, .enautoload 
1560			endif 
1560 fe 02			cp 2 
1562 cc a0 15			call z, .disautoload 
1565			;	cp 3 
1565			;	call z, .selbank 
1565 fe 03			cp 3 
1567 cc 0e 18			call z, .debug_tog 
156a fe 04			cp 4 
156c cc 5c 19			call z, .bpsgo 
156f fe 05			cp 5 
1571 cc 37 18			call z, hardware_diags 
1574			if STARTUP_V2 
1574 fe 06			cp 6 
1576 cc cc 15			call z, create_startup 
1579			endif 
1579 18 d5			jr config 
157b			 
157b			.configmn: 
157b			;	dw prom_c3 
157b 4a 1b			dw prom_c2 
157d 60 1b			dw prom_c2a 
157f			;	dw prom_c2b 
157f			;	dw prom_c4 
157f cd 1b			dw prom_m4 
1581 e8 1b			dw prom_m4b 
1583 f0 1b			dw prom_c1 
1585			if STARTUP_V2 
1585 ff 1b			dw prom_c9 
1587			endif 
1587 00 00			dw 0 
1589				 
1589			 
1589			if STARTUP_V2 
1589			.enautoload: 
1589				if STORAGE_SE 
1589 3e fe			ld a, $fe      ; bit 0 clear 
158b 32 9b f9			ld (spi_device), a 
158e			 
158e cd 16 05			call storage_get_block_0 
1591			 
1591 3e 01			ld a, 1 
1593 32 d6 f9			ld (store_page+STORE_0_AUTOFILE), a 
1596			 
1596 21 00 00				ld hl, 0 
1599 11 b5 f9				ld de, store_page 
159c cd ca 04			call storage_write_block	 ; save update 
159f				else 
159f			 
159f				ld hl, prom_notav 
159f				ld de, prom_empty 
159f				call info_panel 
159f				endif 
159f			 
159f			 
159f c9				ret 
15a0			endif 
15a0			 
15a0			.disautoload: 
15a0				if STORAGE_SE 
15a0 3e fe			ld a, $fe      ; bit 0 clear 
15a2 32 9b f9			ld (spi_device), a 
15a5			 
15a5 cd 16 05			call storage_get_block_0 
15a8			 
15a8 3e 00			ld a, 0 
15aa 32 d6 f9			ld (store_page+STORE_0_AUTOFILE), a 
15ad			 
15ad 21 00 00				ld hl, 0 
15b0 11 b5 f9				ld de, store_page 
15b3 cd ca 04			call storage_write_block	 ; save update 
15b6				else 
15b6			 
15b6				ld hl, prom_notav 
15b6				ld de, prom_empty 
15b6				call info_panel 
15b6				endif 
15b6			 
15b6			 
15b6 c9				ret 
15b7			 
15b7			if STARTUP_V1 
15b7			 
15b7			; Select auto start 
15b7			 
15b7			.selautoload: 
15b7			 
15b7				 
15b7				if STORAGE_SE 
15b7			 
15b7					call config_dir 
15b7				        ld hl, scratch 
15b7					ld a, 0 
15b7					call menu 
15b7			 
15b7					cp 0 
15b7					ret z 
15b7			 
15b7					dec a 
15b7			 
15b7			 
15b7					; locate menu option 
15b7			 
15b7					ld hl, scratch 
15b7					call table_lookup 
15b7			 
15b7					if DEBUG_FORTH_WORDS 
15b7						DMARK "ALl" 
15b7						CALLMONITOR 
15b7					endif 
15b7					; with the pointer to the menu it, the byte following the zero term is the file id 
15b7			 
15b7					ld a, 0 
15b7					ld bc, 50   ; max of bytes to look at 
15b7					cpir  
15b7			 
15b7					if DEBUG_FORTH_WORDS 
15b7						DMARK "ALb" 
15b7						CALLMONITOR 
15b7					endif 
15b7					;inc hl 
15b7			 
15b7					ld a, (hl)   ; file id 
15b7					 
15b7				        ; save bank and file ids 
15b7			 
15b7					push af 
15b7			 
15b7			; TODO need to save to block 0 on bank 1	 
15b7			 
15b7					call storage_get_block_0 
15b7			 
15b7					if DEBUG_FORTH_WORDS 
15b7						DMARK "AL0" 
15b7						CALLMONITOR 
15b7					endif 
15b7					pop af 
15b7			 
15b7					ld (store_page+STORE_0_FILERUN),a 
15b7					 
15b7					; save bank id 
15b7			 
15b7					ld a,(spi_device) 
15b7					ld (store_page+STORE_0_BANKRUN),a 
15b7			 
15b7					; enable auto run of store file 
15b7			 
15b7					ld a, 1 
15b7					ld (store_page+STORE_0_AUTOFILE),a 
15b7			 
15b7					; save buffer 
15b7			 
15b7					ld hl, 0 
15b7					ld de, store_page 
15b7					if DEBUG_FORTH_WORDS 
15b7						DMARK "ALw" 
15b7						CALLMONITOR 
15b7					endif 
15b7				call storage_write_block	 ; save update 
15b7			  
15b7			 
15b7			 
15b7			 
15b7					ld hl, scratch 
15b7					call config_fdir 
15b7			 
15b7				else 
15b7			 
15b7				ld hl, prom_notav 
15b7				ld de, prom_empty 
15b7				call info_panel 
15b7			 
15b7				endif 
15b7				ret 
15b7			endif 
15b7			 
15b7			 
15b7			; Select storage bank 
15b7			 
15b7			.selbank: 
15b7			 
15b7			;	if STORAGE_SE 
15b7			;	else 
15b7			 
15b7 21 14 1c			ld hl, prom_notav 
15ba 11 2a 1c			ld de, prom_empty 
15bd cd 2c 0d			call info_panel 
15c0			;	endif 
15c0				 
15c0 c9				ret 
15c1			 
15c1			if STORAGE_SE 
15c1			 
15c1			.config_ldir:   
15c1				; Load storage bank labels into menu array 
15c1			 
15c1				 
15c1			 
15c1			 
15c1 c9				ret 
15c2			 
15c2			 
15c2			endif 
15c2			 
15c2			 
15c2			; Save user words to storage 
15c2			 
15c2			.savetostore: 
15c2			 
15c2			;	if STORAGE_SE 
15c2			; 
15c2			;		call config_dir 
15c2			;	        ld hl, scratch 
15c2			;		ld a, 0 
15c2			;		call menu 
15c2			;		 
15c2			;		ld hl, scratch 
15c2			;		call config_fdir 
15c2			; 
15c2			;	else 
15c2			 
15c2 21 14 1c			ld hl, prom_notav 
15c5 11 2a 1c			ld de, prom_empty 
15c8 cd 2c 0d			call info_panel 
15cb			 
15cb			;	endif 
15cb			 
15cb c9				ret 
15cc			 
15cc			if STARTUP_V2 
15cc			 
15cc			create_startup: 
15cc			 
15cc 3e 00			ld a, 0 
15ce 21 35 17			ld hl, .crstart 
15d1 cd cc 0d			call menu 
15d4			 
15d4 fe 00			cp 0 
15d6 c8				ret z 
15d7			 
15d7 fe 01			cp 1 
15d9 cc 06 16			call z, .genlsword 
15dc fe 02			cp 2 
15de cc 10 16			call z, .genedword 
15e1			 
15e1 fe 03			cp 3 
15e3 cc 1a 16			call z, .gendemword 
15e6			 
15e6 fe 04			cp 4 
15e8 cc 24 16			call z, .genutlword 
15eb fe 05			cp 5 
15ed cc 2e 16			call z, .genspiword 
15f0 fe 06			cp 6 
15f2 cc 38 16			call z, .genkeyword 
15f5 fe 07			cp 7 
15f7 cc fc 15			call z, .gensoundword 
15fa 18 d0			jr create_startup 
15fc			 
15fc			.gensoundword: 
15fc 21 b8 1b			ld hl, crs_sound 
15ff 11 85 16			ld de, .soundworddef 
1602 cd 42 16			call .genfile 
1605 c9				ret 
1606			.genlsword: 
1606 21 77 1b			ld hl, crs_s1 
1609 11 a9 16			ld de, .lsworddef 
160c cd 42 16			call .genfile 
160f c9				ret 
1610			 
1610			.genedword: 
1610 11 ad 16			ld de, .edworddef 
1613 21 80 1b			ld hl, crs_s2 
1616 cd 42 16			call .genfile 
1619 c9				ret 
161a			 
161a			.gendemword: 
161a 11 b5 16			ld de, .demoworddef 
161d 21 89 1b			ld hl, crs_s3 
1620 cd 42 16			call .genfile 
1623 c9				ret 
1624			 
1624			.genutlword: 
1624 21 98 1b			ld hl, crs_s4 
1627 11 99 16			ld de, .utilwordef 
162a cd 42 16			call .genfile 
162d c9				ret 
162e			.genspiword: 
162e 21 9f 1b			ld hl, crs_s5 
1631 11 fb 16			ld de, .spiworddef 
1634 cd 42 16			call .genfile 
1637 c9				ret 
1638			.genkeyword: 
1638 21 a9 1b			ld hl, crs_s6 
163b 11 09 17			ld de, .keyworddef 
163e cd 42 16			call .genfile 
1641 c9				ret 
1642			 
1642			; hl - points to file name 
1642			; de - points to strings to add to file 
1642			 
1642			.genfile: 
1642 e5				push hl 
1643 d5				push de 
1644			 
1644 cd 9b 0d			call clear_display 
1647 3e 00			ld a, display_row_1 
1649 11 74 16			ld de, .genfiletxt 
164c cd ae 0d			call str_at_display 
164f cd be 0d			call update_display 
1652			 
1652 d1				pop de 
1653 e1				pop hl 
1654			 
1654			 
1654 d5				push de 
1655 cd 68 08			call storage_create 
1658				; id in hl 
1658 d1				pop de   ; table of strings to add 
1659			 
1659			.genloop: 
1659			 
1659 e5				push hl ; save id for next time around 
165a d5				push de ; save de for next time around 
165b			 
165b eb				ex de, hl 
165c cd 47 23			call loadwordinhl 
165f eb				ex de, hl 
1660			 
1660				; need hl to be the id 
1660				; need de to be the string ptr 
1660				 
1660 cd 55 0b			call storage_append 
1663			 
1663 d1				pop de 
1664 e1				pop hl 
1665			 
1665 13				inc de 
1666 13				inc de 
1667			 
1667 1a				ld a,(de) 
1668 fe 00			cp 0 
166a 20 ed			jr nz, .genloop 
166c 13				inc de 
166d 1a				ld a, (de) 
166e 1b				dec de 
166f fe 00			cp 0 
1671 20 e6			jr nz, .genloop	 
1673			 
1673 c9				ret 
1674			 
1674 .. 00		.genfiletxt:  db "Creating file...",0 
1685			 
1685			.soundworddef: 
1685 d0 69			dw sound1 
1687 f4 69			dw sound2 
1689 24 6a			dw sound3 
168b 49 6a			dw sound4 
168d 56 6a			dw sound5 
168f 63 6a			dw sound6 
1691 70 6a			dw sound7 
1693 7d 6a			dw sound8 
1695 95 6a			dw sound9 
1697 00 00			dw 0 
1699			 
1699			.utilwordef: 
1699 21 63			dw strncpy 
169b fc 62			dw type 
169d c8 62			dw clrstack 
169f 81 62			dw longread 
16a1 82 63			dw start1 
16a3 92 63			dw start2 
16a5			; duplicated 
16a5			;	dw start3b 
16a5			;	dw start3c 
16a5 7e 64			dw list 
16a7 00 00			dw 0 
16a9			 
16a9			.lsworddef: 
16a9 a3 63			dw start3b 
16ab 00 00			dw 0 
16ad			 
16ad			.edworddef: 
16ad e0 5e			dw edit1 
16af 01 5f			dw edit2 
16b1 36 5f			dw edit3 
16b3 00 00			dw 0 
16b5			 
16b5			.demoworddef: 
16b5 c6 68			dw test5 
16b7 fe 68			dw test6 
16b9 36 69			dw test7 
16bb 4a 69			dw test8 
16bd 76 69			dw test9 
16bf 8c 69			dw test10 
16c1 ac 6a			dw game1 
16c3 bd 6a			dw game1a 
16c5 1f 6b			dw game1b 
16c7 54 6b			dw game1c 
16c9 8a 6b			dw game1d 
16cb bb 6b			dw game1s 
16cd cf 6b			dw game1t 
16cf e4 6b			dw game1f 
16d1 18 6c			dw game1z 
16d3 5c 6c			dw game1zz 
16d5 c5 6c			dw ssv2 
16d7 fb 6c			dw ssv3 
16d9 17 6d			dw ssv4 
16db 33 6d			dw ssv5 
16dd 4c 6d			dw ssv1 
16df 94 6d			dw ssv1cpm	 
16e1 eb 6d			dw game2b 
16e3 59 6e			dw game2bf 
16e5 a3 6e			dw game2mba 
16e7 39 6f			dw game2mbas	 
16e9 5e 6f			dw game2mbht 
16eb 6d 6f			dw game2mbms 
16ed 7b 6f			dw game2mb 
16ef f8 6f			dw game3w 
16f1 26 70			dw game3p 
16f3 44 70			dw game3sc 
16f5 75 70			dw game3vsi 
16f7 a1 70			dw game3vs 
16f9 00 00			dw 0 
16fb			 
16fb			 
16fb			.spiworddef: 
16fb			 
16fb 6e 5f		    dw spi1 
16fd c7 5f		    dw spi2 
16ff fb 5f		    dw spi2b 
1701 7f 60		    dw spi3 
1703 29 60		    dw spi4 
1705 52 60		    dw spi5 
1707			;    dw spi6 
1707			;    dw spi7 
1707			 
1707			;    dw spi8 
1707			;    dw spi9 
1707			;    dw spi10 
1707 00 00		    dw 0 
1709			 
1709			.keyworddef: 
1709			 
1709 e0 70			dw keyup 
170b ee 70			dw keydown 
170d fe 70			dw keyleft 
170f 0e 71			dw keyright 
1711 1f 71			dw 	keyf1 
1713 2d 71			dw keyf2 
1715 3b 71			dw keyf3 
1717 49 71			dw keyf4 
1719 57 71			dw keyf5 
171b 65 71			dw keyf6 
171d 73 71			dw keyf7 
171f 81 71			dw keyf8 
1721 8f 71			dw keyf9 
1723 9d 71			dw keyf10 
1725 ac 71			dw keyf11 
1727 bb 71			dw keyf12 
1729 ca 71			dw keytab 
172b d9 71			dw keycr 
172d e7 71			dw keyhome 
172f f7 71			dw keyend 
1731 06 72			dw keybs 
1733 00 00			dw 0 
1735			 
1735			.crstart: 
1735 77 1b			dw crs_s1 
1737 80 1b			dw crs_s2 
1739 89 1b			dw crs_s3 
173b 98 1b			dw crs_s4 
173d 9f 1b			dw crs_s5 
173f a9 1b			dw crs_s6 
1741 b8 1b			dw crs_sound 
1743 00 00			dw 0 
1745			 
1745			endif 
1745			 
1745			 
1745			if STORAGE_SE 
1745			 
1745			config_fdir: 
1745				; using the scratch dir go through and release the memory allocated for each string 
1745				 
1745 21 fc f0			ld hl, scratch 
1748 5e			.cfdir:	ld e,(hl) 
1749 23				inc hl 
174a 56				ld d,(hl) 
174b 23				inc hl 
174c			 
174c eb				ex de, hl 
174d cd f8 0f			call ishlzero 
1750 c8				ret z     ; return on null pointer 
1751 cd 81 14			call free 
1754 eb				ex de, hl 
1755 18 f1			jr .cfdir 
1757			 
1757			 
1757 c9				ret 
1758			 
1758			 
1758			config_dir: 
1758			 
1758				; for the config menus that need to build a directory of storage call this routine 
1758				; it will construct a menu in scratch to pass to menu 
1758			 
1758				; open storage device 
1758			 
1758				; execute DIR to build a list of files and their ids into scratch in menu format 
1758				; once the menu has finished then will need to call config_fdir to release the strings 
1758				 
1758				; c = number items 
1758			 
1758				 
1758 cd 16 05			call storage_get_block_0 
175b			 
175b 21 b5 f9			ld hl, store_page     ; get current id count 
175e 46				ld b, (hl) 
175f 0e 00			ld c, 0    ; count of files   
1761			 
1761			 
1761 21 fc f0			ld hl, scratch 
1764 22 ac f9			ld (store_tmp2), hl    ; location to poke strings 
1767			 
1767				; check for empty drive 
1767			 
1767 3e 00			ld a, 0 
1769 b8				cp b 
176a ca 04 18			jp z, .dirdone 
176d			 
176d				 
176d					if DEBUG_FORTH_WORDS 
176d						DMARK "Cdc" 
176d f5				push af  
176e 3a 82 17			ld a, (.dmark)  
1771 32 a6 fd			ld (debug_mark),a  
1774 3a 83 17			ld a, (.dmark+1)  
1777 32 a7 fd			ld (debug_mark+1),a  
177a 3a 84 17			ld a, (.dmark+2)  
177d 32 a8 fd			ld (debug_mark+2),a  
1780 18 03			jr .pastdmark  
1782 ..			.dmark: db "Cdc"  
1785 f1			.pastdmark: pop af  
1786			endm  
# End of macro DMARK
1786						CALLMONITOR 
1786 cd aa fd			call debug_vector  
1789				endm  
# End of macro CALLMONITOR
1789					endif 
1789			 
1789			 
1789			.diritem:	 
1789 c5				push bc 
178a				; for each of the current ids do a search for them and if found push to stack 
178a			 
178a 21 40 00				ld hl, STORE_BLOCK_PHY 
178d 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
178f 58					ld e,b 
1790			 
1790 cd 98 07				call storage_findnextid 
1793			 
1793			 
1793					; if found hl will be non zero 
1793			 
1793 cd f8 0f				call ishlzero 
1796 28 69				jr z, .dirnotfound 
1798			 
1798					; increase count 
1798			 
1798 c1					pop bc	 
1799 0c					inc c 
179a c5					push bc 
179b					 
179b			 
179b					; get file header and push the file name 
179b			 
179b 11 b5 f9				ld de, store_page 
179e cd 65 04				call storage_read_block 
17a1			 
17a1					; push file id to stack 
17a1				 
17a1 3a b5 f9				ld a, (store_page) 
17a4 26 00				ld h, 0 
17a6 6f					ld l, a 
17a7			 
17a7					;call forth_push_numhl 
17a7					; TODO store id 
17a7			 
17a7 e5					push hl 
17a8			 
17a8					; push extent count to stack  
17a8				 
17a8 21 b8 f9				ld hl, store_page+3 
17ab			 
17ab					; get file name length 
17ab			 
17ab cd 42 13				call strlenz   
17ae			 
17ae 23					inc hl   ; cover zero term 
17af 23					inc hl  ; stick the id at the end of the area 
17b0			 
17b0 e5					push hl 
17b1 c1					pop bc    ; move length to bc 
17b2			 
17b2 cd b7 13				call malloc 
17b5			 
17b5					; TODO save malloc area to scratch 
17b5			 
17b5 eb					ex de, hl 
17b6 2a ac f9				ld hl, (store_tmp2) 
17b9 73					ld (hl), e 
17ba 23					inc hl 
17bb 72					ld (hl), d 
17bc 23					inc hl 
17bd 22 ac f9				ld (store_tmp2), hl 
17c0			 
17c0					 
17c0			 
17c0					;pop hl   ; get source 
17c0			;		ex de, hl    ; swap aronund	 
17c0			 
17c0 21 b8 f9				ld hl, store_page+3 
17c3					if DEBUG_FORTH_WORDS 
17c3						DMARK "CFd" 
17c3 f5				push af  
17c4 3a d8 17			ld a, (.dmark)  
17c7 32 a6 fd			ld (debug_mark),a  
17ca 3a d9 17			ld a, (.dmark+1)  
17cd 32 a7 fd			ld (debug_mark+1),a  
17d0 3a da 17			ld a, (.dmark+2)  
17d3 32 a8 fd			ld (debug_mark+2),a  
17d6 18 03			jr .pastdmark  
17d8 ..			.dmark: db "CFd"  
17db f1			.pastdmark: pop af  
17dc			endm  
# End of macro DMARK
17dc						CALLMONITOR 
17dc cd aa fd			call debug_vector  
17df				endm  
# End of macro CALLMONITOR
17df					endif 
17df ed b0				ldir 
17e1			 
17e1					; de is past string, move back one and store id 
17e1					 
17e1 1b					dec de 
17e2			 
17e2					; store file id 
17e2			 
17e2 e1					pop hl 
17e3 eb					ex de,hl 
17e4 73					ld (hl), e 
17e5			 
17e5					if DEBUG_FORTH_WORDS 
17e5						DMARK "Cdi" 
17e5 f5				push af  
17e6 3a fa 17			ld a, (.dmark)  
17e9 32 a6 fd			ld (debug_mark),a  
17ec 3a fb 17			ld a, (.dmark+1)  
17ef 32 a7 fd			ld (debug_mark+1),a  
17f2 3a fc 17			ld a, (.dmark+2)  
17f5 32 a8 fd			ld (debug_mark+2),a  
17f8 18 03			jr .pastdmark  
17fa ..			.dmark: db "Cdi"  
17fd f1			.pastdmark: pop af  
17fe			endm  
# End of macro DMARK
17fe						CALLMONITOR 
17fe cd aa fd			call debug_vector  
1801				endm  
# End of macro CALLMONITOR
1801					endif 
1801					 
1801			.dirnotfound: 
1801 c1					pop bc     
1802 10 85				djnz .diritem 
1804				 
1804			.dirdone:	 
1804			 
1804 3e 00				ld a, 0 
1806 2a ac f9				ld hl, (store_tmp2) 
1809 77					ld (hl), a 
180a 23					inc hl 
180b 77					ld (hl), a 
180c 23					inc hl 
180d					; push a count of the dir items found 
180d			 
180d			;		ld h, 0 
180d			;		ld l, c 
180d			 
180d c9				ret 
180e			 
180e			endif 
180e			 
180e			 
180e			; Settings 
180e			; Run  
180e			 
180e			 
180e			 
180e			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
180e			;;hd_menu2:   db "        2: Editor",0   
180e			;hd_menu2:   db "        2: Editor       6: Menu",0   
180e			;hd_menu3:   db "        3: Storage",0 
180e			;hd_menu4:   db "0=quit  4: Debug",0 
180e			;hd_don:     db "ON",0 
180e			;hd_doff:     db "OFF",0 
180e			; 
180e			; 
180e			; 
180e			;hardware_diags_old:       
180e			; 
180e			;.diagmenu: 
180e			;	call clear_display 
180e			;	ld a, display_row_1 
180e			;	ld de, hd_menu1 
180e			;	call str_at_display 
180e			; 
180e			;	ld a, display_row_2 
180e			;	ld de, hd_menu2 
180e			;	call str_at_display 
180e			; 
180e			;	ld a, display_row_3 
180e			;	ld de, hd_menu3 
180e			;	call str_at_display 
180e			; 
180e			;	ld a,  display_row_4 
180e			;	ld de, hd_menu4 
180e			;	call str_at_display 
180e			; 
180e			;	; display debug state 
180e			; 
180e			;	ld de, hd_don 
180e			;	ld a, (os_view_disable) 
180e			;	cp 0 
180e			;	jr z, .distog 
180e			;	ld de, hd_doff 
180e			;.distog: ld a, display_row_4+17 
180e			;	call str_at_display 
180e			; 
180e			;	call update_display 
180e			; 
180e			;	call cin_wait 
180e			; 
180e			; 
180e			; 
180e			;	cp '4' 
180e			;	jr nz, .diagn1 
180e			; 
180e			;	; debug toggle 
180e			; 
180e			;	ld a, (os_view_disable) 
180e			;	ld b, '*' 
180e			;	cp 0 
180e			;	jr z, .debtog 
180e			;	ld b, 0 
180e			;.debtog:	 
180e			;	ld a,b 
180e			;	ld (os_view_disable),a 
180e			; 
180e			;.diagn1: cp '0' 
180e			;	 ret z 
180e			; 
180e			;;	cp '1' 
180e			;;       jp z, matrix	 
180e			;;   TODO keyboard matrix test 
180e			; 
180e			;	cp '2' 
180e			;	jp z, .diagedit 
180e			; 
180e			;;	cp '6' 
180e			;;	jp z, .menutest 
180e			;;if ENABLE_BASIC 
180e			;;	cp '6' 
180e			;;	jp z, basic 
180e			;;endif 
180e			 ; 
180e			;	jp .diagmenu 
180e			; 
180e			; 
180e			;	ret 
180e			 
180e			 
180e			.debug_tog: 
180e 21 58 18			ld hl, .menudebug 
1811				 
1811			;	ld a, (os_view_disable) 
1811			;	cp '*' 
1811 3a aa fd			ld a,(debug_vector) 
1814 fe c9			cp $C9   ; RET 
1816 20 04			jr nz,.tdon  
1818 3e 01			ld a, 1 
181a 18 02			jr .tog1 
181c 3e 00		.tdon: ld a, 0 
181e			 
181e			.tog1: 
181e cd cc 0d			call menu 
1821 fe 00			cp 0 
1823 c8				ret z 
1824 fe 01			cp 1    ; disable debug 
1826 28 04			jr z, .dtog0 
1828 3e 2a			ld a, '*' 
182a 18 05			jr .dtogset 
182c			.dtog0:  
182c				;ld a, 0 
182c cd 4a 19			call bp_on 
182f 18 dd			jr .debug_tog 
1831			.dtogset:  
1831				; ld (os_view_disable), a 
1831 cd 56 19			call bp_off 
1834 c3 0e 18			jp .debug_tog 
1837			 
1837			 
1837			hardware_diags:       
1837			 
1837			.diagm: 
1837 21 4a 18			ld hl, .menuitems 
183a 3e 00			ld a, 0 
183c cd cc 0d			call menu 
183f			 
183f fe 00		         cp 0 
1841 c8				 ret z 
1842			 
1842 fe 02			cp 2 
1844 ca a3 18			jp z, .diagedit 
1847			 
1847			;	cp '6' 
1847			;	jp z, .menutest 
1847			;if ENABLE_BASIC 
1847			;	cp '6' 
1847			;	jp z, basic 
1847			;endif 
1847			  
1847 c3 37 18			jp .diagm 
184a			 
184a				 
184a 5e 18		.menuitems:   	dw .m1 
184c 69 18				dw .m2 
184e 70 18				dw .m3 
1850 78 18				dw .m5 
1852 7e 18				dw .m5a 
1854 87 18				dw .m5b 
1856 00 00				dw 0 
1858			 
1858			.menudebug: 
1858 90 18				dw .m6 
185a 99 18				dw .m7 
185c 00 00				dw 0 
185e			 
185e .. 00		.m1:   db "Key Matrix",0 
1869 .. 00		.m2:   db "Editor",0 
1870 .. 00		.m3:   db "Storage",0 
1878 .. 00		.m5:   db "Sound",0 
187e .. 00		.m5a:  db "RAM Test",0 
1887 .. 00		.m5b:  db "LCD Test",0 
1890			 
1890 .. 00		.m6:   db "Debug ON",0 
1899 .. 00		.m7:   db "Debug OFF",0 
18a3			 
18a3			; debug editor 
18a3			 
18a3			.diagedit: 
18a3			 
18a3 21 fc f0			ld hl, scratch 
18a6			;	ld bc, 250 
18a6			;	ldir 
18a6				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18a6 3e 00			ld a, 0 
18a8 77				ld (hl), a 
18a9 23				inc hl 
18aa 77				ld (hl), a 
18ab 23				inc hl 
18ac 77				ld (hl), a 
18ad			 
18ad cd 9b 0d		        call clear_display 
18b0 cd be 0d			call update_display 
18b3				;ld a, 1 
18b3				;ld (hardware_diag), a 
18b3			.diloop: 
18b3 3e 00			ld a, display_row_1 
18b5 0e 00			ld c, 0 
18b7 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18b9 1e 28			ld e, 40 
18bb			 
18bb 21 fc f0			ld hl, scratch	 
18be cd fc 0f			call input_str 
18c1			 
18c1 3e 28			ld a, display_row_2 
18c3 11 fc f0			ld de, scratch 
18c6 cd ae 0d			call str_at_display 
18c9 cd be 0d			call update_display 
18cc			 
18cc c3 b3 18			jp .diloop 
18cf			 
18cf			 
18cf			; pass word in hl 
18cf			; a has display location 
18cf			display_word_at: 
18cf f5				push af 
18d0 e5				push hl 
18d1 7c				ld a,h 
18d2 21 01 f4			ld hl, os_word_scratch 
18d5 cd e5 11			call hexout 
18d8 e1				pop hl 
18d9 7d				ld a,l 
18da 21 03 f4			ld hl, os_word_scratch+2 
18dd cd e5 11			call hexout 
18e0 21 05 f4			ld hl, os_word_scratch+4 
18e3 3e 00			ld a,0 
18e5 77				ld (hl),a 
18e6 11 01 f4			ld de,os_word_scratch 
18e9 f1				pop af 
18ea cd ae 0d				call str_at_display 
18ed c9				ret 
18ee			 
18ee			display_ptr_state: 
18ee			 
18ee				; to restore afterwards 
18ee			 
18ee d5				push de 
18ef c5				push bc 
18f0 e5				push hl 
18f1 f5				push af 
18f2			 
18f2				; for use in here 
18f2			 
18f2			;	push bc 
18f2			;	push de 
18f2			;	push hl 
18f2			;	push af 
18f2			 
18f2 cd 9b 0d			call clear_display 
18f5			 
18f5 11 cd 1a			ld de, .ptrstate 
18f8 3e 00			ld a, display_row_1 
18fa cd ae 0d			call str_at_display 
18fd			 
18fd				; display debug step 
18fd			 
18fd			 
18fd 11 a6 fd			ld de, debug_mark 
1900 3e 26			ld a, display_row_1+display_cols-2 
1902 cd ae 0d			call str_at_display 
1905			 
1905				; display a 
1905 11 d7 1a			ld de, .ptrcliptr 
1908 3e 28			ld a, display_row_2 
190a cd ae 0d			call str_at_display 
190d			 
190d f1				pop af 
190e 2a 7b f9			ld hl,(cli_ptr) 
1911 3e 30			ld a, display_row_2+8 
1913 cd cf 18			call display_word_at 
1916			 
1916			 
1916				; display hl 
1916			 
1916			 
1916 11 df 1a			ld de, .ptrclioptr 
1919 3e 32			ld a, display_row_2+10 
191b cd ae 0d			call str_at_display 
191e			; 
191e			;	pop hl 
191e 3e 35			ld a, display_row_2+13 
1920 2a 79 f9			ld hl,(cli_origptr) 
1923 cd cf 18			call display_word_at 
1926			; 
1926			;	 
1926			;	; display de 
1926			 
1926			;	ld de, .regstatede 
1926			;	ld a, display_row_3 
1926			;	call str_at_display 
1926			 
1926			;	pop de 
1926			;	ld h,d 
1926			;	ld l, e 
1926			;	ld a, display_row_3+3 
1926			;	call display_word_at 
1926			 
1926			 
1926				; display bc 
1926			 
1926			;	ld de, .regstatebc 
1926			;	ld a, display_row_3+10 
1926			;	call str_at_display 
1926			 
1926			;	pop bc 
1926			;	ld h,b 
1926			;	ld l, c 
1926			;	ld a, display_row_3+13 
1926			;	call display_word_at 
1926			 
1926			 
1926				; display dsp 
1926			 
1926			;	ld de, .regstatedsp 
1926			;	ld a, display_row_4 
1926			;	call str_at_display 
1926			 
1926				 
1926			;	ld hl,(cli_data_sp) 
1926			;	ld a, display_row_4+4 
1926			;	call display_word_at 
1926			 
1926				; display rsp 
1926			 
1926 11 0e 1b			ld de, .regstatersp 
1929 3e 82			ld a, display_row_4+10 
192b cd ae 0d			call str_at_display 
192e			 
192e				 
192e 2a 2d f9			ld hl,(cli_ret_sp) 
1931 3e 86			ld a, display_row_4+14 
1933 cd cf 18			call display_word_at 
1936			 
1936 cd be 0d			call update_display 
1939			 
1939 cd de 0c			call delay1s 
193c cd de 0c			call delay1s 
193f cd de 0c			call delay1s 
1942			 
1942			 
1942 cd 90 1f			call next_page_prompt 
1945			 
1945				; restore  
1945			 
1945 f1				pop af 
1946 e1				pop hl 
1947 c1				pop bc 
1948 d1				pop de 
1949 c9				ret 
194a			 
194a			; Update the break point vector so that the user can hook a new routine 
194a			 
194a			bp_on: 
194a 3e c3			ld a, $c3    ; JP 
194c 32 aa fd			ld (debug_vector), a 
194f 21 5c 19			ld hl, break_point_state 
1952 22 ab fd			ld (debug_vector+1), hl 
1955 c9				ret 
1956			 
1956			bp_off: 
1956 3e c9			ld a, $c9    ; RET 
1958 32 aa fd			ld (debug_vector), a 
195b c9				ret 
195c			 
195c			 
195c			break_point_state: 
195c			;	push af 
195c			; 
195c			;	; see if disabled 
195c			; 
195c			;	ld a, (os_view_disable) 
195c			;	cp '*' 
195c			;	jr nz, .bpsgo 
195c			;	pop af 
195c			;	ret 
195c			 
195c			.bpsgo: 
195c			;	pop af 
195c f5				push af 
195d 22 de f0			ld (os_view_hl), hl 
1960 ed 53 dc f0		ld (os_view_de), de 
1964 ed 43 da f0		ld (os_view_bc), bc 
1968 e5				push hl 
1969 6f				ld l, a 
196a 26 00			ld h, 0 
196c 22 e0 f0			ld (os_view_af),hl 
196f			 
196f 21 ec fc				ld hl, display_fb0 
1972 22 07 fb				ld (display_fb_active), hl 
1975 e1				pop hl	 
1976			 
1976 3e 31			ld a, '1' 
1978 fe 2a		.bps1:  cp '*' 
197a cc 56 19			call z, bp_off 
197d			;	jr nz, .bps1b 
197d			;	ld (os_view_disable),a 
197d fe 31		.bps1b:  cp '1' 
197f 20 14			jr nz, .bps2 
1981			 
1981				; display reg 
1981			 
1981				 
1981			 
1981 3a e0 f0			ld a, (os_view_af) 
1984 2a de f0			ld hl, (os_view_hl) 
1987 ed 5b dc f0		ld de, (os_view_de) 
198b ed 4b da f0		ld bc, (os_view_bc) 
198f cd 29 1a			call display_reg_state 
1992 c3 15 1a			jp .bpschk 
1995			 
1995 fe 32		.bps2:  cp '2' 
1997 20 08			jr nz, .bps3 
1999				 
1999				; display hl 
1999 2a de f0			ld hl, (os_view_hl) 
199c cd 13 1b			call display_dump_at_hl 
199f			 
199f 18 74			jr .bpschk 
19a1			 
19a1 fe 33		.bps3:  cp '3' 
19a3 20 08			jr nz, .bps4 
19a5			 
19a5			        ; display de 
19a5 2a dc f0			ld hl, (os_view_de) 
19a8 cd 13 1b			call display_dump_at_hl 
19ab			 
19ab 18 68			jr .bpschk 
19ad fe 34		.bps4:  cp '4' 
19af 20 08			jr nz, .bps5 
19b1			 
19b1			        ; display bc 
19b1 2a da f0			ld hl, (os_view_bc) 
19b4 cd 13 1b			call display_dump_at_hl 
19b7			 
19b7 18 5c			jr .bpschk 
19b9 fe 35		.bps5:  cp '5' 
19bb 20 08		        jr nz, .bps7 
19bd			 
19bd				; display cur ptr 
19bd 2a 7b f9			ld hl, (cli_ptr) 
19c0 cd 13 1b			call display_dump_at_hl 
19c3			 
19c3 18 50			jr .bpschk 
19c5 fe 36		.bps7:  cp '6' 
19c7 20 08			jr nz, .bps8b 
19c9				 
19c9				; display cur orig ptr 
19c9 2a 79 f9			ld hl, (cli_origptr) 
19cc cd 13 1b			call display_dump_at_hl 
19cf 18 44			jr .bpschk 
19d1 fe 37		.bps8b:  cp '7' 
19d3 20 08			jr nz, .bps9 
19d5				 
19d5				; display dsp 
19d5 2a 29 f9			ld hl, (cli_data_sp) 
19d8 cd 13 1b			call display_dump_at_hl 
19db			 
19db 18 38			jr .bpschk 
19dd fe 39		.bps9:  cp '9' 
19df 20 05			jr nz, .bps8c 
19e1				 
19e1				; display SP 
19e1			;	ld hl, sp 
19e1 cd 13 1b			call display_dump_at_hl 
19e4			 
19e4 18 2f			jr .bpschk 
19e6 fe 38		.bps8c:  cp '8' 
19e8 20 08			jr nz, .bps8d 
19ea				 
19ea				; display rsp 
19ea 2a 2d f9			ld hl, (cli_ret_sp) 
19ed cd 13 1b			call display_dump_at_hl 
19f0			 
19f0 18 23			jr .bpschk 
19f2 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
19f4 20 05			jr nz, .bps8 
19f6 cd 5e 1d			call monitor 
19f9			 
19f9 18 1a			jr .bpschk 
19fb fe 30		.bps8:  cp '0' 
19fd 20 16			jr nz, .bpschk 
19ff			 
19ff 21 4b fc				ld hl, display_fb1 
1a02 22 07 fb				ld (display_fb_active), hl 
1a05 cd be 0d				call update_display 
1a08			 
1a08				;ld a, (os_view_af) 
1a08 2a de f0			ld hl, (os_view_hl) 
1a0b ed 5b dc f0		ld de, (os_view_de) 
1a0f ed 4b da f0		ld bc, (os_view_bc) 
1a13 f1				pop af 
1a14 c9				ret 
1a15			 
1a15			.bpschk:   
1a15 cd de 0c			call delay1s 
1a18 3e 9f		ld a,display_row_4 + display_cols - 1 
1a1a 11 8e 1f		        ld de, endprg 
1a1d cd ae 0d			call str_at_display 
1a20 cd be 0d			call update_display 
1a23 cd 81 79			call cin_wait 
1a26			 
1a26 c3 78 19			jp .bps1 
1a29			 
1a29			 
1a29			display_reg_state: 
1a29			 
1a29				; to restore afterwards 
1a29			 
1a29 d5				push de 
1a2a c5				push bc 
1a2b e5				push hl 
1a2c f5				push af 
1a2d			 
1a2d				; for use in here 
1a2d			 
1a2d c5				push bc 
1a2e d5				push de 
1a2f e5				push hl 
1a30 f5				push af 
1a31			 
1a31 cd 9b 0d			call clear_display 
1a34			 
1a34 11 e9 1a			ld de, .regstate 
1a37 3e 00			ld a, display_row_1 
1a39 cd ae 0d			call str_at_display 
1a3c			 
1a3c				; display debug step 
1a3c			 
1a3c			 
1a3c 11 a6 fd			ld de, debug_mark 
1a3f 3e 25			ld a, display_row_1+display_cols-3 
1a41 cd ae 0d			call str_at_display 
1a44			 
1a44				; display a 
1a44 11 05 1b			ld de, .regstatea 
1a47 3e 28			ld a, display_row_2 
1a49 cd ae 0d			call str_at_display 
1a4c			 
1a4c e1				pop hl 
1a4d			;	ld h,0 
1a4d			;	ld l, a 
1a4d 3e 2b			ld a, display_row_2+3 
1a4f cd cf 18			call display_word_at 
1a52			 
1a52			 
1a52				; display hl 
1a52			 
1a52			 
1a52 11 f9 1a			ld de, .regstatehl 
1a55 3e 32			ld a, display_row_2+10 
1a57 cd ae 0d			call str_at_display 
1a5a			 
1a5a e1				pop hl 
1a5b 3e 35			ld a, display_row_2+13 
1a5d cd cf 18			call display_word_at 
1a60			 
1a60				 
1a60				; display de 
1a60			 
1a60 11 fd 1a			ld de, .regstatede 
1a63 3e 50			ld a, display_row_3 
1a65 cd ae 0d			call str_at_display 
1a68			 
1a68 e1				pop hl 
1a69			;	ld h,d 
1a69			;	ld l, e 
1a69 3e 53			ld a, display_row_3+3 
1a6b cd cf 18			call display_word_at 
1a6e			 
1a6e			 
1a6e				; display bc 
1a6e			 
1a6e 11 01 1b			ld de, .regstatebc 
1a71 3e 5a			ld a, display_row_3+10 
1a73 cd ae 0d			call str_at_display 
1a76			 
1a76 e1				pop hl 
1a77			;	ld h,b 
1a77			;	ld l, c 
1a77 3e 5d			ld a, display_row_3+13 
1a79 cd cf 18			call display_word_at 
1a7c			 
1a7c			 
1a7c				; display dsp 
1a7c			 
1a7c 11 09 1b			ld de, .regstatedsp 
1a7f 3e 78			ld a, display_row_4 
1a81 cd ae 0d			call str_at_display 
1a84			 
1a84				 
1a84 2a 29 f9			ld hl,(cli_data_sp) 
1a87 3e 7c			ld a, display_row_4+4 
1a89 cd cf 18			call display_word_at 
1a8c			 
1a8c				; display rsp 
1a8c			 
1a8c 11 0e 1b			ld de, .regstatersp 
1a8f 3e 82			ld a, display_row_4+10 
1a91 cd ae 0d			call str_at_display 
1a94			 
1a94				 
1a94 2a 2d f9			ld hl,(cli_ret_sp) 
1a97 3e 86			ld a, display_row_4+14 
1a99 cd cf 18			call display_word_at 
1a9c			 
1a9c cd be 0d			call update_display 
1a9f			 
1a9f			;	call delay1s 
1a9f			;	call delay1s 
1a9f			;	call delay1s 
1a9f			 
1a9f			 
1a9f			;	call next_page_prompt 
1a9f			 
1a9f				; restore  
1a9f			 
1a9f f1				pop af 
1aa0 e1				pop hl 
1aa1 c1				pop bc 
1aa2 d1				pop de 
1aa3 c9				ret 
1aa4			 
1aa4 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1ab8 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1acd .. 00		.ptrstate:	db "Ptr State",0 
1ad7 .. 00		.ptrcliptr:     db "cli_ptr",0 
1adf .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1ae9 .. 00		.regstate:	db "Reg State (1/0)",0 
1af9 .. 00		.regstatehl:	db "HL:",0 
1afd .. 00		.regstatede:	db "DE:",0 
1b01 .. 00		.regstatebc:	db "BC:",0 
1b05 .. 00		.regstatea:	db "A :",0 
1b09 .. 00		.regstatedsp:	db "DSP:",0 
1b0e .. 00		.regstatersp:	db "RSP:",0 
1b13			 
1b13			display_dump_at_hl: 
1b13 e5				push hl 
1b14 d5				push de 
1b15 c5				push bc 
1b16 f5				push af 
1b17			 
1b17 22 1f f4			ld (os_cur_ptr),hl	 
1b1a cd 9b 0d			call clear_display 
1b1d cd 98 1e			call dumpcont 
1b20			;	call delay1s 
1b20			;	call next_page_prompt 
1b20			 
1b20			 
1b20 f1				pop af 
1b21 c1				pop bc 
1b22 d1				pop de 
1b23 e1				pop hl 
1b24 c9				ret 
1b25			 
1b25			;if ENABLE_BASIC 
1b25			;	include "nascombasic.asm" 
1b25			;	basic: 
1b25			;	include "forth/FORTH.ASM" 
1b25			;endif 
1b25			 
1b25			; eof 
1b25			 
1b25			 
# End of file firmware_diags.asm
1b25			  
1b25			include "firmware_prompts.asm"  
1b25			; Prompts  
1b25			 
1b25			; boot messages 
1b25			 
1b25 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1b3a .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1b4a			 
1b4a			 
1b4a			; config menus 
1b4a			 
1b4a			;prom_c3: db "Add Dictionary To File",0 
1b4a			 
1b4a			if STARTUP_V1 
1b4a			prom_c2: db "Select Autoload File",0 
1b4a			prom_c2a: db "Disable Autoload File", 0 
1b4a			endif 
1b4a			 
1b4a			if STARTUP_V2 
1b4a .. 00		prom_c2: db "Enable Autoload Files",0 
1b60 .. 00		prom_c2a: db "Disable Autoload Files", 0 
1b77			 
1b77 .. 00		crs_s1: db "*ls-word", 0 
1b80 .. 00		crs_s2: db "*ed-word", 0 
1b89 .. 00		crs_s3: db "*Demo-Programs", 0 
1b98 .. 00		crs_s4: db "*Utils", 0 
1b9f .. 00		crs_s5: db "*SPI-Util", 0 
1ba9 .. 00		crs_s6: db "*Key-constants", 0 
1bb8 .. 00		crs_sound: db "*Sound-Util", 0 
1bc4			 
1bc4			 
1bc4			 
1bc4			endif 
1bc4			;prom_c2b: db "Select Storage Bank",0 
1bc4 .. 00		prom_c4: db "Settings",0 
1bcd .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1be8 .. 00		prom_m4b:   db "Monitor",0 
1bf0 .. 00		prom_c1: db "Hardware Diags",0 
1bff			 
1bff			 
1bff			if STARTUP_V2 
1bff .. 00		prom_c9: db "Create Startup Files",0 
1c14			endif 
1c14			 
1c14 .. 00		prom_notav:    db "Feature not available",0 
1c2a .. 00		prom_empty:    db "",0 
1c2b			 
1c2b			; eof 
1c2b			 
# End of file firmware_prompts.asm
1c2b			  
1c2b			  
1c2b			; eof  
1c2b			  
# End of file firmware.asm
1c2b			 
1c2b			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1c2b			;if BASE_KEV  
1c2b			;baseram: equ 08000h 
1c2b			;endif 
1c2b			 
1c2b			;if BASE_SC114 
1c2b			;baseram:     equ    endofcode 
1c2b			;endif 
1c2b			 
1c2b			 
1c2b			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1c2b			 
1c2b			; start system 
1c2b			 
1c2b			coldstart: 
1c2b				; set sp 
1c2b				; di/ei 
1c2b			 
1c2b f3				di 
1c2c 31 fd ff			ld sp, tos 
1c2f cd 08 76			call init_nmi 
1c32			;	ei 
1c32			 
1c32				; init spinner 
1c32 3e 00			ld a,0 
1c34 32 01 fb			ld (display_active), a 
1c37			 
1c37				; disable breakpoint by default 
1c37			 
1c37				;ld a,'*' 
1c37			;	ld a,' ' 
1c37			;	ld (os_view_disable),a 
1c37			 
1c37				; set break point vector as new break point on or off 
1c37 cd 56 19			call bp_off 
1c3a			 
1c3a				; init hardware 
1c3a			 
1c3a				; init keyboard and screen hardware 
1c3a			 
1c3a cd 68 00			call hardware_init 
1c3d			 
1c3d			 
1c3d cd de 0c			call delay1s 
1c40 3e 58			ld a, display_row_3+8 
1c42 11 03 00			ld de, buildtime 
1c45 cd ae 0d			call str_at_display 
1c48 cd be 0d			call update_display 
1c4b			 
1c4b cd de 0c			call delay1s 
1c4e cd de 0c			call delay1s 
1c51 cd de 0c			call delay1s 
1c54			 
1c54				; detect if any keys are held down to enable breakpoints at start up 
1c54			 
1c54 cd 92 79			call cin  
1c57 fe 00			cp 0 
1c59 28 03			jr z, .nokeys 
1c5b			 
1c5b				;call hardware_diags 
1c5b cd 50 15			call config 
1c5e			 
1c5e			;	ld de, .bpen 
1c5e			;	ld a, display_row_4 
1c5e			;	call str_at_display 
1c5e			;	call update_display 
1c5e			; 
1c5e			;	ld a,0 
1c5e			;	ld (os_view_disable),a 
1c5e			; 
1c5e			;.bpwait: 
1c5e			;	call cin 
1c5e			;	cp 0 
1c5e			;	jr z, .bpwait 
1c5e			;	jr .nokeys 
1c5e			; 
1c5e			; 
1c5e			;.bpen:  db "Break points enabled!",0 
1c5e			 
1c5e			 
1c5e			 
1c5e			 
1c5e			 
1c5e			 
1c5e			.nokeys: 
1c5e			 
1c5e			 
1c5e				 
1c5e			 
1c5e			;jp  testkey 
1c5e			 
1c5e			;call storage_get_block_0 
1c5e			; 
1c5e			;ld hl, 0 
1c5e			;ld de, store_page 
1c5e			;call storage_read_block 
1c5e			 
1c5e				 
1c5e			;ld hl, 10 
1c5e			;ld de, store_page 
1c5e			;call storage_read_block 
1c5e			 
1c5e			 
1c5e			 
1c5e			 
1c5e			 
1c5e			;stop:	nop 
1c5e			;	jp stop 
1c5e			 
1c5e			 
1c5e			 
1c5e			main: 
1c5e cd 9b 0d			call clear_display 
1c61 cd be 0d			call update_display 
1c64			 
1c64			 
1c64			 
1c64			;	call testlcd 
1c64			 
1c64			 
1c64			 
1c64 cd 95 23			call forth_init 
1c67			 
1c67			 
1c67			warmstart: 
1c67 cd 6b 23			call forth_warmstart 
1c6a			 
1c6a				; run startup word load 
1c6a			        ; TODO prevent this running at warmstart after crash  
1c6a			 
1c6a				if STARTUP_ENABLE 
1c6a			 
1c6a					if STARTUP_V1 
1c6a			 
1c6a						if STORAGE_SE 
1c6a							call forth_autoload 
1c6a						endif 
1c6a						call forth_startup 
1c6a					endif 
1c6a			 
1c6a					if STARTUP_V2 
1c6a			 
1c6a						if STORAGE_SE 
1c6a cd 36 74						call forth_autoload 
1c6d						else 
1c6d							call forth_startup 
1c6d						endif 
1c6d			 
1c6d			 
1c6d					endif 
1c6d			 
1c6d				endif 
1c6d			 
1c6d				; show free memory after boot 
1c6d 11 f9 1c			ld de, freeram 
1c70 3e 00			ld a, display_row_1 
1c72 cd ae 0d			call str_at_display 
1c75			 
1c75				; get current heap start after loading any uwords 
1c75			 
1c75				;ld de, (os_last_new_uword) 
1c75				;ex de, hl 
1c75			 
1c75			; Or use heap_size word???? 
1c75				;ld hl, heap_end 
1c75				;ld hl, heap_size 
1c75				;ld de, topusermem 
1c75				;ld de, heap_start 
1c75 ed 5b 0a 80			ld de, (free_list )      
1c79 21 d7 f0				ld hl, heap_end 
1c7c ed 52			sbc hl, de 
1c7e				;push hl 
1c7e				;ld a,h	         	 
1c7e				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1c7e				;call hexout 
1c7e			   	;pop hl 
1c7e			; 
1c7e			;	ld a,l 
1c7e			;	ld hl, os_word_scratch+2 
1c7e			;	call hexout 
1c7e			;	ld hl, os_word_scratch+4 
1c7e			;	ld a, 0 
1c7e			;	ld (hl),a 
1c7e eb				ex de, hl 
1c7f 21 01 f4			ld hl, os_word_scratch 
1c82 cd f1 12			call uitoa_16 
1c85			 
1c85			 
1c85 11 01 f4			ld de, os_word_scratch 
1c88 3e 0d			ld a, display_row_1 + 13 
1c8a cd ae 0d			call str_at_display 
1c8d cd be 0d			call update_display 
1c90			 
1c90			 
1c90				;call demo 
1c90			 
1c90			 
1c90				; init scratch input area for cli commands 
1c90			 
1c90 21 23 f4			ld hl, os_cli_cmd 
1c93 3e 00			ld a,0 
1c95 77				ld (hl),a 
1c96 23				inc hl 
1c97 77				ld (hl),a 
1c98			 
1c98 3e 00			ld a,0 
1c9a 32 22 f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1c9d			 
1c9d 32 1f f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1ca0 32 20 f4			ld (os_cur_ptr+1),a	 
1ca3			 
1ca3 32 01 f4			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1ca6 32 02 f4			ld (os_word_scratch+1),a	 
1ca9				 
1ca9			 
1ca9				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ca9 21 23 f4			ld hl, os_cli_cmd 
1cac			 
1cac 3e 00			ld a, 0		 ; init cli input 
1cae 77				ld (hl), a 
1caf 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cb1			cli: 
1cb1				; show cli prompt 
1cb1				;push af 
1cb1				;ld a, 0 
1cb1				;ld de, prompt 
1cb1				;call str_at_display 
1cb1			 
1cb1				;call update_display 
1cb1				;pop af 
1cb1				;inc a 
1cb1				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1cb1 0e 00			ld c, 0 
1cb3 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1cb5 1e 28			ld e, 40 
1cb7			 
1cb7 21 23 f4			ld hl, os_cli_cmd 
1cba			 
1cba				STACKFRAME OFF $fefe $9f9f 
1cba				if DEBUG_STACK_IMB 
1cba					if OFF 
1cba						exx 
1cba						ld de, $fefe 
1cba						ld a, d 
1cba						ld hl, curframe 
1cba						call hexout 
1cba						ld a, e 
1cba						ld hl, curframe+2 
1cba						call hexout 
1cba						ld hl, $fefe 
1cba						push hl 
1cba						ld hl, $9f9f 
1cba						push hl 
1cba						exx 
1cba					endif 
1cba				endif 
1cba			endm 
# End of macro STACKFRAME
1cba			 
1cba cd fc 0f			call input_str 
1cbd			 
1cbd				STACKFRAMECHK OFF $fefe $9f9f 
1cbd				if DEBUG_STACK_IMB 
1cbd					if OFF 
1cbd						exx 
1cbd						ld hl, $9f9f 
1cbd						pop de   ; $9f9f 
1cbd						call cmp16 
1cbd						jr nz, .spnosame 
1cbd						ld hl, $fefe 
1cbd						pop de   ; $fefe 
1cbd						call cmp16 
1cbd						jr z, .spfrsame 
1cbd						.spnosame: call showsperror 
1cbd						.spfrsame: nop 
1cbd						exx 
1cbd					endif 
1cbd				endif 
1cbd			endm 
# End of macro STACKFRAMECHK
1cbd			 
1cbd				; copy input to last command 
1cbd			 
1cbd 21 23 f4			ld hl, os_cli_cmd 
1cc0 11 22 f5			ld de, os_last_cmd 
1cc3 01 ff 00			ld bc, 255 
1cc6 ed b0			ldir 
1cc8			 
1cc8				; wipe current buffer 
1cc8			 
1cc8			;	ld a, 0 
1cc8			;	ld hl, os_cli_cmd 
1cc8			;	ld de, os_cli_cmd+1 
1cc8			;	ld bc, 254 
1cc8			;	ldir 
1cc8				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1cc8			;	call strcpy 
1cc8			;	ld a, 0 
1cc8			;	ld (hl), a 
1cc8			;	inc hl 
1cc8			;	ld (hl), a 
1cc8			;	inc hl 
1cc8			;	ld (hl), a 
1cc8			 
1cc8				; switch frame buffer to program  
1cc8			 
1cc8 21 4b fc				ld hl, display_fb1 
1ccb 22 07 fb				ld (display_fb_active), hl 
1cce			 
1cce			;	nop 
1cce				STACKFRAME ON $fbfe $8f9f 
1cce				if DEBUG_STACK_IMB 
1cce					if ON 
1cce						exx 
1cce						ld de, $fbfe 
1cce						ld a, d 
1cce						ld hl, curframe 
1cce						call hexout 
1cce						ld a, e 
1cce						ld hl, curframe+2 
1cce						call hexout 
1cce						ld hl, $fbfe 
1cce						push hl 
1cce						ld hl, $8f9f 
1cce						push hl 
1cce						exx 
1cce					endif 
1cce				endif 
1cce			endm 
# End of macro STACKFRAME
1cce				; first time into the parser so pass over the current scratch pad 
1cce 21 23 f4			ld hl,os_cli_cmd 
1cd1				; tokenise the entered statement(s) in HL 
1cd1 cd 13 24			call forthparse 
1cd4			        ; exec forth statements in top of return stack 
1cd4 cd 53 24			call forthexec 
1cd7				;call forthexec_cleanup 
1cd7			;	call parsenext 
1cd7			 
1cd7				STACKFRAMECHK ON $fbfe $8f9f 
1cd7				if DEBUG_STACK_IMB 
1cd7					if ON 
1cd7						exx 
1cd7						ld hl, $8f9f 
1cd7						pop de   ; $8f9f 
1cd7						call cmp16 
1cd7						jr nz, .spnosame 
1cd7						ld hl, $fbfe 
1cd7						pop de   ; $fbfe 
1cd7						call cmp16 
1cd7						jr z, .spfrsame 
1cd7						.spnosame: call showsperror 
1cd7						.spfrsame: nop 
1cd7						exx 
1cd7					endif 
1cd7				endif 
1cd7			endm 
# End of macro STACKFRAMECHK
1cd7				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1cd7			 
1cd7 3e 78			ld a, display_row_4 
1cd9 11 0a 1d			ld de, endprog 
1cdc			 
1cdc cd be 0d			call update_display		 
1cdf			 
1cdf cd 90 1f			call next_page_prompt 
1ce2			 
1ce2				; switch frame buffer to cli 
1ce2			 
1ce2 21 ec fc				ld hl, display_fb0 
1ce5 22 07 fb				ld (display_fb_active), hl 
1ce8			 
1ce8			 
1ce8 cd 9b 0d		        call clear_display 
1ceb cd be 0d			call update_display		 
1cee			 
1cee 21 23 f4			ld hl, os_cli_cmd 
1cf1			 
1cf1 3e 00			ld a, 0		 ; init cli input 
1cf3 77				ld (hl), a 
1cf4			 
1cf4				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1cf4			 
1cf4				; now on last line 
1cf4			 
1cf4				; TODO scroll screen up 
1cf4			 
1cf4				; TODO instead just clear screen and place at top of screen 
1cf4			 
1cf4			;	ld a, 0 
1cf4			;	ld (f_cursor_ptr),a 
1cf4			 
1cf4				;call clear_display 
1cf4				;call update_display 
1cf4			 
1cf4				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cf4 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cf6 c3 b1 1c			jp cli 
1cf9			 
1cf9 .. 00		freeram: db "Free bytes: ",0 
1d06 ..			asc: db "1A2F" 
1d0a .. 00		endprog: db "End prog...",0 
1d16			 
1d16			testenter2:   
1d16 21 2e f1			ld hl,scratch+50 
1d19 22 1f f4			ld (os_cur_ptr),hl 
1d1c c3 b1 1c			jp cli 
1d1f			 
1d1f			testenter:  
1d1f			 
1d1f 21 06 1d			ld hl,asc 
1d22			;	ld a,(hl) 
1d22			;	call nibble2val 
1d22 cd 3b 12			call get_byte 
1d25			 
1d25			 
1d25			;	ld a,(hl) 
1d25			;	call atohex 
1d25			 
1d25			;	call fourehexhl 
1d25 32 2e f1			ld (scratch+50),a 
1d28			 
1d28			 
1d28			 
1d28 21 08 1d			ld hl,asc+2 
1d2b			;	ld a, (hl) 
1d2b			;	call nibble2val 
1d2b cd 3b 12			call get_byte 
1d2e			 
1d2e			;	call fourehexhl 
1d2e 32 30 f1			ld (scratch+52),a 
1d31				 
1d31 21 2e f1			ld hl,scratch+50 
1d34 22 1f f4			ld (os_cur_ptr),hl 
1d37 c3 b1 1c			jp cli 
1d3a			 
1d3a			enter:	 
1d3a 3a 00 f1			ld a,(scratch+4) 
1d3d fe 00			cp 0 
1d3f 28 0c			jr z, .entercont 
1d41				; no, not a null term line so has an address to work out.... 
1d41			 
1d41 21 fe f0			ld hl,scratch+2 
1d44 cd 9b 12			call get_word_hl 
1d47			 
1d47 22 1f f4			ld (os_cur_ptr),hl	 
1d4a c3 b1 1c			jp cli 
1d4d			 
1d4d			 
1d4d			.entercont:  
1d4d			 
1d4d 21 fe f0			ld hl, scratch+2 
1d50 cd 3b 12			call get_byte 
1d53			 
1d53 2a 1f f4		   	ld hl,(os_cur_ptr) 
1d56 77					ld (hl),a 
1d57 23					inc hl 
1d58 22 1f f4				ld (os_cur_ptr),hl 
1d5b				 
1d5b			; get byte  
1d5b			 
1d5b			 
1d5b c3 b1 1c			jp cli 
1d5e			 
1d5e			 
1d5e			; basic monitor support 
1d5e			 
1d5e			monitor: 
1d5e				;  
1d5e cd 9b 0d			call clear_display 
1d61 3e 00			ld a, 0 
1d63 11 b2 1d			ld de, .monprompt 
1d66 cd ae 0d			call str_at_display 
1d69 cd be 0d			call update_display 
1d6c			 
1d6c				; get a monitor command 
1d6c			 
1d6c 0e 00			ld c, 0     ; entry at top left 
1d6e 16 64			ld d, 100   ; max buffer size 
1d70 1e 0f			ld e, 15    ; input scroll area 
1d72 3e 00			ld a, 0     ; init string 
1d74 21 fa f2			ld hl, os_input 
1d77 77				ld (hl), a 
1d78 23				inc hl 
1d79 77				ld (hl), a 
1d7a 21 fa f2			ld hl, os_input 
1d7d 3e 01			ld a, 1     ; init string 
1d7f cd fc 0f			call input_str 
1d82			 
1d82 cd 9b 0d		        call clear_display 
1d85 cd be 0d			call update_display		 
1d88			 
1d88 3a fa f2			ld a, (os_input) 
1d8b cd 39 13			call toUpper 
1d8e fe 48		        cp 'H' 
1d90 ca 17 1e		        jp z, .monhelp 
1d93 fe 44			cp 'D'		; dump 
1d95 ca 4a 1e			jp z, .mondump	 
1d98 fe 43			cp 'C'		; dump 
1d9a ca 64 1e			jp z, .moncdump	 
1d9d fe 4d			cp 'M'		; dump 
1d9f ca b4 1d			jp z, .moneditstart 
1da2 fe 55			cp 'U'		; dump 
1da4 ca c0 1d			jp z, .monedit	 
1da7 fe 47			cp 'G'		; dump 
1da9 ca 40 1e			jp z, .monjump 
1dac fe 51			cp 'Q'		; dump 
1dae c8				ret z	 
1daf			 
1daf			 
1daf				; TODO "S" to access symbol by name and not need the address 
1daf				; TODO "F" to find a string in memory 
1daf			 
1daf c3 5e 1d			jp monitor 
1db2			 
1db2 .. 00		.monprompt: db ">", 0 
1db4			 
1db4			.moneditstart: 
1db4				; get starting address 
1db4			 
1db4 21 fc f2			ld hl,os_input+2 
1db7 cd 9b 12			call get_word_hl 
1dba			 
1dba 22 1f f4			ld (os_cur_ptr),hl	 
1dbd			 
1dbd c3 5e 1d			jp monitor 
1dc0			 
1dc0			.monedit: 
1dc0				; get byte to load 
1dc0			 
1dc0 21 fc f2			ld hl,os_input+2 
1dc3 cd 3b 12			call get_byte 
1dc6			 
1dc6				; get address to update 
1dc6 2a 1f f4			ld hl, (os_cur_ptr) 
1dc9			 
1dc9				; update byte 
1dc9			 
1dc9 77				ld (hl), a 
1dca			 
1dca				; move to next address and save it 
1dca			 
1dca 23				inc hl 
1dcb 22 1f f4			ld (os_cur_ptr),hl	 
1dce			 
1dce c3 5e 1d			jp monitor 
1dd1			 
1dd1			 
1dd1 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1de5 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1e01 .. 00		.monhelptext3:  db "G-Call address",0 
1e10 .. 00		.monhelptext4:  db "Q-Quit",0 
1e17			        
1e17			.monhelp: 
1e17 3e 00			ld a, display_row_1 
1e19 11 d1 1d		        ld de, .monhelptext1 
1e1c			 
1e1c cd ae 0d			call str_at_display 
1e1f 3e 28			ld a, display_row_2 
1e21 11 e5 1d		        ld de, .monhelptext2 
1e24					 
1e24 cd ae 0d			call str_at_display 
1e27 3e 50			ld a, display_row_3 
1e29 11 01 1e		        ld de, .monhelptext3 
1e2c					 
1e2c cd ae 0d			call str_at_display 
1e2f 3e 78			ld a, display_row_4 
1e31 11 10 1e		        ld de, .monhelptext4 
1e34 cd ae 0d			call str_at_display 
1e37			 
1e37 cd be 0d			call update_display		 
1e3a			 
1e3a cd 90 1f			call next_page_prompt 
1e3d c3 5e 1d			jp monitor 
1e40			 
1e40			.monjump:    
1e40 21 fc f2			ld hl,os_input+2 
1e43 cd 9b 12			call get_word_hl 
1e46			 
1e46 e9				jp (hl) 
1e47 c3 5e 1d			jp monitor 
1e4a			 
1e4a			.mondump:    
1e4a 21 fc f2			ld hl,os_input+2 
1e4d cd 9b 12			call get_word_hl 
1e50			 
1e50 22 1f f4			ld (os_cur_ptr),hl	 
1e53 cd 98 1e			call dumpcont 
1e56 3e 78			ld a, display_row_4 
1e58 11 0a 1d			ld de, endprog 
1e5b			 
1e5b cd be 0d			call update_display		 
1e5e			 
1e5e cd 90 1f			call next_page_prompt 
1e61 c3 5e 1d			jp monitor 
1e64			.moncdump: 
1e64 cd 98 1e			call dumpcont 
1e67 3e 78			ld a, display_row_4 
1e69 11 0a 1d			ld de, endprog 
1e6c			 
1e6c cd be 0d			call update_display		 
1e6f			 
1e6f cd 90 1f			call next_page_prompt 
1e72 c3 5e 1d			jp monitor 
1e75			 
1e75			 
1e75			; TODO symbol access  
1e75			 
1e75			.symbols:     ;; A list of symbols that can be called up  
1e75 ec fc			dw display_fb0 
1e77 .. 00			db "fb0",0  
1e7b b5 f9		     	dw store_page 
1e7d .. 00			db "store_page",0 
1e88			 
1e88			 
1e88			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1e88			 
1e88 3a fd f0			ld a,(scratch+1) 
1e8b fe 00			cp 0 
1e8d 28 09			jr z, dumpcont 
1e8f			 
1e8f				; no, not a null term line so has an address to work out.... 
1e8f			 
1e8f 21 fe f0			ld hl,scratch+2 
1e92 cd 9b 12			call get_word_hl 
1e95			 
1e95 22 1f f4			ld (os_cur_ptr),hl	 
1e98			 
1e98			 
1e98			 
1e98			dumpcont: 
1e98			 
1e98				; dump bytes at ptr 
1e98			 
1e98			 
1e98 3e 00			ld a, display_row_1 
1e9a 2a 07 fb			ld hl, (display_fb_active) 
1e9d cd cf 0f			call addatohl 
1ea0 cd c8 1e			call .dumpbyterow 
1ea3			 
1ea3 3e 28			ld a, display_row_2 
1ea5 2a 07 fb			ld hl, (display_fb_active) 
1ea8 cd cf 0f			call addatohl 
1eab cd c8 1e			call .dumpbyterow 
1eae			 
1eae			 
1eae 3e 50			ld a, display_row_3 
1eb0 2a 07 fb			ld hl, (display_fb_active) 
1eb3 cd cf 0f			call addatohl 
1eb6 cd c8 1e			call .dumpbyterow 
1eb9			 
1eb9 3e 78			ld a, display_row_4 
1ebb 2a 07 fb			ld hl, (display_fb_active) 
1ebe cd cf 0f			call addatohl 
1ec1 cd c8 1e			call .dumpbyterow 
1ec4			 
1ec4 cd be 0d			call update_display 
1ec7			;		jp cli 
1ec7 c9				ret 
1ec8			 
1ec8			.dumpbyterow: 
1ec8			 
1ec8				;push af 
1ec8			 
1ec8 e5				push hl 
1ec9			 
1ec9				; calc where to poke the ascii 
1ec9			if display_cols == 20 
1ec9				ld a, 16 
1ec9			else 
1ec9 3e 1f			ld a, 31 
1ecb			endif 
1ecb			 
1ecb cd cf 0f			call addatohl 
1ece 22 01 f4			ld (os_word_scratch),hl  		; save pos for later 
1ed1			 
1ed1			 
1ed1			; display decoding address 
1ed1 2a 1f f4		   	ld hl,(os_cur_ptr) 
1ed4			 
1ed4 7c				ld a,h 
1ed5 e1				pop hl 
1ed6 e5				push hl 
1ed7			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1ed7 cd e5 11			call hexout 
1eda 2a 1f f4		   	ld hl,(os_cur_ptr) 
1edd			 
1edd 7d				ld a,l 
1ede e1				pop hl 
1edf 23				inc hl 
1ee0 23				inc hl 
1ee1 e5				push hl 
1ee2			;	ld hl, os_word_scratch+2 
1ee2 cd e5 11			call hexout 
1ee5 e1				pop hl 
1ee6 23				inc hl 
1ee7 23				inc hl 
1ee8				;ld hl, os_word_scratch+4 
1ee8 3e 3a			ld a, ':' 
1eea 77				ld (hl),a 
1eeb 23				inc hl 
1eec				;ld a, 0 
1eec				;ld (hl),a 
1eec				;ld de, os_word_scratch 
1eec				;pop af 
1eec				;push af 
1eec			;		ld a, display_row_2 
1eec			;		call str_at_display 
1eec			;		call update_display 
1eec			 
1eec			 
1eec			;pop af 
1eec			;	add 5 
1eec			 
1eec			if display_cols == 20 
1eec				ld b, 4 
1eec			else 
1eec 06 08			ld b, 8 
1eee			endif	 
1eee			 
1eee			.dumpbyte: 
1eee c5				push bc 
1eef e5				push hl 
1ef0			 
1ef0			 
1ef0 2a 1f f4		   	ld hl,(os_cur_ptr) 
1ef3 7e					ld a,(hl) 
1ef4			 
1ef4					; poke the ascii to display 
1ef4 2a 01 f4				ld hl,(os_word_scratch) 
1ef7 77					ld (hl),a 
1ef8 23					inc hl 
1ef9 22 01 f4				ld (os_word_scratch),hl 
1efc			 
1efc					 
1efc			 
1efc			 
1efc e1					pop hl 
1efd e5					push hl 
1efe			 
1efe cd e5 11				call hexout 
1f01			 
1f01					 
1f01 2a 1f f4		   	ld hl,(os_cur_ptr) 
1f04 23				inc hl 
1f05 22 1f f4		   	ld (os_cur_ptr),hl 
1f08			 
1f08 e1					pop hl 
1f09 23					inc hl 
1f0a 23					inc hl 
1f0b 23					inc hl 
1f0c			 
1f0c			 
1f0c			 
1f0c					;ld a,0 
1f0c					;ld (os_word_scratch+2),a 
1f0c					;pop af 
1f0c					;push af 
1f0c			 
1f0c					;ld de, os_word_scratch 
1f0c					;call str_at_display 
1f0c			;		call update_display 
1f0c			;		pop af 
1f0c c1					pop bc 
1f0d c6 03				add 3 
1f0f 10 dd			djnz .dumpbyte 
1f11			 
1f11				 
1f11			 
1f11 c9				ret 
1f12			 
1f12			jump:	 
1f12			 
1f12 21 fe f0			ld hl,scratch+2 
1f15 cd 9b 12			call get_word_hl 
1f18				;ld hl,(scratch+2) 
1f18				;call fourehexhl 
1f18			 
1f18 22 1f f4			ld (os_cur_ptr),hl	 
1f1b			 
1f1b e9				jp (hl) 
1f1c			 
1f1c			 
1f1c			 
1f1c			; TODO implement a basic monitor mode to start with 
1f1c			 
1f1c			 
1f1c			 
1f1c			 
1f1c			 
1f1c			 
1f1c			 
1f1c			 
1f1c			 
1f1c			; testing and demo code during development 
1f1c			 
1f1c			 
1f1c .. 00		str1: db "Enter some text...",0 
1f2f .. 00		clear: db "                    ",0 
1f44			 
1f44			demo: 
1f44			 
1f44			 
1f44			 
1f44			;	call update_display 
1f44			 
1f44				; init scratch input area for testing 
1f44 21 fc f0			ld hl, scratch	 
1f47 3e 00			ld a,0 
1f49 77				ld (hl),a 
1f4a			 
1f4a			 
1f4a 3e 28		            LD   A, display_row_2 
1f4c			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f4c 11 1c 1f		            LD   DE, str1 
1f4f cd ae 0d			call str_at_display 
1f52			 
1f52			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f52			cloop:	 
1f52 3e 50		            LD   A, display_row_3 
1f54			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f54 11 2f 1f		            LD   DE, clear 
1f57			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1f57 cd ae 0d				call str_at_display 
1f5a 3e 78			ld a, display_row_4 
1f5c 11 8c 1f			ld de, prompt 
1f5f			 
1f5f cd ae 0d				call str_at_display 
1f62 cd be 0d			call update_display 
1f65			 
1f65 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1f67 16 0a			ld d, 10 
1f69 21 fc f0			ld hl, scratch	 
1f6c cd fc 0f			call input_str 
1f6f			 
1f6f			;	call clear_display 
1f6f			;'	call update_display 
1f6f			 
1f6f 3e 00		            LD   A, display_row_1 
1f71			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f71 11 2f 1f		            LD   DE, clear 
1f74 cd ae 0d				call str_at_display 
1f77			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f77 3e 00		            LD   A, display_row_1 
1f79			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f79 11 fc f0		            LD   DE, scratch 
1f7c			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f7c cd ae 0d				call str_at_display 
1f7f cd be 0d			call update_display 
1f82			 
1f82 3e 00				ld a,0 
1f84 21 fc f0			ld hl, scratch 
1f87 77				ld (hl),a 
1f88			 
1f88 00				nop 
1f89 c3 52 1f			jp cloop 
1f8c			 
1f8c			 
1f8c			 
1f8c			; OS Prompt 
1f8c			 
1f8c .. 00		prompt: db ">",0 
1f8e .. 00		endprg: db "?",0 
1f90			 
1f90			 
1f90			; handy next page prompt 
1f90			next_page_prompt: 
1f90 e5				push hl 
1f91 d5				push de 
1f92 f5				push af 
1f93 c5				push bc 
1f94			 
1f94 3e 9f			ld a,display_row_4 + display_cols - 1 
1f96 11 8e 1f		        ld de, endprg 
1f99 cd ae 0d			call str_at_display 
1f9c cd be 0d			call update_display 
1f9f cd 81 79			call cin_wait 
1fa2 c1				pop bc 
1fa3 f1				pop af 
1fa4 d1				pop de 
1fa5 e1				pop hl 
1fa6			 
1fa6			 
1fa6 c9				ret 
1fa7			 
1fa7			 
1fa7			; forth parser 
1fa7			 
1fa7			; My forth kernel 
1fa7			include "forth_kernel.asm" 
1fa7			; 
1fa7			; kernel to the forth OS 
1fa7			 
1fa7			DS_TYPE_STR: equ 1     ; string type 
1fa7			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1fa7			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1fa7			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1fa7			 
1fa7			FORTH_PARSEV1: equ 0 
1fa7			FORTH_PARSEV2: equ 0 
1fa7			FORTH_PARSEV3: equ 0 
1fa7			FORTH_PARSEV4: equ 0 
1fa7			FORTH_PARSEV5: equ 1 
1fa7			 
1fa7			;if FORTH_PARSEV5 
1fa7			;	FORTH_END_BUFFER: equ 0 
1fa7			;else 
1fa7			FORTH_END_BUFFER: equ 127 
1fa7			;endif 
1fa7			 
1fa7			FORTH_TRUE: equ 1 
1fa7			FORTH_FALSE: equ 0 
1fa7			 
1fa7			if FORTH_PARSEV4 
1fa7			include "forth_stackops.asm" 
1fa7			endif 
1fa7			 
1fa7			if FORTH_PARSEV5 
1fa7			include "forth_stackopsv5.asm" 
1fa7			 
1fa7			; Stack operations for v5 parser on wards 
1fa7			; * DATA stack 
1fa7			; * LOOP stack 
1fa7			; * RETURN stack 
1fa7			 
1fa7			 
1fa7			 
1fa7			FORTH_CHK_DSP_UNDER: macro 
1fa7				push hl 
1fa7				push de 
1fa7				ld hl,(cli_data_sp) 
1fa7				ld de, cli_data_stack 
1fa7				call cmp16 
1fa7				jp c, fault_dsp_under 
1fa7				pop de 
1fa7				pop hl 
1fa7				endm 
1fa7			 
1fa7			 
1fa7			FORTH_CHK_RSP_UNDER: macro 
1fa7				push hl 
1fa7				push de 
1fa7				ld hl,(cli_ret_sp) 
1fa7				ld de, cli_ret_stack 
1fa7				call cmp16 
1fa7				jp c, fault_rsp_under 
1fa7				pop de 
1fa7				pop hl 
1fa7				endm 
1fa7			 
1fa7			FORTH_CHK_LOOP_UNDER: macro 
1fa7				push hl 
1fa7				push de 
1fa7				ld hl,(cli_loop_sp) 
1fa7				ld de, cli_loop_stack 
1fa7				call cmp16 
1fa7				jp c, fault_loop_under 
1fa7				pop de 
1fa7				pop hl 
1fa7				endm 
1fa7			 
1fa7			FORTH_ERR_TOS_NOTSTR: macro 
1fa7				; TOSO might need more for checks when used 
1fa7				push af 
1fa7				ld a,(hl) 
1fa7				cp DS_TYPE_STR 
1fa7				jp nz, type_faultn   
1fa7				pop af 
1fa7				endm 
1fa7			 
1fa7			FORTH_ERR_TOS_NOTNUM: macro 
1fa7				push af 
1fa7				ld a,(hl) 
1fa7				cp DS_TYPE_INUM 
1fa7				jp nz, type_faultn   
1fa7				pop af 
1fa7				endm 
1fa7			 
1fa7			 
1fa7			; increase data stack pointer and save hl to it 
1fa7				 
1fa7			FORTH_DSP_NEXT: macro 
1fa7				call macro_forth_dsp_next 
1fa7				endm 
1fa7			 
1fa7			 
1fa7			macro_forth_dsp_next: 
1fa7				if DEBUG_FORTH_STACK_GUARD 
1fa7 cd 2e 72				call check_stacks 
1faa				endif 
1faa e5				push hl 
1fab d5				push de 
1fac eb				ex de,hl 
1fad 2a 29 f9			ld hl,(cli_data_sp) 
1fb0 23				inc hl 
1fb1 23				inc hl 
1fb2			 
1fb2			; PARSEV5 
1fb2 23				inc hl 
1fb3 22 29 f9			ld (cli_data_sp),hl 
1fb6 73				ld (hl), e 
1fb7 23				inc hl 
1fb8 72				ld (hl), d 
1fb9 d1				pop de 
1fba e1				pop hl 
1fbb				if DEBUG_FORTH_STACK_GUARD 
1fbb cd 2e 72				call check_stacks 
1fbe				endif 
1fbe c9				ret 
1fbf			 
1fbf			 
1fbf			; increase ret stack pointer and save hl to it 
1fbf				 
1fbf			FORTH_RSP_NEXT: macro 
1fbf				call macro_forth_rsp_next 
1fbf				endm 
1fbf			 
1fbf			macro_forth_rsp_next: 
1fbf				if DEBUG_FORTH_STACK_GUARD 
1fbf cd 2e 72				call check_stacks 
1fc2				endif 
1fc2 e5				push hl 
1fc3 d5				push de 
1fc4 eb				ex de,hl 
1fc5 2a 2d f9			ld hl,(cli_ret_sp) 
1fc8 23				inc hl 
1fc9 23				inc hl 
1fca 22 2d f9			ld (cli_ret_sp),hl 
1fcd 73				ld (hl), e 
1fce 23				inc hl 
1fcf 72				ld (hl), d 
1fd0 d1				pop de 
1fd1 e1				pop hl 
1fd2				if DEBUG_FORTH_STACK_GUARD 
1fd2 cd 2e 72				call check_stacks 
1fd5				endif 
1fd5 c9				ret 
1fd6			 
1fd6			; get current ret stack pointer and save to hl  
1fd6				 
1fd6			FORTH_RSP_TOS: macro 
1fd6				call macro_forth_rsp_tos 
1fd6				endm 
1fd6			 
1fd6			macro_forth_rsp_tos: 
1fd6				;push de 
1fd6 2a 2d f9			ld hl,(cli_ret_sp) 
1fd9 cd 11 20			call loadhlptrtohl 
1fdc				;ld e, (hl) 
1fdc				;inc hl 
1fdc				;ld d, (hl) 
1fdc				;ex de, hl 
1fdc					if DEBUG_FORTH_WORDS 
1fdc			;			DMARK "RST" 
1fdc						CALLMONITOR 
1fdc cd aa fd			call debug_vector  
1fdf				endm  
# End of macro CALLMONITOR
1fdf					endif 
1fdf				;pop de 
1fdf c9				ret 
1fe0			 
1fe0			; pop ret stack pointer 
1fe0				 
1fe0			FORTH_RSP_POP: macro 
1fe0				call macro_forth_rsp_pop 
1fe0				endm 
1fe0			 
1fe0			 
1fe0			macro_forth_rsp_pop: 
1fe0				if DEBUG_FORTH_STACK_GUARD 
1fe0			;		DMARK "RPP" 
1fe0 cd 2e 72				call check_stacks 
1fe3					FORTH_CHK_RSP_UNDER 
1fe3 e5				push hl 
1fe4 d5				push de 
1fe5 2a 2d f9			ld hl,(cli_ret_sp) 
1fe8 11 e7 f8			ld de, cli_ret_stack 
1feb cd ed 0f			call cmp16 
1fee da 42 73			jp c, fault_rsp_under 
1ff1 d1				pop de 
1ff2 e1				pop hl 
1ff3				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ff3				endif 
1ff3 e5				push hl 
1ff4 2a 2d f9			ld hl,(cli_ret_sp) 
1ff7			 
1ff7			 
1ff7				if FORTH_ENABLE_FREE 
1ff7			 
1ff7					; get pointer 
1ff7			 
1ff7					push de 
1ff7					push hl 
1ff7			 
1ff7					ld e, (hl) 
1ff7					inc hl 
1ff7					ld d, (hl) 
1ff7			 
1ff7					ex de, hl 
1ff7					call free 
1ff7			 
1ff7					pop hl 
1ff7					pop de 
1ff7			 
1ff7			 
1ff7				endif 
1ff7			 
1ff7			 
1ff7 2b				dec hl 
1ff8 2b				dec hl 
1ff9 22 2d f9			ld (cli_ret_sp), hl 
1ffc				; do stack underflow checks 
1ffc e1				pop hl 
1ffd				if DEBUG_FORTH_STACK_GUARD 
1ffd cd 2e 72				call check_stacks 
2000					FORTH_CHK_RSP_UNDER 
2000 e5				push hl 
2001 d5				push de 
2002 2a 2d f9			ld hl,(cli_ret_sp) 
2005 11 e7 f8			ld de, cli_ret_stack 
2008 cd ed 0f			call cmp16 
200b da 42 73			jp c, fault_rsp_under 
200e d1				pop de 
200f e1				pop hl 
2010				endm 
# End of macro FORTH_CHK_RSP_UNDER
2010				endif 
2010 c9				ret 
2011			 
2011			 
2011			 
2011			; routine to load word pointed to by hl into hl 
2011			 
2011			loadhlptrtohl: 
2011			 
2011 d5				push de 
2012 5e				ld e, (hl) 
2013 23				inc hl 
2014 56				ld d, (hl) 
2015 eb				ex de, hl 
2016 d1				pop de 
2017			 
2017 c9				ret 
2018			 
2018			 
2018			 
2018			 
2018			 
2018			; push a number held in HL onto the data stack 
2018			; entry point for pushing a value when already in hl used in function above 
2018			 
2018			forth_push_numhl: 
2018			 
2018 e5				push hl    ; save value to push 
2019			 
2019			if DEBUG_FORTH_PUSH 
2019				; see if disabled 
2019			 
2019			 
2019 f5				push af 
201a 3a aa fd			ld a,(debug_vector) 
201d fe c9			cp $c9   ; ret 
201f			;	ld a, (os_view_disable) 
201f			;	cp '*' 
201f 28 34			jr z, .pskip2 
2021 e5				push hl 
2022 e5			push hl 
2023 cd 9b 0d			call clear_display 
2026 e1			pop hl 
2027 7c				ld a,h 
2028 21 01 f4			ld hl, os_word_scratch 
202b cd e5 11			call hexout 
202e e1				pop hl 
202f 7d				ld a,l 
2030 21 03 f4			ld hl, os_word_scratch+2 
2033 cd e5 11			call hexout 
2036			 
2036 21 05 f4			ld hl, os_word_scratch+4 
2039 3e 00			ld a,0 
203b 77				ld (hl),a 
203c 11 01 f4			ld de,os_word_scratch 
203f 3e 28				ld a, display_row_2 
2041 cd ae 0d				call str_at_display 
2044 11 40 5d			ld de, .push_num 
2047 3e 00			ld a, display_row_1 
2049			 
2049 cd ae 0d				call str_at_display 
204c			 
204c			 
204c cd be 0d			call update_display 
204f cd de 0c			call delay1s 
2052 cd de 0c			call delay1s 
2055			.pskip2:  
2055			 
2055 f1				pop af 
2056			endif	 
2056			 
2056			 
2056				FORTH_DSP_NEXT 
2056 cd a7 1f			call macro_forth_dsp_next 
2059				endm 
# End of macro FORTH_DSP_NEXT
2059			 
2059 2a 29 f9			ld hl, (cli_data_sp) 
205c			 
205c				; save item type 
205c 3e 02			ld a,  DS_TYPE_INUM 
205e 77				ld (hl), a 
205f 23				inc hl 
2060			 
2060				; get word off stack 
2060 d1				pop de 
2061 7b				ld a,e 
2062 77				ld (hl), a 
2063 23				inc hl 
2064 7a				ld a,d 
2065 77				ld (hl), a 
2066			 
2066			if DEBUG_FORTH_PUSH 
2066 2b				dec hl 
2067 2b				dec hl 
2068 2b				dec hl 
2069						DMARK "PH5" 
2069 f5				push af  
206a 3a 7e 20			ld a, (.dmark)  
206d 32 a6 fd			ld (debug_mark),a  
2070 3a 7f 20			ld a, (.dmark+1)  
2073 32 a7 fd			ld (debug_mark+1),a  
2076 3a 80 20			ld a, (.dmark+2)  
2079 32 a8 fd			ld (debug_mark+2),a  
207c 18 03			jr .pastdmark  
207e ..			.dmark: db "PH5"  
2081 f1			.pastdmark: pop af  
2082			endm  
# End of macro DMARK
2082				CALLMONITOR 
2082 cd aa fd			call debug_vector  
2085				endm  
# End of macro CALLMONITOR
2085			endif	 
2085			 
2085 c9				ret 
2086			 
2086			 
2086			; Push a string to stack pointed to by hl 
2086			 
2086			forth_push_str: 
2086			 
2086			if DEBUG_FORTH_PUSH 
2086						DMARK "PSQ" 
2086 f5				push af  
2087 3a 9b 20			ld a, (.dmark)  
208a 32 a6 fd			ld (debug_mark),a  
208d 3a 9c 20			ld a, (.dmark+1)  
2090 32 a7 fd			ld (debug_mark+1),a  
2093 3a 9d 20			ld a, (.dmark+2)  
2096 32 a8 fd			ld (debug_mark+2),a  
2099 18 03			jr .pastdmark  
209b ..			.dmark: db "PSQ"  
209e f1			.pastdmark: pop af  
209f			endm  
# End of macro DMARK
209f				CALLMONITOR 
209f cd aa fd			call debug_vector  
20a2				endm  
# End of macro CALLMONITOR
20a2			endif	 
20a2			    
20a2 e5				push hl 
20a3 e5				push hl 
20a4			 
20a4			;	ld a, 0   ; find end of string 
20a4 cd 42 13			call strlenz 
20a7			if DEBUG_FORTH_PUSH 
20a7						DMARK "PQ2" 
20a7 f5				push af  
20a8 3a bc 20			ld a, (.dmark)  
20ab 32 a6 fd			ld (debug_mark),a  
20ae 3a bd 20			ld a, (.dmark+1)  
20b1 32 a7 fd			ld (debug_mark+1),a  
20b4 3a be 20			ld a, (.dmark+2)  
20b7 32 a8 fd			ld (debug_mark+2),a  
20ba 18 03			jr .pastdmark  
20bc ..			.dmark: db "PQ2"  
20bf f1			.pastdmark: pop af  
20c0			endm  
# End of macro DMARK
20c0				CALLMONITOR 
20c0 cd aa fd			call debug_vector  
20c3				endm  
# End of macro CALLMONITOR
20c3			endif	 
20c3 eb				ex de, hl 
20c4 e1				pop hl   ; get ptr to start of string 
20c5			if DEBUG_FORTH_PUSH 
20c5						DMARK "PQ3" 
20c5 f5				push af  
20c6 3a da 20			ld a, (.dmark)  
20c9 32 a6 fd			ld (debug_mark),a  
20cc 3a db 20			ld a, (.dmark+1)  
20cf 32 a7 fd			ld (debug_mark+1),a  
20d2 3a dc 20			ld a, (.dmark+2)  
20d5 32 a8 fd			ld (debug_mark+2),a  
20d8 18 03			jr .pastdmark  
20da ..			.dmark: db "PQ3"  
20dd f1			.pastdmark: pop af  
20de			endm  
# End of macro DMARK
20de				CALLMONITOR 
20de cd aa fd			call debug_vector  
20e1				endm  
# End of macro CALLMONITOR
20e1			endif	 
20e1 19				add hl,de 
20e2			if DEBUG_FORTH_PUSH 
20e2						DMARK "PQE" 
20e2 f5				push af  
20e3 3a f7 20			ld a, (.dmark)  
20e6 32 a6 fd			ld (debug_mark),a  
20e9 3a f8 20			ld a, (.dmark+1)  
20ec 32 a7 fd			ld (debug_mark+1),a  
20ef 3a f9 20			ld a, (.dmark+2)  
20f2 32 a8 fd			ld (debug_mark+2),a  
20f5 18 03			jr .pastdmark  
20f7 ..			.dmark: db "PQE"  
20fa f1			.pastdmark: pop af  
20fb			endm  
# End of macro DMARK
20fb				CALLMONITOR 
20fb cd aa fd			call debug_vector  
20fe				endm  
# End of macro CALLMONITOR
20fe			endif	 
20fe			 
20fe 2b				dec hl    ; see if there is an optional trailing double quote 
20ff 7e				ld a,(hl) 
2100 fe 22			cp '"' 
2102 20 03			jr nz, .strnoq 
2104 3e 00			ld a, 0      ; get rid of double quote 
2106 77				ld (hl), a 
2107 23			.strnoq: inc hl 
2108			 
2108 3e 00			ld a, 0 
210a 77				ld (hl), a     ; add null term and get rid of trailing double quote 
210b			 
210b 13				inc de ; add one for the type string 
210c 13				inc de ; add one for null term??? 
210d			 
210d				; tos is get string pointer again 
210d				; de contains space to allocate 
210d				 
210d d5				push de 
210e			 
210e eb				ex de, hl 
210f			 
210f				;push af 
210f			 
210f			if DEBUG_FORTH_PUSH 
210f						DMARK "PHm" 
210f f5				push af  
2110 3a 24 21			ld a, (.dmark)  
2113 32 a6 fd			ld (debug_mark),a  
2116 3a 25 21			ld a, (.dmark+1)  
2119 32 a7 fd			ld (debug_mark+1),a  
211c 3a 26 21			ld a, (.dmark+2)  
211f 32 a8 fd			ld (debug_mark+2),a  
2122 18 03			jr .pastdmark  
2124 ..			.dmark: db "PHm"  
2127 f1			.pastdmark: pop af  
2128			endm  
# End of macro DMARK
2128				CALLMONITOR 
2128 cd aa fd			call debug_vector  
212b				endm  
# End of macro CALLMONITOR
212b			endif	 
212b cd b7 13			call malloc	; on ret hl now contains allocated memory 
212e				if DEBUG_FORTH_MALLOC_GUARD 
212e cc 98 5d				call z,malloc_error 
2131				endif 
2131			 
2131				 
2131 c1				pop bc    ; get length 
2132 d1				pop de   ;  get string start    
2133			 
2133				; hl has destination from malloc 
2133			 
2133 eb				ex de, hl    ; prep for ldir 
2134			 
2134 d5				push de   ; save malloc area for DSP later 
2135				;push hl   ; save malloc area for DSP later 
2135			 
2135			if DEBUG_FORTH_PUSH 
2135						DMARK "PHc" 
2135 f5				push af  
2136 3a 4a 21			ld a, (.dmark)  
2139 32 a6 fd			ld (debug_mark),a  
213c 3a 4b 21			ld a, (.dmark+1)  
213f 32 a7 fd			ld (debug_mark+1),a  
2142 3a 4c 21			ld a, (.dmark+2)  
2145 32 a8 fd			ld (debug_mark+2),a  
2148 18 03			jr .pastdmark  
214a ..			.dmark: db "PHc"  
214d f1			.pastdmark: pop af  
214e			endm  
# End of macro DMARK
214e				CALLMONITOR 
214e cd aa fd			call debug_vector  
2151				endm  
# End of macro CALLMONITOR
2151			endif	 
2151			 
2151			 
2151 ed b0			ldir 
2153			 
2153			 
2153				; push malloc to data stack     macro?????  
2153			 
2153				FORTH_DSP_NEXT 
2153 cd a7 1f			call macro_forth_dsp_next 
2156				endm 
# End of macro FORTH_DSP_NEXT
2156			 
2156				; save value and type 
2156			 
2156 2a 29 f9			ld hl, (cli_data_sp) 
2159			 
2159				; save item type 
2159 3e 01			ld a,  DS_TYPE_STR 
215b 77				ld (hl), a 
215c 23				inc hl 
215d			 
215d				; get malloc word off stack 
215d d1				pop de 
215e 73				ld (hl), e 
215f 23				inc hl 
2160 72				ld (hl), d 
2161			 
2161			 
2161			 
2161			if DEBUG_FORTH_PUSH 
2161 2a 29 f9			ld hl, (cli_data_sp) 
2164						DMARK "PHS" 
2164 f5				push af  
2165 3a 79 21			ld a, (.dmark)  
2168 32 a6 fd			ld (debug_mark),a  
216b 3a 7a 21			ld a, (.dmark+1)  
216e 32 a7 fd			ld (debug_mark+1),a  
2171 3a 7b 21			ld a, (.dmark+2)  
2174 32 a8 fd			ld (debug_mark+2),a  
2177 18 03			jr .pastdmark  
2179 ..			.dmark: db "PHS"  
217c f1			.pastdmark: pop af  
217d			endm  
# End of macro DMARK
217d				CALLMONITOR 
217d cd aa fd			call debug_vector  
2180				endm  
# End of macro CALLMONITOR
2180			;	ex de,hl 
2180			endif	 
2180				; in case of spaces, skip the ptr past the copied string 
2180				;pop af 
2180				;ld (cli_origptr),hl 
2180			 
2180 c9				ret 
2181			 
2181			 
2181			 
2181			; TODO ascii push input onto stack given hl to start of input 
2181			 
2181			; identify type 
2181			; if starts with a " then a string 
2181			; otherwise it is a number 
2181			;  
2181			; if a string 
2181			;     scan for ending " to get length of string to malloc for + 1 
2181			;     malloc 
2181			;     put pointer to string on stack first byte flags as string 
2181			; 
2181			; else a number 
2181			;    look for number format identifier 
2181			;    $xx hex 
2181			;    %xxxxx bin 
2181			;    xxxxx decimal 
2181			;    convert number to 16bit word.  
2181			;    malloc word + 1 with flag to identiy as num 
2181			;    put pointer to number on stack 
2181			;   
2181			;  
2181			  
2181			forth_apush: 
2181				; kernel push 
2181			 
2181			if DEBUG_FORTH_PUSH 
2181						DMARK "PSH" 
2181 f5				push af  
2182 3a 96 21			ld a, (.dmark)  
2185 32 a6 fd			ld (debug_mark),a  
2188 3a 97 21			ld a, (.dmark+1)  
218b 32 a7 fd			ld (debug_mark+1),a  
218e 3a 98 21			ld a, (.dmark+2)  
2191 32 a8 fd			ld (debug_mark+2),a  
2194 18 03			jr .pastdmark  
2196 ..			.dmark: db "PSH"  
2199 f1			.pastdmark: pop af  
219a			endm  
# End of macro DMARK
219a				CALLMONITOR 
219a cd aa fd			call debug_vector  
219d				endm  
# End of macro CALLMONITOR
219d			endif	 
219d				; identify input type 
219d			 
219d 7e				ld a,(hl) 
219e fe 22			cp '"' 
21a0 28 0a			jr z, .fapstr 
21a2 fe 24			cp '$' 
21a4 ca cc 21			jp z, .faphex 
21a7 fe 25			cp '%' 
21a9 ca b4 21			jp z, .fapbin 
21ac			;	cp 'b' 
21ac			;	jp z, .fabin 
21ac				; else decimal 
21ac			 
21ac				; TODO do decimal conversion 
21ac				; decimal is stored as a 16bit word 
21ac			 
21ac				; by default everything is a string if type is not detected 
21ac			.fapstr: ; 
21ac fe 22			cp '"' 
21ae 20 01			jr nz, .strnoqu 
21b0 23				inc hl 
21b1			.strnoqu: 
21b1 c3 86 20			jp forth_push_str 
21b4			 
21b4			 
21b4			 
21b4			.fapbin:    ; push a binary string.  
21b4 11 00 00			ld de, 0   ; hold a 16bit value 
21b7			 
21b7 23			.fapbinshift:	inc hl  
21b8 7e				ld a,(hl) 
21b9 fe 00			cp 0     ; done scanning  
21bb 28 0b			jr z, .fapbdone  	; got it in HL so push  
21bd			 
21bd				; left shift de 
21bd eb				ex de, hl	 
21be 29				add hl, hl 
21bf			 
21bf				; is 1 
21bf fe 31			cp '1' 
21c1 20 02			jr nz, .binzero 
21c3 cb 4d			bit 1, l 
21c5			.binzero: 
21c5 eb				ex de, hl	 ; save current de 
21c6 18 ef			jr .fapbinshift 
21c8			 
21c8			.fapbdone: 
21c8 eb				ex de, hl 
21c9 c3 18 20			jp forth_push_numhl 
21cc			 
21cc			 
21cc			.faphex:   ; hex is always stored as a 16bit word 
21cc				; skip number prefix 
21cc 23				inc hl 
21cd				; turn ascii into number 
21cd cd 9b 12			call get_word_hl	; ret 16bit word in hl 
21d0			 
21d0 c3 18 20			jp forth_push_numhl 
21d3			 
21d3 00				 nop 
21d4			 
21d4			.fabin:   ; TODO bin conversion 
21d4			 
21d4			 
21d4 c9				ret 
21d5			 
21d5			 
21d5			; get either a string ptr or a 16bit word from the data stack 
21d5			 
21d5			FORTH_DSP: macro 
21d5				call macro_forth_dsp 
21d5				endm 
21d5			 
21d5			macro_forth_dsp: 
21d5				; data stack pointer points to current word on tos 
21d5			 
21d5 2a 29 f9			ld hl,(cli_data_sp) 
21d8			 
21d8				if DEBUG_FORTH_PUSH 
21d8						DMARK "DSP" 
21d8 f5				push af  
21d9 3a ed 21			ld a, (.dmark)  
21dc 32 a6 fd			ld (debug_mark),a  
21df 3a ee 21			ld a, (.dmark+1)  
21e2 32 a7 fd			ld (debug_mark+1),a  
21e5 3a ef 21			ld a, (.dmark+2)  
21e8 32 a8 fd			ld (debug_mark+2),a  
21eb 18 03			jr .pastdmark  
21ed ..			.dmark: db "DSP"  
21f0 f1			.pastdmark: pop af  
21f1			endm  
# End of macro DMARK
21f1			 
21f1 cd cb 5d				call display_data_sp 
21f4				;call break_point_state 
21f4				;rst 030h 
21f4				CALLMONITOR 
21f4 cd aa fd			call debug_vector  
21f7				endm  
# End of macro CALLMONITOR
21f7				endif 
21f7			 
21f7 c9				ret 
21f8			 
21f8			; return hl to start of value on stack 
21f8			 
21f8			FORTH_DSP_VALUE: macro 
21f8				call macro_forth_dsp_value 
21f8				endm 
21f8			 
21f8			macro_forth_dsp_value: 
21f8			 
21f8				FORTH_DSP 
21f8 cd d5 21			call macro_forth_dsp 
21fb				endm 
# End of macro FORTH_DSP
21fb			 
21fb d5				push de 
21fc			 
21fc 23				inc hl ; skip type 
21fd			 
21fd 5e				ld e, (hl) 
21fe 23				inc hl 
21ff 56				ld d, (hl) 
2200 eb				ex de,hl  
2201			 
2201 d1				pop de 
2202			 
2202 c9				ret 
2203			 
2203			; return hl to start of value to second item on stack 
2203			 
2203			FORTH_DSP_VALUEM1: macro 
2203				call macro_forth_dsp_value_m1 
2203				endm 
2203			 
2203			macro_forth_dsp_value_m1: 
2203			 
2203				FORTH_DSP 
2203 cd d5 21			call macro_forth_dsp 
2206				endm 
# End of macro FORTH_DSP
2206			 
2206 2b				dec hl 
2207 2b				dec hl 
2208			;	dec hl 
2208			 
2208 d5				push de 
2209			 
2209 5e				ld e, (hl) 
220a 23				inc hl 
220b 56				ld d, (hl) 
220c eb				ex de,hl  
220d			 
220d d1				pop de 
220e			 
220e c9				ret 
220f			 
220f				 
220f			 
220f			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
220f			 
220f			FORTH_DSP_POP: macro 
220f				call macro_forth_dsp_pop 
220f				endm 
220f			 
220f			 
220f			; get the tos data type 
220f			 
220f			FORTH_DSP_TYPE:   macro 
220f			 
220f				;FORTH_DSP_VALUE 
220f				FORTH_DSP 
220f				 
220f				; hl points to value 
220f				; check type 
220f			 
220f				ld a,(hl) 
220f			 
220f				endm 
220f			 
220f			; load the tos value into hl 
220f			 
220f			 
220f			FORTH_DSP_VALUEHL:  macro 
220f				call macro_dsp_valuehl 
220f				endm 
220f			 
220f			 
220f			 
220f			macro_dsp_valuehl: 
220f				FORTH_DSP_VALUE 
220f cd f8 21			call macro_forth_dsp_value 
2212				endm 
# End of macro FORTH_DSP_VALUE
2212			 
2212				;FORTH_ERR_TOS_NOTNUM 
2212			 
2212				;inc hl   ; skip type id 
2212			 
2212			;	push de 
2212			; 
2212			;	ld e, (hl) 
2212			;	inc hl 
2212			;	ld d, (hl) 
2212			;	ex de,hl  
2212			 
2212			;	pop de 
2212			 
2212				if DEBUG_FORTH_PUSH 
2212						DMARK "DVL" 
2212 f5				push af  
2213 3a 27 22			ld a, (.dmark)  
2216 32 a6 fd			ld (debug_mark),a  
2219 3a 28 22			ld a, (.dmark+1)  
221c 32 a7 fd			ld (debug_mark+1),a  
221f 3a 29 22			ld a, (.dmark+2)  
2222 32 a8 fd			ld (debug_mark+2),a  
2225 18 03			jr .pastdmark  
2227 ..			.dmark: db "DVL"  
222a f1			.pastdmark: pop af  
222b			endm  
# End of macro DMARK
222b				CALLMONITOR 
222b cd aa fd			call debug_vector  
222e				endm  
# End of macro CALLMONITOR
222e				endif 
222e c9				ret 
222f			 
222f			forth_apushstrhl:      
222f				; push of string requires use of cli_origptr 
222f				; bodge use 
222f			 
222f				; get current cli_origptr, save, update with temp pointer  
222f ed 5b 79 f9		ld de, (cli_origptr) 
2233 22 79 f9			ld (cli_origptr), hl 
2236 d5				push de 
2237 cd 81 21			call forth_apush 
223a d1				pop de 
223b ed 53 79 f9		ld (cli_origptr), de 
223f c9			        ret	 
2240			 
2240			 
2240			; increase loop stack pointer and save hl to it 
2240				 
2240			FORTH_LOOP_NEXT: macro 
2240				call macro_forth_loop_next 
2240				;nop 
2240				endm 
2240			 
2240			macro_forth_loop_next: 
2240				if DEBUG_FORTH_STACK_GUARD 
2240 cd 2e 72				call check_stacks 
2243				endif 
2243 e5				push hl 
2244 d5				push de 
2245 eb				ex de,hl 
2246 2a 2b f9			ld hl,(cli_loop_sp) 
2249 23				inc hl 
224a 23				inc hl 
224b					if DEBUG_FORTH_WORDS 
224b						DMARK "LNX" 
224b f5				push af  
224c 3a 60 22			ld a, (.dmark)  
224f 32 a6 fd			ld (debug_mark),a  
2252 3a 61 22			ld a, (.dmark+1)  
2255 32 a7 fd			ld (debug_mark+1),a  
2258 3a 62 22			ld a, (.dmark+2)  
225b 32 a8 fd			ld (debug_mark+2),a  
225e 18 03			jr .pastdmark  
2260 ..			.dmark: db "LNX"  
2263 f1			.pastdmark: pop af  
2264			endm  
# End of macro DMARK
2264						CALLMONITOR 
2264 cd aa fd			call debug_vector  
2267				endm  
# End of macro CALLMONITOR
2267					endif 
2267 22 2b f9			ld (cli_loop_sp),hl 
226a 73				ld (hl), e 
226b 23				inc hl 
226c 72				ld (hl), d 
226d d1				pop de    ; been reversed so save a swap on restore 
226e e1				pop hl 
226f				if DEBUG_FORTH_STACK_GUARD 
226f cd 2e 72				call check_stacks 
2272				endif 
2272 c9				ret 
2273			 
2273			; get current ret stack pointer and save to hl  
2273				 
2273			FORTH_LOOP_TOS: macro 
2273				call macro_forth_loop_tos 
2273				endm 
2273			 
2273			macro_forth_loop_tos: 
2273 d5				push de 
2274 2a 2b f9			ld hl,(cli_loop_sp) 
2277 5e				ld e, (hl) 
2278 23				inc hl 
2279 56				ld d, (hl) 
227a eb				ex de, hl 
227b d1				pop de 
227c c9				ret 
227d			 
227d			; pop loop stack pointer 
227d				 
227d			FORTH_LOOP_POP: macro 
227d				call macro_forth_loop_pop 
227d				endm 
227d			 
227d			 
227d			macro_forth_loop_pop: 
227d				if DEBUG_FORTH_STACK_GUARD 
227d					DMARK "LPP" 
227d f5				push af  
227e 3a 92 22			ld a, (.dmark)  
2281 32 a6 fd			ld (debug_mark),a  
2284 3a 93 22			ld a, (.dmark+1)  
2287 32 a7 fd			ld (debug_mark+1),a  
228a 3a 94 22			ld a, (.dmark+2)  
228d 32 a8 fd			ld (debug_mark+2),a  
2290 18 03			jr .pastdmark  
2292 ..			.dmark: db "LPP"  
2295 f1			.pastdmark: pop af  
2296			endm  
# End of macro DMARK
2296 cd 2e 72				call check_stacks 
2299					FORTH_CHK_LOOP_UNDER 
2299 e5				push hl 
229a d5				push de 
229b 2a 2b f9			ld hl,(cli_loop_sp) 
229e 11 65 f8			ld de, cli_loop_stack 
22a1 cd ed 0f			call cmp16 
22a4 da 48 73			jp c, fault_loop_under 
22a7 d1				pop de 
22a8 e1				pop hl 
22a9				endm 
# End of macro FORTH_CHK_LOOP_UNDER
22a9				endif 
22a9 e5				push hl 
22aa 2a 2b f9			ld hl,(cli_loop_sp) 
22ad 2b				dec hl 
22ae 2b				dec hl 
22af 22 2b f9			ld (cli_loop_sp), hl 
22b2				; TODO do stack underflow checks 
22b2 e1				pop hl 
22b3				if DEBUG_FORTH_STACK_GUARD 
22b3 cd 2e 72				call check_stacks 
22b6					FORTH_CHK_LOOP_UNDER 
22b6 e5				push hl 
22b7 d5				push de 
22b8 2a 2b f9			ld hl,(cli_loop_sp) 
22bb 11 65 f8			ld de, cli_loop_stack 
22be cd ed 0f			call cmp16 
22c1 da 48 73			jp c, fault_loop_under 
22c4 d1				pop de 
22c5 e1				pop hl 
22c6				endm 
# End of macro FORTH_CHK_LOOP_UNDER
22c6				endif 
22c6 c9				ret 
22c7			 
22c7			macro_forth_dsp_pop: 
22c7			 
22c7 e5				push hl 
22c8			 
22c8				; release malloc data 
22c8			 
22c8				if DEBUG_FORTH_STACK_GUARD 
22c8 cd 2e 72				call check_stacks 
22cb					FORTH_CHK_DSP_UNDER 
22cb e5				push hl 
22cc d5				push de 
22cd 2a 29 f9			ld hl,(cli_data_sp) 
22d0 11 63 f6			ld de, cli_data_stack 
22d3 cd ed 0f			call cmp16 
22d6 da 3c 73			jp c, fault_dsp_under 
22d9 d1				pop de 
22da e1				pop hl 
22db				endm 
# End of macro FORTH_CHK_DSP_UNDER
22db				endif 
22db				;ld hl,(cli_data_sp) 
22db			if DEBUG_FORTH_DOT 
22db				DMARK "DPP" 
22db f5				push af  
22dc 3a f0 22			ld a, (.dmark)  
22df 32 a6 fd			ld (debug_mark),a  
22e2 3a f1 22			ld a, (.dmark+1)  
22e5 32 a7 fd			ld (debug_mark+1),a  
22e8 3a f2 22			ld a, (.dmark+2)  
22eb 32 a8 fd			ld (debug_mark+2),a  
22ee 18 03			jr .pastdmark  
22f0 ..			.dmark: db "DPP"  
22f3 f1			.pastdmark: pop af  
22f4			endm  
# End of macro DMARK
22f4				CALLMONITOR 
22f4 cd aa fd			call debug_vector  
22f7				endm  
# End of macro CALLMONITOR
22f7			endif	 
22f7			 
22f7			 
22f7			if FORTH_ENABLE_DSPPOPFREE 
22f7			 
22f7				FORTH_DSP 
22f7 cd d5 21			call macro_forth_dsp 
22fa				endm 
# End of macro FORTH_DSP
22fa			 
22fa 7e				ld a, (hl) 
22fb fe 01			cp DS_TYPE_STR 
22fd 20 23			jr nz, .skippopfree 
22ff			 
22ff				FORTH_DSP_VALUEHL 
22ff cd 0f 22			call macro_dsp_valuehl 
2302				endm 
# End of macro FORTH_DSP_VALUEHL
2302 00				nop 
2303			if DEBUG_FORTH_DOT 
2303				DMARK "DPf" 
2303 f5				push af  
2304 3a 18 23			ld a, (.dmark)  
2307 32 a6 fd			ld (debug_mark),a  
230a 3a 19 23			ld a, (.dmark+1)  
230d 32 a7 fd			ld (debug_mark+1),a  
2310 3a 1a 23			ld a, (.dmark+2)  
2313 32 a8 fd			ld (debug_mark+2),a  
2316 18 03			jr .pastdmark  
2318 ..			.dmark: db "DPf"  
231b f1			.pastdmark: pop af  
231c			endm  
# End of macro DMARK
231c				CALLMONITOR 
231c cd aa fd			call debug_vector  
231f				endm  
# End of macro CALLMONITOR
231f			endif	 
231f cd 81 14			call free 
2322			.skippopfree: 
2322				 
2322			 
2322			endif 
2322			 
2322			if DEBUG_FORTH_DOT_KEY 
2322				DMARK "DP2" 
2322				CALLMONITOR 
2322			endif	 
2322			 
2322				; move pointer down 
2322			 
2322 2a 29 f9			ld hl,(cli_data_sp) 
2325 2b				dec hl 
2326 2b				dec hl 
2327			; PARSEV5 
2327 2b				dec hl 
2328 22 29 f9			ld (cli_data_sp), hl 
232b			 
232b				if DEBUG_FORTH_STACK_GUARD 
232b cd 2e 72				call check_stacks 
232e					FORTH_CHK_DSP_UNDER 
232e e5				push hl 
232f d5				push de 
2330 2a 29 f9			ld hl,(cli_data_sp) 
2333 11 63 f6			ld de, cli_data_stack 
2336 cd ed 0f			call cmp16 
2339 da 3c 73			jp c, fault_dsp_under 
233c d1				pop de 
233d e1				pop hl 
233e				endm 
# End of macro FORTH_CHK_DSP_UNDER
233e				endif 
233e			 
233e e1				pop hl 
233f			 
233f c9				ret 
2340			 
2340			getwordathl: 
2340				; hl points to an address 
2340				; load hl with the word at that address 
2340			 
2340 d5				push de 
2341			 
2341 5e				ld e, (hl) 
2342 23				inc hl 
2343 56				ld d, (hl) 
2344 eb				ex de, hl 
2345			 
2345 d1				pop de 
2346 c9				ret 
2347			 
2347			 
2347			 
2347			 
2347			 
2347			; eof 
2347			 
# End of file forth_stackopsv5.asm
2347			endif 
2347			 
2347			loadwordinhl:	 
2347			 
2347 d5				push de 
2348			 
2348 5e				ld e, (hl) 
2349 23				inc hl 
234a 56				ld d, (hl) 
234b eb				ex de,hl  
234c			 
234c d1				pop de 
234d			 
234d c9				ret 
234e			 
234e			user_word_eol:  
234e				; hl contains the pointer to where to create a linked list item from the end 
234e				; of the user dict to continue on at the system word dict 
234e				 
234e				; poke the stub of the word list linked list to repoint to rom words 
234e			 
234e				; stub format 
234e				; db   word id 
234e				; dw    link to next word 
234e			        ; db char length of token 
234e				; db string + 0 term 
234e				; db exec code....  
234e			 
234e 3e 00			ld a, WORD_SYS_ROOT     ; root word 
2350 77				ld (hl), a		; word id 
2351 23				inc hl 
2352			 
2352 11 1d 25			ld de, sysdict 
2355 73				ld (hl), e		; next word link ie system dict 
2356 23				inc hl 
2357 72				ld (hl), d		; next word link ie system dict 
2358 23				inc hl	 
2359			 
2359			;	ld (hl), sysdict		; next word link ie system dict 
2359			;	inc hl 
2359			;	inc hl 
2359			 
2359			;	inc hl 
2359			;	inc hl 
2359			 
2359 3e 02			ld a, 2			; word length is 0 
235b 77				ld (hl), a	 
235c 23				inc hl 
235d			 
235d 3e 7e			ld a, '~'			; word length is 0 
235f 77				ld (hl), a	 
2360 23				inc hl 
2361 3e 00			ld a, 0			; save empty word 
2363 77				ld (hl), a 
2364			 
2364 c9				ret 
2365			 
2365				 
2365			 
2365			forthexec_cleanup: 
2365				FORTH_RSP_POP 
2365 cd e0 1f			call macro_forth_rsp_pop 
2368				endm 
# End of macro FORTH_RSP_POP
2368 c9				ret 
2369			 
2369			forth_call_hl: 
2369				; taking hl 
2369 e5				push hl 
236a c9				ret 
236b			 
236b			; this is called to reset Forth system but keep existing uwords etc 
236b			 
236b			forth_warmstart: 
236b				; setup stack over/under flow checks 
236b				if DEBUG_FORTH_STACK_GUARD 
236b cd 14 72				call chk_stk_init 
236e				endif 
236e			 
236e				; init stack pointers  - * these stacks go upwards *  
236e 21 e7 f8			ld hl, cli_ret_stack 
2371 22 2d f9			ld (cli_ret_sp), hl	 
2374				; set bottom of stack 
2374 3e 00			ld a,0 
2376 77				ld (hl),a 
2377 23				inc hl 
2378 77				ld (hl),a 
2379			 
2379 21 63 f6			ld hl, cli_data_stack 
237c 22 29 f9			ld (cli_data_sp), hl	 
237f				; set bottom of stack 
237f 3e 00			ld a,0 
2381 77				ld (hl),a 
2382 23				inc hl 
2383 77				ld (hl),a 
2384			 
2384 21 65 f8			ld hl, cli_loop_stack 
2387 22 2b f9			ld (cli_loop_sp), hl	 
238a				; set bottom of stack 
238a 3e 00			ld a,0 
238c 77				ld (hl),a 
238d 23				inc hl 
238e 77				ld (hl),a 
238f			 
238f				; init extent of current open file 
238f			 
238f 3e 00			ld a, 0 
2391 32 a5 f9			ld (store_openext), a 
2394			 
2394 c9				ret 
2395			 
2395			 
2395			 
2395			; Cold Start - this is called to setup the whole Forth system 
2395			 
2395			forth_init: 
2395			 
2395				; setup stack over/under flow checks 
2395			 
2395			;	if DEBUG_FORTH_STACK_GUARD 
2395			;		call chk_stk_init 
2395			;	endif 
2395			 
2395				; enable auto display updates (slow.....) 
2395			 
2395 3e 01			ld a, 1 
2397 32 77 f9			ld (cli_autodisplay), a 
239a			 
239a				; if storage is in use disable long reads for now 
239a 3e 00			ld a, 0 
239c 32 b0 f9			ld (store_longread), a 
239f			 
239f			 
239f				; show start up screen 
239f			 
239f cd 9b 0d			call clear_display 
23a2			 
23a2 3e 00			ld a,0 
23a4 32 99 f9			ld (f_cursor_ptr), a 
23a7			 
23a7				; set start of word list in start of ram - for use when creating user words 
23a7			 
23a7 21 00 80			ld hl, baseram 
23aa 22 f9 f3			ld (os_last_new_uword), hl 
23ad cd 4e 23			call user_word_eol 
23b0				 
23b0			;		call display_data_sp 
23b0			;		call next_page_prompt 
23b0			 
23b0			 
23b0			 
23b0			 
23b0 c9				ret 
23b1			 
23b1 .. 00		.bootforth: db " Forth Kernel Init ",0 
23c5			 
23c5			; TODO push to stack 
23c5			 
23c5			;  
23c5			 
23c5			if FORTH_PARSEV2 
23c5			 
23c5			 
23c5				include "forth_parserv2.asm" 
23c5			 
23c5			endif 
23c5			 
23c5			 
23c5			; parse cli version 1 
23c5			 
23c5			if FORTH_PARSEV1 
23c5			 
23c5			 
23c5			 
23c5			      include "forth_parserv1.asm" 
23c5			endif 
23c5				 
23c5			if FORTH_PARSEV3 
23c5			 
23c5			 
23c5			 
23c5			      include "forth_parserv3.asm" 
23c5				include "forth_wordsv3.asm" 
23c5			endif 
23c5			 
23c5			if FORTH_PARSEV4 
23c5			 
23c5			 
23c5			 
23c5			      include "forth_parserv4.asm" 
23c5				include "forth_wordsv4.asm" 
23c5			endif 
23c5			 
23c5			if FORTH_PARSEV5 
23c5			 
23c5			 
23c5			 
23c5			      include "forth_parserv5.asm" 
23c5			 
23c5			 
23c5			; A better parser without using malloc and string copies all over the place.  
23c5			; Exec in situ should be faster 
23c5			 
23c5			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
23c5			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
23c5			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
23c5			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
23c5			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
23c5			WORD_SYS_END: equ 0   ; Opcode for all user words 
23c5			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
23c5			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
23c5			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
23c5			 
23c5			; Core word preamble macro 
23c5			 
23c5			CWHEAD:   macro nxtword opcode lit len opflags 
23c5				db WORD_SYS_CORE+opcode             
23c5				; internal op code number 
23c5				dw nxtword            
23c5				; link to next dict word block 
23c5				db len + 1 
23c5				; literal length of dict word inc zero term 
23c5				db lit,0              
23c5				; literal dict word 
23c5			        ; TODO db opflags        
23c5				endm 
23c5			 
23c5			 
23c5			NEXTW: macro  
23c5				jp macro_next 
23c5				endm 
23c5			 
23c5			macro_next: 
23c5			if DEBUG_FORTH_PARSE_KEY 
23c5				DMARK "NXT" 
23c5				CALLMONITOR 
23c5			endif	 
23c5			;	inc hl  ; skip token null term  
23c5 ed 4b 7b f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
23c9 ed 5b 79 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
23cd 2a fd f3			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
23d0			if DEBUG_FORTH_PARSE_KEY 
23d0				DMARK "}AA" 
23d0				CALLMONITOR 
23d0			endif	 
23d0 c3 d3 24			jp execnext 
23d3				;jp exec1 
23d3			       
23d3			 
23d3			 
23d3			; Another go at the parser to compile  
23d3			 
23d3			 
23d3			; TODO rework parser to change all of the string words to byte tokens 
23d3			; TODO do a search for  
23d3			 
23d3			; TODO first run normal parser to zero term sections 
23d3			; TODO for each word do a token look up to get the op code 
23d3			; TODO need some means to flag to the exec that this is a byte code form    
23d3			 
23d3			 
23d3			forthcompile: 
23d3			 
23d3			; 
23d3			; line parse: 
23d3			;       parse raw input buffer 
23d3			;       tokenise the words 
23d3			;       malloc new copy (for looping etc) 
23d3			;       copy to malloc + current pc in line to start of string and add line term 
23d3			;       save on new rsp 
23d3			; 
23d3			 
23d3			; hl to point to the line to tokenise 
23d3			 
23d3			;	push hl 
23d3 22 fd f3			ld (os_tok_ptr), hl  ; save ptr to string 
23d6			 
23d6			;	ld a,0		; string term on input 
23d6			;	call strlent 
23d6			 
23d6			;	ld (os_tok_len), hl	 ; save string length 
23d6			 
23d6			;if DEBUG_FORTH_TOK 
23d6			;	ex de,hl		 
23d6			;endif 
23d6			 
23d6			;	pop hl 		; get back string pointer 
23d6			 
23d6			if DEBUG_FORTH_TOK 
23d6						DMARK "TOc" 
23d6				CALLMONITOR 
23d6			endif 
23d6 7e			.cptoken2:    ld a,(hl) 
23d7 23				inc hl 
23d8 fe 7f			cp FORTH_END_BUFFER 
23da 28 29			jr z, .cptokendone2 
23dc fe 00			cp 0 
23de 28 25			jr z, .cptokendone2 
23e0 fe 22			cp '"' 
23e2 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
23e4 fe 20			cp ' ' 
23e6 20 ee			jr nz,  .cptoken2 
23e8			 
23e8			; TODO consume comments held between ( and ) 
23e8			 
23e8				; we have a space so change to zero term for dict match later 
23e8 2b				dec hl 
23e9 3e 00			ld a,0 
23eb 77				ld (hl), a 
23ec 23				inc hl 
23ed 18 e7			jr .cptoken2 
23ef				 
23ef			 
23ef			.cptokenstr2: 
23ef				; skip all white space until either eol (because forgot to term) or end double quote 
23ef			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
23ef				;inc hl ; skip current double quote 
23ef 7e				ld a,(hl) 
23f0 23				inc hl 
23f1 fe 22			cp '"' 
23f3 28 e1			jr z, .cptoken2 
23f5 fe 7f			cp FORTH_END_BUFFER 
23f7 28 0c			jr z, .cptokendone2 
23f9 fe 00			cp 0 
23fb 28 08			jr z, .cptokendone2 
23fd fe 20			cp ' ' 
23ff 28 02			jr z, .cptmp2 
2401 18 ec			jr .cptokenstr2 
2403			 
2403			.cptmp2:	; we have a space so change to zero term for dict match later 
2403				;dec hl 
2403				;ld a,"-"	; TODO remove this when working 
2403				;ld (hl), a 
2403				;inc hl 
2403 18 ea			jr .cptokenstr2 
2405			 
2405			.cptokendone2: 
2405				;inc hl 
2405 3e 7f			ld a, FORTH_END_BUFFER 
2407 77				ld (hl),a 
2408 23				inc hl 
2409 3e 21			ld a, '!' 
240b 77				ld (hl),a 
240c			 
240c 2a fd f3			ld hl,(os_tok_ptr) 
240f			         
240f			if DEBUG_FORTH_TOK 
240f						DMARK "Tc1" 
240f				CALLMONITOR 
240f			endif 
240f			 
240f				; push exec string to top of return stack 
240f				FORTH_RSP_NEXT 
240f cd bf 1f			call macro_forth_rsp_next 
2412				endm 
# End of macro FORTH_RSP_NEXT
2412 c9				ret 
2413			 
2413			; Another go at the parser need to simplify the process 
2413			 
2413			forthparse: 
2413			 
2413			; 
2413			; line parse: 
2413			;       parse raw input buffer 
2413			;       tokenise the words 
2413			;       malloc new copy (for looping etc) 
2413			;       copy to malloc + current pc in line to start of string and add line term 
2413			;       save on new rsp 
2413			; 
2413			 
2413			; hl to point to the line to tokenise 
2413			 
2413			;	push hl 
2413 22 fd f3			ld (os_tok_ptr), hl  ; save ptr to string 
2416			 
2416			;	ld a,0		; string term on input 
2416			;	call strlent 
2416			 
2416			;	ld (os_tok_len), hl	 ; save string length 
2416			 
2416			;if DEBUG_FORTH_TOK 
2416			;	ex de,hl		 
2416			;endif 
2416			 
2416			;	pop hl 		; get back string pointer 
2416			 
2416			if DEBUG_FORTH_TOK 
2416						DMARK "TOK" 
2416				CALLMONITOR 
2416			endif 
2416 7e			.ptoken2:    ld a,(hl) 
2417 23				inc hl 
2418 fe 7f			cp FORTH_END_BUFFER 
241a 28 29			jr z, .ptokendone2 
241c fe 00			cp 0 
241e 28 25			jr z, .ptokendone2 
2420 fe 22			cp '"' 
2422 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2424 fe 20			cp ' ' 
2426 20 ee			jr nz,  .ptoken2 
2428			 
2428			; TODO consume comments held between ( and ) 
2428			 
2428				; we have a space so change to zero term for dict match later 
2428 2b				dec hl 
2429 3e 00			ld a,0 
242b 77				ld (hl), a 
242c 23				inc hl 
242d 18 e7			jr .ptoken2 
242f				 
242f			 
242f			.ptokenstr2: 
242f				; skip all white space until either eol (because forgot to term) or end double quote 
242f			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
242f				;inc hl ; skip current double quote 
242f 7e				ld a,(hl) 
2430 23				inc hl 
2431 fe 22			cp '"' 
2433 28 e1			jr z, .ptoken2 
2435 fe 7f			cp FORTH_END_BUFFER 
2437 28 0c			jr z, .ptokendone2 
2439 fe 00			cp 0 
243b 28 08			jr z, .ptokendone2 
243d fe 20			cp ' ' 
243f 28 02			jr z, .ptmp2 
2441 18 ec			jr .ptokenstr2 
2443			 
2443			.ptmp2:	; we have a space so change to zero term for dict match later 
2443				;dec hl 
2443				;ld a,"-"	; TODO remove this when working 
2443				;ld (hl), a 
2443				;inc hl 
2443 18 ea			jr .ptokenstr2 
2445			 
2445			.ptokendone2: 
2445				;inc hl 
2445 3e 7f			ld a, FORTH_END_BUFFER 
2447 77				ld (hl),a 
2448 23				inc hl 
2449 3e 21			ld a, '!' 
244b 77				ld (hl),a 
244c			 
244c 2a fd f3			ld hl,(os_tok_ptr) 
244f			         
244f			if DEBUG_FORTH_TOK 
244f						DMARK "TK1" 
244f				CALLMONITOR 
244f			endif 
244f			 
244f				; push exec string to top of return stack 
244f				FORTH_RSP_NEXT 
244f cd bf 1f			call macro_forth_rsp_next 
2452				endm 
# End of macro FORTH_RSP_NEXT
2452 c9				ret 
2453			 
2453			; 
2453			;	; malloc size + buffer pointer + if is loop flag 
2453			;	ld hl,(os_tok_len) 		 ; get string length 
2453			; 
2453			;	ld a,l 
2453			; 
2453			;	cp 0			; we dont want to use a null string 
2453			;	ret z 
2453			; 
2453			;;	add 3    ; prefix malloc with buffer for current word ptr 
2453			; 
2453			;	add 5     ; TODO when certain not over writing memory remove 
2453			; 
2453			;		 
2453			; 
2453			;if DEBUG_FORTH_TOK 
2453			;			DMARK "TKE" 
2453			;	CALLMONITOR 
2453			;endif 
2453			; 
2453			;	ld l,a 
2453			;	ld h,0 
2453			;;	push hl   ; save required space for the copy later 
2453			;	call malloc 
2453			;if DEBUG_FORTH_TOK 
2453			;			DMARK "TKM" 
2453			;	CALLMONITOR 
2453			;endif 
2453			;	if DEBUG_FORTH_MALLOC_GUARD 
2453			;		push af 
2453			;		call ishlzero 
2453			;;		ld a, l 
2453			;;		add h 
2453			;;		cp 0 
2453			;		pop af 
2453			;		 
2453			;		call z,malloc_error 
2453			;	endif 
2453			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2453			; 
2453			; 
2453			;if DEBUG_FORTH_TOK 
2453			;			DMARK "TKR" 
2453			;	CALLMONITOR 
2453			;endif 
2453			; 
2453			;	FORTH_RSP_NEXT 
2453			; 
2453			;	;inc hl	 ; go past current buffer pointer 
2453			;	;inc hl 
2453			;	;inc hl   ; and past if loop flag 
2453			;		; TODO Need to set flag  
2453			; 
2453			;	 
2453			;	 
2453			;	ex de,hl	; malloc is dest 
2453			;	ld hl, (os_tok_len) 
2453			;;	pop bc 
2453			;	ld c, l                
2453			;	ld b,0 
2453			;	ld hl, (os_tok_ptr) 
2453			; 
2453			;if DEBUG_FORTH_TOK 
2453			;			DMARK "TKT" 
2453			;	CALLMONITOR 
2453			;endif 
2453			; 
2453			;	; do str cpy 
2453			; 
2453			;	ldir      ; copy byte in hl to de 
2453			; 
2453			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2453			; 
2453			;if DEBUG_FORTH_TOK 
2453			; 
2453			;			DMARK "TKY" 
2453			;	CALLMONITOR 
2453			;endif 
2453			;	;ld a,0 
2453			;	;ld a,FORTH_END_BUFFER 
2453			;	ex de, hl 
2453			;	;dec hl			 ; go back over the space delim at the end of word 
2453			;	;ld (hl),a 
2453			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2453			;	ld a,FORTH_END_BUFFER 
2453			;	ld (hl),a 
2453			;	inc hl 
2453			;	ld a,FORTH_END_BUFFER 
2453			;	ld (hl),a 
2453			; 
2453			;	; init the malloc area data 
2453			;	; set pc for in current area 
2453			;	;ld hl, (os_tok_malloc) 
2453			;	;inc hl 
2453			;	;inc hl 
2453			;	;inc hl 
2453			;	;ex de,hl 
2453			;	;ld hl, (os_tok_malloc) 
2453			;	;ld (hl),e 
2453			;	;inc hl 
2453			;	;ld (hl),d 
2453			; 
2453			; 
2453			;	ld hl,(os_tok_malloc) 
2453			;if DEBUG_FORTH_PARSE_KEY 
2453			;			DMARK "TKU" 
2453			;	CALLMONITOR 
2453			;endif 
2453			; 
2453			;	ret 
2453			 
2453			forthexec: 
2453			 
2453			; line exec: 
2453			; forth parser 
2453			 
2453			; 
2453			;       get current exec line on rsp 
2453			 
2453				FORTH_RSP_TOS 
2453 cd d6 1f			call macro_forth_rsp_tos 
2456				endm 
# End of macro FORTH_RSP_TOS
2456			 
2456			;       restore current pc - hl points to malloc of data 
2456			 
2456				;ld e, (hl) 
2456				;inc hl 
2456				;ld d, (hl) 
2456				;ex de,hl 
2456			 
2456			 
2456			exec1: 
2456 22 fd f3			ld (os_tok_ptr), hl 
2459			 
2459				; copy our PC to working vars  
2459 22 7b f9			ld (cli_ptr), hl 
245c 22 79 f9			ld (cli_origptr), hl 
245f			 
245f 7e				ld a,(hl) 
2460 fe 7f			cp FORTH_END_BUFFER 
2462 c8				ret z 
2463			 
2463				; skip any nulls 
2463			 
2463 fe 00			cp 0 
2465 20 03			jr nz, .execword 
2467 23				inc hl 
2468 18 ec			jr exec1 
246a			 
246a			 
246a			.execword: 
246a			 
246a			 
246a			 
246a			if DEBUG_FORTH_PARSE_KEY 
246a						DMARK "KYQ" 
246a				CALLMONITOR 
246a			endif 
246a			;       while at start of word: 
246a			; get start of dict (in user area first) 
246a			 
246a 21 00 80		ld hl, baseram 
246d			;ld hl, sysdict 
246d 22 7d f9		ld (cli_nextword),hl 
2470			;           match word at pc 
2470			;           exec word 
2470			;           or push to dsp 
2470			;           forward to next token 
2470			;           if line term pop rsp and exit 
2470			;        
2470			 
2470			if DEBUG_FORTH_PARSE_KEY 
2470						DMARK "KYq" 
2470				CALLMONITOR 
2470			endif 
2470			 
2470			; 
2470			; word comp 
2470			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
2470			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
2470			;    move to start of word  
2470			;    compare word to cli_token 
2470			 
2470			.execpnword:	; HL at start of a word in the dictionary to check 
2470			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
2470			;	ld (cli_ptr), hl 
2470			 
2470 2a 7d f9			ld hl,(cli_nextword) 
2473			 
2473 cd 16 25			call forth_tok_next 
2476			; tok next start here 
2476			;	; TODO skip compiled symbol for now 
2476			;	inc hl 
2476			; 
2476			;	; save pointer to next word 
2476			; 
2476			;	; hl now points to the address of the next word pointer  
2476			;	ld e, (hl) 
2476			;	inc hl 
2476			;	ld d, (hl) 
2476			;	inc l 
2476			; 
2476			;	ex de,hl 
2476			;if DEBUG_FORTH_PARSE_NEXTWORD 
2476			;	push bc 
2476			;	ld bc, (cli_nextword) 
2476			;			DMARK "NXW" 
2476			;	CALLMONITOR 
2476			;	pop bc 
2476			;endif 
2476			; tok next end here 
2476 22 7d f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
2479 eb				ex de, hl 
247a			 
247a			 
247a				; save the pointer of the current token - 1 to check against 
247a				 
247a 22 81 f9			ld (cli_token), hl   
247d				; TODO maybe remove below save if no debug 
247d				; save token string ptr for any debug later 
247d 23				inc hl  
247e 22 83 f9			ld (cli_origtoken), hl 
2481 2b				dec hl 
2482				; save pointer to the start of the next dictionay word 
2482 7e				ld a,(hl)   ; get string length 
2483 47				ld b,a 
2484			.execpnwordinc:  
2484 23				inc hl 
2485 10 fd			djnz .execpnwordinc 
2487 22 7f f9			ld (cli_execword), hl      ; save start of this words code 
248a			 
248a				; now check the word token against the string being parsed 
248a			 
248a 2a 81 f9			ld hl,(cli_token) 
248d 23				inc hl     ; skip string length (use zero term instead to end) 
248e 22 81 f9			ld (cli_token), hl 
2491			 
2491			if DEBUG_FORTH_PARSE_KEY 
2491						DMARK "KY2" 
2491			endif 
2491			if DEBUG_FORTH_PARSE_EXEC 
2491				; see if disabled 
2491			 
2491			;	ld a, (os_view_disable) 
2491			;	cp '*' 
2491				ld a, (debug_vector) 
2491				cp $c9   ; RET  
2491				jr z, .skip 
2491			 
2491				push hl 
2491				push hl 
2491				call clear_display 
2491				ld de, .compword 
2491				ld a, display_row_1 
2491				call str_at_display 
2491				pop de 
2491				ld a, display_row_2 
2491				call str_at_display 
2491				ld hl,(cli_ptr) 
2491				ld a,(hl) 
2491			        ld hl, os_word_scratch 
2491				ld (hl),a 
2491				ld a,0 
2491				inc hl 
2491				ld (hl),a 	 
2491				ld de, os_word_scratch 
2491				ld a, display_row_2+10 
2491				call str_at_display 
2491				call update_display 
2491				ld a, 100 
2491				call aDelayInMS 
2491				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2491				call delay250ms 
2491				endif 
2491				pop hl 
2491			.skip:  
2491			endif	 
2491			.execpnchar:    ; compare char between token and string to parse 
2491			 
2491			if DEBUG_FORTH_PARSE_KEY 
2491						DMARK "Ky3" 
2491			endif 
2491			if DEBUG_FORTH_PARSE_EXEC 
2491				; see if disabled 
2491			 
2491			;	ld a, (os_view_disable) 
2491			;	cp '*' 
2491				ld a, (debug_vector) 
2491				cp $C9  ; RET 
2491				jr z, .skip2 
2491			 
2491			;	call clear_display 
2491			ld hl,(cli_token) 
2491			ld a,(hl) 
2491			ld (os_word_scratch),a 
2491				ld hl,(cli_ptr) 
2491			ld a,(hl) 
2491				ld (os_word_scratch+1),a 
2491				ld a,0 
2491				ld (os_word_scratch+2),a 
2491				ld de,os_word_scratch 
2491				ld a,display_row_4 
2491				call str_at_display 
2491				call update_display 
2491			.skip2:  
2491			endif 
2491 2a 81 f9			ld hl,(cli_token) 
2494 7e				ld a, (hl)	 ; char in word token 
2495 23				inc hl 		; move to next char 
2496 22 81 f9			ld (cli_token), hl ; and save it 
2499 47				ld b,a 
249a			 
249a 2a 7b f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
249d 7e				ld a,(hl) 
249e 23				inc hl 
249f 22 7b f9			ld (cli_ptr), hl		; move to next char 
24a2 cd 39 13			call toUpper 		; make sure the input string matches case 
24a5			 
24a5			if DEBUG_FORTH_PARSE 
24a5			endif 
24a5			 
24a5				; input stream end of token is a space so get rid of it 
24a5			 
24a5			;	cp ' ' 
24a5			;	jr nz, .pnskipspace 
24a5			; 
24a5			;	ld a, 0		; make same term as word token term 
24a5			; 
24a5			;.pnskipspace: 
24a5			 
24a5			if DEBUG_FORTH_PARSE_KEY 
24a5						DMARK "KY7" 
24a5			endif 
24a5 b8				cp b 
24a6 c2 bc 24			jp nz, .execpnskipword	 ; no match so move to next word 
24a9				 
24a9			;    if same 
24a9			;       scan for string terms 0 for token and 32 for input 
24a9			 
24a9				 
24a9			if DEBUG_FORTH_PARSE_KEY 
24a9						DMARK "KY8" 
24a9			endif 
24a9			 
24a9 80				add b			 
24aa fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
24ac							; TODO need to make sure last word in zero term string is accounted for 
24ac 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
24ae			 
24ae			 
24ae				; at end of both strings so both are exact match 
24ae			 
24ae			;       skip ptr for next word 
24ae			 
24ae 2a 7b f9			ld hl,(cli_ptr) 	; at input string term 
24b1 23				inc hl			 ; at next char 
24b2 22 7b f9			ld (cli_ptr), hl     ; save for next round of the parser 
24b5 22 79 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
24b8				 
24b8				 
24b8			if DEBUG_FORTH_PARSE_KEY 
24b8						DMARK "KY3" 
24b8			endif 
24b8			 
24b8			 
24b8			 
24b8			;       exec code block 
24b8			if DEBUG_FORTH_JP 
24b8				call clear_display 
24b8				call update_display 
24b8				call delay1s 
24b8				ld hl, (cli_execword)     ; save for next check if no match on this word 
24b8				ld a,h 
24b8				ld hl, os_word_scratch 
24b8				call hexout 
24b8				ld hl, (cli_execword)     ; save for next check if no match on this word 
24b8				ld a,l 
24b8				ld hl, os_word_scratch+2 
24b8				call hexout 
24b8				ld hl, os_word_scratch+4 
24b8				ld a,0 
24b8				ld (hl),a 
24b8				ld de,os_word_scratch 
24b8				call str_at_display 
24b8					ld a, display_row_2 
24b8					call str_at_display 
24b8				ld de, (cli_origtoken) 
24b8				ld a, display_row_1+10 
24b8					call str_at_display 
24b8			 
24b8				ld a,display_row_1 
24b8				ld de, .foundword 
24b8				ld a, display_row_3 
24b8				call str_at_display 
24b8				call update_display 
24b8				call delay1s 
24b8				call delay1s 
24b8				call delay1s 
24b8			endif 
24b8			 
24b8			if DEBUG_FORTH_PARSE_KEY 
24b8						DMARK "KYj" 
24b8			endif 
24b8				; TODO save the word pointer in this exec 
24b8			 
24b8 2a 7f f9			ld hl,(cli_execword) 
24bb e9				jp (hl) 
24bc			 
24bc			 
24bc			;    if not same 
24bc			;	scan for zero term 
24bc			;	get ptr for next word 
24bc			;	goto word comp 
24bc			 
24bc			.execpnskipword:	; get pointer to next word 
24bc 2a 7d f9			ld hl,(cli_nextword) 
24bf			 
24bf 7e				ld a,(hl) 
24c0 fe 00			cp WORD_SYS_END 
24c2			;	cp 0 
24c2 28 09			jr z, .execendofdict			 ; at end of words 
24c4			 
24c4			if DEBUG_FORTH_PARSE_KEY 
24c4						DMARK "KY4" 
24c4			endif 
24c4			if DEBUG_FORTH_PARSE_EXEC 
24c4			 
24c4				; see if disabled 
24c4			 
24c4			;	ld a, (os_view_disable) 
24c4			;	cp '*' 
24c4				ld a,(debug_vector) 
24c4				cp $c9   ; RET 
24c4				jr z, .noskip 
24c4			 
24c4			 
24c4				ld de, .nowordfound 
24c4				ld a, display_row_3 
24c4				call str_at_display 
24c4				call update_display 
24c4				ld a, 100 
24c4				call aDelayInMS 
24c4				 
24c4				if DEBUG_FORTH_PARSE_EXEC_SLOW 
24c4					call delay250ms 
24c4				endif 
24c4			.noskip:  
24c4			 
24c4			endif	 
24c4			 
24c4 2a 79 f9			ld hl,(cli_origptr) 
24c7 22 7b f9			ld (cli_ptr),hl 
24ca			 
24ca			if DEBUG_FORTH_PARSE_KEY 
24ca						DMARK "KY5" 
24ca			endif 
24ca c3 70 24			jp .execpnword			; else go to next word 
24cd			 
24cd			.execendofdict:  
24cd			 
24cd			if DEBUG_FORTH_PARSE_KEY 
24cd						DMARK "KYe" 
24cd			endif 
24cd			if DEBUG_FORTH_PARSE_EXEC 
24cd				; see if disabled 
24cd			 
24cd			;	ld a, (os_view_disable) 
24cd			;	cp '*' 
24cd				ld a,(debug_vector) 
24cd				cp $c9   ; ret 
24cd				jr z, .ispskip 
24cd			 
24cd				call clear_display 
24cd				call update_display 
24cd				call delay1s 
24cd				ld de, (cli_origptr) 
24cd				ld a, display_row_1 
24cd				call str_at_display 
24cd				 
24cd				ld de, .enddict 
24cd				ld a, display_row_3 
24cd				call str_at_display 
24cd				call update_display 
24cd				ld a, 100 
24cd				call aDelayInMS 
24cd				if DEBUG_FORTH_PARSE_EXEC_SLOW 
24cd				call delay1s 
24cd				call delay1s 
24cd				call delay1s 
24cd				endif 
24cd			.ispskip:  
24cd				 
24cd			endif	 
24cd			 
24cd			 
24cd			 
24cd				; if the word is not a keyword then must be a literal so push it to stack 
24cd			 
24cd			; push token to stack to end of word 
24cd			 
24cd				STACKFRAME ON $1efe $2f9f 
24cd				if DEBUG_STACK_IMB 
24cd					if ON 
24cd						exx 
24cd						ld de, $1efe 
24cd						ld a, d 
24cd						ld hl, curframe 
24cd						call hexout 
24cd						ld a, e 
24cd						ld hl, curframe+2 
24cd						call hexout 
24cd						ld hl, $1efe 
24cd						push hl 
24cd						ld hl, $2f9f 
24cd						push hl 
24cd						exx 
24cd					endif 
24cd				endif 
24cd			endm 
# End of macro STACKFRAME
24cd			 
24cd 2a fd f3		ld hl,(os_tok_ptr) 
24d0 cd 81 21		call forth_apush 
24d3			 
24d3				STACKFRAMECHK ON $1efe $2f9f 
24d3				if DEBUG_STACK_IMB 
24d3					if ON 
24d3						exx 
24d3						ld hl, $2f9f 
24d3						pop de   ; $2f9f 
24d3						call cmp16 
24d3						jr nz, .spnosame 
24d3						ld hl, $1efe 
24d3						pop de   ; $1efe 
24d3						call cmp16 
24d3						jr z, .spfrsame 
24d3						.spnosame: call showsperror 
24d3						.spfrsame: nop 
24d3						exx 
24d3					endif 
24d3				endif 
24d3			endm 
# End of macro STACKFRAMECHK
24d3			 
24d3			execnext: 
24d3			 
24d3			if DEBUG_FORTH_PARSE_KEY 
24d3						DMARK "KY>" 
24d3			endif 
24d3			; move past token to next word 
24d3			 
24d3 2a fd f3		ld hl, (os_tok_ptr) 
24d6 3e 00		ld a, 0 
24d8 01 ff 00		ld bc, 255     ; input buffer size 
24db ed b1		cpir 
24dd			 
24dd			if DEBUG_FORTH_PARSE_KEY 
24dd						DMARK "KY!" 
24dd				CALLMONITOR 
24dd			endif	 
24dd			; TODO this might place hl on the null, so will need to forward on??? 
24dd			;inc hl   ; see if this gets onto the next item 
24dd			 
24dd			 
24dd			; TODO pass a pointer to the buffer to push 
24dd			; TODO call function to push 
24dd			 
24dd			; look for end of input 
24dd			 
24dd			;inc hl 
24dd			;ld a,(hl) 
24dd			;cp FORTH_END_BUFFER 
24dd			;ret z 
24dd			 
24dd			 
24dd c3 56 24		jp exec1 
24e0			 
24e0			 
24e0			 
24e0			 
24e0			 
24e0			 
24e0			 
24e0			 
24e0			 
24e0			findnexttok: 
24e0			 
24e0				; hl is pointer to move 
24e0				; de is the token to locate 
24e0			 
24e0					if DEBUG_FORTH 
24e0						DMARK "NTK" 
24e0						CALLMONITOR 
24e0					endif 
24e0 d5				push de 
24e1			 
24e1			.fnt1:	 
24e1				; find first char of token to locate 
24e1			 
24e1 1a				ld a, (de) 
24e2 4f				ld c,a 
24e3 7e				ld a,(hl) 
24e4 cd 39 13			call toUpper 
24e7					if DEBUG_FORTH 
24e7						DMARK "NT1" 
24e7						CALLMONITOR 
24e7					endif 
24e7 b9				cp c 
24e8			 
24e8 28 03			jr z, .fnt2cmpmorefirst	 
24ea			 
24ea				; first char not found move to next char 
24ea			 
24ea 23				inc hl 
24eb 18 f4			jr .fnt1 
24ed			 
24ed			.fnt2cmpmorefirst:	 
24ed				; first char of token found.  
24ed			 
24ed e5				push hl     ; save start of token just in case it is the right one 
24ee d9				exx 
24ef e1				pop hl        ; save it to hl' 
24f0 d9				exx 
24f1			 
24f1			 
24f1			.fnt2cmpmore:	 
24f1				; compare the rest 
24f1				 
24f1 23				inc hl 
24f2 13				inc de 
24f3				 
24f3 1a				ld a, (de) 
24f4 4f				ld c,a 
24f5 7e				ld a,(hl) 
24f6 cd 39 13			call toUpper 
24f9			 
24f9					if DEBUG_FORTH 
24f9						DMARK "NT2" 
24f9						CALLMONITOR 
24f9					endif 
24f9				; c has the token to find char 
24f9				; a has the mem to scan char 
24f9			 
24f9 b9				cp c 
24fa 28 04			jr z,.fntmatch1 
24fc			 
24fc				; they are not the same 
24fc			 
24fc					if DEBUG_FORTH 
24fc						DMARK "NT3" 
24fc						CALLMONITOR 
24fc					endif 
24fc d1				pop de	; reset de token to look for 
24fd d5				push de 
24fe 18 e1			jr .fnt1 
2500				 
2500			.fntmatch1: 
2500			 
2500				; is the same char a null which means we might have a full hit? 
2500					if DEBUG_FORTH 
2500						DMARK "NT4" 
2500						CALLMONITOR 
2500					endif 
2500			 
2500 fe 00			cp 0 
2502 28 0b			jr z, .fntmatchyes 
2504			 
2504				; are we at the end of the token to find? 
2504			 
2504					if DEBUG_FORTH 
2504						DMARK "NT5" 
2504						CALLMONITOR 
2504					endif 
2504 3e 00			ld a, 0 
2506 b9				cp c 
2507			 
2507 c2 f1 24			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
250a			 
250a					if DEBUG_FORTH 
250a						DMARK "NT6" 
250a						CALLMONITOR 
250a					endif 
250a				; token to find is exhusted but no match to stream 
250a			 
250a				; restore tok pointer and continue on 
250a d1				pop de 
250b d5				push de 
250c c3 e1 24			jp .fnt1 
250f			 
250f			 
250f			.fntmatchyes: 
250f			 
250f				; hl now contains the end of the found token 
250f			 
250f				; get rid of saved token pointer to find 
250f			 
250f d1				pop de 
2510			 
2510					if DEBUG_FORTH 
2510						DMARK "NT9" 
2510						CALLMONITOR 
2510					endif 
2510			 
2510				; hl will be on the null term so forward on 
2510			 
2510				; get back the saved start of the token 
2510			 
2510 d9				exx 
2511 e5				push hl     ; save start of token just in case it is the right one 
2512 d9				exx 
2513 e1				pop hl        ; save it to hl 
2514			 
2514 c9				ret 
2515			 
2515			 
2515			; LIST needs to find a specific token   
2515			; FORGET needs to find a spefici token 
2515			 
2515			; SAVE needs to find all tokens by flag 
2515			; WORDS just needs to scan through all  by flag 
2515			; UWORDS needs to scan through all by flag 
2515			 
2515			 
2515			; given hl as pointer to start of dict look up string 
2515			; return hl as pointer to start of word block 
2515			; or 0 if not found 
2515			 
2515			forth_find_tok: 
2515 c9				ret 
2516			 
2516			; given hl as pointer to dict structure 
2516			; move to the next dict block structure 
2516			 
2516			forth_tok_next: 
2516				; hl now points to the address of the next word pointer  
2516				; TODO skip compiled symbol for now 
2516			;	push de 
2516 23				inc hl 
2517 5e				ld e, (hl) 
2518 23				inc hl 
2519 56				ld d, (hl) 
251a 23				inc hl 
251b			 
251b eb				ex de,hl 
251c			if DEBUG_FORTH_PARSE_NEXTWORD 
251c				push bc 
251c				ld bc, (cli_nextword) 
251c						DMARK "NXW" 
251c				CALLMONITOR 
251c				pop bc 
251c			endif 
251c			;	pop de	 
251c c9				ret 
251d			 
251d			 
251d			 
251d			; eof 
# End of file forth_parserv5.asm
251d				include "forth_wordsv4.asm" 
251d			 
251d			; the core word dictionary v4 
251d			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
251d			 
251d			; this is a linked list for each of the system words used 
251d			; user defined words will follow the same format but will be in ram 
251d			 
251d			 
251d			; 
251d			; 
251d			; define linked list: 
251d			; 
251d			; 1. compiled byte op code 
251d			; 2. len of text word 
251d			; 3. text word 
251d			; 4. ptr to next dictionary word 
251d			; 5. asm, calls etc for the word 
251d			; 
251d			;  if 1 == 0 then last word in dict  
251d			;   
251d			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
251d			;  
251d			;  
251d			; create basic standard set of words 
251d			; 
251d			;  
251d			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
251d			; 2DUP 2DROP 2SWAP  
251d			; @ C@ - get byte  
251d			; ! C! - store byte 
251d			; 0< true if less than zero 
251d			; 0= true if zero 
251d			; < >  
251d			; = true if same 
251d			; variables 
251d			 
251d			 
251d			; Hardware specific words I may need 
251d			; 
251d			; IN OUT  
251d			; calls to key util functions 
251d			; calls to hardward abstraction stuff 
251d			; easy control of frame buffers and lcd i/o 
251d			; keyboard  
251d			 
251d			 
251d			;DICT: macro 
251d			; op_code, len, word, next 
251d			;    word: 
251d			;    db op_code 
251d			;    ds word zero term 
251d			;    dw next 
251d			;    endm 
251d			 
251d			 
251d			 
251d			 
251d			; op code 1 is a flag for user define words which are to be handled differently 
251d			 
251d			 
251d			; 
251d			; 
251d			;    TODO on entry to a word this should be the expected environment 
251d			;    hl - tos value if number then held, if string this is the ptr 
251d			;    de -  
251d			 
251d			 
251d			; opcode ranges 
251d			; 0 - end of word dict 
251d			; 255 - user define words 
251d			 
251d			sysdict: 
251d			include "forth_opcodes.asm" 
251d			; op codes for forth keywords 
251d			; free to use code 0  
251d				OPCODE_HEAP: equ  1 
251d				OPCODE_EXEC: equ 2 
251d				OPCODE_DUP: equ 3 
251d				OPCODE_SWAP: equ 4 
251d				OPCODE_COLN: equ 5 
251d				OPCODE_SCOLN: equ 6 
251d				OPCODE_DROP: equ 7 
251d				OPCODE_DUP2: equ 8 
251d				OPCODE_DROP2: equ 9 
251d				OPCODE_SWAP2: equ 10 
251d				OPCODE_AT: equ 11 
251d				OPCODE_CAT: equ 12 
251d				OPCODE_BANG: equ 13 
251d				OPCODE_CBANG: equ 14 
251d				OPCODE_SCALL: equ 15 
251d				OPCODE_DEPTH: equ 16 
251d				OPCODE_OVER: equ 17 
251d				OPCODE_PAUSE: equ 18 
251d				OPCODE_PAUSES: equ 19 
251d				OPCODE_ROT: equ 20 
251d			;free to reuse	OPCODE_WORDS: equ 21 
251d			        OPCODE_NOT: equ 21 
251d				OPCODE_UWORDS: equ 22 
251d				OPCODE_BP: equ 23 
251d				OPCODE_MONITOR: equ 24  
251d				OPCODE_MALLOC: equ 25 
251d				OPCODE_FREE: equ 26 
251d				OPCODE_LIST: equ 27 
251d				OPCODE_FORGET: equ 28 
251d				OPCODE_NOP: equ 29 
251d				OPCODE_COMO: equ 30 
251d				OPCODE_COMC: equ 31 
251d			;free to reuse	OPCODE_ENDCORE: equ 32 
251d				OPCODE_AFTERSOUND: equ 33 
251d				OPCODE_GP2: equ 34 
251d				OPCODE_GP3: equ 35 
251d				OPCODE_GP4: equ 36 
251d				OPCODE_SIN: equ 37 
251d				OPCODE_SOUT: equ 38 
251d				OPCODE_SPIO: equ 39 
251d				OPCODE_SPICEH: equ 40 
251d				OPCODE_SPIOb: equ 41 
251d				OPCODE_SPII: equ 42 
251d				OPCODE_SESEL: equ 43 
251d				OPCODE_CARTDEV: equ 44 
251d			; free to reuse	OPCODE_ENDDEVICE: equ 45 
251d				OPCODE_FB: equ 46 
251d				OPCODE_EMIT: equ 47 
251d				OPCODE_DOTH: equ 48 
251d				OPCODE_DOTF: equ 49 
251d				OPCODE_DOT: equ 50 
251d				OPCODE_CLS: equ 51 
251d				OPCODE_DRAW: equ 52 
251d				OPCODE_DUMP: equ 53 
251d				OPCODE_CDUMP: equ 54 
251d				OPCODE_DAT: equ 55 
251d				OPCODE_HOME: equ 56 
251d				OPCODE_SPACE: equ 57 
251d				OPCODE_SPACES: equ 58 
251d				OPCODE_SCROLL: equ 59 
251d				OPCODE_ATQ: equ 60 
251d				OPCODE_AUTODSP: equ 61 
251d				OPCODE_MENU: equ 62 
251d			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
251d				OPCODE_THEN: equ 64 
251d				OPCODE_ELSE: equ 65 
251d				OPCODE_DO: equ 66 
251d				OPCODE_LOOP: equ 67 
251d				OPCODE_I: equ 68 
251d				OPCODE_DLOOP: equ 69  
251d				OPCODE_REPEAT: equ 70  
251d				OPCODE_UNTIL: equ 71 
251d				OPCODE_ENDFLOW: equ 72 
251d				OPCODE_WAITK: equ 73 
251d				OPCODE_ACCEPT: equ 74 
251d				OPCODE_EDIT: equ 75 
251d			;free to reuse	OPCODE_ENDKEY: equ 76 
251d				OPCODE_LZERO: equ 77 
251d				OPCODE_TZERO: equ 78 
251d				OPCODE_LESS: equ 79 
251d				OPCODE_GT: equ 80 
251d				OPCODE_EQUAL: equ 81  
251d			;free to reuse	OPCODE_ENDLOGIC: equ 82 
251d				OPCODE_NEG: equ 83 
251d				OPCODE_DIV: equ 84 
251d				OPCODE_MUL: equ 85 
251d				OPCODE_MIN: equ 86 
251d				OPCODE_MAX: equ 87 
251d				OPCODE_RND16: equ 88 
251d				OPCODE_RND8: equ 89 
251d				OPCODE_RND: equ 90 
251d			;free to reuse	OPCODE_ENDMATHS: equ 91  
251d				OPCODE_BYNAME: equ 92 
251d				OPCODE_DIR: equ 93 
251d				OPCODE_SAVE: equ 94 
251d				OPCODE_LOAD: equ 95 
251d				OPCODE_BSAVE: equ 96 
251d				OPCODE_BLOAD: equ 97 
251d				OPCODE_SEO: equ 98  
251d				OPCODE_SEI: equ 99 
251d				OPCODE_SFREE: equ 100 
251d				OPCODE_SIZE: equ 101 
251d				OPCODE_CREATE: equ 102 
251d				OPCODE_APPEND: equ 103 
251d				OPCODE_SDEL: equ 104 
251d				OPCODE_OPEN: equ 105 
251d				OPCODE_READ: equ 106 
251d				OPCODE_EOF: equ 106 
251d				OPCODE_FORMAT: equ 107 
251d				OPCODE_LABEL: equ 108 
251d				OPCODE_LABELS: equ 109 
251d			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
251d				OPCODE_UPPER: equ 111 
251d				OPCODE_LOWER: equ 112 
251d				OPCODE_SUBSTR: equ 113 
251d				OPCODE_LEFT: equ 114 
251d				OPCODE_RIGHT: equ 115 
251d				OPCODE_STR2NUM: equ 116 
251d				OPCODE_NUM2STR: equ 117 
251d				OPCODE_CONCAT: equ 118 
251d				OPCODE_FIND: equ 119 
251d				OPCODE_LEN: equ 120 
251d				OPCODE_CHAR: equ 121 
251d			; free to reuse	OPCODE_STRLEN: equ 122 
251d			; free to reuse	OPCODE_ENDSTR: equ 123 
251d				OPCODE_V0S: equ 124 
251d				OPCODE_V0Q: equ 125 
251d				OPCODE_V1S: equ 126 
251d				OPCODE_V1Q: equ 127 
251d				OPCODE_V2S: equ 128 
251d				OPCODE_V2Q: equ 129 
251d				OPCODE_V3S: equ 130 
251d				OPCODE_V3Q: equ 131 
251d			;free to reuse	OPCODE_END: equ 132 
251d				OPCODE_ZDUP: equ 133 
251d			 
251d			; eof 
# End of file forth_opcodes.asm
251d			 
251d			include "forth_words_core.asm" 
251d			 
251d			; | ## Core Words 
251d			 
251d			;if MALLOC_4 
251d			 
251d			.HEAP: 
251d			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
251d 15				db WORD_SYS_CORE+OPCODE_HEAP             
251e 5c 25			dw .EXEC            
2520 05				db 4 + 1 
2521 .. 00			db "HEAP",0              
2526				endm 
# End of macro CWHEAD
2526			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2526			; | | u1 - Current number of bytes in the heap 
2526			; | | u2 - Remaining bytes left on the heap 
2526			; | |  
2526			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2526			 
2526			 
2526				if DEBUG_FORTH_WORDS_KEY 
2526					DMARK "HEP" 
2526 f5				push af  
2527 3a 3b 25			ld a, (.dmark)  
252a 32 a6 fd			ld (debug_mark),a  
252d 3a 3c 25			ld a, (.dmark+1)  
2530 32 a7 fd			ld (debug_mark+1),a  
2533 3a 3d 25			ld a, (.dmark+2)  
2536 32 a8 fd			ld (debug_mark+2),a  
2539 18 03			jr .pastdmark  
253b ..			.dmark: db "HEP"  
253e f1			.pastdmark: pop af  
253f			endm  
# End of macro DMARK
253f					CALLMONITOR 
253f cd aa fd			call debug_vector  
2542				endm  
# End of macro CALLMONITOR
2542				endif 
2542 2a 0a 80			ld hl, (free_list )      
2545 11 0e 80			ld de, heap_start 
2548			 
2548 ed 52			sbc hl, de  
254a			 
254a cd 18 20			call forth_push_numhl 
254d			 
254d			 
254d ed 5b 0a 80		ld de, (free_list )      
2551 21 d7 f0			ld hl, heap_end 
2554			 
2554 ed 52			sbc hl, de 
2556			 
2556 cd 18 20			call forth_push_numhl 
2559				 
2559			 
2559				 
2559			 
2559			 
2559			 
2559				NEXTW 
2559 c3 c5 23			jp macro_next 
255c				endm 
# End of macro NEXTW
255c			;endif 
255c			 
255c			.EXEC: 
255c			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
255c			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
255c			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
255c			;; > > 
255c			;; > >   
255c			;	STACKFRAME OFF $5efe $5f9f 
255c			; 
255c			;		if DEBUG_FORTH_WORDS_KEY 
255c			;			DMARK "EXE" 
255c			;			CALLMONITOR 
255c			;		endif 
255c			; 
255c			;	FORTH_DSP_VALUEHL 
255c			; 
255c			;	FORTH_DSP_POP 
255c			; 
255c			;		if DEBUG_FORTH_WORDS 
255c			;			DMARK "EX1" 
255c			;			CALLMONITOR 
255c			;		endif 
255c			;;	ld e,(hl) 
255c			;;	inc hl 
255c			;;	ld d,(hl) 
255c			;;	ex de,hl 
255c			; 
255c			;;		if DEBUG_FORTH_WORDS 
255c			;;			DMARK "EX2" 
255c			;;			CALLMONITOR 
255c			;;		endif 
255c			;	push hl 
255c			; 
255c			;	;ld a, 0 
255c			;	;ld a, FORTH_END_BUFFER 
255c			;	call strlenz 
255c			;	inc hl   ; include zero term to copy 
255c			;	inc hl   ; include term 
255c			;	inc hl   ; include term 
255c			;	ld b,0 
255c			;	ld c,l 
255c			;	pop hl 
255c			;	ld de, execscratch 
255c			;		if DEBUG_FORTH_WORDS 
255c			;			DMARK "EX3" 
255c			;			CALLMONITOR 
255c			;		endif 
255c			;	ldir 
255c			; 
255c			; 
255c			;	ld hl, execscratch 
255c			; 
255c			;		if DEBUG_FORTH_WORDS 
255c			;			DMARK "EXe" 
255c			;			CALLMONITOR 
255c			;		endif 
255c			; 
255c			;	call forthparse 
255c			;	call forthexec 
255c			;;	call forthexec_cleanup 
255c			;;	call forthparse 
255c			;;	call forthexec 
255c			; 
255c			;	STACKFRAMECHK OFF $5efe $5f9f 
255c			; 
255c			;	; an immediate word so no need to process any more words 
255c			;	ret 
255c			;	NEXTW 
255c			 
255c			; dead code - old version  
255c			;	FORTH_RSP_NEXT 
255c			 
255c			;  
255c			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
255c			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
255c			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
255c			;	push hl 
255c			;	push de 
255c			;	push bc 
255c			; 
255c			; 
255c			;		if DEBUG_FORTH_WORDS_KEY 
255c			;			DMARK "EXR" 
255c			;			CALLMONITOR 
255c			;		endif 
255c			; 
255c			; 
255c			; 
255c			;	;v5 FORTH_DSP_VALUE 
255c			;	FORTH_DSP_VALUEHL 
255c			; 
255c			;	; TODO do string type checks 
255c			; 
255c			;;v5	inc hl   ; skip type 
255c			; 
255c			;	push hl  ; source code  
255c			;		if DEBUG_FORTH_WORDS 
255c			;			DMARK "EX1" 
255c			;			CALLMONITOR 
255c			;		endif 
255c			;	ld a, 0 
255c			;	call strlent 
255c			; 
255c			;	inc hl 
255c			;	inc hl 
255c			;	inc hl 
255c			;	inc hl 
255c			; 
255c			;	push hl    ; size 
255c			; 
255c			;		if DEBUG_FORTH_WORDS 
255c			;			DMARK "EX2" 
255c			;			CALLMONITOR 
255c			;		endif 
255c			;	call malloc 
255c			; 
255c			;	ex de, hl    ; de now contains malloc area 
255c			;	pop bc   	; get byte count 
255c			;	pop hl      ; get string to copy 
255c			; 
255c			;	push de     ; save malloc for free later 
255c			; 
255c			;		if DEBUG_FORTH_WORDS 
255c			;			DMARK "EX3" 
255c			;			CALLMONITOR 
255c			;		endif 
255c			;	ldir       ; duplicate string 
255c			; 
255c			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
255c			;	 
255c			;	; TODO fix the parse would be better than this...  
255c			;	ex de, hl 
255c			;	dec hl 
255c			;	ld a, 0 
255c			;	ld (hl), a 
255c			;	dec hl 
255c			;	ld a, ' ' 
255c			;	ld (hl), a 
255c			;	dec hl 
255c			;	ld (hl), a 
255c			; 
255c			;	dec hl 
255c			;	ld (hl), a 
255c			; 
255c			; 
255c			;	FORTH_DSP_POP  
255c			; 
255c			;	pop hl     
255c			;	push hl    ; save malloc area 
255c			; 
255c			;		if DEBUG_FORTH_WORDS 
255c			;			DMARK "EX4" 
255c			;			CALLMONITOR 
255c			;		endif 
255c			; 
255c			;	call forthparse 
255c			;	call forthexec 
255c			;	 
255c			;	pop hl 
255c			;	if DEBUG_FORTH_WORDS 
255c			;		DMARK "EX5" 
255c			;		CALLMONITOR 
255c			;	endif 
255c			; 
255c			;	if FORTH_ENABLE_FREE 
255c			;	call free 
255c			;	endif 
255c			; 
255c			;	if DEBUG_FORTH_WORDS 
255c			;		DMARK "EX6" 
255c			;		CALLMONITOR 
255c			;	endif 
255c			; 
255c			;	pop bc 
255c			;	pop de 
255c			;	pop hl 
255c			;;	FORTH_RSP_POP	  
255c			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
255c			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
255c			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
255c			; 
255c			;	if DEBUG_FORTH_WORDS 
255c			;		DMARK "EX7" 
255c			;		CALLMONITOR 
255c			;	endif 
255c			;	NEXTW 
255c			 
255c			;.STKEXEC: 
255c			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
255c			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
255c			; 
255c			; 
255c			;		if DEBUG_FORTH_WORDS_KEY 
255c			;			DMARK "STX" 
255c			;			CALLMONITOR 
255c			;		endif 
255c			; 
255c			;	FORTH_DSP_VALUEHL 
255c			; 
255c			;	ld (store_tmp1), hl    ; count 
255c			; 
255c			;	FORTH_DSP_POP 
255c			;.stkexec1: 
255c			;	ld hl, (store_tmp1)   ; count 
255c			;	ld a, 0 
255c			;	cp l 
255c			;	ret z 
255c			; 
255c			;	dec hl 
255c			;	ld (store_tmp1), hl    ; count 
255c			;	 
255c			;	FORTH_DSP_VALUEHL 
255c			;	push hl 
255c			;	 
255c			;		if DEBUG_FORTH_WORDS 
255c			;			DMARK "EXp" 
255c			;			CALLMONITOR 
255c			;		endif 
255c			;	FORTH_DSP_POP 
255c			; 
255c			;	call strlenz 
255c			;	inc hl   ; include zero term to copy 
255c			;	inc hl   ; include zero term to copy 
255c			;	inc hl   ; include zero term to copy 
255c			;	ld b,0 
255c			;	ld c,l 
255c			;	pop hl 
255c			;	ld de, execscratch 
255c			;		if DEBUG_FORTH_WORDS 
255c			;			DMARK "EX3" 
255c			;			CALLMONITOR 
255c			;		endif 
255c			;	ldir 
255c			; 
255c			; 
255c			;	ld hl, execscratch 
255c			; 
255c			;		if DEBUG_FORTH_WORDS 
255c			;			DMARK "EXP" 
255c			;			CALLMONITOR 
255c			;		endif 
255c			; 
255c			;	call forthparse 
255c			;	ld hl, execscratch 
255c			;		if DEBUG_FORTH_WORDS 
255c			;			DMARK "EXx" 
255c			;			CALLMONITOR 
255c			;		endif 
255c			;	call forthexec 
255c			; 
255c			;	jp .stkexec1 
255c			; 
255c			;	ret 
255c			 
255c			 
255c			.DUP: 
255c			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
255c 17				db WORD_SYS_CORE+OPCODE_DUP             
255d d2 25			dw .ZDUP            
255f 04				db 3 + 1 
2560 .. 00			db "DUP",0              
2564				endm 
# End of macro CWHEAD
2564			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2564			 
2564				if DEBUG_FORTH_WORDS_KEY 
2564					DMARK "DUP" 
2564 f5				push af  
2565 3a 79 25			ld a, (.dmark)  
2568 32 a6 fd			ld (debug_mark),a  
256b 3a 7a 25			ld a, (.dmark+1)  
256e 32 a7 fd			ld (debug_mark+1),a  
2571 3a 7b 25			ld a, (.dmark+2)  
2574 32 a8 fd			ld (debug_mark+2),a  
2577 18 03			jr .pastdmark  
2579 ..			.dmark: db "DUP"  
257c f1			.pastdmark: pop af  
257d			endm  
# End of macro DMARK
257d					CALLMONITOR 
257d cd aa fd			call debug_vector  
2580				endm  
# End of macro CALLMONITOR
2580				endif 
2580			 
2580				FORTH_DSP 
2580 cd d5 21			call macro_forth_dsp 
2583				endm 
# End of macro FORTH_DSP
2583			 
2583 7e				ld a, (HL) 
2584 fe 01			cp DS_TYPE_STR 
2586 20 25			jr nz, .dupinum 
2588			 
2588				; push another string 
2588			 
2588				FORTH_DSP_VALUEHL     		 
2588 cd 0f 22			call macro_dsp_valuehl 
258b				endm 
# End of macro FORTH_DSP_VALUEHL
258b			 
258b			if DEBUG_FORTH_WORDS 
258b				DMARK "DUs" 
258b f5				push af  
258c 3a a0 25			ld a, (.dmark)  
258f 32 a6 fd			ld (debug_mark),a  
2592 3a a1 25			ld a, (.dmark+1)  
2595 32 a7 fd			ld (debug_mark+1),a  
2598 3a a2 25			ld a, (.dmark+2)  
259b 32 a8 fd			ld (debug_mark+2),a  
259e 18 03			jr .pastdmark  
25a0 ..			.dmark: db "DUs"  
25a3 f1			.pastdmark: pop af  
25a4			endm  
# End of macro DMARK
25a4				CALLMONITOR 
25a4 cd aa fd			call debug_vector  
25a7				endm  
# End of macro CALLMONITOR
25a7			endif 
25a7 cd 86 20			call forth_push_str 
25aa			 
25aa				NEXTW 
25aa c3 c5 23			jp macro_next 
25ad				endm 
# End of macro NEXTW
25ad			 
25ad			 
25ad			.dupinum: 
25ad				 
25ad			 
25ad			 
25ad				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25ad cd 0f 22			call macro_dsp_valuehl 
25b0				endm 
# End of macro FORTH_DSP_VALUEHL
25b0			 
25b0			; TODO add floating point number detection 
25b0			 
25b0			if DEBUG_FORTH_WORDS 
25b0				DMARK "DUi" 
25b0 f5				push af  
25b1 3a c5 25			ld a, (.dmark)  
25b4 32 a6 fd			ld (debug_mark),a  
25b7 3a c6 25			ld a, (.dmark+1)  
25ba 32 a7 fd			ld (debug_mark+1),a  
25bd 3a c7 25			ld a, (.dmark+2)  
25c0 32 a8 fd			ld (debug_mark+2),a  
25c3 18 03			jr .pastdmark  
25c5 ..			.dmark: db "DUi"  
25c8 f1			.pastdmark: pop af  
25c9			endm  
# End of macro DMARK
25c9				CALLMONITOR 
25c9 cd aa fd			call debug_vector  
25cc				endm  
# End of macro CALLMONITOR
25cc			endif 
25cc			 
25cc cd 18 20			call forth_push_numhl 
25cf				NEXTW 
25cf c3 c5 23			jp macro_next 
25d2				endm 
# End of macro NEXTW
25d2			.ZDUP: 
25d2			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
25d2 99				db WORD_SYS_CORE+OPCODE_ZDUP             
25d3 0a 26			dw .SWAP            
25d5 05				db 4 + 1 
25d6 .. 00			db "?DUP",0              
25db				endm 
# End of macro CWHEAD
25db			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
25db			 
25db				if DEBUG_FORTH_WORDS_KEY 
25db					DMARK "qDU" 
25db f5				push af  
25dc 3a f0 25			ld a, (.dmark)  
25df 32 a6 fd			ld (debug_mark),a  
25e2 3a f1 25			ld a, (.dmark+1)  
25e5 32 a7 fd			ld (debug_mark+1),a  
25e8 3a f2 25			ld a, (.dmark+2)  
25eb 32 a8 fd			ld (debug_mark+2),a  
25ee 18 03			jr .pastdmark  
25f0 ..			.dmark: db "qDU"  
25f3 f1			.pastdmark: pop af  
25f4			endm  
# End of macro DMARK
25f4					CALLMONITOR 
25f4 cd aa fd			call debug_vector  
25f7				endm  
# End of macro CALLMONITOR
25f7				endif 
25f7				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25f7 cd 0f 22			call macro_dsp_valuehl 
25fa				endm 
# End of macro FORTH_DSP_VALUEHL
25fa			 
25fa e5				push hl 
25fb			 
25fb				; is it a zero? 
25fb			 
25fb 3e 00			ld a, 0 
25fd 84				add h 
25fe 85				add l 
25ff			 
25ff e1				pop hl 
2600			 
2600 fe 00			cp 0 
2602 28 03			jr z, .dup2orig 
2604			 
2604			 
2604 cd 18 20			call forth_push_numhl 
2607			 
2607			 
2607			; TODO add floating point number detection 
2607			 
2607			.dup2orig: 
2607			 
2607				NEXTW 
2607 c3 c5 23			jp macro_next 
260a				endm 
# End of macro NEXTW
260a			.SWAP: 
260a			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
260a 18				db WORD_SYS_CORE+OPCODE_SWAP             
260b 49 26			dw .COLN            
260d 05				db 4 + 1 
260e .. 00			db "SWAP",0              
2613				endm 
# End of macro CWHEAD
2613			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2613				if DEBUG_FORTH_WORDS_KEY 
2613					DMARK "SWP" 
2613 f5				push af  
2614 3a 28 26			ld a, (.dmark)  
2617 32 a6 fd			ld (debug_mark),a  
261a 3a 29 26			ld a, (.dmark+1)  
261d 32 a7 fd			ld (debug_mark+1),a  
2620 3a 2a 26			ld a, (.dmark+2)  
2623 32 a8 fd			ld (debug_mark+2),a  
2626 18 03			jr .pastdmark  
2628 ..			.dmark: db "SWP"  
262b f1			.pastdmark: pop af  
262c			endm  
# End of macro DMARK
262c					CALLMONITOR 
262c cd aa fd			call debug_vector  
262f				endm  
# End of macro CALLMONITOR
262f				endif 
262f			 
262f			; TODO Use os stack swap memory 
262f				FORTH_DSP_VALUEHL 
262f cd 0f 22			call macro_dsp_valuehl 
2632				endm 
# End of macro FORTH_DSP_VALUEHL
2632 e5				push hl     ; w2 
2633			 
2633				FORTH_DSP_POP 
2633 cd c7 22			call macro_forth_dsp_pop 
2636				endm 
# End of macro FORTH_DSP_POP
2636			 
2636				FORTH_DSP_VALUEHL 
2636 cd 0f 22			call macro_dsp_valuehl 
2639				endm 
# End of macro FORTH_DSP_VALUEHL
2639			 
2639				FORTH_DSP_POP 
2639 cd c7 22			call macro_forth_dsp_pop 
263c				endm 
# End of macro FORTH_DSP_POP
263c			 
263c d1				pop de     ; w2	, hl = w1 
263d			 
263d eb				ex de, hl 
263e d5				push de 
263f			 
263f cd 18 20			call forth_push_numhl 
2642			 
2642 e1				pop hl 
2643			 
2643 cd 18 20			call forth_push_numhl 
2646				 
2646			 
2646				NEXTW 
2646 c3 c5 23			jp macro_next 
2649				endm 
# End of macro NEXTW
2649			.COLN: 
2649			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
2649 19				db WORD_SYS_CORE+OPCODE_COLN             
264a d5 27			dw .SCOLN            
264c 02				db 1 + 1 
264d .. 00			db ":",0              
264f				endm 
# End of macro CWHEAD
264f			; | : ( -- )         Create new word | DONE 
264f			 
264f				if DEBUG_FORTH_WORDS_KEY 
264f					DMARK "CLN" 
264f f5				push af  
2650 3a 64 26			ld a, (.dmark)  
2653 32 a6 fd			ld (debug_mark),a  
2656 3a 65 26			ld a, (.dmark+1)  
2659 32 a7 fd			ld (debug_mark+1),a  
265c 3a 66 26			ld a, (.dmark+2)  
265f 32 a8 fd			ld (debug_mark+2),a  
2662 18 03			jr .pastdmark  
2664 ..			.dmark: db "CLN"  
2667 f1			.pastdmark: pop af  
2668			endm  
# End of macro DMARK
2668					CALLMONITOR 
2668 cd aa fd			call debug_vector  
266b				endm  
# End of macro CALLMONITOR
266b				endif 
266b			STACKFRAME OFF $8efe $989f 
266b				if DEBUG_STACK_IMB 
266b					if OFF 
266b						exx 
266b						ld de, $8efe 
266b						ld a, d 
266b						ld hl, curframe 
266b						call hexout 
266b						ld a, e 
266b						ld hl, curframe+2 
266b						call hexout 
266b						ld hl, $8efe 
266b						push hl 
266b						ld hl, $989f 
266b						push hl 
266b						exx 
266b					endif 
266b				endif 
266b			endm 
# End of macro STACKFRAME
266b			; get parser buffer length  of new word 
266b			 
266b			 
266b			 
266b				; move tok past this to start of name defintition 
266b				; TODO get word to define 
266b				; TODO Move past word token 
266b				; TODO get length of string up to the ';' 
266b			 
266b 2a fd f3		ld hl, (os_tok_ptr) 
266e 23			inc hl 
266f 23			inc hl 
2670			 
2670 3e 3b		ld a, ';' 
2672 cd 4d 13		call strlent 
2675			 
2675 7d			ld a,l 
2676 32 ec f0		ld (os_new_parse_len), a 
2679			 
2679			 
2679			if DEBUG_FORTH_UWORD 
2679 ed 5b fd f3	ld de, (os_tok_ptr) 
267d					DMARK ":01" 
267d f5				push af  
267e 3a 92 26			ld a, (.dmark)  
2681 32 a6 fd			ld (debug_mark),a  
2684 3a 93 26			ld a, (.dmark+1)  
2687 32 a7 fd			ld (debug_mark+1),a  
268a 3a 94 26			ld a, (.dmark+2)  
268d 32 a8 fd			ld (debug_mark+2),a  
2690 18 03			jr .pastdmark  
2692 ..			.dmark: db ":01"  
2695 f1			.pastdmark: pop af  
2696			endm  
# End of macro DMARK
2696			CALLMONITOR 
2696 cd aa fd			call debug_vector  
2699				endm  
# End of macro CALLMONITOR
2699			endif 
2699			 
2699			; 
2699			;  new word memory layout: 
2699			;  
2699			;    : adg 6666 ;  
2699			; 
2699			;    db   1     ; user defined word  
2699 23			inc hl    
269a			;    dw   sysdict 
269a 23			inc hl 
269b 23			inc hl 
269c			;    db <word len>+1 (for null) 
269c 23			inc hl 
269d			;    db .... <word> 
269d			; 
269d			 
269d 23			inc hl    ; some extras for the word preamble before the above 
269e 23			inc hl 
269f 23			inc hl 
26a0 23			inc hl 
26a1 23			inc hl 
26a2 23			inc hl 
26a3 23			inc hl  
26a4 23			inc hl 
26a5 23			inc hl 
26a6 23			inc hl 
26a7 23			inc hl 
26a8 23			inc hl 
26a9 23			inc hl 
26aa 23			inc hl     ; TODO how many do we really need?     maybe only 6 
26ab			;       exec word buffer 
26ab			;	<ptr word>   
26ab 23			inc hl 
26ac 23			inc hl 
26ad			;       <word list><null term> 7F final term 
26ad			 
26ad			 
26ad			if DEBUG_FORTH_UWORD 
26ad					DMARK ":02" 
26ad f5				push af  
26ae 3a c2 26			ld a, (.dmark)  
26b1 32 a6 fd			ld (debug_mark),a  
26b4 3a c3 26			ld a, (.dmark+1)  
26b7 32 a7 fd			ld (debug_mark+1),a  
26ba 3a c4 26			ld a, (.dmark+2)  
26bd 32 a8 fd			ld (debug_mark+2),a  
26c0 18 03			jr .pastdmark  
26c2 ..			.dmark: db ":02"  
26c5 f1			.pastdmark: pop af  
26c6			endm  
# End of macro DMARK
26c6			CALLMONITOR 
26c6 cd aa fd			call debug_vector  
26c9				endm  
# End of macro CALLMONITOR
26c9			endif 
26c9			 
26c9			 
26c9				; malloc the size 
26c9			 
26c9 cd b7 13			call malloc 
26cc 22 ee f0			ld (os_new_malloc), hl     ; save malloc start 
26cf			 
26cf			;    db   1     ; user defined word  
26cf 3e 01			ld a, WORD_SYS_UWORD  
26d1 77				ld (hl), a 
26d2			 
26d2 23			inc hl    
26d3			;    dw   sysdict 
26d3 11 1d 25		ld de, sysdict       ; continue on with the scan to the system dict 
26d6 73			ld (hl), e 
26d7 23			inc hl 
26d8 72			ld (hl), d 
26d9 23			inc hl 
26da			 
26da			 
26da			;    Setup dict word 
26da			 
26da 23			inc hl 
26db 22 e8 f0		ld (os_new_work_ptr), hl     ; save start of dict word  
26de			 
26de			; 1. get length of dict word 
26de			 
26de			 
26de 2a fd f3		ld hl, (os_tok_ptr) 
26e1 23			inc hl 
26e2 23			inc hl    ; position to start of dict word 
26e3 3e 00		ld a, 0 
26e5 cd 4d 13		call strlent 
26e8			 
26e8			 
26e8 23			inc hl    ; to include null??? 
26e9			 
26e9			; write length of dict word 
26e9			 
26e9 ed 5b e8 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
26ed 1b			dec de 
26ee eb			ex de, hl 
26ef 73			ld (hl), e 
26f0 eb			ex de, hl 
26f1			 
26f1			 
26f1			 
26f1			; copy  
26f1 4d			ld c, l 
26f2 06 00		ld b, 0 
26f4 ed 5b e8 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
26f8 2a fd f3		ld hl, (os_tok_ptr) 
26fb 23			inc hl 
26fc 23			inc hl    ; position to start of dict word 
26fd			 
26fd			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
26fd			 
26fd			; TODO need to convert word to upper case 
26fd			 
26fd			ucasetok:	 
26fd 7e			ld a,(hl) 
26fe cd 39 13		call toUpper 
2701 77			ld (hl),a 
2702 ed a0		ldi 
2704 f2 fd 26		jp p, ucasetok 
2707			 
2707			 
2707			 
2707			; de now points to start of where the word body code should be placed 
2707 ed 53 e8 f0	ld (os_new_work_ptr), de 
270b			; hl now points to the words to throw at forthexec which needs to be copied 
270b 22 e6 f0		ld (os_new_src_ptr), hl 
270e			 
270e			; TODO add 'call to forthexec' 
270e			 
270e			if DEBUG_FORTH_UWORD 
270e c5			push bc 
270f ed 4b ee f0	ld bc, (os_new_malloc) 
2713					DMARK ":0x" 
2713 f5				push af  
2714 3a 28 27			ld a, (.dmark)  
2717 32 a6 fd			ld (debug_mark),a  
271a 3a 29 27			ld a, (.dmark+1)  
271d 32 a7 fd			ld (debug_mark+1),a  
2720 3a 2a 27			ld a, (.dmark+2)  
2723 32 a8 fd			ld (debug_mark+2),a  
2726 18 03			jr .pastdmark  
2728 ..			.dmark: db ":0x"  
272b f1			.pastdmark: pop af  
272c			endm  
# End of macro DMARK
272c			CALLMONITOR 
272c cd aa fd			call debug_vector  
272f				endm  
# End of macro CALLMONITOR
272f c1			pop bc 
2730			endif 
2730			 
2730			 
2730			; create word preamble which should be: 
2730			 
2730			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2730			 
2730			;    ld hl, <word code> 
2730			;    jp user_exec 
2730			;    <word code bytes> 
2730			 
2730			 
2730			;	inc de     ; TODO ??? or are we already past the word's null 
2730 eb			ex de, hl 
2731			 
2731 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2733			 
2733 23			inc hl 
2734 22 e2 f0		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2737 23			inc hl 
2738			 
2738 23			inc hl 
2739 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
273b			 
273b 01 c6 5c		ld bc, user_exec 
273e 23			inc hl 
273f 71			ld (hl), c     ; poke address of user_exec 
2740 23			inc hl 
2741 70			ld (hl), b     
2742			; 
2742			;	inc hl 
2742			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2742			; 
2742			; 
2742			;	ld bc, macro_forth_rsp_next 
2742			;	inc hl 
2742			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2742			;	inc hl 
2742			;	ld (hl), b     
2742			; 
2742			;	inc hl 
2742			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2742			; 
2742			; 
2742			;	inc hl 
2742			;	ld bc, forthexec 
2742			;	ld (hl), c     ; poke address of forthexec 
2742			;	inc hl 
2742			;	ld (hl), b      
2742			; 
2742			;	inc hl 
2742			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2742			; 
2742			;	ld bc, user_dict_next 
2742			;	inc hl 
2742			;	ld (hl), c     ; poke address of forthexec 
2742			;	inc hl 
2742			;	ld (hl), b      
2742			 
2742			; hl is now where we need to copy the word byte data to save this 
2742			 
2742 23			inc hl 
2743 22 e4 f0		ld (os_new_exec), hl 
2746			 
2746			; copy definition 
2746			 
2746 eb			ex de, hl 
2747			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2747			;	inc de    ; skip the PC for this parse 
2747 3a ec f0		ld a, (os_new_parse_len) 
274a 4f			ld c, a 
274b 06 00		ld b, 0 
274d ed b0		ldir		 ; copy defintion 
274f			 
274f			 
274f			; poke the address of where the new word bytes live for forthexec 
274f			 
274f 2a e2 f0		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2752			 
2752 ed 5b e4 f0	ld de, (os_new_exec)      
2756			 
2756 73			ld (hl), e 
2757 23			inc hl 
2758 72			ld (hl), d 
2759			 
2759				; TODO copy last user dict word next link to this word 
2759				; TODO update last user dict word to point to this word 
2759			; 
2759			; hl f923 de 812a ; bc 811a 
2759			 
2759			if DEBUG_FORTH_UWORD 
2759 c5			push bc 
275a ed 4b ee f0	ld bc, (os_new_malloc) 
275e					DMARK ":0A" 
275e f5				push af  
275f 3a 73 27			ld a, (.dmark)  
2762 32 a6 fd			ld (debug_mark),a  
2765 3a 74 27			ld a, (.dmark+1)  
2768 32 a7 fd			ld (debug_mark+1),a  
276b 3a 75 27			ld a, (.dmark+2)  
276e 32 a8 fd			ld (debug_mark+2),a  
2771 18 03			jr .pastdmark  
2773 ..			.dmark: db ":0A"  
2776 f1			.pastdmark: pop af  
2777			endm  
# End of macro DMARK
2777			CALLMONITOR 
2777 cd aa fd			call debug_vector  
277a				endm  
# End of macro CALLMONITOR
277a c1			pop bc 
277b			endif 
277b			if DEBUG_FORTH_UWORD 
277b c5			push bc 
277c ed 4b ee f0	ld bc, (os_new_malloc) 
2780 03			inc bc 
2781 03			inc bc 
2782 03			inc bc 
2783 03			inc bc 
2784 03			inc bc 
2785 03			inc bc 
2786 03			inc bc 
2787 03			inc bc 
2788			 
2788					DMARK ":0B" 
2788 f5				push af  
2789 3a 9d 27			ld a, (.dmark)  
278c 32 a6 fd			ld (debug_mark),a  
278f 3a 9e 27			ld a, (.dmark+1)  
2792 32 a7 fd			ld (debug_mark+1),a  
2795 3a 9f 27			ld a, (.dmark+2)  
2798 32 a8 fd			ld (debug_mark+2),a  
279b 18 03			jr .pastdmark  
279d ..			.dmark: db ":0B"  
27a0 f1			.pastdmark: pop af  
27a1			endm  
# End of macro DMARK
27a1			CALLMONITOR 
27a1 cd aa fd			call debug_vector  
27a4				endm  
# End of macro CALLMONITOR
27a4 c1			pop bc 
27a5			endif 
27a5			 
27a5			; update word dict linked list for new word 
27a5			 
27a5			 
27a5 2a f9 f3		ld hl, (os_last_new_uword)		; get the start of the last added uword 
27a8 23			inc hl     ; move to next work linked list ptr 
27a9			 
27a9 ed 5b ee f0	ld de, (os_new_malloc)		 ; new next word 
27ad 73			ld (hl), e 
27ae 23			inc hl 
27af 72			ld (hl), d 
27b0			 
27b0			if DEBUG_FORTH_UWORD 
27b0 ed 4b f9 f3	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
27b4			endif 
27b4			 
27b4 ed 53 f9 f3	ld (os_last_new_uword), de      ; update last new uword ptr 
27b8			 
27b8			 
27b8			if DEBUG_FORTH_UWORD 
27b8					DMARK ":0+" 
27b8 f5				push af  
27b9 3a cd 27			ld a, (.dmark)  
27bc 32 a6 fd			ld (debug_mark),a  
27bf 3a ce 27			ld a, (.dmark+1)  
27c2 32 a7 fd			ld (debug_mark+1),a  
27c5 3a cf 27			ld a, (.dmark+2)  
27c8 32 a8 fd			ld (debug_mark+2),a  
27cb 18 03			jr .pastdmark  
27cd ..			.dmark: db ":0+"  
27d0 f1			.pastdmark: pop af  
27d1			endm  
# End of macro DMARK
27d1			CALLMONITOR 
27d1 cd aa fd			call debug_vector  
27d4				endm  
# End of macro CALLMONITOR
27d4			endif 
27d4			 
27d4			STACKFRAMECHK OFF $8efe $989f 
27d4				if DEBUG_STACK_IMB 
27d4					if OFF 
27d4						exx 
27d4						ld hl, $989f 
27d4						pop de   ; $989f 
27d4						call cmp16 
27d4						jr nz, .spnosame 
27d4						ld hl, $8efe 
27d4						pop de   ; $8efe 
27d4						call cmp16 
27d4						jr z, .spfrsame 
27d4						.spnosame: call showsperror 
27d4						.spfrsame: nop 
27d4						exx 
27d4					endif 
27d4				endif 
27d4			endm 
# End of macro STACKFRAMECHK
27d4			 
27d4 c9			ret    ; dont process any remaining parser tokens as they form new word 
27d5			 
27d5			 
27d5			 
27d5			 
27d5			;		NEXT 
27d5			.SCOLN: 
27d5			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
27d5 06			db OPCODE_SCOLN 
27d6 21 28		dw .DROP 
27d8 02			db 2 
27d9 .. 00		db ";",0           
27db			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
27db				if DEBUG_FORTH_WORDS_KEY 
27db					DMARK "SCN" 
27db f5				push af  
27dc 3a f0 27			ld a, (.dmark)  
27df 32 a6 fd			ld (debug_mark),a  
27e2 3a f1 27			ld a, (.dmark+1)  
27e5 32 a7 fd			ld (debug_mark+1),a  
27e8 3a f2 27			ld a, (.dmark+2)  
27eb 32 a8 fd			ld (debug_mark+2),a  
27ee 18 03			jr .pastdmark  
27f0 ..			.dmark: db "SCN"  
27f3 f1			.pastdmark: pop af  
27f4			endm  
# End of macro DMARK
27f4					CALLMONITOR 
27f4 cd aa fd			call debug_vector  
27f7				endm  
# End of macro CALLMONITOR
27f7				endif 
27f7				FORTH_RSP_TOS 
27f7 cd d6 1f			call macro_forth_rsp_tos 
27fa				endm 
# End of macro FORTH_RSP_TOS
27fa e5				push hl 
27fb				FORTH_RSP_POP 
27fb cd e0 1f			call macro_forth_rsp_pop 
27fe				endm 
# End of macro FORTH_RSP_POP
27fe e1				pop hl 
27ff			;		ex de,hl 
27ff 22 fd f3			ld (os_tok_ptr),hl 
2802			 
2802			if DEBUG_FORTH_UWORD 
2802					DMARK "SCL" 
2802 f5				push af  
2803 3a 17 28			ld a, (.dmark)  
2806 32 a6 fd			ld (debug_mark),a  
2809 3a 18 28			ld a, (.dmark+1)  
280c 32 a7 fd			ld (debug_mark+1),a  
280f 3a 19 28			ld a, (.dmark+2)  
2812 32 a8 fd			ld (debug_mark+2),a  
2815 18 03			jr .pastdmark  
2817 ..			.dmark: db "SCL"  
281a f1			.pastdmark: pop af  
281b			endm  
# End of macro DMARK
281b			CALLMONITOR 
281b cd aa fd			call debug_vector  
281e				endm  
# End of macro CALLMONITOR
281e			endif 
281e				NEXTW 
281e c3 c5 23			jp macro_next 
2821				endm 
# End of macro NEXTW
2821			 
2821			.DROP: 
2821			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2821 1b				db WORD_SYS_CORE+OPCODE_DROP             
2822 4c 28			dw .DUP2            
2824 05				db 4 + 1 
2825 .. 00			db "DROP",0              
282a				endm 
# End of macro CWHEAD
282a			; | DROP ( w -- )   drop the TOS item   | DONE 
282a				if DEBUG_FORTH_WORDS_KEY 
282a					DMARK "DRP" 
282a f5				push af  
282b 3a 3f 28			ld a, (.dmark)  
282e 32 a6 fd			ld (debug_mark),a  
2831 3a 40 28			ld a, (.dmark+1)  
2834 32 a7 fd			ld (debug_mark+1),a  
2837 3a 41 28			ld a, (.dmark+2)  
283a 32 a8 fd			ld (debug_mark+2),a  
283d 18 03			jr .pastdmark  
283f ..			.dmark: db "DRP"  
2842 f1			.pastdmark: pop af  
2843			endm  
# End of macro DMARK
2843					CALLMONITOR 
2843 cd aa fd			call debug_vector  
2846				endm  
# End of macro CALLMONITOR
2846				endif 
2846				FORTH_DSP_POP 
2846 cd c7 22			call macro_forth_dsp_pop 
2849				endm 
# End of macro FORTH_DSP_POP
2849				NEXTW 
2849 c3 c5 23			jp macro_next 
284c				endm 
# End of macro NEXTW
284c			.DUP2: 
284c			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
284c 1c				db WORD_SYS_CORE+OPCODE_DUP2             
284d 91 28			dw .DROP2            
284f 05				db 4 + 1 
2850 .. 00			db "2DUP",0              
2855				endm 
# End of macro CWHEAD
2855			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2855				if DEBUG_FORTH_WORDS_KEY 
2855					DMARK "2DU" 
2855 f5				push af  
2856 3a 6a 28			ld a, (.dmark)  
2859 32 a6 fd			ld (debug_mark),a  
285c 3a 6b 28			ld a, (.dmark+1)  
285f 32 a7 fd			ld (debug_mark+1),a  
2862 3a 6c 28			ld a, (.dmark+2)  
2865 32 a8 fd			ld (debug_mark+2),a  
2868 18 03			jr .pastdmark  
286a ..			.dmark: db "2DU"  
286d f1			.pastdmark: pop af  
286e			endm  
# End of macro DMARK
286e					CALLMONITOR 
286e cd aa fd			call debug_vector  
2871				endm  
# End of macro CALLMONITOR
2871				endif 
2871				FORTH_DSP_VALUEHL 
2871 cd 0f 22			call macro_dsp_valuehl 
2874				endm 
# End of macro FORTH_DSP_VALUEHL
2874 e5				push hl      ; 2 
2875			 
2875				FORTH_DSP_POP 
2875 cd c7 22			call macro_forth_dsp_pop 
2878				endm 
# End of macro FORTH_DSP_POP
2878				 
2878				FORTH_DSP_VALUEHL 
2878 cd 0f 22			call macro_dsp_valuehl 
287b				endm 
# End of macro FORTH_DSP_VALUEHL
287b			;		push hl      ; 1 
287b			 
287b				FORTH_DSP_POP 
287b cd c7 22			call macro_forth_dsp_pop 
287e				endm 
# End of macro FORTH_DSP_POP
287e			 
287e			;		pop hl       ; 1 
287e d1				pop de       ; 2 
287f			 
287f cd 18 20			call forth_push_numhl 
2882 eb				ex de, hl 
2883 cd 18 20			call forth_push_numhl 
2886			 
2886				 
2886 eb				ex de, hl 
2887			 
2887 cd 18 20			call forth_push_numhl 
288a eb				ex de, hl 
288b cd 18 20			call forth_push_numhl 
288e			 
288e			 
288e				NEXTW 
288e c3 c5 23			jp macro_next 
2891				endm 
# End of macro NEXTW
2891			.DROP2: 
2891			CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2891 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2892 c0 28			dw .SWAP2            
2894 06				db 5 + 1 
2895 .. 00			db "2DROP",0              
289b				endm 
# End of macro CWHEAD
289b			; | 2DROP ( w w -- )    Double drop | DONE 
289b				if DEBUG_FORTH_WORDS_KEY 
289b					DMARK "2DR" 
289b f5				push af  
289c 3a b0 28			ld a, (.dmark)  
289f 32 a6 fd			ld (debug_mark),a  
28a2 3a b1 28			ld a, (.dmark+1)  
28a5 32 a7 fd			ld (debug_mark+1),a  
28a8 3a b2 28			ld a, (.dmark+2)  
28ab 32 a8 fd			ld (debug_mark+2),a  
28ae 18 03			jr .pastdmark  
28b0 ..			.dmark: db "2DR"  
28b3 f1			.pastdmark: pop af  
28b4			endm  
# End of macro DMARK
28b4					CALLMONITOR 
28b4 cd aa fd			call debug_vector  
28b7				endm  
# End of macro CALLMONITOR
28b7				endif 
28b7				FORTH_DSP_POP 
28b7 cd c7 22			call macro_forth_dsp_pop 
28ba				endm 
# End of macro FORTH_DSP_POP
28ba				FORTH_DSP_POP 
28ba cd c7 22			call macro_forth_dsp_pop 
28bd				endm 
# End of macro FORTH_DSP_POP
28bd				NEXTW 
28bd c3 c5 23			jp macro_next 
28c0				endm 
# End of macro NEXTW
28c0			.SWAP2: 
28c0			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
28c0 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
28c1 e9 28			dw .AT            
28c3 06				db 5 + 1 
28c4 .. 00			db "2SWAP",0              
28ca				endm 
# End of macro CWHEAD
28ca			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
28ca				if DEBUG_FORTH_WORDS_KEY 
28ca					DMARK "2SW" 
28ca f5				push af  
28cb 3a df 28			ld a, (.dmark)  
28ce 32 a6 fd			ld (debug_mark),a  
28d1 3a e0 28			ld a, (.dmark+1)  
28d4 32 a7 fd			ld (debug_mark+1),a  
28d7 3a e1 28			ld a, (.dmark+2)  
28da 32 a8 fd			ld (debug_mark+2),a  
28dd 18 03			jr .pastdmark  
28df ..			.dmark: db "2SW"  
28e2 f1			.pastdmark: pop af  
28e3			endm  
# End of macro DMARK
28e3					CALLMONITOR 
28e3 cd aa fd			call debug_vector  
28e6				endm  
# End of macro CALLMONITOR
28e6				endif 
28e6			; TODO Use os stack swap memory 
28e6				NEXTW 
28e6 c3 c5 23			jp macro_next 
28e9				endm 
# End of macro NEXTW
28e9			.AT: 
28e9			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
28e9 1f				db WORD_SYS_CORE+OPCODE_AT             
28ea 1b 29			dw .CAT            
28ec 02				db 1 + 1 
28ed .. 00			db "@",0              
28ef				endm 
# End of macro CWHEAD
28ef			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
28ef			 
28ef				if DEBUG_FORTH_WORDS_KEY 
28ef					DMARK "AT." 
28ef f5				push af  
28f0 3a 04 29			ld a, (.dmark)  
28f3 32 a6 fd			ld (debug_mark),a  
28f6 3a 05 29			ld a, (.dmark+1)  
28f9 32 a7 fd			ld (debug_mark+1),a  
28fc 3a 06 29			ld a, (.dmark+2)  
28ff 32 a8 fd			ld (debug_mark+2),a  
2902 18 03			jr .pastdmark  
2904 ..			.dmark: db "AT."  
2907 f1			.pastdmark: pop af  
2908			endm  
# End of macro DMARK
2908					CALLMONITOR 
2908 cd aa fd			call debug_vector  
290b				endm  
# End of macro CALLMONITOR
290b				endif 
290b			.getbyteat:	 
290b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
290b cd 0f 22			call macro_dsp_valuehl 
290e				endm 
# End of macro FORTH_DSP_VALUEHL
290e				 
290e			;		push hl 
290e			 
290e				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
290e cd c7 22			call macro_forth_dsp_pop 
2911				endm 
# End of macro FORTH_DSP_POP
2911			 
2911			;		pop hl 
2911			 
2911 7e				ld a, (hl) 
2912			 
2912 6f				ld l, a 
2913 26 00			ld h, 0 
2915 cd 18 20			call forth_push_numhl 
2918			 
2918				NEXTW 
2918 c3 c5 23			jp macro_next 
291b				endm 
# End of macro NEXTW
291b			.CAT: 
291b			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
291b 20				db WORD_SYS_CORE+OPCODE_CAT             
291c 44 29			dw .BANG            
291e 03				db 2 + 1 
291f .. 00			db "C@",0              
2922				endm 
# End of macro CWHEAD
2922			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2922				if DEBUG_FORTH_WORDS_KEY 
2922					DMARK "CAA" 
2922 f5				push af  
2923 3a 37 29			ld a, (.dmark)  
2926 32 a6 fd			ld (debug_mark),a  
2929 3a 38 29			ld a, (.dmark+1)  
292c 32 a7 fd			ld (debug_mark+1),a  
292f 3a 39 29			ld a, (.dmark+2)  
2932 32 a8 fd			ld (debug_mark+2),a  
2935 18 03			jr .pastdmark  
2937 ..			.dmark: db "CAA"  
293a f1			.pastdmark: pop af  
293b			endm  
# End of macro DMARK
293b					CALLMONITOR 
293b cd aa fd			call debug_vector  
293e				endm  
# End of macro CALLMONITOR
293e				endif 
293e c3 0b 29			jp .getbyteat 
2941				NEXTW 
2941 c3 c5 23			jp macro_next 
2944				endm 
# End of macro NEXTW
2944			.BANG: 
2944			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2944 21				db WORD_SYS_CORE+OPCODE_BANG             
2945 7a 29			dw .CBANG            
2947 02				db 1 + 1 
2948 .. 00			db "!",0              
294a				endm 
# End of macro CWHEAD
294a			; | ! ( x w -- ) Store x at address w      | DONE 
294a				if DEBUG_FORTH_WORDS_KEY 
294a					DMARK "BNG" 
294a f5				push af  
294b 3a 5f 29			ld a, (.dmark)  
294e 32 a6 fd			ld (debug_mark),a  
2951 3a 60 29			ld a, (.dmark+1)  
2954 32 a7 fd			ld (debug_mark+1),a  
2957 3a 61 29			ld a, (.dmark+2)  
295a 32 a8 fd			ld (debug_mark+2),a  
295d 18 03			jr .pastdmark  
295f ..			.dmark: db "BNG"  
2962 f1			.pastdmark: pop af  
2963			endm  
# End of macro DMARK
2963					CALLMONITOR 
2963 cd aa fd			call debug_vector  
2966				endm  
# End of macro CALLMONITOR
2966				endif 
2966			 
2966			.storebyteat:		 
2966				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2966 cd 0f 22			call macro_dsp_valuehl 
2969				endm 
# End of macro FORTH_DSP_VALUEHL
2969				 
2969 e5				push hl 
296a			 
296a				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
296a cd c7 22			call macro_forth_dsp_pop 
296d				endm 
# End of macro FORTH_DSP_POP
296d			 
296d				; get byte to poke 
296d			 
296d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
296d cd 0f 22			call macro_dsp_valuehl 
2970				endm 
# End of macro FORTH_DSP_VALUEHL
2970 e5				push hl 
2971			 
2971			 
2971				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2971 cd c7 22			call macro_forth_dsp_pop 
2974				endm 
# End of macro FORTH_DSP_POP
2974			 
2974			 
2974 d1				pop de 
2975 e1				pop hl 
2976			 
2976 73				ld (hl),e 
2977			 
2977			 
2977				NEXTW 
2977 c3 c5 23			jp macro_next 
297a				endm 
# End of macro NEXTW
297a			.CBANG: 
297a			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
297a 22				db WORD_SYS_CORE+OPCODE_CBANG             
297b a3 29			dw .SCALL            
297d 03				db 2 + 1 
297e .. 00			db "C!",0              
2981				endm 
# End of macro CWHEAD
2981			; | C!  ( x w -- ) Store x at address w  | DONE 
2981				if DEBUG_FORTH_WORDS_KEY 
2981					DMARK "CBA" 
2981 f5				push af  
2982 3a 96 29			ld a, (.dmark)  
2985 32 a6 fd			ld (debug_mark),a  
2988 3a 97 29			ld a, (.dmark+1)  
298b 32 a7 fd			ld (debug_mark+1),a  
298e 3a 98 29			ld a, (.dmark+2)  
2991 32 a8 fd			ld (debug_mark+2),a  
2994 18 03			jr .pastdmark  
2996 ..			.dmark: db "CBA"  
2999 f1			.pastdmark: pop af  
299a			endm  
# End of macro DMARK
299a					CALLMONITOR 
299a cd aa fd			call debug_vector  
299d				endm  
# End of macro CALLMONITOR
299d				endif 
299d c3 66 29			jp .storebyteat 
29a0				NEXTW 
29a0 c3 c5 23			jp macro_next 
29a3				endm 
# End of macro NEXTW
29a3			.SCALL: 
29a3			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
29a3 23				db WORD_SYS_CORE+OPCODE_SCALL             
29a4 d7 29			dw .DEPTH            
29a6 05				db 4 + 1 
29a7 .. 00			db "CALL",0              
29ac				endm 
# End of macro CWHEAD
29ac			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
29ac				if DEBUG_FORTH_WORDS_KEY 
29ac					DMARK "CLL" 
29ac f5				push af  
29ad 3a c1 29			ld a, (.dmark)  
29b0 32 a6 fd			ld (debug_mark),a  
29b3 3a c2 29			ld a, (.dmark+1)  
29b6 32 a7 fd			ld (debug_mark+1),a  
29b9 3a c3 29			ld a, (.dmark+2)  
29bc 32 a8 fd			ld (debug_mark+2),a  
29bf 18 03			jr .pastdmark  
29c1 ..			.dmark: db "CLL"  
29c4 f1			.pastdmark: pop af  
29c5			endm  
# End of macro DMARK
29c5					CALLMONITOR 
29c5 cd aa fd			call debug_vector  
29c8				endm  
# End of macro CALLMONITOR
29c8				endif 
29c8			 
29c8				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29c8 cd 0f 22			call macro_dsp_valuehl 
29cb				endm 
# End of macro FORTH_DSP_VALUEHL
29cb			 
29cb			;		push hl 
29cb			 
29cb				; destroy value TOS 
29cb			 
29cb				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29cb cd c7 22			call macro_forth_dsp_pop 
29ce				endm 
# End of macro FORTH_DSP_POP
29ce			 
29ce					 
29ce			;		pop hl 
29ce			 
29ce				; how to do a call with hl???? save SP? 
29ce cd 69 23			call forth_call_hl 
29d1			 
29d1			 
29d1				; TODO push value back onto stack for another op etc 
29d1			 
29d1 cd 18 20			call forth_push_numhl 
29d4				NEXTW 
29d4 c3 c5 23			jp macro_next 
29d7				endm 
# End of macro NEXTW
29d7			.DEPTH: 
29d7			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
29d7 24				db WORD_SYS_CORE+OPCODE_DEPTH             
29d8 14 2a			dw .OVER            
29da 06				db 5 + 1 
29db .. 00			db "DEPTH",0              
29e1				endm 
# End of macro CWHEAD
29e1			; | DEPTH ( -- u ) Push count of stack | DONE 
29e1				; take current TOS and remove from base value div by two to get count 
29e1				if DEBUG_FORTH_WORDS_KEY 
29e1					DMARK "DEP" 
29e1 f5				push af  
29e2 3a f6 29			ld a, (.dmark)  
29e5 32 a6 fd			ld (debug_mark),a  
29e8 3a f7 29			ld a, (.dmark+1)  
29eb 32 a7 fd			ld (debug_mark+1),a  
29ee 3a f8 29			ld a, (.dmark+2)  
29f1 32 a8 fd			ld (debug_mark+2),a  
29f4 18 03			jr .pastdmark  
29f6 ..			.dmark: db "DEP"  
29f9 f1			.pastdmark: pop af  
29fa			endm  
# End of macro DMARK
29fa					CALLMONITOR 
29fa cd aa fd			call debug_vector  
29fd				endm  
# End of macro CALLMONITOR
29fd				endif 
29fd			 
29fd			 
29fd 2a 29 f9		ld hl, (cli_data_sp) 
2a00 11 63 f6		ld de, cli_data_stack 
2a03 ed 52		sbc hl,de 
2a05			 
2a05			; div by size of stack item 
2a05			 
2a05 5d			ld e,l 
2a06 0e 03		ld c, 3 
2a08 cd 5f 0f		call Div8 
2a0b			 
2a0b 6f			ld l,a 
2a0c 26 00		ld h,0 
2a0e			 
2a0e			;srl h 
2a0e			;rr l 
2a0e			 
2a0e cd 18 20			call forth_push_numhl 
2a11				NEXTW 
2a11 c3 c5 23			jp macro_next 
2a14				endm 
# End of macro NEXTW
2a14			.OVER: 
2a14			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2a14 42				db WORD_SYS_CORE+46             
2a15 5b 2a			dw .PAUSE            
2a17 05				db 4 + 1 
2a18 .. 00			db "OVER",0              
2a1d				endm 
# End of macro CWHEAD
2a1d			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2a1d				if DEBUG_FORTH_WORDS_KEY 
2a1d					DMARK "OVR" 
2a1d f5				push af  
2a1e 3a 32 2a			ld a, (.dmark)  
2a21 32 a6 fd			ld (debug_mark),a  
2a24 3a 33 2a			ld a, (.dmark+1)  
2a27 32 a7 fd			ld (debug_mark+1),a  
2a2a 3a 34 2a			ld a, (.dmark+2)  
2a2d 32 a8 fd			ld (debug_mark+2),a  
2a30 18 03			jr .pastdmark  
2a32 ..			.dmark: db "OVR"  
2a35 f1			.pastdmark: pop af  
2a36			endm  
# End of macro DMARK
2a36					CALLMONITOR 
2a36 cd aa fd			call debug_vector  
2a39				endm  
# End of macro CALLMONITOR
2a39				endif 
2a39			 
2a39			; TODO Use os stack swap memory 
2a39				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a39 cd 0f 22			call macro_dsp_valuehl 
2a3c				endm 
# End of macro FORTH_DSP_VALUEHL
2a3c e5				push hl    ; n2 
2a3d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a3d cd c7 22			call macro_forth_dsp_pop 
2a40				endm 
# End of macro FORTH_DSP_POP
2a40			 
2a40				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a40 cd 0f 22			call macro_dsp_valuehl 
2a43				endm 
# End of macro FORTH_DSP_VALUEHL
2a43 e5				push hl    ; n1 
2a44				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a44 cd c7 22			call macro_forth_dsp_pop 
2a47				endm 
# End of macro FORTH_DSP_POP
2a47			 
2a47 d1				pop de     ; n1 
2a48 e1				pop hl     ; n2 
2a49			 
2a49 d5				push de 
2a4a e5				push hl 
2a4b d5				push de 
2a4c			 
2a4c				; push back  
2a4c			 
2a4c e1				pop hl 
2a4d cd 18 20			call forth_push_numhl 
2a50 e1				pop hl 
2a51 cd 18 20			call forth_push_numhl 
2a54 e1				pop hl 
2a55 cd 18 20			call forth_push_numhl 
2a58				NEXTW 
2a58 c3 c5 23			jp macro_next 
2a5b				endm 
# End of macro NEXTW
2a5b			 
2a5b			.PAUSE: 
2a5b			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2a5b 43				db WORD_SYS_CORE+47             
2a5c 90 2a			dw .PAUSES            
2a5e 08				db 7 + 1 
2a5f .. 00			db "PAUSEMS",0              
2a67				endm 
# End of macro CWHEAD
2a67			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2a67				if DEBUG_FORTH_WORDS_KEY 
2a67					DMARK "PMS" 
2a67 f5				push af  
2a68 3a 7c 2a			ld a, (.dmark)  
2a6b 32 a6 fd			ld (debug_mark),a  
2a6e 3a 7d 2a			ld a, (.dmark+1)  
2a71 32 a7 fd			ld (debug_mark+1),a  
2a74 3a 7e 2a			ld a, (.dmark+2)  
2a77 32 a8 fd			ld (debug_mark+2),a  
2a7a 18 03			jr .pastdmark  
2a7c ..			.dmark: db "PMS"  
2a7f f1			.pastdmark: pop af  
2a80			endm  
# End of macro DMARK
2a80					CALLMONITOR 
2a80 cd aa fd			call debug_vector  
2a83				endm  
# End of macro CALLMONITOR
2a83				endif 
2a83				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a83 cd 0f 22			call macro_dsp_valuehl 
2a86				endm 
# End of macro FORTH_DSP_VALUEHL
2a86			;		push hl    ; n2 
2a86				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a86 cd c7 22			call macro_forth_dsp_pop 
2a89				endm 
# End of macro FORTH_DSP_POP
2a89			;		pop hl 
2a89			 
2a89 7d				ld a, l 
2a8a cd c3 0c			call aDelayInMS 
2a8d			       NEXTW 
2a8d c3 c5 23			jp macro_next 
2a90				endm 
# End of macro NEXTW
2a90			.PAUSES:  
2a90			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2a90 44				db WORD_SYS_CORE+48             
2a91 ff 2a			dw .ROT            
2a93 06				db 5 + 1 
2a94 .. 00			db "PAUSE",0              
2a9a				endm 
# End of macro CWHEAD
2a9a			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2a9a				if DEBUG_FORTH_WORDS_KEY 
2a9a					DMARK "PAU" 
2a9a f5				push af  
2a9b 3a af 2a			ld a, (.dmark)  
2a9e 32 a6 fd			ld (debug_mark),a  
2aa1 3a b0 2a			ld a, (.dmark+1)  
2aa4 32 a7 fd			ld (debug_mark+1),a  
2aa7 3a b1 2a			ld a, (.dmark+2)  
2aaa 32 a8 fd			ld (debug_mark+2),a  
2aad 18 03			jr .pastdmark  
2aaf ..			.dmark: db "PAU"  
2ab2 f1			.pastdmark: pop af  
2ab3			endm  
# End of macro DMARK
2ab3					CALLMONITOR 
2ab3 cd aa fd			call debug_vector  
2ab6				endm  
# End of macro CALLMONITOR
2ab6				endif 
2ab6				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ab6 cd 0f 22			call macro_dsp_valuehl 
2ab9				endm 
# End of macro FORTH_DSP_VALUEHL
2ab9			;		push hl    ; n2 
2ab9				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ab9 cd c7 22			call macro_forth_dsp_pop 
2abc				endm 
# End of macro FORTH_DSP_POP
2abc			;		pop hl 
2abc 45				ld b, l 
2abd				if DEBUG_FORTH_WORDS 
2abd					DMARK "PAU" 
2abd f5				push af  
2abe 3a d2 2a			ld a, (.dmark)  
2ac1 32 a6 fd			ld (debug_mark),a  
2ac4 3a d3 2a			ld a, (.dmark+1)  
2ac7 32 a7 fd			ld (debug_mark+1),a  
2aca 3a d4 2a			ld a, (.dmark+2)  
2acd 32 a8 fd			ld (debug_mark+2),a  
2ad0 18 03			jr .pastdmark  
2ad2 ..			.dmark: db "PAU"  
2ad5 f1			.pastdmark: pop af  
2ad6			endm  
# End of macro DMARK
2ad6					CALLMONITOR 
2ad6 cd aa fd			call debug_vector  
2ad9				endm  
# End of macro CALLMONITOR
2ad9				endif 
2ad9 c5			.pauses1:	push bc 
2ada cd de 0c			call delay1s 
2add c1				pop bc 
2ade				if DEBUG_FORTH_WORDS 
2ade					DMARK "PA1" 
2ade f5				push af  
2adf 3a f3 2a			ld a, (.dmark)  
2ae2 32 a6 fd			ld (debug_mark),a  
2ae5 3a f4 2a			ld a, (.dmark+1)  
2ae8 32 a7 fd			ld (debug_mark+1),a  
2aeb 3a f5 2a			ld a, (.dmark+2)  
2aee 32 a8 fd			ld (debug_mark+2),a  
2af1 18 03			jr .pastdmark  
2af3 ..			.dmark: db "PA1"  
2af6 f1			.pastdmark: pop af  
2af7			endm  
# End of macro DMARK
2af7					CALLMONITOR 
2af7 cd aa fd			call debug_vector  
2afa				endm  
# End of macro CALLMONITOR
2afa				endif 
2afa 10 dd			djnz .pauses1 
2afc			 
2afc			       NEXTW 
2afc c3 c5 23			jp macro_next 
2aff				endm 
# End of macro NEXTW
2aff			.ROT: 
2aff			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2aff 45				db WORD_SYS_CORE+49             
2b00 4d 2b			dw .UWORDS            
2b02 04				db 3 + 1 
2b03 .. 00			db "ROT",0              
2b07				endm 
# End of macro CWHEAD
2b07			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2b07				if DEBUG_FORTH_WORDS_KEY 
2b07					DMARK "ROT" 
2b07 f5				push af  
2b08 3a 1c 2b			ld a, (.dmark)  
2b0b 32 a6 fd			ld (debug_mark),a  
2b0e 3a 1d 2b			ld a, (.dmark+1)  
2b11 32 a7 fd			ld (debug_mark+1),a  
2b14 3a 1e 2b			ld a, (.dmark+2)  
2b17 32 a8 fd			ld (debug_mark+2),a  
2b1a 18 03			jr .pastdmark  
2b1c ..			.dmark: db "ROT"  
2b1f f1			.pastdmark: pop af  
2b20			endm  
# End of macro DMARK
2b20					CALLMONITOR 
2b20 cd aa fd			call debug_vector  
2b23				endm  
# End of macro CALLMONITOR
2b23				endif 
2b23			 
2b23			; TODO Use os stack swap memory 
2b23				FORTH_DSP_VALUEHL 
2b23 cd 0f 22			call macro_dsp_valuehl 
2b26				endm 
# End of macro FORTH_DSP_VALUEHL
2b26 e5				push hl    ; u3  
2b27			 
2b27				FORTH_DSP_POP 
2b27 cd c7 22			call macro_forth_dsp_pop 
2b2a				endm 
# End of macro FORTH_DSP_POP
2b2a			 
2b2a				FORTH_DSP_VALUEHL 
2b2a cd 0f 22			call macro_dsp_valuehl 
2b2d				endm 
# End of macro FORTH_DSP_VALUEHL
2b2d e5				push hl     ; u2 
2b2e			 
2b2e				FORTH_DSP_POP 
2b2e cd c7 22			call macro_forth_dsp_pop 
2b31				endm 
# End of macro FORTH_DSP_POP
2b31			 
2b31				FORTH_DSP_VALUEHL 
2b31 cd 0f 22			call macro_dsp_valuehl 
2b34				endm 
# End of macro FORTH_DSP_VALUEHL
2b34 e5				push hl     ; u1 
2b35			 
2b35				FORTH_DSP_POP 
2b35 cd c7 22			call macro_forth_dsp_pop 
2b38				endm 
# End of macro FORTH_DSP_POP
2b38			 
2b38 c1				pop bc      ; u1 
2b39 e1				pop hl      ; u2 
2b3a d1				pop de      ; u3 
2b3b			 
2b3b			 
2b3b c5				push bc 
2b3c d5				push de 
2b3d e5				push hl 
2b3e			 
2b3e			 
2b3e e1				pop hl 
2b3f cd 18 20			call forth_push_numhl 
2b42			 
2b42 e1				pop hl 
2b43 cd 18 20			call forth_push_numhl 
2b46			 
2b46 e1				pop hl 
2b47 cd 18 20			call forth_push_numhl 
2b4a				 
2b4a			 
2b4a			 
2b4a			 
2b4a			 
2b4a			 
2b4a			       NEXTW 
2b4a c3 c5 23			jp macro_next 
2b4d				endm 
# End of macro NEXTW
2b4d			 
2b4d			.UWORDS: 
2b4d			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2b4d 50				db WORD_SYS_CORE+60             
2b4e 0f 2c			dw .BP            
2b50 07				db 6 + 1 
2b51 .. 00			db "UWORDS",0              
2b58				endm 
# End of macro CWHEAD
2b58			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2b58			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2b58			; | | Following the count are the individual words. 
2b58			; | | 
2b58			; | | e.g. UWORDS 
2b58			; | | BOX DIRLIST 2 
2b58			; | |  
2b58			; | | Can be used to save the words to storage via: 
2b58			; | | UWORDS $01 DO $01 APPEND LOOP 
2b58			if DEBUG_FORTH_WORDS_KEY 
2b58				DMARK "UWR" 
2b58 f5				push af  
2b59 3a 6d 2b			ld a, (.dmark)  
2b5c 32 a6 fd			ld (debug_mark),a  
2b5f 3a 6e 2b			ld a, (.dmark+1)  
2b62 32 a7 fd			ld (debug_mark+1),a  
2b65 3a 6f 2b			ld a, (.dmark+2)  
2b68 32 a8 fd			ld (debug_mark+2),a  
2b6b 18 03			jr .pastdmark  
2b6d ..			.dmark: db "UWR"  
2b70 f1			.pastdmark: pop af  
2b71			endm  
# End of macro DMARK
2b71				CALLMONITOR 
2b71 cd aa fd			call debug_vector  
2b74				endm  
# End of macro CALLMONITOR
2b74			endif 
2b74 21 00 80			ld hl, baseram 
2b77				;ld hl, baseusermem 
2b77 01 00 00			ld bc, 0    ; start a counter 
2b7a			 
2b7a			; skip dict stub 
2b7a			 
2b7a cd 16 25			call forth_tok_next 
2b7d			 
2b7d			 
2b7d			; while we have words to look for 
2b7d			 
2b7d 7e			.douscan:	ld a, (hl)      
2b7e			if DEBUG_FORTH_WORDS 
2b7e				DMARK "UWs" 
2b7e f5				push af  
2b7f 3a 93 2b			ld a, (.dmark)  
2b82 32 a6 fd			ld (debug_mark),a  
2b85 3a 94 2b			ld a, (.dmark+1)  
2b88 32 a7 fd			ld (debug_mark+1),a  
2b8b 3a 95 2b			ld a, (.dmark+2)  
2b8e 32 a8 fd			ld (debug_mark+2),a  
2b91 18 03			jr .pastdmark  
2b93 ..			.dmark: db "UWs"  
2b96 f1			.pastdmark: pop af  
2b97			endm  
# End of macro DMARK
2b97				CALLMONITOR 
2b97 cd aa fd			call debug_vector  
2b9a				endm  
# End of macro CALLMONITOR
2b9a			endif 
2b9a fe 00			cp WORD_SYS_END 
2b9c 28 4d			jr z, .udone 
2b9e fe 01			cp WORD_SYS_UWORD 
2ba0 20 44			jr nz, .nuword 
2ba2			 
2ba2			if DEBUG_FORTH_WORDS 
2ba2				DMARK "UWu" 
2ba2 f5				push af  
2ba3 3a b7 2b			ld a, (.dmark)  
2ba6 32 a6 fd			ld (debug_mark),a  
2ba9 3a b8 2b			ld a, (.dmark+1)  
2bac 32 a7 fd			ld (debug_mark+1),a  
2baf 3a b9 2b			ld a, (.dmark+2)  
2bb2 32 a8 fd			ld (debug_mark+2),a  
2bb5 18 03			jr .pastdmark  
2bb7 ..			.dmark: db "UWu"  
2bba f1			.pastdmark: pop af  
2bbb			endm  
# End of macro DMARK
2bbb				CALLMONITOR 
2bbb cd aa fd			call debug_vector  
2bbe				endm  
# End of macro CALLMONITOR
2bbe			endif 
2bbe				; we have a uword so push its name to the stack 
2bbe			 
2bbe e5				push hl  ; save so we can move to next dict block 
2bbf			 
2bbf				; skip opcode 
2bbf 23				inc hl  
2bc0				; skip next ptr 
2bc0 23				inc hl  
2bc1 23				inc hl 
2bc2				; skip len 
2bc2 23				inc hl 
2bc3			if DEBUG_FORTH_WORDS 
2bc3				DMARK "UWt" 
2bc3 f5				push af  
2bc4 3a d8 2b			ld a, (.dmark)  
2bc7 32 a6 fd			ld (debug_mark),a  
2bca 3a d9 2b			ld a, (.dmark+1)  
2bcd 32 a7 fd			ld (debug_mark+1),a  
2bd0 3a da 2b			ld a, (.dmark+2)  
2bd3 32 a8 fd			ld (debug_mark+2),a  
2bd6 18 03			jr .pastdmark  
2bd8 ..			.dmark: db "UWt"  
2bdb f1			.pastdmark: pop af  
2bdc			endm  
# End of macro DMARK
2bdc				CALLMONITOR 
2bdc cd aa fd			call debug_vector  
2bdf				endm  
# End of macro CALLMONITOR
2bdf			endif 
2bdf 03				inc bc 
2be0			 
2be0 c5				push bc 
2be1 cd 86 20			call forth_push_str 
2be4 c1				pop bc 
2be5			 
2be5 e1				pop hl 	 
2be6			 
2be6 cd 16 25		.nuword:	call forth_tok_next 
2be9 18 92			jr .douscan  
2beb			 
2beb			.udone:		 ; push count of uwords found 
2beb c5				push bc 
2bec e1				pop hl 
2bed			 
2bed			if DEBUG_FORTH_WORDS 
2bed				DMARK "UWc" 
2bed f5				push af  
2bee 3a 02 2c			ld a, (.dmark)  
2bf1 32 a6 fd			ld (debug_mark),a  
2bf4 3a 03 2c			ld a, (.dmark+1)  
2bf7 32 a7 fd			ld (debug_mark+1),a  
2bfa 3a 04 2c			ld a, (.dmark+2)  
2bfd 32 a8 fd			ld (debug_mark+2),a  
2c00 18 03			jr .pastdmark  
2c02 ..			.dmark: db "UWc"  
2c05 f1			.pastdmark: pop af  
2c06			endm  
# End of macro DMARK
2c06				CALLMONITOR 
2c06 cd aa fd			call debug_vector  
2c09				endm  
# End of macro CALLMONITOR
2c09			endif 
2c09 cd 18 20			call forth_push_numhl 
2c0c			 
2c0c			 
2c0c			       NEXTW 
2c0c c3 c5 23			jp macro_next 
2c0f				endm 
# End of macro NEXTW
2c0f			 
2c0f			.BP: 
2c0f			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2c0f 54				db WORD_SYS_CORE+64             
2c10 49 2c			dw .MONITOR            
2c12 03				db 2 + 1 
2c13 .. 00			db "BP",0              
2c16				endm 
# End of macro CWHEAD
2c16			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2c16			; | | $00 Will enable the break points within specific code paths 
2c16			; | | $01 Will disable break points 
2c16			; | |  
2c16			; | | By default break points are off. Either the above can be used to enable them 
2c16			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2c16			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2c16			; | | can disable break points. Exiting will then continue boot process. 
2c16				; get byte count 
2c16				if DEBUG_FORTH_WORDS_KEY 
2c16					DMARK "BP." 
2c16 f5				push af  
2c17 3a 2b 2c			ld a, (.dmark)  
2c1a 32 a6 fd			ld (debug_mark),a  
2c1d 3a 2c 2c			ld a, (.dmark+1)  
2c20 32 a7 fd			ld (debug_mark+1),a  
2c23 3a 2d 2c			ld a, (.dmark+2)  
2c26 32 a8 fd			ld (debug_mark+2),a  
2c29 18 03			jr .pastdmark  
2c2b ..			.dmark: db "BP."  
2c2e f1			.pastdmark: pop af  
2c2f			endm  
# End of macro DMARK
2c2f					CALLMONITOR 
2c2f cd aa fd			call debug_vector  
2c32				endm  
# End of macro CALLMONITOR
2c32				endif 
2c32			 
2c32				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c32 cd 0f 22			call macro_dsp_valuehl 
2c35				endm 
# End of macro FORTH_DSP_VALUEHL
2c35			 
2c35			;		push hl 
2c35			 
2c35				; destroy value TOS 
2c35			 
2c35				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c35 cd c7 22			call macro_forth_dsp_pop 
2c38				endm 
# End of macro FORTH_DSP_POP
2c38			 
2c38			;		pop hl 
2c38			 
2c38 3e 00			ld a,0 
2c3a bd				cp l 
2c3b 28 06			jr z, .bpset 
2c3d			;		ld a, '*' 
2c3d cd 56 19			call bp_off 
2c40				NEXTW 
2c40 c3 c5 23			jp macro_next 
2c43				endm 
# End of macro NEXTW
2c43			 
2c43			.bpset:	 
2c43				;	ld (os_view_disable), a 
2c43 cd 4a 19			call bp_on 
2c46			 
2c46			 
2c46				NEXTW 
2c46 c3 c5 23			jp macro_next 
2c49				endm 
# End of macro NEXTW
2c49			 
2c49			 
2c49			.MONITOR: 
2c49			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2c49 55				db WORD_SYS_CORE+65             
2c4a 7a 2c			dw .MALLOC            
2c4c 08				db 7 + 1 
2c4d .. 00			db "MONITOR",0              
2c55				endm 
# End of macro CWHEAD
2c55			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2c55			; | | At start the current various registers will be displayed with contents. 
2c55			; | | Top right corner will show the most recent debug marker seen. 
2c55			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2c55			; | | and the return stack pointer (RSP). 
2c55			; | | Pressing: 
2c55			; | |    1 - Initial screen 
2c55			; | |    2 - Display a data dump of HL 
2c55			; | |    3 - Display a data dump of DE 
2c55			; | |    4 - Display a data dump of BC 
2c55			; | |    5 - Display a data dump of HL 
2c55			; | |    6 - Display a data dump of DSP 
2c55			; | |    7 - Display a data dump of RSP 
2c55			; | |    8 - Display a data dump of what is at DSP 
2c55			; | |    9 - Display a data dump of what is at RSP 
2c55			; | |    0 - Exit monitor and continue running. This will also enable break points 
2c55			; | |    * - Disable break points 
2c55			; | |    # - Enter traditional monitor mode 
2c55			; | | 
2c55			; | | Monitor Mode 
2c55			; | | ------------ 
2c55			; | | A prompt of '>' will be shown for various commands: 
2c55			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2c55			; | |    C - Continue display a data dump from the last set address 
2c55			; | |    M xxxx - Set start of memory edit at address xx 
2c55			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2c55			; | |    G xxxx - Exec code at specific address 
2c55			; | |    Q - Return to previous 
2c55				if DEBUG_FORTH_WORDS_KEY 
2c55					DMARK "MON" 
2c55 f5				push af  
2c56 3a 6a 2c			ld a, (.dmark)  
2c59 32 a6 fd			ld (debug_mark),a  
2c5c 3a 6b 2c			ld a, (.dmark+1)  
2c5f 32 a7 fd			ld (debug_mark+1),a  
2c62 3a 6c 2c			ld a, (.dmark+2)  
2c65 32 a8 fd			ld (debug_mark+2),a  
2c68 18 03			jr .pastdmark  
2c6a ..			.dmark: db "MON"  
2c6d f1			.pastdmark: pop af  
2c6e			endm  
# End of macro DMARK
2c6e					CALLMONITOR 
2c6e cd aa fd			call debug_vector  
2c71				endm  
# End of macro CALLMONITOR
2c71				endif 
2c71			;		ld a, 0 
2c71			;		ld (os_view_disable), a 
2c71 cd 4a 19			call bp_on 
2c74			 
2c74				CALLMONITOR 
2c74 cd aa fd			call debug_vector  
2c77				endm  
# End of macro CALLMONITOR
2c77			 
2c77			;	call monitor 
2c77			 
2c77				NEXTW 
2c77 c3 c5 23			jp macro_next 
2c7a				endm 
# End of macro NEXTW
2c7a			 
2c7a			 
2c7a			.MALLOC: 
2c7a			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2c7a 56				db WORD_SYS_CORE+66             
2c7b a3 2c			dw .MALLOC2            
2c7d 06				db 5 + 1 
2c7e .. 00			db "ALLOT",0              
2c84				endm 
# End of macro CWHEAD
2c84			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2c84				if DEBUG_FORTH_WORDS_KEY 
2c84					DMARK "ALL" 
2c84 f5				push af  
2c85 3a 99 2c			ld a, (.dmark)  
2c88 32 a6 fd			ld (debug_mark),a  
2c8b 3a 9a 2c			ld a, (.dmark+1)  
2c8e 32 a7 fd			ld (debug_mark+1),a  
2c91 3a 9b 2c			ld a, (.dmark+2)  
2c94 32 a8 fd			ld (debug_mark+2),a  
2c97 18 03			jr .pastdmark  
2c99 ..			.dmark: db "ALL"  
2c9c f1			.pastdmark: pop af  
2c9d			endm  
# End of macro DMARK
2c9d					CALLMONITOR 
2c9d cd aa fd			call debug_vector  
2ca0				endm  
# End of macro CALLMONITOR
2ca0				endif 
2ca0 c3 ca 2c			jp .mallocc 
2ca3			.MALLOC2: 
2ca3			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2ca3 56				db WORD_SYS_CORE+66             
2ca4 e1 2c			dw .FREE            
2ca6 07				db 6 + 1 
2ca7 .. 00			db "MALLOC",0              
2cae				endm 
# End of macro CWHEAD
2cae			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2cae				; get byte count 
2cae				if DEBUG_FORTH_WORDS_KEY 
2cae					DMARK "MAL" 
2cae f5				push af  
2caf 3a c3 2c			ld a, (.dmark)  
2cb2 32 a6 fd			ld (debug_mark),a  
2cb5 3a c4 2c			ld a, (.dmark+1)  
2cb8 32 a7 fd			ld (debug_mark+1),a  
2cbb 3a c5 2c			ld a, (.dmark+2)  
2cbe 32 a8 fd			ld (debug_mark+2),a  
2cc1 18 03			jr .pastdmark  
2cc3 ..			.dmark: db "MAL"  
2cc6 f1			.pastdmark: pop af  
2cc7			endm  
# End of macro DMARK
2cc7					CALLMONITOR 
2cc7 cd aa fd			call debug_vector  
2cca				endm  
# End of macro CALLMONITOR
2cca				endif 
2cca			.mallocc: 
2cca				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2cca cd 0f 22			call macro_dsp_valuehl 
2ccd				endm 
# End of macro FORTH_DSP_VALUEHL
2ccd			 
2ccd			;		push hl 
2ccd			 
2ccd				; destroy value TOS 
2ccd			 
2ccd				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ccd cd c7 22			call macro_forth_dsp_pop 
2cd0				endm 
# End of macro FORTH_DSP_POP
2cd0			 
2cd0			;		pop hl 
2cd0 cd b7 13			call malloc 
2cd3			if DEBUG_FORTH_MALLOC_GUARD 
2cd3 f5				push af 
2cd4 cd f8 0f			call ishlzero 
2cd7			;		ld a, l 
2cd7			;		add h 
2cd7			;		cp 0 
2cd7 f1				pop af 
2cd8				 
2cd8 cc 98 5d			call z,malloc_error 
2cdb			endif 
2cdb			 
2cdb cd 18 20			call forth_push_numhl 
2cde				NEXTW 
2cde c3 c5 23			jp macro_next 
2ce1				endm 
# End of macro NEXTW
2ce1			 
2ce1			.FREE: 
2ce1			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2ce1 57				db WORD_SYS_CORE+67             
2ce2 12 2d			dw .LIST            
2ce4 05				db 4 + 1 
2ce5 .. 00			db "FREE",0              
2cea				endm 
# End of macro CWHEAD
2cea			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2cea				if DEBUG_FORTH_WORDS_KEY 
2cea					DMARK "FRE" 
2cea f5				push af  
2ceb 3a ff 2c			ld a, (.dmark)  
2cee 32 a6 fd			ld (debug_mark),a  
2cf1 3a 00 2d			ld a, (.dmark+1)  
2cf4 32 a7 fd			ld (debug_mark+1),a  
2cf7 3a 01 2d			ld a, (.dmark+2)  
2cfa 32 a8 fd			ld (debug_mark+2),a  
2cfd 18 03			jr .pastdmark  
2cff ..			.dmark: db "FRE"  
2d02 f1			.pastdmark: pop af  
2d03			endm  
# End of macro DMARK
2d03					CALLMONITOR 
2d03 cd aa fd			call debug_vector  
2d06				endm  
# End of macro CALLMONITOR
2d06				endif 
2d06				; get address 
2d06			 
2d06				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d06 cd 0f 22			call macro_dsp_valuehl 
2d09				endm 
# End of macro FORTH_DSP_VALUEHL
2d09			 
2d09			;		push hl 
2d09			 
2d09				; destroy value TOS 
2d09			 
2d09				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d09 cd c7 22			call macro_forth_dsp_pop 
2d0c				endm 
# End of macro FORTH_DSP_POP
2d0c			 
2d0c			;		pop hl 
2d0c			if FORTH_ENABLE_MALLOCFREE 
2d0c cd 81 14			call free 
2d0f			endif 
2d0f				NEXTW 
2d0f c3 c5 23			jp macro_next 
2d12				endm 
# End of macro NEXTW
2d12			.LIST: 
2d12			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2d12 5c				db WORD_SYS_CORE+72             
2d13 02 2f			dw .FORGET            
2d15 05				db 4 + 1 
2d16 .. 00			db "LIST",0              
2d1b				endm 
# End of macro CWHEAD
2d1b			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2d1b			; | | The quoted word must be in upper case. 
2d1b			if DEBUG_FORTH_WORDS_KEY 
2d1b				DMARK "LST" 
2d1b f5				push af  
2d1c 3a 30 2d			ld a, (.dmark)  
2d1f 32 a6 fd			ld (debug_mark),a  
2d22 3a 31 2d			ld a, (.dmark+1)  
2d25 32 a7 fd			ld (debug_mark+1),a  
2d28 3a 32 2d			ld a, (.dmark+2)  
2d2b 32 a8 fd			ld (debug_mark+2),a  
2d2e 18 03			jr .pastdmark  
2d30 ..			.dmark: db "LST"  
2d33 f1			.pastdmark: pop af  
2d34			endm  
# End of macro DMARK
2d34				CALLMONITOR 
2d34 cd aa fd			call debug_vector  
2d37				endm  
# End of macro CALLMONITOR
2d37			endif 
2d37			 
2d37				FORTH_DSP_VALUEHL 
2d37 cd 0f 22			call macro_dsp_valuehl 
2d3a				endm 
# End of macro FORTH_DSP_VALUEHL
2d3a			 
2d3a e5				push hl 
2d3b				FORTH_DSP_POP 
2d3b cd c7 22			call macro_forth_dsp_pop 
2d3e				endm 
# End of macro FORTH_DSP_POP
2d3e c1				pop bc 
2d3f			 
2d3f			; Start format of scratch string 
2d3f			 
2d3f 21 fc f0			ld hl, scratch 
2d42			 
2d42 3e 3a			ld a, ':' 
2d44 77				ld (hl),a 
2d45 23				inc hl 
2d46 3e 20			ld a, ' ' 
2d48 77				ld (hl), a 
2d49			 
2d49				; Get ptr to the word we need to look up 
2d49			 
2d49			;		FORTH_DSP_VALUEHL 
2d49				;v5 FORTH_DSP_VALUE 
2d49			; TODO type check 
2d49			;		inc hl    ; Skip type check  
2d49			;		push hl 
2d49			;		ex de, hl    ; put into DE 
2d49			 
2d49			 
2d49 21 00 80			ld hl, baseram 
2d4c				;ld hl, baseusermem 
2d4c			 
2d4c e5			push hl   ; sacreifical push 
2d4d			 
2d4d			.ldouscanm: 
2d4d e1			pop hl 
2d4e			.ldouscan: 
2d4e			if DEBUG_FORTH_WORDS 
2d4e				DMARK "LSs" 
2d4e f5				push af  
2d4f 3a 63 2d			ld a, (.dmark)  
2d52 32 a6 fd			ld (debug_mark),a  
2d55 3a 64 2d			ld a, (.dmark+1)  
2d58 32 a7 fd			ld (debug_mark+1),a  
2d5b 3a 65 2d			ld a, (.dmark+2)  
2d5e 32 a8 fd			ld (debug_mark+2),a  
2d61 18 03			jr .pastdmark  
2d63 ..			.dmark: db "LSs"  
2d66 f1			.pastdmark: pop af  
2d67			endm  
# End of macro DMARK
2d67				CALLMONITOR 
2d67 cd aa fd			call debug_vector  
2d6a				endm  
# End of macro CALLMONITOR
2d6a			endif 
2d6a			; skip dict stub 
2d6a cd 16 25			call forth_tok_next 
2d6d			 
2d6d			 
2d6d			; while we have words to look for 
2d6d			 
2d6d 7e			ld a, (hl)      
2d6e			if DEBUG_FORTH_WORDS 
2d6e				DMARK "LSk" 
2d6e f5				push af  
2d6f 3a 83 2d			ld a, (.dmark)  
2d72 32 a6 fd			ld (debug_mark),a  
2d75 3a 84 2d			ld a, (.dmark+1)  
2d78 32 a7 fd			ld (debug_mark+1),a  
2d7b 3a 85 2d			ld a, (.dmark+2)  
2d7e 32 a8 fd			ld (debug_mark+2),a  
2d81 18 03			jr .pastdmark  
2d83 ..			.dmark: db "LSk"  
2d86 f1			.pastdmark: pop af  
2d87			endm  
# End of macro DMARK
2d87				CALLMONITOR 
2d87 cd aa fd			call debug_vector  
2d8a				endm  
# End of macro CALLMONITOR
2d8a			endif 
2d8a				;cp WORD_SYS_END 
2d8a				;jp z, .lunotfound 
2d8a			 
2d8a					; if we hit non uwords then gone too far 
2d8a fe 01				cp WORD_SYS_UWORD 
2d8c c2 be 2e				jp nz, .lunotfound 
2d8f			 
2d8f				if DEBUG_FORTH_WORDS 
2d8f					DMARK "LSu" 
2d8f f5				push af  
2d90 3a a4 2d			ld a, (.dmark)  
2d93 32 a6 fd			ld (debug_mark),a  
2d96 3a a5 2d			ld a, (.dmark+1)  
2d99 32 a7 fd			ld (debug_mark+1),a  
2d9c 3a a6 2d			ld a, (.dmark+2)  
2d9f 32 a8 fd			ld (debug_mark+2),a  
2da2 18 03			jr .pastdmark  
2da4 ..			.dmark: db "LSu"  
2da7 f1			.pastdmark: pop af  
2da8			endm  
# End of macro DMARK
2da8					CALLMONITOR 
2da8 cd aa fd			call debug_vector  
2dab				endm  
# End of macro CALLMONITOR
2dab				endif 
2dab			 
2dab					; found a uword but is it the one we want... 
2dab			 
2dab c5					push bc     ; uword to find is on bc 
2dac d1					pop de 
2dad			 
2dad e5					push hl  ; to save the ptr 
2dae			 
2dae					; skip opcode 
2dae 23					inc hl  
2daf					; skip next ptr 
2daf 23					inc hl  
2db0 23					inc hl 
2db1					; skip len 
2db1 23					inc hl 
2db2			 
2db2				if DEBUG_FORTH_WORDS 
2db2					DMARK "LSc" 
2db2 f5				push af  
2db3 3a c7 2d			ld a, (.dmark)  
2db6 32 a6 fd			ld (debug_mark),a  
2db9 3a c8 2d			ld a, (.dmark+1)  
2dbc 32 a7 fd			ld (debug_mark+1),a  
2dbf 3a c9 2d			ld a, (.dmark+2)  
2dc2 32 a8 fd			ld (debug_mark+2),a  
2dc5 18 03			jr .pastdmark  
2dc7 ..			.dmark: db "LSc"  
2dca f1			.pastdmark: pop af  
2dcb			endm  
# End of macro DMARK
2dcb					CALLMONITOR 
2dcb cd aa fd			call debug_vector  
2dce				endm  
# End of macro CALLMONITOR
2dce				endif 
2dce			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2dce			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2dce			; Nope that has gone the other way. It needs to be exact not on first zero 
2dce			;		call strcmp 
2dce c5					push bc 
2dcf cd 87 13				call StrictStrCmp 
2dd2 c1					pop bc 
2dd3 c2 4d 2d				jp nz, .ldouscanm 
2dd6				 
2dd6			 
2dd6			 
2dd6					; we have a uword so push its name to the stack 
2dd6			 
2dd6			;	   	push hl  ; save so we can move to next dict block 
2dd6 e1			pop hl 
2dd7			 
2dd7				if DEBUG_FORTH_WORDS 
2dd7					DMARK "LSm" 
2dd7 f5				push af  
2dd8 3a ec 2d			ld a, (.dmark)  
2ddb 32 a6 fd			ld (debug_mark),a  
2dde 3a ed 2d			ld a, (.dmark+1)  
2de1 32 a7 fd			ld (debug_mark+1),a  
2de4 3a ee 2d			ld a, (.dmark+2)  
2de7 32 a8 fd			ld (debug_mark+2),a  
2dea 18 03			jr .pastdmark  
2dec ..			.dmark: db "LSm"  
2def f1			.pastdmark: pop af  
2df0			endm  
# End of macro DMARK
2df0					CALLMONITOR 
2df0 cd aa fd			call debug_vector  
2df3				endm  
# End of macro CALLMONITOR
2df3				endif 
2df3			 
2df3					; skip opcode 
2df3 23					inc hl  
2df4					; skip next ptr 
2df4 23					inc hl  
2df5 23					inc hl 
2df6					; skip len 
2df6 7e					ld a, (hl)   ; save length to add 
2df7				if DEBUG_FORTH_WORDS 
2df7					DMARK "LS2" 
2df7 f5				push af  
2df8 3a 0c 2e			ld a, (.dmark)  
2dfb 32 a6 fd			ld (debug_mark),a  
2dfe 3a 0d 2e			ld a, (.dmark+1)  
2e01 32 a7 fd			ld (debug_mark+1),a  
2e04 3a 0e 2e			ld a, (.dmark+2)  
2e07 32 a8 fd			ld (debug_mark+2),a  
2e0a 18 03			jr .pastdmark  
2e0c ..			.dmark: db "LS2"  
2e0f f1			.pastdmark: pop af  
2e10			endm  
# End of macro DMARK
2e10					CALLMONITOR 
2e10 cd aa fd			call debug_vector  
2e13				endm  
# End of macro CALLMONITOR
2e13				endif 
2e13			 
2e13					; save this location 
2e13				 
2e13 e5					push hl 
2e14			 
2e14 23					inc hl 
2e15 11 fe f0				ld de, scratch+2 
2e18 4f					ld c, a 
2e19 06 00				ld b, 0 
2e1b			 
2e1b				if DEBUG_FORTH_WORDS 
2e1b					DMARK "LSn" 
2e1b f5				push af  
2e1c 3a 30 2e			ld a, (.dmark)  
2e1f 32 a6 fd			ld (debug_mark),a  
2e22 3a 31 2e			ld a, (.dmark+1)  
2e25 32 a7 fd			ld (debug_mark+1),a  
2e28 3a 32 2e			ld a, (.dmark+2)  
2e2b 32 a8 fd			ld (debug_mark+2),a  
2e2e 18 03			jr .pastdmark  
2e30 ..			.dmark: db "LSn"  
2e33 f1			.pastdmark: pop af  
2e34			endm  
# End of macro DMARK
2e34					CALLMONITOR 
2e34 cd aa fd			call debug_vector  
2e37				endm  
# End of macro CALLMONITOR
2e37				endif 
2e37			 
2e37					; copy uword name to scratch 
2e37			 
2e37 ed b0				ldir 
2e39			 
2e39 1b					dec de 
2e3a 3e 20				ld a, ' '    ; change null to space 
2e3c 12					ld (de), a 
2e3d			 
2e3d 13					inc de 
2e3e			 
2e3e d5					push de 
2e3f c1					pop bc     ; move scratch pointer to end of word name and save it 
2e40			 
2e40 e1					pop hl 
2e41 7e					ld a, (hl) 
2e42					;inc hl 
2e42					; skip word string 
2e42 cd cf 0f				call addatohl 
2e45			 
2e45 23					inc hl 
2e46			 
2e46				if DEBUG_FORTH_WORDS 
2e46					DMARK "LS3" 
2e46 f5				push af  
2e47 3a 5b 2e			ld a, (.dmark)  
2e4a 32 a6 fd			ld (debug_mark),a  
2e4d 3a 5c 2e			ld a, (.dmark+1)  
2e50 32 a7 fd			ld (debug_mark+1),a  
2e53 3a 5d 2e			ld a, (.dmark+2)  
2e56 32 a8 fd			ld (debug_mark+2),a  
2e59 18 03			jr .pastdmark  
2e5b ..			.dmark: db "LS3"  
2e5e f1			.pastdmark: pop af  
2e5f			endm  
# End of macro DMARK
2e5f					CALLMONITOR 
2e5f cd aa fd			call debug_vector  
2e62				endm  
# End of macro CALLMONITOR
2e62				endif 
2e62					; should now be at the start of the machine code to setup the eval of the uword 
2e62					; now locate the ptr to the string defintion 
2e62			 
2e62					; skip ld hl, 
2e62					; then load the ptr 
2e62			; TODO use get from hl ptr 
2e62 23					inc hl 
2e63 5e					ld e, (hl) 
2e64 23					inc hl 
2e65 56					ld d, (hl) 
2e66 eb					ex de, hl 
2e67			 
2e67			 
2e67				if DEBUG_FORTH_WORDS 
2e67					DMARK "LSt" 
2e67 f5				push af  
2e68 3a 7c 2e			ld a, (.dmark)  
2e6b 32 a6 fd			ld (debug_mark),a  
2e6e 3a 7d 2e			ld a, (.dmark+1)  
2e71 32 a7 fd			ld (debug_mark+1),a  
2e74 3a 7e 2e			ld a, (.dmark+2)  
2e77 32 a8 fd			ld (debug_mark+2),a  
2e7a 18 03			jr .pastdmark  
2e7c ..			.dmark: db "LSt"  
2e7f f1			.pastdmark: pop af  
2e80			endm  
# End of macro DMARK
2e80					CALLMONITOR 
2e80 cd aa fd			call debug_vector  
2e83				endm  
# End of macro CALLMONITOR
2e83				endif 
2e83			 
2e83			; cant push right now due to tokenised strings  
2e83			 
2e83			; get the destination of where to copy this definition to. 
2e83			 
2e83 c5					push bc 
2e84 d1					pop de 
2e85			 
2e85 7e			.listl:         ld a,(hl) 
2e86 fe 00				cp 0 
2e88 28 09				jr z, .lreplsp     ; replace zero with space 
2e8a					;cp FORTH_END_BUFFER 
2e8a fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2e8c 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2e8e				 
2e8e					; just copy this char as is then 
2e8e			 
2e8e 12					ld (de), a 
2e8f			 
2e8f 23			.listnxt:	inc hl 
2e90 13					inc de 
2e91 18 f2				jr .listl 
2e93			 
2e93 3e 20		.lreplsp:	ld a,' ' 
2e95 12					ld (de), a 
2e96 18 f7				jr .listnxt 
2e98			 
2e98			; close up uword def 
2e98			 
2e98			.listdone: 
2e98 12					ld (de), a 
2e99 13					inc de 
2e9a 3e 00				ld a, 0 
2e9c 12					ld (de), a 
2e9d			 
2e9d			; now have def so clean up and push to stack 
2e9d			 
2e9d 21 fc f0				ld hl, scratch 
2ea0				if DEBUG_FORTH_WORDS 
2ea0					DMARK "Ltp" 
2ea0 f5				push af  
2ea1 3a b5 2e			ld a, (.dmark)  
2ea4 32 a6 fd			ld (debug_mark),a  
2ea7 3a b6 2e			ld a, (.dmark+1)  
2eaa 32 a7 fd			ld (debug_mark+1),a  
2ead 3a b7 2e			ld a, (.dmark+2)  
2eb0 32 a8 fd			ld (debug_mark+2),a  
2eb3 18 03			jr .pastdmark  
2eb5 ..			.dmark: db "Ltp"  
2eb8 f1			.pastdmark: pop af  
2eb9			endm  
# End of macro DMARK
2eb9					CALLMONITOR 
2eb9 cd aa fd			call debug_vector  
2ebc				endm  
# End of macro CALLMONITOR
2ebc				endif 
2ebc			 
2ebc 18 1f			jr .listpush 
2ebe			 
2ebe			;.lnuword:	pop hl 
2ebe			;		call forth_tok_next 
2ebe			;		jp .ldouscan  
2ebe			 
2ebe			.lunotfound:		  
2ebe			 
2ebe				if DEBUG_FORTH_WORDS 
2ebe					DMARK "LSn" 
2ebe f5				push af  
2ebf 3a d3 2e			ld a, (.dmark)  
2ec2 32 a6 fd			ld (debug_mark),a  
2ec5 3a d4 2e			ld a, (.dmark+1)  
2ec8 32 a7 fd			ld (debug_mark+1),a  
2ecb 3a d5 2e			ld a, (.dmark+2)  
2ece 32 a8 fd			ld (debug_mark+2),a  
2ed1 18 03			jr .pastdmark  
2ed3 ..			.dmark: db "LSn"  
2ed6 f1			.pastdmark: pop af  
2ed7			endm  
# End of macro DMARK
2ed7					CALLMONITOR 
2ed7 cd aa fd			call debug_vector  
2eda				endm  
# End of macro CALLMONITOR
2eda				endif 
2eda			 
2eda					 
2eda			;		FORTH_DSP_POP 
2eda			;		ld hl, .luno 
2eda			 
2eda					NEXTW			 
2eda c3 c5 23			jp macro_next 
2edd				endm 
# End of macro NEXTW
2edd			 
2edd			.listpush: 
2edd				if DEBUG_FORTH_WORDS 
2edd					DMARK "LS>" 
2edd f5				push af  
2ede 3a f2 2e			ld a, (.dmark)  
2ee1 32 a6 fd			ld (debug_mark),a  
2ee4 3a f3 2e			ld a, (.dmark+1)  
2ee7 32 a7 fd			ld (debug_mark+1),a  
2eea 3a f4 2e			ld a, (.dmark+2)  
2eed 32 a8 fd			ld (debug_mark+2),a  
2ef0 18 03			jr .pastdmark  
2ef2 ..			.dmark: db "LS>"  
2ef5 f1			.pastdmark: pop af  
2ef6			endm  
# End of macro DMARK
2ef6					CALLMONITOR 
2ef6 cd aa fd			call debug_vector  
2ef9				endm  
# End of macro CALLMONITOR
2ef9				endif 
2ef9 cd 86 20				call forth_push_str 
2efc			 
2efc			 
2efc			 
2efc					NEXTW 
2efc c3 c5 23			jp macro_next 
2eff				endm 
# End of macro NEXTW
2eff			 
2eff			;.luno:    db "Word not found",0 
2eff			 
2eff			 
2eff			 
2eff			 
2eff			 
2eff			;		push hl   ; save pointer to start of uword def string 
2eff			; 
2eff			;; look for FORTH_EOL_LINE 
2eff			;		ld a, FORTH_END_BUFFER 
2eff			;		call strlent 
2eff			; 
2eff			;		inc hl		 ; space for coln def 
2eff			;		inc hl 
2eff			;		inc hl          ; space for terms 
2eff			;		inc hl 
2eff			; 
2eff			;		ld a, 20   ; TODO get actual length 
2eff			;		call addatohl    ; include a random amount of room for the uword name 
2eff			; 
2eff			;		 
2eff			;	if DEBUG_FORTH_WORDS 
2eff			;		DMARK "Lt1" 
2eff			;		CALLMONITOR 
2eff			;	endif 
2eff			;		 
2eff			; 
2eff			;; malloc space for the string because we cant change it 
2eff			; 
2eff			;		call malloc 
2eff			;	if DEBUG_FORTH_MALLOC_GUARD 
2eff			;		push af 
2eff			;		call ishlzero 
2eff			;		pop af 
2eff			;		 
2eff			;		call z,malloc_error 
2eff			;	endif 
2eff			; 
2eff			;	if DEBUG_FORTH_WORDS 
2eff			;		DMARK "Lt2" 
2eff			;		CALLMONITOR 
2eff			;	endif 
2eff			;		pop de 
2eff			;		push hl    ; push the malloc to release later 
2eff			;		push hl   ;  push back a copy for the later stack push 
2eff			;		 
2eff			;; copy the string swapping out the zero terms for spaces 
2eff			; 
2eff			;		; de has our source 
2eff			;		; hl has our dest 
2eff			; 
2eff			;; add the coln def 
2eff			; 
2eff			;		ld a, ':' 
2eff			;		ld (hl), a 
2eff			;		inc hl 
2eff			;		ld a, ' ' 
2eff			;		ld (hl), a 
2eff			;		inc hl 
2eff			; 
2eff			;; add the uname word 
2eff			;		push de   ; save our string for now 
2eff			;		ex de, hl 
2eff			; 
2eff			;		FORTH_DSP_VALUE 
2eff			;		;v5 FORTH_DSP_VALUE 
2eff			; 
2eff			;		inc hl   ; skip type but we know by now this is OK 
2eff			; 
2eff			;.luword:	ld a,(hl) 
2eff			;		cp 0 
2eff			;		jr z, .luword2 
2eff			;		ld (de), a 
2eff			;		inc de 
2eff			;		inc hl 
2eff			;		jr .luword 
2eff			; 
2eff			;.luword2:	ld a, ' ' 
2eff			;		ld (de), a 
2eff			;;		inc hl 
2eff			;;		inc de 
2eff			;;		ld (de), a 
2eff			;;		inc hl 
2eff			;		inc de 
2eff			; 
2eff			;		ex de, hl 
2eff			;		pop de 
2eff			;		 
2eff			;		 
2eff			; 
2eff			;; detoken that string and copy it 
2eff			; 
2eff			;	if DEBUG_FORTH_WORDS 
2eff			;		DMARK "Lt2" 
2eff			;		CALLMONITOR 
2eff			;	endif 
2eff			;.ldetok:	ld a, (de) 
2eff			;		cp FORTH_END_BUFFER 
2eff			;		jr z, .ldetokend 
2eff			;		; swap out any zero term for space 
2eff			;		cp 0 
2eff			;		jr nz, .ldetoknext 
2eff			;		ld a, ' ' 
2eff			; 
2eff			;	if DEBUG_FORTH_WORDS 
2eff			;		DMARK "LtS" 
2eff			;		CALLMONITOR 
2eff			;	endif 
2eff			;.ldetoknext:	ld (hl), a 
2eff			;		inc de 
2eff			;		inc hl 
2eff			;		jr .ldetok 
2eff			; 
2eff			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2eff			;		ld (hl), a  
2eff			; 
2eff			;; free that temp malloc 
2eff			; 
2eff			;		pop hl    
2eff			; 
2eff			;	if DEBUG_FORTH_WORDS 
2eff			;		DMARK "Lt4" 
2eff			;		CALLMONITOR 
2eff			;	endif 
2eff			;		call forth_apushstrhl 
2eff			; 
2eff			;		; get rid of temp malloc area 
2eff			; 
2eff			;		pop hl 
2eff			;		call free 
2eff			; 
2eff			;		jr .ludone 
2eff			; 
2eff			;.lnuword:	pop hl 
2eff			;		call forth_tok_next 
2eff			;		jp .ldouscan  
2eff			; 
2eff			;.ludone:		 pop hl 
2eff			; 
2eff					NEXTW 
2eff c3 c5 23			jp macro_next 
2f02				endm 
# End of macro NEXTW
2f02			 
2f02			.FORGET: 
2f02				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2f02 5d				db WORD_SYS_CORE+73             
2f03 7b 2f			dw .NOP            
2f05 07				db 6 + 1 
2f06 .. 00			db "FORGET",0              
2f0d				endm 
# End of macro CWHEAD
2f0d			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2f0d			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2f0d			; | |  
2f0d			; | | e.g. "MORE" forget 
2f0d					if DEBUG_FORTH_WORDS_KEY 
2f0d						DMARK "FRG" 
2f0d f5				push af  
2f0e 3a 22 2f			ld a, (.dmark)  
2f11 32 a6 fd			ld (debug_mark),a  
2f14 3a 23 2f			ld a, (.dmark+1)  
2f17 32 a7 fd			ld (debug_mark+1),a  
2f1a 3a 24 2f			ld a, (.dmark+2)  
2f1d 32 a8 fd			ld (debug_mark+2),a  
2f20 18 03			jr .pastdmark  
2f22 ..			.dmark: db "FRG"  
2f25 f1			.pastdmark: pop af  
2f26			endm  
# End of macro DMARK
2f26						CALLMONITOR 
2f26 cd aa fd			call debug_vector  
2f29				endm  
# End of macro CALLMONITOR
2f29					endif 
2f29			 
2f29				; find uword 
2f29			        ; update start of word with "_" 
2f29				; replace uword with deleted flag 
2f29			 
2f29			 
2f29			;	if DEBUG_FORTH_WORDS 
2f29			;		DMARK "FOG" 
2f29			;		CALLMONITOR 
2f29			;	endif 
2f29			 
2f29			 
2f29					; Get ptr to the word we need to look up 
2f29			 
2f29					FORTH_DSP_VALUEHL 
2f29 cd 0f 22			call macro_dsp_valuehl 
2f2c				endm 
# End of macro FORTH_DSP_VALUEHL
2f2c					;v5 FORTH_DSP_VALUE 
2f2c				; TODO type check 
2f2c			;		inc hl    ; Skip type check  
2f2c e5					push hl 
2f2d c1					pop bc 
2f2e			;		ex de, hl    ; put into DE 
2f2e			 
2f2e			 
2f2e 21 00 80				ld hl, baseram 
2f31					;ld hl, baseusermem 
2f31			 
2f31				; skip dict stub 
2f31			;	call forth_tok_next 
2f31 e5			push hl   ; sacreifical push 
2f32			 
2f32			.fldouscanm: 
2f32 e1				pop hl 
2f33			.fldouscan: 
2f33			;	if DEBUG_FORTH_WORDS 
2f33			;		DMARK "LSs" 
2f33			;		CALLMONITOR 
2f33			;	endif 
2f33				; skip dict stub 
2f33 cd 16 25				call forth_tok_next 
2f36			 
2f36			 
2f36			; while we have words to look for 
2f36			 
2f36 7e				ld a, (hl)      
2f37			;	if DEBUG_FORTH_WORDS 
2f37			;		DMARK "LSk" 
2f37			;		CALLMONITOR 
2f37			;	endif 
2f37 fe 00				cp WORD_SYS_END 
2f39 ca 75 2f				jp z, .flunotfound 
2f3c fe 01				cp WORD_SYS_UWORD 
2f3e c2 33 2f				jp nz, .fldouscan 
2f41			 
2f41			;	if DEBUG_FORTH_WORDS 
2f41			;		DMARK "LSu" 
2f41			;		CALLMONITOR 
2f41			;	endif 
2f41			 
2f41					; found a uword but is it the one we want... 
2f41			 
2f41 c5					push bc     ; uword to find is on bc 
2f42 d1					pop de 
2f43			 
2f43 e5					push hl  ; to save the ptr 
2f44			 
2f44					; skip opcode 
2f44 23					inc hl  
2f45					; skip next ptr 
2f45 23					inc hl  
2f46 23					inc hl 
2f47					; skip len 
2f47 23					inc hl 
2f48			 
2f48			;	if DEBUG_FORTH_WORDS 
2f48			;		DMARK "LSc" 
2f48			;		CALLMONITOR 
2f48			;	endif 
2f48 cd 7a 13				call strcmp 
2f4b c2 32 2f				jp nz, .fldouscanm 
2f4e			; 
2f4e			; 
2f4e			;; while we have words to look for 
2f4e			; 
2f4e			;.fdouscan:	ld a, (hl)      
2f4e			;	if DEBUG_FORTH_WORDS 
2f4e			;		DMARK "LSs" 
2f4e			;		CALLMONITOR 
2f4e			;	endif 
2f4e			;		cp WORD_SYS_END 
2f4e			;		jp z, .fudone 
2f4e			;		cp WORD_SYS_UWORD 
2f4e			;		jp nz, .fnuword 
2f4e			; 
2f4e			;	if DEBUG_FORTH_WORDS 
2f4e			;		DMARK "FGu" 
2f4e			;		CALLMONITOR 
2f4e			;	endif 
2f4e			; 
2f4e			;		; found a uword but is it the one we want... 
2f4e			; 
2f4e			; 
2f4e			;	        pop de   ; get back the dsp name 
2f4e			;		push de 
2f4e			; 
2f4e			;		push hl  ; to save the ptr 
2f4e			; 
2f4e			;		; skip opcode 
2f4e			;		inc hl  
2f4e			;		; skip next ptr 
2f4e			;		inc hl  
2f4e			;		inc hl 
2f4e			;		; skip len 
2f4e			;		inc hl 
2f4e			; 
2f4e			;	if DEBUG_FORTH_WORDS 
2f4e			;		DMARK "FGc" 
2f4e			;		CALLMONITOR 
2f4e			;	endif 
2f4e			;		call strcmp 
2f4e			;		jp nz, .fnuword 
2f4e			 
2f4e			 
2f4e e1			pop hl 
2f4f			 
2f4f				 
2f4f				if DEBUG_FORTH_WORDS 
2f4f					DMARK "FGm" 
2f4f f5				push af  
2f50 3a 64 2f			ld a, (.dmark)  
2f53 32 a6 fd			ld (debug_mark),a  
2f56 3a 65 2f			ld a, (.dmark+1)  
2f59 32 a7 fd			ld (debug_mark+1),a  
2f5c 3a 66 2f			ld a, (.dmark+2)  
2f5f 32 a8 fd			ld (debug_mark+2),a  
2f62 18 03			jr .pastdmark  
2f64 ..			.dmark: db "FGm"  
2f67 f1			.pastdmark: pop af  
2f68			endm  
# End of macro DMARK
2f68					CALLMONITOR 
2f68 cd aa fd			call debug_vector  
2f6b				endm  
# End of macro CALLMONITOR
2f6b				endif 
2f6b			 
2f6b			 
2f6b			 
2f6b					; we have a uword so push its name to the stack 
2f6b			 
2f6b			;	   	push hl  ; save so we can move to next dict block 
2f6b			;pop hl 
2f6b			 
2f6b					; update opcode to deleted 
2f6b 3e 03				ld a, WORD_SYS_DELETED 
2f6d 77					ld (hl), a 
2f6e			 
2f6e 23					inc hl  
2f6f					; skip next ptr 
2f6f 23					inc hl  
2f70 23					inc hl 
2f71					; skip len 
2f71 23					inc hl 
2f72			 
2f72					; TODO change parser to skip deleted words but for now mark it out 
2f72 3e 5f				ld a, "_" 
2f74 77					ld  (hl),a 
2f75			 
2f75			;		jr .fudone 
2f75			; 
2f75			;.fnuword:	pop hl 
2f75			;		call forth_tok_next 
2f75			;		jp .fdouscan  
2f75			 
2f75			.flunotfound:		  
2f75			 
2f75			 
2f75					 
2f75					FORTH_DSP_POP 
2f75 cd c7 22			call macro_forth_dsp_pop 
2f78				endm 
# End of macro FORTH_DSP_POP
2f78			;		ld hl, .luno 
2f78			;.fudone:		 pop hl 
2f78					NEXTW 
2f78 c3 c5 23			jp macro_next 
2f7b				endm 
# End of macro NEXTW
2f7b			.NOP: 
2f7b				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2f7b 61				db WORD_SYS_CORE+77             
2f7c a2 2f			dw .COMO            
2f7e 04				db 3 + 1 
2f7f .. 00			db "NOP",0              
2f83				endm 
# End of macro CWHEAD
2f83			; | NOP (  --  ) Do nothing | DONE 
2f83					if DEBUG_FORTH_WORDS_KEY 
2f83						DMARK "NOP" 
2f83 f5				push af  
2f84 3a 98 2f			ld a, (.dmark)  
2f87 32 a6 fd			ld (debug_mark),a  
2f8a 3a 99 2f			ld a, (.dmark+1)  
2f8d 32 a7 fd			ld (debug_mark+1),a  
2f90 3a 9a 2f			ld a, (.dmark+2)  
2f93 32 a8 fd			ld (debug_mark+2),a  
2f96 18 03			jr .pastdmark  
2f98 ..			.dmark: db "NOP"  
2f9b f1			.pastdmark: pop af  
2f9c			endm  
# End of macro DMARK
2f9c						CALLMONITOR 
2f9c cd aa fd			call debug_vector  
2f9f				endm  
# End of macro CALLMONITOR
2f9f					endif 
2f9f				       NEXTW 
2f9f c3 c5 23			jp macro_next 
2fa2				endm 
# End of macro NEXTW
2fa2			.COMO: 
2fa2				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2fa2 6e				db WORD_SYS_CORE+90             
2fa3 f4 2f			dw .COMC            
2fa5 02				db 1 + 1 
2fa6 .. 00			db "(",0              
2fa8				endm 
# End of macro CWHEAD
2fa8			; | ( ( -- )  Start of comment | DONE 
2fa8			 
2fa8			 
2fa8 2a fd f3				ld hl, ( os_tok_ptr) 
2fab 11 ef 2f			ld de, .closepar 
2fae					 
2fae					if DEBUG_FORTH_WORDS 
2fae						DMARK ").." 
2fae f5				push af  
2faf 3a c3 2f			ld a, (.dmark)  
2fb2 32 a6 fd			ld (debug_mark),a  
2fb5 3a c4 2f			ld a, (.dmark+1)  
2fb8 32 a7 fd			ld (debug_mark+1),a  
2fbb 3a c5 2f			ld a, (.dmark+2)  
2fbe 32 a8 fd			ld (debug_mark+2),a  
2fc1 18 03			jr .pastdmark  
2fc3 ..			.dmark: db ").."  
2fc6 f1			.pastdmark: pop af  
2fc7			endm  
# End of macro DMARK
2fc7						CALLMONITOR 
2fc7 cd aa fd			call debug_vector  
2fca				endm  
# End of macro CALLMONITOR
2fca					endif 
2fca cd e0 24			call findnexttok  
2fcd			 
2fcd					if DEBUG_FORTH_WORDS 
2fcd						DMARK "IF5" 
2fcd f5				push af  
2fce 3a e2 2f			ld a, (.dmark)  
2fd1 32 a6 fd			ld (debug_mark),a  
2fd4 3a e3 2f			ld a, (.dmark+1)  
2fd7 32 a7 fd			ld (debug_mark+1),a  
2fda 3a e4 2f			ld a, (.dmark+2)  
2fdd 32 a8 fd			ld (debug_mark+2),a  
2fe0 18 03			jr .pastdmark  
2fe2 ..			.dmark: db "IF5"  
2fe5 f1			.pastdmark: pop af  
2fe6			endm  
# End of macro DMARK
2fe6						CALLMONITOR 
2fe6 cd aa fd			call debug_vector  
2fe9				endm  
# End of macro CALLMONITOR
2fe9					endif 
2fe9				; replace below with ) exec using tok_ptr 
2fe9 22 fd f3			ld (os_tok_ptr), hl 
2fec c3 56 24			jp exec1 
2fef			 
2fef .. 00			.closepar:   db ")",0 
2ff1			 
2ff1				       NEXTW 
2ff1 c3 c5 23			jp macro_next 
2ff4				endm 
# End of macro NEXTW
2ff4			.COMC: 
2ff4				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2ff4 6f				db WORD_SYS_CORE+91             
2ff5 fd 2f			dw .SCRATCH            
2ff7 02				db 1 + 1 
2ff8 .. 00			db ")",0              
2ffa				endm 
# End of macro CWHEAD
2ffa			; | ) ( -- )  End of comment |  DONE  
2ffa				       NEXTW 
2ffa c3 c5 23			jp macro_next 
2ffd				endm 
# End of macro NEXTW
2ffd			 
2ffd			.SCRATCH: 
2ffd				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2ffd 6f				db WORD_SYS_CORE+91             
2ffe 38 30			dw .INC            
3000 08				db 7 + 1 
3001 .. 00			db "SCRATCH",0              
3009				endm 
# End of macro CWHEAD
3009			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
3009			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
3009			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
3009			; | |  
3009			; | | e.g.    : score $00 scratch ; 
3009			; | |  
3009			; | | $00 score ! 
3009			; | | $01 score +! 
3009			; | |  
3009			; | | e.g.   : varword $0a scratch ;  
3009			; | | 
3009			; | | $8000 varword ! 
3009					if DEBUG_FORTH_WORDS_KEY 
3009						DMARK "SCR" 
3009 f5				push af  
300a 3a 1e 30			ld a, (.dmark)  
300d 32 a6 fd			ld (debug_mark),a  
3010 3a 1f 30			ld a, (.dmark+1)  
3013 32 a7 fd			ld (debug_mark+1),a  
3016 3a 20 30			ld a, (.dmark+2)  
3019 32 a8 fd			ld (debug_mark+2),a  
301c 18 03			jr .pastdmark  
301e ..			.dmark: db "SCR"  
3021 f1			.pastdmark: pop af  
3022			endm  
# End of macro DMARK
3022						CALLMONITOR 
3022 cd aa fd			call debug_vector  
3025				endm  
# End of macro CALLMONITOR
3025					endif 
3025			 
3025					FORTH_DSP_VALUEHL 
3025 cd 0f 22			call macro_dsp_valuehl 
3028				endm 
# End of macro FORTH_DSP_VALUEHL
3028				 
3028					FORTH_DSP_POP 
3028 cd c7 22			call macro_forth_dsp_pop 
302b				endm 
# End of macro FORTH_DSP_POP
302b			 
302b 7d					ld a, l 
302c 21 21 f6				ld hl, os_var_array 
302f cd cf 0f				call addatohl 
3032			 
3032 cd 18 20				call forth_push_numhl 
3035			 
3035				       NEXTW 
3035 c3 c5 23			jp macro_next 
3038				endm 
# End of macro NEXTW
3038			 
3038			.INC: 
3038				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
3038 6f				db WORD_SYS_CORE+91             
3039 8e 30			dw .DEC            
303b 03				db 2 + 1 
303c .. 00			db "+!",0              
303f				endm 
# End of macro CWHEAD
303f			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
303f					if DEBUG_FORTH_WORDS_KEY 
303f						DMARK "+s_" 
303f f5				push af  
3040 3a 54 30			ld a, (.dmark)  
3043 32 a6 fd			ld (debug_mark),a  
3046 3a 55 30			ld a, (.dmark+1)  
3049 32 a7 fd			ld (debug_mark+1),a  
304c 3a 56 30			ld a, (.dmark+2)  
304f 32 a8 fd			ld (debug_mark+2),a  
3052 18 03			jr .pastdmark  
3054 ..			.dmark: db "+s_"  
3057 f1			.pastdmark: pop af  
3058			endm  
# End of macro DMARK
3058						CALLMONITOR 
3058 cd aa fd			call debug_vector  
305b				endm  
# End of macro CALLMONITOR
305b					endif 
305b			 
305b					FORTH_DSP_VALUEHL 
305b cd 0f 22			call macro_dsp_valuehl 
305e				endm 
# End of macro FORTH_DSP_VALUEHL
305e			 
305e e5					push hl   ; save address 
305f			 
305f					FORTH_DSP_POP 
305f cd c7 22			call macro_forth_dsp_pop 
3062				endm 
# End of macro FORTH_DSP_POP
3062			 
3062					FORTH_DSP_VALUEHL 
3062 cd 0f 22			call macro_dsp_valuehl 
3065				endm 
# End of macro FORTH_DSP_VALUEHL
3065			 
3065 e5					push hl 
3066					FORTH_DSP_POP 
3066 cd c7 22			call macro_forth_dsp_pop 
3069				endm 
# End of macro FORTH_DSP_POP
3069 e1					pop hl 
306a			 
306a					; hl contains value to add to byte at a 
306a				 
306a eb					ex de, hl 
306b			 
306b e1					pop hl 
306c			 
306c					if DEBUG_FORTH_WORDS 
306c						DMARK "INC" 
306c f5				push af  
306d 3a 81 30			ld a, (.dmark)  
3070 32 a6 fd			ld (debug_mark),a  
3073 3a 82 30			ld a, (.dmark+1)  
3076 32 a7 fd			ld (debug_mark+1),a  
3079 3a 83 30			ld a, (.dmark+2)  
307c 32 a8 fd			ld (debug_mark+2),a  
307f 18 03			jr .pastdmark  
3081 ..			.dmark: db "INC"  
3084 f1			.pastdmark: pop af  
3085			endm  
# End of macro DMARK
3085						CALLMONITOR 
3085 cd aa fd			call debug_vector  
3088				endm  
# End of macro CALLMONITOR
3088					endif 
3088			 
3088 7e					ld a,(hl) 
3089 83					add e 
308a 77					ld (hl),a 
308b			 
308b			 
308b			 
308b				       NEXTW 
308b c3 c5 23			jp macro_next 
308e				endm 
# End of macro NEXTW
308e			 
308e			.DEC: 
308e				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
308e 6f				db WORD_SYS_CORE+91             
308f e2 30			dw .INC2            
3091 03				db 2 + 1 
3092 .. 00			db "-!",0              
3095				endm 
# End of macro CWHEAD
3095			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
3095					if DEBUG_FORTH_WORDS_KEY 
3095						DMARK "-s_" 
3095 f5				push af  
3096 3a aa 30			ld a, (.dmark)  
3099 32 a6 fd			ld (debug_mark),a  
309c 3a ab 30			ld a, (.dmark+1)  
309f 32 a7 fd			ld (debug_mark+1),a  
30a2 3a ac 30			ld a, (.dmark+2)  
30a5 32 a8 fd			ld (debug_mark+2),a  
30a8 18 03			jr .pastdmark  
30aa ..			.dmark: db "-s_"  
30ad f1			.pastdmark: pop af  
30ae			endm  
# End of macro DMARK
30ae						CALLMONITOR 
30ae cd aa fd			call debug_vector  
30b1				endm  
# End of macro CALLMONITOR
30b1					endif 
30b1			 
30b1					FORTH_DSP_VALUEHL 
30b1 cd 0f 22			call macro_dsp_valuehl 
30b4				endm 
# End of macro FORTH_DSP_VALUEHL
30b4			 
30b4 e5					push hl   ; save address 
30b5			 
30b5					FORTH_DSP_POP 
30b5 cd c7 22			call macro_forth_dsp_pop 
30b8				endm 
# End of macro FORTH_DSP_POP
30b8			 
30b8					FORTH_DSP_VALUEHL 
30b8 cd 0f 22			call macro_dsp_valuehl 
30bb				endm 
# End of macro FORTH_DSP_VALUEHL
30bb			 
30bb					; hl contains value to add to byte at a 
30bb				 
30bb eb					ex de, hl 
30bc			 
30bc e1					pop hl 
30bd			 
30bd					if DEBUG_FORTH_WORDS 
30bd						DMARK "DEC" 
30bd f5				push af  
30be 3a d2 30			ld a, (.dmark)  
30c1 32 a6 fd			ld (debug_mark),a  
30c4 3a d3 30			ld a, (.dmark+1)  
30c7 32 a7 fd			ld (debug_mark+1),a  
30ca 3a d4 30			ld a, (.dmark+2)  
30cd 32 a8 fd			ld (debug_mark+2),a  
30d0 18 03			jr .pastdmark  
30d2 ..			.dmark: db "DEC"  
30d5 f1			.pastdmark: pop af  
30d6			endm  
# End of macro DMARK
30d6						CALLMONITOR 
30d6 cd aa fd			call debug_vector  
30d9				endm  
# End of macro CALLMONITOR
30d9					endif 
30d9			 
30d9 7e					ld a,(hl) 
30da 93					sub e 
30db 77					ld (hl),a 
30dc			 
30dc			 
30dc					FORTH_DSP_POP 
30dc cd c7 22			call macro_forth_dsp_pop 
30df				endm 
# End of macro FORTH_DSP_POP
30df			 
30df				       NEXTW 
30df c3 c5 23			jp macro_next 
30e2				endm 
# End of macro NEXTW
30e2			 
30e2			.INC2: 
30e2				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
30e2 6f				db WORD_SYS_CORE+91             
30e3 8f 31			dw .DEC2            
30e5 04				db 3 + 1 
30e6 .. 00			db "+2!",0              
30ea				endm 
# End of macro CWHEAD
30ea			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
30ea			 
30ea					if DEBUG_FORTH_WORDS_KEY 
30ea						DMARK "+2s" 
30ea f5				push af  
30eb 3a ff 30			ld a, (.dmark)  
30ee 32 a6 fd			ld (debug_mark),a  
30f1 3a 00 31			ld a, (.dmark+1)  
30f4 32 a7 fd			ld (debug_mark+1),a  
30f7 3a 01 31			ld a, (.dmark+2)  
30fa 32 a8 fd			ld (debug_mark+2),a  
30fd 18 03			jr .pastdmark  
30ff ..			.dmark: db "+2s"  
3102 f1			.pastdmark: pop af  
3103			endm  
# End of macro DMARK
3103						CALLMONITOR 
3103 cd aa fd			call debug_vector  
3106				endm  
# End of macro CALLMONITOR
3106					endif 
3106			 
3106					; Address 
3106			 
3106					FORTH_DSP_VALUEHL 
3106 cd 0f 22			call macro_dsp_valuehl 
3109				endm 
# End of macro FORTH_DSP_VALUEHL
3109			 
3109 e5					push hl    ; save address 
310a			 
310a					; load content into de 
310a			 
310a 5e					ld e,(hl) 
310b 23					inc hl 
310c 56					ld d, (hl) 
310d			 
310d					if DEBUG_FORTH_WORDS 
310d						DMARK "+2a" 
310d f5				push af  
310e 3a 22 31			ld a, (.dmark)  
3111 32 a6 fd			ld (debug_mark),a  
3114 3a 23 31			ld a, (.dmark+1)  
3117 32 a7 fd			ld (debug_mark+1),a  
311a 3a 24 31			ld a, (.dmark+2)  
311d 32 a8 fd			ld (debug_mark+2),a  
3120 18 03			jr .pastdmark  
3122 ..			.dmark: db "+2a"  
3125 f1			.pastdmark: pop af  
3126			endm  
# End of macro DMARK
3126						CALLMONITOR 
3126 cd aa fd			call debug_vector  
3129				endm  
# End of macro CALLMONITOR
3129					endif 
3129			 
3129					FORTH_DSP_POP 
3129 cd c7 22			call macro_forth_dsp_pop 
312c				endm 
# End of macro FORTH_DSP_POP
312c			 
312c					; Get value to add 
312c			 
312c					FORTH_DSP_VALUE 
312c cd f8 21			call macro_forth_dsp_value 
312f				endm 
# End of macro FORTH_DSP_VALUE
312f			 
312f					if DEBUG_FORTH_WORDS 
312f						DMARK "+2v" 
312f f5				push af  
3130 3a 44 31			ld a, (.dmark)  
3133 32 a6 fd			ld (debug_mark),a  
3136 3a 45 31			ld a, (.dmark+1)  
3139 32 a7 fd			ld (debug_mark+1),a  
313c 3a 46 31			ld a, (.dmark+2)  
313f 32 a8 fd			ld (debug_mark+2),a  
3142 18 03			jr .pastdmark  
3144 ..			.dmark: db "+2v"  
3147 f1			.pastdmark: pop af  
3148			endm  
# End of macro DMARK
3148						CALLMONITOR 
3148 cd aa fd			call debug_vector  
314b				endm  
# End of macro CALLMONITOR
314b					endif 
314b			 
314b 19					add hl, de 
314c			 
314c					if DEBUG_FORTH_WORDS 
314c						DMARK "+2+" 
314c f5				push af  
314d 3a 61 31			ld a, (.dmark)  
3150 32 a6 fd			ld (debug_mark),a  
3153 3a 62 31			ld a, (.dmark+1)  
3156 32 a7 fd			ld (debug_mark+1),a  
3159 3a 63 31			ld a, (.dmark+2)  
315c 32 a8 fd			ld (debug_mark+2),a  
315f 18 03			jr .pastdmark  
3161 ..			.dmark: db "+2+"  
3164 f1			.pastdmark: pop af  
3165			endm  
# End of macro DMARK
3165						CALLMONITOR 
3165 cd aa fd			call debug_vector  
3168				endm  
# End of macro CALLMONITOR
3168					endif 
3168			 
3168					; move result to de 
3168			 
3168 eb					ex de, hl 
3169			 
3169					; Address 
3169			 
3169 e1					pop hl 
316a			 
316a					; save it back 
316a			 
316a 73					ld (hl), e 
316b 23					inc hl 
316c 72					ld (hl), d 
316d			 
316d					if DEBUG_FORTH_WORDS 
316d						DMARK "+2e" 
316d f5				push af  
316e 3a 82 31			ld a, (.dmark)  
3171 32 a6 fd			ld (debug_mark),a  
3174 3a 83 31			ld a, (.dmark+1)  
3177 32 a7 fd			ld (debug_mark+1),a  
317a 3a 84 31			ld a, (.dmark+2)  
317d 32 a8 fd			ld (debug_mark+2),a  
3180 18 03			jr .pastdmark  
3182 ..			.dmark: db "+2e"  
3185 f1			.pastdmark: pop af  
3186			endm  
# End of macro DMARK
3186						CALLMONITOR 
3186 cd aa fd			call debug_vector  
3189				endm  
# End of macro CALLMONITOR
3189					endif 
3189			 
3189			 
3189			 
3189					FORTH_DSP_POP 
3189 cd c7 22			call macro_forth_dsp_pop 
318c				endm 
# End of macro FORTH_DSP_POP
318c			 
318c			 
318c				       NEXTW 
318c c3 c5 23			jp macro_next 
318f				endm 
# End of macro NEXTW
318f			 
318f			.DEC2: 
318f				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
318f 6f				db WORD_SYS_CORE+91             
3190 3e 32			dw .GET2            
3192 04				db 3 + 1 
3193 .. 00			db "-2!",0              
3197				endm 
# End of macro CWHEAD
3197			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
3197			 
3197			 
3197					if DEBUG_FORTH_WORDS_KEY 
3197						DMARK "-2s" 
3197 f5				push af  
3198 3a ac 31			ld a, (.dmark)  
319b 32 a6 fd			ld (debug_mark),a  
319e 3a ad 31			ld a, (.dmark+1)  
31a1 32 a7 fd			ld (debug_mark+1),a  
31a4 3a ae 31			ld a, (.dmark+2)  
31a7 32 a8 fd			ld (debug_mark+2),a  
31aa 18 03			jr .pastdmark  
31ac ..			.dmark: db "-2s"  
31af f1			.pastdmark: pop af  
31b0			endm  
# End of macro DMARK
31b0						CALLMONITOR 
31b0 cd aa fd			call debug_vector  
31b3				endm  
# End of macro CALLMONITOR
31b3					endif 
31b3			 
31b3					; Address 
31b3			 
31b3					FORTH_DSP_VALUEHL 
31b3 cd 0f 22			call macro_dsp_valuehl 
31b6				endm 
# End of macro FORTH_DSP_VALUEHL
31b6			 
31b6 e5					push hl    ; save address 
31b7			 
31b7					; load content into de 
31b7			 
31b7 5e					ld e,(hl) 
31b8 23					inc hl 
31b9 56					ld d, (hl) 
31ba			 
31ba					if DEBUG_FORTH_WORDS 
31ba						DMARK "-2a" 
31ba f5				push af  
31bb 3a cf 31			ld a, (.dmark)  
31be 32 a6 fd			ld (debug_mark),a  
31c1 3a d0 31			ld a, (.dmark+1)  
31c4 32 a7 fd			ld (debug_mark+1),a  
31c7 3a d1 31			ld a, (.dmark+2)  
31ca 32 a8 fd			ld (debug_mark+2),a  
31cd 18 03			jr .pastdmark  
31cf ..			.dmark: db "-2a"  
31d2 f1			.pastdmark: pop af  
31d3			endm  
# End of macro DMARK
31d3						CALLMONITOR 
31d3 cd aa fd			call debug_vector  
31d6				endm  
# End of macro CALLMONITOR
31d6					endif 
31d6			 
31d6					FORTH_DSP_POP 
31d6 cd c7 22			call macro_forth_dsp_pop 
31d9				endm 
# End of macro FORTH_DSP_POP
31d9			 
31d9					; Get value to remove 
31d9			 
31d9					FORTH_DSP_VALUE 
31d9 cd f8 21			call macro_forth_dsp_value 
31dc				endm 
# End of macro FORTH_DSP_VALUE
31dc			 
31dc					if DEBUG_FORTH_WORDS 
31dc						DMARK "-2v" 
31dc f5				push af  
31dd 3a f1 31			ld a, (.dmark)  
31e0 32 a6 fd			ld (debug_mark),a  
31e3 3a f2 31			ld a, (.dmark+1)  
31e6 32 a7 fd			ld (debug_mark+1),a  
31e9 3a f3 31			ld a, (.dmark+2)  
31ec 32 a8 fd			ld (debug_mark+2),a  
31ef 18 03			jr .pastdmark  
31f1 ..			.dmark: db "-2v"  
31f4 f1			.pastdmark: pop af  
31f5			endm  
# End of macro DMARK
31f5						CALLMONITOR 
31f5 cd aa fd			call debug_vector  
31f8				endm  
# End of macro CALLMONITOR
31f8					endif 
31f8			 
31f8 eb					ex de, hl 
31f9 ed 52				sbc hl, de 
31fb			 
31fb					if DEBUG_FORTH_WORDS 
31fb						DMARK "-2d" 
31fb f5				push af  
31fc 3a 10 32			ld a, (.dmark)  
31ff 32 a6 fd			ld (debug_mark),a  
3202 3a 11 32			ld a, (.dmark+1)  
3205 32 a7 fd			ld (debug_mark+1),a  
3208 3a 12 32			ld a, (.dmark+2)  
320b 32 a8 fd			ld (debug_mark+2),a  
320e 18 03			jr .pastdmark  
3210 ..			.dmark: db "-2d"  
3213 f1			.pastdmark: pop af  
3214			endm  
# End of macro DMARK
3214						CALLMONITOR 
3214 cd aa fd			call debug_vector  
3217				endm  
# End of macro CALLMONITOR
3217					endif 
3217			 
3217					; move result to de 
3217			 
3217 eb					ex de, hl 
3218			 
3218					; Address 
3218			 
3218 e1					pop hl 
3219			 
3219					; save it back 
3219			 
3219 73					ld (hl), e 
321a 23					inc hl 
321b 72					ld (hl), d 
321c			 
321c					if DEBUG_FORTH_WORDS 
321c						DMARK "-2e" 
321c f5				push af  
321d 3a 31 32			ld a, (.dmark)  
3220 32 a6 fd			ld (debug_mark),a  
3223 3a 32 32			ld a, (.dmark+1)  
3226 32 a7 fd			ld (debug_mark+1),a  
3229 3a 33 32			ld a, (.dmark+2)  
322c 32 a8 fd			ld (debug_mark+2),a  
322f 18 03			jr .pastdmark  
3231 ..			.dmark: db "-2e"  
3234 f1			.pastdmark: pop af  
3235			endm  
# End of macro DMARK
3235						CALLMONITOR 
3235 cd aa fd			call debug_vector  
3238				endm  
# End of macro CALLMONITOR
3238					endif 
3238			 
3238			 
3238					FORTH_DSP_POP 
3238 cd c7 22			call macro_forth_dsp_pop 
323b				endm 
# End of macro FORTH_DSP_POP
323b			 
323b			 
323b			 
323b				       NEXTW 
323b c3 c5 23			jp macro_next 
323e				endm 
# End of macro NEXTW
323e			.GET2: 
323e				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
323e 6f				db WORD_SYS_CORE+91             
323f 73 32			dw .BANG2            
3241 03				db 2 + 1 
3242 .. 00			db "2@",0              
3245				endm 
# End of macro CWHEAD
3245			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3245					if DEBUG_FORTH_WORDS_KEY 
3245						DMARK "2A_" 
3245 f5				push af  
3246 3a 5a 32			ld a, (.dmark)  
3249 32 a6 fd			ld (debug_mark),a  
324c 3a 5b 32			ld a, (.dmark+1)  
324f 32 a7 fd			ld (debug_mark+1),a  
3252 3a 5c 32			ld a, (.dmark+2)  
3255 32 a8 fd			ld (debug_mark+2),a  
3258 18 03			jr .pastdmark  
325a ..			.dmark: db "2A_"  
325d f1			.pastdmark: pop af  
325e			endm  
# End of macro DMARK
325e						CALLMONITOR 
325e cd aa fd			call debug_vector  
3261				endm  
# End of macro CALLMONITOR
3261					endif 
3261			 
3261					FORTH_DSP_VALUEHL 
3261 cd 0f 22			call macro_dsp_valuehl 
3264				endm 
# End of macro FORTH_DSP_VALUEHL
3264			 
3264 e5					push hl   ; save address 
3265			 
3265					FORTH_DSP_POP 
3265 cd c7 22			call macro_forth_dsp_pop 
3268				endm 
# End of macro FORTH_DSP_POP
3268			 
3268 e1					pop hl 
3269			 
3269 5e					ld e, (hl) 
326a 23					inc hl 
326b 56					ld d, (hl) 
326c			 
326c eb					ex de, hl 
326d			 
326d cd 18 20				call forth_push_numhl 
3270			 
3270				       NEXTW 
3270 c3 c5 23			jp macro_next 
3273				endm 
# End of macro NEXTW
3273			.BANG2: 
3273				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
3273 6f				db WORD_SYS_CORE+91             
3274 ab 32			dw .CONFIG            
3276 03				db 2 + 1 
3277 .. 00			db "2!",0              
327a				endm 
# End of macro CWHEAD
327a			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
327a					if DEBUG_FORTH_WORDS_KEY 
327a						DMARK "2S_" 
327a f5				push af  
327b 3a 8f 32			ld a, (.dmark)  
327e 32 a6 fd			ld (debug_mark),a  
3281 3a 90 32			ld a, (.dmark+1)  
3284 32 a7 fd			ld (debug_mark+1),a  
3287 3a 91 32			ld a, (.dmark+2)  
328a 32 a8 fd			ld (debug_mark+2),a  
328d 18 03			jr .pastdmark  
328f ..			.dmark: db "2S_"  
3292 f1			.pastdmark: pop af  
3293			endm  
# End of macro DMARK
3293						CALLMONITOR 
3293 cd aa fd			call debug_vector  
3296				endm  
# End of macro CALLMONITOR
3296					endif 
3296			 
3296					FORTH_DSP_VALUEHL 
3296 cd 0f 22			call macro_dsp_valuehl 
3299				endm 
# End of macro FORTH_DSP_VALUEHL
3299			 
3299 e5					push hl   ; save address 
329a			 
329a			 
329a					FORTH_DSP_POP 
329a cd c7 22			call macro_forth_dsp_pop 
329d				endm 
# End of macro FORTH_DSP_POP
329d			 
329d					 
329d					FORTH_DSP_VALUEHL 
329d cd 0f 22			call macro_dsp_valuehl 
32a0				endm 
# End of macro FORTH_DSP_VALUEHL
32a0			 
32a0					FORTH_DSP_POP 
32a0 cd c7 22			call macro_forth_dsp_pop 
32a3				endm 
# End of macro FORTH_DSP_POP
32a3			 
32a3 eb					ex de, hl    ; value now in de 
32a4			 
32a4 e1					pop hl 
32a5			 
32a5 73					ld (hl), e 
32a6			 
32a6 23					inc hl 
32a7			 
32a7 72					ld (hl), d 
32a8			 
32a8			 
32a8				       NEXTW 
32a8 c3 c5 23			jp macro_next 
32ab				endm 
# End of macro NEXTW
32ab			.CONFIG: 
32ab				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
32ab 6f				db WORD_SYS_CORE+91             
32ac bc 32			dw .ADTOS            
32ae 07				db 6 + 1 
32af .. 00			db "CONFIG",0              
32b6				endm 
# End of macro CWHEAD
32b6			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
32b6			 
32b6 cd 50 15				call config 
32b9					NEXTW 
32b9 c3 c5 23			jp macro_next 
32bc				endm 
# End of macro NEXTW
32bc			 
32bc			.ADTOS: 
32bc				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
32bc 6f				db WORD_SYS_CORE+91             
32bd d2 32			dw .SBTOS            
32bf 03				db 2 + 1 
32c0 .. 00			db "1+",0              
32c3				endm 
# End of macro CWHEAD
32c3			; | 1+ ( u -- u )  Increment value on TOS | DONE 
32c3			 
32c3					FORTH_DSP_VALUEHL 
32c3 cd 0f 22			call macro_dsp_valuehl 
32c6				endm 
# End of macro FORTH_DSP_VALUEHL
32c6 e5					push hl 
32c7			 
32c7					FORTH_DSP_POP 
32c7 cd c7 22			call macro_forth_dsp_pop 
32ca				endm 
# End of macro FORTH_DSP_POP
32ca e1					pop hl 
32cb			 
32cb 23					inc hl 
32cc cd 18 20				call forth_push_numhl 
32cf					 
32cf					NEXTW 
32cf c3 c5 23			jp macro_next 
32d2				endm 
# End of macro NEXTW
32d2			.SBTOS: 
32d2				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
32d2 6f				db WORD_SYS_CORE+91             
32d3 e8 32			dw .ADSTORE            
32d5 03				db 2 + 1 
32d6 .. 00			db "1-",0              
32d9				endm 
# End of macro CWHEAD
32d9			; | 1- ( u -- u )  Decrement value on TOS | DONE 
32d9			 
32d9					FORTH_DSP_VALUEHL 
32d9 cd 0f 22			call macro_dsp_valuehl 
32dc				endm 
# End of macro FORTH_DSP_VALUEHL
32dc e5					push hl 
32dd			 
32dd					FORTH_DSP_POP 
32dd cd c7 22			call macro_forth_dsp_pop 
32e0				endm 
# End of macro FORTH_DSP_POP
32e0 e1					pop hl 
32e1			 
32e1 2b					dec hl 
32e2 cd 18 20				call forth_push_numhl 
32e5					 
32e5					NEXTW 
32e5 c3 c5 23			jp macro_next 
32e8				endm 
# End of macro NEXTW
32e8			.ADSTORE: 
32e8				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
32e8 6f				db WORD_SYS_CORE+91             
32e9 fe 32			dw .ADWSTORE            
32eb 04				db 3 + 1 
32ec .. 00			db "1+!",0              
32f0				endm 
# End of macro CWHEAD
32f0			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
32f0			 
32f0					FORTH_DSP_VALUEHL 
32f0 cd 0f 22			call macro_dsp_valuehl 
32f3				endm 
# End of macro FORTH_DSP_VALUEHL
32f3 e5					push hl 
32f4			 
32f4					FORTH_DSP_POP 
32f4 cd c7 22			call macro_forth_dsp_pop 
32f7				endm 
# End of macro FORTH_DSP_POP
32f7 e1					pop hl 
32f8			 
32f8 7e					ld a, (hl) 
32f9 3c					inc a 
32fa 77					ld (hl), a 
32fb					 
32fb					NEXTW 
32fb c3 c5 23			jp macro_next 
32fe				endm 
# End of macro NEXTW
32fe			.ADWSTORE: 
32fe				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
32fe 6f				db WORD_SYS_CORE+91             
32ff 1c 33			dw .SBSTORE            
3301 05				db 4 + 1 
3302 .. 00			db "1+2!",0              
3307				endm 
# End of macro CWHEAD
3307			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
3307			 
3307					FORTH_DSP_VALUEHL 
3307 cd 0f 22			call macro_dsp_valuehl 
330a				endm 
# End of macro FORTH_DSP_VALUEHL
330a e5					push hl 
330b			 
330b					FORTH_DSP_POP 
330b cd c7 22			call macro_forth_dsp_pop 
330e				endm 
# End of macro FORTH_DSP_POP
330e e1					pop hl 
330f			 
330f e5					push hl 
3310			 
3310 cd 47 23				call loadwordinhl 
3313 23					inc hl 
3314			 
3314 d1					pop de 
3315 eb					ex de, hl 
3316 73					ld (hl), e 
3317 23					inc hl 
3318 72					ld (hl), d 
3319					 
3319					NEXTW 
3319 c3 c5 23			jp macro_next 
331c				endm 
# End of macro NEXTW
331c			.SBSTORE: 
331c				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
331c 6f				db WORD_SYS_CORE+91             
331d 32 33			dw .SBWSTORE            
331f 04				db 3 + 1 
3320 .. 00			db "1-!",0              
3324				endm 
# End of macro CWHEAD
3324			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
3324			 
3324					FORTH_DSP_VALUEHL 
3324 cd 0f 22			call macro_dsp_valuehl 
3327				endm 
# End of macro FORTH_DSP_VALUEHL
3327 e5					push hl 
3328			 
3328					FORTH_DSP_POP 
3328 cd c7 22			call macro_forth_dsp_pop 
332b				endm 
# End of macro FORTH_DSP_POP
332b e1					pop hl 
332c			 
332c 7e					ld a, (hl) 
332d 3d					dec a 
332e 77					ld (hl), a 
332f					 
332f					NEXTW 
332f c3 c5 23			jp macro_next 
3332				endm 
# End of macro NEXTW
3332			.SBWSTORE: 
3332				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
3332 6f				db WORD_SYS_CORE+91             
3333 50 33			dw .ENDCORE            
3335 05				db 4 + 1 
3336 .. 00			db "1-2!",0              
333b				endm 
# End of macro CWHEAD
333b			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
333b			 
333b					FORTH_DSP_VALUEHL 
333b cd 0f 22			call macro_dsp_valuehl 
333e				endm 
# End of macro FORTH_DSP_VALUEHL
333e e5					push hl 
333f			 
333f					FORTH_DSP_POP 
333f cd c7 22			call macro_forth_dsp_pop 
3342				endm 
# End of macro FORTH_DSP_POP
3342 e1					pop hl 
3343			 
3343 e5					push hl 
3344			 
3344 cd 47 23				call loadwordinhl 
3347 2b					dec hl 
3348			 
3348 d1					pop de 
3349 eb					ex de, hl 
334a 73					ld (hl), e 
334b 23					inc hl 
334c 72					ld (hl), d 
334d					 
334d					NEXTW 
334d c3 c5 23			jp macro_next 
3350				endm 
# End of macro NEXTW
3350			.ENDCORE: 
3350			 
3350			; eof 
3350			 
3350			 
# End of file forth_words_core.asm
3350			include "forth_words_flow.asm" 
3350			 
3350			; | ## Program Flow Words 
3350			 
3350			.IF: 
3350				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
3350 1e				db WORD_SYS_CORE+10             
3351 45 34			dw .THEN            
3353 03				db 2 + 1 
3354 .. 00			db "IF",0              
3357				endm 
# End of macro CWHEAD
3357			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
3357			; 
3357					if DEBUG_FORTH_WORDS_KEY 
3357						DMARK "IF." 
3357 f5				push af  
3358 3a 6c 33			ld a, (.dmark)  
335b 32 a6 fd			ld (debug_mark),a  
335e 3a 6d 33			ld a, (.dmark+1)  
3361 32 a7 fd			ld (debug_mark+1),a  
3364 3a 6e 33			ld a, (.dmark+2)  
3367 32 a8 fd			ld (debug_mark+2),a  
336a 18 03			jr .pastdmark  
336c ..			.dmark: db "IF."  
336f f1			.pastdmark: pop af  
3370			endm  
# End of macro DMARK
3370						CALLMONITOR 
3370 cd aa fd			call debug_vector  
3373				endm  
# End of macro CALLMONITOR
3373					endif 
3373			; eval TOS 
3373			 
3373				FORTH_DSP_VALUEHL 
3373 cd 0f 22			call macro_dsp_valuehl 
3376				endm 
# End of macro FORTH_DSP_VALUEHL
3376			 
3376			;	push hl 
3376				FORTH_DSP_POP 
3376 cd c7 22			call macro_forth_dsp_pop 
3379				endm 
# End of macro FORTH_DSP_POP
3379			;	pop hl 
3379			 
3379					if DEBUG_FORTH_WORDS 
3379						DMARK "IF1" 
3379 f5				push af  
337a 3a 8e 33			ld a, (.dmark)  
337d 32 a6 fd			ld (debug_mark),a  
3380 3a 8f 33			ld a, (.dmark+1)  
3383 32 a7 fd			ld (debug_mark+1),a  
3386 3a 90 33			ld a, (.dmark+2)  
3389 32 a8 fd			ld (debug_mark+2),a  
338c 18 03			jr .pastdmark  
338e ..			.dmark: db "IF1"  
3391 f1			.pastdmark: pop af  
3392			endm  
# End of macro DMARK
3392						CALLMONITOR 
3392 cd aa fd			call debug_vector  
3395				endm  
# End of macro CALLMONITOR
3395					endif 
3395 b7				or a        ; clear carry flag 
3396 11 00 00			ld de, 0 
3399 eb				ex de,hl 
339a ed 52			sbc hl, de 
339c c2 26 34			jp nz, .iftrue 
339f			 
339f					if DEBUG_FORTH_WORDS 
339f						DMARK "IF2" 
339f f5				push af  
33a0 3a b4 33			ld a, (.dmark)  
33a3 32 a6 fd			ld (debug_mark),a  
33a6 3a b5 33			ld a, (.dmark+1)  
33a9 32 a7 fd			ld (debug_mark+1),a  
33ac 3a b6 33			ld a, (.dmark+2)  
33af 32 a8 fd			ld (debug_mark+2),a  
33b2 18 03			jr .pastdmark  
33b4 ..			.dmark: db "IF2"  
33b7 f1			.pastdmark: pop af  
33b8			endm  
# End of macro DMARK
33b8						CALLMONITOR 
33b8 cd aa fd			call debug_vector  
33bb				endm  
# End of macro CALLMONITOR
33bb					endif 
33bb			 
33bb			; if not true then skip to THEN 
33bb			 
33bb				; TODO get tok_ptr 
33bb				; TODO consume toks until we get to THEN 
33bb			 
33bb 2a fd f3			ld hl, (os_tok_ptr) 
33be					if DEBUG_FORTH_WORDS 
33be						DMARK "IF3" 
33be f5				push af  
33bf 3a d3 33			ld a, (.dmark)  
33c2 32 a6 fd			ld (debug_mark),a  
33c5 3a d4 33			ld a, (.dmark+1)  
33c8 32 a7 fd			ld (debug_mark+1),a  
33cb 3a d5 33			ld a, (.dmark+2)  
33ce 32 a8 fd			ld (debug_mark+2),a  
33d1 18 03			jr .pastdmark  
33d3 ..			.dmark: db "IF3"  
33d6 f1			.pastdmark: pop af  
33d7			endm  
# End of macro DMARK
33d7						CALLMONITOR 
33d7 cd aa fd			call debug_vector  
33da				endm  
# End of macro CALLMONITOR
33da						 
33da					endif 
33da 11 21 34			ld de, .ifthen 
33dd					if DEBUG_FORTH_WORDS 
33dd						DMARK "IF4" 
33dd f5				push af  
33de 3a f2 33			ld a, (.dmark)  
33e1 32 a6 fd			ld (debug_mark),a  
33e4 3a f3 33			ld a, (.dmark+1)  
33e7 32 a7 fd			ld (debug_mark+1),a  
33ea 3a f4 33			ld a, (.dmark+2)  
33ed 32 a8 fd			ld (debug_mark+2),a  
33f0 18 03			jr .pastdmark  
33f2 ..			.dmark: db "IF4"  
33f5 f1			.pastdmark: pop af  
33f6			endm  
# End of macro DMARK
33f6						CALLMONITOR 
33f6 cd aa fd			call debug_vector  
33f9				endm  
# End of macro CALLMONITOR
33f9					endif 
33f9 cd e0 24			call findnexttok  
33fc			 
33fc					if DEBUG_FORTH_WORDS 
33fc						DMARK "IF5" 
33fc f5				push af  
33fd 3a 11 34			ld a, (.dmark)  
3400 32 a6 fd			ld (debug_mark),a  
3403 3a 12 34			ld a, (.dmark+1)  
3406 32 a7 fd			ld (debug_mark+1),a  
3409 3a 13 34			ld a, (.dmark+2)  
340c 32 a8 fd			ld (debug_mark+2),a  
340f 18 03			jr .pastdmark  
3411 ..			.dmark: db "IF5"  
3414 f1			.pastdmark: pop af  
3415			endm  
# End of macro DMARK
3415						CALLMONITOR 
3415 cd aa fd			call debug_vector  
3418				endm  
# End of macro CALLMONITOR
3418					endif 
3418				; TODO replace below with ; exec using tok_ptr 
3418 22 fd f3			ld (os_tok_ptr), hl 
341b c3 56 24			jp exec1 
341e				NEXTW 
341e c3 c5 23			jp macro_next 
3421				endm 
# End of macro NEXTW
3421			 
3421 .. 00		.ifthen:  db "THEN",0 
3426			 
3426			.iftrue:		 
3426				; Exec next words normally 
3426			 
3426				; if true then exec following IF as normal 
3426					if DEBUG_FORTH_WORDS 
3426						DMARK "IFT" 
3426 f5				push af  
3427 3a 3b 34			ld a, (.dmark)  
342a 32 a6 fd			ld (debug_mark),a  
342d 3a 3c 34			ld a, (.dmark+1)  
3430 32 a7 fd			ld (debug_mark+1),a  
3433 3a 3d 34			ld a, (.dmark+2)  
3436 32 a8 fd			ld (debug_mark+2),a  
3439 18 03			jr .pastdmark  
343b ..			.dmark: db "IFT"  
343e f1			.pastdmark: pop af  
343f			endm  
# End of macro DMARK
343f						CALLMONITOR 
343f cd aa fd			call debug_vector  
3442				endm  
# End of macro CALLMONITOR
3442					endif 
3442			 
3442					NEXTW 
3442 c3 c5 23			jp macro_next 
3445				endm 
# End of macro NEXTW
3445			.THEN: 
3445				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3445 1f				db WORD_SYS_CORE+11             
3446 6d 34			dw .ELSE            
3448 05				db 4 + 1 
3449 .. 00			db "THEN",0              
344e				endm 
# End of macro CWHEAD
344e			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
344e					if DEBUG_FORTH_WORDS_KEY 
344e						DMARK "THN" 
344e f5				push af  
344f 3a 63 34			ld a, (.dmark)  
3452 32 a6 fd			ld (debug_mark),a  
3455 3a 64 34			ld a, (.dmark+1)  
3458 32 a7 fd			ld (debug_mark+1),a  
345b 3a 65 34			ld a, (.dmark+2)  
345e 32 a8 fd			ld (debug_mark+2),a  
3461 18 03			jr .pastdmark  
3463 ..			.dmark: db "THN"  
3466 f1			.pastdmark: pop af  
3467			endm  
# End of macro DMARK
3467						CALLMONITOR 
3467 cd aa fd			call debug_vector  
346a				endm  
# End of macro CALLMONITOR
346a					endif 
346a					NEXTW 
346a c3 c5 23			jp macro_next 
346d				endm 
# End of macro NEXTW
346d			.ELSE: 
346d				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
346d 20				db WORD_SYS_CORE+12             
346e 95 34			dw .DO            
3470 03				db 2 + 1 
3471 .. 00			db "ELSE",0              
3476				endm 
# End of macro CWHEAD
3476			; | ELSE ( -- ) Not supported - does nothing | TODO 
3476			 
3476					if DEBUG_FORTH_WORDS_KEY 
3476						DMARK "ELS" 
3476 f5				push af  
3477 3a 8b 34			ld a, (.dmark)  
347a 32 a6 fd			ld (debug_mark),a  
347d 3a 8c 34			ld a, (.dmark+1)  
3480 32 a7 fd			ld (debug_mark+1),a  
3483 3a 8d 34			ld a, (.dmark+2)  
3486 32 a8 fd			ld (debug_mark+2),a  
3489 18 03			jr .pastdmark  
348b ..			.dmark: db "ELS"  
348e f1			.pastdmark: pop af  
348f			endm  
# End of macro DMARK
348f						CALLMONITOR 
348f cd aa fd			call debug_vector  
3492				endm  
# End of macro CALLMONITOR
3492					endif 
3492			 
3492			 
3492					NEXTW 
3492 c3 c5 23			jp macro_next 
3495				endm 
# End of macro NEXTW
3495			.DO: 
3495				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3495 21				db WORD_SYS_CORE+13             
3496 bc 35			dw .LOOP            
3498 03				db 2 + 1 
3499 .. 00			db "DO",0              
349c				endm 
# End of macro CWHEAD
349c			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
349c			 
349c					if DEBUG_FORTH_WORDS_KEY 
349c						DMARK "DO." 
349c f5				push af  
349d 3a b1 34			ld a, (.dmark)  
34a0 32 a6 fd			ld (debug_mark),a  
34a3 3a b2 34			ld a, (.dmark+1)  
34a6 32 a7 fd			ld (debug_mark+1),a  
34a9 3a b3 34			ld a, (.dmark+2)  
34ac 32 a8 fd			ld (debug_mark+2),a  
34af 18 03			jr .pastdmark  
34b1 ..			.dmark: db "DO."  
34b4 f1			.pastdmark: pop af  
34b5			endm  
# End of macro DMARK
34b5						CALLMONITOR 
34b5 cd aa fd			call debug_vector  
34b8				endm  
# End of macro CALLMONITOR
34b8					endif 
34b8			;  push pc to rsp stack past the DO 
34b8			 
34b8 2a fd f3				ld hl, (os_tok_ptr) 
34bb 23					inc hl   ; D 
34bc 23					inc hl  ; O 
34bd 23					inc hl   ; null 
34be					if DEBUG_FORTH_WORDS 
34be						DMARK "DO2" 
34be f5				push af  
34bf 3a d3 34			ld a, (.dmark)  
34c2 32 a6 fd			ld (debug_mark),a  
34c5 3a d4 34			ld a, (.dmark+1)  
34c8 32 a7 fd			ld (debug_mark+1),a  
34cb 3a d5 34			ld a, (.dmark+2)  
34ce 32 a8 fd			ld (debug_mark+2),a  
34d1 18 03			jr .pastdmark  
34d3 ..			.dmark: db "DO2"  
34d6 f1			.pastdmark: pop af  
34d7			endm  
# End of macro DMARK
34d7						CALLMONITOR 
34d7 cd aa fd			call debug_vector  
34da				endm  
# End of macro CALLMONITOR
34da					endif 
34da					FORTH_RSP_NEXT 
34da cd bf 1f			call macro_forth_rsp_next 
34dd				endm 
# End of macro FORTH_RSP_NEXT
34dd					if DEBUG_FORTH_WORDS 
34dd						DMARK "DO3" 
34dd f5				push af  
34de 3a f2 34			ld a, (.dmark)  
34e1 32 a6 fd			ld (debug_mark),a  
34e4 3a f3 34			ld a, (.dmark+1)  
34e7 32 a7 fd			ld (debug_mark+1),a  
34ea 3a f4 34			ld a, (.dmark+2)  
34ed 32 a8 fd			ld (debug_mark+2),a  
34f0 18 03			jr .pastdmark  
34f2 ..			.dmark: db "DO3"  
34f5 f1			.pastdmark: pop af  
34f6			endm  
# End of macro DMARK
34f6						CALLMONITOR 
34f6 cd aa fd			call debug_vector  
34f9				endm  
# End of macro CALLMONITOR
34f9					endif 
34f9			 
34f9					;if DEBUG_FORTH_WORDS 
34f9				;		push hl 
34f9			;		endif  
34f9			 
34f9			; get counters from data stack 
34f9			 
34f9			 
34f9					FORTH_DSP_VALUEHL 
34f9 cd 0f 22			call macro_dsp_valuehl 
34fc				endm 
# End of macro FORTH_DSP_VALUEHL
34fc e5					push hl		 ; hl now has starting counter which needs to be tos 
34fd			 
34fd					if DEBUG_FORTH_WORDS 
34fd						DMARK "DO4" 
34fd f5				push af  
34fe 3a 12 35			ld a, (.dmark)  
3501 32 a6 fd			ld (debug_mark),a  
3504 3a 13 35			ld a, (.dmark+1)  
3507 32 a7 fd			ld (debug_mark+1),a  
350a 3a 14 35			ld a, (.dmark+2)  
350d 32 a8 fd			ld (debug_mark+2),a  
3510 18 03			jr .pastdmark  
3512 ..			.dmark: db "DO4"  
3515 f1			.pastdmark: pop af  
3516			endm  
# End of macro DMARK
3516						CALLMONITOR 
3516 cd aa fd			call debug_vector  
3519				endm  
# End of macro CALLMONITOR
3519					endif 
3519					FORTH_DSP_POP 
3519 cd c7 22			call macro_forth_dsp_pop 
351c				endm 
# End of macro FORTH_DSP_POP
351c			 
351c					if DEBUG_FORTH_WORDS 
351c						DMARK "DO5" 
351c f5				push af  
351d 3a 31 35			ld a, (.dmark)  
3520 32 a6 fd			ld (debug_mark),a  
3523 3a 32 35			ld a, (.dmark+1)  
3526 32 a7 fd			ld (debug_mark+1),a  
3529 3a 33 35			ld a, (.dmark+2)  
352c 32 a8 fd			ld (debug_mark+2),a  
352f 18 03			jr .pastdmark  
3531 ..			.dmark: db "DO5"  
3534 f1			.pastdmark: pop af  
3535			endm  
# End of macro DMARK
3535						CALLMONITOR 
3535 cd aa fd			call debug_vector  
3538				endm  
# End of macro CALLMONITOR
3538					endif 
3538			 
3538					FORTH_DSP_VALUEHL 
3538 cd 0f 22			call macro_dsp_valuehl 
353b				endm 
# End of macro FORTH_DSP_VALUEHL
353b			;		push hl		 ; hl now has starting limit counter 
353b			 
353b					if DEBUG_FORTH_WORDS 
353b						DMARK "DO6" 
353b f5				push af  
353c 3a 50 35			ld a, (.dmark)  
353f 32 a6 fd			ld (debug_mark),a  
3542 3a 51 35			ld a, (.dmark+1)  
3545 32 a7 fd			ld (debug_mark+1),a  
3548 3a 52 35			ld a, (.dmark+2)  
354b 32 a8 fd			ld (debug_mark+2),a  
354e 18 03			jr .pastdmark  
3550 ..			.dmark: db "DO6"  
3553 f1			.pastdmark: pop af  
3554			endm  
# End of macro DMARK
3554						CALLMONITOR 
3554 cd aa fd			call debug_vector  
3557				endm  
# End of macro CALLMONITOR
3557					endif 
3557					FORTH_DSP_POP 
3557 cd c7 22			call macro_forth_dsp_pop 
355a				endm 
# End of macro FORTH_DSP_POP
355a			 
355a			; put counters on the loop stack 
355a			 
355a			;		pop hl			 ; limit counter 
355a d1					pop de			; start counter 
355b			 
355b					; push limit counter 
355b			 
355b					if DEBUG_FORTH_WORDS 
355b						DMARK "DO7" 
355b f5				push af  
355c 3a 70 35			ld a, (.dmark)  
355f 32 a6 fd			ld (debug_mark),a  
3562 3a 71 35			ld a, (.dmark+1)  
3565 32 a7 fd			ld (debug_mark+1),a  
3568 3a 72 35			ld a, (.dmark+2)  
356b 32 a8 fd			ld (debug_mark+2),a  
356e 18 03			jr .pastdmark  
3570 ..			.dmark: db "DO7"  
3573 f1			.pastdmark: pop af  
3574			endm  
# End of macro DMARK
3574						CALLMONITOR 
3574 cd aa fd			call debug_vector  
3577				endm  
# End of macro CALLMONITOR
3577					endif 
3577					FORTH_LOOP_NEXT 
3577 cd 40 22			call macro_forth_loop_next 
357a				endm 
# End of macro FORTH_LOOP_NEXT
357a			 
357a					; push start counter 
357a			 
357a eb					ex de, hl 
357b					if DEBUG_FORTH_WORDS 
357b						DMARK "DO7" 
357b f5				push af  
357c 3a 90 35			ld a, (.dmark)  
357f 32 a6 fd			ld (debug_mark),a  
3582 3a 91 35			ld a, (.dmark+1)  
3585 32 a7 fd			ld (debug_mark+1),a  
3588 3a 92 35			ld a, (.dmark+2)  
358b 32 a8 fd			ld (debug_mark+2),a  
358e 18 03			jr .pastdmark  
3590 ..			.dmark: db "DO7"  
3593 f1			.pastdmark: pop af  
3594			endm  
# End of macro DMARK
3594						CALLMONITOR 
3594 cd aa fd			call debug_vector  
3597				endm  
# End of macro CALLMONITOR
3597					endif 
3597					FORTH_LOOP_NEXT 
3597 cd 40 22			call macro_forth_loop_next 
359a				endm 
# End of macro FORTH_LOOP_NEXT
359a			 
359a			 
359a					; init first round of I counter 
359a			 
359a 22 21 f4				ld (os_current_i), hl 
359d			 
359d					if DEBUG_FORTH_WORDS 
359d						DMARK "DO8" 
359d f5				push af  
359e 3a b2 35			ld a, (.dmark)  
35a1 32 a6 fd			ld (debug_mark),a  
35a4 3a b3 35			ld a, (.dmark+1)  
35a7 32 a7 fd			ld (debug_mark+1),a  
35aa 3a b4 35			ld a, (.dmark+2)  
35ad 32 a8 fd			ld (debug_mark+2),a  
35b0 18 03			jr .pastdmark  
35b2 ..			.dmark: db "DO8"  
35b5 f1			.pastdmark: pop af  
35b6			endm  
# End of macro DMARK
35b6						CALLMONITOR 
35b6 cd aa fd			call debug_vector  
35b9				endm  
# End of macro CALLMONITOR
35b9					endif 
35b9			 
35b9					NEXTW 
35b9 c3 c5 23			jp macro_next 
35bc				endm 
# End of macro NEXTW
35bc			.LOOP: 
35bc				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
35bc 22				db WORD_SYS_CORE+14             
35bd d4 36			dw .I            
35bf 05				db 4 + 1 
35c0 .. 00			db "LOOP",0              
35c5				endm 
# End of macro CWHEAD
35c5			; | LOOP ( -- ) Increment and test loop counter  | DONE 
35c5			 
35c5				; pop tos as current loop count to hl 
35c5			 
35c5				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
35c5			 
35c5				FORTH_LOOP_TOS 
35c5 cd 73 22			call macro_forth_loop_tos 
35c8				endm 
# End of macro FORTH_LOOP_TOS
35c8 e5				push hl 
35c9			 
35c9					if DEBUG_FORTH_WORDS_KEY 
35c9						DMARK "LOP" 
35c9 f5				push af  
35ca 3a de 35			ld a, (.dmark)  
35cd 32 a6 fd			ld (debug_mark),a  
35d0 3a df 35			ld a, (.dmark+1)  
35d3 32 a7 fd			ld (debug_mark+1),a  
35d6 3a e0 35			ld a, (.dmark+2)  
35d9 32 a8 fd			ld (debug_mark+2),a  
35dc 18 03			jr .pastdmark  
35de ..			.dmark: db "LOP"  
35e1 f1			.pastdmark: pop af  
35e2			endm  
# End of macro DMARK
35e2						CALLMONITOR 
35e2 cd aa fd			call debug_vector  
35e5				endm  
# End of macro CALLMONITOR
35e5					endif 
35e5				; next item on the stack is the limit. get it 
35e5			 
35e5			 
35e5				FORTH_LOOP_POP 
35e5 cd 7d 22			call macro_forth_loop_pop 
35e8				endm 
# End of macro FORTH_LOOP_POP
35e8			 
35e8				FORTH_LOOP_TOS 
35e8 cd 73 22			call macro_forth_loop_tos 
35eb				endm 
# End of macro FORTH_LOOP_TOS
35eb			 
35eb d1				pop de		 ; de = i, hl = limit 
35ec			 
35ec					if DEBUG_FORTH_WORDS 
35ec						DMARK "LP1" 
35ec f5				push af  
35ed 3a 01 36			ld a, (.dmark)  
35f0 32 a6 fd			ld (debug_mark),a  
35f3 3a 02 36			ld a, (.dmark+1)  
35f6 32 a7 fd			ld (debug_mark+1),a  
35f9 3a 03 36			ld a, (.dmark+2)  
35fc 32 a8 fd			ld (debug_mark+2),a  
35ff 18 03			jr .pastdmark  
3601 ..			.dmark: db "LP1"  
3604 f1			.pastdmark: pop af  
3605			endm  
# End of macro DMARK
3605						CALLMONITOR 
3605 cd aa fd			call debug_vector  
3608				endm  
# End of macro CALLMONITOR
3608					endif 
3608			 
3608				; go back to previous word 
3608			 
3608 d5				push de    ; save I for inc later 
3609			 
3609			 
3609				; get limit 
3609				;  is I at limit? 
3609			 
3609			 
3609					if DEBUG_FORTH_WORDS 
3609						DMARK "LP1" 
3609 f5				push af  
360a 3a 1e 36			ld a, (.dmark)  
360d 32 a6 fd			ld (debug_mark),a  
3610 3a 1f 36			ld a, (.dmark+1)  
3613 32 a7 fd			ld (debug_mark+1),a  
3616 3a 20 36			ld a, (.dmark+2)  
3619 32 a8 fd			ld (debug_mark+2),a  
361c 18 03			jr .pastdmark  
361e ..			.dmark: db "LP1"  
3621 f1			.pastdmark: pop af  
3622			endm  
# End of macro DMARK
3622						CALLMONITOR 
3622 cd aa fd			call debug_vector  
3625				endm  
# End of macro CALLMONITOR
3625					endif 
3625			 
3625 ed 52			sbc hl, de 
3627			 
3627			 
3627				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3627			 
3627 20 26				jr nz, .loopnotdone 
3629			 
3629 e1				pop hl   ; get rid of saved I 
362a				FORTH_LOOP_POP     ; get rid of limit 
362a cd 7d 22			call macro_forth_loop_pop 
362d				endm 
# End of macro FORTH_LOOP_POP
362d			 
362d				FORTH_RSP_POP     ; get rid of DO ptr 
362d cd e0 1f			call macro_forth_rsp_pop 
3630				endm 
# End of macro FORTH_RSP_POP
3630			 
3630			if DEBUG_FORTH_WORDS 
3630						DMARK "LP>" 
3630 f5				push af  
3631 3a 45 36			ld a, (.dmark)  
3634 32 a6 fd			ld (debug_mark),a  
3637 3a 46 36			ld a, (.dmark+1)  
363a 32 a7 fd			ld (debug_mark+1),a  
363d 3a 47 36			ld a, (.dmark+2)  
3640 32 a8 fd			ld (debug_mark+2),a  
3643 18 03			jr .pastdmark  
3645 ..			.dmark: db "LP>"  
3648 f1			.pastdmark: pop af  
3649			endm  
# End of macro DMARK
3649				CALLMONITOR 
3649 cd aa fd			call debug_vector  
364c				endm  
# End of macro CALLMONITOR
364c			endif 
364c			 
364c					NEXTW 
364c c3 c5 23			jp macro_next 
364f				endm 
# End of macro NEXTW
364f				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
364f			 
364f			.loopnotdone: 
364f			 
364f e1				pop hl    ; get I 
3650 23				inc hl 
3651			 
3651			   	; save new I 
3651			 
3651			 
3651					; set I counter 
3651			 
3651 22 21 f4				ld (os_current_i), hl 
3654			 
3654					if DEBUG_FORTH_WORDS 
3654						DMARK "LPN" 
3654 f5				push af  
3655 3a 69 36			ld a, (.dmark)  
3658 32 a6 fd			ld (debug_mark),a  
365b 3a 6a 36			ld a, (.dmark+1)  
365e 32 a7 fd			ld (debug_mark+1),a  
3661 3a 6b 36			ld a, (.dmark+2)  
3664 32 a8 fd			ld (debug_mark+2),a  
3667 18 03			jr .pastdmark  
3669 ..			.dmark: db "LPN"  
366c f1			.pastdmark: pop af  
366d			endm  
# End of macro DMARK
366d					CALLMONITOR 
366d cd aa fd			call debug_vector  
3670				endm  
# End of macro CALLMONITOR
3670					endif 
3670					 
3670				FORTH_LOOP_NEXT 
3670 cd 40 22			call macro_forth_loop_next 
3673				endm 
# End of macro FORTH_LOOP_NEXT
3673			 
3673			 
3673					if DEBUG_FORTH_WORDS 
3673 eb						ex de,hl 
3674					endif 
3674			 
3674			;	; get DO ptr 
3674			; 
3674					if DEBUG_FORTH_WORDS 
3674						DMARK "LP7" 
3674 f5				push af  
3675 3a 89 36			ld a, (.dmark)  
3678 32 a6 fd			ld (debug_mark),a  
367b 3a 8a 36			ld a, (.dmark+1)  
367e 32 a7 fd			ld (debug_mark+1),a  
3681 3a 8b 36			ld a, (.dmark+2)  
3684 32 a8 fd			ld (debug_mark+2),a  
3687 18 03			jr .pastdmark  
3689 ..			.dmark: db "LP7"  
368c f1			.pastdmark: pop af  
368d			endm  
# End of macro DMARK
368d					CALLMONITOR 
368d cd aa fd			call debug_vector  
3690				endm  
# End of macro CALLMONITOR
3690					endif 
3690				FORTH_RSP_TOS 
3690 cd d6 1f			call macro_forth_rsp_tos 
3693				endm 
# End of macro FORTH_RSP_TOS
3693			 
3693					if DEBUG_FORTH_WORDS 
3693						DMARK "LP8" 
3693 f5				push af  
3694 3a a8 36			ld a, (.dmark)  
3697 32 a6 fd			ld (debug_mark),a  
369a 3a a9 36			ld a, (.dmark+1)  
369d 32 a7 fd			ld (debug_mark+1),a  
36a0 3a aa 36			ld a, (.dmark+2)  
36a3 32 a8 fd			ld (debug_mark+2),a  
36a6 18 03			jr .pastdmark  
36a8 ..			.dmark: db "LP8"  
36ab f1			.pastdmark: pop af  
36ac			endm  
# End of macro DMARK
36ac					CALLMONITOR 
36ac cd aa fd			call debug_vector  
36af				endm  
# End of macro CALLMONITOR
36af					endif 
36af				;push hl 
36af			 
36af				; not going to DO any more 
36af				; get rid of the RSP pointer as DO will add it back in 
36af				;FORTH_RSP_POP 
36af				;pop hl 
36af			 
36af				;ld hl,(cli_ret_sp) 
36af				;ld e, (hl) 
36af				;inc hl 
36af				;ld d, (hl) 
36af				;ex de,hl 
36af 22 fd f3			ld (os_tok_ptr), hl 
36b2					if DEBUG_FORTH_WORDS 
36b2						DMARK "LP<" 
36b2 f5				push af  
36b3 3a c7 36			ld a, (.dmark)  
36b6 32 a6 fd			ld (debug_mark),a  
36b9 3a c8 36			ld a, (.dmark+1)  
36bc 32 a7 fd			ld (debug_mark+1),a  
36bf 3a c9 36			ld a, (.dmark+2)  
36c2 32 a8 fd			ld (debug_mark+2),a  
36c5 18 03			jr .pastdmark  
36c7 ..			.dmark: db "LP<"  
36ca f1			.pastdmark: pop af  
36cb			endm  
# End of macro DMARK
36cb					CALLMONITOR 
36cb cd aa fd			call debug_vector  
36ce				endm  
# End of macro CALLMONITOR
36ce				endif 
36ce c3 56 24			jp exec1 
36d1			 
36d1					 
36d1			 
36d1			 
36d1					NEXTW 
36d1 c3 c5 23			jp macro_next 
36d4				endm 
# End of macro NEXTW
36d4			.I:  
36d4			 
36d4				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
36d4 5e				db WORD_SYS_CORE+74             
36d5 ff 36			dw .DLOOP            
36d7 02				db 1 + 1 
36d8 .. 00			db "I",0              
36da				endm 
# End of macro CWHEAD
36da			; | I ( -- ) Current loop counter | DONE 
36da					if DEBUG_FORTH_WORDS_KEY 
36da						DMARK "I.." 
36da f5				push af  
36db 3a ef 36			ld a, (.dmark)  
36de 32 a6 fd			ld (debug_mark),a  
36e1 3a f0 36			ld a, (.dmark+1)  
36e4 32 a7 fd			ld (debug_mark+1),a  
36e7 3a f1 36			ld a, (.dmark+2)  
36ea 32 a8 fd			ld (debug_mark+2),a  
36ed 18 03			jr .pastdmark  
36ef ..			.dmark: db "I.."  
36f2 f1			.pastdmark: pop af  
36f3			endm  
# End of macro DMARK
36f3						CALLMONITOR 
36f3 cd aa fd			call debug_vector  
36f6				endm  
# End of macro CALLMONITOR
36f6					endif 
36f6			 
36f6 2a 21 f4				ld hl,(os_current_i) 
36f9 cd 18 20				call forth_push_numhl 
36fc			 
36fc					NEXTW 
36fc c3 c5 23			jp macro_next 
36ff				endm 
# End of macro NEXTW
36ff			.DLOOP: 
36ff				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
36ff 5f				db WORD_SYS_CORE+75             
3700 e0 37			dw .REPEAT            
3702 06				db 5 + 1 
3703 .. 00			db "-LOOP",0              
3709				endm 
# End of macro CWHEAD
3709			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3709				; pop tos as current loop count to hl 
3709					if DEBUG_FORTH_WORDS_KEY 
3709						DMARK "-LP" 
3709 f5				push af  
370a 3a 1e 37			ld a, (.dmark)  
370d 32 a6 fd			ld (debug_mark),a  
3710 3a 1f 37			ld a, (.dmark+1)  
3713 32 a7 fd			ld (debug_mark+1),a  
3716 3a 20 37			ld a, (.dmark+2)  
3719 32 a8 fd			ld (debug_mark+2),a  
371c 18 03			jr .pastdmark  
371e ..			.dmark: db "-LP"  
3721 f1			.pastdmark: pop af  
3722			endm  
# End of macro DMARK
3722						CALLMONITOR 
3722 cd aa fd			call debug_vector  
3725				endm  
# End of macro CALLMONITOR
3725					endif 
3725			 
3725				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3725			 
3725				FORTH_LOOP_TOS 
3725 cd 73 22			call macro_forth_loop_tos 
3728				endm 
# End of macro FORTH_LOOP_TOS
3728 e5				push hl 
3729			 
3729					if DEBUG_FORTH_WORDS 
3729						DMARK "-LP" 
3729 f5				push af  
372a 3a 3e 37			ld a, (.dmark)  
372d 32 a6 fd			ld (debug_mark),a  
3730 3a 3f 37			ld a, (.dmark+1)  
3733 32 a7 fd			ld (debug_mark+1),a  
3736 3a 40 37			ld a, (.dmark+2)  
3739 32 a8 fd			ld (debug_mark+2),a  
373c 18 03			jr .pastdmark  
373e ..			.dmark: db "-LP"  
3741 f1			.pastdmark: pop af  
3742			endm  
# End of macro DMARK
3742						CALLMONITOR 
3742 cd aa fd			call debug_vector  
3745				endm  
# End of macro CALLMONITOR
3745					endif 
3745				; next item on the stack is the limit. get it 
3745			 
3745			 
3745				FORTH_LOOP_POP 
3745 cd 7d 22			call macro_forth_loop_pop 
3748				endm 
# End of macro FORTH_LOOP_POP
3748			 
3748				FORTH_LOOP_TOS 
3748 cd 73 22			call macro_forth_loop_tos 
374b				endm 
# End of macro FORTH_LOOP_TOS
374b			 
374b d1				pop de		 ; de = i, hl = limit 
374c			 
374c					if DEBUG_FORTH_WORDS 
374c						DMARK "-L1" 
374c f5				push af  
374d 3a 61 37			ld a, (.dmark)  
3750 32 a6 fd			ld (debug_mark),a  
3753 3a 62 37			ld a, (.dmark+1)  
3756 32 a7 fd			ld (debug_mark+1),a  
3759 3a 63 37			ld a, (.dmark+2)  
375c 32 a8 fd			ld (debug_mark+2),a  
375f 18 03			jr .pastdmark  
3761 ..			.dmark: db "-L1"  
3764 f1			.pastdmark: pop af  
3765			endm  
# End of macro DMARK
3765						CALLMONITOR 
3765 cd aa fd			call debug_vector  
3768				endm  
# End of macro CALLMONITOR
3768					endif 
3768			 
3768				; go back to previous word 
3768			 
3768 d5				push de    ; save I for inc later 
3769			 
3769			 
3769				; get limit 
3769				;  is I at limit? 
3769			 
3769			 
3769					if DEBUG_FORTH_WORDS 
3769						DMARK "-L1" 
3769 f5				push af  
376a 3a 7e 37			ld a, (.dmark)  
376d 32 a6 fd			ld (debug_mark),a  
3770 3a 7f 37			ld a, (.dmark+1)  
3773 32 a7 fd			ld (debug_mark+1),a  
3776 3a 80 37			ld a, (.dmark+2)  
3779 32 a8 fd			ld (debug_mark+2),a  
377c 18 03			jr .pastdmark  
377e ..			.dmark: db "-L1"  
3781 f1			.pastdmark: pop af  
3782			endm  
# End of macro DMARK
3782						CALLMONITOR 
3782 cd aa fd			call debug_vector  
3785				endm  
# End of macro CALLMONITOR
3785					endif 
3785			 
3785 ed 52			sbc hl, de 
3787			 
3787			 
3787				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3787			 
3787 20 26				jr nz, .mloopnotdone 
3789			 
3789 e1				pop hl   ; get rid of saved I 
378a				FORTH_LOOP_POP     ; get rid of limit 
378a cd 7d 22			call macro_forth_loop_pop 
378d				endm 
# End of macro FORTH_LOOP_POP
378d			 
378d				FORTH_RSP_POP     ; get rid of DO ptr 
378d cd e0 1f			call macro_forth_rsp_pop 
3790				endm 
# End of macro FORTH_RSP_POP
3790			 
3790			if DEBUG_FORTH_WORDS 
3790						DMARK "-L>" 
3790 f5				push af  
3791 3a a5 37			ld a, (.dmark)  
3794 32 a6 fd			ld (debug_mark),a  
3797 3a a6 37			ld a, (.dmark+1)  
379a 32 a7 fd			ld (debug_mark+1),a  
379d 3a a7 37			ld a, (.dmark+2)  
37a0 32 a8 fd			ld (debug_mark+2),a  
37a3 18 03			jr .pastdmark  
37a5 ..			.dmark: db "-L>"  
37a8 f1			.pastdmark: pop af  
37a9			endm  
# End of macro DMARK
37a9				CALLMONITOR 
37a9 cd aa fd			call debug_vector  
37ac				endm  
# End of macro CALLMONITOR
37ac			endif 
37ac			 
37ac					NEXTW 
37ac c3 c5 23			jp macro_next 
37af				endm 
# End of macro NEXTW
37af				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
37af			 
37af			.mloopnotdone: 
37af			 
37af e1				pop hl    ; get I 
37b0 2b				dec hl 
37b1			 
37b1			   	; save new I 
37b1			 
37b1			 
37b1					; set I counter 
37b1			 
37b1 22 21 f4				ld (os_current_i), hl 
37b4			 
37b4					 
37b4				FORTH_LOOP_NEXT 
37b4 cd 40 22			call macro_forth_loop_next 
37b7				endm 
# End of macro FORTH_LOOP_NEXT
37b7			 
37b7			 
37b7					if DEBUG_FORTH_WORDS 
37b7 eb						ex de,hl 
37b8					endif 
37b8			 
37b8			;	; get DO ptr 
37b8			; 
37b8				FORTH_RSP_TOS 
37b8 cd d6 1f			call macro_forth_rsp_tos 
37bb				endm 
# End of macro FORTH_RSP_TOS
37bb			 
37bb				;push hl 
37bb			 
37bb				; not going to DO any more 
37bb				; get rid of the RSP pointer as DO will add it back in 
37bb				;FORTH_RSP_POP 
37bb				;pop hl 
37bb			 
37bb			 
37bb 22 fd f3			ld (os_tok_ptr), hl 
37be					if DEBUG_FORTH_WORDS 
37be						DMARK "-L<" 
37be f5				push af  
37bf 3a d3 37			ld a, (.dmark)  
37c2 32 a6 fd			ld (debug_mark),a  
37c5 3a d4 37			ld a, (.dmark+1)  
37c8 32 a7 fd			ld (debug_mark+1),a  
37cb 3a d5 37			ld a, (.dmark+2)  
37ce 32 a8 fd			ld (debug_mark+2),a  
37d1 18 03			jr .pastdmark  
37d3 ..			.dmark: db "-L<"  
37d6 f1			.pastdmark: pop af  
37d7			endm  
# End of macro DMARK
37d7					CALLMONITOR 
37d7 cd aa fd			call debug_vector  
37da				endm  
# End of macro CALLMONITOR
37da				endif 
37da c3 56 24			jp exec1 
37dd			 
37dd					 
37dd			 
37dd			 
37dd			 
37dd				NEXTW 
37dd c3 c5 23			jp macro_next 
37e0				endm 
# End of macro NEXTW
37e0			 
37e0			 
37e0			 
37e0			 
37e0			.REPEAT: 
37e0				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
37e0 71				db WORD_SYS_CORE+93             
37e1 33 38			dw .UNTIL            
37e3 06				db 5 + 1 
37e4 .. 00			db "REPEAT",0              
37eb				endm 
# End of macro CWHEAD
37eb			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
37eb			;  push pc to rsp stack past the REPEAT 
37eb					if DEBUG_FORTH_WORDS_KEY 
37eb						DMARK "REP" 
37eb f5				push af  
37ec 3a 00 38			ld a, (.dmark)  
37ef 32 a6 fd			ld (debug_mark),a  
37f2 3a 01 38			ld a, (.dmark+1)  
37f5 32 a7 fd			ld (debug_mark+1),a  
37f8 3a 02 38			ld a, (.dmark+2)  
37fb 32 a8 fd			ld (debug_mark+2),a  
37fe 18 03			jr .pastdmark  
3800 ..			.dmark: db "REP"  
3803 f1			.pastdmark: pop af  
3804			endm  
# End of macro DMARK
3804						CALLMONITOR 
3804 cd aa fd			call debug_vector  
3807				endm  
# End of macro CALLMONITOR
3807					endif 
3807			 
3807 2a fd f3				ld hl, (os_tok_ptr) 
380a 23					inc hl   ; R 
380b 23					inc hl  ; E 
380c 23					inc hl   ; P 
380d 23					inc hl   ; E 
380e 23					inc hl   ; A 
380f 23					inc hl   ; T 
3810 23					inc hl   ; zero 
3811					FORTH_RSP_NEXT 
3811 cd bf 1f			call macro_forth_rsp_next 
3814				endm 
# End of macro FORTH_RSP_NEXT
3814			 
3814			 
3814					if DEBUG_FORTH_WORDS 
3814						DMARK "REP" 
3814 f5				push af  
3815 3a 29 38			ld a, (.dmark)  
3818 32 a6 fd			ld (debug_mark),a  
381b 3a 2a 38			ld a, (.dmark+1)  
381e 32 a7 fd			ld (debug_mark+1),a  
3821 3a 2b 38			ld a, (.dmark+2)  
3824 32 a8 fd			ld (debug_mark+2),a  
3827 18 03			jr .pastdmark  
3829 ..			.dmark: db "REP"  
382c f1			.pastdmark: pop af  
382d			endm  
# End of macro DMARK
382d						;pop bc    ; TODO BUG ?????? what is this for???? 
382d						CALLMONITOR 
382d cd aa fd			call debug_vector  
3830				endm  
# End of macro CALLMONITOR
3830					endif 
3830			 
3830					NEXTW 
3830 c3 c5 23			jp macro_next 
3833				endm 
# End of macro NEXTW
3833			;	       NEXTW 
3833			 
3833			.UNTIL: 
3833				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3833 72				db WORD_SYS_CORE+94             
3834 ca 38			dw .ENDFLOW            
3836 06				db 5 + 1 
3837 .. 00			db "UNTIL",0              
383d				endm 
# End of macro CWHEAD
383d			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
383d			 
383d				; pop tos as check 
383d			 
383d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
383d			 
383d				FORTH_DSP_VALUEHL 
383d cd 0f 22			call macro_dsp_valuehl 
3840				endm 
# End of macro FORTH_DSP_VALUEHL
3840			 
3840					if DEBUG_FORTH_WORDS_KEY 
3840						DMARK "UNT" 
3840 f5				push af  
3841 3a 55 38			ld a, (.dmark)  
3844 32 a6 fd			ld (debug_mark),a  
3847 3a 56 38			ld a, (.dmark+1)  
384a 32 a7 fd			ld (debug_mark+1),a  
384d 3a 57 38			ld a, (.dmark+2)  
3850 32 a8 fd			ld (debug_mark+2),a  
3853 18 03			jr .pastdmark  
3855 ..			.dmark: db "UNT"  
3858 f1			.pastdmark: pop af  
3859			endm  
# End of macro DMARK
3859						CALLMONITOR 
3859 cd aa fd			call debug_vector  
385c				endm  
# End of macro CALLMONITOR
385c					endif 
385c			 
385c			;	push hl 
385c				FORTH_DSP_POP 
385c cd c7 22			call macro_forth_dsp_pop 
385f				endm 
# End of macro FORTH_DSP_POP
385f			 
385f			;	pop hl 
385f			 
385f				; test if true 
385f			 
385f cd f8 0f			call ishlzero 
3862			;	ld a,l 
3862			;	add h 
3862			; 
3862			;	cp 0 
3862			 
3862 20 3e			jr nz, .untilnotdone 
3864			 
3864					if DEBUG_FORTH_WORDS 
3864						DMARK "UNf" 
3864 f5				push af  
3865 3a 79 38			ld a, (.dmark)  
3868 32 a6 fd			ld (debug_mark),a  
386b 3a 7a 38			ld a, (.dmark+1)  
386e 32 a7 fd			ld (debug_mark+1),a  
3871 3a 7b 38			ld a, (.dmark+2)  
3874 32 a8 fd			ld (debug_mark+2),a  
3877 18 03			jr .pastdmark  
3879 ..			.dmark: db "UNf"  
387c f1			.pastdmark: pop af  
387d			endm  
# End of macro DMARK
387d						CALLMONITOR 
387d cd aa fd			call debug_vector  
3880				endm  
# End of macro CALLMONITOR
3880					endif 
3880			 
3880			 
3880			 
3880				FORTH_RSP_POP     ; get rid of DO ptr 
3880 cd e0 1f			call macro_forth_rsp_pop 
3883				endm 
# End of macro FORTH_RSP_POP
3883			 
3883			if DEBUG_FORTH_WORDS 
3883						DMARK "UN>" 
3883 f5				push af  
3884 3a 98 38			ld a, (.dmark)  
3887 32 a6 fd			ld (debug_mark),a  
388a 3a 99 38			ld a, (.dmark+1)  
388d 32 a7 fd			ld (debug_mark+1),a  
3890 3a 9a 38			ld a, (.dmark+2)  
3893 32 a8 fd			ld (debug_mark+2),a  
3896 18 03			jr .pastdmark  
3898 ..			.dmark: db "UN>"  
389b f1			.pastdmark: pop af  
389c			endm  
# End of macro DMARK
389c				CALLMONITOR 
389c cd aa fd			call debug_vector  
389f				endm  
# End of macro CALLMONITOR
389f			endif 
389f			 
389f					NEXTW 
389f c3 c5 23			jp macro_next 
38a2				endm 
# End of macro NEXTW
38a2				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
38a2			 
38a2			.untilnotdone: 
38a2			 
38a2			 
38a2			;	; get DO ptr 
38a2			; 
38a2				FORTH_RSP_TOS 
38a2 cd d6 1f			call macro_forth_rsp_tos 
38a5				endm 
# End of macro FORTH_RSP_TOS
38a5			 
38a5				;push hl 
38a5			 
38a5				; not going to DO any more 
38a5				; get rid of the RSP pointer as DO will add it back in 
38a5				;FORTH_RSP_POP 
38a5				;pop hl 
38a5			 
38a5			 
38a5 22 fd f3			ld (os_tok_ptr), hl 
38a8					if DEBUG_FORTH_WORDS 
38a8						DMARK "UN<" 
38a8 f5				push af  
38a9 3a bd 38			ld a, (.dmark)  
38ac 32 a6 fd			ld (debug_mark),a  
38af 3a be 38			ld a, (.dmark+1)  
38b2 32 a7 fd			ld (debug_mark+1),a  
38b5 3a bf 38			ld a, (.dmark+2)  
38b8 32 a8 fd			ld (debug_mark+2),a  
38bb 18 03			jr .pastdmark  
38bd ..			.dmark: db "UN<"  
38c0 f1			.pastdmark: pop af  
38c1			endm  
# End of macro DMARK
38c1					CALLMONITOR 
38c1 cd aa fd			call debug_vector  
38c4				endm  
# End of macro CALLMONITOR
38c4				endif 
38c4 c3 56 24			jp exec1 
38c7			 
38c7					 
38c7			 
38c7			 
38c7					NEXTW 
38c7 c3 c5 23			jp macro_next 
38ca				endm 
# End of macro NEXTW
38ca			 
38ca			 
38ca			.ENDFLOW: 
38ca			 
38ca			; eof 
38ca			 
# End of file forth_words_flow.asm
38ca			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
38ca			include "forth_words_logic.asm" 
38ca			 
38ca			; | ## Logic Words 
38ca			 
38ca			.NOT: 
38ca				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
38ca 2d				db WORD_SYS_CORE+25             
38cb 12 39			dw .IS            
38cd 04				db 3 + 1 
38ce .. 00			db "NOT",0              
38d2				endm 
# End of macro CWHEAD
38d2			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
38d2					if DEBUG_FORTH_WORDS_KEY 
38d2						DMARK "NOT" 
38d2 f5				push af  
38d3 3a e7 38			ld a, (.dmark)  
38d6 32 a6 fd			ld (debug_mark),a  
38d9 3a e8 38			ld a, (.dmark+1)  
38dc 32 a7 fd			ld (debug_mark+1),a  
38df 3a e9 38			ld a, (.dmark+2)  
38e2 32 a8 fd			ld (debug_mark+2),a  
38e5 18 03			jr .pastdmark  
38e7 ..			.dmark: db "NOT"  
38ea f1			.pastdmark: pop af  
38eb			endm  
# End of macro DMARK
38eb						CALLMONITOR 
38eb cd aa fd			call debug_vector  
38ee				endm  
# End of macro CALLMONITOR
38ee					endif 
38ee					FORTH_DSP 
38ee cd d5 21			call macro_forth_dsp 
38f1				endm 
# End of macro FORTH_DSP
38f1 7e					ld a,(hl)	; get type of value on TOS 
38f2 fe 02				cp DS_TYPE_INUM  
38f4 28 03				jr z, .noti 
38f6					NEXTW 
38f6 c3 c5 23			jp macro_next 
38f9				endm 
# End of macro NEXTW
38f9			.noti:          FORTH_DSP_VALUEHL 
38f9 cd 0f 22			call macro_dsp_valuehl 
38fc				endm 
# End of macro FORTH_DSP_VALUEHL
38fc			;		push hl 
38fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
38fc cd c7 22			call macro_forth_dsp_pop 
38ff				endm 
# End of macro FORTH_DSP_POP
38ff			;		pop hl 
38ff 3e 00				ld a,0 
3901 bd					cp l 
3902 28 04				jr z, .not2t 
3904 2e 00				ld l, 0 
3906 18 02				jr .notip 
3908			 
3908 2e ff		.not2t:		ld l, 255 
390a			 
390a 26 00		.notip:		ld h, 0	 
390c			 
390c cd 18 20				call forth_push_numhl 
390f					NEXTW 
390f c3 c5 23			jp macro_next 
3912				endm 
# End of macro NEXTW
3912			 
3912			.IS: 
3912				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3912 2d				db WORD_SYS_CORE+25             
3913 38 39			dw .LZERO            
3915 03				db 2 + 1 
3916 .. 00			db "IS",0              
3919				endm 
# End of macro CWHEAD
3919			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3919					if DEBUG_FORTH_WORDS_KEY 
3919						DMARK "IS." 
3919 f5				push af  
391a 3a 2e 39			ld a, (.dmark)  
391d 32 a6 fd			ld (debug_mark),a  
3920 3a 2f 39			ld a, (.dmark+1)  
3923 32 a7 fd			ld (debug_mark+1),a  
3926 3a 30 39			ld a, (.dmark+2)  
3929 32 a8 fd			ld (debug_mark+2),a  
392c 18 03			jr .pastdmark  
392e ..			.dmark: db "IS."  
3931 f1			.pastdmark: pop af  
3932			endm  
# End of macro DMARK
3932						CALLMONITOR 
3932 cd aa fd			call debug_vector  
3935				endm  
# End of macro CALLMONITOR
3935					endif 
3935					NEXTW 
3935 c3 c5 23			jp macro_next 
3938				endm 
# End of macro NEXTW
3938			.LZERO: 
3938				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3938 2d				db WORD_SYS_CORE+25             
3939 42 39			dw .TZERO            
393b 03				db 2 + 1 
393c .. 00			db "0<",0              
393f				endm 
# End of macro CWHEAD
393f			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
393f					NEXTW 
393f c3 c5 23			jp macro_next 
3942				endm 
# End of macro NEXTW
3942			.TZERO: 
3942				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3942 2e				db WORD_SYS_CORE+26             
3943 89 39			dw .LESS            
3945 03				db 2 + 1 
3946 .. 00			db "0=",0              
3949				endm 
# End of macro CWHEAD
3949			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3949				; TODO add floating point number detection 
3949					;v5 FORTH_DSP_VALUE 
3949					if DEBUG_FORTH_WORDS_KEY 
3949						DMARK "0=." 
3949 f5				push af  
394a 3a 5e 39			ld a, (.dmark)  
394d 32 a6 fd			ld (debug_mark),a  
3950 3a 5f 39			ld a, (.dmark+1)  
3953 32 a7 fd			ld (debug_mark+1),a  
3956 3a 60 39			ld a, (.dmark+2)  
3959 32 a8 fd			ld (debug_mark+2),a  
395c 18 03			jr .pastdmark  
395e ..			.dmark: db "0=."  
3961 f1			.pastdmark: pop af  
3962			endm  
# End of macro DMARK
3962						CALLMONITOR 
3962 cd aa fd			call debug_vector  
3965				endm  
# End of macro CALLMONITOR
3965					endif 
3965					FORTH_DSP 
3965 cd d5 21			call macro_forth_dsp 
3968				endm 
# End of macro FORTH_DSP
3968 7e					ld a,(hl)	; get type of value on TOS 
3969 fe 02				cp DS_TYPE_INUM  
396b 28 00				jr z, .tz_inum 
396d			 
396d				if FORTH_ENABLE_FLOATMATH 
396d					jr .tz_done 
396d			 
396d				endif 
396d					 
396d			 
396d			.tz_inum: 
396d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
396d cd 0f 22			call macro_dsp_valuehl 
3970				endm 
# End of macro FORTH_DSP_VALUEHL
3970			 
3970			;		push hl 
3970			 
3970					; destroy value TOS 
3970			 
3970					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3970 cd c7 22			call macro_forth_dsp_pop 
3973				endm 
# End of macro FORTH_DSP_POP
3973			 
3973			;		pop hl 
3973			 
3973 3e 00				ld a,0 
3975			 
3975 bd					cp l 
3976 20 08				jr nz, .tz_notzero 
3978			 
3978 bc					cp h 
3979			 
3979 20 05				jr nz, .tz_notzero 
397b			 
397b			 
397b 21 01 00				ld hl, FORTH_TRUE 
397e 18 03				jr .tz_done 
3980			 
3980 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3983			 
3983					; push value back onto stack for another op etc 
3983			 
3983			.tz_done: 
3983 cd 18 20				call forth_push_numhl 
3986			 
3986					NEXTW 
3986 c3 c5 23			jp macro_next 
3989				endm 
# End of macro NEXTW
3989			.LESS: 
3989				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3989 2f				db WORD_SYS_CORE+27             
398a f2 39			dw .GT            
398c 02				db 1 + 1 
398d .. 00			db "<",0              
398f				endm 
# End of macro CWHEAD
398f			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
398f				; TODO add floating point number detection 
398f					if DEBUG_FORTH_WORDS_KEY 
398f						DMARK "LES" 
398f f5				push af  
3990 3a a4 39			ld a, (.dmark)  
3993 32 a6 fd			ld (debug_mark),a  
3996 3a a5 39			ld a, (.dmark+1)  
3999 32 a7 fd			ld (debug_mark+1),a  
399c 3a a6 39			ld a, (.dmark+2)  
399f 32 a8 fd			ld (debug_mark+2),a  
39a2 18 03			jr .pastdmark  
39a4 ..			.dmark: db "LES"  
39a7 f1			.pastdmark: pop af  
39a8			endm  
# End of macro DMARK
39a8						CALLMONITOR 
39a8 cd aa fd			call debug_vector  
39ab				endm  
# End of macro CALLMONITOR
39ab					endif 
39ab					FORTH_DSP 
39ab cd d5 21			call macro_forth_dsp 
39ae				endm 
# End of macro FORTH_DSP
39ae					;v5 FORTH_DSP_VALUE 
39ae 7e					ld a,(hl)	; get type of value on TOS 
39af fe 02				cp DS_TYPE_INUM  
39b1 28 00				jr z, .less_inum 
39b3			 
39b3				if FORTH_ENABLE_FLOATMATH 
39b3					jr .less_done 
39b3			 
39b3				endif 
39b3					 
39b3			 
39b3			.less_inum: 
39b3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39b3 cd 0f 22			call macro_dsp_valuehl 
39b6				endm 
# End of macro FORTH_DSP_VALUEHL
39b6			 
39b6 e5					push hl  ; u2 
39b7			 
39b7					; destroy value TOS 
39b7			 
39b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39b7 cd c7 22			call macro_forth_dsp_pop 
39ba				endm 
# End of macro FORTH_DSP_POP
39ba			 
39ba			 
39ba					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39ba cd 0f 22			call macro_dsp_valuehl 
39bd				endm 
# End of macro FORTH_DSP_VALUEHL
39bd			 
39bd e5					push hl    ; u1 
39be			 
39be					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39be cd c7 22			call macro_forth_dsp_pop 
39c1				endm 
# End of macro FORTH_DSP_POP
39c1			 
39c1			 
39c1 b7			 or a      ;clear carry flag 
39c2 01 00 00		 ld bc, FORTH_FALSE 
39c5 e1			  pop hl    ; u1 
39c6 d1			  pop de    ; u2 
39c7 ed 52		  sbc hl,de 
39c9 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
39cb			 
39cb 01 01 00		 ld bc, FORTH_TRUE 
39ce			.lscont:  
39ce c5					push bc 
39cf e1					pop hl 
39d0			 
39d0					if DEBUG_FORTH_WORDS 
39d0						DMARK "LT1" 
39d0 f5				push af  
39d1 3a e5 39			ld a, (.dmark)  
39d4 32 a6 fd			ld (debug_mark),a  
39d7 3a e6 39			ld a, (.dmark+1)  
39da 32 a7 fd			ld (debug_mark+1),a  
39dd 3a e7 39			ld a, (.dmark+2)  
39e0 32 a8 fd			ld (debug_mark+2),a  
39e3 18 03			jr .pastdmark  
39e5 ..			.dmark: db "LT1"  
39e8 f1			.pastdmark: pop af  
39e9			endm  
# End of macro DMARK
39e9						CALLMONITOR 
39e9 cd aa fd			call debug_vector  
39ec				endm  
# End of macro CALLMONITOR
39ec					endif 
39ec cd 18 20				call forth_push_numhl 
39ef			 
39ef					NEXTW 
39ef c3 c5 23			jp macro_next 
39f2				endm 
# End of macro NEXTW
39f2			.GT: 
39f2				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
39f2 30				db WORD_SYS_CORE+28             
39f3 5b 3a			dw .EQUAL            
39f5 02				db 1 + 1 
39f6 .. 00			db ">",0              
39f8				endm 
# End of macro CWHEAD
39f8			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
39f8				; TODO add floating point number detection 
39f8					if DEBUG_FORTH_WORDS_KEY 
39f8						DMARK "GRT" 
39f8 f5				push af  
39f9 3a 0d 3a			ld a, (.dmark)  
39fc 32 a6 fd			ld (debug_mark),a  
39ff 3a 0e 3a			ld a, (.dmark+1)  
3a02 32 a7 fd			ld (debug_mark+1),a  
3a05 3a 0f 3a			ld a, (.dmark+2)  
3a08 32 a8 fd			ld (debug_mark+2),a  
3a0b 18 03			jr .pastdmark  
3a0d ..			.dmark: db "GRT"  
3a10 f1			.pastdmark: pop af  
3a11			endm  
# End of macro DMARK
3a11						CALLMONITOR 
3a11 cd aa fd			call debug_vector  
3a14				endm  
# End of macro CALLMONITOR
3a14					endif 
3a14					FORTH_DSP 
3a14 cd d5 21			call macro_forth_dsp 
3a17				endm 
# End of macro FORTH_DSP
3a17					;FORTH_DSP_VALUE 
3a17 7e					ld a,(hl)	; get type of value on TOS 
3a18 fe 02				cp DS_TYPE_INUM  
3a1a 28 00				jr z, .gt_inum 
3a1c			 
3a1c				if FORTH_ENABLE_FLOATMATH 
3a1c					jr .gt_done 
3a1c			 
3a1c				endif 
3a1c					 
3a1c			 
3a1c			.gt_inum: 
3a1c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a1c cd 0f 22			call macro_dsp_valuehl 
3a1f				endm 
# End of macro FORTH_DSP_VALUEHL
3a1f			 
3a1f e5					push hl  ; u2 
3a20			 
3a20					; destroy value TOS 
3a20			 
3a20					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a20 cd c7 22			call macro_forth_dsp_pop 
3a23				endm 
# End of macro FORTH_DSP_POP
3a23			 
3a23			 
3a23					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a23 cd 0f 22			call macro_dsp_valuehl 
3a26				endm 
# End of macro FORTH_DSP_VALUEHL
3a26			 
3a26 e5					push hl    ; u1 
3a27			 
3a27					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a27 cd c7 22			call macro_forth_dsp_pop 
3a2a				endm 
# End of macro FORTH_DSP_POP
3a2a			 
3a2a			 
3a2a b7			 or a      ;clear carry flag 
3a2b 01 00 00		 ld bc, FORTH_FALSE 
3a2e e1			  pop hl    ; u1 
3a2f d1			  pop de    ; u2 
3a30 ed 52		  sbc hl,de 
3a32 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3a34			 
3a34 01 01 00		 ld bc, FORTH_TRUE 
3a37			.gtcont:  
3a37 c5					push bc 
3a38 e1					pop hl 
3a39			 
3a39					if DEBUG_FORTH_WORDS 
3a39						DMARK "GT1" 
3a39 f5				push af  
3a3a 3a 4e 3a			ld a, (.dmark)  
3a3d 32 a6 fd			ld (debug_mark),a  
3a40 3a 4f 3a			ld a, (.dmark+1)  
3a43 32 a7 fd			ld (debug_mark+1),a  
3a46 3a 50 3a			ld a, (.dmark+2)  
3a49 32 a8 fd			ld (debug_mark+2),a  
3a4c 18 03			jr .pastdmark  
3a4e ..			.dmark: db "GT1"  
3a51 f1			.pastdmark: pop af  
3a52			endm  
# End of macro DMARK
3a52						CALLMONITOR 
3a52 cd aa fd			call debug_vector  
3a55				endm  
# End of macro CALLMONITOR
3a55					endif 
3a55 cd 18 20				call forth_push_numhl 
3a58			 
3a58					NEXTW 
3a58 c3 c5 23			jp macro_next 
3a5b				endm 
# End of macro NEXTW
3a5b			.EQUAL: 
3a5b				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3a5b 31				db WORD_SYS_CORE+29             
3a5c c6 3a			dw .ENDLOGIC            
3a5e 02				db 1 + 1 
3a5f .. 00			db "=",0              
3a61				endm 
# End of macro CWHEAD
3a61			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3a61				; TODO add floating point number detection 
3a61					if DEBUG_FORTH_WORDS_KEY 
3a61						DMARK "EQ." 
3a61 f5				push af  
3a62 3a 76 3a			ld a, (.dmark)  
3a65 32 a6 fd			ld (debug_mark),a  
3a68 3a 77 3a			ld a, (.dmark+1)  
3a6b 32 a7 fd			ld (debug_mark+1),a  
3a6e 3a 78 3a			ld a, (.dmark+2)  
3a71 32 a8 fd			ld (debug_mark+2),a  
3a74 18 03			jr .pastdmark  
3a76 ..			.dmark: db "EQ."  
3a79 f1			.pastdmark: pop af  
3a7a			endm  
# End of macro DMARK
3a7a						CALLMONITOR 
3a7a cd aa fd			call debug_vector  
3a7d				endm  
# End of macro CALLMONITOR
3a7d					endif 
3a7d					FORTH_DSP 
3a7d cd d5 21			call macro_forth_dsp 
3a80				endm 
# End of macro FORTH_DSP
3a80					;v5 FORTH_DSP_VALUE 
3a80 7e					ld a,(hl)	; get type of value on TOS 
3a81 fe 02				cp DS_TYPE_INUM  
3a83 28 00				jr z, .eq_inum 
3a85			 
3a85				if FORTH_ENABLE_FLOATMATH 
3a85					jr .eq_done 
3a85			 
3a85				endif 
3a85					 
3a85			 
3a85			.eq_inum: 
3a85					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a85 cd 0f 22			call macro_dsp_valuehl 
3a88				endm 
# End of macro FORTH_DSP_VALUEHL
3a88			 
3a88 e5					push hl 
3a89			 
3a89					; destroy value TOS 
3a89			 
3a89					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a89 cd c7 22			call macro_forth_dsp_pop 
3a8c				endm 
# End of macro FORTH_DSP_POP
3a8c			 
3a8c			 
3a8c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a8c cd 0f 22			call macro_dsp_valuehl 
3a8f				endm 
# End of macro FORTH_DSP_VALUEHL
3a8f			 
3a8f					; one value on hl get other one back 
3a8f			 
3a8f e5					push hl 
3a90			 
3a90					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a90 cd c7 22			call macro_forth_dsp_pop 
3a93				endm 
# End of macro FORTH_DSP_POP
3a93			 
3a93 0e 00				ld c, FORTH_FALSE 
3a95			 
3a95 e1					pop hl 
3a96 d1					pop de 
3a97			 
3a97 7b					ld a, e 
3a98 bd					cp l 
3a99			 
3a99 20 06				jr nz, .eq_done 
3a9b			 
3a9b 7a					ld a, d 
3a9c bc					cp h 
3a9d			 
3a9d 20 02				jr nz, .eq_done 
3a9f			 
3a9f 0e 01				ld c, FORTH_TRUE 
3aa1					 
3aa1			 
3aa1			 
3aa1			.eq_done: 
3aa1			 
3aa1					; TODO push value back onto stack for another op etc 
3aa1			 
3aa1 26 00				ld h, 0 
3aa3 69					ld l, c 
3aa4					if DEBUG_FORTH_WORDS 
3aa4						DMARK "EQ1" 
3aa4 f5				push af  
3aa5 3a b9 3a			ld a, (.dmark)  
3aa8 32 a6 fd			ld (debug_mark),a  
3aab 3a ba 3a			ld a, (.dmark+1)  
3aae 32 a7 fd			ld (debug_mark+1),a  
3ab1 3a bb 3a			ld a, (.dmark+2)  
3ab4 32 a8 fd			ld (debug_mark+2),a  
3ab7 18 03			jr .pastdmark  
3ab9 ..			.dmark: db "EQ1"  
3abc f1			.pastdmark: pop af  
3abd			endm  
# End of macro DMARK
3abd						CALLMONITOR 
3abd cd aa fd			call debug_vector  
3ac0				endm  
# End of macro CALLMONITOR
3ac0					endif 
3ac0 cd 18 20				call forth_push_numhl 
3ac3			 
3ac3					NEXTW 
3ac3 c3 c5 23			jp macro_next 
3ac6				endm 
# End of macro NEXTW
3ac6			 
3ac6			 
3ac6			.ENDLOGIC: 
3ac6			; eof 
3ac6			 
3ac6			 
# End of file forth_words_logic.asm
3ac6			include "forth_words_maths.asm" 
3ac6			 
3ac6			; | ## Maths Words 
3ac6			 
3ac6			.PLUS:	 
3ac6				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3ac6 15				db WORD_SYS_CORE+1             
3ac7 24 3b			dw .NEG            
3ac9 02				db 1 + 1 
3aca .. 00			db "+",0              
3acc				endm 
# End of macro CWHEAD
3acc			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3acc					if DEBUG_FORTH_WORDS_KEY 
3acc						DMARK "PLU" 
3acc f5				push af  
3acd 3a e1 3a			ld a, (.dmark)  
3ad0 32 a6 fd			ld (debug_mark),a  
3ad3 3a e2 3a			ld a, (.dmark+1)  
3ad6 32 a7 fd			ld (debug_mark+1),a  
3ad9 3a e3 3a			ld a, (.dmark+2)  
3adc 32 a8 fd			ld (debug_mark+2),a  
3adf 18 03			jr .pastdmark  
3ae1 ..			.dmark: db "PLU"  
3ae4 f1			.pastdmark: pop af  
3ae5			endm  
# End of macro DMARK
3ae5						CALLMONITOR 
3ae5 cd aa fd			call debug_vector  
3ae8				endm  
# End of macro CALLMONITOR
3ae8					endif 
3ae8					; add top two values and push back result 
3ae8			 
3ae8					;for v5 FORTH_DSP_VALUE 
3ae8					FORTH_DSP 
3ae8 cd d5 21			call macro_forth_dsp 
3aeb				endm 
# End of macro FORTH_DSP
3aeb 7e					ld a,(hl)	; get type of value on TOS 
3aec fe 02				cp DS_TYPE_INUM  
3aee 28 03				jr z, .dot_inum 
3af0			 
3af0					NEXTW 
3af0 c3 c5 23			jp macro_next 
3af3				endm 
# End of macro NEXTW
3af3			 
3af3			; float maths 
3af3			 
3af3				if FORTH_ENABLE_FLOATMATH 
3af3						inc hl      ; now at start of numeric as string 
3af3			 
3af3					if DEBUG_FORTH_MATHS 
3af3						DMARK "ADD" 
3af3				CALLMONITOR 
3af3					endif 
3af3			 
3af3					;ld ix, hl 
3af3					call CON 
3af3			 
3af3			 
3af3					push hl 
3af3					 
3af3					 
3af3			 
3af3						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3af3			 
3af3					; get next number 
3af3			 
3af3						FORTH_DSP_VALUE 
3af3			 
3af3						inc hl      ; now at start of numeric as string 
3af3			 
3af3					;ld ix, hl 
3af3					call CON 
3af3			 
3af3					push hl 
3af3			 
3af3			 
3af3						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3af3			 
3af3						; TODO do add 
3af3			 
3af3						call IADD 
3af3			 
3af3						; TODO get result back as ascii 
3af3			 
3af3						; TODO push result  
3af3			 
3af3			 
3af3			 
3af3						jr .dot_done 
3af3				endif 
3af3			 
3af3			.dot_inum: 
3af3			 
3af3			 
3af3					if DEBUG_FORTH_DOT 
3af3						DMARK "+IT" 
3af3 f5				push af  
3af4 3a 08 3b			ld a, (.dmark)  
3af7 32 a6 fd			ld (debug_mark),a  
3afa 3a 09 3b			ld a, (.dmark+1)  
3afd 32 a7 fd			ld (debug_mark+1),a  
3b00 3a 0a 3b			ld a, (.dmark+2)  
3b03 32 a8 fd			ld (debug_mark+2),a  
3b06 18 03			jr .pastdmark  
3b08 ..			.dmark: db "+IT"  
3b0b f1			.pastdmark: pop af  
3b0c			endm  
# End of macro DMARK
3b0c				CALLMONITOR 
3b0c cd aa fd			call debug_vector  
3b0f				endm  
# End of macro CALLMONITOR
3b0f					endif 
3b0f			 
3b0f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b0f cd 0f 22			call macro_dsp_valuehl 
3b12				endm 
# End of macro FORTH_DSP_VALUEHL
3b12			 
3b12				; TODO add floating point number detection 
3b12			 
3b12 e5					push hl 
3b13			 
3b13					; destroy value TOS 
3b13			 
3b13					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b13 cd c7 22			call macro_forth_dsp_pop 
3b16				endm 
# End of macro FORTH_DSP_POP
3b16			 
3b16			 
3b16					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b16 cd 0f 22			call macro_dsp_valuehl 
3b19				endm 
# End of macro FORTH_DSP_VALUEHL
3b19			 
3b19					; one value on hl get other one back 
3b19			 
3b19 d1					pop de 
3b1a			 
3b1a					; do the add 
3b1a			 
3b1a 19					add hl,de 
3b1b			 
3b1b					; save it 
3b1b			 
3b1b			;		push hl	 
3b1b			 
3b1b					; 
3b1b			 
3b1b					; destroy value TOS 
3b1b			 
3b1b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b1b cd c7 22			call macro_forth_dsp_pop 
3b1e				endm 
# End of macro FORTH_DSP_POP
3b1e			 
3b1e					; TODO push value back onto stack for another op etc 
3b1e			 
3b1e			;		pop hl 
3b1e			 
3b1e			.dot_done: 
3b1e cd 18 20				call forth_push_numhl 
3b21			 
3b21					NEXTW 
3b21 c3 c5 23			jp macro_next 
3b24				endm 
# End of macro NEXTW
3b24			.NEG: 
3b24			 
3b24				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3b24 17				db WORD_SYS_CORE+3             
3b25 67 3b			dw .DIV            
3b27 02				db 1 + 1 
3b28 .. 00			db "-",0              
3b2a				endm 
# End of macro CWHEAD
3b2a			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3b2a					if DEBUG_FORTH_WORDS_KEY 
3b2a						DMARK "SUB" 
3b2a f5				push af  
3b2b 3a 3f 3b			ld a, (.dmark)  
3b2e 32 a6 fd			ld (debug_mark),a  
3b31 3a 40 3b			ld a, (.dmark+1)  
3b34 32 a7 fd			ld (debug_mark+1),a  
3b37 3a 41 3b			ld a, (.dmark+2)  
3b3a 32 a8 fd			ld (debug_mark+2),a  
3b3d 18 03			jr .pastdmark  
3b3f ..			.dmark: db "SUB"  
3b42 f1			.pastdmark: pop af  
3b43			endm  
# End of macro DMARK
3b43						CALLMONITOR 
3b43 cd aa fd			call debug_vector  
3b46				endm  
# End of macro CALLMONITOR
3b46					endif 
3b46			 
3b46			 
3b46				; TODO add floating point number detection 
3b46					; v5 FORTH_DSP_VALUE 
3b46					FORTH_DSP 
3b46 cd d5 21			call macro_forth_dsp 
3b49				endm 
# End of macro FORTH_DSP
3b49 7e					ld a,(hl)	; get type of value on TOS 
3b4a fe 02				cp DS_TYPE_INUM  
3b4c 28 03				jr z, .neg_inum 
3b4e			 
3b4e					NEXTW 
3b4e c3 c5 23			jp macro_next 
3b51				endm 
# End of macro NEXTW
3b51			 
3b51			; float maths 
3b51			 
3b51				if FORTH_ENABLE_FLOATMATH 
3b51					jr .neg_done 
3b51			 
3b51				endif 
3b51					 
3b51			 
3b51			.neg_inum: 
3b51					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b51 cd 0f 22			call macro_dsp_valuehl 
3b54				endm 
# End of macro FORTH_DSP_VALUEHL
3b54			 
3b54 e5					push hl 
3b55			 
3b55					; destroy value TOS 
3b55			 
3b55					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b55 cd c7 22			call macro_forth_dsp_pop 
3b58				endm 
# End of macro FORTH_DSP_POP
3b58			 
3b58			 
3b58					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b58 cd 0f 22			call macro_dsp_valuehl 
3b5b				endm 
# End of macro FORTH_DSP_VALUEHL
3b5b			 
3b5b					; one value on hl get other one back 
3b5b			 
3b5b d1					pop de 
3b5c			 
3b5c					; do the sub 
3b5c			;		ex de, hl 
3b5c			 
3b5c ed 52				sbc hl,de 
3b5e			 
3b5e					; save it 
3b5e			 
3b5e			;		push hl	 
3b5e			 
3b5e					; 
3b5e			 
3b5e					; destroy value TOS 
3b5e			 
3b5e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b5e cd c7 22			call macro_forth_dsp_pop 
3b61				endm 
# End of macro FORTH_DSP_POP
3b61			 
3b61					; TODO push value back onto stack for another op etc 
3b61			 
3b61			;		pop hl 
3b61			 
3b61 cd 18 20				call forth_push_numhl 
3b64			.neg_done: 
3b64			 
3b64					NEXTW 
3b64 c3 c5 23			jp macro_next 
3b67				endm 
# End of macro NEXTW
3b67			.DIV: 
3b67				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3b67 18				db WORD_SYS_CORE+4             
3b68 b4 3b			dw .MUL            
3b6a 02				db 1 + 1 
3b6b .. 00			db "/",0              
3b6d				endm 
# End of macro CWHEAD
3b6d			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3b6d					if DEBUG_FORTH_WORDS_KEY 
3b6d						DMARK "DIV" 
3b6d f5				push af  
3b6e 3a 82 3b			ld a, (.dmark)  
3b71 32 a6 fd			ld (debug_mark),a  
3b74 3a 83 3b			ld a, (.dmark+1)  
3b77 32 a7 fd			ld (debug_mark+1),a  
3b7a 3a 84 3b			ld a, (.dmark+2)  
3b7d 32 a8 fd			ld (debug_mark+2),a  
3b80 18 03			jr .pastdmark  
3b82 ..			.dmark: db "DIV"  
3b85 f1			.pastdmark: pop af  
3b86			endm  
# End of macro DMARK
3b86						CALLMONITOR 
3b86 cd aa fd			call debug_vector  
3b89				endm  
# End of macro CALLMONITOR
3b89					endif 
3b89				; TODO add floating point number detection 
3b89					; v5 FORTH_DSP_VALUE 
3b89					FORTH_DSP 
3b89 cd d5 21			call macro_forth_dsp 
3b8c				endm 
# End of macro FORTH_DSP
3b8c 7e					ld a,(hl)	; get type of value on TOS 
3b8d fe 02				cp DS_TYPE_INUM  
3b8f 28 03				jr z, .div_inum 
3b91			 
3b91				if FORTH_ENABLE_FLOATMATH 
3b91					jr .div_done 
3b91			 
3b91				endif 
3b91					NEXTW 
3b91 c3 c5 23			jp macro_next 
3b94				endm 
# End of macro NEXTW
3b94			.div_inum: 
3b94			 
3b94					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b94 cd 0f 22			call macro_dsp_valuehl 
3b97				endm 
# End of macro FORTH_DSP_VALUEHL
3b97			 
3b97 e5					push hl    ; to go to bc 
3b98			 
3b98					; destroy value TOS 
3b98			 
3b98					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b98 cd c7 22			call macro_forth_dsp_pop 
3b9b				endm 
# End of macro FORTH_DSP_POP
3b9b			 
3b9b			 
3b9b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b9b cd 0f 22			call macro_dsp_valuehl 
3b9e				endm 
# End of macro FORTH_DSP_VALUEHL
3b9e			 
3b9e					; hl to go to de 
3b9e			 
3b9e e5					push hl 
3b9f			 
3b9f c1					pop bc 
3ba0 d1					pop de		 
3ba1			 
3ba1			 
3ba1					if DEBUG_FORTH_MATHS 
3ba1						DMARK "DIV" 
3ba1				CALLMONITOR 
3ba1					endif 
3ba1					; one value on hl but move to a get other one back 
3ba1			 
3ba1			        
3ba1 cd 2c 0f			call Div16 
3ba4			 
3ba4			;	push af	 
3ba4 e5				push hl 
3ba5 c5				push bc 
3ba6			 
3ba6					if DEBUG_FORTH_MATHS 
3ba6						DMARK "DI1" 
3ba6				CALLMONITOR 
3ba6					endif 
3ba6			 
3ba6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ba6 cd c7 22			call macro_forth_dsp_pop 
3ba9				endm 
# End of macro FORTH_DSP_POP
3ba9			 
3ba9			 
3ba9			 
3ba9 e1					pop hl    ; result 
3baa			 
3baa cd 18 20				call forth_push_numhl 
3bad			 
3bad e1					pop hl    ; reminder 
3bae			;		ld h,0 
3bae			;		ld l,d 
3bae			 
3bae cd 18 20				call forth_push_numhl 
3bb1			.div_done: 
3bb1					NEXTW 
3bb1 c3 c5 23			jp macro_next 
3bb4				endm 
# End of macro NEXTW
3bb4			.MUL: 
3bb4				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3bb4 19				db WORD_SYS_CORE+5             
3bb5 f9 3b			dw .MIN            
3bb7 02				db 1 + 1 
3bb8 .. 00			db "*",0              
3bba				endm 
# End of macro CWHEAD
3bba			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3bba				; TODO add floating point number detection 
3bba					if DEBUG_FORTH_WORDS_KEY 
3bba						DMARK "MUL" 
3bba f5				push af  
3bbb 3a cf 3b			ld a, (.dmark)  
3bbe 32 a6 fd			ld (debug_mark),a  
3bc1 3a d0 3b			ld a, (.dmark+1)  
3bc4 32 a7 fd			ld (debug_mark+1),a  
3bc7 3a d1 3b			ld a, (.dmark+2)  
3bca 32 a8 fd			ld (debug_mark+2),a  
3bcd 18 03			jr .pastdmark  
3bcf ..			.dmark: db "MUL"  
3bd2 f1			.pastdmark: pop af  
3bd3			endm  
# End of macro DMARK
3bd3						CALLMONITOR 
3bd3 cd aa fd			call debug_vector  
3bd6				endm  
# End of macro CALLMONITOR
3bd6					endif 
3bd6					FORTH_DSP 
3bd6 cd d5 21			call macro_forth_dsp 
3bd9				endm 
# End of macro FORTH_DSP
3bd9					; v5 FORTH_DSP_VALUE 
3bd9 7e					ld a,(hl)	; get type of value on TOS 
3bda fe 02				cp DS_TYPE_INUM  
3bdc 28 03				jr z, .mul_inum 
3bde			 
3bde				if FORTH_ENABLE_FLOATMATH 
3bde					jr .mul_done 
3bde			 
3bde				endif 
3bde			 
3bde					NEXTW 
3bde c3 c5 23			jp macro_next 
3be1				endm 
# End of macro NEXTW
3be1			.mul_inum:	 
3be1			 
3be1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3be1 cd 0f 22			call macro_dsp_valuehl 
3be4				endm 
# End of macro FORTH_DSP_VALUEHL
3be4			 
3be4 e5					push hl 
3be5			 
3be5					; destroy value TOS 
3be5			 
3be5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3be5 cd c7 22			call macro_forth_dsp_pop 
3be8				endm 
# End of macro FORTH_DSP_POP
3be8			 
3be8			 
3be8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3be8 cd 0f 22			call macro_dsp_valuehl 
3beb				endm 
# End of macro FORTH_DSP_VALUEHL
3beb			 
3beb					; one value on hl but move to a get other one back 
3beb			 
3beb 7d					ld a, l 
3bec			 
3bec d1					pop de 
3bed			 
3bed					; do the mull 
3bed			;		ex de, hl 
3bed			 
3bed cd 52 0f				call Mult16 
3bf0					; save it 
3bf0			 
3bf0			;		push hl	 
3bf0			 
3bf0					; 
3bf0			 
3bf0					; destroy value TOS 
3bf0			 
3bf0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bf0 cd c7 22			call macro_forth_dsp_pop 
3bf3				endm 
# End of macro FORTH_DSP_POP
3bf3			 
3bf3					; TODO push value back onto stack for another op etc 
3bf3			 
3bf3			;		pop hl 
3bf3			 
3bf3 cd 18 20				call forth_push_numhl 
3bf6			 
3bf6			.mul_done: 
3bf6					NEXTW 
3bf6 c3 c5 23			jp macro_next 
3bf9				endm 
# End of macro NEXTW
3bf9			 
3bf9			 
3bf9			 
3bf9			 
3bf9			.MIN: 
3bf9				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3bf9 49				db WORD_SYS_CORE+53             
3bfa 7a 3c			dw .MAX            
3bfc 04				db 3 + 1 
3bfd .. 00			db "MIN",0              
3c01				endm 
# End of macro CWHEAD
3c01			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3c01					if DEBUG_FORTH_WORDS_KEY 
3c01						DMARK "MIN" 
3c01 f5				push af  
3c02 3a 16 3c			ld a, (.dmark)  
3c05 32 a6 fd			ld (debug_mark),a  
3c08 3a 17 3c			ld a, (.dmark+1)  
3c0b 32 a7 fd			ld (debug_mark+1),a  
3c0e 3a 18 3c			ld a, (.dmark+2)  
3c11 32 a8 fd			ld (debug_mark+2),a  
3c14 18 03			jr .pastdmark  
3c16 ..			.dmark: db "MIN"  
3c19 f1			.pastdmark: pop af  
3c1a			endm  
# End of macro DMARK
3c1a						CALLMONITOR 
3c1a cd aa fd			call debug_vector  
3c1d				endm  
# End of macro CALLMONITOR
3c1d					endif 
3c1d					; get u2 
3c1d			 
3c1d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c1d cd 0f 22			call macro_dsp_valuehl 
3c20				endm 
# End of macro FORTH_DSP_VALUEHL
3c20			 
3c20 e5					push hl   ; u2 
3c21			 
3c21					; destroy value TOS 
3c21			 
3c21					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c21 cd c7 22			call macro_forth_dsp_pop 
3c24				endm 
# End of macro FORTH_DSP_POP
3c24			 
3c24					; get u1 
3c24			 
3c24					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c24 cd 0f 22			call macro_dsp_valuehl 
3c27				endm 
# End of macro FORTH_DSP_VALUEHL
3c27			 
3c27 e5					push hl  ; u1 
3c28			 
3c28					; destroy value TOS 
3c28			 
3c28					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c28 cd c7 22			call macro_forth_dsp_pop 
3c2b				endm 
# End of macro FORTH_DSP_POP
3c2b			 
3c2b b7			 or a      ;clear carry flag 
3c2c e1			  pop hl    ; u1 
3c2d d1			  pop de    ; u2 
3c2e e5				push hl   ; saved in case hl is lowest 
3c2f ed 52		  sbc hl,de 
3c31 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3c33			 
3c33 e1				pop hl 
3c34					if DEBUG_FORTH_WORDS 
3c34						DMARK "MIN" 
3c34 f5				push af  
3c35 3a 49 3c			ld a, (.dmark)  
3c38 32 a6 fd			ld (debug_mark),a  
3c3b 3a 4a 3c			ld a, (.dmark+1)  
3c3e 32 a7 fd			ld (debug_mark+1),a  
3c41 3a 4b 3c			ld a, (.dmark+2)  
3c44 32 a8 fd			ld (debug_mark+2),a  
3c47 18 03			jr .pastdmark  
3c49 ..			.dmark: db "MIN"  
3c4c f1			.pastdmark: pop af  
3c4d			endm  
# End of macro DMARK
3c4d						CALLMONITOR 
3c4d cd aa fd			call debug_vector  
3c50				endm  
# End of macro CALLMONITOR
3c50					endif 
3c50 cd 18 20				call forth_push_numhl 
3c53			 
3c53				       NEXTW 
3c53 c3 c5 23			jp macro_next 
3c56				endm 
# End of macro NEXTW
3c56			 
3c56			.mincont:  
3c56 c1				pop bc   ; tidy up 
3c57 eb				ex de , hl  
3c58					if DEBUG_FORTH_WORDS 
3c58						DMARK "MI1" 
3c58 f5				push af  
3c59 3a 6d 3c			ld a, (.dmark)  
3c5c 32 a6 fd			ld (debug_mark),a  
3c5f 3a 6e 3c			ld a, (.dmark+1)  
3c62 32 a7 fd			ld (debug_mark+1),a  
3c65 3a 6f 3c			ld a, (.dmark+2)  
3c68 32 a8 fd			ld (debug_mark+2),a  
3c6b 18 03			jr .pastdmark  
3c6d ..			.dmark: db "MI1"  
3c70 f1			.pastdmark: pop af  
3c71			endm  
# End of macro DMARK
3c71						CALLMONITOR 
3c71 cd aa fd			call debug_vector  
3c74				endm  
# End of macro CALLMONITOR
3c74					endif 
3c74 cd 18 20				call forth_push_numhl 
3c77			 
3c77				       NEXTW 
3c77 c3 c5 23			jp macro_next 
3c7a				endm 
# End of macro NEXTW
3c7a			.MAX: 
3c7a				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3c7a 4a				db WORD_SYS_CORE+54             
3c7b fb 3c			dw .RND16            
3c7d 04				db 3 + 1 
3c7e .. 00			db "MAX",0              
3c82				endm 
# End of macro CWHEAD
3c82			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3c82					if DEBUG_FORTH_WORDS_KEY 
3c82						DMARK "MAX" 
3c82 f5				push af  
3c83 3a 97 3c			ld a, (.dmark)  
3c86 32 a6 fd			ld (debug_mark),a  
3c89 3a 98 3c			ld a, (.dmark+1)  
3c8c 32 a7 fd			ld (debug_mark+1),a  
3c8f 3a 99 3c			ld a, (.dmark+2)  
3c92 32 a8 fd			ld (debug_mark+2),a  
3c95 18 03			jr .pastdmark  
3c97 ..			.dmark: db "MAX"  
3c9a f1			.pastdmark: pop af  
3c9b			endm  
# End of macro DMARK
3c9b						CALLMONITOR 
3c9b cd aa fd			call debug_vector  
3c9e				endm  
# End of macro CALLMONITOR
3c9e					endif 
3c9e					; get u2 
3c9e			 
3c9e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c9e cd 0f 22			call macro_dsp_valuehl 
3ca1				endm 
# End of macro FORTH_DSP_VALUEHL
3ca1			 
3ca1 e5					push hl   ; u2 
3ca2			 
3ca2					; destroy value TOS 
3ca2			 
3ca2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ca2 cd c7 22			call macro_forth_dsp_pop 
3ca5				endm 
# End of macro FORTH_DSP_POP
3ca5			 
3ca5					; get u1 
3ca5			 
3ca5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ca5 cd 0f 22			call macro_dsp_valuehl 
3ca8				endm 
# End of macro FORTH_DSP_VALUEHL
3ca8			 
3ca8 e5					push hl  ; u1 
3ca9			 
3ca9					; destroy value TOS 
3ca9			 
3ca9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ca9 cd c7 22			call macro_forth_dsp_pop 
3cac				endm 
# End of macro FORTH_DSP_POP
3cac			 
3cac b7			 or a      ;clear carry flag 
3cad e1			  pop hl    ; u1 
3cae d1			  pop de    ; u2 
3caf e5				push hl   ; saved in case hl is lowest 
3cb0 ed 52		  sbc hl,de 
3cb2 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3cb4			 
3cb4 e1				pop hl 
3cb5					if DEBUG_FORTH_WORDS 
3cb5						DMARK "MAX" 
3cb5 f5				push af  
3cb6 3a ca 3c			ld a, (.dmark)  
3cb9 32 a6 fd			ld (debug_mark),a  
3cbc 3a cb 3c			ld a, (.dmark+1)  
3cbf 32 a7 fd			ld (debug_mark+1),a  
3cc2 3a cc 3c			ld a, (.dmark+2)  
3cc5 32 a8 fd			ld (debug_mark+2),a  
3cc8 18 03			jr .pastdmark  
3cca ..			.dmark: db "MAX"  
3ccd f1			.pastdmark: pop af  
3cce			endm  
# End of macro DMARK
3cce						CALLMONITOR 
3cce cd aa fd			call debug_vector  
3cd1				endm  
# End of macro CALLMONITOR
3cd1					endif 
3cd1 cd 18 20				call forth_push_numhl 
3cd4			 
3cd4				       NEXTW 
3cd4 c3 c5 23			jp macro_next 
3cd7				endm 
# End of macro NEXTW
3cd7			 
3cd7			.maxcont:  
3cd7 c1				pop bc   ; tidy up 
3cd8 eb				ex de , hl  
3cd9					if DEBUG_FORTH_WORDS 
3cd9						DMARK "MA1" 
3cd9 f5				push af  
3cda 3a ee 3c			ld a, (.dmark)  
3cdd 32 a6 fd			ld (debug_mark),a  
3ce0 3a ef 3c			ld a, (.dmark+1)  
3ce3 32 a7 fd			ld (debug_mark+1),a  
3ce6 3a f0 3c			ld a, (.dmark+2)  
3ce9 32 a8 fd			ld (debug_mark+2),a  
3cec 18 03			jr .pastdmark  
3cee ..			.dmark: db "MA1"  
3cf1 f1			.pastdmark: pop af  
3cf2			endm  
# End of macro DMARK
3cf2						CALLMONITOR 
3cf2 cd aa fd			call debug_vector  
3cf5				endm  
# End of macro CALLMONITOR
3cf5					endif 
3cf5 cd 18 20				call forth_push_numhl 
3cf8				       NEXTW 
3cf8 c3 c5 23			jp macro_next 
3cfb				endm 
# End of macro NEXTW
3cfb			 
3cfb			.RND16: 
3cfb				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3cfb 4e				db WORD_SYS_CORE+58             
3cfc 2a 3d			dw .RND8            
3cfe 06				db 5 + 1 
3cff .. 00			db "RND16",0              
3d05				endm 
# End of macro CWHEAD
3d05			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3d05					if DEBUG_FORTH_WORDS_KEY 
3d05						DMARK "R16" 
3d05 f5				push af  
3d06 3a 1a 3d			ld a, (.dmark)  
3d09 32 a6 fd			ld (debug_mark),a  
3d0c 3a 1b 3d			ld a, (.dmark+1)  
3d0f 32 a7 fd			ld (debug_mark+1),a  
3d12 3a 1c 3d			ld a, (.dmark+2)  
3d15 32 a8 fd			ld (debug_mark+2),a  
3d18 18 03			jr .pastdmark  
3d1a ..			.dmark: db "R16"  
3d1d f1			.pastdmark: pop af  
3d1e			endm  
# End of macro DMARK
3d1e						CALLMONITOR 
3d1e cd aa fd			call debug_vector  
3d21				endm  
# End of macro CALLMONITOR
3d21					endif 
3d21 cd f6 0e				call prng16  
3d24 cd 18 20				call forth_push_numhl 
3d27				       NEXTW 
3d27 c3 c5 23			jp macro_next 
3d2a				endm 
# End of macro NEXTW
3d2a			.RND8: 
3d2a				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3d2a 60				db WORD_SYS_CORE+76             
3d2b 5f 3d			dw .RND            
3d2d 05				db 4 + 1 
3d2e .. 00			db "RND8",0              
3d33				endm 
# End of macro CWHEAD
3d33			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3d33					if DEBUG_FORTH_WORDS_KEY 
3d33						DMARK "RN8" 
3d33 f5				push af  
3d34 3a 48 3d			ld a, (.dmark)  
3d37 32 a6 fd			ld (debug_mark),a  
3d3a 3a 49 3d			ld a, (.dmark+1)  
3d3d 32 a7 fd			ld (debug_mark+1),a  
3d40 3a 4a 3d			ld a, (.dmark+2)  
3d43 32 a8 fd			ld (debug_mark+2),a  
3d46 18 03			jr .pastdmark  
3d48 ..			.dmark: db "RN8"  
3d4b f1			.pastdmark: pop af  
3d4c			endm  
# End of macro DMARK
3d4c						CALLMONITOR 
3d4c cd aa fd			call debug_vector  
3d4f				endm  
# End of macro CALLMONITOR
3d4f					endif 
3d4f 2a e4 fa				ld hl,(xrandc) 
3d52 23					inc hl 
3d53 cd 10 0f				call xrnd 
3d56 6f					ld l,a	 
3d57 26 00				ld h,0 
3d59 cd 18 20				call forth_push_numhl 
3d5c				       NEXTW 
3d5c c3 c5 23			jp macro_next 
3d5f				endm 
# End of macro NEXTW
3d5f			.RND: 
3d5f				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3d5f 60				db WORD_SYS_CORE+76             
3d60 65 3e			dw .ENDMATHS            
3d62 04				db 3 + 1 
3d63 .. 00			db "RND",0              
3d67				endm 
# End of macro CWHEAD
3d67			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3d67			 
3d67					if DEBUG_FORTH_WORDS_KEY 
3d67						DMARK "RND" 
3d67 f5				push af  
3d68 3a 7c 3d			ld a, (.dmark)  
3d6b 32 a6 fd			ld (debug_mark),a  
3d6e 3a 7d 3d			ld a, (.dmark+1)  
3d71 32 a7 fd			ld (debug_mark+1),a  
3d74 3a 7e 3d			ld a, (.dmark+2)  
3d77 32 a8 fd			ld (debug_mark+2),a  
3d7a 18 03			jr .pastdmark  
3d7c ..			.dmark: db "RND"  
3d7f f1			.pastdmark: pop af  
3d80			endm  
# End of macro DMARK
3d80						CALLMONITOR 
3d80 cd aa fd			call debug_vector  
3d83				endm  
# End of macro CALLMONITOR
3d83					endif 
3d83					 
3d83					FORTH_DSP_VALUEHL    ; upper range 
3d83 cd 0f 22			call macro_dsp_valuehl 
3d86				endm 
# End of macro FORTH_DSP_VALUEHL
3d86			 
3d86 22 e8 fa				ld (LFSRSeed), hl	 
3d89			 
3d89					if DEBUG_FORTH_WORDS 
3d89						DMARK "RN1" 
3d89 f5				push af  
3d8a 3a 9e 3d			ld a, (.dmark)  
3d8d 32 a6 fd			ld (debug_mark),a  
3d90 3a 9f 3d			ld a, (.dmark+1)  
3d93 32 a7 fd			ld (debug_mark+1),a  
3d96 3a a0 3d			ld a, (.dmark+2)  
3d99 32 a8 fd			ld (debug_mark+2),a  
3d9c 18 03			jr .pastdmark  
3d9e ..			.dmark: db "RN1"  
3da1 f1			.pastdmark: pop af  
3da2			endm  
# End of macro DMARK
3da2						CALLMONITOR 
3da2 cd aa fd			call debug_vector  
3da5				endm  
# End of macro CALLMONITOR
3da5					endif 
3da5					FORTH_DSP_POP 
3da5 cd c7 22			call macro_forth_dsp_pop 
3da8				endm 
# End of macro FORTH_DSP_POP
3da8			 
3da8					FORTH_DSP_VALUEHL    ; low range 
3da8 cd 0f 22			call macro_dsp_valuehl 
3dab				endm 
# End of macro FORTH_DSP_VALUEHL
3dab			 
3dab					if DEBUG_FORTH_WORDS 
3dab						DMARK "RN2" 
3dab f5				push af  
3dac 3a c0 3d			ld a, (.dmark)  
3daf 32 a6 fd			ld (debug_mark),a  
3db2 3a c1 3d			ld a, (.dmark+1)  
3db5 32 a7 fd			ld (debug_mark+1),a  
3db8 3a c2 3d			ld a, (.dmark+2)  
3dbb 32 a8 fd			ld (debug_mark+2),a  
3dbe 18 03			jr .pastdmark  
3dc0 ..			.dmark: db "RN2"  
3dc3 f1			.pastdmark: pop af  
3dc4			endm  
# End of macro DMARK
3dc4						CALLMONITOR 
3dc4 cd aa fd			call debug_vector  
3dc7				endm  
# End of macro CALLMONITOR
3dc7					endif 
3dc7 22 ea fa				ld (LFSRSeed+2), hl 
3dca			 
3dca					FORTH_DSP_POP 
3dca cd c7 22			call macro_forth_dsp_pop 
3dcd				endm 
# End of macro FORTH_DSP_POP
3dcd			 
3dcd e5					push hl 
3dce			 
3dce e1			.inrange:	pop hl 
3dcf cd f6 0e				call prng16  
3dd2					if DEBUG_FORTH_WORDS 
3dd2						DMARK "RN3" 
3dd2 f5				push af  
3dd3 3a e7 3d			ld a, (.dmark)  
3dd6 32 a6 fd			ld (debug_mark),a  
3dd9 3a e8 3d			ld a, (.dmark+1)  
3ddc 32 a7 fd			ld (debug_mark+1),a  
3ddf 3a e9 3d			ld a, (.dmark+2)  
3de2 32 a8 fd			ld (debug_mark+2),a  
3de5 18 03			jr .pastdmark  
3de7 ..			.dmark: db "RN3"  
3dea f1			.pastdmark: pop af  
3deb			endm  
# End of macro DMARK
3deb						CALLMONITOR 
3deb cd aa fd			call debug_vector  
3dee				endm  
# End of macro CALLMONITOR
3dee					endif 
3dee					 
3dee					; if the range is 8bit knock out the high byte 
3dee			 
3dee ed 5b e8 fa			ld de, (LFSRSeed)     ; check high level 
3df2			 
3df2 3e 00				ld a, 0 
3df4 ba					cp d  
3df5 20 1e				jr nz, .hirange 
3df7 26 00				ld h, 0   ; knock it down to 8bit 
3df9			 
3df9					if DEBUG_FORTH_WORDS 
3df9						DMARK "RNk" 
3df9 f5				push af  
3dfa 3a 0e 3e			ld a, (.dmark)  
3dfd 32 a6 fd			ld (debug_mark),a  
3e00 3a 0f 3e			ld a, (.dmark+1)  
3e03 32 a7 fd			ld (debug_mark+1),a  
3e06 3a 10 3e			ld a, (.dmark+2)  
3e09 32 a8 fd			ld (debug_mark+2),a  
3e0c 18 03			jr .pastdmark  
3e0e ..			.dmark: db "RNk"  
3e11 f1			.pastdmark: pop af  
3e12			endm  
# End of macro DMARK
3e12						CALLMONITOR 
3e12 cd aa fd			call debug_vector  
3e15				endm  
# End of macro CALLMONITOR
3e15					endif 
3e15			.hirange:   
3e15 e5					push hl  
3e16 b7					or a  
3e17 ed 52		                sbc hl, de 
3e19			 
3e19					;call cmp16 
3e19			 
3e19 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3e1b e1					pop hl 
3e1c e5					push hl 
3e1d			 
3e1d					if DEBUG_FORTH_WORDS 
3e1d						DMARK "RN4" 
3e1d f5				push af  
3e1e 3a 32 3e			ld a, (.dmark)  
3e21 32 a6 fd			ld (debug_mark),a  
3e24 3a 33 3e			ld a, (.dmark+1)  
3e27 32 a7 fd			ld (debug_mark+1),a  
3e2a 3a 34 3e			ld a, (.dmark+2)  
3e2d 32 a8 fd			ld (debug_mark+2),a  
3e30 18 03			jr .pastdmark  
3e32 ..			.dmark: db "RN4"  
3e35 f1			.pastdmark: pop af  
3e36			endm  
# End of macro DMARK
3e36						CALLMONITOR 
3e36 cd aa fd			call debug_vector  
3e39				endm  
# End of macro CALLMONITOR
3e39					endif 
3e39 ed 5b ea fa			ld de, (LFSRSeed+2)   ; check low range 
3e3d					;call cmp16 
3e3d				 
3e3d b7					or a  
3e3e ed 52		                sbc hl, de 
3e40 38 8c				jr c, .inrange 
3e42			 
3e42 e1					pop hl 
3e43					 
3e43					if DEBUG_FORTH_WORDS 
3e43						DMARK "RNd" 
3e43 f5				push af  
3e44 3a 58 3e			ld a, (.dmark)  
3e47 32 a6 fd			ld (debug_mark),a  
3e4a 3a 59 3e			ld a, (.dmark+1)  
3e4d 32 a7 fd			ld (debug_mark+1),a  
3e50 3a 5a 3e			ld a, (.dmark+2)  
3e53 32 a8 fd			ld (debug_mark+2),a  
3e56 18 03			jr .pastdmark  
3e58 ..			.dmark: db "RNd"  
3e5b f1			.pastdmark: pop af  
3e5c			endm  
# End of macro DMARK
3e5c						CALLMONITOR 
3e5c cd aa fd			call debug_vector  
3e5f				endm  
# End of macro CALLMONITOR
3e5f					endif 
3e5f			 
3e5f			 
3e5f cd 18 20				call forth_push_numhl 
3e62				       NEXTW 
3e62 c3 c5 23			jp macro_next 
3e65				endm 
# End of macro NEXTW
3e65			 
3e65			.ENDMATHS: 
3e65			 
3e65			; eof 
3e65			 
# End of file forth_words_maths.asm
3e65			include "forth_words_display.asm" 
3e65			 
3e65			; | ## Display Words 
3e65			 
3e65			.ACT: 
3e65			 
3e65				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3e65 62				db WORD_SYS_CORE+78             
3e66 b1 3e			dw .INFO            
3e68 07				db 6 + 1 
3e69 .. 00			db "ACTIVE",0              
3e70				endm 
# End of macro CWHEAD
3e70			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3e70			;  
3e70			; | | To display a pulsing activity indicator in a processing loop do this... 
3e70			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
3e70			 
3e70					if DEBUG_FORTH_WORDS_KEY 
3e70						DMARK "ACT" 
3e70 f5				push af  
3e71 3a 85 3e			ld a, (.dmark)  
3e74 32 a6 fd			ld (debug_mark),a  
3e77 3a 86 3e			ld a, (.dmark+1)  
3e7a 32 a7 fd			ld (debug_mark+1),a  
3e7d 3a 87 3e			ld a, (.dmark+2)  
3e80 32 a8 fd			ld (debug_mark+2),a  
3e83 18 03			jr .pastdmark  
3e85 ..			.dmark: db "ACT"  
3e88 f1			.pastdmark: pop af  
3e89			endm  
# End of macro DMARK
3e89						CALLMONITOR 
3e89 cd aa fd			call debug_vector  
3e8c				endm  
# End of macro CALLMONITOR
3e8c					endif 
3e8c cd f2 0c				call active 
3e8f					if DEBUG_FORTH_WORDS 
3e8f						DMARK "ACp" 
3e8f f5				push af  
3e90 3a a4 3e			ld a, (.dmark)  
3e93 32 a6 fd			ld (debug_mark),a  
3e96 3a a5 3e			ld a, (.dmark+1)  
3e99 32 a7 fd			ld (debug_mark+1),a  
3e9c 3a a6 3e			ld a, (.dmark+2)  
3e9f 32 a8 fd			ld (debug_mark+2),a  
3ea2 18 03			jr .pastdmark  
3ea4 ..			.dmark: db "ACp"  
3ea7 f1			.pastdmark: pop af  
3ea8			endm  
# End of macro DMARK
3ea8						CALLMONITOR 
3ea8 cd aa fd			call debug_vector  
3eab				endm  
# End of macro CALLMONITOR
3eab					endif 
3eab cd 86 20				call forth_push_str 
3eae			 
3eae					NEXTW 
3eae c3 c5 23			jp macro_next 
3eb1				endm 
# End of macro NEXTW
3eb1			.INFO: 
3eb1			 
3eb1				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3eb1 62				db WORD_SYS_CORE+78             
3eb2 ce 3e			dw .ATP            
3eb4 05				db 4 + 1 
3eb5 .. 00			db "INFO",0              
3eba				endm 
# End of macro CWHEAD
3eba			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3eba					FORTH_DSP_VALUEHL 
3eba cd 0f 22			call macro_dsp_valuehl 
3ebd				endm 
# End of macro FORTH_DSP_VALUEHL
3ebd			 
3ebd					FORTH_DSP_POP 
3ebd cd c7 22			call macro_forth_dsp_pop 
3ec0				endm 
# End of macro FORTH_DSP_POP
3ec0			 
3ec0 e5					push hl 
3ec1			 
3ec1					FORTH_DSP_VALUEHL 
3ec1 cd 0f 22			call macro_dsp_valuehl 
3ec4				endm 
# End of macro FORTH_DSP_VALUEHL
3ec4			 
3ec4					FORTH_DSP_POP 
3ec4 cd c7 22			call macro_forth_dsp_pop 
3ec7				endm 
# End of macro FORTH_DSP_POP
3ec7			 
3ec7 d1					pop de 
3ec8			 
3ec8 cd 2c 0d				call info_panel 
3ecb			 
3ecb			 
3ecb					NEXTW 
3ecb c3 c5 23			jp macro_next 
3ece				endm 
# End of macro NEXTW
3ece			.ATP: 
3ece				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3ece 62				db WORD_SYS_CORE+78             
3ecf 45 3f			dw .FB            
3ed1 04				db 3 + 1 
3ed2 .. 00			db "AT?",0              
3ed6				endm 
# End of macro CWHEAD
3ed6			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3ed6					if DEBUG_FORTH_WORDS_KEY 
3ed6						DMARK "AT?" 
3ed6 f5				push af  
3ed7 3a eb 3e			ld a, (.dmark)  
3eda 32 a6 fd			ld (debug_mark),a  
3edd 3a ec 3e			ld a, (.dmark+1)  
3ee0 32 a7 fd			ld (debug_mark+1),a  
3ee3 3a ed 3e			ld a, (.dmark+2)  
3ee6 32 a8 fd			ld (debug_mark+2),a  
3ee9 18 03			jr .pastdmark  
3eeb ..			.dmark: db "AT?"  
3eee f1			.pastdmark: pop af  
3eef			endm  
# End of macro DMARK
3eef						CALLMONITOR 
3eef cd aa fd			call debug_vector  
3ef2				endm  
# End of macro CALLMONITOR
3ef2					endif 
3ef2 3a 99 f9				ld a, (f_cursor_ptr) 
3ef5			 
3ef5			if DEBUG_FORTH_WORDS 
3ef5				DMARK "AT?" 
3ef5 f5				push af  
3ef6 3a 0a 3f			ld a, (.dmark)  
3ef9 32 a6 fd			ld (debug_mark),a  
3efc 3a 0b 3f			ld a, (.dmark+1)  
3eff 32 a7 fd			ld (debug_mark+1),a  
3f02 3a 0c 3f			ld a, (.dmark+2)  
3f05 32 a8 fd			ld (debug_mark+2),a  
3f08 18 03			jr .pastdmark  
3f0a ..			.dmark: db "AT?"  
3f0d f1			.pastdmark: pop af  
3f0e			endm  
# End of macro DMARK
3f0e				CALLMONITOR 
3f0e cd aa fd			call debug_vector  
3f11				endm  
# End of macro CALLMONITOR
3f11			endif	 
3f11					; count the number of rows 
3f11			 
3f11 06 00				ld b, 0 
3f13 4f			.atpr:		ld c, a    ; save in case we go below zero 
3f14 d6 28				sub display_cols 
3f16 f2 1c 3f				jp p, .atprunder 
3f19 04					inc b 
3f1a 18 f7				jr .atpr 
3f1c			.atprunder:	 
3f1c			if DEBUG_FORTH_WORDS 
3f1c				DMARK "A?2" 
3f1c f5				push af  
3f1d 3a 31 3f			ld a, (.dmark)  
3f20 32 a6 fd			ld (debug_mark),a  
3f23 3a 32 3f			ld a, (.dmark+1)  
3f26 32 a7 fd			ld (debug_mark+1),a  
3f29 3a 33 3f			ld a, (.dmark+2)  
3f2c 32 a8 fd			ld (debug_mark+2),a  
3f2f 18 03			jr .pastdmark  
3f31 ..			.dmark: db "A?2"  
3f34 f1			.pastdmark: pop af  
3f35			endm  
# End of macro DMARK
3f35				CALLMONITOR 
3f35 cd aa fd			call debug_vector  
3f38				endm  
# End of macro CALLMONITOR
3f38			endif	 
3f38 26 00				ld h, 0 
3f3a 69					ld l, c 
3f3b cd 18 20				call forth_push_numhl 
3f3e 68					ld l, b  
3f3f cd 18 20				call forth_push_numhl 
3f42			 
3f42			 
3f42				NEXTW 
3f42 c3 c5 23			jp macro_next 
3f45				endm 
# End of macro NEXTW
3f45			 
3f45			.FB: 
3f45				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3f45 1b				db WORD_SYS_CORE+7             
3f46 93 3f			dw .EMIT            
3f48 03				db 2 + 1 
3f49 .. 00			db "FB",0              
3f4c				endm 
# End of macro CWHEAD
3f4c			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3f4c			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3f4c			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3f4c			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3f4c					if DEBUG_FORTH_WORDS_KEY 
3f4c						DMARK "FB." 
3f4c f5				push af  
3f4d 3a 61 3f			ld a, (.dmark)  
3f50 32 a6 fd			ld (debug_mark),a  
3f53 3a 62 3f			ld a, (.dmark+1)  
3f56 32 a7 fd			ld (debug_mark+1),a  
3f59 3a 63 3f			ld a, (.dmark+2)  
3f5c 32 a8 fd			ld (debug_mark+2),a  
3f5f 18 03			jr .pastdmark  
3f61 ..			.dmark: db "FB."  
3f64 f1			.pastdmark: pop af  
3f65			endm  
# End of macro DMARK
3f65						CALLMONITOR 
3f65 cd aa fd			call debug_vector  
3f68				endm  
# End of macro CALLMONITOR
3f68					endif 
3f68			 
3f68					FORTH_DSP_VALUEHL 
3f68 cd 0f 22			call macro_dsp_valuehl 
3f6b				endm 
# End of macro FORTH_DSP_VALUEHL
3f6b			 
3f6b 7d					ld a, l 
3f6c fe 01				cp 1 
3f6e 20 05				jr nz, .fbn1 
3f70 21 4b fc				ld hl, display_fb1 
3f73 18 15				jr .fbset 
3f75 fe 02		.fbn1:		cp 2 
3f77 20 05				jr nz, .fbn2 
3f79 21 09 fb				ld hl, display_fb2 
3f7c 18 0c				jr .fbset 
3f7e fe 03		.fbn2:		cp 3 
3f80 20 05				jr nz, .fbn3 
3f82 21 aa fb				ld hl, display_fb3 
3f85 18 03				jr .fbset 
3f87			.fbn3:		 ; if invalid number select first 
3f87 21 4b fc				ld hl, display_fb1 
3f8a 22 07 fb		.fbset:		ld (display_fb_active), hl 
3f8d			 
3f8d					FORTH_DSP_POP 
3f8d cd c7 22			call macro_forth_dsp_pop 
3f90				endm 
# End of macro FORTH_DSP_POP
3f90			 
3f90					NEXTW 
3f90 c3 c5 23			jp macro_next 
3f93				endm 
# End of macro NEXTW
3f93			 
3f93			 
3f93			.EMIT: 
3f93				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3f93 1b				db WORD_SYS_CORE+7             
3f94 e4 3f			dw .DOTH            
3f96 05				db 4 + 1 
3f97 .. 00			db "EMIT",0              
3f9c				endm 
# End of macro CWHEAD
3f9c			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3f9c					; get value off TOS and display it 
3f9c			 
3f9c					if DEBUG_FORTH_WORDS_KEY 
3f9c						DMARK "EMT" 
3f9c f5				push af  
3f9d 3a b1 3f			ld a, (.dmark)  
3fa0 32 a6 fd			ld (debug_mark),a  
3fa3 3a b2 3f			ld a, (.dmark+1)  
3fa6 32 a7 fd			ld (debug_mark+1),a  
3fa9 3a b3 3f			ld a, (.dmark+2)  
3fac 32 a8 fd			ld (debug_mark+2),a  
3faf 18 03			jr .pastdmark  
3fb1 ..			.dmark: db "EMT"  
3fb4 f1			.pastdmark: pop af  
3fb5			endm  
# End of macro DMARK
3fb5						CALLMONITOR 
3fb5 cd aa fd			call debug_vector  
3fb8				endm  
# End of macro CALLMONITOR
3fb8					endif 
3fb8			 
3fb8					FORTH_DSP_VALUEHL 
3fb8 cd 0f 22			call macro_dsp_valuehl 
3fbb				endm 
# End of macro FORTH_DSP_VALUEHL
3fbb			 
3fbb 7d					ld a,l 
3fbc			 
3fbc					; TODO write to display 
3fbc			 
3fbc 32 fa f2				ld (os_input), a 
3fbf 3e 00				ld a, 0 
3fc1 32 fb f2				ld (os_input+1), a 
3fc4					 
3fc4 3a 99 f9				ld a, (f_cursor_ptr) 
3fc7 11 fa f2				ld de, os_input 
3fca cd ae 0d				call str_at_display 
3fcd			 
3fcd			 
3fcd 3a 77 f9				ld a,(cli_autodisplay) 
3fd0 fe 00				cp 0 
3fd2 28 03				jr z, .enoupdate 
3fd4 cd be 0d						call update_display 
3fd7					.enoupdate: 
3fd7			 
3fd7 3a 99 f9				ld a, (f_cursor_ptr) 
3fda 3c					inc a 
3fdb 32 99 f9				ld (f_cursor_ptr), a   ; save new pos 
3fde			 
3fde			 
3fde					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fde cd c7 22			call macro_forth_dsp_pop 
3fe1				endm 
# End of macro FORTH_DSP_POP
3fe1			  
3fe1			 
3fe1					NEXTW 
3fe1 c3 c5 23			jp macro_next 
3fe4				endm 
# End of macro NEXTW
3fe4			.DOTH: 
3fe4				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3fe4 1c				db WORD_SYS_CORE+8             
3fe5 14 40			dw .DOTF            
3fe7 03				db 2 + 1 
3fe8 .. 00			db ".-",0              
3feb				endm 
# End of macro CWHEAD
3feb			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3feb					; get value off TOS and display it 
3feb					if DEBUG_FORTH_WORDS_KEY 
3feb						DMARK "DTD" 
3feb f5				push af  
3fec 3a 00 40			ld a, (.dmark)  
3fef 32 a6 fd			ld (debug_mark),a  
3ff2 3a 01 40			ld a, (.dmark+1)  
3ff5 32 a7 fd			ld (debug_mark+1),a  
3ff8 3a 02 40			ld a, (.dmark+2)  
3ffb 32 a8 fd			ld (debug_mark+2),a  
3ffe 18 03			jr .pastdmark  
4000 ..			.dmark: db "DTD"  
4003 f1			.pastdmark: pop af  
4004			endm  
# End of macro DMARK
4004						CALLMONITOR 
4004 cd aa fd			call debug_vector  
4007				endm  
# End of macro CALLMONITOR
4007					endif 
4007 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
4009 3e 00			ld a, 0 
400b 32 78 f9			ld (cli_mvdot), a 
400e c3 6b 40			jp .dotgo 
4011				NEXTW 
4011 c3 c5 23			jp macro_next 
4014				endm 
# End of macro NEXTW
4014			.DOTF: 
4014				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
4014 1c				db WORD_SYS_CORE+8             
4015 42 40			dw .DOT            
4017 03				db 2 + 1 
4018 .. 00			db ".>",0              
401b				endm 
# End of macro CWHEAD
401b			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
401b					; get value off TOS and display it 
401b			        ; TODO BUG adds extra spaces 
401b			        ; TODO BUG handle numerics? 
401b					if DEBUG_FORTH_WORDS_KEY 
401b						DMARK "DTC" 
401b f5				push af  
401c 3a 30 40			ld a, (.dmark)  
401f 32 a6 fd			ld (debug_mark),a  
4022 3a 31 40			ld a, (.dmark+1)  
4025 32 a7 fd			ld (debug_mark+1),a  
4028 3a 32 40			ld a, (.dmark+2)  
402b 32 a8 fd			ld (debug_mark+2),a  
402e 18 03			jr .pastdmark  
4030 ..			.dmark: db "DTC"  
4033 f1			.pastdmark: pop af  
4034			endm  
# End of macro DMARK
4034						CALLMONITOR 
4034 cd aa fd			call debug_vector  
4037				endm  
# End of macro CALLMONITOR
4037					endif 
4037 3e 01			ld a, 1 
4039 32 78 f9			ld (cli_mvdot), a 
403c c3 6b 40			jp .dotgo 
403f				NEXTW 
403f c3 c5 23			jp macro_next 
4042				endm 
# End of macro NEXTW
4042			 
4042			.DOT: 
4042				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
4042 1c				db WORD_SYS_CORE+8             
4043 1e 42			dw .CLS            
4045 02				db 1 + 1 
4046 .. 00			db ".",0              
4048				endm 
# End of macro CWHEAD
4048			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
4048					; get value off TOS and display it 
4048			 
4048					if DEBUG_FORTH_WORDS_KEY 
4048						DMARK "DOT" 
4048 f5				push af  
4049 3a 5d 40			ld a, (.dmark)  
404c 32 a6 fd			ld (debug_mark),a  
404f 3a 5e 40			ld a, (.dmark+1)  
4052 32 a7 fd			ld (debug_mark+1),a  
4055 3a 5f 40			ld a, (.dmark+2)  
4058 32 a8 fd			ld (debug_mark+2),a  
405b 18 03			jr .pastdmark  
405d ..			.dmark: db "DOT"  
4060 f1			.pastdmark: pop af  
4061			endm  
# End of macro DMARK
4061						CALLMONITOR 
4061 cd aa fd			call debug_vector  
4064				endm  
# End of macro CALLMONITOR
4064					endif 
4064 3e 00			ld a, 0 
4066 32 78 f9			ld (cli_mvdot), a 
4069 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
406b				 
406b			 
406b			.dotgo: 
406b			 
406b			; move up type to on stack for parserv5 
406b					FORTH_DSP 
406b cd d5 21			call macro_forth_dsp 
406e				endm 
# End of macro FORTH_DSP
406e				;FORTH_DSP_VALUE  
406e			 
406e			if DEBUG_FORTH_DOT 
406e				DMARK "DOT" 
406e f5				push af  
406f 3a 83 40			ld a, (.dmark)  
4072 32 a6 fd			ld (debug_mark),a  
4075 3a 84 40			ld a, (.dmark+1)  
4078 32 a7 fd			ld (debug_mark+1),a  
407b 3a 85 40			ld a, (.dmark+2)  
407e 32 a8 fd			ld (debug_mark+2),a  
4081 18 03			jr .pastdmark  
4083 ..			.dmark: db "DOT"  
4086 f1			.pastdmark: pop af  
4087			endm  
# End of macro DMARK
4087				CALLMONITOR 
4087 cd aa fd			call debug_vector  
408a				endm  
# End of macro CALLMONITOR
408a			endif	 
408a			;		.print: 
408a			 
408a 7e				ld a,(hl)  ; work out what type of value is on the TOS 
408b 23				inc hl   ; position to the actual value 
408c fe 01			cp DS_TYPE_STR 
408e 20 06			jr nz, .dotnum1  
4090			 
4090			; display string 
4090				FORTH_DSP_VALUE  
4090 cd f8 21			call macro_forth_dsp_value 
4093				endm 
# End of macro FORTH_DSP_VALUE
4093 eb				ex de,hl 
4094 18 49			jr .dotwrite 
4096			 
4096			.dotnum1: 
4096 fe 02			cp DS_TYPE_INUM 
4098 20 44			jr nz, .dotflot 
409a			 
409a			 
409a			; display number 
409a			 
409a			;	push hl 
409a			;	call clear_display 
409a			;	pop hl 
409a			 
409a 5e				ld e, (hl) 
409b 23				inc hl 
409c 56				ld d, (hl) 
409d 21 fc f0			ld hl, scratch 
40a0			if DEBUG_FORTH_DOT 
40a0				DMARK "DT1" 
40a0 f5				push af  
40a1 3a b5 40			ld a, (.dmark)  
40a4 32 a6 fd			ld (debug_mark),a  
40a7 3a b6 40			ld a, (.dmark+1)  
40aa 32 a7 fd			ld (debug_mark+1),a  
40ad 3a b7 40			ld a, (.dmark+2)  
40b0 32 a8 fd			ld (debug_mark+2),a  
40b3 18 03			jr .pastdmark  
40b5 ..			.dmark: db "DT1"  
40b8 f1			.pastdmark: pop af  
40b9			endm  
# End of macro DMARK
40b9				CALLMONITOR 
40b9 cd aa fd			call debug_vector  
40bc				endm  
# End of macro CALLMONITOR
40bc			endif	 
40bc			 
40bc cd f1 12			call uitoa_16 
40bf eb				ex de,hl 
40c0			 
40c0			if DEBUG_FORTH_DOT 
40c0				DMARK "DT2" 
40c0 f5				push af  
40c1 3a d5 40			ld a, (.dmark)  
40c4 32 a6 fd			ld (debug_mark),a  
40c7 3a d6 40			ld a, (.dmark+1)  
40ca 32 a7 fd			ld (debug_mark+1),a  
40cd 3a d7 40			ld a, (.dmark+2)  
40d0 32 a8 fd			ld (debug_mark+2),a  
40d3 18 03			jr .pastdmark  
40d5 ..			.dmark: db "DT2"  
40d8 f1			.pastdmark: pop af  
40d9			endm  
# End of macro DMARK
40d9				CALLMONITOR 
40d9 cd aa fd			call debug_vector  
40dc				endm  
# End of macro CALLMONITOR
40dc			endif	 
40dc			 
40dc			;	ld de, os_word_scratch 
40dc 18 01			jr .dotwrite 
40de			 
40de 00			.dotflot:   nop 
40df			; TODO print floating point number 
40df			 
40df			.dotwrite:		 
40df			 
40df					; if c is set then set all '-' to spaces 
40df					; need to also take into account .>  
40df			 
40df 3e 01				ld a, 1 
40e1 b9					cp c 
40e2 20 67				jr nz, .nodashswap 
40e4			 
40e4					; DE has the string to write, working with HL 
40e4			 
40e4 06 ff				ld b, 255 
40e6 d5					push de 
40e7 e1					pop hl 
40e8			 
40e8			if DEBUG_FORTH_DOT 
40e8				DMARK "DT-" 
40e8 f5				push af  
40e9 3a fd 40			ld a, (.dmark)  
40ec 32 a6 fd			ld (debug_mark),a  
40ef 3a fe 40			ld a, (.dmark+1)  
40f2 32 a7 fd			ld (debug_mark+1),a  
40f5 3a ff 40			ld a, (.dmark+2)  
40f8 32 a8 fd			ld (debug_mark+2),a  
40fb 18 03			jr .pastdmark  
40fd ..			.dmark: db "DT-"  
4100 f1			.pastdmark: pop af  
4101			endm  
# End of macro DMARK
4101				CALLMONITOR 
4101 cd aa fd			call debug_vector  
4104				endm  
# End of macro CALLMONITOR
4104			endif	 
4104 7e			.dashscan:	ld a, (hl) 
4105 fe 00				cp 0 
4107 28 42				jr z, .nodashswap 
4109 fe 2d				cp '-' 
410b 20 03				jr nz, .dashskip 
410d 3e 20				ld a, ' ' 
410f 77					ld (hl), a 
4110 23			.dashskip:	inc hl 
4111			if DEBUG_FORTH_DOT 
4111				DMARK "D-2" 
4111 f5				push af  
4112 3a 26 41			ld a, (.dmark)  
4115 32 a6 fd			ld (debug_mark),a  
4118 3a 27 41			ld a, (.dmark+1)  
411b 32 a7 fd			ld (debug_mark+1),a  
411e 3a 28 41			ld a, (.dmark+2)  
4121 32 a8 fd			ld (debug_mark+2),a  
4124 18 03			jr .pastdmark  
4126 ..			.dmark: db "D-2"  
4129 f1			.pastdmark: pop af  
412a			endm  
# End of macro DMARK
412a				CALLMONITOR 
412a cd aa fd			call debug_vector  
412d				endm  
# End of macro CALLMONITOR
412d			endif	 
412d 10 d5				djnz .dashscan 
412f			 
412f			if DEBUG_FORTH_DOT 
412f				DMARK "D-1" 
412f f5				push af  
4130 3a 44 41			ld a, (.dmark)  
4133 32 a6 fd			ld (debug_mark),a  
4136 3a 45 41			ld a, (.dmark+1)  
4139 32 a7 fd			ld (debug_mark+1),a  
413c 3a 46 41			ld a, (.dmark+2)  
413f 32 a8 fd			ld (debug_mark+2),a  
4142 18 03			jr .pastdmark  
4144 ..			.dmark: db "D-1"  
4147 f1			.pastdmark: pop af  
4148			endm  
# End of macro DMARK
4148				CALLMONITOR 
4148 cd aa fd			call debug_vector  
414b				endm  
# End of macro CALLMONITOR
414b			endif	 
414b			 
414b			.nodashswap: 
414b			 
414b			if DEBUG_FORTH_DOT 
414b				DMARK "D-o" 
414b f5				push af  
414c 3a 60 41			ld a, (.dmark)  
414f 32 a6 fd			ld (debug_mark),a  
4152 3a 61 41			ld a, (.dmark+1)  
4155 32 a7 fd			ld (debug_mark+1),a  
4158 3a 62 41			ld a, (.dmark+2)  
415b 32 a8 fd			ld (debug_mark+2),a  
415e 18 03			jr .pastdmark  
4160 ..			.dmark: db "D-o"  
4163 f1			.pastdmark: pop af  
4164			endm  
# End of macro DMARK
4164				CALLMONITOR 
4164 cd aa fd			call debug_vector  
4167				endm  
# End of macro CALLMONITOR
4167			endif	 
4167			 
4167 d5					push de   ; save string start in case we need to advance print 
4168			 
4168 3a 99 f9				ld a, (f_cursor_ptr) 
416b cd ae 0d				call str_at_display 
416e 3a 77 f9				ld a,(cli_autodisplay) 
4171 fe 00				cp 0 
4173 28 03				jr z, .noupdate 
4175 cd be 0d						call update_display 
4178					.noupdate: 
4178			 
4178			 
4178					; see if we need to advance the print position 
4178			 
4178 e1					pop hl   ; get back string 
4179			;		ex de,hl 
4179			 
4179 3a 78 f9				ld a, (cli_mvdot) 
417c			if DEBUG_FORTH_DOT 
417c			;		ld e,a 
417c				DMARK "D>1" 
417c f5				push af  
417d 3a 91 41			ld a, (.dmark)  
4180 32 a6 fd			ld (debug_mark),a  
4183 3a 92 41			ld a, (.dmark+1)  
4186 32 a7 fd			ld (debug_mark+1),a  
4189 3a 93 41			ld a, (.dmark+2)  
418c 32 a8 fd			ld (debug_mark+2),a  
418f 18 03			jr .pastdmark  
4191 ..			.dmark: db "D>1"  
4194 f1			.pastdmark: pop af  
4195			endm  
# End of macro DMARK
4195				CALLMONITOR 
4195 cd aa fd			call debug_vector  
4198				endm  
# End of macro CALLMONITOR
4198			endif	 
4198 fe 00				cp 0 
419a 28 44				jr z, .noadv 
419c					; yes, lets advance the print position 
419c 3e 00				ld a, 0 
419e cd 4d 13				call strlent 
41a1			if DEBUG_FORTH_DOT 
41a1				DMARK "D-?" 
41a1 f5				push af  
41a2 3a b6 41			ld a, (.dmark)  
41a5 32 a6 fd			ld (debug_mark),a  
41a8 3a b7 41			ld a, (.dmark+1)  
41ab 32 a7 fd			ld (debug_mark+1),a  
41ae 3a b8 41			ld a, (.dmark+2)  
41b1 32 a8 fd			ld (debug_mark+2),a  
41b4 18 03			jr .pastdmark  
41b6 ..			.dmark: db "D-?"  
41b9 f1			.pastdmark: pop af  
41ba			endm  
# End of macro DMARK
41ba				CALLMONITOR 
41ba cd aa fd			call debug_vector  
41bd				endm  
# End of macro CALLMONITOR
41bd			endif	 
41bd 3a 99 f9				ld a, (f_cursor_ptr) 
41c0 85					add a,l 
41c1					;call addatohl 
41c1					;ld a, l 
41c1 32 99 f9				ld (f_cursor_ptr), a   ; save new pos 
41c4			 
41c4			if DEBUG_FORTH_DOT 
41c4				DMARK "D->" 
41c4 f5				push af  
41c5 3a d9 41			ld a, (.dmark)  
41c8 32 a6 fd			ld (debug_mark),a  
41cb 3a da 41			ld a, (.dmark+1)  
41ce 32 a7 fd			ld (debug_mark+1),a  
41d1 3a db 41			ld a, (.dmark+2)  
41d4 32 a8 fd			ld (debug_mark+2),a  
41d7 18 03			jr .pastdmark  
41d9 ..			.dmark: db "D->"  
41dc f1			.pastdmark: pop af  
41dd			endm  
# End of macro DMARK
41dd				CALLMONITOR 
41dd cd aa fd			call debug_vector  
41e0				endm  
# End of macro CALLMONITOR
41e0			endif	 
41e0			 
41e0			.noadv:	 
41e0			 
41e0					if DEBUG_FORTH_DOT_WAIT 
41e0							call next_page_prompt 
41e0					endif	 
41e0			; TODO this pop off the stack causes a crash. i dont know why 
41e0			 
41e0			 
41e0			if DEBUG_FORTH_DOT 
41e0				DMARK "DTh" 
41e0 f5				push af  
41e1 3a f5 41			ld a, (.dmark)  
41e4 32 a6 fd			ld (debug_mark),a  
41e7 3a f6 41			ld a, (.dmark+1)  
41ea 32 a7 fd			ld (debug_mark+1),a  
41ed 3a f7 41			ld a, (.dmark+2)  
41f0 32 a8 fd			ld (debug_mark+2),a  
41f3 18 03			jr .pastdmark  
41f5 ..			.dmark: db "DTh"  
41f8 f1			.pastdmark: pop af  
41f9			endm  
# End of macro DMARK
41f9				CALLMONITOR 
41f9 cd aa fd			call debug_vector  
41fc				endm  
# End of macro CALLMONITOR
41fc			endif	 
41fc			 
41fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
41fc cd c7 22			call macro_forth_dsp_pop 
41ff				endm 
# End of macro FORTH_DSP_POP
41ff			 
41ff			if DEBUG_FORTH_DOT 
41ff				DMARK "DTi" 
41ff f5				push af  
4200 3a 14 42			ld a, (.dmark)  
4203 32 a6 fd			ld (debug_mark),a  
4206 3a 15 42			ld a, (.dmark+1)  
4209 32 a7 fd			ld (debug_mark+1),a  
420c 3a 16 42			ld a, (.dmark+2)  
420f 32 a8 fd			ld (debug_mark+2),a  
4212 18 03			jr .pastdmark  
4214 ..			.dmark: db "DTi"  
4217 f1			.pastdmark: pop af  
4218			endm  
# End of macro DMARK
4218				CALLMONITOR 
4218 cd aa fd			call debug_vector  
421b				endm  
# End of macro CALLMONITOR
421b			endif	 
421b			 
421b			 
421b					NEXTW 
421b c3 c5 23			jp macro_next 
421e				endm 
# End of macro NEXTW
421e			 
421e			.CLS: 
421e				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
421e 35				db WORD_SYS_CORE+33             
421f 4b 42			dw .DRAW            
4221 04				db 3 + 1 
4222 .. 00			db "CLS",0              
4226				endm 
# End of macro CWHEAD
4226			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4226					if DEBUG_FORTH_WORDS_KEY 
4226						DMARK "CLS" 
4226 f5				push af  
4227 3a 3b 42			ld a, (.dmark)  
422a 32 a6 fd			ld (debug_mark),a  
422d 3a 3c 42			ld a, (.dmark+1)  
4230 32 a7 fd			ld (debug_mark+1),a  
4233 3a 3d 42			ld a, (.dmark+2)  
4236 32 a8 fd			ld (debug_mark+2),a  
4239 18 03			jr .pastdmark  
423b ..			.dmark: db "CLS"  
423e f1			.pastdmark: pop af  
423f			endm  
# End of macro DMARK
423f						CALLMONITOR 
423f cd aa fd			call debug_vector  
4242				endm  
# End of macro CALLMONITOR
4242					endif 
4242 cd 9b 0d				call clear_display 
4245 c3 59 43				jp .home		; and home cursor 
4248					NEXTW 
4248 c3 c5 23			jp macro_next 
424b				endm 
# End of macro NEXTW
424b			 
424b			.DRAW: 
424b				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
424b 36				db WORD_SYS_CORE+34             
424c 76 42			dw .DUMP            
424e 05				db 4 + 1 
424f .. 00			db "DRAW",0              
4254				endm 
# End of macro CWHEAD
4254			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
4254					if DEBUG_FORTH_WORDS_KEY 
4254						DMARK "DRW" 
4254 f5				push af  
4255 3a 69 42			ld a, (.dmark)  
4258 32 a6 fd			ld (debug_mark),a  
425b 3a 6a 42			ld a, (.dmark+1)  
425e 32 a7 fd			ld (debug_mark+1),a  
4261 3a 6b 42			ld a, (.dmark+2)  
4264 32 a8 fd			ld (debug_mark+2),a  
4267 18 03			jr .pastdmark  
4269 ..			.dmark: db "DRW"  
426c f1			.pastdmark: pop af  
426d			endm  
# End of macro DMARK
426d						CALLMONITOR 
426d cd aa fd			call debug_vector  
4270				endm  
# End of macro CALLMONITOR
4270					endif 
4270 cd be 0d				call update_display 
4273					NEXTW 
4273 c3 c5 23			jp macro_next 
4276				endm 
# End of macro NEXTW
4276			 
4276			.DUMP: 
4276				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
4276 37				db WORD_SYS_CORE+35             
4277 ae 42			dw .CDUMP            
4279 05				db 4 + 1 
427a .. 00			db "DUMP",0              
427f				endm 
# End of macro CWHEAD
427f			; | DUMP ( x -- ) With address x display dump   | DONE 
427f			; TODO pop address to use off of the stack 
427f					if DEBUG_FORTH_WORDS_KEY 
427f						DMARK "DUM" 
427f f5				push af  
4280 3a 94 42			ld a, (.dmark)  
4283 32 a6 fd			ld (debug_mark),a  
4286 3a 95 42			ld a, (.dmark+1)  
4289 32 a7 fd			ld (debug_mark+1),a  
428c 3a 96 42			ld a, (.dmark+2)  
428f 32 a8 fd			ld (debug_mark+2),a  
4292 18 03			jr .pastdmark  
4294 ..			.dmark: db "DUM"  
4297 f1			.pastdmark: pop af  
4298			endm  
# End of macro DMARK
4298						CALLMONITOR 
4298 cd aa fd			call debug_vector  
429b				endm  
# End of macro CALLMONITOR
429b					endif 
429b cd 9b 0d				call clear_display 
429e			 
429e					; get address 
429e			 
429e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
429e cd 0f 22			call macro_dsp_valuehl 
42a1				endm 
# End of macro FORTH_DSP_VALUEHL
42a1				 
42a1					; save it for cdump 
42a1			 
42a1 22 1f f4				ld (os_cur_ptr),hl 
42a4			 
42a4					; destroy value TOS 
42a4			 
42a4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42a4 cd c7 22			call macro_forth_dsp_pop 
42a7				endm 
# End of macro FORTH_DSP_POP
42a7			 
42a7 cd 98 1e				call dumpcont	; skip old style of param parsing	 
42aa c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
42ab					NEXTW 
42ab c3 c5 23			jp macro_next 
42ae				endm 
# End of macro NEXTW
42ae			.CDUMP: 
42ae				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
42ae 38				db WORD_SYS_CORE+36             
42af de 42			dw .DAT            
42b1 06				db 5 + 1 
42b2 .. 00			db "CDUMP",0              
42b8				endm 
# End of macro CWHEAD
42b8			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
42b8					if DEBUG_FORTH_WORDS_KEY 
42b8						DMARK "CDP" 
42b8 f5				push af  
42b9 3a cd 42			ld a, (.dmark)  
42bc 32 a6 fd			ld (debug_mark),a  
42bf 3a ce 42			ld a, (.dmark+1)  
42c2 32 a7 fd			ld (debug_mark+1),a  
42c5 3a cf 42			ld a, (.dmark+2)  
42c8 32 a8 fd			ld (debug_mark+2),a  
42cb 18 03			jr .pastdmark  
42cd ..			.dmark: db "CDP"  
42d0 f1			.pastdmark: pop af  
42d1			endm  
# End of macro DMARK
42d1						CALLMONITOR 
42d1 cd aa fd			call debug_vector  
42d4				endm  
# End of macro CALLMONITOR
42d4					endif 
42d4 cd 9b 0d				call clear_display 
42d7 cd 98 1e				call dumpcont	 
42da c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
42db					NEXTW 
42db c3 c5 23			jp macro_next 
42de				endm 
# End of macro NEXTW
42de			 
42de			 
42de			 
42de			 
42de			.DAT: 
42de				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
42de 3d				db WORD_SYS_CORE+41             
42df 34 43			dw .HOME            
42e1 03				db 2 + 1 
42e2 .. 00			db "AT",0              
42e5				endm 
# End of macro CWHEAD
42e5			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
42e5					if DEBUG_FORTH_WORDS_KEY 
42e5						DMARK "AT." 
42e5 f5				push af  
42e6 3a fa 42			ld a, (.dmark)  
42e9 32 a6 fd			ld (debug_mark),a  
42ec 3a fb 42			ld a, (.dmark+1)  
42ef 32 a7 fd			ld (debug_mark+1),a  
42f2 3a fc 42			ld a, (.dmark+2)  
42f5 32 a8 fd			ld (debug_mark+2),a  
42f8 18 03			jr .pastdmark  
42fa ..			.dmark: db "AT."  
42fd f1			.pastdmark: pop af  
42fe			endm  
# End of macro DMARK
42fe						CALLMONITOR 
42fe cd aa fd			call debug_vector  
4301				endm  
# End of macro CALLMONITOR
4301					endif 
4301					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4301 cd 0f 22			call macro_dsp_valuehl 
4304				endm 
# End of macro FORTH_DSP_VALUEHL
4304			 
4304			 
4304					; TODO save cursor row 
4304 7d					ld a,l 
4305 fe 02				cp 2 
4307 20 04				jr nz, .crow3 
4309 3e 28				ld a, display_row_2 
430b 18 12				jr .ccol1 
430d fe 03		.crow3:		cp 3 
430f 20 04				jr nz, .crow4 
4311 3e 50				ld a, display_row_3 
4313 18 0a				jr .ccol1 
4315 fe 04		.crow4:		cp 4 
4317 20 04				jr nz, .crow1 
4319 3e 78				ld a, display_row_4 
431b 18 02				jr .ccol1 
431d 3e 00		.crow1:		ld a,display_row_1 
431f f5			.ccol1:		push af			; got row offset 
4320 6f					ld l,a 
4321 26 00				ld h,0 
4323					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4323 cd c7 22			call macro_forth_dsp_pop 
4326				endm 
# End of macro FORTH_DSP_POP
4326					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4326 cd 0f 22			call macro_dsp_valuehl 
4329				endm 
# End of macro FORTH_DSP_VALUEHL
4329					; TODO save cursor col 
4329 f1					pop af 
432a 85					add l		; add col offset 
432b 32 99 f9				ld (f_cursor_ptr), a 
432e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
432e cd c7 22			call macro_forth_dsp_pop 
4331				endm 
# End of macro FORTH_DSP_POP
4331			 
4331					; calculate  
4331			 
4331					NEXTW 
4331 c3 c5 23			jp macro_next 
4334				endm 
# End of macro NEXTW
4334			 
4334			 
4334			.HOME: 
4334				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
4334 41				db WORD_SYS_CORE+45             
4335 61 43			dw .CR            
4337 05				db 4 + 1 
4338 .. 00			db "HOME",0              
433d				endm 
# End of macro CWHEAD
433d			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
433d					if DEBUG_FORTH_WORDS_KEY 
433d						DMARK "HOM" 
433d f5				push af  
433e 3a 52 43			ld a, (.dmark)  
4341 32 a6 fd			ld (debug_mark),a  
4344 3a 53 43			ld a, (.dmark+1)  
4347 32 a7 fd			ld (debug_mark+1),a  
434a 3a 54 43			ld a, (.dmark+2)  
434d 32 a8 fd			ld (debug_mark+2),a  
4350 18 03			jr .pastdmark  
4352 ..			.dmark: db "HOM"  
4355 f1			.pastdmark: pop af  
4356			endm  
# End of macro DMARK
4356						CALLMONITOR 
4356 cd aa fd			call debug_vector  
4359				endm  
# End of macro CALLMONITOR
4359					endif 
4359 3e 00		.home:		ld a, 0		; and home cursor 
435b 32 99 f9				ld (f_cursor_ptr), a 
435e					NEXTW 
435e c3 c5 23			jp macro_next 
4361				endm 
# End of macro NEXTW
4361			 
4361			 
4361			.CR: 
4361				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
4361 46				db WORD_SYS_CORE+50             
4362 9c 43			dw .SPACE            
4364 03				db 2 + 1 
4365 .. 00			db "CR",0              
4368				endm 
# End of macro CWHEAD
4368			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
4368					if DEBUG_FORTH_WORDS_KEY 
4368						DMARK "CR." 
4368 f5				push af  
4369 3a 7d 43			ld a, (.dmark)  
436c 32 a6 fd			ld (debug_mark),a  
436f 3a 7e 43			ld a, (.dmark+1)  
4372 32 a7 fd			ld (debug_mark+1),a  
4375 3a 7f 43			ld a, (.dmark+2)  
4378 32 a8 fd			ld (debug_mark+2),a  
437b 18 03			jr .pastdmark  
437d ..			.dmark: db "CR."  
4380 f1			.pastdmark: pop af  
4381			endm  
# End of macro DMARK
4381						CALLMONITOR 
4381 cd aa fd			call debug_vector  
4384				endm  
# End of macro CALLMONITOR
4384					endif 
4384 3e 0d				ld a, 13 
4386 32 fc f0				ld (scratch),a 
4389 3e 0a				ld a, 10 
438b 32 fd f0				ld (scratch+1),a 
438e 3e 00				ld a, 0 
4390 32 fe f0				ld (scratch+2),a 
4393 21 fc f0				ld hl, scratch 
4396 cd 86 20				call forth_push_str 
4399					 
4399				       NEXTW 
4399 c3 c5 23			jp macro_next 
439c				endm 
# End of macro NEXTW
439c			.SPACE: 
439c				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
439c 46				db WORD_SYS_CORE+50             
439d d2 43			dw .SPACES            
439f 03				db 2 + 1 
43a0 .. 00			db "BL",0              
43a3				endm 
# End of macro CWHEAD
43a3			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
43a3					if DEBUG_FORTH_WORDS_KEY 
43a3						DMARK "BL." 
43a3 f5				push af  
43a4 3a b8 43			ld a, (.dmark)  
43a7 32 a6 fd			ld (debug_mark),a  
43aa 3a b9 43			ld a, (.dmark+1)  
43ad 32 a7 fd			ld (debug_mark+1),a  
43b0 3a ba 43			ld a, (.dmark+2)  
43b3 32 a8 fd			ld (debug_mark+2),a  
43b6 18 03			jr .pastdmark  
43b8 ..			.dmark: db "BL."  
43bb f1			.pastdmark: pop af  
43bc			endm  
# End of macro DMARK
43bc						CALLMONITOR 
43bc cd aa fd			call debug_vector  
43bf				endm  
# End of macro CALLMONITOR
43bf					endif 
43bf 3e 20				ld a, " " 
43c1 32 fc f0				ld (scratch),a 
43c4 3e 00				ld a, 0 
43c6 32 fd f0				ld (scratch+1),a 
43c9 21 fc f0				ld hl, scratch 
43cc cd 86 20				call forth_push_str 
43cf					 
43cf				       NEXTW 
43cf c3 c5 23			jp macro_next 
43d2				endm 
# End of macro NEXTW
43d2			 
43d2			;.blstr: db " ", 0 
43d2			 
43d2			.SPACES: 
43d2				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
43d2 47				db WORD_SYS_CORE+51             
43d3 6d 44			dw .SCROLL            
43d5 07				db 6 + 1 
43d6 .. 00			db "SPACES",0              
43dd				endm 
# End of macro CWHEAD
43dd			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
43dd					if DEBUG_FORTH_WORDS_KEY 
43dd						DMARK "SPS" 
43dd f5				push af  
43de 3a f2 43			ld a, (.dmark)  
43e1 32 a6 fd			ld (debug_mark),a  
43e4 3a f3 43			ld a, (.dmark+1)  
43e7 32 a7 fd			ld (debug_mark+1),a  
43ea 3a f4 43			ld a, (.dmark+2)  
43ed 32 a8 fd			ld (debug_mark+2),a  
43f0 18 03			jr .pastdmark  
43f2 ..			.dmark: db "SPS"  
43f5 f1			.pastdmark: pop af  
43f6			endm  
# End of macro DMARK
43f6						CALLMONITOR 
43f6 cd aa fd			call debug_vector  
43f9				endm  
# End of macro CALLMONITOR
43f9					endif 
43f9			 
43f9			 
43f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43f9 cd 0f 22			call macro_dsp_valuehl 
43fc				endm 
# End of macro FORTH_DSP_VALUEHL
43fc			 
43fc e5					push hl    ; u 
43fd					if DEBUG_FORTH_WORDS 
43fd						DMARK "SPA" 
43fd f5				push af  
43fe 3a 12 44			ld a, (.dmark)  
4401 32 a6 fd			ld (debug_mark),a  
4404 3a 13 44			ld a, (.dmark+1)  
4407 32 a7 fd			ld (debug_mark+1),a  
440a 3a 14 44			ld a, (.dmark+2)  
440d 32 a8 fd			ld (debug_mark+2),a  
4410 18 03			jr .pastdmark  
4412 ..			.dmark: db "SPA"  
4415 f1			.pastdmark: pop af  
4416			endm  
# End of macro DMARK
4416						CALLMONITOR 
4416 cd aa fd			call debug_vector  
4419				endm  
# End of macro CALLMONITOR
4419					endif 
4419			 
4419					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4419 cd c7 22			call macro_forth_dsp_pop 
441c				endm 
# End of macro FORTH_DSP_POP
441c e1					pop hl 
441d 0e 00				ld c, 0 
441f 45					ld b, l 
4420 21 fc f0				ld hl, scratch  
4423			 
4423					if DEBUG_FORTH_WORDS 
4423						DMARK "SP2" 
4423 f5				push af  
4424 3a 38 44			ld a, (.dmark)  
4427 32 a6 fd			ld (debug_mark),a  
442a 3a 39 44			ld a, (.dmark+1)  
442d 32 a7 fd			ld (debug_mark+1),a  
4430 3a 3a 44			ld a, (.dmark+2)  
4433 32 a8 fd			ld (debug_mark+2),a  
4436 18 03			jr .pastdmark  
4438 ..			.dmark: db "SP2"  
443b f1			.pastdmark: pop af  
443c			endm  
# End of macro DMARK
443c						CALLMONITOR 
443c cd aa fd			call debug_vector  
443f				endm  
# End of macro CALLMONITOR
443f					endif 
443f 3e 20				ld a, ' ' 
4441			.spaces1:	 
4441 77					ld (hl),a 
4442 23					inc hl 
4443					 
4443 10 fc				djnz .spaces1 
4445 3e 00				ld a,0 
4447 77					ld (hl),a 
4448 21 fc f0				ld hl, scratch 
444b					if DEBUG_FORTH_WORDS 
444b						DMARK "SP3" 
444b f5				push af  
444c 3a 60 44			ld a, (.dmark)  
444f 32 a6 fd			ld (debug_mark),a  
4452 3a 61 44			ld a, (.dmark+1)  
4455 32 a7 fd			ld (debug_mark+1),a  
4458 3a 62 44			ld a, (.dmark+2)  
445b 32 a8 fd			ld (debug_mark+2),a  
445e 18 03			jr .pastdmark  
4460 ..			.dmark: db "SP3"  
4463 f1			.pastdmark: pop af  
4464			endm  
# End of macro DMARK
4464						CALLMONITOR 
4464 cd aa fd			call debug_vector  
4467				endm  
# End of macro CALLMONITOR
4467					endif 
4467 cd 86 20				call forth_push_str 
446a			 
446a				       NEXTW 
446a c3 c5 23			jp macro_next 
446d				endm 
# End of macro NEXTW
446d			 
446d			 
446d			 
446d			.SCROLL: 
446d				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
446d 53				db WORD_SYS_CORE+63             
446e 9a 44			dw .SCROLLD            
4470 07				db 6 + 1 
4471 .. 00			db "SCROLL",0              
4478				endm 
# End of macro CWHEAD
4478			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4478					if DEBUG_FORTH_WORDS_KEY 
4478						DMARK "SCR" 
4478 f5				push af  
4479 3a 8d 44			ld a, (.dmark)  
447c 32 a6 fd			ld (debug_mark),a  
447f 3a 8e 44			ld a, (.dmark+1)  
4482 32 a7 fd			ld (debug_mark+1),a  
4485 3a 8f 44			ld a, (.dmark+2)  
4488 32 a8 fd			ld (debug_mark+2),a  
448b 18 03			jr .pastdmark  
448d ..			.dmark: db "SCR"  
4490 f1			.pastdmark: pop af  
4491			endm  
# End of macro DMARK
4491						CALLMONITOR 
4491 cd aa fd			call debug_vector  
4494				endm  
# End of macro CALLMONITOR
4494					endif 
4494			 
4494 cd 5d 0d			call scroll_up 
4497			;	call update_display 
4497			 
4497					NEXTW 
4497 c3 c5 23			jp macro_next 
449a				endm 
# End of macro NEXTW
449a			 
449a			 
449a			 
449a			;		; get dir 
449a			; 
449a			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
449a			; 
449a			;		push hl 
449a			; 
449a			;		; destroy value TOS 
449a			; 
449a			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
449a			; 
449a			;		; get count 
449a			; 
449a			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
449a			; 
449a			;		push hl 
449a			; 
449a			;		; destroy value TOS 
449a			; 
449a			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
449a			; 
449a			;		; one value on hl get other one back 
449a			; 
449a			;		pop bc    ; count 
449a			; 
449a			;		pop de   ; dir 
449a			; 
449a			; 
449a			;		ld b, c 
449a			; 
449a			;.scrolldir:     push bc 
449a			;		push de 
449a			; 
449a			;		ld a, 0 
449a			;		cp e 
449a			;		jr z, .scrollup  
449a			;		call scroll_down 
449a			;		jr .scrollnext 
449a			;.scrollup:	call scroll_up 
449a			; 
449a			;		 
449a			;.scrollnext: 
449a			;		pop de 
449a			;		pop bc 
449a			;		djnz .scrolldir 
449a			; 
449a			; 
449a			; 
449a			; 
449a			; 
449a			;		NEXTW 
449a			 
449a			.SCROLLD: 
449a				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
449a 53				db WORD_SYS_CORE+63             
449b c8 44			dw .ATQ            
449d 08				db 7 + 1 
449e .. 00			db "SCROLLD",0              
44a6				endm 
# End of macro CWHEAD
44a6			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
44a6					if DEBUG_FORTH_WORDS_KEY 
44a6						DMARK "SCD" 
44a6 f5				push af  
44a7 3a bb 44			ld a, (.dmark)  
44aa 32 a6 fd			ld (debug_mark),a  
44ad 3a bc 44			ld a, (.dmark+1)  
44b0 32 a7 fd			ld (debug_mark+1),a  
44b3 3a bd 44			ld a, (.dmark+2)  
44b6 32 a8 fd			ld (debug_mark+2),a  
44b9 18 03			jr .pastdmark  
44bb ..			.dmark: db "SCD"  
44be f1			.pastdmark: pop af  
44bf			endm  
# End of macro DMARK
44bf						CALLMONITOR 
44bf cd aa fd			call debug_vector  
44c2				endm  
# End of macro CALLMONITOR
44c2					endif 
44c2			 
44c2 cd 81 0d			call scroll_down 
44c5			;	call update_display 
44c5			 
44c5					NEXTW 
44c5 c3 c5 23			jp macro_next 
44c8				endm 
# End of macro NEXTW
44c8			 
44c8			 
44c8			.ATQ: 
44c8				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
44c8 62				db WORD_SYS_CORE+78             
44c9 26 45			dw .AUTODSP            
44cb 04				db 3 + 1 
44cc .. 00			db "AT@",0              
44d0				endm 
# End of macro CWHEAD
44d0			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
44d0					if DEBUG_FORTH_WORDS_KEY 
44d0						DMARK "ATA" 
44d0 f5				push af  
44d1 3a e5 44			ld a, (.dmark)  
44d4 32 a6 fd			ld (debug_mark),a  
44d7 3a e6 44			ld a, (.dmark+1)  
44da 32 a7 fd			ld (debug_mark+1),a  
44dd 3a e7 44			ld a, (.dmark+2)  
44e0 32 a8 fd			ld (debug_mark+2),a  
44e3 18 03			jr .pastdmark  
44e5 ..			.dmark: db "ATA"  
44e8 f1			.pastdmark: pop af  
44e9			endm  
# End of macro DMARK
44e9						CALLMONITOR 
44e9 cd aa fd			call debug_vector  
44ec				endm  
# End of macro CALLMONITOR
44ec					endif 
44ec			 
44ec			 
44ec					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44ec cd 0f 22			call macro_dsp_valuehl 
44ef				endm 
# End of macro FORTH_DSP_VALUEHL
44ef			 
44ef					; TODO save cursor row 
44ef 7d					ld a,l 
44f0 fe 02				cp 2 
44f2 20 04				jr nz, .crow3aq 
44f4 3e 28				ld a, display_row_2 
44f6 18 12				jr .ccol1aq 
44f8 fe 03		.crow3aq:		cp 3 
44fa 20 04				jr nz, .crow4aq 
44fc 3e 50				ld a, display_row_3 
44fe 18 0a				jr .ccol1aq 
4500 fe 04		.crow4aq:		cp 4 
4502 20 04				jr nz, .crow1aq 
4504 3e 78				ld a, display_row_4 
4506 18 02				jr .ccol1aq 
4508 3e 00		.crow1aq:		ld a,display_row_1 
450a f5			.ccol1aq:		push af			; got row offset 
450b 6f					ld l,a 
450c 26 00				ld h,0 
450e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
450e cd c7 22			call macro_forth_dsp_pop 
4511				endm 
# End of macro FORTH_DSP_POP
4511					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4511 cd 0f 22			call macro_dsp_valuehl 
4514				endm 
# End of macro FORTH_DSP_VALUEHL
4514					; TODO save cursor col 
4514 f1					pop af 
4515 85					add l		; add col offset 
4516			 
4516					; add current frame buffer address 
4516 2a 07 fb				ld hl, (display_fb_active) 
4519 cd cf 0f				call addatohl 
451c			 
451c			 
451c			 
451c			 
451c					; get char frame buffer location offset in hl 
451c			 
451c 7e					ld a,(hl) 
451d 26 00				ld h, 0 
451f 6f					ld l, a 
4520			 
4520 cd 18 20				call forth_push_numhl 
4523			 
4523			 
4523					NEXTW 
4523 c3 c5 23			jp macro_next 
4526				endm 
# End of macro NEXTW
4526			 
4526			.AUTODSP: 
4526				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4526 63				db WORD_SYS_CORE+79             
4527 3c 45			dw .MENU            
4529 05				db 4 + 1 
452a .. 00			db "ADSP",0              
452f				endm 
# End of macro CWHEAD
452f			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
452f			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
452f			 
452f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
452f cd 0f 22			call macro_dsp_valuehl 
4532				endm 
# End of macro FORTH_DSP_VALUEHL
4532			 
4532			;		push hl 
4532			 
4532					; destroy value TOS 
4532			 
4532					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4532 cd c7 22			call macro_forth_dsp_pop 
4535				endm 
# End of macro FORTH_DSP_POP
4535			 
4535			;		pop hl 
4535			 
4535 7d					ld a,l 
4536 32 77 f9				ld (cli_autodisplay), a 
4539				       NEXTW 
4539 c3 c5 23			jp macro_next 
453c				endm 
# End of macro NEXTW
453c			 
453c			.MENU: 
453c				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
453c 70				db WORD_SYS_CORE+92             
453d e5 45			dw .ENDDISPLAY            
453f 05				db 4 + 1 
4540 .. 00			db "MENU",0              
4545				endm 
# End of macro CWHEAD
4545			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
4545			 
4545			;		; get number of items on the stack 
4545			; 
4545				 
4545					FORTH_DSP_VALUEHL 
4545 cd 0f 22			call macro_dsp_valuehl 
4548				endm 
# End of macro FORTH_DSP_VALUEHL
4548				 
4548					if DEBUG_FORTH_WORDS_KEY 
4548						DMARK "MNU" 
4548 f5				push af  
4549 3a 5d 45			ld a, (.dmark)  
454c 32 a6 fd			ld (debug_mark),a  
454f 3a 5e 45			ld a, (.dmark+1)  
4552 32 a7 fd			ld (debug_mark+1),a  
4555 3a 5f 45			ld a, (.dmark+2)  
4558 32 a8 fd			ld (debug_mark+2),a  
455b 18 03			jr .pastdmark  
455d ..			.dmark: db "MNU"  
4560 f1			.pastdmark: pop af  
4561			endm  
# End of macro DMARK
4561						CALLMONITOR 
4561 cd aa fd			call debug_vector  
4564				endm  
# End of macro CALLMONITOR
4564					endif 
4564			 
4564 45					ld b, l	 
4565 05					dec b 
4566			 
4566					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4566 cd c7 22			call macro_forth_dsp_pop 
4569				endm 
# End of macro FORTH_DSP_POP
4569			 
4569			 
4569					; go directly through the stack to pluck out the string pointers and build an array 
4569			 
4569			;		FORTH_DSP 
4569			 
4569					; hl contains top most stack item 
4569				 
4569 11 fc f0				ld de, scratch 
456c			 
456c			.mbuild: 
456c			 
456c					FORTH_DSP_VALUEHL 
456c cd 0f 22			call macro_dsp_valuehl 
456f				endm 
# End of macro FORTH_DSP_VALUEHL
456f			 
456f					if DEBUG_FORTH_WORDS 
456f						DMARK "MN3" 
456f f5				push af  
4570 3a 84 45			ld a, (.dmark)  
4573 32 a6 fd			ld (debug_mark),a  
4576 3a 85 45			ld a, (.dmark+1)  
4579 32 a7 fd			ld (debug_mark+1),a  
457c 3a 86 45			ld a, (.dmark+2)  
457f 32 a8 fd			ld (debug_mark+2),a  
4582 18 03			jr .pastdmark  
4584 ..			.dmark: db "MN3"  
4587 f1			.pastdmark: pop af  
4588			endm  
# End of macro DMARK
4588						CALLMONITOR 
4588 cd aa fd			call debug_vector  
458b				endm  
# End of macro CALLMONITOR
458b					endif 
458b eb					ex de, hl 
458c 73					ld (hl), e 
458d 23					inc hl 
458e 72					ld (hl), d 
458f 23					inc hl 
4590 eb					ex de, hl 
4591			 
4591					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4591 cd c7 22			call macro_forth_dsp_pop 
4594				endm 
# End of macro FORTH_DSP_POP
4594			 
4594 10 d6				djnz .mbuild 
4596			 
4596					; done add term 
4596			 
4596 eb					ex de, hl 
4597 36 00				ld (hl), 0 
4599 23					inc hl 
459a 36 00				ld (hl), 0 
459c			 
459c				 
459c					 
459c 21 fc f0				ld hl, scratch 
459f			 
459f					if DEBUG_FORTH_WORDS 
459f						DMARK "MNx" 
459f f5				push af  
45a0 3a b4 45			ld a, (.dmark)  
45a3 32 a6 fd			ld (debug_mark),a  
45a6 3a b5 45			ld a, (.dmark+1)  
45a9 32 a7 fd			ld (debug_mark+1),a  
45ac 3a b6 45			ld a, (.dmark+2)  
45af 32 a8 fd			ld (debug_mark+2),a  
45b2 18 03			jr .pastdmark  
45b4 ..			.dmark: db "MNx"  
45b7 f1			.pastdmark: pop af  
45b8			endm  
# End of macro DMARK
45b8						CALLMONITOR 
45b8 cd aa fd			call debug_vector  
45bb				endm  
# End of macro CALLMONITOR
45bb					endif 
45bb			 
45bb			 
45bb			 
45bb 3e 00				ld a, 0 
45bd cd cc 0d				call menu 
45c0			 
45c0			 
45c0 6f					ld l, a 
45c1 26 00				ld h, 0 
45c3			 
45c3					if DEBUG_FORTH_WORDS 
45c3						DMARK "MNr" 
45c3 f5				push af  
45c4 3a d8 45			ld a, (.dmark)  
45c7 32 a6 fd			ld (debug_mark),a  
45ca 3a d9 45			ld a, (.dmark+1)  
45cd 32 a7 fd			ld (debug_mark+1),a  
45d0 3a da 45			ld a, (.dmark+2)  
45d3 32 a8 fd			ld (debug_mark+2),a  
45d6 18 03			jr .pastdmark  
45d8 ..			.dmark: db "MNr"  
45db f1			.pastdmark: pop af  
45dc			endm  
# End of macro DMARK
45dc						CALLMONITOR 
45dc cd aa fd			call debug_vector  
45df				endm  
# End of macro CALLMONITOR
45df					endif 
45df			 
45df cd 18 20				call forth_push_numhl 
45e2			 
45e2			 
45e2			 
45e2			 
45e2				       NEXTW 
45e2 c3 c5 23			jp macro_next 
45e5				endm 
# End of macro NEXTW
45e5			 
45e5			 
45e5			.ENDDISPLAY: 
45e5			 
45e5			; eof 
# End of file forth_words_display.asm
45e5			include "forth_words_str.asm" 
45e5			 
45e5			; | ## String Words 
45e5			 
45e5			.PTR:   
45e5			 
45e5				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
45e5 48				db WORD_SYS_CORE+52             
45e6 12 46			dw .STYPE            
45e8 04				db 3 + 1 
45e9 .. 00			db "PTR",0              
45ed				endm 
# End of macro CWHEAD
45ed			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
45ed			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
45ed			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
45ed			 
45ed					if DEBUG_FORTH_WORDS_KEY 
45ed						DMARK "PTR" 
45ed f5				push af  
45ee 3a 02 46			ld a, (.dmark)  
45f1 32 a6 fd			ld (debug_mark),a  
45f4 3a 03 46			ld a, (.dmark+1)  
45f7 32 a7 fd			ld (debug_mark+1),a  
45fa 3a 04 46			ld a, (.dmark+2)  
45fd 32 a8 fd			ld (debug_mark+2),a  
4600 18 03			jr .pastdmark  
4602 ..			.dmark: db "PTR"  
4605 f1			.pastdmark: pop af  
4606			endm  
# End of macro DMARK
4606						CALLMONITOR 
4606 cd aa fd			call debug_vector  
4609				endm  
# End of macro CALLMONITOR
4609					endif 
4609					FORTH_DSP_VALUEHL 
4609 cd 0f 22			call macro_dsp_valuehl 
460c				endm 
# End of macro FORTH_DSP_VALUEHL
460c cd 18 20				call forth_push_numhl 
460f			 
460f			 
460f					NEXTW 
460f c3 c5 23			jp macro_next 
4612				endm 
# End of macro NEXTW
4612			.STYPE: 
4612				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4612 48				db WORD_SYS_CORE+52             
4613 61 46			dw .UPPER            
4615 06				db 5 + 1 
4616 .. 00			db "STYPE",0              
461c				endm 
# End of macro CWHEAD
461c			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
461c					if DEBUG_FORTH_WORDS_KEY 
461c						DMARK "STY" 
461c f5				push af  
461d 3a 31 46			ld a, (.dmark)  
4620 32 a6 fd			ld (debug_mark),a  
4623 3a 32 46			ld a, (.dmark+1)  
4626 32 a7 fd			ld (debug_mark+1),a  
4629 3a 33 46			ld a, (.dmark+2)  
462c 32 a8 fd			ld (debug_mark+2),a  
462f 18 03			jr .pastdmark  
4631 ..			.dmark: db "STY"  
4634 f1			.pastdmark: pop af  
4635			endm  
# End of macro DMARK
4635						CALLMONITOR 
4635 cd aa fd			call debug_vector  
4638				endm  
# End of macro CALLMONITOR
4638					endif 
4638					FORTH_DSP 
4638 cd d5 21			call macro_forth_dsp 
463b				endm 
# End of macro FORTH_DSP
463b					;v5 FORTH_DSP_VALUE 
463b			 
463b 7e					ld a, (hl) 
463c			 
463c f5					push af 
463d			 
463d			; Dont destroy TOS		FORTH_DSP_POP 
463d			 
463d f1					pop af 
463e			 
463e fe 01				cp DS_TYPE_STR 
4640 28 09				jr z, .typestr 
4642			 
4642 fe 02				cp DS_TYPE_INUM 
4644 28 0a				jr z, .typeinum 
4646			 
4646 21 5f 46				ld hl, .tna 
4649 18 0a				jr .tpush 
464b			 
464b 21 5b 46		.typestr:	ld hl, .tstr 
464e 18 05				jr .tpush 
4650 21 5d 46		.typeinum:	ld hl, .tinum 
4653 18 00				jr .tpush 
4655			 
4655			.tpush: 
4655			 
4655 cd 86 20				call forth_push_str 
4658			 
4658					NEXTW 
4658 c3 c5 23			jp macro_next 
465b				endm 
# End of macro NEXTW
465b .. 00		.tstr:	db "s",0 
465d .. 00		.tinum:  db "i",0 
465f .. 00		.tna:   db "?", 0 
4661			 
4661			 
4661			.UPPER: 
4661				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4661 48				db WORD_SYS_CORE+52             
4662 9c 46			dw .LOWER            
4664 06				db 5 + 1 
4665 .. 00			db "UPPER",0              
466b				endm 
# End of macro CWHEAD
466b			; | UPPER ( s -- s ) Upper case string s  | DONE 
466b					if DEBUG_FORTH_WORDS_KEY 
466b						DMARK "UPR" 
466b f5				push af  
466c 3a 80 46			ld a, (.dmark)  
466f 32 a6 fd			ld (debug_mark),a  
4672 3a 81 46			ld a, (.dmark+1)  
4675 32 a7 fd			ld (debug_mark+1),a  
4678 3a 82 46			ld a, (.dmark+2)  
467b 32 a8 fd			ld (debug_mark+2),a  
467e 18 03			jr .pastdmark  
4680 ..			.dmark: db "UPR"  
4683 f1			.pastdmark: pop af  
4684			endm  
# End of macro DMARK
4684						CALLMONITOR 
4684 cd aa fd			call debug_vector  
4687				endm  
# End of macro CALLMONITOR
4687					endif 
4687			 
4687					FORTH_DSP 
4687 cd d5 21			call macro_forth_dsp 
468a				endm 
# End of macro FORTH_DSP
468a					 
468a			; TODO check is string type 
468a			 
468a					FORTH_DSP_VALUEHL 
468a cd 0f 22			call macro_dsp_valuehl 
468d				endm 
# End of macro FORTH_DSP_VALUEHL
468d			; get pointer to string in hl 
468d			 
468d 7e			.toup:		ld a, (hl) 
468e fe 00				cp 0 
4690 28 07				jr z, .toupdone 
4692			 
4692 cd 51 12				call to_upper 
4695			 
4695 77					ld (hl), a 
4696 23					inc hl 
4697 18 f4				jr .toup 
4699			 
4699					 
4699			 
4699			 
4699			; for each char convert to upper 
4699					 
4699			.toupdone: 
4699			 
4699			 
4699					NEXTW 
4699 c3 c5 23			jp macro_next 
469c				endm 
# End of macro NEXTW
469c			.LOWER: 
469c				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
469c 48				db WORD_SYS_CORE+52             
469d d7 46			dw .TCASE            
469f 06				db 5 + 1 
46a0 .. 00			db "LOWER",0              
46a6				endm 
# End of macro CWHEAD
46a6			; | LOWER ( s -- s ) Lower case string s  | DONE 
46a6					if DEBUG_FORTH_WORDS_KEY 
46a6						DMARK "LWR" 
46a6 f5				push af  
46a7 3a bb 46			ld a, (.dmark)  
46aa 32 a6 fd			ld (debug_mark),a  
46ad 3a bc 46			ld a, (.dmark+1)  
46b0 32 a7 fd			ld (debug_mark+1),a  
46b3 3a bd 46			ld a, (.dmark+2)  
46b6 32 a8 fd			ld (debug_mark+2),a  
46b9 18 03			jr .pastdmark  
46bb ..			.dmark: db "LWR"  
46be f1			.pastdmark: pop af  
46bf			endm  
# End of macro DMARK
46bf						CALLMONITOR 
46bf cd aa fd			call debug_vector  
46c2				endm  
# End of macro CALLMONITOR
46c2					endif 
46c2			 
46c2					FORTH_DSP 
46c2 cd d5 21			call macro_forth_dsp 
46c5				endm 
# End of macro FORTH_DSP
46c5					 
46c5			; TODO check is string type 
46c5			 
46c5					FORTH_DSP_VALUEHL 
46c5 cd 0f 22			call macro_dsp_valuehl 
46c8				endm 
# End of macro FORTH_DSP_VALUEHL
46c8			; get pointer to string in hl 
46c8			 
46c8 7e			.tolow:		ld a, (hl) 
46c9 fe 00				cp 0 
46cb 28 07				jr z, .tolowdone 
46cd			 
46cd cd 5a 12				call to_lower 
46d0			 
46d0 77					ld (hl), a 
46d1 23					inc hl 
46d2 18 f4				jr .tolow 
46d4			 
46d4					 
46d4			 
46d4			 
46d4			; for each char convert to low 
46d4					 
46d4			.tolowdone: 
46d4					NEXTW 
46d4 c3 c5 23			jp macro_next 
46d7				endm 
# End of macro NEXTW
46d7			.TCASE: 
46d7				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
46d7 48				db WORD_SYS_CORE+52             
46d8 0d 48			dw .SUBSTR            
46da 06				db 5 + 1 
46db .. 00			db "TCASE",0              
46e1				endm 
# End of macro CWHEAD
46e1			; | TCASE ( s -- s ) Title case string s  | DONE 
46e1					if DEBUG_FORTH_WORDS_KEY 
46e1						DMARK "TCS" 
46e1 f5				push af  
46e2 3a f6 46			ld a, (.dmark)  
46e5 32 a6 fd			ld (debug_mark),a  
46e8 3a f7 46			ld a, (.dmark+1)  
46eb 32 a7 fd			ld (debug_mark+1),a  
46ee 3a f8 46			ld a, (.dmark+2)  
46f1 32 a8 fd			ld (debug_mark+2),a  
46f4 18 03			jr .pastdmark  
46f6 ..			.dmark: db "TCS"  
46f9 f1			.pastdmark: pop af  
46fa			endm  
# End of macro DMARK
46fa						CALLMONITOR 
46fa cd aa fd			call debug_vector  
46fd				endm  
# End of macro CALLMONITOR
46fd					endif 
46fd			 
46fd					FORTH_DSP 
46fd cd d5 21			call macro_forth_dsp 
4700				endm 
# End of macro FORTH_DSP
4700					 
4700			; TODO check is string type 
4700			 
4700					FORTH_DSP_VALUEHL 
4700 cd 0f 22			call macro_dsp_valuehl 
4703				endm 
# End of macro FORTH_DSP_VALUEHL
4703			; get pointer to string in hl 
4703			 
4703					if DEBUG_FORTH_WORDS 
4703						DMARK "TC1" 
4703 f5				push af  
4704 3a 18 47			ld a, (.dmark)  
4707 32 a6 fd			ld (debug_mark),a  
470a 3a 19 47			ld a, (.dmark+1)  
470d 32 a7 fd			ld (debug_mark+1),a  
4710 3a 1a 47			ld a, (.dmark+2)  
4713 32 a8 fd			ld (debug_mark+2),a  
4716 18 03			jr .pastdmark  
4718 ..			.dmark: db "TC1"  
471b f1			.pastdmark: pop af  
471c			endm  
# End of macro DMARK
471c						CALLMONITOR 
471c cd aa fd			call debug_vector  
471f				endm  
# End of macro CALLMONITOR
471f					endif 
471f			 
471f					; first time in turn to upper case first char 
471f			 
471f 7e					ld a, (hl) 
4720 c3 aa 47				jp .totsiptou 
4723			 
4723			 
4723 7e			.tot:		ld a, (hl) 
4724 fe 00				cp 0 
4726 ca ee 47				jp z, .totdone 
4729			 
4729					if DEBUG_FORTH_WORDS 
4729						DMARK "TC2" 
4729 f5				push af  
472a 3a 3e 47			ld a, (.dmark)  
472d 32 a6 fd			ld (debug_mark),a  
4730 3a 3f 47			ld a, (.dmark+1)  
4733 32 a7 fd			ld (debug_mark+1),a  
4736 3a 40 47			ld a, (.dmark+2)  
4739 32 a8 fd			ld (debug_mark+2),a  
473c 18 03			jr .pastdmark  
473e ..			.dmark: db "TC2"  
4741 f1			.pastdmark: pop af  
4742			endm  
# End of macro DMARK
4742						CALLMONITOR 
4742 cd aa fd			call debug_vector  
4745				endm  
# End of macro CALLMONITOR
4745					endif 
4745					; check to see if current char is a space 
4745			 
4745 fe 20				cp ' ' 
4747 28 21				jr z, .totsp 
4749 cd 5a 12				call to_lower 
474c					if DEBUG_FORTH_WORDS 
474c						DMARK "TC3" 
474c f5				push af  
474d 3a 61 47			ld a, (.dmark)  
4750 32 a6 fd			ld (debug_mark),a  
4753 3a 62 47			ld a, (.dmark+1)  
4756 32 a7 fd			ld (debug_mark+1),a  
4759 3a 63 47			ld a, (.dmark+2)  
475c 32 a8 fd			ld (debug_mark+2),a  
475f 18 03			jr .pastdmark  
4761 ..			.dmark: db "TC3"  
4764 f1			.pastdmark: pop af  
4765			endm  
# End of macro DMARK
4765						CALLMONITOR 
4765 cd aa fd			call debug_vector  
4768				endm  
# End of macro CALLMONITOR
4768					endif 
4768 18 63				jr .totnxt 
476a			 
476a			.totsp:         ; on a space, find next char which should be upper 
476a			 
476a					if DEBUG_FORTH_WORDS 
476a						DMARK "TC4" 
476a f5				push af  
476b 3a 7f 47			ld a, (.dmark)  
476e 32 a6 fd			ld (debug_mark),a  
4771 3a 80 47			ld a, (.dmark+1)  
4774 32 a7 fd			ld (debug_mark+1),a  
4777 3a 81 47			ld a, (.dmark+2)  
477a 32 a8 fd			ld (debug_mark+2),a  
477d 18 03			jr .pastdmark  
477f ..			.dmark: db "TC4"  
4782 f1			.pastdmark: pop af  
4783			endm  
# End of macro DMARK
4783						CALLMONITOR 
4783 cd aa fd			call debug_vector  
4786				endm  
# End of macro CALLMONITOR
4786					endif 
4786					;; 
4786			 
4786 fe 20				cp ' ' 
4788 20 20				jr nz, .totsiptou 
478a 23					inc hl 
478b 7e					ld a, (hl) 
478c					if DEBUG_FORTH_WORDS 
478c						DMARK "TC5" 
478c f5				push af  
478d 3a a1 47			ld a, (.dmark)  
4790 32 a6 fd			ld (debug_mark),a  
4793 3a a2 47			ld a, (.dmark+1)  
4796 32 a7 fd			ld (debug_mark+1),a  
4799 3a a3 47			ld a, (.dmark+2)  
479c 32 a8 fd			ld (debug_mark+2),a  
479f 18 03			jr .pastdmark  
47a1 ..			.dmark: db "TC5"  
47a4 f1			.pastdmark: pop af  
47a5			endm  
# End of macro DMARK
47a5						CALLMONITOR 
47a5 cd aa fd			call debug_vector  
47a8				endm  
# End of macro CALLMONITOR
47a8					endif 
47a8 18 c0				jr .totsp 
47aa fe 00		.totsiptou:    cp 0 
47ac 28 40				jr z, .totdone 
47ae					; not space and not zero term so upper case it 
47ae cd 51 12				call to_upper 
47b1			 
47b1					if DEBUG_FORTH_WORDS 
47b1						DMARK "TC6" 
47b1 f5				push af  
47b2 3a c6 47			ld a, (.dmark)  
47b5 32 a6 fd			ld (debug_mark),a  
47b8 3a c7 47			ld a, (.dmark+1)  
47bb 32 a7 fd			ld (debug_mark+1),a  
47be 3a c8 47			ld a, (.dmark+2)  
47c1 32 a8 fd			ld (debug_mark+2),a  
47c4 18 03			jr .pastdmark  
47c6 ..			.dmark: db "TC6"  
47c9 f1			.pastdmark: pop af  
47ca			endm  
# End of macro DMARK
47ca						CALLMONITOR 
47ca cd aa fd			call debug_vector  
47cd				endm  
# End of macro CALLMONITOR
47cd					endif 
47cd			 
47cd			 
47cd			.totnxt: 
47cd			 
47cd 77					ld (hl), a 
47ce 23					inc hl 
47cf					if DEBUG_FORTH_WORDS 
47cf						DMARK "TC7" 
47cf f5				push af  
47d0 3a e4 47			ld a, (.dmark)  
47d3 32 a6 fd			ld (debug_mark),a  
47d6 3a e5 47			ld a, (.dmark+1)  
47d9 32 a7 fd			ld (debug_mark+1),a  
47dc 3a e6 47			ld a, (.dmark+2)  
47df 32 a8 fd			ld (debug_mark+2),a  
47e2 18 03			jr .pastdmark  
47e4 ..			.dmark: db "TC7"  
47e7 f1			.pastdmark: pop af  
47e8			endm  
# End of macro DMARK
47e8						CALLMONITOR 
47e8 cd aa fd			call debug_vector  
47eb				endm  
# End of macro CALLMONITOR
47eb					endif 
47eb c3 23 47				jp .tot 
47ee			 
47ee					 
47ee			 
47ee			 
47ee			; for each char convert to low 
47ee					 
47ee			.totdone: 
47ee					if DEBUG_FORTH_WORDS 
47ee						DMARK "TCd" 
47ee f5				push af  
47ef 3a 03 48			ld a, (.dmark)  
47f2 32 a6 fd			ld (debug_mark),a  
47f5 3a 04 48			ld a, (.dmark+1)  
47f8 32 a7 fd			ld (debug_mark+1),a  
47fb 3a 05 48			ld a, (.dmark+2)  
47fe 32 a8 fd			ld (debug_mark+2),a  
4801 18 03			jr .pastdmark  
4803 ..			.dmark: db "TCd"  
4806 f1			.pastdmark: pop af  
4807			endm  
# End of macro DMARK
4807						CALLMONITOR 
4807 cd aa fd			call debug_vector  
480a				endm  
# End of macro CALLMONITOR
480a					endif 
480a					NEXTW 
480a c3 c5 23			jp macro_next 
480d				endm 
# End of macro NEXTW
480d			 
480d			.SUBSTR: 
480d				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
480d 48				db WORD_SYS_CORE+52             
480e 6b 48			dw .LEFT            
4810 07				db 6 + 1 
4811 .. 00			db "SUBSTR",0              
4818				endm 
# End of macro CWHEAD
4818			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4818			 
4818					if DEBUG_FORTH_WORDS_KEY 
4818						DMARK "SST" 
4818 f5				push af  
4819 3a 2d 48			ld a, (.dmark)  
481c 32 a6 fd			ld (debug_mark),a  
481f 3a 2e 48			ld a, (.dmark+1)  
4822 32 a7 fd			ld (debug_mark+1),a  
4825 3a 2f 48			ld a, (.dmark+2)  
4828 32 a8 fd			ld (debug_mark+2),a  
482b 18 03			jr .pastdmark  
482d ..			.dmark: db "SST"  
4830 f1			.pastdmark: pop af  
4831			endm  
# End of macro DMARK
4831						CALLMONITOR 
4831 cd aa fd			call debug_vector  
4834				endm  
# End of macro CALLMONITOR
4834					endif 
4834			; TODO check string type 
4834					FORTH_DSP_VALUEHL 
4834 cd 0f 22			call macro_dsp_valuehl 
4837				endm 
# End of macro FORTH_DSP_VALUEHL
4837			 
4837 e5					push hl      ; string length 
4838			 
4838					FORTH_DSP_POP 
4838 cd c7 22			call macro_forth_dsp_pop 
483b				endm 
# End of macro FORTH_DSP_POP
483b			 
483b					FORTH_DSP_VALUEHL 
483b cd 0f 22			call macro_dsp_valuehl 
483e				endm 
# End of macro FORTH_DSP_VALUEHL
483e			 
483e e5					push hl     ; start char 
483f			 
483f					FORTH_DSP_POP 
483f cd c7 22			call macro_forth_dsp_pop 
4842				endm 
# End of macro FORTH_DSP_POP
4842			 
4842			 
4842					FORTH_DSP_VALUE 
4842 cd f8 21			call macro_forth_dsp_value 
4845				endm 
# End of macro FORTH_DSP_VALUE
4845			 
4845 d1					pop de    ; get start post offset 
4846			 
4846 19					add hl, de    ; starting offset 
4847			 
4847 c1					pop bc 
4848 c5					push bc      ; grab size of string 
4849			 
4849 e5					push hl    ; save string start  
484a			 
484a 26 00				ld h, 0 
484c 69					ld l, c 
484d 23					inc hl 
484e 23					inc hl 
484f			 
484f cd b7 13				call malloc 
4852				if DEBUG_FORTH_MALLOC_GUARD 
4852 cc 98 5d				call z,malloc_error 
4855				endif 
4855			 
4855 eb					ex de, hl      ; save malloc area for string copy 
4856 e1					pop hl    ; get back source 
4857 c1					pop bc    ; get length of string back 
4858			 
4858 d5					push de    ; save malloc area for after we push 
4859 ed b0				ldir     ; copy substr 
485b			 
485b			 
485b eb					ex de, hl 
485c 3e 00				ld a, 0 
485e 77					ld (hl), a   ; term substr 
485f			 
485f					 
485f e1					pop hl    ; get malloc so we can push it 
4860 e5					push hl   ; save so we can free it afterwards 
4861			 
4861 cd 86 20				call forth_push_str 
4864			 
4864 e1					pop hl 
4865 cd 81 14				call free 
4868			 
4868					 
4868					 
4868			 
4868			 
4868					NEXTW 
4868 c3 c5 23			jp macro_next 
486b				endm 
# End of macro NEXTW
486b			 
486b			.LEFT: 
486b				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
486b 48				db WORD_SYS_CORE+52             
486c 93 48			dw .RIGHT            
486e 05				db 4 + 1 
486f .. 00			db "LEFT",0              
4874				endm 
# End of macro CWHEAD
4874			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4874					if DEBUG_FORTH_WORDS_KEY 
4874						DMARK "LEF" 
4874 f5				push af  
4875 3a 89 48			ld a, (.dmark)  
4878 32 a6 fd			ld (debug_mark),a  
487b 3a 8a 48			ld a, (.dmark+1)  
487e 32 a7 fd			ld (debug_mark+1),a  
4881 3a 8b 48			ld a, (.dmark+2)  
4884 32 a8 fd			ld (debug_mark+2),a  
4887 18 03			jr .pastdmark  
4889 ..			.dmark: db "LEF"  
488c f1			.pastdmark: pop af  
488d			endm  
# End of macro DMARK
488d						CALLMONITOR 
488d cd aa fd			call debug_vector  
4890				endm  
# End of macro CALLMONITOR
4890					endif 
4890			 
4890					NEXTW 
4890 c3 c5 23			jp macro_next 
4893				endm 
# End of macro NEXTW
4893			.RIGHT: 
4893				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4893 48				db WORD_SYS_CORE+52             
4894 bc 48			dw .STR2NUM            
4896 06				db 5 + 1 
4897 .. 00			db "RIGHT",0              
489d				endm 
# End of macro CWHEAD
489d			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
489d					if DEBUG_FORTH_WORDS_KEY 
489d						DMARK "RIG" 
489d f5				push af  
489e 3a b2 48			ld a, (.dmark)  
48a1 32 a6 fd			ld (debug_mark),a  
48a4 3a b3 48			ld a, (.dmark+1)  
48a7 32 a7 fd			ld (debug_mark+1),a  
48aa 3a b4 48			ld a, (.dmark+2)  
48ad 32 a8 fd			ld (debug_mark+2),a  
48b0 18 03			jr .pastdmark  
48b2 ..			.dmark: db "RIG"  
48b5 f1			.pastdmark: pop af  
48b6			endm  
# End of macro DMARK
48b6						CALLMONITOR 
48b6 cd aa fd			call debug_vector  
48b9				endm  
# End of macro CALLMONITOR
48b9					endif 
48b9			 
48b9					NEXTW 
48b9 c3 c5 23			jp macro_next 
48bc				endm 
# End of macro NEXTW
48bc			 
48bc			 
48bc			.STR2NUM: 
48bc				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
48bc 48				db WORD_SYS_CORE+52             
48bd 48 49			dw .NUM2STR            
48bf 08				db 7 + 1 
48c0 .. 00			db "STR2NUM",0              
48c8				endm 
# End of macro CWHEAD
48c8			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
48c8			 
48c8			 
48c8			; TODO STR type check to do 
48c8					if DEBUG_FORTH_WORDS_KEY 
48c8						DMARK "S2N" 
48c8 f5				push af  
48c9 3a dd 48			ld a, (.dmark)  
48cc 32 a6 fd			ld (debug_mark),a  
48cf 3a de 48			ld a, (.dmark+1)  
48d2 32 a7 fd			ld (debug_mark+1),a  
48d5 3a df 48			ld a, (.dmark+2)  
48d8 32 a8 fd			ld (debug_mark+2),a  
48db 18 03			jr .pastdmark  
48dd ..			.dmark: db "S2N"  
48e0 f1			.pastdmark: pop af  
48e1			endm  
# End of macro DMARK
48e1						CALLMONITOR 
48e1 cd aa fd			call debug_vector  
48e4				endm  
# End of macro CALLMONITOR
48e4					endif 
48e4			 
48e4					;FORTH_DSP 
48e4					FORTH_DSP_VALUE 
48e4 cd f8 21			call macro_forth_dsp_value 
48e7				endm 
# End of macro FORTH_DSP_VALUE
48e7					;inc hl 
48e7			 
48e7 eb					ex de, hl 
48e8					if DEBUG_FORTH_WORDS 
48e8						DMARK "S2a" 
48e8 f5				push af  
48e9 3a fd 48			ld a, (.dmark)  
48ec 32 a6 fd			ld (debug_mark),a  
48ef 3a fe 48			ld a, (.dmark+1)  
48f2 32 a7 fd			ld (debug_mark+1),a  
48f5 3a ff 48			ld a, (.dmark+2)  
48f8 32 a8 fd			ld (debug_mark+2),a  
48fb 18 03			jr .pastdmark  
48fd ..			.dmark: db "S2a"  
4900 f1			.pastdmark: pop af  
4901			endm  
# End of macro DMARK
4901						CALLMONITOR 
4901 cd aa fd			call debug_vector  
4904				endm  
# End of macro CALLMONITOR
4904					endif 
4904 cd d9 12				call string_to_uint16 
4907			 
4907					if DEBUG_FORTH_WORDS 
4907						DMARK "S2b" 
4907 f5				push af  
4908 3a 1c 49			ld a, (.dmark)  
490b 32 a6 fd			ld (debug_mark),a  
490e 3a 1d 49			ld a, (.dmark+1)  
4911 32 a7 fd			ld (debug_mark+1),a  
4914 3a 1e 49			ld a, (.dmark+2)  
4917 32 a8 fd			ld (debug_mark+2),a  
491a 18 03			jr .pastdmark  
491c ..			.dmark: db "S2b"  
491f f1			.pastdmark: pop af  
4920			endm  
# End of macro DMARK
4920						CALLMONITOR 
4920 cd aa fd			call debug_vector  
4923				endm  
# End of macro CALLMONITOR
4923					endif 
4923			;		push hl 
4923					FORTH_DSP_POP 
4923 cd c7 22			call macro_forth_dsp_pop 
4926				endm 
# End of macro FORTH_DSP_POP
4926			;		pop hl 
4926					 
4926					if DEBUG_FORTH_WORDS 
4926						DMARK "S2b" 
4926 f5				push af  
4927 3a 3b 49			ld a, (.dmark)  
492a 32 a6 fd			ld (debug_mark),a  
492d 3a 3c 49			ld a, (.dmark+1)  
4930 32 a7 fd			ld (debug_mark+1),a  
4933 3a 3d 49			ld a, (.dmark+2)  
4936 32 a8 fd			ld (debug_mark+2),a  
4939 18 03			jr .pastdmark  
493b ..			.dmark: db "S2b"  
493e f1			.pastdmark: pop af  
493f			endm  
# End of macro DMARK
493f						CALLMONITOR 
493f cd aa fd			call debug_vector  
4942				endm  
# End of macro CALLMONITOR
4942					endif 
4942 cd 18 20				call forth_push_numhl	 
4945			 
4945				 
4945				       NEXTW 
4945 c3 c5 23			jp macro_next 
4948				endm 
# End of macro NEXTW
4948			.NUM2STR: 
4948				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4948 48				db WORD_SYS_CORE+52             
4949 57 49			dw .CONCAT            
494b 08				db 7 + 1 
494c .. 00			db "NUM2STR",0              
4954				endm 
# End of macro CWHEAD
4954			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
4954			 
4954			;		; malloc a string to target 
4954			;		ld hl, 10     ; TODO max string size should be fine 
4954			;		call malloc 
4954			;		push hl    ; save malloc location 
4954			; 
4954			; 
4954			;; TODO check int type 
4954			;		FORTH_DSP_VALUEHL 
4954			;		ld a, l 
4954			;		call DispAToASCII   
4954			;;TODO need to chage above call to dump into string 
4954			; 
4954			; 
4954			 
4954				       NEXTW 
4954 c3 c5 23			jp macro_next 
4957				endm 
# End of macro NEXTW
4957			 
4957			.CONCAT: 
4957				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4957 48				db WORD_SYS_CORE+52             
4958 0a 4a			dw .FIND            
495a 07				db 6 + 1 
495b .. 00			db "CONCAT",0              
4962				endm 
# End of macro CWHEAD
4962			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4962			 
4962			; TODO check string type 
4962			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4962			 
4962					if DEBUG_FORTH_WORDS_KEY 
4962						DMARK "CON" 
4962 f5				push af  
4963 3a 77 49			ld a, (.dmark)  
4966 32 a6 fd			ld (debug_mark),a  
4969 3a 78 49			ld a, (.dmark+1)  
496c 32 a7 fd			ld (debug_mark+1),a  
496f 3a 79 49			ld a, (.dmark+2)  
4972 32 a8 fd			ld (debug_mark+2),a  
4975 18 03			jr .pastdmark  
4977 ..			.dmark: db "CON"  
497a f1			.pastdmark: pop af  
497b			endm  
# End of macro DMARK
497b						CALLMONITOR 
497b cd aa fd			call debug_vector  
497e				endm  
# End of macro CALLMONITOR
497e					endif 
497e			 
497e			 
497e					FORTH_DSP_VALUE 
497e cd f8 21			call macro_forth_dsp_value 
4981				endm 
# End of macro FORTH_DSP_VALUE
4981 e5					push hl   ; s2 
4982			 
4982					FORTH_DSP_POP 
4982 cd c7 22			call macro_forth_dsp_pop 
4985				endm 
# End of macro FORTH_DSP_POP
4985			 
4985					FORTH_DSP_VALUE 
4985 cd f8 21			call macro_forth_dsp_value 
4988				endm 
# End of macro FORTH_DSP_VALUE
4988			 
4988 e5					push hl   ; s1 
4989			 
4989					FORTH_DSP_POP 
4989 cd c7 22			call macro_forth_dsp_pop 
498c				endm 
# End of macro FORTH_DSP_POP
498c					 
498c			 
498c					; copy s1 
498c			 
498c				 
498c					; save ptr 
498c e1					pop hl  
498d e5					push hl 
498e 3e 00				ld a, 0 
4990 cd 4d 13				call strlent 
4993					;inc hl    ; zer0 
4993 06 00				ld b, 0 
4995 4d					ld c, l 
4996 e1					pop hl		 
4997 11 fc f0				ld de, scratch	 
499a					if DEBUG_FORTH_WORDS 
499a						DMARK "CO1" 
499a f5				push af  
499b 3a af 49			ld a, (.dmark)  
499e 32 a6 fd			ld (debug_mark),a  
49a1 3a b0 49			ld a, (.dmark+1)  
49a4 32 a7 fd			ld (debug_mark+1),a  
49a7 3a b1 49			ld a, (.dmark+2)  
49aa 32 a8 fd			ld (debug_mark+2),a  
49ad 18 03			jr .pastdmark  
49af ..			.dmark: db "CO1"  
49b2 f1			.pastdmark: pop af  
49b3			endm  
# End of macro DMARK
49b3						CALLMONITOR 
49b3 cd aa fd			call debug_vector  
49b6				endm  
# End of macro CALLMONITOR
49b6					endif 
49b6 ed b0				ldir 
49b8			 
49b8 e1					pop hl 
49b9 e5					push hl 
49ba d5					push de 
49bb			 
49bb			 
49bb 3e 00				ld a, 0 
49bd cd 4d 13				call strlent 
49c0 23					inc hl    ; zer0 
49c1 23					inc hl 
49c2 06 00				ld b, 0 
49c4 4d					ld c, l 
49c5 d1					pop de 
49c6 e1					pop hl		 
49c7					if DEBUG_FORTH_WORDS 
49c7						DMARK "CO2" 
49c7 f5				push af  
49c8 3a dc 49			ld a, (.dmark)  
49cb 32 a6 fd			ld (debug_mark),a  
49ce 3a dd 49			ld a, (.dmark+1)  
49d1 32 a7 fd			ld (debug_mark+1),a  
49d4 3a de 49			ld a, (.dmark+2)  
49d7 32 a8 fd			ld (debug_mark+2),a  
49da 18 03			jr .pastdmark  
49dc ..			.dmark: db "CO2"  
49df f1			.pastdmark: pop af  
49e0			endm  
# End of macro DMARK
49e0						CALLMONITOR 
49e0 cd aa fd			call debug_vector  
49e3				endm  
# End of macro CALLMONITOR
49e3					endif 
49e3 ed b0				ldir 
49e5			 
49e5			 
49e5			 
49e5 21 fc f0				ld hl, scratch 
49e8					if DEBUG_FORTH_WORDS 
49e8						DMARK "CO5" 
49e8 f5				push af  
49e9 3a fd 49			ld a, (.dmark)  
49ec 32 a6 fd			ld (debug_mark),a  
49ef 3a fe 49			ld a, (.dmark+1)  
49f2 32 a7 fd			ld (debug_mark+1),a  
49f5 3a ff 49			ld a, (.dmark+2)  
49f8 32 a8 fd			ld (debug_mark+2),a  
49fb 18 03			jr .pastdmark  
49fd ..			.dmark: db "CO5"  
4a00 f1			.pastdmark: pop af  
4a01			endm  
# End of macro DMARK
4a01						CALLMONITOR 
4a01 cd aa fd			call debug_vector  
4a04				endm  
# End of macro CALLMONITOR
4a04					endif 
4a04			 
4a04 cd 86 20				call forth_push_str 
4a07			 
4a07			 
4a07			 
4a07			 
4a07				       NEXTW 
4a07 c3 c5 23			jp macro_next 
4a0a				endm 
# End of macro NEXTW
4a0a			 
4a0a			 
4a0a			.FIND: 
4a0a				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4a0a 4b				db WORD_SYS_CORE+55             
4a0b c8 4a			dw .LEN            
4a0d 05				db 4 + 1 
4a0e .. 00			db "FIND",0              
4a13				endm 
# End of macro CWHEAD
4a13			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4a13			 
4a13					if DEBUG_FORTH_WORDS_KEY 
4a13						DMARK "FND" 
4a13 f5				push af  
4a14 3a 28 4a			ld a, (.dmark)  
4a17 32 a6 fd			ld (debug_mark),a  
4a1a 3a 29 4a			ld a, (.dmark+1)  
4a1d 32 a7 fd			ld (debug_mark+1),a  
4a20 3a 2a 4a			ld a, (.dmark+2)  
4a23 32 a8 fd			ld (debug_mark+2),a  
4a26 18 03			jr .pastdmark  
4a28 ..			.dmark: db "FND"  
4a2b f1			.pastdmark: pop af  
4a2c			endm  
# End of macro DMARK
4a2c						CALLMONITOR 
4a2c cd aa fd			call debug_vector  
4a2f				endm  
# End of macro CALLMONITOR
4a2f					endif 
4a2f			 
4a2f			; TODO check string type 
4a2f					FORTH_DSP_VALUE 
4a2f cd f8 21			call macro_forth_dsp_value 
4a32				endm 
# End of macro FORTH_DSP_VALUE
4a32			 
4a32 e5					push hl    
4a33 7e					ld a,(hl)    ; char to find   
4a34			; TODO change char to substr 
4a34			 
4a34 f5					push af 
4a35					 
4a35			 
4a35			 
4a35					if DEBUG_FORTH_WORDS 
4a35						DMARK "FN1" 
4a35 f5				push af  
4a36 3a 4a 4a			ld a, (.dmark)  
4a39 32 a6 fd			ld (debug_mark),a  
4a3c 3a 4b 4a			ld a, (.dmark+1)  
4a3f 32 a7 fd			ld (debug_mark+1),a  
4a42 3a 4c 4a			ld a, (.dmark+2)  
4a45 32 a8 fd			ld (debug_mark+2),a  
4a48 18 03			jr .pastdmark  
4a4a ..			.dmark: db "FN1"  
4a4d f1			.pastdmark: pop af  
4a4e			endm  
# End of macro DMARK
4a4e						CALLMONITOR 
4a4e cd aa fd			call debug_vector  
4a51				endm  
# End of macro CALLMONITOR
4a51					endif 
4a51			 
4a51					FORTH_DSP_POP 
4a51 cd c7 22			call macro_forth_dsp_pop 
4a54				endm 
# End of macro FORTH_DSP_POP
4a54			 
4a54					; string to search 
4a54			 
4a54					FORTH_DSP_VALUE 
4a54 cd f8 21			call macro_forth_dsp_value 
4a57				endm 
# End of macro FORTH_DSP_VALUE
4a57			 
4a57 d1					pop de  ; d is char to find  
4a58			 
4a58					if DEBUG_FORTH_WORDS 
4a58						DMARK "FN2" 
4a58 f5				push af  
4a59 3a 6d 4a			ld a, (.dmark)  
4a5c 32 a6 fd			ld (debug_mark),a  
4a5f 3a 6e 4a			ld a, (.dmark+1)  
4a62 32 a7 fd			ld (debug_mark+1),a  
4a65 3a 6f 4a			ld a, (.dmark+2)  
4a68 32 a8 fd			ld (debug_mark+2),a  
4a6b 18 03			jr .pastdmark  
4a6d ..			.dmark: db "FN2"  
4a70 f1			.pastdmark: pop af  
4a71			endm  
# End of macro DMARK
4a71						CALLMONITOR 
4a71 cd aa fd			call debug_vector  
4a74				endm  
# End of macro CALLMONITOR
4a74					endif 
4a74					 
4a74 01 00 00				ld bc, 0 
4a77 7e			.findchar:      ld a,(hl) 
4a78 fe 00				cp 0   		 
4a7a 28 27				jr z, .finddone     
4a7c ba					cp d 
4a7d 28 20				jr z, .foundchar 
4a7f 03					inc bc 
4a80 23					inc hl 
4a81					if DEBUG_FORTH_WORDS 
4a81						DMARK "FN3" 
4a81 f5				push af  
4a82 3a 96 4a			ld a, (.dmark)  
4a85 32 a6 fd			ld (debug_mark),a  
4a88 3a 97 4a			ld a, (.dmark+1)  
4a8b 32 a7 fd			ld (debug_mark+1),a  
4a8e 3a 98 4a			ld a, (.dmark+2)  
4a91 32 a8 fd			ld (debug_mark+2),a  
4a94 18 03			jr .pastdmark  
4a96 ..			.dmark: db "FN3"  
4a99 f1			.pastdmark: pop af  
4a9a			endm  
# End of macro DMARK
4a9a						CALLMONITOR 
4a9a cd aa fd			call debug_vector  
4a9d				endm  
# End of macro CALLMONITOR
4a9d					endif 
4a9d 18 d8				jr .findchar 
4a9f			 
4a9f			 
4a9f c5			.foundchar:	push bc 
4aa0 e1					pop hl 
4aa1 18 03				jr .findexit 
4aa3			 
4aa3			 
4aa3							 
4aa3			 
4aa3			.finddone:     ; got to end of string with no find 
4aa3 21 00 00				ld hl, 0 
4aa6			.findexit: 
4aa6			 
4aa6					if DEBUG_FORTH_WORDS 
4aa6						DMARK "FNd" 
4aa6 f5				push af  
4aa7 3a bb 4a			ld a, (.dmark)  
4aaa 32 a6 fd			ld (debug_mark),a  
4aad 3a bc 4a			ld a, (.dmark+1)  
4ab0 32 a7 fd			ld (debug_mark+1),a  
4ab3 3a bd 4a			ld a, (.dmark+2)  
4ab6 32 a8 fd			ld (debug_mark+2),a  
4ab9 18 03			jr .pastdmark  
4abb ..			.dmark: db "FNd"  
4abe f1			.pastdmark: pop af  
4abf			endm  
# End of macro DMARK
4abf						CALLMONITOR 
4abf cd aa fd			call debug_vector  
4ac2				endm  
# End of macro CALLMONITOR
4ac2					endif 
4ac2 cd 18 20			call forth_push_numhl 
4ac5			 
4ac5				       NEXTW 
4ac5 c3 c5 23			jp macro_next 
4ac8				endm 
# End of macro NEXTW
4ac8			 
4ac8			.LEN: 
4ac8				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4ac8 4c				db WORD_SYS_CORE+56             
4ac9 32 4b			dw .ASC            
4acb 06				db 5 + 1 
4acc .. 00			db "COUNT",0              
4ad2				endm 
# End of macro CWHEAD
4ad2			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4ad2			 
4ad2					if DEBUG_FORTH_WORDS_KEY 
4ad2						DMARK "CNT" 
4ad2 f5				push af  
4ad3 3a e7 4a			ld a, (.dmark)  
4ad6 32 a6 fd			ld (debug_mark),a  
4ad9 3a e8 4a			ld a, (.dmark+1)  
4adc 32 a7 fd			ld (debug_mark+1),a  
4adf 3a e9 4a			ld a, (.dmark+2)  
4ae2 32 a8 fd			ld (debug_mark+2),a  
4ae5 18 03			jr .pastdmark  
4ae7 ..			.dmark: db "CNT"  
4aea f1			.pastdmark: pop af  
4aeb			endm  
# End of macro DMARK
4aeb						CALLMONITOR 
4aeb cd aa fd			call debug_vector  
4aee				endm  
# End of macro CALLMONITOR
4aee					endif 
4aee			; TODO check string type 
4aee					FORTH_DSP_VALUE 
4aee cd f8 21			call macro_forth_dsp_value 
4af1				endm 
# End of macro FORTH_DSP_VALUE
4af1			 
4af1			 
4af1					if DEBUG_FORTH_WORDS 
4af1						DMARK "CN?" 
4af1 f5				push af  
4af2 3a 06 4b			ld a, (.dmark)  
4af5 32 a6 fd			ld (debug_mark),a  
4af8 3a 07 4b			ld a, (.dmark+1)  
4afb 32 a7 fd			ld (debug_mark+1),a  
4afe 3a 08 4b			ld a, (.dmark+2)  
4b01 32 a8 fd			ld (debug_mark+2),a  
4b04 18 03			jr .pastdmark  
4b06 ..			.dmark: db "CN?"  
4b09 f1			.pastdmark: pop af  
4b0a			endm  
# End of macro DMARK
4b0a						CALLMONITOR 
4b0a cd aa fd			call debug_vector  
4b0d				endm  
# End of macro CALLMONITOR
4b0d					endif 
4b0d cd 42 13				call strlenz 
4b10					if DEBUG_FORTH_WORDS 
4b10						DMARK "CNl" 
4b10 f5				push af  
4b11 3a 25 4b			ld a, (.dmark)  
4b14 32 a6 fd			ld (debug_mark),a  
4b17 3a 26 4b			ld a, (.dmark+1)  
4b1a 32 a7 fd			ld (debug_mark+1),a  
4b1d 3a 27 4b			ld a, (.dmark+2)  
4b20 32 a8 fd			ld (debug_mark+2),a  
4b23 18 03			jr .pastdmark  
4b25 ..			.dmark: db "CNl"  
4b28 f1			.pastdmark: pop af  
4b29			endm  
# End of macro DMARK
4b29						CALLMONITOR 
4b29 cd aa fd			call debug_vector  
4b2c				endm  
# End of macro CALLMONITOR
4b2c					endif 
4b2c			 
4b2c cd 18 20				call forth_push_numhl 
4b2f			 
4b2f			 
4b2f			 
4b2f				       NEXTW 
4b2f c3 c5 23			jp macro_next 
4b32				endm 
# End of macro NEXTW
4b32			.ASC: 
4b32				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4b32 4d				db WORD_SYS_CORE+57             
4b33 a0 4b			dw .CHR            
4b35 04				db 3 + 1 
4b36 .. 00			db "ASC",0              
4b3a				endm 
# End of macro CWHEAD
4b3a			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4b3a					if DEBUG_FORTH_WORDS_KEY 
4b3a						DMARK "ASC" 
4b3a f5				push af  
4b3b 3a 4f 4b			ld a, (.dmark)  
4b3e 32 a6 fd			ld (debug_mark),a  
4b41 3a 50 4b			ld a, (.dmark+1)  
4b44 32 a7 fd			ld (debug_mark+1),a  
4b47 3a 51 4b			ld a, (.dmark+2)  
4b4a 32 a8 fd			ld (debug_mark+2),a  
4b4d 18 03			jr .pastdmark  
4b4f ..			.dmark: db "ASC"  
4b52 f1			.pastdmark: pop af  
4b53			endm  
# End of macro DMARK
4b53						CALLMONITOR 
4b53 cd aa fd			call debug_vector  
4b56				endm  
# End of macro CALLMONITOR
4b56					endif 
4b56					FORTH_DSP_VALUE 
4b56 cd f8 21			call macro_forth_dsp_value 
4b59				endm 
# End of macro FORTH_DSP_VALUE
4b59					;v5 FORTH_DSP_VALUE 
4b59			;		inc hl      ; now at start of numeric as string 
4b59			 
4b59 e5					push hl 
4b5a			 
4b5a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b5a cd c7 22			call macro_forth_dsp_pop 
4b5d				endm 
# End of macro FORTH_DSP_POP
4b5d			 
4b5d e1					pop hl 
4b5e			 
4b5e					if DEBUG_FORTH_WORDS 
4b5e						DMARK "AS1" 
4b5e f5				push af  
4b5f 3a 73 4b			ld a, (.dmark)  
4b62 32 a6 fd			ld (debug_mark),a  
4b65 3a 74 4b			ld a, (.dmark+1)  
4b68 32 a7 fd			ld (debug_mark+1),a  
4b6b 3a 75 4b			ld a, (.dmark+2)  
4b6e 32 a8 fd			ld (debug_mark+2),a  
4b71 18 03			jr .pastdmark  
4b73 ..			.dmark: db "AS1"  
4b76 f1			.pastdmark: pop af  
4b77			endm  
# End of macro DMARK
4b77						CALLMONITOR 
4b77 cd aa fd			call debug_vector  
4b7a				endm  
# End of macro CALLMONITOR
4b7a					endif 
4b7a					; push the content of a onto the stack as a value 
4b7a			 
4b7a 7e					ld a,(hl)   ; get char 
4b7b 26 00				ld h,0 
4b7d 6f					ld l,a 
4b7e					if DEBUG_FORTH_WORDS 
4b7e						DMARK "AS2" 
4b7e f5				push af  
4b7f 3a 93 4b			ld a, (.dmark)  
4b82 32 a6 fd			ld (debug_mark),a  
4b85 3a 94 4b			ld a, (.dmark+1)  
4b88 32 a7 fd			ld (debug_mark+1),a  
4b8b 3a 95 4b			ld a, (.dmark+2)  
4b8e 32 a8 fd			ld (debug_mark+2),a  
4b91 18 03			jr .pastdmark  
4b93 ..			.dmark: db "AS2"  
4b96 f1			.pastdmark: pop af  
4b97			endm  
# End of macro DMARK
4b97						CALLMONITOR 
4b97 cd aa fd			call debug_vector  
4b9a				endm  
# End of macro CALLMONITOR
4b9a					endif 
4b9a cd 18 20				call forth_push_numhl 
4b9d			 
4b9d				       NEXTW 
4b9d c3 c5 23			jp macro_next 
4ba0				endm 
# End of macro NEXTW
4ba0			 
4ba0			.CHR: 
4ba0				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4ba0 4d				db WORD_SYS_CORE+57             
4ba1 dc 4b			dw .ENDSTR            
4ba3 04				db 3 + 1 
4ba4 .. 00			db "CHR",0              
4ba8				endm 
# End of macro CWHEAD
4ba8			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4ba8					if DEBUG_FORTH_WORDS_KEY 
4ba8						DMARK "CHR" 
4ba8 f5				push af  
4ba9 3a bd 4b			ld a, (.dmark)  
4bac 32 a6 fd			ld (debug_mark),a  
4baf 3a be 4b			ld a, (.dmark+1)  
4bb2 32 a7 fd			ld (debug_mark+1),a  
4bb5 3a bf 4b			ld a, (.dmark+2)  
4bb8 32 a8 fd			ld (debug_mark+2),a  
4bbb 18 03			jr .pastdmark  
4bbd ..			.dmark: db "CHR"  
4bc0 f1			.pastdmark: pop af  
4bc1			endm  
# End of macro DMARK
4bc1						CALLMONITOR 
4bc1 cd aa fd			call debug_vector  
4bc4				endm  
# End of macro CALLMONITOR
4bc4					endif 
4bc4					FORTH_DSP_VALUEHL 
4bc4 cd 0f 22			call macro_dsp_valuehl 
4bc7				endm 
# End of macro FORTH_DSP_VALUEHL
4bc7			 
4bc7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bc7 cd c7 22			call macro_forth_dsp_pop 
4bca				endm 
# End of macro FORTH_DSP_POP
4bca			 
4bca					; save asci byte as a zero term string and push string 
4bca			 
4bca 7d					ld a,l 
4bcb 32 fc f0				ld (scratch), a 
4bce			 
4bce 3e 00				ld a, 0 
4bd0 32 fd f0				ld (scratch+1), a 
4bd3			 
4bd3 21 fc f0				ld hl, scratch 
4bd6 cd 86 20				call forth_push_str 
4bd9			 
4bd9			 
4bd9				       NEXTW 
4bd9 c3 c5 23			jp macro_next 
4bdc				endm 
# End of macro NEXTW
4bdc			 
4bdc			 
4bdc			 
4bdc			 
4bdc			.ENDSTR: 
4bdc			; eof 
4bdc			 
# End of file forth_words_str.asm
4bdc			include "forth_words_key.asm" 
4bdc			 
4bdc			; | ## Keyboard Words 
4bdc			 
4bdc			.KEY: 
4bdc				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4bdc 3e				db WORD_SYS_CORE+42             
4bdd 0c 4c			dw .WAITK            
4bdf 04				db 3 + 1 
4be0 .. 00			db "KEY",0              
4be4				endm 
# End of macro CWHEAD
4be4			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
4be4			 
4be4					if DEBUG_FORTH_WORDS_KEY 
4be4						DMARK "KEY" 
4be4 f5				push af  
4be5 3a f9 4b			ld a, (.dmark)  
4be8 32 a6 fd			ld (debug_mark),a  
4beb 3a fa 4b			ld a, (.dmark+1)  
4bee 32 a7 fd			ld (debug_mark+1),a  
4bf1 3a fb 4b			ld a, (.dmark+2)  
4bf4 32 a8 fd			ld (debug_mark+2),a  
4bf7 18 03			jr .pastdmark  
4bf9 ..			.dmark: db "KEY"  
4bfc f1			.pastdmark: pop af  
4bfd			endm  
# End of macro DMARK
4bfd						CALLMONITOR 
4bfd cd aa fd			call debug_vector  
4c00				endm  
# End of macro CALLMONITOR
4c00					endif 
4c00			; TODO currently waits 
4c00 cd 92 79				call cin 
4c03					;call cin_wait 
4c03 6f					ld l, a 
4c04 26 00				ld h, 0 
4c06 cd 18 20				call forth_push_numhl 
4c09					NEXTW 
4c09 c3 c5 23			jp macro_next 
4c0c				endm 
# End of macro NEXTW
4c0c			.WAITK: 
4c0c				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4c0c 3f				db WORD_SYS_CORE+43             
4c0d 3e 4c			dw .ACCEPT            
4c0f 06				db 5 + 1 
4c10 .. 00			db "WAITK",0              
4c16				endm 
# End of macro CWHEAD
4c16			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4c16					if DEBUG_FORTH_WORDS_KEY 
4c16						DMARK "WAI" 
4c16 f5				push af  
4c17 3a 2b 4c			ld a, (.dmark)  
4c1a 32 a6 fd			ld (debug_mark),a  
4c1d 3a 2c 4c			ld a, (.dmark+1)  
4c20 32 a7 fd			ld (debug_mark+1),a  
4c23 3a 2d 4c			ld a, (.dmark+2)  
4c26 32 a8 fd			ld (debug_mark+2),a  
4c29 18 03			jr .pastdmark  
4c2b ..			.dmark: db "WAI"  
4c2e f1			.pastdmark: pop af  
4c2f			endm  
# End of macro DMARK
4c2f						CALLMONITOR 
4c2f cd aa fd			call debug_vector  
4c32				endm  
# End of macro CALLMONITOR
4c32					endif 
4c32 cd 81 79				call cin_wait 
4c35 6f					ld l, a 
4c36 26 00				ld h, 0 
4c38 cd 18 20				call forth_push_numhl 
4c3b					NEXTW 
4c3b c3 c5 23			jp macro_next 
4c3e				endm 
# End of macro NEXTW
4c3e			.ACCEPT: 
4c3e				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4c3e 40				db WORD_SYS_CORE+44             
4c3f 9c 4c			dw .EDIT            
4c41 07				db 6 + 1 
4c42 .. 00			db "ACCEPT",0              
4c49				endm 
# End of macro CWHEAD
4c49			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4c49					; TODO crashes on push 
4c49					if DEBUG_FORTH_WORDS_KEY 
4c49						DMARK "ACC" 
4c49 f5				push af  
4c4a 3a 5e 4c			ld a, (.dmark)  
4c4d 32 a6 fd			ld (debug_mark),a  
4c50 3a 5f 4c			ld a, (.dmark+1)  
4c53 32 a7 fd			ld (debug_mark+1),a  
4c56 3a 60 4c			ld a, (.dmark+2)  
4c59 32 a8 fd			ld (debug_mark+2),a  
4c5c 18 03			jr .pastdmark  
4c5e ..			.dmark: db "ACC"  
4c61 f1			.pastdmark: pop af  
4c62			endm  
# End of macro DMARK
4c62						CALLMONITOR 
4c62 cd aa fd			call debug_vector  
4c65				endm  
# End of macro CALLMONITOR
4c65					endif 
4c65 21 fa f2				ld hl, os_input 
4c68 3e 00				ld a, 0 
4c6a 77					ld (hl),a 
4c6b 3a 99 f9				ld a,(f_cursor_ptr) 
4c6e 16 64				ld d, 100 
4c70 0e 00				ld c, 0 
4c72 1e 28				ld e, 40 
4c74 cd fc 0f				call input_str 
4c77					; TODO perhaps do a type check and wrap in quotes if not a number 
4c77 21 fa f2				ld hl, os_input 
4c7a					if DEBUG_FORTH_WORDS 
4c7a						DMARK "AC1" 
4c7a f5				push af  
4c7b 3a 8f 4c			ld a, (.dmark)  
4c7e 32 a6 fd			ld (debug_mark),a  
4c81 3a 90 4c			ld a, (.dmark+1)  
4c84 32 a7 fd			ld (debug_mark+1),a  
4c87 3a 91 4c			ld a, (.dmark+2)  
4c8a 32 a8 fd			ld (debug_mark+2),a  
4c8d 18 03			jr .pastdmark  
4c8f ..			.dmark: db "AC1"  
4c92 f1			.pastdmark: pop af  
4c93			endm  
# End of macro DMARK
4c93						CALLMONITOR 
4c93 cd aa fd			call debug_vector  
4c96				endm  
# End of macro CALLMONITOR
4c96					endif 
4c96 cd 86 20				call forth_push_str 
4c99					NEXTW 
4c99 c3 c5 23			jp macro_next 
4c9c				endm 
# End of macro NEXTW
4c9c			 
4c9c			.EDIT: 
4c9c				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4c9c 40				db WORD_SYS_CORE+44             
4c9d 3e 4d			dw .DEDIT            
4c9f 05				db 4 + 1 
4ca0 .. 00			db "EDIT",0              
4ca5				endm 
# End of macro CWHEAD
4ca5			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4ca5			 
4ca5					; TODO does not copy from stack 
4ca5					if DEBUG_FORTH_WORDS_KEY 
4ca5						DMARK "EDT" 
4ca5 f5				push af  
4ca6 3a ba 4c			ld a, (.dmark)  
4ca9 32 a6 fd			ld (debug_mark),a  
4cac 3a bb 4c			ld a, (.dmark+1)  
4caf 32 a7 fd			ld (debug_mark+1),a  
4cb2 3a bc 4c			ld a, (.dmark+2)  
4cb5 32 a8 fd			ld (debug_mark+2),a  
4cb8 18 03			jr .pastdmark  
4cba ..			.dmark: db "EDT"  
4cbd f1			.pastdmark: pop af  
4cbe			endm  
# End of macro DMARK
4cbe						CALLMONITOR 
4cbe cd aa fd			call debug_vector  
4cc1				endm  
# End of macro CALLMONITOR
4cc1					endif 
4cc1			 
4cc1					;FORTH_DSP 
4cc1					FORTH_DSP_VALUEHL 
4cc1 cd 0f 22			call macro_dsp_valuehl 
4cc4				endm 
# End of macro FORTH_DSP_VALUEHL
4cc4			;		inc hl    ; TODO do type check 
4cc4			 
4cc4			;		call get_word_hl 
4cc4 e5					push hl 
4cc5					if DEBUG_FORTH_WORDS 
4cc5						DMARK "EDp" 
4cc5 f5				push af  
4cc6 3a da 4c			ld a, (.dmark)  
4cc9 32 a6 fd			ld (debug_mark),a  
4ccc 3a db 4c			ld a, (.dmark+1)  
4ccf 32 a7 fd			ld (debug_mark+1),a  
4cd2 3a dc 4c			ld a, (.dmark+2)  
4cd5 32 a8 fd			ld (debug_mark+2),a  
4cd8 18 03			jr .pastdmark  
4cda ..			.dmark: db "EDp"  
4cdd f1			.pastdmark: pop af  
4cde			endm  
# End of macro DMARK
4cde						CALLMONITOR 
4cde cd aa fd			call debug_vector  
4ce1				endm  
# End of macro CALLMONITOR
4ce1					endif 
4ce1				;	ld a, 0 
4ce1 cd 42 13				call strlenz 
4ce4 23					inc hl 
4ce5			 
4ce5 06 00				ld b, 0 
4ce7 4d					ld c, l 
4ce8			 
4ce8 e1					pop hl 
4ce9 11 fa f2				ld de, os_input 
4cec					if DEBUG_FORTH_WORDS_KEY 
4cec						DMARK "EDc" 
4cec f5				push af  
4ced 3a 01 4d			ld a, (.dmark)  
4cf0 32 a6 fd			ld (debug_mark),a  
4cf3 3a 02 4d			ld a, (.dmark+1)  
4cf6 32 a7 fd			ld (debug_mark+1),a  
4cf9 3a 03 4d			ld a, (.dmark+2)  
4cfc 32 a8 fd			ld (debug_mark+2),a  
4cff 18 03			jr .pastdmark  
4d01 ..			.dmark: db "EDc"  
4d04 f1			.pastdmark: pop af  
4d05			endm  
# End of macro DMARK
4d05						CALLMONITOR 
4d05 cd aa fd			call debug_vector  
4d08				endm  
# End of macro CALLMONITOR
4d08					endif 
4d08 ed b0				ldir 
4d0a			 
4d0a			 
4d0a 21 fa f2				ld hl, os_input 
4d0d					;ld a, 0 
4d0d					;ld (hl),a 
4d0d 3a 99 f9				ld a,(f_cursor_ptr) 
4d10 16 64				ld d, 100 
4d12 0e 00				ld c, 0 
4d14 1e 28				ld e, 40 
4d16 cd fc 0f				call input_str 
4d19					; TODO perhaps do a type check and wrap in quotes if not a number 
4d19 21 fa f2				ld hl, os_input 
4d1c					if DEBUG_FORTH_WORDS 
4d1c						DMARK "ED1" 
4d1c f5				push af  
4d1d 3a 31 4d			ld a, (.dmark)  
4d20 32 a6 fd			ld (debug_mark),a  
4d23 3a 32 4d			ld a, (.dmark+1)  
4d26 32 a7 fd			ld (debug_mark+1),a  
4d29 3a 33 4d			ld a, (.dmark+2)  
4d2c 32 a8 fd			ld (debug_mark+2),a  
4d2f 18 03			jr .pastdmark  
4d31 ..			.dmark: db "ED1"  
4d34 f1			.pastdmark: pop af  
4d35			endm  
# End of macro DMARK
4d35						CALLMONITOR 
4d35 cd aa fd			call debug_vector  
4d38				endm  
# End of macro CALLMONITOR
4d38					endif 
4d38 cd 86 20				call forth_push_str 
4d3b					NEXTW 
4d3b c3 c5 23			jp macro_next 
4d3e				endm 
# End of macro NEXTW
4d3e			 
4d3e			.DEDIT: 
4d3e				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4d3e 40				db WORD_SYS_CORE+44             
4d3f a0 4d			dw .ENDKEY            
4d41 06				db 5 + 1 
4d42 .. 00			db "DEDIT",0              
4d48				endm 
# End of macro CWHEAD
4d48			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | TO TEST 
4d48			 
4d48					; TODO does not copy from stack 
4d48					if DEBUG_FORTH_WORDS_KEY 
4d48						DMARK "DED" 
4d48 f5				push af  
4d49 3a 5d 4d			ld a, (.dmark)  
4d4c 32 a6 fd			ld (debug_mark),a  
4d4f 3a 5e 4d			ld a, (.dmark+1)  
4d52 32 a7 fd			ld (debug_mark+1),a  
4d55 3a 5f 4d			ld a, (.dmark+2)  
4d58 32 a8 fd			ld (debug_mark+2),a  
4d5b 18 03			jr .pastdmark  
4d5d ..			.dmark: db "DED"  
4d60 f1			.pastdmark: pop af  
4d61			endm  
# End of macro DMARK
4d61						CALLMONITOR 
4d61 cd aa fd			call debug_vector  
4d64				endm  
# End of macro CALLMONITOR
4d64					endif 
4d64			 
4d64					;FORTH_DSP 
4d64					FORTH_DSP_VALUEHL 
4d64 cd 0f 22			call macro_dsp_valuehl 
4d67				endm 
# End of macro FORTH_DSP_VALUEHL
4d67			;		inc hl    ; TODO do type check 
4d67			 
4d67			;		call get_word_hl 
4d67 e5					push hl 
4d68 e5					push hl 
4d69					FORTH_DSP_POP 
4d69 cd c7 22			call macro_forth_dsp_pop 
4d6c				endm 
# End of macro FORTH_DSP_POP
4d6c e1					pop hl 
4d6d					if DEBUG_FORTH_WORDS 
4d6d						DMARK "EDp" 
4d6d f5				push af  
4d6e 3a 82 4d			ld a, (.dmark)  
4d71 32 a6 fd			ld (debug_mark),a  
4d74 3a 83 4d			ld a, (.dmark+1)  
4d77 32 a7 fd			ld (debug_mark+1),a  
4d7a 3a 84 4d			ld a, (.dmark+2)  
4d7d 32 a8 fd			ld (debug_mark+2),a  
4d80 18 03			jr .pastdmark  
4d82 ..			.dmark: db "EDp"  
4d85 f1			.pastdmark: pop af  
4d86			endm  
# End of macro DMARK
4d86						CALLMONITOR 
4d86 cd aa fd			call debug_vector  
4d89				endm  
# End of macro CALLMONITOR
4d89					endif 
4d89				;	ld a, 0 
4d89 cd 42 13				call strlenz 
4d8c 23					inc hl 
4d8d			 
4d8d 06 00				ld b, 0 
4d8f 4d					ld c, l 
4d90			 
4d90 e1					pop hl 
4d91			 
4d91					;ld a, 0 
4d91					;ld (hl),a 
4d91 3a 99 f9				ld a,(f_cursor_ptr) 
4d94 16 64				ld d, 100 
4d96 0e 00				ld c, 0 
4d98 1e 28				ld e, 40 
4d9a cd fc 0f				call input_str 
4d9d					; TODO perhaps do a type check and wrap in quotes if not a number 
4d9d					NEXTW 
4d9d c3 c5 23			jp macro_next 
4da0				endm 
# End of macro NEXTW
4da0			 
4da0			 
4da0			.ENDKEY: 
4da0			; eof 
4da0			 
# End of file forth_words_key.asm
4da0			include "forth_words_const.asm" 
4da0			 
4da0			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4da0			 
4da0			 
4da0			.SPITIME: 
4da0				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4da0 77				db WORD_SYS_CORE+99             
4da1 b5 4d			dw .VA            
4da3 08				db 7 + 1 
4da4 .. 00			db "SPITIME",0              
4dac				endm 
# End of macro CWHEAD
4dac			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
4dac			; 
4dac			; | | If using BANK devices then leave as is. 
4dac			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
4dac			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
4dac			 
4dac 21 9f f9				ld hl, spi_clktime  
4daf cd 18 20				call forth_push_numhl 
4db2			 
4db2					NEXTW 
4db2 c3 c5 23			jp macro_next 
4db5				endm 
# End of macro NEXTW
4db5			 
4db5			 
4db5			.VA: 
4db5				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4db5 77				db WORD_SYS_CORE+99             
4db6 c5 4d			dw .SYMBOL            
4db8 03				db 2 + 1 
4db9 .. 00			db "VA",0              
4dbc				endm 
# End of macro CWHEAD
4dbc			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
4dbc 21 63 f9				ld hl, cli_var_array 
4dbf cd 18 20				call forth_push_numhl 
4dc2			 
4dc2					NEXTW 
4dc2 c3 c5 23			jp macro_next 
4dc5				endm 
# End of macro NEXTW
4dc5			 
4dc5			.SYMBOL: 
4dc5				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4dc5 77				db WORD_SYS_CORE+99             
4dc6 cf 4e			dw .ENDCONST            
4dc8 07				db 6 + 1 
4dc9 .. 00			db "SYMBOL",0              
4dd0				endm 
# End of macro CWHEAD
4dd0			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4dd0			; | 
4dd0			; | | The value is the number reference and the final address is pushed to stack 
4dd0			 
4dd0			; | | ``` 
4dd0			; | | dw sym_table 
4dd0			; | | dw nmi_vector 
4dd0			; | | dw cli_autodisplay 
4dd0			; | | dw cli_data_sp 
4dd0			; | | dw cli_data_stack 
4dd0			; | | dw cli_loop_sp 
4dd0			; | | dw cli_loop_stack 
4dd0			; | | dw cli_var_array 
4dd0			; | | dw cursor_col 
4dd0			; | | dw cursor_ptr 
4dd0			; | | ; 10 
4dd0			; | | dw cursor_row 
4dd0			; | | dw debug_mark 
4dd0			; | | dw display_fb0 
4dd0			; | | dw display_fb1 
4dd0			; | | dw display_fb2 
4dd0			; | | dw display_fb3 
4dd0			; | | dw display_fb_active 
4dd0			; | | dw execscratch 
4dd0			; | | dw f_cursor_ptr 
4dd0			; | | dw hardware_word 
4dd0			; | | ;20 
4dd0			; | | dw input_at_cursor 
4dd0			; | | dw input_at_pos 
4dd0			; | | dw input_cur_flash 
4dd0			; | | dw input_cur_onoff 
4dd0			; | | dw input_cursor 
4dd0			; | | dw input_display_size 
4dd0			; | | dw input_len 
4dd0			; | | dw input_ptr 
4dd0			; | | dw input_size 
4dd0			; | | dw input_start 
4dd0			; | | ; 30 
4dd0			; | | dw input_str 
4dd0			; | | dw input_under_cursor 
4dd0			; | | dw os_cli_cmd 
4dd0			; | | dw os_cur_ptr 
4dd0			; | | dw os_current_i 
4dd0			; | | dw os_input 
4dd0			; | | dw os_last_cmd 
4dd0			; | | dw os_last_new_uword 
4dd0			; | | dw debug_vector 
4dd0			; | | dw os_view_hl 
4dd0			; | | ;40 
4dd0			; | | dw os_word_scratch 
4dd0			; | | dw portbctl 
4dd0			; | | dw portbdata 
4dd0			; | | dw spi_cartdev 
4dd0			; | | dw spi_cartdev2 
4dd0			; | | dw spi_clktime 
4dd0			; | | dw spi_device 
4dd0			; | | dw spi_device_id 
4dd0			; | | dw spi_portbyte 
4dd0			; | | dw stackstore 
4dd0			; | | ; 50 
4dd0			; | | if STORAGE_SE 
4dd0			; | | dw storage_actl 
4dd0			; | | dw storage_adata 
4dd0			; | | else 
4dd0			; | | dw 0 
4dd0			; | | dw 0 
4dd0			; | | endif 
4dd0			; | | dw storage_append 
4dd0			; | | if STORAGE_SE 
4dd0			; | | dw storage_bctl 
4dd0			; | | else 
4dd0			; | | dw 0 
4dd0			; | | endif 
4dd0			; | | dw store_bank_active 
4dd0			; | | dw store_filecache 
4dd0			; | | dw store_longread 
4dd0			; | | dw store_openaddr 
4dd0			; | | dw store_openext 
4dd0			; | | dw store_openmaxext 
4dd0			; | | ; 60 
4dd0			; | | dw store_page 
4dd0			; | | dw store_readbuf 
4dd0			; | | dw store_readcont 
4dd0			; | | dw store_readptr 
4dd0			; | | dw store_tmpext 
4dd0			; | | dw store_tmpid 
4dd0			; | | dw store_tmppageid 
4dd0			; | | dw malloc 
4dd0			; | | dw free 
4dd0			; | | dw cin 
4dd0			; | | ; 70 
4dd0			; | | dw cin_wait 
4dd0			; | | dw forth_push_numhl 
4dd0			; | | dw forth_push_str 
4dd0			; | | ``` 
4dd0			 
4dd0					if DEBUG_FORTH_WORDS_KEY 
4dd0						DMARK "SYM" 
4dd0 f5				push af  
4dd1 3a e5 4d			ld a, (.dmark)  
4dd4 32 a6 fd			ld (debug_mark),a  
4dd7 3a e6 4d			ld a, (.dmark+1)  
4dda 32 a7 fd			ld (debug_mark+1),a  
4ddd 3a e7 4d			ld a, (.dmark+2)  
4de0 32 a8 fd			ld (debug_mark+2),a  
4de3 18 03			jr .pastdmark  
4de5 ..			.dmark: db "SYM"  
4de8 f1			.pastdmark: pop af  
4de9			endm  
# End of macro DMARK
4de9						CALLMONITOR 
4de9 cd aa fd			call debug_vector  
4dec				endm  
# End of macro CALLMONITOR
4dec					endif 
4dec			 
4dec					FORTH_DSP_VALUEHL 
4dec cd 0f 22			call macro_dsp_valuehl 
4def				endm 
# End of macro FORTH_DSP_VALUEHL
4def			 
4def 7d					ld a, l     
4df0			 
4df0			 
4df0					if DEBUG_FORTH_WORDS 
4df0						DMARK "SY1" 
4df0 f5				push af  
4df1 3a 05 4e			ld a, (.dmark)  
4df4 32 a6 fd			ld (debug_mark),a  
4df7 3a 06 4e			ld a, (.dmark+1)  
4dfa 32 a7 fd			ld (debug_mark+1),a  
4dfd 3a 07 4e			ld a, (.dmark+2)  
4e00 32 a8 fd			ld (debug_mark+2),a  
4e03 18 03			jr .pastdmark  
4e05 ..			.dmark: db "SY1"  
4e08 f1			.pastdmark: pop af  
4e09			endm  
# End of macro DMARK
4e09						CALLMONITOR 
4e09 cd aa fd			call debug_vector  
4e0c				endm  
# End of macro CALLMONITOR
4e0c					endif 
4e0c					 
4e0c f5					push af	 
4e0d					FORTH_DSP_POP 
4e0d cd c7 22			call macro_forth_dsp_pop 
4e10				endm 
# End of macro FORTH_DSP_POP
4e10 f1					pop af 
4e11			 
4e11 cb 27				sla a  
4e13				 
4e13					 
4e13					if DEBUG_FORTH_WORDS 
4e13						DMARK "SY" 
4e13 f5				push af  
4e14 3a 28 4e			ld a, (.dmark)  
4e17 32 a6 fd			ld (debug_mark),a  
4e1a 3a 29 4e			ld a, (.dmark+1)  
4e1d 32 a7 fd			ld (debug_mark+1),a  
4e20 3a 2a 4e			ld a, (.dmark+2)  
4e23 32 a8 fd			ld (debug_mark+2),a  
4e26 18 02			jr .pastdmark  
4e28 ..			.dmark: db "SY"  
4e2a f1			.pastdmark: pop af  
4e2b			endm  
# End of macro DMARK
4e2b						CALLMONITOR 
4e2b cd aa fd			call debug_vector  
4e2e				endm  
# End of macro CALLMONITOR
4e2e					endif 
4e2e			 
4e2e 21 3d 4e				ld hl, sym_table 
4e31 cd cf 0f				call addatohl 
4e34 cd 47 23				call loadwordinhl 
4e37 cd 18 20				call forth_push_numhl 
4e3a			 
4e3a			 
4e3a				       NEXTW 
4e3a c3 c5 23			jp macro_next 
4e3d				endm 
# End of macro NEXTW
4e3d			 
4e3d			sym_table: 
4e3d			 
4e3d			; 0 
4e3d 3d 4e		dw sym_table 
4e3f ad fd		dw nmi_vector 
4e41 77 f9		dw cli_autodisplay 
4e43 29 f9		dw cli_data_sp 
4e45 63 f6		dw cli_data_stack 
4e47 2b f9		dw cli_loop_sp 
4e49 65 f8		dw cli_loop_stack 
4e4b 63 f9		dw cli_var_array 
4e4d 00 fb		dw cursor_col 
4e4f fe fa		dw cursor_ptr 
4e51			; 10 
4e51 ff fa		dw cursor_row 
4e53 a6 fd		dw debug_mark 
4e55 ec fc		dw display_fb0 
4e57 4b fc		dw display_fb1 
4e59 09 fb		dw display_fb2 
4e5b aa fb		dw display_fb3 
4e5d 07 fb		dw display_fb_active 
4e5f fb f1		dw execscratch 
4e61 99 f9		dw f_cursor_ptr 
4e63 b0 fd		dw hardware_word 
4e65			;20 
4e65 9d fd		dw input_at_cursor 
4e67 9f fd		dw input_at_pos 
4e69 9b fd		dw input_cur_flash 
4e6b 9a fd		dw input_cur_onoff 
4e6d 90 fd		dw input_cursor 
4e6f a0 fd		dw input_display_size 
4e71 95 fd		dw input_len 
4e73 a4 fd		dw input_ptr 
4e75 a1 fd		dw input_size 
4e77 a2 fd		dw input_start 
4e79			; 30 
4e79 fc 0f		dw input_str 
4e7b 9e fd		dw input_under_cursor 
4e7d 23 f4		dw os_cli_cmd 
4e7f 1f f4		dw os_cur_ptr 
4e81 21 f4		dw os_current_i 
4e83 fa f2		dw os_input 
4e85 22 f5		dw os_last_cmd 
4e87 f9 f3		dw os_last_new_uword 
4e89 aa fd		dw debug_vector 
4e8b de f0		dw os_view_hl 
4e8d			;40 
4e8d 01 f4		dw os_word_scratch 
4e8f c3 00		dw portbctl 
4e91 c1 00		dw portbdata 
4e93 9e f9		dw spi_cartdev 
4e95 9d f9		dw spi_cartdev2 
4e97 9f f9		dw spi_clktime 
4e99 9b f9		dw spi_device 
4e9b 9a f9		dw spi_device_id 
4e9d 9c f9		dw spi_portbyte 
4e9f e2 fa		dw stackstore 
4ea1			; 50 
4ea1			if STORAGE_SE 
4ea1 82 00		dw storage_actl 
4ea3 80 00		dw storage_adata 
4ea5			else 
4ea5			dw 0 
4ea5			dw 0 
4ea5			endif 
4ea5 55 0b		dw storage_append 
4ea7			if STORAGE_SE 
4ea7 83 00		dw storage_bctl 
4ea9			else 
4ea9			dw 0 
4ea9			endif 
4ea9 ce fa		dw store_bank_active 
4eab a2 f9		dw store_filecache 
4ead b0 f9		dw store_longread 
4eaf a6 f9		dw store_openaddr 
4eb1 a5 f9		dw store_openext 
4eb3 a4 f9		dw store_openmaxext 
4eb5			; 60 
4eb5 b5 f9		dw store_page 
4eb7 b1 f9		dw store_readbuf 
4eb9 a8 f9		dw store_readcont 
4ebb b3 f9		dw store_readptr 
4ebd a8 f9		dw store_tmpext 
4ebf a9 f9		dw store_tmpid 
4ec1 a0 f9		dw store_tmppageid 
4ec3 b7 13		dw malloc 
4ec5 81 14		dw free 
4ec7 92 79		dw cin 
4ec9			; 70 
4ec9 81 79		dw cin_wait 
4ecb 18 20		dw forth_push_numhl 
4ecd 86 20		dw forth_push_str 
4ecf			 
4ecf			 
4ecf			.ENDCONST: 
4ecf			 
4ecf			; eof 
4ecf			 
4ecf			 
# End of file forth_words_const.asm
4ecf			 
4ecf			if STORAGE_SE 
4ecf			   	include "forth_words_storage.asm" 
4ecf			 
4ecf			; | ## Fixed Storage Words 
4ecf			 
4ecf			.RENAME: 
4ecf			  
4ecf				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
4ecf 3a				db WORD_SYS_CORE+38             
4ed0 c5 4f			dw .RECORD            
4ed2 07				db 6 + 1 
4ed3 .. 00			db "RENAME",0              
4eda				endm 
# End of macro CWHEAD
4eda			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
4eda			; | | > [!NOTE] 
4eda			; | | > Compatible with PicoSPINet  
4eda					if DEBUG_FORTH_WORDS_KEY 
4eda						DMARK "REN" 
4eda f5				push af  
4edb 3a ef 4e			ld a, (.dmark)  
4ede 32 a6 fd			ld (debug_mark),a  
4ee1 3a f0 4e			ld a, (.dmark+1)  
4ee4 32 a7 fd			ld (debug_mark+1),a  
4ee7 3a f1 4e			ld a, (.dmark+2)  
4eea 32 a8 fd			ld (debug_mark+2),a  
4eed 18 03			jr .pastdmark  
4eef ..			.dmark: db "REN"  
4ef2 f1			.pastdmark: pop af  
4ef3			endm  
# End of macro DMARK
4ef3						CALLMONITOR 
4ef3 cd aa fd			call debug_vector  
4ef6				endm  
# End of macro CALLMONITOR
4ef6					endif 
4ef6			 
4ef6			 
4ef6					; preserve some internal vars used by other file handing routines 
4ef6			 
4ef6 2a a6 f9				ld hl, (store_openaddr) 
4ef9 e5					push hl 
4efa 3a a8 f9				ld a, (store_readcont) 
4efd f5					push af 
4efe			 
4efe					FORTH_DSP_VALUEHL 
4efe cd 0f 22			call macro_dsp_valuehl 
4f01				endm 
# End of macro FORTH_DSP_VALUEHL
4f01			 
4f01					; move ext and id around for the file header 
4f01			 
4f01 65					ld h, l 
4f02 2e 00				ld l, 0 
4f04			 
4f04 e5					push hl    ; id 
4f05			 
4f05					FORTH_DSP_POP 
4f05 cd c7 22			call macro_forth_dsp_pop 
4f08				endm 
# End of macro FORTH_DSP_POP
4f08			 
4f08					; Locate the file header 
4f08			 
4f08 e1					pop hl 
4f09 e5					push hl 
4f0a 11 b5 f9				ld de, store_page      ; get block zero of file 
4f0d					if DEBUG_FORTH_WORDS 
4f0d						DMARK "REr" 
4f0d f5				push af  
4f0e 3a 22 4f			ld a, (.dmark)  
4f11 32 a6 fd			ld (debug_mark),a  
4f14 3a 23 4f			ld a, (.dmark+1)  
4f17 32 a7 fd			ld (debug_mark+1),a  
4f1a 3a 24 4f			ld a, (.dmark+2)  
4f1d 32 a8 fd			ld (debug_mark+2),a  
4f20 18 03			jr .pastdmark  
4f22 ..			.dmark: db "REr"  
4f25 f1			.pastdmark: pop af  
4f26			endm  
# End of macro DMARK
4f26						CALLMONITOR 
4f26 cd aa fd			call debug_vector  
4f29				endm  
# End of macro CALLMONITOR
4f29					endif 
4f29 cd be 09				call storage_read 
4f2c			 
4f2c cd f8 0f			call ishlzero 
4f2f 20 05			jr nz, .rnfound 
4f31			 
4f31				; file does not exist so indicate with 255 extents in use 
4f31			 
4f31 3e ff			ld a, 255 
4f33 e1				pop hl ; clear dup hl 
4f34 18 7b			jr .skiprneof 
4f36			 
4f36			 
4f36			.rnfound: 
4f36					; file found so rename 
4f36			 
4f36					FORTH_DSP_VALUEHL 
4f36 cd 0f 22			call macro_dsp_valuehl 
4f39				endm 
# End of macro FORTH_DSP_VALUEHL
4f39			 
4f39 e5				push hl 
4f3a 3e 00			ld a, 0 
4f3c cd 4d 13			call strlent 
4f3f 23				inc hl   ; cover zero term 
4f40 06 00			ld b,0 
4f42 4d				ld c,l 
4f43 e1				pop hl 
4f44 11 b8 f9				ld de, store_page + 3 
4f47 ed b0				ldir 
4f49			 
4f49 11 b5 f9				ld de, store_page 
4f4c					if DEBUG_FORTH_WORDS 
4f4c						DMARK "RER" 
4f4c f5				push af  
4f4d 3a 61 4f			ld a, (.dmark)  
4f50 32 a6 fd			ld (debug_mark),a  
4f53 3a 62 4f			ld a, (.dmark+1)  
4f56 32 a7 fd			ld (debug_mark+1),a  
4f59 3a 63 4f			ld a, (.dmark+2)  
4f5c 32 a8 fd			ld (debug_mark+2),a  
4f5f 18 03			jr .pastdmark  
4f61 ..			.dmark: db "RER"  
4f64 f1			.pastdmark: pop af  
4f65			endm  
# End of macro DMARK
4f65						CALLMONITOR 
4f65 cd aa fd			call debug_vector  
4f68				endm  
# End of macro CALLMONITOR
4f68					endif 
4f68			 
4f68 e1					pop hl    ; get orig file id and mangle it for find id 
4f69 55					ld d, l 
4f6a 5c					ld e, h 
4f6b			 
4f6b 21 00 00				ld hl, 0 
4f6e					if DEBUG_FORTH_WORDS 
4f6e						DMARK "REf" 
4f6e f5				push af  
4f6f 3a 83 4f			ld a, (.dmark)  
4f72 32 a6 fd			ld (debug_mark),a  
4f75 3a 84 4f			ld a, (.dmark+1)  
4f78 32 a7 fd			ld (debug_mark+1),a  
4f7b 3a 85 4f			ld a, (.dmark+2)  
4f7e 32 a8 fd			ld (debug_mark+2),a  
4f81 18 03			jr .pastdmark  
4f83 ..			.dmark: db "REf"  
4f86 f1			.pastdmark: pop af  
4f87			endm  
# End of macro DMARK
4f87						CALLMONITOR 
4f87 cd aa fd			call debug_vector  
4f8a				endm  
# End of macro CALLMONITOR
4f8a					endif 
4f8a cd 98 07				call storage_findnextid 
4f8d 11 b5 f9				ld de, store_page 
4f90					if DEBUG_FORTH_WORDS 
4f90						DMARK "REw" 
4f90 f5				push af  
4f91 3a a5 4f			ld a, (.dmark)  
4f94 32 a6 fd			ld (debug_mark),a  
4f97 3a a6 4f			ld a, (.dmark+1)  
4f9a 32 a7 fd			ld (debug_mark+1),a  
4f9d 3a a7 4f			ld a, (.dmark+2)  
4fa0 32 a8 fd			ld (debug_mark+2),a  
4fa3 18 03			jr .pastdmark  
4fa5 ..			.dmark: db "REw"  
4fa8 f1			.pastdmark: pop af  
4fa9			endm  
# End of macro DMARK
4fa9						CALLMONITOR 
4fa9 cd aa fd			call debug_vector  
4fac				endm  
# End of macro CALLMONITOR
4fac					endif 
4fac cd ca 04				call storage_write_block 
4faf			 
4faf 3e 00				ld a, 0 
4fb1			.skiprneof: 
4fb1					; drop file name 
4fb1					FORTH_DSP_POP 
4fb1 cd c7 22			call macro_forth_dsp_pop 
4fb4				endm 
# End of macro FORTH_DSP_POP
4fb4			 
4fb4 6f					ld l, a 
4fb5 26 00				ld h, 0 
4fb7 cd 18 20				call forth_push_numhl 
4fba			 
4fba			 
4fba f1					pop af 
4fbb 32 a8 f9				ld (store_readcont),a 
4fbe e1					pop hl 
4fbf 22 a6 f9				ld (store_openaddr), hl 
4fc2						 
4fc2				NEXTW 
4fc2 c3 c5 23			jp macro_next 
4fc5				endm 
# End of macro NEXTW
4fc5			.RECORD: 
4fc5			  
4fc5				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
4fc5 3a				db WORD_SYS_CORE+38             
4fc6 69 50			dw .BREAD            
4fc8 07				db 6 + 1 
4fc9 .. 00			db "RECORD",0              
4fd0				endm 
# End of macro CWHEAD
4fd0			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
4fd0			; | | > [!NOTE] 
4fd0			; | | > Compatible with PicoSPINet  
4fd0			 
4fd0					if DEBUG_FORTH_WORDS_KEY 
4fd0						DMARK "REC" 
4fd0 f5				push af  
4fd1 3a e5 4f			ld a, (.dmark)  
4fd4 32 a6 fd			ld (debug_mark),a  
4fd7 3a e6 4f			ld a, (.dmark+1)  
4fda 32 a7 fd			ld (debug_mark+1),a  
4fdd 3a e7 4f			ld a, (.dmark+2)  
4fe0 32 a8 fd			ld (debug_mark+2),a  
4fe3 18 03			jr .pastdmark  
4fe5 ..			.dmark: db "REC"  
4fe8 f1			.pastdmark: pop af  
4fe9			endm  
# End of macro DMARK
4fe9						CALLMONITOR 
4fe9 cd aa fd			call debug_vector  
4fec				endm  
# End of macro CALLMONITOR
4fec					endif 
4fec			 
4fec					FORTH_DSP_VALUEHL 
4fec cd 0f 22			call macro_dsp_valuehl 
4fef				endm 
# End of macro FORTH_DSP_VALUEHL
4fef			 
4fef e5					push hl    ; id 
4ff0			 
4ff0					FORTH_DSP_POP 
4ff0 cd c7 22			call macro_forth_dsp_pop 
4ff3				endm 
# End of macro FORTH_DSP_POP
4ff3			 
4ff3					FORTH_DSP_VALUEHL 
4ff3 cd 0f 22			call macro_dsp_valuehl 
4ff6				endm 
# End of macro FORTH_DSP_VALUEHL
4ff6			 
4ff6					FORTH_DSP_POP 
4ff6 cd c7 22			call macro_forth_dsp_pop 
4ff9				endm 
# End of macro FORTH_DSP_POP
4ff9			 
4ff9 d1					pop de     ; get file id 
4ffa			 
4ffa					; e = file id 
4ffa					; l = file extent 
4ffa			 
4ffa			 
4ffa					; construct request to access file extent 
4ffa			 
4ffa			;		ld a, e 
4ffa 63					ld h, e 
4ffb					 
4ffb					 
4ffb					 
4ffb			 
4ffb					; e has id 
4ffb			 
4ffb 11 b5 f9			ld de, store_page 
4ffe					if DEBUG_FORTH_WORDS 
4ffe						DMARK "REr" 
4ffe f5				push af  
4fff 3a 13 50			ld a, (.dmark)  
5002 32 a6 fd			ld (debug_mark),a  
5005 3a 14 50			ld a, (.dmark+1)  
5008 32 a7 fd			ld (debug_mark+1),a  
500b 3a 15 50			ld a, (.dmark+2)  
500e 32 a8 fd			ld (debug_mark+2),a  
5011 18 03			jr .pastdmark  
5013 ..			.dmark: db "REr"  
5016 f1			.pastdmark: pop af  
5017			endm  
# End of macro DMARK
5017						CALLMONITOR 
5017 cd aa fd			call debug_vector  
501a				endm  
# End of macro CALLMONITOR
501a					endif 
501a cd be 09				call storage_read 
501d cd f8 0f			call ishlzero 
5020 28 22			jr z, .recnotfound 
5022			 
5022			 
5022					if DEBUG_FORTH_WORDS 
5022						DMARK "REe" 
5022 f5				push af  
5023 3a 37 50			ld a, (.dmark)  
5026 32 a6 fd			ld (debug_mark),a  
5029 3a 38 50			ld a, (.dmark+1)  
502c 32 a7 fd			ld (debug_mark+1),a  
502f 3a 39 50			ld a, (.dmark+2)  
5032 32 a8 fd			ld (debug_mark+2),a  
5035 18 03			jr .pastdmark  
5037 ..			.dmark: db "REe"  
503a f1			.pastdmark: pop af  
503b			endm  
# End of macro DMARK
503b						CALLMONITOR 
503b cd aa fd			call debug_vector  
503e				endm  
# End of macro CALLMONITOR
503e					endif 
503e cd 86 20			call forth_push_str 
5041			 
5041					NEXTW 
5041 c3 c5 23			jp macro_next 
5044				endm 
# End of macro NEXTW
5044			 
5044			.recnotfound: 
5044					if DEBUG_FORTH_WORDS 
5044						DMARK "REf" 
5044 f5				push af  
5045 3a 59 50			ld a, (.dmark)  
5048 32 a6 fd			ld (debug_mark),a  
504b 3a 5a 50			ld a, (.dmark+1)  
504e 32 a7 fd			ld (debug_mark+1),a  
5051 3a 5b 50			ld a, (.dmark+2)  
5054 32 a8 fd			ld (debug_mark+2),a  
5057 18 03			jr .pastdmark  
5059 ..			.dmark: db "REf"  
505c f1			.pastdmark: pop af  
505d			endm  
# End of macro DMARK
505d						CALLMONITOR 
505d cd aa fd			call debug_vector  
5060				endm  
# End of macro CALLMONITOR
5060					endif 
5060 21 ff 00			ld hl, 255 
5063 cd 18 20			call forth_push_numhl 
5066				NEXTW 
5066 c3 c5 23			jp macro_next 
5069				endm 
# End of macro NEXTW
5069			 
5069			 
5069			.BREAD: 
5069			  
5069				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
5069 3a				db WORD_SYS_CORE+38             
506a ec 50			dw .BWRITE            
506c 06				db 5 + 1 
506d .. 00			db "BREAD",0              
5073				endm 
# End of macro CWHEAD
5073			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
5073			; | | > [!NOTE] 
5073			; | | > Compatible with PicoSPINet  
5073				 
5073					if DEBUG_FORTH_WORDS_KEY 
5073						DMARK "BRD" 
5073 f5				push af  
5074 3a 88 50			ld a, (.dmark)  
5077 32 a6 fd			ld (debug_mark),a  
507a 3a 89 50			ld a, (.dmark+1)  
507d 32 a7 fd			ld (debug_mark+1),a  
5080 3a 8a 50			ld a, (.dmark+2)  
5083 32 a8 fd			ld (debug_mark+2),a  
5086 18 03			jr .pastdmark  
5088 ..			.dmark: db "BRD"  
508b f1			.pastdmark: pop af  
508c			endm  
# End of macro DMARK
508c						CALLMONITOR 
508c cd aa fd			call debug_vector  
508f				endm  
# End of macro CALLMONITOR
508f					endif 
508f			 
508f				FORTH_DSP_VALUEHL 
508f cd 0f 22			call macro_dsp_valuehl 
5092				endm 
# End of macro FORTH_DSP_VALUEHL
5092			 
5092				FORTH_DSP_POP 
5092 cd c7 22			call macro_forth_dsp_pop 
5095				endm 
# End of macro FORTH_DSP_POP
5095			 
5095				; calc block address 
5095			 
5095 eb				ex de, hl 
5096 3e 40			ld a, STORE_BLOCK_PHY 
5098 cd 52 0f			call Mult16 
509b			 
509b			 
509b 11 b5 f9			ld de, store_page 
509e			 
509e					if DEBUG_FORTH_WORDS 
509e						DMARK "BR1" 
509e f5				push af  
509f 3a b3 50			ld a, (.dmark)  
50a2 32 a6 fd			ld (debug_mark),a  
50a5 3a b4 50			ld a, (.dmark+1)  
50a8 32 a7 fd			ld (debug_mark+1),a  
50ab 3a b5 50			ld a, (.dmark+2)  
50ae 32 a8 fd			ld (debug_mark+2),a  
50b1 18 03			jr .pastdmark  
50b3 ..			.dmark: db "BR1"  
50b6 f1			.pastdmark: pop af  
50b7			endm  
# End of macro DMARK
50b7						CALLMONITOR 
50b7 cd aa fd			call debug_vector  
50ba				endm  
# End of macro CALLMONITOR
50ba					endif 
50ba			 
50ba cd 65 04			call storage_read_block 
50bd			 
50bd cd f8 0f			call ishlzero 
50c0 20 05			jr nz, .brfound 
50c2			 
50c2 cd 18 20			call forth_push_numhl 
50c5 18 22			jr .brdone 
50c7			 
50c7			 
50c7			.brfound: 
50c7 21 b7 f9		        ld hl, store_page+2 
50ca			 
50ca					if DEBUG_FORTH_WORDS 
50ca						DMARK "BR2" 
50ca f5				push af  
50cb 3a df 50			ld a, (.dmark)  
50ce 32 a6 fd			ld (debug_mark),a  
50d1 3a e0 50			ld a, (.dmark+1)  
50d4 32 a7 fd			ld (debug_mark+1),a  
50d7 3a e1 50			ld a, (.dmark+2)  
50da 32 a8 fd			ld (debug_mark+2),a  
50dd 18 03			jr .pastdmark  
50df ..			.dmark: db "BR2"  
50e2 f1			.pastdmark: pop af  
50e3			endm  
# End of macro DMARK
50e3						CALLMONITOR 
50e3 cd aa fd			call debug_vector  
50e6				endm  
# End of macro CALLMONITOR
50e6					endif 
50e6			 
50e6 cd 86 20			call forth_push_str 
50e9			 
50e9			 
50e9			.brdone: 
50e9			 
50e9					NEXTW 
50e9 c3 c5 23			jp macro_next 
50ec				endm 
# End of macro NEXTW
50ec			.BWRITE: 
50ec				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
50ec 3a				db WORD_SYS_CORE+38             
50ed 81 51			dw .BUPD            
50ef 07				db 6 + 1 
50f0 .. 00			db "BWRITE",0              
50f7				endm 
# End of macro CWHEAD
50f7			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
50f7			; | | > [!NOTE] 
50f7			; | | > Compatible with PicoSPINet  
50f7			 
50f7					if DEBUG_FORTH_WORDS_KEY 
50f7						DMARK "BWR" 
50f7 f5				push af  
50f8 3a 0c 51			ld a, (.dmark)  
50fb 32 a6 fd			ld (debug_mark),a  
50fe 3a 0d 51			ld a, (.dmark+1)  
5101 32 a7 fd			ld (debug_mark+1),a  
5104 3a 0e 51			ld a, (.dmark+2)  
5107 32 a8 fd			ld (debug_mark+2),a  
510a 18 03			jr .pastdmark  
510c ..			.dmark: db "BWR"  
510f f1			.pastdmark: pop af  
5110			endm  
# End of macro DMARK
5110						CALLMONITOR 
5110 cd aa fd			call debug_vector  
5113				endm  
# End of macro CALLMONITOR
5113					endif 
5113			 
5113				FORTH_DSP_VALUEHL 
5113 cd 0f 22			call macro_dsp_valuehl 
5116				endm 
# End of macro FORTH_DSP_VALUEHL
5116			 
5116				; calc block address 
5116			 
5116 eb				ex de, hl 
5117 3e 40			ld a, STORE_BLOCK_PHY 
5119 cd 52 0f			call Mult16 
511c			 
511c e5				push hl         ; address 
511d			 
511d				FORTH_DSP_POP 
511d cd c7 22			call macro_forth_dsp_pop 
5120				endm 
# End of macro FORTH_DSP_POP
5120			 
5120				FORTH_DSP_VALUEHL 
5120 cd 0f 22			call macro_dsp_valuehl 
5123				endm 
# End of macro FORTH_DSP_VALUEHL
5123			 
5123				FORTH_DSP_POP 
5123 cd c7 22			call macro_forth_dsp_pop 
5126				endm 
# End of macro FORTH_DSP_POP
5126			 
5126 cd a1 0c			call storage_clear_page 
5129			 
5129				; copy string to store page 
5129			 
5129 e5				push hl     ; save string address 
512a			 
512a 3e 00			ld a, 0 
512c cd 4d 13			call strlent 
512f			 
512f 23				inc hl 
5130			 
5130 4d				ld c, l 
5131 06 00			ld b, 0 
5133			 
5133 e1				pop hl 
5134 11 b7 f9			ld de, store_page + 2 
5137					if DEBUG_FORTH_WORDS 
5137						DMARK "BW1" 
5137 f5				push af  
5138 3a 4c 51			ld a, (.dmark)  
513b 32 a6 fd			ld (debug_mark),a  
513e 3a 4d 51			ld a, (.dmark+1)  
5141 32 a7 fd			ld (debug_mark+1),a  
5144 3a 4e 51			ld a, (.dmark+2)  
5147 32 a8 fd			ld (debug_mark+2),a  
514a 18 03			jr .pastdmark  
514c ..			.dmark: db "BW1"  
514f f1			.pastdmark: pop af  
5150			endm  
# End of macro DMARK
5150						CALLMONITOR 
5150 cd aa fd			call debug_vector  
5153				endm  
# End of macro CALLMONITOR
5153					endif 
5153 ed b0			ldir 
5155			 
5155			 
5155				; poke the start of the block with flags to prevent high level file ops hitting the block 
5155			 
5155 21 ff ff			ld hl, $ffff 
5158			 
5158 22 b5 f9			ld (store_page), hl	 
515b				 
515b e1				pop hl    ; get address 
515c 11 b5 f9			ld de, store_page 
515f			 
515f					if DEBUG_FORTH_WORDS 
515f						DMARK "BW2" 
515f f5				push af  
5160 3a 74 51			ld a, (.dmark)  
5163 32 a6 fd			ld (debug_mark),a  
5166 3a 75 51			ld a, (.dmark+1)  
5169 32 a7 fd			ld (debug_mark+1),a  
516c 3a 76 51			ld a, (.dmark+2)  
516f 32 a8 fd			ld (debug_mark+2),a  
5172 18 03			jr .pastdmark  
5174 ..			.dmark: db "BW2"  
5177 f1			.pastdmark: pop af  
5178			endm  
# End of macro DMARK
5178						CALLMONITOR 
5178 cd aa fd			call debug_vector  
517b				endm  
# End of macro CALLMONITOR
517b					endif 
517b			 
517b cd ca 04			call storage_write_block 
517e			 
517e					NEXTW 
517e c3 c5 23			jp macro_next 
5181				endm 
# End of macro NEXTW
5181			 
5181			.BUPD: 
5181				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
5181 3a				db WORD_SYS_CORE+38             
5182 d7 51			dw .BYID            
5184 05				db 4 + 1 
5185 .. 00			db "BUPD",0              
518a				endm 
# End of macro CWHEAD
518a			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
518a			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
518a			; | | or completely different file system structure. 
518a			; | | > [!NOTE] 
518a			; | | > Compatible with PicoSPINet  
518a			 
518a					if DEBUG_FORTH_WORDS_KEY 
518a						DMARK "BUD" 
518a f5				push af  
518b 3a 9f 51			ld a, (.dmark)  
518e 32 a6 fd			ld (debug_mark),a  
5191 3a a0 51			ld a, (.dmark+1)  
5194 32 a7 fd			ld (debug_mark+1),a  
5197 3a a1 51			ld a, (.dmark+2)  
519a 32 a8 fd			ld (debug_mark+2),a  
519d 18 03			jr .pastdmark  
519f ..			.dmark: db "BUD"  
51a2 f1			.pastdmark: pop af  
51a3			endm  
# End of macro DMARK
51a3						CALLMONITOR 
51a3 cd aa fd			call debug_vector  
51a6				endm  
# End of macro CALLMONITOR
51a6					endif 
51a6			 
51a6				FORTH_DSP_VALUEHL 
51a6 cd 0f 22			call macro_dsp_valuehl 
51a9				endm 
# End of macro FORTH_DSP_VALUEHL
51a9			 
51a9				; calc block address 
51a9			 
51a9 eb				ex de, hl 
51aa 3e 40			ld a, STORE_BLOCK_PHY 
51ac cd 52 0f			call Mult16 
51af			 
51af				FORTH_DSP_POP 
51af cd c7 22			call macro_forth_dsp_pop 
51b2				endm 
# End of macro FORTH_DSP_POP
51b2			 
51b2			 
51b2 11 b5 f9			ld de, store_page 
51b5			 
51b5					if DEBUG_FORTH_WORDS 
51b5						DMARK "BUe" 
51b5 f5				push af  
51b6 3a ca 51			ld a, (.dmark)  
51b9 32 a6 fd			ld (debug_mark),a  
51bc 3a cb 51			ld a, (.dmark+1)  
51bf 32 a7 fd			ld (debug_mark+1),a  
51c2 3a cc 51			ld a, (.dmark+2)  
51c5 32 a8 fd			ld (debug_mark+2),a  
51c8 18 03			jr .pastdmark  
51ca ..			.dmark: db "BUe"  
51cd f1			.pastdmark: pop af  
51ce			endm  
# End of macro DMARK
51ce						CALLMONITOR 
51ce cd aa fd			call debug_vector  
51d1				endm  
# End of macro CALLMONITOR
51d1					endif 
51d1			 
51d1 cd ca 04			call storage_write_block 
51d4			 
51d4					NEXTW 
51d4 c3 c5 23			jp macro_next 
51d7				endm 
# End of macro NEXTW
51d7			 
51d7			.BYID: 
51d7			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
51d7			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
51d7			; 
51d7			;		 
51d7			;		if DEBUG_FORTH_WORDS_KEY 
51d7			;			DMARK "BYID" 
51d7			;			CALLMONITOR 
51d7			;		endif 
51d7			; 
51d7			;		; get direct address 
51d7			; 
51d7			;		FORTH_DSP_VALUEHL 
51d7			; 
51d7			;		FORTH_DSP_POP 
51d7			; 
51d7			;	; calc block address 
51d7			; 
51d7			;	ex de, hl 
51d7			;	ld a, STORE_BLOCK_PHY 
51d7			;	call Mult16 
51d7			;	;	do BREAD with number as param 
51d7			;	; push the file name	 
51d7			;	ld de, store_page 
51d7			;	call storage_read_block 
51d7			 ;       ld hl, store_page+2 
51d7			; 
51d7			; 
51d7			;		NEXTW 
51d7			;.BYNAME: 
51d7				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
51d7 3a				db WORD_SYS_CORE+38             
51d8 f0 51			dw .DIR            
51da 06				db 5 + 1 
51db .. 00			db "GETID",0              
51e1				endm 
# End of macro CWHEAD
51e1			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
51e1			; | | > [!NOTE] 
51e1			; | | > Compatible with PicoSPINet  
51e1			 
51e1					; get pointer to file name to seek 
51e1			 
51e1					FORTH_DSP_VALUEHL 
51e1 cd 0f 22			call macro_dsp_valuehl 
51e4				endm 
# End of macro FORTH_DSP_VALUEHL
51e4			 
51e4			 
51e4 cd 8c 03				call storage_getid  
51e7			 
51e7					FORTH_DSP_POP 
51e7 cd c7 22			call macro_forth_dsp_pop 
51ea				endm 
# End of macro FORTH_DSP_POP
51ea			 
51ea cd 18 20				call forth_push_numhl 
51ed			 
51ed					NEXTW 
51ed c3 c5 23			jp macro_next 
51f0				endm 
# End of macro NEXTW
51f0			; 
51f0			.DIR: 
51f0				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
51f0 3a				db WORD_SYS_CORE+38             
51f1 f4 52			dw .SAVE            
51f3 04				db 3 + 1 
51f4 .. 00			db "DIR",0              
51f8				endm 
# End of macro CWHEAD
51f8			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
51f8			; | | > [!NOTE] 
51f8			; | | > Compatible with PicoSPINet  
51f8			 
51f8					if DEBUG_FORTH_WORDS_KEY 
51f8						DMARK "DIR" 
51f8 f5				push af  
51f9 3a 0d 52			ld a, (.dmark)  
51fc 32 a6 fd			ld (debug_mark),a  
51ff 3a 0e 52			ld a, (.dmark+1)  
5202 32 a7 fd			ld (debug_mark+1),a  
5205 3a 0f 52			ld a, (.dmark+2)  
5208 32 a8 fd			ld (debug_mark+2),a  
520b 18 03			jr .pastdmark  
520d ..			.dmark: db "DIR"  
5210 f1			.pastdmark: pop af  
5211			endm  
# End of macro DMARK
5211						CALLMONITOR 
5211 cd aa fd			call debug_vector  
5214				endm  
# End of macro CALLMONITOR
5214					endif 
5214 cd 16 05			call storage_get_block_0 
5217			 
5217 21 b5 f9			ld hl, store_page     ; get current id count 
521a 46				ld b, (hl) 
521b 0e 00			ld c, 0    ; count of files   
521d					if DEBUG_FORTH_WORDS 
521d						DMARK "DI1" 
521d f5				push af  
521e 3a 32 52			ld a, (.dmark)  
5221 32 a6 fd			ld (debug_mark),a  
5224 3a 33 52			ld a, (.dmark+1)  
5227 32 a7 fd			ld (debug_mark+1),a  
522a 3a 34 52			ld a, (.dmark+2)  
522d 32 a8 fd			ld (debug_mark+2),a  
5230 18 03			jr .pastdmark  
5232 ..			.dmark: db "DI1"  
5235 f1			.pastdmark: pop af  
5236			endm  
# End of macro DMARK
5236						CALLMONITOR 
5236 cd aa fd			call debug_vector  
5239				endm  
# End of macro CALLMONITOR
5239					endif 
5239			 
5239				; check for empty drive 
5239			 
5239 3e 00			ld a, 0 
523b b8				cp b 
523c ca aa 52			jp z, .dirdone 
523f			 
523f				; for each of the current ids do a search for them and if found push to stack 
523f			 
523f c5			.diritem:	push bc 
5240 21 40 00				ld hl, STORE_BLOCK_PHY 
5243 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
5245 58					ld e,b 
5246			 
5246			;		if DEBUG_FORTH_WORDS 
5246			;			DMARK "DI2" 
5246			;			CALLMONITOR 
5246			;		endif 
5246			 
5246 cd 98 07				call storage_findnextid 
5249			 
5249			;		if DEBUG_FORTH_WORDS 
5249			;			DMARK "DI3" 
5249			;			CALLMONITOR 
5249			;		endif 
5249			 
5249					; if found hl will be non zero 
5249			 
5249 cd f8 0f				call ishlzero 
524c			;		ld a, l 
524c			;		add h 
524c			; 
524c			;		cp 0 
524c 28 59				jr z, .dirnotfound 
524e			 
524e					; increase count 
524e			 
524e c1					pop bc	 
524f 0c					inc c 
5250 c5					push bc 
5251					 
5251			 
5251					; get file header and push the file name 
5251			 
5251 11 b5 f9				ld de, store_page 
5254 cd 65 04				call storage_read_block 
5257			 
5257					; push file id to stack 
5257				 
5257 3a b5 f9				ld a, (store_page) 
525a 26 00				ld h, 0 
525c 6f					ld l, a 
525d cd 18 20				call forth_push_numhl 
5260			 
5260					; push extent count to stack  
5260				 
5260 3a b7 f9				ld a, (store_page+2) 
5263 26 00				ld h, 0 
5265 6f					ld l, a 
5266 cd 18 20				call forth_push_numhl 
5269			 
5269					; push file name 
5269			 
5269 21 b8 f9				ld hl, store_page+3 
526c					if DEBUG_FORTH_WORDS 
526c						DMARK "DI5" 
526c f5				push af  
526d 3a 81 52			ld a, (.dmark)  
5270 32 a6 fd			ld (debug_mark),a  
5273 3a 82 52			ld a, (.dmark+1)  
5276 32 a7 fd			ld (debug_mark+1),a  
5279 3a 83 52			ld a, (.dmark+2)  
527c 32 a8 fd			ld (debug_mark+2),a  
527f 18 03			jr .pastdmark  
5281 ..			.dmark: db "DI5"  
5284 f1			.pastdmark: pop af  
5285			endm  
# End of macro DMARK
5285						CALLMONITOR 
5285 cd aa fd			call debug_vector  
5288				endm  
# End of macro CALLMONITOR
5288					endif 
5288 cd 86 20				call forth_push_str 
528b					if DEBUG_FORTH_WORDS 
528b						DMARK "DI6" 
528b f5				push af  
528c 3a a0 52			ld a, (.dmark)  
528f 32 a6 fd			ld (debug_mark),a  
5292 3a a1 52			ld a, (.dmark+1)  
5295 32 a7 fd			ld (debug_mark+1),a  
5298 3a a2 52			ld a, (.dmark+2)  
529b 32 a8 fd			ld (debug_mark+2),a  
529e 18 03			jr .pastdmark  
52a0 ..			.dmark: db "DI6"  
52a3 f1			.pastdmark: pop af  
52a4			endm  
# End of macro DMARK
52a4						CALLMONITOR 
52a4 cd aa fd			call debug_vector  
52a7				endm  
# End of macro CALLMONITOR
52a7					endif 
52a7			.dirnotfound: 
52a7 c1					pop bc     
52a8 10 95				djnz .diritem 
52aa				 
52aa			.dirdone:	 
52aa					if DEBUG_FORTH_WORDS 
52aa						DMARK "DI7" 
52aa f5				push af  
52ab 3a bf 52			ld a, (.dmark)  
52ae 32 a6 fd			ld (debug_mark),a  
52b1 3a c0 52			ld a, (.dmark+1)  
52b4 32 a7 fd			ld (debug_mark+1),a  
52b7 3a c1 52			ld a, (.dmark+2)  
52ba 32 a8 fd			ld (debug_mark+2),a  
52bd 18 03			jr .pastdmark  
52bf ..			.dmark: db "DI7"  
52c2 f1			.pastdmark: pop af  
52c3			endm  
# End of macro DMARK
52c3						CALLMONITOR 
52c3 cd aa fd			call debug_vector  
52c6				endm  
# End of macro CALLMONITOR
52c6					endif 
52c6			 
52c6					; push a count of the dir items found 
52c6			 
52c6 26 00				ld h, 0 
52c8 69					ld l, c 
52c9 cd 18 20				call forth_push_numhl 
52cc			 
52cc					; push the bank label 
52cc			 
52cc cd 16 05				call storage_get_block_0 
52cf			 
52cf				 
52cf 21 b8 f9		 		ld hl, store_page+3 
52d2			 
52d2					if DEBUG_FORTH_WORDS 
52d2						DMARK "DI8" 
52d2 f5				push af  
52d3 3a e7 52			ld a, (.dmark)  
52d6 32 a6 fd			ld (debug_mark),a  
52d9 3a e8 52			ld a, (.dmark+1)  
52dc 32 a7 fd			ld (debug_mark+1),a  
52df 3a e9 52			ld a, (.dmark+2)  
52e2 32 a8 fd			ld (debug_mark+2),a  
52e5 18 03			jr .pastdmark  
52e7 ..			.dmark: db "DI8"  
52ea f1			.pastdmark: pop af  
52eb			endm  
# End of macro DMARK
52eb						CALLMONITOR 
52eb cd aa fd			call debug_vector  
52ee				endm  
# End of macro CALLMONITOR
52ee					endif 
52ee cd 86 20				call forth_push_str 
52f1			 
52f1			 
52f1				 
52f1					NEXTW 
52f1 c3 c5 23			jp macro_next 
52f4				endm 
# End of macro NEXTW
52f4			.SAVE: 
52f4			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
52f4			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
52f4			;		NEXTW 
52f4			;.LOAD: 
52f4			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
52f4			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
52f4			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
52f4			;; > > The LOAD command can not be used in any user words or compound lines. 
52f4			; 
52f4			;		; store_openext use it. If zero it is EOF 
52f4			; 
52f4			;		; read block from current stream id 
52f4			;		; if the block does not contain zero term keep reading blocks until zero found 
52f4			;		; push the block to stack 
52f4			;		; save the block id to stream 
52f4			; 
52f4			; 
52f4			;		FORTH_DSP_VALUEHL 
52f4			; 
52f4			;;		push hl 
52f4			; 
52f4			;	if DEBUG_STORESE 
52f4			;		DMARK "LOA" 
52f4			;		CALLMONITOR 
52f4			;	endif 
52f4			;		FORTH_DSP_POP 
52f4			; 
52f4			;;		pop hl 
52f4			; 
52f4			;		ld h, l 
52f4			;		ld l, 0 
52f4			; 
52f4			;		push hl     ; stack holds current file id and extent to work with 
52f4			; 
52f4			; 
52f4			;		ld de, store_page      ; get block zero of file 
52f4			;	if DEBUG_STORESE 
52f4			;		DMARK "LO0" 
52f4			;		CALLMONITOR 
52f4			;	endif 
52f4			;		call storage_read 
52f4			; 
52f4			;		ld a, (store_page+2)    ; max extents for this file 
52f4			;		ld  (store_openmaxext),a   ; get our limit 
52f4			; 
52f4			;	if DEBUG_STORESE 
52f4			;		DMARK "LOE" 
52f4			;		CALLMONITOR 
52f4			;	endif 
52f4			; 
52f4			;; TODO dont know why max extents are not present 
52f4			;;		cp 0 
52f4			;;		jp z, .loadeof     ; dont read past eof 
52f4			; 
52f4			;;		ld a, 1   ; start from the head of the file 
52f4			; 
52f4			;.loadline:	pop hl 
52f4			;		inc hl 
52f4			;		ld  a, (store_openmaxext)   ; get our limit 
52f4			;	if DEBUG_STORESE 
52f4			;		DMARK "LOx" 
52f4			;		CALLMONITOR 
52f4			;	endif 
52f4			;		inc a 
52f4			;		cp l 
52f4			;		jp z, .loadeof 
52f4			;		push hl    ; save current extent 
52f4			; 
52f4			;		ld de, store_page 
52f4			; 
52f4			;	if DEBUG_STORESE 
52f4			;		DMARK "LO1" 
52f4			;		CALLMONITOR 
52f4			;	endif 
52f4			;		call storage_read 
52f4			; 
52f4			;	if DEBUG_STORESE 
52f4			;		DMARK "LO2" 
52f4			;		CALLMONITOR 
52f4			;	endif 
52f4			;	call ishlzero 
52f4			;	ld a, l 
52f4			;	add h 
52f4			;	cp 0 
52f4			;	jr z, .loadeof 
52f4			; 
52f4			;	; not eof so hl should point to data to exec 
52f4			; 
52f4			;	; will need to add the FORTH_END_BUFFER flag 
52f4			 ; 
52f4			;	ld hl, store_page+2 
52f4			;	ld bc, 255 
52f4			;	ld a, 0 
52f4			;	cpir 
52f4			;	if DEBUG_STORESE 
52f4			;		DMARK "LOt" 
52f4			;		CALLMONITOR 
52f4			;	endif 
52f4			;	dec hl 
52f4			;	ld a, ' ' 
52f4			;	ld (hl), a 
52f4			;	inc hl 
52f4			;	ld (hl), a 
52f4			;	inc hl 
52f4			;	ld (hl), a 
52f4			;	inc hl 
52f4			;	ld a, FORTH_END_BUFFER 
52f4			;	ld (hl), a 
52f4			; 
52f4			;	; TODO handle more than a single block read 
52f4			; 
52f4			; 
52f4			;	ld hl, store_page+2 
52f4			; 
52f4			;	ld (os_tok_ptr), hl 
52f4			; 
52f4			;	if DEBUG_STORESE 
52f4			;		DMARK "LO3" 
52f4			;		CALLMONITOR 
52f4			;	endif 
52f4			; 
52f4			;	call forthparse 
52f4			;	call forthexec 
52f4			;	call forthexec_cleanup 
52f4			; 
52f4			;	; go to next extent 
52f4			; 
52f4			;	; get next block  or mark as eof 
52f4			;	jp .loadline 
52f4			; 
52f4			; 
52f4			; 
52f4			;	       NEXTW 
52f4			;.loadeof:	ld a, 0 
52f4			;		ld (store_openext), a 
52f4			; 
52f4			;	if DEBUG_STORESE 
52f4			;		DMARK "LOF" 
52f4			;		CALLMONITOR 
52f4			;	endif 
52f4			;		ret 
52f4			;		;NEXTW 
52f4			;.BSAVE:   
52f4			; 
52f4			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
52f4			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
52f4			;		NEXTW 
52f4			;.BLOAD: 
52f4			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
52f4			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
52f4			;		NEXTW 
52f4			;;;; counter gap 
52f4			 
52f4			 
52f4			.SEO: 
52f4				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
52f4 64				db WORD_SYS_CORE+80             
52f5 13 53			dw .SEI            
52f7 04				db 3 + 1 
52f8 .. 00			db "SEO",0              
52fc				endm 
# End of macro CWHEAD
52fc			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
52fc			 
52fc					; get port 
52fc			 
52fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
52fc cd 0f 22			call macro_dsp_valuehl 
52ff				endm 
# End of macro FORTH_DSP_VALUEHL
52ff			 
52ff e5					push hl    ; u2 - byte 
5300			 
5300					; destroy value TOS 
5300			 
5300					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5300 cd c7 22			call macro_forth_dsp_pop 
5303				endm 
# End of macro FORTH_DSP_POP
5303			 
5303					; get byte to send 
5303			 
5303					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5303 cd 0f 22			call macro_dsp_valuehl 
5306				endm 
# End of macro FORTH_DSP_VALUEHL
5306			 
5306 e5					push hl    ; u1 - addr 
5307			 
5307					; destroy value TOS 
5307			 
5307					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5307 cd c7 22			call macro_forth_dsp_pop 
530a				endm 
# End of macro FORTH_DSP_POP
530a			 
530a					; one value on hl get other one back 
530a			 
530a d1					pop de   ; u1 - byte 
530b			 
530b e1					pop hl   ; u2 - addr 
530c			 
530c					; TODO Send SPI byte 
530c			 
530c			 
530c 7b					ld a, e 
530d cd 6a 02				call se_writebyte 
5310			 
5310					 
5310			 
5310					NEXTW 
5310 c3 c5 23			jp macro_next 
5313				endm 
# End of macro NEXTW
5313			 
5313			.SEI: 
5313				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
5313 65				db WORD_SYS_CORE+81             
5314 2d 53			dw .SFREE            
5316 04				db 3 + 1 
5317 .. 00			db "SEI",0              
531b				endm 
# End of macro CWHEAD
531b			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
531b			 
531b					; get port 
531b			 
531b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
531b cd 0f 22			call macro_dsp_valuehl 
531e				endm 
# End of macro FORTH_DSP_VALUEHL
531e			 
531e			;		push hl 
531e			 
531e					; destroy value TOS 
531e			 
531e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
531e cd c7 22			call macro_forth_dsp_pop 
5321				endm 
# End of macro FORTH_DSP_POP
5321			 
5321					; one value on hl get other one back 
5321			 
5321			;		pop hl 
5321			 
5321			 
5321					; TODO Get SPI byte 
5321			 
5321 cd 0c 03				call se_readbyte 
5324			 
5324 26 00				ld h, 0 
5326 6f					ld l, a 
5327 cd 18 20				call forth_push_numhl 
532a			 
532a					NEXTW 
532a c3 c5 23			jp macro_next 
532d				endm 
# End of macro NEXTW
532d			 
532d			.SFREE: 
532d				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
532d 67				db WORD_SYS_CORE+83             
532e 5c 53			dw .SIZE            
5330 06				db 5 + 1 
5331 .. 00			db "FFREE",0              
5337				endm 
# End of macro CWHEAD
5337			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
5337			; | | > [!NOTE] 
5337			; | | > Compatible with PicoSPINet  
5337					if DEBUG_FORTH_WORDS_KEY 
5337						DMARK "FFR" 
5337 f5				push af  
5338 3a 4c 53			ld a, (.dmark)  
533b 32 a6 fd			ld (debug_mark),a  
533e 3a 4d 53			ld a, (.dmark+1)  
5341 32 a7 fd			ld (debug_mark+1),a  
5344 3a 4e 53			ld a, (.dmark+2)  
5347 32 a8 fd			ld (debug_mark+2),a  
534a 18 03			jr .pastdmark  
534c ..			.dmark: db "FFR"  
534f f1			.pastdmark: pop af  
5350			endm  
# End of macro DMARK
5350						CALLMONITOR 
5350 cd aa fd			call debug_vector  
5353				endm  
# End of macro CALLMONITOR
5353					endif 
5353			 
5353 cd 32 08				call storage_freeblocks 
5356			 
5356 cd 18 20				call forth_push_numhl 
5359			 
5359				       NEXTW 
5359 c3 c5 23			jp macro_next 
535c				endm 
# End of macro NEXTW
535c			.SIZE: 
535c				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
535c 67				db WORD_SYS_CORE+83             
535d 90 53			dw .CREATE            
535f 05				db 4 + 1 
5360 .. 00			db "SIZE",0              
5365				endm 
# End of macro CWHEAD
5365			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
5365			; | | > [!NOTE] 
5365			; | | > Compatible with PicoSPINet  
5365					if DEBUG_FORTH_WORDS_KEY 
5365						DMARK "SIZ" 
5365 f5				push af  
5366 3a 7a 53			ld a, (.dmark)  
5369 32 a6 fd			ld (debug_mark),a  
536c 3a 7b 53			ld a, (.dmark+1)  
536f 32 a7 fd			ld (debug_mark+1),a  
5372 3a 7c 53			ld a, (.dmark+2)  
5375 32 a8 fd			ld (debug_mark+2),a  
5378 18 03			jr .pastdmark  
537a ..			.dmark: db "SIZ"  
537d f1			.pastdmark: pop af  
537e			endm  
# End of macro DMARK
537e						CALLMONITOR 
537e cd aa fd			call debug_vector  
5381				endm  
# End of macro CALLMONITOR
5381					endif 
5381			 
5381					FORTH_DSP_VALUEHL 
5381 cd 0f 22			call macro_dsp_valuehl 
5384				endm 
# End of macro FORTH_DSP_VALUEHL
5384			;		push hl 
5384					FORTH_DSP_POP 
5384 cd c7 22			call macro_forth_dsp_pop 
5387				endm 
# End of macro FORTH_DSP_POP
5387			;		pop hl 
5387 cd 94 04				call storage_file_size 
538a			 
538a cd 18 20				call forth_push_numhl 
538d			  
538d			 
538d				       NEXTW 
538d c3 c5 23			jp macro_next 
5390				endm 
# End of macro NEXTW
5390			 
5390			.CREATE: 
5390				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
5390 68				db WORD_SYS_CORE+84             
5391 fe 53			dw .APPEND            
5393 07				db 6 + 1 
5394 .. 00			db "CREATE",0              
539b				endm 
# End of macro CWHEAD
539b			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
539b			; | | e.g.  
539b			; | | TestProgram CREATE 
539b			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
539b			; | |  
539b			; | | Max file IDs are 255. 
539b			; | |  
539b			; | | > [!NOTE] 
539b			; | | > Compatible with PicoSPINet  
539b					 
539b					if DEBUG_FORTH_WORDS_KEY 
539b						DMARK "CRT" 
539b f5				push af  
539c 3a b0 53			ld a, (.dmark)  
539f 32 a6 fd			ld (debug_mark),a  
53a2 3a b1 53			ld a, (.dmark+1)  
53a5 32 a7 fd			ld (debug_mark+1),a  
53a8 3a b2 53			ld a, (.dmark+2)  
53ab 32 a8 fd			ld (debug_mark+2),a  
53ae 18 03			jr .pastdmark  
53b0 ..			.dmark: db "CRT"  
53b3 f1			.pastdmark: pop af  
53b4			endm  
# End of macro DMARK
53b4						CALLMONITOR 
53b4 cd aa fd			call debug_vector  
53b7				endm  
# End of macro CALLMONITOR
53b7					endif 
53b7			;		call storage_get_block_0 
53b7			 
53b7					; TODO pop hl 
53b7			 
53b7					;v5 FORTH_DSP_VALUE 
53b7					FORTH_DSP_VALUE 
53b7 cd f8 21			call macro_forth_dsp_value 
53ba				endm 
# End of macro FORTH_DSP_VALUE
53ba			 
53ba				if DEBUG_STORESE 
53ba					DMARK "CR1" 
53ba f5				push af  
53bb 3a cf 53			ld a, (.dmark)  
53be 32 a6 fd			ld (debug_mark),a  
53c1 3a d0 53			ld a, (.dmark+1)  
53c4 32 a7 fd			ld (debug_mark+1),a  
53c7 3a d1 53			ld a, (.dmark+2)  
53ca 32 a8 fd			ld (debug_mark+2),a  
53cd 18 03			jr .pastdmark  
53cf ..			.dmark: db "CR1"  
53d2 f1			.pastdmark: pop af  
53d3			endm  
# End of macro DMARK
53d3					CALLMONITOR 
53d3 cd aa fd			call debug_vector  
53d6				endm  
# End of macro CALLMONITOR
53d6				endif 
53d6			;		push hl 
53d6			;		FORTH_DSP_POP 
53d6			;		pop hl 
53d6			 
53d6			;		inc hl   ; move past the type marker 
53d6			 
53d6 cd 68 08				call storage_create 
53d9			 
53d9				if DEBUG_STORESE 
53d9					DMARK "CT1" 
53d9 f5				push af  
53da 3a ee 53			ld a, (.dmark)  
53dd 32 a6 fd			ld (debug_mark),a  
53e0 3a ef 53			ld a, (.dmark+1)  
53e3 32 a7 fd			ld (debug_mark+1),a  
53e6 3a f0 53			ld a, (.dmark+2)  
53e9 32 a8 fd			ld (debug_mark+2),a  
53ec 18 03			jr .pastdmark  
53ee ..			.dmark: db "CT1"  
53f1 f1			.pastdmark: pop af  
53f2			endm  
# End of macro DMARK
53f2					CALLMONITOR 
53f2 cd aa fd			call debug_vector  
53f5				endm  
# End of macro CALLMONITOR
53f5				endif 
53f5			;		push hl 
53f5					FORTH_DSP_POP 
53f5 cd c7 22			call macro_forth_dsp_pop 
53f8				endm 
# End of macro FORTH_DSP_POP
53f8			;		pop hl 
53f8					; push file id to stack 
53f8 cd 18 20				call forth_push_numhl 
53fb			 
53fb			 
53fb			 
53fb				       NEXTW 
53fb c3 c5 23			jp macro_next 
53fe				endm 
# End of macro NEXTW
53fe			 
53fe			.APPEND: 
53fe				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
53fe 69				db WORD_SYS_CORE+85             
53ff 8f 54			dw .SDEL            
5401 07				db 6 + 1 
5402 .. 00			db "APPEND",0              
5409				endm 
# End of macro CWHEAD
5409			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
5409			; | | e.g. 
5409			; | | Test CREATE      -> $01 
5409			; | | "A string to add to file" $01 APPEND 
5409			; | |  
5409			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
5409			; | | > [!NOTE] 
5409			; | | > Compatible with PicoSPINet  
5409					if DEBUG_FORTH_WORDS_KEY 
5409						DMARK "APP" 
5409 f5				push af  
540a 3a 1e 54			ld a, (.dmark)  
540d 32 a6 fd			ld (debug_mark),a  
5410 3a 1f 54			ld a, (.dmark+1)  
5413 32 a7 fd			ld (debug_mark+1),a  
5416 3a 20 54			ld a, (.dmark+2)  
5419 32 a8 fd			ld (debug_mark+2),a  
541c 18 03			jr .pastdmark  
541e ..			.dmark: db "APP"  
5421 f1			.pastdmark: pop af  
5422			endm  
# End of macro DMARK
5422						CALLMONITOR 
5422 cd aa fd			call debug_vector  
5425				endm  
# End of macro CALLMONITOR
5425					endif 
5425			 
5425					FORTH_DSP_VALUEHL 
5425 cd 0f 22			call macro_dsp_valuehl 
5428				endm 
# End of macro FORTH_DSP_VALUEHL
5428 e5					push hl 	; save file id 
5429			 
5429				if DEBUG_STORESE 
5429					DMARK "AP1" 
5429 f5				push af  
542a 3a 3e 54			ld a, (.dmark)  
542d 32 a6 fd			ld (debug_mark),a  
5430 3a 3f 54			ld a, (.dmark+1)  
5433 32 a7 fd			ld (debug_mark+1),a  
5436 3a 40 54			ld a, (.dmark+2)  
5439 32 a8 fd			ld (debug_mark+2),a  
543c 18 03			jr .pastdmark  
543e ..			.dmark: db "AP1"  
5441 f1			.pastdmark: pop af  
5442			endm  
# End of macro DMARK
5442					CALLMONITOR 
5442 cd aa fd			call debug_vector  
5445				endm  
# End of macro CALLMONITOR
5445				endif 
5445					FORTH_DSP_POP 
5445 cd c7 22			call macro_forth_dsp_pop 
5448				endm 
# End of macro FORTH_DSP_POP
5448			 
5448					FORTH_DSP_VALUEHL 
5448 cd 0f 22			call macro_dsp_valuehl 
544b				endm 
# End of macro FORTH_DSP_VALUEHL
544b					;v5 FORTH_DSP_VALUE 
544b e5					push hl 	; save ptr to string to save 
544c			 
544c				if DEBUG_STORESE 
544c					DMARK "AP1" 
544c f5				push af  
544d 3a 61 54			ld a, (.dmark)  
5450 32 a6 fd			ld (debug_mark),a  
5453 3a 62 54			ld a, (.dmark+1)  
5456 32 a7 fd			ld (debug_mark+1),a  
5459 3a 63 54			ld a, (.dmark+2)  
545c 32 a8 fd			ld (debug_mark+2),a  
545f 18 03			jr .pastdmark  
5461 ..			.dmark: db "AP1"  
5464 f1			.pastdmark: pop af  
5465			endm  
# End of macro DMARK
5465					CALLMONITOR 
5465 cd aa fd			call debug_vector  
5468				endm  
# End of macro CALLMONITOR
5468				endif 
5468					FORTH_DSP_POP 
5468 cd c7 22			call macro_forth_dsp_pop 
546b				endm 
# End of macro FORTH_DSP_POP
546b			 
546b d1					pop de 
546c e1					pop hl 
546d				if DEBUG_STORESE 
546d					DMARK "AP2" 
546d f5				push af  
546e 3a 82 54			ld a, (.dmark)  
5471 32 a6 fd			ld (debug_mark),a  
5474 3a 83 54			ld a, (.dmark+1)  
5477 32 a7 fd			ld (debug_mark+1),a  
547a 3a 84 54			ld a, (.dmark+2)  
547d 32 a8 fd			ld (debug_mark+2),a  
5480 18 03			jr .pastdmark  
5482 ..			.dmark: db "AP2"  
5485 f1			.pastdmark: pop af  
5486			endm  
# End of macro DMARK
5486					CALLMONITOR 
5486 cd aa fd			call debug_vector  
5489				endm  
# End of macro CALLMONITOR
5489				endif 
5489					;inc de ; skip var type indicator 
5489			 
5489					; TODO how to append numerics???? 
5489			 
5489 cd 55 0b				call storage_append		 
548c			 
548c				       NEXTW 
548c c3 c5 23			jp macro_next 
548f				endm 
# End of macro NEXTW
548f			.SDEL: 
548f				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
548f 6a				db WORD_SYS_CORE+86             
5490 db 54			dw .OPEN            
5492 05				db 4 + 1 
5493 .. 00			db "ERA",0              
5497				endm 
# End of macro CWHEAD
5497			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
5497			; | | > [!NOTE] 
5497			; | | > Compatible with PicoSPINet  
5497					FORTH_DSP_VALUEHL 
5497 cd 0f 22			call macro_dsp_valuehl 
549a				endm 
# End of macro FORTH_DSP_VALUEHL
549a			;		push hl 	; save file id 
549a			 
549a					if DEBUG_FORTH_WORDS_KEY 
549a						DMARK "ERA" 
549a f5				push af  
549b 3a af 54			ld a, (.dmark)  
549e 32 a6 fd			ld (debug_mark),a  
54a1 3a b0 54			ld a, (.dmark+1)  
54a4 32 a7 fd			ld (debug_mark+1),a  
54a7 3a b1 54			ld a, (.dmark+2)  
54aa 32 a8 fd			ld (debug_mark+2),a  
54ad 18 03			jr .pastdmark  
54af ..			.dmark: db "ERA"  
54b2 f1			.pastdmark: pop af  
54b3			endm  
# End of macro DMARK
54b3						CALLMONITOR 
54b3 cd aa fd			call debug_vector  
54b6				endm  
# End of macro CALLMONITOR
54b6					endif 
54b6				if DEBUG_STORESE 
54b6					DMARK "ER1" 
54b6 f5				push af  
54b7 3a cb 54			ld a, (.dmark)  
54ba 32 a6 fd			ld (debug_mark),a  
54bd 3a cc 54			ld a, (.dmark+1)  
54c0 32 a7 fd			ld (debug_mark+1),a  
54c3 3a cd 54			ld a, (.dmark+2)  
54c6 32 a8 fd			ld (debug_mark+2),a  
54c9 18 03			jr .pastdmark  
54cb ..			.dmark: db "ER1"  
54ce f1			.pastdmark: pop af  
54cf			endm  
# End of macro DMARK
54cf					CALLMONITOR 
54cf cd aa fd			call debug_vector  
54d2				endm  
# End of macro CALLMONITOR
54d2				endif 
54d2					FORTH_DSP_POP 
54d2 cd c7 22			call macro_forth_dsp_pop 
54d5				endm 
# End of macro FORTH_DSP_POP
54d5			 
54d5			;		pop hl 
54d5			 
54d5 cd a7 06				call storage_erase 
54d8				       NEXTW 
54d8 c3 c5 23			jp macro_next 
54db				endm 
# End of macro NEXTW
54db			 
54db			.OPEN: 
54db				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
54db 6b				db WORD_SYS_CORE+87             
54dc 6f 55			dw .READ            
54de 05				db 4 + 1 
54df .. 00			db "OPEN",0              
54e4				endm 
# End of macro CWHEAD
54e4			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
54e4			; | | e.g. 
54e4			; | | $01 OPEN $01 DO $01 READ . LOOP 
54e4			; | | 
54e4			; | | Will return with 255 blocks if the file does not exist 
54e4			; | | > [!NOTE] 
54e4			; | | > Compatible with PicoSPINet  
54e4			 
54e4					if DEBUG_FORTH_WORDS_KEY 
54e4						DMARK "OPN" 
54e4 f5				push af  
54e5 3a f9 54			ld a, (.dmark)  
54e8 32 a6 fd			ld (debug_mark),a  
54eb 3a fa 54			ld a, (.dmark+1)  
54ee 32 a7 fd			ld (debug_mark+1),a  
54f1 3a fb 54			ld a, (.dmark+2)  
54f4 32 a8 fd			ld (debug_mark+2),a  
54f7 18 03			jr .pastdmark  
54f9 ..			.dmark: db "OPN"  
54fc f1			.pastdmark: pop af  
54fd			endm  
# End of macro DMARK
54fd						CALLMONITOR 
54fd cd aa fd			call debug_vector  
5500				endm  
# End of macro CALLMONITOR
5500					endif 
5500					; TODO handle multiple file opens 
5500			 
5500 3e 01			       	ld a, 1 
5502 32 a5 f9				ld (store_openext), a 
5505			 
5505					; get max extents for this file 
5505				 
5505								 
5505					FORTH_DSP_VALUEHL 
5505 cd 0f 22			call macro_dsp_valuehl 
5508				endm 
# End of macro FORTH_DSP_VALUEHL
5508			 
5508 65					ld h, l 
5509 2e 00				ld l, 0 
550b			 
550b					; store file id 
550b			 
550b 7c					ld a, h 
550c 32 a2 f9				ld (store_filecache), a 
550f			 
550f				if DEBUG_STORESE 
550f					DMARK "OPN" 
550f f5				push af  
5510 3a 24 55			ld a, (.dmark)  
5513 32 a6 fd			ld (debug_mark),a  
5516 3a 25 55			ld a, (.dmark+1)  
5519 32 a7 fd			ld (debug_mark+1),a  
551c 3a 26 55			ld a, (.dmark+2)  
551f 32 a8 fd			ld (debug_mark+2),a  
5522 18 03			jr .pastdmark  
5524 ..			.dmark: db "OPN"  
5527 f1			.pastdmark: pop af  
5528			endm  
# End of macro DMARK
5528					CALLMONITOR 
5528 cd aa fd			call debug_vector  
552b				endm  
# End of macro CALLMONITOR
552b				endif 
552b			;		push hl 
552b					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
552b cd c7 22			call macro_forth_dsp_pop 
552e				endm 
# End of macro FORTH_DSP_POP
552e			;		pop hl 
552e						 
552e 11 b5 f9				ld de, store_page      ; get block zero of file 
5531 cd be 09				call storage_read 
5534 cd f8 0f			call ishlzero 
5537 20 04			jr nz, .opfound 
5539			 
5539				; file does not exist so indicate with 255 extents in use 
5539			 
5539 3e ff			ld a, 255 
553b 18 29			jr .skipopeneof 
553d			 
553d			 
553d			.opfound: 
553d			 
553d			 
553d 3a b7 f9				ld a, (store_page+2)    ; max extents for this file 
5540 32 a4 f9				ld  (store_openmaxext), a   ; get our limit and push 
5543					 
5543				if DEBUG_STORESE 
5543					DMARK "OPx" 
5543 f5				push af  
5544 3a 58 55			ld a, (.dmark)  
5547 32 a6 fd			ld (debug_mark),a  
554a 3a 59 55			ld a, (.dmark+1)  
554d 32 a7 fd			ld (debug_mark+1),a  
5550 3a 5a 55			ld a, (.dmark+2)  
5553 32 a8 fd			ld (debug_mark+2),a  
5556 18 03			jr .pastdmark  
5558 ..			.dmark: db "OPx"  
555b f1			.pastdmark: pop af  
555c			endm  
# End of macro DMARK
555c					CALLMONITOR 
555c cd aa fd			call debug_vector  
555f				endm  
# End of macro CALLMONITOR
555f				endif 
555f fe 00				cp 0 
5561 20 03				jr nz, .skipopeneof 
5563					; have opened an empty file 
5563					 
5563 32 a5 f9				ld (store_openext), a 
5566			 
5566			.skipopeneof: 
5566			 
5566 6f					ld l, a 
5567 26 00				ld h, 0 
5569 cd 18 20				call forth_push_numhl 
556c			 
556c			 
556c				       NEXTW 
556c c3 c5 23			jp macro_next 
556f				endm 
# End of macro NEXTW
556f			.READ: 
556f				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
556f 6c				db WORD_SYS_CORE+88             
5570 99 56			dw .EOF            
5572 05				db 4 + 1 
5573 .. 00			db "READ",0              
5578				endm 
# End of macro CWHEAD
5578			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
5578			; | | e.g. 
5578			; | | $01 OPEN $01 DO READ . LOOP 
5578			; | | 
5578			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
5578			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
5578			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
5578			; | | two bytes contain the file id and extent. 
5578			; | |  
5578			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
5578			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
5578			; | | > [!NOTE] 
5578			; | | > Compatible with PicoSPINet  
5578			 
5578					if DEBUG_FORTH_WORDS_KEY 
5578						DMARK "REA" 
5578 f5				push af  
5579 3a 8d 55			ld a, (.dmark)  
557c 32 a6 fd			ld (debug_mark),a  
557f 3a 8e 55			ld a, (.dmark+1)  
5582 32 a7 fd			ld (debug_mark+1),a  
5585 3a 8f 55			ld a, (.dmark+2)  
5588 32 a8 fd			ld (debug_mark+2),a  
558b 18 03			jr .pastdmark  
558d ..			.dmark: db "REA"  
5590 f1			.pastdmark: pop af  
5591			endm  
# End of macro DMARK
5591						CALLMONITOR 
5591 cd aa fd			call debug_vector  
5594				endm  
# End of macro CALLMONITOR
5594					endif 
5594					; store_openext use it. If zero it is EOF 
5594			 
5594					; read block from current stream id 
5594					; if the block does not contain zero term keep reading blocks until zero found 
5594					; push the block to stack 
5594					; save the block id to stream 
5594			 
5594			 
5594 cd c6 56				call .testeof 
5597 3e 01				ld a, 1 
5599 bd					cp l 
559a ca 75 56				jp z, .ateof 
559d			 
559d			 
559d			;		FORTH_DSP_VALUEHL 
559d			 
559d			;		push hl 
559d			 
559d			;	if DEBUG_STORESE 
559d			;		DMARK "REA" 
559d			;		CALLMONITOR 
559d			;	endif 
559d			;		FORTH_DSP_POP 
559d			 
559d			;		pop hl 
559d				 
559d 3a a2 f9				ld a, (store_filecache) 
55a0 67					ld h,a 
55a1			 
55a1 3a a5 f9				ld a, (store_openext) 
55a4 6f					ld l, a 
55a5					 
55a5 fe 00				cp 0 
55a7 ca 75 56				jp z, .ateof     ; dont read past eof 
55aa			 
55aa cd a1 0c				call storage_clear_page 
55ad			 
55ad 11 b5 f9				ld de, store_page 
55b0				if DEBUG_STORESE 
55b0					DMARK "RE1" 
55b0 f5				push af  
55b1 3a c5 55			ld a, (.dmark)  
55b4 32 a6 fd			ld (debug_mark),a  
55b7 3a c6 55			ld a, (.dmark+1)  
55ba 32 a7 fd			ld (debug_mark+1),a  
55bd 3a c7 55			ld a, (.dmark+2)  
55c0 32 a8 fd			ld (debug_mark+2),a  
55c3 18 03			jr .pastdmark  
55c5 ..			.dmark: db "RE1"  
55c8 f1			.pastdmark: pop af  
55c9			endm  
# End of macro DMARK
55c9					CALLMONITOR 
55c9 cd aa fd			call debug_vector  
55cc				endm  
# End of macro CALLMONITOR
55cc				endif 
55cc cd be 09				call storage_read 
55cf			 
55cf				if DEBUG_STORESE 
55cf					DMARK "RE2" 
55cf f5				push af  
55d0 3a e4 55			ld a, (.dmark)  
55d3 32 a6 fd			ld (debug_mark),a  
55d6 3a e5 55			ld a, (.dmark+1)  
55d9 32 a7 fd			ld (debug_mark+1),a  
55dc 3a e6 55			ld a, (.dmark+2)  
55df 32 a8 fd			ld (debug_mark+2),a  
55e2 18 03			jr .pastdmark  
55e4 ..			.dmark: db "RE2"  
55e7 f1			.pastdmark: pop af  
55e8			endm  
# End of macro DMARK
55e8					CALLMONITOR 
55e8 cd aa fd			call debug_vector  
55eb				endm  
# End of macro CALLMONITOR
55eb				endif 
55eb cd f8 0f			call ishlzero 
55ee			;	ld a, l 
55ee			;	add h 
55ee			;	cp 0 
55ee ca 75 56			jp z, .readeof 
55f1			 
55f1				; not eof so hl should point to data to push to stack 
55f1			 
55f1				if DEBUG_STORESE 
55f1					DMARK "RE3" 
55f1 f5				push af  
55f2 3a 06 56			ld a, (.dmark)  
55f5 32 a6 fd			ld (debug_mark),a  
55f8 3a 07 56			ld a, (.dmark+1)  
55fb 32 a7 fd			ld (debug_mark+1),a  
55fe 3a 08 56			ld a, (.dmark+2)  
5601 32 a8 fd			ld (debug_mark+2),a  
5604 18 03			jr .pastdmark  
5606 ..			.dmark: db "RE3"  
5609 f1			.pastdmark: pop af  
560a			endm  
# End of macro DMARK
560a					CALLMONITOR 
560a cd aa fd			call debug_vector  
560d				endm  
# End of macro CALLMONITOR
560d				endif 
560d cd 86 20			call forth_push_str 
5610			 
5610				if DEBUG_STORESE 
5610					DMARK "RE4" 
5610 f5				push af  
5611 3a 25 56			ld a, (.dmark)  
5614 32 a6 fd			ld (debug_mark),a  
5617 3a 26 56			ld a, (.dmark+1)  
561a 32 a7 fd			ld (debug_mark+1),a  
561d 3a 27 56			ld a, (.dmark+2)  
5620 32 a8 fd			ld (debug_mark+2),a  
5623 18 03			jr .pastdmark  
5625 ..			.dmark: db "RE4"  
5628 f1			.pastdmark: pop af  
5629			endm  
# End of macro DMARK
5629					CALLMONITOR 
5629 cd aa fd			call debug_vector  
562c				endm  
# End of macro CALLMONITOR
562c				endif 
562c				; get next block  or mark as eof 
562c			 
562c 3a a4 f9			ld a, (store_openmaxext)   ; get our limit 
562f 4f				ld c, a	 
5630 3a a5 f9			ld a, (store_openext) 
5633			 
5633				if DEBUG_STORESE 
5633					DMARK "RE5" 
5633 f5				push af  
5634 3a 48 56			ld a, (.dmark)  
5637 32 a6 fd			ld (debug_mark),a  
563a 3a 49 56			ld a, (.dmark+1)  
563d 32 a7 fd			ld (debug_mark+1),a  
5640 3a 4a 56			ld a, (.dmark+2)  
5643 32 a8 fd			ld (debug_mark+2),a  
5646 18 03			jr .pastdmark  
5648 ..			.dmark: db "RE5"  
564b f1			.pastdmark: pop af  
564c			endm  
# End of macro DMARK
564c					CALLMONITOR 
564c cd aa fd			call debug_vector  
564f				endm  
# End of macro CALLMONITOR
564f				endif 
564f b9				cp c 
5650 28 23			jr z, .readeof     ; at last extent 
5652			 
5652 3c					inc a 
5653 32 a5 f9				ld (store_openext), a 
5656			 
5656				if DEBUG_STORESE 
5656					DMARK "RE6" 
5656 f5				push af  
5657 3a 6b 56			ld a, (.dmark)  
565a 32 a6 fd			ld (debug_mark),a  
565d 3a 6c 56			ld a, (.dmark+1)  
5660 32 a7 fd			ld (debug_mark+1),a  
5663 3a 6d 56			ld a, (.dmark+2)  
5666 32 a8 fd			ld (debug_mark+2),a  
5669 18 03			jr .pastdmark  
566b ..			.dmark: db "RE6"  
566e f1			.pastdmark: pop af  
566f			endm  
# End of macro DMARK
566f					CALLMONITOR 
566f cd aa fd			call debug_vector  
5672				endm  
# End of macro CALLMONITOR
5672				endif 
5672			 
5672			 
5672				       NEXTW 
5672 c3 c5 23			jp macro_next 
5675				endm 
# End of macro NEXTW
5675			.ateof: 
5675				;	ld hl, .showeof 
5675				;	call forth_push_str 
5675 3e 00		.readeof:	ld a, 0 
5677 32 a5 f9				ld (store_openext), a 
567a			 
567a					 
567a				if DEBUG_STORESE 
567a					DMARK "REF" 
567a f5				push af  
567b 3a 8f 56			ld a, (.dmark)  
567e 32 a6 fd			ld (debug_mark),a  
5681 3a 90 56			ld a, (.dmark+1)  
5684 32 a7 fd			ld (debug_mark+1),a  
5687 3a 91 56			ld a, (.dmark+2)  
568a 32 a8 fd			ld (debug_mark+2),a  
568d 18 03			jr .pastdmark  
568f ..			.dmark: db "REF"  
5692 f1			.pastdmark: pop af  
5693			endm  
# End of macro DMARK
5693					CALLMONITOR 
5693 cd aa fd			call debug_vector  
5696				endm  
# End of macro CALLMONITOR
5696				endif 
5696				       NEXTW 
5696 c3 c5 23			jp macro_next 
5699				endm 
# End of macro NEXTW
5699			 
5699			;.showeof:   db "eof", 0 
5699			 
5699			 
5699			.EOF: 
5699				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
5699 6d				db WORD_SYS_CORE+89             
569a db 56			dw .FORMAT            
569c 04				db 3 + 1 
569d .. 00			db "EOF",0              
56a1				endm 
# End of macro CWHEAD
56a1			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
56a1			; | | e.g. 
56a1			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
56a1			; | | > [!NOTE] 
56a1			; | | > Compatible with PicoSPINet  
56a1					; TODO if current block id for stream is zero then push true else false 
56a1			 
56a1					if DEBUG_FORTH_WORDS_KEY 
56a1						DMARK "EOF" 
56a1 f5				push af  
56a2 3a b6 56			ld a, (.dmark)  
56a5 32 a6 fd			ld (debug_mark),a  
56a8 3a b7 56			ld a, (.dmark+1)  
56ab 32 a7 fd			ld (debug_mark+1),a  
56ae 3a b8 56			ld a, (.dmark+2)  
56b1 32 a8 fd			ld (debug_mark+2),a  
56b4 18 03			jr .pastdmark  
56b6 ..			.dmark: db "EOF"  
56b9 f1			.pastdmark: pop af  
56ba			endm  
# End of macro DMARK
56ba						CALLMONITOR 
56ba cd aa fd			call debug_vector  
56bd				endm  
# End of macro CALLMONITOR
56bd					endif 
56bd			 
56bd					; TODO handlue multiple file streams 
56bd			 
56bd			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
56bd cd c6 56				call .testeof 
56c0 cd 18 20				call forth_push_numhl 
56c3			 
56c3			 
56c3				       NEXTW 
56c3 c3 c5 23			jp macro_next 
56c6				endm 
# End of macro NEXTW
56c6			 
56c6			.testeof: 
56c6 2e 01				ld l, 1 
56c8 3a a4 f9				ld a, (store_openmaxext) 
56cb fe 00				cp 0 
56cd 28 09				jr  z, .eofdone   ; empty file 
56cf 3a a5 f9				ld a, (store_openext) 
56d2 fe 00				cp 0 
56d4 28 02				jr  z, .eofdone 
56d6 2e 00				ld l, 0 
56d8 26 00		.eofdone:	ld h, 0 
56da c9					ret 
56db			 
56db			 
56db			 
56db			 
56db			.FORMAT: 
56db				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
56db 6d				db WORD_SYS_CORE+89             
56dc 2c 57			dw .LABEL            
56de 07				db 6 + 1 
56df .. 00			db "FORMAT",0              
56e6				endm 
# End of macro CWHEAD
56e6			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
56e6			; | | > [!NOTE] 
56e6			; | | > Compatible with PicoSPINet  
56e6					; TODO if current block id for stream is zero then push true else false 
56e6				 
56e6				if DEBUG_STORESE 
56e6					DMARK "FOR" 
56e6 f5				push af  
56e7 3a fb 56			ld a, (.dmark)  
56ea 32 a6 fd			ld (debug_mark),a  
56ed 3a fc 56			ld a, (.dmark+1)  
56f0 32 a7 fd			ld (debug_mark+1),a  
56f3 3a fd 56			ld a, (.dmark+2)  
56f6 32 a8 fd			ld (debug_mark+2),a  
56f9 18 03			jr .pastdmark  
56fb ..			.dmark: db "FOR"  
56fe f1			.pastdmark: pop af  
56ff			endm  
# End of macro DMARK
56ff					CALLMONITOR 
56ff cd aa fd			call debug_vector  
5702				endm  
# End of macro CALLMONITOR
5702				endif 
5702					; Wipes the bank check flags to cause a reformat on next block 0 read 
5702			 
5702 21 01 00				ld hl, 1 
5705 3e 00				ld a, 0 
5707 cd 6a 02				call se_writebyte 
570a			 
570a				if DEBUG_STORESE 
570a					DMARK "FO0" 
570a f5				push af  
570b 3a 1f 57			ld a, (.dmark)  
570e 32 a6 fd			ld (debug_mark),a  
5711 3a 20 57			ld a, (.dmark+1)  
5714 32 a7 fd			ld (debug_mark+1),a  
5717 3a 21 57			ld a, (.dmark+2)  
571a 32 a8 fd			ld (debug_mark+2),a  
571d 18 03			jr .pastdmark  
571f ..			.dmark: db "FO0"  
5722 f1			.pastdmark: pop af  
5723			endm  
# End of macro DMARK
5723					CALLMONITOR 
5723 cd aa fd			call debug_vector  
5726				endm  
# End of macro CALLMONITOR
5726				endif 
5726					; force bank init 
5726			 
5726 cd 16 05				call storage_get_block_0 
5729					 
5729				       NEXTW 
5729 c3 c5 23			jp macro_next 
572c				endm 
# End of macro NEXTW
572c			.LABEL: 
572c				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
572c 6d				db WORD_SYS_CORE+89             
572d 7a 57			dw .STOREPAGE            
572f 06				db 5 + 1 
5730 .. 00			db "LABEL",0              
5736				endm 
# End of macro CWHEAD
5736			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5736			; | | > [!NOTE] 
5736			; | | > Compatible with PicoSPINet  
5736					; TODO test to see if bank is selected 
5736				 
5736					if DEBUG_FORTH_WORDS_KEY 
5736						DMARK "LBL" 
5736 f5				push af  
5737 3a 4b 57			ld a, (.dmark)  
573a 32 a6 fd			ld (debug_mark),a  
573d 3a 4c 57			ld a, (.dmark+1)  
5740 32 a7 fd			ld (debug_mark+1),a  
5743 3a 4d 57			ld a, (.dmark+2)  
5746 32 a8 fd			ld (debug_mark+2),a  
5749 18 03			jr .pastdmark  
574b ..			.dmark: db "LBL"  
574e f1			.pastdmark: pop af  
574f			endm  
# End of macro DMARK
574f						CALLMONITOR 
574f cd aa fd			call debug_vector  
5752				endm  
# End of macro CALLMONITOR
5752					endif 
5752			;	if DEBUG_STORESE 
5752			;		DMARK "LBL" 
5752			;		CALLMONITOR 
5752			;	endif 
5752					FORTH_DSP_VALUEHL 
5752 cd 0f 22			call macro_dsp_valuehl 
5755				endm 
# End of macro FORTH_DSP_VALUEHL
5755					;v5FORTH_DSP_VALUE 
5755					 
5755			;		push hl 
5755					FORTH_DSP_POP 
5755 cd c7 22			call macro_forth_dsp_pop 
5758				endm 
# End of macro FORTH_DSP_POP
5758			;		pop hl 
5758			 
5758			;v5		inc hl   ; move past the type marker 
5758			 
5758				if DEBUG_STORESE 
5758					DMARK "LBl" 
5758 f5				push af  
5759 3a 6d 57			ld a, (.dmark)  
575c 32 a6 fd			ld (debug_mark),a  
575f 3a 6e 57			ld a, (.dmark+1)  
5762 32 a7 fd			ld (debug_mark+1),a  
5765 3a 6f 57			ld a, (.dmark+2)  
5768 32 a8 fd			ld (debug_mark+2),a  
576b 18 03			jr .pastdmark  
576d ..			.dmark: db "LBl"  
5770 f1			.pastdmark: pop af  
5771			endm  
# End of macro DMARK
5771					CALLMONITOR 
5771 cd aa fd			call debug_vector  
5774				endm  
# End of macro CALLMONITOR
5774				endif 
5774 cd 3a 06				call storage_label 
5777			 
5777				       NEXTW 
5777 c3 c5 23			jp macro_next 
577a				endm 
# End of macro NEXTW
577a			.STOREPAGE: 
577a				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
577a 6d				db WORD_SYS_CORE+89             
577b ad 57			dw .LABELS            
577d 0a				db 9 + 1 
577e .. 00			db "STOREPAGE",0              
5788				endm 
# End of macro CWHEAD
5788			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5788			; | | > [!NOTE] 
5788			; | | > Compatible with PicoSPINet  
5788					; TODO test to see if bank is selected 
5788				 
5788					if DEBUG_FORTH_WORDS_KEY 
5788						DMARK "STP" 
5788 f5				push af  
5789 3a 9d 57			ld a, (.dmark)  
578c 32 a6 fd			ld (debug_mark),a  
578f 3a 9e 57			ld a, (.dmark+1)  
5792 32 a7 fd			ld (debug_mark+1),a  
5795 3a 9f 57			ld a, (.dmark+2)  
5798 32 a8 fd			ld (debug_mark+2),a  
579b 18 03			jr .pastdmark  
579d ..			.dmark: db "STP"  
57a0 f1			.pastdmark: pop af  
57a1			endm  
# End of macro DMARK
57a1						CALLMONITOR 
57a1 cd aa fd			call debug_vector  
57a4				endm  
# End of macro CALLMONITOR
57a4					endif 
57a4			;	if DEBUG_STORESE 
57a4			;		DMARK "STP" 
57a4			;		CALLMONITOR 
57a4			;	endif 
57a4			 
57a4 21 b5 f9			ld hl, store_page 
57a7 cd 18 20			call forth_push_numhl 
57aa			 
57aa			 
57aa				       NEXTW 
57aa c3 c5 23			jp macro_next 
57ad				endm 
# End of macro NEXTW
57ad			.LABELS: 
57ad				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
57ad 6d				db WORD_SYS_CORE+89             
57ae 37 58			dw .SCONST1            
57b0 07				db 6 + 1 
57b1 .. 00			db "LABELS",0              
57b8				endm 
# End of macro CWHEAD
57b8			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | DONE 
57b8			; | | > [!CAUTION] 
57b8			; | | > *NOT* Compatible with PicoSPINet  
57b8					;  
57b8			 
57b8					; save the current device selected to restore afterwards 
57b8				 
57b8 3a 9b f9				ld a, (spi_device) 
57bb f5					push af 
57bc			 
57bc			 
57bc					; run through each of the banks 
57bc			 
57bc 21 01 00				ld hl, 1 
57bf cd 18 20				call forth_push_numhl 
57c2 3e ff				ld a, SPI_CE_HIGH 
57c4 cb 87				res SPI_CE0, a 
57c6 32 9b f9				ld (spi_device), a 
57c9 cd 16 05				call storage_get_block_0 
57cc 21 b8 f9				ld hl, store_page+3 
57cf cd 86 20				call forth_push_str 
57d2			 
57d2					 
57d2 21 02 00				ld hl, 2 
57d5 cd 18 20				call forth_push_numhl 
57d8 3e ff				ld a, SPI_CE_HIGH 
57da cb 8f				res SPI_CE1, a 
57dc 32 9b f9				ld (spi_device), a 
57df cd 16 05				call storage_get_block_0 
57e2 21 b8 f9				ld hl, store_page+3 
57e5 cd 86 20				call forth_push_str 
57e8			 
57e8					 
57e8 21 03 00				ld hl, 3 
57eb cd 18 20				call forth_push_numhl 
57ee 3e ff				ld a, SPI_CE_HIGH 
57f0 cb 97				res SPI_CE2, a 
57f2 32 9b f9				ld (spi_device), a 
57f5 cd 16 05				call storage_get_block_0 
57f8 21 b8 f9				ld hl, store_page+3 
57fb cd 86 20				call forth_push_str 
57fe			 
57fe			 
57fe 21 04 00				ld hl, 4 
5801 cd 18 20				call forth_push_numhl 
5804 3e ff				ld a, SPI_CE_HIGH 
5806 cb 9f				res SPI_CE3, a 
5808 32 9b f9				ld (spi_device), a 
580b cd 16 05				call storage_get_block_0 
580e 21 b8 f9				ld hl, store_page+3 
5811 cd 86 20				call forth_push_str 
5814			 
5814					 
5814			 
5814 21 05 00				ld hl, 5 
5817 cd 18 20				call forth_push_numhl 
581a 3e ff				ld a, SPI_CE_HIGH 
581c cb a7				res SPI_CE4, a 
581e 32 9b f9				ld (spi_device), a 
5821 cd 16 05				call storage_get_block_0 
5824 21 b8 f9				ld hl, store_page+3 
5827 cd 86 20				call forth_push_str 
582a			 
582a					 
582a					; push fixed count of storage devices (on board) for now 
582a			 
582a 21 05 00				ld hl, 5 
582d cd 18 20				call forth_push_numhl 
5830			 
5830					; restore selected device  
5830				 
5830 f1					pop af 
5831 32 9b f9				ld (spi_device), a 
5834			 
5834				       NEXTW 
5834 c3 c5 23			jp macro_next 
5837				endm 
# End of macro NEXTW
5837			 
5837			.SCONST1: 
5837				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5837 6d				db WORD_SYS_CORE+89             
5838 4e 58			dw .SCONST2            
583a 07				db 6 + 1 
583b .. 00			db "FILEID",0              
5842				endm 
# End of macro CWHEAD
5842			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5842			; | | > [!NOTE] 
5842			; | | > Compatible with PicoSPINet  
5842 3a a2 f9				ld a, (store_filecache) 
5845 26 00				ld h, 0 
5847 6f					ld l, a 
5848 cd 18 20				call forth_push_numhl 
584b					NEXTW 
584b c3 c5 23			jp macro_next 
584e				endm 
# End of macro NEXTW
584e			.SCONST2: 
584e				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
584e 6d				db WORD_SYS_CORE+89             
584f 66 58			dw .SCONST3            
5851 08				db 7 + 1 
5852 .. 00			db "FILEEXT",0              
585a				endm 
# End of macro CWHEAD
585a			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
585a			; | | > [!NOTE] 
585a			; | | > Compatible with PicoSPINet  
585a 3a a5 f9				ld a, (store_openext) 
585d 26 00				ld h, 0 
585f 6f					ld l, a 
5860 cd 18 20				call forth_push_numhl 
5863					NEXTW 
5863 c3 c5 23			jp macro_next 
5866				endm 
# End of macro NEXTW
5866			.SCONST3: 
5866				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5866 6d				db WORD_SYS_CORE+89             
5867 7e 58			dw .SCONST4            
5869 08				db 7 + 1 
586a .. 00			db "FILEMAX",0              
5872				endm 
# End of macro CWHEAD
5872			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
5872			; | | > [!NOTE] 
5872			; | | > Compatible with PicoSPINet  
5872 3a a4 f9				ld a, (store_openmaxext) 
5875 26 00				ld h, 0 
5877 6f					ld l, a 
5878 cd 18 20				call forth_push_numhl 
587b					NEXTW 
587b c3 c5 23			jp macro_next 
587e				endm 
# End of macro NEXTW
587e			.SCONST4: 
587e				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
587e 6d				db WORD_SYS_CORE+89             
587f 94 58			dw .SCONST5            
5881 09				db 8 + 1 
5882 .. 00			db "FILEADDR",0              
588b				endm 
# End of macro CWHEAD
588b			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currently open file to stack | DONE 
588b			; | | > [!NOTE] 
588b			; | | > Compatible with PicoSPINet  
588b 2a a6 f9				ld hl, (store_openaddr) 
588e cd 18 20				call forth_push_numhl 
5891					NEXTW 
5891 c3 c5 23			jp macro_next 
5894				endm 
# End of macro NEXTW
5894			.SCONST5: 
5894				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
5894 6d				db WORD_SYS_CORE+89             
5895 b5 58			dw .SCONST6            
5897 09				db 8 + 1 
5898 .. 00			db "FILEPAGE",0              
58a1				endm 
# End of macro CWHEAD
58a1			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
58a1			; | | > [!NOTE] 
58a1			; | | > Compatible with PicoSPINet  
58a1 2a a6 f9				ld hl, (store_openaddr) 
58a4 e5					push hl 
58a5 c1					pop bc 
58a6 16 00				ld d, 0 
58a8 1e 40				ld e, STORE_BLOCK_PHY 
58aa cd 2c 0f				call Div16 
58ad c5					push bc 
58ae e1					pop hl 
58af cd 18 20				call forth_push_numhl 
58b2					NEXTW 
58b2 c3 c5 23			jp macro_next 
58b5				endm 
# End of macro NEXTW
58b5			.SCONST6: 
58b5				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
58b5 6d				db WORD_SYS_CORE+89             
58b6 ce 58			dw .ENDSTORAGE            
58b8 09				db 8 + 1 
58b9 .. 00			db "READCONT",0              
58c2				endm 
# End of macro CWHEAD
58c2			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
58c2			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
58c2			; | | a further read should, if applicable, be CONCAT to the previous read. 
58c2			; | | > [!NOTE] 
58c2			; | | > Compatible with PicoSPINet  
58c2 3a a8 f9				ld a, (store_readcont) 
58c5 26 00				ld h, 0 
58c7 6f					ld l, a 
58c8 cd 18 20				call forth_push_numhl 
58cb					NEXTW 
58cb c3 c5 23			jp macro_next 
58ce				endm 
# End of macro NEXTW
58ce			.ENDSTORAGE: 
58ce			; eof 
# End of file forth_words_storage.asm
58ce			endif 
58ce				include "forth_words_device.asm" 
58ce			; Device related words 
58ce			 
58ce			; | ## Device Words 
58ce			 
58ce			;if SOUND_ENABLE 
58ce			;.NOTE: 
58ce			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
58ce			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
58ce			;		if DEBUG_FORTH_WORDS_KEY 
58ce			;			DMARK "NTE" 
58ce			;			CALLMONITOR 
58ce			;		endif 
58ce			; 
58ce			;	 
58ce			; 
58ce			;		NEXTW 
58ce			;.AFTERSOUND: 
58ce			;endif 
58ce			 
58ce			 
58ce			USE_GPIO: equ 0 
58ce			 
58ce			if USE_GPIO 
58ce			.GP1: 
58ce				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
58ce			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
58ce					NEXTW 
58ce			.GP2: 
58ce				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
58ce			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
58ce			 
58ce					NEXTW 
58ce			 
58ce			.GP3: 
58ce				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
58ce			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
58ce			 
58ce					NEXTW 
58ce			 
58ce			.GP4: 
58ce				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
58ce			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
58ce			 
58ce					NEXTW 
58ce			.SIN: 
58ce			 
58ce			 
58ce			endif 
58ce			 
58ce			 
58ce				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
58ce 33				db WORD_SYS_CORE+31             
58cf 03 59			dw .SOUT            
58d1 03				db 2 + 1 
58d2 .. 00			db "IN",0              
58d5				endm 
# End of macro CWHEAD
58d5			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
58d5					if DEBUG_FORTH_WORDS_KEY 
58d5						DMARK "IN." 
58d5 f5				push af  
58d6 3a ea 58			ld a, (.dmark)  
58d9 32 a6 fd			ld (debug_mark),a  
58dc 3a eb 58			ld a, (.dmark+1)  
58df 32 a7 fd			ld (debug_mark+1),a  
58e2 3a ec 58			ld a, (.dmark+2)  
58e5 32 a8 fd			ld (debug_mark+2),a  
58e8 18 03			jr .pastdmark  
58ea ..			.dmark: db "IN."  
58ed f1			.pastdmark: pop af  
58ee			endm  
# End of macro DMARK
58ee						CALLMONITOR 
58ee cd aa fd			call debug_vector  
58f1				endm  
# End of macro CALLMONITOR
58f1					endif 
58f1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
58f1 cd 0f 22			call macro_dsp_valuehl 
58f4				endm 
# End of macro FORTH_DSP_VALUEHL
58f4			 
58f4 e5					push hl 
58f5			 
58f5					; destroy value TOS 
58f5			 
58f5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
58f5 cd c7 22			call macro_forth_dsp_pop 
58f8				endm 
# End of macro FORTH_DSP_POP
58f8			 
58f8					; one value on hl get other one back 
58f8			 
58f8 c1					pop bc 
58f9			 
58f9					; do the sub 
58f9			;		ex de, hl 
58f9			 
58f9 ed 68				in l,(c) 
58fb			 
58fb					; save it 
58fb			 
58fb 26 00				ld h,0 
58fd			 
58fd					; TODO push value back onto stack for another op etc 
58fd			 
58fd cd 18 20				call forth_push_numhl 
5900					NEXTW 
5900 c3 c5 23			jp macro_next 
5903				endm 
# End of macro NEXTW
5903			.SOUT: 
5903				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5903 34				db WORD_SYS_CORE+32             
5904 56 59			dw .SPIO            
5906 04				db 3 + 1 
5907 .. 00			db "OUT",0              
590b				endm 
# End of macro CWHEAD
590b			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
590b					if DEBUG_FORTH_WORDS_KEY 
590b						DMARK "OUT" 
590b f5				push af  
590c 3a 20 59			ld a, (.dmark)  
590f 32 a6 fd			ld (debug_mark),a  
5912 3a 21 59			ld a, (.dmark+1)  
5915 32 a7 fd			ld (debug_mark+1),a  
5918 3a 22 59			ld a, (.dmark+2)  
591b 32 a8 fd			ld (debug_mark+2),a  
591e 18 03			jr .pastdmark  
5920 ..			.dmark: db "OUT"  
5923 f1			.pastdmark: pop af  
5924			endm  
# End of macro DMARK
5924						CALLMONITOR 
5924 cd aa fd			call debug_vector  
5927				endm  
# End of macro CALLMONITOR
5927					endif 
5927			 
5927					; get port 
5927			 
5927					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5927 cd 0f 22			call macro_dsp_valuehl 
592a				endm 
# End of macro FORTH_DSP_VALUEHL
592a			 
592a e5					push hl 
592b			 
592b					; destroy value TOS 
592b			 
592b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
592b cd c7 22			call macro_forth_dsp_pop 
592e				endm 
# End of macro FORTH_DSP_POP
592e			 
592e					; get byte to send 
592e			 
592e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
592e cd 0f 22			call macro_dsp_valuehl 
5931				endm 
# End of macro FORTH_DSP_VALUEHL
5931			 
5931			;		push hl 
5931			 
5931					; destroy value TOS 
5931			 
5931					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5931 cd c7 22			call macro_forth_dsp_pop 
5934				endm 
# End of macro FORTH_DSP_POP
5934			 
5934					; one value on hl get other one back 
5934			 
5934			;		pop hl 
5934			 
5934 c1					pop bc 
5935			 
5935					if DEBUG_FORTH_WORDS 
5935						DMARK "OUT" 
5935 f5				push af  
5936 3a 4a 59			ld a, (.dmark)  
5939 32 a6 fd			ld (debug_mark),a  
593c 3a 4b 59			ld a, (.dmark+1)  
593f 32 a7 fd			ld (debug_mark+1),a  
5942 3a 4c 59			ld a, (.dmark+2)  
5945 32 a8 fd			ld (debug_mark+2),a  
5948 18 03			jr .pastdmark  
594a ..			.dmark: db "OUT"  
594d f1			.pastdmark: pop af  
594e			endm  
# End of macro DMARK
594e						CALLMONITOR 
594e cd aa fd			call debug_vector  
5951				endm  
# End of macro CALLMONITOR
5951					endif 
5951			 
5951 ed 69				out (c), l 
5953			 
5953					NEXTW 
5953 c3 c5 23			jp macro_next 
5956				endm 
# End of macro NEXTW
5956			 
5956			 
5956			.SPIO: 
5956			 
5956			if STORAGE_SE 
5956				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5956 51				db WORD_SYS_CORE+61             
5957 67 59			dw .SPICEH            
5959 07				db 6 + 1 
595a .. 00			db "SPICEL",0              
5961				endm 
# End of macro CWHEAD
5961			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5961			 
5961 cd 13 02				call spi_ce_low 
5964			    NEXTW 
5964 c3 c5 23			jp macro_next 
5967				endm 
# End of macro NEXTW
5967			 
5967			.SPICEH: 
5967				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5967 51				db WORD_SYS_CORE+61             
5968 78 59			dw .SPIOb            
596a 07				db 6 + 1 
596b .. 00			db "SPICEH",0              
5972				endm 
# End of macro CWHEAD
5972			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
5972			 
5972 cd 02 02				call spi_ce_high 
5975			    NEXTW 
5975 c3 c5 23			jp macro_next 
5978				endm 
# End of macro NEXTW
5978			 
5978			 
5978			.SPIOb: 
5978			 
5978				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
5978 51				db WORD_SYS_CORE+61             
5979 aa 59			dw .SPII            
597b 05				db 4 + 1 
597c .. 00			db "SPIO",0              
5981				endm 
# End of macro CWHEAD
5981			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
5981			 
5981					if DEBUG_FORTH_WORDS_KEY 
5981						DMARK "SPo" 
5981 f5				push af  
5982 3a 96 59			ld a, (.dmark)  
5985 32 a6 fd			ld (debug_mark),a  
5988 3a 97 59			ld a, (.dmark+1)  
598b 32 a7 fd			ld (debug_mark+1),a  
598e 3a 98 59			ld a, (.dmark+2)  
5991 32 a8 fd			ld (debug_mark+2),a  
5994 18 03			jr .pastdmark  
5996 ..			.dmark: db "SPo"  
5999 f1			.pastdmark: pop af  
599a			endm  
# End of macro DMARK
599a						CALLMONITOR 
599a cd aa fd			call debug_vector  
599d				endm  
# End of macro CALLMONITOR
599d					endif 
599d					; get port 
599d			 
599d			 
599d					; get byte to send 
599d			 
599d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
599d cd 0f 22			call macro_dsp_valuehl 
59a0				endm 
# End of macro FORTH_DSP_VALUEHL
59a0			 
59a0			;		push hl    ; u1  
59a0			 
59a0					; destroy value TOS 
59a0			 
59a0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
59a0 cd c7 22			call macro_forth_dsp_pop 
59a3				endm 
# End of macro FORTH_DSP_POP
59a3			 
59a3					; one value on hl get other one back 
59a3			 
59a3			;		pop hl   ; u2 - addr 
59a3			 
59a3					; TODO Send SPI byte 
59a3			 
59a3			;		push hl 
59a3			;		call spi_ce_low 
59a3			;		pop hl 
59a3 7d					ld a, l 
59a4 cd 01 01				call spi_send_byte 
59a7			;		call spi_ce_high 
59a7			 
59a7					NEXTW 
59a7 c3 c5 23			jp macro_next 
59aa				endm 
# End of macro NEXTW
59aa			 
59aa			.SPII: 
59aa				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
59aa 52				db WORD_SYS_CORE+62             
59ab 13 5a			dw .SESEL            
59ad 06				db 5 + 1 
59ae .. 00			db "SPII",0              
59b3				endm 
# End of macro CWHEAD
59b3			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
59b3					if DEBUG_FORTH_WORDS_KEY 
59b3						DMARK "SPi" 
59b3 f5				push af  
59b4 3a c8 59			ld a, (.dmark)  
59b7 32 a6 fd			ld (debug_mark),a  
59ba 3a c9 59			ld a, (.dmark+1)  
59bd 32 a7 fd			ld (debug_mark+1),a  
59c0 3a ca 59			ld a, (.dmark+2)  
59c3 32 a8 fd			ld (debug_mark+2),a  
59c6 18 03			jr .pastdmark  
59c8 ..			.dmark: db "SPi"  
59cb f1			.pastdmark: pop af  
59cc			endm  
# End of macro DMARK
59cc						CALLMONITOR 
59cc cd aa fd			call debug_vector  
59cf				endm  
# End of macro CALLMONITOR
59cf					endif 
59cf			 
59cf					; TODO Get SPI byte 
59cf			 
59cf cd 28 01				call spi_read_byte 
59d2			 
59d2					if DEBUG_FORTH_WORDS 
59d2						DMARK "Si2" 
59d2 f5				push af  
59d3 3a e7 59			ld a, (.dmark)  
59d6 32 a6 fd			ld (debug_mark),a  
59d9 3a e8 59			ld a, (.dmark+1)  
59dc 32 a7 fd			ld (debug_mark+1),a  
59df 3a e9 59			ld a, (.dmark+2)  
59e2 32 a8 fd			ld (debug_mark+2),a  
59e5 18 03			jr .pastdmark  
59e7 ..			.dmark: db "Si2"  
59ea f1			.pastdmark: pop af  
59eb			endm  
# End of macro DMARK
59eb						CALLMONITOR 
59eb cd aa fd			call debug_vector  
59ee				endm  
# End of macro CALLMONITOR
59ee					endif 
59ee 26 00				ld h, 0 
59f0 6f					ld l, a 
59f1					if DEBUG_FORTH_WORDS 
59f1						DMARK "Si3" 
59f1 f5				push af  
59f2 3a 06 5a			ld a, (.dmark)  
59f5 32 a6 fd			ld (debug_mark),a  
59f8 3a 07 5a			ld a, (.dmark+1)  
59fb 32 a7 fd			ld (debug_mark+1),a  
59fe 3a 08 5a			ld a, (.dmark+2)  
5a01 32 a8 fd			ld (debug_mark+2),a  
5a04 18 03			jr .pastdmark  
5a06 ..			.dmark: db "Si3"  
5a09 f1			.pastdmark: pop af  
5a0a			endm  
# End of macro DMARK
5a0a						CALLMONITOR 
5a0a cd aa fd			call debug_vector  
5a0d				endm  
# End of macro CALLMONITOR
5a0d					endif 
5a0d cd 18 20				call forth_push_numhl 
5a10			 
5a10					NEXTW 
5a10 c3 c5 23			jp macro_next 
5a13				endm 
# End of macro NEXTW
5a13			 
5a13			 
5a13			 
5a13			.SESEL: 
5a13				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5a13 66				db WORD_SYS_CORE+82             
5a14 bc 5a			dw .CARTDEV            
5a16 05				db 4 + 1 
5a17 .. 00			db "BANK",0              
5a1c				endm 
# End of macro CWHEAD
5a1c			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5a1c					if DEBUG_FORTH_WORDS_KEY 
5a1c						DMARK "BNK" 
5a1c f5				push af  
5a1d 3a 31 5a			ld a, (.dmark)  
5a20 32 a6 fd			ld (debug_mark),a  
5a23 3a 32 5a			ld a, (.dmark+1)  
5a26 32 a7 fd			ld (debug_mark+1),a  
5a29 3a 33 5a			ld a, (.dmark+2)  
5a2c 32 a8 fd			ld (debug_mark+2),a  
5a2f 18 03			jr .pastdmark  
5a31 ..			.dmark: db "BNK"  
5a34 f1			.pastdmark: pop af  
5a35			endm  
# End of macro DMARK
5a35						CALLMONITOR 
5a35 cd aa fd			call debug_vector  
5a38				endm  
# End of macro CALLMONITOR
5a38					endif 
5a38			 
5a38 3e ff				ld a, 255 
5a3a 32 9e f9				ld (spi_cartdev), a 
5a3d			 
5a3d					; get bank 
5a3d			 
5a3d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5a3d cd 0f 22			call macro_dsp_valuehl 
5a40				endm 
# End of macro FORTH_DSP_VALUEHL
5a40			 
5a40			;		push hl 
5a40			 
5a40					; destroy value TOS 
5a40			 
5a40					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5a40 cd c7 22			call macro_forth_dsp_pop 
5a43				endm 
# End of macro FORTH_DSP_POP
5a43			 
5a43					; one value on hl get other one back 
5a43			 
5a43			;		pop hl 
5a43			 
5a43			 
5a43 0e ff				ld c, SPI_CE_HIGH 
5a45 06 30				ld b, '0'    ; human readable bank number 
5a47			 
5a47 7d					ld a, l 
5a48			 
5a48					if DEBUG_FORTH_WORDS 
5a48						DMARK "BNK" 
5a48 f5				push af  
5a49 3a 5d 5a			ld a, (.dmark)  
5a4c 32 a6 fd			ld (debug_mark),a  
5a4f 3a 5e 5a			ld a, (.dmark+1)  
5a52 32 a7 fd			ld (debug_mark+1),a  
5a55 3a 5f 5a			ld a, (.dmark+2)  
5a58 32 a8 fd			ld (debug_mark+2),a  
5a5b 18 03			jr .pastdmark  
5a5d ..			.dmark: db "BNK"  
5a60 f1			.pastdmark: pop af  
5a61			endm  
# End of macro DMARK
5a61						CALLMONITOR 
5a61 cd aa fd			call debug_vector  
5a64				endm  
# End of macro CALLMONITOR
5a64					endif 
5a64			 
5a64					; active low 
5a64			 
5a64 fe 00				cp 0 
5a66 28 28				jr z, .bset 
5a68 fe 01				cp 1 
5a6a 20 04				jr nz, .b2 
5a6c cb 81				res 0, c 
5a6e 06 31				ld b, '1'    ; human readable bank number 
5a70 fe 02		.b2:		cp 2 
5a72 20 04				jr nz, .b3 
5a74 cb 89				res 1, c 
5a76 06 32				ld b, '2'    ; human readable bank number 
5a78 fe 03		.b3:		cp 3 
5a7a 20 04				jr nz, .b4 
5a7c cb 91				res 2, c 
5a7e 06 33				ld b, '3'    ; human readable bank number 
5a80 fe 04		.b4:		cp 4 
5a82 20 04				jr nz, .b5 
5a84 cb 99				res 3, c 
5a86 06 34				ld b, '4'    ; human readable bank number 
5a88 fe 05		.b5:		cp 5 
5a8a 20 04				jr nz, .bset 
5a8c cb a1				res 4, c 
5a8e 06 35				ld b, '5'    ; human readable bank number 
5a90			 
5a90			.bset: 
5a90 79					ld a, c 
5a91 32 9b f9				ld (spi_device),a 
5a94 78					ld a, b 
5a95 32 9a f9				ld (spi_device_id),a 
5a98					if DEBUG_FORTH_WORDS 
5a98						DMARK "BN2" 
5a98 f5				push af  
5a99 3a ad 5a			ld a, (.dmark)  
5a9c 32 a6 fd			ld (debug_mark),a  
5a9f 3a ae 5a			ld a, (.dmark+1)  
5aa2 32 a7 fd			ld (debug_mark+1),a  
5aa5 3a af 5a			ld a, (.dmark+2)  
5aa8 32 a8 fd			ld (debug_mark+2),a  
5aab 18 03			jr .pastdmark  
5aad ..			.dmark: db "BN2"  
5ab0 f1			.pastdmark: pop af  
5ab1			endm  
# End of macro DMARK
5ab1						CALLMONITOR 
5ab1 cd aa fd			call debug_vector  
5ab4				endm  
# End of macro CALLMONITOR
5ab4					endif 
5ab4			 
5ab4					; set default SPI clk pulse time as disabled for BANK use 
5ab4			 
5ab4 3e 00				ld a, 0 
5ab6 32 9f f9				ld (spi_clktime), a 
5ab9			 
5ab9					NEXTW 
5ab9 c3 c5 23			jp macro_next 
5abc				endm 
# End of macro NEXTW
5abc			 
5abc			.CARTDEV: 
5abc				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5abc 66				db WORD_SYS_CORE+82             
5abd 6a 5b			dw .ENDDEVICE            
5abf 08				db 7 + 1 
5ac0 .. 00			db "CARTDEV",0              
5ac8				endm 
# End of macro CWHEAD
5ac8			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5ac8					if DEBUG_FORTH_WORDS_KEY 
5ac8						DMARK "CDV" 
5ac8 f5				push af  
5ac9 3a dd 5a			ld a, (.dmark)  
5acc 32 a6 fd			ld (debug_mark),a  
5acf 3a de 5a			ld a, (.dmark+1)  
5ad2 32 a7 fd			ld (debug_mark+1),a  
5ad5 3a df 5a			ld a, (.dmark+2)  
5ad8 32 a8 fd			ld (debug_mark+2),a  
5adb 18 03			jr .pastdmark  
5add ..			.dmark: db "CDV"  
5ae0 f1			.pastdmark: pop af  
5ae1			endm  
# End of macro DMARK
5ae1						CALLMONITOR 
5ae1 cd aa fd			call debug_vector  
5ae4				endm  
# End of macro CALLMONITOR
5ae4					endif 
5ae4			 
5ae4					; disable se storage bank selection 
5ae4			 
5ae4 3e ff				ld a, SPI_CE_HIGH		; ce high 
5ae6 32 9b f9				ld (spi_device), a 
5ae9			 
5ae9					; get bank 
5ae9			 
5ae9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ae9 cd 0f 22			call macro_dsp_valuehl 
5aec				endm 
# End of macro FORTH_DSP_VALUEHL
5aec			 
5aec			;		push hl 
5aec			 
5aec					; destroy value TOS 
5aec			 
5aec					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5aec cd c7 22			call macro_forth_dsp_pop 
5aef				endm 
# End of macro FORTH_DSP_POP
5aef			 
5aef					; one value on hl get other one back 
5aef			 
5aef			;		pop hl 
5aef			 
5aef					; active low 
5aef			 
5aef 0e ff				ld c, 255 
5af1			 
5af1 7d					ld a, l 
5af2					if DEBUG_FORTH_WORDS 
5af2						DMARK "CDV" 
5af2 f5				push af  
5af3 3a 07 5b			ld a, (.dmark)  
5af6 32 a6 fd			ld (debug_mark),a  
5af9 3a 08 5b			ld a, (.dmark+1)  
5afc 32 a7 fd			ld (debug_mark+1),a  
5aff 3a 09 5b			ld a, (.dmark+2)  
5b02 32 a8 fd			ld (debug_mark+2),a  
5b05 18 03			jr .pastdmark  
5b07 ..			.dmark: db "CDV"  
5b0a f1			.pastdmark: pop af  
5b0b			endm  
# End of macro DMARK
5b0b						CALLMONITOR 
5b0b cd aa fd			call debug_vector  
5b0e				endm  
# End of macro CALLMONITOR
5b0e					endif 
5b0e fe 00				cp 0 
5b10 28 30				jr z, .cset 
5b12 fe 01				cp 1 
5b14 20 02				jr nz, .c2 
5b16 cb 81				res 0, c 
5b18 fe 02		.c2:		cp 2 
5b1a 20 02				jr nz, .c3 
5b1c cb 89				res 1, c 
5b1e fe 03		.c3:		cp 3 
5b20 20 02				jr nz, .c4 
5b22 cb 91				res 2, c 
5b24 fe 04		.c4:		cp 4 
5b26 20 02				jr nz, .c5 
5b28 cb 99				res 3, c 
5b2a fe 05		.c5:		cp 5 
5b2c 20 02				jr nz, .c6 
5b2e cb a1				res 4, c 
5b30 fe 06		.c6:		cp 6 
5b32 20 02				jr nz, .c7 
5b34 cb a9				res 5, c 
5b36 fe 07		.c7:		cp 7 
5b38 20 02				jr nz, .c8 
5b3a cb b1				res 6, c 
5b3c fe 08		.c8:		cp 8 
5b3e 20 02				jr nz, .cset 
5b40 cb b9				res 7, c 
5b42 79			.cset:		ld a, c 
5b43 32 9e f9				ld (spi_cartdev),a 
5b46			 
5b46					if DEBUG_FORTH_WORDS 
5b46						DMARK "CD2" 
5b46 f5				push af  
5b47 3a 5b 5b			ld a, (.dmark)  
5b4a 32 a6 fd			ld (debug_mark),a  
5b4d 3a 5c 5b			ld a, (.dmark+1)  
5b50 32 a7 fd			ld (debug_mark+1),a  
5b53 3a 5d 5b			ld a, (.dmark+2)  
5b56 32 a8 fd			ld (debug_mark+2),a  
5b59 18 03			jr .pastdmark  
5b5b ..			.dmark: db "CD2"  
5b5e f1			.pastdmark: pop af  
5b5f			endm  
# End of macro DMARK
5b5f						CALLMONITOR 
5b5f cd aa fd			call debug_vector  
5b62				endm  
# End of macro CALLMONITOR
5b62					endif 
5b62			 
5b62					; set default SPI clk pulse time as 10ms for CARTDEV use 
5b62			 
5b62 3e 0a				ld a, $0a 
5b64 32 9f f9				ld (spi_clktime), a 
5b67					NEXTW 
5b67 c3 c5 23			jp macro_next 
5b6a				endm 
# End of macro NEXTW
5b6a			endif 
5b6a			 
5b6a			.ENDDEVICE: 
5b6a			; eof 
5b6a			 
# End of file forth_words_device.asm
5b6a			 
5b6a			; var handler 
5b6a			 
5b6a			 
5b6a			.VARS: 
5b6a				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5b6a 77				db WORD_SYS_CORE+99             
5b6b 1b 5c			dw .V0            
5b6d 04				db 3 + 1 
5b6e .. 00			db "VAR",0              
5b72				endm 
# End of macro CWHEAD
5b72			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5b72			;| 
5b72			;| The variable name should consist of a single letter. e.g. "a" 
5b72			;! If a full string is passed then only the first char is looked at 
5b72			;| Any other char could exceed bounds checks!  
5b72			 
5b72					if DEBUG_FORTH_WORDS_KEY 
5b72						DMARK "VAR" 
5b72 f5				push af  
5b73 3a 87 5b			ld a, (.dmark)  
5b76 32 a6 fd			ld (debug_mark),a  
5b79 3a 88 5b			ld a, (.dmark+1)  
5b7c 32 a7 fd			ld (debug_mark+1),a  
5b7f 3a 89 5b			ld a, (.dmark+2)  
5b82 32 a8 fd			ld (debug_mark+2),a  
5b85 18 03			jr .pastdmark  
5b87 ..			.dmark: db "VAR"  
5b8a f1			.pastdmark: pop af  
5b8b			endm  
# End of macro DMARK
5b8b						CALLMONITOR 
5b8b cd aa fd			call debug_vector  
5b8e				endm  
# End of macro CALLMONITOR
5b8e					endif 
5b8e			 
5b8e					FORTH_DSP_VALUEHL 
5b8e cd 0f 22			call macro_dsp_valuehl 
5b91				endm 
# End of macro FORTH_DSP_VALUEHL
5b91			 
5b91 7e					ld a, (hl)    ; get first char on of the string 
5b92			 
5b92			 
5b92					if DEBUG_FORTH_WORDS 
5b92						DMARK "VR1" 
5b92 f5				push af  
5b93 3a a7 5b			ld a, (.dmark)  
5b96 32 a6 fd			ld (debug_mark),a  
5b99 3a a8 5b			ld a, (.dmark+1)  
5b9c 32 a7 fd			ld (debug_mark+1),a  
5b9f 3a a9 5b			ld a, (.dmark+2)  
5ba2 32 a8 fd			ld (debug_mark+2),a  
5ba5 18 03			jr .pastdmark  
5ba7 ..			.dmark: db "VR1"  
5baa f1			.pastdmark: pop af  
5bab			endm  
# End of macro DMARK
5bab						CALLMONITOR 
5bab cd aa fd			call debug_vector  
5bae				endm  
# End of macro CALLMONITOR
5bae					endif 
5bae					 
5bae f5					push af	 
5baf					FORTH_DSP_POP 
5baf cd c7 22			call macro_forth_dsp_pop 
5bb2				endm 
# End of macro FORTH_DSP_POP
5bb2 f1					pop af 
5bb3			 
5bb3					; convert to upper 
5bb3			 
5bb3 cd 51 12				call to_upper 
5bb6					if DEBUG_FORTH_WORDS 
5bb6						DMARK "Vaa" 
5bb6 f5				push af  
5bb7 3a cb 5b			ld a, (.dmark)  
5bba 32 a6 fd			ld (debug_mark),a  
5bbd 3a cc 5b			ld a, (.dmark+1)  
5bc0 32 a7 fd			ld (debug_mark+1),a  
5bc3 3a cd 5b			ld a, (.dmark+2)  
5bc6 32 a8 fd			ld (debug_mark+2),a  
5bc9 18 03			jr .pastdmark  
5bcb ..			.dmark: db "Vaa"  
5bce f1			.pastdmark: pop af  
5bcf			endm  
# End of macro DMARK
5bcf						CALLMONITOR 
5bcf cd aa fd			call debug_vector  
5bd2				endm  
# End of macro CALLMONITOR
5bd2					endif 
5bd2 06 41				ld b, 'A' 
5bd4 90					sub b			; set offset 
5bd5					if DEBUG_FORTH_WORDS 
5bd5						DMARK "Vbb" 
5bd5 f5				push af  
5bd6 3a ea 5b			ld a, (.dmark)  
5bd9 32 a6 fd			ld (debug_mark),a  
5bdc 3a eb 5b			ld a, (.dmark+1)  
5bdf 32 a7 fd			ld (debug_mark+1),a  
5be2 3a ec 5b			ld a, (.dmark+2)  
5be5 32 a8 fd			ld (debug_mark+2),a  
5be8 18 03			jr .pastdmark  
5bea ..			.dmark: db "Vbb"  
5bed f1			.pastdmark: pop af  
5bee			endm  
# End of macro DMARK
5bee						CALLMONITOR 
5bee cd aa fd			call debug_vector  
5bf1				endm  
# End of macro CALLMONITOR
5bf1					endif 
5bf1 cb 27				sla a  
5bf3				 
5bf3					 
5bf3					if DEBUG_FORTH_WORDS 
5bf3						DMARK "VR2" 
5bf3 f5				push af  
5bf4 3a 08 5c			ld a, (.dmark)  
5bf7 32 a6 fd			ld (debug_mark),a  
5bfa 3a 09 5c			ld a, (.dmark+1)  
5bfd 32 a7 fd			ld (debug_mark+1),a  
5c00 3a 0a 5c			ld a, (.dmark+2)  
5c03 32 a8 fd			ld (debug_mark+2),a  
5c06 18 03			jr .pastdmark  
5c08 ..			.dmark: db "VR2"  
5c0b f1			.pastdmark: pop af  
5c0c			endm  
# End of macro DMARK
5c0c						CALLMONITOR 
5c0c cd aa fd			call debug_vector  
5c0f				endm  
# End of macro CALLMONITOR
5c0f					endif 
5c0f			 
5c0f 21 2f f9				ld hl, cli_var_array2 
5c12 cd cf 0f				call addatohl 
5c15 cd 18 20				call forth_push_numhl 
5c18			 
5c18			 
5c18				       NEXTW 
5c18 c3 c5 23			jp macro_next 
5c1b				endm 
# End of macro NEXTW
5c1b			.V0: 
5c1b				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5c1b 78				db WORD_SYS_CORE+100             
5c1c 33 5c			dw .V0Q            
5c1e 04				db 3 + 1 
5c1f .. 00			db "V0!",0              
5c23				endm 
# End of macro CWHEAD
5c23			;| V0! ( u1 -- )  Store value to v0  | DONE 
5c23			 
5c23					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c23 cd 0f 22			call macro_dsp_valuehl 
5c26				endm 
# End of macro FORTH_DSP_VALUEHL
5c26			 
5c26 11 63 f9				ld de, cli_var_array 
5c29			 
5c29 eb					ex de, hl 
5c2a 73					ld (hl), e 
5c2b 23					inc hl 
5c2c 72					ld (hl), d 
5c2d			 
5c2d					; destroy value TOS 
5c2d			 
5c2d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c2d cd c7 22			call macro_forth_dsp_pop 
5c30				endm 
# End of macro FORTH_DSP_POP
5c30			 
5c30				       NEXTW 
5c30 c3 c5 23			jp macro_next 
5c33				endm 
# End of macro NEXTW
5c33			.V0Q: 
5c33				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5c33 79				db WORD_SYS_CORE+101             
5c34 44 5c			dw .V1S            
5c36 04				db 3 + 1 
5c37 .. 00			db "V0@",0              
5c3b				endm 
# End of macro CWHEAD
5c3b			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5c3b 2a 63 f9				ld hl, (cli_var_array) 
5c3e cd 18 20				call forth_push_numhl 
5c41			 
5c41				       NEXTW 
5c41 c3 c5 23			jp macro_next 
5c44				endm 
# End of macro NEXTW
5c44			.V1S: 
5c44				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5c44 7a				db WORD_SYS_CORE+102             
5c45 5c 5c			dw .V1Q            
5c47 04				db 3 + 1 
5c48 .. 00			db "V1!",0              
5c4c				endm 
# End of macro CWHEAD
5c4c			;| V1! ( u1 -- )  Store value to v1 | DONE 
5c4c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c4c cd 0f 22			call macro_dsp_valuehl 
5c4f				endm 
# End of macro FORTH_DSP_VALUEHL
5c4f			 
5c4f 11 65 f9				ld de, cli_var_array+2 
5c52				 
5c52 eb					ex de, hl 
5c53 73					ld (hl), e 
5c54 23					inc hl 
5c55 72					ld (hl), d 
5c56			 
5c56					; destroy value TOS 
5c56			 
5c56					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c56 cd c7 22			call macro_forth_dsp_pop 
5c59				endm 
# End of macro FORTH_DSP_POP
5c59				       NEXTW 
5c59 c3 c5 23			jp macro_next 
5c5c				endm 
# End of macro NEXTW
5c5c			.V1Q: 
5c5c				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5c5c 7b				db WORD_SYS_CORE+103             
5c5d 6d 5c			dw .V2S            
5c5f 04				db 3 + 1 
5c60 .. 00			db "V1@",0              
5c64				endm 
# End of macro CWHEAD
5c64			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5c64 2a 65 f9				ld hl, (cli_var_array+2) 
5c67 cd 18 20				call forth_push_numhl 
5c6a				       NEXTW 
5c6a c3 c5 23			jp macro_next 
5c6d				endm 
# End of macro NEXTW
5c6d			.V2S: 
5c6d				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5c6d 7c				db WORD_SYS_CORE+104             
5c6e 85 5c			dw .V2Q            
5c70 04				db 3 + 1 
5c71 .. 00			db "V2!",0              
5c75				endm 
# End of macro CWHEAD
5c75			;| V2! ( u1 -- )  Store value to v2 | DONE 
5c75					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c75 cd 0f 22			call macro_dsp_valuehl 
5c78				endm 
# End of macro FORTH_DSP_VALUEHL
5c78			 
5c78 11 67 f9				ld de, cli_var_array+4 
5c7b				 
5c7b eb					ex de, hl 
5c7c 73					ld (hl), e 
5c7d 23					inc hl 
5c7e 72					ld (hl), d 
5c7f			 
5c7f					; destroy value TOS 
5c7f			 
5c7f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c7f cd c7 22			call macro_forth_dsp_pop 
5c82				endm 
# End of macro FORTH_DSP_POP
5c82				       NEXTW 
5c82 c3 c5 23			jp macro_next 
5c85				endm 
# End of macro NEXTW
5c85			.V2Q: 
5c85				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5c85 7d				db WORD_SYS_CORE+105             
5c86 96 5c			dw .V3S            
5c88 04				db 3 + 1 
5c89 .. 00			db "V2@",0              
5c8d				endm 
# End of macro CWHEAD
5c8d			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5c8d 2a 67 f9				ld hl, (cli_var_array+4) 
5c90 cd 18 20				call forth_push_numhl 
5c93				       NEXTW 
5c93 c3 c5 23			jp macro_next 
5c96				endm 
# End of macro NEXTW
5c96			.V3S: 
5c96				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5c96 7c				db WORD_SYS_CORE+104             
5c97 ae 5c			dw .V3Q            
5c99 04				db 3 + 1 
5c9a .. 00			db "V3!",0              
5c9e				endm 
# End of macro CWHEAD
5c9e			;| V3! ( u1 -- )  Store value to v3 | DONE 
5c9e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c9e cd 0f 22			call macro_dsp_valuehl 
5ca1				endm 
# End of macro FORTH_DSP_VALUEHL
5ca1			 
5ca1 11 69 f9				ld de, cli_var_array+6 
5ca4				 
5ca4 eb					ex de, hl 
5ca5 73					ld (hl), e 
5ca6 23					inc hl 
5ca7 72					ld (hl), d 
5ca8			 
5ca8					; destroy value TOS 
5ca8			 
5ca8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ca8 cd c7 22			call macro_forth_dsp_pop 
5cab				endm 
# End of macro FORTH_DSP_POP
5cab				       NEXTW 
5cab c3 c5 23			jp macro_next 
5cae				endm 
# End of macro NEXTW
5cae			.V3Q: 
5cae				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5cae 7d				db WORD_SYS_CORE+105             
5caf bf 5c			dw .END            
5cb1 04				db 3 + 1 
5cb2 .. 00			db "V3@",0              
5cb6				endm 
# End of macro CWHEAD
5cb6			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5cb6 2a 69 f9				ld hl, (cli_var_array+6) 
5cb9 cd 18 20				call forth_push_numhl 
5cbc				       NEXTW 
5cbc c3 c5 23			jp macro_next 
5cbf				endm 
# End of macro NEXTW
5cbf			 
5cbf			 
5cbf			 
5cbf			 
5cbf			 
5cbf			; end of dict marker 
5cbf			 
5cbf 00			.END:    db WORD_SYS_END 
5cc0 00 00			dw 0 
5cc2 00				db 0 
5cc3			 
5cc3			; use to jp here for user dict words to save on macro expansion  
5cc3			 
5cc3			user_dict_next: 
5cc3				NEXTW 
5cc3 c3 c5 23			jp macro_next 
5cc6				endm 
# End of macro NEXTW
5cc6			 
5cc6			 
5cc6			user_exec: 
5cc6				;    ld hl, <word code> 
5cc6				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5cc6				;    call forthexec 
5cc6				;    jp user_dict_next   (NEXT) 
5cc6			        ;    <word code bytes> 
5cc6 eb				ex de, hl 
5cc7 2a fd f3			ld hl,(os_tok_ptr) 
5cca				 
5cca				FORTH_RSP_NEXT 
5cca cd bf 1f			call macro_forth_rsp_next 
5ccd				endm 
# End of macro FORTH_RSP_NEXT
5ccd			 
5ccd			if DEBUG_FORTH_UWORD 
5ccd						DMARK "UEX" 
5ccd f5				push af  
5cce 3a e2 5c			ld a, (.dmark)  
5cd1 32 a6 fd			ld (debug_mark),a  
5cd4 3a e3 5c			ld a, (.dmark+1)  
5cd7 32 a7 fd			ld (debug_mark+1),a  
5cda 3a e4 5c			ld a, (.dmark+2)  
5cdd 32 a8 fd			ld (debug_mark+2),a  
5ce0 18 03			jr .pastdmark  
5ce2 ..			.dmark: db "UEX"  
5ce5 f1			.pastdmark: pop af  
5ce6			endm  
# End of macro DMARK
5ce6				CALLMONITOR 
5ce6 cd aa fd			call debug_vector  
5ce9				endm  
# End of macro CALLMONITOR
5ce9			endif 
5ce9			 
5ce9			 
5ce9			 
5ce9 eb				ex de, hl 
5cea 22 fd f3			ld (os_tok_ptr), hl 
5ced				 
5ced				; Don't use next - Skips the first word in uword. 
5ced			 
5ced c3 56 24			jp exec1 
5cf0			;	NEXT 
5cf0			 
5cf0			 
5cf0			; eof 
# End of file forth_wordsv4.asm
5cf0			endif 
5cf0			;;;;;;;;;;;;;; Debug code 
5cf0			 
5cf0			 
5cf0			;if DEBUG_FORTH_PARSE 
5cf0 .. 00		.nowordfound: db "No match",0 
5cf9 .. 00		.compword:	db "Comparing word ",0 
5d09 .. 00		.nextwordat:	db "Next word at",0 
5d16 .. 00		.charmatch:	db "Char match",0 
5d21			;endif 
5d21			if DEBUG_FORTH_JP 
5d21			.foundword:	db "Word match. Exec..",0 
5d21			endif 
5d21			;if DEBUG_FORTH_PUSH 
5d21 .. 00		.enddict:	db "Dict end. Push.",0 
5d31 .. 00		.push_str:	db "Pushing string",0 
5d40 .. 00		.push_num:	db "Pushing number",0 
5d4f .. 00		.data_sp:	db "SP:",0 
5d53 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5d65 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5d77 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5d89			;endif 
5d89			;if DEBUG_FORTH_MALLOC 
5d89 .. 00		.push_malloc:	db "Malloc address",0 
5d98			;endif 
5d98			 
5d98			 
5d98			 
5d98			; display malloc address and current data stack pointer  
5d98			 
5d98			malloc_error: 
5d98 d5				push de 
5d99 f5				push af 
5d9a e5				push hl 
5d9b cd 9b 0d			call clear_display 
5d9e 11 be 5d			ld de, .mallocerr 
5da1 3e 00			ld a,0 
5da3			;	ld de,os_word_scratch 
5da3 cd ae 0d			call str_at_display 
5da6 3e 11			ld a, display_row_1+17 
5da8 11 a6 fd			ld de, debug_mark 
5dab cd ae 0d			call str_at_display 
5dae cd be 0d			call update_display 
5db1				;call break_point_state 
5db1 cd 81 79			call cin_wait 
5db4			 
5db4			;	ld a, ' ' 
5db4			;	ld (os_view_disable), a 
5db4 cd 4a 19			call bp_on 
5db7 e1				pop hl 
5db8 f1				pop af 
5db9 d1				pop de	 
5dba				CALLMONITOR 
5dba cd aa fd			call debug_vector  
5dbd				endm  
# End of macro CALLMONITOR
5dbd c9				ret 
5dbe			 
5dbe .. 00		.mallocerr: 	db "Malloc Error",0 
5dcb			;if DEBUG_FORTH_PUSH 
5dcb			display_data_sp: 
5dcb f5				push af 
5dcc			 
5dcc				; see if disabled 
5dcc			 
5dcc			 
5dcc 3a aa fd			ld a, (debug_vector) 
5dcf fe c9			cp $C9  ; RET 
5dd1				;ld a, (os_view_disable) 
5dd1				;cp '*' 
5dd1 28 67			jr z, .skipdsp 
5dd3			 
5dd3 e5				push hl 
5dd4 e5				push hl 
5dd5 e5			push hl 
5dd6 cd 9b 0d			call clear_display 
5dd9 e1			pop hl 
5dda 7c				ld a,h 
5ddb 21 01 f4			ld hl, os_word_scratch 
5dde cd e5 11			call hexout 
5de1 e1				pop hl 
5de2 7d				ld a,l 
5de3 21 03 f4			ld hl, os_word_scratch+2 
5de6 cd e5 11			call hexout 
5de9 21 05 f4			ld hl, os_word_scratch+4 
5dec 3e 00			ld a,0 
5dee 77				ld (hl),a 
5def 11 01 f4			ld de,os_word_scratch 
5df2 3e 28				ld a, display_row_2 
5df4 cd ae 0d				call str_at_display 
5df7 11 53 5d			ld de, .wordinhl 
5dfa 3e 00			ld a, display_row_1 
5dfc			 
5dfc cd ae 0d				call str_at_display 
5dff 11 a6 fd			ld de, debug_mark 
5e02 3e 11			ld a, display_row_1+17 
5e04			 
5e04 cd ae 0d				call str_at_display 
5e07			 
5e07				; display current data stack pointer 
5e07 11 4f 5d			ld de,.data_sp 
5e0a 3e 30				ld a, display_row_2 + 8 
5e0c cd ae 0d				call str_at_display 
5e0f			 
5e0f 2a 29 f9			ld hl,(cli_data_sp) 
5e12 e5				push hl 
5e13 7c				ld a,h 
5e14 21 01 f4			ld hl, os_word_scratch 
5e17 cd e5 11			call hexout 
5e1a e1				pop hl 
5e1b 7d				ld a,l 
5e1c 21 03 f4			ld hl, os_word_scratch+2 
5e1f cd e5 11			call hexout 
5e22 21 05 f4			ld hl, os_word_scratch+4 
5e25 3e 00			ld a,0 
5e27 77				ld (hl),a 
5e28 11 01 f4			ld de,os_word_scratch 
5e2b 3e 33				ld a, display_row_2 + 11 
5e2d cd ae 0d				call str_at_display 
5e30			 
5e30			 
5e30 cd be 0d			call update_display 
5e33 cd de 0c			call delay1s 
5e36 cd de 0c			call delay1s 
5e39 e1				pop hl 
5e3a			.skipdsp: 
5e3a f1				pop af 
5e3b c9				ret 
5e3c			 
5e3c			display_data_malloc: 
5e3c			 
5e3c f5				push af 
5e3d e5				push hl 
5e3e e5				push hl 
5e3f e5			push hl 
5e40 cd 9b 0d			call clear_display 
5e43 e1			pop hl 
5e44 7c				ld a,h 
5e45 21 01 f4			ld hl, os_word_scratch 
5e48 cd e5 11			call hexout 
5e4b e1				pop hl 
5e4c 7d				ld a,l 
5e4d 21 03 f4			ld hl, os_word_scratch+2 
5e50 cd e5 11			call hexout 
5e53 21 05 f4			ld hl, os_word_scratch+4 
5e56 3e 00			ld a,0 
5e58 77				ld (hl),a 
5e59 11 01 f4			ld de,os_word_scratch 
5e5c 3e 28				ld a, display_row_2 
5e5e cd ae 0d				call str_at_display 
5e61 11 89 5d			ld de, .push_malloc 
5e64 3e 00			ld a, display_row_1 
5e66			 
5e66 cd ae 0d				call str_at_display 
5e69			 
5e69				; display current data stack pointer 
5e69 11 4f 5d			ld de,.data_sp 
5e6c 3e 30				ld a, display_row_2 + 8 
5e6e cd ae 0d				call str_at_display 
5e71			 
5e71 2a 29 f9			ld hl,(cli_data_sp) 
5e74 e5				push hl 
5e75 7c				ld a,h 
5e76 21 01 f4			ld hl, os_word_scratch 
5e79 cd e5 11			call hexout 
5e7c e1				pop hl 
5e7d 7d				ld a,l 
5e7e 21 03 f4			ld hl, os_word_scratch+2 
5e81 cd e5 11			call hexout 
5e84 21 05 f4			ld hl, os_word_scratch+4 
5e87 3e 00			ld a,0 
5e89 77				ld (hl),a 
5e8a 11 01 f4			ld de,os_word_scratch 
5e8d 3e 33				ld a, display_row_2 + 11 
5e8f cd ae 0d				call str_at_display 
5e92			 
5e92 cd be 0d			call update_display 
5e95 cd de 0c			call delay1s 
5e98 cd de 0c			call delay1s 
5e9b e1				pop hl 
5e9c f1				pop af 
5e9d c9				ret 
5e9e			;endif 
5e9e			 
5e9e			include "forth_autostart.asm" 
5e9e			; list of commands to perform at system start up 
5e9e			 
5e9e			startcmds: 
5e9e			;	dw test11 
5e9e			;	dw test12 
5e9e			;	dw test13 
5e9e			;	dw test14 
5e9e			;	dw test15 
5e9e			;	dw test16 
5e9e			;	dw test17 
5e9e			;	dw ifthtest1 
5e9e			;	dw ifthtest2 
5e9e			;	dw ifthtest3 
5e9e			;	dw mmtest1 
5e9e			;	dw mmtest2 
5e9e			;	dw mmtest3 
5e9e			;	dw mmtest4 
5e9e			;	dw mmtest5 
5e9e			;	dw mmtest6 
5e9e			;	dw iftest1 
5e9e			;	dw iftest2 
5e9e			;	dw iftest3 
5e9e			;	dw looptest1 
5e9e			;	dw looptest2 
5e9e			;	dw test1 
5e9e			;	dw test2 
5e9e			;	dw test3 
5e9e			;	dw test4 
5e9e			;	dw game2r 
5e9e			;	dw game2b1 
5e9e			;	dw game2b2 
5e9e			 
5e9e				; start up words that are actually useful 
5e9e			 
5e9e			;    dw spi1 
5e9e			;    dw spi2 
5e9e			;    dw spi3 
5e9e			;    dw spi4 
5e9e			;    dw spi5 
5e9e			;    dw spi6 
5e9e			;    dw spi7 
5e9e			; 
5e9e			;    dw spi8 
5e9e			;    dw spi9 
5e9e			;    dw spi10 
5e9e			 
5e9e			; file editor 
5e9e			;	dw edit1 
5e9e			;	dw edit2 
5e9e			;	dw edit3 
5e9e			 
5e9e			;	dw longread 
5e9e c8 62			dw clrstack 
5ea0 fc 62			dw type 
5ea2			;	dw stest 
5ea2 21 63			dw strncpy 
5ea4			;	dw list 
5ea4 82 63			dw start1 
5ea6 92 63			dw start2 
5ea8			;	dw start3 
5ea8			;	dw start3b 
5ea8			;	dw start3c 
5ea8			 
5ea8				; (unit) testing words 
5ea8			 
5ea8			;	dw mtesta 
5ea8			;	dw mtestb 
5ea8			;	dw mtestc 
5ea8			;	dw mtestd 
5ea8			;	dw mteste 
5ea8			 
5ea8				; demo/game words 
5ea8			 
5ea8			;        dw game3w 
5ea8			;        dw game3p 
5ea8			;        dw game3sc 
5ea8			;        dw game3vsi 
5ea8			;        dw game3vs 
5ea8				 
5ea8 eb 6d			dw game2b 
5eaa 59 6e			dw game2bf 
5eac a3 6e			dw game2mba 
5eae 39 6f			dw game2mbas 
5eb0 7b 6f			dw game2mb 
5eb2			 
5eb2 ac 6a			dw game1 
5eb4 bd 6a			dw game1a 
5eb6 1f 6b			dw game1b 
5eb8 54 6b			dw game1c 
5eba 8a 6b			dw game1d 
5ebc bb 6b			dw game1s 
5ebe cf 6b			dw game1t 
5ec0 e4 6b			dw game1f 
5ec2 18 6c			dw game1z 
5ec4 5c 6c			dw game1zz 
5ec6			 
5ec6 c6 68			dw test5 
5ec8 fe 68			dw test6 
5eca 36 69			dw test7 
5ecc 4a 69			dw test8 
5ece 76 69			dw test9 
5ed0 8c 69			dw test10 
5ed2				 
5ed2 33 6d		        dw ssv5 
5ed4 17 6d		        dw ssv4 
5ed6 fb 6c		        dw ssv3 
5ed8 c5 6c		        dw ssv2 
5eda 4c 6d		        dw ssv1 
5edc 94 6d		        dw ssv1cpm 
5ede			;	dw keyup 
5ede			;	dw keydown 
5ede			;	dw keyleft 
5ede			;	dw keyright 
5ede			;	dw 	keyf1 
5ede			;	dw keyf2 
5ede			;	dw keyf3 
5ede			;	dw keyf4 
5ede			;	dw keyf5 
5ede			;	dw keyf6 
5ede			;	dw keyf7 
5ede			;	dw keyf8 
5ede			;	dw keyf9 
5ede			;	dw keyf10 
5ede			;	dw keyf11 
5ede			;	dw keyf12 
5ede			;	dw keytab 
5ede			;	dw keycr 
5ede			;	dw keyhome 
5ede			;	dw keyend 
5ede			;	dw keybs 
5ede 00 00			db 0, 0	 
5ee0			 
5ee0			 
5ee0			; File Editor 
5ee0			 
5ee0			; ( id - ) use 'e' to edit the displayed line 
5ee0 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
5f01 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5f36			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
5f36 .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
5f6e			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
5f6e			 
5f6e			; SPI Net support words 
5f6e			 
5f6e			; v0! = node to send to 
5f6e			; ( str count - ) 
5f6e .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
5fc7			 
5fc7			; spiputc ( char node - ) 
5fc7 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
5ffb			; spiputc ( u node - ) 
5ffb .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
6029			 
6029			; spigetc ( - n ) 
6029 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
6052			 
6052			; getnode ( - n ) 
6052 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
607f			 
607f			; ( str node - )  
607f .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
60e5			; store string ( str i - ) 
60e5			 
60e5			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
60e5 .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
613a			 
613a			; get string ( addr i -  )    TO FIX 
613a			 
613a .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
6192			 
6192			 
6192			; NETCHAT (TODO) 
6192			; Program to allow two nodes to chat with eachother 
6192			; 
6192			; v0 - target node 
6192			;  
6192			; accept input at 0,0 
6192			; if input is string send spitype to target node 
6192			; starting at row 2,0 , while spigetchr is not zero ->  
6192			; 
6192			; 
6192			; TODO add paging of get request 
6192			 
6192			; ( node - ) 
6192 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
61b1 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
6209 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
6281			 
6281			 
6281			; Long read of currently open file 
6281 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
62c8			 
62c8			; clear stack  
62c8			 
62c8 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
62fc			 
62fc			; type ( addr count - ) 
62fc .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
6321			 
6321			; some direct memory words 
6321			; strncpy ( len t f -- t ) 
6321			 
6321 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
6382			 
6382 .. 00		start1:     	db ": bpon $00 bp ;",0 
6392 .. 00		start2:     	db ": bpoff $01 bp ;",0 
63a3 .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
641e .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
647e			 
647e			 
647e			; a handy word to list items on the stack 
647e			 
647e .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
64e8			 
64e8			 
64e8			; test stack  
64e8			; rnd8 stest 
64e8			 
64e8 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
655f			 
655f			; random malloc and free cycles 
655f			 
655f .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6614			 
6614			; fixed malloc and free cycles 
6614			 
6614 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
66b7			 
66b7			; fixed double string push and drop cycle  
66b7			 
66b7 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
676c			 
676c			; consistent fixed string push and drop cycle  
676c			 
676c .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6810			 
6810 .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
68c6			 
68c6			;test1:		db ": aa 1 2 3 ;", 0 
68c6			;test2:     	db "111 aa 888 999",0 
68c6			;test3:     	db ": bb 77 ;",0 
68c6			;test4:     	db "$02 $01 do i . loop bb",0 
68c6			 
68c6 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
68fe .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6936 .. 00		test7:     	db ": box hline vline ;",0 
694a .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
6976 .. 00		test9:     	db ": sw $01 adsp world ;",0 
698c .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
69b1 .. 00		test11:     	db "hello create .",0 
69c0 .. 00		test12:     	db "hello2 create .",0 
69d0			 
69d0			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
69d0			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
69d0			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
69d0			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
69d0			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
69d0			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
69d0			 
69d0			;iftest1:     	db "$0001 IF cls .",0 
69d0			;iftest2:     	db "$0000 IF cls .",0 
69d0			;iftest3:     	db "$0002 $0003 - IF cls .",0 
69d0			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
69d0			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
69d0			 
69d0			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
69d0			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
69d0			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
69d0			 
69d0			 
69d0 .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
69f4 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
6a24 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
6a49 .. 00		sound4: db ": cha $00 ; ",0 
6a56 .. 00		sound5: db ": chb $20 ; ",0 
6a63 .. 00		sound6: db ": chc $40 ; ",0 
6a70 .. 00		sound7: db ": chd $60 ; ",0 
6a7d .. 00		sound8: db ": cnote $80 + + note ; ", 0 
6a95 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
6aac			 
6aac			 
6aac			 
6aac			 
6aac			; a small guess the number game 
6aac			 
6aac .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6abd .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6b1f			 
6b1f .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6b54 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6b8a .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
6bbb .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
6bcf .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
6be4 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6c18 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6c5c			 
6c5c			; Using 'ga' save a high score across multiple runs using external storage 
6c5c			 
6c5c .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6cc5			 
6cc5			 
6cc5			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6cc5			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6cc5			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6cc5			 
6cc5			; simple screen saver to test code memory reuse to destruction 
6cc5			 
6cc5 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6cfb .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6d17 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6d33 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6d4c .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6d94 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6deb			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6deb			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6deb			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6deb			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6deb			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6deb			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6deb			 
6deb			 
6deb			 
6deb			; minesweeper/battleship finding game 
6deb			; draws a game board of random ship/mine positions 
6deb			; user enters coords to see if it hits on 
6deb			; game ends when all are hit 
6deb			; when hit or miss says how many may be in the area 
6deb			 
6deb			; setup the game board and then hide it 
6deb .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6e59 .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6ea3			; prompt for where to target 
6ea3 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6f39 .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6f5e			; TODO see if the entered coords hits or misses pushes char hit of miss 
6f5e .. 00		game2mbht:      db ": mbckht nop ;",0 
6f6d .. 00		game2mbms:      db ": mbcms nop ;",0 
6f7b			; TODO how many might be near by 
6f7b .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6ff8			 
6ff8			; Game 3 
6ff8			 
6ff8			; Vert scroller ski game - avoid the trees! 
6ff8			 
6ff8			; v0 score (ie turns) 
6ff8			; v1 player pos 
6ff8			; v2 left wall 
6ff8			; v3 right wall 
6ff8			 
6ff8			; Draw side walls randomly 
6ff8			 
6ff8 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
7026			 
7026			; Draw player 
7026 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
7044			 
7044			; TODO Get Key 
7044			 
7044			; TODO Move left right 
7044			 
7044			; scroll and move walls a bit 
7044			 
7044 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
7075			 
7075			; main game loop 
7075			 
7075 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
70a1 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
70e0			 
70e0			; key board defs 
70e0			 
70e0 .. 00		keyup:       db ": keyup $05 ;",0 
70ee .. 00		keydown:       db ": keydown $0a ;",0 
70fe .. 00		keyleft:       db ": keyleft $0b ;",0 
710e .. 00		keyright:       db ": keyright $0c ;",0 
711f .. 00		keyf1:       db ": keyf1 $10 ;",0 
712d .. 00		keyf2:       db ": keyf2 $11 ;",0 
713b .. 00		keyf3:       db ": keyf3 $12 ;",0 
7149 .. 00		keyf4:       db ": keyf4 $13 ;",0 
7157 .. 00		keyf5:       db ": keyf5 $14 ;",0 
7165 .. 00		keyf6:       db ": keyf6 $15 ;",0 
7173 .. 00		keyf7:       db ": keyf7 $16 ;",0 
7181 .. 00		keyf8:       db ": keyf8 $17 ;",0 
718f .. 00		keyf9:       db ": keyf9 $18 ;",0 
719d .. 00		keyf10:       db ": keyf10 $19 ;",0 
71ac .. 00		keyf11:       db ": keyf11 $1a ;",0 
71bb .. 00		keyf12:       db ": keyf12 $1b ;",0 
71ca			 
71ca .. 00		keytab:       db ": keytab $09 ;",0 
71d9 .. 00		keycr:       db ": keycr $0d ;",0 
71e7 .. 00		keyhome:       db ": keyhome $0e ;",0 
71f7 .. 00		keyend:       db ": keyend $0f ;",0 
7206 .. 00		keybs:       db ": keybs $08 ;",0 
7214			 
7214			   
7214			 
7214			 
7214			 
7214			; eof 
# End of file forth_autostart.asm
7214			 
7214			 
7214			 
7214			; stack over and underflow checks 
7214			 
7214			; init the words to detect the under/overflow 
7214			 
7214			chk_stk_init: 
7214				; a vague random number to check so we dont get any "lucky" hits 
7214 3e 2d			ld a, 45 
7216 6f				ld l, a 
7217 00				nop 
7218 3e 17			ld a, 23 
721a 67				ld h, a 
721b			 
721b 22 d8 f0			ld (chk_word), hl     ; the word we need to check against 
721e			 
721e			;	ld (chk_stund), hl	; stack points.... 
721e 22 3b fe			ld (chk_stovr), hl 
7221 22 27 f9			ld (chk_ret_und), hl 
7224 22 e5 f8			ld (chk_ret_ovr), hl 
7227 22 63 f8			ld (chk_loop_ovr), hl 
722a 22 61 f6			ld (chk_data_ovr), hl 
722d c9				ret 
722e				 
722e			check_stacks: 
722e				; check all stack words 
722e			 
722e e5				push hl 
722f d5				push de 
7230			 
7230			;	ld de,(chk_word) 
7230			;	ld hl, (chk_stund)	; stack points.... 
7230			;	if DEBUG_STK_FAULT 
7230			;		DMARK "FAa" 
7230			;		CALLMONITOR 
7230			;	endif 
7230			;	call cmp16 
7230			;	jp z, .chk_faulta 
7230			; 
7230			;	ld de, sfaultsu 
7230			;	jp .chk_fault 
7230			 
7230 2a 3b fe		.chk_faulta: ld hl, (chk_stovr) 
7233 ed 5b d8 f0		ld de,(chk_word) 
7237				if DEBUG_STK_FAULT 
7237					DMARK "FAb" 
7237					CALLMONITOR 
7237				endif 
7237 cd ed 0f			call cmp16 
723a 28 06			jr z, .chk_fault1 
723c 11 dd 72			ld de, sfaultso 
723f c3 91 72			jp .chk_fault 
7242			.chk_fault1:  
7242 2a 27 f9			ld hl, (chk_ret_und) 
7245 ed 5b d8 f0		ld de,(chk_word) 
7249				if DEBUG_STK_FAULT 
7249					DMARK "FAU" 
7249					CALLMONITOR 
7249				endif 
7249 cd ed 0f			call cmp16 
724c ca 55 72			jp z, .chk_fault2 
724f 11 ed 72			ld de, sfaultru 
7252 c3 91 72			jp .chk_fault 
7255			.chk_fault2:  
7255 2a e5 f8			ld hl, (chk_ret_ovr) 
7258 ed 5b d8 f0		ld de,(chk_word) 
725c				if DEBUG_STK_FAULT 
725c					DMARK "FA1" 
725c					CALLMONITOR 
725c				endif 
725c cd ed 0f			call cmp16 
725f ca 68 72			jp z, .chk_fault3 
7262 11 fb 72			ld de, sfaultro 
7265 c3 91 72			jp .chk_fault 
7268			.chk_fault3:  
7268 2a 63 f8			ld hl, (chk_loop_ovr) 
726b ed 5b d8 f0		ld de,(chk_word) 
726f				if DEBUG_STK_FAULT 
726f					DMARK "FA2" 
726f					CALLMONITOR 
726f				endif 
726f cd ed 0f			call cmp16 
7272 ca 7b 72			jp z, .chk_fault4 
7275 11 15 73			ld de, sfaultlo 
7278 c3 91 72			jp .chk_fault 
727b			.chk_fault4:  
727b 2a 61 f6			ld hl, (chk_data_ovr) 
727e ed 5b d8 f0		ld de,(chk_word) 
7282				if DEBUG_STK_FAULT 
7282					DMARK "FA3" 
7282					CALLMONITOR 
7282				endif 
7282 cd ed 0f			call cmp16 
7285 ca 8e 72			jp z, .chk_fault5 
7288 11 2f 73			ld de, sfaultdo 
728b c3 91 72			jp .chk_fault 
728e			 
728e			 
728e			.chk_fault5:  
728e d1				pop de 
728f e1				pop hl 
7290			 
7290 c9				ret 
7291			 
7291 cd 9b 0d		.chk_fault: 	call clear_display 
7294 3e 28				ld a, display_row_2 
7296 cd ae 0d				call str_at_display 
7299 11 bf 72				   ld de, .stackfault 
729c 3e 00				ld a, display_row_1 
729e cd ae 0d				call str_at_display 
72a1 11 a6 fd				    ld de, debug_mark 
72a4 3e 11				ld a, display_row_1+17 
72a6 cd ae 0d				call str_at_display 
72a9 cd be 0d				call update_display 
72ac			 
72ac				; prompt before entering montior for investigating issue 
72ac			 
72ac 3e 78			ld a, display_row_4 
72ae 11 0a 1d			ld de, endprog 
72b1			 
72b1 cd be 0d			call update_display		 
72b4			 
72b4 cd 90 1f			call next_page_prompt 
72b7			 
72b7 d1				pop de 
72b8 e1				pop hl 
72b9 cd 5e 1d				call monitor 
72bc c3 67 1c				jp warmstart 
72bf					;jp 0 
72bf					;halt 
72bf			 
72bf			 
72bf			 
72bf .. 00		.stackfault: 	db "Stack fault:",0 
72cc			 
72cc .. 00		sfaultsu: 	db	"Stack under flow",0 
72dd .. 00		sfaultso: 	db	"Stack over flow",0 
72ed .. 00		sfaultru:	db "RTS underflow",0 
72fb .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
7315 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
732f .. 00		sfaultdo:	db "DTS overflow", 0 
733c			 
733c			 
733c			fault_dsp_under: 
733c 11 4e 73			ld de, .dsp_under 
733f c3 fe 73			jp .show_fault 
7342			 
7342			fault_rsp_under: 
7342 11 5c 73			ld de, .rsp_under 
7345 c3 fe 73			jp .show_fault 
7348			fault_loop_under: 
7348 11 6a 73			ld de, .loop_under 
734b c3 fe 73			jp .show_fault 
734e			 
734e .. 00		.dsp_under: db "DSP Underflow",0 
735c .. 00		.rsp_under: db "RSP Underflow",0 
736a .. 00		.loop_under: db "LOOP Underflow",0 
7379			 
7379			 
7379 d5			type_faultn: 	push de 
737a e5					push hl 
737b cd 9b 0d				call clear_display 
737e 11 a5 73				   ld de, .typefaultn 
7381 3e 00				ld a, display_row_1 
7383 cd ae 0d				call str_at_display 
7386 11 a6 fd				    ld de, debug_mark 
7389 3e 11				ld a, display_row_1+17 
738b cd ae 0d				call str_at_display 
738e cd be 0d				call update_display 
7391			 
7391				; prompt before entering montior for investigating issue 
7391			 
7391 3e 78			ld a, display_row_4 
7393 11 0a 1d			ld de, endprog 
7396			 
7396 cd be 0d			call update_display		 
7399			 
7399 cd 90 1f			call next_page_prompt 
739c			 
739c e5					push hl 
739d d5					push de 
739e cd 5e 1d				call monitor 
73a1 c3 67 1c				jp warmstart 
73a4 76					halt 
73a5			 
73a5			 
73a5 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
73bc			 
73bc d5			type_faults: 	push de 
73bd e5					push hl 
73be cd 9b 0d				call clear_display 
73c1 11 e7 73				   ld de, .typefaults 
73c4 3e 00				ld a, display_row_1 
73c6 cd ae 0d				call str_at_display 
73c9 11 a6 fd				    ld de, debug_mark 
73cc 3e 11				ld a, display_row_1+17 
73ce cd ae 0d				call str_at_display 
73d1 cd be 0d				call update_display 
73d4			 
73d4				; prompt before entering montior for investigating issue 
73d4			 
73d4 3e 78			ld a, display_row_4 
73d6 11 0a 1d			ld de, endprog 
73d9			 
73d9 cd be 0d			call update_display		 
73dc			 
73dc cd 90 1f			call next_page_prompt 
73df			 
73df e1					pop hl 
73e0 d1					pop de 
73e1 cd 5e 1d				call monitor 
73e4 c3 67 1c				jp warmstart 
73e7			 
73e7			 
73e7 .. 00		.typefaults: db "STR Type Expected TOS!",0 
73fe			 
73fe			.show_fault: 	 
73fe d5					push de 
73ff cd 9b 0d				call clear_display 
7402 d1					pop de 
7403 3e 00				ld a, display_row_1 
7405 cd ae 0d				call str_at_display 
7408 11 a6 fd				    ld de, debug_mark 
740b 3e 11				ld a, display_row_1+17 
740d cd ae 0d				call str_at_display 
7410 cd be 0d				call update_display 
7413			 
7413				; prompt before entering montior for investigating issue 
7413			 
7413 3e 78			ld a, display_row_4 
7415 11 0a 1d			ld de, endprog 
7418			 
7418 cd be 0d			call update_display		 
741b			 
741b cd 90 1f			call next_page_prompt 
741e			 
741e e1					pop hl 
741f d1					pop de 
7420 cd 5e 1d				call monitor 
7423			; do a dump to cli and not warmstart so we preserve all of the uwords.  
7423			; TODO Make optional fault restart to cli or warm boot? 
7423					;jp warmstart 
7423 c3 b1 1c				jp cli 
7426 76					halt 
7427			 
7427			; handle the auto run of code from files in storage 
7427			 
7427			 
7427			include "forth_startup.asm" 
7427			; Which startup method to use? 
7427			; 
7427			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
7427			; followed by loading of a list of scripts in eeprom 
7427			 
7427			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
7427			; from eeprom 
7427			 
7427			; Select with define in main stubs 
7427			 
7427			if STARTUP_V1 
7427				include "forth_startupv1.asm" 
7427			endif 
7427			if STARTUP_V2 
7427				include "forth_startupv2.asm" 
7427			; Version 2 of the startup  
7427			;  
7427			; Auto load any files in bank 1 that start with a '*' 
7427			; If no se storage then revert to using eprom 
7427			 
7427			 
7427			if STORAGE_SE = 0 
7427			 
7427			sprompt1: db "Startup load...",0 
7427			sprompt2: db "Run? 1=No *=End #=All",0 
7427			 
7427			 
7427			 
7427			 
7427			forth_startup: 
7427				ld hl, startcmds 
7427				ld a, 0 
7427				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
7427			 
7427			.start1:	push hl 
7427				call clear_display 
7427				ld de, sprompt1 
7427			        ld a, display_row_1 
7427				call str_at_display 
7427				ld de, sprompt2 
7427			        ld a, display_row_2 
7427				call str_at_display 
7427				pop hl 
7427				push hl 
7427				ld e,(hl) 
7427				inc hl 
7427				ld d,(hl) 
7427			        ld a, display_row_3 
7427				call str_at_display 
7427				call update_display 
7427			 
7427			 
7427				ld a, (os_last_cmd) 
7427				cp 0 
7427				jr z, .startprompt 
7427				call delay250ms 
7427				jr .startdo 
7427				 
7427				 
7427			 
7427			.startprompt: 
7427			 
7427				ld a,display_row_4 + display_cols - 1 
7427			        ld de, endprg 
7427				call str_at_display 
7427				call update_display 
7427				call delay1s 
7427				call cin_wait 
7427						 
7427				cp '*' 
7427				jr z, .startupend1 
7427				cp '#' 
7427				jr nz, .startno 
7427				ld a, 1 
7427				ld (os_last_cmd),a 
7427				jr .startdo 
7427			.startno:	cp '1' 
7427				jr z,.startnxt  
7427			 
7427				; exec startup line 
7427			.startdo:	 
7427				pop hl 
7427				push hl 
7427				 
7427				ld e,(hl) 
7427				inc hl 
7427				ld d,(hl) 
7427				ex de,hl 
7427			 
7427				push hl 
7427			 
7427				ld a, 0 
7427				;ld a, FORTH_END_BUFFER 
7427				call strlent 
7427				inc hl   ; include zero term to copy 
7427				ld b,0 
7427				ld c,l 
7427				pop hl 
7427				ld de, scratch 
7427				ldir 
7427			 
7427			 
7427				ld hl, scratch 
7427				call forthparse 
7427				call forthexec 
7427				call forthexec_cleanup 
7427			 
7427				ld a, display_row_4 
7427				ld de, endprog 
7427			 
7427				call update_display		 
7427			 
7427				ld a, (os_last_cmd) 
7427				cp 0 
7427				jr nz, .startnxt 
7427				call next_page_prompt 
7427			        call clear_display 
7427				call update_display		 
7427			 
7427				; move onto next startup line? 
7427			.startnxt: 
7427			 
7427				call delay250ms 
7427				pop hl 
7427			 
7427				inc hl 
7427				inc hl 
7427			 
7427				push hl 
7427				ld e, (hl) 
7427				inc hl 
7427				ld d, (hl) 
7427				pop hl 
7427				; TODO replace 0 test 
7427			 
7427				ex de, hl 
7427				call ishlzero 
7427			;	ld a,e 
7427			;	add d 
7427			;	cp 0    ; any left to do? 
7427				ex de, hl 
7427				jp nz, .start1 
7427				jr .startupend 
7427			 
7427			.startupend1: pop hl 
7427			.startupend: 
7427			 
7427				call clear_display 
7427				call update_display 
7427				ret 
7427			endif 
7427			 
7427			 
7427			if STORAGE_SE 
7427			 
7427			;sprompt3: db "Loading from start-up file:",0 
7427 .. 00		sprompt3: db "  Searching...",0 
7436			;sprompt4: db "(Any key to stop)",0 
7436			 
7436			 
7436			forth_autoload: 
7436			 
7436				; load block 0 of store 1 
7436				 
7436 3e fe			ld a, $fe      ; bit 0 clear 
7438 32 9b f9			ld (spi_device), a 
743b			 
743b cd 16 05			call storage_get_block_0 
743e			 
743e 3a d6 f9			ld a, (store_page+STORE_0_AUTOFILE) 
7441			 
7441 fe 00			cp 0 
7443 c8				ret z     ; auto start not enabled 
7444			 
7444 cd 9b 0d			call clear_display 
7447			 
7447				; set bank 
7447			 
7447 3a d8 f9				ld a, (store_page+STORE_0_BANKRUN) 
744a 32 9b f9				ld (spi_device), a 
744d			 
744d			 
744d				; generate a directory of bank 1 and search for flagged files 
744d			 
744d					if DEBUG_FORTH_WORDS_KEY 
744d						DMARK "DIR" 
744d f5				push af  
744e 3a 62 74			ld a, (.dmark)  
7451 32 a6 fd			ld (debug_mark),a  
7454 3a 63 74			ld a, (.dmark+1)  
7457 32 a7 fd			ld (debug_mark+1),a  
745a 3a 64 74			ld a, (.dmark+2)  
745d 32 a8 fd			ld (debug_mark+2),a  
7460 18 03			jr .pastdmark  
7462 ..			.dmark: db "DIR"  
7465 f1			.pastdmark: pop af  
7466			endm  
# End of macro DMARK
7466						CALLMONITOR 
7466 cd aa fd			call debug_vector  
7469				endm  
# End of macro CALLMONITOR
7469					endif 
7469			 
7469 cd 16 05			call storage_get_block_0 
746c			 
746c 21 b5 f9			ld hl, store_page     ; get current id count 
746f 46				ld b, (hl) 
7470 0e 00			ld c, 0    ; count of files   
7472					if DEBUG_FORTH_WORDS 
7472						DMARK "DI1" 
7472 f5				push af  
7473 3a 87 74			ld a, (.dmark)  
7476 32 a6 fd			ld (debug_mark),a  
7479 3a 88 74			ld a, (.dmark+1)  
747c 32 a7 fd			ld (debug_mark+1),a  
747f 3a 89 74			ld a, (.dmark+2)  
7482 32 a8 fd			ld (debug_mark+2),a  
7485 18 03			jr .pastdmark  
7487 ..			.dmark: db "DI1"  
748a f1			.pastdmark: pop af  
748b			endm  
# End of macro DMARK
748b						CALLMONITOR 
748b cd aa fd			call debug_vector  
748e				endm  
# End of macro CALLMONITOR
748e					endif 
748e			 
748e				; check for empty drive 
748e			 
748e 3e 00			ld a, 0 
7490 b8				cp b 
7491 ca de 74			jp z, .dirdone 
7494			 
7494				; for each of the current ids do a search for them and if found push to stack 
7494			 
7494 c5			.diritem:	push bc 
7495 21 40 00				ld hl, STORE_BLOCK_PHY 
7498 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
749a 58					ld e,b 
749b			 
749b d5					push de 
749c e5					push hl 
749d cd 9b 0d			call clear_display 
74a0 3e 32			ld a, display_row_2 + 10 
74a2 11 27 74			ld de, sprompt3 
74a5 cd ae 0d			call str_at_display 
74a8 cd f2 0c			call active 
74ab eb				ex de, hl 
74ac 3e 2f			ld a, display_row_2 + 7 
74ae cd ae 0d			call str_at_display 
74b1 cd be 0d			call update_display 
74b4 e1				pop hl 
74b5 d1				pop de 
74b6			 
74b6			;		if DEBUG_FORTH_WORDS 
74b6			;			DMARK "DI2" 
74b6			;			CALLMONITOR 
74b6			;		endif 
74b6			 
74b6 cd 98 07				call storage_findnextid 
74b9			 
74b9			;		if DEBUG_FORTH_WORDS 
74b9			;			DMARK "DI3" 
74b9			;			CALLMONITOR 
74b9			;		endif 
74b9			 
74b9					; if found hl will be non zero 
74b9			 
74b9 cd f8 0f				call ishlzero 
74bc			;		ld a, l 
74bc			;		add h 
74bc			; 
74bc			;		cp 0 
74bc 28 1d				jr z, .dirnotfound 
74be			 
74be					; increase count 
74be			 
74be c1					pop bc	 
74bf 0c					inc c 
74c0 c5					push bc 
74c1					 
74c1			 
74c1					; get file header and push the file name 
74c1			 
74c1 11 b5 f9				ld de, store_page 
74c4 cd 65 04				call storage_read_block 
74c7			 
74c7					; push file id to stack 
74c7				 
74c7			 
74c7					; is this a file we want to run? 
74c7			 
74c7 21 b8 f9				ld hl, store_page+3 
74ca 7e					ld a,(hl) 
74cb fe 2a				cp '*' 
74cd 20 0c				jr nz,  .dirnotfound 
74cf					 
74cf			 
74cf			 
74cf 3a b5 f9				ld a, (store_page) 
74d2 d5					push de 
74d3 e5					push hl 
74d4 c5					push bc 
74d5 cd 01 75				call .autorunf 
74d8 c1					pop bc 
74d9 e1					pop hl 
74da d1					pop de 
74db			 
74db			 
74db			 
74db				; save this extent 
74db			 
74db					; push file name 
74db			;display file name to run 
74db			 
74db			;		ld hl, store_page+3 
74db			;		if DEBUG_FORTH_WORDS 
74db			;			DMARK "DI5" 
74db			;			CALLMONITOR 
74db			;		endif 
74db			; 
74db			;		 
74db			; 
74db			;		call forth_push_str 
74db			;		if DEBUG_FORTH_WORDS 
74db			;			DMARK "DI6" 
74db			;			CALLMONITOR 
74db			;		endif 
74db			.dirnotfound: 
74db c1					pop bc     
74dc 10 b6				djnz .diritem 
74de				 
74de			.dirdone:	 
74de					if DEBUG_FORTH_WORDS 
74de						DMARK "DI7" 
74de f5				push af  
74df 3a f3 74			ld a, (.dmark)  
74e2 32 a6 fd			ld (debug_mark),a  
74e5 3a f4 74			ld a, (.dmark+1)  
74e8 32 a7 fd			ld (debug_mark+1),a  
74eb 3a f5 74			ld a, (.dmark+2)  
74ee 32 a8 fd			ld (debug_mark+2),a  
74f1 18 03			jr .pastdmark  
74f3 ..			.dmark: db "DI7"  
74f6 f1			.pastdmark: pop af  
74f7			endm  
# End of macro DMARK
74f7						CALLMONITOR 
74f7 cd aa fd			call debug_vector  
74fa				endm  
# End of macro CALLMONITOR
74fa					endif 
74fa			 
74fa cd 9b 0d				call clear_display 
74fd cd be 0d				call update_display 
7500			 
7500 c9					ret 
7501			 
7501			 
7501			 
7501			 
7501			 
7501			.autorunf: 
7501			 
7501			 
7501				; get file id to load from and get the file name to display 
7501			 
7501			;		ld a, (store_page+STORE_0_FILERUN) 
7501			 
7501 2e 00				ld l, 0 
7503 67					ld h, a 
7504 11 b5 f9				ld de, store_page 
7507			 
7507					if DEBUG_FORTH_WORDS 
7507						DMARK "ASp" 
7507 f5				push af  
7508 3a 1c 75			ld a, (.dmark)  
750b 32 a6 fd			ld (debug_mark),a  
750e 3a 1d 75			ld a, (.dmark+1)  
7511 32 a7 fd			ld (debug_mark+1),a  
7514 3a 1e 75			ld a, (.dmark+2)  
7517 32 a8 fd			ld (debug_mark+2),a  
751a 18 03			jr .pastdmark  
751c ..			.dmark: db "ASp"  
751f f1			.pastdmark: pop af  
7520			endm  
# End of macro DMARK
7520						CALLMONITOR 
7520 cd aa fd			call debug_vector  
7523				endm  
# End of macro CALLMONITOR
7523					endif 
7523 cd be 09				call storage_read 
7526			 
7526					if DEBUG_FORTH_WORDS 
7526						DMARK "ASr" 
7526 f5				push af  
7527 3a 3b 75			ld a, (.dmark)  
752a 32 a6 fd			ld (debug_mark),a  
752d 3a 3c 75			ld a, (.dmark+1)  
7530 32 a7 fd			ld (debug_mark+1),a  
7533 3a 3d 75			ld a, (.dmark+2)  
7536 32 a8 fd			ld (debug_mark+2),a  
7539 18 03			jr .pastdmark  
753b ..			.dmark: db "ASr"  
753e f1			.pastdmark: pop af  
753f			endm  
# End of macro DMARK
753f						CALLMONITOR 
753f cd aa fd			call debug_vector  
7542				endm  
# End of macro CALLMONITOR
7542					endif 
7542			 
7542 cd f8 0f				call ishlzero 
7545 c8					ret z             ; file not found 
7546			 
7546					; display file name we are loading 
7546			 
7546 cd 9b 0d				call clear_display 
7549			 
7549 3e 32				ld a, display_row_2 + 10 
754b 11 b8 f9				ld de, store_page+3 
754e cd ae 0d				call str_at_display 
7551				 
7551			; 
7551			 
7551			;	ld a, display_row_1+5 
7551			;	ld de, sprompt3 
7551			;	call str_at_display 
7551			;	ld a, display_row_2+7 
7551			;	call active 
7551			;	ex de, hl 
7551			;;	ld de, sprompt4 
7551			;	call str_at_display 
7551			; 
7551 cd be 0d			call update_display 
7554			 
7554			;	call cin_wait 
7554			;	cp 'n' 
7554			;	ret z 
7554			;	cp 'N' 
7554			;	ret z 
7554			 
7554			;	call delay1s 
7554			 
7554 3a b7 f9			ld a, (store_page+2) 
7557 32 a4 f9			ld (store_openmaxext), a    ; save count of ext 
755a 3e 01			ld a, 1  
755c 32 a5 f9			ld (store_openext), a    ; save count of ext 
755f			 
755f			.autof: 
755f				; begin to read a line from file 
755f			 
755f 21 23 f4			ld hl, os_cli_cmd 
7562 22 21 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
7565			  
7565			.readext: 
7565 3a a5 f9			ld a, (store_openext) 
7568 6f				ld l , a 
7569				 
7569 3a b5 f9			ld a, (store_page) 
756c 67				ld h, a	 
756d 11 b5 f9			ld de, store_page 
7570					if DEBUG_FORTH_WORDS 
7570						DMARK "ASl" 
7570 f5				push af  
7571 3a 85 75			ld a, (.dmark)  
7574 32 a6 fd			ld (debug_mark),a  
7577 3a 86 75			ld a, (.dmark+1)  
757a 32 a7 fd			ld (debug_mark+1),a  
757d 3a 87 75			ld a, (.dmark+2)  
7580 32 a8 fd			ld (debug_mark+2),a  
7583 18 03			jr .pastdmark  
7585 ..			.dmark: db "ASl"  
7588 f1			.pastdmark: pop af  
7589			endm  
# End of macro DMARK
7589						CALLMONITOR 
7589 cd aa fd			call debug_vector  
758c				endm  
# End of macro CALLMONITOR
758c					endif 
758c cd be 09				call storage_read 
758f cd f8 0f			call ishlzero 
7592 c8				ret z 
7593			 
7593			; TODO copy to exec buffer 
7593			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
7593			 
7593				; copy the record buffer to the cli buffer 
7593			 
7593 ed 5b 21 f6		ld de, (os_var_array) 
7597 21 b7 f9			ld hl, store_page+2 
759a			;	ex de, hl 
759a 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
759d ed b0			ldir 
759f ed 53 21 f6		ld (os_var_array), de 
75a3				 
75a3 3a a5 f9			ld a, (store_openext) 
75a6 3c				inc a 
75a7 32 a5 f9			ld (store_openext), a    ; save count of ext 
75aa			 
75aa			 
75aa			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
75aa				 
75aa 3a a8 f9			ld a, (store_readcont) 
75ad fe 00			cp 0 
75af 20 b4			jr nz, .readext 
75b1			 
75b1			;	jr z, .autoend 
75b1			 
75b1					if DEBUG_FORTH_WORDS 
75b1						DMARK "ASc" 
75b1 f5				push af  
75b2 3a c6 75			ld a, (.dmark)  
75b5 32 a6 fd			ld (debug_mark),a  
75b8 3a c7 75			ld a, (.dmark+1)  
75bb 32 a7 fd			ld (debug_mark+1),a  
75be 3a c8 75			ld a, (.dmark+2)  
75c1 32 a8 fd			ld (debug_mark+2),a  
75c4 18 03			jr .pastdmark  
75c6 ..			.dmark: db "ASc"  
75c9 f1			.pastdmark: pop af  
75ca			endm  
# End of macro DMARK
75ca						CALLMONITOR 
75ca cd aa fd			call debug_vector  
75cd				endm  
# End of macro CALLMONITOR
75cd					endif 
75cd e5				push hl	 
75ce d5				push de 
75cf cd f2 0c			call active 
75d2 eb				ex de, hl 
75d3 3e 2f			ld a, display_row_2 + 7 
75d5 cd ae 0d			call str_at_display 
75d8			 
75d8 cd be 0d			call update_display 
75db d1				pop de  
75dc e1				pop hl 
75dd			;	call delay250ms 
75dd			 
75dd			 
75dd			 
75dd			 
75dd			.autoexec: 
75dd			 
75dd			 
75dd 21 23 f4			ld hl, os_cli_cmd 
75e0					if DEBUG_FORTH_WORDS 
75e0						DMARK "ASx" 
75e0 f5				push af  
75e1 3a f5 75			ld a, (.dmark)  
75e4 32 a6 fd			ld (debug_mark),a  
75e7 3a f6 75			ld a, (.dmark+1)  
75ea 32 a7 fd			ld (debug_mark+1),a  
75ed 3a f7 75			ld a, (.dmark+2)  
75f0 32 a8 fd			ld (debug_mark+2),a  
75f3 18 03			jr .pastdmark  
75f5 ..			.dmark: db "ASx"  
75f8 f1			.pastdmark: pop af  
75f9			endm  
# End of macro DMARK
75f9						CALLMONITOR 
75f9 cd aa fd			call debug_vector  
75fc				endm  
# End of macro CALLMONITOR
75fc					endif 
75fc cd 13 24			call forthparse 
75ff cd 53 24			call forthexec 
7602 cd 65 23			call forthexec_cleanup 
7605			 
7605			 
7605			 
7605 c3 5f 75			jp .autof 
7608			;.autofdone: 
7608			; 
7608			;		if DEBUG_FORTH_WORDS 
7608			;			DMARK "ASx" 
7608			;			CALLMONITOR 
7608			;		endif 
7608			;;	call clear_display 
7608			;	ret 
7608			 
7608			 
7608			 
7608			endif 
# End of file forth_startupv2.asm
7608			endif 
7608			 
# End of file forth_startup.asm
7608			 
7608			; eof 
# End of file forth_kernel.asm
7608			;include "nascombasic.asm" 
7608			 
7608			 
7608			; find out where the code ends if loaded into RAM (for SC114) 
7608			;endofcode:  
7608			;	nop 
7608			 
7608			 
7608			; jump to nmi vector 
7608			 
7608			init_nmi: 
7608 3e c9			ld a, $c9   ; RET 
760a 32 ad fd			ld (nmi_vector), a 
760d c9				ret 
760e			nmi: 
760e e5				push hl 
760f d5				push de 
7610 c5				push bc 
7611 f5				push af 
7612 cd ad fd			call nmi_vector 
7615 f5				push af 
7616 c5				push bc 
7617 d5				push de 
7618 e5				push hl 
7619 ed 4d			reti 
761b			 
761b			 
761b			; eof 
761b			 
# End of file main.asm
761b			include "firmware_lcd_4x40.asm" 
761b			; **********************************************************************  
761b			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
761b			; **********************************************************************  
761b			;  
761b			; **  Written as a Small Computer Monitor App  
761b			; **  www.scc.me.uk  
761b			;  
761b			; History  
761b			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
761b			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
761b			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
761b			;  
761b			; **********************************************************************  
761b			;  
761b			; This program is an example of one of the methods of interfacing an   
761b			; alphanumeric LCD module.   
761b			;  
761b			; In this example the display is connected to either a Z80 PIO or a   
761b			; simple 8-bit output port.   
761b			;  
761b			; This interfacing method uses 4-bit data mode and uses time delays  
761b			; rather than polling the display's ready status. As a result the   
761b			; interface only requires 6 simple output lines:  
761b			;   Output bit 0 = not used  
761b			;   Output bit 1 = not used  
761b			;   Output bit 2 = RS         High = data, Low = instruction  
761b			;   Output bit 3 = E          Active high  
761b			;   Output bit 4 = DB4  
761b			;   Output bit 5 = DB5  
761b			;   Output bit 6 = DB6  
761b			;   Output bit 7 = DB7  
761b			; Display's R/W is connected to 0v so it is always in write mode  
761b			;  
761b			; This set up should work with any system supporting the RC2014 bus  
761b			  
761b			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
761b			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
761b			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
761b			;  
761b			; **********************************************************************  
761b			  
761b			; Additonal for 4x40. E1 and E2 instead of just E   
761b			; TODO swipe vidout signal on port a to activate E2  
761b			  
761b			; **********************************************************************  
761b			; **  Constants  
761b			; **********************************************************************  
761b			; LCD constants required by LCD support module  
761b			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
761b			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
761b			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
761b			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
761b			; TODO Decide which E is being set  
761b			kLCDWidth:  EQU display_cols             ;Width in characters  
761b			  
761b			; **********************************************************************  
761b			; **  Code library usage  
761b			; **********************************************************************  
761b			  
761b			; send character to current cursor position  
761b			; wraps and/or scrolls screen automatically  
761b			  
761b			  
761b			  
761b			lcd_init:  
761b			  
761b			; SCMonAPI functions used  
761b			  
761b			; Alphanumeric LCD functions used  
761b			; no need to specify specific functions for this module  
761b			  
761b 3e cf		            LD   A, 11001111b  
761d d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
761f 3e 00		            LD   A, 00000000b  
7621 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
7623			  
7623			; Initialise alphanumeric LCD module  
7623 3e 00				ld a, 0  
7625 32 06 fb				ld (display_lcde1e2), a  
7628 cd a9 76		            CALL fLCD_Init      ;Initialise LCD module  
762b 3e 01				ld a, 1  
762d 32 06 fb				ld (display_lcde1e2), a  
7630 cd a9 76		            CALL fLCD_Init      ;Initialise LCD module  
7633			  
7633 c9				ret  
7634			  
7634			;  
7634			;;  
7634			; lcd functions  
7634			;  
7634			;  
7634			  
7634			; what is at cursor position   
7634			  
7634			;get_cursor:	ld de, (cursor_row)   ;  row + col  
7634			;		call curptr  
7634			;		ret  
7634			  
7634			  
7634			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
7634			  
7634			curptr:  
7634 c5				push bc  
7635 21 ec fc			ld hl, display_fb0  
7638			cpr:	  
7638				; loop for cursor whole row  
7638 0e 28			ld c, display_cols  
763a 23			cpr1:	inc hl  
763b 0d				dec c  
763c 20 fc			jr nz, cpr1  
763e 05				dec b  
763f 20 f7			jr nz, cpr  
7641			  
7641				; add col	  
7641			  
7641 23			cpr2:	inc hl  
7642 1d				dec e  
7643 20 fc			jr nz, cpr2  
7645			  
7645 c1				pop bc  
7646 c9				ret  
7647				  
7647			  
7647			  
7647			  
7647			  
7647			; write the frame buffer given in hl to hardware   
7647 22 04 fb		write_display: ld (display_write_tmp), hl 	   
764a 3e 00			ld a, kLCD_Line1  
764c cd 56 77		            CALL fLCD_Pos       ;Position cursor to location in A  
764f 06 28			ld b, display_cols  
7651 ed 5b 04 fb		ld de, (display_write_tmp)  
7655 cd a1 76			call write_len_string  
7658				  
7658				  
7658 2a 04 fb			ld hl, (display_write_tmp)  
765b 11 28 00			ld de, display_cols  
765e 19				add hl,de  
765f 22 04 fb			ld (display_write_tmp),hl  
7662			  
7662				  
7662 3e 28			ld a, kLCD_Line2  
7664 cd 56 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7667 06 28			ld b, display_cols  
7669 ed 5b 04 fb		ld de, (display_write_tmp)  
766d cd a1 76			call write_len_string  
7670				  
7670 2a 04 fb			ld hl, (display_write_tmp)  
7673 11 28 00			ld de, display_cols  
7676 19				add hl,de  
7677 22 04 fb			ld (display_write_tmp),hl  
767a			  
767a				  
767a 3e 50			ld a, kLCD_Line3  
767c cd 56 77		            CALL fLCD_Pos       ;Position cursor to location in A  
767f 06 28			ld b, display_cols  
7681 ed 5b 04 fb		ld de, (display_write_tmp)  
7685 cd a1 76			call write_len_string  
7688				  
7688 2a 04 fb			ld hl, (display_write_tmp)  
768b 11 28 00			ld de, display_cols  
768e 19				add hl,de  
768f 22 04 fb			ld (display_write_tmp),hl  
7692			  
7692				  
7692 3e 78			ld a, kLCD_Line4  
7694 cd 56 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7697 06 28			ld b, display_cols  
7699 ed 5b 04 fb		ld de, (display_write_tmp)  
769d cd a1 76			call write_len_string  
76a0 c9					ret  
76a1				  
76a1				; write out a fixed length string given in b from de  
76a1			  
76a1 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
76a2 cd 0e 77		            CALL fLCD_Data      ;Write character to display  
76a5 13				inc de  
76a6 10 f9			djnz write_len_string  
76a8 c9				ret  
76a9			  
76a9			; Some other things to do  
76a9			;            LD   A, kLCD_Clear ;Display clear  
76a9			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
76a9			;            LD   A, kLCD_Under ;Display on with underscore cursor  
76a9			;            LD   A, kLCD_On     ;Display on with no cursor  
76a9			;            ;LD   A, kLCD_Off   ;Display off  
76a9			;            CALL fLCD_Inst      ;Send instruction to display  
76a9			;  
76a9			;  
76a9			;            halt  
76a9			;  
76a9			;  
76a9			;MsgHello:   DB  "Hello World!",0  
76a9			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
76a9			  
76a9			; Custom characters 5 pixels wide by 8 pixels high  
76a9			; Up to 8 custom characters can be defined  
76a9			;BitMaps:      
76a9			;; Character 0x00 = Battery icon  
76a9			;            DB  01110b  
76a9			;            DB  11011b  
76a9			;            DB  10001b  
76a9			;            DB  10001b  
76a9			;            DB  11111b  
76a9			;            DB  11111b  
76a9			;            DB  11111b  
76a9			;            DB  11111b  
76a9			;; Character 0x01 = Bluetooth icon  
76a9			;            DB  01100b  
76a9			;            DB  01010b  
76a9			;            DB  11100b  
76a9			;            DB  01000b  
76a9			;            DB  11100b  
76a9			;            DB  01010b  
76a9			;            DB  01100b  
76a9			;            DB  00000b  
76a9			;  
76a9			  
76a9			  
76a9			; **********************************************************************  
76a9			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
76a9			; **********************************************************************  
76a9			;  
76a9			; **  Written as a Small Computer Monitor App   
76a9			; **  Version 0.1 SCC 2018-05-16  
76a9			; **  www.scc.me.uk  
76a9			;  
76a9			; **********************************************************************  
76a9			;  
76a9			; This module provides support for alphanumeric LCD modules using with  
76a9			; *  HD44780 (or compatible) controller  
76a9			; *  5 x 7 pixel fonts  
76a9			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
76a9			; *  Interface via six digital outputs to the display (see below)  
76a9			;  
76a9			; LCD module pinout:  
76a9			;   1  Vss   0v supply  
76a9			;   2  Vdd   5v supply  
76a9			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
76a9			;   4  RS    High = data, Low = instruction  
76a9			;   5  R/W   High = Read, Low = Write  
76a9			;   6  E     Enable signal (active high)  
76a9			;   7  DB0   Data bit 0  
76a9			;   8  DB1   Data bit 1  
76a9			;   9  DB2   Data bit 2  
76a9			;  10  DB3   Data bit 3  
76a9			;  11  DB4   Data bit 4  
76a9			;  12  DB5   Data bit 5  
76a9			;  13  DB6   Data bit 6  
76a9			;  14  DB7   Data bit 7  
76a9			;  15  A     Backlight anode (+)  
76a9			;  16  K     Backlight cathode (-)  
76a9			;  
76a9			; This interfacing method uses 4-bit data mode and uses time delays  
76a9			; rather than polling the display's ready status. As a result the   
76a9			; interface only requires 6 simple output lines:  
76a9			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
76a9			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
76a9			;   LCD DB4 = Microcomputer output port bit 4  
76a9			;   LCD DB5 = Microcomputer output port bit 5  
76a9			;   LCD DB6 = Microcomputer output port bit 6  
76a9			;   LCD DB7 = Microcomputer output port bit 7  
76a9			; Display's R/W is connected to 0v so it is always in write mode  
76a9			; All 6 connections must be on the same port address <kLCDPrt>  
76a9			; This method also allows a decent length of cable from micro to LCD  
76a9			;  
76a9			; **********************************************************************  
76a9			;  
76a9			; To include the code for any given function provided by this module,   
76a9			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
76a9			; the parent source file.  
76a9			; For example:  #REQUIRES   uHexPrefix  
76a9			;  
76a9			; Also #INCLUDE this file at some point after the #REQUIRES statements  
76a9			; in the parent source file.  
76a9			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
76a9			;  
76a9			; These are the function names provided by this module:  
76a9			; fLCD_Init                     ;Initialise LCD  
76a9			; fLCD_Inst                     ;Send instruction to LCD  
76a9			; fLCD_Data                     ;Send data byte to LCD  
76a9			; fLCD_Pos                      ;Position cursor  
76a9			; fLCD_Str                      ;Display string  
76a9			; fLCD_Def                      ;Define custom character  
76a9			;  
76a9			; **********************************************************************  
76a9			;  
76a9			; Requires SCMonAPI.asm to also be included in the project  
76a9			;  
76a9			  
76a9			  
76a9			; **********************************************************************  
76a9			; **  Constants  
76a9			; **********************************************************************  
76a9			  
76a9			; Constants that must be defined externally  
76a9			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
76a9			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
76a9			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
76a9			;kLCDWidth: EQU 20             ;Width in characters  
76a9			  
76a9			; general line offsets in any frame buffer  
76a9			  
76a9			  
76a9			display_row_1: equ 0  
76a9			display_row_2: equ display_row_1+display_cols  
76a9			display_row_3: equ display_row_2 + display_cols  
76a9			display_row_4: equ display_row_3 + display_cols  
76a9			;display_row_4_eol:   
76a9			  
76a9			  
76a9			; Cursor position values for the start of each line  
76a9			  
76a9			; E  
76a9			kLCD_Line1: EQU 0x00   
76a9			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
76a9			; E1  
76a9			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
76a9			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
76a9			  
76a9			; Instructions to send as A register to fLCD_Inst  
76a9			kLCD_Clear: EQU 00000001b     ;LCD clear  
76a9			kLCD_Off:   EQU 00001000b     ;LCD off  
76a9			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
76a9			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
76a9			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
76a9			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
76a9			  
76a9			; Constants used by this code module  
76a9			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
76a9			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
76a9			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
76a9			  
76a9			  
76a9			  
76a9			; **********************************************************************  
76a9			; **  LCD support functions  
76a9			; **********************************************************************  
76a9			  
76a9			; Initialise alphanumeric LCD module  
76a9			; LCD control register codes:  
76a9			;   DL   0 = 4-bit mode        1 = 8-bit mode  
76a9			;   N    0 = 1-line mode       1 = 2-line mode  
76a9			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
76a9			;   D    0 = Display off       1 = Display on  
76a9			;   C    0 = Cursor off        1 = Cursor on  
76a9			;   B    0 = Blinking off      1 = Blinking on  
76a9			;   ID   0 = Decrement mode    1 = Increment mode  
76a9			;   SH   0 = Entire shift off  1 = Entire shift on  
76a9 3e 28		fLCD_Init:  LD   A, 40  
76ab cd d0 77		            CALL LCDDelay       ;Delay 40ms after power up  
76ae			; For reliable reset set 8-bit mode - 3 times  
76ae cd a0 77		            CALL WrFn8bit       ;Function = 8-bit mode  
76b1 cd a0 77		            CALL WrFn8bit       ;Function = 8-bit mode  
76b4 cd a0 77		            CALL WrFn8bit       ;Function = 8-bit mode  
76b7			; Set 4-bit mode  
76b7 cd 9c 77		            CALL WrFn4bit       ;Function = 4-bit mode  
76ba cd ce 77		            CALL LCDDelay1      ;Delay 37 us or more  
76bd			; Function set  
76bd 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
76bf cd d2 76		            CALL fLCD_Inst      ;2 line, display on  
76c2			; Display On/Off control  
76c2 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
76c4 cd d2 76		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
76c7			; Display Clear  
76c7 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
76c9 cd d2 76		            CALL fLCD_Inst      ;Clear display  
76cc			; Entry mode  
76cc 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
76ce cd d2 76		            CALL fLCD_Inst      ;Increment mode, shift off  
76d1			; Display module now initialised  
76d1 c9			            RET  
76d2			; ok to here  
76d2			  
76d2			; Write instruction to LCD  
76d2			;   On entry: A = Instruction byte to be written  
76d2			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
76d2 f5			fLCD_Inst:  PUSH AF  
76d3 f5			            PUSH AF  
76d4 cd e6 76		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
76d7 f1			            POP  AF  
76d8 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
76d9 17			            RLA  
76da 17			            RLA  
76db 17			            RLA  
76dc cd e6 76		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
76df 3e 02		            LD   A, 2  
76e1 cd d0 77		            CALL LCDDelay       ;Delay 2 ms to complete   
76e4 f1			            POP  AF  
76e5 c9			            RET  
76e6			Wr4bits:   
76e6 f5					push af  
76e7 3a 06 fb				ld a, (display_lcde1e2)  
76ea fe 00				cp 0     ; e  
76ec 20 10				jr nz, .wea2	  
76ee f1					pop af  
76ef e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
76f1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
76f3 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
76f5 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
76f7 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
76f9 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
76fb d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
76fd c9			            RET  
76fe f1			.wea2:		pop af  
76ff e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7701 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7703 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
7705 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
7707 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7709 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
770b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
770d c9			            RET  
770e			  
770e			  
770e			; Write data to LCD  
770e			;   On entry: A = Data byte to be written  
770e			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
770e f5			fLCD_Data:  PUSH AF  
770f f5			            PUSH AF  
7710 cd 22 77		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
7713 f1			            POP  AF  
7714 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7715 17			            RLA  
7716 17			            RLA  
7717 17			            RLA  
7718 cd 22 77		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
771b 3e 96		            LD   A, 150  
771d 3d			Wait:      DEC  A              ;Wait a while to allow data   
771e 20 fd		            JR   NZ, Wait      ;  write to complete  
7720 f1			            POP  AF  
7721 c9			            RET  
7722			Wr4bitsa:     
7722 f5					push af  
7723 3a 06 fb				ld a, (display_lcde1e2)  
7726 fe 00				cp 0     ; e1  
7728 20 16				jr nz, .we2	  
772a f1					pop af  
772b e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
772d cb d7		            SET  kLCDBitRS, A  
772f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7731 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
7733 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
7735 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7737 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
7739 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
773b cb 97		            RES  kLCDBitRS, A  
773d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
773f c9			            RET  
7740 f1			.we2:		pop af  
7741 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7743 cb d7		            SET  kLCDBitRS, A  
7745 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7747 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
7749 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
774b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
774d cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
774f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7751 cb 97		            RES  kLCDBitRS, A  
7753 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7755 c9			            RET  
7756			  
7756			  
7756			; Position cursor to specified location  
7756			;   On entry: A = Cursor position  
7756			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7756 f5			fLCD_Pos:   PUSH AF  
7757					; at this point set the E1 or E2 flag depending on position  
7757			  
7757 c5					push bc  
7758			;		push af  
7758 06 00				ld b, 0  
775a 4f					ld c, a  
775b 3e 4f				ld a, kLCD_Line3-1  
775d b7			 		or a      ;clear carry flag  
775e 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
775f 38 04				jr c, .pe1  
7761			  
7761					; E selection  
7761 cb 80				res 0, b         ; bit 0 unset e  
7763			;		pop af    ; before line 3 so recover orig pos  
7763			;		ld c, a    ; save for poking back  
7763 18 06				jr .peset	          
7765			.pe1:          	; E2 selection  
7765 cb c0				set 0, b         ; bit 0 set e1  
7767 79					ld a, c  
7768 de 4f				sbc a, kLCD_Line3-1  
776a 4f					ld c, a	         ; save caculated offset  
776b			;		pop af     ; bin this original value now we have calculated form  
776b			  
776b			.peset:		; set bit  
776b 78					ld a, b  
776c 32 06 fb				ld (display_lcde1e2), a 	  
776f 79					ld a, c  
7770 c1					pop bc  
7771			  
7771 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
7773 cd d2 76		            CALL fLCD_Inst      ;Write instruction to LCD  
7776 f1			            POP  AF  
7777 c9			            RET  
7778			  
7778			  
7778			; Output text string to LCD  
7778			;   On entry: DE = Pointer to null terminated text string  
7778			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
7778 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
7779 b7			            OR   A              ;Null terminator?  
777a c8			            RET  Z              ;Yes, so finished  
777b cd 0e 77		            CALL fLCD_Data      ;Write character to display  
777e 13			            INC  DE             ;Point to next character  
777f 18 f7		            JR   fLCD_Str       ;Repeat  
7781 c9					ret  
7782			  
7782			; Define custom character  
7782			;   On entry: A = Character number (0 to 7)  
7782			;             DE = Pointer to character bitmap data  
7782			;   On exit:  A = Next character number  
7782			;             DE = Next location following bitmap  
7782			;             BC HL IX IY I AF' BC' DE' HL' preserved  
7782			; Character is   
7782 c5			fLCD_Def:   PUSH BC  
7783 f5			            PUSH AF  
7784 07			            RLCA                ;Calculate location  
7785 07			            RLCA                ;  for bitmap data  
7786 07			            RLCA                ;  = 8 x CharacterNumber  
7787 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
7789 cd d2 76		            CALL fLCD_Inst      ;Write instruction to LCD  
778c 06 00		            LD   B, 0  
778e 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
778f cd 0e 77		            CALL fLCD_Data      ;Write byte to display  
7792 13			            INC  DE             ;Point to next byte  
7793 04			            INC  B              ;Count bytes  
7794 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
7796 28 f6		            JR   Z, Loop       ;No, so repeat  
7798 f1			            POP  AF  
7799 3c			            INC  A              ;Increment character number  
779a c1			            POP  BC  
779b c9			            RET  
779c			  
779c			  
779c			; **********************************************************************  
779c			; **  Private functions  
779c			; **********************************************************************  
779c			  
779c			; Write function to LCD  
779c			;   On entry: A = Function byte to be written  
779c			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
779c 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
779e 18 02		            JR   WrFunc  
77a0 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
77a2 f5			WrFunc:     PUSH AF  
77a3 f5					push af  
77a4 3a 06 fb				ld a, (display_lcde1e2)  
77a7 fe 00				cp 0     ; e1  
77a9 20 0f				jr nz, .wfea2	  
77ab f1					pop af  
77ac d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77ae cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
77b0 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
77b2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
77b4 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
77b6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77b8 18 0d			jr .wfskip  
77ba f1			.wfea2:		pop af  
77bb d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77bd cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
77bf cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
77c1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
77c3 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
77c5 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
77c7 3e 05		.wfskip:            LD  A, 5  
77c9 cd d0 77		            CALL LCDDelay       ;Delay 5 ms to complete  
77cc f1			            POP  AF  
77cd c9			            RET  
77ce			  
77ce			  
77ce			; Delay in milliseconds  
77ce			;   On entry: A = Number of milliseconds delay  
77ce			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
77ce 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
77d0 d5			LCDDelay:   PUSH DE  
77d1 5f			            LD   E, A           ;Delay by 'A' ms  
77d2 16 00		            LD   D, 0  
77d4 cd c3 0c		            CALL aDelayInMS  
77d7 d1			            POP  DE  
77d8 c9			            RET  
77d9			  
77d9			  
77d9			testlcd:  
77d9 3e 00			ld a, kLCD_Line1  
77db cd 56 77			call fLCD_Pos  
77de 06 28			ld b, 40  
77e0 11 0e 78			ld de, .ttext1  
77e3 cd a1 76			call write_len_string  
77e6			  
77e6 3e 28			ld a, kLCD_Line2  
77e8 cd 56 77			call fLCD_Pos  
77eb 06 28			ld b, 40  
77ed 11 37 78			ld de, .ttext2  
77f0 cd a1 76			call write_len_string  
77f3 3e 50			ld a, kLCD_Line3  
77f5 cd 56 77			call fLCD_Pos  
77f8 06 28			ld b, 40  
77fa 11 60 78			ld de, .ttext3  
77fd cd a1 76			call write_len_string  
7800 3e 78			ld a, kLCD_Line4  
7802 cd 56 77			call fLCD_Pos  
7805 06 28			ld b, 40  
7807 11 89 78			ld de, .ttext4  
780a cd a1 76			call write_len_string  
780d			  
780d 76				halt  
780e			  
780e			  
780e .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
7837 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
7860 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
7889 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
78b2			   
78b2			  
78b2			  
78b2			; eof  
78b2			  
# End of file firmware_lcd_4x40.asm
78b2			;include "firmware_lcd_4x20.asm" 
78b2			include "firmware_key_5x10.asm" 
78b2			; 5 x 10 decade counter scanner  
78b2			  
78b2			  
78b2			; TODO do cursor shape change for shift keys  
78b2			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
78b2			  
78b2			  
78b2			; bit mask for each scan column and row for teing the matrix  
78b2			  
78b2			  
78b2			key_init:  
78b2			  
78b2			; SCMonAPI functions used  
78b2			  
78b2			; Alphanumeric LCD functions used  
78b2			; no need to specify specific functions for this module  
78b2			  
78b2			  
78b2 3e cf		            LD   A, 11001111b  
78b4 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
78b6			;            LD   A, 00000000b  
78b6 3e 1f		            LD   A, 00011111b  
78b8 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
78ba			  
78ba			  
78ba				; TODO Configure cursor shapes  
78ba			  
78ba				; Load cursor shapes   
78ba 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
78bc 11 cc 78		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
78bf 06 02		            LD   B, 2           ;Number of characters to define  
78c1 cd 82 77		.DefLoop:   CALL fLCD_Def       ;Define custom character  
78c4 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
78c6			  
78c6 3e 01				ld a, 1  
78c8 32 fc fa			ld (cursor_shape),a  
78cb c9				ret  
78cc			  
78cc			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
78cc			; Up to 8 custom characters can be defined  
78cc			.cursor_shapes:      
78cc			;; Character 0x00 = Normal  
78cc 1f			            DB  11111b  
78cd 1f			            DB  11111b  
78ce 1f			            DB  11111b  
78cf 1f			            DB  11111b  
78d0 1f			            DB  11111b  
78d1 1f			            DB  11111b  
78d2 1f			            DB  11111b  
78d3 1f			            DB  11111b  
78d4			;; Character 0x01 = Modifier  
78d4 1f			            DB  11111b  
78d5 1b			            DB  11011b  
78d6 1b			            DB  11011b  
78d7 1b			            DB  11011b  
78d8 1b			            DB  11011b  
78d9 1f			            DB  11111b  
78da 1b			            DB  11011b  
78db 1f			            DB  11111b  
78dc			  
78dc			  
78dc			  
78dc			  
78dc			; Display custom character 0  
78dc			;            LD   A, kLCD_Line1+14  
78dc			;            CALL fLCD_Pos       ;Position cursor to location in A  
78dc			;            LD   A, 0  
78dc			;            CALL fLCD_Data      ;Write character in A at cursor  
78dc			  
78dc			; Display custom character 1  
78dc			;            LD   A, kLCD_Line2+14  
78dc			;            CALL fLCD_Pos      ;Position cursor to location in A  
78dc			;            LD   A, 1  
78dc			;            CALL fLCD_Data     ;Write character in A at cursor  
78dc			  
78dc			; keyboard scanning   
78dc			  
78dc			; character in from keyboard  
78dc			  
78dc			; mapping for the pcb layout  
78dc			  
78dc			.matrix_to_char:  
78dc .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
78e7 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
78f2 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
78fd 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7908 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
7913			.matrix_to_shift:  
7913			  
7913 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
791e .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
7929 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
7934 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
793f .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
794a			  
794a			.matrix_to_symbolshift:  
794a			  
794a fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7955 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
7960 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
796b			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
796b 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
7976 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
7981			  
7981			  
7981			  
7981			; mapping for a simple straight through breadboard layout  
7981			  
7981			;.matrix_to_char:  
7981			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7981			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
7981			;		db "asdfghjkl",KEY_CR,0  
7981			;		db "qwertyuiop",0  
7981			;		 db "1234567890",0  
7981			;.matrix_to_shift:  
7981			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
7981			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
7981			;		db "ASDFGHJKL",KEY_CR,0  
7981			;		db "QWERTYUIOP",0  
7981			;		 db "!",'"',"#$%^&*()",0  
7981			;.matrix_to_symbolshift:  
7981			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7981			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
7981			;		db "_?*fghjk=",KEY_CR,0  
7981			;		db "-/+*[]{}@#",0  
7981			;		 db "1234567890",0  
7981			  
7981			;.matrix_to_char: db "D#0*C987B654A321"  
7981			  
7981			  
7981				  
7981			  
7981			; add cin and cin_wait  
7981			  
7981 cd 92 79		cin_wait: 	call cin  
7984						if DEBUG_KEYCINWAIT  
7984							push af  
7984							  
7984							ld hl,key_repeat_ct  
7984							ld (hl),a  
7984							inc hl  
7984							call hexout  
7984							ld hl,key_repeat_ct+3  
7984							ld a,0  
7984							ld (hl),a  
7984			  
7984							    LD   A, kLCD_Line1+11  
7984							    CALL fLCD_Pos       ;Position cursor to location in A  
7984							    LD   DE, key_repeat_ct  
7984							    ;LD   DE, MsgHello  
7984							    CALL fLCD_Str       ;Display string pointed to by DE  
7984			  
7984			  
7984			  
7984							pop af  
7984						endif  
7984 fe 00			cp 0  
7986 28 f9			jr z, cin_wait   ; block until key press  
7988			  
7988							if DEBUG_KEYCINWAIT  
7988								push af  
7988			  
7988								ld a, 'A'	  
7988								ld hl,key_repeat_ct  
7988								ld (hl),a  
7988								inc hl  
7988								ld a,0  
7988								ld (hl),a  
7988			  
7988								    LD   A, kLCD_Line2+11  
7988								    CALL fLCD_Pos       ;Position cursor to location in A  
7988								    LD   DE, key_repeat_ct  
7988								    ;LD   DE, MsgHello  
7988								    CALL fLCD_Str       ;Display string pointed to by DE  
7988			  
7988							call delay500ms  
7988			  
7988								pop af  
7988							endif  
7988 f5				push af   ; save key pressed  
7989			  
7989			.cin_wait1:	  
7989							if DEBUG_KEYCINWAIT  
7989								push af  
7989			  
7989								ld a, 'b'	  
7989								ld hl,key_repeat_ct  
7989								ld (hl),a  
7989								inc hl  
7989								ld a,0  
7989								ld (hl),a  
7989			  
7989								    LD   A, kLCD_Line2+11  
7989								    CALL fLCD_Pos       ;Position cursor to location in A  
7989								    LD   DE, key_repeat_ct  
7989								    ;LD   DE, MsgHello  
7989								    CALL fLCD_Str       ;Display string pointed to by DE  
7989			  
7989			  
7989							call delay500ms  
7989			  
7989								pop af  
7989							endif  
7989			  
7989 cd 92 79		call cin  
798c fe 00			cp 0  
798e 20 f9			jr nz, .cin_wait1  	; wait for key release  
7990			if DEBUG_KEYCINWAIT  
7990				push af  
7990			  
7990				ld a, '3'	  
7990				ld hl,key_repeat_ct  
7990				ld (hl),a  
7990				inc hl  
7990				ld a,0  
7990				ld (hl),a  
7990			  
7990			            LD   A, kLCD_Line2+11  
7990			            CALL fLCD_Pos       ;Position cursor to location in A  
7990			            LD   DE, key_repeat_ct  
7990			            ;LD   DE, MsgHello  
7990			            CALL fLCD_Str       ;Display string pointed to by DE  
7990			  
7990			  
7990			call delay500ms  
7990			  
7990				pop af  
7990			endif  
7990			  
7990 f1				pop af   ; get key  
7991 c9				ret  
7992			  
7992			  
7992 cd a6 79		cin: 	call .mtoc  
7995			  
7995			if DEBUG_KEYCIN  
7995				push af  
7995				  
7995				ld hl,key_repeat_ct  
7995				ld (hl),a  
7995				inc hl  
7995				call hexout  
7995				ld hl,key_repeat_ct+3  
7995				ld a,0  
7995				ld (hl),a  
7995			  
7995			            LD   A, kLCD_Line3+15  
7995			            CALL fLCD_Pos       ;Position cursor to location in A  
7995			            LD   DE, key_repeat_ct  
7995			            ;LD   DE, MsgHello  
7995			            CALL fLCD_Str       ;Display string pointed to by DE  
7995			  
7995			  
7995			call delay500ms  
7995			  
7995				pop af  
7995			endif  
7995			  
7995			  
7995				; no key held  
7995 fe 00			cp 0  
7997 c8				ret z  
7998			  
7998			if DEBUG_KEYCIN  
7998				push af  
7998			  
7998				ld a, '1'	  
7998				ld hl,key_repeat_ct  
7998				ld (hl),a  
7998				inc hl  
7998				ld a,0  
7998				ld (hl),a  
7998			  
7998			            LD   A, kLCD_Line4+15  
7998			            CALL fLCD_Pos       ;Position cursor to location in A  
7998			            LD   DE, key_repeat_ct  
7998			            ;LD   DE, MsgHello  
7998			            CALL fLCD_Str       ;Display string pointed to by DE  
7998			  
7998			  
7998			call delay500ms  
7998			  
7998				pop af  
7998			endif  
7998			  
7998				; stop key bounce  
7998			  
7998 32 c6 fd			ld (key_held),a		 ; save it  
799b 47				ld b, a  
799c			  
799c c5			.cina1:	push bc  
799d			if DEBUG_KEYCIN  
799d				push af  
799d			  
799d				ld hl,key_repeat_ct  
799d				inc hl  
799d				call hexout  
799d				ld hl,key_repeat_ct+3  
799d				ld a,0  
799d				ld (hl),a  
799d				ld hl,key_repeat_ct  
799d				ld a, '2'	  
799d				ld (hl),a  
799d			  
799d			            LD   A, kLCD_Line4+15  
799d			            CALL fLCD_Pos       ;Position cursor to location in A  
799d			            LD   DE, key_repeat_ct  
799d			            ;LD   DE, MsgHello  
799d			            CALL fLCD_Str       ;Display string pointed to by DE  
799d			  
799d				pop af  
799d			endif  
799d cd a6 79			call .mtoc  
79a0 c1				pop bc  
79a1 b8				cp b  
79a2 28 f8			jr z, .cina1  
79a4 78				ld a,b		  
79a5			if DEBUG_KEYCIN  
79a5				push af  
79a5			  
79a5				ld hl,key_repeat_ct  
79a5				inc hl  
79a5				call hexout  
79a5				ld hl,key_repeat_ct+3  
79a5				ld a,0  
79a5				ld (hl),a  
79a5				ld hl,key_repeat_ct  
79a5				ld a, '3'	  
79a5				ld (hl),a  
79a5			  
79a5			            LD   A, kLCD_Line4+15  
79a5			            CALL fLCD_Pos       ;Position cursor to location in A  
79a5			            LD   DE, key_repeat_ct  
79a5			            ;LD   DE, MsgHello  
79a5			            CALL fLCD_Str       ;Display string pointed to by DE  
79a5			  
79a5				pop af  
79a5			endif  
79a5 c9				ret  
79a6			  
79a6			; detect keyboard modifier key press and apply new overlay to the face key held  
79a6			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
79a6			  
79a6			;.cin_map_modifier:   
79a6			;	ld a, (hl)  
79a6			;	and 255  
79a6			;	ret NZ		; modifier key not flagged  
79a6			;  
79a6			;	; get key face  
79a6			;  
79a6			;	ld b,(key_face_held)  
79a6			;  
79a6			;	ld b, key_cols * key_rows  
79a6			;  
79a6			;	push de  
79a6			;	pop hl  
79a6			;  
79a6			;.mmod1: ld a,(hl)   ; get map test  
79a6			;	cp b  
79a6			;	jr z, .mmod2  
79a6			;  
79a6			;  
79a6			;  
79a6			;.mmod2: inc hl    ;   
79a6			;  
79a6			;	  
79a6			;  
79a6			;	  
79a6			;  
79a6			;	ld hl,key_actual_pressed  
79a6			;	ld (hl),a,  
79a6			;	ret  
79a6			  
79a6			; map matrix key held to char on face of key  
79a6			  
79a6			.mtoc:  
79a6			  
79a6			; test decade counter strobes  
79a6			  
79a6			;.decadetest1:  
79a6			  
79a6			; reset counter  
79a6			;ld a, 128  
79a6			;out (portbdata),a  
79a6			  
79a6			  
79a6			;ld b, 5  
79a6			;.dec1:  
79a6			;ld a, 0  
79a6			;out (portbdata),a  
79a6			;call delay1s  
79a6			  
79a6			;ld a, 32  
79a6			;out (portbdata),a  
79a6			;call delay1s  
79a6			;call delay1s  
79a6			;call delay1s  
79a6			;  
79a6			;ld a, 64+32  
79a6			;out (portbdata),a  
79a6			;call delay1s  
79a6			;;djnz .dec1  
79a6			;  
79a6			;jp .decadetest1  
79a6			  
79a6			  
79a6			  
79a6			  
79a6			  
79a6			  
79a6			  
79a6			  
79a6			  
79a6			  
79a6				; scan keyboard matrix and generate raw scan map  
79a6 cd 39 7a			call matrix  
79a9			  
79a9				; reuse c bit 0 left modifer button - ie shift  
79a9			        ; reuse c bit 1 for right modifer button - ie symbol shift  
79a9				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
79a9			  
79a9 0e 00			ld c, 0  
79ab			  
79ab				; TODO set flags for modifer key presses   
79ab				; TODO do a search for modifer key...  
79ab			  
79ab				;ld hl,keyscan_table_row4  
79ab 21 25 fe			ld hl,keyscan_table_row2  
79ae			  
79ae 7e				ld a, (hl)  
79af fe 23			cp '#'  
79b1 20 07			jr nz, .nextmodcheck  
79b3 cb c1			set 0, c  
79b5 21 13 79			ld hl, .matrix_to_shift  
79b8 18 21			jr .dokeymap  
79ba				; TODO for now igonre  
79ba			.nextmodcheck:  
79ba 21 1a fe			ld hl,keyscan_table_row3  
79bd			  
79bd 7e				ld a, (hl)  
79be fe 23			cp '#'  
79c0 20 07			jr nz, .nextmodcheck2  
79c2 cb c9			set 1, c   
79c4 21 4a 79			ld hl, .matrix_to_symbolshift  
79c7 18 12			jr .dokeymap  
79c9			.nextmodcheck2:  
79c9 21 2e fe			ld hl,keyscan_table_row2+9    ; right shift  
79cc			  
79cc 7e				ld a, (hl)  
79cd fe 23			cp '#'  
79cf 20 07			jr nz, .donemodcheck  
79d1 cb c9			set 1, c   
79d3 21 13 79			ld hl, .matrix_to_shift  
79d6 18 03			jr .dokeymap  
79d8			  
79d8				; no modifer found so just map to normal keys  
79d8				; get mtoc map matrix to respective keys  
79d8			;	ld hl, .matrix_to_char  
79d8			;	ld hl, .matrix_to_char  
79d8			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
79d8			;	ld a, KEY_SHIFT  
79d8			;	call findchar  
79d8			;  
79d8			;	; got offset to key modifer in b  
79d8			;  
79d8			;	ld hl,keyscan_table_row5  
79d8			;  
79d8			;	ld a,b  
79d8			;	call addatohl  
79d8			;	ld a,(hl)  
79d8			;  
79d8			;	cp '#'  
79d8			;	jr nz, .nextmodcheck  
79d8			;	set 0, c  
79d8			;	ld hl, .matrix_to_char  
79d8			;	jr .dokeymap  
79d8			;	; TODO for now igonre  
79d8			;.nextmodcheck:  
79d8			;	ld hl, .matrix_to_symbolshift  
79d8			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
79d8			;	ld a, KEY_SYMBOLSHIFT  
79d8			;	call findchar  
79d8			;  
79d8			;  
79d8			;	; got offset to key modifer in b  
79d8			;  
79d8			;	ld hl,keyscan_table_row5  
79d8			;  
79d8			;	ld a,b  
79d8			;	call addatohl  
79d8			;	ld a,(hl)  
79d8			;  
79d8			;	cp '#'  
79d8			;	jr nz, .donemodcheck  
79d8			;	set 1, c   
79d8			;	ld hl, .matrix_to_symbolshift  
79d8			;	jr .dokeymap  
79d8			  
79d8			  
79d8			  
79d8			.donemodcheck:  
79d8				; no modifer found so just map to normal keys  
79d8				; get mtoc map matrix to respective keys  
79d8 21 dc 78			ld hl, .matrix_to_char  
79db			  
79db			.dokeymap:  
79db				;ld (key_fa), c   
79db cd f4 79			call .mapkeys  
79de			  
79de			  
79de			if DEBUG_KEY  
79de			  
79de			; Display text on first line  
79de			            LD   A, kLCD_Line1  
79de			            CALL fLCD_Pos       ;Position cursor to location in A  
79de			            LD   DE, keyscan_table_row1  
79de			            ;LD   DE, MsgHello  
79de			            CALL fLCD_Str       ;Display string pointed to by DE  
79de			  
79de			; Display text on second line  
79de			            LD   A, kLCD_Line2  
79de			            CALL fLCD_Pos       ;Position cursor to location in A  
79de			            LD   DE, keyscan_table_row2  
79de			            CALL fLCD_Str       ;Display string pointed to by DE  
79de			            LD   A, kLCD_Line3  
79de			            CALL fLCD_Pos       ;Position cursor to location in A  
79de			            LD   DE, keyscan_table_row3  
79de			            CALL fLCD_Str       ;Display string pointed to by DE  
79de			            LD   A, kLCD_Line4  
79de			            CALL fLCD_Pos       ;Position cursor to location in A  
79de			            LD   DE, keyscan_table_row4  
79de			            CALL fLCD_Str       ;Display string pointed to by DE  
79de			            LD   A, kLCD_Line1+10  
79de			            CALL fLCD_Pos       ;Position cursor to location in A  
79de			            LD   DE, keyscan_table_row5  
79de			            CALL fLCD_Str       ;Display string pointed to by DE  
79de			  
79de				;call delay250ms  
79de			endif  
79de			;	jp testkey  
79de			  
79de			; get first char reported  
79de			  
79de 21 04 fe			ld hl,keyscan_table_row5  
79e1			  
79e1				;ld b, 46   ; 30 keys to remap + 8 nulls   
79e1 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
79e3			.findkey:  
79e3 7e				ld a,(hl)  
79e4 fe 00			cp 0  
79e6 28 04			jr z, .nextkey  
79e8 fe 7e			cp KEY_MATRIX_NO_PRESS  
79ea 20 06			jr nz, .foundkey  
79ec			.nextkey:  
79ec 23				inc hl  
79ed 10 f4			djnz .findkey  
79ef 3e 00			ld a,0  
79f1 c9				ret  
79f2			.foundkey:  
79f2 7e				ld a,(hl)  
79f3 c9				ret  
79f4				  
79f4			  
79f4			; convert the raw key map given hl for destination key  
79f4			.mapkeys:  
79f4 11 04 fe			ld de,keyscan_table_row5  
79f7			  
79f7 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
79f9			.remap:  
79f9 1a				ld a,(de)  
79fa fe 23			cp '#'  
79fc 20 02			jr nz, .remapnext  
79fe				;CALLMONITOR  
79fe 7e				ld a,(hl)  
79ff 12				ld (de),a  
7a00			  
7a00			  
7a00			  
7a00			.remapnext:  
7a00 23				inc hl  
7a01 13				inc de  
7a02 10 f5			djnz .remap  
7a04				  
7a04 c9				ret  
7a05			  
7a05			  
7a05			  
7a05			.mtocold2:  
7a05			  
7a05			;	; flag if key D is held down and remove from reporting  
7a05			;	ld bc, .key_map_fd    
7a05			;	ld hl, keyscan_table  
7a05			;	ld de, key_fd  
7a05			;	call .key_shift_hold  
7a05			;	cp 255  
7a05			;	jr z, .cinmap  
7a05			;	; flag if key C is held down and remove from reporting  
7a05			;	ld bc, .key_map_fc    
7a05			;	ld hl, keyscan_table+key_cols  
7a05			;	ld de, key_fc  
7a05			;	call .key_shift_hold  
7a05			;	cp 255  
7a05			;	jr z, .cinmap  
7a05			;	; flag if key B is held down and remove from reporting  
7a05			;	ld bc, .key_map_fb    
7a05			;	ld hl, keyscan_table+(key_cols*2)  
7a05			;	ld de, key_fb  
7a05			;	call .key_shift_hold  
7a05			;	cp 255  
7a05			;	jr z, .cinmap  
7a05			;	; flag if key A is held down and remove from reporting  
7a05			;	ld bc, .key_map_fa    
7a05			;	ld hl, keyscan_table+(key_cols*3)  
7a05			;	ld de, key_fa  
7a05			;	call .key_shift_hold  
7a05			;	cp 255  
7a05			;	jr z, .cinmap  
7a05			  
7a05 11 dc 78			ld de, .matrix_to_char  
7a08			  
7a08			  
7a08			.cinmap1:   
7a08				if DEBUG_KEY  
7a08			            LD   A, kLCD_Line4  
7a08			            CALL fLCD_Pos       ;Position cursor to location in A  
7a08					push de  
7a08			            LD   DE, keyscan_table  
7a08			            CALL fLCD_Str       ;Display string pointed to by DE  
7a08					pop de  
7a08				endif  
7a08			  
7a08				; scan key matrix table for any held key  
7a08			  
7a08				; de holds either the default matrix or one selected above  
7a08			  
7a08 21 d1 fd			ld hl, keyscan_table  
7a0b 06 32			ld b,key_cols*key_rows  
7a0d			  
7a0d 7e			.cin11:	ld a,(hl)  
7a0e fe 23			cp '#'  
7a10 28 08			jr z, .cinhit1  
7a12 23				inc hl  
7a13 13				inc de  
7a14 05				dec b  
7a15 20 f6			jr nz, .cin11  
7a17				; no key found held  
7a17 3e 00			ld a,0  
7a19 c9				ret  
7a1a d5			.cinhit1: push de  
7a1b e1				pop hl  
7a1c 7e				ld a,(hl)  
7a1d c9				ret  
7a1e			  
7a1e			; flag a control key is held   
7a1e			; hl is key pin, de is flag indicator  
7a1e			  
7a1e			.key_shift_hold1:  
7a1e c5				push bc  
7a1f 3e 01			ld a, 1  
7a21 32 fc fa			ld (cursor_shape),a  
7a24 06 00			ld b, 0  
7a26 7e				ld a, (hl)  
7a27 fe 2e			cp '.'  
7a29 28 0a			jr z, .key_shift11  
7a2b 06 ff			ld b, 255  
7a2d 3e 2b			ld a, '+'    ; hide key from later scans  
7a2f 77				ld (hl),a  
7a30 3e 02			ld a, 2  
7a32 32 fc fa			ld (cursor_shape),a  
7a35			.key_shift11:  
7a35				; write flag indicator  
7a35 78				ld a,b  
7a36 12				ld (de),a  
7a37			  
7a37 d1				pop de    ; de now holds the key map ptr  
7a38 c9				ret  
7a39			  
7a39				  
7a39			  
7a39			; scans keyboard matrix and flags key press in memory array	  
7a39				  
7a39			matrix:  
7a39				;call matrix  
7a39				; TODO optimise the code....  
7a39			  
7a39			  
7a39			;ld hl, keyscan_table_row1  
7a39			;ld de, keyscan_table_row1+1  
7a39			;ld bc,46  
7a39			;ld a,KEY_MATRIX_NO_PRESS  
7a39			;ldir  
7a39			  
7a39			  
7a39			  
7a39			; reset counter  
7a39 3e 80		ld a, 128  
7a3b d3 c1		out (portbdata),a  
7a3d			  
7a3d 06 0a		ld b, 10  
7a3f 0e 00		ld c, 0       ; current clock toggle  
7a41			  
7a41			.colscan:  
7a41			  
7a41			; set current column  
7a41			; disable clock enable and set clock low  
7a41			  
7a41			;ld a, 0  
7a41			;out (portbdata),a  
7a41			  
7a41			; For each column scan for switches  
7a41			  
7a41 c5			push bc  
7a42 21 c7 fd		ld hl, keyscan_scancol  
7a45 cd 4e 7b		call .rowscan  
7a48 c1			pop bc  
7a49			  
7a49			  
7a49			; get back current column  
7a49			  
7a49			; translate the row scan  
7a49			  
7a49			;   
7a49			; row 1  
7a49			  
7a49 78			ld a,b  
7a4a			  
7a4a 21 3a fe		LD   hl, keyscan_table_row1+10  
7a4d			  
7a4d cd e1 0f		call subafromhl  
7a50			;call addatohl  
7a50			  
7a50 11 c7 fd		ld de, keyscan_scancol  
7a53			  
7a53 1a			ld a,(de)  
7a54 77			ld (hl),a  
7a55			  
7a55			  
7a55			  
7a55			  
7a55			; row 2  
7a55			  
7a55 78			ld a,b  
7a56			  
7a56 21 2f fe		LD   hl, keyscan_table_row2+10  
7a59			  
7a59			;call addatohl  
7a59 cd e1 0f		call subafromhl  
7a5c			  
7a5c			  
7a5c 11 c8 fd		ld de, keyscan_scancol+1  
7a5f			  
7a5f 1a			ld a,(de)  
7a60 77			ld (hl),a  
7a61			  
7a61			  
7a61			; row 3  
7a61			  
7a61 78			ld a,b  
7a62			  
7a62 21 24 fe		LD   hl, keyscan_table_row3+10  
7a65			  
7a65			;call addatohl  
7a65 cd e1 0f		call subafromhl  
7a68			  
7a68 11 c9 fd		ld de, keyscan_scancol+2  
7a6b			  
7a6b 1a			ld a,(de)  
7a6c 77			ld (hl),a  
7a6d			  
7a6d			  
7a6d			  
7a6d			; row 4  
7a6d			  
7a6d 78			ld a,b  
7a6e			  
7a6e 21 19 fe		LD   hl, keyscan_table_row4+10  
7a71			  
7a71			;call addatohl  
7a71 cd e1 0f		call subafromhl  
7a74			  
7a74 11 ca fd		ld de, keyscan_scancol+3  
7a77			  
7a77 1a			ld a,(de)  
7a78 77			ld (hl),a  
7a79			  
7a79			; row 5  
7a79			  
7a79 78			ld a,b  
7a7a			  
7a7a 21 0e fe		LD   hl, keyscan_table_row5+10  
7a7d			  
7a7d			;call addatohl  
7a7d cd e1 0f		call subafromhl  
7a80			  
7a80 11 cb fd		ld de, keyscan_scancol+4  
7a83			  
7a83 1a			ld a,(de)  
7a84 77			ld (hl),a  
7a85			  
7a85			; handshake next column  
7a85			  
7a85			  
7a85 3e 40		ld a, 64  
7a87 d3 c1		out (portbdata),a  
7a89			  
7a89 3e 00		ld a, 0  
7a8b d3 c1		out (portbdata),a  
7a8d			  
7a8d			; toggle clk and move to next column  
7a8d			;ld a, 64  
7a8d			;cp c  
7a8d			;  
7a8d			;jr z, .coltoglow  
7a8d			;ld c, a  
7a8d			;jr .coltog  
7a8d			;.coltoglow:  
7a8d			;ld c, 0  
7a8d			;.coltog:  
7a8d			;ld a, c  
7a8d			;out (portbdata),a  
7a8d			  
7a8d 10 b2		djnz .colscan  
7a8f			  
7a8f 3e 0a		ld a,10  
7a91 21 30 fe		LD   hl, keyscan_table_row1  
7a94 cd cf 0f		call addatohl  
7a97 3e 00		ld a, 0  
7a99 77			ld (hl), a  
7a9a			  
7a9a			  
7a9a 3e 0a		ld a,10  
7a9c 21 25 fe		LD   hl, keyscan_table_row2  
7a9f cd cf 0f		call addatohl  
7aa2 3e 00		ld a, 0  
7aa4 77			ld (hl), a  
7aa5			  
7aa5 3e 0a		ld a,10  
7aa7 21 1a fe		LD   hl, keyscan_table_row3  
7aaa cd cf 0f		call addatohl  
7aad 3e 00		ld a, 0  
7aaf 77			ld (hl), a  
7ab0			  
7ab0 3e 0a		ld a,10  
7ab2 21 0f fe		LD   hl, keyscan_table_row4  
7ab5 cd cf 0f		call addatohl  
7ab8 3e 00		ld a, 0  
7aba 77			ld (hl), a  
7abb			  
7abb 3e 0a		ld a,10  
7abd 21 04 fe		LD   hl, keyscan_table_row5  
7ac0 cd cf 0f		call addatohl  
7ac3 3e 00		ld a, 0  
7ac5 77			ld (hl), a  
7ac6			  
7ac6			if DEBUG_KEY_MATRIX  
7ac6			  
7ac6			; Display text on first line  
7ac6			            LD   A, kLCD_Line1  
7ac6			            CALL fLCD_Pos       ;Position cursor to location in A  
7ac6			            LD   DE, keyscan_table_row1  
7ac6			            ;LD   DE, MsgHello  
7ac6			            CALL fLCD_Str       ;Display string pointed to by DE  
7ac6			  
7ac6			; Display text on second line  
7ac6			            LD   A, kLCD_Line2  
7ac6			            CALL fLCD_Pos       ;Position cursor to location in A  
7ac6			            LD   DE, keyscan_table_row2  
7ac6			            CALL fLCD_Str       ;Display string pointed to by DE  
7ac6			            LD   A, kLCD_Line3  
7ac6			            CALL fLCD_Pos       ;Position cursor to location in A  
7ac6			            LD   DE, keyscan_table_row3  
7ac6			            CALL fLCD_Str       ;Display string pointed to by DE  
7ac6			            LD   A, kLCD_Line4  
7ac6			            CALL fLCD_Pos       ;Position cursor to location in A  
7ac6			            LD   DE, keyscan_table_row4  
7ac6			            CALL fLCD_Str       ;Display string pointed to by DE  
7ac6			            LD   A, kLCD_Line4+10  
7ac6			            CALL fLCD_Pos       ;Position cursor to location in A  
7ac6			            LD   DE, keyscan_table_row5  
7ac6			            CALL fLCD_Str       ;Display string pointed to by DE  
7ac6			  
7ac6			;call delay250ms  
7ac6				jp matrix  
7ac6			endif  
7ac6 c9			ret  
7ac7			  
7ac7			; using decade counter....  
7ac7			  
7ac7			  
7ac7			; TODO reset decade counter to start of scan  
7ac7			  
7ac7			; reset 15  
7ac7			; clock 14  
7ac7			; ce 13  
7ac7			  
7ac7			; 1 - q5  
7ac7			; 2 - q1  
7ac7			; 3 - q0  
7ac7			; 4 - q2  
7ac7			; 5 - q6  
7ac7			; 6 - q7  
7ac7			; 7 - q3  
7ac7			; 8 - vss  
7ac7			; 9 - q8  
7ac7			; 10 - q4  
7ac7			; 11 - q9  
7ac7			; 12 - cout  
7ac7			; 16 - vdd  
7ac7			  
7ac7			; clock      ce       reset     output  
7ac7			; 0          x        0         n  
7ac7			; x          1        0         n  
7ac7			; x          x        1         q0  
7ac7			; rising     0        0         n+1  
7ac7			; falling    x        0         n  
7ac7			; x          rising   0         n  
7ac7			; 1          falling  0         x+1  
7ac7			;  
7ac7			; x = dont care, if n < 5 carry = 1 otherwise 0  
7ac7			  
7ac7			;   
7ac7			; reset   
7ac7			; 13=0, 14=0, 15=1 .. 15=0  
7ac7			;  
7ac7			; handshake line  
7ac7			; 14=1.... read line 14=0  
7ac7			  
7ac7			  
7ac7			  
7ac7			  
7ac7			  
7ac7			; TODO hand shake clock for next column scan  
7ac7			; TODO detect each row  
7ac7			  
7ac7			  
7ac7			  
7ac7			  
7ac7			; reset 128  
7ac7			; clock 64  
7ac7			; ce 32  
7ac7			  
7ac7			  
7ac7			.cyclestart:  
7ac7			  
7ac7			; reset counter  
7ac7 3e 80		ld a, 128  
7ac9 d3 c1		out (portbdata),a  
7acb			  
7acb			; loop leds  
7acb 06 0a		ld b,10  
7acd			  
7acd			.cycle1:  
7acd c5			push bc  
7ace 3e 00		ld a, 0  
7ad0 d3 c1		out (portbdata),a  
7ad2 cd d2 0c		call delay250ms  
7ad5			  
7ad5 3e 40		ld a, 64  
7ad7 d3 c1		out (portbdata),a  
7ad9 cd d2 0c		call delay250ms  
7adc			  
7adc 3e 00		ld a, 0  
7ade d3 c1		out (portbdata),a  
7ae0 cd d2 0c		call delay250ms  
7ae3			  
7ae3 c1			pop bc  
7ae4 10 e7		djnz .cycle1  
7ae6			  
7ae6			  
7ae6 18 df		jr .cyclestart  
7ae8			  
7ae8			  
7ae8			  
7ae8			  
7ae8			  
7ae8			  
7ae8			  
7ae8			  
7ae8			  
7ae8			; map matrix key held to char on face of key  
7ae8			  
7ae8			;.mtocold:  
7ae8			;  
7ae8			;  
7ae8			;; reset counter  
7ae8			;ld a, 128  
7ae8			;out (portbdata),a  
7ae8			;  
7ae8			;  
7ae8			;; scan keyboard row 1  
7ae8			;ld a, 0  
7ae8			;out (portbdata),a  
7ae8			;;ld a, 64  
7ae8			;;out (portbdata),a  
7ae8			;  
7ae8			;  
7ae8			;	ld a, 128  
7ae8			;	ld hl, keyscan_table  
7ae8			;	call .rowscan  
7ae8			;  
7ae8			;;ld a, 0  
7ae8			;;out (portbdata),a  
7ae8			;ld a, 64  
7ae8			;out (portbdata),a  
7ae8			;  
7ae8			;	ld a, 64  
7ae8			;	ld hl, keyscan_table+key_cols  
7ae8			;	call .rowscan  
7ae8			;  
7ae8			;ld a, 0  
7ae8			;out (portbdata),a  
7ae8			;;ld a, 64  
7ae8			;;out (portbdata),a  
7ae8			;	ld a, 32  
7ae8			;	ld hl, keyscan_table+(key_cols*2)  
7ae8			;	call .rowscan  
7ae8			;  
7ae8			;  
7ae8			;;ld a, 0  
7ae8			;;out (portbdata),a  
7ae8			;ld a, 64  
7ae8			;out (portbdata),a  
7ae8			;  
7ae8			;	ld a, 16  
7ae8			;	ld hl, keyscan_table+(key_cols*3)  
7ae8			;	call .rowscan  
7ae8			;  
7ae8			;  
7ae8			;	; flag if key D is held down and remove from reporting  
7ae8			;	ld bc, .key_map_fd    
7ae8			;	ld hl, keyscan_table  
7ae8			;	ld de, key_fd  
7ae8			;	call .key_shift_hold  
7ae8			;	cp 255  
7ae8			;	jr z, .cinmap  
7ae8			;	; flag if key C is held down and remove from reporting  
7ae8			;	ld bc, .key_map_fc    
7ae8			;	ld hl, keyscan_table+key_cols  
7ae8			;	ld de, key_fc  
7ae8			;	call .key_shift_hold  
7ae8			;	cp 255  
7ae8			;	jr z, .cinmap  
7ae8			;	; flag if key B is held down and remove from reporting  
7ae8			;	ld bc, .key_map_fb    
7ae8			;	ld hl, keyscan_table+(key_cols*2)  
7ae8			;	ld de, key_fb  
7ae8			;	call .key_shift_hold  
7ae8			;	cp 255  
7ae8			;	jr z, .cinmap  
7ae8			;	; flag if key A is held down and remove from reporting  
7ae8			;	ld bc, .key_map_fa    
7ae8			;	ld hl, keyscan_table+(key_cols*3)  
7ae8			;	ld de, key_fa  
7ae8			;	call .key_shift_hold  
7ae8			;	cp 255  
7ae8			;	jr z, .cinmap  
7ae8			;  
7ae8			;	ld de, .matrix_to_char  
7ae8			;  
7ae8			;  
7ae8			;.cinmap:   
7ae8			;	if DEBUG_KEY  
7ae8			;            LD   A, kLCD_Line4  
7ae8			;            CALL fLCD_Pos       ;Position cursor to location in A  
7ae8			;		push de  
7ae8			;            LD   DE, keyscan_table  
7ae8			;            CALL fLCD_Str       ;Display string pointed to by DE  
7ae8			;		pop de  
7ae8			;	endif  
7ae8			  
7ae8				; scan key matrix table for any held key  
7ae8			  
7ae8				; de holds either the default matrix or one selected above  
7ae8			  
7ae8			;	ld hl, keyscan_table  
7ae8			;	ld b,key_cols*key_rows  
7ae8			;  
7ae8			;.cin1:	ld a,(hl)  
7ae8			;	cp '#'  
7ae8			;	jr z, .cinhit  
7ae8			;	inc hl  
7ae8			;	inc de  
7ae8			;	dec b  
7ae8			;	jr nz, .cin1  
7ae8			;	; no key found held  
7ae8			;	ld a,0  
7ae8			;	ret  
7ae8			;.cinhit: push de  
7ae8			;	pop hl  
7ae8			;	ld a,(hl)  
7ae8			;	ret  
7ae8			  
7ae8			; flag a control key is held   
7ae8			; hl is key pin, de is flag indicator  
7ae8			  
7ae8			;.key_shift_hold:  
7ae8			;	push bc  
7ae8			;	ld a, 1  
7ae8			;	ld (cursor_shape),a  
7ae8			;	ld b, 0  
7ae8			;	ld a, (hl)  
7ae8			;	cp '.'  
7ae8			;	jr z, .key_shift1  
7ae8			;	ld b, 255  
7ae8			;	ld a, '+'    ; hide key from later scans  
7ae8			;	ld (hl),a  
7ae8			;	ld a, 2  
7ae8			;	ld (cursor_shape),a  
7ae8			;.key_shift1:  
7ae8			;	; write flag indicator  
7ae8			;	ld a,b  
7ae8			;	ld (de),a  
7ae8			;  
7ae8			;	pop de    ; de now holds the key map ptr  
7ae8			;	ret  
7ae8			  
7ae8				  
7ae8				  
7ae8			  
7ae8			  
7ae8			  
7ae8			  
7ae8			  
7ae8			  
7ae8			  
7ae8			  
7ae8			  
7ae8			  
7ae8			  
7ae8			;	push hl  
7ae8			;	push de  
7ae8			;	push bc  
7ae8			;	call keyscan  
7ae8			;	; map key matrix to ascii value of key face  
7ae8			;  
7ae8			;	ld hl, key_face_map  
7ae8			;	ld de, keyscan_table  
7ae8			;  
7ae8			;	; get how many keys to look at  
7ae8			;	ld b, keyscan_table_len  
7ae8			;	  
7ae8			;  
7ae8			;	; at this stage fall out on first key hit  
7ae8			;	; TODO handle multiple key press  
7ae8			;  
7ae8			;map1:	ld a,(hl)  
7ae8			;	cp '#'  
7ae8			;	jr z, keyhit  
7ae8			;	inc hl  
7ae8			;	inc de  
7ae8			;	dec b  
7ae8			;	jr nz, map1  
7ae8			;nohit:	ld a, 0  
7ae8			;	jr keydone  
7ae8			;keyhit: push de  
7ae8			;	pop hl  
7ae8			;	ld a,(hl)  
7ae8			;keydone:  
7ae8			;	push bc  
7ae8			;	push de  
7ae8			; 	push hl  
7ae8			;	ret   
7ae8			;  
7ae8			  
7ae8			  
7ae8			  
7ae8			  
7ae8			; scan physical key matrix  
7ae8			  
7ae8			  
7ae8			;keyscan:  
7ae8			;  
7ae8			;; for each key_row use keyscanr bit mask for out  
7ae8			;; then read in for keyscanc bitmask  
7ae8			;; save result of row scan to keyscantable  
7ae8			;  
7ae8			;; scan keyboard row 1  
7ae8			;  
7ae8			;	ld b, key_rows  
7ae8			;	ld hl, key_scanr  
7ae8			;	ld de, keyscan_table  
7ae8			;  
7ae8			;rowloop:  
7ae8			;  
7ae8			;	ld a,(hl)		; out bit mask to energise keyboard row  
7ae8			;	call rowscan  
7ae8			;	inc hl  
7ae8			;	dec b  
7ae8			;	jr nz, rowloop  
7ae8			;  
7ae8			;	ret  
7ae8			;  
7ae8			;  
7ae8			;; pass a out bitmask, b row number  
7ae8			;arowscan:   
7ae8			;	push bc  
7ae8			;  
7ae8			;	ld d, b  
7ae8			;  
7ae8			;	; calculate buffer location for this row  
7ae8			;  
7ae8			;	ld hl, keyscan_table	  
7ae8			;kbufr:  ld e, key_cols  
7ae8			;kbufc:	inc hl  
7ae8			;	dec e  
7ae8			;	jr nz, kbufc  
7ae8			;	dec d  
7ae8			;	jr nz, kbufr  
7ae8			;  
7ae8			;	; energise row and read columns  
7ae8			;  
7ae8			;	out (portbdata),a  
7ae8			;	in a,(portbdata)  
7ae8			;	ld c,a  
7ae8			;  
7ae8			;  
7ae8			;	; save buffer loc  
7ae8			;  
7ae8			;	ld (keybufptr), hl  
7ae8			;  
7ae8			;	ld hl, key_scanc  
7ae8			;	ld d, key_cols  
7ae8			;  
7ae8			;	; for each column check each bit mask  
7ae8			;  
7ae8			;colloop:  
7ae8			;	  
7ae8			;  
7ae8			;	; reset flags for the row   
7ae8			;  
7ae8			;	ld b,'.'  
7ae8			;	and (hl)  
7ae8			;	jr z, maskskip  
7ae8			;	ld b,'#'  
7ae8			;maskskip:  
7ae8			;	; save  key state  
7ae8			;	push hl  
7ae8			;	ld hl, (keybufptr)  
7ae8			;	ld (hl), b  
7ae8			;	inc hl  
7ae8			;	ld (keybufptr), hl  
7ae8			;  
7ae8			;	; move to next bit mask  
7ae8			;	pop hl  
7ae8			;	inc hl  
7ae8			;  
7ae8			;	dec d  
7ae8			;	jr nz, colloop  
7ae8			;  
7ae8			;	ret  
7ae8			;  
7ae8			;  
7ae8			;;  
7ae8			; lcd functions  
7ae8			;  
7ae8			;  
7ae8			  
7ae8			;if DEBUG_KEY_MATRIX  
7ae8			  
7ae8			; test function to display hardware view of matrix state  
7ae8			  
7ae8			matrixold:  
7ae8			  
7ae8			  
7ae8			  
7ae8			; reset counter  
7ae8 3e 80		ld a, 128  
7aea d3 c1		out (portbdata),a  
7aec			; scan keyboard row 1  
7aec 3e 00		ld a, 0  
7aee d3 c1		out (portbdata),a  
7af0			;ld a, 64  
7af0			;out (portbdata),a  
7af0 3e 80			ld a, 128  
7af2 21 30 fe			ld hl, keyscan_table_row1  
7af5 cd 4e 7b			call .rowscan  
7af8			  
7af8			;ld a, 0  
7af8			;out (portbdata),a  
7af8 3e 40		ld a, 64  
7afa d3 c1		out (portbdata),a  
7afc 3e 40			ld a, 64  
7afe 21 25 fe			ld hl, keyscan_table_row2  
7b01 cd 4e 7b			call .rowscan  
7b04			  
7b04 3e 00		ld a, 0  
7b06 d3 c1		out (portbdata),a  
7b08			;ld a, 64  
7b08			;out (portbdata),a  
7b08 3e 20			ld a, 32  
7b0a 21 1a fe			ld hl, keyscan_table_row3  
7b0d cd 4e 7b			call .rowscan  
7b10			  
7b10			;ld a, 0  
7b10			;out (portbdata),a  
7b10 3e 40		ld a, 64  
7b12 d3 c1		out (portbdata),a  
7b14 3e 10			ld a, 16  
7b16 21 0f fe			ld hl, keyscan_table_row4  
7b19 cd 4e 7b			call .rowscan  
7b1c			  
7b1c			; Display text on first line  
7b1c 3e 00		            LD   A, kLCD_Line1  
7b1e cd 56 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b21 11 30 fe		            LD   DE, keyscan_table_row1  
7b24			            ;LD   DE, MsgHello  
7b24 cd 78 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b27			  
7b27			; Display text on second line  
7b27 3e 28		            LD   A, kLCD_Line2  
7b29 cd 56 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b2c 11 25 fe		            LD   DE, keyscan_table_row2  
7b2f cd 78 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b32 3e 50		            LD   A, kLCD_Line3  
7b34 cd 56 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b37 11 1a fe		            LD   DE, keyscan_table_row3  
7b3a cd 78 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b3d 3e 78		            LD   A, kLCD_Line4  
7b3f cd 56 77		            CALL fLCD_Pos       ;Position cursor to location in A  
7b42 11 0f fe		            LD   DE, keyscan_table_row4  
7b45 cd 78 77		            CALL fLCD_Str       ;Display string pointed to by DE  
7b48			  
7b48 cd d2 0c			call delay250ms  
7b4b c3 39 7a			jp matrix  
7b4e			  
7b4e			; pass de as row display flags  
7b4e			.rowscan:   
7b4e			;	out (portbdata),a  
7b4e db c1			in a,(portbdata)  
7b50 4f				ld c,a  
7b51				; reset flags for the row   
7b51 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7b53 e6 01			and 1  
7b55 28 02			jr z, .p1on  
7b57 06 23			ld b,'#'  
7b59			.p1on:  
7b59 70				ld (hl), b  
7b5a 23				inc hl  
7b5b			  
7b5b 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7b5d 79				ld a,c  
7b5e e6 02			and 2  
7b60			;	bit 0,a  
7b60 28 02			jr z, .p2on  
7b62 06 23			ld b,'#'  
7b64			.p2on:  
7b64 70				ld (hl), b  
7b65 23				inc hl  
7b66			;  
7b66 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7b68 79				ld a,c  
7b69 e6 04			and 4  
7b6b			;;	bit 0,a  
7b6b 28 02			jr z, .p3on  
7b6d 06 23			ld b,'#'  
7b6f			.p3on:  
7b6f 70				ld (hl), b  
7b70 23				inc hl  
7b71			;;  
7b71 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7b73			;;	bit 0,a  
7b73 79				ld a,c  
7b74 e6 08			and 8  
7b76 28 02			jr z, .p4on  
7b78 06 23			ld b,'#'  
7b7a			.p4on:  
7b7a 70				ld (hl), b  
7b7b 23				inc hl  
7b7c			  
7b7c 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7b7e			;;	bit 0,a  
7b7e 79				ld a,c  
7b7f e6 10			and 16  
7b81 28 02			jr z, .p5on  
7b83 06 23			ld b,'#'  
7b85			.p5on:  
7b85 70				ld (hl), b  
7b86 23				inc hl  
7b87			; zero term  
7b87 06 00			ld b,0  
7b89 70				ld (hl), b  
7b8a			  
7b8a c9			.rscandone: ret  
7b8b			  
7b8b			;addatohl:  
7b8b			;  
7b8b			 ;add   a, l    ; A = A+L  
7b8b			  ;  ld    l, a    ; L = A+L  
7b8b			   ; adc   a, h    ; A = A+L+H+carry  
7b8b			   ; sub   l       ; A = H+carry  
7b8b			   ; ld    h, a    ; H = H+carry  
7b8b			  
7b8b			;ret  
7b8b			; eof  
# End of file firmware_key_5x10.asm
7b8b			;include "firmware_key_4x10.asm" 
7b8b			 
7b8b			heap_size:    equ heap_end - heap_start 
7b8b			;eof 
# End of file os_mega.asm
7b8b
