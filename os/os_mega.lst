# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 34 1c			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 ..			buildtime: db   "Build: " 
000a					include "romtimestamp.asm" 
000a ..			db '2025-08-31 17:28' 
# End of file romtimestamp.asm
001a 00				   db 0 
001b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
001f			 
001f			 
001f			 
001f			;        nop  
001f			;        nop 
001f			;;	org 05h		; null out bdos call 
001f			; 
001f			;        nop  
001f			;        nop  
001f			;        nop 
001f			;;	org 08h 
001f			;;; 
001f			;;	jp cin		; rst 8 - char in 
001f			;;; 
001f			; 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;	org 010h 
001f			;; 
001f			;	jp cout		; rest 010h  - char out 
001f			;; 
001f			;	org 01bh   
001f			; 
001f			;	;jp  		; rst 01bh   - write string to display 
001f			;	jp str_at_display 
001f			; 
001f			; 
001f			;	org 020h 
001f			; 
001f			;	; jp		 ; rst 020h - read char at screen location 
001f			; 
001f			;	org 028h 
001f			 
001f				; jp		 ; rst 028h  - storage i/o 
001f			 
001f			; 	org 030h 
001f			;	jp break_point_state 
001f			  
001f			; $30  
001f			; org 038h 
001f			; $38 
001f			 
001f			; TODO any more important entry points to add to jump table for easier coding use? 
001f			 
001f			if BASE_KEV = 1  
001f			 
001f				; need to be at $66 for nmi support 
001f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0025 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0031 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0037 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0043 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0049 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0055 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0061 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0067 00 ff			db 0,255 
0069 c3 0f 71			jp nmi 
006c			endif 
006c			 
006c			include "firmware.asm" 
006c			  
006c			; main constants (used here and in firmware)  
006c			  
006c			; TODO have page 0 of storage as bios  
006c			  
006c			Device_A: equ 0h  
006c			Device_B: equ 040h          ; Sound  
006c			  
006c			if BASE_KEV  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_SC114  
006c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			; TODO fixup for CPM  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			Device_D: equ 0c0h             ; Keyboard and LCD  
006c			  
006c			; Odd specific debug points for testing hardware dev  
006c			  
006c			;if DEBUG_LEVEL0  
006c			;	include "debug_level0.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL1  
006c			;	include "debug_level1.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL2  
006c			;	include "debug_level2.asm"  
006c			;endif  
006c			  
006c			  
006c			CALLMONITOR: macro  
006c			;	call break_point_state  
006c			; now use the break point debug vector  
006c				call debug_vector  
006c				endm  
006c			  
006c			MALLOC_1: equ 1        ; from dk88   
006c			MALLOC_2: equ 0           ; broke  
006c			MALLOC_3: equ 0           ; really broke  
006c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
006c			  
006c			if BASE_KEV   
006c			;stacksize: equ 256  
006c			; each stack entry is three bytes (type + word)  
006c			stacksize: equ 3*150  
006c			  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 512  
006c			endif  
006c			if BASE_SC114  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			;if STORAGE_SE == 0  
006c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
006c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
006c			;endif  
006c			  
006c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
006c			  
006c			STORE_0_AUTORUN: equ $20  
006c			  
006c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
006c			  
006c			STORE_0_AUTOFILE: equ $21  
006c			STORE_0_BANKRUN: equ $23  
006c			STORE_0_FILERUN: equ $24  
006c			  
006c			; Block 0 offsets for settings  
006c			  
006c			; if set then skip prompt for start up and accept all  
006c			  
006c			STORE_0_QUICKSTART: equ $25  
006c			  
006c			; Blocks where directory table is held  
006c			  
006c			; Reducing the number of entries increases the max file size  
006c			  
006c			;STORE_DIR_START: equ 1  
006c			;STORE_DIR_END: equ 33  
006c			  
006c			; Blocks from where file data is stored  
006c			  
006c			;STORE_DATA_START: equ STORE_DIR_END + 1  
006c			  
006c			; Block indicators (<32 are data files)  
006c			  
006c			;STORE_BLOCK_CFG: equ $8f       ; config block  
006c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
006c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
006c			;STORE_BLOCK_FREE: equ $85       ; data block free  
006c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
006c			  
006c			  
006c			  
006c			; Directory entry flags  
006c			  
006c			;STORE_DIR_FREE: equ 0  
006c			;STORE_DIR_FILE:  equ 1  
006c			  
006c			; Structure offsets to directory entries  
006c			;STORE_DE_FLAG: equ 0  
006c			;STORE_DE_MAXEXT: equ 1  
006c			;STORE_DE_FILENAME: equ 2  
006c			  
006c			; Structure offsets to block 0  
006c			  
006c			;STORE_BK0_ISFOR: equ 1  
006c			;STORE_BK0_LABEL: equ 3  
006c			  
006c			; memory allocation   
006c			  
006c			chk_stund: equ tos+2           ; underflow check word  
006c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
006c			  
006c			; keyscan table needs rows x cols buffer  
006c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
006c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
006c			  
006c			keyscan_table_row1: equ chk_stovr -key_cols-1  
006c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
006c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
006c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
006c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
006c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
006c			keyscan_scancol: equ keyscan_table-key_cols  
006c			;keyscan_table_len: equ key_rows*key_cols  
006c			;keybufptr: equ keyscan_table - 2  
006c			;keysymbol: equ keybufptr - 1  
006c			key_held: equ keyscan_scancol-1	; currently held  
006c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
006c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
006c			key_fa: equ key_repeat_ct -1 ;  
006c			key_fb: equ key_fa -1 ;  
006c			key_fc: equ key_fb -1 ;  
006c			key_fd: equ key_fc -1 ;  
006c			key_face_held: equ key_fd - 1   
006c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
006c			  
006c			hardware_config: equ key_face_held - 10  
006c			  
006c			; hardware config switches  
006c			; TODO add bitmasks on includes for hardware  
006c			; high byte for expansion ids  
006c			;     0000 0000  no card inserted  
006c			;     0000 0001  storage card inserted  
006c			;     0000 0010  spi sd card active  
006c			  
006c			;       
006c			; low byte:  
006c			;     0000 0001   4x4 keypad  
006c			;     0000 0010   full keyboard  
006c			;     0000 0011   spi/ext keyboard  
006c			;     0000 0100   20x4 lcd  
006c			;     0000 1000   40x4 lcd  
006c			;     0000 1100   spi/ext display  
006c			;     0001 0000   ide interface available  
006c			  
006c			hardware_word: equ hardware_config - 2  
006c			  
006c			; debug marker - optional display of debug point on the debug screens  
006c			  
006c			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
006c			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
006c			  
006c			debug_umark: equ debug_vector - 6  ; current user mark  
006c			debug_mark: equ debug_umark - 4    ; internal word debug points  
006c			  
006c			; input_str vars  
006c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
006c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
006c			input_size: equ input_start -1  ; number of chars  
006c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
006c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
006c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
006c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
006c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
006c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
006c			input_len: equ input_cur_onoff - 5 ; length of current input  
006c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
006c			  
006c			; cursor blink rate  
006c			CUR_BLINK_RATE: equ $09  
006c			;CUR_BLINK_RATE: equ 15  
006c			  
006c			key_actual_pressed: equ input_cursor - 1   
006c			key_symbol: equ key_actual_pressed - 1   
006c			key_shift: equ key_symbol - 1   
006c			  
006c			; Display allocation  
006c			  
006c			;display_rows: equ 4     ; move out to mini and mega files  
006c			;display_cols: equ 20  
006c			  
006c			display_fb_len: equ display_rows*display_cols  
006c			  
006c			; primary frame buffer     
006c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
006c			; working frame buffers  
006c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
006c			display_fb3: equ  display_fb1-display_fb_len - 1  
006c			display_fb2: equ  display_fb3-display_fb_len - 1  
006c			;  
006c			; pointer to active frame buffer  
006c			display_fb_active: equ display_fb2 - 2  
006c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
006c			display_write_tmp: equ display_lcde1e2 - 2  
006c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
006c			  
006c			;  
006c			  
006c			;; can load into de directory  
006c			cursor_col: equ display_active-1  
006c			cursor_row: equ cursor_col-1  
006c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
006c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
006c			  
006c			; maths vars  
006c			  
006c			LFSRSeed: equ cursor_shape -20   
006c			randData: equ LFSRSeed - 2  
006c			xrandc: equ randData - 2  
006c			stackstore: equ xrandc - 2  
006c			seed1: equ  stackstore -2   
006c			seed2: equ seed1 - 2  
006c			  
006c			; cf storage vars  
006c			  
006c			iErrorNum:  equ seed2-1         ;Error number  
006c			iErrorReg:  equ iErrorNum -1              ;Error register  
006c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
006c			  
006c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
006c			  
006c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
006c			  
006c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
006c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
006c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
006c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
006c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
006c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
006c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
006c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
006c			store_tmpid: equ store_tmp3 - 1		; page temp id  
006c			store_tmpext: equ store_tmpid - 1		; file extent temp  
006c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
006c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
006c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
006c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
006c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
006c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
006c			;  
006c			; spi vars  
006c			  
006c			  
006c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
006c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
006c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
006c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
006c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
006c			spi_device_id: equ spi_device - 1    ; human readable bank number  
006c			  
006c			;;;;; forth cli params  
006c			  
006c			; TODO use a different frame buffer for forth???  
006c			  
006c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
006c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
006c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
006c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
006c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
006c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
006c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
006c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
006c			  
006c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
006c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
006c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
006c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
006c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
006c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
006c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
006c			  
006c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
006c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
006c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
006c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
006c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
006c			  
006c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
006c			  
006c			; os/forth token vars  
006c			  
006c			os_last_cmd: equ os_var_array-255  
006c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
006c			os_current_i: equ os_cli_cmd-2  
006c			os_cur_ptr: equ os_current_i-2  
006c			os_word_scratch: equ os_cur_ptr-30  
006c			os_tok_len: equ os_word_scratch - 2  
006c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
006c			os_tok_malloc: equ os_tok_ptr - 2  
006c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
006c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
006c			execscratch: equ os_input-255        ; exec cmd eval buffer  
006c			scratch: equ execscratch-255  
006c			  
006c			os_stack_1: equ scratch - 3       ; stack holding area 1  
006c			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
006c			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
006c			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
006c			  
006c			  
006c			; temp locations for new word processing to save on adding more   
006c			  
006c			os_new_malloc: equ os_stack_4-2  
006c			os_new_parse_len: equ os_new_malloc - 2  
006c			os_new_word_len: equ os_new_parse_len - 2  
006c			os_new_work_ptr: equ os_new_word_len - 2  
006c			os_new_src_ptr: equ os_new_work_ptr - 2  
006c			os_new_exec: equ os_new_src_ptr - 2  
006c			os_new_exec_ptr: equ os_new_exec - 2  
006c			  
006c			; resume memory alloocations....  
006c			  
006c			;os_view_disable: equ os_new_exec_ptr - 1  
006c			os_view_af: equ os_new_exec_ptr - 2  
006c			os_view_hl: equ os_view_af -2  
006c			os_view_de: equ os_view_hl - 2  
006c			os_view_bc: equ os_view_de - 2  
006c			  
006c			; stack checksum word  
006c			if DEBUG_STACK_IMB  
006c				curframe: equ  os_view_de - 5  
006c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
006c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			else  
006c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			endif  
006c			  
006c			; with data stack could see memory filled with junk. need some memory management   
006c			; malloc and free entry points added  
006c			  
006c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
006c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			;heap_end: equ free_list-1  ; Starting address of heap  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			heap_end: equ chk_word-1  ; Starting address of heap  
006c			  
006c			  
006c			;if BASE_KEV   
006c			;heap_start: equ 0800eh  ; Starting address of heap  
006c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;heap_start: equ baseram+15  ; Starting address of heap  
006c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;endif  
006c			  
006c			  
006c			;;;;  
006c			  
006c			  
006c			; change below to point to last memory alloc above  
006c			topusermem:  equ   heap_start  
006c			  
006c			;if BASE_KEV   
006c			;baseusermem: equ 08000h  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;;aseusermem:     equ    12  
006c			;baseusermem:     equ    prompt  
006c			;;baseusermem:     equ    endofcode  
006c			;endif  
006c			  
006c			  
006c			; **********************************************************************  
006c			; **  Constants  
006c			; **********************************************************************  
006c			  
006c			; Constants used by this code module  
006c			kDataReg:   EQU Device_D           ;PIO port A data register  
006c			kContReg:   EQU Device_D+2           ;PIO port A control register  
006c			  
006c			  
006c			portbdata:  equ Device_D+1    ; port b data  
006c			portbctl:   equ Device_D+3    ; port b control  
006c			  
006c			  
006c			;KEY_SHIFT:   equ 5  
006c			;KEY_SYMBOLSHIFT:  equ 6  
006c			  
006c			KEY_SHIFTLOCK: equ 4  
006c			  
006c			  
006c			KEY_UP: equ 5  
006c			KEY_NEXTWORD: equ 6  
006c			KEY_PREVWORD: equ 7  
006c			KEY_BS: equ 8  
006c			KEY_TAB:  equ 9  
006c			KEY_DOWN: equ 10  
006c			KEY_LEFT: equ 11  
006c			KEY_RIGHT: equ 12  
006c			KEY_CR:   equ 13  
006c			KEY_HOME: equ 14  
006c			KEY_END: equ 15  
006c			  
006c			KEY_F1: equ 16  
006c			KEY_F2: equ 17  
006c			KEY_F3: equ 18  
006c			KEY_F4: equ 19  
006c			  
006c			KEY_F5: equ 20  
006c			KEY_F6: equ 21  
006c			KEY_F7: equ 22  
006c			KEY_F8: equ 23  
006c			  
006c			KEY_F9: equ 24  
006c			KEY_F10: equ 25  
006c			KEY_F11: equ 26  
006c			KEY_F12: equ 27  
006c			  
006c			;if DEBUG_KEY  
006c			;	KEY_MATRIX_NO_PRESS: equ '.'  
006c			;	KEY_SHIFT:   equ '.'  
006c			;	KEY_SYMBOLSHIFT:  equ '.'  
006c			;else  
006c				KEY_SHIFT:   equ '~'  
006c				KEY_SYMBOLSHIFT:  equ '~'  
006c				KEY_MATRIX_NO_PRESS: equ '~'  
006c			;endi  
006c			  
006c			  
006c			  
006c			  
006c			; Macro to make adding debug marks easier  
006c			  
006c			DMARK: macro str  
006c				push af  
006c				ld a, (.dmark)  
006c				ld (debug_mark),a  
006c				ld a, (.dmark+1)  
006c				ld (debug_mark+1),a  
006c				ld a, (.dmark+2)  
006c				ld (debug_mark+2),a  
006c				jr .pastdmark  
006c			.dmark: db str  
006c			.pastdmark: pop af  
006c			  
006c			endm  
006c			  
006c			  
006c			; macro to detect for stack imbalances  
006c			  
006c			include "stackimbal.asm"  
006c			; Macro and code to detect stock imbalances 
006c			 
006c			SPPUSH: equ 0 
006c			 
006c			; Add a stack frame which can be checked before return 
006c			 
006c			STACKFRAME: macro onoff frame1 frame2 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c						exx 
006c			 
006c						ld de, frame1 
006c						ld a, d 
006c						ld hl, curframe 
006c						call hexout 
006c						ld a, e 
006c						ld hl, curframe+2 
006c						call hexout 
006c			  
006c						ld hl, frame1 
006c						push hl 
006c						ld hl, frame2 
006c						push hl 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			endm 
006c			 
006c			STACKFRAMECHK: macro onoff frame1 frame2 
006c			 
006c					 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						exx 
006c						; check stack frame SP 
006c			 
006c						ld hl, frame2 
006c						pop de   ; frame2 
006c			 
006c						call cmp16 
006c						jr nz, .spnosame 
006c						 
006c			 
006c						ld hl, frame1 
006c						pop de   ; frame1 
006c			 
006c						call cmp16 
006c						jr z, .spfrsame 
006c			 
006c						.spnosame: call showsperror 
006c			 
006c						.spfrsame: nop 
006c			 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			 
006c			 
006c			endm 
006c			 
006c			 
006c			; for a sub routine, wrap SP collection and comparisons 
006c			 
006c			; Usage: 
006c			; 
006c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
006c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
006c			 
006c			SAVESP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c			 
006c						ld (store_sp+(storeword*4)), sp 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			CHECKSP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c			 
006c						; save SP after last save 
006c				 
006c						ld (store_sp+(storeword*4)+2), sp 
006c			 
006c						push hl 
006c						ld hl, store_sp+(storeword*4) 
006c						call check_stack_sp  
006c						pop hl 
006c			 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			if DEBUG_STACK_IMB 
006c			 
006c			check_stack_sp: 
006c					push de 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					push de 
006c			 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					pop hl 
006c			 
006c			 
006c					; check to see if the same 
006c			 
006c					call cmp16 
006c					jr z, .spsame 
006c			 
006c					; not same 
006c			 
006c					call showsperror 
006c			.spsame: 
006c			 
006c					pop de 
006c			 
006c					ret 
006c			 
006c			.sperr:  db "Stack imbalance",0 
006c			 
006c			 
006c			showsperror: 
006c			 
006c			 
006c				push hl 
006c				push af 
006c				push de 
006c				call clear_display 
006c				ld de, .sperr 
006c				ld a,0 
006c			;	ld de,os_word_scratch 
006c				call str_at_display 
006c				ld a, display_row_1+17 
006c				ld de, debug_mark 
006c				call str_at_display 
006c				ld a, 0 
006c				ld (curframe+4),a 
006c				ld hl, curframe 
006c				ld de, os_word_scratch 
006c				ld a, display_row_4 
006c				call str_at_display 
006c				call update_display 
006c				;call break_point_state 
006c				call cin_wait 
006c			 
006c			;	ld a, ' ' 
006c			;	ld (os_view_disable), a 
006c				call bp_on 
006c				pop de	 
006c				pop af 
006c				pop hl 
006c				CALLMONITOR 
006c				ret 
006c			 
006c			endif 
006c			 
006c			 
006c			 
006c			; eof 
# End of file stackimbal.asm
006c			  
006c			;TODO macro to calc col and row offset into screen  
006c			  
006c			  
006c			  
006c			hardware_init:  
006c			  
006c				  
006c			  
006c					;ld a, 0  
006c					;ld (hardware_diag), a  
006c			  
006c					; clear all the buffers  
006c			  
006c 21 45 fc				ld hl, display_fb1  
006f 22 01 fb				ld (display_fb_active), hl  
0072			  
0072 cd aa 0d				call clear_display  
0075			  
0075 21 03 fb				ld hl, display_fb2  
0078 22 01 fb				ld (display_fb_active), hl  
007b			  
007b cd aa 0d				call clear_display  
007e			  
007e					; init primary frame buffer area  
007e 21 e6 fc				ld hl, display_fb0  
0081 22 01 fb				ld (display_fb_active), hl  
0084			  
0084 cd aa 0d				call clear_display  
0087			  
0087			  
0087 cd 1c 71				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
008a			  
008a cd b3 73			call key_init  
008d cd 56 02			call storage_init  
0090			  
0090				; setup malloc functions  
0090			  
0090				if MALLOC_1  
0090 cd 95 13				call  heap_init  
0093				endif  
0093				if MALLOC_4  
0093					call  heap_init  
0093				endif  
0093			  
0093				; init sound hardware if present  
0093			  
0093				if SOUND_ENABLE  
0093					call sound_init  
0093				endif  
0093			  
0093				; lcd test sequence  
0093					  
0093 cd cd 0d			call update_display  
0096 cd ed 0c			call delay1s  
0099 3e 2b			ld a,'+'  
009b cd af 0d			call fill_display  
009e cd cd 0d			call update_display  
00a1 cd ed 0c			call delay1s  
00a4 3e 2a			ld a,'*'  
00a6 cd af 0d			call fill_display  
00a9 cd cd 0d			call update_display  
00ac cd ed 0c			call delay1s  
00af 3e 2d			ld a,'-'  
00b1 cd af 0d			call fill_display  
00b4 cd cd 0d			call update_display  
00b7 cd ed 0c			call delay1s  
00ba			  
00ba			; boot splash screen  
00ba			if display_cols == 20	  
00ba			        ld a, display_row_1    
00ba			else  
00ba 3e 0a		        ld a, display_row_1 +10   
00bc			endif  
00bc 11 24 1b			ld de, prom_bootmsg  
00bf cd bd 0d			call str_at_display  
00c2 cd cd 0d			call update_display  
00c5			  
00c5			  
00c5 cd ed 0c			call delay1s  
00c8 cd ed 0c			call delay1s  
00cb			if display_cols == 20	  
00cb			            LD   A, display_row_3+2  
00cb			else  
00cb 3e 5c		            LD   A, display_row_3+12  
00cd			endif  
00cd 11 39 1b			ld de, prom_bootmsg1  
00d0 cd bd 0d			call str_at_display  
00d3			; display debug level  
00d3 3e 78		            LD   A, display_row_4  
00d5 11 1b 00			ld de, debuglevel  
00d8 cd bd 0d			call str_at_display  
00db			  
00db cd cd 0d			call update_display  
00de cd ed 0c			call delay1s  
00e1 cd ed 0c			call delay1s  
00e4			  
00e4			;	ld a, display_row_4+3  
00e4			;	ld de, bootmsg2  
00e4			;	call str_at_display  
00e4			;	call update_display  
00e4			;	call delay1s  
00e4			;	call delay1s  
00e4			  
00e4			; debug mark setup  
00e4			  
00e4 3e 5f		ld a, '_'  
00e6 32 a0 fd		ld (debug_mark),a  
00e9 32 a1 fd		ld (debug_mark+1),a  
00ec 32 a2 fd		ld (debug_mark+2),a  
00ef 3e 00		ld a,0  
00f1 32 a3 fd		ld (debug_mark+3),a  
00f4 32 a4 fd		ld (debug_umark),a  
00f7			  
00f7 c9					ret  
00f8			  
00f8			  
00f8			;bootmsg2:	db "Firmware v0.1",0  
00f8			  
00f8			; a 4x20 lcd  
00f8			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00f8			  
00f8			;if display_cols == 20  
00f8			;	include "firmware_lcd_4x20.asm"  
00f8			;endif  
00f8			  
00f8			;if display_cols == 40  
00f8			;	include "firmware_lcd_4x40.asm"  
00f8			;endif  
00f8			  
00f8			;  
00f8			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00f8			; TODO abstract the bit bang video out interface for dual display  
00f8			; TODO wire video out to tx pin on rc2014 bus  
00f8			  
00f8			; must supply cin, and cin_wait for low level hardware abstraction   
00f8			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00f8			; test scancode  
00f8			  
00f8			;;;;;  
00f8			;;;  
00f8			; Moved out to mini and maxi versions  
00f8			;  
00f8			; include "firmware_key_4x4.asm"  
00f8			; using existing 4 wire x 4 resistor array for input  
00f8			;include "firmware_key_4x10.asm"  
00f8			; need to mod the board for 5 rows due to resistor array  
00f8			;include "firmware_key_5x10.asm"  
00f8			  
00f8			; storage hardware interface  
00f8			  
00f8			; use microchip serial eeprom for storage  
00f8			  
00f8			  
00f8			if STORAGE_SE  
00f8				include "firmware_spi.asm"  
00f8			; my spi protocol (used by storage) 
00f8			 
00f8			; SPI pins 
00f8			 
00f8			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00f8			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00f8			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00f8			 
00f8			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00f8			; chip pin 4 gnd 
00f8			 
00f8			 
00f8			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00f8			SPI_CE1: equ 1      ;    port a1 pin 14  
00f8			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00f8			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00f8			SPI_CE4: equ 4      ; port a4     pin 10 
00f8			 
00f8			; active low AND masks 
00f8			 
00f8			;SPI_CE0_MASK: equ    255-1 
00f8			;SPI_CE1_MASK: equ   255-2 
00f8			;SPI_CE2_MASK: equ   255-4 
00f8			;SPI_CE3_MASK: equ   255-8 
00f8			;SPI_CE4_MASK: equ   255-16 
00f8			SPI_CE_HIGH:  equ 255 
00f8			 
00f8			 
00f8			 
00f8			;  Perform SCLK wait pulse 
00f8			 
00f8			spi_clk: 
00f8 f5				push af 
00f9 3a 99 f9			ld a, (spi_clktime) 
00fc fe 00			cp 0 
00fe 28 03			jr z, .scskip 
0100 cd d2 0c			call aDelayInMS 
0103			.scskip: 
0103 f1				pop af 
0104 c9				ret 
0105			 
0105			 
0105			 
0105			; TODO store port id for spi device ie dev c 
0105			; TODO store pin for SO 
0105			; TODO store pin for SI 
0105			; TODO store pin for SCLK 
0105			 
0105			; 
0105			 
0105			; ensure that spi bus is in a stable state with default pins  
0105			 
0105			se_stable_spi:   
0105			 
0105				 ; set DI high, CE high , SCLK low 
0105				;ld a, SPI_DI | SPI_CE0 
0105 3e 07			ld a, SPI_DI  
0107 cd 11 02			call spi_ce_high 
010a d3 80			 out (storage_adata),a 
010c 32 96 f9			ld (spi_portbyte),a 
010f			 
010f				if DEBUG_SPI 
010f					push hl 
010f					ld l, a 
010f					DMARK "SPI" 
010f					CALLMONITOR 
010f					pop hl 
010f				endif 
010f c9				ret 
0110			 
0110			; byte to send in a 
0110			 
0110			spi_send_byte: 
0110				; save byte to send for bit mask shift out 
0110 4f			        ld c,a 
0111 3a 96 f9			ld a,(spi_portbyte) 
0114				  
0114				; clock out	each bit of the byte msb first 
0114			 
0114 06 08			ld b, 8 
0116			.ssb1: 
0116				; clear so bit  
0116 cb bf			res SPI_DI, a 
0118 cb 11			rl c 
011a				; if bit 7 is set then carry is set 
011a 30 02			jr nc, .ssb2 
011c cb ff			set SPI_DI,a 
011e			.ssb2:  ; output bit to ensure it is stable 
011e d3 80			out (storage_adata),a 
0120 00				nop 
0121				; clock bit high 
0121 cb ef			set SPI_SCLK,a 
0123 d3 80			out (storage_adata),a 
0125 00				nop 
0126 cd f8 00			call spi_clk 
0129				; then low 
0129 cb af			res SPI_SCLK,a 
012b d3 80			out (storage_adata),a 
012d 00				nop 
012e cd f8 00			call spi_clk 
0131 10 e3			djnz .ssb1 
0133			 
0133 32 96 f9			ld (spi_portbyte),a 
0136 c9				ret 
0137			 
0137			; TODO low level get byte into A on spi 
0137			 
0137			spi_read_byte:  
0137			 
0137				; save byte to send for bit mask shift out 
0137 0e 00		    ld c,0 
0139 3a 96 f9			ld a,(spi_portbyte) 
013c				  
013c				; clock out	each bit of the byte msb first 
013c			 
013c			 
013c				; clock bit high 
013c cb ef			set SPI_SCLK,a 
013e d3 80			out (storage_adata),a 
0140 00				nop 
0141 cd f8 00			call spi_clk 
0144			 
0144			    ; read DO  
0144			 
0144 cb f9		    set 7,c 
0146 db 80			in a,(storage_adata) 
0148 cb 77		    bit SPI_DO,a 
014a 20 02		    jr nz, .b7 
014c cb b9		    res 7,c 
014e			.b7: 
014e				; then low 
014e cb af			res SPI_SCLK,a 
0150 d3 80			out (storage_adata),a 
0152 00				nop 
0153 cd f8 00			call spi_clk 
0156			     
0156			 
0156				; clock bit high 
0156 cb ef			set SPI_SCLK,a 
0158 d3 80			out (storage_adata),a 
015a 00				nop 
015b cd f8 00			call spi_clk 
015e			 
015e			    ; read DO  
015e			 
015e cb f1		    set 6,c 
0160 db 80			in a,(storage_adata) 
0162 cb 77		    bit SPI_DO,a 
0164 20 02		    jr nz, .b6 
0166 cb b1		    res 6,c 
0168			.b6: 
0168				; then low 
0168 cb af			res SPI_SCLK,a 
016a d3 80			out (storage_adata),a 
016c 00				nop 
016d cd f8 00			call spi_clk 
0170			 
0170				; clock bit high 
0170 cb ef			set SPI_SCLK,a 
0172 d3 80			out (storage_adata),a 
0174 00				nop 
0175 cd f8 00			call spi_clk 
0178			 
0178			 
0178			    ; read DO  
0178			 
0178 cb e9		    set 5,c 
017a db 80			in a,(storage_adata) 
017c cb 77		    bit SPI_DO,a 
017e 20 02		    jr nz, .b5 
0180 cb a9		    res 5,c 
0182			.b5: 
0182				; then low 
0182 cb af			res SPI_SCLK,a 
0184 d3 80			out (storage_adata),a 
0186 00				nop 
0187 cd f8 00			call spi_clk 
018a				; clock bit high 
018a cb ef			set SPI_SCLK,a 
018c d3 80			out (storage_adata),a 
018e 00				nop 
018f cd f8 00			call spi_clk 
0192			 
0192			    ; read DO  
0192			 
0192 cb e1		    set 4,c 
0194 db 80			in a,(storage_adata) 
0196 cb 77		    bit SPI_DO,a 
0198 20 02		    jr nz, .b4 
019a cb a1		    res 4,c 
019c			.b4: 
019c				; then low 
019c cb af			res SPI_SCLK,a 
019e d3 80			out (storage_adata),a 
01a0 00				nop 
01a1 cd f8 00			call spi_clk 
01a4				; clock bit high 
01a4 cb ef			set SPI_SCLK,a 
01a6 d3 80			out (storage_adata),a 
01a8 00				nop 
01a9 cd f8 00			call spi_clk 
01ac			 
01ac			    ; read DO  
01ac			 
01ac cb d9		    set 3,c 
01ae db 80			in a,(storage_adata) 
01b0 cb 77		    bit SPI_DO,a 
01b2 20 02		    jr nz, .b3 
01b4 cb 99		    res 3,c 
01b6			.b3: 
01b6				; then low 
01b6 cb af			res SPI_SCLK,a 
01b8 d3 80			out (storage_adata),a 
01ba 00				nop 
01bb cd f8 00			call spi_clk 
01be				; clock bit high 
01be cb ef			set SPI_SCLK,a 
01c0 d3 80			out (storage_adata),a 
01c2 00				nop 
01c3 cd f8 00			call spi_clk 
01c6			 
01c6			    ; read DO  
01c6			 
01c6 cb d1		    set 2,c 
01c8 db 80			in a,(storage_adata) 
01ca cb 77		    bit SPI_DO,a 
01cc 20 02		    jr nz, .b2 
01ce cb 91		    res 2,c 
01d0			.b2: 
01d0				; then low 
01d0 cb af			res SPI_SCLK,a 
01d2 d3 80			out (storage_adata),a 
01d4 00				nop 
01d5 cd f8 00			call spi_clk 
01d8				; clock bit high 
01d8 cb ef			set SPI_SCLK,a 
01da d3 80			out (storage_adata),a 
01dc 00				nop 
01dd cd f8 00			call spi_clk 
01e0			 
01e0			    ; read DO  
01e0			 
01e0 cb c9		    set 1,c 
01e2 db 80			in a,(storage_adata) 
01e4 cb 77		    bit SPI_DO,a 
01e6 20 02		    jr nz, .b1 
01e8 cb 89		    res 1,c 
01ea			.b1: 
01ea				; then low 
01ea cb af			res SPI_SCLK,a 
01ec d3 80			out (storage_adata),a 
01ee 00				nop 
01ef cd f8 00			call spi_clk 
01f2				; clock bit high 
01f2 cb ef			set SPI_SCLK,a 
01f4 d3 80			out (storage_adata),a 
01f6 00				nop 
01f7 cd f8 00			call spi_clk 
01fa			 
01fa			    ; read DO  
01fa			 
01fa cb c1		    set 0,c 
01fc db 80			in a,(storage_adata) 
01fe cb 77		    bit SPI_DO,a 
0200 20 02		    jr nz, .b0 
0202 cb 81		    res 0,c 
0204			.b0: 
0204				; then low 
0204 cb af			res SPI_SCLK,a 
0206 d3 80			out (storage_adata),a 
0208 00				nop 
0209 cd f8 00			call spi_clk 
020c			 
020c			 
020c 32 96 f9			ld (spi_portbyte),a 
020f			 
020f			    ; return byte 
020f 79			    ld a,c 
0210			 
0210			 
0210 c9				ret 
0211			 
0211			 
0211			 
0211			spi_ce_high: 
0211			 
0211				if DEBUG_SPI_HARD_CE0 
0211			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0211					ret 
0211			 
0211				endif 
0211			 
0211			 
0211 f5				push af 
0212			 
0212				; send direct ce to port b 
0212 3e ff			ld a, 255 
0214 d3 81			out (storage_bdata), a 
0216			 
0216 f1				pop af 
0217			 
0217				; for port a that shares with spi lines AND the mask 
0217			  
0217				if DEBUG_SPI 
0217					push hl 
0217					ld h, a 
0217				endif 
0217			;	ld c, SPI_CE_HIGH 
0217			;	and c 
0217 cb c7			set SPI_CE0, a 
0219 cb cf			set SPI_CE1, a 
021b cb d7			set SPI_CE2, a 
021d cb df			set SPI_CE3, a 
021f cb e7			set SPI_CE4, a 
0221			 
0221				if DEBUG_SPI 
0221					ld l, a 
0221					DMARK "CEh" 
0221					CALLMONITOR 
0221					pop hl 
0221				endif 
0221 c9				ret 
0222			 
0222			 
0222			spi_ce_low: 
0222			 
0222				if DEBUG_SPI_HARD_CE0 
0222			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0222					ret 
0222			 
0222				endif 
0222			 
0222 c5				push bc 
0223 f5				push af 
0224			 
0224				; send direct ce to port b 
0224 3a 98 f9			ld a, (spi_cartdev) 
0227 d3 81			out (storage_bdata), a 
0229			 
0229			 
0229			 
0229				; for port a that shares with spi lines AND the mask 
0229			 
0229 3a 95 f9			ld a, (spi_device)  
022c 4f				ld c, a 
022d			 
022d f1				pop af 
022e			 
022e				; detect CEx 
022e			 
022e				if DEBUG_SPI 
022e					push hl 
022e					ld h, a 
022e				endif 
022e			 
022e cb 41			bit SPI_CE0, c 
0230 20 04			jr nz, .cel1 
0232 cb 87			res SPI_CE0, a 
0234 18 1e			jr .celn 
0236			.cel1: 
0236 cb 49			bit SPI_CE1, c 
0238 20 04			jr nz, .cel2 
023a cb 8f			res SPI_CE1, a 
023c 18 16			jr .celn 
023e			.cel2: 
023e cb 51			bit SPI_CE2, c 
0240 20 04			jr nz, .cel3 
0242 cb 97			res SPI_CE2, a 
0244 18 0e			jr .celn 
0246			.cel3: 
0246 cb 59			bit SPI_CE3, c 
0248 20 04			jr nz, .cel4 
024a cb 9f			res SPI_CE3, a 
024c 18 06			jr .celn 
024e			.cel4: 
024e cb 61			bit SPI_CE4, c 
0250 20 02			jr nz, .celn 
0252 cb a7			res SPI_CE4, a 
0254			.celn: 
0254			 
0254			 
0254			 
0254			;	add c 
0254			 
0254				if DEBUG_SPI 
0254					ld l, a 
0254					DMARK "CEl" 
0254					CALLMONITOR 
0254					pop hl 
0254				endif 
0254 c1				pop bc 
0255 c9				ret 
0256			 
0256			 
0256			 
0256			; eof 
0256			 
0256			 
0256			 
0256			 
0256			 
# End of file firmware_spi.asm
0256				include "firmware_seeprom.asm"  
0256			; 
0256			; persisent storage interface via microchip serial eeprom 
0256			 
0256			; port a pio 2 
0256			; pa 7 - si 
0256			; pa 6 - sclk  
0256			; pa 5 - so 
0256			; pa 4 - cs 
0256			; pa 3 - cs 
0256			; pa 2 - cs 
0256			; pa 1 - cs 
0256			; pa 0 - cs 
0256			; 
0256			; TODO get block 
0256			; TODO save block 
0256			; TODO load file 
0256			; TODO save file 
0256			; TODO get dir  
0256			 
0256			;  
0256			storage_adata: equ Device_C    ; device c port a - onboard storage 
0256			storage_actl: equ Device_C+2     ; device c port a 
0256			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0256			storage_bctl: equ Device_C+3     ; device c port b 
0256			 
0256			 
0256			; TODO move these to hardware driver file 
0256			 
0256			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0256			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0256			; storage bank file system format 
0256			; 
0256			; first page of bank: 
0256			; 	addr 0 - status check 
0256			;       addr 1 - write protect flag 
0256			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0256			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0256			;         TODO see if scanning whole of for available next file id is fast enough 
0256			;	addr 4 > zero term string of bank label 
0256			; 
0256			;        
0256			;  
0256			; first page of any file: 
0256			;      byte 0 - file id  
0256			;      byte 1-17 - fixed file name  
0256			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0256			; 
0256			; other pages of any file: 
0256			;      byte 0 - file id 
0256			;      byte 1> - file data 
0256			; 
0256			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0256			;  
0256			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0256			 
0256			 
0256			;storage_so_bit: 5 
0256			;storage_si_bit: 7 
0256			;storage_sclk_bit: 6 
0256			  
0256			 
0256			; init storage pio 
0256			 
0256			storage_init: 
0256			 
0256			 
0256					; set default SPI clk pulse time as disabled 
0256			 
0256 3e 00				ld a, 0 
0258 32 99 f9				ld (spi_clktime), a 
025b			 
025b					; init hardware 
025b			 
025b 3e cf		            LD   A, 11001111b 
025d d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
025f 3e 00		            LD   A, 00000000b 
0261 cb f7			set SPI_DO,a 
0263			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
0263 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0265			 
0265 3e cf		            LD   A, 11001111b 
0267 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
0269 3e 00		            LD   A, 00000000b 
026b d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
026d			 
026d				; set all external spi devices off  
026d 3e ff			ld a, 255 
026f 32 95 f9			ld (spi_device), a 
0272 32 98 f9			ld (spi_cartdev), a 
0275			 
0275					; ensure the spi bus is in a default stable state 
0275 cd 05 01				call se_stable_spi 
0278			 
0278			; TODO scan spi bus and gather which storage banks are present 
0278			 
0278			; populate store_bank_active  
0278			; for each ce line activate and attempt to write first byte of bank and read back 
0278			; if zero is returned then bank is empty 
0278			;   
0278			; 
0278			 
0278					; init file extent cache to save on slow reads 
0278			 
0278			;	ld hl, store_filecache 
0278			;	ld de, 0 
0278			;	ld hl,(de)	 
0278			 
0278			 
0278 c9			    ret 
0279			 
0279			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
0279			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
0279			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
0279			 
0279			; INSTRUCTION SET 
0279			; READ 0000 0011 Read data from memory array beginning at selected address 
0279			; WRITE 0000 0010 Write data to memory array beginning at selected address 
0279			; WREN 0000 0110 Set the write enable latch (enable write operations) 
0279			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
0279			; RDSR 0000 0101 Read STATUS register 
0279			; WRSR 0000 0001 Write STATUS register 
0279			; PE 0100 0010 Page Erase – erase one page in memory array 
0279			; SE 1101 1000 Sector Erase – erase one sector in memory array 
0279			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
0279			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
0279			 
0279			; TODO send byte steam for page without setting the address for every single byte 
0279			; TODO read byte  
0279			 
0279			; byte in a 
0279			; address in hl  
0279			se_writebyte: 
0279			        
0279			    ;   ld c, a 
0279 f5			        push af 
027a e5			        push hl 
027b			 
027b			    ; initi write mode 
027b			    ; 
027b			    ;CS low 
027b			 
027b 3a 96 f9		       ld a,(spi_portbyte) 
027e cd 22 02			call spi_ce_low 
0281			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0281 d3 80		       out (storage_adata),a 
0283 32 96 f9		       ld (spi_portbyte), a 
0286			 
0286			    ;clock out wren instruction 
0286			 
0286 3e 06		    ld a, store_wren_ins 
0288 cd 10 01		    call spi_send_byte  
028b			 
028b			    ;cs high to enable write latch 
028b			 
028b 3a 96 f9		       ld a,(spi_portbyte) 
028e cd 11 02			call spi_ce_high 
0291			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0291 d3 80		       out (storage_adata),a 
0293 32 96 f9		       ld (spi_portbyte), a 
0296			 
0296 00				nop 
0297			    ; 
0297			    ; intial write data 
0297			    ; 
0297			    ; cs low 
0297			     
0297 3a 96 f9		       ld a,(spi_portbyte) 
029a cd 22 02			call spi_ce_low 
029d			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
029d d3 80		       out (storage_adata),a 
029f 32 96 f9		       ld (spi_portbyte), a 
02a2			 
02a2			    ; clock out write instruction 
02a2			     
02a2 3e 02		    ld a, store_write_ins  
02a4 cd 10 01		    call spi_send_byte  
02a7			 
02a7			    ; clock out address (depending on address size) 
02a7			     
02a7 e1			    pop hl 
02a8 7c			    ld a,h    ; address out msb first 
02a9 cd 10 01		    call spi_send_byte  
02ac 7d			    ld a,l 
02ad cd 10 01		    call spi_send_byte  
02b0			 
02b0			    ; clock out byte(s) for page 
02b0			 
02b0 f1			    pop af 
02b1 cd 10 01		    call spi_send_byte  
02b4			 
02b4			    ; end write with ce high 
02b4 3a 96 f9		       ld a,(spi_portbyte) 
02b7			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02b7 cd 11 02			call spi_ce_high 
02ba d3 80		       out (storage_adata),a 
02bc 32 96 f9		       ld (spi_portbyte), a 
02bf			 
02bf				; pause for internal write cycle 
02bf 3e 0a			ld a, 10 
02c1 cd d2 0c			call aDelayInMS 
02c4 c9			    ret 
02c5			 
02c5			; buffer to write in de 
02c5			; address in hl  
02c5			se_writepage: 
02c5			        
02c5			    ;   ld c, a 
02c5 d5				push de 
02c6 e5			        push hl 
02c7			 
02c7			    ; initi write mode 
02c7			    ; 
02c7			    ;CS low 
02c7			 
02c7 3a 96 f9		       ld a,(spi_portbyte) 
02ca cd 22 02			call spi_ce_low 
02cd			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02cd d3 80		       out (storage_adata),a 
02cf 32 96 f9		       ld (spi_portbyte), a 
02d2			 
02d2			    ;clock out wren instruction 
02d2			 
02d2 3e 06		    ld a, store_wren_ins 
02d4 cd 10 01		    call spi_send_byte  
02d7			 
02d7			    ;cs high to enable write latch 
02d7			 
02d7 3a 96 f9		       ld a,(spi_portbyte) 
02da cd 11 02			call spi_ce_high 
02dd			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02dd d3 80		       out (storage_adata),a 
02df 32 96 f9		       ld (spi_portbyte), a 
02e2			 
02e2 00				nop 
02e3			    ; 
02e3			    ; intial write data 
02e3			    ; 
02e3			    ; cs low 
02e3			     
02e3 3a 96 f9		       ld a,(spi_portbyte) 
02e6			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02e6 cd 22 02			call spi_ce_low 
02e9 d3 80		       out (storage_adata),a 
02eb 32 96 f9		       ld (spi_portbyte), a 
02ee			 
02ee			    ; clock out write instruction 
02ee			     
02ee 3e 02		    ld a, store_write_ins  
02f0 cd 10 01		    call spi_send_byte  
02f3			 
02f3			    ; clock out address (depending on address size) 
02f3			     
02f3 e1			    pop hl 
02f4 7c			    ld a,h    ; address out msb first 
02f5 cd 10 01		    call spi_send_byte  
02f8 7d			    ld a,l 
02f9 cd 10 01		    call spi_send_byte  
02fc			 
02fc			    ; clock out byte(s) for page 
02fc			 
02fc e1				pop hl 
02fd 06 40			ld b, STORE_BLOCK_PHY 
02ff			.bytewrite: 
02ff			 
02ff 7e				ld a,(hl) 
0300 e5			    push hl 
0301 c5				push bc 
0302 cd 10 01		    call spi_send_byte  
0305 c1				pop bc 
0306 e1				pop hl 
0307			 
0307			    ; end write with ce high 
0307 3a 96 f9		       ld a,(spi_portbyte) 
030a cd 11 02			call spi_ce_high 
030d			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
030d d3 80		       out (storage_adata),a 
030f 32 96 f9		       ld (spi_portbyte), a 
0312			 
0312 23				inc hl 
0313 10 ea			djnz .bytewrite 
0315			 
0315				; pause for internal write cycle 
0315 3e 64			ld a, 100 
0317 cd d2 0c			call aDelayInMS 
031a c9			    ret 
031b			; returns byte in a 
031b			; address in hl  
031b			se_readbyte: 
031b d5				push de 
031c c5				push bc 
031d			 
031d			    ;   ld c, a 
031d e5			        push hl 
031e			 
031e			    ; initi write mode 
031e			    ; 
031e			    ;CS low 
031e			 
031e 3a 96 f9		       ld a,(spi_portbyte) 
0321 cd 22 02			call spi_ce_low 
0324			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0324 d3 80		       out (storage_adata),a 
0326 32 96 f9		       ld (spi_portbyte), a 
0329			 
0329			    ;clock out wren instruction 
0329			 
0329 3e 03		    ld a, store_read_ins 
032b cd 10 01		    call spi_send_byte  
032e			 
032e			 
032e			    ; clock out address (depending on address size) 
032e			     
032e e1			    pop hl 
032f 7c			    ld a,h    ; address out msb first 
0330 cd 10 01		    call spi_send_byte  
0333 7d			    ld a,l 
0334 cd 10 01		    call spi_send_byte  
0337			 
0337			    ; clock in byte(s) for page 
0337			 
0337 cd 37 01		    call spi_read_byte  
033a f5				push af 
033b			 
033b			    ; end write with ce high 
033b 3a 96 f9		       ld a,(spi_portbyte) 
033e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
033e cd 11 02			call spi_ce_high 
0341 d3 80		       out (storage_adata),a 
0343 32 96 f9		       ld (spi_portbyte), a 
0346			 
0346 f1				pop af 
0347			 
0347 c1				pop bc 
0348 d1				pop de 
0349			 
0349 c9			    ret 
034a			 
034a			if DEBUG_STORESE 
034a			 
034a			storageput:  
034a			 
034a			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
034a			 
034a 21 f8 f0			ld hl,scratch+2 
034d cd 9d 12			call get_word_hl 
0350			 
0350				; stuff it here for the moment as it will be overwritten later anyway 
0350			 
0350 22 19 f4			ld (os_cur_ptr),hl	 
0353			 
0353			 
0353			; get pointer to start of string 
0353			 
0353 21 fd f0			ld hl, scratch+7 
0356			 
0356			; loop writing char of string to eeprom 
0356			 
0356 7e			.writestr:	ld a,(hl) 
0357 fe 00				cp 0 
0359 28 12				jr z, .wsdone		; done writing 
035b e5					push hl 
035c 2a 19 f4				ld hl,(os_cur_ptr) 
035f cd 79 02				call se_writebyte 
0362			 
0362 2a 19 f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0365 23					inc hl 
0366 22 19 f4				ld (os_cur_ptr),hl 
0369			 
0369					; restore string pointer and get next char 
0369			 
0369 e1					pop hl 
036a 23					inc hl 
036b 18 e9				jr .writestr 
036d			 
036d			 
036d			 
036d			.wsdone: 
036d			 
036d			 
036d			; when done load first page into a buffer  
036d			 
036d 21 00 80				ld hl,08000h		; start in ram 
0370 22 19 f4				ld (os_cur_ptr),hl 
0373 21 00 00				ld hl, 0		 ; start of page 
0376 22 1e f1				ld (scratch+40),hl	; hang on to it 
0379			 
0379 06 80				ld b, 128		; actually get more then one page 
037b c5			.wsload:	push bc 
037c 2a 1e f1				ld hl,(scratch+40) 
037f e5					push hl 
0380 cd 1b 03				call se_readbyte 
0383			 
0383					; a now as the byte 
0383			 
0383 2a 19 f4				ld hl,(os_cur_ptr) 
0386 77					ld (hl),a 
0387					; inc next buffer area 
0387 23					inc hl 
0388 22 19 f4				ld (os_cur_ptr),hl 
038b			 
038b					; get eeprom position, inc and save for next round 
038b e1					pop hl		 
038c 23					inc hl 
038d 22 1e f1				ld (scratch+40),hl 
0390 c1					pop bc 
0391 10 e8				djnz .wsload 
0393			 
0393			; set 'd' pointer to start of buffer 
0393			 
0393 21 00 80				ld hl,08000h 
0396 22 19 f4				ld (os_cur_ptr),hl 
0399			 
0399			 
0399 c9			ret 
039a			 
039a			 
039a c9			storageread: ret 
039b			 
039b			 
039b			 
039b			 
039b			 
039b			 
039b			endif 
039b			 
039b			 
039b			 
# End of file firmware_seeprom.asm
039b			else  
039b			   ; create some stubs for the labels  
039b			se_readbyte: ret  
039b			se_writebyte: ret  
039b			storage_init: ret  
039b			  
039b			endif  
039b			  
039b			; use cf card for storage - throwing timeout errors. Hardware or software?????  
039b			;include "firmware_cf.asm"  
039b			  
039b			; load up high level storage hardward abstractions  
039b			include "firmware_storage.asm"  
039b			 
039b			; persisent storage hardware abstraction layer  
039b			 
039b			 
039b			 
039b			; Block 0 on storage is a config state 
039b			 
039b			 
039b			 
039b			; TODO add read phy block and write phy block functions 
039b			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
039b			 
039b			; Abstraction layer  
039b			 
039b			; Logocial block size is same size as physical size - using tape concept 
039b			 
039b			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
039b			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
039b			 
039b			 
039b			 
039b			; Filesystem layout (Logical layout) 
039b			; 
039b			; Block 0 - Bank config  
039b			; 
039b			;      Byte - 0 file id counter 
039b			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
039b			;      Byte - 3-20 zero terminated bank label 
039b			; 
039b			; Block 1 > File storage 
039b			; 
039b			;      Byte 0 file id    - block 0 file details 
039b			;      Byte 1 block id - block 0 is file  
039b			;            Byte 2-15 - File name 
039b			; 
039b			;       - to end of block data 
039b			; 
039b			 
039b			; Get ID for the file named in pointer held HL 
039b			; Returns ID in HL = 255 if no file found 
039b			 
039b			storage_getid: 
039b			 
039b 22 a8 f9			ld (store_tmp1), hl 
039e			 
039e				if DEBUG_STORESE 
039e					DMARK "SGI" 
039e f5				push af  
039f 3a b3 03			ld a, (.dmark)  
03a2 32 a0 fd			ld (debug_mark),a  
03a5 3a b4 03			ld a, (.dmark+1)  
03a8 32 a1 fd			ld (debug_mark+1),a  
03ab 3a b5 03			ld a, (.dmark+2)  
03ae 32 a2 fd			ld (debug_mark+2),a  
03b1 18 03			jr .pastdmark  
03b3 ..			.dmark: db "SGI"  
03b6 f1			.pastdmark: pop af  
03b7			endm  
# End of macro DMARK
03b7					CALLMONITOR 
03b7 cd aa fd			call debug_vector  
03ba				endm  
# End of macro CALLMONITOR
03ba				endif 
03ba				; get block 0 and set counter for number of files to scan 
03ba			 
03ba cd 25 05			call storage_get_block_0 
03bd			 
03bd 3a af f9			ld a, (store_page) 
03c0 47				ld b, a 
03c1			 
03c1				; get extent 0 of each file id 
03c1			 
03c1				if DEBUG_STORESE 
03c1					DMARK "SGc" 
03c1 f5				push af  
03c2 3a d6 03			ld a, (.dmark)  
03c5 32 a0 fd			ld (debug_mark),a  
03c8 3a d7 03			ld a, (.dmark+1)  
03cb 32 a1 fd			ld (debug_mark+1),a  
03ce 3a d8 03			ld a, (.dmark+2)  
03d1 32 a2 fd			ld (debug_mark+2),a  
03d4 18 03			jr .pastdmark  
03d6 ..			.dmark: db "SGc"  
03d9 f1			.pastdmark: pop af  
03da			endm  
# End of macro DMARK
03da					CALLMONITOR 
03da cd aa fd			call debug_vector  
03dd				endm  
# End of macro CALLMONITOR
03dd				endif 
03dd 60			.getloop:	ld h, b 
03de 2e 00				ld l, 0 
03e0 c5					push bc 
03e1			 
03e1 11 af f9				ld de, store_page 
03e4				if DEBUG_STORESE 
03e4					DMARK "SGr" 
03e4 f5				push af  
03e5 3a f9 03			ld a, (.dmark)  
03e8 32 a0 fd			ld (debug_mark),a  
03eb 3a fa 03			ld a, (.dmark+1)  
03ee 32 a1 fd			ld (debug_mark+1),a  
03f1 3a fb 03			ld a, (.dmark+2)  
03f4 32 a2 fd			ld (debug_mark+2),a  
03f7 18 03			jr .pastdmark  
03f9 ..			.dmark: db "SGr"  
03fc f1			.pastdmark: pop af  
03fd			endm  
# End of macro DMARK
03fd					CALLMONITOR 
03fd cd aa fd			call debug_vector  
0400				endm  
# End of macro CALLMONITOR
0400				endif 
0400 cd cd 09				call storage_read 
0403 cd 07 10				call ishlzero 
0406 28 2d				jr z, .gap 
0408					 
0408					; have a file name read. Is it one we want. 
0408			 
0408 2a a8 f9				ld hl, (store_tmp1) 
040b 11 b2 f9				ld de, store_page+3   ; file name 
040e			 
040e				if DEBUG_STORESE 
040e					DMARK "SGc" 
040e f5				push af  
040f 3a 23 04			ld a, (.dmark)  
0412 32 a0 fd			ld (debug_mark),a  
0415 3a 24 04			ld a, (.dmark+1)  
0418 32 a1 fd			ld (debug_mark+1),a  
041b 3a 25 04			ld a, (.dmark+2)  
041e 32 a2 fd			ld (debug_mark+2),a  
0421 18 03			jr .pastdmark  
0423 ..			.dmark: db "SGc"  
0426 f1			.pastdmark: pop af  
0427			endm  
# End of macro DMARK
0427					CALLMONITOR 
0427 cd aa fd			call debug_vector  
042a				endm  
# End of macro CALLMONITOR
042a				endif 
042a cd 7c 13				call strcmp 
042d 20 06				jr nz, .gap   ; not this one 
042f			 
042f c1				        pop bc 
0430			 
0430 26 00				ld h, 0 
0432 68					ld l, b 
0433 18 22				jr .getdone 
0435						 
0435			 
0435			 
0435			 
0435			.gap: 
0435				if DEBUG_STORESE 
0435					DMARK "SGg" 
0435 f5				push af  
0436 3a 4a 04			ld a, (.dmark)  
0439 32 a0 fd			ld (debug_mark),a  
043c 3a 4b 04			ld a, (.dmark+1)  
043f 32 a1 fd			ld (debug_mark+1),a  
0442 3a 4c 04			ld a, (.dmark+2)  
0445 32 a2 fd			ld (debug_mark+2),a  
0448 18 03			jr .pastdmark  
044a ..			.dmark: db "SGg"  
044d f1			.pastdmark: pop af  
044e			endm  
# End of macro DMARK
044e					CALLMONITOR 
044e cd aa fd			call debug_vector  
0451				endm  
# End of macro CALLMONITOR
0451				endif 
0451			 
0451 c1					pop bc 
0452 10 89				djnz .getloop 
0454 21 ff 00				ld hl, 255 
0457			.getdone: 
0457			 
0457				if DEBUG_STORESE 
0457					DMARK "SGe" 
0457 f5				push af  
0458 3a 6c 04			ld a, (.dmark)  
045b 32 a0 fd			ld (debug_mark),a  
045e 3a 6d 04			ld a, (.dmark+1)  
0461 32 a1 fd			ld (debug_mark+1),a  
0464 3a 6e 04			ld a, (.dmark+2)  
0467 32 a2 fd			ld (debug_mark+2),a  
046a 18 03			jr .pastdmark  
046c ..			.dmark: db "SGe"  
046f f1			.pastdmark: pop af  
0470			endm  
# End of macro DMARK
0470					CALLMONITOR 
0470 cd aa fd			call debug_vector  
0473				endm  
# End of macro CALLMONITOR
0473				endif 
0473			 
0473 c9				ret 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			 
0474			; Read Block 
0474			; ---------- 
0474			; 
0474			; With current bank 
0474			;  
0474			; Get block number to read 
0474			; Load physical blocks starting at start block into buffer 
0474			 
0474			; de points to buffer to use 
0474			; hl holds logical block number  
0474			 
0474			storage_read_block: 
0474			 
0474				; TODO bank selection 
0474			 
0474				; for each of the physical blocks read it into the buffer 
0474 06 40			ld b, STORE_BLOCK_PHY 
0476			 
0476				if DEBUG_STORESE 
0476 d5					push de 
0477				endif 
0477				 
0477			.rl1:    
0477			 
0477				; read physical block at hl into de 
0477			        ; increment hl and de to next read position on exit 
0477			 
0477 e5				push hl 
0478 d5				push de	 
0479 c5				push bc 
047a			;	if DEBUG_STORESE 
047a			;		push af 
047a			;		ld a, 'R' 
047a			;		ld (debug_mark),a 
047a			;		pop af 
047a			;		CALLMONITOR 
047a			;	endif 
047a cd 1b 03			call se_readbyte 
047d			;	if DEBUG_STORESE 
047d			;		ld a,(spi_portbyte) 
047d			;		ld l, a 
047d			;		push af 
047d			;		ld a, '1' 
047d			;		ld (debug_mark),a 
047d			;		pop af 
047d			;		CALLMONITOR 
047d			;	endif 
047d c1				pop bc 
047e d1				pop de 
047f e1				pop hl 
0480 12				ld (de),a 
0481 23				inc hl 
0482 13				inc de 
0483			 
0483			;	if DEBUG_STORESE 
0483			;		push af 
0483			;		ld a, 'r' 
0483			;		ld (debug_mark),a 
0483			;		pop af 
0483			;		CALLMONITOR 
0483			;	endif 
0483			 
0483 10 f2			djnz .rl1 
0485			 
0485				if DEBUG_STORESE 
0485					DMARK "SRB" 
0485 f5				push af  
0486 3a 9a 04			ld a, (.dmark)  
0489 32 a0 fd			ld (debug_mark),a  
048c 3a 9b 04			ld a, (.dmark+1)  
048f 32 a1 fd			ld (debug_mark+1),a  
0492 3a 9c 04			ld a, (.dmark+2)  
0495 32 a2 fd			ld (debug_mark+2),a  
0498 18 03			jr .pastdmark  
049a ..			.dmark: db "SRB"  
049d f1			.pastdmark: pop af  
049e			endm  
# End of macro DMARK
049e d1					pop de 
049f			; 
049f			;		push af 
049f			;		ld a, 'R' 
049f			;		ld (debug_mark),a 
049f			;		pop af 
049f					CALLMONITOR 
049f cd aa fd			call debug_vector  
04a2				endm  
# End of macro CALLMONITOR
04a2				endif 
04a2 c9				ret	 
04a3				 
04a3			 
04a3			; File Size 
04a3			; --------- 
04a3			; 
04a3			;   hl file id 
04a3			; 
04a3			;  returns in hl the number of blocks 
04a3			 
04a3			storage_file_size: 
04a3 5d				ld e, l 
04a4 16 00			ld d, 0 
04a6 21 40 00			ld hl, STORE_BLOCK_PHY 
04a9					if DEBUG_FORTH_WORDS 
04a9						DMARK "SIZ" 
04a9 f5				push af  
04aa 3a be 04			ld a, (.dmark)  
04ad 32 a0 fd			ld (debug_mark),a  
04b0 3a bf 04			ld a, (.dmark+1)  
04b3 32 a1 fd			ld (debug_mark+1),a  
04b6 3a c0 04			ld a, (.dmark+2)  
04b9 32 a2 fd			ld (debug_mark+2),a  
04bc 18 03			jr .pastdmark  
04be ..			.dmark: db "SIZ"  
04c1 f1			.pastdmark: pop af  
04c2			endm  
# End of macro DMARK
04c2						CALLMONITOR 
04c2 cd aa fd			call debug_vector  
04c5				endm  
# End of macro CALLMONITOR
04c5					endif 
04c5 cd a7 07			call storage_findnextid 
04c8			 
04c8 cd 07 10			call ishlzero 
04cb			;	ld a, l 
04cb			;	add h 
04cb			;	cp 0 
04cb c8				ret z			; block not found so EOF 
04cc			 
04cc 11 af f9			ld de, store_page 
04cf cd 74 04			call storage_read_block 
04d2			 
04d2 3a b1 f9			ld a, (store_page+2)	 ; get extent count 
04d5 6f				ld l, a 
04d6 26 00			ld h, 0 
04d8 c9			 	ret 
04d9			 
04d9			 
04d9			; Write Block 
04d9			; ----------- 
04d9			; 
04d9			; With current bank 
04d9			;  
04d9			; Get block number to write 
04d9			; Write physical blocks starting at start block from buffer 
04d9			  
04d9			storage_write_block: 
04d9				; TODO bank selection 
04d9			 
04d9				; for each of the physical blocks read it into the buffer 
04d9 06 40			ld b, STORE_BLOCK_PHY 
04db			 
04db				if DEBUG_STORESE 
04db					DMARK "SWB" 
04db f5				push af  
04dc 3a f0 04			ld a, (.dmark)  
04df 32 a0 fd			ld (debug_mark),a  
04e2 3a f1 04			ld a, (.dmark+1)  
04e5 32 a1 fd			ld (debug_mark+1),a  
04e8 3a f2 04			ld a, (.dmark+2)  
04eb 32 a2 fd			ld (debug_mark+2),a  
04ee 18 03			jr .pastdmark  
04f0 ..			.dmark: db "SWB"  
04f3 f1			.pastdmark: pop af  
04f4			endm  
# End of macro DMARK
04f4			 
04f4					;push af 
04f4					;ld a, 'W' 
04f4					;ld (debug_mark),a 
04f4					;pop af 
04f4					CALLMONITOR 
04f4 cd aa fd			call debug_vector  
04f7				endm  
# End of macro CALLMONITOR
04f7				endif 
04f7			 
04f7			; might not be working 
04f7			;	call se_writepage 
04f7			 
04f7			;	ret 
04f7			; 
04f7			 
04f7			 
04f7			 
04f7			.wl1:    
04f7			 
04f7				; read physical block at hl into de 
04f7			        ; increment hl and de to next read position on exit 
04f7			 
04f7 e5				push hl 
04f8 d5				push de	 
04f9 c5				push bc 
04fa 1a				ld a,(de) 
04fb				;if DEBUG_STORESE 
04fb			;		push af 
04fb			;		ld a, 'W' 
04fb			;		ld (debug_mark),a 
04fb			;		pop af 
04fb			;		CALLMONITOR 
04fb			;	endif 
04fb cd 79 02			call se_writebyte 
04fe			;	call delay250ms 
04fe 00				nop 
04ff 00				nop 
0500 00				nop 
0501			;	if DEBUG_STORESE 
0501			;		push af 
0501			;		ld a, 'w' 
0501			;		ld (debug_mark),a 
0501			;		pop af 
0501			;		CALLMONITOR 
0501			;	endif 
0501 c1				pop bc 
0502 d1				pop de 
0503 e1				pop hl 
0504 23				inc hl 
0505 13				inc de 
0506			 
0506			 
0506 10 ef			djnz .wl1 
0508			 
0508				if DEBUG_STORESE 
0508					DMARK "SW2" 
0508 f5				push af  
0509 3a 1d 05			ld a, (.dmark)  
050c 32 a0 fd			ld (debug_mark),a  
050f 3a 1e 05			ld a, (.dmark+1)  
0512 32 a1 fd			ld (debug_mark+1),a  
0515 3a 1f 05			ld a, (.dmark+2)  
0518 32 a2 fd			ld (debug_mark+2),a  
051b 18 03			jr .pastdmark  
051d ..			.dmark: db "SW2"  
0520 f1			.pastdmark: pop af  
0521			endm  
# End of macro DMARK
0521			 
0521					;push af 
0521					;ld a, 'W' 
0521					;ld (debug_mark),a 
0521					;pop af 
0521					CALLMONITOR 
0521 cd aa fd			call debug_vector  
0524				endm  
# End of macro CALLMONITOR
0524				endif 
0524 c9				ret	 
0525			 
0525			; Init bank 
0525			; --------- 
0525			; 
0525			; With current bank 
0525			; 
0525			; Setup block 0 config 
0525			;     Set 0 file id counter 
0525			;     Set formatted byte pattern 
0525			;     Zero out bank label 
0525			;      
0525			; For every logical block write 0-1 byte as null 
0525			 
0525			storage_get_block_0: 
0525			 
0525				; TODO check presence 
0525			 
0525				; get block 0 config 
0525			 
0525 21 00 00			ld hl, 0 
0528 11 af f9			ld de, store_page 
052b cd 74 04			call storage_read_block 
052e			 
052e				if DEBUG_STORESE 
052e					DMARK "SB0" 
052e f5				push af  
052f 3a 43 05			ld a, (.dmark)  
0532 32 a0 fd			ld (debug_mark),a  
0535 3a 44 05			ld a, (.dmark+1)  
0538 32 a1 fd			ld (debug_mark+1),a  
053b 3a 45 05			ld a, (.dmark+2)  
053e 32 a2 fd			ld (debug_mark+2),a  
0541 18 03			jr .pastdmark  
0543 ..			.dmark: db "SB0"  
0546 f1			.pastdmark: pop af  
0547			endm  
# End of macro DMARK
0547 11 af f9				ld de, store_page 
054a			;		push af 
054a			;		ld a, 'i' 
054a			;		ld (debug_mark),a 
054a			;		pop af 
054a					CALLMONITOR 
054a cd aa fd			call debug_vector  
054d				endm  
# End of macro CALLMONITOR
054d				endif 
054d			 
054d				; is this area formatted? 
054d			 
054d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
054d 2a b0 f9			ld hl, (store_page+1) 
0550 3e 80			ld a,0x80 
0552 bd				cp l 
0553 20 22			jr nz, .ininotformatted 
0555				; do a double check 
0555 3e 27			ld a, 0x27 
0557 bc				cp h 
0558 20 1d			jr nz, .ininotformatted 
055a			 
055a				; formatted then 
055a			 
055a				if DEBUG_STORESE 
055a					DMARK "SB1" 
055a f5				push af  
055b 3a 6f 05			ld a, (.dmark)  
055e 32 a0 fd			ld (debug_mark),a  
0561 3a 70 05			ld a, (.dmark+1)  
0564 32 a1 fd			ld (debug_mark+1),a  
0567 3a 71 05			ld a, (.dmark+2)  
056a 32 a2 fd			ld (debug_mark+2),a  
056d 18 03			jr .pastdmark  
056f ..			.dmark: db "SB1"  
0572 f1			.pastdmark: pop af  
0573			endm  
# End of macro DMARK
0573					;push af 
0573					;ld a, 'I' 
0573					;ld (debug_mark),a 
0573					;pop af 
0573					CALLMONITOR 
0573 cd aa fd			call debug_vector  
0576				endm  
# End of macro CALLMONITOR
0576				endif 
0576 c9				ret 
0577			 
0577			.ininotformatted: 
0577				; bank not formatted so poke various bits to make sure 
0577			 
0577				if DEBUG_STORESE 
0577					DMARK "SB2" 
0577 f5				push af  
0578 3a 8c 05			ld a, (.dmark)  
057b 32 a0 fd			ld (debug_mark),a  
057e 3a 8d 05			ld a, (.dmark+1)  
0581 32 a1 fd			ld (debug_mark+1),a  
0584 3a 8e 05			ld a, (.dmark+2)  
0587 32 a2 fd			ld (debug_mark+2),a  
058a 18 03			jr .pastdmark  
058c ..			.dmark: db "SB2"  
058f f1			.pastdmark: pop af  
0590			endm  
# End of macro DMARK
0590					;push af 
0590					;ld a, 'f' 
0590					;ld (debug_mark),a 
0590					;pop af 
0590					CALLMONITOR 
0590 cd aa fd			call debug_vector  
0593				endm  
# End of macro CALLMONITOR
0593				endif 
0593			 
0593 cd b0 0c			call storage_clear_page 
0596			 
0596 21 af f9			ld hl, store_page 
0599 3e 00			ld a, 0 
059b				 
059b 77				ld (hl),a   ; reset file counter 
059c			 
059c 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
059f 22 b0 f9		 	ld (store_page+1), hl	 
05a2			 
05a2				; set default label 
05a2			 
05a2 21 3e 06			ld hl, .defaultbanklabl 
05a5 11 b2 f9		 	ld de, store_page+3 
05a8 01 0f 00			ld bc, 15 
05ab ed b0			ldir 
05ad			 
05ad				; Append the current bank id 
05ad 21 bb f9			ld hl, store_page+3+9 
05b0 3a 94 f9			ld a, (spi_device_id) 
05b3 77				ld (hl), a 
05b4			 
05b4				; save default page 0 
05b4			 
05b4 21 00 00			ld hl, 0 
05b7 11 af f9			ld de, store_page 
05ba				if DEBUG_STORESE 
05ba					DMARK "SB3" 
05ba f5				push af  
05bb 3a cf 05			ld a, (.dmark)  
05be 32 a0 fd			ld (debug_mark),a  
05c1 3a d0 05			ld a, (.dmark+1)  
05c4 32 a1 fd			ld (debug_mark+1),a  
05c7 3a d1 05			ld a, (.dmark+2)  
05ca 32 a2 fd			ld (debug_mark+2),a  
05cd 18 03			jr .pastdmark  
05cf ..			.dmark: db "SB3"  
05d2 f1			.pastdmark: pop af  
05d3			endm  
# End of macro DMARK
05d3			;		push af 
05d3			;		ld a, 'F' 
05d3			;		ld (debug_mark),a 
05d3			;		pop af 
05d3					CALLMONITOR 
05d3 cd aa fd			call debug_vector  
05d6				endm  
# End of macro CALLMONITOR
05d6				endif 
05d6 cd d9 04			call storage_write_block 
05d9				if DEBUG_STORESE 
05d9					DMARK "SB4" 
05d9 f5				push af  
05da 3a ee 05			ld a, (.dmark)  
05dd 32 a0 fd			ld (debug_mark),a  
05e0 3a ef 05			ld a, (.dmark+1)  
05e3 32 a1 fd			ld (debug_mark+1),a  
05e6 3a f0 05			ld a, (.dmark+2)  
05e9 32 a2 fd			ld (debug_mark+2),a  
05ec 18 03			jr .pastdmark  
05ee ..			.dmark: db "SB4"  
05f1 f1			.pastdmark: pop af  
05f2			endm  
# End of macro DMARK
05f2			;		push af 
05f2			;		ld a, '>' 
05f2			;		ld (debug_mark),a 
05f2			;		pop af 
05f2					CALLMONITOR 
05f2 cd aa fd			call debug_vector  
05f5				endm  
# End of macro CALLMONITOR
05f5				endif 
05f5			 
05f5 00				nop 
05f6 00				nop 
05f7 00				nop 
05f8			 
05f8				; now set 0 in every page to mark as a free block 
05f8			 
05f8 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05fa 21 40 00			ld hl, STORE_BLOCK_PHY 
05fd			 
05fd 3e 00		.setmark1:   	ld a,0 
05ff e5					push hl 
0600 c5					push bc 
0601 cd 79 02				call se_writebyte 
0604 3e 0a			ld a, 10 
0606 cd d2 0c			call aDelayInMS 
0609 23				inc hl 
060a cd 79 02				call se_writebyte 
060d 3e 0a			ld a, 10 
060f cd d2 0c			call aDelayInMS 
0612 2b				dec hl 
0613 c1					pop bc 
0614 e1					pop hl 
0615 3e 40				ld a, STORE_BLOCK_PHY 
0617 cd de 0f				call addatohl 
061a 10 e1				djnz .setmark1 
061c			 
061c 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
061e 3e 00		.setmark2:   	ld a,0 
0620 e5					push hl 
0621 c5					push bc 
0622 cd 79 02				call se_writebyte 
0625 3e 0a			ld a, 10 
0627 cd d2 0c			call aDelayInMS 
062a 23				inc hl 
062b cd 79 02				call se_writebyte 
062e 3e 0a			ld a, 10 
0630 cd d2 0c			call aDelayInMS 
0633 2b				dec hl 
0634 c1					pop bc 
0635 e1					pop hl 
0636 3e 40				ld a, STORE_BLOCK_PHY 
0638 cd de 0f				call addatohl 
063b 10 e1				djnz .setmark2 
063d			 
063d					 
063d			 
063d			 
063d c9				ret 
063e			 
063e			 
063e			 
063e			 
063e .. 00		.defaultbanklabl:   db "BankLabel_",0 
0649			 
0649			 
0649			 
0649			; Label Bank 
0649			; ---------- 
0649			; 
0649			; With current bank 
0649			; Read block 0 
0649			; Set label 
0649			; Write block 0 
0649			 
0649			; label str pointer in hl 
0649			 
0649			storage_label:     
0649			 
0649				if DEBUG_STORESE 
0649					DMARK "LBL" 
0649 f5				push af  
064a 3a 5e 06			ld a, (.dmark)  
064d 32 a0 fd			ld (debug_mark),a  
0650 3a 5f 06			ld a, (.dmark+1)  
0653 32 a1 fd			ld (debug_mark+1),a  
0656 3a 60 06			ld a, (.dmark+2)  
0659 32 a2 fd			ld (debug_mark+2),a  
065c 18 03			jr .pastdmark  
065e ..			.dmark: db "LBL"  
0661 f1			.pastdmark: pop af  
0662			endm  
# End of macro DMARK
0662					CALLMONITOR 
0662 cd aa fd			call debug_vector  
0665				endm  
# End of macro CALLMONITOR
0665				endif 
0665			 
0665 e5				push hl 
0666			 
0666 cd 25 05			call storage_get_block_0 
0669			 
0669				; set default label 
0669			 
0669 e1				pop hl 
066a			 
066a 11 b2 f9		 	ld de, store_page+3 
066d 01 0f 00			ld bc, 15 
0670				if DEBUG_STORESE 
0670					DMARK "LB3" 
0670 f5				push af  
0671 3a 85 06			ld a, (.dmark)  
0674 32 a0 fd			ld (debug_mark),a  
0677 3a 86 06			ld a, (.dmark+1)  
067a 32 a1 fd			ld (debug_mark+1),a  
067d 3a 87 06			ld a, (.dmark+2)  
0680 32 a2 fd			ld (debug_mark+2),a  
0683 18 03			jr .pastdmark  
0685 ..			.dmark: db "LB3"  
0688 f1			.pastdmark: pop af  
0689			endm  
# End of macro DMARK
0689					CALLMONITOR 
0689 cd aa fd			call debug_vector  
068c				endm  
# End of macro CALLMONITOR
068c				endif 
068c ed b0			ldir 
068e				; save default page 0 
068e			 
068e 21 00 00			ld hl, 0 
0691 11 af f9			ld de, store_page 
0694				if DEBUG_STORESE 
0694					DMARK "LBW" 
0694 f5				push af  
0695 3a a9 06			ld a, (.dmark)  
0698 32 a0 fd			ld (debug_mark),a  
069b 3a aa 06			ld a, (.dmark+1)  
069e 32 a1 fd			ld (debug_mark+1),a  
06a1 3a ab 06			ld a, (.dmark+2)  
06a4 32 a2 fd			ld (debug_mark+2),a  
06a7 18 03			jr .pastdmark  
06a9 ..			.dmark: db "LBW"  
06ac f1			.pastdmark: pop af  
06ad			endm  
# End of macro DMARK
06ad					CALLMONITOR 
06ad cd aa fd			call debug_vector  
06b0				endm  
# End of macro CALLMONITOR
06b0				endif 
06b0 cd d9 04			call storage_write_block 
06b3			 
06b3 c9				ret 
06b4			 
06b4			 
06b4			 
06b4			; Read Block 0 - Config 
06b4			; --------------------- 
06b4			; 
06b4			; With current bank 
06b4			; Call presence test 
06b4			;    If not present format/init bank  
06b4			; Read block 0  
06b4			;  
06b4			 
06b4			 
06b4			; Dir 
06b4			; --- 
06b4			; 
06b4			; With current bank 
06b4			; Load Block 0 Config 
06b4			; Get max file id number 
06b4			; For each logical block 
06b4			;    Read block read byte 2 
06b4			;      if first block of file 
06b4			;         Display file name 
06b4			;         Display type flags for file 
06b4			;        
06b4			 
06b4			; moving to words as this requires stack control 
06b4			 
06b4			 
06b4			; Delete File 
06b4			; ----------- 
06b4			; 
06b4			; With current bank 
06b4			; 
06b4			; Load Block 0 Config 
06b4			; Get max file id number 
06b4			; For each logical block 
06b4			;    Read block file id 
06b4			;      If first block of file and dont have file id 
06b4			;         if file to delete 
06b4			;         Save file id 
06b4			;         Null file id 
06b4			;         Write this block back 
06b4			;      If file id is one saved 
06b4			;         Null file id 
06b4			;         Write this block back 
06b4			 
06b4			 
06b4			.se_done: 
06b4 e1				pop hl 
06b5 c9				ret 
06b6			 
06b6			storage_erase: 
06b6			 
06b6				; hl contains the file id 
06b6			 
06b6 5d				ld e, l 
06b7 16 00			ld d, 0 
06b9 21 40 00			ld hl, STORE_BLOCK_PHY 
06bc					if DEBUG_FORTH_WORDS 
06bc						DMARK "ERA" 
06bc f5				push af  
06bd 3a d1 06			ld a, (.dmark)  
06c0 32 a0 fd			ld (debug_mark),a  
06c3 3a d2 06			ld a, (.dmark+1)  
06c6 32 a1 fd			ld (debug_mark+1),a  
06c9 3a d3 06			ld a, (.dmark+2)  
06cc 32 a2 fd			ld (debug_mark+2),a  
06cf 18 03			jr .pastdmark  
06d1 ..			.dmark: db "ERA"  
06d4 f1			.pastdmark: pop af  
06d5			endm  
# End of macro DMARK
06d5						CALLMONITOR 
06d5 cd aa fd			call debug_vector  
06d8				endm  
# End of macro CALLMONITOR
06d8					endif 
06d8 cd a7 07			call storage_findnextid 
06db cd 07 10			call ishlzero 
06de c8				ret z 
06df			 
06df e5				push hl 
06e0			 
06e0				; TODO check file not found 
06e0			 
06e0 11 af f9			ld de, store_page 
06e3 cd 74 04			call storage_read_block 
06e6			 
06e6 cd 07 10			call ishlzero 
06e9 ca b4 06			jp z,.se_done 
06ec			 
06ec					if DEBUG_FORTH_WORDS 
06ec						DMARK "ER1" 
06ec f5				push af  
06ed 3a 01 07			ld a, (.dmark)  
06f0 32 a0 fd			ld (debug_mark),a  
06f3 3a 02 07			ld a, (.dmark+1)  
06f6 32 a1 fd			ld (debug_mark+1),a  
06f9 3a 03 07			ld a, (.dmark+2)  
06fc 32 a2 fd			ld (debug_mark+2),a  
06ff 18 03			jr .pastdmark  
0701 ..			.dmark: db "ER1"  
0704 f1			.pastdmark: pop af  
0705			endm  
# End of macro DMARK
0705						CALLMONITOR 
0705 cd aa fd			call debug_vector  
0708				endm  
# End of macro CALLMONITOR
0708					endif 
0708 3a af f9			ld a, (store_page)	; get file id 
070b 32 a3 f9			ld (store_tmpid), a 
070e			 
070e 3a b1 f9			ld a, (store_page+2)    ; get count of extends 
0711 32 a2 f9			ld (store_tmpext), a 
0714			 
0714				; wipe file header 
0714			 
0714 e1				pop hl 
0715 3e 00			ld a, 0 
0717 32 af f9			ld (store_page), a 
071a 32 b0 f9			ld (store_page+1),a 
071d 11 af f9			ld de, store_page 
0720					if DEBUG_FORTH_WORDS 
0720						DMARK "ER2" 
0720 f5				push af  
0721 3a 35 07			ld a, (.dmark)  
0724 32 a0 fd			ld (debug_mark),a  
0727 3a 36 07			ld a, (.dmark+1)  
072a 32 a1 fd			ld (debug_mark+1),a  
072d 3a 37 07			ld a, (.dmark+2)  
0730 32 a2 fd			ld (debug_mark+2),a  
0733 18 03			jr .pastdmark  
0735 ..			.dmark: db "ER2"  
0738 f1			.pastdmark: pop af  
0739			endm  
# End of macro DMARK
0739						CALLMONITOR 
0739 cd aa fd			call debug_vector  
073c				endm  
# End of macro CALLMONITOR
073c					endif 
073c cd d9 04			call storage_write_block 
073f			 
073f			 
073f				; wipe file extents 
073f			 
073f 3a a2 f9			ld a, (store_tmpext) 
0742 47				ld b, a 
0743			 
0743			.eraext:	  
0743 c5				push bc 
0744			 
0744 21 40 00			ld hl, STORE_BLOCK_PHY 
0747 3a a3 f9			ld a,(store_tmpid) 
074a 5f				ld e, a 
074b 50				ld d, b	 
074c					if DEBUG_FORTH_WORDS 
074c						DMARK "ER3" 
074c f5				push af  
074d 3a 61 07			ld a, (.dmark)  
0750 32 a0 fd			ld (debug_mark),a  
0753 3a 62 07			ld a, (.dmark+1)  
0756 32 a1 fd			ld (debug_mark+1),a  
0759 3a 63 07			ld a, (.dmark+2)  
075c 32 a2 fd			ld (debug_mark+2),a  
075f 18 03			jr .pastdmark  
0761 ..			.dmark: db "ER3"  
0764 f1			.pastdmark: pop af  
0765			endm  
# End of macro DMARK
0765						CALLMONITOR 
0765 cd aa fd			call debug_vector  
0768				endm  
# End of macro CALLMONITOR
0768					endif 
0768 cd a7 07			call storage_findnextid 
076b cd 07 10			call ishlzero 
076e ca b4 06			jp z,.se_done 
0771			 
0771 e5				push hl 
0772 11 af f9			ld de, store_page 
0775 cd 74 04			call storage_read_block 
0778			 
0778				; free block	 
0778			 
0778 3e 00			ld a, 0 
077a 32 af f9			ld (store_page), a 
077d 32 b0 f9			ld (store_page+1),a 
0780 11 af f9			ld de, store_page 
0783 e1				pop hl 
0784					if DEBUG_FORTH_WORDS 
0784						DMARK "ER4" 
0784 f5				push af  
0785 3a 99 07			ld a, (.dmark)  
0788 32 a0 fd			ld (debug_mark),a  
078b 3a 9a 07			ld a, (.dmark+1)  
078e 32 a1 fd			ld (debug_mark+1),a  
0791 3a 9b 07			ld a, (.dmark+2)  
0794 32 a2 fd			ld (debug_mark+2),a  
0797 18 03			jr .pastdmark  
0799 ..			.dmark: db "ER4"  
079c f1			.pastdmark: pop af  
079d			endm  
# End of macro DMARK
079d						CALLMONITOR 
079d cd aa fd			call debug_vector  
07a0				endm  
# End of macro CALLMONITOR
07a0					endif 
07a0 cd d9 04			call storage_write_block 
07a3			 
07a3 c1				pop bc 
07a4 10 9d			djnz .eraext 
07a6			 
07a6 c9				ret 
07a7			 
07a7			 
07a7			; Find Free Block 
07a7			; --------------- 
07a7			; 
07a7			; With current bank 
07a7			;  
07a7			; From given starting logical block 
07a7			;    Read block  
07a7			;    If no file id 
07a7			;         Return block id 
07a7			 
07a7			 
07a7			; hl starting page number 
07a7			; hl contains free page number or zero if no pages free 
07a7			; e contains the file id to locate 
07a7			; d contains the block number 
07a7			 
07a7			; TODO change to find file id and use zero for free block 
07a7			 
07a7			storage_findnextid: 
07a7			 
07a7				; now locate first 0 page to mark as a free block 
07a7			 
07a7 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07a9			;	ld hl, STORE_BLOCK_PHY 
07a9			 
07a9					if DEBUG_FORTH_WORDS 
07a9					DMARK "FNI" 
07a9 f5				push af  
07aa 3a be 07			ld a, (.dmark)  
07ad 32 a0 fd			ld (debug_mark),a  
07b0 3a bf 07			ld a, (.dmark+1)  
07b3 32 a1 fd			ld (debug_mark+1),a  
07b6 3a c0 07			ld a, (.dmark+2)  
07b9 32 a2 fd			ld (debug_mark+2),a  
07bc 18 03			jr .pastdmark  
07be ..			.dmark: db "FNI"  
07c1 f1			.pastdmark: pop af  
07c2			endm  
# End of macro DMARK
07c2						CALLMONITOR 
07c2 cd aa fd			call debug_vector  
07c5				endm  
# End of macro CALLMONITOR
07c5					endif 
07c5			.ff1:   	 
07c5 e5					push hl 
07c6 c5					push bc 
07c7 d5					push de 
07c8 cd 1b 03				call se_readbyte 
07cb 5f					ld e,a 
07cc 23					inc hl 
07cd cd 1b 03				call se_readbyte 
07d0 57					ld d, a 
07d1 e1					pop hl 
07d2 e5					push hl 
07d3 cd fc 0f				call cmp16 
07d6 28 49				jr z, .fffound 
07d8			 
07d8 d1					pop de 
07d9 c1					pop bc 
07da e1					pop hl 
07db			 
07db					; is found? 
07db					;cp e 
07db					;ret z 
07db			 
07db 3e 40				ld a, STORE_BLOCK_PHY 
07dd cd de 0f				call addatohl 
07e0 10 e3				djnz .ff1 
07e2			 
07e2 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07e4			.ff2:   	 
07e4			 
07e4 e5					push hl 
07e5 c5					push bc 
07e6 d5					push de 
07e7 cd 1b 03				call se_readbyte 
07ea 5f					ld e,a 
07eb 23					inc hl 
07ec cd 1b 03				call se_readbyte 
07ef 57					ld d, a 
07f0			 
07f0 e1					pop hl 
07f1 e5					push hl 
07f2 cd fc 0f				call cmp16 
07f5 28 2a				jr z, .fffound 
07f7			 
07f7 d1					pop de 
07f8 c1					pop bc 
07f9 e1					pop hl 
07fa					; is found? 
07fa					;cp e 
07fa					;ret z 
07fa			 
07fa 3e 40				ld a, STORE_BLOCK_PHY 
07fc cd de 0f				call addatohl 
07ff 10 e3				djnz .ff2 
0801			 
0801			 
0801					if DEBUG_FORTH_WORDS 
0801					DMARK "FN-" 
0801 f5				push af  
0802 3a 16 08			ld a, (.dmark)  
0805 32 a0 fd			ld (debug_mark),a  
0808 3a 17 08			ld a, (.dmark+1)  
080b 32 a1 fd			ld (debug_mark+1),a  
080e 3a 18 08			ld a, (.dmark+2)  
0811 32 a2 fd			ld (debug_mark+2),a  
0814 18 03			jr .pastdmark  
0816 ..			.dmark: db "FN-"  
0819 f1			.pastdmark: pop af  
081a			endm  
# End of macro DMARK
081a					;	push af 
081a					;	ld a, 'n' 
081a					;	ld (debug_mark),a 
081a					;	pop af 
081a						CALLMONITOR 
081a cd aa fd			call debug_vector  
081d				endm  
# End of macro CALLMONITOR
081d					endif 
081d				; no free marks! 
081d 21 00 00				ld hl, 0 
0820 c9				ret 
0821			.fffound: 
0821				 
0821			 
0821 d1					pop de 
0822 c1					pop bc 
0823 e1					pop hl 
0824					if DEBUG_FORTH_WORDS 
0824					DMARK "FNF" 
0824 f5				push af  
0825 3a 39 08			ld a, (.dmark)  
0828 32 a0 fd			ld (debug_mark),a  
082b 3a 3a 08			ld a, (.dmark+1)  
082e 32 a1 fd			ld (debug_mark+1),a  
0831 3a 3b 08			ld a, (.dmark+2)  
0834 32 a2 fd			ld (debug_mark+2),a  
0837 18 03			jr .pastdmark  
0839 ..			.dmark: db "FNF"  
083c f1			.pastdmark: pop af  
083d			endm  
# End of macro DMARK
083d					;	push af 
083d					;	ld a, 'n' 
083d					;	ld (debug_mark),a 
083d					;	pop af 
083d						CALLMONITOR 
083d cd aa fd			call debug_vector  
0840				endm  
# End of macro CALLMONITOR
0840					endif 
0840 c9				ret 
0841			 
0841			 
0841			 
0841			; Free Space 
0841			; ---------- 
0841			; 
0841			; With current bank 
0841			; 
0841			; Set block count to zero 
0841			; Starting with first logical block 
0841			;      Find free block  
0841			;      If block id given, increment block count 
0841			; 
0841			;  
0841			 
0841			 
0841			; hl contains count of free blocks 
0841			 
0841			storage_freeblocks: 
0841			 
0841				; now locate first 0 page to mark as a free block 
0841			 
0841 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0843 21 40 00			ld hl, STORE_BLOCK_PHY 
0846 11 00 00			ld de, 0 
0849			 
0849			.fb1:   	 
0849 e5					push hl 
084a c5					push bc 
084b d5					push de 
084c cd 1b 03				call se_readbyte 
084f d1					pop de 
0850 c1					pop bc 
0851 e1					pop hl 
0852			 
0852					; is free? 
0852 fe 00				cp 0 
0854 20 01				jr nz, .ff1cont 
0856 13					inc de 
0857			 
0857			.ff1cont: 
0857			 
0857			 
0857 3e 40				ld a, STORE_BLOCK_PHY 
0859 cd de 0f				call addatohl 
085c 10 eb				djnz .fb1 
085e			 
085e 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0860			.fb2:   	 
0860 e5					push hl 
0861 c5					push bc 
0862 d5					push de 
0863 cd 1b 03				call se_readbyte 
0866 d1					pop de 
0867 c1					pop bc 
0868 e1					pop hl 
0869			 
0869					; is free? 
0869 fe 00				cp 0 
086b 20 01				jr nz, .ff2cont 
086d 13					inc de 
086e			 
086e			.ff2cont: 
086e			 
086e 3e 40				ld a, STORE_BLOCK_PHY 
0870 cd de 0f				call addatohl 
0873 10 eb				djnz .fb2 
0875			 
0875 eb				ex de, hl 
0876 c9				ret 
0877			 
0877			; Get File ID 
0877			; ----------- 
0877			; 
0877			; With current bank 
0877			;  
0877			; Load Block 0 Config 
0877			; Get max file id number 
0877			; For each logical block 
0877			;    Read block file id 
0877			;      If first block of file and dont have file id 
0877			;         if file get id and exit 
0877			 
0877			 
0877			 
0877			 
0877			; Create File 
0877			; ----------- 
0877			; 
0877			; With current bank  
0877			; Load Block 0 Config 
0877			; Get max file id number 
0877			; Increment file id number 
0877			; Save Config 
0877			; Find free block 
0877			; Set buffer with file name and file id 
0877			; Write buffer to free block  
0877			 
0877			 
0877			; hl point to file name 
0877			; hl returns file id 
0877			 
0877			; file format: 
0877			; byte 0 - file id 
0877			; byte 1 - extent number 
0877			; byte 2-> data 
0877			 
0877			; format for extent number 0: 
0877			; 
0877			; byte 0 - file id 
0877			; byte 1 - extent 0 
0877			; byte 2 - extent count 
0877			; byte 3 -> file name and meta data 
0877			 
0877			 
0877			storage_create: 
0877				if DEBUG_STORESE 
0877					DMARK "SCR" 
0877 f5				push af  
0878 3a 8c 08			ld a, (.dmark)  
087b 32 a0 fd			ld (debug_mark),a  
087e 3a 8d 08			ld a, (.dmark+1)  
0881 32 a1 fd			ld (debug_mark+1),a  
0884 3a 8e 08			ld a, (.dmark+2)  
0887 32 a2 fd			ld (debug_mark+2),a  
088a 18 03			jr .pastdmark  
088c ..			.dmark: db "SCR"  
088f f1			.pastdmark: pop af  
0890			endm  
# End of macro DMARK
0890					CALLMONITOR 
0890 cd aa fd			call debug_vector  
0893				endm  
# End of macro CALLMONITOR
0893				endif 
0893			 
0893 e5				push hl		; save file name pointer 
0894			 
0894 cd 25 05			call storage_get_block_0 
0897			 
0897 3a af f9			ld a,(store_page)	; get current file id 
089a 3c				inc a 
089b 32 af f9			ld (store_page),a 
089e				 
089e 32 a3 f9			ld (store_tmpid),a			; save id 
08a1			 
08a1 21 00 00			ld hl, 0 
08a4 11 af f9			ld de, store_page 
08a7				if DEBUG_STORESE 
08a7					DMARK "SCw" 
08a7 f5				push af  
08a8 3a bc 08			ld a, (.dmark)  
08ab 32 a0 fd			ld (debug_mark),a  
08ae 3a bd 08			ld a, (.dmark+1)  
08b1 32 a1 fd			ld (debug_mark+1),a  
08b4 3a be 08			ld a, (.dmark+2)  
08b7 32 a2 fd			ld (debug_mark+2),a  
08ba 18 03			jr .pastdmark  
08bc ..			.dmark: db "SCw"  
08bf f1			.pastdmark: pop af  
08c0			endm  
# End of macro DMARK
08c0					CALLMONITOR 
08c0 cd aa fd			call debug_vector  
08c3				endm  
# End of macro CALLMONITOR
08c3				endif 
08c3 cd d9 04			call storage_write_block	 ; save update 
08c6			 
08c6				if DEBUG_STORESE 
08c6 11 af f9				ld de, store_page 
08c9					DMARK "SCC" 
08c9 f5				push af  
08ca 3a de 08			ld a, (.dmark)  
08cd 32 a0 fd			ld (debug_mark),a  
08d0 3a df 08			ld a, (.dmark+1)  
08d3 32 a1 fd			ld (debug_mark+1),a  
08d6 3a e0 08			ld a, (.dmark+2)  
08d9 32 a2 fd			ld (debug_mark+2),a  
08dc 18 03			jr .pastdmark  
08de ..			.dmark: db "SCC"  
08e1 f1			.pastdmark: pop af  
08e2			endm  
# End of macro DMARK
08e2					CALLMONITOR 
08e2 cd aa fd			call debug_vector  
08e5				endm  
# End of macro CALLMONITOR
08e5				endif 
08e5				;  
08e5				 
08e5 21 40 00			ld hl, STORE_BLOCK_PHY 
08e8 11 00 00			ld de, 0 
08eb cd a7 07			call storage_findnextid 
08ee			 
08ee 22 9a f9			ld (store_tmppageid), hl    ; save page to use  
08f1			 
08f1				; TODO detect 0 = no spare blocks 
08f1			 
08f1				; hl now contains the free page to use for the file header page 
08f1			 
08f1				if DEBUG_STORESE 
08f1				DMARK "SCF" 
08f1 f5				push af  
08f2 3a 06 09			ld a, (.dmark)  
08f5 32 a0 fd			ld (debug_mark),a  
08f8 3a 07 09			ld a, (.dmark+1)  
08fb 32 a1 fd			ld (debug_mark+1),a  
08fe 3a 08 09			ld a, (.dmark+2)  
0901 32 a2 fd			ld (debug_mark+2),a  
0904 18 03			jr .pastdmark  
0906 ..			.dmark: db "SCF"  
0909 f1			.pastdmark: pop af  
090a			endm  
# End of macro DMARK
090a					CALLMONITOR 
090a cd aa fd			call debug_vector  
090d				endm  
# End of macro CALLMONITOR
090d				endif 
090d			 
090d 22 9a f9			ld (store_tmppageid), hl 
0910				 
0910 3a a3 f9			ld a,(store_tmpid)    ; get file id 
0913			;	ld a, (store_filecache)			; save to cache 
0913			 
0913 32 af f9			ld (store_page),a    ; set page id 
0916 3e 00			ld a, 0			 ; extent 0 is file header 
0918 32 b0 f9			ld (store_page+1), a   ; set file extent 
091b			 
091b 32 b1 f9			ld (store_page+2), a   ; extent count for the file 
091e			 
091e			;	inc hl 		; init block 0 of file 
091e			;	inc hl   		; skip file and extent id 
091e			 ;       ld a, 0 
091e			;	ld (hl),a 
091e			;	ld a, (store_filecache+1)  	; save to cache 
091e			 
091e			;	inc hl    ; file name 
091e				 
091e				 
091e 11 b2 f9			ld de, store_page+3    ; get buffer for term string to use as file name 
0921				if DEBUG_STORESE 
0921					DMARK "SCc" 
0921 f5				push af  
0922 3a 36 09			ld a, (.dmark)  
0925 32 a0 fd			ld (debug_mark),a  
0928 3a 37 09			ld a, (.dmark+1)  
092b 32 a1 fd			ld (debug_mark+1),a  
092e 3a 38 09			ld a, (.dmark+2)  
0931 32 a2 fd			ld (debug_mark+2),a  
0934 18 03			jr .pastdmark  
0936 ..			.dmark: db "SCc"  
0939 f1			.pastdmark: pop af  
093a			endm  
# End of macro DMARK
093a					CALLMONITOR 
093a cd aa fd			call debug_vector  
093d				endm  
# End of macro CALLMONITOR
093d				endif 
093d e1				pop hl    ; get zero term string 
093e e5				push hl 
093f 3e 00			ld a, 0 
0941 cd 4f 13			call strlent 
0944 23				inc hl   ; cover zero term 
0945 06 00			ld b,0 
0947 4d				ld c,l 
0948 e1				pop hl 
0949				;ex de, hl 
0949				if DEBUG_STORESE 
0949					DMARK "SCa" 
0949 f5				push af  
094a 3a 5e 09			ld a, (.dmark)  
094d 32 a0 fd			ld (debug_mark),a  
0950 3a 5f 09			ld a, (.dmark+1)  
0953 32 a1 fd			ld (debug_mark+1),a  
0956 3a 60 09			ld a, (.dmark+2)  
0959 32 a2 fd			ld (debug_mark+2),a  
095c 18 03			jr .pastdmark  
095e ..			.dmark: db "SCa"  
0961 f1			.pastdmark: pop af  
0962			endm  
# End of macro DMARK
0962					;push af 
0962					;ld a, 'a' 
0962					;ld (debug_mark),a 
0962					;pop af 
0962					CALLMONITOR 
0962 cd aa fd			call debug_vector  
0965				endm  
# End of macro CALLMONITOR
0965				endif 
0965 ed b0			ldir    ; copy zero term string 
0967				if DEBUG_STORESE 
0967					DMARK "SCA" 
0967 f5				push af  
0968 3a 7c 09			ld a, (.dmark)  
096b 32 a0 fd			ld (debug_mark),a  
096e 3a 7d 09			ld a, (.dmark+1)  
0971 32 a1 fd			ld (debug_mark+1),a  
0974 3a 7e 09			ld a, (.dmark+2)  
0977 32 a2 fd			ld (debug_mark+2),a  
097a 18 03			jr .pastdmark  
097c ..			.dmark: db "SCA"  
097f f1			.pastdmark: pop af  
0980			endm  
# End of macro DMARK
0980					CALLMONITOR 
0980 cd aa fd			call debug_vector  
0983				endm  
# End of macro CALLMONITOR
0983				endif 
0983			 
0983				; write file header page 
0983			 
0983 2a 9a f9			ld hl,(store_tmppageid) 
0986 11 af f9			ld de, store_page 
0989				if DEBUG_STORESE 
0989					DMARK "SCb" 
0989 f5				push af  
098a 3a 9e 09			ld a, (.dmark)  
098d 32 a0 fd			ld (debug_mark),a  
0990 3a 9f 09			ld a, (.dmark+1)  
0993 32 a1 fd			ld (debug_mark+1),a  
0996 3a a0 09			ld a, (.dmark+2)  
0999 32 a2 fd			ld (debug_mark+2),a  
099c 18 03			jr .pastdmark  
099e ..			.dmark: db "SCb"  
09a1 f1			.pastdmark: pop af  
09a2			endm  
# End of macro DMARK
09a2					;push af 
09a2					;ld a, 'b' 
09a2					;ld (debug_mark),a 
09a2					;pop af 
09a2					CALLMONITOR 
09a2 cd aa fd			call debug_vector  
09a5				endm  
# End of macro CALLMONITOR
09a5				endif 
09a5 cd d9 04			call storage_write_block 
09a8			 
09a8 3a a3 f9			ld a, (store_tmpid) 
09ab 6f				ld l, a 
09ac 26 00			ld h,0 
09ae				if DEBUG_STORESE 
09ae					DMARK "SCz" 
09ae f5				push af  
09af 3a c3 09			ld a, (.dmark)  
09b2 32 a0 fd			ld (debug_mark),a  
09b5 3a c4 09			ld a, (.dmark+1)  
09b8 32 a1 fd			ld (debug_mark+1),a  
09bb 3a c5 09			ld a, (.dmark+2)  
09be 32 a2 fd			ld (debug_mark+2),a  
09c1 18 03			jr .pastdmark  
09c3 ..			.dmark: db "SCz"  
09c6 f1			.pastdmark: pop af  
09c7			endm  
# End of macro DMARK
09c7					CALLMONITOR 
09c7 cd aa fd			call debug_vector  
09ca				endm  
# End of macro CALLMONITOR
09ca				endif 
09ca c9				ret 
09cb				 
09cb			 
09cb			 
09cb			; 
09cb			; Read File 
09cb			; 
09cb			; h - file id to locate 
09cb			; l - extent to locate 
09cb			; de - pointer to string to read into 
09cb			; 
09cb			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09cb			 
09cb			.sr_fail: 
09cb d1				pop de 
09cc c9				ret 
09cd			 
09cd			storage_read: 
09cd			 
09cd			 
09cd d5				push de 
09ce			 
09ce			; TODO BUG the above push is it popped before the RET Z? 
09ce			 
09ce			; TODO how to handle multiple part blocks 
09ce			 
09ce				; locate file extent to read 
09ce			 
09ce 5c				ld e, h 
09cf 55				ld d, l 
09d0			 
09d0			.srext: 
09d0 22 ad f9			ld (store_readptr), hl     ; save the current extent to load 
09d3 ed 53 ab f9		ld (store_readbuf), de     ; save the current buffer to load in to 
09d7			 
09d7 21 40 00			ld hl, STORE_BLOCK_PHY 
09da				if DEBUG_STORESE 
09da					DMARK "sre" 
09da f5				push af  
09db 3a ef 09			ld a, (.dmark)  
09de 32 a0 fd			ld (debug_mark),a  
09e1 3a f0 09			ld a, (.dmark+1)  
09e4 32 a1 fd			ld (debug_mark+1),a  
09e7 3a f1 09			ld a, (.dmark+2)  
09ea 32 a2 fd			ld (debug_mark+2),a  
09ed 18 03			jr .pastdmark  
09ef ..			.dmark: db "sre"  
09f2 f1			.pastdmark: pop af  
09f3			endm  
# End of macro DMARK
09f3					CALLMONITOR 
09f3 cd aa fd			call debug_vector  
09f6				endm  
# End of macro CALLMONITOR
09f6				endif 
09f6 cd a7 07			call storage_findnextid 
09f9			 
09f9				if DEBUG_STORESE 
09f9					DMARK "srf" 
09f9 f5				push af  
09fa 3a 0e 0a			ld a, (.dmark)  
09fd 32 a0 fd			ld (debug_mark),a  
0a00 3a 0f 0a			ld a, (.dmark+1)  
0a03 32 a1 fd			ld (debug_mark+1),a  
0a06 3a 10 0a			ld a, (.dmark+2)  
0a09 32 a2 fd			ld (debug_mark+2),a  
0a0c 18 03			jr .pastdmark  
0a0e ..			.dmark: db "srf"  
0a11 f1			.pastdmark: pop af  
0a12			endm  
# End of macro DMARK
0a12					CALLMONITOR 
0a12 cd aa fd			call debug_vector  
0a15				endm  
# End of macro CALLMONITOR
0a15				endif 
0a15 cd 07 10			call ishlzero 
0a18			;	ld a, l 
0a18			;	add h 
0a18			;	cp 0 
0a18 28 b1			jr z,.sr_fail			; block not found so EOF 
0a1a			 
0a1a				; save current address for use by higher level words etc 
0a1a			 
0a1a 22 a0 f9			ld (store_openaddr),hl 
0a1d			 
0a1d			 
0a1d				; hl contains page number to load 
0a1d d1				pop de   ; get storage 
0a1e ed 53 ab f9		ld (store_readbuf), de     ; current buffer to load in to 
0a22 d5				push de 
0a23				if DEBUG_STORESE 
0a23					DMARK "srg" 
0a23 f5				push af  
0a24 3a 38 0a			ld a, (.dmark)  
0a27 32 a0 fd			ld (debug_mark),a  
0a2a 3a 39 0a			ld a, (.dmark+1)  
0a2d 32 a1 fd			ld (debug_mark+1),a  
0a30 3a 3a 0a			ld a, (.dmark+2)  
0a33 32 a2 fd			ld (debug_mark+2),a  
0a36 18 03			jr .pastdmark  
0a38 ..			.dmark: db "srg"  
0a3b f1			.pastdmark: pop af  
0a3c			endm  
# End of macro DMARK
0a3c					CALLMONITOR 
0a3c cd aa fd			call debug_vector  
0a3f				endm  
# End of macro CALLMONITOR
0a3f				endif 
0a3f cd 74 04			call storage_read_block 
0a42			 
0a42				; if this a continuation read??? 
0a42			 
0a42 2a ab f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a45			 
0a45 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a47 cd de 0f			call addatohl 
0a4a 7e				ld a,(hl) 
0a4b fe 00			cp 0 
0a4d 28 02			jr z, .markiscont 
0a4f 3e ff			ld a, 255 
0a51			 
0a51			.markiscont: 
0a51 32 a2 f9			ld (store_readcont), a 
0a54			 
0a54				if DEBUG_STORESE 
0a54					DMARK "srC" 
0a54 f5				push af  
0a55 3a 69 0a			ld a, (.dmark)  
0a58 32 a0 fd			ld (debug_mark),a  
0a5b 3a 6a 0a			ld a, (.dmark+1)  
0a5e 32 a1 fd			ld (debug_mark+1),a  
0a61 3a 6b 0a			ld a, (.dmark+2)  
0a64 32 a2 fd			ld (debug_mark+2),a  
0a67 18 03			jr .pastdmark  
0a69 ..			.dmark: db "srC"  
0a6c f1			.pastdmark: pop af  
0a6d			endm  
# End of macro DMARK
0a6d					CALLMONITOR 
0a6d cd aa fd			call debug_vector  
0a70				endm  
# End of macro CALLMONITOR
0a70				endif 
0a70				; only short reads enabled 
0a70			 
0a70 3a aa f9			ld a, (store_longread) 
0a73 fe 00			cp 0 
0a75 ca 42 0b			jp z, .readdone 
0a78			 
0a78			; TODO if block has no zeros then need to read next block  
0a78			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a78			; check last byte of physical block. 
0a78			; if not zero then the next block needs to be loaded 
0a78			 
0a78			 
0a78 2a ab f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a7b			 
0a7b 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a7d cd de 0f			call addatohl 
0a80				;dec hl 
0a80 7e				ld a,(hl) 
0a81				if DEBUG_STORESE 
0a81					DMARK "sr?" 
0a81 f5				push af  
0a82 3a 96 0a			ld a, (.dmark)  
0a85 32 a0 fd			ld (debug_mark),a  
0a88 3a 97 0a			ld a, (.dmark+1)  
0a8b 32 a1 fd			ld (debug_mark+1),a  
0a8e 3a 98 0a			ld a, (.dmark+2)  
0a91 32 a2 fd			ld (debug_mark+2),a  
0a94 18 03			jr .pastdmark  
0a96 ..			.dmark: db "sr?"  
0a99 f1			.pastdmark: pop af  
0a9a			endm  
# End of macro DMARK
0a9a					CALLMONITOR 
0a9a cd aa fd			call debug_vector  
0a9d				endm  
# End of macro CALLMONITOR
0a9d				endif 
0a9d fe 00			cp 0 
0a9f ca 42 0b			jp z, .readdone 
0aa2			 
0aa2				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0aa2			 
0aa2 23				inc hl 
0aa3			 
0aa3 22 ab f9			ld (store_readbuf), hl     ; save the current buffer to load in to 
0aa6			 
0aa6 ed 5b ad f9		ld de, (store_readptr)     ; save the current extent to load 
0aaa			 
0aaa eb				ex de, hl 
0aab			 
0aab				; next ext 
0aab			 
0aab 23				inc hl 
0aac 22 ad f9			ld  (store_readptr), hl     ; save the current extent to load 
0aaf			 
0aaf				if DEBUG_STORESE 
0aaf					DMARK "sF2" 
0aaf f5				push af  
0ab0 3a c4 0a			ld a, (.dmark)  
0ab3 32 a0 fd			ld (debug_mark),a  
0ab6 3a c5 0a			ld a, (.dmark+1)  
0ab9 32 a1 fd			ld (debug_mark+1),a  
0abc 3a c6 0a			ld a, (.dmark+2)  
0abf 32 a2 fd			ld (debug_mark+2),a  
0ac2 18 03			jr .pastdmark  
0ac4 ..			.dmark: db "sF2"  
0ac7 f1			.pastdmark: pop af  
0ac8			endm  
# End of macro DMARK
0ac8					CALLMONITOR 
0ac8 cd aa fd			call debug_vector  
0acb				endm  
# End of macro CALLMONITOR
0acb				endif 
0acb			 
0acb				; get and load block 
0acb			 
0acb cd a7 07			call storage_findnextid 
0ace			 
0ace				if DEBUG_STORESE 
0ace					DMARK "sf2" 
0ace f5				push af  
0acf 3a e3 0a			ld a, (.dmark)  
0ad2 32 a0 fd			ld (debug_mark),a  
0ad5 3a e4 0a			ld a, (.dmark+1)  
0ad8 32 a1 fd			ld (debug_mark+1),a  
0adb 3a e5 0a			ld a, (.dmark+2)  
0ade 32 a2 fd			ld (debug_mark+2),a  
0ae1 18 03			jr .pastdmark  
0ae3 ..			.dmark: db "sf2"  
0ae6 f1			.pastdmark: pop af  
0ae7			endm  
# End of macro DMARK
0ae7					CALLMONITOR 
0ae7 cd aa fd			call debug_vector  
0aea				endm  
# End of macro CALLMONITOR
0aea				endif 
0aea cd 07 10			call ishlzero 
0aed			;	ld a, l 
0aed			;	add h 
0aed			;	cp 0 
0aed ca cb 09			jp z,.sr_fail			; block not found so EOF 
0af0				 
0af0				; save current address for use by higher level words etc 
0af0			 
0af0 22 a0 f9			ld (store_openaddr),hl 
0af3			 
0af3 cd 74 04			call storage_read_block 
0af6			 
0af6				; on a continuation block, we now have the file id and ext in the middle of the block 
0af6				; we need to pull everything back  
0af6			 
0af6 ed 5b ab f9		ld de, (store_readbuf)     ; current buffer to nudge into 
0afa 2a ab f9			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0afd 23				inc hl 
0afe 23				inc hl     ; skip id and ext 
0aff 01 40 00			ld bc, STORE_BLOCK_PHY 
0b02				if DEBUG_STORESE 
0b02					DMARK "SR<" 
0b02 f5				push af  
0b03 3a 17 0b			ld a, (.dmark)  
0b06 32 a0 fd			ld (debug_mark),a  
0b09 3a 18 0b			ld a, (.dmark+1)  
0b0c 32 a1 fd			ld (debug_mark+1),a  
0b0f 3a 19 0b			ld a, (.dmark+2)  
0b12 32 a2 fd			ld (debug_mark+2),a  
0b15 18 03			jr .pastdmark  
0b17 ..			.dmark: db "SR<"  
0b1a f1			.pastdmark: pop af  
0b1b			endm  
# End of macro DMARK
0b1b					CALLMONITOR 
0b1b cd aa fd			call debug_vector  
0b1e				endm  
# End of macro CALLMONITOR
0b1e				endif 
0b1e ed b0			ldir     ; copy data 
0b20			 
0b20				; move the pointer back and pretend we have a full buffer for next recheck 
0b20			 
0b20 1b				dec de 
0b21 1b				dec de 
0b22			 
0b22			; TODO do pop below now short circuit loop????? 
0b22 c1				pop bc     ; get rid of spare de on stack 
0b23				if DEBUG_STORESE 
0b23					DMARK "SR>" 
0b23 f5				push af  
0b24 3a 38 0b			ld a, (.dmark)  
0b27 32 a0 fd			ld (debug_mark),a  
0b2a 3a 39 0b			ld a, (.dmark+1)  
0b2d 32 a1 fd			ld (debug_mark+1),a  
0b30 3a 3a 0b			ld a, (.dmark+2)  
0b33 32 a2 fd			ld (debug_mark+2),a  
0b36 18 03			jr .pastdmark  
0b38 ..			.dmark: db "SR>"  
0b3b f1			.pastdmark: pop af  
0b3c			endm  
# End of macro DMARK
0b3c					CALLMONITOR 
0b3c cd aa fd			call debug_vector  
0b3f				endm  
# End of macro CALLMONITOR
0b3f				endif 
0b3f c3 d0 09			jp .srext 
0b42			 
0b42			 
0b42			 
0b42			 
0b42			 
0b42			.readdone:		 
0b42 e1				pop hl 		 ; return start of data to show as not EOF 
0b43 23				inc hl   ; past file id 
0b44 23				inc hl   ; past ext 
0b45				if DEBUG_STORESE 
0b45					DMARK "SRe" 
0b45 f5				push af  
0b46 3a 5a 0b			ld a, (.dmark)  
0b49 32 a0 fd			ld (debug_mark),a  
0b4c 3a 5b 0b			ld a, (.dmark+1)  
0b4f 32 a1 fd			ld (debug_mark+1),a  
0b52 3a 5c 0b			ld a, (.dmark+2)  
0b55 32 a2 fd			ld (debug_mark+2),a  
0b58 18 03			jr .pastdmark  
0b5a ..			.dmark: db "SRe"  
0b5d f1			.pastdmark: pop af  
0b5e			endm  
# End of macro DMARK
0b5e					CALLMONITOR 
0b5e cd aa fd			call debug_vector  
0b61				endm  
# End of macro CALLMONITOR
0b61				endif 
0b61 c9					ret 
0b62			 
0b62			 
0b62			 
0b62			; 
0b62			; Append File 
0b62			; 
0b62			; hl - file id to locate 
0b62			; de - pointer to (multi block) string to write 
0b62			 
0b62			.sa_notfound: 
0b62 d1				pop de 
0b63 c9				ret 
0b64			 
0b64			 
0b64			storage_append: 
0b64				; hl -  file id to append to 
0b64				; de - string to append 
0b64			 
0b64 d5				push de 
0b65				 
0b65				if DEBUG_STORESE 
0b65					DMARK "AP1" 
0b65 f5				push af  
0b66 3a 7a 0b			ld a, (.dmark)  
0b69 32 a0 fd			ld (debug_mark),a  
0b6c 3a 7b 0b			ld a, (.dmark+1)  
0b6f 32 a1 fd			ld (debug_mark+1),a  
0b72 3a 7c 0b			ld a, (.dmark+2)  
0b75 32 a2 fd			ld (debug_mark+2),a  
0b78 18 03			jr .pastdmark  
0b7a ..			.dmark: db "AP1"  
0b7d f1			.pastdmark: pop af  
0b7e			endm  
# End of macro DMARK
0b7e					CALLMONITOR 
0b7e cd aa fd			call debug_vector  
0b81				endm  
# End of macro CALLMONITOR
0b81				endif 
0b81			 
0b81 7d				ld a, l 
0b82 32 a3 f9			ld (store_tmpid), a 
0b85			 
0b85				; get file header  
0b85			 
0b85 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b87 3a a3 f9			ld a, (store_tmpid) 
0b8a 5f				ld e, a 
0b8b			 
0b8b 21 40 00				ld hl, STORE_BLOCK_PHY 
0b8e cd a7 07				call storage_findnextid 
0b91			 
0b91 cd 07 10			call ishlzero 
0b94 28 cc			jr z, .sa_notfound 
0b96			 
0b96 22 9a f9			ld (store_tmppageid), hl 
0b99			 
0b99				; TODO handle file id not found 
0b99			 
0b99				if DEBUG_STORESE 
0b99					DMARK "AP2" 
0b99 f5				push af  
0b9a 3a ae 0b			ld a, (.dmark)  
0b9d 32 a0 fd			ld (debug_mark),a  
0ba0 3a af 0b			ld a, (.dmark+1)  
0ba3 32 a1 fd			ld (debug_mark+1),a  
0ba6 3a b0 0b			ld a, (.dmark+2)  
0ba9 32 a2 fd			ld (debug_mark+2),a  
0bac 18 03			jr .pastdmark  
0bae ..			.dmark: db "AP2"  
0bb1 f1			.pastdmark: pop af  
0bb2			endm  
# End of macro DMARK
0bb2					CALLMONITOR 
0bb2 cd aa fd			call debug_vector  
0bb5				endm  
# End of macro CALLMONITOR
0bb5				endif 
0bb5			 
0bb5				; update file extent count 
0bb5			 
0bb5 11 af f9			ld de, store_page 
0bb8			 
0bb8 cd 74 04			call storage_read_block 
0bbb			 
0bbb				if DEBUG_STORESE 
0bbb					DMARK "AP3" 
0bbb f5				push af  
0bbc 3a d0 0b			ld a, (.dmark)  
0bbf 32 a0 fd			ld (debug_mark),a  
0bc2 3a d1 0b			ld a, (.dmark+1)  
0bc5 32 a1 fd			ld (debug_mark+1),a  
0bc8 3a d2 0b			ld a, (.dmark+2)  
0bcb 32 a2 fd			ld (debug_mark+2),a  
0bce 18 03			jr .pastdmark  
0bd0 ..			.dmark: db "AP3"  
0bd3 f1			.pastdmark: pop af  
0bd4			endm  
# End of macro DMARK
0bd4					CALLMONITOR 
0bd4 cd aa fd			call debug_vector  
0bd7				endm  
# End of macro CALLMONITOR
0bd7				endif 
0bd7			;	ld (store_tmppageid), hl 
0bd7			 
0bd7 3a b1 f9			ld a, (store_page+2) 
0bda 3c				inc a 
0bdb 32 b1 f9			ld (store_page+2), a 
0bde 32 a2 f9			ld (store_tmpext), a 
0be1				 
0be1				if DEBUG_STORESE 
0be1					DMARK "AP3" 
0be1 f5				push af  
0be2 3a f6 0b			ld a, (.dmark)  
0be5 32 a0 fd			ld (debug_mark),a  
0be8 3a f7 0b			ld a, (.dmark+1)  
0beb 32 a1 fd			ld (debug_mark+1),a  
0bee 3a f8 0b			ld a, (.dmark+2)  
0bf1 32 a2 fd			ld (debug_mark+2),a  
0bf4 18 03			jr .pastdmark  
0bf6 ..			.dmark: db "AP3"  
0bf9 f1			.pastdmark: pop af  
0bfa			endm  
# End of macro DMARK
0bfa					CALLMONITOR 
0bfa cd aa fd			call debug_vector  
0bfd				endm  
# End of macro CALLMONITOR
0bfd				endif 
0bfd 2a 9a f9			ld hl, (store_tmppageid) 
0c00 11 af f9			ld de, store_page 
0c03 cd d9 04			call storage_write_block 
0c06			 
0c06				; find free block 
0c06			 
0c06 11 00 00			ld de, 0			 ; file extent to locate 
0c09			 
0c09 21 40 00				ld hl, STORE_BLOCK_PHY 
0c0c cd a7 07				call storage_findnextid 
0c0f cd 07 10			call ishlzero 
0c12 ca 62 0b			jp z, .sa_notfound 
0c15			 
0c15					; TODO handle no space left 
0c15					 
0c15 22 9a f9				ld (store_tmppageid), hl 
0c18			 
0c18				if DEBUG_STORESE 
0c18					DMARK "AP4" 
0c18 f5				push af  
0c19 3a 2d 0c			ld a, (.dmark)  
0c1c 32 a0 fd			ld (debug_mark),a  
0c1f 3a 2e 0c			ld a, (.dmark+1)  
0c22 32 a1 fd			ld (debug_mark+1),a  
0c25 3a 2f 0c			ld a, (.dmark+2)  
0c28 32 a2 fd			ld (debug_mark+2),a  
0c2b 18 03			jr .pastdmark  
0c2d ..			.dmark: db "AP4"  
0c30 f1			.pastdmark: pop af  
0c31			endm  
# End of macro DMARK
0c31					CALLMONITOR 
0c31 cd aa fd			call debug_vector  
0c34				endm  
# End of macro CALLMONITOR
0c34				endif 
0c34					; init the buffer with zeros so we can id if the buffer is full or not 
0c34			 
0c34 e5					push hl 
0c35 c5					push bc 
0c36			 
0c36 21 af f9				ld hl, store_page 
0c39 06 40				ld b, STORE_BLOCK_PHY 
0c3b 3e 00				ld a, 0 
0c3d 77			.zeroblock:	ld (hl), a 
0c3e 23					inc hl 
0c3f 10 fc				djnz .zeroblock 
0c41			 
0c41 c1					pop bc 
0c42 e1					pop hl 
0c43			 
0c43					; construct block 
0c43			 
0c43 3a a3 f9				ld a, (store_tmpid) 
0c46 32 af f9				ld (store_page), a   ; file id 
0c49 3a a2 f9				ld a, (store_tmpext)   ; extent for this block 
0c4c 32 b0 f9				ld (store_page+1), a 
0c4f			 
0c4f e1					pop hl    ; get string to write 
0c50 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c52 11 b1 f9				ld de, store_page+2 
0c55			 
0c55				if DEBUG_STORESE 
0c55					DMARK "AP5" 
0c55 f5				push af  
0c56 3a 6a 0c			ld a, (.dmark)  
0c59 32 a0 fd			ld (debug_mark),a  
0c5c 3a 6b 0c			ld a, (.dmark+1)  
0c5f 32 a1 fd			ld (debug_mark+1),a  
0c62 3a 6c 0c			ld a, (.dmark+2)  
0c65 32 a2 fd			ld (debug_mark+2),a  
0c68 18 03			jr .pastdmark  
0c6a ..			.dmark: db "AP5"  
0c6d f1			.pastdmark: pop af  
0c6e			endm  
# End of macro DMARK
0c6e					CALLMONITOR 
0c6e cd aa fd			call debug_vector  
0c71				endm  
# End of macro CALLMONITOR
0c71				endif 
0c71			 
0c71			 
0c71			 
0c71					; fill buffer with data until end of string or full block 
0c71			 
0c71 7e			.appd:		ld a, (hl) 
0c72 12					ld (de), a 
0c73 fe 00				cp 0 
0c75 28 04				jr z, .appdone 
0c77 23					inc hl 
0c78 13					inc de 
0c79 10 f6				djnz .appd 
0c7b			 
0c7b e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c7c f5					push af   		; save last byte dumped 
0c7d			 
0c7d			 
0c7d 2a 9a f9			ld hl, (store_tmppageid) 
0c80 11 af f9			ld de, store_page 
0c83				if DEBUG_STORESE 
0c83					DMARK "AP6" 
0c83 f5				push af  
0c84 3a 98 0c			ld a, (.dmark)  
0c87 32 a0 fd			ld (debug_mark),a  
0c8a 3a 99 0c			ld a, (.dmark+1)  
0c8d 32 a1 fd			ld (debug_mark+1),a  
0c90 3a 9a 0c			ld a, (.dmark+2)  
0c93 32 a2 fd			ld (debug_mark+2),a  
0c96 18 03			jr .pastdmark  
0c98 ..			.dmark: db "AP6"  
0c9b f1			.pastdmark: pop af  
0c9c			endm  
# End of macro DMARK
0c9c					CALLMONITOR 
0c9c cd aa fd			call debug_vector  
0c9f				endm  
# End of macro CALLMONITOR
0c9f				endif 
0c9f cd d9 04				call storage_write_block 
0ca2			 
0ca2			 
0ca2				; was that a full block of data written? 
0ca2				; any more to write out? 
0ca2			 
0ca2				; if yes then set vars and jump to start of function again 
0ca2			 
0ca2 f1					pop af 
0ca3 d1					pop de 
0ca4			 
0ca4 fe 00				cp 0		 ; no, string was fully written 
0ca6 c8					ret z 
0ca7			 
0ca7					; setup vars for next cycle 
0ca7			 
0ca7 3a a3 f9				ld a, (store_tmpid) 
0caa 6f					ld l, a 
0cab 26 00				ld h, 0 
0cad			 
0cad c3 64 0b			 	jp storage_append	 ; yes, need to write out some more 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			 
0cb0			if DEBUG_STORECF 
0cb0			storageput:	 
0cb0					ret 
0cb0			storageread: 
0cb0					ld hl, store_page 
0cb0					ld b, 200 
0cb0					ld a,0 
0cb0			.src:		ld (hl),a 
0cb0					inc hl 
0cb0					djnz .src 
0cb0					 
0cb0			 
0cb0					ld de, 0 
0cb0					ld bc, 1 
0cb0					ld hl, store_page 
0cb0					call cfRead 
0cb0			 
0cb0				call cfGetError 
0cb0				ld hl,scratch 
0cb0				call hexout 
0cb0				ld hl, scratch+2 
0cb0				ld a, 0 
0cb0				ld (hl),a 
0cb0				ld de, scratch 
0cb0				ld a,display_row_1 
0cb0				call str_at_display 
0cb0				call update_display 
0cb0			 
0cb0					ld hl, store_page 
0cb0					ld (os_cur_ptr),hl 
0cb0			 
0cb0					ret 
0cb0			endif 
0cb0			 
0cb0			 
0cb0			; Clear out the main buffer store (used to remove junk before writing a new block) 
0cb0			 
0cb0			storage_clear_page: 
0cb0 e5				push hl 
0cb1 d5				push de 
0cb2 c5				push bc 
0cb3 21 af f9			ld hl, store_page 
0cb6 3e 00			ld a, 0 
0cb8 77				ld (hl), a 
0cb9			 
0cb9 11 b0 f9			ld de, store_page+1 
0cbc 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0cbf			 
0cbf ed b0			ldir 
0cc1				 
0cc1 c1				pop bc 
0cc2 d1				pop de 
0cc3 e1				pop hl 
0cc4 c9				ret 
0cc5			 
0cc5			; eof 
# End of file firmware_storage.asm
0cc5			  
0cc5			; support routines for above hardware abstraction layer  
0cc5			  
0cc5			include "firmware_general.asm"        ; general support functions  
0cc5			 
0cc5			; word look up 
0cc5			 
0cc5			; in 
0cc5			; a is the index 
0cc5			; hl is pointer start of array 
0cc5			; 
0cc5			; returns 
0cc5			; hl to the word 
0cc5			; 
0cc5			 
0cc5			table_lookup:  
0cc5 d5					push de 
0cc6 eb					ex de, hl 
0cc7			 
0cc7 6f					ld l, a 
0cc8 26 00				ld h, 0 
0cca 29					add hl, hl 
0ccb 19					add hl, de 
0ccc 7e					ld a, (hl) 
0ccd 23					inc hl 
0cce 66					ld h,(hl) 
0ccf 6f					ld l, a 
0cd0			 
0cd0 d1					pop de 
0cd1 c9					ret 
0cd2			 
0cd2			; Delay loops 
0cd2			 
0cd2			 
0cd2			 
0cd2			aDelayInMS: 
0cd2 c5				push bc 
0cd3 47				ld b,a 
0cd4			msdelay: 
0cd4 c5				push bc 
0cd5				 
0cd5			 
0cd5 01 41 00			ld bc,041h 
0cd8 cd f0 0c			call delayloop 
0cdb c1				pop bc 
0cdc 05				dec b 
0cdd 20 f5			jr nz,msdelay 
0cdf			 
0cdf			;if CPU_CLOCK_8MHZ 
0cdf			;msdelay8: 
0cdf			;	push bc 
0cdf			;	 
0cdf			; 
0cdf			;	ld bc,041h 
0cdf			;	call delayloop 
0cdf			;	pop bc 
0cdf			;	dec b 
0cdf			;	jr nz,msdelay8 
0cdf			;endif 
0cdf			 
0cdf			 
0cdf c1				pop bc 
0ce0 c9				ret 
0ce1			 
0ce1			 
0ce1			delay250ms: 
0ce1				;push de 
0ce1 01 00 40			ld bc, 04000h 
0ce4 c3 f0 0c			jp delayloop 
0ce7			delay500ms: 
0ce7				;push de 
0ce7 01 00 80			ld bc, 08000h 
0cea c3 f0 0c			jp delayloop 
0ced			delay1s: 
0ced				;push bc 
0ced			   ; Clobbers A, d and e 
0ced 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0cf0			delayloop: 
0cf0 c5			    push bc 
0cf1			 
0cf1			if BASE_CPM 
0cf1				ld bc, CPM_DELAY_TUNE 
0cf1			.cpmloop: 
0cf1				push bc 
0cf1			 
0cf1			endif 
0cf1			 
0cf1			 
0cf1			 
0cf1			delayloopi: 
0cf1			;	push bc 
0cf1			;.dl: 
0cf1 cb 47		    bit     0,a    	; 8 
0cf3 cb 47		    bit     0,a    	; 8 
0cf5 cb 47		    bit     0,a    	; 8 
0cf7 e6 ff		    and     255  	; 7 
0cf9 0b			    dec     bc      	; 6 
0cfa 79			    ld      a,c     	; 4 
0cfb b0			    or      b     	; 4 
0cfc c2 f1 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cff			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cff				;pop de 
0cff			;pop bc 
0cff			 
0cff			if BASE_CPM 
0cff				pop bc 
0cff				 
0cff			    dec     bc      	; 6 
0cff			    ld      a,c     	; 4 
0cff			    or      b     	; 4 
0cff			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cff				 
0cff			 
0cff			endif 
0cff			;if CPU_CLOCK_8MHZ 
0cff			;    pop bc 
0cff			;    push bc 
0cff			;.dl8: 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    and     255  	; 7 
0cff			;    dec     bc      	; 6 
0cff			;    ld      a,c     	; 4 
0cff			;    or      b     	; 4 
0cff			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cff			;endif 
0cff			 
0cff			;if CPU_CLOCK_10MHZ 
0cff			;    pop bc 
0cff			;    push bc 
0cff			;.dl8: 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    bit     0,a    	; 8 
0cff			;    and     255  	; 7 
0cff			;    dec     bc      	; 6 
0cff			;    ld      a,c     	; 4 
0cff			;    or      b     	; 4 
0cff			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cff			;endif 
0cff c1			    pop bc 
0d00			 
0d00 c9				ret 
0d01			 
0d01			 
0d01			 
0d01			; eof 
# End of file firmware_general.asm
0d01			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0d01			; display routines that use the physical hardware abstraction layer 
0d01			 
0d01			 
0d01			; Display an activity indicator 
0d01			; Each call returns the new char pointed to in hl 
0d01			 
0d01			active: 
0d01 3a fb fa			ld a, (display_active) 
0d04 fe 06			cp 6 
0d06			 
0d06 20 02			jr nz, .sne 
0d08				; gone past the last one reset sequence 
0d08 3e ff			ld a, 255 
0d0a			 
0d0a			.sne:   
0d0a				; get the next char in seq 
0d0a 3c				inc a 
0d0b 32 fb fa			ld (display_active), a 
0d0e			 
0d0e				; look up the string in the table 
0d0e 21 25 0d			ld hl, actseq 
0d11 cb 27			sla a 
0d13 cd de 0f			call addatohl 
0d16 cd bb 23			call loadwordinhl 
0d19			 
0d19				; forth will write the to string when pushing so move from rom to ram 
0d19			 
0d19 11 fc fa			ld de, display_active+1 
0d1c 01 02 00			ld bc, 2 
0d1f ed b0			ldir 
0d21			 
0d21 21 fc fa			ld hl, display_active+1 
0d24 c9				ret 
0d25				 
0d25				 
0d25			 
0d25			 
0d25			;db "|/-\|-\" 
0d25			 
0d25			actseq: 
0d25			 
0d25 33 0d		dw spin0 
0d27 35 0d		dw spin1 
0d29 37 0d		dw spin2 
0d2b 39 0d		dw spin3 
0d2d 37 0d		dw spin2 
0d2f 35 0d		dw spin1 
0d31 33 0d		dw spin0 
0d33			 
0d33 .. 00		spin0: db " ", 0 
0d35 .. 00		spin1: db "-", 0 
0d37 .. 00		spin2: db "+", 0 
0d39 .. 00		spin3: db "#", 0 
0d3b			 
0d3b			 
0d3b			; information window 
0d3b			 
0d3b			; pass hl with 1st string to display 
0d3b			; pass de with 2nd string to display 
0d3b			 
0d3b			info_panel: 
0d3b e5				push hl 
0d3c			 
0d3c 2a 01 fb			ld hl, (display_fb_active) 
0d3f e5				push hl    ; future de destination 
0d40 21 e6 fc				ld hl, display_fb0 
0d43 22 01 fb				ld (display_fb_active), hl 
0d46			 
0d46			;	call clear_display 
0d46			 
0d46				if BASE_CPM 
0d46				ld a, '.' 
0d46				else 
0d46 3e a5			ld a, 165 
0d48				endif 
0d48 cd af 0d			call fill_display 
0d4b			 
0d4b			 
0d4b 3e 55			ld a, display_row_3 + 5 
0d4d cd bd 0d			call str_at_display 
0d50			 
0d50 e1				pop hl 
0d51 d1				pop de 
0d52			 
0d52 e5				push hl 
0d53			 
0d53			 
0d53 3e 2d			ld a, display_row_2 + 5 
0d55 cd bd 0d			call str_at_display 
0d58			 
0d58			 
0d58 cd cd 0d			call update_display 
0d5b cd c0 1f			call next_page_prompt 
0d5e cd aa 0d			call clear_display 
0d61			 
0d61				 
0d61 21 45 fc				ld hl, display_fb1 
0d64 22 01 fb				ld (display_fb_active), hl 
0d67 cd cd 0d			call update_display 
0d6a			 
0d6a e1				pop hl 
0d6b			 
0d6b c9				ret 
0d6c			 
0d6c			 
0d6c			 
0d6c			 
0d6c			; TODO windowing? 
0d6c			 
0d6c			; TODO scroll line up 
0d6c			 
0d6c			scroll_up: 
0d6c			 
0d6c e5				push hl 
0d6d d5				push de 
0d6e c5				push bc 
0d6f			 
0d6f				; get frame buffer  
0d6f			 
0d6f 2a 01 fb			ld hl, (display_fb_active) 
0d72 e5				push hl    ; future de destination 
0d73			 
0d73 11 28 00			ld  de, display_cols 
0d76 19				add hl, de 
0d77			 
0d77 d1				pop de 
0d78			 
0d78				;ex de, hl 
0d78 01 9f 00			ld bc, display_fb_len -1  
0d7b			;if DEBUG_FORTH_WORDS 
0d7b			;	DMARK "SCL" 
0d7b			;	CALLMONITOR 
0d7b			;endif	 
0d7b ed b0			ldir 
0d7d			 
0d7d				; wipe bottom row 
0d7d			 
0d7d			 
0d7d 2a 01 fb			ld hl, (display_fb_active) 
0d80 11 a0 00			ld de, display_cols*display_rows 
0d83 19				add hl, de 
0d84 06 28			ld b, display_cols 
0d86 3e 20			ld a, ' ' 
0d88			.scwipe: 
0d88 77				ld (hl), a 
0d89 2b				dec hl 
0d8a 10 fc			djnz .scwipe 
0d8c			 
0d8c				;pop hl 
0d8c			 
0d8c c1				pop bc 
0d8d d1				pop de 
0d8e e1				pop hl 
0d8f			 
0d8f c9				ret 
0d90			 
0d90			 
0d90			;scroll_upo: 
0d90			;	ld de, display_row_1 
0d90			 ;	ld hl, display_row_2 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			;	ld de, display_row_2 
0d90			 ;	ld hl, display_row_3 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			;	ld de, display_row_3 
0d90			 ;	ld hl, display_row_4 
0d90			;	ld bc, display_cols 
0d90			;	ldir 
0d90			 
0d90			; TODO clear row 4 
0d90			 
0d90			;	ret 
0d90			 
0d90				 
0d90			scroll_down: 
0d90			 
0d90 e5				push hl 
0d91 d5				push de 
0d92 c5				push bc 
0d93			 
0d93				; get frame buffer  
0d93			 
0d93 2a 01 fb			ld hl, (display_fb_active) 
0d96			 
0d96 11 9f 00			ld de, display_fb_len - 1 
0d99 19				add hl, de 
0d9a			 
0d9a e5			push hl    ; future de destination 
0d9b			 
0d9b 11 28 00			ld  de, display_cols 
0d9e ed 52			sbc hl, de 
0da0			 
0da0			 
0da0 d1				pop de 
0da1			 
0da1			;	ex de, hl 
0da1 01 9f 00			ld bc, display_fb_len -1  
0da4			 
0da4			 
0da4				 
0da4			 
0da4 ed b0			ldir 
0da6			 
0da6				; wipe bottom row 
0da6			 
0da6			 
0da6			;	ld hl, (display_fb_active) 
0da6			;;	ld de, display_cols*display_rows 
0da6			;;	add hl, de 
0da6			;	ld b, display_cols 
0da6			;	ld a, ' ' 
0da6			;.scwiped: 
0da6			;	ld (hl), a 
0da6			;	dec hl 
0da6			;	djnz .scwiped 
0da6			 
0da6				;pop hl 
0da6			 
0da6 c1				pop bc 
0da7 d1				pop de 
0da8 e1				pop hl 
0da9			 
0da9 c9				ret 
0daa			;scroll_down: 
0daa			;	ld de, display_row_4 
0daa			;	ld hl, display_row_3 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;	ld de, display_row_3 
0daa			; 	ld hl, display_row_2 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;	ld de, display_row_2 
0daa			;	ld hl, display_row_1 
0daa			;	ld bc, display_cols 
0daa			;	ldir 
0daa			;;; TODO clear row 1 
0daa			;	ret 
0daa			 
0daa			 
0daa			 
0daa			 
0daa			 
0daa			; clear active frame buffer 
0daa			 
0daa			clear_display: 
0daa 3e 20			ld a, ' ' 
0dac c3 af 0d			jp fill_display 
0daf			 
0daf			; fill active frame buffer with a char in A 
0daf			 
0daf			fill_display: 
0daf 06 a0			ld b,display_fb_len 
0db1 2a 01 fb			ld hl, (display_fb_active) 
0db4 77			.fd1:	ld (hl),a 
0db5 23				inc hl 
0db6 10 fc			djnz .fd1 
0db8 23				inc hl 
0db9 3e 00			ld a,0 
0dbb 77				ld (hl),a 
0dbc			 
0dbc			 
0dbc c9				ret 
0dbd			; Write string (DE) at pos (A) to active frame buffer 
0dbd			 
0dbd 2a 01 fb		str_at_display:    ld hl,(display_fb_active) 
0dc0 06 00					ld b,0 
0dc2 4f					ld c,a 
0dc3 09					add hl,bc 
0dc4 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0dc5 b7			            OR   A              ;Null terminator? 
0dc6 c8			            RET  Z              ;Yes, so finished 
0dc7 77					ld (hl),a 
0dc8 23				inc hl 
0dc9 13			            INC  DE             ;Point to next character 
0dca 18 f8		            JR   .sad1     ;Repeat 
0dcc c9					ret 
0dcd			 
0dcd			; using current frame buffer write to physical display 
0dcd			 
0dcd			update_display: 
0dcd e5				push hl 
0dce 2a 01 fb			ld hl, (display_fb_active) 
0dd1 cd 48 71			call write_display 
0dd4 e1				pop hl 
0dd5 c9				ret 
0dd6			 
0dd6			; TODO scrolling 
0dd6			 
0dd6			 
0dd6			; move cursor right one char 
0dd6			cursor_right: 
0dd6			 
0dd6				; TODO shift right 
0dd6				; TODO if beyond max col 
0dd6				; TODO       cursor_next_line 
0dd6			 
0dd6 c9				ret 
0dd7			 
0dd7			 
0dd7			cursor_next_line: 
0dd7				; TODO first char 
0dd7				; TODO line down 
0dd7				; TODO if past last row 
0dd7				; TODO    scroll up 
0dd7			 
0dd7 c9				ret 
0dd8			 
0dd8			cursor_left: 
0dd8				; TODO shift left 
0dd8				; TODO if beyond left  
0dd8				; TODO     cursor prev line 
0dd8				 
0dd8 c9				ret 
0dd9			 
0dd9			cursor_prev_line: 
0dd9				; TODO last char 
0dd9				; TODO line up 
0dd9				; TODO if past first row 
0dd9				; TODO   scroll down 
0dd9			 
0dd9 c9				ret 
0dda			 
0dda			 
0dda			cout: 
0dda				; A - char 
0dda c9				ret 
0ddb			 
0ddb			 
0ddb			; Display a menu and allow item selection (optional toggle items) 
0ddb			; 
0ddb			; format: 
0ddb			; hl pointer to word array with zero term for items 
0ddb			; e.g.    db item1 
0ddb			;         db .... 
0ddb			;         db 0 
0ddb			; 
0ddb			; a = starting menu item  
0ddb			; 
0ddb			; de = pointer item toggle array   (todo) 
0ddb			; 
0ddb			; returns item selected in a 1-... 
0ddb			; returns 0 if back button pressed 
0ddb			; 
0ddb			; NOTE: Uses system frame buffer to display 
0ddb			; 
0ddb			; LEFT, Q = go back 
0ddb			; RIGHT, SPACE, CR = select 
0ddb			; UP, A - Up 
0ddb			; DOWN, Z - Down 
0ddb			 
0ddb			 
0ddb			 
0ddb			 
0ddb			 
0ddb			menu: 
0ddb			 
0ddb					; keep array pointer 
0ddb			 
0ddb 22 a8 f9				ld (store_tmp1), hl 
0dde 32 a6 f9				ld (store_tmp2), a 
0de1			 
0de1					; check for key bounce 
0de1			 
0de1			if BASE_KEV 
0de1			 
0de1 cd 93 74		.mbounce:	call cin 
0de4 fe 00				cp 0 
0de6 20 f9				jr nz, .mbounce 
0de8			endif 
0de8					; for ease use ex 
0de8			 
0de8					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0de8 21 e6 fc				ld hl, display_fb0 
0deb 22 01 fb				ld (display_fb_active), hl 
0dee			 
0dee cd aa 0d		.mloop:		call clear_display 
0df1 cd cd 0d				call update_display 
0df4			 
0df4					; draw selection id '>' at 1 
0df4			 
0df4					; init start of list display 
0df4			 
0df4 3e 05				ld a, 5 
0df6 32 a4 f9				ld (store_tmp3), a   ; display row count 
0df9 3a a6 f9				ld a,( store_tmp2) 
0dfc 32 a7 f9				ld (store_tmp2+1), a   ; display item count 
0dff			 
0dff					 
0dff			.mitem:	 
0dff			 
0dff			 
0dff 3a a7 f9				ld a,(store_tmp2+1) 
0e02 6f					ld l, a 
0e03 26 00				ld h, 0 
0e05 29					add hl, hl 
0e06 ed 5b a8 f9			ld de, (store_tmp1) 
0e0a 19					add hl, de 
0e0b 7e					ld a, (hl) 
0e0c 23					inc hl 
0e0d 66					ld h,(hl) 
0e0e 6f					ld l, a 
0e0f			 
0e0f cd 07 10				call ishlzero 
0e12 28 1a				jr z, .mdone 
0e14			 
0e14 eb					ex de, hl 
0e15 3a a4 f9				ld a, (store_tmp3) 
0e18 cd bd 0d				call str_at_display 
0e1b					 
0e1b			 
0e1b					; next item 
0e1b 3a a7 f9				ld a, (store_tmp2+1) 
0e1e 3c					inc a 
0e1f 32 a7 f9				ld (store_tmp2+1), a   ; display item count 
0e22			 
0e22			 		; next row 
0e22			 
0e22 3a a4 f9				ld a, (store_tmp3) 
0e25 c6 28				add display_cols 
0e27 32 a4 f9				ld (store_tmp3), a 
0e2a			 
0e2a					; at end of screen? 
0e2a			 
0e2a fe 10				cp display_rows*4 
0e2c 20 d1				jr nz, .mitem 
0e2e			 
0e2e			 
0e2e			.mdone: 
0e2e cd 07 10				call ishlzero 
0e31 28 08				jr z, .nodn 
0e33			 
0e33 3e 78				ld a, display_row_4 
0e35 11 b4 0e				ld de, .mdown 
0e38 cd bd 0d				call str_at_display 
0e3b			 
0e3b					; draw options to fill the screens with active item on line 1 
0e3b					; if current option is 2 or more then display ^ in top 
0e3b			 
0e3b 3a a6 f9		.nodn:		ld a, (store_tmp2) 
0e3e fe 00				cp 0 
0e40 28 08				jr z, .noup 
0e42			 
0e42 3e 00				ld a, 0 
0e44 11 b2 0e				ld de, .mup 
0e47 cd bd 0d				call str_at_display 
0e4a			 
0e4a 3e 02		.noup:		ld a, 2 
0e4c 11 b0 0e				ld de, .msel 
0e4f cd bd 0d				call str_at_display 
0e52			 
0e52					; if current option + 1 is not null then display V in bottom 
0e52					; get key 
0e52 cd cd 0d				call update_display 
0e55			 
0e55			 
0e55					; handle key 
0e55			 
0e55 cd 82 74				call cin_wait 
0e58			 
0e58 fe 05				cp KEY_UP 
0e5a 28 2b				jr z, .mgoup 
0e5c fe 61				cp 'a' 
0e5e 28 27				jr z, .mgoup 
0e60 fe 0a				cp KEY_DOWN 
0e62 28 32				jr z, .mgod 
0e64 fe 7a				cp 'z' 
0e66 28 2e				jr z, .mgod 
0e68 fe 20				cp ' ' 
0e6a 28 34				jr z, .goend 
0e6c fe 0c				cp KEY_RIGHT 
0e6e 28 30				jr z, .goend 
0e70 fe 0d				cp KEY_CR 
0e72 28 2c				jr z, .goend 
0e74 fe 71				cp 'q' 
0e76 28 0b				jr z, .goback 
0e78			 
0e78 fe 0b				cp KEY_LEFT 
0e7a 28 07				jr z, .goback 
0e7c fe 08				cp KEY_BS 
0e7e 28 03				jr z, .goback 
0e80 c3 ee 0d				jp .mloop 
0e83			 
0e83			.goback: 
0e83 3e 00			ld a, 0 
0e85 18 1d			jr .goend2 
0e87			 
0e87				; move up one 
0e87			.mgoup: 
0e87 3a a6 f9				ld a, (store_tmp2) 
0e8a fe 00				cp 0 
0e8c ca ee 0d				jp z, .mloop 
0e8f 3d					dec a 
0e90 32 a6 f9				ld (store_tmp2), a 
0e93 c3 ee 0d				jp .mloop 
0e96			 
0e96				; move down one 
0e96			.mgod: 
0e96 3a a6 f9				ld a, (store_tmp2) 
0e99 3c					inc a 
0e9a 32 a6 f9				ld (store_tmp2), a 
0e9d c3 ee 0d				jp .mloop 
0ea0			 
0ea0			 
0ea0			.goend: 
0ea0					; get selected item number 
0ea0			 
0ea0 3a a6 f9				ld a, (store_tmp2) 
0ea3 3c					inc a 
0ea4			 
0ea4			.goend2: 
0ea4 f5					push af 
0ea5			 
0ea5					; restore active fb 
0ea5					; TODO BUG assumes fb1 
0ea5			 
0ea5 21 45 fc				ld hl, display_fb1 
0ea8 22 01 fb				ld (display_fb_active), hl 
0eab			 
0eab					; restore main regs 
0eab			 
0eab			 
0eab cd cd 0d				call update_display 
0eae			 
0eae f1					pop af 
0eaf			 
0eaf c9				ret 
0eb0			 
0eb0 .. 00		.msel:   db ">",0 
0eb2 .. 00		.mup:   db "^",0 
0eb4 .. 00		.mdown:   db "v",0 
0eb6			 
0eb6			 
0eb6			; eof 
0eb6			 
# End of file firmware_display.asm
0eb6			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0eb6			; random number generators 
0eb6			 
0eb6			 
0eb6			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0eb6			 
0eb6			 
0eb6			;-----> Generate a random number 
0eb6			; output a=answer 0<=a<=255 
0eb6			; all registers are preserved except: af 
0eb6			random: 
0eb6 e5			        push    hl 
0eb7 d5			        push    de 
0eb8 2a e0 fa		        ld      hl,(randData) 
0ebb ed 5f		        ld      a,r 
0ebd 57			        ld      d,a 
0ebe 5e			        ld      e,(hl) 
0ebf 19			        add     hl,de 
0ec0 85			        add     a,l 
0ec1 ac			        xor     h 
0ec2 22 e0 fa		        ld      (randData),hl 
0ec5 d1			        pop     de 
0ec6 e1			        pop     hl 
0ec7 c9			        ret 
0ec8			 
0ec8			 
0ec8			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0ec8			 
0ec8			 
0ec8			 
0ec8			;------LFSR------ 
0ec8			;James Montelongo 
0ec8			;optimized by Spencer Putt 
0ec8			;out: 
0ec8			; a = 8 bit random number 
0ec8			RandLFSR: 
0ec8 21 e6 fa		        ld hl,LFSRSeed+4 
0ecb 5e			        ld e,(hl) 
0ecc 23			        inc hl 
0ecd 56			        ld d,(hl) 
0ece 23			        inc hl 
0ecf 4e			        ld c,(hl) 
0ed0 23			        inc hl 
0ed1 7e			        ld a,(hl) 
0ed2 47			        ld b,a 
0ed3 cb 13		        rl e  
0ed5 cb 12			rl d 
0ed7 cb 11		        rl c  
0ed9 17				rla 
0eda cb 13		        rl e  
0edc cb 12			rl d 
0ede cb 11		        rl c  
0ee0 17				rla 
0ee1 cb 13		        rl e  
0ee3 cb 12			rl d 
0ee5 cb 11		        rl c  
0ee7 17				rla 
0ee8 67			        ld h,a 
0ee9 cb 13		        rl e  
0eeb cb 12			rl d 
0eed cb 11		        rl c  
0eef 17				rla 
0ef0 a8			        xor b 
0ef1 cb 13		        rl e  
0ef3 cb 12			rl d 
0ef5 ac			        xor h 
0ef6 a9			        xor c 
0ef7 aa			        xor d 
0ef8 21 e8 fa		        ld hl,LFSRSeed+6 
0efb 11 e9 fa		        ld de,LFSRSeed+7 
0efe 01 07 00		        ld bc,7 
0f01 ed b8		        lddr 
0f03 12			        ld (de),a 
0f04 c9			        ret 
0f05			 
0f05			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0f05			 
0f05			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0f05			 
0f05			 
0f05			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0f05			 
0f05			prng16: 
0f05			;Inputs: 
0f05			;   (seed1) contains a 16-bit seed value 
0f05			;   (seed2) contains a NON-ZERO 16-bit seed value 
0f05			;Outputs: 
0f05			;   HL is the result 
0f05			;   BC is the result of the LCG, so not that great of quality 
0f05			;   DE is preserved 
0f05			;Destroys: 
0f05			;   AF 
0f05			;cycle: 4,294,901,760 (almost 4.3 billion) 
0f05			;160cc 
0f05			;26 bytes 
0f05 2a da fa		    ld hl,(seed1) 
0f08 44			    ld b,h 
0f09 4d			    ld c,l 
0f0a 29			    add hl,hl 
0f0b 29			    add hl,hl 
0f0c 2c			    inc l 
0f0d 09			    add hl,bc 
0f0e 22 da fa		    ld (seed1),hl 
0f11 2a d8 fa		    ld hl,(seed2) 
0f14 29			    add hl,hl 
0f15 9f			    sbc a,a 
0f16 e6 2d		    and %00101101 
0f18 ad			    xor l 
0f19 6f			    ld l,a 
0f1a 22 d8 fa		    ld (seed2),hl 
0f1d 09			    add hl,bc 
0f1e c9			    ret 
0f1f			 
0f1f			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0f1f			 
0f1f			rand32: 
0f1f			;Inputs: 
0f1f			;   (seed1_0) holds the lower 16 bits of the first seed 
0f1f			;   (seed1_1) holds the upper 16 bits of the first seed 
0f1f			;   (seed2_0) holds the lower 16 bits of the second seed 
0f1f			;   (seed2_1) holds the upper 16 bits of the second seed 
0f1f			;   **NOTE: seed2 must be non-zero 
0f1f			;Outputs: 
0f1f			;   HL is the result 
0f1f			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0f1f			;Destroys: 
0f1f			;   AF 
0f1f			;Tested and passes all CAcert tests 
0f1f			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0f1f			;it has a period of 18,446,744,069,414,584,320 
0f1f			;roughly 18.4 quintillion. 
0f1f			;LFSR taps: 0,2,6,7  = 11000101 
0f1f			;291cc 
0f1f			;seed1_0=$+1 
0f1f			;    ld hl,12345 
0f1f			;seed1_1=$+1 
0f1f			;    ld de,6789 
0f1f			;    ld b,h 
0f1f			;    ld c,l 
0f1f			;    add hl,hl \ rl e \ rl d 
0f1f			;    add hl,hl \ rl e \ rl d 
0f1f			;    inc l 
0f1f			;    add hl,bc 
0f1f			;    ld (seed1_0),hl 
0f1f			;    ld hl,(seed1_1) 
0f1f			;    adc hl,de 
0f1f			;    ld (seed1_1),hl 
0f1f			;    ex de,hl 
0f1f			;seed2_0=$+1 
0f1f			;    ld hl,9876 
0f1f			;seed2_1=$+1 
0f1f			;    ld bc,54321 
0f1f			;    add hl,hl \ rl c \ rl b 
0f1f			;    ld (seed2_1),bc 
0f1f			;    sbc a,a 
0f1f			;    and %11000101 
0f1f			;    xor l 
0f1f			;    ld l,a 
0f1f			;    ld (seed2_0),hl 
0f1f			;    ex de,hl 
0f1f			;    add hl,bc 
0f1f			;    ret 
0f1f			; 
0f1f			 
0f1f			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0f1f			; 20 bytes, 86 cycles (excluding ret) 
0f1f			 
0f1f			; returns   hl = pseudorandom number 
0f1f			; corrupts   a 
0f1f			 
0f1f			; generates 16-bit pseudorandom numbers with a period of 65535 
0f1f			; using the xorshift method: 
0f1f			 
0f1f			; hl ^= hl << 7 
0f1f			; hl ^= hl >> 9 
0f1f			; hl ^= hl << 8 
0f1f			 
0f1f			; some alternative shift triplets which also perform well are: 
0f1f			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0f1f			 
0f1f			;  org 32768 
0f1f			 
0f1f			xrnd: 
0f1f 2a de fa		  ld hl,(xrandc)       ; seed must not be 0 
0f22 3e 00		  ld a,0 
0f24 bd			  cp l 
0f25 20 02		  jr nz, .xrnd1 
0f27 2e 01		  ld l, 1 
0f29			.xrnd1: 
0f29			 
0f29 7c			  ld a,h 
0f2a 1f			  rra 
0f2b 7d			  ld a,l 
0f2c 1f			  rra 
0f2d ac			  xor h 
0f2e 67			  ld h,a 
0f2f 7d			  ld a,l 
0f30 1f			  rra 
0f31 7c			  ld a,h 
0f32 1f			  rra 
0f33 ad			  xor l 
0f34 6f			  ld l,a 
0f35 ac			  xor h 
0f36 67			  ld h,a 
0f37			 
0f37 22 de fa		  ld (xrandc),hl 
0f3a			 
0f3a c9			  ret 
0f3b			;  
0f3b			 
0f3b			 
0f3b			;;;; int maths 
0f3b			 
0f3b			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f3b			; Divide 16-bit values (with 16-bit result) 
0f3b			; In: Divide BC by divider DE 
0f3b			; Out: BC = result, HL = rest 
0f3b			; 
0f3b			Div16: 
0f3b 21 00 00		    ld hl,0 
0f3e 78			    ld a,b 
0f3f 06 08		    ld b,8 
0f41			Div16_Loop1: 
0f41 17			    rla 
0f42 ed 6a		    adc hl,hl 
0f44 ed 52		    sbc hl,de 
0f46 30 01		    jr nc,Div16_NoAdd1 
0f48 19			    add hl,de 
0f49			Div16_NoAdd1: 
0f49 10 f6		    djnz Div16_Loop1 
0f4b 17			    rla 
0f4c 2f			    cpl 
0f4d 47			    ld b,a 
0f4e 79			    ld a,c 
0f4f 48			    ld c,b 
0f50 06 08		    ld b,8 
0f52			Div16_Loop2: 
0f52 17			    rla 
0f53 ed 6a		    adc hl,hl 
0f55 ed 52		    sbc hl,de 
0f57 30 01		    jr nc,Div16_NoAdd2 
0f59 19			    add hl,de 
0f5a			Div16_NoAdd2: 
0f5a 10 f6		    djnz Div16_Loop2 
0f5c 17			    rla 
0f5d 2f			    cpl 
0f5e 41			    ld b,c 
0f5f 4f			    ld c,a 
0f60 c9			ret 
0f61			 
0f61			 
0f61			;http://z80-heaven.wikidot.com/math 
0f61			; 
0f61			;Inputs: 
0f61			;     DE and A are factors 
0f61			;Outputs: 
0f61			;     A is not changed 
0f61			;     B is 0 
0f61			;     C is not changed 
0f61			;     DE is not changed 
0f61			;     HL is the product 
0f61			;Time: 
0f61			;     342+6x 
0f61			; 
0f61			Mult16: 
0f61			 
0f61 06 08		     ld b,8          ;7           7 
0f63 21 00 00		     ld hl,0         ;10         10 
0f66 29			       add hl,hl     ;11*8       88 
0f67 07			       rlca          ;4*8        32 
0f68 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f6a 19			         add hl,de   ;--         -- 
0f6b 10 f9		       djnz $-5      ;13*7+8     99 
0f6d c9			ret 
0f6e			 
0f6e			; 
0f6e			; Square root of 16-bit value 
0f6e			; In:  HL = value 
0f6e			; Out:  D = result (rounded down) 
0f6e			; 
0f6e			;Sqr16: 
0f6e			;    ld de,#0040 
0f6e			;    ld a,l 
0f6e			;    ld l,h 
0f6e			;    ld h,d 
0f6e			;    or a 
0f6e			;    ld b,8 
0f6e			;Sqr16_Loop: 
0f6e			;    sbc hl,de 
0f6e			;    jr nc,Sqr16_Skip 
0f6e			;    add hl,de 
0f6e			;Sqr16_Skip: 
0f6e			;    ccf 
0f6e			;    rl d 
0f6e			;    add a,a 
0f6e			;    adc hl,hl 
0f6e			;    add a,a 
0f6e			;    adc hl,hl 
0f6e			;    djnz Sqr16_Loop 
0f6e			;    ret 
0f6e			; 
0f6e			; 
0f6e			; Divide 8-bit values 
0f6e			; In: Divide E by divider C 
0f6e			; Out: A = result, B = rest 
0f6e			; 
0f6e			Div8: 
0f6e af			    xor a 
0f6f 06 08		    ld b,8 
0f71			Div8_Loop: 
0f71 cb 13		    rl e 
0f73 17			    rla 
0f74 91			    sub c 
0f75 30 01		    jr nc,Div8_NoAdd 
0f77 81			    add a,c 
0f78			Div8_NoAdd: 
0f78 10 f7		    djnz Div8_Loop 
0f7a 47			    ld b,a 
0f7b 7b			    ld a,e 
0f7c 17			    rla 
0f7d 2f			    cpl 
0f7e c9			    ret 
0f7f			 
0f7f			; 
0f7f			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f7f			; In: Multiply A with DE 
0f7f			; Out: HL = result 
0f7f			; 
0f7f			Mult12U: 
0f7f 2e 00		    ld l,0 
0f81 87			    add a,a 
0f82 30 01		    jr nc,Mult12U_NoAdd0 
0f84 19			    add hl,de 
0f85			Mult12U_NoAdd0: 
0f85 29			    add hl,hl 
0f86 87			    add a,a 
0f87 30 01		    jr nc,Mult12U_NoAdd1 
0f89 19			    add hl,de 
0f8a			Mult12U_NoAdd1: 
0f8a 29			    add hl,hl 
0f8b 87			    add a,a 
0f8c 30 01		    jr nc,Mult12U_NoAdd2 
0f8e 19			    add hl,de 
0f8f			Mult12U_NoAdd2: 
0f8f 29			    add hl,hl 
0f90 87			    add a,a 
0f91 30 01		    jr nc,Mult12U_NoAdd3 
0f93 19			    add hl,de 
0f94			Mult12U_NoAdd3: 
0f94 29			    add hl,hl 
0f95 87			    add a,a 
0f96 30 01		    jr nc,Mult12U_NoAdd4 
0f98 19			    add hl,de 
0f99			Mult12U_NoAdd4: 
0f99 29			    add hl,hl 
0f9a 87			    add a,a 
0f9b 30 01		    jr nc,Mult12U_NoAdd5 
0f9d 19			    add hl,de 
0f9e			Mult12U_NoAdd5: 
0f9e 29			    add hl,hl 
0f9f 87			    add a,a 
0fa0 30 01		    jr nc,Mult12U_NoAdd6 
0fa2 19			    add hl,de 
0fa3			Mult12U_NoAdd6: 
0fa3 29			    add hl,hl 
0fa4 87			    add a,a 
0fa5 d0			    ret nc 
0fa6 19			    add hl,de 
0fa7 c9			    ret 
0fa8			 
0fa8			; 
0fa8			; Multiply 8-bit value with a 16-bit value (right rotating) 
0fa8			; In: Multiply A with DE 
0fa8			;      Put lowest value in A for most efficient calculation 
0fa8			; Out: HL = result 
0fa8			; 
0fa8			Mult12R: 
0fa8 21 00 00		    ld hl,0 
0fab			Mult12R_Loop: 
0fab cb 3f		    srl a 
0fad 30 01		    jr nc,Mult12R_NoAdd 
0faf 19			    add hl,de 
0fb0			Mult12R_NoAdd: 
0fb0 cb 23		    sla e 
0fb2 cb 12		    rl d 
0fb4 b7			    or a 
0fb5 c2 ab 0f		    jp nz,Mult12R_Loop 
0fb8 c9			    ret 
0fb9			 
0fb9			; 
0fb9			; Multiply 16-bit values (with 32-bit result) 
0fb9			; In: Multiply BC with DE 
0fb9			; Out: BCHL = result 
0fb9			; 
0fb9			Mult32: 
0fb9 79			    ld a,c 
0fba 48			    ld c,b 
0fbb 21 00 00		    ld hl,0 
0fbe 06 10		    ld b,16 
0fc0			Mult32_Loop: 
0fc0 29			    add hl,hl 
0fc1 17			    rla 
0fc2 cb 11		    rl c 
0fc4 30 07		    jr nc,Mult32_NoAdd 
0fc6 19			    add hl,de 
0fc7 ce 00		    adc a,0 
0fc9 d2 cd 0f		    jp nc,Mult32_NoAdd 
0fcc 0c			    inc c 
0fcd			Mult32_NoAdd: 
0fcd 10 f1		    djnz Mult32_Loop 
0fcf 41			    ld b,c 
0fd0 4f			    ld c,a 
0fd1 c9			    ret 
0fd2			 
0fd2			 
0fd2			 
0fd2			; 
0fd2			; Multiply 8-bit values 
0fd2			; In:  Multiply H with E 
0fd2			; Out: HL = result 
0fd2			; 
0fd2			Mult8: 
0fd2 16 00		    ld d,0 
0fd4 6a			    ld l,d 
0fd5 06 08		    ld b,8 
0fd7			Mult8_Loop: 
0fd7 29			    add hl,hl 
0fd8 30 01		    jr nc,Mult8_NoAdd 
0fda 19			    add hl,de 
0fdb			Mult8_NoAdd: 
0fdb 10 fa		    djnz Mult8_Loop 
0fdd c9			    ret 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			 
0fde			;;http://z80-heaven.wikidot.com/math 
0fde			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fde			; 
0fde			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fde			;     ld a,16        ;7 
0fde			;     ld hl,0        ;10 
0fde			;     jp $+5         ;10 
0fde			;.DivLoop: 
0fde			;       add hl,bc    ;-- 
0fde			;       dec a        ;64 
0fde			;       jr z,.DivLoopEnd        ;86 
0fde			; 
0fde			;       sla e        ;128 
0fde			;       rl d         ;128 
0fde			;       adc hl,hl    ;240 
0fde			;       sbc hl,bc    ;240 
0fde			;       jr nc,.DivLoop ;23|21 
0fde			;       inc e        ;-- 
0fde			;       jp .DivLoop+1 
0fde			; 
0fde			;.DivLoopEnd: 
0fde			 
0fde			;HL_Div_C: 
0fde			;Inputs: 
0fde			;     HL is the numerator 
0fde			;     C is the denominator 
0fde			;Outputs: 
0fde			;     A is the remainder 
0fde			;     B is 0 
0fde			;     C is not changed 
0fde			;     DE is not changed 
0fde			;     HL is the quotient 
0fde			; 
0fde			;       ld b,16 
0fde			;       xor a 
0fde			;         add hl,hl 
0fde			;         rla 
0fde			;         cp c 
0fde			;         jr c,$+4 
0fde			;           inc l 
0fde			;           sub c 
0fde			;         djnz $-7 
0fde			 
0fde			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fde			 
0fde			addatohl: 
0fde 85			    add   a, l    ; A = A+L 
0fdf 6f			    ld    l, a    ; L = A+L 
0fe0 8c			    adc   a, h    ; A = A+L+H+carry 
0fe1 95			    sub   l       ; A = H+carry 
0fe2 67			    ld    h, a    ; H = H+carry 
0fe3 c9			ret 
0fe4			 
0fe4			addatode: 
0fe4 83			    add   a, e    ; A = A+L 
0fe5 5f			    ld    e, a    ; L = A+L 
0fe6 8a			    adc   a, d    ; A = A+L+H+carry 
0fe7 93			    sub   e       ; A = H+carry 
0fe8 57			    ld    d, a    ; H = H+carry 
0fe9 c9			ret 
0fea			 
0fea			 
0fea			addatobc: 
0fea 81			    add   a, c    ; A = A+L 
0feb 4f			    ld    c, a    ; L = A+L 
0fec 88			    adc   a, b    ; A = A+L+H+carry 
0fed 91			    sub   c       ; A = H+carry 
0fee 47			    ld    b, a    ; H = H+carry 
0fef c9			ret 
0ff0			 
0ff0			subafromhl: 
0ff0			   ; If A=0 do nothing 
0ff0			    ; Otherwise flip A's sign. Since 
0ff0			    ; the upper byte becomes -1, also 
0ff0			    ; substract 1 from H. 
0ff0 ed 44		    neg 
0ff2 ca fb 0f		    jp    z, Skip 
0ff5 25			    dec   h 
0ff6			     
0ff6			    ; Now add the low byte as usual 
0ff6			    ; Two's complement takes care of 
0ff6			    ; ensuring the result is correct 
0ff6 85			    add   a, l 
0ff7 6f			    ld    l, a 
0ff8 8c			    adc   a, h 
0ff9 95			    sub   l 
0ffa 67			    ld    h, a 
0ffb			Skip: 
0ffb c9				ret 
0ffc			 
0ffc			 
0ffc			; compare hl and de 
0ffc			; returns:  
0ffc			; if hl = de, z=1, s=0, c0=0 
0ffc			; if hl > de, z=0, s=0, c=0 
0ffc			; if hl < de, z=0, s=1, c=1 
0ffc			cmp16:	 
0ffc b7				or a 
0ffd ed 52			sbc hl,de 
0fff e0				ret po 
1000 7c				ld a,h 
1001 1f				rra 
1002 ee 40			xor 01000000B 
1004 37				scf 
1005 8f				adc a,a 
1006 c9				ret 
1007			 
1007			 
1007			; test if hl contains zero   - A is destroyed 
1007			 
1007			ishlzero:    
1007 b7				or a     ; reset flags 
1008 7c				ld a, h 
1009 b5				or l        	 
100a			 
100a c9				ret 
100b			 
100b			 
100b			 
100b			 
100b			if FORTH_ENABLE_FLOATMATH 
100b			;include "float/bbcmath.z80" 
100b			include "float/lpfpcalc.asm" 
100b			endif 
100b			 
100b			 
100b			; eof 
100b			 
# End of file firmware_maths.asm
100b			include "firmware_strings.asm"   ; string handling  
100b			 
100b			 
100b			; TODO string len 
100b			; input text string, end on cr with zero term 
100b			; a offset into frame buffer to start prompt 
100b			; d is max length 
100b			; e is display size TODO 
100b			; c is current cursor position 
100b			; hl is ptr to where string will be stored and edited directly 
100b			 
100b			 
100b			; TODO check limit of buffer for new inserts 
100b			; TODO check insert does not push beyond buffer 
100b			; TODO scroll in a limited display area 
100b			; TODO scroll whole screen on page wrap 
100b			 
100b			 
100b			; TODO use LCD cursor? 
100b			 
100b			EDIT_V1: equ 0 
100b			EDIT_V2: equ 1 
100b			 
100b			 
100b			 
100b			if EDIT_V2 
100b			input_str: 
100b			 
100b 32 99 fd			    	ld (input_at_pos),a      ; save display position to start 
100e			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
100e 22 9c fd				ld (input_start), hl     ; save ptr to buffer 
1011			;		ld a, c 
1011			;		call addatohl 
1011			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
1011 7a					ld a,d 
1012 32 9b fd			        ld (input_size), a       ; save length of input area 
1015 79					ld a, c 
1016 32 8a fd				ld (input_cursor),a      ; init cursor start position relative to start of string 
1019 7b					ld a,e 
101a 32 9a fd			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
101d			 
101d			 
101d					; add a trailing space to make screen refresh nicer 
101d			 
101d					;ld hl, (input_start) 
101d					;push hl 
101d					;ld a, 0 
101d					;call strlent 
101d					;ld a, l 
101d					;pop hl 
101d					;call addatohl 
101d					;dec hl 
101d					;ld a, ' ' 
101d					;ld (hl), a 
101d					;inc hl 
101d					;ld (hl), a 
101d					;inc hl 
101d					;ld a, 0 
101d					;ld (hl), a 
101d			 
101d			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
101d					; init cursor shape if not set by the cin routines 
101d 21 f6 fa				ld hl, cursor_shape 
1020			if BASE_KEV 
1020 3e ff				ld a, 255 
1022			else 
1022					ld a, '#' 
1022			endif 
1022 77					ld (hl), a 
1023 23					inc hl 
1024 3e 00				ld a, 0 
1026 77					ld (hl), a 
1027			 
1027 3e 09				ld a, CUR_BLINK_RATE 
1029 32 95 fd				ld (input_cur_flash), a 
102c 3e 01				ld a, 1 
102e 32 94 fd				ld (input_cur_onoff),a 
1031			.inmain:	 
1031			 
1031 cd 59 11				call input_disp_ref 
1034			 
1034					; save current length of string 
1034			 
1034 2a 9c fd				ld hl, (input_start) 
1037 3e 00				ld a, 0 
1039 cd 4f 13				call strlent 
103c 7d					ld a,l 
103d 32 8f fd				ld (input_len), a 
1040			 
1040					;call input_disp_oncur 
1040			 
1040					; display current state of input buffer 
1040			 
1040					; clean any backspace chars 
1040			 
1040 3e 20				ld a, " " 
1042 32 f6 f0				ld (scratch),a 
1045 3e 00				ld a, 0 
1047 32 f7 f0				ld (scratch+1),a 
104a 3a 99 fd				ld a,(input_at_pos) 
104d 85					add l 
104e 11 f6 f0				ld de, scratch 
1051 cd bd 0d				call str_at_display 
1054			 
1054					; pause 1ms 
1054			 
1054 3e 01				ld a, 1 
1056 cd d2 0c				call aDelayInMS 
1059			 
1059			; display cursor if visible on this cycle 
1059			 
1059					; dec flash counter 
1059 3a 95 fd				ld a, (input_cur_flash) 
105c 3d					dec a 
105d 32 95 fd				ld (input_cur_flash), a 
1060 fe 00				cp 0 
1062 20 0d				jr nz, .inochgstate 
1064			 
1064			 
1064					; reset on change of state 
1064 3e 09				ld a, CUR_BLINK_RATE 
1066 32 95 fd				ld (input_cur_flash), a 
1069			 
1069					; change state 
1069 3a 94 fd				ld a,(input_cur_onoff) 
106c ed 44				neg 
106e 32 94 fd				ld (input_cur_onoff),a 
1071			 
1071			 
1071			 
1071			 
1071					; TODO is cursor visible? 
1071					; TODO if so then over write the char at curspos pos with the cursor shape 
1071			 
1071								 
1071			 
1071			.inochgstate: 
1071 3a 94 fd				ld a,(input_cur_onoff) 
1074 fe ff				cp 255 
1076 28 0e				jr z, .skipcursor 
1078 3a 99 fd				ld a, (input_at_pos) 
107b 47					ld b, a 
107c 3a 8a fd				ld a, (input_cursor) 
107f 80					add b 
1080 11 f6 fa				ld de, cursor_shape 
1083					 
1083 cd bd 0d				call str_at_display 
1086			 
1086			.skipcursor: 
1086				if DEBUG_INPUTV2 
1086			 
1086					ld a,(input_at_pos) 
1086					ld hl, LFSRSeed 
1086					call hexout 
1086					ld a, (input_cursor) 
1086					ld hl, LFSRSeed+2 
1086					call hexout 
1086					ld a,(input_size) 
1086					ld hl, LFSRSeed+4 
1086					call hexout 
1086			 
1086					ld a,(input_cur_onoff) 
1086					ld hl, LFSRSeed+6 
1086					call hexout 
1086			 
1086					ld a,(input_cur_flash) 
1086					ld hl, LFSRSeed+8 
1086					call hexout 
1086			 
1086					ld a,(input_len) 
1086					ld hl, LFSRSeed+10 
1086					call hexout 
1086					ld hl, LFSRSeed+12 
1086					ld a, 0 
1086					ld (hl),a 
1086					ld a, display_row_4 
1086					ld de, LFSRSeed 
1086					call str_at_display 
1086				endif 
1086 cd cd 0d				call update_display 
1089			 
1089					; TODO keyboard processing 
1089			 
1089			if BASE_CPM 
1089					call cin_wait 
1089			else 
1089 cd 93 74				call cin    ; _wait 
108c			endif 
108c fe 00				cp 0 
108e ca 31 10				jp z, .inmain 
1091			 
1091 fe 0b				cp KEY_LEFT    ; cursor left 
1093 ca 4b 11				jp z, input_left 
1096				 
1096 fe 0c				cp KEY_RIGHT      ; cursor right 
1098 ca 52 11				jp z, input_right 
109b			 
109b fe 0d				cp KEY_CR 
109d c8					ret z 
109e			 
109e fe 08				cp KEY_BS 
10a0 ca c0 11				jp z, input_delchar 
10a3			 
10a3 fe 06				cp KEY_NEXTWORD 
10a5 ca cc 10				jp z, input_nxtword 
10a8			 
10a8 fe 07				cp KEY_PREVWORD 
10aa ca f3 10				jp z, input_prvword 
10ad			 
10ad fe 0e				cp KEY_HOME    ; jump to start of line 
10af 20 08				jr nz, .ikh 
10b1 3e 00				ld a, 0 
10b3 32 8a fd				ld (input_cursor), a 
10b6 ca 31 10				jp z, .inmain 
10b9			.ikh: 
10b9			 
10b9 fe 0f				cp KEY_END     ; jump to end of line 
10bb 20 09				jr nz, .ike 
10bd 3a 8f fd				ld a, (input_len) 
10c0 32 8a fd				ld (input_cursor),a 
10c3 ca 31 10				jp z, .inmain 
10c6			.ike: 
10c6 fe 05			        cp KEY_UP      ; recall last command 
10c8 c8					ret z 
10c9			;jr nz, .irec 
10c9			; TODO next word 
10c9			; TODO prev word 
10c9			;  
10c9			; 
10c9			;	ld hl, scratch 
10c9			;	ld de, os_last_cmd 
10c9			;	call strcpy 
10c9			;		jp  .inmain 
10c9			.irec: 
10c9			;		jr .instr1 
10c9			 
10c9			 
10c9			 
10c9					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
10c9			 
10c9			; TODO return if any special keys are given 
10c9			;		ld l, a 
10c9			;		ld a, 28 ; KEY_F12   ; 27 
10c9			;		sub l 
10c9			;		ret m 
10c9			;		ld a, l 
10c9					; if no special key then insert as a char 
10c9			 
10c9 c3 92 11				jp input_inschr 
10cc			 
10cc				 
10cc			input_nxtword: 
10cc				; jump to start next word after the cursor 
10cc			 
10cc			.insknwn:	 
10cc cd 88 11				call input_curptr	 
10cf 7e					ld a,(hl)	 
10d0 fe 00				cp 0 
10d2 ca 31 10				jp z, .inmain    ; end of string 
10d5			 
10d5			; if we are on a word, then move off of it 
10d5			 
10d5 fe 20				cp ' ' 
10d7 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
10d9 21 8a fd				ld hl, input_cursor 
10dc 34					inc (hl) 
10dd 18 ed				jr .insknwn 
10df			 
10df			.inspace: 
10df			 
10df cd 88 11				call input_curptr	 
10e2 7e					ld a,(hl)	 
10e3 fe 00				cp 0 
10e5 ca 31 10				jp z, .inmain    ; end of string 
10e8			 
10e8			; if we are on a word, then move off of it 
10e8			 
10e8 fe 20				cp ' ' 
10ea c2 31 10				jp nz, .inmain     ; we are on non space so at next word 
10ed 21 8a fd				ld hl, input_cursor 
10f0 34					inc (hl) 
10f1 18 ec				jr .inspace 
10f3			 
10f3			 
10f3			 
10f3			 
10f3			input_prvword: 
10f3				; jump to the start of previous word before the cursor 
10f3			 
10f3			; where are we to start with currently? 
10f3			 
10f3 cd 88 11				call input_curptr	 
10f6 7e					ld a, (hl) 
10f7 fe 20				cp ' ' 
10f9 28 1d				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
10fb			 
10fb			 
10fb			 
10fb			.inskpwn:	 
10fb 3a 8a fd				ld a,(input_cursor) 
10fe fe 00				cp 0 
1100 ca 31 10				jp z, .inmain    ; start of string 
1103			 
1103			;if we are on a word, then move off of it 
1103			 
1103 cd 88 11				call input_curptr	 
1106 7e					ld a, (hl) 
1107 fe 20				cp ' ' 
1109 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
110b					;jp z, .inmain    ; start of string 
110b 21 8a fd				ld hl, input_cursor 
110e 35					dec (hl) 
110f 18 ea				jr .inskpwn 
1111			.iwstart: 
1111 21 8a fd				ld hl, input_cursor 
1114 34					inc (hl) 
1115 c3 31 10				jp .inmain 
1118					 
1118			 
1118			.inspacep: 
1118			 
1118					;jp .inmain    ; start of string 
1118			 
1118			 
1118			 
1118 3a 8a fd				ld a,(input_cursor) 
111b fe 00				cp 0 
111d ca 31 10				jp z, .inmain    ; start of string 
1120			 
1120			; if we are on a word, then move off of it 
1120			 
1120 cd 88 11				call input_curptr	 
1123 7e					ld a, (hl) 
1124 fe 20				cp ' ' 
1126 c2 2f 11				jp nz, .incharp     ; we are on non space so at end of prev word 
1129 21 8a fd				ld hl, input_cursor 
112c 35					dec (hl) 
112d 18 e9				jr .inspacep 
112f			 
112f			 
112f			.incharp:	 
112f					; eat the word to get to the start 
112f 3a 8a fd				ld a,(input_cursor) 
1132 fe 00				cp 0 
1134 ca 31 10				jp z, .inmain    ; start of string 
1137			 
1137			; if we are on a word, then move off of it 
1137			 
1137 cd 88 11				call input_curptr	 
113a 7e					ld a, (hl) 
113b fe 20				cp ' ' 
113d 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
113f 21 8a fd				ld hl, input_cursor 
1142 35					dec (hl) 
1143 18 ea				jr .incharp 
1145			.ipwordst: 
1145					; at space before the prev word so reposition over it 
1145 21 8a fd				ld hl, input_cursor 
1148 34					inc (hl) 
1149 18 b0				jr .inskpwn 
114b					 
114b			 
114b			 
114b			input_left: 
114b				; move cursor left 
114b 21 8a fd			ld hl, input_cursor 
114e 35				dec (hl) 
114f			;	cp 0 
114f			;	jp z, .inmain    ; ignore left as at the start of the string 
114f c3 31 10			jp .inmain 
1152			 
1152			input_right: 
1152				; move cursor right 
1152				 
1152				;ld a, (input_size) 
1152				;ld b, a 
1152 21 8a fd			ld hl, input_cursor 
1155 34				inc (hl) 
1156				;dec b 
1156				;cp 0 
1156				;jp z, .inmain   ; ignore as at end of the string buffer 
1156				;ld a, b 
1156				;inc a 
1156				;ld (input_cursor), a 
1156 c3 31 10			jp .inmain 
1159			 
1159			 
1159			 
1159			input_disp_ref: 
1159				; display the text from start of buffer (ie full refresh) 
1159 3a 99 fd			ld a, (input_at_pos) 
115c 2a 9c fd			ld hl,(input_start) 
115f eb				ex de, hl 
1160 cd bd 0d			call str_at_display  
1163 c9				ret 
1164			input_disp_oncur: 
1164				; display the text from cursor position to end of buffer 
1164				; TODO position start of string at cursor position on screen 
1164				; TODO draw from that point on 
1164 3a 8a fd			ld a, (input_cursor) 
1167 47				ld b, a 
1168 3a 99 fd			ld a, (input_at_pos) 
116b 80				add b 
116c 48				ld c, b     ; save a 
116d 78				ld a, b     ; inc string start for cursor 
116e 2a 9c fd			ld hl,(input_start) 
1171 cd de 0f			call addatohl 
1174 eb				ex de, hl 
1175 79				ld a, c 
1176 cd bd 0d			call str_at_display  
1179 c9				ret 
117a			 
117a			input_nxtw: 
117a				; Find next word 
117a c9				ret 
117b			 
117b			input_prvw: 
117b				; Find previous word 
117b c9				ret 
117c			 
117c			input_lenrem:   
117c				; Calculate the length of string remaining from current cursor 
117c				; position to end of buffer (exc null term) 
117c				 
117c 3a 8a fd			ld a, (input_cursor) 
117f 4f				ld c, a 
1180 3a 9b fd			ld a, (input_size) 
1183 91				sub c 
1184 06 00			ld b, 0 
1186 0d				dec c 
1187 c9				ret	 
1188			 
1188			input_curptr: 
1188				; calc address of the character under the cursor 
1188				 
1188 2a 9c fd			ld hl, (input_start) 
118b 3a 8a fd			ld a, (input_cursor) 
118e cd de 0f			call addatohl 
1191 c9				ret 
1192			 
1192			input_inschr: 
1192				; Insert char at cursor position 
1192 f5				push af   ; save char 
1193				;call input_lenrem    ; get bc length of remaining string 
1193			 
1193				 
1193 cd 88 11			call input_curptr 
1196			;	ld hl, (input_start) 
1196			;	ld a, (input_cursor) 
1196			;	call addatohl 
1196				;push hl   ; save to come back to 
1196			 
1196				; shift everything up one to end of buffer 
1196			 
1196				;push hl 
1196				;dec de 
1196				;inc de 
1196			;	ldir 
1196				 
1196				;pop hl 
1196			 
1196				; are we adding to the end of line? 
1196			 
1196 3a 8a fd			ld a, (input_cursor) 
1199 47				ld b, a 
119a 3a 8f fd			ld a, (input_len) 
119d b8				cp b 
119e 20 09			jr nz, .insmid   ; no, insert in middle of text 
11a0			 
11a0				; tack on the end of the line 
11a0 f1				pop af 
11a1 77				ld (hl), a   ; save new char 
11a2 23				inc hl 
11a3 3e 00			ld a, 0 
11a5 77				ld (hl), a 
11a6 c3 52 11			jp input_right 
11a9				 
11a9			.insmid: 
11a9				; hl has insertion point so move everything up one to allow for insertion 
11a9				;call input_shiftright 
11a9 f1				pop af 
11aa			 
11aa			.shufinsmid: 
11aa 47				ld b, a     ; b contains new char, c prev char at this position  
11ab 7e				ld a, (hl) 
11ac			 
11ac fe 00			cp 0    ; at end of string need to then dump new char and add term 
11ae 28 07			jr z, .endinsmid 
11b0 4f				ld c, a 
11b1 78				ld a, b 
11b2 77				ld (hl), a 
11b3 23				inc hl 
11b4 79				ld a, c 
11b5 18 f3			jr .shufinsmid 
11b7				 
11b7			 
11b7			 
11b7			 
11b7			.endinsmid: 
11b7 78				ld a, b 
11b8 77				ld (hl), a 
11b9 23				inc hl 
11ba 3e 00			ld a, 0 
11bc 77				ld (hl), a 
11bd			 
11bd			 
11bd			;	ld (hl), a   ; save new char 
11bd			 
11bd c3 52 11			jp input_right 
11c0			 
11c0			;input_shiftright: 
11c0			;	; shift text right at cursor, hl has shift start 
11c0			;	push hl 
11c0			;	push de 
11c0			;	push bc 
11c0			; 
11c0			; 
11c0			;	; move to end of string past zero term 
11c0			;	ld hl,(input_start) 
11c0			;	ld a, (input_len) 
11c0			;	call addatohl 
11c0			;	inc hl 
11c0			;;	inc hl 
11c0			;;	inc hl 
11c0			;	ld a, 0 
11c0			;	ld (hl), a 
11c0			;;	dec hl 
11c0			;	 
11c0			;;	ld (hl), a 
11c0			;;	dec hl 
11c0			; 
11c0			;	push hl 
11c0			;	pop de 
11c0			;	inc de 
11c0			;	 
11c0			; 
11c0			;;	ld hl,(input_start) 
11c0			;;	ld a, (input_cursor) 
11c0			;;	call addatohl 
11c0			; 
11c0			; 
11c0			;	; calc how many bytes from cursor pos to end of string we need to shift 
11c0			;	call input_lenrem    ; get bc length of remaining string 
11c0			;	;ld a, (input_cursor) 
11c0			;	;ld c, a 
11c0			;	ld a, (input_len) 
11c0			;	cp 2 
11c0			;	jr z, .iskipzero	 
11c0			;	;sub c 
11c0			;	;inc a 
11c0			;	;ld c, a 
11c0			;	;ld b, 0 
11c0			;	inc c 
11c0			;	inc c 
11c0			;	; move data 
11c0			;	lddr 
11c0			;.iskipzero: 
11c0			; 
11c0			;	pop bc 
11c0			;	pop de 
11c0			;	pop hl 
11c0			;	ret	 
11c0			 
11c0			input_delchar: 
11c0				; Delete char at cursor position 
11c0 cd 7c 11			call input_lenrem    ; get bc length of remaining string 
11c3 2a 9c fd			ld hl, (input_start) 
11c6 3a 8a fd			ld a, (input_cursor) 
11c9 cd de 0f			call addatohl 
11cc			 
11cc e5				push hl 
11cd d1				pop de 
11ce 1b				dec de 
11cf			 
11cf			.dl:	 
11cf ed a0			ldi  
11d1 7e				ld a, (hl) 
11d2 fe 00			cp 0 
11d4 28 02			jr z, .dldone 
11d6 18 f7			jr .dl 
11d8			.dldone: 
11d8 ed a0			ldi 
11da			 
11da c3 4b 11			jp input_left 
11dd			 
11dd			 
11dd			endif 
11dd			 
11dd			 
11dd			 
11dd			if EDIT_V1 
11dd			input_str: 
11dd			 
11dd				    	ld (input_at_pos),a      ; save display position to start 
11dd					add c 
11dd					ld (input_at_cursor),a	; save draw pos of cursor 
11dd					ld (input_start), hl     ; save ptr to buffer 
11dd					ld a, c 
11dd					call addatohl 
11dd					ld (input_ptr), hl     ; save ptr to point under the cursor 
11dd					ld a,d 
11dd				        ld (input_size), a       ; save length of input area 
11dd					ld a, c 
11dd					ld (input_cursor),a      ; init cursor start position  
11dd					ld a,e 
11dd				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
11dd					 
11dd					 
11dd			 
11dd			;		ld a,(input_ptr) 
11dd			;		ld (input_under_cursor),a 	; save what is under the cursor 
11dd			 
11dd			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
11dd					; init cursor shape if not set by the cin routines 
11dd					ld hl, cursor_shape 
11dd			if BASE_KEV 
11dd					ld a, 255 
11dd			else 
11dd					ld a, '#' 
11dd			endif 
11dd					ld (hl), a 
11dd					inc hl 
11dd					ld a, 0 
11dd					ld (hl), a 
11dd			 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd					ld a, 1 
11dd					ld (input_cur_onoff),a 
11dd			 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, 'I' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd			.is1:		; main entry loop 
11dd			 
11dd			 
11dd			 
11dd					; pause 1ms 
11dd			 
11dd					ld a, 1 
11dd					call aDelayInMS 
11dd			 
11dd					; dec flash counter 
11dd					ld a, (input_cur_flash) 
11dd					dec a 
11dd					ld (input_cur_flash), a 
11dd					cp 0 
11dd					jr nz, .nochgstate 
11dd			 
11dd			 
11dd					; change state 
11dd					ld a,(input_cur_onoff) 
11dd					neg 
11dd					ld (input_cur_onoff),a 
11dd			 
11dd			 
11dd					; reset on change of state 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd			.nochgstate: 
11dd					 
11dd					 
11dd			 
11dd					; display cursor  
11dd			 
11dd			;		ld hl, (input_start) 
11dd			;		ld a, (input_cursor) 
11dd			;		call addatohl 
11dd			 
11dd					; get char under cursor and replace with cursor 
11dd			ld hl, (input_ptr) 
11dd			;		ld a, (hl) 
11dd			;		ld (input_under_cursor),a 
11dd			;		ld a, '_' 
11dd			;		ld (hl), a 
11dd			 
11dd					; display string 
11dd			 
11dd					ld de, (input_start) 
11dd					ld a, (input_at_pos) 
11dd					call str_at_display 
11dd			;	        call update_display 
11dd			 
11dd					; find place to put the cursor 
11dd			;		add h 
11dd			;		ld l, display_row_1 
11dd			;		sub l 
11dd			; (input_at_pos) 
11dd					;ld c, a 
11dd			;		ld a, (input_cursor) 
11dd			;		ld l, (input_at_pos) 
11dd			;		;ld b, h 
11dd			;		add l 
11dd			;		ld (input_at_cursor),a 
11dd					;ld l,h 
11dd			 
11dd			;		ld h, 0 
11dd			;		ld l,(input_at_pos) 
11dd			;		ld a, (input_cursor) 
11dd			;		call addatohl 
11dd			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
11dd			;		call subafromhl 
11dd			;		ld a,l 
11dd			;		ld (input_at_cursor), a 
11dd			 
11dd				if DEBUG_INPUT 
11dd					ld a, (hardware_diag) 
11dd					cp 0 
11dd					jr z, .skip_input_diag 
11dd			 
11dd					ld a,(input_at_pos) 
11dd					ld hl, LFSRSeed 
11dd					call hexout 
11dd					ld a, (input_cursor) 
11dd					ld hl, LFSRSeed+2 
11dd					call hexout 
11dd					ld a,(input_at_cursor) 
11dd					ld hl, LFSRSeed+4 
11dd					call hexout 
11dd			 
11dd					ld a,(input_cur_onoff) 
11dd					ld hl, LFSRSeed+6 
11dd					call hexout 
11dd			 
11dd					ld a,(input_cur_flash) 
11dd					ld hl, LFSRSeed+8 
11dd					call hexout 
11dd			 
11dd					ld a,(input_len) 
11dd					ld hl, LFSRSeed+10 
11dd					call hexout 
11dd					ld hl, LFSRSeed+12 
11dd					ld a, 0 
11dd					ld (hl),a 
11dd					ld a, display_row_4 
11dd					ld de, LFSRSeed 
11dd					call str_at_display 
11dd					.skip_input_diag: 
11dd				endif 
11dd			 
11dd					; decide on if we are showing the cursor this time round 
11dd			 
11dd					ld a, (input_cur_onoff) 
11dd					cp 255 
11dd					jr z, .skipcur 
11dd			 
11dd			 
11dd					ld a,(input_at_cursor) 
11dd					ld de, cursor_shape 
11dd					call str_at_display 
11dd			 
11dd					; save length of current input string 
11dd					ld hl, (input_start) 
11dd					ld a, 0 
11dd					call strlent 
11dd					ld a,l 
11dd					ld (input_len),a 
11dd			 
11dd			.skipcur: 
11dd			 
11dd				        call update_display 
11dd					 
11dd			 
11dd			 
11dd					; wait 
11dd				 
11dd					; TODO loop without wait to flash the cursor and char under cursor	 
11dd					call cin    ; _wait 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 
11dd			 
11dd					; get ptr to char to input into 
11dd			 
11dd					ld c,a 
11dd					ld hl, (input_start) 
11dd					ld a, (input_cursor) 
11dd					call addatohl 
11dd					ld (input_ptr), hl 
11dd					ld a,c 
11dd			 
11dd					; replace char under cursor 
11dd			 
11dd			;		ld hl, (input_ptr) 
11dd			;		ld a, (input_under_cursor) 	; get what is under the cursor 
11dd			;		ld (hl), a 
11dd			 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, 'i' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd					cp KEY_HOME 
11dd					jr nz, .iske 
11dd			 
11dd					ld a, (input_at_pos) 
11dd					ld (input_at_cursor),a 
11dd					ld a, 0 
11dd					ld (input_cursor), a 
11dd					jp .is1 
11dd					 
11dd			.iske:		cp KEY_END 
11dd					jr nz, .isknw 
11dd					jp .is1 
11dd			 
11dd			.isknw:		cp KEY_NEXTWORD 
11dd					jr nz, .iskpw 
11dd			 
11dd			.isknwm:	ld hl, (input_ptr) 
11dd					ld a,(hl)	 
11dd					cp 0 
11dd					jp z, .is1    ; end of string 
11dd					cp ' ' 
11dd					jp z, .is1    ; end of word 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd					jr .isknwm 
11dd			 
11dd			.iskpw:		cp KEY_PREVWORD 
11dd					jr nz, .iskl 
11dd			.iskpwm:	 
11dd					ld hl, (input_ptr) 
11dd					ld a,(hl)	 
11dd					cp 0  
11dd					jp z, .is1    ; end of string 
11dd					cp ' ' 
11dd					jp z, .is1    ; end of word 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd					jr .iskpwm 
11dd			 
11dd			 
11dd			.iskl:		cp KEY_LEFT 
11dd					jr nz, .isk1 
11dd			 
11dd					ld a, (input_cursor) 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 		; at start of line to ignore  
11dd			 
11dd					dec  a 		; TODO check underflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd					 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk1:		cp KEY_RIGHT 
11dd					jr nz, .isk2 
11dd			 
11dd					ld a,(input_len)		; TODO BUG why cant i load e direct? 
11dd					ld e,a 
11dd					ld a, (input_cursor) 
11dd					cp e 
11dd					jp z, .is1		; at the end of string so dont go right 
11dd			 
11dd					inc  a 		; TODO check overflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk2:		cp KEY_UP 
11dd			 
11dd					jr nz, .isk3 
11dd			 
11dd					; swap last command with the current on 
11dd			 
11dd					; move cursor to start of string 
11dd					ld hl, (input_start) 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld a, (input_at_pos) 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld a, 0 
11dd					ld (input_cursor), a 
11dd					 
11dd					; swap input and last command buffers 
11dd			 
11dd					ld hl, os_cli_cmd 
11dd					ld de, os_last_cmd 
11dd					ld b, 255 
11dd			.swap1:		ld a, (hl) 
11dd					ld c,a 
11dd					ld a, (de) 
11dd					ld (hl), a 
11dd					ld a,c 
11dd					ld (de),a 
11dd					inc hl 
11dd					inc de 
11dd					djnz .swap1 
11dd			 
11dd			 
11dd			 
11dd			 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk3:		cp KEY_BS 
11dd					jr nz, .isk4 
11dd			 
11dd					ld a, (input_cursor) 
11dd			 
11dd					cp 0 
11dd					jp z, .is1 		; at start of line to ignore  
11dd			 
11dd					dec  a 		; TODO check underflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					; hl is source 
11dd					; de needs to be source - 1 
11dd			 
11dd			;		ld a, 0 
11dd			;		dec hl 
11dd			;		ld (hl), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					; shift all data 
11dd			 
11dd					push hl 
11dd					inc hl 
11dd					pop de 
11dd					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
11dd					ld c,a 
11dd					ld b,0 
11dd					ldir  
11dd			 
11dd			 
11dd			 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					dec a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd			 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd			 
11dd					; remove char 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld de,.iblank 
11dd					call str_at_display 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.isk4:		cp KEY_CR 
11dd					jr z, .endinput 
11dd			 
11dd					; else add the key press to the end 
11dd			 
11dd					ld c, a			; save key pressed 
11dd			 
11dd					ld a,(hl)		; get what is currently under char 
11dd			 
11dd					cp 0			; we are at the end of the string 
11dd					jr nz, .onchar 
11dd					 
11dd					; add a char to the end of the string 
11dd				 
11dd					ld (hl),c 
11dd					inc hl 
11dd			;		ld a,' ' 
11dd			;		ld (hl),a 
11dd			;		inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd					dec hl 
11dd			 
11dd					ld a, (input_cursor) 
11dd					inc a				; TODO check max string length and scroll  
11dd					ld (input_cursor), a		; inc cursor pos 
11dd							 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					inc hl 
11dd					ld (input_ptr), hl 
11dd			;	if DEBUG_INPUT 
11dd			;		push af 
11dd			;		ld a, '+' 
11dd			;		ld (debug_mark),a 
11dd			;		pop af 
11dd			;		CALLMONITOR 
11dd			;	endif 
11dd					ld a, 1		; show cursor moving 
11dd					ld (input_cur_onoff),a 
11dd					ld a, CUR_BLINK_RATE 
11dd					ld (input_cur_flash), a 
11dd					jp .is1 
11dd					 
11dd			 
11dd			 
11dd					; if on a char then insert 
11dd			.onchar: 
11dd			 
11dd					; TODO over flow check: make sure insert does not blow out buffer 
11dd			 
11dd					; need to do some maths to use lddr 
11dd			 
11dd					push hl   ; save char pos 
11dd					push bc 
11dd			 
11dd					ld hl, (input_start) 
11dd					ld a, (input_len) 
11dd					call addatohl  		; end of string 
11dd					inc hl 
11dd					inc hl		; past zero term 
11dd					push hl 
11dd					inc hl 
11dd					push hl  
11dd			 
11dd								; start and end of lddr set, now how much to move? 
11dd			 
11dd							 
11dd					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
11dd					ld b,a 
11dd					ld a,(input_len) 
11dd					ld e,a 
11dd					sub b 
11dd					inc a		;?? 
11dd					inc a		;?? 
11dd					inc a		;?? 
11dd			 
11dd					ld b,0 
11dd					ld c,a 
11dd			 
11dd				if DEBUG_INPUT 
11dd					push af 
11dd					ld a, 'i' 
11dd					ld (debug_mark),a 
11dd					pop af 
11dd			;		CALLMONITOR 
11dd				endif 
11dd					pop de 
11dd					pop hl 
11dd				if DEBUG_INPUT 
11dd					push af 
11dd					ld a, 'I' 
11dd					ld (debug_mark),a 
11dd					pop af 
11dd			;		CALLMONITOR 
11dd				endif 
11dd					lddr 
11dd				 
11dd			 
11dd			 
11dd					; TODO have a key for insert/overwrite mode???? 
11dd					pop bc 
11dd					pop hl 
11dd					ld (hl), c		; otherwise overwrite current char 
11dd					 
11dd			 
11dd			 
11dd			 
11dd					ld a, (input_cursor) 
11dd					inc  a 		; TODO check overflow 
11dd					ld (input_cursor), a 
11dd			 
11dd					ld a, (input_at_cursor) 
11dd					inc a 
11dd					ld (input_at_cursor), a 
11dd			 
11dd					jp .is1 
11dd			 
11dd			.endinput:	; TODO look for end of string 
11dd			 
11dd					; add trailing space for end of token 
11dd			 
11dd					ld hl, (input_start) 
11dd					ld a,(input_len) 
11dd					call addatohl 
11dd					ld a, ' ' 
11dd					ld (hl),a 
11dd					; TODO eof of parse marker 
11dd			 
11dd					inc hl 
11dd					ld a, 0 
11dd					ld (hl),a 
11dd			 
11dd			 
11dd					ret 
11dd			 
11dd			.iblank: db " ",0 
11dd			 
11dd			 
11dd			input_str_prev:	ld (input_at_pos), a 
11dd					ld (input_start), hl 
11dd					ld a,1			; add cursor 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd					ld (input_ptr), hl 
11dd					ld a,d 
11dd					ld (input_size), a 
11dd					ld a,0 
11dd					ld (input_cursor),a 
11dd			.instr1:	 
11dd			 
11dd					; TODO do block cursor 
11dd					; TODO switch cursor depending on the modifer key 
11dd			 
11dd					; update cursor shape change on key hold 
11dd			 
11dd					ld hl, (input_ptr) 
11dd					dec hl 
11dd					ld a,(cursor_shape) 
11dd					ld (hl), a 
11dd			 
11dd					; display entered text 
11dd					ld a,(input_at_pos) 
11dd			            	CALL fLCD_Pos       ;Position cursor to location in A 
11dd			            	LD   de, (input_start) 
11dd			            	CALL fLCD_Str       ;Display string pointed to by DE 
11dd			 
11dd					call cin 
11dd					cp 0 
11dd					jr z, .instr1 
11dd			 
11dd					; proecess keyboard controls first 
11dd			 
11dd					ld hl,(input_ptr) 
11dd			 
11dd					cp KEY_CR	 ; pressing enter ends input 
11dd					jr z, .instrcr 
11dd			 
11dd					cp KEY_BS 	; back space 
11dd					jr nz, .instr2 
11dd					; process back space 
11dd			 
11dd					; TODO stop back space if at start of string 
11dd					dec hl 
11dd					dec hl ; to over write cursor 
11dd					ld a,(cursor_shape) 
11dd					;ld a,0 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a," " 
11dd					ld (hl),a 
11dd					ld (input_ptr),hl 
11dd					 
11dd			 
11dd					jr .instr1 
11dd			 
11dd			.instr2:	cp KEY_LEFT    ; cursor left 
11dd					jr nz, .instr3 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd				 
11dd			.instr3:	cp KEY_RIGHT      ; cursor right 
11dd					jr nz, .instr4 
11dd					inc hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			 
11dd			.instr4:	cp KEY_HOME    ; jump to start of line 
11dd					jr nz, .instr5 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			 
11dd			.instr5:	cp KEY_END     ; jump to end of line 
11dd					jr nz, .instr6 
11dd					dec hl 
11dd					ld (input_ptr),hl 
11dd					jr .instr1 
11dd			.instr6:        cp KEY_UP      ; recall last command 
11dd					jr nz, .instrnew 
11dd			 
11dd				ld hl, scratch 
11dd				ld de, os_last_cmd 
11dd				call strcpy 
11dd					jr .instr1 
11dd			 
11dd			 
11dd			.instrnew:	; no special key pressed to see if we have room to store it 
11dd			 
11dd					; TODO do string size test 
11dd			 
11dd					dec hl ; to over write cursor 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,(cursor_shape) 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd			 
11dd					ld (input_ptr),hl 
11dd					 
11dd					jr .instr1 
11dd			.instrcr:	dec hl		; remove cursor 
11dd					ld a,' '	; TODO add a trailing space for safety 
11dd					ld (hl),a 
11dd					inc hl 
11dd					ld a,0 
11dd					ld (hl),a 
11dd			 
11dd			 
11dd					; if at end of line scroll up    
11dd					; TODO detecting only end of line 4 for scroll up  
11dd			 
11dd					;ld   
11dd			 
11dd					ret 
11dd			 
11dd			 
11dd			endif 
11dd			; strcpy hl = dest, de source 
11dd			 
11dd 1a			strcpy:   LD   A, (DE)        ;Get character from string 
11de b7			            OR   A              ;Null terminator? 
11df c8			            RET  Z              ;Yes, so finished 
11e0 1a					ld a,(de) 
11e1 77					ld (hl),a 
11e2 13			            INC  DE             ;Point to next character 
11e3 23					inc hl 
11e4 18 f7		            JR   strcpy       ;Repeat 
11e6 c9					ret 
11e7			 
11e7			 
11e7			; TODO string_at  
11e7			; pass string which starts with lcd offset address and then null term string 
11e7			 
11e7			; TODO string to dec 
11e7			; TODO string to hex 
11e7			; TODO byte to string hex 
11e7			; TODO byte to string dec 
11e7			 
11e7			 
11e7			 
11e7			; from z80uartmonitor 
11e7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e7			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
11e7			; pass hl for where to put the text 
11e7			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11e7 c5			hexout:	PUSH BC 
11e8 f5					PUSH AF 
11e9 47					LD B, A 
11ea					; Upper nybble 
11ea cb 3f				SRL A 
11ec cb 3f				SRL A 
11ee cb 3f				SRL A 
11f0 cb 3f				SRL A 
11f2 cd 02 12				CALL tohex 
11f5 77					ld (hl),a 
11f6 23					inc hl	 
11f7					 
11f7					; Lower nybble 
11f7 78					LD A, B 
11f8 e6 0f				AND 0FH 
11fa cd 02 12				CALL tohex 
11fd 77					ld (hl),a 
11fe 23					inc hl	 
11ff					 
11ff f1					POP AF 
1200 c1					POP BC 
1201 c9					RET 
1202					 
1202			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1202			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
1202			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
1202			tohex: 
1202 e5					PUSH HL 
1203 d5					PUSH DE 
1204 16 00				LD D, 0 
1206 5f					LD E, A 
1207 21 0f 12				LD HL, .DATA 
120a 19					ADD HL, DE 
120b 7e					LD A, (HL) 
120c d1					POP DE 
120d e1					POP HL 
120e c9					RET 
120f			 
120f			.DATA: 
120f 30					DEFB	30h	; 0 
1210 31					DEFB	31h	; 1 
1211 32					DEFB	32h	; 2 
1212 33					DEFB	33h	; 3 
1213 34					DEFB	34h	; 4 
1214 35					DEFB	35h	; 5 
1215 36					DEFB	36h	; 6 
1216 37					DEFB	37h	; 7 
1217 38					DEFB	38h	; 8 
1218 39					DEFB	39h	; 9 
1219 41					DEFB	41h	; A 
121a 42					DEFB	42h	; B 
121b 43					DEFB	43h	; C 
121c 44					DEFB	44h	; D 
121d 45					DEFB	45h	; E 
121e 46					DEFB	46h	; F 
121f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
121f			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
121f			;;    subtract $30, if result > 9 then subtract $7 more 
121f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
121f			atohex: 
121f d6 30				SUB $30 
1221 fe 0a				CP 10 
1223 f8					RET M		; If result negative it was 0-9 so we're done 
1224 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
1226 c9					RET		 
1227			 
1227			 
1227			 
1227			 
1227			; Get 2 ASCII characters as hex byte from pointer in hl 
1227			 
1227			BYTERD: 
1227 16 00			LD	D,00h		;Set up 
1229 cd 31 12			CALL	HEXCON		;Get byte and convert to hex 
122c 87				ADD	A,A		;First nibble so 
122d 87				ADD	A,A		;multiply by 16 
122e 87				ADD	A,A		; 
122f 87				ADD	A,A		; 
1230 57				LD	D,A		;Save hi nibble in D 
1231			HEXCON: 
1231 7e				ld a, (hl)		;Get next chr 
1232 23				inc hl 
1233 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
1235 fe 0a			CP	00Ah		;Is it 0-9 ? 
1237 38 02			JR	C,NALPHA	;If so miss next bit 
1239 d6 07			SUB	007h		;Else convert alpha 
123b			NALPHA: 
123b b2				OR	D		;Add hi nibble back 
123c c9				RET			; 
123d			 
123d			 
123d			; 
123d			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
123d			; Since the routines get_byte and therefore get_nibble are called, only valid 
123d			; characters (0-9a-f) are accepted. 
123d			; 
123d			;get_word        push    af 
123d			;                call    get_byte        ; Get the upper byte 
123d			;                ld      h, a 
123d			;                call    get_byte        ; Get the lower byte 
123d			;                ld      l, a 
123d			;                pop     af 
123d			;                ret 
123d			; 
123d			; Get a byte in hexadecimal notation. The result is returned in A. Since 
123d			; the routine get_nibble is used only valid characters are accepted - the  
123d			; input routine only accepts characters 0-9a-f. 
123d			; 
123d c5			get_byte:        push    bc              ; Save contents of B (and C) 
123e 7e					ld a,(hl) 
123f 23					inc hl 
1240 cd 65 12		                call    nibble2val      ; Get upper nibble 
1243 cb 07		                rlc     a 
1245 cb 07		                rlc     a 
1247 cb 07		                rlc     a 
1249 cb 07		                rlc     a 
124b 47			                ld      b, a            ; Save upper four bits 
124c 7e					ld a,(hl) 
124d cd 65 12		                call    nibble2val      ; Get lower nibble 
1250 b0			                or      b               ; Combine both nibbles 
1251 c1			                pop     bc              ; Restore B (and C) 
1252 c9			                ret 
1253			; 
1253			; Get a hexadecimal digit from the serial line. This routine blocks until 
1253			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1253			; to the serial line interface. The lower 4 bits of A contain the value of  
1253			; that particular digit. 
1253			; 
1253			;get_nibble      ld a,(hl)           ; Read a character 
1253			;                call    to_upper        ; Convert to upper case 
1253			;                call    is_hex          ; Was it a hex digit? 
1253			;                jr      nc, get_nibble  ; No, get another character 
1253			 ;               call    nibble2val      ; Convert nibble to value 
1253			 ;               call    print_nibble 
1253			 ;               ret 
1253			; 
1253			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1253			; A valid hexadecimal digit is denoted by a set C flag. 
1253			; 
1253			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1253			;                ret     nc              ; Yes 
1253			;                cp      '0'             ; Less than '0'? 
1253			;                jr      nc, is_hex_1    ; No, continue 
1253			;                ccf                     ; Complement carry (i.e. clear it) 
1253			;                ret 
1253			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1253			;                ret     c               ; Yes 
1253			;                cp      'A'             ; Less than 'A'? 
1253			;                jr      nc, is_hex_2    ; No, continue 
1253			;                ccf                     ; Yes - clear carry and return 
1253			;                ret 
1253			;is_hex_2        scf                     ; Set carry 
1253			;                ret 
1253			; 
1253			; Convert a single character contained in A to upper case: 
1253			; 
1253 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1255 d8			                ret     c 
1256 fe 7b		                cp      'z' + 1         ; > 'z'? 
1258 d0			                ret     nc              ; Nothing to do, either 
1259 e6 5f		                and     $5f             ; Convert to upper case 
125b c9			                ret 
125c			 
125c			 
125c			to_lower: 
125c			 
125c			   ; if char is in [A-Z] make it lower case 
125c			 
125c			   ; enter : a = char 
125c			   ; exit  : a = lower case char 
125c			   ; uses  : af 
125c			 
125c fe 41		   cp 'A' 
125e d8			   ret c 
125f			    
125f fe 5b		   cp 'Z'+1 
1261 d0			   ret nc 
1262			    
1262 f6 20		   or $20 
1264 c9			   ret 
1265			 
1265			; 
1265			; Expects a hexadecimal digit (upper case!) in A and returns the 
1265			; corresponding value in A. 
1265			; 
1265 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1267 38 02		                jr      c, nibble2val_1 ; Yes 
1269 d6 07		                sub     7               ; Adjust for A-F 
126b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
126d e6 0f		                and     $f              ; Only return lower 4 bits 
126f c9			                ret 
1270			; 
1270			; Print_nibble prints a single hex nibble which is contained in the lower  
1270			; four bits of A: 
1270			; 
1270			;print_nibble    push    af              ; We won't destroy the contents of A 
1270			;                and     $f              ; Just in case... 
1270			;                add     a, '0'             ; If we have a digit we are done here. 
1270			;                cp      '9' + 1         ; Is the result > 9? 
1270			;                jr      c, print_nibble_1 
1270			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1270			;print_nibble_1  call    putc            ; Print the nibble and 
1270			;                pop     af              ; restore the original value of A 
1270			;                ret 
1270			;; 
1270			;; Send a CR/LF pair: 
1270			; 
1270			;crlf            push    af 
1270			;                ld      a, cr 
1270			;                call    putc 
1270			;                ld      a, lf 
1270			;                call    putc 
1270			;                pop     af 
1270			;                ret 
1270			; 
1270			; Print_word prints the four hex digits of a word to the serial line. The  
1270			; word is expected to be in HL. 
1270			; 
1270			;print_word      push    hl 
1270			;                push    af 
1270			;                ld      a, h 
1270			;                call    print_byte 
1270			;                ld      a, l 
1270			;                call    print_byte 
1270			;                pop     af 
1270			;                pop     hl 
1270			;                ret 
1270			; 
1270			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1270			; The byte to be printed is expected to be in A. 
1270			; 
1270			;print_byte      push    af              ; Save the contents of the registers 
1270			;                push    bc 
1270			;                ld      b, a 
1270			;                rrca 
1270			;                rrca 
1270			;                rrca 
1270			;                rrca 
1270			;                call    print_nibble    ; Print high nibble 
1270			;                ld      a, b 
1270			;                call    print_nibble    ; Print low nibble 
1270			;                pop     bc              ; Restore original register contents 
1270			;                pop     af 
1270			;                ret 
1270			 
1270			 
1270			 
1270			 
1270			 
1270			fourehexhl:  
1270 7e				ld a,(hl) 
1271 cd 1f 12			call atohex 
1274 cb 3f				SRL A 
1276 cb 3f				SRL A 
1278 cb 3f				SRL A 
127a cb 3f				SRL A 
127c 47				ld b, a 
127d 23				inc hl 
127e 7e				ld a,(hl) 
127f 23				inc hl 
1280 cd 1f 12			call atohex 
1283 80				add b 
1284 57				ld d,a 
1285 7e				ld a,(hl) 
1286 cd 1f 12			call atohex 
1289 cb 3f				SRL A 
128b cb 3f				SRL A 
128d cb 3f				SRL A 
128f cb 3f				SRL A 
1291 47				ld b, a 
1292 23				inc hl 
1293 7e				ld a,(hl) 
1294 23				inc hl 
1295 cd 1f 12			call atohex 
1298 80				add b 
1299 5f				ld e, a 
129a d5				push de 
129b e1				pop hl 
129c c9				ret 
129d			 
129d			; pass hl. returns z set if the byte at hl is a digit 
129d			;isdigithl:  
129d			;	push bc 
129d			;	ld a,(hl) 
129d			;	cp ':' 
129d			;	jr nc, .isdf 		; > 
129d			;	cp '0' 
129d			;	jr c, .isdf		; < 
129d			; 
129d			;	; TODO find a better way to set z 
129d			; 
129d			;	ld b,a 
129d			;	cp b 
129d			;	pop bc 
129d			;	ret 
129d			; 
129d			;.isdf:	; not digit so clear z 
129d			; 
129d			;	; TODO find a better way to unset z 
129d			; 
129d			;	ld b,a 
129d			;	inc b 
129d			;	cp b 
129d			; 
129d			;	pop bc 
129d			;	ret 
129d				 
129d				 
129d			 
129d			 
129d			; pass hl as the four byte address to load 
129d			 
129d			get_word_hl:  
129d e5				push hl 
129e cd 3d 12			call get_byte 
12a1				 
12a1 47				ld b, a 
12a2			 
12a2 e1				pop hl 
12a3 23				inc hl 
12a4 23				inc hl 
12a5			 
12a5			; TODO not able to handle a-f  
12a5 7e				ld a,(hl) 
12a6			;	;cp ':' 
12a6			;	cp 'g' 
12a6			;	jr nc, .single_byte_hl 		; > 
12a6			;	cp 'G' 
12a6			;	jr nc, .single_byte_hl 		; > 
12a6			;	cp '0' 
12a6			;	jr c, .single_byte_hl		; < 
12a6			 
12a6				;call isdigithl 
12a6 fe 00			cp 0 
12a8 28 06			jr z, .single_byte_hl 
12aa			 
12aa			.getwhln:   ; hex word so get next byte 
12aa			 
12aa cd 3d 12			call get_byte 
12ad 6f				ld l, a 
12ae 60				ld h,b 
12af c9				ret 
12b0 68			.single_byte_hl:   ld l,b 
12b1 26 00				ld h,0 
12b3 c9					ret 
12b4			 
12b4			 
12b4			 
12b4			 
12b4 21 23 1d			ld hl,asc+1 
12b7			;	ld a, (hl) 
12b7			;	call nibble2val 
12b7 cd 3d 12			call get_byte 
12ba			 
12ba			;	call fourehexhl 
12ba 32 2a f1			ld (scratch+52),a 
12bd				 
12bd 21 28 f1			ld hl,scratch+50 
12c0 22 19 f4			ld (os_cur_ptr),hl 
12c3			 
12c3 c9				ret 
12c4			 
12c4			 
12c4			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
12c4			 
12c4			; Decimal Unsigned Version 
12c4			 
12c4			;Number in a to decimal ASCII 
12c4			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
12c4			;Example: display a=56 as "056" 
12c4			;input: a = number 
12c4			;Output: a=0,value of a in the screen 
12c4			;destroys af,bc (don't know about hl and de) 
12c4			DispAToASCII: 
12c4 0e 9c			ld	c,-100 
12c6 cd d0 12			call	.Na1 
12c9 0e f6			ld	c,-10 
12cb cd d0 12			call	.Na1 
12ce 0e ff			ld	c,-1 
12d0 06 2f		.Na1:	ld	b,'0'-1 
12d2 04			.Na2:	inc	b 
12d3 81				add	a,c 
12d4 38 fc			jr	c,.Na2 
12d6 91				sub	c		;works as add 100/10/1 
12d7 f5				push af		;safer than ld c,a 
12d8 78				ld	a,b		;char is in b 
12d9			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
12d9 f1				pop af		;safer than ld a,c 
12da c9				ret 
12db			 
12db			; Decimal Signed Version 
12db			 
12db			; DispA 
12db			; -------------------------------------------------------------- 
12db			; Converts a signed integer value to a zero-terminated ASCII 
12db			; string representative of that value (using radix 10). 
12db			; -------------------------------------------------------------- 
12db			; INPUTS: 
12db			;     HL     Value to convert (two's complement integer). 
12db			;     DE     Base address of string destination. (pointer). 
12db			; -------------------------------------------------------------- 
12db			; OUTPUTS: 
12db			;     None 
12db			; -------------------------------------------------------------- 
12db			; REGISTERS/MEMORY DESTROYED 
12db			; AF HL 
12db			; -------------------------------------------------------------- 
12db			 
12db			;DispHLToASCII: 
12db			;   push    de 
12db			;   push    bc 
12db			; 
12db			;; Detect sign of HL. 
12db			;    bit    7, h 
12db			;    jr     z, ._DoConvert 
12db			; 
12db			;; HL is negative. Output '-' to string and negate HL. 
12db			;    ld     a, '-' 
12db			;    ld     (de), a 
12db			;    inc    de 
12db			; 
12db			;; Negate HL (using two's complement) 
12db			;    xor    a 
12db			;    sub    l 
12db			;    ld     l, a 
12db			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
12db			;    sbc    a, h 
12db			;    ld     h, a 
12db			; 
12db			;; Convert HL to digit characters 
12db			;._DoConvert: 
12db			;    ld     b, 0     ; B will count character length of number 
12db			;-   ld     a, 10 
12db			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
12db			;    push   af 
12db			;    inc    b 
12db			;    ld     a, h 
12db			;    or     l 
12db			;    jr     nz, - 
12db			; 
12db			;; Retrieve digits from stack 
12db			;-   pop    af 
12db			;    or     $30 
12db			;    ld     (de), a 
12db			;    inc    de 
12db			;    djnz   - 
12db			; 
12db			;; Terminate string with NULL 
12db			;    xor    a 
12db			;    ld     (de), a 
12db			; 
12db			;    pop    bc 
12db			;    pop    de 
12db			;    ret 
12db			 
12db			;Comments 
12db			; 
12db			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
12db			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
12db			;    Note that the output string will not be fixed-width. 
12db			; 
12db			;Example Usage 
12db			; 
12db			;    ld    hl, -1004 
12db			;    ld    de, OP1 
12db			;    call  DispA 
12db			;    ld    hl, OP1 
12db			;    syscall  PutS 
12db			 
12db			 
12db			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12db			 
12db			 
12db			;Converts an ASCII string to an unsigned 16-bit integer 
12db			;Quits when it reaches a non-decimal digit 
12db			 
12db			string_to_uint16: 
12db			atoui_16: 
12db			;Input: 
12db			;     DE points to the string 
12db			;Outputs: 
12db			;     HL is the result 
12db			;     A is the 8-bit value of the number 
12db			;     DE points to the byte after the number 
12db			;Destroys: 
12db			;     BC 
12db			;       if the string is non-empty, BC is HL/10 
12db			;Size:  24 bytes 
12db			;Speed: 42+d(104+{0,9}) 
12db			;       d is the number of digits in the number 
12db			;       max is 640 cycles for a 5 digit number 
12db			;Assuming no leading zeros: 
12db			;1 digit:  146cc 
12db			;2 digit:  250cc 
12db			;3 digit:  354cc or 363cc (avg: 354.126cc) 
12db			;4 digit:  458cc or 467cc (avg: 458.27cc) 
12db			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
12db			;avg: 544.81158447265625cc (544+13297/16384) 
12db			;=============================================================== 
12db 21 00 00		  ld hl,0 
12de			.u16a: 
12de 1a			  ld a,(de) 
12df d6 30		  sub 30h 
12e1 fe 0a		  cp 10 
12e3 d0			  ret nc 
12e4 13			  inc de 
12e5 44			  ld b,h 
12e6 4d			  ld c,l 
12e7 29			  add hl,hl 
12e8 29			  add hl,hl 
12e9 09			  add hl,bc 
12ea 29			  add hl,hl 
12eb 85			  add a,l 
12ec 6f			  ld l,a 
12ed 30 ef		  jr nc,.u16a 
12ef 24			  inc h 
12f0 c3 de 12		  jp .u16a 
12f3			 
12f3			 
12f3			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12f3			 
12f3			;written by Zeda 
12f3			;Converts a 16-bit unsigned integer to an ASCII string. 
12f3			 
12f3			uitoa_16: 
12f3			;Input: 
12f3			;   DE is the number to convert 
12f3			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
12f3			;Output: 
12f3			;   HL points to the null-terminated ASCII string 
12f3			;      NOTE: This isn't necessarily the same as the input HL. 
12f3 d5			  push de 
12f4 c5			  push bc 
12f5 f5			  push af 
12f6 eb			  ex de,hl 
12f7			 
12f7 01 f0 d8		  ld bc,-10000 
12fa 3e 2f		  ld a,'0'-1 
12fc 3c			  inc a 
12fd 09			  add hl,bc  
12fe 38 fc		   jr c,$-2 
1300 12			  ld (de),a 
1301 13			  inc de 
1302			 
1302 01 e8 03		  ld bc,1000 
1305 3e 3a		  ld a,'9'+1 
1307 3d			  dec a  
1308 09			  add hl,bc  
1309 30 fc		   jr nc,$-2 
130b 12			  ld (de),a 
130c 13			  inc de 
130d			 
130d 01 9c ff		  ld bc,-100 
1310 3e 2f		  ld a,'0'-1 
1312 3c			  inc a  
1313 09			  add hl,bc  
1314 38 fc		   jr c,$-2 
1316 12			  ld (de),a 
1317 13			  inc de 
1318			 
1318 7d			  ld a,l 
1319 26 3a		  ld h,'9'+1 
131b 25			  dec h  
131c c6 0a		  add a,10  
131e 30 fb		   jr nc,$-3 
1320 c6 30		  add a,'0' 
1322 eb			  ex de,hl 
1323 72			  ld (hl),d 
1324 23			  inc hl 
1325 77			  ld (hl),a 
1326 23			  inc hl 
1327 36 00		  ld (hl),0 
1329			 
1329			;Now strip the leading zeros 
1329 0e fa		  ld c,-6 
132b 09			  add hl,bc 
132c 3e 30		  ld a,'0' 
132e 23			  inc hl  
132f be			  cp (hl)  
1330 28 fc		  jr z,$-2 
1332			 
1332			;Make sure that the string is non-empty! 
1332 7e			  ld a,(hl) 
1333 b7			  or a 
1334 20 01		  jr nz,.atoub 
1336 2b			  dec hl 
1337			.atoub: 
1337			 
1337 f1			  pop af 
1338 c1			  pop bc 
1339 d1			  pop de 
133a c9			  ret 
133b			 
133b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
133b			 
133b			toUpper: 
133b			;A is the char. 
133b			;If A is a lowercase letter, this sets it to the matching uppercase 
133b			;18cc or 30cc or 41cc 
133b			;avg: 26.75cc 
133b fe 61		  cp 'a' 
133d d8			  ret c 
133e fe 7b		  cp 'z'+1 
1340 d0			  ret nc 
1341 d6 20		  sub 'a'-'A' 
1343 c9			  ret 
1344			 
1344			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1344			 
1344			; String Length 
1344			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1344			 
1344			; Get the length of the null-terminated string starting at $8000 hl 
1344			;    LD     HL, $8000 
1344			 
1344			strlenz: 
1344			 
1344 af			    XOR    A               ; Zero is the value we are looking for. 
1345 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1346 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1347			                           ; 65, 536 bytes (the entire addressable memory space). 
1347 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1349			 
1349			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1349 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
134a 6f			    LD     L, A             ; number of bytes 
134b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
134d 2b			    DEC    HL              ; Compensate for null. 
134e c9				ret 
134f			 
134f			; Get the length of the A terminated string starting at $8000 hl 
134f			;    LD     HL, $8000 
134f			 
134f			strlent: 
134f			 
134f			                  ; A is the value we are looking for. 
134f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1351 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1353			                           ; 65, 536 bytes (the entire addressable memory space). 
1353 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1355			 
1355			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1355 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1357 2e 00		    LD     L, 0             ; number of bytes 
1359 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
135b 2b			    DEC    HL              ; Compensate for null. 
135c c9				ret 
135d			 
135d			 
135d			;Comparing Strings 
135d			 
135d			;IN    HL     Address of string1. 
135d			;      DE     Address of string2. 
135d			 
135d			; doc given but wrong??? 
135d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
135d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
135d			; tested 
135d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
135d			 
135d			strcmp_old: 
135d e5			    PUSH   HL 
135e d5			    PUSH   DE 
135f			 
135f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1360 be			    CP     (HL)            ; (want to minimize work). 
1361 38 01		    JR     C, Str1IsBigger 
1363 7e			    LD     A, (HL) 
1364			 
1364			Str1IsBigger: 
1364 4f			    LD     C, A             ; Put length in BC 
1365 06 00		    LD     B, 0 
1367 13			    INC    DE              ; Increment pointers to meat of string. 
1368 23			    INC    HL 
1369			 
1369			CmpLoop: 
1369 1a			    LD     A, (DE)          ; Compare bytes. 
136a ed a1		    CPI 
136c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
136e 13			    INC    DE              ; Update pointer. 
136f ea 69 13		    JP     PE, CmpLoop 
1372			 
1372 d1			    POP    DE 
1373 e1			    POP    HL 
1374 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1375 be			    CP     (HL) 
1376 c9			    RET 
1377			 
1377			NoMatch: 
1377 2b			    DEC    HL 
1378 be			    CP     (HL)            ; Compare again to affect carry. 
1379 d1			    POP    DE 
137a e1			    POP    HL 
137b c9			    RET 
137c			 
137c			;; test strmp 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str2 
137c			;call strcmp 
137c			;jr z, .z1 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "NZ1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.z1: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "ZZ1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str1 
137c			;call strcmp 
137c			;jr z, .z2 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "NZ2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.z2: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "ZZ2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str2 
137c			;call strcmp 
137c			;jr c, .c1 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "Nc1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.c1: 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "cc1" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			; 
137c			;ld de, .str1 
137c			;ld hl, .str1 
137c			;call strcmp 
137c			;jr c, .c2 
137c			;;this 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "Nc2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;.c2: 
137c			; 
137c			;	if DEBUG_FORTH_WORDS 
137c			;		DMARK "cc2" 
137c			;		CALLMONITOR 
137c			;	endif 
137c			;	NEXTW 
137c			;.str1:   db "string1",0 
137c			;.str2:   db "string2",0 
137c			 
137c			; only care about direct match or not 
137c			; hl and de strings 
137c			; zero set if the same 
137c			 
137c			strcmp: 
137c 1a				ld a, (de) 
137d be				cp (hl) 
137e 28 02			jr z, .ssame 
1380 b7				or a 
1381 c9				ret 
1382			 
1382			.ssame:  
1382 fe 00			cp 0 
1384 c8				ret z 
1385			 
1385 23				inc hl 
1386 13				inc de 
1387 18 f3			jr strcmp 
1389				 
1389				 
1389			 
1389			;Copyright (c) 2014, Luke Maurits 
1389			;All rights reserved. 
1389			; 
1389			;Redistribution and use in source and binary forms, with or without 
1389			;modification, are permitted provided that the following conditions are met: 
1389			; 
1389			;* Redistributions of source code must retain the above copyright notice, this 
1389			;  list of conditions and the following disclaimer. 
1389			; 
1389			;* Redistributions in binary form must reproduce the above copyright notice, 
1389			;  this list of conditions and the following disclaimer in the documentation 
1389			;  and/or other materials provided with the distribution. 
1389			; 
1389			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
1389			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
1389			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
1389			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
1389			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
1389			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
1389			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
1389			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
1389			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
1389			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
1389			 
1389			; https://github.com/lmaurits/lm512/blob/master/string.z80 
1389			 
1389			StrictStrCmp: 
1389				; Load next chars of each string 
1389 1a				ld a, (de) 
138a 47				ld b, a 
138b 7e				ld a, (hl) 
138c				; Compare 
138c b8				cp b 
138d				; Return non-zero if chars don't match 
138d c0				ret nz 
138e				; Check for end of both strings 
138e fe 00			cp "\0" 
1390				; Return if strings have ended 
1390 c8				ret z 
1391				; Otherwise, advance to next chars 
1391 23				inc hl 
1392 13				inc de 
1393 18 f4			jr StrictStrCmp 
1395			 
1395			;end 
1395			; eof 
1395			 
1395			 
1395			 
1395			 
1395			 
1395			 
# End of file firmware_strings.asm
1395			include "firmware_memory.asm"   ; malloc and free  
1395			 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			.mallocsize: db "Wants malloc >256",0 
1395			.mallocasize: db "MALLOC gives >256",0 
1395			.malloczero: db "MALLOC gives zero",0 
1395			 
1395			malloc_guard_zerolen: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395				ld de, 0 
1395			        call cmp16 
1395				jr nz, .lowalloz 
1395			 
1395				push hl 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .malloczero 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395				call bp_on 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395			 
1395				pop de 
1395				pop hl 
1395			 
1395				 
1395			 
1395				CALLMONITOR 
1395			.lowalloz: 
1395			 
1395			 
1395				pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			 
1395			malloc_guard_entry: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395			 	or a      ;clear carry flag 
1395				push hl 
1395				ld de, 255 
1395				sbc hl, de 
1395				jr c, .lowalloc 
1395			 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .mallocsize 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395				call bp_on 
1395			 
1395				pop de 
1395				pop hl 
1395			 
1395				 
1395			 
1395				CALLMONITOR 
1395				jr .lowdone 
1395			.lowalloc: 
1395			 
1395			 
1395				pop hl 
1395			.lowdone:	pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			 
1395			malloc_guard_exit: 
1395				push hl 
1395				push de 
1395				push af 
1395			 
1395			 	or a      ;clear carry flag 
1395				push hl 
1395				ld de, 255 
1395				sbc hl, de 
1395				jr c, .lowallocx 
1395			 
1395				push de 
1395					ld hl, display_fb0 
1395					ld (display_fb_active), hl 
1395				call clear_display 
1395				ld a, 0 
1395				ld de, .mallocasize 
1395				call str_at_display 
1395				call update_display 
1395				call delay1s 
1395				call delay1s 
1395			;	ld a, 0 
1395			;	ld (os_view_disable), a 
1395				call bp_on 
1395				pop de 
1395				pop hl 
1395			 
1395				CALLMONITOR 
1395				jr .lowdonex 
1395			.lowallocx: 
1395			 
1395				pop hl 
1395			.lowdonex:	pop af 
1395				pop de 
1395				pop hl 
1395			ret 
1395			endif 
1395			 
1395			if MALLOC_2 
1395			; Z80 Malloc and Free Functions 
1395			 
1395			; Malloc Function: 
1395			; Input: 
1395			;   HL: Size of block to allocate 
1395			; Output: 
1395			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1395			 
1395			malloc: 
1395				 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			call malloc_guard_entry 
1395			endif 
1395			 
1395			 
1395			 
1395			 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "mal" 
1395						CALLMONITOR 
1395					endif 
1395			    push af            ; Save AF register 
1395			    ld a, l            ; Load low byte of size into A 
1395			    or h               ; Check if size is zero 
1395			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1395			 
1395			    ; Allocate memory 
1395			    ld hl, (heap_start) ; Load start of heap into HL 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma1" 
1395						CALLMONITOR 
1395					endif 
1395			    call malloc_internal ; Call internal malloc function 
1395			    pop af             ; Restore AF register 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret                ; Return 
1395			 
1395			; Free Function: 
1395			; Input: 
1395			;   HL: Pointer to memory block to free 
1395			; Output: 
1395			;   None 
1395			 
1395			free: 
1395			    push af            ; Save AF register 
1395			    ld a, l            ; Load low byte of pointer into A 
1395			    or h               ; Check if pointer is NULL 
1395			    jp z, free_exit    ; If pointer is NULL, exit 
1395			 
1395			    ; Free memory 
1395			    ld hl, (heap_start) ; Load start of heap into HL 
1395			    call free_internal  ; Call internal free function 
1395			    pop af             ; Restore AF register 
1395			    ret                ; Return 
1395			 
1395			; Internal Malloc Function: 
1395			; Input: 
1395			;   HL: Size of block to allocate 
1395			; Output: 
1395			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1395			 
1395			malloc_internal: 
1395			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1395			    add hl, bc         ; Add management overhead to requested size 
1395			    ex de, hl          ; Save total size in DE, and keep it in HL 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma2" 
1395						CALLMONITOR 
1395					endif 
1395			 
1395			    ; Search for free memory block 
1395			    ld de, (heap_end)  ; Load end of heap into DE 
1395			    ld bc, 0           ; Initialize counter 
1395			 
1395					if DEBUG_FORTH_MALLOC 
1395						DMARK "ma2" 
1395						CALLMONITOR 
1395					endif 
1395			malloc_search_loop: 
1395			    ; Check if current block is free 
1395			    ld a, (hl)         ; Load current block's status (free or used) 
1395			    cp 0               ; Compare with zero (free) 
1395			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1395			 
1395			    ; Check if current block is large enough 
1395			    ld a, (hl+1)       ; Load high byte of block size 
1395			    cp l               ; Compare with low byte of requested size 
1395			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1395			 
1395			    ld a, (hl+2)       ; Load low byte of block size 
1395			    cp h               ; Compare with high byte of requested size 
1395			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1395			 
1395			    ; Mark block as used 
1395			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1395			 
1395			    ; Calculate remaining space in block 
1395			    ld bc, 0           ; Clear BC 
1395			    add hl, bc         ; Increment HL to point to start of data block 
1395			    add hl, de         ; HL = HL + DE (total size) 
1395			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1395			    add hl, bc         ; Add management overhead to start of data block 
1395			 
1395			    ; Save pointer to allocated block in HL 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma5" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			 
1395			malloc_skip_block_check: 
1395			    ; Move to the next block 
1395			    ld bc, 3           ; Size of management overhead 
1395			    add hl, bc         ; Move to the next block 
1395			    inc de             ; Increment counter 
1395			 
1395			    ; Check if we have reached the end of heap 
1395			    ld a, e            ; Load low byte of heap end address 
1395			    cp (hl)            ; Compare with low byte of current address 
1395			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1395			    ld a, d            ; Load high byte of heap end address 
1395			    cp 0               ; Check if it's zero (end of memory) 
1395			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1395			 
1395			    ; If we reached here, allocation failed 
1395			    xor a              ; Set result to NULL 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma6" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			malloc_exit: 
1395			if DEBUG_FORTH_MALLOC_HIGH 
1395						DMARK "ma7" 
1395			call malloc_guard_exit 
1395			call malloc_guard_zerolen 
1395			endif 
1395			    ret 
1395			 
1395			; Internal Free Function: 
1395			; Input: 
1395			;   HL: Pointer to memory block to free 
1395			; Output: 
1395			;   None 
1395			 
1395			free_internal: 
1395			    ld de, (heap_start) ; Load start of heap into DE 
1395			    ld bc, 0            ; Initialize counter 
1395			 
1395			free_search_loop: 
1395			    ; Check if current block contains the pointer 
1395			    ld a, l             ; Load low byte of pointer 
1395			    cp (hl+1)           ; Compare with high byte of current block's address 
1395			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1395			    ld a, h             ; Load high byte of pointer 
1395			    cp (hl+2)           ; Compare with low byte of current block's address 
1395			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1395			 
1395			    ; Mark block as free 
1395			    ld (hl), 0          ; Set status byte to indicate free block 
1395			    ret                 ; Return 
1395			 
1395			free_skip_block_check: 
1395			    ; Move to the next block 
1395			    ld bc, 3            ; Size of management overhead 
1395			    add hl, bc          ; Move to the next block 
1395			    inc de              ; Increment counter 
1395			 
1395			    ; Check if we have reached the end of heap 
1395			    ld a, e             ; Load low byte of heap end address 
1395			    cp (hl)             ; Compare with low byte of current address 
1395			    jr nz, free_search_loop  ; If not equal, continue searching 
1395			    ld a, d             ; Load high byte of heap end address 
1395			    cp 0                ; Check if it's zero (end of memory) 
1395			    jr nz, free_search_loop  ; If not zero, continue searching 
1395			 
1395			    ; If we reached here, pointer is not found in heap 
1395			    ret 
1395			 
1395			free_exit: 
1395			    ret                 ; Return 
1395			 
1395			; Define heap start and end addresses 
1395			;heap_start:    .dw 0xC000   ; Start of heap 
1395			;heap_end:      .dw 0xE000   ; End of heap 
1395			 
1395			endif 
1395			 
1395			 
1395			if MALLOC_1 
1395			 
1395			 
1395			 
1395			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1395			 
1395			;moved to firmware.asm 
1395			;heap_start        .equ  0x9000      ; Starting address of heap 
1395			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1395			 
1395			;      .org 0 
1395			;      jp    main 
1395			 
1395			 
1395			;      .org  0x100 
1395			;main: 
1395			;      ld    HL, 0x8100 
1395			;      ld    SP, HL 
1395			; 
1395			;      call  heap_init 
1395			; 
1395			;      ; Make some allocations 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9004 
1395			; 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9014 
1395			; 
1395			;      ld    HL, 12 
1395			;      call  malloc            ; Allocates 0x9024 
1395			; 
1395			;      ; Free some allocations 
1395			;      ld    HL, 0x9014 
1395			;      call  free 
1395			; 
1395			;      ld    HL, 0x9004 
1395			;      call  free 
1395			; 
1395			;      ld    HL, 0x9024 
1395			;      call  free 
1395			; 
1395			; 
1395			;      halt 
1395			 
1395			 
1395			;------------------------------------------------------------------------------ 
1395			;     heap_init                                                               : 
1395			;                                                                             : 
1395			; Description                                                                 : 
1395			;     Initialise the heap and make it ready for malloc and free operations.   : 
1395			;                                                                             : 
1395			;     The heap is maintained as a linked list, starting with an initial       : 
1395			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1395			;     the first free block in the heap. Each block then points to the next    : 
1395			;     free block within the heap, and the free list ends at the first block   : 
1395			;     with a null pointer to the next free block.                             : 
1395			;                                                                             : 
1395			; Parameters                                                                  : 
1395			;     Inputs are compile-time only. Two defines which specify the starting    : 
1395			;     address of the heap and its size are required, along with a memory      : 
1395			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1395			;     principally stores a pointer to the first free block in the heap.       : 
1395			;                                                                             : 
1395			; Returns                                                                     : 
1395			;     Nothing                                                                 : 
1395			;------------------------------------------------------------------------------ 
1395			heap_init: 
1395 e5			      push  HL 
1396			 
1396			      ; Initialise free list struct 
1396 21 0e 80		      ld    HL, heap_start 
1399 22 0a 80		      ld    (free_list), HL 
139c 21 00 00		      ld    HL, 0 
139f 22 0c 80		      ld    (free_list+2), HL 
13a2			 
13a2			      ; Insert first free block at bottom of heap, consumes entire heap 
13a2 21 cd f0		      ld    HL, heap_start+heap_size-4 
13a5 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
13a8 21 bf 70		      ld    HL, heap_size-4 
13ab 22 10 80		      ld    (heap_start+2), HL      ; Block size 
13ae			 
13ae			      ; Insert end of free list block at top of heap - two null words will 
13ae			      ; terminate the free list 
13ae 21 00 00		      ld    HL, 0 
13b1 22 cf f0		      ld    (heap_start+heap_size-2), HL 
13b4 22 cd f0		      ld    (heap_start+heap_size-4), HL 
13b7			 
13b7 e1			      pop   HL 
13b8			 
13b8 c9			      ret 
13b9			 
13b9			 
13b9			;------------------------------------------------------------------------------ 
13b9			;     malloc                                                                  : 
13b9			;                                                                             : 
13b9			; Description                                                                 : 
13b9			;     Allocates the wanted space from the heap and returns the address of the : 
13b9			;     first useable byte of the allocation.                                   : 
13b9			;                                                                             : 
13b9			;     Allocations can happen in one of two ways:                              : 
13b9			;                                                                             : 
13b9			;     1. A free block may be found which is the exact size wanted. In this    : 
13b9			;        case the block is removed from the free list and retuedn to the      : 
13b9			;        caller.                                                              : 
13b9			;     2. A free block may be found which is larger than the size wanted. In   : 
13b9			;        this case, the larger block is split into two. The first portion of  : 
13b9			;        this block will become the requested space by the malloc call and    : 
13b9			;        is returned to the caller. The second portion becomes a new free     : 
13b9			;        block, and the free list is adjusted to maintain continuity via this : 
13b9			;        newly created block.                                                 : 
13b9			;                                                                             : 
13b9			;     malloc does not set any initial value in the allocated space, the       : 
13b9			;     caller is required to do this as required.                              : 
13b9			;                                                                             : 
13b9			;     This implementation of malloc uses the stack exclusively, and is        : 
13b9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
13b9			;     advisable to disable interrupts before calling malloc, and recommended  : 
13b9			;     to avoid the use of malloc inside ISRs in general.                      : 
13b9			;                                                                             : 
13b9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
13b9			;                                                                             : 
13b9			; Parameters                                                                  : 
13b9			;     HL  Number of bytes wanted                                              : 
13b9			;                                                                             : 
13b9			; Returns                                                                     : 
13b9			;     HL  Address of the first useable byte of the allocation                 : 
13b9			;                                                                             : 
13b9			; Flags                                                                       : 
13b9			;     Z   Set if the allocation did not succeed, clear otherwise              : 
13b9			;                                                                             : 
13b9			; Stack frame                                                                 : 
13b9			;       |             |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     BC      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     DE      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |     IX      |                                                       : 
13b9			;       +-------------+                                                       : 
13b9			;       |  prev_free  |                                                       : 
13b9			;   +4  +-------------+                                                       : 
13b9			;       |  this_free  |                                                       : 
13b9			;   +2  +-------------+                                                       : 
13b9			;       |  next_free  |                                                       : 
13b9			;   +0  +-------------+                                                       : 
13b9			;       |             |                                                       : 
13b9			;                                                                             : 
13b9			;------------------------------------------------------------------------------ 
13b9			 
13b9			 
13b9			;malloc: 
13b9			; 
13b9			;	SAVESP ON 1 
13b9			; 
13b9			;	call malloc_code 
13b9			; 
13b9			;	CHECKSP ON 1 
13b9			;	ret 
13b9			 
13b9			 
13b9			malloc: 
13b9 c5			      push  BC 
13ba d5			      push  DE 
13bb dd e5		      push  IX 
13bd			if DEBUG_FORTH_MALLOC_HIGH 
13bd			call malloc_guard_entry 
13bd			endif 
13bd			 
13bd					if DEBUG_FORTH_MALLOC 
13bd						DMARK "mal" 
13bd						CALLMONITOR 
13bd					endif 
13bd 7c			      ld    A, H                    ; Exit if no space requested 
13be b5			      or    L 
13bf ca 7e 14		      jp    Z, malloc_early_exit 
13c2			 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			; 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			;inc hl 
13c2			 
13c2			 
13c2			 
13c2			 
13c2					if DEBUG_FORTH_MALLOC 
13c2						DMARK "maA" 
13c2						CALLMONITOR 
13c2					endif 
13c2			      ; Set up stack frame 
13c2 eb			      ex    DE, HL 
13c3 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
13c6 39			      add   HL, SP 
13c7 f9			      ld    SP, HL 
13c8 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
13cc dd 39		      add   IX, SP 
13ce			 
13ce			      ; Setup initial state 
13ce 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
13d1 19			      add   HL, DE 
13d2			 
13d2 44			      ld    B, H                    ; Move want to BC 
13d3 4d			      ld    C, L 
13d4			 
13d4 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
13d7 dd 75 04		      ld    (IX+4), L 
13da dd 74 05		      ld    (IX+5), H 
13dd			 
13dd 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
13de 23			      inc   HL 
13df 56			      ld    D, (HL) 
13e0 dd 73 02		      ld    (IX+2), E 
13e3 dd 72 03		      ld    (IX+3), D 
13e6 eb			      ex    DE, HL                  ; this_free ptr into HL 
13e7			 
13e7					if DEBUG_FORTH_MALLOC 
13e7						DMARK "maB" 
13e7						CALLMONITOR 
13e7					endif 
13e7			      ; Loop through free block list to find some space 
13e7			malloc_find_space: 
13e7 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
13e8 23			      inc   HL 
13e9 56			      ld    D, (HL) 
13ea			 
13ea 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13eb b3			      or    E 
13ec ca 78 14		      jp    Z, malloc_no_space 
13ef			 
13ef dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
13f2 dd 72 01		      ld    (IX+1), D 
13f5			 
13f5			      ; Does this block have enough space to make the allocation? 
13f5 23			      inc   HL                      ; Load free block size into DE 
13f6 5e			      ld    E, (HL) 
13f7 23			      inc   HL 
13f8 56			      ld    D, (HL) 
13f9			 
13f9 eb			      ex    DE, HL                  ; Check size of block against want 
13fa b7			      or    A                       ; Ensure carry flag clear 
13fb ed 42		      sbc   HL, BC 
13fd e5			      push  HL                      ; Store the result for later (new block size) 
13fe			 
13fe ca 4d 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1401 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1403			 
1403			      ; this_free block is not big enough, setup ptrs to test next free block 
1403 e1			      pop   HL                      ; Discard previous result 
1404			 
1404 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1407 dd 66 03		      ld    H, (IX+3) 
140a dd 75 04		      ld    (IX+4), L 
140d dd 74 05		      ld    (IX+5), H 
1410			 
1410 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1413 dd 66 01		      ld    H, (IX+1) 
1416 dd 75 02		      ld    (IX+2), L 
1419 dd 74 03		      ld    (IX+3), H 
141c			 
141c					if DEBUG_FORTH_MALLOC 
141c						DMARK "MA>" 
141c						CALLMONITOR 
141c					endif 
141c 18 c9		      jr    malloc_find_space 
141e			 
141e			      ; split a bigger block into two - requested size and remaining size 
141e			malloc_alloc_split: 
141e					if DEBUG_FORTH_MALLOC 
141e						DMARK "MAs" 
141e						CALLMONITOR 
141e					endif 
141e eb			      ex    DE, HL                  ; Calculate address of new free block 
141f 2b			      dec   HL 
1420 2b			      dec   HL 
1421 2b			      dec   HL 
1422 09			      add   HL, BC 
1423			 
1423			      ; Create a new block and point it at next_free 
1423 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1426 dd 56 01		      ld    D, (IX+1) 
1429			 
1429 73			      ld    (HL), E                 ; Store next_free ptr into new block 
142a 23			      inc   HL 
142b 72			      ld    (HL), D 
142c			 
142c d1			      pop   DE                      ; Store size of new block into new block 
142d 23			      inc   HL 
142e 73			      ld    (HL), E 
142f 23			      inc   HL 
1430 72			      ld    (HL), D 
1431			 
1431			      ; Update this_free ptr to point to new block 
1431 2b			      dec   HL 
1432 2b			      dec   HL 
1433 2b			      dec   HL 
1434			 
1434 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1437 dd 56 03		      ld    D, (IX+3) 
143a			 
143a dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
143d dd 74 03		      ld    (IX+3), H 
1440			 
1440			      ; Modify this_free block to be allocation 
1440 eb			      ex    DE, HL 
1441 af			      xor   A                       ; Null the next block ptr of allocated block 
1442 77			      ld    (HL), A 
1443 23			      inc   HL 
1444 77			      ld    (HL), A 
1445			 
1445 23			      inc   HL                      ; Store want size into allocated block 
1446 71			      ld    (HL), C 
1447 23			      inc   HL 
1448 70			      ld    (HL), B 
1449 23			      inc   HL 
144a e5			      push  HL                      ; Address of allocation to return 
144b			 
144b 18 19		      jr    malloc_update_links 
144d			 
144d			malloc_alloc_fit: 
144d e1			      pop   HL                      ; Dont need new block size, want is exact fit 
144e			 
144e					if DEBUG_FORTH_MALLOC 
144e						DMARK "MAf" 
144e						CALLMONITOR 
144e					endif 
144e			      ; Modify this_free block to be allocation 
144e eb			      ex    DE, HL 
144f 2b			      dec   HL 
1450 2b			      dec   HL 
1451 2b			      dec   HL 
1452			 
1452 af			      xor   A                       ; Null the next block ptr of allocated block 
1453 77			      ld    (HL), A 
1454 23			      inc   HL 
1455 77			      ld    (HL), A 
1456			 
1456 23			      inc   HL                      ; Store address of allocation to return 
1457 23			      inc   HL 
1458 23			      inc   HL 
1459 e5			      push  HL 
145a			 
145a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
145a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
145d dd 66 01		      ld    H, (IX+1) 
1460			 
1460 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1463 dd 74 03		      ld    (IX+3), H 
1466			 
1466			 
1466			malloc_update_links: 
1466			      ; Update prev_free ptr to point to this_free 
1466 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1469 dd 66 05		      ld    H, (IX+5) 
146c			 
146c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
146f dd 56 03		      ld    D, (IX+3) 
1472			 
1472 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1473 23			      inc   HL 
1474 72			      ld    (HL), D 
1475			 
1475					if DEBUG_FORTH_MALLOC 
1475						DMARK "Mul" 
1475						CALLMONITOR 
1475					endif 
1475			      ; Clear the Z flag to indicate successful allocation 
1475 7a			      ld    A, D 
1476 b3			      or    E 
1477			 
1477 d1			      pop   DE                      ; Address of allocation 
1478					if DEBUG_FORTH_MALLOC 
1478						DMARK "MAu" 
1478						CALLMONITOR 
1478					endif 
1478			 
1478			malloc_no_space: 
1478 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
147b 39			      add   HL, SP 
147c f9			      ld    SP, HL 
147d			 
147d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
147e					if DEBUG_FORTH_MALLOC 
147e						DMARK "MAN" 
147e						CALLMONITOR 
147e					endif 
147e			 
147e			malloc_early_exit: 
147e					if DEBUG_FORTH_MALLOC 
147e						DMARK "MAx" 
147e						CALLMONITOR 
147e					endif 
147e dd e1		      pop   IX 
1480 d1			      pop   DE 
1481 c1			      pop   BC 
1482			 
1482			if DEBUG_FORTH_MALLOC_HIGH 
1482			call malloc_guard_exit 
1482			call malloc_guard_zerolen 
1482			endif 
1482 c9			      ret 
1483			 
1483			 
1483			;------------------------------------------------------------------------------ 
1483			;     free                                                                    : 
1483			;                                                                             : 
1483			; Description                                                                 : 
1483			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1483			;     returned by malloc, otherwise the behaviour is undefined.               : 
1483			;                                                                             : 
1483			;     Where possible, directly adjacent free blocks will be merged together   : 
1483			;     into larger blocks to help ensure that the heap does not become         : 
1483			;     excessively fragmented.                                                 : 
1483			;                                                                             : 
1483			;     free does not clear or set any other value into the freed space, and    : 
1483			;     therefore its contents may be visible through subsequent malloc's. The  : 
1483			;     caller should clear the freed space as required.                        : 
1483			;                                                                             : 
1483			;     This implementation of free uses the stack exclusively, and is          : 
1483			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1483			;     advisable to disable interrupts before calling free, and recommended    : 
1483			;     to avoid the use of free inside ISRs in general.                        : 
1483			;                                                                             : 
1483			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1483			;                                                                             : 
1483			; Parameters                                                                  : 
1483			;     HL  Pointer to address of first byte of allocation to be freed          : 
1483			;                                                                             : 
1483			; Returns                                                                     : 
1483			;     Nothing                                                                 : 
1483			;                                                                             : 
1483			; Stack frame                                                                 : 
1483			;       |             |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     BC      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     DE      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |     IX      |                                                       : 
1483			;       +-------------+                                                       : 
1483			;       |  prev_free  |                                                       : 
1483			;   +2  +-------------+                                                       : 
1483			;       |  next_free  |                                                       : 
1483			;   +0  +-------------+                                                       : 
1483			;       |             |                                                       : 
1483			;                                                                             : 
1483			;------------------------------------------------------------------------------ 
1483			free: 
1483 c5			      push  BC 
1484 d5			      push  DE 
1485 dd e5		      push  IX 
1487			 
1487 7c			      ld    A, H                    ; Exit if ptr is null 
1488 b5			      or    L 
1489 ca 4d 15		      jp    Z, free_early_exit 
148c			 
148c			      ; Set up stack frame 
148c eb			      ex    DE, HL 
148d 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1490 39			      add   HL, SP 
1491 f9			      ld    SP, HL 
1492 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1496 dd 39		      add   IX, SP 
1498			 
1498			      ; The address in HL points to the start of the useable allocated space, 
1498			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1498			      ; address of the block itself. 
1498 eb			      ex    DE, HL 
1499 11 fc ff		      ld    DE, -4 
149c 19			      add   HL, DE 
149d			 
149d			      ; An allocated block must have a null next block pointer in it 
149d 7e			      ld    A, (HL) 
149e 23			      inc   HL 
149f b6			      or    (HL) 
14a0 c2 48 15		      jp    NZ, free_done 
14a3			 
14a3 2b			      dec   HL 
14a4			 
14a4 44			      ld    B, H                    ; Copy HL to BC 
14a5 4d			      ld    C, L 
14a6			 
14a6			      ; Loop through the free list to find the first block with an address 
14a6			      ; higher than the block being freed 
14a6 21 0a 80		      ld    HL, free_list 
14a9			 
14a9			free_find_higher_block: 
14a9 5e			      ld    E, (HL)                 ; Load next ptr from free block 
14aa 23			      inc   HL 
14ab 56			      ld    D, (HL) 
14ac 2b			      dec   HL 
14ad			 
14ad dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
14b0 dd 72 01		      ld    (IX+1), D 
14b3 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
14b6 dd 74 03		      ld    (IX+3), H 
14b9			 
14b9 78			      ld    A, B                    ; Check if DE is greater than BC 
14ba ba			      cp    D                       ; Compare MSB first 
14bb 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
14bd 30 04		      jr    NC, free_find_higher_block_skip 
14bf 79			      ld    A, C 
14c0 bb			      cp    E                       ; Then compare LSB 
14c1 38 08		      jr    C, free_found_higher_block 
14c3			 
14c3			free_find_higher_block_skip: 
14c3 7a			      ld    A, D                    ; Reached the end of the free list? 
14c4 b3			      or    E 
14c5 ca 48 15		      jp    Z, free_done 
14c8			 
14c8 eb			      ex    DE, HL 
14c9			 
14c9 18 de		      jr    free_find_higher_block 
14cb			 
14cb			free_found_higher_block: 
14cb			      ; Insert freed block between prev and next free blocks 
14cb 71			      ld    (HL), C                 ; Point prev free block to freed block 
14cc 23			      inc   HL 
14cd 70			      ld    (HL), B 
14ce			 
14ce 60			      ld    H, B                    ; Point freed block at next free block 
14cf 69			      ld    L, C 
14d0 73			      ld    (HL), E 
14d1 23			      inc   HL 
14d2 72			      ld    (HL), D 
14d3			 
14d3			      ; Check if the freed block is adjacent to the next free block 
14d3 23			      inc   HL                      ; Load size of freed block into HL 
14d4 5e			      ld    E, (HL) 
14d5 23			      inc   HL 
14d6 56			      ld    D, (HL) 
14d7 eb			      ex    DE, HL 
14d8			 
14d8 09			      add   HL, BC                  ; Add addr of freed block and its size 
14d9			 
14d9 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
14dc dd 56 01		      ld    D, (IX+1) 
14df			 
14df b7			      or    A                       ; Clear the carry flag 
14e0 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
14e2 20 22		      jr    NZ, free_check_adjacent_to_prev 
14e4			 
14e4			      ; Freed block is adjacent to next, merge into one bigger block 
14e4 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
14e5 5e			      ld    E, (HL) 
14e6 23			      inc   HL 
14e7 56			      ld    D, (HL) 
14e8 e5			      push  HL                      ; Save ptr to next block for later 
14e9			 
14e9 60			      ld    H, B                    ; Store ptr from next block into freed block 
14ea 69			      ld    L, C 
14eb 73			      ld    (HL), E 
14ec 23			      inc   HL 
14ed 72			      ld    (HL), D 
14ee			 
14ee e1			      pop   HL                      ; Restore ptr to next block 
14ef 23			      inc   HL                      ; Load size of next block into DE 
14f0 5e			      ld    E, (HL) 
14f1 23			      inc   HL 
14f2 56			      ld    D, (HL) 
14f3 d5			      push  DE                      ; Save next block size for later 
14f4			 
14f4 60			      ld    H, B                    ; Load size of freed block into HL 
14f5 69			      ld    L, C 
14f6 23			      inc   HL 
14f7 23			      inc   HL 
14f8 5e			      ld    E, (HL) 
14f9 23			      inc   HL 
14fa 56			      ld    D, (HL) 
14fb eb			      ex    DE, HL 
14fc			 
14fc d1			      pop   DE                      ; Restore size of next block 
14fd 19			      add   HL, DE                  ; Add sizes of both blocks 
14fe eb			      ex    DE, HL 
14ff			 
14ff 60			      ld    H, B                    ; Store new bigger size into freed block 
1500 69			      ld    L, C 
1501 23			      inc   HL 
1502 23			      inc   HL 
1503 73			      ld    (HL), E 
1504 23			      inc   HL 
1505 72			      ld    (HL), D 
1506			 
1506			free_check_adjacent_to_prev: 
1506			      ; Check if the freed block is adjacent to the prev free block 
1506 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1509 dd 66 03		      ld    H, (IX+3) 
150c			 
150c 23			      inc   HL                      ; Size of prev free block into DE 
150d 23			      inc   HL 
150e 5e			      ld    E, (HL) 
150f 23			      inc   HL 
1510 56			      ld    D, (HL) 
1511 2b			      dec   HL 
1512 2b			      dec   HL 
1513 2b			      dec   HL 
1514			 
1514 19			      add   HL, DE                  ; Add prev block addr and size 
1515			 
1515 b7			      or    A                       ; Clear the carry flag 
1516 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1518 20 2e		      jr    NZ, free_done 
151a			 
151a			      ; Freed block is adjacent to prev, merge into one bigger block 
151a 60			      ld    H, B                    ; Load next ptr from freed block into DE 
151b 69			      ld    L, C 
151c 5e			      ld    E, (HL) 
151d 23			      inc   HL 
151e 56			      ld    D, (HL) 
151f e5			      push  HL                      ; Save freed block ptr for later 
1520			 
1520 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1523 dd 66 03		      ld    H, (IX+3) 
1526 73			      ld    (HL), E 
1527 23			      inc   HL 
1528 72			      ld    (HL), D 
1529			 
1529 e1			      pop   HL                      ; Restore freed block ptr 
152a 23			      inc   HL                      ; Load size of freed block into DE 
152b 5e			      ld    E, (HL) 
152c 23			      inc   HL 
152d 56			      ld    D, (HL) 
152e d5			      push  DE                      ; Save freed block size for later 
152f			 
152f dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1532 dd 66 03		      ld    H, (IX+3) 
1535 23			      inc   HL 
1536 23			      inc   HL 
1537 5e			      ld    E, (HL) 
1538 23			      inc   HL 
1539 56			      ld    D, (HL) 
153a			 
153a e1			      pop   HL                      ; Add sizes of both blocks 
153b 19			      add   HL, DE 
153c eb			      ex    DE, HL 
153d			 
153d dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1540 dd 66 03		      ld    H, (IX+3) 
1543 23			      inc   HL 
1544 23			      inc   HL 
1545 73			      ld    (HL), E 
1546 23			      inc   HL 
1547 72			      ld    (HL), D 
1548			 
1548			free_done: 
1548 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
154b 39			      add   HL, SP 
154c f9			      ld    SP, HL 
154d			 
154d			free_early_exit: 
154d dd e1		      pop   IX 
154f d1			      pop   DE 
1550 c1			      pop   BC 
1551			 
1551 c9			      ret 
1552			 
1552			; moved to firmware.asm 
1552			; 
1552			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1552			;                  .dw   0 
1552			 
1552			 
1552			endif 
1552			 
1552			 
1552			if MALLOC_3 
1552			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1552			;heap_start        .equ  0x9000      ; Starting address of heap 
1552			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1552			; 
1552			 ;     .org 0 
1552			  ;    jp    main 
1552			; 
1552			; 
1552			 ;     .org  0x100 
1552			;main: 
1552			 ;     ld    HL, 0x8100 
1552			  ;    ld    SP, HL 
1552			; 
1552			;      call  heap_init 
1552			 
1552			      ; Make some allocations 
1552			;      ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9004 
1552			; 
1552			 ;     ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9014 
1552			 
1552			;      ld    HL, 12 
1552			;      call  malloc            ; Allocates 0x9024 
1552			 
1552			      ; Free some allocations 
1552			;      ld    HL, 0x9014 
1552			;      call  free 
1552			 
1552			;      ld    HL, 0x9004 
1552			;      call  free 
1552			; 
1552			;      ld    HL, 0x9024 
1552			;      call  free 
1552			 
1552			 
1552			 ;     halt 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     heap_init                                                               : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Initialise the heap and make it ready for malloc and free operations.   : 
1552			;                                                                             : 
1552			;     The heap is maintained as a linked list, starting with an initial       : 
1552			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1552			;     the first free block in the heap. Each block then points to the next    : 
1552			;     free block within the heap, and the free list ends at the first block   : 
1552			;     with a null pointer to the next free block.                             : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     Inputs are compile-time only. Two defines which specify the starting    : 
1552			;     address of the heap and its size are required, along with a memory      : 
1552			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1552			;     principally stores a pointer to the first free block in the heap.       : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     Nothing                                                                 : 
1552			;------------------------------------------------------------------------------ 
1552			heap_init: 
1552			      push  HL 
1552			 
1552			      ; Initialise free list struct 
1552			      ld    HL, heap_start 
1552			      ld    (free_list), HL 
1552			      ld    HL, 0 
1552			      ld    (free_list+2), HL 
1552			 
1552			      ; Insert first free block at bottom of heap, consumes entire heap 
1552			      ld    HL, heap_start+heap_size-4 
1552			      ld    (heap_start), HL        ; Next block (end of free list) 
1552			      ld    HL, heap_size-4 
1552			      ld    (heap_start+2), HL      ; Block size 
1552			 
1552			      ; Insert end of free list block at top of heap - two null words will 
1552			      ; terminate the free list 
1552			      ld    HL, 0 
1552			      ld    (heap_start+heap_size-2), HL 
1552			      ld    (heap_start+heap_size-4), HL 
1552			 
1552			      pop   HL 
1552			 
1552			      ret 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     malloc                                                                  : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Allocates the wanted space from the heap and returns the address of the : 
1552			;     first useable byte of the allocation.                                   : 
1552			;                                                                             : 
1552			;     Allocations can happen in one of two ways:                              : 
1552			;                                                                             : 
1552			;     1. A free block may be found which is the exact size wanted. In this    : 
1552			;        case the block is removed from the free list and retuedn to the      : 
1552			;        caller.                                                              : 
1552			;     2. A free block may be found which is larger than the size wanted. In   : 
1552			;        this case, the larger block is split into two. The first portion of  : 
1552			;        this block will become the requested space by the malloc call and    : 
1552			;        is returned to the caller. The second portion becomes a new free     : 
1552			;        block, and the free list is adjusted to maintain continuity via this : 
1552			;        newly created block.                                                 : 
1552			;                                                                             : 
1552			;     malloc does not set any initial value in the allocated space, the       : 
1552			;     caller is required to do this as required.                              : 
1552			;                                                                             : 
1552			;     This implementation of malloc uses the stack exclusively, and is        : 
1552			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1552			;     advisable to disable interrupts before calling malloc, and recommended  : 
1552			;     to avoid the use of malloc inside ISRs in general.                      : 
1552			;                                                                             : 
1552			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     HL  Number of bytes wanted                                              : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     HL  Address of the first useable byte of the allocation                 : 
1552			;                                                                             : 
1552			; Flags                                                                       : 
1552			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1552			;                                                                             : 
1552			; Stack frame                                                                 : 
1552			;       |             |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     BC      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     DE      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     IX      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |  prev_free  |                                                       : 
1552			;   +4  +-------------+                                                       : 
1552			;       |  this_free  |                                                       : 
1552			;   +2  +-------------+                                                       : 
1552			;       |  next_free  |                                                       : 
1552			;   +0  +-------------+                                                       : 
1552			;       |             |                                                       : 
1552			;                                                                             : 
1552			;------------------------------------------------------------------------------ 
1552			malloc: 
1552			      push  BC 
1552			      push  DE 
1552			      push  IX 
1552			 
1552			      ld    A, H                    ; Exit if no space requested 
1552			      or    L 
1552			      jp    Z, malloc_early_exit 
1552			 
1552			      ; Set up stack frame 
1552			      ex    DE, HL 
1552			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			      ld    IX, 0                   ; Use IX as a frame pointer 
1552			      add   IX, SP 
1552			 
1552			      ; Setup initial state 
1552			      ld    HL, 4                   ; want must also include space used by block struct 
1552			      add   HL, DE 
1552			 
1552			      ld    B, H                    ; Move want to BC 
1552			      ld    C, L 
1552			 
1552			      ld    HL, free_list           ; Store prev_free ptr to stack 
1552			      ld    (IX+4), L 
1552			      ld    (IX+5), H 
1552			 
1552			      ld    E, (HL)                 ; Store this_free ptr to stack 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ld    (IX+2), E 
1552			      ld    (IX+3), D 
1552			      ex    DE, HL                  ; this_free ptr into HL 
1552			 
1552			      ; Loop through free block list to find some space 
1552			malloc_find_space: 
1552			      ld    E, (HL)                 ; Load next_free ptr into DE 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1552			      or    E 
1552			      jp    Z, malloc_no_space 
1552			 
1552			      ld    (IX+0), E               ; Store next_free ptr to stack 
1552			      ld    (IX+1), D 
1552			 
1552			      ; Does this block have enough space to make the allocation? 
1552			      inc   HL                      ; Load free block size into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      ex    DE, HL                  ; Check size of block against want 
1552			      or    A                       ; Ensure carry flag clear 
1552			      sbc   HL, BC 
1552			      push  HL                      ; Store the result for later (new block size) 
1552			 
1552			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1552			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1552			 
1552			      ; this_free block is not big enough, setup ptrs to test next free block 
1552			      pop   HL                      ; Discard previous result 
1552			 
1552			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1552			      ld    H, (IX+3) 
1552			      ld    (IX+4), L 
1552			      ld    (IX+5), H 
1552			 
1552			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1552			      ld    H, (IX+1) 
1552			      ld    (IX+2), L 
1552			      ld    (IX+3), H 
1552			 
1552			      jr    malloc_find_space 
1552			 
1552			      ; split a bigger block into two - requested size and remaining size 
1552			malloc_alloc_split: 
1552			      ex    DE, HL                  ; Calculate address of new free block 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			      add   HL, BC 
1552			 
1552			      ; Create a new block and point it at next_free 
1552			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1552			      ld    D, (IX+1) 
1552			 
1552			      ld    (HL), E                 ; Store next_free ptr into new block 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   DE                      ; Store size of new block into new block 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Update this_free ptr to point to new block 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1552			      ld    D, (IX+3) 
1552			 
1552			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1552			      ld    (IX+3), H 
1552			 
1552			      ; Modify this_free block to be allocation 
1552			      ex    DE, HL 
1552			      xor   A                       ; Null the next block ptr of allocated block 
1552			      ld    (HL), A 
1552			      inc   HL 
1552			      ld    (HL), A 
1552			 
1552			      inc   HL                      ; Store want size into allocated block 
1552			      ld    (HL), C 
1552			      inc   HL 
1552			      ld    (HL), B 
1552			      inc   HL 
1552			      push  HL                      ; Address of allocation to return 
1552			 
1552			      jr    malloc_update_links 
1552			 
1552			malloc_alloc_fit: 
1552			      pop   HL                      ; Dont need new block size, want is exact fit 
1552			 
1552			      ; Modify this_free block to be allocation 
1552			      ex    DE, HL 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      xor   A                       ; Null the next block ptr of allocated block 
1552			      ld    (HL), A 
1552			      inc   HL 
1552			      ld    (HL), A 
1552			 
1552			      inc   HL                      ; Store address of allocation to return 
1552			      inc   HL 
1552			      inc   HL 
1552			      push  HL 
1552			 
1552			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1552			      ld    L, (IX+0)               ; next_free to HL 
1552			      ld    H, (IX+1) 
1552			 
1552			      ld    (IX+2), L               ; HL to this_free 
1552			      ld    (IX+3), H 
1552			 
1552			 
1552			malloc_update_links: 
1552			      ; Update prev_free ptr to point to this_free 
1552			      ld    L, (IX+4)               ; prev_free ptr to HL 
1552			      ld    H, (IX+5) 
1552			 
1552			      ld    E, (IX+2)               ; this_free ptr to DE 
1552			      ld    D, (IX+3) 
1552			 
1552			      ld    (HL), E                 ; this_free ptr into prev_free 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Clear the Z flag to indicate successful allocation 
1552			      ld    A, D 
1552			      or    E 
1552			 
1552			      pop   DE                      ; Address of allocation 
1552			 
1552			malloc_no_space: 
1552			      ld    HL, 6                   ; Clean up stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			 
1552			      ex    DE, HL                  ; Alloc addr into HL for return 
1552			 
1552			malloc_early_exit: 
1552			      pop   IX 
1552			      pop   DE 
1552			      pop   BC 
1552			 
1552			      ret 
1552			 
1552			 
1552			;------------------------------------------------------------------------------ 
1552			;     free                                                                    : 
1552			;                                                                             : 
1552			; Description                                                                 : 
1552			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1552			;     returned by malloc, otherwise the behaviour is undefined.               : 
1552			;                                                                             : 
1552			;     Where possible, directly adjacent free blocks will be merged together   : 
1552			;     into larger blocks to help ensure that the heap does not become         : 
1552			;     excessively fragmented.                                                 : 
1552			;                                                                             : 
1552			;     free does not clear or set any other value into the freed space, and    : 
1552			;     therefore its contents may be visible through subsequent malloc's. The  : 
1552			;     caller should clear the freed space as required.                        : 
1552			;                                                                             : 
1552			;     This implementation of free uses the stack exclusively, and is          : 
1552			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1552			;     advisable to disable interrupts before calling free, and recommended    : 
1552			;     to avoid the use of free inside ISRs in general.                        : 
1552			;                                                                             : 
1552			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1552			;                                                                             : 
1552			; Parameters                                                                  : 
1552			;     HL  Pointer to address of first byte of allocation to be freed          : 
1552			;                                                                             : 
1552			; Returns                                                                     : 
1552			;     Nothing                                                                 : 
1552			;                                                                             : 
1552			; Stack frame                                                                 : 
1552			;       |             |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     BC      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     DE      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |     IX      |                                                       : 
1552			;       +-------------+                                                       : 
1552			;       |  prev_free  |                                                       : 
1552			;   +2  +-------------+                                                       : 
1552			;       |  next_free  |                                                       : 
1552			;   +0  +-------------+                                                       : 
1552			;       |             |                                                       : 
1552			;                                                                             : 
1552			;------------------------------------------------------------------------------ 
1552			free: 
1552			      push  BC 
1552			      push  DE 
1552			      push  IX 
1552			 
1552			      ld    A, H                    ; Exit if ptr is null 
1552			      or    L 
1552			      jp    Z, free_early_exit 
1552			 
1552			      ; Set up stack frame 
1552			      ex    DE, HL 
1552			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			      ld    IX, 0                   ; Use IX as a frame pointer 
1552			      add   IX, SP 
1552			 
1552			      ; The address in HL points to the start of the useable allocated space, 
1552			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1552			      ; address of the block itself. 
1552			      ex    DE, HL 
1552			      ld    DE, -4 
1552			      add   HL, DE 
1552			 
1552			      ; An allocated block must have a null next block pointer in it 
1552			      ld    A, (HL) 
1552			      inc   HL 
1552			      or    (HL) 
1552			      jp    NZ, free_done 
1552			 
1552			      dec   HL 
1552			 
1552			      ld    B, H                    ; Copy HL to BC 
1552			      ld    C, L 
1552			 
1552			      ; Loop through the free list to find the first block with an address 
1552			      ; higher than the block being freed 
1552			      ld    HL, free_list 
1552			 
1552			free_find_higher_block: 
1552			      ld    E, (HL)                 ; Load next ptr from free block 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      dec   HL 
1552			 
1552			      ld    (IX+0), E               ; Save ptr to next free block 
1552			      ld    (IX+1), D 
1552			      ld    (IX+2), L               ; Save ptr to prev free block 
1552			      ld    (IX+3), H 
1552			 
1552			      ld    A, B                    ; Check if DE is greater than BC 
1552			      cp    D                       ; Compare MSB first 
1552			      jr    Z, $+4                  ; MSB the same, compare LSB 
1552			      jr    NC, free_find_higher_block_skip 
1552			      ld    A, C 
1552			      cp    E                       ; Then compare LSB 
1552			      jr    C, free_found_higher_block 
1552			 
1552			free_find_higher_block_skip: 
1552			      ld    A, D                    ; Reached the end of the free list? 
1552			      or    E 
1552			      jp    Z, free_done 
1552			 
1552			      ex    DE, HL 
1552			 
1552			      jr    free_find_higher_block 
1552			 
1552			free_found_higher_block: 
1552			      ; Insert freed block between prev and next free blocks 
1552			      ld    (HL), C                 ; Point prev free block to freed block 
1552			      inc   HL 
1552			      ld    (HL), B 
1552			 
1552			      ld    H, B                    ; Point freed block at next free block 
1552			      ld    L, C 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      ; Check if the freed block is adjacent to the next free block 
1552			      inc   HL                      ; Load size of freed block into HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ex    DE, HL 
1552			 
1552			      add   HL, BC                  ; Add addr of freed block and its size 
1552			 
1552			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1552			      ld    D, (IX+1) 
1552			 
1552			      or    A                       ; Clear the carry flag 
1552			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1552			      jr    NZ, free_check_adjacent_to_prev 
1552			 
1552			      ; Freed block is adjacent to next, merge into one bigger block 
1552			      ex    DE, HL                  ; Load next ptr from next block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  HL                      ; Save ptr to next block for later 
1552			 
1552			      ld    H, B                    ; Store ptr from next block into freed block 
1552			      ld    L, C 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   HL                      ; Restore ptr to next block 
1552			      inc   HL                      ; Load size of next block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  DE                      ; Save next block size for later 
1552			 
1552			      ld    H, B                    ; Load size of freed block into HL 
1552			      ld    L, C 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      ex    DE, HL 
1552			 
1552			      pop   DE                      ; Restore size of next block 
1552			      add   HL, DE                  ; Add sizes of both blocks 
1552			      ex    DE, HL 
1552			 
1552			      ld    H, B                    ; Store new bigger size into freed block 
1552			      ld    L, C 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			free_check_adjacent_to_prev: 
1552			      ; Check if the freed block is adjacent to the prev free block 
1552			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1552			      ld    H, (IX+3) 
1552			 
1552			      inc   HL                      ; Size of prev free block into DE 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      dec   HL 
1552			      dec   HL 
1552			      dec   HL 
1552			 
1552			      add   HL, DE                  ; Add prev block addr and size 
1552			 
1552			      or    A                       ; Clear the carry flag 
1552			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1552			      jr    NZ, free_done 
1552			 
1552			      ; Freed block is adjacent to prev, merge into one bigger block 
1552			      ld    H, B                    ; Load next ptr from freed block into DE 
1552			      ld    L, C 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  HL                      ; Save freed block ptr for later 
1552			 
1552			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1552			      ld    H, (IX+3) 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			      pop   HL                      ; Restore freed block ptr 
1552			      inc   HL                      ; Load size of freed block into DE 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			      push  DE                      ; Save freed block size for later 
1552			 
1552			      ld    L, (IX+2)               ; Load size of prev block into DE 
1552			      ld    H, (IX+3) 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    E, (HL) 
1552			      inc   HL 
1552			      ld    D, (HL) 
1552			 
1552			      pop   HL                      ; Add sizes of both blocks 
1552			      add   HL, DE 
1552			      ex    DE, HL 
1552			 
1552			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1552			      ld    H, (IX+3) 
1552			      inc   HL 
1552			      inc   HL 
1552			      ld    (HL), E 
1552			      inc   HL 
1552			      ld    (HL), D 
1552			 
1552			free_done: 
1552			      ld    HL, 4                   ; Clean up stack frame 
1552			      add   HL, SP 
1552			      ld    SP, HL 
1552			 
1552			free_early_exit: 
1552			      pop   IX 
1552			      pop   DE 
1552			      pop   BC 
1552			 
1552			      ret 
1552			 
1552			 
1552			;      .org 0x8000 
1552			; 
1552			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1552			 ;                 .dw   0 
1552			 
1552			endif 
1552			 
1552			 
1552			if MALLOC_4 
1552			 
1552			; My memory allocation code. Very very simple.... 
1552			; allocate space under 250 chars 
1552			 
1552			heap_init: 
1552				; init start of heap as zero 
1552				;  
1552			 
1552				ld hl, heap_start 
1552				ld a, 0 
1552				ld (hl), a      ; empty block 
1552				inc hl 
1552				ld a, 0 
1552				ld (hl), a      ; length of block 
1552				; write end of list 
1552				inc hl 
1552				ld a,(hl) 
1552				inc hl 
1552				ld a,(hl) 
1552				 
1552			 
1552				; init some malloc vars 
1552			 
1552				ld hl, 0 
1552				ld (free_list), hl       ; store last malloc location 
1552			 
1552				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1552				ld a, 0 
1552				ld (hl), a 
1552			 
1552			 
1552				ld hl, heap_start 
1552				;  
1552				  
1552				ret 
1552			 
1552			 
1552			;    free block marker 
1552			;    requested size  
1552			;    pointer to next block 
1552			;    .... 
1552			;    next block marker 
1552			 
1552			 
1552			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1552			; 
1552			 
1552			 
1552			malloc:  
1552				push de 
1552				push bc 
1552				push af 
1552			 
1552				; hl space required 
1552				 
1552				ld c, l    ; hold space   (TODO only a max of 255) 
1552			 
1552			;	inc c     ; TODO BUG need to fix memory leak on push str 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			;	inc c 
1552			 
1552			 
1552			 
1552				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1552			 
1552				ld a, (free_list+3) 
1552				cp 0 
1552				jr z, .contheap 
1552			 
1552				ld hl, (free_list)     ; get last alloc 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mrs" 
1552						CALLMONITOR 
1552					endif 
1552				jr .startalloc 
1552			 
1552			.contheap: 
1552				ld hl, heap_start 
1552			 
1552			.startalloc: 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mym" 
1552						CALLMONITOR 
1552					endif 
1552			.findblock: 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mmf" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552				ld a,(hl)  
1552				; if byte is zero then clear to use 
1552			 
1552				cp 0 
1552				jr z, .foundemptyblock 
1552			 
1552				; if byte is not clear 
1552				;     then byte is offset to next block 
1552			 
1552				inc hl 
1552				ld a, (hl) ; get size 
1552			.nextblock:	inc hl 
1552					ld e, (hl) 
1552					inc hl 
1552					ld d, (hl) 
1552					ex de, hl 
1552			;	inc hl  ; move past the store space 
1552			;	inc hl  ; move past zero index  
1552			 
1552				; TODO detect no more space 
1552			 
1552				push hl 
1552				ld de, heap_end 
1552				call cmp16 
1552				pop hl 
1552				jr nc, .nospace 
1552			 
1552				jr .findblock 
1552			 
1552			.nospace: ld hl, 0 
1552				jp .exit 
1552			 
1552			 
1552			.foundemptyblock:	 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mme" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			; TODO has block enough space if reusing??? 
1552			 
1552				;  
1552			 
1552			; see if this block has been previously used 
1552				inc hl 
1552				ld a, (hl) 
1552				dec hl 
1552				cp 0 
1552				jr z, .newblock 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "meR" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			; no reusing previously allocated block 
1552			 
1552			; is it smaller than previously used? 
1552				 
1552				inc hl    ; move to size 
1552				ld a, c 
1552				sub (hl)        ; we want c < (hl) 
1552				dec hl    ; move back to marker 
1552			        jr z, .findblock 
1552			 
1552				; update with the new size which should be lower 
1552			 
1552			        ;inc  hl   ; negate next move. move back to size  
1552			 
1552			.newblock: 
1552				; need to be at marker here 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "meN" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			 
1552				ld a, c 
1552			 
1552				ld (free_list+3), a	 ; flag resume from last malloc  
1552				ld (free_list), hl    ; save out last location 
1552			 
1552			 
1552				;inc a     ; space for length byte 
1552				ld (hl), a     ; save block in use marker 
1552			 
1552				inc hl   ; move to space marker 
1552				ld (hl), a    ; save new space 
1552			 
1552				inc hl   ; move to start of allocated area 
1552				 
1552			;	push hl     ; save where we are - 1  
1552			 
1552			;	inc hl  ; move past zero index  
1552				; skip space to set down new marker 
1552			 
1552				; provide some extra space for now 
1552			 
1552				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1552				inc a 
1552				inc a 
1552			 
1552				push hl   ; save where we are in the node block 
1552			 
1552				call addatohl 
1552			 
1552				; write linked list point 
1552			 
1552				pop de     ; get our node position 
1552				ex de, hl 
1552			 
1552				ld (hl), e 
1552				inc hl 
1552				ld (hl), d 
1552			 
1552				inc hl 
1552			 
1552				; now at start of allocated data so save pointer 
1552			 
1552				push hl 
1552			 
1552				; jump to position of next node and setup empty header in DE 
1552			 
1552				ex de, hl 
1552			 
1552			;	inc hl ; move past end of block 
1552			 
1552				ld a, 0 
1552				ld (hl), a   ; empty marker 
1552				inc hl 
1552				ld (hl), a   ; size 
1552				inc hl  
1552				ld (hl), a   ; ptr 
1552				inc hl 
1552				ld (hl), a   ; ptr 
1552			 
1552			 
1552				pop hl 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "mmr" 
1552						CALLMONITOR 
1552					endif 
1552			 
1552			.exit: 
1552				pop af 
1552				pop bc 
1552				pop de  
1552				ret 
1552			 
1552			 
1552			 
1552			 
1552			free:  
1552				push hl 
1552				push af 
1552				; get address in hl 
1552			 
1552					if DEBUG_FORTH_MALLOC_INT 
1552						DMARK "fre" 
1552						CALLMONITOR 
1552					endif 
1552				; data is at hl - move to block count 
1552				dec hl 
1552				dec hl    ; get past pointer 
1552				dec hl 
1552			 
1552				ld a, (hl)    ; need this for a validation check 
1552			 
1552				dec hl    ; move to block marker 
1552			 
1552				; now check that the block count and block marker are the same  
1552			        ; this checks that we are on a malloc node and not random memory 
1552			        ; OK a faint chance this could be a problem but rare - famous last words! 
1552			 
1552				ld c, a 
1552				ld a, (hl)    
1552			 
1552				cp c 
1552				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1552			 
1552				; yes good chance we are on a malloc node 
1552			 
1552				ld a, 0      
1552				ld (hl), a   ; mark as free 
1552			 
1552				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1552			 
1552			.freeignore:  
1552			 
1552				pop af 
1552				pop hl 
1552			 
1552				ret 
1552			 
1552			 
1552			 
1552			endif 
1552			 
1552			; eof 
# End of file firmware_memory.asm
1552			  
1552			; device C  
1552			; Now handled by SPI  
1552			;if SOUND_ENABLE  
1552			;	include "firmware_sound.asm"  
1552			;endif  
1552			  
1552			include "firmware_diags.asm"  
1552			; Hardware diags menu 
1552			 
1552			 
1552			config: 
1552			 
1552 3e 00			ld a, 0 
1554 21 7d 15			ld hl, .configmn 
1557 cd db 0d			call menu 
155a			 
155a fe 00			cp 0 
155c c8				ret z 
155d			 
155d			;	cp 1 
155d			;	call z, .savetostore 
155d			 
155d fe 01			cp 1 
155f			if STARTUP_V1 
155f				call z, .selautoload 
155f			endif 
155f			 
155f			if STARTUP_V2 
155f cc 8b 15			call z, .enautoload 
1562			endif 
1562 fe 02			cp 2 
1564 cc a2 15			call z, .disautoload 
1567			;	cp 3 
1567			;	call z, .selbank 
1567 fe 03			cp 3 
1569 cc 0d 18			call z, .debug_tog 
156c fe 04			cp 4 
156e cc 5b 19			call z, .bpsgo 
1571 fe 05			cp 5 
1573 cc 36 18			call z, hardware_diags 
1576			if STARTUP_V2 
1576 fe 06			cp 6 
1578 cc ce 15			call z, create_startup 
157b			endif 
157b 18 d5			jr config 
157d			 
157d			.configmn: 
157d			;	dw prom_c3 
157d 49 1b			dw prom_c2 
157f 5f 1b			dw prom_c2a 
1581			;	dw prom_c2b 
1581			;	dw prom_c4 
1581 d6 1b			dw prom_m4 
1583 f1 1b			dw prom_m4b 
1585 f9 1b			dw prom_c1 
1587			if STARTUP_V2 
1587 08 1c			dw prom_c9 
1589			endif 
1589 00 00			dw 0 
158b				 
158b			 
158b			if STARTUP_V2 
158b			.enautoload: 
158b				if STORAGE_SE 
158b 3e fe			ld a, $fe      ; bit 0 clear 
158d 32 95 f9			ld (spi_device), a 
1590			 
1590 cd 25 05			call storage_get_block_0 
1593			 
1593 3e 01			ld a, 1 
1595 32 d0 f9			ld (store_page+STORE_0_AUTOFILE), a 
1598			 
1598 21 00 00				ld hl, 0 
159b 11 af f9				ld de, store_page 
159e cd d9 04			call storage_write_block	 ; save update 
15a1				else 
15a1			 
15a1				ld hl, prom_notav 
15a1				ld de, prom_empty 
15a1				call info_panel 
15a1				endif 
15a1			 
15a1			 
15a1 c9				ret 
15a2			endif 
15a2			 
15a2			.disautoload: 
15a2				if STORAGE_SE 
15a2 3e fe			ld a, $fe      ; bit 0 clear 
15a4 32 95 f9			ld (spi_device), a 
15a7			 
15a7 cd 25 05			call storage_get_block_0 
15aa			 
15aa 3e 00			ld a, 0 
15ac 32 d0 f9			ld (store_page+STORE_0_AUTOFILE), a 
15af			 
15af 21 00 00				ld hl, 0 
15b2 11 af f9				ld de, store_page 
15b5 cd d9 04			call storage_write_block	 ; save update 
15b8				else 
15b8			 
15b8				ld hl, prom_notav 
15b8				ld de, prom_empty 
15b8				call info_panel 
15b8				endif 
15b8			 
15b8			 
15b8 c9				ret 
15b9			 
15b9			if STARTUP_V1 
15b9			 
15b9			; Select auto start 
15b9			 
15b9			.selautoload: 
15b9			 
15b9				 
15b9				if STORAGE_SE 
15b9			 
15b9					call config_dir 
15b9				        ld hl, scratch 
15b9					ld a, 0 
15b9					call menu 
15b9			 
15b9					cp 0 
15b9					ret z 
15b9			 
15b9					dec a 
15b9			 
15b9			 
15b9					; locate menu option 
15b9			 
15b9					ld hl, scratch 
15b9					call table_lookup 
15b9			 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "ALl" 
15b9						CALLMONITOR 
15b9					endif 
15b9					; with the pointer to the menu it, the byte following the zero term is the file id 
15b9			 
15b9					ld a, 0 
15b9					ld bc, 50   ; max of bytes to look at 
15b9					cpir  
15b9			 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "ALb" 
15b9						CALLMONITOR 
15b9					endif 
15b9					;inc hl 
15b9			 
15b9					ld a, (hl)   ; file id 
15b9					 
15b9				        ; save bank and file ids 
15b9			 
15b9					push af 
15b9			 
15b9			; TODO need to save to block 0 on bank 1	 
15b9			 
15b9					call storage_get_block_0 
15b9			 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "AL0" 
15b9						CALLMONITOR 
15b9					endif 
15b9					pop af 
15b9			 
15b9					ld (store_page+STORE_0_FILERUN),a 
15b9					 
15b9					; save bank id 
15b9			 
15b9					ld a,(spi_device) 
15b9					ld (store_page+STORE_0_BANKRUN),a 
15b9			 
15b9					; enable auto run of store file 
15b9			 
15b9					ld a, 1 
15b9					ld (store_page+STORE_0_AUTOFILE),a 
15b9			 
15b9					; save buffer 
15b9			 
15b9					ld hl, 0 
15b9					ld de, store_page 
15b9					if DEBUG_FORTH_WORDS 
15b9						DMARK "ALw" 
15b9						CALLMONITOR 
15b9					endif 
15b9				call storage_write_block	 ; save update 
15b9			  
15b9			 
15b9			 
15b9			 
15b9					ld hl, scratch 
15b9					call config_fdir 
15b9			 
15b9				else 
15b9			 
15b9				ld hl, prom_notav 
15b9				ld de, prom_empty 
15b9				call info_panel 
15b9			 
15b9				endif 
15b9				ret 
15b9			endif 
15b9			 
15b9			 
15b9			; Select storage bank 
15b9			 
15b9			.selbank: 
15b9			 
15b9			;	if STORAGE_SE 
15b9			;	else 
15b9			 
15b9 21 1d 1c			ld hl, prom_notav 
15bc 11 33 1c			ld de, prom_empty 
15bf cd 3b 0d			call info_panel 
15c2			;	endif 
15c2				 
15c2 c9				ret 
15c3			 
15c3			if STORAGE_SE 
15c3			 
15c3			.config_ldir:   
15c3				; Load storage bank labels into menu array 
15c3			 
15c3				 
15c3			 
15c3			 
15c3 c9				ret 
15c4			 
15c4			 
15c4			endif 
15c4			 
15c4			 
15c4			; Save user words to storage 
15c4			 
15c4			.savetostore: 
15c4			 
15c4			;	if STORAGE_SE 
15c4			; 
15c4			;		call config_dir 
15c4			;	        ld hl, scratch 
15c4			;		ld a, 0 
15c4			;		call menu 
15c4			;		 
15c4			;		ld hl, scratch 
15c4			;		call config_fdir 
15c4			; 
15c4			;	else 
15c4			 
15c4 21 1d 1c			ld hl, prom_notav 
15c7 11 33 1c			ld de, prom_empty 
15ca cd 3b 0d			call info_panel 
15cd			 
15cd			;	endif 
15cd			 
15cd c9				ret 
15ce			 
15ce			if STARTUP_V2 
15ce			 
15ce			create_startup: 
15ce			 
15ce 3e 00			ld a, 0 
15d0 21 32 17			ld hl, .crstart 
15d3 cd db 0d			call menu 
15d6			 
15d6 fe 00			cp 0 
15d8 c8				ret z 
15d9			 
15d9 fe 01			cp 1 
15db cc 17 16			call z, .genlsword 
15de fe 02			cp 2 
15e0 cc 21 16			call z, .genedword 
15e3			 
15e3 fe 03			cp 3 
15e5 cc 2b 16			call z, .gendemword 
15e8			 
15e8 fe 04			cp 4 
15ea cc 35 16			call z, .genutlword 
15ed fe 05			cp 5 
15ef cc 3f 16			call z, .genspiword 
15f2 fe 06			cp 6 
15f4 cc 49 16			call z, .genkeyword 
15f7 fe 07			cp 7 
15f9 cc 0d 16			call z, .gensoundword 
15fc fe 07			cp 7 
15fe cc 03 16			call z, .genhwword 
1601 18 cb			jr create_startup 
1603			 
1603			.genhwword: 
1603 21 c0 1b			ld hl, crs_hw 
1606 11 96 16			ld de, .hwworddef 
1609 cd 53 16			call .genfile 
160c c9				ret 
160d			.gensoundword: 
160d 21 b4 1b			ld hl, crs_sound 
1610 11 a4 16			ld de, .soundworddef 
1613 cd 53 16			call .genfile 
1616 c9				ret 
1617			.genlsword: 
1617 21 76 1b			ld hl, crs_s1 
161a 11 ca 16			ld de, .lsworddef 
161d cd 53 16			call .genfile 
1620 c9				ret 
1621			 
1621			.genedword: 
1621 11 ce 16			ld de, .edworddef 
1624 21 7f 1b			ld hl, crs_s2 
1627 cd 53 16			call .genfile 
162a c9				ret 
162b			 
162b			.gendemword: 
162b 11 d6 16			ld de, .demoworddef 
162e 21 88 1b			ld hl, crs_s3 
1631 cd 53 16			call .genfile 
1634 c9				ret 
1635			 
1635			.genutlword: 
1635 21 94 1b			ld hl, crs_s4 
1638 11 b8 16			ld de, .utilwordef 
163b cd 53 16			call .genfile 
163e c9				ret 
163f			.genspiword: 
163f 21 9b 1b			ld hl, crs_s5 
1642 11 f8 16			ld de, .spiworddef 
1645 cd 53 16			call .genfile 
1648 c9				ret 
1649			.genkeyword: 
1649 21 a5 1b			ld hl, crs_s6 
164c 11 06 17			ld de, .keyworddef 
164f cd 53 16			call .genfile 
1652 c9				ret 
1653			 
1653			; hl - points to file name 
1653			; de - points to strings to add to file 
1653			 
1653			.genfile: 
1653 e5				push hl 
1654 d5				push de 
1655			 
1655 cd aa 0d			call clear_display 
1658 3e 00			ld a, display_row_1 
165a 11 85 16			ld de, .genfiletxt 
165d cd bd 0d			call str_at_display 
1660 cd cd 0d			call update_display 
1663			 
1663 d1				pop de 
1664 e1				pop hl 
1665			 
1665			 
1665 d5				push de 
1666 cd 77 08			call storage_create 
1669				; id in hl 
1669 d1				pop de   ; table of strings to add 
166a			 
166a			.genloop: 
166a			 
166a e5				push hl ; save id for next time around 
166b d5				push de ; save de for next time around 
166c			 
166c eb				ex de, hl 
166d cd bb 23			call loadwordinhl 
1670 eb				ex de, hl 
1671			 
1671				; need hl to be the id 
1671				; need de to be the string ptr 
1671				 
1671 cd 64 0b			call storage_append 
1674			 
1674 d1				pop de 
1675 e1				pop hl 
1676			 
1676 13				inc de 
1677 13				inc de 
1678			 
1678 1a				ld a,(de) 
1679 fe 00			cp 0 
167b 20 ed			jr nz, .genloop 
167d 13				inc de 
167e 1a				ld a, (de) 
167f 1b				dec de 
1680 fe 00			cp 0 
1682 20 e6			jr nz, .genloop	 
1684			 
1684 c9				ret 
1685			 
1685 .. 00		.genfiletxt:  db "Creating file...",0 
1696			 
1696			.hwworddef: 
1696 d2 66			dw test5 
1698 0a 67			dw test6 
169a 42 67			dw test7 
169c 56 67			dw test8 
169e 82 67			dw test9 
16a0 98 67			dw test10 
16a2 00 00			dw 0 
16a4			 
16a4			.soundworddef: 
16a4 bd 67			dw sound1 
16a6 e1 67			dw sound2 
16a8 11 68			dw sound3 
16aa 36 68			dw sound4 
16ac 43 68			dw sound5 
16ae 50 68			dw sound6 
16b0 5d 68			dw sound7 
16b2 6a 68			dw sound8 
16b4 82 68			dw sound9 
16b6 00 00			dw 0 
16b8			 
16b8			.utilwordef: 
16b8 f8 64			dw strncpy 
16ba d3 64			dw type 
16bc 55 66			dw tuck 
16be 9f 64			dw clrstack 
16c0 58 64			dw longread 
16c2 59 65			dw start1 
16c4 69 65			dw start2 
16c6			; duplicated 
16c6			;	dw start3b 
16c6			;	dw start3c 
16c6 68 66			dw list 
16c8 00 00			dw 0 
16ca			 
16ca			.lsworddef: 
16ca 7a 65			dw start3b 
16cc 00 00			dw 0 
16ce			 
16ce			.edworddef: 
16ce b7 60			dw edit1 
16d0 d8 60			dw edit2 
16d2 0d 61			dw edit3 
16d4 00 00			dw 0 
16d6			 
16d6			.demoworddef: 
16d6 99 68			dw game1 
16d8 aa 68			dw game1a 
16da 0c 69			dw game1b 
16dc 41 69			dw game1c 
16de 77 69			dw game1d 
16e0 a8 69			dw game1s 
16e2 bc 69			dw game1t 
16e4 d1 69			dw game1f 
16e6 05 6a			dw game1z 
16e8 49 6a			dw game1zz 
16ea b2 6a			dw ssv2 
16ec e8 6a			dw ssv3 
16ee 04 6b			dw ssv4 
16f0 20 6b			dw ssv5 
16f2 39 6b			dw ssv1 
16f4 81 6b			dw ssv1cpm	 
16f6			;	dw game2b 
16f6			;	dw game2bf 
16f6			;	dw game2mba 
16f6			;	dw game2mbas	 
16f6			;	dw game2mbht 
16f6			;	dw game2mbms 
16f6			;	dw game2mb 
16f6			;	dw game3w 
16f6			;	dw game3p 
16f6			;	dw game3sc 
16f6			;	dw game3vsi 
16f6			;	dw game3vs 
16f6 00 00			dw 0 
16f8			 
16f8			 
16f8			.spiworddef: 
16f8			 
16f8 45 61		    dw spi1 
16fa 9e 61		    dw spi2 
16fc d2 61		    dw spi2b 
16fe 56 62		    dw spi3 
1700 00 62		    dw spi4 
1702 29 62		    dw spi5 
1704			;    dw spi6 
1704			;    dw spi7 
1704			 
1704			;    dw spi8 
1704			;    dw spi9 
1704			;    dw spi10 
1704 00 00		    dw 0 
1706			 
1706			.keyworddef: 
1706			 
1706 d8 6b			dw keyup 
1708 e6 6b			dw keydown 
170a f6 6b			dw keyleft 
170c 06 6c			dw keyright 
170e 17 6c			dw 	keyf1 
1710 25 6c			dw keyf2 
1712 33 6c			dw keyf3 
1714 41 6c			dw keyf4 
1716 4f 6c			dw keyf5 
1718 5d 6c			dw keyf6 
171a 6b 6c			dw keyf7 
171c 79 6c			dw keyf8 
171e 87 6c			dw keyf9 
1720 95 6c			dw keyf10 
1722 a4 6c			dw keyf11 
1724 b3 6c			dw keyf12 
1726 c2 6c			dw keytab 
1728 d1 6c			dw keycr 
172a df 6c			dw keyhome 
172c ef 6c			dw keyend 
172e fe 6c			dw keybs 
1730 00 00			dw 0 
1732			 
1732			.crstart: 
1732 76 1b			dw crs_s1 
1734 7f 1b			dw crs_s2 
1736 88 1b			dw crs_s3 
1738 94 1b			dw crs_s4 
173a 9b 1b			dw crs_s5 
173c a5 1b			dw crs_s6 
173e b4 1b			dw crs_sound 
1740 c0 1b			dw crs_hw 
1742 00 00			dw 0 
1744			 
1744			endif 
1744			 
1744			 
1744			if STORAGE_SE 
1744			 
1744			config_fdir: 
1744				; using the scratch dir go through and release the memory allocated for each string 
1744				 
1744 21 f6 f0			ld hl, scratch 
1747 5e			.cfdir:	ld e,(hl) 
1748 23				inc hl 
1749 56				ld d,(hl) 
174a 23				inc hl 
174b			 
174b eb				ex de, hl 
174c cd 07 10			call ishlzero 
174f c8				ret z     ; return on null pointer 
1750 cd 83 14			call free 
1753 eb				ex de, hl 
1754 18 f1			jr .cfdir 
1756			 
1756			 
1756 c9				ret 
1757			 
1757			 
1757			config_dir: 
1757			 
1757				; for the config menus that need to build a directory of storage call this routine 
1757				; it will construct a menu in scratch to pass to menu 
1757			 
1757				; open storage device 
1757			 
1757				; execute DIR to build a list of files and their ids into scratch in menu format 
1757				; once the menu has finished then will need to call config_fdir to release the strings 
1757				 
1757				; c = number items 
1757			 
1757				 
1757 cd 25 05			call storage_get_block_0 
175a			 
175a 21 af f9			ld hl, store_page     ; get current id count 
175d 46				ld b, (hl) 
175e 0e 00			ld c, 0    ; count of files   
1760			 
1760			 
1760 21 f6 f0			ld hl, scratch 
1763 22 a6 f9			ld (store_tmp2), hl    ; location to poke strings 
1766			 
1766				; check for empty drive 
1766			 
1766 3e 00			ld a, 0 
1768 b8				cp b 
1769 ca 03 18			jp z, .dirdone 
176c			 
176c				 
176c					if DEBUG_FORTH_WORDS 
176c						DMARK "Cdc" 
176c f5				push af  
176d 3a 81 17			ld a, (.dmark)  
1770 32 a0 fd			ld (debug_mark),a  
1773 3a 82 17			ld a, (.dmark+1)  
1776 32 a1 fd			ld (debug_mark+1),a  
1779 3a 83 17			ld a, (.dmark+2)  
177c 32 a2 fd			ld (debug_mark+2),a  
177f 18 03			jr .pastdmark  
1781 ..			.dmark: db "Cdc"  
1784 f1			.pastdmark: pop af  
1785			endm  
# End of macro DMARK
1785						CALLMONITOR 
1785 cd aa fd			call debug_vector  
1788				endm  
# End of macro CALLMONITOR
1788					endif 
1788			 
1788			 
1788			.diritem:	 
1788 c5				push bc 
1789				; for each of the current ids do a search for them and if found push to stack 
1789			 
1789 21 40 00				ld hl, STORE_BLOCK_PHY 
178c 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
178e 58					ld e,b 
178f			 
178f cd a7 07				call storage_findnextid 
1792			 
1792			 
1792					; if found hl will be non zero 
1792			 
1792 cd 07 10				call ishlzero 
1795 28 69				jr z, .dirnotfound 
1797			 
1797					; increase count 
1797			 
1797 c1					pop bc	 
1798 0c					inc c 
1799 c5					push bc 
179a					 
179a			 
179a					; get file header and push the file name 
179a			 
179a 11 af f9				ld de, store_page 
179d cd 74 04				call storage_read_block 
17a0			 
17a0					; push file id to stack 
17a0				 
17a0 3a af f9				ld a, (store_page) 
17a3 26 00				ld h, 0 
17a5 6f					ld l, a 
17a6			 
17a6					;call forth_push_numhl 
17a6					; TODO store id 
17a6			 
17a6 e5					push hl 
17a7			 
17a7					; push extent count to stack  
17a7				 
17a7 21 b2 f9				ld hl, store_page+3 
17aa			 
17aa					; get file name length 
17aa			 
17aa cd 44 13				call strlenz   
17ad			 
17ad 23					inc hl   ; cover zero term 
17ae 23					inc hl  ; stick the id at the end of the area 
17af			 
17af e5					push hl 
17b0 c1					pop bc    ; move length to bc 
17b1			 
17b1 cd b9 13				call malloc 
17b4			 
17b4					; TODO save malloc area to scratch 
17b4			 
17b4 eb					ex de, hl 
17b5 2a a6 f9				ld hl, (store_tmp2) 
17b8 73					ld (hl), e 
17b9 23					inc hl 
17ba 72					ld (hl), d 
17bb 23					inc hl 
17bc 22 a6 f9				ld (store_tmp2), hl 
17bf			 
17bf					 
17bf			 
17bf					;pop hl   ; get source 
17bf			;		ex de, hl    ; swap aronund	 
17bf			 
17bf 21 b2 f9				ld hl, store_page+3 
17c2					if DEBUG_FORTH_WORDS 
17c2						DMARK "CFd" 
17c2 f5				push af  
17c3 3a d7 17			ld a, (.dmark)  
17c6 32 a0 fd			ld (debug_mark),a  
17c9 3a d8 17			ld a, (.dmark+1)  
17cc 32 a1 fd			ld (debug_mark+1),a  
17cf 3a d9 17			ld a, (.dmark+2)  
17d2 32 a2 fd			ld (debug_mark+2),a  
17d5 18 03			jr .pastdmark  
17d7 ..			.dmark: db "CFd"  
17da f1			.pastdmark: pop af  
17db			endm  
# End of macro DMARK
17db						CALLMONITOR 
17db cd aa fd			call debug_vector  
17de				endm  
# End of macro CALLMONITOR
17de					endif 
17de ed b0				ldir 
17e0			 
17e0					; de is past string, move back one and store id 
17e0					 
17e0 1b					dec de 
17e1			 
17e1					; store file id 
17e1			 
17e1 e1					pop hl 
17e2 eb					ex de,hl 
17e3 73					ld (hl), e 
17e4			 
17e4					if DEBUG_FORTH_WORDS 
17e4						DMARK "Cdi" 
17e4 f5				push af  
17e5 3a f9 17			ld a, (.dmark)  
17e8 32 a0 fd			ld (debug_mark),a  
17eb 3a fa 17			ld a, (.dmark+1)  
17ee 32 a1 fd			ld (debug_mark+1),a  
17f1 3a fb 17			ld a, (.dmark+2)  
17f4 32 a2 fd			ld (debug_mark+2),a  
17f7 18 03			jr .pastdmark  
17f9 ..			.dmark: db "Cdi"  
17fc f1			.pastdmark: pop af  
17fd			endm  
# End of macro DMARK
17fd						CALLMONITOR 
17fd cd aa fd			call debug_vector  
1800				endm  
# End of macro CALLMONITOR
1800					endif 
1800					 
1800			.dirnotfound: 
1800 c1					pop bc     
1801 10 85				djnz .diritem 
1803				 
1803			.dirdone:	 
1803			 
1803 3e 00				ld a, 0 
1805 2a a6 f9				ld hl, (store_tmp2) 
1808 77					ld (hl), a 
1809 23					inc hl 
180a 77					ld (hl), a 
180b 23					inc hl 
180c					; push a count of the dir items found 
180c			 
180c			;		ld h, 0 
180c			;		ld l, c 
180c			 
180c c9				ret 
180d			 
180d			endif 
180d			 
180d			 
180d			; Settings 
180d			; Run  
180d			 
180d			 
180d			 
180d			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
180d			;;hd_menu2:   db "        2: Editor",0   
180d			;hd_menu2:   db "        2: Editor       6: Menu",0   
180d			;hd_menu3:   db "        3: Storage",0 
180d			;hd_menu4:   db "0=quit  4: Debug",0 
180d			;hd_don:     db "ON",0 
180d			;hd_doff:     db "OFF",0 
180d			; 
180d			; 
180d			; 
180d			;hardware_diags_old:       
180d			; 
180d			;.diagmenu: 
180d			;	call clear_display 
180d			;	ld a, display_row_1 
180d			;	ld de, hd_menu1 
180d			;	call str_at_display 
180d			; 
180d			;	ld a, display_row_2 
180d			;	ld de, hd_menu2 
180d			;	call str_at_display 
180d			; 
180d			;	ld a, display_row_3 
180d			;	ld de, hd_menu3 
180d			;	call str_at_display 
180d			; 
180d			;	ld a,  display_row_4 
180d			;	ld de, hd_menu4 
180d			;	call str_at_display 
180d			; 
180d			;	; display debug state 
180d			; 
180d			;	ld de, hd_don 
180d			;	ld a, (os_view_disable) 
180d			;	cp 0 
180d			;	jr z, .distog 
180d			;	ld de, hd_doff 
180d			;.distog: ld a, display_row_4+17 
180d			;	call str_at_display 
180d			; 
180d			;	call update_display 
180d			; 
180d			;	call cin_wait 
180d			; 
180d			; 
180d			; 
180d			;	cp '4' 
180d			;	jr nz, .diagn1 
180d			; 
180d			;	; debug toggle 
180d			; 
180d			;	ld a, (os_view_disable) 
180d			;	ld b, '*' 
180d			;	cp 0 
180d			;	jr z, .debtog 
180d			;	ld b, 0 
180d			;.debtog:	 
180d			;	ld a,b 
180d			;	ld (os_view_disable),a 
180d			; 
180d			;.diagn1: cp '0' 
180d			;	 ret z 
180d			; 
180d			;;	cp '1' 
180d			;;       jp z, matrix	 
180d			;;   TODO keyboard matrix test 
180d			; 
180d			;	cp '2' 
180d			;	jp z, .diagedit 
180d			; 
180d			;;	cp '6' 
180d			;;	jp z, .menutest 
180d			;;if ENABLE_BASIC 
180d			;;	cp '6' 
180d			;;	jp z, basic 
180d			;;endif 
180d			 ; 
180d			;	jp .diagmenu 
180d			; 
180d			; 
180d			;	ret 
180d			 
180d			 
180d			.debug_tog: 
180d 21 57 18			ld hl, .menudebug 
1810				 
1810			;	ld a, (os_view_disable) 
1810			;	cp '*' 
1810 3a aa fd			ld a,(debug_vector) 
1813 fe c9			cp $C9   ; RET 
1815 20 04			jr nz,.tdon  
1817 3e 01			ld a, 1 
1819 18 02			jr .tog1 
181b 3e 00		.tdon: ld a, 0 
181d			 
181d			.tog1: 
181d cd db 0d			call menu 
1820 fe 00			cp 0 
1822 c8				ret z 
1823 fe 01			cp 1    ; disable debug 
1825 28 04			jr z, .dtog0 
1827 3e 2a			ld a, '*' 
1829 18 05			jr .dtogset 
182b			.dtog0:  
182b				;ld a, 0 
182b cd 49 19			call bp_on 
182e 18 dd			jr .debug_tog 
1830			.dtogset:  
1830				; ld (os_view_disable), a 
1830 cd 55 19			call bp_off 
1833 c3 0d 18			jp .debug_tog 
1836			 
1836			 
1836			hardware_diags:       
1836			 
1836			.diagm: 
1836 21 49 18			ld hl, .menuitems 
1839 3e 00			ld a, 0 
183b cd db 0d			call menu 
183e			 
183e fe 00		         cp 0 
1840 c8				 ret z 
1841			 
1841 fe 02			cp 2 
1843 ca a2 18			jp z, .diagedit 
1846			 
1846			;	cp '6' 
1846			;	jp z, .menutest 
1846			;if ENABLE_BASIC 
1846			;	cp '6' 
1846			;	jp z, basic 
1846			;endif 
1846			  
1846 c3 36 18			jp .diagm 
1849			 
1849				 
1849 5d 18		.menuitems:   	dw .m1 
184b 68 18				dw .m2 
184d 6f 18				dw .m3 
184f 77 18				dw .m5 
1851 7d 18				dw .m5a 
1853 86 18				dw .m5b 
1855 00 00				dw 0 
1857			 
1857			.menudebug: 
1857 8f 18				dw .m6 
1859 98 18				dw .m7 
185b 00 00				dw 0 
185d			 
185d .. 00		.m1:   db "Key Matrix",0 
1868 .. 00		.m2:   db "Editor",0 
186f .. 00		.m3:   db "Storage",0 
1877 .. 00		.m5:   db "Sound",0 
187d .. 00		.m5a:  db "RAM Test",0 
1886 .. 00		.m5b:  db "LCD Test",0 
188f			 
188f .. 00		.m6:   db "Debug ON",0 
1898 .. 00		.m7:   db "Debug OFF",0 
18a2			 
18a2			; debug editor 
18a2			 
18a2			.diagedit: 
18a2			 
18a2 21 f6 f0			ld hl, scratch 
18a5			;	ld bc, 250 
18a5			;	ldir 
18a5				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
18a5 3e 00			ld a, 0 
18a7 77				ld (hl), a 
18a8 23				inc hl 
18a9 77				ld (hl), a 
18aa 23				inc hl 
18ab 77				ld (hl), a 
18ac			 
18ac cd aa 0d		        call clear_display 
18af cd cd 0d			call update_display 
18b2				;ld a, 1 
18b2				;ld (hardware_diag), a 
18b2			.diloop: 
18b2 3e 00			ld a, display_row_1 
18b4 0e 00			ld c, 0 
18b6 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
18b8 1e 28			ld e, 40 
18ba			 
18ba 21 f6 f0			ld hl, scratch	 
18bd cd 0b 10			call input_str 
18c0			 
18c0 3e 28			ld a, display_row_2 
18c2 11 f6 f0			ld de, scratch 
18c5 cd bd 0d			call str_at_display 
18c8 cd cd 0d			call update_display 
18cb			 
18cb c3 b2 18			jp .diloop 
18ce			 
18ce			 
18ce			; pass word in hl 
18ce			; a has display location 
18ce			display_word_at: 
18ce f5				push af 
18cf e5				push hl 
18d0 7c				ld a,h 
18d1 21 fb f3			ld hl, os_word_scratch 
18d4 cd e7 11			call hexout 
18d7 e1				pop hl 
18d8 7d				ld a,l 
18d9 21 fd f3			ld hl, os_word_scratch+2 
18dc cd e7 11			call hexout 
18df 21 ff f3			ld hl, os_word_scratch+4 
18e2 3e 00			ld a,0 
18e4 77				ld (hl),a 
18e5 11 fb f3			ld de,os_word_scratch 
18e8 f1				pop af 
18e9 cd bd 0d				call str_at_display 
18ec c9				ret 
18ed			 
18ed			display_ptr_state: 
18ed			 
18ed				; to restore afterwards 
18ed			 
18ed d5				push de 
18ee c5				push bc 
18ef e5				push hl 
18f0 f5				push af 
18f1			 
18f1				; for use in here 
18f1			 
18f1			;	push bc 
18f1			;	push de 
18f1			;	push hl 
18f1			;	push af 
18f1			 
18f1 cd aa 0d			call clear_display 
18f4			 
18f4 11 cc 1a			ld de, .ptrstate 
18f7 3e 00			ld a, display_row_1 
18f9 cd bd 0d			call str_at_display 
18fc			 
18fc				; display debug step 
18fc			 
18fc			 
18fc 11 a0 fd			ld de, debug_mark 
18ff 3e 26			ld a, display_row_1+display_cols-2 
1901 cd bd 0d			call str_at_display 
1904			 
1904				; display a 
1904 11 d6 1a			ld de, .ptrcliptr 
1907 3e 28			ld a, display_row_2 
1909 cd bd 0d			call str_at_display 
190c			 
190c f1				pop af 
190d 2a 75 f9			ld hl,(cli_ptr) 
1910 3e 30			ld a, display_row_2+8 
1912 cd ce 18			call display_word_at 
1915			 
1915			 
1915				; display hl 
1915			 
1915			 
1915 11 de 1a			ld de, .ptrclioptr 
1918 3e 32			ld a, display_row_2+10 
191a cd bd 0d			call str_at_display 
191d			; 
191d			;	pop hl 
191d 3e 35			ld a, display_row_2+13 
191f 2a 73 f9			ld hl,(cli_origptr) 
1922 cd ce 18			call display_word_at 
1925			; 
1925			;	 
1925			;	; display de 
1925			 
1925			;	ld de, .regstatede 
1925			;	ld a, display_row_3 
1925			;	call str_at_display 
1925			 
1925			;	pop de 
1925			;	ld h,d 
1925			;	ld l, e 
1925			;	ld a, display_row_3+3 
1925			;	call display_word_at 
1925			 
1925			 
1925				; display bc 
1925			 
1925			;	ld de, .regstatebc 
1925			;	ld a, display_row_3+10 
1925			;	call str_at_display 
1925			 
1925			;	pop bc 
1925			;	ld h,b 
1925			;	ld l, c 
1925			;	ld a, display_row_3+13 
1925			;	call display_word_at 
1925			 
1925			 
1925				; display dsp 
1925			 
1925			;	ld de, .regstatedsp 
1925			;	ld a, display_row_4 
1925			;	call str_at_display 
1925			 
1925				 
1925			;	ld hl,(cli_data_sp) 
1925			;	ld a, display_row_4+4 
1925			;	call display_word_at 
1925			 
1925				; display rsp 
1925			 
1925 11 0d 1b			ld de, .regstatersp 
1928 3e 82			ld a, display_row_4+10 
192a cd bd 0d			call str_at_display 
192d			 
192d				 
192d 2a 27 f9			ld hl,(cli_ret_sp) 
1930 3e 86			ld a, display_row_4+14 
1932 cd ce 18			call display_word_at 
1935			 
1935 cd cd 0d			call update_display 
1938			 
1938 cd ed 0c			call delay1s 
193b cd ed 0c			call delay1s 
193e cd ed 0c			call delay1s 
1941			 
1941			 
1941 cd c0 1f			call next_page_prompt 
1944			 
1944				; restore  
1944			 
1944 f1				pop af 
1945 e1				pop hl 
1946 c1				pop bc 
1947 d1				pop de 
1948 c9				ret 
1949			 
1949			; Update the break point vector so that the user can hook a new routine 
1949			 
1949			bp_on: 
1949 3e c3			ld a, $c3    ; JP 
194b 32 aa fd			ld (debug_vector), a 
194e 21 5b 19			ld hl, break_point_state 
1951 22 ab fd			ld (debug_vector+1), hl 
1954 c9				ret 
1955			 
1955			bp_off: 
1955 3e c9			ld a, $c9    ; RET 
1957 32 aa fd			ld (debug_vector), a 
195a c9				ret 
195b			 
195b			 
195b			break_point_state: 
195b			;	push af 
195b			; 
195b			;	; see if disabled 
195b			; 
195b			;	ld a, (os_view_disable) 
195b			;	cp '*' 
195b			;	jr nz, .bpsgo 
195b			;	pop af 
195b			;	ret 
195b			 
195b			.bpsgo: 
195b			;	pop af 
195b f5				push af 
195c 22 d8 f0			ld (os_view_hl), hl 
195f ed 53 d6 f0		ld (os_view_de), de 
1963 ed 43 d4 f0		ld (os_view_bc), bc 
1967 e5				push hl 
1968 6f				ld l, a 
1969 26 00			ld h, 0 
196b 22 da f0			ld (os_view_af),hl 
196e			 
196e 21 e6 fc				ld hl, display_fb0 
1971 22 01 fb				ld (display_fb_active), hl 
1974 e1				pop hl	 
1975			 
1975 3e 31			ld a, '1' 
1977 fe 2a		.bps1:  cp '*' 
1979 cc 55 19			call z, bp_off 
197c			;	jr nz, .bps1b 
197c			;	ld (os_view_disable),a 
197c fe 31		.bps1b:  cp '1' 
197e 20 14			jr nz, .bps2 
1980			 
1980				; display reg 
1980			 
1980				 
1980			 
1980 3a da f0			ld a, (os_view_af) 
1983 2a d8 f0			ld hl, (os_view_hl) 
1986 ed 5b d6 f0		ld de, (os_view_de) 
198a ed 4b d4 f0		ld bc, (os_view_bc) 
198e cd 28 1a			call display_reg_state 
1991 c3 14 1a			jp .bpschk 
1994			 
1994 fe 32		.bps2:  cp '2' 
1996 20 08			jr nz, .bps3 
1998				 
1998				; display hl 
1998 2a d8 f0			ld hl, (os_view_hl) 
199b cd 12 1b			call display_dump_at_hl 
199e			 
199e 18 74			jr .bpschk 
19a0			 
19a0 fe 33		.bps3:  cp '3' 
19a2 20 08			jr nz, .bps4 
19a4			 
19a4			        ; display de 
19a4 2a d6 f0			ld hl, (os_view_de) 
19a7 cd 12 1b			call display_dump_at_hl 
19aa			 
19aa 18 68			jr .bpschk 
19ac fe 34		.bps4:  cp '4' 
19ae 20 08			jr nz, .bps5 
19b0			 
19b0			        ; display bc 
19b0 2a d4 f0			ld hl, (os_view_bc) 
19b3 cd 12 1b			call display_dump_at_hl 
19b6			 
19b6 18 5c			jr .bpschk 
19b8 fe 35		.bps5:  cp '5' 
19ba 20 08		        jr nz, .bps7 
19bc			 
19bc				; display cur ptr 
19bc 2a 75 f9			ld hl, (cli_ptr) 
19bf cd 12 1b			call display_dump_at_hl 
19c2			 
19c2 18 50			jr .bpschk 
19c4 fe 36		.bps7:  cp '6' 
19c6 20 08			jr nz, .bps8b 
19c8				 
19c8				; display cur orig ptr 
19c8 2a 73 f9			ld hl, (cli_origptr) 
19cb cd 12 1b			call display_dump_at_hl 
19ce 18 44			jr .bpschk 
19d0 fe 37		.bps8b:  cp '7' 
19d2 20 08			jr nz, .bps9 
19d4				 
19d4				; display dsp 
19d4 2a 23 f9			ld hl, (cli_data_sp) 
19d7 cd 12 1b			call display_dump_at_hl 
19da			 
19da 18 38			jr .bpschk 
19dc fe 39		.bps9:  cp '9' 
19de 20 05			jr nz, .bps8c 
19e0				 
19e0				; display SP 
19e0			;	ld hl, sp 
19e0 cd 12 1b			call display_dump_at_hl 
19e3			 
19e3 18 2f			jr .bpschk 
19e5 fe 38		.bps8c:  cp '8' 
19e7 20 08			jr nz, .bps8d 
19e9				 
19e9				; display rsp 
19e9 2a 27 f9			ld hl, (cli_ret_sp) 
19ec cd 12 1b			call display_dump_at_hl 
19ef			 
19ef 18 23			jr .bpschk 
19f1 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
19f3 20 05			jr nz, .bps8 
19f5 cd 7a 1d			call monitor 
19f8			 
19f8 18 1a			jr .bpschk 
19fa fe 30		.bps8:  cp '0' 
19fc 20 16			jr nz, .bpschk 
19fe			 
19fe 21 45 fc				ld hl, display_fb1 
1a01 22 01 fb				ld (display_fb_active), hl 
1a04 cd cd 0d				call update_display 
1a07			 
1a07				;ld a, (os_view_af) 
1a07 2a d8 f0			ld hl, (os_view_hl) 
1a0a ed 5b d6 f0		ld de, (os_view_de) 
1a0e ed 4b d4 f0		ld bc, (os_view_bc) 
1a12 f1				pop af 
1a13 c9				ret 
1a14			 
1a14			.bpschk:   
1a14 cd ed 0c			call delay1s 
1a17 3e 9f		ld a,display_row_4 + display_cols - 1 
1a19 11 be 1f		        ld de, endprg 
1a1c cd bd 0d			call str_at_display 
1a1f cd cd 0d			call update_display 
1a22 cd 82 74			call cin_wait 
1a25			 
1a25 c3 77 19			jp .bps1 
1a28			 
1a28			 
1a28			display_reg_state: 
1a28			 
1a28				; to restore afterwards 
1a28			 
1a28 d5				push de 
1a29 c5				push bc 
1a2a e5				push hl 
1a2b f5				push af 
1a2c			 
1a2c				; for use in here 
1a2c			 
1a2c c5				push bc 
1a2d d5				push de 
1a2e e5				push hl 
1a2f f5				push af 
1a30			 
1a30 cd aa 0d			call clear_display 
1a33			 
1a33 11 e8 1a			ld de, .regstate 
1a36 3e 00			ld a, display_row_1 
1a38 cd bd 0d			call str_at_display 
1a3b			 
1a3b				; display debug step 
1a3b			 
1a3b			 
1a3b 11 a0 fd			ld de, debug_mark 
1a3e 3e 25			ld a, display_row_1+display_cols-3 
1a40 cd bd 0d			call str_at_display 
1a43			 
1a43				; display a 
1a43 11 04 1b			ld de, .regstatea 
1a46 3e 28			ld a, display_row_2 
1a48 cd bd 0d			call str_at_display 
1a4b			 
1a4b e1				pop hl 
1a4c			;	ld h,0 
1a4c			;	ld l, a 
1a4c 3e 2b			ld a, display_row_2+3 
1a4e cd ce 18			call display_word_at 
1a51			 
1a51			 
1a51				; display hl 
1a51			 
1a51			 
1a51 11 f8 1a			ld de, .regstatehl 
1a54 3e 32			ld a, display_row_2+10 
1a56 cd bd 0d			call str_at_display 
1a59			 
1a59 e1				pop hl 
1a5a 3e 35			ld a, display_row_2+13 
1a5c cd ce 18			call display_word_at 
1a5f			 
1a5f				 
1a5f				; display de 
1a5f			 
1a5f 11 fc 1a			ld de, .regstatede 
1a62 3e 50			ld a, display_row_3 
1a64 cd bd 0d			call str_at_display 
1a67			 
1a67 e1				pop hl 
1a68			;	ld h,d 
1a68			;	ld l, e 
1a68 3e 53			ld a, display_row_3+3 
1a6a cd ce 18			call display_word_at 
1a6d			 
1a6d			 
1a6d				; display bc 
1a6d			 
1a6d 11 00 1b			ld de, .regstatebc 
1a70 3e 5a			ld a, display_row_3+10 
1a72 cd bd 0d			call str_at_display 
1a75			 
1a75 e1				pop hl 
1a76			;	ld h,b 
1a76			;	ld l, c 
1a76 3e 5d			ld a, display_row_3+13 
1a78 cd ce 18			call display_word_at 
1a7b			 
1a7b			 
1a7b				; display dsp 
1a7b			 
1a7b 11 08 1b			ld de, .regstatedsp 
1a7e 3e 78			ld a, display_row_4 
1a80 cd bd 0d			call str_at_display 
1a83			 
1a83				 
1a83 2a 23 f9			ld hl,(cli_data_sp) 
1a86 3e 7c			ld a, display_row_4+4 
1a88 cd ce 18			call display_word_at 
1a8b			 
1a8b				; display rsp 
1a8b			 
1a8b 11 0d 1b			ld de, .regstatersp 
1a8e 3e 82			ld a, display_row_4+10 
1a90 cd bd 0d			call str_at_display 
1a93			 
1a93				 
1a93 2a 27 f9			ld hl,(cli_ret_sp) 
1a96 3e 86			ld a, display_row_4+14 
1a98 cd ce 18			call display_word_at 
1a9b			 
1a9b cd cd 0d			call update_display 
1a9e			 
1a9e			;	call delay1s 
1a9e			;	call delay1s 
1a9e			;	call delay1s 
1a9e			 
1a9e			 
1a9e			;	call next_page_prompt 
1a9e			 
1a9e				; restore  
1a9e			 
1a9e f1				pop af 
1a9f e1				pop hl 
1aa0 c1				pop bc 
1aa1 d1				pop de 
1aa2 c9				ret 
1aa3			 
1aa3 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1ab7 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1acc .. 00		.ptrstate:	db "Ptr State",0 
1ad6 .. 00		.ptrcliptr:     db "cli_ptr",0 
1ade .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1ae8 .. 00		.regstate:	db "Reg State (1/0)",0 
1af8 .. 00		.regstatehl:	db "HL:",0 
1afc .. 00		.regstatede:	db "DE:",0 
1b00 .. 00		.regstatebc:	db "BC:",0 
1b04 .. 00		.regstatea:	db "A :",0 
1b08 .. 00		.regstatedsp:	db "DSP:",0 
1b0d .. 00		.regstatersp:	db "RSP:",0 
1b12			 
1b12			display_dump_at_hl: 
1b12 e5				push hl 
1b13 d5				push de 
1b14 c5				push bc 
1b15 f5				push af 
1b16			 
1b16 22 19 f4			ld (os_cur_ptr),hl	 
1b19 cd aa 0d			call clear_display 
1b1c cd c8 1e			call dumpcont 
1b1f			;	call delay1s 
1b1f			;	call next_page_prompt 
1b1f			 
1b1f			 
1b1f f1				pop af 
1b20 c1				pop bc 
1b21 d1				pop de 
1b22 e1				pop hl 
1b23 c9				ret 
1b24			 
1b24			;if ENABLE_BASIC 
1b24			;	include "nascombasic.asm" 
1b24			;	basic: 
1b24			;	include "forth/FORTH.ASM" 
1b24			;endif 
1b24			 
1b24			; eof 
1b24			 
1b24			 
# End of file firmware_diags.asm
1b24			  
1b24			include "firmware_prompts.asm"  
1b24			; Prompts  
1b24			 
1b24			; boot messages 
1b24			 
1b24 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1b39 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1b49			 
1b49			 
1b49			; config menus 
1b49			 
1b49			;prom_c3: db "Add Dictionary To File",0 
1b49			 
1b49			if STARTUP_V1 
1b49			prom_c2: db "Select Autoload File",0 
1b49			prom_c2a: db "Disable Autoload File", 0 
1b49			endif 
1b49			 
1b49			if STARTUP_V2 
1b49 .. 00		prom_c2: db "Enable Autoload Files",0 
1b5f .. 00		prom_c2a: db "Disable Autoload Files", 0 
1b76			 
1b76 .. 00		crs_s1: db "*ls-word", 0 
1b7f .. 00		crs_s2: db "*ed-word", 0 
1b88 .. 00		crs_s3: db "*Demo-Games", 0 
1b94 .. 00		crs_s4: db "*Utils", 0 
1b9b .. 00		crs_s5: db "*SPI-Util", 0 
1ba5 .. 00		crs_s6: db "*Key-Constants", 0 
1bb4 .. 00		crs_sound: db "*Sound-Util", 0 
1bc0 .. 00		crs_hw: db "*Hello-World",0 
1bcd			 
1bcd			 
1bcd			 
1bcd			endif 
1bcd			;prom_c2b: db "Select Storage Bank",0 
1bcd .. 00		prom_c4: db "Settings",0 
1bd6 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1bf1 .. 00		prom_m4b:   db "Monitor",0 
1bf9 .. 00		prom_c1: db "Hardware Diags",0 
1c08			 
1c08			 
1c08			if STARTUP_V2 
1c08 .. 00		prom_c9: db "Create Startup Files",0 
1c1d			endif 
1c1d			 
1c1d .. 00		prom_notav:    db "Feature not available",0 
1c33 .. 00		prom_empty:    db "",0 
1c34			 
1c34			; eof 
1c34			 
# End of file firmware_prompts.asm
1c34			  
1c34			  
1c34			; eof  
1c34			  
# End of file firmware.asm
1c34			 
1c34			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1c34			;if BASE_KEV  
1c34			;baseram: equ 08000h 
1c34			;endif 
1c34			 
1c34			;if BASE_SC114 
1c34			;baseram:     equ    endofcode 
1c34			;endif 
1c34			 
1c34			 
1c34			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1c34			 
1c34			; start system 
1c34			 
1c34			coldstart: 
1c34				; set sp 
1c34				; di/ei 
1c34			 
1c34 f3				di 
1c35 31 fd ff			ld sp, tos 
1c38 cd 09 71			call init_nmi 
1c3b			;	ei 
1c3b			 
1c3b				; init spinner 
1c3b 3e 00			ld a,0 
1c3d 32 fb fa			ld (display_active), a 
1c40			 
1c40				; disable breakpoint by default 
1c40			 
1c40				;ld a,'*' 
1c40			;	ld a,' ' 
1c40			;	ld (os_view_disable),a 
1c40			 
1c40				; set break point vector as new break point on or off 
1c40 cd 55 19			call bp_off 
1c43			 
1c43				; init hardware 
1c43			 
1c43				; init keyboard and screen hardware 
1c43			 
1c43 cd 6c 00			call hardware_init 
1c46			 
1c46			 
1c46 cd ed 0c			call delay1s 
1c49 3e 58			ld a, display_row_3+8 
1c4b 11 03 00			ld de, buildtime 
1c4e cd bd 0d			call str_at_display 
1c51 cd cd 0d			call update_display 
1c54			 
1c54 cd ed 0c			call delay1s 
1c57 cd ed 0c			call delay1s 
1c5a cd ed 0c			call delay1s 
1c5d			 
1c5d				; detect if any keys are held down to enable breakpoints at start up 
1c5d			 
1c5d cd 93 74			call cin  
1c60 fe 00			cp 0 
1c62 28 03			jr z, .nokeys 
1c64			 
1c64				;call hardware_diags 
1c64 cd 52 15			call config 
1c67			 
1c67			;	ld de, .bpen 
1c67			;	ld a, display_row_4 
1c67			;	call str_at_display 
1c67			;	call update_display 
1c67			; 
1c67			;	ld a,0 
1c67			;	ld (os_view_disable),a 
1c67			; 
1c67			;.bpwait: 
1c67			;	call cin 
1c67			;	cp 0 
1c67			;	jr z, .bpwait 
1c67			;	jr .nokeys 
1c67			; 
1c67			; 
1c67			;.bpen:  db "Break points enabled!",0 
1c67			 
1c67			 
1c67			 
1c67			 
1c67			 
1c67			 
1c67			.nokeys: 
1c67			 
1c67			 
1c67				 
1c67			 
1c67			;jp  testkey 
1c67			 
1c67			;call storage_get_block_0 
1c67			; 
1c67			;ld hl, 0 
1c67			;ld de, store_page 
1c67			;call storage_read_block 
1c67			 
1c67				 
1c67			;ld hl, 10 
1c67			;ld de, store_page 
1c67			;call storage_read_block 
1c67			 
1c67			 
1c67			 
1c67			 
1c67			 
1c67			;stop:	nop 
1c67			;	jp stop 
1c67			 
1c67			 
1c67			 
1c67			main: 
1c67 cd aa 0d			call clear_display 
1c6a cd cd 0d			call update_display 
1c6d			 
1c6d			 
1c6d			 
1c6d			;	call testlcd 
1c6d			 
1c6d			 
1c6d			 
1c6d cd 09 24			call forth_init 
1c70			 
1c70			 
1c70			warmstart: 
1c70 cd df 23			call forth_warmstart 
1c73			 
1c73				; run startup word load 
1c73			        ; TODO prevent this running at warmstart after crash  
1c73			 
1c73				if STARTUP_ENABLE 
1c73			 
1c73					if STARTUP_V1 
1c73			 
1c73						if STORAGE_SE 
1c73							call forth_autoload 
1c73						endif 
1c73						call forth_startup 
1c73					endif 
1c73			 
1c73					if STARTUP_V2 
1c73			 
1c73						if STORAGE_SE 
1c73 cd 37 6f						call forth_autoload 
1c76						else 
1c76							call forth_startup 
1c76						endif 
1c76			 
1c76			 
1c76					endif 
1c76			 
1c76				endif 
1c76			 
1c76			warmstart_afterauto: 
1c76			 
1c76				; show free memory after boot 
1c76 11 15 1d			ld de, freeram 
1c79 3e 00			ld a, display_row_1 
1c7b cd bd 0d			call str_at_display 
1c7e			 
1c7e				; get current heap start after loading any uwords 
1c7e			 
1c7e				;ld de, (os_last_new_uword) 
1c7e				;ex de, hl 
1c7e			 
1c7e			; Or use heap_size word???? 
1c7e				;ld hl, heap_end 
1c7e				;ld hl, heap_size 
1c7e				;ld de, topusermem 
1c7e				;ld de, heap_start 
1c7e ed 5b 0a 80			ld de, (free_list )      
1c82 21 d1 f0				ld hl, heap_end 
1c85 ed 52			sbc hl, de 
1c87				;push hl 
1c87				;ld a,h	         	 
1c87				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1c87				;call hexout 
1c87			   	;pop hl 
1c87			; 
1c87			;	ld a,l 
1c87			;	ld hl, os_word_scratch+2 
1c87			;	call hexout 
1c87			;	ld hl, os_word_scratch+4 
1c87			;	ld a, 0 
1c87			;	ld (hl),a 
1c87 eb				ex de, hl 
1c88 21 fb f3			ld hl, os_word_scratch 
1c8b cd f3 12			call uitoa_16 
1c8e			 
1c8e			 
1c8e 11 fb f3			ld de, os_word_scratch 
1c91 3e 0d			ld a, display_row_1 + 13 
1c93 cd bd 0d			call str_at_display 
1c96 cd cd 0d			call update_display 
1c99			 
1c99			 
1c99				;call demo 
1c99			 
1c99			 
1c99				; init scratch input area for cli commands 
1c99			 
1c99 21 1d f4			ld hl, os_cli_cmd 
1c9c 3e 00			ld a,0 
1c9e 77				ld (hl),a 
1c9f 23				inc hl 
1ca0 77				ld (hl),a 
1ca1			 
1ca1 3e 00			ld a,0 
1ca3 32 1c f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1ca6			 
1ca6 32 19 f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1ca9 32 1a f4			ld (os_cur_ptr+1),a	 
1cac			 
1cac 32 fb f3			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1caf 32 fc f3			ld (os_word_scratch+1),a	 
1cb2				 
1cb2			 
1cb2				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cb2 21 1d f4			ld hl, os_cli_cmd 
1cb5			 
1cb5 3e 00			ld a, 0		 ; init cli input 
1cb7 77				ld (hl), a 
1cb8 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1cba			cli: 
1cba				; show cli prompt 
1cba				;push af 
1cba				;ld a, 0 
1cba				;ld de, prompt 
1cba				;call str_at_display 
1cba			 
1cba				;call update_display 
1cba				;pop af 
1cba				;inc a 
1cba				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1cba			 
1cba			.lastrecall: 
1cba			 
1cba 0e 00			ld c, 0 
1cbc 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1cbe 1e 28			ld e, 40 
1cc0			 
1cc0 21 1d f4			ld hl, os_cli_cmd 
1cc3			 
1cc3				STACKFRAME OFF $fefe $9f9f 
1cc3				if DEBUG_STACK_IMB 
1cc3					if OFF 
1cc3						exx 
1cc3						ld de, $fefe 
1cc3						ld a, d 
1cc3						ld hl, curframe 
1cc3						call hexout 
1cc3						ld a, e 
1cc3						ld hl, curframe+2 
1cc3						call hexout 
1cc3						ld hl, $fefe 
1cc3						push hl 
1cc3						ld hl, $9f9f 
1cc3						push hl 
1cc3						exx 
1cc3					endif 
1cc3				endif 
1cc3			endm 
# End of macro STACKFRAME
1cc3			 
1cc3 cd 0b 10			call input_str 
1cc6			 
1cc6				STACKFRAMECHK OFF $fefe $9f9f 
1cc6				if DEBUG_STACK_IMB 
1cc6					if OFF 
1cc6						exx 
1cc6						ld hl, $9f9f 
1cc6						pop de   ; $9f9f 
1cc6						call cmp16 
1cc6						jr nz, .spnosame 
1cc6						ld hl, $fefe 
1cc6						pop de   ; $fefe 
1cc6						call cmp16 
1cc6						jr z, .spfrsame 
1cc6						.spnosame: call showsperror 
1cc6						.spfrsame: nop 
1cc6						exx 
1cc6					endif 
1cc6				endif 
1cc6			endm 
# End of macro STACKFRAMECHK
1cc6			 
1cc6			 
1cc6				; check to see if last line recall has been requested 
1cc6			 
1cc6			if EDIT_V2 
1cc6 fe 05			cp KEY_UP 
1cc8 20 0f			jr nz, .noexecline 
1cca			 
1cca 11 1d f4			ld de, os_cli_cmd 
1ccd 21 1c f5			ld hl, os_last_cmd 
1cd0 01 ff 00			ld bc, 255 
1cd3 ed b0			ldir 
1cd5 3e 00			ld a, 0 
1cd7 18 e1			jr .lastrecall 
1cd9			endif 
1cd9			 
1cd9			.noexecline: 
1cd9				; no so exec the line		 
1cd9			 
1cd9				; copy input to last command 
1cd9			 
1cd9 21 1d f4			ld hl, os_cli_cmd 
1cdc 11 1c f5			ld de, os_last_cmd 
1cdf 01 ff 00			ld bc, 255 
1ce2 ed b0			ldir 
1ce4			 
1ce4				; wipe current buffer 
1ce4			 
1ce4			;	ld a, 0 
1ce4			;	ld hl, os_cli_cmd 
1ce4			;	ld de, os_cli_cmd+1 
1ce4			;	ld bc, 254 
1ce4			;	ldir 
1ce4				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1ce4			;	call strcpy 
1ce4			;	ld a, 0 
1ce4			;	ld (hl), a 
1ce4			;	inc hl 
1ce4			;	ld (hl), a 
1ce4			;	inc hl 
1ce4			;	ld (hl), a 
1ce4			 
1ce4				; switch frame buffer to program  
1ce4			 
1ce4 21 45 fc				ld hl, display_fb1 
1ce7 22 01 fb				ld (display_fb_active), hl 
1cea			 
1cea			;	nop 
1cea				STACKFRAME ON $fbfe $8f9f 
1cea				if DEBUG_STACK_IMB 
1cea					if ON 
1cea						exx 
1cea						ld de, $fbfe 
1cea						ld a, d 
1cea						ld hl, curframe 
1cea						call hexout 
1cea						ld a, e 
1cea						ld hl, curframe+2 
1cea						call hexout 
1cea						ld hl, $fbfe 
1cea						push hl 
1cea						ld hl, $8f9f 
1cea						push hl 
1cea						exx 
1cea					endif 
1cea				endif 
1cea			endm 
# End of macro STACKFRAME
1cea				; first time into the parser so pass over the current scratch pad 
1cea 21 1d f4			ld hl,os_cli_cmd 
1ced				; tokenise the entered statement(s) in HL 
1ced cd 87 24			call forthparse 
1cf0			        ; exec forth statements in top of return stack 
1cf0 cd c7 24			call forthexec 
1cf3				;call forthexec_cleanup 
1cf3			;	call parsenext 
1cf3			 
1cf3				STACKFRAMECHK ON $fbfe $8f9f 
1cf3				if DEBUG_STACK_IMB 
1cf3					if ON 
1cf3						exx 
1cf3						ld hl, $8f9f 
1cf3						pop de   ; $8f9f 
1cf3						call cmp16 
1cf3						jr nz, .spnosame 
1cf3						ld hl, $fbfe 
1cf3						pop de   ; $fbfe 
1cf3						call cmp16 
1cf3						jr z, .spfrsame 
1cf3						.spnosame: call showsperror 
1cf3						.spfrsame: nop 
1cf3						exx 
1cf3					endif 
1cf3				endif 
1cf3			endm 
# End of macro STACKFRAMECHK
1cf3				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1cf3			 
1cf3 3e 78			ld a, display_row_4 
1cf5 11 26 1d			ld de, endprog 
1cf8			 
1cf8 cd cd 0d			call update_display		 
1cfb			 
1cfb cd c0 1f			call next_page_prompt 
1cfe			 
1cfe				; switch frame buffer to cli 
1cfe			 
1cfe 21 e6 fc				ld hl, display_fb0 
1d01 22 01 fb				ld (display_fb_active), hl 
1d04			 
1d04			 
1d04 cd aa 0d		        call clear_display 
1d07 cd cd 0d			call update_display		 
1d0a			 
1d0a 21 1d f4			ld hl, os_cli_cmd 
1d0d			 
1d0d 3e 00			ld a, 0		 ; init cli input 
1d0f 77				ld (hl), a 
1d10			 
1d10				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1d10			 
1d10				; now on last line 
1d10			 
1d10				; TODO scroll screen up 
1d10			 
1d10				; TODO instead just clear screen and place at top of screen 
1d10			 
1d10			;	ld a, 0 
1d10			;	ld (f_cursor_ptr),a 
1d10			 
1d10				;call clear_display 
1d10				;call update_display 
1d10			 
1d10				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d10 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1d12 c3 ba 1c			jp cli 
1d15			 
1d15 .. 00		freeram: db "Free bytes: ",0 
1d22 ..			asc: db "1A2F" 
1d26 .. 00		endprog: db "End prog...",0 
1d32			 
1d32			testenter2:   
1d32 21 28 f1			ld hl,scratch+50 
1d35 22 19 f4			ld (os_cur_ptr),hl 
1d38 c3 ba 1c			jp cli 
1d3b			 
1d3b			testenter:  
1d3b			 
1d3b 21 22 1d			ld hl,asc 
1d3e			;	ld a,(hl) 
1d3e			;	call nibble2val 
1d3e cd 3d 12			call get_byte 
1d41			 
1d41			 
1d41			;	ld a,(hl) 
1d41			;	call atohex 
1d41			 
1d41			;	call fourehexhl 
1d41 32 28 f1			ld (scratch+50),a 
1d44			 
1d44			 
1d44			 
1d44 21 24 1d			ld hl,asc+2 
1d47			;	ld a, (hl) 
1d47			;	call nibble2val 
1d47 cd 3d 12			call get_byte 
1d4a			 
1d4a			;	call fourehexhl 
1d4a 32 2a f1			ld (scratch+52),a 
1d4d				 
1d4d 21 28 f1			ld hl,scratch+50 
1d50 22 19 f4			ld (os_cur_ptr),hl 
1d53 c3 ba 1c			jp cli 
1d56			 
1d56			enter:	 
1d56 3a fa f0			ld a,(scratch+4) 
1d59 fe 00			cp 0 
1d5b 28 0c			jr z, .entercont 
1d5d				; no, not a null term line so has an address to work out.... 
1d5d			 
1d5d 21 f8 f0			ld hl,scratch+2 
1d60 cd 9d 12			call get_word_hl 
1d63			 
1d63 22 19 f4			ld (os_cur_ptr),hl	 
1d66 c3 ba 1c			jp cli 
1d69			 
1d69			 
1d69			.entercont:  
1d69			 
1d69 21 f8 f0			ld hl, scratch+2 
1d6c cd 3d 12			call get_byte 
1d6f			 
1d6f 2a 19 f4		   	ld hl,(os_cur_ptr) 
1d72 77					ld (hl),a 
1d73 23					inc hl 
1d74 22 19 f4				ld (os_cur_ptr),hl 
1d77				 
1d77			; get byte  
1d77			 
1d77			 
1d77 c3 ba 1c			jp cli 
1d7a			 
1d7a			 
1d7a			; basic monitor support 
1d7a			 
1d7a			monitor: 
1d7a				;  
1d7a cd aa 0d			call clear_display 
1d7d 3e 00			ld a, 0 
1d7f 11 d3 1d			ld de, .monprompt 
1d82 cd bd 0d			call str_at_display 
1d85 cd cd 0d			call update_display 
1d88			 
1d88				; get a monitor command 
1d88			 
1d88 0e 00			ld c, 0     ; entry at top left 
1d8a 16 64			ld d, 100   ; max buffer size 
1d8c 1e 0f			ld e, 15    ; input scroll area 
1d8e 3e 00			ld a, 0     ; init string 
1d90 21 f4 f2			ld hl, os_input 
1d93 77				ld (hl), a 
1d94 23				inc hl 
1d95 77				ld (hl), a 
1d96 21 f4 f2			ld hl, os_input 
1d99 3e 01			ld a, 1     ; init string 
1d9b cd 0b 10			call input_str 
1d9e			 
1d9e cd aa 0d		        call clear_display 
1da1 cd cd 0d			call update_display		 
1da4			 
1da4 3a f4 f2			ld a, (os_input) 
1da7 cd 3b 13			call toUpper 
1daa fe 48		        cp 'H' 
1dac ca 47 1e		        jp z, .monhelp 
1daf fe 44			cp 'D'		; dump 
1db1 ca 7a 1e			jp z, .mondump	 
1db4 fe 43			cp 'C'		; dump 
1db6 ca 94 1e			jp z, .moncdump	 
1db9 fe 4d			cp 'M'		; dump 
1dbb ca d5 1d			jp z, .moneditstart 
1dbe fe 55			cp 'U'		; dump 
1dc0 ca e1 1d			jp z, .monedit	 
1dc3 fe 47			cp 'G'		; dump 
1dc5 ca 70 1e			jp z, .monjump 
1dc8 fe 42			cp 'B'		; forth breakpoint 
1dca cc 5b 19			call z, break_point_state 
1dcd fe 51			cp 'Q'		; dump 
1dcf c8				ret z	 
1dd0			 
1dd0			 
1dd0				; TODO "S" to access symbol by name and not need the address 
1dd0				; TODO "F" to find a string in memory 
1dd0			 
1dd0 c3 7a 1d			jp monitor 
1dd3			 
1dd3 .. 00		.monprompt: db ">", 0 
1dd5			 
1dd5			.moneditstart: 
1dd5				; get starting address 
1dd5			 
1dd5 21 f6 f2			ld hl,os_input+2 
1dd8 cd 9d 12			call get_word_hl 
1ddb			 
1ddb 22 19 f4			ld (os_cur_ptr),hl	 
1dde			 
1dde c3 7a 1d			jp monitor 
1de1			 
1de1			.monedit: 
1de1				; get byte to load 
1de1			 
1de1 21 f6 f2			ld hl,os_input+2 
1de4 cd 3d 12			call get_byte 
1de7			 
1de7				; get address to update 
1de7 2a 19 f4			ld hl, (os_cur_ptr) 
1dea			 
1dea				; update byte 
1dea			 
1dea 77				ld (hl), a 
1deb			 
1deb				; move to next address and save it 
1deb			 
1deb 23				inc hl 
1dec 22 19 f4			ld (os_cur_ptr),hl	 
1def			 
1def c3 7a 1d			jp monitor 
1df2			 
1df2			 
1df2 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1e06 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1e22 .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
1e40 .. 00		.monhelptext4:  db "Q-Quit",0 
1e47			        
1e47			.monhelp: 
1e47 3e 00			ld a, display_row_1 
1e49 11 f2 1d		        ld de, .monhelptext1 
1e4c			 
1e4c cd bd 0d			call str_at_display 
1e4f 3e 28			ld a, display_row_2 
1e51 11 06 1e		        ld de, .monhelptext2 
1e54					 
1e54 cd bd 0d			call str_at_display 
1e57 3e 50			ld a, display_row_3 
1e59 11 22 1e		        ld de, .monhelptext3 
1e5c					 
1e5c cd bd 0d			call str_at_display 
1e5f 3e 78			ld a, display_row_4 
1e61 11 40 1e		        ld de, .monhelptext4 
1e64 cd bd 0d			call str_at_display 
1e67			 
1e67 cd cd 0d			call update_display		 
1e6a			 
1e6a cd c0 1f			call next_page_prompt 
1e6d c3 7a 1d			jp monitor 
1e70			 
1e70			.monjump:    
1e70 21 f6 f2			ld hl,os_input+2 
1e73 cd 9d 12			call get_word_hl 
1e76			 
1e76 e9				jp (hl) 
1e77 c3 7a 1d			jp monitor 
1e7a			 
1e7a			.mondump:    
1e7a 21 f6 f2			ld hl,os_input+2 
1e7d cd 9d 12			call get_word_hl 
1e80			 
1e80 22 19 f4			ld (os_cur_ptr),hl	 
1e83 cd c8 1e			call dumpcont 
1e86 3e 78			ld a, display_row_4 
1e88 11 26 1d			ld de, endprog 
1e8b			 
1e8b cd cd 0d			call update_display		 
1e8e			 
1e8e cd c0 1f			call next_page_prompt 
1e91 c3 7a 1d			jp monitor 
1e94			.moncdump: 
1e94 cd c8 1e			call dumpcont 
1e97 3e 78			ld a, display_row_4 
1e99 11 26 1d			ld de, endprog 
1e9c			 
1e9c cd cd 0d			call update_display		 
1e9f			 
1e9f cd c0 1f			call next_page_prompt 
1ea2 c3 7a 1d			jp monitor 
1ea5			 
1ea5			 
1ea5			; TODO symbol access  
1ea5			 
1ea5			.symbols:     ;; A list of symbols that can be called up  
1ea5 e6 fc			dw display_fb0 
1ea7 .. 00			db "fb0",0  
1eab af f9		     	dw store_page 
1ead .. 00			db "store_page",0 
1eb8			 
1eb8			 
1eb8			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1eb8			 
1eb8 3a f7 f0			ld a,(scratch+1) 
1ebb fe 00			cp 0 
1ebd 28 09			jr z, dumpcont 
1ebf			 
1ebf				; no, not a null term line so has an address to work out.... 
1ebf			 
1ebf 21 f8 f0			ld hl,scratch+2 
1ec2 cd 9d 12			call get_word_hl 
1ec5			 
1ec5 22 19 f4			ld (os_cur_ptr),hl	 
1ec8			 
1ec8			 
1ec8			 
1ec8			dumpcont: 
1ec8			 
1ec8				; dump bytes at ptr 
1ec8			 
1ec8			 
1ec8 3e 00			ld a, display_row_1 
1eca 2a 01 fb			ld hl, (display_fb_active) 
1ecd cd de 0f			call addatohl 
1ed0 cd f8 1e			call .dumpbyterow 
1ed3			 
1ed3 3e 28			ld a, display_row_2 
1ed5 2a 01 fb			ld hl, (display_fb_active) 
1ed8 cd de 0f			call addatohl 
1edb cd f8 1e			call .dumpbyterow 
1ede			 
1ede			 
1ede 3e 50			ld a, display_row_3 
1ee0 2a 01 fb			ld hl, (display_fb_active) 
1ee3 cd de 0f			call addatohl 
1ee6 cd f8 1e			call .dumpbyterow 
1ee9			 
1ee9 3e 78			ld a, display_row_4 
1eeb 2a 01 fb			ld hl, (display_fb_active) 
1eee cd de 0f			call addatohl 
1ef1 cd f8 1e			call .dumpbyterow 
1ef4			 
1ef4 cd cd 0d			call update_display 
1ef7			;		jp cli 
1ef7 c9				ret 
1ef8			 
1ef8			.dumpbyterow: 
1ef8			 
1ef8				;push af 
1ef8			 
1ef8 e5				push hl 
1ef9			 
1ef9				; calc where to poke the ascii 
1ef9			if display_cols == 20 
1ef9				ld a, 16 
1ef9			else 
1ef9 3e 1f			ld a, 31 
1efb			endif 
1efb			 
1efb cd de 0f			call addatohl 
1efe 22 fb f3			ld (os_word_scratch),hl  		; save pos for later 
1f01			 
1f01			 
1f01			; display decoding address 
1f01 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f04			 
1f04 7c				ld a,h 
1f05 e1				pop hl 
1f06 e5				push hl 
1f07			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1f07 cd e7 11			call hexout 
1f0a 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f0d			 
1f0d 7d				ld a,l 
1f0e e1				pop hl 
1f0f 23				inc hl 
1f10 23				inc hl 
1f11 e5				push hl 
1f12			;	ld hl, os_word_scratch+2 
1f12 cd e7 11			call hexout 
1f15 e1				pop hl 
1f16 23				inc hl 
1f17 23				inc hl 
1f18				;ld hl, os_word_scratch+4 
1f18 3e 3a			ld a, ':' 
1f1a 77				ld (hl),a 
1f1b 23				inc hl 
1f1c				;ld a, 0 
1f1c				;ld (hl),a 
1f1c				;ld de, os_word_scratch 
1f1c				;pop af 
1f1c				;push af 
1f1c			;		ld a, display_row_2 
1f1c			;		call str_at_display 
1f1c			;		call update_display 
1f1c			 
1f1c			 
1f1c			;pop af 
1f1c			;	add 5 
1f1c			 
1f1c			if display_cols == 20 
1f1c				ld b, 4 
1f1c			else 
1f1c 06 08			ld b, 8 
1f1e			endif	 
1f1e			 
1f1e			.dumpbyte: 
1f1e c5				push bc 
1f1f e5				push hl 
1f20			 
1f20			 
1f20 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f23 7e					ld a,(hl) 
1f24			 
1f24					; poke the ascii to display 
1f24 2a fb f3				ld hl,(os_word_scratch) 
1f27 77					ld (hl),a 
1f28 23					inc hl 
1f29 22 fb f3				ld (os_word_scratch),hl 
1f2c			 
1f2c					 
1f2c			 
1f2c			 
1f2c e1					pop hl 
1f2d e5					push hl 
1f2e			 
1f2e cd e7 11				call hexout 
1f31			 
1f31					 
1f31 2a 19 f4		   	ld hl,(os_cur_ptr) 
1f34 23				inc hl 
1f35 22 19 f4		   	ld (os_cur_ptr),hl 
1f38			 
1f38 e1					pop hl 
1f39 23					inc hl 
1f3a 23					inc hl 
1f3b 23					inc hl 
1f3c			 
1f3c			 
1f3c			 
1f3c					;ld a,0 
1f3c					;ld (os_word_scratch+2),a 
1f3c					;pop af 
1f3c					;push af 
1f3c			 
1f3c					;ld de, os_word_scratch 
1f3c					;call str_at_display 
1f3c			;		call update_display 
1f3c			;		pop af 
1f3c c1					pop bc 
1f3d c6 03				add 3 
1f3f 10 dd			djnz .dumpbyte 
1f41			 
1f41				 
1f41			 
1f41 c9				ret 
1f42			 
1f42			jump:	 
1f42			 
1f42 21 f8 f0			ld hl,scratch+2 
1f45 cd 9d 12			call get_word_hl 
1f48				;ld hl,(scratch+2) 
1f48				;call fourehexhl 
1f48			 
1f48 22 19 f4			ld (os_cur_ptr),hl	 
1f4b			 
1f4b e9				jp (hl) 
1f4c			 
1f4c			 
1f4c			 
1f4c			; TODO implement a basic monitor mode to start with 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			 
1f4c			; testing and demo code during development 
1f4c			 
1f4c			 
1f4c .. 00		str1: db "Enter some text...",0 
1f5f .. 00		clear: db "                    ",0 
1f74			 
1f74			demo: 
1f74			 
1f74			 
1f74			 
1f74			;	call update_display 
1f74			 
1f74				; init scratch input area for testing 
1f74 21 f6 f0			ld hl, scratch	 
1f77 3e 00			ld a,0 
1f79 77				ld (hl),a 
1f7a			 
1f7a			 
1f7a 3e 28		            LD   A, display_row_2 
1f7c			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f7c 11 4c 1f		            LD   DE, str1 
1f7f cd bd 0d			call str_at_display 
1f82			 
1f82			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f82			cloop:	 
1f82 3e 50		            LD   A, display_row_3 
1f84			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f84 11 5f 1f		            LD   DE, clear 
1f87			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1f87 cd bd 0d				call str_at_display 
1f8a 3e 78			ld a, display_row_4 
1f8c 11 bc 1f			ld de, prompt 
1f8f			 
1f8f cd bd 0d				call str_at_display 
1f92 cd cd 0d			call update_display 
1f95			 
1f95 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1f97 16 0a			ld d, 10 
1f99 21 f6 f0			ld hl, scratch	 
1f9c cd 0b 10			call input_str 
1f9f			 
1f9f			;	call clear_display 
1f9f			;'	call update_display 
1f9f			 
1f9f 3e 00		            LD   A, display_row_1 
1fa1			;            CALL fLCD_Pos       ;Position cursor to location in A 
1fa1 11 5f 1f		            LD   DE, clear 
1fa4 cd bd 0d				call str_at_display 
1fa7			;            CALL fLCD_Str       ;Display string pointed to by DE 
1fa7 3e 00		            LD   A, display_row_1 
1fa9			;            CALL fLCD_Pos       ;Position cursor to location in A 
1fa9 11 f6 f0		            LD   DE, scratch 
1fac			;            CALL fLCD_Str       ;Display string pointed to by DE 
1fac cd bd 0d				call str_at_display 
1faf cd cd 0d			call update_display 
1fb2			 
1fb2 3e 00				ld a,0 
1fb4 21 f6 f0			ld hl, scratch 
1fb7 77				ld (hl),a 
1fb8			 
1fb8 00				nop 
1fb9 c3 82 1f			jp cloop 
1fbc			 
1fbc			 
1fbc			 
1fbc			; OS Prompt 
1fbc			 
1fbc .. 00		prompt: db ">",0 
1fbe .. 00		endprg: db "?",0 
1fc0			 
1fc0			 
1fc0			; handy next page prompt 
1fc0			next_page_prompt: 
1fc0 e5				push hl 
1fc1 d5				push de 
1fc2 f5				push af 
1fc3 c5				push bc 
1fc4			 
1fc4 3e 9f			ld a,display_row_4 + display_cols - 1 
1fc6 11 be 1f		        ld de, endprg 
1fc9 cd bd 0d			call str_at_display 
1fcc cd cd 0d			call update_display 
1fcf cd 82 74			call cin_wait 
1fd2 c1				pop bc 
1fd3 f1				pop af 
1fd4 d1				pop de 
1fd5 e1				pop hl 
1fd6			 
1fd6			 
1fd6 c9				ret 
1fd7			 
1fd7			 
1fd7			; forth parser 
1fd7			 
1fd7			; My forth kernel 
1fd7			include "forth_kernel.asm" 
1fd7			; 
1fd7			; kernel to the forth OS 
1fd7			 
1fd7			DS_TYPE_STR: equ 1     ; string type 
1fd7			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1fd7			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1fd7			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1fd7			 
1fd7			FORTH_PARSEV1: equ 0 
1fd7			FORTH_PARSEV2: equ 0 
1fd7			FORTH_PARSEV3: equ 0 
1fd7			FORTH_PARSEV4: equ 0 
1fd7			FORTH_PARSEV5: equ 1 
1fd7			 
1fd7			;if FORTH_PARSEV5 
1fd7			;	FORTH_END_BUFFER: equ 0 
1fd7			;else 
1fd7			FORTH_END_BUFFER: equ 127 
1fd7			;endif 
1fd7			 
1fd7			FORTH_TRUE: equ 1 
1fd7			FORTH_FALSE: equ 0 
1fd7			 
1fd7			if FORTH_PARSEV4 
1fd7			include "forth_stackops.asm" 
1fd7			endif 
1fd7			 
1fd7			if FORTH_PARSEV5 
1fd7			include "forth_stackopsv5.asm" 
1fd7			 
1fd7			; Stack operations for v5 parser on wards 
1fd7			; * DATA stack 
1fd7			; * LOOP stack 
1fd7			; * RETURN stack 
1fd7			 
1fd7			 
1fd7			 
1fd7			FORTH_CHK_DSP_UNDER: macro 
1fd7				push hl 
1fd7				push de 
1fd7				ld hl,(cli_data_sp) 
1fd7				ld de, cli_data_stack 
1fd7				call cmp16 
1fd7				jp c, fault_dsp_under 
1fd7				pop de 
1fd7				pop hl 
1fd7				endm 
1fd7			 
1fd7			 
1fd7			FORTH_CHK_RSP_UNDER: macro 
1fd7				push hl 
1fd7				push de 
1fd7				ld hl,(cli_ret_sp) 
1fd7				ld de, cli_ret_stack 
1fd7				call cmp16 
1fd7				jp c, fault_rsp_under 
1fd7				pop de 
1fd7				pop hl 
1fd7				endm 
1fd7			 
1fd7			FORTH_CHK_LOOP_UNDER: macro 
1fd7				push hl 
1fd7				push de 
1fd7				ld hl,(cli_loop_sp) 
1fd7				ld de, cli_loop_stack 
1fd7				call cmp16 
1fd7				jp c, fault_loop_under 
1fd7				pop de 
1fd7				pop hl 
1fd7				endm 
1fd7			 
1fd7			FORTH_ERR_TOS_NOTSTR: macro 
1fd7				; TOSO might need more for checks when used 
1fd7				push af 
1fd7				ld a,(hl) 
1fd7				cp DS_TYPE_STR 
1fd7				jp nz, type_faultn   
1fd7				pop af 
1fd7				endm 
1fd7			 
1fd7			FORTH_ERR_TOS_NOTNUM: macro 
1fd7				push af 
1fd7				ld a,(hl) 
1fd7				cp DS_TYPE_INUM 
1fd7				jp nz, type_faultn   
1fd7				pop af 
1fd7				endm 
1fd7			 
1fd7			 
1fd7			; increase data stack pointer and save hl to it 
1fd7				 
1fd7			FORTH_DSP_NEXT: macro 
1fd7				call macro_forth_dsp_next 
1fd7				endm 
1fd7			 
1fd7			 
1fd7			macro_forth_dsp_next: 
1fd7				if DEBUG_FORTH_STACK_GUARD 
1fd7 cd 26 6d				call check_stacks 
1fda				endif 
1fda e5				push hl 
1fdb d5				push de 
1fdc eb				ex de,hl 
1fdd 2a 23 f9			ld hl,(cli_data_sp) 
1fe0 23				inc hl 
1fe1 23				inc hl 
1fe2			 
1fe2			; PARSEV5 
1fe2 23				inc hl 
1fe3 22 23 f9			ld (cli_data_sp),hl 
1fe6 73				ld (hl), e 
1fe7 23				inc hl 
1fe8 72				ld (hl), d 
1fe9 d1				pop de 
1fea e1				pop hl 
1feb				if DEBUG_FORTH_STACK_GUARD 
1feb cd 26 6d				call check_stacks 
1fee				endif 
1fee c9				ret 
1fef			 
1fef			 
1fef			; increase ret stack pointer and save hl to it 
1fef				 
1fef			FORTH_RSP_NEXT: macro 
1fef				call macro_forth_rsp_next 
1fef				endm 
1fef			 
1fef			macro_forth_rsp_next: 
1fef				if DEBUG_FORTH_STACK_GUARD 
1fef cd 26 6d				call check_stacks 
1ff2				endif 
1ff2 e5				push hl 
1ff3 d5				push de 
1ff4 eb				ex de,hl 
1ff5 2a 27 f9			ld hl,(cli_ret_sp) 
1ff8 23				inc hl 
1ff9 23				inc hl 
1ffa 22 27 f9			ld (cli_ret_sp),hl 
1ffd 73				ld (hl), e 
1ffe 23				inc hl 
1fff 72				ld (hl), d 
2000 d1				pop de 
2001 e1				pop hl 
2002				if DEBUG_FORTH_STACK_GUARD 
2002 cd 26 6d				call check_stacks 
2005				endif 
2005 c9				ret 
2006			 
2006			; get current ret stack pointer and save to hl  
2006				 
2006			FORTH_RSP_TOS: macro 
2006				call macro_forth_rsp_tos 
2006				endm 
2006			 
2006			macro_forth_rsp_tos: 
2006				;push de 
2006 2a 27 f9			ld hl,(cli_ret_sp) 
2009 cd 41 20			call loadhlptrtohl 
200c				;ld e, (hl) 
200c				;inc hl 
200c				;ld d, (hl) 
200c				;ex de, hl 
200c					if DEBUG_FORTH_WORDS 
200c			;			DMARK "RST" 
200c						CALLMONITOR 
200c cd aa fd			call debug_vector  
200f				endm  
# End of macro CALLMONITOR
200f					endif 
200f				;pop de 
200f c9				ret 
2010			 
2010			; pop ret stack pointer 
2010				 
2010			FORTH_RSP_POP: macro 
2010				call macro_forth_rsp_pop 
2010				endm 
2010			 
2010			 
2010			macro_forth_rsp_pop: 
2010				if DEBUG_FORTH_STACK_GUARD 
2010			;		DMARK "RPP" 
2010 cd 26 6d				call check_stacks 
2013					FORTH_CHK_RSP_UNDER 
2013 e5				push hl 
2014 d5				push de 
2015 2a 27 f9			ld hl,(cli_ret_sp) 
2018 11 e1 f8			ld de, cli_ret_stack 
201b cd fc 0f			call cmp16 
201e da 3d 6e			jp c, fault_rsp_under 
2021 d1				pop de 
2022 e1				pop hl 
2023				endm 
# End of macro FORTH_CHK_RSP_UNDER
2023				endif 
2023 e5				push hl 
2024 2a 27 f9			ld hl,(cli_ret_sp) 
2027			 
2027			 
2027				if FORTH_ENABLE_FREE 
2027			 
2027					; get pointer 
2027			 
2027					push de 
2027					push hl 
2027			 
2027					ld e, (hl) 
2027					inc hl 
2027					ld d, (hl) 
2027			 
2027					ex de, hl 
2027					call free 
2027			 
2027					pop hl 
2027					pop de 
2027			 
2027			 
2027				endif 
2027			 
2027			 
2027 2b				dec hl 
2028 2b				dec hl 
2029 22 27 f9			ld (cli_ret_sp), hl 
202c				; do stack underflow checks 
202c e1				pop hl 
202d				if DEBUG_FORTH_STACK_GUARD 
202d cd 26 6d				call check_stacks 
2030					FORTH_CHK_RSP_UNDER 
2030 e5				push hl 
2031 d5				push de 
2032 2a 27 f9			ld hl,(cli_ret_sp) 
2035 11 e1 f8			ld de, cli_ret_stack 
2038 cd fc 0f			call cmp16 
203b da 3d 6e			jp c, fault_rsp_under 
203e d1				pop de 
203f e1				pop hl 
2040				endm 
# End of macro FORTH_CHK_RSP_UNDER
2040				endif 
2040 c9				ret 
2041			 
2041			 
2041			 
2041			; routine to load word pointed to by hl into hl 
2041			 
2041			loadhlptrtohl: 
2041			 
2041 d5				push de 
2042 5e				ld e, (hl) 
2043 23				inc hl 
2044 56				ld d, (hl) 
2045 eb				ex de, hl 
2046 d1				pop de 
2047			 
2047 c9				ret 
2048			 
2048			 
2048			 
2048			 
2048			 
2048			; push a number held in HL onto the data stack 
2048			; entry point for pushing a value when already in hl used in function above 
2048			 
2048			forth_push_numhl: 
2048			 
2048 e5				push hl    ; save value to push 
2049			 
2049			if DEBUG_FORTH_PUSH 
2049				; see if disabled 
2049			 
2049			 
2049 f5				push af 
204a 3a aa fd			ld a,(debug_vector) 
204d fe c9			cp $c9   ; ret 
204f			;	ld a, (os_view_disable) 
204f			;	cp '*' 
204f 28 34			jr z, .pskip2 
2051 e5				push hl 
2052 e5			push hl 
2053 cd aa 0d			call clear_display 
2056 e1			pop hl 
2057 7c				ld a,h 
2058 21 fb f3			ld hl, os_word_scratch 
205b cd e7 11			call hexout 
205e e1				pop hl 
205f 7d				ld a,l 
2060 21 fd f3			ld hl, os_word_scratch+2 
2063 cd e7 11			call hexout 
2066			 
2066 21 ff f3			ld hl, os_word_scratch+4 
2069 3e 00			ld a,0 
206b 77				ld (hl),a 
206c 11 fb f3			ld de,os_word_scratch 
206f 3e 28				ld a, display_row_2 
2071 cd bd 0d				call str_at_display 
2074 11 21 5f			ld de, .push_num 
2077 3e 00			ld a, display_row_1 
2079			 
2079 cd bd 0d				call str_at_display 
207c			 
207c			 
207c cd cd 0d			call update_display 
207f cd ed 0c			call delay1s 
2082 cd ed 0c			call delay1s 
2085			.pskip2:  
2085			 
2085 f1				pop af 
2086			endif	 
2086			 
2086			 
2086				FORTH_DSP_NEXT 
2086 cd d7 1f			call macro_forth_dsp_next 
2089				endm 
# End of macro FORTH_DSP_NEXT
2089			 
2089 2a 23 f9			ld hl, (cli_data_sp) 
208c			 
208c				; save item type 
208c 3e 02			ld a,  DS_TYPE_INUM 
208e 77				ld (hl), a 
208f 23				inc hl 
2090			 
2090				; get word off stack 
2090 d1				pop de 
2091 7b				ld a,e 
2092 77				ld (hl), a 
2093 23				inc hl 
2094 7a				ld a,d 
2095 77				ld (hl), a 
2096			 
2096			if DEBUG_FORTH_PUSH 
2096 2b				dec hl 
2097 2b				dec hl 
2098 2b				dec hl 
2099						DMARK "PH5" 
2099 f5				push af  
209a 3a ae 20			ld a, (.dmark)  
209d 32 a0 fd			ld (debug_mark),a  
20a0 3a af 20			ld a, (.dmark+1)  
20a3 32 a1 fd			ld (debug_mark+1),a  
20a6 3a b0 20			ld a, (.dmark+2)  
20a9 32 a2 fd			ld (debug_mark+2),a  
20ac 18 03			jr .pastdmark  
20ae ..			.dmark: db "PH5"  
20b1 f1			.pastdmark: pop af  
20b2			endm  
# End of macro DMARK
20b2				CALLMONITOR 
20b2 cd aa fd			call debug_vector  
20b5				endm  
# End of macro CALLMONITOR
20b5			endif	 
20b5			 
20b5 c9				ret 
20b6			 
20b6			 
20b6			; Push a string to stack pointed to by hl 
20b6			 
20b6			forth_push_str: 
20b6			 
20b6			if DEBUG_FORTH_PUSH 
20b6						DMARK "PSQ" 
20b6 f5				push af  
20b7 3a cb 20			ld a, (.dmark)  
20ba 32 a0 fd			ld (debug_mark),a  
20bd 3a cc 20			ld a, (.dmark+1)  
20c0 32 a1 fd			ld (debug_mark+1),a  
20c3 3a cd 20			ld a, (.dmark+2)  
20c6 32 a2 fd			ld (debug_mark+2),a  
20c9 18 03			jr .pastdmark  
20cb ..			.dmark: db "PSQ"  
20ce f1			.pastdmark: pop af  
20cf			endm  
# End of macro DMARK
20cf				CALLMONITOR 
20cf cd aa fd			call debug_vector  
20d2				endm  
# End of macro CALLMONITOR
20d2			endif	 
20d2			 
20d2			 
20d2			    
20d2 e5				push hl 
20d3 e5				push hl 
20d4			 
20d4			;	ld a, 0   ; find end of string 
20d4 cd 44 13			call strlenz 
20d7			if DEBUG_FORTH_PUSH 
20d7						DMARK "PQ2" 
20d7 f5				push af  
20d8 3a ec 20			ld a, (.dmark)  
20db 32 a0 fd			ld (debug_mark),a  
20de 3a ed 20			ld a, (.dmark+1)  
20e1 32 a1 fd			ld (debug_mark+1),a  
20e4 3a ee 20			ld a, (.dmark+2)  
20e7 32 a2 fd			ld (debug_mark+2),a  
20ea 18 03			jr .pastdmark  
20ec ..			.dmark: db "PQ2"  
20ef f1			.pastdmark: pop af  
20f0			endm  
# End of macro DMARK
20f0				CALLMONITOR 
20f0 cd aa fd			call debug_vector  
20f3				endm  
# End of macro CALLMONITOR
20f3			endif	 
20f3 eb				ex de, hl 
20f4 e1				pop hl   ; get ptr to start of string 
20f5			if DEBUG_FORTH_PUSH 
20f5						DMARK "PQ3" 
20f5 f5				push af  
20f6 3a 0a 21			ld a, (.dmark)  
20f9 32 a0 fd			ld (debug_mark),a  
20fc 3a 0b 21			ld a, (.dmark+1)  
20ff 32 a1 fd			ld (debug_mark+1),a  
2102 3a 0c 21			ld a, (.dmark+2)  
2105 32 a2 fd			ld (debug_mark+2),a  
2108 18 03			jr .pastdmark  
210a ..			.dmark: db "PQ3"  
210d f1			.pastdmark: pop af  
210e			endm  
# End of macro DMARK
210e				CALLMONITOR 
210e cd aa fd			call debug_vector  
2111				endm  
# End of macro CALLMONITOR
2111			endif	 
2111 19				add hl,de 
2112			if DEBUG_FORTH_PUSH 
2112						DMARK "PQE" 
2112 f5				push af  
2113 3a 27 21			ld a, (.dmark)  
2116 32 a0 fd			ld (debug_mark),a  
2119 3a 28 21			ld a, (.dmark+1)  
211c 32 a1 fd			ld (debug_mark+1),a  
211f 3a 29 21			ld a, (.dmark+2)  
2122 32 a2 fd			ld (debug_mark+2),a  
2125 18 03			jr .pastdmark  
2127 ..			.dmark: db "PQE"  
212a f1			.pastdmark: pop af  
212b			endm  
# End of macro DMARK
212b				CALLMONITOR 
212b cd aa fd			call debug_vector  
212e				endm  
# End of macro CALLMONITOR
212e			endif	 
212e			 
212e 2b				dec hl    ; see if there is an optional trailing double quote 
212f 7e				ld a,(hl) 
2130 fe 22			cp '"' 
2132 20 03			jr nz, .strnoq 
2134 3e 00			ld a, 0      ; get rid of double quote 
2136 77				ld (hl), a 
2137 23			.strnoq: inc hl 
2138			 
2138 3e 00			ld a, 0 
213a 77				ld (hl), a     ; add null term and get rid of trailing double quote 
213b			 
213b 13				inc de ; add one for the type string 
213c 13				inc de ; add one for null term??? 
213d			 
213d				; tos is get string pointer again 
213d				; de contains space to allocate 
213d				 
213d d5				push de 
213e			 
213e eb				ex de, hl 
213f			 
213f				;push af 
213f			 
213f			if DEBUG_FORTH_PUSH 
213f						DMARK "PHm" 
213f f5				push af  
2140 3a 54 21			ld a, (.dmark)  
2143 32 a0 fd			ld (debug_mark),a  
2146 3a 55 21			ld a, (.dmark+1)  
2149 32 a1 fd			ld (debug_mark+1),a  
214c 3a 56 21			ld a, (.dmark+2)  
214f 32 a2 fd			ld (debug_mark+2),a  
2152 18 03			jr .pastdmark  
2154 ..			.dmark: db "PHm"  
2157 f1			.pastdmark: pop af  
2158			endm  
# End of macro DMARK
2158				CALLMONITOR 
2158 cd aa fd			call debug_vector  
215b				endm  
# End of macro CALLMONITOR
215b			endif	 
215b cd b9 13			call malloc	; on ret hl now contains allocated memory 
215e				if DEBUG_FORTH_MALLOC_GUARD 
215e cc 79 5f				call z,malloc_error 
2161				endif 
2161			 
2161				 
2161 c1				pop bc    ; get length 
2162 d1				pop de   ;  get string start    
2163			 
2163				; hl has destination from malloc 
2163			 
2163 eb				ex de, hl    ; prep for ldir 
2164			 
2164 d5				push de   ; save malloc area for DSP later 
2165				;push hl   ; save malloc area for DSP later 
2165			 
2165			if DEBUG_FORTH_PUSH 
2165						DMARK "PHc" 
2165 f5				push af  
2166 3a 7a 21			ld a, (.dmark)  
2169 32 a0 fd			ld (debug_mark),a  
216c 3a 7b 21			ld a, (.dmark+1)  
216f 32 a1 fd			ld (debug_mark+1),a  
2172 3a 7c 21			ld a, (.dmark+2)  
2175 32 a2 fd			ld (debug_mark+2),a  
2178 18 03			jr .pastdmark  
217a ..			.dmark: db "PHc"  
217d f1			.pastdmark: pop af  
217e			endm  
# End of macro DMARK
217e				CALLMONITOR 
217e cd aa fd			call debug_vector  
2181				endm  
# End of macro CALLMONITOR
2181			endif	 
2181			 
2181			 
2181 ed b0			ldir 
2183			 
2183			 
2183				; push malloc to data stack     macro?????  
2183			 
2183				FORTH_DSP_NEXT 
2183 cd d7 1f			call macro_forth_dsp_next 
2186				endm 
# End of macro FORTH_DSP_NEXT
2186			 
2186				; save value and type 
2186			 
2186 2a 23 f9			ld hl, (cli_data_sp) 
2189			 
2189				; save item type 
2189 3e 01			ld a,  DS_TYPE_STR 
218b 77				ld (hl), a 
218c 23				inc hl 
218d			 
218d				; get malloc word off stack 
218d d1				pop de 
218e 73				ld (hl), e 
218f 23				inc hl 
2190 72				ld (hl), d 
2191			 
2191			 
2191			 
2191			if DEBUG_FORTH_PUSH 
2191 2a 23 f9			ld hl, (cli_data_sp) 
2194						DMARK "PHS" 
2194 f5				push af  
2195 3a a9 21			ld a, (.dmark)  
2198 32 a0 fd			ld (debug_mark),a  
219b 3a aa 21			ld a, (.dmark+1)  
219e 32 a1 fd			ld (debug_mark+1),a  
21a1 3a ab 21			ld a, (.dmark+2)  
21a4 32 a2 fd			ld (debug_mark+2),a  
21a7 18 03			jr .pastdmark  
21a9 ..			.dmark: db "PHS"  
21ac f1			.pastdmark: pop af  
21ad			endm  
# End of macro DMARK
21ad				CALLMONITOR 
21ad cd aa fd			call debug_vector  
21b0				endm  
# End of macro CALLMONITOR
21b0			;	ex de,hl 
21b0			endif	 
21b0				; in case of spaces, skip the ptr past the copied string 
21b0				;pop af 
21b0				;ld (cli_origptr),hl 
21b0			 
21b0 c9				ret 
21b1			 
21b1			 
21b1			 
21b1			; TODO ascii push input onto stack given hl to start of input 
21b1			 
21b1			; identify type 
21b1			; if starts with a " then a string 
21b1			; otherwise it is a number 
21b1			;  
21b1			; if a string 
21b1			;     scan for ending " to get length of string to malloc for + 1 
21b1			;     malloc 
21b1			;     put pointer to string on stack first byte flags as string 
21b1			; 
21b1			; else a number 
21b1			;    look for number format identifier 
21b1			;    $xx hex 
21b1			;    %xxxxx bin 
21b1			;    xxxxx decimal 
21b1			;    convert number to 16bit word.  
21b1			;    malloc word + 1 with flag to identiy as num 
21b1			;    put pointer to number on stack 
21b1			;   
21b1			;  
21b1			  
21b1			forth_apush: 
21b1				; kernel push 
21b1			 
21b1			if DEBUG_FORTH_PUSH 
21b1						DMARK "PSH" 
21b1 f5				push af  
21b2 3a c6 21			ld a, (.dmark)  
21b5 32 a0 fd			ld (debug_mark),a  
21b8 3a c7 21			ld a, (.dmark+1)  
21bb 32 a1 fd			ld (debug_mark+1),a  
21be 3a c8 21			ld a, (.dmark+2)  
21c1 32 a2 fd			ld (debug_mark+2),a  
21c4 18 03			jr .pastdmark  
21c6 ..			.dmark: db "PSH"  
21c9 f1			.pastdmark: pop af  
21ca			endm  
# End of macro DMARK
21ca				CALLMONITOR 
21ca cd aa fd			call debug_vector  
21cd				endm  
# End of macro CALLMONITOR
21cd			endif	 
21cd				; identify input type 
21cd			 
21cd 7e				ld a,(hl) 
21ce			 
21ce fe 23			cp '#' 
21d0 ca 0a 22			jp z, .fapdec 
21d3			 
21d3			 
21d3 fe 22			cp '"' 
21d5 28 0a			jr z, .fapstr 
21d7 fe 24			cp '$' 
21d9 ca 01 22			jp z, .faphex 
21dc fe 25			cp '%' 
21de ca e9 21			jp z, .fapbin 
21e1			;	cp 'b' 
21e1			;	jp z, .fabin 
21e1				; else decimal 
21e1			 
21e1				; TODO do decimal conversion 
21e1				; decimal is stored as a 16bit word 
21e1			 
21e1				; by default everything is a string if type is not detected 
21e1			.fapstr: ; 
21e1 fe 22			cp '"' 
21e3 20 01			jr nz, .strnoqu 
21e5 23				inc hl 
21e6			.strnoqu: 
21e6 c3 b6 20			jp forth_push_str 
21e9			 
21e9			 
21e9			 
21e9			.fapbin:    ; push a binary string.  
21e9 11 00 00			ld de, 0   ; hold a 16bit value 
21ec			 
21ec 23			.fapbinshift:	inc hl  
21ed 7e				ld a,(hl) 
21ee fe 00			cp 0     ; done scanning  
21f0 28 0b			jr z, .fapbdone  	; got it in HL so push  
21f2			 
21f2				; left shift de 
21f2 eb				ex de, hl	 
21f3 29				add hl, hl 
21f4			 
21f4				; is 1 
21f4 fe 31			cp '1' 
21f6 20 02			jr nz, .binzero 
21f8 cb 4d			bit 1, l 
21fa			.binzero: 
21fa eb				ex de, hl	 ; save current de 
21fb 18 ef			jr .fapbinshift 
21fd			 
21fd			.fapbdone: 
21fd eb				ex de, hl 
21fe c3 48 20			jp forth_push_numhl 
2201			 
2201			 
2201			.faphex:   ; hex is always stored as a 16bit word 
2201				; skip number prefix 
2201 23				inc hl 
2202				; turn ascii into number 
2202 cd 9d 12			call get_word_hl	; ret 16bit word in hl 
2205			 
2205 c3 48 20			jp forth_push_numhl 
2208			 
2208 00				 nop 
2209			 
2209			.fabin:   ; TODO bin conversion 
2209			 
2209			 
2209 c9				ret 
220a			.fapdec:	 
220a				; string to dec conversion 
220a 23				inc hl 
220b eb				ex de, hl 
220c cd db 12			call string_to_uint16 
220f c3 48 20			jp forth_push_numhl 
2212 c9				ret 
2213				 
2213			;atoui_16: 
2213			 
2213			; get either a string ptr or a 16bit word from the data stack 
2213			 
2213			FORTH_DSP: macro 
2213				call macro_forth_dsp 
2213				endm 
2213			 
2213			macro_forth_dsp: 
2213				; data stack pointer points to current word on tos 
2213			 
2213 2a 23 f9			ld hl,(cli_data_sp) 
2216			 
2216				if DEBUG_FORTH_PUSH 
2216						DMARK "DSP" 
2216 f5				push af  
2217 3a 2b 22			ld a, (.dmark)  
221a 32 a0 fd			ld (debug_mark),a  
221d 3a 2c 22			ld a, (.dmark+1)  
2220 32 a1 fd			ld (debug_mark+1),a  
2223 3a 2d 22			ld a, (.dmark+2)  
2226 32 a2 fd			ld (debug_mark+2),a  
2229 18 03			jr .pastdmark  
222b ..			.dmark: db "DSP"  
222e f1			.pastdmark: pop af  
222f			endm  
# End of macro DMARK
222f			 
222f cd ac 5f				call display_data_sp 
2232				;call break_point_state 
2232				;rst 030h 
2232				CALLMONITOR 
2232 cd aa fd			call debug_vector  
2235				endm  
# End of macro CALLMONITOR
2235				endif 
2235			 
2235 c9				ret 
2236			 
2236			; return hl to start of value on stack 
2236			 
2236			FORTH_DSP_VALUE: macro 
2236				call macro_forth_dsp_value 
2236				endm 
2236			 
2236			macro_forth_dsp_value: 
2236			 
2236				FORTH_DSP 
2236 cd 13 22			call macro_forth_dsp 
2239				endm 
# End of macro FORTH_DSP
2239			 
2239 d5				push de 
223a			 
223a 23				inc hl ; skip type 
223b			 
223b 5e				ld e, (hl) 
223c 23				inc hl 
223d 56				ld d, (hl) 
223e eb				ex de,hl  
223f			 
223f d1				pop de 
2240			 
2240 c9				ret 
2241			 
2241			; return hl to start of value to second item on stack 
2241			 
2241			FORTH_DSP_VALUEM1: macro 
2241				call macro_forth_dsp_value_m1 
2241				endm 
2241			 
2241			macro_forth_dsp_value_m1: 
2241			 
2241				FORTH_DSP 
2241 cd 13 22			call macro_forth_dsp 
2244				endm 
# End of macro FORTH_DSP
2244			 
2244 2b				dec hl 
2245 2b				dec hl 
2246			;	dec hl 
2246			 
2246 d5				push de 
2247			 
2247 5e				ld e, (hl) 
2248 23				inc hl 
2249 56				ld d, (hl) 
224a eb				ex de,hl  
224b			 
224b d1				pop de 
224c			 
224c c9				ret 
224d			 
224d				 
224d			 
224d			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
224d			 
224d			FORTH_DSP_POP: macro 
224d				call macro_forth_dsp_pop 
224d				endm 
224d			 
224d			 
224d			; get the tos data type 
224d			 
224d			FORTH_DSP_TYPE:   macro 
224d			 
224d				;FORTH_DSP_VALUE 
224d				FORTH_DSP 
224d				 
224d				; hl points to value 
224d				; check type 
224d			 
224d				ld a,(hl) 
224d			 
224d				endm 
224d			 
224d			; load the tos value into hl 
224d			 
224d			 
224d			FORTH_DSP_VALUEHL:  macro 
224d				call macro_dsp_valuehl 
224d				endm 
224d			 
224d			 
224d			 
224d			macro_dsp_valuehl: 
224d				FORTH_DSP_VALUE 
224d cd 36 22			call macro_forth_dsp_value 
2250				endm 
# End of macro FORTH_DSP_VALUE
2250			 
2250				;FORTH_ERR_TOS_NOTNUM 
2250			 
2250				;inc hl   ; skip type id 
2250			 
2250			;	push de 
2250			; 
2250			;	ld e, (hl) 
2250			;	inc hl 
2250			;	ld d, (hl) 
2250			;	ex de,hl  
2250			 
2250			;	pop de 
2250			 
2250				if DEBUG_FORTH_PUSH 
2250						DMARK "DVL" 
2250 f5				push af  
2251 3a 65 22			ld a, (.dmark)  
2254 32 a0 fd			ld (debug_mark),a  
2257 3a 66 22			ld a, (.dmark+1)  
225a 32 a1 fd			ld (debug_mark+1),a  
225d 3a 67 22			ld a, (.dmark+2)  
2260 32 a2 fd			ld (debug_mark+2),a  
2263 18 03			jr .pastdmark  
2265 ..			.dmark: db "DVL"  
2268 f1			.pastdmark: pop af  
2269			endm  
# End of macro DMARK
2269				CALLMONITOR 
2269 cd aa fd			call debug_vector  
226c				endm  
# End of macro CALLMONITOR
226c				endif 
226c c9				ret 
226d			 
226d			forth_apushstrhl:      
226d				; push of string requires use of cli_origptr 
226d				; bodge use 
226d			 
226d				; get current cli_origptr, save, update with temp pointer  
226d ed 5b 73 f9		ld de, (cli_origptr) 
2271 22 73 f9			ld (cli_origptr), hl 
2274 d5				push de 
2275 cd b1 21			call forth_apush 
2278 d1				pop de 
2279 ed 53 73 f9		ld (cli_origptr), de 
227d c9			        ret	 
227e			 
227e			 
227e			; increase loop stack pointer and save hl to it 
227e				 
227e			FORTH_LOOP_NEXT: macro 
227e				call macro_forth_loop_next 
227e				;nop 
227e				endm 
227e			 
227e			macro_forth_loop_next: 
227e				if DEBUG_FORTH_STACK_GUARD 
227e cd 26 6d				call check_stacks 
2281				endif 
2281 e5				push hl 
2282 d5				push de 
2283 eb				ex de,hl 
2284 2a 25 f9			ld hl,(cli_loop_sp) 
2287 23				inc hl 
2288 23				inc hl 
2289					if DEBUG_FORTH_WORDS 
2289						DMARK "LNX" 
2289 f5				push af  
228a 3a 9e 22			ld a, (.dmark)  
228d 32 a0 fd			ld (debug_mark),a  
2290 3a 9f 22			ld a, (.dmark+1)  
2293 32 a1 fd			ld (debug_mark+1),a  
2296 3a a0 22			ld a, (.dmark+2)  
2299 32 a2 fd			ld (debug_mark+2),a  
229c 18 03			jr .pastdmark  
229e ..			.dmark: db "LNX"  
22a1 f1			.pastdmark: pop af  
22a2			endm  
# End of macro DMARK
22a2						CALLMONITOR 
22a2 cd aa fd			call debug_vector  
22a5				endm  
# End of macro CALLMONITOR
22a5					endif 
22a5 22 25 f9			ld (cli_loop_sp),hl 
22a8 73				ld (hl), e 
22a9 23				inc hl 
22aa 72				ld (hl), d 
22ab d1				pop de    ; been reversed so save a swap on restore 
22ac e1				pop hl 
22ad				if DEBUG_FORTH_STACK_GUARD 
22ad cd 26 6d				call check_stacks 
22b0				endif 
22b0 c9				ret 
22b1			 
22b1			; get current ret stack pointer and save to hl  
22b1				 
22b1			FORTH_LOOP_TOS: macro 
22b1				call macro_forth_loop_tos 
22b1				endm 
22b1			 
22b1			macro_forth_loop_tos: 
22b1 d5				push de 
22b2 2a 25 f9			ld hl,(cli_loop_sp) 
22b5 5e				ld e, (hl) 
22b6 23				inc hl 
22b7 56				ld d, (hl) 
22b8 eb				ex de, hl 
22b9 d1				pop de 
22ba c9				ret 
22bb			 
22bb			; pop loop stack pointer 
22bb				 
22bb			FORTH_LOOP_POP: macro 
22bb				call macro_forth_loop_pop 
22bb				endm 
22bb			 
22bb			 
22bb			macro_forth_loop_pop: 
22bb				if DEBUG_FORTH_STACK_GUARD 
22bb					DMARK "LPP" 
22bb f5				push af  
22bc 3a d0 22			ld a, (.dmark)  
22bf 32 a0 fd			ld (debug_mark),a  
22c2 3a d1 22			ld a, (.dmark+1)  
22c5 32 a1 fd			ld (debug_mark+1),a  
22c8 3a d2 22			ld a, (.dmark+2)  
22cb 32 a2 fd			ld (debug_mark+2),a  
22ce 18 03			jr .pastdmark  
22d0 ..			.dmark: db "LPP"  
22d3 f1			.pastdmark: pop af  
22d4			endm  
# End of macro DMARK
22d4 cd 26 6d				call check_stacks 
22d7					FORTH_CHK_LOOP_UNDER 
22d7 e5				push hl 
22d8 d5				push de 
22d9 2a 25 f9			ld hl,(cli_loop_sp) 
22dc 11 5f f8			ld de, cli_loop_stack 
22df cd fc 0f			call cmp16 
22e2 da 43 6e			jp c, fault_loop_under 
22e5 d1				pop de 
22e6 e1				pop hl 
22e7				endm 
# End of macro FORTH_CHK_LOOP_UNDER
22e7				endif 
22e7 e5				push hl 
22e8 2a 25 f9			ld hl,(cli_loop_sp) 
22eb 2b				dec hl 
22ec 2b				dec hl 
22ed 22 25 f9			ld (cli_loop_sp), hl 
22f0				; TODO do stack underflow checks 
22f0 e1				pop hl 
22f1				if DEBUG_FORTH_STACK_GUARD 
22f1 cd 26 6d				call check_stacks 
22f4					FORTH_CHK_LOOP_UNDER 
22f4 e5				push hl 
22f5 d5				push de 
22f6 2a 25 f9			ld hl,(cli_loop_sp) 
22f9 11 5f f8			ld de, cli_loop_stack 
22fc cd fc 0f			call cmp16 
22ff da 43 6e			jp c, fault_loop_under 
2302 d1				pop de 
2303 e1				pop hl 
2304				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2304				endif 
2304 c9				ret 
2305			 
2305			macro_forth_dsp_pop: 
2305			 
2305 e5				push hl 
2306			 
2306				; release malloc data 
2306			 
2306				if DEBUG_FORTH_STACK_GUARD 
2306 cd 26 6d				call check_stacks 
2309					FORTH_CHK_DSP_UNDER 
2309 e5				push hl 
230a d5				push de 
230b 2a 23 f9			ld hl,(cli_data_sp) 
230e 11 5d f6			ld de, cli_data_stack 
2311 cd fc 0f			call cmp16 
2314 da 37 6e			jp c, fault_dsp_under 
2317 d1				pop de 
2318 e1				pop hl 
2319				endm 
# End of macro FORTH_CHK_DSP_UNDER
2319				endif 
2319				;ld hl,(cli_data_sp) 
2319			if DEBUG_FORTH_DOT 
2319				DMARK "DPP" 
2319 f5				push af  
231a 3a 2e 23			ld a, (.dmark)  
231d 32 a0 fd			ld (debug_mark),a  
2320 3a 2f 23			ld a, (.dmark+1)  
2323 32 a1 fd			ld (debug_mark+1),a  
2326 3a 30 23			ld a, (.dmark+2)  
2329 32 a2 fd			ld (debug_mark+2),a  
232c 18 03			jr .pastdmark  
232e ..			.dmark: db "DPP"  
2331 f1			.pastdmark: pop af  
2332			endm  
# End of macro DMARK
2332				CALLMONITOR 
2332 cd aa fd			call debug_vector  
2335				endm  
# End of macro CALLMONITOR
2335			endif	 
2335			 
2335			 
2335			if FORTH_ENABLE_DSPPOPFREE 
2335			 
2335				FORTH_DSP 
2335 cd 13 22			call macro_forth_dsp 
2338				endm 
# End of macro FORTH_DSP
2338			 
2338 7e				ld a, (hl) 
2339 fe 01			cp DS_TYPE_STR 
233b 20 23			jr nz, .skippopfree 
233d			 
233d				FORTH_DSP_VALUEHL 
233d cd 4d 22			call macro_dsp_valuehl 
2340				endm 
# End of macro FORTH_DSP_VALUEHL
2340 00				nop 
2341			if DEBUG_FORTH_DOT 
2341				DMARK "DPf" 
2341 f5				push af  
2342 3a 56 23			ld a, (.dmark)  
2345 32 a0 fd			ld (debug_mark),a  
2348 3a 57 23			ld a, (.dmark+1)  
234b 32 a1 fd			ld (debug_mark+1),a  
234e 3a 58 23			ld a, (.dmark+2)  
2351 32 a2 fd			ld (debug_mark+2),a  
2354 18 03			jr .pastdmark  
2356 ..			.dmark: db "DPf"  
2359 f1			.pastdmark: pop af  
235a			endm  
# End of macro DMARK
235a				CALLMONITOR 
235a cd aa fd			call debug_vector  
235d				endm  
# End of macro CALLMONITOR
235d			endif	 
235d cd 83 14			call free 
2360			.skippopfree: 
2360				 
2360			 
2360			endif 
2360			 
2360			if DEBUG_FORTH_DOT_KEY 
2360				DMARK "DP2" 
2360				CALLMONITOR 
2360			endif	 
2360			 
2360				; move pointer down 
2360			 
2360 2a 23 f9			ld hl,(cli_data_sp) 
2363 2b				dec hl 
2364 2b				dec hl 
2365			; PARSEV5 
2365 2b				dec hl 
2366 22 23 f9			ld (cli_data_sp), hl 
2369			 
2369				if DEBUG_FORTH_STACK_GUARD 
2369 cd 26 6d				call check_stacks 
236c					FORTH_CHK_DSP_UNDER 
236c e5				push hl 
236d d5				push de 
236e 2a 23 f9			ld hl,(cli_data_sp) 
2371 11 5d f6			ld de, cli_data_stack 
2374 cd fc 0f			call cmp16 
2377 da 37 6e			jp c, fault_dsp_under 
237a d1				pop de 
237b e1				pop hl 
237c				endm 
# End of macro FORTH_CHK_DSP_UNDER
237c				endif 
237c			 
237c e1				pop hl 
237d			 
237d c9				ret 
237e			 
237e			getwordathl: 
237e				; hl points to an address 
237e				; load hl with the word at that address 
237e			 
237e d5				push de 
237f			 
237f 5e				ld e, (hl) 
2380 23				inc hl 
2381 56				ld d, (hl) 
2382 eb				ex de, hl 
2383			 
2383 d1				pop de 
2384 c9				ret 
2385			 
2385			 
2385			; functions to manuplite stack pointers 
2385			 
2385			; generate fragment to set hl to be pointer to a stack item 
2385			 
2385			FORTH_DSP_PTR: macro  x 
2385				ld hl,(cli_data_sp) 
2385				ld de, x * 3 
2385				sbc hl, de 
2385				endm 
2385			 
2385			 
2385			 
2385			; copy point in hl to stack tmp storage slots 1-4 
2385			hltostack1: 
2385 11 f3 f0			ld de, os_stack_1  
2388 c3 b3 23			jp hltostackmv 
238b			 
238b			hltostack2:  
238b 11 f0 f0			ld de, os_stack_2 
238e c3 b3 23			jp hltostackmv 
2391			 
2391			hltostack3:  
2391 11 ed f0			ld de, os_stack_3 
2394 c3 b3 23			jp hltostackmv 
2397			 
2397			hltostack4:  
2397 11 ea f0			ld de, os_stack_4  
239a c3 b3 23			jp hltostackmv 
239d			 
239d			; copy to point in hl from stack tmp storage slots 1-4 
239d			hlfromstack1: 
239d 11 f3 f0			ld de, os_stack_1 
23a0 c3 b2 23			jp hlfromsttackmv 
23a3			 
23a3			hlfromstack2:  
23a3 11 f0 f0			ld de, os_stack_2 
23a6 c3 b2 23			jp hlfromsttackmv 
23a9			 
23a9			hlfromstack3:  
23a9 11 ed f0			ld de, os_stack_3 
23ac c3 b2 23			jp hlfromsttackmv 
23af			 
23af			hlfromstack4:  
23af 11 ea f0			ld de, os_stack_4 
23b2			 
23b2			hlfromsttackmv: 
23b2 eb				ex de, hl 
23b3			 
23b3			hltostackmv: 
23b3			 
23b3				; do stack move 
23b3 c5				push bc 
23b4 01 03 00			ld bc, 3 
23b7 ed b0			ldir  
23b9 c1				pop bc	 
23ba c9				ret 
23bb			 
23bb			; eof 
23bb			 
# End of file forth_stackopsv5.asm
23bb			endif 
23bb			 
23bb			loadwordinhl:	 
23bb			 
23bb d5				push de 
23bc			 
23bc 5e				ld e, (hl) 
23bd 23				inc hl 
23be 56				ld d, (hl) 
23bf eb				ex de,hl  
23c0			 
23c0 d1				pop de 
23c1			 
23c1 c9				ret 
23c2			 
23c2			user_word_eol:  
23c2				; hl contains the pointer to where to create a linked list item from the end 
23c2				; of the user dict to continue on at the system word dict 
23c2				 
23c2				; poke the stub of the word list linked list to repoint to rom words 
23c2			 
23c2				; stub format 
23c2				; db   word id 
23c2				; dw    link to next word 
23c2			        ; db char length of token 
23c2				; db string + 0 term 
23c2				; db exec code....  
23c2			 
23c2 3e 00			ld a, WORD_SYS_ROOT     ; root word 
23c4 77				ld (hl), a		; word id 
23c5 23				inc hl 
23c6			 
23c6 11 91 25			ld de, sysdict 
23c9 73				ld (hl), e		; next word link ie system dict 
23ca 23				inc hl 
23cb 72				ld (hl), d		; next word link ie system dict 
23cc 23				inc hl	 
23cd			 
23cd			;	ld (hl), sysdict		; next word link ie system dict 
23cd			;	inc hl 
23cd			;	inc hl 
23cd			 
23cd			;	inc hl 
23cd			;	inc hl 
23cd			 
23cd 3e 02			ld a, 2			; word length is 0 
23cf 77				ld (hl), a	 
23d0 23				inc hl 
23d1			 
23d1 3e 7e			ld a, '~'			; word length is 0 
23d3 77				ld (hl), a	 
23d4 23				inc hl 
23d5 3e 00			ld a, 0			; save empty word 
23d7 77				ld (hl), a 
23d8			 
23d8 c9				ret 
23d9			 
23d9				 
23d9			 
23d9			forthexec_cleanup: 
23d9				FORTH_RSP_POP 
23d9 cd 10 20			call macro_forth_rsp_pop 
23dc				endm 
# End of macro FORTH_RSP_POP
23dc c9				ret 
23dd			 
23dd			forth_call_hl: 
23dd				; taking hl 
23dd e5				push hl 
23de c9				ret 
23df			 
23df			; this is called to reset Forth system but keep existing uwords etc 
23df			 
23df			forth_warmstart: 
23df				; setup stack over/under flow checks 
23df				if DEBUG_FORTH_STACK_GUARD 
23df cd 0c 6d				call chk_stk_init 
23e2				endif 
23e2			 
23e2				; init stack pointers  - * these stacks go upwards *  
23e2 21 e1 f8			ld hl, cli_ret_stack 
23e5 22 27 f9			ld (cli_ret_sp), hl	 
23e8				; set bottom of stack 
23e8 3e 00			ld a,0 
23ea 77				ld (hl),a 
23eb 23				inc hl 
23ec 77				ld (hl),a 
23ed			 
23ed 21 5d f6			ld hl, cli_data_stack 
23f0 22 23 f9			ld (cli_data_sp), hl	 
23f3				; set bottom of stack 
23f3 3e 00			ld a,0 
23f5 77				ld (hl),a 
23f6 23				inc hl 
23f7 77				ld (hl),a 
23f8			 
23f8 21 5f f8			ld hl, cli_loop_stack 
23fb 22 25 f9			ld (cli_loop_sp), hl	 
23fe				; set bottom of stack 
23fe 3e 00			ld a,0 
2400 77				ld (hl),a 
2401 23				inc hl 
2402 77				ld (hl),a 
2403			 
2403				; init extent of current open file 
2403			 
2403 3e 00			ld a, 0 
2405 32 9f f9			ld (store_openext), a 
2408			 
2408 c9				ret 
2409			 
2409			 
2409			 
2409			; Cold Start - this is called to setup the whole Forth system 
2409			 
2409			forth_init: 
2409			 
2409				; setup stack over/under flow checks 
2409			 
2409			;	if DEBUG_FORTH_STACK_GUARD 
2409			;		call chk_stk_init 
2409			;	endif 
2409			 
2409				; enable auto display updates (slow.....) 
2409			 
2409 3e 01			ld a, 1 
240b 32 71 f9			ld (cli_autodisplay), a 
240e			 
240e				; if storage is in use disable long reads for now 
240e 3e 00			ld a, 0 
2410 32 aa f9			ld (store_longread), a 
2413			 
2413			 
2413				; show start up screen 
2413			 
2413 cd aa 0d			call clear_display 
2416			 
2416 3e 00			ld a,0 
2418 32 93 f9			ld (f_cursor_ptr), a 
241b			 
241b				; set start of word list in start of ram - for use when creating user words 
241b			 
241b 21 00 80			ld hl, baseram 
241e 22 f3 f3			ld (os_last_new_uword), hl 
2421 cd c2 23			call user_word_eol 
2424				 
2424			;		call display_data_sp 
2424			;		call next_page_prompt 
2424			 
2424			 
2424			 
2424			 
2424 c9				ret 
2425			 
2425 .. 00		.bootforth: db " Forth Kernel Init ",0 
2439			 
2439			; TODO push to stack 
2439			 
2439			;  
2439			 
2439			if FORTH_PARSEV2 
2439			 
2439			 
2439				include "forth_parserv2.asm" 
2439			 
2439			endif 
2439			 
2439			 
2439			; parse cli version 1 
2439			 
2439			if FORTH_PARSEV1 
2439			 
2439			 
2439			 
2439			      include "forth_parserv1.asm" 
2439			endif 
2439				 
2439			if FORTH_PARSEV3 
2439			 
2439			 
2439			 
2439			      include "forth_parserv3.asm" 
2439				include "forth_wordsv3.asm" 
2439			endif 
2439			 
2439			if FORTH_PARSEV4 
2439			 
2439			 
2439			 
2439			      include "forth_parserv4.asm" 
2439				include "forth_wordsv4.asm" 
2439			endif 
2439			 
2439			if FORTH_PARSEV5 
2439			 
2439			 
2439			 
2439			      include "forth_parserv5.asm" 
2439			 
2439			 
2439			; A better parser without using malloc and string copies all over the place.  
2439			; Exec in situ should be faster 
2439			 
2439			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
2439			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
2439			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
2439			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
2439			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
2439			WORD_SYS_END: equ 0   ; Opcode for all user words 
2439			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
2439			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
2439			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
2439			 
2439			; Core word preamble macro 
2439			 
2439			CWHEAD:   macro nxtword opcode lit len opflags 
2439				db WORD_SYS_CORE+opcode             
2439				; internal op code number 
2439				dw nxtword            
2439				; link to next dict word block 
2439				db len + 1 
2439				; literal length of dict word inc zero term 
2439				db lit,0              
2439				; literal dict word 
2439			        ; TODO db opflags        
2439				endm 
2439			 
2439			 
2439			NEXTW: macro  
2439				jp macro_next 
2439				endm 
2439			 
2439			macro_next: 
2439			if DEBUG_FORTH_PARSE_KEY 
2439				DMARK "NXT" 
2439				CALLMONITOR 
2439			endif	 
2439			;	inc hl  ; skip token null term  
2439 ed 4b 75 f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
243d ed 5b 73 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
2441 2a f7 f3			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
2444			if DEBUG_FORTH_PARSE_KEY 
2444				DMARK "}AA" 
2444				CALLMONITOR 
2444			endif	 
2444 c3 47 25			jp execnext 
2447				;jp exec1 
2447			       
2447			 
2447			 
2447			; Another go at the parser to compile  
2447			 
2447			 
2447			; TODO rework parser to change all of the string words to byte tokens 
2447			; TODO do a search for  
2447			 
2447			; TODO first run normal parser to zero term sections 
2447			; TODO for each word do a token look up to get the op code 
2447			; TODO need some means to flag to the exec that this is a byte code form    
2447			 
2447			 
2447			forthcompile: 
2447			 
2447			; 
2447			; line parse: 
2447			;       parse raw input buffer 
2447			;       tokenise the words 
2447			;       malloc new copy (for looping etc) 
2447			;       copy to malloc + current pc in line to start of string and add line term 
2447			;       save on new rsp 
2447			; 
2447			 
2447			; hl to point to the line to tokenise 
2447			 
2447			;	push hl 
2447 22 f7 f3			ld (os_tok_ptr), hl  ; save ptr to string 
244a			 
244a			;	ld a,0		; string term on input 
244a			;	call strlent 
244a			 
244a			;	ld (os_tok_len), hl	 ; save string length 
244a			 
244a			;if DEBUG_FORTH_TOK 
244a			;	ex de,hl		 
244a			;endif 
244a			 
244a			;	pop hl 		; get back string pointer 
244a			 
244a			if DEBUG_FORTH_TOK 
244a						DMARK "TOc" 
244a				CALLMONITOR 
244a			endif 
244a 7e			.cptoken2:    ld a,(hl) 
244b 23				inc hl 
244c fe 7f			cp FORTH_END_BUFFER 
244e 28 29			jr z, .cptokendone2 
2450 fe 00			cp 0 
2452 28 25			jr z, .cptokendone2 
2454 fe 22			cp '"' 
2456 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2458 fe 20			cp ' ' 
245a 20 ee			jr nz,  .cptoken2 
245c			 
245c			; TODO consume comments held between ( and ) 
245c			 
245c				; we have a space so change to zero term for dict match later 
245c 2b				dec hl 
245d 3e 00			ld a,0 
245f 77				ld (hl), a 
2460 23				inc hl 
2461 18 e7			jr .cptoken2 
2463				 
2463			 
2463			.cptokenstr2: 
2463				; skip all white space until either eol (because forgot to term) or end double quote 
2463			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2463				;inc hl ; skip current double quote 
2463 7e				ld a,(hl) 
2464 23				inc hl 
2465 fe 22			cp '"' 
2467 28 e1			jr z, .cptoken2 
2469 fe 7f			cp FORTH_END_BUFFER 
246b 28 0c			jr z, .cptokendone2 
246d fe 00			cp 0 
246f 28 08			jr z, .cptokendone2 
2471 fe 20			cp ' ' 
2473 28 02			jr z, .cptmp2 
2475 18 ec			jr .cptokenstr2 
2477			 
2477			.cptmp2:	; we have a space so change to zero term for dict match later 
2477				;dec hl 
2477				;ld a,"-"	; TODO remove this when working 
2477				;ld (hl), a 
2477				;inc hl 
2477 18 ea			jr .cptokenstr2 
2479			 
2479			.cptokendone2: 
2479				;inc hl 
2479 3e 7f			ld a, FORTH_END_BUFFER 
247b 77				ld (hl),a 
247c 23				inc hl 
247d 3e 21			ld a, '!' 
247f 77				ld (hl),a 
2480			 
2480 2a f7 f3			ld hl,(os_tok_ptr) 
2483			         
2483			if DEBUG_FORTH_TOK 
2483						DMARK "Tc1" 
2483				CALLMONITOR 
2483			endif 
2483			 
2483				; push exec string to top of return stack 
2483				FORTH_RSP_NEXT 
2483 cd ef 1f			call macro_forth_rsp_next 
2486				endm 
# End of macro FORTH_RSP_NEXT
2486 c9				ret 
2487			 
2487			; Another go at the parser need to simplify the process 
2487			 
2487			forthparse: 
2487			 
2487			; 
2487			; line parse: 
2487			;       parse raw input buffer 
2487			;       tokenise the words 
2487			;       malloc new copy (for looping etc) 
2487			;       copy to malloc + current pc in line to start of string and add line term 
2487			;       save on new rsp 
2487			; 
2487			 
2487			; hl to point to the line to tokenise 
2487			 
2487			;	push hl 
2487 22 f7 f3			ld (os_tok_ptr), hl  ; save ptr to string 
248a			 
248a			;	ld a,0		; string term on input 
248a			;	call strlent 
248a			 
248a			;	ld (os_tok_len), hl	 ; save string length 
248a			 
248a			;if DEBUG_FORTH_TOK 
248a			;	ex de,hl		 
248a			;endif 
248a			 
248a			;	pop hl 		; get back string pointer 
248a			 
248a			if DEBUG_FORTH_TOK 
248a						DMARK "TOK" 
248a				CALLMONITOR 
248a			endif 
248a 7e			.ptoken2:    ld a,(hl) 
248b 23				inc hl 
248c fe 7f			cp FORTH_END_BUFFER 
248e 28 29			jr z, .ptokendone2 
2490 fe 00			cp 0 
2492 28 25			jr z, .ptokendone2 
2494 fe 22			cp '"' 
2496 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2498 fe 20			cp ' ' 
249a 20 ee			jr nz,  .ptoken2 
249c			 
249c			; TODO consume comments held between ( and ) 
249c			 
249c				; we have a space so change to zero term for dict match later 
249c 2b				dec hl 
249d 3e 00			ld a,0 
249f 77				ld (hl), a 
24a0 23				inc hl 
24a1 18 e7			jr .ptoken2 
24a3				 
24a3			 
24a3			.ptokenstr2: 
24a3				; skip all white space until either eol (because forgot to term) or end double quote 
24a3			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
24a3				;inc hl ; skip current double quote 
24a3 7e				ld a,(hl) 
24a4 23				inc hl 
24a5 fe 22			cp '"' 
24a7 28 e1			jr z, .ptoken2 
24a9 fe 7f			cp FORTH_END_BUFFER 
24ab 28 0c			jr z, .ptokendone2 
24ad fe 00			cp 0 
24af 28 08			jr z, .ptokendone2 
24b1 fe 20			cp ' ' 
24b3 28 02			jr z, .ptmp2 
24b5 18 ec			jr .ptokenstr2 
24b7			 
24b7			.ptmp2:	; we have a space so change to zero term for dict match later 
24b7				;dec hl 
24b7				;ld a,"-"	; TODO remove this when working 
24b7				;ld (hl), a 
24b7				;inc hl 
24b7 18 ea			jr .ptokenstr2 
24b9			 
24b9			.ptokendone2: 
24b9				;inc hl 
24b9 3e 7f			ld a, FORTH_END_BUFFER 
24bb 77				ld (hl),a 
24bc 23				inc hl 
24bd 3e 21			ld a, '!' 
24bf 77				ld (hl),a 
24c0			 
24c0 2a f7 f3			ld hl,(os_tok_ptr) 
24c3			         
24c3			if DEBUG_FORTH_TOK 
24c3						DMARK "TK1" 
24c3				CALLMONITOR 
24c3			endif 
24c3			 
24c3				; push exec string to top of return stack 
24c3				FORTH_RSP_NEXT 
24c3 cd ef 1f			call macro_forth_rsp_next 
24c6				endm 
# End of macro FORTH_RSP_NEXT
24c6 c9				ret 
24c7			 
24c7			; 
24c7			;	; malloc size + buffer pointer + if is loop flag 
24c7			;	ld hl,(os_tok_len) 		 ; get string length 
24c7			; 
24c7			;	ld a,l 
24c7			; 
24c7			;	cp 0			; we dont want to use a null string 
24c7			;	ret z 
24c7			; 
24c7			;;	add 3    ; prefix malloc with buffer for current word ptr 
24c7			; 
24c7			;	add 5     ; TODO when certain not over writing memory remove 
24c7			; 
24c7			;		 
24c7			; 
24c7			;if DEBUG_FORTH_TOK 
24c7			;			DMARK "TKE" 
24c7			;	CALLMONITOR 
24c7			;endif 
24c7			; 
24c7			;	ld l,a 
24c7			;	ld h,0 
24c7			;;	push hl   ; save required space for the copy later 
24c7			;	call malloc 
24c7			;if DEBUG_FORTH_TOK 
24c7			;			DMARK "TKM" 
24c7			;	CALLMONITOR 
24c7			;endif 
24c7			;	if DEBUG_FORTH_MALLOC_GUARD 
24c7			;		push af 
24c7			;		call ishlzero 
24c7			;;		ld a, l 
24c7			;;		add h 
24c7			;;		cp 0 
24c7			;		pop af 
24c7			;		 
24c7			;		call z,malloc_error 
24c7			;	endif 
24c7			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
24c7			; 
24c7			; 
24c7			;if DEBUG_FORTH_TOK 
24c7			;			DMARK "TKR" 
24c7			;	CALLMONITOR 
24c7			;endif 
24c7			; 
24c7			;	FORTH_RSP_NEXT 
24c7			; 
24c7			;	;inc hl	 ; go past current buffer pointer 
24c7			;	;inc hl 
24c7			;	;inc hl   ; and past if loop flag 
24c7			;		; TODO Need to set flag  
24c7			; 
24c7			;	 
24c7			;	 
24c7			;	ex de,hl	; malloc is dest 
24c7			;	ld hl, (os_tok_len) 
24c7			;;	pop bc 
24c7			;	ld c, l                
24c7			;	ld b,0 
24c7			;	ld hl, (os_tok_ptr) 
24c7			; 
24c7			;if DEBUG_FORTH_TOK 
24c7			;			DMARK "TKT" 
24c7			;	CALLMONITOR 
24c7			;endif 
24c7			; 
24c7			;	; do str cpy 
24c7			; 
24c7			;	ldir      ; copy byte in hl to de 
24c7			; 
24c7			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
24c7			; 
24c7			;if DEBUG_FORTH_TOK 
24c7			; 
24c7			;			DMARK "TKY" 
24c7			;	CALLMONITOR 
24c7			;endif 
24c7			;	;ld a,0 
24c7			;	;ld a,FORTH_END_BUFFER 
24c7			;	ex de, hl 
24c7			;	;dec hl			 ; go back over the space delim at the end of word 
24c7			;	;ld (hl),a 
24c7			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
24c7			;	ld a,FORTH_END_BUFFER 
24c7			;	ld (hl),a 
24c7			;	inc hl 
24c7			;	ld a,FORTH_END_BUFFER 
24c7			;	ld (hl),a 
24c7			; 
24c7			;	; init the malloc area data 
24c7			;	; set pc for in current area 
24c7			;	;ld hl, (os_tok_malloc) 
24c7			;	;inc hl 
24c7			;	;inc hl 
24c7			;	;inc hl 
24c7			;	;ex de,hl 
24c7			;	;ld hl, (os_tok_malloc) 
24c7			;	;ld (hl),e 
24c7			;	;inc hl 
24c7			;	;ld (hl),d 
24c7			; 
24c7			; 
24c7			;	ld hl,(os_tok_malloc) 
24c7			;if DEBUG_FORTH_PARSE_KEY 
24c7			;			DMARK "TKU" 
24c7			;	CALLMONITOR 
24c7			;endif 
24c7			; 
24c7			;	ret 
24c7			 
24c7			forthexec: 
24c7			 
24c7			; line exec: 
24c7			; forth parser 
24c7			 
24c7			; 
24c7			;       get current exec line on rsp 
24c7			 
24c7				FORTH_RSP_TOS 
24c7 cd 06 20			call macro_forth_rsp_tos 
24ca				endm 
# End of macro FORTH_RSP_TOS
24ca			 
24ca			;       restore current pc - hl points to malloc of data 
24ca			 
24ca				;ld e, (hl) 
24ca				;inc hl 
24ca				;ld d, (hl) 
24ca				;ex de,hl 
24ca			 
24ca			 
24ca			exec1: 
24ca 22 f7 f3			ld (os_tok_ptr), hl 
24cd			 
24cd				; copy our PC to working vars  
24cd 22 75 f9			ld (cli_ptr), hl 
24d0 22 73 f9			ld (cli_origptr), hl 
24d3			 
24d3 7e				ld a,(hl) 
24d4 fe 7f			cp FORTH_END_BUFFER 
24d6 c8				ret z 
24d7			 
24d7				; skip any nulls 
24d7			 
24d7 fe 00			cp 0 
24d9 20 03			jr nz, .execword 
24db 23				inc hl 
24dc 18 ec			jr exec1 
24de			 
24de			 
24de			.execword: 
24de			 
24de			 
24de			 
24de			if DEBUG_FORTH_PARSE_KEY 
24de						DMARK "KYQ" 
24de				CALLMONITOR 
24de			endif 
24de			;       while at start of word: 
24de			; get start of dict (in user area first) 
24de			 
24de 21 00 80		ld hl, baseram 
24e1			;ld hl, sysdict 
24e1 22 77 f9		ld (cli_nextword),hl 
24e4			;           match word at pc 
24e4			;           exec word 
24e4			;           or push to dsp 
24e4			;           forward to next token 
24e4			;           if line term pop rsp and exit 
24e4			;        
24e4			 
24e4			if DEBUG_FORTH_PARSE_KEY 
24e4						DMARK "KYq" 
24e4				CALLMONITOR 
24e4			endif 
24e4			 
24e4			; 
24e4			; word comp 
24e4			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
24e4			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
24e4			;    move to start of word  
24e4			;    compare word to cli_token 
24e4			 
24e4			.execpnword:	; HL at start of a word in the dictionary to check 
24e4			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
24e4			;	ld (cli_ptr), hl 
24e4			 
24e4 2a 77 f9			ld hl,(cli_nextword) 
24e7			 
24e7 cd 8a 25			call forth_tok_next 
24ea			; tok next start here 
24ea			;	; TODO skip compiled symbol for now 
24ea			;	inc hl 
24ea			; 
24ea			;	; save pointer to next word 
24ea			; 
24ea			;	; hl now points to the address of the next word pointer  
24ea			;	ld e, (hl) 
24ea			;	inc hl 
24ea			;	ld d, (hl) 
24ea			;	inc l 
24ea			; 
24ea			;	ex de,hl 
24ea			;if DEBUG_FORTH_PARSE_NEXTWORD 
24ea			;	push bc 
24ea			;	ld bc, (cli_nextword) 
24ea			;			DMARK "NXW" 
24ea			;	CALLMONITOR 
24ea			;	pop bc 
24ea			;endif 
24ea			; tok next end here 
24ea 22 77 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
24ed eb				ex de, hl 
24ee			 
24ee			 
24ee				; save the pointer of the current token - 1 to check against 
24ee				 
24ee 22 7b f9			ld (cli_token), hl   
24f1				; TODO maybe remove below save if no debug 
24f1				; save token string ptr for any debug later 
24f1 23				inc hl  
24f2 22 7d f9			ld (cli_origtoken), hl 
24f5 2b				dec hl 
24f6				; save pointer to the start of the next dictionay word 
24f6 7e				ld a,(hl)   ; get string length 
24f7 47				ld b,a 
24f8			.execpnwordinc:  
24f8 23				inc hl 
24f9 10 fd			djnz .execpnwordinc 
24fb 22 79 f9			ld (cli_execword), hl      ; save start of this words code 
24fe			 
24fe				; now check the word token against the string being parsed 
24fe			 
24fe 2a 7b f9			ld hl,(cli_token) 
2501 23				inc hl     ; skip string length (use zero term instead to end) 
2502 22 7b f9			ld (cli_token), hl 
2505			 
2505			if DEBUG_FORTH_PARSE_KEY 
2505						DMARK "KY2" 
2505			endif 
2505			if DEBUG_FORTH_PARSE_EXEC 
2505				; see if disabled 
2505			 
2505			;	ld a, (os_view_disable) 
2505			;	cp '*' 
2505				ld a, (debug_vector) 
2505				cp $c9   ; RET  
2505				jr z, .skip 
2505			 
2505				push hl 
2505				push hl 
2505				call clear_display 
2505				ld de, .compword 
2505				ld a, display_row_1 
2505				call str_at_display 
2505				pop de 
2505				ld a, display_row_2 
2505				call str_at_display 
2505				ld hl,(cli_ptr) 
2505				ld a,(hl) 
2505			        ld hl, os_word_scratch 
2505				ld (hl),a 
2505				ld a,0 
2505				inc hl 
2505				ld (hl),a 	 
2505				ld de, os_word_scratch 
2505				ld a, display_row_2+10 
2505				call str_at_display 
2505				call update_display 
2505				ld a, 100 
2505				call aDelayInMS 
2505				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2505				call delay250ms 
2505				endif 
2505				pop hl 
2505			.skip:  
2505			endif	 
2505			.execpnchar:    ; compare char between token and string to parse 
2505			 
2505			if DEBUG_FORTH_PARSE_KEY 
2505						DMARK "Ky3" 
2505			endif 
2505			if DEBUG_FORTH_PARSE_EXEC 
2505				; see if disabled 
2505			 
2505			;	ld a, (os_view_disable) 
2505			;	cp '*' 
2505				ld a, (debug_vector) 
2505				cp $C9  ; RET 
2505				jr z, .skip2 
2505			 
2505			;	call clear_display 
2505			ld hl,(cli_token) 
2505			ld a,(hl) 
2505			ld (os_word_scratch),a 
2505				ld hl,(cli_ptr) 
2505			ld a,(hl) 
2505				ld (os_word_scratch+1),a 
2505				ld a,0 
2505				ld (os_word_scratch+2),a 
2505				ld de,os_word_scratch 
2505				ld a,display_row_4 
2505				call str_at_display 
2505				call update_display 
2505			.skip2:  
2505			endif 
2505 2a 7b f9			ld hl,(cli_token) 
2508 7e				ld a, (hl)	 ; char in word token 
2509 23				inc hl 		; move to next char 
250a 22 7b f9			ld (cli_token), hl ; and save it 
250d 47				ld b,a 
250e			 
250e 2a 75 f9			ld hl,(cli_ptr) ;	get the char from the string to parse 
2511 7e				ld a,(hl) 
2512 23				inc hl 
2513 22 75 f9			ld (cli_ptr), hl		; move to next char 
2516 cd 3b 13			call toUpper 		; make sure the input string matches case 
2519			 
2519			if DEBUG_FORTH_PARSE 
2519			endif 
2519			 
2519				; input stream end of token is a space so get rid of it 
2519			 
2519			;	cp ' ' 
2519			;	jr nz, .pnskipspace 
2519			; 
2519			;	ld a, 0		; make same term as word token term 
2519			; 
2519			;.pnskipspace: 
2519			 
2519			if DEBUG_FORTH_PARSE_KEY 
2519						DMARK "KY7" 
2519			endif 
2519 b8				cp b 
251a c2 30 25			jp nz, .execpnskipword	 ; no match so move to next word 
251d				 
251d			;    if same 
251d			;       scan for string terms 0 for token and 32 for input 
251d			 
251d				 
251d			if DEBUG_FORTH_PARSE_KEY 
251d						DMARK "KY8" 
251d			endif 
251d			 
251d 80				add b			 
251e fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
2520							; TODO need to make sure last word in zero term string is accounted for 
2520 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
2522			 
2522			 
2522				; at end of both strings so both are exact match 
2522			 
2522			;       skip ptr for next word 
2522			 
2522 2a 75 f9			ld hl,(cli_ptr) 	; at input string term 
2525 23				inc hl			 ; at next char 
2526 22 75 f9			ld (cli_ptr), hl     ; save for next round of the parser 
2529 22 73 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
252c				 
252c				 
252c			if DEBUG_FORTH_PARSE_KEY 
252c						DMARK "KY3" 
252c			endif 
252c			 
252c			 
252c			 
252c			;       exec code block 
252c			if DEBUG_FORTH_JP 
252c				call clear_display 
252c				call update_display 
252c				call delay1s 
252c				ld hl, (cli_execword)     ; save for next check if no match on this word 
252c				ld a,h 
252c				ld hl, os_word_scratch 
252c				call hexout 
252c				ld hl, (cli_execword)     ; save for next check if no match on this word 
252c				ld a,l 
252c				ld hl, os_word_scratch+2 
252c				call hexout 
252c				ld hl, os_word_scratch+4 
252c				ld a,0 
252c				ld (hl),a 
252c				ld de,os_word_scratch 
252c				call str_at_display 
252c					ld a, display_row_2 
252c					call str_at_display 
252c				ld de, (cli_origtoken) 
252c				ld a, display_row_1+10 
252c					call str_at_display 
252c			 
252c				ld a,display_row_1 
252c				ld de, .foundword 
252c				ld a, display_row_3 
252c				call str_at_display 
252c				call update_display 
252c				call delay1s 
252c				call delay1s 
252c				call delay1s 
252c			endif 
252c			 
252c			if DEBUG_FORTH_PARSE_KEY 
252c						DMARK "KYj" 
252c			endif 
252c				; TODO save the word pointer in this exec 
252c			 
252c 2a 79 f9			ld hl,(cli_execword) 
252f e9				jp (hl) 
2530			 
2530			 
2530			;    if not same 
2530			;	scan for zero term 
2530			;	get ptr for next word 
2530			;	goto word comp 
2530			 
2530			.execpnskipword:	; get pointer to next word 
2530 2a 77 f9			ld hl,(cli_nextword) 
2533			 
2533 7e				ld a,(hl) 
2534 fe 00			cp WORD_SYS_END 
2536			;	cp 0 
2536 28 09			jr z, .execendofdict			 ; at end of words 
2538			 
2538			if DEBUG_FORTH_PARSE_KEY 
2538						DMARK "KY4" 
2538			endif 
2538			if DEBUG_FORTH_PARSE_EXEC 
2538			 
2538				; see if disabled 
2538			 
2538			;	ld a, (os_view_disable) 
2538			;	cp '*' 
2538				ld a,(debug_vector) 
2538				cp $c9   ; RET 
2538				jr z, .noskip 
2538			 
2538			 
2538				ld de, .nowordfound 
2538				ld a, display_row_3 
2538				call str_at_display 
2538				call update_display 
2538				ld a, 100 
2538				call aDelayInMS 
2538				 
2538				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2538					call delay250ms 
2538				endif 
2538			.noskip:  
2538			 
2538			endif	 
2538			 
2538 2a 73 f9			ld hl,(cli_origptr) 
253b 22 75 f9			ld (cli_ptr),hl 
253e			 
253e			if DEBUG_FORTH_PARSE_KEY 
253e						DMARK "KY5" 
253e			endif 
253e c3 e4 24			jp .execpnword			; else go to next word 
2541			 
2541			.execendofdict:  
2541			 
2541			if DEBUG_FORTH_PARSE_KEY 
2541						DMARK "KYe" 
2541			endif 
2541			if DEBUG_FORTH_PARSE_EXEC 
2541				; see if disabled 
2541			 
2541			;	ld a, (os_view_disable) 
2541			;	cp '*' 
2541				ld a,(debug_vector) 
2541				cp $c9   ; ret 
2541				jr z, .ispskip 
2541			 
2541				call clear_display 
2541				call update_display 
2541				call delay1s 
2541				ld de, (cli_origptr) 
2541				ld a, display_row_1 
2541				call str_at_display 
2541				 
2541				ld de, .enddict 
2541				ld a, display_row_3 
2541				call str_at_display 
2541				call update_display 
2541				ld a, 100 
2541				call aDelayInMS 
2541				if DEBUG_FORTH_PARSE_EXEC_SLOW 
2541				call delay1s 
2541				call delay1s 
2541				call delay1s 
2541				endif 
2541			.ispskip:  
2541				 
2541			endif	 
2541			 
2541			 
2541			 
2541				; if the word is not a keyword then must be a literal so push it to stack 
2541			 
2541			; push token to stack to end of word 
2541			 
2541				STACKFRAME ON $1efe $2f9f 
2541				if DEBUG_STACK_IMB 
2541					if ON 
2541						exx 
2541						ld de, $1efe 
2541						ld a, d 
2541						ld hl, curframe 
2541						call hexout 
2541						ld a, e 
2541						ld hl, curframe+2 
2541						call hexout 
2541						ld hl, $1efe 
2541						push hl 
2541						ld hl, $2f9f 
2541						push hl 
2541						exx 
2541					endif 
2541				endif 
2541			endm 
# End of macro STACKFRAME
2541			 
2541 2a f7 f3		ld hl,(os_tok_ptr) 
2544 cd b1 21		call forth_apush 
2547			 
2547				STACKFRAMECHK ON $1efe $2f9f 
2547				if DEBUG_STACK_IMB 
2547					if ON 
2547						exx 
2547						ld hl, $2f9f 
2547						pop de   ; $2f9f 
2547						call cmp16 
2547						jr nz, .spnosame 
2547						ld hl, $1efe 
2547						pop de   ; $1efe 
2547						call cmp16 
2547						jr z, .spfrsame 
2547						.spnosame: call showsperror 
2547						.spfrsame: nop 
2547						exx 
2547					endif 
2547				endif 
2547			endm 
# End of macro STACKFRAMECHK
2547			 
2547			execnext: 
2547			 
2547			if DEBUG_FORTH_PARSE_KEY 
2547						DMARK "KY>" 
2547			endif 
2547			; move past token to next word 
2547			 
2547 2a f7 f3		ld hl, (os_tok_ptr) 
254a 3e 00		ld a, 0 
254c 01 ff 00		ld bc, 255     ; input buffer size 
254f ed b1		cpir 
2551			 
2551			if DEBUG_FORTH_PARSE_KEY 
2551						DMARK "KY!" 
2551				CALLMONITOR 
2551			endif	 
2551			; TODO this might place hl on the null, so will need to forward on??? 
2551			;inc hl   ; see if this gets onto the next item 
2551			 
2551			 
2551			; TODO pass a pointer to the buffer to push 
2551			; TODO call function to push 
2551			 
2551			; look for end of input 
2551			 
2551			;inc hl 
2551			;ld a,(hl) 
2551			;cp FORTH_END_BUFFER 
2551			;ret z 
2551			 
2551			 
2551 c3 ca 24		jp exec1 
2554			 
2554			 
2554			 
2554			 
2554			 
2554			 
2554			 
2554			 
2554			 
2554			findnexttok: 
2554			 
2554				; hl is pointer to move 
2554				; de is the token to locate 
2554			 
2554					if DEBUG_FORTH 
2554						DMARK "NTK" 
2554						CALLMONITOR 
2554					endif 
2554 d5				push de 
2555			 
2555			.fnt1:	 
2555				; find first char of token to locate 
2555			 
2555 1a				ld a, (de) 
2556 4f				ld c,a 
2557 7e				ld a,(hl) 
2558 cd 3b 13			call toUpper 
255b					if DEBUG_FORTH 
255b						DMARK "NT1" 
255b						CALLMONITOR 
255b					endif 
255b b9				cp c 
255c			 
255c 28 03			jr z, .fnt2cmpmorefirst	 
255e			 
255e				; first char not found move to next char 
255e			 
255e 23				inc hl 
255f 18 f4			jr .fnt1 
2561			 
2561			.fnt2cmpmorefirst:	 
2561				; first char of token found.  
2561			 
2561 e5				push hl     ; save start of token just in case it is the right one 
2562 d9				exx 
2563 e1				pop hl        ; save it to hl' 
2564 d9				exx 
2565			 
2565			 
2565			.fnt2cmpmore:	 
2565				; compare the rest 
2565				 
2565 23				inc hl 
2566 13				inc de 
2567				 
2567 1a				ld a, (de) 
2568 4f				ld c,a 
2569 7e				ld a,(hl) 
256a cd 3b 13			call toUpper 
256d			 
256d					if DEBUG_FORTH 
256d						DMARK "NT2" 
256d						CALLMONITOR 
256d					endif 
256d				; c has the token to find char 
256d				; a has the mem to scan char 
256d			 
256d b9				cp c 
256e 28 04			jr z,.fntmatch1 
2570			 
2570				; they are not the same 
2570			 
2570					if DEBUG_FORTH 
2570						DMARK "NT3" 
2570						CALLMONITOR 
2570					endif 
2570 d1				pop de	; reset de token to look for 
2571 d5				push de 
2572 18 e1			jr .fnt1 
2574				 
2574			.fntmatch1: 
2574			 
2574				; is the same char a null which means we might have a full hit? 
2574					if DEBUG_FORTH 
2574						DMARK "NT4" 
2574						CALLMONITOR 
2574					endif 
2574			 
2574 fe 00			cp 0 
2576 28 0b			jr z, .fntmatchyes 
2578			 
2578				; are we at the end of the token to find? 
2578			 
2578					if DEBUG_FORTH 
2578						DMARK "NT5" 
2578						CALLMONITOR 
2578					endif 
2578 3e 00			ld a, 0 
257a b9				cp c 
257b			 
257b c2 65 25			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
257e			 
257e					if DEBUG_FORTH 
257e						DMARK "NT6" 
257e						CALLMONITOR 
257e					endif 
257e				; token to find is exhusted but no match to stream 
257e			 
257e				; restore tok pointer and continue on 
257e d1				pop de 
257f d5				push de 
2580 c3 55 25			jp .fnt1 
2583			 
2583			 
2583			.fntmatchyes: 
2583			 
2583				; hl now contains the end of the found token 
2583			 
2583				; get rid of saved token pointer to find 
2583			 
2583 d1				pop de 
2584			 
2584					if DEBUG_FORTH 
2584						DMARK "NT9" 
2584						CALLMONITOR 
2584					endif 
2584			 
2584				; hl will be on the null term so forward on 
2584			 
2584				; get back the saved start of the token 
2584			 
2584 d9				exx 
2585 e5				push hl     ; save start of token just in case it is the right one 
2586 d9				exx 
2587 e1				pop hl        ; save it to hl 
2588			 
2588 c9				ret 
2589			 
2589			 
2589			; LIST needs to find a specific token   
2589			; FORGET needs to find a spefici token 
2589			 
2589			; SAVE needs to find all tokens by flag 
2589			; WORDS just needs to scan through all  by flag 
2589			; UWORDS needs to scan through all by flag 
2589			 
2589			 
2589			; given hl as pointer to start of dict look up string 
2589			; return hl as pointer to start of word block 
2589			; or 0 if not found 
2589			 
2589			forth_find_tok: 
2589 c9				ret 
258a			 
258a			; given hl as pointer to dict structure 
258a			; move to the next dict block structure 
258a			 
258a			forth_tok_next: 
258a				; hl now points to the address of the next word pointer  
258a				; TODO skip compiled symbol for now 
258a			;	push de 
258a 23				inc hl 
258b 5e				ld e, (hl) 
258c 23				inc hl 
258d 56				ld d, (hl) 
258e 23				inc hl 
258f			 
258f eb				ex de,hl 
2590			if DEBUG_FORTH_PARSE_NEXTWORD 
2590				push bc 
2590				ld bc, (cli_nextword) 
2590						DMARK "NXW" 
2590				CALLMONITOR 
2590				pop bc 
2590			endif 
2590			;	pop de	 
2590 c9				ret 
2591			 
2591			 
2591			 
2591			; eof 
# End of file forth_parserv5.asm
2591				include "forth_wordsv4.asm" 
2591			 
2591			; the core word dictionary v4 
2591			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
2591			 
2591			; this is a linked list for each of the system words used 
2591			; user defined words will follow the same format but will be in ram 
2591			 
2591			 
2591			; 
2591			; 
2591			; define linked list: 
2591			; 
2591			; 1. compiled byte op code 
2591			; 2. len of text word 
2591			; 3. text word 
2591			; 4. ptr to next dictionary word 
2591			; 5. asm, calls etc for the word 
2591			; 
2591			;  if 1 == 0 then last word in dict  
2591			;   
2591			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
2591			;  
2591			;  
2591			; create basic standard set of words 
2591			; 
2591			;  
2591			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
2591			; 2DUP 2DROP 2SWAP  
2591			; @ C@ - get byte  
2591			; ! C! - store byte 
2591			; 0< true if less than zero 
2591			; 0= true if zero 
2591			; < >  
2591			; = true if same 
2591			; variables 
2591			 
2591			 
2591			; Hardware specific words I may need 
2591			; 
2591			; IN OUT  
2591			; calls to key util functions 
2591			; calls to hardward abstraction stuff 
2591			; easy control of frame buffers and lcd i/o 
2591			; keyboard  
2591			 
2591			 
2591			;DICT: macro 
2591			; op_code, len, word, next 
2591			;    word: 
2591			;    db op_code 
2591			;    ds word zero term 
2591			;    dw next 
2591			;    endm 
2591			 
2591			 
2591			 
2591			 
2591			; op code 1 is a flag for user define words which are to be handled differently 
2591			 
2591			 
2591			; 
2591			; 
2591			;    TODO on entry to a word this should be the expected environment 
2591			;    hl - tos value if number then held, if string this is the ptr 
2591			;    de -  
2591			 
2591			 
2591			; opcode ranges 
2591			; 0 - end of word dict 
2591			; 255 - user define words 
2591			 
2591			sysdict: 
2591			include "forth_opcodes.asm" 
2591			; op codes for forth keywords 
2591			 
2591			; Changing use of opcodes to flag is the word exists in compiled form or not.  
2591			; This provides a means to compile uwords if required for higher performance 
2591			; by avoiding the use of the keyword parser and just jumping directly to the code 
2591			; Actually there is already a flag for if the code exists as binary thinking about it... 
2591			 
2591			 
2591			 
2591			 
2591			 
2591			; free to use code 0  
2591				OPCODE_HEAP: equ  1 
2591				OPCODE_EXEC: equ 2 
2591				OPCODE_DUP: equ 3 
2591				OPCODE_SWAP: equ 4 
2591				OPCODE_COLN: equ 5 
2591				OPCODE_SCOLN: equ 6 
2591				OPCODE_DROP: equ 7 
2591				OPCODE_DUP2: equ 8 
2591				OPCODE_DROP2: equ 9 
2591				OPCODE_SWAP2: equ 10 
2591				OPCODE_AT: equ 11 
2591				OPCODE_CAT: equ 12 
2591				OPCODE_BANG: equ 13 
2591				OPCODE_CBANG: equ 14 
2591				OPCODE_SCALL: equ 15 
2591				OPCODE_DEPTH: equ 16 
2591				OPCODE_OVER: equ 17 
2591				OPCODE_PAUSE: equ 18 
2591				OPCODE_PAUSES: equ 19 
2591				OPCODE_ROT: equ 20 
2591			;free to reuse	OPCODE_WORDS: equ 21 
2591			        OPCODE_NOT: equ 21 
2591				OPCODE_UWORDS: equ 22 
2591				OPCODE_BP: equ 23 
2591				OPCODE_MONITOR: equ 24  
2591				OPCODE_MALLOC: equ 25 
2591				OPCODE_FREE: equ 26 
2591				OPCODE_LIST: equ 27 
2591				OPCODE_FORGET: equ 28 
2591				OPCODE_NOP: equ 29 
2591				OPCODE_COMO: equ 30 
2591				OPCODE_COMC: equ 31 
2591			;free to reuse	OPCODE_ENDCORE: equ 32 
2591				OPCODE_AFTERSOUND: equ 33 
2591				OPCODE_GP2: equ 34 
2591				OPCODE_GP3: equ 35 
2591				OPCODE_GP4: equ 36 
2591				OPCODE_SIN: equ 37 
2591				OPCODE_SOUT: equ 38 
2591				OPCODE_SPIO: equ 39 
2591				OPCODE_SPICEH: equ 40 
2591				OPCODE_SPIOb: equ 41 
2591				OPCODE_SPII: equ 42 
2591				OPCODE_SESEL: equ 43 
2591				OPCODE_CARTDEV: equ 44 
2591			; free to reuse	OPCODE_ENDDEVICE: equ 45 
2591				OPCODE_FB: equ 46 
2591				OPCODE_EMIT: equ 47 
2591				OPCODE_DOTH: equ 48 
2591				OPCODE_DOTF: equ 49 
2591				OPCODE_DOT: equ 50 
2591				OPCODE_CLS: equ 51 
2591				OPCODE_DRAW: equ 52 
2591				OPCODE_DUMP: equ 53 
2591				OPCODE_CDUMP: equ 54 
2591				OPCODE_DAT: equ 55 
2591				OPCODE_HOME: equ 56 
2591				OPCODE_SPACE: equ 57 
2591				OPCODE_SPACES: equ 58 
2591				OPCODE_SCROLL: equ 59 
2591				OPCODE_ATQ: equ 60 
2591				OPCODE_AUTODSP: equ 61 
2591				OPCODE_MENU: equ 62 
2591			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
2591				OPCODE_THEN: equ 64 
2591				OPCODE_ELSE: equ 65 
2591				OPCODE_DO: equ 66 
2591				OPCODE_LOOP: equ 67 
2591				OPCODE_I: equ 68 
2591				OPCODE_DLOOP: equ 69  
2591				OPCODE_REPEAT: equ 70  
2591				OPCODE_UNTIL: equ 71 
2591				OPCODE_ENDFLOW: equ 72 
2591				OPCODE_WAITK: equ 73 
2591				OPCODE_ACCEPT: equ 74 
2591				OPCODE_EDIT: equ 75 
2591			;free to reuse	OPCODE_ENDKEY: equ 76 
2591				OPCODE_LZERO: equ 77 
2591				OPCODE_TZERO: equ 78 
2591				OPCODE_LESS: equ 79 
2591				OPCODE_GT: equ 80 
2591				OPCODE_EQUAL: equ 81  
2591			;free to reuse	OPCODE_ENDLOGIC: equ 82 
2591				OPCODE_NEG: equ 83 
2591				OPCODE_DIV: equ 84 
2591				OPCODE_MUL: equ 85 
2591				OPCODE_MIN: equ 86 
2591				OPCODE_MAX: equ 87 
2591				OPCODE_RND16: equ 88 
2591				OPCODE_RND8: equ 89 
2591				OPCODE_RND: equ 90 
2591			;free to reuse	OPCODE_ENDMATHS: equ 91  
2591				OPCODE_BYNAME: equ 92 
2591				OPCODE_DIR: equ 93 
2591				OPCODE_SAVE: equ 94 
2591				OPCODE_LOAD: equ 95 
2591				OPCODE_BSAVE: equ 96 
2591				OPCODE_BLOAD: equ 97 
2591				OPCODE_SEO: equ 98  
2591				OPCODE_SEI: equ 99 
2591				OPCODE_SFREE: equ 100 
2591				OPCODE_SIZE: equ 101 
2591				OPCODE_CREATE: equ 102 
2591				OPCODE_APPEND: equ 103 
2591				OPCODE_SDEL: equ 104 
2591				OPCODE_OPEN: equ 105 
2591				OPCODE_READ: equ 106 
2591				OPCODE_EOF: equ 106 
2591				OPCODE_FORMAT: equ 107 
2591				OPCODE_LABEL: equ 108 
2591				OPCODE_LABELS: equ 109 
2591			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
2591				OPCODE_UPPER: equ 111 
2591				OPCODE_LOWER: equ 112 
2591				OPCODE_SUBSTR: equ 113 
2591				OPCODE_LEFT: equ 114 
2591				OPCODE_RIGHT: equ 115 
2591				OPCODE_STR2NUM: equ 116 
2591				OPCODE_NUM2STR: equ 117 
2591				OPCODE_CONCAT: equ 118 
2591				OPCODE_FIND: equ 119 
2591				OPCODE_LEN: equ 120 
2591				OPCODE_CHAR: equ 121 
2591			; free to reuse	OPCODE_STRLEN: equ 122 
2591			; free to reuse	OPCODE_ENDSTR: equ 123 
2591				OPCODE_V0S: equ 124 
2591				OPCODE_V0Q: equ 125 
2591				OPCODE_V1S: equ 126 
2591				OPCODE_V1Q: equ 127 
2591				OPCODE_V2S: equ 128 
2591				OPCODE_V2Q: equ 129 
2591				OPCODE_V3S: equ 130 
2591				OPCODE_V3Q: equ 131 
2591			;free to reuse	OPCODE_END: equ 132 
2591				OPCODE_ZDUP: equ 133 
2591			 
2591			; eof 
# End of file forth_opcodes.asm
2591			 
2591			include "forth_words_core.asm" 
2591			 
2591			; | ## Core Words 
2591			 
2591			;if MALLOC_4 
2591			 
2591			.HEAP: 
2591			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
2591 15				db WORD_SYS_CORE+OPCODE_HEAP             
2592 d0 25			dw .EXEC            
2594 05				db 4 + 1 
2595 .. 00			db "HEAP",0              
259a				endm 
# End of macro CWHEAD
259a			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
259a			; | | u1 - Current number of bytes in the heap 
259a			; | | u2 - Remaining bytes left on the heap 
259a			; | |  
259a			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
259a			 
259a			 
259a				if DEBUG_FORTH_WORDS_KEY 
259a					DMARK "HEP" 
259a f5				push af  
259b 3a af 25			ld a, (.dmark)  
259e 32 a0 fd			ld (debug_mark),a  
25a1 3a b0 25			ld a, (.dmark+1)  
25a4 32 a1 fd			ld (debug_mark+1),a  
25a7 3a b1 25			ld a, (.dmark+2)  
25aa 32 a2 fd			ld (debug_mark+2),a  
25ad 18 03			jr .pastdmark  
25af ..			.dmark: db "HEP"  
25b2 f1			.pastdmark: pop af  
25b3			endm  
# End of macro DMARK
25b3					CALLMONITOR 
25b3 cd aa fd			call debug_vector  
25b6				endm  
# End of macro CALLMONITOR
25b6				endif 
25b6 2a 0a 80			ld hl, (free_list )      
25b9 11 0e 80			ld de, heap_start 
25bc			 
25bc ed 52			sbc hl, de  
25be			 
25be cd 48 20			call forth_push_numhl 
25c1			 
25c1			 
25c1 ed 5b 0a 80		ld de, (free_list )      
25c5 21 d1 f0			ld hl, heap_end 
25c8			 
25c8 ed 52			sbc hl, de 
25ca			 
25ca cd 48 20			call forth_push_numhl 
25cd				 
25cd			 
25cd				 
25cd			 
25cd			 
25cd			 
25cd				NEXTW 
25cd c3 39 24			jp macro_next 
25d0				endm 
# End of macro NEXTW
25d0			;endif 
25d0			 
25d0			.EXEC: 
25d0			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
25d0			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
25d0			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
25d0			;; > > 
25d0			;; > >   
25d0			;	STACKFRAME OFF $5efe $5f9f 
25d0			; 
25d0			;		if DEBUG_FORTH_WORDS_KEY 
25d0			;			DMARK "EXE" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			; 
25d0			;	FORTH_DSP_VALUEHL 
25d0			; 
25d0			;	FORTH_DSP_POP 
25d0			; 
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EX1" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			;;	ld e,(hl) 
25d0			;;	inc hl 
25d0			;;	ld d,(hl) 
25d0			;;	ex de,hl 
25d0			; 
25d0			;;		if DEBUG_FORTH_WORDS 
25d0			;;			DMARK "EX2" 
25d0			;;			CALLMONITOR 
25d0			;;		endif 
25d0			;	push hl 
25d0			; 
25d0			;	;ld a, 0 
25d0			;	;ld a, FORTH_END_BUFFER 
25d0			;	call strlenz 
25d0			;	inc hl   ; include zero term to copy 
25d0			;	inc hl   ; include term 
25d0			;	inc hl   ; include term 
25d0			;	ld b,0 
25d0			;	ld c,l 
25d0			;	pop hl 
25d0			;	ld de, execscratch 
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EX3" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			;	ldir 
25d0			; 
25d0			; 
25d0			;	ld hl, execscratch 
25d0			; 
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EXe" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			; 
25d0			;	call forthparse 
25d0			;	call forthexec 
25d0			;;	call forthexec_cleanup 
25d0			;;	call forthparse 
25d0			;;	call forthexec 
25d0			; 
25d0			;	STACKFRAMECHK OFF $5efe $5f9f 
25d0			; 
25d0			;	; an immediate word so no need to process any more words 
25d0			;	ret 
25d0			;	NEXTW 
25d0			 
25d0			; dead code - old version  
25d0			;	FORTH_RSP_NEXT 
25d0			 
25d0			;  
25d0			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
25d0			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
25d0			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
25d0			;	push hl 
25d0			;	push de 
25d0			;	push bc 
25d0			; 
25d0			; 
25d0			;		if DEBUG_FORTH_WORDS_KEY 
25d0			;			DMARK "EXR" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			; 
25d0			; 
25d0			; 
25d0			;	;v5 FORTH_DSP_VALUE 
25d0			;	FORTH_DSP_VALUEHL 
25d0			; 
25d0			;	; TODO do string type checks 
25d0			; 
25d0			;;v5	inc hl   ; skip type 
25d0			; 
25d0			;	push hl  ; source code  
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EX1" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			;	ld a, 0 
25d0			;	call strlent 
25d0			; 
25d0			;	inc hl 
25d0			;	inc hl 
25d0			;	inc hl 
25d0			;	inc hl 
25d0			; 
25d0			;	push hl    ; size 
25d0			; 
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EX2" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			;	call malloc 
25d0			; 
25d0			;	ex de, hl    ; de now contains malloc area 
25d0			;	pop bc   	; get byte count 
25d0			;	pop hl      ; get string to copy 
25d0			; 
25d0			;	push de     ; save malloc for free later 
25d0			; 
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EX3" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			;	ldir       ; duplicate string 
25d0			; 
25d0			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
25d0			;	 
25d0			;	; TODO fix the parse would be better than this...  
25d0			;	ex de, hl 
25d0			;	dec hl 
25d0			;	ld a, 0 
25d0			;	ld (hl), a 
25d0			;	dec hl 
25d0			;	ld a, ' ' 
25d0			;	ld (hl), a 
25d0			;	dec hl 
25d0			;	ld (hl), a 
25d0			; 
25d0			;	dec hl 
25d0			;	ld (hl), a 
25d0			; 
25d0			; 
25d0			;	FORTH_DSP_POP  
25d0			; 
25d0			;	pop hl     
25d0			;	push hl    ; save malloc area 
25d0			; 
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EX4" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			; 
25d0			;	call forthparse 
25d0			;	call forthexec 
25d0			;	 
25d0			;	pop hl 
25d0			;	if DEBUG_FORTH_WORDS 
25d0			;		DMARK "EX5" 
25d0			;		CALLMONITOR 
25d0			;	endif 
25d0			; 
25d0			;	if FORTH_ENABLE_FREE 
25d0			;	call free 
25d0			;	endif 
25d0			; 
25d0			;	if DEBUG_FORTH_WORDS 
25d0			;		DMARK "EX6" 
25d0			;		CALLMONITOR 
25d0			;	endif 
25d0			; 
25d0			;	pop bc 
25d0			;	pop de 
25d0			;	pop hl 
25d0			;;	FORTH_RSP_POP	  
25d0			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
25d0			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
25d0			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
25d0			; 
25d0			;	if DEBUG_FORTH_WORDS 
25d0			;		DMARK "EX7" 
25d0			;		CALLMONITOR 
25d0			;	endif 
25d0			;	NEXTW 
25d0			 
25d0			;.STKEXEC: 
25d0			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
25d0			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
25d0			; 
25d0			; 
25d0			;		if DEBUG_FORTH_WORDS_KEY 
25d0			;			DMARK "STX" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			; 
25d0			;	FORTH_DSP_VALUEHL 
25d0			; 
25d0			;	ld (store_tmp1), hl    ; count 
25d0			; 
25d0			;	FORTH_DSP_POP 
25d0			;.stkexec1: 
25d0			;	ld hl, (store_tmp1)   ; count 
25d0			;	ld a, 0 
25d0			;	cp l 
25d0			;	ret z 
25d0			; 
25d0			;	dec hl 
25d0			;	ld (store_tmp1), hl    ; count 
25d0			;	 
25d0			;	FORTH_DSP_VALUEHL 
25d0			;	push hl 
25d0			;	 
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EXp" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			;	FORTH_DSP_POP 
25d0			; 
25d0			;	call strlenz 
25d0			;	inc hl   ; include zero term to copy 
25d0			;	inc hl   ; include zero term to copy 
25d0			;	inc hl   ; include zero term to copy 
25d0			;	ld b,0 
25d0			;	ld c,l 
25d0			;	pop hl 
25d0			;	ld de, execscratch 
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EX3" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			;	ldir 
25d0			; 
25d0			; 
25d0			;	ld hl, execscratch 
25d0			; 
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EXP" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			; 
25d0			;	call forthparse 
25d0			;	ld hl, execscratch 
25d0			;		if DEBUG_FORTH_WORDS 
25d0			;			DMARK "EXx" 
25d0			;			CALLMONITOR 
25d0			;		endif 
25d0			;	call forthexec 
25d0			; 
25d0			;	jp .stkexec1 
25d0			; 
25d0			;	ret 
25d0			 
25d0			 
25d0			.DUP: 
25d0			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
25d0 17				db WORD_SYS_CORE+OPCODE_DUP             
25d1 46 26			dw .ZDUP            
25d3 04				db 3 + 1 
25d4 .. 00			db "DUP",0              
25d8				endm 
# End of macro CWHEAD
25d8			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
25d8			 
25d8				if DEBUG_FORTH_WORDS_KEY 
25d8					DMARK "DUP" 
25d8 f5				push af  
25d9 3a ed 25			ld a, (.dmark)  
25dc 32 a0 fd			ld (debug_mark),a  
25df 3a ee 25			ld a, (.dmark+1)  
25e2 32 a1 fd			ld (debug_mark+1),a  
25e5 3a ef 25			ld a, (.dmark+2)  
25e8 32 a2 fd			ld (debug_mark+2),a  
25eb 18 03			jr .pastdmark  
25ed ..			.dmark: db "DUP"  
25f0 f1			.pastdmark: pop af  
25f1			endm  
# End of macro DMARK
25f1					CALLMONITOR 
25f1 cd aa fd			call debug_vector  
25f4				endm  
# End of macro CALLMONITOR
25f4				endif 
25f4			 
25f4				FORTH_DSP 
25f4 cd 13 22			call macro_forth_dsp 
25f7				endm 
# End of macro FORTH_DSP
25f7			 
25f7 7e				ld a, (HL) 
25f8 fe 01			cp DS_TYPE_STR 
25fa 20 25			jr nz, .dupinum 
25fc			 
25fc				; push another string 
25fc			 
25fc				FORTH_DSP_VALUEHL     		 
25fc cd 4d 22			call macro_dsp_valuehl 
25ff				endm 
# End of macro FORTH_DSP_VALUEHL
25ff			 
25ff			if DEBUG_FORTH_WORDS 
25ff				DMARK "DUs" 
25ff f5				push af  
2600 3a 14 26			ld a, (.dmark)  
2603 32 a0 fd			ld (debug_mark),a  
2606 3a 15 26			ld a, (.dmark+1)  
2609 32 a1 fd			ld (debug_mark+1),a  
260c 3a 16 26			ld a, (.dmark+2)  
260f 32 a2 fd			ld (debug_mark+2),a  
2612 18 03			jr .pastdmark  
2614 ..			.dmark: db "DUs"  
2617 f1			.pastdmark: pop af  
2618			endm  
# End of macro DMARK
2618				CALLMONITOR 
2618 cd aa fd			call debug_vector  
261b				endm  
# End of macro CALLMONITOR
261b			endif 
261b cd b6 20			call forth_push_str 
261e			 
261e				NEXTW 
261e c3 39 24			jp macro_next 
2621				endm 
# End of macro NEXTW
2621			 
2621			 
2621			.dupinum: 
2621				 
2621			 
2621			 
2621				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2621 cd 4d 22			call macro_dsp_valuehl 
2624				endm 
# End of macro FORTH_DSP_VALUEHL
2624			 
2624			; TODO add floating point number detection 
2624			 
2624			if DEBUG_FORTH_WORDS 
2624				DMARK "DUi" 
2624 f5				push af  
2625 3a 39 26			ld a, (.dmark)  
2628 32 a0 fd			ld (debug_mark),a  
262b 3a 3a 26			ld a, (.dmark+1)  
262e 32 a1 fd			ld (debug_mark+1),a  
2631 3a 3b 26			ld a, (.dmark+2)  
2634 32 a2 fd			ld (debug_mark+2),a  
2637 18 03			jr .pastdmark  
2639 ..			.dmark: db "DUi"  
263c f1			.pastdmark: pop af  
263d			endm  
# End of macro DMARK
263d				CALLMONITOR 
263d cd aa fd			call debug_vector  
2640				endm  
# End of macro CALLMONITOR
2640			endif 
2640			 
2640 cd 48 20			call forth_push_numhl 
2643				NEXTW 
2643 c3 39 24			jp macro_next 
2646				endm 
# End of macro NEXTW
2646			.ZDUP: 
2646			CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2646 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2647 7e 26			dw .SWAP            
2649 05				db 4 + 1 
264a .. 00			db "?DUP",0              
264f				endm 
# End of macro CWHEAD
264f			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
264f			 
264f				if DEBUG_FORTH_WORDS_KEY 
264f					DMARK "qDU" 
264f f5				push af  
2650 3a 64 26			ld a, (.dmark)  
2653 32 a0 fd			ld (debug_mark),a  
2656 3a 65 26			ld a, (.dmark+1)  
2659 32 a1 fd			ld (debug_mark+1),a  
265c 3a 66 26			ld a, (.dmark+2)  
265f 32 a2 fd			ld (debug_mark+2),a  
2662 18 03			jr .pastdmark  
2664 ..			.dmark: db "qDU"  
2667 f1			.pastdmark: pop af  
2668			endm  
# End of macro DMARK
2668					CALLMONITOR 
2668 cd aa fd			call debug_vector  
266b				endm  
# End of macro CALLMONITOR
266b				endif 
266b				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
266b cd 4d 22			call macro_dsp_valuehl 
266e				endm 
# End of macro FORTH_DSP_VALUEHL
266e			 
266e e5				push hl 
266f			 
266f				; is it a zero? 
266f			 
266f 3e 00			ld a, 0 
2671 84				add h 
2672 85				add l 
2673			 
2673 e1				pop hl 
2674			 
2674 fe 00			cp 0 
2676 28 03			jr z, .dup2orig 
2678			 
2678			 
2678 cd 48 20			call forth_push_numhl 
267b			 
267b			 
267b			; TODO add floating point number detection 
267b			 
267b			.dup2orig: 
267b			 
267b				NEXTW 
267b c3 39 24			jp macro_next 
267e				endm 
# End of macro NEXTW
267e			.SWAP: 
267e			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
267e 18				db WORD_SYS_CORE+OPCODE_SWAP             
267f d2 26			dw .COLN            
2681 05				db 4 + 1 
2682 .. 00			db "SWAP",0              
2687				endm 
# End of macro CWHEAD
2687			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2687				if DEBUG_FORTH_WORDS_KEY 
2687					DMARK "SWP" 
2687 f5				push af  
2688 3a 9c 26			ld a, (.dmark)  
268b 32 a0 fd			ld (debug_mark),a  
268e 3a 9d 26			ld a, (.dmark+1)  
2691 32 a1 fd			ld (debug_mark+1),a  
2694 3a 9e 26			ld a, (.dmark+2)  
2697 32 a2 fd			ld (debug_mark+2),a  
269a 18 03			jr .pastdmark  
269c ..			.dmark: db "SWP"  
269f f1			.pastdmark: pop af  
26a0			endm  
# End of macro DMARK
26a0					CALLMONITOR 
26a0 cd aa fd			call debug_vector  
26a3				endm  
# End of macro CALLMONITOR
26a3				endif 
26a3			 
26a3			; DONE Use os stack swap memory 
26a3			 
26a3				FORTH_DSP_PTR 0     ; TOS 
26a3 2a 23 f9			ld hl,(cli_data_sp) 
26a6 11 00 00			ld de, 0 * 3 
26a9 ed 52			sbc hl, de 
26ab				endm 
# End of macro FORTH_DSP_PTR
26ab cd 85 23			call hltostack1 
26ae			  
26ae				FORTH_DSP_PTR 1     ; TOS 
26ae 2a 23 f9			ld hl,(cli_data_sp) 
26b1 11 03 00			ld de, 1 * 3 
26b4 ed 52			sbc hl, de 
26b6				endm 
# End of macro FORTH_DSP_PTR
26b6 cd 8b 23			call hltostack2 
26b9			 
26b9				FORTH_DSP_PTR 0     ; TOS 
26b9 2a 23 f9			ld hl,(cli_data_sp) 
26bc 11 00 00			ld de, 0 * 3 
26bf ed 52			sbc hl, de 
26c1				endm 
# End of macro FORTH_DSP_PTR
26c1 cd a3 23			call hlfromstack2 
26c4			 
26c4				FORTH_DSP_PTR 1     ; TOS 
26c4 2a 23 f9			ld hl,(cli_data_sp) 
26c7 11 03 00			ld de, 1 * 3 
26ca ed 52			sbc hl, de 
26cc				endm 
# End of macro FORTH_DSP_PTR
26cc cd 9d 23			call hlfromstack1 
26cf			;	FORTH_DSP_VALUEHL 
26cf			;	push hl     ; w2 
26cf			; 
26cf			;	FORTH_DSP_POP 
26cf			; 
26cf			;	FORTH_DSP_VALUEHL 
26cf			; 
26cf			;	FORTH_DSP_POP 
26cf			; 
26cf			;	pop de     ; w2	, hl = w1 
26cf			; 
26cf			;	ex de, hl 
26cf			;	push de 
26cf			; 
26cf			;	call forth_push_numhl 
26cf			; 
26cf			;	pop hl 
26cf			; 
26cf			;	call forth_push_numhl 
26cf				 
26cf			 
26cf				NEXTW 
26cf c3 39 24			jp macro_next 
26d2				endm 
# End of macro NEXTW
26d2			.COLN: 
26d2			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
26d2 19				db WORD_SYS_CORE+OPCODE_COLN             
26d3 5e 28			dw .SCOLN            
26d5 02				db 1 + 1 
26d6 .. 00			db ":",0              
26d8				endm 
# End of macro CWHEAD
26d8			; | : ( -- )         Create new word | DONE 
26d8			 
26d8				if DEBUG_FORTH_WORDS_KEY 
26d8					DMARK "CLN" 
26d8 f5				push af  
26d9 3a ed 26			ld a, (.dmark)  
26dc 32 a0 fd			ld (debug_mark),a  
26df 3a ee 26			ld a, (.dmark+1)  
26e2 32 a1 fd			ld (debug_mark+1),a  
26e5 3a ef 26			ld a, (.dmark+2)  
26e8 32 a2 fd			ld (debug_mark+2),a  
26eb 18 03			jr .pastdmark  
26ed ..			.dmark: db "CLN"  
26f0 f1			.pastdmark: pop af  
26f1			endm  
# End of macro DMARK
26f1					CALLMONITOR 
26f1 cd aa fd			call debug_vector  
26f4				endm  
# End of macro CALLMONITOR
26f4				endif 
26f4			STACKFRAME OFF $8efe $989f 
26f4				if DEBUG_STACK_IMB 
26f4					if OFF 
26f4						exx 
26f4						ld de, $8efe 
26f4						ld a, d 
26f4						ld hl, curframe 
26f4						call hexout 
26f4						ld a, e 
26f4						ld hl, curframe+2 
26f4						call hexout 
26f4						ld hl, $8efe 
26f4						push hl 
26f4						ld hl, $989f 
26f4						push hl 
26f4						exx 
26f4					endif 
26f4				endif 
26f4			endm 
# End of macro STACKFRAME
26f4			; get parser buffer length  of new word 
26f4			 
26f4			 
26f4			 
26f4				; move tok past this to start of name defintition 
26f4				; TODO get word to define 
26f4				; TODO Move past word token 
26f4				; TODO get length of string up to the ';' 
26f4			 
26f4 2a f7 f3		ld hl, (os_tok_ptr) 
26f7 23			inc hl 
26f8 23			inc hl 
26f9			 
26f9 3e 3b		ld a, ';' 
26fb cd 4f 13		call strlent 
26fe			 
26fe 7d			ld a,l 
26ff 32 e6 f0		ld (os_new_parse_len), a 
2702			 
2702			 
2702			if DEBUG_FORTH_UWORD 
2702 ed 5b f7 f3	ld de, (os_tok_ptr) 
2706					DMARK ":01" 
2706 f5				push af  
2707 3a 1b 27			ld a, (.dmark)  
270a 32 a0 fd			ld (debug_mark),a  
270d 3a 1c 27			ld a, (.dmark+1)  
2710 32 a1 fd			ld (debug_mark+1),a  
2713 3a 1d 27			ld a, (.dmark+2)  
2716 32 a2 fd			ld (debug_mark+2),a  
2719 18 03			jr .pastdmark  
271b ..			.dmark: db ":01"  
271e f1			.pastdmark: pop af  
271f			endm  
# End of macro DMARK
271f			CALLMONITOR 
271f cd aa fd			call debug_vector  
2722				endm  
# End of macro CALLMONITOR
2722			endif 
2722			 
2722			; 
2722			;  new word memory layout: 
2722			;  
2722			;    : adg 6666 ;  
2722			; 
2722			;    db   1     ; user defined word  
2722 23			inc hl    
2723			;    dw   sysdict 
2723 23			inc hl 
2724 23			inc hl 
2725			;    db <word len>+1 (for null) 
2725 23			inc hl 
2726			;    db .... <word> 
2726			; 
2726			 
2726 23			inc hl    ; some extras for the word preamble before the above 
2727 23			inc hl 
2728 23			inc hl 
2729 23			inc hl 
272a 23			inc hl 
272b 23			inc hl 
272c 23			inc hl  
272d 23			inc hl 
272e 23			inc hl 
272f 23			inc hl 
2730 23			inc hl 
2731 23			inc hl 
2732 23			inc hl 
2733 23			inc hl     ; TODO how many do we really need?     maybe only 6 
2734			;       exec word buffer 
2734			;	<ptr word>   
2734 23			inc hl 
2735 23			inc hl 
2736			;       <word list><null term> 7F final term 
2736			 
2736			 
2736			if DEBUG_FORTH_UWORD 
2736					DMARK ":02" 
2736 f5				push af  
2737 3a 4b 27			ld a, (.dmark)  
273a 32 a0 fd			ld (debug_mark),a  
273d 3a 4c 27			ld a, (.dmark+1)  
2740 32 a1 fd			ld (debug_mark+1),a  
2743 3a 4d 27			ld a, (.dmark+2)  
2746 32 a2 fd			ld (debug_mark+2),a  
2749 18 03			jr .pastdmark  
274b ..			.dmark: db ":02"  
274e f1			.pastdmark: pop af  
274f			endm  
# End of macro DMARK
274f			CALLMONITOR 
274f cd aa fd			call debug_vector  
2752				endm  
# End of macro CALLMONITOR
2752			endif 
2752			 
2752			 
2752				; malloc the size 
2752			 
2752 cd b9 13			call malloc 
2755 22 e8 f0			ld (os_new_malloc), hl     ; save malloc start 
2758			 
2758			;    db   1     ; user defined word  
2758 3e 01			ld a, WORD_SYS_UWORD  
275a 77				ld (hl), a 
275b			 
275b 23			inc hl    
275c			;    dw   sysdict 
275c 11 91 25		ld de, sysdict       ; continue on with the scan to the system dict 
275f 73			ld (hl), e 
2760 23			inc hl 
2761 72			ld (hl), d 
2762 23			inc hl 
2763			 
2763			 
2763			;    Setup dict word 
2763			 
2763 23			inc hl 
2764 22 e2 f0		ld (os_new_work_ptr), hl     ; save start of dict word  
2767			 
2767			; 1. get length of dict word 
2767			 
2767			 
2767 2a f7 f3		ld hl, (os_tok_ptr) 
276a 23			inc hl 
276b 23			inc hl    ; position to start of dict word 
276c 3e 00		ld a, 0 
276e cd 4f 13		call strlent 
2771			 
2771			 
2771 23			inc hl    ; to include null??? 
2772			 
2772			; write length of dict word 
2772			 
2772 ed 5b e2 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2776 1b			dec de 
2777 eb			ex de, hl 
2778 73			ld (hl), e 
2779 eb			ex de, hl 
277a			 
277a			 
277a			 
277a			; copy  
277a 4d			ld c, l 
277b 06 00		ld b, 0 
277d ed 5b e2 f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
2781 2a f7 f3		ld hl, (os_tok_ptr) 
2784 23			inc hl 
2785 23			inc hl    ; position to start of dict word 
2786			 
2786			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2786			 
2786			; TODO need to convert word to upper case 
2786			 
2786			ucasetok:	 
2786 7e			ld a,(hl) 
2787 cd 3b 13		call toUpper 
278a 77			ld (hl),a 
278b ed a0		ldi 
278d f2 86 27		jp p, ucasetok 
2790			 
2790			 
2790			 
2790			; de now points to start of where the word body code should be placed 
2790 ed 53 e2 f0	ld (os_new_work_ptr), de 
2794			; hl now points to the words to throw at forthexec which needs to be copied 
2794 22 e0 f0		ld (os_new_src_ptr), hl 
2797			 
2797			; TODO add 'call to forthexec' 
2797			 
2797			if DEBUG_FORTH_UWORD 
2797 c5			push bc 
2798 ed 4b e8 f0	ld bc, (os_new_malloc) 
279c					DMARK ":0x" 
279c f5				push af  
279d 3a b1 27			ld a, (.dmark)  
27a0 32 a0 fd			ld (debug_mark),a  
27a3 3a b2 27			ld a, (.dmark+1)  
27a6 32 a1 fd			ld (debug_mark+1),a  
27a9 3a b3 27			ld a, (.dmark+2)  
27ac 32 a2 fd			ld (debug_mark+2),a  
27af 18 03			jr .pastdmark  
27b1 ..			.dmark: db ":0x"  
27b4 f1			.pastdmark: pop af  
27b5			endm  
# End of macro DMARK
27b5			CALLMONITOR 
27b5 cd aa fd			call debug_vector  
27b8				endm  
# End of macro CALLMONITOR
27b8 c1			pop bc 
27b9			endif 
27b9			 
27b9			 
27b9			; create word preamble which should be: 
27b9			 
27b9			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
27b9			 
27b9			;    ld hl, <word code> 
27b9			;    jp user_exec 
27b9			;    <word code bytes> 
27b9			 
27b9			 
27b9			;	inc de     ; TODO ??? or are we already past the word's null 
27b9 eb			ex de, hl 
27ba			 
27ba 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
27bc			 
27bc 23			inc hl 
27bd 22 dc f0		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
27c0 23			inc hl 
27c1			 
27c1 23			inc hl 
27c2 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
27c4			 
27c4 01 a7 5e		ld bc, user_exec 
27c7 23			inc hl 
27c8 71			ld (hl), c     ; poke address of user_exec 
27c9 23			inc hl 
27ca 70			ld (hl), b     
27cb			; 
27cb			;	inc hl 
27cb			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
27cb			; 
27cb			; 
27cb			;	ld bc, macro_forth_rsp_next 
27cb			;	inc hl 
27cb			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
27cb			;	inc hl 
27cb			;	ld (hl), b     
27cb			; 
27cb			;	inc hl 
27cb			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
27cb			; 
27cb			; 
27cb			;	inc hl 
27cb			;	ld bc, forthexec 
27cb			;	ld (hl), c     ; poke address of forthexec 
27cb			;	inc hl 
27cb			;	ld (hl), b      
27cb			; 
27cb			;	inc hl 
27cb			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
27cb			; 
27cb			;	ld bc, user_dict_next 
27cb			;	inc hl 
27cb			;	ld (hl), c     ; poke address of forthexec 
27cb			;	inc hl 
27cb			;	ld (hl), b      
27cb			 
27cb			; hl is now where we need to copy the word byte data to save this 
27cb			 
27cb 23			inc hl 
27cc 22 de f0		ld (os_new_exec), hl 
27cf			 
27cf			; copy definition 
27cf			 
27cf eb			ex de, hl 
27d0			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
27d0			;	inc de    ; skip the PC for this parse 
27d0 3a e6 f0		ld a, (os_new_parse_len) 
27d3 4f			ld c, a 
27d4 06 00		ld b, 0 
27d6 ed b0		ldir		 ; copy defintion 
27d8			 
27d8			 
27d8			; poke the address of where the new word bytes live for forthexec 
27d8			 
27d8 2a dc f0		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
27db			 
27db ed 5b de f0	ld de, (os_new_exec)      
27df			 
27df 73			ld (hl), e 
27e0 23			inc hl 
27e1 72			ld (hl), d 
27e2			 
27e2				; TODO copy last user dict word next link to this word 
27e2				; TODO update last user dict word to point to this word 
27e2			; 
27e2			; hl f923 de 812a ; bc 811a 
27e2			 
27e2			if DEBUG_FORTH_UWORD 
27e2 c5			push bc 
27e3 ed 4b e8 f0	ld bc, (os_new_malloc) 
27e7					DMARK ":0A" 
27e7 f5				push af  
27e8 3a fc 27			ld a, (.dmark)  
27eb 32 a0 fd			ld (debug_mark),a  
27ee 3a fd 27			ld a, (.dmark+1)  
27f1 32 a1 fd			ld (debug_mark+1),a  
27f4 3a fe 27			ld a, (.dmark+2)  
27f7 32 a2 fd			ld (debug_mark+2),a  
27fa 18 03			jr .pastdmark  
27fc ..			.dmark: db ":0A"  
27ff f1			.pastdmark: pop af  
2800			endm  
# End of macro DMARK
2800			CALLMONITOR 
2800 cd aa fd			call debug_vector  
2803				endm  
# End of macro CALLMONITOR
2803 c1			pop bc 
2804			endif 
2804			if DEBUG_FORTH_UWORD 
2804 c5			push bc 
2805 ed 4b e8 f0	ld bc, (os_new_malloc) 
2809 03			inc bc 
280a 03			inc bc 
280b 03			inc bc 
280c 03			inc bc 
280d 03			inc bc 
280e 03			inc bc 
280f 03			inc bc 
2810 03			inc bc 
2811			 
2811					DMARK ":0B" 
2811 f5				push af  
2812 3a 26 28			ld a, (.dmark)  
2815 32 a0 fd			ld (debug_mark),a  
2818 3a 27 28			ld a, (.dmark+1)  
281b 32 a1 fd			ld (debug_mark+1),a  
281e 3a 28 28			ld a, (.dmark+2)  
2821 32 a2 fd			ld (debug_mark+2),a  
2824 18 03			jr .pastdmark  
2826 ..			.dmark: db ":0B"  
2829 f1			.pastdmark: pop af  
282a			endm  
# End of macro DMARK
282a			CALLMONITOR 
282a cd aa fd			call debug_vector  
282d				endm  
# End of macro CALLMONITOR
282d c1			pop bc 
282e			endif 
282e			 
282e			; update word dict linked list for new word 
282e			 
282e			 
282e 2a f3 f3		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2831 23			inc hl     ; move to next work linked list ptr 
2832			 
2832 ed 5b e8 f0	ld de, (os_new_malloc)		 ; new next word 
2836 73			ld (hl), e 
2837 23			inc hl 
2838 72			ld (hl), d 
2839			 
2839			if DEBUG_FORTH_UWORD 
2839 ed 4b f3 f3	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
283d			endif 
283d			 
283d ed 53 f3 f3	ld (os_last_new_uword), de      ; update last new uword ptr 
2841			 
2841			 
2841			if DEBUG_FORTH_UWORD 
2841					DMARK ":0+" 
2841 f5				push af  
2842 3a 56 28			ld a, (.dmark)  
2845 32 a0 fd			ld (debug_mark),a  
2848 3a 57 28			ld a, (.dmark+1)  
284b 32 a1 fd			ld (debug_mark+1),a  
284e 3a 58 28			ld a, (.dmark+2)  
2851 32 a2 fd			ld (debug_mark+2),a  
2854 18 03			jr .pastdmark  
2856 ..			.dmark: db ":0+"  
2859 f1			.pastdmark: pop af  
285a			endm  
# End of macro DMARK
285a			CALLMONITOR 
285a cd aa fd			call debug_vector  
285d				endm  
# End of macro CALLMONITOR
285d			endif 
285d			 
285d			STACKFRAMECHK OFF $8efe $989f 
285d				if DEBUG_STACK_IMB 
285d					if OFF 
285d						exx 
285d						ld hl, $989f 
285d						pop de   ; $989f 
285d						call cmp16 
285d						jr nz, .spnosame 
285d						ld hl, $8efe 
285d						pop de   ; $8efe 
285d						call cmp16 
285d						jr z, .spfrsame 
285d						.spnosame: call showsperror 
285d						.spfrsame: nop 
285d						exx 
285d					endif 
285d				endif 
285d			endm 
# End of macro STACKFRAMECHK
285d			 
285d c9			ret    ; dont process any remaining parser tokens as they form new word 
285e			 
285e			 
285e			 
285e			 
285e			;		NEXT 
285e			.SCOLN: 
285e			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
285e 06			db OPCODE_SCOLN 
285f aa 28		dw .DROP 
2861 02			db 2 
2862 .. 00		db ";",0           
2864			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2864				if DEBUG_FORTH_WORDS_KEY 
2864					DMARK "SCN" 
2864 f5				push af  
2865 3a 79 28			ld a, (.dmark)  
2868 32 a0 fd			ld (debug_mark),a  
286b 3a 7a 28			ld a, (.dmark+1)  
286e 32 a1 fd			ld (debug_mark+1),a  
2871 3a 7b 28			ld a, (.dmark+2)  
2874 32 a2 fd			ld (debug_mark+2),a  
2877 18 03			jr .pastdmark  
2879 ..			.dmark: db "SCN"  
287c f1			.pastdmark: pop af  
287d			endm  
# End of macro DMARK
287d					CALLMONITOR 
287d cd aa fd			call debug_vector  
2880				endm  
# End of macro CALLMONITOR
2880				endif 
2880				FORTH_RSP_TOS 
2880 cd 06 20			call macro_forth_rsp_tos 
2883				endm 
# End of macro FORTH_RSP_TOS
2883 e5				push hl 
2884				FORTH_RSP_POP 
2884 cd 10 20			call macro_forth_rsp_pop 
2887				endm 
# End of macro FORTH_RSP_POP
2887 e1				pop hl 
2888			;		ex de,hl 
2888 22 f7 f3			ld (os_tok_ptr),hl 
288b			 
288b			if DEBUG_FORTH_UWORD 
288b					DMARK "SCL" 
288b f5				push af  
288c 3a a0 28			ld a, (.dmark)  
288f 32 a0 fd			ld (debug_mark),a  
2892 3a a1 28			ld a, (.dmark+1)  
2895 32 a1 fd			ld (debug_mark+1),a  
2898 3a a2 28			ld a, (.dmark+2)  
289b 32 a2 fd			ld (debug_mark+2),a  
289e 18 03			jr .pastdmark  
28a0 ..			.dmark: db "SCL"  
28a3 f1			.pastdmark: pop af  
28a4			endm  
# End of macro DMARK
28a4			CALLMONITOR 
28a4 cd aa fd			call debug_vector  
28a7				endm  
# End of macro CALLMONITOR
28a7			endif 
28a7				NEXTW 
28a7 c3 39 24			jp macro_next 
28aa				endm 
# End of macro NEXTW
28aa			 
28aa			.DROP: 
28aa			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
28aa 1b				db WORD_SYS_CORE+OPCODE_DROP             
28ab d5 28			dw .DUP2            
28ad 05				db 4 + 1 
28ae .. 00			db "DROP",0              
28b3				endm 
# End of macro CWHEAD
28b3			; | DROP ( w -- )   drop the TOS item   | DONE 
28b3				if DEBUG_FORTH_WORDS_KEY 
28b3					DMARK "DRP" 
28b3 f5				push af  
28b4 3a c8 28			ld a, (.dmark)  
28b7 32 a0 fd			ld (debug_mark),a  
28ba 3a c9 28			ld a, (.dmark+1)  
28bd 32 a1 fd			ld (debug_mark+1),a  
28c0 3a ca 28			ld a, (.dmark+2)  
28c3 32 a2 fd			ld (debug_mark+2),a  
28c6 18 03			jr .pastdmark  
28c8 ..			.dmark: db "DRP"  
28cb f1			.pastdmark: pop af  
28cc			endm  
# End of macro DMARK
28cc					CALLMONITOR 
28cc cd aa fd			call debug_vector  
28cf				endm  
# End of macro CALLMONITOR
28cf				endif 
28cf				FORTH_DSP_POP 
28cf cd 05 23			call macro_forth_dsp_pop 
28d2				endm 
# End of macro FORTH_DSP_POP
28d2				NEXTW 
28d2 c3 39 24			jp macro_next 
28d5				endm 
# End of macro NEXTW
28d5			.DUP2: 
28d5			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
28d5 1c				db WORD_SYS_CORE+OPCODE_DUP2             
28d6 1a 29			dw .DROP2            
28d8 05				db 4 + 1 
28d9 .. 00			db "2DUP",0              
28de				endm 
# End of macro CWHEAD
28de			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
28de				if DEBUG_FORTH_WORDS_KEY 
28de					DMARK "2DU" 
28de f5				push af  
28df 3a f3 28			ld a, (.dmark)  
28e2 32 a0 fd			ld (debug_mark),a  
28e5 3a f4 28			ld a, (.dmark+1)  
28e8 32 a1 fd			ld (debug_mark+1),a  
28eb 3a f5 28			ld a, (.dmark+2)  
28ee 32 a2 fd			ld (debug_mark+2),a  
28f1 18 03			jr .pastdmark  
28f3 ..			.dmark: db "2DU"  
28f6 f1			.pastdmark: pop af  
28f7			endm  
# End of macro DMARK
28f7					CALLMONITOR 
28f7 cd aa fd			call debug_vector  
28fa				endm  
# End of macro CALLMONITOR
28fa				endif 
28fa				FORTH_DSP_VALUEHL 
28fa cd 4d 22			call macro_dsp_valuehl 
28fd				endm 
# End of macro FORTH_DSP_VALUEHL
28fd e5				push hl      ; 2 
28fe			 
28fe				FORTH_DSP_POP 
28fe cd 05 23			call macro_forth_dsp_pop 
2901				endm 
# End of macro FORTH_DSP_POP
2901				 
2901				FORTH_DSP_VALUEHL 
2901 cd 4d 22			call macro_dsp_valuehl 
2904				endm 
# End of macro FORTH_DSP_VALUEHL
2904			;		push hl      ; 1 
2904			 
2904				FORTH_DSP_POP 
2904 cd 05 23			call macro_forth_dsp_pop 
2907				endm 
# End of macro FORTH_DSP_POP
2907			 
2907			;		pop hl       ; 1 
2907 d1				pop de       ; 2 
2908			 
2908 cd 48 20			call forth_push_numhl 
290b eb				ex de, hl 
290c cd 48 20			call forth_push_numhl 
290f			 
290f				 
290f eb				ex de, hl 
2910			 
2910 cd 48 20			call forth_push_numhl 
2913 eb				ex de, hl 
2914 cd 48 20			call forth_push_numhl 
2917			 
2917			 
2917				NEXTW 
2917 c3 39 24			jp macro_next 
291a				endm 
# End of macro NEXTW
291a			.DROP2: 
291a			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
291a 1d				db WORD_SYS_CORE+OPCODE_DROP2             
291b 49 29			dw .PICK            
291d 06				db 5 + 1 
291e .. 00			db "2DROP",0              
2924				endm 
# End of macro CWHEAD
2924			; | 2DROP ( w w -- )    Double drop | DONE 
2924				if DEBUG_FORTH_WORDS_KEY 
2924					DMARK "2DR" 
2924 f5				push af  
2925 3a 39 29			ld a, (.dmark)  
2928 32 a0 fd			ld (debug_mark),a  
292b 3a 3a 29			ld a, (.dmark+1)  
292e 32 a1 fd			ld (debug_mark+1),a  
2931 3a 3b 29			ld a, (.dmark+2)  
2934 32 a2 fd			ld (debug_mark+2),a  
2937 18 03			jr .pastdmark  
2939 ..			.dmark: db "2DR"  
293c f1			.pastdmark: pop af  
293d			endm  
# End of macro DMARK
293d					CALLMONITOR 
293d cd aa fd			call debug_vector  
2940				endm  
# End of macro CALLMONITOR
2940				endif 
2940				FORTH_DSP_POP 
2940 cd 05 23			call macro_forth_dsp_pop 
2943				endm 
# End of macro FORTH_DSP_POP
2943				FORTH_DSP_POP 
2943 cd 05 23			call macro_forth_dsp_pop 
2946				endm 
# End of macro FORTH_DSP_POP
2946				NEXTW 
2946 c3 39 24			jp macro_next 
2949				endm 
# End of macro NEXTW
2949			.PICK: 
2949			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
2949 77				db WORD_SYS_CORE+99             
294a 87 29			dw .SWAP2            
294c 05				db 4 + 1 
294d .. 00			db "PICK",0              
2952				endm 
# End of macro CWHEAD
2952			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | TODO 
2952				if DEBUG_FORTH_WORDS_KEY 
2952					DMARK "PIK" 
2952 f5				push af  
2953 3a 67 29			ld a, (.dmark)  
2956 32 a0 fd			ld (debug_mark),a  
2959 3a 68 29			ld a, (.dmark+1)  
295c 32 a1 fd			ld (debug_mark+1),a  
295f 3a 69 29			ld a, (.dmark+2)  
2962 32 a2 fd			ld (debug_mark+2),a  
2965 18 03			jr .pastdmark  
2967 ..			.dmark: db "PIK"  
296a f1			.pastdmark: pop af  
296b			endm  
# End of macro DMARK
296b					CALLMONITOR 
296b cd aa fd			call debug_vector  
296e				endm  
# End of macro CALLMONITOR
296e				endif 
296e			 
296e				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
296e cd 4d 22			call macro_dsp_valuehl 
2971				endm 
# End of macro FORTH_DSP_VALUEHL
2971				 
2971				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2971 cd 05 23			call macro_forth_dsp_pop 
2974				endm 
# End of macro FORTH_DSP_POP
2974			 
2974				; init from TOS 
2974 45				ld b, l 
2975 21 23 f9			ld hl, cli_data_sp 
2978			.pkl: 
2978 2b				dec hl 
2979 2b				dec hl 
297a 2b				dec hl 
297b			 
297b 10 fb			djnz .pkl 
297d			 
297d				 
297d				; TODO do type check with correct push 
297d			 
297d 23				inc hl 
297e cd bb 23			call loadwordinhl 
2981 cd 48 20			call forth_push_numhl 
2984			 
2984				NEXTW 
2984 c3 39 24			jp macro_next 
2987				endm 
# End of macro NEXTW
2987			.SWAP2: 
2987			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2987 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2988 b0 29			dw .AT            
298a 06				db 5 + 1 
298b .. 00			db "2SWAP",0              
2991				endm 
# End of macro CWHEAD
2991			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
2991				if DEBUG_FORTH_WORDS_KEY 
2991					DMARK "2SW" 
2991 f5				push af  
2992 3a a6 29			ld a, (.dmark)  
2995 32 a0 fd			ld (debug_mark),a  
2998 3a a7 29			ld a, (.dmark+1)  
299b 32 a1 fd			ld (debug_mark+1),a  
299e 3a a8 29			ld a, (.dmark+2)  
29a1 32 a2 fd			ld (debug_mark+2),a  
29a4 18 03			jr .pastdmark  
29a6 ..			.dmark: db "2SW"  
29a9 f1			.pastdmark: pop af  
29aa			endm  
# End of macro DMARK
29aa					CALLMONITOR 
29aa cd aa fd			call debug_vector  
29ad				endm  
# End of macro CALLMONITOR
29ad				endif 
29ad			; TODO Use os stack swap memory 
29ad				NEXTW 
29ad c3 39 24			jp macro_next 
29b0				endm 
# End of macro NEXTW
29b0			.AT: 
29b0			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
29b0 1f				db WORD_SYS_CORE+OPCODE_AT             
29b1 e2 29			dw .CAT            
29b3 02				db 1 + 1 
29b4 .. 00			db "@",0              
29b6				endm 
# End of macro CWHEAD
29b6			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
29b6			 
29b6				if DEBUG_FORTH_WORDS_KEY 
29b6					DMARK "AT." 
29b6 f5				push af  
29b7 3a cb 29			ld a, (.dmark)  
29ba 32 a0 fd			ld (debug_mark),a  
29bd 3a cc 29			ld a, (.dmark+1)  
29c0 32 a1 fd			ld (debug_mark+1),a  
29c3 3a cd 29			ld a, (.dmark+2)  
29c6 32 a2 fd			ld (debug_mark+2),a  
29c9 18 03			jr .pastdmark  
29cb ..			.dmark: db "AT."  
29ce f1			.pastdmark: pop af  
29cf			endm  
# End of macro DMARK
29cf					CALLMONITOR 
29cf cd aa fd			call debug_vector  
29d2				endm  
# End of macro CALLMONITOR
29d2				endif 
29d2			.getbyteat:	 
29d2				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29d2 cd 4d 22			call macro_dsp_valuehl 
29d5				endm 
# End of macro FORTH_DSP_VALUEHL
29d5				 
29d5			;		push hl 
29d5			 
29d5				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29d5 cd 05 23			call macro_forth_dsp_pop 
29d8				endm 
# End of macro FORTH_DSP_POP
29d8			 
29d8			;		pop hl 
29d8			 
29d8 7e				ld a, (hl) 
29d9			 
29d9 6f				ld l, a 
29da 26 00			ld h, 0 
29dc cd 48 20			call forth_push_numhl 
29df			 
29df				NEXTW 
29df c3 39 24			jp macro_next 
29e2				endm 
# End of macro NEXTW
29e2			.CAT: 
29e2			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
29e2 20				db WORD_SYS_CORE+OPCODE_CAT             
29e3 0b 2a			dw .BANG            
29e5 03				db 2 + 1 
29e6 .. 00			db "C@",0              
29e9				endm 
# End of macro CWHEAD
29e9			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
29e9				if DEBUG_FORTH_WORDS_KEY 
29e9					DMARK "CAA" 
29e9 f5				push af  
29ea 3a fe 29			ld a, (.dmark)  
29ed 32 a0 fd			ld (debug_mark),a  
29f0 3a ff 29			ld a, (.dmark+1)  
29f3 32 a1 fd			ld (debug_mark+1),a  
29f6 3a 00 2a			ld a, (.dmark+2)  
29f9 32 a2 fd			ld (debug_mark+2),a  
29fc 18 03			jr .pastdmark  
29fe ..			.dmark: db "CAA"  
2a01 f1			.pastdmark: pop af  
2a02			endm  
# End of macro DMARK
2a02					CALLMONITOR 
2a02 cd aa fd			call debug_vector  
2a05				endm  
# End of macro CALLMONITOR
2a05				endif 
2a05 c3 d2 29			jp .getbyteat 
2a08				NEXTW 
2a08 c3 39 24			jp macro_next 
2a0b				endm 
# End of macro NEXTW
2a0b			.BANG: 
2a0b			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2a0b 21				db WORD_SYS_CORE+OPCODE_BANG             
2a0c 41 2a			dw .CBANG            
2a0e 02				db 1 + 1 
2a0f .. 00			db "!",0              
2a11				endm 
# End of macro CWHEAD
2a11			; | ! ( x w -- ) Store x at address w      | DONE 
2a11				if DEBUG_FORTH_WORDS_KEY 
2a11					DMARK "BNG" 
2a11 f5				push af  
2a12 3a 26 2a			ld a, (.dmark)  
2a15 32 a0 fd			ld (debug_mark),a  
2a18 3a 27 2a			ld a, (.dmark+1)  
2a1b 32 a1 fd			ld (debug_mark+1),a  
2a1e 3a 28 2a			ld a, (.dmark+2)  
2a21 32 a2 fd			ld (debug_mark+2),a  
2a24 18 03			jr .pastdmark  
2a26 ..			.dmark: db "BNG"  
2a29 f1			.pastdmark: pop af  
2a2a			endm  
# End of macro DMARK
2a2a					CALLMONITOR 
2a2a cd aa fd			call debug_vector  
2a2d				endm  
# End of macro CALLMONITOR
2a2d				endif 
2a2d			 
2a2d			.storebyteat:		 
2a2d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a2d cd 4d 22			call macro_dsp_valuehl 
2a30				endm 
# End of macro FORTH_DSP_VALUEHL
2a30				 
2a30 e5				push hl 
2a31			 
2a31				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a31 cd 05 23			call macro_forth_dsp_pop 
2a34				endm 
# End of macro FORTH_DSP_POP
2a34			 
2a34				; get byte to poke 
2a34			 
2a34				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a34 cd 4d 22			call macro_dsp_valuehl 
2a37				endm 
# End of macro FORTH_DSP_VALUEHL
2a37 e5				push hl 
2a38			 
2a38			 
2a38				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a38 cd 05 23			call macro_forth_dsp_pop 
2a3b				endm 
# End of macro FORTH_DSP_POP
2a3b			 
2a3b			 
2a3b d1				pop de 
2a3c e1				pop hl 
2a3d			 
2a3d 73				ld (hl),e 
2a3e			 
2a3e			 
2a3e				NEXTW 
2a3e c3 39 24			jp macro_next 
2a41				endm 
# End of macro NEXTW
2a41			.CBANG: 
2a41			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2a41 22				db WORD_SYS_CORE+OPCODE_CBANG             
2a42 6a 2a			dw .SCALL            
2a44 03				db 2 + 1 
2a45 .. 00			db "C!",0              
2a48				endm 
# End of macro CWHEAD
2a48			; | C!  ( x w -- ) Store x at address w  | DONE 
2a48				if DEBUG_FORTH_WORDS_KEY 
2a48					DMARK "CBA" 
2a48 f5				push af  
2a49 3a 5d 2a			ld a, (.dmark)  
2a4c 32 a0 fd			ld (debug_mark),a  
2a4f 3a 5e 2a			ld a, (.dmark+1)  
2a52 32 a1 fd			ld (debug_mark+1),a  
2a55 3a 5f 2a			ld a, (.dmark+2)  
2a58 32 a2 fd			ld (debug_mark+2),a  
2a5b 18 03			jr .pastdmark  
2a5d ..			.dmark: db "CBA"  
2a60 f1			.pastdmark: pop af  
2a61			endm  
# End of macro DMARK
2a61					CALLMONITOR 
2a61 cd aa fd			call debug_vector  
2a64				endm  
# End of macro CALLMONITOR
2a64				endif 
2a64 c3 2d 2a			jp .storebyteat 
2a67				NEXTW 
2a67 c3 39 24			jp macro_next 
2a6a				endm 
# End of macro NEXTW
2a6a			.SCALL: 
2a6a			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2a6a 23				db WORD_SYS_CORE+OPCODE_SCALL             
2a6b 9e 2a			dw .DEPTH            
2a6d 05				db 4 + 1 
2a6e .. 00			db "CALL",0              
2a73				endm 
# End of macro CWHEAD
2a73			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2a73				if DEBUG_FORTH_WORDS_KEY 
2a73					DMARK "CLL" 
2a73 f5				push af  
2a74 3a 88 2a			ld a, (.dmark)  
2a77 32 a0 fd			ld (debug_mark),a  
2a7a 3a 89 2a			ld a, (.dmark+1)  
2a7d 32 a1 fd			ld (debug_mark+1),a  
2a80 3a 8a 2a			ld a, (.dmark+2)  
2a83 32 a2 fd			ld (debug_mark+2),a  
2a86 18 03			jr .pastdmark  
2a88 ..			.dmark: db "CLL"  
2a8b f1			.pastdmark: pop af  
2a8c			endm  
# End of macro DMARK
2a8c					CALLMONITOR 
2a8c cd aa fd			call debug_vector  
2a8f				endm  
# End of macro CALLMONITOR
2a8f				endif 
2a8f			 
2a8f				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2a8f cd 4d 22			call macro_dsp_valuehl 
2a92				endm 
# End of macro FORTH_DSP_VALUEHL
2a92			 
2a92			;		push hl 
2a92			 
2a92				; destroy value TOS 
2a92			 
2a92				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2a92 cd 05 23			call macro_forth_dsp_pop 
2a95				endm 
# End of macro FORTH_DSP_POP
2a95			 
2a95					 
2a95			;		pop hl 
2a95			 
2a95				; how to do a call with hl???? save SP? 
2a95 cd dd 23			call forth_call_hl 
2a98			 
2a98			 
2a98				; TODO push value back onto stack for another op etc 
2a98			 
2a98 cd 48 20			call forth_push_numhl 
2a9b				NEXTW 
2a9b c3 39 24			jp macro_next 
2a9e				endm 
# End of macro NEXTW
2a9e			.DEPTH: 
2a9e			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2a9e 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2a9f db 2a			dw .OVER            
2aa1 06				db 5 + 1 
2aa2 .. 00			db "DEPTH",0              
2aa8				endm 
# End of macro CWHEAD
2aa8			; | DEPTH ( -- u ) Push count of stack | DONE 
2aa8				; take current TOS and remove from base value div by two to get count 
2aa8				if DEBUG_FORTH_WORDS_KEY 
2aa8					DMARK "DEP" 
2aa8 f5				push af  
2aa9 3a bd 2a			ld a, (.dmark)  
2aac 32 a0 fd			ld (debug_mark),a  
2aaf 3a be 2a			ld a, (.dmark+1)  
2ab2 32 a1 fd			ld (debug_mark+1),a  
2ab5 3a bf 2a			ld a, (.dmark+2)  
2ab8 32 a2 fd			ld (debug_mark+2),a  
2abb 18 03			jr .pastdmark  
2abd ..			.dmark: db "DEP"  
2ac0 f1			.pastdmark: pop af  
2ac1			endm  
# End of macro DMARK
2ac1					CALLMONITOR 
2ac1 cd aa fd			call debug_vector  
2ac4				endm  
# End of macro CALLMONITOR
2ac4				endif 
2ac4			 
2ac4			 
2ac4 2a 23 f9		ld hl, (cli_data_sp) 
2ac7 11 5d f6		ld de, cli_data_stack 
2aca ed 52		sbc hl,de 
2acc			 
2acc			; div by size of stack item 
2acc			 
2acc 5d			ld e,l 
2acd 0e 03		ld c, 3 
2acf cd 6e 0f		call Div8 
2ad2			 
2ad2 6f			ld l,a 
2ad3 26 00		ld h,0 
2ad5			 
2ad5			;srl h 
2ad5			;rr l 
2ad5			 
2ad5 cd 48 20			call forth_push_numhl 
2ad8				NEXTW 
2ad8 c3 39 24			jp macro_next 
2adb				endm 
# End of macro NEXTW
2adb			.OVER: 
2adb			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2adb 42				db WORD_SYS_CORE+46             
2adc 22 2b			dw .PAUSE            
2ade 05				db 4 + 1 
2adf .. 00			db "OVER",0              
2ae4				endm 
# End of macro CWHEAD
2ae4			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | TOFIX 
2ae4				if DEBUG_FORTH_WORDS_KEY 
2ae4					DMARK "OVR" 
2ae4 f5				push af  
2ae5 3a f9 2a			ld a, (.dmark)  
2ae8 32 a0 fd			ld (debug_mark),a  
2aeb 3a fa 2a			ld a, (.dmark+1)  
2aee 32 a1 fd			ld (debug_mark+1),a  
2af1 3a fb 2a			ld a, (.dmark+2)  
2af4 32 a2 fd			ld (debug_mark+2),a  
2af7 18 03			jr .pastdmark  
2af9 ..			.dmark: db "OVR"  
2afc f1			.pastdmark: pop af  
2afd			endm  
# End of macro DMARK
2afd					CALLMONITOR 
2afd cd aa fd			call debug_vector  
2b00				endm  
# End of macro CALLMONITOR
2b00				endif 
2b00			 
2b00			; TODO Use os stack swap memory 
2b00			 
2b00				; work out what type we are looking at 
2b00			 
2b00				FORTH_DSP_PTR 1 
2b00 2a 23 f9			ld hl,(cli_data_sp) 
2b03 11 03 00			ld de, 1 * 3 
2b06 ed 52			sbc hl, de 
2b08				endm 
# End of macro FORTH_DSP_PTR
2b08			 
2b08 7e				ld a, (hl) 
2b09				 
2b09 f5				push af 
2b0a				; whatever the type lets get the pointer or word 
2b0a 23				inc hl 
2b0b			;; 
2b0b			 
2b0b				; type check now to decide on how to push  
2b0b			 
2b0b cd bb 23			call loadwordinhl 
2b0e f1				pop af 
2b0f fe 01			cp DS_TYPE_STR 
2b11 28 06			jr z, .ovstr 
2b13			 
2b13				; we have a numeric so load the word and push 
2b13			;	ld e, (hl) 
2b13			;	inc hl 
2b13			;	ld d, (hl) 
2b13			;	ex de, hl 
2b13 cd 48 20			call forth_push_numhl 
2b16				NEXTW 
2b16 c3 39 24			jp macro_next 
2b19				endm 
# End of macro NEXTW
2b19			 
2b19			.ovstr: 
2b19				; ok, a string so get the pointer and push as a string 
2b19			 
2b19			;	call loadwordinhl 
2b19 cd b6 20			call forth_push_str 
2b1c				NEXTW 
2b1c c3 39 24			jp macro_next 
2b1f				endm 
# End of macro NEXTW
2b1f			 
2b1f			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b1f			;	push hl    ; n2 
2b1f			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b1f			; 
2b1f			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b1f			;	push hl    ; n1 
2b1f			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b1f			; 
2b1f			;	pop de     ; n1 
2b1f			;	pop hl     ; n2 
2b1f			; 
2b1f			;	push de 
2b1f			;	push hl 
2b1f			;	push de 
2b1f			 
2b1f				; push back  
2b1f			 
2b1f			;	pop hl 
2b1f			;	call forth_push_numhl 
2b1f			;	pop hl 
2b1f			;	call forth_push_numhl 
2b1f			;	pop hl 
2b1f			;	call forth_push_numhl 
2b1f				NEXTW 
2b1f c3 39 24			jp macro_next 
2b22				endm 
# End of macro NEXTW
2b22			 
2b22			.PAUSE: 
2b22			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2b22 43				db WORD_SYS_CORE+47             
2b23 57 2b			dw .PAUSES            
2b25 08				db 7 + 1 
2b26 .. 00			db "PAUSEMS",0              
2b2e				endm 
# End of macro CWHEAD
2b2e			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2b2e				if DEBUG_FORTH_WORDS_KEY 
2b2e					DMARK "PMS" 
2b2e f5				push af  
2b2f 3a 43 2b			ld a, (.dmark)  
2b32 32 a0 fd			ld (debug_mark),a  
2b35 3a 44 2b			ld a, (.dmark+1)  
2b38 32 a1 fd			ld (debug_mark+1),a  
2b3b 3a 45 2b			ld a, (.dmark+2)  
2b3e 32 a2 fd			ld (debug_mark+2),a  
2b41 18 03			jr .pastdmark  
2b43 ..			.dmark: db "PMS"  
2b46 f1			.pastdmark: pop af  
2b47			endm  
# End of macro DMARK
2b47					CALLMONITOR 
2b47 cd aa fd			call debug_vector  
2b4a				endm  
# End of macro CALLMONITOR
2b4a				endif 
2b4a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b4a cd 4d 22			call macro_dsp_valuehl 
2b4d				endm 
# End of macro FORTH_DSP_VALUEHL
2b4d			;		push hl    ; n2 
2b4d				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b4d cd 05 23			call macro_forth_dsp_pop 
2b50				endm 
# End of macro FORTH_DSP_POP
2b50			;		pop hl 
2b50			 
2b50 7d				ld a, l 
2b51 cd d2 0c			call aDelayInMS 
2b54			       NEXTW 
2b54 c3 39 24			jp macro_next 
2b57				endm 
# End of macro NEXTW
2b57			.PAUSES:  
2b57			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2b57 44				db WORD_SYS_CORE+48             
2b58 c6 2b			dw .ROT            
2b5a 06				db 5 + 1 
2b5b .. 00			db "PAUSE",0              
2b61				endm 
# End of macro CWHEAD
2b61			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2b61				if DEBUG_FORTH_WORDS_KEY 
2b61					DMARK "PAU" 
2b61 f5				push af  
2b62 3a 76 2b			ld a, (.dmark)  
2b65 32 a0 fd			ld (debug_mark),a  
2b68 3a 77 2b			ld a, (.dmark+1)  
2b6b 32 a1 fd			ld (debug_mark+1),a  
2b6e 3a 78 2b			ld a, (.dmark+2)  
2b71 32 a2 fd			ld (debug_mark+2),a  
2b74 18 03			jr .pastdmark  
2b76 ..			.dmark: db "PAU"  
2b79 f1			.pastdmark: pop af  
2b7a			endm  
# End of macro DMARK
2b7a					CALLMONITOR 
2b7a cd aa fd			call debug_vector  
2b7d				endm  
# End of macro CALLMONITOR
2b7d				endif 
2b7d				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b7d cd 4d 22			call macro_dsp_valuehl 
2b80				endm 
# End of macro FORTH_DSP_VALUEHL
2b80			;		push hl    ; n2 
2b80				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b80 cd 05 23			call macro_forth_dsp_pop 
2b83				endm 
# End of macro FORTH_DSP_POP
2b83			;		pop hl 
2b83 45				ld b, l 
2b84				if DEBUG_FORTH_WORDS 
2b84					DMARK "PAU" 
2b84 f5				push af  
2b85 3a 99 2b			ld a, (.dmark)  
2b88 32 a0 fd			ld (debug_mark),a  
2b8b 3a 9a 2b			ld a, (.dmark+1)  
2b8e 32 a1 fd			ld (debug_mark+1),a  
2b91 3a 9b 2b			ld a, (.dmark+2)  
2b94 32 a2 fd			ld (debug_mark+2),a  
2b97 18 03			jr .pastdmark  
2b99 ..			.dmark: db "PAU"  
2b9c f1			.pastdmark: pop af  
2b9d			endm  
# End of macro DMARK
2b9d					CALLMONITOR 
2b9d cd aa fd			call debug_vector  
2ba0				endm  
# End of macro CALLMONITOR
2ba0				endif 
2ba0 c5			.pauses1:	push bc 
2ba1 cd ed 0c			call delay1s 
2ba4 c1				pop bc 
2ba5				if DEBUG_FORTH_WORDS 
2ba5					DMARK "PA1" 
2ba5 f5				push af  
2ba6 3a ba 2b			ld a, (.dmark)  
2ba9 32 a0 fd			ld (debug_mark),a  
2bac 3a bb 2b			ld a, (.dmark+1)  
2baf 32 a1 fd			ld (debug_mark+1),a  
2bb2 3a bc 2b			ld a, (.dmark+2)  
2bb5 32 a2 fd			ld (debug_mark+2),a  
2bb8 18 03			jr .pastdmark  
2bba ..			.dmark: db "PA1"  
2bbd f1			.pastdmark: pop af  
2bbe			endm  
# End of macro DMARK
2bbe					CALLMONITOR 
2bbe cd aa fd			call debug_vector  
2bc1				endm  
# End of macro CALLMONITOR
2bc1				endif 
2bc1 10 dd			djnz .pauses1 
2bc3			 
2bc3			       NEXTW 
2bc3 c3 39 24			jp macro_next 
2bc6				endm 
# End of macro NEXTW
2bc6			.ROT: 
2bc6			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2bc6 45				db WORD_SYS_CORE+49             
2bc7 2f 2c			dw .UWORDS            
2bc9 04				db 3 + 1 
2bca .. 00			db "ROT",0              
2bce				endm 
# End of macro CWHEAD
2bce			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | TOFIX 
2bce				if DEBUG_FORTH_WORDS_KEY 
2bce					DMARK "ROT" 
2bce f5				push af  
2bcf 3a e3 2b			ld a, (.dmark)  
2bd2 32 a0 fd			ld (debug_mark),a  
2bd5 3a e4 2b			ld a, (.dmark+1)  
2bd8 32 a1 fd			ld (debug_mark+1),a  
2bdb 3a e5 2b			ld a, (.dmark+2)  
2bde 32 a2 fd			ld (debug_mark+2),a  
2be1 18 03			jr .pastdmark  
2be3 ..			.dmark: db "ROT"  
2be6 f1			.pastdmark: pop af  
2be7			endm  
# End of macro DMARK
2be7					CALLMONITOR 
2be7 cd aa fd			call debug_vector  
2bea				endm  
# End of macro CALLMONITOR
2bea				endif 
2bea			 
2bea			; DONE Use os stack swap memory 
2bea			 
2bea				FORTH_DSP_PTR 0     ; u3 
2bea 2a 23 f9			ld hl,(cli_data_sp) 
2bed 11 00 00			ld de, 0 * 3 
2bf0 ed 52			sbc hl, de 
2bf2				endm 
# End of macro FORTH_DSP_PTR
2bf2 cd 85 23			call hltostack1     
2bf5			  
2bf5				FORTH_DSP_PTR 1     ; u2 
2bf5 2a 23 f9			ld hl,(cli_data_sp) 
2bf8 11 03 00			ld de, 1 * 3 
2bfb ed 52			sbc hl, de 
2bfd				endm 
# End of macro FORTH_DSP_PTR
2bfd cd 8b 23			call hltostack2      
2c00			 
2c00				FORTH_DSP_PTR 2     ; u1 
2c00 2a 23 f9			ld hl,(cli_data_sp) 
2c03 11 06 00			ld de, 2 * 3 
2c06 ed 52			sbc hl, de 
2c08				endm 
# End of macro FORTH_DSP_PTR
2c08 cd 91 23			call hltostack3 
2c0b			 
2c0b			 
2c0b				FORTH_DSP_PTR 0     ;  
2c0b 2a 23 f9			ld hl,(cli_data_sp) 
2c0e 11 00 00			ld de, 0 * 3 
2c11 ed 52			sbc hl, de 
2c13				endm 
# End of macro FORTH_DSP_PTR
2c13 cd a9 23			call hlfromstack3 
2c16			 
2c16				FORTH_DSP_PTR 1     ; TOS 
2c16 2a 23 f9			ld hl,(cli_data_sp) 
2c19 11 03 00			ld de, 1 * 3 
2c1c ed 52			sbc hl, de 
2c1e				endm 
# End of macro FORTH_DSP_PTR
2c1e cd 9d 23			call hlfromstack1 
2c21			 
2c21				FORTH_DSP_PTR 2     ; TOS 
2c21 2a 23 f9			ld hl,(cli_data_sp) 
2c24 11 06 00			ld de, 2 * 3 
2c27 ed 52			sbc hl, de 
2c29				endm 
# End of macro FORTH_DSP_PTR
2c29 cd a3 23			call hlfromstack2 
2c2c			 
2c2c			 
2c2c			;	FORTH_DSP_VALUEHL 
2c2c			;	push hl    ; u3  
2c2c			; 
2c2c			;	FORTH_DSP_POP 
2c2c			; 
2c2c			;	FORTH_DSP_VALUEHL 
2c2c			;	push hl     ; u2 
2c2c			; 
2c2c			;	FORTH_DSP_POP 
2c2c			; 
2c2c			;	FORTH_DSP_VALUEHL 
2c2c			;	push hl     ; u1 
2c2c			; 
2c2c			;	FORTH_DSP_POP 
2c2c			; 
2c2c			;	pop bc      ; u1 
2c2c			;	pop hl      ; u2 
2c2c			;	pop de      ; u3 
2c2c			; 
2c2c			; 
2c2c			;	push bc 
2c2c			;	push de 
2c2c			;	push hl 
2c2c			; 
2c2c			; 
2c2c			;	pop hl 
2c2c			;	call forth_push_numhl 
2c2c			; 
2c2c			;	pop hl 
2c2c			;	call forth_push_numhl 
2c2c			; 
2c2c			;	pop hl 
2c2c			;	call forth_push_numhl 
2c2c				 
2c2c			 
2c2c			 
2c2c			 
2c2c			 
2c2c			 
2c2c			       NEXTW 
2c2c c3 39 24			jp macro_next 
2c2f				endm 
# End of macro NEXTW
2c2f			 
2c2f			.UWORDS: 
2c2f			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2c2f 50				db WORD_SYS_CORE+60             
2c30 f1 2c			dw .BP            
2c32 07				db 6 + 1 
2c33 .. 00			db "UWORDS",0              
2c3a				endm 
# End of macro CWHEAD
2c3a			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2c3a			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2c3a			; | | Following the count are the individual words. 
2c3a			; | | 
2c3a			; | | e.g. UWORDS 
2c3a			; | | BOX DIRLIST 2 
2c3a			; | |  
2c3a			; | | Can be used to save the words to storage via: 
2c3a			; | | UWORDS $01 DO $01 APPEND LOOP 
2c3a			if DEBUG_FORTH_WORDS_KEY 
2c3a				DMARK "UWR" 
2c3a f5				push af  
2c3b 3a 4f 2c			ld a, (.dmark)  
2c3e 32 a0 fd			ld (debug_mark),a  
2c41 3a 50 2c			ld a, (.dmark+1)  
2c44 32 a1 fd			ld (debug_mark+1),a  
2c47 3a 51 2c			ld a, (.dmark+2)  
2c4a 32 a2 fd			ld (debug_mark+2),a  
2c4d 18 03			jr .pastdmark  
2c4f ..			.dmark: db "UWR"  
2c52 f1			.pastdmark: pop af  
2c53			endm  
# End of macro DMARK
2c53				CALLMONITOR 
2c53 cd aa fd			call debug_vector  
2c56				endm  
# End of macro CALLMONITOR
2c56			endif 
2c56 21 00 80			ld hl, baseram 
2c59				;ld hl, baseusermem 
2c59 01 00 00			ld bc, 0    ; start a counter 
2c5c			 
2c5c			; skip dict stub 
2c5c			 
2c5c cd 8a 25			call forth_tok_next 
2c5f			 
2c5f			 
2c5f			; while we have words to look for 
2c5f			 
2c5f 7e			.douscan:	ld a, (hl)      
2c60			if DEBUG_FORTH_WORDS 
2c60				DMARK "UWs" 
2c60 f5				push af  
2c61 3a 75 2c			ld a, (.dmark)  
2c64 32 a0 fd			ld (debug_mark),a  
2c67 3a 76 2c			ld a, (.dmark+1)  
2c6a 32 a1 fd			ld (debug_mark+1),a  
2c6d 3a 77 2c			ld a, (.dmark+2)  
2c70 32 a2 fd			ld (debug_mark+2),a  
2c73 18 03			jr .pastdmark  
2c75 ..			.dmark: db "UWs"  
2c78 f1			.pastdmark: pop af  
2c79			endm  
# End of macro DMARK
2c79				CALLMONITOR 
2c79 cd aa fd			call debug_vector  
2c7c				endm  
# End of macro CALLMONITOR
2c7c			endif 
2c7c fe 00			cp WORD_SYS_END 
2c7e 28 4d			jr z, .udone 
2c80 fe 01			cp WORD_SYS_UWORD 
2c82 20 44			jr nz, .nuword 
2c84			 
2c84			if DEBUG_FORTH_WORDS 
2c84				DMARK "UWu" 
2c84 f5				push af  
2c85 3a 99 2c			ld a, (.dmark)  
2c88 32 a0 fd			ld (debug_mark),a  
2c8b 3a 9a 2c			ld a, (.dmark+1)  
2c8e 32 a1 fd			ld (debug_mark+1),a  
2c91 3a 9b 2c			ld a, (.dmark+2)  
2c94 32 a2 fd			ld (debug_mark+2),a  
2c97 18 03			jr .pastdmark  
2c99 ..			.dmark: db "UWu"  
2c9c f1			.pastdmark: pop af  
2c9d			endm  
# End of macro DMARK
2c9d				CALLMONITOR 
2c9d cd aa fd			call debug_vector  
2ca0				endm  
# End of macro CALLMONITOR
2ca0			endif 
2ca0				; we have a uword so push its name to the stack 
2ca0			 
2ca0 e5				push hl  ; save so we can move to next dict block 
2ca1			 
2ca1				; skip opcode 
2ca1 23				inc hl  
2ca2				; skip next ptr 
2ca2 23				inc hl  
2ca3 23				inc hl 
2ca4				; skip len 
2ca4 23				inc hl 
2ca5			if DEBUG_FORTH_WORDS 
2ca5				DMARK "UWt" 
2ca5 f5				push af  
2ca6 3a ba 2c			ld a, (.dmark)  
2ca9 32 a0 fd			ld (debug_mark),a  
2cac 3a bb 2c			ld a, (.dmark+1)  
2caf 32 a1 fd			ld (debug_mark+1),a  
2cb2 3a bc 2c			ld a, (.dmark+2)  
2cb5 32 a2 fd			ld (debug_mark+2),a  
2cb8 18 03			jr .pastdmark  
2cba ..			.dmark: db "UWt"  
2cbd f1			.pastdmark: pop af  
2cbe			endm  
# End of macro DMARK
2cbe				CALLMONITOR 
2cbe cd aa fd			call debug_vector  
2cc1				endm  
# End of macro CALLMONITOR
2cc1			endif 
2cc1 03				inc bc 
2cc2			 
2cc2 c5				push bc 
2cc3 cd b6 20			call forth_push_str 
2cc6 c1				pop bc 
2cc7			 
2cc7 e1				pop hl 	 
2cc8			 
2cc8 cd 8a 25		.nuword:	call forth_tok_next 
2ccb 18 92			jr .douscan  
2ccd			 
2ccd			.udone:		 ; push count of uwords found 
2ccd c5				push bc 
2cce e1				pop hl 
2ccf			 
2ccf			if DEBUG_FORTH_WORDS 
2ccf				DMARK "UWc" 
2ccf f5				push af  
2cd0 3a e4 2c			ld a, (.dmark)  
2cd3 32 a0 fd			ld (debug_mark),a  
2cd6 3a e5 2c			ld a, (.dmark+1)  
2cd9 32 a1 fd			ld (debug_mark+1),a  
2cdc 3a e6 2c			ld a, (.dmark+2)  
2cdf 32 a2 fd			ld (debug_mark+2),a  
2ce2 18 03			jr .pastdmark  
2ce4 ..			.dmark: db "UWc"  
2ce7 f1			.pastdmark: pop af  
2ce8			endm  
# End of macro DMARK
2ce8				CALLMONITOR 
2ce8 cd aa fd			call debug_vector  
2ceb				endm  
# End of macro CALLMONITOR
2ceb			endif 
2ceb cd 48 20			call forth_push_numhl 
2cee			 
2cee			 
2cee			       NEXTW 
2cee c3 39 24			jp macro_next 
2cf1				endm 
# End of macro NEXTW
2cf1			 
2cf1			.BP: 
2cf1			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2cf1 54				db WORD_SYS_CORE+64             
2cf2 2b 2d			dw .MONITOR            
2cf4 03				db 2 + 1 
2cf5 .. 00			db "BP",0              
2cf8				endm 
# End of macro CWHEAD
2cf8			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2cf8			; | | $00 Will enable the break points within specific code paths 
2cf8			; | | $01 Will disable break points 
2cf8			; | |  
2cf8			; | | By default break points are off. Either the above can be used to enable them 
2cf8			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2cf8			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2cf8			; | | can disable break points. Exiting will then continue boot process. 
2cf8				; get byte count 
2cf8				if DEBUG_FORTH_WORDS_KEY 
2cf8					DMARK "BP." 
2cf8 f5				push af  
2cf9 3a 0d 2d			ld a, (.dmark)  
2cfc 32 a0 fd			ld (debug_mark),a  
2cff 3a 0e 2d			ld a, (.dmark+1)  
2d02 32 a1 fd			ld (debug_mark+1),a  
2d05 3a 0f 2d			ld a, (.dmark+2)  
2d08 32 a2 fd			ld (debug_mark+2),a  
2d0b 18 03			jr .pastdmark  
2d0d ..			.dmark: db "BP."  
2d10 f1			.pastdmark: pop af  
2d11			endm  
# End of macro DMARK
2d11					CALLMONITOR 
2d11 cd aa fd			call debug_vector  
2d14				endm  
# End of macro CALLMONITOR
2d14				endif 
2d14			 
2d14				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2d14 cd 4d 22			call macro_dsp_valuehl 
2d17				endm 
# End of macro FORTH_DSP_VALUEHL
2d17			 
2d17			;		push hl 
2d17			 
2d17				; destroy value TOS 
2d17			 
2d17				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2d17 cd 05 23			call macro_forth_dsp_pop 
2d1a				endm 
# End of macro FORTH_DSP_POP
2d1a			 
2d1a			;		pop hl 
2d1a			 
2d1a 3e 00			ld a,0 
2d1c bd				cp l 
2d1d 28 06			jr z, .bpset 
2d1f			;		ld a, '*' 
2d1f cd 55 19			call bp_off 
2d22				NEXTW 
2d22 c3 39 24			jp macro_next 
2d25				endm 
# End of macro NEXTW
2d25			 
2d25			.bpset:	 
2d25				;	ld (os_view_disable), a 
2d25 cd 49 19			call bp_on 
2d28			 
2d28			 
2d28				NEXTW 
2d28 c3 39 24			jp macro_next 
2d2b				endm 
# End of macro NEXTW
2d2b			 
2d2b			 
2d2b			.MONITOR: 
2d2b			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2d2b 55				db WORD_SYS_CORE+65             
2d2c 5c 2d			dw .MALLOC            
2d2e 08				db 7 + 1 
2d2f .. 00			db "MONITOR",0              
2d37				endm 
# End of macro CWHEAD
2d37			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2d37			; | | At start the current various registers will be displayed with contents. 
2d37			; | | Top right corner will show the most recent debug marker seen. 
2d37			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2d37			; | | and the return stack pointer (RSP). 
2d37			; | | Pressing: 
2d37			; | |    1 - Initial screen 
2d37			; | |    2 - Display a data dump of HL 
2d37			; | |    3 - Display a data dump of DE 
2d37			; | |    4 - Display a data dump of BC 
2d37			; | |    5 - Display a data dump of HL 
2d37			; | |    6 - Display a data dump of DSP 
2d37			; | |    7 - Display a data dump of RSP 
2d37			; | |    8 - Display a data dump of what is at DSP 
2d37			; | |    9 - Display a data dump of what is at RSP 
2d37			; | |    0 - Exit monitor and continue running. This will also enable break points 
2d37			; | |    * - Disable break points 
2d37			; | |    # - Enter traditional monitor mode 
2d37			; | | 
2d37			; | | Monitor Mode 
2d37			; | | ------------ 
2d37			; | | A prompt of '>' will be shown for various commands: 
2d37			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2d37			; | |    C - Continue display a data dump from the last set address 
2d37			; | |    M xxxx - Set start of memory edit at address xx 
2d37			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2d37			; | |    G xxxx - Exec code at specific address 
2d37			; | |    Q - Return to previous 
2d37				if DEBUG_FORTH_WORDS_KEY 
2d37					DMARK "MON" 
2d37 f5				push af  
2d38 3a 4c 2d			ld a, (.dmark)  
2d3b 32 a0 fd			ld (debug_mark),a  
2d3e 3a 4d 2d			ld a, (.dmark+1)  
2d41 32 a1 fd			ld (debug_mark+1),a  
2d44 3a 4e 2d			ld a, (.dmark+2)  
2d47 32 a2 fd			ld (debug_mark+2),a  
2d4a 18 03			jr .pastdmark  
2d4c ..			.dmark: db "MON"  
2d4f f1			.pastdmark: pop af  
2d50			endm  
# End of macro DMARK
2d50					CALLMONITOR 
2d50 cd aa fd			call debug_vector  
2d53				endm  
# End of macro CALLMONITOR
2d53				endif 
2d53			;		ld a, 0 
2d53			;		ld (os_view_disable), a 
2d53 cd 49 19			call bp_on 
2d56			 
2d56				CALLMONITOR 
2d56 cd aa fd			call debug_vector  
2d59				endm  
# End of macro CALLMONITOR
2d59			 
2d59			;	call monitor 
2d59			 
2d59				NEXTW 
2d59 c3 39 24			jp macro_next 
2d5c				endm 
# End of macro NEXTW
2d5c			 
2d5c			 
2d5c			.MALLOC: 
2d5c			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2d5c 56				db WORD_SYS_CORE+66             
2d5d 85 2d			dw .MALLOC2            
2d5f 06				db 5 + 1 
2d60 .. 00			db "ALLOT",0              
2d66				endm 
# End of macro CWHEAD
2d66			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d66				if DEBUG_FORTH_WORDS_KEY 
2d66					DMARK "ALL" 
2d66 f5				push af  
2d67 3a 7b 2d			ld a, (.dmark)  
2d6a 32 a0 fd			ld (debug_mark),a  
2d6d 3a 7c 2d			ld a, (.dmark+1)  
2d70 32 a1 fd			ld (debug_mark+1),a  
2d73 3a 7d 2d			ld a, (.dmark+2)  
2d76 32 a2 fd			ld (debug_mark+2),a  
2d79 18 03			jr .pastdmark  
2d7b ..			.dmark: db "ALL"  
2d7e f1			.pastdmark: pop af  
2d7f			endm  
# End of macro DMARK
2d7f					CALLMONITOR 
2d7f cd aa fd			call debug_vector  
2d82				endm  
# End of macro CALLMONITOR
2d82				endif 
2d82 c3 ac 2d			jp .mallocc 
2d85			.MALLOC2: 
2d85			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2d85 56				db WORD_SYS_CORE+66             
2d86 c3 2d			dw .FREE            
2d88 07				db 6 + 1 
2d89 .. 00			db "MALLOC",0              
2d90				endm 
# End of macro CWHEAD
2d90			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2d90				; get byte count 
2d90				if DEBUG_FORTH_WORDS_KEY 
2d90					DMARK "MAL" 
2d90 f5				push af  
2d91 3a a5 2d			ld a, (.dmark)  
2d94 32 a0 fd			ld (debug_mark),a  
2d97 3a a6 2d			ld a, (.dmark+1)  
2d9a 32 a1 fd			ld (debug_mark+1),a  
2d9d 3a a7 2d			ld a, (.dmark+2)  
2da0 32 a2 fd			ld (debug_mark+2),a  
2da3 18 03			jr .pastdmark  
2da5 ..			.dmark: db "MAL"  
2da8 f1			.pastdmark: pop af  
2da9			endm  
# End of macro DMARK
2da9					CALLMONITOR 
2da9 cd aa fd			call debug_vector  
2dac				endm  
# End of macro CALLMONITOR
2dac				endif 
2dac			.mallocc: 
2dac				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2dac cd 4d 22			call macro_dsp_valuehl 
2daf				endm 
# End of macro FORTH_DSP_VALUEHL
2daf			 
2daf			;		push hl 
2daf			 
2daf				; destroy value TOS 
2daf			 
2daf				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2daf cd 05 23			call macro_forth_dsp_pop 
2db2				endm 
# End of macro FORTH_DSP_POP
2db2			 
2db2			;		pop hl 
2db2 cd b9 13			call malloc 
2db5			if DEBUG_FORTH_MALLOC_GUARD 
2db5 f5				push af 
2db6 cd 07 10			call ishlzero 
2db9			;		ld a, l 
2db9			;		add h 
2db9			;		cp 0 
2db9 f1				pop af 
2dba				 
2dba cc 79 5f			call z,malloc_error 
2dbd			endif 
2dbd			 
2dbd cd 48 20			call forth_push_numhl 
2dc0				NEXTW 
2dc0 c3 39 24			jp macro_next 
2dc3				endm 
# End of macro NEXTW
2dc3			 
2dc3			.FREE: 
2dc3			CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2dc3 57				db WORD_SYS_CORE+67             
2dc4 f4 2d			dw .LIST            
2dc6 05				db 4 + 1 
2dc7 .. 00			db "FREE",0              
2dcc				endm 
# End of macro CWHEAD
2dcc			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2dcc				if DEBUG_FORTH_WORDS_KEY 
2dcc					DMARK "FRE" 
2dcc f5				push af  
2dcd 3a e1 2d			ld a, (.dmark)  
2dd0 32 a0 fd			ld (debug_mark),a  
2dd3 3a e2 2d			ld a, (.dmark+1)  
2dd6 32 a1 fd			ld (debug_mark+1),a  
2dd9 3a e3 2d			ld a, (.dmark+2)  
2ddc 32 a2 fd			ld (debug_mark+2),a  
2ddf 18 03			jr .pastdmark  
2de1 ..			.dmark: db "FRE"  
2de4 f1			.pastdmark: pop af  
2de5			endm  
# End of macro DMARK
2de5					CALLMONITOR 
2de5 cd aa fd			call debug_vector  
2de8				endm  
# End of macro CALLMONITOR
2de8				endif 
2de8				; get address 
2de8			 
2de8				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2de8 cd 4d 22			call macro_dsp_valuehl 
2deb				endm 
# End of macro FORTH_DSP_VALUEHL
2deb			 
2deb			;		push hl 
2deb			 
2deb				; destroy value TOS 
2deb			 
2deb				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2deb cd 05 23			call macro_forth_dsp_pop 
2dee				endm 
# End of macro FORTH_DSP_POP
2dee			 
2dee			;		pop hl 
2dee			if FORTH_ENABLE_MALLOCFREE 
2dee cd 83 14			call free 
2df1			endif 
2df1				NEXTW 
2df1 c3 39 24			jp macro_next 
2df4				endm 
# End of macro NEXTW
2df4			.LIST: 
2df4			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2df4 5c				db WORD_SYS_CORE+72             
2df5 f0 2f			dw .FORGET            
2df7 05				db 4 + 1 
2df8 .. 00			db "LIST",0              
2dfd				endm 
# End of macro CWHEAD
2dfd			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
2dfd			; | | The quoted word must be in upper case. 
2dfd			if DEBUG_FORTH_WORDS_KEY 
2dfd				DMARK "LST" 
2dfd f5				push af  
2dfe 3a 12 2e			ld a, (.dmark)  
2e01 32 a0 fd			ld (debug_mark),a  
2e04 3a 13 2e			ld a, (.dmark+1)  
2e07 32 a1 fd			ld (debug_mark+1),a  
2e0a 3a 14 2e			ld a, (.dmark+2)  
2e0d 32 a2 fd			ld (debug_mark+2),a  
2e10 18 03			jr .pastdmark  
2e12 ..			.dmark: db "LST"  
2e15 f1			.pastdmark: pop af  
2e16			endm  
# End of macro DMARK
2e16				CALLMONITOR 
2e16 cd aa fd			call debug_vector  
2e19				endm  
# End of macro CALLMONITOR
2e19			endif 
2e19			 
2e19				FORTH_DSP_VALUEHL 
2e19 cd 4d 22			call macro_dsp_valuehl 
2e1c				endm 
# End of macro FORTH_DSP_VALUEHL
2e1c			 
2e1c e5				push hl 
2e1d				FORTH_DSP_POP 
2e1d cd 05 23			call macro_forth_dsp_pop 
2e20				endm 
# End of macro FORTH_DSP_POP
2e20 c1				pop bc 
2e21			 
2e21			; Start format of scratch string 
2e21			 
2e21 21 f6 f0			ld hl, scratch 
2e24			 
2e24 3e 3a			ld a, ':' 
2e26 77				ld (hl),a 
2e27 23				inc hl 
2e28 3e 20			ld a, ' ' 
2e2a 77				ld (hl), a 
2e2b			 
2e2b				; Get ptr to the word we need to look up 
2e2b			 
2e2b			;		FORTH_DSP_VALUEHL 
2e2b				;v5 FORTH_DSP_VALUE 
2e2b			; TODO type check 
2e2b			;		inc hl    ; Skip type check  
2e2b			;		push hl 
2e2b			;		ex de, hl    ; put into DE 
2e2b			 
2e2b			 
2e2b 21 00 80			ld hl, baseram 
2e2e				;ld hl, baseusermem 
2e2e			 
2e2e e5			push hl   ; sacreifical push 
2e2f			 
2e2f			.ldouscanm: 
2e2f e1			pop hl 
2e30			.ldouscan: 
2e30			if DEBUG_FORTH_WORDS 
2e30				DMARK "LSs" 
2e30 f5				push af  
2e31 3a 45 2e			ld a, (.dmark)  
2e34 32 a0 fd			ld (debug_mark),a  
2e37 3a 46 2e			ld a, (.dmark+1)  
2e3a 32 a1 fd			ld (debug_mark+1),a  
2e3d 3a 47 2e			ld a, (.dmark+2)  
2e40 32 a2 fd			ld (debug_mark+2),a  
2e43 18 03			jr .pastdmark  
2e45 ..			.dmark: db "LSs"  
2e48 f1			.pastdmark: pop af  
2e49			endm  
# End of macro DMARK
2e49				CALLMONITOR 
2e49 cd aa fd			call debug_vector  
2e4c				endm  
# End of macro CALLMONITOR
2e4c			endif 
2e4c			; skip dict stub 
2e4c cd 8a 25			call forth_tok_next 
2e4f			 
2e4f			 
2e4f			; while we have words to look for 
2e4f			 
2e4f 7e			ld a, (hl)      
2e50			if DEBUG_FORTH_WORDS 
2e50				DMARK "LSk" 
2e50 f5				push af  
2e51 3a 65 2e			ld a, (.dmark)  
2e54 32 a0 fd			ld (debug_mark),a  
2e57 3a 66 2e			ld a, (.dmark+1)  
2e5a 32 a1 fd			ld (debug_mark+1),a  
2e5d 3a 67 2e			ld a, (.dmark+2)  
2e60 32 a2 fd			ld (debug_mark+2),a  
2e63 18 03			jr .pastdmark  
2e65 ..			.dmark: db "LSk"  
2e68 f1			.pastdmark: pop af  
2e69			endm  
# End of macro DMARK
2e69				CALLMONITOR 
2e69 cd aa fd			call debug_vector  
2e6c				endm  
# End of macro CALLMONITOR
2e6c			endif 
2e6c				;cp WORD_SYS_END 
2e6c				;jp z, .lunotfound 
2e6c			 
2e6c					; if we hit non uwords then gone too far 
2e6c fe 01				cp WORD_SYS_UWORD 
2e6e c2 ac 2f				jp nz, .lunotfound 
2e71			 
2e71				if DEBUG_FORTH_WORDS 
2e71					DMARK "LSu" 
2e71 f5				push af  
2e72 3a 86 2e			ld a, (.dmark)  
2e75 32 a0 fd			ld (debug_mark),a  
2e78 3a 87 2e			ld a, (.dmark+1)  
2e7b 32 a1 fd			ld (debug_mark+1),a  
2e7e 3a 88 2e			ld a, (.dmark+2)  
2e81 32 a2 fd			ld (debug_mark+2),a  
2e84 18 03			jr .pastdmark  
2e86 ..			.dmark: db "LSu"  
2e89 f1			.pastdmark: pop af  
2e8a			endm  
# End of macro DMARK
2e8a					CALLMONITOR 
2e8a cd aa fd			call debug_vector  
2e8d				endm  
# End of macro CALLMONITOR
2e8d				endif 
2e8d			 
2e8d					; found a uword but is it the one we want... 
2e8d			 
2e8d c5					push bc     ; uword to find is on bc 
2e8e d1					pop de 
2e8f			 
2e8f e5					push hl  ; to save the ptr 
2e90			 
2e90					; skip opcode 
2e90 23					inc hl  
2e91					; skip next ptr 
2e91 23					inc hl  
2e92 23					inc hl 
2e93					; skip len 
2e93 23					inc hl 
2e94			 
2e94				if DEBUG_FORTH_WORDS 
2e94					DMARK "LSc" 
2e94 f5				push af  
2e95 3a a9 2e			ld a, (.dmark)  
2e98 32 a0 fd			ld (debug_mark),a  
2e9b 3a aa 2e			ld a, (.dmark+1)  
2e9e 32 a1 fd			ld (debug_mark+1),a  
2ea1 3a ab 2e			ld a, (.dmark+2)  
2ea4 32 a2 fd			ld (debug_mark+2),a  
2ea7 18 03			jr .pastdmark  
2ea9 ..			.dmark: db "LSc"  
2eac f1			.pastdmark: pop af  
2ead			endm  
# End of macro DMARK
2ead					CALLMONITOR 
2ead cd aa fd			call debug_vector  
2eb0				endm  
# End of macro CALLMONITOR
2eb0				endif 
2eb0			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2eb0			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2eb0			; Nope that has gone the other way. It needs to be exact not on first zero 
2eb0			;		call strcmp 
2eb0 c5					push bc 
2eb1 cd 89 13				call StrictStrCmp 
2eb4 c1					pop bc 
2eb5 c2 2f 2e				jp nz, .ldouscanm 
2eb8				 
2eb8			 
2eb8			 
2eb8					; we have a uword so push its name to the stack 
2eb8			 
2eb8			;	   	push hl  ; save so we can move to next dict block 
2eb8 e1			pop hl 
2eb9			 
2eb9				if DEBUG_FORTH_WORDS 
2eb9					DMARK "LSm" 
2eb9 f5				push af  
2eba 3a ce 2e			ld a, (.dmark)  
2ebd 32 a0 fd			ld (debug_mark),a  
2ec0 3a cf 2e			ld a, (.dmark+1)  
2ec3 32 a1 fd			ld (debug_mark+1),a  
2ec6 3a d0 2e			ld a, (.dmark+2)  
2ec9 32 a2 fd			ld (debug_mark+2),a  
2ecc 18 03			jr .pastdmark  
2ece ..			.dmark: db "LSm"  
2ed1 f1			.pastdmark: pop af  
2ed2			endm  
# End of macro DMARK
2ed2					CALLMONITOR 
2ed2 cd aa fd			call debug_vector  
2ed5				endm  
# End of macro CALLMONITOR
2ed5				endif 
2ed5			 
2ed5					; skip opcode 
2ed5 23					inc hl  
2ed6					; skip next ptr 
2ed6 23					inc hl  
2ed7 23					inc hl 
2ed8					; skip len 
2ed8 7e					ld a, (hl)   ; save length to add 
2ed9				if DEBUG_FORTH_WORDS 
2ed9					DMARK "LS2" 
2ed9 f5				push af  
2eda 3a ee 2e			ld a, (.dmark)  
2edd 32 a0 fd			ld (debug_mark),a  
2ee0 3a ef 2e			ld a, (.dmark+1)  
2ee3 32 a1 fd			ld (debug_mark+1),a  
2ee6 3a f0 2e			ld a, (.dmark+2)  
2ee9 32 a2 fd			ld (debug_mark+2),a  
2eec 18 03			jr .pastdmark  
2eee ..			.dmark: db "LS2"  
2ef1 f1			.pastdmark: pop af  
2ef2			endm  
# End of macro DMARK
2ef2					CALLMONITOR 
2ef2 cd aa fd			call debug_vector  
2ef5				endm  
# End of macro CALLMONITOR
2ef5				endif 
2ef5			 
2ef5					; save this location 
2ef5				 
2ef5 e5					push hl 
2ef6			 
2ef6 23					inc hl 
2ef7 11 f8 f0				ld de, scratch+2 
2efa 4f					ld c, a 
2efb 06 00				ld b, 0 
2efd			 
2efd				if DEBUG_FORTH_WORDS 
2efd					DMARK "LSn" 
2efd f5				push af  
2efe 3a 12 2f			ld a, (.dmark)  
2f01 32 a0 fd			ld (debug_mark),a  
2f04 3a 13 2f			ld a, (.dmark+1)  
2f07 32 a1 fd			ld (debug_mark+1),a  
2f0a 3a 14 2f			ld a, (.dmark+2)  
2f0d 32 a2 fd			ld (debug_mark+2),a  
2f10 18 03			jr .pastdmark  
2f12 ..			.dmark: db "LSn"  
2f15 f1			.pastdmark: pop af  
2f16			endm  
# End of macro DMARK
2f16					CALLMONITOR 
2f16 cd aa fd			call debug_vector  
2f19				endm  
# End of macro CALLMONITOR
2f19				endif 
2f19			 
2f19					; copy uword name to scratch 
2f19			 
2f19			;		ldir 
2f19			.licplw:	; copy uword name to scratch converting to lower case as we go 
2f19 ed a0				ldi 
2f1b 1b					dec de 
2f1c 1a					ld a, (de) 
2f1d cd 5c 12				call to_lower 
2f20 12					ld (de),a 
2f21 13					inc de 
2f22 3e 00				ld a, 0 
2f24 b9					cp c 
2f25 20 f2				jr nz, .licplw 
2f27			 
2f27			 
2f27			 
2f27 1b					dec de 
2f28 3e 20				ld a, ' '    ; change null to space 
2f2a 12					ld (de), a 
2f2b			 
2f2b 13					inc de 
2f2c			 
2f2c d5					push de 
2f2d c1					pop bc     ; move scratch pointer to end of word name and save it 
2f2e			 
2f2e e1					pop hl 
2f2f 7e					ld a, (hl) 
2f30					;inc hl 
2f30					; skip word string 
2f30 cd de 0f				call addatohl 
2f33			 
2f33 23					inc hl 
2f34			 
2f34				if DEBUG_FORTH_WORDS 
2f34					DMARK "LS3" 
2f34 f5				push af  
2f35 3a 49 2f			ld a, (.dmark)  
2f38 32 a0 fd			ld (debug_mark),a  
2f3b 3a 4a 2f			ld a, (.dmark+1)  
2f3e 32 a1 fd			ld (debug_mark+1),a  
2f41 3a 4b 2f			ld a, (.dmark+2)  
2f44 32 a2 fd			ld (debug_mark+2),a  
2f47 18 03			jr .pastdmark  
2f49 ..			.dmark: db "LS3"  
2f4c f1			.pastdmark: pop af  
2f4d			endm  
# End of macro DMARK
2f4d					CALLMONITOR 
2f4d cd aa fd			call debug_vector  
2f50				endm  
# End of macro CALLMONITOR
2f50				endif 
2f50					; should now be at the start of the machine code to setup the eval of the uword 
2f50					; now locate the ptr to the string defintion 
2f50			 
2f50					; skip ld hl, 
2f50					; then load the ptr 
2f50			; TODO use get from hl ptr 
2f50 23					inc hl 
2f51 5e					ld e, (hl) 
2f52 23					inc hl 
2f53 56					ld d, (hl) 
2f54 eb					ex de, hl 
2f55			 
2f55			 
2f55				if DEBUG_FORTH_WORDS 
2f55					DMARK "LSt" 
2f55 f5				push af  
2f56 3a 6a 2f			ld a, (.dmark)  
2f59 32 a0 fd			ld (debug_mark),a  
2f5c 3a 6b 2f			ld a, (.dmark+1)  
2f5f 32 a1 fd			ld (debug_mark+1),a  
2f62 3a 6c 2f			ld a, (.dmark+2)  
2f65 32 a2 fd			ld (debug_mark+2),a  
2f68 18 03			jr .pastdmark  
2f6a ..			.dmark: db "LSt"  
2f6d f1			.pastdmark: pop af  
2f6e			endm  
# End of macro DMARK
2f6e					CALLMONITOR 
2f6e cd aa fd			call debug_vector  
2f71				endm  
# End of macro CALLMONITOR
2f71				endif 
2f71			 
2f71			; cant push right now due to tokenised strings  
2f71			 
2f71			; get the destination of where to copy this definition to. 
2f71			 
2f71 c5					push bc 
2f72 d1					pop de 
2f73			 
2f73 7e			.listl:         ld a,(hl) 
2f74 fe 00				cp 0 
2f76 28 09				jr z, .lreplsp     ; replace zero with space 
2f78					;cp FORTH_END_BUFFER 
2f78 fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
2f7a 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
2f7c				 
2f7c					; just copy this char as is then 
2f7c			 
2f7c 12					ld (de), a 
2f7d			 
2f7d 23			.listnxt:	inc hl 
2f7e 13					inc de 
2f7f 18 f2				jr .listl 
2f81			 
2f81 3e 20		.lreplsp:	ld a,' ' 
2f83 12					ld (de), a 
2f84 18 f7				jr .listnxt 
2f86			 
2f86			; close up uword def 
2f86			 
2f86			.listdone: 
2f86 12					ld (de), a 
2f87 13					inc de 
2f88 3e 00				ld a, 0 
2f8a 12					ld (de), a 
2f8b			 
2f8b			; now have def so clean up and push to stack 
2f8b			 
2f8b 21 f6 f0				ld hl, scratch 
2f8e				if DEBUG_FORTH_WORDS 
2f8e					DMARK "Ltp" 
2f8e f5				push af  
2f8f 3a a3 2f			ld a, (.dmark)  
2f92 32 a0 fd			ld (debug_mark),a  
2f95 3a a4 2f			ld a, (.dmark+1)  
2f98 32 a1 fd			ld (debug_mark+1),a  
2f9b 3a a5 2f			ld a, (.dmark+2)  
2f9e 32 a2 fd			ld (debug_mark+2),a  
2fa1 18 03			jr .pastdmark  
2fa3 ..			.dmark: db "Ltp"  
2fa6 f1			.pastdmark: pop af  
2fa7			endm  
# End of macro DMARK
2fa7					CALLMONITOR 
2fa7 cd aa fd			call debug_vector  
2faa				endm  
# End of macro CALLMONITOR
2faa				endif 
2faa			 
2faa 18 1f			jr .listpush 
2fac			 
2fac			;.lnuword:	pop hl 
2fac			;		call forth_tok_next 
2fac			;		jp .ldouscan  
2fac			 
2fac			.lunotfound:		  
2fac			 
2fac				if DEBUG_FORTH_WORDS 
2fac					DMARK "LSn" 
2fac f5				push af  
2fad 3a c1 2f			ld a, (.dmark)  
2fb0 32 a0 fd			ld (debug_mark),a  
2fb3 3a c2 2f			ld a, (.dmark+1)  
2fb6 32 a1 fd			ld (debug_mark+1),a  
2fb9 3a c3 2f			ld a, (.dmark+2)  
2fbc 32 a2 fd			ld (debug_mark+2),a  
2fbf 18 03			jr .pastdmark  
2fc1 ..			.dmark: db "LSn"  
2fc4 f1			.pastdmark: pop af  
2fc5			endm  
# End of macro DMARK
2fc5					CALLMONITOR 
2fc5 cd aa fd			call debug_vector  
2fc8				endm  
# End of macro CALLMONITOR
2fc8				endif 
2fc8			 
2fc8					 
2fc8			;		FORTH_DSP_POP 
2fc8			;		ld hl, .luno 
2fc8			 
2fc8					NEXTW			 
2fc8 c3 39 24			jp macro_next 
2fcb				endm 
# End of macro NEXTW
2fcb			 
2fcb			.listpush: 
2fcb				if DEBUG_FORTH_WORDS 
2fcb					DMARK "LS>" 
2fcb f5				push af  
2fcc 3a e0 2f			ld a, (.dmark)  
2fcf 32 a0 fd			ld (debug_mark),a  
2fd2 3a e1 2f			ld a, (.dmark+1)  
2fd5 32 a1 fd			ld (debug_mark+1),a  
2fd8 3a e2 2f			ld a, (.dmark+2)  
2fdb 32 a2 fd			ld (debug_mark+2),a  
2fde 18 03			jr .pastdmark  
2fe0 ..			.dmark: db "LS>"  
2fe3 f1			.pastdmark: pop af  
2fe4			endm  
# End of macro DMARK
2fe4					CALLMONITOR 
2fe4 cd aa fd			call debug_vector  
2fe7				endm  
# End of macro CALLMONITOR
2fe7				endif 
2fe7 cd b6 20				call forth_push_str 
2fea			 
2fea			 
2fea			 
2fea					NEXTW 
2fea c3 39 24			jp macro_next 
2fed				endm 
# End of macro NEXTW
2fed			 
2fed			;.luno:    db "Word not found",0 
2fed			 
2fed			 
2fed			 
2fed			 
2fed			 
2fed			;		push hl   ; save pointer to start of uword def string 
2fed			; 
2fed			;; look for FORTH_EOL_LINE 
2fed			;		ld a, FORTH_END_BUFFER 
2fed			;		call strlent 
2fed			; 
2fed			;		inc hl		 ; space for coln def 
2fed			;		inc hl 
2fed			;		inc hl          ; space for terms 
2fed			;		inc hl 
2fed			; 
2fed			;		ld a, 20   ; TODO get actual length 
2fed			;		call addatohl    ; include a random amount of room for the uword name 
2fed			; 
2fed			;		 
2fed			;	if DEBUG_FORTH_WORDS 
2fed			;		DMARK "Lt1" 
2fed			;		CALLMONITOR 
2fed			;	endif 
2fed			;		 
2fed			; 
2fed			;; malloc space for the string because we cant change it 
2fed			; 
2fed			;		call malloc 
2fed			;	if DEBUG_FORTH_MALLOC_GUARD 
2fed			;		push af 
2fed			;		call ishlzero 
2fed			;		pop af 
2fed			;		 
2fed			;		call z,malloc_error 
2fed			;	endif 
2fed			; 
2fed			;	if DEBUG_FORTH_WORDS 
2fed			;		DMARK "Lt2" 
2fed			;		CALLMONITOR 
2fed			;	endif 
2fed			;		pop de 
2fed			;		push hl    ; push the malloc to release later 
2fed			;		push hl   ;  push back a copy for the later stack push 
2fed			;		 
2fed			;; copy the string swapping out the zero terms for spaces 
2fed			; 
2fed			;		; de has our source 
2fed			;		; hl has our dest 
2fed			; 
2fed			;; add the coln def 
2fed			; 
2fed			;		ld a, ':' 
2fed			;		ld (hl), a 
2fed			;		inc hl 
2fed			;		ld a, ' ' 
2fed			;		ld (hl), a 
2fed			;		inc hl 
2fed			; 
2fed			;; add the uname word 
2fed			;		push de   ; save our string for now 
2fed			;		ex de, hl 
2fed			; 
2fed			;		FORTH_DSP_VALUE 
2fed			;		;v5 FORTH_DSP_VALUE 
2fed			; 
2fed			;		inc hl   ; skip type but we know by now this is OK 
2fed			; 
2fed			;.luword:	ld a,(hl) 
2fed			;		cp 0 
2fed			;		jr z, .luword2 
2fed			;		ld (de), a 
2fed			;		inc de 
2fed			;		inc hl 
2fed			;		jr .luword 
2fed			; 
2fed			;.luword2:	ld a, ' ' 
2fed			;		ld (de), a 
2fed			;;		inc hl 
2fed			;;		inc de 
2fed			;;		ld (de), a 
2fed			;;		inc hl 
2fed			;		inc de 
2fed			; 
2fed			;		ex de, hl 
2fed			;		pop de 
2fed			;		 
2fed			;		 
2fed			; 
2fed			;; detoken that string and copy it 
2fed			; 
2fed			;	if DEBUG_FORTH_WORDS 
2fed			;		DMARK "Lt2" 
2fed			;		CALLMONITOR 
2fed			;	endif 
2fed			;.ldetok:	ld a, (de) 
2fed			;		cp FORTH_END_BUFFER 
2fed			;		jr z, .ldetokend 
2fed			;		; swap out any zero term for space 
2fed			;		cp 0 
2fed			;		jr nz, .ldetoknext 
2fed			;		ld a, ' ' 
2fed			; 
2fed			;	if DEBUG_FORTH_WORDS 
2fed			;		DMARK "LtS" 
2fed			;		CALLMONITOR 
2fed			;	endif 
2fed			;.ldetoknext:	ld (hl), a 
2fed			;		inc de 
2fed			;		inc hl 
2fed			;		jr .ldetok 
2fed			; 
2fed			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2fed			;		ld (hl), a  
2fed			; 
2fed			;; free that temp malloc 
2fed			; 
2fed			;		pop hl    
2fed			; 
2fed			;	if DEBUG_FORTH_WORDS 
2fed			;		DMARK "Lt4" 
2fed			;		CALLMONITOR 
2fed			;	endif 
2fed			;		call forth_apushstrhl 
2fed			; 
2fed			;		; get rid of temp malloc area 
2fed			; 
2fed			;		pop hl 
2fed			;		call free 
2fed			; 
2fed			;		jr .ludone 
2fed			; 
2fed			;.lnuword:	pop hl 
2fed			;		call forth_tok_next 
2fed			;		jp .ldouscan  
2fed			; 
2fed			;.ludone:		 pop hl 
2fed			; 
2fed					NEXTW 
2fed c3 39 24			jp macro_next 
2ff0				endm 
# End of macro NEXTW
2ff0			 
2ff0			.FORGET: 
2ff0				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2ff0 5d				db WORD_SYS_CORE+73             
2ff1 69 30			dw .NOP            
2ff3 07				db 6 + 1 
2ff4 .. 00			db "FORGET",0              
2ffb				endm 
# End of macro CWHEAD
2ffb			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2ffb			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
2ffb			; | |  
2ffb			; | | e.g. "MORE" forget 
2ffb					if DEBUG_FORTH_WORDS_KEY 
2ffb						DMARK "FRG" 
2ffb f5				push af  
2ffc 3a 10 30			ld a, (.dmark)  
2fff 32 a0 fd			ld (debug_mark),a  
3002 3a 11 30			ld a, (.dmark+1)  
3005 32 a1 fd			ld (debug_mark+1),a  
3008 3a 12 30			ld a, (.dmark+2)  
300b 32 a2 fd			ld (debug_mark+2),a  
300e 18 03			jr .pastdmark  
3010 ..			.dmark: db "FRG"  
3013 f1			.pastdmark: pop af  
3014			endm  
# End of macro DMARK
3014						CALLMONITOR 
3014 cd aa fd			call debug_vector  
3017				endm  
# End of macro CALLMONITOR
3017					endif 
3017			 
3017				; find uword 
3017			        ; update start of word with "_" 
3017				; replace uword with deleted flag 
3017			 
3017			 
3017			;	if DEBUG_FORTH_WORDS 
3017			;		DMARK "FOG" 
3017			;		CALLMONITOR 
3017			;	endif 
3017			 
3017			 
3017					; Get ptr to the word we need to look up 
3017			 
3017					FORTH_DSP_VALUEHL 
3017 cd 4d 22			call macro_dsp_valuehl 
301a				endm 
# End of macro FORTH_DSP_VALUEHL
301a					;v5 FORTH_DSP_VALUE 
301a				; TODO type check 
301a			;		inc hl    ; Skip type check  
301a e5					push hl 
301b c1					pop bc 
301c			;		ex de, hl    ; put into DE 
301c			 
301c			 
301c 21 00 80				ld hl, baseram 
301f					;ld hl, baseusermem 
301f			 
301f				; skip dict stub 
301f			;	call forth_tok_next 
301f e5			push hl   ; sacreifical push 
3020			 
3020			.fldouscanm: 
3020 e1				pop hl 
3021			.fldouscan: 
3021			;	if DEBUG_FORTH_WORDS 
3021			;		DMARK "LSs" 
3021			;		CALLMONITOR 
3021			;	endif 
3021				; skip dict stub 
3021 cd 8a 25				call forth_tok_next 
3024			 
3024			 
3024			; while we have words to look for 
3024			 
3024 7e				ld a, (hl)      
3025			;	if DEBUG_FORTH_WORDS 
3025			;		DMARK "LSk" 
3025			;		CALLMONITOR 
3025			;	endif 
3025 fe 00				cp WORD_SYS_END 
3027 ca 63 30				jp z, .flunotfound 
302a fe 01				cp WORD_SYS_UWORD 
302c c2 21 30				jp nz, .fldouscan 
302f			 
302f			;	if DEBUG_FORTH_WORDS 
302f			;		DMARK "LSu" 
302f			;		CALLMONITOR 
302f			;	endif 
302f			 
302f					; found a uword but is it the one we want... 
302f			 
302f c5					push bc     ; uword to find is on bc 
3030 d1					pop de 
3031			 
3031 e5					push hl  ; to save the ptr 
3032			 
3032					; skip opcode 
3032 23					inc hl  
3033					; skip next ptr 
3033 23					inc hl  
3034 23					inc hl 
3035					; skip len 
3035 23					inc hl 
3036			 
3036			;	if DEBUG_FORTH_WORDS 
3036			;		DMARK "LSc" 
3036			;		CALLMONITOR 
3036			;	endif 
3036 cd 7c 13				call strcmp 
3039 c2 20 30				jp nz, .fldouscanm 
303c			; 
303c			; 
303c			;; while we have words to look for 
303c			; 
303c			;.fdouscan:	ld a, (hl)      
303c			;	if DEBUG_FORTH_WORDS 
303c			;		DMARK "LSs" 
303c			;		CALLMONITOR 
303c			;	endif 
303c			;		cp WORD_SYS_END 
303c			;		jp z, .fudone 
303c			;		cp WORD_SYS_UWORD 
303c			;		jp nz, .fnuword 
303c			; 
303c			;	if DEBUG_FORTH_WORDS 
303c			;		DMARK "FGu" 
303c			;		CALLMONITOR 
303c			;	endif 
303c			; 
303c			;		; found a uword but is it the one we want... 
303c			; 
303c			; 
303c			;	        pop de   ; get back the dsp name 
303c			;		push de 
303c			; 
303c			;		push hl  ; to save the ptr 
303c			; 
303c			;		; skip opcode 
303c			;		inc hl  
303c			;		; skip next ptr 
303c			;		inc hl  
303c			;		inc hl 
303c			;		; skip len 
303c			;		inc hl 
303c			; 
303c			;	if DEBUG_FORTH_WORDS 
303c			;		DMARK "FGc" 
303c			;		CALLMONITOR 
303c			;	endif 
303c			;		call strcmp 
303c			;		jp nz, .fnuword 
303c			 
303c			 
303c e1			pop hl 
303d			 
303d				 
303d				if DEBUG_FORTH_WORDS 
303d					DMARK "FGm" 
303d f5				push af  
303e 3a 52 30			ld a, (.dmark)  
3041 32 a0 fd			ld (debug_mark),a  
3044 3a 53 30			ld a, (.dmark+1)  
3047 32 a1 fd			ld (debug_mark+1),a  
304a 3a 54 30			ld a, (.dmark+2)  
304d 32 a2 fd			ld (debug_mark+2),a  
3050 18 03			jr .pastdmark  
3052 ..			.dmark: db "FGm"  
3055 f1			.pastdmark: pop af  
3056			endm  
# End of macro DMARK
3056					CALLMONITOR 
3056 cd aa fd			call debug_vector  
3059				endm  
# End of macro CALLMONITOR
3059				endif 
3059			 
3059			 
3059			 
3059					; we have a uword so push its name to the stack 
3059			 
3059			;	   	push hl  ; save so we can move to next dict block 
3059			;pop hl 
3059			 
3059					; update opcode to deleted 
3059 3e 03				ld a, WORD_SYS_DELETED 
305b 77					ld (hl), a 
305c			 
305c 23					inc hl  
305d					; skip next ptr 
305d 23					inc hl  
305e 23					inc hl 
305f					; skip len 
305f 23					inc hl 
3060			 
3060					; TODO change parser to skip deleted words but for now mark it out 
3060 3e 5f				ld a, "_" 
3062 77					ld  (hl),a 
3063			 
3063			;		jr .fudone 
3063			; 
3063			;.fnuword:	pop hl 
3063			;		call forth_tok_next 
3063			;		jp .fdouscan  
3063			 
3063			.flunotfound:		  
3063			 
3063			 
3063					 
3063					FORTH_DSP_POP 
3063 cd 05 23			call macro_forth_dsp_pop 
3066				endm 
# End of macro FORTH_DSP_POP
3066			;		ld hl, .luno 
3066			;.fudone:		 pop hl 
3066					NEXTW 
3066 c3 39 24			jp macro_next 
3069				endm 
# End of macro NEXTW
3069			.NOP: 
3069				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
3069 61				db WORD_SYS_CORE+77             
306a 90 30			dw .COMO            
306c 04				db 3 + 1 
306d .. 00			db "NOP",0              
3071				endm 
# End of macro CWHEAD
3071			; | NOP (  --  ) Do nothing | DONE 
3071					if DEBUG_FORTH_WORDS_KEY 
3071						DMARK "NOP" 
3071 f5				push af  
3072 3a 86 30			ld a, (.dmark)  
3075 32 a0 fd			ld (debug_mark),a  
3078 3a 87 30			ld a, (.dmark+1)  
307b 32 a1 fd			ld (debug_mark+1),a  
307e 3a 88 30			ld a, (.dmark+2)  
3081 32 a2 fd			ld (debug_mark+2),a  
3084 18 03			jr .pastdmark  
3086 ..			.dmark: db "NOP"  
3089 f1			.pastdmark: pop af  
308a			endm  
# End of macro DMARK
308a						CALLMONITOR 
308a cd aa fd			call debug_vector  
308d				endm  
# End of macro CALLMONITOR
308d					endif 
308d				       NEXTW 
308d c3 39 24			jp macro_next 
3090				endm 
# End of macro NEXTW
3090			.COMO: 
3090				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
3090 6e				db WORD_SYS_CORE+90             
3091 e2 30			dw .COMC            
3093 02				db 1 + 1 
3094 .. 00			db "(",0              
3096				endm 
# End of macro CWHEAD
3096			; | ( ( -- )  Start of comment | DONE 
3096			 
3096			 
3096 2a f7 f3				ld hl, ( os_tok_ptr) 
3099 11 dd 30			ld de, .closepar 
309c					 
309c					if DEBUG_FORTH_WORDS 
309c						DMARK ").." 
309c f5				push af  
309d 3a b1 30			ld a, (.dmark)  
30a0 32 a0 fd			ld (debug_mark),a  
30a3 3a b2 30			ld a, (.dmark+1)  
30a6 32 a1 fd			ld (debug_mark+1),a  
30a9 3a b3 30			ld a, (.dmark+2)  
30ac 32 a2 fd			ld (debug_mark+2),a  
30af 18 03			jr .pastdmark  
30b1 ..			.dmark: db ").."  
30b4 f1			.pastdmark: pop af  
30b5			endm  
# End of macro DMARK
30b5						CALLMONITOR 
30b5 cd aa fd			call debug_vector  
30b8				endm  
# End of macro CALLMONITOR
30b8					endif 
30b8 cd 54 25			call findnexttok  
30bb			 
30bb					if DEBUG_FORTH_WORDS 
30bb						DMARK "IF5" 
30bb f5				push af  
30bc 3a d0 30			ld a, (.dmark)  
30bf 32 a0 fd			ld (debug_mark),a  
30c2 3a d1 30			ld a, (.dmark+1)  
30c5 32 a1 fd			ld (debug_mark+1),a  
30c8 3a d2 30			ld a, (.dmark+2)  
30cb 32 a2 fd			ld (debug_mark+2),a  
30ce 18 03			jr .pastdmark  
30d0 ..			.dmark: db "IF5"  
30d3 f1			.pastdmark: pop af  
30d4			endm  
# End of macro DMARK
30d4						CALLMONITOR 
30d4 cd aa fd			call debug_vector  
30d7				endm  
# End of macro CALLMONITOR
30d7					endif 
30d7				; replace below with ) exec using tok_ptr 
30d7 22 f7 f3			ld (os_tok_ptr), hl 
30da c3 ca 24			jp exec1 
30dd			 
30dd .. 00			.closepar:   db ")",0 
30df			 
30df				       NEXTW 
30df c3 39 24			jp macro_next 
30e2				endm 
# End of macro NEXTW
30e2			.COMC: 
30e2				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
30e2 6f				db WORD_SYS_CORE+91             
30e3 eb 30			dw .SCRATCH            
30e5 02				db 1 + 1 
30e6 .. 00			db ")",0              
30e8				endm 
# End of macro CWHEAD
30e8			; | ) ( -- )  End of comment |  DONE  
30e8				       NEXTW 
30e8 c3 39 24			jp macro_next 
30eb				endm 
# End of macro NEXTW
30eb			 
30eb			.SCRATCH: 
30eb				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
30eb 6f				db WORD_SYS_CORE+91             
30ec 26 31			dw .INC            
30ee 08				db 7 + 1 
30ef .. 00			db "SCRATCH",0              
30f7				endm 
# End of macro CWHEAD
30f7			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
30f7			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
30f7			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
30f7			; | |  
30f7			; | | e.g.    : score $00 scratch ; 
30f7			; | |  
30f7			; | | $00 score ! 
30f7			; | | $01 score +! 
30f7			; | |  
30f7			; | | e.g.   : varword $0a scratch ;  
30f7			; | | 
30f7			; | | $8000 varword ! 
30f7					if DEBUG_FORTH_WORDS_KEY 
30f7						DMARK "SCR" 
30f7 f5				push af  
30f8 3a 0c 31			ld a, (.dmark)  
30fb 32 a0 fd			ld (debug_mark),a  
30fe 3a 0d 31			ld a, (.dmark+1)  
3101 32 a1 fd			ld (debug_mark+1),a  
3104 3a 0e 31			ld a, (.dmark+2)  
3107 32 a2 fd			ld (debug_mark+2),a  
310a 18 03			jr .pastdmark  
310c ..			.dmark: db "SCR"  
310f f1			.pastdmark: pop af  
3110			endm  
# End of macro DMARK
3110						CALLMONITOR 
3110 cd aa fd			call debug_vector  
3113				endm  
# End of macro CALLMONITOR
3113					endif 
3113			 
3113					FORTH_DSP_VALUEHL 
3113 cd 4d 22			call macro_dsp_valuehl 
3116				endm 
# End of macro FORTH_DSP_VALUEHL
3116				 
3116					FORTH_DSP_POP 
3116 cd 05 23			call macro_forth_dsp_pop 
3119				endm 
# End of macro FORTH_DSP_POP
3119			 
3119 7d					ld a, l 
311a 21 1b f6				ld hl, os_var_array 
311d cd de 0f				call addatohl 
3120			 
3120 cd 48 20				call forth_push_numhl 
3123			 
3123				       NEXTW 
3123 c3 39 24			jp macro_next 
3126				endm 
# End of macro NEXTW
3126			 
3126			.INC: 
3126				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
3126 6f				db WORD_SYS_CORE+91             
3127 7c 31			dw .DEC            
3129 03				db 2 + 1 
312a .. 00			db "+!",0              
312d				endm 
# End of macro CWHEAD
312d			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
312d					if DEBUG_FORTH_WORDS_KEY 
312d						DMARK "+s_" 
312d f5				push af  
312e 3a 42 31			ld a, (.dmark)  
3131 32 a0 fd			ld (debug_mark),a  
3134 3a 43 31			ld a, (.dmark+1)  
3137 32 a1 fd			ld (debug_mark+1),a  
313a 3a 44 31			ld a, (.dmark+2)  
313d 32 a2 fd			ld (debug_mark+2),a  
3140 18 03			jr .pastdmark  
3142 ..			.dmark: db "+s_"  
3145 f1			.pastdmark: pop af  
3146			endm  
# End of macro DMARK
3146						CALLMONITOR 
3146 cd aa fd			call debug_vector  
3149				endm  
# End of macro CALLMONITOR
3149					endif 
3149			 
3149					FORTH_DSP_VALUEHL 
3149 cd 4d 22			call macro_dsp_valuehl 
314c				endm 
# End of macro FORTH_DSP_VALUEHL
314c			 
314c e5					push hl   ; save address 
314d			 
314d					FORTH_DSP_POP 
314d cd 05 23			call macro_forth_dsp_pop 
3150				endm 
# End of macro FORTH_DSP_POP
3150			 
3150					FORTH_DSP_VALUEHL 
3150 cd 4d 22			call macro_dsp_valuehl 
3153				endm 
# End of macro FORTH_DSP_VALUEHL
3153			 
3153 e5					push hl 
3154					FORTH_DSP_POP 
3154 cd 05 23			call macro_forth_dsp_pop 
3157				endm 
# End of macro FORTH_DSP_POP
3157 e1					pop hl 
3158			 
3158					; hl contains value to add to byte at a 
3158				 
3158 eb					ex de, hl 
3159			 
3159 e1					pop hl 
315a			 
315a					if DEBUG_FORTH_WORDS 
315a						DMARK "INC" 
315a f5				push af  
315b 3a 6f 31			ld a, (.dmark)  
315e 32 a0 fd			ld (debug_mark),a  
3161 3a 70 31			ld a, (.dmark+1)  
3164 32 a1 fd			ld (debug_mark+1),a  
3167 3a 71 31			ld a, (.dmark+2)  
316a 32 a2 fd			ld (debug_mark+2),a  
316d 18 03			jr .pastdmark  
316f ..			.dmark: db "INC"  
3172 f1			.pastdmark: pop af  
3173			endm  
# End of macro DMARK
3173						CALLMONITOR 
3173 cd aa fd			call debug_vector  
3176				endm  
# End of macro CALLMONITOR
3176					endif 
3176			 
3176 7e					ld a,(hl) 
3177 83					add e 
3178 77					ld (hl),a 
3179			 
3179			 
3179			 
3179				       NEXTW 
3179 c3 39 24			jp macro_next 
317c				endm 
# End of macro NEXTW
317c			 
317c			.DEC: 
317c				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
317c 6f				db WORD_SYS_CORE+91             
317d d0 31			dw .INC2            
317f 03				db 2 + 1 
3180 .. 00			db "-!",0              
3183				endm 
# End of macro CWHEAD
3183			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
3183					if DEBUG_FORTH_WORDS_KEY 
3183						DMARK "-s_" 
3183 f5				push af  
3184 3a 98 31			ld a, (.dmark)  
3187 32 a0 fd			ld (debug_mark),a  
318a 3a 99 31			ld a, (.dmark+1)  
318d 32 a1 fd			ld (debug_mark+1),a  
3190 3a 9a 31			ld a, (.dmark+2)  
3193 32 a2 fd			ld (debug_mark+2),a  
3196 18 03			jr .pastdmark  
3198 ..			.dmark: db "-s_"  
319b f1			.pastdmark: pop af  
319c			endm  
# End of macro DMARK
319c						CALLMONITOR 
319c cd aa fd			call debug_vector  
319f				endm  
# End of macro CALLMONITOR
319f					endif 
319f			 
319f					FORTH_DSP_VALUEHL 
319f cd 4d 22			call macro_dsp_valuehl 
31a2				endm 
# End of macro FORTH_DSP_VALUEHL
31a2			 
31a2 e5					push hl   ; save address 
31a3			 
31a3					FORTH_DSP_POP 
31a3 cd 05 23			call macro_forth_dsp_pop 
31a6				endm 
# End of macro FORTH_DSP_POP
31a6			 
31a6					FORTH_DSP_VALUEHL 
31a6 cd 4d 22			call macro_dsp_valuehl 
31a9				endm 
# End of macro FORTH_DSP_VALUEHL
31a9			 
31a9					; hl contains value to add to byte at a 
31a9				 
31a9 eb					ex de, hl 
31aa			 
31aa e1					pop hl 
31ab			 
31ab					if DEBUG_FORTH_WORDS 
31ab						DMARK "DEC" 
31ab f5				push af  
31ac 3a c0 31			ld a, (.dmark)  
31af 32 a0 fd			ld (debug_mark),a  
31b2 3a c1 31			ld a, (.dmark+1)  
31b5 32 a1 fd			ld (debug_mark+1),a  
31b8 3a c2 31			ld a, (.dmark+2)  
31bb 32 a2 fd			ld (debug_mark+2),a  
31be 18 03			jr .pastdmark  
31c0 ..			.dmark: db "DEC"  
31c3 f1			.pastdmark: pop af  
31c4			endm  
# End of macro DMARK
31c4						CALLMONITOR 
31c4 cd aa fd			call debug_vector  
31c7				endm  
# End of macro CALLMONITOR
31c7					endif 
31c7			 
31c7 7e					ld a,(hl) 
31c8 93					sub e 
31c9 77					ld (hl),a 
31ca			 
31ca			 
31ca					FORTH_DSP_POP 
31ca cd 05 23			call macro_forth_dsp_pop 
31cd				endm 
# End of macro FORTH_DSP_POP
31cd			 
31cd				       NEXTW 
31cd c3 39 24			jp macro_next 
31d0				endm 
# End of macro NEXTW
31d0			 
31d0			.INC2: 
31d0				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
31d0 6f				db WORD_SYS_CORE+91             
31d1 7d 32			dw .DEC2            
31d3 04				db 3 + 1 
31d4 .. 00			db "+2!",0              
31d8				endm 
# End of macro CWHEAD
31d8			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
31d8			 
31d8					if DEBUG_FORTH_WORDS_KEY 
31d8						DMARK "+2s" 
31d8 f5				push af  
31d9 3a ed 31			ld a, (.dmark)  
31dc 32 a0 fd			ld (debug_mark),a  
31df 3a ee 31			ld a, (.dmark+1)  
31e2 32 a1 fd			ld (debug_mark+1),a  
31e5 3a ef 31			ld a, (.dmark+2)  
31e8 32 a2 fd			ld (debug_mark+2),a  
31eb 18 03			jr .pastdmark  
31ed ..			.dmark: db "+2s"  
31f0 f1			.pastdmark: pop af  
31f1			endm  
# End of macro DMARK
31f1						CALLMONITOR 
31f1 cd aa fd			call debug_vector  
31f4				endm  
# End of macro CALLMONITOR
31f4					endif 
31f4			 
31f4					; Address 
31f4			 
31f4					FORTH_DSP_VALUEHL 
31f4 cd 4d 22			call macro_dsp_valuehl 
31f7				endm 
# End of macro FORTH_DSP_VALUEHL
31f7			 
31f7 e5					push hl    ; save address 
31f8			 
31f8					; load content into de 
31f8			 
31f8 5e					ld e,(hl) 
31f9 23					inc hl 
31fa 56					ld d, (hl) 
31fb			 
31fb					if DEBUG_FORTH_WORDS 
31fb						DMARK "+2a" 
31fb f5				push af  
31fc 3a 10 32			ld a, (.dmark)  
31ff 32 a0 fd			ld (debug_mark),a  
3202 3a 11 32			ld a, (.dmark+1)  
3205 32 a1 fd			ld (debug_mark+1),a  
3208 3a 12 32			ld a, (.dmark+2)  
320b 32 a2 fd			ld (debug_mark+2),a  
320e 18 03			jr .pastdmark  
3210 ..			.dmark: db "+2a"  
3213 f1			.pastdmark: pop af  
3214			endm  
# End of macro DMARK
3214						CALLMONITOR 
3214 cd aa fd			call debug_vector  
3217				endm  
# End of macro CALLMONITOR
3217					endif 
3217			 
3217					FORTH_DSP_POP 
3217 cd 05 23			call macro_forth_dsp_pop 
321a				endm 
# End of macro FORTH_DSP_POP
321a			 
321a					; Get value to add 
321a			 
321a					FORTH_DSP_VALUE 
321a cd 36 22			call macro_forth_dsp_value 
321d				endm 
# End of macro FORTH_DSP_VALUE
321d			 
321d					if DEBUG_FORTH_WORDS 
321d						DMARK "+2v" 
321d f5				push af  
321e 3a 32 32			ld a, (.dmark)  
3221 32 a0 fd			ld (debug_mark),a  
3224 3a 33 32			ld a, (.dmark+1)  
3227 32 a1 fd			ld (debug_mark+1),a  
322a 3a 34 32			ld a, (.dmark+2)  
322d 32 a2 fd			ld (debug_mark+2),a  
3230 18 03			jr .pastdmark  
3232 ..			.dmark: db "+2v"  
3235 f1			.pastdmark: pop af  
3236			endm  
# End of macro DMARK
3236						CALLMONITOR 
3236 cd aa fd			call debug_vector  
3239				endm  
# End of macro CALLMONITOR
3239					endif 
3239			 
3239 19					add hl, de 
323a			 
323a					if DEBUG_FORTH_WORDS 
323a						DMARK "+2+" 
323a f5				push af  
323b 3a 4f 32			ld a, (.dmark)  
323e 32 a0 fd			ld (debug_mark),a  
3241 3a 50 32			ld a, (.dmark+1)  
3244 32 a1 fd			ld (debug_mark+1),a  
3247 3a 51 32			ld a, (.dmark+2)  
324a 32 a2 fd			ld (debug_mark+2),a  
324d 18 03			jr .pastdmark  
324f ..			.dmark: db "+2+"  
3252 f1			.pastdmark: pop af  
3253			endm  
# End of macro DMARK
3253						CALLMONITOR 
3253 cd aa fd			call debug_vector  
3256				endm  
# End of macro CALLMONITOR
3256					endif 
3256			 
3256					; move result to de 
3256			 
3256 eb					ex de, hl 
3257			 
3257					; Address 
3257			 
3257 e1					pop hl 
3258			 
3258					; save it back 
3258			 
3258 73					ld (hl), e 
3259 23					inc hl 
325a 72					ld (hl), d 
325b			 
325b					if DEBUG_FORTH_WORDS 
325b						DMARK "+2e" 
325b f5				push af  
325c 3a 70 32			ld a, (.dmark)  
325f 32 a0 fd			ld (debug_mark),a  
3262 3a 71 32			ld a, (.dmark+1)  
3265 32 a1 fd			ld (debug_mark+1),a  
3268 3a 72 32			ld a, (.dmark+2)  
326b 32 a2 fd			ld (debug_mark+2),a  
326e 18 03			jr .pastdmark  
3270 ..			.dmark: db "+2e"  
3273 f1			.pastdmark: pop af  
3274			endm  
# End of macro DMARK
3274						CALLMONITOR 
3274 cd aa fd			call debug_vector  
3277				endm  
# End of macro CALLMONITOR
3277					endif 
3277			 
3277			 
3277			 
3277					FORTH_DSP_POP 
3277 cd 05 23			call macro_forth_dsp_pop 
327a				endm 
# End of macro FORTH_DSP_POP
327a			 
327a			 
327a				       NEXTW 
327a c3 39 24			jp macro_next 
327d				endm 
# End of macro NEXTW
327d			 
327d			.DEC2: 
327d				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
327d 6f				db WORD_SYS_CORE+91             
327e 2c 33			dw .GET2            
3280 04				db 3 + 1 
3281 .. 00			db "-2!",0              
3285				endm 
# End of macro CWHEAD
3285			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
3285			 
3285			 
3285					if DEBUG_FORTH_WORDS_KEY 
3285						DMARK "-2s" 
3285 f5				push af  
3286 3a 9a 32			ld a, (.dmark)  
3289 32 a0 fd			ld (debug_mark),a  
328c 3a 9b 32			ld a, (.dmark+1)  
328f 32 a1 fd			ld (debug_mark+1),a  
3292 3a 9c 32			ld a, (.dmark+2)  
3295 32 a2 fd			ld (debug_mark+2),a  
3298 18 03			jr .pastdmark  
329a ..			.dmark: db "-2s"  
329d f1			.pastdmark: pop af  
329e			endm  
# End of macro DMARK
329e						CALLMONITOR 
329e cd aa fd			call debug_vector  
32a1				endm  
# End of macro CALLMONITOR
32a1					endif 
32a1			 
32a1					; Address 
32a1			 
32a1					FORTH_DSP_VALUEHL 
32a1 cd 4d 22			call macro_dsp_valuehl 
32a4				endm 
# End of macro FORTH_DSP_VALUEHL
32a4			 
32a4 e5					push hl    ; save address 
32a5			 
32a5					; load content into de 
32a5			 
32a5 5e					ld e,(hl) 
32a6 23					inc hl 
32a7 56					ld d, (hl) 
32a8			 
32a8					if DEBUG_FORTH_WORDS 
32a8						DMARK "-2a" 
32a8 f5				push af  
32a9 3a bd 32			ld a, (.dmark)  
32ac 32 a0 fd			ld (debug_mark),a  
32af 3a be 32			ld a, (.dmark+1)  
32b2 32 a1 fd			ld (debug_mark+1),a  
32b5 3a bf 32			ld a, (.dmark+2)  
32b8 32 a2 fd			ld (debug_mark+2),a  
32bb 18 03			jr .pastdmark  
32bd ..			.dmark: db "-2a"  
32c0 f1			.pastdmark: pop af  
32c1			endm  
# End of macro DMARK
32c1						CALLMONITOR 
32c1 cd aa fd			call debug_vector  
32c4				endm  
# End of macro CALLMONITOR
32c4					endif 
32c4			 
32c4					FORTH_DSP_POP 
32c4 cd 05 23			call macro_forth_dsp_pop 
32c7				endm 
# End of macro FORTH_DSP_POP
32c7			 
32c7					; Get value to remove 
32c7			 
32c7					FORTH_DSP_VALUE 
32c7 cd 36 22			call macro_forth_dsp_value 
32ca				endm 
# End of macro FORTH_DSP_VALUE
32ca			 
32ca					if DEBUG_FORTH_WORDS 
32ca						DMARK "-2v" 
32ca f5				push af  
32cb 3a df 32			ld a, (.dmark)  
32ce 32 a0 fd			ld (debug_mark),a  
32d1 3a e0 32			ld a, (.dmark+1)  
32d4 32 a1 fd			ld (debug_mark+1),a  
32d7 3a e1 32			ld a, (.dmark+2)  
32da 32 a2 fd			ld (debug_mark+2),a  
32dd 18 03			jr .pastdmark  
32df ..			.dmark: db "-2v"  
32e2 f1			.pastdmark: pop af  
32e3			endm  
# End of macro DMARK
32e3						CALLMONITOR 
32e3 cd aa fd			call debug_vector  
32e6				endm  
# End of macro CALLMONITOR
32e6					endif 
32e6			 
32e6 eb					ex de, hl 
32e7 ed 52				sbc hl, de 
32e9			 
32e9					if DEBUG_FORTH_WORDS 
32e9						DMARK "-2d" 
32e9 f5				push af  
32ea 3a fe 32			ld a, (.dmark)  
32ed 32 a0 fd			ld (debug_mark),a  
32f0 3a ff 32			ld a, (.dmark+1)  
32f3 32 a1 fd			ld (debug_mark+1),a  
32f6 3a 00 33			ld a, (.dmark+2)  
32f9 32 a2 fd			ld (debug_mark+2),a  
32fc 18 03			jr .pastdmark  
32fe ..			.dmark: db "-2d"  
3301 f1			.pastdmark: pop af  
3302			endm  
# End of macro DMARK
3302						CALLMONITOR 
3302 cd aa fd			call debug_vector  
3305				endm  
# End of macro CALLMONITOR
3305					endif 
3305			 
3305					; move result to de 
3305			 
3305 eb					ex de, hl 
3306			 
3306					; Address 
3306			 
3306 e1					pop hl 
3307			 
3307					; save it back 
3307			 
3307 73					ld (hl), e 
3308 23					inc hl 
3309 72					ld (hl), d 
330a			 
330a					if DEBUG_FORTH_WORDS 
330a						DMARK "-2e" 
330a f5				push af  
330b 3a 1f 33			ld a, (.dmark)  
330e 32 a0 fd			ld (debug_mark),a  
3311 3a 20 33			ld a, (.dmark+1)  
3314 32 a1 fd			ld (debug_mark+1),a  
3317 3a 21 33			ld a, (.dmark+2)  
331a 32 a2 fd			ld (debug_mark+2),a  
331d 18 03			jr .pastdmark  
331f ..			.dmark: db "-2e"  
3322 f1			.pastdmark: pop af  
3323			endm  
# End of macro DMARK
3323						CALLMONITOR 
3323 cd aa fd			call debug_vector  
3326				endm  
# End of macro CALLMONITOR
3326					endif 
3326			 
3326			 
3326					FORTH_DSP_POP 
3326 cd 05 23			call macro_forth_dsp_pop 
3329				endm 
# End of macro FORTH_DSP_POP
3329			 
3329			 
3329			 
3329				       NEXTW 
3329 c3 39 24			jp macro_next 
332c				endm 
# End of macro NEXTW
332c			.GET2: 
332c				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
332c 6f				db WORD_SYS_CORE+91             
332d 61 33			dw .BANG2            
332f 03				db 2 + 1 
3330 .. 00			db "2@",0              
3333				endm 
# End of macro CWHEAD
3333			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
3333					if DEBUG_FORTH_WORDS_KEY 
3333						DMARK "2A_" 
3333 f5				push af  
3334 3a 48 33			ld a, (.dmark)  
3337 32 a0 fd			ld (debug_mark),a  
333a 3a 49 33			ld a, (.dmark+1)  
333d 32 a1 fd			ld (debug_mark+1),a  
3340 3a 4a 33			ld a, (.dmark+2)  
3343 32 a2 fd			ld (debug_mark+2),a  
3346 18 03			jr .pastdmark  
3348 ..			.dmark: db "2A_"  
334b f1			.pastdmark: pop af  
334c			endm  
# End of macro DMARK
334c						CALLMONITOR 
334c cd aa fd			call debug_vector  
334f				endm  
# End of macro CALLMONITOR
334f					endif 
334f			 
334f					FORTH_DSP_VALUEHL 
334f cd 4d 22			call macro_dsp_valuehl 
3352				endm 
# End of macro FORTH_DSP_VALUEHL
3352			 
3352 e5					push hl   ; save address 
3353			 
3353					FORTH_DSP_POP 
3353 cd 05 23			call macro_forth_dsp_pop 
3356				endm 
# End of macro FORTH_DSP_POP
3356			 
3356 e1					pop hl 
3357			 
3357 5e					ld e, (hl) 
3358 23					inc hl 
3359 56					ld d, (hl) 
335a			 
335a eb					ex de, hl 
335b			 
335b cd 48 20				call forth_push_numhl 
335e			 
335e				       NEXTW 
335e c3 39 24			jp macro_next 
3361				endm 
# End of macro NEXTW
3361			.BANG2: 
3361				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
3361 6f				db WORD_SYS_CORE+91             
3362 99 33			dw .CONFIG            
3364 03				db 2 + 1 
3365 .. 00			db "2!",0              
3368				endm 
# End of macro CWHEAD
3368			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
3368					if DEBUG_FORTH_WORDS_KEY 
3368						DMARK "2S_" 
3368 f5				push af  
3369 3a 7d 33			ld a, (.dmark)  
336c 32 a0 fd			ld (debug_mark),a  
336f 3a 7e 33			ld a, (.dmark+1)  
3372 32 a1 fd			ld (debug_mark+1),a  
3375 3a 7f 33			ld a, (.dmark+2)  
3378 32 a2 fd			ld (debug_mark+2),a  
337b 18 03			jr .pastdmark  
337d ..			.dmark: db "2S_"  
3380 f1			.pastdmark: pop af  
3381			endm  
# End of macro DMARK
3381						CALLMONITOR 
3381 cd aa fd			call debug_vector  
3384				endm  
# End of macro CALLMONITOR
3384					endif 
3384			 
3384					FORTH_DSP_VALUEHL 
3384 cd 4d 22			call macro_dsp_valuehl 
3387				endm 
# End of macro FORTH_DSP_VALUEHL
3387			 
3387 e5					push hl   ; save address 
3388			 
3388			 
3388					FORTH_DSP_POP 
3388 cd 05 23			call macro_forth_dsp_pop 
338b				endm 
# End of macro FORTH_DSP_POP
338b			 
338b					 
338b					FORTH_DSP_VALUEHL 
338b cd 4d 22			call macro_dsp_valuehl 
338e				endm 
# End of macro FORTH_DSP_VALUEHL
338e			 
338e					FORTH_DSP_POP 
338e cd 05 23			call macro_forth_dsp_pop 
3391				endm 
# End of macro FORTH_DSP_POP
3391			 
3391 eb					ex de, hl    ; value now in de 
3392			 
3392 e1					pop hl 
3393			 
3393 73					ld (hl), e 
3394			 
3394 23					inc hl 
3395			 
3395 72					ld (hl), d 
3396			 
3396			 
3396				       NEXTW 
3396 c3 39 24			jp macro_next 
3399				endm 
# End of macro NEXTW
3399			.CONFIG: 
3399				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
3399 6f				db WORD_SYS_CORE+91             
339a aa 33			dw .ADTOS            
339c 07				db 6 + 1 
339d .. 00			db "CONFIG",0              
33a4				endm 
# End of macro CWHEAD
33a4			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
33a4			 
33a4 cd 52 15				call config 
33a7					NEXTW 
33a7 c3 39 24			jp macro_next 
33aa				endm 
# End of macro NEXTW
33aa			 
33aa			.ADTOS: 
33aa				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
33aa 6f				db WORD_SYS_CORE+91             
33ab c0 33			dw .SBTOS            
33ad 03				db 2 + 1 
33ae .. 00			db "1+",0              
33b1				endm 
# End of macro CWHEAD
33b1			; | 1+ ( u -- u )  Increment value on TOS | DONE 
33b1			 
33b1					FORTH_DSP_VALUEHL 
33b1 cd 4d 22			call macro_dsp_valuehl 
33b4				endm 
# End of macro FORTH_DSP_VALUEHL
33b4 e5					push hl 
33b5			 
33b5					FORTH_DSP_POP 
33b5 cd 05 23			call macro_forth_dsp_pop 
33b8				endm 
# End of macro FORTH_DSP_POP
33b8 e1					pop hl 
33b9			 
33b9 23					inc hl 
33ba cd 48 20				call forth_push_numhl 
33bd					 
33bd					NEXTW 
33bd c3 39 24			jp macro_next 
33c0				endm 
# End of macro NEXTW
33c0			.SBTOS: 
33c0				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
33c0 6f				db WORD_SYS_CORE+91             
33c1 d6 33			dw .ADSTORE            
33c3 03				db 2 + 1 
33c4 .. 00			db "1-",0              
33c7				endm 
# End of macro CWHEAD
33c7			; | 1- ( u -- u )  Decrement value on TOS | DONE 
33c7			 
33c7					FORTH_DSP_VALUEHL 
33c7 cd 4d 22			call macro_dsp_valuehl 
33ca				endm 
# End of macro FORTH_DSP_VALUEHL
33ca e5					push hl 
33cb			 
33cb					FORTH_DSP_POP 
33cb cd 05 23			call macro_forth_dsp_pop 
33ce				endm 
# End of macro FORTH_DSP_POP
33ce e1					pop hl 
33cf			 
33cf 2b					dec hl 
33d0 cd 48 20				call forth_push_numhl 
33d3					 
33d3					NEXTW 
33d3 c3 39 24			jp macro_next 
33d6				endm 
# End of macro NEXTW
33d6			.ADSTORE: 
33d6				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
33d6 6f				db WORD_SYS_CORE+91             
33d7 ec 33			dw .ADWSTORE            
33d9 04				db 3 + 1 
33da .. 00			db "1+!",0              
33de				endm 
# End of macro CWHEAD
33de			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
33de			 
33de					FORTH_DSP_VALUEHL 
33de cd 4d 22			call macro_dsp_valuehl 
33e1				endm 
# End of macro FORTH_DSP_VALUEHL
33e1 e5					push hl 
33e2			 
33e2					FORTH_DSP_POP 
33e2 cd 05 23			call macro_forth_dsp_pop 
33e5				endm 
# End of macro FORTH_DSP_POP
33e5 e1					pop hl 
33e6			 
33e6 7e					ld a, (hl) 
33e7 3c					inc a 
33e8 77					ld (hl), a 
33e9					 
33e9					NEXTW 
33e9 c3 39 24			jp macro_next 
33ec				endm 
# End of macro NEXTW
33ec			.ADWSTORE: 
33ec				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
33ec 6f				db WORD_SYS_CORE+91             
33ed 0a 34			dw .SBSTORE            
33ef 05				db 4 + 1 
33f0 .. 00			db "1+2!",0              
33f5				endm 
# End of macro CWHEAD
33f5			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
33f5			 
33f5					FORTH_DSP_VALUEHL 
33f5 cd 4d 22			call macro_dsp_valuehl 
33f8				endm 
# End of macro FORTH_DSP_VALUEHL
33f8 e5					push hl 
33f9			 
33f9					FORTH_DSP_POP 
33f9 cd 05 23			call macro_forth_dsp_pop 
33fc				endm 
# End of macro FORTH_DSP_POP
33fc e1					pop hl 
33fd			 
33fd e5					push hl 
33fe			 
33fe cd bb 23				call loadwordinhl 
3401 23					inc hl 
3402			 
3402 d1					pop de 
3403 eb					ex de, hl 
3404 73					ld (hl), e 
3405 23					inc hl 
3406 72					ld (hl), d 
3407					 
3407					NEXTW 
3407 c3 39 24			jp macro_next 
340a				endm 
# End of macro NEXTW
340a			.SBSTORE: 
340a				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
340a 6f				db WORD_SYS_CORE+91             
340b 20 34			dw .SBWSTORE            
340d 04				db 3 + 1 
340e .. 00			db "1-!",0              
3412				endm 
# End of macro CWHEAD
3412			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
3412			 
3412					FORTH_DSP_VALUEHL 
3412 cd 4d 22			call macro_dsp_valuehl 
3415				endm 
# End of macro FORTH_DSP_VALUEHL
3415 e5					push hl 
3416			 
3416					FORTH_DSP_POP 
3416 cd 05 23			call macro_forth_dsp_pop 
3419				endm 
# End of macro FORTH_DSP_POP
3419 e1					pop hl 
341a			 
341a 7e					ld a, (hl) 
341b 3d					dec a 
341c 77					ld (hl), a 
341d					 
341d					NEXTW 
341d c3 39 24			jp macro_next 
3420				endm 
# End of macro NEXTW
3420			.SBWSTORE: 
3420				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
3420 6f				db WORD_SYS_CORE+91             
3421 3e 34			dw .ENDCORE            
3423 05				db 4 + 1 
3424 .. 00			db "1-2!",0              
3429				endm 
# End of macro CWHEAD
3429			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
3429			 
3429					FORTH_DSP_VALUEHL 
3429 cd 4d 22			call macro_dsp_valuehl 
342c				endm 
# End of macro FORTH_DSP_VALUEHL
342c e5					push hl 
342d			 
342d					FORTH_DSP_POP 
342d cd 05 23			call macro_forth_dsp_pop 
3430				endm 
# End of macro FORTH_DSP_POP
3430 e1					pop hl 
3431			 
3431 e5					push hl 
3432			 
3432 cd bb 23				call loadwordinhl 
3435 2b					dec hl 
3436			 
3436 d1					pop de 
3437 eb					ex de, hl 
3438 73					ld (hl), e 
3439 23					inc hl 
343a 72					ld (hl), d 
343b					 
343b					NEXTW 
343b c3 39 24			jp macro_next 
343e				endm 
# End of macro NEXTW
343e			.ENDCORE: 
343e			 
343e			; eof 
343e			 
343e			 
# End of file forth_words_core.asm
343e			include "forth_words_flow.asm" 
343e			 
343e			; | ## Program Flow Words 
343e			 
343e			.IF: 
343e				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
343e 1e				db WORD_SYS_CORE+10             
343f 33 35			dw .THEN            
3441 03				db 2 + 1 
3442 .. 00			db "IF",0              
3445				endm 
# End of macro CWHEAD
3445			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
3445			; 
3445					if DEBUG_FORTH_WORDS_KEY 
3445						DMARK "IF." 
3445 f5				push af  
3446 3a 5a 34			ld a, (.dmark)  
3449 32 a0 fd			ld (debug_mark),a  
344c 3a 5b 34			ld a, (.dmark+1)  
344f 32 a1 fd			ld (debug_mark+1),a  
3452 3a 5c 34			ld a, (.dmark+2)  
3455 32 a2 fd			ld (debug_mark+2),a  
3458 18 03			jr .pastdmark  
345a ..			.dmark: db "IF."  
345d f1			.pastdmark: pop af  
345e			endm  
# End of macro DMARK
345e						CALLMONITOR 
345e cd aa fd			call debug_vector  
3461				endm  
# End of macro CALLMONITOR
3461					endif 
3461			; eval TOS 
3461			 
3461				FORTH_DSP_VALUEHL 
3461 cd 4d 22			call macro_dsp_valuehl 
3464				endm 
# End of macro FORTH_DSP_VALUEHL
3464			 
3464			;	push hl 
3464				FORTH_DSP_POP 
3464 cd 05 23			call macro_forth_dsp_pop 
3467				endm 
# End of macro FORTH_DSP_POP
3467			;	pop hl 
3467			 
3467					if DEBUG_FORTH_WORDS 
3467						DMARK "IF1" 
3467 f5				push af  
3468 3a 7c 34			ld a, (.dmark)  
346b 32 a0 fd			ld (debug_mark),a  
346e 3a 7d 34			ld a, (.dmark+1)  
3471 32 a1 fd			ld (debug_mark+1),a  
3474 3a 7e 34			ld a, (.dmark+2)  
3477 32 a2 fd			ld (debug_mark+2),a  
347a 18 03			jr .pastdmark  
347c ..			.dmark: db "IF1"  
347f f1			.pastdmark: pop af  
3480			endm  
# End of macro DMARK
3480						CALLMONITOR 
3480 cd aa fd			call debug_vector  
3483				endm  
# End of macro CALLMONITOR
3483					endif 
3483 b7				or a        ; clear carry flag 
3484 11 00 00			ld de, 0 
3487 eb				ex de,hl 
3488 ed 52			sbc hl, de 
348a c2 14 35			jp nz, .iftrue 
348d			 
348d					if DEBUG_FORTH_WORDS 
348d						DMARK "IF2" 
348d f5				push af  
348e 3a a2 34			ld a, (.dmark)  
3491 32 a0 fd			ld (debug_mark),a  
3494 3a a3 34			ld a, (.dmark+1)  
3497 32 a1 fd			ld (debug_mark+1),a  
349a 3a a4 34			ld a, (.dmark+2)  
349d 32 a2 fd			ld (debug_mark+2),a  
34a0 18 03			jr .pastdmark  
34a2 ..			.dmark: db "IF2"  
34a5 f1			.pastdmark: pop af  
34a6			endm  
# End of macro DMARK
34a6						CALLMONITOR 
34a6 cd aa fd			call debug_vector  
34a9				endm  
# End of macro CALLMONITOR
34a9					endif 
34a9			 
34a9			; if not true then skip to THEN 
34a9			 
34a9				; TODO get tok_ptr 
34a9				; TODO consume toks until we get to THEN 
34a9			 
34a9 2a f7 f3			ld hl, (os_tok_ptr) 
34ac					if DEBUG_FORTH_WORDS 
34ac						DMARK "IF3" 
34ac f5				push af  
34ad 3a c1 34			ld a, (.dmark)  
34b0 32 a0 fd			ld (debug_mark),a  
34b3 3a c2 34			ld a, (.dmark+1)  
34b6 32 a1 fd			ld (debug_mark+1),a  
34b9 3a c3 34			ld a, (.dmark+2)  
34bc 32 a2 fd			ld (debug_mark+2),a  
34bf 18 03			jr .pastdmark  
34c1 ..			.dmark: db "IF3"  
34c4 f1			.pastdmark: pop af  
34c5			endm  
# End of macro DMARK
34c5						CALLMONITOR 
34c5 cd aa fd			call debug_vector  
34c8				endm  
# End of macro CALLMONITOR
34c8						 
34c8					endif 
34c8 11 0f 35			ld de, .ifthen 
34cb					if DEBUG_FORTH_WORDS 
34cb						DMARK "IF4" 
34cb f5				push af  
34cc 3a e0 34			ld a, (.dmark)  
34cf 32 a0 fd			ld (debug_mark),a  
34d2 3a e1 34			ld a, (.dmark+1)  
34d5 32 a1 fd			ld (debug_mark+1),a  
34d8 3a e2 34			ld a, (.dmark+2)  
34db 32 a2 fd			ld (debug_mark+2),a  
34de 18 03			jr .pastdmark  
34e0 ..			.dmark: db "IF4"  
34e3 f1			.pastdmark: pop af  
34e4			endm  
# End of macro DMARK
34e4						CALLMONITOR 
34e4 cd aa fd			call debug_vector  
34e7				endm  
# End of macro CALLMONITOR
34e7					endif 
34e7 cd 54 25			call findnexttok  
34ea			 
34ea					if DEBUG_FORTH_WORDS 
34ea						DMARK "IF5" 
34ea f5				push af  
34eb 3a ff 34			ld a, (.dmark)  
34ee 32 a0 fd			ld (debug_mark),a  
34f1 3a 00 35			ld a, (.dmark+1)  
34f4 32 a1 fd			ld (debug_mark+1),a  
34f7 3a 01 35			ld a, (.dmark+2)  
34fa 32 a2 fd			ld (debug_mark+2),a  
34fd 18 03			jr .pastdmark  
34ff ..			.dmark: db "IF5"  
3502 f1			.pastdmark: pop af  
3503			endm  
# End of macro DMARK
3503						CALLMONITOR 
3503 cd aa fd			call debug_vector  
3506				endm  
# End of macro CALLMONITOR
3506					endif 
3506				; TODO replace below with ; exec using tok_ptr 
3506 22 f7 f3			ld (os_tok_ptr), hl 
3509 c3 ca 24			jp exec1 
350c				NEXTW 
350c c3 39 24			jp macro_next 
350f				endm 
# End of macro NEXTW
350f			 
350f .. 00		.ifthen:  db "THEN",0 
3514			 
3514			.iftrue:		 
3514				; Exec next words normally 
3514			 
3514				; if true then exec following IF as normal 
3514					if DEBUG_FORTH_WORDS 
3514						DMARK "IFT" 
3514 f5				push af  
3515 3a 29 35			ld a, (.dmark)  
3518 32 a0 fd			ld (debug_mark),a  
351b 3a 2a 35			ld a, (.dmark+1)  
351e 32 a1 fd			ld (debug_mark+1),a  
3521 3a 2b 35			ld a, (.dmark+2)  
3524 32 a2 fd			ld (debug_mark+2),a  
3527 18 03			jr .pastdmark  
3529 ..			.dmark: db "IFT"  
352c f1			.pastdmark: pop af  
352d			endm  
# End of macro DMARK
352d						CALLMONITOR 
352d cd aa fd			call debug_vector  
3530				endm  
# End of macro CALLMONITOR
3530					endif 
3530			 
3530					NEXTW 
3530 c3 39 24			jp macro_next 
3533				endm 
# End of macro NEXTW
3533			.THEN: 
3533				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
3533 1f				db WORD_SYS_CORE+11             
3534 5b 35			dw .ELSE            
3536 05				db 4 + 1 
3537 .. 00			db "THEN",0              
353c				endm 
# End of macro CWHEAD
353c			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
353c					if DEBUG_FORTH_WORDS_KEY 
353c						DMARK "THN" 
353c f5				push af  
353d 3a 51 35			ld a, (.dmark)  
3540 32 a0 fd			ld (debug_mark),a  
3543 3a 52 35			ld a, (.dmark+1)  
3546 32 a1 fd			ld (debug_mark+1),a  
3549 3a 53 35			ld a, (.dmark+2)  
354c 32 a2 fd			ld (debug_mark+2),a  
354f 18 03			jr .pastdmark  
3551 ..			.dmark: db "THN"  
3554 f1			.pastdmark: pop af  
3555			endm  
# End of macro DMARK
3555						CALLMONITOR 
3555 cd aa fd			call debug_vector  
3558				endm  
# End of macro CALLMONITOR
3558					endif 
3558					NEXTW 
3558 c3 39 24			jp macro_next 
355b				endm 
# End of macro NEXTW
355b			.ELSE: 
355b				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
355b 20				db WORD_SYS_CORE+12             
355c 83 35			dw .DO            
355e 03				db 2 + 1 
355f .. 00			db "ELSE",0              
3564				endm 
# End of macro CWHEAD
3564			; | ELSE ( -- ) Not supported - does nothing | TODO 
3564			 
3564					if DEBUG_FORTH_WORDS_KEY 
3564						DMARK "ELS" 
3564 f5				push af  
3565 3a 79 35			ld a, (.dmark)  
3568 32 a0 fd			ld (debug_mark),a  
356b 3a 7a 35			ld a, (.dmark+1)  
356e 32 a1 fd			ld (debug_mark+1),a  
3571 3a 7b 35			ld a, (.dmark+2)  
3574 32 a2 fd			ld (debug_mark+2),a  
3577 18 03			jr .pastdmark  
3579 ..			.dmark: db "ELS"  
357c f1			.pastdmark: pop af  
357d			endm  
# End of macro DMARK
357d						CALLMONITOR 
357d cd aa fd			call debug_vector  
3580				endm  
# End of macro CALLMONITOR
3580					endif 
3580			 
3580			 
3580					NEXTW 
3580 c3 39 24			jp macro_next 
3583				endm 
# End of macro NEXTW
3583			.DO: 
3583				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3583 21				db WORD_SYS_CORE+13             
3584 aa 36			dw .LOOP            
3586 03				db 2 + 1 
3587 .. 00			db "DO",0              
358a				endm 
# End of macro CWHEAD
358a			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
358a			 
358a					if DEBUG_FORTH_WORDS_KEY 
358a						DMARK "DO." 
358a f5				push af  
358b 3a 9f 35			ld a, (.dmark)  
358e 32 a0 fd			ld (debug_mark),a  
3591 3a a0 35			ld a, (.dmark+1)  
3594 32 a1 fd			ld (debug_mark+1),a  
3597 3a a1 35			ld a, (.dmark+2)  
359a 32 a2 fd			ld (debug_mark+2),a  
359d 18 03			jr .pastdmark  
359f ..			.dmark: db "DO."  
35a2 f1			.pastdmark: pop af  
35a3			endm  
# End of macro DMARK
35a3						CALLMONITOR 
35a3 cd aa fd			call debug_vector  
35a6				endm  
# End of macro CALLMONITOR
35a6					endif 
35a6			;  push pc to rsp stack past the DO 
35a6			 
35a6 2a f7 f3				ld hl, (os_tok_ptr) 
35a9 23					inc hl   ; D 
35aa 23					inc hl  ; O 
35ab 23					inc hl   ; null 
35ac					if DEBUG_FORTH_WORDS 
35ac						DMARK "DO2" 
35ac f5				push af  
35ad 3a c1 35			ld a, (.dmark)  
35b0 32 a0 fd			ld (debug_mark),a  
35b3 3a c2 35			ld a, (.dmark+1)  
35b6 32 a1 fd			ld (debug_mark+1),a  
35b9 3a c3 35			ld a, (.dmark+2)  
35bc 32 a2 fd			ld (debug_mark+2),a  
35bf 18 03			jr .pastdmark  
35c1 ..			.dmark: db "DO2"  
35c4 f1			.pastdmark: pop af  
35c5			endm  
# End of macro DMARK
35c5						CALLMONITOR 
35c5 cd aa fd			call debug_vector  
35c8				endm  
# End of macro CALLMONITOR
35c8					endif 
35c8					FORTH_RSP_NEXT 
35c8 cd ef 1f			call macro_forth_rsp_next 
35cb				endm 
# End of macro FORTH_RSP_NEXT
35cb					if DEBUG_FORTH_WORDS 
35cb						DMARK "DO3" 
35cb f5				push af  
35cc 3a e0 35			ld a, (.dmark)  
35cf 32 a0 fd			ld (debug_mark),a  
35d2 3a e1 35			ld a, (.dmark+1)  
35d5 32 a1 fd			ld (debug_mark+1),a  
35d8 3a e2 35			ld a, (.dmark+2)  
35db 32 a2 fd			ld (debug_mark+2),a  
35de 18 03			jr .pastdmark  
35e0 ..			.dmark: db "DO3"  
35e3 f1			.pastdmark: pop af  
35e4			endm  
# End of macro DMARK
35e4						CALLMONITOR 
35e4 cd aa fd			call debug_vector  
35e7				endm  
# End of macro CALLMONITOR
35e7					endif 
35e7			 
35e7					;if DEBUG_FORTH_WORDS 
35e7				;		push hl 
35e7			;		endif  
35e7			 
35e7			; get counters from data stack 
35e7			 
35e7			 
35e7					FORTH_DSP_VALUEHL 
35e7 cd 4d 22			call macro_dsp_valuehl 
35ea				endm 
# End of macro FORTH_DSP_VALUEHL
35ea e5					push hl		 ; hl now has starting counter which needs to be tos 
35eb			 
35eb					if DEBUG_FORTH_WORDS 
35eb						DMARK "DO4" 
35eb f5				push af  
35ec 3a 00 36			ld a, (.dmark)  
35ef 32 a0 fd			ld (debug_mark),a  
35f2 3a 01 36			ld a, (.dmark+1)  
35f5 32 a1 fd			ld (debug_mark+1),a  
35f8 3a 02 36			ld a, (.dmark+2)  
35fb 32 a2 fd			ld (debug_mark+2),a  
35fe 18 03			jr .pastdmark  
3600 ..			.dmark: db "DO4"  
3603 f1			.pastdmark: pop af  
3604			endm  
# End of macro DMARK
3604						CALLMONITOR 
3604 cd aa fd			call debug_vector  
3607				endm  
# End of macro CALLMONITOR
3607					endif 
3607					FORTH_DSP_POP 
3607 cd 05 23			call macro_forth_dsp_pop 
360a				endm 
# End of macro FORTH_DSP_POP
360a			 
360a					if DEBUG_FORTH_WORDS 
360a						DMARK "DO5" 
360a f5				push af  
360b 3a 1f 36			ld a, (.dmark)  
360e 32 a0 fd			ld (debug_mark),a  
3611 3a 20 36			ld a, (.dmark+1)  
3614 32 a1 fd			ld (debug_mark+1),a  
3617 3a 21 36			ld a, (.dmark+2)  
361a 32 a2 fd			ld (debug_mark+2),a  
361d 18 03			jr .pastdmark  
361f ..			.dmark: db "DO5"  
3622 f1			.pastdmark: pop af  
3623			endm  
# End of macro DMARK
3623						CALLMONITOR 
3623 cd aa fd			call debug_vector  
3626				endm  
# End of macro CALLMONITOR
3626					endif 
3626			 
3626					FORTH_DSP_VALUEHL 
3626 cd 4d 22			call macro_dsp_valuehl 
3629				endm 
# End of macro FORTH_DSP_VALUEHL
3629			;		push hl		 ; hl now has starting limit counter 
3629			 
3629					if DEBUG_FORTH_WORDS 
3629						DMARK "DO6" 
3629 f5				push af  
362a 3a 3e 36			ld a, (.dmark)  
362d 32 a0 fd			ld (debug_mark),a  
3630 3a 3f 36			ld a, (.dmark+1)  
3633 32 a1 fd			ld (debug_mark+1),a  
3636 3a 40 36			ld a, (.dmark+2)  
3639 32 a2 fd			ld (debug_mark+2),a  
363c 18 03			jr .pastdmark  
363e ..			.dmark: db "DO6"  
3641 f1			.pastdmark: pop af  
3642			endm  
# End of macro DMARK
3642						CALLMONITOR 
3642 cd aa fd			call debug_vector  
3645				endm  
# End of macro CALLMONITOR
3645					endif 
3645					FORTH_DSP_POP 
3645 cd 05 23			call macro_forth_dsp_pop 
3648				endm 
# End of macro FORTH_DSP_POP
3648			 
3648			; put counters on the loop stack 
3648			 
3648			;		pop hl			 ; limit counter 
3648 d1					pop de			; start counter 
3649			 
3649					; push limit counter 
3649			 
3649					if DEBUG_FORTH_WORDS 
3649						DMARK "DO7" 
3649 f5				push af  
364a 3a 5e 36			ld a, (.dmark)  
364d 32 a0 fd			ld (debug_mark),a  
3650 3a 5f 36			ld a, (.dmark+1)  
3653 32 a1 fd			ld (debug_mark+1),a  
3656 3a 60 36			ld a, (.dmark+2)  
3659 32 a2 fd			ld (debug_mark+2),a  
365c 18 03			jr .pastdmark  
365e ..			.dmark: db "DO7"  
3661 f1			.pastdmark: pop af  
3662			endm  
# End of macro DMARK
3662						CALLMONITOR 
3662 cd aa fd			call debug_vector  
3665				endm  
# End of macro CALLMONITOR
3665					endif 
3665					FORTH_LOOP_NEXT 
3665 cd 7e 22			call macro_forth_loop_next 
3668				endm 
# End of macro FORTH_LOOP_NEXT
3668			 
3668					; push start counter 
3668			 
3668 eb					ex de, hl 
3669					if DEBUG_FORTH_WORDS 
3669						DMARK "DO7" 
3669 f5				push af  
366a 3a 7e 36			ld a, (.dmark)  
366d 32 a0 fd			ld (debug_mark),a  
3670 3a 7f 36			ld a, (.dmark+1)  
3673 32 a1 fd			ld (debug_mark+1),a  
3676 3a 80 36			ld a, (.dmark+2)  
3679 32 a2 fd			ld (debug_mark+2),a  
367c 18 03			jr .pastdmark  
367e ..			.dmark: db "DO7"  
3681 f1			.pastdmark: pop af  
3682			endm  
# End of macro DMARK
3682						CALLMONITOR 
3682 cd aa fd			call debug_vector  
3685				endm  
# End of macro CALLMONITOR
3685					endif 
3685					FORTH_LOOP_NEXT 
3685 cd 7e 22			call macro_forth_loop_next 
3688				endm 
# End of macro FORTH_LOOP_NEXT
3688			 
3688			 
3688					; init first round of I counter 
3688			 
3688 22 1b f4				ld (os_current_i), hl 
368b			 
368b					if DEBUG_FORTH_WORDS 
368b						DMARK "DO8" 
368b f5				push af  
368c 3a a0 36			ld a, (.dmark)  
368f 32 a0 fd			ld (debug_mark),a  
3692 3a a1 36			ld a, (.dmark+1)  
3695 32 a1 fd			ld (debug_mark+1),a  
3698 3a a2 36			ld a, (.dmark+2)  
369b 32 a2 fd			ld (debug_mark+2),a  
369e 18 03			jr .pastdmark  
36a0 ..			.dmark: db "DO8"  
36a3 f1			.pastdmark: pop af  
36a4			endm  
# End of macro DMARK
36a4						CALLMONITOR 
36a4 cd aa fd			call debug_vector  
36a7				endm  
# End of macro CALLMONITOR
36a7					endif 
36a7			 
36a7					NEXTW 
36a7 c3 39 24			jp macro_next 
36aa				endm 
# End of macro NEXTW
36aa			.LOOP: 
36aa				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
36aa 22				db WORD_SYS_CORE+14             
36ab c2 37			dw .I            
36ad 05				db 4 + 1 
36ae .. 00			db "LOOP",0              
36b3				endm 
# End of macro CWHEAD
36b3			; | LOOP ( -- ) Increment and test loop counter  | DONE 
36b3			 
36b3				; pop tos as current loop count to hl 
36b3			 
36b3				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
36b3			 
36b3				FORTH_LOOP_TOS 
36b3 cd b1 22			call macro_forth_loop_tos 
36b6				endm 
# End of macro FORTH_LOOP_TOS
36b6 e5				push hl 
36b7			 
36b7					if DEBUG_FORTH_WORDS_KEY 
36b7						DMARK "LOP" 
36b7 f5				push af  
36b8 3a cc 36			ld a, (.dmark)  
36bb 32 a0 fd			ld (debug_mark),a  
36be 3a cd 36			ld a, (.dmark+1)  
36c1 32 a1 fd			ld (debug_mark+1),a  
36c4 3a ce 36			ld a, (.dmark+2)  
36c7 32 a2 fd			ld (debug_mark+2),a  
36ca 18 03			jr .pastdmark  
36cc ..			.dmark: db "LOP"  
36cf f1			.pastdmark: pop af  
36d0			endm  
# End of macro DMARK
36d0						CALLMONITOR 
36d0 cd aa fd			call debug_vector  
36d3				endm  
# End of macro CALLMONITOR
36d3					endif 
36d3				; next item on the stack is the limit. get it 
36d3			 
36d3			 
36d3				FORTH_LOOP_POP 
36d3 cd bb 22			call macro_forth_loop_pop 
36d6				endm 
# End of macro FORTH_LOOP_POP
36d6			 
36d6				FORTH_LOOP_TOS 
36d6 cd b1 22			call macro_forth_loop_tos 
36d9				endm 
# End of macro FORTH_LOOP_TOS
36d9			 
36d9 d1				pop de		 ; de = i, hl = limit 
36da			 
36da					if DEBUG_FORTH_WORDS 
36da						DMARK "LP1" 
36da f5				push af  
36db 3a ef 36			ld a, (.dmark)  
36de 32 a0 fd			ld (debug_mark),a  
36e1 3a f0 36			ld a, (.dmark+1)  
36e4 32 a1 fd			ld (debug_mark+1),a  
36e7 3a f1 36			ld a, (.dmark+2)  
36ea 32 a2 fd			ld (debug_mark+2),a  
36ed 18 03			jr .pastdmark  
36ef ..			.dmark: db "LP1"  
36f2 f1			.pastdmark: pop af  
36f3			endm  
# End of macro DMARK
36f3						CALLMONITOR 
36f3 cd aa fd			call debug_vector  
36f6				endm  
# End of macro CALLMONITOR
36f6					endif 
36f6			 
36f6				; go back to previous word 
36f6			 
36f6 d5				push de    ; save I for inc later 
36f7			 
36f7			 
36f7				; get limit 
36f7				;  is I at limit? 
36f7			 
36f7			 
36f7					if DEBUG_FORTH_WORDS 
36f7						DMARK "LP1" 
36f7 f5				push af  
36f8 3a 0c 37			ld a, (.dmark)  
36fb 32 a0 fd			ld (debug_mark),a  
36fe 3a 0d 37			ld a, (.dmark+1)  
3701 32 a1 fd			ld (debug_mark+1),a  
3704 3a 0e 37			ld a, (.dmark+2)  
3707 32 a2 fd			ld (debug_mark+2),a  
370a 18 03			jr .pastdmark  
370c ..			.dmark: db "LP1"  
370f f1			.pastdmark: pop af  
3710			endm  
# End of macro DMARK
3710						CALLMONITOR 
3710 cd aa fd			call debug_vector  
3713				endm  
# End of macro CALLMONITOR
3713					endif 
3713			 
3713 ed 52			sbc hl, de 
3715			 
3715			 
3715				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3715			 
3715 20 26				jr nz, .loopnotdone 
3717			 
3717 e1				pop hl   ; get rid of saved I 
3718				FORTH_LOOP_POP     ; get rid of limit 
3718 cd bb 22			call macro_forth_loop_pop 
371b				endm 
# End of macro FORTH_LOOP_POP
371b			 
371b				FORTH_RSP_POP     ; get rid of DO ptr 
371b cd 10 20			call macro_forth_rsp_pop 
371e				endm 
# End of macro FORTH_RSP_POP
371e			 
371e			if DEBUG_FORTH_WORDS 
371e						DMARK "LP>" 
371e f5				push af  
371f 3a 33 37			ld a, (.dmark)  
3722 32 a0 fd			ld (debug_mark),a  
3725 3a 34 37			ld a, (.dmark+1)  
3728 32 a1 fd			ld (debug_mark+1),a  
372b 3a 35 37			ld a, (.dmark+2)  
372e 32 a2 fd			ld (debug_mark+2),a  
3731 18 03			jr .pastdmark  
3733 ..			.dmark: db "LP>"  
3736 f1			.pastdmark: pop af  
3737			endm  
# End of macro DMARK
3737				CALLMONITOR 
3737 cd aa fd			call debug_vector  
373a				endm  
# End of macro CALLMONITOR
373a			endif 
373a			 
373a					NEXTW 
373a c3 39 24			jp macro_next 
373d				endm 
# End of macro NEXTW
373d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
373d			 
373d			.loopnotdone: 
373d			 
373d e1				pop hl    ; get I 
373e 23				inc hl 
373f			 
373f			   	; save new I 
373f			 
373f			 
373f					; set I counter 
373f			 
373f 22 1b f4				ld (os_current_i), hl 
3742			 
3742					if DEBUG_FORTH_WORDS 
3742						DMARK "LPN" 
3742 f5				push af  
3743 3a 57 37			ld a, (.dmark)  
3746 32 a0 fd			ld (debug_mark),a  
3749 3a 58 37			ld a, (.dmark+1)  
374c 32 a1 fd			ld (debug_mark+1),a  
374f 3a 59 37			ld a, (.dmark+2)  
3752 32 a2 fd			ld (debug_mark+2),a  
3755 18 03			jr .pastdmark  
3757 ..			.dmark: db "LPN"  
375a f1			.pastdmark: pop af  
375b			endm  
# End of macro DMARK
375b					CALLMONITOR 
375b cd aa fd			call debug_vector  
375e				endm  
# End of macro CALLMONITOR
375e					endif 
375e					 
375e				FORTH_LOOP_NEXT 
375e cd 7e 22			call macro_forth_loop_next 
3761				endm 
# End of macro FORTH_LOOP_NEXT
3761			 
3761			 
3761					if DEBUG_FORTH_WORDS 
3761 eb						ex de,hl 
3762					endif 
3762			 
3762			;	; get DO ptr 
3762			; 
3762					if DEBUG_FORTH_WORDS 
3762						DMARK "LP7" 
3762 f5				push af  
3763 3a 77 37			ld a, (.dmark)  
3766 32 a0 fd			ld (debug_mark),a  
3769 3a 78 37			ld a, (.dmark+1)  
376c 32 a1 fd			ld (debug_mark+1),a  
376f 3a 79 37			ld a, (.dmark+2)  
3772 32 a2 fd			ld (debug_mark+2),a  
3775 18 03			jr .pastdmark  
3777 ..			.dmark: db "LP7"  
377a f1			.pastdmark: pop af  
377b			endm  
# End of macro DMARK
377b					CALLMONITOR 
377b cd aa fd			call debug_vector  
377e				endm  
# End of macro CALLMONITOR
377e					endif 
377e				FORTH_RSP_TOS 
377e cd 06 20			call macro_forth_rsp_tos 
3781				endm 
# End of macro FORTH_RSP_TOS
3781			 
3781					if DEBUG_FORTH_WORDS 
3781						DMARK "LP8" 
3781 f5				push af  
3782 3a 96 37			ld a, (.dmark)  
3785 32 a0 fd			ld (debug_mark),a  
3788 3a 97 37			ld a, (.dmark+1)  
378b 32 a1 fd			ld (debug_mark+1),a  
378e 3a 98 37			ld a, (.dmark+2)  
3791 32 a2 fd			ld (debug_mark+2),a  
3794 18 03			jr .pastdmark  
3796 ..			.dmark: db "LP8"  
3799 f1			.pastdmark: pop af  
379a			endm  
# End of macro DMARK
379a					CALLMONITOR 
379a cd aa fd			call debug_vector  
379d				endm  
# End of macro CALLMONITOR
379d					endif 
379d				;push hl 
379d			 
379d				; not going to DO any more 
379d				; get rid of the RSP pointer as DO will add it back in 
379d				;FORTH_RSP_POP 
379d				;pop hl 
379d			 
379d				;ld hl,(cli_ret_sp) 
379d				;ld e, (hl) 
379d				;inc hl 
379d				;ld d, (hl) 
379d				;ex de,hl 
379d 22 f7 f3			ld (os_tok_ptr), hl 
37a0					if DEBUG_FORTH_WORDS 
37a0						DMARK "LP<" 
37a0 f5				push af  
37a1 3a b5 37			ld a, (.dmark)  
37a4 32 a0 fd			ld (debug_mark),a  
37a7 3a b6 37			ld a, (.dmark+1)  
37aa 32 a1 fd			ld (debug_mark+1),a  
37ad 3a b7 37			ld a, (.dmark+2)  
37b0 32 a2 fd			ld (debug_mark+2),a  
37b3 18 03			jr .pastdmark  
37b5 ..			.dmark: db "LP<"  
37b8 f1			.pastdmark: pop af  
37b9			endm  
# End of macro DMARK
37b9					CALLMONITOR 
37b9 cd aa fd			call debug_vector  
37bc				endm  
# End of macro CALLMONITOR
37bc				endif 
37bc c3 ca 24			jp exec1 
37bf			 
37bf					 
37bf			 
37bf			 
37bf					NEXTW 
37bf c3 39 24			jp macro_next 
37c2				endm 
# End of macro NEXTW
37c2			.I:  
37c2			 
37c2				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
37c2 5e				db WORD_SYS_CORE+74             
37c3 ed 37			dw .DLOOP            
37c5 02				db 1 + 1 
37c6 .. 00			db "I",0              
37c8				endm 
# End of macro CWHEAD
37c8			; | I ( -- ) Current loop counter | DONE 
37c8					if DEBUG_FORTH_WORDS_KEY 
37c8						DMARK "I.." 
37c8 f5				push af  
37c9 3a dd 37			ld a, (.dmark)  
37cc 32 a0 fd			ld (debug_mark),a  
37cf 3a de 37			ld a, (.dmark+1)  
37d2 32 a1 fd			ld (debug_mark+1),a  
37d5 3a df 37			ld a, (.dmark+2)  
37d8 32 a2 fd			ld (debug_mark+2),a  
37db 18 03			jr .pastdmark  
37dd ..			.dmark: db "I.."  
37e0 f1			.pastdmark: pop af  
37e1			endm  
# End of macro DMARK
37e1						CALLMONITOR 
37e1 cd aa fd			call debug_vector  
37e4				endm  
# End of macro CALLMONITOR
37e4					endif 
37e4			 
37e4 2a 1b f4				ld hl,(os_current_i) 
37e7 cd 48 20				call forth_push_numhl 
37ea			 
37ea					NEXTW 
37ea c3 39 24			jp macro_next 
37ed				endm 
# End of macro NEXTW
37ed			.DLOOP: 
37ed				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
37ed 5f				db WORD_SYS_CORE+75             
37ee ce 38			dw .REPEAT            
37f0 06				db 5 + 1 
37f1 .. 00			db "-LOOP",0              
37f7				endm 
# End of macro CWHEAD
37f7			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
37f7				; pop tos as current loop count to hl 
37f7					if DEBUG_FORTH_WORDS_KEY 
37f7						DMARK "-LP" 
37f7 f5				push af  
37f8 3a 0c 38			ld a, (.dmark)  
37fb 32 a0 fd			ld (debug_mark),a  
37fe 3a 0d 38			ld a, (.dmark+1)  
3801 32 a1 fd			ld (debug_mark+1),a  
3804 3a 0e 38			ld a, (.dmark+2)  
3807 32 a2 fd			ld (debug_mark+2),a  
380a 18 03			jr .pastdmark  
380c ..			.dmark: db "-LP"  
380f f1			.pastdmark: pop af  
3810			endm  
# End of macro DMARK
3810						CALLMONITOR 
3810 cd aa fd			call debug_vector  
3813				endm  
# End of macro CALLMONITOR
3813					endif 
3813			 
3813				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3813			 
3813				FORTH_LOOP_TOS 
3813 cd b1 22			call macro_forth_loop_tos 
3816				endm 
# End of macro FORTH_LOOP_TOS
3816 e5				push hl 
3817			 
3817					if DEBUG_FORTH_WORDS 
3817						DMARK "-LP" 
3817 f5				push af  
3818 3a 2c 38			ld a, (.dmark)  
381b 32 a0 fd			ld (debug_mark),a  
381e 3a 2d 38			ld a, (.dmark+1)  
3821 32 a1 fd			ld (debug_mark+1),a  
3824 3a 2e 38			ld a, (.dmark+2)  
3827 32 a2 fd			ld (debug_mark+2),a  
382a 18 03			jr .pastdmark  
382c ..			.dmark: db "-LP"  
382f f1			.pastdmark: pop af  
3830			endm  
# End of macro DMARK
3830						CALLMONITOR 
3830 cd aa fd			call debug_vector  
3833				endm  
# End of macro CALLMONITOR
3833					endif 
3833				; next item on the stack is the limit. get it 
3833			 
3833			 
3833				FORTH_LOOP_POP 
3833 cd bb 22			call macro_forth_loop_pop 
3836				endm 
# End of macro FORTH_LOOP_POP
3836			 
3836				FORTH_LOOP_TOS 
3836 cd b1 22			call macro_forth_loop_tos 
3839				endm 
# End of macro FORTH_LOOP_TOS
3839			 
3839 d1				pop de		 ; de = i, hl = limit 
383a			 
383a					if DEBUG_FORTH_WORDS 
383a						DMARK "-L1" 
383a f5				push af  
383b 3a 4f 38			ld a, (.dmark)  
383e 32 a0 fd			ld (debug_mark),a  
3841 3a 50 38			ld a, (.dmark+1)  
3844 32 a1 fd			ld (debug_mark+1),a  
3847 3a 51 38			ld a, (.dmark+2)  
384a 32 a2 fd			ld (debug_mark+2),a  
384d 18 03			jr .pastdmark  
384f ..			.dmark: db "-L1"  
3852 f1			.pastdmark: pop af  
3853			endm  
# End of macro DMARK
3853						CALLMONITOR 
3853 cd aa fd			call debug_vector  
3856				endm  
# End of macro CALLMONITOR
3856					endif 
3856			 
3856				; go back to previous word 
3856			 
3856 d5				push de    ; save I for inc later 
3857			 
3857			 
3857				; get limit 
3857				;  is I at limit? 
3857			 
3857			 
3857					if DEBUG_FORTH_WORDS 
3857						DMARK "-L1" 
3857 f5				push af  
3858 3a 6c 38			ld a, (.dmark)  
385b 32 a0 fd			ld (debug_mark),a  
385e 3a 6d 38			ld a, (.dmark+1)  
3861 32 a1 fd			ld (debug_mark+1),a  
3864 3a 6e 38			ld a, (.dmark+2)  
3867 32 a2 fd			ld (debug_mark+2),a  
386a 18 03			jr .pastdmark  
386c ..			.dmark: db "-L1"  
386f f1			.pastdmark: pop af  
3870			endm  
# End of macro DMARK
3870						CALLMONITOR 
3870 cd aa fd			call debug_vector  
3873				endm  
# End of macro CALLMONITOR
3873					endif 
3873			 
3873 ed 52			sbc hl, de 
3875			 
3875			 
3875				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3875			 
3875 20 26				jr nz, .mloopnotdone 
3877			 
3877 e1				pop hl   ; get rid of saved I 
3878				FORTH_LOOP_POP     ; get rid of limit 
3878 cd bb 22			call macro_forth_loop_pop 
387b				endm 
# End of macro FORTH_LOOP_POP
387b			 
387b				FORTH_RSP_POP     ; get rid of DO ptr 
387b cd 10 20			call macro_forth_rsp_pop 
387e				endm 
# End of macro FORTH_RSP_POP
387e			 
387e			if DEBUG_FORTH_WORDS 
387e						DMARK "-L>" 
387e f5				push af  
387f 3a 93 38			ld a, (.dmark)  
3882 32 a0 fd			ld (debug_mark),a  
3885 3a 94 38			ld a, (.dmark+1)  
3888 32 a1 fd			ld (debug_mark+1),a  
388b 3a 95 38			ld a, (.dmark+2)  
388e 32 a2 fd			ld (debug_mark+2),a  
3891 18 03			jr .pastdmark  
3893 ..			.dmark: db "-L>"  
3896 f1			.pastdmark: pop af  
3897			endm  
# End of macro DMARK
3897				CALLMONITOR 
3897 cd aa fd			call debug_vector  
389a				endm  
# End of macro CALLMONITOR
389a			endif 
389a			 
389a					NEXTW 
389a c3 39 24			jp macro_next 
389d				endm 
# End of macro NEXTW
389d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
389d			 
389d			.mloopnotdone: 
389d			 
389d e1				pop hl    ; get I 
389e 2b				dec hl 
389f			 
389f			   	; save new I 
389f			 
389f			 
389f					; set I counter 
389f			 
389f 22 1b f4				ld (os_current_i), hl 
38a2			 
38a2					 
38a2				FORTH_LOOP_NEXT 
38a2 cd 7e 22			call macro_forth_loop_next 
38a5				endm 
# End of macro FORTH_LOOP_NEXT
38a5			 
38a5			 
38a5					if DEBUG_FORTH_WORDS 
38a5 eb						ex de,hl 
38a6					endif 
38a6			 
38a6			;	; get DO ptr 
38a6			; 
38a6				FORTH_RSP_TOS 
38a6 cd 06 20			call macro_forth_rsp_tos 
38a9				endm 
# End of macro FORTH_RSP_TOS
38a9			 
38a9				;push hl 
38a9			 
38a9				; not going to DO any more 
38a9				; get rid of the RSP pointer as DO will add it back in 
38a9				;FORTH_RSP_POP 
38a9				;pop hl 
38a9			 
38a9			 
38a9 22 f7 f3			ld (os_tok_ptr), hl 
38ac					if DEBUG_FORTH_WORDS 
38ac						DMARK "-L<" 
38ac f5				push af  
38ad 3a c1 38			ld a, (.dmark)  
38b0 32 a0 fd			ld (debug_mark),a  
38b3 3a c2 38			ld a, (.dmark+1)  
38b6 32 a1 fd			ld (debug_mark+1),a  
38b9 3a c3 38			ld a, (.dmark+2)  
38bc 32 a2 fd			ld (debug_mark+2),a  
38bf 18 03			jr .pastdmark  
38c1 ..			.dmark: db "-L<"  
38c4 f1			.pastdmark: pop af  
38c5			endm  
# End of macro DMARK
38c5					CALLMONITOR 
38c5 cd aa fd			call debug_vector  
38c8				endm  
# End of macro CALLMONITOR
38c8				endif 
38c8 c3 ca 24			jp exec1 
38cb			 
38cb					 
38cb			 
38cb			 
38cb			 
38cb				NEXTW 
38cb c3 39 24			jp macro_next 
38ce				endm 
# End of macro NEXTW
38ce			 
38ce			 
38ce			 
38ce			 
38ce			.REPEAT: 
38ce				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
38ce 71				db WORD_SYS_CORE+93             
38cf 21 39			dw .UNTIL            
38d1 06				db 5 + 1 
38d2 .. 00			db "REPEAT",0              
38d9				endm 
# End of macro CWHEAD
38d9			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
38d9			;  push pc to rsp stack past the REPEAT 
38d9					if DEBUG_FORTH_WORDS_KEY 
38d9						DMARK "REP" 
38d9 f5				push af  
38da 3a ee 38			ld a, (.dmark)  
38dd 32 a0 fd			ld (debug_mark),a  
38e0 3a ef 38			ld a, (.dmark+1)  
38e3 32 a1 fd			ld (debug_mark+1),a  
38e6 3a f0 38			ld a, (.dmark+2)  
38e9 32 a2 fd			ld (debug_mark+2),a  
38ec 18 03			jr .pastdmark  
38ee ..			.dmark: db "REP"  
38f1 f1			.pastdmark: pop af  
38f2			endm  
# End of macro DMARK
38f2						CALLMONITOR 
38f2 cd aa fd			call debug_vector  
38f5				endm  
# End of macro CALLMONITOR
38f5					endif 
38f5			 
38f5 2a f7 f3				ld hl, (os_tok_ptr) 
38f8 23					inc hl   ; R 
38f9 23					inc hl  ; E 
38fa 23					inc hl   ; P 
38fb 23					inc hl   ; E 
38fc 23					inc hl   ; A 
38fd 23					inc hl   ; T 
38fe 23					inc hl   ; zero 
38ff					FORTH_RSP_NEXT 
38ff cd ef 1f			call macro_forth_rsp_next 
3902				endm 
# End of macro FORTH_RSP_NEXT
3902			 
3902			 
3902					if DEBUG_FORTH_WORDS 
3902						DMARK "REP" 
3902 f5				push af  
3903 3a 17 39			ld a, (.dmark)  
3906 32 a0 fd			ld (debug_mark),a  
3909 3a 18 39			ld a, (.dmark+1)  
390c 32 a1 fd			ld (debug_mark+1),a  
390f 3a 19 39			ld a, (.dmark+2)  
3912 32 a2 fd			ld (debug_mark+2),a  
3915 18 03			jr .pastdmark  
3917 ..			.dmark: db "REP"  
391a f1			.pastdmark: pop af  
391b			endm  
# End of macro DMARK
391b						;pop bc    ; TODO BUG ?????? what is this for???? 
391b						CALLMONITOR 
391b cd aa fd			call debug_vector  
391e				endm  
# End of macro CALLMONITOR
391e					endif 
391e			 
391e					NEXTW 
391e c3 39 24			jp macro_next 
3921				endm 
# End of macro NEXTW
3921			;	       NEXTW 
3921			 
3921			.UNTIL: 
3921				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3921 72				db WORD_SYS_CORE+94             
3922 b8 39			dw .ENDFLOW            
3924 06				db 5 + 1 
3925 .. 00			db "UNTIL",0              
392b				endm 
# End of macro CWHEAD
392b			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
392b			 
392b				; pop tos as check 
392b			 
392b				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
392b			 
392b				FORTH_DSP_VALUEHL 
392b cd 4d 22			call macro_dsp_valuehl 
392e				endm 
# End of macro FORTH_DSP_VALUEHL
392e			 
392e					if DEBUG_FORTH_WORDS_KEY 
392e						DMARK "UNT" 
392e f5				push af  
392f 3a 43 39			ld a, (.dmark)  
3932 32 a0 fd			ld (debug_mark),a  
3935 3a 44 39			ld a, (.dmark+1)  
3938 32 a1 fd			ld (debug_mark+1),a  
393b 3a 45 39			ld a, (.dmark+2)  
393e 32 a2 fd			ld (debug_mark+2),a  
3941 18 03			jr .pastdmark  
3943 ..			.dmark: db "UNT"  
3946 f1			.pastdmark: pop af  
3947			endm  
# End of macro DMARK
3947						CALLMONITOR 
3947 cd aa fd			call debug_vector  
394a				endm  
# End of macro CALLMONITOR
394a					endif 
394a			 
394a			;	push hl 
394a				FORTH_DSP_POP 
394a cd 05 23			call macro_forth_dsp_pop 
394d				endm 
# End of macro FORTH_DSP_POP
394d			 
394d			;	pop hl 
394d			 
394d				; test if true 
394d			 
394d cd 07 10			call ishlzero 
3950			;	ld a,l 
3950			;	add h 
3950			; 
3950			;	cp 0 
3950			 
3950 20 3e			jr nz, .untilnotdone 
3952			 
3952					if DEBUG_FORTH_WORDS 
3952						DMARK "UNf" 
3952 f5				push af  
3953 3a 67 39			ld a, (.dmark)  
3956 32 a0 fd			ld (debug_mark),a  
3959 3a 68 39			ld a, (.dmark+1)  
395c 32 a1 fd			ld (debug_mark+1),a  
395f 3a 69 39			ld a, (.dmark+2)  
3962 32 a2 fd			ld (debug_mark+2),a  
3965 18 03			jr .pastdmark  
3967 ..			.dmark: db "UNf"  
396a f1			.pastdmark: pop af  
396b			endm  
# End of macro DMARK
396b						CALLMONITOR 
396b cd aa fd			call debug_vector  
396e				endm  
# End of macro CALLMONITOR
396e					endif 
396e			 
396e			 
396e			 
396e				FORTH_RSP_POP     ; get rid of DO ptr 
396e cd 10 20			call macro_forth_rsp_pop 
3971				endm 
# End of macro FORTH_RSP_POP
3971			 
3971			if DEBUG_FORTH_WORDS 
3971						DMARK "UN>" 
3971 f5				push af  
3972 3a 86 39			ld a, (.dmark)  
3975 32 a0 fd			ld (debug_mark),a  
3978 3a 87 39			ld a, (.dmark+1)  
397b 32 a1 fd			ld (debug_mark+1),a  
397e 3a 88 39			ld a, (.dmark+2)  
3981 32 a2 fd			ld (debug_mark+2),a  
3984 18 03			jr .pastdmark  
3986 ..			.dmark: db "UN>"  
3989 f1			.pastdmark: pop af  
398a			endm  
# End of macro DMARK
398a				CALLMONITOR 
398a cd aa fd			call debug_vector  
398d				endm  
# End of macro CALLMONITOR
398d			endif 
398d			 
398d					NEXTW 
398d c3 39 24			jp macro_next 
3990				endm 
# End of macro NEXTW
3990				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3990			 
3990			.untilnotdone: 
3990			 
3990			 
3990			;	; get DO ptr 
3990			; 
3990				FORTH_RSP_TOS 
3990 cd 06 20			call macro_forth_rsp_tos 
3993				endm 
# End of macro FORTH_RSP_TOS
3993			 
3993				;push hl 
3993			 
3993				; not going to DO any more 
3993				; get rid of the RSP pointer as DO will add it back in 
3993				;FORTH_RSP_POP 
3993				;pop hl 
3993			 
3993			 
3993 22 f7 f3			ld (os_tok_ptr), hl 
3996					if DEBUG_FORTH_WORDS 
3996						DMARK "UN<" 
3996 f5				push af  
3997 3a ab 39			ld a, (.dmark)  
399a 32 a0 fd			ld (debug_mark),a  
399d 3a ac 39			ld a, (.dmark+1)  
39a0 32 a1 fd			ld (debug_mark+1),a  
39a3 3a ad 39			ld a, (.dmark+2)  
39a6 32 a2 fd			ld (debug_mark+2),a  
39a9 18 03			jr .pastdmark  
39ab ..			.dmark: db "UN<"  
39ae f1			.pastdmark: pop af  
39af			endm  
# End of macro DMARK
39af					CALLMONITOR 
39af cd aa fd			call debug_vector  
39b2				endm  
# End of macro CALLMONITOR
39b2				endif 
39b2 c3 ca 24			jp exec1 
39b5			 
39b5					 
39b5			 
39b5			 
39b5					NEXTW 
39b5 c3 39 24			jp macro_next 
39b8				endm 
# End of macro NEXTW
39b8			 
39b8			 
39b8			.ENDFLOW: 
39b8			 
39b8			; eof 
39b8			 
# End of file forth_words_flow.asm
39b8			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
39b8			include "forth_words_logic.asm" 
39b8			 
39b8			; | ## Logic Words 
39b8			 
39b8			.NOT: 
39b8				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
39b8 2d				db WORD_SYS_CORE+25             
39b9 00 3a			dw .IS            
39bb 04				db 3 + 1 
39bc .. 00			db "NOT",0              
39c0				endm 
# End of macro CWHEAD
39c0			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
39c0					if DEBUG_FORTH_WORDS_KEY 
39c0						DMARK "NOT" 
39c0 f5				push af  
39c1 3a d5 39			ld a, (.dmark)  
39c4 32 a0 fd			ld (debug_mark),a  
39c7 3a d6 39			ld a, (.dmark+1)  
39ca 32 a1 fd			ld (debug_mark+1),a  
39cd 3a d7 39			ld a, (.dmark+2)  
39d0 32 a2 fd			ld (debug_mark+2),a  
39d3 18 03			jr .pastdmark  
39d5 ..			.dmark: db "NOT"  
39d8 f1			.pastdmark: pop af  
39d9			endm  
# End of macro DMARK
39d9						CALLMONITOR 
39d9 cd aa fd			call debug_vector  
39dc				endm  
# End of macro CALLMONITOR
39dc					endif 
39dc					FORTH_DSP 
39dc cd 13 22			call macro_forth_dsp 
39df				endm 
# End of macro FORTH_DSP
39df 7e					ld a,(hl)	; get type of value on TOS 
39e0 fe 02				cp DS_TYPE_INUM  
39e2 28 03				jr z, .noti 
39e4					NEXTW 
39e4 c3 39 24			jp macro_next 
39e7				endm 
# End of macro NEXTW
39e7			.noti:          FORTH_DSP_VALUEHL 
39e7 cd 4d 22			call macro_dsp_valuehl 
39ea				endm 
# End of macro FORTH_DSP_VALUEHL
39ea			;		push hl 
39ea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39ea cd 05 23			call macro_forth_dsp_pop 
39ed				endm 
# End of macro FORTH_DSP_POP
39ed			;		pop hl 
39ed 3e 00				ld a,0 
39ef bd					cp l 
39f0 28 04				jr z, .not2t 
39f2 2e 00				ld l, 0 
39f4 18 02				jr .notip 
39f6			 
39f6 2e ff		.not2t:		ld l, 255 
39f8			 
39f8 26 00		.notip:		ld h, 0	 
39fa			 
39fa cd 48 20				call forth_push_numhl 
39fd					NEXTW 
39fd c3 39 24			jp macro_next 
3a00				endm 
# End of macro NEXTW
3a00			 
3a00			.IS: 
3a00				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3a00 2d				db WORD_SYS_CORE+25             
3a01 26 3a			dw .LZERO            
3a03 03				db 2 + 1 
3a04 .. 00			db "IS",0              
3a07				endm 
# End of macro CWHEAD
3a07			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3a07					if DEBUG_FORTH_WORDS_KEY 
3a07						DMARK "IS." 
3a07 f5				push af  
3a08 3a 1c 3a			ld a, (.dmark)  
3a0b 32 a0 fd			ld (debug_mark),a  
3a0e 3a 1d 3a			ld a, (.dmark+1)  
3a11 32 a1 fd			ld (debug_mark+1),a  
3a14 3a 1e 3a			ld a, (.dmark+2)  
3a17 32 a2 fd			ld (debug_mark+2),a  
3a1a 18 03			jr .pastdmark  
3a1c ..			.dmark: db "IS."  
3a1f f1			.pastdmark: pop af  
3a20			endm  
# End of macro DMARK
3a20						CALLMONITOR 
3a20 cd aa fd			call debug_vector  
3a23				endm  
# End of macro CALLMONITOR
3a23					endif 
3a23					NEXTW 
3a23 c3 39 24			jp macro_next 
3a26				endm 
# End of macro NEXTW
3a26			.LZERO: 
3a26				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3a26 2d				db WORD_SYS_CORE+25             
3a27 30 3a			dw .TZERO            
3a29 03				db 2 + 1 
3a2a .. 00			db "0<",0              
3a2d				endm 
# End of macro CWHEAD
3a2d			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3a2d					NEXTW 
3a2d c3 39 24			jp macro_next 
3a30				endm 
# End of macro NEXTW
3a30			.TZERO: 
3a30				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3a30 2e				db WORD_SYS_CORE+26             
3a31 77 3a			dw .LESS            
3a33 03				db 2 + 1 
3a34 .. 00			db "0=",0              
3a37				endm 
# End of macro CWHEAD
3a37			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3a37				; TODO add floating point number detection 
3a37					;v5 FORTH_DSP_VALUE 
3a37					if DEBUG_FORTH_WORDS_KEY 
3a37						DMARK "0=." 
3a37 f5				push af  
3a38 3a 4c 3a			ld a, (.dmark)  
3a3b 32 a0 fd			ld (debug_mark),a  
3a3e 3a 4d 3a			ld a, (.dmark+1)  
3a41 32 a1 fd			ld (debug_mark+1),a  
3a44 3a 4e 3a			ld a, (.dmark+2)  
3a47 32 a2 fd			ld (debug_mark+2),a  
3a4a 18 03			jr .pastdmark  
3a4c ..			.dmark: db "0=."  
3a4f f1			.pastdmark: pop af  
3a50			endm  
# End of macro DMARK
3a50						CALLMONITOR 
3a50 cd aa fd			call debug_vector  
3a53				endm  
# End of macro CALLMONITOR
3a53					endif 
3a53					FORTH_DSP 
3a53 cd 13 22			call macro_forth_dsp 
3a56				endm 
# End of macro FORTH_DSP
3a56 7e					ld a,(hl)	; get type of value on TOS 
3a57 fe 02				cp DS_TYPE_INUM  
3a59 28 00				jr z, .tz_inum 
3a5b			 
3a5b				if FORTH_ENABLE_FLOATMATH 
3a5b					jr .tz_done 
3a5b			 
3a5b				endif 
3a5b					 
3a5b			 
3a5b			.tz_inum: 
3a5b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a5b cd 4d 22			call macro_dsp_valuehl 
3a5e				endm 
# End of macro FORTH_DSP_VALUEHL
3a5e			 
3a5e			;		push hl 
3a5e			 
3a5e					; destroy value TOS 
3a5e			 
3a5e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a5e cd 05 23			call macro_forth_dsp_pop 
3a61				endm 
# End of macro FORTH_DSP_POP
3a61			 
3a61			;		pop hl 
3a61			 
3a61 3e 00				ld a,0 
3a63			 
3a63 bd					cp l 
3a64 20 08				jr nz, .tz_notzero 
3a66			 
3a66 bc					cp h 
3a67			 
3a67 20 05				jr nz, .tz_notzero 
3a69			 
3a69			 
3a69 21 01 00				ld hl, FORTH_TRUE 
3a6c 18 03				jr .tz_done 
3a6e			 
3a6e 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3a71			 
3a71					; push value back onto stack for another op etc 
3a71			 
3a71			.tz_done: 
3a71 cd 48 20				call forth_push_numhl 
3a74			 
3a74					NEXTW 
3a74 c3 39 24			jp macro_next 
3a77				endm 
# End of macro NEXTW
3a77			.LESS: 
3a77				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3a77 2f				db WORD_SYS_CORE+27             
3a78 e0 3a			dw .GT            
3a7a 02				db 1 + 1 
3a7b .. 00			db "<",0              
3a7d				endm 
# End of macro CWHEAD
3a7d			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3a7d				; TODO add floating point number detection 
3a7d					if DEBUG_FORTH_WORDS_KEY 
3a7d						DMARK "LES" 
3a7d f5				push af  
3a7e 3a 92 3a			ld a, (.dmark)  
3a81 32 a0 fd			ld (debug_mark),a  
3a84 3a 93 3a			ld a, (.dmark+1)  
3a87 32 a1 fd			ld (debug_mark+1),a  
3a8a 3a 94 3a			ld a, (.dmark+2)  
3a8d 32 a2 fd			ld (debug_mark+2),a  
3a90 18 03			jr .pastdmark  
3a92 ..			.dmark: db "LES"  
3a95 f1			.pastdmark: pop af  
3a96			endm  
# End of macro DMARK
3a96						CALLMONITOR 
3a96 cd aa fd			call debug_vector  
3a99				endm  
# End of macro CALLMONITOR
3a99					endif 
3a99					FORTH_DSP 
3a99 cd 13 22			call macro_forth_dsp 
3a9c				endm 
# End of macro FORTH_DSP
3a9c					;v5 FORTH_DSP_VALUE 
3a9c 7e					ld a,(hl)	; get type of value on TOS 
3a9d fe 02				cp DS_TYPE_INUM  
3a9f 28 00				jr z, .less_inum 
3aa1			 
3aa1				if FORTH_ENABLE_FLOATMATH 
3aa1					jr .less_done 
3aa1			 
3aa1				endif 
3aa1					 
3aa1			 
3aa1			.less_inum: 
3aa1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3aa1 cd 4d 22			call macro_dsp_valuehl 
3aa4				endm 
# End of macro FORTH_DSP_VALUEHL
3aa4			 
3aa4 e5					push hl  ; u2 
3aa5			 
3aa5					; destroy value TOS 
3aa5			 
3aa5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aa5 cd 05 23			call macro_forth_dsp_pop 
3aa8				endm 
# End of macro FORTH_DSP_POP
3aa8			 
3aa8			 
3aa8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3aa8 cd 4d 22			call macro_dsp_valuehl 
3aab				endm 
# End of macro FORTH_DSP_VALUEHL
3aab			 
3aab e5					push hl    ; u1 
3aac			 
3aac					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3aac cd 05 23			call macro_forth_dsp_pop 
3aaf				endm 
# End of macro FORTH_DSP_POP
3aaf			 
3aaf			 
3aaf b7			 or a      ;clear carry flag 
3ab0 01 00 00		 ld bc, FORTH_FALSE 
3ab3 e1			  pop hl    ; u1 
3ab4 d1			  pop de    ; u2 
3ab5 ed 52		  sbc hl,de 
3ab7 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3ab9			 
3ab9 01 01 00		 ld bc, FORTH_TRUE 
3abc			.lscont:  
3abc c5					push bc 
3abd e1					pop hl 
3abe			 
3abe					if DEBUG_FORTH_WORDS 
3abe						DMARK "LT1" 
3abe f5				push af  
3abf 3a d3 3a			ld a, (.dmark)  
3ac2 32 a0 fd			ld (debug_mark),a  
3ac5 3a d4 3a			ld a, (.dmark+1)  
3ac8 32 a1 fd			ld (debug_mark+1),a  
3acb 3a d5 3a			ld a, (.dmark+2)  
3ace 32 a2 fd			ld (debug_mark+2),a  
3ad1 18 03			jr .pastdmark  
3ad3 ..			.dmark: db "LT1"  
3ad6 f1			.pastdmark: pop af  
3ad7			endm  
# End of macro DMARK
3ad7						CALLMONITOR 
3ad7 cd aa fd			call debug_vector  
3ada				endm  
# End of macro CALLMONITOR
3ada					endif 
3ada cd 48 20				call forth_push_numhl 
3add			 
3add					NEXTW 
3add c3 39 24			jp macro_next 
3ae0				endm 
# End of macro NEXTW
3ae0			.GT: 
3ae0				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3ae0 30				db WORD_SYS_CORE+28             
3ae1 49 3b			dw .EQUAL            
3ae3 02				db 1 + 1 
3ae4 .. 00			db ">",0              
3ae6				endm 
# End of macro CWHEAD
3ae6			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3ae6				; TODO add floating point number detection 
3ae6					if DEBUG_FORTH_WORDS_KEY 
3ae6						DMARK "GRT" 
3ae6 f5				push af  
3ae7 3a fb 3a			ld a, (.dmark)  
3aea 32 a0 fd			ld (debug_mark),a  
3aed 3a fc 3a			ld a, (.dmark+1)  
3af0 32 a1 fd			ld (debug_mark+1),a  
3af3 3a fd 3a			ld a, (.dmark+2)  
3af6 32 a2 fd			ld (debug_mark+2),a  
3af9 18 03			jr .pastdmark  
3afb ..			.dmark: db "GRT"  
3afe f1			.pastdmark: pop af  
3aff			endm  
# End of macro DMARK
3aff						CALLMONITOR 
3aff cd aa fd			call debug_vector  
3b02				endm  
# End of macro CALLMONITOR
3b02					endif 
3b02					FORTH_DSP 
3b02 cd 13 22			call macro_forth_dsp 
3b05				endm 
# End of macro FORTH_DSP
3b05					;FORTH_DSP_VALUE 
3b05 7e					ld a,(hl)	; get type of value on TOS 
3b06 fe 02				cp DS_TYPE_INUM  
3b08 28 00				jr z, .gt_inum 
3b0a			 
3b0a				if FORTH_ENABLE_FLOATMATH 
3b0a					jr .gt_done 
3b0a			 
3b0a				endif 
3b0a					 
3b0a			 
3b0a			.gt_inum: 
3b0a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b0a cd 4d 22			call macro_dsp_valuehl 
3b0d				endm 
# End of macro FORTH_DSP_VALUEHL
3b0d			 
3b0d e5					push hl  ; u2 
3b0e			 
3b0e					; destroy value TOS 
3b0e			 
3b0e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b0e cd 05 23			call macro_forth_dsp_pop 
3b11				endm 
# End of macro FORTH_DSP_POP
3b11			 
3b11			 
3b11					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b11 cd 4d 22			call macro_dsp_valuehl 
3b14				endm 
# End of macro FORTH_DSP_VALUEHL
3b14			 
3b14 e5					push hl    ; u1 
3b15			 
3b15					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b15 cd 05 23			call macro_forth_dsp_pop 
3b18				endm 
# End of macro FORTH_DSP_POP
3b18			 
3b18			 
3b18 b7			 or a      ;clear carry flag 
3b19 01 00 00		 ld bc, FORTH_FALSE 
3b1c e1			  pop hl    ; u1 
3b1d d1			  pop de    ; u2 
3b1e ed 52		  sbc hl,de 
3b20 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3b22			 
3b22 01 01 00		 ld bc, FORTH_TRUE 
3b25			.gtcont:  
3b25 c5					push bc 
3b26 e1					pop hl 
3b27			 
3b27					if DEBUG_FORTH_WORDS 
3b27						DMARK "GT1" 
3b27 f5				push af  
3b28 3a 3c 3b			ld a, (.dmark)  
3b2b 32 a0 fd			ld (debug_mark),a  
3b2e 3a 3d 3b			ld a, (.dmark+1)  
3b31 32 a1 fd			ld (debug_mark+1),a  
3b34 3a 3e 3b			ld a, (.dmark+2)  
3b37 32 a2 fd			ld (debug_mark+2),a  
3b3a 18 03			jr .pastdmark  
3b3c ..			.dmark: db "GT1"  
3b3f f1			.pastdmark: pop af  
3b40			endm  
# End of macro DMARK
3b40						CALLMONITOR 
3b40 cd aa fd			call debug_vector  
3b43				endm  
# End of macro CALLMONITOR
3b43					endif 
3b43 cd 48 20				call forth_push_numhl 
3b46			 
3b46					NEXTW 
3b46 c3 39 24			jp macro_next 
3b49				endm 
# End of macro NEXTW
3b49			.EQUAL: 
3b49				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3b49 31				db WORD_SYS_CORE+29             
3b4a b4 3b			dw .ENDLOGIC            
3b4c 02				db 1 + 1 
3b4d .. 00			db "=",0              
3b4f				endm 
# End of macro CWHEAD
3b4f			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3b4f				; TODO add floating point number detection 
3b4f					if DEBUG_FORTH_WORDS_KEY 
3b4f						DMARK "EQ." 
3b4f f5				push af  
3b50 3a 64 3b			ld a, (.dmark)  
3b53 32 a0 fd			ld (debug_mark),a  
3b56 3a 65 3b			ld a, (.dmark+1)  
3b59 32 a1 fd			ld (debug_mark+1),a  
3b5c 3a 66 3b			ld a, (.dmark+2)  
3b5f 32 a2 fd			ld (debug_mark+2),a  
3b62 18 03			jr .pastdmark  
3b64 ..			.dmark: db "EQ."  
3b67 f1			.pastdmark: pop af  
3b68			endm  
# End of macro DMARK
3b68						CALLMONITOR 
3b68 cd aa fd			call debug_vector  
3b6b				endm  
# End of macro CALLMONITOR
3b6b					endif 
3b6b					FORTH_DSP 
3b6b cd 13 22			call macro_forth_dsp 
3b6e				endm 
# End of macro FORTH_DSP
3b6e					;v5 FORTH_DSP_VALUE 
3b6e 7e					ld a,(hl)	; get type of value on TOS 
3b6f fe 02				cp DS_TYPE_INUM  
3b71 28 00				jr z, .eq_inum 
3b73			 
3b73				if FORTH_ENABLE_FLOATMATH 
3b73					jr .eq_done 
3b73			 
3b73				endif 
3b73					 
3b73			 
3b73			.eq_inum: 
3b73					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b73 cd 4d 22			call macro_dsp_valuehl 
3b76				endm 
# End of macro FORTH_DSP_VALUEHL
3b76			 
3b76 e5					push hl 
3b77			 
3b77					; destroy value TOS 
3b77			 
3b77					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b77 cd 05 23			call macro_forth_dsp_pop 
3b7a				endm 
# End of macro FORTH_DSP_POP
3b7a			 
3b7a			 
3b7a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b7a cd 4d 22			call macro_dsp_valuehl 
3b7d				endm 
# End of macro FORTH_DSP_VALUEHL
3b7d			 
3b7d					; one value on hl get other one back 
3b7d			 
3b7d e5					push hl 
3b7e			 
3b7e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b7e cd 05 23			call macro_forth_dsp_pop 
3b81				endm 
# End of macro FORTH_DSP_POP
3b81			 
3b81 0e 00				ld c, FORTH_FALSE 
3b83			 
3b83 e1					pop hl 
3b84 d1					pop de 
3b85			 
3b85 7b					ld a, e 
3b86 bd					cp l 
3b87			 
3b87 20 06				jr nz, .eq_done 
3b89			 
3b89 7a					ld a, d 
3b8a bc					cp h 
3b8b			 
3b8b 20 02				jr nz, .eq_done 
3b8d			 
3b8d 0e 01				ld c, FORTH_TRUE 
3b8f					 
3b8f			 
3b8f			 
3b8f			.eq_done: 
3b8f			 
3b8f					; TODO push value back onto stack for another op etc 
3b8f			 
3b8f 26 00				ld h, 0 
3b91 69					ld l, c 
3b92					if DEBUG_FORTH_WORDS 
3b92						DMARK "EQ1" 
3b92 f5				push af  
3b93 3a a7 3b			ld a, (.dmark)  
3b96 32 a0 fd			ld (debug_mark),a  
3b99 3a a8 3b			ld a, (.dmark+1)  
3b9c 32 a1 fd			ld (debug_mark+1),a  
3b9f 3a a9 3b			ld a, (.dmark+2)  
3ba2 32 a2 fd			ld (debug_mark+2),a  
3ba5 18 03			jr .pastdmark  
3ba7 ..			.dmark: db "EQ1"  
3baa f1			.pastdmark: pop af  
3bab			endm  
# End of macro DMARK
3bab						CALLMONITOR 
3bab cd aa fd			call debug_vector  
3bae				endm  
# End of macro CALLMONITOR
3bae					endif 
3bae cd 48 20				call forth_push_numhl 
3bb1			 
3bb1					NEXTW 
3bb1 c3 39 24			jp macro_next 
3bb4				endm 
# End of macro NEXTW
3bb4			 
3bb4			 
3bb4			.ENDLOGIC: 
3bb4			; eof 
3bb4			 
3bb4			 
# End of file forth_words_logic.asm
3bb4			include "forth_words_maths.asm" 
3bb4			 
3bb4			; | ## Maths Words 
3bb4			 
3bb4			.PLUS:	 
3bb4				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3bb4 15				db WORD_SYS_CORE+1             
3bb5 12 3c			dw .NEG            
3bb7 02				db 1 + 1 
3bb8 .. 00			db "+",0              
3bba				endm 
# End of macro CWHEAD
3bba			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3bba					if DEBUG_FORTH_WORDS_KEY 
3bba						DMARK "PLU" 
3bba f5				push af  
3bbb 3a cf 3b			ld a, (.dmark)  
3bbe 32 a0 fd			ld (debug_mark),a  
3bc1 3a d0 3b			ld a, (.dmark+1)  
3bc4 32 a1 fd			ld (debug_mark+1),a  
3bc7 3a d1 3b			ld a, (.dmark+2)  
3bca 32 a2 fd			ld (debug_mark+2),a  
3bcd 18 03			jr .pastdmark  
3bcf ..			.dmark: db "PLU"  
3bd2 f1			.pastdmark: pop af  
3bd3			endm  
# End of macro DMARK
3bd3						CALLMONITOR 
3bd3 cd aa fd			call debug_vector  
3bd6				endm  
# End of macro CALLMONITOR
3bd6					endif 
3bd6					; add top two values and push back result 
3bd6			 
3bd6					;for v5 FORTH_DSP_VALUE 
3bd6					FORTH_DSP 
3bd6 cd 13 22			call macro_forth_dsp 
3bd9				endm 
# End of macro FORTH_DSP
3bd9 7e					ld a,(hl)	; get type of value on TOS 
3bda fe 02				cp DS_TYPE_INUM  
3bdc 28 03				jr z, .dot_inum 
3bde			 
3bde					NEXTW 
3bde c3 39 24			jp macro_next 
3be1				endm 
# End of macro NEXTW
3be1			 
3be1			; float maths 
3be1			 
3be1				if FORTH_ENABLE_FLOATMATH 
3be1						inc hl      ; now at start of numeric as string 
3be1			 
3be1					if DEBUG_FORTH_MATHS 
3be1						DMARK "ADD" 
3be1				CALLMONITOR 
3be1					endif 
3be1			 
3be1					;ld ix, hl 
3be1					call CON 
3be1			 
3be1			 
3be1					push hl 
3be1					 
3be1					 
3be1			 
3be1						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3be1			 
3be1					; get next number 
3be1			 
3be1						FORTH_DSP_VALUE 
3be1			 
3be1						inc hl      ; now at start of numeric as string 
3be1			 
3be1					;ld ix, hl 
3be1					call CON 
3be1			 
3be1					push hl 
3be1			 
3be1			 
3be1						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3be1			 
3be1						; TODO do add 
3be1			 
3be1						call IADD 
3be1			 
3be1						; TODO get result back as ascii 
3be1			 
3be1						; TODO push result  
3be1			 
3be1			 
3be1			 
3be1						jr .dot_done 
3be1				endif 
3be1			 
3be1			.dot_inum: 
3be1			 
3be1			 
3be1					if DEBUG_FORTH_DOT 
3be1						DMARK "+IT" 
3be1 f5				push af  
3be2 3a f6 3b			ld a, (.dmark)  
3be5 32 a0 fd			ld (debug_mark),a  
3be8 3a f7 3b			ld a, (.dmark+1)  
3beb 32 a1 fd			ld (debug_mark+1),a  
3bee 3a f8 3b			ld a, (.dmark+2)  
3bf1 32 a2 fd			ld (debug_mark+2),a  
3bf4 18 03			jr .pastdmark  
3bf6 ..			.dmark: db "+IT"  
3bf9 f1			.pastdmark: pop af  
3bfa			endm  
# End of macro DMARK
3bfa				CALLMONITOR 
3bfa cd aa fd			call debug_vector  
3bfd				endm  
# End of macro CALLMONITOR
3bfd					endif 
3bfd			 
3bfd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bfd cd 4d 22			call macro_dsp_valuehl 
3c00				endm 
# End of macro FORTH_DSP_VALUEHL
3c00			 
3c00				; TODO add floating point number detection 
3c00			 
3c00 e5					push hl 
3c01			 
3c01					; destroy value TOS 
3c01			 
3c01					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c01 cd 05 23			call macro_forth_dsp_pop 
3c04				endm 
# End of macro FORTH_DSP_POP
3c04			 
3c04			 
3c04					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c04 cd 4d 22			call macro_dsp_valuehl 
3c07				endm 
# End of macro FORTH_DSP_VALUEHL
3c07			 
3c07					; one value on hl get other one back 
3c07			 
3c07 d1					pop de 
3c08			 
3c08					; do the add 
3c08			 
3c08 19					add hl,de 
3c09			 
3c09					; save it 
3c09			 
3c09			;		push hl	 
3c09			 
3c09					; 
3c09			 
3c09					; destroy value TOS 
3c09			 
3c09					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c09 cd 05 23			call macro_forth_dsp_pop 
3c0c				endm 
# End of macro FORTH_DSP_POP
3c0c			 
3c0c					; TODO push value back onto stack for another op etc 
3c0c			 
3c0c			;		pop hl 
3c0c			 
3c0c			.dot_done: 
3c0c cd 48 20				call forth_push_numhl 
3c0f			 
3c0f					NEXTW 
3c0f c3 39 24			jp macro_next 
3c12				endm 
# End of macro NEXTW
3c12			.NEG: 
3c12			 
3c12				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3c12 17				db WORD_SYS_CORE+3             
3c13 55 3c			dw .DIV            
3c15 02				db 1 + 1 
3c16 .. 00			db "-",0              
3c18				endm 
# End of macro CWHEAD
3c18			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3c18					if DEBUG_FORTH_WORDS_KEY 
3c18						DMARK "SUB" 
3c18 f5				push af  
3c19 3a 2d 3c			ld a, (.dmark)  
3c1c 32 a0 fd			ld (debug_mark),a  
3c1f 3a 2e 3c			ld a, (.dmark+1)  
3c22 32 a1 fd			ld (debug_mark+1),a  
3c25 3a 2f 3c			ld a, (.dmark+2)  
3c28 32 a2 fd			ld (debug_mark+2),a  
3c2b 18 03			jr .pastdmark  
3c2d ..			.dmark: db "SUB"  
3c30 f1			.pastdmark: pop af  
3c31			endm  
# End of macro DMARK
3c31						CALLMONITOR 
3c31 cd aa fd			call debug_vector  
3c34				endm  
# End of macro CALLMONITOR
3c34					endif 
3c34			 
3c34			 
3c34				; TODO add floating point number detection 
3c34					; v5 FORTH_DSP_VALUE 
3c34					FORTH_DSP 
3c34 cd 13 22			call macro_forth_dsp 
3c37				endm 
# End of macro FORTH_DSP
3c37 7e					ld a,(hl)	; get type of value on TOS 
3c38 fe 02				cp DS_TYPE_INUM  
3c3a 28 03				jr z, .neg_inum 
3c3c			 
3c3c					NEXTW 
3c3c c3 39 24			jp macro_next 
3c3f				endm 
# End of macro NEXTW
3c3f			 
3c3f			; float maths 
3c3f			 
3c3f				if FORTH_ENABLE_FLOATMATH 
3c3f					jr .neg_done 
3c3f			 
3c3f				endif 
3c3f					 
3c3f			 
3c3f			.neg_inum: 
3c3f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c3f cd 4d 22			call macro_dsp_valuehl 
3c42				endm 
# End of macro FORTH_DSP_VALUEHL
3c42			 
3c42 e5					push hl 
3c43			 
3c43					; destroy value TOS 
3c43			 
3c43					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c43 cd 05 23			call macro_forth_dsp_pop 
3c46				endm 
# End of macro FORTH_DSP_POP
3c46			 
3c46			 
3c46					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c46 cd 4d 22			call macro_dsp_valuehl 
3c49				endm 
# End of macro FORTH_DSP_VALUEHL
3c49			 
3c49					; one value on hl get other one back 
3c49			 
3c49 d1					pop de 
3c4a			 
3c4a					; do the sub 
3c4a			;		ex de, hl 
3c4a			 
3c4a ed 52				sbc hl,de 
3c4c			 
3c4c					; save it 
3c4c			 
3c4c			;		push hl	 
3c4c			 
3c4c					; 
3c4c			 
3c4c					; destroy value TOS 
3c4c			 
3c4c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c4c cd 05 23			call macro_forth_dsp_pop 
3c4f				endm 
# End of macro FORTH_DSP_POP
3c4f			 
3c4f					; TODO push value back onto stack for another op etc 
3c4f			 
3c4f			;		pop hl 
3c4f			 
3c4f cd 48 20				call forth_push_numhl 
3c52			.neg_done: 
3c52			 
3c52					NEXTW 
3c52 c3 39 24			jp macro_next 
3c55				endm 
# End of macro NEXTW
3c55			.DIV: 
3c55				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3c55 18				db WORD_SYS_CORE+4             
3c56 a2 3c			dw .MUL            
3c58 02				db 1 + 1 
3c59 .. 00			db "/",0              
3c5b				endm 
# End of macro CWHEAD
3c5b			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3c5b					if DEBUG_FORTH_WORDS_KEY 
3c5b						DMARK "DIV" 
3c5b f5				push af  
3c5c 3a 70 3c			ld a, (.dmark)  
3c5f 32 a0 fd			ld (debug_mark),a  
3c62 3a 71 3c			ld a, (.dmark+1)  
3c65 32 a1 fd			ld (debug_mark+1),a  
3c68 3a 72 3c			ld a, (.dmark+2)  
3c6b 32 a2 fd			ld (debug_mark+2),a  
3c6e 18 03			jr .pastdmark  
3c70 ..			.dmark: db "DIV"  
3c73 f1			.pastdmark: pop af  
3c74			endm  
# End of macro DMARK
3c74						CALLMONITOR 
3c74 cd aa fd			call debug_vector  
3c77				endm  
# End of macro CALLMONITOR
3c77					endif 
3c77				; TODO add floating point number detection 
3c77					; v5 FORTH_DSP_VALUE 
3c77					FORTH_DSP 
3c77 cd 13 22			call macro_forth_dsp 
3c7a				endm 
# End of macro FORTH_DSP
3c7a 7e					ld a,(hl)	; get type of value on TOS 
3c7b fe 02				cp DS_TYPE_INUM  
3c7d 28 03				jr z, .div_inum 
3c7f			 
3c7f				if FORTH_ENABLE_FLOATMATH 
3c7f					jr .div_done 
3c7f			 
3c7f				endif 
3c7f					NEXTW 
3c7f c3 39 24			jp macro_next 
3c82				endm 
# End of macro NEXTW
3c82			.div_inum: 
3c82			 
3c82					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c82 cd 4d 22			call macro_dsp_valuehl 
3c85				endm 
# End of macro FORTH_DSP_VALUEHL
3c85			 
3c85 e5					push hl    ; to go to bc 
3c86			 
3c86					; destroy value TOS 
3c86			 
3c86					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c86 cd 05 23			call macro_forth_dsp_pop 
3c89				endm 
# End of macro FORTH_DSP_POP
3c89			 
3c89			 
3c89					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c89 cd 4d 22			call macro_dsp_valuehl 
3c8c				endm 
# End of macro FORTH_DSP_VALUEHL
3c8c			 
3c8c					; hl to go to de 
3c8c			 
3c8c e5					push hl 
3c8d			 
3c8d c1					pop bc 
3c8e d1					pop de		 
3c8f			 
3c8f			 
3c8f					if DEBUG_FORTH_MATHS 
3c8f						DMARK "DIV" 
3c8f				CALLMONITOR 
3c8f					endif 
3c8f					; one value on hl but move to a get other one back 
3c8f			 
3c8f			        
3c8f cd 3b 0f			call Div16 
3c92			 
3c92			;	push af	 
3c92 e5				push hl 
3c93 c5				push bc 
3c94			 
3c94					if DEBUG_FORTH_MATHS 
3c94						DMARK "DI1" 
3c94				CALLMONITOR 
3c94					endif 
3c94			 
3c94					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c94 cd 05 23			call macro_forth_dsp_pop 
3c97				endm 
# End of macro FORTH_DSP_POP
3c97			 
3c97			 
3c97			 
3c97 e1					pop hl    ; result 
3c98			 
3c98 cd 48 20				call forth_push_numhl 
3c9b			 
3c9b e1					pop hl    ; reminder 
3c9c			;		ld h,0 
3c9c			;		ld l,d 
3c9c			 
3c9c cd 48 20				call forth_push_numhl 
3c9f			.div_done: 
3c9f					NEXTW 
3c9f c3 39 24			jp macro_next 
3ca2				endm 
# End of macro NEXTW
3ca2			.MUL: 
3ca2				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3ca2 19				db WORD_SYS_CORE+5             
3ca3 e7 3c			dw .MIN            
3ca5 02				db 1 + 1 
3ca6 .. 00			db "*",0              
3ca8				endm 
# End of macro CWHEAD
3ca8			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3ca8				; TODO add floating point number detection 
3ca8					if DEBUG_FORTH_WORDS_KEY 
3ca8						DMARK "MUL" 
3ca8 f5				push af  
3ca9 3a bd 3c			ld a, (.dmark)  
3cac 32 a0 fd			ld (debug_mark),a  
3caf 3a be 3c			ld a, (.dmark+1)  
3cb2 32 a1 fd			ld (debug_mark+1),a  
3cb5 3a bf 3c			ld a, (.dmark+2)  
3cb8 32 a2 fd			ld (debug_mark+2),a  
3cbb 18 03			jr .pastdmark  
3cbd ..			.dmark: db "MUL"  
3cc0 f1			.pastdmark: pop af  
3cc1			endm  
# End of macro DMARK
3cc1						CALLMONITOR 
3cc1 cd aa fd			call debug_vector  
3cc4				endm  
# End of macro CALLMONITOR
3cc4					endif 
3cc4					FORTH_DSP 
3cc4 cd 13 22			call macro_forth_dsp 
3cc7				endm 
# End of macro FORTH_DSP
3cc7					; v5 FORTH_DSP_VALUE 
3cc7 7e					ld a,(hl)	; get type of value on TOS 
3cc8 fe 02				cp DS_TYPE_INUM  
3cca 28 03				jr z, .mul_inum 
3ccc			 
3ccc				if FORTH_ENABLE_FLOATMATH 
3ccc					jr .mul_done 
3ccc			 
3ccc				endif 
3ccc			 
3ccc					NEXTW 
3ccc c3 39 24			jp macro_next 
3ccf				endm 
# End of macro NEXTW
3ccf			.mul_inum:	 
3ccf			 
3ccf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ccf cd 4d 22			call macro_dsp_valuehl 
3cd2				endm 
# End of macro FORTH_DSP_VALUEHL
3cd2			 
3cd2 e5					push hl 
3cd3			 
3cd3					; destroy value TOS 
3cd3			 
3cd3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cd3 cd 05 23			call macro_forth_dsp_pop 
3cd6				endm 
# End of macro FORTH_DSP_POP
3cd6			 
3cd6			 
3cd6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cd6 cd 4d 22			call macro_dsp_valuehl 
3cd9				endm 
# End of macro FORTH_DSP_VALUEHL
3cd9			 
3cd9					; one value on hl but move to a get other one back 
3cd9			 
3cd9 7d					ld a, l 
3cda			 
3cda d1					pop de 
3cdb			 
3cdb					; do the mull 
3cdb			;		ex de, hl 
3cdb			 
3cdb cd 61 0f				call Mult16 
3cde					; save it 
3cde			 
3cde			;		push hl	 
3cde			 
3cde					; 
3cde			 
3cde					; destroy value TOS 
3cde			 
3cde					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cde cd 05 23			call macro_forth_dsp_pop 
3ce1				endm 
# End of macro FORTH_DSP_POP
3ce1			 
3ce1					; TODO push value back onto stack for another op etc 
3ce1			 
3ce1			;		pop hl 
3ce1			 
3ce1 cd 48 20				call forth_push_numhl 
3ce4			 
3ce4			.mul_done: 
3ce4					NEXTW 
3ce4 c3 39 24			jp macro_next 
3ce7				endm 
# End of macro NEXTW
3ce7			 
3ce7			 
3ce7			 
3ce7			 
3ce7			.MIN: 
3ce7				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3ce7 49				db WORD_SYS_CORE+53             
3ce8 68 3d			dw .MAX            
3cea 04				db 3 + 1 
3ceb .. 00			db "MIN",0              
3cef				endm 
# End of macro CWHEAD
3cef			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3cef					if DEBUG_FORTH_WORDS_KEY 
3cef						DMARK "MIN" 
3cef f5				push af  
3cf0 3a 04 3d			ld a, (.dmark)  
3cf3 32 a0 fd			ld (debug_mark),a  
3cf6 3a 05 3d			ld a, (.dmark+1)  
3cf9 32 a1 fd			ld (debug_mark+1),a  
3cfc 3a 06 3d			ld a, (.dmark+2)  
3cff 32 a2 fd			ld (debug_mark+2),a  
3d02 18 03			jr .pastdmark  
3d04 ..			.dmark: db "MIN"  
3d07 f1			.pastdmark: pop af  
3d08			endm  
# End of macro DMARK
3d08						CALLMONITOR 
3d08 cd aa fd			call debug_vector  
3d0b				endm  
# End of macro CALLMONITOR
3d0b					endif 
3d0b					; get u2 
3d0b			 
3d0b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d0b cd 4d 22			call macro_dsp_valuehl 
3d0e				endm 
# End of macro FORTH_DSP_VALUEHL
3d0e			 
3d0e e5					push hl   ; u2 
3d0f			 
3d0f					; destroy value TOS 
3d0f			 
3d0f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d0f cd 05 23			call macro_forth_dsp_pop 
3d12				endm 
# End of macro FORTH_DSP_POP
3d12			 
3d12					; get u1 
3d12			 
3d12					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d12 cd 4d 22			call macro_dsp_valuehl 
3d15				endm 
# End of macro FORTH_DSP_VALUEHL
3d15			 
3d15 e5					push hl  ; u1 
3d16			 
3d16					; destroy value TOS 
3d16			 
3d16					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d16 cd 05 23			call macro_forth_dsp_pop 
3d19				endm 
# End of macro FORTH_DSP_POP
3d19			 
3d19 b7			 or a      ;clear carry flag 
3d1a e1			  pop hl    ; u1 
3d1b d1			  pop de    ; u2 
3d1c e5				push hl   ; saved in case hl is lowest 
3d1d ed 52		  sbc hl,de 
3d1f 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3d21			 
3d21 e1				pop hl 
3d22					if DEBUG_FORTH_WORDS 
3d22						DMARK "MIN" 
3d22 f5				push af  
3d23 3a 37 3d			ld a, (.dmark)  
3d26 32 a0 fd			ld (debug_mark),a  
3d29 3a 38 3d			ld a, (.dmark+1)  
3d2c 32 a1 fd			ld (debug_mark+1),a  
3d2f 3a 39 3d			ld a, (.dmark+2)  
3d32 32 a2 fd			ld (debug_mark+2),a  
3d35 18 03			jr .pastdmark  
3d37 ..			.dmark: db "MIN"  
3d3a f1			.pastdmark: pop af  
3d3b			endm  
# End of macro DMARK
3d3b						CALLMONITOR 
3d3b cd aa fd			call debug_vector  
3d3e				endm  
# End of macro CALLMONITOR
3d3e					endif 
3d3e cd 48 20				call forth_push_numhl 
3d41			 
3d41				       NEXTW 
3d41 c3 39 24			jp macro_next 
3d44				endm 
# End of macro NEXTW
3d44			 
3d44			.mincont:  
3d44 c1				pop bc   ; tidy up 
3d45 eb				ex de , hl  
3d46					if DEBUG_FORTH_WORDS 
3d46						DMARK "MI1" 
3d46 f5				push af  
3d47 3a 5b 3d			ld a, (.dmark)  
3d4a 32 a0 fd			ld (debug_mark),a  
3d4d 3a 5c 3d			ld a, (.dmark+1)  
3d50 32 a1 fd			ld (debug_mark+1),a  
3d53 3a 5d 3d			ld a, (.dmark+2)  
3d56 32 a2 fd			ld (debug_mark+2),a  
3d59 18 03			jr .pastdmark  
3d5b ..			.dmark: db "MI1"  
3d5e f1			.pastdmark: pop af  
3d5f			endm  
# End of macro DMARK
3d5f						CALLMONITOR 
3d5f cd aa fd			call debug_vector  
3d62				endm  
# End of macro CALLMONITOR
3d62					endif 
3d62 cd 48 20				call forth_push_numhl 
3d65			 
3d65				       NEXTW 
3d65 c3 39 24			jp macro_next 
3d68				endm 
# End of macro NEXTW
3d68			.MAX: 
3d68				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
3d68 4a				db WORD_SYS_CORE+54             
3d69 e9 3d			dw .RND16            
3d6b 04				db 3 + 1 
3d6c .. 00			db "MAX",0              
3d70				endm 
# End of macro CWHEAD
3d70			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3d70					if DEBUG_FORTH_WORDS_KEY 
3d70						DMARK "MAX" 
3d70 f5				push af  
3d71 3a 85 3d			ld a, (.dmark)  
3d74 32 a0 fd			ld (debug_mark),a  
3d77 3a 86 3d			ld a, (.dmark+1)  
3d7a 32 a1 fd			ld (debug_mark+1),a  
3d7d 3a 87 3d			ld a, (.dmark+2)  
3d80 32 a2 fd			ld (debug_mark+2),a  
3d83 18 03			jr .pastdmark  
3d85 ..			.dmark: db "MAX"  
3d88 f1			.pastdmark: pop af  
3d89			endm  
# End of macro DMARK
3d89						CALLMONITOR 
3d89 cd aa fd			call debug_vector  
3d8c				endm  
# End of macro CALLMONITOR
3d8c					endif 
3d8c					; get u2 
3d8c			 
3d8c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d8c cd 4d 22			call macro_dsp_valuehl 
3d8f				endm 
# End of macro FORTH_DSP_VALUEHL
3d8f			 
3d8f e5					push hl   ; u2 
3d90			 
3d90					; destroy value TOS 
3d90			 
3d90					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d90 cd 05 23			call macro_forth_dsp_pop 
3d93				endm 
# End of macro FORTH_DSP_POP
3d93			 
3d93					; get u1 
3d93			 
3d93					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d93 cd 4d 22			call macro_dsp_valuehl 
3d96				endm 
# End of macro FORTH_DSP_VALUEHL
3d96			 
3d96 e5					push hl  ; u1 
3d97			 
3d97					; destroy value TOS 
3d97			 
3d97					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d97 cd 05 23			call macro_forth_dsp_pop 
3d9a				endm 
# End of macro FORTH_DSP_POP
3d9a			 
3d9a b7			 or a      ;clear carry flag 
3d9b e1			  pop hl    ; u1 
3d9c d1			  pop de    ; u2 
3d9d e5				push hl   ; saved in case hl is lowest 
3d9e ed 52		  sbc hl,de 
3da0 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3da2			 
3da2 e1				pop hl 
3da3					if DEBUG_FORTH_WORDS 
3da3						DMARK "MAX" 
3da3 f5				push af  
3da4 3a b8 3d			ld a, (.dmark)  
3da7 32 a0 fd			ld (debug_mark),a  
3daa 3a b9 3d			ld a, (.dmark+1)  
3dad 32 a1 fd			ld (debug_mark+1),a  
3db0 3a ba 3d			ld a, (.dmark+2)  
3db3 32 a2 fd			ld (debug_mark+2),a  
3db6 18 03			jr .pastdmark  
3db8 ..			.dmark: db "MAX"  
3dbb f1			.pastdmark: pop af  
3dbc			endm  
# End of macro DMARK
3dbc						CALLMONITOR 
3dbc cd aa fd			call debug_vector  
3dbf				endm  
# End of macro CALLMONITOR
3dbf					endif 
3dbf cd 48 20				call forth_push_numhl 
3dc2			 
3dc2				       NEXTW 
3dc2 c3 39 24			jp macro_next 
3dc5				endm 
# End of macro NEXTW
3dc5			 
3dc5			.maxcont:  
3dc5 c1				pop bc   ; tidy up 
3dc6 eb				ex de , hl  
3dc7					if DEBUG_FORTH_WORDS 
3dc7						DMARK "MA1" 
3dc7 f5				push af  
3dc8 3a dc 3d			ld a, (.dmark)  
3dcb 32 a0 fd			ld (debug_mark),a  
3dce 3a dd 3d			ld a, (.dmark+1)  
3dd1 32 a1 fd			ld (debug_mark+1),a  
3dd4 3a de 3d			ld a, (.dmark+2)  
3dd7 32 a2 fd			ld (debug_mark+2),a  
3dda 18 03			jr .pastdmark  
3ddc ..			.dmark: db "MA1"  
3ddf f1			.pastdmark: pop af  
3de0			endm  
# End of macro DMARK
3de0						CALLMONITOR 
3de0 cd aa fd			call debug_vector  
3de3				endm  
# End of macro CALLMONITOR
3de3					endif 
3de3 cd 48 20				call forth_push_numhl 
3de6				       NEXTW 
3de6 c3 39 24			jp macro_next 
3de9				endm 
# End of macro NEXTW
3de9			 
3de9			.RND16: 
3de9				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
3de9 4e				db WORD_SYS_CORE+58             
3dea 18 3e			dw .RND8            
3dec 06				db 5 + 1 
3ded .. 00			db "RND16",0              
3df3				endm 
# End of macro CWHEAD
3df3			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3df3					if DEBUG_FORTH_WORDS_KEY 
3df3						DMARK "R16" 
3df3 f5				push af  
3df4 3a 08 3e			ld a, (.dmark)  
3df7 32 a0 fd			ld (debug_mark),a  
3dfa 3a 09 3e			ld a, (.dmark+1)  
3dfd 32 a1 fd			ld (debug_mark+1),a  
3e00 3a 0a 3e			ld a, (.dmark+2)  
3e03 32 a2 fd			ld (debug_mark+2),a  
3e06 18 03			jr .pastdmark  
3e08 ..			.dmark: db "R16"  
3e0b f1			.pastdmark: pop af  
3e0c			endm  
# End of macro DMARK
3e0c						CALLMONITOR 
3e0c cd aa fd			call debug_vector  
3e0f				endm  
# End of macro CALLMONITOR
3e0f					endif 
3e0f cd 05 0f				call prng16  
3e12 cd 48 20				call forth_push_numhl 
3e15				       NEXTW 
3e15 c3 39 24			jp macro_next 
3e18				endm 
# End of macro NEXTW
3e18			.RND8: 
3e18				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
3e18 60				db WORD_SYS_CORE+76             
3e19 4d 3e			dw .RND            
3e1b 05				db 4 + 1 
3e1c .. 00			db "RND8",0              
3e21				endm 
# End of macro CWHEAD
3e21			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3e21					if DEBUG_FORTH_WORDS_KEY 
3e21						DMARK "RN8" 
3e21 f5				push af  
3e22 3a 36 3e			ld a, (.dmark)  
3e25 32 a0 fd			ld (debug_mark),a  
3e28 3a 37 3e			ld a, (.dmark+1)  
3e2b 32 a1 fd			ld (debug_mark+1),a  
3e2e 3a 38 3e			ld a, (.dmark+2)  
3e31 32 a2 fd			ld (debug_mark+2),a  
3e34 18 03			jr .pastdmark  
3e36 ..			.dmark: db "RN8"  
3e39 f1			.pastdmark: pop af  
3e3a			endm  
# End of macro DMARK
3e3a						CALLMONITOR 
3e3a cd aa fd			call debug_vector  
3e3d				endm  
# End of macro CALLMONITOR
3e3d					endif 
3e3d 2a de fa				ld hl,(xrandc) 
3e40 23					inc hl 
3e41 cd 1f 0f				call xrnd 
3e44 6f					ld l,a	 
3e45 26 00				ld h,0 
3e47 cd 48 20				call forth_push_numhl 
3e4a				       NEXTW 
3e4a c3 39 24			jp macro_next 
3e4d				endm 
# End of macro NEXTW
3e4d			.RND: 
3e4d				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3e4d 60				db WORD_SYS_CORE+76             
3e4e 53 3f			dw .ENDMATHS            
3e50 04				db 3 + 1 
3e51 .. 00			db "RND",0              
3e55				endm 
# End of macro CWHEAD
3e55			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3e55			 
3e55					if DEBUG_FORTH_WORDS_KEY 
3e55						DMARK "RND" 
3e55 f5				push af  
3e56 3a 6a 3e			ld a, (.dmark)  
3e59 32 a0 fd			ld (debug_mark),a  
3e5c 3a 6b 3e			ld a, (.dmark+1)  
3e5f 32 a1 fd			ld (debug_mark+1),a  
3e62 3a 6c 3e			ld a, (.dmark+2)  
3e65 32 a2 fd			ld (debug_mark+2),a  
3e68 18 03			jr .pastdmark  
3e6a ..			.dmark: db "RND"  
3e6d f1			.pastdmark: pop af  
3e6e			endm  
# End of macro DMARK
3e6e						CALLMONITOR 
3e6e cd aa fd			call debug_vector  
3e71				endm  
# End of macro CALLMONITOR
3e71					endif 
3e71					 
3e71					FORTH_DSP_VALUEHL    ; upper range 
3e71 cd 4d 22			call macro_dsp_valuehl 
3e74				endm 
# End of macro FORTH_DSP_VALUEHL
3e74			 
3e74 22 e2 fa				ld (LFSRSeed), hl	 
3e77			 
3e77					if DEBUG_FORTH_WORDS 
3e77						DMARK "RN1" 
3e77 f5				push af  
3e78 3a 8c 3e			ld a, (.dmark)  
3e7b 32 a0 fd			ld (debug_mark),a  
3e7e 3a 8d 3e			ld a, (.dmark+1)  
3e81 32 a1 fd			ld (debug_mark+1),a  
3e84 3a 8e 3e			ld a, (.dmark+2)  
3e87 32 a2 fd			ld (debug_mark+2),a  
3e8a 18 03			jr .pastdmark  
3e8c ..			.dmark: db "RN1"  
3e8f f1			.pastdmark: pop af  
3e90			endm  
# End of macro DMARK
3e90						CALLMONITOR 
3e90 cd aa fd			call debug_vector  
3e93				endm  
# End of macro CALLMONITOR
3e93					endif 
3e93					FORTH_DSP_POP 
3e93 cd 05 23			call macro_forth_dsp_pop 
3e96				endm 
# End of macro FORTH_DSP_POP
3e96			 
3e96					FORTH_DSP_VALUEHL    ; low range 
3e96 cd 4d 22			call macro_dsp_valuehl 
3e99				endm 
# End of macro FORTH_DSP_VALUEHL
3e99			 
3e99					if DEBUG_FORTH_WORDS 
3e99						DMARK "RN2" 
3e99 f5				push af  
3e9a 3a ae 3e			ld a, (.dmark)  
3e9d 32 a0 fd			ld (debug_mark),a  
3ea0 3a af 3e			ld a, (.dmark+1)  
3ea3 32 a1 fd			ld (debug_mark+1),a  
3ea6 3a b0 3e			ld a, (.dmark+2)  
3ea9 32 a2 fd			ld (debug_mark+2),a  
3eac 18 03			jr .pastdmark  
3eae ..			.dmark: db "RN2"  
3eb1 f1			.pastdmark: pop af  
3eb2			endm  
# End of macro DMARK
3eb2						CALLMONITOR 
3eb2 cd aa fd			call debug_vector  
3eb5				endm  
# End of macro CALLMONITOR
3eb5					endif 
3eb5 22 e4 fa				ld (LFSRSeed+2), hl 
3eb8			 
3eb8					FORTH_DSP_POP 
3eb8 cd 05 23			call macro_forth_dsp_pop 
3ebb				endm 
# End of macro FORTH_DSP_POP
3ebb			 
3ebb e5					push hl 
3ebc			 
3ebc e1			.inrange:	pop hl 
3ebd cd 05 0f				call prng16  
3ec0					if DEBUG_FORTH_WORDS 
3ec0						DMARK "RN3" 
3ec0 f5				push af  
3ec1 3a d5 3e			ld a, (.dmark)  
3ec4 32 a0 fd			ld (debug_mark),a  
3ec7 3a d6 3e			ld a, (.dmark+1)  
3eca 32 a1 fd			ld (debug_mark+1),a  
3ecd 3a d7 3e			ld a, (.dmark+2)  
3ed0 32 a2 fd			ld (debug_mark+2),a  
3ed3 18 03			jr .pastdmark  
3ed5 ..			.dmark: db "RN3"  
3ed8 f1			.pastdmark: pop af  
3ed9			endm  
# End of macro DMARK
3ed9						CALLMONITOR 
3ed9 cd aa fd			call debug_vector  
3edc				endm  
# End of macro CALLMONITOR
3edc					endif 
3edc					 
3edc					; if the range is 8bit knock out the high byte 
3edc			 
3edc ed 5b e2 fa			ld de, (LFSRSeed)     ; check high level 
3ee0			 
3ee0 3e 00				ld a, 0 
3ee2 ba					cp d  
3ee3 20 1e				jr nz, .hirange 
3ee5 26 00				ld h, 0   ; knock it down to 8bit 
3ee7			 
3ee7					if DEBUG_FORTH_WORDS 
3ee7						DMARK "RNk" 
3ee7 f5				push af  
3ee8 3a fc 3e			ld a, (.dmark)  
3eeb 32 a0 fd			ld (debug_mark),a  
3eee 3a fd 3e			ld a, (.dmark+1)  
3ef1 32 a1 fd			ld (debug_mark+1),a  
3ef4 3a fe 3e			ld a, (.dmark+2)  
3ef7 32 a2 fd			ld (debug_mark+2),a  
3efa 18 03			jr .pastdmark  
3efc ..			.dmark: db "RNk"  
3eff f1			.pastdmark: pop af  
3f00			endm  
# End of macro DMARK
3f00						CALLMONITOR 
3f00 cd aa fd			call debug_vector  
3f03				endm  
# End of macro CALLMONITOR
3f03					endif 
3f03			.hirange:   
3f03 e5					push hl  
3f04 b7					or a  
3f05 ed 52		                sbc hl, de 
3f07			 
3f07					;call cmp16 
3f07			 
3f07 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
3f09 e1					pop hl 
3f0a e5					push hl 
3f0b			 
3f0b					if DEBUG_FORTH_WORDS 
3f0b						DMARK "RN4" 
3f0b f5				push af  
3f0c 3a 20 3f			ld a, (.dmark)  
3f0f 32 a0 fd			ld (debug_mark),a  
3f12 3a 21 3f			ld a, (.dmark+1)  
3f15 32 a1 fd			ld (debug_mark+1),a  
3f18 3a 22 3f			ld a, (.dmark+2)  
3f1b 32 a2 fd			ld (debug_mark+2),a  
3f1e 18 03			jr .pastdmark  
3f20 ..			.dmark: db "RN4"  
3f23 f1			.pastdmark: pop af  
3f24			endm  
# End of macro DMARK
3f24						CALLMONITOR 
3f24 cd aa fd			call debug_vector  
3f27				endm  
# End of macro CALLMONITOR
3f27					endif 
3f27 ed 5b e4 fa			ld de, (LFSRSeed+2)   ; check low range 
3f2b					;call cmp16 
3f2b				 
3f2b b7					or a  
3f2c ed 52		                sbc hl, de 
3f2e 38 8c				jr c, .inrange 
3f30			 
3f30 e1					pop hl 
3f31					 
3f31					if DEBUG_FORTH_WORDS 
3f31						DMARK "RNd" 
3f31 f5				push af  
3f32 3a 46 3f			ld a, (.dmark)  
3f35 32 a0 fd			ld (debug_mark),a  
3f38 3a 47 3f			ld a, (.dmark+1)  
3f3b 32 a1 fd			ld (debug_mark+1),a  
3f3e 3a 48 3f			ld a, (.dmark+2)  
3f41 32 a2 fd			ld (debug_mark+2),a  
3f44 18 03			jr .pastdmark  
3f46 ..			.dmark: db "RNd"  
3f49 f1			.pastdmark: pop af  
3f4a			endm  
# End of macro DMARK
3f4a						CALLMONITOR 
3f4a cd aa fd			call debug_vector  
3f4d				endm  
# End of macro CALLMONITOR
3f4d					endif 
3f4d			 
3f4d			 
3f4d cd 48 20				call forth_push_numhl 
3f50				       NEXTW 
3f50 c3 39 24			jp macro_next 
3f53				endm 
# End of macro NEXTW
3f53			 
3f53			.ENDMATHS: 
3f53			 
3f53			; eof 
3f53			 
# End of file forth_words_maths.asm
3f53			include "forth_words_display.asm" 
3f53			 
3f53			; | ## Display Words 
3f53			 
3f53			.ACT: 
3f53			 
3f53				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
3f53 62				db WORD_SYS_CORE+78             
3f54 9f 3f			dw .INFO            
3f56 07				db 6 + 1 
3f57 .. 00			db "ACTIVE",0              
3f5e				endm 
# End of macro CWHEAD
3f5e			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
3f5e			;  
3f5e			; | | To display a pulsing activity indicator in a processing loop do this... 
3f5e			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
3f5e			 
3f5e					if DEBUG_FORTH_WORDS_KEY 
3f5e						DMARK "ACT" 
3f5e f5				push af  
3f5f 3a 73 3f			ld a, (.dmark)  
3f62 32 a0 fd			ld (debug_mark),a  
3f65 3a 74 3f			ld a, (.dmark+1)  
3f68 32 a1 fd			ld (debug_mark+1),a  
3f6b 3a 75 3f			ld a, (.dmark+2)  
3f6e 32 a2 fd			ld (debug_mark+2),a  
3f71 18 03			jr .pastdmark  
3f73 ..			.dmark: db "ACT"  
3f76 f1			.pastdmark: pop af  
3f77			endm  
# End of macro DMARK
3f77						CALLMONITOR 
3f77 cd aa fd			call debug_vector  
3f7a				endm  
# End of macro CALLMONITOR
3f7a					endif 
3f7a cd 01 0d				call active 
3f7d					if DEBUG_FORTH_WORDS 
3f7d						DMARK "ACp" 
3f7d f5				push af  
3f7e 3a 92 3f			ld a, (.dmark)  
3f81 32 a0 fd			ld (debug_mark),a  
3f84 3a 93 3f			ld a, (.dmark+1)  
3f87 32 a1 fd			ld (debug_mark+1),a  
3f8a 3a 94 3f			ld a, (.dmark+2)  
3f8d 32 a2 fd			ld (debug_mark+2),a  
3f90 18 03			jr .pastdmark  
3f92 ..			.dmark: db "ACp"  
3f95 f1			.pastdmark: pop af  
3f96			endm  
# End of macro DMARK
3f96						CALLMONITOR 
3f96 cd aa fd			call debug_vector  
3f99				endm  
# End of macro CALLMONITOR
3f99					endif 
3f99 cd b6 20				call forth_push_str 
3f9c			 
3f9c					NEXTW 
3f9c c3 39 24			jp macro_next 
3f9f				endm 
# End of macro NEXTW
3f9f			.INFO: 
3f9f			 
3f9f				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3f9f 62				db WORD_SYS_CORE+78             
3fa0 bc 3f			dw .ATP            
3fa2 05				db 4 + 1 
3fa3 .. 00			db "INFO",0              
3fa8				endm 
# End of macro CWHEAD
3fa8			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
3fa8					FORTH_DSP_VALUEHL 
3fa8 cd 4d 22			call macro_dsp_valuehl 
3fab				endm 
# End of macro FORTH_DSP_VALUEHL
3fab			 
3fab					FORTH_DSP_POP 
3fab cd 05 23			call macro_forth_dsp_pop 
3fae				endm 
# End of macro FORTH_DSP_POP
3fae			 
3fae e5					push hl 
3faf			 
3faf					FORTH_DSP_VALUEHL 
3faf cd 4d 22			call macro_dsp_valuehl 
3fb2				endm 
# End of macro FORTH_DSP_VALUEHL
3fb2			 
3fb2					FORTH_DSP_POP 
3fb2 cd 05 23			call macro_forth_dsp_pop 
3fb5				endm 
# End of macro FORTH_DSP_POP
3fb5			 
3fb5 d1					pop de 
3fb6			 
3fb6 cd 3b 0d				call info_panel 
3fb9			 
3fb9			 
3fb9					NEXTW 
3fb9 c3 39 24			jp macro_next 
3fbc				endm 
# End of macro NEXTW
3fbc			.ATP: 
3fbc				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3fbc 62				db WORD_SYS_CORE+78             
3fbd 33 40			dw .FB            
3fbf 04				db 3 + 1 
3fc0 .. 00			db "AT?",0              
3fc4				endm 
# End of macro CWHEAD
3fc4			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
3fc4					if DEBUG_FORTH_WORDS_KEY 
3fc4						DMARK "AT?" 
3fc4 f5				push af  
3fc5 3a d9 3f			ld a, (.dmark)  
3fc8 32 a0 fd			ld (debug_mark),a  
3fcb 3a da 3f			ld a, (.dmark+1)  
3fce 32 a1 fd			ld (debug_mark+1),a  
3fd1 3a db 3f			ld a, (.dmark+2)  
3fd4 32 a2 fd			ld (debug_mark+2),a  
3fd7 18 03			jr .pastdmark  
3fd9 ..			.dmark: db "AT?"  
3fdc f1			.pastdmark: pop af  
3fdd			endm  
# End of macro DMARK
3fdd						CALLMONITOR 
3fdd cd aa fd			call debug_vector  
3fe0				endm  
# End of macro CALLMONITOR
3fe0					endif 
3fe0 3a 93 f9				ld a, (f_cursor_ptr) 
3fe3			 
3fe3			if DEBUG_FORTH_WORDS 
3fe3				DMARK "AT?" 
3fe3 f5				push af  
3fe4 3a f8 3f			ld a, (.dmark)  
3fe7 32 a0 fd			ld (debug_mark),a  
3fea 3a f9 3f			ld a, (.dmark+1)  
3fed 32 a1 fd			ld (debug_mark+1),a  
3ff0 3a fa 3f			ld a, (.dmark+2)  
3ff3 32 a2 fd			ld (debug_mark+2),a  
3ff6 18 03			jr .pastdmark  
3ff8 ..			.dmark: db "AT?"  
3ffb f1			.pastdmark: pop af  
3ffc			endm  
# End of macro DMARK
3ffc				CALLMONITOR 
3ffc cd aa fd			call debug_vector  
3fff				endm  
# End of macro CALLMONITOR
3fff			endif	 
3fff					; count the number of rows 
3fff			 
3fff 06 00				ld b, 0 
4001 4f			.atpr:		ld c, a    ; save in case we go below zero 
4002 d6 28				sub display_cols 
4004 f2 0a 40				jp p, .atprunder 
4007 04					inc b 
4008 18 f7				jr .atpr 
400a			.atprunder:	 
400a			if DEBUG_FORTH_WORDS 
400a				DMARK "A?2" 
400a f5				push af  
400b 3a 1f 40			ld a, (.dmark)  
400e 32 a0 fd			ld (debug_mark),a  
4011 3a 20 40			ld a, (.dmark+1)  
4014 32 a1 fd			ld (debug_mark+1),a  
4017 3a 21 40			ld a, (.dmark+2)  
401a 32 a2 fd			ld (debug_mark+2),a  
401d 18 03			jr .pastdmark  
401f ..			.dmark: db "A?2"  
4022 f1			.pastdmark: pop af  
4023			endm  
# End of macro DMARK
4023				CALLMONITOR 
4023 cd aa fd			call debug_vector  
4026				endm  
# End of macro CALLMONITOR
4026			endif	 
4026 26 00				ld h, 0 
4028 69					ld l, c 
4029 cd 48 20				call forth_push_numhl 
402c 68					ld l, b  
402d cd 48 20				call forth_push_numhl 
4030			 
4030			 
4030				NEXTW 
4030 c3 39 24			jp macro_next 
4033				endm 
# End of macro NEXTW
4033			 
4033			.FB: 
4033				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
4033 1b				db WORD_SYS_CORE+7             
4034 81 40			dw .EMIT            
4036 03				db 2 + 1 
4037 .. 00			db "FB",0              
403a				endm 
# End of macro CWHEAD
403a			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
403a			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
403a			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
403a			; | | If automatic display is off then updates will not be shown until DRAW is used. 
403a					if DEBUG_FORTH_WORDS_KEY 
403a						DMARK "FB." 
403a f5				push af  
403b 3a 4f 40			ld a, (.dmark)  
403e 32 a0 fd			ld (debug_mark),a  
4041 3a 50 40			ld a, (.dmark+1)  
4044 32 a1 fd			ld (debug_mark+1),a  
4047 3a 51 40			ld a, (.dmark+2)  
404a 32 a2 fd			ld (debug_mark+2),a  
404d 18 03			jr .pastdmark  
404f ..			.dmark: db "FB."  
4052 f1			.pastdmark: pop af  
4053			endm  
# End of macro DMARK
4053						CALLMONITOR 
4053 cd aa fd			call debug_vector  
4056				endm  
# End of macro CALLMONITOR
4056					endif 
4056			 
4056					FORTH_DSP_VALUEHL 
4056 cd 4d 22			call macro_dsp_valuehl 
4059				endm 
# End of macro FORTH_DSP_VALUEHL
4059			 
4059 7d					ld a, l 
405a fe 01				cp 1 
405c 20 05				jr nz, .fbn1 
405e 21 45 fc				ld hl, display_fb1 
4061 18 15				jr .fbset 
4063 fe 02		.fbn1:		cp 2 
4065 20 05				jr nz, .fbn2 
4067 21 03 fb				ld hl, display_fb2 
406a 18 0c				jr .fbset 
406c fe 03		.fbn2:		cp 3 
406e 20 05				jr nz, .fbn3 
4070 21 a4 fb				ld hl, display_fb3 
4073 18 03				jr .fbset 
4075			.fbn3:		 ; if invalid number select first 
4075 21 45 fc				ld hl, display_fb1 
4078 22 01 fb		.fbset:		ld (display_fb_active), hl 
407b			 
407b					FORTH_DSP_POP 
407b cd 05 23			call macro_forth_dsp_pop 
407e				endm 
# End of macro FORTH_DSP_POP
407e			 
407e					NEXTW 
407e c3 39 24			jp macro_next 
4081				endm 
# End of macro NEXTW
4081			 
4081			 
4081			.EMIT: 
4081				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
4081 1b				db WORD_SYS_CORE+7             
4082 d2 40			dw .DOTH            
4084 05				db 4 + 1 
4085 .. 00			db "EMIT",0              
408a				endm 
# End of macro CWHEAD
408a			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
408a					; get value off TOS and display it 
408a			 
408a					if DEBUG_FORTH_WORDS_KEY 
408a						DMARK "EMT" 
408a f5				push af  
408b 3a 9f 40			ld a, (.dmark)  
408e 32 a0 fd			ld (debug_mark),a  
4091 3a a0 40			ld a, (.dmark+1)  
4094 32 a1 fd			ld (debug_mark+1),a  
4097 3a a1 40			ld a, (.dmark+2)  
409a 32 a2 fd			ld (debug_mark+2),a  
409d 18 03			jr .pastdmark  
409f ..			.dmark: db "EMT"  
40a2 f1			.pastdmark: pop af  
40a3			endm  
# End of macro DMARK
40a3						CALLMONITOR 
40a3 cd aa fd			call debug_vector  
40a6				endm  
# End of macro CALLMONITOR
40a6					endif 
40a6			 
40a6					FORTH_DSP_VALUEHL 
40a6 cd 4d 22			call macro_dsp_valuehl 
40a9				endm 
# End of macro FORTH_DSP_VALUEHL
40a9			 
40a9 7d					ld a,l 
40aa			 
40aa					; TODO write to display 
40aa			 
40aa 32 f4 f2				ld (os_input), a 
40ad 3e 00				ld a, 0 
40af 32 f5 f2				ld (os_input+1), a 
40b2					 
40b2 3a 93 f9				ld a, (f_cursor_ptr) 
40b5 11 f4 f2				ld de, os_input 
40b8 cd bd 0d				call str_at_display 
40bb			 
40bb			 
40bb 3a 71 f9				ld a,(cli_autodisplay) 
40be fe 00				cp 0 
40c0 28 03				jr z, .enoupdate 
40c2 cd cd 0d						call update_display 
40c5					.enoupdate: 
40c5			 
40c5 3a 93 f9				ld a, (f_cursor_ptr) 
40c8 3c					inc a 
40c9 32 93 f9				ld (f_cursor_ptr), a   ; save new pos 
40cc			 
40cc			 
40cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
40cc cd 05 23			call macro_forth_dsp_pop 
40cf				endm 
# End of macro FORTH_DSP_POP
40cf			  
40cf			 
40cf					NEXTW 
40cf c3 39 24			jp macro_next 
40d2				endm 
# End of macro NEXTW
40d2			.DOTH: 
40d2				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
40d2 1c				db WORD_SYS_CORE+8             
40d3 02 41			dw .DOTF            
40d5 03				db 2 + 1 
40d6 .. 00			db ".-",0              
40d9				endm 
# End of macro CWHEAD
40d9			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
40d9					; get value off TOS and display it 
40d9					if DEBUG_FORTH_WORDS_KEY 
40d9						DMARK "DTD" 
40d9 f5				push af  
40da 3a ee 40			ld a, (.dmark)  
40dd 32 a0 fd			ld (debug_mark),a  
40e0 3a ef 40			ld a, (.dmark+1)  
40e3 32 a1 fd			ld (debug_mark+1),a  
40e6 3a f0 40			ld a, (.dmark+2)  
40e9 32 a2 fd			ld (debug_mark+2),a  
40ec 18 03			jr .pastdmark  
40ee ..			.dmark: db "DTD"  
40f1 f1			.pastdmark: pop af  
40f2			endm  
# End of macro DMARK
40f2						CALLMONITOR 
40f2 cd aa fd			call debug_vector  
40f5				endm  
# End of macro CALLMONITOR
40f5					endif 
40f5 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
40f7 3e 00			ld a, 0 
40f9 32 72 f9			ld (cli_mvdot), a 
40fc c3 59 41			jp .dotgo 
40ff				NEXTW 
40ff c3 39 24			jp macro_next 
4102				endm 
# End of macro NEXTW
4102			.DOTF: 
4102				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
4102 1c				db WORD_SYS_CORE+8             
4103 30 41			dw .DOT            
4105 03				db 2 + 1 
4106 .. 00			db ".>",0              
4109				endm 
# End of macro CWHEAD
4109			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
4109					; get value off TOS and display it 
4109			        ; TODO BUG adds extra spaces 
4109			        ; TODO BUG handle numerics? 
4109					if DEBUG_FORTH_WORDS_KEY 
4109						DMARK "DTC" 
4109 f5				push af  
410a 3a 1e 41			ld a, (.dmark)  
410d 32 a0 fd			ld (debug_mark),a  
4110 3a 1f 41			ld a, (.dmark+1)  
4113 32 a1 fd			ld (debug_mark+1),a  
4116 3a 20 41			ld a, (.dmark+2)  
4119 32 a2 fd			ld (debug_mark+2),a  
411c 18 03			jr .pastdmark  
411e ..			.dmark: db "DTC"  
4121 f1			.pastdmark: pop af  
4122			endm  
# End of macro DMARK
4122						CALLMONITOR 
4122 cd aa fd			call debug_vector  
4125				endm  
# End of macro CALLMONITOR
4125					endif 
4125 3e 01			ld a, 1 
4127 32 72 f9			ld (cli_mvdot), a 
412a c3 59 41			jp .dotgo 
412d				NEXTW 
412d c3 39 24			jp macro_next 
4130				endm 
# End of macro NEXTW
4130			 
4130			.DOT: 
4130				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
4130 1c				db WORD_SYS_CORE+8             
4131 0c 43			dw .CLS            
4133 02				db 1 + 1 
4134 .. 00			db ".",0              
4136				endm 
# End of macro CWHEAD
4136			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
4136					; get value off TOS and display it 
4136			 
4136					if DEBUG_FORTH_WORDS_KEY 
4136						DMARK "DOT" 
4136 f5				push af  
4137 3a 4b 41			ld a, (.dmark)  
413a 32 a0 fd			ld (debug_mark),a  
413d 3a 4c 41			ld a, (.dmark+1)  
4140 32 a1 fd			ld (debug_mark+1),a  
4143 3a 4d 41			ld a, (.dmark+2)  
4146 32 a2 fd			ld (debug_mark+2),a  
4149 18 03			jr .pastdmark  
414b ..			.dmark: db "DOT"  
414e f1			.pastdmark: pop af  
414f			endm  
# End of macro DMARK
414f						CALLMONITOR 
414f cd aa fd			call debug_vector  
4152				endm  
# End of macro CALLMONITOR
4152					endif 
4152 3e 00			ld a, 0 
4154 32 72 f9			ld (cli_mvdot), a 
4157 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
4159				 
4159			 
4159			.dotgo: 
4159			 
4159			; move up type to on stack for parserv5 
4159					FORTH_DSP 
4159 cd 13 22			call macro_forth_dsp 
415c				endm 
# End of macro FORTH_DSP
415c				;FORTH_DSP_VALUE  
415c			 
415c			if DEBUG_FORTH_DOT 
415c				DMARK "DOT" 
415c f5				push af  
415d 3a 71 41			ld a, (.dmark)  
4160 32 a0 fd			ld (debug_mark),a  
4163 3a 72 41			ld a, (.dmark+1)  
4166 32 a1 fd			ld (debug_mark+1),a  
4169 3a 73 41			ld a, (.dmark+2)  
416c 32 a2 fd			ld (debug_mark+2),a  
416f 18 03			jr .pastdmark  
4171 ..			.dmark: db "DOT"  
4174 f1			.pastdmark: pop af  
4175			endm  
# End of macro DMARK
4175				CALLMONITOR 
4175 cd aa fd			call debug_vector  
4178				endm  
# End of macro CALLMONITOR
4178			endif	 
4178			;		.print: 
4178			 
4178 7e				ld a,(hl)  ; work out what type of value is on the TOS 
4179 23				inc hl   ; position to the actual value 
417a fe 01			cp DS_TYPE_STR 
417c 20 06			jr nz, .dotnum1  
417e			 
417e			; display string 
417e				FORTH_DSP_VALUE  
417e cd 36 22			call macro_forth_dsp_value 
4181				endm 
# End of macro FORTH_DSP_VALUE
4181 eb				ex de,hl 
4182 18 49			jr .dotwrite 
4184			 
4184			.dotnum1: 
4184 fe 02			cp DS_TYPE_INUM 
4186 20 44			jr nz, .dotflot 
4188			 
4188			 
4188			; display number 
4188			 
4188			;	push hl 
4188			;	call clear_display 
4188			;	pop hl 
4188			 
4188 5e				ld e, (hl) 
4189 23				inc hl 
418a 56				ld d, (hl) 
418b 21 f6 f0			ld hl, scratch 
418e			if DEBUG_FORTH_DOT 
418e				DMARK "DT1" 
418e f5				push af  
418f 3a a3 41			ld a, (.dmark)  
4192 32 a0 fd			ld (debug_mark),a  
4195 3a a4 41			ld a, (.dmark+1)  
4198 32 a1 fd			ld (debug_mark+1),a  
419b 3a a5 41			ld a, (.dmark+2)  
419e 32 a2 fd			ld (debug_mark+2),a  
41a1 18 03			jr .pastdmark  
41a3 ..			.dmark: db "DT1"  
41a6 f1			.pastdmark: pop af  
41a7			endm  
# End of macro DMARK
41a7				CALLMONITOR 
41a7 cd aa fd			call debug_vector  
41aa				endm  
# End of macro CALLMONITOR
41aa			endif	 
41aa			 
41aa cd f3 12			call uitoa_16 
41ad eb				ex de,hl 
41ae			 
41ae			if DEBUG_FORTH_DOT 
41ae				DMARK "DT2" 
41ae f5				push af  
41af 3a c3 41			ld a, (.dmark)  
41b2 32 a0 fd			ld (debug_mark),a  
41b5 3a c4 41			ld a, (.dmark+1)  
41b8 32 a1 fd			ld (debug_mark+1),a  
41bb 3a c5 41			ld a, (.dmark+2)  
41be 32 a2 fd			ld (debug_mark+2),a  
41c1 18 03			jr .pastdmark  
41c3 ..			.dmark: db "DT2"  
41c6 f1			.pastdmark: pop af  
41c7			endm  
# End of macro DMARK
41c7				CALLMONITOR 
41c7 cd aa fd			call debug_vector  
41ca				endm  
# End of macro CALLMONITOR
41ca			endif	 
41ca			 
41ca			;	ld de, os_word_scratch 
41ca 18 01			jr .dotwrite 
41cc			 
41cc 00			.dotflot:   nop 
41cd			; TODO print floating point number 
41cd			 
41cd			.dotwrite:		 
41cd			 
41cd					; if c is set then set all '-' to spaces 
41cd					; need to also take into account .>  
41cd			 
41cd 3e 01				ld a, 1 
41cf b9					cp c 
41d0 20 67				jr nz, .nodashswap 
41d2			 
41d2					; DE has the string to write, working with HL 
41d2			 
41d2 06 ff				ld b, 255 
41d4 d5					push de 
41d5 e1					pop hl 
41d6			 
41d6			if DEBUG_FORTH_DOT 
41d6				DMARK "DT-" 
41d6 f5				push af  
41d7 3a eb 41			ld a, (.dmark)  
41da 32 a0 fd			ld (debug_mark),a  
41dd 3a ec 41			ld a, (.dmark+1)  
41e0 32 a1 fd			ld (debug_mark+1),a  
41e3 3a ed 41			ld a, (.dmark+2)  
41e6 32 a2 fd			ld (debug_mark+2),a  
41e9 18 03			jr .pastdmark  
41eb ..			.dmark: db "DT-"  
41ee f1			.pastdmark: pop af  
41ef			endm  
# End of macro DMARK
41ef				CALLMONITOR 
41ef cd aa fd			call debug_vector  
41f2				endm  
# End of macro CALLMONITOR
41f2			endif	 
41f2 7e			.dashscan:	ld a, (hl) 
41f3 fe 00				cp 0 
41f5 28 42				jr z, .nodashswap 
41f7 fe 2d				cp '-' 
41f9 20 03				jr nz, .dashskip 
41fb 3e 20				ld a, ' ' 
41fd 77					ld (hl), a 
41fe 23			.dashskip:	inc hl 
41ff			if DEBUG_FORTH_DOT 
41ff				DMARK "D-2" 
41ff f5				push af  
4200 3a 14 42			ld a, (.dmark)  
4203 32 a0 fd			ld (debug_mark),a  
4206 3a 15 42			ld a, (.dmark+1)  
4209 32 a1 fd			ld (debug_mark+1),a  
420c 3a 16 42			ld a, (.dmark+2)  
420f 32 a2 fd			ld (debug_mark+2),a  
4212 18 03			jr .pastdmark  
4214 ..			.dmark: db "D-2"  
4217 f1			.pastdmark: pop af  
4218			endm  
# End of macro DMARK
4218				CALLMONITOR 
4218 cd aa fd			call debug_vector  
421b				endm  
# End of macro CALLMONITOR
421b			endif	 
421b 10 d5				djnz .dashscan 
421d			 
421d			if DEBUG_FORTH_DOT 
421d				DMARK "D-1" 
421d f5				push af  
421e 3a 32 42			ld a, (.dmark)  
4221 32 a0 fd			ld (debug_mark),a  
4224 3a 33 42			ld a, (.dmark+1)  
4227 32 a1 fd			ld (debug_mark+1),a  
422a 3a 34 42			ld a, (.dmark+2)  
422d 32 a2 fd			ld (debug_mark+2),a  
4230 18 03			jr .pastdmark  
4232 ..			.dmark: db "D-1"  
4235 f1			.pastdmark: pop af  
4236			endm  
# End of macro DMARK
4236				CALLMONITOR 
4236 cd aa fd			call debug_vector  
4239				endm  
# End of macro CALLMONITOR
4239			endif	 
4239			 
4239			.nodashswap: 
4239			 
4239			if DEBUG_FORTH_DOT 
4239				DMARK "D-o" 
4239 f5				push af  
423a 3a 4e 42			ld a, (.dmark)  
423d 32 a0 fd			ld (debug_mark),a  
4240 3a 4f 42			ld a, (.dmark+1)  
4243 32 a1 fd			ld (debug_mark+1),a  
4246 3a 50 42			ld a, (.dmark+2)  
4249 32 a2 fd			ld (debug_mark+2),a  
424c 18 03			jr .pastdmark  
424e ..			.dmark: db "D-o"  
4251 f1			.pastdmark: pop af  
4252			endm  
# End of macro DMARK
4252				CALLMONITOR 
4252 cd aa fd			call debug_vector  
4255				endm  
# End of macro CALLMONITOR
4255			endif	 
4255			 
4255 d5					push de   ; save string start in case we need to advance print 
4256			 
4256 3a 93 f9				ld a, (f_cursor_ptr) 
4259 cd bd 0d				call str_at_display 
425c 3a 71 f9				ld a,(cli_autodisplay) 
425f fe 00				cp 0 
4261 28 03				jr z, .noupdate 
4263 cd cd 0d						call update_display 
4266					.noupdate: 
4266			 
4266			 
4266					; see if we need to advance the print position 
4266			 
4266 e1					pop hl   ; get back string 
4267			;		ex de,hl 
4267			 
4267 3a 72 f9				ld a, (cli_mvdot) 
426a			if DEBUG_FORTH_DOT 
426a			;		ld e,a 
426a				DMARK "D>1" 
426a f5				push af  
426b 3a 7f 42			ld a, (.dmark)  
426e 32 a0 fd			ld (debug_mark),a  
4271 3a 80 42			ld a, (.dmark+1)  
4274 32 a1 fd			ld (debug_mark+1),a  
4277 3a 81 42			ld a, (.dmark+2)  
427a 32 a2 fd			ld (debug_mark+2),a  
427d 18 03			jr .pastdmark  
427f ..			.dmark: db "D>1"  
4282 f1			.pastdmark: pop af  
4283			endm  
# End of macro DMARK
4283				CALLMONITOR 
4283 cd aa fd			call debug_vector  
4286				endm  
# End of macro CALLMONITOR
4286			endif	 
4286 fe 00				cp 0 
4288 28 44				jr z, .noadv 
428a					; yes, lets advance the print position 
428a 3e 00				ld a, 0 
428c cd 4f 13				call strlent 
428f			if DEBUG_FORTH_DOT 
428f				DMARK "D-?" 
428f f5				push af  
4290 3a a4 42			ld a, (.dmark)  
4293 32 a0 fd			ld (debug_mark),a  
4296 3a a5 42			ld a, (.dmark+1)  
4299 32 a1 fd			ld (debug_mark+1),a  
429c 3a a6 42			ld a, (.dmark+2)  
429f 32 a2 fd			ld (debug_mark+2),a  
42a2 18 03			jr .pastdmark  
42a4 ..			.dmark: db "D-?"  
42a7 f1			.pastdmark: pop af  
42a8			endm  
# End of macro DMARK
42a8				CALLMONITOR 
42a8 cd aa fd			call debug_vector  
42ab				endm  
# End of macro CALLMONITOR
42ab			endif	 
42ab 3a 93 f9				ld a, (f_cursor_ptr) 
42ae 85					add a,l 
42af					;call addatohl 
42af					;ld a, l 
42af 32 93 f9				ld (f_cursor_ptr), a   ; save new pos 
42b2			 
42b2			if DEBUG_FORTH_DOT 
42b2				DMARK "D->" 
42b2 f5				push af  
42b3 3a c7 42			ld a, (.dmark)  
42b6 32 a0 fd			ld (debug_mark),a  
42b9 3a c8 42			ld a, (.dmark+1)  
42bc 32 a1 fd			ld (debug_mark+1),a  
42bf 3a c9 42			ld a, (.dmark+2)  
42c2 32 a2 fd			ld (debug_mark+2),a  
42c5 18 03			jr .pastdmark  
42c7 ..			.dmark: db "D->"  
42ca f1			.pastdmark: pop af  
42cb			endm  
# End of macro DMARK
42cb				CALLMONITOR 
42cb cd aa fd			call debug_vector  
42ce				endm  
# End of macro CALLMONITOR
42ce			endif	 
42ce			 
42ce			.noadv:	 
42ce			 
42ce					if DEBUG_FORTH_DOT_WAIT 
42ce							call next_page_prompt 
42ce					endif	 
42ce			; TODO this pop off the stack causes a crash. i dont know why 
42ce			 
42ce			 
42ce			if DEBUG_FORTH_DOT 
42ce				DMARK "DTh" 
42ce f5				push af  
42cf 3a e3 42			ld a, (.dmark)  
42d2 32 a0 fd			ld (debug_mark),a  
42d5 3a e4 42			ld a, (.dmark+1)  
42d8 32 a1 fd			ld (debug_mark+1),a  
42db 3a e5 42			ld a, (.dmark+2)  
42de 32 a2 fd			ld (debug_mark+2),a  
42e1 18 03			jr .pastdmark  
42e3 ..			.dmark: db "DTh"  
42e6 f1			.pastdmark: pop af  
42e7			endm  
# End of macro DMARK
42e7				CALLMONITOR 
42e7 cd aa fd			call debug_vector  
42ea				endm  
# End of macro CALLMONITOR
42ea			endif	 
42ea			 
42ea					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
42ea cd 05 23			call macro_forth_dsp_pop 
42ed				endm 
# End of macro FORTH_DSP_POP
42ed			 
42ed			if DEBUG_FORTH_DOT 
42ed				DMARK "DTi" 
42ed f5				push af  
42ee 3a 02 43			ld a, (.dmark)  
42f1 32 a0 fd			ld (debug_mark),a  
42f4 3a 03 43			ld a, (.dmark+1)  
42f7 32 a1 fd			ld (debug_mark+1),a  
42fa 3a 04 43			ld a, (.dmark+2)  
42fd 32 a2 fd			ld (debug_mark+2),a  
4300 18 03			jr .pastdmark  
4302 ..			.dmark: db "DTi"  
4305 f1			.pastdmark: pop af  
4306			endm  
# End of macro DMARK
4306				CALLMONITOR 
4306 cd aa fd			call debug_vector  
4309				endm  
# End of macro CALLMONITOR
4309			endif	 
4309			 
4309			 
4309					NEXTW 
4309 c3 39 24			jp macro_next 
430c				endm 
# End of macro NEXTW
430c			 
430c			.CLS: 
430c				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
430c 35				db WORD_SYS_CORE+33             
430d 39 43			dw .DRAW            
430f 04				db 3 + 1 
4310 .. 00			db "CLS",0              
4314				endm 
# End of macro CWHEAD
4314			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4314					if DEBUG_FORTH_WORDS_KEY 
4314						DMARK "CLS" 
4314 f5				push af  
4315 3a 29 43			ld a, (.dmark)  
4318 32 a0 fd			ld (debug_mark),a  
431b 3a 2a 43			ld a, (.dmark+1)  
431e 32 a1 fd			ld (debug_mark+1),a  
4321 3a 2b 43			ld a, (.dmark+2)  
4324 32 a2 fd			ld (debug_mark+2),a  
4327 18 03			jr .pastdmark  
4329 ..			.dmark: db "CLS"  
432c f1			.pastdmark: pop af  
432d			endm  
# End of macro DMARK
432d						CALLMONITOR 
432d cd aa fd			call debug_vector  
4330				endm  
# End of macro CALLMONITOR
4330					endif 
4330 cd aa 0d				call clear_display 
4333 c3 47 44				jp .home		; and home cursor 
4336					NEXTW 
4336 c3 39 24			jp macro_next 
4339				endm 
# End of macro NEXTW
4339			 
4339			.DRAW: 
4339				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
4339 36				db WORD_SYS_CORE+34             
433a 64 43			dw .DUMP            
433c 05				db 4 + 1 
433d .. 00			db "DRAW",0              
4342				endm 
# End of macro CWHEAD
4342			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
4342					if DEBUG_FORTH_WORDS_KEY 
4342						DMARK "DRW" 
4342 f5				push af  
4343 3a 57 43			ld a, (.dmark)  
4346 32 a0 fd			ld (debug_mark),a  
4349 3a 58 43			ld a, (.dmark+1)  
434c 32 a1 fd			ld (debug_mark+1),a  
434f 3a 59 43			ld a, (.dmark+2)  
4352 32 a2 fd			ld (debug_mark+2),a  
4355 18 03			jr .pastdmark  
4357 ..			.dmark: db "DRW"  
435a f1			.pastdmark: pop af  
435b			endm  
# End of macro DMARK
435b						CALLMONITOR 
435b cd aa fd			call debug_vector  
435e				endm  
# End of macro CALLMONITOR
435e					endif 
435e cd cd 0d				call update_display 
4361					NEXTW 
4361 c3 39 24			jp macro_next 
4364				endm 
# End of macro NEXTW
4364			 
4364			.DUMP: 
4364				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
4364 37				db WORD_SYS_CORE+35             
4365 9c 43			dw .CDUMP            
4367 05				db 4 + 1 
4368 .. 00			db "DUMP",0              
436d				endm 
# End of macro CWHEAD
436d			; | DUMP ( x -- ) With address x display dump   | DONE 
436d			; TODO pop address to use off of the stack 
436d					if DEBUG_FORTH_WORDS_KEY 
436d						DMARK "DUM" 
436d f5				push af  
436e 3a 82 43			ld a, (.dmark)  
4371 32 a0 fd			ld (debug_mark),a  
4374 3a 83 43			ld a, (.dmark+1)  
4377 32 a1 fd			ld (debug_mark+1),a  
437a 3a 84 43			ld a, (.dmark+2)  
437d 32 a2 fd			ld (debug_mark+2),a  
4380 18 03			jr .pastdmark  
4382 ..			.dmark: db "DUM"  
4385 f1			.pastdmark: pop af  
4386			endm  
# End of macro DMARK
4386						CALLMONITOR 
4386 cd aa fd			call debug_vector  
4389				endm  
# End of macro CALLMONITOR
4389					endif 
4389 cd aa 0d				call clear_display 
438c			 
438c					; get address 
438c			 
438c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
438c cd 4d 22			call macro_dsp_valuehl 
438f				endm 
# End of macro FORTH_DSP_VALUEHL
438f				 
438f					; save it for cdump 
438f			 
438f 22 19 f4				ld (os_cur_ptr),hl 
4392			 
4392					; destroy value TOS 
4392			 
4392					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4392 cd 05 23			call macro_forth_dsp_pop 
4395				endm 
# End of macro FORTH_DSP_POP
4395			 
4395 cd c8 1e				call dumpcont	; skip old style of param parsing	 
4398 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
4399					NEXTW 
4399 c3 39 24			jp macro_next 
439c				endm 
# End of macro NEXTW
439c			.CDUMP: 
439c				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
439c 38				db WORD_SYS_CORE+36             
439d cc 43			dw .DAT            
439f 06				db 5 + 1 
43a0 .. 00			db "CDUMP",0              
43a6				endm 
# End of macro CWHEAD
43a6			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
43a6					if DEBUG_FORTH_WORDS_KEY 
43a6						DMARK "CDP" 
43a6 f5				push af  
43a7 3a bb 43			ld a, (.dmark)  
43aa 32 a0 fd			ld (debug_mark),a  
43ad 3a bc 43			ld a, (.dmark+1)  
43b0 32 a1 fd			ld (debug_mark+1),a  
43b3 3a bd 43			ld a, (.dmark+2)  
43b6 32 a2 fd			ld (debug_mark+2),a  
43b9 18 03			jr .pastdmark  
43bb ..			.dmark: db "CDP"  
43be f1			.pastdmark: pop af  
43bf			endm  
# End of macro DMARK
43bf						CALLMONITOR 
43bf cd aa fd			call debug_vector  
43c2				endm  
# End of macro CALLMONITOR
43c2					endif 
43c2 cd aa 0d				call clear_display 
43c5 cd c8 1e				call dumpcont	 
43c8 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
43c9					NEXTW 
43c9 c3 39 24			jp macro_next 
43cc				endm 
# End of macro NEXTW
43cc			 
43cc			 
43cc			 
43cc			 
43cc			.DAT: 
43cc				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
43cc 3d				db WORD_SYS_CORE+41             
43cd 22 44			dw .HOME            
43cf 03				db 2 + 1 
43d0 .. 00			db "AT",0              
43d3				endm 
# End of macro CWHEAD
43d3			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
43d3					if DEBUG_FORTH_WORDS_KEY 
43d3						DMARK "AT." 
43d3 f5				push af  
43d4 3a e8 43			ld a, (.dmark)  
43d7 32 a0 fd			ld (debug_mark),a  
43da 3a e9 43			ld a, (.dmark+1)  
43dd 32 a1 fd			ld (debug_mark+1),a  
43e0 3a ea 43			ld a, (.dmark+2)  
43e3 32 a2 fd			ld (debug_mark+2),a  
43e6 18 03			jr .pastdmark  
43e8 ..			.dmark: db "AT."  
43eb f1			.pastdmark: pop af  
43ec			endm  
# End of macro DMARK
43ec						CALLMONITOR 
43ec cd aa fd			call debug_vector  
43ef				endm  
# End of macro CALLMONITOR
43ef					endif 
43ef					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
43ef cd 4d 22			call macro_dsp_valuehl 
43f2				endm 
# End of macro FORTH_DSP_VALUEHL
43f2			 
43f2			 
43f2					; TODO save cursor row 
43f2 7d					ld a,l 
43f3 fe 02				cp 2 
43f5 20 04				jr nz, .crow3 
43f7 3e 28				ld a, display_row_2 
43f9 18 12				jr .ccol1 
43fb fe 03		.crow3:		cp 3 
43fd 20 04				jr nz, .crow4 
43ff 3e 50				ld a, display_row_3 
4401 18 0a				jr .ccol1 
4403 fe 04		.crow4:		cp 4 
4405 20 04				jr nz, .crow1 
4407 3e 78				ld a, display_row_4 
4409 18 02				jr .ccol1 
440b 3e 00		.crow1:		ld a,display_row_1 
440d f5			.ccol1:		push af			; got row offset 
440e 6f					ld l,a 
440f 26 00				ld h,0 
4411					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4411 cd 05 23			call macro_forth_dsp_pop 
4414				endm 
# End of macro FORTH_DSP_POP
4414					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4414 cd 4d 22			call macro_dsp_valuehl 
4417				endm 
# End of macro FORTH_DSP_VALUEHL
4417					; TODO save cursor col 
4417 f1					pop af 
4418 85					add l		; add col offset 
4419 32 93 f9				ld (f_cursor_ptr), a 
441c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
441c cd 05 23			call macro_forth_dsp_pop 
441f				endm 
# End of macro FORTH_DSP_POP
441f			 
441f					; calculate  
441f			 
441f					NEXTW 
441f c3 39 24			jp macro_next 
4422				endm 
# End of macro NEXTW
4422			 
4422			 
4422			.HOME: 
4422				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
4422 41				db WORD_SYS_CORE+45             
4423 4f 44			dw .CR            
4425 05				db 4 + 1 
4426 .. 00			db "HOME",0              
442b				endm 
# End of macro CWHEAD
442b			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
442b					if DEBUG_FORTH_WORDS_KEY 
442b						DMARK "HOM" 
442b f5				push af  
442c 3a 40 44			ld a, (.dmark)  
442f 32 a0 fd			ld (debug_mark),a  
4432 3a 41 44			ld a, (.dmark+1)  
4435 32 a1 fd			ld (debug_mark+1),a  
4438 3a 42 44			ld a, (.dmark+2)  
443b 32 a2 fd			ld (debug_mark+2),a  
443e 18 03			jr .pastdmark  
4440 ..			.dmark: db "HOM"  
4443 f1			.pastdmark: pop af  
4444			endm  
# End of macro DMARK
4444						CALLMONITOR 
4444 cd aa fd			call debug_vector  
4447				endm  
# End of macro CALLMONITOR
4447					endif 
4447 3e 00		.home:		ld a, 0		; and home cursor 
4449 32 93 f9				ld (f_cursor_ptr), a 
444c					NEXTW 
444c c3 39 24			jp macro_next 
444f				endm 
# End of macro NEXTW
444f			 
444f			 
444f			.CR: 
444f				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
444f 46				db WORD_SYS_CORE+50             
4450 8a 44			dw .SPACE            
4452 03				db 2 + 1 
4453 .. 00			db "CR",0              
4456				endm 
# End of macro CWHEAD
4456			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
4456					if DEBUG_FORTH_WORDS_KEY 
4456						DMARK "CR." 
4456 f5				push af  
4457 3a 6b 44			ld a, (.dmark)  
445a 32 a0 fd			ld (debug_mark),a  
445d 3a 6c 44			ld a, (.dmark+1)  
4460 32 a1 fd			ld (debug_mark+1),a  
4463 3a 6d 44			ld a, (.dmark+2)  
4466 32 a2 fd			ld (debug_mark+2),a  
4469 18 03			jr .pastdmark  
446b ..			.dmark: db "CR."  
446e f1			.pastdmark: pop af  
446f			endm  
# End of macro DMARK
446f						CALLMONITOR 
446f cd aa fd			call debug_vector  
4472				endm  
# End of macro CALLMONITOR
4472					endif 
4472 3e 0d				ld a, 13 
4474 32 f6 f0				ld (scratch),a 
4477 3e 0a				ld a, 10 
4479 32 f7 f0				ld (scratch+1),a 
447c 3e 00				ld a, 0 
447e 32 f8 f0				ld (scratch+2),a 
4481 21 f6 f0				ld hl, scratch 
4484 cd b6 20				call forth_push_str 
4487					 
4487				       NEXTW 
4487 c3 39 24			jp macro_next 
448a				endm 
# End of macro NEXTW
448a			.SPACE: 
448a				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
448a 46				db WORD_SYS_CORE+50             
448b c0 44			dw .SPACES            
448d 03				db 2 + 1 
448e .. 00			db "BL",0              
4491				endm 
# End of macro CWHEAD
4491			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
4491					if DEBUG_FORTH_WORDS_KEY 
4491						DMARK "BL." 
4491 f5				push af  
4492 3a a6 44			ld a, (.dmark)  
4495 32 a0 fd			ld (debug_mark),a  
4498 3a a7 44			ld a, (.dmark+1)  
449b 32 a1 fd			ld (debug_mark+1),a  
449e 3a a8 44			ld a, (.dmark+2)  
44a1 32 a2 fd			ld (debug_mark+2),a  
44a4 18 03			jr .pastdmark  
44a6 ..			.dmark: db "BL."  
44a9 f1			.pastdmark: pop af  
44aa			endm  
# End of macro DMARK
44aa						CALLMONITOR 
44aa cd aa fd			call debug_vector  
44ad				endm  
# End of macro CALLMONITOR
44ad					endif 
44ad 3e 20				ld a, " " 
44af 32 f6 f0				ld (scratch),a 
44b2 3e 00				ld a, 0 
44b4 32 f7 f0				ld (scratch+1),a 
44b7 21 f6 f0				ld hl, scratch 
44ba cd b6 20				call forth_push_str 
44bd					 
44bd				       NEXTW 
44bd c3 39 24			jp macro_next 
44c0				endm 
# End of macro NEXTW
44c0			 
44c0			;.blstr: db " ", 0 
44c0			 
44c0			.SPACES: 
44c0				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
44c0 47				db WORD_SYS_CORE+51             
44c1 5b 45			dw .SCROLL            
44c3 07				db 6 + 1 
44c4 .. 00			db "SPACES",0              
44cb				endm 
# End of macro CWHEAD
44cb			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
44cb					if DEBUG_FORTH_WORDS_KEY 
44cb						DMARK "SPS" 
44cb f5				push af  
44cc 3a e0 44			ld a, (.dmark)  
44cf 32 a0 fd			ld (debug_mark),a  
44d2 3a e1 44			ld a, (.dmark+1)  
44d5 32 a1 fd			ld (debug_mark+1),a  
44d8 3a e2 44			ld a, (.dmark+2)  
44db 32 a2 fd			ld (debug_mark+2),a  
44de 18 03			jr .pastdmark  
44e0 ..			.dmark: db "SPS"  
44e3 f1			.pastdmark: pop af  
44e4			endm  
# End of macro DMARK
44e4						CALLMONITOR 
44e4 cd aa fd			call debug_vector  
44e7				endm  
# End of macro CALLMONITOR
44e7					endif 
44e7			 
44e7			 
44e7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44e7 cd 4d 22			call macro_dsp_valuehl 
44ea				endm 
# End of macro FORTH_DSP_VALUEHL
44ea			 
44ea e5					push hl    ; u 
44eb					if DEBUG_FORTH_WORDS 
44eb						DMARK "SPA" 
44eb f5				push af  
44ec 3a 00 45			ld a, (.dmark)  
44ef 32 a0 fd			ld (debug_mark),a  
44f2 3a 01 45			ld a, (.dmark+1)  
44f5 32 a1 fd			ld (debug_mark+1),a  
44f8 3a 02 45			ld a, (.dmark+2)  
44fb 32 a2 fd			ld (debug_mark+2),a  
44fe 18 03			jr .pastdmark  
4500 ..			.dmark: db "SPA"  
4503 f1			.pastdmark: pop af  
4504			endm  
# End of macro DMARK
4504						CALLMONITOR 
4504 cd aa fd			call debug_vector  
4507				endm  
# End of macro CALLMONITOR
4507					endif 
4507			 
4507					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4507 cd 05 23			call macro_forth_dsp_pop 
450a				endm 
# End of macro FORTH_DSP_POP
450a e1					pop hl 
450b 0e 00				ld c, 0 
450d 45					ld b, l 
450e 21 f6 f0				ld hl, scratch  
4511			 
4511					if DEBUG_FORTH_WORDS 
4511						DMARK "SP2" 
4511 f5				push af  
4512 3a 26 45			ld a, (.dmark)  
4515 32 a0 fd			ld (debug_mark),a  
4518 3a 27 45			ld a, (.dmark+1)  
451b 32 a1 fd			ld (debug_mark+1),a  
451e 3a 28 45			ld a, (.dmark+2)  
4521 32 a2 fd			ld (debug_mark+2),a  
4524 18 03			jr .pastdmark  
4526 ..			.dmark: db "SP2"  
4529 f1			.pastdmark: pop af  
452a			endm  
# End of macro DMARK
452a						CALLMONITOR 
452a cd aa fd			call debug_vector  
452d				endm  
# End of macro CALLMONITOR
452d					endif 
452d 3e 20				ld a, ' ' 
452f			.spaces1:	 
452f 77					ld (hl),a 
4530 23					inc hl 
4531					 
4531 10 fc				djnz .spaces1 
4533 3e 00				ld a,0 
4535 77					ld (hl),a 
4536 21 f6 f0				ld hl, scratch 
4539					if DEBUG_FORTH_WORDS 
4539						DMARK "SP3" 
4539 f5				push af  
453a 3a 4e 45			ld a, (.dmark)  
453d 32 a0 fd			ld (debug_mark),a  
4540 3a 4f 45			ld a, (.dmark+1)  
4543 32 a1 fd			ld (debug_mark+1),a  
4546 3a 50 45			ld a, (.dmark+2)  
4549 32 a2 fd			ld (debug_mark+2),a  
454c 18 03			jr .pastdmark  
454e ..			.dmark: db "SP3"  
4551 f1			.pastdmark: pop af  
4552			endm  
# End of macro DMARK
4552						CALLMONITOR 
4552 cd aa fd			call debug_vector  
4555				endm  
# End of macro CALLMONITOR
4555					endif 
4555 cd b6 20				call forth_push_str 
4558			 
4558				       NEXTW 
4558 c3 39 24			jp macro_next 
455b				endm 
# End of macro NEXTW
455b			 
455b			 
455b			 
455b			.SCROLL: 
455b				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
455b 53				db WORD_SYS_CORE+63             
455c 88 45			dw .SCROLLD            
455e 07				db 6 + 1 
455f .. 00			db "SCROLL",0              
4566				endm 
# End of macro CWHEAD
4566			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
4566					if DEBUG_FORTH_WORDS_KEY 
4566						DMARK "SCR" 
4566 f5				push af  
4567 3a 7b 45			ld a, (.dmark)  
456a 32 a0 fd			ld (debug_mark),a  
456d 3a 7c 45			ld a, (.dmark+1)  
4570 32 a1 fd			ld (debug_mark+1),a  
4573 3a 7d 45			ld a, (.dmark+2)  
4576 32 a2 fd			ld (debug_mark+2),a  
4579 18 03			jr .pastdmark  
457b ..			.dmark: db "SCR"  
457e f1			.pastdmark: pop af  
457f			endm  
# End of macro DMARK
457f						CALLMONITOR 
457f cd aa fd			call debug_vector  
4582				endm  
# End of macro CALLMONITOR
4582					endif 
4582			 
4582 cd 6c 0d			call scroll_up 
4585			;	call update_display 
4585			 
4585					NEXTW 
4585 c3 39 24			jp macro_next 
4588				endm 
# End of macro NEXTW
4588			 
4588			 
4588			 
4588			;		; get dir 
4588			; 
4588			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4588			; 
4588			;		push hl 
4588			; 
4588			;		; destroy value TOS 
4588			; 
4588			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4588			; 
4588			;		; get count 
4588			; 
4588			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4588			; 
4588			;		push hl 
4588			; 
4588			;		; destroy value TOS 
4588			; 
4588			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4588			; 
4588			;		; one value on hl get other one back 
4588			; 
4588			;		pop bc    ; count 
4588			; 
4588			;		pop de   ; dir 
4588			; 
4588			; 
4588			;		ld b, c 
4588			; 
4588			;.scrolldir:     push bc 
4588			;		push de 
4588			; 
4588			;		ld a, 0 
4588			;		cp e 
4588			;		jr z, .scrollup  
4588			;		call scroll_down 
4588			;		jr .scrollnext 
4588			;.scrollup:	call scroll_up 
4588			; 
4588			;		 
4588			;.scrollnext: 
4588			;		pop de 
4588			;		pop bc 
4588			;		djnz .scrolldir 
4588			; 
4588			; 
4588			; 
4588			; 
4588			; 
4588			;		NEXTW 
4588			 
4588			.SCROLLD: 
4588				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
4588 53				db WORD_SYS_CORE+63             
4589 b6 45			dw .ATQ            
458b 08				db 7 + 1 
458c .. 00			db "SCROLLD",0              
4594				endm 
# End of macro CWHEAD
4594			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
4594					if DEBUG_FORTH_WORDS_KEY 
4594						DMARK "SCD" 
4594 f5				push af  
4595 3a a9 45			ld a, (.dmark)  
4598 32 a0 fd			ld (debug_mark),a  
459b 3a aa 45			ld a, (.dmark+1)  
459e 32 a1 fd			ld (debug_mark+1),a  
45a1 3a ab 45			ld a, (.dmark+2)  
45a4 32 a2 fd			ld (debug_mark+2),a  
45a7 18 03			jr .pastdmark  
45a9 ..			.dmark: db "SCD"  
45ac f1			.pastdmark: pop af  
45ad			endm  
# End of macro DMARK
45ad						CALLMONITOR 
45ad cd aa fd			call debug_vector  
45b0				endm  
# End of macro CALLMONITOR
45b0					endif 
45b0			 
45b0 cd 90 0d			call scroll_down 
45b3			;	call update_display 
45b3			 
45b3					NEXTW 
45b3 c3 39 24			jp macro_next 
45b6				endm 
# End of macro NEXTW
45b6			 
45b6			 
45b6			.ATQ: 
45b6				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
45b6 62				db WORD_SYS_CORE+78             
45b7 14 46			dw .AUTODSP            
45b9 04				db 3 + 1 
45ba .. 00			db "AT@",0              
45be				endm 
# End of macro CWHEAD
45be			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
45be					if DEBUG_FORTH_WORDS_KEY 
45be						DMARK "ATA" 
45be f5				push af  
45bf 3a d3 45			ld a, (.dmark)  
45c2 32 a0 fd			ld (debug_mark),a  
45c5 3a d4 45			ld a, (.dmark+1)  
45c8 32 a1 fd			ld (debug_mark+1),a  
45cb 3a d5 45			ld a, (.dmark+2)  
45ce 32 a2 fd			ld (debug_mark+2),a  
45d1 18 03			jr .pastdmark  
45d3 ..			.dmark: db "ATA"  
45d6 f1			.pastdmark: pop af  
45d7			endm  
# End of macro DMARK
45d7						CALLMONITOR 
45d7 cd aa fd			call debug_vector  
45da				endm  
# End of macro CALLMONITOR
45da					endif 
45da			 
45da			 
45da					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45da cd 4d 22			call macro_dsp_valuehl 
45dd				endm 
# End of macro FORTH_DSP_VALUEHL
45dd			 
45dd					; TODO save cursor row 
45dd 7d					ld a,l 
45de fe 02				cp 2 
45e0 20 04				jr nz, .crow3aq 
45e2 3e 28				ld a, display_row_2 
45e4 18 12				jr .ccol1aq 
45e6 fe 03		.crow3aq:		cp 3 
45e8 20 04				jr nz, .crow4aq 
45ea 3e 50				ld a, display_row_3 
45ec 18 0a				jr .ccol1aq 
45ee fe 04		.crow4aq:		cp 4 
45f0 20 04				jr nz, .crow1aq 
45f2 3e 78				ld a, display_row_4 
45f4 18 02				jr .ccol1aq 
45f6 3e 00		.crow1aq:		ld a,display_row_1 
45f8 f5			.ccol1aq:		push af			; got row offset 
45f9 6f					ld l,a 
45fa 26 00				ld h,0 
45fc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45fc cd 05 23			call macro_forth_dsp_pop 
45ff				endm 
# End of macro FORTH_DSP_POP
45ff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45ff cd 4d 22			call macro_dsp_valuehl 
4602				endm 
# End of macro FORTH_DSP_VALUEHL
4602					; TODO save cursor col 
4602 f1					pop af 
4603 85					add l		; add col offset 
4604			 
4604					; add current frame buffer address 
4604 2a 01 fb				ld hl, (display_fb_active) 
4607 cd de 0f				call addatohl 
460a			 
460a			 
460a			 
460a			 
460a					; get char frame buffer location offset in hl 
460a			 
460a 7e					ld a,(hl) 
460b 26 00				ld h, 0 
460d 6f					ld l, a 
460e			 
460e cd 48 20				call forth_push_numhl 
4611			 
4611			 
4611					NEXTW 
4611 c3 39 24			jp macro_next 
4614				endm 
# End of macro NEXTW
4614			 
4614			.AUTODSP: 
4614				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4614 63				db WORD_SYS_CORE+79             
4615 2a 46			dw .MENU            
4617 05				db 4 + 1 
4618 .. 00			db "ADSP",0              
461d				endm 
# End of macro CWHEAD
461d			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
461d			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
461d			 
461d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
461d cd 4d 22			call macro_dsp_valuehl 
4620				endm 
# End of macro FORTH_DSP_VALUEHL
4620			 
4620			;		push hl 
4620			 
4620					; destroy value TOS 
4620			 
4620					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4620 cd 05 23			call macro_forth_dsp_pop 
4623				endm 
# End of macro FORTH_DSP_POP
4623			 
4623			;		pop hl 
4623			 
4623 7d					ld a,l 
4624 32 71 f9				ld (cli_autodisplay), a 
4627				       NEXTW 
4627 c3 39 24			jp macro_next 
462a				endm 
# End of macro NEXTW
462a			 
462a			.MENU: 
462a				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
462a 70				db WORD_SYS_CORE+92             
462b d3 46			dw .ENDDISPLAY            
462d 05				db 4 + 1 
462e .. 00			db "MENU",0              
4633				endm 
# End of macro CWHEAD
4633			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
4633			 
4633			;		; get number of items on the stack 
4633			; 
4633				 
4633					FORTH_DSP_VALUEHL 
4633 cd 4d 22			call macro_dsp_valuehl 
4636				endm 
# End of macro FORTH_DSP_VALUEHL
4636				 
4636					if DEBUG_FORTH_WORDS_KEY 
4636						DMARK "MNU" 
4636 f5				push af  
4637 3a 4b 46			ld a, (.dmark)  
463a 32 a0 fd			ld (debug_mark),a  
463d 3a 4c 46			ld a, (.dmark+1)  
4640 32 a1 fd			ld (debug_mark+1),a  
4643 3a 4d 46			ld a, (.dmark+2)  
4646 32 a2 fd			ld (debug_mark+2),a  
4649 18 03			jr .pastdmark  
464b ..			.dmark: db "MNU"  
464e f1			.pastdmark: pop af  
464f			endm  
# End of macro DMARK
464f						CALLMONITOR 
464f cd aa fd			call debug_vector  
4652				endm  
# End of macro CALLMONITOR
4652					endif 
4652			 
4652 45					ld b, l	 
4653 05					dec b 
4654			 
4654					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4654 cd 05 23			call macro_forth_dsp_pop 
4657				endm 
# End of macro FORTH_DSP_POP
4657			 
4657			 
4657					; go directly through the stack to pluck out the string pointers and build an array 
4657			 
4657			;		FORTH_DSP 
4657			 
4657					; hl contains top most stack item 
4657				 
4657 11 f6 f0				ld de, scratch 
465a			 
465a			.mbuild: 
465a			 
465a					FORTH_DSP_VALUEHL 
465a cd 4d 22			call macro_dsp_valuehl 
465d				endm 
# End of macro FORTH_DSP_VALUEHL
465d			 
465d					if DEBUG_FORTH_WORDS 
465d						DMARK "MN3" 
465d f5				push af  
465e 3a 72 46			ld a, (.dmark)  
4661 32 a0 fd			ld (debug_mark),a  
4664 3a 73 46			ld a, (.dmark+1)  
4667 32 a1 fd			ld (debug_mark+1),a  
466a 3a 74 46			ld a, (.dmark+2)  
466d 32 a2 fd			ld (debug_mark+2),a  
4670 18 03			jr .pastdmark  
4672 ..			.dmark: db "MN3"  
4675 f1			.pastdmark: pop af  
4676			endm  
# End of macro DMARK
4676						CALLMONITOR 
4676 cd aa fd			call debug_vector  
4679				endm  
# End of macro CALLMONITOR
4679					endif 
4679 eb					ex de, hl 
467a 73					ld (hl), e 
467b 23					inc hl 
467c 72					ld (hl), d 
467d 23					inc hl 
467e eb					ex de, hl 
467f			 
467f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
467f cd 05 23			call macro_forth_dsp_pop 
4682				endm 
# End of macro FORTH_DSP_POP
4682			 
4682 10 d6				djnz .mbuild 
4684			 
4684					; done add term 
4684			 
4684 eb					ex de, hl 
4685 36 00				ld (hl), 0 
4687 23					inc hl 
4688 36 00				ld (hl), 0 
468a			 
468a				 
468a					 
468a 21 f6 f0				ld hl, scratch 
468d			 
468d					if DEBUG_FORTH_WORDS 
468d						DMARK "MNx" 
468d f5				push af  
468e 3a a2 46			ld a, (.dmark)  
4691 32 a0 fd			ld (debug_mark),a  
4694 3a a3 46			ld a, (.dmark+1)  
4697 32 a1 fd			ld (debug_mark+1),a  
469a 3a a4 46			ld a, (.dmark+2)  
469d 32 a2 fd			ld (debug_mark+2),a  
46a0 18 03			jr .pastdmark  
46a2 ..			.dmark: db "MNx"  
46a5 f1			.pastdmark: pop af  
46a6			endm  
# End of macro DMARK
46a6						CALLMONITOR 
46a6 cd aa fd			call debug_vector  
46a9				endm  
# End of macro CALLMONITOR
46a9					endif 
46a9			 
46a9			 
46a9			 
46a9 3e 00				ld a, 0 
46ab cd db 0d				call menu 
46ae			 
46ae			 
46ae 6f					ld l, a 
46af 26 00				ld h, 0 
46b1			 
46b1					if DEBUG_FORTH_WORDS 
46b1						DMARK "MNr" 
46b1 f5				push af  
46b2 3a c6 46			ld a, (.dmark)  
46b5 32 a0 fd			ld (debug_mark),a  
46b8 3a c7 46			ld a, (.dmark+1)  
46bb 32 a1 fd			ld (debug_mark+1),a  
46be 3a c8 46			ld a, (.dmark+2)  
46c1 32 a2 fd			ld (debug_mark+2),a  
46c4 18 03			jr .pastdmark  
46c6 ..			.dmark: db "MNr"  
46c9 f1			.pastdmark: pop af  
46ca			endm  
# End of macro DMARK
46ca						CALLMONITOR 
46ca cd aa fd			call debug_vector  
46cd				endm  
# End of macro CALLMONITOR
46cd					endif 
46cd			 
46cd cd 48 20				call forth_push_numhl 
46d0			 
46d0			 
46d0			 
46d0			 
46d0				       NEXTW 
46d0 c3 39 24			jp macro_next 
46d3				endm 
# End of macro NEXTW
46d3			 
46d3			 
46d3			.ENDDISPLAY: 
46d3			 
46d3			; eof 
# End of file forth_words_display.asm
46d3			include "forth_words_str.asm" 
46d3			 
46d3			; | ## String Words 
46d3			 
46d3			.SPLIT:   
46d3			 
46d3				CWHEAD .PTR 52 "SPLIT" 5 WORD_FLAG_CODE 
46d3 48				db WORD_SYS_CORE+52             
46d4 c6 47			dw .PTR            
46d6 06				db 5 + 1 
46d7 .. 00			db "SPLIT",0              
46dd				endm 
# End of macro CWHEAD
46dd			; | SPLIT ( s d -- s s...sn c ) Using delimter d, add strings found in s to stack pushing item count c | TODO 
46dd					if DEBUG_FORTH_WORDS_KEY 
46dd						DMARK "SPT" 
46dd f5				push af  
46de 3a f2 46			ld a, (.dmark)  
46e1 32 a0 fd			ld (debug_mark),a  
46e4 3a f3 46			ld a, (.dmark+1)  
46e7 32 a1 fd			ld (debug_mark+1),a  
46ea 3a f4 46			ld a, (.dmark+2)  
46ed 32 a2 fd			ld (debug_mark+2),a  
46f0 18 03			jr .pastdmark  
46f2 ..			.dmark: db "SPT"  
46f5 f1			.pastdmark: pop af  
46f6			endm  
# End of macro DMARK
46f6						CALLMONITOR 
46f6 cd aa fd			call debug_vector  
46f9				endm  
# End of macro CALLMONITOR
46f9					endif 
46f9			 
46f9					; get delim 
46f9					FORTH_DSP_VALUEHL 
46f9 cd 4d 22			call macro_dsp_valuehl 
46fc				endm 
# End of macro FORTH_DSP_VALUEHL
46fc			 
46fc					FORTH_DSP_POP 
46fc cd 05 23			call macro_forth_dsp_pop 
46ff				endm 
# End of macro FORTH_DSP_POP
46ff					 
46ff			 
46ff 45					ld b, l    ; move delim to b 
4700 0e 01				ld c, 1   ; count of poritions 
4702			 
4702 c5					push bc 
4703			 
4703					if DEBUG_FORTH_WORDS 
4703						DMARK "SPa" 
4703 f5				push af  
4704 3a 18 47			ld a, (.dmark)  
4707 32 a0 fd			ld (debug_mark),a  
470a 3a 19 47			ld a, (.dmark+1)  
470d 32 a1 fd			ld (debug_mark+1),a  
4710 3a 1a 47			ld a, (.dmark+2)  
4713 32 a2 fd			ld (debug_mark+2),a  
4716 18 03			jr .pastdmark  
4718 ..			.dmark: db "SPa"  
471b f1			.pastdmark: pop af  
471c			endm  
# End of macro DMARK
471c						CALLMONITOR 
471c cd aa fd			call debug_vector  
471f				endm  
# End of macro CALLMONITOR
471f					endif 
471f					; get pointer to string to chop up 
471f					FORTH_DSP_VALUEHL 
471f cd 4d 22			call macro_dsp_valuehl 
4722				endm 
# End of macro FORTH_DSP_VALUEHL
4722			 
4722			;		push hl 
4722 11 f6 f0				ld de, scratch 
4725			.spllop: 
4725 c1					pop bc 
4726 c5					push bc 
4727			;		pop hl 
4727					if DEBUG_FORTH_WORDS 
4727						DMARK "SPl" 
4727 f5				push af  
4728 3a 3c 47			ld a, (.dmark)  
472b 32 a0 fd			ld (debug_mark),a  
472e 3a 3d 47			ld a, (.dmark+1)  
4731 32 a1 fd			ld (debug_mark+1),a  
4734 3a 3e 47			ld a, (.dmark+2)  
4737 32 a2 fd			ld (debug_mark+2),a  
473a 18 03			jr .pastdmark  
473c ..			.dmark: db "SPl"  
473f f1			.pastdmark: pop af  
4740			endm  
# End of macro DMARK
4740						CALLMONITOR 
4740 cd aa fd			call debug_vector  
4743				endm  
# End of macro CALLMONITOR
4743					endif 
4743 7e					ld a, (hl) 
4744 b8					cp b 
4745 28 08				jr z, .splnxt 
4747 fe 00				cp 0 
4749 28 35				jr z, .splend 
474b ed a0				ldi 
474d 18 d6				jr .spllop 
474f			 
474f					; hit dlim 
474f			 
474f			.splnxt: 
474f					if DEBUG_FORTH_WORDS 
474f						DMARK "SPx" 
474f f5				push af  
4750 3a 64 47			ld a, (.dmark)  
4753 32 a0 fd			ld (debug_mark),a  
4756 3a 65 47			ld a, (.dmark+1)  
4759 32 a1 fd			ld (debug_mark+1),a  
475c 3a 66 47			ld a, (.dmark+2)  
475f 32 a2 fd			ld (debug_mark+2),a  
4762 18 03			jr .pastdmark  
4764 ..			.dmark: db "SPx"  
4767 f1			.pastdmark: pop af  
4768			endm  
# End of macro DMARK
4768						CALLMONITOR 
4768 cd aa fd			call debug_vector  
476b				endm  
# End of macro CALLMONITOR
476b					endif 
476b 3e 00				ld a, 0 
476d 12					ld (de), a 
476e eb					ex de, hl 
476f e5					push hl 
4770 21 f6 f0				ld hl, scratch 
4773 cd b6 20				call forth_push_str 
4776 e1					pop hl 
4777 eb					ex de, hl 
4778 c1					pop bc 
4779 0c					inc c 
477a c5					push bc 
477b 11 f6 f0				ld de, scratch 
477e 18 a5				jr .spllop 
4780			 
4780			.splend:		 
4780					if DEBUG_FORTH_WORDS 
4780						DMARK "SPe" 
4780 f5				push af  
4781 3a 95 47			ld a, (.dmark)  
4784 32 a0 fd			ld (debug_mark),a  
4787 3a 96 47			ld a, (.dmark+1)  
478a 32 a1 fd			ld (debug_mark+1),a  
478d 3a 97 47			ld a, (.dmark+2)  
4790 32 a2 fd			ld (debug_mark+2),a  
4793 18 03			jr .pastdmark  
4795 ..			.dmark: db "SPe"  
4798 f1			.pastdmark: pop af  
4799			endm  
# End of macro DMARK
4799						CALLMONITOR 
4799 cd aa fd			call debug_vector  
479c				endm  
# End of macro CALLMONITOR
479c					endif 
479c 12					ld (de), a 
479d eb					ex de, hl 
479e			;		push hl 
479e cd b6 20				call forth_push_str 
47a1					 
47a1					if DEBUG_FORTH_WORDS 
47a1						DMARK "SPc" 
47a1 f5				push af  
47a2 3a b6 47			ld a, (.dmark)  
47a5 32 a0 fd			ld (debug_mark),a  
47a8 3a b7 47			ld a, (.dmark+1)  
47ab 32 a1 fd			ld (debug_mark+1),a  
47ae 3a b8 47			ld a, (.dmark+2)  
47b1 32 a2 fd			ld (debug_mark+2),a  
47b4 18 03			jr .pastdmark  
47b6 ..			.dmark: db "SPc"  
47b9 f1			.pastdmark: pop af  
47ba			endm  
# End of macro DMARK
47ba						CALLMONITOR 
47ba cd aa fd			call debug_vector  
47bd				endm  
# End of macro CALLMONITOR
47bd					endif 
47bd			 
47bd e1					pop hl    ; get counter from bc which has been push 
47be 26 00				ld h, 0 
47c0			;		ld l, c 
47c0 cd 48 20				call forth_push_numhl 
47c3			 
47c3			 
47c3				NEXTW 
47c3 c3 39 24			jp macro_next 
47c6				endm 
# End of macro NEXTW
47c6			.PTR:   
47c6			 
47c6				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
47c6 48				db WORD_SYS_CORE+52             
47c7 f3 47			dw .STYPE            
47c9 04				db 3 + 1 
47ca .. 00			db "PTR",0              
47ce				endm 
# End of macro CWHEAD
47ce			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
47ce			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
47ce			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
47ce			 
47ce					if DEBUG_FORTH_WORDS_KEY 
47ce						DMARK "PTR" 
47ce f5				push af  
47cf 3a e3 47			ld a, (.dmark)  
47d2 32 a0 fd			ld (debug_mark),a  
47d5 3a e4 47			ld a, (.dmark+1)  
47d8 32 a1 fd			ld (debug_mark+1),a  
47db 3a e5 47			ld a, (.dmark+2)  
47de 32 a2 fd			ld (debug_mark+2),a  
47e1 18 03			jr .pastdmark  
47e3 ..			.dmark: db "PTR"  
47e6 f1			.pastdmark: pop af  
47e7			endm  
# End of macro DMARK
47e7						CALLMONITOR 
47e7 cd aa fd			call debug_vector  
47ea				endm  
# End of macro CALLMONITOR
47ea					endif 
47ea					FORTH_DSP_VALUEHL 
47ea cd 4d 22			call macro_dsp_valuehl 
47ed				endm 
# End of macro FORTH_DSP_VALUEHL
47ed cd 48 20				call forth_push_numhl 
47f0			 
47f0			 
47f0					NEXTW 
47f0 c3 39 24			jp macro_next 
47f3				endm 
# End of macro NEXTW
47f3			.STYPE: 
47f3				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
47f3 48				db WORD_SYS_CORE+52             
47f4 42 48			dw .UPPER            
47f6 06				db 5 + 1 
47f7 .. 00			db "STYPE",0              
47fd				endm 
# End of macro CWHEAD
47fd			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
47fd					if DEBUG_FORTH_WORDS_KEY 
47fd						DMARK "STY" 
47fd f5				push af  
47fe 3a 12 48			ld a, (.dmark)  
4801 32 a0 fd			ld (debug_mark),a  
4804 3a 13 48			ld a, (.dmark+1)  
4807 32 a1 fd			ld (debug_mark+1),a  
480a 3a 14 48			ld a, (.dmark+2)  
480d 32 a2 fd			ld (debug_mark+2),a  
4810 18 03			jr .pastdmark  
4812 ..			.dmark: db "STY"  
4815 f1			.pastdmark: pop af  
4816			endm  
# End of macro DMARK
4816						CALLMONITOR 
4816 cd aa fd			call debug_vector  
4819				endm  
# End of macro CALLMONITOR
4819					endif 
4819					FORTH_DSP 
4819 cd 13 22			call macro_forth_dsp 
481c				endm 
# End of macro FORTH_DSP
481c					;v5 FORTH_DSP_VALUE 
481c			 
481c 7e					ld a, (hl) 
481d			 
481d f5					push af 
481e			 
481e			; Dont destroy TOS		FORTH_DSP_POP 
481e			 
481e f1					pop af 
481f			 
481f fe 01				cp DS_TYPE_STR 
4821 28 09				jr z, .typestr 
4823			 
4823 fe 02				cp DS_TYPE_INUM 
4825 28 0a				jr z, .typeinum 
4827			 
4827 21 40 48				ld hl, .tna 
482a 18 0a				jr .tpush 
482c			 
482c 21 3c 48		.typestr:	ld hl, .tstr 
482f 18 05				jr .tpush 
4831 21 3e 48		.typeinum:	ld hl, .tinum 
4834 18 00				jr .tpush 
4836			 
4836			.tpush: 
4836			 
4836 cd b6 20				call forth_push_str 
4839			 
4839					NEXTW 
4839 c3 39 24			jp macro_next 
483c				endm 
# End of macro NEXTW
483c .. 00		.tstr:	db "s",0 
483e .. 00		.tinum:  db "i",0 
4840 .. 00		.tna:   db "?", 0 
4842			 
4842			 
4842			.UPPER: 
4842				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4842 48				db WORD_SYS_CORE+52             
4843 7d 48			dw .LOWER            
4845 06				db 5 + 1 
4846 .. 00			db "UPPER",0              
484c				endm 
# End of macro CWHEAD
484c			; | UPPER ( s -- s ) Upper case string s  | DONE 
484c					if DEBUG_FORTH_WORDS_KEY 
484c						DMARK "UPR" 
484c f5				push af  
484d 3a 61 48			ld a, (.dmark)  
4850 32 a0 fd			ld (debug_mark),a  
4853 3a 62 48			ld a, (.dmark+1)  
4856 32 a1 fd			ld (debug_mark+1),a  
4859 3a 63 48			ld a, (.dmark+2)  
485c 32 a2 fd			ld (debug_mark+2),a  
485f 18 03			jr .pastdmark  
4861 ..			.dmark: db "UPR"  
4864 f1			.pastdmark: pop af  
4865			endm  
# End of macro DMARK
4865						CALLMONITOR 
4865 cd aa fd			call debug_vector  
4868				endm  
# End of macro CALLMONITOR
4868					endif 
4868			 
4868					FORTH_DSP 
4868 cd 13 22			call macro_forth_dsp 
486b				endm 
# End of macro FORTH_DSP
486b					 
486b			; TODO check is string type 
486b			 
486b					FORTH_DSP_VALUEHL 
486b cd 4d 22			call macro_dsp_valuehl 
486e				endm 
# End of macro FORTH_DSP_VALUEHL
486e			; get pointer to string in hl 
486e			 
486e 7e			.toup:		ld a, (hl) 
486f fe 00				cp 0 
4871 28 07				jr z, .toupdone 
4873			 
4873 cd 53 12				call to_upper 
4876			 
4876 77					ld (hl), a 
4877 23					inc hl 
4878 18 f4				jr .toup 
487a			 
487a					 
487a			 
487a			 
487a			; for each char convert to upper 
487a					 
487a			.toupdone: 
487a			 
487a			 
487a					NEXTW 
487a c3 39 24			jp macro_next 
487d				endm 
# End of macro NEXTW
487d			.LOWER: 
487d				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
487d 48				db WORD_SYS_CORE+52             
487e b8 48			dw .TCASE            
4880 06				db 5 + 1 
4881 .. 00			db "LOWER",0              
4887				endm 
# End of macro CWHEAD
4887			; | LOWER ( s -- s ) Lower case string s  | DONE 
4887					if DEBUG_FORTH_WORDS_KEY 
4887						DMARK "LWR" 
4887 f5				push af  
4888 3a 9c 48			ld a, (.dmark)  
488b 32 a0 fd			ld (debug_mark),a  
488e 3a 9d 48			ld a, (.dmark+1)  
4891 32 a1 fd			ld (debug_mark+1),a  
4894 3a 9e 48			ld a, (.dmark+2)  
4897 32 a2 fd			ld (debug_mark+2),a  
489a 18 03			jr .pastdmark  
489c ..			.dmark: db "LWR"  
489f f1			.pastdmark: pop af  
48a0			endm  
# End of macro DMARK
48a0						CALLMONITOR 
48a0 cd aa fd			call debug_vector  
48a3				endm  
# End of macro CALLMONITOR
48a3					endif 
48a3			 
48a3					FORTH_DSP 
48a3 cd 13 22			call macro_forth_dsp 
48a6				endm 
# End of macro FORTH_DSP
48a6					 
48a6			; TODO check is string type 
48a6			 
48a6					FORTH_DSP_VALUEHL 
48a6 cd 4d 22			call macro_dsp_valuehl 
48a9				endm 
# End of macro FORTH_DSP_VALUEHL
48a9			; get pointer to string in hl 
48a9			 
48a9 7e			.tolow:		ld a, (hl) 
48aa fe 00				cp 0 
48ac 28 07				jr z, .tolowdone 
48ae			 
48ae cd 5c 12				call to_lower 
48b1			 
48b1 77					ld (hl), a 
48b2 23					inc hl 
48b3 18 f4				jr .tolow 
48b5			 
48b5					 
48b5			 
48b5			 
48b5			; for each char convert to low 
48b5					 
48b5			.tolowdone: 
48b5					NEXTW 
48b5 c3 39 24			jp macro_next 
48b8				endm 
# End of macro NEXTW
48b8			.TCASE: 
48b8				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
48b8 48				db WORD_SYS_CORE+52             
48b9 ee 49			dw .SUBSTR            
48bb 06				db 5 + 1 
48bc .. 00			db "TCASE",0              
48c2				endm 
# End of macro CWHEAD
48c2			; | TCASE ( s -- s ) Title case string s  | DONE 
48c2					if DEBUG_FORTH_WORDS_KEY 
48c2						DMARK "TCS" 
48c2 f5				push af  
48c3 3a d7 48			ld a, (.dmark)  
48c6 32 a0 fd			ld (debug_mark),a  
48c9 3a d8 48			ld a, (.dmark+1)  
48cc 32 a1 fd			ld (debug_mark+1),a  
48cf 3a d9 48			ld a, (.dmark+2)  
48d2 32 a2 fd			ld (debug_mark+2),a  
48d5 18 03			jr .pastdmark  
48d7 ..			.dmark: db "TCS"  
48da f1			.pastdmark: pop af  
48db			endm  
# End of macro DMARK
48db						CALLMONITOR 
48db cd aa fd			call debug_vector  
48de				endm  
# End of macro CALLMONITOR
48de					endif 
48de			 
48de					FORTH_DSP 
48de cd 13 22			call macro_forth_dsp 
48e1				endm 
# End of macro FORTH_DSP
48e1					 
48e1			; TODO check is string type 
48e1			 
48e1					FORTH_DSP_VALUEHL 
48e1 cd 4d 22			call macro_dsp_valuehl 
48e4				endm 
# End of macro FORTH_DSP_VALUEHL
48e4			; get pointer to string in hl 
48e4			 
48e4					if DEBUG_FORTH_WORDS 
48e4						DMARK "TC1" 
48e4 f5				push af  
48e5 3a f9 48			ld a, (.dmark)  
48e8 32 a0 fd			ld (debug_mark),a  
48eb 3a fa 48			ld a, (.dmark+1)  
48ee 32 a1 fd			ld (debug_mark+1),a  
48f1 3a fb 48			ld a, (.dmark+2)  
48f4 32 a2 fd			ld (debug_mark+2),a  
48f7 18 03			jr .pastdmark  
48f9 ..			.dmark: db "TC1"  
48fc f1			.pastdmark: pop af  
48fd			endm  
# End of macro DMARK
48fd						CALLMONITOR 
48fd cd aa fd			call debug_vector  
4900				endm  
# End of macro CALLMONITOR
4900					endif 
4900			 
4900					; first time in turn to upper case first char 
4900			 
4900 7e					ld a, (hl) 
4901 c3 8b 49				jp .totsiptou 
4904			 
4904			 
4904 7e			.tot:		ld a, (hl) 
4905 fe 00				cp 0 
4907 ca cf 49				jp z, .totdone 
490a			 
490a					if DEBUG_FORTH_WORDS 
490a						DMARK "TC2" 
490a f5				push af  
490b 3a 1f 49			ld a, (.dmark)  
490e 32 a0 fd			ld (debug_mark),a  
4911 3a 20 49			ld a, (.dmark+1)  
4914 32 a1 fd			ld (debug_mark+1),a  
4917 3a 21 49			ld a, (.dmark+2)  
491a 32 a2 fd			ld (debug_mark+2),a  
491d 18 03			jr .pastdmark  
491f ..			.dmark: db "TC2"  
4922 f1			.pastdmark: pop af  
4923			endm  
# End of macro DMARK
4923						CALLMONITOR 
4923 cd aa fd			call debug_vector  
4926				endm  
# End of macro CALLMONITOR
4926					endif 
4926					; check to see if current char is a space 
4926			 
4926 fe 20				cp ' ' 
4928 28 21				jr z, .totsp 
492a cd 5c 12				call to_lower 
492d					if DEBUG_FORTH_WORDS 
492d						DMARK "TC3" 
492d f5				push af  
492e 3a 42 49			ld a, (.dmark)  
4931 32 a0 fd			ld (debug_mark),a  
4934 3a 43 49			ld a, (.dmark+1)  
4937 32 a1 fd			ld (debug_mark+1),a  
493a 3a 44 49			ld a, (.dmark+2)  
493d 32 a2 fd			ld (debug_mark+2),a  
4940 18 03			jr .pastdmark  
4942 ..			.dmark: db "TC3"  
4945 f1			.pastdmark: pop af  
4946			endm  
# End of macro DMARK
4946						CALLMONITOR 
4946 cd aa fd			call debug_vector  
4949				endm  
# End of macro CALLMONITOR
4949					endif 
4949 18 63				jr .totnxt 
494b			 
494b			.totsp:         ; on a space, find next char which should be upper 
494b			 
494b					if DEBUG_FORTH_WORDS 
494b						DMARK "TC4" 
494b f5				push af  
494c 3a 60 49			ld a, (.dmark)  
494f 32 a0 fd			ld (debug_mark),a  
4952 3a 61 49			ld a, (.dmark+1)  
4955 32 a1 fd			ld (debug_mark+1),a  
4958 3a 62 49			ld a, (.dmark+2)  
495b 32 a2 fd			ld (debug_mark+2),a  
495e 18 03			jr .pastdmark  
4960 ..			.dmark: db "TC4"  
4963 f1			.pastdmark: pop af  
4964			endm  
# End of macro DMARK
4964						CALLMONITOR 
4964 cd aa fd			call debug_vector  
4967				endm  
# End of macro CALLMONITOR
4967					endif 
4967					;; 
4967			 
4967 fe 20				cp ' ' 
4969 20 20				jr nz, .totsiptou 
496b 23					inc hl 
496c 7e					ld a, (hl) 
496d					if DEBUG_FORTH_WORDS 
496d						DMARK "TC5" 
496d f5				push af  
496e 3a 82 49			ld a, (.dmark)  
4971 32 a0 fd			ld (debug_mark),a  
4974 3a 83 49			ld a, (.dmark+1)  
4977 32 a1 fd			ld (debug_mark+1),a  
497a 3a 84 49			ld a, (.dmark+2)  
497d 32 a2 fd			ld (debug_mark+2),a  
4980 18 03			jr .pastdmark  
4982 ..			.dmark: db "TC5"  
4985 f1			.pastdmark: pop af  
4986			endm  
# End of macro DMARK
4986						CALLMONITOR 
4986 cd aa fd			call debug_vector  
4989				endm  
# End of macro CALLMONITOR
4989					endif 
4989 18 c0				jr .totsp 
498b fe 00		.totsiptou:    cp 0 
498d 28 40				jr z, .totdone 
498f					; not space and not zero term so upper case it 
498f cd 53 12				call to_upper 
4992			 
4992					if DEBUG_FORTH_WORDS 
4992						DMARK "TC6" 
4992 f5				push af  
4993 3a a7 49			ld a, (.dmark)  
4996 32 a0 fd			ld (debug_mark),a  
4999 3a a8 49			ld a, (.dmark+1)  
499c 32 a1 fd			ld (debug_mark+1),a  
499f 3a a9 49			ld a, (.dmark+2)  
49a2 32 a2 fd			ld (debug_mark+2),a  
49a5 18 03			jr .pastdmark  
49a7 ..			.dmark: db "TC6"  
49aa f1			.pastdmark: pop af  
49ab			endm  
# End of macro DMARK
49ab						CALLMONITOR 
49ab cd aa fd			call debug_vector  
49ae				endm  
# End of macro CALLMONITOR
49ae					endif 
49ae			 
49ae			 
49ae			.totnxt: 
49ae			 
49ae 77					ld (hl), a 
49af 23					inc hl 
49b0					if DEBUG_FORTH_WORDS 
49b0						DMARK "TC7" 
49b0 f5				push af  
49b1 3a c5 49			ld a, (.dmark)  
49b4 32 a0 fd			ld (debug_mark),a  
49b7 3a c6 49			ld a, (.dmark+1)  
49ba 32 a1 fd			ld (debug_mark+1),a  
49bd 3a c7 49			ld a, (.dmark+2)  
49c0 32 a2 fd			ld (debug_mark+2),a  
49c3 18 03			jr .pastdmark  
49c5 ..			.dmark: db "TC7"  
49c8 f1			.pastdmark: pop af  
49c9			endm  
# End of macro DMARK
49c9						CALLMONITOR 
49c9 cd aa fd			call debug_vector  
49cc				endm  
# End of macro CALLMONITOR
49cc					endif 
49cc c3 04 49				jp .tot 
49cf			 
49cf					 
49cf			 
49cf			 
49cf			; for each char convert to low 
49cf					 
49cf			.totdone: 
49cf					if DEBUG_FORTH_WORDS 
49cf						DMARK "TCd" 
49cf f5				push af  
49d0 3a e4 49			ld a, (.dmark)  
49d3 32 a0 fd			ld (debug_mark),a  
49d6 3a e5 49			ld a, (.dmark+1)  
49d9 32 a1 fd			ld (debug_mark+1),a  
49dc 3a e6 49			ld a, (.dmark+2)  
49df 32 a2 fd			ld (debug_mark+2),a  
49e2 18 03			jr .pastdmark  
49e4 ..			.dmark: db "TCd"  
49e7 f1			.pastdmark: pop af  
49e8			endm  
# End of macro DMARK
49e8						CALLMONITOR 
49e8 cd aa fd			call debug_vector  
49eb				endm  
# End of macro CALLMONITOR
49eb					endif 
49eb					NEXTW 
49eb c3 39 24			jp macro_next 
49ee				endm 
# End of macro NEXTW
49ee			 
49ee			.SUBSTR: 
49ee				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
49ee 48				db WORD_SYS_CORE+52             
49ef 4c 4a			dw .LEFT            
49f1 07				db 6 + 1 
49f2 .. 00			db "SUBSTR",0              
49f9				endm 
# End of macro CWHEAD
49f9			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
49f9			 
49f9					if DEBUG_FORTH_WORDS_KEY 
49f9						DMARK "SST" 
49f9 f5				push af  
49fa 3a 0e 4a			ld a, (.dmark)  
49fd 32 a0 fd			ld (debug_mark),a  
4a00 3a 0f 4a			ld a, (.dmark+1)  
4a03 32 a1 fd			ld (debug_mark+1),a  
4a06 3a 10 4a			ld a, (.dmark+2)  
4a09 32 a2 fd			ld (debug_mark+2),a  
4a0c 18 03			jr .pastdmark  
4a0e ..			.dmark: db "SST"  
4a11 f1			.pastdmark: pop af  
4a12			endm  
# End of macro DMARK
4a12						CALLMONITOR 
4a12 cd aa fd			call debug_vector  
4a15				endm  
# End of macro CALLMONITOR
4a15					endif 
4a15			; TODO check string type 
4a15					FORTH_DSP_VALUEHL 
4a15 cd 4d 22			call macro_dsp_valuehl 
4a18				endm 
# End of macro FORTH_DSP_VALUEHL
4a18			 
4a18 e5					push hl      ; string length 
4a19			 
4a19					FORTH_DSP_POP 
4a19 cd 05 23			call macro_forth_dsp_pop 
4a1c				endm 
# End of macro FORTH_DSP_POP
4a1c			 
4a1c					FORTH_DSP_VALUEHL 
4a1c cd 4d 22			call macro_dsp_valuehl 
4a1f				endm 
# End of macro FORTH_DSP_VALUEHL
4a1f			 
4a1f e5					push hl     ; start char 
4a20			 
4a20					FORTH_DSP_POP 
4a20 cd 05 23			call macro_forth_dsp_pop 
4a23				endm 
# End of macro FORTH_DSP_POP
4a23			 
4a23			 
4a23					FORTH_DSP_VALUE 
4a23 cd 36 22			call macro_forth_dsp_value 
4a26				endm 
# End of macro FORTH_DSP_VALUE
4a26			 
4a26 d1					pop de    ; get start post offset 
4a27			 
4a27 19					add hl, de    ; starting offset 
4a28			 
4a28 c1					pop bc 
4a29 c5					push bc      ; grab size of string 
4a2a			 
4a2a e5					push hl    ; save string start  
4a2b			 
4a2b 26 00				ld h, 0 
4a2d 69					ld l, c 
4a2e 23					inc hl 
4a2f 23					inc hl 
4a30			 
4a30 cd b9 13				call malloc 
4a33				if DEBUG_FORTH_MALLOC_GUARD 
4a33 cc 79 5f				call z,malloc_error 
4a36				endif 
4a36			 
4a36 eb					ex de, hl      ; save malloc area for string copy 
4a37 e1					pop hl    ; get back source 
4a38 c1					pop bc    ; get length of string back 
4a39			 
4a39 d5					push de    ; save malloc area for after we push 
4a3a ed b0				ldir     ; copy substr 
4a3c			 
4a3c			 
4a3c eb					ex de, hl 
4a3d 3e 00				ld a, 0 
4a3f 77					ld (hl), a   ; term substr 
4a40			 
4a40					 
4a40 e1					pop hl    ; get malloc so we can push it 
4a41 e5					push hl   ; save so we can free it afterwards 
4a42			 
4a42 cd b6 20				call forth_push_str 
4a45			 
4a45 e1					pop hl 
4a46 cd 83 14				call free 
4a49			 
4a49					 
4a49					 
4a49			 
4a49			 
4a49					NEXTW 
4a49 c3 39 24			jp macro_next 
4a4c				endm 
# End of macro NEXTW
4a4c			 
4a4c			.LEFT: 
4a4c				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4a4c 48				db WORD_SYS_CORE+52             
4a4d 74 4a			dw .RIGHT            
4a4f 05				db 4 + 1 
4a50 .. 00			db "LEFT",0              
4a55				endm 
# End of macro CWHEAD
4a55			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4a55					if DEBUG_FORTH_WORDS_KEY 
4a55						DMARK "LEF" 
4a55 f5				push af  
4a56 3a 6a 4a			ld a, (.dmark)  
4a59 32 a0 fd			ld (debug_mark),a  
4a5c 3a 6b 4a			ld a, (.dmark+1)  
4a5f 32 a1 fd			ld (debug_mark+1),a  
4a62 3a 6c 4a			ld a, (.dmark+2)  
4a65 32 a2 fd			ld (debug_mark+2),a  
4a68 18 03			jr .pastdmark  
4a6a ..			.dmark: db "LEF"  
4a6d f1			.pastdmark: pop af  
4a6e			endm  
# End of macro DMARK
4a6e						CALLMONITOR 
4a6e cd aa fd			call debug_vector  
4a71				endm  
# End of macro CALLMONITOR
4a71					endif 
4a71			 
4a71					NEXTW 
4a71 c3 39 24			jp macro_next 
4a74				endm 
# End of macro NEXTW
4a74			.RIGHT: 
4a74				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4a74 48				db WORD_SYS_CORE+52             
4a75 9d 4a			dw .STR2NUM            
4a77 06				db 5 + 1 
4a78 .. 00			db "RIGHT",0              
4a7e				endm 
# End of macro CWHEAD
4a7e			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
4a7e					if DEBUG_FORTH_WORDS_KEY 
4a7e						DMARK "RIG" 
4a7e f5				push af  
4a7f 3a 93 4a			ld a, (.dmark)  
4a82 32 a0 fd			ld (debug_mark),a  
4a85 3a 94 4a			ld a, (.dmark+1)  
4a88 32 a1 fd			ld (debug_mark+1),a  
4a8b 3a 95 4a			ld a, (.dmark+2)  
4a8e 32 a2 fd			ld (debug_mark+2),a  
4a91 18 03			jr .pastdmark  
4a93 ..			.dmark: db "RIG"  
4a96 f1			.pastdmark: pop af  
4a97			endm  
# End of macro DMARK
4a97						CALLMONITOR 
4a97 cd aa fd			call debug_vector  
4a9a				endm  
# End of macro CALLMONITOR
4a9a					endif 
4a9a			 
4a9a					NEXTW 
4a9a c3 39 24			jp macro_next 
4a9d				endm 
# End of macro NEXTW
4a9d			 
4a9d			 
4a9d			.STR2NUM: 
4a9d				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4a9d 48				db WORD_SYS_CORE+52             
4a9e 29 4b			dw .NUM2STR            
4aa0 08				db 7 + 1 
4aa1 .. 00			db "STR2NUM",0              
4aa9				endm 
# End of macro CWHEAD
4aa9			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4aa9			 
4aa9			 
4aa9			; TODO STR type check to do 
4aa9					if DEBUG_FORTH_WORDS_KEY 
4aa9						DMARK "S2N" 
4aa9 f5				push af  
4aaa 3a be 4a			ld a, (.dmark)  
4aad 32 a0 fd			ld (debug_mark),a  
4ab0 3a bf 4a			ld a, (.dmark+1)  
4ab3 32 a1 fd			ld (debug_mark+1),a  
4ab6 3a c0 4a			ld a, (.dmark+2)  
4ab9 32 a2 fd			ld (debug_mark+2),a  
4abc 18 03			jr .pastdmark  
4abe ..			.dmark: db "S2N"  
4ac1 f1			.pastdmark: pop af  
4ac2			endm  
# End of macro DMARK
4ac2						CALLMONITOR 
4ac2 cd aa fd			call debug_vector  
4ac5				endm  
# End of macro CALLMONITOR
4ac5					endif 
4ac5			 
4ac5					;FORTH_DSP 
4ac5					FORTH_DSP_VALUE 
4ac5 cd 36 22			call macro_forth_dsp_value 
4ac8				endm 
# End of macro FORTH_DSP_VALUE
4ac8					;inc hl 
4ac8			 
4ac8 eb					ex de, hl 
4ac9					if DEBUG_FORTH_WORDS 
4ac9						DMARK "S2a" 
4ac9 f5				push af  
4aca 3a de 4a			ld a, (.dmark)  
4acd 32 a0 fd			ld (debug_mark),a  
4ad0 3a df 4a			ld a, (.dmark+1)  
4ad3 32 a1 fd			ld (debug_mark+1),a  
4ad6 3a e0 4a			ld a, (.dmark+2)  
4ad9 32 a2 fd			ld (debug_mark+2),a  
4adc 18 03			jr .pastdmark  
4ade ..			.dmark: db "S2a"  
4ae1 f1			.pastdmark: pop af  
4ae2			endm  
# End of macro DMARK
4ae2						CALLMONITOR 
4ae2 cd aa fd			call debug_vector  
4ae5				endm  
# End of macro CALLMONITOR
4ae5					endif 
4ae5 cd db 12				call string_to_uint16 
4ae8			 
4ae8					if DEBUG_FORTH_WORDS 
4ae8						DMARK "S2b" 
4ae8 f5				push af  
4ae9 3a fd 4a			ld a, (.dmark)  
4aec 32 a0 fd			ld (debug_mark),a  
4aef 3a fe 4a			ld a, (.dmark+1)  
4af2 32 a1 fd			ld (debug_mark+1),a  
4af5 3a ff 4a			ld a, (.dmark+2)  
4af8 32 a2 fd			ld (debug_mark+2),a  
4afb 18 03			jr .pastdmark  
4afd ..			.dmark: db "S2b"  
4b00 f1			.pastdmark: pop af  
4b01			endm  
# End of macro DMARK
4b01						CALLMONITOR 
4b01 cd aa fd			call debug_vector  
4b04				endm  
# End of macro CALLMONITOR
4b04					endif 
4b04			;		push hl 
4b04					FORTH_DSP_POP 
4b04 cd 05 23			call macro_forth_dsp_pop 
4b07				endm 
# End of macro FORTH_DSP_POP
4b07			;		pop hl 
4b07					 
4b07					if DEBUG_FORTH_WORDS 
4b07						DMARK "S2b" 
4b07 f5				push af  
4b08 3a 1c 4b			ld a, (.dmark)  
4b0b 32 a0 fd			ld (debug_mark),a  
4b0e 3a 1d 4b			ld a, (.dmark+1)  
4b11 32 a1 fd			ld (debug_mark+1),a  
4b14 3a 1e 4b			ld a, (.dmark+2)  
4b17 32 a2 fd			ld (debug_mark+2),a  
4b1a 18 03			jr .pastdmark  
4b1c ..			.dmark: db "S2b"  
4b1f f1			.pastdmark: pop af  
4b20			endm  
# End of macro DMARK
4b20						CALLMONITOR 
4b20 cd aa fd			call debug_vector  
4b23				endm  
# End of macro CALLMONITOR
4b23					endif 
4b23 cd 48 20				call forth_push_numhl	 
4b26			 
4b26				 
4b26				       NEXTW 
4b26 c3 39 24			jp macro_next 
4b29				endm 
# End of macro NEXTW
4b29			.NUM2STR: 
4b29				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
4b29 48				db WORD_SYS_CORE+52             
4b2a 38 4b			dw .CONCAT            
4b2c 08				db 7 + 1 
4b2d .. 00			db "NUM2STR",0              
4b35				endm 
# End of macro CWHEAD
4b35			; | NUM2STR ( n -- s ) Convert a number on TOS to string | TODO 
4b35			 
4b35			;		; malloc a string to target 
4b35			;		ld hl, 10     ; TODO max string size should be fine 
4b35			;		call malloc 
4b35			;		push hl    ; save malloc location 
4b35			; 
4b35			; 
4b35			;; TODO check int type 
4b35			;		FORTH_DSP_VALUEHL 
4b35			;		ld a, l 
4b35			;		call DispAToASCII   
4b35			;;TODO need to chage above call to dump into string 
4b35			; 
4b35			; 
4b35			 
4b35				       NEXTW 
4b35 c3 39 24			jp macro_next 
4b38				endm 
# End of macro NEXTW
4b38			 
4b38			.CONCAT: 
4b38				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4b38 48				db WORD_SYS_CORE+52             
4b39 eb 4b			dw .FIND            
4b3b 07				db 6 + 1 
4b3c .. 00			db "CONCAT",0              
4b43				endm 
# End of macro CWHEAD
4b43			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4b43			 
4b43			; TODO check string type 
4b43			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4b43			 
4b43					if DEBUG_FORTH_WORDS_KEY 
4b43						DMARK "CON" 
4b43 f5				push af  
4b44 3a 58 4b			ld a, (.dmark)  
4b47 32 a0 fd			ld (debug_mark),a  
4b4a 3a 59 4b			ld a, (.dmark+1)  
4b4d 32 a1 fd			ld (debug_mark+1),a  
4b50 3a 5a 4b			ld a, (.dmark+2)  
4b53 32 a2 fd			ld (debug_mark+2),a  
4b56 18 03			jr .pastdmark  
4b58 ..			.dmark: db "CON"  
4b5b f1			.pastdmark: pop af  
4b5c			endm  
# End of macro DMARK
4b5c						CALLMONITOR 
4b5c cd aa fd			call debug_vector  
4b5f				endm  
# End of macro CALLMONITOR
4b5f					endif 
4b5f			 
4b5f			 
4b5f					FORTH_DSP_VALUE 
4b5f cd 36 22			call macro_forth_dsp_value 
4b62				endm 
# End of macro FORTH_DSP_VALUE
4b62 e5					push hl   ; s2 
4b63			 
4b63					FORTH_DSP_POP 
4b63 cd 05 23			call macro_forth_dsp_pop 
4b66				endm 
# End of macro FORTH_DSP_POP
4b66			 
4b66					FORTH_DSP_VALUE 
4b66 cd 36 22			call macro_forth_dsp_value 
4b69				endm 
# End of macro FORTH_DSP_VALUE
4b69			 
4b69 e5					push hl   ; s1 
4b6a			 
4b6a					FORTH_DSP_POP 
4b6a cd 05 23			call macro_forth_dsp_pop 
4b6d				endm 
# End of macro FORTH_DSP_POP
4b6d					 
4b6d			 
4b6d					; copy s1 
4b6d			 
4b6d				 
4b6d					; save ptr 
4b6d e1					pop hl  
4b6e e5					push hl 
4b6f 3e 00				ld a, 0 
4b71 cd 4f 13				call strlent 
4b74					;inc hl    ; zer0 
4b74 06 00				ld b, 0 
4b76 4d					ld c, l 
4b77 e1					pop hl		 
4b78 11 f6 f0				ld de, scratch	 
4b7b					if DEBUG_FORTH_WORDS 
4b7b						DMARK "CO1" 
4b7b f5				push af  
4b7c 3a 90 4b			ld a, (.dmark)  
4b7f 32 a0 fd			ld (debug_mark),a  
4b82 3a 91 4b			ld a, (.dmark+1)  
4b85 32 a1 fd			ld (debug_mark+1),a  
4b88 3a 92 4b			ld a, (.dmark+2)  
4b8b 32 a2 fd			ld (debug_mark+2),a  
4b8e 18 03			jr .pastdmark  
4b90 ..			.dmark: db "CO1"  
4b93 f1			.pastdmark: pop af  
4b94			endm  
# End of macro DMARK
4b94						CALLMONITOR 
4b94 cd aa fd			call debug_vector  
4b97				endm  
# End of macro CALLMONITOR
4b97					endif 
4b97 ed b0				ldir 
4b99			 
4b99 e1					pop hl 
4b9a e5					push hl 
4b9b d5					push de 
4b9c			 
4b9c			 
4b9c 3e 00				ld a, 0 
4b9e cd 4f 13				call strlent 
4ba1 23					inc hl    ; zer0 
4ba2 23					inc hl 
4ba3 06 00				ld b, 0 
4ba5 4d					ld c, l 
4ba6 d1					pop de 
4ba7 e1					pop hl		 
4ba8					if DEBUG_FORTH_WORDS 
4ba8						DMARK "CO2" 
4ba8 f5				push af  
4ba9 3a bd 4b			ld a, (.dmark)  
4bac 32 a0 fd			ld (debug_mark),a  
4baf 3a be 4b			ld a, (.dmark+1)  
4bb2 32 a1 fd			ld (debug_mark+1),a  
4bb5 3a bf 4b			ld a, (.dmark+2)  
4bb8 32 a2 fd			ld (debug_mark+2),a  
4bbb 18 03			jr .pastdmark  
4bbd ..			.dmark: db "CO2"  
4bc0 f1			.pastdmark: pop af  
4bc1			endm  
# End of macro DMARK
4bc1						CALLMONITOR 
4bc1 cd aa fd			call debug_vector  
4bc4				endm  
# End of macro CALLMONITOR
4bc4					endif 
4bc4 ed b0				ldir 
4bc6			 
4bc6			 
4bc6			 
4bc6 21 f6 f0				ld hl, scratch 
4bc9					if DEBUG_FORTH_WORDS 
4bc9						DMARK "CO5" 
4bc9 f5				push af  
4bca 3a de 4b			ld a, (.dmark)  
4bcd 32 a0 fd			ld (debug_mark),a  
4bd0 3a df 4b			ld a, (.dmark+1)  
4bd3 32 a1 fd			ld (debug_mark+1),a  
4bd6 3a e0 4b			ld a, (.dmark+2)  
4bd9 32 a2 fd			ld (debug_mark+2),a  
4bdc 18 03			jr .pastdmark  
4bde ..			.dmark: db "CO5"  
4be1 f1			.pastdmark: pop af  
4be2			endm  
# End of macro DMARK
4be2						CALLMONITOR 
4be2 cd aa fd			call debug_vector  
4be5				endm  
# End of macro CALLMONITOR
4be5					endif 
4be5			 
4be5 cd b6 20				call forth_push_str 
4be8			 
4be8			 
4be8			 
4be8			 
4be8				       NEXTW 
4be8 c3 39 24			jp macro_next 
4beb				endm 
# End of macro NEXTW
4beb			 
4beb			 
4beb			.FIND: 
4beb				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
4beb 4b				db WORD_SYS_CORE+55             
4bec a9 4c			dw .LEN            
4bee 05				db 4 + 1 
4bef .. 00			db "FIND",0              
4bf4				endm 
# End of macro CWHEAD
4bf4			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
4bf4			 
4bf4					if DEBUG_FORTH_WORDS_KEY 
4bf4						DMARK "FND" 
4bf4 f5				push af  
4bf5 3a 09 4c			ld a, (.dmark)  
4bf8 32 a0 fd			ld (debug_mark),a  
4bfb 3a 0a 4c			ld a, (.dmark+1)  
4bfe 32 a1 fd			ld (debug_mark+1),a  
4c01 3a 0b 4c			ld a, (.dmark+2)  
4c04 32 a2 fd			ld (debug_mark+2),a  
4c07 18 03			jr .pastdmark  
4c09 ..			.dmark: db "FND"  
4c0c f1			.pastdmark: pop af  
4c0d			endm  
# End of macro DMARK
4c0d						CALLMONITOR 
4c0d cd aa fd			call debug_vector  
4c10				endm  
# End of macro CALLMONITOR
4c10					endif 
4c10			 
4c10			; TODO check string type 
4c10					FORTH_DSP_VALUE 
4c10 cd 36 22			call macro_forth_dsp_value 
4c13				endm 
# End of macro FORTH_DSP_VALUE
4c13			 
4c13 e5					push hl    
4c14 7e					ld a,(hl)    ; char to find   
4c15			; TODO change char to substr 
4c15			 
4c15 f5					push af 
4c16					 
4c16			 
4c16			 
4c16					if DEBUG_FORTH_WORDS 
4c16						DMARK "FN1" 
4c16 f5				push af  
4c17 3a 2b 4c			ld a, (.dmark)  
4c1a 32 a0 fd			ld (debug_mark),a  
4c1d 3a 2c 4c			ld a, (.dmark+1)  
4c20 32 a1 fd			ld (debug_mark+1),a  
4c23 3a 2d 4c			ld a, (.dmark+2)  
4c26 32 a2 fd			ld (debug_mark+2),a  
4c29 18 03			jr .pastdmark  
4c2b ..			.dmark: db "FN1"  
4c2e f1			.pastdmark: pop af  
4c2f			endm  
# End of macro DMARK
4c2f						CALLMONITOR 
4c2f cd aa fd			call debug_vector  
4c32				endm  
# End of macro CALLMONITOR
4c32					endif 
4c32			 
4c32					FORTH_DSP_POP 
4c32 cd 05 23			call macro_forth_dsp_pop 
4c35				endm 
# End of macro FORTH_DSP_POP
4c35			 
4c35					; string to search 
4c35			 
4c35					FORTH_DSP_VALUE 
4c35 cd 36 22			call macro_forth_dsp_value 
4c38				endm 
# End of macro FORTH_DSP_VALUE
4c38			 
4c38 d1					pop de  ; d is char to find  
4c39			 
4c39					if DEBUG_FORTH_WORDS 
4c39						DMARK "FN2" 
4c39 f5				push af  
4c3a 3a 4e 4c			ld a, (.dmark)  
4c3d 32 a0 fd			ld (debug_mark),a  
4c40 3a 4f 4c			ld a, (.dmark+1)  
4c43 32 a1 fd			ld (debug_mark+1),a  
4c46 3a 50 4c			ld a, (.dmark+2)  
4c49 32 a2 fd			ld (debug_mark+2),a  
4c4c 18 03			jr .pastdmark  
4c4e ..			.dmark: db "FN2"  
4c51 f1			.pastdmark: pop af  
4c52			endm  
# End of macro DMARK
4c52						CALLMONITOR 
4c52 cd aa fd			call debug_vector  
4c55				endm  
# End of macro CALLMONITOR
4c55					endif 
4c55					 
4c55 01 00 00				ld bc, 0 
4c58 7e			.findchar:      ld a,(hl) 
4c59 fe 00				cp 0   		 
4c5b 28 27				jr z, .finddone     
4c5d ba					cp d 
4c5e 28 20				jr z, .foundchar 
4c60 03					inc bc 
4c61 23					inc hl 
4c62					if DEBUG_FORTH_WORDS 
4c62						DMARK "FN3" 
4c62 f5				push af  
4c63 3a 77 4c			ld a, (.dmark)  
4c66 32 a0 fd			ld (debug_mark),a  
4c69 3a 78 4c			ld a, (.dmark+1)  
4c6c 32 a1 fd			ld (debug_mark+1),a  
4c6f 3a 79 4c			ld a, (.dmark+2)  
4c72 32 a2 fd			ld (debug_mark+2),a  
4c75 18 03			jr .pastdmark  
4c77 ..			.dmark: db "FN3"  
4c7a f1			.pastdmark: pop af  
4c7b			endm  
# End of macro DMARK
4c7b						CALLMONITOR 
4c7b cd aa fd			call debug_vector  
4c7e				endm  
# End of macro CALLMONITOR
4c7e					endif 
4c7e 18 d8				jr .findchar 
4c80			 
4c80			 
4c80 c5			.foundchar:	push bc 
4c81 e1					pop hl 
4c82 18 03				jr .findexit 
4c84			 
4c84			 
4c84							 
4c84			 
4c84			.finddone:     ; got to end of string with no find 
4c84 21 00 00				ld hl, 0 
4c87			.findexit: 
4c87			 
4c87					if DEBUG_FORTH_WORDS 
4c87						DMARK "FNd" 
4c87 f5				push af  
4c88 3a 9c 4c			ld a, (.dmark)  
4c8b 32 a0 fd			ld (debug_mark),a  
4c8e 3a 9d 4c			ld a, (.dmark+1)  
4c91 32 a1 fd			ld (debug_mark+1),a  
4c94 3a 9e 4c			ld a, (.dmark+2)  
4c97 32 a2 fd			ld (debug_mark+2),a  
4c9a 18 03			jr .pastdmark  
4c9c ..			.dmark: db "FNd"  
4c9f f1			.pastdmark: pop af  
4ca0			endm  
# End of macro DMARK
4ca0						CALLMONITOR 
4ca0 cd aa fd			call debug_vector  
4ca3				endm  
# End of macro CALLMONITOR
4ca3					endif 
4ca3 cd 48 20			call forth_push_numhl 
4ca6			 
4ca6				       NEXTW 
4ca6 c3 39 24			jp macro_next 
4ca9				endm 
# End of macro NEXTW
4ca9			 
4ca9			.LEN: 
4ca9				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
4ca9 4c				db WORD_SYS_CORE+56             
4caa 13 4d			dw .ASC            
4cac 06				db 5 + 1 
4cad .. 00			db "COUNT",0              
4cb3				endm 
# End of macro CWHEAD
4cb3			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
4cb3			 
4cb3					if DEBUG_FORTH_WORDS_KEY 
4cb3						DMARK "CNT" 
4cb3 f5				push af  
4cb4 3a c8 4c			ld a, (.dmark)  
4cb7 32 a0 fd			ld (debug_mark),a  
4cba 3a c9 4c			ld a, (.dmark+1)  
4cbd 32 a1 fd			ld (debug_mark+1),a  
4cc0 3a ca 4c			ld a, (.dmark+2)  
4cc3 32 a2 fd			ld (debug_mark+2),a  
4cc6 18 03			jr .pastdmark  
4cc8 ..			.dmark: db "CNT"  
4ccb f1			.pastdmark: pop af  
4ccc			endm  
# End of macro DMARK
4ccc						CALLMONITOR 
4ccc cd aa fd			call debug_vector  
4ccf				endm  
# End of macro CALLMONITOR
4ccf					endif 
4ccf			; TODO check string type 
4ccf					FORTH_DSP_VALUE 
4ccf cd 36 22			call macro_forth_dsp_value 
4cd2				endm 
# End of macro FORTH_DSP_VALUE
4cd2			 
4cd2			 
4cd2					if DEBUG_FORTH_WORDS 
4cd2						DMARK "CN?" 
4cd2 f5				push af  
4cd3 3a e7 4c			ld a, (.dmark)  
4cd6 32 a0 fd			ld (debug_mark),a  
4cd9 3a e8 4c			ld a, (.dmark+1)  
4cdc 32 a1 fd			ld (debug_mark+1),a  
4cdf 3a e9 4c			ld a, (.dmark+2)  
4ce2 32 a2 fd			ld (debug_mark+2),a  
4ce5 18 03			jr .pastdmark  
4ce7 ..			.dmark: db "CN?"  
4cea f1			.pastdmark: pop af  
4ceb			endm  
# End of macro DMARK
4ceb						CALLMONITOR 
4ceb cd aa fd			call debug_vector  
4cee				endm  
# End of macro CALLMONITOR
4cee					endif 
4cee cd 44 13				call strlenz 
4cf1					if DEBUG_FORTH_WORDS 
4cf1						DMARK "CNl" 
4cf1 f5				push af  
4cf2 3a 06 4d			ld a, (.dmark)  
4cf5 32 a0 fd			ld (debug_mark),a  
4cf8 3a 07 4d			ld a, (.dmark+1)  
4cfb 32 a1 fd			ld (debug_mark+1),a  
4cfe 3a 08 4d			ld a, (.dmark+2)  
4d01 32 a2 fd			ld (debug_mark+2),a  
4d04 18 03			jr .pastdmark  
4d06 ..			.dmark: db "CNl"  
4d09 f1			.pastdmark: pop af  
4d0a			endm  
# End of macro DMARK
4d0a						CALLMONITOR 
4d0a cd aa fd			call debug_vector  
4d0d				endm  
# End of macro CALLMONITOR
4d0d					endif 
4d0d			 
4d0d cd 48 20				call forth_push_numhl 
4d10			 
4d10			 
4d10			 
4d10				       NEXTW 
4d10 c3 39 24			jp macro_next 
4d13				endm 
# End of macro NEXTW
4d13			.ASC: 
4d13				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
4d13 4d				db WORD_SYS_CORE+57             
4d14 81 4d			dw .CHR            
4d16 04				db 3 + 1 
4d17 .. 00			db "ASC",0              
4d1b				endm 
# End of macro CWHEAD
4d1b			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
4d1b					if DEBUG_FORTH_WORDS_KEY 
4d1b						DMARK "ASC" 
4d1b f5				push af  
4d1c 3a 30 4d			ld a, (.dmark)  
4d1f 32 a0 fd			ld (debug_mark),a  
4d22 3a 31 4d			ld a, (.dmark+1)  
4d25 32 a1 fd			ld (debug_mark+1),a  
4d28 3a 32 4d			ld a, (.dmark+2)  
4d2b 32 a2 fd			ld (debug_mark+2),a  
4d2e 18 03			jr .pastdmark  
4d30 ..			.dmark: db "ASC"  
4d33 f1			.pastdmark: pop af  
4d34			endm  
# End of macro DMARK
4d34						CALLMONITOR 
4d34 cd aa fd			call debug_vector  
4d37				endm  
# End of macro CALLMONITOR
4d37					endif 
4d37					FORTH_DSP_VALUE 
4d37 cd 36 22			call macro_forth_dsp_value 
4d3a				endm 
# End of macro FORTH_DSP_VALUE
4d3a					;v5 FORTH_DSP_VALUE 
4d3a			;		inc hl      ; now at start of numeric as string 
4d3a			 
4d3a e5					push hl 
4d3b			 
4d3b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4d3b cd 05 23			call macro_forth_dsp_pop 
4d3e				endm 
# End of macro FORTH_DSP_POP
4d3e			 
4d3e e1					pop hl 
4d3f			 
4d3f					if DEBUG_FORTH_WORDS 
4d3f						DMARK "AS1" 
4d3f f5				push af  
4d40 3a 54 4d			ld a, (.dmark)  
4d43 32 a0 fd			ld (debug_mark),a  
4d46 3a 55 4d			ld a, (.dmark+1)  
4d49 32 a1 fd			ld (debug_mark+1),a  
4d4c 3a 56 4d			ld a, (.dmark+2)  
4d4f 32 a2 fd			ld (debug_mark+2),a  
4d52 18 03			jr .pastdmark  
4d54 ..			.dmark: db "AS1"  
4d57 f1			.pastdmark: pop af  
4d58			endm  
# End of macro DMARK
4d58						CALLMONITOR 
4d58 cd aa fd			call debug_vector  
4d5b				endm  
# End of macro CALLMONITOR
4d5b					endif 
4d5b					; push the content of a onto the stack as a value 
4d5b			 
4d5b 7e					ld a,(hl)   ; get char 
4d5c 26 00				ld h,0 
4d5e 6f					ld l,a 
4d5f					if DEBUG_FORTH_WORDS 
4d5f						DMARK "AS2" 
4d5f f5				push af  
4d60 3a 74 4d			ld a, (.dmark)  
4d63 32 a0 fd			ld (debug_mark),a  
4d66 3a 75 4d			ld a, (.dmark+1)  
4d69 32 a1 fd			ld (debug_mark+1),a  
4d6c 3a 76 4d			ld a, (.dmark+2)  
4d6f 32 a2 fd			ld (debug_mark+2),a  
4d72 18 03			jr .pastdmark  
4d74 ..			.dmark: db "AS2"  
4d77 f1			.pastdmark: pop af  
4d78			endm  
# End of macro DMARK
4d78						CALLMONITOR 
4d78 cd aa fd			call debug_vector  
4d7b				endm  
# End of macro CALLMONITOR
4d7b					endif 
4d7b cd 48 20				call forth_push_numhl 
4d7e			 
4d7e				       NEXTW 
4d7e c3 39 24			jp macro_next 
4d81				endm 
# End of macro NEXTW
4d81			 
4d81			.CHR: 
4d81				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
4d81 4d				db WORD_SYS_CORE+57             
4d82 bd 4d			dw .ENDSTR            
4d84 04				db 3 + 1 
4d85 .. 00			db "CHR",0              
4d89				endm 
# End of macro CWHEAD
4d89			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
4d89					if DEBUG_FORTH_WORDS_KEY 
4d89						DMARK "CHR" 
4d89 f5				push af  
4d8a 3a 9e 4d			ld a, (.dmark)  
4d8d 32 a0 fd			ld (debug_mark),a  
4d90 3a 9f 4d			ld a, (.dmark+1)  
4d93 32 a1 fd			ld (debug_mark+1),a  
4d96 3a a0 4d			ld a, (.dmark+2)  
4d99 32 a2 fd			ld (debug_mark+2),a  
4d9c 18 03			jr .pastdmark  
4d9e ..			.dmark: db "CHR"  
4da1 f1			.pastdmark: pop af  
4da2			endm  
# End of macro DMARK
4da2						CALLMONITOR 
4da2 cd aa fd			call debug_vector  
4da5				endm  
# End of macro CALLMONITOR
4da5					endif 
4da5					FORTH_DSP_VALUEHL 
4da5 cd 4d 22			call macro_dsp_valuehl 
4da8				endm 
# End of macro FORTH_DSP_VALUEHL
4da8			 
4da8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4da8 cd 05 23			call macro_forth_dsp_pop 
4dab				endm 
# End of macro FORTH_DSP_POP
4dab			 
4dab					; save asci byte as a zero term string and push string 
4dab			 
4dab 7d					ld a,l 
4dac 32 f6 f0				ld (scratch), a 
4daf			 
4daf 3e 00				ld a, 0 
4db1 32 f7 f0				ld (scratch+1), a 
4db4			 
4db4 21 f6 f0				ld hl, scratch 
4db7 cd b6 20				call forth_push_str 
4dba			 
4dba			 
4dba				       NEXTW 
4dba c3 39 24			jp macro_next 
4dbd				endm 
# End of macro NEXTW
4dbd			 
4dbd			 
4dbd			 
4dbd			 
4dbd			.ENDSTR: 
4dbd			; eof 
4dbd			 
# End of file forth_words_str.asm
4dbd			include "forth_words_key.asm" 
4dbd			 
4dbd			; | ## Keyboard Words 
4dbd			 
4dbd			.KEY: 
4dbd				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4dbd 3e				db WORD_SYS_CORE+42             
4dbe ed 4d			dw .WAITK            
4dc0 04				db 3 + 1 
4dc1 .. 00			db "KEY",0              
4dc5				endm 
# End of macro CWHEAD
4dc5			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
4dc5			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
4dc5			; | | Can use something like this to process: 
4dc5			; | | > repeat active . key ?dup if emit then #1 until  
4dc5			 
4dc5					if DEBUG_FORTH_WORDS_KEY 
4dc5						DMARK "KEY" 
4dc5 f5				push af  
4dc6 3a da 4d			ld a, (.dmark)  
4dc9 32 a0 fd			ld (debug_mark),a  
4dcc 3a db 4d			ld a, (.dmark+1)  
4dcf 32 a1 fd			ld (debug_mark+1),a  
4dd2 3a dc 4d			ld a, (.dmark+2)  
4dd5 32 a2 fd			ld (debug_mark+2),a  
4dd8 18 03			jr .pastdmark  
4dda ..			.dmark: db "KEY"  
4ddd f1			.pastdmark: pop af  
4dde			endm  
# End of macro DMARK
4dde						CALLMONITOR 
4dde cd aa fd			call debug_vector  
4de1				endm  
# End of macro CALLMONITOR
4de1					endif 
4de1			; TODO currently waits 
4de1 cd 93 74				call cin 
4de4					;call cin_wait 
4de4 6f					ld l, a 
4de5 26 00				ld h, 0 
4de7 cd 48 20				call forth_push_numhl 
4dea					NEXTW 
4dea c3 39 24			jp macro_next 
4ded				endm 
# End of macro NEXTW
4ded			.WAITK: 
4ded				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4ded 3f				db WORD_SYS_CORE+43             
4dee 1f 4e			dw .ACCEPT            
4df0 06				db 5 + 1 
4df1 .. 00			db "WAITK",0              
4df7				endm 
# End of macro CWHEAD
4df7			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
4df7					if DEBUG_FORTH_WORDS_KEY 
4df7						DMARK "WAI" 
4df7 f5				push af  
4df8 3a 0c 4e			ld a, (.dmark)  
4dfb 32 a0 fd			ld (debug_mark),a  
4dfe 3a 0d 4e			ld a, (.dmark+1)  
4e01 32 a1 fd			ld (debug_mark+1),a  
4e04 3a 0e 4e			ld a, (.dmark+2)  
4e07 32 a2 fd			ld (debug_mark+2),a  
4e0a 18 03			jr .pastdmark  
4e0c ..			.dmark: db "WAI"  
4e0f f1			.pastdmark: pop af  
4e10			endm  
# End of macro DMARK
4e10						CALLMONITOR 
4e10 cd aa fd			call debug_vector  
4e13				endm  
# End of macro CALLMONITOR
4e13					endif 
4e13 cd 82 74				call cin_wait 
4e16 6f					ld l, a 
4e17 26 00				ld h, 0 
4e19 cd 48 20				call forth_push_numhl 
4e1c					NEXTW 
4e1c c3 39 24			jp macro_next 
4e1f				endm 
# End of macro NEXTW
4e1f			.ACCEPT: 
4e1f				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4e1f 40				db WORD_SYS_CORE+44             
4e20 7d 4e			dw .EDIT            
4e22 07				db 6 + 1 
4e23 .. 00			db "ACCEPT",0              
4e2a				endm 
# End of macro CWHEAD
4e2a			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4e2a					; TODO crashes on push 
4e2a					if DEBUG_FORTH_WORDS_KEY 
4e2a						DMARK "ACC" 
4e2a f5				push af  
4e2b 3a 3f 4e			ld a, (.dmark)  
4e2e 32 a0 fd			ld (debug_mark),a  
4e31 3a 40 4e			ld a, (.dmark+1)  
4e34 32 a1 fd			ld (debug_mark+1),a  
4e37 3a 41 4e			ld a, (.dmark+2)  
4e3a 32 a2 fd			ld (debug_mark+2),a  
4e3d 18 03			jr .pastdmark  
4e3f ..			.dmark: db "ACC"  
4e42 f1			.pastdmark: pop af  
4e43			endm  
# End of macro DMARK
4e43						CALLMONITOR 
4e43 cd aa fd			call debug_vector  
4e46				endm  
# End of macro CALLMONITOR
4e46					endif 
4e46 21 f4 f2				ld hl, os_input 
4e49 3e 00				ld a, 0 
4e4b 77					ld (hl),a 
4e4c 3a 93 f9				ld a,(f_cursor_ptr) 
4e4f 16 64				ld d, 100 
4e51 0e 00				ld c, 0 
4e53 1e 28				ld e, 40 
4e55 cd 0b 10				call input_str 
4e58					; TODO perhaps do a type check and wrap in quotes if not a number 
4e58 21 f4 f2				ld hl, os_input 
4e5b					if DEBUG_FORTH_WORDS 
4e5b						DMARK "AC1" 
4e5b f5				push af  
4e5c 3a 70 4e			ld a, (.dmark)  
4e5f 32 a0 fd			ld (debug_mark),a  
4e62 3a 71 4e			ld a, (.dmark+1)  
4e65 32 a1 fd			ld (debug_mark+1),a  
4e68 3a 72 4e			ld a, (.dmark+2)  
4e6b 32 a2 fd			ld (debug_mark+2),a  
4e6e 18 03			jr .pastdmark  
4e70 ..			.dmark: db "AC1"  
4e73 f1			.pastdmark: pop af  
4e74			endm  
# End of macro DMARK
4e74						CALLMONITOR 
4e74 cd aa fd			call debug_vector  
4e77				endm  
# End of macro CALLMONITOR
4e77					endif 
4e77 cd b6 20				call forth_push_str 
4e7a					NEXTW 
4e7a c3 39 24			jp macro_next 
4e7d				endm 
# End of macro NEXTW
4e7d			 
4e7d			.EDIT: 
4e7d				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
4e7d 40				db WORD_SYS_CORE+44             
4e7e 1f 4f			dw .DEDIT            
4e80 05				db 4 + 1 
4e81 .. 00			db "EDIT",0              
4e86				endm 
# End of macro CWHEAD
4e86			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4e86			 
4e86					; TODO does not copy from stack 
4e86					if DEBUG_FORTH_WORDS_KEY 
4e86						DMARK "EDT" 
4e86 f5				push af  
4e87 3a 9b 4e			ld a, (.dmark)  
4e8a 32 a0 fd			ld (debug_mark),a  
4e8d 3a 9c 4e			ld a, (.dmark+1)  
4e90 32 a1 fd			ld (debug_mark+1),a  
4e93 3a 9d 4e			ld a, (.dmark+2)  
4e96 32 a2 fd			ld (debug_mark+2),a  
4e99 18 03			jr .pastdmark  
4e9b ..			.dmark: db "EDT"  
4e9e f1			.pastdmark: pop af  
4e9f			endm  
# End of macro DMARK
4e9f						CALLMONITOR 
4e9f cd aa fd			call debug_vector  
4ea2				endm  
# End of macro CALLMONITOR
4ea2					endif 
4ea2			 
4ea2					;FORTH_DSP 
4ea2					FORTH_DSP_VALUEHL 
4ea2 cd 4d 22			call macro_dsp_valuehl 
4ea5				endm 
# End of macro FORTH_DSP_VALUEHL
4ea5			;		inc hl    ; TODO do type check 
4ea5			 
4ea5			;		call get_word_hl 
4ea5 e5					push hl 
4ea6					if DEBUG_FORTH_WORDS 
4ea6						DMARK "EDp" 
4ea6 f5				push af  
4ea7 3a bb 4e			ld a, (.dmark)  
4eaa 32 a0 fd			ld (debug_mark),a  
4ead 3a bc 4e			ld a, (.dmark+1)  
4eb0 32 a1 fd			ld (debug_mark+1),a  
4eb3 3a bd 4e			ld a, (.dmark+2)  
4eb6 32 a2 fd			ld (debug_mark+2),a  
4eb9 18 03			jr .pastdmark  
4ebb ..			.dmark: db "EDp"  
4ebe f1			.pastdmark: pop af  
4ebf			endm  
# End of macro DMARK
4ebf						CALLMONITOR 
4ebf cd aa fd			call debug_vector  
4ec2				endm  
# End of macro CALLMONITOR
4ec2					endif 
4ec2				;	ld a, 0 
4ec2 cd 44 13				call strlenz 
4ec5 23					inc hl 
4ec6			 
4ec6 06 00				ld b, 0 
4ec8 4d					ld c, l 
4ec9			 
4ec9 e1					pop hl 
4eca 11 f4 f2				ld de, os_input 
4ecd					if DEBUG_FORTH_WORDS_KEY 
4ecd						DMARK "EDc" 
4ecd f5				push af  
4ece 3a e2 4e			ld a, (.dmark)  
4ed1 32 a0 fd			ld (debug_mark),a  
4ed4 3a e3 4e			ld a, (.dmark+1)  
4ed7 32 a1 fd			ld (debug_mark+1),a  
4eda 3a e4 4e			ld a, (.dmark+2)  
4edd 32 a2 fd			ld (debug_mark+2),a  
4ee0 18 03			jr .pastdmark  
4ee2 ..			.dmark: db "EDc"  
4ee5 f1			.pastdmark: pop af  
4ee6			endm  
# End of macro DMARK
4ee6						CALLMONITOR 
4ee6 cd aa fd			call debug_vector  
4ee9				endm  
# End of macro CALLMONITOR
4ee9					endif 
4ee9 ed b0				ldir 
4eeb			 
4eeb			 
4eeb 21 f4 f2				ld hl, os_input 
4eee					;ld a, 0 
4eee					;ld (hl),a 
4eee 3a 93 f9				ld a,(f_cursor_ptr) 
4ef1 16 64				ld d, 100 
4ef3 0e 00				ld c, 0 
4ef5 1e 28				ld e, 40 
4ef7 cd 0b 10				call input_str 
4efa					; TODO perhaps do a type check and wrap in quotes if not a number 
4efa 21 f4 f2				ld hl, os_input 
4efd					if DEBUG_FORTH_WORDS 
4efd						DMARK "ED1" 
4efd f5				push af  
4efe 3a 12 4f			ld a, (.dmark)  
4f01 32 a0 fd			ld (debug_mark),a  
4f04 3a 13 4f			ld a, (.dmark+1)  
4f07 32 a1 fd			ld (debug_mark+1),a  
4f0a 3a 14 4f			ld a, (.dmark+2)  
4f0d 32 a2 fd			ld (debug_mark+2),a  
4f10 18 03			jr .pastdmark  
4f12 ..			.dmark: db "ED1"  
4f15 f1			.pastdmark: pop af  
4f16			endm  
# End of macro DMARK
4f16						CALLMONITOR 
4f16 cd aa fd			call debug_vector  
4f19				endm  
# End of macro CALLMONITOR
4f19					endif 
4f19 cd b6 20				call forth_push_str 
4f1c					NEXTW 
4f1c c3 39 24			jp macro_next 
4f1f				endm 
# End of macro NEXTW
4f1f			 
4f1f			.DEDIT: 
4f1f				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
4f1f 40				db WORD_SYS_CORE+44             
4f20 81 4f			dw .ENDKEY            
4f22 06				db 5 + 1 
4f23 .. 00			db "DEDIT",0              
4f29				endm 
# End of macro CWHEAD
4f29			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | DONE 
4f29			 
4f29					; TODO does not copy from stack 
4f29					if DEBUG_FORTH_WORDS_KEY 
4f29						DMARK "DED" 
4f29 f5				push af  
4f2a 3a 3e 4f			ld a, (.dmark)  
4f2d 32 a0 fd			ld (debug_mark),a  
4f30 3a 3f 4f			ld a, (.dmark+1)  
4f33 32 a1 fd			ld (debug_mark+1),a  
4f36 3a 40 4f			ld a, (.dmark+2)  
4f39 32 a2 fd			ld (debug_mark+2),a  
4f3c 18 03			jr .pastdmark  
4f3e ..			.dmark: db "DED"  
4f41 f1			.pastdmark: pop af  
4f42			endm  
# End of macro DMARK
4f42						CALLMONITOR 
4f42 cd aa fd			call debug_vector  
4f45				endm  
# End of macro CALLMONITOR
4f45					endif 
4f45			 
4f45					;FORTH_DSP 
4f45					FORTH_DSP_VALUEHL 
4f45 cd 4d 22			call macro_dsp_valuehl 
4f48				endm 
# End of macro FORTH_DSP_VALUEHL
4f48			;		inc hl    ; TODO do type check 
4f48			 
4f48			;		call get_word_hl 
4f48 e5					push hl 
4f49 e5					push hl 
4f4a					FORTH_DSP_POP 
4f4a cd 05 23			call macro_forth_dsp_pop 
4f4d				endm 
# End of macro FORTH_DSP_POP
4f4d e1					pop hl 
4f4e					if DEBUG_FORTH_WORDS 
4f4e						DMARK "EDp" 
4f4e f5				push af  
4f4f 3a 63 4f			ld a, (.dmark)  
4f52 32 a0 fd			ld (debug_mark),a  
4f55 3a 64 4f			ld a, (.dmark+1)  
4f58 32 a1 fd			ld (debug_mark+1),a  
4f5b 3a 65 4f			ld a, (.dmark+2)  
4f5e 32 a2 fd			ld (debug_mark+2),a  
4f61 18 03			jr .pastdmark  
4f63 ..			.dmark: db "EDp"  
4f66 f1			.pastdmark: pop af  
4f67			endm  
# End of macro DMARK
4f67						CALLMONITOR 
4f67 cd aa fd			call debug_vector  
4f6a				endm  
# End of macro CALLMONITOR
4f6a					endif 
4f6a				;	ld a, 0 
4f6a cd 44 13				call strlenz 
4f6d 23					inc hl 
4f6e			 
4f6e 06 00				ld b, 0 
4f70 4d					ld c, l 
4f71			 
4f71 e1					pop hl 
4f72			 
4f72					;ld a, 0 
4f72					;ld (hl),a 
4f72 3a 93 f9				ld a,(f_cursor_ptr) 
4f75 16 64				ld d, 100 
4f77 0e 00				ld c, 0 
4f79 1e 28				ld e, 40 
4f7b cd 0b 10				call input_str 
4f7e					; TODO perhaps do a type check and wrap in quotes if not a number 
4f7e					NEXTW 
4f7e c3 39 24			jp macro_next 
4f81				endm 
# End of macro NEXTW
4f81			 
4f81			 
4f81			.ENDKEY: 
4f81			; eof 
4f81			 
# End of file forth_words_key.asm
4f81			include "forth_words_const.asm" 
4f81			 
4f81			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
4f81			 
4f81			 
4f81			.SPITIME: 
4f81				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
4f81 77				db WORD_SYS_CORE+99             
4f82 96 4f			dw .VA            
4f84 08				db 7 + 1 
4f85 .. 00			db "SPITIME",0              
4f8d				endm 
# End of macro CWHEAD
4f8d			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
4f8d			; 
4f8d			; | | If using BANK devices then leave as is. 
4f8d			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
4f8d			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
4f8d			 
4f8d 21 99 f9				ld hl, spi_clktime  
4f90 cd 48 20				call forth_push_numhl 
4f93			 
4f93					NEXTW 
4f93 c3 39 24			jp macro_next 
4f96				endm 
# End of macro NEXTW
4f96			 
4f96			 
4f96			.VA: 
4f96				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
4f96 77				db WORD_SYS_CORE+99             
4f97 a6 4f			dw .SYMBOL            
4f99 03				db 2 + 1 
4f9a .. 00			db "VA",0              
4f9d				endm 
# End of macro CWHEAD
4f9d			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
4f9d 21 5d f9				ld hl, cli_var_array 
4fa0 cd 48 20				call forth_push_numhl 
4fa3			 
4fa3					NEXTW 
4fa3 c3 39 24			jp macro_next 
4fa6				endm 
# End of macro NEXTW
4fa6			 
4fa6			.SYMBOL: 
4fa6				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
4fa6 77				db WORD_SYS_CORE+99             
4fa7 b0 50			dw .ENDCONST            
4fa9 07				db 6 + 1 
4faa .. 00			db "SYMBOL",0              
4fb1				endm 
# End of macro CWHEAD
4fb1			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
4fb1			; | 
4fb1			; | | The value is the number reference and the final address is pushed to stack 
4fb1			 
4fb1			; | | ``` 
4fb1			; | | dw sym_table 
4fb1			; | | dw nmi_vector 
4fb1			; | | dw cli_autodisplay 
4fb1			; | | dw cli_data_sp 
4fb1			; | | dw cli_data_stack 
4fb1			; | | dw cli_loop_sp 
4fb1			; | | dw cli_loop_stack 
4fb1			; | | dw cli_var_array 
4fb1			; | | dw cursor_col 
4fb1			; | | dw cursor_ptr 
4fb1			; | | ; 10 
4fb1			; | | dw cursor_row 
4fb1			; | | dw debug_mark 
4fb1			; | | dw display_fb0 
4fb1			; | | dw display_fb1 
4fb1			; | | dw display_fb2 
4fb1			; | | dw display_fb3 
4fb1			; | | dw display_fb_active 
4fb1			; | | dw execscratch 
4fb1			; | | dw f_cursor_ptr 
4fb1			; | | dw hardware_word 
4fb1			; | | ;20 
4fb1			; | | dw input_at_cursor 
4fb1			; | | dw input_at_pos 
4fb1			; | | dw input_cur_flash 
4fb1			; | | dw input_cur_onoff 
4fb1			; | | dw input_cursor 
4fb1			; | | dw input_display_size 
4fb1			; | | dw input_len 
4fb1			; | | dw input_ptr 
4fb1			; | | dw input_size 
4fb1			; | | dw input_start 
4fb1			; | | ; 30 
4fb1			; | | dw input_str 
4fb1			; | | dw input_under_cursor 
4fb1			; | | dw os_cli_cmd 
4fb1			; | | dw os_cur_ptr 
4fb1			; | | dw os_current_i 
4fb1			; | | dw os_input 
4fb1			; | | dw os_last_cmd 
4fb1			; | | dw os_last_new_uword 
4fb1			; | | dw debug_vector 
4fb1			; | | dw os_view_hl 
4fb1			; | | ;40 
4fb1			; | | dw os_word_scratch 
4fb1			; | | dw portbctl 
4fb1			; | | dw portbdata 
4fb1			; | | dw spi_cartdev 
4fb1			; | | dw spi_cartdev2 
4fb1			; | | dw spi_clktime 
4fb1			; | | dw spi_device 
4fb1			; | | dw spi_device_id 
4fb1			; | | dw spi_portbyte 
4fb1			; | | dw stackstore 
4fb1			; | | ; 50 
4fb1			; | | if STORAGE_SE 
4fb1			; | | dw storage_actl 
4fb1			; | | dw storage_adata 
4fb1			; | | else 
4fb1			; | | dw 0 
4fb1			; | | dw 0 
4fb1			; | | endif 
4fb1			; | | dw storage_append 
4fb1			; | | if STORAGE_SE 
4fb1			; | | dw storage_bctl 
4fb1			; | | else 
4fb1			; | | dw 0 
4fb1			; | | endif 
4fb1			; | | dw store_bank_active 
4fb1			; | | dw store_filecache 
4fb1			; | | dw store_longread 
4fb1			; | | dw store_openaddr 
4fb1			; | | dw store_openext 
4fb1			; | | dw store_openmaxext 
4fb1			; | | ; 60 
4fb1			; | | dw store_page 
4fb1			; | | dw store_readbuf 
4fb1			; | | dw store_readcont 
4fb1			; | | dw store_readptr 
4fb1			; | | dw store_tmpext 
4fb1			; | | dw store_tmpid 
4fb1			; | | dw store_tmppageid 
4fb1			; | | dw malloc 
4fb1			; | | dw free 
4fb1			; | | dw cin 
4fb1			; | | ; 70 
4fb1			; | | dw cin_wait 
4fb1			; | | dw forth_push_numhl 
4fb1			; | | dw forth_push_str 
4fb1			; | | ``` 
4fb1			 
4fb1					if DEBUG_FORTH_WORDS_KEY 
4fb1						DMARK "SYM" 
4fb1 f5				push af  
4fb2 3a c6 4f			ld a, (.dmark)  
4fb5 32 a0 fd			ld (debug_mark),a  
4fb8 3a c7 4f			ld a, (.dmark+1)  
4fbb 32 a1 fd			ld (debug_mark+1),a  
4fbe 3a c8 4f			ld a, (.dmark+2)  
4fc1 32 a2 fd			ld (debug_mark+2),a  
4fc4 18 03			jr .pastdmark  
4fc6 ..			.dmark: db "SYM"  
4fc9 f1			.pastdmark: pop af  
4fca			endm  
# End of macro DMARK
4fca						CALLMONITOR 
4fca cd aa fd			call debug_vector  
4fcd				endm  
# End of macro CALLMONITOR
4fcd					endif 
4fcd			 
4fcd					FORTH_DSP_VALUEHL 
4fcd cd 4d 22			call macro_dsp_valuehl 
4fd0				endm 
# End of macro FORTH_DSP_VALUEHL
4fd0			 
4fd0 7d					ld a, l     
4fd1			 
4fd1			 
4fd1					if DEBUG_FORTH_WORDS 
4fd1						DMARK "SY1" 
4fd1 f5				push af  
4fd2 3a e6 4f			ld a, (.dmark)  
4fd5 32 a0 fd			ld (debug_mark),a  
4fd8 3a e7 4f			ld a, (.dmark+1)  
4fdb 32 a1 fd			ld (debug_mark+1),a  
4fde 3a e8 4f			ld a, (.dmark+2)  
4fe1 32 a2 fd			ld (debug_mark+2),a  
4fe4 18 03			jr .pastdmark  
4fe6 ..			.dmark: db "SY1"  
4fe9 f1			.pastdmark: pop af  
4fea			endm  
# End of macro DMARK
4fea						CALLMONITOR 
4fea cd aa fd			call debug_vector  
4fed				endm  
# End of macro CALLMONITOR
4fed					endif 
4fed					 
4fed f5					push af	 
4fee					FORTH_DSP_POP 
4fee cd 05 23			call macro_forth_dsp_pop 
4ff1				endm 
# End of macro FORTH_DSP_POP
4ff1 f1					pop af 
4ff2			 
4ff2 cb 27				sla a  
4ff4				 
4ff4					 
4ff4					if DEBUG_FORTH_WORDS 
4ff4						DMARK "SY" 
4ff4 f5				push af  
4ff5 3a 09 50			ld a, (.dmark)  
4ff8 32 a0 fd			ld (debug_mark),a  
4ffb 3a 0a 50			ld a, (.dmark+1)  
4ffe 32 a1 fd			ld (debug_mark+1),a  
5001 3a 0b 50			ld a, (.dmark+2)  
5004 32 a2 fd			ld (debug_mark+2),a  
5007 18 02			jr .pastdmark  
5009 ..			.dmark: db "SY"  
500b f1			.pastdmark: pop af  
500c			endm  
# End of macro DMARK
500c						CALLMONITOR 
500c cd aa fd			call debug_vector  
500f				endm  
# End of macro CALLMONITOR
500f					endif 
500f			 
500f 21 1e 50				ld hl, sym_table 
5012 cd de 0f				call addatohl 
5015 cd bb 23				call loadwordinhl 
5018 cd 48 20				call forth_push_numhl 
501b			 
501b			 
501b				       NEXTW 
501b c3 39 24			jp macro_next 
501e				endm 
# End of macro NEXTW
501e			 
501e			sym_table: 
501e			 
501e			; 0 
501e 1e 50		dw sym_table 
5020 ad fd		dw nmi_vector 
5022 71 f9		dw cli_autodisplay 
5024 23 f9		dw cli_data_sp 
5026 5d f6		dw cli_data_stack 
5028 25 f9		dw cli_loop_sp 
502a 5f f8		dw cli_loop_stack 
502c 5d f9		dw cli_var_array 
502e fa fa		dw cursor_col 
5030 f8 fa		dw cursor_ptr 
5032			; 10 
5032 f9 fa		dw cursor_row 
5034 a0 fd		dw debug_mark 
5036 e6 fc		dw display_fb0 
5038 45 fc		dw display_fb1 
503a 03 fb		dw display_fb2 
503c a4 fb		dw display_fb3 
503e 01 fb		dw display_fb_active 
5040 f5 f1		dw execscratch 
5042 93 f9		dw f_cursor_ptr 
5044 b0 fd		dw hardware_word 
5046			;20 
5046 97 fd		dw input_at_cursor 
5048 99 fd		dw input_at_pos 
504a 95 fd		dw input_cur_flash 
504c 94 fd		dw input_cur_onoff 
504e 8a fd		dw input_cursor 
5050 9a fd		dw input_display_size 
5052 8f fd		dw input_len 
5054 9e fd		dw input_ptr 
5056 9b fd		dw input_size 
5058 9c fd		dw input_start 
505a			; 30 
505a 0b 10		dw input_str 
505c 98 fd		dw input_under_cursor 
505e 1d f4		dw os_cli_cmd 
5060 19 f4		dw os_cur_ptr 
5062 1b f4		dw os_current_i 
5064 f4 f2		dw os_input 
5066 1c f5		dw os_last_cmd 
5068 f3 f3		dw os_last_new_uword 
506a aa fd		dw debug_vector 
506c d8 f0		dw os_view_hl 
506e			;40 
506e fb f3		dw os_word_scratch 
5070 c3 00		dw portbctl 
5072 c1 00		dw portbdata 
5074 98 f9		dw spi_cartdev 
5076 97 f9		dw spi_cartdev2 
5078 99 f9		dw spi_clktime 
507a 95 f9		dw spi_device 
507c 94 f9		dw spi_device_id 
507e 96 f9		dw spi_portbyte 
5080 dc fa		dw stackstore 
5082			; 50 
5082			if STORAGE_SE 
5082 82 00		dw storage_actl 
5084 80 00		dw storage_adata 
5086			else 
5086			dw 0 
5086			dw 0 
5086			endif 
5086 64 0b		dw storage_append 
5088			if STORAGE_SE 
5088 83 00		dw storage_bctl 
508a			else 
508a			dw 0 
508a			endif 
508a c8 fa		dw store_bank_active 
508c 9c f9		dw store_filecache 
508e aa f9		dw store_longread 
5090 a0 f9		dw store_openaddr 
5092 9f f9		dw store_openext 
5094 9e f9		dw store_openmaxext 
5096			; 60 
5096 af f9		dw store_page 
5098 ab f9		dw store_readbuf 
509a a2 f9		dw store_readcont 
509c ad f9		dw store_readptr 
509e a2 f9		dw store_tmpext 
50a0 a3 f9		dw store_tmpid 
50a2 9a f9		dw store_tmppageid 
50a4 b9 13		dw malloc 
50a6 83 14		dw free 
50a8 93 74		dw cin 
50aa			; 70 
50aa 82 74		dw cin_wait 
50ac 48 20		dw forth_push_numhl 
50ae b6 20		dw forth_push_str 
50b0			 
50b0			 
50b0			.ENDCONST: 
50b0			 
50b0			; eof 
50b0			 
50b0			 
# End of file forth_words_const.asm
50b0			 
50b0			if STORAGE_SE 
50b0			   	include "forth_words_storage.asm" 
50b0			 
50b0			; | ## Fixed Storage Words 
50b0			 
50b0			.RENAME: 
50b0			  
50b0				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
50b0 3a				db WORD_SYS_CORE+38             
50b1 a6 51			dw .RECORD            
50b3 07				db 6 + 1 
50b4 .. 00			db "RENAME",0              
50bb				endm 
# End of macro CWHEAD
50bb			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
50bb			; | | > [!NOTE] 
50bb			; | | > Compatible with PicoSPINet  
50bb					if DEBUG_FORTH_WORDS_KEY 
50bb						DMARK "REN" 
50bb f5				push af  
50bc 3a d0 50			ld a, (.dmark)  
50bf 32 a0 fd			ld (debug_mark),a  
50c2 3a d1 50			ld a, (.dmark+1)  
50c5 32 a1 fd			ld (debug_mark+1),a  
50c8 3a d2 50			ld a, (.dmark+2)  
50cb 32 a2 fd			ld (debug_mark+2),a  
50ce 18 03			jr .pastdmark  
50d0 ..			.dmark: db "REN"  
50d3 f1			.pastdmark: pop af  
50d4			endm  
# End of macro DMARK
50d4						CALLMONITOR 
50d4 cd aa fd			call debug_vector  
50d7				endm  
# End of macro CALLMONITOR
50d7					endif 
50d7			 
50d7			 
50d7					; preserve some internal vars used by other file handing routines 
50d7			 
50d7 2a a0 f9				ld hl, (store_openaddr) 
50da e5					push hl 
50db 3a a2 f9				ld a, (store_readcont) 
50de f5					push af 
50df			 
50df					FORTH_DSP_VALUEHL 
50df cd 4d 22			call macro_dsp_valuehl 
50e2				endm 
# End of macro FORTH_DSP_VALUEHL
50e2			 
50e2					; move ext and id around for the file header 
50e2			 
50e2 65					ld h, l 
50e3 2e 00				ld l, 0 
50e5			 
50e5 e5					push hl    ; id 
50e6			 
50e6					FORTH_DSP_POP 
50e6 cd 05 23			call macro_forth_dsp_pop 
50e9				endm 
# End of macro FORTH_DSP_POP
50e9			 
50e9					; Locate the file header 
50e9			 
50e9 e1					pop hl 
50ea e5					push hl 
50eb 11 af f9				ld de, store_page      ; get block zero of file 
50ee					if DEBUG_FORTH_WORDS 
50ee						DMARK "REr" 
50ee f5				push af  
50ef 3a 03 51			ld a, (.dmark)  
50f2 32 a0 fd			ld (debug_mark),a  
50f5 3a 04 51			ld a, (.dmark+1)  
50f8 32 a1 fd			ld (debug_mark+1),a  
50fb 3a 05 51			ld a, (.dmark+2)  
50fe 32 a2 fd			ld (debug_mark+2),a  
5101 18 03			jr .pastdmark  
5103 ..			.dmark: db "REr"  
5106 f1			.pastdmark: pop af  
5107			endm  
# End of macro DMARK
5107						CALLMONITOR 
5107 cd aa fd			call debug_vector  
510a				endm  
# End of macro CALLMONITOR
510a					endif 
510a cd cd 09				call storage_read 
510d			 
510d cd 07 10			call ishlzero 
5110 20 05			jr nz, .rnfound 
5112			 
5112				; file does not exist so indicate with 255 extents in use 
5112			 
5112 3e ff			ld a, 255 
5114 e1				pop hl ; clear dup hl 
5115 18 7b			jr .skiprneof 
5117			 
5117			 
5117			.rnfound: 
5117					; file found so rename 
5117			 
5117					FORTH_DSP_VALUEHL 
5117 cd 4d 22			call macro_dsp_valuehl 
511a				endm 
# End of macro FORTH_DSP_VALUEHL
511a			 
511a e5				push hl 
511b 3e 00			ld a, 0 
511d cd 4f 13			call strlent 
5120 23				inc hl   ; cover zero term 
5121 06 00			ld b,0 
5123 4d				ld c,l 
5124 e1				pop hl 
5125 11 b2 f9				ld de, store_page + 3 
5128 ed b0				ldir 
512a			 
512a 11 af f9				ld de, store_page 
512d					if DEBUG_FORTH_WORDS 
512d						DMARK "RER" 
512d f5				push af  
512e 3a 42 51			ld a, (.dmark)  
5131 32 a0 fd			ld (debug_mark),a  
5134 3a 43 51			ld a, (.dmark+1)  
5137 32 a1 fd			ld (debug_mark+1),a  
513a 3a 44 51			ld a, (.dmark+2)  
513d 32 a2 fd			ld (debug_mark+2),a  
5140 18 03			jr .pastdmark  
5142 ..			.dmark: db "RER"  
5145 f1			.pastdmark: pop af  
5146			endm  
# End of macro DMARK
5146						CALLMONITOR 
5146 cd aa fd			call debug_vector  
5149				endm  
# End of macro CALLMONITOR
5149					endif 
5149			 
5149 e1					pop hl    ; get orig file id and mangle it for find id 
514a 55					ld d, l 
514b 5c					ld e, h 
514c			 
514c 21 00 00				ld hl, 0 
514f					if DEBUG_FORTH_WORDS 
514f						DMARK "REf" 
514f f5				push af  
5150 3a 64 51			ld a, (.dmark)  
5153 32 a0 fd			ld (debug_mark),a  
5156 3a 65 51			ld a, (.dmark+1)  
5159 32 a1 fd			ld (debug_mark+1),a  
515c 3a 66 51			ld a, (.dmark+2)  
515f 32 a2 fd			ld (debug_mark+2),a  
5162 18 03			jr .pastdmark  
5164 ..			.dmark: db "REf"  
5167 f1			.pastdmark: pop af  
5168			endm  
# End of macro DMARK
5168						CALLMONITOR 
5168 cd aa fd			call debug_vector  
516b				endm  
# End of macro CALLMONITOR
516b					endif 
516b cd a7 07				call storage_findnextid 
516e 11 af f9				ld de, store_page 
5171					if DEBUG_FORTH_WORDS 
5171						DMARK "REw" 
5171 f5				push af  
5172 3a 86 51			ld a, (.dmark)  
5175 32 a0 fd			ld (debug_mark),a  
5178 3a 87 51			ld a, (.dmark+1)  
517b 32 a1 fd			ld (debug_mark+1),a  
517e 3a 88 51			ld a, (.dmark+2)  
5181 32 a2 fd			ld (debug_mark+2),a  
5184 18 03			jr .pastdmark  
5186 ..			.dmark: db "REw"  
5189 f1			.pastdmark: pop af  
518a			endm  
# End of macro DMARK
518a						CALLMONITOR 
518a cd aa fd			call debug_vector  
518d				endm  
# End of macro CALLMONITOR
518d					endif 
518d cd d9 04				call storage_write_block 
5190			 
5190 3e 00				ld a, 0 
5192			.skiprneof: 
5192					; drop file name 
5192					FORTH_DSP_POP 
5192 cd 05 23			call macro_forth_dsp_pop 
5195				endm 
# End of macro FORTH_DSP_POP
5195			 
5195 6f					ld l, a 
5196 26 00				ld h, 0 
5198 cd 48 20				call forth_push_numhl 
519b			 
519b			 
519b f1					pop af 
519c 32 a2 f9				ld (store_readcont),a 
519f e1					pop hl 
51a0 22 a0 f9				ld (store_openaddr), hl 
51a3						 
51a3				NEXTW 
51a3 c3 39 24			jp macro_next 
51a6				endm 
# End of macro NEXTW
51a6			.RECORD: 
51a6			  
51a6				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
51a6 3a				db WORD_SYS_CORE+38             
51a7 4a 52			dw .BREAD            
51a9 07				db 6 + 1 
51aa .. 00			db "RECORD",0              
51b1				endm 
# End of macro CWHEAD
51b1			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
51b1			; | | > [!NOTE] 
51b1			; | | > Compatible with PicoSPINet  
51b1			 
51b1					if DEBUG_FORTH_WORDS_KEY 
51b1						DMARK "REC" 
51b1 f5				push af  
51b2 3a c6 51			ld a, (.dmark)  
51b5 32 a0 fd			ld (debug_mark),a  
51b8 3a c7 51			ld a, (.dmark+1)  
51bb 32 a1 fd			ld (debug_mark+1),a  
51be 3a c8 51			ld a, (.dmark+2)  
51c1 32 a2 fd			ld (debug_mark+2),a  
51c4 18 03			jr .pastdmark  
51c6 ..			.dmark: db "REC"  
51c9 f1			.pastdmark: pop af  
51ca			endm  
# End of macro DMARK
51ca						CALLMONITOR 
51ca cd aa fd			call debug_vector  
51cd				endm  
# End of macro CALLMONITOR
51cd					endif 
51cd			 
51cd					FORTH_DSP_VALUEHL 
51cd cd 4d 22			call macro_dsp_valuehl 
51d0				endm 
# End of macro FORTH_DSP_VALUEHL
51d0			 
51d0 e5					push hl    ; id 
51d1			 
51d1					FORTH_DSP_POP 
51d1 cd 05 23			call macro_forth_dsp_pop 
51d4				endm 
# End of macro FORTH_DSP_POP
51d4			 
51d4					FORTH_DSP_VALUEHL 
51d4 cd 4d 22			call macro_dsp_valuehl 
51d7				endm 
# End of macro FORTH_DSP_VALUEHL
51d7			 
51d7					FORTH_DSP_POP 
51d7 cd 05 23			call macro_forth_dsp_pop 
51da				endm 
# End of macro FORTH_DSP_POP
51da			 
51da d1					pop de     ; get file id 
51db			 
51db					; e = file id 
51db					; l = file extent 
51db			 
51db			 
51db					; construct request to access file extent 
51db			 
51db			;		ld a, e 
51db 63					ld h, e 
51dc					 
51dc					 
51dc					 
51dc			 
51dc					; e has id 
51dc			 
51dc 11 af f9			ld de, store_page 
51df					if DEBUG_FORTH_WORDS 
51df						DMARK "REr" 
51df f5				push af  
51e0 3a f4 51			ld a, (.dmark)  
51e3 32 a0 fd			ld (debug_mark),a  
51e6 3a f5 51			ld a, (.dmark+1)  
51e9 32 a1 fd			ld (debug_mark+1),a  
51ec 3a f6 51			ld a, (.dmark+2)  
51ef 32 a2 fd			ld (debug_mark+2),a  
51f2 18 03			jr .pastdmark  
51f4 ..			.dmark: db "REr"  
51f7 f1			.pastdmark: pop af  
51f8			endm  
# End of macro DMARK
51f8						CALLMONITOR 
51f8 cd aa fd			call debug_vector  
51fb				endm  
# End of macro CALLMONITOR
51fb					endif 
51fb cd cd 09				call storage_read 
51fe cd 07 10			call ishlzero 
5201 28 22			jr z, .recnotfound 
5203			 
5203			 
5203					if DEBUG_FORTH_WORDS 
5203						DMARK "REe" 
5203 f5				push af  
5204 3a 18 52			ld a, (.dmark)  
5207 32 a0 fd			ld (debug_mark),a  
520a 3a 19 52			ld a, (.dmark+1)  
520d 32 a1 fd			ld (debug_mark+1),a  
5210 3a 1a 52			ld a, (.dmark+2)  
5213 32 a2 fd			ld (debug_mark+2),a  
5216 18 03			jr .pastdmark  
5218 ..			.dmark: db "REe"  
521b f1			.pastdmark: pop af  
521c			endm  
# End of macro DMARK
521c						CALLMONITOR 
521c cd aa fd			call debug_vector  
521f				endm  
# End of macro CALLMONITOR
521f					endif 
521f cd b6 20			call forth_push_str 
5222			 
5222					NEXTW 
5222 c3 39 24			jp macro_next 
5225				endm 
# End of macro NEXTW
5225			 
5225			.recnotfound: 
5225					if DEBUG_FORTH_WORDS 
5225						DMARK "REf" 
5225 f5				push af  
5226 3a 3a 52			ld a, (.dmark)  
5229 32 a0 fd			ld (debug_mark),a  
522c 3a 3b 52			ld a, (.dmark+1)  
522f 32 a1 fd			ld (debug_mark+1),a  
5232 3a 3c 52			ld a, (.dmark+2)  
5235 32 a2 fd			ld (debug_mark+2),a  
5238 18 03			jr .pastdmark  
523a ..			.dmark: db "REf"  
523d f1			.pastdmark: pop af  
523e			endm  
# End of macro DMARK
523e						CALLMONITOR 
523e cd aa fd			call debug_vector  
5241				endm  
# End of macro CALLMONITOR
5241					endif 
5241 21 ff 00			ld hl, 255 
5244 cd 48 20			call forth_push_numhl 
5247				NEXTW 
5247 c3 39 24			jp macro_next 
524a				endm 
# End of macro NEXTW
524a			 
524a			 
524a			.BREAD: 
524a			  
524a				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
524a 3a				db WORD_SYS_CORE+38             
524b cd 52			dw .BWRITE            
524d 06				db 5 + 1 
524e .. 00			db "BREAD",0              
5254				endm 
# End of macro CWHEAD
5254			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
5254			; | | > [!NOTE] 
5254			; | | > Compatible with PicoSPINet  
5254				 
5254					if DEBUG_FORTH_WORDS_KEY 
5254						DMARK "BRD" 
5254 f5				push af  
5255 3a 69 52			ld a, (.dmark)  
5258 32 a0 fd			ld (debug_mark),a  
525b 3a 6a 52			ld a, (.dmark+1)  
525e 32 a1 fd			ld (debug_mark+1),a  
5261 3a 6b 52			ld a, (.dmark+2)  
5264 32 a2 fd			ld (debug_mark+2),a  
5267 18 03			jr .pastdmark  
5269 ..			.dmark: db "BRD"  
526c f1			.pastdmark: pop af  
526d			endm  
# End of macro DMARK
526d						CALLMONITOR 
526d cd aa fd			call debug_vector  
5270				endm  
# End of macro CALLMONITOR
5270					endif 
5270			 
5270				FORTH_DSP_VALUEHL 
5270 cd 4d 22			call macro_dsp_valuehl 
5273				endm 
# End of macro FORTH_DSP_VALUEHL
5273			 
5273				FORTH_DSP_POP 
5273 cd 05 23			call macro_forth_dsp_pop 
5276				endm 
# End of macro FORTH_DSP_POP
5276			 
5276				; calc block address 
5276			 
5276 eb				ex de, hl 
5277 3e 40			ld a, STORE_BLOCK_PHY 
5279 cd 61 0f			call Mult16 
527c			 
527c			 
527c 11 af f9			ld de, store_page 
527f			 
527f					if DEBUG_FORTH_WORDS 
527f						DMARK "BR1" 
527f f5				push af  
5280 3a 94 52			ld a, (.dmark)  
5283 32 a0 fd			ld (debug_mark),a  
5286 3a 95 52			ld a, (.dmark+1)  
5289 32 a1 fd			ld (debug_mark+1),a  
528c 3a 96 52			ld a, (.dmark+2)  
528f 32 a2 fd			ld (debug_mark+2),a  
5292 18 03			jr .pastdmark  
5294 ..			.dmark: db "BR1"  
5297 f1			.pastdmark: pop af  
5298			endm  
# End of macro DMARK
5298						CALLMONITOR 
5298 cd aa fd			call debug_vector  
529b				endm  
# End of macro CALLMONITOR
529b					endif 
529b			 
529b cd 74 04			call storage_read_block 
529e			 
529e cd 07 10			call ishlzero 
52a1 20 05			jr nz, .brfound 
52a3			 
52a3 cd 48 20			call forth_push_numhl 
52a6 18 22			jr .brdone 
52a8			 
52a8			 
52a8			.brfound: 
52a8 21 b1 f9		        ld hl, store_page+2 
52ab			 
52ab					if DEBUG_FORTH_WORDS 
52ab						DMARK "BR2" 
52ab f5				push af  
52ac 3a c0 52			ld a, (.dmark)  
52af 32 a0 fd			ld (debug_mark),a  
52b2 3a c1 52			ld a, (.dmark+1)  
52b5 32 a1 fd			ld (debug_mark+1),a  
52b8 3a c2 52			ld a, (.dmark+2)  
52bb 32 a2 fd			ld (debug_mark+2),a  
52be 18 03			jr .pastdmark  
52c0 ..			.dmark: db "BR2"  
52c3 f1			.pastdmark: pop af  
52c4			endm  
# End of macro DMARK
52c4						CALLMONITOR 
52c4 cd aa fd			call debug_vector  
52c7				endm  
# End of macro CALLMONITOR
52c7					endif 
52c7			 
52c7 cd b6 20			call forth_push_str 
52ca			 
52ca			 
52ca			.brdone: 
52ca			 
52ca					NEXTW 
52ca c3 39 24			jp macro_next 
52cd				endm 
# End of macro NEXTW
52cd			.BWRITE: 
52cd				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
52cd 3a				db WORD_SYS_CORE+38             
52ce 62 53			dw .BUPD            
52d0 07				db 6 + 1 
52d1 .. 00			db "BWRITE",0              
52d8				endm 
# End of macro CWHEAD
52d8			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
52d8			; | | > [!NOTE] 
52d8			; | | > Compatible with PicoSPINet  
52d8			 
52d8					if DEBUG_FORTH_WORDS_KEY 
52d8						DMARK "BWR" 
52d8 f5				push af  
52d9 3a ed 52			ld a, (.dmark)  
52dc 32 a0 fd			ld (debug_mark),a  
52df 3a ee 52			ld a, (.dmark+1)  
52e2 32 a1 fd			ld (debug_mark+1),a  
52e5 3a ef 52			ld a, (.dmark+2)  
52e8 32 a2 fd			ld (debug_mark+2),a  
52eb 18 03			jr .pastdmark  
52ed ..			.dmark: db "BWR"  
52f0 f1			.pastdmark: pop af  
52f1			endm  
# End of macro DMARK
52f1						CALLMONITOR 
52f1 cd aa fd			call debug_vector  
52f4				endm  
# End of macro CALLMONITOR
52f4					endif 
52f4			 
52f4				FORTH_DSP_VALUEHL 
52f4 cd 4d 22			call macro_dsp_valuehl 
52f7				endm 
# End of macro FORTH_DSP_VALUEHL
52f7			 
52f7				; calc block address 
52f7			 
52f7 eb				ex de, hl 
52f8 3e 40			ld a, STORE_BLOCK_PHY 
52fa cd 61 0f			call Mult16 
52fd			 
52fd e5				push hl         ; address 
52fe			 
52fe				FORTH_DSP_POP 
52fe cd 05 23			call macro_forth_dsp_pop 
5301				endm 
# End of macro FORTH_DSP_POP
5301			 
5301				FORTH_DSP_VALUEHL 
5301 cd 4d 22			call macro_dsp_valuehl 
5304				endm 
# End of macro FORTH_DSP_VALUEHL
5304			 
5304				FORTH_DSP_POP 
5304 cd 05 23			call macro_forth_dsp_pop 
5307				endm 
# End of macro FORTH_DSP_POP
5307			 
5307 cd b0 0c			call storage_clear_page 
530a			 
530a				; copy string to store page 
530a			 
530a e5				push hl     ; save string address 
530b			 
530b 3e 00			ld a, 0 
530d cd 4f 13			call strlent 
5310			 
5310 23				inc hl 
5311			 
5311 4d				ld c, l 
5312 06 00			ld b, 0 
5314			 
5314 e1				pop hl 
5315 11 b1 f9			ld de, store_page + 2 
5318					if DEBUG_FORTH_WORDS 
5318						DMARK "BW1" 
5318 f5				push af  
5319 3a 2d 53			ld a, (.dmark)  
531c 32 a0 fd			ld (debug_mark),a  
531f 3a 2e 53			ld a, (.dmark+1)  
5322 32 a1 fd			ld (debug_mark+1),a  
5325 3a 2f 53			ld a, (.dmark+2)  
5328 32 a2 fd			ld (debug_mark+2),a  
532b 18 03			jr .pastdmark  
532d ..			.dmark: db "BW1"  
5330 f1			.pastdmark: pop af  
5331			endm  
# End of macro DMARK
5331						CALLMONITOR 
5331 cd aa fd			call debug_vector  
5334				endm  
# End of macro CALLMONITOR
5334					endif 
5334 ed b0			ldir 
5336			 
5336			 
5336				; poke the start of the block with flags to prevent high level file ops hitting the block 
5336			 
5336 21 ff ff			ld hl, $ffff 
5339			 
5339 22 af f9			ld (store_page), hl	 
533c				 
533c e1				pop hl    ; get address 
533d 11 af f9			ld de, store_page 
5340			 
5340					if DEBUG_FORTH_WORDS 
5340						DMARK "BW2" 
5340 f5				push af  
5341 3a 55 53			ld a, (.dmark)  
5344 32 a0 fd			ld (debug_mark),a  
5347 3a 56 53			ld a, (.dmark+1)  
534a 32 a1 fd			ld (debug_mark+1),a  
534d 3a 57 53			ld a, (.dmark+2)  
5350 32 a2 fd			ld (debug_mark+2),a  
5353 18 03			jr .pastdmark  
5355 ..			.dmark: db "BW2"  
5358 f1			.pastdmark: pop af  
5359			endm  
# End of macro DMARK
5359						CALLMONITOR 
5359 cd aa fd			call debug_vector  
535c				endm  
# End of macro CALLMONITOR
535c					endif 
535c			 
535c cd d9 04			call storage_write_block 
535f			 
535f					NEXTW 
535f c3 39 24			jp macro_next 
5362				endm 
# End of macro NEXTW
5362			 
5362			.BUPD: 
5362				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
5362 3a				db WORD_SYS_CORE+38             
5363 b8 53			dw .BYID            
5365 05				db 4 + 1 
5366 .. 00			db "BUPD",0              
536b				endm 
# End of macro CWHEAD
536b			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
536b			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
536b			; | | or completely different file system structure. 
536b			; | | > [!NOTE] 
536b			; | | > Compatible with PicoSPINet  
536b			 
536b					if DEBUG_FORTH_WORDS_KEY 
536b						DMARK "BUD" 
536b f5				push af  
536c 3a 80 53			ld a, (.dmark)  
536f 32 a0 fd			ld (debug_mark),a  
5372 3a 81 53			ld a, (.dmark+1)  
5375 32 a1 fd			ld (debug_mark+1),a  
5378 3a 82 53			ld a, (.dmark+2)  
537b 32 a2 fd			ld (debug_mark+2),a  
537e 18 03			jr .pastdmark  
5380 ..			.dmark: db "BUD"  
5383 f1			.pastdmark: pop af  
5384			endm  
# End of macro DMARK
5384						CALLMONITOR 
5384 cd aa fd			call debug_vector  
5387				endm  
# End of macro CALLMONITOR
5387					endif 
5387			 
5387				FORTH_DSP_VALUEHL 
5387 cd 4d 22			call macro_dsp_valuehl 
538a				endm 
# End of macro FORTH_DSP_VALUEHL
538a			 
538a				; calc block address 
538a			 
538a eb				ex de, hl 
538b 3e 40			ld a, STORE_BLOCK_PHY 
538d cd 61 0f			call Mult16 
5390			 
5390				FORTH_DSP_POP 
5390 cd 05 23			call macro_forth_dsp_pop 
5393				endm 
# End of macro FORTH_DSP_POP
5393			 
5393			 
5393 11 af f9			ld de, store_page 
5396			 
5396					if DEBUG_FORTH_WORDS 
5396						DMARK "BUe" 
5396 f5				push af  
5397 3a ab 53			ld a, (.dmark)  
539a 32 a0 fd			ld (debug_mark),a  
539d 3a ac 53			ld a, (.dmark+1)  
53a0 32 a1 fd			ld (debug_mark+1),a  
53a3 3a ad 53			ld a, (.dmark+2)  
53a6 32 a2 fd			ld (debug_mark+2),a  
53a9 18 03			jr .pastdmark  
53ab ..			.dmark: db "BUe"  
53ae f1			.pastdmark: pop af  
53af			endm  
# End of macro DMARK
53af						CALLMONITOR 
53af cd aa fd			call debug_vector  
53b2				endm  
# End of macro CALLMONITOR
53b2					endif 
53b2			 
53b2 cd d9 04			call storage_write_block 
53b5			 
53b5					NEXTW 
53b5 c3 39 24			jp macro_next 
53b8				endm 
# End of macro NEXTW
53b8			 
53b8			.BYID: 
53b8			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
53b8			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
53b8			; 
53b8			;		 
53b8			;		if DEBUG_FORTH_WORDS_KEY 
53b8			;			DMARK "BYID" 
53b8			;			CALLMONITOR 
53b8			;		endif 
53b8			; 
53b8			;		; get direct address 
53b8			; 
53b8			;		FORTH_DSP_VALUEHL 
53b8			; 
53b8			;		FORTH_DSP_POP 
53b8			; 
53b8			;	; calc block address 
53b8			; 
53b8			;	ex de, hl 
53b8			;	ld a, STORE_BLOCK_PHY 
53b8			;	call Mult16 
53b8			;	;	do BREAD with number as param 
53b8			;	; push the file name	 
53b8			;	ld de, store_page 
53b8			;	call storage_read_block 
53b8			 ;       ld hl, store_page+2 
53b8			; 
53b8			; 
53b8			;		NEXTW 
53b8			;.BYNAME: 
53b8				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
53b8 3a				db WORD_SYS_CORE+38             
53b9 d1 53			dw .DIR            
53bb 06				db 5 + 1 
53bc .. 00			db "GETID",0              
53c2				endm 
# End of macro CWHEAD
53c2			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
53c2			; | | > [!NOTE] 
53c2			; | | > Compatible with PicoSPINet  
53c2			 
53c2					; get pointer to file name to seek 
53c2			 
53c2					FORTH_DSP_VALUEHL 
53c2 cd 4d 22			call macro_dsp_valuehl 
53c5				endm 
# End of macro FORTH_DSP_VALUEHL
53c5			 
53c5			 
53c5 cd 9b 03				call storage_getid  
53c8			 
53c8					FORTH_DSP_POP 
53c8 cd 05 23			call macro_forth_dsp_pop 
53cb				endm 
# End of macro FORTH_DSP_POP
53cb			 
53cb cd 48 20				call forth_push_numhl 
53ce			 
53ce					NEXTW 
53ce c3 39 24			jp macro_next 
53d1				endm 
# End of macro NEXTW
53d1			; 
53d1			.DIR: 
53d1				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
53d1 3a				db WORD_SYS_CORE+38             
53d2 d5 54			dw .SAVE            
53d4 04				db 3 + 1 
53d5 .. 00			db "DIR",0              
53d9				endm 
# End of macro CWHEAD
53d9			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
53d9			; | | > [!NOTE] 
53d9			; | | > Compatible with PicoSPINet  
53d9			 
53d9					if DEBUG_FORTH_WORDS_KEY 
53d9						DMARK "DIR" 
53d9 f5				push af  
53da 3a ee 53			ld a, (.dmark)  
53dd 32 a0 fd			ld (debug_mark),a  
53e0 3a ef 53			ld a, (.dmark+1)  
53e3 32 a1 fd			ld (debug_mark+1),a  
53e6 3a f0 53			ld a, (.dmark+2)  
53e9 32 a2 fd			ld (debug_mark+2),a  
53ec 18 03			jr .pastdmark  
53ee ..			.dmark: db "DIR"  
53f1 f1			.pastdmark: pop af  
53f2			endm  
# End of macro DMARK
53f2						CALLMONITOR 
53f2 cd aa fd			call debug_vector  
53f5				endm  
# End of macro CALLMONITOR
53f5					endif 
53f5 cd 25 05			call storage_get_block_0 
53f8			 
53f8 21 af f9			ld hl, store_page     ; get current id count 
53fb 46				ld b, (hl) 
53fc 0e 00			ld c, 0    ; count of files   
53fe					if DEBUG_FORTH_WORDS 
53fe						DMARK "DI1" 
53fe f5				push af  
53ff 3a 13 54			ld a, (.dmark)  
5402 32 a0 fd			ld (debug_mark),a  
5405 3a 14 54			ld a, (.dmark+1)  
5408 32 a1 fd			ld (debug_mark+1),a  
540b 3a 15 54			ld a, (.dmark+2)  
540e 32 a2 fd			ld (debug_mark+2),a  
5411 18 03			jr .pastdmark  
5413 ..			.dmark: db "DI1"  
5416 f1			.pastdmark: pop af  
5417			endm  
# End of macro DMARK
5417						CALLMONITOR 
5417 cd aa fd			call debug_vector  
541a				endm  
# End of macro CALLMONITOR
541a					endif 
541a			 
541a				; check for empty drive 
541a			 
541a 3e 00			ld a, 0 
541c b8				cp b 
541d ca 8b 54			jp z, .dirdone 
5420			 
5420				; for each of the current ids do a search for them and if found push to stack 
5420			 
5420 c5			.diritem:	push bc 
5421 21 40 00				ld hl, STORE_BLOCK_PHY 
5424 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
5426 58					ld e,b 
5427			 
5427			;		if DEBUG_FORTH_WORDS 
5427			;			DMARK "DI2" 
5427			;			CALLMONITOR 
5427			;		endif 
5427			 
5427 cd a7 07				call storage_findnextid 
542a			 
542a			;		if DEBUG_FORTH_WORDS 
542a			;			DMARK "DI3" 
542a			;			CALLMONITOR 
542a			;		endif 
542a			 
542a					; if found hl will be non zero 
542a			 
542a cd 07 10				call ishlzero 
542d			;		ld a, l 
542d			;		add h 
542d			; 
542d			;		cp 0 
542d 28 59				jr z, .dirnotfound 
542f			 
542f					; increase count 
542f			 
542f c1					pop bc	 
5430 0c					inc c 
5431 c5					push bc 
5432					 
5432			 
5432					; get file header and push the file name 
5432			 
5432 11 af f9				ld de, store_page 
5435 cd 74 04				call storage_read_block 
5438			 
5438					; push file id to stack 
5438				 
5438 3a af f9				ld a, (store_page) 
543b 26 00				ld h, 0 
543d 6f					ld l, a 
543e cd 48 20				call forth_push_numhl 
5441			 
5441					; push extent count to stack  
5441				 
5441 3a b1 f9				ld a, (store_page+2) 
5444 26 00				ld h, 0 
5446 6f					ld l, a 
5447 cd 48 20				call forth_push_numhl 
544a			 
544a					; push file name 
544a			 
544a 21 b2 f9				ld hl, store_page+3 
544d					if DEBUG_FORTH_WORDS 
544d						DMARK "DI5" 
544d f5				push af  
544e 3a 62 54			ld a, (.dmark)  
5451 32 a0 fd			ld (debug_mark),a  
5454 3a 63 54			ld a, (.dmark+1)  
5457 32 a1 fd			ld (debug_mark+1),a  
545a 3a 64 54			ld a, (.dmark+2)  
545d 32 a2 fd			ld (debug_mark+2),a  
5460 18 03			jr .pastdmark  
5462 ..			.dmark: db "DI5"  
5465 f1			.pastdmark: pop af  
5466			endm  
# End of macro DMARK
5466						CALLMONITOR 
5466 cd aa fd			call debug_vector  
5469				endm  
# End of macro CALLMONITOR
5469					endif 
5469 cd b6 20				call forth_push_str 
546c					if DEBUG_FORTH_WORDS 
546c						DMARK "DI6" 
546c f5				push af  
546d 3a 81 54			ld a, (.dmark)  
5470 32 a0 fd			ld (debug_mark),a  
5473 3a 82 54			ld a, (.dmark+1)  
5476 32 a1 fd			ld (debug_mark+1),a  
5479 3a 83 54			ld a, (.dmark+2)  
547c 32 a2 fd			ld (debug_mark+2),a  
547f 18 03			jr .pastdmark  
5481 ..			.dmark: db "DI6"  
5484 f1			.pastdmark: pop af  
5485			endm  
# End of macro DMARK
5485						CALLMONITOR 
5485 cd aa fd			call debug_vector  
5488				endm  
# End of macro CALLMONITOR
5488					endif 
5488			.dirnotfound: 
5488 c1					pop bc     
5489 10 95				djnz .diritem 
548b				 
548b			.dirdone:	 
548b					if DEBUG_FORTH_WORDS 
548b						DMARK "DI7" 
548b f5				push af  
548c 3a a0 54			ld a, (.dmark)  
548f 32 a0 fd			ld (debug_mark),a  
5492 3a a1 54			ld a, (.dmark+1)  
5495 32 a1 fd			ld (debug_mark+1),a  
5498 3a a2 54			ld a, (.dmark+2)  
549b 32 a2 fd			ld (debug_mark+2),a  
549e 18 03			jr .pastdmark  
54a0 ..			.dmark: db "DI7"  
54a3 f1			.pastdmark: pop af  
54a4			endm  
# End of macro DMARK
54a4						CALLMONITOR 
54a4 cd aa fd			call debug_vector  
54a7				endm  
# End of macro CALLMONITOR
54a7					endif 
54a7			 
54a7					; push a count of the dir items found 
54a7			 
54a7 26 00				ld h, 0 
54a9 69					ld l, c 
54aa cd 48 20				call forth_push_numhl 
54ad			 
54ad					; push the bank label 
54ad			 
54ad cd 25 05				call storage_get_block_0 
54b0			 
54b0				 
54b0 21 b2 f9		 		ld hl, store_page+3 
54b3			 
54b3					if DEBUG_FORTH_WORDS 
54b3						DMARK "DI8" 
54b3 f5				push af  
54b4 3a c8 54			ld a, (.dmark)  
54b7 32 a0 fd			ld (debug_mark),a  
54ba 3a c9 54			ld a, (.dmark+1)  
54bd 32 a1 fd			ld (debug_mark+1),a  
54c0 3a ca 54			ld a, (.dmark+2)  
54c3 32 a2 fd			ld (debug_mark+2),a  
54c6 18 03			jr .pastdmark  
54c8 ..			.dmark: db "DI8"  
54cb f1			.pastdmark: pop af  
54cc			endm  
# End of macro DMARK
54cc						CALLMONITOR 
54cc cd aa fd			call debug_vector  
54cf				endm  
# End of macro CALLMONITOR
54cf					endif 
54cf cd b6 20				call forth_push_str 
54d2			 
54d2			 
54d2				 
54d2					NEXTW 
54d2 c3 39 24			jp macro_next 
54d5				endm 
# End of macro NEXTW
54d5			.SAVE: 
54d5			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
54d5			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
54d5			;		NEXTW 
54d5			;.LOAD: 
54d5			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
54d5			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
54d5			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
54d5			;; > > The LOAD command can not be used in any user words or compound lines. 
54d5			; 
54d5			;		; store_openext use it. If zero it is EOF 
54d5			; 
54d5			;		; read block from current stream id 
54d5			;		; if the block does not contain zero term keep reading blocks until zero found 
54d5			;		; push the block to stack 
54d5			;		; save the block id to stream 
54d5			; 
54d5			; 
54d5			;		FORTH_DSP_VALUEHL 
54d5			; 
54d5			;;		push hl 
54d5			; 
54d5			;	if DEBUG_STORESE 
54d5			;		DMARK "LOA" 
54d5			;		CALLMONITOR 
54d5			;	endif 
54d5			;		FORTH_DSP_POP 
54d5			; 
54d5			;;		pop hl 
54d5			; 
54d5			;		ld h, l 
54d5			;		ld l, 0 
54d5			; 
54d5			;		push hl     ; stack holds current file id and extent to work with 
54d5			; 
54d5			; 
54d5			;		ld de, store_page      ; get block zero of file 
54d5			;	if DEBUG_STORESE 
54d5			;		DMARK "LO0" 
54d5			;		CALLMONITOR 
54d5			;	endif 
54d5			;		call storage_read 
54d5			; 
54d5			;		ld a, (store_page+2)    ; max extents for this file 
54d5			;		ld  (store_openmaxext),a   ; get our limit 
54d5			; 
54d5			;	if DEBUG_STORESE 
54d5			;		DMARK "LOE" 
54d5			;		CALLMONITOR 
54d5			;	endif 
54d5			; 
54d5			;; TODO dont know why max extents are not present 
54d5			;;		cp 0 
54d5			;;		jp z, .loadeof     ; dont read past eof 
54d5			; 
54d5			;;		ld a, 1   ; start from the head of the file 
54d5			; 
54d5			;.loadline:	pop hl 
54d5			;		inc hl 
54d5			;		ld  a, (store_openmaxext)   ; get our limit 
54d5			;	if DEBUG_STORESE 
54d5			;		DMARK "LOx" 
54d5			;		CALLMONITOR 
54d5			;	endif 
54d5			;		inc a 
54d5			;		cp l 
54d5			;		jp z, .loadeof 
54d5			;		push hl    ; save current extent 
54d5			; 
54d5			;		ld de, store_page 
54d5			; 
54d5			;	if DEBUG_STORESE 
54d5			;		DMARK "LO1" 
54d5			;		CALLMONITOR 
54d5			;	endif 
54d5			;		call storage_read 
54d5			; 
54d5			;	if DEBUG_STORESE 
54d5			;		DMARK "LO2" 
54d5			;		CALLMONITOR 
54d5			;	endif 
54d5			;	call ishlzero 
54d5			;	ld a, l 
54d5			;	add h 
54d5			;	cp 0 
54d5			;	jr z, .loadeof 
54d5			; 
54d5			;	; not eof so hl should point to data to exec 
54d5			; 
54d5			;	; will need to add the FORTH_END_BUFFER flag 
54d5			 ; 
54d5			;	ld hl, store_page+2 
54d5			;	ld bc, 255 
54d5			;	ld a, 0 
54d5			;	cpir 
54d5			;	if DEBUG_STORESE 
54d5			;		DMARK "LOt" 
54d5			;		CALLMONITOR 
54d5			;	endif 
54d5			;	dec hl 
54d5			;	ld a, ' ' 
54d5			;	ld (hl), a 
54d5			;	inc hl 
54d5			;	ld (hl), a 
54d5			;	inc hl 
54d5			;	ld (hl), a 
54d5			;	inc hl 
54d5			;	ld a, FORTH_END_BUFFER 
54d5			;	ld (hl), a 
54d5			; 
54d5			;	; TODO handle more than a single block read 
54d5			; 
54d5			; 
54d5			;	ld hl, store_page+2 
54d5			; 
54d5			;	ld (os_tok_ptr), hl 
54d5			; 
54d5			;	if DEBUG_STORESE 
54d5			;		DMARK "LO3" 
54d5			;		CALLMONITOR 
54d5			;	endif 
54d5			; 
54d5			;	call forthparse 
54d5			;	call forthexec 
54d5			;	call forthexec_cleanup 
54d5			; 
54d5			;	; go to next extent 
54d5			; 
54d5			;	; get next block  or mark as eof 
54d5			;	jp .loadline 
54d5			; 
54d5			; 
54d5			; 
54d5			;	       NEXTW 
54d5			;.loadeof:	ld a, 0 
54d5			;		ld (store_openext), a 
54d5			; 
54d5			;	if DEBUG_STORESE 
54d5			;		DMARK "LOF" 
54d5			;		CALLMONITOR 
54d5			;	endif 
54d5			;		ret 
54d5			;		;NEXTW 
54d5			;.BSAVE:   
54d5			; 
54d5			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
54d5			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
54d5			;		NEXTW 
54d5			;.BLOAD: 
54d5			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
54d5			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
54d5			;		NEXTW 
54d5			;;;; counter gap 
54d5			 
54d5			 
54d5			.SEO: 
54d5				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
54d5 64				db WORD_SYS_CORE+80             
54d6 f4 54			dw .SEI            
54d8 04				db 3 + 1 
54d9 .. 00			db "SEO",0              
54dd				endm 
# End of macro CWHEAD
54dd			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
54dd			 
54dd					; get port 
54dd			 
54dd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
54dd cd 4d 22			call macro_dsp_valuehl 
54e0				endm 
# End of macro FORTH_DSP_VALUEHL
54e0			 
54e0 e5					push hl    ; u2 - byte 
54e1			 
54e1					; destroy value TOS 
54e1			 
54e1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
54e1 cd 05 23			call macro_forth_dsp_pop 
54e4				endm 
# End of macro FORTH_DSP_POP
54e4			 
54e4					; get byte to send 
54e4			 
54e4					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
54e4 cd 4d 22			call macro_dsp_valuehl 
54e7				endm 
# End of macro FORTH_DSP_VALUEHL
54e7			 
54e7 e5					push hl    ; u1 - addr 
54e8			 
54e8					; destroy value TOS 
54e8			 
54e8					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
54e8 cd 05 23			call macro_forth_dsp_pop 
54eb				endm 
# End of macro FORTH_DSP_POP
54eb			 
54eb					; one value on hl get other one back 
54eb			 
54eb d1					pop de   ; u1 - byte 
54ec			 
54ec e1					pop hl   ; u2 - addr 
54ed			 
54ed					; TODO Send SPI byte 
54ed			 
54ed			 
54ed 7b					ld a, e 
54ee cd 79 02				call se_writebyte 
54f1			 
54f1					 
54f1			 
54f1					NEXTW 
54f1 c3 39 24			jp macro_next 
54f4				endm 
# End of macro NEXTW
54f4			 
54f4			.SEI: 
54f4				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
54f4 65				db WORD_SYS_CORE+81             
54f5 0e 55			dw .SFREE            
54f7 04				db 3 + 1 
54f8 .. 00			db "SEI",0              
54fc				endm 
# End of macro CWHEAD
54fc			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
54fc			 
54fc					; get port 
54fc			 
54fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
54fc cd 4d 22			call macro_dsp_valuehl 
54ff				endm 
# End of macro FORTH_DSP_VALUEHL
54ff			 
54ff			;		push hl 
54ff			 
54ff					; destroy value TOS 
54ff			 
54ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
54ff cd 05 23			call macro_forth_dsp_pop 
5502				endm 
# End of macro FORTH_DSP_POP
5502			 
5502					; one value on hl get other one back 
5502			 
5502			;		pop hl 
5502			 
5502			 
5502					; TODO Get SPI byte 
5502			 
5502 cd 1b 03				call se_readbyte 
5505			 
5505 26 00				ld h, 0 
5507 6f					ld l, a 
5508 cd 48 20				call forth_push_numhl 
550b			 
550b					NEXTW 
550b c3 39 24			jp macro_next 
550e				endm 
# End of macro NEXTW
550e			 
550e			.SFREE: 
550e				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
550e 67				db WORD_SYS_CORE+83             
550f 3d 55			dw .SIZE            
5511 06				db 5 + 1 
5512 .. 00			db "FFREE",0              
5518				endm 
# End of macro CWHEAD
5518			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
5518			; | | > [!NOTE] 
5518			; | | > Compatible with PicoSPINet  
5518					if DEBUG_FORTH_WORDS_KEY 
5518						DMARK "FFR" 
5518 f5				push af  
5519 3a 2d 55			ld a, (.dmark)  
551c 32 a0 fd			ld (debug_mark),a  
551f 3a 2e 55			ld a, (.dmark+1)  
5522 32 a1 fd			ld (debug_mark+1),a  
5525 3a 2f 55			ld a, (.dmark+2)  
5528 32 a2 fd			ld (debug_mark+2),a  
552b 18 03			jr .pastdmark  
552d ..			.dmark: db "FFR"  
5530 f1			.pastdmark: pop af  
5531			endm  
# End of macro DMARK
5531						CALLMONITOR 
5531 cd aa fd			call debug_vector  
5534				endm  
# End of macro CALLMONITOR
5534					endif 
5534			 
5534 cd 41 08				call storage_freeblocks 
5537			 
5537 cd 48 20				call forth_push_numhl 
553a			 
553a				       NEXTW 
553a c3 39 24			jp macro_next 
553d				endm 
# End of macro NEXTW
553d			.SIZE: 
553d				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
553d 67				db WORD_SYS_CORE+83             
553e 71 55			dw .CREATE            
5540 05				db 4 + 1 
5541 .. 00			db "SIZE",0              
5546				endm 
# End of macro CWHEAD
5546			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
5546			; | | > [!NOTE] 
5546			; | | > Compatible with PicoSPINet  
5546					if DEBUG_FORTH_WORDS_KEY 
5546						DMARK "SIZ" 
5546 f5				push af  
5547 3a 5b 55			ld a, (.dmark)  
554a 32 a0 fd			ld (debug_mark),a  
554d 3a 5c 55			ld a, (.dmark+1)  
5550 32 a1 fd			ld (debug_mark+1),a  
5553 3a 5d 55			ld a, (.dmark+2)  
5556 32 a2 fd			ld (debug_mark+2),a  
5559 18 03			jr .pastdmark  
555b ..			.dmark: db "SIZ"  
555e f1			.pastdmark: pop af  
555f			endm  
# End of macro DMARK
555f						CALLMONITOR 
555f cd aa fd			call debug_vector  
5562				endm  
# End of macro CALLMONITOR
5562					endif 
5562			 
5562					FORTH_DSP_VALUEHL 
5562 cd 4d 22			call macro_dsp_valuehl 
5565				endm 
# End of macro FORTH_DSP_VALUEHL
5565			;		push hl 
5565					FORTH_DSP_POP 
5565 cd 05 23			call macro_forth_dsp_pop 
5568				endm 
# End of macro FORTH_DSP_POP
5568			;		pop hl 
5568 cd a3 04				call storage_file_size 
556b			 
556b cd 48 20				call forth_push_numhl 
556e			  
556e			 
556e				       NEXTW 
556e c3 39 24			jp macro_next 
5571				endm 
# End of macro NEXTW
5571			 
5571			.CREATE: 
5571				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
5571 68				db WORD_SYS_CORE+84             
5572 df 55			dw .APPEND            
5574 07				db 6 + 1 
5575 .. 00			db "CREATE",0              
557c				endm 
# End of macro CWHEAD
557c			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
557c			; | | e.g.  
557c			; | | TestProgram CREATE 
557c			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
557c			; | |  
557c			; | | Max file IDs are 255. 
557c			; | |  
557c			; | | > [!NOTE] 
557c			; | | > Compatible with PicoSPINet  
557c					 
557c					if DEBUG_FORTH_WORDS_KEY 
557c						DMARK "CRT" 
557c f5				push af  
557d 3a 91 55			ld a, (.dmark)  
5580 32 a0 fd			ld (debug_mark),a  
5583 3a 92 55			ld a, (.dmark+1)  
5586 32 a1 fd			ld (debug_mark+1),a  
5589 3a 93 55			ld a, (.dmark+2)  
558c 32 a2 fd			ld (debug_mark+2),a  
558f 18 03			jr .pastdmark  
5591 ..			.dmark: db "CRT"  
5594 f1			.pastdmark: pop af  
5595			endm  
# End of macro DMARK
5595						CALLMONITOR 
5595 cd aa fd			call debug_vector  
5598				endm  
# End of macro CALLMONITOR
5598					endif 
5598			;		call storage_get_block_0 
5598			 
5598					; TODO pop hl 
5598			 
5598					;v5 FORTH_DSP_VALUE 
5598					FORTH_DSP_VALUE 
5598 cd 36 22			call macro_forth_dsp_value 
559b				endm 
# End of macro FORTH_DSP_VALUE
559b			 
559b				if DEBUG_STORESE 
559b					DMARK "CR1" 
559b f5				push af  
559c 3a b0 55			ld a, (.dmark)  
559f 32 a0 fd			ld (debug_mark),a  
55a2 3a b1 55			ld a, (.dmark+1)  
55a5 32 a1 fd			ld (debug_mark+1),a  
55a8 3a b2 55			ld a, (.dmark+2)  
55ab 32 a2 fd			ld (debug_mark+2),a  
55ae 18 03			jr .pastdmark  
55b0 ..			.dmark: db "CR1"  
55b3 f1			.pastdmark: pop af  
55b4			endm  
# End of macro DMARK
55b4					CALLMONITOR 
55b4 cd aa fd			call debug_vector  
55b7				endm  
# End of macro CALLMONITOR
55b7				endif 
55b7			;		push hl 
55b7			;		FORTH_DSP_POP 
55b7			;		pop hl 
55b7			 
55b7			;		inc hl   ; move past the type marker 
55b7			 
55b7 cd 77 08				call storage_create 
55ba			 
55ba				if DEBUG_STORESE 
55ba					DMARK "CT1" 
55ba f5				push af  
55bb 3a cf 55			ld a, (.dmark)  
55be 32 a0 fd			ld (debug_mark),a  
55c1 3a d0 55			ld a, (.dmark+1)  
55c4 32 a1 fd			ld (debug_mark+1),a  
55c7 3a d1 55			ld a, (.dmark+2)  
55ca 32 a2 fd			ld (debug_mark+2),a  
55cd 18 03			jr .pastdmark  
55cf ..			.dmark: db "CT1"  
55d2 f1			.pastdmark: pop af  
55d3			endm  
# End of macro DMARK
55d3					CALLMONITOR 
55d3 cd aa fd			call debug_vector  
55d6				endm  
# End of macro CALLMONITOR
55d6				endif 
55d6			;		push hl 
55d6					FORTH_DSP_POP 
55d6 cd 05 23			call macro_forth_dsp_pop 
55d9				endm 
# End of macro FORTH_DSP_POP
55d9			;		pop hl 
55d9					; push file id to stack 
55d9 cd 48 20				call forth_push_numhl 
55dc			 
55dc			 
55dc			 
55dc				       NEXTW 
55dc c3 39 24			jp macro_next 
55df				endm 
# End of macro NEXTW
55df			 
55df			.APPEND: 
55df				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
55df 69				db WORD_SYS_CORE+85             
55e0 70 56			dw .SDEL            
55e2 07				db 6 + 1 
55e3 .. 00			db "APPEND",0              
55ea				endm 
# End of macro CWHEAD
55ea			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
55ea			; | | e.g. 
55ea			; | | Test CREATE      -> $01 
55ea			; | | "A string to add to file" $01 APPEND 
55ea			; | |  
55ea			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
55ea			; | | > [!NOTE] 
55ea			; | | > Compatible with PicoSPINet  
55ea					if DEBUG_FORTH_WORDS_KEY 
55ea						DMARK "APP" 
55ea f5				push af  
55eb 3a ff 55			ld a, (.dmark)  
55ee 32 a0 fd			ld (debug_mark),a  
55f1 3a 00 56			ld a, (.dmark+1)  
55f4 32 a1 fd			ld (debug_mark+1),a  
55f7 3a 01 56			ld a, (.dmark+2)  
55fa 32 a2 fd			ld (debug_mark+2),a  
55fd 18 03			jr .pastdmark  
55ff ..			.dmark: db "APP"  
5602 f1			.pastdmark: pop af  
5603			endm  
# End of macro DMARK
5603						CALLMONITOR 
5603 cd aa fd			call debug_vector  
5606				endm  
# End of macro CALLMONITOR
5606					endif 
5606			 
5606					FORTH_DSP_VALUEHL 
5606 cd 4d 22			call macro_dsp_valuehl 
5609				endm 
# End of macro FORTH_DSP_VALUEHL
5609 e5					push hl 	; save file id 
560a			 
560a				if DEBUG_STORESE 
560a					DMARK "AP1" 
560a f5				push af  
560b 3a 1f 56			ld a, (.dmark)  
560e 32 a0 fd			ld (debug_mark),a  
5611 3a 20 56			ld a, (.dmark+1)  
5614 32 a1 fd			ld (debug_mark+1),a  
5617 3a 21 56			ld a, (.dmark+2)  
561a 32 a2 fd			ld (debug_mark+2),a  
561d 18 03			jr .pastdmark  
561f ..			.dmark: db "AP1"  
5622 f1			.pastdmark: pop af  
5623			endm  
# End of macro DMARK
5623					CALLMONITOR 
5623 cd aa fd			call debug_vector  
5626				endm  
# End of macro CALLMONITOR
5626				endif 
5626					FORTH_DSP_POP 
5626 cd 05 23			call macro_forth_dsp_pop 
5629				endm 
# End of macro FORTH_DSP_POP
5629			 
5629					FORTH_DSP_VALUEHL 
5629 cd 4d 22			call macro_dsp_valuehl 
562c				endm 
# End of macro FORTH_DSP_VALUEHL
562c					;v5 FORTH_DSP_VALUE 
562c e5					push hl 	; save ptr to string to save 
562d			 
562d				if DEBUG_STORESE 
562d					DMARK "AP1" 
562d f5				push af  
562e 3a 42 56			ld a, (.dmark)  
5631 32 a0 fd			ld (debug_mark),a  
5634 3a 43 56			ld a, (.dmark+1)  
5637 32 a1 fd			ld (debug_mark+1),a  
563a 3a 44 56			ld a, (.dmark+2)  
563d 32 a2 fd			ld (debug_mark+2),a  
5640 18 03			jr .pastdmark  
5642 ..			.dmark: db "AP1"  
5645 f1			.pastdmark: pop af  
5646			endm  
# End of macro DMARK
5646					CALLMONITOR 
5646 cd aa fd			call debug_vector  
5649				endm  
# End of macro CALLMONITOR
5649				endif 
5649					FORTH_DSP_POP 
5649 cd 05 23			call macro_forth_dsp_pop 
564c				endm 
# End of macro FORTH_DSP_POP
564c			 
564c d1					pop de 
564d e1					pop hl 
564e				if DEBUG_STORESE 
564e					DMARK "AP2" 
564e f5				push af  
564f 3a 63 56			ld a, (.dmark)  
5652 32 a0 fd			ld (debug_mark),a  
5655 3a 64 56			ld a, (.dmark+1)  
5658 32 a1 fd			ld (debug_mark+1),a  
565b 3a 65 56			ld a, (.dmark+2)  
565e 32 a2 fd			ld (debug_mark+2),a  
5661 18 03			jr .pastdmark  
5663 ..			.dmark: db "AP2"  
5666 f1			.pastdmark: pop af  
5667			endm  
# End of macro DMARK
5667					CALLMONITOR 
5667 cd aa fd			call debug_vector  
566a				endm  
# End of macro CALLMONITOR
566a				endif 
566a					;inc de ; skip var type indicator 
566a			 
566a					; TODO how to append numerics???? 
566a			 
566a cd 64 0b				call storage_append		 
566d			 
566d				       NEXTW 
566d c3 39 24			jp macro_next 
5670				endm 
# End of macro NEXTW
5670			.SDEL: 
5670				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
5670 6a				db WORD_SYS_CORE+86             
5671 bc 56			dw .OPEN            
5673 05				db 4 + 1 
5674 .. 00			db "ERA",0              
5678				endm 
# End of macro CWHEAD
5678			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
5678			; | | > [!NOTE] 
5678			; | | > Compatible with PicoSPINet  
5678					FORTH_DSP_VALUEHL 
5678 cd 4d 22			call macro_dsp_valuehl 
567b				endm 
# End of macro FORTH_DSP_VALUEHL
567b			;		push hl 	; save file id 
567b			 
567b					if DEBUG_FORTH_WORDS_KEY 
567b						DMARK "ERA" 
567b f5				push af  
567c 3a 90 56			ld a, (.dmark)  
567f 32 a0 fd			ld (debug_mark),a  
5682 3a 91 56			ld a, (.dmark+1)  
5685 32 a1 fd			ld (debug_mark+1),a  
5688 3a 92 56			ld a, (.dmark+2)  
568b 32 a2 fd			ld (debug_mark+2),a  
568e 18 03			jr .pastdmark  
5690 ..			.dmark: db "ERA"  
5693 f1			.pastdmark: pop af  
5694			endm  
# End of macro DMARK
5694						CALLMONITOR 
5694 cd aa fd			call debug_vector  
5697				endm  
# End of macro CALLMONITOR
5697					endif 
5697				if DEBUG_STORESE 
5697					DMARK "ER1" 
5697 f5				push af  
5698 3a ac 56			ld a, (.dmark)  
569b 32 a0 fd			ld (debug_mark),a  
569e 3a ad 56			ld a, (.dmark+1)  
56a1 32 a1 fd			ld (debug_mark+1),a  
56a4 3a ae 56			ld a, (.dmark+2)  
56a7 32 a2 fd			ld (debug_mark+2),a  
56aa 18 03			jr .pastdmark  
56ac ..			.dmark: db "ER1"  
56af f1			.pastdmark: pop af  
56b0			endm  
# End of macro DMARK
56b0					CALLMONITOR 
56b0 cd aa fd			call debug_vector  
56b3				endm  
# End of macro CALLMONITOR
56b3				endif 
56b3					FORTH_DSP_POP 
56b3 cd 05 23			call macro_forth_dsp_pop 
56b6				endm 
# End of macro FORTH_DSP_POP
56b6			 
56b6			;		pop hl 
56b6			 
56b6 cd b6 06				call storage_erase 
56b9				       NEXTW 
56b9 c3 39 24			jp macro_next 
56bc				endm 
# End of macro NEXTW
56bc			 
56bc			.OPEN: 
56bc				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
56bc 6b				db WORD_SYS_CORE+87             
56bd 50 57			dw .READ            
56bf 05				db 4 + 1 
56c0 .. 00			db "OPEN",0              
56c5				endm 
# End of macro CWHEAD
56c5			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
56c5			; | | e.g. 
56c5			; | | $01 OPEN $01 DO $01 READ . LOOP 
56c5			; | | 
56c5			; | | Will return with 255 blocks if the file does not exist 
56c5			; | | > [!NOTE] 
56c5			; | | > Compatible with PicoSPINet  
56c5			 
56c5					if DEBUG_FORTH_WORDS_KEY 
56c5						DMARK "OPN" 
56c5 f5				push af  
56c6 3a da 56			ld a, (.dmark)  
56c9 32 a0 fd			ld (debug_mark),a  
56cc 3a db 56			ld a, (.dmark+1)  
56cf 32 a1 fd			ld (debug_mark+1),a  
56d2 3a dc 56			ld a, (.dmark+2)  
56d5 32 a2 fd			ld (debug_mark+2),a  
56d8 18 03			jr .pastdmark  
56da ..			.dmark: db "OPN"  
56dd f1			.pastdmark: pop af  
56de			endm  
# End of macro DMARK
56de						CALLMONITOR 
56de cd aa fd			call debug_vector  
56e1				endm  
# End of macro CALLMONITOR
56e1					endif 
56e1					; TODO handle multiple file opens 
56e1			 
56e1 3e 01			       	ld a, 1 
56e3 32 9f f9				ld (store_openext), a 
56e6			 
56e6					; get max extents for this file 
56e6				 
56e6								 
56e6					FORTH_DSP_VALUEHL 
56e6 cd 4d 22			call macro_dsp_valuehl 
56e9				endm 
# End of macro FORTH_DSP_VALUEHL
56e9			 
56e9 65					ld h, l 
56ea 2e 00				ld l, 0 
56ec			 
56ec					; store file id 
56ec			 
56ec 7c					ld a, h 
56ed 32 9c f9				ld (store_filecache), a 
56f0			 
56f0				if DEBUG_STORESE 
56f0					DMARK "OPN" 
56f0 f5				push af  
56f1 3a 05 57			ld a, (.dmark)  
56f4 32 a0 fd			ld (debug_mark),a  
56f7 3a 06 57			ld a, (.dmark+1)  
56fa 32 a1 fd			ld (debug_mark+1),a  
56fd 3a 07 57			ld a, (.dmark+2)  
5700 32 a2 fd			ld (debug_mark+2),a  
5703 18 03			jr .pastdmark  
5705 ..			.dmark: db "OPN"  
5708 f1			.pastdmark: pop af  
5709			endm  
# End of macro DMARK
5709					CALLMONITOR 
5709 cd aa fd			call debug_vector  
570c				endm  
# End of macro CALLMONITOR
570c				endif 
570c			;		push hl 
570c					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
570c cd 05 23			call macro_forth_dsp_pop 
570f				endm 
# End of macro FORTH_DSP_POP
570f			;		pop hl 
570f						 
570f 11 af f9				ld de, store_page      ; get block zero of file 
5712 cd cd 09				call storage_read 
5715 cd 07 10			call ishlzero 
5718 20 04			jr nz, .opfound 
571a			 
571a				; file does not exist so indicate with 255 extents in use 
571a			 
571a 3e ff			ld a, 255 
571c 18 29			jr .skipopeneof 
571e			 
571e			 
571e			.opfound: 
571e			 
571e			 
571e 3a b1 f9				ld a, (store_page+2)    ; max extents for this file 
5721 32 9e f9				ld  (store_openmaxext), a   ; get our limit and push 
5724					 
5724				if DEBUG_STORESE 
5724					DMARK "OPx" 
5724 f5				push af  
5725 3a 39 57			ld a, (.dmark)  
5728 32 a0 fd			ld (debug_mark),a  
572b 3a 3a 57			ld a, (.dmark+1)  
572e 32 a1 fd			ld (debug_mark+1),a  
5731 3a 3b 57			ld a, (.dmark+2)  
5734 32 a2 fd			ld (debug_mark+2),a  
5737 18 03			jr .pastdmark  
5739 ..			.dmark: db "OPx"  
573c f1			.pastdmark: pop af  
573d			endm  
# End of macro DMARK
573d					CALLMONITOR 
573d cd aa fd			call debug_vector  
5740				endm  
# End of macro CALLMONITOR
5740				endif 
5740 fe 00				cp 0 
5742 20 03				jr nz, .skipopeneof 
5744					; have opened an empty file 
5744					 
5744 32 9f f9				ld (store_openext), a 
5747			 
5747			.skipopeneof: 
5747			 
5747 6f					ld l, a 
5748 26 00				ld h, 0 
574a cd 48 20				call forth_push_numhl 
574d			 
574d			 
574d				       NEXTW 
574d c3 39 24			jp macro_next 
5750				endm 
# End of macro NEXTW
5750			.READ: 
5750				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
5750 6c				db WORD_SYS_CORE+88             
5751 7a 58			dw .EOF            
5753 05				db 4 + 1 
5754 .. 00			db "READ",0              
5759				endm 
# End of macro CWHEAD
5759			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
5759			; | | e.g. 
5759			; | | $01 OPEN $01 DO READ . LOOP 
5759			; | | 
5759			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
5759			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
5759			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
5759			; | | two bytes contain the file id and extent. 
5759			; | |  
5759			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
5759			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
5759			; | | > [!NOTE] 
5759			; | | > Compatible with PicoSPINet  
5759			 
5759					if DEBUG_FORTH_WORDS_KEY 
5759						DMARK "REA" 
5759 f5				push af  
575a 3a 6e 57			ld a, (.dmark)  
575d 32 a0 fd			ld (debug_mark),a  
5760 3a 6f 57			ld a, (.dmark+1)  
5763 32 a1 fd			ld (debug_mark+1),a  
5766 3a 70 57			ld a, (.dmark+2)  
5769 32 a2 fd			ld (debug_mark+2),a  
576c 18 03			jr .pastdmark  
576e ..			.dmark: db "REA"  
5771 f1			.pastdmark: pop af  
5772			endm  
# End of macro DMARK
5772						CALLMONITOR 
5772 cd aa fd			call debug_vector  
5775				endm  
# End of macro CALLMONITOR
5775					endif 
5775					; store_openext use it. If zero it is EOF 
5775			 
5775					; read block from current stream id 
5775					; if the block does not contain zero term keep reading blocks until zero found 
5775					; push the block to stack 
5775					; save the block id to stream 
5775			 
5775			 
5775 cd a7 58				call .testeof 
5778 3e 01				ld a, 1 
577a bd					cp l 
577b ca 56 58				jp z, .ateof 
577e			 
577e			 
577e			;		FORTH_DSP_VALUEHL 
577e			 
577e			;		push hl 
577e			 
577e			;	if DEBUG_STORESE 
577e			;		DMARK "REA" 
577e			;		CALLMONITOR 
577e			;	endif 
577e			;		FORTH_DSP_POP 
577e			 
577e			;		pop hl 
577e				 
577e 3a 9c f9				ld a, (store_filecache) 
5781 67					ld h,a 
5782			 
5782 3a 9f f9				ld a, (store_openext) 
5785 6f					ld l, a 
5786					 
5786 fe 00				cp 0 
5788 ca 56 58				jp z, .ateof     ; dont read past eof 
578b			 
578b cd b0 0c				call storage_clear_page 
578e			 
578e 11 af f9				ld de, store_page 
5791				if DEBUG_STORESE 
5791					DMARK "RE1" 
5791 f5				push af  
5792 3a a6 57			ld a, (.dmark)  
5795 32 a0 fd			ld (debug_mark),a  
5798 3a a7 57			ld a, (.dmark+1)  
579b 32 a1 fd			ld (debug_mark+1),a  
579e 3a a8 57			ld a, (.dmark+2)  
57a1 32 a2 fd			ld (debug_mark+2),a  
57a4 18 03			jr .pastdmark  
57a6 ..			.dmark: db "RE1"  
57a9 f1			.pastdmark: pop af  
57aa			endm  
# End of macro DMARK
57aa					CALLMONITOR 
57aa cd aa fd			call debug_vector  
57ad				endm  
# End of macro CALLMONITOR
57ad				endif 
57ad cd cd 09				call storage_read 
57b0			 
57b0				if DEBUG_STORESE 
57b0					DMARK "RE2" 
57b0 f5				push af  
57b1 3a c5 57			ld a, (.dmark)  
57b4 32 a0 fd			ld (debug_mark),a  
57b7 3a c6 57			ld a, (.dmark+1)  
57ba 32 a1 fd			ld (debug_mark+1),a  
57bd 3a c7 57			ld a, (.dmark+2)  
57c0 32 a2 fd			ld (debug_mark+2),a  
57c3 18 03			jr .pastdmark  
57c5 ..			.dmark: db "RE2"  
57c8 f1			.pastdmark: pop af  
57c9			endm  
# End of macro DMARK
57c9					CALLMONITOR 
57c9 cd aa fd			call debug_vector  
57cc				endm  
# End of macro CALLMONITOR
57cc				endif 
57cc cd 07 10			call ishlzero 
57cf			;	ld a, l 
57cf			;	add h 
57cf			;	cp 0 
57cf ca 56 58			jp z, .readeof 
57d2			 
57d2				; not eof so hl should point to data to push to stack 
57d2			 
57d2				if DEBUG_STORESE 
57d2					DMARK "RE3" 
57d2 f5				push af  
57d3 3a e7 57			ld a, (.dmark)  
57d6 32 a0 fd			ld (debug_mark),a  
57d9 3a e8 57			ld a, (.dmark+1)  
57dc 32 a1 fd			ld (debug_mark+1),a  
57df 3a e9 57			ld a, (.dmark+2)  
57e2 32 a2 fd			ld (debug_mark+2),a  
57e5 18 03			jr .pastdmark  
57e7 ..			.dmark: db "RE3"  
57ea f1			.pastdmark: pop af  
57eb			endm  
# End of macro DMARK
57eb					CALLMONITOR 
57eb cd aa fd			call debug_vector  
57ee				endm  
# End of macro CALLMONITOR
57ee				endif 
57ee cd b6 20			call forth_push_str 
57f1			 
57f1				if DEBUG_STORESE 
57f1					DMARK "RE4" 
57f1 f5				push af  
57f2 3a 06 58			ld a, (.dmark)  
57f5 32 a0 fd			ld (debug_mark),a  
57f8 3a 07 58			ld a, (.dmark+1)  
57fb 32 a1 fd			ld (debug_mark+1),a  
57fe 3a 08 58			ld a, (.dmark+2)  
5801 32 a2 fd			ld (debug_mark+2),a  
5804 18 03			jr .pastdmark  
5806 ..			.dmark: db "RE4"  
5809 f1			.pastdmark: pop af  
580a			endm  
# End of macro DMARK
580a					CALLMONITOR 
580a cd aa fd			call debug_vector  
580d				endm  
# End of macro CALLMONITOR
580d				endif 
580d				; get next block  or mark as eof 
580d			 
580d 3a 9e f9			ld a, (store_openmaxext)   ; get our limit 
5810 4f				ld c, a	 
5811 3a 9f f9			ld a, (store_openext) 
5814			 
5814				if DEBUG_STORESE 
5814					DMARK "RE5" 
5814 f5				push af  
5815 3a 29 58			ld a, (.dmark)  
5818 32 a0 fd			ld (debug_mark),a  
581b 3a 2a 58			ld a, (.dmark+1)  
581e 32 a1 fd			ld (debug_mark+1),a  
5821 3a 2b 58			ld a, (.dmark+2)  
5824 32 a2 fd			ld (debug_mark+2),a  
5827 18 03			jr .pastdmark  
5829 ..			.dmark: db "RE5"  
582c f1			.pastdmark: pop af  
582d			endm  
# End of macro DMARK
582d					CALLMONITOR 
582d cd aa fd			call debug_vector  
5830				endm  
# End of macro CALLMONITOR
5830				endif 
5830 b9				cp c 
5831 28 23			jr z, .readeof     ; at last extent 
5833			 
5833 3c					inc a 
5834 32 9f f9				ld (store_openext), a 
5837			 
5837				if DEBUG_STORESE 
5837					DMARK "RE6" 
5837 f5				push af  
5838 3a 4c 58			ld a, (.dmark)  
583b 32 a0 fd			ld (debug_mark),a  
583e 3a 4d 58			ld a, (.dmark+1)  
5841 32 a1 fd			ld (debug_mark+1),a  
5844 3a 4e 58			ld a, (.dmark+2)  
5847 32 a2 fd			ld (debug_mark+2),a  
584a 18 03			jr .pastdmark  
584c ..			.dmark: db "RE6"  
584f f1			.pastdmark: pop af  
5850			endm  
# End of macro DMARK
5850					CALLMONITOR 
5850 cd aa fd			call debug_vector  
5853				endm  
# End of macro CALLMONITOR
5853				endif 
5853			 
5853			 
5853				       NEXTW 
5853 c3 39 24			jp macro_next 
5856				endm 
# End of macro NEXTW
5856			.ateof: 
5856				;	ld hl, .showeof 
5856				;	call forth_push_str 
5856 3e 00		.readeof:	ld a, 0 
5858 32 9f f9				ld (store_openext), a 
585b			 
585b					 
585b				if DEBUG_STORESE 
585b					DMARK "REF" 
585b f5				push af  
585c 3a 70 58			ld a, (.dmark)  
585f 32 a0 fd			ld (debug_mark),a  
5862 3a 71 58			ld a, (.dmark+1)  
5865 32 a1 fd			ld (debug_mark+1),a  
5868 3a 72 58			ld a, (.dmark+2)  
586b 32 a2 fd			ld (debug_mark+2),a  
586e 18 03			jr .pastdmark  
5870 ..			.dmark: db "REF"  
5873 f1			.pastdmark: pop af  
5874			endm  
# End of macro DMARK
5874					CALLMONITOR 
5874 cd aa fd			call debug_vector  
5877				endm  
# End of macro CALLMONITOR
5877				endif 
5877				       NEXTW 
5877 c3 39 24			jp macro_next 
587a				endm 
# End of macro NEXTW
587a			 
587a			;.showeof:   db "eof", 0 
587a			 
587a			 
587a			.EOF: 
587a				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
587a 6d				db WORD_SYS_CORE+89             
587b bc 58			dw .FORMAT            
587d 04				db 3 + 1 
587e .. 00			db "EOF",0              
5882				endm 
# End of macro CWHEAD
5882			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
5882			; | | e.g. 
5882			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
5882			; | | > [!NOTE] 
5882			; | | > Compatible with PicoSPINet  
5882					; TODO if current block id for stream is zero then push true else false 
5882			 
5882					if DEBUG_FORTH_WORDS_KEY 
5882						DMARK "EOF" 
5882 f5				push af  
5883 3a 97 58			ld a, (.dmark)  
5886 32 a0 fd			ld (debug_mark),a  
5889 3a 98 58			ld a, (.dmark+1)  
588c 32 a1 fd			ld (debug_mark+1),a  
588f 3a 99 58			ld a, (.dmark+2)  
5892 32 a2 fd			ld (debug_mark+2),a  
5895 18 03			jr .pastdmark  
5897 ..			.dmark: db "EOF"  
589a f1			.pastdmark: pop af  
589b			endm  
# End of macro DMARK
589b						CALLMONITOR 
589b cd aa fd			call debug_vector  
589e				endm  
# End of macro CALLMONITOR
589e					endif 
589e			 
589e					; TODO handlue multiple file streams 
589e			 
589e			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
589e cd a7 58				call .testeof 
58a1 cd 48 20				call forth_push_numhl 
58a4			 
58a4			 
58a4				       NEXTW 
58a4 c3 39 24			jp macro_next 
58a7				endm 
# End of macro NEXTW
58a7			 
58a7			.testeof: 
58a7 2e 01				ld l, 1 
58a9 3a 9e f9				ld a, (store_openmaxext) 
58ac fe 00				cp 0 
58ae 28 09				jr  z, .eofdone   ; empty file 
58b0 3a 9f f9				ld a, (store_openext) 
58b3 fe 00				cp 0 
58b5 28 02				jr  z, .eofdone 
58b7 2e 00				ld l, 0 
58b9 26 00		.eofdone:	ld h, 0 
58bb c9					ret 
58bc			 
58bc			 
58bc			 
58bc			 
58bc			.FORMAT: 
58bc				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
58bc 6d				db WORD_SYS_CORE+89             
58bd 0d 59			dw .LABEL            
58bf 07				db 6 + 1 
58c0 .. 00			db "FORMAT",0              
58c7				endm 
# End of macro CWHEAD
58c7			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
58c7			; | | > [!NOTE] 
58c7			; | | > Compatible with PicoSPINet  
58c7					; TODO if current block id for stream is zero then push true else false 
58c7				 
58c7				if DEBUG_STORESE 
58c7					DMARK "FOR" 
58c7 f5				push af  
58c8 3a dc 58			ld a, (.dmark)  
58cb 32 a0 fd			ld (debug_mark),a  
58ce 3a dd 58			ld a, (.dmark+1)  
58d1 32 a1 fd			ld (debug_mark+1),a  
58d4 3a de 58			ld a, (.dmark+2)  
58d7 32 a2 fd			ld (debug_mark+2),a  
58da 18 03			jr .pastdmark  
58dc ..			.dmark: db "FOR"  
58df f1			.pastdmark: pop af  
58e0			endm  
# End of macro DMARK
58e0					CALLMONITOR 
58e0 cd aa fd			call debug_vector  
58e3				endm  
# End of macro CALLMONITOR
58e3				endif 
58e3					; Wipes the bank check flags to cause a reformat on next block 0 read 
58e3			 
58e3 21 01 00				ld hl, 1 
58e6 3e 00				ld a, 0 
58e8 cd 79 02				call se_writebyte 
58eb			 
58eb				if DEBUG_STORESE 
58eb					DMARK "FO0" 
58eb f5				push af  
58ec 3a 00 59			ld a, (.dmark)  
58ef 32 a0 fd			ld (debug_mark),a  
58f2 3a 01 59			ld a, (.dmark+1)  
58f5 32 a1 fd			ld (debug_mark+1),a  
58f8 3a 02 59			ld a, (.dmark+2)  
58fb 32 a2 fd			ld (debug_mark+2),a  
58fe 18 03			jr .pastdmark  
5900 ..			.dmark: db "FO0"  
5903 f1			.pastdmark: pop af  
5904			endm  
# End of macro DMARK
5904					CALLMONITOR 
5904 cd aa fd			call debug_vector  
5907				endm  
# End of macro CALLMONITOR
5907				endif 
5907					; force bank init 
5907			 
5907 cd 25 05				call storage_get_block_0 
590a					 
590a				       NEXTW 
590a c3 39 24			jp macro_next 
590d				endm 
# End of macro NEXTW
590d			.LABEL: 
590d				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
590d 6d				db WORD_SYS_CORE+89             
590e 5b 59			dw .STOREPAGE            
5910 06				db 5 + 1 
5911 .. 00			db "LABEL",0              
5917				endm 
# End of macro CWHEAD
5917			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5917			; | | > [!NOTE] 
5917			; | | > Compatible with PicoSPINet  
5917					; TODO test to see if bank is selected 
5917				 
5917					if DEBUG_FORTH_WORDS_KEY 
5917						DMARK "LBL" 
5917 f5				push af  
5918 3a 2c 59			ld a, (.dmark)  
591b 32 a0 fd			ld (debug_mark),a  
591e 3a 2d 59			ld a, (.dmark+1)  
5921 32 a1 fd			ld (debug_mark+1),a  
5924 3a 2e 59			ld a, (.dmark+2)  
5927 32 a2 fd			ld (debug_mark+2),a  
592a 18 03			jr .pastdmark  
592c ..			.dmark: db "LBL"  
592f f1			.pastdmark: pop af  
5930			endm  
# End of macro DMARK
5930						CALLMONITOR 
5930 cd aa fd			call debug_vector  
5933				endm  
# End of macro CALLMONITOR
5933					endif 
5933			;	if DEBUG_STORESE 
5933			;		DMARK "LBL" 
5933			;		CALLMONITOR 
5933			;	endif 
5933					FORTH_DSP_VALUEHL 
5933 cd 4d 22			call macro_dsp_valuehl 
5936				endm 
# End of macro FORTH_DSP_VALUEHL
5936					;v5FORTH_DSP_VALUE 
5936					 
5936			;		push hl 
5936					FORTH_DSP_POP 
5936 cd 05 23			call macro_forth_dsp_pop 
5939				endm 
# End of macro FORTH_DSP_POP
5939			;		pop hl 
5939			 
5939			;v5		inc hl   ; move past the type marker 
5939			 
5939				if DEBUG_STORESE 
5939					DMARK "LBl" 
5939 f5				push af  
593a 3a 4e 59			ld a, (.dmark)  
593d 32 a0 fd			ld (debug_mark),a  
5940 3a 4f 59			ld a, (.dmark+1)  
5943 32 a1 fd			ld (debug_mark+1),a  
5946 3a 50 59			ld a, (.dmark+2)  
5949 32 a2 fd			ld (debug_mark+2),a  
594c 18 03			jr .pastdmark  
594e ..			.dmark: db "LBl"  
5951 f1			.pastdmark: pop af  
5952			endm  
# End of macro DMARK
5952					CALLMONITOR 
5952 cd aa fd			call debug_vector  
5955				endm  
# End of macro CALLMONITOR
5955				endif 
5955 cd 49 06				call storage_label 
5958			 
5958				       NEXTW 
5958 c3 39 24			jp macro_next 
595b				endm 
# End of macro NEXTW
595b			.STOREPAGE: 
595b				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
595b 6d				db WORD_SYS_CORE+89             
595c 8e 59			dw .LABELS            
595e 0a				db 9 + 1 
595f .. 00			db "STOREPAGE",0              
5969				endm 
# End of macro CWHEAD
5969			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5969			; | | > [!NOTE] 
5969			; | | > Compatible with PicoSPINet  
5969					; TODO test to see if bank is selected 
5969				 
5969					if DEBUG_FORTH_WORDS_KEY 
5969						DMARK "STP" 
5969 f5				push af  
596a 3a 7e 59			ld a, (.dmark)  
596d 32 a0 fd			ld (debug_mark),a  
5970 3a 7f 59			ld a, (.dmark+1)  
5973 32 a1 fd			ld (debug_mark+1),a  
5976 3a 80 59			ld a, (.dmark+2)  
5979 32 a2 fd			ld (debug_mark+2),a  
597c 18 03			jr .pastdmark  
597e ..			.dmark: db "STP"  
5981 f1			.pastdmark: pop af  
5982			endm  
# End of macro DMARK
5982						CALLMONITOR 
5982 cd aa fd			call debug_vector  
5985				endm  
# End of macro CALLMONITOR
5985					endif 
5985			;	if DEBUG_STORESE 
5985			;		DMARK "STP" 
5985			;		CALLMONITOR 
5985			;	endif 
5985			 
5985 21 af f9			ld hl, store_page 
5988 cd 48 20			call forth_push_numhl 
598b			 
598b			 
598b				       NEXTW 
598b c3 39 24			jp macro_next 
598e				endm 
# End of macro NEXTW
598e			.LABELS: 
598e				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
598e 6d				db WORD_SYS_CORE+89             
598f 18 5a			dw .SCONST1            
5991 07				db 6 + 1 
5992 .. 00			db "LABELS",0              
5999				endm 
# End of macro CWHEAD
5999			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | DONE 
5999			; | | > [!CAUTION] 
5999			; | | > *NOT* Compatible with PicoSPINet  
5999					;  
5999			 
5999					; save the current device selected to restore afterwards 
5999				 
5999 3a 95 f9				ld a, (spi_device) 
599c f5					push af 
599d			 
599d			 
599d					; run through each of the banks 
599d			 
599d 21 01 00				ld hl, 1 
59a0 cd 48 20				call forth_push_numhl 
59a3 3e ff				ld a, SPI_CE_HIGH 
59a5 cb 87				res SPI_CE0, a 
59a7 32 95 f9				ld (spi_device), a 
59aa cd 25 05				call storage_get_block_0 
59ad 21 b2 f9				ld hl, store_page+3 
59b0 cd b6 20				call forth_push_str 
59b3			 
59b3					 
59b3 21 02 00				ld hl, 2 
59b6 cd 48 20				call forth_push_numhl 
59b9 3e ff				ld a, SPI_CE_HIGH 
59bb cb 8f				res SPI_CE1, a 
59bd 32 95 f9				ld (spi_device), a 
59c0 cd 25 05				call storage_get_block_0 
59c3 21 b2 f9				ld hl, store_page+3 
59c6 cd b6 20				call forth_push_str 
59c9			 
59c9					 
59c9 21 03 00				ld hl, 3 
59cc cd 48 20				call forth_push_numhl 
59cf 3e ff				ld a, SPI_CE_HIGH 
59d1 cb 97				res SPI_CE2, a 
59d3 32 95 f9				ld (spi_device), a 
59d6 cd 25 05				call storage_get_block_0 
59d9 21 b2 f9				ld hl, store_page+3 
59dc cd b6 20				call forth_push_str 
59df			 
59df			 
59df 21 04 00				ld hl, 4 
59e2 cd 48 20				call forth_push_numhl 
59e5 3e ff				ld a, SPI_CE_HIGH 
59e7 cb 9f				res SPI_CE3, a 
59e9 32 95 f9				ld (spi_device), a 
59ec cd 25 05				call storage_get_block_0 
59ef 21 b2 f9				ld hl, store_page+3 
59f2 cd b6 20				call forth_push_str 
59f5			 
59f5					 
59f5			 
59f5 21 05 00				ld hl, 5 
59f8 cd 48 20				call forth_push_numhl 
59fb 3e ff				ld a, SPI_CE_HIGH 
59fd cb a7				res SPI_CE4, a 
59ff 32 95 f9				ld (spi_device), a 
5a02 cd 25 05				call storage_get_block_0 
5a05 21 b2 f9				ld hl, store_page+3 
5a08 cd b6 20				call forth_push_str 
5a0b			 
5a0b					 
5a0b					; push fixed count of storage devices (on board) for now 
5a0b			 
5a0b 21 05 00				ld hl, 5 
5a0e cd 48 20				call forth_push_numhl 
5a11			 
5a11					; restore selected device  
5a11				 
5a11 f1					pop af 
5a12 32 95 f9				ld (spi_device), a 
5a15			 
5a15				       NEXTW 
5a15 c3 39 24			jp macro_next 
5a18				endm 
# End of macro NEXTW
5a18			 
5a18			.SCONST1: 
5a18				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
5a18 6d				db WORD_SYS_CORE+89             
5a19 2f 5a			dw .SCONST2            
5a1b 07				db 6 + 1 
5a1c .. 00			db "FILEID",0              
5a23				endm 
# End of macro CWHEAD
5a23			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
5a23			; | | > [!NOTE] 
5a23			; | | > Compatible with PicoSPINet  
5a23 3a 9c f9				ld a, (store_filecache) 
5a26 26 00				ld h, 0 
5a28 6f					ld l, a 
5a29 cd 48 20				call forth_push_numhl 
5a2c					NEXTW 
5a2c c3 39 24			jp macro_next 
5a2f				endm 
# End of macro NEXTW
5a2f			.SCONST2: 
5a2f				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
5a2f 6d				db WORD_SYS_CORE+89             
5a30 47 5a			dw .SCONST3            
5a32 08				db 7 + 1 
5a33 .. 00			db "FILEEXT",0              
5a3b				endm 
# End of macro CWHEAD
5a3b			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
5a3b			; | | > [!NOTE] 
5a3b			; | | > Compatible with PicoSPINet  
5a3b 3a 9f f9				ld a, (store_openext) 
5a3e 26 00				ld h, 0 
5a40 6f					ld l, a 
5a41 cd 48 20				call forth_push_numhl 
5a44					NEXTW 
5a44 c3 39 24			jp macro_next 
5a47				endm 
# End of macro NEXTW
5a47			.SCONST3: 
5a47				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
5a47 6d				db WORD_SYS_CORE+89             
5a48 5f 5a			dw .SCONST4            
5a4a 08				db 7 + 1 
5a4b .. 00			db "FILEMAX",0              
5a53				endm 
# End of macro CWHEAD
5a53			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
5a53			; | | > [!NOTE] 
5a53			; | | > Compatible with PicoSPINet  
5a53 3a 9e f9				ld a, (store_openmaxext) 
5a56 26 00				ld h, 0 
5a58 6f					ld l, a 
5a59 cd 48 20				call forth_push_numhl 
5a5c					NEXTW 
5a5c c3 39 24			jp macro_next 
5a5f				endm 
# End of macro NEXTW
5a5f			.SCONST4: 
5a5f				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
5a5f 6d				db WORD_SYS_CORE+89             
5a60 75 5a			dw .SCONST5            
5a62 09				db 8 + 1 
5a63 .. 00			db "FILEADDR",0              
5a6c				endm 
# End of macro CWHEAD
5a6c			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currently open file to stack | DONE 
5a6c			; | | > [!NOTE] 
5a6c			; | | > Compatible with PicoSPINet  
5a6c 2a a0 f9				ld hl, (store_openaddr) 
5a6f cd 48 20				call forth_push_numhl 
5a72					NEXTW 
5a72 c3 39 24			jp macro_next 
5a75				endm 
# End of macro NEXTW
5a75			.SCONST5: 
5a75				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
5a75 6d				db WORD_SYS_CORE+89             
5a76 96 5a			dw .SCONST6            
5a78 09				db 8 + 1 
5a79 .. 00			db "FILEPAGE",0              
5a82				endm 
# End of macro CWHEAD
5a82			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
5a82			; | | > [!NOTE] 
5a82			; | | > Compatible with PicoSPINet  
5a82 2a a0 f9				ld hl, (store_openaddr) 
5a85 e5					push hl 
5a86 c1					pop bc 
5a87 16 00				ld d, 0 
5a89 1e 40				ld e, STORE_BLOCK_PHY 
5a8b cd 3b 0f				call Div16 
5a8e c5					push bc 
5a8f e1					pop hl 
5a90 cd 48 20				call forth_push_numhl 
5a93					NEXTW 
5a93 c3 39 24			jp macro_next 
5a96				endm 
# End of macro NEXTW
5a96			.SCONST6: 
5a96				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
5a96 6d				db WORD_SYS_CORE+89             
5a97 af 5a			dw .ENDSTORAGE            
5a99 09				db 8 + 1 
5a9a .. 00			db "READCONT",0              
5aa3				endm 
# End of macro CWHEAD
5aa3			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
5aa3			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
5aa3			; | | a further read should, if applicable, be CONCAT to the previous read. 
5aa3			; | | > [!NOTE] 
5aa3			; | | > Compatible with PicoSPINet  
5aa3 3a a2 f9				ld a, (store_readcont) 
5aa6 26 00				ld h, 0 
5aa8 6f					ld l, a 
5aa9 cd 48 20				call forth_push_numhl 
5aac					NEXTW 
5aac c3 39 24			jp macro_next 
5aaf				endm 
# End of macro NEXTW
5aaf			.ENDSTORAGE: 
5aaf			; eof 
# End of file forth_words_storage.asm
5aaf			endif 
5aaf				include "forth_words_device.asm" 
5aaf			; Device related words 
5aaf			 
5aaf			; | ## Device Words 
5aaf			 
5aaf			;if SOUND_ENABLE 
5aaf			;.NOTE: 
5aaf			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
5aaf			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
5aaf			;		if DEBUG_FORTH_WORDS_KEY 
5aaf			;			DMARK "NTE" 
5aaf			;			CALLMONITOR 
5aaf			;		endif 
5aaf			; 
5aaf			;	 
5aaf			; 
5aaf			;		NEXTW 
5aaf			;.AFTERSOUND: 
5aaf			;endif 
5aaf			 
5aaf			 
5aaf			USE_GPIO: equ 0 
5aaf			 
5aaf			if USE_GPIO 
5aaf			.GP1: 
5aaf				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
5aaf			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
5aaf					NEXTW 
5aaf			.GP2: 
5aaf				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
5aaf			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
5aaf			 
5aaf					NEXTW 
5aaf			 
5aaf			.GP3: 
5aaf				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
5aaf			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
5aaf			 
5aaf					NEXTW 
5aaf			 
5aaf			.GP4: 
5aaf				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
5aaf			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
5aaf			 
5aaf					NEXTW 
5aaf			.SIN: 
5aaf			 
5aaf			 
5aaf			endif 
5aaf			 
5aaf			 
5aaf				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
5aaf 33				db WORD_SYS_CORE+31             
5ab0 e4 5a			dw .SOUT            
5ab2 03				db 2 + 1 
5ab3 .. 00			db "IN",0              
5ab6				endm 
# End of macro CWHEAD
5ab6			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
5ab6					if DEBUG_FORTH_WORDS_KEY 
5ab6						DMARK "IN." 
5ab6 f5				push af  
5ab7 3a cb 5a			ld a, (.dmark)  
5aba 32 a0 fd			ld (debug_mark),a  
5abd 3a cc 5a			ld a, (.dmark+1)  
5ac0 32 a1 fd			ld (debug_mark+1),a  
5ac3 3a cd 5a			ld a, (.dmark+2)  
5ac6 32 a2 fd			ld (debug_mark+2),a  
5ac9 18 03			jr .pastdmark  
5acb ..			.dmark: db "IN."  
5ace f1			.pastdmark: pop af  
5acf			endm  
# End of macro DMARK
5acf						CALLMONITOR 
5acf cd aa fd			call debug_vector  
5ad2				endm  
# End of macro CALLMONITOR
5ad2					endif 
5ad2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ad2 cd 4d 22			call macro_dsp_valuehl 
5ad5				endm 
# End of macro FORTH_DSP_VALUEHL
5ad5			 
5ad5 e5					push hl 
5ad6			 
5ad6					; destroy value TOS 
5ad6			 
5ad6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ad6 cd 05 23			call macro_forth_dsp_pop 
5ad9				endm 
# End of macro FORTH_DSP_POP
5ad9			 
5ad9					; one value on hl get other one back 
5ad9			 
5ad9 c1					pop bc 
5ada			 
5ada					; do the sub 
5ada			;		ex de, hl 
5ada			 
5ada ed 68				in l,(c) 
5adc			 
5adc					; save it 
5adc			 
5adc 26 00				ld h,0 
5ade			 
5ade					; TODO push value back onto stack for another op etc 
5ade			 
5ade cd 48 20				call forth_push_numhl 
5ae1					NEXTW 
5ae1 c3 39 24			jp macro_next 
5ae4				endm 
# End of macro NEXTW
5ae4			.SOUT: 
5ae4				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
5ae4 34				db WORD_SYS_CORE+32             
5ae5 37 5b			dw .SPIO            
5ae7 04				db 3 + 1 
5ae8 .. 00			db "OUT",0              
5aec				endm 
# End of macro CWHEAD
5aec			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
5aec					if DEBUG_FORTH_WORDS_KEY 
5aec						DMARK "OUT" 
5aec f5				push af  
5aed 3a 01 5b			ld a, (.dmark)  
5af0 32 a0 fd			ld (debug_mark),a  
5af3 3a 02 5b			ld a, (.dmark+1)  
5af6 32 a1 fd			ld (debug_mark+1),a  
5af9 3a 03 5b			ld a, (.dmark+2)  
5afc 32 a2 fd			ld (debug_mark+2),a  
5aff 18 03			jr .pastdmark  
5b01 ..			.dmark: db "OUT"  
5b04 f1			.pastdmark: pop af  
5b05			endm  
# End of macro DMARK
5b05						CALLMONITOR 
5b05 cd aa fd			call debug_vector  
5b08				endm  
# End of macro CALLMONITOR
5b08					endif 
5b08			 
5b08					; get port 
5b08			 
5b08					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b08 cd 4d 22			call macro_dsp_valuehl 
5b0b				endm 
# End of macro FORTH_DSP_VALUEHL
5b0b			 
5b0b e5					push hl 
5b0c			 
5b0c					; destroy value TOS 
5b0c			 
5b0c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b0c cd 05 23			call macro_forth_dsp_pop 
5b0f				endm 
# End of macro FORTH_DSP_POP
5b0f			 
5b0f					; get byte to send 
5b0f			 
5b0f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b0f cd 4d 22			call macro_dsp_valuehl 
5b12				endm 
# End of macro FORTH_DSP_VALUEHL
5b12			 
5b12			;		push hl 
5b12			 
5b12					; destroy value TOS 
5b12			 
5b12					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b12 cd 05 23			call macro_forth_dsp_pop 
5b15				endm 
# End of macro FORTH_DSP_POP
5b15			 
5b15					; one value on hl get other one back 
5b15			 
5b15			;		pop hl 
5b15			 
5b15 c1					pop bc 
5b16			 
5b16					if DEBUG_FORTH_WORDS 
5b16						DMARK "OUT" 
5b16 f5				push af  
5b17 3a 2b 5b			ld a, (.dmark)  
5b1a 32 a0 fd			ld (debug_mark),a  
5b1d 3a 2c 5b			ld a, (.dmark+1)  
5b20 32 a1 fd			ld (debug_mark+1),a  
5b23 3a 2d 5b			ld a, (.dmark+2)  
5b26 32 a2 fd			ld (debug_mark+2),a  
5b29 18 03			jr .pastdmark  
5b2b ..			.dmark: db "OUT"  
5b2e f1			.pastdmark: pop af  
5b2f			endm  
# End of macro DMARK
5b2f						CALLMONITOR 
5b2f cd aa fd			call debug_vector  
5b32				endm  
# End of macro CALLMONITOR
5b32					endif 
5b32			 
5b32 ed 69				out (c), l 
5b34			 
5b34					NEXTW 
5b34 c3 39 24			jp macro_next 
5b37				endm 
# End of macro NEXTW
5b37			 
5b37			 
5b37			.SPIO: 
5b37			 
5b37			if STORAGE_SE 
5b37				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
5b37 51				db WORD_SYS_CORE+61             
5b38 48 5b			dw .SPICEH            
5b3a 07				db 6 + 1 
5b3b .. 00			db "SPICEL",0              
5b42				endm 
# End of macro CWHEAD
5b42			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
5b42			 
5b42 cd 22 02				call spi_ce_low 
5b45			    NEXTW 
5b45 c3 39 24			jp macro_next 
5b48				endm 
# End of macro NEXTW
5b48			 
5b48			.SPICEH: 
5b48				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
5b48 51				db WORD_SYS_CORE+61             
5b49 59 5b			dw .SPIOb            
5b4b 07				db 6 + 1 
5b4c .. 00			db "SPICEH",0              
5b53				endm 
# End of macro CWHEAD
5b53			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
5b53			 
5b53 cd 11 02				call spi_ce_high 
5b56			    NEXTW 
5b56 c3 39 24			jp macro_next 
5b59				endm 
# End of macro NEXTW
5b59			 
5b59			 
5b59			.SPIOb: 
5b59			 
5b59				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
5b59 51				db WORD_SYS_CORE+61             
5b5a 8b 5b			dw .SPII            
5b5c 05				db 4 + 1 
5b5d .. 00			db "SPIO",0              
5b62				endm 
# End of macro CWHEAD
5b62			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
5b62			 
5b62					if DEBUG_FORTH_WORDS_KEY 
5b62						DMARK "SPo" 
5b62 f5				push af  
5b63 3a 77 5b			ld a, (.dmark)  
5b66 32 a0 fd			ld (debug_mark),a  
5b69 3a 78 5b			ld a, (.dmark+1)  
5b6c 32 a1 fd			ld (debug_mark+1),a  
5b6f 3a 79 5b			ld a, (.dmark+2)  
5b72 32 a2 fd			ld (debug_mark+2),a  
5b75 18 03			jr .pastdmark  
5b77 ..			.dmark: db "SPo"  
5b7a f1			.pastdmark: pop af  
5b7b			endm  
# End of macro DMARK
5b7b						CALLMONITOR 
5b7b cd aa fd			call debug_vector  
5b7e				endm  
# End of macro CALLMONITOR
5b7e					endif 
5b7e					; get port 
5b7e			 
5b7e			 
5b7e					; get byte to send 
5b7e			 
5b7e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5b7e cd 4d 22			call macro_dsp_valuehl 
5b81				endm 
# End of macro FORTH_DSP_VALUEHL
5b81			 
5b81			;		push hl    ; u1  
5b81			 
5b81					; destroy value TOS 
5b81			 
5b81					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5b81 cd 05 23			call macro_forth_dsp_pop 
5b84				endm 
# End of macro FORTH_DSP_POP
5b84			 
5b84					; one value on hl get other one back 
5b84			 
5b84			;		pop hl   ; u2 - addr 
5b84			 
5b84					; TODO Send SPI byte 
5b84			 
5b84			;		push hl 
5b84			;		call spi_ce_low 
5b84			;		pop hl 
5b84 7d					ld a, l 
5b85 cd 10 01				call spi_send_byte 
5b88			;		call spi_ce_high 
5b88			 
5b88					NEXTW 
5b88 c3 39 24			jp macro_next 
5b8b				endm 
# End of macro NEXTW
5b8b			 
5b8b			.SPII: 
5b8b				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
5b8b 52				db WORD_SYS_CORE+62             
5b8c f4 5b			dw .SESEL            
5b8e 06				db 5 + 1 
5b8f .. 00			db "SPII",0              
5b94				endm 
# End of macro CWHEAD
5b94			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
5b94					if DEBUG_FORTH_WORDS_KEY 
5b94						DMARK "SPi" 
5b94 f5				push af  
5b95 3a a9 5b			ld a, (.dmark)  
5b98 32 a0 fd			ld (debug_mark),a  
5b9b 3a aa 5b			ld a, (.dmark+1)  
5b9e 32 a1 fd			ld (debug_mark+1),a  
5ba1 3a ab 5b			ld a, (.dmark+2)  
5ba4 32 a2 fd			ld (debug_mark+2),a  
5ba7 18 03			jr .pastdmark  
5ba9 ..			.dmark: db "SPi"  
5bac f1			.pastdmark: pop af  
5bad			endm  
# End of macro DMARK
5bad						CALLMONITOR 
5bad cd aa fd			call debug_vector  
5bb0				endm  
# End of macro CALLMONITOR
5bb0					endif 
5bb0			 
5bb0					; TODO Get SPI byte 
5bb0			 
5bb0 cd 37 01				call spi_read_byte 
5bb3			 
5bb3					if DEBUG_FORTH_WORDS 
5bb3						DMARK "Si2" 
5bb3 f5				push af  
5bb4 3a c8 5b			ld a, (.dmark)  
5bb7 32 a0 fd			ld (debug_mark),a  
5bba 3a c9 5b			ld a, (.dmark+1)  
5bbd 32 a1 fd			ld (debug_mark+1),a  
5bc0 3a ca 5b			ld a, (.dmark+2)  
5bc3 32 a2 fd			ld (debug_mark+2),a  
5bc6 18 03			jr .pastdmark  
5bc8 ..			.dmark: db "Si2"  
5bcb f1			.pastdmark: pop af  
5bcc			endm  
# End of macro DMARK
5bcc						CALLMONITOR 
5bcc cd aa fd			call debug_vector  
5bcf				endm  
# End of macro CALLMONITOR
5bcf					endif 
5bcf 26 00				ld h, 0 
5bd1 6f					ld l, a 
5bd2					if DEBUG_FORTH_WORDS 
5bd2						DMARK "Si3" 
5bd2 f5				push af  
5bd3 3a e7 5b			ld a, (.dmark)  
5bd6 32 a0 fd			ld (debug_mark),a  
5bd9 3a e8 5b			ld a, (.dmark+1)  
5bdc 32 a1 fd			ld (debug_mark+1),a  
5bdf 3a e9 5b			ld a, (.dmark+2)  
5be2 32 a2 fd			ld (debug_mark+2),a  
5be5 18 03			jr .pastdmark  
5be7 ..			.dmark: db "Si3"  
5bea f1			.pastdmark: pop af  
5beb			endm  
# End of macro DMARK
5beb						CALLMONITOR 
5beb cd aa fd			call debug_vector  
5bee				endm  
# End of macro CALLMONITOR
5bee					endif 
5bee cd 48 20				call forth_push_numhl 
5bf1			 
5bf1					NEXTW 
5bf1 c3 39 24			jp macro_next 
5bf4				endm 
# End of macro NEXTW
5bf4			 
5bf4			 
5bf4			 
5bf4			.SESEL: 
5bf4				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
5bf4 66				db WORD_SYS_CORE+82             
5bf5 9d 5c			dw .CARTDEV            
5bf7 05				db 4 + 1 
5bf8 .. 00			db "BANK",0              
5bfd				endm 
# End of macro CWHEAD
5bfd			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
5bfd					if DEBUG_FORTH_WORDS_KEY 
5bfd						DMARK "BNK" 
5bfd f5				push af  
5bfe 3a 12 5c			ld a, (.dmark)  
5c01 32 a0 fd			ld (debug_mark),a  
5c04 3a 13 5c			ld a, (.dmark+1)  
5c07 32 a1 fd			ld (debug_mark+1),a  
5c0a 3a 14 5c			ld a, (.dmark+2)  
5c0d 32 a2 fd			ld (debug_mark+2),a  
5c10 18 03			jr .pastdmark  
5c12 ..			.dmark: db "BNK"  
5c15 f1			.pastdmark: pop af  
5c16			endm  
# End of macro DMARK
5c16						CALLMONITOR 
5c16 cd aa fd			call debug_vector  
5c19				endm  
# End of macro CALLMONITOR
5c19					endif 
5c19			 
5c19 3e ff				ld a, 255 
5c1b 32 98 f9				ld (spi_cartdev), a 
5c1e			 
5c1e					; get bank 
5c1e			 
5c1e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5c1e cd 4d 22			call macro_dsp_valuehl 
5c21				endm 
# End of macro FORTH_DSP_VALUEHL
5c21			 
5c21			;		push hl 
5c21			 
5c21					; destroy value TOS 
5c21			 
5c21					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5c21 cd 05 23			call macro_forth_dsp_pop 
5c24				endm 
# End of macro FORTH_DSP_POP
5c24			 
5c24					; one value on hl get other one back 
5c24			 
5c24			;		pop hl 
5c24			 
5c24			 
5c24 0e ff				ld c, SPI_CE_HIGH 
5c26 06 30				ld b, '0'    ; human readable bank number 
5c28			 
5c28 7d					ld a, l 
5c29			 
5c29					if DEBUG_FORTH_WORDS 
5c29						DMARK "BNK" 
5c29 f5				push af  
5c2a 3a 3e 5c			ld a, (.dmark)  
5c2d 32 a0 fd			ld (debug_mark),a  
5c30 3a 3f 5c			ld a, (.dmark+1)  
5c33 32 a1 fd			ld (debug_mark+1),a  
5c36 3a 40 5c			ld a, (.dmark+2)  
5c39 32 a2 fd			ld (debug_mark+2),a  
5c3c 18 03			jr .pastdmark  
5c3e ..			.dmark: db "BNK"  
5c41 f1			.pastdmark: pop af  
5c42			endm  
# End of macro DMARK
5c42						CALLMONITOR 
5c42 cd aa fd			call debug_vector  
5c45				endm  
# End of macro CALLMONITOR
5c45					endif 
5c45			 
5c45					; active low 
5c45			 
5c45 fe 00				cp 0 
5c47 28 28				jr z, .bset 
5c49 fe 01				cp 1 
5c4b 20 04				jr nz, .b2 
5c4d cb 81				res 0, c 
5c4f 06 31				ld b, '1'    ; human readable bank number 
5c51 fe 02		.b2:		cp 2 
5c53 20 04				jr nz, .b3 
5c55 cb 89				res 1, c 
5c57 06 32				ld b, '2'    ; human readable bank number 
5c59 fe 03		.b3:		cp 3 
5c5b 20 04				jr nz, .b4 
5c5d cb 91				res 2, c 
5c5f 06 33				ld b, '3'    ; human readable bank number 
5c61 fe 04		.b4:		cp 4 
5c63 20 04				jr nz, .b5 
5c65 cb 99				res 3, c 
5c67 06 34				ld b, '4'    ; human readable bank number 
5c69 fe 05		.b5:		cp 5 
5c6b 20 04				jr nz, .bset 
5c6d cb a1				res 4, c 
5c6f 06 35				ld b, '5'    ; human readable bank number 
5c71			 
5c71			.bset: 
5c71 79					ld a, c 
5c72 32 95 f9				ld (spi_device),a 
5c75 78					ld a, b 
5c76 32 94 f9				ld (spi_device_id),a 
5c79					if DEBUG_FORTH_WORDS 
5c79						DMARK "BN2" 
5c79 f5				push af  
5c7a 3a 8e 5c			ld a, (.dmark)  
5c7d 32 a0 fd			ld (debug_mark),a  
5c80 3a 8f 5c			ld a, (.dmark+1)  
5c83 32 a1 fd			ld (debug_mark+1),a  
5c86 3a 90 5c			ld a, (.dmark+2)  
5c89 32 a2 fd			ld (debug_mark+2),a  
5c8c 18 03			jr .pastdmark  
5c8e ..			.dmark: db "BN2"  
5c91 f1			.pastdmark: pop af  
5c92			endm  
# End of macro DMARK
5c92						CALLMONITOR 
5c92 cd aa fd			call debug_vector  
5c95				endm  
# End of macro CALLMONITOR
5c95					endif 
5c95			 
5c95					; set default SPI clk pulse time as disabled for BANK use 
5c95			 
5c95 3e 00				ld a, 0 
5c97 32 99 f9				ld (spi_clktime), a 
5c9a			 
5c9a					NEXTW 
5c9a c3 39 24			jp macro_next 
5c9d				endm 
# End of macro NEXTW
5c9d			 
5c9d			.CARTDEV: 
5c9d				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
5c9d 66				db WORD_SYS_CORE+82             
5c9e 4b 5d			dw .ENDDEVICE            
5ca0 08				db 7 + 1 
5ca1 .. 00			db "CARTDEV",0              
5ca9				endm 
# End of macro CWHEAD
5ca9			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
5ca9					if DEBUG_FORTH_WORDS_KEY 
5ca9						DMARK "CDV" 
5ca9 f5				push af  
5caa 3a be 5c			ld a, (.dmark)  
5cad 32 a0 fd			ld (debug_mark),a  
5cb0 3a bf 5c			ld a, (.dmark+1)  
5cb3 32 a1 fd			ld (debug_mark+1),a  
5cb6 3a c0 5c			ld a, (.dmark+2)  
5cb9 32 a2 fd			ld (debug_mark+2),a  
5cbc 18 03			jr .pastdmark  
5cbe ..			.dmark: db "CDV"  
5cc1 f1			.pastdmark: pop af  
5cc2			endm  
# End of macro DMARK
5cc2						CALLMONITOR 
5cc2 cd aa fd			call debug_vector  
5cc5				endm  
# End of macro CALLMONITOR
5cc5					endif 
5cc5			 
5cc5					; disable se storage bank selection 
5cc5			 
5cc5 3e ff				ld a, SPI_CE_HIGH		; ce high 
5cc7 32 95 f9				ld (spi_device), a 
5cca			 
5cca					; get bank 
5cca			 
5cca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5cca cd 4d 22			call macro_dsp_valuehl 
5ccd				endm 
# End of macro FORTH_DSP_VALUEHL
5ccd			 
5ccd			;		push hl 
5ccd			 
5ccd					; destroy value TOS 
5ccd			 
5ccd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ccd cd 05 23			call macro_forth_dsp_pop 
5cd0				endm 
# End of macro FORTH_DSP_POP
5cd0			 
5cd0					; one value on hl get other one back 
5cd0			 
5cd0			;		pop hl 
5cd0			 
5cd0					; active low 
5cd0			 
5cd0 0e ff				ld c, 255 
5cd2			 
5cd2 7d					ld a, l 
5cd3					if DEBUG_FORTH_WORDS 
5cd3						DMARK "CDV" 
5cd3 f5				push af  
5cd4 3a e8 5c			ld a, (.dmark)  
5cd7 32 a0 fd			ld (debug_mark),a  
5cda 3a e9 5c			ld a, (.dmark+1)  
5cdd 32 a1 fd			ld (debug_mark+1),a  
5ce0 3a ea 5c			ld a, (.dmark+2)  
5ce3 32 a2 fd			ld (debug_mark+2),a  
5ce6 18 03			jr .pastdmark  
5ce8 ..			.dmark: db "CDV"  
5ceb f1			.pastdmark: pop af  
5cec			endm  
# End of macro DMARK
5cec						CALLMONITOR 
5cec cd aa fd			call debug_vector  
5cef				endm  
# End of macro CALLMONITOR
5cef					endif 
5cef fe 00				cp 0 
5cf1 28 30				jr z, .cset 
5cf3 fe 01				cp 1 
5cf5 20 02				jr nz, .c2 
5cf7 cb 81				res 0, c 
5cf9 fe 02		.c2:		cp 2 
5cfb 20 02				jr nz, .c3 
5cfd cb 89				res 1, c 
5cff fe 03		.c3:		cp 3 
5d01 20 02				jr nz, .c4 
5d03 cb 91				res 2, c 
5d05 fe 04		.c4:		cp 4 
5d07 20 02				jr nz, .c5 
5d09 cb 99				res 3, c 
5d0b fe 05		.c5:		cp 5 
5d0d 20 02				jr nz, .c6 
5d0f cb a1				res 4, c 
5d11 fe 06		.c6:		cp 6 
5d13 20 02				jr nz, .c7 
5d15 cb a9				res 5, c 
5d17 fe 07		.c7:		cp 7 
5d19 20 02				jr nz, .c8 
5d1b cb b1				res 6, c 
5d1d fe 08		.c8:		cp 8 
5d1f 20 02				jr nz, .cset 
5d21 cb b9				res 7, c 
5d23 79			.cset:		ld a, c 
5d24 32 98 f9				ld (spi_cartdev),a 
5d27			 
5d27					if DEBUG_FORTH_WORDS 
5d27						DMARK "CD2" 
5d27 f5				push af  
5d28 3a 3c 5d			ld a, (.dmark)  
5d2b 32 a0 fd			ld (debug_mark),a  
5d2e 3a 3d 5d			ld a, (.dmark+1)  
5d31 32 a1 fd			ld (debug_mark+1),a  
5d34 3a 3e 5d			ld a, (.dmark+2)  
5d37 32 a2 fd			ld (debug_mark+2),a  
5d3a 18 03			jr .pastdmark  
5d3c ..			.dmark: db "CD2"  
5d3f f1			.pastdmark: pop af  
5d40			endm  
# End of macro DMARK
5d40						CALLMONITOR 
5d40 cd aa fd			call debug_vector  
5d43				endm  
# End of macro CALLMONITOR
5d43					endif 
5d43			 
5d43					; set default SPI clk pulse time as 10ms for CARTDEV use 
5d43			 
5d43 3e 0a				ld a, $0a 
5d45 32 99 f9				ld (spi_clktime), a 
5d48					NEXTW 
5d48 c3 39 24			jp macro_next 
5d4b				endm 
# End of macro NEXTW
5d4b			endif 
5d4b			 
5d4b			.ENDDEVICE: 
5d4b			; eof 
5d4b			 
# End of file forth_words_device.asm
5d4b			 
5d4b			; var handler 
5d4b			 
5d4b			 
5d4b			.VARS: 
5d4b				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
5d4b 77				db WORD_SYS_CORE+99             
5d4c fc 5d			dw .V0            
5d4e 04				db 3 + 1 
5d4f .. 00			db "VAR",0              
5d53				endm 
# End of macro CWHEAD
5d53			;| VAR ( u1 -- )  Get the address of the variable referenced on TOS  | TO TEST 
5d53			;| 
5d53			;| The variable name should consist of a single letter. e.g. "a" 
5d53			;! If a full string is passed then only the first char is looked at 
5d53			;| Any other char could exceed bounds checks!  
5d53			 
5d53					if DEBUG_FORTH_WORDS_KEY 
5d53						DMARK "VAR" 
5d53 f5				push af  
5d54 3a 68 5d			ld a, (.dmark)  
5d57 32 a0 fd			ld (debug_mark),a  
5d5a 3a 69 5d			ld a, (.dmark+1)  
5d5d 32 a1 fd			ld (debug_mark+1),a  
5d60 3a 6a 5d			ld a, (.dmark+2)  
5d63 32 a2 fd			ld (debug_mark+2),a  
5d66 18 03			jr .pastdmark  
5d68 ..			.dmark: db "VAR"  
5d6b f1			.pastdmark: pop af  
5d6c			endm  
# End of macro DMARK
5d6c						CALLMONITOR 
5d6c cd aa fd			call debug_vector  
5d6f				endm  
# End of macro CALLMONITOR
5d6f					endif 
5d6f			 
5d6f					FORTH_DSP_VALUEHL 
5d6f cd 4d 22			call macro_dsp_valuehl 
5d72				endm 
# End of macro FORTH_DSP_VALUEHL
5d72			 
5d72 7e					ld a, (hl)    ; get first char on of the string 
5d73			 
5d73			 
5d73					if DEBUG_FORTH_WORDS 
5d73						DMARK "VR1" 
5d73 f5				push af  
5d74 3a 88 5d			ld a, (.dmark)  
5d77 32 a0 fd			ld (debug_mark),a  
5d7a 3a 89 5d			ld a, (.dmark+1)  
5d7d 32 a1 fd			ld (debug_mark+1),a  
5d80 3a 8a 5d			ld a, (.dmark+2)  
5d83 32 a2 fd			ld (debug_mark+2),a  
5d86 18 03			jr .pastdmark  
5d88 ..			.dmark: db "VR1"  
5d8b f1			.pastdmark: pop af  
5d8c			endm  
# End of macro DMARK
5d8c						CALLMONITOR 
5d8c cd aa fd			call debug_vector  
5d8f				endm  
# End of macro CALLMONITOR
5d8f					endif 
5d8f					 
5d8f f5					push af	 
5d90					FORTH_DSP_POP 
5d90 cd 05 23			call macro_forth_dsp_pop 
5d93				endm 
# End of macro FORTH_DSP_POP
5d93 f1					pop af 
5d94			 
5d94					; convert to upper 
5d94			 
5d94 cd 53 12				call to_upper 
5d97					if DEBUG_FORTH_WORDS 
5d97						DMARK "Vaa" 
5d97 f5				push af  
5d98 3a ac 5d			ld a, (.dmark)  
5d9b 32 a0 fd			ld (debug_mark),a  
5d9e 3a ad 5d			ld a, (.dmark+1)  
5da1 32 a1 fd			ld (debug_mark+1),a  
5da4 3a ae 5d			ld a, (.dmark+2)  
5da7 32 a2 fd			ld (debug_mark+2),a  
5daa 18 03			jr .pastdmark  
5dac ..			.dmark: db "Vaa"  
5daf f1			.pastdmark: pop af  
5db0			endm  
# End of macro DMARK
5db0						CALLMONITOR 
5db0 cd aa fd			call debug_vector  
5db3				endm  
# End of macro CALLMONITOR
5db3					endif 
5db3 06 41				ld b, 'A' 
5db5 90					sub b			; set offset 
5db6					if DEBUG_FORTH_WORDS 
5db6						DMARK "Vbb" 
5db6 f5				push af  
5db7 3a cb 5d			ld a, (.dmark)  
5dba 32 a0 fd			ld (debug_mark),a  
5dbd 3a cc 5d			ld a, (.dmark+1)  
5dc0 32 a1 fd			ld (debug_mark+1),a  
5dc3 3a cd 5d			ld a, (.dmark+2)  
5dc6 32 a2 fd			ld (debug_mark+2),a  
5dc9 18 03			jr .pastdmark  
5dcb ..			.dmark: db "Vbb"  
5dce f1			.pastdmark: pop af  
5dcf			endm  
# End of macro DMARK
5dcf						CALLMONITOR 
5dcf cd aa fd			call debug_vector  
5dd2				endm  
# End of macro CALLMONITOR
5dd2					endif 
5dd2 cb 27				sla a  
5dd4				 
5dd4					 
5dd4					if DEBUG_FORTH_WORDS 
5dd4						DMARK "VR2" 
5dd4 f5				push af  
5dd5 3a e9 5d			ld a, (.dmark)  
5dd8 32 a0 fd			ld (debug_mark),a  
5ddb 3a ea 5d			ld a, (.dmark+1)  
5dde 32 a1 fd			ld (debug_mark+1),a  
5de1 3a eb 5d			ld a, (.dmark+2)  
5de4 32 a2 fd			ld (debug_mark+2),a  
5de7 18 03			jr .pastdmark  
5de9 ..			.dmark: db "VR2"  
5dec f1			.pastdmark: pop af  
5ded			endm  
# End of macro DMARK
5ded						CALLMONITOR 
5ded cd aa fd			call debug_vector  
5df0				endm  
# End of macro CALLMONITOR
5df0					endif 
5df0			 
5df0 21 29 f9				ld hl, cli_var_array2 
5df3 cd de 0f				call addatohl 
5df6 cd 48 20				call forth_push_numhl 
5df9			 
5df9			 
5df9				       NEXTW 
5df9 c3 39 24			jp macro_next 
5dfc				endm 
# End of macro NEXTW
5dfc			.V0: 
5dfc				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
5dfc 78				db WORD_SYS_CORE+100             
5dfd 14 5e			dw .V0Q            
5dff 04				db 3 + 1 
5e00 .. 00			db "V0!",0              
5e04				endm 
# End of macro CWHEAD
5e04			;| V0! ( u1 -- )  Store value to v0  | DONE 
5e04			 
5e04					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5e04 cd 4d 22			call macro_dsp_valuehl 
5e07				endm 
# End of macro FORTH_DSP_VALUEHL
5e07			 
5e07 11 5d f9				ld de, cli_var_array 
5e0a			 
5e0a eb					ex de, hl 
5e0b 73					ld (hl), e 
5e0c 23					inc hl 
5e0d 72					ld (hl), d 
5e0e			 
5e0e					; destroy value TOS 
5e0e			 
5e0e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5e0e cd 05 23			call macro_forth_dsp_pop 
5e11				endm 
# End of macro FORTH_DSP_POP
5e11			 
5e11				       NEXTW 
5e11 c3 39 24			jp macro_next 
5e14				endm 
# End of macro NEXTW
5e14			.V0Q: 
5e14				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
5e14 79				db WORD_SYS_CORE+101             
5e15 25 5e			dw .V1S            
5e17 04				db 3 + 1 
5e18 .. 00			db "V0@",0              
5e1c				endm 
# End of macro CWHEAD
5e1c			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
5e1c 2a 5d f9				ld hl, (cli_var_array) 
5e1f cd 48 20				call forth_push_numhl 
5e22			 
5e22				       NEXTW 
5e22 c3 39 24			jp macro_next 
5e25				endm 
# End of macro NEXTW
5e25			.V1S: 
5e25				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
5e25 7a				db WORD_SYS_CORE+102             
5e26 3d 5e			dw .V1Q            
5e28 04				db 3 + 1 
5e29 .. 00			db "V1!",0              
5e2d				endm 
# End of macro CWHEAD
5e2d			;| V1! ( u1 -- )  Store value to v1 | DONE 
5e2d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5e2d cd 4d 22			call macro_dsp_valuehl 
5e30				endm 
# End of macro FORTH_DSP_VALUEHL
5e30			 
5e30 11 5f f9				ld de, cli_var_array+2 
5e33				 
5e33 eb					ex de, hl 
5e34 73					ld (hl), e 
5e35 23					inc hl 
5e36 72					ld (hl), d 
5e37			 
5e37					; destroy value TOS 
5e37			 
5e37					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5e37 cd 05 23			call macro_forth_dsp_pop 
5e3a				endm 
# End of macro FORTH_DSP_POP
5e3a				       NEXTW 
5e3a c3 39 24			jp macro_next 
5e3d				endm 
# End of macro NEXTW
5e3d			.V1Q: 
5e3d				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
5e3d 7b				db WORD_SYS_CORE+103             
5e3e 4e 5e			dw .V2S            
5e40 04				db 3 + 1 
5e41 .. 00			db "V1@",0              
5e45				endm 
# End of macro CWHEAD
5e45			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
5e45 2a 5f f9				ld hl, (cli_var_array+2) 
5e48 cd 48 20				call forth_push_numhl 
5e4b				       NEXTW 
5e4b c3 39 24			jp macro_next 
5e4e				endm 
# End of macro NEXTW
5e4e			.V2S: 
5e4e				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
5e4e 7c				db WORD_SYS_CORE+104             
5e4f 66 5e			dw .V2Q            
5e51 04				db 3 + 1 
5e52 .. 00			db "V2!",0              
5e56				endm 
# End of macro CWHEAD
5e56			;| V2! ( u1 -- )  Store value to v2 | DONE 
5e56					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5e56 cd 4d 22			call macro_dsp_valuehl 
5e59				endm 
# End of macro FORTH_DSP_VALUEHL
5e59			 
5e59 11 61 f9				ld de, cli_var_array+4 
5e5c				 
5e5c eb					ex de, hl 
5e5d 73					ld (hl), e 
5e5e 23					inc hl 
5e5f 72					ld (hl), d 
5e60			 
5e60					; destroy value TOS 
5e60			 
5e60					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5e60 cd 05 23			call macro_forth_dsp_pop 
5e63				endm 
# End of macro FORTH_DSP_POP
5e63				       NEXTW 
5e63 c3 39 24			jp macro_next 
5e66				endm 
# End of macro NEXTW
5e66			.V2Q: 
5e66				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
5e66 7d				db WORD_SYS_CORE+105             
5e67 77 5e			dw .V3S            
5e69 04				db 3 + 1 
5e6a .. 00			db "V2@",0              
5e6e				endm 
# End of macro CWHEAD
5e6e			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
5e6e 2a 61 f9				ld hl, (cli_var_array+4) 
5e71 cd 48 20				call forth_push_numhl 
5e74				       NEXTW 
5e74 c3 39 24			jp macro_next 
5e77				endm 
# End of macro NEXTW
5e77			.V3S: 
5e77				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
5e77 7c				db WORD_SYS_CORE+104             
5e78 8f 5e			dw .V3Q            
5e7a 04				db 3 + 1 
5e7b .. 00			db "V3!",0              
5e7f				endm 
# End of macro CWHEAD
5e7f			;| V3! ( u1 -- )  Store value to v3 | DONE 
5e7f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5e7f cd 4d 22			call macro_dsp_valuehl 
5e82				endm 
# End of macro FORTH_DSP_VALUEHL
5e82			 
5e82 11 63 f9				ld de, cli_var_array+6 
5e85				 
5e85 eb					ex de, hl 
5e86 73					ld (hl), e 
5e87 23					inc hl 
5e88 72					ld (hl), d 
5e89			 
5e89					; destroy value TOS 
5e89			 
5e89					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5e89 cd 05 23			call macro_forth_dsp_pop 
5e8c				endm 
# End of macro FORTH_DSP_POP
5e8c				       NEXTW 
5e8c c3 39 24			jp macro_next 
5e8f				endm 
# End of macro NEXTW
5e8f			.V3Q: 
5e8f				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
5e8f 7d				db WORD_SYS_CORE+105             
5e90 a0 5e			dw .END            
5e92 04				db 3 + 1 
5e93 .. 00			db "V3@",0              
5e97				endm 
# End of macro CWHEAD
5e97			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
5e97 2a 63 f9				ld hl, (cli_var_array+6) 
5e9a cd 48 20				call forth_push_numhl 
5e9d				       NEXTW 
5e9d c3 39 24			jp macro_next 
5ea0				endm 
# End of macro NEXTW
5ea0			 
5ea0			 
5ea0			 
5ea0			 
5ea0			 
5ea0			; end of dict marker 
5ea0			 
5ea0 00			.END:    db WORD_SYS_END 
5ea1 00 00			dw 0 
5ea3 00				db 0 
5ea4			 
5ea4			; use to jp here for user dict words to save on macro expansion  
5ea4			 
5ea4			user_dict_next: 
5ea4				NEXTW 
5ea4 c3 39 24			jp macro_next 
5ea7				endm 
# End of macro NEXTW
5ea7			 
5ea7			 
5ea7			user_exec: 
5ea7				;    ld hl, <word code> 
5ea7				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
5ea7				;    call forthexec 
5ea7				;    jp user_dict_next   (NEXT) 
5ea7			        ;    <word code bytes> 
5ea7 eb				ex de, hl 
5ea8 2a f7 f3			ld hl,(os_tok_ptr) 
5eab				 
5eab				FORTH_RSP_NEXT 
5eab cd ef 1f			call macro_forth_rsp_next 
5eae				endm 
# End of macro FORTH_RSP_NEXT
5eae			 
5eae			if DEBUG_FORTH_UWORD 
5eae						DMARK "UEX" 
5eae f5				push af  
5eaf 3a c3 5e			ld a, (.dmark)  
5eb2 32 a0 fd			ld (debug_mark),a  
5eb5 3a c4 5e			ld a, (.dmark+1)  
5eb8 32 a1 fd			ld (debug_mark+1),a  
5ebb 3a c5 5e			ld a, (.dmark+2)  
5ebe 32 a2 fd			ld (debug_mark+2),a  
5ec1 18 03			jr .pastdmark  
5ec3 ..			.dmark: db "UEX"  
5ec6 f1			.pastdmark: pop af  
5ec7			endm  
# End of macro DMARK
5ec7				CALLMONITOR 
5ec7 cd aa fd			call debug_vector  
5eca				endm  
# End of macro CALLMONITOR
5eca			endif 
5eca			 
5eca			 
5eca			 
5eca eb				ex de, hl 
5ecb 22 f7 f3			ld (os_tok_ptr), hl 
5ece				 
5ece				; Don't use next - Skips the first word in uword. 
5ece			 
5ece c3 ca 24			jp exec1 
5ed1			;	NEXT 
5ed1			 
5ed1			 
5ed1			; eof 
# End of file forth_wordsv4.asm
5ed1			endif 
5ed1			;;;;;;;;;;;;;; Debug code 
5ed1			 
5ed1			 
5ed1			;if DEBUG_FORTH_PARSE 
5ed1 .. 00		.nowordfound: db "No match",0 
5eda .. 00		.compword:	db "Comparing word ",0 
5eea .. 00		.nextwordat:	db "Next word at",0 
5ef7 .. 00		.charmatch:	db "Char match",0 
5f02			;endif 
5f02			if DEBUG_FORTH_JP 
5f02			.foundword:	db "Word match. Exec..",0 
5f02			endif 
5f02			;if DEBUG_FORTH_PUSH 
5f02 .. 00		.enddict:	db "Dict end. Push.",0 
5f12 .. 00		.push_str:	db "Pushing string",0 
5f21 .. 00		.push_num:	db "Pushing number",0 
5f30 .. 00		.data_sp:	db "SP:",0 
5f34 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
5f46 .. 00		.wordinde:	db "Word in DE (3/0):",0 
5f58 .. 00		.wordinbc:	db "Word in BC (4/0):",0 
5f6a			;endif 
5f6a			;if DEBUG_FORTH_MALLOC 
5f6a .. 00		.push_malloc:	db "Malloc address",0 
5f79			;endif 
5f79			 
5f79			 
5f79			 
5f79			; display malloc address and current data stack pointer  
5f79			 
5f79			malloc_error: 
5f79 d5				push de 
5f7a f5				push af 
5f7b e5				push hl 
5f7c cd aa 0d			call clear_display 
5f7f 11 9f 5f			ld de, .mallocerr 
5f82 3e 00			ld a,0 
5f84			;	ld de,os_word_scratch 
5f84 cd bd 0d			call str_at_display 
5f87 3e 11			ld a, display_row_1+17 
5f89 11 a0 fd			ld de, debug_mark 
5f8c cd bd 0d			call str_at_display 
5f8f cd cd 0d			call update_display 
5f92				;call break_point_state 
5f92 cd 82 74			call cin_wait 
5f95			 
5f95			;	ld a, ' ' 
5f95			;	ld (os_view_disable), a 
5f95 cd 49 19			call bp_on 
5f98 e1				pop hl 
5f99 f1				pop af 
5f9a d1				pop de	 
5f9b				CALLMONITOR 
5f9b cd aa fd			call debug_vector  
5f9e				endm  
# End of macro CALLMONITOR
5f9e c9				ret 
5f9f			 
5f9f .. 00		.mallocerr: 	db "Malloc Error",0 
5fac			;if DEBUG_FORTH_PUSH 
5fac			display_data_sp: 
5fac f5				push af 
5fad			 
5fad				; see if disabled 
5fad			 
5fad			 
5fad 3a aa fd			ld a, (debug_vector) 
5fb0 fe c9			cp $C9  ; RET 
5fb2				;ld a, (os_view_disable) 
5fb2				;cp '*' 
5fb2 28 67			jr z, .skipdsp 
5fb4			 
5fb4 e5				push hl 
5fb5 e5				push hl 
5fb6 e5			push hl 
5fb7 cd aa 0d			call clear_display 
5fba e1			pop hl 
5fbb 7c				ld a,h 
5fbc 21 fb f3			ld hl, os_word_scratch 
5fbf cd e7 11			call hexout 
5fc2 e1				pop hl 
5fc3 7d				ld a,l 
5fc4 21 fd f3			ld hl, os_word_scratch+2 
5fc7 cd e7 11			call hexout 
5fca 21 ff f3			ld hl, os_word_scratch+4 
5fcd 3e 00			ld a,0 
5fcf 77				ld (hl),a 
5fd0 11 fb f3			ld de,os_word_scratch 
5fd3 3e 28				ld a, display_row_2 
5fd5 cd bd 0d				call str_at_display 
5fd8 11 34 5f			ld de, .wordinhl 
5fdb 3e 00			ld a, display_row_1 
5fdd			 
5fdd cd bd 0d				call str_at_display 
5fe0 11 a0 fd			ld de, debug_mark 
5fe3 3e 11			ld a, display_row_1+17 
5fe5			 
5fe5 cd bd 0d				call str_at_display 
5fe8			 
5fe8				; display current data stack pointer 
5fe8 11 30 5f			ld de,.data_sp 
5feb 3e 30				ld a, display_row_2 + 8 
5fed cd bd 0d				call str_at_display 
5ff0			 
5ff0 2a 23 f9			ld hl,(cli_data_sp) 
5ff3 e5				push hl 
5ff4 7c				ld a,h 
5ff5 21 fb f3			ld hl, os_word_scratch 
5ff8 cd e7 11			call hexout 
5ffb e1				pop hl 
5ffc 7d				ld a,l 
5ffd 21 fd f3			ld hl, os_word_scratch+2 
6000 cd e7 11			call hexout 
6003 21 ff f3			ld hl, os_word_scratch+4 
6006 3e 00			ld a,0 
6008 77				ld (hl),a 
6009 11 fb f3			ld de,os_word_scratch 
600c 3e 33				ld a, display_row_2 + 11 
600e cd bd 0d				call str_at_display 
6011			 
6011			 
6011 cd cd 0d			call update_display 
6014 cd ed 0c			call delay1s 
6017 cd ed 0c			call delay1s 
601a e1				pop hl 
601b			.skipdsp: 
601b f1				pop af 
601c c9				ret 
601d			 
601d			display_data_malloc: 
601d			 
601d f5				push af 
601e e5				push hl 
601f e5				push hl 
6020 e5			push hl 
6021 cd aa 0d			call clear_display 
6024 e1			pop hl 
6025 7c				ld a,h 
6026 21 fb f3			ld hl, os_word_scratch 
6029 cd e7 11			call hexout 
602c e1				pop hl 
602d 7d				ld a,l 
602e 21 fd f3			ld hl, os_word_scratch+2 
6031 cd e7 11			call hexout 
6034 21 ff f3			ld hl, os_word_scratch+4 
6037 3e 00			ld a,0 
6039 77				ld (hl),a 
603a 11 fb f3			ld de,os_word_scratch 
603d 3e 28				ld a, display_row_2 
603f cd bd 0d				call str_at_display 
6042 11 6a 5f			ld de, .push_malloc 
6045 3e 00			ld a, display_row_1 
6047			 
6047 cd bd 0d				call str_at_display 
604a			 
604a				; display current data stack pointer 
604a 11 30 5f			ld de,.data_sp 
604d 3e 30				ld a, display_row_2 + 8 
604f cd bd 0d				call str_at_display 
6052			 
6052 2a 23 f9			ld hl,(cli_data_sp) 
6055 e5				push hl 
6056 7c				ld a,h 
6057 21 fb f3			ld hl, os_word_scratch 
605a cd e7 11			call hexout 
605d e1				pop hl 
605e 7d				ld a,l 
605f 21 fd f3			ld hl, os_word_scratch+2 
6062 cd e7 11			call hexout 
6065 21 ff f3			ld hl, os_word_scratch+4 
6068 3e 00			ld a,0 
606a 77				ld (hl),a 
606b 11 fb f3			ld de,os_word_scratch 
606e 3e 33				ld a, display_row_2 + 11 
6070 cd bd 0d				call str_at_display 
6073			 
6073 cd cd 0d			call update_display 
6076 cd ed 0c			call delay1s 
6079 cd ed 0c			call delay1s 
607c e1				pop hl 
607d f1				pop af 
607e c9				ret 
607f			;endif 
607f			 
607f			include "forth_autostart.asm" 
607f			; list of commands to perform at system start up 
607f			 
607f			startcmds: 
607f			;	dw test11 
607f			;	dw test12 
607f			;	dw test13 
607f			;	dw test14 
607f			;	dw test15 
607f			;	dw test16 
607f			;	dw test17 
607f			;	dw ifthtest1 
607f			;	dw ifthtest2 
607f			;	dw ifthtest3 
607f			;	dw mmtest1 
607f			;	dw mmtest2 
607f			;	dw mmtest3 
607f			;	dw mmtest4 
607f			;	dw mmtest5 
607f			;	dw mmtest6 
607f			;	dw iftest1 
607f			;	dw iftest2 
607f			;	dw iftest3 
607f			;	dw looptest1 
607f			;	dw looptest2 
607f			;	dw test1 
607f			;	dw test2 
607f			;	dw test3 
607f			;	dw test4 
607f			;	dw game2r 
607f			;	dw game2b1 
607f			;	dw game2b2 
607f			 
607f				; start up words that are actually useful 
607f			 
607f			;    dw spi1 
607f			;    dw spi2 
607f			;    dw spi3 
607f			;    dw spi4 
607f			;    dw spi5 
607f			;    dw spi6 
607f			;    dw spi7 
607f			; 
607f			;    dw spi8 
607f			;    dw spi9 
607f			;    dw spi10 
607f			 
607f			; file editor 
607f			;	dw edit1 
607f			;	dw edit2 
607f			;	dw edit3 
607f			 
607f			;	dw longread 
607f 9f 64			dw clrstack 
6081 d3 64			dw type 
6083			;	dw stest 
6083 f8 64			dw strncpy 
6085			;	dw list 
6085 59 65			dw start1 
6087 69 65			dw start2 
6089			;	dw start3 
6089			;	dw start3b 
6089			;	dw start3c 
6089			 
6089				; (unit) testing words 
6089			 
6089			;	dw mtesta 
6089			;	dw mtestb 
6089			;	dw mtestc 
6089			;	dw mtestd 
6089			;	dw mteste 
6089			 
6089				; demo/game words 
6089			 
6089			;        dw game3w 
6089			;        dw game3p 
6089			;        dw game3sc 
6089			;        dw game3vsi 
6089			;        dw game3vs 
6089				 
6089			;	dw game2b 
6089			;	dw game2bf 
6089			;	dw game2mba 
6089			;	dw game2mbas 
6089			;	dw game2mb 
6089			 
6089 99 68			dw game1 
608b aa 68			dw game1a 
608d 0c 69			dw game1b 
608f 41 69			dw game1c 
6091 77 69			dw game1d 
6093 a8 69			dw game1s 
6095 bc 69			dw game1t 
6097 d1 69			dw game1f 
6099 05 6a			dw game1z 
609b 49 6a			dw game1zz 
609d			 
609d d2 66			dw test5 
609f 0a 67			dw test6 
60a1 42 67			dw test7 
60a3 56 67			dw test8 
60a5 82 67			dw test9 
60a7 98 67			dw test10 
60a9				 
60a9 20 6b		        dw ssv5 
60ab 04 6b		        dw ssv4 
60ad e8 6a		        dw ssv3 
60af b2 6a		        dw ssv2 
60b1 39 6b		        dw ssv1 
60b3 81 6b		        dw ssv1cpm 
60b5			;	dw keyup 
60b5			;	dw keydown 
60b5			;	dw keyleft 
60b5			;	dw keyright 
60b5			;	dw 	keyf1 
60b5			;	dw keyf2 
60b5			;	dw keyf3 
60b5			;	dw keyf4 
60b5			;	dw keyf5 
60b5			;	dw keyf6 
60b5			;	dw keyf7 
60b5			;	dw keyf8 
60b5			;	dw keyf9 
60b5			;	dw keyf10 
60b5			;	dw keyf11 
60b5			;	dw keyf12 
60b5			;	dw keytab 
60b5			;	dw keycr 
60b5			;	dw keyhome 
60b5			;	dw keyend 
60b5			;	dw keybs 
60b5 00 00			db 0, 0	 
60b7			 
60b7			 
60b7			; File Editor 
60b7			 
60b7			; ( id - ) use 'e' to edit the displayed line 
60b7 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
60d8 .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
610d			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
610d .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
6145			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
6145			 
6145			; SPI Net support words 
6145			 
6145			; v0! = node to send to 
6145			; ( str count - ) 
6145 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
619e			 
619e			; spiputc ( char node - ) 
619e .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
61d2			; spiputc ( u node - ) 
61d2 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
6200			 
6200			; spigetc ( - n ) 
6200 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
6229			 
6229			; getnode ( - n ) 
6229 .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
6256			 
6256			; ( str node - )  
6256 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
62bc			; store string ( str i - ) 
62bc			 
62bc			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
62bc .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
6311			 
6311			; get string ( addr i -  )    TO FIX 
6311			 
6311 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
6369			 
6369			 
6369			; NETCHAT (TODO) 
6369			; Program to allow two nodes to chat with eachother 
6369			; 
6369			; v0 - target node 
6369			;  
6369			; accept input at 0,0 
6369			; if input is string send spitype to target node 
6369			; starting at row 2,0 , while spigetchr is not zero ->  
6369			; 
6369			; 
6369			; TODO add paging of get request 
6369			 
6369			; ( node - ) 
6369 .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
6388 .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
63e0 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
6458			 
6458			 
6458			; Long read of currently open file 
6458 .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
649f			 
649f			; clear stack  
649f			 
649f .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
64d3			 
64d3			; type ( addr count - ) 
64d3 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
64f8			 
64f8			; some direct memory words 
64f8			; strncpy ( len t f -- t ) 
64f8			 
64f8 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
6559			 
6559 .. 00		start1:     	db ": bpon $00 bp ;",0 
6569 .. 00		start2:     	db ": bpoff $01 bp ;",0 
657a .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
65f5 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
6655			 
6655 .. 00		tuck:         db ": tuck swap over ;", 0 
6668			 
6668			; a handy word to list items on the stack 
6668			 
6668 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
66d2			 
66d2			 
66d2			; test stack  
66d2			; rnd8 stest 
66d2			 
66d2			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
66d2			 
66d2			; random malloc and free cycles 
66d2			 
66d2			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
66d2			 
66d2			; fixed malloc and free cycles 
66d2			 
66d2			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
66d2			 
66d2			; fixed double string push and drop cycle  
66d2			 
66d2			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
66d2			 
66d2			; consistent fixed string push and drop cycle  
66d2			 
66d2			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
66d2			 
66d2			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
66d2			 
66d2			;test1:		db ": aa 1 2 3 ;", 0 
66d2			;test2:     	db "111 aa 888 999",0 
66d2			;test3:     	db ": bb 77 ;",0 
66d2			;test4:     	db "$02 $01 do i . loop bb",0 
66d2			 
66d2 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
670a .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6742 .. 00		test7:     	db ": box hline vline ;",0 
6756 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
6782 .. 00		test9:     	db ": sw $01 adsp world ;",0 
6798 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
67bd			;test11:     	db "hello create .",0 
67bd			;test12:     	db "hello2 create .",0 
67bd			 
67bd			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
67bd			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
67bd			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
67bd			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
67bd			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
67bd			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
67bd			 
67bd			;iftest1:     	db "$0001 IF cls .",0 
67bd			;iftest2:     	db "$0000 IF cls .",0 
67bd			;iftest3:     	db "$0002 $0003 - IF cls .",0 
67bd			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
67bd			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
67bd			 
67bd			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
67bd			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
67bd			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
67bd			 
67bd			 
67bd .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
67e1 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
6811 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
6836 .. 00		sound4: db ": cha $00 ; ",0 
6843 .. 00		sound5: db ": chb $20 ; ",0 
6850 .. 00		sound6: db ": chc $40 ; ",0 
685d .. 00		sound7: db ": chd $60 ; ",0 
686a .. 00		sound8: db ": cnote $80 + + note ; ", 0 
6882 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
6899			 
6899			 
6899			 
6899			 
6899			; a small guess the number game 
6899			 
6899 .. 00		game1:          db ": gsn rnd8 v1! ;",0 
68aa .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
690c			 
690c .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6941 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6977 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
69a8 .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
69bc .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
69d1 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
6a05 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
6a49			 
6a49			; Using 'ga' save a high score across multiple runs using external storage 
6a49			 
6a49 .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
6ab2			 
6ab2			 
6ab2			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
6ab2			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
6ab2			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
6ab2			 
6ab2			; simple screen saver to test code memory reuse to destruction 
6ab2			 
6ab2 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
6ae8 .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
6b04 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
6b20 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
6b39 .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
6b81 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
6bd8			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
6bd8			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
6bd8			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
6bd8			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
6bd8			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
6bd8			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
6bd8			 
6bd8			 
6bd8			 
6bd8			; minesweeper/battleship finding game 
6bd8			; draws a game board of random ship/mine positions 
6bd8			; user enters coords to see if it hits on 
6bd8			; game ends when all are hit 
6bd8			; when hit or miss says how many may be in the area 
6bd8			 
6bd8			; setup the game board and then hide it 
6bd8			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
6bd8			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
6bd8			;; prompt for where to target 
6bd8			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
6bd8			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
6bd8			;; TODO see if the entered coords hits or misses pushes char hit of miss 
6bd8			;game2mbht:      db ": mbckht nop ;",0 
6bd8			;game2mbms:      db ": mbcms nop ;",0 
6bd8			; TODO how many might be near by 
6bd8			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
6bd8			 
6bd8			; Game 3 
6bd8			 
6bd8			; Vert scroller ski game - avoid the trees! 
6bd8			 
6bd8			; v0 score (ie turns) 
6bd8			; v1 player pos 
6bd8			; v2 left wall 
6bd8			; v3 right wall 
6bd8			 
6bd8			; Draw side walls randomly 
6bd8			 
6bd8			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
6bd8			 
6bd8			; Draw player 
6bd8			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
6bd8			 
6bd8			; TODO Get Key 
6bd8			 
6bd8			; TODO Move left right 
6bd8			 
6bd8			; scroll and move walls a bit 
6bd8			 
6bd8			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
6bd8			 
6bd8			; main game loop 
6bd8			 
6bd8			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
6bd8			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
6bd8			 
6bd8			; key board defs 
6bd8			 
6bd8 .. 00		keyup:       db ": keyup $05 ;",0 
6be6 .. 00		keydown:       db ": keydown $0a ;",0 
6bf6 .. 00		keyleft:       db ": keyleft $0b ;",0 
6c06 .. 00		keyright:       db ": keyright $0c ;",0 
6c17 .. 00		keyf1:       db ": keyf1 $10 ;",0 
6c25 .. 00		keyf2:       db ": keyf2 $11 ;",0 
6c33 .. 00		keyf3:       db ": keyf3 $12 ;",0 
6c41 .. 00		keyf4:       db ": keyf4 $13 ;",0 
6c4f .. 00		keyf5:       db ": keyf5 $14 ;",0 
6c5d .. 00		keyf6:       db ": keyf6 $15 ;",0 
6c6b .. 00		keyf7:       db ": keyf7 $16 ;",0 
6c79 .. 00		keyf8:       db ": keyf8 $17 ;",0 
6c87 .. 00		keyf9:       db ": keyf9 $18 ;",0 
6c95 .. 00		keyf10:       db ": keyf10 $19 ;",0 
6ca4 .. 00		keyf11:       db ": keyf11 $1a ;",0 
6cb3 .. 00		keyf12:       db ": keyf12 $1b ;",0 
6cc2			 
6cc2 .. 00		keytab:       db ": keytab $09 ;",0 
6cd1 .. 00		keycr:       db ": keycr $0d ;",0 
6cdf .. 00		keyhome:       db ": keyhome $0e ;",0 
6cef .. 00		keyend:       db ": keyend $0f ;",0 
6cfe .. 00		keybs:       db ": keybs $08 ;",0 
6d0c			 
6d0c			   
6d0c			 
6d0c			 
6d0c			 
6d0c			; eof 
# End of file forth_autostart.asm
6d0c			 
6d0c			 
6d0c			 
6d0c			; stack over and underflow checks 
6d0c			 
6d0c			; init the words to detect the under/overflow 
6d0c			 
6d0c			chk_stk_init: 
6d0c				; a vague random number to check so we dont get any "lucky" hits 
6d0c 3e 2d			ld a, 45 
6d0e 6f				ld l, a 
6d0f 00				nop 
6d10 3e 17			ld a, 23 
6d12 67				ld h, a 
6d13			 
6d13 22 d2 f0			ld (chk_word), hl     ; the word we need to check against 
6d16			 
6d16			;	ld (chk_stund), hl	; stack points.... 
6d16 22 3b fe			ld (chk_stovr), hl 
6d19 22 21 f9			ld (chk_ret_und), hl 
6d1c 22 df f8			ld (chk_ret_ovr), hl 
6d1f 22 5d f8			ld (chk_loop_ovr), hl 
6d22 22 5b f6			ld (chk_data_ovr), hl 
6d25 c9				ret 
6d26				 
6d26			check_stacks: 
6d26				; check all stack words 
6d26			 
6d26 e5				push hl 
6d27 d5				push de 
6d28			 
6d28			;	ld de,(chk_word) 
6d28			;	ld hl, (chk_stund)	; stack points.... 
6d28			;	if DEBUG_STK_FAULT 
6d28			;		DMARK "FAa" 
6d28			;		CALLMONITOR 
6d28			;	endif 
6d28			;	call cmp16 
6d28			;	jp z, .chk_faulta 
6d28			; 
6d28			;	ld de, sfaultsu 
6d28			;	jp .chk_fault 
6d28			 
6d28 2a 3b fe		.chk_faulta: ld hl, (chk_stovr) 
6d2b ed 5b d2 f0		ld de,(chk_word) 
6d2f				if DEBUG_STK_FAULT 
6d2f					DMARK "FAb" 
6d2f					CALLMONITOR 
6d2f				endif 
6d2f cd fc 0f			call cmp16 
6d32 28 06			jr z, .chk_fault1 
6d34 11 d8 6d			ld de, sfaultso 
6d37 c3 89 6d			jp .chk_fault 
6d3a			.chk_fault1:  
6d3a 2a 21 f9			ld hl, (chk_ret_und) 
6d3d ed 5b d2 f0		ld de,(chk_word) 
6d41				if DEBUG_STK_FAULT 
6d41					DMARK "FAU" 
6d41					CALLMONITOR 
6d41				endif 
6d41 cd fc 0f			call cmp16 
6d44 ca 4d 6d			jp z, .chk_fault2 
6d47 11 e8 6d			ld de, sfaultru 
6d4a c3 89 6d			jp .chk_fault 
6d4d			.chk_fault2:  
6d4d 2a df f8			ld hl, (chk_ret_ovr) 
6d50 ed 5b d2 f0		ld de,(chk_word) 
6d54				if DEBUG_STK_FAULT 
6d54					DMARK "FA1" 
6d54					CALLMONITOR 
6d54				endif 
6d54 cd fc 0f			call cmp16 
6d57 ca 60 6d			jp z, .chk_fault3 
6d5a 11 f6 6d			ld de, sfaultro 
6d5d c3 89 6d			jp .chk_fault 
6d60			.chk_fault3:  
6d60 2a 5d f8			ld hl, (chk_loop_ovr) 
6d63 ed 5b d2 f0		ld de,(chk_word) 
6d67				if DEBUG_STK_FAULT 
6d67					DMARK "FA2" 
6d67					CALLMONITOR 
6d67				endif 
6d67 cd fc 0f			call cmp16 
6d6a ca 73 6d			jp z, .chk_fault4 
6d6d 11 10 6e			ld de, sfaultlo 
6d70 c3 89 6d			jp .chk_fault 
6d73			.chk_fault4:  
6d73 2a 5b f6			ld hl, (chk_data_ovr) 
6d76 ed 5b d2 f0		ld de,(chk_word) 
6d7a				if DEBUG_STK_FAULT 
6d7a					DMARK "FA3" 
6d7a					CALLMONITOR 
6d7a				endif 
6d7a cd fc 0f			call cmp16 
6d7d ca 86 6d			jp z, .chk_fault5 
6d80 11 2a 6e			ld de, sfaultdo 
6d83 c3 89 6d			jp .chk_fault 
6d86			 
6d86			 
6d86			.chk_fault5:  
6d86 d1				pop de 
6d87 e1				pop hl 
6d88			 
6d88 c9				ret 
6d89			 
6d89 cd aa 0d		.chk_fault: 	call clear_display 
6d8c 3e 28				ld a, display_row_2 
6d8e cd bd 0d				call str_at_display 
6d91 11 ba 6d				   ld de, .stackfault 
6d94 3e 00				ld a, display_row_1 
6d96 cd bd 0d				call str_at_display 
6d99 11 a0 fd				    ld de, debug_mark 
6d9c 3e 11				ld a, display_row_1+17 
6d9e cd bd 0d				call str_at_display 
6da1 cd cd 0d				call update_display 
6da4			 
6da4				; prompt before entering montior for investigating issue 
6da4			 
6da4 3e 78			ld a, display_row_4 
6da6 11 26 1d			ld de, endprog 
6da9			 
6da9 cd cd 0d			call update_display		 
6dac			 
6dac cd c0 1f			call next_page_prompt 
6daf			 
6daf d1				pop de 
6db0 e1				pop hl 
6db1 cd 7a 1d				call monitor 
6db4 cd df 23				call forth_warmstart 
6db7 c3 76 1c				jp warmstart_afterauto 
6dba					;jp 0 
6dba					;halt 
6dba			 
6dba			 
6dba			 
6dba .. 00		.stackfault: 	db "Stack fault:",0 
6dc7			 
6dc7 .. 00		sfaultsu: 	db	"Stack under flow",0 
6dd8 .. 00		sfaultso: 	db	"Stack over flow",0 
6de8 .. 00		sfaultru:	db "RTS underflow",0 
6df6 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
6e10 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6e2a .. 00		sfaultdo:	db "DTS overflow", 0 
6e37			 
6e37			 
6e37			fault_dsp_under: 
6e37 11 49 6e			ld de, .dsp_under 
6e3a c3 ff 6e			jp .show_fault 
6e3d			 
6e3d			fault_rsp_under: 
6e3d 11 57 6e			ld de, .rsp_under 
6e40 c3 ff 6e			jp .show_fault 
6e43			fault_loop_under: 
6e43 11 65 6e			ld de, .loop_under 
6e46 c3 ff 6e			jp .show_fault 
6e49			 
6e49 .. 00		.dsp_under: db "DSP Underflow",0 
6e57 .. 00		.rsp_under: db "RSP Underflow",0 
6e65 .. 00		.loop_under: db "LOOP Underflow",0 
6e74			 
6e74			 
6e74 d5			type_faultn: 	push de 
6e75 e5					push hl 
6e76 cd aa 0d				call clear_display 
6e79 11 a3 6e				   ld de, .typefaultn 
6e7c 3e 00				ld a, display_row_1 
6e7e cd bd 0d				call str_at_display 
6e81 11 a0 fd				    ld de, debug_mark 
6e84 3e 11				ld a, display_row_1+17 
6e86 cd bd 0d				call str_at_display 
6e89 cd cd 0d				call update_display 
6e8c			 
6e8c				; prompt before entering montior for investigating issue 
6e8c			 
6e8c 3e 78			ld a, display_row_4 
6e8e 11 26 1d			ld de, endprog 
6e91			 
6e91 cd cd 0d			call update_display		 
6e94			 
6e94 cd c0 1f			call next_page_prompt 
6e97			 
6e97 e5					push hl 
6e98 d5					push de 
6e99 cd 7a 1d				call monitor 
6e9c cd df 23				call forth_warmstart 
6e9f c3 76 1c				jp warmstart_afterauto 
6ea2 76					halt 
6ea3			 
6ea3			 
6ea3 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6eba			 
6eba d5			type_faults: 	push de 
6ebb e5					push hl 
6ebc cd aa 0d				call clear_display 
6ebf 11 e8 6e				   ld de, .typefaults 
6ec2 3e 00				ld a, display_row_1 
6ec4 cd bd 0d				call str_at_display 
6ec7 11 a0 fd				    ld de, debug_mark 
6eca 3e 11				ld a, display_row_1+17 
6ecc cd bd 0d				call str_at_display 
6ecf cd cd 0d				call update_display 
6ed2			 
6ed2				; prompt before entering montior for investigating issue 
6ed2			 
6ed2 3e 78			ld a, display_row_4 
6ed4 11 26 1d			ld de, endprog 
6ed7			 
6ed7 cd cd 0d			call update_display		 
6eda			 
6eda cd c0 1f			call next_page_prompt 
6edd			 
6edd e1					pop hl 
6ede d1					pop de 
6edf cd 7a 1d				call monitor 
6ee2 cd df 23				call forth_warmstart 
6ee5 c3 76 1c				jp warmstart_afterauto 
6ee8			 
6ee8			 
6ee8 .. 00		.typefaults: db "STR Type Expected TOS!",0 
6eff			 
6eff			.show_fault: 	 
6eff d5					push de 
6f00 cd aa 0d				call clear_display 
6f03 d1					pop de 
6f04 3e 00				ld a, display_row_1 
6f06 cd bd 0d				call str_at_display 
6f09 11 a0 fd				    ld de, debug_mark 
6f0c 3e 11				ld a, display_row_1+17 
6f0e cd bd 0d				call str_at_display 
6f11 cd cd 0d				call update_display 
6f14			 
6f14				; prompt before entering montior for investigating issue 
6f14			 
6f14 3e 78			ld a, display_row_4 
6f16 11 26 1d			ld de, endprog 
6f19			 
6f19 cd cd 0d			call update_display		 
6f1c			 
6f1c cd c0 1f			call next_page_prompt 
6f1f			 
6f1f e1					pop hl 
6f20 d1					pop de 
6f21 cd 7a 1d				call monitor 
6f24			; do a dump to cli and not warmstart so we preserve all of the uwords.  
6f24			; TODO Make optional fault restart to cli or warm boot? 
6f24					;jp warmstart 
6f24 c3 ba 1c				jp cli 
6f27 76					halt 
6f28			 
6f28			 
6f28			; handle the auto run of code from files in storage 
6f28			 
6f28			 
6f28			include "forth_startup.asm" 
6f28			; Which startup method to use? 
6f28			; 
6f28			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
6f28			; followed by loading of a list of scripts in eeprom 
6f28			 
6f28			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
6f28			; from eeprom 
6f28			 
6f28			; Select with define in main stubs 
6f28			 
6f28			if STARTUP_V1 
6f28				include "forth_startupv1.asm" 
6f28			endif 
6f28			if STARTUP_V2 
6f28				include "forth_startupv2.asm" 
6f28			; Version 2 of the startup  
6f28			;  
6f28			; Auto load any files in bank 1 that start with a '*' 
6f28			; If no se storage then revert to using eprom 
6f28			 
6f28			 
6f28			if STORAGE_SE = 0 
6f28			 
6f28			sprompt1: db "Startup load...",0 
6f28			sprompt2: db "Run? 1=No *=End #=All",0 
6f28			 
6f28			 
6f28			 
6f28			 
6f28			forth_startup: 
6f28				ld hl, startcmds 
6f28				ld a, 0 
6f28				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
6f28			 
6f28			.start1:	push hl 
6f28				call clear_display 
6f28				ld de, sprompt1 
6f28			        ld a, display_row_1 
6f28				call str_at_display 
6f28				ld de, sprompt2 
6f28			        ld a, display_row_2 
6f28				call str_at_display 
6f28				pop hl 
6f28				push hl 
6f28				ld e,(hl) 
6f28				inc hl 
6f28				ld d,(hl) 
6f28			        ld a, display_row_3 
6f28				call str_at_display 
6f28				call update_display 
6f28			 
6f28			 
6f28				ld a, (os_last_cmd) 
6f28				cp 0 
6f28				jr z, .startprompt 
6f28				call delay250ms 
6f28				jr .startdo 
6f28				 
6f28				 
6f28			 
6f28			.startprompt: 
6f28			 
6f28				ld a,display_row_4 + display_cols - 1 
6f28			        ld de, endprg 
6f28				call str_at_display 
6f28				call update_display 
6f28				call delay1s 
6f28				call cin_wait 
6f28						 
6f28				cp '*' 
6f28				jr z, .startupend1 
6f28				cp '#' 
6f28				jr nz, .startno 
6f28				ld a, 1 
6f28				ld (os_last_cmd),a 
6f28				jr .startdo 
6f28			.startno:	cp '1' 
6f28				jr z,.startnxt  
6f28			 
6f28				; exec startup line 
6f28			.startdo:	 
6f28				pop hl 
6f28				push hl 
6f28				 
6f28				ld e,(hl) 
6f28				inc hl 
6f28				ld d,(hl) 
6f28				ex de,hl 
6f28			 
6f28				push hl 
6f28			 
6f28				ld a, 0 
6f28				;ld a, FORTH_END_BUFFER 
6f28				call strlent 
6f28				inc hl   ; include zero term to copy 
6f28				ld b,0 
6f28				ld c,l 
6f28				pop hl 
6f28				ld de, scratch 
6f28				ldir 
6f28			 
6f28			 
6f28				ld hl, scratch 
6f28				call forthparse 
6f28				call forthexec 
6f28				call forthexec_cleanup 
6f28			 
6f28				ld a, display_row_4 
6f28				ld de, endprog 
6f28			 
6f28				call update_display		 
6f28			 
6f28				ld a, (os_last_cmd) 
6f28				cp 0 
6f28				jr nz, .startnxt 
6f28				call next_page_prompt 
6f28			        call clear_display 
6f28				call update_display		 
6f28			 
6f28				; move onto next startup line? 
6f28			.startnxt: 
6f28			 
6f28				call delay250ms 
6f28				pop hl 
6f28			 
6f28				inc hl 
6f28				inc hl 
6f28			 
6f28				push hl 
6f28				ld e, (hl) 
6f28				inc hl 
6f28				ld d, (hl) 
6f28				pop hl 
6f28				; TODO replace 0 test 
6f28			 
6f28				ex de, hl 
6f28				call ishlzero 
6f28			;	ld a,e 
6f28			;	add d 
6f28			;	cp 0    ; any left to do? 
6f28				ex de, hl 
6f28				jp nz, .start1 
6f28				jr .startupend 
6f28			 
6f28			.startupend1: pop hl 
6f28			.startupend: 
6f28			 
6f28				call clear_display 
6f28				call update_display 
6f28				ret 
6f28			endif 
6f28			 
6f28			 
6f28			if STORAGE_SE 
6f28			 
6f28			;sprompt3: db "Loading from start-up file:",0 
6f28 .. 00		sprompt3: db "  Searching...",0 
6f37			;sprompt4: db "(Any key to stop)",0 
6f37			 
6f37			 
6f37			forth_autoload: 
6f37			 
6f37				; load block 0 of store 1 
6f37				 
6f37 3e fe			ld a, $fe      ; bit 0 clear 
6f39 32 95 f9			ld (spi_device), a 
6f3c			 
6f3c cd 25 05			call storage_get_block_0 
6f3f			 
6f3f 3a d0 f9			ld a, (store_page+STORE_0_AUTOFILE) 
6f42			 
6f42 fe 00			cp 0 
6f44 c8				ret z     ; auto start not enabled 
6f45			 
6f45 cd aa 0d			call clear_display 
6f48			 
6f48				; set bank 
6f48			 
6f48 3a d2 f9				ld a, (store_page+STORE_0_BANKRUN) 
6f4b 32 95 f9				ld (spi_device), a 
6f4e			 
6f4e			 
6f4e				; generate a directory of bank 1 and search for flagged files 
6f4e			 
6f4e					if DEBUG_FORTH_WORDS_KEY 
6f4e						DMARK "DIR" 
6f4e f5				push af  
6f4f 3a 63 6f			ld a, (.dmark)  
6f52 32 a0 fd			ld (debug_mark),a  
6f55 3a 64 6f			ld a, (.dmark+1)  
6f58 32 a1 fd			ld (debug_mark+1),a  
6f5b 3a 65 6f			ld a, (.dmark+2)  
6f5e 32 a2 fd			ld (debug_mark+2),a  
6f61 18 03			jr .pastdmark  
6f63 ..			.dmark: db "DIR"  
6f66 f1			.pastdmark: pop af  
6f67			endm  
# End of macro DMARK
6f67						CALLMONITOR 
6f67 cd aa fd			call debug_vector  
6f6a				endm  
# End of macro CALLMONITOR
6f6a					endif 
6f6a			 
6f6a cd 25 05			call storage_get_block_0 
6f6d			 
6f6d 21 af f9			ld hl, store_page     ; get current id count 
6f70 46				ld b, (hl) 
6f71 0e 00			ld c, 0    ; count of files   
6f73					if DEBUG_FORTH_WORDS 
6f73						DMARK "DI1" 
6f73 f5				push af  
6f74 3a 88 6f			ld a, (.dmark)  
6f77 32 a0 fd			ld (debug_mark),a  
6f7a 3a 89 6f			ld a, (.dmark+1)  
6f7d 32 a1 fd			ld (debug_mark+1),a  
6f80 3a 8a 6f			ld a, (.dmark+2)  
6f83 32 a2 fd			ld (debug_mark+2),a  
6f86 18 03			jr .pastdmark  
6f88 ..			.dmark: db "DI1"  
6f8b f1			.pastdmark: pop af  
6f8c			endm  
# End of macro DMARK
6f8c						CALLMONITOR 
6f8c cd aa fd			call debug_vector  
6f8f				endm  
# End of macro CALLMONITOR
6f8f					endif 
6f8f			 
6f8f				; check for empty drive 
6f8f			 
6f8f 3e 00			ld a, 0 
6f91 b8				cp b 
6f92 ca df 6f			jp z, .dirdone 
6f95			 
6f95				; for each of the current ids do a search for them and if found push to stack 
6f95			 
6f95 c5			.diritem:	push bc 
6f96 21 40 00				ld hl, STORE_BLOCK_PHY 
6f99 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
6f9b 58					ld e,b 
6f9c			 
6f9c d5					push de 
6f9d e5					push hl 
6f9e cd aa 0d			call clear_display 
6fa1 3e 32			ld a, display_row_2 + 10 
6fa3 11 28 6f			ld de, sprompt3 
6fa6 cd bd 0d			call str_at_display 
6fa9 cd 01 0d			call active 
6fac eb				ex de, hl 
6fad 3e 2f			ld a, display_row_2 + 7 
6faf cd bd 0d			call str_at_display 
6fb2 cd cd 0d			call update_display 
6fb5 e1				pop hl 
6fb6 d1				pop de 
6fb7			 
6fb7			;		if DEBUG_FORTH_WORDS 
6fb7			;			DMARK "DI2" 
6fb7			;			CALLMONITOR 
6fb7			;		endif 
6fb7			 
6fb7 cd a7 07				call storage_findnextid 
6fba			 
6fba			;		if DEBUG_FORTH_WORDS 
6fba			;			DMARK "DI3" 
6fba			;			CALLMONITOR 
6fba			;		endif 
6fba			 
6fba					; if found hl will be non zero 
6fba			 
6fba cd 07 10				call ishlzero 
6fbd			;		ld a, l 
6fbd			;		add h 
6fbd			; 
6fbd			;		cp 0 
6fbd 28 1d				jr z, .dirnotfound 
6fbf			 
6fbf					; increase count 
6fbf			 
6fbf c1					pop bc	 
6fc0 0c					inc c 
6fc1 c5					push bc 
6fc2					 
6fc2			 
6fc2					; get file header and push the file name 
6fc2			 
6fc2 11 af f9				ld de, store_page 
6fc5 cd 74 04				call storage_read_block 
6fc8			 
6fc8					; push file id to stack 
6fc8				 
6fc8			 
6fc8					; is this a file we want to run? 
6fc8			 
6fc8 21 b2 f9				ld hl, store_page+3 
6fcb 7e					ld a,(hl) 
6fcc fe 2a				cp '*' 
6fce 20 0c				jr nz,  .dirnotfound 
6fd0					 
6fd0			 
6fd0			 
6fd0 3a af f9				ld a, (store_page) 
6fd3 d5					push de 
6fd4 e5					push hl 
6fd5 c5					push bc 
6fd6 cd 02 70				call .autorunf 
6fd9 c1					pop bc 
6fda e1					pop hl 
6fdb d1					pop de 
6fdc			 
6fdc			 
6fdc			 
6fdc				; save this extent 
6fdc			 
6fdc					; push file name 
6fdc			;display file name to run 
6fdc			 
6fdc			;		ld hl, store_page+3 
6fdc			;		if DEBUG_FORTH_WORDS 
6fdc			;			DMARK "DI5" 
6fdc			;			CALLMONITOR 
6fdc			;		endif 
6fdc			; 
6fdc			;		 
6fdc			; 
6fdc			;		call forth_push_str 
6fdc			;		if DEBUG_FORTH_WORDS 
6fdc			;			DMARK "DI6" 
6fdc			;			CALLMONITOR 
6fdc			;		endif 
6fdc			.dirnotfound: 
6fdc c1					pop bc     
6fdd 10 b6				djnz .diritem 
6fdf				 
6fdf			.dirdone:	 
6fdf					if DEBUG_FORTH_WORDS 
6fdf						DMARK "DI7" 
6fdf f5				push af  
6fe0 3a f4 6f			ld a, (.dmark)  
6fe3 32 a0 fd			ld (debug_mark),a  
6fe6 3a f5 6f			ld a, (.dmark+1)  
6fe9 32 a1 fd			ld (debug_mark+1),a  
6fec 3a f6 6f			ld a, (.dmark+2)  
6fef 32 a2 fd			ld (debug_mark+2),a  
6ff2 18 03			jr .pastdmark  
6ff4 ..			.dmark: db "DI7"  
6ff7 f1			.pastdmark: pop af  
6ff8			endm  
# End of macro DMARK
6ff8						CALLMONITOR 
6ff8 cd aa fd			call debug_vector  
6ffb				endm  
# End of macro CALLMONITOR
6ffb					endif 
6ffb			 
6ffb cd aa 0d				call clear_display 
6ffe cd cd 0d				call update_display 
7001			 
7001 c9					ret 
7002			 
7002			 
7002			 
7002			 
7002			 
7002			.autorunf: 
7002			 
7002			 
7002				; get file id to load from and get the file name to display 
7002			 
7002			;		ld a, (store_page+STORE_0_FILERUN) 
7002			 
7002 2e 00				ld l, 0 
7004 67					ld h, a 
7005 11 af f9				ld de, store_page 
7008			 
7008					if DEBUG_FORTH_WORDS 
7008						DMARK "ASp" 
7008 f5				push af  
7009 3a 1d 70			ld a, (.dmark)  
700c 32 a0 fd			ld (debug_mark),a  
700f 3a 1e 70			ld a, (.dmark+1)  
7012 32 a1 fd			ld (debug_mark+1),a  
7015 3a 1f 70			ld a, (.dmark+2)  
7018 32 a2 fd			ld (debug_mark+2),a  
701b 18 03			jr .pastdmark  
701d ..			.dmark: db "ASp"  
7020 f1			.pastdmark: pop af  
7021			endm  
# End of macro DMARK
7021						CALLMONITOR 
7021 cd aa fd			call debug_vector  
7024				endm  
# End of macro CALLMONITOR
7024					endif 
7024 cd cd 09				call storage_read 
7027			 
7027					if DEBUG_FORTH_WORDS 
7027						DMARK "ASr" 
7027 f5				push af  
7028 3a 3c 70			ld a, (.dmark)  
702b 32 a0 fd			ld (debug_mark),a  
702e 3a 3d 70			ld a, (.dmark+1)  
7031 32 a1 fd			ld (debug_mark+1),a  
7034 3a 3e 70			ld a, (.dmark+2)  
7037 32 a2 fd			ld (debug_mark+2),a  
703a 18 03			jr .pastdmark  
703c ..			.dmark: db "ASr"  
703f f1			.pastdmark: pop af  
7040			endm  
# End of macro DMARK
7040						CALLMONITOR 
7040 cd aa fd			call debug_vector  
7043				endm  
# End of macro CALLMONITOR
7043					endif 
7043			 
7043 cd 07 10				call ishlzero 
7046 c8					ret z             ; file not found 
7047			 
7047					; display file name we are loading 
7047			 
7047 cd aa 0d				call clear_display 
704a			 
704a 3e 32				ld a, display_row_2 + 10 
704c 11 b2 f9				ld de, store_page+3 
704f cd bd 0d				call str_at_display 
7052				 
7052			; 
7052			 
7052			;	ld a, display_row_1+5 
7052			;	ld de, sprompt3 
7052			;	call str_at_display 
7052			;	ld a, display_row_2+7 
7052			;	call active 
7052			;	ex de, hl 
7052			;;	ld de, sprompt4 
7052			;	call str_at_display 
7052			; 
7052 cd cd 0d			call update_display 
7055			 
7055			;	call cin_wait 
7055			;	cp 'n' 
7055			;	ret z 
7055			;	cp 'N' 
7055			;	ret z 
7055			 
7055			;	call delay1s 
7055			 
7055 3a b1 f9			ld a, (store_page+2) 
7058 32 9e f9			ld (store_openmaxext), a    ; save count of ext 
705b 3e 01			ld a, 1  
705d 32 9f f9			ld (store_openext), a    ; save count of ext 
7060			 
7060			.autof: 
7060				; begin to read a line from file 
7060			 
7060 21 1d f4			ld hl, os_cli_cmd 
7063 22 1b f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
7066			  
7066			.readext: 
7066 3a 9f f9			ld a, (store_openext) 
7069 6f				ld l , a 
706a				 
706a 3a af f9			ld a, (store_page) 
706d 67				ld h, a	 
706e 11 af f9			ld de, store_page 
7071					if DEBUG_FORTH_WORDS 
7071						DMARK "ASl" 
7071 f5				push af  
7072 3a 86 70			ld a, (.dmark)  
7075 32 a0 fd			ld (debug_mark),a  
7078 3a 87 70			ld a, (.dmark+1)  
707b 32 a1 fd			ld (debug_mark+1),a  
707e 3a 88 70			ld a, (.dmark+2)  
7081 32 a2 fd			ld (debug_mark+2),a  
7084 18 03			jr .pastdmark  
7086 ..			.dmark: db "ASl"  
7089 f1			.pastdmark: pop af  
708a			endm  
# End of macro DMARK
708a						CALLMONITOR 
708a cd aa fd			call debug_vector  
708d				endm  
# End of macro CALLMONITOR
708d					endif 
708d cd cd 09				call storage_read 
7090 cd 07 10			call ishlzero 
7093 c8				ret z 
7094			 
7094			; TODO copy to exec buffer 
7094			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
7094			 
7094				; copy the record buffer to the cli buffer 
7094			 
7094 ed 5b 1b f6		ld de, (os_var_array) 
7098 21 b1 f9			ld hl, store_page+2 
709b			;	ex de, hl 
709b 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
709e ed b0			ldir 
70a0 ed 53 1b f6		ld (os_var_array), de 
70a4				 
70a4 3a 9f f9			ld a, (store_openext) 
70a7 3c				inc a 
70a8 32 9f f9			ld (store_openext), a    ; save count of ext 
70ab			 
70ab			 
70ab			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
70ab				 
70ab 3a a2 f9			ld a, (store_readcont) 
70ae fe 00			cp 0 
70b0 20 b4			jr nz, .readext 
70b2			 
70b2			;	jr z, .autoend 
70b2			 
70b2					if DEBUG_FORTH_WORDS 
70b2						DMARK "ASc" 
70b2 f5				push af  
70b3 3a c7 70			ld a, (.dmark)  
70b6 32 a0 fd			ld (debug_mark),a  
70b9 3a c8 70			ld a, (.dmark+1)  
70bc 32 a1 fd			ld (debug_mark+1),a  
70bf 3a c9 70			ld a, (.dmark+2)  
70c2 32 a2 fd			ld (debug_mark+2),a  
70c5 18 03			jr .pastdmark  
70c7 ..			.dmark: db "ASc"  
70ca f1			.pastdmark: pop af  
70cb			endm  
# End of macro DMARK
70cb						CALLMONITOR 
70cb cd aa fd			call debug_vector  
70ce				endm  
# End of macro CALLMONITOR
70ce					endif 
70ce e5				push hl	 
70cf d5				push de 
70d0 cd 01 0d			call active 
70d3 eb				ex de, hl 
70d4 3e 2f			ld a, display_row_2 + 7 
70d6 cd bd 0d			call str_at_display 
70d9			 
70d9 cd cd 0d			call update_display 
70dc d1				pop de  
70dd e1				pop hl 
70de			;	call delay250ms 
70de			 
70de			 
70de			 
70de			 
70de			.autoexec: 
70de			 
70de			 
70de 21 1d f4			ld hl, os_cli_cmd 
70e1					if DEBUG_FORTH_WORDS 
70e1						DMARK "ASx" 
70e1 f5				push af  
70e2 3a f6 70			ld a, (.dmark)  
70e5 32 a0 fd			ld (debug_mark),a  
70e8 3a f7 70			ld a, (.dmark+1)  
70eb 32 a1 fd			ld (debug_mark+1),a  
70ee 3a f8 70			ld a, (.dmark+2)  
70f1 32 a2 fd			ld (debug_mark+2),a  
70f4 18 03			jr .pastdmark  
70f6 ..			.dmark: db "ASx"  
70f9 f1			.pastdmark: pop af  
70fa			endm  
# End of macro DMARK
70fa						CALLMONITOR 
70fa cd aa fd			call debug_vector  
70fd				endm  
# End of macro CALLMONITOR
70fd					endif 
70fd cd 87 24			call forthparse 
7100 cd c7 24			call forthexec 
7103 cd d9 23			call forthexec_cleanup 
7106			 
7106			 
7106			 
7106 c3 60 70			jp .autof 
7109			;.autofdone: 
7109			; 
7109			;		if DEBUG_FORTH_WORDS 
7109			;			DMARK "ASx" 
7109			;			CALLMONITOR 
7109			;		endif 
7109			;;	call clear_display 
7109			;	ret 
7109			 
7109			 
7109			 
7109			endif 
# End of file forth_startupv2.asm
7109			endif 
7109			 
# End of file forth_startup.asm
7109			 
7109			; eof 
# End of file forth_kernel.asm
7109			;include "nascombasic.asm" 
7109			 
7109			 
7109			; find out where the code ends if loaded into RAM (for SC114) 
7109			;endofcode:  
7109			;	nop 
7109			 
7109			 
7109			; jump to nmi vector 
7109			 
7109			init_nmi: 
7109 3e c9			ld a, $c9   ; RET 
710b 32 ad fd			ld (nmi_vector), a 
710e c9				ret 
710f			nmi: 
710f e5				push hl 
7110 d5				push de 
7111 c5				push bc 
7112 f5				push af 
7113 cd ad fd			call nmi_vector 
7116 f5				push af 
7117 c5				push bc 
7118 d5				push de 
7119 e5				push hl 
711a ed 4d			reti 
711c			 
711c			 
711c			; eof 
711c			 
# End of file main.asm
711c			include "firmware_lcd_4x40.asm" 
711c			; **********************************************************************  
711c			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
711c			; **********************************************************************  
711c			;  
711c			; **  Written as a Small Computer Monitor App  
711c			; **  www.scc.me.uk  
711c			;  
711c			; History  
711c			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
711c			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
711c			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
711c			;  
711c			; **********************************************************************  
711c			;  
711c			; This program is an example of one of the methods of interfacing an   
711c			; alphanumeric LCD module.   
711c			;  
711c			; In this example the display is connected to either a Z80 PIO or a   
711c			; simple 8-bit output port.   
711c			;  
711c			; This interfacing method uses 4-bit data mode and uses time delays  
711c			; rather than polling the display's ready status. As a result the   
711c			; interface only requires 6 simple output lines:  
711c			;   Output bit 0 = not used  
711c			;   Output bit 1 = not used  
711c			;   Output bit 2 = RS         High = data, Low = instruction  
711c			;   Output bit 3 = E          Active high  
711c			;   Output bit 4 = DB4  
711c			;   Output bit 5 = DB5  
711c			;   Output bit 6 = DB6  
711c			;   Output bit 7 = DB7  
711c			; Display's R/W is connected to 0v so it is always in write mode  
711c			;  
711c			; This set up should work with any system supporting the RC2014 bus  
711c			  
711c			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
711c			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
711c			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
711c			;  
711c			; **********************************************************************  
711c			  
711c			; Additonal for 4x40. E1 and E2 instead of just E   
711c			; TODO swipe vidout signal on port a to activate E2  
711c			  
711c			; **********************************************************************  
711c			; **  Constants  
711c			; **********************************************************************  
711c			; LCD constants required by LCD support module  
711c			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
711c			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
711c			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
711c			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
711c			; TODO Decide which E is being set  
711c			kLCDWidth:  EQU display_cols             ;Width in characters  
711c			  
711c			; **********************************************************************  
711c			; **  Code library usage  
711c			; **********************************************************************  
711c			  
711c			; send character to current cursor position  
711c			; wraps and/or scrolls screen automatically  
711c			  
711c			  
711c			  
711c			lcd_init:  
711c			  
711c			; SCMonAPI functions used  
711c			  
711c			; Alphanumeric LCD functions used  
711c			; no need to specify specific functions for this module  
711c			  
711c 3e cf		            LD   A, 11001111b  
711e d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
7120 3e 00		            LD   A, 00000000b  
7122 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
7124			  
7124			; Initialise alphanumeric LCD module  
7124 3e 00				ld a, 0  
7126 32 00 fb				ld (display_lcde1e2), a  
7129 cd aa 71		            CALL fLCD_Init      ;Initialise LCD module  
712c 3e 01				ld a, 1  
712e 32 00 fb				ld (display_lcde1e2), a  
7131 cd aa 71		            CALL fLCD_Init      ;Initialise LCD module  
7134			  
7134 c9				ret  
7135			  
7135			;  
7135			;;  
7135			; lcd functions  
7135			;  
7135			;  
7135			  
7135			; what is at cursor position   
7135			  
7135			;get_cursor:	ld de, (cursor_row)   ;  row + col  
7135			;		call curptr  
7135			;		ret  
7135			  
7135			  
7135			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
7135			  
7135			curptr:  
7135 c5				push bc  
7136 21 e6 fc			ld hl, display_fb0  
7139			cpr:	  
7139				; loop for cursor whole row  
7139 0e 28			ld c, display_cols  
713b 23			cpr1:	inc hl  
713c 0d				dec c  
713d 20 fc			jr nz, cpr1  
713f 05				dec b  
7140 20 f7			jr nz, cpr  
7142			  
7142				; add col	  
7142			  
7142 23			cpr2:	inc hl  
7143 1d				dec e  
7144 20 fc			jr nz, cpr2  
7146			  
7146 c1				pop bc  
7147 c9				ret  
7148				  
7148			  
7148			  
7148			  
7148			  
7148			; write the frame buffer given in hl to hardware   
7148 22 fe fa		write_display: ld (display_write_tmp), hl 	   
714b 3e 00			ld a, kLCD_Line1  
714d cd 57 72		            CALL fLCD_Pos       ;Position cursor to location in A  
7150 06 28			ld b, display_cols  
7152 ed 5b fe fa		ld de, (display_write_tmp)  
7156 cd a2 71			call write_len_string  
7159				  
7159				  
7159 2a fe fa			ld hl, (display_write_tmp)  
715c 11 28 00			ld de, display_cols  
715f 19				add hl,de  
7160 22 fe fa			ld (display_write_tmp),hl  
7163			  
7163				  
7163 3e 28			ld a, kLCD_Line2  
7165 cd 57 72		            CALL fLCD_Pos       ;Position cursor to location in A  
7168 06 28			ld b, display_cols  
716a ed 5b fe fa		ld de, (display_write_tmp)  
716e cd a2 71			call write_len_string  
7171				  
7171 2a fe fa			ld hl, (display_write_tmp)  
7174 11 28 00			ld de, display_cols  
7177 19				add hl,de  
7178 22 fe fa			ld (display_write_tmp),hl  
717b			  
717b				  
717b 3e 50			ld a, kLCD_Line3  
717d cd 57 72		            CALL fLCD_Pos       ;Position cursor to location in A  
7180 06 28			ld b, display_cols  
7182 ed 5b fe fa		ld de, (display_write_tmp)  
7186 cd a2 71			call write_len_string  
7189				  
7189 2a fe fa			ld hl, (display_write_tmp)  
718c 11 28 00			ld de, display_cols  
718f 19				add hl,de  
7190 22 fe fa			ld (display_write_tmp),hl  
7193			  
7193				  
7193 3e 78			ld a, kLCD_Line4  
7195 cd 57 72		            CALL fLCD_Pos       ;Position cursor to location in A  
7198 06 28			ld b, display_cols  
719a ed 5b fe fa		ld de, (display_write_tmp)  
719e cd a2 71			call write_len_string  
71a1 c9					ret  
71a2				  
71a2				; write out a fixed length string given in b from de  
71a2			  
71a2 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
71a3 cd 0f 72		            CALL fLCD_Data      ;Write character to display  
71a6 13				inc de  
71a7 10 f9			djnz write_len_string  
71a9 c9				ret  
71aa			  
71aa			; Some other things to do  
71aa			;            LD   A, kLCD_Clear ;Display clear  
71aa			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
71aa			;            LD   A, kLCD_Under ;Display on with underscore cursor  
71aa			;            LD   A, kLCD_On     ;Display on with no cursor  
71aa			;            ;LD   A, kLCD_Off   ;Display off  
71aa			;            CALL fLCD_Inst      ;Send instruction to display  
71aa			;  
71aa			;  
71aa			;            halt  
71aa			;  
71aa			;  
71aa			;MsgHello:   DB  "Hello World!",0  
71aa			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
71aa			  
71aa			; Custom characters 5 pixels wide by 8 pixels high  
71aa			; Up to 8 custom characters can be defined  
71aa			;BitMaps:      
71aa			;; Character 0x00 = Battery icon  
71aa			;            DB  01110b  
71aa			;            DB  11011b  
71aa			;            DB  10001b  
71aa			;            DB  10001b  
71aa			;            DB  11111b  
71aa			;            DB  11111b  
71aa			;            DB  11111b  
71aa			;            DB  11111b  
71aa			;; Character 0x01 = Bluetooth icon  
71aa			;            DB  01100b  
71aa			;            DB  01010b  
71aa			;            DB  11100b  
71aa			;            DB  01000b  
71aa			;            DB  11100b  
71aa			;            DB  01010b  
71aa			;            DB  01100b  
71aa			;            DB  00000b  
71aa			;  
71aa			  
71aa			  
71aa			; **********************************************************************  
71aa			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
71aa			; **********************************************************************  
71aa			;  
71aa			; **  Written as a Small Computer Monitor App   
71aa			; **  Version 0.1 SCC 2018-05-16  
71aa			; **  www.scc.me.uk  
71aa			;  
71aa			; **********************************************************************  
71aa			;  
71aa			; This module provides support for alphanumeric LCD modules using with  
71aa			; *  HD44780 (or compatible) controller  
71aa			; *  5 x 7 pixel fonts  
71aa			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
71aa			; *  Interface via six digital outputs to the display (see below)  
71aa			;  
71aa			; LCD module pinout:  
71aa			;   1  Vss   0v supply  
71aa			;   2  Vdd   5v supply  
71aa			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
71aa			;   4  RS    High = data, Low = instruction  
71aa			;   5  R/W   High = Read, Low = Write  
71aa			;   6  E     Enable signal (active high)  
71aa			;   7  DB0   Data bit 0  
71aa			;   8  DB1   Data bit 1  
71aa			;   9  DB2   Data bit 2  
71aa			;  10  DB3   Data bit 3  
71aa			;  11  DB4   Data bit 4  
71aa			;  12  DB5   Data bit 5  
71aa			;  13  DB6   Data bit 6  
71aa			;  14  DB7   Data bit 7  
71aa			;  15  A     Backlight anode (+)  
71aa			;  16  K     Backlight cathode (-)  
71aa			;  
71aa			; This interfacing method uses 4-bit data mode and uses time delays  
71aa			; rather than polling the display's ready status. As a result the   
71aa			; interface only requires 6 simple output lines:  
71aa			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
71aa			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
71aa			;   LCD DB4 = Microcomputer output port bit 4  
71aa			;   LCD DB5 = Microcomputer output port bit 5  
71aa			;   LCD DB6 = Microcomputer output port bit 6  
71aa			;   LCD DB7 = Microcomputer output port bit 7  
71aa			; Display's R/W is connected to 0v so it is always in write mode  
71aa			; All 6 connections must be on the same port address <kLCDPrt>  
71aa			; This method also allows a decent length of cable from micro to LCD  
71aa			;  
71aa			; **********************************************************************  
71aa			;  
71aa			; To include the code for any given function provided by this module,   
71aa			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
71aa			; the parent source file.  
71aa			; For example:  #REQUIRES   uHexPrefix  
71aa			;  
71aa			; Also #INCLUDE this file at some point after the #REQUIRES statements  
71aa			; in the parent source file.  
71aa			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
71aa			;  
71aa			; These are the function names provided by this module:  
71aa			; fLCD_Init                     ;Initialise LCD  
71aa			; fLCD_Inst                     ;Send instruction to LCD  
71aa			; fLCD_Data                     ;Send data byte to LCD  
71aa			; fLCD_Pos                      ;Position cursor  
71aa			; fLCD_Str                      ;Display string  
71aa			; fLCD_Def                      ;Define custom character  
71aa			;  
71aa			; **********************************************************************  
71aa			;  
71aa			; Requires SCMonAPI.asm to also be included in the project  
71aa			;  
71aa			  
71aa			  
71aa			; **********************************************************************  
71aa			; **  Constants  
71aa			; **********************************************************************  
71aa			  
71aa			; Constants that must be defined externally  
71aa			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
71aa			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
71aa			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
71aa			;kLCDWidth: EQU 20             ;Width in characters  
71aa			  
71aa			; general line offsets in any frame buffer  
71aa			  
71aa			  
71aa			display_row_1: equ 0  
71aa			display_row_2: equ display_row_1+display_cols  
71aa			display_row_3: equ display_row_2 + display_cols  
71aa			display_row_4: equ display_row_3 + display_cols  
71aa			;display_row_4_eol:   
71aa			  
71aa			  
71aa			; Cursor position values for the start of each line  
71aa			  
71aa			; E  
71aa			kLCD_Line1: EQU 0x00   
71aa			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
71aa			; E1  
71aa			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
71aa			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
71aa			  
71aa			; Instructions to send as A register to fLCD_Inst  
71aa			kLCD_Clear: EQU 00000001b     ;LCD clear  
71aa			kLCD_Off:   EQU 00001000b     ;LCD off  
71aa			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
71aa			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
71aa			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
71aa			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
71aa			  
71aa			; Constants used by this code module  
71aa			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
71aa			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
71aa			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
71aa			  
71aa			  
71aa			  
71aa			; **********************************************************************  
71aa			; **  LCD support functions  
71aa			; **********************************************************************  
71aa			  
71aa			; Initialise alphanumeric LCD module  
71aa			; LCD control register codes:  
71aa			;   DL   0 = 4-bit mode        1 = 8-bit mode  
71aa			;   N    0 = 1-line mode       1 = 2-line mode  
71aa			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
71aa			;   D    0 = Display off       1 = Display on  
71aa			;   C    0 = Cursor off        1 = Cursor on  
71aa			;   B    0 = Blinking off      1 = Blinking on  
71aa			;   ID   0 = Decrement mode    1 = Increment mode  
71aa			;   SH   0 = Entire shift off  1 = Entire shift on  
71aa 3e 28		fLCD_Init:  LD   A, 40  
71ac cd d1 72		            CALL LCDDelay       ;Delay 40ms after power up  
71af			; For reliable reset set 8-bit mode - 3 times  
71af cd a1 72		            CALL WrFn8bit       ;Function = 8-bit mode  
71b2 cd a1 72		            CALL WrFn8bit       ;Function = 8-bit mode  
71b5 cd a1 72		            CALL WrFn8bit       ;Function = 8-bit mode  
71b8			; Set 4-bit mode  
71b8 cd 9d 72		            CALL WrFn4bit       ;Function = 4-bit mode  
71bb cd cf 72		            CALL LCDDelay1      ;Delay 37 us or more  
71be			; Function set  
71be 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
71c0 cd d3 71		            CALL fLCD_Inst      ;2 line, display on  
71c3			; Display On/Off control  
71c3 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
71c5 cd d3 71		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
71c8			; Display Clear  
71c8 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
71ca cd d3 71		            CALL fLCD_Inst      ;Clear display  
71cd			; Entry mode  
71cd 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
71cf cd d3 71		            CALL fLCD_Inst      ;Increment mode, shift off  
71d2			; Display module now initialised  
71d2 c9			            RET  
71d3			; ok to here  
71d3			  
71d3			; Write instruction to LCD  
71d3			;   On entry: A = Instruction byte to be written  
71d3			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
71d3 f5			fLCD_Inst:  PUSH AF  
71d4 f5			            PUSH AF  
71d5 cd e7 71		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
71d8 f1			            POP  AF  
71d9 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
71da 17			            RLA  
71db 17			            RLA  
71dc 17			            RLA  
71dd cd e7 71		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
71e0 3e 02		            LD   A, 2  
71e2 cd d1 72		            CALL LCDDelay       ;Delay 2 ms to complete   
71e5 f1			            POP  AF  
71e6 c9			            RET  
71e7			Wr4bits:   
71e7 f5					push af  
71e8 3a 00 fb				ld a, (display_lcde1e2)  
71eb fe 00				cp 0     ; e  
71ed 20 10				jr nz, .wea2	  
71ef f1					pop af  
71f0 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
71f2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
71f4 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
71f6 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
71f8 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
71fa cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
71fc d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
71fe c9			            RET  
71ff f1			.wea2:		pop af  
7200 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7202 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7204 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
7206 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
7208 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
720a cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
720c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
720e c9			            RET  
720f			  
720f			  
720f			; Write data to LCD  
720f			;   On entry: A = Data byte to be written  
720f			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
720f f5			fLCD_Data:  PUSH AF  
7210 f5			            PUSH AF  
7211 cd 23 72		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
7214 f1			            POP  AF  
7215 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7216 17			            RLA  
7217 17			            RLA  
7218 17			            RLA  
7219 cd 23 72		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
721c 3e 96		            LD   A, 150  
721e 3d			Wait:      DEC  A              ;Wait a while to allow data   
721f 20 fd		            JR   NZ, Wait      ;  write to complete  
7221 f1			            POP  AF  
7222 c9			            RET  
7223			Wr4bitsa:     
7223 f5					push af  
7224 3a 00 fb				ld a, (display_lcde1e2)  
7227 fe 00				cp 0     ; e1  
7229 20 16				jr nz, .we2	  
722b f1					pop af  
722c e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
722e cb d7		            SET  kLCDBitRS, A  
7230 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7232 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
7234 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
7236 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
7238 cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
723a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
723c cb 97		            RES  kLCDBitRS, A  
723e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7240 c9			            RET  
7241 f1			.we2:		pop af  
7242 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7244 cb d7		            SET  kLCDBitRS, A  
7246 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7248 cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
724a cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
724c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
724e cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
7250 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
7252 cb 97		            RES  kLCDBitRS, A  
7254 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7256 c9			            RET  
7257			  
7257			  
7257			; Position cursor to specified location  
7257			;   On entry: A = Cursor position  
7257			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7257 f5			fLCD_Pos:   PUSH AF  
7258					; at this point set the E1 or E2 flag depending on position  
7258			  
7258 c5					push bc  
7259			;		push af  
7259 06 00				ld b, 0  
725b 4f					ld c, a  
725c 3e 4f				ld a, kLCD_Line3-1  
725e b7			 		or a      ;clear carry flag  
725f 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
7260 38 04				jr c, .pe1  
7262			  
7262					; E selection  
7262 cb 80				res 0, b         ; bit 0 unset e  
7264			;		pop af    ; before line 3 so recover orig pos  
7264			;		ld c, a    ; save for poking back  
7264 18 06				jr .peset	          
7266			.pe1:          	; E2 selection  
7266 cb c0				set 0, b         ; bit 0 set e1  
7268 79					ld a, c  
7269 de 4f				sbc a, kLCD_Line3-1  
726b 4f					ld c, a	         ; save caculated offset  
726c			;		pop af     ; bin this original value now we have calculated form  
726c			  
726c			.peset:		; set bit  
726c 78					ld a, b  
726d 32 00 fb				ld (display_lcde1e2), a 	  
7270 79					ld a, c  
7271 c1					pop bc  
7272			  
7272 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
7274 cd d3 71		            CALL fLCD_Inst      ;Write instruction to LCD  
7277 f1			            POP  AF  
7278 c9			            RET  
7279			  
7279			  
7279			; Output text string to LCD  
7279			;   On entry: DE = Pointer to null terminated text string  
7279			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
7279 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
727a b7			            OR   A              ;Null terminator?  
727b c8			            RET  Z              ;Yes, so finished  
727c cd 0f 72		            CALL fLCD_Data      ;Write character to display  
727f 13			            INC  DE             ;Point to next character  
7280 18 f7		            JR   fLCD_Str       ;Repeat  
7282 c9					ret  
7283			  
7283			; Define custom character  
7283			;   On entry: A = Character number (0 to 7)  
7283			;             DE = Pointer to character bitmap data  
7283			;   On exit:  A = Next character number  
7283			;             DE = Next location following bitmap  
7283			;             BC HL IX IY I AF' BC' DE' HL' preserved  
7283			; Character is   
7283 c5			fLCD_Def:   PUSH BC  
7284 f5			            PUSH AF  
7285 07			            RLCA                ;Calculate location  
7286 07			            RLCA                ;  for bitmap data  
7287 07			            RLCA                ;  = 8 x CharacterNumber  
7288 f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
728a cd d3 71		            CALL fLCD_Inst      ;Write instruction to LCD  
728d 06 00		            LD   B, 0  
728f 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
7290 cd 0f 72		            CALL fLCD_Data      ;Write byte to display  
7293 13			            INC  DE             ;Point to next byte  
7294 04			            INC  B              ;Count bytes  
7295 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
7297 28 f6		            JR   Z, Loop       ;No, so repeat  
7299 f1			            POP  AF  
729a 3c			            INC  A              ;Increment character number  
729b c1			            POP  BC  
729c c9			            RET  
729d			  
729d			  
729d			; **********************************************************************  
729d			; **  Private functions  
729d			; **********************************************************************  
729d			  
729d			; Write function to LCD  
729d			;   On entry: A = Function byte to be written  
729d			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
729d 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
729f 18 02		            JR   WrFunc  
72a1 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
72a3 f5			WrFunc:     PUSH AF  
72a4 f5					push af  
72a5 3a 00 fb				ld a, (display_lcde1e2)  
72a8 fe 00				cp 0     ; e1  
72aa 20 0f				jr nz, .wfea2	  
72ac f1					pop af  
72ad d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
72af cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
72b1 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
72b3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
72b5 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
72b7 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
72b9 18 0d			jr .wfskip  
72bb f1			.wfea2:		pop af  
72bc d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
72be cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
72c0 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
72c2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
72c4 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
72c6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
72c8 3e 05		.wfskip:            LD  A, 5  
72ca cd d1 72		            CALL LCDDelay       ;Delay 5 ms to complete  
72cd f1			            POP  AF  
72ce c9			            RET  
72cf			  
72cf			  
72cf			; Delay in milliseconds  
72cf			;   On entry: A = Number of milliseconds delay  
72cf			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
72cf 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
72d1 d5			LCDDelay:   PUSH DE  
72d2 5f			            LD   E, A           ;Delay by 'A' ms  
72d3 16 00		            LD   D, 0  
72d5 cd d2 0c		            CALL aDelayInMS  
72d8 d1			            POP  DE  
72d9 c9			            RET  
72da			  
72da			  
72da			testlcd:  
72da 3e 00			ld a, kLCD_Line1  
72dc cd 57 72			call fLCD_Pos  
72df 06 28			ld b, 40  
72e1 11 0f 73			ld de, .ttext1  
72e4 cd a2 71			call write_len_string  
72e7			  
72e7 3e 28			ld a, kLCD_Line2  
72e9 cd 57 72			call fLCD_Pos  
72ec 06 28			ld b, 40  
72ee 11 38 73			ld de, .ttext2  
72f1 cd a2 71			call write_len_string  
72f4 3e 50			ld a, kLCD_Line3  
72f6 cd 57 72			call fLCD_Pos  
72f9 06 28			ld b, 40  
72fb 11 61 73			ld de, .ttext3  
72fe cd a2 71			call write_len_string  
7301 3e 78			ld a, kLCD_Line4  
7303 cd 57 72			call fLCD_Pos  
7306 06 28			ld b, 40  
7308 11 8a 73			ld de, .ttext4  
730b cd a2 71			call write_len_string  
730e			  
730e 76				halt  
730f			  
730f			  
730f .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
7338 .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
7361 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
738a .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
73b3			   
73b3			  
73b3			  
73b3			; eof  
73b3			  
# End of file firmware_lcd_4x40.asm
73b3			;include "firmware_lcd_4x20.asm" 
73b3			include "firmware_key_5x10.asm" 
73b3			; 5 x 10 decade counter scanner  
73b3			  
73b3			  
73b3			; TODO do cursor shape change for shift keys  
73b3			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
73b3			  
73b3			  
73b3			; bit mask for each scan column and row for teing the matrix  
73b3			  
73b3			  
73b3			key_init:  
73b3			  
73b3			; SCMonAPI functions used  
73b3			  
73b3			; Alphanumeric LCD functions used  
73b3			; no need to specify specific functions for this module  
73b3			  
73b3			  
73b3 3e cf		            LD   A, 11001111b  
73b5 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
73b7			;            LD   A, 00000000b  
73b7 3e 1f		            LD   A, 00011111b  
73b9 d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
73bb			  
73bb			  
73bb				; TODO Configure cursor shapes  
73bb			  
73bb				; Load cursor shapes   
73bb 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
73bd 11 cd 73		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
73c0 06 02		            LD   B, 2           ;Number of characters to define  
73c2 cd 83 72		.DefLoop:   CALL fLCD_Def       ;Define custom character  
73c5 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
73c7			  
73c7 3e 01				ld a, 1  
73c9 32 f6 fa			ld (cursor_shape),a  
73cc c9				ret  
73cd			  
73cd			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
73cd			; Up to 8 custom characters can be defined  
73cd			.cursor_shapes:      
73cd			;; Character 0x00 = Normal  
73cd 1f			            DB  11111b  
73ce 1f			            DB  11111b  
73cf 1f			            DB  11111b  
73d0 1f			            DB  11111b  
73d1 1f			            DB  11111b  
73d2 1f			            DB  11111b  
73d3 1f			            DB  11111b  
73d4 1f			            DB  11111b  
73d5			;; Character 0x01 = Modifier  
73d5 1f			            DB  11111b  
73d6 1b			            DB  11011b  
73d7 1b			            DB  11011b  
73d8 1b			            DB  11011b  
73d9 1b			            DB  11011b  
73da 1f			            DB  11111b  
73db 1b			            DB  11011b  
73dc 1f			            DB  11111b  
73dd			  
73dd			  
73dd			  
73dd			  
73dd			; Display custom character 0  
73dd			;            LD   A, kLCD_Line1+14  
73dd			;            CALL fLCD_Pos       ;Position cursor to location in A  
73dd			;            LD   A, 0  
73dd			;            CALL fLCD_Data      ;Write character in A at cursor  
73dd			  
73dd			; Display custom character 1  
73dd			;            LD   A, kLCD_Line2+14  
73dd			;            CALL fLCD_Pos      ;Position cursor to location in A  
73dd			;            LD   A, 1  
73dd			;            CALL fLCD_Data     ;Write character in A at cursor  
73dd			  
73dd			; keyboard scanning   
73dd			  
73dd			; character in from keyboard  
73dd			  
73dd			; mapping for the pcb layout  
73dd			  
73dd			.matrix_to_char:  
73dd .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
73e8 .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
73f3 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
73fe 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7409 .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
7414			.matrix_to_shift:  
7414			  
7414 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
741f .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
742a 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
7435 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
7440 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
744b			  
744b			.matrix_to_symbolshift:  
744b			  
744b fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7456 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
7461 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
746c			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
746c 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
7477 .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
7482			  
7482			  
7482			  
7482			; mapping for a simple straight through breadboard layout  
7482			  
7482			;.matrix_to_char:  
7482			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7482			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
7482			;		db "asdfghjkl",KEY_CR,0  
7482			;		db "qwertyuiop",0  
7482			;		 db "1234567890",0  
7482			;.matrix_to_shift:  
7482			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
7482			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
7482			;		db "ASDFGHJKL",KEY_CR,0  
7482			;		db "QWERTYUIOP",0  
7482			;		 db "!",'"',"#$%^&*()",0  
7482			;.matrix_to_symbolshift:  
7482			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7482			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
7482			;		db "_?*fghjk=",KEY_CR,0  
7482			;		db "-/+*[]{}@#",0  
7482			;		 db "1234567890",0  
7482			  
7482			;.matrix_to_char: db "D#0*C987B654A321"  
7482			  
7482			  
7482				  
7482			  
7482			; add cin and cin_wait  
7482			  
7482 cd 93 74		cin_wait: 	call cin  
7485						if DEBUG_KEYCINWAIT  
7485							push af  
7485							  
7485							ld hl,key_repeat_ct  
7485							ld (hl),a  
7485							inc hl  
7485							call hexout  
7485							ld hl,key_repeat_ct+3  
7485							ld a,0  
7485							ld (hl),a  
7485			  
7485							    LD   A, kLCD_Line1+11  
7485							    CALL fLCD_Pos       ;Position cursor to location in A  
7485							    LD   DE, key_repeat_ct  
7485							    ;LD   DE, MsgHello  
7485							    CALL fLCD_Str       ;Display string pointed to by DE  
7485			  
7485			  
7485			  
7485							pop af  
7485						endif  
7485 fe 00			cp 0  
7487 28 f9			jr z, cin_wait   ; block until key press  
7489			  
7489							if DEBUG_KEYCINWAIT  
7489								push af  
7489			  
7489								ld a, 'A'	  
7489								ld hl,key_repeat_ct  
7489								ld (hl),a  
7489								inc hl  
7489								ld a,0  
7489								ld (hl),a  
7489			  
7489								    LD   A, kLCD_Line2+11  
7489								    CALL fLCD_Pos       ;Position cursor to location in A  
7489								    LD   DE, key_repeat_ct  
7489								    ;LD   DE, MsgHello  
7489								    CALL fLCD_Str       ;Display string pointed to by DE  
7489			  
7489							call delay500ms  
7489			  
7489								pop af  
7489							endif  
7489 f5				push af   ; save key pressed  
748a			  
748a			.cin_wait1:	  
748a							if DEBUG_KEYCINWAIT  
748a								push af  
748a			  
748a								ld a, 'b'	  
748a								ld hl,key_repeat_ct  
748a								ld (hl),a  
748a								inc hl  
748a								ld a,0  
748a								ld (hl),a  
748a			  
748a								    LD   A, kLCD_Line2+11  
748a								    CALL fLCD_Pos       ;Position cursor to location in A  
748a								    LD   DE, key_repeat_ct  
748a								    ;LD   DE, MsgHello  
748a								    CALL fLCD_Str       ;Display string pointed to by DE  
748a			  
748a			  
748a							call delay500ms  
748a			  
748a								pop af  
748a							endif  
748a			  
748a cd 93 74		call cin  
748d fe 00			cp 0  
748f 20 f9			jr nz, .cin_wait1  	; wait for key release  
7491			if DEBUG_KEYCINWAIT  
7491				push af  
7491			  
7491				ld a, '3'	  
7491				ld hl,key_repeat_ct  
7491				ld (hl),a  
7491				inc hl  
7491				ld a,0  
7491				ld (hl),a  
7491			  
7491			            LD   A, kLCD_Line2+11  
7491			            CALL fLCD_Pos       ;Position cursor to location in A  
7491			            LD   DE, key_repeat_ct  
7491			            ;LD   DE, MsgHello  
7491			            CALL fLCD_Str       ;Display string pointed to by DE  
7491			  
7491			  
7491			call delay500ms  
7491			  
7491				pop af  
7491			endif  
7491			  
7491 f1				pop af   ; get key  
7492 c9				ret  
7493			  
7493			  
7493 cd a7 74		cin: 	call .mtoc  
7496			  
7496			if DEBUG_KEYCIN  
7496				push af  
7496				  
7496				ld hl,key_repeat_ct  
7496				ld (hl),a  
7496				inc hl  
7496				call hexout  
7496				ld hl,key_repeat_ct+3  
7496				ld a,0  
7496				ld (hl),a  
7496			  
7496			            LD   A, kLCD_Line3+15  
7496			            CALL fLCD_Pos       ;Position cursor to location in A  
7496			            LD   DE, key_repeat_ct  
7496			            ;LD   DE, MsgHello  
7496			            CALL fLCD_Str       ;Display string pointed to by DE  
7496			  
7496			  
7496			call delay500ms  
7496			  
7496				pop af  
7496			endif  
7496			  
7496			  
7496				; no key held  
7496 fe 00			cp 0  
7498 c8				ret z  
7499			  
7499			if DEBUG_KEYCIN  
7499				push af  
7499			  
7499				ld a, '1'	  
7499				ld hl,key_repeat_ct  
7499				ld (hl),a  
7499				inc hl  
7499				ld a,0  
7499				ld (hl),a  
7499			  
7499			            LD   A, kLCD_Line4+15  
7499			            CALL fLCD_Pos       ;Position cursor to location in A  
7499			            LD   DE, key_repeat_ct  
7499			            ;LD   DE, MsgHello  
7499			            CALL fLCD_Str       ;Display string pointed to by DE  
7499			  
7499			  
7499			call delay500ms  
7499			  
7499				pop af  
7499			endif  
7499			  
7499				; stop key bounce  
7499			  
7499 32 c6 fd			ld (key_held),a		 ; save it  
749c 47				ld b, a  
749d			  
749d c5			.cina1:	push bc  
749e			if DEBUG_KEYCIN  
749e				push af  
749e			  
749e				ld hl,key_repeat_ct  
749e				inc hl  
749e				call hexout  
749e				ld hl,key_repeat_ct+3  
749e				ld a,0  
749e				ld (hl),a  
749e				ld hl,key_repeat_ct  
749e				ld a, '2'	  
749e				ld (hl),a  
749e			  
749e			            LD   A, kLCD_Line4+15  
749e			            CALL fLCD_Pos       ;Position cursor to location in A  
749e			            LD   DE, key_repeat_ct  
749e			            ;LD   DE, MsgHello  
749e			            CALL fLCD_Str       ;Display string pointed to by DE  
749e			  
749e				pop af  
749e			endif  
749e cd a7 74			call .mtoc  
74a1 c1				pop bc  
74a2 b8				cp b  
74a3 28 f8			jr z, .cina1  
74a5 78				ld a,b		  
74a6			if DEBUG_KEYCIN  
74a6				push af  
74a6			  
74a6				ld hl,key_repeat_ct  
74a6				inc hl  
74a6				call hexout  
74a6				ld hl,key_repeat_ct+3  
74a6				ld a,0  
74a6				ld (hl),a  
74a6				ld hl,key_repeat_ct  
74a6				ld a, '3'	  
74a6				ld (hl),a  
74a6			  
74a6			            LD   A, kLCD_Line4+15  
74a6			            CALL fLCD_Pos       ;Position cursor to location in A  
74a6			            LD   DE, key_repeat_ct  
74a6			            ;LD   DE, MsgHello  
74a6			            CALL fLCD_Str       ;Display string pointed to by DE  
74a6			  
74a6				pop af  
74a6			endif  
74a6 c9				ret  
74a7			  
74a7			; detect keyboard modifier key press and apply new overlay to the face key held  
74a7			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
74a7			  
74a7			;.cin_map_modifier:   
74a7			;	ld a, (hl)  
74a7			;	and 255  
74a7			;	ret NZ		; modifier key not flagged  
74a7			;  
74a7			;	; get key face  
74a7			;  
74a7			;	ld b,(key_face_held)  
74a7			;  
74a7			;	ld b, key_cols * key_rows  
74a7			;  
74a7			;	push de  
74a7			;	pop hl  
74a7			;  
74a7			;.mmod1: ld a,(hl)   ; get map test  
74a7			;	cp b  
74a7			;	jr z, .mmod2  
74a7			;  
74a7			;  
74a7			;  
74a7			;.mmod2: inc hl    ;   
74a7			;  
74a7			;	  
74a7			;  
74a7			;	  
74a7			;  
74a7			;	ld hl,key_actual_pressed  
74a7			;	ld (hl),a,  
74a7			;	ret  
74a7			  
74a7			; map matrix key held to char on face of key  
74a7			  
74a7			.mtoc:  
74a7			  
74a7			; test decade counter strobes  
74a7			  
74a7			;.decadetest1:  
74a7			  
74a7			; reset counter  
74a7			;ld a, 128  
74a7			;out (portbdata),a  
74a7			  
74a7			  
74a7			;ld b, 5  
74a7			;.dec1:  
74a7			;ld a, 0  
74a7			;out (portbdata),a  
74a7			;call delay1s  
74a7			  
74a7			;ld a, 32  
74a7			;out (portbdata),a  
74a7			;call delay1s  
74a7			;call delay1s  
74a7			;call delay1s  
74a7			;  
74a7			;ld a, 64+32  
74a7			;out (portbdata),a  
74a7			;call delay1s  
74a7			;;djnz .dec1  
74a7			;  
74a7			;jp .decadetest1  
74a7			  
74a7			  
74a7			  
74a7			  
74a7			  
74a7			  
74a7			  
74a7			  
74a7			  
74a7			  
74a7				; scan keyboard matrix and generate raw scan map  
74a7 cd 3a 75			call matrix  
74aa			  
74aa				; reuse c bit 0 left modifer button - ie shift  
74aa			        ; reuse c bit 1 for right modifer button - ie symbol shift  
74aa				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
74aa			  
74aa 0e 00			ld c, 0  
74ac			  
74ac				; TODO set flags for modifer key presses   
74ac				; TODO do a search for modifer key...  
74ac			  
74ac				;ld hl,keyscan_table_row4  
74ac 21 25 fe			ld hl,keyscan_table_row2  
74af			  
74af 7e				ld a, (hl)  
74b0 fe 23			cp '#'  
74b2 20 07			jr nz, .nextmodcheck  
74b4 cb c1			set 0, c  
74b6 21 14 74			ld hl, .matrix_to_shift  
74b9 18 21			jr .dokeymap  
74bb				; TODO for now igonre  
74bb			.nextmodcheck:  
74bb 21 1a fe			ld hl,keyscan_table_row3  
74be			  
74be 7e				ld a, (hl)  
74bf fe 23			cp '#'  
74c1 20 07			jr nz, .nextmodcheck2  
74c3 cb c9			set 1, c   
74c5 21 4b 74			ld hl, .matrix_to_symbolshift  
74c8 18 12			jr .dokeymap  
74ca			.nextmodcheck2:  
74ca 21 2e fe			ld hl,keyscan_table_row2+9    ; right shift  
74cd			  
74cd 7e				ld a, (hl)  
74ce fe 23			cp '#'  
74d0 20 07			jr nz, .donemodcheck  
74d2 cb c9			set 1, c   
74d4 21 14 74			ld hl, .matrix_to_shift  
74d7 18 03			jr .dokeymap  
74d9			  
74d9				; no modifer found so just map to normal keys  
74d9				; get mtoc map matrix to respective keys  
74d9			;	ld hl, .matrix_to_char  
74d9			;	ld hl, .matrix_to_char  
74d9			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
74d9			;	ld a, KEY_SHIFT  
74d9			;	call findchar  
74d9			;  
74d9			;	; got offset to key modifer in b  
74d9			;  
74d9			;	ld hl,keyscan_table_row5  
74d9			;  
74d9			;	ld a,b  
74d9			;	call addatohl  
74d9			;	ld a,(hl)  
74d9			;  
74d9			;	cp '#'  
74d9			;	jr nz, .nextmodcheck  
74d9			;	set 0, c  
74d9			;	ld hl, .matrix_to_char  
74d9			;	jr .dokeymap  
74d9			;	; TODO for now igonre  
74d9			;.nextmodcheck:  
74d9			;	ld hl, .matrix_to_symbolshift  
74d9			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
74d9			;	ld a, KEY_SYMBOLSHIFT  
74d9			;	call findchar  
74d9			;  
74d9			;  
74d9			;	; got offset to key modifer in b  
74d9			;  
74d9			;	ld hl,keyscan_table_row5  
74d9			;  
74d9			;	ld a,b  
74d9			;	call addatohl  
74d9			;	ld a,(hl)  
74d9			;  
74d9			;	cp '#'  
74d9			;	jr nz, .donemodcheck  
74d9			;	set 1, c   
74d9			;	ld hl, .matrix_to_symbolshift  
74d9			;	jr .dokeymap  
74d9			  
74d9			  
74d9			  
74d9			.donemodcheck:  
74d9				; no modifer found so just map to normal keys  
74d9				; get mtoc map matrix to respective keys  
74d9 21 dd 73			ld hl, .matrix_to_char  
74dc			  
74dc			.dokeymap:  
74dc				;ld (key_fa), c   
74dc cd f5 74			call .mapkeys  
74df			  
74df			  
74df			if DEBUG_KEY  
74df			  
74df			; Display text on first line  
74df			            LD   A, kLCD_Line1  
74df			            CALL fLCD_Pos       ;Position cursor to location in A  
74df			            LD   DE, keyscan_table_row1  
74df			            ;LD   DE, MsgHello  
74df			            CALL fLCD_Str       ;Display string pointed to by DE  
74df			  
74df			; Display text on second line  
74df			            LD   A, kLCD_Line2  
74df			            CALL fLCD_Pos       ;Position cursor to location in A  
74df			            LD   DE, keyscan_table_row2  
74df			            CALL fLCD_Str       ;Display string pointed to by DE  
74df			            LD   A, kLCD_Line3  
74df			            CALL fLCD_Pos       ;Position cursor to location in A  
74df			            LD   DE, keyscan_table_row3  
74df			            CALL fLCD_Str       ;Display string pointed to by DE  
74df			            LD   A, kLCD_Line4  
74df			            CALL fLCD_Pos       ;Position cursor to location in A  
74df			            LD   DE, keyscan_table_row4  
74df			            CALL fLCD_Str       ;Display string pointed to by DE  
74df			            LD   A, kLCD_Line1+10  
74df			            CALL fLCD_Pos       ;Position cursor to location in A  
74df			            LD   DE, keyscan_table_row5  
74df			            CALL fLCD_Str       ;Display string pointed to by DE  
74df			  
74df				;call delay250ms  
74df			endif  
74df			;	jp testkey  
74df			  
74df			; get first char reported  
74df			  
74df 21 04 fe			ld hl,keyscan_table_row5  
74e2			  
74e2				;ld b, 46   ; 30 keys to remap + 8 nulls   
74e2 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
74e4			.findkey:  
74e4 7e				ld a,(hl)  
74e5 fe 00			cp 0  
74e7 28 04			jr z, .nextkey  
74e9 fe 7e			cp KEY_MATRIX_NO_PRESS  
74eb 20 06			jr nz, .foundkey  
74ed			.nextkey:  
74ed 23				inc hl  
74ee 10 f4			djnz .findkey  
74f0 3e 00			ld a,0  
74f2 c9				ret  
74f3			.foundkey:  
74f3 7e				ld a,(hl)  
74f4 c9				ret  
74f5				  
74f5			  
74f5			; convert the raw key map given hl for destination key  
74f5			.mapkeys:  
74f5 11 04 fe			ld de,keyscan_table_row5  
74f8			  
74f8 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
74fa			.remap:  
74fa 1a				ld a,(de)  
74fb fe 23			cp '#'  
74fd 20 02			jr nz, .remapnext  
74ff				;CALLMONITOR  
74ff 7e				ld a,(hl)  
7500 12				ld (de),a  
7501			  
7501			  
7501			  
7501			.remapnext:  
7501 23				inc hl  
7502 13				inc de  
7503 10 f5			djnz .remap  
7505				  
7505 c9				ret  
7506			  
7506			  
7506			  
7506			.mtocold2:  
7506			  
7506			;	; flag if key D is held down and remove from reporting  
7506			;	ld bc, .key_map_fd    
7506			;	ld hl, keyscan_table  
7506			;	ld de, key_fd  
7506			;	call .key_shift_hold  
7506			;	cp 255  
7506			;	jr z, .cinmap  
7506			;	; flag if key C is held down and remove from reporting  
7506			;	ld bc, .key_map_fc    
7506			;	ld hl, keyscan_table+key_cols  
7506			;	ld de, key_fc  
7506			;	call .key_shift_hold  
7506			;	cp 255  
7506			;	jr z, .cinmap  
7506			;	; flag if key B is held down and remove from reporting  
7506			;	ld bc, .key_map_fb    
7506			;	ld hl, keyscan_table+(key_cols*2)  
7506			;	ld de, key_fb  
7506			;	call .key_shift_hold  
7506			;	cp 255  
7506			;	jr z, .cinmap  
7506			;	; flag if key A is held down and remove from reporting  
7506			;	ld bc, .key_map_fa    
7506			;	ld hl, keyscan_table+(key_cols*3)  
7506			;	ld de, key_fa  
7506			;	call .key_shift_hold  
7506			;	cp 255  
7506			;	jr z, .cinmap  
7506			  
7506 11 dd 73			ld de, .matrix_to_char  
7509			  
7509			  
7509			.cinmap1:   
7509				if DEBUG_KEY  
7509			            LD   A, kLCD_Line4  
7509			            CALL fLCD_Pos       ;Position cursor to location in A  
7509					push de  
7509			            LD   DE, keyscan_table  
7509			            CALL fLCD_Str       ;Display string pointed to by DE  
7509					pop de  
7509				endif  
7509			  
7509				; scan key matrix table for any held key  
7509			  
7509				; de holds either the default matrix or one selected above  
7509			  
7509 21 d1 fd			ld hl, keyscan_table  
750c 06 32			ld b,key_cols*key_rows  
750e			  
750e 7e			.cin11:	ld a,(hl)  
750f fe 23			cp '#'  
7511 28 08			jr z, .cinhit1  
7513 23				inc hl  
7514 13				inc de  
7515 05				dec b  
7516 20 f6			jr nz, .cin11  
7518				; no key found held  
7518 3e 00			ld a,0  
751a c9				ret  
751b d5			.cinhit1: push de  
751c e1				pop hl  
751d 7e				ld a,(hl)  
751e c9				ret  
751f			  
751f			; flag a control key is held   
751f			; hl is key pin, de is flag indicator  
751f			  
751f			.key_shift_hold1:  
751f c5				push bc  
7520 3e 01			ld a, 1  
7522 32 f6 fa			ld (cursor_shape),a  
7525 06 00			ld b, 0  
7527 7e				ld a, (hl)  
7528 fe 2e			cp '.'  
752a 28 0a			jr z, .key_shift11  
752c 06 ff			ld b, 255  
752e 3e 2b			ld a, '+'    ; hide key from later scans  
7530 77				ld (hl),a  
7531 3e 02			ld a, 2  
7533 32 f6 fa			ld (cursor_shape),a  
7536			.key_shift11:  
7536				; write flag indicator  
7536 78				ld a,b  
7537 12				ld (de),a  
7538			  
7538 d1				pop de    ; de now holds the key map ptr  
7539 c9				ret  
753a			  
753a				  
753a			  
753a			; scans keyboard matrix and flags key press in memory array	  
753a				  
753a			matrix:  
753a				;call matrix  
753a				; TODO optimise the code....  
753a			  
753a			  
753a			;ld hl, keyscan_table_row1  
753a			;ld de, keyscan_table_row1+1  
753a			;ld bc,46  
753a			;ld a,KEY_MATRIX_NO_PRESS  
753a			;ldir  
753a			  
753a			  
753a			  
753a			; reset counter  
753a 3e 80		ld a, 128  
753c d3 c1		out (portbdata),a  
753e			  
753e 06 0a		ld b, 10  
7540 0e 00		ld c, 0       ; current clock toggle  
7542			  
7542			.colscan:  
7542			  
7542			; set current column  
7542			; disable clock enable and set clock low  
7542			  
7542			;ld a, 0  
7542			;out (portbdata),a  
7542			  
7542			; For each column scan for switches  
7542			  
7542 c5			push bc  
7543 21 c7 fd		ld hl, keyscan_scancol  
7546 cd 4f 76		call .rowscan  
7549 c1			pop bc  
754a			  
754a			  
754a			; get back current column  
754a			  
754a			; translate the row scan  
754a			  
754a			;   
754a			; row 1  
754a			  
754a 78			ld a,b  
754b			  
754b 21 3a fe		LD   hl, keyscan_table_row1+10  
754e			  
754e cd f0 0f		call subafromhl  
7551			;call addatohl  
7551			  
7551 11 c7 fd		ld de, keyscan_scancol  
7554			  
7554 1a			ld a,(de)  
7555 77			ld (hl),a  
7556			  
7556			  
7556			  
7556			  
7556			; row 2  
7556			  
7556 78			ld a,b  
7557			  
7557 21 2f fe		LD   hl, keyscan_table_row2+10  
755a			  
755a			;call addatohl  
755a cd f0 0f		call subafromhl  
755d			  
755d			  
755d 11 c8 fd		ld de, keyscan_scancol+1  
7560			  
7560 1a			ld a,(de)  
7561 77			ld (hl),a  
7562			  
7562			  
7562			; row 3  
7562			  
7562 78			ld a,b  
7563			  
7563 21 24 fe		LD   hl, keyscan_table_row3+10  
7566			  
7566			;call addatohl  
7566 cd f0 0f		call subafromhl  
7569			  
7569 11 c9 fd		ld de, keyscan_scancol+2  
756c			  
756c 1a			ld a,(de)  
756d 77			ld (hl),a  
756e			  
756e			  
756e			  
756e			; row 4  
756e			  
756e 78			ld a,b  
756f			  
756f 21 19 fe		LD   hl, keyscan_table_row4+10  
7572			  
7572			;call addatohl  
7572 cd f0 0f		call subafromhl  
7575			  
7575 11 ca fd		ld de, keyscan_scancol+3  
7578			  
7578 1a			ld a,(de)  
7579 77			ld (hl),a  
757a			  
757a			; row 5  
757a			  
757a 78			ld a,b  
757b			  
757b 21 0e fe		LD   hl, keyscan_table_row5+10  
757e			  
757e			;call addatohl  
757e cd f0 0f		call subafromhl  
7581			  
7581 11 cb fd		ld de, keyscan_scancol+4  
7584			  
7584 1a			ld a,(de)  
7585 77			ld (hl),a  
7586			  
7586			; handshake next column  
7586			  
7586			  
7586 3e 40		ld a, 64  
7588 d3 c1		out (portbdata),a  
758a			  
758a 3e 00		ld a, 0  
758c d3 c1		out (portbdata),a  
758e			  
758e			; toggle clk and move to next column  
758e			;ld a, 64  
758e			;cp c  
758e			;  
758e			;jr z, .coltoglow  
758e			;ld c, a  
758e			;jr .coltog  
758e			;.coltoglow:  
758e			;ld c, 0  
758e			;.coltog:  
758e			;ld a, c  
758e			;out (portbdata),a  
758e			  
758e 10 b2		djnz .colscan  
7590			  
7590 3e 0a		ld a,10  
7592 21 30 fe		LD   hl, keyscan_table_row1  
7595 cd de 0f		call addatohl  
7598 3e 00		ld a, 0  
759a 77			ld (hl), a  
759b			  
759b			  
759b 3e 0a		ld a,10  
759d 21 25 fe		LD   hl, keyscan_table_row2  
75a0 cd de 0f		call addatohl  
75a3 3e 00		ld a, 0  
75a5 77			ld (hl), a  
75a6			  
75a6 3e 0a		ld a,10  
75a8 21 1a fe		LD   hl, keyscan_table_row3  
75ab cd de 0f		call addatohl  
75ae 3e 00		ld a, 0  
75b0 77			ld (hl), a  
75b1			  
75b1 3e 0a		ld a,10  
75b3 21 0f fe		LD   hl, keyscan_table_row4  
75b6 cd de 0f		call addatohl  
75b9 3e 00		ld a, 0  
75bb 77			ld (hl), a  
75bc			  
75bc 3e 0a		ld a,10  
75be 21 04 fe		LD   hl, keyscan_table_row5  
75c1 cd de 0f		call addatohl  
75c4 3e 00		ld a, 0  
75c6 77			ld (hl), a  
75c7			  
75c7			if DEBUG_KEY_MATRIX  
75c7			  
75c7			; Display text on first line  
75c7			            LD   A, kLCD_Line1  
75c7			            CALL fLCD_Pos       ;Position cursor to location in A  
75c7			            LD   DE, keyscan_table_row1  
75c7			            ;LD   DE, MsgHello  
75c7			            CALL fLCD_Str       ;Display string pointed to by DE  
75c7			  
75c7			; Display text on second line  
75c7			            LD   A, kLCD_Line2  
75c7			            CALL fLCD_Pos       ;Position cursor to location in A  
75c7			            LD   DE, keyscan_table_row2  
75c7			            CALL fLCD_Str       ;Display string pointed to by DE  
75c7			            LD   A, kLCD_Line3  
75c7			            CALL fLCD_Pos       ;Position cursor to location in A  
75c7			            LD   DE, keyscan_table_row3  
75c7			            CALL fLCD_Str       ;Display string pointed to by DE  
75c7			            LD   A, kLCD_Line4  
75c7			            CALL fLCD_Pos       ;Position cursor to location in A  
75c7			            LD   DE, keyscan_table_row4  
75c7			            CALL fLCD_Str       ;Display string pointed to by DE  
75c7			            LD   A, kLCD_Line4+10  
75c7			            CALL fLCD_Pos       ;Position cursor to location in A  
75c7			            LD   DE, keyscan_table_row5  
75c7			            CALL fLCD_Str       ;Display string pointed to by DE  
75c7			  
75c7			;call delay250ms  
75c7				jp matrix  
75c7			endif  
75c7 c9			ret  
75c8			  
75c8			; using decade counter....  
75c8			  
75c8			  
75c8			; TODO reset decade counter to start of scan  
75c8			  
75c8			; reset 15  
75c8			; clock 14  
75c8			; ce 13  
75c8			  
75c8			; 1 - q5  
75c8			; 2 - q1  
75c8			; 3 - q0  
75c8			; 4 - q2  
75c8			; 5 - q6  
75c8			; 6 - q7  
75c8			; 7 - q3  
75c8			; 8 - vss  
75c8			; 9 - q8  
75c8			; 10 - q4  
75c8			; 11 - q9  
75c8			; 12 - cout  
75c8			; 16 - vdd  
75c8			  
75c8			; clock      ce       reset     output  
75c8			; 0          x        0         n  
75c8			; x          1        0         n  
75c8			; x          x        1         q0  
75c8			; rising     0        0         n+1  
75c8			; falling    x        0         n  
75c8			; x          rising   0         n  
75c8			; 1          falling  0         x+1  
75c8			;  
75c8			; x = dont care, if n < 5 carry = 1 otherwise 0  
75c8			  
75c8			;   
75c8			; reset   
75c8			; 13=0, 14=0, 15=1 .. 15=0  
75c8			;  
75c8			; handshake line  
75c8			; 14=1.... read line 14=0  
75c8			  
75c8			  
75c8			  
75c8			  
75c8			  
75c8			; TODO hand shake clock for next column scan  
75c8			; TODO detect each row  
75c8			  
75c8			  
75c8			  
75c8			  
75c8			; reset 128  
75c8			; clock 64  
75c8			; ce 32  
75c8			  
75c8			  
75c8			.cyclestart:  
75c8			  
75c8			; reset counter  
75c8 3e 80		ld a, 128  
75ca d3 c1		out (portbdata),a  
75cc			  
75cc			; loop leds  
75cc 06 0a		ld b,10  
75ce			  
75ce			.cycle1:  
75ce c5			push bc  
75cf 3e 00		ld a, 0  
75d1 d3 c1		out (portbdata),a  
75d3 cd e1 0c		call delay250ms  
75d6			  
75d6 3e 40		ld a, 64  
75d8 d3 c1		out (portbdata),a  
75da cd e1 0c		call delay250ms  
75dd			  
75dd 3e 00		ld a, 0  
75df d3 c1		out (portbdata),a  
75e1 cd e1 0c		call delay250ms  
75e4			  
75e4 c1			pop bc  
75e5 10 e7		djnz .cycle1  
75e7			  
75e7			  
75e7 18 df		jr .cyclestart  
75e9			  
75e9			  
75e9			  
75e9			  
75e9			  
75e9			  
75e9			  
75e9			  
75e9			  
75e9			; map matrix key held to char on face of key  
75e9			  
75e9			;.mtocold:  
75e9			;  
75e9			;  
75e9			;; reset counter  
75e9			;ld a, 128  
75e9			;out (portbdata),a  
75e9			;  
75e9			;  
75e9			;; scan keyboard row 1  
75e9			;ld a, 0  
75e9			;out (portbdata),a  
75e9			;;ld a, 64  
75e9			;;out (portbdata),a  
75e9			;  
75e9			;  
75e9			;	ld a, 128  
75e9			;	ld hl, keyscan_table  
75e9			;	call .rowscan  
75e9			;  
75e9			;;ld a, 0  
75e9			;;out (portbdata),a  
75e9			;ld a, 64  
75e9			;out (portbdata),a  
75e9			;  
75e9			;	ld a, 64  
75e9			;	ld hl, keyscan_table+key_cols  
75e9			;	call .rowscan  
75e9			;  
75e9			;ld a, 0  
75e9			;out (portbdata),a  
75e9			;;ld a, 64  
75e9			;;out (portbdata),a  
75e9			;	ld a, 32  
75e9			;	ld hl, keyscan_table+(key_cols*2)  
75e9			;	call .rowscan  
75e9			;  
75e9			;  
75e9			;;ld a, 0  
75e9			;;out (portbdata),a  
75e9			;ld a, 64  
75e9			;out (portbdata),a  
75e9			;  
75e9			;	ld a, 16  
75e9			;	ld hl, keyscan_table+(key_cols*3)  
75e9			;	call .rowscan  
75e9			;  
75e9			;  
75e9			;	; flag if key D is held down and remove from reporting  
75e9			;	ld bc, .key_map_fd    
75e9			;	ld hl, keyscan_table  
75e9			;	ld de, key_fd  
75e9			;	call .key_shift_hold  
75e9			;	cp 255  
75e9			;	jr z, .cinmap  
75e9			;	; flag if key C is held down and remove from reporting  
75e9			;	ld bc, .key_map_fc    
75e9			;	ld hl, keyscan_table+key_cols  
75e9			;	ld de, key_fc  
75e9			;	call .key_shift_hold  
75e9			;	cp 255  
75e9			;	jr z, .cinmap  
75e9			;	; flag if key B is held down and remove from reporting  
75e9			;	ld bc, .key_map_fb    
75e9			;	ld hl, keyscan_table+(key_cols*2)  
75e9			;	ld de, key_fb  
75e9			;	call .key_shift_hold  
75e9			;	cp 255  
75e9			;	jr z, .cinmap  
75e9			;	; flag if key A is held down and remove from reporting  
75e9			;	ld bc, .key_map_fa    
75e9			;	ld hl, keyscan_table+(key_cols*3)  
75e9			;	ld de, key_fa  
75e9			;	call .key_shift_hold  
75e9			;	cp 255  
75e9			;	jr z, .cinmap  
75e9			;  
75e9			;	ld de, .matrix_to_char  
75e9			;  
75e9			;  
75e9			;.cinmap:   
75e9			;	if DEBUG_KEY  
75e9			;            LD   A, kLCD_Line4  
75e9			;            CALL fLCD_Pos       ;Position cursor to location in A  
75e9			;		push de  
75e9			;            LD   DE, keyscan_table  
75e9			;            CALL fLCD_Str       ;Display string pointed to by DE  
75e9			;		pop de  
75e9			;	endif  
75e9			  
75e9				; scan key matrix table for any held key  
75e9			  
75e9				; de holds either the default matrix or one selected above  
75e9			  
75e9			;	ld hl, keyscan_table  
75e9			;	ld b,key_cols*key_rows  
75e9			;  
75e9			;.cin1:	ld a,(hl)  
75e9			;	cp '#'  
75e9			;	jr z, .cinhit  
75e9			;	inc hl  
75e9			;	inc de  
75e9			;	dec b  
75e9			;	jr nz, .cin1  
75e9			;	; no key found held  
75e9			;	ld a,0  
75e9			;	ret  
75e9			;.cinhit: push de  
75e9			;	pop hl  
75e9			;	ld a,(hl)  
75e9			;	ret  
75e9			  
75e9			; flag a control key is held   
75e9			; hl is key pin, de is flag indicator  
75e9			  
75e9			;.key_shift_hold:  
75e9			;	push bc  
75e9			;	ld a, 1  
75e9			;	ld (cursor_shape),a  
75e9			;	ld b, 0  
75e9			;	ld a, (hl)  
75e9			;	cp '.'  
75e9			;	jr z, .key_shift1  
75e9			;	ld b, 255  
75e9			;	ld a, '+'    ; hide key from later scans  
75e9			;	ld (hl),a  
75e9			;	ld a, 2  
75e9			;	ld (cursor_shape),a  
75e9			;.key_shift1:  
75e9			;	; write flag indicator  
75e9			;	ld a,b  
75e9			;	ld (de),a  
75e9			;  
75e9			;	pop de    ; de now holds the key map ptr  
75e9			;	ret  
75e9			  
75e9				  
75e9				  
75e9			  
75e9			  
75e9			  
75e9			  
75e9			  
75e9			  
75e9			  
75e9			  
75e9			  
75e9			  
75e9			  
75e9			;	push hl  
75e9			;	push de  
75e9			;	push bc  
75e9			;	call keyscan  
75e9			;	; map key matrix to ascii value of key face  
75e9			;  
75e9			;	ld hl, key_face_map  
75e9			;	ld de, keyscan_table  
75e9			;  
75e9			;	; get how many keys to look at  
75e9			;	ld b, keyscan_table_len  
75e9			;	  
75e9			;  
75e9			;	; at this stage fall out on first key hit  
75e9			;	; TODO handle multiple key press  
75e9			;  
75e9			;map1:	ld a,(hl)  
75e9			;	cp '#'  
75e9			;	jr z, keyhit  
75e9			;	inc hl  
75e9			;	inc de  
75e9			;	dec b  
75e9			;	jr nz, map1  
75e9			;nohit:	ld a, 0  
75e9			;	jr keydone  
75e9			;keyhit: push de  
75e9			;	pop hl  
75e9			;	ld a,(hl)  
75e9			;keydone:  
75e9			;	push bc  
75e9			;	push de  
75e9			; 	push hl  
75e9			;	ret   
75e9			;  
75e9			  
75e9			  
75e9			  
75e9			  
75e9			; scan physical key matrix  
75e9			  
75e9			  
75e9			;keyscan:  
75e9			;  
75e9			;; for each key_row use keyscanr bit mask for out  
75e9			;; then read in for keyscanc bitmask  
75e9			;; save result of row scan to keyscantable  
75e9			;  
75e9			;; scan keyboard row 1  
75e9			;  
75e9			;	ld b, key_rows  
75e9			;	ld hl, key_scanr  
75e9			;	ld de, keyscan_table  
75e9			;  
75e9			;rowloop:  
75e9			;  
75e9			;	ld a,(hl)		; out bit mask to energise keyboard row  
75e9			;	call rowscan  
75e9			;	inc hl  
75e9			;	dec b  
75e9			;	jr nz, rowloop  
75e9			;  
75e9			;	ret  
75e9			;  
75e9			;  
75e9			;; pass a out bitmask, b row number  
75e9			;arowscan:   
75e9			;	push bc  
75e9			;  
75e9			;	ld d, b  
75e9			;  
75e9			;	; calculate buffer location for this row  
75e9			;  
75e9			;	ld hl, keyscan_table	  
75e9			;kbufr:  ld e, key_cols  
75e9			;kbufc:	inc hl  
75e9			;	dec e  
75e9			;	jr nz, kbufc  
75e9			;	dec d  
75e9			;	jr nz, kbufr  
75e9			;  
75e9			;	; energise row and read columns  
75e9			;  
75e9			;	out (portbdata),a  
75e9			;	in a,(portbdata)  
75e9			;	ld c,a  
75e9			;  
75e9			;  
75e9			;	; save buffer loc  
75e9			;  
75e9			;	ld (keybufptr), hl  
75e9			;  
75e9			;	ld hl, key_scanc  
75e9			;	ld d, key_cols  
75e9			;  
75e9			;	; for each column check each bit mask  
75e9			;  
75e9			;colloop:  
75e9			;	  
75e9			;  
75e9			;	; reset flags for the row   
75e9			;  
75e9			;	ld b,'.'  
75e9			;	and (hl)  
75e9			;	jr z, maskskip  
75e9			;	ld b,'#'  
75e9			;maskskip:  
75e9			;	; save  key state  
75e9			;	push hl  
75e9			;	ld hl, (keybufptr)  
75e9			;	ld (hl), b  
75e9			;	inc hl  
75e9			;	ld (keybufptr), hl  
75e9			;  
75e9			;	; move to next bit mask  
75e9			;	pop hl  
75e9			;	inc hl  
75e9			;  
75e9			;	dec d  
75e9			;	jr nz, colloop  
75e9			;  
75e9			;	ret  
75e9			;  
75e9			;  
75e9			;;  
75e9			; lcd functions  
75e9			;  
75e9			;  
75e9			  
75e9			;if DEBUG_KEY_MATRIX  
75e9			  
75e9			; test function to display hardware view of matrix state  
75e9			  
75e9			matrixold:  
75e9			  
75e9			  
75e9			  
75e9			; reset counter  
75e9 3e 80		ld a, 128  
75eb d3 c1		out (portbdata),a  
75ed			; scan keyboard row 1  
75ed 3e 00		ld a, 0  
75ef d3 c1		out (portbdata),a  
75f1			;ld a, 64  
75f1			;out (portbdata),a  
75f1 3e 80			ld a, 128  
75f3 21 30 fe			ld hl, keyscan_table_row1  
75f6 cd 4f 76			call .rowscan  
75f9			  
75f9			;ld a, 0  
75f9			;out (portbdata),a  
75f9 3e 40		ld a, 64  
75fb d3 c1		out (portbdata),a  
75fd 3e 40			ld a, 64  
75ff 21 25 fe			ld hl, keyscan_table_row2  
7602 cd 4f 76			call .rowscan  
7605			  
7605 3e 00		ld a, 0  
7607 d3 c1		out (portbdata),a  
7609			;ld a, 64  
7609			;out (portbdata),a  
7609 3e 20			ld a, 32  
760b 21 1a fe			ld hl, keyscan_table_row3  
760e cd 4f 76			call .rowscan  
7611			  
7611			;ld a, 0  
7611			;out (portbdata),a  
7611 3e 40		ld a, 64  
7613 d3 c1		out (portbdata),a  
7615 3e 10			ld a, 16  
7617 21 0f fe			ld hl, keyscan_table_row4  
761a cd 4f 76			call .rowscan  
761d			  
761d			; Display text on first line  
761d 3e 00		            LD   A, kLCD_Line1  
761f cd 57 72		            CALL fLCD_Pos       ;Position cursor to location in A  
7622 11 30 fe		            LD   DE, keyscan_table_row1  
7625			            ;LD   DE, MsgHello  
7625 cd 79 72		            CALL fLCD_Str       ;Display string pointed to by DE  
7628			  
7628			; Display text on second line  
7628 3e 28		            LD   A, kLCD_Line2  
762a cd 57 72		            CALL fLCD_Pos       ;Position cursor to location in A  
762d 11 25 fe		            LD   DE, keyscan_table_row2  
7630 cd 79 72		            CALL fLCD_Str       ;Display string pointed to by DE  
7633 3e 50		            LD   A, kLCD_Line3  
7635 cd 57 72		            CALL fLCD_Pos       ;Position cursor to location in A  
7638 11 1a fe		            LD   DE, keyscan_table_row3  
763b cd 79 72		            CALL fLCD_Str       ;Display string pointed to by DE  
763e 3e 78		            LD   A, kLCD_Line4  
7640 cd 57 72		            CALL fLCD_Pos       ;Position cursor to location in A  
7643 11 0f fe		            LD   DE, keyscan_table_row4  
7646 cd 79 72		            CALL fLCD_Str       ;Display string pointed to by DE  
7649			  
7649 cd e1 0c			call delay250ms  
764c c3 3a 75			jp matrix  
764f			  
764f			; pass de as row display flags  
764f			.rowscan:   
764f			;	out (portbdata),a  
764f db c1			in a,(portbdata)  
7651 4f				ld c,a  
7652				; reset flags for the row   
7652 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7654 e6 01			and 1  
7656 28 02			jr z, .p1on  
7658 06 23			ld b,'#'  
765a			.p1on:  
765a 70				ld (hl), b  
765b 23				inc hl  
765c			  
765c 06 7e			ld b,KEY_MATRIX_NO_PRESS  
765e 79				ld a,c  
765f e6 02			and 2  
7661			;	bit 0,a  
7661 28 02			jr z, .p2on  
7663 06 23			ld b,'#'  
7665			.p2on:  
7665 70				ld (hl), b  
7666 23				inc hl  
7667			;  
7667 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7669 79				ld a,c  
766a e6 04			and 4  
766c			;;	bit 0,a  
766c 28 02			jr z, .p3on  
766e 06 23			ld b,'#'  
7670			.p3on:  
7670 70				ld (hl), b  
7671 23				inc hl  
7672			;;  
7672 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7674			;;	bit 0,a  
7674 79				ld a,c  
7675 e6 08			and 8  
7677 28 02			jr z, .p4on  
7679 06 23			ld b,'#'  
767b			.p4on:  
767b 70				ld (hl), b  
767c 23				inc hl  
767d			  
767d 06 7e			ld b,KEY_MATRIX_NO_PRESS  
767f			;;	bit 0,a  
767f 79				ld a,c  
7680 e6 10			and 16  
7682 28 02			jr z, .p5on  
7684 06 23			ld b,'#'  
7686			.p5on:  
7686 70				ld (hl), b  
7687 23				inc hl  
7688			; zero term  
7688 06 00			ld b,0  
768a 70				ld (hl), b  
768b			  
768b c9			.rscandone: ret  
768c			  
768c			;addatohl:  
768c			;  
768c			 ;add   a, l    ; A = A+L  
768c			  ;  ld    l, a    ; L = A+L  
768c			   ; adc   a, h    ; A = A+L+H+carry  
768c			   ; sub   l       ; A = H+carry  
768c			   ; ld    h, a    ; H = H+carry  
768c			  
768c			;ret  
768c			; eof  
# End of file firmware_key_5x10.asm
768c			;include "firmware_key_4x10.asm" 
768c			 
768c			heap_size:    equ heap_end - heap_start 
768c			;eof 
# End of file os_mega.asm
768c
